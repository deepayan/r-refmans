<!DOCTYPE html><html lang="en-US"><head><title>Help for package ICAMS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ICAMS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AddAndCheckDBSClassInVCF'><p>Add and check DBS class in an annotated VCF with the corresponding DBS</p>
mutation matrix</a></li>
<li><a href='#AddAndCheckSBSClassInVCF'><p>Add and check SBS class in an annotated VCF with the corresponding SBS</p>
mutation matrix</a></li>
<li><a href='#AddDBSClass'><p>Add DBS mutation class to an annotated DBS VCF</p></a></li>
<li><a href='#AddRunInformation'><p>Create a run information text file from generating zip archive from VCF</p>
files.</a></li>
<li><a href='#AddSBSClass'><p>Add SBS mutation class to an annotated SBS VCF</p></a></li>
<li><a href='#AddSeqContext'><p>Add sequence context to a data frame with mutation records</p></a></li>
<li><a href='#AddTranscript'><p>Add transcript information to a data frame with mutation records</p></a></li>
<li><a href='#all.abundance'><p>K-mer abundances</p></a></li>
<li><a href='#AnnotateDBSVCF'><p>Add sequence context and transcript information to an in-memory DBS VCF</p></a></li>
<li><a href='#AnnotateIDVCF'><p>Add sequence context to an in-memory ID (insertion/deletion) VCF, and</p>
confirm that they match the given reference genome</a></li>
<li><a href='#AnnotateSBSVCF'><p>Add sequence context and transcript information to an in-memory SBS VCF</p></a></li>
<li><a href='#as.catalog'><p>Create a catalog from a <code>matrix</code>, <code>data.frame</code>, or <code>vector</code></p></a></li>
<li><a href='#CalBaseCountsFrom3MerAbundance'><p>Calculate base counts from three mer abundance</p></a></li>
<li><a href='#CalculateNumberOfSpace'><p>Calculate the number of space needed to add strand bias statistics to</p>
the run-information.txt file.</a></li>
<li><a href='#Canonicalize1Del'><p>Given a deletion and its sequence context, categorize it</p></a></li>
<li><a href='#Canonicalize1ID'><p>Given a single insertion or deletion in context categorize it.</p></a></li>
<li><a href='#Canonicalize1INS'><p>Given an insertion and its sequence context, categorize it.</p></a></li>
<li><a href='#CanonicalizeID'><p>Determine the mutation types of insertions and deletions.</p></a></li>
<li><a href='#CatalogRowOrder'><p>Standard order of row names in a catalog</p></a></li>
<li><a href='#CheckAndFixChrNames'><p>Check and, if possible, correct the chromosome names in a VCF <code>data.frame</code>.</p></a></li>
<li><a href='#CheckAndFixChrNamesForTransRanges'><p>Check and, if possible, correct the chromosome names in a trans.ranges <code>data.table</code></p></a></li>
<li><a href='#CheckAndReorderRownames'><p>Check whether the rownames of <code>object</code> are correct, if yes then put the</p>
rows in the correct order.</a></li>
<li><a href='#CheckAndReturnDBSCatalogs'><p>Check and return DBS catalogs</p></a></li>
<li><a href='#CheckAndReturnDBSMatrix'><p>Check and return the DBS mutation matrix</p></a></li>
<li><a href='#CheckAndReturnIDCatalog'><p>Check and return ID catalog</p></a></li>
<li><a href='#CheckAndReturnIDMatrix'><p>Check and return the ID mutation matrix</p></a></li>
<li><a href='#CheckAndReturnSBSCatalogs'><p>Check and return SBS catalogs</p></a></li>
<li><a href='#CheckAndReturnSBSMatrix'><p>Check and return the SBS mutation matrix</p></a></li>
<li><a href='#CheckDBSClassInVCF'><p>Check DBS mutation class in VCF with the corresponding DBS mutation matrix</p></a></li>
<li><a href='#CheckSBSClassInVCF'><p>Check SBS mutation class in VCF with the corresponding SBS mutation matrix</p></a></li>
<li><a href='#CheckSeqContextInVCF'><p>Check that the sequence context information is consistent with the value of</p>
the column REF.</a></li>
<li><a href='#CollapseCatalog'><p>&quot;Collapse&quot; a catalog</p></a></li>
<li><a href='#ConvertICAMSCatalogToSigProSBS96'><p>Covert an ICAMS SBS96 Catalog to SigProfiler format</p></a></li>
<li><a href='#CreateDinucAbundance'><p>Create dinucleotide abundance</p></a></li>
<li><a href='#CreateExomeStrandedRanges'><p>Create exome transcriptionally stranded regions</p></a></li>
<li><a href='#CreateOneColDBSMatrix'><p>Create the matrix a DBS catalog for *one* sample from an in-memory VCF.</p></a></li>
<li><a href='#CreateOneColIDMatrix'><p>Create one column of the matrix for an indel catalog from *one* in-memory VCF.</p></a></li>
<li><a href='#CreateOneColSBSMatrix'><p>Create the matrix an SBS catalog for *one* sample from an in-memory VCF.</p></a></li>
<li><a href='#CreateOnePPMFromSBSVCF'><p>Create position probability matrix (PPM) for *one* sample from</p>
a Variant Call Format (VCF) file.</a></li>
<li><a href='#CreatePentanucAbundance'><p>Create pentanucleotide abundance</p></a></li>
<li><a href='#CreatePPMFromSBSVCFs'><p>Create position probability matrices (PPM) from a list of SBS vcfs</p></a></li>
<li><a href='#CreateStrandedDinucAbundance'><p>Create stranded dinucleotide abundance</p></a></li>
<li><a href='#CreateStrandedTrinucAbundance'><p>Create stranded trinucleotide abundance</p></a></li>
<li><a href='#CreateTetranucAbundance'><p>Create tetranucleotide abundance</p></a></li>
<li><a href='#CreateTransRanges'><p>Create a transcript range file from the raw GFF3 File</p></a></li>
<li><a href='#CreateTrinucAbundance'><p>Create trinucleotide abundance</p></a></li>
<li><a href='#FindDelMH'><p>Return the length of microhomology at a deletion</p></a></li>
<li><a href='#FindMaxRepeatDel'><p>Return the number of repeat units in which a deletion is embedded</p></a></li>
<li><a href='#FindMaxRepeatIns'><p>Return the number of repeat units in which an insertion</p>
is embedded.</a></li>
<li><a href='#GeneExpressionData'><p>Example gene expression data from two cell lines</p></a></li>
<li><a href='#GenerateEmptyKmerCounts'><p>Generate an empty matrix of k-mer abundance</p></a></li>
<li><a href='#GenerateKmer'><p>Generate all possible k-mers of length k.</p></a></li>
<li><a href='#GetConsensusVAF'><p>Analogous to <code>GetMutectVAF</code>, calculating VAF and read depth</p>
from PCAWG7 consensus vcfs</a></li>
<li><a href='#GetCustomKmerCounts'><p>Generate custom k-mer abundance from a given reference genome</p></a></li>
<li><a href='#GetGenomeKmerCounts'><p>Generate k-mer abundance from a given genome</p></a></li>
<li><a href='#GetMutationLoadsFromMutectVCFs'><p>Get mutation loads information from Mutect VCF files.</p></a></li>
<li><a href='#GetMutationLoadsFromStrelkaIDVCFs'><p>Get mutation loads information from Strelka ID VCF files.</p></a></li>
<li><a href='#GetMutationLoadsFromStrelkaSBSVCFs'><p>Get mutation loads information from Strelka SBS VCF files.</p></a></li>
<li><a href='#GetSequenceKmerCounts'><p>Generate k-mer abundance from given nucleotide sequences</p></a></li>
<li><a href='#GetStrandedKmerCounts'><p>Generate stranded k-mer abundance from a given genome and gene annotation file</p></a></li>
<li><a href='#GetVAF'><p>Extract the VAFs (variant allele frequencies) and read depth information from</p>
a VCF file</a></li>
<li><a href='#ICAMS'><p>ICAMS: In-depth Characterization and Analysis of Mutational Signatures</p></a></li>
<li><a href='#InferAbundance'><p>Infer <code>abundance</code> given a matrix-like <code>object</code> and additional information.</p></a></li>
<li><a href='#InferCatalogClassPrefix'><p>These two functions is applicable only for</p>
internal ICAMS-formatted catalog object.</a></li>
<li><a href='#InferCatalogInfo'><p>This function converts an data.table imported</p>
from external catalog text file into ICAMS
internal catalog object of appropriate type.</a></li>
<li><a href='#InferRownames'><p>Infer the correct rownames for a matrix based on its number of rows</p></a></li>
<li><a href='#IsGRCh37'><p>Test if object is <code>BSgenome.Hsapiens.1000genome.hs37d5</code>.</p></a></li>
<li><a href='#IsGRCh38'><p>Test if object is <code>BSgenome.Hsapiens.UCSC.hg38</code>.</p></a></li>
<li><a href='#IsGRCm38'><p>Test if object is <code>BSgenome.Mmusculus.UCSC.mm10</code>.</p></a></li>
<li><a href='#MakeDataFrameFromVCF'><p>Read in the data lines of a Variant Call Format (VCF) file</p></a></li>
<li><a href='#MakeVCFDBSdf'><p>MakeVCFDBSdf Take DBS ranges and the original VCF and generate a VCF with</p>
dinucleotide REF and ALT alleles.</a></li>
<li><a href='#MutectVCFFilesToCatalog'><p>Create SBS, DBS and Indel catalogs from Mutect VCF files</p></a></li>
<li><a href='#MutectVCFFilesToCatalogAndPlotToPdf'><p>Create SBS, DBS and Indel catalogs from Mutect VCF files and plot them to PDF</p></a></li>
<li><a href='#MutectVCFFilesToZipFile'><p>Create a zip file which contains catalogs and plot PDFs from Mutect VCF files</p></a></li>
<li><a href='#NormalizeGenomeArg'><p>Take strings representing a genome and return the <code>BSgenome</code> object.</p></a></li>
<li><a href='#Plot96PartOfCompositeToPDF'><p>Plot the SBS96 part of a SignatureAnalyzer COMPOSITE signature or catalog</p></a></li>
<li><a href='#PlotCatalog'><p>Plot <strong>one</strong> spectrum or signature</p></a></li>
<li><a href='#PlotCatalogToPdf'><p>Plot catalog to a PDF file</p></a></li>
<li><a href='#PlotPPM'><p>Plot position probability matrix (PPM) for *one* sample from a Variant Call Format</p>
(VCF) file.</a></li>
<li><a href='#PlotPPMToPdf'><p>Plot position probability matrices (PPM) to a PDF file</p></a></li>
<li><a href='#PlotTransBiasGeneExp'><p>Plot transcription strand bias with respect to gene expression values</p></a></li>
<li><a href='#PlotTransBiasGeneExpToPdf'><p>Plot transcription strand bias with respect to gene expression values to a</p>
PDF file</a></li>
<li><a href='#ReadAndSplitMutectVCFs'><p>Read and split Mutect VCF files</p></a></li>
<li><a href='#ReadAndSplitStrelkaSBSVCFs'><p>Read and split Strelka SBS VCF files</p></a></li>
<li><a href='#ReadAndSplitVCFs'><p>Read and split VCF files</p></a></li>
<li><a href='#ReadBedRanges'><p>Read chromosome and position information from a bed format file.</p></a></li>
<li><a href='#ReadCatalog'><p>Read catalog</p></a></li>
<li><a href='#ReadCatalogErrReturn'><p>Get error message and either stop or create a null error output for read catalog</p></a></li>
<li><a href='#ReadCatalogInternal'><p>Internal read catalog function to be wrapped in a tryCatch</p></a></li>
<li><a href='#ReadDukeNUSCat192'><p>Read a 192-channel spectra (or signature) catalog in Duke-NUS format</p></a></li>
<li><a href='#ReadMutectVCF'><p>Read in the data lines of a Variant Call Format (VCF) file created by Mutect</p></a></li>
<li><a href='#ReadMutectVCFs'><p>Read Mutect VCF files.</p></a></li>
<li><a href='#ReadStapleGT96SBS'><p>Read a 96-channel spectra (or signature) catalog where rownames are e.g. &quot;A[C&gt;A]T&quot;</p></a></li>
<li><a href='#ReadStrelkaIDVCF'><p>Read in the data lines of an ID VCF created by Strelka version 1</p></a></li>
<li><a href='#ReadStrelkaIDVCFs'><p>Read Strelka ID (small insertion and deletion) VCF files</p></a></li>
<li><a href='#ReadStrelkaSBSVCF'><p>Read in the data lines of an SBS VCF created by Strelka version 1</p></a></li>
<li><a href='#ReadStrelkaSBSVCFs'><p>Read Strelka SBS (single base substitutions) VCF files.</p></a></li>
<li><a href='#ReadTranscriptRanges'><p>Read transcript ranges and strand information from a gff3 format file.</p>
Use this one for the new, cut down gff3 file (2018 11 24)</a></li>
<li><a href='#ReadVCF'><p>Read in the data lines of a Variant Call Format (VCF) file</p></a></li>
<li><a href='#ReadVCFs'><p>Read VCF files</p></a></li>
<li><a href='#RemoveRangesOnBothStrand'><p>Remove ranges that fall on both strands</p></a></li>
<li><a href='#RenameColumnsWithNameStrand'><p>Is there any column in <code>df</code> with name &quot;strand&quot;?</p>
If there is, change its name to &quot;strand_old&quot; so that it will
conflict with code in other parts of ICAMS package.</a></li>
<li><a href='#RenameColumnsWithNameVAF'><p>Is there any column in df1 with name &quot;VAF&quot;?</p>
If there is, change its name to &quot;VAF_old&quot; so that it will
conflict with code in other parts of ICAMS package.</a></li>
<li><a href='#Restaple1536'><p>Convert 1536-channel mutation-type identifiers like this <code>"ACCGTA" -&gt; "AC[C&gt;A]GT"</code></p></a></li>
<li><a href='#Restaple96'><p>Convert 96-channel mutation-type identifiers like this <code>"ACTA" -&gt; "A[C&gt;A]T"</code></p></a></li>
<li><a href='#revc'><p>Reverse complement every string in <code>string.vec</code></p></a></li>
<li><a href='#RevcDBS144'><p>Reverse complement strings that represent stranded DBSs</p></a></li>
<li><a href='#RevcSBS96'><p>Reverse complement strings that represent stranded SBSs</p></a></li>
<li><a href='#SplitListOfMutectVCFs'><p>Split each Mutect VCF into SBS, DBS, and ID VCFs (plus</p>
VCF-like data frame with left-over rows)</a></li>
<li><a href='#SplitListOfStrelkaSBSVCFs'><p>Split a list of in-memory Strelka SBS VCF into SBS, DBS, and variants involving</p>
&gt; 2 consecutive bases</a></li>
<li><a href='#SplitListOfVCFs'><p>Split each VCF into SBS, DBS, and ID VCFs (plus</p>
VCF-like data frame with left-over rows)</a></li>
<li><a href='#SplitOneMutectVCF'><p>Split a mutect2 VCF into SBS, DBS, and ID VCFs, plus a list of other mutations</p></a></li>
<li><a href='#SplitOneVCF'><p>Split a VCF into SBS, DBS, and ID VCFs, plus a list of other mutations</p></a></li>
<li><a href='#SplitSBSVCF'><p>Split an in-memory SBS VCF into pure SBSs, pure DBSs, and variants involving</p>
&gt; 2 consecutive bases</a></li>
<li><a href='#SplitStrelkaSBSVCF'><p>Split an in-memory Strelka VCF into SBS, DBS, and variants involving</p>
&gt; 2 consecutive bases</a></li>
<li><a href='#StandardChromName'><p>Standardize the chromosome name annotations for a data frame.</p></a></li>
<li><a href='#StandardChromNameNew'><p>Standardize the chromosome name annotations for a data frame.</p></a></li>
<li><a href='#StopIfCatalogTypeIllegal'><p>Stop if <code>catalog.type</code> is illegal.</p></a></li>
<li><a href='#StopIfNrowIllegal'><p>Stop if the number of rows in <code>object</code> is illegal</p></a></li>
<li><a href='#StopIfRegionIllegal'><p>Stop if <code>region</code> is illegal.</p></a></li>
<li><a href='#StopIfTranscribedRegionIllegal'><p>Stop if <code>region</code> is illegal for an in-transcript catalogs</p></a></li>
<li><a href='#StrelkaIDVCFFilesToCatalog'><p>Create ID (small insertion and deletion) catalog from Strelka ID VCF files</p></a></li>
<li><a href='#StrelkaIDVCFFilesToCatalogAndPlotToPdf'><p>Create ID (small insertion and deletion) catalog from Strelka ID VCF files</p>
and plot them to PDF</a></li>
<li><a href='#StrelkaIDVCFFilesToZipFile'><p>Create a zip file which contains ID (small insertion and deletion) catalog</p>
and plot PDF from Strelka ID VCF files</a></li>
<li><a href='#StrelkaSBSVCFFilesToCatalog'><p>Create SBS and DBS catalogs from Strelka SBS VCF files</p></a></li>
<li><a href='#StrelkaSBSVCFFilesToCatalogAndPlotToPdf'><p>Create SBS and DBS catalogs from Strelka SBS VCF files and plot them to PDF</p></a></li>
<li><a href='#StrelkaSBSVCFFilesToZipFile'><p>Create a zip file which contains catalogs and plot PDFs from Strelka SBS VCF files</p></a></li>
<li><a href='#TCFromCouSigCou'><p>Source catalog type is counts or counts.signature</p></a></li>
<li><a href='#TCFromDenSigDen'><p>density -&gt; &lt;anything&gt;</p>
density.signature -&gt; density.signature, counts.signature</a></li>
<li><a href='#TestMakeCatalogFromMutectVCFs'><p>This function makes catalogs from the sample Mutect VCF file</p>
and compares it with the expected catalog information.</a></li>
<li><a href='#TestMakeCatalogFromStrelkaIDVCFs'><p>This function is to make catalogs from the sample Strelka ID VCF files</p>
to compare with the expected catalog information.</a></li>
<li><a href='#TestMakeCatalogFromStrelkaSBSVCFs'><p>This function is to make catalogs from the sample Strelka SBS VCF files</p>
to compare with the expected catalog information.</a></li>
<li><a href='#TestPlotCatCOMPOSITE'><p>Plot the a SignatureAnalyzer COMPOSITE signature or catalog into separate pdfs</p></a></li>
<li><a href='#TranscriptRanges'><p>Transcript ranges data</p></a></li>
<li><a href='#TransformCatalog'><p>Transform between counts and density spectrum catalogs</p>
and counts and density signature catalogs</a></li>
<li><a href='#TransRownames.ID.PCAWG.SigPro'><p>For indels, convert ICAMS/PCAWG7 rownames into SigProfiler rownames</p></a></li>
<li><a href='#TransRownames.ID.SigPro.PCAWG'><p>For indels, convert SigProfiler rownames into ICAMS/PCAWG7 rownames</p></a></li>
<li><a href='#Unstaple1536'><p>Convert SBS1536-channel mutations-type identifiers like this <code>"AC[C&gt;A]GT" -&gt; "ACCGTA"</code></p></a></li>
<li><a href='#Unstaple78'><p>Convert DBS78-channel mutations-type identifiers like this <code>"AC&gt;GA" -&gt; "ACGA"</code></p></a></li>
<li><a href='#Unstaple96'><p>Convert SBS96-channel mutations-type identifiers like this <code>"A[C&gt;A]T" -&gt; "ACTA"</code></p></a></li>
<li><a href='#VCFsToCatalogs'><p>Create SBS, DBS and Indel catalogs from VCFs</p></a></li>
<li><a href='#VCFsToCatalogsAndPlotToPdf'><p>Create SBS, DBS and Indel catalogs from VCFs and plot them to PDF</p></a></li>
<li><a href='#VCFsToDBSCatalogs'><p>Create DBS catalogs from VCFs</p></a></li>
<li><a href='#VCFsToIDCatalogs'><p>Create ID (small insertion and deletion) catalog from ID VCFs</p></a></li>
<li><a href='#VCFsToSBSCatalogs'><p>Create SBS catalogs from SBS VCFs</p></a></li>
<li><a href='#VCFsToZipFile'><p>Create a zip file which contains catalogs and plot PDFs from VCFs</p></a></li>
<li><a href='#VCFsToZipFileXtra'><p>Analogous to <code>VCFsToZipFile</code>, also generates density CSV and PDF files in the zip</p>
archive.</a></li>
<li><a href='#WriteCat'><p>Write a catalog to a file.</p></a></li>
<li><a href='#WriteCatalog'><p>Write a catalog</p></a></li>
<li><a href='#WriteCatalogIndelSigPro'><p>Write Indel Catalogs in SigProExtractor format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>In-Depth Characterization and Analysis of Mutational Signatures
('ICAMS')</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3.12</td>
</tr>
<tr>
<td>Author:</td>
<td>Steve Rozen, Nanhai Jiang, Arnoud Boot, Mo Liu, Yang Wu</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Steve Rozen &lt;steverozen@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Analysis and visualization of experimentally elucidated mutational
    signatures &ndash; the kind of analysis and visualization in Boot et al.,
    "In-depth characterization of the cisplatin mutational signature in 
    human cell lines and in esophageal and liver tumors", Genome Research 2018, 
    &lt;<a href="https://doi.org/10.1101%2Fgr.230219.117">doi:10.1101/gr.230219.117</a>&gt; and
    "Characterization of colibactin-associated mutational signature in an 
    Asian oral squamous cell carcinoma and in other mucosal tumor types",
    Genome Research 2020 &lt;<a href="https://doi.org/10.1101%2Fgr.255620.119">doi:10.1101/gr.255620.119</a>&gt;.
    'ICAMS' stands for In-depth Characterization 
    and Analysis of Mutational Signatures. 'ICAMS' has functions to read in 
    variant call files (VCFs) and to collate the corresponding catalogs of 
    mutational spectra and to analyze and plot catalogs of mutational spectra
    and signatures. Handles both "counts-based" and "density-based" (i.e.
    representation as mutations per megabase) mutational spectra or signatures.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/steverozen/ICAMS">https://github.com/steverozen/ICAMS</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/steverozen/ICAMS/issues">https://github.com/steverozen/ICAMS/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Imports:</td>
<td>Biostrings, BSgenome, data.table, dplyr, GenomeInfoDb,
GenomicRanges, graphics, grDevices, IRanges, RColorBrewer,
stats, stringi, utils, zip</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5),</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BSgenome.Hsapiens.1000genomes.hs37d5,
BSgenome.Hsapiens.UCSC.hg38, BSgenome.Mmusculus.UCSC.mm10,
testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-08 11:48:14 UTC; User</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-09 15:20:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='AddAndCheckDBSClassInVCF'>Add and check DBS class in an annotated VCF with the corresponding DBS
mutation matrix</h2><span id='topic+AddAndCheckDBSClassInVCF'></span>

<h3>Description</h3>

<p>Add and check DBS class in an annotated VCF with the corresponding DBS
mutation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddAndCheckDBSClassInVCF(vcf, mat78, mat136, mat144 = NULL, sample.id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AddAndCheckDBSClassInVCF_+3A_vcf">vcf</code></td>
<td>
<p>An in-memory VCF file annotated with sequence context and
transcript information by function <code><a href="#topic+AnnotateDBSVCF">AnnotateDBSVCF</a></code>. It must
*not* contain indels and must *not* contain SBS (single base
substitutions), or triplet base substitutions etc.</p>
</td></tr>
<tr><td><code id="AddAndCheckDBSClassInVCF_+3A_mat78">mat78</code></td>
<td>
<p>The DBS78 mutation count matrix.</p>
</td></tr>
<tr><td><code id="AddAndCheckDBSClassInVCF_+3A_mat136">mat136</code></td>
<td>
<p>The DBS136 mutation count matrix.</p>
</td></tr>
<tr><td><code id="AddAndCheckDBSClassInVCF_+3A_mat144">mat144</code></td>
<td>
<p>The DBS144 mutation count matrix.</p>
</td></tr>
<tr><td><code id="AddAndCheckDBSClassInVCF_+3A_sample.id">sample.id</code></td>
<td>
<p>Usually the sample id, but defaults to &quot;count&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original <code>vcf</code> with three additional columns
<code>DBS78.class</code>, <code>DBS136.class</code> and <code>DBS144.class</code> added.
</p>

<hr>
<h2 id='AddAndCheckSBSClassInVCF'>Add and check SBS class in an annotated VCF with the corresponding SBS
mutation matrix</h2><span id='topic+AddAndCheckSBSClassInVCF'></span>

<h3>Description</h3>

<p>Add and check SBS class in an annotated VCF with the corresponding SBS
mutation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddAndCheckSBSClassInVCF(vcf, mat96, mat1536, mat192 = NULL, sample.id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AddAndCheckSBSClassInVCF_+3A_vcf">vcf</code></td>
<td>
<p>An in-memory VCF file annotated with sequence context and
transcript information by function <code><a href="#topic+AnnotateSBSVCF">AnnotateSBSVCF</a></code>. It must
*not* contain indels and must *not* contain DBS (double base
substitutions), or triplet base substitutions etc., even if encoded as
neighboring SBS.</p>
</td></tr>
<tr><td><code id="AddAndCheckSBSClassInVCF_+3A_mat96">mat96</code></td>
<td>
<p>The SBS96 mutation count matrix.</p>
</td></tr>
<tr><td><code id="AddAndCheckSBSClassInVCF_+3A_mat1536">mat1536</code></td>
<td>
<p>The SBS1536 mutation count matrix.</p>
</td></tr>
<tr><td><code id="AddAndCheckSBSClassInVCF_+3A_mat192">mat192</code></td>
<td>
<p>The SBS192 mutation count matrix.</p>
</td></tr>
<tr><td><code id="AddAndCheckSBSClassInVCF_+3A_sample.id">sample.id</code></td>
<td>
<p>Usually the sample id, but defaults to &quot;count&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original <code>vcf</code> with three additional columns
<code>SBS96.class</code>, <code>SBS192.class</code> and <code>SBS1536.class</code> added.
</p>

<hr>
<h2 id='AddDBSClass'>Add DBS mutation class to an annotated DBS VCF</h2><span id='topic+AddDBSClass'></span>

<h3>Description</h3>

<p>Add DBS mutation class to an annotated DBS VCF
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddDBSClass(vcf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AddDBSClass_+3A_vcf">vcf</code></td>
<td>
<p>An in-memory VCF file annotated with sequence context and
transcript information by function <code><a href="#topic+AnnotateDBSVCF">AnnotateDBSVCF</a></code>. It must
*not* contain indels and must *not* contain SBS (single base
substitutions), or triplet base substitutions etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original <code>vcf</code> with three additional columns
<code>DBS78.class</code>, <code>DBS136.class</code> and <code>DBS144.class</code> added.
</p>

<hr>
<h2 id='AddRunInformation'>Create a run information text file from generating zip archive from VCF
files.</h2><span id='topic+AddRunInformation'></span>

<h3>Description</h3>

<p>Create a run information text file from generating zip archive from VCF
files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddRunInformation(
  files,
  vcf.names,
  zipfile.name,
  vcftype,
  ref.genome,
  region,
  mutation.loads,
  strand.bias.statistics,
  tmpdir
)
</code></pre>

<hr>
<h2 id='AddSBSClass'>Add SBS mutation class to an annotated SBS VCF</h2><span id='topic+AddSBSClass'></span>

<h3>Description</h3>

<p>Add SBS mutation class to an annotated SBS VCF
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddSBSClass(vcf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AddSBSClass_+3A_vcf">vcf</code></td>
<td>
<p>An in-memory VCF file annotated with sequence context and
transcript information by function <code><a href="#topic+AnnotateSBSVCF">AnnotateSBSVCF</a></code>. It must
*not* contain indels and must *not* contain DBS (double base
substitutions), or triplet base substitutions etc., even if encoded as
neighboring SBS.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original <code>vcf</code> with three additional columns
<code>SBS96.class</code>, <code>SBS192.class</code> and <code>SBS1536.class</code> added.
</p>

<hr>
<h2 id='AddSeqContext'>Add sequence context to a data frame with mutation records</h2><span id='topic+AddSeqContext'></span>

<h3>Description</h3>

<p>Add sequence context to a data frame with mutation records
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddSeqContext(df, ref.genome, seq.context.width = 10, name.of.VCF = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AddSeqContext_+3A_df">df</code></td>
<td>
<p>An input data frame storing mutation records of a VCF file.</p>
</td></tr>
<tr><td><code id="AddSeqContext_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="AddSeqContext_+3A_seq.context.width">seq.context.width</code></td>
<td>
<p>The number of preceding and following bases to be
extracted around the mutated position from <code>ref.genome</code>. The default value is 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of the input data.frame with a new column added
that contains sequence context information.
</p>

<hr>
<h2 id='AddTranscript'>Add transcript information to a data frame with mutation records</h2><span id='topic+AddTranscript'></span>

<h3>Description</h3>

<p>Add transcript information to a data frame with mutation records
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddTranscript(df, trans.ranges = NULL, ref.genome, name.of.VCF = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AddTranscript_+3A_df">df</code></td>
<td>
<p>A data frame storing mutation records of a VCF file.</p>
</td></tr>
<tr><td><code id="AddTranscript_+3A_trans.ranges">trans.ranges</code></td>
<td>
<p>A <code><a href="data.table.html#topic+data.table">data.table</a></code> which contains
transcript range and strand information. Please refer to
<code><a href="#topic+TranscriptRanges">TranscriptRanges</a></code> for more details.</p>
</td></tr>
<tr><td><code id="AddTranscript_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="AddTranscript_+3A_name.of.vcf">name.of.VCF</code></td>
<td>
<p>Name of the VCF file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with new columns added to the input data frame,
which contain the mutated gene's name, range and strand information.
</p>

<hr>
<h2 id='all.abundance'>K-mer abundances</h2><span id='topic+all.abundance'></span>

<h3>Description</h3>

<p>An R list with one element each for 
<code>BSgenome.Hsapiens.1000genomes.hs37d5</code>, <br />
<code>BSgenome.Hsapiens.UCSC.hg38</code> and <code>BSgenome.Mmusculus.UCSC.mm10</code>.
Each element is in turn a sub-list keyed by 
<code>exome</code>, <code>transcript</code>, 
and <code>genome</code>. Each element of the sub list
is keyed by the number of rows in the catalog class (as a string, e.g. 
<code>"78"</code>, not <code>78</code>). The keys are:
78 (<code>DBS78Catalog</code>), 96 (<code>SBS96Catalog</code>), 136 (<code>DBS136Catalog</code>),
144 (<code>DBS144Catalog</code>), 192 (<code>SBS192Catalog</code>),
and 1536 (<code>SBS1536Catalog</code>). So, for example to get the exome
abundances for SBS96 catalogs for <code>BSgenome.Hsapiens.UCSC.hg38</code> exomes
one would reference <br />
<code>all.abundance[["BSgenome.Hsapiens.UCSC.hg38"]][["exome"]][["96"]]</code> <br />
or <code>all.abundance$BSgenome.Hsapiens.UCSC.hg38$exome$"96"</code>.
The value of the abundance is an integer vector with the K-mers
as names and each value being the count of that K-mer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all.abundance
</code></pre>


<h3>Format</h3>

<p>See Description.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>all.abundance$BSgenome.Hsapiens.UCSC.hg38$transcript$`144` 
#        AA        AC        AG        AT        CA        CC ... 
#  90769160  57156295  85738416  87552737  83479655  63267896 ...
# There are 90769160 AAs on the sense strands of transcripts in
# this genome.
</code></pre>

<hr>
<h2 id='AnnotateDBSVCF'>Add sequence context and transcript information to an in-memory DBS VCF</h2><span id='topic+AnnotateDBSVCF'></span>

<h3>Description</h3>

<p>Add sequence context and transcript information to an in-memory DBS VCF
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AnnotateDBSVCF(DBS.vcf, ref.genome, trans.ranges = NULL, name.of.VCF = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AnnotateDBSVCF_+3A_dbs.vcf">DBS.vcf</code></td>
<td>
<p>An in-memory DBS VCF as a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="AnnotateDBSVCF_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="AnnotateDBSVCF_+3A_trans.ranges">trans.ranges</code></td>
<td>
<p>Optional. If <code>ref.genome</code> specifies one of the
<code>BSgenome</code> object
</p>

<ol>
<li> <p><code>BSgenome.Hsapiens.1000genomes.hs37d5</code>
</p>
</li>
<li> <p><code>BSgenome.Hsapiens.UCSC.hg38</code>
</p>
</li>
<li> <p><code>BSgenome.Mmusculus.UCSC.mm10</code>
</p>
</li></ol>

<p>then the function will infer <code>trans.ranges</code> automatically. Otherwise,
user will need to provide the necessary <code>trans.ranges</code>. Please refer to
<code><a href="#topic+TranscriptRanges">TranscriptRanges</a></code> for more details.
If <code>is.null(trans.ranges)</code> do not add transcript range
information.</p>
</td></tr>
<tr><td><code id="AnnotateDBSVCF_+3A_name.of.vcf">name.of.VCF</code></td>
<td>
<p>Name of the VCF file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An in-memory DBS VCF as a <code>data.table</code>. This has been annotated
with the sequence context (column name <code>seq.21bases</code>) and with
transcript information in the form of a gene symbol (e.g. <code>"TP53"</code>)
and transcript strand. This information is in the columns
<code>trans.start.pos</code>, <code>trans.end.pos</code> , <code>trans.strand</code>,
<code>trans.Ensembl.gene.ID</code> and <code>trans.gene.symbol</code> in the output.
These columns are not added if <code>is.null(trans.ranges)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- c(system.file("extdata/Strelka-SBS-vcf",
                      "Strelka.SBS.GRCh37.s1.vcf",
                      package = "ICAMS"))
list.of.vcfs &lt;- ReadAndSplitStrelkaSBSVCFs(file)
DBS.vcf &lt;- list.of.vcfs$DBS.vcfs[[1]]
if (requireNamespace("BSgenome.Hsapiens.1000genomes.hs37d5", quietly = TRUE)) {
  annotated.DBS.vcf &lt;- AnnotateDBSVCF(DBS.vcf, ref.genome = "hg19",
                                      trans.ranges = trans.ranges.GRCh37)}
</code></pre>

<hr>
<h2 id='AnnotateIDVCF'>Add sequence context to an in-memory ID (insertion/deletion) VCF, and
confirm that they match the given reference genome</h2><span id='topic+AnnotateIDVCF'></span>

<h3>Description</h3>

<p>Add sequence context to an in-memory ID (insertion/deletion) VCF, and
confirm that they match the given reference genome
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AnnotateIDVCF(
  ID.vcf,
  ref.genome,
  flag.mismatches = 0,
  name.of.VCF = NULL,
  suppress.discarded.variants.warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AnnotateIDVCF_+3A_id.vcf">ID.vcf</code></td>
<td>
<p>An in-memory ID (insertion/deletion) VCF as a
<code>data.frame</code>. This function expects that there is a &quot;context base&quot; to
the left, for example REF = ACG, ALT = A (deletion of CG) or REF = A, ALT =
ACC (insertion of CC).</p>
</td></tr>
<tr><td><code id="AnnotateIDVCF_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="AnnotateIDVCF_+3A_flag.mismatches">flag.mismatches</code></td>
<td>
<p>Deprecated. If there are ID variants whose <code>REF</code>
do not match the extracted sequence from <code>ref.genome</code>, the function
will automatically discard these variants. See element
<code>discarded.variants</code> in the return value for more details.</p>
</td></tr>
<tr><td><code id="AnnotateIDVCF_+3A_name.of.vcf">name.of.VCF</code></td>
<td>
<p>Name of the VCF file.</p>
</td></tr>
<tr><td><code id="AnnotateIDVCF_+3A_suppress.discarded.variants.warnings">suppress.discarded.variants.warnings</code></td>
<td>
<p>Logical. Whether to suppress
warning messages showing information about the discarded variants. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of elements:
</p>

<ul>
<li> <p><code>annotated.vcf</code>: The original VCF data
frame with two new columns added to the input data frame:
</p>

<ul>
<li> <p><code>seq.context</code>: The sequence embedding the variant.
</p>
</li>
<li> <p><code>seq.context.width</code>: The width of <code>seq.context</code> to the left.
</p>
</li></ul>

</li>
<li> <p><code>discarded.variants</code>: <strong>Non-NULL only if</strong> there are variants
that were excluded from the analysis. See the added extra column
<code>discarded.reason</code> for more details.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- c(system.file("extdata/Strelka-ID-vcf/",
                      "Strelka.ID.GRCh37.s1.vcf",
                      package = "ICAMS"))
ID.vcf &lt;- ReadStrelkaIDVCFs(file)[[1]]
if (requireNamespace("BSgenome.Hsapiens.1000genomes.hs37d5", quietly = TRUE)) {
  list &lt;- AnnotateIDVCF(ID.vcf, ref.genome = "hg19")
  annotated.ID.vcf &lt;- list$annotated.vcf}
</code></pre>

<hr>
<h2 id='AnnotateSBSVCF'>Add sequence context and transcript information to an in-memory SBS VCF</h2><span id='topic+AnnotateSBSVCF'></span>

<h3>Description</h3>

<p>Add sequence context and transcript information to an in-memory SBS VCF
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AnnotateSBSVCF(SBS.vcf, ref.genome, trans.ranges = NULL, name.of.VCF = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AnnotateSBSVCF_+3A_sbs.vcf">SBS.vcf</code></td>
<td>
<p>An in-memory SBS VCF as a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="AnnotateSBSVCF_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="AnnotateSBSVCF_+3A_trans.ranges">trans.ranges</code></td>
<td>
<p>Optional. If <code>ref.genome</code> specifies one of the
<code>BSgenome</code> object
</p>

<ol>
<li> <p><code>BSgenome.Hsapiens.1000genomes.hs37d5</code>
</p>
</li>
<li> <p><code>BSgenome.Hsapiens.UCSC.hg38</code>
</p>
</li>
<li> <p><code>BSgenome.Mmusculus.UCSC.mm10</code>
</p>
</li></ol>

<p>then the function will infer <code>trans.ranges</code> automatically. Otherwise,
user will need to provide the necessary <code>trans.ranges</code>. Please refer to
<code><a href="#topic+TranscriptRanges">TranscriptRanges</a></code> for more details.
If <code>is.null(trans.ranges)</code> do not add transcript range
information.</p>
</td></tr>
<tr><td><code id="AnnotateSBSVCF_+3A_name.of.vcf">name.of.VCF</code></td>
<td>
<p>Name of the VCF file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An in-memory SBS VCF as a <code>data.table</code>. This has been annotated
with the sequence context (column name <code>seq.21bases</code>) and with
transcript information in the form of a gene symbol (e.g. <code>"TP53"</code>)
and transcript strand. This information is in the columns
<code>trans.start.pos</code>, <code>trans.end.pos</code> , <code>trans.strand</code>,
<code>trans.Ensembl.gene.ID</code> and <code>trans.gene.symbol</code> in the output.
These columns are not added if <code>is.null(trans.ranges)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- c(system.file("extdata/Strelka-SBS-vcf",
                      "Strelka.SBS.GRCh37.s1.vcf",
                      package = "ICAMS"))
list.of.vcfs &lt;- ReadAndSplitStrelkaSBSVCFs(file)
SBS.vcf &lt;- list.of.vcfs$SBS.vcfs[[1]]
if (requireNamespace("BSgenome.Hsapiens.1000genomes.hs37d5", quietly = TRUE)) {
  annotated.SBS.vcf &lt;- AnnotateSBSVCF(SBS.vcf, ref.genome = "hg19",
                                      trans.ranges = trans.ranges.GRCh37)}
</code></pre>

<hr>
<h2 id='as.catalog'>Create a catalog from a <code>matrix</code>, <code>data.frame</code>, or <code>vector</code></h2><span id='topic+as.catalog'></span>

<h3>Description</h3>

<p>Create a catalog from a <code>matrix</code>, <code>data.frame</code>, or <code>vector</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.catalog(
  object,
  ref.genome = NULL,
  region = "unknown",
  catalog.type = "counts",
  abundance = NULL,
  infer.rownames = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.catalog_+3A_object">object</code></td>
<td>
<p>A numeric <code>matrix</code>, numeric <code>data.frame</code>,
or <code>vector</code>.
If a <code>vector</code>, converted to a 1-column <code>matrix</code>
with rownames taken from the element names of the <code>vector</code>
and with column name <code>"Unknown"</code>.
If argument <code>infer.rownames</code>
is <code>FALSE</code> then this argument must have
rownames to denote the mutation types. See <code><a href="#topic+CatalogRowOrder">CatalogRowOrder</a></code>
for more details.</p>
</td></tr>
<tr><td><code id="as.catalog_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="as.catalog_+3A_region">region</code></td>
<td>
<p>A character string designating a region, one of
<code>genome</code>, <code>transcript</code>, <code>exome</code>, <code>unknown</code>;
see <code><a href="#topic+ICAMS">ICAMS</a></code>. If the catalog type is a stranded
catalog type (SBS192 or DBS144), region = &quot;genome&quot; will
be silently converted to &quot;transcript&quot;.</p>
</td></tr>
<tr><td><code id="as.catalog_+3A_catalog.type">catalog.type</code></td>
<td>
<p>One of &quot;counts&quot;, &quot;density&quot;, &quot;counts.signature&quot;,
&quot;density.signature&quot;.</p>
</td></tr>
<tr><td><code id="as.catalog_+3A_abundance">abundance</code></td>
<td>
<p>If <code>NULL</code>, then
inferred if <code>ref.genome</code>
is one of
the reference genomes known to ICAMS and <code>region</code>
is not <code>unknown</code>. See <code><a href="#topic+ICAMS">ICAMS</a></code>.
The argument <code>abundance</code> should
contain the counts of different source sequences for mutations
in the same format as the numeric vectors in <code><a href="#topic+all.abundance">all.abundance</a></code>.</p>
</td></tr>
<tr><td><code id="as.catalog_+3A_infer.rownames">infer.rownames</code></td>
<td>
<p>If <code>TRUE</code>, and <code>object</code> has no
rownames, then assume the rows of <code>object</code> are in the
correct order and add the rownames implied by the number of rows
in <code>object</code> (e.g. rownames for SBS 192 if there are 192 rows).
If <code>TRUE</code>, <strong>be sure the order of rows is correct.</strong></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A catalog as described in <code><a href="#topic+ICAMS">ICAMS</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an SBS96 catalog with all mutation counts equal to 1.  
object &lt;- matrix(1, nrow = 96, ncol = 1, 
                 dimnames = list(catalog.row.order$SBS96))
catSBS96 &lt;- as.catalog(object)
</code></pre>

<hr>
<h2 id='CalBaseCountsFrom3MerAbundance'>Calculate base counts from three mer abundance</h2><span id='topic+CalBaseCountsFrom3MerAbundance'></span>

<h3>Description</h3>

<p>Calculate base counts from three mer abundance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalBaseCountsFrom3MerAbundance(three.mer.abundance)
</code></pre>

<hr>
<h2 id='CalculateNumberOfSpace'>Calculate the number of space needed to add strand bias statistics to
the run-information.txt file.</h2><span id='topic+CalculateNumberOfSpace'></span>

<h3>Description</h3>

<p>Calculate the number of space needed to add strand bias statistics to
the run-information.txt file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateNumberOfSpace(list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalculateNumberOfSpace_+3A_list">list</code></td>
<td>
<p>A list containing strand bias statistics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the space information.
</p>

<hr>
<h2 id='Canonicalize1Del'>Given a deletion and its sequence context, categorize it</h2><span id='topic+Canonicalize1Del'></span>

<h3>Description</h3>

<p>This function is primarily for internal use, but we export it
to document the underlying logic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Canonicalize1Del(context, del.seq, pos, trace = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Canonicalize1Del_+3A_context">context</code></td>
<td>
<p>The deleted sequence plus ample surrounding
sequence on each side (at least as long as <code>del.seq</code>).</p>
</td></tr>
<tr><td><code id="Canonicalize1Del_+3A_del.seq">del.seq</code></td>
<td>
<p>The deleted sequence in <code>context</code>.</p>
</td></tr>
<tr><td><code id="Canonicalize1Del_+3A_pos">pos</code></td>
<td>
<p>The position of <code>del.sequence</code> in <code>context</code>.</p>
</td></tr>
<tr><td><code id="Canonicalize1Del_+3A_trace">trace</code></td>
<td>
<p>If &gt; 0, then generate messages tracing
how the computation is carried out.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx">https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx</a>
for additional information on deletion mutation classification.
</p>
<p>This function first handles deletions in homopolymers, then
handles deletions in simple repeats with
longer repeat units, (e.g. <code>CACACACA</code>, see
<code><a href="#topic+FindMaxRepeatDel">FindMaxRepeatDel</a></code>),
and if the deletion is not in a simple repeat,
looks for microhomology (see <code><a href="#topic+FindDelMH">FindDelMH</a></code>).
</p>
<p>See the code for unexported function <code><a href="#topic+CanonicalizeID">CanonicalizeID</a></code>
and the functions it calls for handling of insertions.
</p>


<h3>Value</h3>

<p>A string that is the canonical representation
of the given deletion type. Return <code>NA</code> 
and raise a warning if
there is an un-normalized representation of
the deletion of a repeat unit.
See <code>FindDelMH</code> for details.
(This seems to be very rare.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Canonicalize1Del("xyAAAqr", del.seq = "A", pos = 3) # "DEL:T:1:2"
Canonicalize1Del("xyAAAqr", del.seq = "A", pos = 4) # "DEL:T:1:2"
Canonicalize1Del("xyAqr", del.seq = "A", pos = 3)   # "DEL:T:1:0"

</code></pre>

<hr>
<h2 id='Canonicalize1ID'>Given a single insertion or deletion in context categorize it.</h2><span id='topic+Canonicalize1ID'></span>

<h3>Description</h3>

<p>Given a single insertion or deletion in context categorize it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Canonicalize1ID(context, ref, alt, pos, trace = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Canonicalize1ID_+3A_context">context</code></td>
<td>
<p>Ample surrounding
sequence on each side of the insertion or deletion.</p>
</td></tr>
<tr><td><code id="Canonicalize1ID_+3A_ref">ref</code></td>
<td>
<p>The reference allele (vector of length 1)</p>
</td></tr>
<tr><td><code id="Canonicalize1ID_+3A_alt">alt</code></td>
<td>
<p>The alternative allele (vector of length 1)</p>
</td></tr>
<tr><td><code id="Canonicalize1ID_+3A_pos">pos</code></td>
<td>
<p>The position of <code>ins.or.del.seq</code> in <code>context</code>.</p>
</td></tr>
<tr><td><code id="Canonicalize1ID_+3A_trace">trace</code></td>
<td>
<p>If &gt; 0, then generate messages tracing
how the computation is carried out.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string that is the canonical representation
of the type of the given
insertion or deletion.
Return <code>NA</code> 
and raise a warning if
there is an un-normalized representation of
the deletion of a repeat unit.
See <code>FindDelMH</code> for details.
(This seems to be very rare.)
</p>

<hr>
<h2 id='Canonicalize1INS'>Given an insertion and its sequence context, categorize it.</h2><span id='topic+Canonicalize1INS'></span>

<h3>Description</h3>

<p>Given an insertion and its sequence context, categorize it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Canonicalize1INS(context, ins.sequence, pos, trace = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Canonicalize1INS_+3A_context">context</code></td>
<td>
<p>The deleted sequence plus ample surrounding
sequence on each side (at least as long as <code>ins.sequence</code> * 6).</p>
</td></tr>
<tr><td><code id="Canonicalize1INS_+3A_ins.sequence">ins.sequence</code></td>
<td>
<p>The deleted sequence in <code>context</code>.</p>
</td></tr>
<tr><td><code id="Canonicalize1INS_+3A_pos">pos</code></td>
<td>
<p>The position of <code>ins.sequence</code> in <code>context</code>.</p>
</td></tr>
<tr><td><code id="Canonicalize1INS_+3A_trace">trace</code></td>
<td>
<p>If &gt; 0, then generate
messages tracing how the computation is carried out.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string that is the canonical representation of 
the given insertion type.
</p>

<hr>
<h2 id='CanonicalizeID'>Determine the mutation types of insertions and deletions.</h2><span id='topic+CanonicalizeID'></span>

<h3>Description</h3>

<p>Determine the mutation types of insertions and deletions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CanonicalizeID(context, ref, alt, pos)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CanonicalizeID_+3A_context">context</code></td>
<td>
<p>A vector of ample surrounding
sequence on each side the variants</p>
</td></tr>
<tr><td><code id="CanonicalizeID_+3A_ref">ref</code></td>
<td>
<p>Vector of reference alleles</p>
</td></tr>
<tr><td><code id="CanonicalizeID_+3A_alt">alt</code></td>
<td>
<p>Vector of alternative alleles</p>
</td></tr>
<tr><td><code id="CanonicalizeID_+3A_pos">pos</code></td>
<td>
<p>Vector of the positions of the insertions and deletions in
<code>context</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of strings that are the canonical representations
of the given insertions and deletions.
</p>

<hr>
<h2 id='CatalogRowOrder'>Standard order of row names in a catalog</h2><span id='topic+CatalogRowOrder'></span><span id='topic+catalog.row.order'></span>

<h3>Description</h3>

<p>This data is designed for those
who need to create their own catalogs from formats not
supported by this package. The rownames denote the mutation
types.  For example, for SBS96 catalogs, the rowname
AGAT represents a mutation from AGA &gt; ATA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catalog.row.order
</code></pre>


<h3>Format</h3>

<p>A list of character vectors indicating the standard
orders of row names in catalogs.
</p>
<p>An object of class <code>list</code> of length 8.
</p>


<h3>ID classification</h3>

<p>See <a href="https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx">https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx</a>
for additional information on ID (small insertion and deletion) mutation
classification.
</p>
<p>See the documentation for <code><a href="#topic+Canonicalize1Del">Canonicalize1Del</a></code> which first handles
deletions in homopolymers, then handles deletions in simple repeats with
longer repeat units, (e.g. <code>CACACACA</code>, see
<code><a href="#topic+FindMaxRepeatDel">FindMaxRepeatDel</a></code>), and if the deletion is not in a simple
repeat, looks for microhomology (see <code><a href="#topic+FindDelMH">FindDelMH</a></code>).
</p>
<p>See the code for unexported function <code><a href="#topic+CanonicalizeID">CanonicalizeID</a></code>
and the functions it calls for handling of insertions.
</p>


<h3>Note</h3>

<p>In ID (small insertion and deletion) catalogs, deletion repeat sizes
range from 0 to 5+, but for plotting and end-user documentation deletion
repeat sizes range from 1 to 6+. In ID83 catalogs, deletion repeat sizes
range from 0 to 5.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>catalog.row.order$SBS96
# "ACAA" "ACCA" "ACGA" "ACTA" "CCAA" "CCCA" "CCGA" "CCTA" ...
# There are altogether 96 row names to denote the mutation types
# in SBS96 catalog.
</code></pre>

<hr>
<h2 id='CheckAndFixChrNames'>Check and, if possible, correct the chromosome names in a VCF <code>data.frame</code>.</h2><span id='topic+CheckAndFixChrNames'></span>

<h3>Description</h3>

<p>Check and, if possible, correct the chromosome names in a VCF <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckAndFixChrNames(vcf.df, ref.genome, name.of.VCF = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CheckAndFixChrNames_+3A_vcf.df">vcf.df</code></td>
<td>
<p>A VCF as a <code>data.frame</code>. Check the names in column
<code>CHROM</code>.</p>
</td></tr>
<tr><td><code id="CheckAndFixChrNames_+3A_ref.genome">ref.genome</code></td>
<td>
<p>The reference genome with the chromosome names to check
<code>vcf.df$CHROM</code> against; must be a Bioconductor
<code>BSgenome</code>, e.g.
<code>BSgenome.Hsapiens.UCSC.hg38</code>.</p>
</td></tr>
<tr><td><code id="CheckAndFixChrNames_+3A_name.of.vcf">name.of.VCF</code></td>
<td>
<p>Name of the VCF file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the <code>vcf.df$CHROM</code> values are correct or
can be corrected, then a vector of chromosome names
that can be used as a replacement for <code>vcf.df$CHROM</code>.
If the names in <code>vcf.df$CHROM</code> cannot be made to
be consistent with the chromosome names in <code>ref.genome</code>,
then <code>stop</code>.
</p>

<hr>
<h2 id='CheckAndFixChrNamesForTransRanges'>Check and, if possible, correct the chromosome names in a trans.ranges <code>data.table</code></h2><span id='topic+CheckAndFixChrNamesForTransRanges'></span>

<h3>Description</h3>

<p>Check and, if possible, correct the chromosome names in a trans.ranges <code>data.table</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckAndFixChrNamesForTransRanges(
  trans.ranges,
  vcf.df,
  ref.genome,
  name.of.VCF = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CheckAndFixChrNamesForTransRanges_+3A_trans.ranges">trans.ranges</code></td>
<td>
<p>A <code><a href="data.table.html#topic+data.table">data.table</a></code> which contains
transcript range and strand information. Please refer to
<code><a href="#topic+TranscriptRanges">TranscriptRanges</a></code> for more details.</p>
</td></tr>
<tr><td><code id="CheckAndFixChrNamesForTransRanges_+3A_vcf.df">vcf.df</code></td>
<td>
<p>A VCF as a <code>data.frame</code>. Check the names in column
<code>CHROM</code>.</p>
</td></tr>
<tr><td><code id="CheckAndFixChrNamesForTransRanges_+3A_ref.genome">ref.genome</code></td>
<td>
<p>The reference genome with the chromosome names to check
<code>vcf.df$CHROM</code> against; must be a Bioconductor
<code>BSgenome</code>, e.g.
<code>BSgenome.Hsapiens.UCSC.hg38</code>.</p>
</td></tr>
<tr><td><code id="CheckAndFixChrNamesForTransRanges_+3A_name.of.vcf">name.of.VCF</code></td>
<td>
<p>Name of the VCF file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the <code>vcf.df$CHROM</code> values are correct or can be corrected,
then a vector of chromosome names that can be used as a replacement for
<code>trans.ranges$chrom</code>. If the names in <code>vcf.df$CHROM</code> cannot be
made to be consistent with the chromosome names in
<code>trans.ranges$chrom</code>, then <code>stop</code>.
</p>

<hr>
<h2 id='CheckAndReorderRownames'>Check whether the rownames of <code>object</code> are correct, if yes then put the
rows in the correct order.</h2><span id='topic+CheckAndReorderRownames'></span>

<h3>Description</h3>

<p>Check whether the rownames of <code>object</code> are correct, if yes then put the
rows in the correct order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckAndReorderRownames(object)
</code></pre>

<hr>
<h2 id='CheckAndReturnDBSCatalogs'>Check and return DBS catalogs</h2><span id='topic+CheckAndReturnDBSCatalogs'></span>

<h3>Description</h3>

<p>Check and return DBS catalogs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckAndReturnDBSCatalogs(
  catDBS78,
  catDBS136,
  catDBS144 = NULL,
  discarded.variants,
  annotated.vcfs
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CheckAndReturnDBSCatalogs_+3A_catdbs78">catDBS78</code></td>
<td>
<p>An DBS78 catalog.</p>
</td></tr>
<tr><td><code id="CheckAndReturnDBSCatalogs_+3A_catdbs136">catDBS136</code></td>
<td>
<p>An DBS136 catalog.</p>
</td></tr>
<tr><td><code id="CheckAndReturnDBSCatalogs_+3A_catdbs144">catDBS144</code></td>
<td>
<p>An DBS144 catalog.</p>
</td></tr>
<tr><td><code id="CheckAndReturnDBSCatalogs_+3A_discarded.variants">discarded.variants</code></td>
<td>
<p>A list of discarded variants.</p>
</td></tr>
<tr><td><code id="CheckAndReturnDBSCatalogs_+3A_annotated.vcfs">annotated.vcfs</code></td>
<td>
<p>A list of annotated VCFs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of DBS catalogs. Also return the discarded variants and
annotated VCFs if they exit.
</p>

<hr>
<h2 id='CheckAndReturnDBSMatrix'>Check and return the DBS mutation matrix</h2><span id='topic+CheckAndReturnDBSMatrix'></span>

<h3>Description</h3>

<p>Check and return the DBS mutation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckAndReturnDBSMatrix(
  vcf,
  discarded.variants,
  mat78,
  mat136,
  mat144 = NULL,
  return.annotated.vcf = FALSE,
  sample.id = "counts"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CheckAndReturnDBSMatrix_+3A_vcf">vcf</code></td>
<td>
<p>An in-memory VCF file annotated with sequence context and
transcript information by function <code><a href="#topic+AnnotateDBSVCF">AnnotateDBSVCF</a></code>. It must
*not* contain indels and must *not* contain SBS (single base
substitutions), or triplet base substitutions etc.</p>
</td></tr>
<tr><td><code id="CheckAndReturnDBSMatrix_+3A_discarded.variants">discarded.variants</code></td>
<td>
<p>A <code>data.frame</code> which contains rows of DBS
variants whose tetranucleotide context contains &quot;N&quot;.</p>
</td></tr>
<tr><td><code id="CheckAndReturnDBSMatrix_+3A_mat78">mat78</code></td>
<td>
<p>The DBS78 mutation count matrix.</p>
</td></tr>
<tr><td><code id="CheckAndReturnDBSMatrix_+3A_mat136">mat136</code></td>
<td>
<p>The DBS136 mutation count matrix.</p>
</td></tr>
<tr><td><code id="CheckAndReturnDBSMatrix_+3A_mat144">mat144</code></td>
<td>
<p>The DBS144 mutation count matrix.</p>
</td></tr>
<tr><td><code id="CheckAndReturnDBSMatrix_+3A_return.annotated.vcf">return.annotated.vcf</code></td>
<td>
<p>Whether to return the annotated VCF with
additional columns showing the mutation class for each variant. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="CheckAndReturnDBSMatrix_+3A_sample.id">sample.id</code></td>
<td>
<p>Usually the sample id, but defaults to &quot;count&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three 1-column matrices with the names <code>catDBS78</code>,
<code>catDBS136</code>, and <code>catDBS144</code>. If trans.ranges is NULL,
<code>catDBS144</code> is not generated. Do not rely on the order of elements in
the list. If <code>return.annotated.vcf</code> = TRUE, another element
<code>annotated.vcf</code> will appear in the list. If there are DBS variants
whose tetranucleotide context contains &quot;N&quot;, they will be excluded in the
analysis and an additional element <code>discarded.variants</code> will appear in
the return list.
</p>

<hr>
<h2 id='CheckAndReturnIDCatalog'>Check and return ID catalog</h2><span id='topic+CheckAndReturnIDCatalog'></span>

<h3>Description</h3>

<p>Check and return ID catalog
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckAndReturnIDCatalog(catID, discarded.variants, annotated.vcfs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CheckAndReturnIDCatalog_+3A_catid">catID</code></td>
<td>
<p>An ID catalog.</p>
</td></tr>
<tr><td><code id="CheckAndReturnIDCatalog_+3A_discarded.variants">discarded.variants</code></td>
<td>
<p>A list of discarded variants.</p>
</td></tr>
<tr><td><code id="CheckAndReturnIDCatalog_+3A_annotated.vcfs">annotated.vcfs</code></td>
<td>
<p>A list of annotated VCFs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of ID catalog. Also return the discarded variants and
annotated VCFs if they exit.
</p>

<hr>
<h2 id='CheckAndReturnIDMatrix'>Check and return the ID mutation matrix</h2><span id='topic+CheckAndReturnIDMatrix'></span>

<h3>Description</h3>

<p>Check and return the ID mutation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckAndReturnIDMatrix(
  annotated.vcf,
  discarded.variants,
  ID.mat,
  return.annotated.vcf = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CheckAndReturnIDMatrix_+3A_annotated.vcf">annotated.vcf</code></td>
<td>
<p>An annotated ID VCF with additional column
<code>ID.class</code> showing ID classification for each variant.</p>
</td></tr>
<tr><td><code id="CheckAndReturnIDMatrix_+3A_discarded.variants">discarded.variants</code></td>
<td>
<p>A <code>data.frame</code> which contains rows of ID
variants which are excluded in the analysis.</p>
</td></tr>
<tr><td><code id="CheckAndReturnIDMatrix_+3A_id.mat">ID.mat</code></td>
<td>
<p>The ID mutation count matrix.</p>
</td></tr>
<tr><td><code id="CheckAndReturnIDMatrix_+3A_return.annotated.vcf">return.annotated.vcf</code></td>
<td>
<p>Whether to return <code>annotated.vcf</code>. Default is
FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of a 1-column ID matrix containing the mutation catalog
information and the annotated VCF with ID categories information added. If
some ID variants were excluded in the analysis, an additional element
<code>discarded.variants</code> will appear in the return list.
</p>

<hr>
<h2 id='CheckAndReturnSBSCatalogs'>Check and return SBS catalogs</h2><span id='topic+CheckAndReturnSBSCatalogs'></span>

<h3>Description</h3>

<p>Check and return SBS catalogs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckAndReturnSBSCatalogs(
  catSBS96,
  catSBS1536,
  catSBS192 = NULL,
  discarded.variants,
  annotated.vcfs
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CheckAndReturnSBSCatalogs_+3A_catsbs96">catSBS96</code></td>
<td>
<p>An SBS96 catalog.</p>
</td></tr>
<tr><td><code id="CheckAndReturnSBSCatalogs_+3A_catsbs1536">catSBS1536</code></td>
<td>
<p>An SBS1536 catalog.</p>
</td></tr>
<tr><td><code id="CheckAndReturnSBSCatalogs_+3A_catsbs192">catSBS192</code></td>
<td>
<p>An SBS192 catalog.</p>
</td></tr>
<tr><td><code id="CheckAndReturnSBSCatalogs_+3A_discarded.variants">discarded.variants</code></td>
<td>
<p>A list of discarded variants.</p>
</td></tr>
<tr><td><code id="CheckAndReturnSBSCatalogs_+3A_annotated.vcfs">annotated.vcfs</code></td>
<td>
<p>A list of annotated VCFs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of SBS catalogs. Also return the discarded variants and
annotated VCFs if they exit.
</p>

<hr>
<h2 id='CheckAndReturnSBSMatrix'>Check and return the SBS mutation matrix</h2><span id='topic+CheckAndReturnSBSMatrix'></span>

<h3>Description</h3>

<p>Check and return the SBS mutation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckAndReturnSBSMatrix(
  vcf,
  discarded.variants,
  mat96,
  mat1536,
  mat192 = NULL,
  return.annotated.vcf = FALSE,
  sample.id = "counts"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CheckAndReturnSBSMatrix_+3A_vcf">vcf</code></td>
<td>
<p>An in-memory VCF file annotated with sequence context and
transcript information by function <code><a href="#topic+AnnotateSBSVCF">AnnotateSBSVCF</a></code>. It must
*not* contain indels and must *not* contain DBS (double base
substitutions), or triplet base substitutions etc., even if encoded as
neighboring SBS.</p>
</td></tr>
<tr><td><code id="CheckAndReturnSBSMatrix_+3A_discarded.variants">discarded.variants</code></td>
<td>
<p>A <code>data.frame</code> which contains rows of SBS
variants whose pentanucleotide context contains &quot;N&quot;.</p>
</td></tr>
<tr><td><code id="CheckAndReturnSBSMatrix_+3A_mat96">mat96</code></td>
<td>
<p>The SBS96 mutation count matrix.</p>
</td></tr>
<tr><td><code id="CheckAndReturnSBSMatrix_+3A_mat1536">mat1536</code></td>
<td>
<p>The SBS1536 mutation count matrix.</p>
</td></tr>
<tr><td><code id="CheckAndReturnSBSMatrix_+3A_mat192">mat192</code></td>
<td>
<p>The SBS192 mutation count matrix.</p>
</td></tr>
<tr><td><code id="CheckAndReturnSBSMatrix_+3A_return.annotated.vcf">return.annotated.vcf</code></td>
<td>
<p>Whether to return the annotated VCF with
additional columns showing the mutation class for each variant. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="CheckAndReturnSBSMatrix_+3A_sample.id">sample.id</code></td>
<td>
<p>Usually the sample id, but defaults to &quot;count&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three 1-column matrices with the names
<code>catSBS96</code>, <code>catSBS192</code>, <code>catSBS1536</code>. If transcript
information is not available in <code>vcf</code>, <code>catSBS192</code> is not
generated. Do not rely on the order of elements in the list. If
<code>return.annotated.vcf</code> = TRUE, another element <code>annotated.vcf</code>
will appear in the list. If there are SBS variants whose pentanucleotide
context contains &quot;N&quot;, they will be excluded in the analysis and an
additional element <code>discarded.variants</code> will appear in the return
list.
</p>

<hr>
<h2 id='CheckDBSClassInVCF'>Check DBS mutation class in VCF with the corresponding DBS mutation matrix</h2><span id='topic+CheckDBSClassInVCF'></span>

<h3>Description</h3>

<p>Check DBS mutation class in VCF with the corresponding DBS mutation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckDBSClassInVCF(vcf, mat, sample.id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CheckDBSClassInVCF_+3A_vcf">vcf</code></td>
<td>
<p>An annotated DBS VCF with columns of DBS mutation
classes added by <code>AddDBSClass</code>.</p>
</td></tr>
<tr><td><code id="CheckDBSClassInVCF_+3A_mat">mat</code></td>
<td>
<p>The DBS mutation count matrix.</p>
</td></tr>
<tr><td><code id="CheckDBSClassInVCF_+3A_sample.id">sample.id</code></td>
<td>
<p>Usually the sample id, but defaults to &quot;count&quot;.</p>
</td></tr>
</table>

<hr>
<h2 id='CheckSBSClassInVCF'>Check SBS mutation class in VCF with the corresponding SBS mutation matrix</h2><span id='topic+CheckSBSClassInVCF'></span>

<h3>Description</h3>

<p>Check SBS mutation class in VCF with the corresponding SBS mutation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckSBSClassInVCF(vcf, mat, sample.id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CheckSBSClassInVCF_+3A_vcf">vcf</code></td>
<td>
<p>An annotated SBS VCF with columns of SBS mutation
classes added by <code>AddSBSClass</code>.</p>
</td></tr>
<tr><td><code id="CheckSBSClassInVCF_+3A_mat">mat</code></td>
<td>
<p>The SBS mutation count matrix.</p>
</td></tr>
<tr><td><code id="CheckSBSClassInVCF_+3A_sample.id">sample.id</code></td>
<td>
<p>Usually the sample id, but defaults to &quot;count&quot;.</p>
</td></tr>
</table>

<hr>
<h2 id='CheckSeqContextInVCF'>Check that the sequence context information is consistent with the value of
the column REF.</h2><span id='topic+CheckSeqContextInVCF'></span>

<h3>Description</h3>

<p>Check that the sequence context information is consistent with the value of
the column REF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckSeqContextInVCF(vcf, column.to.use)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CheckSeqContextInVCF_+3A_vcf">vcf</code></td>
<td>
<p>In-memory VCF as a data.frame; must be an SBS or DBS VCF.</p>
</td></tr>
<tr><td><code id="CheckSeqContextInVCF_+3A_column.to.use">column.to.use</code></td>
<td>
<p>The column name as a string of the column in the VCF
with the context information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Throws error with location information if the value of REF is
inconsistent with the value of seq.21bases. Assumes the first base of the
reference allele is at position (size(&lt;context string&gt;)-1)/2, and generates
error if this is not an integer. Indices are 1-based.
</p>

<hr>
<h2 id='CollapseCatalog'>&quot;Collapse&quot; a catalog</h2><span id='topic+CollapseCatalog'></span><span id='topic+Collapse192CatalogTo96'></span><span id='topic+Collapse1536CatalogTo96'></span><span id='topic+Collapse144CatalogTo78'></span>

<h3>Description</h3>


<ol>
<li><p> Take a mutational spectrum or signature catalog
that is based on a fined-grained set of features (for example, single-nucleotide
substitutions in the context of the preceding and following 2 bases).
</p>
</li>
<li><p> Collapse it to a catalog based on a coarser-grained set of features
(for example, single-nucleotide substitutions in the context of the
immediately preceding and following bases).
</p>
</li></ol>

<p><code>Collapse192CatalogTo96</code> Collapse an SBS 192 catalog
to an SBS 96 catalog.
</p>
<p><code>Collapse1536CatalogTo96</code> Collapse an SBS 1536 catalog
to an SBS 96 catalog.
</p>
<p><code>Collapse144CatalogTo78</code> Collapse a DBS 144 catalog
to a DBS 78 catalog.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Collapse192CatalogTo96(catalog)

Collapse1536CatalogTo96(catalog)

Collapse144CatalogTo78(catalog)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CollapseCatalog_+3A_catalog">catalog</code></td>
<td>
<p>A catalog as defined in <code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A catalog as defined in <code><a href="#topic+ICAMS">ICAMS</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an SBS192 catalog and collapse it to an SBS96 catalog
object &lt;- matrix(1, nrow = 192, ncol = 1, 
                 dimnames = list(catalog.row.order$SBS192))
catSBS192 &lt;- as.catalog(object, region = "transcript")
catSBS96 &lt;- Collapse192CatalogTo96(catSBS192)
</code></pre>

<hr>
<h2 id='ConvertICAMSCatalogToSigProSBS96'>Covert an ICAMS SBS96 Catalog to SigProfiler format</h2><span id='topic+ConvertICAMSCatalogToSigProSBS96'></span>

<h3>Description</h3>

<p>Covert an ICAMS SBS96 Catalog to SigProfiler format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConvertICAMSCatalogToSigProSBS96(input.catalog, file, sep = "\t")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ConvertICAMSCatalogToSigProSBS96_+3A_input.catalog">input.catalog</code></td>
<td>
<p>Either a character string, in which case this is the
path to a file containing a catalog in <code><a href="#topic+ICAMS">ICAMS</a></code>
format, or an in-memory <code><a href="#topic+ICAMS">ICAMS</a></code> catalog.</p>
</td></tr>
<tr><td><code id="ConvertICAMSCatalogToSigProSBS96_+3A_file">file</code></td>
<td>
<p>The path of the file to be written.</p>
</td></tr>
<tr><td><code id="ConvertICAMSCatalogToSigProSBS96_+3A_sep">sep</code></td>
<td>
<p>Separator to use in the output file.</p>
</td></tr>
</table>

<hr>
<h2 id='CreateDinucAbundance'>Create dinucleotide abundance</h2><span id='topic+CreateDinucAbundance'></span>

<h3>Description</h3>

<p>Create dinucleotide abundance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateDinucAbundance(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CreateDinucAbundance_+3A_file">file</code></td>
<td>
<p>Path to the file with the nucleotide abundance information with 2
base pairs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector whose names indicate 10 different types of 2 base pairs
combinations while its values indicate the occurrences of each type.
</p>

<hr>
<h2 id='CreateExomeStrandedRanges'>Create exome transcriptionally stranded regions</h2><span id='topic+CreateExomeStrandedRanges'></span>

<h3>Description</h3>

<p>Create exome transcriptionally stranded regions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateExomeStrandedRanges(file, trans.ranges)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CreateExomeStrandedRanges_+3A_file">file</code></td>
<td>
<p>Path to a SureSelect BED file which contains unstranded exome
ranges.</p>
</td></tr>
<tr><td><code id="CreateExomeStrandedRanges_+3A_trans.ranges">trans.ranges</code></td>
<td>
<p>A data.table which contains transcript range and strand
information. Please refer to <code><a href="#topic+TranscriptRanges">TranscriptRanges</a></code> for more
details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data table which contains chromosome name, start, end position,
strand information. It is keyed by chrom, start, and
end.
</p>

<hr>
<h2 id='CreateOneColDBSMatrix'>Create the matrix a DBS catalog for *one* sample from an in-memory VCF.</h2><span id='topic+CreateOneColDBSMatrix'></span>

<h3>Description</h3>

<p>Create the matrix a DBS catalog for *one* sample from an in-memory VCF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateOneColDBSMatrix(vcf, sample.id = "count", return.annotated.vcf = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CreateOneColDBSMatrix_+3A_vcf">vcf</code></td>
<td>
<p>An in-memory VCF file annotated with sequence context and
transcript information by function <code><a href="#topic+AnnotateDBSVCF">AnnotateDBSVCF</a></code>. It must
*not* contain indels and must *not* contain SBS (single base
substitutions), or triplet base substitutions etc.</p>
</td></tr>
<tr><td><code id="CreateOneColDBSMatrix_+3A_sample.id">sample.id</code></td>
<td>
<p>Usually the sample id, but defaults to &quot;count&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three 1-column matrices with the names <code>catDBS78</code>,
<code>catDBS136</code>, and <code>catDBS144</code>. If trans.ranges is NULL,
<code>catDBS144</code> is not generated. Do not rely on the order of elements in
the list. If <code>return.annotated.vcf</code> = TRUE, another element
<code>annotated.vcf</code> will appear in the list. If there are DBS variants
whose tetranucleotide context contains &quot;N&quot;, they will be excluded in the
analysis and an additional element <code>discarded.variants</code> will appear in
the return list.
</p>


<h3>Note</h3>

<p>DBS 144 catalog only contains mutations in transcribed regions.
</p>

<hr>
<h2 id='CreateOneColIDMatrix'>Create one column of the matrix for an indel catalog from *one* in-memory VCF.</h2><span id='topic+CreateOneColIDMatrix'></span>

<h3>Description</h3>

<p>Create one column of the matrix for an indel catalog from *one* in-memory VCF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateOneColIDMatrix(
  ID.vcf,
  SBS.vcf = NULL,
  sample.id = "count",
  return.annotated.vcf = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CreateOneColIDMatrix_+3A_id.vcf">ID.vcf</code></td>
<td>
<p>An in-memory VCF as a data.frame annotated by the
<code><a href="#topic+AnnotateIDVCF">AnnotateIDVCF</a></code> function. It must only
contain indels and must <strong>not</strong> contain SBSs
(single base substitutions), DBSs, or triplet
base substitutions, etc.
</p>
<p>One design decision for variant callers is the representation of &quot;complex
indels&quot;, e.g. mutations e.g. CAT &gt; GC. Some callers represent this as C&gt;G,
A&gt;C, and T&gt;_. Others might represent it as CAT &gt; CG. Multiple issues can
arise. In PCAWG, overlapping indel/SBS calls from different callers were
included in the indel VCFs.</p>
</td></tr>
<tr><td><code id="CreateOneColIDMatrix_+3A_sbs.vcf">SBS.vcf</code></td>
<td>
<p>This argument defaults to <code>NULL</code> and
is not used. Ideally this should be an in-memory SBS VCF 
as a data frame. The rational is that for some data,
complex indels might be represented as an indel with adjoining
SBSs.</p>
</td></tr>
<tr><td><code id="CreateOneColIDMatrix_+3A_sample.id">sample.id</code></td>
<td>
<p>Usually the sample id, but defaults to &quot;count&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of a 1-column ID matrix containing the mutation catalog
information and the annotated VCF with ID categories information added. If
some ID variants were excluded in the analysis, an additional element
<code>discarded.variants</code> will appear in the return list.
</p>

<hr>
<h2 id='CreateOneColSBSMatrix'>Create the matrix an SBS catalog for *one* sample from an in-memory VCF.</h2><span id='topic+CreateOneColSBSMatrix'></span>

<h3>Description</h3>

<p>Create the matrix an SBS catalog for *one* sample from an in-memory VCF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateOneColSBSMatrix(vcf, sample.id = "count", return.annotated.vcf = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CreateOneColSBSMatrix_+3A_vcf">vcf</code></td>
<td>
<p>An in-memory VCF file annotated with sequence context and
transcript information by function <code><a href="#topic+AnnotateSBSVCF">AnnotateSBSVCF</a></code>. It must
*not* contain indels and must *not* contain DBS (double base
substitutions), or triplet base substitutions etc., even if encoded as
neighboring SBS.</p>
</td></tr>
<tr><td><code id="CreateOneColSBSMatrix_+3A_sample.id">sample.id</code></td>
<td>
<p>Usually the sample id, but defaults to &quot;count&quot;.</p>
</td></tr>
<tr><td><code id="CreateOneColSBSMatrix_+3A_return.annotated.vcf">return.annotated.vcf</code></td>
<td>
<p>Whether to return the annotated VCF with
additional columns showing the mutation class for each variant. Default is
FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three 1-column matrices with the names
<code>catSBS96</code>, <code>catSBS192</code>, <code>catSBS1536</code>. If transcript
information is not available in <code>vcf</code>, <code>catSBS192</code> is not
generated. Do not rely on the order of elements in the list. If
<code>return.annotated.vcf</code> = TRUE, another element <code>annotated.vcf</code>
will appear in the list. If there are SBS variants whose pentanucleotide
context contains &quot;N&quot;, they will be excluded in the analysis and an
additional element <code>discarded.variants</code> will appear in the return
list.
</p>


<h3>Note</h3>

<p>catSBS192 only contains mutations in transcribed regions.
</p>

<hr>
<h2 id='CreateOnePPMFromSBSVCF'>Create position probability matrix (PPM) for *one* sample from
a Variant Call Format (VCF) file.</h2><span id='topic+CreateOnePPMFromSBSVCF'></span>

<h3>Description</h3>

<p>Create position probability matrix (PPM) for *one* sample from
a Variant Call Format (VCF) file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateOnePPMFromSBSVCF(vcf, ref.genome, seq.context.width)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CreateOnePPMFromSBSVCF_+3A_vcf">vcf</code></td>
<td>
<p>One in-memory data frame of pure SBS mutations &ndash; no DBS or 3+BS
mutations.</p>
</td></tr>
<tr><td><code id="CreateOnePPMFromSBSVCF_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="CreateOnePPMFromSBSVCF_+3A_seq.context.width">seq.context.width</code></td>
<td>
<p>The number of preceding and following bases to be
extracted around the mutated position from <code>ref.genome</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A position probability matrix (PPM).
</p>

<hr>
<h2 id='CreatePentanucAbundance'>Create pentanucleotide abundance</h2><span id='topic+CreatePentanucAbundance'></span>

<h3>Description</h3>

<p>Create pentanucleotide abundance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreatePentanucAbundance(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CreatePentanucAbundance_+3A_file">file</code></td>
<td>
<p>Path to the file with the nucleotide abundance information
with 5 base pairs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector whose names indicate 512 different types of 5 base
pairs combinations while its values indicate the occurrences of each type.
</p>

<hr>
<h2 id='CreatePPMFromSBSVCFs'>Create position probability matrices (PPM) from a list of SBS vcfs</h2><span id='topic+CreatePPMFromSBSVCFs'></span>

<h3>Description</h3>

<p>Create position probability matrices (PPM) from a list of SBS vcfs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreatePPMFromSBSVCFs(list.of.SBS.vcfs, ref.genome, seq.context.width)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CreatePPMFromSBSVCFs_+3A_list.of.sbs.vcfs">list.of.SBS.vcfs</code></td>
<td>
<p>List of in-memory data frames of pure SBS mutations
&ndash; no DBS or 3+BS mutations.</p>
</td></tr>
<tr><td><code id="CreatePPMFromSBSVCFs_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="CreatePPMFromSBSVCFs_+3A_seq.context.width">seq.context.width</code></td>
<td>
<p>The number of preceding and following bases to be
extracted around the mutated position from <code>ref.genome</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of position probability matrices (PPM).
</p>

<hr>
<h2 id='CreateStrandedDinucAbundance'>Create stranded dinucleotide abundance</h2><span id='topic+CreateStrandedDinucAbundance'></span>

<h3>Description</h3>

<p>Create stranded dinucleotide abundance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateStrandedDinucAbundance(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CreateStrandedDinucAbundance_+3A_file">file</code></td>
<td>
<p>Path to the file with the nucleotide abundance information with 2
base pairs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector whose names indicate 16 different types of 2 base pairs
combinations while its values indicate the occurrences of each type.
</p>

<hr>
<h2 id='CreateStrandedTrinucAbundance'>Create stranded trinucleotide abundance</h2><span id='topic+CreateStrandedTrinucAbundance'></span>

<h3>Description</h3>

<p>Create stranded trinucleotide abundance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateStrandedTrinucAbundance(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CreateStrandedTrinucAbundance_+3A_file">file</code></td>
<td>
<p>Path to the file with the nucleotide abundance information with 3
base pairs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector whose names indicate 64 different types of 3 base pairs
combinations while its values indicate the occurrences of each type.
</p>

<hr>
<h2 id='CreateTetranucAbundance'>Create tetranucleotide abundance</h2><span id='topic+CreateTetranucAbundance'></span>

<h3>Description</h3>

<p>Create tetranucleotide abundance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateTetranucAbundance(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CreateTetranucAbundance_+3A_file">file</code></td>
<td>
<p>Path to the file with the nucleotide abundance information with 4
base pairs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector whose names indicate 136 different types of 4 base pairs
combinations while its values indicate the occurrences of each type.
</p>

<hr>
<h2 id='CreateTransRanges'>Create a transcript range file from the raw GFF3 File</h2><span id='topic+CreateTransRanges'></span>

<h3>Description</h3>

<p>Create a transcript range file from the raw GFF3 File
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateTransRanges(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CreateTransRanges_+3A_file">file</code></td>
<td>
<p>The name/path of the raw GFF3 File, or a complete URL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data table which contains chromosome name, start, end position,
strand information and gene name. It is keyed by chrom, start, and
end. Only genes that are associated with a CCDS ID are kept for
transcriptional strand bias analysis.
</p>

<hr>
<h2 id='CreateTrinucAbundance'>Create trinucleotide abundance</h2><span id='topic+CreateTrinucAbundance'></span>

<h3>Description</h3>

<p>Create trinucleotide abundance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateTrinucAbundance(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CreateTrinucAbundance_+3A_file">file</code></td>
<td>
<p>Path to the file with the nucleotide abundance information with 3
base pairs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector whose names indicate 32 different types of 3 base pairs
combinations while its values indicate the occurrences of each type.
</p>

<hr>
<h2 id='FindDelMH'>Return the length of microhomology at a deletion</h2><span id='topic+FindDelMH'></span>

<h3>Description</h3>

<p>Return the length of microhomology at a deletion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindDelMH(context, deleted.seq, pos, trace = 0, warn.cryptic = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FindDelMH_+3A_context">context</code></td>
<td>
<p>The deleted sequence plus ample surrounding
sequence on each side (at least as long as <code>del.sequence</code>).</p>
</td></tr>
<tr><td><code id="FindDelMH_+3A_deleted.seq">deleted.seq</code></td>
<td>
<p>The deleted sequence in <code>context</code>.</p>
</td></tr>
<tr><td><code id="FindDelMH_+3A_pos">pos</code></td>
<td>
<p>The position of <code>del.sequence</code> in <code>context</code>.</p>
</td></tr>
<tr><td><code id="FindDelMH_+3A_trace">trace</code></td>
<td>
<p>If &gt; 0, then generate various 
messages showing how the computation is carried out.</p>
</td></tr>
<tr><td><code id="FindDelMH_+3A_warn.cryptic">warn.cryptic</code></td>
<td>
<p>if <code>TRUE</code> generating a warning
if there is a cryptic repeat (see the example).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is primarily for internal use, but we export it
to document the underlying logic.
</p>
<p>Example:
</p>
<p><code>GGCTAGTT</code> aligned to <code>GGCTAGAACTAGTT</code> with
a deletion represented as:
</p>
<pre>

GGCTAGAACTAGTT
GG------CTAGTT GGCTAGTT GG[CTAGAA]CTAGTT
                           ----   ----
</pre>
<p>Presumed repair mechanism leading to this:
</p>
<pre>
  ....
GGCTAGAACTAGTT
CCGATCTTGATCAA

=&gt;

  ....
GGCTAG      TT
CC      GATCAA
        ....

=&gt;

GGCTAGTT
CCGATCAA

</pre>
<p>Variant-caller software can represent the
same deletion in several
different, but completely equivalent, ways.
</p>
<pre>

GGC------TAGTT GGCTAGTT GGC[TAGAAC]TAGTT
                          * ---  * ---

GGCT------AGTT GGCTAGTT GGCT[AGAACT]AGTT
                          ** --  ** --

GGCTA------GTT GGCTAGTT GGCTA[GAACTA]GTT
                          *** -  *** -

GGCTAG------TT GGCTAGTT GGCTAG[AACTAG]TT
                          ****   ****
</pre>
<p>This function finds:
</p>

<ol>
<li><p> The maximum match of undeleted sequence to the left
of the deletion that is
identical to the right end of the deleted sequence, and
</p>
</li>
<li><p> The maximum match of undeleted sequence to the right
of the deletion that
is identical to the left end of the deleted sequence.
</p>
</li></ol>

<p>The microhomology sequence is the concatenation of items
(1) and (2).
</p>
<p><strong>Warning</strong><br />
A deletion in a <em>repeat</em> can also be represented
in several different ways. A deletion in a repeat
is abstractly equivalent to a deletion with microhomology that
spans the entire deleted sequence. For example;
</p>
<pre>
GACTAGCTAGTT
GACTA----GTT GACTAGTT GACTA[GCTA]GTT
                        *** -*** -
</pre>
<p>is really a repeat
</p>
<pre>
GACTAG----TT GACTAGTT GACTAG[CTAG]TT
                        **** ----

GACT----AGTT GACTAGTT GACT[AGCT]AGTT
                        ** --** --
</pre>
<p><strong>This function only flags these
&quot;cryptic repeats&quot; with a -1 return; it does not figure
out the repeat extent.</strong>
</p>


<h3>Value</h3>

<p>The length of the maximum microhomology of <code>del.sequence</code>
in <code>context</code>.
</p>


<h3>ID classification</h3>

<p>See <a href="https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx">https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx</a>
for additional information on ID (small insertion and deletion) mutation
classification.
</p>
<p>See the documentation for <code><a href="#topic+Canonicalize1Del">Canonicalize1Del</a></code> which first handles
deletions in homopolymers, then handles deletions in simple repeats with
longer repeat units, (e.g. <code>CACACACA</code>, see
<code><a href="#topic+FindMaxRepeatDel">FindMaxRepeatDel</a></code>), and if the deletion is not in a simple
repeat, looks for microhomology (see <code><a href="#topic+FindDelMH">FindDelMH</a></code>).
</p>
<p>See the code for unexported function <code><a href="#topic+CanonicalizeID">CanonicalizeID</a></code>
and the functions it calls for handling of insertions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GAGAGG[CTAGAA]CTAGTT
#        ----   ----
FindDelMH("GGAGAGGCTAGAACTAGTTAAAAA", "CTAGAA", 8, trace = 0)  # 4

# A cryptic repeat
# 
# TAAATTATTTATTAATTTATTG
# TAAATTA----TTAATTTATTG = TAAATTATTAATTTATTG
# 
# equivalent to
#
# TAAATTATTTATTAATTTATTG
# TAAAT----TATTAATTTATTG = TAAATTATTAATTTATTG 
# 
# and
#
# TAAATTATTTATTAATTTATTG
# TAAA----TTATTAATTTATTG = TAAATTATTAATTTATTG  

FindDelMH("TAAATTATTTATTAATTTATTG", "TTTA", 8, warn.cryptic = FALSE) # -1
</code></pre>

<hr>
<h2 id='FindMaxRepeatDel'>Return the number of repeat units in which a deletion is embedded</h2><span id='topic+FindMaxRepeatDel'></span>

<h3>Description</h3>

<p>Return the number of repeat units in which a deletion is embedded
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindMaxRepeatDel(context, rep.unit.seq, pos)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FindMaxRepeatDel_+3A_context">context</code></td>
<td>
<p>A string that embeds <code>rep.unit.seq</code> at position
<code>pos</code></p>
</td></tr>
<tr><td><code id="FindMaxRepeatDel_+3A_rep.unit.seq">rep.unit.seq</code></td>
<td>
<p>A substring of <code>context</code> at <code>pos</code>
to <code>pos + nchar(rep.unit.seq) - 1</code>, which is the repeat
unit sequence.</p>
</td></tr>
<tr><td><code id="FindMaxRepeatDel_+3A_pos">pos</code></td>
<td>
<p>The position of <code>rep.unit.seq</code> in <code>context</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is primarily for internal use, but we export it
to document the underlying logic.
</p>
<p>For example <code>FindMaxRepeatDel("xyaczt", "ac", 3)</code>
returns 0.
</p>
<p>If
<code>substr(context, pos, pos + nchar(rep.unit.seq) - 1) != rep.unit.seq</code>
then stop.
</p>
<p>If this functions returns 0, then it is necessary to
look for microhomology using the function
<code><a href="#topic+FindDelMH">FindDelMH</a></code>.
</p>
<p><strong>Warning</strong><br />
This function depends on the variant caller having 
&quot;aligned&quot; the deletion within the context of the
repeat.
</p>
<p>For example, a deletion of <code>CAG</code> in the repeat
</p>
<pre>
GTCAGCAGCATGT
</pre>
<p>can have 3 &quot;aligned&quot; representations as follows:
</p>
<pre>
CT---CAGCAGGT
CTCAG---CAGGT
CTCAGCAG---GT
</pre>
<p>In these cases this function will return 2. (Please
not that the return value does not include the
<code>rep.uni.seq</code> in the count.)
</p>
<p>However, the same deletion can also have an &quot;unaligned&quot; representation, such as
</p>
<pre>
CTCAGC---AGGT
</pre>
<p>(a deletion of <code>AGC</code>).
</p>
<p>In this case this function will return 1 (a deletion of <code>AGC</code>
in a 2-element repeat of <code>AGC</code>).
</p>


<h3>Value</h3>

<p>The number of repeat units in which <code>rep.unit.seq</code> is
embedded, not including
the input <code>rep.unit.seq</code> in the count.
</p>


<h3>ID classification</h3>

<p>See <a href="https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx">https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx</a>
for additional information on ID (small insertion and deletion) mutation
classification.
</p>
<p>See the documentation for <code><a href="#topic+Canonicalize1Del">Canonicalize1Del</a></code> which first handles
deletions in homopolymers, then handles deletions in simple repeats with
longer repeat units, (e.g. <code>CACACACA</code>, see
<code><a href="#topic+FindMaxRepeatDel">FindMaxRepeatDel</a></code>), and if the deletion is not in a simple
repeat, looks for microhomology (see <code><a href="#topic+FindDelMH">FindDelMH</a></code>).
</p>
<p>See the code for unexported function <code><a href="#topic+CanonicalizeID">CanonicalizeID</a></code>
and the functions it calls for handling of insertions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FindMaxRepeatDel("xyACACzt", "AC", 3) # 1
FindMaxRepeatDel("xyACACzt", "CA", 4) # 0

</code></pre>

<hr>
<h2 id='FindMaxRepeatIns'>Return the number of repeat units in which an insertion
is embedded.</h2><span id='topic+FindMaxRepeatIns'></span>

<h3>Description</h3>

<p>Return the number of repeat units in which an insertion
is embedded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindMaxRepeatIns(context, rep.unit.seq, pos)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FindMaxRepeatIns_+3A_context">context</code></td>
<td>
<p>A string into which <code>rep.unit.seq</code> was
inserted at position <code>pos</code>.</p>
</td></tr>
<tr><td><code id="FindMaxRepeatIns_+3A_rep.unit.seq">rep.unit.seq</code></td>
<td>
<p>The inserted sequence and candidate repeat unit
sequence.</p>
</td></tr>
<tr><td><code id="FindMaxRepeatIns_+3A_pos">pos</code></td>
<td>
<p><code>rep.unit.seq</code> is understood to be inserted between
positions <code>pos</code> and <code>pos + 1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For example
</p>
<pre>

rep.unit.seq = ac
pos = 2
context = xyaczt
return 1

rep.unit.seq = ac
pos = 4
context = xyaczt
return 1

rep.unit.seq = cgct
pos = 2
rep.unit.seq = at
return 0

context = gacacacacg
rep.unit.seq = ac
pos = any of 1, 3, 5, 7, 9
return 4
</pre>
<p>If 
<code>substr(context, pos, pos + nchar(rep.unit.seq) - 1) != rep.unit.seq</code>,
then stop.
</p>


<h3>Value</h3>

<p>If same sequence as <code>rep.unit.seq</code> occurs ending at
<code>pos</code> or starting at <code>pos + 1</code> then the number of
repeat units before the insertion, otherwise 0.
</p>

<hr>
<h2 id='GeneExpressionData'>Example gene expression data from two cell lines</h2><span id='topic+GeneExpressionData'></span><span id='topic+gene.expression.data.HepG2'></span><span id='topic+gene.expression.data.MCF10A'></span>

<h3>Description</h3>

<p>This data is designed to be used as an example in function <br />
<code><a href="#topic+PlotTransBiasGeneExp">PlotTransBiasGeneExp</a></code> and <code><a href="#topic+PlotTransBiasGeneExpToPdf">PlotTransBiasGeneExpToPdf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gene.expression.data.HepG2

gene.expression.data.MCF10A
</code></pre>


<h3>Format</h3>

<p>A <code>data.table</code> which contains the expression values of genes.
</p>
<p>An object of class <code>data.table</code> (inherits from <code>data.frame</code>) with 57736 rows and 4 columns.
</p>
<p>An object of class <code>data.table</code> (inherits from <code>data.frame</code>) with 57736 rows and 4 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene.expression.data.HepG2
# Ensembl.gene.ID  gene.symbol  counts            TPM
# ENSG00000000003       TSPAN6    6007   33.922648455
# ENSG00000000005         TNMD       0    0.000000000
# ENSG00000000419         DPM1    4441   61.669371091
# ENSG00000000457        SCYL3    1368    3.334619195
# ENSG00000000460     C1orf112     916    2.416263423
#             ...          ...     ...            ...
</code></pre>

<hr>
<h2 id='GenerateEmptyKmerCounts'>Generate an empty matrix of k-mer abundance</h2><span id='topic+GenerateEmptyKmerCounts'></span>

<h3>Description</h3>

<p>Generate an empty matrix of k-mer abundance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenerateEmptyKmerCounts(k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GenerateEmptyKmerCounts_+3A_k">k</code></td>
<td>
<p>Length of k-mers (k&gt;=2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An empty matrix of k-mer abundance
</p>

<hr>
<h2 id='GenerateKmer'>Generate all possible k-mers of length k.</h2><span id='topic+GenerateKmer'></span>

<h3>Description</h3>

<p>Generate all possible k-mers of length k.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenerateKmer(k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GenerateKmer_+3A_k">k</code></td>
<td>
<p>Length of k-mers (k&gt;=2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector containing all possible k-mers.
</p>

<hr>
<h2 id='GetConsensusVAF'>Analogous to <code><a href="#topic+GetMutectVAF">GetMutectVAF</a></code>, calculating VAF and read depth
from PCAWG7 consensus vcfs</h2><span id='topic+GetConsensusVAF'></span>

<h3>Description</h3>

<p>Analogous to <code><a href="#topic+GetMutectVAF">GetMutectVAF</a></code>, calculating VAF and read depth
from PCAWG7 consensus vcfs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetConsensusVAF(vcf, mc.cores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetConsensusVAF_+3A_vcf">vcf</code></td>
<td>
<p>An in-memory VCF data frame.</p>
</td></tr>
<tr><td><code id="GetConsensusVAF_+3A_mc.cores">mc.cores</code></td>
<td>
<p>The number of cores to use. Not available on Windows
unless <code>mc.cores = 1</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='GetCustomKmerCounts'>Generate custom k-mer abundance from a given reference genome</h2><span id='topic+GetCustomKmerCounts'></span>

<h3>Description</h3>

<p>Generate custom k-mer abundance from a given reference genome
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetCustomKmerCounts(k, ref.genome, custom.ranges, filter.path, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetCustomKmerCounts_+3A_k">k</code></td>
<td>
<p>Length of k-mers (k&gt;=2)</p>
</td></tr>
<tr><td><code id="GetCustomKmerCounts_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="GetCustomKmerCounts_+3A_custom.ranges">custom.ranges</code></td>
<td>
<p>A keyed data table which has custom ranges information. It
has three columns: chrom, start and end. It should use one-based coordinate
system. You can use the internal function in this package
<code>ICAMS:::ReadBedRanges</code> to read a BED file in 0-based coordinates and
convert it to 1-based coordinates.</p>
</td></tr>
<tr><td><code id="GetCustomKmerCounts_+3A_filter.path">filter.path</code></td>
<td>
<p>If given, homopolymers will be masked from
genome(sequence). Only simple repeat masking is accepted now.</p>
</td></tr>
<tr><td><code id="GetCustomKmerCounts_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> generate progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of the counts of custom k-mer across the <code>ref.genome</code>
</p>

<hr>
<h2 id='GetGenomeKmerCounts'>Generate k-mer abundance from a given genome</h2><span id='topic+GetGenomeKmerCounts'></span>

<h3>Description</h3>

<p>Generate k-mer abundance from a given genome
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetGenomeKmerCounts(k, ref.genome, filter.path, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetGenomeKmerCounts_+3A_k">k</code></td>
<td>
<p>Length of k-mers (k&gt;=2)</p>
</td></tr>
<tr><td><code id="GetGenomeKmerCounts_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="GetGenomeKmerCounts_+3A_filter.path">filter.path</code></td>
<td>
<p>If given, homopolymers will be masked from
genome(sequence). Only simple repeat masking is accepted now.</p>
</td></tr>
<tr><td><code id="GetGenomeKmerCounts_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, generate progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of the counts of each k-mer across the <code>ref.genome</code>
</p>

<hr>
<h2 id='GetMutationLoadsFromMutectVCFs'>Get mutation loads information from Mutect VCF files.</h2><span id='topic+GetMutationLoadsFromMutectVCFs'></span>

<h3>Description</h3>

<p>Get mutation loads information from Mutect VCF files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetMutationLoadsFromMutectVCFs(catalogs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetMutationLoadsFromMutectVCFs_+3A_catalogs">catalogs</code></td>
<td>
<p>A list generated by calling function
<code><a href="#topic+MutectVCFFilesToCatalog">MutectVCFFilesToCatalog</a></code> to Mutect VCF files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing mutation loads information from Mutect VCF files:
</p>

<ol>
<li> <p><code>total.variants</code> Total number of mutations.
</p>
</li>
<li> <p><code>SBS</code> Number of single base substitutions.
</p>
</li>
<li> <p><code>DBS</code> Number of double base substitutions.
</p>
</li>
<li> <p><code>ID</code> Number of small insertions and deletions.
</p>
</li>
<li> <p><code>discarded.variants</code> Number of other types of mutations which are
excluded in the analysis in <code><a href="#topic+ICAMS">ICAMS</a></code>.
</p>
</li></ol>


<hr>
<h2 id='GetMutationLoadsFromStrelkaIDVCFs'>Get mutation loads information from Strelka ID VCF files.</h2><span id='topic+GetMutationLoadsFromStrelkaIDVCFs'></span>

<h3>Description</h3>

<p>Get mutation loads information from Strelka ID VCF files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetMutationLoadsFromStrelkaIDVCFs(catalogs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetMutationLoadsFromStrelkaIDVCFs_+3A_catalogs">catalogs</code></td>
<td>
<p>A list generated by calling function
<code><a href="#topic+StrelkaIDVCFFilesToCatalog">StrelkaIDVCFFilesToCatalog</a></code> to Strelka ID VCF files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing mutation loads information from Strelka ID VCF
files:
</p>

<ol>
<li> <p><code>total.variants</code> Total number of mutations.
</p>
</li>
<li> <p><code>SBS</code> Number of single base substitutions.
</p>
</li>
<li> <p><code>DBS</code> Number of double base substitutions.
</p>
</li>
<li> <p><code>ID</code> Number of small insertions and deletions.
</p>
</li>
<li> <p><code>excluded.variants</code> Number of other types of mutations which are
excluded in the analysis in <code><a href="#topic+ICAMS">ICAMS</a></code>.
</p>
</li></ol>


<hr>
<h2 id='GetMutationLoadsFromStrelkaSBSVCFs'>Get mutation loads information from Strelka SBS VCF files.</h2><span id='topic+GetMutationLoadsFromStrelkaSBSVCFs'></span>

<h3>Description</h3>

<p>Get mutation loads information from Strelka SBS VCF files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetMutationLoadsFromStrelkaSBSVCFs(catalogs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetMutationLoadsFromStrelkaSBSVCFs_+3A_catalogs">catalogs</code></td>
<td>
<p>A list generated by calling function
<code><a href="#topic+StrelkaSBSVCFFilesToCatalog">StrelkaSBSVCFFilesToCatalog</a></code> to Strelka SBS VCF files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing mutation loads information from Strelka SBS VCF
files:
</p>

<ol>
<li> <p><code>total.variants</code> Total number of mutations.
</p>
</li>
<li> <p><code>SBS</code> Number of single base substitutions.
</p>
</li>
<li> <p><code>DBS</code> Number of double base substitutions.
</p>
</li>
<li> <p><code>ID</code> Number of small insertions and deletions.
</p>
</li>
<li> <p><code>discarded.variants</code> Number of other types of mutations which are
excluded in the analysis in <code><a href="#topic+ICAMS">ICAMS</a></code>.
</p>
</li></ol>


<hr>
<h2 id='GetSequenceKmerCounts'>Generate k-mer abundance from given nucleotide sequences</h2><span id='topic+GetSequenceKmerCounts'></span>

<h3>Description</h3>

<p>Generate k-mer abundance from given nucleotide sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetSequenceKmerCounts(sequences, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetSequenceKmerCounts_+3A_sequences">sequences</code></td>
<td>
<p>A vector of nucleotide sequences</p>
</td></tr>
<tr><td><code id="GetSequenceKmerCounts_+3A_k">k</code></td>
<td>
<p>Length of k-mers (k&gt;=2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of the counts of each k-mer inside <code>sequences</code>
</p>

<hr>
<h2 id='GetStrandedKmerCounts'>Generate stranded k-mer abundance from a given genome and gene annotation file</h2><span id='topic+GetStrandedKmerCounts'></span>

<h3>Description</h3>

<p>Generate stranded k-mer abundance from a given genome and gene annotation file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetStrandedKmerCounts(
  k,
  ref.genome,
  stranded.ranges,
  filter.path,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetStrandedKmerCounts_+3A_k">k</code></td>
<td>
<p>Length of k-mers (k&gt;=2)</p>
</td></tr>
<tr><td><code id="GetStrandedKmerCounts_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="GetStrandedKmerCounts_+3A_stranded.ranges">stranded.ranges</code></td>
<td>
<p>A keyed data table which has stranded ranges
information. It has four columns: chrom, start, end and strand. It should
use one-based coordinate system.</p>
</td></tr>
<tr><td><code id="GetStrandedKmerCounts_+3A_filter.path">filter.path</code></td>
<td>
<p>If given, homopolymers will be masked from
genome(sequence). Only simple repeat masking is accepted now.</p>
</td></tr>
<tr><td><code id="GetStrandedKmerCounts_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> generate progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of the counts of each stranded k-mer across the <code>ref.genome</code>
</p>

<hr>
<h2 id='GetVAF'>Extract the VAFs (variant allele frequencies) and read depth information from
a VCF file</h2><span id='topic+GetVAF'></span><span id='topic+GetStrelkaVAF'></span><span id='topic+GetMutectVAF'></span><span id='topic+GetFreebayesVAF'></span>

<h3>Description</h3>

<p>Extract the VAFs (variant allele frequencies) and read depth information from
a VCF file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetStrelkaVAF(vcf, name.of.VCF = NULL)

GetMutectVAF(vcf, name.of.VCF = NULL, tumor.col.name = NA)

GetFreebayesVAF(vcf, name.of.VCF = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetVAF_+3A_vcf">vcf</code></td>
<td>
<p>Said VCF as a data.frame.</p>
</td></tr>
<tr><td><code id="GetVAF_+3A_name.of.vcf">name.of.VCF</code></td>
<td>
<p>Name of the VCF file.</p>
</td></tr>
<tr><td><code id="GetVAF_+3A_tumor.col.name">tumor.col.name</code></td>
<td>
<p>Optional. Only applicable to <strong>Mutect</strong> VCF. Name
of the column in <strong>Mutect</strong> VCF which contains the tumor sample
information. It <strong>must</strong> have quotation marks. If
<code>tumor.col.name</code> is equal to <code>NA</code>(default), this function will
use the 10th column to calculate VAFs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original <code>vcf</code> with two additional columns added which
contain the VAF(variant allele frequency) and read depth information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- c(system.file("extdata/Strelka-SBS-vcf",
                      "Strelka.SBS.GRCh37.s1.vcf",
                      package = "ICAMS"))
MakeDataFrameFromVCF &lt;- getFromNamespace("MakeDataFrameFromVCF", "ICAMS")
df &lt;- MakeDataFrameFromVCF(file)
df1 &lt;- GetStrelkaVAF(df)
</code></pre>

<hr>
<h2 id='ICAMS'>ICAMS: In-depth Characterization and Analysis of Mutational Signatures</h2><span id='topic+ICAMS'></span>

<h3>Description</h3>

<p>Analysis and visualization of experimentally elucidated mutational signatures
&ndash; the kind of analysis and visualization in Boot et al., &quot;In-depth
characterization of the cisplatin mutational signature in human cell lines
and in esophageal and liver tumors&quot;, <br />
<em>Genome Research</em> 2018 https://doi.org/10.1101/gr.230219.117 and
&quot;Characterization of colibactin-associated mutational signature in an
Asian oral squamous cell carcinoma and in other mucosal tumor types&quot;,
<em>Genome Research</em> 2020, https://doi.org/10.1101/gr.255620.119.
&quot;ICAMS&quot; stands for In-depth Characterization and
Analysis of Mutational Signatures. &quot;ICAMS&quot; has functions to read in variant
call files (VCFs) and to collate the corresponding catalogs of mutational
spectra and to analyze and plot catalogs of mutational spectra and
signatures. Handles both &quot;counts-based&quot; and &quot;density-based&quot; catalogs of
mutational spectra or signatures.
</p>


<h3>Details</h3>

<p>&quot;ICAMS&quot; can read in VCFs generated by Strelka or Mutect, and collate the
mutations  into &quot;catalogs&quot; of mutational spectra. &quot;ICAMS&quot; can create and plot
catalogs of mutational spectra or signatures for single base substitutions
(SBS), double base substitutions (DBS), and small insertions and deletions
(ID). It can also read and write these catalogs.
</p>


<h3>Catalogs</h3>

<p>A key data type in &quot;ICAMS&quot; is a &quot;catalog&quot; of mutation counts, of
mutation densities, or of mutational signatures.
</p>
<p>Catalogs are S3 objects of class <code>matrix</code> and one of
several additional classes that specify the types of the mutations
represented in the catalog. The possible
additional class is one of
</p>

<ul>
<li> <p><code>SBS96Catalog</code> (strand-agnostic single base substitutions in
trinucleotide context)
</p>
</li>
<li> <p><code>SBS192Catalog</code> (transcription-stranded single-base substitutions
in trinucleotide context)
</p>
</li>
<li> <p><code>SBS1536Catalog</code>
</p>
</li>
<li> <p><code>DBS78Catalog</code>
</p>
</li>
<li> <p><code>DBS144Catalog</code>
</p>
</li>
<li> <p><code>DBS136Catalog</code>
</p>
</li>
<li> <p><code>IndelCatalog</code>
</p>
</li></ul>

<p><code><a href="#topic+as.catalog">as.catalog</a></code>
is the main constructor.
</p>
<p>Conceptually, a catalog also has one of the following types,
indicated by the attribute <code>catalog.type</code>:
</p>

<ol>
<li><p> Matrix of mutation counts (one column per sample), representing
(counts-based) mutational spectra (<code>catalog.type = "counts"</code>).
</p>
</li>
<li><p> Matrix of mutation densities, i.e. mutations per occurrences
of source sequences (one column per sample), representing
(density-based) mutational spectra (<code>catalog.type = "density"</code>).
</p>
</li>
<li><p> Matrix of mutational signatures, which
are similar to spectra. However where spectra consist of
counts or densities of mutations in each mutation class
(e.g. ACA &gt; AAA, ACA &gt; AGA, ACA &gt; ATA, ACC &gt; AAC, ...),
signatures consist of
the proportions of mutations in each class (with all the
proportions summing to 1). A mutational signature can be based
on either:
</p>

<ul>
<li><p> mutation counts (a &quot;counts-based mutational signature&quot;,
<code>catalog.type = "counts.signature"</code>), or
</p>
</li>
<li><p> mutation densities (a &quot;density-based mutational signature&quot;,
<code>catalog.type = "density.signature"</code>).
</p>
</li></ul>

</li></ol>

<p>Catalogs also have the attribute <code>abundance</code>, which contains the
counts of different source sequences for mutations. For example,
for SBSs in trinucleotide context, the abundances would be the counts
of each trinucleotide in the human genome, exome, or in the transcribed
region of the genome. See <code><a href="#topic+TransformCatalog">TransformCatalog</a></code>
for more information. Abundances logically depend on the species in
question and on the part of the genome being analyzed.
</p>
<p>In &quot;ICAMS&quot;
abundances can sometimes be inferred from the
<code>catalog</code> class attribute and the
function arguments <code>region</code>, <code>ref.genome</code>,
and <code>catalog.type</code>.
Otherwise abundances can be provided as an <code>abundance</code> argument.
See <code><a href="#topic+all.abundance">all.abundance</a></code> for examples.
</p>
<p>Possible values for
<code>region</code> are the strings <code>genome</code>, <code>transcript</code>,
<code>exome</code>, and <code>unknown</code>; <code>transcript</code> includes entire
transcribed regions, i.e. the introns as well as the exons.
</p>
<p>If you need to create a catalog from a source other than
this package (i.e. other than with
<code><a href="#topic+ReadCatalog">ReadCatalog</a></code>
or <code><a href="#topic+StrelkaSBSVCFFilesToCatalog">StrelkaSBSVCFFilesToCatalog</a></code>,
<code><a href="#topic+MutectVCFFilesToCatalog">MutectVCFFilesToCatalog</a></code>, etc.), then use
<code><a href="#topic+as.catalog">as.catalog</a></code>.
</p>


<h3>Creating catalogs from variant call files (VCF files)</h3>


<ol>
<li> <p><code><a href="#topic+VCFsToCatalogs">VCFsToCatalogs</a></code> creates 3 SBS catalogs (96, 192, 1536), 3
DBS catalogs (78, 136, 144) and ID (small insertion and deletion) catalog
from the VCFs. It has more general usage with functionalities overlapping
with the three functions below. For example, it is the same as
<code><a href="#topic+MutectVCFFilesToCatalog">MutectVCFFilesToCatalog</a></code> when <code>variant.caller = "mutect"</code>.
</p>
</li>
<li> <p><code><a href="#topic+StrelkaSBSVCFFilesToCatalog">StrelkaSBSVCFFilesToCatalog</a></code> creates 3 SBS catalogs (96,
192, 1536) and 3 DBS catalogs (78, 136, 144) from the Strelka SBS VCFs.
</p>
</li>
<li> <p><code><a href="#topic+StrelkaIDVCFFilesToCatalog">StrelkaIDVCFFilesToCatalog</a></code> creates an ID
(small insertion and deletion) catalog
from the Strelka ID VCFs.
</p>
</li>
<li> <p><code><a href="#topic+MutectVCFFilesToCatalog">MutectVCFFilesToCatalog</a></code> creates 3 SBS catalogs (96, 192,
1536), 3 DBS catalogs (78, 136, 144) and ID (small insertion and deletion)
catalog from the Mutect VCFs.
</p>
</li></ol>



<h3>Plotting catalogs</h3>

<p>The <code><a href="#topic+PlotCatalog">PlotCatalog</a></code> functions plot mutational spectra
for <strong>one</strong> sample or plot <strong>one</strong> mutational signature.
</p>
<p>The <code><a href="#topic+PlotCatalogToPdf">PlotCatalogToPdf</a></code>
functions plot catalogs of mutational spectra or
of mutational signatures to a PDF file.
</p>


<h3>Wrapper functions to create catalogs from VCFs and plot the catalogs to PDF files</h3>


<ol>
<li> <p><code><a href="#topic+VCFsToCatalogsAndPlotToPdf">VCFsToCatalogsAndPlotToPdf</a></code> creates all types of SBS, DBS
and ID catalogs from VCFs and plots the catalogs. It has more general usage
with functionalities overlapping with the three functions below. For
example, it is the same as <code><a href="#topic+MutectVCFFilesToCatalogAndPlotToPdf">MutectVCFFilesToCatalogAndPlotToPdf</a></code>
when <code>variant.caller = "mutect"</code>.
</p>
</li>
<li> <p><code><a href="#topic+StrelkaSBSVCFFilesToCatalogAndPlotToPdf">StrelkaSBSVCFFilesToCatalogAndPlotToPdf</a></code> creates all
type of SBS and DBS catalogs from Strelka SBS VCFs and plots the catalogs.
</p>
</li>
<li> <p><code><a href="#topic+StrelkaIDVCFFilesToCatalogAndPlotToPdf">StrelkaIDVCFFilesToCatalogAndPlotToPdf</a></code> creates an ID
(small insertion and deletion) catalog from Strelka ID VCFs and plot it.
</p>
</li>
<li> <p><code><a href="#topic+MutectVCFFilesToCatalogAndPlotToPdf">MutectVCFFilesToCatalogAndPlotToPdf</a></code> creates all types of
SBS, DBS and ID catalogs from Mutect VCFs and plots the catalogs. </p>
</li></ol>



<h3>Wrapper functions to create a zip file which contains catalogs and plot PDFs from VCF files</h3>


<ol>
<li> <p><code><a href="#topic+VCFsToZipFile">VCFsToZipFile</a></code> creates a zip file which contains SBS, DBS
and ID catalogs and plot PDFs from VCF files. It has more general usage with
functionalities overlapping with the three functions below. For example,
it is the same as <code><a href="#topic+MutectVCFFilesToZipFile">MutectVCFFilesToZipFile</a></code> when
<code>variant.caller = "mutect"</code>.
</p>
</li>
<li> <p><code><a href="#topic+StrelkaSBSVCFFilesToZipFile">StrelkaSBSVCFFilesToZipFile</a></code> creates a zip file which
contains SBS and DBS catalogs and plot PDFs from Strelka SBS VCF files.
</p>
</li>
<li> <p><code><a href="#topic+StrelkaIDVCFFilesToZipFile">StrelkaIDVCFFilesToZipFile</a></code> creates a zip file which
contains ID (small insertion and deletion) catalog and plot PDF from
Strelka ID VCF files.
</p>
</li>
<li> <p><code><a href="#topic+MutectVCFFilesToZipFile">MutectVCFFilesToZipFile</a></code> creates a zip file which contains
SBS, DBS and ID catalogs and plot PDFs from Mutect VCF files. </p>
</li></ol>



<h3>The <code>ref.genome</code> (reference genome) argument</h3>

<p>Many functions take the argument <code>ref.genome</code>.
</p>
<p>To create a mutational
spectrum catalog from a VCF file, ICAMS needs the reference genome sequence
that matches the VCF file. The <code>ref.genome</code> argument
provides this.
</p>
<p><code>ref.genome</code> must be one of
</p>

<ol>
<li><p> A variable from the Bioconductor <code>BSgenome</code> package
that contains a particular reference genome, for example
<code>BSgenome.Hsapiens.1000genomes.hs37d5</code>.
</p>
</li>
<li><p> The strings <code>"hg38"</code> or <code>"GRCh38"</code>, which specify
<code>BSgenome.Hsapiens.UCSC.hg38</code>.
</p>
</li>
<li><p> The strings <code>"hg19"</code> or <code>"GRCh37"</code>,
which specify
<code>BSgenome.Hsapiens.1000genomes.hs37d5</code>.
</p>
</li>
<li><p> The strings <code>"mm10"</code> or <code>"GRCm38"</code>,
which specify
<code>BSgenome.Mmusculus.UCSC.mm10</code>.
</p>
</li></ol>

<p>All needed reference genomes must be installed separately by the user.
Further instructions are at <br />
https://bioconductor.org/packages/release/bioc/html/BSgenome.html. <br />
</p>
<p>Use of ICAMS with reference genomes other than the 2 human genomes
and 1 mouse genome specified above is restricted to
<code>catalog.type</code> of <code>counts</code> or <code>counts.signature</code>
unless the user also creates the necessary abundance vectors.
See <code><a href="#topic+all.abundance">all.abundance</a></code>.
</p>
<p>Use <code><a href="BSgenome.html#topic+available.genomes">available.genomes</a>()</code>
to get the list of available genomes.
</p>


<h3>Writing catalogs to files</h3>

<p>The <code><a href="#topic+WriteCatalog">WriteCatalog</a></code> functions
write a catalog to a file.
</p>


<h3>Reading catalogs</h3>

<p>The <code><a href="#topic+ReadCatalog">ReadCatalog</a></code> functions
read a file that contains a catalog in standardized format.
</p>


<h3>Transforming catalogs</h3>

<p>The <code><a href="#topic+TransformCatalog">TransformCatalog</a></code>
function transforms catalogs of mutational spectra or
signatures to account for differing abundances of the source
sequence of the mutations in the genome.
</p>
<p>For example, mutations from
ACG are much rarer in the human genome than mutations from ACC
simply because CG dinucleotides are rare in the genome.
Consequently, there are two possible representations of
mutational spectra or signatures. One representation is
based on mutation counts as observed in a given genome
or exome,
and this approach is widely used, as, for example, at
https://cancer.sanger.ac.uk/signatures/, which
presents signatures based on observed mutation counts
in the human genome. We call these &quot;counts-based spectra&quot;
or &quot;counts-based signatures&quot;.
</p>
<p>Alternatively,
mutational spectra or signatures can be represented as
mutations per source sequence, for example
the number of ACT &gt; AGT mutations occurring at all
ACT 3-mers in a genome. We call these &quot;density-based
spectra&quot; or &quot;density-based signatures&quot;.
</p>
<p>This function can also transform spectra
based on observed genome-wide counts to &quot;density&quot;-based
catalogs. In density-based catalogs
mutations are expressed as mutations per
source sequences. For example,
a density-based catalog represents
the proportion of ACCs mutated to
ATCs, the proportion of ACGs mutated to ATGs, etc.
This is
different from counts-based mutational spectra catalogs, which
contain the number of ACC &gt; ATC mutations, the number of
ACG &gt; ATG mutations, etc.
</p>
<p>This function can also transform observed-count based
spectra or signatures from genome to exome based counts,
or between different species (since the abundances of
source sequences vary between genome and exome and between
species).
</p>


<h3>Collapsing catalogs</h3>

<p>The <code><a href="#topic+CollapseCatalog">CollapseCatalog</a></code> functions
</p>

<ol>
<li><p> Take a mutational spectrum or signature catalog
that is based on a fined-grained set of features (for example, single-nucleotide
substitutions in the context of the preceding and following 2 bases).
</p>
</li>
<li><p> Collapse it to a catalog based on a coarser-grained set of features
(for example, single-nucleotide substitutions in the context of the
immediately preceding and following bases).
</p>
</li></ol>



<h3>Data</h3>


<ol>
<li> <p><code><a href="#topic+CatalogRowOrder">CatalogRowOrder</a></code> Standard order of rownames in a catalog.
The rownames encode the type of each mutation. For example, for SBS96
catalogs, the rowname AGAT represents a mutation from AGA &gt; ATA.
</p>
</li>
<li> <p><code><a href="#topic+TranscriptRanges">TranscriptRanges</a></code> Transcript ranges and strand information
for a particular reference genome.
</p>
</li>
<li> <p><code><a href="#topic+GeneExpressionData">GeneExpressionData</a></code> Example gene expression data from two
cell lines.
</p>
</li></ol>


<hr>
<h2 id='InferAbundance'>Infer <code>abundance</code> given a matrix-like <code>object</code> and additional information.</h2><span id='topic+InferAbundance'></span>

<h3>Description</h3>

<p>Infer <code>abundance</code> given a matrix-like <code>object</code> and additional information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InferAbundance(object, ref.genome, region, catalog.type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="InferAbundance_+3A_object">object</code></td>
<td>
<p>A numeric matrix, numeric data frame, or <code>catalog</code>.</p>
</td></tr>
<tr><td><code id="InferAbundance_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="InferAbundance_+3A_region">region</code></td>
<td>
<p>A character string designating a genomic region;
see <code><a href="#topic+as.catalog">as.catalog</a></code> and <code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="InferAbundance_+3A_catalog.type">catalog.type</code></td>
<td>
<p>A character string for <code>catalog.type</code>
as described in <code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value that can be set as the abundance attribute of
a <code>catalog</code> (which may be <code>NULL</code> if no abundance
can be inferred).
</p>

<hr>
<h2 id='InferCatalogClassPrefix'>These two functions is applicable only for 
internal ICAMS-formatted catalog object.</h2><span id='topic+InferCatalogClassPrefix'></span>

<h3>Description</h3>

<p>These two functions is applicable only for 
internal ICAMS-formatted catalog object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InferCatalogClassPrefix(object)
</code></pre>

<hr>
<h2 id='InferCatalogInfo'>This function converts an data.table imported
from external catalog text file into ICAMS
internal catalog object of appropriate type.</h2><span id='topic+InferCatalogInfo'></span>

<h3>Description</h3>

<p>This function converts an data.table imported
from external catalog text file into ICAMS
internal catalog object of appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InferCatalogInfo(object)
</code></pre>

<hr>
<h2 id='InferRownames'>Infer the correct rownames for a matrix based on its number of rows</h2><span id='topic+InferRownames'></span>

<h3>Description</h3>

<p>Infer the correct rownames for a matrix based on its number of rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InferRownames(object)
</code></pre>

<hr>
<h2 id='IsGRCh37'>Test if object is <code>BSgenome.Hsapiens.1000genome.hs37d5</code>.</h2><span id='topic+IsGRCh37'></span>

<h3>Description</h3>

<p>Test if object is <code>BSgenome.Hsapiens.1000genome.hs37d5</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IsGRCh37(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IsGRCh37_+3A_x">x</code></td>
<td>
<p>Object to test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if <code>x</code> is <code>BSgenome.Hsapiens.1000genome.hs37d5</code>.
</p>

<hr>
<h2 id='IsGRCh38'>Test if object is <code>BSgenome.Hsapiens.UCSC.hg38</code>.</h2><span id='topic+IsGRCh38'></span>

<h3>Description</h3>

<p>Test if object is <code>BSgenome.Hsapiens.UCSC.hg38</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IsGRCh38(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IsGRCh38_+3A_x">x</code></td>
<td>
<p>Object to test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if <code>x</code> is <code>BSgenome.Hsapiens.UCSC.hg38</code>.
</p>

<hr>
<h2 id='IsGRCm38'>Test if object is <code>BSgenome.Mmusculus.UCSC.mm10</code>.</h2><span id='topic+IsGRCm38'></span>

<h3>Description</h3>

<p>Test if object is <code>BSgenome.Mmusculus.UCSC.mm10</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IsGRCm38(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IsGRCm38_+3A_x">x</code></td>
<td>
<p>Object to test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if <code>x</code> is <code>BSgenome.Mmusculus.UCSC.mm10</code>.
</p>

<hr>
<h2 id='MakeDataFrameFromVCF'>Read in the data lines of a Variant Call Format (VCF) file</h2><span id='topic+MakeDataFrameFromVCF'></span>

<h3>Description</h3>

<p>Read in the data lines of a Variant Call Format (VCF) file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeDataFrameFromVCF(file, name.of.VCF = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MakeDataFrameFromVCF_+3A_file">file</code></td>
<td>
<p>The name/path of the VCF file, or a complete URL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame storing mutation records of a VCF file.
</p>

<hr>
<h2 id='MakeVCFDBSdf'>MakeVCFDBSdf Take DBS ranges and the original VCF and generate a VCF with
dinucleotide REF and ALT alleles.</h2><span id='topic+MakeVCFDBSdf'></span>

<h3>Description</h3>

<p>MakeVCFDBSdf Take DBS ranges and the original VCF and generate a VCF with
dinucleotide REF and ALT alleles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeVCFDBSdf(DBS.range.df, SBS.vcf.dt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MakeVCFDBSdf_+3A_dbs.range.df">DBS.range.df</code></td>
<td>
<p>Data frame with columns CHROM, LOW, HIGH</p>
</td></tr>
<tr><td><code id="MakeVCFDBSdf_+3A_sbs.vcf.dt">SBS.vcf.dt</code></td>
<td>
<p>A data table containing the VCF from which
<code>DBS.range.df</code> was computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A minimal VCF with only the columns <code>CHROM</code>, <code>POS</code>,
<code>ID</code>, <code>REF</code>, <code>ALT</code>, <code>VAF</code>, <code>read.depth</code>.
</p>

<hr>
<h2 id='MutectVCFFilesToCatalog'>Create SBS, DBS and Indel catalogs from Mutect VCF files</h2><span id='topic+MutectVCFFilesToCatalog'></span>

<h3>Description</h3>

<p>Create 3 SBS catalogs (96, 192, 1536), 3 DBS catalogs (78, 136, 144) and
Indel catalog from the Mutect VCFs specified by <code>files</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MutectVCFFilesToCatalog(
  files,
  ref.genome,
  trans.ranges = NULL,
  region = "unknown",
  names.of.VCFs = NULL,
  tumor.col.names = NA,
  flag.mismatches = 0,
  return.annotated.vcfs = FALSE,
  suppress.discarded.variants.warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MutectVCFFilesToCatalog_+3A_files">files</code></td>
<td>
<p>Character vector of file paths to the Mutect VCF files.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToCatalog_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToCatalog_+3A_trans.ranges">trans.ranges</code></td>
<td>
<p>Optional. If <code>ref.genome</code> specifies one of the
<code>BSgenome</code> object
</p>

<ol>
<li> <p><code>BSgenome.Hsapiens.1000genomes.hs37d5</code>
</p>
</li>
<li> <p><code>BSgenome.Hsapiens.UCSC.hg38</code>
</p>
</li>
<li> <p><code>BSgenome.Mmusculus.UCSC.mm10</code>
</p>
</li></ol>

<p>then the function will infer <code>trans.ranges</code> automatically. Otherwise,
user will need to provide the necessary <code>trans.ranges</code>. Please refer to
<code><a href="#topic+TranscriptRanges">TranscriptRanges</a></code> for more details.
If <code>is.null(trans.ranges)</code> do not add transcript range
information.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToCatalog_+3A_region">region</code></td>
<td>
<p>A character string designating a genomic region;
see <code><a href="#topic+as.catalog">as.catalog</a></code> and <code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToCatalog_+3A_names.of.vcfs">names.of.VCFs</code></td>
<td>
<p>Optional. Character vector of names of the VCF files.
The order of names in <code>names.of.VCFs</code> should match the order of VCF
file paths in <code>files</code>. If <code>NULL</code>(default), this function will
remove all of the path up to and including the last path separator (if any)
in <code>files</code> and file paths without extensions (and the leading dot)
will be used as the names of the VCF files.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToCatalog_+3A_tumor.col.names">tumor.col.names</code></td>
<td>
<p>Optional. Character vector of column names in VCFs
which contain the tumor sample information. The order of names in
<code>tumor.col.names</code> should match the order of VCFs specified in
<code>files</code>. If <code>tumor.col.names</code> is equal to <code>NA</code>(default),
this function will use the 10th column in all the VCFs to calculate VAFs.
See <code><a href="#topic+GetMutectVAF">GetMutectVAF</a></code> for more details.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToCatalog_+3A_flag.mismatches">flag.mismatches</code></td>
<td>
<p>Deprecated. If there are ID variants whose <code>REF</code>
do not match the extracted sequence from <code>ref.genome</code>, the function
will automatically discard these variants and an element
<code>discarded.variants</code> will appear in the return value. See
<code><a href="#topic+AnnotateIDVCF">AnnotateIDVCF</a></code> for more details.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToCatalog_+3A_return.annotated.vcfs">return.annotated.vcfs</code></td>
<td>
<p>Logical. Whether to return the annotated VCFs
with additional columns showing mutation class for each variant. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToCatalog_+3A_suppress.discarded.variants.warnings">suppress.discarded.variants.warnings</code></td>
<td>
<p>Logical. Whether to suppress
warning messages showing information about the discarded variants. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code><a href="#topic+VCFsToSBSCatalogs">VCFsToSBSCatalogs</a></code>,
<code><a href="#topic+VCFsToDBSCatalogs">VCFsToDBSCatalogs</a></code> and <code><a href="#topic+VCFsToIDCatalogs">VCFsToIDCatalogs</a></code>
</p>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>catSBS96</code>, <code>catSBS192</code>, <code>catSBS1536</code>: Matrix of
3 SBS catalogs (one each for 96, 192, and 1536).
</p>
</li>
<li> <p><code>catDBS78</code>, <code>catDBS136</code>, <code>catDBS144</code>: Matrix of
3 DBS catalogs (one each for 78, 136, and 144).
</p>
</li>
<li> <p><code>catID</code>: Matrix of ID (small insertion and deletion) catalog.
</p>
</li>
<li> <p><code>discarded.variants</code>: <strong>Non-NULL only if</strong> there are variants
that were excluded from the analysis. See the added extra column
<code>discarded.reason</code> for more details.
</p>
</li>
<li> <p><code>annotated.vcfs</code>:
<strong>Non-NULL only if</strong> <code>return.annotated.vcfs</code> = TRUE.
A list of elements:
</p>

<ul>
<li> <p><code>SBS</code>: SBS VCF annotated by <code><a href="#topic+AnnotateSBSVCF">AnnotateSBSVCF</a></code> with
three new columns <code>SBS96.class</code>, <code>SBS192.class</code> and
<code>SBS1536.class</code> showing the mutation class for each SBS variant.
</p>
</li>
<li> <p><code>DBS</code>: DBS VCF annotated by <code><a href="#topic+AnnotateDBSVCF">AnnotateDBSVCF</a></code> with
three new columns <code>DBS78.class</code>, <code>DBS136.class</code> and
<code>DBS144.class</code> showing the mutation class for each DBS variant.
</p>
</li>
<li> <p><code>ID</code>: ID VCF annotated by <code><a href="#topic+AnnotateIDVCF">AnnotateIDVCF</a></code> with one
new column <code>ID.class</code> showing the mutation class for each
ID variant.
</p>
</li></ul>

</li></ul>

<p>If <code>trans.ranges</code> is not provided by user and cannot be inferred by
ICAMS, SBS 192 and DBS 144 catalog will not be generated. Each catalog has
attributes added. See <code><a href="#topic+as.catalog">as.catalog</a></code> for more details.
</p>


<h3>ID classification</h3>

<p>See <a href="https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx">https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx</a>
for additional information on ID (small insertion and deletion) mutation
classification.
</p>
<p>See the documentation for <code><a href="#topic+Canonicalize1Del">Canonicalize1Del</a></code> which first handles
deletions in homopolymers, then handles deletions in simple repeats with
longer repeat units, (e.g. <code>CACACACA</code>, see
<code><a href="#topic+FindMaxRepeatDel">FindMaxRepeatDel</a></code>), and if the deletion is not in a simple
repeat, looks for microhomology (see <code><a href="#topic+FindDelMH">FindDelMH</a></code>).
</p>
<p>See the code for unexported function <code><a href="#topic+CanonicalizeID">CanonicalizeID</a></code>
and the functions it calls for handling of insertions.
</p>


<h3>Note</h3>

<p>SBS 192 and DBS 144 catalogs include only mutations in transcribed regions.
In ID (small insertion and deletion) catalogs, deletion repeat sizes range
from 0 to 5+, but for plotting and end-user documentation deletion repeat
sizes range from 1 to 6+.
</p>


<h3>Comments</h3>

<p>To add or change attributes of the catalog, you can use function
<code><a href="base.html#topic+attr">attr</a></code>. <br /> For example, <code>attr(catalog, "abundance")
&lt;- custom.abundance</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- c(system.file("extdata/Mutect-vcf",
                      "Mutect.GRCh37.s1.vcf",
                      package = "ICAMS"))
if (requireNamespace("BSgenome.Hsapiens.1000genomes.hs37d5", quietly = TRUE)) {
  catalogs &lt;- MutectVCFFilesToCatalog(file, ref.genome = "hg19",
                                      trans.ranges = trans.ranges.GRCh37,
                                      region = "genome")}
</code></pre>

<hr>
<h2 id='MutectVCFFilesToCatalogAndPlotToPdf'>Create SBS, DBS and Indel catalogs from Mutect VCF files and plot them to PDF</h2><span id='topic+MutectVCFFilesToCatalogAndPlotToPdf'></span>

<h3>Description</h3>

<p>Create 3 SBS catalogs (96, 192, 1536), 3 DBS catalogs (78, 136, 144) and
Indel catalog from the Mutect VCFs specified by <code>files</code> and plot them to
PDF
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MutectVCFFilesToCatalogAndPlotToPdf(
  files,
  ref.genome,
  trans.ranges = NULL,
  region = "unknown",
  names.of.VCFs = NULL,
  tumor.col.names = NA,
  output.file = "",
  flag.mismatches = 0,
  return.annotated.vcfs = FALSE,
  suppress.discarded.variants.warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MutectVCFFilesToCatalogAndPlotToPdf_+3A_files">files</code></td>
<td>
<p>Character vector of file paths to the Mutect VCF files.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToCatalogAndPlotToPdf_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToCatalogAndPlotToPdf_+3A_trans.ranges">trans.ranges</code></td>
<td>
<p>Optional. If <code>ref.genome</code> specifies one of the
<code>BSgenome</code> object
</p>

<ol>
<li> <p><code>BSgenome.Hsapiens.1000genomes.hs37d5</code>
</p>
</li>
<li> <p><code>BSgenome.Hsapiens.UCSC.hg38</code>
</p>
</li>
<li> <p><code>BSgenome.Mmusculus.UCSC.mm10</code>
</p>
</li></ol>

<p>then the function will infer <code>trans.ranges</code> automatically. Otherwise,
user will need to provide the necessary <code>trans.ranges</code>. Please refer to
<code><a href="#topic+TranscriptRanges">TranscriptRanges</a></code> for more details.
If <code>is.null(trans.ranges)</code> do not add transcript range
information.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToCatalogAndPlotToPdf_+3A_region">region</code></td>
<td>
<p>A character string designating a genomic region;
see <code><a href="#topic+as.catalog">as.catalog</a></code> and <code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToCatalogAndPlotToPdf_+3A_names.of.vcfs">names.of.VCFs</code></td>
<td>
<p>Optional. Character vector of names of the VCF files.
The order of names in <code>names.of.VCFs</code> should match the order of VCF
file paths in <code>files</code>. If <code>NULL</code>(default), this function will
remove all of the path up to and including the last path separator (if any)
in <code>files</code> and file paths without extensions (and the leading dot)
will be used as the names of the VCF files.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToCatalogAndPlotToPdf_+3A_tumor.col.names">tumor.col.names</code></td>
<td>
<p>Optional. Character vector of column names in VCFs
which contain the tumor sample information. The order of names in
<code>tumor.col.names</code> should match the order of VCFs specified in
<code>files</code>. If <code>tumor.col.names</code> is equal to <code>NA</code>(default),
this function will use the 10th column in all the VCFs to calculate VAFs.
See <code><a href="#topic+GetMutectVAF">GetMutectVAF</a></code> for more details.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToCatalogAndPlotToPdf_+3A_output.file">output.file</code></td>
<td>
<p>Optional. The base name of the PDF files to be produced;
multiple files will be generated, each ending in <code class="reqn">x</code><code>.pdf</code>, where
<code class="reqn">x</code> indicates the type of catalog plotted in the file.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToCatalogAndPlotToPdf_+3A_flag.mismatches">flag.mismatches</code></td>
<td>
<p>Deprecated. If there are ID variants whose <code>REF</code>
do not match the extracted sequence from <code>ref.genome</code>, the function
will automatically discard these variants and an element
<code>discarded.variants</code> will appear in the return value. See
<code><a href="#topic+AnnotateIDVCF">AnnotateIDVCF</a></code> for more details.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToCatalogAndPlotToPdf_+3A_return.annotated.vcfs">return.annotated.vcfs</code></td>
<td>
<p>Logical. Whether to return the annotated VCFs
with additional columns showing mutation class for each variant. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToCatalogAndPlotToPdf_+3A_suppress.discarded.variants.warnings">suppress.discarded.variants.warnings</code></td>
<td>
<p>Logical. Whether to suppress
warning messages showing information about the discarded variants. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code><a href="#topic+MutectVCFFilesToCatalog">MutectVCFFilesToCatalog</a></code> and
<code><a href="#topic+PlotCatalogToPdf">PlotCatalogToPdf</a></code>
</p>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>catSBS96</code>, <code>catSBS192</code>, <code>catSBS1536</code>: Matrix of
3 SBS catalogs (one each for 96, 192, and 1536).
</p>
</li>
<li> <p><code>catDBS78</code>, <code>catDBS136</code>, <code>catDBS144</code>: Matrix of
3 DBS catalogs (one each for 78, 136, and 144).
</p>
</li>
<li> <p><code>catID</code>: Matrix of ID (small insertion and deletion) catalog.
</p>
</li>
<li> <p><code>discarded.variants</code>: <strong>Non-NULL only if</strong> there are variants
that were excluded from the analysis. See the added extra column
<code>discarded.reason</code> for more details.
</p>
</li>
<li> <p><code>annotated.vcfs</code>:
<strong>Non-NULL only if</strong> <code>return.annotated.vcfs</code> = TRUE.
A list of elements:
</p>

<ul>
<li> <p><code>SBS</code>: SBS VCF annotated by <code><a href="#topic+AnnotateSBSVCF">AnnotateSBSVCF</a></code> with
three new columns <code>SBS96.class</code>, <code>SBS192.class</code> and
<code>SBS1536.class</code> showing the mutation class for each SBS variant.
</p>
</li>
<li> <p><code>DBS</code>: DBS VCF annotated by <code><a href="#topic+AnnotateDBSVCF">AnnotateDBSVCF</a></code> with
three new columns <code>DBS78.class</code>, <code>DBS136.class</code> and
<code>DBS144.class</code> showing the mutation class for each DBS variant.
</p>
</li>
<li> <p><code>ID</code>: ID VCF annotated by <code><a href="#topic+AnnotateIDVCF">AnnotateIDVCF</a></code> with one
new column <code>ID.class</code> showing the mutation class for each
ID variant.
</p>
</li></ul>

</li></ul>

<p>If <code>trans.ranges</code> is not provided by user and cannot be inferred by
ICAMS, SBS 192 and DBS 144 catalog will not be generated. Each catalog has
attributes added. See <code><a href="#topic+as.catalog">as.catalog</a></code> for more details.
</p>


<h3>ID classification</h3>

<p>See <a href="https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx">https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx</a>
for additional information on ID (small insertion and deletion) mutation
classification.
</p>
<p>See the documentation for <code><a href="#topic+Canonicalize1Del">Canonicalize1Del</a></code> which first handles
deletions in homopolymers, then handles deletions in simple repeats with
longer repeat units, (e.g. <code>CACACACA</code>, see
<code><a href="#topic+FindMaxRepeatDel">FindMaxRepeatDel</a></code>), and if the deletion is not in a simple
repeat, looks for microhomology (see <code><a href="#topic+FindDelMH">FindDelMH</a></code>).
</p>
<p>See the code for unexported function <code><a href="#topic+CanonicalizeID">CanonicalizeID</a></code>
and the functions it calls for handling of insertions.
</p>


<h3>Note</h3>

<p>SBS 192 and DBS 144 catalogs include only mutations in transcribed regions.
In ID (small insertion and deletion) catalogs, deletion repeat sizes range
from 0 to 5+, but for plotting and end-user documentation deletion repeat
sizes range from 1 to 6+.
</p>


<h3>Comments</h3>

<p>To add or change attributes of the catalog, you can use function
<code><a href="base.html#topic+attr">attr</a></code>. <br /> For example, <code>attr(catalog, "abundance")
&lt;- custom.abundance</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- c(system.file("extdata/Mutect-vcf",
                      "Mutect.GRCh37.s1.vcf",
                      package = "ICAMS"))
if (requireNamespace("BSgenome.Hsapiens.1000genomes.hs37d5", quietly = TRUE)) {
  catalogs &lt;-
    MutectVCFFilesToCatalogAndPlotToPdf(file, ref.genome = "hg19",
                                        trans.ranges = trans.ranges.GRCh37,
                                        region = "genome",
                                        output.file =
                                        file.path(tempdir(), "Mutect"))}
</code></pre>

<hr>
<h2 id='MutectVCFFilesToZipFile'>Create a zip file which contains catalogs and plot PDFs from Mutect VCF files</h2><span id='topic+MutectVCFFilesToZipFile'></span>

<h3>Description</h3>

<p>Create 3 SBS catalogs (96, 192, 1536), 3 DBS catalogs (78, 136, 144) and
Indel catalog from the Mutect VCFs specified by <code>dir</code>, save the catalogs
as CSV files, plot them to PDF and generate a zip archive of all the output files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MutectVCFFilesToZipFile(
  dir,
  zipfile,
  ref.genome,
  trans.ranges = NULL,
  region = "unknown",
  names.of.VCFs = NULL,
  tumor.col.names = NA,
  base.filename = "",
  flag.mismatches = 0,
  return.annotated.vcfs = FALSE,
  suppress.discarded.variants.warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MutectVCFFilesToZipFile_+3A_dir">dir</code></td>
<td>
<p>Pathname of the directory which contains <strong>only</strong> the Mutect
VCF files. Each Mutect VCF <strong>must</strong> have a file extension &quot;.vcf&quot; (case
insensitive) and share the <strong>same</strong> <code>ref.genome</code> and
<code>region</code>.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToZipFile_+3A_zipfile">zipfile</code></td>
<td>
<p>Pathname of the zip file to be created.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToZipFile_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToZipFile_+3A_trans.ranges">trans.ranges</code></td>
<td>
<p>Optional. If <code>ref.genome</code> specifies one of the
<code>BSgenome</code> object
</p>

<ol>
<li> <p><code>BSgenome.Hsapiens.1000genomes.hs37d5</code>
</p>
</li>
<li> <p><code>BSgenome.Hsapiens.UCSC.hg38</code>
</p>
</li>
<li> <p><code>BSgenome.Mmusculus.UCSC.mm10</code>
</p>
</li></ol>

<p>then the function will infer <code>trans.ranges</code> automatically. Otherwise,
user will need to provide the necessary <code>trans.ranges</code>. Please refer to
<code><a href="#topic+TranscriptRanges">TranscriptRanges</a></code> for more details.
If <code>is.null(trans.ranges)</code> do not add transcript range
information.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToZipFile_+3A_region">region</code></td>
<td>
<p>A character string designating a genomic region;
see <code><a href="#topic+as.catalog">as.catalog</a></code> and <code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToZipFile_+3A_names.of.vcfs">names.of.VCFs</code></td>
<td>
<p>Optional. Character vector of names of the VCF files.
The order of names in <code>names.of.VCFs</code> should match the order of VCFs
listed in <code>dir</code>. If <code>NULL</code>(default), this function will remove
all of the path up to and including the last path separator (if any) in
<code>dir</code> and file paths without extensions (and the leading dot) will be
used as the names of the VCF files.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToZipFile_+3A_tumor.col.names">tumor.col.names</code></td>
<td>
<p>Optional. Character vector of column names in VCFs which contain
the tumor sample information. The order of names in <code>tumor.col.names</code>
should match the order of VCFs listed in <code>dir</code>. If
<code>tumor.col.names</code> is equal to <code>NA</code>(default), this function will
use the 10th column in all the VCFs to calculate VAFs.
See <code><a href="#topic+GetMutectVAF">GetMutectVAF</a></code> for more details.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToZipFile_+3A_base.filename">base.filename</code></td>
<td>
<p>Optional. The base name of the CSV and PDF files to be
produced; multiple files will be generated, each ending in
<code class="reqn">x</code><code>.csv</code> or <code class="reqn">x</code><code>.pdf</code>, where <code class="reqn">x</code> indicates the type
of catalog.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToZipFile_+3A_flag.mismatches">flag.mismatches</code></td>
<td>
<p>Deprecated. If there are ID variants whose <code>REF</code>
do not match the extracted sequence from <code>ref.genome</code>, the function
will automatically discard these variants and an element
<code>discarded.variants</code> will appear in the return value. See
<code><a href="#topic+AnnotateIDVCF">AnnotateIDVCF</a></code> for more details.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToZipFile_+3A_return.annotated.vcfs">return.annotated.vcfs</code></td>
<td>
<p>Logical. Whether to return the annotated VCFs
with additional columns showing mutation class for each variant. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="MutectVCFFilesToZipFile_+3A_suppress.discarded.variants.warnings">suppress.discarded.variants.warnings</code></td>
<td>
<p>Logical. Whether to suppress
warning messages showing information about the discarded variants. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code><a href="#topic+MutectVCFFilesToCatalog">MutectVCFFilesToCatalog</a></code>,
<code><a href="#topic+PlotCatalogToPdf">PlotCatalogToPdf</a></code>, <code><a href="#topic+WriteCatalog">WriteCatalog</a></code> and
<code>zip::zipr</code>.
</p>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>catSBS96</code>, <code>catSBS192</code>, <code>catSBS1536</code>: Matrix of
3 SBS catalogs (one each for 96, 192, and 1536).
</p>
</li>
<li> <p><code>catDBS78</code>, <code>catDBS136</code>, <code>catDBS144</code>: Matrix of
3 DBS catalogs (one each for 78, 136, and 144).
</p>
</li>
<li> <p><code>catID</code>: Matrix of ID (small insertion and deletion) catalog.
</p>
</li>
<li> <p><code>discarded.variants</code>: <strong>Non-NULL only if</strong> there are variants
that were excluded from the analysis. See the added extra column
<code>discarded.reason</code> for more details.
</p>
</li>
<li> <p><code>annotated.vcfs</code>:
<strong>Non-NULL only if</strong> <code>return.annotated.vcfs</code> = TRUE.
A list of elements:
</p>

<ul>
<li> <p><code>SBS</code>: SBS VCF annotated by <code><a href="#topic+AnnotateSBSVCF">AnnotateSBSVCF</a></code> with
three new columns <code>SBS96.class</code>, <code>SBS192.class</code> and
<code>SBS1536.class</code> showing the mutation class for each SBS variant.
</p>
</li>
<li> <p><code>DBS</code>: DBS VCF annotated by <code><a href="#topic+AnnotateDBSVCF">AnnotateDBSVCF</a></code> with
three new columns <code>DBS78.class</code>, <code>DBS136.class</code> and
<code>DBS144.class</code> showing the mutation class for each DBS variant.
</p>
</li>
<li> <p><code>ID</code>: ID VCF annotated by <code><a href="#topic+AnnotateIDVCF">AnnotateIDVCF</a></code> with one
new column <code>ID.class</code> showing the mutation class for each
ID variant.
</p>
</li></ul>

</li></ul>

<p>If <code>trans.ranges</code> is not provided by user and cannot be inferred by
ICAMS, SBS 192 and DBS 144 catalog will not be generated. Each catalog has
attributes added. See <code><a href="#topic+as.catalog">as.catalog</a></code> for more details.
</p>


<h3>ID classification</h3>

<p>See <a href="https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx">https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx</a>
for additional information on ID (small insertion and deletion) mutation
classification.
</p>
<p>See the documentation for <code><a href="#topic+Canonicalize1Del">Canonicalize1Del</a></code> which first handles
deletions in homopolymers, then handles deletions in simple repeats with
longer repeat units, (e.g. <code>CACACACA</code>, see
<code><a href="#topic+FindMaxRepeatDel">FindMaxRepeatDel</a></code>), and if the deletion is not in a simple
repeat, looks for microhomology (see <code><a href="#topic+FindDelMH">FindDelMH</a></code>).
</p>
<p>See the code for unexported function <code><a href="#topic+CanonicalizeID">CanonicalizeID</a></code>
and the functions it calls for handling of insertions.
</p>


<h3>Note</h3>

<p>SBS 192 and DBS 144 catalogs include only mutations in transcribed regions.
In ID (small insertion and deletion) catalogs, deletion repeat sizes range
from 0 to 5+, but for plotting and end-user documentation deletion repeat
sizes range from 1 to 6+.
</p>


<h3>Comments</h3>

<p>To add or change attributes of the catalog, you can use function
<code><a href="base.html#topic+attr">attr</a></code>. <br /> For example, <code>attr(catalog, "abundance")
&lt;- custom.abundance</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dir &lt;- c(system.file("extdata/Mutect-vcf",
                     package = "ICAMS"))
if (requireNamespace("BSgenome.Hsapiens.1000genomes.hs37d5", quietly = TRUE)) {
  catalogs &lt;-
    MutectVCFFilesToZipFile(dir,
                            zipfile = file.path(tempdir(), "test.zip"),
                            ref.genome = "hg19",
                            trans.ranges = trans.ranges.GRCh37,
                            region = "genome",
                            base.filename = "Mutect")
  unlink(file.path(tempdir(), "test.zip"))}
</code></pre>

<hr>
<h2 id='NormalizeGenomeArg'>Take strings representing a genome and return the <code>BSgenome</code> object.</h2><span id='topic+NormalizeGenomeArg'></span>

<h3>Description</h3>

<p>Take strings representing a genome and return the <code>BSgenome</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NormalizeGenomeArg(ref.genome)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NormalizeGenomeArg_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>ref.genome</code> is 
a <code>BSgenome</code> object, return it.
Otherwise return the <code>BSgenome</code> object identified by the
string <code>ref.genome</code>.
</p>

<hr>
<h2 id='Plot96PartOfCompositeToPDF'>Plot the SBS96 part of a SignatureAnalyzer COMPOSITE signature or catalog</h2><span id='topic+Plot96PartOfCompositeToPDF'></span>

<h3>Description</h3>

<p>Plot the SBS96 part of a SignatureAnalyzer COMPOSITE signature or catalog
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot96PartOfCompositeToPDF(catalog, name, type = "density")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot96PartOfCompositeToPDF_+3A_catalog">catalog</code></td>
<td>
<p>Catalog or signature matrix</p>
</td></tr>
<tr><td><code id="Plot96PartOfCompositeToPDF_+3A_name">name</code></td>
<td>
<p>Name of file to print to.</p>
</td></tr>
<tr><td><code id="Plot96PartOfCompositeToPDF_+3A_type">type</code></td>
<td>
<p>See <code><a href="#topic+PlotCatalogToPdf">PlotCatalogToPdf</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='PlotCatalog'>Plot <strong>one</strong> spectrum or signature</h2><span id='topic+PlotCatalog'></span>

<h3>Description</h3>

<p>Plot the spectrum of <strong>one</strong> sample or plot <strong>one</strong> signature. The
type of graph is based on <code>attribute("catalog.type")</code> of the input catalog.
You can first use <code><a href="#topic+TransformCatalog">TransformCatalog</a></code> to get different types of
catalog and then do the plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotCatalog(
  catalog,
  plot.SBS12 = NULL,
  cex = NULL,
  grid = NULL,
  upper = NULL,
  xlabels = NULL,
  ylabels = NULL,
  ylim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotCatalog_+3A_catalog">catalog</code></td>
<td>
<p>A catalog as defined in <code><a href="#topic+ICAMS">ICAMS</a></code> with attributes
added. See <code><a href="#topic+as.catalog">as.catalog</a></code> for more details. <code>catalog</code> can
also be a numeric <code>matrix</code>, numeric <code>data.frame</code>, or a
<code>vector</code> denoting the mutation <strong>counts</strong>, but <strong>must</strong> be in the
correct row order used in <code><a href="#topic+ICAMS">ICAMS</a></code>. See
<code><a href="#topic+CatalogRowOrder">CatalogRowOrder</a></code> for more details. If <code>catalog</code> is a
<code>vector</code>, it will be converted to a 1-column <code>matrix</code> with
rownames taken from the element names of the <code>vector</code> and with column
name <code>"Unknown"</code>.</p>
</td></tr>
<tr><td><code id="PlotCatalog_+3A_plot.sbs12">plot.SBS12</code></td>
<td>
<p>Only meaningful for class <code>SBS192Catalog</code>; if <code>TRUE</code>,
generate an abbreviated plot of only SBS without context, i.e. 
C&gt;A, C&gt;G, C&gt;T, T&gt;A, T&gt;C, T&gt;G each on transcribed and untranscribed strands,
rather than SBS in trinucleotide context, e.g.
ACA &gt; AAA, ACA &gt; AGA, ..., TCT &gt; TAT, ... There are 12 bars in the graph.</p>
</td></tr>
<tr><td><code id="PlotCatalog_+3A_cex">cex</code></td>
<td>
<p>Has the usual meaning. Taken from <code>par("cex")</code> by default.
Only implemented for SBS96Catalog, SBS192Catalog and DBS144Catalog.</p>
</td></tr>
<tr><td><code id="PlotCatalog_+3A_grid">grid</code></td>
<td>
<p>A logical value indicating whether to draw grid lines. Only
implemented for SBS96Catalog, DBS78Catalog, IndelCatalog.</p>
</td></tr>
<tr><td><code id="PlotCatalog_+3A_upper">upper</code></td>
<td>
<p>A logical value indicating whether to draw horizontal lines and
the names of major mutation class on top of graph. Only implemented for
SBS96Catalog, DBS78Catalog, IndelCatalog.</p>
</td></tr>
<tr><td><code id="PlotCatalog_+3A_xlabels">xlabels</code></td>
<td>
<p>A logical value indicating whether to draw x axis labels. Only
implemented for SBS96Catalog, DBS78Catalog, IndelCatalog. If <code>FALSE</code> then plot x
axis tick marks for SBS96Catalog; set <code>par(tck = 0)</code> to suppress.</p>
</td></tr>
<tr><td><code id="PlotCatalog_+3A_ylabels">ylabels</code></td>
<td>
<p>A logical value indicating whether to draw y axis labels. Only
implemented for SBS96Catalog, DBS78Catalog, IndelCatalog.</p>
</td></tr>
<tr><td><code id="PlotCatalog_+3A_ylim">ylim</code></td>
<td>
<p>Has the usual meaning. Only implemented for SBS96Catalog and
IndelCatalog.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <strong>invisible</strong> list whose first element is a logic value
indicating whether the plot is successful. For <code>SBS96Catalog</code>,
<code>SBS192Catalog</code>, <code>DBS78Catalog</code>, <code>DBS144Catalog</code> and
<code>IndelCatalog</code>, the list will have a second element, which is a
numeric vector giving the coordinates of all the bar midpoints drawn,
useful for adding to the graph. For <strong>SBS192Catalog</strong> with &quot;counts&quot;
catalog.type and non-NULL abundance and <code>plot.SBS12 = TRUE</code>, the list
will have an additional element which is a list containing the strand bias
statistics.
</p>


<h3>Comments</h3>

<p>For <strong>SBS192Catalog</strong> with &quot;counts&quot; catalog.type and
non-NULL abundance and <code>plot.SBS12 = TRUE</code>, the strand bias statistics
are Benjamini-Hochberg q-values based on two-sided binomial tests of the
mutation counts on the transcribed and untranscribed strands relative to
the actual abundances of C and T on the transcribed strand. On the SBS12
plot, asterisks indicate q-values as follows *, <code class="reqn">Q&lt;0.05</code>; **,
<code class="reqn">Q&lt;0.01</code>; ***, <code class="reqn">Q&lt;0.001</code>.
</p>


<h3>Note</h3>

<p>The sizes of repeats involved in deletions range from 0 to 5+ in the
mutational-spectra and signature catalog rownames, but for plotting and
end-user documentation deletion repeat sizes range from 1 to 6+.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- system.file("extdata",
                    "strelka.regress.cat.sbs.96.csv",
                    package = "ICAMS")
catSBS96 &lt;- ReadCatalog(file)
colnames(catSBS96) &lt;- "sample"
PlotCatalog(catSBS96)
</code></pre>

<hr>
<h2 id='PlotCatalogToPdf'>Plot catalog to a PDF file</h2><span id='topic+PlotCatalogToPdf'></span>

<h3>Description</h3>

<p>Plot catalog to a PDF file. The type of graph is based on 
<code>attribute("catalog.type")</code> of the input catalog. You can first use
<code><a href="#topic+TransformCatalog">TransformCatalog</a></code> to get different types of catalog and then do
the plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotCatalogToPdf(
  catalog,
  file,
  plot.SBS12 = NULL,
  cex = NULL,
  grid = NULL,
  upper = NULL,
  xlabels = NULL,
  ylabels = NULL,
  ylim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotCatalogToPdf_+3A_catalog">catalog</code></td>
<td>
<p>A catalog as defined in <code><a href="#topic+ICAMS">ICAMS</a></code> with attributes
added. See <code><a href="#topic+as.catalog">as.catalog</a></code> for more details. <code>catalog</code> can
also be a numeric <code>matrix</code>, numeric <code>data.frame</code>, or a
<code>vector</code> denoting the mutation <strong>counts</strong>, but <strong>must</strong> be in the
correct row order used in <code><a href="#topic+ICAMS">ICAMS</a></code>. See
<code><a href="#topic+CatalogRowOrder">CatalogRowOrder</a></code> for more details. If <code>catalog</code> is a
<code>vector</code>, it will be converted to a 1-column <code>matrix</code> with
rownames taken from the element names of the <code>vector</code> and with column
name <code>"Unknown"</code>.</p>
</td></tr>
<tr><td><code id="PlotCatalogToPdf_+3A_file">file</code></td>
<td>
<p>The name of the PDF file to be produced.</p>
</td></tr>
<tr><td><code id="PlotCatalogToPdf_+3A_plot.sbs12">plot.SBS12</code></td>
<td>
<p>Only meaningful for class <code>SBS192Catalog</code>; if <code>TRUE</code>,
generate an abbreviated plot of only SBS without context, i.e. 
C&gt;A, C&gt;G, C&gt;T, T&gt;A, T&gt;C, T&gt;G each on transcribed and untranscribed strands,
rather than SBS in trinucleotide context, e.g.
ACA &gt; AAA, ACA &gt; AGA, ..., TCT &gt; TAT, ... There are 12 bars in the graph.</p>
</td></tr>
<tr><td><code id="PlotCatalogToPdf_+3A_cex">cex</code></td>
<td>
<p>Has the usual meaning. A default value has been used by the
program internally. Only implemented for SBS96Catalog, SBS192Catalog and
DBS144Catalog.</p>
</td></tr>
<tr><td><code id="PlotCatalogToPdf_+3A_grid">grid</code></td>
<td>
<p>A logical value indicating whether to draw grid lines. Only
implemented for SBS96Catalog, DBS78Catalog, IndelCatalog.</p>
</td></tr>
<tr><td><code id="PlotCatalogToPdf_+3A_upper">upper</code></td>
<td>
<p>A logical value indicating whether to draw horizontal lines and
the names of major mutation class on top of graph. Only implemented for
SBS96Catalog, DBS78Catalog, IndelCatalog.</p>
</td></tr>
<tr><td><code id="PlotCatalogToPdf_+3A_xlabels">xlabels</code></td>
<td>
<p>A logical value indicating whether to draw x axis labels. Only
implemented for SBS96Catalog, DBS78Catalog, IndelCatalog. If <code>FALSE</code> then plot x
axis tick marks for SBS96Catalog; set <code>par(tck = 0)</code> to suppress.</p>
</td></tr>
<tr><td><code id="PlotCatalogToPdf_+3A_ylabels">ylabels</code></td>
<td>
<p>A logical value indicating whether to draw y axis labels. Only
implemented for SBS96Catalog, DBS78Catalog, IndelCatalog.</p>
</td></tr>
<tr><td><code id="PlotCatalogToPdf_+3A_ylim">ylim</code></td>
<td>
<p>Has the usual meaning. Only implemented for SBS96Catalog and
IndelCatalog.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <strong>invisible</strong> list whose first element is a logic value
indicating whether the plot is successful. For <strong>SBS192Catalog</strong> with
&quot;counts&quot; catalog.type and non-null abundance and <code>plot.SBS12 = TRUE</code>,
the list will have a second element which is a list containing the strand
bias statistics.
</p>


<h3>Comments</h3>

<p>For <strong>SBS192Catalog</strong> with &quot;counts&quot; catalog.type and
non-NULL abundance and <code>plot.SBS12 = TRUE</code>, the strand bias statistics
are Benjamini-Hochberg q-values based on two-sided binomial tests of the
mutation counts on the transcribed and untranscribed strands relative to
the actual abundances of C and T on the transcribed strand. On the SBS12
plot, asterisks indicate q-values as follows *, <code class="reqn">Q&lt;0.05</code>; **,
<code class="reqn">Q&lt;0.01</code>; ***, <code class="reqn">Q&lt;0.001</code>.
</p>


<h3>Note</h3>

<p>The sizes of repeats involved in deletions range from 0 to 5+ in the
mutational-spectra and signature catalog rownames, but for plotting and
end-user documentation deletion repeat sizes range from 1 to 6+.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- system.file("extdata",
                    "strelka.regress.cat.sbs.96.csv",
                    package = "ICAMS")
catSBS96 &lt;- ReadCatalog(file)
colnames(catSBS96) &lt;- "sample"
PlotCatalogToPdf(catSBS96, file = file.path(tempdir(), "test.pdf"))
</code></pre>

<hr>
<h2 id='PlotPPM'>Plot position probability matrix (PPM) for *one* sample from a Variant Call Format
(VCF) file.</h2><span id='topic+PlotPPM'></span>

<h3>Description</h3>

<p>Plot position probability matrix (PPM) for *one* sample from a Variant Call Format
(VCF) file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotPPM(ppm, title)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotPPM_+3A_ppm">ppm</code></td>
<td>
<p>A position probability matrix (PPM) for *one* sample.</p>
</td></tr>
<tr><td><code id="PlotPPM_+3A_title">title</code></td>
<td>
<p>The main title of the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>invisible(TRUE)</code>
</p>

<hr>
<h2 id='PlotPPMToPdf'>Plot position probability matrices (PPM) to a PDF file</h2><span id='topic+PlotPPMToPdf'></span>

<h3>Description</h3>

<p>Plot position probability matrices (PPM) to a PDF file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotPPMToPdf(list.of.ppm, file, titles = names(list.of.ppm))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotPPMToPdf_+3A_list.of.ppm">list.of.ppm</code></td>
<td>
<p>A list of position probability matrices (PPM)</p>
</td></tr>
<tr><td><code id="PlotPPMToPdf_+3A_file">file</code></td>
<td>
<p>The name of the PDF file to be produced.</p>
</td></tr>
<tr><td><code id="PlotPPMToPdf_+3A_titles">titles</code></td>
<td>
<p>A vector of titles on top of each PPM plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>invisible(TRUE)</code>
</p>

<hr>
<h2 id='PlotTransBiasGeneExp'>Plot transcription strand bias with respect to gene expression values</h2><span id='topic+PlotTransBiasGeneExp'></span>

<h3>Description</h3>

<p>Plot transcription strand bias with respect to gene expression values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotTransBiasGeneExp(
  annotated.SBS.vcf,
  expression.data,
  Ensembl.gene.ID.col,
  expression.value.col,
  num.of.bins,
  plot.type,
  damaged.base = NULL,
  ymax = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotTransBiasGeneExp_+3A_annotated.sbs.vcf">annotated.SBS.vcf</code></td>
<td>
<p>An SBS VCF annotated by
<code><a href="#topic+AnnotateSBSVCF">AnnotateSBSVCF</a></code>. It <strong>must</strong> have transcript range
information added.</p>
</td></tr>
<tr><td><code id="PlotTransBiasGeneExp_+3A_expression.data">expression.data</code></td>
<td>
<p>A <code>data.table</code> which contains the
expression values of genes. <br /> See <code><a href="#topic+GeneExpressionData">GeneExpressionData</a></code> for more
details.</p>
</td></tr>
<tr><td><code id="PlotTransBiasGeneExp_+3A_ensembl.gene.id.col">Ensembl.gene.ID.col</code></td>
<td>
<p>Name of column which has the Ensembl gene ID
information in <code>expression.data</code>.</p>
</td></tr>
<tr><td><code id="PlotTransBiasGeneExp_+3A_expression.value.col">expression.value.col</code></td>
<td>
<p>Name of column which has the gene expression
values in <code>expression.data</code>.</p>
</td></tr>
<tr><td><code id="PlotTransBiasGeneExp_+3A_num.of.bins">num.of.bins</code></td>
<td>
<p>The number of bins that will be plotted on the graph.</p>
</td></tr>
<tr><td><code id="PlotTransBiasGeneExp_+3A_plot.type">plot.type</code></td>
<td>
<p>A character string indicating one mutation type to be
plotted. It should be one of &quot;C&gt;A&quot;, &quot;C&gt;G&quot;, &quot;C&gt;T&quot;, &quot;T&gt;A&quot;, &quot;T&gt;C&quot;, &quot;T&gt;G&quot;.</p>
</td></tr>
<tr><td><code id="PlotTransBiasGeneExp_+3A_damaged.base">damaged.base</code></td>
<td>
<p>One of <code>NULL</code>, <code>"purine"</code> or
<code>"pyrimidine"</code>. This function allocates approximately
equal numbers of mutations from <code>damaged.base</code> into
each of <code>num.of.bins</code> bin by expression level. E.g.
if <code>damaged.base</code> is <code>"purine"</code>, then mutations from
A and G will be allocated in approximately equal numbers to
each expression-level bin. The rationale for the name <code>damaged.base</code>
is that the direction of strand bias is a result of whether the damage
occurs on a purine or pyrimidine.
If <code>NULL</code>, the function attempts to infer the <code>damaged.base</code>
based on mutation counts.</p>
</td></tr>
<tr><td><code id="PlotTransBiasGeneExp_+3A_ymax">ymax</code></td>
<td>
<p>Limit for the y axis. If not specified, it defaults to NULL and
the y axis limit equals 1.5 times of the maximum mutation counts in a
specific mutation type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list whose first element is a logic value indicating whether the
plot is successful. The second element is a named numeric vector containing
the p-values printed on the plot.
</p>


<h3>Note</h3>

<p>The p-values are calculated by logistic regression using function
<code><a href="stats.html#topic+glm">glm</a></code>. The dependent variable is labeled &quot;1&quot; and &quot;0&quot; if
the mutation from <code>annotated.SBS.vcf</code> falls onto the untranscribed and
transcribed strand respectively. The independent variable is the binary
logarithm of the gene expression value from <code>expression.data</code> plus one,
i.e. <code class="reqn">log_2 (x + 1)</code> where <code class="reqn">x</code> stands for gene
expression value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- c(system.file("extdata/Strelka-SBS-vcf/",
                      "Strelka.SBS.GRCh37.s1.vcf",
                      package = "ICAMS"))
list.of.vcfs &lt;- ReadAndSplitStrelkaSBSVCFs(file)
SBS.vcf &lt;- list.of.vcfs$SBS.vcfs[[1]]             
if (requireNamespace("BSgenome.Hsapiens.1000genomes.hs37d5", quietly = TRUE)) {
  annotated.SBS.vcf &lt;- AnnotateSBSVCF(SBS.vcf, ref.genome = "hg19",
                                      trans.ranges = trans.ranges.GRCh37)
  PlotTransBiasGeneExp(annotated.SBS.vcf = annotated.SBS.vcf, 
                       expression.data = gene.expression.data.HepG2, 
                       Ensembl.gene.ID.col = "Ensembl.gene.ID", 
                       expression.value.col = "TPM", 
                       num.of.bins = 4, plot.type = "C&gt;A")
}
</code></pre>

<hr>
<h2 id='PlotTransBiasGeneExpToPdf'>Plot transcription strand bias with respect to gene expression values to a
PDF file</h2><span id='topic+PlotTransBiasGeneExpToPdf'></span>

<h3>Description</h3>

<p>Plot transcription strand bias with respect to gene expression values to a
PDF file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotTransBiasGeneExpToPdf(
  annotated.SBS.vcf,
  file,
  expression.data,
  Ensembl.gene.ID.col,
  expression.value.col,
  num.of.bins,
  plot.type = c("C&gt;A", "C&gt;G", "C&gt;T", "T&gt;A", "T&gt;C", "T&gt;G"),
  damaged.base = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotTransBiasGeneExpToPdf_+3A_annotated.sbs.vcf">annotated.SBS.vcf</code></td>
<td>
<p>An SBS VCF annotated by
<code><a href="#topic+AnnotateSBSVCF">AnnotateSBSVCF</a></code>. It <strong>must</strong> have transcript range
information added.</p>
</td></tr>
<tr><td><code id="PlotTransBiasGeneExpToPdf_+3A_file">file</code></td>
<td>
<p>The name of output file.</p>
</td></tr>
<tr><td><code id="PlotTransBiasGeneExpToPdf_+3A_expression.data">expression.data</code></td>
<td>
<p>A <code>data.table</code> which contains the
expression values of genes. <br /> See <code><a href="#topic+GeneExpressionData">GeneExpressionData</a></code> for more
details.</p>
</td></tr>
<tr><td><code id="PlotTransBiasGeneExpToPdf_+3A_ensembl.gene.id.col">Ensembl.gene.ID.col</code></td>
<td>
<p>Name of column which has the Ensembl gene ID
information in <code>expression.data</code>.</p>
</td></tr>
<tr><td><code id="PlotTransBiasGeneExpToPdf_+3A_expression.value.col">expression.value.col</code></td>
<td>
<p>Name of column which has the gene expression
values in <code>expression.data</code>.</p>
</td></tr>
<tr><td><code id="PlotTransBiasGeneExpToPdf_+3A_num.of.bins">num.of.bins</code></td>
<td>
<p>The number of bins that will be plotted on the graph.</p>
</td></tr>
<tr><td><code id="PlotTransBiasGeneExpToPdf_+3A_plot.type">plot.type</code></td>
<td>
<p>A vector of character indicating types to be plotted. It
can be one or more types from &quot;C&gt;A&quot;, &quot;C&gt;G&quot;, &quot;C&gt;T&quot;, &quot;T&gt;A&quot;, &quot;T&gt;C&quot;, &quot;T&gt;G&quot;.
The default is to print all the six mutation types.</p>
</td></tr>
<tr><td><code id="PlotTransBiasGeneExpToPdf_+3A_damaged.base">damaged.base</code></td>
<td>
<p>One of <code>NULL</code>, <code>"purine"</code> or
<code>"pyrimidine"</code>. This function allocates approximately
equal numbers of mutations from <code>damaged.base</code> into
each of <code>num.of.bins</code> bin by expression level. E.g.
if <code>damaged.base</code> is <code>"purine"</code>, then mutations from
A and G will be allocated in approximately equal numbers to
each expression-level bin. The rationale for the name <code>damaged.base</code>
is that the direction of strand bias is a result of whether the damage
occurs on a purine or pyrimidine.
If <code>NULL</code>, the function attempts to infer the <code>damaged.base</code>
based on mutation counts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list whose first element is a logic value indicating whether the
plot is successful. The second element is a named numeric vector containing
the p-values printed on the plot.
</p>


<h3>Note</h3>

<p>The p-values are calculated by logistic regression using function
<code><a href="stats.html#topic+glm">glm</a></code>. The dependent variable is labeled &quot;1&quot; and &quot;0&quot; if
the mutation from <code>annotated.SBS.vcf</code> falls onto the untranscribed and
transcribed strand respectively. The independent variable is the binary
logarithm of the gene expression value from <code>expression.data</code> plus one,
i.e. <code class="reqn">log_2 (x + 1)</code> where <code class="reqn">x</code> stands for gene
expression value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- c(system.file("extdata/Strelka-SBS-vcf/",
                      "Strelka.SBS.GRCh37.s1.vcf",
                      package = "ICAMS"))
list.of.vcfs &lt;- ReadAndSplitStrelkaSBSVCFs(file)
SBS.vcf &lt;- list.of.vcfs$SBS.vcfs[[1]]             
if (requireNamespace("BSgenome.Hsapiens.1000genomes.hs37d5", quietly = TRUE)) {
  annotated.SBS.vcf &lt;- AnnotateSBSVCF(SBS.vcf, ref.genome = "hg19",
                                      trans.ranges = trans.ranges.GRCh37)
  PlotTransBiasGeneExpToPdf(annotated.SBS.vcf = annotated.SBS.vcf, 
                            expression.data = gene.expression.data.HepG2, 
                            Ensembl.gene.ID.col = "Ensembl.gene.ID", 
                            expression.value.col = "TPM", 
                            num.of.bins = 4, 
                            plot.type = c("C&gt;A","C&gt;G","C&gt;T","T&gt;A","T&gt;C"), 
                            file = file.path(tempdir(), "test.pdf"))
}
</code></pre>

<hr>
<h2 id='ReadAndSplitMutectVCFs'>Read and split Mutect VCF files</h2><span id='topic+ReadAndSplitMutectVCFs'></span>

<h3>Description</h3>

<p>Read and split Mutect VCF files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadAndSplitMutectVCFs(
  files,
  names.of.VCFs = NULL,
  tumor.col.names = NA,
  suppress.discarded.variants.warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ReadAndSplitMutectVCFs_+3A_files">files</code></td>
<td>
<p>Character vector of file paths to the Mutect VCF files.</p>
</td></tr>
<tr><td><code id="ReadAndSplitMutectVCFs_+3A_names.of.vcfs">names.of.VCFs</code></td>
<td>
<p>Optional. Character vector of names of the VCF files.
The order of names in <code>names.of.VCFs</code> should match the order of VCF
file paths in <code>files</code>. If <code>NULL</code>(default), this function will
remove all of the path up to and including the last path separator (if any)
in <code>files</code> and file paths without extensions (and the leading dot)
will be used as the names of the VCF files.</p>
</td></tr>
<tr><td><code id="ReadAndSplitMutectVCFs_+3A_tumor.col.names">tumor.col.names</code></td>
<td>
<p>Optional. Character vector of column names in VCFs
which contain the tumor sample information. The order of names in
<code>tumor.col.names</code> should match the order of VCFs specified in
<code>files</code>. If <code>tumor.col.names</code> is equal to <code>NA</code>(default),
this function will use the 10th column in all the VCFs to calculate VAFs.
See <code><a href="#topic+GetMutectVAF">GetMutectVAF</a></code> for more details.</p>
</td></tr>
<tr><td><code id="ReadAndSplitMutectVCFs_+3A_suppress.discarded.variants.warnings">suppress.discarded.variants.warnings</code></td>
<td>
<p>Logical. Whether to suppress
warning messages showing information about the discarded variants. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>SBS</code>: List of VCFs with only single base substitutions.
</p>
</li>
<li> <p><code>DBS</code>: List of VCFs with only doublet base substitutions as called
by Mutect.
</p>
</li>
<li> <p><code>ID</code>: List of VCFs with only small insertions and deletions.
</p>
</li>
<li> <p><code>discarded.variants</code>: <strong>Non-NULL only if</strong> there are variants
that were excluded from the analysis. See the added extra column
<code>discarded.reason</code> for more details.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+MutectVCFFilesToCatalog">MutectVCFFilesToCatalog</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- c(system.file("extdata/Mutect-vcf",
                      "Mutect.GRCh37.s1.vcf",
                      package = "ICAMS"))
list.of.vcfs &lt;- ReadAndSplitMutectVCFs(file)
</code></pre>

<hr>
<h2 id='ReadAndSplitStrelkaSBSVCFs'>Read and split Strelka SBS VCF files</h2><span id='topic+ReadAndSplitStrelkaSBSVCFs'></span>

<h3>Description</h3>

<p>The function will find and merge adjacent SBS pairs into DBS if their VAFs
are very similar. The default threshold value for VAF is 0.02.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadAndSplitStrelkaSBSVCFs(
  files,
  names.of.VCFs = NULL,
  suppress.discarded.variants.warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ReadAndSplitStrelkaSBSVCFs_+3A_files">files</code></td>
<td>
<p>Character vector of file paths to the Strelka SBS VCF files.</p>
</td></tr>
<tr><td><code id="ReadAndSplitStrelkaSBSVCFs_+3A_names.of.vcfs">names.of.VCFs</code></td>
<td>
<p>Optional. Character vector of names of the VCF files.
The order of names in <code>names.of.VCFs</code> should match the order of VCF
file paths in <code>files</code>. If <code>NULL</code>(default), this function will
remove all of the path up to and including the last path separator (if any)
in <code>files</code> and file paths without extensions (and the leading dot)
will be used as the names of the VCF files.</p>
</td></tr>
<tr><td><code id="ReadAndSplitStrelkaSBSVCFs_+3A_suppress.discarded.variants.warnings">suppress.discarded.variants.warnings</code></td>
<td>
<p>Logical. Whether to suppress
warning messages showing information about the discarded variants. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of elements as follows:
</p>

<ul>
<li> <p><code>SBS.vcfs</code>: List of data.frames of pure SBS mutations &ndash; no DBS or
3+BS mutations.
</p>
</li>
<li> <p><code>DBS.vcfs</code>: List of data.frames of pure DBS mutations &ndash; no SBS or
3+BS mutations.
</p>
</li>
<li> <p><code>discarded.variants</code>: <strong>Non-NULL only if</strong> there are variants
that were excluded from the analysis. See the added extra column
<code>discarded.reason</code> for more details.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+StrelkaSBSVCFFilesToCatalog">StrelkaSBSVCFFilesToCatalog</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- c(system.file("extdata/Strelka-SBS-vcf",
                      "Strelka.SBS.GRCh37.s1.vcf",
                      package = "ICAMS"))
list.of.vcfs &lt;- ReadAndSplitStrelkaSBSVCFs(file)
</code></pre>

<hr>
<h2 id='ReadAndSplitVCFs'>Read and split VCF files</h2><span id='topic+ReadAndSplitVCFs'></span>

<h3>Description</h3>

<p>Read and split VCF files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadAndSplitVCFs(
  files,
  variant.caller = "unknown",
  num.of.cores = 1,
  names.of.VCFs = NULL,
  tumor.col.names = NA,
  filter.status = NULL,
  get.vaf.function = NULL,
  ...,
  max.vaf.diff = 0.02,
  suppress.discarded.variants.warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ReadAndSplitVCFs_+3A_files">files</code></td>
<td>
<p>Character vector of file paths to the VCF files.</p>
</td></tr>
<tr><td><code id="ReadAndSplitVCFs_+3A_variant.caller">variant.caller</code></td>
<td>
<p>Name of the variant caller that produces the VCF, can
be either <code>"strelka"</code>, <code>"mutect"</code>, <code>"freebayes"</code> or
<code>"unknown"</code>. This information is needed to calculate the VAFs (variant
allele frequencies). If variant caller is <code>"unknown"</code>(default) and
<code>get.vaf.function</code> is NULL, then VAF and read depth will be NAs. If
variant caller is <code>"mutect"</code>, do <strong>not</strong> merge SBSs into DBS.</p>
</td></tr>
<tr><td><code id="ReadAndSplitVCFs_+3A_num.of.cores">num.of.cores</code></td>
<td>
<p>The number of cores to use. Not available on Windows
unless <code>num.of.cores = 1</code>.</p>
</td></tr>
<tr><td><code id="ReadAndSplitVCFs_+3A_names.of.vcfs">names.of.VCFs</code></td>
<td>
<p>Character vector of names of the VCF files. The order
of names in <code>names.of.VCFs</code> should match the order of VCF file paths
in <code>files</code>. If <code>NULL</code>(default), this function will remove all of
the path up to and including the last path separator (if any) and file
paths without extensions (and the leading dot) will be used as the names of
the VCF files.</p>
</td></tr>
<tr><td><code id="ReadAndSplitVCFs_+3A_tumor.col.names">tumor.col.names</code></td>
<td>
<p>Optional. Only applicable to <strong>Mutect</strong> VCFs.
Character vector of column names in <strong>Mutect</strong> VCFs which contain the
tumor sample information. The order of names in <code>tumor.col.names</code>
should match the order of <strong>Mutect</strong> VCFs specified in <code>files</code>.
If <code>tumor.col.names</code> is equal to <code>NA</code>(default), this function
will use the 10th column in all the <strong>Mutect</strong> VCFs to calculate VAFs.
See <code><a href="#topic+GetMutectVAF">GetMutectVAF</a></code> for more details.</p>
</td></tr>
<tr><td><code id="ReadAndSplitVCFs_+3A_filter.status">filter.status</code></td>
<td>
<p>The status indicating a variant has passed all filters.
An example would be <code>"PASS"</code>. Variants which don't have the specified
<code>filter.status</code> in the <code>FILTER</code> column in VCF will be removed. If
<code>NULL</code>(default), no variants will be removed from the original VCF.</p>
</td></tr>
<tr><td><code id="ReadAndSplitVCFs_+3A_get.vaf.function">get.vaf.function</code></td>
<td>
<p>Optional. Only applicable when <code>variant.caller</code> is
<strong>&quot;unknown&quot;</strong>. Function to calculate VAF(variant allele frequency) and read
depth information from original VCF. See <code><a href="#topic+GetMutectVAF">GetMutectVAF</a></code> as an example.
If <code>NULL</code>(default) and <code>variant.caller</code> is &quot;unknown&quot;, then VAF
and read depth will be NAs.</p>
</td></tr>
<tr><td><code id="ReadAndSplitVCFs_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code>get.vaf.function</code>.</p>
</td></tr>
<tr><td><code id="ReadAndSplitVCFs_+3A_max.vaf.diff">max.vaf.diff</code></td>
<td>
<p><strong>Not</strong> applicable if <code>variant.caller =
  "mutect"</code>. The maximum difference of VAF, default value is 0.02. If the
absolute difference of VAFs for adjacent SBSs is bigger than <code>max.vaf.diff</code>,
then these adjacent SBSs are likely to be &quot;merely&quot; asynchronous single base
mutations, opposed to a simultaneous doublet mutation or variants involving
more than two consecutive bases.</p>
</td></tr>
<tr><td><code id="ReadAndSplitVCFs_+3A_suppress.discarded.variants.warnings">suppress.discarded.variants.warnings</code></td>
<td>
<p>Logical. Whether to suppress
warning messages showing information about the discarded variants. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>SBS</code>: List of VCFs with only single base substitutions.
</p>
</li>
<li> <p><code>DBS</code>: List of VCFs with only doublet base substitutions.
</p>
</li>
<li> <p><code>ID</code>: List of VCFs with only small insertions and deletions.
</p>
</li>
<li> <p><code>discarded.variants</code>: <strong>Non-NULL only if</strong> there are variants
that were excluded from the analysis. See the added extra column
<code>discarded.reason</code> for more details.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+VCFsToCatalogs">VCFsToCatalogs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- c(system.file("extdata/Mutect-vcf",
                      "Mutect.GRCh37.s1.vcf",
                      package = "ICAMS"))
list.of.vcfs &lt;- ReadAndSplitVCFs(file, variant.caller = "mutect")
</code></pre>

<hr>
<h2 id='ReadBedRanges'>Read chromosome and position information from a bed format file.</h2><span id='topic+ReadBedRanges'></span>

<h3>Description</h3>

<p>Read chromosome and position information from a bed format file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadBedRanges(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ReadBedRanges_+3A_file">file</code></td>
<td>
<p>Path to the file in bed format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table keyed by chrom, start, and end. It uses one-based
coordinates.
</p>

<hr>
<h2 id='ReadCatalog'>Read catalog</h2><span id='topic+ReadCatalog'></span>

<h3>Description</h3>

<p>Read a catalog in standardized format from path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadCatalog(
  file,
  ref.genome = NULL,
  region = "unknown",
  catalog.type = "counts",
  strict = NULL,
  stop.on.error = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ReadCatalog_+3A_file">file</code></td>
<td>
<p>Path to a catalog on disk in a standardized format.
The recognized formats are:
</p>

<ul>
<li><p> ICAMS formatted SBS96, SBS192, SBS1536, DBS78, DBS136, DBS144, ID
(see <code><a href="#topic+CatalogRowOrder">CatalogRowOrder</a></code>).
</p>
</li>
<li><p> SigProfiler-formatted SBS96, DBS78 and ID83 catalogs;
see <a href="https://github.com/AlexandrovLab/SigProfilerExtractor">https://github.com/AlexandrovLab/SigProfilerExtractor</a>.
</p>
</li>
<li><p> COSMIC-formatted SBS96, SBS192 (a.k.a. TSB192),
DBS78, ID83 catalogs;
see <a href="https://cancer.sanger.ac.uk/signatures/">https://cancer.sanger.ac.uk/signatures/</a>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ReadCatalog_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="ReadCatalog_+3A_region">region</code></td>
<td>
<p>region A character string designating a genomic region;
see <code><a href="#topic+as.catalog">as.catalog</a></code> and <code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="ReadCatalog_+3A_catalog.type">catalog.type</code></td>
<td>
<p>One of &quot;counts&quot;, &quot;density&quot;, &quot;counts.signature&quot;,
&quot;density.signature&quot;.</p>
</td></tr>
<tr><td><code id="ReadCatalog_+3A_strict">strict</code></td>
<td>
<p>Ignored and deprecated.</p>
</td></tr>
<tr><td><code id="ReadCatalog_+3A_stop.on.error">stop.on.error</code></td>
<td>
<p>If TRUE, call <code>stop</code> on error; otherwise
return a 1-column matrix of NA's with the attribute &quot;error&quot;
containing error information. The number of rows may not
be the correct number for the expected catalog type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See also <code><a href="#topic+WriteCatalog">WriteCatalog</a></code>
</p>


<h3>Value</h3>

<p>A catalog as an S3 object; see <code><a href="#topic+as.catalog">as.catalog</a></code>.
</p>


<h3>Comments</h3>

<p>To add or change attributes of the catalog, you can use function
<code><a href="base.html#topic+attr">attr</a></code>. <br /> For example, <code>attr(catalog, "abundance")
&lt;- custom.abundance</code>.
</p>


<h3>Note</h3>

<p>In ID (small insertion and deletion) catalogs, deletion repeat sizes
range from 0 to 5+, but for plotting and end-user documentation
deletion repeat sizes range from 1 to 6+.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- system.file("extdata",
                    "strelka.regress.cat.sbs.96.csv",
                    package = "ICAMS")
catSBS96 &lt;- ReadCatalog(file)

</code></pre>

<hr>
<h2 id='ReadCatalogErrReturn'>Get error message and either stop or create a null error output for read catalog</h2><span id='topic+ReadCatalogErrReturn'></span>

<h3>Description</h3>

<p>Get error message and either stop or create a null error output for read catalog
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadCatalogErrReturn(err.info, nrow, stop.on.error = TRUE, do.message = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ReadCatalogErrReturn_+3A_err.info">err.info</code></td>
<td>
<p>The information passed to the <code>tryCatch</code> <code>error</code>
function argument.</p>
</td></tr>
<tr><td><code id="ReadCatalogErrReturn_+3A_nrow">nrow</code></td>
<td>
<p>The number of rows to put in the 1-column NA return matrix.</p>
</td></tr>
<tr><td><code id="ReadCatalogErrReturn_+3A_stop.on.error">stop.on.error</code></td>
<td>
<p>If <code>TRUE</code> then call <code>stop()</code>.</p>
</td></tr>
<tr><td><code id="ReadCatalogErrReturn_+3A_do.message">do.message</code></td>
<td>
<p>If <code>TRUE</code> then <code>message</code> the error information.</p>
</td></tr>
</table>

<hr>
<h2 id='ReadCatalogInternal'>Internal read catalog function to be wrapped in a tryCatch</h2><span id='topic+ReadCatalogInternal'></span>

<h3>Description</h3>

<p>Internal read catalog function to be wrapped in a tryCatch
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadCatalogInternal(
  file,
  ref.genome = NULL,
  region = "unknown",
  catalog.type = "counts"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ReadCatalogInternal_+3A_file">file</code></td>
<td>
<p>Path to a catalog on disk in a standardized format.
The recognized formats are:
</p>

<ul>
<li><p> ICAMS formatted SBS96, SBS192, SBS1536, DBS78, DBS136, DBS144, ID
(see <code><a href="#topic+CatalogRowOrder">CatalogRowOrder</a></code>).
</p>
</li>
<li><p> SigProfiler-formatted SBS96, DBS78 and ID83 catalogs;
see <a href="https://github.com/AlexandrovLab/SigProfilerExtractor">https://github.com/AlexandrovLab/SigProfilerExtractor</a>.
</p>
</li>
<li><p> COSMIC-formatted SBS96, SBS192 (a.k.a. TSB192),
DBS78, ID83 catalogs;
see <a href="https://cancer.sanger.ac.uk/signatures/">https://cancer.sanger.ac.uk/signatures/</a>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ReadCatalogInternal_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="ReadCatalogInternal_+3A_region">region</code></td>
<td>
<p>region A character string designating a genomic region;
see <code><a href="#topic+as.catalog">as.catalog</a></code> and <code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="ReadCatalogInternal_+3A_catalog.type">catalog.type</code></td>
<td>
<p>One of &quot;counts&quot;, &quot;density&quot;, &quot;counts.signature&quot;,
&quot;density.signature&quot;.</p>
</td></tr>
</table>

<hr>
<h2 id='ReadDukeNUSCat192'>Read a 192-channel spectra (or signature) catalog in Duke-NUS format</h2><span id='topic+ReadDukeNUSCat192'></span>

<h3>Description</h3>

<p>WARNING: will not work with <code>region = "genome"</code>. For this
you must first read with <code>region = "unknown"</code>, then
convert the <code>cat96</code> return to <code>"genome"</code> and
ignore the <code>cat192</code> return, which is nonsensical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadDukeNUSCat192(
  file,
  ref.genome = NULL,
  region = "unknown",
  catalog.type = "counts",
  abundance = NULL
)
</code></pre>


<h3>Details</h3>

<p>The file needs to have the column names Before	Ref	After	Var
in the first 4 columns
</p>


<h3>Value</h3>

<p>A list with two elements
</p>

<hr>
<h2 id='ReadMutectVCF'>Read in the data lines of a Variant Call Format (VCF) file created by Mutect</h2><span id='topic+ReadMutectVCF'></span>

<h3>Description</h3>

<p>Read in the data lines of a Variant Call Format (VCF) file created by Mutect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadMutectVCF(file, name.of.VCF = NULL, tumor.col.name = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ReadMutectVCF_+3A_file">file</code></td>
<td>
<p>The name/path of the VCF file, or a complete URL.</p>
</td></tr>
<tr><td><code id="ReadMutectVCF_+3A_name.of.vcf">name.of.VCF</code></td>
<td>
<p>Name of the VCF file. If <code>NULL</code>(default), this
function will remove all of the path up to and including the last path
separator (if any) in <code>file</code> and file path without extensions (and the
leading dot) will be used as the name of the VCF file.</p>
</td></tr>
<tr><td><code id="ReadMutectVCF_+3A_tumor.col.name">tumor.col.name</code></td>
<td>
<p>Name of the column in VCF which contains the tumor
sample information. It <strong>must</strong> have quotation marks. If
<code>tumor.col.name</code> is equal to <code>NA</code>(default), this function will
use the 10th column to calculate VAFs. See <code><a href="#topic+GetMutectVAF">GetMutectVAF</a></code> for
more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame storing data lines of a VCF file with two
additional columns added which contain the VAF(variant allele frequency)
and read depth information.
</p>

<hr>
<h2 id='ReadMutectVCFs'>Read Mutect VCF files.</h2><span id='topic+ReadMutectVCFs'></span>

<h3>Description</h3>

<p>Read Mutect VCF files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadMutectVCFs(files, names.of.VCFs = NULL, tumor.col.names = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ReadMutectVCFs_+3A_files">files</code></td>
<td>
<p>Character vector of file paths to the VCF files.</p>
</td></tr>
<tr><td><code id="ReadMutectVCFs_+3A_names.of.vcfs">names.of.VCFs</code></td>
<td>
<p>Character vector of names of the VCF files. The order of
names in <code>names.of.VCFs</code> should match the order of VCF file paths in
<code>files</code>. If <code>NULL</code>(default), this function will remove all of the
path up to and including the last path separator (if any) in <code>files</code>
and file paths without extensions (and the leading dot) will be used as the
names of the VCF files.</p>
</td></tr>
<tr><td><code id="ReadMutectVCFs_+3A_tumor.col.names">tumor.col.names</code></td>
<td>
<p>Character vector of column names in VCFs which contain
the tumor sample information. The order of names in <code>tumor.col.names</code>
should match the order of VCFs specified in <code>files</code>. If
<code>tumor.col.names</code> is equal to <code>NA</code>(default), this function will
use the 10th column in all the VCFs to calculate VAFs.
See <code><a href="#topic+GetMutectVAF">GetMutectVAF</a></code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data frames which store data lines of VCF files
with two additional columns added which contain the VAF(variant allele
frequency) and read depth information.
</p>

<hr>
<h2 id='ReadStapleGT96SBS'>Read a 96-channel spectra (or signature) catalog where rownames are e.g. &quot;A[C&gt;A]T&quot;</h2><span id='topic+ReadStapleGT96SBS'></span>

<h3>Description</h3>

<p>The file needs to have the rownames in the first column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadStapleGT96SBS(
  file,
  ref.genome = NULL,
  region = "unknown",
  catalog.type = "counts",
  abundance = NULL,
  sep = "\t"
)
</code></pre>

<hr>
<h2 id='ReadStrelkaIDVCF'>Read in the data lines of an ID VCF created by Strelka version 1</h2><span id='topic+ReadStrelkaIDVCF'></span>

<h3>Description</h3>

<p>Read in the data lines of an ID VCF created by Strelka version 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadStrelkaIDVCF(file, name.of.VCF = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ReadStrelkaIDVCF_+3A_file">file</code></td>
<td>
<p>The name/path of the VCF file, or a complete URL.</p>
</td></tr>
<tr><td><code id="ReadStrelkaIDVCF_+3A_name.of.vcf">name.of.VCF</code></td>
<td>
<p>Name of the VCF file. If <code>NULL</code>(default), this
function will remove all of the path up to and including the last path
separator (if any) in <code>file</code> and file path without extensions (and the
leading dot) will be used as the name of the VCF file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame storing data lines of the VCF file.
</p>


<h3>Note</h3>

<p>In ID (small insertion and deletion) catalogs, deletion repeat sizes range
from 0 to 5+, but for plotting and end-user documentation deletion repeat
sizes range from 1 to 6+.
</p>

<hr>
<h2 id='ReadStrelkaIDVCFs'>Read Strelka ID (small insertion and deletion) VCF files</h2><span id='topic+ReadStrelkaIDVCFs'></span>

<h3>Description</h3>

<p>Read Strelka ID (small insertion and deletion) VCF files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadStrelkaIDVCFs(files, names.of.VCFs = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ReadStrelkaIDVCFs_+3A_files">files</code></td>
<td>
<p>Character vector of file paths to the VCF files.</p>
</td></tr>
<tr><td><code id="ReadStrelkaIDVCFs_+3A_names.of.vcfs">names.of.VCFs</code></td>
<td>
<p>Character vector of names of the VCF files. The order of
names in <code>names.of.VCFs</code> should match the order of VCF file paths in
<code>files</code>. If <code>NULL</code>(default), this function will remove all of the
path up to and including the last path separator (if any) in <code>files</code>
and file paths without extensions (and the leading dot) will be used as the
names of the VCF files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data frames containing data lines of the VCF files.
</p>


<h3>Note</h3>

<p>In ID (small insertion and deletion) catalogs, deletion repeat sizes range
from 0 to 5+, but for plotting and end-user documentation deletion repeat
sizes range from 1 to 6+.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+StrelkaIDVCFFilesToCatalog">StrelkaIDVCFFilesToCatalog</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- c(system.file("extdata/Strelka-ID-vcf",
                      "Strelka.ID.GRCh37.s1.vcf",
                      package = "ICAMS"))
list.of.vcfs &lt;- ReadStrelkaIDVCFs(file)
</code></pre>

<hr>
<h2 id='ReadStrelkaSBSVCF'>Read in the data lines of an SBS VCF created by Strelka version 1</h2><span id='topic+ReadStrelkaSBSVCF'></span>

<h3>Description</h3>

<p>Read in the data lines of an SBS VCF created by Strelka version 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadStrelkaSBSVCF(file, name.of.VCF = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ReadStrelkaSBSVCF_+3A_file">file</code></td>
<td>
<p>The name/path of the VCF file, or a complete URL.</p>
</td></tr>
<tr><td><code id="ReadStrelkaSBSVCF_+3A_name.of.vcf">name.of.VCF</code></td>
<td>
<p>Name of the VCF file. If <code>NULL</code>(default), this
function will remove all of the path up to and including the last path
separator (if any) in <code>file</code> and file path without extensions (and the
leading dot) will be used as the name of the VCF file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame storing data lines of a VCF file with two
additional columns added which contain the VAF(variant allele frequency)
and read depth information.
</p>

<hr>
<h2 id='ReadStrelkaSBSVCFs'>Read Strelka SBS (single base substitutions) VCF files.</h2><span id='topic+ReadStrelkaSBSVCFs'></span>

<h3>Description</h3>

<p>Read Strelka SBS (single base substitutions) VCF files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadStrelkaSBSVCFs(files, names.of.VCFs = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ReadStrelkaSBSVCFs_+3A_files">files</code></td>
<td>
<p>Character vector of file paths to the VCF files.</p>
</td></tr>
<tr><td><code id="ReadStrelkaSBSVCFs_+3A_names.of.vcfs">names.of.VCFs</code></td>
<td>
<p>Character vector of names of the VCF files. The order of
names in <code>names.of.VCFs</code> should match the order of VCF file paths in
<code>files</code>. If <code>NULL</code>(default), this function will remove all of the
path up to and including the last path separator (if any) in <code>files</code>
and file paths without extensions (and the leading dot) will be used as the
names of the VCF files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data frames which store data lines of VCF files
with two additional columns added which contain the VAF(variant allele
frequency) and read depth information.
</p>

<hr>
<h2 id='ReadTranscriptRanges'>Read transcript ranges and strand information from a gff3 format file.
Use this one for the new, cut down gff3 file (2018 11 24)</h2><span id='topic+ReadTranscriptRanges'></span>

<h3>Description</h3>

<p>Read transcript ranges and strand information from a gff3 format file.
Use this one for the new, cut down gff3 file (2018 11 24)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadTranscriptRanges(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ReadTranscriptRanges_+3A_file">file</code></td>
<td>
<p>Path to the file with the transcript information with 1-based
start end positions of genomic ranges.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table keyed by chrom, start, and end.
</p>

<hr>
<h2 id='ReadVCF'>Read in the data lines of a Variant Call Format (VCF) file</h2><span id='topic+ReadVCF'></span>

<h3>Description</h3>

<p>Read in the data lines of a Variant Call Format (VCF) file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadVCF(
  file,
  variant.caller = "unknown",
  name.of.VCF = NULL,
  tumor.col.name = NA,
  filter.status = NULL,
  get.vaf.function = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ReadVCF_+3A_file">file</code></td>
<td>
<p>The name/path of the VCF file, or a complete URL.</p>
</td></tr>
<tr><td><code id="ReadVCF_+3A_variant.caller">variant.caller</code></td>
<td>
<p>Name of the variant caller that produces the VCF, can
be either <code>"strelka"</code>, <code>"mutect"</code>, <code>"freebayes"</code> or
<code>"unknown"</code>. This information is needed to calculate the VAFs (variant
allele frequencies). If <code>"unknown"</code>(default) and
<code>get.vaf.function</code> is NULL, then VAF and read depth will be NAs.</p>
</td></tr>
<tr><td><code id="ReadVCF_+3A_name.of.vcf">name.of.VCF</code></td>
<td>
<p>Name of the VCF file. If <code>NULL</code>(default), this
function will remove all of the path up to and including the last path
separator (if any) in <code>file</code> and file path without extensions (and the
leading dot) will be used as the name of the VCF file.</p>
</td></tr>
<tr><td><code id="ReadVCF_+3A_tumor.col.name">tumor.col.name</code></td>
<td>
<p>Optional. Only applicable to <strong>Mutect</strong> VCF. Name
of the column in <strong>Mutect</strong> VCF which contains the tumor sample
information. It <strong>must</strong> have quotation marks. If
<code>tumor.col.name</code> is equal to <code>NA</code>(default), this function will
use the 10th column to calculate VAFs. See <code><a href="#topic+GetMutectVAF">GetMutectVAF</a></code> for
more details.</p>
</td></tr>
<tr><td><code id="ReadVCF_+3A_filter.status">filter.status</code></td>
<td>
<p>The status indicating a variant has passed all filters.
An example would be <code>"PASS"</code>. Variants which don't have the specified
<code>filter.status</code> in the <code>FILTER</code> column in VCF will be removed. If
<code>NULL</code>(default), no variants will be removed from the original VCF.</p>
</td></tr>
<tr><td><code id="ReadVCF_+3A_get.vaf.function">get.vaf.function</code></td>
<td>
<p>Optional. Only applicable when <code>variant.caller</code> is
<strong>&quot;unknown&quot;</strong>. Function to calculate VAF(variant allele frequency) and read
depth information from original VCF. See <code><a href="#topic+GetMutectVAF">GetMutectVAF</a></code> as an example.
If <code>NULL</code>(default) and <code>variant.caller</code> is &quot;unknown&quot;, then VAF
and read depth will be NAs.</p>
</td></tr>
<tr><td><code id="ReadVCF_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code>get.vaf.function</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame storing data lines of the VCF file with two additional
columns added which contain the VAF(variant allele frequency) and read
depth information.
</p>

<hr>
<h2 id='ReadVCFs'>Read VCF files</h2><span id='topic+ReadVCFs'></span>

<h3>Description</h3>

<p>Read VCF files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadVCFs(
  files,
  variant.caller = "unknown",
  num.of.cores = 1,
  names.of.VCFs = NULL,
  tumor.col.names = NA,
  filter.status = NULL,
  get.vaf.function = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ReadVCFs_+3A_files">files</code></td>
<td>
<p>Character vector of file paths to the VCF files.</p>
</td></tr>
<tr><td><code id="ReadVCFs_+3A_variant.caller">variant.caller</code></td>
<td>
<p>Name of the variant caller that produces the VCF, can
be either <code>"strelka"</code>, <code>"mutect"</code>, <code>"freebayes"</code> or
<code>"unknown"</code>. This information is needed to calculate the VAFs (variant
allele frequencies). If variant caller is <code>"unknown"</code>(default) and
<code>get.vaf.function</code> is NULL, then VAF and read depth will be NAs. If
variant caller is <code>"mutect"</code>, do <strong>not</strong> merge SBSs into DBS.</p>
</td></tr>
<tr><td><code id="ReadVCFs_+3A_num.of.cores">num.of.cores</code></td>
<td>
<p>The number of cores to use. Not available on Windows
unless <code>num.of.cores = 1</code>.</p>
</td></tr>
<tr><td><code id="ReadVCFs_+3A_names.of.vcfs">names.of.VCFs</code></td>
<td>
<p>Character vector of names of the VCF files. The order
of names in <code>names.of.VCFs</code> should match the order of VCF file paths
in <code>files</code>. If <code>NULL</code>(default), this function will remove all of
the path up to and including the last path separator (if any) and file
paths without extensions (and the leading dot) will be used as the names of
the VCF files.</p>
</td></tr>
<tr><td><code id="ReadVCFs_+3A_tumor.col.names">tumor.col.names</code></td>
<td>
<p>Optional. Only applicable to <strong>Mutect</strong> VCFs.
Character vector of column names in <strong>Mutect</strong> VCFs which contain the
tumor sample information. The order of names in <code>tumor.col.names</code>
should match the order of <strong>Mutect</strong> VCFs specified in <code>files</code>.
If <code>tumor.col.names</code> is equal to <code>NA</code>(default), this function
will use the 10th column in all the <strong>Mutect</strong> VCFs to calculate VAFs.
See <code><a href="#topic+GetMutectVAF">GetMutectVAF</a></code> for more details.</p>
</td></tr>
<tr><td><code id="ReadVCFs_+3A_filter.status">filter.status</code></td>
<td>
<p>The status indicating a variant has passed all filters.
An example would be <code>"PASS"</code>. Variants which don't have the specified
<code>filter.status</code> in the <code>FILTER</code> column in VCF will be removed. If
<code>NULL</code>(default), no variants will be removed from the original VCF.</p>
</td></tr>
<tr><td><code id="ReadVCFs_+3A_get.vaf.function">get.vaf.function</code></td>
<td>
<p>Optional. Only applicable when <code>variant.caller</code> is
<strong>&quot;unknown&quot;</strong>. Function to calculate VAF(variant allele frequency) and read
depth information from original VCF. See <code><a href="#topic+GetMutectVAF">GetMutectVAF</a></code> as an example.
If <code>NULL</code>(default) and <code>variant.caller</code> is &quot;unknown&quot;, then VAF
and read depth will be NAs.</p>
</td></tr>
<tr><td><code id="ReadVCFs_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code>get.vaf.function</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data frames storing data lines of the VCF files with two
additional columns added which contain the VAF(variant allele frequency)
and read depth information.
</p>

<hr>
<h2 id='RemoveRangesOnBothStrand'>Remove ranges that fall on both strands</h2><span id='topic+RemoveRangesOnBothStrand'></span>

<h3>Description</h3>

<p>Remove ranges that fall on both strands
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RemoveRangesOnBothStrand(stranded.ranges)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RemoveRangesOnBothStrand_+3A_stranded.ranges">stranded.ranges</code></td>
<td>
<p>A keyed data table which has stranded ranges information.
It has four columns: chrom, start, end and strand.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data table which has removed ranges that fall on both strands from
the input <code>stranded.ranges</code>.
</p>

<hr>
<h2 id='RenameColumnsWithNameStrand'>Is there any column in <code>df</code> with name &quot;strand&quot;?
If there is, change its name to &quot;strand_old&quot; so that it will
conflict with code in other parts of ICAMS package.</h2><span id='topic+RenameColumnsWithNameStrand'></span>

<h3>Description</h3>

<p>Is there any column in <code>df</code> with name &quot;strand&quot;?
If there is, change its name to &quot;strand_old&quot; so that it will
conflict with code in other parts of ICAMS package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RenameColumnsWithNameStrand(df)
</code></pre>

<hr>
<h2 id='RenameColumnsWithNameVAF'>Is there any column in df1 with name &quot;VAF&quot;?
If there is, change its name to &quot;VAF_old&quot; so that it will
conflict with code in other parts of ICAMS package.</h2><span id='topic+RenameColumnsWithNameVAF'></span>

<h3>Description</h3>

<p>Is there any column in df1 with name &quot;VAF&quot;?
If there is, change its name to &quot;VAF_old&quot; so that it will
conflict with code in other parts of ICAMS package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RenameColumnsWithNameVAF(df)
</code></pre>

<hr>
<h2 id='Restaple1536'>Convert 1536-channel mutation-type identifiers like this <code>"ACCGTA" -&gt; "AC[C&gt;A]GT"</code></h2><span id='topic+Restaple1536'></span>

<h3>Description</h3>

<p>This is an internal function needed for generating
&quot;non-canonical&quot; row number formats for catalogs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Restaple1536(c1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Restaple1536_+3A_c1">c1</code></td>
<td>
<p>A vector of character strings with the first 5 characters
being the source trinucleotide and the last character being the
mutated (center) nucleotide. E.g. <code>ACCGTA</code> means a mutation from
<code>ACCGT &gt; ACAGT</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='Restaple96'>Convert 96-channel mutation-type identifiers like this <code>"ACTA" -&gt; "A[C&gt;A]T"</code></h2><span id='topic+Restaple96'></span>

<h3>Description</h3>

<p>This is an internal function needed for generating
&quot;non-canonical&quot; row number formats for catalogs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Restaple96(c1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Restaple96_+3A_c1">c1</code></td>
<td>
<p>A vector of character strings with the first 3 characters
being the source trinucleotide and the last character being the
mutated (center) nucleotide. E.g. <code>ACTA</code> means a mutation from
<code>ACT &gt; AAT</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='revc'>Reverse complement every string in <code>string.vec</code></h2><span id='topic+revc'></span>

<h3>Description</h3>

<p>Based on <code>reverseComplement</code>.
Handles IUPAC ambiguity codes but not &quot;u&quot; (uracil). <br />
(see &lt;https://en.wikipedia.org/wiki/Nucleic_acid_notation&gt;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>revc(string.vec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="revc_+3A_string.vec">string.vec</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with the reverse complement of every
string in <code>string.vec</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>revc("aTgc") # GCAT

# A vector and strings with ambiguity codes
revc(c("ATGC", "aTGc", "wnTCb")) # GCAT GCAT VGANW

## Not run: 
revc("ACGU") # An error
## End(Not run)
</code></pre>

<hr>
<h2 id='RevcDBS144'>Reverse complement strings that represent stranded DBSs</h2><span id='topic+RevcDBS144'></span>

<h3>Description</h3>

<p>Reverse complement strings that represent stranded DBSs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RevcDBS144(mutstring)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RevcDBS144_+3A_mutstring">mutstring</code></td>
<td>
<p>A vector of 4-character strings representing
stranded DBSs, for example &quot;AATC&quot; represents AA &gt; TC mutations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return the vector of
reverse complements of the first 2 characters
concatenated with the reverse complement of the second
2 characters, e.g. &quot;AATC&quot; returns &quot;TTGA&quot;.
</p>

<hr>
<h2 id='RevcSBS96'>Reverse complement strings that represent stranded SBSs</h2><span id='topic+RevcSBS96'></span>

<h3>Description</h3>

<p>Reverse complement strings that represent stranded SBSs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RevcSBS96(mutstring)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RevcSBS96_+3A_mutstring">mutstring</code></td>
<td>
<p>A vector of 4-character strings representing
stranded SBSs in trinucleotide context,
for example &quot;AATC&quot; represents AAT &gt; ACT mutations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return the vector of
reverse complements of the first 3 characters
concatenated with the reverse complement of the
last character, e.g. &quot;AATC&quot; returns &quot;ATTG&quot;.
</p>

<hr>
<h2 id='SplitListOfMutectVCFs'>Split each Mutect VCF into SBS, DBS, and ID VCFs (plus
VCF-like data frame with left-over rows)</h2><span id='topic+SplitListOfMutectVCFs'></span>

<h3>Description</h3>

<p>Split each Mutect VCF into SBS, DBS, and ID VCFs (plus
VCF-like data frame with left-over rows)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SplitListOfMutectVCFs(
  list.of.vcfs,
  suppress.discarded.variants.warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SplitListOfMutectVCFs_+3A_list.of.vcfs">list.of.vcfs</code></td>
<td>
<p>List of VCFs as in-memory data.frames.</p>
</td></tr>
<tr><td><code id="SplitListOfMutectVCFs_+3A_suppress.discarded.variants.warnings">suppress.discarded.variants.warnings</code></td>
<td>
<p>Logical. Whether to suppress
warning messages showing information about the discarded variants. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>SBS</code>: List of VCFs with only single base substitutions.
</p>
</li>
<li> <p><code>DBS</code>: List of VCFs with only doublet base substitutions as called
by Mutect.
</p>
</li>
<li> <p><code>ID</code>: List of VCFs with only small insertions and deletions.
</p>
</li>
<li> <p><code>discarded.variants</code>: <strong>Non-NULL only if</strong> there are variants
that were excluded from the analysis. See the added extra column
<code>discarded.reason</code> for more details.
</p>
</li></ul>


<hr>
<h2 id='SplitListOfStrelkaSBSVCFs'>Split a list of in-memory Strelka SBS VCF into SBS, DBS, and variants involving
&gt; 2 consecutive bases</h2><span id='topic+SplitListOfStrelkaSBSVCFs'></span>

<h3>Description</h3>

<p>SBSs are single base substitutions,
e.g. C&gt;T, A&lt;G,....  DBSs are double base substitutions,
e.g. CC&gt;TT, AT&gt;GG, ...  Variants involving &gt; 2 consecutive
bases are rare, so this function just records them. These
would be variants such ATG&gt;CCT, AGAT&gt;TCTA, ...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SplitListOfStrelkaSBSVCFs(
  list.of.vcfs,
  suppress.discarded.variants.warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SplitListOfStrelkaSBSVCFs_+3A_list.of.vcfs">list.of.vcfs</code></td>
<td>
<p>A list of in-memory data frames containing Strelka SBS
VCF file contents.</p>
</td></tr>
<tr><td><code id="SplitListOfStrelkaSBSVCFs_+3A_suppress.discarded.variants.warnings">suppress.discarded.variants.warnings</code></td>
<td>
<p>Logical. Whether to suppress
warning messages showing information about the discarded variants. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of elements as follows:
</p>

<ul>
<li> <p><code>SBS.vcfs</code>: List of data.frames of pure SBS mutations &ndash; no DBS or
3+BS mutations.
</p>
</li>
<li> <p><code>DBS.vcfs</code>: List of data.frames of pure DBS mutations &ndash; no SBS or
3+BS mutations.
</p>
</li>
<li> <p><code>discarded.variants</code>: <strong>Non-NULL only if</strong> there are variants
that were excluded from the analysis. See the added extra column
<code>discarded.reason</code> for more details.
</p>
</li></ul>


<hr>
<h2 id='SplitListOfVCFs'>Split each VCF into SBS, DBS, and ID VCFs (plus
VCF-like data frame with left-over rows)</h2><span id='topic+SplitListOfVCFs'></span>

<h3>Description</h3>

<p>Split each VCF into SBS, DBS, and ID VCFs (plus
VCF-like data frame with left-over rows)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SplitListOfVCFs(
  list.of.vcfs,
  variant.caller,
  max.vaf.diff = 0.02,
  num.of.cores = 1,
  suppress.discarded.variants.warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SplitListOfVCFs_+3A_list.of.vcfs">list.of.vcfs</code></td>
<td>
<p>List of VCFs as in-memory data.frames.</p>
</td></tr>
<tr><td><code id="SplitListOfVCFs_+3A_variant.caller">variant.caller</code></td>
<td>
<p>Name of the variant caller that produces the VCF, can
be either <code>"strelka"</code>, <code>"mutect"</code>, <code>"freebayes"</code> or
<code>"unknown"</code>. If variant caller is <code>"mutect"</code>, do <strong>not</strong> merge
SBSs into DBS.</p>
</td></tr>
<tr><td><code id="SplitListOfVCFs_+3A_max.vaf.diff">max.vaf.diff</code></td>
<td>
<p>The maximum difference of VAF, default value is 0.02. If
the absolute difference of VAFs for adjacent SBSs is bigger than
<code>max.vaf.diff</code>, then these adjacent SBSs are likely to be &quot;merely&quot;
asynchronous single base mutations, opposed to a simultaneous doublet
mutation or variants involving more than two consecutive bases.</p>
</td></tr>
<tr><td><code id="SplitListOfVCFs_+3A_num.of.cores">num.of.cores</code></td>
<td>
<p>The number of cores to use. Not available on Windows
unless <code>num.of.cores = 1</code>.</p>
</td></tr>
<tr><td><code id="SplitListOfVCFs_+3A_suppress.discarded.variants.warnings">suppress.discarded.variants.warnings</code></td>
<td>
<p>Logical. Whether to suppress
warning messages showing information about the discarded variants. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>SBS</code>: List of VCFs with only single base substitutions.
</p>
</li>
<li> <p><code>DBS</code>: List of VCFs with only doublet base substitutions as called
by Mutect.
</p>
</li>
<li> <p><code>ID</code>: List of VCFs with only small insertions and deletions.
</p>
</li>
<li> <p><code>discarded.variants</code>: <strong>Non-NULL only if</strong> there are variants
that were excluded from the analysis. See the added extra column
<code>discarded.reason</code> for more details.
</p>
</li></ul>


<hr>
<h2 id='SplitOneMutectVCF'>Split a mutect2 VCF into SBS, DBS, and ID VCFs, plus a list of other mutations</h2><span id='topic+SplitOneMutectVCF'></span>

<h3>Description</h3>

<p>Split a mutect2 VCF into SBS, DBS, and ID VCFs, plus a list of other mutations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SplitOneMutectVCF(vcf.df, name.of.VCF = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SplitOneMutectVCF_+3A_vcf.df">vcf.df</code></td>
<td>
<p>An in-memory data.frame representing a Mutect VCF, including
VAFs, which are added by <code><a href="#topic+ReadMutectVCF">ReadMutectVCF</a></code>.</p>
</td></tr>
<tr><td><code id="SplitOneMutectVCF_+3A_name.of.vcf">name.of.VCF</code></td>
<td>
<p>Name of the VCF file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 3 in-memory VCFs and discarded variants that were not
incorporated into the first 3 VCFs:
</p>
<p>* <code>SBS</code>: VCF with only single base substitutions.
</p>
<p>* <code>DBS</code>: VCF with only doublet base substitutions
as called by Mutect.
</p>
<p>* <code>ID</code>: VCF with only small insertions and deletions.
</p>
<p>* <code>discarded.variants</code>: <strong>Non-NULL only if</strong> there are variants
that were excluded from the analysis. See the added extra column
<code>discarded.reason</code> for more details.
@md
</p>

<hr>
<h2 id='SplitOneVCF'>Split a VCF into SBS, DBS, and ID VCFs, plus a list of other mutations</h2><span id='topic+SplitOneVCF'></span>

<h3>Description</h3>

<p>Split a VCF into SBS, DBS, and ID VCFs, plus a list of other mutations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SplitOneVCF(vcf.df, max.vaf.diff = 0.02, name.of.VCF = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SplitOneVCF_+3A_vcf.df">vcf.df</code></td>
<td>
<p>An in-memory data.frame representing a VCF, including
VAFs, which are added by <code><a href="#topic+ReadVCF">ReadVCF</a></code>.</p>
</td></tr>
<tr><td><code id="SplitOneVCF_+3A_max.vaf.diff">max.vaf.diff</code></td>
<td>
<p>The maximum difference of VAF, default value is 0.02. If
the absolute difference of VAFs for adjacent SBSs is bigger than
<code>max.vaf.diff</code>, then these adjacent SBSs are likely to be &quot;merely&quot;
asynchronous single base mutations, opposed to a simultaneous doublet
mutation or variants involving more than two consecutive bases.</p>
</td></tr>
<tr><td><code id="SplitOneVCF_+3A_name.of.vcf">name.of.VCF</code></td>
<td>
<p>Name of the VCF file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 3 in-memory VCFs and discarded variants that were not
incorporated into the first 3 VCFs:
</p>
<p>* <code>SBS</code>: VCF with only single base substitutions.
</p>
<p>* <code>DBS</code>: VCF with only doublet base substitutions
as called by Mutect.
</p>
<p>* <code>ID</code>: VCF with only small insertions and deletions.
</p>
<p>* <code>discarded.variants</code>: <strong>Non-NULL only if</strong> there are variants
that were excluded from the analysis. See the added extra column
<code>discarded.reason</code> for more details.
@md
</p>

<hr>
<h2 id='SplitSBSVCF'>Split an in-memory SBS VCF into pure SBSs, pure DBSs, and variants involving
&gt; 2 consecutive bases</h2><span id='topic+SplitSBSVCF'></span>

<h3>Description</h3>

<p>SBSs are single base substitutions,
e.g. C&gt;T, A&gt;G,....  DBSs are double base substitutions,
e.g. CC&gt;TT, AT&gt;GG, ...  Variants involving &gt; 2 consecutive
bases are rare, so this function just records them. These
would be variants such ATG&gt;CCT, AGAT&gt;TCTA, ...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SplitSBSVCF(vcf.df, max.vaf.diff = 0.02, name.of.VCF = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SplitSBSVCF_+3A_vcf.df">vcf.df</code></td>
<td>
<p>An in-memory data frame containing an SBS VCF file contents.</p>
</td></tr>
<tr><td><code id="SplitSBSVCF_+3A_max.vaf.diff">max.vaf.diff</code></td>
<td>
<p>The maximum difference of VAF, default value is 0.02. If
the absolute difference of VAFs for adjacent SBSs is bigger than
<code>max.vaf.diff</code>, then these adjacent SBSs are likely to be &quot;merely&quot;
asynchronous single base mutations, opposed to a simultaneous doublet
mutation or variants involving more than two consecutive bases.</p>
</td></tr>
<tr><td><code id="SplitSBSVCF_+3A_name.of.vcf">name.of.VCF</code></td>
<td>
<p>Name of the VCF file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of in-memory objects with the elements:
</p>

<ol>
<li> <p><code>SBS.vcf</code>: Data frame of pure SBS mutations &ndash; no DBS or 3+BS
mutations.
</p>
</li>
<li> <p><code>DBS.vcf</code>: Data frame of pure DBS mutations &ndash; no SBS or 3+BS
mutations.
</p>
</li>
<li> <p><code>discarded.variants</code>: <strong>Non-NULL only if</strong> there are
variants that were excluded from the analysis. See the added extra column
<code>discarded.reason</code> for more details.
</p>
</li></ol>


<hr>
<h2 id='SplitStrelkaSBSVCF'>Split an in-memory Strelka VCF into SBS, DBS, and variants involving
&gt; 2 consecutive bases</h2><span id='topic+SplitStrelkaSBSVCF'></span>

<h3>Description</h3>

<p>SBSs are single base substitutions,
e.g. C&gt;T, A&gt;G,....  DBSs are double base substitutions,
e.g. CC&gt;TT, AT&gt;GG, ...  Variants involving &gt; 2 consecutive
bases are rare, so this function just records them. These
would be variants such ATG&gt;CCT, AGAT&gt;TCTA, ...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SplitStrelkaSBSVCF(vcf.df, max.vaf.diff = 0.02, name.of.VCF = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SplitStrelkaSBSVCF_+3A_vcf.df">vcf.df</code></td>
<td>
<p>An in-memory data frame containing a Strelka VCF file contents.</p>
</td></tr>
<tr><td><code id="SplitStrelkaSBSVCF_+3A_max.vaf.diff">max.vaf.diff</code></td>
<td>
<p>The maximum difference of VAF, default value is 0.02. If
the absolute difference of VAFs for adjacent SBSs is bigger than
<code>max.vaf.diff</code>, then these adjacent SBSs are likely to be &quot;merely&quot;
asynchronous single base mutations, opposed to a simultaneous doublet
mutation or variants involving more than two consecutive bases.</p>
</td></tr>
<tr><td><code id="SplitStrelkaSBSVCF_+3A_name.of.vcf">name.of.VCF</code></td>
<td>
<p>Name of the VCF file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of in-memory objects with the elements:
</p>

<ol>
<li> <p><code>SBS.vcf</code>: Data frame of pure SBS mutations &ndash; no DBS or 3+BS
mutations.
</p>
</li>
<li> <p><code>DBS.vcf</code>: Data frame of pure DBS mutations &ndash; no SBS or 3+BS
mutations.
</p>
</li>
<li> <p><code>discarded.variants</code>: <strong>Non-NULL only if</strong> there are
variants that were excluded from the analysis. See the added extra column
<code>discarded.reason</code> for more details.
</p>
</li></ol>


<hr>
<h2 id='StandardChromName'>Standardize the chromosome name annotations for a data frame.</h2><span id='topic+StandardChromName'></span>

<h3>Description</h3>

<p>Standardize the chromosome name annotations for a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StandardChromName(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="StandardChromName_+3A_df">df</code></td>
<td>
<p>A data frame whose first column contains the Chromosome name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame whose Chromosome names are only in the form of 1:22, &quot;X&quot;
and &quot;Y&quot;.
</p>

<hr>
<h2 id='StandardChromNameNew'>Standardize the chromosome name annotations for a data frame.</h2><span id='topic+StandardChromNameNew'></span>

<h3>Description</h3>

<p>Standardize the chromosome name annotations for a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StandardChromNameNew(df, name.of.VCF = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="StandardChromNameNew_+3A_df">df</code></td>
<td>
<p>An in-memory data.frame representing a VCF.</p>
</td></tr>
<tr><td><code id="StandardChromNameNew_+3A_name.of.vcf">name.of.VCF</code></td>
<td>
<p>Name of the VCF file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <strong>list</strong> with the elements
</p>

<ul>
<li> <p><code>df</code> a data frame with variants that had &quot;legal&quot; chromosome
names (see below for illegal chromosome names).
Leading &quot;chr&quot; strings are removed.
</p>
</li>
<li> <p><code>discarded.variants</code>: <strong>Non-NULL only if</strong> there
variants with illegal chromosome names; these are
names that contain the strings &quot;GL&quot;, &quot;Hs&quot;, &quot;KI&quot;, &quot;M&quot;, &quot;random&quot;.
</p>
</li></ul>


<hr>
<h2 id='StopIfCatalogTypeIllegal'>Stop if <code>catalog.type</code> is illegal.</h2><span id='topic+StopIfCatalogTypeIllegal'></span>

<h3>Description</h3>

<p>Stop if <code>catalog.type</code> is illegal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StopIfCatalogTypeIllegal(catalog.type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="StopIfCatalogTypeIllegal_+3A_catalog.type">catalog.type</code></td>
<td>
<p>Character string to check.</p>
</td></tr>
</table>

<hr>
<h2 id='StopIfNrowIllegal'>Stop if the number of rows in <code>object</code> is illegal</h2><span id='topic+StopIfNrowIllegal'></span>

<h3>Description</h3>

<p>Stop if the number of rows in <code>object</code> is illegal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StopIfNrowIllegal(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="StopIfNrowIllegal_+3A_object">object</code></td>
<td>
<p>A <code>catalog</code>, numeric <code>matrix</code>, or numeric <code>data.fram</code></p>
</td></tr>
</table>

<hr>
<h2 id='StopIfRegionIllegal'>Stop if <code>region</code> is illegal.</h2><span id='topic+StopIfRegionIllegal'></span>

<h3>Description</h3>

<p>Stop if <code>region</code> is illegal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StopIfRegionIllegal(region)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="StopIfRegionIllegal_+3A_region">region</code></td>
<td>
<p>Character string to check.</p>
</td></tr>
</table>

<hr>
<h2 id='StopIfTranscribedRegionIllegal'>Stop if <code>region</code> is illegal for an in-transcript catalogs</h2><span id='topic+StopIfTranscribedRegionIllegal'></span>

<h3>Description</h3>

<p>Stop if <code>region</code> is illegal for an in-transcript catalogs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StopIfTranscribedRegionIllegal(region)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="StopIfTranscribedRegionIllegal_+3A_region">region</code></td>
<td>
<p>The region to test (a character string)</p>
</td></tr>
</table>

<hr>
<h2 id='StrelkaIDVCFFilesToCatalog'>Create ID (small insertion and deletion) catalog from Strelka ID VCF files</h2><span id='topic+StrelkaIDVCFFilesToCatalog'></span>

<h3>Description</h3>

<p>Create ID (small insertion and deletion) catalog from the Strelka ID VCFs
specified by <code>files</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StrelkaIDVCFFilesToCatalog(
  files,
  ref.genome,
  region = "unknown",
  names.of.VCFs = NULL,
  flag.mismatches = 0,
  return.annotated.vcfs = FALSE,
  suppress.discarded.variants.warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="StrelkaIDVCFFilesToCatalog_+3A_files">files</code></td>
<td>
<p>Character vector of file paths to the Strelka ID VCF files.</p>
</td></tr>
<tr><td><code id="StrelkaIDVCFFilesToCatalog_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="StrelkaIDVCFFilesToCatalog_+3A_region">region</code></td>
<td>
<p>A character string designating a genomic region;
see <code><a href="#topic+as.catalog">as.catalog</a></code> and <code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="StrelkaIDVCFFilesToCatalog_+3A_names.of.vcfs">names.of.VCFs</code></td>
<td>
<p>Optional. Character vector of names of the VCF files.
The order of names in <code>names.of.VCFs</code> should match the order of VCF
file paths in <code>files</code>. If <code>NULL</code>(default), this function will
remove all of the path up to and including the last path separator (if any)
in <code>files</code> and file paths without extensions (and the leading dot)
will be used as the names of the VCF files.</p>
</td></tr>
<tr><td><code id="StrelkaIDVCFFilesToCatalog_+3A_flag.mismatches">flag.mismatches</code></td>
<td>
<p>Deprecated. If there are ID variants whose <code>REF</code>
do not match the extracted sequence from <code>ref.genome</code>, the function
will automatically discard these variants and an element
<code>discarded.variants</code> will appear in the return value. See
<code><a href="#topic+AnnotateIDVCF">AnnotateIDVCF</a></code> for more details.</p>
</td></tr>
<tr><td><code id="StrelkaIDVCFFilesToCatalog_+3A_return.annotated.vcfs">return.annotated.vcfs</code></td>
<td>
<p>Logical. Whether to return the annotated VCFs
with additional columns showing mutation class for each variant. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="StrelkaIDVCFFilesToCatalog_+3A_suppress.discarded.variants.warnings">suppress.discarded.variants.warnings</code></td>
<td>
<p>Logical. Whether to suppress
warning messages showing information about the discarded variants. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code><a href="#topic+VCFsToIDCatalogs">VCFsToIDCatalogs</a></code>
</p>


<h3>Value</h3>

<p>A <strong>list</strong> of elements:
</p>

<ul>
<li> <p><code>catalog</code>: The ID (small insertion and deletion) catalog with
attributes added. See <code><a href="#topic+as.catalog">as.catalog</a></code> for more details.
</p>
</li>
<li> <p><code>discarded.variants</code>: <strong>Non-NULL only if</strong> there are variants
that were excluded from the analysis. See the added extra column
<code>discarded.reason</code> for more details.
</p>
</li>
<li> <p><code>annotated.vcfs</code>:
<strong>Non-NULL only if</strong> <code>return.annotated.vcfs</code> = TRUE. A list of
data frames which contain the original VCF's ID mutation rows with three
additional columns <code>seq.context.width</code>, <code>seq.context</code> and
<code>ID.class</code> added. The category assignment of each ID mutation in VCF can
be obtained from <code>ID.class</code> column.
</p>
</li></ul>



<h3>ID classification</h3>

<p>See <a href="https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx">https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx</a>
for additional information on ID (small insertion and deletion) mutation
classification.
</p>
<p>See the documentation for <code><a href="#topic+Canonicalize1Del">Canonicalize1Del</a></code> which first handles
deletions in homopolymers, then handles deletions in simple repeats with
longer repeat units, (e.g. <code>CACACACA</code>, see
<code><a href="#topic+FindMaxRepeatDel">FindMaxRepeatDel</a></code>), and if the deletion is not in a simple
repeat, looks for microhomology (see <code><a href="#topic+FindDelMH">FindDelMH</a></code>).
</p>
<p>See the code for unexported function <code><a href="#topic+CanonicalizeID">CanonicalizeID</a></code>
and the functions it calls for handling of insertions.
</p>


<h3>Note</h3>

<p>In ID (small insertion and deletion) catalogs, deletion repeat sizes range
from 0 to 5+, but for plotting and end-user documentation deletion repeat
sizes range from 1 to 6+.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- c(system.file("extdata/Strelka-ID-vcf",
                      "Strelka.ID.GRCh37.s1.vcf",
                      package = "ICAMS"))
if (requireNamespace("BSgenome.Hsapiens.1000genomes.hs37d5", quietly = TRUE)) {
  catID &lt;- StrelkaIDVCFFilesToCatalog(file, ref.genome = "hg19",
                                      region = "genome")}
</code></pre>

<hr>
<h2 id='StrelkaIDVCFFilesToCatalogAndPlotToPdf'>Create ID (small insertion and deletion) catalog from Strelka ID VCF files
and plot them to PDF</h2><span id='topic+StrelkaIDVCFFilesToCatalogAndPlotToPdf'></span>

<h3>Description</h3>

<p>Create ID (small insertion and deletion) catalog from the Strelka ID VCFs
specified by <code>files</code> and plot them to PDF
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StrelkaIDVCFFilesToCatalogAndPlotToPdf(
  files,
  ref.genome,
  region = "unknown",
  names.of.VCFs = NULL,
  output.file = "",
  flag.mismatches = 0,
  return.annotated.vcfs = FALSE,
  suppress.discarded.variants.warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="StrelkaIDVCFFilesToCatalogAndPlotToPdf_+3A_files">files</code></td>
<td>
<p>Character vector of file paths to the Strelka ID VCF files.</p>
</td></tr>
<tr><td><code id="StrelkaIDVCFFilesToCatalogAndPlotToPdf_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="StrelkaIDVCFFilesToCatalogAndPlotToPdf_+3A_region">region</code></td>
<td>
<p>A character string designating a genomic region;
see <code><a href="#topic+as.catalog">as.catalog</a></code> and <code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="StrelkaIDVCFFilesToCatalogAndPlotToPdf_+3A_names.of.vcfs">names.of.VCFs</code></td>
<td>
<p>Optional. Character vector of names of the VCF files.
The order of names in <code>names.of.VCFs</code> should match the order of VCF
file paths in <code>files</code>. If <code>NULL</code>(default), this function will
remove all of the path up to and including the last path separator (if any)
in <code>files</code> and file paths without extensions (and the leading dot)
will be used as the names of the VCF files.</p>
</td></tr>
<tr><td><code id="StrelkaIDVCFFilesToCatalogAndPlotToPdf_+3A_output.file">output.file</code></td>
<td>
<p>Optional. The base name of the PDF file to be produced;
the file is ending in <code>catID.pdf</code>.</p>
</td></tr>
<tr><td><code id="StrelkaIDVCFFilesToCatalogAndPlotToPdf_+3A_flag.mismatches">flag.mismatches</code></td>
<td>
<p>Deprecated. If there are ID variants whose <code>REF</code>
do not match the extracted sequence from <code>ref.genome</code>, the function
will automatically discard these variants and an element
<code>discarded.variants</code> will appear in the return value. See
<code><a href="#topic+AnnotateIDVCF">AnnotateIDVCF</a></code> for more details.</p>
</td></tr>
<tr><td><code id="StrelkaIDVCFFilesToCatalogAndPlotToPdf_+3A_return.annotated.vcfs">return.annotated.vcfs</code></td>
<td>
<p>Logical. Whether to return the annotated VCFs
with additional columns showing mutation class for each variant. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="StrelkaIDVCFFilesToCatalogAndPlotToPdf_+3A_suppress.discarded.variants.warnings">suppress.discarded.variants.warnings</code></td>
<td>
<p>Logical. Whether to suppress
warning messages showing information about the discarded variants. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code><a href="#topic+StrelkaIDVCFFilesToCatalog">StrelkaIDVCFFilesToCatalog</a></code> and
<code><a href="#topic+PlotCatalogToPdf">PlotCatalogToPdf</a></code>
</p>


<h3>Value</h3>

<p>A <strong>list</strong> of elements:
</p>

<ul>
<li> <p><code>catalog</code>: The ID (small insertion and deletion) catalog with
attributes added. See <code><a href="#topic+as.catalog">as.catalog</a></code> for more details.
</p>
</li>
<li> <p><code>discarded.variants</code>: <strong>Non-NULL only if</strong> there are variants
that were excluded from the analysis. See the added extra column
<code>discarded.reason</code> for more details.
</p>
</li>
<li> <p><code>annotated.vcfs</code>:
<strong>Non-NULL only if</strong> <code>return.annotated.vcfs</code> = TRUE. A list of
data frames which contain the original VCF's ID mutation rows with three
additional columns <code>seq.context.width</code>, <code>seq.context</code> and
<code>ID.class</code> added. The category assignment of each ID mutation in VCF can
be obtained from <code>ID.class</code> column.
</p>
</li></ul>



<h3>ID classification</h3>

<p>See <a href="https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx">https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx</a>
for additional information on ID (small insertion and deletion) mutation
classification.
</p>
<p>See the documentation for <code><a href="#topic+Canonicalize1Del">Canonicalize1Del</a></code> which first handles
deletions in homopolymers, then handles deletions in simple repeats with
longer repeat units, (e.g. <code>CACACACA</code>, see
<code><a href="#topic+FindMaxRepeatDel">FindMaxRepeatDel</a></code>), and if the deletion is not in a simple
repeat, looks for microhomology (see <code><a href="#topic+FindDelMH">FindDelMH</a></code>).
</p>
<p>See the code for unexported function <code><a href="#topic+CanonicalizeID">CanonicalizeID</a></code>
and the functions it calls for handling of insertions.
</p>


<h3>Note</h3>

<p>In ID (small insertion and deletion) catalogs, deletion repeat sizes range
from 0 to 5+, but for plotting and end-user documentation deletion repeat
sizes range from 1 to 6+.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- c(system.file("extdata/Strelka-ID-vcf",
                      "Strelka.ID.GRCh37.s1.vcf",
                      package = "ICAMS"))
if (requireNamespace("BSgenome.Hsapiens.1000genomes.hs37d5", quietly = TRUE)) {
  catID &lt;-
    StrelkaIDVCFFilesToCatalogAndPlotToPdf(file, ref.genome = "hg19",
                                           region = "genome",
                                           output.file =
                                           file.path(tempdir(), "StrelkaID"))}

</code></pre>

<hr>
<h2 id='StrelkaIDVCFFilesToZipFile'>Create a zip file which contains ID (small insertion and deletion) catalog
and plot PDF from Strelka ID VCF files</h2><span id='topic+StrelkaIDVCFFilesToZipFile'></span>

<h3>Description</h3>

<p>Create ID (small insertion and deletion) catalog from the Strelka ID VCFs
specified by <code>dir</code>, save the catalog as CSV file, plot it to PDF and
generate a zip archive of all the output files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StrelkaIDVCFFilesToZipFile(
  dir,
  zipfile,
  ref.genome,
  region = "unknown",
  names.of.VCFs = NULL,
  base.filename = "",
  flag.mismatches = 0,
  return.annotated.vcfs = FALSE,
  suppress.discarded.variants.warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="StrelkaIDVCFFilesToZipFile_+3A_dir">dir</code></td>
<td>
<p>Pathname of the directory which contains <strong>only</strong> the Strelka
ID VCF files. Each Strelka ID VCF <strong>must</strong> have a file extension
&quot;.vcf&quot; (case insensitive) and share the <strong>same</strong> <code>ref.genome</code> and
<code>region</code>.</p>
</td></tr>
<tr><td><code id="StrelkaIDVCFFilesToZipFile_+3A_zipfile">zipfile</code></td>
<td>
<p>Pathname of the zip file to be created.</p>
</td></tr>
<tr><td><code id="StrelkaIDVCFFilesToZipFile_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="StrelkaIDVCFFilesToZipFile_+3A_region">region</code></td>
<td>
<p>A character string designating a genomic region;
see <code><a href="#topic+as.catalog">as.catalog</a></code> and <code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="StrelkaIDVCFFilesToZipFile_+3A_names.of.vcfs">names.of.VCFs</code></td>
<td>
<p>Optional. Character vector of names of the VCF files.
The order of names in <code>names.of.VCFs</code> should match the order of VCFs
listed in <code>dir</code>. If <code>NULL</code>(default), this function will remove
all of the path up to and including the last path separator (if any) in
<code>dir</code> and file paths without extensions (and the leading dot) will be
used as the names of the VCF files.</p>
</td></tr>
<tr><td><code id="StrelkaIDVCFFilesToZipFile_+3A_base.filename">base.filename</code></td>
<td>
<p>Optional. The base name of the CSV and PDF file to be
produced; the file is ending in <code>catID.csv</code> and <code>catID.pdf</code>
respectively.</p>
</td></tr>
<tr><td><code id="StrelkaIDVCFFilesToZipFile_+3A_flag.mismatches">flag.mismatches</code></td>
<td>
<p>Deprecated. If there are ID variants whose <code>REF</code>
do not match the extracted sequence from <code>ref.genome</code>, the function
will automatically discard these variants and an element
<code>discarded.variants</code> will appear in the return value. See
<code><a href="#topic+AnnotateIDVCF">AnnotateIDVCF</a></code> for more details.</p>
</td></tr>
<tr><td><code id="StrelkaIDVCFFilesToZipFile_+3A_return.annotated.vcfs">return.annotated.vcfs</code></td>
<td>
<p>Logical. Whether to return the annotated VCFs
with additional columns showing mutation class for each variant. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="StrelkaIDVCFFilesToZipFile_+3A_suppress.discarded.variants.warnings">suppress.discarded.variants.warnings</code></td>
<td>
<p>Logical. Whether to suppress
warning messages showing information about the discarded variants. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code><a href="#topic+StrelkaIDVCFFilesToCatalog">StrelkaIDVCFFilesToCatalog</a></code>,
<code><a href="#topic+PlotCatalogToPdf">PlotCatalogToPdf</a></code>, <code><a href="#topic+WriteCatalog">WriteCatalog</a></code> and
<code>zip::zipr</code>.
</p>


<h3>Value</h3>

<p>A <strong>list</strong> of elements:
</p>

<ul>
<li> <p><code>catalog</code>: The ID (small insertion and deletion) catalog with
attributes added. See <code><a href="#topic+as.catalog">as.catalog</a></code> for more details.
</p>
</li>
<li> <p><code>discarded.variants</code>: <strong>Non-NULL only if</strong> there are variants
that were excluded from the analysis. See the added extra column
<code>discarded.reason</code> for more details.
</p>
</li>
<li> <p><code>annotated.vcfs</code>:
<strong>Non-NULL only if</strong> <code>return.annotated.vcfs</code> = TRUE. A list of
data frames which contain the original VCF's ID mutation rows with three
additional columns <code>seq.context.width</code>, <code>seq.context</code> and
<code>ID.class</code> added. The category assignment of each ID mutation in VCF can
be obtained from <code>ID.class</code> column.
</p>
</li></ul>



<h3>ID classification</h3>

<p>See <a href="https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx">https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx</a>
for additional information on ID (small insertion and deletion) mutation
classification.
</p>
<p>See the documentation for <code><a href="#topic+Canonicalize1Del">Canonicalize1Del</a></code> which first handles
deletions in homopolymers, then handles deletions in simple repeats with
longer repeat units, (e.g. <code>CACACACA</code>, see
<code><a href="#topic+FindMaxRepeatDel">FindMaxRepeatDel</a></code>), and if the deletion is not in a simple
repeat, looks for microhomology (see <code><a href="#topic+FindDelMH">FindDelMH</a></code>).
</p>
<p>See the code for unexported function <code><a href="#topic+CanonicalizeID">CanonicalizeID</a></code>
and the functions it calls for handling of insertions.
</p>


<h3>Note</h3>

<p>In ID (small insertion and deletion) catalogs, deletion repeat sizes range
from 0 to 5+, but for plotting and end-user documentation deletion repeat
sizes range from 1 to 6+.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dir &lt;- c(system.file("extdata/Strelka-ID-vcf",
                     package = "ICAMS"))
if (requireNamespace("BSgenome.Hsapiens.1000genomes.hs37d5", quietly = TRUE)) {
  catalogs &lt;-
    StrelkaIDVCFFilesToZipFile(dir,
                               zipfile = file.path(tempdir(), "test.zip"),
                               ref.genome = "hg19",
                               region = "genome",
                               base.filename = "Strelka-ID")
  unlink(file.path(tempdir(), "test.zip"))}
</code></pre>

<hr>
<h2 id='StrelkaSBSVCFFilesToCatalog'>Create SBS and DBS catalogs from Strelka SBS VCF files</h2><span id='topic+StrelkaSBSVCFFilesToCatalog'></span>

<h3>Description</h3>

<p>Create 3 SBS catalogs (96, 192, 1536) and 3 DBS catalogs (78, 136, 144) from
the Strelka SBS VCFs specified by <code>files</code>. The function will find and
merge adjacent SBS pairs into DBS if their VAFs are very similar. The default
threshold value for VAF is 0.02.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StrelkaSBSVCFFilesToCatalog(
  files,
  ref.genome,
  trans.ranges = NULL,
  region = "unknown",
  names.of.VCFs = NULL,
  return.annotated.vcfs = FALSE,
  suppress.discarded.variants.warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="StrelkaSBSVCFFilesToCatalog_+3A_files">files</code></td>
<td>
<p>Character vector of file paths to the Strelka SBS VCF files.</p>
</td></tr>
<tr><td><code id="StrelkaSBSVCFFilesToCatalog_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="StrelkaSBSVCFFilesToCatalog_+3A_trans.ranges">trans.ranges</code></td>
<td>
<p>Optional. If <code>ref.genome</code> specifies one of the
<code>BSgenome</code> object
</p>

<ol>
<li> <p><code>BSgenome.Hsapiens.1000genomes.hs37d5</code>
</p>
</li>
<li> <p><code>BSgenome.Hsapiens.UCSC.hg38</code>
</p>
</li>
<li> <p><code>BSgenome.Mmusculus.UCSC.mm10</code>
</p>
</li></ol>

<p>then the function will infer <code>trans.ranges</code> automatically. Otherwise,
user will need to provide the necessary <code>trans.ranges</code>. Please refer to
<code><a href="#topic+TranscriptRanges">TranscriptRanges</a></code> for more details.
If <code>is.null(trans.ranges)</code> do not add transcript range
information.</p>
</td></tr>
<tr><td><code id="StrelkaSBSVCFFilesToCatalog_+3A_region">region</code></td>
<td>
<p>A character string designating a genomic region;
see <code><a href="#topic+as.catalog">as.catalog</a></code> and <code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="StrelkaSBSVCFFilesToCatalog_+3A_names.of.vcfs">names.of.VCFs</code></td>
<td>
<p>Optional. Character vector of names of the VCF files.
The order of names in <code>names.of.VCFs</code> should match the order of VCF
file paths in <code>files</code>. If <code>NULL</code>(default), this function will
remove all of the path up to and including the last path separator (if any)
in <code>files</code> and file paths without extensions (and the leading dot)
will be used as the names of the VCF files.</p>
</td></tr>
<tr><td><code id="StrelkaSBSVCFFilesToCatalog_+3A_return.annotated.vcfs">return.annotated.vcfs</code></td>
<td>
<p>Logical. Whether to return the annotated VCFs
with additional columns showing mutation class for each variant. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="StrelkaSBSVCFFilesToCatalog_+3A_suppress.discarded.variants.warnings">suppress.discarded.variants.warnings</code></td>
<td>
<p>Logical. Whether to suppress
warning messages showing information about the discarded variants. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code><a href="#topic+VCFsToSBSCatalogs">VCFsToSBSCatalogs</a></code> and
<code><a href="#topic+VCFsToDBSCatalogs">VCFsToDBSCatalogs</a></code>.
</p>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>catSBS96</code>, <code>catSBS192</code>, <code>catSBS1536</code>: Matrix of
3 SBS catalogs (one each for 96, 192, and 1536).
</p>
</li>
<li> <p><code>catDBS78</code>, <code>catDBS136</code>, <code>catDBS144</code>: Matrix of
3 DBS catalogs (one each for 78, 136, and 144).
</p>
</li>
<li> <p><code>discarded.variants</code>: <strong>Non-NULL only if</strong> there are variants
that were excluded from the analysis. See the added extra column
<code>discarded.reason</code> for more details.
</p>
</li>
<li> <p><code>annotated.vcfs</code>:
<strong>Non-NULL only if</strong> <code>return.annotated.vcfs</code> = TRUE.
A list of elements:
</p>

<ul>
<li> <p><code>SBS</code>: SBS VCF annotated by <code><a href="#topic+AnnotateSBSVCF">AnnotateSBSVCF</a></code> with
three new columns <code>SBS96.class</code>, <code>SBS192.class</code> and
<code>SBS1536.class</code> showing the mutation class for each SBS variant.
</p>
</li>
<li> <p><code>DBS</code>: DBS VCF annotated by <code><a href="#topic+AnnotateDBSVCF">AnnotateDBSVCF</a></code> with
three new columns <code>DBS78.class</code>, <code>DBS136.class</code> and
<code>DBS144.class</code> showing the mutation class for each DBS variant.
</p>
</li></ul>

</li></ul>

<p>If <code>trans.ranges</code> is not provided by user and cannot be inferred by
ICAMS, SBS 192 and DBS 144 catalog will not be generated. Each catalog has
attributes added. See <code><a href="#topic+as.catalog">as.catalog</a></code> for more details.
</p>


<h3>Note</h3>

<p>SBS 192 and DBS 144 catalogs include only mutations in
transcribed regions.
</p>


<h3>Comments</h3>

<p>To add or change attributes of the catalog, you can use function
<code><a href="base.html#topic+attr">attr</a></code>. <br /> For example, <code>attr(catalog, "abundance")
&lt;- custom.abundance</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- c(system.file("extdata/Strelka-SBS-vcf",
                      "Strelka.SBS.GRCh37.s1.vcf",
                      package = "ICAMS"))
if (requireNamespace("BSgenome.Hsapiens.1000genomes.hs37d5", quietly = TRUE)) {
  catalogs &lt;- StrelkaSBSVCFFilesToCatalog(file, ref.genome = "hg19",
                                          trans.ranges = trans.ranges.GRCh37,
                                          region = "genome")}
</code></pre>

<hr>
<h2 id='StrelkaSBSVCFFilesToCatalogAndPlotToPdf'>Create SBS and DBS catalogs from Strelka SBS VCF files and plot them to PDF</h2><span id='topic+StrelkaSBSVCFFilesToCatalogAndPlotToPdf'></span>

<h3>Description</h3>

<p>Create 3 SBS catalogs (96, 192, 1536) and 3 DBS catalogs (78, 136, 144) from
the Strelka SBS VCFs specified by <code>files</code> and plot them to PDF. The
function will find and merge adjacent SBS pairs into DBS if their VAFs are
very similar. The default threshold value for VAF is 0.02.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StrelkaSBSVCFFilesToCatalogAndPlotToPdf(
  files,
  ref.genome,
  trans.ranges = NULL,
  region = "unknown",
  names.of.VCFs = NULL,
  output.file = "",
  return.annotated.vcfs = FALSE,
  suppress.discarded.variants.warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="StrelkaSBSVCFFilesToCatalogAndPlotToPdf_+3A_files">files</code></td>
<td>
<p>Character vector of file paths to the Strelka SBS VCF files.</p>
</td></tr>
<tr><td><code id="StrelkaSBSVCFFilesToCatalogAndPlotToPdf_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="StrelkaSBSVCFFilesToCatalogAndPlotToPdf_+3A_trans.ranges">trans.ranges</code></td>
<td>
<p>Optional. If <code>ref.genome</code> specifies one of the
<code>BSgenome</code> object
</p>

<ol>
<li> <p><code>BSgenome.Hsapiens.1000genomes.hs37d5</code>
</p>
</li>
<li> <p><code>BSgenome.Hsapiens.UCSC.hg38</code>
</p>
</li>
<li> <p><code>BSgenome.Mmusculus.UCSC.mm10</code>
</p>
</li></ol>

<p>then the function will infer <code>trans.ranges</code> automatically. Otherwise,
user will need to provide the necessary <code>trans.ranges</code>. Please refer to
<code><a href="#topic+TranscriptRanges">TranscriptRanges</a></code> for more details.
If <code>is.null(trans.ranges)</code> do not add transcript range
information.</p>
</td></tr>
<tr><td><code id="StrelkaSBSVCFFilesToCatalogAndPlotToPdf_+3A_region">region</code></td>
<td>
<p>A character string designating a genomic region;
see <code><a href="#topic+as.catalog">as.catalog</a></code> and <code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="StrelkaSBSVCFFilesToCatalogAndPlotToPdf_+3A_names.of.vcfs">names.of.VCFs</code></td>
<td>
<p>Optional. Character vector of names of the VCF files.
The order of names in <code>names.of.VCFs</code> should match the order of VCF
file paths in <code>files</code>. If <code>NULL</code>(default), this function will
remove all of the path up to and including the last path separator (if any)
in <code>files</code> and file paths without extensions (and the leading dot)
will be used as the names of the VCF files.</p>
</td></tr>
<tr><td><code id="StrelkaSBSVCFFilesToCatalogAndPlotToPdf_+3A_output.file">output.file</code></td>
<td>
<p>Optional. The base name of the PDF files to be produced;
multiple files will be generated, each ending in <code class="reqn">x</code><code>.pdf</code>, where
<code class="reqn">x</code> indicates the type of catalog plotted in the file.</p>
</td></tr>
<tr><td><code id="StrelkaSBSVCFFilesToCatalogAndPlotToPdf_+3A_return.annotated.vcfs">return.annotated.vcfs</code></td>
<td>
<p>Logical. Whether to return the annotated VCFs
with additional columns showing mutation class for each variant. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="StrelkaSBSVCFFilesToCatalogAndPlotToPdf_+3A_suppress.discarded.variants.warnings">suppress.discarded.variants.warnings</code></td>
<td>
<p>Logical. Whether to suppress
warning messages showing information about the discarded variants. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code><a href="#topic+StrelkaSBSVCFFilesToCatalog">StrelkaSBSVCFFilesToCatalog</a></code> and
<code><a href="#topic+PlotCatalogToPdf">PlotCatalogToPdf</a></code>
</p>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>catSBS96</code>, <code>catSBS192</code>, <code>catSBS1536</code>: Matrix of
3 SBS catalogs (one each for 96, 192, and 1536).
</p>
</li>
<li> <p><code>catDBS78</code>, <code>catDBS136</code>, <code>catDBS144</code>: Matrix of
3 DBS catalogs (one each for 78, 136, and 144).
</p>
</li>
<li> <p><code>discarded.variants</code>: <strong>Non-NULL only if</strong> there are variants
that were excluded from the analysis. See the added extra column
<code>discarded.reason</code> for more details.
</p>
</li>
<li> <p><code>annotated.vcfs</code>:
<strong>Non-NULL only if</strong> <code>return.annotated.vcfs</code> = TRUE.
A list of elements:
</p>

<ul>
<li> <p><code>SBS</code>: SBS VCF annotated by <code><a href="#topic+AnnotateSBSVCF">AnnotateSBSVCF</a></code> with
three new columns <code>SBS96.class</code>, <code>SBS192.class</code> and
<code>SBS1536.class</code> showing the mutation class for each SBS variant.
</p>
</li>
<li> <p><code>DBS</code>: DBS VCF annotated by <code><a href="#topic+AnnotateDBSVCF">AnnotateDBSVCF</a></code> with
three new columns <code>DBS78.class</code>, <code>DBS136.class</code> and
<code>DBS144.class</code> showing the mutation class for each DBS variant.
</p>
</li></ul>

</li></ul>

<p>If <code>trans.ranges</code> is not provided by user and cannot be inferred by
ICAMS, SBS 192 and DBS 144 catalog will not be generated. Each catalog has
attributes added. See <code><a href="#topic+as.catalog">as.catalog</a></code> for more details.
</p>


<h3>Note</h3>

<p>SBS 192 and DBS 144 catalogs include only mutations in
transcribed regions.
</p>


<h3>Comments</h3>

<p>To add or change attributes of the catalog, you can use function
<code><a href="base.html#topic+attr">attr</a></code>. <br /> For example, <code>attr(catalog, "abundance")
&lt;- custom.abundance</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- c(system.file("extdata/Strelka-SBS-vcf",
                      "Strelka.SBS.GRCh37.s1.vcf",
                      package = "ICAMS"))
if (requireNamespace("BSgenome.Hsapiens.1000genomes.hs37d5", quietly = TRUE)) {
  catalogs &lt;-
    StrelkaSBSVCFFilesToCatalogAndPlotToPdf(file, ref.genome = "hg19",
                                            trans.ranges = trans.ranges.GRCh37,
                                            region = "genome",
                                            output.file =
                                            file.path(tempdir(), "StrelkaSBS"))}
</code></pre>

<hr>
<h2 id='StrelkaSBSVCFFilesToZipFile'>Create a zip file which contains catalogs and plot PDFs from Strelka SBS VCF files</h2><span id='topic+StrelkaSBSVCFFilesToZipFile'></span>

<h3>Description</h3>

<p>Create 3 SBS catalogs (96, 192, 1536), 3 DBS catalogs (78, 136, 144) from the
Strelka SBS VCFs specified by <code>dir</code>, save the catalogs as CSV files,
plot them to PDF and generate a zip archive of all the output files. The
function will find and merge adjacent SBS pairs into DBS if their VAFs are
very similar. The default threshold value for VAF is 0.02.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StrelkaSBSVCFFilesToZipFile(
  dir,
  zipfile,
  ref.genome,
  trans.ranges = NULL,
  region = "unknown",
  names.of.VCFs = NULL,
  base.filename = "",
  return.annotated.vcfs = FALSE,
  suppress.discarded.variants.warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="StrelkaSBSVCFFilesToZipFile_+3A_dir">dir</code></td>
<td>
<p>Pathname of the directory which contains <strong>only</strong> the Strelka
SBS VCF files. Each Strelka SBS VCF <strong>must</strong> have a file extension
&quot;.vcf&quot; (case insensitive) and share the <strong>same</strong> <code>ref.genome</code> and
<code>region</code>.</p>
</td></tr>
<tr><td><code id="StrelkaSBSVCFFilesToZipFile_+3A_zipfile">zipfile</code></td>
<td>
<p>Pathname of the zip file to be created.</p>
</td></tr>
<tr><td><code id="StrelkaSBSVCFFilesToZipFile_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="StrelkaSBSVCFFilesToZipFile_+3A_trans.ranges">trans.ranges</code></td>
<td>
<p>Optional. If <code>ref.genome</code> specifies one of the
<code>BSgenome</code> object
</p>

<ol>
<li> <p><code>BSgenome.Hsapiens.1000genomes.hs37d5</code>
</p>
</li>
<li> <p><code>BSgenome.Hsapiens.UCSC.hg38</code>
</p>
</li>
<li> <p><code>BSgenome.Mmusculus.UCSC.mm10</code>
</p>
</li></ol>

<p>then the function will infer <code>trans.ranges</code> automatically. Otherwise,
user will need to provide the necessary <code>trans.ranges</code>. Please refer to
<code><a href="#topic+TranscriptRanges">TranscriptRanges</a></code> for more details.
If <code>is.null(trans.ranges)</code> do not add transcript range
information.</p>
</td></tr>
<tr><td><code id="StrelkaSBSVCFFilesToZipFile_+3A_region">region</code></td>
<td>
<p>A character string designating a genomic region;
see <code><a href="#topic+as.catalog">as.catalog</a></code> and <code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="StrelkaSBSVCFFilesToZipFile_+3A_names.of.vcfs">names.of.VCFs</code></td>
<td>
<p>Optional. Character vector of names of the VCF files.
The order of names in <code>names.of.VCFs</code> should match the order of VCFs
listed in <code>dir</code>. If <code>NULL</code>(default), this function will remove
all of the path up to and including the last path separator (if any) in
<code>dir</code> and file paths without extensions (and the leading dot) will be
used as the names of the VCF files.</p>
</td></tr>
<tr><td><code id="StrelkaSBSVCFFilesToZipFile_+3A_base.filename">base.filename</code></td>
<td>
<p>Optional. The base name of the CSV and PDF files to be
produced; multiple files will be generated, each ending in
<code class="reqn">x</code><code>.csv</code> or <code class="reqn">x</code><code>.pdf</code>, where <code class="reqn">x</code> indicates the type
of catalog.</p>
</td></tr>
<tr><td><code id="StrelkaSBSVCFFilesToZipFile_+3A_return.annotated.vcfs">return.annotated.vcfs</code></td>
<td>
<p>Logical. Whether to return the annotated VCFs
with additional columns showing mutation class for each variant. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="StrelkaSBSVCFFilesToZipFile_+3A_suppress.discarded.variants.warnings">suppress.discarded.variants.warnings</code></td>
<td>
<p>Logical. Whether to suppress
warning messages showing information about the discarded variants. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code><a href="#topic+StrelkaSBSVCFFilesToCatalog">StrelkaSBSVCFFilesToCatalog</a></code>,
<code><a href="#topic+PlotCatalogToPdf">PlotCatalogToPdf</a></code>, <code><a href="#topic+WriteCatalog">WriteCatalog</a></code> and
<code>zip::zipr</code>.
</p>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>catSBS96</code>, <code>catSBS192</code>, <code>catSBS1536</code>: Matrix of
3 SBS catalogs (one each for 96, 192, and 1536).
</p>
</li>
<li> <p><code>catDBS78</code>, <code>catDBS136</code>, <code>catDBS144</code>: Matrix of
3 DBS catalogs (one each for 78, 136, and 144).
</p>
</li>
<li> <p><code>discarded.variants</code>: <strong>Non-NULL only if</strong> there are variants
that were excluded from the analysis. See the added extra column
<code>discarded.reason</code> for more details.
</p>
</li>
<li> <p><code>annotated.vcfs</code>:
<strong>Non-NULL only if</strong> <code>return.annotated.vcfs</code> = TRUE.
A list of elements:
</p>

<ul>
<li> <p><code>SBS</code>: SBS VCF annotated by <code><a href="#topic+AnnotateSBSVCF">AnnotateSBSVCF</a></code> with
three new columns <code>SBS96.class</code>, <code>SBS192.class</code> and
<code>SBS1536.class</code> showing the mutation class for each SBS variant.
</p>
</li>
<li> <p><code>DBS</code>: DBS VCF annotated by <code><a href="#topic+AnnotateDBSVCF">AnnotateDBSVCF</a></code> with
three new columns <code>DBS78.class</code>, <code>DBS136.class</code> and
<code>DBS144.class</code> showing the mutation class for each DBS variant.
</p>
</li></ul>

</li></ul>

<p>If <code>trans.ranges</code> is not provided by user and cannot be inferred by
ICAMS, SBS 192 and DBS 144 catalog will not be generated. Each catalog has
attributes added. See <code><a href="#topic+as.catalog">as.catalog</a></code> for more details.
</p>


<h3>Note</h3>

<p>SBS 192 and DBS 144 catalogs include only mutations in
transcribed regions.
</p>


<h3>Comments</h3>

<p>To add or change attributes of the catalog, you can use function
<code><a href="base.html#topic+attr">attr</a></code>. <br /> For example, <code>attr(catalog, "abundance")
&lt;- custom.abundance</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dir &lt;- c(system.file("extdata/Strelka-SBS-vcf",
                     package = "ICAMS"))
if (requireNamespace("BSgenome.Hsapiens.1000genomes.hs37d5", quietly = TRUE)) {
  catalogs &lt;-
    StrelkaSBSVCFFilesToZipFile(dir,
                                zipfile = file.path(tempdir(), "test.zip"),
                                ref.genome = "hg19",
                                trans.ranges = trans.ranges.GRCh37,
                                region = "genome",
                                base.filename = "Strelka-SBS")
  unlink(file.path(tempdir(), "test.zip"))}
</code></pre>

<hr>
<h2 id='TCFromCouSigCou'>Source catalog type is counts or counts.signature</h2><span id='topic+TCFromCouSigCou'></span>

<h3>Description</h3>

<p>counts.signature -&gt; density.signature, counts.signature
counts -&gt; anything
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TCFromCouSigCou(s, t)
</code></pre>

<hr>
<h2 id='TCFromDenSigDen'>density -&gt; &lt;anything&gt;
density.signature -&gt; density.signature, counts.signature</h2><span id='topic+TCFromDenSigDen'></span>

<h3>Description</h3>

<p>density -&gt; &lt;anything&gt;
density.signature -&gt; density.signature, counts.signature
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TCFromDenSigDen(s, t)
</code></pre>

<hr>
<h2 id='TestMakeCatalogFromMutectVCFs'>This function makes catalogs from the sample Mutect VCF file
and compares it with the expected catalog information.</h2><span id='topic+TestMakeCatalogFromMutectVCFs'></span>

<h3>Description</h3>

<p>This function makes catalogs from the sample Mutect VCF file
and compares it with the expected catalog information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TestMakeCatalogFromMutectVCFs()
</code></pre>

<hr>
<h2 id='TestMakeCatalogFromStrelkaIDVCFs'>This function is to make catalogs from the sample Strelka ID VCF files
to compare with the expected catalog information.</h2><span id='topic+TestMakeCatalogFromStrelkaIDVCFs'></span>

<h3>Description</h3>

<p>This function is to make catalogs from the sample Strelka ID VCF files
to compare with the expected catalog information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TestMakeCatalogFromStrelkaIDVCFs()
</code></pre>

<hr>
<h2 id='TestMakeCatalogFromStrelkaSBSVCFs'>This function is to make catalogs from the sample Strelka SBS VCF files
to compare with the expected catalog information.</h2><span id='topic+TestMakeCatalogFromStrelkaSBSVCFs'></span>

<h3>Description</h3>

<p>This function is to make catalogs from the sample Strelka SBS VCF files
to compare with the expected catalog information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TestMakeCatalogFromStrelkaSBSVCFs()
</code></pre>

<hr>
<h2 id='TestPlotCatCOMPOSITE'>Plot the a SignatureAnalyzer COMPOSITE signature or catalog into separate pdfs</h2><span id='topic+TestPlotCatCOMPOSITE'></span>

<h3>Description</h3>

<p>Plot the a SignatureAnalyzer COMPOSITE signature or catalog into separate pdfs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TestPlotCatCOMPOSITE(catalog, filename.header, type, id = colnames(catalog))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TestPlotCatCOMPOSITE_+3A_catalog">catalog</code></td>
<td>
<p>Catalog or signature matrix</p>
</td></tr>
<tr><td><code id="TestPlotCatCOMPOSITE_+3A_filename.header">filename.header</code></td>
<td>
<p>Contain path and the beginning part of the file name.
The name of the pdf files will be:
<em>filename.header</em><code>.SBS.96.pdf</code>
<em>filename.header</em><code>.SBS.1536.pdf</code>
<em>filename.header</em><code>.DBS.78.pdf</code>
<em>filename.header</em><code>.ID.83.pdf</code></p>
</td></tr>
<tr><td><code id="TestPlotCatCOMPOSITE_+3A_type">type</code></td>
<td>
<p>See <code><a href="#topic+PlotCatalogToPdf">PlotCatalogToPdf</a></code>.</p>
</td></tr>
<tr><td><code id="TestPlotCatCOMPOSITE_+3A_id">id</code></td>
<td>
<p>A vector containing the identifiers of the samples
or signatures in <code>catalog</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='TranscriptRanges'>Transcript ranges data</h2><span id='topic+TranscriptRanges'></span><span id='topic+trans.ranges.GRCh37'></span><span id='topic+trans.ranges.GRCh38'></span><span id='topic+trans.ranges.GRCm38'></span>

<h3>Description</h3>

<p>Transcript ranges and strand information for a particular reference genome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trans.ranges.GRCh37

trans.ranges.GRCh38

trans.ranges.GRCm38
</code></pre>


<h3>Format</h3>

<p>A <code><a href="data.table.html#topic+data.table">data.table</a></code> which contains transcript
range and strand information for a particular reference genome.
<code>colname</code>s are <code>chrom</code>, <code>start</code>, <code>end</code>, <code>strand</code>,
<code>Ensembl.gene.ID</code>, <code>gene.symbol</code>. It uses one-based coordinates.
</p>
<p>An object of class <code>data.table</code> (inherits from <code>data.frame</code>) with 19083 rows and 6 columns.
</p>
<p>An object of class <code>data.table</code> (inherits from <code>data.frame</code>) with 19096 rows and 6 columns.
</p>
<p>An object of class <code>data.table</code> (inherits from <code>data.frame</code>) with 20325 rows and 6 columns.
</p>


<h3>Details</h3>

<p>This information is needed to generate catalogs that
depend on transcriptional
strand information, for example catalogs of 
class <code>SBS192Catalog</code>. 
</p>
<p><code>trans.ranges.GRCh37</code>:  <strong>Human</strong> GRCh37. 
</p>
<p><code>trans.ranges.GRCh38</code>:  <strong>Human</strong> GRCh38. 
</p>
<p><code>trans.ranges.GRCm38</code>:  <strong>Mouse</strong> GRCm38. 
</p>
<p>For these two tables, only genes that are associated with a CCDS ID are kept for transcriptional
strand bias analysis. 
</p>
<p>This information is needed for <code><a href="#topic+StrelkaSBSVCFFilesToCatalog">StrelkaSBSVCFFilesToCatalog</a></code>, <br />
<code><a href="#topic+StrelkaSBSVCFFilesToCatalogAndPlotToPdf">StrelkaSBSVCFFilesToCatalogAndPlotToPdf</a></code>, 
<code><a href="#topic+MutectVCFFilesToCatalog">MutectVCFFilesToCatalog</a></code>, <br />
<code><a href="#topic+MutectVCFFilesToCatalogAndPlotToPdf">MutectVCFFilesToCatalogAndPlotToPdf</a></code>,
<code><a href="#topic+VCFsToSBSCatalogs">VCFsToSBSCatalogs</a></code> and <code><a href="#topic+VCFsToDBSCatalogs">VCFsToDBSCatalogs</a></code>.
</p>


<h3>Source</h3>

<p><a href="ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_30/GRCh37_mapping/gencode.v30lift37.annotation.gff3.gz">ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_30/GRCh37_mapping/gencode.v30lift37.annotation.gff3.gz</a>
</p>
<p><a href="ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_30/gencode.v30.annotation.gff3.gz">ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_30/gencode.v30.annotation.gff3.gz</a>
</p>
<p><a href="ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_mouse/release_M21/gencode.vM21.annotation.gff3.gz">ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_mouse/release_M21/gencode.vM21.annotation.gff3.gz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trans.ranges.GRCh37
# chrom    start      end strand Ensembl.gene.ID  gene.symbol
#     1    65419    71585      + ENSG00000186092        OR4F5
#     1   367640   368634      + ENSG00000235249       OR4F29
#     1   621059   622053      - ENSG00000284662       OR4F16
#     1   859308   879961      + ENSG00000187634       SAMD11
#     1   879583   894689      - ENSG00000188976        NOC2L
#   ...      ...      ...    ...             ...          ... 
</code></pre>

<hr>
<h2 id='TransformCatalog'>Transform between counts and density spectrum catalogs
and counts and density signature catalogs</h2><span id='topic+TransformCatalog'></span>

<h3>Description</h3>

<p>Transform between counts and density spectrum catalogs
and counts and density signature catalogs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TransformCatalog(
  catalog,
  target.ref.genome = NULL,
  target.region = NULL,
  target.catalog.type = NULL,
  target.abundance = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TransformCatalog_+3A_catalog">catalog</code></td>
<td>
<p>An SBS or DBS catalog as described in <code><a href="#topic+ICAMS">ICAMS</a></code>;
must <strong>not</strong> be an ID (small insertion and deletion) catalog.</p>
</td></tr>
<tr><td><code id="TransformCatalog_+3A_target.ref.genome">target.ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>. If <code>NULL</code>, then defaults to the
<code>ref.genome</code> attribute of <code>catalog</code>.</p>
</td></tr>
<tr><td><code id="TransformCatalog_+3A_target.region">target.region</code></td>
<td>
<p>A <code>region</code> argument; see <code><a href="#topic+as.catalog">as.catalog</a></code>
and <code><a href="#topic+ICAMS">ICAMS</a></code>. If <code>NULL</code>, then defaults to the
<code>region</code> attribute of <code>catalog</code>.</p>
</td></tr>
<tr><td><code id="TransformCatalog_+3A_target.catalog.type">target.catalog.type</code></td>
<td>
<p>A character string acting as a catalog type
identifier, one of &quot;counts&quot;, &quot;density&quot;, &quot;counts.signature&quot;,
&quot;density.signature&quot;; see <code><a href="#topic+as.catalog">as.catalog</a></code>. If <code>NULL</code>, then defaults to the
<code>catalog.type</code> attribute of <code>catalog</code>.</p>
</td></tr>
<tr><td><code id="TransformCatalog_+3A_target.abundance">target.abundance</code></td>
<td>
<p>A vector of counts, one for each source K-mer for mutations (e.g. for
strand-agnostic single nucleotide substitutions in trinucleotide &ndash; i.e.
3-mer &ndash; context, one count each for ACA, ACC, ACG, ... TTT). See
<code><a href="#topic+all.abundance">all.abundance</a></code>. If <code>NULL</code>, the function tries to infer
<code>target.abundace</code> from the class of <code>catalog</code> and the value of
the <code>target.ref.genome</code>, <code>target.region</code>, and
<code>target.catalog.type</code>. If the <code>target.abundance</code> can be inferred
and is different from a supplied non-<code>NULL</code> value of
<code>target.abundance</code>, raise an error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only the following transformations are legal:
</p>

<ol>
<li> <p><code>counts -&gt; counts</code> (deprecated, generates a warning;
we strongly suggest that you work with densities if comparing
spectra or signatures generated from data with
different underlying abundances.)
</p>
</li>
<li> <p><code>counts -&gt; density</code>
</p>
</li>
<li> <p><code>counts -&gt; (counts.signature, density.signature)</code>
</p>
</li>
<li> <p><code>density -&gt; counts</code> (the semantics are to
infer the genome-wide or exome-wide counts based on the
densities)
</p>
</li>
<li> <p><code>density -&gt; density</code> (a null operation, generates
a warning)
</p>
</li>
<li> <p><code>density -&gt; (counts.signature, density.signature)</code>
</p>
</li>
<li> <p><code>counts.signature -&gt; counts.signature</code> (used to transform
between the source abundance and <code>target.abundance</code>)
</p>
</li>
<li> <p><code>counts.signature -&gt; density.signature</code>
</p>
</li>
<li> <p><code>counts.signature -&gt; (counts, density)</code> (generates an error)
</p>
</li>
<li> <p><code>density.signature -&gt; density.signature</code> (a null operation,
generates a warning)
</p>
</li>
<li> <p><code>density.signature -&gt; counts.signature</code>
</p>
</li>
<li> <p><code>density.signature -&gt; (counts, density)</code> (generates an error)
</p>
</li></ol>



<h3>Value</h3>

<p>A catalog as defined in <code><a href="#topic+ICAMS">ICAMS</a></code>.
</p>


<h3>Rationale</h3>

<p>The <code><a href="#topic+TransformCatalog">TransformCatalog</a></code>
function transforms catalogs of mutational spectra or
signatures to account for differing abundances of the source
sequence of the mutations in the genome.
</p>
<p>For example, mutations from
ACG are much rarer in the human genome than mutations from ACC
simply because CG dinucleotides are rare in the genome.
Consequently, there are two possible representations of
mutational spectra or signatures. One representation is
based on mutation counts as observed in a given genome
or exome,
and this approach is widely used, as, for example, at
https://cancer.sanger.ac.uk/cosmic/signatures, which
presents signatures based on observed mutation counts
in the human genome. We call these &quot;counts-based spectra&quot;
or &quot;counts-based signatures&quot;.
</p>
<p>Alternatively,
mutational spectra or signatures can be represented as
mutations per source sequence, for example
the number of ACT &gt; AGT mutations occurring at all
ACT 3-mers in a genome. We call these &quot;density-based
spectra&quot; or &quot;density-based signatures&quot;.
</p>
<p>This function can also transform spectra
based on observed genome-wide counts to &quot;density&quot;-based
catalogs. In density-based catalogs
mutations are expressed as mutations per
source sequences. For example,
a density-based catalog represents
the proportion of ACCs mutated to
ATCs, the proportion of ACGs mutated to ATGs, etc.
This is
different from counts-based mutational spectra catalogs, which
contain the number of ACC &gt; ATC mutations, the number of
ACG &gt; ATG mutations, etc.
</p>
<p>This function can also transform observed-count based
spectra or signatures from genome to exome based counts,
or between different species (since the abundances of
source sequences vary between genome and exome and between
species).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- system.file("extdata",
                    "strelka.regress.cat.sbs.96.csv",
                    package = "ICAMS")
if (requireNamespace("BSgenome.Hsapiens.1000genomes.hs37d5", quietly = TRUE)) {
  catSBS96.counts &lt;- ReadCatalog(file, ref.genome = "hg19", 
                                 region = "genome",
                                 catalog.type = "counts")
  catSBS96.density &lt;- TransformCatalog(catSBS96.counts,
                                       target.ref.genome = "hg19",
                                       target.region = "genome",
                                       target.catalog.type = "density")}
</code></pre>

<hr>
<h2 id='TransRownames.ID.PCAWG.SigPro'>For indels, convert ICAMS/PCAWG7 rownames into SigProfiler rownames</h2><span id='topic+TransRownames.ID.PCAWG.SigPro'></span>

<h3>Description</h3>

<p>For indels, convert ICAMS/PCAWG7 rownames into SigProfiler rownames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TransRownames.ID.PCAWG.SigPro(vector.of.rownames)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>ICAMS:::TransRownames.ID.PCAWG.SigPro("DEL:C:1:0") # 1:Del:C:0;
ICAMS:::TransRownames.ID.PCAWG.SigPro("INS:repeat:2:5+") # 2:Ins:R:5

</code></pre>

<hr>
<h2 id='TransRownames.ID.SigPro.PCAWG'>For indels, convert SigProfiler rownames into ICAMS/PCAWG7 rownames</h2><span id='topic+TransRownames.ID.SigPro.PCAWG'></span>

<h3>Description</h3>

<p>For indels, convert SigProfiler rownames into ICAMS/PCAWG7 rownames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TransRownames.ID.SigPro.PCAWG(vector.of.rownames)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>ICAMS:::TransRownames.ID.SigPro.PCAWG("1:Del:C:0") # DEL:C:1:0;
ICAMS:::TransRownames.ID.SigPro.PCAWG("2:Ins:R:5") # INS:repeat:2:5+

</code></pre>

<hr>
<h2 id='Unstaple1536'>Convert SBS1536-channel mutations-type identifiers like this <code>"AC[C&gt;A]GT" -&gt; "ACCGTA"</code></h2><span id='topic+Unstaple1536'></span>

<h3>Description</h3>

<p>Convert SBS1536-channel mutations-type identifiers like this <code>"AC[C&gt;A]GT" -&gt; "ACCGTA"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Unstaple1536(c1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Unstaple1536_+3A_c1">c1</code></td>
<td>
<p>A vector of character strings with the mutation indicated by
e.g. <code>[C&gt;A]</code> in the middle.</p>
</td></tr>
</table>

<hr>
<h2 id='Unstaple78'>Convert DBS78-channel mutations-type identifiers like this <code>"AC&gt;GA" -&gt; "ACGA"</code></h2><span id='topic+Unstaple78'></span>

<h3>Description</h3>

<p>Convert DBS78-channel mutations-type identifiers like this <code>"AC&gt;GA" -&gt; "ACGA"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Unstaple78(c1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Unstaple78_+3A_c1">c1</code></td>
<td>
<p>A vector of character strings with a <code>&gt;</code> sign separating
reference and variant context e.g. <code>AC&gt;GA</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='Unstaple96'>Convert SBS96-channel mutations-type identifiers like this <code>"A[C&gt;A]T" -&gt; "ACTA"</code></h2><span id='topic+Unstaple96'></span>

<h3>Description</h3>

<p>Convert SBS96-channel mutations-type identifiers like this <code>"A[C&gt;A]T" -&gt; "ACTA"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Unstaple96(c1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Unstaple96_+3A_c1">c1</code></td>
<td>
<p>A vector of character strings with the mutation indicated by
e.g. <code>[C&gt;A]</code> in the middle.</p>
</td></tr>
</table>

<hr>
<h2 id='VCFsToCatalogs'>Create SBS, DBS and Indel catalogs from VCFs</h2><span id='topic+VCFsToCatalogs'></span>

<h3>Description</h3>

<p>Create 3 SBS catalogs (96, 192, 1536), 3 DBS catalogs (78, 136, 144) and
Indel catalog from the Mutect VCFs specified by <code>files</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VCFsToCatalogs(
  files,
  ref.genome,
  variant.caller = "unknown",
  num.of.cores = 1,
  trans.ranges = NULL,
  region = "unknown",
  names.of.VCFs = NULL,
  tumor.col.names = NA,
  filter.status = NULL,
  get.vaf.function = NULL,
  ...,
  max.vaf.diff = 0.02,
  return.annotated.vcfs = FALSE,
  suppress.discarded.variants.warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VCFsToCatalogs_+3A_files">files</code></td>
<td>
<p>Character vector of file paths to the VCF files.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogs_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogs_+3A_variant.caller">variant.caller</code></td>
<td>
<p>Name of the variant caller that produces the VCF, can
be either <code>"strelka"</code>, <code>"mutect"</code>, <code>"freebayes"</code> or
<code>"unknown"</code>. This information is needed to calculate the VAFs (variant
allele frequencies). If variant caller is <code>"unknown"</code>(default) and
<code>get.vaf.function</code> is NULL, then VAF and read depth will be NAs. If
variant caller is <code>"mutect"</code>, do <strong>not</strong> merge SBSs into DBS.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogs_+3A_num.of.cores">num.of.cores</code></td>
<td>
<p>The number of cores to use. Not available on Windows
unless <code>num.of.cores = 1</code>.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogs_+3A_trans.ranges">trans.ranges</code></td>
<td>
<p>Optional. If <code>ref.genome</code> specifies one of the
<code>BSgenome</code> object
</p>

<ol>
<li> <p><code>BSgenome.Hsapiens.1000genomes.hs37d5</code>
</p>
</li>
<li> <p><code>BSgenome.Hsapiens.UCSC.hg38</code>
</p>
</li>
<li> <p><code>BSgenome.Mmusculus.UCSC.mm10</code>
</p>
</li></ol>

<p>then the function will infer <code>trans.ranges</code> automatically. Otherwise,
user will need to provide the necessary <code>trans.ranges</code>. Please refer to
<code><a href="#topic+TranscriptRanges">TranscriptRanges</a></code> for more details.
If <code>is.null(trans.ranges)</code> do not add transcript range
information.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogs_+3A_region">region</code></td>
<td>
<p>A character string designating a genomic region;
see <code><a href="#topic+as.catalog">as.catalog</a></code> and <code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogs_+3A_names.of.vcfs">names.of.VCFs</code></td>
<td>
<p>Optional. Character vector of names of the VCF files.
The order of names in <code>names.of.VCFs</code> should match the order of VCF
file paths in <code>files</code>. If <code>NULL</code>(default), this function will
remove all of the path up to and including the last path separator (if any)
in <code>files</code> and file paths without extensions (and the leading dot)
will be used as the names of the VCF files.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogs_+3A_tumor.col.names">tumor.col.names</code></td>
<td>
<p>Optional. Only applicable to <strong>Mutect</strong> VCFs.
Character vector of column names in <strong>Mutect</strong> VCFs which contain the
tumor sample information. The order of names in <code>tumor.col.names</code>
should match the order of <strong>Mutect</strong> VCFs specified in <code>files</code>.
If <code>tumor.col.names</code> is equal to <code>NA</code>(default), this function
will use the 10th column in all the <strong>Mutect</strong> VCFs to calculate VAFs.
See <code><a href="#topic+GetMutectVAF">GetMutectVAF</a></code> for more details.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogs_+3A_filter.status">filter.status</code></td>
<td>
<p>The status indicating a variant has passed all filters.
An example would be <code>"PASS"</code>. Variants which don't have the specified
<code>filter.status</code> in the <code>FILTER</code> column in VCF will be removed. If
<code>NULL</code>(default), no variants will be removed from the original VCF.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogs_+3A_get.vaf.function">get.vaf.function</code></td>
<td>
<p>Optional. Only applicable when <code>variant.caller</code> is
<strong>&quot;unknown&quot;</strong>. Function to calculate VAF(variant allele frequency) and read
depth information from original VCF. See <code><a href="#topic+GetMutectVAF">GetMutectVAF</a></code> as an example.
If <code>NULL</code>(default) and <code>variant.caller</code> is &quot;unknown&quot;, then VAF
and read depth will be NAs.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogs_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code>get.vaf.function</code>.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogs_+3A_max.vaf.diff">max.vaf.diff</code></td>
<td>
<p><strong>Not</strong> applicable if <code>variant.caller =
  "mutect"</code>. The maximum difference of VAF, default value is 0.02. If the
absolute difference of VAFs for adjacent SBSs is bigger than <code>max.vaf.diff</code>,
then these adjacent SBSs are likely to be &quot;merely&quot; asynchronous single base
mutations, opposed to a simultaneous doublet mutation or variants involving
more than two consecutive bases.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogs_+3A_return.annotated.vcfs">return.annotated.vcfs</code></td>
<td>
<p>Logical. Whether to return the annotated VCFs
with additional columns showing mutation class for each variant. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogs_+3A_suppress.discarded.variants.warnings">suppress.discarded.variants.warnings</code></td>
<td>
<p>Logical. Whether to suppress
warning messages showing information about the discarded variants. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code><a href="#topic+VCFsToSBSCatalogs">VCFsToSBSCatalogs</a></code>,
<code><a href="#topic+VCFsToDBSCatalogs">VCFsToDBSCatalogs</a></code> and <code><a href="#topic+VCFsToIDCatalogs">VCFsToIDCatalogs</a></code>
</p>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>catSBS96</code>, <code>catSBS192</code>, <code>catSBS1536</code>: Matrix of
3 SBS catalogs (one each for 96, 192, and 1536).
</p>
</li>
<li> <p><code>catDBS78</code>, <code>catDBS136</code>, <code>catDBS144</code>: Matrix of
3 DBS catalogs (one each for 78, 136, and 144).
</p>
</li>
<li> <p><code>catID</code>: Matrix of ID (small insertion and deletion) catalog.
</p>
</li>
<li> <p><code>discarded.variants</code>: <strong>Non-NULL only if</strong> there are variants
that were excluded from the analysis. See the added extra column
<code>discarded.reason</code> for more details.
</p>
</li>
<li> <p><code>annotated.vcfs</code>:
<strong>Non-NULL only if</strong> <code>return.annotated.vcfs</code> = TRUE.
A list of elements:
</p>

<ul>
<li> <p><code>SBS</code>: SBS VCF annotated by <code><a href="#topic+AnnotateSBSVCF">AnnotateSBSVCF</a></code> with
three new columns <code>SBS96.class</code>, <code>SBS192.class</code> and
<code>SBS1536.class</code> showing the mutation class for each SBS variant.
</p>
</li>
<li> <p><code>DBS</code>: DBS VCF annotated by <code><a href="#topic+AnnotateDBSVCF">AnnotateDBSVCF</a></code> with
three new columns <code>DBS78.class</code>, <code>DBS136.class</code> and
<code>DBS144.class</code> showing the mutation class for each DBS variant.
</p>
</li>
<li> <p><code>ID</code>: ID VCF annotated by <code><a href="#topic+AnnotateIDVCF">AnnotateIDVCF</a></code> with one
new column <code>ID.class</code> showing the mutation class for each
ID variant.
</p>
</li></ul>

</li></ul>

<p>If <code>trans.ranges</code> is not provided by user and cannot be inferred by
ICAMS, SBS 192 and DBS 144 catalog will not be generated. Each catalog has
attributes added. See <code><a href="#topic+as.catalog">as.catalog</a></code> for more details.
</p>


<h3>ID classification</h3>

<p>See <a href="https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx">https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx</a>
for additional information on ID (small insertion and deletion) mutation
classification.
</p>
<p>See the documentation for <code><a href="#topic+Canonicalize1Del">Canonicalize1Del</a></code> which first handles
deletions in homopolymers, then handles deletions in simple repeats with
longer repeat units, (e.g. <code>CACACACA</code>, see
<code><a href="#topic+FindMaxRepeatDel">FindMaxRepeatDel</a></code>), and if the deletion is not in a simple
repeat, looks for microhomology (see <code><a href="#topic+FindDelMH">FindDelMH</a></code>).
</p>
<p>See the code for unexported function <code><a href="#topic+CanonicalizeID">CanonicalizeID</a></code>
and the functions it calls for handling of insertions.
</p>


<h3>Note</h3>

<p>SBS 192 and DBS 144 catalogs include only mutations in transcribed regions.
In ID (small insertion and deletion) catalogs, deletion repeat sizes range
from 0 to 5+, but for plotting and end-user documentation deletion repeat
sizes range from 1 to 6+.
</p>


<h3>Comments</h3>

<p>To add or change attributes of the catalog, you can use function
<code><a href="base.html#topic+attr">attr</a></code>. <br /> For example, <code>attr(catalog, "abundance")
&lt;- custom.abundance</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- c(system.file("extdata/Mutect-vcf",
                      "Mutect.GRCh37.s1.vcf",
                      package = "ICAMS"))
if (requireNamespace("BSgenome.Hsapiens.1000genomes.hs37d5", quietly = TRUE)) {
  catalogs &lt;- VCFsToCatalogs(file, ref.genome = "hg19",
                             variant.caller = "mutect", region = "genome")}
</code></pre>

<hr>
<h2 id='VCFsToCatalogsAndPlotToPdf'>Create SBS, DBS and Indel catalogs from VCFs and plot them to PDF</h2><span id='topic+VCFsToCatalogsAndPlotToPdf'></span>

<h3>Description</h3>

<p>Create 3 SBS catalogs (96, 192, 1536), 3 DBS catalogs (78, 136, 144) and
Indel catalog from the VCFs specified by <code>files</code> and plot them to
PDF
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VCFsToCatalogsAndPlotToPdf(
  files,
  output.dir,
  ref.genome,
  variant.caller = "unknown",
  num.of.cores = 1,
  trans.ranges = NULL,
  region = "unknown",
  names.of.VCFs = NULL,
  tumor.col.names = NA,
  filter.status = NULL,
  get.vaf.function = NULL,
  ...,
  max.vaf.diff = 0.02,
  base.filename = "",
  return.annotated.vcfs = FALSE,
  suppress.discarded.variants.warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VCFsToCatalogsAndPlotToPdf_+3A_files">files</code></td>
<td>
<p>Character vector of file paths to the VCF files.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogsAndPlotToPdf_+3A_output.dir">output.dir</code></td>
<td>
<p>The directory where the PDF files will be saved.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogsAndPlotToPdf_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogsAndPlotToPdf_+3A_variant.caller">variant.caller</code></td>
<td>
<p>Name of the variant caller that produces the VCF, can
be either <code>"strelka"</code>, <code>"mutect"</code>, <code>"freebayes"</code> or
<code>"unknown"</code>. This information is needed to calculate the VAFs (variant
allele frequencies). If variant caller is <code>"unknown"</code>(default) and
<code>get.vaf.function</code> is NULL, then VAF and read depth will be NAs. If
variant caller is <code>"mutect"</code>, do <strong>not</strong> merge SBSs into DBS.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogsAndPlotToPdf_+3A_num.of.cores">num.of.cores</code></td>
<td>
<p>The number of cores to use. Not available on Windows
unless <code>num.of.cores = 1</code>.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogsAndPlotToPdf_+3A_trans.ranges">trans.ranges</code></td>
<td>
<p>Optional. If <code>ref.genome</code> specifies one of the
<code>BSgenome</code> object
</p>

<ol>
<li> <p><code>BSgenome.Hsapiens.1000genomes.hs37d5</code>
</p>
</li>
<li> <p><code>BSgenome.Hsapiens.UCSC.hg38</code>
</p>
</li>
<li> <p><code>BSgenome.Mmusculus.UCSC.mm10</code>
</p>
</li></ol>

<p>then the function will infer <code>trans.ranges</code> automatically. Otherwise,
user will need to provide the necessary <code>trans.ranges</code>. Please refer to
<code><a href="#topic+TranscriptRanges">TranscriptRanges</a></code> for more details.
If <code>is.null(trans.ranges)</code> do not add transcript range
information.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogsAndPlotToPdf_+3A_region">region</code></td>
<td>
<p>A character string designating a genomic region;
see <code><a href="#topic+as.catalog">as.catalog</a></code> and <code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogsAndPlotToPdf_+3A_names.of.vcfs">names.of.VCFs</code></td>
<td>
<p>Optional. Character vector of names of the VCF files.
The order of names in <code>names.of.VCFs</code> should match the order of VCF
file paths in <code>files</code>. If <code>NULL</code>(default), this function will
remove all of the path up to and including the last path separator (if any)
in <code>files</code> and file paths without extensions (and the leading dot)
will be used as the names of the VCF files.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogsAndPlotToPdf_+3A_tumor.col.names">tumor.col.names</code></td>
<td>
<p>Optional. Only applicable to <strong>Mutect</strong> VCFs.
Character vector of column names in <strong>Mutect</strong> VCFs which contain the
tumor sample information. The order of names in <code>tumor.col.names</code>
should match the order of <strong>Mutect</strong> VCFs specified in <code>files</code>.
If <code>tumor.col.names</code> is equal to <code>NA</code>(default), this function
will use the 10th column in all the <strong>Mutect</strong> VCFs to calculate VAFs.
See <code><a href="#topic+GetMutectVAF">GetMutectVAF</a></code> for more details.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogsAndPlotToPdf_+3A_filter.status">filter.status</code></td>
<td>
<p>The status indicating a variant has passed all filters.
An example would be <code>"PASS"</code>. Variants which don't have the specified
<code>filter.status</code> in the <code>FILTER</code> column in VCF will be removed. If
<code>NULL</code>(default), no variants will be removed from the original VCF.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogsAndPlotToPdf_+3A_get.vaf.function">get.vaf.function</code></td>
<td>
<p>Optional. Only applicable when <code>variant.caller</code> is
<strong>&quot;unknown&quot;</strong>. Function to calculate VAF(variant allele frequency) and read
depth information from original VCF. See <code><a href="#topic+GetMutectVAF">GetMutectVAF</a></code> as an example.
If <code>NULL</code>(default) and <code>variant.caller</code> is &quot;unknown&quot;, then VAF
and read depth will be NAs.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogsAndPlotToPdf_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code>get.vaf.function</code>.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogsAndPlotToPdf_+3A_max.vaf.diff">max.vaf.diff</code></td>
<td>
<p><strong>Not</strong> applicable if <code>variant.caller =
  "mutect"</code>. The maximum difference of VAF, default value is 0.02. If the
absolute difference of VAFs for adjacent SBSs is bigger than <code>max.vaf.diff</code>,
then these adjacent SBSs are likely to be &quot;merely&quot; asynchronous single base
mutations, opposed to a simultaneous doublet mutation or variants involving
more than two consecutive bases.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogsAndPlotToPdf_+3A_base.filename">base.filename</code></td>
<td>
<p>Optional. The base name of the PDF files to be produced;
multiple files will be generated, each ending in <code class="reqn">x</code><code>.pdf</code>, where
<code class="reqn">x</code> indicates the type of catalog plotted in the file.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogsAndPlotToPdf_+3A_return.annotated.vcfs">return.annotated.vcfs</code></td>
<td>
<p>Logical. Whether to return the annotated VCFs
with additional columns showing mutation class for each variant. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="VCFsToCatalogsAndPlotToPdf_+3A_suppress.discarded.variants.warnings">suppress.discarded.variants.warnings</code></td>
<td>
<p>Logical. Whether to suppress
warning messages showing information about the discarded variants. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code><a href="#topic+VCFsToCatalogs">VCFsToCatalogs</a></code> and
<code><a href="#topic+PlotCatalogToPdf">PlotCatalogToPdf</a></code>
</p>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>catSBS96</code>, <code>catSBS192</code>, <code>catSBS1536</code>: Matrix of
3 SBS catalogs (one each for 96, 192, and 1536).
</p>
</li>
<li> <p><code>catDBS78</code>, <code>catDBS136</code>, <code>catDBS144</code>: Matrix of
3 DBS catalogs (one each for 78, 136, and 144).
</p>
</li>
<li> <p><code>catID</code>: Matrix of ID (small insertion and deletion) catalog.
</p>
</li>
<li> <p><code>discarded.variants</code>: <strong>Non-NULL only if</strong> there are variants
that were excluded from the analysis. See the added extra column
<code>discarded.reason</code> for more details.
</p>
</li>
<li> <p><code>annotated.vcfs</code>:
<strong>Non-NULL only if</strong> <code>return.annotated.vcfs</code> = TRUE.
A list of elements:
</p>

<ul>
<li> <p><code>SBS</code>: SBS VCF annotated by <code><a href="#topic+AnnotateSBSVCF">AnnotateSBSVCF</a></code> with
three new columns <code>SBS96.class</code>, <code>SBS192.class</code> and
<code>SBS1536.class</code> showing the mutation class for each SBS variant.
</p>
</li>
<li> <p><code>DBS</code>: DBS VCF annotated by <code><a href="#topic+AnnotateDBSVCF">AnnotateDBSVCF</a></code> with
three new columns <code>DBS78.class</code>, <code>DBS136.class</code> and
<code>DBS144.class</code> showing the mutation class for each DBS variant.
</p>
</li>
<li> <p><code>ID</code>: ID VCF annotated by <code><a href="#topic+AnnotateIDVCF">AnnotateIDVCF</a></code> with one
new column <code>ID.class</code> showing the mutation class for each
ID variant.
</p>
</li></ul>

</li></ul>

<p>If <code>trans.ranges</code> is not provided by user and cannot be inferred by
ICAMS, SBS 192 and DBS 144 catalog will not be generated. Each catalog has
attributes added. See <code><a href="#topic+as.catalog">as.catalog</a></code> for more details.
</p>


<h3>ID classification</h3>

<p>See <a href="https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx">https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx</a>
for additional information on ID (small insertion and deletion) mutation
classification.
</p>
<p>See the documentation for <code><a href="#topic+Canonicalize1Del">Canonicalize1Del</a></code> which first handles
deletions in homopolymers, then handles deletions in simple repeats with
longer repeat units, (e.g. <code>CACACACA</code>, see
<code><a href="#topic+FindMaxRepeatDel">FindMaxRepeatDel</a></code>), and if the deletion is not in a simple
repeat, looks for microhomology (see <code><a href="#topic+FindDelMH">FindDelMH</a></code>).
</p>
<p>See the code for unexported function <code><a href="#topic+CanonicalizeID">CanonicalizeID</a></code>
and the functions it calls for handling of insertions.
</p>


<h3>Note</h3>

<p>SBS 192 and DBS 144 catalogs include only mutations in transcribed regions.
In ID (small insertion and deletion) catalogs, deletion repeat sizes range
from 0 to 5+, but for plotting and end-user documentation deletion repeat
sizes range from 1 to 6+.
</p>


<h3>Comments</h3>

<p>To add or change attributes of the catalog, you can use function
<code><a href="base.html#topic+attr">attr</a></code>. <br /> For example, <code>attr(catalog, "abundance")
&lt;- custom.abundance</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- c(system.file("extdata/Mutect-vcf",
                      "Mutect.GRCh37.s1.vcf",
                      package = "ICAMS"))
if (requireNamespace("BSgenome.Hsapiens.1000genomes.hs37d5", quietly = TRUE)) {
  catalogs &lt;-
    VCFsToCatalogsAndPlotToPdf(file, ref.genome = "hg19",
                               output.dir = tempdir(),
                               variant.caller = "mutect",
                               region = "genome",
                               base.filename = "Mutect")}
</code></pre>

<hr>
<h2 id='VCFsToDBSCatalogs'>Create DBS catalogs from VCFs</h2><span id='topic+VCFsToDBSCatalogs'></span>

<h3>Description</h3>

<p>Create a list of 3 catalogs (one each for DBS78, DBS144 and DBS136)
out of the contents in list.of.DBS.vcfs. The VCFs must not contain
any type of mutation other then DBSs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VCFsToDBSCatalogs(
  list.of.DBS.vcfs,
  ref.genome,
  num.of.cores = 1,
  trans.ranges = NULL,
  region = "unknown",
  return.annotated.vcfs = FALSE,
  suppress.discarded.variants.warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VCFsToDBSCatalogs_+3A_list.of.dbs.vcfs">list.of.DBS.vcfs</code></td>
<td>
<p>List of in-memory data frames of pure DBS mutations
&ndash; no SBS or 3+BS mutations. The list names will be the sample ids in the
output catalog.</p>
</td></tr>
<tr><td><code id="VCFsToDBSCatalogs_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="VCFsToDBSCatalogs_+3A_num.of.cores">num.of.cores</code></td>
<td>
<p>The number of cores to use. Not available on Windows
unless <code>num.of.cores = 1</code>.</p>
</td></tr>
<tr><td><code id="VCFsToDBSCatalogs_+3A_trans.ranges">trans.ranges</code></td>
<td>
<p>Optional. If <code>ref.genome</code> specifies one of the
<code>BSgenome</code> object
</p>

<ol>
<li> <p><code>BSgenome.Hsapiens.1000genomes.hs37d5</code>
</p>
</li>
<li> <p><code>BSgenome.Hsapiens.UCSC.hg38</code>
</p>
</li>
<li> <p><code>BSgenome.Mmusculus.UCSC.mm10</code>
</p>
</li></ol>

<p>then the function will infer <code>trans.ranges</code> automatically. Otherwise,
user will need to provide the necessary <code>trans.ranges</code>. Please refer to
<code><a href="#topic+TranscriptRanges">TranscriptRanges</a></code> for more details.
If <code>is.null(trans.ranges)</code> do not add transcript range
information.</p>
</td></tr>
<tr><td><code id="VCFsToDBSCatalogs_+3A_region">region</code></td>
<td>
<p>A character string designating a genomic region;
see <code><a href="#topic+as.catalog">as.catalog</a></code> and <code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="VCFsToDBSCatalogs_+3A_return.annotated.vcfs">return.annotated.vcfs</code></td>
<td>
<p>Logical. Whether to return the annotated VCFs
with additional columns showing mutation class for each variant. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="VCFsToDBSCatalogs_+3A_suppress.discarded.variants.warnings">suppress.discarded.variants.warnings</code></td>
<td>
<p>Logical. Whether to suppress
warning messages showing information about the discarded variants. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>catDBS78</code>, <code>catDBS136</code>, <code>catDBS144</code>: Matrix of
3 DBS catalogs (one each for 78, 136, and 144).
</p>
</li>
<li> <p><code>discarded.variants</code>: <strong>Non-NULL only if</strong> there are variants
that were excluded from the analysis. See the added extra column
<code>discarded.reason</code> for more details.
</p>
</li>
<li> <p><code>annotated.vcfs</code>: <strong>Non-NULL only if</strong>
<code>return.annotated.vcfs</code> = TRUE. DBS VCF annotated by
<code><a href="#topic+AnnotateDBSVCF">AnnotateDBSVCF</a></code> with three new columns <code>DBS78.class</code>,
<code>DBS136.class</code> and <code>DBS144.class</code> showing the mutation class for
each DBS variant.
</p>
</li></ul>

<p>If <code>trans.ranges</code> is not provided by user and cannot be inferred by
ICAMS, DBS 144 catalog will not be generated. Each catalog has
attributes added. See <code><a href="#topic+as.catalog">as.catalog</a></code> for more details.
</p>


<h3>Comments</h3>

<p>To add or change attributes of the catalog, you can use function
<code><a href="base.html#topic+attr">attr</a></code>. <br /> For example, <code>attr(catalog, "abundance")
&lt;- custom.abundance</code>.
</p>


<h3>Note</h3>

<p>DBS 144 catalog only contains mutations in transcribed regions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- c(system.file("extdata/Mutect-vcf",
                      "Mutect.GRCh37.s1.vcf",
                      package = "ICAMS"))
list.of.DBS.vcfs &lt;- ReadAndSplitMutectVCFs(file)$DBS
if (requireNamespace("BSgenome.Hsapiens.1000genomes.hs37d5", quietly = TRUE)) {
  catalogs.DBS &lt;- VCFsToDBSCatalogs(list.of.DBS.vcfs, ref.genome = "hg19",
                                    trans.ranges = trans.ranges.GRCh37,
                                    region = "genome")}
</code></pre>

<hr>
<h2 id='VCFsToIDCatalogs'>Create ID (small insertion and deletion) catalog from ID VCFs</h2><span id='topic+VCFsToIDCatalogs'></span>

<h3>Description</h3>

<p>Create ID (small insertion and deletion) catalog from ID VCFs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VCFsToIDCatalogs(
  list.of.vcfs,
  ref.genome,
  num.of.cores = 1,
  region = "unknown",
  flag.mismatches = 0,
  return.annotated.vcfs = FALSE,
  suppress.discarded.variants.warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VCFsToIDCatalogs_+3A_list.of.vcfs">list.of.vcfs</code></td>
<td>
<p>List of in-memory ID VCFs. The list names will be
the sample ids in the output catalog.</p>
</td></tr>
<tr><td><code id="VCFsToIDCatalogs_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="VCFsToIDCatalogs_+3A_num.of.cores">num.of.cores</code></td>
<td>
<p>The number of cores to use. Not available on Windows
unless <code>num.of.cores = 1</code>.</p>
</td></tr>
<tr><td><code id="VCFsToIDCatalogs_+3A_region">region</code></td>
<td>
<p>A character string acting as a region identifier, one of
&quot;genome&quot;, &quot;exome&quot;.</p>
</td></tr>
<tr><td><code id="VCFsToIDCatalogs_+3A_flag.mismatches">flag.mismatches</code></td>
<td>
<p>Deprecated. If there are ID variants whose <code>REF</code>
do not match the extracted sequence from <code>ref.genome</code>, the function
will automatically discard these variants and an element
<code>discarded.variants</code> will appear in the return value. See
<code><a href="#topic+AnnotateIDVCF">AnnotateIDVCF</a></code> for more details.</p>
</td></tr>
<tr><td><code id="VCFsToIDCatalogs_+3A_return.annotated.vcfs">return.annotated.vcfs</code></td>
<td>
<p>Logical. Whether to return the annotated VCFs
with additional columns showing mutation class for each variant. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="VCFsToIDCatalogs_+3A_suppress.discarded.variants.warnings">suppress.discarded.variants.warnings</code></td>
<td>
<p>Logical. Whether to suppress
warning messages showing information about the discarded variants. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <strong>list</strong> of elements:
</p>

<ul>
<li> <p><code>catalog</code>: The ID (small insertion and deletion) catalog with
attributes added. See <code><a href="#topic+as.catalog">as.catalog</a></code> for details.
</p>
</li>
<li> <p><code>discarded.variants</code>: <strong>Non-NULL only if</strong> there are variants
that were excluded from the analysis. See the added extra column
<code>discarded.reason</code> for more details.
</p>
</li>
<li> <p><code>annotated.vcfs</code>:
<strong>Non-NULL only if</strong> <code>return.annotated.vcfs</code> = TRUE. A list of
data frames which contain the original VCF's ID mutation rows with three
additional columns <code>seq.context.width</code>, <code>seq.context</code> and
<code>ID.class</code> added. The category assignment of each ID mutation in VCF can
be obtained from <code>ID.class</code> column.
</p>
</li></ul>



<h3>Note</h3>

<p>In ID (small insertion and deletion) catalogs, deletion repeat sizes range
from 0 to 5+, but for plotting and end-user documentation deletion repeat
sizes range from 1 to 6+.
</p>


<h3>ID classification</h3>

<p>See <a href="https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx">https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx</a>
for additional information on ID (small insertion and deletion) mutation
classification.
</p>
<p>See the documentation for <code><a href="#topic+Canonicalize1Del">Canonicalize1Del</a></code> which first handles
deletions in homopolymers, then handles deletions in simple repeats with
longer repeat units, (e.g. <code>CACACACA</code>, see
<code><a href="#topic+FindMaxRepeatDel">FindMaxRepeatDel</a></code>), and if the deletion is not in a simple
repeat, looks for microhomology (see <code><a href="#topic+FindDelMH">FindDelMH</a></code>).
</p>
<p>See the code for unexported function <code><a href="#topic+CanonicalizeID">CanonicalizeID</a></code>
and the functions it calls for handling of insertions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- c(system.file("extdata/Strelka-ID-vcf/",
                      "Strelka.ID.GRCh37.s1.vcf",
                      package = "ICAMS"))
list.of.ID.vcfs &lt;- ReadStrelkaIDVCFs(file)
if (requireNamespace("BSgenome.Hsapiens.1000genomes.hs37d5",
 quietly = TRUE)) {
  catID &lt;- VCFsToIDCatalogs(list.of.ID.vcfs, ref.genome = "hg19",
                            region = "genome")}
</code></pre>

<hr>
<h2 id='VCFsToSBSCatalogs'>Create SBS catalogs from SBS VCFs</h2><span id='topic+VCFsToSBSCatalogs'></span>

<h3>Description</h3>

<p>Create a list of 3 catalogs (one each for 96, 192, 1536)
out of the contents in list.of.SBS.vcfs. The SBS VCFs must not contain
DBSs, indels, or other types of mutations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VCFsToSBSCatalogs(
  list.of.SBS.vcfs,
  ref.genome,
  num.of.cores = 1,
  trans.ranges = NULL,
  region = "unknown",
  return.annotated.vcfs = FALSE,
  suppress.discarded.variants.warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VCFsToSBSCatalogs_+3A_list.of.sbs.vcfs">list.of.SBS.vcfs</code></td>
<td>
<p>List of in-memory data frames of pure SBS mutations
&ndash; no DBS or 3+BS mutations. The list names will be the sample ids in the
output catalog.</p>
</td></tr>
<tr><td><code id="VCFsToSBSCatalogs_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="VCFsToSBSCatalogs_+3A_num.of.cores">num.of.cores</code></td>
<td>
<p>The number of cores to use. Not available on Windows
unless <code>num.of.cores = 1</code>.</p>
</td></tr>
<tr><td><code id="VCFsToSBSCatalogs_+3A_trans.ranges">trans.ranges</code></td>
<td>
<p>Optional. If <code>ref.genome</code> specifies one of the
<code>BSgenome</code> object
</p>

<ol>
<li> <p><code>BSgenome.Hsapiens.1000genomes.hs37d5</code>
</p>
</li>
<li> <p><code>BSgenome.Hsapiens.UCSC.hg38</code>
</p>
</li>
<li> <p><code>BSgenome.Mmusculus.UCSC.mm10</code>
</p>
</li></ol>

<p>then the function will infer <code>trans.ranges</code> automatically. Otherwise,
user will need to provide the necessary <code>trans.ranges</code>. Please refer to
<code><a href="#topic+TranscriptRanges">TranscriptRanges</a></code> for more details.
If <code>is.null(trans.ranges)</code> do not add transcript range
information.</p>
</td></tr>
<tr><td><code id="VCFsToSBSCatalogs_+3A_region">region</code></td>
<td>
<p>A character string designating a genomic region;
see <code><a href="#topic+as.catalog">as.catalog</a></code> and <code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="VCFsToSBSCatalogs_+3A_return.annotated.vcfs">return.annotated.vcfs</code></td>
<td>
<p>Logical. Whether to return the annotated VCFs
with additional columns showing mutation class for each variant. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="VCFsToSBSCatalogs_+3A_suppress.discarded.variants.warnings">suppress.discarded.variants.warnings</code></td>
<td>
<p>Logical. Whether to suppress
warning messages showing information about the discarded variants. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>catSBS96</code>, <code>catSBS192</code>, <code>catSBS1536</code>: Matrix of
3 SBS catalogs (one each for 96, 192, and 1536).
</p>
</li>
<li> <p><code>discarded.variants</code>: <strong>Non-NULL only if</strong> there are variants
that were excluded from the analysis. See the added extra column
<code>discarded.reason</code> for more details.
</p>
</li>
<li> <p><code>annotated.vcfs</code>:
<strong>Non-NULL only if</strong> <code>return.annotated.vcfs</code> = TRUE.
SBS VCF annotated by <code><a href="#topic+AnnotateSBSVCF">AnnotateSBSVCF</a></code> with
three new columns <code>SBS96.class</code>, <code>SBS192.class</code> and
<code>SBS1536.class</code> showing the mutation class for each SBS variant.
</p>
</li></ul>

<p>If <code>trans.ranges</code> is not provided by user and cannot be inferred by
ICAMS, SBS 192 catalog will not be generated. Each catalog has attributes
added. See <code><a href="#topic+as.catalog">as.catalog</a></code> for more details.
</p>


<h3>Comments</h3>

<p>To add or change attributes of the catalog, you can use function
<code><a href="base.html#topic+attr">attr</a></code>. <br /> For example, <code>attr(catalog, "abundance")
&lt;- custom.abundance</code>.
</p>


<h3>Note</h3>

<p>SBS 192 catalogs only contain mutations in transcribed regions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- c(system.file("extdata/Mutect-vcf",
                      "Mutect.GRCh37.s1.vcf",
                      package = "ICAMS"))
list.of.SBS.vcfs &lt;- ReadAndSplitMutectVCFs(file)$SBS
if (requireNamespace("BSgenome.Hsapiens.1000genomes.hs37d5", quietly = TRUE)) {
  catalogs.SBS &lt;- VCFsToSBSCatalogs(list.of.SBS.vcfs, ref.genome = "hg19",
                                    trans.ranges = trans.ranges.GRCh37,
                                    region = "genome")}
</code></pre>

<hr>
<h2 id='VCFsToZipFile'>Create a zip file which contains catalogs and plot PDFs from VCFs</h2><span id='topic+VCFsToZipFile'></span>

<h3>Description</h3>

<p>Create 3 SBS catalogs (96, 192, 1536), 3 DBS catalogs (78, 136, 144) and
Indel catalog from the VCFs specified by <code>dir</code>, save the catalogs
as CSV files, plot them to PDF and generate a zip archive of all the output files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VCFsToZipFile(
  dir,
  files,
  zipfile,
  ref.genome,
  variant.caller = "unknown",
  num.of.cores = 1,
  trans.ranges = NULL,
  region = "unknown",
  names.of.VCFs = NULL,
  tumor.col.names = NA,
  filter.status = NULL,
  get.vaf.function = NULL,
  ...,
  max.vaf.diff = 0.02,
  base.filename = "",
  return.annotated.vcfs = FALSE,
  suppress.discarded.variants.warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VCFsToZipFile_+3A_dir">dir</code></td>
<td>
<p>Pathname of the directory which contains VCFs that come from the
<strong>same</strong> variant caller. Each VCF <strong>must</strong> have a file extension
&quot;.vcf&quot; (case insensitive) and share the <strong>same</strong> <code>ref.genome</code> and
<code>region</code>.</p>
</td></tr>
<tr><td><code id="VCFsToZipFile_+3A_files">files</code></td>
<td>
<p>Character vector of file paths to the VCF files. Only <strong>one</strong> of 
argument <code>dir</code> or <code>files</code> need to be specified.</p>
</td></tr>
<tr><td><code id="VCFsToZipFile_+3A_zipfile">zipfile</code></td>
<td>
<p>Pathname of the zip file to be created.</p>
</td></tr>
<tr><td><code id="VCFsToZipFile_+3A_ref.genome">ref.genome</code></td>
<td>
<p>A <code>ref.genome</code> argument as described in
<code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="VCFsToZipFile_+3A_variant.caller">variant.caller</code></td>
<td>
<p>Name of the variant caller that produces the VCF, can
be either <code>"strelka"</code>, <code>"mutect"</code>, <code>"freebayes"</code> or
<code>"unknown"</code>. This information is needed to calculate the VAFs (variant
allele frequencies). If variant caller is <code>"unknown"</code>(default) and
<code>get.vaf.function</code> is NULL, then VAF and read depth will be NAs. If
variant caller is <code>"mutect"</code>, do <strong>not</strong> merge SBSs into DBS.</p>
</td></tr>
<tr><td><code id="VCFsToZipFile_+3A_num.of.cores">num.of.cores</code></td>
<td>
<p>The number of cores to use. Not available on Windows
unless <code>num.of.cores = 1</code>.</p>
</td></tr>
<tr><td><code id="VCFsToZipFile_+3A_trans.ranges">trans.ranges</code></td>
<td>
<p>Optional. If <code>ref.genome</code> specifies one of the
<code>BSgenome</code> object
</p>

<ol>
<li> <p><code>BSgenome.Hsapiens.1000genomes.hs37d5</code>
</p>
</li>
<li> <p><code>BSgenome.Hsapiens.UCSC.hg38</code>
</p>
</li>
<li> <p><code>BSgenome.Mmusculus.UCSC.mm10</code>
</p>
</li></ol>

<p>then the function will infer <code>trans.ranges</code> automatically. Otherwise,
user will need to provide the necessary <code>trans.ranges</code>. Please refer to
<code><a href="#topic+TranscriptRanges">TranscriptRanges</a></code> for more details.
If <code>is.null(trans.ranges)</code> do not add transcript range
information.</p>
</td></tr>
<tr><td><code id="VCFsToZipFile_+3A_region">region</code></td>
<td>
<p>A character string designating a genomic region;
see <code><a href="#topic+as.catalog">as.catalog</a></code> and <code><a href="#topic+ICAMS">ICAMS</a></code>.</p>
</td></tr>
<tr><td><code id="VCFsToZipFile_+3A_names.of.vcfs">names.of.VCFs</code></td>
<td>
<p>Optional. Character vector of names of the VCF files.
The order of names in <code>names.of.VCFs</code> should match the order of VCFs
listed in <code>dir</code>. If <code>NULL</code>(default), this function will remove
all of the path up to and including the last path separator (if any) in
<code>dir</code> and file paths without extensions (and the leading dot) will be
used as the names of the VCF files.</p>
</td></tr>
<tr><td><code id="VCFsToZipFile_+3A_tumor.col.names">tumor.col.names</code></td>
<td>
<p>Optional. Only applicable to <strong>Mutect</strong> VCFs.
Character vector of column names in <strong>Mutect</strong> VCFs which contain the
tumor sample information. The order of names in <code>tumor.col.names</code>
should match the order of <strong>Mutect</strong> VCFs specified in <code>files</code>.
If <code>tumor.col.names</code> is equal to <code>NA</code>(default), this function
will use the 10th column in all the <strong>Mutect</strong> VCFs to calculate VAFs.
See <code><a href="#topic+GetMutectVAF">GetMutectVAF</a></code> for more details.</p>
</td></tr>
<tr><td><code id="VCFsToZipFile_+3A_filter.status">filter.status</code></td>
<td>
<p>The status indicating a variant has passed all filters.
An example would be <code>"PASS"</code>. Variants which don't have the specified
<code>filter.status</code> in the <code>FILTER</code> column in VCF will be removed. If
<code>NULL</code>(default), no variants will be removed from the original VCF.</p>
</td></tr>
<tr><td><code id="VCFsToZipFile_+3A_get.vaf.function">get.vaf.function</code></td>
<td>
<p>Optional. Only applicable when <code>variant.caller</code> is
<strong>&quot;unknown&quot;</strong>. Function to calculate VAF(variant allele frequency) and read
depth information from original VCF. See <code><a href="#topic+GetMutectVAF">GetMutectVAF</a></code> as an example.
If <code>NULL</code>(default) and <code>variant.caller</code> is &quot;unknown&quot;, then VAF
and read depth will be NAs.</p>
</td></tr>
<tr><td><code id="VCFsToZipFile_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code>get.vaf.function</code>.</p>
</td></tr>
<tr><td><code id="VCFsToZipFile_+3A_max.vaf.diff">max.vaf.diff</code></td>
<td>
<p><strong>Not</strong> applicable if <code>variant.caller =
"mutect"</code>. The maximum difference of VAF, default value is 0.02. If the
absolute difference of VAFs for adjacent SBSs is bigger than <code>max.vaf.diff</code>,
then these adjacent SBSs are likely to be &quot;merely&quot; asynchronous single base
mutations, opposed to a simultaneous doublet mutation or variants involving
more than two consecutive bases.</p>
</td></tr>
<tr><td><code id="VCFsToZipFile_+3A_base.filename">base.filename</code></td>
<td>
<p>Optional. The base name of the CSV and PDF files to be
produced; multiple files will be generated, each ending in
<code class="reqn">x</code><code>.csv</code> or <code class="reqn">x</code><code>.pdf</code>, where <code class="reqn">x</code> indicates the type
of catalog.</p>
</td></tr>
<tr><td><code id="VCFsToZipFile_+3A_return.annotated.vcfs">return.annotated.vcfs</code></td>
<td>
<p>Logical. Whether to return the annotated VCFs
with additional columns showing mutation class for each variant. Default is
FALSE.</p>
</td></tr>
<tr><td><code id="VCFsToZipFile_+3A_suppress.discarded.variants.warnings">suppress.discarded.variants.warnings</code></td>
<td>
<p>Logical. Whether to suppress
warning messages showing information about the discarded variants. Default
is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code><a href="#topic+VCFsToCatalogs">VCFsToCatalogs</a></code>,
<code><a href="#topic+PlotCatalogToPdf">PlotCatalogToPdf</a></code>, <code><a href="#topic+WriteCatalog">WriteCatalog</a></code> and
<code>zip::zipr</code>.
</p>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>catSBS96</code>, <code>catSBS192</code>, <code>catSBS1536</code>: Matrix of
3 SBS catalogs (one each for 96, 192, and 1536).
</p>
</li>
<li> <p><code>catDBS78</code>, <code>catDBS136</code>, <code>catDBS144</code>: Matrix of
3 DBS catalogs (one each for 78, 136, and 144).
</p>
</li>
<li> <p><code>catID</code>: Matrix of ID (small insertion and deletion) catalog.
</p>
</li>
<li> <p><code>discarded.variants</code>: <strong>Non-NULL only if</strong> there are variants
that were excluded from the analysis. See the added extra column
<code>discarded.reason</code> for more details.
</p>
</li>
<li> <p><code>annotated.vcfs</code>:
<strong>Non-NULL only if</strong> <code>return.annotated.vcfs</code> = TRUE.
A list of elements:
</p>

<ul>
<li> <p><code>SBS</code>: SBS VCF annotated by <code><a href="#topic+AnnotateSBSVCF">AnnotateSBSVCF</a></code> with
three new columns <code>SBS96.class</code>, <code>SBS192.class</code> and
<code>SBS1536.class</code> showing the mutation class for each SBS variant.
</p>
</li>
<li> <p><code>DBS</code>: DBS VCF annotated by <code><a href="#topic+AnnotateDBSVCF">AnnotateDBSVCF</a></code> with
three new columns <code>DBS78.class</code>, <code>DBS136.class</code> and
<code>DBS144.class</code> showing the mutation class for each DBS variant.
</p>
</li>
<li> <p><code>ID</code>: ID VCF annotated by <code><a href="#topic+AnnotateIDVCF">AnnotateIDVCF</a></code> with one
new column <code>ID.class</code> showing the mutation class for each
ID variant.
</p>
</li></ul>

</li></ul>

<p>If <code>trans.ranges</code> is not provided by user and cannot be inferred by
ICAMS, SBS 192 and DBS 144 catalog will not be generated. Each catalog has
attributes added. See <code><a href="#topic+as.catalog">as.catalog</a></code> for more details.
</p>


<h3>ID classification</h3>

<p>See <a href="https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx">https://github.com/steverozen/ICAMS/blob/master/data-raw/PCAWG7_indel_classification_2021_09_03.xlsx</a>
for additional information on ID (small insertion and deletion) mutation
classification.
</p>
<p>See the documentation for <code><a href="#topic+Canonicalize1Del">Canonicalize1Del</a></code> which first handles
deletions in homopolymers, then handles deletions in simple repeats with
longer repeat units, (e.g. <code>CACACACA</code>, see
<code><a href="#topic+FindMaxRepeatDel">FindMaxRepeatDel</a></code>), and if the deletion is not in a simple
repeat, looks for microhomology (see <code><a href="#topic+FindDelMH">FindDelMH</a></code>).
</p>
<p>See the code for unexported function <code><a href="#topic+CanonicalizeID">CanonicalizeID</a></code>
and the functions it calls for handling of insertions.
</p>


<h3>Note</h3>

<p>SBS 192 and DBS 144 catalogs include only mutations in transcribed regions.
In ID (small insertion and deletion) catalogs, deletion repeat sizes range
from 0 to 5+, but for plotting and end-user documentation deletion repeat
sizes range from 1 to 6+.
</p>


<h3>Comments</h3>

<p>To add or change attributes of the catalog, you can use function
<code><a href="base.html#topic+attr">attr</a></code>. <br /> For example, <code>attr(catalog, "abundance")
&lt;- custom.abundance</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dir &lt;- c(system.file("extdata/Mutect-vcf",
                     package = "ICAMS"))
if (requireNamespace("BSgenome.Hsapiens.1000genomes.hs37d5", quietly = TRUE)) {
  catalogs &lt;-
    VCFsToZipFile(dir,
                  zipfile = file.path(tempdir(), "test.zip"),
                  ref.genome = "hg19",
                  variant.caller = "mutect",
                  region = "genome",
                  base.filename = "Mutect")
  unlink(file.path(tempdir(), "test.zip"))}
</code></pre>

<hr>
<h2 id='VCFsToZipFileXtra'>Analogous to <code><a href="#topic+VCFsToZipFile">VCFsToZipFile</a></code>, also generates density CSV and PDF files in the zip
archive.</h2><span id='topic+VCFsToZipFileXtra'></span>

<h3>Description</h3>

<p>Analogous to <code><a href="#topic+VCFsToZipFile">VCFsToZipFile</a></code>, also generates density CSV and PDF files in the zip
archive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VCFsToZipFileXtra(
  dir,
  zipfile,
  ref.genome,
  variant.caller = "unknown",
  num.of.cores = 1,
  trans.ranges = NULL,
  region = "unknown",
  names.of.VCFs = NULL,
  tumor.col.names = NA,
  filter.status = NULL,
  get.vaf.function = NULL,
  ...,
  max.vaf.diff = 0.02,
  base.filename = "",
  return.annotated.vcfs = FALSE,
  suppress.discarded.variants.warnings = TRUE
)
</code></pre>

<hr>
<h2 id='WriteCat'>Write a catalog to a file.</h2><span id='topic+WriteCat'></span>

<h3>Description</h3>

<p>This internal function is called by exported functions to do the
actual writing of the catalog.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WriteCat(catalog, file, num.row, row.order, row.header, strict, sep = ",")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WriteCat_+3A_catalog">catalog</code></td>
<td>
<p>A catalog as defined in <code><a href="#topic+ICAMS">ICAMS</a></code> with attributes added.
See <code><a href="#topic+as.catalog">as.catalog</a></code> for more details.</p>
</td></tr>
<tr><td><code id="WriteCat_+3A_file">file</code></td>
<td>
<p>The path of the file to be written.</p>
</td></tr>
<tr><td><code id="WriteCat_+3A_num.row">num.row</code></td>
<td>
<p>The number of rows in the file to be written.</p>
</td></tr>
<tr><td><code id="WriteCat_+3A_row.order">row.order</code></td>
<td>
<p>The row order to be used for writing the file.</p>
</td></tr>
<tr><td><code id="WriteCat_+3A_row.header">row.header</code></td>
<td>
<p>The row header to be used for writing the file.</p>
</td></tr>
<tr><td><code id="WriteCat_+3A_strict">strict</code></td>
<td>
<p>If TRUE, then stop if additional checks on the input fail.</p>
</td></tr>
</table>

<hr>
<h2 id='WriteCatalog'>Write a catalog</h2><span id='topic+WriteCatalog'></span>

<h3>Description</h3>

<p>Write a catalog to a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WriteCatalog(catalog, file, strict = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WriteCatalog_+3A_catalog">catalog</code></td>
<td>
<p>A catalog as defined in <code><a href="#topic+ICAMS">ICAMS</a></code>;
see also <code><a href="#topic+as.catalog">as.catalog</a></code>.</p>
</td></tr>
<tr><td><code id="WriteCatalog_+3A_file">file</code></td>
<td>
<p>The path to the file to be created.</p>
</td></tr>
<tr><td><code id="WriteCatalog_+3A_strict">strict</code></td>
<td>
<p>If TRUE, do additional checks on the input, and stop if the
checks fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See also <code><a href="#topic+ReadCatalog">ReadCatalog</a></code>.
</p>


<h3>Note</h3>

<p>In ID (small insertion and deletion) catalogs, deletion repeat sizes
range from 0 to 5+, but for plotting and end-user documentation
deletion repeat sizes range from 1 to 6+.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- system.file("extdata",
                    "strelka.regress.cat.sbs.96.csv",
                    package = "ICAMS")
catSBS96 &lt;- ReadCatalog(file)
WriteCatalog(catSBS96, file = file.path(tempdir(), "catSBS96.csv"))
</code></pre>

<hr>
<h2 id='WriteCatalogIndelSigPro'>Write Indel Catalogs in SigProExtractor format</h2><span id='topic+WriteCatalogIndelSigPro'></span>

<h3>Description</h3>

<p>Write Indel Catalogs in SigProExtractor format to a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WriteCatalogIndelSigPro(catalog, file, strict = TRUE, sep = "\t")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WriteCatalogIndelSigPro_+3A_catalog">catalog</code></td>
<td>
<p>A catalog as defined in <code><a href="#topic+ICAMS">ICAMS</a></code>;
see also <code><a href="#topic+as.catalog">as.catalog</a></code>.</p>
</td></tr>
<tr><td><code id="WriteCatalogIndelSigPro_+3A_file">file</code></td>
<td>
<p>The path to the file to be created.</p>
</td></tr>
<tr><td><code id="WriteCatalogIndelSigPro_+3A_strict">strict</code></td>
<td>
<p>If TRUE, do additional checks on the input, and stop if the
checks fail.</p>
</td></tr>
<tr><td><code id="WriteCatalogIndelSigPro_+3A_sep">sep</code></td>
<td>
<p>Separator to use in the output file. In older version 
SigProfiler read comma-separated files; as of May 2020 it
reads tab-separated files.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In ID (small insertion and deletion) catalogs in SigProExtractor format, 
deletion repeat sizes range from 0 to 5, rather than 0 to 5+.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
