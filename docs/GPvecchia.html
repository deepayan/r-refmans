<!DOCTYPE html><html lang="en"><head><title>Help for package GPvecchia</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GPvecchia}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GPvecchia'><p>GPvecchia: fast, scalable Gaussian process approximations</p></a></li>
<li><a href='#calculate_posterior_VL'><p>Vecchia Laplace extension of GPVecchia for non-Gaussian data</p></a></li>
<li><a href='#createL'><p>create the sparse triangular L matrix for specific parameters</p></a></li>
<li><a href='#createU'><p>create the sparse triangular U matrix for specific parameters</p></a></li>
<li><a href='#getMatCov'><p>extract the required elements from the covariance matrix</p></a></li>
<li><a href='#getMatCovFromFactorCpp'><p>Calculate the covariance values required by HV for</p>
matrix factors passed as sparse matrices</a></li>
<li><a href='#ic0'><p>Incomplete Cholesky decomposition of a sparse matrix passed in</p>
the compressed sparse row format</a></li>
<li><a href='#ichol'><p>Wrapper for incomplete Cholesky decomposition</p></a></li>
<li><a href='#MaternFun'><p>Calculate Matern covariance function</p></a></li>
<li><a href='#order_coordinate'><p>Sorted coordinate ordering</p></a></li>
<li><a href='#order_dist_to_point'><p>Distance to specified point ordering</p></a></li>
<li><a href='#order_maxmin_exact'><p>Maximum minimum distance ordering</p></a></li>
<li><a href='#order_maxmin_exact_obs_pred'><p>Maximum minimum distance ordering for prediction</p></a></li>
<li><a href='#order_middleout'><p>Middle-out ordering</p></a></li>
<li><a href='#order_outsidein'><p>Outside-in ordering</p></a></li>
<li><a href='#SelInv'><p>selected inverse of a sparse matrix</p></a></li>
<li><a href='#V2covmat'><p>compute covariance matrix from V.ord</p>
Do not run this function for large n or n.p!!!</a></li>
<li><a href='#vecchia_estimate'><p>estimate mean and covariance parameters of a Matern covariance function using Vecchia</p></a></li>
<li><a href='#vecchia_laplace_likelihood'><p>Wrapper for VL version of vecchia_likelihood</p></a></li>
<li><a href='#vecchia_laplace_likelihood_from_posterior'><p>Wrapper for VL version of vecchia_likelihood</p></a></li>
<li><a href='#vecchia_laplace_prediction'><p>Wrapper for VL version of vecchia_prediction</p></a></li>
<li><a href='#vecchia_likelihood'><p>evaluation of the likelihood</p></a></li>
<li><a href='#vecchia_lincomb'><p>linear combination of predictions</p>
compute the distribution of a linear combination Hy</a></li>
<li><a href='#vecchia_pred'><p>make spatial predictions using Vecchia based on estimated parameters</p></a></li>
<li><a href='#vecchia_prediction'><p>Vecchia prediction</p></a></li>
<li><a href='#vecchia_specify'><p>specify a general vecchia approximation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Scalable Gaussian-Process Approximations</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-29</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marcin Jurek &lt;marcinjurek1988@gmail.com&gt;</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthias Katzfuss [aut],
  Marcin Jurek [aut, cre],
  Daniel Zilber [aut],
  Wenlong Gong [aut],
  Joe Guinness [ctb],
  Jingjie Zhang [ctb],
  Florian Schaefer [ctb]</td>
</tr>
<tr>
<td>Description:</td>
<td>Fast scalable Gaussian process approximations, particularly well suited to spatial (aerial, remote-sensed) and environmental data, described in more detail in Katzfuss and Guinness (2017) &lt;<a href="https://doi.org/10.48550/arXiv.1708.06302">doi:10.48550/arXiv.1708.06302</a>&gt;. Package also contains a fast implementation of the incomplete Cholesky decomposition (IC0), based on Schaefer et al. (2019) &lt;<a href="https://doi.org/10.48550/arXiv.1706.02205">doi:10.48550/arXiv.1706.02205</a>&gt; and MaxMin ordering proposed in Guinness (2018) &lt;<a href="https://doi.org/10.48550/arXiv.1609.05372">doi:10.48550/arXiv.1609.05372</a>&gt;.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.9), methods, stats, sparseinv, fields, Matrix(&ge;
1.5.1), parallel, GpGp, FNN</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, BH</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mvtnorm, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-29 20:11:39 UTC; jurek</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-12 11:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='GPvecchia'>GPvecchia: fast, scalable Gaussian process approximations</h2><span id='topic+GPvecchia'></span><span id='topic+GPvecchia-package'></span>

<h3>Description</h3>

<p>The package can be used for parameter inference and prediction for Gaussian and non-Gaussian spatial data using many popular GP approximation methods.
</p>

<hr>
<h2 id='calculate_posterior_VL'>Vecchia Laplace extension of GPVecchia for non-Gaussian data</h2><span id='topic+calculate_posterior_VL'></span>

<h3>Description</h3>

<p>Vecchia Laplace extension of GPVecchia for non-Gaussian data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_posterior_VL(
  z,
  vecchia.approx,
  likelihood_model = c("gaussian", "logistic", "poisson", "gamma", "beta", "gamma_alt"),
  covparms,
  covmodel = "matern",
  likparms = list(alpha = 2, sigma = sqrt(0.1)),
  max.iter = 50,
  convg = 1e-06,
  return_all = FALSE,
  y_init = NA,
  prior_mean = rep(0, length(z)),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_posterior_VL_+3A_z">z</code></td>
<td>
<p>an array of real numbers representing observations</p>
</td></tr>
<tr><td><code id="calculate_posterior_VL_+3A_vecchia.approx">vecchia.approx</code></td>
<td>
<p>a vecchia object as generated by vecchia_specify()</p>
</td></tr>
<tr><td><code id="calculate_posterior_VL_+3A_likelihood_model">likelihood_model</code></td>
<td>
<p>text describing likelihood model to be used for observations.  Can be &quot;gaussian&quot;,&quot;logistic&quot;, &quot;poisson&quot;, &quot;gamma&quot;, or &quot;beta&quot;</p>
</td></tr>
<tr><td><code id="calculate_posterior_VL_+3A_covparms">covparms</code></td>
<td>
<p>covariance parameters as a vector</p>
</td></tr>
<tr><td><code id="calculate_posterior_VL_+3A_covmodel">covmodel</code></td>
<td>
<p>type of the model covariance or selected elements of the covariance matrix</p>
</td></tr>
<tr><td><code id="calculate_posterior_VL_+3A_likparms">likparms</code></td>
<td>
<p>likelihood parameters for the likelihood_model, as a list.  Default values are sqrt(.1) for Gaussian noise and 2 for the alpha parameter for Gamma data.</p>
</td></tr>
<tr><td><code id="calculate_posterior_VL_+3A_max.iter">max.iter</code></td>
<td>
<p>maximum iterations to perform</p>
</td></tr>
<tr><td><code id="calculate_posterior_VL_+3A_convg">convg</code></td>
<td>
<p>convergence criteria.  End iterations if the Newton step is this small</p>
</td></tr>
<tr><td><code id="calculate_posterior_VL_+3A_return_all">return_all</code></td>
<td>
<p>Return additional posterior covariance terms, TRUE or FALSE</p>
</td></tr>
<tr><td><code id="calculate_posterior_VL_+3A_y_init">y_init</code></td>
<td>
<p>Specify initial guess for posterior mode</p>
</td></tr>
<tr><td><code id="calculate_posterior_VL_+3A_prior_mean">prior_mean</code></td>
<td>
<p>specify the prior latent mean</p>
</td></tr>
<tr><td><code id="calculate_posterior_VL_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE messages about the posterior estimation will be displayed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>multivariate normal posterior parameters calculated by the Vecchia-Laplace approximation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z=rnorm(10); locs=matrix(1:10,ncol=1); vecchia.approx=vecchia_specify(locs,m=5)
calculate_posterior_VL(z,vecchia.approx,"gaussian",covparms=c(1,2,.5))
</code></pre>

<hr>
<h2 id='createL'>create the sparse triangular L matrix for specific parameters</h2><span id='topic+createL'></span>

<h3>Description</h3>

<p>create the sparse triangular L matrix for specific parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createL(vecchia.approx, covmodel, covparms = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createL_+3A_vecchia.approx">vecchia.approx</code></td>
<td>
<p>object returned by <code><a href="#topic+vecchia_specify">vecchia_specify</a></code></p>
</td></tr>
<tr><td><code id="createL_+3A_covmodel">covmodel</code></td>
<td>
<p>covariance model. currently implemented:
matern: with covparms (var,range,smoothness)
esqe: exponential + squared exp with covparms (var1,range1,var2,range2)
If covmodel is a function it has to be able to take a distance matrix
and return a vector with distances which is of length k.</p>
</td></tr>
<tr><td><code id="createL_+3A_covparms">covparms</code></td>
<td>
<p>vector of covariance parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the sparse lower triangular L,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z=rnorm(9); locs=matrix(1:9,ncol=1); vecchia.approx=vecchia_specify(locs,m=5)
L = createL(vecchia.approx, covparms=c(1,2,.5), 'matern')
</code></pre>

<hr>
<h2 id='createU'>create the sparse triangular U matrix for specific parameters</h2><span id='topic+createU'></span>

<h3>Description</h3>

<p>create the sparse triangular U matrix for specific parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createU(vecchia.approx, covparms, nuggets, covmodel = "matern")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createU_+3A_vecchia.approx">vecchia.approx</code></td>
<td>
<p>object returned by <code><a href="#topic+vecchia_specify">vecchia_specify</a></code></p>
</td></tr>
<tr><td><code id="createU_+3A_covparms">covparms</code></td>
<td>
<p>vector of covariance parameters</p>
</td></tr>
<tr><td><code id="createU_+3A_nuggets">nuggets</code></td>
<td>
<p>nugget variances &ndash; if a scalar is provided, variance is assumed constant</p>
</td></tr>
<tr><td><code id="createU_+3A_covmodel">covmodel</code></td>
<td>
<p>covariance model. currently implemented:</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the sparse upper triangular U,
plus additional objects required for other functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z=rnorm(9); locs=matrix(1:9,ncol=1); vecchia.approx=vecchia_specify(locs,m=5)
U.obj=createU(vecchia.approx,covparms=c(1,2,.5),nuggets=.2)
</code></pre>

<hr>
<h2 id='getMatCov'>extract the required elements from the covariance matrix</h2><span id='topic+getMatCov'></span>

<h3>Description</h3>

<p>This function takes the entire covariance matrix and creates
a matrix of covariances based on the vecchia approximatino object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMatCov(V, covariances, factor = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMatCov_+3A_v">V</code></td>
<td>
<p>the object returned by vecchia_specify</p>
</td></tr>
<tr><td><code id="getMatCov_+3A_covariances">covariances</code></td>
<td>
<p>The full covariance matrix or a covariance function</p>
</td></tr>
<tr><td><code id="getMatCov_+3A_factor">factor</code></td>
<td>
<p>True if we are passing a factor of a matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of size n x (m+1) with only those elements that 
are used by the incomplete Cholesky decomposition
</p>

<hr>
<h2 id='getMatCovFromFactorCpp'>Calculate the covariance values required by HV for
matrix factors passed as sparse matrices</h2><span id='topic+getMatCovFromFactorCpp'></span>

<h3>Description</h3>

<p>Calculate the covariance values required by HV for
matrix factors passed as sparse matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMatCovFromFactorCpp(F, revNNarray)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMatCovFromFactorCpp_+3A_f">F</code></td>
<td>
<p>factor of a matrix in a sparse format</p>
</td></tr>
<tr><td><code id="getMatCovFromFactorCpp_+3A_revnnarray">revNNarray</code></td>
<td>
<p>array with the neighbourhood structure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with covariance values
</p>

<hr>
<h2 id='ic0'>Incomplete Cholesky decomposition of a sparse matrix passed in
the compressed sparse row format</h2><span id='topic+ic0'></span>

<h3>Description</h3>

<p>Incomplete Cholesky decomposition of a sparse matrix passed in
the compressed sparse row format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ic0(ptrs, inds, vals)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ic0_+3A_ptrs">ptrs</code></td>
<td>
<p>pointers to the beginning of the row</p>
</td></tr>
<tr><td><code id="ic0_+3A_inds">inds</code></td>
<td>
<p>indices of nonzero elements in a row</p>
</td></tr>
<tr><td><code id="ic0_+3A_vals">vals</code></td>
<td>
<p>nonzero values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of the values of the incomplete Cholesky factor
</p>

<hr>
<h2 id='ichol'>Wrapper for incomplete Cholesky decomposition</h2><span id='topic+ichol'></span>

<h3>Description</h3>

<p>Wrapper for incomplete Cholesky decomposition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ichol(M, S = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ichol_+3A_m">M</code></td>
<td>
<p>the matrix to be decomposed</p>
</td></tr>
<tr><td><code id="ichol_+3A_s">S</code></td>
<td>
<p>sparsity pattern matrix given</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the incomplete Cholesky factor in the sparse format
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A = matrix(runif(25), ncol = 5)
A = t(A) * A + 2 * Matrix::Diagonal(5)
S = Matrix::Matrix(c(rep(1, 5), c(0, 1, 1, 0, 0), c(0, 0, 1, 0, 1),
c(0, 0, 0, 1, 0), c(0, 0, 0, 0, 1)), ncol = 5, byrow = TRUE)
I1 = ichol(A, S)
I2 = ichol(A * S)

</code></pre>

<hr>
<h2 id='MaternFun'>Calculate Matern covariance function</h2><span id='topic+MaternFun'></span>

<h3>Description</h3>

<p>Calculate Matern covariance function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MaternFun(distmat, covparms)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MaternFun_+3A_distmat">distmat</code></td>
<td>
<p>A matrix with distances between points</p>
</td></tr>
<tr><td><code id="MaternFun_+3A_covparms">covparms</code></td>
<td>
<p>A vector with parameters (marg. variance, range, smoothness)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with covariance values corresponding to the distance matrix
</p>

<hr>
<h2 id='order_coordinate'>Sorted coordinate ordering</h2><span id='topic+order_coordinate'></span>

<h3>Description</h3>

<p>Return the ordering of locations sorted along one of the
coordinates or the sum of multiple coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_coordinate(locs, coordinate)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="order_coordinate_+3A_locs">locs</code></td>
<td>
<p>A matrix of locations. Each row of <code>locs</code> contains a location, which can
be a point in Euclidean space R^d, a point in space-time R^d x T,
a longitude and latitude (in degrees) giving a point on the sphere,
or a longitude, latitude, and time giving a point in the sphere-time domain.</p>
</td></tr>
<tr><td><code id="order_coordinate_+3A_coordinate">coordinate</code></td>
<td>
<p>integer or vector of integers in {1,...,d}. If a single integer,
coordinates are ordered along that coordinate. If multiple integers,
coordinates are ordered according to the sum of specified coordinate values. For example,
when <code>d=2</code>, <code>coordinate = c(1,2)</code> orders from bottom left to top right.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of indices giving the ordering, i.e.
the first element of this vector is the index of the first location.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100             # Number of locations
d &lt;- 2               # dimension of domain
locs &lt;- matrix( runif(n*d), n, d )
ord1 &lt;- order_coordinate(locs, 1 )
ord12 &lt;- order_coordinate(locs, c(1,2) )
</code></pre>

<hr>
<h2 id='order_dist_to_point'>Distance to specified point ordering</h2><span id='topic+order_dist_to_point'></span>

<h3>Description</h3>

<p>Return the ordering of locations increasing in their
distance to some specified location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_dist_to_point(locs, loc0, lonlat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="order_dist_to_point_+3A_locs">locs</code></td>
<td>
<p>A matrix of locations. Each row of <code>locs</code> contains a location, which can
be a point in Euclidean space R^d, a point in space-time R^d x T,
a longitude and latitude (in degrees) giving a point on the sphere,
or a longitude, latitude, and time giving a point in the sphere-time domain.</p>
</td></tr>
<tr><td><code id="order_dist_to_point_+3A_loc0">loc0</code></td>
<td>
<p>A vector containing a single location in R^d.</p>
</td></tr>
<tr><td><code id="order_dist_to_point_+3A_lonlat">lonlat</code></td>
<td>
<p>TRUE/FALSE whether locations are longitudes and latitudes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of indices giving the ordering, i.e.
the first element of this vector is the index of the location nearest to <code>loc0</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100             # Number of locations
d &lt;- 2               # dimension of domain
locs &lt;- matrix( runif(n*d), n, d )
loc0 &lt;- c(1/2,1/2)
ord &lt;- order_dist_to_point(locs,loc0)
</code></pre>

<hr>
<h2 id='order_maxmin_exact'>Maximum minimum distance ordering</h2><span id='topic+order_maxmin_exact'></span>

<h3>Description</h3>

<p>Return the indices of an exact maximum-minimum distance ordering.
The first point is chosen as the &quot;center&quot; point, minimizing L2 distance.
Dimensions d=2 and d=3 handled separately, dimensions d=1 and d&gt;3 handled similarly.
Algorithm is exact and scales quasilinearly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_maxmin_exact(locs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="order_maxmin_exact_+3A_locs">locs</code></td>
<td>
<p>Observation locations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of indices giving the ordering, i.e.
the first element of this vector is the index of the first location.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n=100; locs &lt;- cbind(runif(n),runif(n))
ord &lt;- order_maxmin_exact(locs)

</code></pre>

<hr>
<h2 id='order_maxmin_exact_obs_pred'>Maximum minimum distance ordering for prediction</h2><span id='topic+order_maxmin_exact_obs_pred'></span>

<h3>Description</h3>

<p>Return the indices of an exact maximum-minimum distance ordering.
The first point is chosen as the &quot;center&quot; point, minimizing L2 distance.
Dimensions d=2 and d=3 handled separately, dimensions d=1 and d&gt;3 handled similarly.
Algorithm is exact and scales quasilinearly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_maxmin_exact_obs_pred(locs, locs_pred)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="order_maxmin_exact_obs_pred_+3A_locs">locs</code></td>
<td>
<p>Observation locations</p>
</td></tr>
<tr><td><code id="order_maxmin_exact_obs_pred_+3A_locs_pred">locs_pred</code></td>
<td>
<p>Prediction locations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of indices giving the ordering, i.e.
the first element of this vector is the index of the first location.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n=100; locs &lt;- cbind(runif(n),runif(n))
locs_pred = cbind(runif(n), runif(n))
ord &lt;- order_maxmin_exact_obs_pred(locs, locs_pred)

</code></pre>

<hr>
<h2 id='order_middleout'>Middle-out ordering</h2><span id='topic+order_middleout'></span>

<h3>Description</h3>

<p>Return the ordering of locations increasing in their
distance to the average location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_middleout(locs, lonlat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="order_middleout_+3A_locs">locs</code></td>
<td>
<p>A matrix of locations. Each row of <code>locs</code> contains a location, which can
be a point in Euclidean space R^d, a point in space-time R^d x T,
a longitude and latitude (in degrees) giving a point on the sphere,
or a longitude, latitude, and time giving a point in the sphere-time domain.</p>
</td></tr>
<tr><td><code id="order_middleout_+3A_lonlat">lonlat</code></td>
<td>
<p>TRUE/FALSE whether locations are longitudes and latitudes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of indices giving the ordering, i.e.
the first element of this vector is the index of the location nearest the center.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100             # Number of locations
d &lt;- 2               # dimension of domain
locs &lt;- matrix( runif(n*d), n, d )
ord &lt;- order_middleout(locs)
</code></pre>

<hr>
<h2 id='order_outsidein'>Outside-in ordering</h2><span id='topic+order_outsidein'></span>

<h3>Description</h3>

<p>Return the ordering of locations decreasing in their
distance to the average location.  Reverses middleout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_outsidein(locs, lonlat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="order_outsidein_+3A_locs">locs</code></td>
<td>
<p>A matrix of locations. Each row of <code>locs</code> contains a location, which can
be a point in Euclidean space R^d, a point in space-time R^d x T,
a longitude and latitude (in degrees) giving a point on the sphere,
or a longitude, latitude, and time giving a point in the sphere-time domain.</p>
</td></tr>
<tr><td><code id="order_outsidein_+3A_lonlat">lonlat</code></td>
<td>
<p>TRUE/FALSE whether locations are longitudes and latitudes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of indices giving the ordering, i.e.
the first element of this vector is the index of the location farthest from the center.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100             # Number of locations
d &lt;- 2               # dimension of domain
locs &lt;- matrix( runif(n*d), n, d )
ord &lt;- order_outsidein(locs)
</code></pre>

<hr>
<h2 id='SelInv'>selected inverse of a sparse matrix</h2><span id='topic+SelInv'></span>

<h3>Description</h3>

<p>selected inverse of a sparse matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SelInv(cholmat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SelInv_+3A_cholmat">cholmat</code></td>
<td>
<p>cholesky factor L of a positive definite sparseMatrix A</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sparse inverse of A, with same sparsity pattern as L
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A=Matrix::sparseMatrix(1:9,1:9,x=4); L=Matrix::chol(A)
SelInv(L)
</code></pre>

<hr>
<h2 id='V2covmat'>compute covariance matrix from V.ord
Do not run this function for large n or n.p!!!</h2><span id='topic+V2covmat'></span>

<h3>Description</h3>

<p>compute covariance matrix from V.ord
Do not run this function for large n or n.p!!!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>V2covmat(preds)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="V2covmat_+3A_preds">preds</code></td>
<td>
<p>Object returned by vecchia_prediction()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Covariance matrix at all locations in original order
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z=rnorm(5)
locs=matrix(1:5,ncol=1)
vecchia_specify=function(z,locs,m=5,locs.pred=(1:5)+.5)
V2covmat(vecchia_prediction(vecchia.approx,covparms=c(1,2,.5),nuggets=.2))
</code></pre>

<hr>
<h2 id='vecchia_estimate'>estimate mean and covariance parameters of a Matern covariance function using Vecchia</h2><span id='topic+vecchia_estimate'></span>

<h3>Description</h3>

<p>estimate mean and covariance parameters of a Matern covariance function using Vecchia
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecchia_estimate(
  data,
  locs,
  X,
  m = 20,
  covmodel = "matern",
  theta.ini,
  output.level = 1,
  reltol = sqrt(.Machine$double.eps),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vecchia_estimate_+3A_data">data</code></td>
<td>
<p>data vector of length n</p>
</td></tr>
<tr><td><code id="vecchia_estimate_+3A_locs">locs</code></td>
<td>
<p>n x d matrix of spatial locations</p>
</td></tr>
<tr><td><code id="vecchia_estimate_+3A_x">X</code></td>
<td>
<p>n x p matrix of trend covariates. default is vector of ones (constant trend).
set to NULL if data are already detrended</p>
</td></tr>
<tr><td><code id="vecchia_estimate_+3A_m">m</code></td>
<td>
<p>number of neighbors for vecchia approximation. default is 20</p>
</td></tr>
<tr><td><code id="vecchia_estimate_+3A_covmodel">covmodel</code></td>
<td>
<p>covariance model. default is Matern.
see <code><a href="#topic+vecchia_likelihood">vecchia_likelihood</a></code> for details.</p>
</td></tr>
<tr><td><code id="vecchia_estimate_+3A_theta.ini">theta.ini</code></td>
<td>
<p>initial values of covariance parameters. nugget variance must be last.</p>
</td></tr>
<tr><td><code id="vecchia_estimate_+3A_output.level">output.level</code></td>
<td>
<p>passed on to trace in the <code>stats::optim</code> function</p>
</td></tr>
<tr><td><code id="vecchia_estimate_+3A_reltol">reltol</code></td>
<td>
<p>tolerance for the optimization function; by default set to the sqrt of machine
precision</p>
</td></tr>
<tr><td><code id="vecchia_estimate_+3A_...">...</code></td>
<td>
<p>additional input parameters for <code><a href="#topic+vecchia_specify">vecchia_specify</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>object containing detrended data z, trend coefficients beta.hat,
covariance parameters theta.hat, and other quantities necessary for prediction
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n=10^2; locs=cbind(runif(n),runif(n))
covparms=c(1,.1,.5); nuggets=rep(.1,n)
Sigma=exp(-fields::rdist(locs)/covparms[2])+diag(nuggets)
z=as.numeric(t(chol(Sigma))%*%rnorm(n));
data=z+1
vecchia.est=vecchia_estimate(data,locs,theta.ini=c(covparms,nuggets[1]))

</code></pre>

<hr>
<h2 id='vecchia_laplace_likelihood'>Wrapper for VL version of vecchia_likelihood</h2><span id='topic+vecchia_laplace_likelihood'></span>

<h3>Description</h3>

<p>Wrapper for VL version of vecchia_likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecchia_laplace_likelihood(
  z,
  vecchia.approx,
  likelihood_model,
  covparms,
  likparms = list(alpha = 2, sigma = sqrt(0.1)),
  covmodel = "matern",
  max.iter = 50,
  convg = 1e-05,
  return_all = FALSE,
  y_init = NA,
  prior_mean = rep(0, length(z)),
  vecchia.approx.IW = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vecchia_laplace_likelihood_+3A_z">z</code></td>
<td>
<p>an array of real numbers representing observations</p>
</td></tr>
<tr><td><code id="vecchia_laplace_likelihood_+3A_vecchia.approx">vecchia.approx</code></td>
<td>
<p>a vecchia object as generated by vecchia_specify()</p>
</td></tr>
<tr><td><code id="vecchia_laplace_likelihood_+3A_likelihood_model">likelihood_model</code></td>
<td>
<p>text describing likelihood model to be used for observations</p>
</td></tr>
<tr><td><code id="vecchia_laplace_likelihood_+3A_covparms">covparms</code></td>
<td>
<p>covariance parameters as a vector</p>
</td></tr>
<tr><td><code id="vecchia_laplace_likelihood_+3A_likparms">likparms</code></td>
<td>
<p>likelihood parameters for the likelihood_model, as a list</p>
</td></tr>
<tr><td><code id="vecchia_laplace_likelihood_+3A_covmodel">covmodel</code></td>
<td>
<p>describes the covariance model, &quot;matern&quot; by default</p>
</td></tr>
<tr><td><code id="vecchia_laplace_likelihood_+3A_max.iter">max.iter</code></td>
<td>
<p>maximum iterations to perform</p>
</td></tr>
<tr><td><code id="vecchia_laplace_likelihood_+3A_convg">convg</code></td>
<td>
<p>convergence criteria.  End iterations if the Newton step is this small</p>
</td></tr>
<tr><td><code id="vecchia_laplace_likelihood_+3A_return_all">return_all</code></td>
<td>
<p>Return additional posterior covariance terms</p>
</td></tr>
<tr><td><code id="vecchia_laplace_likelihood_+3A_y_init">y_init</code></td>
<td>
<p>Specify initial guess for posterior mode</p>
</td></tr>
<tr><td><code id="vecchia_laplace_likelihood_+3A_prior_mean">prior_mean</code></td>
<td>
<p>specify the prior latent mean</p>
</td></tr>
<tr><td><code id="vecchia_laplace_likelihood_+3A_vecchia.approx.iw">vecchia.approx.IW</code></td>
<td>
<p>an optional vecchia approximation object, can reduce computation if method is called repeatedly</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(multivariate normal) loglikelihood implied by the Vecchia approximation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z=rnorm(10); locs=matrix(1:10,ncol=1); vecchia.approx=vecchia_specify(locs,m=5)
vecchia_laplace_likelihood(z,vecchia.approx,"gaussian",covparms=c(1,2,.5))
</code></pre>

<hr>
<h2 id='vecchia_laplace_likelihood_from_posterior'>Wrapper for VL version of vecchia_likelihood</h2><span id='topic+vecchia_laplace_likelihood_from_posterior'></span>

<h3>Description</h3>

<p>Wrapper for VL version of vecchia_likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecchia_laplace_likelihood_from_posterior(
  z,
  posterior,
  vecchia.approx,
  likelihood_model,
  covparms,
  likparms = list(alpha = 2, sigma = sqrt(0.1)),
  covmodel = "matern",
  max.iter = 50,
  convg = 1e-05,
  return_all = FALSE,
  y_init = NA,
  prior_mean = rep(0, length(z)),
  vecchia.approx.IW = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vecchia_laplace_likelihood_from_posterior_+3A_z">z</code></td>
<td>
<p>an array of real numbers representing observations</p>
</td></tr>
<tr><td><code id="vecchia_laplace_likelihood_from_posterior_+3A_posterior">posterior</code></td>
<td>
<p>posterior distribution obtained from calculate_posterior_VL()</p>
</td></tr>
<tr><td><code id="vecchia_laplace_likelihood_from_posterior_+3A_vecchia.approx">vecchia.approx</code></td>
<td>
<p>a vecchia object as generated by vecchia_specify()</p>
</td></tr>
<tr><td><code id="vecchia_laplace_likelihood_from_posterior_+3A_likelihood_model">likelihood_model</code></td>
<td>
<p>text describing likelihood model to be used for observations</p>
</td></tr>
<tr><td><code id="vecchia_laplace_likelihood_from_posterior_+3A_covparms">covparms</code></td>
<td>
<p>covariance parameters as a vector</p>
</td></tr>
<tr><td><code id="vecchia_laplace_likelihood_from_posterior_+3A_likparms">likparms</code></td>
<td>
<p>likelihood parameters for the likelihood_model, as a list</p>
</td></tr>
<tr><td><code id="vecchia_laplace_likelihood_from_posterior_+3A_covmodel">covmodel</code></td>
<td>
<p>describes the covariance model, &quot;matern&quot; by default</p>
</td></tr>
<tr><td><code id="vecchia_laplace_likelihood_from_posterior_+3A_max.iter">max.iter</code></td>
<td>
<p>maximum iterations to perform</p>
</td></tr>
<tr><td><code id="vecchia_laplace_likelihood_from_posterior_+3A_convg">convg</code></td>
<td>
<p>convergence criteria.  End iterations if the Newton step is this small</p>
</td></tr>
<tr><td><code id="vecchia_laplace_likelihood_from_posterior_+3A_return_all">return_all</code></td>
<td>
<p>Return additional posterior covariance terms</p>
</td></tr>
<tr><td><code id="vecchia_laplace_likelihood_from_posterior_+3A_y_init">y_init</code></td>
<td>
<p>Specify initial guess for posterior mode</p>
</td></tr>
<tr><td><code id="vecchia_laplace_likelihood_from_posterior_+3A_prior_mean">prior_mean</code></td>
<td>
<p>specify the prior latent mean</p>
</td></tr>
<tr><td><code id="vecchia_laplace_likelihood_from_posterior_+3A_vecchia.approx.iw">vecchia.approx.IW</code></td>
<td>
<p>an optional vecchia approximation object, can reduce computation if method is called repeatedly</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(multivariate normal) loglikelihood implied by the Vecchia approximation
</p>

<hr>
<h2 id='vecchia_laplace_prediction'>Wrapper for VL version of vecchia_prediction</h2><span id='topic+vecchia_laplace_prediction'></span>

<h3>Description</h3>

<p>Wrapper for VL version of vecchia_prediction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecchia_laplace_prediction(
  vl_posterior,
  vecchia.approx,
  covparms,
  pred.mean = 0,
  var.exact = FALSE,
  covmodel = "matern",
  return.values = "all"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vecchia_laplace_prediction_+3A_vl_posterior">vl_posterior</code></td>
<td>
<p>a posterior estimate object produced by calculate_posterior_VL</p>
</td></tr>
<tr><td><code id="vecchia_laplace_prediction_+3A_vecchia.approx">vecchia.approx</code></td>
<td>
<p>a vecchia object as generated by vecchia_specify()</p>
</td></tr>
<tr><td><code id="vecchia_laplace_prediction_+3A_covparms">covparms</code></td>
<td>
<p>covariance parameters as a vector</p>
</td></tr>
<tr><td><code id="vecchia_laplace_prediction_+3A_pred.mean">pred.mean</code></td>
<td>
<p>provides the prior latent mean for the prediction locations</p>
</td></tr>
<tr><td><code id="vecchia_laplace_prediction_+3A_var.exact">var.exact</code></td>
<td>
<p>should prediction variances be computed exactly, or is a (faster) approximation acceptable</p>
</td></tr>
<tr><td><code id="vecchia_laplace_prediction_+3A_covmodel">covmodel</code></td>
<td>
<p>covariance model, 'matern' by default.</p>
</td></tr>
<tr><td><code id="vecchia_laplace_prediction_+3A_return.values">return.values</code></td>
<td>
<p>either 'mean' only, 'meanvar', 'meanmat', or 'all'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(multivariate normal) loglikelihood implied by the Vecchia approximation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z=rnorm(10); locs=matrix(1:10,ncol=1); vecchia.approx=vecchia_specify(locs,m=5)
vl_posterior = calculate_posterior_VL(z,vecchia.approx,"gaussian",covparms=c(1,2,.5))
locs.pred=matrix(1:10+.5,ncol=1)
vecchia.approx.pred = vecchia_specify(locs, m=5, locs.pred=locs.pred )
vecchia_laplace_prediction(vl_posterior,vecchia.approx.pred,covparms=c(1,2,.5))
</code></pre>

<hr>
<h2 id='vecchia_likelihood'>evaluation of the likelihood</h2><span id='topic+vecchia_likelihood'></span>

<h3>Description</h3>

<p>evaluation of the likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecchia_likelihood(z, vecchia.approx, covparms, nuggets, covmodel = "matern")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vecchia_likelihood_+3A_z">z</code></td>
<td>
<p>the observed data</p>
</td></tr>
<tr><td><code id="vecchia_likelihood_+3A_vecchia.approx">vecchia.approx</code></td>
<td>
<p>a vecchia object as generated by vecchia_specify()</p>
</td></tr>
<tr><td><code id="vecchia_likelihood_+3A_covparms">covparms</code></td>
<td>
<p>covariance parameters as a vector</p>
</td></tr>
<tr><td><code id="vecchia_likelihood_+3A_nuggets">nuggets</code></td>
<td>
<p>either a single (constant) nugget or a vector of nugget terms for the observations</p>
</td></tr>
<tr><td><code id="vecchia_likelihood_+3A_covmodel">covmodel</code></td>
<td>
<p>covariance model, 'matern' by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(multivariate normal) loglikelihood implied by the Vecchia approximation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z=rnorm(5); locs=matrix(1:5,ncol=1); vecchia.approx=vecchia_specify(locs,m=3)
vecchia_likelihood(z,vecchia.approx,covparms=c(1,2,.5),nuggets=.2)
</code></pre>

<hr>
<h2 id='vecchia_lincomb'>linear combination of predictions
compute the distribution of a linear combination Hy</h2><span id='topic+vecchia_lincomb'></span>

<h3>Description</h3>

<p>linear combination of predictions
compute the distribution of a linear combination Hy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecchia_lincomb(H, U.obj, V.ord, cov.mat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vecchia_lincomb_+3A_h">H</code></td>
<td>
<p>sparse matrix with n.all columns specifying the linear combination</p>
</td></tr>
<tr><td><code id="vecchia_lincomb_+3A_u.obj">U.obj</code></td>
<td>
<p>U matrix is the full joint approximated cholesky matrix</p>
</td></tr>
<tr><td><code id="vecchia_lincomb_+3A_v.ord">V.ord</code></td>
<td>
<p>ordered V matrix from vecchia_prediction() or U2V()</p>
</td></tr>
<tr><td><code id="vecchia_lincomb_+3A_cov.mat">cov.mat</code></td>
<td>
<p>logical TRUE or FALSE &ndash; should the entire covariance matrix be returned (only do if H has a small number of rows)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Variance of linear combination of predictions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n=5; z=rnorm(n); locs=matrix(1:n,ncol=1); n.p=5
vecchia.approx = vecchia_specify(locs,m=3,locs.pred=locs+.5)
preds=vecchia_prediction(z,vecchia.approx,covparms=c(1,2,.5),nuggets=.2)
H=Matrix::sparseMatrix(i=rep(1,n.p),j=n+(1:n.p),x=1/n.p)
vecchia_lincomb(H,vecchia.approx,preds$V.ord,cov.mat=TRUE)
</code></pre>

<hr>
<h2 id='vecchia_pred'>make spatial predictions using Vecchia based on estimated parameters</h2><span id='topic+vecchia_pred'></span>

<h3>Description</h3>

<p>make spatial predictions using Vecchia based on estimated parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecchia_pred(vecchia.est, locs.pred, X.pred, m = 30, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vecchia_pred_+3A_vecchia.est">vecchia.est</code></td>
<td>
<p>object returned by <code><a href="#topic+vecchia_estimate">vecchia_estimate</a></code></p>
</td></tr>
<tr><td><code id="vecchia_pred_+3A_locs.pred">locs.pred</code></td>
<td>
<p>n.p x d matrix of prediction locations</p>
</td></tr>
<tr><td><code id="vecchia_pred_+3A_x.pred">X.pred</code></td>
<td>
<p>n.p x p matrix of trend covariates at prediction locations.
does not need to be specified if constant or no trend was used in
<code><a href="#topic+vecchia_estimate">vecchia_estimate</a></code></p>
</td></tr>
<tr><td><code id="vecchia_pred_+3A_m">m</code></td>
<td>
<p>number of neighbors for vecchia approximation. default is 30.</p>
</td></tr>
<tr><td><code id="vecchia_pred_+3A_...">...</code></td>
<td>
<p>additional input parameters for <code><a href="#topic+vecchia_specify">vecchia_specify</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>object containing prediction means mean.pred and variances var.pred
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n=10^2; locs=cbind(runif(n),runif(n))
covparms=c(1,.1,.5); nuggets=rep(.1,n)
Sigma=exp(-fields::rdist(locs)/covparms[2])+diag(nuggets)
z=as.numeric(t(chol(Sigma))%*%rnorm(n));
data=z+1
vecchia.est=vecchia_estimate(data,locs,theta.ini=c(covparms,nuggets[1]))
n.p=30^2; grid.oneside=seq(0,1,length=round(sqrt(n.p)))
locs.pred=as.matrix(expand.grid(grid.oneside,grid.oneside))
vecchia.pred=vecchia_pred(vecchia.est,locs.pred)

</code></pre>

<hr>
<h2 id='vecchia_prediction'>Vecchia prediction</h2><span id='topic+vecchia_prediction'></span>

<h3>Description</h3>

<p>Vecchia prediction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecchia_prediction(
  z,
  vecchia.approx,
  covparms,
  nuggets,
  var.exact,
  covmodel = "matern",
  return.values = "all"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vecchia_prediction_+3A_z">z</code></td>
<td>
<p>observed data</p>
</td></tr>
<tr><td><code id="vecchia_prediction_+3A_vecchia.approx">vecchia.approx</code></td>
<td>
<p>a vecchia object as generated by vecchia_specify()</p>
</td></tr>
<tr><td><code id="vecchia_prediction_+3A_covparms">covparms</code></td>
<td>
<p>covariance parameters as a vector</p>
</td></tr>
<tr><td><code id="vecchia_prediction_+3A_nuggets">nuggets</code></td>
<td>
<p>nugget</p>
</td></tr>
<tr><td><code id="vecchia_prediction_+3A_var.exact">var.exact</code></td>
<td>
<p>should prediction variances be computed exactly, or is a (faster) approximation acceptable</p>
</td></tr>
<tr><td><code id="vecchia_prediction_+3A_covmodel">covmodel</code></td>
<td>
<p>covariance model, 'matern' by default.</p>
</td></tr>
<tr><td><code id="vecchia_prediction_+3A_return.values">return.values</code></td>
<td>
<p>either 'mean' only, 'meanvar', 'meanmat', or 'all'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>posterior mean and variances at observed and unobserved locations; V matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z=rnorm(5); locs=matrix(1:5,ncol=1); vecchia.approx=vecchia_specify(locs,m=3,locs.pred=locs+.5)
vecchia_prediction(z,vecchia.approx,covparms=c(1,2,.5),nuggets=.2)
</code></pre>

<hr>
<h2 id='vecchia_specify'>specify a general vecchia approximation</h2><span id='topic+vecchia_specify'></span>

<h3>Description</h3>

<p>specify the vecchia approximation for later use in likelihood evaluation or prediction.
This function does not depend on parameter values, and only has to be run once before
repeated likelihood evaluations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecchia_specify(
  locs,
  m = -1,
  ordering,
  cond.yz,
  locs.pred,
  ordering.pred,
  pred.cond,
  conditioning,
  mra.options = NULL,
  ic0 = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vecchia_specify_+3A_locs">locs</code></td>
<td>
<p>nxd matrix of observed locs</p>
</td></tr>
<tr><td><code id="vecchia_specify_+3A_m">m</code></td>
<td>
<p>Number of nearby points to condition on</p>
</td></tr>
<tr><td><code id="vecchia_specify_+3A_ordering">ordering</code></td>
<td>
<p>options are 'coord' or 'maxmin'</p>
</td></tr>
<tr><td><code id="vecchia_specify_+3A_cond.yz">cond.yz</code></td>
<td>
<p>options are 'y', 'z', 'SGV', 'SGVT', 'RVP', 'LK', and 'zy'</p>
</td></tr>
<tr><td><code id="vecchia_specify_+3A_locs.pred">locs.pred</code></td>
<td>
<p>nxd matrix of locations at which to make predictions</p>
</td></tr>
<tr><td><code id="vecchia_specify_+3A_ordering.pred">ordering.pred</code></td>
<td>
<p>options are 'obspred' or 'general'</p>
</td></tr>
<tr><td><code id="vecchia_specify_+3A_pred.cond">pred.cond</code></td>
<td>
<p>prediction conditioning, options are 'general' or 'independent'</p>
</td></tr>
<tr><td><code id="vecchia_specify_+3A_conditioning">conditioning</code></td>
<td>
<p>conditioning on 'NN' (nearest neighbor) or 'firstm' (fixed set for low rank)
or 'mra'</p>
</td></tr>
<tr><td><code id="vecchia_specify_+3A_mra.options">mra.options</code></td>
<td>
<p>Settings for number of levels and neighbors per level</p>
</td></tr>
<tr><td><code id="vecchia_specify_+3A_ic0">ic0</code></td>
<td>
<p>Specifies if ic0 decomposition should be used as opposed to regular Cholesky</p>
</td></tr>
<tr><td><code id="vecchia_specify_+3A_verbose">verbose</code></td>
<td>
<p>Provide more detail when using MRA calculations.  Default is false.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object that specifies the vecchia approximation for later use in likelihood
evaluation or prediction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>locs=matrix(1:5,ncol=1); vecchia_specify(locs,m=2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
