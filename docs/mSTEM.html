<!DOCTYPE html><html><head><title>Help for package mSTEM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mSTEM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ch.est'><p>Estimate <strong>s2</strong>,<strong>lambda2</strong>,<strong>lambda4</strong>,<strong>Delta</strong></p></a></li>
<li><a href='#conv'><p>Compute convolution function using FFT, similar to the function 'conv' in matlab</p></a></li>
<li><a href='#Fdr'><p>Evaluate performance of estimated change points</p></a></li>
<li><a href='#fdr.gam'><p>Parallel computing fdr and power of change points estimation for different <code>gamma</code> and <code>nu</code></p></a></li>
<li><a href='#fdrBH'><p>FDR threshold based on the Benjamini-Hochberg algorithm</p></a></li>
<li><a href='#GenDY'><p>Generate first-order differential of a smoothed sequence Y</p></a></li>
<li><a href='#GenMu'><p>Generate a piecewise constant sequence starting from 0</p></a></li>
<li><a href='#GenZ'><p>Generate Gaussian autocorrelated random error sequence based on White-noise and Gaussian kernal</p></a></li>
<li><a href='#illu.plot'><p>Illustration plot of the procedure t0 detect change points</p></a></li>
<li><a href='#which.cp'><p>Find locations of change points</p></a></li>
<li><a href='#which.peaks'><p>Find local maxima and minima in a sequence</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiple Testing of Local Extrema for Detection of Change Points</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-09-1</td>
</tr>
<tr>
<td>Author:</td>
<td>Zhibing He and Dan Cheng</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zhibing He &lt;zhibingh@asu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A new approach to detect change points based on smoothing and multiple testing, which is for long data sequence modeled as piecewise constant functions plus stationary Gaussian noise, see Dan Cheng and Armin Schwartzman (2015) &lt;<a href="https://doi.org/10.48550/arXiv.1504.06384">doi:10.48550/arXiv.1504.06384</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, foreach, doParallel, latex2exp</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://arxiv.org/abs/1504.06384">https://arxiv.org/abs/1504.06384</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-09-26 19:40:58 UTC; hzb</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-10-02 10:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='ch.est'>Estimate <strong>s2</strong>,<strong>lambda2</strong>,<strong>lambda4</strong>,<strong>Delta</strong></h2><span id='topic+ch.est'></span>

<h3>Description</h3>

<p>Estimate <strong>s2</strong>,<strong>lambda2</strong>,<strong>lambda4</strong>,<strong>Delta</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ch.est(nu, gamma, size, B = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ch.est_+3A_nu">nu</code></td>
<td>
<p>bandwidth of Gaussian kernal applied to White-noise, Whitenoise error if <code>nu</code> = 0</p>
</td></tr>
<tr><td><code id="ch.est_+3A_gamma">gamma</code></td>
<td>
<p>bandwidth of nonparameter smoothing</p>
</td></tr>
<tr><td><code id="ch.est_+3A_size">size</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="ch.est_+3A_b">B</code></td>
<td>
<p>Montelarlo iteration times</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of s2,lambda2,lambda4,Delta
</p>


<h3>References</h3>

<p>Multiple Testing of Local Extrema for Detection of Change Points <a href="https://arxiv.org/abs/1504.06384">https://arxiv.org/abs/1504.06384</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+which.cp">which.cp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ch.est(nu=2,gamma=4,size=1000,B=100)
</code></pre>

<hr>
<h2 id='conv'>Compute convolution function using FFT, similar to the function 'conv' in matlab</h2><span id='topic+conv'></span>

<h3>Description</h3>

<p>Compute convolution function using FFT, similar to the function 'conv' in matlab
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv(u, v, shape = c("same", "full"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conv_+3A_u">u</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="conv_+3A_v">v</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="conv_+3A_shape">shape</code></td>
<td>
<p>if 'same', return central part of the convolution,the same size as u;
ortherwise return the whole sequence with size lenth(u)+length(v)-1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of convolution, as specified by shape.
</p>


<h3>References</h3>

<p>Matlab document on 'conv' <a href="https://www.mathworks.com/help/matlab/ref/conv.html">https://www.mathworks.com/help/matlab/ref/conv.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u = c(-1,2,3,-2,0,1,2)
v = c(2,4,-1,1)
w = conv(u,v,'same')
</code></pre>

<hr>
<h2 id='Fdr'>Evaluate performance of estimated change points</h2><span id='topic+Fdr'></span>

<h3>Description</h3>

<p>Evaluate performance of estimated change points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fdr(uh, b, th)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fdr_+3A_uh">uh</code></td>
<td>
<p>a vector of estimated change points locations</p>
</td></tr>
<tr><td><code id="Fdr_+3A_b">b</code></td>
<td>
<p>a scalar of location tolerance, specified by user</p>
</td></tr>
<tr><td><code id="Fdr_+3A_th">th</code></td>
<td>
<p>a vector of true change points locations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of vector of <code>FDR</code> and <code>Power</code>
</p>
<table>
<tr><td><code>FDR</code></td>
<td>
<p>a scalar of fdr (false discovery rate)</p>
</td></tr>
<tr><td><code>Power</code></td>
<td>
<p>a scalar of power (true positive rate)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+which.cp">which.cp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Fdr(uh=c(7,15,32,47),b=4,th=c(10,20,30,40,50))
</code></pre>

<hr>
<h2 id='fdr.gam'>Parallel computing fdr and power of change points estimation for different <code>gamma</code> and <code>nu</code></h2><span id='topic+fdr.gam'></span>

<h3>Description</h3>

<p>Parallel computing fdr and power of change points estimation for different <code>gamma</code> and <code>nu</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdr.gam(c, mu, Gamma, Nu, b, th, B = 100, level = 0.1, iter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fdr.gam_+3A_c">c</code></td>
<td>
<p>number of cpu cores used for parallel computing</p>
</td></tr>
<tr><td><code id="fdr.gam_+3A_mu">mu</code></td>
<td>
<p>a vector of piecewise constant</p>
</td></tr>
<tr><td><code id="fdr.gam_+3A_gamma">Gamma</code></td>
<td>
<p>a vector of different <code>gamma</code>s</p>
</td></tr>
<tr><td><code id="fdr.gam_+3A_nu">Nu</code></td>
<td>
<p>a vector of different <code>nu</code>s</p>
</td></tr>
<tr><td><code id="fdr.gam_+3A_b">b</code></td>
<td>
<p>a scalar of location tolerance, specified by user</p>
</td></tr>
<tr><td><code id="fdr.gam_+3A_th">th</code></td>
<td>
<p>a vector of true change points locations</p>
</td></tr>
<tr><td><code id="fdr.gam_+3A_b">B</code></td>
<td>
<p>Montelarlo iteration times</p>
</td></tr>
<tr><td><code id="fdr.gam_+3A_level">level</code></td>
<td>
<p>FDR control level</p>
</td></tr>
<tr><td><code id="fdr.gam_+3A_iter">iter</code></td>
<td>
<p>iteration times for each combination of <code>gamma</code> and <code>nu</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of matrix with the same length as <code>Nu</code>, FDR and Power for different <code>Gamma</code> are displayed within each matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
size=12000
a = 1
A = a*(1:119)
H = seq(100,11900,100)
mu = GenMu(A,H,size=size)
z = GenZ(nu=2,size=size)
Gamma = seq(1,5,1)
Nu = seq(0,2,0.5)
model = fdr.gam(2,mu,Gamma,Nu,8,H,iter=100)

</code></pre>

<hr>
<h2 id='fdrBH'>FDR threshold based on the Benjamini-Hochberg algorithm</h2><span id='topic+fdrBH'></span>

<h3>Description</h3>

<p>FDR threshold based on the Benjamini-Hochberg algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdrBH(p, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fdrBH_+3A_p">p</code></td>
<td>
<p>a vector of p-values</p>
</td></tr>
<tr><td><code id="fdrBH_+3A_q">q</code></td>
<td>
<p>False Discovery Rate level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p-value threshold based on independence or positive dependence
</p>


<h3>See Also</h3>

<p><code><a href="#topic+which.cp">which.cp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fdrBH(seq(0.01,0.1,0.01),q=0.1)
</code></pre>

<hr>
<h2 id='GenDY'>Generate first-order differential of a smoothed sequence Y</h2><span id='topic+GenDY'></span>

<h3>Description</h3>

<p>Generate first-order differential of a smoothed sequence Y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenDY(mu, z, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenDY_+3A_mu">mu</code></td>
<td>
<p>a vector of piecewise constant</p>
</td></tr>
<tr><td><code id="GenDY_+3A_z">z</code></td>
<td>
<p>a vector of stationary Gaussian random error</p>
</td></tr>
<tr><td><code id="GenDY_+3A_gamma">gamma</code></td>
<td>
<p>bandwidth of nonparameter smoothing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the differential of Y
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GenMu">GenMu</a></code>/<code><a href="#topic+GenZ">GenZ</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu = GenMu(x=1:10,pos=seq(10,100,10),size=150)
z = GenZ(nu=2,size=150)
GenDY(mu=mu,z=z,gamma=4)
</code></pre>

<hr>
<h2 id='GenMu'>Generate a piecewise constant sequence starting from 0</h2><span id='topic+GenMu'></span>

<h3>Description</h3>

<p>Generate a piecewise constant sequence starting from 0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenMu(x, pos, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenMu_+3A_x">x</code></td>
<td>
<p>a vector containing all values of change points</p>
</td></tr>
<tr><td><code id="GenMu_+3A_pos">pos</code></td>
<td>
<p>positions of change points, corresponding to <code>x</code></p>
</td></tr>
<tr><td><code id="GenMu_+3A_size">size</code></td>
<td>
<p>sample size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a piecewise constant sequence
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GenDY">GenDY</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GenMu(x=1:10,pos=seq(10,100,10),size=150)
</code></pre>

<hr>
<h2 id='GenZ'>Generate Gaussian autocorrelated random error sequence based on White-noise and Gaussian kernal</h2><span id='topic+GenZ'></span>

<h3>Description</h3>

<p>Generate Gaussian autocorrelated random error sequence based on White-noise and Gaussian kernal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenZ(nu, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenZ_+3A_nu">nu</code></td>
<td>
<p>bandwidth of Gaussian kernal applied to White-noise, Whitenoise error if <code>nu</code> = 0</p>
</td></tr>
<tr><td><code id="GenZ_+3A_size">size</code></td>
<td>
<p>sample size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of random error
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GenDY">GenDY</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GenZ(nu=2,size=1000)
</code></pre>

<hr>
<h2 id='illu.plot'>Illustration plot of the procedure t0 detect change points</h2><span id='topic+illu.plot'></span>

<h3>Description</h3>

<p>Illustration plot of the procedure t0 detect change points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>illu.plot(mu, z, gamma, whichcp, b, Tmax, Tmin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="illu.plot_+3A_mu">mu</code></td>
<td>
<p>a vector of piecewise constant</p>
</td></tr>
<tr><td><code id="illu.plot_+3A_z">z</code></td>
<td>
<p>a vector of stationary Gaussian random error</p>
</td></tr>
<tr><td><code id="illu.plot_+3A_gamma">gamma</code></td>
<td>
<p>bandwidth of nonparameter smoothing</p>
</td></tr>
<tr><td><code id="illu.plot_+3A_whichcp">whichcp</code></td>
<td>
<p>output of the function <code><a href="#topic+which.cp">which.cp</a></code></p>
</td></tr>
<tr><td><code id="illu.plot_+3A_b">b</code></td>
<td>
<p>a scalar of location tolerance, specified by user</p>
</td></tr>
<tr><td><code id="illu.plot_+3A_tmax">Tmax</code></td>
<td>
<p>a vector of true peak locations</p>
</td></tr>
<tr><td><code id="illu.plot_+3A_tmin">Tmin</code></td>
<td>
<p>a vector true valley locations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a figure plot showing detection of change points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2019)
L = 1200
A = c(2.8,0,-2.4,0,-3,0.5,3,5,2,0)/1.5
Tmax = c(150,410,680,770,980)
Tmin = c(250,320,550,1000,1100)
H = c(150,250,320,410,550,680,770,980,1000,1100)
mu = GenMu(A,H,L); z = GenZ(nu=2,L)
y1 = GenDY(mu=mu,z=z,gamma=6)
chest = ch.est(nu=2,gamma=6,size=L,B=100)
chp= which.cp(y1,chest,level=0.1)
illu.plot(mu,z,gamma=6,chp,b=5,Tmax,Tmin)
</code></pre>

<hr>
<h2 id='which.cp'>Find locations of change points</h2><span id='topic+which.cp'></span>

<h3>Description</h3>

<p>Find locations of change points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which.cp(y1, chest, level = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which.cp_+3A_y1">y1</code></td>
<td>
<p>a vector of the differential of sequence Y</p>
</td></tr>
<tr><td><code id="which.cp_+3A_chest">chest</code></td>
<td>
<p>output of function <code><a href="#topic+ch.est">ch.est</a></code></p>
</td></tr>
<tr><td><code id="which.cp_+3A_level">level</code></td>
<td>
<p>FDR control level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of components
</p>
<table>
<tr><td><code>peak</code></td>
<td>
<p>a vector of peaks location</p>
</td></tr>
<tr><td><code>vall</code></td>
<td>
<p>a vector of valleys location</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>a scalar of adjusted p-value based on FDR control</p>
</td></tr>
<tr><td><code>thresh</code></td>
<td>
<p>a scalar of threshold for <code>y1</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ch.est">ch.est</a></code>/<code><a href="#topic+fdrBH">fdrBH</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu = GenMu(x=1:10,pos=seq(10,100,10),size=150)
z = GenZ(nu=2,size=150)
y1 = GenDY(mu,z,gamma=4)
chest = ch.est(nu=2,gamma=8,size=150,B=100)
which.cp(y1,chest,level=0.1)
</code></pre>

<hr>
<h2 id='which.peaks'>Find local maxima and minima in a sequence</h2><span id='topic+which.peaks'></span>

<h3>Description</h3>

<p>Find local maxima and minima in a sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which.peaks(x, partial = FALSE, decreasing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which.peaks_+3A_x">x</code></td>
<td>
<p>a vector with maxima or minima</p>
</td></tr>
<tr><td><code id="which.peaks_+3A_partial">partial</code></td>
<td>
<p>endpoints will be considered if 'true'</p>
</td></tr>
<tr><td><code id="which.peaks_+3A_decreasing">decreasing</code></td>
<td>
<p>find local minima if 'true', ortherwise local maxima</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of positions of local maxima or minima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = 100:1
which.peaks(a*sin(a/3))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
