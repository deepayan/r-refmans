<!DOCTYPE html><html><head><title>Help for package Branching</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Branching}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BGWM.covar'><p>Variances and covariances of a multi-type Bienayme - Galton -</p>
Watson process</a></li>
<li><a href='#BGWM.covar.estim'><p>Estimation of the covariance matrices of a multi-type Bienayme</p>
- Galton - Watson process</a></li>
<li><a href='#BGWM.mean'><p>Means of a multi-type Bienayme - Galton - Watson process</p></a></li>
<li><a href='#BGWM.mean.estim'><p>Estimation of the mean matrix of a multi-type Bienayme</p>
- Galton - Watson process</a></li>
<li><a href='#rBGWM'><p>Simulating a multi-type Bienayme - Galton - Watson process</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.9.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-11</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulation and Estimation for Branching Processes</td>
</tr>
<tr>
<td>Author:</td>
<td>Camilo Jose Torres-Jimenez &lt;cjtorresj@unal.edu.co&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Camilo Jose Torres-Jimenez &lt;cjtorresj@unal.edu.co&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulation and parameter estimation of multitype Bienayme - Galton - Watson processes.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-11 23:56:53 UTC; USER</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-12 00:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='BGWM.covar'>Variances and covariances of a multi-type Bienayme - Galton -
Watson process</h2><span id='topic+BGWM.covar'></span><span id='topic+BGWM.gener.covar'></span><span id='topic+BGWM.indep.covar'></span><span id='topic+BGWM.multinom.covar'></span>

<h3>Description</h3>

<p>Calculates the covariance matrices of a multi-type Bienayme
- Galton - Watson process from its offspring distributions,
additionally, it could be obtained the covariance matrices in a
specific time <code class="reqn">n</code> and the covariance matrix of the population in
the nth generation, if it is providesd the initial population vector.</p>


<h3>Usage</h3>

<pre><code class='language-R'>BGWM.covar(dists, type=c("general","multinomial","independents"),
           d, n=1, z0=NULL, maxiter = 1e5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BGWM.covar_+3A_dists">dists</code></td>
<td>
<p>offspring distributions. Its structure depends on the class
of the Bienayme - Galton - Watson process (See details and examples).</p>
</td></tr>
<tr><td><code id="BGWM.covar_+3A_type">type</code></td>
<td>
<p>Class or family of the Bienayme - Galton - Watson process
(See details and examples).</p>
</td></tr>
<tr><td><code id="BGWM.covar_+3A_d">d</code></td>
<td>
<p>positive integer, number of types.</p>
</td></tr>
<tr><td><code id="BGWM.covar_+3A_n">n</code></td>
<td>
<p>positive integer, nth generation.</p>
</td></tr>
<tr><td><code id="BGWM.covar_+3A_z0">z0</code></td>
<td>
<p>nonnegative integer vector of size d; initial population by type.</p>
</td></tr>
<tr><td><code id="BGWM.covar_+3A_maxiter">maxiter</code></td>
<td>
<p>positive integer, size of the simulated sample used to
estimate the parameters of univariate distributions that do not have
an analytical formula for their exact calculation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the covariance matrices of a multi-type
Bienayme - Galton - Watson (BGWM) process from its offspring
distributions.
</p>
<p>From particular offspring distributions and taking into
account a differentiated algorithmic approach, we propose the
following classes or types for these processes: 
</p>
<p><code>general</code> This option is for BGWM processes without conditions over
the offspring distributions, in this case, it is required as
input data for each distribution, all d-dimensional vectors with their
respective, greater than zero, probability.
</p>
<p><code>multinomial</code> This option is for BGMW processes where each offspring
distribution is a multinomial distribution with a random number of
trials, in this case, it is required as input data, <code class="reqn">d</code> univariate
distributions related to the random number of trials for each
multinomial distribution and a <code class="reqn">d \times d</code> matrix where each row
contains probabilities of the <code class="reqn">d</code> possible outcomes for each multinomial
distribution.
</p>
<p><code>independents</code> This option is for BGMW processes where each offspring
distribution is a joint distribution of <code class="reqn">d</code> combined independent
discrete random variables, one for each type of individuals, in this
case, it is required as input data <code class="reqn">d^2</code> univariate distributions.
</p>
<p>The structure need it for each classification is illustrated in the examples.
</p>
<p>These are the univariate distributions available:
</p>
<p><em>unif</em> Discrete uniform distribution, parameters <code class="reqn">min</code> and
<code class="reqn">max</code>. All the non-negative integers between <code class="reqn">min</code> y <code class="reqn">max</code> have the same
probability. 
</p>
<p><em>binom</em> Binomial distribution, parameters <code class="reqn">n</code> and <code class="reqn">p</code>.
</p>
<p style="text-align: center;"><code class="reqn">p(x) = {n \choose x} {p}^{x} {(1-p)}^{n-x}</code>
</p>

<p>for x = 0, <code class="reqn">\dots</code>, n.
</p>
<p><em>hyper</em> Hypergeometric distribution, parameters <code class="reqn">m</code> (the
number of white balls in the urn), <code class="reqn">n</code> (the number of white balls
in the urn), <code class="reqn">k</code> (the number of balls drawn from the urn). 
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) = \left. {m \choose x}{n \choose k-x} \right/ {m+n \choose k}%
  </code>
</p>

<p>for x = 0, ..., k.
</p>
<p><em>geom</em> Geometric distribution, parameter <code class="reqn">p</code>.
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) = p {(1-p)}^{x}
  </code>
</p>

<p>for x = 0, 1, 2, <code class="reqn">\dots</code>
</p>
<p><em>nbinom</em> Negative binomial distribution, parameters <code class="reqn">n</code> and
<code class="reqn">p</code>.
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) = \frac{\Gamma(x+n)}{\Gamma(n) x!} p^n (1-p)^x
  </code>
</p>

<p>for x = 0, 1, 2, <code class="reqn">\dots</code>
</p>
<p><em>pois</em> Poisson distribution, parameter <code class="reqn">\lambda</code>.
</p>
<p style="text-align: center;"><code class="reqn">p(x) = \frac{\lambda^x e^{-\lambda}}{x!}</code>
</p>

<p>for x = 0, 1, 2, <code class="reqn">\dots</code>
</p>
<p><em>norm</em> Normal distribution rounded to integer values and negative
values become 0, parameters <code class="reqn">\mu</code> and
<code class="reqn">\sigma</code>.
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) = \int_{x-0.5}^{x+0.5} \frac{1}{\sqrt{2\pi}\sigma} e^{-(t-\mu)^2/2\sigma^2}dt%
  </code>
</p>

<p>for x = 1, 2, <code class="reqn">\dots</code>
</p>
<p style="text-align: center;"><code class="reqn">p(x) = \int_{-\infty}^{0.5} \frac{1}{\sqrt{2\pi}\sigma} e^{-(t-\mu)^2/2\sigma^2}dt%
  </code>
</p>

<p>for x = 0
</p>
<p><em>lnorm</em> Lognormal distribution rounded to integer values,
parameters <code>logmean</code> <code class="reqn">=\mu</code> y <code>logsd</code> <code class="reqn">=\sigma</code>.
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) = \int_{x-0.5}^{x+0.5} \frac{1}{\sqrt{2\pi}\sigma t} e^{-(\log(t) - \mu)^2/2 \sigma^2 }dt%
  </code>
</p>

<p>for x = 1, 2, <code class="reqn">\dots</code>
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) = \int_{0}^{0.5} \frac{1}{\sqrt{2\pi}\sigma t} e^{-(\log(t) - \mu)^2/2 \sigma^2 }dt%
  </code>
</p>

<p>for x = 0
</p>
<p><em>gamma</em> Gamma distribution rounded to integer values,
parameters <code>shape</code> <code class="reqn">=\alpha</code> y <code>scale</code> <code class="reqn">=\sigma</code>.
</p>
<p style="text-align: center;"><code class="reqn">
    p(x)= \int_{x-0.5}^{x+0.5} \frac{1}{{\sigma}^{\alpha}\Gamma(\alpha)}{t}^{\alpha-1} e^{-t/\sigma} dt%
  </code>
</p>

<p>para x = 1, 2, <code class="reqn">\dots</code>
</p>
<p style="text-align: center;"><code class="reqn">
    p(x)= \int_{0}^{0.5} \frac{1}{{\sigma}^{\alpha}\Gamma(\alpha)}{t}^{\alpha-1} e^{-t/\sigma} dt%
  </code>
</p>

<p>for x = 0
</p>
<p>When the offspring distributions used <code>norm</code>, <code>lnorm</code> or
<code>gamma</code>, mean and variance related to these univariate
distributions is estimated by calculating sample mean and sample variance
of <code>maxiter</code> random values generated from the corresponding distribution.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> object with the covariance matrices of the process in
the nth generation, combined by rows, or, a <code>matrix</code> object with
the covariace matrix of the population in the nth generation, in case
of provide the initial population vector (z0).
</p>


<h3>Author(s)</h3>

<p>Camilo Jose Torres-Jimenez <a href="mailto:cjtorresj@unal.edu.co">cjtorresj@unal.edu.co</a>
</p>


<h3>References</h3>

<p>Torres-Jimenez, C. J. (2010), Relative frequencies and parameter 
estimation in multi-type Bienayme - Galton - Watson processes, 
Master's Thesis, Master of Science in Statistics.
Universidad Nacional de Colombia. Bogota, Colombia.
</p>
<p>Stefanescu, C. (1998), 'Simulation of a multitype Galton-Watson
chain', Simulation Practice and Theory 6(7), 657-663.
</p>
<p>Athreya, K. &amp; Ney, P. (1972), Branching Processes, Springer-Verlag.
</p>
<p>Harris, T. E. (1963), The Theory of Branching Processes, Courier Dover
Publications. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BGWM.mean">BGWM.mean</a></code>, <code><a href="#topic+rBGWM">rBGWM</a></code>, <code><a href="#topic+BGWM.mean.estim">BGWM.mean.estim</a></code>, <code><a href="#topic+BGWM.covar.estim">BGWM.covar.estim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Variances and covariances of a BGWM process based on a model analyzed
## in Stefanescu (1998) 

# Variables and parameters
d &lt;- 2
n &lt;- 30
N &lt;- c(90, 10)
a &lt;- c(0.2, 0.3)

# with independent distributions
Dists.i &lt;- data.frame( name=rep( "pois", d*d ),
                       param1=rep( a, rep(d,d) ),
                       stringsAsFactors=FALSE )

# covariance matrices of the process
I.matriz.V &lt;- BGWM.covar(Dists.i, "independents", d)

# covariance matrix of the population in the nth generation
# from vector N representing the initial population
I.matrix.V.n_N &lt;- BGWM.covar(Dists.i, "independents", d, n, N)

# with multinomial distributions
dist &lt;- data.frame( name=rep( "pois", d ),
                    param1=a*d,
                    stringsAsFactors=FALSE )
matrix.b &lt;- matrix( rep(0.5, 4), nrow=2 )
Dists.m &lt;- list( dists.eta=dist, matrix.B=matrix.b )

# covariance matrices of the process
M.matrix.V &lt;- BGWM.covar(Dists.m, "multinomial", d)

# covariance matrix of the population in the nth generation
# from vector N representing the initial population
M.matrix.V.n_N &lt;- BGWM.covar(Dists.m, "multinomial", d, n, N)

# with general distributions (approximation)
max &lt;- 30
A &lt;- t(expand.grid(c(0:max),c(0:max)))
aux1 &lt;- factorial(A)
aux1 &lt;- apply(aux1,2,prod)
aux2 &lt;- apply(A,2,sum)
distp &lt;- function(x,y,z){ exp(-d*x)*(x^y)/z }
p &lt;- sapply( a, distp, aux2, aux1 )
prob &lt;- list( dist1=p[,1], dist2=p[,2] )
size &lt;- list( dist1=ncol(A), dist2=ncol(A) )
vect &lt;- list( dist1=t(A), dist2=t(A) )
Dists.g &lt;- list( sizes=size, probs=prob, vects=vect )

# covariance matrices of the process
G.matrix.V &lt;- BGWM.covar(Dists.g, "general", d)

# covariance matrix of the population in the nth generation
# from vector N representing the initial population
G.matrix.V.n_N &lt;- BGWM.covar(Dists.g, "general", d, n, N)

# Comparison of results
I.matrix.V.n_N
I.matrix.V.n_N - M.matrix.V.n_N
M.matrix.V.n_N - G.matrix.V.n_N
G.matrix.V.n_N - I.matrix.V.n_N

## End(Not run)
</code></pre>

<hr>
<h2 id='BGWM.covar.estim'>Estimation of the covariance matrices of a multi-type Bienayme
- Galton - Watson process</h2><span id='topic+BGWM.covar.estim'></span><span id='topic+BGWM.covar.EE'></span><span id='topic+BGWM.covar.MLE'></span>

<h3>Description</h3>

<p>Calculates a estimation of the covariance matrices of a
multi-type Bienayme - Galton - Watson process from experimental
observed data that can be modeled by this kind of process.</p>


<h3>Usage</h3>

<pre><code class='language-R'>BGWM.covar.estim(sample, method=c("EE-m","MLE-m"), d, n, z0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BGWM.covar.estim_+3A_sample">sample</code></td>
<td>
<p>nonnegative integer matrix with <code class="reqn">d</code> columns and
<code class="reqn">dn</code> rows, trajectory
of the process with the number of individuals for every 
combination parent type - descendent type (observed data).</p>
</td></tr>
<tr><td><code id="BGWM.covar.estim_+3A_method">method</code></td>
<td>
<p>methods of estimation (EE-m with empirical estimation
of the mean matrix, MLE-m with maximum likelihood estimation of the
mean matrix).</p>
</td></tr>
<tr><td><code id="BGWM.covar.estim_+3A_d">d</code></td>
<td>
<p>positive integer, number of types.</p>
</td></tr>
<tr><td><code id="BGWM.covar.estim_+3A_n">n</code></td>
<td>
<p>positive integer, nth generation.</p>
</td></tr>
<tr><td><code id="BGWM.covar.estim_+3A_z0">z0</code></td>
<td>
<p>nonnegative integer vector of size d, initial population by
type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates the covariance matrices of a BGWM process using two
possible estimators from asymptotic results related with empirical
estimator and maximum likelihood estimator of the mean matrix, they
both require the so-called full sample associated with the process,
ie, it is required to have the trajectory of the process with the
number of individuals for every combination parent type - descendent
type. For more details see Torres-Jimenez (2010) or Maaouia &amp; Touati
(2005). 
</p>


<h3>Value</h3>

<p>A <code>list</code> object with:
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p>method of estimation selected.</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>A <code>matrix</code> object, estimation of the <code class="reqn">d</code> covariance
matrices of the process, combined by rows.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Camilo Jose Torres-Jimenez <a href="mailto:cjtorresj@unal.edu.co">cjtorresj@unal.edu.co</a>
</p>


<h3>References</h3>

<p>Torres-Jimenez, C. J. (2010), Relative frequencies and parameter 
estimation in multi-type Bienayme - Galton - Watson processes, 
Master's Thesis, Master of Science in Statistics.
Universidad Nacional de Colombia. Bogota, Colombia.
</p>
<p>Maaouia, F. &amp; Touati, A. (2005), 'Identification of Multitype Branching
Processes', The Annals of Statistics 33(6), 2655-2694.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BGWM.mean">BGWM.mean</a></code>, <code><a href="#topic+BGWM.covar">BGWM.covar</a></code>, <code><a href="#topic+BGWM.mean.estim">BGWM.mean.estim</a></code>, <code><a href="#topic+rBGWM">rBGWM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Estimation of covariace matrices from simulated data

# Variables and parameters
d &lt;- 3
n &lt;- 30
N &lt;- c(10,10,10)
LeslieMatrix &lt;- matrix( c(0.08, 1.06, 0.07, 
                          0.99, 0, 0, 
                          0, 0.98, 0), 3, 3 )

# offspring distributions from the Leslie matrix
# (with independent distributions)  
Dists.pois &lt;- data.frame( name=rep( "pois", d ),
                          param1=LeslieMatrix[,1],
                          param2=NA,
                          stringsAsFactors=FALSE )
Dists.binom &lt;- data.frame( name=rep( "binom", 2*d ),
                           param1=rep( 1, 2*d ),
                           param2=c(t(LeslieMatrix[,-1])),
                           stringsAsFactors=FALSE ) 
Dists.i &lt;- rbind(Dists.pois,Dists.binom)
Dists.i &lt;- Dists.i[c(1,4,5,2,6,7,3,8,9),]
Dists.i

# covariance matrices of the process from its offspring distributions
V &lt;- BGWM.covar(Dists.i,"independents",d)

# generated trajectories of the process from its offspring distributions
simulated.data &lt;- rBGWM(Dists.i, "independents", d, n, N, 
                        TRUE, FALSE, FALSE)$o.c.s

# estimation of covariance matrices using mean matrix empiric estimate
# from generated trajectories of the process 
V.EE.m &lt;- BGWM.covar.estim( simulated.data, "EE-m", d, n, N )$V

# estimation of covariance matrices using mean matrix maximum likelihood
# estimate from generated trajectories of the process 
V.MLE.m &lt;- BGWM.covar.estim( simulated.data, "MLE-m", d, n, N )$V

# Comparison of exact and estimated covariance matrices
V
V - V.EE.m
V - V.MLE.m

## End(Not run)
</code></pre>

<hr>
<h2 id='BGWM.mean'>Means of a multi-type Bienayme - Galton - Watson process</h2><span id='topic+BGWM.mean'></span><span id='topic+BGWM.gener.mean'></span><span id='topic+BGWM.indep.mean'></span><span id='topic+BGWM.multinom.mean'></span>

<h3>Description</h3>

<p>Calculates the mean matrix of a multi-type Bienayme - Galton -
Watson process from its offspring distributions, additionally, it
could be obtained the mean matrix in a specific time <code class="reqn">n</code> and the
mean vector of the population in the nth generation, if it is provided
the initial population vector.</p>


<h3>Usage</h3>

<pre><code class='language-R'>BGWM.mean(dists, type=c("general","multinomial","independents"),
          d, n=1, z0=NULL, maxiter = 1e5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BGWM.mean_+3A_dists">dists</code></td>
<td>
<p>offspring distributions. Its structure depends on the class
of the Bienayme - Galton - Watson process (See details and examples).</p>
</td></tr> 
<tr><td><code id="BGWM.mean_+3A_type">type</code></td>
<td>
<p>Class or family of the Bienayme - Galton - Watson process
(See details and examples).</p>
</td></tr>
<tr><td><code id="BGWM.mean_+3A_d">d</code></td>
<td>
<p>positive integer, number of types.</p>
</td></tr>
<tr><td><code id="BGWM.mean_+3A_n">n</code></td>
<td>
<p>positive integer, nth generation.</p>
</td></tr>
<tr><td><code id="BGWM.mean_+3A_z0">z0</code></td>
<td>
<p>nonnegative integer vector of size d, initial population by type.</p>
</td></tr>
<tr><td><code id="BGWM.mean_+3A_maxiter">maxiter</code></td>
<td>
<p>positive integer, size of the simulated sample used to
estimate the parameters of univariate distributions that do not have
an analytical formula for their exact calculation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the mean matrix of a multi-type Bienayme - Galton -
Watson (BGWM) process from its offspring distributions.
</p>
<p>From particular offspring distributions and taking into account a
differentiated algorithmic approach, we propose the following classes
or types for these processes:
</p>
<p><code>general</code> This option is for BGWM processes without conditions over
the offspring distributions, in this case, it is required as
input data for each distribution, all d-dimensional vectors with their
respective, greater than zero, probability.
</p>
<p><code>multinomial</code> This option is for BGMW processes where each offspring
distribution is a multinomial distribution with a random number of
trials, in this case, it is required as input data, <code class="reqn">d</code> univariate
distributions related to the random number of trials for each
multinomial distribution and a <code class="reqn">d \times d</code> matrix where each row
contains probabilities of the <code class="reqn">d</code> possible outcomes for each multinomial
distribution.
</p>
<p><code>independents</code> This option is for BGMW processes where each offspring
distribution is a joint distribution of <code class="reqn">d</code> combined independent
discrete random variables, one for each type of individuals, in this
case, it is required as input data <code class="reqn">d^2</code> univariate distributions.
</p>
<p>The structure need it for each classification is illustrated in the examples.
</p>
<p>These are the univariate distributions available:
</p>
<p><em>unif</em> Discrete uniform distribution, parameters <code class="reqn">min</code> and
<code class="reqn">max</code>. All the non-negative integers between <code class="reqn">min</code> y <code class="reqn">max</code> have the same
probability. 
</p>
<p><em>binom</em> Binomial distribution, parameters <code class="reqn">n</code> and <code class="reqn">p</code>.
</p>
<p style="text-align: center;"><code class="reqn">p(x) = {n \choose x} {p}^{x} {(1-p)}^{n-x}</code>
</p>

<p>for x = 0, <code class="reqn">\dots</code>, n.
</p>
<p><em>hyper</em> Hypergeometric distribution, parameters <code class="reqn">m</code> (the
number of white balls in the urn), <code class="reqn">n</code> (the number of white balls
in the urn), <code class="reqn">k</code> (the number of balls drawn from the urn). 
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) = \left. {m \choose x}{n \choose k-x} \right/ {m+n \choose k}%
  </code>
</p>

<p>for x = 0, ..., k.
</p>
<p><em>geom</em> Geometric distribution, parameter <code class="reqn">p</code>.
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) = p {(1-p)}^{x}
  </code>
</p>

<p>for x = 0, 1, 2, <code class="reqn">\dots</code>
</p>
<p><em>nbinom</em> Negative binomial distribution, parameters <code class="reqn">n</code> and
<code class="reqn">p</code>.
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) = \frac{\Gamma(x+n)}{\Gamma(n) x!} p^n (1-p)^x
  </code>
</p>

<p>for x = 0, 1, 2, <code class="reqn">\dots</code>
</p>
<p><em>pois</em> Poisson distribution, parameter <code class="reqn">\lambda</code>.
</p>
<p style="text-align: center;"><code class="reqn">p(x) = \frac{\lambda^x e^{-\lambda}}{x!}</code>
</p>

<p>for x = 0, 1, 2, <code class="reqn">\dots</code>
</p>
<p><em>norm</em> Normal distribution rounded to integer values and negative
values become 0, parameters <code class="reqn">\mu</code> and
<code class="reqn">\sigma</code>.
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) = \int_{x-0.5}^{x+0.5} \frac{1}{\sqrt{2\pi}\sigma} e^{-(t-\mu)^2/2\sigma^2}dt%
  </code>
</p>

<p>for x = 1, 2, <code class="reqn">\dots</code>
</p>
<p style="text-align: center;"><code class="reqn">p(x) = \int_{-\infty}^{0.5} \frac{1}{\sqrt{2\pi}\sigma} e^{-(t-\mu)^2/2\sigma^2}dt%
  </code>
</p>

<p>for x = 0
</p>
<p><em>lnorm</em> Lognormal distribution rounded to integer values,
parameters <code>logmean</code> <code class="reqn">=\mu</code> y <code>logsd</code> <code class="reqn">=\sigma</code>.
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) = \int_{x-0.5}^{x+0.5} \frac{1}{\sqrt{2\pi}\sigma t} e^{-(\log(t) - \mu)^2/2 \sigma^2 }dt%
  </code>
</p>

<p>for x = 1, 2, <code class="reqn">\dots</code>
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) = \int_{0}^{0.5} \frac{1}{\sqrt{2\pi}\sigma t} e^{-(\log(t) - \mu)^2/2 \sigma^2 }dt%
  </code>
</p>

<p>for x = 0
</p>
<p><em>gamma</em> Gamma distribution rounded to integer values,
parameters <code>shape</code> <code class="reqn">=\alpha</code> y <code>scale</code> <code class="reqn">=\sigma</code>.
</p>
<p style="text-align: center;"><code class="reqn">
    p(x)= \int_{x-0.5}^{x+0.5} \frac{1}{{\sigma}^{\alpha}\Gamma(\alpha)}{t}^{\alpha-1} e^{-t/\sigma} dt%
  </code>
</p>

<p>para x = 1, 2, <code class="reqn">\dots</code>
</p>
<p style="text-align: center;"><code class="reqn">
    p(x)= \int_{0}^{0.5} \frac{1}{{\sigma}^{\alpha}\Gamma(\alpha)}{t}^{\alpha-1} e^{-t/\sigma} dt%
  </code>
</p>

<p>for x = 0
</p>
<p>When the offspring distributions used <code>norm</code>, <code>lnorm</code> or
<code>gamma</code>, mean related to these univariate distributions
is estimated by calculating sample mean of <code>maxiter</code> random
values generated from the corresponding distribution.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> object with the mean matrix of the process in the nth
generation, or, a <code>vector</code> object with the mean vector of the
population in the nth generation, in case of provide the initial population
vector (z0).
</p>


<h3>Author(s)</h3>

<p>Camilo Jose Torres-Jimenez <a href="mailto:cjtorresj@unal.edu.co">cjtorresj@unal.edu.co</a>
</p>


<h3>References</h3>

<p>Torres-Jimenez, C. J. (2010), Relative frequencies and parameter 
estimation in multi-type Bienayme - Galton - Watson processes, 
Master's Thesis, Master of Science in Statistics.
Universidad Nacional de Colombia. Bogota, Colombia.
</p>
<p>Stefanescu, C. (1998), 'Simulation of a multitype Galton-Watson
chain', Simulation Practice and Theory 6(7), 657-663.
</p>
<p>Athreya, K. &amp; Ney, P. (1972), Branching Processes, Springer-Verlag.
</p>
<p>Harris, T. E. (1963), The Theory of Branching Processes, Courier Dover
Publications. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rBGWM">rBGWM</a></code>, <code><a href="#topic+BGWM.covar">BGWM.covar</a></code>, <code><a href="#topic+BGWM.mean.estim">BGWM.mean.estim</a></code>, <code><a href="#topic+BGWM.covar.estim">BGWM.covar.estim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Means of a BGWM process based on a model analyzed in Stefanescu (1998)

# Variables and parameters
d &lt;- 2
n &lt;- 30
N &lt;- c(90, 10)
a &lt;- c(0.2, 0.3)

# with independent distributions
Dists.i &lt;- data.frame( name=rep( "pois", d*d ),
                       param1=rep( a, rep(d,d) ),
                       stringsAsFactors=FALSE )

# mean matrix of the process
I.matriz.m &lt;- BGWM.mean(Dists.i, "independents", d)

# mean vector of the population in the nth generation
# from vector N representing the initial population
I.vector.m.n_N &lt;- BGWM.mean(Dists.i, "independents", d, n, N)

# with multinomial distributions
dist &lt;- data.frame( name=rep( "pois", d ),
                    param1=a*d,
                    stringsAsFactors=FALSE )
matrix.b &lt;- matrix( rep(0.5, 4), nrow=2 )
Dists.m &lt;- list( dists.eta=dist, matrix.B=matrix.b )

# mean matrix of the process
M.matrix.m &lt;- BGWM.mean(Dists.m, "multinomial", d)

# mean vector of the population in the nth generation
# from vector N representing the initial population
M.vector.m.n_N &lt;- BGWM.mean(Dists.m, "multinomial", d, n, N)

# with general distributions (approximation)
max &lt;- 30
A &lt;- t(expand.grid(c(0:max),c(0:max)))
aux1 &lt;- factorial(A)
aux1 &lt;- apply(aux1,2,prod)
aux2 &lt;- apply(A,2,sum)
distp &lt;- function(x,y,z){ exp(-d*x)*(x^y)/z }
p &lt;- sapply( a, distp, aux2, aux1 )
prob &lt;- list( dist1=p[,1], dist2=p[,2] )
size &lt;- list( dist1=ncol(A), dist2=ncol(A) )
vect &lt;- list( dist1=t(A), dist2=t(A) )
Dists.g &lt;- list( sizes=size, probs=prob, vects=vect )

# mean matrix of the process
G.matrix.m &lt;- BGWM.mean(Dists.g, "general", d)

# mean vector of the population in the nth generation
# from vector N representing the initial population
G.vector.m.n_N &lt;- BGWM.mean(Dists.g, "general", d, n, N)

# Comparison of results
I.vector.m.n_N
I.vector.m.n_N - M.vector.m.n_N
M.vector.m.n_N - G.vector.m.n_N
G.vector.m.n_N - I.vector.m.n_N

## End(Not run)
</code></pre>

<hr>
<h2 id='BGWM.mean.estim'>Estimation of the mean matrix of a multi-type Bienayme
- Galton - Watson process</h2><span id='topic+BGWM.mean.estim'></span><span id='topic+BGWM.mean.EE'></span><span id='topic+BGWM.mean.MLE'></span>

<h3>Description</h3>

<p>Calculates a estimation of the mean matrix of a multi-type Bienayme
- Galton - Watson process from experimental observed data that can be
modeled by this kind of process.</p>


<h3>Usage</h3>

<pre><code class='language-R'>BGWM.mean.estim(sample, method=c("EE","MLE"), d, n, z0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BGWM.mean.estim_+3A_sample">sample</code></td>
<td>
<p>nonnegative integer matrix with <code class="reqn">d</code> columns and
<code class="reqn">dn</code> rows, trajectory
of the process with the number of individuals for every 
combination parent type - descendent type (observed data).</p>
</td></tr>
<tr><td><code id="BGWM.mean.estim_+3A_method">method</code></td>
<td>
<p>methods of estimation (EE Empirical estimacion,
MLE Maximum likelihood estimation).</p>
</td></tr>
<tr><td><code id="BGWM.mean.estim_+3A_d">d</code></td>
<td>
<p>positive integer, number of types.</p>
</td></tr>
<tr><td><code id="BGWM.mean.estim_+3A_n">n</code></td>
<td>
<p>positive integer, nth generation.</p>
</td></tr>
<tr><td><code id="BGWM.mean.estim_+3A_z0">z0</code></td>
<td>
<p>nonnegative integer vector of size d, initial population by
type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates the mean matrix of a BGWM process using two
possible estimators, empirical estimator and maximum likelihood
estimator, they both require the so-called full sample associated with
the process, ie, it is required to have the trajectory of the process
with the number of individuals for every combination parent type -
descendent type. For more details see Torres-Jimenez (2010) or
Maaouia &amp; Touati (2005).
</p>


<h3>Value</h3>

<p>A <code>list</code> object with:
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p>method of estimation selected.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>A <code>matrix</code> object, estimation of the <code class="reqn">d \times d</code>
mean matrix of the process.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Camilo Jose Torres-Jimenez <a href="mailto:cjtorresj@unal.edu.co">cjtorresj@unal.edu.co</a>
</p>


<h3>References</h3>

<p>Torres-Jimenez, C. J. (2010), Relative frequencies and parameter 
estimation in multi-type Bienayme - Galton - Watson processes, 
Master's Thesis, Master of Science in Statistics.
Universidad Nacional de Colombia. Bogota, Colombia.
</p>
<p>Maaouia, F. &amp; Touati, A. (2005), 'Identification of Multitype Branching
Processes', The Annals of Statistics 33(6), 2655-2694.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BGWM.mean">BGWM.mean</a></code>, <code><a href="#topic+BGWM.covar">BGWM.covar</a></code>, <code><a href="#topic+rBGWM">rBGWM</a></code>, <code><a href="#topic+BGWM.covar.estim">BGWM.covar.estim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Estimation of mean matrix from simulated data

# Variables and parameters
d &lt;- 3
n &lt;- 30
N &lt;- c(10,10,10)
LeslieMatrix &lt;- matrix( c(0.08, 1.06, 0.07, 
                          0.99, 0, 0, 
                          0, 0.98, 0), 3, 3 )

# offspring distributions from the Leslie matrix
# (with independent distributions)  
Dists.pois &lt;- data.frame( name=rep( "pois", d ),
                          param1=LeslieMatrix[,1],
                          param2=NA,
                          stringsAsFactors=FALSE )
Dists.binom &lt;- data.frame( name=rep( "binom", 2*d ),
                           param1=rep( 1, 2*d ),
                           param2=c(t(LeslieMatrix[,-1])),
                           stringsAsFactors=FALSE ) 
Dists.i &lt;- rbind(Dists.pois,Dists.binom)
Dists.i &lt;- Dists.i[c(1,4,5,2,6,7,3,8,9),]
Dists.i

# mean matrix of the process from its offspring distributions
m &lt;- BGWM.mean(Dists.i,"independents",d)

# generated trajectories of the process from its offspring distributions
simulated.data &lt;- rBGWM(Dists.i, "independents", d, n, N, 
                        TRUE, FALSE, FALSE)$o.c.s

# mean matrix empiric estimate from generated trajectories of the process
m.EE &lt;- BGWM.mean.estim( simulated.data, "EE", d, n, N )$m

# mean matrix maximum likelihood estimate from generated trajectories
# of the process 
m.MLE &lt;- BGWM.mean.estim( simulated.data, "MLE", d, n, N )$m

# Comparison of exact and estimated mean matrices
m
m - m.EE
m - m.MLE

## End(Not run)
</code></pre>

<hr>
<h2 id='rBGWM'>Simulating a multi-type Bienayme - Galton - Watson process</h2><span id='topic+rBGWM'></span><span id='topic+rBGWM.gener'></span><span id='topic+rBGWM.indep'></span><span id='topic+rBGWM.multinom'></span>

<h3>Description</h3>

<p>Generate the trajectories of a multi-type Bienayme - 
Galton - Watson process from its offspring distributions, using three
different algorithms based on three different classes or families of these 
processes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rBGWM(dists, type=c("general","multinomial","independents"), d,
      n, z0=rep(1,d), c.s=TRUE, tt.s=TRUE, rf.s=TRUE, file=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rBGWM_+3A_dists">dists</code></td>
<td>
<p>offspring distributions. Its structure depends on the class
of the Bienayme - Galton - Watson process (See details and examples).</p>
</td></tr>
<tr><td><code id="rBGWM_+3A_type">type</code></td>
<td>
<p>Class or family of the Bienayme - Galton - Watson process
(See details).</p>
</td></tr>
<tr><td><code id="rBGWM_+3A_d">d</code></td>
<td>
<p>positive integer, number of types.</p>
</td></tr>
<tr><td><code id="rBGWM_+3A_n">n</code></td>
<td>
<p>positive integer, maximum lenght of the wanted trajectory.</p>
</td></tr>
<tr><td><code id="rBGWM_+3A_z0">z0</code></td>
<td>
<p>nonnegative integer vector of size d; initial population by type.</p>
</td></tr>
<tr><td><code id="rBGWM_+3A_c.s">c.s</code></td>
<td>
<p>logical value, if TRUE, the output object will include the 
generated trajectory of the process with the number of individuals for 
every combination parent type - descendent type.</p>
</td></tr>
<tr><td><code id="rBGWM_+3A_tt.s">tt.s</code></td>
<td>
<p>logical value, if TRUE, the output object will include the 
generated trajectory of the process with the number of descendents by type.</p>
</td></tr>
<tr><td><code id="rBGWM_+3A_rf.s">rf.s</code></td>
<td>
<p>logical value, if TRUE, the output object will include the 
generated trajectory of the process with the relative frequencies by type.</p>
</td></tr>
<tr><td><code id="rBGWM_+3A_file">file</code></td>
<td>
<p>the name of the output file where the generated trajectory of the 
process with the number of individuals for every combination parent type - 
descendent type could be stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a simulation of a multi-type Bienayme - Galton
- Watson process (BGWM) from its offspring distributions.
</p>
<p>From particular offspring distributions and taking into account a
differentiated algorithmic approach, we propose the following classes
or types for these processes: 
</p>
<p><code>general</code> This option is for BGWM processes without conditions over
the offspring distributions, in this case, it is required as
input data for each distribution, all d-dimensional vectors with their
respective, greater than zero, probability.
</p>
<p><code>multinomial</code> This option is for BGMW processes where each offspring
distribution is a multinomial distribution with a random number of
trials, in this case, it is required as input data, <code class="reqn">d</code> univariate
distributions related to the random number of trials for each
multinomial distribution and a <code class="reqn">d \times d</code> matrix where each row
contains probabilities of the <code class="reqn">d</code> possible outcomes for each multinomial
distribution.
</p>
<p><code>independents</code> This option is for BGMW processes where each offspring
distribution is a joint distribution of <code class="reqn">d</code> combined independent
discrete random variables, one for each type of individuals, in this
case, it is required as input data <code class="reqn">d^2</code> univariate distributions.
</p>
<p>The structure need it for each classification is illustrated in the examples.
</p>
<p>These are the univariate distributions available:
</p>
<p><em>unif</em> Discrete uniform distribution, parameters <code class="reqn">min</code> and
<code class="reqn">max</code>. All the non-negative integers between <code class="reqn">min</code> y <code class="reqn">max</code> have the same
probability. 
</p>
<p><em>binom</em> Binomial distribution, parameters <code class="reqn">n</code> and <code class="reqn">p</code>.
</p>
<p style="text-align: center;"><code class="reqn">p(x) = {n \choose x} {p}^{x} {(1-p)}^{n-x}</code>
</p>

<p>for x = 0, <code class="reqn">\dots</code>, n.
</p>
<p><em>hyper</em> Hypergeometric distribution, parameters <code class="reqn">m</code> (the
number of white balls in the urn), <code class="reqn">n</code> (the number of white balls
in the urn), <code class="reqn">k</code> (the number of balls drawn from the urn). 
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) = \left. {m \choose x}{n \choose k-x} \right/ {m+n \choose k}%
  </code>
</p>

<p>for x = 0, ..., k.
</p>
<p><em>geom</em> Geometric distribution, parameter <code class="reqn">p</code>.
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) = p {(1-p)}^{x}
  </code>
</p>

<p>for x = 0, 1, 2, <code class="reqn">\dots</code>
</p>
<p><em>nbinom</em> Negative binomial distribution, parameters <code class="reqn">n</code> and
<code class="reqn">p</code>.
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) = \frac{\Gamma(x+n)}{\Gamma(n) x!} p^n (1-p)^x
  </code>
</p>

<p>for x = 0, 1, 2, <code class="reqn">\dots</code>
</p>
<p><em>pois</em> Poisson distribution, parameter <code class="reqn">\lambda</code>.
</p>
<p style="text-align: center;"><code class="reqn">p(x) = \frac{\lambda^x e^{-\lambda}}{x!}</code>
</p>

<p>for x = 0, 1, 2, <code class="reqn">\dots</code>
</p>
<p><em>norm</em> Normal distribution rounded to integer values and negative
values become 0, parameters <code class="reqn">\mu</code> and
<code class="reqn">\sigma</code>.
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) = \int_{x-0.5}^{x+0.5} \frac{1}{\sqrt{2\pi}\sigma} e^{-(t-\mu)^2/2\sigma^2}dt%
  </code>
</p>

<p>for x = 1, 2, <code class="reqn">\dots</code>
</p>
<p style="text-align: center;"><code class="reqn">p(x) = \int_{-\infty}^{0.5} \frac{1}{\sqrt{2\pi}\sigma} e^{-(t-\mu)^2/2\sigma^2}dt%
  </code>
</p>

<p>for x = 0
</p>
<p><em>lnorm</em> Lognormal distribution rounded to integer values,
parameters <code>logmean</code> <code class="reqn">=\mu</code> y <code>logsd</code> <code class="reqn">=\sigma</code>.
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) = \int_{x-0.5}^{x+0.5} \frac{1}{\sqrt{2\pi}\sigma t} e^{-(\log(t) - \mu)^2/2 \sigma^2 }dt%
  </code>
</p>

<p>for x = 1, 2, <code class="reqn">\dots</code>
</p>
<p style="text-align: center;"><code class="reqn">
    p(x) = \int_{0}^{0.5} \frac{1}{\sqrt{2\pi}\sigma t} e^{-(\log(t) - \mu)^2/2 \sigma^2 }dt%
  </code>
</p>

<p>for x = 0
</p>
<p><em>gamma</em> Gamma distribution rounded to integer values,
parameters <code>shape</code> <code class="reqn">=\alpha</code> y <code>scale</code> <code class="reqn">=\sigma</code>.
</p>
<p style="text-align: center;"><code class="reqn">
    p(x)= \int_{x-0.5}^{x+0.5} \frac{1}{{\sigma}^{\alpha}\Gamma(\alpha)}{t}^{\alpha-1} e^{-t/\sigma} dt%
  </code>
</p>

<p>para x = 1, 2, <code class="reqn">\dots</code>
</p>
<p style="text-align: center;"><code class="reqn">
    p(x)= \int_{0}^{0.5} \frac{1}{{\sigma}^{\alpha}\Gamma(\alpha)}{t}^{\alpha-1} e^{-t/\sigma} dt%
  </code>
</p>

<p>for x = 0
</p>


<h3>Value</h3>

<p>An object of class <code>list</code> with these components:
</p>
<table>
<tr><td><code>i.d</code></td>
<td>
<p>input. number of types.</p>
</td></tr>
<tr><td><code>i.dists</code></td>
<td>
<p>input. offspring distributions.</p>
</td></tr>
<tr><td><code>i.n</code></td>
<td>
<p>input. maximum lenght of the generated trajectory.</p>
</td></tr>
<tr><td><code>i.z0</code></td>
<td>
<p>input. initial population by type.</p>
</td></tr>
<tr><td><code>o.c.s</code></td>
<td>
<p>output. A matrix indicating the generated trajectory of the 
process with the number of individuals for every combination parent type - 
descendent type.</p>
</td></tr>
<tr><td><code>o.tt.s</code></td>
<td>
<p>output. A matrix indicating the generated trajectory of the 
process with the number of descendents by type.</p>
</td></tr>
<tr><td><code>o.rf.s</code></td>
<td>
<p>output. A matrix indicating the generated trajectory of the 
process with the relative frequencies by type.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Camilo Jose Torres-Jimenez <a href="mailto:cjtorresj@unal.edu.co">cjtorresj@unal.edu.co</a>
</p>


<h3>References</h3>

<p>Torres-Jimenez, C. J. (2010), Relative frequencies and parameter 
estimation in multi-type Bienayme - Galton - Watson processes, 
Master's Thesis, Master of Science in Statistics.
Universidad Nacional de Colombia. Bogota, Colombia.
</p>
<p>Stefanescu, C. (1998), 'Simulation of a multitype Galton-Watson
chain', Simulation Practice and Theory 6(7), 657-663.
</p>
<p>Athreya, K. &amp; Ney, P. (1972), Branching Processes, Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BGWM.mean">BGWM.mean</a></code>, <code><a href="#topic+BGWM.covar">BGWM.covar</a></code>, <code><a href="#topic+BGWM.mean.estim">BGWM.mean.estim</a></code>, <code><a href="#topic+BGWM.covar.estim">BGWM.covar.estim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Simulation based on a model analyzed in Stefanescu(1998)

# Variables and parameters
d &lt;- 2
n &lt;- 30
N &lt;- c(90, 10)
a &lt;- c(0.2, 0.3)

# with independent distributions
Dists.i &lt;- data.frame( name=rep( "pois", d*d ),
                       param1=rep( a, rep(d,d) ),
                       stringsAsFactors=FALSE )

rA &lt;- rBGWM(Dists.i, "independents", d, n, N)

# with multinomial distributions
dist &lt;- data.frame( name=rep( "pois", d ),
                    param1=a*d,
                    stringsAsFactors=FALSE )
matrix.b &lt;- matrix( rep(0.5, 4), nrow=2 )
Dists.m &lt;- list( dists.eta=dist, matrix.B=matrix.b )

rB &lt;- rBGWM(Dists.m, "multinomial", d, n, N)

# with general distributions (approximation)
max &lt;- 30
A &lt;- t(expand.grid(c(0:max),c(0:max)))
aux1 &lt;- factorial(A)
aux1 &lt;- apply(aux1,2,prod)
aux2 &lt;- apply(A,2,sum)
distp &lt;- function(x,y,z){ exp(-d*x)*(x^y)/z }
p &lt;- sapply( a, distp, aux2, aux1 )
prob &lt;- list( dist1=p[,1], dist2=p[,2] )
size &lt;- list( dist1=ncol(A), dist2=ncol(A) )
vect &lt;- list( dist1=t(A), dist2=t(A) )
Dists.g &lt;- list( sizes=size, probs=prob, vects=vect )

rC &lt;- rBGWM(Dists.g, "general", d, n, N)

# Comparison chart
dev.new()
plot.ts(rA$o.tt.s,main="with independents")
dev.new()
plot.ts(rB$o.tt.s,main="with multinomial")
dev.new()
plot.ts(rC$o.tt.s,main="with general (aprox.)")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
