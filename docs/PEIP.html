<!DOCTYPE html><html lang="en"><head><title>Help for package PEIP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PEIP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PEIP-package'>
<p>Inverse Theory Functions for PEIP book</p></a></li>
<li><a href='#Ainv'><p>An Inverse Solution</p></a></li>
<li><a href='#art'><p>ART Inverse solution</p></a></li>
<li><a href='#bartl'><p>Bartlett window</p></a></li>
<li><a href='#bayes'><p>Bayes Inversion</p></a></li>
<li><a href='#blf2'><p>Bounded least squares</p></a></li>
<li><a href='#cgls'><p>Conjugate gradient Least squares</p></a></li>
<li><a href='#chi'><p>Chi function</p></a></li>
<li><a href='#chi2cdf'><p>Chi-Sq CDF</p></a></li>
<li><a href='#chi2inv'><p>Inverse Chi-Sq</p></a></li>
<li><a href='#dcost'><p>cosine transform</p></a></li>
<li><a href='#error.bar'><p>Plot Error Bar</p></a></li>
<li><a href='#flipGSVD'><p>Flip output of GSVD</p></a></li>
<li><a href='#gcv_function'><p>gcv func</p></a></li>
<li><a href='#gcval'><p>Get c-val</p></a></li>
<li><a href='#get_l_rough'><p>One-D Roughening</p></a></li>
<li><a href='#ginv'><p>Get inverse</p></a></li>
<li><a href='#GSVD'><p>Generalized SVD</p></a></li>
<li><a href='#idcost'><p>Inverse  cosine transform</p></a></li>
<li><a href='#imagesc'><p>Image Display</p></a></li>
<li><a href='#interp2grid'><p> Bilinear and Bicubic Interpolation to Grid</p></a></li>
<li><a href='#irls'><p>Iteratively reweight least squares</p></a></li>
<li><a href='#irlsl1reg'><p>L1 least squares with sparsity</p></a></li>
<li><a href='#kac'><p>Kaczmarz</p></a></li>
<li><a href='#l_curve_corner'><p>L Curve Corner</p></a></li>
<li><a href='#l_curve_tgsvd'><p>L curve tgsvd</p></a></li>
<li><a href='#l_curve_tikh_gsvd'><p>L-curve tikh gsvd</p></a></li>
<li><a href='#l_curve_tikh_svd'><p>L-curve Tikhonov</p></a></li>
<li><a href='#linesconst'><p>Plot constant model</p></a></li>
<li><a href='#lmarq'><p>Lev-Marquardt Inversion</p></a></li>
<li><a href='#loadMAT'><p>Load a Matlab matfile</p></a></li>
<li><a href='#mcmc'><p>Maximum likelihood Models</p></a></li>
<li><a href='#Mnorm'><p>Matrix Norm</p></a></li>
<li><a href='#nnz'><p>Non-zeros</p></a></li>
<li><a href='#occam'><p>Occam inversion</p></a></li>
<li><a href='#phi'><p>Integral of Normal Distribution</p></a></li>
<li><a href='#phiinv'><p>Inverse Normal Distribution Integral</p></a></li>
<li><a href='#picard_vals'><p>Picard plot</p></a></li>
<li><a href='#plotconst'><p>Plot constant model</p></a></li>
<li><a href='#quadlin'><p>Lagrange multiplier technique</p></a></li>
<li><a href='#rnk'><p>Rank of Matrix</p></a></li>
<li><a href='#setDesignG'><p>Set a Design Matrix.</p></a></li>
<li><a href='#shawG'><p>Shaw Model of Slit Diffraction</p></a></li>
<li><a href='#sirt'><p>SIRT Algorithm for sparse matrix inversion</p></a></li>
<li><a href='#tinv'>
<p>Inverse T-distribution</p></a></li>
<li><a href='#USV'><p>Singular Value Decomposition</p></a></li>
<li><a href='#Vnorm'><p>Vector 2-Norm</p></a></li>
<li><a href='#vspprofile'><p>Vertical Seismic Profile In 1D</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Geophysical Inverse Theory and Optimization</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2-5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-09</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.12)</td>
</tr>
<tr>
<td>Imports:</td>
<td>bvls, Matrix, RSEIS, pracma, geigen, fields</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonathan M. Lees [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Several functions introduced in Aster et al.'s book on inverse theory. The functions are often translations of MATLAB code developed by the authors to illustrate concepts of inverse theory as applied to geophysics. Generalized inversion, tomographic inversion algorithms (conjugate gradients, 'ART' and 'SIRT'), non-linear least squares, first and second order Tikhonov regularization, roughness constraints, and procedures for estimating smoothing parameters are included. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-19 10:35:11 UTC; lees</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-21 08:52:41 UTC</td>
</tr>
</table>
<hr>
<h2 id='PEIP-package'>
Inverse Theory Functions for PEIP book
</h2><span id='topic+PEIP-package'></span><span id='topic+PEIP'></span>

<h3>Description</h3>

<p>Auxilliary functions and routines for running the
examples and excersizes described in the book
on inverse theory.
</p>


<h3>Details</h3>

<p>These functions are used in conjunction with the example described in
the PEIP book.
</p>
<p>There is one C-code routine, interp2grid.
This is introduced to replicate the MATLAB code interp2.
It does not work exactly as the matlab code prescribes.
</p>
<p>In the PEIP library one LAPACK routine
is called: dggsvd.
In R, LAPACK routines are stored in slightly
different locations on Linux, Windows and Mac computers.
Be aware. This will come up in examples from Chapter 4.
</p>
<p>Almost all examples work as scripts 
run with virtually no user input, e.g.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;
Maintainer:Jonathan M. Lees&lt;jonathan.lees.edu&gt;
</p>


<h3>References</h3>

<p>Aster, R.C., C.H. Thurber, and B. Borchers,
<em>Parameter Estimation and Inverse Problems</em>, Elsevier Academic Press, Amsterdam, 2005.
</p>

<hr>
<h2 id='Ainv'>An Inverse Solution
</h2><span id='topic+Ainv'></span>

<h3>Description</h3>

<p>QR decomposition solution to Ax=b
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ainv(GAB, x, tol = 1e-12)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Ainv_+3A_gab">GAB</code></td>
<td>
<p>design matrix
</p>
</td></tr>
<tr><td><code id="Ainv_+3A_x">x</code></td>
<td>
<p>right hand side
</p>
</td></tr>
<tr><td><code id="Ainv_+3A_tol">tol</code></td>
<td>
<p>tolerance for singularity
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>I needed something to make up for the lame-o matlab code that does this h = G\x to get the inverse
</p>


<h3>Value</h3>

<p>Inverse Solution
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2015)
GAB = matrix(runif(36), ncol=6)
truex =rnorm(ncol(GAB))
rhs = GAB %*% truex

rhs = as.vector(rhs )

tout = Ainv(GAB, rhs, tol = 1e-12)
tout - truex 

</code></pre>

<hr>
<h2 id='art'>ART Inverse solution
</h2><span id='topic+art'></span>

<h3>Description</h3>

<p>ART algorythm for solving
sparse linear inverse problems
</p>


<h3>Usage</h3>

<pre><code class='language-R'>art(A, b, tolx, maxiter)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="art_+3A_a">A</code></td>
<td>
<p>Constraint matrix
</p>
</td></tr>
<tr><td><code id="art_+3A_b">b</code></td>
<td>
<p>right hand side
</p>
</td></tr>
<tr><td><code id="art_+3A_tolx">tolx</code></td>
<td>
<p>difference tolerance for successive iterations (stopping criteria)
</p>
</td></tr>
<tr><td><code id="art_+3A_maxiter">maxiter</code></td>
<td>
<p> maximum iterations (stopping criteria).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Alpha is a damping factor.  If alpha&lt;1, then we won't take full steps
in the ART direction.  Using a smaller value of alpha (say alpha=.75)
can help with convergence on some problems.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>solution</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Aster, R.C., C.H. Thurber, and B. Borchers,
<em>Parameter Estimation and Inverse Problems</em>, Elsevier Academic Press, Amsterdam, 2005.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(2015)
G = setDesignG()
### % Setup the true model.
mtruem=matrix(rep(0, 16*16), ncol=16,nrow=16);

mtruem[9,9]=1; mtruem[9,10]=1; mtruem[9,11]=1;
mtruem[10,9]=1; mtruem[10,11]=1;
mtruem[11,9]=1; mtruem[11,10]=1; mtruem[11,11]=1;
mtruem[2,3]=1; mtruem[2,4]=1;
mtruem[3,3]=1; mtruem[3,4]=1;

### % reshape the true model to be a vector
mtruev=as.vector(mtruem);

### % Compute the data.
dtrue=G %*% mtruev;

### % Add the noise.


d=dtrue+0.01*rnorm(length(dtrue));

mkac&lt;-art(G,d,0.01,200)
par(mfrow=c(1,2))
imagesc(matrix(mtruem,16,16) , asp=1 , main="True Model" );

imagesc(matrix(mkac,16,16) , asp=1 , main="ART Solution" );


</code></pre>

<hr>
<h2 id='bartl'>Bartlett window 
</h2><span id='topic+bartl'></span>

<h3>Description</h3>

<p>Bartlett (triangle) window of length m
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bartl(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bartl_+3A_m">m</code></td>
<td>
<p>integer, length of vector
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Aster, R.C., C.H. Thurber, and B. Borchers,
<em>Parameter Estimation and Inverse Problems</em>, Elsevier Academic Press, Amsterdam, 2005.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bartl(11)

</code></pre>

<hr>
<h2 id='bayes'>Bayes Inversion
</h2><span id='topic+bayes'></span>

<h3>Description</h3>

<p>Given a linear inverse problem Gm=d, a prior mean mprior and covariance
matrix covm, data d, and data covariance matrix covd, this function
computes the MAP solution and the corresponding covariance matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayes(G, mprior, covm, d, covd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayes_+3A_g">G</code></td>
<td>
<p>Design Matrix
</p>
</td></tr>
<tr><td><code id="bayes_+3A_mprior">mprior</code></td>
<td>
<p>vector, prior model
</p>
</td></tr>
<tr><td><code id="bayes_+3A_covm">covm</code></td>
<td>
<p>vector, model covariance
</p>
</td></tr>
<tr><td><code id="bayes_+3A_d">d</code></td>
<td>
<p>vector, right hand side
</p>
</td></tr>
<tr><td><code id="bayes_+3A_covd">covd</code></td>
<td>
<p>vector, data covariance
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector model
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Aster, R.C., C.H. Thurber, and B. Borchers,
<em>Parameter Estimation and Inverse Problems</em>, Elsevier Academic Press, Amsterdam, 2005.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
set.seed(2015)
G = setDesignG()
### 
mtruem=matrix(rep(0, 16*16), ncol=16,nrow=16);

mtruem[9,9]=1; mtruem[9,10]=1; mtruem[9,11]=1;
mtruem[10,9]=1; mtruem[10,11]=1;
mtruem[11,9]=1; mtruem[11,10]=1; mtruem[11,11]=1;
mtruem[2,3]=1; mtruem[2,4]=1;
mtruem[3,3]=1; mtruem[3,4]=1;

### 
mtruev=as.vector(mtruem);
imagesc(matrix(mtruem,16,16) , asp=1 , main="True Model" );


matrix(mtruem,16,16) , asp=1 , main="True Model" )


### 
dtrue=G %*% mtruev;

### 
d=dtrue+0.01*rnorm(length(dtrue));
covd = 0.1*diag( nrow=length(d) )
covm = 1*diag( nrow=dim(G)[2] )

## End(Not run)
</code></pre>

<hr>
<h2 id='blf2'>Bounded least squares
</h2><span id='topic+blf2'></span>

<h3>Description</h3>

<p>Bounded least squares </p>


<h3>Usage</h3>

<pre><code class='language-R'>blf2(A, b, c, delta, l, u)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blf2_+3A_a">A</code></td>
<td>
<p>Design Matrix
</p>
</td></tr>
<tr><td><code id="blf2_+3A_b">b</code></td>
<td>
<p>Right hand side
</p>
</td></tr>
<tr><td><code id="blf2_+3A_c">c</code></td>
<td>
<p>matrix weight on x
</p>
</td></tr>
<tr><td><code id="blf2_+3A_delta">delta</code></td>
<td>
<p>tolerance 
</p>
</td></tr>
<tr><td><code id="blf2_+3A_l">l</code></td>
<td>
<p>lower bound
</p>
</td></tr>
<tr><td><code id="blf2_+3A_u">u</code></td>
<td>
<p>upper bound
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Solves the problem: min/max c'*x where || Ax-b || &lt;= delta
and l &lt;= x &lt;= u.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>solution</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Aster, R.C., C.H. Thurber, and B. Borchers,
<em>Parameter Estimation and Inverse Problems</em>, Elsevier Academic
Press, Amsterdam, 2005.
</p>
<p>Stark, P.B. , and R. L. Parker, <em>Bounded-Variable Least-Squares: An Algorithm
and Applications</em>, Computational Statistics 10:129-141, 1995.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###  set up an inverse problem:Shaw problem

n = 20
G = shawG(n,n)

spike = rep(0,n)
spike[10] = 1

spiken = G %*%  spike

wts = rep(1, n)
delta = 1e-03
set.seed(2015)
dspiken = spiken + 6e-6 *rnorm(length(spiken))

lb = spike - (.2) * wts
ub = spike + (.2) * wts

dspiken = dspiken

 blf2(G, dspiken, wts , delta, lb, ub)


</code></pre>

<hr>
<h2 id='cgls'>Conjugate gradient Least squares 
</h2><span id='topic+cgls'></span>

<h3>Description</h3>

<p>Conjugate gradient Least squares 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cgls(Gmat, dee, niter)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cgls_+3A_gmat">Gmat</code></td>
<td>
<p>input matrix
</p>
</td></tr>
<tr><td><code id="cgls_+3A_dee">dee</code></td>
<td>
<p>right hand side
</p>
</td></tr>
<tr><td><code id="cgls_+3A_niter">niter</code></td>
<td>
<p>max number of iterations
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs niter iterations of the CGLS algorithm on the least
squares problem  min norm(G*m-d).  Gmat should be a sparse matrix.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p>matrix of  models</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>misfit norms</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>model norms</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Aster, R.C., C.H. Thurber, and B. Borchers,
<em>Parameter Estimation and Inverse Problems</em>, Elsevier Academic Press, Amsterdam, 2005.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(11)
####  perfect data with no noise
n &lt;- 5
A &lt;- matrix(runif(n*n),nrow=n)
B &lt;- runif(n)
###  get right-hand-side (data)
trhs = as.vector( A %*% B  )
Lout = cgls(A, trhs , 15)

###  solution is
Lout$X[,15]

Lout$X[,15] - B



</code></pre>

<hr>
<h2 id='chi'>Chi function
</h2><span id='topic+chi'></span>

<h3>Description</h3>

<p>Chi function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chi(x, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chi_+3A_x">x</code></td>
<td>
<p>value
</p>
</td></tr>
<tr><td><code id="chi_+3A_n">n</code></td>
<td>
<p>degrees of freedom
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>function evaluated
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p> Aster, R.C., C.H. Thurber, and B. Borchers,
<em>Parameter Estimation and Inverse Problems</em>, Elsevier Academic Press, Amsterdam, 2005.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = seq(0, 10, length=100)
n = 5
y=chi(x, n)
plot(x, y)


</code></pre>

<hr>
<h2 id='chi2cdf'>Chi-Sq CDF
</h2><span id='topic+chi2cdf'></span>

<h3>Description</h3>

<p>Computes the Chi^2 CDF, using a transformation to N(0,1) on page
333 of Thistead, Elements of Statistical Computing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chi2cdf(x, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chi2cdf_+3A_x">x</code></td>
<td>
<p>end value of chi^2 pdf to integrate to. (scalar)
</p>
</td></tr>
<tr><td><code id="chi2cdf_+3A_n">n</code></td>
<td>
<p>degrees of freedom (scalar)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that x and m must be scalars.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>p</code></td>
<td>
<p> probability that Chi^2 random variable is less than or equal to x (scalar).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Aster, R.C., C.H. Thurber, and B. Borchers,
<em>Parameter Estimation and Inverse Problems</em>, Elsevier Academic Press, Amsterdam, 2005.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x= seq(from=0.1, to=0.9, length=20)
chi2cdf(x , 3)

</code></pre>

<hr>
<h2 id='chi2inv'>Inverse Chi-Sq
</h2><span id='topic+chi2inv'></span>

<h3>Description</h3>

<p>Inverse Chi-Sq
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chi2inv(x, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chi2inv_+3A_x">x</code></td>
<td>
<p>probability that Chi^2 random variable is less than or equal to x (scalar).
</p>
</td></tr>
<tr><td><code id="chi2inv_+3A_n">n</code></td>
<td>
<p>degrees of freedom(scalar)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the inverse Chi^2 distribution corresponding to a given
probability that a Chi^2 random variable with the given degrees
of freedom is less than or equal to x.  Uses chi2cdf.m.
</p>


<h3>Value</h3>

<p>corresponding value of x for given probability.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Aster, R.C., C.H. Thurber, and B. Borchers,
<em>Parameter Estimation and Inverse Problems</em>, Elsevier Academic Press, Amsterdam, 2005.
</p>


<h3>See Also</h3>

<p>chi, chi2cdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = seq(from=0.1, to=0.9, length=10) 
h = chi2cdf(x, 3)

chi2inv(h, 3)

</code></pre>

<hr>
<h2 id='dcost'>cosine transform
</h2><span id='topic+dcost'></span>

<h3>Description</h3>

<p>Computes the column-by-column discrete cosine transform of X.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcost(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dcost_+3A_x">X</code></td>
<td>
<p>Time series matrix
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cosine transformaed data
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 x &lt;- 1:4

### compare fft with cosine transform
     fft(x)
    
dcost(x)

</code></pre>

<hr>
<h2 id='error.bar'>Plot Error Bar
</h2><span id='topic+error.bar'></span>

<h3>Description</h3>

<p>Plot Error Bar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>error.bar(x, y, lo, hi, pch = 1, col = 1, barw = 0.1, add = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="error.bar_+3A_x">x</code></td>
<td>
<p>X-values
</p>
</td></tr>
<tr><td><code id="error.bar_+3A_y">y</code></td>
<td>
<p>Y-values
</p>
</td></tr>
<tr><td><code id="error.bar_+3A_lo">lo</code></td>
<td>
<p>Lower limit of error bars
</p>
</td></tr>
<tr><td><code id="error.bar_+3A_hi">hi</code></td>
<td>
<p>Upper limit of error bars
</p>
</td></tr>
<tr><td><code id="error.bar_+3A_pch">pch</code></td>
<td>
<p>plotting character
</p>
</td></tr>
<tr><td><code id="error.bar_+3A_col">col</code></td>
<td>
<p>color
</p>
</td></tr>
<tr><td><code id="error.bar_+3A_barw">barw</code></td>
<td>
<p>width of the bar
</p>
</td></tr>
<tr><td><code id="error.bar_+3A_add">add</code></td>
<td>
<p>logical, add=FALSE starts a new plot
</p>
</td></tr>
<tr><td><code id="error.bar_+3A_...">...</code></td>
<td>
<p>other plotting parameters
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>graphical side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = 1:10
y = 2*x+5
zup = rnorm(10)


zup = zup-min(zup)+.5
zdown = rnorm(10)
zdown = zdown-min(zdown)+.2


####  example with same error on either side:
error.bar(x, y, y-zup, y+zup, pch = 1, col = 'brown' , barw = 0.1, add =
FALSE)


####  example with different  error on either side:
error.bar(x, y, y-zdown, y+zup, pch = 1, col = 'brown' , barw = 0.1, add
= FALSE)




</code></pre>

<hr>
<h2 id='flipGSVD'>Flip output of GSVD
</h2><span id='topic+flipGSVD'></span>

<h3>Description</h3>

<p>Flip (reverse order) output of GSVD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flipGSVD(vs, d1 = c(50, 50), d2 = c(48, 50))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flipGSVD_+3A_vs">vs</code></td>
<td>
<p>list output of GSVD
</p>
</td></tr>
<tr><td><code id="flipGSVD_+3A_d1">d1</code></td>
<td>
<p>dimensionals of A
</p>
</td></tr>
<tr><td><code id="flipGSVD_+3A_d2">d2</code></td>
<td>
<p>dimensions of B
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This flipping of the matrix
is done to agree with the Matlab code.
</p>


<h3>Value</h3>

<p>Same as GSVD, but order of eigenvectors is reversed.
</p>
<table role = "presentation">
<tr><td><code>U</code></td>
<td>
<p>m by m orthogonal matrix</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>p by p orthogonal matrix, p=rank(B)</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>n by n nonsingular matrix</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>singular values, m by n matrix with diagonal elements shifted from main diagonal</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>singular values, p by n diagonal matrix</p>
</td></tr>
</table>


<h3>Note</h3>

<p> The GSVD routines are from LAPACK.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>GSVD
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(12)

n &lt;- 5
A &lt;- matrix(runif(n*n),nrow=n)
B &lt;- matrix(runif(n*n),nrow=n)

VS = GSVD(A, B)

FVS = flipGSVD(VS, d1 = dim(A) , d2 = dim(B) )
## see that order of eigen vectors is reversed
diag(VS$S)
diag(FVS$S)

</code></pre>

<hr>
<h2 id='gcv_function'>gcv func
</h2><span id='topic+gcv_function'></span>

<h3>Description</h3>

<p>Auxiliary routine for GCV calculations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcv_function(alpha, gamma2, beta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gcv_function_+3A_alpha">alpha</code></td>
<td>
<p>parameter
</p>
</td></tr>
<tr><td><code id="gcv_function_+3A_gamma2">gamma2</code></td>
<td>
<p>square of the gamma from the gsvd
</p>
</td></tr>
<tr><td><code id="gcv_function_+3A_beta">beta</code></td>
<td>
<p>projected data to fit
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector, g - || Gm_(alpha,L) - d ||^2 / (Tr(I - GG#)^2
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Aster, R.C., C.H. Thurber, and B. Borchers,
<em>Parameter Estimation and Inverse Problems</em>, Elsevier Academic Press, Amsterdam, 2005.
</p>

<hr>
<h2 id='gcval'>Get c-val
</h2><span id='topic+gcval'></span>

<h3>Description</h3>

<p> Extract the smallest regularization parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcval(U, s, b, npoints)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gcval_+3A_u">U</code></td>
<td>
<p>U matrix from gsvd(G, L)
</p>
</td></tr>
<tr><td><code id="gcval_+3A_s">s</code></td>
<td>
<p>[diag(C) diag(S)] which are the lambdas and mus from the gsvd
</p>
</td></tr>
<tr><td><code id="gcval_+3A_b">b</code></td>
<td>
<p>the data to try and match
</p>
</td></tr>
<tr><td><code id="gcval_+3A_npoints">npoints</code></td>
<td>
<p>number of alphas to estimate
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Evaluate the GCV function gcv_function at npoints points.
</p>


<h3>Value</h3>

<p>List:
</p>
<table role = "presentation">
<tr><td><code>reg_min</code></td>
<td>
<p> alpha with the minimal g (scalar)</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p> || Gm_(alpha,L) - d ||^2 / (Tr(I - GG#)^2</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>alpha for the corresponding g</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>gcv_function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(2015)
VSP = vspprofile()
t = VSP$t2
G = VSP$G
M = VSP$M
N = VSP$N

L1 = get_l_rough(N,1);
littleU = PEIP::GSVD(as.matrix(G), as.matrix(L1) );

BIGU = flipGSVD(littleU, dim(G), dim(L1) )

U1 = BIGU$U
V1 =BIGU$V
X1=BIGU$X
Lam1=BIGU$C
M1=BIGU$S

lam=sqrt(diag(t(Lam1 %*% Lam1)));

mu=sqrt(diag(t(M1)%*%M1));

p=rnk(L1);

sm1=cbind(lam[1:p],mu[1:p])

### % get the gcv values varying alpha

###
ngcvpoints=1000;

HI = gcval(U1,sm1,t,ngcvpoints);



</code></pre>

<hr>
<h2 id='get_l_rough'>One-D Roughening
</h2><span id='topic+get_l_rough'></span>

<h3>Description</h3>

<p>Returns a 1D differentiating matrix operating on a series with n points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_l_rough(n, deg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_l_rough_+3A_n">n</code></td>
<td>
<p>integer, number of data points
</p>
</td></tr>
<tr><td><code id="get_l_rough_+3A_deg">deg</code></td>
<td>
<p>order of the derivative to approximate
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used to get first and 2nd order roughening matrices for 1-D problems
</p>


<h3>Value</h3>

<p>Matrix:discrete differentiation matrix 
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p> Aster, R.C., C.H. Thurber, and B. Borchers,
<em>Parameter Estimation and Inverse Problems</em>, Elsevier Academic Press, Amsterdam, 2005.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### first order roughening matrix for a 10 by 10 model: a sparse matrix
N = 10
L1 = get_l_rough(10,1);

### second order roughening matrix for a 10 by 10 model
N = 10
L2 = get_l_rough(10,2);

</code></pre>

<hr>
<h2 id='ginv'>Get inverse
</h2><span id='topic+ginv'></span>

<h3>Description</h3>

<p>Get inverse of matrisx or solve Ax=b.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ginv(G, x, tol = 1e-12)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ginv_+3A_g">G</code></td>
<td>
<p>Design Matrix
</p>
</td></tr>
<tr><td><code id="ginv_+3A_x">x</code></td>
<td>
<p>right hand side
</p>
</td></tr>
<tr><td><code id="ginv_+3A_tol">tol</code></td>
<td>
<p>tolerance
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function used as alternative to matlab code that does this h = G\x to get the inverse
</p>


<h3>Value</h3>

<p>inverse as a N by 1 matrix.
</p>


<h3>Note</h3>

<p>Be careful about the usage of tolerance
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>solve, Ainv 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2015)
GAB = matrix(runif(36), ncol=6)
truex =rnorm(ncol(GAB))
rhs = GAB %*% truex

rhs = as.vector(rhs )

tout = ginv(GAB, rhs, tol = 1e-12)
tout - truex 

</code></pre>

<hr>
<h2 id='GSVD'>Generalized SVD
</h2><span id='topic+GSVD'></span>

<h3>Description</h3>

<p>Wrapper for generalized svd from LAPACK
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GSVD(A, B)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GSVD_+3A_a">A</code></td>
<td>
<p>Matrix, see below </p>
</td></tr>
<tr><td><code id="GSVD_+3A_b">B</code></td>
<td>
<p>Matrix, see below </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The A and B matrices will be, A=U*C*t(X) and B=V*S*t(X), respectively.
</p>
<p>Since PEIP is based on a book, which is iteslef based on MATLAB routines,
the convention here follows the book.  The R implementation uses LAPACK
and wraps the function so the output will comply with the book.  See page
104 of the second edition of the Aster book cited below.  That said,
the purpose is to find an inversion of the form Y = t(A aB),
where a is a regularization parameter, B is
smoothing matrix and A is the design matrix for the forward problem.
The input matrices A and B are assumed to have full rank, and
p = rank(B).  The generalized singular values are then gamma = lambda/mu,
where lambda = sqrt(diag(t(C)*C) ) and mu = sqrt(diag(t(S)*S) ).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>U</code></td>
<td>
<p>m by m orthogonal matrix</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>p by p orthogonal matrix, p=rank(B)</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>n by n nonsingular matrix</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>singular values, m by n matrix with diagonal elements shifted from main diagonal</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>singular values, p by n diagonal matrix</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Requires R version of LAPACK. The code is a wrapper
for the dggsvd function in LAPACK.  The author thanks Berend Hasselman for advice
and help preparing this function.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Aster, R.C., C.H. Thurber, and B. Borchers,
<em>Parameter Estimation and Inverse Problems</em>,
Elsevier Academic Press, Amsterdam, 2005.
</p>


<h3>See Also</h3>

<p>flipGSVD</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example from NAG F08VAF

A &lt;- matrix(1:15, nrow=5,ncol=3)
 B &lt;- matrix(c(8,1,6,
               3,5,7,
               4,9,2), nrow=3, byrow=TRUE)

z &lt;- GSVD(A,B)
C &lt;- z$C
S &lt;- z$S
sqrt(diag(t(C) %*% C)) / sqrt(diag(t(S) %*% S))
testA = A - z$U %*% C %*% t(z$X)
testB = B - z$V %*% S %*% t(z$X)

print(testA)
print(testB)


</code></pre>

<hr>
<h2 id='idcost'>Inverse  cosine transform 
</h2><span id='topic+idcost'></span>

<h3>Description</h3>

<p>Takes the column-by-column inverse discrete cosine transform of Y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idcost(Y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idcost_+3A_y">Y</code></td>
<td>
<p>Input cosine transform
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Time series
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Aster, R.C., C.H. Thurber, and B. Borchers,
<em>Parameter Estimation and Inverse Problems</em>, Elsevier Academic Press, Amsterdam, 2005.
</p>


<h3>See Also</h3>

<p>dcost
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- 1:4

### compare fft with cosine transform
     fft(x)
    
zig = dcost(x)
zag = idcost(zig)

</code></pre>

<hr>
<h2 id='imagesc'>Image Display
</h2><span id='topic+imagesc'></span><span id='topic+contoursc'></span>

<h3>Description</h3>

<p>Display image in matlab format, i.e. flip and transpose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imagesc(G, col = grey((1:99)/100), ...)
contoursc(G, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imagesc_+3A_g">G</code></td>
<td>
<p>Image matrix
</p>
</td></tr>
<tr><td><code id="imagesc_+3A_col">col</code></td>
<td>
<p>color scale
</p>
</td></tr>
<tr><td><code id="imagesc_+3A_...">...</code></td>
<td>
<p>graphical parameters
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Program flips image and transposes prior to plotting.
The contour version does the same and can be used to add contours.
</p>


<h3>Value</h3>

<p>graphical side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtruem=matrix(rep(0, 16*16), ncol=16,nrow=16);

mtruem[9,9]=1; mtruem[9,10]=1; mtruem[9,11]=1;
mtruem[10,9]=1; mtruem[10,11]=1;
mtruem[11,9]=1; mtruem[11,10]=1; mtruem[11,11]=1;
mtruem[2,3]=1; mtruem[2,4]=1;
mtruem[3,3]=1; mtruem[3,4]=1;

imagesc(mtruem, asp=1)



</code></pre>

<hr>
<h2 id='interp2grid'> Bilinear and Bicubic Interpolation to Grid </h2><span id='topic+interp2grid'></span>

<h3>Description</h3>

<p>This code includes a  bicubic interpolation and a  bilinear
interpolation adapted from Numerical Recipes in C: The art of
scientific computing  (chapter
3... bicubic interpolation) and a bicubic interpolation from
in java code.
</p>
<p>Inputs are a list of points to interpolate to and from raster objects of
class 'asc' (adehabitat package), 'RasterLayer' (raster package) or 'SpatialGridDataFrame' (sp package).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interp2grid(mat,xout,yout,xin=NULL,yin=NULL,type=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interp2grid_+3A_mat">mat</code></td>
<td>
<p>a matrix of data that can be a raster matrix of class 'asc' (adehabitat package), 'RasterLayer' (raster package) or 'SpatialGridDataFrame' (sp package)
NA values are not permitted.. data must be complete.</p>
</td></tr>
<tr><td><code id="interp2grid_+3A_xout">xout</code></td>
<td>
<p>a vector of data representing x coordinates of the output grid. Resulting grid must have square cell sizes if mat is of class 'asc', 'RasterLayer' or 'SpatialGridDataFrame'.</p>
</td></tr>
<tr><td><code id="interp2grid_+3A_yout">yout</code></td>
<td>
<p>a vector of data representing x coordinates of the output grid. Resulting grid must have square cell sizes if mat is of class 'asc', 'RasterLayer' or 'SpatialGridDataFrame'.</p>
</td></tr>
<tr><td><code id="interp2grid_+3A_xin">xin</code></td>
<td>
<p>a vector identifying the locations of the columns of the input data matrix. These are automatically populated if mat is of class 'asc', 'RasterLayer' or 'SpatialGridDataFrame'.</p>
</td></tr>
<tr><td><code id="interp2grid_+3A_yin">yin</code></td>
<td>
<p>a vector identifying the locations of the rows of the input data matrix. These are automatically populated if mat is of class 'asc', 'RasterLayer' or 'SpatialGridDataFrame'.</p>
</td></tr>
<tr><td><code id="interp2grid_+3A_type">type</code></td>
<td>
<p>an integer value representing the type of
interpolation method used.
</p>
<p>1 - bilinear adapted from Numerical Recipes in C
</p>
<p>2 - bicubic adapted from Numerical Recipes in C
</p>
<p>3 - bicubic adapted from online java code</p>
</td></tr>
</table>


<h3>Value</h3>

<p> Returns a matrix of the originating class. </p>


<h3>Author(s)</h3>

<p> Jeremy VanDerWal <a href="mailto:jjvanderwal@gmail.com">jjvanderwal@gmail.com</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
tx = seq(0,3,0.1)
ty = seq(0,3,0.1)

     tmat = matrix(runif(16,1,16),nrow=4)
     txin = seq(0,3,length=4)
     tyin = seq(0,3,length=4)

     bilinear1 = interp2grid(tmat,tx,ty,txin, tyin,    type=1)
     bicubic2 = interp2grid(tmat,tx,ty,txin, tyin, type=2)
     bicubic3 = interp2grid(tmat,tx,ty,txin, tyin, type=3)

    par(mfrow=c(2,2),cex=1)
             image(tmat,main='base',zlim=c(0,16),col=heat.colors(100))
             image(bilinear1,main='bilinear',zlim=c(0,16),col=heat.colors(100))
             image(bicubic2,main='bicubic2',zlim=c(0,16),col=heat.colors(100))
             image(bicubic3,main='bicubic3',zlim=c(0,16),col=heat.colors(100))
   

</code></pre>

<hr>
<h2 id='irls'>Iteratively reweight least squares
</h2><span id='topic+irls'></span>

<h3>Description</h3>

<p>Uses the iteratively reweight least squares strategy to find an
approximate L_p solution to Ax=b.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irls(A, b, tolr, tolx, p, maxiter)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="irls_+3A_a">A</code></td>
<td>
<p>Matrix of the system of equations.
</p>
</td></tr>
<tr><td><code id="irls_+3A_b">b</code></td>
<td>
<p>Right hand side of the system of equations
</p>
</td></tr>
<tr><td><code id="irls_+3A_tolr">tolr</code></td>
<td>
<p>Tolerance below which residuals are ignored
</p>
</td></tr>
<tr><td><code id="irls_+3A_tolx">tolx</code></td>
<td>
<p>Stopping tolerance.  Stop when (norm(newx-x)/(1+norm(x)) &lt; tolx)
</p>
</td></tr>
<tr><td><code id="irls_+3A_p">p</code></td>
<td>
<p>Specifies which p-norm to use (most often, p=1.)
</p>
</td></tr>
<tr><td><code id="irls_+3A_maxiter">maxiter</code></td>
<td>
<p>Limit on number of iterations of IRLS
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use to get L-1 norm solution of inverse problems.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p> Approximate L_p solution</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Aster, R.C., C.H. Thurber, and B. Borchers,
<em>Parameter Estimation and Inverse Problems</em>, Elsevier Academic Press, Amsterdam, 2005.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t = 1:10
y=c(109.3827,187.5385,267.5319,331.8753,386.0535,
428.4271,452.1644,498.1461,512.3499,512.9753)
sigma = rep(8, length(y))
N=length(t);

### % Introduce the outlier
y[4]=y[4]-200;

G = cbind( rep(1, N), t, -1/2*t^2 )

### % Apply the weighting

yw = y/sigma;

Gw = G/sigma

m2 = solve( t(Gw) %*% Gw , t(Gw) %*% yw, tol=1e-12 )


###  Solve for the 1-norm solution

m1 = irls(Gw,yw,1.0e-5,1.0e-5,1,25)
m1



</code></pre>

<hr>
<h2 id='irlsl1reg'>L1 least squares with sparsity
</h2><span id='topic+irlsl1reg'></span>

<h3>Description</h3>

<p>Solves the system Gm=d using sparsity regularization on Lm.
Solves the L1 regularized least squares problem:
min norm(G*m-d,2)^2+alpha*norm(L*m,1)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irlsl1reg(G, d, L, alpha, maxiter = 100, tolx = 1e-04, tolr = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="irlsl1reg_+3A_g">G</code></td>
<td>
<p>design matrix
</p>
</td></tr>
<tr><td><code id="irlsl1reg_+3A_d">d</code></td>
<td>
<p>right hand side
</p>
</td></tr>
<tr><td><code id="irlsl1reg_+3A_l">L</code></td>
<td>
<p>regularization matrix
</p>
</td></tr>
<tr><td><code id="irlsl1reg_+3A_alpha">alpha</code></td>
<td>
<p>regularization parameter
</p>
</td></tr>
<tr><td><code id="irlsl1reg_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of IRLS iterations
</p>
</td></tr>
<tr><td><code id="irlsl1reg_+3A_tolx">tolx</code></td>
<td>
<p>Tolerance on successive iterates
</p>
</td></tr>
<tr><td><code id="irlsl1reg_+3A_tolr">tolr</code></td>
<td>
<p>Tolerance below which we consider an element of L*m to be
effectively zero
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>m</code></td>
<td>
<p>model vector</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Aster, R.C., C.H. Thurber, and B. Borchers,
<em>Parameter Estimation and Inverse Problems</em>, Elsevier Academic Press, Amsterdam, 2005.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

n = 20
G = shawG(n,n)

spike = rep(0,n)
spike[10] = 1

spiken = G %*%  spike

wts = rep(1, n)
delta = 1e-03
set.seed(2015)
dspiken = spiken + 6e-6 *rnorm(length(spiken))
L1 = get_l_rough(n,1);
alpha = 0.001

k = irlsl1reg(G, dspiken, L1, alpha, maxiter = 100, tolx = 1e-04, tolr = 1e-06)


plotconst(k,-pi/2,pi/2, ylim=c(-.2,  0.5), xlab="theta", ylab="Intensity" );


</code></pre>

<hr>
<h2 id='kac'>Kaczmarz
</h2><span id='topic+kac'></span>

<h3>Description</h3>

<p>Implements Kaczmarz's algorithm to solve a system of equations iteratively
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kac(A, b, tolx, maxiter)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kac_+3A_a">A</code></td>
<td>
<p>Constraint matrix
</p>
</td></tr>
<tr><td><code id="kac_+3A_b">b</code></td>
<td>
<p>right hand side
</p>
</td></tr>
<tr><td><code id="kac_+3A_tolx">tolx</code></td>
<td>
<p>difference tolerence for successive iterations (stopping criteria)
</p>
</td></tr>
<tr><td><code id="kac_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum iterations (stopping criteria)
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>solution</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Aster, R.C., C.H. Thurber, and B. Borchers,
<em>Parameter Estimation and Inverse Problems</em>, Elsevier Academic Press, Amsterdam, 2005.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(2015)
G = setDesignG()
### % Setup the true model.
mtruem=matrix(rep(0, 16*16), ncol=16,nrow=16);

mtruem[9,9]=1; mtruem[9,10]=1; mtruem[9,11]=1;
mtruem[10,9]=1; mtruem[10,11]=1;
mtruem[11,9]=1; mtruem[11,10]=1; mtruem[11,11]=1;
mtruem[2,3]=1; mtruem[2,4]=1;
mtruem[3,3]=1; mtruem[3,4]=1;

### % reshape the true model to be a vector
mtruev=as.vector(mtruem);

### % Compute the data.
dtrue=G %*% mtruev;

### % Add the noise.

d=dtrue+0.1*rnorm(length(dtrue));

mkac&lt;-kac(G,d,0.0,200)
par(mfrow=c(1,2))
imagesc(matrix(mtruem,16,16) , asp=1 , main="True Model" );

imagesc(matrix(mkac,16,16) , asp=1 , main="Kacz Solution" );

</code></pre>

<hr>
<h2 id='l_curve_corner'>L Curve Corner
</h2><span id='topic+l_curve_corner'></span>

<h3>Description</h3>

<p>Retrieve corner of L-curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_curve_corner(rho, eta, reg_param)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="l_curve_corner_+3A_rho">rho</code></td>
<td>
<p>misfit
</p>
</td></tr>
<tr><td><code id="l_curve_corner_+3A_eta">eta</code></td>
<td>
<p>model norm or seminorm
</p>
</td></tr>
<tr><td><code id="l_curve_corner_+3A_reg_param">reg_param</code></td>
<td>
<p>regularization parameter
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>reg_corner</code></td>
<td>
<p>   the value of reg_param with maximum curvature</p>
</td></tr>
<tr><td><code>ireg_corner</code></td>
<td>
<p>  the index of the value in reg_param with maximum curvature</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>        the curvature for each reg_param</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Aster, R.C., C.H. Thurber, and B. Borchers,
<em>Parameter Estimation and Inverse Problems</em>, Elsevier Academic Press, Amsterdam, 2005.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####  Vertical Seismic Profile example
set.seed(2015)
VSP = vspprofile()
t = VSP$t2
G = VSP$G
M = VSP$M
N = VSP$N

L1 = get_l_rough(N,1);
littleU = PEIP::GSVD(as.matrix(G), as.matrix(L1) );

BIGU = flipGSVD(littleU, dim(G), dim(L1) )

U1 = BIGU$U
V1 =BIGU$V
X1=BIGU$X
Lam1=BIGU$C
M1=BIGU$S



K1 =  l_curve_tgsvd(U1,t,X1,Lam1,G,L1);

rho1 =K1$rho
eta1 =K1$eta
reg_param1 =K1$reg_param
m1s =K1$m

### % store where the corner is (from visual inspection)
vcorn = l_curve_corner(rho1, eta1, reg_param1)

ireg_corner1=vcorn$reg_corner
rho_corner1=rho1[ireg_corner1];
eta_corner1=eta1[ireg_corner1];
print(paste('1st order reg corner is:  ',ireg_corner1));


plot(rho1,eta1,type="b", log="xy" , xlim=c(1e-4, 1e-2) , ylim=c(6e-6, 2e-4)  ,
     xlab="Residual Norm ||Gm-d||_2", ylab="Solution Seminorm ||Lm||_2"  );
points(rho_corner1, eta_corner1, col='red', cex=2 )


</code></pre>

<hr>
<h2 id='l_curve_tgsvd'>L curve tgsvd
</h2><span id='topic+l_curve_tgsvd'></span>

<h3>Description</h3>

<p>L curve parematers and models for truncated gsvd regularization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_curve_tgsvd(U, d, X, Lam, G, L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="l_curve_tgsvd_+3A_u">U</code></td>
<td>
<p>U, output of GSVD
</p>
</td></tr>
<tr><td><code id="l_curve_tgsvd_+3A_d">d</code></td>
<td>
<p> output of GSVD
</p>
</td></tr>
<tr><td><code id="l_curve_tgsvd_+3A_x">X</code></td>
<td>
<p>output of GSVD
</p>
</td></tr>
<tr><td><code id="l_curve_tgsvd_+3A_lam">Lam</code></td>
<td>
<p>output of GSVD
</p>
</td></tr>
<tr><td><code id="l_curve_tgsvd_+3A_g">G</code></td>
<td>
<p>output of GSVD
</p>
</td></tr>
<tr><td><code id="l_curve_tgsvd_+3A_l">L</code></td>
<td>
<p>output of GSVD
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List:
</p>
<table role = "presentation">
<tr><td><code>eta</code></td>
<td>
<p>        the solution seminorm ||Lm||</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>       the residual norm ||G m - d||</p>
</td></tr>
<tr><td><code>reg_param</code></td>
<td>
<p>  corresponding regularization parameters</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>          corresponding suite of models for truncated GSVD</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p> Aster, R.C., C.H. Thurber, and B. Borchers,
<em>Parameter Estimation and Inverse Problems</em>, Elsevier Academic Press, Amsterdam, 2005.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

####  Vertical Seismic Profile example
set.seed(2015)
VSP = vspprofile()
t = VSP$t2
G = VSP$G
M = VSP$M
N = VSP$N


L1 = get_l_rough(N,1);
littleU = PEIP::GSVD(as.matrix(G), as.matrix(L1) );

BIGU = flipGSVD(littleU, dim(G), dim(L1) )

U1 = BIGU$U
V1 =BIGU$V
X1=BIGU$X
Lam1=BIGU$C
M1=BIGU$S



K1 =  l_curve_tgsvd(U1,t,X1,Lam1,G,L1);

rho1 =K1$rho
eta1 =K1$eta
reg_param1 =K1$reg_param
m1s =K1$m


### % store where the corner is (from visual inspection)
ireg_corner1=8;
rho_corner1=rho1[ireg_corner1];
eta_corner1=eta1[ireg_corner1];
print(paste('1st order reg corner is:  ',ireg_corner1));


plot(rho1,eta1,type="b", log="xy", xlim=c(1e-4, 1e-2) , ylim=c(6e-6, 2e-4) ,
     xlab="Residual Norm ||Gm-d||_2", ylab="Solution Seminorm ||Lm||_2"  );




</code></pre>

<hr>
<h2 id='l_curve_tikh_gsvd'>L-curve tikh gsvd
</h2><span id='topic+l_curve_tikh_gsvd'></span>

<h3>Description</h3>

<p>L-curve tikh gsvd
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_curve_tikh_gsvd(U, d, X, Lam, Mu, G, L, npoints, varargin = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="l_curve_tikh_gsvd_+3A_u">U</code></td>
<td>
<p>from the gsvd 
</p>
</td></tr>
<tr><td><code id="l_curve_tikh_gsvd_+3A_d">d</code></td>
<td>
<p>data vector for the problem G*m=d
</p>
</td></tr>
<tr><td><code id="l_curve_tikh_gsvd_+3A_x">X</code></td>
<td>
<p>from the gsvd 
</p>
</td></tr>
<tr><td><code id="l_curve_tikh_gsvd_+3A_lam">Lam</code></td>
<td>
<p>from the gsvd 
</p>
</td></tr>
<tr><td><code id="l_curve_tikh_gsvd_+3A_mu">Mu</code></td>
<td>
<p>from the gsvd 
</p>
</td></tr>
<tr><td><code id="l_curve_tikh_gsvd_+3A_g">G</code></td>
<td>
<p>system matrix 
</p>
</td></tr>
<tr><td><code id="l_curve_tikh_gsvd_+3A_l">L</code></td>
<td>
<p>roughening matrix
</p>
</td></tr>
<tr><td><code id="l_curve_tikh_gsvd_+3A_npoints">npoints</code></td>
<td>
<p>Number of points
</p>
</td></tr>
<tr><td><code id="l_curve_tikh_gsvd_+3A_varargin">varargin</code></td>
<td>

<p>alpha_min, alpha_max: if specified, constrain the logrithmically spaced
regularization parameter range, otherwise an attempt is made to estimate
them from the range of generalized singular values
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses output of GSVD
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>eta</code></td>
<td>
<p>       - the solution seminorm ||Lm||</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>       - the residual norm ||G m - d||</p>
</td></tr>
<tr><td><code>reg_param</code></td>
<td>
<p> - corresponding regularization parameters</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>         - corresponding suite of models for truncated GSVD</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

####  Vertical Seismic Profile example
set.seed(2015)
VSP = vspprofile()
t = VSP$t2
G = VSP$G
M = VSP$M
N = VSP$N

L1 = get_l_rough(N,1);
littleU = PEIP::GSVD(as.matrix(G), as.matrix(L1) );

BIGU = flipGSVD(littleU, dim(G), dim(L1) )

U1 = BIGU$U
V1 =BIGU$V
X1=BIGU$X
Lam1=BIGU$C
M1=BIGU$S

K1 =  l_curve_tikh_gsvd(U1,t,X1,Lam1,M1, G,L1, 25);

rho1 =K1$rho
eta1 =K1$eta
reg_param1 =K1$reg_param
m1s =K1$m


###  store where the corner is (from visual inspection)
ireg_corner1=8;
rho_corner1=rho1[ireg_corner1];
eta_corner1=eta1[ireg_corner1];
print(paste('1st order reg corner is:  ',ireg_corner1));


plot(rho1,eta1,type="b", log="xy", xlim=c(1e-4, 1e-2) , ylim=c(6e-6, 2e-4) ,
     xlab="Residual Norm ||Gm-d||_2", ylab="Solution Seminorm ||Lm||_2"  );

 


</code></pre>

<hr>
<h2 id='l_curve_tikh_svd'>L-curve Tikhonov
</h2><span id='topic+l_curve_tikh_svd'></span>

<h3>Description</h3>

<p>L-curve for Tikhonov regularization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_curve_tikh_svd(U, s, d, npoints, varargin = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="l_curve_tikh_svd_+3A_u">U</code></td>
<td>
<p>matrix of data space basis vectors from the svd
</p>
</td></tr>
<tr><td><code id="l_curve_tikh_svd_+3A_s">s</code></td>
<td>
<p>vector of singular values
</p>
</td></tr>
<tr><td><code id="l_curve_tikh_svd_+3A_d">d</code></td>
<td>
<p>the data vector
</p>
</td></tr>
<tr><td><code id="l_curve_tikh_svd_+3A_npoints">npoints</code></td>
<td>
<p>the number of logarithmically spaced regularization parameters
</p>
</td></tr>
<tr><td><code id="l_curve_tikh_svd_+3A_varargin">varargin</code></td>
<td>

<p>alpha_min, alpha_max: if specified, constrain the logrithmically spaced
regularization parameter range, otherwise an attempt is made to estimate
them from the range of singular values
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the L-curve
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>eta</code></td>
<td>
<p>the solution norm ||m|| or seminorm ||Lm||</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>the residual norm ||G m - d||</p>
</td></tr>
<tr><td><code>reg_param</code></td>
<td>
<p>corresponding regularization parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####  Vertical Seismic Profile example
set.seed(2015)
VSP = vspprofile()
t = VSP$t2
G = VSP$G
M = VSP$M
N = VSP$N

L1 = get_l_rough(N,1);
littleU = PEIP::GSVD(as.matrix(G), as.matrix(L1) );

BIGU = flipGSVD(littleU, dim(G), dim(L1) )

U1 = BIGU$U
V1 =BIGU$V
X1=BIGU$X
Lam1=BIGU$C
M1=BIGU$S

K1 = l_curve_tikh_svd(U1, diag(M1) , X1, 25, varargin = NULL)

rho1 =K1$rho
eta1 =K1$eta
reg_param1 =K1$reg_param
m1s =K1$m

###  store where the corner is (from visual inspection)
ireg_corner1=8;
rho_corner1=rho1[ireg_corner1];
eta_corner1=eta1[ireg_corner1];
print(paste("1st order reg corner is:  ",ireg_corner1));

plot(rho1,eta1,type="b", log="xy" ,
     xlab="Residual Norm ||Gm-d||_2", ylab="Solution Seminorm ||Lm||_2"  );

</code></pre>

<hr>
<h2 id='linesconst'>Plot constant model
</h2><span id='topic+linesconst'></span>

<h3>Description</h3>

<p>Add to plotting  model in piecewise constant form over n subintervals,
where n is the length of x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linesconst(x, l, r, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linesconst_+3A_x">x</code></td>
<td>
<p>model to be plotted
</p>
</td></tr>
<tr><td><code id="linesconst_+3A_l">l</code></td>
<td>
<p>left endpoint of plot
</p>
</td></tr>
<tr><td><code id="linesconst_+3A_r">r</code></td>
<td>
<p>right endpoint of plot
</p>
</td></tr>
<tr><td><code id="linesconst_+3A_...">...</code></td>
<td>
<p>graphical parameters 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used for plotting vector models
</p>


<h3>Value</h3>

<p>graphical side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>plotconst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
zip = runif(25)
plotconst(zip, 0, 1 )
linesconst(runif(25) , 0, 1 , col='red' )

</code></pre>

<hr>
<h2 id='lmarq'>Lev-Marquardt Inversion
</h2><span id='topic+lmarq'></span>

<h3>Description</h3>

<p>Use the Levenberg-Marquardt algorithm to minimize
f(p)=sum(F_i(p)^2)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmarq(afun, ajac, p0, tol, maxiter)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmarq_+3A_afun">afun</code></td>
<td>
<p>name of the function F(x)
</p>
</td></tr>
<tr><td><code id="lmarq_+3A_ajac">ajac</code></td>
<td>
<p> name of the Jacobian function J(x)
</p>
</td></tr>
<tr><td><code id="lmarq_+3A_p0">p0</code></td>
<td>
<p>initial guess
</p>
</td></tr>
<tr><td><code id="lmarq_+3A_tol">tol</code></td>
<td>
<p>stopping tolerance
</p>
</td></tr>
<tr><td><code id="lmarq_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations allowed
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pstar</code></td>
<td>
<p>        best solution found.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>         Iteration count.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fun&lt;-function(p){
###  Compute the function values.
fvec=rep(0,length(TM))
fvec=(Q*exp(-D^2*p[1]/(4*p[2]*TM))/(4*pi*p[2]*TM) - H)/SIGMA
  return(fvec)
}
jac &lt;-function( p)
  {
###  use known formula for the derivatives in the Jacobian
    n=length(TM)
    J= matrix(0,nrow=n,ncol=2)

      J[,1]=(-Q*D^2*exp(-D^2*p[1]/(4*p[2]*TM))/(16*pi*p[2]^2*TM^2))/SIGMA
      
      J[,2]=(Q/(4*pi*p[2]^2*TM))*
          ((D^2*p[1])/(4*p[2]*TM)-1)*exp(-D^2*p[1]/(4*p[2]*TM))/SIGMA
   return(J)
  }

H=c(0.72, 0.49, 0.30, 0.20, 0.16, 0.12)
TM=c(5.0, 10.0, 20.0, 30.0, 40.0, 50.0)

###  Fixed parameter values.
D=60
Q=50
###  We'll use sigma=1cm.  
SIGMA=0.01*rep(1,length(H))
###  The unknown/estimated parameters are S=p(1) and T=p(2).
p0=c(0.001, 1.0)
###  Solve the least squares problem with LM.
 PEST =  lmarq('fun','jac',p0,1.0e-12,100)

</code></pre>

<hr>
<h2 id='loadMAT'>Load a Matlab matfile
</h2><span id='topic+loadMAT'></span>

<h3>Description</h3>

<p>Load a Matlab matfile, rename the internal parameters
to get R-objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadMAT(fn, pos=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadMAT_+3A_fn">fn</code></td>
<td>
<p>file name of MATfile
</p>
</td></tr>
<tr><td><code id="loadMAT_+3A_pos">pos</code></td>
<td>
<p> integer, position in search path, default=1 </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Program reads in previously saved mat-files and extracts the
data, and renames the variables to match the book.
</p>


<h3>Value</h3>

<p>Whatever is in the MATfile
</p>


<h3>Note</h3>

<p>Matfiles are created using the matlab2R routines
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>

<hr>
<h2 id='mcmc'>Maximum likelihood Models 
</h2><span id='topic+mcmc'></span>

<h3>Description</h3>

<p>Maximum likelihood Models 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc(alogprior, aloglikelihood, agenerate, alogproposal, m0, niter)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmc_+3A_alogprior">alogprior</code></td>
<td>
<p>Name of a function that computes the log of
the prior distribution.
</p>
</td></tr>
<tr><td><code id="mcmc_+3A_aloglikelihood">aloglikelihood</code></td>
<td>
<p>Name of a function the computes the log of
the likelihood.
</p>
</td></tr>
<tr><td><code id="mcmc_+3A_agenerate">agenerate</code></td>
<td>
<p>Name of a function that generates a random
model from the current model using the
</p>
</td></tr>
<tr><td><code id="mcmc_+3A_alogproposal">alogproposal</code></td>
<td>
<p>Name of a function that computes the log of
the proposal distribution r(x,y).
</p>
</td></tr>
<tr><td><code id="mcmc_+3A_m0">m0</code></td>
<td>
<p>Initial model
</p>
</td></tr>
<tr><td><code id="mcmc_+3A_niter">niter</code></td>
<td>
<p>Number of iterations to perform
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mout</code></td>
<td>
<p> MCMC samples</p>
</td></tr>
<tr><td><code>mMAP</code></td>
<td>
<p>Best model found in the MCMC simulation.</p>
</td></tr>
<tr><td><code>accrate</code></td>
<td>
<p> Acceptance rate</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fun &lt;-function(m,x)
{
  y=m[1]*exp(m[2]*x)+m[3]*x*exp(m[4]*x)
  return(y)
}

generate &lt;-function( x) {  
  y=x+step*rnorm(4)
  return(y)
}

logprior &lt;-function(m)
{
  if( (m[1]&gt;=0) &amp; (m[1]&lt;=2) &amp;
     (m[2]&gt;=-0.9) &amp; (m[2]&lt;=0) &amp;
     (m[3]&gt;=0) &amp; (m[3]&lt;=2) &amp;
     (m[4]&gt;=-0.9) &amp; (m[4]&lt;=0)  )
    {
      lp=0
    }
  else
    {
      lp= -Inf
    }

  return(lp)
}
loglikelihood &lt;-function(m)
{ 
  fvec=(y-fun(m,x))/sigma
  L=(-1/2)*sum(fvec^2)
  return(L)
}
logproposal &lt;-function(x,y)
  {  
    LR=(-1/2)*sum((x-y)^2/step^2)
    return(LR)
  }

###  Generate the data set.
x=seq(from=1, by=0.25, to=7.0)

mtrue=c(1.0, -0.5, 1.0, -0.75)

ytrue=fun(mtrue,x)

sigma=0.01*rep(1, times= length(ytrue) )

y=ytrue+sigma*rnorm(length(ytrue) )

### set the MCMC parameters
### number of skips to reduce autocorrelation of models
skip=100
### burn-in steps
BURNIN=1000
### number of posterior distribution samples
N=4100
### MVN step size
step = 0.005*rep(1,times=4)

###  We assume flat priors here
m0 = c(0.9003,
   -0.5377,
    0.2137,
   -0.0280)

alogprior='logprior'
aloglikelihood='loglikelihood'
agenerate='generate'
alogproposal='logproposal'

### ###  initialize model at a random point on [-1,1]

###  m0=(runif(4)-0.5)*2
###  this is the matlab initialization:
m0 = c(0.9003,
   -0.5377,
    0.2137,
   -0.0280)

MM =  mcmc('logprior','loglikelihood','generate','logproposal',m0,N)

mout = MM[[1]]
mMAP= MM[[2]]
pacc= MM[[3]]


</code></pre>

<hr>
<h2 id='Mnorm'>Matrix Norm
</h2><span id='topic+Mnorm'></span>

<h3>Description</h3>

<p>Matrix Norm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mnorm(X, k = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Mnorm_+3A_x">X</code></td>
<td>
<p>matrix
</p>
</td></tr>
<tr><td><code id="Mnorm_+3A_k">k</code></td>
<td>
<p>norm number
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>returns the largest singular value of the matrix or vector 
</p>


<h3>Value</h3>

<p>Scalar Norm
</p>


<h3>Note</h3>

<p>if k=1, absolute value; k=2 2-norm (rms); k&gt;2, largest singular value.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = runif(10)

Mnorm(x, k = 2)


</code></pre>

<hr>
<h2 id='nnz'>Non-zeros
</h2><span id='topic+nnz'></span>

<h3>Description</h3>

<p>Number of non-zero elements in a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnz(h)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nnz_+3A_h">h</code></td>
<td>
<p>vector
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
zip&lt;-rnorm(15)
nnz(zip)



</code></pre>

<hr>
<h2 id='occam'>Occam inversion
</h2><span id='topic+occam'></span>

<h3>Description</h3>

<p>Occam's inversion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occam(afun, ajac, L, d, m0, delta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="occam_+3A_afun">afun</code></td>
<td>
<p>character, function handle that computes the forward problem
</p>
</td></tr>
<tr><td><code id="occam_+3A_ajac">ajac</code></td>
<td>
<p>character, function handle that computes the Jacobian of the forward problem
</p>
</td></tr>
<tr><td><code id="occam_+3A_l">L</code></td>
<td>
<p>regularization matrix
</p>
</td></tr>
<tr><td><code id="occam_+3A_d">d</code></td>
<td>
<p>data that should be fit
</p>
</td></tr>
<tr><td><code id="occam_+3A_m0">m0</code></td>
<td>
<p>guess at the model
</p>
</td></tr>
<tr><td><code id="occam_+3A_delta">delta</code></td>
<td>
<p>cutoff to use for the discrepancy principle portion
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector, model found
</p>


<h3>Note</h3>

<p>This is a simple brute force way to do the line search.  Much more
sophisticated methods are available.  Note: we've restricted the line
search to the range from 1.0e-20 to 1.  This seems to work well in
practice, but might need to be adjusted for a particular problem.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>bayes
</p>

<hr>
<h2 id='phi'>Integral of Normal Distribution
</h2><span id='topic+phi'></span>

<h3>Description</h3>

<p>normal distribution and returns the value of the integral
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phi(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phi_+3A_x">x</code></td>
<td>
<p>endpoint of integration (scalar)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of integral
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>erf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 x &lt;- 1.0
##   pracma::erf(x)
 phi(x)
phiinv( phi(x) )


</code></pre>

<hr>
<h2 id='phiinv'>Inverse Normal Distribution Integral
</h2><span id='topic+phiinv'></span>

<h3>Description</h3>

<p>Calculates the inverse normal distribution from the value of the
integral
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phiinv(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phiinv_+3A_x">x</code></td>
<td>
<p>endpoint value of integration (scalar)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of integral (scalar)
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>phi
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 x &lt;- 1.0
##   pracma::erf(x)
 phi(x)
phiinv( phi(x) )


</code></pre>

<hr>
<h2 id='picard_vals'>Picard plot
</h2><span id='topic+picard_vals'></span>

<h3>Description</h3>

<p>Picard plot parameters for subsequent plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>picard_vals(U, sm, d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="picard_vals_+3A_u">U</code></td>
<td>
<p>the U matrix from the SVD or GSVD
</p>
</td></tr>
<tr><td><code id="picard_vals_+3A_sm">sm</code></td>
<td>
<p>singular values in decreasing order, or the GSVD lambdas divided by the mus
in decreasing order
</p>
</td></tr>
<tr><td><code id="picard_vals_+3A_d">d</code></td>
<td>
<p>data to fit, right hand side
</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The Picard plot is a method of helping to determine
regularization schemes.</p>


<h3>Value</h3>

<p>List:
</p>
<table role = "presentation">
<tr><td><code>utd</code></td>
<td>
<p>the columns of U transposed times d</p>
</td></tr>
<tr><td><code>utd_norm</code></td>
<td>
<p>utd./sm</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>GSVD</p>


<h3>Examples</h3>

<pre><code class='language-R'>####
n = 20
G = shawG(n,n)
spike = rep(0,n)
spike[10] = 1
dspiken = G 

set.seed(2015)
dspiken = dspiken + 6e-6 *rnorm(length(dspiken))
Utube=svd(G);
U = Utube$u
V = Utube$v
S = Utube$d
s=Utube$d
 R3 = picard_vals(U,s,dspiken);
utd = R3$utd
utd_norm= R3$utd_norm
###  Produce the Picard plot.

x_ind=1:length(s);
##  
plot( range(x_ind) , range(c(s ,abs(utd),abs(utd_norm))),
          type='n',  log='y', xlab="i", ylab="" )
lines(x_ind,s, col='black')
points(x_ind,abs(utd), pch=1, col='red')
points(x_ind,abs(utd_norm), pch=2, col='blue')

title("Picard Plot for Shaw Problem")




</code></pre>

<hr>
<h2 id='plotconst'>Plot constant model
</h2><span id='topic+plotconst'></span>

<h3>Description</h3>

<p>Plots a model in piecewise constant form over n subintervals,
where n is the length of x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotconst(x, l, r, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotconst_+3A_x">x</code></td>
<td>
<p>model to be plotted
</p>
</td></tr>
<tr><td><code id="plotconst_+3A_l">l</code></td>
<td>
<p>left endpoint of plot
</p>
</td></tr>
<tr><td><code id="plotconst_+3A_r">r</code></td>
<td>
<p>right endpoint of plot
</p>
</td></tr>
<tr><td><code id="plotconst_+3A_...">...</code></td>
<td>
<p>graphical parameters 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used for plotting vector models
</p>


<h3>Value</h3>

<p>graphical side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>linesconst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
zip = runif(25)
plotconst(zip, 0, 1 )
linesconst(runif(25) , 0, 1 , col='red' )



</code></pre>

<hr>
<h2 id='quadlin'>Lagrange multiplier technique
</h2><span id='topic+quadlin'></span>

<h3>Description</h3>

<p>Quadratic Linearization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadlin(Q, A, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quadlin_+3A_q">Q</code></td>
<td>
<p>positive definite symmetric matrix
</p>
</td></tr>
<tr><td><code id="quadlin_+3A_a">A</code></td>
<td>
<p>matrix with linearly independent rows
</p>
</td></tr>
<tr><td><code id="quadlin_+3A_b">b</code></td>
<td>
<p>data vector
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Solves the problem: min (1/2) t(x)*Q*x  with Ax = b.
using the Lagrange multiplier technique, where Q is assumed to be
symmetric and positive definite and the rows of A are linearly
independent.
</p>


<h3>Value</h3>

<p>list:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>vector of solution values</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Lagrange multiplier</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###%    Radius of the Earth (km)
    Re=6370.8;
rad = 5000
ri=rad/Re;

q=c(1.083221147,  1.757951474)
H = matrix(rep(0, 4), ncol=2, nrow=2)

H[1,1]=1.508616069 - 3.520104161*ri + 2.112062496*ri^2;
H[1,2]=3.173750352 - 7.140938293*ri + 4.080536168*ri^2;
H[2,1]=H[1,2];
H[2,2]=7.023621326 - 15.45196692*ri + 8.584426066*ri^2;
A1 =quadlin(H,t(q), 1.0 );


</code></pre>

<hr>
<h2 id='rnk'>Rank of Matrix
</h2><span id='topic+rnk'></span>

<h3>Description</h3>

<p>Return the rank of a matrix.  Not to be confused with the
R function rank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnk(G, tol = 1e-14)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rnk_+3A_g">G</code></td>
<td>
<p>Matrix
</p>
</td></tr>
<tr><td><code id="rnk_+3A_tol">tol</code></td>
<td>
<p>machine tolerance for small numbers
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Number of singular values greater than
tol.
</p>


<h3>Value</h3>

<p>integer, number of non-zero singular values
</p>


<h3>Note</h3>

<p>duplicate the matlab function rank
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>svd
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

hilbert &lt;- function(n) { i &lt;- 1:n; 1 / outer(i - 1, i, "+") }
X &lt;- hilbert(9)[,1:6]
rnk(X)


</code></pre>

<hr>
<h2 id='setDesignG'>Set a Design Matrix.
</h2><span id='topic+setDesignG'></span>

<h3>Description</h3>

<p>Creata design matrix for simulating a
tomographic inversion on a simple grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setDesignG()</code></pre>


<h3>Details</h3>

<p>Set up a simple design matrix
for tomographic in version.  This is used in examples
and illustrations of tomographics and matrix inversion methods. 
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>G = setDesignG()

### show the 56-th row
g = matrix( G[56,] , ncol=16, nrow=16)
imagesc(g)

## Not run: 
### show total coverage
zim = matrix(0 , ncol=16, nrow=16)
for(i in 1:dim(G)[1])
{
g = matrix( G[i,] , ncol=16, nrow=16)
zim =zim + g
}
image(zim)



## End(Not run)

</code></pre>

<hr>
<h2 id='shawG'>Shaw Model of Slit Diffraction
</h2><span id='topic+shawG'></span>

<h3>Description</h3>

<p>Creates the design matrix for the Shaw inverse problem
of diffraction through a narrow slot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shawG(m, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shawG_+3A_m">m</code></td>
<td>
<p>integer, number of rows
</p>
</td></tr>
<tr><td><code id="shawG_+3A_n">n</code></td>
<td>
<p>integern number of columns
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Aster's book for a details explaination.
</p>


<h3>Value</h3>

<p>Matrix used for creating data and inversion.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>C. B. Shaw, Jr., &quot;Improvements of the resolution of 
an instrument by numerical solution of an integral equation&quot;, 
J. Math. Anal. Appl. 37: 83-112, 1972. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 20
G = shawG(n,n)

spike = rep(0,n)
spike[10] = 1

dspiken = G %*%  spike

plot(dspiken)



</code></pre>

<hr>
<h2 id='sirt'>SIRT Algorithm for sparse matrix inversion
</h2><span id='topic+sirt'></span>

<h3>Description</h3>

<p>Row action method for inversion of matrices, using SIRT algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sirt(A, b, tolx, maxiter)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sirt_+3A_a">A</code></td>
<td>
<p>Design Matrix
</p>
</td></tr>
<tr><td><code id="sirt_+3A_b">b</code></td>
<td>
<p>vector, Right hand side
</p>
</td></tr>
<tr><td><code id="sirt_+3A_tolx">tolx</code></td>
<td>
<p>numeric, tolerance for stopping
</p>
</td></tr>
<tr><td><code id="sirt_+3A_maxiter">maxiter</code></td>
<td>
<p>integer, Maximum iterations
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Iterates until conversion
</p>


<h3>Value</h3>

<p>Solution vector
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Lees, J. M. and R. S. Crosson (1989):
Tomographic inversion for three-dimensional velocity structure at Mount St.
Helens using earthquake data, <em>J. Geophys. Res.</em>, 94(B5), 5716-5728.
</p>


<h3>See Also</h3>

<p>art, kac</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2015)
G = setDesignG()
###  Setup the true model.
mtruem=matrix(rep(0, 16*16), ncol=16,nrow=16);

mtruem[9,9]=1; mtruem[9,10]=1; mtruem[9,11]=1;
mtruem[10,9]=1; mtruem[10,11]=1;
mtruem[11,9]=1; mtruem[11,10]=1; mtruem[11,11]=1;
mtruem[2,3]=1; mtruem[2,4]=1;
mtruem[3,3]=1; mtruem[3,4]=1;

###  reshape the true model to be a vector
mtruev=as.vector(mtruem);

###  Compute the data.
dtrue=G %*% mtruev;

###  Add the noise.

d=dtrue+0.01*rnorm(length(dtrue));

msirt&lt;-sirt(G,d,0.01,200)
par(mfrow=c(1,2))
imagesc(matrix(mtruem,16,16) , asp=1 , main="True Model" );

imagesc(matrix(msirt,16,16) , asp=1 , main="SIRT Solution" );

</code></pre>

<hr>
<h2 id='tinv'>
Inverse T-distribution
</h2><span id='topic+tinv'></span>

<h3>Description</h3>

<p>Inverse T-distribution, qt
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tinv(p, nu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tinv_+3A_p">p</code></td>
<td>
<p>P-value
</p>
</td></tr>
<tr><td><code id="tinv_+3A_nu">nu</code></td>
<td>
<p>degrees of freedom
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wrapper for qt
</p>


<h3>Value</h3>

<p>Quantile for T-distribution
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>qt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tinv(.4, 10)


</code></pre>

<hr>
<h2 id='USV'>Singular Value Decomposition
</h2><span id='topic+USV'></span>

<h3>Description</h3>

<p>Singular Value Decomposition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>USV(G)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="USV_+3A_g">G</code></td>
<td>
<p>Matrix
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>returns matrices U, S, V according to
matlab convention.
</p>


<h3>Value</h3>

<p>list:
</p>
<table role = "presentation">
<tr><td><code>U</code></td>
<td>
<p>Matrix</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>Matrix, singular values</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>svd
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 hilbert &lt;- function(n) { i &lt;- 1:n; 1 / outer(i - 1, i, "+") }
     X &lt;- hilbert(9)[,1:6]
     
h = USV(X)

print( h$U )


</code></pre>

<hr>
<h2 id='Vnorm'>Vector 2-Norm
</h2><span id='topic+Vnorm'></span>

<h3>Description</h3>

<p>Vector 2-Norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Vnorm(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Vnorm_+3A_x">X</code></td>
<td>

<p>numeric vector
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric scale norm
</p>


<h3>Note</h3>

<p>This function is intended to duplicated the
matlab function norm.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
V = Vnorm(rnorm(10))


</code></pre>

<hr>
<h2 id='vspprofile'>Vertical Seismic Profile In 1D
</h2><span id='topic+vspprofile'></span>

<h3>Description</h3>

<p>Example vertical 1-dimensional seismic profile
used for setting up examples for inverse theory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vspprofile(M = 50, N = 50, maxdepth = 1000, deltobs = 20,
noise = 2e-04, M1 = c(9000, -6, 0.001))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vspprofile_+3A_m">M</code></td>
<td>
<p>integer, number of rows in in design matrix G, default=50
</p>
</td></tr>
<tr><td><code id="vspprofile_+3A_n">N</code></td>
<td>
<p>integer, number of columns in design matrix G, default=50
</p>
</td></tr>
<tr><td><code id="vspprofile_+3A_maxdepth">maxdepth</code></td>
<td>
<p>Maximum depth of model, default = 1000
</p>
</td></tr>
<tr><td><code id="vspprofile_+3A_deltobs">deltobs</code></td>
<td>
<p>integer, sampling interval in depth, default=20
</p>
</td></tr>
<tr><td><code id="vspprofile_+3A_noise">noise</code></td>
<td>
<p>gausian noise multiplier, default=2e-04
</p>
</td></tr>
<tr><td><code id="vspprofile_+3A_m1">M1</code></td>
<td>
<p>3-vector, linear model for velocity versus depth model
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vertical seismic profile in 1D dimension used for setting up examples in PEIP.
Given a simple velocity profile, defined by input parameter M1
create the travel times and designe matrix used for solving an inverse problem. The
velocity model is defined as depth versus velocity, and the function inverts that
from the slowness.  Any model could be used to replace this model.  The default model
here is taken from an inversion in the Aster book.
</p>


<h3>Value</h3>

<p>list:
</p>
<table role = "presentation">
<tr><td><code>G</code></td>
<td>
<p>M by N design matrix</p>
</td></tr>
<tr><td><code>tee</code></td>
<td>
<p>true travel times from model</p>
</td></tr>
<tr><td><code>t2</code></td>
<td>
<p>travel times with noise added</p>
</td></tr>
<tr><td><code>depth</code></td>
<td>
<p>depth samples of model</p>
</td></tr>
<tr><td><code>vee</code></td>
<td>
<p>velocity at the depths indicated</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>input M</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>input N</p>
</td></tr>
<tr><td><code>maxdepth</code></td>
<td>
<p>input maxdepth</p>
</td></tr>
<tr><td><code>deltobs</code></td>
<td>
<p>input delta observation</p>
</td></tr>
<tr><td><code>noise</code></td>
<td>
<p>input noise</p>
</td></tr>
<tr><td><code>M1</code></td>
<td>
<p>True model used for depth versus velocity</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Aster, R.C., C.H. Thurber, and B. Borchers,
<em>Parameter Estimation and Inverse Problems</em>, Elsevier Academic Press, Amsterdam, 2005.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
V = vspprofile()
### plot quadratic velocity profile
plot(V$vee, -V$depth, main="VSP: velocity increasing with depth")
dobs = seq(from=V$deltobs, to=V$maxdepth, by=V$deltobs)
### plotdepth versus time (not linear)
plot(dobs, V$t2)
abline(lm(V$t2 ~ dobs) )


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
