<!DOCTYPE html><html lang="en"><head><title>Help for package LPGraph</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LPGraph}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#LPGraph-package'>
<p>Nonparametric Smoothing of Laplacian Graph Spectra</p></a></li>
<li><a href='#LP.basis'>
<p>Computes LP basis function of a discrete distribution</p></a></li>
<li><a href='#LP.struct.test'>
<p>Detection of structures in an ordered-network.</p></a></li>
<li><a href='#LPSpectral'>
<p>Nonparametric smooth approximation of the Laplacian graph spectra</p></a></li>
<li><a href='#senate'><p>Senate Vote Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Nonparametric Smoothing of Laplacian Graph Spectra</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-01-29</td>
</tr>
<tr>
<td>Author:</td>
<td>Subhadeep Mukhopadhyay, Kaijun Wang</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kaijun Wang &lt;kaijun.wang@temple.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A nonparametric method to approximate Laplacian graph spectra of a network with 
    ordered vertices. This provides a computationally efficient algorithm for obtaining an 
	accurate and smooth estimate of the graph Laplacian basis. The approximation results can 
	then be used for tasks like change point detection, k-sample testing, and so on. The 
	primary reference is Mukhopadhyay, S. and Wang, K. (2018, Technical Report).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), stats, car, PMA</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-01-30 05:34:33 UTC; AquinasUnit</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-01-30 20:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='LPGraph-package'>
Nonparametric Smoothing of Laplacian Graph Spectra
</h2><span id='topic+LPGraph-package'></span><span id='topic+LPGraph'></span>

<h3>Description</h3>

<p>This package provides an algorithm to approximate and smooth the Laplacian graph spectra of a network with ordered vertices using LP-nonparametric basis. The underlying theory yields a reduced order (compressive) characterization of spectral graph properties.
</p>


<h3>Author(s)</h3>

<p>Mukhopadhyay, S. and Wang, K.
</p>
<p>Maintainer: Kaijun Wang &lt;kaijun.wang@temple.edu&gt;
</p>


<h3>References</h3>

<p>Mukhopadhyay, S. and Wang, K. (2018), &quot;Graph Spectral Compression via Smoothing&quot;.
</p>
<p>Mukhopadhyay, S. (2017+), &quot;Unified Statistical Theory of Spectral Graph Analysis&quot;.
</p>
<p>Mukhopadhyay, S. and Parzen, E. (2014), &quot;LP Approach to Statistical Modeling&quot;, arXiv:1405.2601.
</p>

<hr>
<h2 id='LP.basis'>
Computes LP basis function of a discrete distribution
</h2><span id='topic+LP.basis'></span><span id='topic+wt.mean'></span>

<h3>Description</h3>

<p>This function computes <code>m</code> LP basis functions for the given discrete distribution <code>p.dist</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LP.basis(p.dist, m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LP.basis_+3A_p.dist">p.dist</code></td>
<td>
<p> A vector of <code class="reqn">n</code> probabilities of a discrete distribution </p>
</td></tr>
<tr><td><code id="LP.basis_+3A_m">m</code></td>
<td>
<p> An integer denoting the number of required LP basis functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of dimension <code class="reqn">n\times m</code>.
</p>


<h3>Author(s)</h3>

<p> Mukhopadhyay, S. and Wang, K.</p>


<h3>References</h3>

<p>Mukhopadhyay, S. and Parzen, E. (2014), &quot;LP Approach to Statistical Modeling&quot;, arXiv:1405.2601.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   ##1.toy example:
   ##simulate a two sample locational difference normal data:
    X1&lt;-matrix(rnorm(250,mean=0,sd=1),10,25)
    X2&lt;-matrix(rnorm(250,mean=0.5,sd=1),10,25)
    X&lt;-rbind(X1,X2)
   ## Adjacency matrix:
    dmat&lt;-dist(X)
    W   &lt;-exp(-as.matrix(dmat)^2/(2*quantile(dmat,.5)^2))
   ## getting the basis
    pp&lt;- rowSums(W)/sum(W)
    T&lt;-LP.basis(pp,m=4)
   #plot the j-th LP basis for the two sample data (here we use j=1).
    j=1
    plot(cumsum(pp),T[,j],type='s',xlab='',ylab='')

   ##2.Senate data
   ## Not run: 
    data(senate)
    attach(senate)
   #create W matrix: (long computation)
    require(psych)
    W &lt;- matrix(0,nrow(X),nrow(X))
    for(i in 1:(nrow(X)-1)){
	for(j in (i+1):nrow(X)) { 
		W[i,j] &lt;- psych::phi(table(X[i,],X[j,])) 
	}
    }
    W = W + t(W)
    diag(W)&lt;-0
   #getting the basis:
    pp&lt;- rowSums(W)/sum(W)
    T&lt;-LP.basis(pp,m=4)
   #plot the j-th LP basis for senate data (here we use j=1).
    j=1
    plot(cumsum(pp),T[,j],type='s',xlab='',ylab='')
   
## End(Not run)
</code></pre>

<hr>
<h2 id='LP.struct.test'>
Detection of structures in an ordered-network.
</h2><span id='topic+LP.struct.test'></span><span id='topic+Laplacian'></span>

<h3>Description</h3>

<p>Given adjacency matrix <code>W</code>, this function perform a graph based test to determine whether there are different communities present in a graph of ordered vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LP.struct.test(W, m = NULL, n.iter = 50)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LP.struct.test_+3A_w">W</code></td>
<td>
<p> A <code class="reqn">n</code>-by-<code class="reqn">n</code> weighted-adjacency matrix. </p>
</td></tr>
<tr><td><code id="LP.struct.test_+3A_m">m</code></td>
<td>
<p> Number of LP-nonparametric basis used for generating the test statistic, set to <code>NULL</code> to use original Laplacian. </p>
</td></tr>
<tr><td><code id="LP.struct.test_+3A_n.iter">n.iter</code></td>
<td>
<p> Iterations used for small sample correction, default is <code class="reqn">50</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following items:
</p>
<table role = "presentation">
<tr><td><code>stat</code></td>
<td>
<p>The test statistic, which asymptotically follows a normal distribution with mean and variance mentioned in the reference.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>P-value for the test, small p-value means different communities may be present.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Mukhopadhyay, S. and Wang, K.</p>


<h3>References</h3>

<p>Mukhopadhyay, S. and Wang, K. (2018), &quot;Graph Spectral Compression via Smoothing&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ##1.example: null case
   ##simulate a normal data with mean 0 and variance 1:
    X  &lt;-matrix(rnorm(500,mean=0,sd=1),20,25)
   ## Generate adjacency matrix:
    dmat&lt;-dist(X)
    W   &lt;-exp(-as.matrix(dmat)^2/(2*quantile(dmat,.5)^2))
   ## test of structure:
    h0.test&lt;-LP.struct.test(W, m = 4 , n.iter = 50)
   ###extract p-value:
    h0.test$pval

   ##2.example: two sample location alternative
   ##simulate a two sample locational difference normal data:
    X1&lt;-matrix(rnorm(250,mean=0,sd=1),10,25)
    X2&lt;-matrix(rnorm(250,mean=0.5,sd=1),10,25)
    X&lt;-rbind(X1,X2)
   ## Generate adjacency matrix:
    dmat&lt;-dist(X)
    W   &lt;-exp(-as.matrix(dmat)^2/(2*quantile(dmat,.5)^2))
   ## test of structure:
    h1.test&lt;-LP.struct.test(W, m = 4 , n.iter = 50)
   ###extract p-value:
    h1.test$pval
</code></pre>

<hr>
<h2 id='LPSpectral'>
Nonparametric smooth approximation of the Laplacian graph spectra
</h2><span id='topic+LPSpectral'></span>

<h3>Description</h3>

<p>This function provides nonparametric smooth approximation of the Laplacian graph spectra given a weighted-adjacency matrix <code class="reqn">W</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LPSpectral(W, k, m=8,sparse=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LPSpectral_+3A_w">W</code></td>
<td>
<p> A <code class="reqn">n</code>-by-<code class="reqn">n</code> weighted-adjacency matrix. </p>
</td></tr>
<tr><td><code id="LPSpectral_+3A_k">k</code></td>
<td>
<p> Number of approximated singular vectors and singular values to return, where <code class="reqn">k \leq m</code>.</p>
</td></tr>
<tr><td><code id="LPSpectral_+3A_m">m</code></td>
<td>
<p> Number of LP-nonparametric basis used for approximation, where <code class="reqn">m \leq n</code>. By default, <code class="reqn">m=8</code>. </p>
</td></tr>
<tr><td><code id="LPSpectral_+3A_sparse">sparse</code></td>
<td>
<p> Set to <code>TRUE</code> to make coefficients for LP basis sparse, thus allowing for further smoothing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following items:
</p>
<table role = "presentation">
<tr><td><code>LP</code></td>
<td>
<p><code class="reqn">m</code>-by-<code class="reqn">m</code> LP Spectral graph matrix.</p>
</td></tr>
<tr><td><code>Phi</code></td>
<td>
<p>A <code class="reqn">n</code>-by-<code class="reqn">k</code> matrix of LP-approximated singular vectors.</p>
</td></tr>
<tr><td><code>sval</code></td>
<td>
<p>A vector of length <code class="reqn">k</code> containing top k approximated singular values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Mukhopadhyay, S. and Wang, K.</p>


<h3>References</h3>

<p>Mukhopadhyay, S. and Wang, K. (2018), &quot;Graph Spectral Compression via Smoothing&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   ##1.toy example:
   ##simulate a two sample locational difference normal data:
    X1&lt;-matrix(rnorm(250,mean=0,sd=1),10,25)
    X2&lt;-matrix(rnorm(250,mean=0.5,sd=1),10,25)
    X&lt;-rbind(X1,X2)
   ## Adjacency matrix:
    dmat&lt;-dist(X)
    W &lt;-exp(-as.matrix(dmat)^2/(2*quantile(dmat,.5)^2))
   ## Obtain top 10 approximated nontrivial singular values:
    data_sval&lt;-LPSpectral(W, k=10)$sval
   ## Obtain approximated singular vector corresponding to the top nontrivial singular value:   
    data_phi1&lt;-LPSpectral(W, k=1)$Phi
   ## plot the results:
    par(mfrow=c(1,2))
    plot(data_sval,type='b')
    plot(data_phi1)

   ##2.Senate Data
  ## Not run: 
    data(senate)
    attach(senate)
   ##creating W (long computation)
    require(psych)
    W &lt;- matrix(0,nrow(X),nrow(X))
    for(i in 1:(nrow(X)-1)){
	for(j in (i+1):nrow(X)) { 
		W[i,j] &lt;- psych::phi(table(X[i,],X[j,])) 
	}
    }
    W = W + t(W)
    diag(W)&lt;-0
   ## Obtain top 10 approximated nontrivial singular values:
    senate_sval&lt;-LPSpectral(W, k=10, m=15)$sval
   ## Obtain approximated singular vector corresponding to the top nontrivial singular value:   
    senate_phi1&lt;-LPSpectral(W, k=1, m=15)$Phi
   ## plot the results:
    par(mfrow=c(1,2))
    plot(senate_sval,type='b')
    plot(senate_phi1)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='senate'>Senate Vote Data</h2><span id='topic+senate'></span>

<h3>Description</h3>

<p>The senate vote data contain 2508 observations ordered by time from 1989 to 2001, with a dimension of 100. 
The change point occurred on January 17th, 1995, at the beginning of the tenure of the 104th Congress when the Republican Party captured the US House of Representatives for the first time after 1956.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("senate")</code></pre>


<h3>Format</h3>

<p>A list containing the following items:
</p>

<dl>
<dt><code>year</code>:</dt><dd><p>A vector of length 2508, time labels.</p>
</dd>
<dt><code>X</code>   :</dt><dd><p>A matrix of dimension 2508 by 100, original data of senate votes.</p>
</dd>
</dl>



<h3>Details</h3>

<p>To generate the weighted adjacency matrix <code>W</code>, one simple take the matrix <code>X</code> and Compute:
<code class="reqn">
       W_{ij}=\phi(X_i,X_j)=\frac{p_{00}-p_{+0}p_{0+}}{\sqrt{p_{0+}p_{1+}p_{+0}p_{+1}}}
     </code>
Where <code class="reqn">p_{rs}=\sum_i\sum_j I(X_i=r,X_j=s), r\in \{0,1\}; s \in \{0,1\}</code>. And <code class="reqn">p_{+s}=\sum_r p_{rs}; \  p_{r+}=\sum_s p_{rs}</code>.
See the examples in main function <code>LPSpectral</code> for the codes.
</p>


<h3>References</h3>

<p>Roy, S., Atchade, Y., and Michailidis, G. (2017). &quot;Change point estimation in high dimensional Markov random-field models&quot;. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 79(4), 1187-1206.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
