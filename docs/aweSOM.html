<!DOCTYPE html><html lang="en"><head><title>Help for package aweSOM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {aweSOM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aweSOM-package'><p>Interactive Self-Organizing Maps</p></a></li>
<li><a href='#aweSOM'><p>aweSOM interface</p></a></li>
<li><a href='#aweSOMdendrogram'><p>Dendogram of hierarchical clustering of SOM cells</p></a></li>
<li><a href='#aweSOMplot'><p>Interactive SOM plots</p></a></li>
<li><a href='#aweSOMreorder'><p>Reorder variables for SOM plot</p></a></li>
<li><a href='#aweSOMscreeplot'><p>Screeplot of SOM superclasses</p></a></li>
<li><a href='#aweSOMsilhouette'><p>Silhouette plot of SOM superclasses</p></a></li>
<li><a href='#aweSOMsmoothdist'><p>Smooth Distance Plot for SOM</p></a></li>
<li><a href='#cdt'><p>Complete disjunctive table</p></a></li>
<li><a href='#somDist'><p>Distance measures on a SOM</p></a></li>
<li><a href='#somInit'><p>Initialize SOM prototypes</p></a></li>
<li><a href='#somQuality'><p>SOM quality measures</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Interactive Self-Organizing Maps</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-30</td>
</tr>
<tr>
<td>Description:</td>
<td>Self-organizing maps (also known as SOM, see Kohonen (2001) &lt;<a href="https://doi.org/10.1007%2F978-3-642-56927-2">doi:10.1007/978-3-642-56927-2</a>&gt;) are a method for dimensionality reduction and clustering of continuous data. This package introduces interactive (html) graphics for easier analysis of SOM results. It also features an interactive interface, for push-button training and visualization of SOM on numeric, categorical or mixed data, as well as tools to evaluate the quality of SOM.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>kohonen (&ge; 2.0), shiny (&ge; 1.6), htmlwidgets, bslib,
rmarkdown, htmltools, rclipboard, ggplot2, RColorBrewer,
viridis, data.table, DT, kernlab, fields, stats, cluster,
e1071, haven, foreign, readxl, readODS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-30 15:07:15 UTC; bart</td>
</tr>
<tr>
<td>Author:</td>
<td>Julien Boelaert [aut, cre],
  Etienne Ollion [aut],
  Jan Sodoge [aut],
  Mohamed Megdoud [ctb],
  Otmane Naji [ctb],
  Arnaud Lemba Kote [ctb],
  Theo Renoud [ctb],
  Samuel Hym [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Julien Boelaert &lt;julien.boelaert@univ-lille.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-30 15:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aweSOM-package'>Interactive Self-Organizing Maps</h2><span id='topic+aweSOM-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" alt='logo' />
Interactive plots and interface for Kohonen self-organizing maps.
</p>


<h3>References</h3>

<p>Kohonen T. (2001) <em>Self-Organizing Maps</em>, 3rd edition,
Springer Press, Berlin. &lt;doi:10.1007/978-3-642-56927-2&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aweSOM">aweSOM</a></code>, <code><a href="#topic+aweSOMplot">aweSOMplot</a></code>,
<code><a href="#topic+somInit">somInit</a></code>, <code><a href="#topic+somQuality">somQuality</a></code>.
</p>

<hr>
<h2 id='aweSOM'>aweSOM interface</h2><span id='topic+aweSOM'></span>

<h3>Description</h3>

<p>Launches the (offline) web-based interface for training and visualizing
self-organizing maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aweSOM()
</code></pre>


<h3>Details</h3>

<p>If the interface does not open automatically, open the printed link
in a web browser.
</p>
<p>To open large files within the interface, use
<code>options(shiny.maxRequestSize=2^30)</code> (or a suitably large file size)
before lauching the interface.
</p>


<h3>Value</h3>

<p>No return value, used for side effects.
</p>


<h3>References</h3>

<p>Kohonen T. (2001) <em>Self-Organizing Maps</em>, 3rd edition,
Springer Press, Berlin. &lt;doi:10.1007/978-3-642-56927-2&gt;
</p>

<hr>
<h2 id='aweSOMdendrogram'>Dendogram of hierarchical clustering of SOM cells</h2><span id='topic+aweSOMdendrogram'></span>

<h3>Description</h3>

<p>Plots the dendogram of a hierarchical clustering of the SOM prototypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aweSOMdendrogram(clust, nclass)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aweSOMdendrogram_+3A_clust">clust</code></td>
<td>
<p>an object of class <code>hclust</code>, the result of a hierarchical
clustering performed by <code>stats::hclust</code>.</p>
</td></tr>
<tr><td><code id="aweSOMdendrogram_+3A_nclass">nclass</code></td>
<td>
<p>an integer, number of superclasses</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>NULL</code> if <code>nclass</code> is 1, or else a <code>list</code>
containing the indices of the SOM cells in each superclass.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Build training data
dat &lt;- iris[, c("Sepal.Length", "Sepal.Width", "Petal.Length", "Petal.Width")]
### Scale training data
dat &lt;- scale(dat)
## Train SOM
### Initialization (PCA grid)
init &lt;- somInit(dat, 4, 4)
ok.som &lt;- kohonen::som(dat, grid = kohonen::somgrid(4, 4, 'hexagonal'),
                       rlen = 100, alpha = c(0.05, 0.01),
                       radius = c(2.65,-2.65),
                       init = init, dist.fcts = 'sumofsquares')
## Group cells into superclasses (hierarchical clustering)
superclust &lt;- hclust(dist(ok.som$codes[[1]]), 'complete')
## Plot superclasses dendrogram
aweSOMdendrogram(superclust, 2)
</code></pre>

<hr>
<h2 id='aweSOMplot'>Interactive SOM plots</h2><span id='topic+aweSOMplot'></span>

<h3>Description</h3>

<p>Plot interactive visualizations of self-organizing maps (SOM), as an html
page. The plot can represent general map informations, or selected
categorical or numeric variables (not necessarily the ones used during
training). Hover over the map to focus on the selected cell or variable, and
display further information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aweSOMplot(
  som,
  type = c("Hitmap", "Cloud", "UMatrix", "Circular", "Barplot", "Boxplot", "Radar",
    "Line", "Color", "Pie", "CatBarplot"),
  data = NULL,
  variables = NULL,
  superclass = NULL,
  obsNames = NULL,
  scales = c("contrast", "range", "same"),
  values = c("mean", "median", "prototypes"),
  size = 400,
  palsc = c("Set3", "viridis", "grey", "rainbow", "heat", "terrain", "topo", "cm",
    rownames(RColorBrewer::brewer.pal.info)),
  palvar = c("viridis", "grey", "rainbow", "heat", "terrain", "topo", "cm",
    rownames(RColorBrewer::brewer.pal.info)),
  palrev = FALSE,
  showAxes = TRUE,
  transparency = TRUE,
  boxOutliers = TRUE,
  showSC = TRUE,
  pieEqualSize = FALSE,
  showNames = TRUE,
  legendPos = c("beside", "below", "none"),
  legendFontsize = 14,
  cloudType = c("cellPCA", "kPCA", "PCA", "proximity", "random"),
  cloudSeed = NA,
  elementId = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aweSOMplot_+3A_som">som</code></td>
<td>
<p><code>kohonen</code> object, a SOM created by the <code>kohonen::som</code> function.</p>
</td></tr>
<tr><td><code id="aweSOMplot_+3A_type">type</code></td>
<td>
<p>character, the plot type. The default &quot;Hitmap&quot; is a population
map. &quot;Cloud&quot; plots the observations as a scatterplot within each cell (see
Details). &quot;UMatrix&quot; plots the average distance of each cell to its
neighbors, on a color scale. &quot;Circular&quot; (barplot), &quot;Barplot&quot;, &quot;Boxplot&quot;,
&quot;Radar&quot; and &quot;Line&quot; are for numeric variables. &quot;Color&quot; (heat map) is for a
single numeric variable. &quot;Pie&quot; (pie chart) and &quot;CatBarplot&quot; are for a
single categorical (factor) variable.</p>
</td></tr>
<tr><td><code id="aweSOMplot_+3A_data">data</code></td>
<td>
<p>data.frame containing the variables to plot. This is typically
not the training data, but rather the unscaled original data, as it is
easier to read the results in the original units, and this allows to plot
extra variables not used in training. If not provided, the training data is
used.</p>
</td></tr>
<tr><td><code id="aweSOMplot_+3A_variables">variables</code></td>
<td>
<p>character vector containing the names of the variable(s) to
plot. See Details.</p>
</td></tr>
<tr><td><code id="aweSOMplot_+3A_superclass">superclass</code></td>
<td>
<p>integer vector, the superclass of each cell of the SOM.</p>
</td></tr>
<tr><td><code id="aweSOMplot_+3A_obsnames">obsNames</code></td>
<td>
<p>character vector, names of the observations to be displayed
when hovering over the cells of the SOM. Must have a length equal to the
number of data rows. If not provided, the row names of data will be used.</p>
</td></tr>
<tr><td><code id="aweSOMplot_+3A_scales">scales</code></td>
<td>
<p>character, controls the scaling of the variables on the plot.
See Details.</p>
</td></tr>
<tr><td><code id="aweSOMplot_+3A_values">values</code></td>
<td>
<p>character, the type of value to be displayed. The default
&quot;mean&quot; uses the observation means (from data) for each cell. Alternatively,
&quot;median&quot; uses the observation medians for each cell, and &quot;prototypes&quot; uses
the SOM's prototypes values.</p>
</td></tr>
<tr><td><code id="aweSOMplot_+3A_size">size</code></td>
<td>
<p>numeric, plot size, in pixels. Default 400.</p>
</td></tr>
<tr><td><code id="aweSOMplot_+3A_palsc">palsc</code></td>
<td>
<p>character, the color palette used to represent the superclasses
as background of the cells. Default is &quot;Set3&quot;. Can be &quot;viridis&quot;, &quot;grey&quot;,
&quot;rainbow&quot;, &quot;heat&quot;, &quot;terrain&quot;, &quot;topo&quot;, &quot;cm&quot;, or any palette name of the
RColorBrewer package.</p>
</td></tr>
<tr><td><code id="aweSOMplot_+3A_palvar">palvar</code></td>
<td>
<p>character, the color palette used to represent the variables.
Default is &quot;viridis&quot;, available choices are the same as for palsc.</p>
</td></tr>
<tr><td><code id="aweSOMplot_+3A_palrev">palrev</code></td>
<td>
<p>logical, whether color palette for variables is reversed.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="aweSOMplot_+3A_showaxes">showAxes</code></td>
<td>
<p>logical, whether to display the axes (for &quot;Circular&quot;,
&quot;Barplot&quot;, &quot;Boxplot&quot;, &quot;Star&quot;, &quot;Line&quot;, &quot;CatBarplot&quot;), default TRUE.</p>
</td></tr>
<tr><td><code id="aweSOMplot_+3A_transparency">transparency</code></td>
<td>
<p>logical, whether to use transparency when focusing on a
variable, default TRUE.</p>
</td></tr>
<tr><td><code id="aweSOMplot_+3A_boxoutliers">boxOutliers</code></td>
<td>
<p>logical, whether outliers in &quot;Boxplot&quot; are displayed,
default TRUE.</p>
</td></tr>
<tr><td><code id="aweSOMplot_+3A_showsc">showSC</code></td>
<td>
<p>logical, whether to display superclasses as labels in the
&quot;Color&quot; and &quot;UMatrix&quot; plots, default TRUE.</p>
</td></tr>
<tr><td><code id="aweSOMplot_+3A_pieequalsize">pieEqualSize</code></td>
<td>
<p>logical, whether &quot;Pie&quot; should display pies of equal size.
The default FALSE displays pies with areas proportional to the number of
observations in the cells.</p>
</td></tr>
<tr><td><code id="aweSOMplot_+3A_shownames">showNames</code></td>
<td>
<p>logical, whether to display the observations names in a box
below the plot.</p>
</td></tr>
<tr><td><code id="aweSOMplot_+3A_legendpos">legendPos</code></td>
<td>
<p>character, whether and where to display the legend (if
applicable). Possible values are &quot;beside&quot;, &quot;below&quot; or &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="aweSOMplot_+3A_legendfontsize">legendFontsize</code></td>
<td>
<p>numeric, font size to use for the legend, and for the
tooltip information of the &quot;Cloud&quot; plot. Default is 14.</p>
</td></tr>
<tr><td><code id="aweSOMplot_+3A_cloudtype">cloudType</code></td>
<td>
<p>character, for &quot;Cloud&quot; type, controls how the point
coordinates are computed, see Details.</p>
</td></tr>
<tr><td><code id="aweSOMplot_+3A_cloudseed">cloudSeed</code></td>
<td>
<p>numeric, for &quot;random Cloud&quot; type, seed for the pseudo-random
placement of the points. If NA (the default), no seed will be set.</p>
</td></tr>
<tr><td><code id="aweSOMplot_+3A_elementid">elementId</code></td>
<td>
<p>character, user-defined elementId of the widget. Can be
useful for user extensions when embedding the result in an html page.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The selected <code>variables</code> must be numeric for types &quot;Circular&quot;,
&quot;Barplot&quot;, &quot;Boxplot&quot;, &quot;Radar&quot;, &quot;Color&quot; and &quot;Line&quot;, or factor for types
&quot;Pie&quot; and &quot;CatBarplot&quot;. If not provided, all columns of data will be
selected. If a numeric variable is provided to a &quot;Cloud&quot;, &quot;Pie&quot; or
&quot;CatBarplot&quot;, it will be split into a maximum of 8 classes. For &quot;Cloud&quot;
plots, the first element of <code>variables</code> is used to color the points
(and can be &quot;None&quot; for no coloring), the following elements (if any) are
used in the information box of each point.
</p>
<p>Variables scales: All values that are used for the plots (means,
medians, prototypes) are scaled to 0-1 for display (minimum height to
maximum height). The <code>scales</code> parameter controls how this scaling is
done.
</p>

<ul>
<li><p>&quot;contrast&quot;: for each variable, the minimum height is the minimum
observed mean/median/prototype on the map, the maximum height is the maximum
on the map. This ensures maximal contrast on the plot.
</p>
</li>
<li><p>&quot;range&quot;: observation range; for each variable, the minimum height
corresponds to the minimum of that variable over the whole dataset, the
maximum height to the maximum of the variable on the whole dataset.
</p>
</li>
<li><p>&quot;same&quot;: same scales; all heights are displayed on the same scale,
using the global minimum and maximum of the dataset.
</p>
</li></ul>

<p>Cloud plot: three types of cloud plots are available, controlled by the
<code>cloudType</code> argument:
</p>

<ul>
<li><p>&quot;cellPCA&quot;: (default) the point coordinates are computed cell by cell,
by computing a PCA on the training data of that cell only. Points close to
the center of the cell are close to the mean of its observations. Points far
apart within a cell are likely to have different characteristics.
</p>
</li>
<li><p>&quot;kPCA&quot;: the point coordinates are computed globally, by a kernel PCA
performed on all the differences between the training data and their winning
prototypes. Points close to the center of their cell are close to their
prototype, and points with similar placements in the clouds thus have a
similar difference to their prototype. Not recommended for large datasets
(eg. &gt; 1000 observations), as it tends to take too much memory.
</p>
</li>
<li><p>&quot;PCA&quot;: the point coordinates are computed globally, by a PCA
performed on all the differences between the training data and their winning
prototypes. Points close to the center of their cell are close to their
prototype, and points with similar placements in the clouds thus have a
similar difference to their prototype.
</p>
</li>
<li><p>&quot;proximity&quot;: the point coordinates are computed one by one, based on
the distances of the observation's training data to its cell's prototype and
to its second best matching prototypes among its cell's neighbors. Points
close to their cell's center are close to their closest prototype, while
points close to another cell are close to that cell's prototype.
</p>
</li>
<li><p>&quot;random&quot;: the point coordinates are random samples from a uniform
distribution.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns an object of class <code>htmlwidget</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Build training data
dat &lt;- iris[, c("Sepal.Length", "Sepal.Width", "Petal.Length", "Petal.Width")]
### Scale training data
dat &lt;- scale(dat)
## Train SOM
### Initialization (PCA grid)
init &lt;- somInit(dat, 4, 4)
ok.som &lt;- kohonen::som(dat, grid = kohonen::somgrid(4, 4, 'hexagonal'),
                       rlen = 100, alpha = c(0.05, 0.01),
                       radius = c(2.65,-2.65), init = init,
                       dist.fcts = 'sumofsquares')
## Group cells into superclasses (PAM clustering)
superclust &lt;- cluster::pam(ok.som$codes[[1]], 2)
superclasses &lt;- superclust$clustering

## Observations cloud ('Cloud')
variables &lt;- c("Sepal.Length", "Sepal.Width",  "Petal.Length", "Petal.Width")
aweSOMplot(som = ok.som, type = 'Cloud', data = iris, 
           variables = c("Species", variables), superclass = superclasses)

## Not run: 
## Population map ('Hitmap')
aweSOMplot(som = ok.som, type = 'Hitmap', superclass = superclasses)

## Plots for numerical variables
## Circular barplot
aweSOMplot(som = ok.som, type = 'Circular', data = iris,
           variables= variables, superclass = superclasses)
## Barplot (numeric variables)
aweSOMplot(som = ok.som, type = 'Barplot', data = iris,
           variables= variables, superclass = superclasses)

## Plots for categorial variables (iris species, not used for training)
## Pie
aweSOMplot(som = ok.som, type = 'Pie', data = iris,
           variables= "Species", superclass = superclasses)
## Barplot (categorical variables)
aweSOMplot(som = ok.som, type = 'CatBarplot', data = iris,
           variables= "Species", superclass = superclasses)

## End(Not run)
</code></pre>

<hr>
<h2 id='aweSOMreorder'>Reorder variables for SOM plot</h2><span id='topic+aweSOMreorder'></span>

<h3>Description</h3>

<p>Reorders a set of variables for prettier display on SOM plots. Variables that
have similar variations along the cell plots while be ordered close together.
Reordering is computed from the first component of a kernel PCA performed on
the matrix of displayed values (with the variables as rows, and the cells as
columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aweSOMreorder(
  som,
  data = NULL,
  variables = NULL,
  scales = c("contrast", "range", "same"),
  values = c("mean", "median", "prototypes")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aweSOMreorder_+3A_som">som</code></td>
<td>
<p><code>kohonen</code> object, a SOM created by the <code>kohonen::som</code>
function.</p>
</td></tr>
<tr><td><code id="aweSOMreorder_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing the variables to plot. This is
typically not the training data, but rather the unscaled original data, as
it is easier to read the results in the original units, and this allows to
plot extra variables not used in training. If not provided, the training
data is used.</p>
</td></tr>
<tr><td><code id="aweSOMreorder_+3A_variables">variables</code></td>
<td>
<p>character vector containing the names of the variables to
plot. If not provided, all columns of data will be selected. All variables
must be numeric.</p>
</td></tr>
<tr><td><code id="aweSOMreorder_+3A_scales">scales</code></td>
<td>
<p>character, controls the scaling of the variables on the plot.
The default &quot;constrast&quot; maximizes the displayed contrast by scaling the
displayed heights of each variable from minimum to maximum of the displayed
value. Alternatively, &quot;range&quot; uses the minimum and maximum of the
observations for each variable, and &quot;same&quot; displays all variables on the
same scale, using the global minimum and maximum of the data.</p>
</td></tr>
<tr><td><code id="aweSOMreorder_+3A_values">values</code></td>
<td>
<p>character, the type of value to be displayed. The default
&quot;mean&quot; uses the observation means (from data) for each cell. Alternatively,
&quot;median&quot; uses the observation medians for each cell, and &quot;prototypes&quot; uses
the SOM's prototypes values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character vector containing the reordered variables names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Build training data
dat &lt;- iris[, c("Sepal.Length", "Sepal.Width", "Petal.Length", "Petal.Width")]
### Scale training data
dat &lt;- scale(dat)
## Train SOM
### Initialization (PCA grid)
init &lt;- somInit(dat, 4, 4)
ok.som &lt;- kohonen::som(dat, grid = kohonen::somgrid(4, 4, 'hexagonal'),
                       rlen = 100, alpha = c(0.05, 0.01),
                       radius = c(2.65,-2.65), init = init,
                       dist.fcts = 'sumofsquares')
## Reorder variables
ordered.vars &lt;- aweSOMreorder(ok.som)
## Not run: 
## Plot with reordered variables
aweSOMplot(som = ok.som, type = 'Circular', data = iris,
           variables= ordered.vars)

## End(Not run)
</code></pre>

<hr>
<h2 id='aweSOMscreeplot'>Screeplot of SOM superclasses</h2><span id='topic+aweSOMscreeplot'></span>

<h3>Description</h3>

<p>The screeplot, helps deciding the optimal number of superclasses. Available
for both PAM and hierarchical clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aweSOMscreeplot(
  som,
  nclass = 2,
  method = c("hierarchical", "pam"),
  hmethod = c("complete", "ward.D2", "ward.D", "single", "average", "mcquitty", "median",
    "centroid")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aweSOMscreeplot_+3A_som">som</code></td>
<td>
<p><code>kohonen</code> object, a SOM created by the <code>kohonen::som</code>
function.</p>
</td></tr>
<tr><td><code id="aweSOMscreeplot_+3A_nclass">nclass</code></td>
<td>
<p>number of superclasses to be visualized in the screeplot.
Default is 2.</p>
</td></tr>
<tr><td><code id="aweSOMscreeplot_+3A_method">method</code></td>
<td>
<p>Method used for clustering. Hierarchical clustering
(&quot;hierarchical&quot;) and Partitioning around medoids (&quot;pam&quot;) can be used.
Default is hierarchical clustering.</p>
</td></tr>
<tr><td><code id="aweSOMscreeplot_+3A_hmethod">hmethod</code></td>
<td>
<p>For hierarchicical clustering, the clustering method, by
default &quot;complete&quot;. See the <code>stats::hclust</code> documentation for more
details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Build training data
dat &lt;- iris[, c("Sepal.Length", "Sepal.Width", "Petal.Length", "Petal.Width")]
### Scale training data
dat &lt;- scale(dat)
## Train SOM
### Initialization (PCA grid)
init &lt;- somInit(dat, 4, 4)
ok.som &lt;- kohonen::som(dat, grid = kohonen::somgrid(4, 4, 'hexagonal'),
                       rlen = 100, alpha = c(0.05, 0.01),
                       radius = c(2.65,-2.65),
                       init = init, dist.fcts = 'sumofsquares')
## Group cells into superclasses (PAM clustering)
superclust &lt;- cluster::pam(ok.som$codes[[1]], 2)
superclasses &lt;- superclust$clustering
aweSOMscreeplot(ok.som, method = 'hierarchical',
                hmethod = 'complete', nclass = 2)
</code></pre>

<hr>
<h2 id='aweSOMsilhouette'>Silhouette plot of SOM superclasses</h2><span id='topic+aweSOMsilhouette'></span>

<h3>Description</h3>

<p>Plots a silhouette plot, used to assess the quality of the super-clustering
of SOM prototypes into superclasses. Available for both PAM and
hierarchical clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aweSOMsilhouette(som, clust)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aweSOMsilhouette_+3A_som">som</code></td>
<td>
<p><code>kohonen</code> object, a SOM created by the <code>kohonen::som</code> function.</p>
</td></tr>
<tr><td><code id="aweSOMsilhouette_+3A_clust">clust</code></td>
<td>
<p>object containing the result of the super-clustering of the SOM
prototypes (either a <code>hclust</code> or a <code>pam</code> object).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Build training data
dat &lt;- iris[, c("Sepal.Length", "Sepal.Width", "Petal.Length", "Petal.Width")]
### Scale training data
dat &lt;- scale(dat)
## Train SOM
### Initialization (PCA grid)
init &lt;- somInit(dat, 4, 4)
ok.som &lt;- kohonen::som(dat, grid = kohonen::somgrid(4, 4, 'hexagonal'),
                       rlen = 100, alpha = c(0.05, 0.01),
                       radius = c(2.65,-2.65), init = init,
                       dist.fcts = 'sumofsquares')
## Group cells into superclasses (PAM clustering)
superclust &lt;- cluster::pam(ok.som$codes[[1]], 2)
superclasses &lt;- superclust$clustering
aweSOMsilhouette(ok.som, superclasses)
</code></pre>

<hr>
<h2 id='aweSOMsmoothdist'>Smooth Distance Plot for SOM</h2><span id='topic+aweSOMsmoothdist'></span>

<h3>Description</h3>

<p>Plots a visualization of the distances between the SOM cells. Based on the
U-Matrix, which is computed for each cell as the mean distance to its
immediate neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aweSOMsmoothdist(
  som,
  pal = c("viridis", "grey", "rainbow", "heat", "terrain", "topo", "cm",
    rownames(RColorBrewer::brewer.pal.info)),
  reversePal = FALSE,
  legendFontsize = 14
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aweSOMsmoothdist_+3A_som">som</code></td>
<td>
<p><code>kohonen</code> object, a SOM created by the <code>kohonen::som</code> function.</p>
</td></tr>
<tr><td><code id="aweSOMsmoothdist_+3A_pal">pal</code></td>
<td>
<p>character, the color palette. Default is &quot;viridis&quot;. Can be
&quot;viridis&quot;, &quot;grey&quot;, &quot;rainbow&quot;, &quot;heat&quot;, &quot;terrain&quot;, &quot;topo&quot;, &quot;cm&quot;, or any
palette name of the RColorBrewer package.</p>
</td></tr>
<tr><td><code id="aweSOMsmoothdist_+3A_reversepal">reversePal</code></td>
<td>
<p>logical, whether color palette should be reversed. Default
is FALSE.</p>
</td></tr>
<tr><td><code id="aweSOMsmoothdist_+3A_legendfontsize">legendFontsize</code></td>
<td>
<p>numeric, the font size for the legend. Default 14.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of classes <code>gg</code> and <code>ggplot</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Build training data
dat &lt;- iris[, c("Sepal.Length", "Sepal.Width", "Petal.Length", "Petal.Width")]
### Scale training data
dat &lt;- scale(dat)
## Train SOM
### Initialization (PCA grid)
init &lt;- somInit(dat, 4, 4)
ok.som &lt;- kohonen::som(dat, grid = kohonen::somgrid(4, 4, 'rectangular'),
                       init = init)
aweSOMsmoothdist(ok.som)
</code></pre>

<hr>
<h2 id='cdt'>Complete disjunctive table</h2><span id='topic+cdt'></span>

<h3>Description</h3>

<p>Computes the complete disjunctive table of a set of factors, where each
factor (ie categorical variable) is encoded as a set of dummy variables, one
for each level (category).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdt(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cdt_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> on which the table is computed. All columns will
be treated as factors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> of dummy variables, with <code>nrow(x)</code> rows and a
number of columns equal to the sum of numbers of levels in all the
variables of <code>x</code>.
</p>

<hr>
<h2 id='somDist'>Distance measures on a SOM</h2><span id='topic+somDist'></span>

<h3>Description</h3>

<p>Several distance measures between cells or prototypes of a trained SOM (in
grid space, in data space).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>somDist(som)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="somDist_+3A_som">som</code></td>
<td>
<p><code>kohonen</code> object, a SOM created by the <code>som</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with distance measures: between cells on the grid,
between prototypes in data space, and the neighborhood matrix on the grid.
</p>

<hr>
<h2 id='somInit'>Initialize SOM prototypes</h2><span id='topic+somInit'></span>

<h3>Description</h3>

<p>Prototypes are the artificial points in data space that are used to cluster
observations: each observation is assigned to the cluster of its closest
prototype. In self-organizing maps, each cell of the map has its own
prototype, and training is performed by iteratively adjusting the prototypes.
This function creates an initial guess for the prototypes of a SOM grid, to
be used as the <code>init</code> argument to the <code>kohonen::som</code> function (see example).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>somInit(traindat, nrows, ncols, method = c("pca.sample", "pca", "random"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="somInit_+3A_traindat">traindat</code></td>
<td>
<p>Matrix of training data, that will also be used to train the
SOM.</p>
</td></tr>
<tr><td><code id="somInit_+3A_nrows">nrows</code></td>
<td>
<p>Number of rows on the map.</p>
</td></tr>
<tr><td><code id="somInit_+3A_ncols">ncols</code></td>
<td>
<p>Number of columns on the map.</p>
</td></tr>
<tr><td><code id="somInit_+3A_method">method</code></td>
<td>
<p>Method used, see Details. &quot;pca&quot; or &quot;random&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default method &quot;pca.sample&quot; takes as prototypes the observations
that are closest to the nodes of a 2d grid placed along the first two
components of a PCA. The &quot;pca&quot; method uses the nodes instead of the
observations. The &quot;random&quot; method samples random observations.
</p>


<h3>Value</h3>

<p>A matrix of prototype coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- iris[, c("Sepal.Length", "Sepal.Width", "Petal.Length", "Petal.Width")]
### Scale training data
dat &lt;- scale(dat)
## Train SOM
### Initialization (PCA grid)
init &lt;- somInit(dat, 4, 4)
the.som &lt;- kohonen::som(dat, grid = kohonen::somgrid(4, 4, 'hexagonal'), 
                        rlen = 100, alpha = c(0.05, 0.01), 
                        radius = c(2.65,-2.65), init = init, 
                        dist.fcts = 'sumofsquares')
</code></pre>

<hr>
<h2 id='somQuality'>SOM quality measures</h2><span id='topic+somQuality'></span>

<h3>Description</h3>

<p>Computes several quality measures on a trained SOM (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>somQuality(som, traindat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="somQuality_+3A_som">som</code></td>
<td>
<p><code>kohonen</code> object, a SOM created by the <code>kohonen::som</code> function.</p>
</td></tr>
<tr><td><code id="somQuality_+3A_traindat">traindat</code></td>
<td>
<p>matrix containing the training data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Four measures of SOM quality are returned : 
</p>

<dl>
<dt>Quantization error:</dt><dd><p>Average squared distance between the data points and the map's prototypes to which they are mapped. Lower is better.</p>
</dd>
<dt>Percentage of explained variance:</dt><dd><p>Similar to other clustering methods, the share of total variance that is explained by the clustering (equal to 1 minus the ratio of quantization error to total variance). Higher is better.</p>
</dd>
<dt>Topographic error:</dt><dd><p>Measures how well the topographic structure of the data is preserved on the map. It is computed as the share of observations for which the best-matching node is not a neighbor of the second-best matching node on the map. Lower is better: 0 indicates excellent topographic representation (all best and second-best matching nodes are neighbors), 1 is the maximum error (best and second-best nodes are never neighbors).</p>
</dd>
<dt>Kaski-Lagus error:</dt><dd><p>Combines aspects of the quantization and topographic error. It is the sum of the mean distance between points and their best-matching prototypes, and of the mean geodesic distance (pairwise prototype distances following the SOM grid) between the points and their second-best matching prototype.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code>list</code> containing quality measures : quantization error, share
of explained variance, topographic error and Kaski-Lagus error (see
Details).
</p>


<h3>References</h3>

<p>Kohonen T. (2001) <em>Self-Organizing Maps</em>, 3rd edition,
Springer Press, Berlin. &lt;doi:10.1007/978-3-642-56927-2&gt;
</p>
<p>Kaski, S. and Lagus, K. (1996) Comparing Self-Organizing Maps. In C. von
der Malsburg, W. von Seelen, J. C. Vorbruggen, and B. Sendho (Eds.)
<em>Proceedings of ICANN96, International Conference on Articial Neural
Networks , Lecture Notes in Computer Science</em> vol. 1112, pp. 809-814.
Springer, Berlin. &lt;doi:10.1007/3-540-61510-5_136&gt;
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
