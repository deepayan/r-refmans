<!DOCTYPE html><html><head><title>Help for package rubias</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rubias}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#a_freq_list'><p>Convert data frame of allele frequencies to nested lists</p></a></li>
<li><a href='#alewife'><p>Microsat data from alewife herring reference populations</p></a></li>
<li><a href='#allelic_list'><p>Create genotype lists for each locus</p></a></li>
<li><a href='#assess_pb_bias_correction'><p>Test the effects of the parametric bootstrap bias correction on a reference dataset through cross-validation</p></a></li>
<li><a href='#assess_reference_loo'><p>Simulate mixtures and estimate reporting group and collection proportions.</p></a></li>
<li><a href='#assess_reference_mc'><p>Partition a reference dataset and estimate reporting group and collection proportions</p></a></li>
<li><a href='#avg_coll2correctRU'><p>Get the average within-RU assignment rate for each collection</p></a></li>
<li><a href='#blueback'><p>Microsat data from blueback herring reference populations</p></a></li>
<li><a href='#bootstrap_rho'><p>Perform a parametric bootstrapping correction on an estimated rho vector</p></a></li>
<li><a href='#check_known_collections'><p>check a baseline and mixture file together to ensure the known_collections are valid if they exist</p></a></li>
<li><a href='#check_refmix'><p>A helper function to check that the input data frame is OK</p></a></li>
<li><a href='#chinook'><p>SNP data from chinook reference populations</p></a></li>
<li><a href='#chinook_collection_levels'><p>a vector that gives a desired sort order of the chinook collections</p></a></li>
<li><a href='#chinook_mix'><p>SNP data from Chinook salmon taken in May/August 2015 from California fisheries</p></a></li>
<li><a href='#chinook_repunit_levels'><p>a vector that gives a desired sort order of the chinook repunits</p></a></li>
<li><a href='#close_matching_samples'><p>check for matching (or close to matching) genotypes in a data frame</p></a></li>
<li><a href='#count_missing_data'><p>for each individual count the number or loci missing and non_missing</p></a></li>
<li><a href='#custom_pi_prior'><p>Create a vector of pi Dirichlet priors with specified values for one or more collections</p></a></li>
<li><a href='#dirch_from_allocations'><p>Given a vector of different categories in 1...n and a prior,</p>
simulate a Dirichlet random vector</a></li>
<li><a href='#dirch_from_counts'><p>Given a vector of counts for different categories in 1...n and a prior,</p>
simulate a Dirichlet random vector</a></li>
<li><a href='#geno_logL'><p>Calculate a matrix of genotype log-likelihoods for a genetic dataset</p></a></li>
<li><a href='#geno_logL_ssq'><p>Calculate a matrix of sum-of-squares of genotype log-likelihoods for a genetic dataset</p></a></li>
<li><a href='#get_ploidy_from_frame'><p>infer the ploidy from the pattern of NAs in the columns of data</p></a></li>
<li><a href='#gprob_sim_gc'><p>Simulate genotype log-likelihoods from a population by gene copy</p></a></li>
<li><a href='#gprob_sim_gc_missing'><p>Simulate genotypes by gene copy, with missing data from chosen individuals</p></a></li>
<li><a href='#gprob_sim_ind'><p>Simulate genotype log-likelihoods from a population by individual</p></a></li>
<li><a href='#gsi_em_1'><p>EM algorithm from the simplest GSI model for pi and the individual posterior probabilities</p></a></li>
<li><a href='#gsi_mcmc_1'><p>MCMC from the simplest GSI model for pi and the individual posterior probabilities</p></a></li>
<li><a href='#gsi_mcmc_fb'><p>MCMC from the fully Bayesian GSI model for pi and the individual posterior probabilities</p></a></li>
<li><a href='#Hasselman_sim_colls'><p>Generate a random population structure and mixture sample, as in</p>
Hasselman <em>et al.</em> 2015</a></li>
<li><a href='#infer_mixture'><p>Estimate mixing proportions and origin probabilities from one or several mixtures</p></a></li>
<li><a href='#list_diploid_params'><p>Collect essential data values before mixture proportion estimation</p></a></li>
<li><a href='#mixture_draw'><p>Separate a chosen proportion of a reference dataset into a mixture with known population proportions</p></a></li>
<li><a href='#modify_scaled_likelihoods_for_known_mixture_fish'><p>for individuals of known origin in the mixture, put all their weight on their known collection</p></a></li>
<li><a href='#per_locus_means_and_vars'><p>Compute the mean and variance of the single-locus genotype likelihoods for each collection</p></a></li>
<li><a href='#perfect_chinook'><p>perfect-assignment genetic data for chinook.</p></a></li>
<li><a href='#perfect_chinook_mix'><p>perfect-assignment mixture genetic data for chinook.</p></a></li>
<li><a href='#rcpp_close_matchers'><p>Find all pairs that have close matches</p></a></li>
<li><a href='#rcpp_indiv_specific_logl_means_and_vars'><p>From the pattern of missing data at each individual, compute the expected mean and variance of the logl</p></a></li>
<li><a href='#rcpp_per_locus_logls'><p>Return a matrix of locus-specific self-assignment logls</p></a></li>
<li><a href='#read_gsi_sim'><p>read a gsi_sim formatted input file into a tibble that rubias can use</p></a></li>
<li><a href='#ref_and_mix_pipeline'><p>Estimate mixing proportions from reference and mixture datasets</p></a></li>
<li><a href='#reference_allele_counts'><p>Tabulate occurrences of all observed alleles in reference genetic data</p></a></li>
<li><a href='#round2'><p>Round a given number, with 5 always rounded up</p></a></li>
<li><a href='#rubias'><p>rubias: Bayesian inference from the conditional genetic stock identification model</p></a></li>
<li><a href='#samp_from_mat'><p>Sample 1 observation from cell probabilities that are columns of a matrix</p></a></li>
<li><a href='#self_assign'><p>Do leave-one-out self-assignment of individuals in a reference baseline</p></a></li>
<li><a href='#sim_spec_examples'><p>List of example ways of specifying repunit and collection quantities in simulations</p></a></li>
<li><a href='#simulate_random_samples'><p>Generate a samples for a mixture.</p></a></li>
<li><a href='#small_chinook_mix'><p>Small sample of SNP data from Chinook salmon taken in May/August 2015 from California fisheries</p></a></li>
<li><a href='#small_chinook_ref'><p>SNP data from selected chinook reference populations</p></a></li>
<li><a href='#tcf2long'><p>Convert Two-Column Genetic Data to Long Format</p></a></li>
<li><a href='#tcf2param_list'><p>Generate MCMC parameter list from two-column genetic data &amp; print summary</p></a></li>
<li><a href='#tidy_mcmc_coll_rep_stuff'><p>A helper function to tidy up the output from the gsi_mcmc functions</p></a></li>
<li><a href='#tidy_mcmc_pofz'><p>A helper function to tidy up the PofZ-like output from the gsi_mcmc functions</p></a></li>
<li><a href='#tidy_pi_traces'><p>a helper function to tidy up the pi-traces that come out of the mcmc functions</p></a></li>
<li><a href='#write_gsi_sim_mixture'><p>Write a mixture data frame to gsi_sim format baseline and repunits file</p></a></li>
<li><a href='#write_gsi_sim_reference'><p>Write a reference data frame to gsi_sim format baseline and repunits file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Inference from the Conditional Genetic Stock
Identification Model</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eric C. Anderson &lt;eric.anderson@noaa.gov&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements Bayesian inference for the conditional genetic 
    stock identification model.  It allows inference of mixed fisheries and also 
    simulation of mixtures to predict accuracy.  A full description of the underlying
    methods is available in a recently published article in the
    Canadian Journal of Fisheries and Aquatic Sciences: &lt;<a href="https://doi.org/10.1139%2Fcjfas-2018-0016">doi:10.1139/cjfas-2018-0016</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/publicdomain/zero/1.0/legalcode">CC0</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, gtools, magrittr, Rcpp (&ge; 0.12.5), readr, rlang,
stringr, tibble, tidyr, RcppParallel</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppParallel</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, ggplot2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-23 21:49:33 UTC; eriq</td>
</tr>
<tr>
<td>Author:</td>
<td>Eric C. Anderson [aut, cre],
  Ben Moran [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-24 14:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='a_freq_list'>Convert data frame of allele frequencies to nested lists</h2><span id='topic+a_freq_list'></span>

<h3>Description</h3>

<p>List-izes the output of <code>reference_allele_counts</code> into a usable format for <code>allelic_list</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a_freq_list(D, pop_level = "collection")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="a_freq_list_+3A_d">D</code></td>
<td>
<p>the long-format dataframe of counts by collection, locus, and allele,
output by <code>reference_allele_counts</code>, to be made into a nested list</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>a_freq_list</code> returns a list named by loci, each element of which is a matrix
containing that locus's allele count data. Rows in the matrix mark alleles, and columns collections
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Generate a list of individual genotypes by allele from
 # the alewife data's reference allele count tables
 example(reference_allele_counts)
 ale_ac &lt;- a_freq_list(ale_rac)
</code></pre>

<hr>
<h2 id='alewife'>Microsat data from alewife herring reference populations</h2><span id='topic+alewife'></span>

<h3>Description</h3>

<p>Standard two-column genetic data with lots of other columns preceding it.
Can be fed directly into rubias because it has at least the columns sample_type,
collection, repunit and indiv.
</p>


<h3>Format</h3>

<p>A tibble.
</p>


<h3>Source</h3>

<p><a href="https://datadryad.org/stash/dataset/doi:10.5061/dryad.80f4f">https://datadryad.org/stash/dataset/doi:10.5061/dryad.80f4f</a>
</p>

<hr>
<h2 id='allelic_list'>Create genotype lists for each locus</h2><span id='topic+allelic_list'></span>

<h3>Description</h3>

<p>Uses the allele counts from <code>a_freq_list</code> and the cleaned short-format output of
<code>tcf2long</code> to generate a nested list of individual genotypes for each locus
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allelic_list(cs, ac, samp_type = "both")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allelic_list_+3A_cs">cs</code></td>
<td>
<p>a clean short genetic data matrix; the second element of the
output from <code>tcf2long</code>. Must have a column of individual identifiers, named &quot;indiv&quot;</p>
</td></tr>
<tr><td><code id="allelic_list_+3A_ac">ac</code></td>
<td>
<p>allele counts from a_freq_list</p>
</td></tr>
<tr><td><code id="allelic_list_+3A_samp_type">samp_type</code></td>
<td>
<p>choose which sample types of individuals to include in output:
&quot;mixture&quot;, &quot;both&quot;, or &quot;reference&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>allelic_list</code> returns a two-component nested list, with data stored as character
names of alleles ($chr) or as integer indices for the alleles ($int). Both forms contain lists
representing to loci, with two component vectors corresponding to gene copies a and b.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(a_freq_list)
ale_cs &lt;- ale_long$clean_short
# Get the vectors of gene copies a and b for all loci in integer index form
ale_alle_list &lt;- allelic_list(ale_cs, ale_ac)$int

</code></pre>

<hr>
<h2 id='assess_pb_bias_correction'>Test the effects of the parametric bootstrap bias correction on a reference dataset through cross-validation</h2><span id='topic+assess_pb_bias_correction'></span>

<h3>Description</h3>

<p>This is a rewrite of bias_comparison().  Eric didn't want the plotting to
be wrapped up in a function, and wanted to return a more informative data
frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assess_pb_bias_correction(
  reference,
  gen_start_col,
  seed = 5,
  nreps = 50,
  mixsize = 100,
  alle_freq_prior = list(const_scaled = 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assess_pb_bias_correction_+3A_reference">reference</code></td>
<td>
<p>a two-column format genetic dataset, with a &quot;repunit&quot; column
specifying each individual's reporting unit of origin, a &quot;collection&quot; column
specifying the collection (population or time of sampling) and &quot;indiv&quot; providing
a unique name</p>
</td></tr>
<tr><td><code id="assess_pb_bias_correction_+3A_gen_start_col">gen_start_col</code></td>
<td>
<p>the first column containing genetic data in <code>reference</code>.
All columns should be genetic format following this column, and gene copies from the
same locus should be adjacent</p>
</td></tr>
<tr><td><code id="assess_pb_bias_correction_+3A_seed">seed</code></td>
<td>
<p>the random seed for simulations</p>
</td></tr>
<tr><td><code id="assess_pb_bias_correction_+3A_nreps">nreps</code></td>
<td>
<p>The number of reps to do.</p>
</td></tr>
<tr><td><code id="assess_pb_bias_correction_+3A_mixsize">mixsize</code></td>
<td>
<p>The size of each simulated mixture sample.</p>
</td></tr>
<tr><td><code id="assess_pb_bias_correction_+3A_alle_freq_prior">alle_freq_prior</code></td>
<td>
<p>a one-element named list specifying the prior to be used when
generating Dirichlet parameters for genotype likelihood calculations. Valid methods include
<code>"const"</code>, <code>"scaled_const"</code>, and <code>"empirical"</code>. See
<code>?list_diploid_params</code> for method details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes a reference two-column genetic dataset, pulls a series of random
&quot;mixture&quot; datasets with varying reporting unit proportions from this reference,
and compares the results of GSI through standard MCMC
vs. parametric-bootstrap MCMC bias correction
</p>
<p>The amount of bias in reporting unit proportion calculations increases with the
rate of misassignment between reporting units (decreases with genetic differentiation),
and increases as the number of collections within reporting units becomes more uneven.
</p>
<p>Output from the standard Bayesian MCMC method demonstrates the level of bias to be
expected for the input data set, and parametric bootstrapping is an empirical method
for the removal of any existing bias.
</p>


<h3>Value</h3>

<p><code>bias_comparison</code> returns a list; the first element is
a list of the relevant rho values generated on each iteration of the random &quot;mixture&quot;
creation. This includes the true rho value, the standard result <code>rho_mcmc</code>,
and the parametric bootstrapped <code>rho_pb</code>.
</p>
<p>The second element is a dataframe listing summary statistics for each
reporting unit and estimation method. <code>mse</code>, the mean squared error, summarizes
the deviation of the rho estimates from their true value, including both bias and other variance.
<code>mean_prop_bias</code> is the average ratio of residual to true value, which gives greater
weight to deviations at smaller values. <code>mean_bias</code> is simply the average residual;
unlike <code>mse</code>, this demonstrates the direction of the bias.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## This takes too long to run in R CMD CHECK
ale_bias &lt;- assess_pb_bias_correction(alewife, 17)

## End(Not run)

</code></pre>

<hr>
<h2 id='assess_reference_loo'>Simulate mixtures and estimate reporting group and collection proportions.</h2><span id='topic+assess_reference_loo'></span>

<h3>Description</h3>

<p>From a reference dataset, this creates a genotype-logL matrix based on
simulation-by-individual with randomly drawn population proportions,
then uses this in two different estimates of population mixture proportions:
maximum likelihood via EM-algorithm and posterior mean from
MCMC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assess_reference_loo(
  reference,
  gen_start_col,
  reps = 50,
  mixsize = 100,
  seed = 5,
  alpha_repunit = 1.5,
  alpha_collection = 1.5,
  resampling_unit = "individual",
  alle_freq_prior = list(const_scaled = 1),
  printSummary = FALSE,
  return_indiv_posteriors = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assess_reference_loo_+3A_reference">reference</code></td>
<td>
<p>a two-column format genetic dataset, with &quot;repunit&quot;, &quot;collection&quot;, and &quot;indiv&quot;
columns, as well as a &quot;sample_type&quot; column that has some &quot;reference&quot; entries</p>
</td></tr>
<tr><td><code id="assess_reference_loo_+3A_gen_start_col">gen_start_col</code></td>
<td>
<p>the first column of genetic data in <code>reference</code></p>
</td></tr>
<tr><td><code id="assess_reference_loo_+3A_reps">reps</code></td>
<td>
<p>number of reps of mixture simulation and MCMC to do</p>
</td></tr>
<tr><td><code id="assess_reference_loo_+3A_mixsize">mixsize</code></td>
<td>
<p>the number of individuals in each simulated mixture</p>
</td></tr>
<tr><td><code id="assess_reference_loo_+3A_seed">seed</code></td>
<td>
<p>a random seed for simulations</p>
</td></tr>
<tr><td><code id="assess_reference_loo_+3A_alpha_repunit">alpha_repunit</code></td>
<td>
<p>If a vector, this is the dirichlet parameter for simulating
the proportions of reporting units. Gets recycled to the number of reporting units. Default is 1.5.
Otherwise, this could be a two-column data frame.  The first column must be named &quot;repunit&quot; and the
second one must be one of &quot;dirichlet&quot;, &quot;ppn&quot;, or &quot;cnt&quot;, according to whether you wish to
specify dirichlet parameters, or proportions, or exact counts, respectively, for each population.
If you want to make multiple simulations, pass in a list of data frames or of individual dirichlet parameters.
For examples, see <code><a href="#topic+sim_spec_examples">sim_spec_examples</a></code>.</p>
</td></tr>
<tr><td><code id="assess_reference_loo_+3A_alpha_collection">alpha_collection</code></td>
<td>
<p>The dirichlet parameter for simulating proportions of collections within reporting units. Default = 1.5.
If this is a data frame then the first column must be &quot;collection&quot; and the second must be one of
&quot;dirichlet&quot;, &quot;ppn&quot;, &quot;cnt&quot;, &quot;sub_dirichlet&quot;, &quot;sub_ppn&quot;.  If you want to provide multiple different
scenarios.  You can pass them in as a list.  If alpha_repunit or alpha_collection is a list with length
greater than 1, the shorter will be recycled.
For examples, see <code><a href="#topic+sim_spec_examples">sim_spec_examples</a></code>.</p>
</td></tr>
<tr><td><code id="assess_reference_loo_+3A_resampling_unit">resampling_unit</code></td>
<td>
<p>what unit should be resampled.  Currently the choices are &quot;individuals&quot; (the default)
and &quot;gene_copies&quot;.  Using &quot;individuals&quot; preserves missing data patterns available in the reference data set.
We also have &quot;gene_copies_with_missing&quot; capability, but it is not yet linked into this function.</p>
</td></tr>
<tr><td><code id="assess_reference_loo_+3A_alle_freq_prior">alle_freq_prior</code></td>
<td>
<p>a one-element named list specifying the prior to be used when
generating Dirichlet parameters for genotype likelihood calculations. Valid methods include
<code>"const"</code>, <code>"scaled_const"</code>, and <code>"empirical"</code>. See <code>?list_diploid_params</code>
for method details.</p>
</td></tr>
<tr><td><code id="assess_reference_loo_+3A_printsummary">printSummary</code></td>
<td>
<p>if TRUE a summary of the reference samples will be printed to stdout.</p>
</td></tr>
<tr><td><code id="assess_reference_loo_+3A_return_indiv_posteriors">return_indiv_posteriors</code></td>
<td>
<p>if TRUE, output is a list of 2. The first entry, <code>mixing_proportions</code>,
contains the true (simulated) and estimated mixture proportions for each scenario, iteration, and collection.
The second, <code>indiv_posteriors</code>, contains the posterior probability of assignment to each collection
for each scenario, iteration, and individual. If FALSE, output is a single data frame, <code>mixing_proportions</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># very small number of reps so it is quick enough for example
ale_dev &lt;- assess_reference_loo(alewife, 17, reps = 5)

</code></pre>

<hr>
<h2 id='assess_reference_mc'>Partition a reference dataset and estimate reporting group and collection proportions</h2><span id='topic+assess_reference_mc'></span>

<h3>Description</h3>

<p>From a reference dataset, this draws (without replacement) a simulated mixture
dataset with randomly drawn population proportions,
then uses this in two different estimates of population mixture proportions:
maximum likelihood via EM-algorithm and posterior mean from MCMC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assess_reference_mc(
  reference,
  gen_start_col,
  reps = 50,
  mixsize = 100,
  seed = 5,
  alpha_repunit = 1.5,
  alpha_collection = 1.5,
  min_remaining = 5,
  alle_freq_prior = list(const_scaled = 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assess_reference_mc_+3A_reference">reference</code></td>
<td>
<p>a two-column format genetic dataset, with &quot;repunit&quot;, &quot;collection&quot;, and &quot;indiv&quot;
columns, as well as a &quot;sample_type&quot; column that has some &quot;reference&quot; entries.</p>
</td></tr>
<tr><td><code id="assess_reference_mc_+3A_gen_start_col">gen_start_col</code></td>
<td>
<p>the first column of genetic data in reference</p>
</td></tr>
<tr><td><code id="assess_reference_mc_+3A_reps">reps</code></td>
<td>
<p>number of reps to do</p>
</td></tr>
<tr><td><code id="assess_reference_mc_+3A_mixsize">mixsize</code></td>
<td>
<p>the number of individuals in each simulated mixture.</p>
</td></tr>
<tr><td><code id="assess_reference_mc_+3A_seed">seed</code></td>
<td>
<p>a random seed for simulations</p>
</td></tr>
<tr><td><code id="assess_reference_mc_+3A_alpha_repunit">alpha_repunit</code></td>
<td>
<p>The dirichlet parameter for simulating the proportions of
reporting units. Default = 1.5</p>
</td></tr>
<tr><td><code id="assess_reference_mc_+3A_alpha_collection">alpha_collection</code></td>
<td>
<p>The dirichlet parameter for simulating proportions of collections
within reporting units. Default = 1.5</p>
</td></tr>
<tr><td><code id="assess_reference_mc_+3A_min_remaining">min_remaining</code></td>
<td>
<p>the minimum number of individuals which should be conserved in
each reference collection during sampling without replacement to form the simulated mixture</p>
</td></tr>
<tr><td><code id="assess_reference_mc_+3A_alle_freq_prior">alle_freq_prior</code></td>
<td>
<p>a one-element named list specifying the prior to be used when
generating Dirichlet parameters for genotype likelihood calculations. Valid methods include
<code>"const"</code>, <code>"scaled_const"</code>, and <code>"empirical"</code>. See <code>?list_diploid_params</code>
for method details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is referred to as &quot;Monte Carlo cross-validation&quot;.
The input parameters for <code>assess_reference_mc</code> are more restrictive than those of
<code>assess_reference_loo</code>. Rather than allowing a <em>data.frame</em> to specify Dirichlet
parameters, proportions, or counts for specific reporting units and collections,
<code>assess_reference_mc</code> only allows vector input (default = 1.5) for <code>alpha_repunit</code>
and <code>alpha_collection</code>. These inputs specify the uniform Dirichlet parameters for
all reporting units and collections, respectively.
</p>
<p>For mixture proportion generation, the rho values are first drawn using a stick-breaking
model of the Dirichlet distribution, but with proportions capped by <code>min_remaining</code>.
Stick-breaking is then used to subdivide each reporting unit into collections. In
addition to the constraint that mixture sampling without replacement cannot deplete
the number of individuals in each collection below <code>min_remaining</code>, a similar
constraint is placed upon the number of individuals left in reporting units,
determined as <code>min_remaining</code> * (# collections in reporting unit).
</p>
<p>Note that this implies that the data are only truly Dirichlet distributed when no
rejections based on <code>min_remaining</code> occur. This is a reasonable certainty with
sufficient reference collection sizes relative to the desired mixture size.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># only 5 reps, so it doesn't take too long.  Typically you would
# do many more
ale_dev &lt;- assess_reference_mc(alewife, 17, 5)
</code></pre>

<hr>
<h2 id='avg_coll2correctRU'>Get the average within-RU assignment rate for each collection</h2><span id='topic+avg_coll2correctRU'></span>

<h3>Description</h3>

<p>This function takes a matrix of scaled genotype likelihoods for a group of
individuals of known origin, and calculates the average rate at which individuals
in a particular collection are assigned to the correct reporting unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avg_coll2correctRU(SL, coll, RU_starts, RU_vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="avg_coll2correctRU_+3A_sl">SL</code></td>
<td>
<p>a scaled likelihood matrix; each column should sum to one, and represent
the probability of assignments to each collection (row) for a particular individual</p>
</td></tr>
<tr><td><code id="avg_coll2correctRU_+3A_coll">coll</code></td>
<td>
<p>a vector of the collection of origin indices of the individuals (length = <code>ncol(SL)</code>)</p>
</td></tr>
<tr><td><code id="avg_coll2correctRU_+3A_ru_starts">RU_starts</code></td>
<td>
<p>a vector delineating starting indices of different reporting units in RU_vec</p>
</td></tr>
<tr><td><code id="avg_coll2correctRU_+3A_ru_vec">RU_vec</code></td>
<td>
<p>a vector of collection indices, organized by reporting unit</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The average rate of correct within-reporting unit assignment is proportional to
reporting-unit-level bias in the posterior probability for this collection;
if the correct assignment rate is high relative to other collections,
it will be upwardly biased, and vice versa. The inverse of this vector is used
to scale Dirichlet draws of <code>omega</code> during misassignment-scaled MCMC.
</p>


<h3>Value</h3>

<p><code>avg_coll2correctRU</code> returns a vector of length <code>nrow(SL)</code>, where
each element represents the average proportion of fish from the corresponding collection
which are correctly assigned to the proper collection, or misassigned to another
collection within the same reporting unit. This is distinct from the rate of
correct assignment at the collection level, which is too low and variable to serve
as a stable metric for <code>omega</code> scaling.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>locnames &lt;- names(alewife)[-(1:16)][c(TRUE, FALSE)]
ploidies &lt;- rep(2, length(locnames))
names(ploidies) &lt;- locnames

params &lt;- tcf2param_list(alewife, 17, ploidies = ploidies)
SL &lt;- geno_logL(params) %&gt;% exp() %&gt;% apply(2, function(x) x/sum(x))
correct &lt;- avg_coll2correctRU(SL, params$coll, params$RU_starts, params$RU_vec)
</code></pre>

<hr>
<h2 id='blueback'>Microsat data from blueback herring reference populations</h2><span id='topic+blueback'></span>

<h3>Description</h3>

<p>Standard two-column genetic data with lots of other columns preceding it.
Can be fed directly into rubias because it has at least the columns sample_type,
collection, repunit and indiv.
</p>


<h3>Format</h3>

<p>A tibble.
</p>


<h3>Source</h3>

<p><a href="https://datadryad.org/stash/dataset/doi:10.5061/dryad.80f4f">https://datadryad.org/stash/dataset/doi:10.5061/dryad.80f4f</a>
</p>

<hr>
<h2 id='bootstrap_rho'>Perform a parametric bootstrapping correction on an estimated rho vector</h2><span id='topic+bootstrap_rho'></span>

<h3>Description</h3>

<p>Takes an estimate of rho, and a two-column format genetic data frame
containing both reference and mixture data. Returns a new rho corrected by
parametric bootstrapping
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap_rho(
  rho_est,
  pi_est,
  D,
  gen_start_col,
  niter = 100,
  reps = 2000,
  burn_in = 100,
  pi_prior = NA,
  pi_prior_sum = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap_rho_+3A_rho_est">rho_est</code></td>
<td>
<p>the rho value previously estimated from MCMC GSI from the
provided reference and mixture data</p>
</td></tr>
<tr><td><code id="bootstrap_rho_+3A_pi_est">pi_est</code></td>
<td>
<p>the pi value previously estimated from MCMC GSI from the
provided reference and mixture data</p>
</td></tr>
<tr><td><code id="bootstrap_rho_+3A_d">D</code></td>
<td>
<p>a two-column genetic dataframe containing the reference and mixture
data from which <code>rho_est</code> was computed; with &quot;repunit&quot;, &quot;collection&quot;,
and &quot;indiv&quot; columns</p>
</td></tr>
<tr><td><code id="bootstrap_rho_+3A_gen_start_col">gen_start_col</code></td>
<td>
<p>the first column of genetic data in D. All columns after
<code>gen_start_col</code> must be genetic data</p>
</td></tr>
<tr><td><code id="bootstrap_rho_+3A_pi_prior">pi_prior</code></td>
<td>
<p>The prior to be added to the collection allocations, in order
to generate pseudo-count Dirichlet parameters for the simulation of a new pi vector.
Non-default values should be a vector of length equal to the number of populations
in the reference dataset. Default value of NA leads to the
calculation of a symmetrical prior based on <code>pi_prior_sum</code>.</p>
</td></tr>
<tr><td><code id="bootstrap_rho_+3A_pi_prior_sum">pi_prior_sum</code></td>
<td>
<p>total weight on default symmetrical prior for pi.
</p>
<p>In parametric bootstrapping, <code>niter</code> new mixture datasets are simulated by
individual from the reference with reporting unit proportions <code>rho_est</code>,
and the mean of their MCMC GSI outputs is used to calculate an average bias.
This bias is subtracted from rho_est to give the output. The number of individuals
in each simulated bootstrap dataset is equal to the number of &quot;mixture&quot; individuals
in <code>D</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>bootstrap_rho</code> returns a new rho value, corrected by parametric
bootstrapping.
</p>

<hr>
<h2 id='check_known_collections'>check a baseline and mixture file together to ensure the known_collections are valid if they exist</h2><span id='topic+check_known_collections'></span>

<h3>Description</h3>

<p>Simple function that checks for known_collections columns in a reference and mixture and
makes sure that they are compliant.
If there is a non-NA entry in the Mixture frame's known_collection column this
function returns TRUE.  Otherwise it returns FALSE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_known_collections(R, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_known_collections_+3A_r">R</code></td>
<td>
<p>reference data frame</p>
</td></tr>
<tr><td><code id="check_known_collections_+3A_m">M</code></td>
<td>
<p>mixture data frame</p>
</td></tr>
</table>

<hr>
<h2 id='check_refmix'>A helper function to check that the input data frame is OK</h2><span id='topic+check_refmix'></span>

<h3>Description</h3>

<p>Just checks to make sure that column types are correct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_refmix(D, gen_start_col, type = "reference")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_refmix_+3A_d">D</code></td>
<td>
<p>the data frame</p>
</td></tr>
<tr><td><code id="check_refmix_+3A_gen_start_col">gen_start_col</code></td>
<td>
<p>the column in which the genetic data starts</p>
</td></tr>
<tr><td><code id="check_refmix_+3A_type">type</code></td>
<td>
<p>For writing errors, supply &quot;mixture&quot; or &quot;reference&quot; as appropriate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It also checks the patterns of missing data, and from that infers whether
markers are haploid or diploid.
</p>

<hr>
<h2 id='chinook'>SNP data from chinook reference populations</h2><span id='topic+chinook'></span>

<h3>Description</h3>

<p>Chinook salmon baseline data similar to that which can be
downloaded from <a href="https://datadryad.org/stash/dataset/doi:10.5061/dryad.574sv">https://datadryad.org/stash/dataset/doi:10.5061/dryad.574sv</a>.
This data set includes 91 SNPs and 7301 fish and is what the Dryad data became
after we converted from TaqMan to SNPtype assays (being forced to toss some loci)
and tossed out a bunch of lousy historical
samples from Trinity River.
</p>


<h3>Format</h3>

<p>A tbl_df-ed (from dplyr) data frame with 7,301 rows and 185 variables. The first
three columns are
</p>

<dl>
<dt>repunit (chr)</dt><dd><p>the reporting unit that the individual is in</p>
</dd>
<dt>pop (chr)</dt><dd><p>the population from which the individual was sampled</p>
</dd>
<dt>ID (chr)</dt><dd><p>Unique identifier of the individual fish</p>
</dd>
</dl>

<p>The remaining columns are two columns for each locus.  These columns are named like,
&quot;Locus.1&quot; and &quot;Locus.2&quot; for the first and second gene copies at that locus.  For example,
&quot;Ots_104569-86.1&quot; and  &quot;Ots_104569-86.2&quot;.  The locus columns are ints and missing data
is denoted by NA.
</p>


<h3>Source</h3>

<p><a href="https://datadryad.org/stash/dataset/doi:10.5061/dryad.574sv">https://datadryad.org/stash/dataset/doi:10.5061/dryad.574sv</a>
</p>

<hr>
<h2 id='chinook_collection_levels'>a vector that gives a desired sort order of the chinook collections</h2><span id='topic+chinook_collection_levels'></span>

<h3>Description</h3>

<p>This is just an example of what one would use as levels in order to
get the <code><a href="#topic+chinook">chinook</a></code> collections in a desired sort order after
analysis.  The issue here is collection in the input data frame to most
functions must be a character vector, not a factor.  But, after analysis
you can always make them a factor again and use a vector like this
one to specify the levels.
</p>


<h3>Source</h3>

<p>Made it up!
</p>

<hr>
<h2 id='chinook_mix'>SNP data from Chinook salmon taken in May/August 2015 from California fisheries</h2><span id='topic+chinook_mix'></span>

<h3>Description</h3>

<p>This has data from 91 SNP markers (a subset of the 95 markers in the <code><a href="#topic+chinook">chinook</a></code> baseline
data set).
</p>


<h3>Format</h3>

<p>A tbl_df-ed (from dplyr) data frame with 2256 rows and 193 variables. The first
four columns are meta data.
The remaining columns are two columns for each locus.  These columns are named like,
&quot;Locus.1&quot; and &quot;Locus.2&quot; for the first and second gene copies at that locus.  For example,
&quot;Ots_104569-86.1&quot; and  &quot;Ots_104569-86.2&quot;.  The locus columns are ints and missing data
is denoted by NA.
</p>


<h3>Source</h3>

<p>Southwest Fisheries Science Center, Santa Cruz, CA
</p>

<hr>
<h2 id='chinook_repunit_levels'>a vector that gives a desired sort order of the chinook repunits</h2><span id='topic+chinook_repunit_levels'></span>

<h3>Description</h3>

<p>This is just an example of what one would use as levels in order to
get the <code><a href="#topic+chinook">chinook</a></code> repunits in a desired sort order after
analysis.  The issue here is that repunit in the input data frame to most
functions must be a character vector, not a factor.  But, after analysis
you can always make them a factor again and use a vector like this
one to specify the levels.
</p>


<h3>Source</h3>

<p>Made it up!
</p>

<hr>
<h2 id='close_matching_samples'>check for matching (or close to matching) genotypes in a data frame</h2><span id='topic+close_matching_samples'></span>

<h3>Description</h3>

<p>Super simple function that looks at all pairs of fish from the data frame and
returns a tibble that includes those which shared a fraction &gt;= than min_frac_non_miss
of the genotypes not missing in either fish, and which were matching at a fraction &gt;= min_frac_matching
of those non-missing pairs of genotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>close_matching_samples(
  D,
  gen_start_col,
  min_frac_non_miss = 0.7,
  min_frac_matching = 0.9
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="close_matching_samples_+3A_d">D</code></td>
<td>
<p>a two-column format genetic dataset, with &quot;repunit&quot;, &quot;collection&quot;, and &quot;indiv&quot;
columns, as well as a &quot;sample_type&quot; column that has entried either of &quot;reference&quot; or &quot;mixture&quot;
or both.</p>
</td></tr>
<tr><td><code id="close_matching_samples_+3A_gen_start_col">gen_start_col</code></td>
<td>
<p>the first column of genetic data in <code>reference</code></p>
</td></tr>
<tr><td><code id="close_matching_samples_+3A_min_frac_non_miss">min_frac_non_miss</code></td>
<td>
<p>the fraction of loci that the pair must share non missing in order to be reported</p>
</td></tr>
<tr><td><code id="close_matching_samples_+3A_min_frac_matching">min_frac_matching</code></td>
<td>
<p>the fraction of shared non-missing loci that must be shared between the indivdiuals
to be reported as a matching pair.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble ...
</p>


<h3>Examples</h3>

<pre><code class='language-R'># one pair found in the interal alewife data set:
close_matching_samples(alewife, 17)
</code></pre>

<hr>
<h2 id='count_missing_data'>for each individual count the number or loci missing and non_missing</h2><span id='topic+count_missing_data'></span>

<h3>Description</h3>

<p>Takes a rubias genetic data frame that must have column &quot;indiv&quot;. Haploids have the
second column at each locus totally missing.  Diploids with missing data will have both gene copies
missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_missing_data(D, gen_start_col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_missing_data_+3A_d">D</code></td>
<td>
<p>the data frame</p>
</td></tr>
<tr><td><code id="count_missing_data_+3A_gen_start_col">gen_start_col</code></td>
<td>
<p>the column in which the genetic data starts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame with indiv (as characters), n_non_miss_loci, n_miss_loci (as numeric) and missing_loci
(as a list-column of named integer vectors)
</p>

<hr>
<h2 id='custom_pi_prior'>Create a vector of pi Dirichlet priors with specified values for one or more collections</h2><span id='topic+custom_pi_prior'></span>

<h3>Description</h3>

<p>This handles a case in which the user provides a data frame for <code>pi_prior</code>. The
data frame lists desired Dirichlet parameter priors for at least one reference collection,
and/or a default value for all unspecified collections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>custom_pi_prior(P, C)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="custom_pi_prior_+3A_p">P</code></td>
<td>
<p>A data frame of one or more desired pi prior parameters. One column, &quot;collection&quot;,
is a character vector, with valid values including the names of any reference collections,
or the special value &quot;DEFAULT_PI&quot;. The second column, &quot;pi_param&quot; is the prior value to be
used for each collection.</p>
</td></tr>
<tr><td><code id="custom_pi_prior_+3A_c">C</code></td>
<td>
<p>a tibble with a column &quot;collection&quot; collection names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input checking is currently done in the early stages of <code>infer_mixture</code> in order to
throw errors before long processing times, and avoid re-checking during <code>bootstrap_rho</code>.
</p>

<hr>
<h2 id='dirch_from_allocations'>Given a vector of different categories in 1...n and a prior,
simulate a Dirichlet random vector</h2><span id='topic+dirch_from_allocations'></span>

<h3>Description</h3>

<p>Takes a vector of collection indices to which individuals (vector elements) were assigned,
and returns a Dirichlet random variable generated by adding the prior to the sum
of each collection's occurrences, and simulating an alpha from a gamma distribution
with this shape parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dirch_from_allocations(C, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dirch_from_allocations_+3A_c">C</code></td>
<td>
<p>a vector giving different categories of individual
(not counts of categories - untabulated)</p>
</td></tr>
<tr><td><code id="dirch_from_allocations_+3A_lambda">lambda</code></td>
<td>
<p>priors for the categories</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The categories are labeled in C from 1 up to n.  n is the length of <code>lambda</code>,
which is a vector of priors. Note that all elements of <code>lambda</code>
must be strictly greater than 0.
</p>

<hr>
<h2 id='dirch_from_counts'>Given a vector of counts for different categories in 1...n and a prior,
simulate a Dirichlet random vector</h2><span id='topic+dirch_from_counts'></span>

<h3>Description</h3>

<p>Takes a vector of counts for 1:n collections,
and returns a Dirichlet random variable generated by adding the prior to each
collection value, and simulating an alpha from a gamma distribution
with this shape parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dirch_from_counts(C, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dirch_from_counts_+3A_c">C</code></td>
<td>
<p>a vector giving counts of categories</p>
</td></tr>
<tr><td><code id="dirch_from_counts_+3A_lambda">lambda</code></td>
<td>
<p>priors for the categories</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The categories are labeled in C from 1 up to n.  n is the length of <code>lambda</code>,
which is a vector of priors. Note that all elements of <code>lambda</code>
must be strictly greater than 0.
</p>

<hr>
<h2 id='geno_logL'>Calculate a matrix of genotype log-likelihoods for a genetic dataset</h2><span id='topic+geno_logL'></span>

<h3>Description</h3>

<p>Takes a list of key parameters from a genetic dataset, and calculates
the log-likelihood of each individual's genotype, given the allele counts
in each collection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geno_logL(par_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geno_logL_+3A_par_list">par_list</code></td>
<td>
<p>genetic data converted to the param_list format by <code>tcf2param_list</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Leave-One-Out cross-validation is used to avoid bias in log-likelihood for an
individual's known collection of origin
</p>


<h3>Value</h3>

<p><code>geno_logL</code> returns a matrix with C rows and I columns. Each column
represents an individual, and each row the log-likelihood of that individual's
genotype, given the allele counts in that collection
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(tcf2param_list)
ale_glL &lt;- geno_logL(ale_par_list)
</code></pre>

<hr>
<h2 id='geno_logL_ssq'>Calculate a matrix of sum-of-squares of genotype log-likelihoods for a genetic dataset</h2><span id='topic+geno_logL_ssq'></span>

<h3>Description</h3>

<p>Takes a list of key parameters from a genetic dataset, and calculates
the sum of squared log-likelihood of each individual's genotype, given the allele counts
in each collection. This is used for the quick-and-dirty Z-score calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geno_logL_ssq(par_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geno_logL_ssq_+3A_par_list">par_list</code></td>
<td>
<p>genetic data converted to the param_list format by <code>tcf2param_list</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Leave-One-Out cross-validation is used to avoid bias in log-likelihood for an
individual's known collection of origin
</p>


<h3>Value</h3>

<p><code>geno_logL</code> returns a matrix with C rows and I columns. Each column
represents an individual, and each row the log-likelihood of that individual's
genotype, given the allele counts in that collection
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(tcf2param_list)
ale_glL &lt;- geno_logL(ale_par_list)
</code></pre>

<hr>
<h2 id='get_ploidy_from_frame'>infer the ploidy from the pattern of NAs in the columns of data</h2><span id='topic+get_ploidy_from_frame'></span>

<h3>Description</h3>

<p>This is strictly internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ploidy_from_frame(tmp, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ploidy_from_frame_+3A_tmp">tmp</code></td>
<td>
<p>a data frame with 2 * L columns (two for each locus)</p>
</td></tr>
</table>

<hr>
<h2 id='gprob_sim_gc'>Simulate genotype log-likelihoods from a population by gene copy</h2><span id='topic+gprob_sim_gc'></span>

<h3>Description</h3>

<p>Takes a list of parameters from a genetic dataset, and returns a genotype log-likelihood
matrix for individuals simulated by gene copy from the specified collections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gprob_sim_gc(par_list, sim_colls)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gprob_sim_gc_+3A_par_list">par_list</code></td>
<td>
<p>genetic data converted to the param_list format by <code>tcf2param_list</code></p>
</td></tr>
<tr><td><code id="gprob_sim_gc_+3A_sim_colls">sim_colls</code></td>
<td>
<p>a vector of indices for the collections desired for simulation;
each element of the list corresponds to an individual</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In simulation by gene copy, the genotype at a locus for any individual is the result
of two random draws from the allele count matrix of that locus. Draws within an individual
are performed without replacement, but allele counts are replaced between individuals.
</p>


<h3>Value</h3>

<p><code>gprob_sim</code> returns a matrix of the summed log-likelihoods
for all loci of a simulated population mixture; columns represent individuals,
with each row containing their log-likelihood of belonging to the collection
of the same index, given the selection of two independent gene copies from the
desired collection of origin's reference allele frequencies
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(tcf2param_list)
sim_colls &lt;- sample(ale_par_list$C, 1070, replace = TRUE)
ale_sim_gprobs_gc &lt;- gprob_sim_gc(ale_par_list, sim_colls)
</code></pre>

<hr>
<h2 id='gprob_sim_gc_missing'>Simulate genotypes by gene copy, with missing data from chosen individuals</h2><span id='topic+gprob_sim_gc_missing'></span>

<h3>Description</h3>

<p>Takes a list of parameters from a genetic dataset, and returns a genotype log-likelihood
matrix for individuals simulated by gene copy from the specified collections, with
genotypes masked by missing data patterns from reference individuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gprob_sim_gc_missing(par_list, sim_colls, sim_missing)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gprob_sim_gc_missing_+3A_par_list">par_list</code></td>
<td>
<p>genetic data converted to the param_list format by <code>tcf2param_list</code></p>
</td></tr>
<tr><td><code id="gprob_sim_gc_missing_+3A_sim_colls">sim_colls</code></td>
<td>
<p>a vector; element i specifies the collection from which to sample
the genotypes for individual i</p>
</td></tr>
<tr><td><code id="gprob_sim_gc_missing_+3A_sim_missing">sim_missing</code></td>
<td>
<p>a vector; element i specifies the index for the individual in
params$I whose missing data should be copied for individual i</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In simulation by gene copy, the genotype at a locus for any individual is the result
of two random draws from the allele count matrix of that locus. Draws within an individual
are performed without replacement, but allele counts are replaced between individuals.
If the data at a particular locus is missing for individual i in <code>sim_missing</code>,
this data will also be missing in simulated individual i for the
log-likelihood calculation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# If one wanted to simulate the missing data patterns
# of a troublesome mixture dataset, one would run tcf2param_list,
# selecting samp_type = "mixture", then draw sim_miss from
# the mixture individual genotype list

# make a fake mixture data set to demonstrate...
drawn &lt;- mixture_draw(alewife, rhos = c(1/3, 1/3, 1/3),N = 100)
ref &lt;- drawn$reference
mix &lt;- drawn$mix

# then run it...
# we have to get the ploidies to pass to tcf2param_list
locnames &lt;- names(alewife)[-(1:16)][c(TRUE, FALSE)]
ploidies &lt;- rep(2, length(locnames))
names(ploidies) &lt;- locnames
params &lt;- tcf2param_list(rbind(ref,mix), 17, samp_type = "mixture", ploidies = ploidies)
sim_colls &lt;- sample(params$C, 1070, replace = TRUE)
sim_miss &lt;- sample(length(params$coll), 1070, replace = TRUE)
ale_sim_gprobs_miss &lt;- gprob_sim_gc_missing(params, sim_colls, sim_miss)
</code></pre>

<hr>
<h2 id='gprob_sim_ind'>Simulate genotype log-likelihoods from a population by individual</h2><span id='topic+gprob_sim_ind'></span>

<h3>Description</h3>

<p>Takes a list of parameters from a genetic dataset, and returns a genotype log-likelihood
matrix for individuals simulated by individual from the specified collections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gprob_sim_ind(par_list, sim_colls)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gprob_sim_ind_+3A_par_list">par_list</code></td>
<td>
<p>genetic data converted to the param_list format by <code>tcf2param_list</code></p>
</td></tr>
<tr><td><code id="gprob_sim_ind_+3A_sim_colls">sim_colls</code></td>
<td>
<p>a vector of indices for the collections desired for simulation;
each element of the list corresponds to an individual</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In simulation by individual, the genotype for any simulated individual is the
result of a single random draw from the genotypes of all individuals in the collection.
Gene copies and loci are therefore not independent.
</p>


<h3>Value</h3>

<p><code>gprob_sim</code> returns a matrix of the summed log-likelihoods
for all loci of a simulated population mixture; columns represent individuals,
with each row containing their log-likelihood of belonging to the collection
of the same index, given the selection of an individual's genotype from the
reference collection of interest. Selection at the locus and gene copy level
are not independent, and missing data is included in selection.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(tcf2param_list)
sim_colls &lt;- sample(ale_par_list$C, 1070, replace = TRUE)
ale_sim_gprobs_ind &lt;- gprob_sim_ind(ale_par_list, sim_colls)
</code></pre>

<hr>
<h2 id='gsi_em_1'>EM algorithm from the simplest GSI model for pi and the individual posterior probabilities</h2><span id='topic+gsi_em_1'></span>

<h3>Description</h3>

<p>Using a matrix of scaled likelihoods, this function does an EM algorithm to climb the
likelihood surface for pi, and computes the plug-in estimate of the posteriors
for all the individuals.  It returns the output in a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsi_em_1(SL, Pi_init, max_iterations, tolerance, return_progression)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsi_em_1_+3A_sl">SL</code></td>
<td>
<p>a matrix of the scaled likelihoods.  This is should have values for each individual in a column
(going down in the rows are values for different collections).</p>
</td></tr>
<tr><td><code id="gsi_em_1_+3A_pi_init">Pi_init</code></td>
<td>
<p>Starting value for the pi (collection mixture proportion) vector.</p>
</td></tr>
<tr><td><code id="gsi_em_1_+3A_max_iterations">max_iterations</code></td>
<td>
<p>the maximum total number of reps iterations to do.</p>
</td></tr>
<tr><td><code id="gsi_em_1_+3A_tolerance">tolerance</code></td>
<td>
<p>the EM-algorithm will be considered converged when the sum over the elements of pi of the absolute value
of the difference between the previous and the current estimate is less than tolerance.</p>
</td></tr>
<tr><td><code id="gsi_em_1_+3A_return_progression">return_progression</code></td>
<td>
<p>If true, then the pi_trace component of the output shows the value of pi visited en route to the end.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gsi_em_1</code> returns a final Maximum-Likelihood estimate for pi and PofZ,
as well as the number of iterations needed to reach convergence (&quot;iterations_performed&quot;),
and traces of the pi values and change in pi in each iteration
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this is shown with a scaled likelihood matrix from self-assignment
# of the reference individuals

# we have to get the ploidies to pass to tcf2param_list
locnames &lt;- names(alewife)[-(1:16)][c(TRUE, FALSE)]
ploidies &lt;- rep(2, length(locnames))
names(ploidies) &lt;- locnames
params &lt;- tcf2param_list(alewife, 17, ploidies = ploidies)
logl &lt;- geno_logL(params)
SL &lt;- apply(exp(logl), 2, function(x) x/sum(x))
test_em &lt;- gsi_em_1(SL,
                    rep(1/params$C, params$C),
                    max_iterations = 10^6,
                    tolerance = 10^-7,
                    return_progression = TRUE)
</code></pre>

<hr>
<h2 id='gsi_mcmc_1'>MCMC from the simplest GSI model for pi and the individual posterior probabilities</h2><span id='topic+gsi_mcmc_1'></span>

<h3>Description</h3>

<p>Using a matrix of scaled likelihoods, this function samples values of pi and the posteriors
for all the individuals.  It returns the output in a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsi_mcmc_1(SL, Pi_init, lambda, reps, burn_in, sample_int_Pi, sample_int_PofZ)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsi_mcmc_1_+3A_sl">SL</code></td>
<td>
<p>matrix of the scaled likelihoods.  This is should have values for each individual in a column
(going down in the rows are values for different populations).</p>
</td></tr>
<tr><td><code id="gsi_mcmc_1_+3A_pi_init">Pi_init</code></td>
<td>
<p>Starting value for the pi (collection mixture proportion) vector.</p>
</td></tr>
<tr><td><code id="gsi_mcmc_1_+3A_lambda">lambda</code></td>
<td>
<p>the prior to be added to the collection allocations, in order to
generate pseudo-count Dirichlet parameters for the simulation of a new pi vector</p>
</td></tr>
<tr><td><code id="gsi_mcmc_1_+3A_reps">reps</code></td>
<td>
<p>total number of reps (sweeps) to do.</p>
</td></tr>
<tr><td><code id="gsi_mcmc_1_+3A_burn_in">burn_in</code></td>
<td>
<p>how many reps to discard in the beginning when doing the mean calculation. They will still be
returned in the traces if desired</p>
</td></tr>
<tr><td><code id="gsi_mcmc_1_+3A_sample_int_pi">sample_int_Pi</code></td>
<td>
<p>the number of reps between samples being taken for Pi traces.  If 0 no trace samples are taken</p>
</td></tr>
<tr><td><code id="gsi_mcmc_1_+3A_sample_int_pofz">sample_int_PofZ</code></td>
<td>
<p>the number of reps between samples being taken for the traces of posterior of each individual's origin. If 0
no trace samples are taken.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gsi_mcmc_1</code> returns a list of three. <code>$mean</code> lists the posterior
means for collection proportions <code>pi</code> and for the individual posterior
probabilities of assignment <code>PofZ</code>. <code>$sd</code> returns the posterior standard
deviations for the same values.
</p>
<p>If the corresponding <code>sample_int</code> variables are not 0, <code>$trace</code> contains
samples taken from the Markov chain at intervals of <code>sample_int_</code>(variable) steps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this demonstrates it with scaled likelihoods computed from
# assignment of the reference samples

# we have to get the ploidies to pass to tcf2param_list
locnames &lt;- names(alewife)[-(1:16)][c(TRUE, FALSE)]
ploidies &lt;- rep(2, length(locnames))
names(ploidies) &lt;- locnames

params &lt;- tcf2param_list(alewife, 17, ploidies = ploidies)
logl &lt;- geno_logL(params)
SL &lt;- apply(exp(logl), 2, function(x) x/sum(x))
lambda &lt;- rep(1/params$C, params$C)
mcmc &lt;- gsi_mcmc_1(SL, lambda, lambda, 200, 50, 5, 5)
</code></pre>

<hr>
<h2 id='gsi_mcmc_fb'>MCMC from the fully Bayesian GSI model for pi and the individual posterior probabilities</h2><span id='topic+gsi_mcmc_fb'></span>

<h3>Description</h3>

<p>Given a list of key parameters from a genetic dataset, this function samples values of pi
and the posteriors for all the individuals. Each MCMC iteration includes a recalculation
of the scaled genotype likelihood matrix, with baseline allele frequencies updated
based on the previous iteration's allocations. It returns the output in a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsi_mcmc_fb(
  par_list,
  Pi_init,
  lambda,
  reps,
  burn_in,
  sample_int_Pi,
  sample_int_PofZ
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsi_mcmc_fb_+3A_par_list">par_list</code></td>
<td>
<p>genetic data converted to the param_list format by <code>tcf2param_list</code></p>
</td></tr>
<tr><td><code id="gsi_mcmc_fb_+3A_pi_init">Pi_init</code></td>
<td>
<p>Starting value for the pi (collection mixture proportion) vector.</p>
</td></tr>
<tr><td><code id="gsi_mcmc_fb_+3A_lambda">lambda</code></td>
<td>
<p>the prior to be added to the collection allocations, in order to
generate pseudo-count Dirichlet parameters for the simulation of a new pi vector</p>
</td></tr>
<tr><td><code id="gsi_mcmc_fb_+3A_reps">reps</code></td>
<td>
<p>total number of reps (sweeps) to do.</p>
</td></tr>
<tr><td><code id="gsi_mcmc_fb_+3A_burn_in">burn_in</code></td>
<td>
<p>how many reps to discard in the beginning when doing the mean calculation. They will still be
returned in the traces if desired</p>
</td></tr>
<tr><td><code id="gsi_mcmc_fb_+3A_sample_int_pi">sample_int_Pi</code></td>
<td>
<p>the number of reps between samples being taken for Pi traces.  If 0 no trace samples are taken</p>
</td></tr>
<tr><td><code id="gsi_mcmc_fb_+3A_sample_int_pofz">sample_int_PofZ</code></td>
<td>
<p>the number of reps between samples being taken for the traces of posterior of each individual's origin. If 0
no trace samples are taken.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gsi_mcmc_fb</code> returns a list of three. <code>$mean</code> lists the posterior
means for collection proportions <code>pi</code>, for the individual posterior
probabilities of assignment <code>PofZ</code>, and for the allele frequencies <code>theta</code>.
<code>$sd</code> returns the posterior standard deviations for the same values.
</p>
<p>If the corresponding <code>sample_int</code> variables are not 0, <code>$trace</code> contains
samples taken from the Markov chain at intervals of <code>sample_int_</code>(variable) steps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this demonstrates it with scaled likelihoods computed from
# assignment of the reference samples

# we have to get the ploidies to pass to tcf2param_list
locnames &lt;- names(alewife)[-(1:16)][c(TRUE, FALSE)]
ploidies &lt;- rep(2, length(locnames))
names(ploidies) &lt;- locnames

params &lt;- tcf2param_list(alewife, 17, ploidies = ploidies)
lambda &lt;- rep(1/params$C, params$C)
# use very short run and burn in so it doesn't take too long
# when checking on CRAN
mcmc &lt;- gsi_mcmc_fb(params, lambda, lambda, 20, 5, 4, 4)
</code></pre>

<hr>
<h2 id='Hasselman_sim_colls'>Generate a random population structure and mixture sample, as in
Hasselman <em>et al.</em> 2015</h2><span id='topic+Hasselman_sim_colls'></span>

<h3>Description</h3>

<p>Creates random reporting unit (rho) and collection (omega) proportions, and a
<code>sim_colls</code> vector for simulation of individual genotypes, based on the methods
used in Hasselman <em>et al.</em> (2015)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hasselman_sim_colls(RU_starts, RU_vec, size = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hasselman_sim_colls_+3A_ru_starts">RU_starts</code></td>
<td>
<p>a vector delineating the reporting units in <code>RU_vec</code>;
generated by <code>tcf2param_list</code></p>
</td></tr>
<tr><td><code id="Hasselman_sim_colls_+3A_ru_vec">RU_vec</code></td>
<td>
<p>a vector of collection indices, grouped by reporting unit;
generated by <code>tcf2param_list</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed specifically to recreate the simulations in Hasselman
<em>et al.</em> (2015), to check for the bias that was observed therein.
Rho (reporting unit proportions) is chosen with alphas of 1.5,
and omega (collection proportions) chosen with the same alpha, then scaled by the
corresponding rho.
</p>


<h3>Value</h3>

<p><code>Hasselman_sim_colls</code> returns a list with three elements.
The first two are a rho vector and an omega vector, respectively,
both with alpha parameters = 1.5. The third is a vector of origins for
simulated individuals, sampled from the collections with probabilities = omega
</p>

<hr>
<h2 id='infer_mixture'>Estimate mixing proportions and origin probabilities from one or several mixtures</h2><span id='topic+infer_mixture'></span>

<h3>Description</h3>

<p>Takes a mixture and reference dataframe of two-column genetic data, and a
desired method of estimation for the population mixture proportions (MCMC, PB, BR).
Returns the output of the chosen estimation method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infer_mixture(
  reference,
  mixture,
  gen_start_col,
  method = "MCMC",
  alle_freq_prior = list(const_scaled = 1),
  pi_prior = NA,
  pi_init = NULL,
  reps = 2000,
  burn_in = 100,
  pb_iter = 100,
  prelim_reps = NULL,
  prelim_burn_in = NULL,
  sample_int_Pi = 1,
  sample_theta = TRUE,
  pi_prior_sum = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infer_mixture_+3A_reference">reference</code></td>
<td>
<p>a dataframe of two-column genetic format data, proceeded by &quot;repunit&quot;, &quot;collection&quot;,
and &quot;indiv&quot; columns. Does not need &quot;sample_type&quot; column, and will be overwritten if provided</p>
</td></tr>
<tr><td><code id="infer_mixture_+3A_mixture">mixture</code></td>
<td>
<p>a dataframe of two-column genetic format data. Must have the same structure as
<code>reference</code> dataframe, but &quot;collection&quot; and &quot;repunit&quot; columns are ignored.
Does not need &quot;sample_type&quot; column, and will be overwritten if provided</p>
</td></tr>
<tr><td><code id="infer_mixture_+3A_gen_start_col">gen_start_col</code></td>
<td>
<p>the first column of genetic data in both data frames</p>
</td></tr>
<tr><td><code id="infer_mixture_+3A_method">method</code></td>
<td>
<p>a choice between &quot;MCMC&quot;, &quot;PB&quot;, &quot;BR&quot; methods for estimating mixture proportions</p>
</td></tr>
<tr><td><code id="infer_mixture_+3A_alle_freq_prior">alle_freq_prior</code></td>
<td>
<p>a one-element named list specifying the prior to be used when
generating Dirichlet parameters for genotype likelihood calculations. Valid methods include
<code>"const"</code>, <code>"scaled_const"</code>, and <code>"empirical"</code>. See <code>?list_diploid_params</code>
for method details.</p>
</td></tr>
<tr><td><code id="infer_mixture_+3A_pi_prior">pi_prior</code></td>
<td>
<p>The prior to be added to the collection allocations, in order to generate pseudo-count
Dirichlet parameters for the simulation of new pi vectors in MCMC. Default value of NA leads to the
calculation of a symmetrical prior based on <code>pi_prior_sum</code>. To provide other values to
certain collections, you can pass in a data frame with two columns, &quot;collection&quot;
listing the relevant collection, and &quot;pi_param&quot; listing the desired prior for that collection.
Specific priors may be listed for as few as one collection. The special collection name &quot;DEFAULT_PI&quot;
is used to set the prior for all collections not explicitly listed; if no &quot;DEFAULT_PI&quot; is given, it is
taken to be 1/(# collections).</p>
</td></tr>
<tr><td><code id="infer_mixture_+3A_pi_init">pi_init</code></td>
<td>
<p>The initial value to use for the mixing proportion of collections.  This lets
the user start the chain from a specific value of the mixing proportion vector.  If pi_init is NULL
(the default) then the mixing proportions are all initialized to be equal.  Otherwise, you pass
in a data frame with one column named &quot;collection&quot; and the other named &quot;pi_init&quot;.  Every value in the
pi_init column must be strictly positive (&gt; 0), and a value must be given for every collection.  If they sum
to more than one the values will be normalized to sum to one.</p>
</td></tr>
<tr><td><code id="infer_mixture_+3A_reps">reps</code></td>
<td>
<p>the number of iterations to be performed in MCMC</p>
</td></tr>
<tr><td><code id="infer_mixture_+3A_burn_in">burn_in</code></td>
<td>
<p>how many reps to discard in the beginning of MCMC when doing the mean calculation.
They will still be returned in the traces if desired.</p>
</td></tr>
<tr><td><code id="infer_mixture_+3A_pb_iter">pb_iter</code></td>
<td>
<p>how many bootstrapped data sets to do for bootstrap correction using method PB.  Default
is 100.</p>
</td></tr>
<tr><td><code id="infer_mixture_+3A_prelim_reps">prelim_reps</code></td>
<td>
<p>for method &quot;BR&quot;, the number of reps of conditional MCMC (as in method &quot;MCMC&quot;)
to perform prior to MCMC with baseline resampling. The posterior mean of mixing proportions
from this conditional MCMC is then used as <code>pi_init</code> in the baseline resampling MCMC.</p>
</td></tr>
<tr><td><code id="infer_mixture_+3A_prelim_burn_in">prelim_burn_in</code></td>
<td>
<p>for method &quot;BR&quot;, this sets the number of sweeps out of <code>prelim_reps</code>
that should be discarded as burn in when preparing the posterior means of the mixing
proportions to be set as <code>pi_init</code> in the baseline resampling MCMC.</p>
</td></tr>
<tr><td><code id="infer_mixture_+3A_sample_int_pi">sample_int_Pi</code></td>
<td>
<p>how many iterations between storing the mixing proportions trace. Default is 1.
Can't be 0. Can't be so large that fewer than 10 samples are taken from the burn in and the sweeps.</p>
</td></tr>
<tr><td><code id="infer_mixture_+3A_sample_theta">sample_theta</code></td>
<td>
<p>for method &quot;BR&quot;, whether or not the function should store the posterior mean
of the updated allele frequences. Default is TRUE</p>
</td></tr>
<tr><td><code id="infer_mixture_+3A_pi_prior_sum">pi_prior_sum</code></td>
<td>
<p>For <code>pi_prior = NA</code>, the prior on the mixing proportions is set
as a Dirichlet vector of length C, with each element being W/C, where W is the pi_prior_sum
and C is the number of collections. By default this is 1.  If it is made much smaller than 1, things
could start to mix more poorly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;MCMC&quot; estimates mixing proportions and individual posterior
probabilities of assignment through Markov-chain Monte Carlo
conditional on the reference allele frequencies,
while &quot;PB&quot; does the same with a parametric bootstrapping correction,
and &quot;BR&quot; runs MCMC sweeps while simulating reference allele frequencies
using the genotypes of mixture individuals and allocations from the previous sweep.
All methods default to a uniform 1/(# collections or RUs) prior for the mixing proportions.
</p>


<h3>Value</h3>

<p>Tidy data frames in a list with the following components:
mixing_proportions: the estimated mixing proportions of the different collections.
indiv_posteriors: the posterior probs of fish being from each of the collections.
mix_prop_traces: the traces of the mixing proportions.  Useful for computing credible intervals.
bootstrapped_proportions: If using method &quot;PB&quot; this returns the bootstrap corrected
reporting unit proportions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mcmc &lt;- infer_mixture(reference = small_chinook_ref,
                      mixture = small_chinook_mix,
                      gen_start_col = 5,
                      method = "MCMC",
                      reps  = 200)
</code></pre>

<hr>
<h2 id='list_diploid_params'>Collect essential data values before mixture proportion estimation</h2><span id='topic+list_diploid_params'></span>

<h3>Description</h3>

<p>Takes all relevant information created in previous steps of data conversion pipeline,
and combines into a single list which serves as input for further calculations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_diploid_params(
  AC_list,
  I_list,
  PO,
  coll_N,
  RU_vec,
  RU_starts,
  alle_freq_prior = list(const_scaled = 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_diploid_params_+3A_ac_list">AC_list</code></td>
<td>
<p>a list of allele count matrices; output from <code>a_freq_list</code></p>
</td></tr>
<tr><td><code id="list_diploid_params_+3A_i_list">I_list</code></td>
<td>
<p>a list of genotype vectors; output from <code>allelic_list</code></p>
</td></tr>
<tr><td><code id="list_diploid_params_+3A_po">PO</code></td>
<td>
<p>a vector of collection (population of origin) indices
for every individual in the sample, in order identical to <code>I_list</code></p>
</td></tr>
<tr><td><code id="list_diploid_params_+3A_coll_n">coll_N</code></td>
<td>
<p>a vector of the total number of individuals in each collection,
in order of appearance in the dataset</p>
</td></tr>
<tr><td><code id="list_diploid_params_+3A_ru_vec">RU_vec</code></td>
<td>
<p>a vector of collection indices, sorted by reporting unit</p>
</td></tr>
<tr><td><code id="list_diploid_params_+3A_ru_starts">RU_starts</code></td>
<td>
<p>a vector of indices, designating the first collection for each
reporting unit in RU_vec</p>
</td></tr>
<tr><td><code id="list_diploid_params_+3A_alle_freq_prior">alle_freq_prior</code></td>
<td>
<p>a one-element named list specifying the prior to be used when
generating Dirichlet parameters for genotype likelihood calculations. The name of the
list item determines the type of prior used, with options <code>"const"</code>, <code>"scaled_const"</code>,
and <code>"empirical"</code>. If <code>"const"</code>, the listed number will be taken as a constant
added to the count for each allele, locus, and collection.
If <code>"scaled_const"</code>, the listed number will be divided by the number of alleles at a locus,
then added to the allele counts. If <code>"empirical"</code>, the listed number will be multiplied
by the relative frequency of each allele across all populations, then added to the allele counts.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Genotypes represented in <code>I_list</code> are converted into a single long vector,
ordered by locus, individual, and gene copy, with <code>NA</code> values represented as 0s.
Similarly, <code>AC_list</code> is unlisted to <code>AC</code>, ordered by locus, collection,
and allele. <code>DP</code> is a list of Dirichlet priors for likelihood calculations, created
by adding the values calculated from <code>alle_freq_prior</code> to each allele
<code>sum_AC</code> and <code>sum_DP</code> are the summed allele values for each locus
of their parent vectors, ordered by locus and collection.
</p>


<h3>Value</h3>

<p><code>list_diploid_params</code> returns a list of the information necessary
for the calculation of genotype likelihoods in MCMC:
</p>
<p><code>L</code>, <code>N</code>, and <code>C</code> represent the number of loci, individual genotypes,
and collections, respectively. <code>A</code> is a vector of the number of alleles at each
locus, and <code>CA</code> is the cumulative sum of <code>A</code>. <code>coll</code>, <code>coll_N</code>,
<code>RU_vec</code>, and <code>RU_starts</code> are copied directly from input.
</p>
<p><code>I</code>, <code>AC</code>, <code>sum_AC</code>, <code>DP</code>, and <code>sum_DP</code> are vectorized
versions of data previously represented as lists and matrices; indexing macros
use <code>L</code>, <code>N</code>, <code>C</code>, <code>A</code>, and <code>CA</code> to access these vectors
in later Rcpp-based calculations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(allelic_list)
PO &lt;- as.integer(factor(ale_long$clean_short$collection))
coll_N &lt;- as.vector(table(PO))

Colls_by_RU &lt;- dplyr::count(ale_long$clean_short, repunit, collection) %&gt;%
   dplyr::filter(n &gt; 0) %&gt;%
   dplyr::select(-n)
 PC &lt;- rep(0, length(unique((Colls_by_RU$repunit))))
 for(i in 1:nrow(Colls_by_RU)) {
   PC[Colls_by_RU$repunit[i]] &lt;- PC[Colls_by_RU$repunit[i]] + 1
 }
RU_starts &lt;- c(0, cumsum(PC))
RU_vec &lt;- as.integer(Colls_by_RU$collection)
param_list &lt;- list_diploid_params(ale_ac, ale_alle_list, PO, coll_N, RU_vec, RU_starts)

</code></pre>

<hr>
<h2 id='mixture_draw'>Separate a chosen proportion of a reference dataset into a mixture with known population proportions</h2><span id='topic+mixture_draw'></span>

<h3>Description</h3>

<p>Takes a reference dataset and a set of population proportions, either at the collection
or reporting unit level. Randomly samples individuals to satisfy these desired proportions,
and splits them into a new &quot;mixture&quot; dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixture_draw(D, rhos = NULL, omegas = NULL, N, min_remaining = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixture_draw_+3A_d">D</code></td>
<td>
<p>a two-column genetic dataframe with &quot;indiv&quot;, &quot;repunit&quot;, and &quot;collection&quot; columns</p>
</td></tr>
<tr><td><code id="mixture_draw_+3A_rhos">rhos</code></td>
<td>
<p>a vector of the desired reporting unit proportions in the mixture set;
if not named, will be assumed to be ordered by order of appearance in the dataset</p>
</td></tr>
<tr><td><code id="mixture_draw_+3A_omegas">omegas</code></td>
<td>
<p>the desired collection proportions in the mixture set</p>
</td></tr>
<tr><td><code id="mixture_draw_+3A_n">N</code></td>
<td>
<p>the total size of the mixture set</p>
</td></tr>
<tr><td><code id="mixture_draw_+3A_min_remaining">min_remaining</code></td>
<td>
<p>the fraction of any collection in the reference dataset which must remain
at the end of the draw</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mixture_draw</code> returns a list of two data frames,
&quot;mixture&quot; being the random sample taken, and &quot;reference&quot; being the remaining samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rhos &lt;- as.vector(gtools::rdirichlet(1, table(alewife$repunit)))
cross_val &lt;- mixture_draw(D = alewife, rhos = rhos, N = 100, min_remaining = .005)

</code></pre>

<hr>
<h2 id='modify_scaled_likelihoods_for_known_mixture_fish'>for individuals of known origin in the mixture, put all their weight on their known collection</h2><span id='topic+modify_scaled_likelihoods_for_known_mixture_fish'></span>

<h3>Description</h3>

<p>This is used internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify_scaled_likelihoods_for_known_mixture_fish(SL, KC, CFL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modify_scaled_likelihoods_for_known_mixture_fish_+3A_sl">SL</code></td>
<td>
<p>the matrix of scaled likelihoods.</p>
</td></tr>
<tr><td><code id="modify_scaled_likelihoods_for_known_mixture_fish_+3A_kc">KC</code></td>
<td>
<p>a character vector of collections that the individuals belong to (or NA if you
don't know where they come from).  If this is NULL, then SL just gets returned untouched.</p>
</td></tr>
<tr><td><code id="modify_scaled_likelihoods_for_known_mixture_fish_+3A_cfl">CFL</code></td>
<td>
<p>the levels of the collections factor (which is within clean$short)</p>
</td></tr>
</table>

<hr>
<h2 id='per_locus_means_and_vars'>Compute the mean and variance of the single-locus genotype likelihoods for each collection</h2><span id='topic+per_locus_means_and_vars'></span>

<h3>Description</h3>

<p>This assumes that you have compiled params for a reference data set and then it just
calls rcpp_per_locus and then summarizes the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>per_locus_means_and_vars(par_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="per_locus_means_and_vars_+3A_par_list">par_list</code></td>
<td>
<p>genetic data converted to the param_list format by <code>tcf2param_list</code>. This should be
include genotypes only for the reference individuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with two components, mean and var, each one a matrix that has
C (number of collections) rows and L (number of loci) columns, giving the mean (or variance)
of the genotype likelihoods in the individuals in that collection at that locus.
</p>

<hr>
<h2 id='perfect_chinook'>perfect-assignment genetic data for chinook.</h2><span id='topic+perfect_chinook'></span>

<h3>Description</h3>

<p>This is just like the <code><a href="#topic+chinook">chinook</a></code> data, but only has 7 loci and all loci are
fixed in fortuitous patterns so that every single collection is easily resolved.  This is
primarily useful for testing purposes.
</p>


<h3>Source</h3>

<p>Made it up!
</p>

<hr>
<h2 id='perfect_chinook_mix'>perfect-assignment mixture genetic data for chinook.</h2><span id='topic+perfect_chinook_mix'></span>

<h3>Description</h3>

<p>This is similar to the <code><a href="#topic+chinook_mix">chinook_mix</a></code> data, but only has 7 loci and all loci are
fixed in fortuitous patterns so that every single collection is easily resolved.  This is
primarily useful for testing purposes.  The name of the individual has its collection
inside the colons.
</p>


<h3>Source</h3>

<p>Made it up!
</p>

<hr>
<h2 id='rcpp_close_matchers'>Find all pairs that have close matches</h2><span id='topic+rcpp_close_matchers'></span>

<h3>Description</h3>

<p>Find all pairs that have close matches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_close_matchers(par_list, non_miss_fract, match_fract)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_close_matchers_+3A_par_list">par_list</code></td>
<td>
<p>genetic data converted to the param_list format by <code>tcf2param_list</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Gotta say more
</p>


<h3>Examples</h3>

<pre><code class='language-R'># gotta do something here too
</code></pre>

<hr>
<h2 id='rcpp_indiv_specific_logl_means_and_vars'>From the pattern of missing data at each individual, compute the expected mean and variance of the logl</h2><span id='topic+rcpp_indiv_specific_logl_means_and_vars'></span>

<h3>Description</h3>

<p>This takes a param_list so that it has access to individual genotypes (and hence can cycle through them
and know which are missing and which are not.)  It also takes a matrix of per-locus logl means
and variances like what is computed by <code><a href="#topic+per_locus_means_and_vars">per_locus_means_and_vars</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_indiv_specific_logl_means_and_vars(par_list, MV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_indiv_specific_logl_means_and_vars_+3A_par_list">par_list</code></td>
<td>
<p>genetic data converted to the param_list format by <code>tcf2param_list</code></p>
</td></tr>
<tr><td><code id="rcpp_indiv_specific_logl_means_and_vars_+3A_mv">MV</code></td>
<td>
<p>a list of two matrices, one of means and the other of variances, which are C x L
matrices.  This is basically the list that is returned by <code><a href="#topic+per_locus_means_and_vars">per_locus_means_and_vars</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function doesn't do any checking to assure that the par_list and the per-locus logl means
matrix are made for one another.  (i.e. use the same collections in the same order.)
</p>


<h3>Value</h3>

<p>a matrix with C rows and I columns. Each row
represents a collection, and each column an individual.
</p>

<hr>
<h2 id='rcpp_per_locus_logls'>Return a matrix of locus-specific self-assignment logls</h2><span id='topic+rcpp_per_locus_logls'></span>

<h3>Description</h3>

<p>Takes a list of key parameters from a genetic dataset, and calculates
the log-likelihood of each individual's single-locus genotype, given the allele counts
in the individual's collection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_per_locus_logls(par_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_per_locus_logls_+3A_par_list">par_list</code></td>
<td>
<p>genetic data converted to the param_list format by <code>tcf2param_list</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This uses Leave-One-Out cross-validation is used to avoid bias in log-likelihood for an
individual's known collection of origin
</p>


<h3>Value</h3>

<p><code>rcpp_per_locus_logls</code> returns a matrix with I rows and L columns. Each row
represents an individual, and each column a locus. Note that missing data at a locus
returns a zero.  That should be changed to NA later.
</p>

<hr>
<h2 id='read_gsi_sim'>read a gsi_sim formatted input file into a tibble that rubias can use</h2><span id='topic+read_gsi_sim'></span>

<h3>Description</h3>

<p>Note that this relies on a system call to awk.  It probably won't work
on Windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_gsi_sim(path, sample_type, repunits = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_gsi_sim_+3A_path">path</code></td>
<td>
<p>path to the gsi_sim file</p>
</td></tr>
<tr><td><code id="read_gsi_sim_+3A_sample_type">sample_type</code></td>
<td>
<p>should be &quot;reference&quot; or &quot;mixture&quot; depending on what kind of file it is</p>
</td></tr>
<tr><td><code id="read_gsi_sim_+3A_repunits">repunits</code></td>
<td>
<p>the gsi_sim reporting units file.  Has no effect if sample_type is &quot;mixture&quot;.  If
sample_type is &quot;reference&quot; and this is left as NULL, then all collections will be put in the the
&quot;default_repu&quot;.</p>
</td></tr>
</table>

<hr>
<h2 id='ref_and_mix_pipeline'>Estimate mixing proportions from reference and mixture datasets</h2><span id='topic+ref_and_mix_pipeline'></span>

<h3>Description</h3>

<p>Takes a mixture and reference dataframe of two-column genetic data, and a
desired method of estimation for the population mixture proportions (MCMC, PB, or BH MCMC)
Returns the output of the chosen estimation method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ref_and_mix_pipeline(
  reference,
  mixture,
  gen_start_col,
  method = "MCMC",
  reps = 2000,
  burn_in = 100,
  sample_int_Pi = 0,
  sample_int_PofZ = 0,
  sample_int_omega = 0,
  sample_int_rho = 0,
  sample_int_PofR = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ref_and_mix_pipeline_+3A_reference">reference</code></td>
<td>
<p>a dataframe of two-column genetic format data, proceeded by &quot;repunit&quot;, &quot;collection&quot;,
and &quot;indiv&quot; columns. Does not need &quot;sample_type&quot; column, and will be overwritten if provided</p>
</td></tr>
<tr><td><code id="ref_and_mix_pipeline_+3A_mixture">mixture</code></td>
<td>
<p>a dataframe of two-column genetic format data. Must have the same structure as
<code>reference</code> dataframe, but &quot;collection&quot; and &quot;repunit&quot; columns are ignored.
Does not need &quot;sample_type&quot; column, and will be overwritten if provided</p>
</td></tr>
<tr><td><code id="ref_and_mix_pipeline_+3A_gen_start_col">gen_start_col</code></td>
<td>
<p>the first column of genetic data in both data frames</p>
</td></tr>
<tr><td><code id="ref_and_mix_pipeline_+3A_method">method</code></td>
<td>
<p>this must be &quot;MCMC&quot;.   &quot;PB&quot; and &quot;BH&quot; are no longer supported in this function.</p>
</td></tr>
<tr><td><code id="ref_and_mix_pipeline_+3A_reps">reps</code></td>
<td>
<p>the number of iterations to be performed in MCMC</p>
</td></tr>
<tr><td><code id="ref_and_mix_pipeline_+3A_burn_in">burn_in</code></td>
<td>
<p>how many reps to discard in the beginning of MCMC when doing the mean calculation.
They will still be returned in the traces if desired.</p>
</td></tr>
<tr><td><code id="ref_and_mix_pipeline_+3A_sample_int_pi">sample_int_Pi</code></td>
<td>
<p>the number of reps between samples being taken for pi traces. If 0
no traces are taken. Only used in methods &quot;MCMC&quot; and &quot;PB&quot;.</p>
</td></tr>
<tr><td><code id="ref_and_mix_pipeline_+3A_sample_int_pofz">sample_int_PofZ</code></td>
<td>
<p>the number of reps between samples being taken for the posterior
traces of each individual's collection of origin. If 0 no trace samples are taken.
Used in all methods</p>
</td></tr>
<tr><td><code id="ref_and_mix_pipeline_+3A_sample_int_omega">sample_int_omega</code></td>
<td>
<p>the number of reps between samples being taken for
collection proportion traces. If 0 no traces are taken. Only used in method &quot;BH&quot;</p>
</td></tr>
<tr><td><code id="ref_and_mix_pipeline_+3A_sample_int_rho">sample_int_rho</code></td>
<td>
<p>the number of reps between samples being taken for
reporting unit proportion  traces. If 0 no traces are taken. Only used in method &quot;BH&quot;</p>
</td></tr>
<tr><td><code id="ref_and_mix_pipeline_+3A_sample_int_pofr">sample_int_PofR</code></td>
<td>
<p>the number of reps between samples being taken for the posterior
traces of each individual's reporting unit of origin. If 0 no trace samples are taken.
Only used in method &quot;BH&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;MCMC&quot; estimates mixing proportions and individual posterior
probabilities of assignment through Markov-chain Monte Carlo,
while &quot;PB&quot; does the same with a parametric bootstrapping correction,
and &quot;BH&quot; uses the misassignment-scaled, hierarchical MCMC.
All methods use a uniform 1/(# collections or RUs) prior for pi/omega and rho.
</p>


<h3>Value</h3>

<p><code>mix_proportion_pipeline</code> returns the standard output of the chosen
mixing proportion estimation method (always a list). For method &quot;PB&quot;,
returns the standard MCMC results, as well as the bootstrap-corrected
collection proportions under <code>$mean$bootstrap</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reference &lt;- small_chinook_ref
mixture &lt;- small_chinook_mix
gen_start_col &lt;- 5

# this function expects things as factors.  This function is old and needs
# to be replaced and deprecated.

reference$repunit &lt;- factor(reference$repunit, levels = unique(reference$repunit))
reference$collection &lt;- factor(reference$collection, levels = unique(reference$collection))
mixture$repunit &lt;- factor(mixture$repunit, levels = unique(mixture$repunit))
mixture$collection &lt;- factor(mixture$collection, levels = unique(mixture$collection))

mcmc &lt;- ref_and_mix_pipeline(reference, mixture, gen_start_col, method = "MCMC")

</code></pre>

<hr>
<h2 id='reference_allele_counts'>Tabulate occurrences of all observed alleles in reference genetic data</h2><span id='topic+reference_allele_counts'></span>

<h3>Description</h3>

<p>Takes the first output of <code>tcf2long</code>, along with two columns named &quot;collection&quot; and &quot;sample_type&quot;,
and returns a data frame of allele counts for each locus within each reference population.
Alleles to be counted are identified from both reference and mixture populations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reference_allele_counts(D, pop_level = "collection")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reference_allele_counts_+3A_d">D</code></td>
<td>
<p>A data frame containing, at minimum, a column of sample group identifiers named
&quot;collection&quot;, a column designating each row as &quot;reference&quot; or &quot;mixture&quot;, named &quot;sample_type&quot;,
and (from tcf2long output) locus, gene copy, and observed alleles. If higher-level reporting
unit counts are desired, must have a column of reporting unit identifiers named &quot;repunit&quot;</p>
</td></tr>
<tr><td><code id="reference_allele_counts_+3A_pop_level">pop_level</code></td>
<td>
<p>a character vector expressing the population level for which allele counts
should be tabulated. Set to &quot;collection&quot; for collection/underlying sample group (default),
or &quot;repunit&quot; for reporting unit/overlying sample groups</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;collection&quot; column should be a key assigning samples to the desired groups,
e.g. collection site, run time, year.
The &quot;sample_type&quot; column must contain either &quot;reference&quot; or &quot;mixture&quot; for each sample.
</p>


<h3>Value</h3>

<p><code>reference_allele_counts</code> returns a long-format dataframe, with count data for
each collection, locus, and allele. Counts are only drawn from &quot;reference&quot; samples; alleles
unique to the &quot;mixture&quot; samples will still appear in the list, but will have 0s for all groups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## count alleles in alewife reference populations
example(tcf2long)  # gets variable ale_long
ale_rac &lt;- reference_allele_counts(ale_long$long)

</code></pre>

<hr>
<h2 id='round2'>Round a given number, with 5 always rounded up</h2><span id='topic+round2'></span>

<h3>Description</h3>

<p>Given a number and a digit to round to, returns the rounded number,
with 5 always rounded upwards.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round2(x, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="round2_+3A_x">x</code></td>
<td>
<p>the data to be rounded</p>
</td></tr>
<tr><td><code id="round2_+3A_n">n</code></td>
<td>
<p>the number of digits to round to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function differs from <code>round</code>, which rounds 5 &quot;towards the
even number&quot;. Rounding 5s up leads to bias when positive and negative numbers
are expected, but can be desired in some cases.
</p>

<hr>
<h2 id='rubias'>rubias: Bayesian inference from the conditional genetic stock identification model</h2><span id='topic+rubias'></span>

<h3>Description</h3>

<p>Read the &quot;rubias-overview&quot; vignette for information on data input formats
and how to use the package
</p>


<h3>the <code>rubias</code> main high-level functions</h3>

<p>The following functions are wrappers, designed for user-friendly input and useful output:
</p>
<p><code><a href="#topic+infer_mixture">infer_mixture</a></code> is used to perform genetic stock identification.
Options include standard MCMC and the parametric bootstrap bias correction.
</p>
<p><code><a href="#topic+self_assign">self_assign</a></code> does simple self-assignment of individuals in a reference data set
to the various collections in the reference data set.
</p>
<p><code><a href="#topic+assess_reference_loo">assess_reference_loo</a></code> does leave-one-out based simulations to predict how
accurately GSI can be done.
</p>
<p><code><a href="#topic+assess_reference_mc">assess_reference_mc</a></code> uses Monte-Carlo cross-validation based simulations
to predict how accurately GSI can be done.
</p>
<p><code><a href="#topic+assess_pb_bias_correction">assess_pb_bias_correction</a></code> attempts to demonstrate how much (or little)
improvement can be expected from the parametric bootstrap correction given a particular
reference data set.
</p>


<h3>genetic data format</h3>

<p>See the vignette.
</p>


<h3>example data</h3>

<p><code><a href="#topic+alewife">alewife</a></code>, <code><a href="#topic+blueback">blueback</a></code>, and <code><a href="#topic+chinook">chinook</a></code> are
genetic data sets that are useful for playing around with rubias and testing it
out.
</p>

<hr>
<h2 id='samp_from_mat'>Sample 1 observation from cell probabilities that are columns of a matrix</h2><span id='topic+samp_from_mat'></span>

<h3>Description</h3>

<p>Takes a matrix in which columns sum to one. For each column, performs a
single multinomial draw from the rows, weighted by their values in that column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samp_from_mat(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samp_from_mat_+3A_m">M</code></td>
<td>
<p>a matrix whose columns are reals summing to one</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector length = <code>ncol(M)</code> of indices, with each element being
the row that was chosen in that column's sampling
</p>

<hr>
<h2 id='self_assign'>Do leave-one-out self-assignment of individuals in a reference baseline</h2><span id='topic+self_assign'></span>

<h3>Description</h3>

<p>Returns a tidy data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>self_assign(
  reference,
  gen_start_col,
  preCompiledParams = NULL,
  alle_freq_prior = list(const_scaled = 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="self_assign_+3A_reference">reference</code></td>
<td>
<p>a two-column format genetic dataset, with &quot;repunit&quot;, &quot;collection&quot;, and &quot;indiv&quot;
columns, as well as a &quot;sample_type&quot; column that has some &quot;reference&quot; entries</p>
</td></tr>
<tr><td><code id="self_assign_+3A_gen_start_col">gen_start_col</code></td>
<td>
<p>the first column of genetic data in <code>reference</code></p>
</td></tr>
<tr><td><code id="self_assign_+3A_precompiledparams">preCompiledParams</code></td>
<td>
<p>Users should never use this option.  It is here only so that
this function can be called on a precompiled set of parameters with infer_mixture.  Don't
use this, unless you are one of the package developers...</p>
</td></tr>
<tr><td><code id="self_assign_+3A_alle_freq_prior">alle_freq_prior</code></td>
<td>
<p>a one-element named list specifying the prior to be used when
generating Dirichlet parameters for genotype likelihood calculations. Valid methods include
<code>"const"</code>, <code>"scaled_const"</code>, and <code>"empirical"</code>. See <code>?list_diploid_params</code>
for method details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble ...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ale_sa &lt;- self_assign(alewife, 17)
</code></pre>

<hr>
<h2 id='sim_spec_examples'>List of example ways of specifying repunit and collection quantities in simulations</h2><span id='topic+sim_spec_examples'></span>

<h3>Description</h3>

<p>This is just a list of tibbles that can be passed to the alpha_repunit or the
alpha_collection parameters in, for example, <code><a href="#topic+assess_reference_loo">assess_reference_loo</a></code>.
</p>


<h3>Source</h3>

<p>Made it up!
</p>

<hr>
<h2 id='simulate_random_samples'>Generate a samples for a mixture.</h2><span id='topic+simulate_random_samples'></span>

<h3>Description</h3>

<p>Creates random reporting unit (rho) and collection (omega) proportions, and a
<code>sim_colls</code> vector for simulation of individual genotypes, based on the methods
used in Hasselman <em>et al.</em> (2015)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_random_samples(
  RU_starts,
  RU_vec,
  size = 100,
  alpha_repunit = 1.5,
  alpha_collection = 1.5,
  coll_sub_dirichlet_default = 1.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_random_samples_+3A_ru_starts">RU_starts</code></td>
<td>
<p>a vector delineating the reporting units in <code>RU_vec</code>;
generated by <code>tcf2param_list</code></p>
</td></tr>
<tr><td><code id="simulate_random_samples_+3A_ru_vec">RU_vec</code></td>
<td>
<p>a vector of collection indices, grouped by reporting unit;
generated by <code>tcf2param_list</code></p>
</td></tr>
<tr><td><code id="simulate_random_samples_+3A_size">size</code></td>
<td>
<p>The number of individuals desired in the mixture sample.  Default = 100.  This is
ignored without a warning if alpha_repunit is specified with counts (a cnt column) or if alpha_collection
is specified with counts (a cnt column).</p>
</td></tr>
<tr><td><code id="simulate_random_samples_+3A_alpha_repunit">alpha_repunit</code></td>
<td>
<p>If a vector, this is the dirichlet parameter for simulating
the proportions of reporting units. Gets recycled to the number of reporting units. Default is 1.5.
Otherwise, this could be a two-column data frame.  The first column must be named &quot;repunit&quot; and the
second one must be one of &quot;dirichlet&quot;, &quot;ppn&quot;, or &quot;cnt&quot;, according to whether you wish to
specify dirichlet parameters, or proportions, or exact counts, respectively, for each population.</p>
</td></tr>
<tr><td><code id="simulate_random_samples_+3A_alpha_collection">alpha_collection</code></td>
<td>
<p>The dirichlet parameter for simulating proportions of collections within reporting units. Default = 1.5</p>
</td></tr>
<tr><td><code id="simulate_random_samples_+3A_coll_sub_dirichlet_default">coll_sub_dirichlet_default</code></td>
<td>
<p>If you are providing a data frame with requested sub_dirichlet pars
for collections, and you don't specifically list one, this is the value it gets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with three elements.
The first two are a rho vector and an omega vector, respectively. The third is a vector of origins for
simulated individuals, sampled from the collections with probabilities = omega
</p>

<hr>
<h2 id='small_chinook_mix'>Small sample of SNP data from Chinook salmon taken in May/August 2015 from California fisheries</h2><span id='topic+small_chinook_mix'></span>

<h3>Description</h3>

<p>This is simply a sample of 100 fish from <code><a href="#topic+chinook">chinook</a></code>.
</p>


<h3>Source</h3>

<p>Southwest Fisheries Science Center, Santa Cruz, CA
</p>

<hr>
<h2 id='small_chinook_ref'>SNP data from selected chinook reference populations</h2><span id='topic+small_chinook_ref'></span>

<h3>Description</h3>

<p>A small number of poulations from the
Chinook salmon baseline data similar to that which can be
downloaded from <a href="https://datadryad.org/stash/dataset/doi:10.5061/dryad.574sv">https://datadryad.org/stash/dataset/doi:10.5061/dryad.574sv</a>.
This data set includes 91 SNPs and 909 fish.
</p>


<h3>Format</h3>

<p>A tbl_df-ed (from dplyr) data frame with 909 rows and 185 variables. The first
three columns are
</p>

<dl>
<dt>repunit (chr)</dt><dd><p>the reporting unit that the individual is in</p>
</dd>
<dt>pop (chr)</dt><dd><p>the population from which the individual was sampled</p>
</dd>
<dt>ID (chr)</dt><dd><p>Unique identifier of the individual fish</p>
</dd>
</dl>

<p>The remaining columns are two columns for each locus.  These columns are named like,
&quot;Locus.1&quot; and &quot;Locus.2&quot; for the first and second gene copies at that locus.  For example,
&quot;Ots_104569-86.1&quot; and  &quot;Ots_104569-86.2&quot;.  The locus columns are ints and missing data
is denoted by NA.
</p>


<h3>Source</h3>

<p><a href="https://datadryad.org/stash/dataset/doi:10.5061/dryad.574sv">https://datadryad.org/stash/dataset/doi:10.5061/dryad.574sv</a>
</p>

<hr>
<h2 id='tcf2long'>Convert Two-Column Genetic Data to Long Format</h2><span id='topic+tcf2long'></span>

<h3>Description</h3>

<p>Takes a data frame consisting of metadata followed by paired columns of genetic data,
with each column in the pair representing a gene copy at a locus.
Returns a list of two data frames: one with genetic data condensed into one column,
and the other with two-column structure intact, but with cleaned allele names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcf2long(D, gen_start_col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcf2long_+3A_d">D</code></td>
<td>
<p>A data frame containing two-column genetic data, optionally preceded by metadata.
The header of the first genetic data column in each pair lists the locus name, the second is ignored.
<strong>Locus names must not have spaces in them!</strong></p>
</td></tr>
<tr><td><code id="tcf2long_+3A_gen_start_col">gen_start_col</code></td>
<td>
<p>The index (number) of the column in which genetic data starts.
Columns must be only genetic data after genetic data starts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>tcf2long</code> returns a list of two data frames: in the first, &quot;long&quot;, the rightmost
column is the genetic data. Two new columns, &quot;locus&quot; and &quot;gene copy&quot;, duplicate the original
column name provided in the first of each pair, and designate copies &quot;a&quot; and &quot;b&quot;, respectively.
Metadata is duplicated as necessary for each locus. The second, &quot;clean_short&quot;, replicates the
input dataset, but with column names replaced by &quot;(locus name) a&quot; and &quot;(locus name) b&quot; in each pair.
In other words the locus name has an &quot;a&quot; or a &quot;b&quot; added to it <em>after a space</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Convert the alewife dataset for further processing
# the data frame passed into this function must have had
# character collections and repunits converted to factors
reference &lt;- alewife
reference$repunit &lt;- factor(reference$repunit, levels = unique(reference$repunit))
reference$collection &lt;- factor(reference$collection, levels = unique(reference$collection))
ale_long &lt;- tcf2long(reference, 17)
</code></pre>

<hr>
<h2 id='tcf2param_list'>Generate MCMC parameter list from two-column genetic data &amp; print summary</h2><span id='topic+tcf2param_list'></span>

<h3>Description</h3>

<p>This function is a wrapper for all steps to create the parameter list necessary
for genotype log-likelihood calculation from the starting two-column genetic data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcf2param_list(
  D,
  gen_start_col,
  samp_type = "both",
  alle_freq_prior = list(const_scaled = 1),
  summ = T,
  ploidies
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcf2param_list_+3A_d">D</code></td>
<td>
<p>A data frame containing two-column genetic data, preceded by metadata.
The header of the first genetic data column in each pair lists the locus name,
the second is ignored. <strong>Locus names must not have spaces in them!</strong>
Required metadata includes a column of unique individual identifiers named &quot;indiv&quot;,
a column named &quot;collection&quot; designating the sample groups, a column &quot;repunit&quot;
designating the reporting unit of origin of each fish, and a &quot;sample_type&quot; column
denoting each individual as a &quot;reference&quot; or &quot;mixture&quot; sample. <em>No NAs should be
present in metadata</em></p>
</td></tr>
<tr><td><code id="tcf2param_list_+3A_gen_start_col">gen_start_col</code></td>
<td>
<p>The index (number) of the column in which genetic data starts.
Columns must be only genetic data after genetic data starts.</p>
</td></tr>
<tr><td><code id="tcf2param_list_+3A_samp_type">samp_type</code></td>
<td>
<p>the sample groups to be include in the individual genotype list,
whose likelihoods will be used in MCMC. Options &quot;reference&quot;, &quot;mixture&quot;, and &quot;both&quot;</p>
</td></tr>
<tr><td><code id="tcf2param_list_+3A_alle_freq_prior">alle_freq_prior</code></td>
<td>
<p>a one-element named list specifying the prior to be used when
generating Dirichlet parameters for genotype likelihood calculations. Valid methods
include <code>"const"</code>, <code>"scaled_const"</code>, and <code>"empirical"</code>. See
<code>?list_diploid_params</code> for method details.</p>
</td></tr>
<tr><td><code id="tcf2param_list_+3A_summ">summ</code></td>
<td>
<p>logical indicating whether summary descriptions of the formatted data be provided</p>
</td></tr>
<tr><td><code id="tcf2param_list_+3A_ploidies">ploidies</code></td>
<td>
<p>a named vector of ploidies (1 or 2) for each locus.  The names must the the locus names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order for all steps in conversion to be carried out successfully, the dataset
must have &quot;repunit&quot;, &quot;collection&quot;, &quot;indiv&quot;, and &quot;sample_type&quot; columns preceding
two-column genetic data. If <code>summ == TRUE</code>, the function prints summary statistics
describing the structure of the dataset, as well as the presence of missing data,
enabling verification of proper data conversion.
</p>


<h3>Value</h3>

<p><code>tcf2param_list</code> returns the output of <code>list_diploid_params</code>,
after the original dataset is converted to a usable format and all relevant values
are extracted. See <code>?list_diploid_params</code> for details
</p>


<h3>Examples</h3>

<pre><code class='language-R'># after adding support for haploid markers we need to pass
# in the ploidies vector.  These markers are all diploid...
locnames &lt;- names(alewife)[-(1:16)][c(TRUE, FALSE)]
ploidies &lt;- rep(2, length(locnames))
names(ploidies) &lt;- locnames
ale_par_list &lt;- tcf2param_list(alewife, 17, ploidies = ploidies)

</code></pre>

<hr>
<h2 id='tidy_mcmc_coll_rep_stuff'>A helper function to tidy up the output from the gsi_mcmc functions</h2><span id='topic+tidy_mcmc_coll_rep_stuff'></span>

<h3>Description</h3>

<p>This makes a tidy data frame of stuff, and also changes things back to
factors, if the levels are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_mcmc_coll_rep_stuff(field, p, pname, car_tib)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_mcmc_coll_rep_stuff_+3A_field">field</code></td>
<td>
<p>The output to tidy (i.e.. out$mean)</p>
</td></tr>
<tr><td><code id="tidy_mcmc_coll_rep_stuff_+3A_p">p</code></td>
<td>
<p>the name of the parameter whose values you want to extract (like &quot;pi&quot;)</p>
</td></tr>
<tr><td><code id="tidy_mcmc_coll_rep_stuff_+3A_pname">pname</code></td>
<td>
<p>the name that you want the parameter to be called in the output</p>
</td></tr>
<tr><td><code id="tidy_mcmc_coll_rep_stuff_+3A_car_tib">car_tib</code></td>
<td>
<p>a tibble with repunit and collection in the order they appear in the output</p>
</td></tr>
</table>

<hr>
<h2 id='tidy_mcmc_pofz'>A helper function to tidy up the PofZ-like output from the gsi_mcmc functions</h2><span id='topic+tidy_mcmc_pofz'></span>

<h3>Description</h3>

<p>This makes a tidy data frame of stuff, and also changes things back to
factors, if the levels are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_mcmc_pofz(input, pname, car_tib, mix_indiv_tib)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_mcmc_pofz_+3A_input">input</code></td>
<td>
<p>The output to tidy (i.e.. out$mean$PofZ)</p>
</td></tr>
<tr><td><code id="tidy_mcmc_pofz_+3A_pname">pname</code></td>
<td>
<p>the name that you want the parameter to be called in the output</p>
</td></tr>
<tr><td><code id="tidy_mcmc_pofz_+3A_car_tib">car_tib</code></td>
<td>
<p>a tibble with repunit and collection in the order they appear in the output</p>
</td></tr>
<tr><td><code id="tidy_mcmc_pofz_+3A_mix_indiv_tib">mix_indiv_tib</code></td>
<td>
<p>a tibble with the individuals in the order they appear in the output</p>
</td></tr>
</table>

<hr>
<h2 id='tidy_pi_traces'>a helper function to tidy up the pi-traces that come out of the mcmc functions</h2><span id='topic+tidy_pi_traces'></span>

<h3>Description</h3>

<p>This makes a tidy data frame of stuff, and also changes things back to
factors, if the levels are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_pi_traces(input, pname, car_tib, interval)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_pi_traces_+3A_input">input</code></td>
<td>
<p>The output to tidy (i.e.. out$trace$pi)</p>
</td></tr>
<tr><td><code id="tidy_pi_traces_+3A_pname">pname</code></td>
<td>
<p>the name that you want the parameter to be called in the output</p>
</td></tr>
<tr><td><code id="tidy_pi_traces_+3A_car_tib">car_tib</code></td>
<td>
<p>a tibble with repunit and collection in the order they appear in the output</p>
</td></tr>
<tr><td><code id="tidy_pi_traces_+3A_interval">interval</code></td>
<td>
<p>the thinning interval that was used</p>
</td></tr>
</table>

<hr>
<h2 id='write_gsi_sim_mixture'>Write a mixture data frame to gsi_sim format baseline and repunits file</h2><span id='topic+write_gsi_sim_mixture'></span>

<h3>Description</h3>

<p>Note, this is only intended to work with integer-valued alleles, at the moment.
It was just written for testing and verifying that things are working correctly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_gsi_sim_mixture(mix, gen_start_col, mixprefix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_gsi_sim_mixture_+3A_mix">mix</code></td>
<td>
<p>mixture data frame</p>
</td></tr>
<tr><td><code id="write_gsi_sim_mixture_+3A_gen_start_col">gen_start_col</code></td>
<td>
<p>column in which the genetic data start</p>
</td></tr>
<tr><td><code id="write_gsi_sim_mixture_+3A_mixprefix">mixprefix</code></td>
<td>
<p>path to write the mixture file to.  The mixture collection name + .txt will
be appended to this.  This path can include directories if they exist.  An example
would be &quot;./my_gsi_data/mixture&quot;. This is a required argument.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># this writes to file prefix "mixfile" in a temporary directory
dd &lt;- tempdir()
prefix &lt;- file.path(dd, "mixfile")

# print that
prefix

# note that in practice you will probably want to specify
# your own directory...

# run the function
write_gsi_sim_mixture(chinook_mix, 5, prefix)

# see where those files live:
dir(dd, pattern = "mixfile*", full.names = TRUE)
</code></pre>

<hr>
<h2 id='write_gsi_sim_reference'>Write a reference data frame to gsi_sim format baseline and repunits file</h2><span id='topic+write_gsi_sim_reference'></span>

<h3>Description</h3>

<p>Note, this is only intended to work with integer-valued alleles, at the moment.
It was just written for testing and verifying that things are working correctly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_gsi_sim_reference(
  ref,
  gen_start_col,
  baseout = "baseline.txt",
  repout = "repunits.txt"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_gsi_sim_reference_+3A_ref">ref</code></td>
<td>
<p>reference data frame</p>
</td></tr>
<tr><td><code id="write_gsi_sim_reference_+3A_gen_start_col">gen_start_col</code></td>
<td>
<p>column in which the genetic data start</p>
</td></tr>
<tr><td><code id="write_gsi_sim_reference_+3A_baseout">baseout</code></td>
<td>
<p>path to write the baseline file to. Required.</p>
</td></tr>
<tr><td><code id="write_gsi_sim_reference_+3A_repout">repout</code></td>
<td>
<p>path to write the repunits file to. Required.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># create a temp directory to put example outputs
dd &lt;- tempdir()
basefile &lt;- file.path(dd, "baseline.txt")
repunitsfile &lt;- file.path(dd, "repunits.txt")

# print those
basefile
repunitsfile

# note that in practice you will probably want to specify
# your own filepaths...

# run the function
write_gsi_sim_reference(alewife, 17, basefile, repunitsfile)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
