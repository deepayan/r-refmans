<!DOCTYPE html><html><head><title>Help for package spfilteR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spfilteR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fakedata'><p>Synthetic Dataset</p></a></li>
<li><a href='#getEVs'><p>Eigenfunction Decomposition of a (Transformed) Spatial Connectivity</p>
Matrix</a></li>
<li><a href='#glmFilter'><p>Unsupervised Spatial Filtering with Eigenvectors in Generalized</p>
Linear Regression Models</a></li>
<li><a href='#lmFilter'><p>Unsupervised Spatial Filtering with Eigenvectors in Linear Regression Models</p></a></li>
<li><a href='#MI.decomp'><p>Decomposition of the Moran Coefficient</p></a></li>
<li><a href='#MI.ev'><p>Moran Coefficients of Eigenvectors</p></a></li>
<li><a href='#MI.resid'><p>Moran Test for Residual Spatial Autocorrelation</p></a></li>
<li><a href='#MI.sf'><p>Moran Coefficient of the Spatial Filter</p></a></li>
<li><a href='#MI.vec'><p>Local Moran Coefficient</p></a></li>
<li><a href='#partialR2'><p>Coefficient of Partial Determination</p></a></li>
<li><a href='#vif.ev'><p>Variance Inflation Factor of Eigenvectors</p></a></li>
<li><a href='#vp'><p>Variance Partitioning with Moran Spectral Randomization</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Semiparametric Spatial Filtering with Eigenvectors in
(Generalized) Linear Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools to decompose (transformed) spatial connectivity matrices and perform supervised or unsupervised semiparametric spatial filtering in a regression framework. The package supports unsupervised spatial filtering in standard linear as well as some generalized linear regression models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/sjuhl/spfilteR">https://github.com/sjuhl/spfilteR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sjuhl/spfilteR/issues">https://github.com/sjuhl/spfilteR/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-22 18:01:49 UTC; SJuhl</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastian Juhl <a href="https://orcid.org/0000-0002-7123-5398"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastian Juhl &lt;sebastian.juhl@t-online.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-22 19:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fakedata'>Synthetic Dataset</h2><span id='topic+fakedata'></span><span id='topic+fakedataset'></span><span id='topic+W'></span>

<h3>Description</h3>

<p>An artificially generated cross-sectional dataset together with
an accompanying binary connectivity matrix <em><strong>W</strong></em>. The
<code class="reqn">n=100</code> units are located on a regular grid and <em><strong>W</strong></em>
is defined according to rook's adjacency definition of contiguity.
The synthetic data can be used to illustrate the functionality
of this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fakedata)

W
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 100 rows and 8 columns.
</p>
<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 100 rows and 100 columns.
</p>


<h3>Value</h3>

<p>The file contains two objects:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>fakedataset</code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> a synthetic dataset</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>W</code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> an artificial spatial connectivity matrix</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>
data(fakedata)
head(fakedataset)
dim(W)
</code></pre>

<hr>
<h2 id='getEVs'>Eigenfunction Decomposition of a (Transformed) Spatial Connectivity
Matrix</h2><span id='topic+getEVs'></span>

<h3>Description</h3>

<p>Extract eigenvectors and corresponding eigenvalues from
the matrix <em><strong>MWM</strong></em>, where <em><strong>M</strong></em> denotes a symmetric
and idempotent projection matrix and <em><strong>W</strong></em> is the spatial
connectivity matrix. This function also reports the Moran coefficient
associated with each of the eigenvectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEVs(W, covars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEVs_+3A_w">W</code></td>
<td>
<p>spatial connectivity matrix</p>
</td></tr>
<tr><td><code id="getEVs_+3A_covars">covars</code></td>
<td>
<p>vector/ matrix of regressors included in the construction
of the projection matrix <em><strong>M</strong></em> - see Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The eigenfunctions obtained by <code>getEVs</code>
can be used to perform supervised eigenvector selection and to
manually create a spatial filter. To this end, a candidate set
may be determined by 1) the sign of the spatial autocorrelation
in model residuals and 2) the strength of spatial association
found in each eigenvector as indicated by <code>moran</code>.
</p>
<p>Prior to the spectral decomposition, <code>getEVs</code> symmetrizes the
spatial connectivity matrix by: 1/2 * (<em><strong>W</strong></em> + <em><strong>W</strong></em>').
</p>
<p>If <code>covars</code> are supplied, the function uses the covariates to construct
projection matrix: <em><strong>M</strong> = <strong>I</strong> - <strong>X</strong> (<strong>X</strong>'
<strong>X</strong>)^-1<strong>X</strong>'</em>. Using this matrix results in a set of
eigenvectors that are uncorrelated to each other as well as to the
covariates. If <code>covars = NULL</code>, only the intercept term is used
to construct <em><strong>M</strong></em>. See e.g., Griffith and Tiefelsdorf (2007)
for more details on the appropriate choice of <em><strong>M</strong></em>.
</p>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<dl>
<dt><code>vectors</code></dt><dd><p>matrix of all eigenvectors</p>
</dd>
<dt><code>values</code></dt><dd><p>vector of the corresponding eigenvalues</p>
</dd>
<dt><code>moran</code></dt><dd><p>vector of the Moran coefficients associated with
the eigenvectors</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Sebastian Juhl
</p>


<h3>References</h3>

<p>Tiefelsdorf, Michael and Daniel A. Griffith (2007):
Semiparametric filtering of spatial autocorrelation: the eigenvector
approach. Environment and Planning A: Economy and Space, 39 (5):
pp. 1193 - 1221.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmFilter">lmFilter</a></code>, <code><a href="#topic+glmFilter">glmFilter</a></code>, <code><a href="#topic+MI.ev">MI.ev</a></code>,
<code><a href="#topic+MI.sf">MI.sf</a></code>, <code><a href="#topic+vif.ev">vif.ev</a></code>, <code><a href="#topic+partialR2">partialR2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fakedata)

E &lt;- getEVs(W = W, covars = NULL)

</code></pre>

<hr>
<h2 id='glmFilter'>Unsupervised Spatial Filtering with Eigenvectors in Generalized
Linear Regression Models</h2><span id='topic+glmFilter'></span>

<h3>Description</h3>

<p>This function implements the eigenvector-based semiparametric
spatial filtering approach in a generalized linear regression framework using
maximum likelihood estimation (MLE). Eigenvectors are selected by an unsupervised
stepwise regression technique. Supported selection criteria are the minimization of
residual autocorrelation, maximization of model fit, significance of residual
autocorrelation, and the statistical significance of eigenvectors. Alternatively,
all eigenvectors in the candidate set can be included as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmFilter(
  y,
  x = NULL,
  W,
  objfn = "AIC",
  MX = NULL,
  model,
  optim.method = "BFGS",
  sig = 0.05,
  bonferroni = TRUE,
  positive = TRUE,
  ideal.setsize = FALSE,
  min.reduction = 0.05,
  boot.MI = 100,
  resid.type = "pearson",
  alpha = 0.25,
  tol = 0.1,
  na.rm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmFilter_+3A_y">y</code></td>
<td>
<p>response variable</p>
</td></tr>
<tr><td><code id="glmFilter_+3A_x">x</code></td>
<td>
<p>vector/ matrix of regressors (default = NULL)</p>
</td></tr>
<tr><td><code id="glmFilter_+3A_w">W</code></td>
<td>
<p>spatial connectivity matrix</p>
</td></tr>
<tr><td><code id="glmFilter_+3A_objfn">objfn</code></td>
<td>
<p>the objective function to be used for eigenvector
selection. Possible criteria are: the maximization of model fit
('AIC' or 'BIC'), minimization of residual autocorrelation ('MI'),
significance level of candidate eigenvectors ('p'), significance of residual spatial
autocorrelation ('pMI'), or all eigenvectors in the candidate set ('all')</p>
</td></tr>
<tr><td><code id="glmFilter_+3A_mx">MX</code></td>
<td>
<p>covariates used to construct the projection matrix (default = NULL) - see
Details</p>
</td></tr>
<tr><td><code id="glmFilter_+3A_model">model</code></td>
<td>
<p>a character string indicating the type of model to be estimated.
Currently, 'probit', 'logit', and 'poisson' are valid inputs</p>
</td></tr>
<tr><td><code id="glmFilter_+3A_optim.method">optim.method</code></td>
<td>
<p>a character specifying the optimization method used by
the <code>optim</code> function</p>
</td></tr>
<tr><td><code id="glmFilter_+3A_sig">sig</code></td>
<td>
<p>significance level to be used for eigenvector selection
if <code>objfn = 'p'</code> or <code>objfn = 'pMI'</code></p>
</td></tr>
<tr><td><code id="glmFilter_+3A_bonferroni">bonferroni</code></td>
<td>
<p>Bonferroni adjustment for the significance level
(TRUE/ FALSE) if <code>objfn = 'p'</code>. Set to FALSE if <code>objfn = 'pMI'</code> -
see Details</p>
</td></tr>
<tr><td><code id="glmFilter_+3A_positive">positive</code></td>
<td>
<p>restrict search to eigenvectors associated with positive
levels of spatial autocorrelation (TRUE/ FALSE)</p>
</td></tr>
<tr><td><code id="glmFilter_+3A_ideal.setsize">ideal.setsize</code></td>
<td>
<p>if <code>positive = TRUE</code>, uses the formula proposed by
Chun et al. (2016) to determine the ideal size of the candidate set
(TRUE/ FALSE)</p>
</td></tr>
<tr><td><code id="glmFilter_+3A_min.reduction">min.reduction</code></td>
<td>
<p>if <code>objfn</code> is either 'AIC' or 'BIC'. A value in the
interval [0,1) that determines the minimum reduction in AIC/ BIC (relative to the
current AIC/ BIC) a candidate eigenvector need to achieve in order to be selected</p>
</td></tr>
<tr><td><code id="glmFilter_+3A_boot.mi">boot.MI</code></td>
<td>
<p>number of iterations used to estimate the variance of Moran's I
(default = 100). Alternatively, if <code>boot.MI = NULL</code>, analytical results will
be used</p>
</td></tr>
<tr><td><code id="glmFilter_+3A_resid.type">resid.type</code></td>
<td>
<p>character string specifying the residual type to be used.
Options are 'raw', 'deviance', and 'pearson' (default)</p>
</td></tr>
<tr><td><code id="glmFilter_+3A_alpha">alpha</code></td>
<td>
<p>a value in (0,1] indicating the range of candidate eigenvectors
according to their associated level of spatial autocorrelation, see e.g.,
Griffith (2003)</p>
</td></tr>
<tr><td><code id="glmFilter_+3A_tol">tol</code></td>
<td>
<p>if <code>objfn = 'MI'</code>, determines the amount of remaining residual
autocorrelation at which the eigenvector selection terminates</p>
</td></tr>
<tr><td><code id="glmFilter_+3A_na.rm">na.rm</code></td>
<td>
<p>remove observations with missing values (TRUE/ FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <strong>W</strong> is not symmetric, it gets symmetrized by
1/2 * (<strong>W</strong> + <strong>W</strong>') before the decomposition.
</p>
<p>If covariates are supplied to <code>MX</code>, the function uses these regressors
to construct the following projection matrix:
</p>
<p><strong>M</strong> = <strong>I</strong> - <strong>X</strong> (<strong>X</strong>'<strong>X</strong>)^-1<strong>X</strong>'
</p>
<p>Eigenvectors from <strong>MWM</strong> using this specification of
<strong>M</strong> are not only mutually uncorrelated but also orthogonal
to the regressors specified in <code>MX</code>. Alternatively, if <code>MX = NULL</code>, the
projection matrix becomes <strong>M</strong> = <strong>I</strong> - <strong>11</strong>'/ *n*,
where <strong>1</strong> is a vector of ones and *n* represents the number of
observations. Griffith and Tiefelsdorf (2007) show how the choice of the appropriate
<strong>M</strong> depends on the underlying process that generates the spatial
dependence.
</p>
<p>The Bonferroni correction is only possible if eigenvector selection is based on
the significance level of the eigenvectors (<code>objfn = 'p'</code>). It is set to
FALSE if eigenvectors are added to the model until the residuals exhibit no
significant level of spatial autocorrelation (<code>objfn = 'pMI'</code>).
</p>


<h3>Value</h3>

<p>An object of class <code>spfilter</code> containing the following
information:
</p>

<dl>
<dt><code>estimates</code></dt><dd><p>summary statistics of the parameter estimates</p>
</dd>
<dt><code>varcovar</code></dt><dd><p>estimated variance-covariance matrix</p>
</dd>
<dt><code>EV</code></dt><dd><p>a matrix containing the summary statistics of selected eigenvectors</p>
</dd>
<dt><code>selvecs</code></dt><dd><p>vector/ matrix of selected eigenvectors</p>
</dd>
<dt><code>evMI</code></dt><dd><p>Moran coefficient of all eigenvectors</p>
</dd>
<dt><code>moran</code></dt><dd><p>residual autocorrelation in the initial and the
filtered model</p>
</dd>
<dt><code>fit</code></dt><dd><p>adjusted R-squared of the initial and the filtered model</p>
</dd>
<dt><code>residuals</code></dt><dd><p>initial and filtered model residuals</p>
</dd>
<dt><code>other</code></dt><dd><p>a list providing supplementary information:
</p>

<dl>
<dt><code>ncandidates</code></dt><dd><p>number of candidate eigenvectors considered</p>
</dd>
<dt><code>nev</code></dt><dd><p>number of selected eigenvectors</p>
</dd>
<dt><code>condnum</code></dt><dd><p>condition number to assess the degree of multicollinearity
among the eigenvectors induced by the link function, see e.g., Griffith/ Amrhein
(1997)</p>
</dd>
<dt><code>sel_id</code></dt><dd><p>ID of selected eigenvectors</p>
</dd>
<dt><code>sf</code></dt><dd><p>vector representing the spatial filter</p>
</dd>
<dt><code>sfMI</code></dt><dd><p>Moran coefficient of the spatial filter</p>
</dd>
<dt><code>model</code></dt><dd><p>type of the regression model</p>
</dd>
<dt><code>dependence</code></dt><dd><p>filtered for positive or negative spatial dependence</p>
</dd>
<dt><code>objfn</code></dt><dd><p>selection criterion specified in the objective function of
the stepwise regression procedure</p>
</dd>
<dt><code>bonferroni</code></dt><dd><p>TRUE/ FALSE: Bonferroni-adjusted significance level
(if <code>objfn='p'</code>)</p>
</dd>
<dt><code>siglevel</code></dt><dd><p>if <code>objfn = 'p'</code> or <code>objfn = 'pMI'</code>: actual
(unadjusted/ adjusted) significance level</p>
</dd>
<dt><code>resid.type</code></dt><dd><p>residual type ('raw', 'deviance', or 'pearson')</p>
</dd>
<dt><code>pseudoR2</code></dt><dd><p>McFadden's pseudo R-squared (filtered vs. unfiltered model)</p>
</dd>
</dl>

</dd>
</dl>



<h3>Note</h3>

<p>If the condition number (<code>condnum</code>) suggests high levels of
multicollinearity, eigenvectors can be sequentially removed from <code>selvecs</code>
and the model can be re-estimated using the <code>glm</code> function in order to
identify and manually remove the problematic eigenvectors. Moreover, if other
models that are currently not implemented here need to be estimated
(e.g., quasi-binomial models), users can extract eigenvectors using the function
<code>getEVs</code> and perform a supervised eigenvector search using the <code>glm</code>
function.
</p>
<p>In contrast to eigenvector-based spatial filtering in linear regression models,
Chun (2014) notes that only a limited number of studies address the problem
of measuring spatial autocorrelation in generalized linear model residuals.
Consequently, eigenvector selection may be based on an objective function that
maximizes model fit rather than minimizes residual spatial autocorrelation.
</p>


<h3>References</h3>

<p>Chun, Yongwan (2014): Analyzing Space-Time Crime Incidents Using
Eigenvector Spatial Filtering: An Application to Vehicle Burglary.
Geographical Analysis 46 (2): pp. 165 - 184.
</p>
<p>Tiefelsdorf, Michael and Daniel A. Griffith (2007):
Semiparametric filtering of spatial autocorrelation: the eigenvector
approach. Environment and Planning A: Economy and Space, 39 (5):
pp. 1193 - 1221.
</p>
<p>Griffith, Daniel A. (2003): Spatial Autocorrelation and Spatial Filtering:
Gaining Understanding Through Theory and Scientific Visualization.
Berlin/ Heidelberg, Springer.
</p>
<p>Griffith, Daniel A. and Carl G. Amrhein (1997): Multivariate Statistical
Analysis for Geographers. Englewood Cliffs, Prentice Hall.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmFilter">lmFilter</a></code>, <code><a href="#topic+getEVs">getEVs</a></code>, <code><a href="#topic+MI.resid">MI.resid</a></code>,
<code><a href="stats.html#topic+optim">optim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fakedata)

# poisson model
y_pois &lt;- fakedataset$count
poisson &lt;- glmFilter(y = y_pois, x = NULL, W = W, objfn = "MI", positive = FALSE,
model = "poisson", boot.MI = 100)
print(poisson)
summary(poisson, EV = FALSE)

# probit model - summarize EVs
y_prob &lt;- fakedataset$indicator
probit &lt;- glmFilter(y = y_prob, x = NULL, W = W, objfn = "p", positive = FALSE,
model = "probit", boot.MI = 100)
print(probit)
summary(probit, EV = TRUE)

# logit model - AIC objective function
y_logit &lt;- fakedataset$indicator
logit &lt;- glmFilter(y = y_logit, x = NULL, W = W, objfn = "AIC", positive = FALSE,
model = "logit", min.reduction = .05)
print(logit)
summary(logit, EV = FALSE)

</code></pre>

<hr>
<h2 id='lmFilter'>Unsupervised Spatial Filtering with Eigenvectors in Linear Regression Models</h2><span id='topic+lmFilter'></span><span id='topic+summary.spfilter'></span>

<h3>Description</h3>

<p>This function implements the eigenvector-based semiparametric
spatial filtering approach in a linear regression framework using ordinary least
squares (OLS). Eigenvectors are selected by an unsupervised stepwise regression
technique. Supported selection criteria are the minimization of residual
autocorrelation, maximization of model fit, significance of residual autocorrelation,
and the statistical significance of eigenvectors. Alternatively, all eigenvectors in
the candidate set can be included as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmFilter(
  y,
  x = NULL,
  W,
  objfn = "MI",
  MX = NULL,
  sig = 0.05,
  bonferroni = TRUE,
  positive = TRUE,
  ideal.setsize = FALSE,
  alpha = 0.25,
  tol = 0.1,
  boot.MI = NULL,
  na.rm = TRUE
)

## S3 method for class 'spfilter'
summary(object, EV = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmFilter_+3A_y">y</code></td>
<td>
<p>response variable</p>
</td></tr>
<tr><td><code id="lmFilter_+3A_x">x</code></td>
<td>
<p>vector/ matrix of regressors (default = NULL)</p>
</td></tr>
<tr><td><code id="lmFilter_+3A_w">W</code></td>
<td>
<p>spatial connectivity matrix</p>
</td></tr>
<tr><td><code id="lmFilter_+3A_objfn">objfn</code></td>
<td>
<p>the objective function to be used for eigenvector selection.
Possible criteria are: the maximization of the adjusted R-squared ('R2'),
minimization of residual autocorrelation ('MI'), significance level of
candidate eigenvectors ('p'), significance of residual spatial
autocorrelation ('pMI') or all eigenvectors in the candidate set ('all')</p>
</td></tr>
<tr><td><code id="lmFilter_+3A_mx">MX</code></td>
<td>
<p>covariates used to construct the projection matrix (default = NULL) - see
Details</p>
</td></tr>
<tr><td><code id="lmFilter_+3A_sig">sig</code></td>
<td>
<p>significance level to be used for eigenvector selection
if <code>objfn = 'p'</code> or <code>objfn = 'pMI'</code></p>
</td></tr>
<tr><td><code id="lmFilter_+3A_bonferroni">bonferroni</code></td>
<td>
<p>Bonferroni adjustment for the significance level
(TRUE/ FALSE) if <code>objfn = 'p'</code>. Set to FALSE if <code>objfn = 'pMI'</code> -
see Details</p>
</td></tr>
<tr><td><code id="lmFilter_+3A_positive">positive</code></td>
<td>
<p>restrict search to eigenvectors associated with positive
levels of spatial autocorrelation (TRUE/ FALSE)</p>
</td></tr>
<tr><td><code id="lmFilter_+3A_ideal.setsize">ideal.setsize</code></td>
<td>
<p>if <code>positive = TRUE</code>, uses the formula proposed by
Chun et al. (2016) to determine the ideal size of the candidate set
(TRUE/ FALSE)</p>
</td></tr>
<tr><td><code id="lmFilter_+3A_alpha">alpha</code></td>
<td>
<p>a value in (0,1] indicating the range of candidate eigenvectors
according to their associated level of spatial autocorrelation, see e.g.,
Griffith (2003)</p>
</td></tr>
<tr><td><code id="lmFilter_+3A_tol">tol</code></td>
<td>
<p>if <code>objfn = 'MI'</code>, determines the amount of remaining residual
autocorrelation at which the eigenvector selection terminates</p>
</td></tr>
<tr><td><code id="lmFilter_+3A_boot.mi">boot.MI</code></td>
<td>
<p>number of iterations used to estimate the variance of Moran's I.
If <code>boot.MI = NULL</code> (default), analytical results will be used</p>
</td></tr>
<tr><td><code id="lmFilter_+3A_na.rm">na.rm</code></td>
<td>
<p>remove observations with missing values (TRUE/ FALSE)</p>
</td></tr>
<tr><td><code id="lmFilter_+3A_object">object</code></td>
<td>
<p>an object of class <code>spfilter</code></p>
</td></tr>
<tr><td><code id="lmFilter_+3A_ev">EV</code></td>
<td>
<p>display summary statistics for selected eigenvectors (TRUE/ FALSE)</p>
</td></tr>
<tr><td><code id="lmFilter_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <strong>W</strong> is not symmetric, it gets symmetrized by
1/2 * (<strong>W</strong> + <strong>W</strong>') before the decomposition.
</p>
<p>If covariates are supplied to <code>MX</code>, the function uses these regressors
to construct the following projection matrix:
</p>
<p><strong>M</strong> = <strong>I</strong> - <strong>X</strong> (<strong>X</strong>'<strong>X</strong>)^-1<strong>X</strong>'
</p>
<p>Eigenvectors from <strong>MWM</strong> using this specification of
<strong>M</strong> are not only mutually uncorrelated but also orthogonal
to the regressors specified in <code>MX</code>. Alternatively, if <code>MX = NULL</code>, the
projection matrix becomes <strong>M</strong> = <strong>I</strong> - <strong>11</strong>'/*n*,
where <strong>1</strong> is a vector of ones and *n* represents the number of
observations. Griffith and Tiefelsdorf (2007) show how the choice of the appropriate
<strong>M</strong> depends on the underlying process that generates the spatial
dependence.
</p>
<p>The Bonferroni correction is only possible if eigenvector selection is based on
the significance level of the eigenvectors (<code>objfn = 'p'</code>). It is set to
FALSE if eigenvectors are added to the model until the residuals exhibit no
significant level of spatial autocorrelation (<code>objfn = 'pMI'</code>).
</p>


<h3>Value</h3>

<p>An object of class <code>spfilter</code> containing the following
information:
</p>

<dl>
<dt><code>estimates</code></dt><dd><p>summary statistics of the parameter estimates</p>
</dd>
<dt><code>varcovar</code></dt><dd><p>estimated variance-covariance matrix</p>
</dd>
<dt><code>EV</code></dt><dd><p>a matrix containing the summary statistics of selected eigenvectors</p>
</dd>
<dt><code>selvecs</code></dt><dd><p>vector/ matrix of selected eigenvectors</p>
</dd>
<dt><code>evMI</code></dt><dd><p>Moran coefficient of all eigenvectors</p>
</dd>
<dt><code>moran</code></dt><dd><p>residual autocorrelation in the initial and the
filtered model</p>
</dd>
<dt><code>fit</code></dt><dd><p>adjusted R-squared of the initial and the filtered model</p>
</dd>
<dt><code>residuals</code></dt><dd><p>initial and filtered model residuals</p>
</dd>
<dt><code>other</code></dt><dd><p>a list providing supplementary information:
</p>

<dl>
<dt><code>ncandidates</code></dt><dd><p>number of candidate eigenvectors considered</p>
</dd>
<dt><code>nev</code></dt><dd><p>number of selected eigenvectors</p>
</dd>
<dt><code>sel_id</code></dt><dd><p>ID of selected eigenvectors</p>
</dd>
<dt><code>sf</code></dt><dd><p>vector representing the spatial filter</p>
</dd>
<dt><code>sfMI</code></dt><dd><p>Moran coefficient of the spatial filter</p>
</dd>
<dt><code>model</code></dt><dd><p>type of the fitted regression model</p>
</dd>
<dt><code>dependence</code></dt><dd><p>filtered for positive or negative spatial dependence</p>
</dd>
<dt><code>objfn</code></dt><dd><p>selection criterion specified in the objective function of
the stepwise regression procedure</p>
</dd>
<dt><code>bonferroni</code></dt><dd><p>TRUE/ FALSE: Bonferroni-adjusted significance level
(if <code>objfn = 'p'</code>)</p>
</dd>
<dt><code>siglevel</code></dt><dd><p>if <code>objfn = 'p'</code> or <code>objfn = 'pMI'</code>: actual
(unadjusted/ adjusted) significance level</p>
</dd>
</dl>

</dd>
</dl>



<h3>References</h3>

<p>Tiefelsdorf, Michael and Daniel A. Griffith (2007):
Semiparametric filtering of spatial autocorrelation: the eigenvector
approach. Environment and Planning A: Economy and Space, 39 (5):
pp. 1193 - 1221.
</p>
<p>Griffith, Daniel A. (2003): Spatial Autocorrelation and Spatial Filtering:
Gaining Understanding Through Theory and Scientific Visualization.
Berlin/ Heidelberg, Springer.
</p>
<p>Chun, Yongwan, Daniel A. Griffith, Monghyeon Lee, Parmanand
Sinha (2016): Eigenvector selection with stepwise regression techniques
to construct eigenvector spatial filters. Journal of Geographical
Systems, 18, pp. 67 – 85.
</p>
<p>Le Gallo, Julie and Antonio Páez (2013): Using synthetic
variables in instrumental variable estimation of spatial series models.
Environment and Planning A: Economy and Space, 45 (9): pp. 2227 - 2242.
</p>
<p>Tiefelsdorf, Michael and Barry Boots (1995): The Exact Distribution
of Moran's I. Environment and Planning A: Economy and Space, 27 (6):
pp. 985 - 999.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glmFilter">glmFilter</a></code>, <code><a href="#topic+getEVs">getEVs</a></code>, <code><a href="#topic+MI.resid">MI.resid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fakedata)
y &lt;- fakedataset$x1
X &lt;- cbind(fakedataset$x2, fakedataset$x3, fakedataset$x4)

res &lt;- lmFilter(y = y, x = X, W = W, objfn = 'MI', positive = FALSE)
print(res)
summary(res, EV = TRUE)

E &lt;- res$selvecs
(ols &lt;- coef(lm(y ~ X + E)))
coef(res)

</code></pre>

<hr>
<h2 id='MI.decomp'>Decomposition of the Moran Coefficient</h2><span id='topic+MI.decomp'></span>

<h3>Description</h3>

<p>A decomposition of the Moran coefficient in order to separately
test for the simultaneous presence of positive and negative autocorrelation
in a variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MI.decomp(x, W, nsim = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MI.decomp_+3A_x">x</code></td>
<td>
<p>a vector or matrix</p>
</td></tr>
<tr><td><code id="MI.decomp_+3A_w">W</code></td>
<td>
<p>spatial connectivity matrix</p>
</td></tr>
<tr><td><code id="MI.decomp_+3A_nsim">nsim</code></td>
<td>
<p>number of iterations to simulate the null distribution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a matrix, this function computes the Moran
test for spatial autocorrelation for each column.
</p>
<p>The <em>p</em>-values calculated for <code>I+</code> and <code>I-</code> assume
a directed alternative hypothesis. Statistical significance is assessed
using a permutation procedure to generate a simulated null distribution.
</p>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> that contains the following information
for each variable:
</p>

<dl>
<dt><code>I+</code></dt><dd><p>observed value of Moran's I (positive part)</p>
</dd>
<dt><code>VarI+</code></dt><dd><p>variance of Moran's I (positive part)</p>
</dd>
<dt><code>pI+</code></dt><dd><p>simulated <em>p</em>-value of Moran's I (positive part)</p>
</dd>
<dt><code>I-</code></dt><dd><p>observed value of Moran's I (negative part)</p>
</dd>
<dt><code>VarI-</code></dt><dd><p>variance of Moran's I (negative part)</p>
</dd>
<dt><code>pI-</code></dt><dd><p>simulated <em>p</em>-value of Moran's I (negative part)</p>
</dd>
<dt><code>pItwo.sided</code></dt><dd><p>simulated <em>p</em>-value of the two-sided test</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Sebastian Juhl
</p>


<h3>References</h3>

<p>Dary, Stéphane (2011): A New Perspective about Moran’s
Coefficient: Spatial Autocorrelation as a Linear Regression Problem.
Geographical Analysis, 43 (2): pp. 127 - 141.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MI.vec">MI.vec</a></code>, <code><a href="#topic+MI.ev">MI.ev</a></code>, <code><a href="#topic+MI.sf">MI.sf</a></code>,
<code><a href="#topic+MI.resid">MI.resid</a></code>, <code><a href="#topic+MI.local">MI.local</a></code>, <code><a href="#topic+getEVs">getEVs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fakedata)
X &lt;- cbind(fakedataset$x1, fakedataset$x2,
fakedataset$x3, fakedataset$negative)

(MI.dec &lt;- MI.decomp(x = X, W = W, nsim = 100))

# the sum of I+ and I- equals the observed Moran coefficient:
I &lt;- MI.vec(x = X, W = W)[, "I"]
cbind(MI.dec[, "I+"] + MI.dec[, "I-"], I)

</code></pre>

<hr>
<h2 id='MI.ev'>Moran Coefficients of Eigenvectors</h2><span id='topic+MI.ev'></span>

<h3>Description</h3>

<p>Calculates the Moran coefficient for each eigenvector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MI.ev(W, evals)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MI.ev_+3A_w">W</code></td>
<td>
<p>spatial connectivity matrix</p>
</td></tr>
<tr><td><code id="MI.ev_+3A_evals">evals</code></td>
<td>
<p>vector of eigenvalues</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector containing the Moran coefficients of the
eigenvectors associated with the supplied eigenvalues.
</p>


<h3>Author(s)</h3>

<p>Sebastian Juhl
</p>


<h3>References</h3>

<p>Le Gallo, Julie and Antonio Páez (2013): Using synthetic
variables in instrumental variable estimation of spatial series models.
Environment and Planning A, 45 (9): pp. 2227 - 2242.
</p>
<p>Tiefelsdorf, Michael and Barry Boots (1995): The Exact Distribution
of Moran's I. Environment and Planning A: Economy and Space, 27 (6):
pp. 985 - 999.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmFilter">lmFilter</a></code>, <code><a href="#topic+glmFilter">glmFilter</a></code>, <code><a href="#topic+getEVs">getEVs</a></code>,
<code><a href="#topic+MI.sf">MI.sf</a></code>
</p>

<hr>
<h2 id='MI.resid'>Moran Test for Residual Spatial Autocorrelation</h2><span id='topic+MI.resid'></span>

<h3>Description</h3>

<p>This function assesses the degree of spatial
autocorrelation present in regression residuals by means of the Moran
coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MI.resid(resid, x = NULL, W, alternative = "greater", boot = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MI.resid_+3A_resid">resid</code></td>
<td>
<p>residual vector</p>
</td></tr>
<tr><td><code id="MI.resid_+3A_x">x</code></td>
<td>
<p>vector/ matrix of regressors (default = NULL)</p>
</td></tr>
<tr><td><code id="MI.resid_+3A_w">W</code></td>
<td>
<p>spatial connectivity matrix</p>
</td></tr>
<tr><td><code id="MI.resid_+3A_alternative">alternative</code></td>
<td>
<p>specification of alternative hypothesis as 'greater' (default),
'lower', or 'two.sided'</p>
</td></tr>
<tr><td><code id="MI.resid_+3A_boot">boot</code></td>
<td>
<p>optional integer specifying the number of simulation iterations to
compute the variance. If NULL (default), variance calculated under assumed normality</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function assumes an intercept-only model if <code>x = NULL</code>.
Furthermore, <code>MI.resid</code> automatically symmetrizes the matrix
<em><strong>W</strong></em> by: 1/2 * (<em><strong>W</strong></em> + <em><strong>W</strong></em>').
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> object with the following elements:
</p>

<dl>
<dt><code>I</code></dt><dd><p>observed value of the Moran coefficient</p>
</dd>
<dt><code>EI</code></dt><dd><p>expected value of Moran's I</p>
</dd>
<dt><code>VarI</code></dt><dd><p>variance of Moran's I</p>
</dd>
<dt><code>zI</code></dt><dd><p>standardized Moran coefficient</p>
</dd>
<dt><code>pI</code></dt><dd><p><em>p</em>-value of the test statistic</p>
</dd>
</dl>



<h3>Note</h3>

<p>Calculations are based on the procedure proposed by Cliff and Ord
(1981). See also Cliff and Ord (1972).
</p>


<h3>Author(s)</h3>

<p>Sebastian Juhl
</p>


<h3>References</h3>

<p>Cliff, Andrew D. and John K. Ord (1981): Spatial Processes:
Models &amp; Applications. Pion, London.
</p>
<p>Cliff, Andrew D. and John K. Ord (1972): Testing for Spatial Autocorrelation
Among Regression Residuals. Geographical Analysis, 4 (3): pp. 267 - 284
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmFilter">lmFilter</a></code>, <code><a href="#topic+glmFilter">glmFilter</a></code>, <code><a href="#topic+MI.vec">MI.vec</a></code>,
<code><a href="#topic+MI.local">MI.local</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fakedata)
y &lt;- fakedataset$x1
x &lt;- fakedataset$x2

resid &lt;- y - x %*% solve(crossprod(x)) %*% crossprod(x,y)
(Moran &lt;- MI.resid(resid = resid, x = x, W = W, alternative = "greater"))

# intercept-only model
x &lt;- rep(1, length(y))
resid2 &lt;- y - x %*% solve(crossprod(x)) %*% crossprod(x,y)
intercept &lt;- MI.resid(resid = resid2, W = W, alternative = "greater")
# same result with MI.vec for the intercept-only model
vec &lt;- MI.vec(x = resid2, W = W, alternative = "greater")
rbind(intercept, vec)

</code></pre>

<hr>
<h2 id='MI.sf'>Moran Coefficient of the Spatial Filter</h2><span id='topic+MI.sf'></span>

<h3>Description</h3>

<p>Computes the Moran coefficient of the spatial filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MI.sf(gamma, evMI)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MI.sf_+3A_gamma">gamma</code></td>
<td>
<p>vector of regression coefficients associated with
the eigenvectors</p>
</td></tr>
<tr><td><code id="MI.sf_+3A_evmi">evMI</code></td>
<td>
<p>Moran coefficient of eigenvectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Moran coefficient of the spatial filter.
</p>


<h3>Author(s)</h3>

<p>Sebastian Juhl
</p>


<h3>References</h3>

<p>Le Gallo, Julie and Antonio Páez (2013): Using synthetic
variables in instrumental variable estimation of spatial series models.
Environment and Planning A: Economy and Space, 45 (9): pp. 2227 - 2242.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmFilter">lmFilter</a></code>, <code><a href="#topic+glmFilter">glmFilter</a></code>, <code><a href="#topic+getEVs">getEVs</a></code>,
<code><a href="#topic+MI.ev">MI.ev</a></code>
</p>

<hr>
<h2 id='MI.vec'>Local Moran Coefficient</h2><span id='topic+MI.vec'></span><span id='topic+MI.local'></span>

<h3>Description</h3>

<p>Reports the local Moran Coefficient for each unit.
</p>
<p>Tests for the presence of spatial autocorrelation
in variables as indicated by the Moran coefficient. The variance
is calculated under the normality assumption.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MI.local(x, W, alternative = "greater")

MI.vec(x, W, alternative = "greater", symmetrize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MI.vec_+3A_x">x</code></td>
<td>
<p>a vector or matrix</p>
</td></tr>
<tr><td><code id="MI.vec_+3A_w">W</code></td>
<td>
<p>spatial connectivity matrix</p>
</td></tr>
<tr><td><code id="MI.vec_+3A_alternative">alternative</code></td>
<td>
<p>specification of alternative hypothesis as 'greater' (default),
'lower', or 'two.sided'</p>
</td></tr>
<tr><td><code id="MI.vec_+3A_symmetrize">symmetrize</code></td>
<td>
<p>symmetrizes the connectivity matrix <em><strong>W</strong></em>
by: 1/2 * (<em><strong>W</strong></em> + <em><strong>W</strong></em>') (TRUE/ FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a matrix, this function computes the Moran
test for spatial autocorrelation for each column.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>data.frame</code> that contains the
following information for each variable:
</p>

<dl>
<dt><code>Ii</code></dt><dd><p>observed value of local Moran's I</p>
</dd>
<dt><code>EIi</code></dt><dd><p>expected value of local Moran coefficients</p>
</dd>
<dt><code>VarIi</code></dt><dd><p>variance of local Moran's I</p>
</dd>
<dt><code>zIi</code></dt><dd><p>standardized local Moran coefficient</p>
</dd>
<dt><code>pIi</code></dt><dd><p><em>p</em>-value of the test statistic</p>
</dd>
</dl>

<p>Returns an object of class <code>data.frame</code> that contains the
following information for each variable:
</p>

<dl>
<dt><code>I</code></dt><dd><p>observed value of the Moran coefficient</p>
</dd>
<dt><code>EI</code></dt><dd><p>expected value of Moran's I</p>
</dd>
<dt><code>VarI</code></dt><dd><p>variance of Moran's I (under normality)</p>
</dd>
<dt><code>zI</code></dt><dd><p>standardized Moran coefficient</p>
</dd>
<dt><code>pI</code></dt><dd><p><em>p</em>-value of the test statistic</p>
</dd>
</dl>



<h3>Note</h3>

<p>The calculation of the statistic and its moments follows
Anselin (1995) and Sokal et al. (1998).
</p>
<p>Estimation of the variance (under the normality assumption)
follows Cliff and Ord (1981), see also Upton and Fingleton (1985).
It assumes the connectivity matrix <em><strong>W</strong></em> to be symmetric.
For inherently non-symmetric matrices, it is recommended to specify
<code>symmetrize=TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Sebastian Juhl
</p>


<h3>References</h3>

<p>Anselin, Luc (1991): Local Indicators of Spatial
Association-LISA. Geographical Analysis, 27 (2): pp. 93 - 115.
</p>
<p>Bivand, Roger S. and David W. S. Wong (2018): Comparing Implementations
of Global and Local Indicators of Spatial Association. TEST, 27:
pp. 716 - 748.
</p>
<p>Sokal, Robert R., Neal L. Oden, Barbara A. Thomson (1998): Local
Spatial Autocorrelation in a Biological Model. Geographical Analysis,
30 (4): pp. 331 - 354.
</p>
<p>Cliff, Andrew D. and John K. Ord (1981): Spatial Processes:
Models &amp; Applications. Pion, London.
</p>
<p>Upton, Graham J. G. and Bernard Fingleton (1985): Spatial Data Analysis
by Example, Volume 1. New York, Wiley.
</p>
<p>Bivand, Roger S. and David W. S. Wong (2018): Comparing Implementations
of Global and Local Indicators of Spatial Association. TEST 27:
pp. 716 - 748.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MI.vec">MI.vec</a></code>, <code><a href="#topic+MI.ev">MI.ev</a></code>, <code><a href="#topic+MI.sf">MI.sf</a></code>,
<code><a href="#topic+MI.resid">MI.resid</a></code>, <code><a href="#topic+MI.decomp">MI.decomp</a></code>
</p>
<p><code><a href="#topic+MI.resid">MI.resid</a></code>, <code><a href="#topic+MI.local">MI.local</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fakedata)
x &lt;- fakedataset$x2

(MIi &lt;- MI.local(x = x, W = W, alternative = "greater"))

data(fakedata)
X &lt;- cbind(fakedataset$x1, fakedataset$x2, fakedataset$x3)

(MI &lt;- MI.vec(x = X, W = W, alternative = "greater", symmetrize = TRUE))

</code></pre>

<hr>
<h2 id='partialR2'>Coefficient of Partial Determination</h2><span id='topic+partialR2'></span>

<h3>Description</h3>

<p>This function computes the partial R-squared of all
selected eigenvectors in a spatially filtered linear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partialR2(y, x = NULL, evecs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partialR2_+3A_y">y</code></td>
<td>
<p>response variable</p>
</td></tr>
<tr><td><code id="partialR2_+3A_x">x</code></td>
<td>
<p>vector/ matrix of regressors</p>
</td></tr>
<tr><td><code id="partialR2_+3A_evecs">evecs</code></td>
<td>
<p>(selected) eigenvectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of partial R-squared values of the eigenvectors.
</p>


<h3>Note</h3>

<p>The function assumes a linear regression model. Since the
eigenvectors are mutually uncorrelated, <code>partialR2</code> evaluates
them sequentially. In generalized linear models, the presence of a link
function can corrupt the uncorrelatedness of the eigenvectors.
</p>


<h3>Author(s)</h3>

<p>Sebastian Juhl
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmFilter">lmFilter</a></code>, <code><a href="#topic+getEVs">getEVs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fakedata)
y &lt;- fakedataset$x1
x &lt;- fakedataset$x2

# get eigenvectors
E &lt;-getEVs(W = W, covars = NULL)$vectors

(out &lt;- partialR2(y = y, x = x, evecs = E[, 1:5]))


</code></pre>

<hr>
<h2 id='vif.ev'>Variance Inflation Factor of Eigenvectors</h2><span id='topic+vif.ev'></span>

<h3>Description</h3>

<p>Calculate the variance inflation factor (VIF) of
the eigenvectors in the spatial filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vif.ev(x = NULL, evecs, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vif.ev_+3A_x">x</code></td>
<td>
<p>vector/ matrix of regressors (default = NULL)</p>
</td></tr>
<tr><td><code id="vif.ev_+3A_evecs">evecs</code></td>
<td>
<p>(selected) eigenvectors</p>
</td></tr>
<tr><td><code id="vif.ev_+3A_na.rm">na.rm</code></td>
<td>
<p>remove missing values in covariates (TRUE/ FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector containing the VIF for each eigenvector.
</p>


<h3>Note</h3>

<p>This function assumes a linear model which ensures the
uncorrelatedness of the eigenvectors. Note that regression weights
or the link function used in generalized linear models can corrupt
this property.
</p>


<h3>Author(s)</h3>

<p>Sebastian Juhl
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmFilter">lmFilter</a></code>, <code><a href="#topic+getEVs">getEVs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fakedata)
E &lt;- getEVs(W = W, covars = NULL)$vectors
(VIF &lt;- vif.ev(x = fakedataset$x1, evecs = E[, 1:10]))

</code></pre>

<hr>
<h2 id='vp'>Variance Partitioning with Moran Spectral Randomization</h2><span id='topic+vp'></span>

<h3>Description</h3>

<p>This function decomposes the variation in an outcome variable
into four fractions: a) the influence of covariates, b) joint influence of
covariates and space, c) the influence of space, and d) unexplained residual
variation. Moran spectral randomization is applied to obtain the expected
value of the coefficient of determination adjusted for spurious correlations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vp(y, x = NULL, evecs = NULL, msr = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vp_+3A_y">y</code></td>
<td>
<p>outcome vector</p>
</td></tr>
<tr><td><code id="vp_+3A_x">x</code></td>
<td>
<p>vector/ matrix of covariates</p>
</td></tr>
<tr><td><code id="vp_+3A_evecs">evecs</code></td>
<td>
<p>selected eigenvectors</p>
</td></tr>
<tr><td><code id="vp_+3A_msr">msr</code></td>
<td>
<p>number of permutations to compute the expected value under H0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>vpart</code> which provides the following
information:
</p>

<dl>
<dt><code>R2</code></dt><dd><p>unadjusted fractions of explained variation</p>
</dd>
<dt><code>adjR2</code></dt><dd><p>adjusted fractions (based on Moran spectral randomization)</p>
</dd>
<dt><code>msr</code></dt><dd><p>number of permutations to obtain the expected value under H0</p>
</dd>
</dl>



<h3>Note</h3>

<p>The adjusted R-squared values are obtained by: 1 - (1 - R2) / (1 - E(R2|H0)).
For fractions [ab] and [a], Moran spectral randomization is used to derive
E(R2|H0). To this end, the rows in matrix (or column vector) x are randomly
permuted in order to preserve the correlation structure (see e.g., Clappe et
al. 2018).
</p>


<h3>Author(s)</h3>

<p>Sebastian Juhl
</p>


<h3>References</h3>

<p>Clappe, Sylvie, Dray Stéphane. and Pedro R. Peres-Neto (2018):
Beyond neutrality: disentangling the effects of species sorting
and spurious correlations in community analysis. Ecology 99 (8):
pp. 1737 - 1747.
</p>
<p>Wagner, Helene H., and Stéphane Dray (2015): Generating spatially
constrained null models for irregularly spaced data using Moran spectral
randomization methods. Methods in Ecology and Evolution 6 (10):
pp. 1169 - 1178.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getEVs">getEVs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fakedata)
E &lt;- getEVs(W = W, covars = NULL)$vectors

(partition &lt;- vp(y = fakedataset$x1, evecs = E[, 1:10], msr = 100))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
