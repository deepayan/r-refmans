<!DOCTYPE html><html lang="en"><head><title>Help for package spatsoc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spatsoc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#spatsoc'><p>spatsoc</p></a></li>
<li><a href='#build_lines'><p>Build Lines</p></a></li>
<li><a href='#build_polys'><p>Build Polygons</p></a></li>
<li><a href='#DT'><p>Movement of 10 &quot;Newfoundland Bog Cows&quot;</p></a></li>
<li><a href='#dyad_id'><p>Dyad ID</p></a></li>
<li><a href='#edge_dist'><p>Distance based edge lists</p></a></li>
<li><a href='#edge_nn'><p>Nearest neighbour based edge lists</p></a></li>
<li><a href='#get_gbi'><p>Generate group by individual matrix</p></a></li>
<li><a href='#group_lines'><p>Group Lines</p></a></li>
<li><a href='#group_polys'><p>Group Polygons</p></a></li>
<li><a href='#group_pts'><p>Group Points</p></a></li>
<li><a href='#group_times'><p>Group Times</p></a></li>
<li><a href='#randomizations'><p>Data-stream randomizations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Group Animal Relocation Data by Spatial and Temporal
Relationship</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Detects spatial and temporal groups in GPS relocations
    (Robitaille et al. (2019) &lt;<a href="https://doi.org/10.1111%2F2041-210X.13215">doi:10.1111/2041-210X.13215</a>&gt;).  It can be
    used to convert GPS relocations to gambit-of-the-group format to build
    proximity-based social networks In addition, the randomizations
    function provides data-stream randomization methods suitable for GPS
    data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.ropensci.org/spatsoc/">https://docs.ropensci.org/spatsoc/</a>,
<a href="https://github.com/ropensci/spatsoc">https://github.com/ropensci/spatsoc</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/spatsoc/issues">https://github.com/ropensci/spatsoc/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>adehabitatHR (&ge; 0.4.21), data.table (&ge; 1.10.5), igraph, sf,
stats, units</td>
</tr>
<tr>
<td>Suggests:</td>
<td>asnipe, knitr, markdown, rmarkdown, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GDAL (&gt;= 2.0.1), GEOS (&gt;= 3.4.0), PROJ (&gt;= 4.8.0),
sqlite3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-07 20:22:26 UTC; alecr</td>
</tr>
<tr>
<td>Author:</td>
<td>Alec L. Robitaille
    <a href="https://orcid.org/0000-0002-4706-1762"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Quinn Webber <a href="https://orcid.org/0000-0002-0434-9360"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Eric Vander Wal <a href="https://orcid.org/0000-0002-8534-4317"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alec L. Robitaille &lt;robit.alec@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-07 20:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='spatsoc'>spatsoc</h2><span id='topic+spatsoc'></span><span id='topic+_PACKAGE'></span><span id='topic+spatsoc-package'></span>

<h3>Description</h3>

<p>spatsoc is an R package for detecting spatial and temporal groups in GPS
relocations. It can be used to convert GPS relocations to gambit-of-the-group
format to build proximity-based social networks. In addition, the
randomization function provides data-stream randomization methods suitable
for GPS data.
</p>


<h3>Details</h3>

<p>The spatsoc package provides one temporal grouping function:
</p>
 <ul>
<li> <p><code><a href="#topic+group_times">group_times</a></code> </p>
</li></ul>
<p> three spatial grouping functions:
</p>
 <ul>
<li> <p><code><a href="#topic+group_pts">group_pts</a></code> </p>
</li>
<li> <p><code><a href="#topic+group_lines">group_lines</a></code> </p>
</li>
<li>
<p><code><a href="#topic+group_polys">group_polys</a></code> </p>
</li></ul>

<p>two edge list generating functions:
</p>
 <ul>
<li> <p><code><a href="#topic+edge_dist">edge_dist</a></code> </p>
</li>
<li> <p><code><a href="#topic+edge_nn">edge_nn</a></code> </p>
</li></ul>

<p>and two social network functions: </p>
 <ul>
<li>
<p><code><a href="#topic+randomizations">randomizations</a></code> </p>
</li>
<li> <p><code><a href="#topic+get_gbi">get_gbi</a></code> </p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Alec L. Robitaille <a href="mailto:robit.alec@gmail.com">robit.alec@gmail.com</a> (<a href="https://orcid.org/0000-0002-4706-1762">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Quinn Webber (<a href="https://orcid.org/0000-0002-0434-9360">ORCID</a>)
</p>
</li>
<li><p> Eric Vander Wal (<a href="https://orcid.org/0000-0002-8534-4317">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://docs.ropensci.org/spatsoc/">https://docs.ropensci.org/spatsoc/</a>
</p>
</li>
<li> <p><a href="https://github.com/ropensci/spatsoc">https://github.com/ropensci/spatsoc</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ropensci/spatsoc/issues">https://github.com/ropensci/spatsoc/issues</a>
</p>
</li></ul>


<hr>
<h2 id='build_lines'>Build Lines</h2><span id='topic+build_lines'></span>

<h3>Description</h3>

<p><code>build_lines</code> generates a simple feature collection with LINESTRINGs from a
<code>data.table</code>. The function accepts a <code>data.table</code> with relocation data,
individual identifiers, a sorting column and a <code>projection</code>. The relocation
data is transformed into LINESTRINGs for each individual and, optionally,
combination of columns listed in <code>splitBy</code>. Relocation data should be in two
columns representing the X and Y coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_lines(
  DT = NULL,
  projection = NULL,
  id = NULL,
  coords = NULL,
  sortBy = NULL,
  splitBy = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_lines_+3A_dt">DT</code></td>
<td>
<p>input data.table</p>
</td></tr>
<tr><td><code id="build_lines_+3A_projection">projection</code></td>
<td>
<p>numeric or character defining the coordinate reference
system to be passed to <a href="sf.html#topic+st_crs">sf::st_crs</a>. For example, either
<code>projection = "EPSG:32736"</code> or <code>projection = 32736</code>.</p>
</td></tr>
<tr><td><code id="build_lines_+3A_id">id</code></td>
<td>
<p>Character string of ID column name</p>
</td></tr>
<tr><td><code id="build_lines_+3A_coords">coords</code></td>
<td>
<p>Character vector of X coordinate and Y coordinate column names</p>
</td></tr>
<tr><td><code id="build_lines_+3A_sortby">sortBy</code></td>
<td>
<p>Character string of date time column(s) to sort rows by. Must
be a POSIXct.</p>
</td></tr>
<tr><td><code id="build_lines_+3A_splitby">splitBy</code></td>
<td>
<p>(optional) character string or vector of grouping column
name(s) upon which the grouping will be calculated</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>R-spatial evolution</h4>

<p>Please note, spatsoc has followed updates from R spatial, GDAL and PROJ
for handling projections, see more at
<a href="https://r-spatial.org/r/2020/03/17/wkt.html">https://r-spatial.org/r/2020/03/17/wkt.html</a>.
</p>
<p>In addition, <code>build_lines</code> previously used <a href="sp.html#topic+SpatialLines">sp::SpatialLines</a> but has been
updated to use <a href="sf.html#topic+st_as_sf">sf::st_as_sf</a> and <a href="sf.html#topic+st">sf::st_linestring</a> according to the
R-spatial evolution, see more at
<a href="https://r-spatial.org/r/2022/04/12/evolution.html">https://r-spatial.org/r/2022/04/12/evolution.html</a>.
</p>



<h4>Notes on arguments</h4>

<p>The <code>projection</code> argument expects a numeric or character defining the
coordinate reference system.
For example, for UTM zone 36N (EPSG 32736), the projection argument is either
<code>projection = 'EPSG:32736'</code> or <code>projection = 32736</code>.
See details in <code><a href="sf.html#topic+st_crs">sf::st_crs()</a></code> and <a href="https://spatialreference.org">https://spatialreference.org</a>
for a list of EPSG codes.
</p>
<p>The <code>sortBy</code> argument is used to order the input <code>DT</code> when creating
sf LINESTRINGs. It must a column in the input <code>DT</code> of type
POSIXct to ensure the rows are sorted by date time.
</p>
<p>The <code>splitBy</code> argument offers further control building LINESTRINGs.
If in your input <code>DT</code>, you have multiple temporal groups (e.g.: years) for
example, you can provide the name of the column which identifies them and
build LINESTRINGs for each individual in each year.
</p>
<p><code>build_lines</code> is used by <code>group_lines</code> for grouping overlapping
lines generated from relocations.
</p>



<h3>Value</h3>

<p><code>build_lines</code> returns an sf LINESTRING object with a line
for each individual (and optionally <code>splitBy</code> combination).
</p>
<p>Individuals (or combinations of individuals and <code>splitBy</code>) with less than two
relocations are dropped since it requires at least two relocations to
build a line.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+group_lines">group_lines</a></code>
</p>
<p>Other Build functions: 
<code><a href="#topic+build_polys">build_polys</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data.table
library(data.table)


# Read example data
DT &lt;- fread(system.file("extdata", "DT.csv", package = "spatsoc"))

# Cast the character column to POSIXct
DT[, datetime := as.POSIXct(datetime, tz = 'UTC')]

# EPSG code for example data
utm &lt;- 32736

# Build lines for each individual
lines &lt;- build_lines(DT, projection = utm, id = 'ID', coords = c('X', 'Y'),
            sortBy = 'datetime')

# Build lines for each individual by year
DT[, yr := year(datetime)]
lines &lt;- build_lines(DT, projection = utm, id = 'ID', coords = c('X', 'Y'),
            sortBy = 'datetime', splitBy = 'yr')
</code></pre>

<hr>
<h2 id='build_polys'>Build Polygons</h2><span id='topic+build_polys'></span>

<h3>Description</h3>

<p><code>build_polys</code> generates a simple feature collection with POLYGONs from a
<code>data.table</code>. The function accepts a <code>data.table</code> with
relocation data, individual identifiers, a projection,
home range type and parameters. The relocation
data is transformed into POLYGONs using either <a href="adehabitatHR.html#topic+mcp">adehabitatHR::mcp</a> or
<a href="adehabitatHR.html#topic+kernelUD">adehabitatHR::kernelUD</a> for each individual and, optionally,
combination of columns listed in <code>splitBy</code>. Relocation data should be in two
columns representing the X and Y coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_polys(
  DT = NULL,
  projection = NULL,
  hrType = NULL,
  hrParams = NULL,
  id = NULL,
  coords = NULL,
  splitBy = NULL,
  spPts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_polys_+3A_dt">DT</code></td>
<td>
<p>input data.table</p>
</td></tr>
<tr><td><code id="build_polys_+3A_projection">projection</code></td>
<td>
<p>numeric or character defining the coordinate reference
system to be passed to <a href="sf.html#topic+st_crs">sf::st_crs</a>. For example, either
<code>projection = "EPSG:32736"</code> or <code>projection = 32736</code>.</p>
</td></tr>
<tr><td><code id="build_polys_+3A_hrtype">hrType</code></td>
<td>
<p>type of HR estimation, either 'mcp' or 'kernel'</p>
</td></tr>
<tr><td><code id="build_polys_+3A_hrparams">hrParams</code></td>
<td>
<p>a named list of parameters for <code>adehabitatHR</code> functions</p>
</td></tr>
<tr><td><code id="build_polys_+3A_id">id</code></td>
<td>
<p>Character string of ID column name</p>
</td></tr>
<tr><td><code id="build_polys_+3A_coords">coords</code></td>
<td>
<p>Character vector of X coordinate and Y coordinate column names</p>
</td></tr>
<tr><td><code id="build_polys_+3A_splitby">splitBy</code></td>
<td>
<p>(optional) character string or vector of grouping column
name(s) upon which the grouping will be calculated</p>
</td></tr>
<tr><td><code id="build_polys_+3A_sppts">spPts</code></td>
<td>
<p>alternatively, provide solely a SpatialPointsDataFrame with one
column representing the ID of each point, as specified by <a href="adehabitatHR.html#topic+mcp">adehabitatHR::mcp</a>
or <a href="adehabitatHR.html#topic+kernelUD">adehabitatHR::kernelUD</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="#topic+group_polys">group_polys</a> uses <code>build_polys</code> for grouping overlapping
polygons created from relocations.
</p>


<h4>R-spatial evolution</h4>

<p>Please note, spatsoc has followed updates from R spatial, GDAL and PROJ for
handling projections, see more below and  details at
<a href="https://r-spatial.org/r/2020/03/17/wkt.html">https://r-spatial.org/r/2020/03/17/wkt.html</a>.
</p>
<p>In addition, <code>build_polys</code> previously used <a href="sp.html#topic+SpatialPoints">sp::SpatialPoints</a> but has been
updated to use <a href="sf.html#topic+st_as_sf">sf::st_as_sf</a> according to the R-spatial evolution, see more
at <a href="https://r-spatial.org/r/2022/04/12/evolution.html">https://r-spatial.org/r/2022/04/12/evolution.html</a>.
</p>



<h4>Notes on arguments</h4>

<p>The <code>DT</code> must be a <code>data.table</code>. If your data is a <code>data.frame</code>, you can
convert it by reference using <a href="data.table.html#topic+setDT">data.table::setDT</a>.
</p>
<p>The <code>id</code>, <code>coords</code> (and optional <code>splitBy</code>) arguments
expect the names of respective columns in <code>DT</code> which correspond
to the individual identifier, X and Y coordinates, and additional
grouping columns.
</p>
<p>The <code>projection</code> argument expects a character string or numeric
defining the coordinate reference system to be passed to <a href="sf.html#topic+st_crs">sf::st_crs</a>.
For example, for UTM zone 36S (EPSG 32736), the projection
argument is <code>projection = "EPSG:32736"</code> or <code>projection = 32736</code>.
See <a href="https://spatialreference.org">https://spatialreference.org</a>
for a list of EPSG codes.
</p>
<p>The <code>hrType</code> must be either one of &quot;kernel&quot; or &quot;mcp&quot;. The
<code>hrParams</code> must be a named list of arguments matching those
of <a href="adehabitatHR.html#topic+kernelUD">adehabitatHR::kernelUD</a> and <a href="adehabitatHR.html#topic+getverticeshr">adehabitatHR::getverticeshr</a>
or <a href="adehabitatHR.html#topic+mcp">adehabitatHR::mcp</a>.
</p>
<p>The <code>splitBy</code> argument offers further control building
POLYGONs. If in your <code>DT</code>, you have multiple
temporal groups (e.g.: years) for example, you can provide the
name of the column which identifies them and build POLYGONs
for each individual in each year.
</p>



<h3>Value</h3>

<p><code>build_polys</code> returns a simple feature collection with POLYGONs
for each individual (and optionally <code>splitBy</code> combination).
</p>
<p>An error is returned when <code>hrParams</code> do not match the arguments
of the respective <code>hrType</code> <code>adehabitatHR</code> function.
</p>


<h3>See Also</h3>

<p><a href="#topic+group_polys">group_polys</a>
</p>
<p>Other Build functions: 
<code><a href="#topic+build_lines">build_lines</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data.table
library(data.table)


# Read example data
DT &lt;- fread(system.file("extdata", "DT.csv", package = "spatsoc"))

# Cast the character column to POSIXct
DT[, datetime := as.POSIXct(datetime, tz = 'UTC')]

# EPSG code for example data
utm &lt;- 32736

# Build polygons for each individual using kernelUD and getverticeshr
build_polys(DT, projection = utm, hrType = 'kernel',
            hrParams = list(grid = 60, percent = 95),
            id = 'ID', coords = c('X', 'Y'))

# Build polygons for each individual by year
DT[, yr := year(datetime)]
build_polys(DT, projection = utm, hrType = 'mcp',
            hrParams = list(percent = 95),
            id = 'ID', coords = c('X', 'Y'), splitBy = 'yr')
</code></pre>

<hr>
<h2 id='DT'>Movement of 10 &quot;Newfoundland Bog Cows&quot;</h2><span id='topic+DT'></span>

<h3>Description</h3>

<p>A dataset containing the GPS relocations of 10 individuals in winter
2016-2017.
</p>


<h3>Format</h3>

<p>A data.table with 14297 rows and 5 variables: </p>

<dl>
<dt>ID</dt><dd><p>individual identifier</p>
</dd> <dt>X</dt><dd><p>X coordinate of the relocation
(UTM 36N)</p>
</dd> <dt>Y</dt><dd><p>Y coordinate of the relocation (UTM 36N)</p>
</dd>
<dt>datetime</dt><dd><p>character string representing the date time</p>
</dd>
<dt>population</dt><dd><p>sub population within the individuals</p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'># Load data.table
library(data.table)


# Read example data
DT &lt;- fread(system.file("extdata", "DT.csv", package = "spatsoc"))
</code></pre>

<hr>
<h2 id='dyad_id'>Dyad ID</h2><span id='topic+dyad_id'></span>

<h3>Description</h3>

<p>Generate a dyad ID for edge list generated by <code><a href="#topic+edge_nn">edge_nn</a></code> or
<code><a href="#topic+edge_dist">edge_dist</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dyad_id(DT = NULL, id1 = NULL, id2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dyad_id_+3A_dt">DT</code></td>
<td>
<p>input data.table with columns id1 and id2, as generated by
<code>edge_dist</code> or <code>edge_nn</code></p>
</td></tr>
<tr><td><code id="dyad_id_+3A_id1">id1</code></td>
<td>
<p>ID1 column name generated by <code>edge_dist</code> or <code>edge_nn</code></p>
</td></tr>
<tr><td><code id="dyad_id_+3A_id2">id2</code></td>
<td>
<p>ID2 column name generated by <code>edge_dist</code> or <code>edge_nn</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>An undirected edge identifier between, for example individuals A and B will
be A-B (and reverse B and A will be A-B). Internally sorts and pastes id
columns.
</p>
<p>More details in the edge and dyad vignette (in progress).
</p>


<h3>Value</h3>

<p><code>dyad_id</code> returns the input <code>data.table</code> with appended &quot;dyadID&quot;
column
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data.table
library(data.table)


# Read example data
DT &lt;- fread(system.file("extdata", "DT.csv", package = "spatsoc"))

# Cast the character column to POSIXct
DT[, datetime := as.POSIXct(datetime, tz = 'UTC')]

# Temporal grouping
group_times(DT, datetime = 'datetime', threshold = '20 minutes')

# Edge list generation
edges &lt;- edge_dist(
    DT,
    threshold = 100,
    id = 'ID',
    coords = c('X', 'Y'),
    timegroup = 'timegroup',
    returnDist = TRUE,
    fillNA = TRUE
  )

# Generate dyad IDs
dyad_id(edges, 'ID1', 'ID2')
</code></pre>

<hr>
<h2 id='edge_dist'>Distance based edge lists</h2><span id='topic+edge_dist'></span>

<h3>Description</h3>

<p><code>edge_dist</code> returns edge lists defined by a spatial distance within the
user defined threshold. The function accepts a <code>data.table</code> with
relocation data, individual identifiers and a threshold argument. The
threshold argument is used to specify the criteria for distance between
points which defines a group. Relocation data should be in two columns
representing the X and Y coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_dist(
  DT = NULL,
  threshold,
  id = NULL,
  coords = NULL,
  timegroup,
  splitBy = NULL,
  returnDist = FALSE,
  fillNA = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edge_dist_+3A_dt">DT</code></td>
<td>
<p>input data.table</p>
</td></tr>
<tr><td><code id="edge_dist_+3A_threshold">threshold</code></td>
<td>
<p>distance for grouping points, in the units of the
coordinates</p>
</td></tr>
<tr><td><code id="edge_dist_+3A_id">id</code></td>
<td>
<p>Character string of ID column name</p>
</td></tr>
<tr><td><code id="edge_dist_+3A_coords">coords</code></td>
<td>
<p>Character vector of X coordinate and Y coordinate column names</p>
</td></tr>
<tr><td><code id="edge_dist_+3A_timegroup">timegroup</code></td>
<td>
<p>timegroup field in the DT within which the grouping will be
calculated</p>
</td></tr>
<tr><td><code id="edge_dist_+3A_splitby">splitBy</code></td>
<td>
<p>(optional) character string or vector of grouping column
name(s) upon which the grouping will be calculated</p>
</td></tr>
<tr><td><code id="edge_dist_+3A_returndist">returnDist</code></td>
<td>
<p>boolean indicating if the distance between individuals
should be returned. If FALSE (default), only ID1, ID2 columns (and
timegroup, splitBy columns if provided) are returned. If TRUE, another
column &quot;distance&quot; is returned indicating the distance between ID1 and ID2.</p>
</td></tr>
<tr><td><code id="edge_dist_+3A_fillna">fillNA</code></td>
<td>
<p>boolean indicating if NAs should be returned for individuals
that were not within the threshold distance of any other. If TRUE, NAs are
returned. If FALSE, only edges between individuals within the threshold
distance are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>DT</code> must be a <code>data.table</code>. If your data is a
<code>data.frame</code>, you can convert it by reference using
<code><a href="data.table.html#topic+setDT">data.table::setDT</a></code>.
</p>
<p>The <code>id</code>, <code>coords</code> <code>timegroup</code> (and optional <code>splitBy</code>)
arguments expect the names of a column in <code>DT</code> which correspond to the
individual identifier, X and Y coordinates, timegroup (generated by
<code>group_times</code>) and additional grouping columns.
</p>
<p>If provided, the <code>threshold</code> must be provided in the units of the coordinates and must be larger than 0.
If the <code>threshold</code> is NULL, the distance to all other individuals will be returned. The coordinates must be planar
coordinates (e.g.: UTM). In the case of UTM, a <code>threshold</code> = 50 would
indicate a 50m distance threshold.
</p>
<p>The <code>timegroup</code> argument is required to define the temporal groups
within which edges are calculated. The intended framework is to group rows
temporally with <code><a href="#topic+group_times">group_times</a></code> then spatially with <code>edge_dist</code>.
If you have already calculated temporal groups without
<code><a href="#topic+group_times">group_times</a></code>, you can pass this column to the <code>timegroup</code>
argument. Note that the expectation is that each individual will be observed
only once per timegroup. Caution that accidentally including huge numbers of
rows within timegroups can overload your machine since all pairwise distances
are calculated within each timegroup.
</p>
<p>The <code>splitBy</code> argument offers further control over grouping. If within
your <code>DT</code>, you have multiple populations, subgroups or other distinct
parts, you can provide the name of the column which identifies them to
<code>splitBy</code>. <code>edge_dist</code> will only consider rows within each
<code>splitBy</code> subgroup.
</p>


<h3>Value</h3>

<p><code>edge_dist</code> returns a <code>data.table</code> with columns ID1, ID2,
timegroup (if supplied) and any columns provided in splitBy. If
'returnDist' is TRUE, column 'distance' is returned indicating the distance
between ID1 and ID2.
</p>
<p>The ID1 and ID2 columns represent the edges defined by the spatial (and
temporal with <code>group_times</code>) thresholds.
</p>


<h3>See Also</h3>

<p>Other Edge-list generation: 
<code><a href="#topic+edge_nn">edge_nn</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data.table
library(data.table)


# Read example data
DT &lt;- fread(system.file("extdata", "DT.csv", package = "spatsoc"))

# Cast the character column to POSIXct
DT[, datetime := as.POSIXct(datetime, tz = 'UTC')]

# Temporal grouping
group_times(DT, datetime = 'datetime', threshold = '20 minutes')

# Edge list generation
edges &lt;- edge_dist(
    DT,
    threshold = 100,
    id = 'ID',
    coords = c('X', 'Y'),
    timegroup = 'timegroup',
    returnDist = TRUE,
    fillNA = TRUE
  )
</code></pre>

<hr>
<h2 id='edge_nn'>Nearest neighbour based edge lists</h2><span id='topic+edge_nn'></span>

<h3>Description</h3>

<p><code>edge_nn</code> returns edge lists defined by the nearest neighbour. The
function accepts a <code>data.table</code> with relocation data, individual
identifiers and a threshold argument. The threshold argument is used to
specify the criteria for distance between points which defines a group.
Relocation data should be in two columns representing the X and Y
coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_nn(
  DT = NULL,
  id = NULL,
  coords = NULL,
  timegroup,
  splitBy = NULL,
  threshold = NULL,
  returnDist = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edge_nn_+3A_dt">DT</code></td>
<td>
<p>input data.table</p>
</td></tr>
<tr><td><code id="edge_nn_+3A_id">id</code></td>
<td>
<p>Character string of ID column name</p>
</td></tr>
<tr><td><code id="edge_nn_+3A_coords">coords</code></td>
<td>
<p>Character vector of X coordinate and Y coordinate column names</p>
</td></tr>
<tr><td><code id="edge_nn_+3A_timegroup">timegroup</code></td>
<td>
<p>timegroup field in the DT within which the grouping will be
calculated</p>
</td></tr>
<tr><td><code id="edge_nn_+3A_splitby">splitBy</code></td>
<td>
<p>(optional) character string or vector of grouping column
name(s) upon which the grouping will be calculated</p>
</td></tr>
<tr><td><code id="edge_nn_+3A_threshold">threshold</code></td>
<td>
<p>(optional) spatial distance threshold to set maximum
distance between an individual and their neighbour.</p>
</td></tr>
<tr><td><code id="edge_nn_+3A_returndist">returnDist</code></td>
<td>
<p>boolean indicating if the distance between individuals
should be returned. If FALSE (default), only ID, NN columns (and timegroup,
splitBy columns if provided) are returned. If TRUE, another column
&quot;distance&quot; is returned indicating the distance between ID and NN.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>DT</code> must be a <code>data.table</code>. If your data is a
<code>data.frame</code>, you can convert it by reference using
<code><a href="data.table.html#topic+setDT">data.table::setDT</a></code>.
</p>
<p>The <code>id</code>, <code>coords</code>, <code>timegroup</code>  (and optional <code>splitBy</code>)
arguments expect the names of a column in <code>DT</code> which correspond to the
individual identifier, X and Y coordinates, timegroup (generated by
<code>group_times</code>) and additional grouping columns.
</p>
<p>The <code>threshold</code> must be provided in the units of the coordinates. The
<code>threshold</code> must be larger than 0. The coordinates must be planar
coordinates (e.g.: UTM). In the case of UTM, a <code>threshold</code> = 50 would
indicate a 50m distance threshold.
</p>
<p>The <code>timegroup</code> argument is required to define the temporal groups
within which edge nearest neighbours are calculated. The intended framework
is to group rows temporally with <code><a href="#topic+group_times">group_times</a></code> then spatially
with <code>edge_nn</code>. If you have already calculated temporal groups without
<code><a href="#topic+group_times">group_times</a></code>, you can pass this column to the <code>timegroup</code>
argument. Note that the expectation is that each individual will be observed
only once per timegroup. Caution that accidentally including huge numbers of
rows within timegroups can overload your machine since all pairwise distances
are calculated within each timegroup.
</p>
<p>The <code>splitBy</code> argument offers further control over grouping. If within
your <code>DT</code>, you have multiple populations, subgroups or other distinct
parts, you can provide the name of the column which identifies them to
<code>splitBy</code>. <code>edge_nn</code> will only consider rows within each
<code>splitBy</code> subgroup.
</p>


<h3>Value</h3>

<p><code>edge_nn</code> returns a <code>data.table</code>  with three columns:
timegroup, ID and NN. If 'returnDist' is TRUE, column 'distance' is
returned indicating the distance between ID and NN.
</p>
<p>The ID and NN columns represent the edges defined by the nearest neighbours
(and temporal thresholds with <code>group_times</code>).
</p>
<p>If an individual was alone in a timegroup or splitBy, or did not have any
neighbours within the threshold distance, they are assigned NA for nearest
neighbour.
</p>


<h3>See Also</h3>

<p>Other Edge-list generation: 
<code><a href="#topic+edge_dist">edge_dist</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data.table
library(data.table)


# Read example data
DT &lt;- fread(system.file("extdata", "DT.csv", package = "spatsoc"))

# Select only individuals A, B, C for this example
DT &lt;- DT[ID %in% c('A', 'B', 'C')]

# Cast the character column to POSIXct
DT[, datetime := as.POSIXct(datetime, tz = 'UTC')]

# Temporal grouping
group_times(DT, datetime = 'datetime', threshold = '20 minutes')

# Edge list generation
edges &lt;- edge_nn(DT, id = 'ID', coords = c('X', 'Y'),
        timegroup = 'timegroup')

# Edge list generation using maximum distance threshold
edges &lt;- edge_nn(DT, id = 'ID', coords = c('X', 'Y'),
        timegroup = 'timegroup', threshold = 100)

# Edge list generation, returning distance between nearest neighbours
edge_nn(DT, id = 'ID', coords = c('X', 'Y'),
        timegroup = 'timegroup', threshold = 100,
        returnDist = TRUE)

</code></pre>

<hr>
<h2 id='get_gbi'>Generate group by individual matrix</h2><span id='topic+get_gbi'></span>

<h3>Description</h3>

<p><code>get_gbi</code> generates a group by individual matrix. The function accepts a
<code>data.table</code> with individual identifiers and a group column. The group
by individual matrix can then be used to build a network using
<code><a href="asnipe.html#topic+get_network">asnipe::get_network</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_gbi(DT = NULL, group = "group", id = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_gbi_+3A_dt">DT</code></td>
<td>
<p>input data.table</p>
</td></tr>
<tr><td><code id="get_gbi_+3A_group">group</code></td>
<td>
<p>Character string of group column (generated from one of
spatsoc's spatial grouping functions)</p>
</td></tr>
<tr><td><code id="get_gbi_+3A_id">id</code></td>
<td>
<p>Character string of ID column name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>DT</code> must be a <code>data.table</code>. If your data is a
<code>data.frame</code>, you can convert it by reference using
<code><a href="data.table.html#topic+setDT">data.table::setDT</a></code>.
</p>
<p>The <code>group</code> argument expects the name of a column which corresponds to
an integer group identifier (generated by <code><a href="#topic+spatsoc">spatsoc</a></code>'s grouping
functions).
</p>
<p>The <code>id</code> argument expects the name of a column which corresponds to the
individual identifier.
</p>


<h3>Value</h3>

<p><code>get_gbi</code> returns a group by individual matrix (columns
represent individuals and rows represent groups).
</p>
<p>Note that <code>get_gbi</code> is identical in function for turning the outputs
of <code>spatsoc</code> into social networks as
<code><a href="asnipe.html#topic+get_group_by_individual">asnipe::get_group_by_individual</a></code>
but is more efficient thanks to
<code><a href="data.table.html#topic+dcast.data.table">data.table::dcast</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+group_pts">group_pts</a></code> <code><a href="#topic+group_lines">group_lines</a></code>
<code><a href="#topic+group_polys">group_polys</a></code>
</p>
<p>Other Social network tools: 
<code><a href="#topic+randomizations">randomizations</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data.table
library(data.table)


# Read example data
DT &lt;- fread(system.file("extdata", "DT.csv", package = "spatsoc"))

# Cast the character column to POSIXct
DT[, datetime := as.POSIXct(datetime, tz = 'UTC')]
DT[, yr := year(datetime)]

# EPSG code for example data
utm &lt;- 'EPSG:32736'

group_polys(DT, area = FALSE, hrType = 'mcp',
            hrParams = list(percent = 95),
            projection = utm, id = 'ID', coords = c('X', 'Y'),
            splitBy = 'yr')

gbiMtrx &lt;- get_gbi(DT = DT, group = 'group', id = 'ID')

</code></pre>

<hr>
<h2 id='group_lines'>Group Lines</h2><span id='topic+group_lines'></span>

<h3>Description</h3>

<p><code>group_lines</code> groups rows into spatial groups by generating LINESTRINGs and
grouping based on spatial intersection. The function accepts a <code>data.table</code>
with relocation data, individual identifiers and a distance threshold. The
relocation data is transformed into sf LINESTRINGs using <a href="#topic+build_lines">build_lines</a> and
intersecting LINESTRINGs are grouped. The threshold argument is used to
specify the distance criteria for grouping. Relocation data should be in two
columns representing the X and Y coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_lines(
  DT = NULL,
  threshold = NULL,
  projection = NULL,
  id = NULL,
  coords = NULL,
  timegroup = NULL,
  sortBy = NULL,
  splitBy = NULL,
  sfLines = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_lines_+3A_dt">DT</code></td>
<td>
<p>input data.table</p>
</td></tr>
<tr><td><code id="group_lines_+3A_threshold">threshold</code></td>
<td>
<p>The width of the buffer around the lines in the units of the
projection. Use <code>threshold = 0</code> to compare intersection without buffering.</p>
</td></tr>
<tr><td><code id="group_lines_+3A_projection">projection</code></td>
<td>
<p>numeric or character defining the coordinate reference
system to be passed to <a href="sf.html#topic+st_crs">sf::st_crs</a>. For example, either
<code>projection = "EPSG:32736"</code> or <code>projection = 32736</code>.</p>
</td></tr>
<tr><td><code id="group_lines_+3A_id">id</code></td>
<td>
<p>Character string of ID column name</p>
</td></tr>
<tr><td><code id="group_lines_+3A_coords">coords</code></td>
<td>
<p>Character vector of X coordinate and Y coordinate column names</p>
</td></tr>
<tr><td><code id="group_lines_+3A_timegroup">timegroup</code></td>
<td>
<p>timegroup field in the DT within which the grouping will be
calculated</p>
</td></tr>
<tr><td><code id="group_lines_+3A_sortby">sortBy</code></td>
<td>
<p>Character string of date time column(s) to sort rows by. Must
be a POSIXct.</p>
</td></tr>
<tr><td><code id="group_lines_+3A_splitby">splitBy</code></td>
<td>
<p>(optional) character string or vector of grouping column
name(s) upon which the grouping will be calculated</p>
</td></tr>
<tr><td><code id="group_lines_+3A_sflines">sfLines</code></td>
<td>
<p>Alternatively to providing a DT, provide a simple feature
LINESTRING object generated with the sf package. The id argument is
required to provide the identifier matching each LINESTRING.
If an sfLines object is provided, groups cannot be calculated by timegroup
or splitBy.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>R-spatial evolution</h4>

<p>Please note, spatsoc has followed updates from R spatial, GDAL and PROJ for
handling projections, see more at
<a href="https://r-spatial.org/r/2020/03/17/wkt.html">https://r-spatial.org/r/2020/03/17/wkt.html</a>.
</p>
<p>In addition, <code>group_lines</code> (and <a href="#topic+build_lines">build_lines</a>) previously used
<a href="sp.html#topic+SpatialLines">sp::SpatialLines</a>, rgeos::gIntersects, rgeos::gBuffer but have been
updated to use <a href="sf.html#topic+st_as_sf">sf::st_as_sf</a>, <a href="sf.html#topic+st">sf::st_linestring</a>, <a href="sf.html#topic+geos_binary_pred">sf::st_intersects</a>, and
<a href="sf.html#topic+geos_unary">sf::st_buffer</a> according to the R-spatial evolution, see more at
<a href="https://r-spatial.org/r/2022/04/12/evolution.html">https://r-spatial.org/r/2022/04/12/evolution.html</a>.
</p>



<h4>Notes on arguments</h4>

<p>The <code>DT</code> must be a <code>data.table</code>. If your data is a
<code>data.frame</code>, you can convert it by reference using <a href="data.table.html#topic+setDT">data.table::setDT</a>.
</p>
<p>The <code>id</code>, <code>coords</code>, <code>sortBy</code> (and optional <code>timegroup</code>
and <code>splitBy</code>) arguments expect the names of respective columns in
<code>DT</code> which correspond to the individual identifier, X and Y coordinates,
sorting, timegroup (generated by <a href="#topic+group_times">group_times</a>) and additional grouping
columns.
</p>
<p>The <code>projection</code> argument expects a numeric or character defining the
coordinate reference system. For example, for UTM zone 36N (EPSG 32736), the
projection argument is either <code>projection = 'EPSG:32736'</code> or <code>projection = 32736</code>. See details in <code><a href="sf.html#topic+st_crs">sf::st_crs()</a></code> and
<a href="https://spatialreference.org">https://spatialreference.org</a> for a list of EPSG codes.
</p>
<p>The <code>sortBy</code> argument is used to order the input <code>DT</code> when creating sf
LINESTRINGs. It must a column in the input <code>DT</code> of type POSIXct to ensure the
rows are sorted by date time.
</p>
<p>The <code>threshold</code> must be provided in the units of the coordinates. The
<code>threshold</code> can be equal to 0 if strict overlap is intended, otherwise it
should be some value greater than 0. The coordinates must be planar
coordinates (e.g.: UTM). In the case of UTM, a <code>threshold = 50</code> would
indicate a 50m distance threshold.
</p>
<p>The <code>timegroup</code> argument is optional, but recommended to pair with
<a href="#topic+group_times">group_times</a>. The intended framework is to group rows temporally with
<a href="#topic+group_times">group_times</a> then spatially with <a href="#topic+group_lines">group_lines</a> (or <a href="#topic+group_pts">group_pts</a>,
<a href="#topic+group_polys">group_polys</a>). With <a href="#topic+group_lines">group_lines</a>, pick a relevant <a href="#topic+group_times">group_times</a> threshold
such as <code>'1 day'</code> or <code>'7 days'</code> which is informed by your study species,
system or question.
</p>
<p>The <code>splitBy</code> argument offers further control building LINESTRINGs. If in
your input <code>DT</code>, you have multiple temporal groups (e.g.: years) for example,
you can provide the name of the column which identifies them and build
LINESTRINGs for each individual in each year. The grouping performed by
<a href="#topic+group_lines">group_lines</a> will only consider rows within each <code>splitBy</code> subgroup.
</p>



<h3>Value</h3>

<p><code>group_lines</code> returns the input <code>DT</code> appended with a &quot;group&quot;
column.
</p>
<p>This column represents the spatial (and if <code>timegroup</code> was provided -
spatiotemporal) group calculated by intersecting lines. As with the other
grouping functions,  the actual value of group is arbitrary and represents
the identity of a given group where 1 or more individuals are assigned to a
group. If the data was reordered, the group may change, but the contents of
each group would not.
</p>
<p>A message is returned when a column named &quot;group&quot; already exists in the
input <code>DT</code>, because it will be overwritten.
</p>


<h3>See Also</h3>

<p><a href="#topic+build_lines">build_lines</a> <a href="#topic+group_times">group_times</a>
</p>
<p>Other Spatial grouping: 
<code><a href="#topic+group_polys">group_polys</a>()</code>,
<code><a href="#topic+group_pts">group_pts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data.table
library(data.table)


# Read example data
DT &lt;- fread(system.file("extdata", "DT.csv", package = "spatsoc"))

# Subset only individuals A, B, and C
DT &lt;- DT[ID %in% c('A', 'B', 'C')]

# Cast the character column to POSIXct
DT[, datetime := as.POSIXct(datetime, tz = 'UTC')]

# EPSG code for example data
utm &lt;- 32736

group_lines(DT, threshold = 50, projection = utm, sortBy = 'datetime',
            id = 'ID', coords = c('X', 'Y'))

## Daily movement tracks
# Temporal grouping
group_times(DT, datetime = 'datetime', threshold = '1 day')

# Subset only first 50 days
DT &lt;- DT[timegroup &lt; 25]

# Spatial grouping
group_lines(DT, threshold = 50, projection = utm,
            id = 'ID', coords = c('X', 'Y'),
            timegroup = 'timegroup', sortBy = 'datetime')

## Daily movement tracks by population
group_lines(DT, threshold = 50, projection = utm,
            id = 'ID', coords = c('X', 'Y'),
            timegroup = 'timegroup', sortBy = 'datetime',
            splitBy = 'population')
</code></pre>

<hr>
<h2 id='group_polys'>Group Polygons</h2><span id='topic+group_polys'></span>

<h3>Description</h3>

<p><code>group_polys</code> groups rows into spatial groups by overlapping polygons (home
ranges). The function accepts a <code>data.table</code> with relocation data, individual
identifiers and an <code>area</code> argument.  The relocation data is transformed into
home range POLYGONs using <code><a href="#topic+build_polys">build_polys()</a></code> with <a href="adehabitatHR.html#topic+mcp">adehabitatHR::mcp</a> or
<a href="adehabitatHR.html#topic+kernelUD">adehabitatHR::kernelUD</a>. If the <code>area</code> argument is <code>FALSE</code>, <code>group_polys</code>
returns grouping calculated by spatial overlap. If the <code>area</code> argument is
<code>TRUE</code>, <code>group_polys</code> returns the area area and proportion of overlap.
Relocation data should be in two columns representing the X and Y
coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_polys(
  DT = NULL,
  area = NULL,
  hrType = NULL,
  hrParams = NULL,
  projection = NULL,
  id = NULL,
  coords = NULL,
  splitBy = NULL,
  sfPolys = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_polys_+3A_dt">DT</code></td>
<td>
<p>input data.table</p>
</td></tr>
<tr><td><code id="group_polys_+3A_area">area</code></td>
<td>
<p>boolean indicating either overlap group (when <code>FALSE</code>) or
area and proportion of overlap (when <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="group_polys_+3A_hrtype">hrType</code></td>
<td>
<p>type of HR estimation, either 'mcp' or 'kernel'</p>
</td></tr>
<tr><td><code id="group_polys_+3A_hrparams">hrParams</code></td>
<td>
<p>a named list of parameters for <code>adehabitatHR</code> functions</p>
</td></tr>
<tr><td><code id="group_polys_+3A_projection">projection</code></td>
<td>
<p>numeric or character defining the coordinate reference
system to be passed to <a href="sf.html#topic+st_crs">sf::st_crs</a>. For example, either
<code>projection = "EPSG:32736"</code> or <code>projection = 32736</code>.</p>
</td></tr>
<tr><td><code id="group_polys_+3A_id">id</code></td>
<td>
<p>Character string of ID column name</p>
</td></tr>
<tr><td><code id="group_polys_+3A_coords">coords</code></td>
<td>
<p>Character vector of X coordinate and Y coordinate column names</p>
</td></tr>
<tr><td><code id="group_polys_+3A_splitby">splitBy</code></td>
<td>
<p>(optional) character string or vector of grouping column
name(s) upon which the grouping will be calculated</p>
</td></tr>
<tr><td><code id="group_polys_+3A_sfpolys">sfPolys</code></td>
<td>
<p>Alternatively, provide solely a simple features object with
POLYGONs or MULTIPOLYGONs. If sfPolys are provided, id is required and
splitBy cannot be used.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>R-spatial evolution</h4>

<p>Please note, spatsoc has followed updates from R spatial, GDAL and PROJ for
handling projections, see more below and  details at
<a href="https://r-spatial.org/r/2020/03/17/wkt.html">https://r-spatial.org/r/2020/03/17/wkt.html</a>.
</p>
<p>In addition, <code>group_polys</code> previously used rgeos::gIntersection,
rgeos::gIntersects and rgeos::gArea but has been
updated to use <a href="sf.html#topic+geos_binary_pred">sf::st_intersects</a>, <a href="sf.html#topic+geos_binary_ops">sf::st_intersection</a> and <a href="sf.html#topic+geos_measures">sf::st_area</a>
according to the R-spatial evolution, see more
at <a href="https://r-spatial.org/r/2022/04/12/evolution.html">https://r-spatial.org/r/2022/04/12/evolution.html</a>.
</p>



<h4>Notes on arguments</h4>

<p>The <code>DT</code> must be a <code>data.table</code>. If your data is a
<code>data.frame</code>, you can convert it by reference using
<code><a href="data.table.html#topic+setDT">data.table::setDT()</a></code>.
</p>
<p>The <code>id</code>, <code>coords</code> (and optional <code>splitBy</code>) arguments expect
the names of respective columns in <code>DT</code> which correspond to the
individual identifier, X and Y coordinates, and additional grouping columns.
</p>
<p>The <code>projection</code> argument expects a character string or numeric
defining the coordinate reference system to be passed to <a href="sf.html#topic+st_crs">sf::st_crs</a>.
For example, for UTM zone 36S (EPSG 32736), the projection
argument is <code>projection = "EPSG:32736"</code> or <code>projection = 32736</code>.
See <a href="https://spatialreference.org">https://spatialreference.org</a>
for a list of EPSG codes.
</p>
<p>The <code>hrType</code> must be either one of &quot;kernel&quot; or &quot;mcp&quot;. The
<code>hrParams</code> must be a named list of arguments matching those of
<code><a href="adehabitatHR.html#topic+kernelUD">adehabitatHR::kernelUD()</a></code> or <code><a href="adehabitatHR.html#topic+mcp">adehabitatHR::mcp()</a></code>.
</p>
<p>The <code>splitBy</code> argument offers further control over grouping. If within
your <code>DT</code>, you have multiple populations, subgroups or other distinct
parts, you can provide the name of the column which identifies them to
<code>splitBy</code>. The grouping performed by <code>group_polys</code> will only
consider rows within each <code>splitBy</code> subgroup.
</p>



<h3>Value</h3>

<p>When <code>area</code> is <code>FALSE</code>, <code>group_polys</code> returns the input <code>DT</code> appended
with a <code>group</code> column. As with the other grouping functions,  the actual
value of <code>group</code> is arbitrary and represents the identity of a given group
where 1 or more individuals are assigned to a group. If the data was
reordered, the <code>group</code> may change, but the contents of each group would
not. When <code>area</code> is <code>TRUE</code>, <code>group_polys</code> returns a proportional area
overlap <code>data.table</code>. In this case, ID refers to the focal individual of
which the total area is compared against the overlapping area of ID2.
</p>
<p>If <code>area</code> is <code>FALSE</code>, a message is returned when a column named <code>group</code>
already exists in the input <code>DT</code>, because it will be overwritten.
</p>
<p>Along with changes to follow the R-spatial evolution, <code>group_polys</code> also
now returns area and proportion of overlap with units explicitly specified
through the <code>units</code> package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_polys">build_polys()</a></code> <code><a href="#topic+group_times">group_times()</a></code>
</p>
<p>Other Spatial grouping: 
<code><a href="#topic+group_lines">group_lines</a>()</code>,
<code><a href="#topic+group_pts">group_pts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data.table
library(data.table)


# Read example data
DT &lt;- fread(system.file("extdata", "DT.csv", package = "spatsoc"))

# Cast the character column to POSIXct
DT[, datetime := as.POSIXct(datetime, tz = 'UTC')]

# EPSG code for example data
utm &lt;- 32736

group_polys(DT, area = FALSE, hrType = 'mcp',
            hrParams = list(percent = 95), projection = utm,
            id = 'ID', coords = c('X', 'Y'))

areaDT &lt;- group_polys(DT, area = TRUE, hrType = 'mcp',
                      hrParams = list(percent = 95), projection = utm,
                      id = 'ID', coords = c('X', 'Y'))
print(areaDT)
</code></pre>

<hr>
<h2 id='group_pts'>Group Points</h2><span id='topic+group_pts'></span>

<h3>Description</h3>

<p><code>group_pts</code> groups rows into spatial groups. The function accepts a
<code>data.table</code> with relocation data, individual identifiers and a
threshold argument. The threshold argument is used to specify the criteria
for distance between points which defines a group. Relocation data should be
in two columns representing the X and Y coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_pts(
  DT = NULL,
  threshold = NULL,
  id = NULL,
  coords = NULL,
  timegroup,
  splitBy = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_pts_+3A_dt">DT</code></td>
<td>
<p>input data.table</p>
</td></tr>
<tr><td><code id="group_pts_+3A_threshold">threshold</code></td>
<td>
<p>distance for grouping points, in the units of the
coordinates</p>
</td></tr>
<tr><td><code id="group_pts_+3A_id">id</code></td>
<td>
<p>Character string of ID column name</p>
</td></tr>
<tr><td><code id="group_pts_+3A_coords">coords</code></td>
<td>
<p>Character vector of X coordinate and Y coordinate column names</p>
</td></tr>
<tr><td><code id="group_pts_+3A_timegroup">timegroup</code></td>
<td>
<p>timegroup field in the DT within which the grouping will be
calculated</p>
</td></tr>
<tr><td><code id="group_pts_+3A_splitby">splitBy</code></td>
<td>
<p>(optional) character string or vector of grouping column
name(s) upon which the grouping will be calculated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>DT</code> must be a <code>data.table</code>. If your data is a
<code>data.frame</code>, you can convert it by reference using
<code><a href="data.table.html#topic+setDT">data.table::setDT</a></code>.
</p>
<p>The <code>id</code>, <code>coords</code>, <code>timegroup</code> (and optional <code>splitBy</code>)
arguments expect the names of a column in <code>DT</code> which correspond to the
individual identifier, X and Y coordinates, timegroup (typically generated by
<code>group_times</code>) and additional grouping columns.
</p>
<p>The <code>threshold</code> must be provided in the units of the coordinates. The
<code>threshold</code> must be larger than 0. The coordinates must be planar
coordinates (e.g.: UTM). In the case of UTM, a <code>threshold</code> = 50 would
indicate a 50m distance threshold.
</p>
<p>The <code>timegroup</code> argument is required to define the temporal groups
within which spatial groups are calculated. The intended framework is to
group rows temporally with <code><a href="#topic+group_times">group_times</a></code> then spatially with
<code>group_pts</code> (or <code><a href="#topic+group_lines">group_lines</a></code>, <code><a href="#topic+group_polys">group_polys</a></code>).
If you have already calculated temporal groups without
<code><a href="#topic+group_times">group_times</a></code>, you can pass this column to the <code>timegroup</code>
argument. Note that the expectation is that each individual will be observed
only once per timegroup. Caution that accidentally including huge numbers of
rows within timegroups can overload your machine since all pairwise distances
are calculated within each timegroup.
</p>
<p>The <code>splitBy</code> argument offers further control over grouping. If within
your <code>DT</code>, you have multiple populations, subgroups or other distinct
parts, you can provide the name of the column which identifies them to
<code>splitBy</code>. The grouping performed by <code>group_pts</code> will only consider
rows within each <code>splitBy</code> subgroup.
</p>


<h3>Value</h3>

<p><code>group_pts</code> returns the input <code>DT</code> appended with a
<code>group</code> column.
</p>
<p>This column represents the spatialtemporal group. As with the other
grouping functions,  the actual value of <code>group</code> is arbitrary and
represents the identity of a given group where 1 or more individuals are
assigned to a group. If the data was reordered, the <code>group</code> may
change, but the contents of each group would not.
</p>
<p>A message is returned when a column named <code>group</code> already exists in
the input <code>DT</code>, because it will be overwritten.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+group_times">group_times</a></code>
</p>
<p>Other Spatial grouping: 
<code><a href="#topic+group_lines">group_lines</a>()</code>,
<code><a href="#topic+group_polys">group_polys</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data.table
library(data.table)


# Read example data
DT &lt;- fread(system.file("extdata", "DT.csv", package = "spatsoc"))

# Select only individuals A, B, C for this example
DT &lt;- DT[ID %in% c('A', 'B', 'C')]

# Cast the character column to POSIXct
DT[, datetime := as.POSIXct(datetime, tz = 'UTC')]

# Temporal grouping
group_times(DT, datetime = 'datetime', threshold = '20 minutes')

# Spatial grouping with timegroup
group_pts(DT, threshold = 5, id = 'ID',
          coords = c('X', 'Y'), timegroup = 'timegroup')

# Spatial grouping with timegroup and splitBy on population
group_pts(DT, threshold = 5, id = 'ID', coords = c('X', 'Y'),
         timegroup = 'timegroup', splitBy = 'population')
</code></pre>

<hr>
<h2 id='group_times'>Group Times</h2><span id='topic+group_times'></span>

<h3>Description</h3>

<p><code>group_times</code> groups rows into time groups. The function accepts date
time formatted data and a threshold argument. The threshold argument is used
to specify a time window within which rows are grouped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_times(DT = NULL, datetime = NULL, threshold = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_times_+3A_dt">DT</code></td>
<td>
<p>input data.table</p>
</td></tr>
<tr><td><code id="group_times_+3A_datetime">datetime</code></td>
<td>
<p>name of date time column(s). either 1 POSIXct or 2 IDate and
ITime. e.g.: 'datetime' or c('idate', 'itime')</p>
</td></tr>
<tr><td><code id="group_times_+3A_threshold">threshold</code></td>
<td>
<p>threshold for grouping times. e.g.: '2 hours', '10 minutes',
etc. if not provided, times will be matched exactly. Note that provided
threshold must be in the expected format: '## unit'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>DT</code> must be a <code>data.table</code>. If your data is a
<code>data.frame</code>, you can convert it by reference using
<code><a href="data.table.html#topic+setDT">data.table::setDT</a></code>.
</p>
<p>The <code>datetime</code> argument expects the name of a column in <code>DT</code> which
is of type <code>POSIXct</code> or the name of two columns in <code>DT</code> which are
of type <code>IDate</code> and <code>ITime</code>.
</p>
<p><code>threshold</code> must be provided in units of minutes, hours or days. The
character string should start with an integer followed by a unit, separated
by a space. It is interpreted in terms of 24 hours which poses the following
limitations:
</p>
 <ul>
<li><p> minutes, hours and days cannot be fractional </p>
</li>
<li><p> minutes
must divide evenly into 60 </p>
</li>
<li><p> minutes must not exceed 60 </p>
</li>
<li><p> minutes,
hours which are nearer to the next day, are grouped as such </p>
</li>
<li><p> hours must
divide evenly into 24 </p>
</li>
<li><p> multi-day blocks should divide into the range of
days, else the blocks may not be the same length </p>
</li></ul>

<p>In addition, the <code>threshold</code> is considered a fixed window throughout the
time series and the rows are grouped to the nearest interval.
</p>
<p>If <code>threshold</code> is NULL, rows are grouped using the <code>datetime</code>
column directly.
</p>


<h3>Value</h3>

<p><code>group_times</code> returns the input <code>DT</code> appended with a
<code>timegroup</code> column and additional temporal grouping columns to help
investigate, troubleshoot and interpret the timegroup.
</p>
<p>The actual value of <code>timegroup</code> is arbitrary and represents the
identity of a given <code>timegroup</code> which 1 or more individuals are
assigned to. If the data was reordered, the group may change, but the
contents of each group would not.
</p>
<p>The temporal grouping columns added depend on the <code>threshold</code>
provided:
</p>
 <ul>
<li> <p><code>threshold</code> with unit minutes: &quot;minutes&quot; column added
identifying the nearest minute group for each row. </p>
</li>
<li> <p><code>threshold</code>
with unit hours: &quot;hours&quot; column added identifying the nearest hour group
for each row. </p>
</li>
<li> <p><code>threshold</code> with unit days: &quot;block&quot; columns added
identifying the multiday block for each row. </p>
</li></ul>

<p>A message is returned when any of these columns already exist in the input
<code>DT</code>, because they will be overwritten.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+group_pts">group_pts</a></code> <code><a href="#topic+group_lines">group_lines</a></code>
<code><a href="#topic+group_polys">group_polys</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data.table
library(data.table)


# Read example data
DT &lt;- fread(system.file("extdata", "DT.csv", package = "spatsoc"))

# Cast the character column to POSIXct
DT[, datetime := as.POSIXct(datetime, tz = 'UTC')]

group_times(DT, datetime = 'datetime', threshold = '5 minutes')

group_times(DT, datetime = 'datetime', threshold = '2 hours')

group_times(DT, datetime = 'datetime', threshold = '10 days')

</code></pre>

<hr>
<h2 id='randomizations'>Data-stream randomizations</h2><span id='topic+randomizations'></span>

<h3>Description</h3>

<p><code>randomizations</code> performs data-stream social network randomization. The
function accepts a <code>data.table</code> with relocation data, individual
identifiers and a randomization <code>type</code>. The <code>data.table</code> is
randomized either using <code>step</code> or <code>daily</code> between-individual
methods, or within-individual daily <code>trajectory</code> method described by
Spiegel et al. (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomizations(
  DT = NULL,
  type = NULL,
  id = NULL,
  group = NULL,
  coords = NULL,
  datetime = NULL,
  splitBy = NULL,
  iterations = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randomizations_+3A_dt">DT</code></td>
<td>
<p>input data.table</p>
</td></tr>
<tr><td><code id="randomizations_+3A_type">type</code></td>
<td>
<p>one of 'daily', 'step' or 'trajectory' - see details</p>
</td></tr>
<tr><td><code id="randomizations_+3A_id">id</code></td>
<td>
<p>Character string of ID column name</p>
</td></tr>
<tr><td><code id="randomizations_+3A_group">group</code></td>
<td>
<p>generated from spatial grouping functions - see details</p>
</td></tr>
<tr><td><code id="randomizations_+3A_coords">coords</code></td>
<td>
<p>Character vector of X coordinate and Y coordinate column names</p>
</td></tr>
<tr><td><code id="randomizations_+3A_datetime">datetime</code></td>
<td>
<p>field used for providing date time or time group - see
details</p>
</td></tr>
<tr><td><code id="randomizations_+3A_splitby">splitBy</code></td>
<td>
<p>List of fields in DT to split the randomization process by</p>
</td></tr>
<tr><td><code id="randomizations_+3A_iterations">iterations</code></td>
<td>
<p>The number of iterations to randomize</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>DT</code> must be a <code>data.table</code>. If your data is a
<code>data.frame</code>, you can convert it by reference using
<code><a href="data.table.html#topic+setDT">data.table::setDT</a></code>.
</p>
<p>Three randomization <code>type</code>s are provided: </p>
 <ol>
<li><p> step -
randomizes identities of relocations between individuals within each time
step. </p>
</li>
<li><p> daily - randomizes identities of relocations between individuals
within each day. </p>
</li>
<li><p> trajectory - randomizes daily trajectories within
individuals (Spiegel et al. 2016). </p>
</li></ol>

<p>Depending on the <code>type</code>, the <code>datetime</code> must be a certain format:
</p>
 <ul>
<li><p> step - datetime is integer group created by
<code>group_times</code> </p>
</li>
<li><p> daily - datetime is <code>POSIXct</code> format </p>
</li>
<li>
<p>trajectory - datetime is <code>POSIXct</code> format </p>
</li></ul>

<p>The <code>id</code>, <code>datetime</code>,  (and optional <code>splitBy</code>) arguments
expect the names of respective columns in <code>DT</code> which correspond to the
individual identifier, date time, and additional grouping columns. The
<code>coords</code> argument is only required when the <code>type</code> is &quot;trajectory&quot;,
since the coordinates are required for recalculating spatial groups with
<code>group_pts</code>, <code>group_lines</code> or <code>group_polys</code>.
</p>
<p>Please note that if the data extends over multiple years, a column indicating
the year should be provided to the <code>splitBy</code> argument. This will ensure
randomizations only occur within each year.
</p>
<p>The <code>group</code> argument is expected only when <code>type</code> is 'step' or
'daily'.
</p>
<p>For example, using <code><a href="data.table.html#topic+IDateTime">data.table::year</a></code>:
</p>
<pre> DT[, yr := year(datetime)] randomizations(DT, type = 'step',
id = 'ID', datetime = 'timegroup', splitBy = 'yr') </pre>
<p><code>iterations</code> is set to 1 if not provided. Take caution with a large
value for <code>iterations</code> with large input <code>DT</code>.
</p>


<h3>Value</h3>

<p><code>randomizations</code> returns the random date time or random id along
with the original <code>DT</code>, depending on the randomization <code>type</code>.
The length of the returned <code>data.table</code> is the original number of rows
multiplied by the number of iterations + 1. For example, 3 iterations will
return 4x - one observed and three randomized.
</p>
<p>Two columns are always returned: </p>
 <ul>
<li><p> observed - if the rows
represent the observed (TRUE/FALSE) </p>
</li>
<li><p> iteration - iteration of rows
(where 0 is the observed) </p>
</li></ul>

<p>In addition, depending on the randomization type, random ID or random date
time columns are returned:
</p>
 <ul>
<li><p> step - <code>randomID</code> each time step </p>
</li>
<li><p> daily -
<code>randomID</code> for each day and <code>jul</code> indicating julian day </p>
</li>
<li>
<p>trajectory - a random date time (&quot;random&quot; prefixed to <code>datetime</code>
argument), observed <code>jul</code> and <code>randomJul</code> indicating the random
day relocations are swapped to. </p>
</li></ul>



<h3>References</h3>

<p><a href="doi:10.1111/2041-210X.12553">doi:10.1111/2041-210X.12553</a>
</p>


<h3>See Also</h3>

<p>Other Social network tools: 
<code><a href="#topic+get_gbi">get_gbi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data.table
library(data.table)


# Read example data
DT &lt;- fread(system.file("extdata", "DT.csv", package = "spatsoc"))

# Select only individuals A, B, C for this example
DT &lt;- DT[ID %in% c('A', 'B', 'C')]

# Date time columns
DT[, datetime := as.POSIXct(datetime)]
DT[, yr := year(datetime)]

# Temporal grouping
group_times(DT, datetime = 'datetime', threshold = '5 minutes')

# Spatial grouping with timegroup
group_pts(DT, threshold = 5, id = 'ID', coords = c('X', 'Y'), timegroup = 'timegroup')

# Randomization: step
randStep &lt;- randomizations(
    DT,
    type = 'step',
    id = 'ID',
    group = 'group',
    datetime = 'timegroup',
    splitBy = 'yr',
    iterations = 2
)

# Randomization: daily
randDaily &lt;- randomizations(
    DT,
    type = 'daily',
    id = 'ID',
    group = 'group',
    datetime = 'datetime',
    splitBy = 'yr',
    iterations = 2
)

# Randomization: trajectory
randTraj &lt;- randomizations(
    DT,
    type = 'trajectory',
    id = 'ID',
    group = NULL,
    coords = c('X', 'Y'),
    datetime = 'datetime',
    splitBy = 'yr',
    iterations = 2
)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
