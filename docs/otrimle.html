<!DOCTYPE html><html><head><title>Help for package otrimle</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {otrimle}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#banknote'><p>Swiss Banknotes Data</p></a></li>
<li><a href='#generator.otrimle'><p>Generates random data from OTRIMLE output model</p></a></li>
<li><a href='#InitClust'><p>Robust Initialization for Model-based Clustering Methods</p></a></li>
<li><a href='#kerndenscluster'><p>Aggregated distance to elliptical unimodal density over clusters</p></a></li>
<li><a href='#kerndensmeasure'><p>Statistic measuring closeness to symmetric unimodal distribution</p></a></li>
<li><a href='#kerndensp'><p>Closeness of multivariate distribution to elliptical unimodal distribution</p></a></li>
<li><a href='#kmeanfun'><p>Mean and standard deviation of unimodality statistic</p></a></li>
<li><a href='#otrimle'><p>Optimally Tuned Robust Improper Maximum Likelihood Clustering</p></a></li>
<li><a href='#otrimleg'><p>OTRIMLE for a range of numbers of clusters with density-based cluster quality statistic</p></a></li>
<li><a href='#otrimlesimg'><p>Adequacy approach for number of clusters for OTRIMLE</p></a></li>
<li><a href='#plot.otrimle'>
<p>Plot Methods for OTRIMLE Objects</p></a></li>
<li><a href='#plot.rimle'>
<p>Plot Methods for RIMLE Objects</p></a></li>
<li><a href='#rimle'><p>Robust Improper Maximum Likelihood Clustering</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Robust Model-Based Clustering</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs robust cluster analysis allowing for outliers and noise that cannot be fitted by any cluster. The data are modelled by a mixture of Gaussian distributions and a noise component, which is an improper uniform  distribution covering the whole Euclidean space. Parameters are estimated by  (pseudo) maximum likelihood. This is fitted by a EM-type algorithm. See Coretto and Hennig (2016) &lt;<a href="https://doi.org/10.1080%2F01621459.2015.1100996">doi:10.1080/01621459.2015.1100996</a>&gt;, and Coretto and Hennig (2017) <a href="https://jmlr.org/papers/v18/16-382.html">https://jmlr.org/papers/v18/16-382.html</a>.</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-05-28</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, graphics, grDevices, mvtnorm, parallel, foreach,
doParallel, robustbase, mclust</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-28 19:45:53 UTC; pietro</td>
</tr>
<tr>
<td>Author:</td>
<td>Pietro Coretto [aut, cre] (Homepage:
    &lt;https://pietro-coretto.github.io&gt;),
  Christian Hennig [aut] (Homepage:
    &lt;https://www.unibo.it/sitoweb/christian.hennig/en&gt;)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pietro Coretto &lt;pcoretto@unisa.it&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-29 06:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='banknote'>Swiss Banknotes Data</h2><span id='topic+banknote'></span>

<h3>Description</h3>

<p>Data from Tables 1.1 and 1.2 (pp. 5-8) of Flury  and Riedwyl
(1988). There are  six measurements made on 200 Swiss
banknotes  (the old-Swiss 1000-franc). The banknotes belong to two
classes of equal size:  <em>genuine</em> and <em>counterfeit</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(banknote)</code></pre>


<h3>Format</h3>

<p>A  <code>data.frame</code> of dimension <code>200x7</code> with the following variables:
</p>

<dl>
<dt>Class</dt><dd><p>a <code>factor</code> with classes: <code>genuine</code>, <code>counterfeit</code></p>
</dd>
<dt>Length</dt><dd><p>Length of bill (mm)</p>
</dd>
<dt>Left</dt><dd><p>Width of left edge (mm)</p>
</dd>
<dt>Right</dt><dd><p>Width of right edge (mm)</p>
</dd>
<dt>Bottom</dt><dd><p>Bottom margin width (mm)</p>
</dd>
<dt>Top</dt><dd><p>Top margin width (mm)</p>
</dd>
<dt>Diagonal</dt><dd><p>Length of diagonal (mm)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Flury, B. and Riedwyl, H. (1988).
<em>Multivariate Statistics: A practical approach.</em>
London: Chapman &amp; Hall.
</p>

<hr>
<h2 id='generator.otrimle'>Generates random data from OTRIMLE output model</h2><span id='topic+generator.otrimle'></span>

<h3>Description</h3>

<p>This uses data and the output of <code><a href="#topic+otrimle">otrimle</a></code> or
<code><a href="#topic+rimle">rimle</a></code> to generate a new artificial dataset of the size
of the original data using noise and cluster proportions from the
clustering output. The clusters are then generated from multivariate
normal distributions with the parameters estimated by
<code><a href="#topic+otrimle">otrimle</a></code>, the noise is generated resampling from what is
estimated as moise component with weights given by posterior
probabilities of all observations to be noise. See Hennig and Coretto
(2021).   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  generator.otrimle(data, fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generator.otrimle_+3A_data">data</code></td>
<td>
<p>something that can be coerced into a matrix. Dataset.</p>
</td></tr>
<tr><td><code id="generator.otrimle_+3A_fit">fit</code></td>
<td>
<p>output object of <code><a href="#topic+otrimle">otrimle</a></code> or <code><a href="#topic+rimle">rimle</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components <code>data, clustering</code>.
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>matrix of generated data.</p>
</td></tr>
<tr><td><code>cs</code></td>
<td>
<p>vector of integers. Clustering indicator.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en/">https://www.unibo.it/sitoweb/christian.hennig/en/</a>
</p>


<h3>References</h3>

<p>Hennig, C. and P.Coretto (2021). An adequacy approach for deciding the
number of clusters for OTRIMLE robust Gaussian mixture based
clustering. To appear in <em>Australian and New Zealand Journal of
Statistics</em>, <a href="https://arxiv.org/abs/2009.00921">https://arxiv.org/abs/2009.00921</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kerndensp">kerndensp</a></code>, <code><a href="#topic+kerndensmeasure">kerndensmeasure</a></code>,
<code><a href="#topic+otrimle">otrimle</a></code>,  <code><a href="#topic+rimle">rimle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data(banknote)
   selectdata &lt;- c(1:30,101:110,117:136,160:161)
   set.seed(555566)
   x &lt;- banknote[selectdata,5:7]
   ox &lt;- otrimle(x, G=2 , ncores = 1)
   str(generator.otrimle(x, ox))
</code></pre>

<hr>
<h2 id='InitClust'>Robust Initialization for Model-based Clustering Methods</h2><span id='topic+InitClust'></span>

<h3>Description</h3>

<p>Computes the initial cluster assignment based on a combination of
nearest neighbor based noise detection, and agglomerative hierarchical
clustering based on maximum likelihood criteria for Gaussian
mixture models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> InitClust(data , G , k = 3 , knnd.trim = 0.5 , modelName='VVV')
 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InitClust_+3A_data">data</code></td>
<td>

<p>A numeric vector, matrix, or data frame of observations. Rows correspond
to observations and columns correspond to variables. Categorical
variables and <code>NA</code> values are not allowed.
</p>
</td></tr>
<tr><td><code id="InitClust_+3A_g">G</code></td>
<td>

<p>An integer specifying the number of clusters.
</p>
</td></tr>
<tr><td><code id="InitClust_+3A_k">k</code></td>
<td>

<p>An integer specifying the number of considered nearest neighbors per point
used for the denoising step (see <em>Details</em>).
</p>
</td></tr>
<tr><td><code id="InitClust_+3A_knnd.trim">knnd.trim</code></td>
<td>

<p>A number in [0,1) which defines the proportion of points
initialized as noise. Tipically <code>knnd.trim&lt;=0.5</code> (see <em>Details</em>).
</p>
</td></tr>
<tr><td><code id="InitClust_+3A_modelname">modelName</code></td>
<td>

<p>A character string indicating the covariance model to be used. Possible models are: <br />
<code>"E"</code>:   equal variance  (one-dimensional) <br />
<code>"V"</code> :  spherical, variable variance (one-dimensional) <br />
<code>"EII"</code>: spherical, equal volume <br />
<code>"VII"</code>: spherical, unequal volume <br />
<code>"EEE"</code>: ellipsoidal, equal volume, shape, and orientation <br />
<code>"VVV"</code>: ellipsoidal, varying volume, shape, and orientation (default).<br />
See <em>Details</em>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initialization is based on Coretto and Hennig (2017). First, wwo
steps are performed:<br />
</p>
<p><em>Step 1 (denoising step):</em> for each data point compute its
<code>k</code>th<code>-</code>nearest neighbors
distance (<code>k-</code>NND). All points with <code>k-</code>NND  larger
than the (1-<code>knnd.trim</code>)<code>-</code>quantile  of the <code>k-</code>NND
are initialized as noise. Intepretaion of
<code>k</code> is that:  <code>(k-1)</code>, but not <code>k</code>, points close
together may still be interpreted  as noise or outliers
</p>
<p><em>Step 2 (clustering step):</em> perform the model-based hierarchical
clustering (MBHC) proposed in Fraley (1998). This step is performed using
<code><a href="mclust.html#topic+hc">hc</a></code>. The input argument <code>modelName</code> is passed
to <code><a href="mclust.html#topic+hc">hc</a></code>. See <em>Details</em> of
<code><a href="mclust.html#topic+hc">hc</a></code> for more details.
</p>
<p>If the previous <em>Step 2</em> fails to provide <code>G</code> clusters each
containing at least 2 distinct data points, it is replaced with
classical hirararchical clustering implemented in
<code><a href="stats.html#topic+hclust">hclust</a></code>. Finally, if
<code><a href="stats.html#topic+hclust">hclust</a></code> fails to provide a valid partition, up
to ten random partitions are tried.
</p>


<h3>Value</h3>

<p>An integer vector specifying the initial cluster
assignment  with <code>0</code> denoting noise/outliers.
</p>


<h3>References</h3>

<p>Fraley, C.  (1998).
Algorithms for model-based Gaussian hierarchical clustering.
<em>SIAM Journal on Scientific Computing</em> 20:270-281.
</p>
<p>P. Coretto and C. Hennig (2017).
Consistency, breakdown robustness, and algorithms for robust improper
maximum  likelihood clustering.
<em>Journal of Machine Learning Research</em>, Vol. 18(142), pp. 1-39.
<a href="https://jmlr.org/papers/v18/16-382.html">https://jmlr.org/papers/v18/16-382.html</a>
</p>


<h3>Author(s)</h3>

<p>Pietro Coretto
<a href="mailto:pcoretto@unisa.it">pcoretto@unisa.it</a>
<a href="https://pietro-coretto.github.io">https://pietro-coretto.github.io</a>
</p>


<h3>See Also</h3>

<p><a href="mclust.html#topic+hc">hc</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Load  Swiss banknotes data
 data(banknote)
 x &lt;- banknote[,-1]

 ## Initial clusters with default arguments
 init &lt;- InitClust(data = x, G = 2)
 print(init)

 ## Perform otrimle
 a &lt;- otrimle(data = x, G = 2, initial = init,
              logicd = c(-Inf, -50, -10), ncores = 1)
 plot(a, what="clustering", data=x)
 </code></pre>

<hr>
<h2 id='kerndenscluster'>Aggregated distance to elliptical unimodal density over clusters</h2><span id='topic+kerndenscluster'></span>

<h3>Description</h3>

<p>This calls <code><a href="#topic+kerndensp">kerndensp</a></code> for computing and aggregating
density- and
principal components-based distances between
multivariate data and a unimodal
elliptical distribution about the data mean for all clusters in a
mixture-based clustering as generated by <code><a href="#topic+otrimle">otrimle</a></code> or
<code><a href="#topic+rimle">rimle</a></code>. For use in <code><a href="#topic+otrimleg">otrimleg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kerndenscluster(x,fit,maxq=qnorm(0.9995),kernn=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kerndenscluster_+3A_x">x</code></td>
<td>
<p>something that can be coerced into a matrix. Dataset.</p>
</td></tr>
<tr><td><code id="kerndenscluster_+3A_fit">fit</code></td>
<td>
<p>output object of <code><a href="#topic+otrimle">otrimle</a></code> or <code><a href="#topic+rimle">rimle</a></code>.</p>
</td></tr>
<tr><td><code id="kerndenscluster_+3A_maxq">maxq</code></td>
<td>
<p>positive numeric. One-dimensional densities are evaluated
between <code>mean(x)-maxq</code> and <code>mean(x)+maxq</code>.</p>
</td></tr>
<tr><td><code id="kerndenscluster_+3A_kernn">kernn</code></td>
<td>
<p>integer. Number of points at which the one-dimensional
density is evaluated, input parameter <code>n</code> of
<code><a href="stats.html#topic+density">density</a></code>. This should be even.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Hennig and Coretto (2021), Sec. 4.2. <code>kerndenscluster</code> calls
<code><a href="#topic+kerndensp">kerndensp</a></code> for all clusters and aggregates the resulting
measures as root sum of squares. 
</p>


<h3>Value</h3>

<p>A list with components <code>ddpi, ddpm, measure</code>.
</p>
<table>
<tr><td><code>ddpi</code></td>
<td>
<p>list of outputs of <code><a href="#topic+kerndensp">kerndensp</a></code> for all
clusters.</p>
</td></tr>
<tr><td><code>ddpm</code></td>
<td>
<p>vector of <code>measure</code>-components of <code>ddpi</code>.</p>
</td></tr>
<tr><td><code>measure</code></td>
<td>
<p>Final aggregation result.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en/">https://www.unibo.it/sitoweb/christian.hennig/en/</a>
</p>


<h3>References</h3>

<p>Hennig, C. and P.Coretto (2021). An adequacy approach for deciding the
number of clusters for OTRIMLE robust Gaussian mixture based
clustering. To appear in <em>Australian and New Zealand Journal of
Statistics</em>, <a href="https://arxiv.org/abs/2009.00921">https://arxiv.org/abs/2009.00921</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kerndensp">kerndensp</a></code>, <code><a href="#topic+kerndensmeasure">kerndensmeasure</a></code>,
<code><a href="#topic+otrimle">otrimle</a></code>,  <code><a href="#topic+rimle">rimle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data(banknote)
   selectdata &lt;- c(1:30,101:110,117:136,160:161)
   set.seed(555566)
   x &lt;- banknote[selectdata,5:7]
   ox &lt;- otrimle(x, G=2, ncores=1)
   kerndenscluster(x,ox)$measure
</code></pre>

<hr>
<h2 id='kerndensmeasure'>Statistic measuring closeness to symmetric unimodal distribution</h2><span id='topic+kerndensmeasure'></span>

<h3>Description</h3>

<p>Density-based distance between one-dimensional data and a unimodal
symmetric distribution about the data mean based on Pons (2013, p.79),
adapted by Hennig and Coretto (2021), see details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kerndensmeasure(x,weights=rep(1,nrow(as.matrix(x))),maxq=qnorm(0.9995),
                  kernn=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kerndensmeasure_+3A_x">x</code></td>
<td>
<p>vector. One-dimensional dataset.</p>
</td></tr> 
<tr><td><code id="kerndensmeasure_+3A_weights">weights</code></td>
<td>
<p>non-negative vector. Relative weights of observations
(will be standardised to sup up to one internally).</p>
</td></tr>
<tr><td><code id="kerndensmeasure_+3A_maxq">maxq</code></td>
<td>
<p>densities are evaluated between <code>mean(x)-maxq</code> and
<code>mean(x)+maxq</code>.</p>
</td></tr>
<tr><td><code id="kerndensmeasure_+3A_kernn">kernn</code></td>
<td>
<p>integer. Number of points at which the density is
evaluated, input parameter <code>n</code> of <code><a href="stats.html#topic+density">density</a></code>. This
should be even.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code><a href="stats.html#topic+density">density</a></code> is used in order to compute a kernel
density estimator from the data. The <code style="white-space: pre;">&#8288;kernn&#8288;</code> values of the
density are then ordered from the pargest to the smallest. Beginning
from the largest to the smallest, pairs of two values are formed
(largest and largest biggest, third and fourth largest, and so
on). Each pair is replaced by two copies of the average of the two
values. Then on each side of the mean one of each copy is placed from
the biggest to the smallest, and this produces a symmetric density
about the mean. The the root mean squared difference between this and
the original density is computed.
</p>


<h3>Value</h3>

<p>A list with components <code>cp, cpx, measure</code>.
</p>
<table>
<tr><td><code>cp</code></td>
<td>
<p>vector of generated symmetric density values from largest to
smallest (just one copy, sp <code>kernn/2</code> values).</p>
</td></tr>
<tr><td><code>cpx</code></td>
<td>
<p><code>y</code>-component of <code><a href="stats.html#topic+density">density</a></code>-output.</p>
</td></tr>
<tr><td><code>measure</code></td>
<td>
<p>root mean squared difference between the densities.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en/">https://www.unibo.it/sitoweb/christian.hennig/en/</a></p>


<h3>References</h3>

<p>Hennig, C. and P.Coretto (2021). An adequacy approach for deciding the
number of clusters for OTRIMLE robust Gaussian mixture based
clustering. To appear in <em>Australian and New Zealand Journal of
Statistics</em>, <a href="https://arxiv.org/abs/2009.00921">https://arxiv.org/abs/2009.00921</a>.
</p>
<p>Pons, O. (2013). <em>Statistical Tests of Nonparametric Hypotheses:
Asymptotic Theory</em>. World Scientific, Singapore.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kerndensp">kerndensp</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(124578)
  x &lt;- runif(20)
  str(kerndensmeasure(x))
</code></pre>

<hr>
<h2 id='kerndensp'>Closeness of multivariate distribution to elliptical unimodal distribution</h2><span id='topic+kerndensp'></span>

<h3>Description</h3>

<p>Density- and and principal components-based distance between
multivariate data and a unimodal
elliptical distribution about the data mean, see Hennig and Coretto
(2021). For use in <code><a href="#topic+kerndenscluster">kerndenscluster</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kerndensp(x,weights=rep(1,nrow(as.matrix(x))), siglist,maxq=qnorm(0.9995),
            kernn=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kerndensp_+3A_x">x</code></td>
<td>
<p>something that can be coerced into a matrix. Dataset.</p>
</td></tr> 
<tr><td><code id="kerndensp_+3A_weights">weights</code></td>
<td>
<p>non-negative vector. Relative weights of observations
(will be standardised to sup up to one internally).</p>
</td></tr>
<tr><td><code id="kerndensp_+3A_siglist">siglist</code></td>
<td>
<p>list with components <code>cov</code> (covariance matrix),
<code>center</code> (mean) and <code>n.obs</code> (number of observations).</p>
</td></tr>
<tr><td><code id="kerndensp_+3A_maxq">maxq</code></td>
<td>
<p>positive numeric. One-dimensional densities are evaluated
between <code>mean(x)-maxq</code> and <code>mean(x)+maxq</code>.</p>
</td></tr>
<tr><td><code id="kerndensp_+3A_kernn">kernn</code></td>
<td>
<p>integer. Number of points at which the one-dimensional
density is evaluated, input parameter <code>n</code> of
<code><a href="stats.html#topic+density">density</a></code>. This should be even.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Hennig and Coretto (2021), Sec. 4.2. <code><a href="#topic+kerndensmeasure">kerndensmeasure</a></code>
is run on the principal components of <code>x</code>. The resulting measures
are standardised by <code><a href="#topic+kmeanfun">kmeanfun</a></code> and <code><a href="#topic+ksdfun">ksdfun</a></code>
and then aggregated as mean square of the positive values, see
Hennig and Coretto (2021). The PCS is computed by
<code><a href="stats.html#topic+princomp">princomp</a></code> and will always use <code>siglist</code> rather than
statistics computed from <code>x</code>. 
</p>


<h3>Value</h3>

<p>A list with components <code>cml, cm, pca, stanmeasure, measure</code>.
</p>
<table>
<tr><td><code>cml</code></td>
<td>
<p>List of outputs of <code><a href="#topic+kerndensmeasure">kerndensmeasure</a></code> for the
principal components.</p>
</td></tr>
<tr><td><code>cm</code></td>
<td>
<p>vector of <code>measure</code> components of
<code><a href="#topic+kerndensmeasure">kerndensmeasure</a></code> for the principal components.</p>
</td></tr>
<tr><td><code>stanmeasure</code></td>
<td>
<p>vector of standardised <code>measure</code> components of
<code><a href="#topic+kerndensmeasure">kerndensmeasure</a></code> for the principal components.</p>
</td></tr>
<tr><td><code>pca</code></td>
<td>
<p>output of <code><a href="stats.html#topic+princomp">princomp</a></code>.</p>
</td></tr> 
<tr><td><code>measure</code></td>
<td>
<p>Final aggregation result.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en/">https://www.unibo.it/sitoweb/christian.hennig/en/</a>
</p>


<h3>References</h3>

<p>Hennig, C. and P.Coretto (2021). An adequacy approach for deciding the
number of clusters for OTRIMLE robust Gaussian mixture based
clustering. To appear in <em>Australian and New Zealand Journal of
Statistics</em>, <a href="https://arxiv.org/abs/2009.00921">https://arxiv.org/abs/2009.00921</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kerndensmeasure">kerndensmeasure</a></code>,  <code><a href="#topic+kerndenscluster">kerndenscluster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(124578)
  x &lt;- cbind(runif(20),runif(20))
  siglist &lt;- list(cov=cov(x),center=colMeans(x),n.obs=20) 
  kerndensp(x,siglist=siglist)$measure
</code></pre>

<hr>
<h2 id='kmeanfun'>Mean and standard deviation of unimodality statistic</h2><span id='topic+kmeanfun'></span><span id='topic+ksdfun'></span>

<h3>Description</h3>

<p>These functions approximate the mean and standard deviation of the
unimodality statistic computed by <code><a href="#topic+kerndensmeasure">kerndensmeasure</a></code>
assuming standard Gaussian data dependent on the number of
observations<code>n</code>. They have been chosen based on a simulation involving 74
different values of <code>n</code>. Used for standardisation in
<code><a href="#topic+kerndensp">kerndensp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kmeanfun(n)
  ksdfun(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmeanfun_+3A_n">n</code></td>
<td>
<p>integer. Number of observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The resulting mean (<code>kmeanfun</code>) or standard deviation
(<code>ksdfun</code>).
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en/">https://www.unibo.it/sitoweb/christian.hennig/en/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kerndensp">kerndensp</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   kmeanfun(50)
   ksdfun(50)
</code></pre>

<hr>
<h2 id='otrimle'>Optimally Tuned Robust Improper Maximum Likelihood Clustering</h2><span id='topic+otrimle'></span><span id='topic+print.otrimle'></span>

<h3>Description</h3>

<p><code>otrimle</code> searches for <code>G</code> approximately Gaussian-shaped
clusters with/without noise/outliers. The method's tuning controlling  the noise
level is adaptively chosen based on the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>otrimle(data, G, initial = NULL, logicd = NULL, npr.max = 0.5, erc = 20,
beta = 0, iter.max = 500, tol = 1e-06, ncores = NULL, monitor = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="otrimle_+3A_data">data</code></td>
<td>

<p>A numeric vector, matrix, or data frame of observations. Rows correspond
to observations and columns correspond to variables. Categorical
variables and <code>NA</code> values are not allowed.
</p>
</td></tr>
<tr><td><code id="otrimle_+3A_g">G</code></td>
<td>

<p>An integer specifying the number of clusters.
</p>
</td></tr>
<tr><td><code id="otrimle_+3A_initial">initial</code></td>
<td>
<p>An integer vector specifying the initial cluster
assignment  with <code>0</code> denoting noise/outliers. If <code>NULL</code> (default)
initialization is performed using <code><a href="#topic+InitClust">InitClust</a></code>.
</p>
</td></tr>
<tr><td><code id="otrimle_+3A_logicd">logicd</code></td>
<td>

<p>A vector defining a grid of <em>log(icd)</em> values, where <em>icd</em>
denotes the  improper constant density. If <code>logicd=NULL</code>
a default grid is considered. A pure Gaussian Mixture Model fit
(obtained when <code>log(icd)=-Inf</code>) is  included in the default
search path.
</p>
</td></tr>
<tr><td><code id="otrimle_+3A_npr.max">npr.max</code></td>
<td>

<p>A number in <code>[0,1)</code> specifying the maximum proportion of
noise/outliers. This defines the <em>noise proportion
constraint</em>. If <code>npr.max=0</code> a single solution without noise
component is computed (corresponding to <code>logicd = -Inf</code>.
</p>
</td></tr>
<tr><td><code id="otrimle_+3A_erc">erc</code></td>
<td>

<p>A number <code>&gt;=1</code> specifying the maximum allowed ratio between
within-cluster covariance matrix eigenvalues. This defines the
<em>eigenratio constraint</em>. <code>erc=1</code> enforces spherical clusters
with equal covariance matrices. A large <code>erc</code> allows for large
between-cluster covariance discrepancies. In order to facilitate the
setting of <code>erc</code>, it is suggested to scale the columns of
<code>data</code> (see <code><a href="base.html#topic+scale">scale</a></code>) whenever measurement units
of the different variables are grossly incompatible.
</p>
</td></tr>
<tr><td><code id="otrimle_+3A_beta">beta</code></td>
<td>

<p>A non-negative constant. This is the <em>beta</em> penalty coefficient
introduced in Coretto and Hennig (2016). 
</p>
</td></tr>
<tr><td><code id="otrimle_+3A_iter.max">iter.max</code></td>
<td>

<p>An integer value specifying the maximum number of iterations allowed
in the underlying ECM-algorithm.
</p>
</td></tr>
<tr><td><code id="otrimle_+3A_tol">tol</code></td>
<td>

<p>Stopping criterion for the underlying ECM-algorithm. An ECM iteration
stops if two successive improper log-likelihood values are within
<code>tol</code>.
</p>
</td></tr>
<tr><td><code id="otrimle_+3A_ncores">ncores</code></td>
<td>

<p>an integer value defining the number of cores used for parallel
computing. When <code>ncores=NULL</code> (default), the number <code>r</code> of
available cores is detected, and <code>(r-1)</code> of them are used (See
<em>Details</em>). If <code>ncores=1</code> no parallel backend is started.
</p>
</td></tr>
<tr><td><code id="otrimle_+3A_monitor">monitor</code></td>
<td>
<p>logical. If <code>TRUE</code> progress  messages are printed on
screen.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>otrimle</code> function computes the OTRIMLE solution based on  the
ECM-algorithm (expectation conditional maximization algorithm)
proposed in Coretto and Hennig (2017).
</p>
<p>The otrimle criterion is minimized over the <code>logicd</code> grid of
<code>log(icd)</code> values using parallel computing based on the
<code><a href="foreach.html#topic+foreach">foreach</a></code>.
Note that, depending on the BLAS/LAPACK setting, increasing <code>ncores</code> may not
produce the desired reduction in computing time.  The latter
happens when optimized linear algebra routines are in use (e.g.
OpenBLAS, Intel Math Kernel Library (MKL), etc.). These optimized shared
libraries  already implement multithreading. Therefore, in this case
increasing <code>ncores</code> may only reduce the computing time marginally.
</p>
<p>Occasionally,  there may be datasets for which the function does not provide a
solution based on default arguments. This corresponds to
<code>code=0</code> and <code>flag=1</code> or <code>flag=2</code> in the output (see
<em>Value</em>-section below).  This usually happens when some (or all) of the
following circumstances occur: (i) <code>erc</code> is too
large; (ii) <code>npr.max</code> is too large; (iii) choice of the initial
partition. Regarding (i) and (ii) it is not possible to give numeric
references because whether these numbers are too large/small
strongly depends on the sample size and the dimensionality of the
data. References given below explain the relationship between
these quantities. <br />
</p>
<p>It is suggested to try the following whenever a <code>code=0</code>
non-solution occurs. Set the <code>logicd</code> range wide enough
(e.g. <code>logicd=seq(-500,-5, length=50)</code>), choose <code>erc=1</code>,
and a low choice of <code>npr.max</code> (e.g. <code>npr.max=0.02</code>).
Monitor the solution with the criterion profiling plot
(<code><a href="#topic+plot.otrimle">plot.otrimle</a></code>). According to the criterion profiling
plot change <code>logicd</code>, and increase <code>erc</code> and <code>npr.max</code>
up to the point when a &quot;clear&quot; minimum in the criterion profiling plot
is obtained. If this strategy does not work it is suggested to
experiment with a different initial partitions (see <code>initial</code>
above).
</p>
<p>TBA: Christian may add something about the <code>beta</code> here.
</p>
<p>The <code>pi</code> object returned by the <code>rimle</code> function (see
<em>Value</em>) corresponds to the vector of <code>pi</code> parameters in
the underlying pseudo-model (1) defined in Coretto and Hennig (2017).
With <code>logicd = -Inf</code> the <code>rimle</code> function approximates the
MLE for the <em>plain</em> Gaussian mixture model with eigenratio
covariance regularization, in this case the the first element of the
<code>pi</code> vector is set to zero because the noise component is not
considered.  In general, for iid sampling from finite mixture models
context, these <em>pi</em> parameters define expected clusters'
proportions. Because of the noise proportion constraint in the RIMLE,
there are situations where this connection may not happen in
practice. The latter is likely to happen when both <code>logicd</code> and
<code>npr.max</code> are large. Therefore, estimated expected clusters' proportions
are reported in the <code>exproportion</code> object of the <code>rimle</code>
output, and these are computed based on the improper posterior
probabilities given in <code>tau</code>.  See Coretto and Hennig (2017) for
more discussion on this.
</p>
<p>An earlier approximate version of the algorithm was originally
proposed in Coretto and Hennig (2016). Software for the original
version of the algorithm can be found in the supplementary materials
of Coretto and Hennig (2016).
</p>


<h3>Value</h3>

<p>An S3 object of class <code>'otrimle'</code> providing the optimal (according to
the OTRIMLE criterion) clustering. Output components are as follows:
</p>
<table>
<tr><td><code>code</code></td>
<td>

<p>An integer indicator for the convergence.
<code>code=0</code> if no solution is found (see <em>Details</em>);
<code>code=1</code> if at the optimal icd value the corresponding EM-algorithm did not
converge within <code>em.iter.max</code>;
<code>code=2</code> convergence is fully achieved.
</p>
</td></tr>
<tr><td><code>flag</code></td>
<td>

<p>A character string containing one or more flags related to
the EM iteration at the optimal icd.
<code>flag=1</code>  if it was not possible to prevent the numerical
degeneracy of improper posterior probabilities (<code>tau</code> value
below).
<code>flag=2</code> if enforcement of the <em>noise proportion constraint</em>
failed for numerical reasons.
<code>flag=3</code> if the  <em>noise proportion constraint</em> has been
successfully applied at least once.
<code>flag=4</code> if the  <em>eigenratio constraint</em> has been
successfully applied at least once.
</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>

<p>Number of iterations performed in the underlying  EM-algorithm at the
optimal <code>icd</code>.
</p>
</td></tr>
<tr><td><code>logicd</code></td>
<td>

<p>Resulting value of the optimal <code>log(icd)</code>.
</p>
</td></tr>
<tr><td><code>iloglik</code></td>
<td>

<p>Resulting value of the improper likelihood.
</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>

<p>Resulting value of the OTRIMLE criterion.
</p>
</td></tr>
<tr><td><code>pi</code></td>
<td>

<p>Estimated vector of the <code>pi</code> parameters of the underlying pseudo-model (see <em>Details</em>).
</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>

<p>A matrix of dimension <code>ncol(data) x G</code> containing the
mean parameters  of each cluster (column-wise).
</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>

<p>An array of size <code>ncol(data) x ncol(data) x G</code>
containing the covariance matrices of each cluster.
</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>A matrix of dimension <code>nrow(data) x {1+G}</code> where
<code>tau[i, 1+j]</code> is the estimated (improper) posterior probability that
the <em>i</em>th observation belongs to the <em>j</em>th cluster.
<code>tau[i,1]</code> is the estimated (improper) posterior probability that
<em>i</em>th observation belongs to the noise component.
</p>
</td></tr>
<tr><td><code>smd</code></td>
<td>

<p>A matrix of dimension  <code>nrow(data) x G </code> where <code>smd[i,j]</code>
is the squared Mahalanobis distance of <code>data[i,]</code> from
<code>mean[,j]</code> according to <code>cov[,,j]</code>.
</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>

<p>A vector of integers  denoting cluster assignments for each
observation. It's <code>0</code> for observations assigned to  noise/outliers.
</p>
</td></tr>
<tr><td><code>size</code></td>
<td>

<p>A vector of integers with sizes (counts) of each cluster.
</p>
</td></tr>
<tr><td><code>exproportion</code></td>
<td>

<p>A vector of estimated expected clusters' proportions (see <em>Details</em>).
</p>
</td></tr>
<tr><td><code>optimization</code></td>
<td>

<p>A data.frame with  the OTRIMLE optimization profiling. For each
value of <code>log(icd)</code> explored by the algorithm the data.frame
stores <code>logicd, criterion, iloglik, code, flag</code>
(defined above), and <code>enpr</code> that denotes the expected noise
proportion.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Coretto, P.  and C. Hennig (2016).
Robust improper maximum likelihood: tuning, computation, and a comparison with
other methods for robust Gaussian clustering.
<em>Journal of the American Statistical Association</em>, Vol. 111(516),
pp. 1648-1659. 
doi: <a href="https://doi.org/10.1080/01621459.2015.1100996">10.1080/01621459.2015.1100996</a>
</p>
<p>P. Coretto and C. Hennig (2017).
Consistency, breakdown robustness, and algorithms for robust improper
maximum  likelihood clustering.
<em>Journal of Machine Learning Research</em>, Vol. 18(142), pp. 1-39. 
<a href="https://jmlr.org/papers/v18/16-382.html">https://jmlr.org/papers/v18/16-382.html</a>
</p>


<h3>Author(s)</h3>

<p>Pietro Coretto
<a href="mailto:pcoretto@unisa.it">pcoretto@unisa.it</a>
<a href="https://pietro-coretto.github.io">https://pietro-coretto.github.io</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.otrimle">plot.otrimle</a></code>,
<code><a href="#topic+InitClust">InitClust</a></code>,
<code><a href="#topic+rimle">rimle</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load  Swiss banknotes data
data(banknote)
x &lt;- banknote[,-1]

## Perform otrimle clustering with default arguments
set.seed(1)
a &lt;- otrimle(data=x, G=2, logicd=c(-Inf, -50, -10), ncores=1)

## Plot clustering
plot(a, data=x, what="clustering")

## Plot OTRIMLE criterion profiling
plot(a, what="criterion")

## Plot Improper log-likelihood profiling
plot(a, what="iloglik")

## P-P plot of the clusterwise empirical weighted squared Mahalanobis
## distances against the target distribution pchisq(, df=ncol(data))
plot(a, what="fit")
plot(a, what="fit", cluster=1)



## Perform the same otrimle as before with non-zero penalty
set.seed(1)
b &lt;- otrimle(data=x, G=2, beta = 0.5, logicd=c(-Inf, -50, -10), ncores=1)

## Plot clustering
plot(b, data=x, what="clustering")

## Plot OTRIMLE criterion profiling
plot(b, what="criterion")

## Plot Improper log-likelihood profiling
plot(b, what="iloglik")

## P-P plot of the clusterwise empirical weighted squared Mahalanobis
## distances against the target distribution pchisq(, df=ncol(data))
plot(b, what="fit")
plot(b, what="fit", cluster=1)





   
## Not run: 
## Perform the same example using the finer default grid of logicd
## values using multiple cores
##
a &lt;- otrimle(data = x, G = 2)

## Inspect the otrimle criterion-vs-logicd
plot(a, what = 'criterion')

## The minimum occurs at  a$logicd=-9, and exploring a$optimization it
## cane be seen that the interval [-12.5, -4] brackets the optimal
## solution. We search with a finer grid located around the minimum
##
b &lt;- otrimle(data = x, G = 2, logicd = seq(-12.5, -4, length.out = 25))

## Inspect the otrimle criterion-vs-logicd
plot(b, what = 'criterion')

## Check the difference between the two clusterings
table(A = a$cluster, B = b$cluster)

## Check differences in estimated parameters
##
colSums(abs(a$mean - b$mean))               ## L1 distance for mean vectors
apply({a$cov-b$cov}, 3, norm, type = "F")   ## Frobenius distance for covariances
c(Noise=abs(a$npr-b$npr), abs(a$cpr-b$cpr)) ## Absolute difference for proportions

## End(Not run)
</code></pre>

<hr>
<h2 id='otrimleg'>OTRIMLE for a range of numbers of clusters with density-based cluster quality statistic</h2><span id='topic+otrimleg'></span>

<h3>Description</h3>

<p>Computes Optimally Tuned Robust Improper Maximum Likelihood Clustering
(OTRIMLE), see <code><a href="#topic+otrimle">otrimle</a></code>,
together with the
density-based cluster quality statistics Q (Hennig and Coretto 2021)
for a range of values of the number of clusters. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>otrimleg(dataset, G=1:6, multicore=TRUE, ncores=detectCores(logical=FALSE)-1,
   erc=20, beta0=0, fixlogicd=NULL, monitor=1, dmaxq=qnorm(0.9995))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="otrimleg_+3A_dataset">dataset</code></td>
<td>
<p>something that can be coerced into an
observations times variables matrix. The dataset.</p>
</td></tr>
<tr><td><code id="otrimleg_+3A_g">G</code></td>
<td>
<p>vector of integers (normally starting from 1). Numbers of
clusters to be considered.</p>
</td></tr>
<tr><td><code id="otrimleg_+3A_multicore">multicore</code></td>
<td>
<p>logical. If <code>TRUE</code>, parallel computing is used
through the function <code><a href="parallel.html#topic+mclapply">mclapply</a></code> from package
<code>parallel</code>; read warnings there if you intend to use this; it
won't work on Windows.</p>
</td></tr>
<tr><td><code id="otrimleg_+3A_ncores">ncores</code></td>
<td>
<p>integer. Number of cores for parallelisation.</p>
</td></tr>
<tr><td><code id="otrimleg_+3A_erc">erc</code></td>
<td>
<p>A number larger or equal than one specifying the maximum
allowed ratio between within-cluster covariance matrix
eigenvalues. See <code><a href="#topic+otrimle">otrimle</a></code>.</p>
</td></tr>
<tr><td><code id="otrimleg_+3A_beta0">beta0</code></td>
<td>
<p>A non-negative constant, penalty term for noise, to be
passed as <code>beta</code> to  <code><a href="#topic+otrimle">otrimle</a></code>, see documentation
there.</p>
</td></tr>
<tr><td><code id="otrimleg_+3A_fixlogicd">fixlogicd</code></td>
<td>
<p>numeric of <code>NULL</code>. Value for the
logarithm of the improper
constant density <code>logicd</code>, see
<code><a href="#topic+rimle">rimle</a></code>, which is run instead of <code><a href="#topic+otrimle">otrimle</a></code>
if this is not <code>NULL</code>. <code>NULL</code> means that <code><a href="#topic+otrimle">otrimle</a></code>
determines it from the data.</p>
</td></tr>
<tr><td><code id="otrimleg_+3A_monitor">monitor</code></td>
<td>
<p>0 or 1. If 1, progress messages are printed on screen.</p>
</td></tr>
<tr><td><code id="otrimleg_+3A_dmaxq">dmaxq</code></td>
<td>
<p>numeric. Passed as <code>maxq</code> to
<code><a href="#topic+kerndensmeasure">kerndensmeasure</a></code>. The interval considered for the
one-dimensional density estimator is <code>(-maxq,maxq)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For estimating the number of clusters this is meant to be called by
<code><a href="#topic+otrimlesimg">otrimlesimg</a></code>. The output of <code><a href="#topic+otrimleg">otrimleg</a></code> is not
meant to be used directly for estimating the number of clusters, see
Hennig and Coretto (2021).</p>


<h3>Value</h3>

<p><code>otrimleg</code> returns a list
containing the components <code>solution, iloglik, ibic, criterion,
    logicd, noiseprob, denscrit, ddpm</code>. All of these are lists or
vectors of which the component number is the number of clusters.
</p>
<table>
<tr><td><code>solution</code></td>
<td>
<p>list of output objects of <code><a href="#topic+otrimle">otrimle</a></code> or
<code><a href="#topic+rimle">rimle</a></code>.</p>
</td></tr>
<tr><td><code>iloglik</code></td>
<td>
<p>vector of improper likelihood values from
<code><a href="#topic+otrimle">otrimle</a></code>.</p>
</td></tr>
<tr><td><code>ibic</code></td>
<td>
<p>vector of improper BIC-values (small is good) computed
from <code>iloglik</code> and the numbers of parameters. Note that the
behaviour of the improper likelihood is not compatible with the standard
use of the BIC, so this is experimental and should not be trusted
for choosing the number of clusters.</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>vector of values of OTRIMLE criterion, see
<code><a href="#topic+otrimle">otrimle</a></code>.</p>
</td></tr>
<tr><td><code>noiseprob</code></td>
<td>
<p>vector of estimated noise proportions,
<code>exproportion[1]</code> from <code><a href="#topic+otrimle">otrimle</a></code>.</p>
</td></tr>
<tr><td><code>denscrit</code></td>
<td>
<p>vector of density-based cluster quality statistics Q
(Hennig and Coretto 2021) as provided by the
<code>measure</code>-component of
<code><a href="#topic+kerndensmeasure">kerndensmeasure</a></code>.</p>
</td></tr>
<tr><td><code>ddpm</code></td>
<td>
<p>list of the vector of cluster-wise density-based cluster
quality measures as provided by the
<code>ddpm</code>-component of <code><a href="#topic+kerndensmeasure">kerndensmeasure</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en/">https://www.unibo.it/sitoweb/christian.hennig/en/</a></p>


<h3>References</h3>

<p>Coretto, P.  and C. Hennig (2016).  Robust improper maximum
likelihood: tuning, computation, and a comparison with other
methods for robust Gaussian clustering.  <em>Journal of the American
Statistical Association</em>, Vol. 111(516), pp. 1648-1659.  doi:
10.1080/01621459.2015.1100996
</p>
<p>P. Coretto and C. Hennig (2017).  Consistency, breakdown
robustness, and algorithms for robust improper maximum likelihood
clustering.  <em>Journal of Machine Learning Research</em>, Vol. 18(142),
pp. 1-39.  <a href="https://jmlr.org/papers/v18/16-382.html">https://jmlr.org/papers/v18/16-382.html</a>
</p>
<p>Hennig, C. and P.Coretto (2021). An adequacy approach for deciding the
number of clusters for OTRIMLE robust Gaussian mixture based
clustering. To appear in <em>Australian and New Zealand Journal of
Statistics</em>, <a href="https://arxiv.org/abs/2009.00921">https://arxiv.org/abs/2009.00921</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+otrimle">otrimle</a></code>, <code><a href="#topic+rimle">rimle</a></code>, <code><a href="#topic+otrimlesimg">otrimlesimg</a></code>,
<code><a href="#topic+kerndensmeasure">kerndensmeasure</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data(banknote)
   selectdata &lt;- c(1:30,101:110,117:136,160:161)
   x &lt;- banknote[selectdata,5:7]
   obanknote &lt;- otrimleg(x,G=1:2,multicore=FALSE)
</code></pre>

<hr>
<h2 id='otrimlesimg'>Adequacy approach for number of clusters for OTRIMLE</h2><span id='topic+otrimlesimg'></span><span id='topic+summary.otrimlesimgdens'></span><span id='topic+print.summary.otrimlesimgdens'></span><span id='topic+plot.summary.otrimlesimgdens'></span>

<h3>Description</h3>

<p><code>otrimlesimg</code> computes Optimally Tuned Robust Improper Maximum
Likelihood Clustering
(OTRIMLE), see <code><a href="#topic+otrimle">otrimle</a></code> for a range of values of the
number of clusters, and also for artificial datasets simulated from
the model parameters estimated on the original data. The
<code>summary</code>-methods present and evaluate the results so that a
smallest adequate number of clusters can be found as the smallest one
for which the value of the density-based cluster quality statistics Q
on the original data 
is compatible with its distribution on the artificial datasets with
the same number of clusters, see Hennig and Coretto 2021 for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>otrimlesimg(dataset, G=1:6, multicore=TRUE,
ncores=detectCores(logical=FALSE)-1, erc=20, beta0=0, simruns=20,
sim.est.logicd=FALSE, 
monitor=1)

## S3 method for class 'otrimlesimgdens'
summary(object, noisepenalty=0.05 , sdcutoff=2
, ...)

## S3 method for class 'summary.otrimlesimgdens'
print(x, ...)

## S3 method for class 'summary.otrimlesimgdens'
plot(x , plot="criterion", penx=NULL,
peny=NULL, pencex=1, cutoff=TRUE, ylim=NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="otrimlesimg_+3A_dataset">dataset</code></td>
<td>
<p>something that can be coerced into an
observations times variables matrix. The dataset.</p>
</td></tr>
<tr><td><code id="otrimlesimg_+3A_g">G</code></td>
<td>
<p>vector of integers (normally starting from 1). Numbers of
clusters to be considered.</p>
</td></tr>
<tr><td><code id="otrimlesimg_+3A_multicore">multicore</code></td>
<td>
<p>logical. If <code>TRUE</code>, parallel computing is used
through the function <code><a href="parallel.html#topic+mclapply">mclapply</a></code> from package
<code>parallel</code>; read warnings there if you intend to use this; it
won't work on Windows.</p>
</td></tr>
<tr><td><code id="otrimlesimg_+3A_ncores">ncores</code></td>
<td>
<p>integer. Number of cores for parallelisation.</p>
</td></tr>
<tr><td><code id="otrimlesimg_+3A_erc">erc</code></td>
<td>
<p>A number larger or equal than one specifying the maximum
allowed ratio between within-cluster covariance matrix
eigenvalues. See <code><a href="#topic+otrimle">otrimle</a></code>.</p>
</td></tr>
<tr><td><code id="otrimlesimg_+3A_beta0">beta0</code></td>
<td>
<p>A non-negative constant, penalty term for noise, to be
passed as <code>beta</code> to  <code><a href="#topic+otrimle">otrimle</a></code>, see documentation
there.</p>
</td></tr>
<tr><td><code id="otrimlesimg_+3A_simruns">simruns</code></td>
<td>
<p>integer. Number of replicate artificial datasets drawn
from each model.</p>
</td></tr> 
<tr><td><code id="otrimlesimg_+3A_sim.est.logicd">sim.est.logicd</code></td>
<td>
<p>logical. If <code>TRUE</code>, the logarithm of the improper
constant density <code>logicd</code>, see <code><a href="#topic+otrimle">otrimle</a></code>, is
re-estimated when running <code><a href="#topic+otrimle">otrimle</a></code> on the artificial
datasets. Otherwise the value estimated on the original data is
taken as fixed. <code>TRUE</code> requires much longer computation time,
but can be seen as generating more realistic variation.</p>
</td></tr>
<tr><td><code id="otrimlesimg_+3A_monitor">monitor</code></td>
<td>
<p>0 or 1. If 1, progress messages are printed on screen.</p>
</td></tr>
<tr><td><code id="otrimlesimg_+3A_noisepenalty">noisepenalty</code></td>
<td>
<p>number between 0 and 1. <code>p_0</code> in Hennig and
Coretto (2021); normally small. The method prefers to treat a
proportion of <code>&lt;=noisepenalty</code> of points as outliers to adding a
cluster.</p>
</td></tr>
<tr><td><code id="otrimlesimg_+3A_sdcutoff">sdcutoff</code></td>
<td>
<p>numerical. <code>c</code> in formula (7) in Hennig and
Coretto (2021). A clustering is treated as adequate if its value of
the density-based cluster quality measure Q calibrated (i.e.,
mean/sd-standardised) by the values on the artificial datasets
generated from the estimated model is <code>&lt;=sdcutoff</code>.</p>
</td></tr>
<tr><td><code id="otrimlesimg_+3A_plot">plot</code></td>
<td>
<p><code>"criterion"</code> or <code>"noise"</code>, see details.</p>
</td></tr>
<tr><td><code id="otrimlesimg_+3A_penx">penx</code></td>
<td>
<p><code>FALSE, NULL</code>, or numerical. x-coordinate from where
the simplicity ordering of clustering is given (as test in the
plot). If <code>FALSE</code>, this is not added to the plot. If
<code>NULL</code> a default guess is made for a good position (which
doesn't always work well).</p>
</td></tr>
<tr><td><code id="otrimlesimg_+3A_peny">peny</code></td>
<td>
<p><code>NULL</code>, or numerical. x-coordinate from where
the simplicity ordering of clustering is given (as test in the
plot). If
<code>NULL</code>, a default guess is made for a good position (which
doesn't always work well).</p>
</td></tr>
<tr><td><code id="otrimlesimg_+3A_pencex">pencex</code></td>
<td>
<p>numeric. Magnification factor (parameter <code>cex</code> to
be passed on to <code><a href="graphics.html#topic+legend">legend</a></code>) for simplicity ordering, see
parameter <code>penx</code>.</p>
</td></tr>
<tr><td><code id="otrimlesimg_+3A_cutoff">cutoff</code></td>
<td>
<p>logical. If <code>TRUE</code>, the <code>"criterion"</code>-plot
shows the cutoff value below which numbers of clusters are adequate,
see details.</p>
</td></tr>
<tr><td><code id="otrimlesimg_+3A_ylim">ylim</code></td>
<td>
<p>vector of two numericals, range of the y-axis to be passed
on to <code><a href="graphics.html#topic+plot">plot</a></code>. If <code>NULL</code>, the range is chosen
automatically (but can be different from the <code><a href="graphics.html#topic+plot">plot</a></code>
default).</p>
</td></tr>
<tr><td><code id="otrimlesimg_+3A_object">object</code></td>
<td>
<p>an object of class <code>'otrimlesimgdens'</code> obtained
from calling <code><a href="#topic+otrimlesimg">otrimlesimg</a></code>
</p>
</td></tr>
<tr><td><code id="otrimlesimg_+3A_x">x</code></td>
<td>
<p>an object of class <code>'summary.otrimlesimgdens'</code> obtained
from calling <code><a href="base.html#topic+summary">summary</a></code> function over an object of class 
<code>'otrimlesimgdens'</code> obtained from calling <code><a href="#topic+otrimlesimg">otrimlesimg</a></code>.
</p>
</td></tr>
<tr><td><code id="otrimlesimg_+3A_...">...</code></td>
<td>
<p>optional parameters to be passed on to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method is fully described in Hennig and Coretto
(2021). The required tuning constants for choosing an optimal number
of clusters, the smallest percentage of additional noise that the user
is willing to trade in for adding another cluster (<code>p_0</code> in the
paper, <code>noisepenalty</code> here) and the critical value (<code>c</code> in
the paper, <code>sdcutoff</code> here) for adequacy of the standardised
density based quality measure Q are provided to the summary function,
which is required to choose the best (simplest adequate) number of
clusters.
</p>
<p>The plot function <code>plot.summary.otrimlesimgdens</code> can produce two
plots. If <code>plot="criterion"</code>, the standardised density-based
cluster quality
measure Q is plotted against the number of clusters. The values for
the simulated artificial datasets are points, the values for the
original dataset are given as line type. If <code>cutoff="TRUE"</code>, the
critical values (see above) are added as red crosses; a number of
clusters is adequate if the value of the original data is below the
critical value, i.e., Q is not significantly larger than for the
artificial datasets generated from the fitted model. Using
<code>penx</code>, the ordered numbers of clusters from the simplest to the
least simple can also be indicated in the plot, where simplicitly is
defined as the number of clusters plus the estimated noise proportion
divided by <code>noisepenalty</code>, see above. The chosen number of
clusters is the simplest adequate one, meaning that a low number of
clusters and a low noise proportion are preferred.
</p>
<p>If <code>plot="noise"</code>, the noise proportion (black) and the
simplicity (red) are plotted against the numnber of clusters.
</p>


<h3>Value</h3>

<p><code>otrimlesimg</code> returns a list of type <code>"otrimlesimgdens"</code>
containing the components <code>result, simresult, simruns</code>.   
</p>
<table>
<tr><td><code>result</code></td>
<td>
<p>output object of <code><a href="#topic+otrimleg">otrimleg</a></code> (list of results on
original data) run with the parameters provided to
<code><a href="#topic+otrimlesimg">otrimlesimg</a></code>.</p>
</td></tr>
<tr><td><code>simresult</code></td>
<td>
<p>list of length <code>simruns</code> of output objects of
<code><a href="#topic+otrimleg">otrimleg</a></code> for all the simulated artificial datasets.</p>
</td></tr>
<tr><td><code>simruns</code></td>
<td>
<p>input parameter <code>simruns</code>.</p>
</td></tr>
</table>
<p><code>summary.otrimlesimgdens</code> returns a list of type
<code>"summary.otrimlesimgdens"</code> with components <code>G, simeval,
    ssimruns, npr, nprdiff, logicd, denscrit, peng,
    penorder, bestG, sdcutoff, bestresult,
    cluster</code>. <code>simruns</code> 
</p>
<table>
<tr><td><code>G</code></td>
<td>
<p><code>otrmlesimg</code> input parameter <code>G</code> (numbers of
clusters).</p>
</td></tr>
<tr><td><code>simeval</code></td>
<td>
<p>list with components <code>denscrit,
      meandens, sddens, standens, errors</code>, defined below.</p>
</td></tr>
<tr><td><code>ssimruns</code></td>
<td>
<p><code>otrmlesimg</code> input parameter <code>simruns</code>.</p>
</td></tr>
<tr><td><code>npr</code></td>
<td>
<p>vector of estimated noise proportions on the original data
for all numbers of clusters, <code>exproportion[1]</code> from
<code><a href="#topic+otrimle">otrimle</a></code>.</p>
</td></tr>
<tr><td><code>nprdiff</code></td>
<td>
<p>vector for all numbers of clusters of differences
between estimated smallest cluster proportion and noise proportion
on the original data.</p>
</td></tr>
<tr><td><code>logicd</code></td>
<td>
<p>vector of logs of improper constant density values on
the original data for all numbers of clusters.</p>
</td></tr>
<tr><td><code>denscrit</code></td>
<td>
<p>vector over all numbers of clusters of density-based
cluster quality statistics Q
on original data as provided by the <code>measure</code>-component of
<code><a href="#topic+kerndensmeasure">kerndensmeasure</a></code>.</p>
</td></tr>
<tr><td><code>peng</code></td>
<td>
<p>vector of simplicity values (see Details) over all numbers
of clusters.</p>
</td></tr>
<tr><td><code>penorder</code></td>
<td>
<p>simplicity order of number of clusters.</p>
</td></tr>
<tr><td><code>bestG</code></td>
<td>
<p>best (i.e., most simple adequate) number of clusters.</p>
</td></tr>
<tr><td><code>sdcutoff</code></td>
<td>
<p>input parameter <code>sdcutoff</code>.</p>
</td></tr>
<tr><td><code>result</code></td>
<td>
<p>output of <code><a href="#topic+otrimle">otrimle</a></code> for the best number of
clusters <code>bestG</code>.</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>clustering vector for the best number of
clusters <code>bestG</code>. <code>0</code> corresponds to noise/outliers.</p>
</td></tr>
</table>
<p>Components of <code>summary.otrimlesimgdens</code> output component
<code>simeval</code>:
</p>
<table>
<tr><td><code>denscritmatrix</code></td>
<td>
<p>maximum number of clusters times <code>simruns</code> matrix
of <code>denscrit</code>-vectors for all clusterings on simulated data.</p>
</td></tr>
<tr><td><code>meandens</code></td>
<td>
<p>vector over numbers of clusters of robust estimator of
the mean of <code>denscrit</code> over simulated datasets, computed by
<code><a href="robustbase.html#topic+scaleTau2">scaleTau2</a></code>.</p>
</td></tr>    
<tr><td><code>sddens</code></td>
<td>
<p>vector over numbers of clusters of robust estimator of
the standard deviation of <code>denscrit</code> over simulated datasets,
computed by <code><a href="robustbase.html#topic+scaleTau2">scaleTau2</a></code>.</p>
</td></tr>    
<tr><td><code>standens</code></td>
<td>
<p>vector over numbers of clusters of <code>denscrit</code> of
the original data standardised by <code>meandens</code> and
<code>sddens</code>.</p>
</td></tr>
<tr><td><code>errors</code></td>
<td>
<p>vector over numbers of clusters of numbers of times that
<code><a href="#topic+otrimle">otrimle</a> led to an error.</code>
</p>
<p><code>plot.summary.otrimlesimgdens</code> will return the output
of <code><a href="graphics.html#topic+par">par</a>()</code> before anything was changed by the plot
function. 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en/">https://www.unibo.it/sitoweb/christian.hennig/en/</a>
</p>


<h3>References</h3>

<p>Coretto, P.  and C. Hennig (2016).  Robust improper maximum
likelihood: tuning, computation, and a comparison with other
methods for robust Gaussian clustering.  <em>Journal of the American
Statistical Association</em>, Vol. 111(516), pp. 1648-1659.
doi: <a href="https://doi.org/10.1080/01621459.2015.1100996">10.1080/01621459.2015.1100996</a>
</p>
<p>P. Coretto and C. Hennig (2017).  Consistency, breakdown
robustness, and algorithms for robust improper maximum likelihood
clustering. <em>Journal of Machine Learning Research</em>, Vol. 18(142),
pp. 1-39.  <a href="https://jmlr.org/papers/v18/16-382.html">https://jmlr.org/papers/v18/16-382.html</a>
</p>
<p>Hennig, C. and P.Coretto (2021). An adequacy approach for deciding the
number of clusters for OTRIMLE robust Gaussian mixture based
clustering. To appear in <em>Australian and New Zealand Journal of
Statistics</em>, <a href="https://arxiv.org/abs/2009.00921">https://arxiv.org/abs/2009.00921</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+otrimle">otrimle</a></code>, <code><a href="#topic+rimle">rimle</a></code>, <code><a href="#topic+otrimleg">otrimleg</a></code>,
<code><a href="#topic+kerndensmeasure">kerndensmeasure</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## otrimlesimg is computer intensive, so only a small data subset
## is used for speed.
data(banknote)
selectdata &lt;- c(1:30,101:110,117:136,160:161)
set.seed(555566)
x &lt;- banknote[selectdata,5:7]
   
## simruns=2 chosen for speed. This is not recommended in practice. 
obanknote &lt;- otrimlesimg(x,G=1:2,multicore=FALSE,simruns=2,monitor=0)
sobanknote &lt;- summary(obanknote)
print(sobanknote)
plot(sobanknote,plot="criterion",penx=1.4)
plot(sobanknote,plot="noise",penx=1.4)
plot(x,col=sobanknote$cluster+1,pch=c("N","1","2")[sobanknote$cluster+1])
</code></pre>

<hr>
<h2 id='plot.otrimle'>
Plot Methods for OTRIMLE Objects
</h2><span id='topic+plot.otrimle'></span>

<h3>Description</h3>

<p>Plot robust model-based clustering results: scatter plot with
clustering information, optimization profiling, and cluster fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'otrimle'
plot(x, what=c("criterion","iloglik", "fit", "clustering"),
     data=NULL, margins=NULL, cluster=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.otrimle_+3A_x">x</code></td>
<td>

<p>Output from <code><a href="#topic+otrimle">otrimle</a></code>
</p>
</td></tr>
<tr><td><code id="plot.otrimle_+3A_what">what</code></td>
<td>

<p>The type of graph. It can be one of the following:
<code>"criterion"</code> (default), <code>"iloglik"</code>, <code>"fit"</code>, <code>"clustering"</code>. See <em>Details</em>.
</p>
</td></tr>
<tr><td><code id="plot.otrimle_+3A_data">data</code></td>
<td>
<p>The data vector, matrix or data.frame (or some transformation of them), used for obtaining the
<code>'otrimle'</code> object. This is only relevant if <code>what="clustering"</code>.
</p>
</td></tr>
<tr><td><code id="plot.otrimle_+3A_margins">margins</code></td>
<td>

<p>A vector of integers denoting the variables (numbers of columns of
<code>data</code>) to be used for a <code>pairs</code>-plot if
<code>what="clustering"</code>. When <code>margins=NULL</code> it is
set to  <code>1:ncol(data)</code> (default).
</p>
</td></tr>
<tr><td><code id="plot.otrimle_+3A_cluster">cluster</code></td>
<td>
<p>An integer denoting the cluster for which the <em>fit</em>
plot is returned. This is only relevant if <code>what="fit"</code>.
</p>
</td></tr>
<tr><td><code id="plot.otrimle_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>If <code>what="criterion"</code></dt><dd>
<p>A plot with the profiling of the OTRIMLE criterion
optimization. Criterion at <code>log(icd)=-Inf</code> is always represented.
</p>
</dd>
<dt>If <code>what="iloglik"</code></dt><dd>
<p>A plot with the profiling of the improper log<code>-</code>likelihood function
along the search path for the OTRIMLE optimization.
</p>
</dd>
<dt>If <code>what="fit"</code></dt><dd>
<p>The P<code>-</code>P plot (probability<code>-</code>probability plot) of the weighted empirical
distribution function of the Mahalanobis distances of observations
from clusters' centers against the target distribution. The target
distribution is the Chi-square distribution with degrees of
freedom equal to
<code>ncol(data)</code>. The weights are given by the improper posterior
probabilities. If <code>cluster=NULL</code> P<code>-</code>P plots are produced for
all clusters, otherwise <code>cluster</code> selects a single P<code>-</code>P
plot at times.
</p>
</dd>
<dt>If <code>what="clustering"</code></dt><dd>
<p>A pairwise scatterplot with cluster memberships. Points
assigned to the noise/outliers component are denoted by
<code>'+'</code>.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Coretto, P.  and C. Hennig (2016).
Robust improper maximum likelihood: tuning, computation, and a comparison with
other methods for robust Gaussian clustering.
<em>Journal of the American Statistical Association</em>, Vol. 111(516),
pp. 1648-1659. 
doi: <a href="https://doi.org/10.1080/01621459.2015.1100996">10.1080/01621459.2015.1100996</a>
</p>
<p>P. Coretto and C. Hennig (2017).
Consistency, breakdown robustness, and algorithms for robust improper
maximum  likelihood clustering.
<em>Journal of Machine Learning Research</em>, Vol. 18(142), pp. 1-39. 
<a href="https://jmlr.org/papers/v18/16-382.html">https://jmlr.org/papers/v18/16-382.html</a>
</p>


<h3>Author(s)</h3>

<p>Pietro Coretto
<a href="mailto:pcoretto@unisa.it">pcoretto@unisa.it</a>
<a href="https://pietro-coretto.github.io">https://pietro-coretto.github.io</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.otrimle">plot.otrimle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load  Swiss banknotes data
data(banknote)
x &lt;- banknote[,-1]

## Perform otrimle clustering on a small grid of logicd values
a &lt;- otrimle(data = x, G = 2, logicd = c(-Inf, -50, -10), ncores = 1)
print(a)

## Plot clustering
plot(a, data = x, what = "clustering")

## Plot clustering on selected margins
plot(a, data = x, what = "clustering", margins = 4:6)

## Plot clustering on the first two principal components
z &lt;- scale(x) %*%   eigen(cor(x), symmetric = TRUE)$vectors
colnames(z) &lt;- paste("PC", 1:ncol(z), sep = "")
plot(a, data = z, what = "clustering", margins = 1:2)

## Plot OTRIMLE criterion profiling
plot(a, what = "criterion")

## Plot Improper log-likelihood profiling
plot(a, what = "iloglik")

## Fit plot for all clusters
plot(a, what = "fit")

## Fit plot for cluster 1
plot(a, what = "fit", cluster = 1)



## Not run: 
## Perform the same example using the finer default grid of logicd
## values using multiple cores
##
a &lt;- otrimle(data = x, G = 2)

## Inspect the otrimle criterion-vs-logicd
plot(a, what = 'criterion')

## The minimum occurs at  a$logicd=-9, and exploring a$optimization it
## cane be seen that the interval [-12.5, -4] brackets the optimal
## solution. We search with a finer grid located around the minimum
##
b &lt;- otrimle(data = x, G = 2, logicd = seq(-12.5, -4, length.out = 25))

## Inspect the otrimle criterion-vs-logicd
plot(b, what = 'criterion')

## Check the difference between the two clusterings
table(A = a$cluster, B = b$cluster)

## Check differences in estimated parameters
##
colSums(abs(a$mean - b$mean))               ## L1 distance for mean vectors
apply({a$cov-b$cov}, 3, norm, type = "F")   ## Frobenius distance for covariances
c(Noise=abs(a$npr-b$npr), abs(a$cpr-b$cpr)) ## Absolute difference for proportions

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.rimle'>
Plot Methods for RIMLE Objects
</h2><span id='topic+plot.rimle'></span>

<h3>Description</h3>

<p>Plot robust model-based clustering results: scatter plot with
clustering information and cluster fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rimle'
plot(x, what=c("fit", "clustering"),
     data=NULL, margins=NULL, cluster=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.rimle_+3A_x">x</code></td>
<td>

<p>Output from <code><a href="#topic+rimle">rimle</a></code>
</p>
</td></tr>
<tr><td><code id="plot.rimle_+3A_what">what</code></td>
<td>

<p>The type of graph. It can be one of the following:
<code>"fit"</code> (default), <code>"clustering"</code>. See <em>Details</em>.
</p>
</td></tr>
<tr><td><code id="plot.rimle_+3A_data">data</code></td>
<td>
<p>The data vector, matrix or data.frame (or some
transformation of them),  used for obtaining the
<code>'rimle'</code> object. This is only relevant if
<code>what="clustering"</code>.
</p>
</td></tr>
<tr><td><code id="plot.rimle_+3A_margins">margins</code></td>
<td>

<p>A vector of integers denoting the variables (numbers of columns of
<code>data</code>) to be used for a <code>pairs</code>-plot if
<code>what="clustering"</code>. When <code>margins=NULL</code> it is
set to  <code>1:ncol(data)</code> (default).
</p>
</td></tr>
<tr><td><code id="plot.rimle_+3A_cluster">cluster</code></td>
<td>
<p>An integer denoting the cluster for which the <em>fit</em>
plot is returned. This is only relevant if <code>what="fit"</code>.
</p>
</td></tr>
<tr><td><code id="plot.rimle_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>If <code>what="fit"</code></dt><dd>
<p>The P<code>-</code>P plot (probability<code>-</code>probability plot) of the weighted empirical
distribution function of the Mahalanobis distances of observations
from clusters' centers against the target distribution. The target
distribution is the Chi-square distribution with degrees of
freedom equal to <code>ncol(data)</code>. The weights are given by the improper posterior
probabilities. If <code>cluster=NULL</code> P<code>-</code>P plots are produced for
all clusters, otherwise <code>cluster</code> selects a single P<code>-</code>P
plot at times.
</p>
</dd>
<dt>If <code>what="clustering"</code></dt><dd>
<p>A pairwise scatterplot with cluster memberships. Points
assigned to the noise/outliers component are denoted by
<code>'+'</code>.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Coretto, P.  and C. Hennig (2016).
Robust improper maximum likelihood: tuning, computation, and a comparison with
other methods for robust Gaussian clustering.
<em>Journal of the American Statistical Association</em>, Vol. 111(516),
pp. 1648-1659. 
doi: <a href="https://doi.org/10.1080/01621459.2015.1100996">10.1080/01621459.2015.1100996</a>
</p>
<p>P. Coretto and C. Hennig (2017).
Consistency, breakdown robustness, and algorithms for robust improper
maximum  likelihood clustering.
<em>Journal of Machine Learning Research</em>, Vol. 18(142), pp. 1-39.
<a href="https://jmlr.org/papers/v18/16-382.html">https://jmlr.org/papers/v18/16-382.html</a>
</p>


<h3>Author(s)</h3>

<p>Pietro Coretto
<a href="mailto:pcoretto@unisa.it">pcoretto@unisa.it</a>
<a href="https://pietro-coretto.github.io">https://pietro-coretto.github.io</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+otrimle">otrimle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load  Swiss banknotes data
data(banknote)
x &lt;- banknote[,-1]

## Perform rimle clustering with default arguments
set.seed(1)
a &lt;- rimle(data = x, G = 2)
print(a)

## Plot clustering
plot(a, data = x, what = "clustering")

## Plot clustering on selected margins
plot(a, data = x, what = "clustering", margins = 4:6)

## Plot clustering on the first two principal components
z &lt;- scale(x) %*%   eigen(cor(x), symmetric = TRUE)$vectors
colnames(z) &lt;- paste("PC", 1:ncol(z), sep = "")
plot(a, data = z, what = "clustering", margins = 1:2)

## Fit plot for all clusters
plot(a, what = "fit")

## Fit plot for cluster 1
plot(a, what = "fit", cluster = 1)
</code></pre>

<hr>
<h2 id='rimle'>Robust Improper Maximum Likelihood Clustering</h2><span id='topic+rimle'></span><span id='topic+print.rimle'></span>

<h3>Description</h3>

<p><code>rimle</code> searches for <code>G</code> approximately Gaussian-shaped
clusters with/without noise/outliers. The method's tuning controlling
the noise level is fixed and is to be provided by the user or will be guessed by
the function in a rather quick and dirty way (<code><a href="#topic+otrimle">otrimle</a></code>
performs  a more sophisticated data-driven choice).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rimle(data, G, initial=NULL, logicd=NULL, npr.max=0.5, erc=20, iter.max=500, tol=1e-6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rimle_+3A_data">data</code></td>
<td>

<p>A numeric vector, matrix, or data frame of observations. Rows correspond
to observations and columns correspond to variables. Categorical
variables and <code>NA</code> values are not allowed.
</p>
</td></tr>
<tr><td><code id="rimle_+3A_g">G</code></td>
<td>

<p>An integer specifying the number of clusters.
</p>
</td></tr>
<tr><td><code id="rimle_+3A_initial">initial</code></td>
<td>
<p>An integer vector specifying the initial cluster
assignment  with <code>0</code> denoting noise/outliers. If <code>NULL</code> (default)
initialization is performed using <code><a href="#topic+InitClust">InitClust</a></code>.
</p>
</td></tr>
<tr><td><code id="rimle_+3A_logicd">logicd</code></td>
<td>

<p>A number <code>log(icd)</code>, where <code>0 &lt;= icd &lt; Inf</code>
is the value of the improper constant density (<code>icd</code>). This is
the RIMLE's tuning for controlling the size of the noise.
If <code>logicd=NULL</code> (default), an <code>icd</code> value is guessed
based on the data. A pure Gaussian Mixture Model fit is obtained
with <code>logicd = -Inf</code>.
</p>
</td></tr>
<tr><td><code id="rimle_+3A_npr.max">npr.max</code></td>
<td>

<p>A number in <code>[0,1)</code> specifying the maximum proportion of
noise/outliers. This defines the <em>noise proportion
constraint</em>. If <code>npr.max=0</code> a solution without noise
component is computed (corresponding to <code>logicd = -Inf</code>.
</p>
</td></tr>
<tr><td><code id="rimle_+3A_erc">erc</code></td>
<td>

<p>A number <code>&gt;=1</code> specifying the maximum allowed ratio between
within-cluster covariance matrix eigenvalues. This defines the
<em>eigenratio constraint</em>. <code>erc=1</code> enforces spherical clusters
with equal covariance matrices. A large <code>erc</code> allows for large
between-cluster covariance discrepancies. In order to facilitate the
setting of <code>erc</code>, it is suggested to scale the columns of
<code>data</code> (see <code><a href="base.html#topic+scale">scale</a></code>) whenever measurement units
of the different variables are grossly incompatible.
</p>
</td></tr>
<tr><td><code id="rimle_+3A_iter.max">iter.max</code></td>
<td>

<p>An integer value specifying the maximum number of iterations allowed
in the  ECM-algorithm (see Details).
</p>
</td></tr>
<tr><td><code id="rimle_+3A_tol">tol</code></td>
<td>

<p>Stopping criterion for the underlying ECM-algorithm. An ECM iteration
stops if two successive improper log-likelihood values are within
<code>tol</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>rimle</code> function computes the RIMLE solution using the
ECM-algorithm proposed in Coretto and Hennig (2017).
</p>
<p>There may be datasets for which the function does not provide a
solution based on default arguments. This corresponds to
<code>code=0</code> and <code>flag=1</code> or <code>flag=2</code>  in the output (see
<em>Value</em>-section below).  This usually happens when some (or all) of the
following circumstances occur: (i) <code>log(icd)</code> is too
large; (ii) <code>erc</code> is too large; (iii) npr.max is too large;
(iv) choice of the initial partition. In these cases it is suggested
to find a suitable interval of <code>icd</code> values by using the
<code><a href="#topic+otrimle">otrimle</a></code> function. The <em>Details</em> section of
<code><a href="#topic+otrimle">otrimle</a></code> suggests several actions to take
whenever a <code>code=0</code> non-solution occurs.
</p>
<p>The <code>pi</code> object returned by the <code>rimle</code> function (see
<em>Value</em>) corresponds to the vector of <code>pi</code> parameters in
the underlying pseudo-model (1) defined in Coretto and Hennig (2017).
With <code>logicd = -Inf</code> the <code>rimle</code> function approximates the
MLE for the <em>plain</em> Gaussian mixture model with eigenratio
covariance regularization, in this case the the first element of the
<code>pi</code> vector is set to zero because the noise component is not
considered.  In general, for iid sampling from finite mixture models
context, these <em>pi</em> parameters define expected clusters'
proportions. Because of the noise proportion constraint in the RIMLE,
there are situations where this connection may not happen in
practice. The latter is likely to happen when both <code>logicd</code> and
<code>npr.max</code> are large. Therefore, estimated expected clusters'
proportions are reported in the <code>exproportion</code> object of the
<code>rimle</code> output, and these are computed based on the
improper posterior probabilities given in <code>tau</code>.
See Coretto and Hennig (2017) for more discussion on this. 
</p>
<p>An earlier approximate version of the algorithm was originally
proposed in Coretto and Hennig (2016). Software for the original
version of the algorithm can be found in the supplementary materials
of  Coretto and Hennig (2016).
</p>


<h3>Value</h3>

<p>An S3 object of class <code>'rimle'</code>. Output components are as follows:
</p>
<table>
<tr><td><code>code</code></td>
<td>

<p>An integer indicator for the convergence.
<code>code=0</code> if no solution is found (see <em>Details</em>);
<code>code=1</code> if the  EM-algorithm did not converge within <code>em.iter.max</code>;
<code>code=2</code> convergence is fully achieved.
</p>
</td></tr>
<tr><td><code>flag</code></td>
<td>

<p>A character string containing one or more flags related to
the EM iteration at the optimal icd.
<code>flag=1</code>  if it was not possible to prevent the numerical
degeneracy of improper posterior probabilities (<code>tau</code> value
below).
<code>flag=2</code> if enforcement of the <em>noise proportion constraint</em>
failed for numerical reasons.
<code>flag=3</code> if enforcement of the <em>eigenratio constraint</em> failed for
numerical reasons.
<code>flag=4</code> if the  <em>noise proportion constraint</em> has been
successfully applied at least once.
<code>flag=5</code> if the  <em>eigenratio constraint</em> has been
successfully applied at least once.
</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>

<p>Number of iterations performed in the underlying  EM-algorithm.
</p>
</td></tr>
<tr><td><code>logicd</code></td>
<td>

<p>Value of the <code>log(icd)</code>.
</p>
</td></tr>
<tr><td><code>iloglik</code></td>
<td>

<p>Value of the improper likelihood.
</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>

<p>Value of the OTRIMLE criterion.
</p>
</td></tr>
<tr><td><code>pi</code></td>
<td>

<p>Estimated vector of the <code>pi</code> parameters of the underlying pseudo-model (see <em>Details</em>).
</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>

<p>A matrix of dimension <code>ncol(data) x G</code> containing the
mean parameters  of each cluster (column-wise).
</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>

<p>An array of size <code>ncol(data) x ncol(data) x G</code>
containing the covariance matrices of each cluster.
</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>A matrix of dimension <code>nrow(data) x {1+G}</code> where
<code>tau[i, 1+j]</code> is the estimated (improper) posterior probability that
the <em>i</em>th observation belongs to the <em>j</em>th cluster.
<code>tau[i,1]</code> is the estimated (improper) posterior probability that
<em>i</em>th observation belongs to the noise component.
</p>
</td></tr>
<tr><td><code>smd</code></td>
<td>

<p>A matrix of dimension  <code>nrow(data) x G </code> where <code>smd[i,j]</code>
is the squared Mahalanobis distance of <code>data[i,]</code> from
<code>mean[,j]</code> according to <code>cov[,,j]</code>.
</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>

<p>A vector of integers  denoting cluster assignments for each
observation. It's <code>0</code> for observations assigned to  noise/outliers.
</p>
</td></tr>
<tr><td><code>size</code></td>
<td>

<p>A vector of integers with sizes (counts) of each cluster.
</p>
</td></tr>
<tr><td><code>exproportion</code></td>
<td>

<p>A vector of estimated expected clusters' proportions (see <em>Details</em>).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pietro Coretto
<a href="mailto:pcoretto@unisa.it">pcoretto@unisa.it</a>
<a href="https://pietro-coretto.github.io">https://pietro-coretto.github.io</a>
</p>


<h3>References</h3>

<p>Coretto, P.  and C. Hennig (2016).
Robust improper maximum likelihood: tuning, computation, and a comparison with
other methods for robust Gaussian clustering.
<em>Journal of the American Statistical Association</em>, Vol. 111(516),
pp. 1648-1659. doi: <a href="https://doi.org/10.1080/01621459.2015.1100996">10.1080/01621459.2015.1100996</a>
</p>
<p>P. Coretto and C. Hennig (2017).
Consistency, breakdown robustness, and algorithms for robust improper
maximum  likelihood clustering.
<em>Journal of Machine Learning Research</em>, Vol. 18(142), pp. 1-39.
<a href="https://jmlr.org/papers/v18/16-382.html">https://jmlr.org/papers/v18/16-382.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.rimle">plot.rimle</a></code>,
<code><a href="#topic+InitClust">InitClust</a></code>,
<code><a href="#topic+otrimle">otrimle</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load  Swiss banknotes data
data(banknote)
x &lt;- banknote[,-1]

## -----------------------------------------------------------------------------
## EXAMPLE 1:
## Perform RIMLE with default inputs
## -----------------------------------------------------------------------------
set.seed(1)
a &lt;- rimle(data = x, G = 2)
print(a)

## Plot clustering
plot(a, data = x, what = "clustering")

## P-P plot of the clusterwise empirical weighted squared Mahalanobis
## distances against the target distribution pchisq(, df=ncol(data))
plot(a, what = "fit")
plot(a, what = "fit", cluster = 1)



## -----------------------------------------------------------------------------
## EXAMPLE 2:
## Compare solutions for different choices of logicd
## -----------------------------------------------------------------------------
set.seed(1)

## Case 1: noiseless solution, that is fit a pure Gaussian Mixture Model
b1 &lt;- rimle(data = x, G = 2, logicd = -Inf)
plot(b1, data=x, what="clustering")
plot(b1, what="fit")

## Case 2: low noise level
b2 &lt;- rimle(data = x, G = 2, logicd = -100)
plot(b2, data=x, what="clustering")
plot(b2, what="fit")

## Case 3: medium noise level
b3 &lt;- rimle(data = x, G = 2, logicd = -10)
plot(b3, data=x, what="clustering")
plot(b3, what="fit")

## Case 3: large noise level
b3 &lt;- rimle(data = x, G = 2, logicd = 5)
plot(b3, data=x, what="clustering")
plot(b3, what="fit")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
