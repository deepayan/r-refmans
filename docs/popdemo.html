<!DOCTYPE html><html><head><title>Help for package popdemo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {popdemo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#popdemo-package'><p>Provides tools for demographic modelling using projection matrices</p></a></li>
<li><a href='#blockmatrix'><p>Block-permute a reducible matrix</p></a></li>
<li><a href='#CohenD'><p>Calculate Cohen's cumulative distance</p></a></li>
<li><a href='#convt'><p>Calculate time to convergence</p></a></li>
<li><a href='#dr'><p>Calculate damping ratio</p></a></li>
<li><a href='#eigs'><p>Calculate asymptotic growth</p></a></li>
<li><a href='#elas'><p>Calculate elasticity matrix</p></a></li>
<li><a href='#inertia'><p>Calculate population inertia</p></a></li>
<li><a href='#isErgodic'><p>Determine ergodicity of a matrix</p></a></li>
<li><a href='#isIrreducible'><p>Determine reducibility of a matrix</p></a></li>
<li><a href='#isPrimitive'><p>Determine primitivity of a matrix</p></a></li>
<li><a href='#KeyfitzD'><p>Calculate Keyfitz's delta</p></a></li>
<li><a href='#Kreiss'><p>Calculate Kreiss bounds</p></a></li>
<li><a href='#Matlab2R'><p>Read Matlab style matrices into R</p></a></li>
<li><a href='#maxamp'><p>Calculate maximal amplification</p></a></li>
<li><a href='#maxatt'><p>Calculate maximal attenuation</p></a></li>
<li><a href='#Pbear'><p>Polar bear matrices</p></a></li>
<li><a href='#plot.tfa'><p>Plot transfer function</p></a></li>
<li><a href='#plot.tfam'><p>Plot transfer function</p></a></li>
<li><a href='#popdemo-deprecated'><p>Deprecated functions in the popdemo package</p></a></li>
<li><a href='#project'><p>Project population dynamics</p></a></li>
<li><a href='#Projection-class'><p>'Projection' object S4 class</p></a></li>
<li><a href='#Projection-plots'><p>Plot methods for 'Projection' objects</p></a></li>
<li><a href='#projectionD'><p>Calculate projection distance</p></a></li>
<li><a href='#R2Matlab'><p>Convert matrices into Matlab style strings</p></a></li>
<li><a href='#reac'><p>Calculate reactivity and first-timestep attenuation</p></a></li>
<li><a href='#sens'><p>Calculate sensitivity matrix</p></a></li>
<li><a href='#stoch'><p>Project population dynamics</p></a></li>
<li><a href='#tfa_inertia'><p>Transfer function Analysis</p></a></li>
<li><a href='#tfa_lambda'><p>Transfer function analysis</p></a></li>
<li><a href='#tfam_inertia'><p>Transfer function Analysis</p></a></li>
<li><a href='#tfam_lambda'><p>Transfer function analysis</p></a></li>
<li><a href='#tfs_inertia'><p>Calculate sensitivity of inertia using transfer functions</p></a></li>
<li><a href='#tfs_lambda'><p>Calculate sensitivity using transfer functions</p></a></li>
<li><a href='#Tort'><p>Desert tortoise matrix</p></a></li>
<li><a href='#truelambda'><p>Calculate asymptotic growth</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Demographic Modelling Using Projection Matrices</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3-1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Iain Stott &lt;iainmstott@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for modelling populations and demography using matrix projection models,
 with deterministic and stochastic model implementations. Includes population projection,
 indices of short- and long-term population size and growth, perturbation analysis,
 convergence to stability or stationarity, and diagnostic and manipulation tools.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>expm, graphics, methods, MCMCpack, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, magick, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-16 13:50:59 UTC; Iain Stott</td>
</tr>
<tr>
<td>Author:</td>
<td>Iain Stott [aut, cre],
  Dave Hodgson [aut],
  Stuart Townley [aut],
  Stephen Ellner [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-16 14:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='popdemo-package'>Provides tools for demographic modelling using projection matrices</h2><span id='topic+popdemo'></span><span id='topic+popdemo-package'></span>

<h3>Description</h3>

<p><code>popdemo</code> provides tools for modelling populations and demography using 
matrix projection models (MPMs), with deterministic and stochastic model 
implementations. These tools include population projection, indices of short- 
and long-term population size and growth, perturbation analysis, convergence 
to stability or stationarity, and diagnostic and manipulation tools. This includes:
</p>

<dl>
<dt>POPULATION PROJECTION</dt><dd>
<p><code>popdemo</code> provides a simple means of projecting and plotting PPM models.
<code><a href="#topic+project">project</a></code> provides a means to project and plot population 
dynamics of both deterministic and stochastic models. Many methods are available
for working with population projections: see <code><a href="#topic+Projection-class">Projection-class</a></code> and 
<code><a href="#topic+Projection-plots">Projection-plots</a></code>
</p>
</dd>
<dt>ASYMPTOTIC DYNAMICS</dt><dd>
<p>The <code><a href="#topic+eigs">eigs</a></code> function provides a simple means to calculate asymptotic 
population dynamics using matrix eigenvalues.
</p>
</dd>
<dt>TRANSIENT DYNAMICS</dt><dd>
<p>There are functions for calculating transient dynamics at various points of 
the population projection. <code><a href="#topic+reac">reac</a></code> measures immediate transient 
density of a population (within the first time step). <code><a href="#topic+maxamp">maxamp</a></code>, 
<code><a href="#topic+maxatt">maxatt</a></code> are near-term indices that measure the largest and 
smallest transient dynamics a population may exhibit overall, respectively. 
code<a href="#topic+inertia">inertia</a> measures asymptotic population density relative to stable
state, and has many perturbation methods in the package (see below). All transient 
indices can be calculated using specific population structures, as well as bounds on
population size.
</p>
</dd>
<dt>PERTURBATION ANALYSIS</dt><dd>
<p>Methods for linear perturbation (sensitivity and elasticity) analysis of asymptotic dynamics 
are available through the <code><a href="#topic+sens">sens</a></code>, <code><a href="#topic+tfs_lambda">tfs_lambda</a></code> and <code><a href="#topic+tfsm_lambda">tfsm_lambda</a></code> 
functions. Elasticity analysis is also available using the <code><a href="#topic+elas">elas</a></code> function. 
Sensitivity analysis of transient dynamics is available using the <code><a href="#topic+tfs_inertia">tfs_inertia</a></code> 
and <code><a href="#topic+tfsm_inertia">tfsm_inertia</a></code> functions.
Methods for nonlinear perturbation (transfer function) analysis of asymptotic 
dynamics is achieved using <code><a href="#topic+tfa_lambda">tfa_lambda</a></code> and <code><a href="#topic+tfam_lambda">tfam_lambda</a></code>, 
whilst transfer function analysis of transient dynamics is available with 
<code><a href="#topic+tfa_inertia">tfa_inertia</a></code> and <code><a href="#topic+tfam_inertia">tfam_inertia</a></code>. These all have 
associated plotting methods linked to them: see <code><a href="#topic+plot.tfa">plot.tfa</a></code> and 
<code><a href="#topic+plot.tfam">plot.tfam</a></code>).
</p>
</dd>
<dt>MODEL CONVERGENCE</dt><dd>
<p>Information on the convergence of populations to stable state can be useful, and
<code>popdemo</code> provides several means of analysing convergence.
<code><a href="#topic+dr">dr</a></code> measures the damping ratio, and there are several distance measures available
(see <code><a href="#topic+KeyfitzD">KeyfitzD</a></code>, <code><a href="#topic+projectionD">projectionD</a></code> and 
<code><a href="#topic+CohenD">CohenD</a></code>).  There is also a means of calculating convergence time
through simulation: <code><a href="#topic+convt">convt</a></code>.
</p>
</dd>
<dt>DIAGNOSTIC TOOLS</dt><dd>
<p><code><a href="#topic+isPrimitive">isPrimitive</a></code>, <code><a href="#topic+isIrreducible">isIrreducible</a></code> and
<code><a href="#topic+isErgodic">isErgodic</a></code> facilitate diagnosis of matrix properties
pertaining to ergodicity.
</p>
</dd>
<dt>UTILITIES</dt><dd>
<p><code><a href="#topic+Matlab2R">Matlab2R</a></code> allows coding of matrices in a Matlab style, which
also facilitates import of multiple matrices simultaneously if comma-seperated
files are used to import dataframes. Its analogue, <code><a href="#topic+R2Matlab">R2Matlab</a></code>,
converts <span class="rlang"><b>R</b></span> matrices to Matlab-style strings, for easier export.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Iain Stott <a href="mailto:iainmstott@gmail.com">iainmstott@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Dave Hodgson <a href="mailto:D.J.Hodgson@exeter.ac.uk">D.J.Hodgson@exeter.ac.uk</a>
</p>
</li>
<li><p> Stuart Townley <a href="mailto:S.B.Townley@exeter.ac.uk">S.B.Townley@exeter.ac.uk</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Stephen Ellner <a href="mailto:spe2@cornell.edu">spe2@cornell.edu</a> [contributor]
</p>
</li></ul>


<hr>
<h2 id='blockmatrix'>Block-permute a reducible matrix</h2><span id='topic+blockmatrix'></span>

<h3>Description</h3>

<p>Conjugate a reducible matrix into block upper triangular form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockmatrix(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockmatrix_+3A_a">A</code></td>
<td>
<p>a square, reducible, non-negative numeric matrix of any dimension</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any square, reducible, non-negative matrix may have its rows and columns 
conjugated so that it takes a block upper triangular structure, with 
irreducible square submatrices on the diagonal, zero submatrices in the 
lower triangle and non-negative submatrices in the upper triangle (Caswell 
2001; Stott et al. 2010). <code>blockmatrix</code> permutes the rows and columns 
of a reducible matrix into this form, which enables further evaluation (e.g. 
computation of eigenvalues of submatrices).
</p>


<h3>Value</h3>

<p>a list containing components:
</p>

<dl>
<dt><code>blockmatrix</code></dt><dd><p> the block-permuted matrix. </p>
</dd>
<dt><code>stage.order</code></dt><dd><p> the permutation of rows/columns of <code>A</code> in the
block-permuted matrix. </p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Caswell (2001) Matrix population models 2nd ed. Sinauer.
</p>
</li>
<li><p> Stott et al. (2010) Methods. Ecol. Evol., 1, 242-252.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  # Create a 3x3 reducible PPM
  A &lt;- matrix(c(0,1,0,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3)
  dimnames(A) &lt;- list(c("Juv", "Pre-R", "R"), c("Juv", "Pre-R", "R"))
  A

  # Block-permute the matrix
  blockmatrix(A)

</code></pre>

<hr>
<h2 id='CohenD'>Calculate Cohen's cumulative distance</h2><span id='topic+CohenD'></span>

<h3>Description</h3>

<p>Calculate Cohen's cumulative distance metric for a population matrix 
projection model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CohenD(A, vector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CohenD_+3A_a">A</code></td>
<td>
<p>a square, irreducible, non-negative numeric matrix of any dimension.</p>
</td></tr>
<tr><td><code id="CohenD_+3A_vector">vector</code></td>
<td>
<p>a numeric vector or one-column matrix describing the age/stage 
distribution used to calculate the distance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the cumulative distance metric as outlined in Cohen (1979). 
Will not work for reducible matrices and returns a warning for imprimitive 
matrices (although will not function for imprimitive matrices with nonzero 
imaginary components in the dominant eigenpair).
</p>


<h3>Value</h3>

<p>Cohen's D1.
</p>


<h3>References</h3>


<ul>
<li><p> Cohen (1979) SIAM J. Appl. Math., 36, 169-175.
</p>
</li>
<li><p> Stott et al. (2011) Ecol. Lett., 14, 959-970.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other DistanceMeasures: 
<code><a href="#topic+KeyfitzD">KeyfitzD</a>()</code>,
<code><a href="#topic+projectionD">projectionD</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a 3x3 PPM
  ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Create an initial stage structure
  ( initial &lt;- c(1,3,2) )

  # Calculate Cohen cumulative distance
  CohenD(A, vector=initial)

</code></pre>

<hr>
<h2 id='convt'>Calculate time to convergence</h2><span id='topic+convt'></span>

<h3>Description</h3>

<p>Calculate the time to convergence of a population matrix projection model
from the model projection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convt(A, vector = "n", accuracy = 0.01, iterations = 1e+05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convt_+3A_a">A</code></td>
<td>
<p>a square, non-negative numeric matrix of any dimension</p>
</td></tr>
<tr><td><code id="convt_+3A_vector">vector</code></td>
<td>
<p>(optional) a numeric vector or one-column matrix describing 
the age/stage distribution used to calculate the projection.</p>
</td></tr>
<tr><td><code id="convt_+3A_accuracy">accuracy</code></td>
<td>
<p>the accuracy with which to determine convergence on 
asymptotic growth, expressed as a proportion (see details).</p>
</td></tr>
<tr><td><code id="convt_+3A_iterations">iterations</code></td>
<td>
<p>the maximum number of iterations of the model before the 
code breaks.  For slowly-converging models and/or high specified convergence
accuracy, this may need to be increased.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>convt</code> works by simulating the given model and manually 
determining growth when convergence to the given <code>accuracy</code> is reached. 
Convergence on an asymptotic growth is deemed to have been reached when the 
growth of the model stays within the window determined by <code>accuracy</code> for 
10*s iterations of the model, with s equal to the dimension of <code>A</code>. For 
example, projection of an 8 by 8 matrix with convergence accuracy of 1e-2 is 
deemed to have converged on asymptotic growth when 10*8=80 consecutive 
iterations of the model have a growth within 1-1e-2=0.99 (i.e. 99%) and 
1+1e-2=1.01 (i.e. 101%) of each other.
</p>
<p>If <code>vector</code> is specified, the convergence time of the projection of 
<code>vector</code> through <code>A</code> is returned. If <code>vector="n"</code> then 
asymptotic growths of the set of 'stage-biased' vectors are calculated. These 
projections are achieved using a set of standard basis vectors equal in number 
to the dimension of <code>A</code>. These have every element equal to 0, except for 
a single element equal to 1, i.e. for a matrix of dimension 3, the set of 
stage-biased vectors are: <code>c(1,0,0)</code>, <code>c(0,1,0)</code> and 
<code>c(0,0,1)</code>.
</p>
<p>Due to the way in which convergence is defined, <code>convt</code> can 
only properly work for strongly ergodic models. Therefore, it will not 
function for imprimitive (therefore potentially weakly ergodic) or reducible 
(therefore potentially nonergodic) models.
</p>


<h3>Value</h3>

<p>If <code>vector</code> is specified, the convergence time of <code>vector</code> projected
through <code>A</code>.
</p>
<p>If <code>vector</code> is not specified, a numeric vector of convergence times for 
corresponding stage-biased projections: the length of the vector is equal to 
the dimension of <code>A</code>; the first entry is the convergence time of 
[1,0,0,...], the second entry is the convergence time of [0,1,0,...], etc.).
</p>


<h3>References</h3>


<ul>
<li><p> Stott et al. (2011) Ecol. Lett., 14, 959-970.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other ConvergenceMeasures: 
<code><a href="#topic+dr">dr</a>()</code>,
<code><a href="#topic+truelambda">truelambda</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # Create a 3x3 PPM
 ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

 # Create an initial stage structure
 ( initial &lt;- c(1,3,2) )

 # Calculate the convergence time of the 3 stage-biased 
 # populations within 0.1% of lambda-max
 ( convt(A, accuracy=1e-3) )

 # Calculate the convergence time of the projection of initial and A
 # to within 0.001% of lambda-max
 ( convt(A, vector=initial, accuracy=1e-5) )

</code></pre>

<hr>
<h2 id='dr'>Calculate damping ratio</h2><span id='topic+dr'></span>

<h3>Description</h3>

<p>Calculate the damping ratio of a given population matrix projection model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dr(A, return.time = FALSE, x = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dr_+3A_a">A</code></td>
<td>
<p>a square, irreducible, non-negative numeric matrix of any dimension.</p>
</td></tr>
<tr><td><code id="dr_+3A_return.time">return.time</code></td>
<td>
<p>(optional) a logical argument determining whether an 
estimated convergence time should be returned.</p>
</td></tr>
<tr><td><code id="dr_+3A_x">x</code></td>
<td>
<p>(optional) the logarithm used in determining estimated time to 
convergence (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The damping ratio is calculated as the ratio of the dominant eigenvalue to 
the modulus of the largest subdominant eigenvalue. Time to convergence can 
be estmimated by calculating <code>log(dr)/log(x)</code>, which is the time taken 
for the dominant eigenvalue to become <code>x</code> times larger than the largest 
subdominant eigenvalue.
</p>


<h3>Value</h3>

<p>If <code>return.time=FALSE</code>, the damping ratio of <code>A</code>.<br />
If <code>return.time=TRUE</code>, a list containing components:
</p>

<dl>
<dt>dr</dt><dd><p>the damping ratio of <code>A</code></p>
</dd>
<dt>t</dt><dd><p>the estimated time to convergence.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Caswell (2001) Matrix Population Models 2nd. ed. Sinauer.
</p>
</li>
<li><p> Stott et al. (2010) Ecol. Lett., 14, 959-970.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other ConvergenceMeasures: 
<code><a href="#topic+convt">convt</a>()</code>,
<code><a href="#topic+truelambda">truelambda</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a 3x3 PPM
  A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3)

  # Calculate damping ratio
  dr(A)

  # Calculate damping ratio and time to convergence using a 
  # multiple of 10
  dr(A, return.time=TRUE, x=10)

</code></pre>

<hr>
<h2 id='eigs'>Calculate asymptotic growth</h2><span id='topic+eigs'></span>

<h3>Description</h3>

<p>Dominant eigenstuff of a population matrix projection model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigs(A, what = "all", check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigs_+3A_a">A</code></td>
<td>
<p>a square, nonnegative numeric matrix of any dimension.</p>
</td></tr>
<tr><td><code id="eigs_+3A_what">what</code></td>
<td>
<p>what components of the dominant eigenstuff should be returned. 
A character vector, which may include:
</p>

<dl>
<dt><code>"lambda"</code></dt><dd><p>the dominant eigenvalue (lambda)</p>
</dd>
<dt><code>"ss"</code></dt><dd><p>the dominant right eigenvector (stable stage)</p>
</dd>
<dt><code>"rv"</code></dt><dd><p>the dominant left eigenvector (reproductive value)</p>
</dd>
</dl>

<p>the default, <code>"all"</code>, returns all of the above.</p>
</td></tr>
<tr><td><code id="eigs_+3A_check">check</code></td>
<td>
<p>(logical) determines whether the dominant eigenvalue is 
checked for nonzero imaginary component, and largest absolute value. If
either of these occur, then the dominant eigenvalue may not be described as 
truly dominant.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>eigs</code> gives the dominant eigenstuff of a population projection model. 
This includes the dominant eigenvalue (asymptotic population growth), the 
dominant right eigenvector (stable age/stage distribution), and the dominant
left eigenvector (reproductive value). The dominant eigenvalue is the 
eigenvalue with the largest real component, and the dominant eigenvectors are 
the eigenvectors that correspond to this eigenvalue. If the matrix is 
reducible, then there may be other real or complex eigenvalues whose absolute
value are equal in magnitude to that of the dominant eigenvalue. In this case,
<code>eigs</code> returns the first one, and gives a warning &quot;More than one eigenvalues 
have equal absolute magnitude&quot;, for information.
</p>


<h3>Value</h3>

<p>A list with possible components that depends on the contents of <code>what</code>:
</p>

<dl>
<dt>lambda</dt><dd> 
<p>the dominant eigenvalue, which describes asymptotic population growth (if A 
is primitive; see <code><a href="#topic+isPrimitive">isPrimitive</a></code>). A real, nonnegative numeric 
vector of length 1. 
</p>
</dd>
<dt>ss</dt><dd>
<p>the dominant right eigenvector, which describes the stable age/stage structure
(if <code>A</code> is primitive; see <code><a href="#topic+isPrimitive">isPrimitive</a></code>). A real, nonnegative 
numeric vector equal to the dimension of <code>A</code> in length, scaled to sum to 1.
</p>
</dd>
<dt>rv</dt><dd>
<p>the dominant left eigenvector, which describes the reproductive value (if 
<code>A</code> is primitive; see <code><a href="#topic+isPrimitive">isPrimitive</a></code>). A real, nonnegative 
numeric vector equal to the dimension of <code>A</code> in length, scaled so that 
rv
</p>
</dd>
</dl>

<p>If only one of these components is returned, then the value is not a list, but 
a single numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # load the desert tortoise data
  data(Tort)
  
  # find the dominant eigenvalue
  eigs(Tort, "lambda")
  
  #find the stable stage structure
  eigs(Tort, "ss")
  
  #find the reproductive value
  eigs(Tort, "rv")
  
  #find both dominant eigenvectors
  eigs(Tort, c("ss","rv"))
  
  #find all eigenstuff
  eigs(Tort)

</code></pre>

<hr>
<h2 id='elas'>Calculate elasticity matrix</h2><span id='topic+elas'></span>

<h3>Description</h3>

<p>Calculate the elasticity matrix for a specified population matrix projection 
model using eigenvectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elas(A, eval = "max")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elas_+3A_a">A</code></td>
<td>
<p>a square, non-negative numeric matrix of any dimension</p>
</td></tr>
<tr><td><code id="elas_+3A_eval">eval</code></td>
<td>
<p>the eigenvalue to evaluate. Default is <code>eval="max"</code>, which 
evaluates the dominant eigenvalue (the eigenvalue with largest REAL value: 
for imprimitive or reducible matrices this may not be the first eigenvalue). 
Otherwise, specifying e.g. <code>eval=2</code> will evaluate elasticity of the 
eigenvalue with second-largest modulus.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>elas</code> uses the eigenvectors of <code>A</code> to calculate the elasticity 
matrix of the specified eigenvalue, see section 9.1 in Caswell (2001). 
Same method as <code>elasticity</code> in <code>popbio</code> but can also evaluate
subdominant eigenvalues.
</p>


<h3>Value</h3>

<p>A numeric (real or complex) matrix of equal dimension to <code>A</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Caswell (2001) Matrix Population Models 2nd ed. Sinauer.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other PerturbationAnalyses: 
<code><a href="#topic+sens">sens</a>()</code>,
<code><a href="#topic+tfa_inertia">tfa_inertia</a>()</code>,
<code><a href="#topic+tfa_lambda">tfa_lambda</a>()</code>,
<code><a href="#topic+tfam_inertia">tfam_inertia</a>()</code>,
<code><a href="#topic+tfam_lambda">tfam_lambda</a>()</code>,
<code><a href="#topic+tfs_inertia">tfs_inertia</a>()</code>,
<code><a href="#topic+tfs_lambda">tfs_lambda</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a 3x3 PPM
  ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Calculate sensitivities of dominant eigenvalue
  elas(A)
  # Calculate sensitivities of first subdominant eigenvalue,
  # only for observed transitions
  elas(A, eval=2)

</code></pre>

<hr>
<h2 id='inertia'>Calculate population inertia</h2><span id='topic+inertia'></span>

<h3>Description</h3>

<p>Calculate population inertia for a population matrix projection model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inertia(A, vector = "n", bound = NULL, return.N = FALSE, t = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inertia_+3A_a">A</code></td>
<td>
<p>a square, primitive, irreducible, non-negative numeric matrix of any 
dimension</p>
</td></tr>
<tr><td><code id="inertia_+3A_vector">vector</code></td>
<td>
<p>(optional) a numeric vector or one-column matrix describing 
the age/stage distribution ('demographic structure') used to calculate a 
'case-specific' maximal amplification</p>
</td></tr>
<tr><td><code id="inertia_+3A_bound">bound</code></td>
<td>
<p>(optional) specifies whether an upper or lower bound should be 
calculated (see details).</p>
</td></tr>
<tr><td><code id="inertia_+3A_return.n">return.N</code></td>
<td>
<p>(optional) if <code>TRUE</code>, returns population size for a 
specified <code>t</code> (including effects of asymptotic growth and initial 
population size), alongside standardised inertia.</p>
</td></tr>
<tr><td><code id="inertia_+3A_t">t</code></td>
<td>
<p>(optional) the projection interval at which <code>N</code> is to be 
calculated.  Calculation of <code>N</code> is only accurate for <code>t</code> where the 
model has converged (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A nonstable population, when it achieves asymptotic growth following transient 
dynamics, is a fixed ratio of the size of a population projected with the same
initial size but stable structure. <code>inertia</code> calculates the value of this
ratio (Koons et al. 2007)
</p>
<p>If <code>vector="n"</code> then either <code>bound="upper"</code> or <code>bound="lower"</code>
must be specified, which calculate the upper or lower bound on population 
inertia (i.e. the largest and smallest values that inertia may take) 
respectively. Specifying <code>vector</code> overrides calculation of a bound, and 
will yield a 'case-specific' value for inertia.
</p>
<p><code>inertia</code> will not work with imprimitive or reducible matrices.
</p>


<h3>Value</h3>

<p>If <code>vector="n"</code>, the upper bound on inertia of <code>A</code> if 
<code>bound="upper"</code> and the lower bound on inertia of <code>A</code> if 
<code>bound="lower"</code>.<br />
If <code>vector</code> is specified, the case-specific inertia of the model.<br />
If <code>return.N=TRUE</code> and <code>t</code> is specified, a list with components:
</p>

<dl>
<dt>inertia</dt><dd><p>the bound on or case-specific inertia</p>
</dd>
<dt>N</dt><dd><p>the population size at specified <code>t</code>.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Koons et al. (2007) Ecology, 88, 2867-2867.
</p>
</li>
<li><p> Stott et al. (2011) Ecol. Lett., 14, 959-970.
</p>
</li></ul>



<h3>See Also</h3>

<p>Transfer function methods for inertia: <code><a href="#topic+inertia.tfa">inertia.tfa</a></code>, 
<code><a href="#topic+inertia.tfamatrix">inertia.tfamatrix</a></code>, <code><a href="#topic+inertia.tfsens">inertia.tfsens</a></code>, 
<code><a href="#topic+inertia.tfsensmatrix">inertia.tfsensmatrix</a></code>
</p>
<p>Other TransientIndices: 
<code><a href="#topic+Kreiss">Kreiss</a>()</code>,
<code><a href="#topic+maxamp">maxamp</a>()</code>,
<code><a href="#topic+maxatt">maxatt</a>()</code>,
<code><a href="#topic+reac">reac</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a 3x3 PPM
  ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Create an initial stage structure
  ( initial &lt;- c(1,3,2) )

  # Calculate the upper bound on inertia of A
  inertia(A,bound="upper")

  # Calculate the lower bound on inertia of A
  inertia(A,bound="lower")

  # Calculate case-specific inertia of A and initial
  inertia(A, vector=initial)

  # Calculate case-specific inertia of A and initial and 
  # return realised population size at t=25
  inertia(A, vector=initial, return.N=TRUE, t=25)

</code></pre>

<hr>
<h2 id='isErgodic'>Determine ergodicity of a matrix</h2><span id='topic+isErgodic'></span>

<h3>Description</h3>

<p>Determine whether a matrix is ergodic or nonergodic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isErgodic(A, digits = 12, return.eigvec = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isErgodic_+3A_a">A</code></td>
<td>
<p>a square, non-negative numeric matrix of any dimension.</p>
</td></tr>
<tr><td><code id="isErgodic_+3A_digits">digits</code></td>
<td>
<p>the number of digits that the dominant left eigenvector should 
be rounded to.</p>
</td></tr>
<tr><td><code id="isErgodic_+3A_return.eigvec">return.eigvec</code></td>
<td>
<p>(optional) logical argument determining whether or not 
the dominant left eigenvector should be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>isErgodic</code> works on the premise that a matrix is ergodic if 
and only if the dominant left eigenvector (the reproductive value vector) of 
the matrix is positive (Stott et al. 2010).
</p>
<p>In rare cases, <span class="rlang"><b>R</b></span> may calculate that the dominant left eigenvector of a 
nonergodic matrix contains very small entries that are approximate to (but 
not equal to) zero.  Rounding the dominant eigenvector using <code>digits</code> 
prevents mistakes.
</p>


<h3>Value</h3>

<p>If <code>return.eigvec=FALSE</code>, either <code>TRUE</code> (for an ergodic matrix) or 
<code>FALSE</code> (for a nonergodic matrix).
</p>
<p>If <code>return.eigvec=TRUE</code>, a list containing elements:
</p>

<dl>
<dt><code>ergodic</code></dt><dd> <p><code>TRUE</code> or <code>FALSE</code>, as above </p>
</dd>
<dt><code>eigvec</code></dt><dd><p> the dominant left eigenvector of <code>A</code> </p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Stott et al. (2010) Methods Ecol. Evol., 1, 242-252.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other PerronFrobeniusDiagnostics: 
<code><a href="#topic+isIrreducible">isIrreducible</a>()</code>,
<code><a href="#topic+isPrimitive">isPrimitive</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a 3x3 ergodic PPM
  ( A &lt;- matrix(c(0,0,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Diagnose ergodicity
  isErgodic(A)

  # Create a 3x3 nonergodic PPM
  B&lt;-A; B[3,2] &lt;- 0; B

  # Diagnose ergodicity and return left eigenvector
  isErgodic(B, return.eigvec=TRUE)

</code></pre>

<hr>
<h2 id='isIrreducible'>Determine reducibility of a matrix</h2><span id='topic+isIrreducible'></span>

<h3>Description</h3>

<p>Determine whether a matrix is irreducible or reducible
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isIrreducible(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isIrreducible_+3A_a">A</code></td>
<td>
<p>a square, non-negative numeric matrix of any dimension.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>isIrreducible</code> works on the premise that a matrix <strong>A</strong> 
is irreducible if and only if (<strong>I</strong>+<strong>A</strong>)^(s-1) is positive, 
where <strong>I</strong> is the identity matrix of the same dimension as <strong>A</strong> 
and s is the dimension of <strong>A</strong> (Caswell 2001).
</p>


<h3>Value</h3>

<p><code>TRUE</code> (for an irreducible matrix) or <code>FALSE</code> (for a reducible 
matrix).
</p>


<h3>References</h3>


<ul>
<li><p> Caswell (2001) matrix Population Models, 2nd. ed. Sinauer.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other PerronFrobeniusDiagnostics: 
<code><a href="#topic+isErgodic">isErgodic</a>()</code>,
<code><a href="#topic+isPrimitive">isPrimitive</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a 3x3 irreducible PPM
  ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Diagnose reducibility
  isIrreducible(A)

  # Create a 3x3 reducible PPM
  B&lt;-A; B[3,2] &lt;- 0; B

  # Diagnose reducibility
  isIrreducible(B)

</code></pre>

<hr>
<h2 id='isPrimitive'>Determine primitivity of a matrix</h2><span id='topic+isPrimitive'></span>

<h3>Description</h3>

<p>Determine whether a matrix is primitive or imprimitive
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isPrimitive(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isPrimitive_+3A_a">A</code></td>
<td>
<p>a square, non-negative numeric matrix of any dimension.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>isPrimitive</code> works on the premise that a matrix <strong>A</strong> is 
primitive if <strong>A</strong>^(s^2-(2*s)+2) is positive, where s is the dimension 
of <strong>A</strong> (Caswell 2001).
</p>


<h3>Value</h3>

<p><code>TRUE</code> (for an primitive matrix) or <code>FALSE</code> (for an imprimitive 
matrix).
</p>


<h3>References</h3>


<ul>
<li><p> Caswell (2001) matrix Population Models, 2nd. ed. Sinauer.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other PerronFrobeniusDiagnostics: 
<code><a href="#topic+isErgodic">isErgodic</a>()</code>,
<code><a href="#topic+isIrreducible">isIrreducible</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a 3x3 primitive PPM
  ( A &lt;- matrix(c(0,1,2,0.5,0,0,0,0.6,0), byrow=TRUE, ncol=3) )

  # Diagnose primitivity
  isPrimitive(A)

  # Create a 3x3 imprimitive PPM
  B&lt;-A; B[1,2] &lt;- 0; B

  # Diagnose primitivity
  isPrimitive(B)

</code></pre>

<hr>
<h2 id='KeyfitzD'>Calculate Keyfitz's delta</h2><span id='topic+KeyfitzD'></span>

<h3>Description</h3>

<p>Calculate Keyfitz's delta for a population matrix projection model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KeyfitzD(A, vector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KeyfitzD_+3A_a">A</code></td>
<td>
<p>a square, irreducible, non-negative numeric matrix of any dimension.</p>
</td></tr>
<tr><td><code id="KeyfitzD_+3A_vector">vector</code></td>
<td>
<p>a numeric vector or one-column matrix describing the age/stage 
distribution used to calculate the distance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Keyfitz's delta is the sum of the differences between the stable demographic 
vector (the dominant right eigenvector of <code>A</code>) and the demographic 
distribution vector of the population (given by <code>vector</code>). 
<code>KeyfitzD</code> will not work for reducible matrices and returns a 
warning for imprimitive matrices (although will not function for imprimitive 
matrices with nonzero imaginary components in the dominant eigenpair).
</p>


<h3>Value</h3>

<p>Keyfitz's delta.
</p>


<h3>References</h3>


<ul>
<li><p> Keyfitz (1968) Introduction to the Mathematics of Populations. Addison-Wesley.
</p>
</li>
<li><p> Stott et al. (2010) Ecol. Lett., 14, 959-970.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other DistanceMeasures: 
<code><a href="#topic+CohenD">CohenD</a>()</code>,
<code><a href="#topic+projectionD">projectionD</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a 3x3 PPM
  ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Create an initial stage structure
  ( initial &lt;- c(1,3,2) )
  
  # Calculate Keyfitz's delta
  KeyfitzD(A, vector=initial)

</code></pre>

<hr>
<h2 id='Kreiss'>Calculate Kreiss bounds</h2><span id='topic+Kreiss'></span>

<h3>Description</h3>

<p>Calculate the upper or lower Kreiss bound for a population matrix projection 
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kreiss(
  A,
  bound = NULL,
  return.r = FALSE,
  theta = 1,
  rlimit = 100,
  step1 = 0.001,
  step2 = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kreiss_+3A_a">A</code></td>
<td>
<p>a square, irreducible, non-negative numeric matrix of any dimension</p>
</td></tr>
<tr><td><code id="Kreiss_+3A_bound">bound</code></td>
<td>
<p>(optional) specifies whether an upper or lower bound should be 
calculated.</p>
</td></tr>
<tr><td><code id="Kreiss_+3A_return.r">return.r</code></td>
<td>
<p>(optional) specifies whether the value of r at which the 
Kreiss bound is achieved should be returned (see details).</p>
</td></tr>
<tr><td><code id="Kreiss_+3A_theta">theta</code></td>
<td>
<p>the value to which the Kriess bound is to be assessed relative 
to (see details).</p>
</td></tr>
<tr><td><code id="Kreiss_+3A_rlimit">rlimit</code></td>
<td>
<p>the maximum value of r that may be reached before the code 
breaks (see details).</p>
</td></tr>
<tr><td><code id="Kreiss_+3A_step1">step1</code>, <code id="Kreiss_+3A_step2">step2</code></td>
<td>
<p>determine the iterative process in calculating the Kreiss 
bound (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Kreiss</code> by default returns a standardised Kreiss bound relative to both 
asymptotic growth/decline and initial population density (Townley &amp; Hodgson 2008; 
Stott et al. 2011).  It uses an iterative process that evaluates a function of 
the resolvent of <code>A</code> over a range of values r where r&gt;<code>theta</code>. This 
iterative process finds the maximum/minimum of the function for the upper/lower 
bounds respectively. The process is determined using <code>step1</code> and 
<code>step2</code>: in order to increase accuracy but keep computation time low, the 
function is evaluated forward in steps equal to <code>step1</code> until the 
maximum/minimum is passed and then backward in steps of <code>step2</code> to more 
accurately find the maximum/minimum itself. Therefore, <code>step1</code> should be 
larger than <code>step2</code>. The balance between both will determine computation 
time, whilst accuracy is determined almost solely by <code>step2</code>. The defaults 
should be sufficient for most matrices.
</p>
<p><code>theta</code> defaults to 1, which means the Kriess bound is assessed relative to 
both asymptotic growth and initial population size. Sometimes, the maximum/minimum 
of the function occurs at r&ndash;&gt;<code>theta</code>, in which case r is equal to 
<code>theta+step2</code>. Setting <code>return.r=TRUE</code> tells the function to return the 
value of r where the maximum/minimum occurs alongside the value of the Kreiss bound. 
r may not exceed <code>rlimit</code>.
</p>
<p><code>Kreiss</code> will not work with reducible matrices, and returns a warning for 
imprimitive matrices.
</p>


<h3>Value</h3>

<p>The upper or lower Kreiss bound of <code>A</code>.<br />
If <code>return.r=TRUE</code>, a list with components:
</p>

<dl>
<dt>bound</dt><dd><p>the upper or lower Kriess bound</p>
</dd>
<dt>r</dt><dd><p>the value of r at which the function is minimised/maximised.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Stott et al. (2011) Ecol. Lett., 14, 959-970.
</p>
</li>
<li><p> Townley &amp; Hodgson (2008) J. Appl. Ecol., 45, 1836-1839.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other TransientIndices: 
<code><a href="#topic+inertia">inertia</a>()</code>,
<code><a href="#topic+maxamp">maxamp</a>()</code>,
<code><a href="#topic+maxatt">maxatt</a>()</code>,
<code><a href="#topic+reac">reac</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a 3x3 PPM
  ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Calculate the upper Kreiss bound of A
  Kreiss(A, bound="upper")

  # Calculate the lower Kreiss bound of A
  Kreiss(A, bound="lower")

  # Calculate the upper Kreiss bound of A and return 
  # the value of r at which the function is maximised
  Kreiss(A, bound="upper", return.r=TRUE)

</code></pre>

<hr>
<h2 id='Matlab2R'>Read Matlab style matrices into R</h2><span id='topic+Matlab2R'></span>

<h3>Description</h3>

<p>Read a matrix coded in a Matlab style into <span class="rlang"><b>R</b></span> to create an object of class
matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Matlab2R(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Matlab2R_+3A_m">M</code></td>
<td>
<p>an object of class character that represents a numeric matrix coded 
in a Matlab style.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Matlab reads matrices using a unique one-line notation that can prove useful 
for storage in databases and importing multiple matrices into a program at 
once, amongst other applications. This notation is by row, with &quot;[&quot; and &quot;]&quot; 
to specify the beginning and end of the matrix respectively, &quot;;&quot; to specify a 
new row and a space between each matrix element. Thus, the <span class="rlang"><b>R</b></span> matrix created 
using <code>matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3)</code> is 
equivalent to [0 1 2;0.5 0.1 0;0 0.6 0.6].
</p>
<p><code>Matlab2R</code> takes a Matlab-coded matrix expressed as a character string 
and converts it into an <span class="rlang"><b>R</b></span> object of class matrix. As well as providing a 
simpler means of matrix notation in <span class="rlang"><b>R</b></span>, it also enables simultaneous import of 
multiple matrices of varying dimensions, using comma-seperated dataframes and 
tables.
</p>


<h3>Value</h3>

<p>An object of class matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+R2Matlab">R2Matlab</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a 3x3 PPM using Matlab2R
  ( A&lt;-Matlab2R("[0 1 2;0.5 0.1 0;0 0.6 0.6]") )

</code></pre>

<hr>
<h2 id='maxamp'>Calculate maximal amplification</h2><span id='topic+maxamp'></span>

<h3>Description</h3>

<p>Calculate maximal amplification for a population matrix projection model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxamp(
  A,
  vector = "n",
  return.N = FALSE,
  return.t = FALSE,
  return.stage = FALSE,
  conv.iterations = 1e+05,
  conv.accuracy = 1e-05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxamp_+3A_a">A</code></td>
<td>
<p>a square, primitive, non-negative numeric matrix of any dimension</p>
</td></tr>
<tr><td><code id="maxamp_+3A_vector">vector</code></td>
<td>
<p>(optional) a numeric vector or one-column matrix describing 
the age/stage distribution ('demographic structure') used to calculate a 
'case-specific' maximal amplification.</p>
</td></tr>
<tr><td><code id="maxamp_+3A_return.n">return.N</code></td>
<td>
<p>(optional) if <code>TRUE</code>, returns population size at the 
point of maximal amplification (including effects of asymptotic growth and 
initial population size), alongside standardised maximal amplification.</p>
</td></tr>
<tr><td><code id="maxamp_+3A_return.t">return.t</code></td>
<td>
<p>(optional) if <code>TRUE</code>, returns the time at which maximal 
amplification occurs in the population projection.</p>
</td></tr>
<tr><td><code id="maxamp_+3A_return.stage">return.stage</code></td>
<td>
<p>(optional) if <code>TRUE</code> and <code>vector="n"</code>, returns 
the stage that achieves the bound on maximal amplification.</p>
</td></tr>
<tr><td><code id="maxamp_+3A_conv.iterations">conv.iterations</code></td>
<td>
<p>the maximum number of iterations allowed when calulating 
convergence time (see details). Please see <code>iterations</code> in 
<code><a href="#topic+convt">convt</a></code>.</p>
</td></tr>
<tr><td><code id="maxamp_+3A_conv.accuracy">conv.accuracy</code></td>
<td>
<p>the accuracy of convergence (see details). Please see 
<code>accuracy</code> in <code><a href="#topic+convt">convt</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>maxamp</code> returns a standardised measure of maximal amplification, 
discounting the effects of both initial population size and asymoptotic growth 
(Stott et al. 2011).
</p>
<p>If <code>vector</code> is not specified then the bound on maximal amplification (the 
largest maximal amplification that may be achieved) is returned, otherwise a 
'case-specific' maximal amplification for the specified matrix and demographic 
structure is calculated. Note that not all demographic structures will yield a 
maximal amplification: if the model does not amplify then an error is returned.
</p>
<p>Setting <code>return.N=T</code>, <code>return.t=T</code> and <code>return.stage=T</code> results in 
the function returning realised population size at maximal amplification 
(including the effects of asymptotic growth and initial population size), the 
time at which maximal amplification occurs and (if <code>vector="n"</code>), 
the stage-bias that results in the bound on maximal amplification, respectively.
NOTE that <code>N</code> is not indicative of maximum possible population size for a 
non-standardised model: merely the population size at the point of maximal 
amplification (i.e. largest positive deviation from lambda-max).
</p>
<p><code>max.amp</code> uses a simulation technique, using <code><a href="#topic+project">project</a></code> to project 
the dynamics of the model before evaluating maximum projected density over all t. 
<code>conv.accuracy</code> and <code>conv.iterations</code> are passed to 
<code><a href="#topic+convt">convt</a></code>, which is used to find the point of model convergence 
in order to ensure maximal amplification is correctly captured in model projection.
</p>
<p><code>maxamp</code> will not work for imprimitive or reducible matrices.
</p>


<h3>Value</h3>

<p>If <code>vector="n"</code>, the bound on maximal amplification of <code>A</code>.<br />
If <code>vector</code> is specified, the case-specific maximal amplification of the model.<br />
If <code>return.N=TRUE</code>, <code>return.t=TRUE</code> and/or <code>return.stage=TRUE</code>,
a list with possible components:<br />
</p>

<dl>
<dt>maxamp</dt><dd><p>the bound on or case-specific maximal amplification</p>
</dd>
<dt>N</dt><dd><p>the population size at the point of maximal amplification, including the 
effects of initial population size and asymptotic growth. NOTE that <code>N</code> is not 
indicative of maximum possible population size for a non-standardised model:
merely the population size at the point of maximal amplification (i.e. largest 
positive deviation from lambda-max).</p>
</dd>
<dt>t</dt><dd><p>the projection interval at which maximal amplification is achieved.</p>
</dd>
<dt>stage</dt><dd><p>(only if <code>vector="n"</code>), the stage that achieves the bound on 
maximal amplification.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Neubert &amp; Caswell (1997) Ecology, 78, 653-665.
</p>
</li>
<li><p> Stott et al. (2011) Ecol. Lett., 14, 959-970.
</p>
</li>
<li><p> Townley &amp; Hodgson (2008) J. Appl. Ecol., 45, 1836-1839.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other TransientIndices: 
<code><a href="#topic+Kreiss">Kreiss</a>()</code>,
<code><a href="#topic+inertia">inertia</a>()</code>,
<code><a href="#topic+maxatt">maxatt</a>()</code>,
<code><a href="#topic+reac">reac</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a 3x3 PPM
  ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Create an initial stage structure
  ( initial &lt;- c(1,3,2) )

  # Calculate the bound on maximal amplification of A
  maxamp(A)

  # Calculate the bound on maximal amplification of A and 
  # return the stage that achieves it
  maxamp(A, return.stage=TRUE)

  # Calculate case-specific maximal amplification of A
  # and initial
  maxamp(A, vector=initial)

  # Calculate case-specific maximal amplification of A
  # and initial and return realised population size and the 
  # time at which it is achieved
  maxamp(A, vector=initial, return.N=TRUE, return.t=TRUE)

</code></pre>

<hr>
<h2 id='maxatt'>Calculate maximal attenuation</h2><span id='topic+maxatt'></span>

<h3>Description</h3>

<p>Calculate maximal attenuation for a population matrix projection model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxatt(
  A,
  vector = "n",
  return.N = FALSE,
  return.t = FALSE,
  return.stage = FALSE,
  conv.iterations = 1e+05,
  conv.accuracy = 1e-05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxatt_+3A_a">A</code></td>
<td>
<p>a square, primitive, non-negative numeric matrix of any dimension</p>
</td></tr>
<tr><td><code id="maxatt_+3A_vector">vector</code></td>
<td>
<p>(optional) a numeric vector or one-column matrix describing 
the age/stage distribution ('demographic structure') used to calculate a 
'case-specific' maximal attenuation</p>
</td></tr>
<tr><td><code id="maxatt_+3A_return.n">return.N</code></td>
<td>
<p>(optional) if <code>TRUE</code>, returns population size at the 
point of maximal attenuation (including effects of asymptotic growth and 
initial population size), alongside standardised maximal attenuation.</p>
</td></tr>
<tr><td><code id="maxatt_+3A_return.t">return.t</code></td>
<td>
<p>(optional) if <code>TRUE</code>, returns the time at which maximal 
attenuation occurs in the population projection.</p>
</td></tr>
<tr><td><code id="maxatt_+3A_return.stage">return.stage</code></td>
<td>
<p>(optional) if <code>TRUE</code> and <code>vector="n"</code>, returns 
the stage that achieves the bound on maximal attenuation.</p>
</td></tr>
<tr><td><code id="maxatt_+3A_conv.iterations">conv.iterations</code></td>
<td>
<p>the maximum number of iterations allowed when calulating 
convergence time (see details). Please see <code>iterations</code> in 
<code><a href="#topic+convt">convt</a></code>.</p>
</td></tr>
<tr><td><code id="maxatt_+3A_conv.accuracy">conv.accuracy</code></td>
<td>
<p>the accuracy of convergence (see details). Please see 
<code>accuracy</code> in <code><a href="#topic+convt">convt</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>maxatt</code> returns a standardised measure of maximal attenuation, 
discounting the effects of both initial population size and asymoptotic growth 
(Stott et al. 2011).
</p>
<p>If <code>vector</code> is not specified then the bound on maximal attenuation (the 
greatest maximal attenuation that may be achieved) is returned, otherwise a 
'case-specific' maximal attenuation for the specified matrix and demographic 
structure is calculated. Note that not all demographic structures will yield a 
maximal attenuation: if the model does not amplify then an error is returned.
</p>
<p>Setting <code>return.N=T</code>, <code>return.t=T</code> and <code>return.stage=T</code> results in 
the function returning realised population size at maximal attenuation 
(including the effects of asymptotic growth and initial population size), the 
time at which maximal attenuation occurs and (if <code>vector="n"</code>), 
the stage-bias that results in the bound on maximal attenuation, respectively.
NOTE that <code>N</code> is not indicative of minuium possible population size for a 
non-standardised model: merely the population size at the point of maximal 
attenuation (i.e. largest negative deviation from lambda-max).
</p>
<p><code>max.att</code> uses a simulation technique, using <code><a href="#topic+project">project</a></code> to project 
the dynamics of the model before evaluating minimum projected density over all t. 
<code>conv.accuracy</code> and <code>conv.iterations</code> are passed to 
<code><a href="#topic+convt">convt</a></code>, which is used to find the point of model convergence 
in order to ensure maximal attenuation is correctly captured in model projection.
</p>
<p><code>maxatt</code> will not work for imprimitive or reducible matrices.
</p>


<h3>Value</h3>

<p>If <code>vector="n"</code>, the bound on maximal attenuation of <code>A</code>.<br />
If <code>vector</code> is specified, the case-specific maximal attenuation of the model.<br />
If <code>return.N=TRUE</code>, <code>return.t=TRUE</code> and/or <code>return.stage=TRUE</code>,
a list with possible components:<br />
</p>

<dl>
<dt>maxatt</dt><dd><p>the bound on or case-specific maximal attenuation</p>
</dd>
<dt>N</dt><dd><p>the population size at the point of maximal attenuation, including the 
effects of initial population size and asymptotic growth. NOTE that <code>N</code> is not 
indicative of minimum possible population size for a non-standardised model:
merely the population size at the point of maximal attenuation (i.e. largest 
negative deviation from lambda-max).</p>
</dd>
<dt>t</dt><dd><p>the projection interval at which maximal attenuation is achieved.</p>
</dd>
<dt>stage</dt><dd><p>(only if <code>vector="n"</code>), the stage that achieves the bound on 
maximal attenuation.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Neubert &amp; Caswell (1997) Ecology, 78, 653-665.
</p>
</li>
<li><p> Stott et al. (2011) Ecol. Lett., 14, 959-970.
</p>
</li>
<li><p> Townley &amp; Hodgson (2008) J. Appl. Ecol., 45, 1836-1839.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other TransientIndices: 
<code><a href="#topic+Kreiss">Kreiss</a>()</code>,
<code><a href="#topic+inertia">inertia</a>()</code>,
<code><a href="#topic+maxamp">maxamp</a>()</code>,
<code><a href="#topic+reac">reac</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a 3x3 PPM
  ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Create an initial stage structure
  ( initial &lt;- c(3,1,1) )

  # Calculate the bound on maximal attenuation of A
  maxatt(A)

  # Calculate the bound on maximal attenuation of A and 
  # return the stage that achieves it
  maxatt(A, return.stage=TRUE)

  # Calculate case-specific maximal attenuation of A
  # and initial
  maxatt(A, vector=initial)

  # Calculate case-specific maximal attenuation of A
  # and initial and return realised population size and the 
  # time at which it is achieved
  maxatt(A, vector=initial, return.N=TRUE, return.t=TRUE)

</code></pre>

<hr>
<h2 id='Pbear'>Polar bear matrices</h2><span id='topic+Pbear'></span>

<h3>Description</h3>

<p>Matrix projection model for the polar bear <em>Ursus maritimus</em>, with 
5 matrices corresponding to years 2001-2005. The matrices are based on a 
population in the southern Beaufort Sea. During 2001-2003, ice conditions were
classified as &quot;good&quot;, but in 2004-2005, ice conditions were classified as 
&quot;poor&quot;. Poor ice conditions lead to worse population performance. Stages are 
based on age and 
reproductive status:<br />
Stage-1: 2-year-old<br />
Stage 2: 3-year-old<br />
Stage 3: 4-year-old<br />
Stage 4: adult (5+ years old), available to breed<br />
Stage 5: adult, with cub (0-1 years old)<br />
Stage 6: adult, with yearling (1-2 years old).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Pbear)
</code></pre>


<h3>Format</h3>

<p>List object containing matrices.
</p>


<h3>Details</h3>

<p>The population structure is 
<code>c(0.106, 0.068, 0.106, 0.461, 0.151, 0.108))</code>
</p>


<h3>References</h3>


<ul>
<li><p> Hunter et al. (2010) Ecology, 91, 2883-2897.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  #read in data
  data(Pbear)
  Pbear

</code></pre>

<hr>
<h2 id='plot.tfa'>Plot transfer function</h2><span id='topic+plot.tfa'></span>

<h3>Description</h3>

<p>Plot a transfer function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tfa'
plot(x, xvar = NULL, yvar = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.tfa_+3A_x">x</code></td>
<td>
<p>an object of class 'tfa' (transfer function analysis) created using 
<code><a href="#topic+tfa_lambda">tfa_lambda</a></code> or <code><a href="#topic+tfa_inertia">tfa_inertia</a></code>.</p>
</td></tr>
<tr><td><code id="plot.tfa_+3A_xvar">xvar</code>, <code id="plot.tfa_+3A_yvar">yvar</code></td>
<td>
<p>(optional) the variables to plot on the x and y axes. May
be <code>"p"</code>, <code>"lambda"</code> or <code>"inertia"</code>. Defaults to
<code>xvar="p"</code> and <code>yvar="lambda"</code> for objects created using
<code>tfa_lambda</code> and <code>xvar="p"</code> and <code>yvar="inertia"</code> for 
objects created using <code>tfa_inertia</code>.</p>
</td></tr>
<tr><td><code id="plot.tfa_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods: see <code><a href="graphics.html#topic+par">par</a></code> and
<code><a href="#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.tfa</code> plots transfer functions (class <code>tfa</code>) created using 
<code><a href="#topic+tfa_lambda">tfa_lambda</a></code> or <code><a href="#topic+tfa_inertia">tfa_inertia</a></code>.
</p>


<h3>See Also</h3>

<p>Constructor functions: <code><a href="#topic+tfa_lambda">tfa_lambda</a></code>, <code><a href="#topic+tfa_inertia">tfa_inertia</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a 3x3 matrix
  ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Calculate the transfer function of A[3,2] given a range of lambda
  evals &lt;- eigen(A)$values
  lmax &lt;- which.max(Re(evals))
  lambda &lt;- Re(evals[lmax])
  lambdarange &lt;- seq(lambda-0.1, lambda+0.1, 0.01)
  ( transfer &lt;- tfa_lambda(A, d=c(0,0,1), e=c(0,1,0), lambdarange=lambdarange) )

  # Plot the transfer function
  plot(transfer)

  # Create an initial stage structure
  ( initial &lt;- c(1,3,2) )

  # Calculate the transfer function of upper bound on inertia 
  # given a perturbation to A[3,2]
  ( transfer&lt;-tfa_inertia(A, d=c(0,0,1), e=c(0,1,0), bound="upper",
                          prange=seq(-0.6,0.4,0.01)) )

  # Plot the transfer function (defaults to inertia ~ p)
  plot(transfer)

  # Plot inertia against lambda
  plot(transfer, xvar="lambda", yvar="inertia")

</code></pre>

<hr>
<h2 id='plot.tfam'>Plot transfer function</h2><span id='topic+plot.tfam'></span>

<h3>Description</h3>

<p>Plot a matrix of transfer functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tfam'
plot(x, xvar = NULL, yvar = NULL, mar = c(1.1, 1.1, 0.1, 0.1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.tfam_+3A_x">x</code></td>
<td>
<p>an object of class 'tfam' (transfer function analysis matrix) 
created using <code><a href="#topic+tfam_lambda">tfam_lambda</a></code> or <code><a href="#topic+tfam_inertia">tfam_inertia</a></code>.</p>
</td></tr>
<tr><td><code id="plot.tfam_+3A_xvar">xvar</code>, <code id="plot.tfam_+3A_yvar">yvar</code></td>
<td>
<p>(optional) the variables to plot on the x and y axes. May
be <code>"p"</code>, <code>"lambda"</code> or <code>"inertia"</code>. Defaults to
<code>xvar="p"</code> and <code>yvar="lambda"</code> for objects created using
<code>tfam_lambda</code>, and <code>xvar="p"</code> and <code>yvar="inertia"</code> for 
objects created using codetfam_inertia.</p>
</td></tr>
<tr><td><code id="plot.tfam_+3A_mar">mar</code></td>
<td>
<p>the margin limits on the plots: see <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plot.tfam_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods: see <code><a href="graphics.html#topic+par">par</a></code> and
<code><a href="#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.tfam</code> plots matrices of transfer functions (class 
<code>tfam</code>) created using <code><a href="#topic+tfam_lambda">tfam_lambda</a></code> or 
<code><a href="#topic+tfam_inertia">tfam_inertia</a></code>. The plot is laid out to correspond with 
the nonzero entries of the matrix used to generate the transfer functions, 
for easy visual comparison of how perturbation affects different matrix 
elements.
</p>


<h3>See Also</h3>

<p>Constructor functions: <code><a href="#topic+tfam_lambda">tfam_lambda</a></code>, <code><a href="#topic+tfam_inertia">tfam_inertia</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a 3x3 matrix
  ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Calculate the matrix of transfer functions using default arguments
  ( tfmat&lt;-tfam_lambda(A) )

  # Plot the matrix of transfer functions
  plot(tfmat)

  # Create an initial stage structure
  ( initial &lt;- c(1,3,2) )

  # Calculate the matrix of transfer functions for inertia and 
  # specified initial stage structure using default arguments
  ( tfmat2&lt;-tfam_inertia(A,vector=initial) )

  # Plot the result (defaults to inertia ~ p)
  plot(tfmat2)

  # Plot inertia ~ lambda
  plot(tfmat2, xvar="lambda", yvar="inertia")

</code></pre>

<hr>
<h2 id='popdemo-deprecated'>Deprecated functions in the popdemo package</h2><span id='topic+popdemo-deprecated'></span><span id='topic+Cohen.cumulative'></span><span id='topic+Cohen.cumulative-deprecated'></span><span id='topic+convergence.time'></span><span id='topic+convergence.time-deprecated'></span><span id='topic+inertia.tfa'></span><span id='topic+inertia.tfa-deprecated'></span><span id='topic+inertia.tfamatrix'></span><span id='topic+inertia.tfamatrix-deprecated'></span><span id='topic+inertia.tfsens'></span><span id='topic+inertia.tfsens-deprecated'></span><span id='topic+inertia.tfsensmatrix'></span><span id='topic+inertia.tfsensmatrix-deprecated'></span><span id='topic+is.matrix_ergodic'></span><span id='topic+is.matrix_ergodic-deprecated'></span><span id='topic+is.matrix_irreducible'></span><span id='topic+is.matrix_irreducible-deprecated'></span><span id='topic+is.matrix_primitive'></span><span id='topic+is.matrix_primitive-deprecated'></span><span id='topic+Keyfitz.delta'></span><span id='topic+Keyfitz-delta-deprecated'></span><span id='topic+projection.distance'></span><span id='topic+projection.distance-deprecated'></span><span id='topic+tfa'></span><span id='topic+tfa-deprecated'></span><span id='topic+tfamatrix'></span><span id='topic+tfamatrix-deprecated'></span><span id='topic+tfsens'></span><span id='topic+tfsens-deprecated'></span><span id='topic+tfsensmatrix'></span><span id='topic+tfsensmatrix-deprecated'></span><span id='topic+minCS'></span><span id='topic+minCS-deprecated'></span><span id='topic+tf'></span><span id='topic+tf-deprecated'></span><span id='topic+reactivity'></span><span id='topic+reactivity-deprecated'></span><span id='topic+firststepatt'></span><span id='topic+firststepatt-deprecated'></span>

<h3>Description</h3>

<p>Deprecated functions in the popdemo package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cohen.cumulative(...)
convergence.time(...)
inertia.tfa(...)
inertia.tfamatrix(...)
inertia.tfsens(...)
inertia.tfsensmatrix(...)
is.matrix_ergodic(...)
is.matrix_irreducible(...)
is.matrix_primitive(...)
Keyfitz.delta(...)
projection.distance(...)
tfa(...)
tfamatrix(...)
tfsens(...)
tfsensmatrix(...)
minCS(...)
reactivity(...)
firststepatt(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popdemo-deprecated_+3A_...">...</code></td>
<td>
<p>Parameters to be passed to the new function versions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Many functions have become deprecated as of popdemo_1.0-0 (meaning they will stop
working at some point in the future). In most cases, this is because 
functions needed to be re-named. For now the older function names will 
work but issue a warning, but you should use the new function names wherever possible.
Please update your code, and I'm sorry for the inconvenience!
</p>

<dl>
<dt>Avoiding S3 troubles</dt><dd>
<p>Most deprecated functions needed to be renamed because they included a period 
in the function name: the new function names don't use periods, which is a 
better approach for playing nicely with the S3 object-oriented system (see Hadley 
Wickham's <a href="http://adv-r.had.co.nz/OO-essentials.html">OO field guide</a> for more
info). These are:
</p>

<table>
<tr>
 <td style="text-align: right;">
  <code>Cohen.cumulative</code> </td><td style="text-align: left;"> now called <code>CohenD</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>convergence.time</code> </td><td style="text-align: left;"> now called <code>convt</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>inertia.tfa</code> </td><td style="text-align: left;"> now called <code>tfa_inertia</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>inertia.tfamatrix</code> </td><td style="text-align: left;"> now called <code>tfam_inertia</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>inertia.tfsens</code> </td><td style="text-align: left;"> now called <code>tfs_inertia</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>inertia.tfsensmatrix</code> </td><td style="text-align: left;"> now called <code>tfsm_inertia</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>is.matrix_ergodic</code> </td><td style="text-align: left;"> now called <code>isErgodic</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>is.matrix_irreducible</code> </td><td style="text-align: left;"> now called <code>isIrreducible</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>is.matrix_primitive</code> </td><td style="text-align: left;"> now called <code>isPrimitive</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>Keyfitz.delta</code> </td><td style="text-align: left;"> now called <code>KeyfitzD</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>projection.distance</code> </td><td style="text-align: left;"> now called <code>projectionD</code></td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

</dd>
<dt>Consistency</dt><dd>
<p>Some other functions have been renamed to keep consistency with new functions, 
and also to further avoid problems with S3 methods by making sure classes and 
functions don't have the same names:
</p>

<table>
<tr>
 <td style="text-align: right;">
  <code>tfa</code> </td><td style="text-align: left;"> now called <code>tfa_lambda</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>tfamatrix</code> </td><td style="text-align: left;"> now called <code>tfam_lambda</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>tfsens</code> </td><td style="text-align: left;"> now called <code>tfs_lambda</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>tfsensmatrix</code> </td><td style="text-align: left;"> now called <code>tfsm_lambda</code></td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

</dd>
<dt>Hidden functions</dt><dd>
<p>Some functions have been made internal (they're &quot;hidden&quot; but you can still 
use them):
</p>

<table>
<tr>
 <td style="text-align: right;">
  <code>minCS</code> </td><td style="text-align: left;"> now called <code>.minCS</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>tf</code> </td><td style="text-align: left;"> now called <code>.tf</code></td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

</dd>
<dt>Merged functions</dt><dd>
<p>Two functions are deprecated because they have been merged into one:
</p>

<table>
<tr>
 <td style="text-align: right;">
  <code>reactivity,firststepatt</code> </td><td style="text-align: left;"> now handled by <code><a href="#topic+reac">reac</a></code>.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p>Before, <code>reactivity</code> handled first-timestep amplification and 
<code>firststepatt</code> handled first-timestep attenuation. This is silly, because
a projection EITHER amplifies OR attenuates in the first timestep. Desptite 
the semantics, <code><a href="#topic+reac">reac</a></code> now deals with both amplification and attenuation
in the first timestep, everything that was calculable in the previous two
functions is also calculable in the one new function.
</p>
</dd>
</dl>


<hr>
<h2 id='project'>Project population dynamics</h2><span id='topic+project'></span>

<h3>Description</h3>

<p>Project dynamics of a specified population matrix projection model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project(
  A,
  vector = "n",
  time = 100,
  standard.A = FALSE,
  standard.vec = FALSE,
  return.vec = TRUE,
  Aseq = "unif",
  Astart = NULL,
  draws = 1000,
  alpha.draws = "unif",
  PREcheck = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_+3A_a">A</code></td>
<td>
<p>a matrix, or list of matrices. If <code>A</code> is a matrix, then 
<code>project</code> performs a 'deterministic' projection, where the matrix
does not change with each timestep. If <code>A</code> is a list of matrices, then 
<code>project</code> performs a 'stochastic' projection where the matrix varies 
with each timestep. The sequence of matrices is determined using <code>Aseq</code>. 
Matrices must be square, non-negative and numeric. If <code>A</code> is a list, 
all matrices must have the same dimension. 'Projection' objects inherit
names from <code>A</code>: if <code>A</code> is a matrix, stage names (in mat and 
vec slots) are inherited from its column names..</p>
</td></tr>
<tr><td><code id="project_+3A_vector">vector</code></td>
<td>
<p>(optional) a numeric vector or matrix describing 
the age/stage distribution(s) used to calculate the projection. Single
population vectors can be given either as a numeric vector or 
one-column matrix. Multiple vectors are specified as a matrix, where 
each column describes a single population vector. Therefore the number
of rows of the matrix should be equal to the matrix dimension, whilst the 
number of columns gives the number of vectors to project. <code>vector</code> may
also take either &quot;n&quot; (default) to calculate the set of stage-biased projections 
(see details), or &quot;diri&quot; to project random population vectors drawn from a 
dirichlet distribution (see details).</p>
</td></tr>
<tr><td><code id="project_+3A_time">time</code></td>
<td>
<p>the number of projection intervals.</p>
</td></tr>
<tr><td><code id="project_+3A_standard.a">standard.A</code></td>
<td>
<p>(optional) if <code>TRUE</code>, scales each matrix in <code>A</code>
by dividing all elements by the dominant eigenvalue. This standardises 
asymptotic dynamics: the dominant eigenvalue of the scaled matrix is 1. 
Useful for assessing transient dynamics.</p>
</td></tr>
<tr><td><code id="project_+3A_standard.vec">standard.vec</code></td>
<td>
<p>(optional) if <code>TRUE</code>, standardises each <code>vector</code> 
to sum to 1, by dividing each vector by its sum. Useful for assessing projection
relative to initial population size.</p>
</td></tr>
<tr><td><code id="project_+3A_return.vec">return.vec</code></td>
<td>
<p>(optional) if <code>TRUE</code>, returns the time series of 
demographic (st)age vectors as well as overall population size.</p>
</td></tr>
<tr><td><code id="project_+3A_aseq">Aseq</code></td>
<td>
<p>(optional, for stochastic projections only) the sequence of 
matrices in a stochastic projection. 
<code>Aseq</code> may be either:
</p>

<ul>
<li><p> &quot;unif&quot; (default), which results in every matrix in <code>A</code> having an 
equal, random chance of being chosen at each timestep.
</p>
</li>
<li><p> a square, nonnegative left-stochastic matrix describing a first-order 
Markov chain used to choose the matrices. The transitions are defined COLUMNWISE: 
each column j describes the probability of choosing stage (row) i at time t+1, 
given that stage (column) j was chosen at time t. <code>Aseq</code>  should have the 
same dimension as the number of matrices in <code>A</code>. 
</p>
</li>
<li><p> a numeric vector giving a specific sequence which corresponds to the
matrices in <code>A</code>.
</p>
</li>
<li><p> a character vector giving a specific sequence which corresponds to the
names of the matrices in <code>A</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="project_+3A_astart">Astart</code></td>
<td>
<p>(optional) in a stochastic projection, the matrix with which to
initialise the projection (either numeric, corresponding to the matrices in 
<code>A</code>, or character, corresponding to the names of matrices in <code>A</code>). 
When <code>Astart = NULL</code> (the default), a random initial matrix is chosen.</p>
</td></tr>
<tr><td><code id="project_+3A_draws">draws</code></td>
<td>
<p>if <code>vector="diri"</code>, the number of population vectors drawn
from dirichlet.</p>
</td></tr>
<tr><td><code id="project_+3A_alpha.draws">alpha.draws</code></td>
<td>
<p>if <code>vector="diri"</code>, the alpha values passed to 
<code>rdirichlet</code>: used to bias draws towards or away from a certain population
structure.</p>
</td></tr>
<tr><td><code id="project_+3A_precheck">PREcheck</code></td>
<td>
<p>many functions in <code>popdemo</code> first check Primitivity, 
Reducibility and/or Ergodicity of matrices, with associated warnings and/or 
errors if a matrix breaks any assumptions. Set <code>PREcheck=FALSE</code> if you
want to bypass these checks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>vector</code> is specified, <code>project</code> will calculate population 
dynamics through time by projecting this vector / these vectors through 
<code>A</code>. If multiple vectors are specified, a separate population projection
is calculated for each.
</p>
<p>If <code>vector="n"</code>, <code>project</code> will automatically project the set of 
'stage-biased' vectors of <code>A</code>. Effectively, each vector is a population
consisting of all individuals in one stage. These projections are achieved using a 
set of standard basis vectors equal in number to the dimension of <code>A</code>.
The vectors have every element equal to 0, except for a single element equal to 1,  
i.e. for a matrix of dimension 3, the set of stage-biased vectors are: 
<code>c(1,0,0)</code>, <code>c(0,1,0)</code> and <code>c(0,0,1)</code>. Stage-biased projections are 
useful for seeing how extreme transient dynamics can be.
</p>
<p>If <code>vector="diri"</code>, <code>project</code> draws random population vectors from 
the dirichlet distribution. <code>draws</code> gives the number of population vectors
to draw. <code>alpha.draws</code> gives the parameters for the dirichlet and can be
used to bias the draws towards or away from certain population structures.
The default is <code>alpha.draws="unif"</code>, which passes <code>rep(1,dim)</code> (where
dim is the dimension of the matrix), resulting in an equal probability of 
any random population vector. Relative values in the vector give the population
structure to focus the distribution on, and the absolute value of the vector
entries (and their sum) gives the strength of the distribution: values greater
than 1 make it more likely to draw from nearby that population structure, 
whilst values less than 1 make it less likely to draw from nearby that population
structure.
</p>
<p>Projections returned are of length <code>time+1</code>, as the first element 
represents the population at <code>t=0</code>.
</p>
<p>Projections have their own plotting method (see <code><a href="#topic+Projection-plots">Projection-plots</a></code>)
to enable easy graphing.
</p>
<p>In addition to the examples below, see the &quot;Deterministic population dynamics&quot; 
and &quot;Stochastic population dynamics&quot; vignettes for worked examples that use 
the <code>project</code> function.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+Projection-class">Projection-class</a></code> item. 
'Projection' objects inherit from a standard array, and can be treated as 
such. Therefore, if if <code>vector</code> is specified, the 'Projection' object will 
behave as: 
</p>

<ul>
<li><p> if a single <code>vector</code> is given, a numeric vector of population sizes 
of length <code>time+1</code>
</p>
</li>
<li><p> if multiple <code>vector</code>s are given, a numeric matrix of population 
projections where each column represents a single population projection and 
is of length <code>time+1</code>
</p>
</li>
<li><p> if <code>vector="n"</code>, a numeric matrix of population projections where each column 
represents a single stage-biased projection and is of length <code>time+1</code>.
</p>
</li>
<li><p> if <code>vector="diri"</code>, a numeric matrix of population projections where each 
column represents projection of a single vector draw and each column is of 
length <code>time+1</code>
</p>
</li></ul>

<p>See documentation on <code><a href="#topic+Projection-class">Projection-class</a></code> objects to understand how 
to access other slots (e.g. (st)age vectors through the population projection) 
and for S4 methods (e.g. plotting projections).
Some examples for understanding the structure of 3D arrays returned when 
<code>return.vec=TRUE</code>: when projecting a 3 by 3 matrix for &gt;10 time intervals 
(see examples), element [11,3,2] represents the density of stage 3 at time 10 
for either vector 2 (multiple vectors), stage-bias 2 (<code>vector="n"</code>) or draw 2 
(<code>vector="diri"</code>); note that because element 1 represents t=0, then t=10 
is found at element 11. The vector [,3,2] represents the time series of densities 
of stage 3 in the projection of vector 2 / stage-bias 2 / draw 2. The matrix [,,2] 
represents the time series of all stages in the projection of vector 2 / stage-bias 
2 / draw 2.
</p>
<p>Note that the projections inherit the labelling from <code>A</code> and <code>vector</code>, if
it exists. Both stage and vector names are taken from the COLUMN names of <code>A</code> 
and <code>vector</code> respectively. These may be useful for selecting from the
<code>projection</code> object, and for labelling graphs when plotting Projection
objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Projection-class">Projection-class</a></code> <code><a href="#topic+Projection-plots">Projection-plots</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ### USING PROJECTION OBJECTS

  # Create a 3x3 PPM
  ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Project stage-biased dynamics of A over 70 intervals
  ( pr &lt;- project(A, vector="n", time=70) )
  plot(pr)

  # Access other slots
  vec(pr)  #time sequence of population vectors
  bounds(pr)  #bounds on population dynamics
  mat(pr)  #matrix used to create projection
  Aseq(pr)  #sequence of matrices (more useful for stochastic projections)
  projtype(pr)  #type of projection
  vectype(pr)  #type of vector(s) initiating projection

  # Extra information on the projection
  nproj(pr)  #number of projections
  nmat(pr)  #number of matrices (more usefulk for stochastic projections)
  ntime(pr)  #number of time intervals
  
  # Select the projection of stage 2 bias
  pr[,2]

  # Project stage-biased dynamics of standardised A over 30 intervals
  ( pr2 &lt;- project(A, vector="n", time=30, standard.A=TRUE) )
  plot(pr2)

  #Select the projection of stage 2 bias
  pr2[,2]

  # Select the density of stage 3 in bias 2 at time 10
  vec(pr2)[11,3,2]

  # Select the time series of densities of stage 2 in bias 1
  vec(pr2)[,2,1]

  #Select the matrix of population vectors for bias 2
  vec(pr2)[,,2]

  # Create an initial stage structure
  ( initial &lt;- c(1,3,2) )

  # Project A over 50 intervals using a specified population structure
  ( pr3 &lt;- project(A, vector=initial, time=50) )
  plot(pr3)

  # Project standardised dynamics of A over 10 intervals using 
  # standardised initial structure and return demographic vectors
  ( pr4 &lt;- project(A, vector=initial, time=10, standard.vec=TRUE, 
                   standard.A=TRUE, return.vec=TRUE) )
  plot(pr4)

  # Select the time series for stage 1
  vec(pr4)[,1]

  ### DETERMINISTIC PROJECTIONS

  # Load the desert Tortoise matrix
  data(Tort)

  # Create an initial stage structure
  Tortvec1 &lt;- c(8, 7, 6, 5, 4, 3, 2, 1)
  
  # Create a projection over 30 time intervals
  ( Tortp1 &lt;- project(Tort, vector = Tortvec1, time = 10) )

  # plot p1
  plot(Tortp1)
  plot(Tortp1, bounds = TRUE) #with bounds
 
  # new display parameters
  plot(Tortp1, bounds = TRUE, col = "red", bty = "n", log = "y", 
       ylab = "Number of individuals (log scale)",
       bounds.args = list(lty = 2, lwd = 2) )

  # multiple vectors
  Tortvec2 &lt;- cbind(Tortvec1, c(1, 2, 3, 4, 5, 6, 7, 8))
  plot(project(Tort, vector = Tortvec2), log = "y")
  plot(project(Tort, vector = Tortvec2), log = "y", labs = FALSE) #no labels

  # dirichlet distribution 
  # darker shading indicates more likely population size
  Tortshade &lt;- project(Tort, time = 30, vector = "diri", standard.A = TRUE,
               draws = 500, alpha.draws = "unif")
  plot(Tortshade, plottype = "shady", bounds = TRUE)
  
  ### STOCHASTIC PROJECTIONS
  # load polar bear data
  data(Pbear)
  
  # project over 50 years with uniform matrix selection
  Pbearvec &lt;- c(0.106, 0.068, 0.106, 0.461, 0.151, 0.108)
  p2 &lt;- project(Pbear, Pbearvec, time = 50, Aseq = "unif")

  # stochastic projection information
  Aseq(p2)
  projtype(p2)
  nmat(p2)
  
  # plot
  plot(p2, log = "y")
  
</code></pre>

<hr>
<h2 id='Projection-class'>'Projection' object S4 class</h2><span id='topic+Projection-class'></span><span id='topic+Projection'></span><span id='topic+vec'></span><span id='topic+vec+2CProjection-method'></span><span id='topic+bounds'></span><span id='topic+bounds+2CProjection-method'></span><span id='topic+mat'></span><span id='topic+mat+2CProjection-method'></span><span id='topic+Aseq'></span><span id='topic+Aseq+2CProjection-method'></span><span id='topic+projtype'></span><span id='topic+projtype+2CProjection-method'></span><span id='topic+vectype'></span><span id='topic+vectype+2CProjection-method'></span><span id='topic+nproj'></span><span id='topic+nproj+2CProjection-method'></span><span id='topic+nmat'></span><span id='topic+nmat+2CProjection-method'></span><span id='topic+ntime'></span><span id='topic+ntime+2CProjection-method'></span><span id='topic+show'></span><span id='topic+show+2CProjection-method'></span>

<h3>Description</h3>

<p>Projection objects are created using the <code><a href="#topic+project">project</a></code> function. 
Primarily, they contain overall population size over time: they can be 
treated as a vector (single population projection) or matrix (multiple 
population projections; see information on slot &quot;.Data&quot; below). They also 
contain further information on the population projection. These extra pieces 
of information are described below in the &quot;Slots&quot; section, and the methods 
for accessing them appear below. These are:
</p>

<dl>
<dt><code>vec</code></dt><dd><p> access population vectors</p>
</dd>
<dt><code>bounds</code></dt><dd><p> access bounds on population dynamics</p>
</dd>
<dt><code>mat</code></dt><dd><p> access projection matrix/matrices used to create projection(s)</p>
</dd>
<dt><code>Aseq</code></dt><dd><p> access projection matrix sequence used to create projection(s)</p>
</dd>
<dt><code>projtype</code></dt><dd><p> find out projection type</p>
</dd>
<dt><code>vectype</code></dt><dd><p> access type of vector used to initiate population projection(s)</p>
</dd>
</dl>

<p>Other methods for accessing basic information from the projection are:
</p>

<dl>
<dt><code>nproj</code></dt><dd><p> access projection matrix/matrices used to create projection</p>
</dd>
<dt><code>nmat</code></dt><dd><p> number of projection matrices used to create projection(s)</p>
</dd>
<dt><code>ntime</code></dt><dd><p> number of time intervals</p>
</dd>
</dl>

<p>Plotting and display methods for 'Projection' objects can be found on the 
<code><a href="#topic+Projection-plots">Projection-plots</a></code> page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec(object)

## S4 method for signature 'Projection'
vec(object)

bounds(object)

## S4 method for signature 'Projection'
bounds(object)

mat(object, ...)

## S4 method for signature 'Projection'
mat(object, return = "simple")

Aseq(object)

## S4 method for signature 'Projection'
Aseq(object)

projtype(object)

## S4 method for signature 'Projection'
projtype(object)

vectype(object)

## S4 method for signature 'Projection'
vectype(object)

nproj(object)

## S4 method for signature 'Projection'
nproj(object)

nmat(object)

## S4 method for signature 'Projection'
nmat(object)

ntime(object)

## S4 method for signature 'Projection'
ntime(object)

show(object)

## S4 method for signature 'Projection'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Projection-class_+3A_object">object</code></td>
<td>
<p>an object of class &quot;Projection&quot; generated using <code><a href="#topic+project">project</a></code></p>
</td></tr>
<tr><td><code id="Projection-class_+3A_...">...</code></td>
<td>
<p>further arguments (see method, below)</p>
</td></tr>
<tr><td><code id="Projection-class_+3A_return">return</code></td>
<td>
<p>either &quot;simple&quot;, &quot;list&quot;, or &quot;array&quot;: used for accessing the 'mat'
slot from a Projection object. Note that only list or array can be used for 
stochastic projections, which have more than one matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition to the examples below, see the &quot;Deterministic population dynamics&quot; 
and &quot;Stochastic population dynamics&quot; vignettes for worked examples that use 
the 'Projection' objects.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code></dt><dd><p>One or more time series of population sizes. 
'Projection' objects inherit from a standard array, and can be treated as 
such. Therefore, if <code>vector</code> is specified, the 'Projection' object will 
behave as: 
</p>

<ul>
<li><p> if a single <code>vector</code> is given, a numeric vector of population sizes 
of length <code>time+1</code>
</p>
</li>
<li><p> if multiple <code>vector</code>s are given, a numeric matrix of population 
projections where each column represents a single population projection and 
is of length <code>time+1</code>
</p>
</li>
<li><p> if <code>vector="n"</code>, a numeric matrix of population projections where each column 
represents a single stage-biased projection and is of length <code>time+1</code>.
</p>
</li>
<li><p> if <code>vector="diri"</code>, a numeric matrix of population projections where each 
column represents projection of a single vector draw and each column is of 
length <code>time+1</code>.
</p>
</li></ul>
</dd>
<dt><code>vec</code></dt><dd><p>Age- or stage-based population vectors. <code>vec</code> 
will be:
</p>

<ul>
<li><p> If a single <code>vector</code> is specified, a numeric matrix of demographic 
vectors from projection of <code>vector</code> through <code>A</code>. Each column 
represents the densities of one life (st)age in the projection.
</p>
</li>
<li><p> If multiple <code>vector</code>s are specified, a three-dimensional array of
demographic vectors from projection of the set of initial vectors through
<code>A</code>. The first dimension represents time (and is therefore equal to 
<code>time+1</code>). The second dimension represents the densities of 
each stage (and is therefore equal to the dimension of <code>A</code>). 
The third dimension represents each individual projection (and is 
therefore equal to the number of initial vectors given).
</p>
</li>
<li><p> If <code>vector="n"</code>, a three-dimensional array of demographic vectors from
projection of the set of stage-biased vectors through <code>A</code>. The first 
dimension represents time (and is therefore equal to <code>time+1</code>). The 
second dimension represents the densities of each stage (and 
is therefore equal to the dimension of <code>A</code>). The third 
dimension represents each individual stage-biased projection (and is 
therefore also equal to the dimension of <code>A</code>).
</p>
</li>
<li><p> If<code>vector="diri"</code>, a three-dimensional array of demographic vectors from
projection of the dirichlet vector draws projected through <code>A</code>. The first 
dimension represents time (and is therefore equal to <code>time+1</code>). The second 
dimension represents the densities of each stage (and 
is therefore equal to the dimension of <code>A</code>). The third 
dimension represents projection of each population draw (and is therefore equal
to <code>draws</code>).
</p>
</li></ul>

<p>Some examples for understanding the structure of 3D arrays returned when 
<code>return.vec=TRUE</code>: when projecting a 3 by 3 matrix for &gt;10 time intervals, 
element [11,3,2] represents the density of stage 3 at time 10 
for either vector 2 (multiple vectors), stage-bias 2 (<code>vector="n"</code>) or draw 2 
(<code>vector="diri"</code>); note that because element 1 represents t=0, then t=10 
is found at element 11. The vector [,3,2] represents the time series of densities 
of stage 3 in the projection of vector 2 / stage-bias 2 / draw 2. The matrix [,,2] 
represents the time series of all stages in the projection of vector 2 / stage-bias 
2 / draw 2.
</p>
<p>Note that the projections inherit the labelling from <code>A</code> and <code>vector</code>, if
it exists. Both stage and vector names are taken from the COLUMN names of <code>A</code> 
and <code>vector</code> respectively. These may be useful for selecting from the
<code>projection</code> object, and are used when labelling plots of Projection 
objects containing multiple population projections.
</p>
<p>Set <code>return.vec = FALSE</code> when calling <code>project</code> to prevent population
vectors from being saved: in this case, <code>vec</code> is equal to 
<code>numeric(0)</code>. This may be necessary when projecting large numbers of
vectors, as is the case when <code>vector = "diri"</code>.</p>
</dd>
<dt><code>bounds</code></dt><dd><p>The bounds on population dynamics (only for deterministic 
projections). These represent the maximum and minimum population sizes 
achieveable at each time interval of the projection. <code>bounds</code> is a 
matrix with 2 columns (lower and upper bounds, in that order), and the 
number of rows is equal to <code>time + 1</code>.</p>
</dd>
<dt><code>mat</code></dt><dd><p>The matrix/matrices used in the population projection. In their 
raw form <code>mat</code> is always a three-dimensional array, where the third 
dimension is used to index the different matrices. However, by using the 
<code>mat()</code> accessor function below, it is possible to choose different ways
of representing the matrices (matrix, list, array).</p>
</dd>
<dt><code>Aseq</code></dt><dd><p>The sequence of matrices used in the projection. For deterministic
projections (where there is only 1 matrix) this will always be <code>rep(1, time)</code>.
For stochastic projections (with more than 1 matrix), if <code>Aseq</code> is given 
to <code>project</code> as a numeric or character vector then this slot will take 
that value. If a matrix describing a random markov process is passed, the 
<code>Aseq</code> slot will be a single random chain.</p>
</dd>
<dt><code>projtype</code></dt><dd><p>The type of projection. Either &quot;deterministic&quot; (single matrix; 
time-invariant), or &quot;stochastic&quot; (multiple matrices; time-varying).</p>
</dd>
<dt><code>vectype</code></dt><dd><p>The type of vector passed to <code>project</code>. May be &quot;single&quot; 
(one vector; one population projection), &quot;multiple&quot; (more than one vector; 
several population projections), &quot;bias&quot; (stage-biased vectors; 
<code>vector = "n"</code>), or &quot;diri&quot; (vectors drawn from the dirichlet 
distribution; <code>vector = "diri"</code>).</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+project">project</a></code> <code><a href="#topic+Projection-plots">Projection-plots</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ### USING PROJECTION OBJECTS

  # Create a 3x3 PPM
  ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Project stage-biased dynamics of A over 70 intervals
  ( pr &lt;- project(A, vector="n", time=70) )
  plot(pr)

  # Access other slots
  vec(pr)  #time sequence of population vectors
  bounds(pr)  #bounds on population dynamics
  mat(pr)  #matrix used to create projection
  Aseq(pr)  #sequence of matrices (more useful for stochastic projections)
  projtype(pr)  #type of projection
  vectype(pr)  #type of vector(s) initiating projection

  # Extra information on the projection
  nproj(pr)  #number of projections
  nmat(pr)  #number of matrices (more usefulk for stochastic projections)
  ntime(pr)  #number of time intervals
  
  # Select the projection of stage 2 bias
  pr[,2]

  # Project stage-biased dynamics of standardised A over 30 intervals
  ( pr2 &lt;- project(A, vector="n", time=30, standard.A=TRUE) )
  plot(pr2)

  #Select the projection of stage 2 bias
  pr2[,2]

  # Select the density of stage 3 in bias 2 at time 10
  vec(pr2)[11,3,2]

  # Select the time series of densities of stage 2 in bias 1
  vec(pr2)[,2,1]

  #Select the matrix of population vectors for bias 2
  vec(pr2)[,,2]

  # Create an initial stage structure
  ( initial &lt;- c(1,3,2) )

  # Project A over 50 intervals using a specified population structure
  ( pr3 &lt;- project(A, vector=initial, time=50) )
  plot(pr3)

  # Project standardised dynamics of A over 10 intervals using 
  # standardised initial structure and return demographic vectors
  ( pr4 &lt;- project(A, vector=initial, time=10, standard.vec=TRUE, 
                   standard.A=TRUE, return.vec=TRUE) )
  plot(pr4)

  # Select the time series for stage 1
  vec(pr4)[,1]

</code></pre>

<hr>
<h2 id='Projection-plots'>Plot methods for 'Projection' objects</h2><span id='topic+Projection-plots'></span><span id='topic+plot'></span><span id='topic+plot+2CProjection+2Cmissing-method'></span>

<h3>Description</h3>

<p>This page describes print and plot methods for <code><a href="#topic+Projection-class">Projection-class</a></code>. 
Example code is below, or worked examples using these methods are 
available in the &quot;Deterministic population dynamics&quot; and &quot;Stochastic 
population dynamics&quot; vignettes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot(x, y, ...)

## S4 method for signature 'Projection,missing'
plot(
  x,
  y,
  bounds = FALSE,
  bounds.args = NULL,
  labs = TRUE,
  plottype = "lines",
  ybreaks = 20,
  shadelevels = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Projection-plots_+3A_x">x</code></td>
<td>
<p>an object of class &quot;Projection&quot; generated using <code><a href="#topic+project">project</a></code></p>
</td></tr>
<tr><td><code id="Projection-plots_+3A_y">y</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="Projection-plots_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods: see <code><a href="graphics.html#topic+par">par</a></code> and
<code><a href="#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="Projection-plots_+3A_bounds">bounds</code></td>
<td>
<p>logical: indicates whether to plot the bounds on population density.</p>
</td></tr>
<tr><td><code id="Projection-plots_+3A_bounds.args">bounds.args</code></td>
<td>
<p>A list of graphical parameters for plotting the bounds if
<code>bounds=T</code>. The name of each list element indicates the name of the argument.
Could include, e.g. <code>list(lwd=2,lty=3,col="darkred")</code>.</p>
</td></tr>
<tr><td><code id="Projection-plots_+3A_labs">labs</code></td>
<td>
<p>logical: if <code>TRUE</code>, the plot includes more than one projection
and <code>plottype="lines"</code>, then lines are automatically labelled according to
the names contained in the 'projection' object.</p>
</td></tr>
<tr><td><code id="Projection-plots_+3A_plottype">plottype</code></td>
<td>
<p>for projections generated from dirichlet draws (see
<code><a href="#topic+project">project</a></code>), <code>plottype</code> has two options. <code>"lines"</code>
will plot each projection as a separate line. <code>"shady"</code> will
plot shaded contours showing the probabilities of population
densities over over time, calculated across the set of projections from
dirichlet draws. By default this shaded plot is a gradient of black to
white (with black representing higher probabilities), but this can be
overridden by using the 'col' argument (see examples).</p>
</td></tr>
<tr><td><code id="Projection-plots_+3A_ybreaks">ybreaks</code></td>
<td>
<p>if <code>plottype="shady"</code>, gives the number of breaks on
the y axis for generating the grid for the shade plot. A larger number of
breaks means a finer resolution grid for the shading.</p>
</td></tr>
<tr><td><code id="Projection-plots_+3A_shadelevels">shadelevels</code></td>
<td>
<p>if <code>plottype="shady"</code> and a palette of colours
is not specified using 'col', then <code>shadelevels</code> gives the number of
colour/shading levels to use when generating the black and white shade plot.
A larger number of levels means a finer resolution on the shade
plot of population density (see examples).</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><code>plot</code></dt><dd><p> plot a Projection object</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+project">project</a></code> <code><a href="#topic+Projection-class">Projection-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ### Desert tortoise matrix
  data(Tort)

  # Create an initial stage structure
  Tortvec1 &lt;- c(8, 7, 6, 5, 4, 3, 2, 1)
  
  # Create a projection over 30 time intervals
  ( Tortp1 &lt;- project(Tort, vector = Tortvec1, time = 10) )

  # plot p1
  plot(Tortp1)
  plot(Tortp1, bounds = TRUE) #with bounds
 
  # new display parameters
  plot(Tortp1, bounds = TRUE, col = "red", bty = "n", log = "y", 
       ylab = "Number of individuals (log scale)",
       bounds.args = list(lty = 2, lwd = 2) )

  # multiple vectors
  Tortvec2 &lt;- cbind(Tortvec1, c(1, 2, 3, 4, 5, 6, 7, 8))
  plot(project(Tort, vector = Tortvec2), log = "y")
  plot(project(Tort, vector = Tortvec2), log = "y", labs = FALSE) #no labels

  # dirichlet distribution 
  # darker shading indicates more likely population size
  Tortshade &lt;- project(Tort, time = 30, vector = "diri", standard.A = TRUE,
               draws = 500, alpha.draws = "unif")
  plot(Tortshade, plottype = "shady", bounds = TRUE)
  
  ### STOCHASTIC PROJECTIONS
  # load polar bear data
  data(Pbear)
  
  # project over 50 years with uniform matrix selection
  Pbearvec &lt;- c(0.106, 0.068, 0.106, 0.461, 0.151, 0.108)
  p2 &lt;- project(Pbear, Pbearvec, time = 50, Aseq = "unif")

  # stochastic projection information
  Aseq(p2)
  projtype(p2)
  nmat(p2)
  
  # plot
  plot(p2, log = "y")
  
  ### USING PROJECTION OBJECTS

  # Create a 3x3 PPM
  ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Project stage-biased dynamics of A over 70 intervals
  ( pr &lt;- project(A, vector="n", time=70) )
  plot(pr)

  # Access other slots
  vec(pr)  #time sequence of population vectors
  bounds(pr)  #bounds on population dynamics
  mat(pr)  #matrix used to create projection
  Aseq(pr)  #sequence of matrices (more useful for stochastic projections)
  projtype(pr)  #type of projection
  vectype(pr)  #type of vector(s) initiating projection

  # Extra information on the projection
  nproj(pr)  #number of projections
  nmat(pr)  #number of matrices (more usefulk for stochastic projections)
  ntime(pr)  #number of time intervals
  
  # Select the projection of stage 2 bias
  pr[,2]

  # Project stage-biased dynamics of standardised A over 30 intervals
  ( pr2 &lt;- project(A, vector="n", time=30, standard.A=TRUE) )
  plot(pr2)

  #Select the projection of stage 2 bias
  pr2[,2]

  # Select the density of stage 3 in bias 2 at time 10
  vec(pr2)[11,3,2]

  # Select the time series of densities of stage 2 in bias 1
  vec(pr2)[,2,1]

  #Select the matrix of population vectors for bias 2
  vec(pr2)[,,2]

  # Create an initial stage structure
  ( initial &lt;- c(1,3,2) )

  # Project A over 50 intervals using a specified population structure
  ( pr3 &lt;- project(A, vector=initial, time=50) )
  plot(pr3)

  # Project standardised dynamics of A over 10 intervals using 
  # standardised initial structure and return demographic vectors
  ( pr4 &lt;- project(A, vector=initial, time=10, standard.vec=TRUE, 
                   standard.A=TRUE, return.vec=TRUE) )
  plot(pr4)

  # Select the time series for stage 1
  vec(pr4)[,1]

  ### DETERMINISTIC PROJECTIONS

  # Load the desert Tortoise matrix
  data(Tort)

  # Create an initial stage structure
  Tortvec1 &lt;- c(8, 7, 6, 5, 4, 3, 2, 1)
  
  # Create a projection over 30 time intervals
  ( Tortp1 &lt;- project(Tort, vector = Tortvec1, time = 10) )

  # plot p1
  plot(Tortp1)
  plot(Tortp1, bounds = TRUE) #with bounds
 
  # new display parameters
  plot(Tortp1, bounds = TRUE, col = "red", bty = "n", log = "y", 
       ylab = "Number of individuals (log scale)",
       bounds.args = list(lty = 2, lwd = 2) )

  # multiple vectors
  Tortvec2 &lt;- cbind(Tortvec1, c(1, 2, 3, 4, 5, 6, 7, 8))
  plot(project(Tort, vector = Tortvec2), log = "y")
  plot(project(Tort, vector = Tortvec2), log = "y", labs = FALSE) #no labels

  # dirichlet distribution 
  # darker shading indicates more likely population size
  Tortshade &lt;- project(Tort, time = 30, vector = "diri", standard.A = TRUE,
               draws = 500, alpha.draws = "unif")
  plot(Tortshade, plottype = "shady", bounds = TRUE)
  
  ### STOCHASTIC PROJECTIONS
  # load polar bear data
  data(Pbear)
  
  # project over 50 years with uniform matrix selection
  Pbearvec &lt;- c(0.106, 0.068, 0.106, 0.461, 0.151, 0.108)
  p2 &lt;- project(Pbear, Pbearvec, time = 50, Aseq = "unif")

  # stochastic projection information
  Aseq(p2)
  projtype(p2)
  nmat(p2)
  
  # plot
  plot(p2, log = "y")

</code></pre>

<hr>
<h2 id='projectionD'>Calculate projection distance</h2><span id='topic+projectionD'></span>

<h3>Description</h3>

<p>Calculate projection distance for a population matrix projection model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projectionD(A, vector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projectionD_+3A_a">A</code></td>
<td>
<p>a square, irreducible, non-negative numeric matrix of any dimension.</p>
</td></tr>
<tr><td><code id="projectionD_+3A_vector">vector</code></td>
<td>
<p>a numeric vector or one-column matrix describing the age/stage 
distribution used to calculate the distance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>projectionD</code> (Haridas &amp; Tuljapurkar 2007) is the difference 
between the reproductive value of a population with demographic distribution 
given by <code>vector</code> and the reproductive value of a population in stable 
state.
</p>
<p><code>projectionD</code> will not work for reducible matrices and returns a 
warning for imprimitive matrices (although will not function for imprimitive 
matrices with nonzero imaginary components in the dominant eigenpair).
</p>


<h3>Value</h3>

<p>Projection distance.
</p>


<h3>References</h3>


<ul>
<li><p> Haridas &amp; Tuljapurkar (2007) Ecol. Lett., 10, 1143-1153.
</p>
</li>
<li><p> Stott et al. (2011) Ecol. Lett., 14, 959-970.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other DistanceMeasures: 
<code><a href="#topic+CohenD">CohenD</a>()</code>,
<code><a href="#topic+KeyfitzD">KeyfitzD</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a 3x3 PPM
  ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Create an initial stage structure
  ( initial &lt;- c(1,3,2) )

  # Calculate projection distance
  projectionD(A, vector=initial)

</code></pre>

<hr>
<h2 id='R2Matlab'>Convert matrices into Matlab style strings</h2><span id='topic+R2Matlab'></span>

<h3>Description</h3>

<p>Convert <span class="rlang"><b>R</b></span> objects of class matrix into character strings that represent the 
matrix in a Matlab style
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R2Matlab(A, noquote = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R2Matlab_+3A_a">A</code></td>
<td>
<p>a numeric matrix of any dimension</p>
</td></tr>
<tr><td><code id="R2Matlab_+3A_noquote">noquote</code></td>
<td>
<p>(optional) if <code>noquote=TRUE</code> then the returned character 
vector is printed without quotes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Matlab reads matrices using a unique one-line notation that can prove useful 
for storage in databases and importing multiple matrices into a program at 
once, amongst other applications.  This notation is by row, with &quot;[&quot; and &quot;]&quot; 
to specify the beginning and end of the matrix respectively, &quot;;&quot; to specify a 
new row and a space between each matrix element. Thus, the <span class="rlang"><b>R</b></span> matrix created 
using <code>matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3)</code> is 
equivalent to [0 1 2;0.5 0.1 0;0 0.6 0.6].
</p>
<p><code>R2Matlab</code> takes an <span class="rlang"><b>R</b></span> object of class matrix converts it into a 
Matlab-style character string that may be useful for exporting into databases.
</p>


<h3>Value</h3>

<p>Object of class character representing <code>A</code> in a Matlab style.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Matlab2R">Matlab2R</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a 3x3 PPM
  ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Code the matrix in a Matlab style
  R2Matlab(A)

  # Print without quotes
  R2Matlab(A, noquote=TRUE)

</code></pre>

<hr>
<h2 id='reac'>Calculate reactivity and first-timestep attenuation</h2><span id='topic+reac'></span>

<h3>Description</h3>

<p>Calculate reactivity (first-timestep amplification) and first-timestep 
attenuation for a population matrix projection model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reac(A, vector = "n", bound = NULL, return.N = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reac_+3A_a">A</code></td>
<td>
<p>a square, non-negative numeric matrix of any dimension</p>
</td></tr>
<tr><td><code id="reac_+3A_vector">vector</code></td>
<td>
<p>(optional) a numeric vector or one-column matrix describing 
the age/stage distribution used to calculate a 'case-specific' reactivity/
first-timestep attenuation</p>
</td></tr>
<tr><td><code id="reac_+3A_bound">bound</code></td>
<td>
<p>(optional) specifies whether an upper or lower bound should be 
calculated (see details).</p>
</td></tr>
<tr><td><code id="reac_+3A_return.n">return.N</code></td>
<td>
<p>(optional) if <code>TRUE</code>, returns population size in the 
first time interval (including effects of asymptotic growth and initial 
population size), alongside standardised reactivity/first-timestep attenuation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>reac</code> returns a standardised measure of first-timestep 
amplification or attenuation, discounting the effects of both initial 
population size and asymoptotic growth (Stott et al. 2011).
</p>
<p>If <code>vector</code>=&quot;n&quot; then either <code>bound="upper"</code> or <code>bound="lower"</code>
must be specified, which calculate the upper or lower bound on first-timestep
amplification and attenuation (i.e. the largest and smallest values that 
reactivity and first-timestep attenuation may take) respectively.
Specifying <code>vector</code> overrides calculation of a bound, and will yield 
a 'case-specific' reactivity/first-timestep attenuation.
</p>
<p>If <code>return.N=T</code> then the function also returns realised population size 
(including the effects of asymptotic growth and initial population size).
</p>
<p><code>reac</code> works with imprimitive and irreducible matrices, but 
returns a warning in these cases.
</p>
<p>NOTE: <code>reac</code> replaces <code>reactivity</code> and <code>firststepatt</code> as of 
version 1.0-0. Although semantically 'reactivity' and 'first-timestep 
attenuation' are different (the former is an amplification in the first timestep
and the latter an attenuation in the first timestep), as a population matrix 
projection model EITHER amplifies OR attenuates in the first timestep, it made 
no sense to have two separate functions to calculate one thing 
(transient dynamics in the first timestep).
</p>


<h3>Value</h3>

<p>If <code>vector="n"</code>, the upper bound on reactivity of <code>A</code> if 
<code>bound="upper"</code> and the lower bound on first-timestep attenuation of 
<code>A</code> if <code>bound="lower"</code>.<br />
If <code>vector</code> is specified, the 'case-specific' reactivity or first-timestep 
attenuation of the model.
</p>
<p>If <code>return.N=TRUE</code>, a list with components:
</p>

<dl>
<dt>reac</dt><dd><p>the bound on or case-specific reactivity or first-timestep 
attenuation</p>
</dd>
<dt>N</dt><dd><p>the population size at the first timestep, including the effects 
of initial population size and asymptotic growth.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Neubert &amp; Caswell (1997) Ecology, 78, 653-665.
</p>
</li>
<li><p> Stott et al. (2011) Ecol. Lett., 14, 959-970.
</p>
</li>
<li><p> Townley &amp; Hodgson (2008) J. Appl. Ecol., 45, 1836-1839.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other TransientIndices: 
<code><a href="#topic+Kreiss">Kreiss</a>()</code>,
<code><a href="#topic+inertia">inertia</a>()</code>,
<code><a href="#topic+maxamp">maxamp</a>()</code>,
<code><a href="#topic+maxatt">maxatt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a 3x3 PPM
  ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Create initial stage structures
  ( initial1 &lt;- c(1,3,2) )
  ( initial2 &lt;- c(3,1,1) )

  # Calculate the upper bound on reactivity of A
  reac(A, bound="upper")

  # Calculate the lower bound on first-timestep attenuation of A
  reac(A, bound="lower")

  # Calculate case-specific reactivity of A
  # when projected using specific demographic structure
  # that amplifies
  reac(A, vector=initial1)

  # Calculate case-specific reactivity of A
  # and initial1 and return realised population size
  reac(A, vector=initial1, return.N=TRUE)

  # Calculate case-specific first-timestep attenuation of A 
  # when projected using a specific demographic structure that
  #attenuates
  reac(A, vector=initial2)

  # Calculate case-specific first-timestep attenuation of A 
  # and initial2 and return realised population size
  reac(A, vector=initial2, return.N=TRUE)#'

</code></pre>

<hr>
<h2 id='sens'>Calculate sensitivity matrix</h2><span id='topic+sens'></span>

<h3>Description</h3>

<p>Calculate the sensitivity matrix for a population matrix projection model 
using eigenvectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sens(A, eval = "max", all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sens_+3A_a">A</code></td>
<td>
<p>a square, non-negative numeric matrix of any dimension</p>
</td></tr>
<tr><td><code id="sens_+3A_eval">eval</code></td>
<td>
<p>the eigenvalue to evaluate. Default is <code>eval="max"</code>, which 
evaluates the dominant eigenvalue (the eigenvalue with largest REAL value: 
for imprimitive or reducible matrices this may not be the first eigenvalue). 
Otherwise, specifying e.g. <code>eval=2</code> will evaluate sensitivity of the 
eigenvalue with second-largest modulus.</p>
</td></tr>
<tr><td><code id="sens_+3A_all">all</code></td>
<td>
<p>(optional) if <code>FALSE</code>, then only sensitivity values for 
observed transitions (nonzero entries in <code>A</code>) are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sens</code> uses the eigenvectors of <code>A</code> to calculate the sensitivity 
matrix of the specified eigenvalue, see section 9.1 in Caswell (2001). 
Same method as <code>sensitivity</code> in <code>popbio</code> but can also evaluate
subdominant eigenvalues.
</p>


<h3>Value</h3>

<p>A numeric (real or complex) matrix of equal dimension to <code>A</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Caswell (2001) Matrix Population Models 2nd ed. Sinauer.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other PerturbationAnalyses: 
<code><a href="#topic+elas">elas</a>()</code>,
<code><a href="#topic+tfa_inertia">tfa_inertia</a>()</code>,
<code><a href="#topic+tfa_lambda">tfa_lambda</a>()</code>,
<code><a href="#topic+tfam_inertia">tfam_inertia</a>()</code>,
<code><a href="#topic+tfam_lambda">tfam_lambda</a>()</code>,
<code><a href="#topic+tfs_inertia">tfs_inertia</a>()</code>,
<code><a href="#topic+tfs_lambda">tfs_lambda</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a 3x3 PPM
  ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Calculate sensitivities of dominant eigenvalue
  sens(A)
  # Calculate sensitivities of first subdominant eigenvalue,
  # only for observed transitions
  sens(A, eval=2, all=FALSE) 

</code></pre>

<hr>
<h2 id='stoch'>Project population dynamics</h2><span id='topic+stoch'></span>

<h3>Description</h3>

<p>Analyse long-term dynamics of a stochastic population matrix projection model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stoch(
  A,
  what = "all",
  Aseq = "unif",
  vector = NULL,
  Astart = NULL,
  iterations = 10000,
  discard = 1000,
  PREcheck = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stoch_+3A_a">A</code></td>
<td>
<p>a list of matrices. <code>stoch</code> uses <code><a href="#topic+project">project</a></code> to 
perform a stochastic' projection where the matrix varies with each timestep. 
The sequence of matrices is determined using <code>Aseq</code>. Matrices must be 
square, non-negative and numeric, and all matrices must have the same dimension.</p>
</td></tr>
<tr><td><code id="stoch_+3A_what">what</code></td>
<td>
<p>what should be returned. A character vector with possible entries
&quot;lambda&quot; (to calcualate stochastic growth), &quot;var&quot; (to calculate variance in 
stochastic growth) and/or &quot;all&quot; (to calculate both).</p>
</td></tr>
<tr><td><code id="stoch_+3A_aseq">Aseq</code></td>
<td>
<p>the sequence of matrices in a stochastic projection. 
<code>Aseq</code> may be either:
</p>

<ul>
<li><p> &quot;unif&quot; (default), which results in every matrix in <code>A</code> having an 
equal, random chance of being chosen at each timestep.
</p>
</li>
<li><p> a square, nonnegative left-stochastic matrix describing a 
first-order markov chain used to choose the matrices. This should have the 
same dimension as the number of matrices in <code>A</code>. 
</p>
</li>
<li><p> a numeric vector giving a specific sequence which corresponds to the
matrices in <code>A</code>.
</p>
</li>
<li><p> a character vector giving a specific sequence which corresponds to the
names of the matrices in <code>A</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stoch_+3A_vector">vector</code></td>
<td>
<p>(optional) a numeric vector describing the age/stage 
distribution used to calculate the projection. If <code>vector</code> is not 
specified, a random vector is generated. Long-term stochastic dynamics should 
usually be the same for any vector, although if all the matrices in A are 
reducible (see <code><a href="#topic+isIrreducible">isIrreducible</a></code>), that may not be the case.</p>
</td></tr>
<tr><td><code id="stoch_+3A_astart">Astart</code></td>
<td>
<p>(optional) in a stochastic projection, the matrix with which to
initialise the projection (either numeric, corresponding to the matrices in 
<code>A</code>, or character, corresponding to the names of matrices in <code>A</code>). 
When <code>Astart = NULL</code>, a random initial matrix is chosen.</p>
</td></tr>
<tr><td><code id="stoch_+3A_iterations">iterations</code></td>
<td>
<p>the number of projection intervals. The default is 1e+5.</p>
</td></tr>
<tr><td><code id="stoch_+3A_discard">discard</code></td>
<td>
<p>the number of initial projection intervals to discard, to 
discount near-term effects arising from the choice of vector. The default is
1e+3</p>
</td></tr>
<tr><td><code id="stoch_+3A_precheck">PREcheck</code></td>
<td>
<p>many functions in <code>popdemo</code> first check Primitivity, 
Reducibility and/or Ergodicity of matrices, with associated warnings and/or 
errors if a matrix breaks any assumptions. Set <code>PREcheck=FALSE</code> if you
want to bypass these checks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates stochastic growth and its variance for a given stochastic population 
matrix projection model.
</p>


<h3>Value</h3>

<p>A numeric vector with two possible elements: &quot;lambda&quot; (the stochastic population
growth rate) and &quot;var&quot; (the variance in stochastic population growth rate). Values
returned depend on what's passed to <code>what</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # load the Polar bear data
  ( data(Pbear) )

  # Find the stochastic growth for a time series with uniform probability of each
  # matrix
  ( lambda_unif &lt;- stoch(Pbear, what = "lambda", Aseq = "unif") )

  # Find the variance in stochastic growth for a time series with uniform 
  # probability of each matrix
  ( var_unif &lt;- stoch(Pbear, what = "var", Aseq = "unif") )
                 
  # Find stochastic growth and its variance for a time series with a sequence of
  # matrices where "bad" years happen with probability q
  q &lt;- 0.5
  prob_seq &lt;- c(rep(1-q,3)/3, rep(q,2)/2)
  Pbear_seq &lt;- matrix(rep(prob_seq,5), 5, 5)
  ( var_unif &lt;- stoch(Pbear, what = "var", Aseq = Pbear_seq) )
  
</code></pre>

<hr>
<h2 id='tfa_inertia'>Transfer function Analysis</h2><span id='topic+tfa_inertia'></span>

<h3>Description</h3>

<p>Transfer function analysis of inertia of a population matrix 
projection model using a specified perturbation structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfa_inertia(A, d, e, vector = "n", bound = NULL, prange, digits = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tfa_inertia_+3A_a">A</code></td>
<td>
<p>a square, primitive, nonnegative numeric matrix of any dimension</p>
</td></tr>
<tr><td><code id="tfa_inertia_+3A_d">d</code>, <code id="tfa_inertia_+3A_e">e</code></td>
<td>
<p>numeric vectors that determine the perturbation structure 
(see details).</p>
</td></tr>
<tr><td><code id="tfa_inertia_+3A_vector">vector</code></td>
<td>
<p>(optional) a numeric vector or one-column matrix describing 
the age/stage distribution ('demographic structure') used to calculate the
transfer function of a 'case-specific' inertia</p>
</td></tr>
<tr><td><code id="tfa_inertia_+3A_bound">bound</code></td>
<td>
<p>(optional) specifies whether the transfer funciton of an upper 
or lower bound on inertia should be calculated (see details).</p>
</td></tr>
<tr><td><code id="tfa_inertia_+3A_prange">prange</code></td>
<td>
<p>a numeric vector giving the range of perturbation magnitude
(see details)</p>
</td></tr>
<tr><td><code id="tfa_inertia_+3A_digits">digits</code></td>
<td>
<p>specifies which values of lambda should be excluded from 
analysis to avoid a computationally singular system (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tfa_inertia</code> calculates the transfer function of inertia of a 
population matrix projection model given a perturbation structure 
(specified using <code>d</code> and <code>e</code>), and a range of desired perturbation
magnitude (<code>prange</code>). Currently <code>tfa_inertia</code> can only work with 
rank-one, single-parameter perturbations (see Hodgson &amp; Townley 2006).
</p>
<p>If <code>vector="n"</code> then either <code>bound="upper"</code> or <code>bound="lower"</code>
must be specified, which calculate the transfer function of the upper or 
lower bound on population inertia (i.e. the largest and smallest values that 
inertia may take) respectively.  Specifying <code>vector</code> overrides 
calculation of a bound, and will yield a transfer function of a 'case-specific'
inertia.
</p>
<p>The perturbation structure is determined by <code>d%*%t(e)</code>. Therefore, 
the rows to be perturbed are determined by <code>d</code> and the columns to be 
perturbed are determined by <code>e</code>. The specific values in d and e will 
determine the relative perturbation magnitude. So for example, if only entry
[3,2] of a 3 by 3 matrix is to be perturbed, then <code>d = c(0,0,1)</code> and 
<code>e = c(0,1,0)</code>. If entries [3,2] and [3,3] are to be perturbed with the 
magnitude of perturbation to [3,2] half that of [3,3] then <code>d = c(0,0,1)</code> 
and <code>e = c(0,0.5,1)</code>. <code>d</code> and <code>e</code> may also be expressed as 
numeric one-column matrices, e.g. <code>d = matrix(c(0,0,1), ncol=1)</code>, 
<code>e = matrix(c(0,0.5,1), ncol=1)</code>. See Hodgson et al. (2006) for more 
information on perturbation structures.
</p>
<p>The perturbation magnitude is determined by <code>prange</code>, a numeric vector 
that gives the continuous range of perterbation magnitude to evaluate over. 
This is usually a sequence (e.g. <code>prange=seq(-0.1,0.1,0.001)</code>), but 
single transfer functions can be calculated using a single perturbation 
magnitude (e.g. <code>prange=-0.1</code>). Because of the nature of the equation
used to calculate the transfer function, <code>prange</code> is used to find a 
range of lambda from which the perturbation magnitudes are back-calculated, 
and matched to their orresponding inertia, so the output perturbation
magnitude <code>p</code> will match <code>prange</code> in length and range but not in
numerical value (see Stott et al. 2012 for more information).
</p>
<p><code>tfa_inertia</code> uses the resolvent matrix in its calculation, which
cannot be computed if any lambda in the equation are equal to the dominant
eigenvalue of <code>A</code>. <code>digits</code> specifies the values of lambda that 
should be excluded in order to avoid a computationally singular system. 
Any values equal to the dominant eigenvalue of <code>A</code> rounded to an 
accuracy of <code>digits</code> are excluded. <code>digits</code> should only need to 
be changed when the system is found to be computationally singular, in 
which case increasing <code>digits</code> should help to solve the problem.
</p>
<p><code>tfa_inertia</code> will not work for reducible matrices.
</p>
<p>There is an S3 plotting method available (see <code><a href="#topic+plot.tfa">plot.tfa</a></code> 
and examples below)
</p>


<h3>Value</h3>

<p>A list containing numerical vectors:
</p>

<dl>
<dt>p</dt><dd><p>perturbation magnitudes</p>
</dd>
<dt>lambda</dt><dd><p>dominant eigenvalues of perturbed matrices</p>
</dd>
</dl>
<p>iteminertiainertias of perturbed matrices

(Note that <code>p</code> will not be exactly the same as <code>prange</code> when 
<code>prange</code> is specified, as the code calculates p for a given lambda 
rather than the other way around, with <code>prange</code> only used to determine 
max, min and number of lambda values to evaluate.)
</p>


<h3>References</h3>


<ul>
<li><p> Stott et al. (2012) Methods Ecol. Evol., 3, 673-684.
</p>
</li>
<li><p> Hodgson et al. (2006) J. Theor. Biol., 70, 214-224.
</p>
</li></ul>



<h3>See Also</h3>

<p>S3 plotting method: <code><a href="#topic+plot.tfa">plot.tfa</a></code>
</p>
<p>Other TransferFunctionAnalyses: 
<code><a href="#topic+tfa_lambda">tfa_lambda</a>()</code>,
<code><a href="#topic+tfam_inertia">tfam_inertia</a>()</code>,
<code><a href="#topic+tfam_lambda">tfam_lambda</a>()</code>,
<code><a href="#topic+tfs_inertia">tfs_inertia</a>()</code>,
<code><a href="#topic+tfs_lambda">tfs_lambda</a>()</code>
</p>
<p>Other PerturbationAnalyses: 
<code><a href="#topic+elas">elas</a>()</code>,
<code><a href="#topic+sens">sens</a>()</code>,
<code><a href="#topic+tfa_lambda">tfa_lambda</a>()</code>,
<code><a href="#topic+tfam_inertia">tfam_inertia</a>()</code>,
<code><a href="#topic+tfam_lambda">tfam_lambda</a>()</code>,
<code><a href="#topic+tfs_inertia">tfs_inertia</a>()</code>,
<code><a href="#topic+tfs_lambda">tfs_lambda</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a 3x3 matrix
  ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Create an initial stage structure
  ( initial &lt;- c(1,3,2) )

  # Calculate the transfer function of upper bound on inertia 
  # given a perturbation to A[3,2]
  ( transfer&lt;-tfa_inertia(A, d=c(0,0,1), e=c(0,1,0), bound="upper",
                          prange=seq(-0.6,0.4,0.01)) )

  # Plot the transfer function using the S3 method (defaults to p 
  # and inertia in this case)
  plot(transfer)

  # Plot inertia against lambda using the S3 method
  plot(transfer, xvar="lambda", yvar="inertia")

  # Calculate the transfer function of case-specific inertia 
  # given perturbation to A[3,2] and A[3,3] with perturbation 
  # to A[3,2] half that of A[3,3]
  ( transfer2&lt;-tfa_inertia(A, d=c(0,0,1), e=c(0,0.5,1), vector=initial,
                           prange=seq(-0.6,0.4,0.01)) )

  # Plot inertia against p using the S3 method
  plot(transfer2)

  # Plot inertia against lambda without using the S3 method
  plot(transfer$inertia~transfer$lambda,type="l", 
       xlab=expression(lambda),ylab="inertia")

</code></pre>

<hr>
<h2 id='tfa_lambda'>Transfer function analysis</h2><span id='topic+tfa_lambda'></span>

<h3>Description</h3>

<p>Transfer function analysis of the dominant eigenvalue of a population matrix 
projection model using a specified perturbation structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfa_lambda(A, d, e, prange = NULL, lambdarange = NULL, digits = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tfa_lambda_+3A_a">A</code></td>
<td>
<p>a square, irreducible, nonnegative numeric matrix of any dimension</p>
</td></tr>
<tr><td><code id="tfa_lambda_+3A_d">d</code>, <code id="tfa_lambda_+3A_e">e</code></td>
<td>
<p>numeric vectors that determine the perturbation structure 
(see details).</p>
</td></tr>
<tr><td><code id="tfa_lambda_+3A_prange">prange</code></td>
<td>
<p>a numeric vector giving the range of perturbation magnitude
(see details)</p>
</td></tr>
<tr><td><code id="tfa_lambda_+3A_lambdarange">lambdarange</code></td>
<td>
<p>a numeric vector giving the range of lambda values 
(asymptotic growth rates) to be achieved (see details).</p>
</td></tr>
<tr><td><code id="tfa_lambda_+3A_digits">digits</code></td>
<td>
<p>specifies which values of lambda should be excluded from 
analysis to avoid a computationally singular system (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tfa_lambda</code> calculates the transfer function of the dominant eigenvalue
of a matrix (<code>A</code>), given a perturbation structure (specified using 
<code>d</code> and <code>e</code>), and either a range of target values for asymptotic 
population growth (<code>lambdavalues</code>) or a range of desired perturbation 
magnitude (<code>prange</code>). Currently <code>tfa_lambda</code> can only work with rank-
one, single-parameter perturbations (see Hodgson &amp; Townley 2004).
</p>
<p>The perturbation structure is determined by <code>d%*%t(e)</code>. Therefore, 
the rows to be perturbed are determined by <code>d</code> and the columns to be 
perturbed are determined by <code>e</code>. The specific values in d and e will 
determine the relative perturbation magnitude. So for example, if only entry
[3,2] of a 3 by 3 matrix is to be perturbed, then <code>d = c(0,0,1)</code> and 
<code>e = c(0,1,0)</code>. If entries [3,2] and [3,3] are to be perturbed with the 
magnitude of perturbation to [3,2] half that of [3,3] then <code>d = c(0,0,1)</code> 
and <code>e = c(0,0.5,1)</code>. <code>d</code> and <code>e</code> may also be expressed as 
numeric one-column matrices, e.g. <code>d = matrix(c(0,0,1), ncol=1)</code>, 
<code>e = matrix(c(0,0.5,1), ncol=1)</code>. See Hodgson et al. (2006) for more 
information on perturbation structures.
</p>
<p>The perturbation magnitude is determined by <code>prange</code>, a numeric vector 
that gives the continuous range of perterbation magnitude to evaluate over. 
This is usually a sequence (e.g. <code>prange=seq(-0.1,0.1,0.001)</code>), but 
single transfer functions can be calculated using a single perturbation 
magnitude (e.g. <code>prange=-0.1</code>). Because of the nature of the equation, 
<code>prange</code> is used to find a range of lambda from which the perturbation 
magnitudes are back-calculated, so the output perturbation magnitude 
<code>p</code> will match <code>prange</code> in length and range but not in numerical 
value (see value). Alternatively, a vector <code>lambdarange</code> can be 
specified, representing a range of target lambda values from which the
corresponding perturbation values will be calculated. Only one of either 
<code>prange</code> or <code>lambdarange</code> may be specified.
</p>
<p><code>tfa_lambda</code> uses the resolvent matrix in its calculation, which cannot be 
computed if any lambda are equal to the dominant eigenvalue of 
<code>A</code>. <code>digits</code> specifies the values of lambda that should be 
excluded in order to avoid a computationally singular system. Any values 
equal to the dominant eigenvalue of <code>A</code> rounded to an accuracy of 
<code>digits</code> are excluded. <code>digits</code> should only need to be changed 
when the system is found to be computationally singular, in which case 
increasing <code>digits</code> should help to solve the problem.
</p>
<p><code>tfa_lambda</code> will not work for reducible matrices.
</p>
<p>There is an S3 plotting method available (see <code><a href="#topic+plot.tfa">plot.tfa</a></code> 
and examples below)
</p>


<h3>Value</h3>

<p>A list containing numerical vectors:
</p>

<dl>
<dt>p</dt><dd><p>the perturbation magnitude(s).</p>
</dd>
<dt>lambda</dt><dd><p>the dominant eigenvalue(s) of the perturbed matrix(matrices)</p>
</dd></dl>
<p>.

(Note that <code>p</code> will not be exactly the same as <code>prange</code> when 
<code>prange</code> is specified, as the code calculates p for a given lambda 
rather than the other way around, with <code>prange</code> only used to determine 
max, min and number of lambda values to evaluate.)
</p>


<h3>References</h3>


<ul>
<li><p> Townley &amp; Hodgson (2004) J. Appl. Ecol., 41, 1155-1161.
</p>
</li>
<li><p> Hodgson et al. (2006) J. Theor. Biol., 70, 214-224.
</p>
</li></ul>



<h3>See Also</h3>

<p>S3 plotting method: <code><a href="#topic+plot.tfa">plot.tfa</a></code>
</p>
<p>Other TransferFunctionAnalyses: 
<code><a href="#topic+tfa_inertia">tfa_inertia</a>()</code>,
<code><a href="#topic+tfam_inertia">tfam_inertia</a>()</code>,
<code><a href="#topic+tfam_lambda">tfam_lambda</a>()</code>,
<code><a href="#topic+tfs_inertia">tfs_inertia</a>()</code>,
<code><a href="#topic+tfs_lambda">tfs_lambda</a>()</code>
</p>
<p>Other PerturbationAnalyses: 
<code><a href="#topic+elas">elas</a>()</code>,
<code><a href="#topic+sens">sens</a>()</code>,
<code><a href="#topic+tfa_inertia">tfa_inertia</a>()</code>,
<code><a href="#topic+tfam_inertia">tfam_inertia</a>()</code>,
<code><a href="#topic+tfam_lambda">tfam_lambda</a>()</code>,
<code><a href="#topic+tfs_inertia">tfs_inertia</a>()</code>,
<code><a href="#topic+tfs_lambda">tfs_lambda</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a 3x3 matrix
  ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Calculate the transfer function of A[3,2] given a range of lambda
  evals &lt;- eigen(A)$values
  lmax &lt;- which.max(Re(evals))
  lambda &lt;- Re(evals[lmax])
  lambdarange &lt;- seq(lambda-0.1, lambda+0.1, 0.01)
  ( transfer &lt;- tfa_lambda(A, d=c(0,0,1), e=c(0,1,0), lambdarange=lambdarange) )

  # Plot the transfer function using the S3 method
  plot(transfer)

  # Calculate the transfer function of perturbation to A[3,2] and A[3,3]
  # with perturbation to A[3,2] half that of A[3,3], given a range of 
  # perturbation values
  p&lt;-seq(-0.6,0.4,0.01)
  ( transfer2 &lt;- tfa_lambda(A, d=c(0,0,1), e=c(0,0.5,1), prange=p) )

  # Plot p and lambda without using the S3 method
  plot(transfer$lambda~transfer$p, type="l", xlab="p", ylab=expression(lambda))

</code></pre>

<hr>
<h2 id='tfam_inertia'>Transfer function Analysis</h2><span id='topic+tfam_inertia'></span>

<h3>Description</h3>

<p>Transfer function analysis of inertia of a population matrix 
projection model for all matrix elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfam_inertia(
  A,
  bound = NULL,
  vector = "n",
  elementtype = NULL,
  Flim = c(-1, 10),
  Plim = c(-1, 10),
  plength = 100,
  digits = 1e-10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tfam_inertia_+3A_a">A</code></td>
<td>
<p>a square, primitive, nonnegative numeric matrix of any dimension</p>
</td></tr>
<tr><td><code id="tfam_inertia_+3A_bound">bound</code></td>
<td>
<p>(optional) specifies whether the transfer funciton of an upper 
or lower bound on inertia should be calculated (see details).</p>
</td></tr>
<tr><td><code id="tfam_inertia_+3A_vector">vector</code></td>
<td>
<p>(optional) a numeric vector or one-column matrix describing 
the age/stage distribution ('demographic structure') used to calculate the
transfer function of a 'case-specific' inertia</p>
</td></tr>
<tr><td><code id="tfam_inertia_+3A_elementtype">elementtype</code></td>
<td>
<p>(optional) a character matrix of the same dimension as 
<code>A</code> describing the structure of <code>A</code>: <code>"P"</code> denotes elements 
bounded between 0 and 1, i.e. survival, growth, regression; <code>"F"</code> 
denotes elements not bounded at 1, i.e. fecundity, fission; <code>NA</code> 
denotes absent elements (see details).</p>
</td></tr>
<tr><td><code id="tfam_inertia_+3A_flim">Flim</code>, <code id="tfam_inertia_+3A_plim">Plim</code></td>
<td>
<p>the perturbation ranges for <code>"F"</code> and <code>"P"</code> 
elements, expressed as a proportion of their magnitude  (see details).</p>
</td></tr>
<tr><td><code id="tfam_inertia_+3A_plength">plength</code></td>
<td>
<p>the desired length of the perturbation ranges.</p>
</td></tr>
<tr><td><code id="tfam_inertia_+3A_digits">digits</code></td>
<td>
<p>specifies which values of lambda should be excluded from 
analysis to avoid a computationally singular system (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tfam_inertia</code> calculates an array of transfer functions 
of population inertia. A separate transfer function for each nonzero 
element of <code>A</code> is calculated (each element perturbed independently of 
the others). The function is most useful for use with the S3 method 
<code><a href="#topic+plot.tfam">plot.tfam</a></code> to visualise how perturbations affect the 
life cycle transitions, and easily compare the (nonlinear) effect of 
perturbation to different transitions on the dominant eigenvalue.
</p>
<p>The sizes of the perturbations are determined by <code>elementtype</code>, 
<code>Flim</code>, <code>Plim</code> and <code>plength</code>. <code>elementtype</code> gives the 
type of each element, specifying whether perturbations should be 
bounded at 1 (<code>elementtype = "P"</code>) or not (<code>elementtype = "F"</code>). 
If <code>elementtype</code> is not directly specified, the function assigns its 
own types, with those in the first row attributed <code>"F"</code>, and elsewhere 
in the matrix attributed <code>"F"</code> if the value of the element &gt;1 and 
<code>"P"</code> if the value of the element is &lt;=1. <code>Flim</code> and <code>Plim</code> 
determine the desired perturbation magnitude, expressed as a proportion of 
the magnitude of the elements of <code>A</code>, whilst plength determines the 
length of the perturbation vector.  For example, if an &quot;F&quot; element is equal 
to 0.5, <code>Flim=c(-1,10)</code> and <code>plength=100</code> then the perturbation 
to that element is <code>seq(-1*0.5,10*0.5,100-1)</code>. The process is the same 
for <code>"P"</code> elements, except that these are truncated to a maximum value 
of 1 (growth/survival elements cannot be greater than 1). Both <code>"F"</code> 
and <code>"P"</code> elements are truncated to a minimum value of 0.
</p>
<p><code>tfam_inertia</code> uses <code><a href="#topic+tfa_inertia">tfa_inertia</a></code> to calculate
transfer functions. <code>digits</code> is passed to <code>tfa_inertia</code> to
prevent the problem of singular matrices (see details in
<code><a href="#topic+tfa_inertia">tfa_inertia</a></code>).
</p>
<p><code>tfam_inertia</code> will not work for reducible matrices.
</p>


<h3>Value</h3>

<p>A list containing numerical arrays: 
</p>

<dl>
<dt>p</dt><dd><p>perturbation magnitudes</p>
</dd>
<dt>lambda</dt><dd><p>dominant eigenvalues of perturbed matrices</p>
</dd>
<dt>inertia</dt><dd><p>inertias of perturbed matrices</p>
</dd>
</dl>

<p>The first and second dimensions of the arrays are equivalent to the 
first and second dimensions of <code>A</code>. The third dimension of the 
arrays are the vectors returned by <code>tfa_inertia</code>. e.g.
$inertia[3,2,] selects the inertia values for the transfer function of
element [3,2] of the matrix.
</p>


<h3>References</h3>


<ul>
<li><p> Stott et al. (2012) Methods Ecol. Evol., 3, 673-684.
</p>
</li>
<li><p> Hodgson et al. (2006) J. Theor. Biol., 70, 214-224.
</p>
</li></ul>



<h3>See Also</h3>

<p>S3 plotting method: <code><a href="#topic+plot.tfam">plot.tfam</a></code>
</p>
<p>Other TransferFunctionAnalyses: 
<code><a href="#topic+tfa_inertia">tfa_inertia</a>()</code>,
<code><a href="#topic+tfa_lambda">tfa_lambda</a>()</code>,
<code><a href="#topic+tfam_lambda">tfam_lambda</a>()</code>,
<code><a href="#topic+tfs_inertia">tfs_inertia</a>()</code>,
<code><a href="#topic+tfs_lambda">tfs_lambda</a>()</code>
</p>
<p>Other PerturbationAnalyses: 
<code><a href="#topic+elas">elas</a>()</code>,
<code><a href="#topic+sens">sens</a>()</code>,
<code><a href="#topic+tfa_inertia">tfa_inertia</a>()</code>,
<code><a href="#topic+tfa_lambda">tfa_lambda</a>()</code>,
<code><a href="#topic+tfam_lambda">tfam_lambda</a>()</code>,
<code><a href="#topic+tfs_inertia">tfs_inertia</a>()</code>,
<code><a href="#topic+tfs_lambda">tfs_lambda</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a 3x3 matrix
  ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Create an initial stage structure
  ( initial &lt;- c(1,3,2))

  # Calculate the matrix of transfer functions for the upper bound on
  # inertia, using default arguments
  ( tfmat&lt;-tfam_inertia(A,bound="upper") )

  # Plot the transfer function using the S3 method (defaults to p 
  # and inertia in this case)
  plot(tfmat)

  # Plot inertia against lambda using the S3 method
  plot(tfmat, xvar="lambda", yvar="inertia")
    
  # Plot the transfer function of element [3,2] without the S3 method
  par(mfrow=c(1,1))
  par(mar=c(5,4,4,2)+0.1)
  plot(tfmat$inertia[3,2,]~tfmat$p[3,2,],xlab="p",ylab="lambda",type="l")

  # Create a new matrix with fission of adults
  B &lt;- A; B[2,3] &lt;- 0.9; B

  # Calculate the matrix of transfer functions for specified
  # initial stage structure, using chosen arguments
  # that give the exact structure of the new matrix
  # and perturb a minimum of half the value of an element and
  # a maximum of double the value of an element
  ( etype &lt;- matrix(c(NA, "F", "F", "P", "P", "F", NA, "P", "P"), 
                    ncol=3, byrow=TRUE) )
  ( tfmat2 &lt;- tfam_inertia(B, vector=initial, elementtype=etype, 
                                Flim=c(-0.5,2), Plim=c(-0.5,2)) )

  # Plot the new matrix of transfer functions using the S3 method
  plot(tfmat2)
    
</code></pre>

<hr>
<h2 id='tfam_lambda'>Transfer function analysis</h2><span id='topic+tfam_lambda'></span>

<h3>Description</h3>

<p>Transfer function analysis of the dominant eigenvalue of a population matrix 
projection model for all matrix elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfam_lambda(
  A,
  elementtype = NULL,
  Flim = c(-1, 10),
  Plim = c(-1, 10),
  plength = 100,
  digits = 1e-10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tfam_lambda_+3A_a">A</code></td>
<td>
<p>a square, irreducible, nonnegative numeric matrix of any dimension</p>
</td></tr>
<tr><td><code id="tfam_lambda_+3A_elementtype">elementtype</code></td>
<td>
<p>(optional) a character matrix of the same dimension as 
<code>A</code> describing the structure of <code>A</code>: <code>"P"</code> denotes elements 
bounded between 0 and 1, i.e. survival, growth, regression; <code>"F"</code> 
denotes elements not bounded at 1, i.e. fecundity, fission; <code>NA</code> 
denotes absent elements (see details).</p>
</td></tr>
<tr><td><code id="tfam_lambda_+3A_flim">Flim</code>, <code id="tfam_lambda_+3A_plim">Plim</code></td>
<td>
<p>the perturbation ranges for <code>"F"</code> and <code>"P"</code> 
elements, expressed as a proportion of their magnitude  (see details).</p>
</td></tr>
<tr><td><code id="tfam_lambda_+3A_plength">plength</code></td>
<td>
<p>the desired length of the perturbation ranges.</p>
</td></tr>
<tr><td><code id="tfam_lambda_+3A_digits">digits</code></td>
<td>
<p>specifies which values of lambda should be excluded from 
analysis to avoid a computationally singular system (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tfam_lambda</code> calculates an array of transfer functions of the dominant
eigenvalue of <code>A</code>. A separate transfer function for each nonzero 
element of <code>A</code> is calculated (each element perturbed independently of 
the others). The function is most useful for use with the S3 method 
<code><a href="#topic+plot.tfam">plot.tfam</a></code> to visualise how perturbations affect the 
life cycle transitions, and easily compare the (nonlinear) effect of 
perturbation to different transitions on the dominant eigenvalue.
</p>
<p>The sizes of the perturbations are determined by <code>elementtype</code>, 
<code>Flim</code>, <code>Plim</code> and <code>plength</code>. <code>elementtype</code> gives the 
type of each element, specifying whether perturbations should be 
bounded at 1 (<code>elementtype = "P"</code>) or not (<code>elementtype = "F"</code>). 
If <code>elementtype</code> is not directly specified, the function assigns its 
own types, with those in the first row attributed <code>"F"</code>, and elsewhere 
in the matrix attributed <code>"F"</code> if the value of the element &gt;1 and 
<code>"P"</code> if the value of the element is &lt;=1. <code>Flim</code> and <code>Plim</code> 
determine the desired perturbation magnitude, expressed as a proportion of 
the magnitude of the elements of <code>A</code>, whilst plength determines the 
length of the perturbation vector.  For example, if an &quot;F&quot; element is equal 
to 0.5, <code>Flim=c(-1,10)</code> and <code>plength=100</code> then the perturbation 
to that element is <code>seq(-1*0.5,10*0.5,100-1)</code>. The process is the same 
for <code>"P"</code> elements, except that these are truncated to a maximum value 
of 1 (growth/survival elements cannot be greater than 1). Both <code>"F"</code> 
and <code>"P"</code> elements are truncated to a minimum value of 0.
</p>
<p><code>tfam_lambda</code> uses <code><a href="#topic+tfa_lambda">tfa_lambda</a></code> to calculate transfer 
functions. <code>digits</code> is passed to <code>tfa_lambda</code> to prevent the 
problem of singular matrices (see details in <code><a href="#topic+tfa_lambda">tfa_lambda</a></code>).
</p>
<p><code>tfam_lambda</code> will not work for reducible matrices.
</p>


<h3>Value</h3>

<p>A list containing numerical arrays:
</p>

<dl>
<dt>p</dt><dd><p>perturbation magnitudes</p>
</dd>
<dt>lambda</dt><dd><p>dominant eigenvalues of perturbed matrices</p>
</dd>
</dl>

<p>The first and second dimensions of the arrays are equivalent to
the first and second dimensions of <code>A</code>. The third dimension of the
arrays are the vectors returned by <code>tfa_lambda</code>. e.g. $lambda[3,2,] selects
the lambda values for the transfer function of element [3,2] of the matrix.
</p>


<h3>References</h3>


<ul>
<li><p> Townley &amp; Hodgson (2004) J. Appl. Ecol., 41, 1155-1161.
</p>
</li>
<li><p> Hodgson et al. (2006) J. Theor. Biol., 70, 214-224.
</p>
</li></ul>



<h3>See Also</h3>

<p>S3 plotting method: <code><a href="#topic+plot.tfa">plot.tfa</a></code>
</p>
<p>Other TransferFunctionAnalyses: 
<code><a href="#topic+tfa_inertia">tfa_inertia</a>()</code>,
<code><a href="#topic+tfa_lambda">tfa_lambda</a>()</code>,
<code><a href="#topic+tfam_inertia">tfam_inertia</a>()</code>,
<code><a href="#topic+tfs_inertia">tfs_inertia</a>()</code>,
<code><a href="#topic+tfs_lambda">tfs_lambda</a>()</code>
</p>
<p>Other PerturbationAnalyses: 
<code><a href="#topic+elas">elas</a>()</code>,
<code><a href="#topic+sens">sens</a>()</code>,
<code><a href="#topic+tfa_inertia">tfa_inertia</a>()</code>,
<code><a href="#topic+tfa_lambda">tfa_lambda</a>()</code>,
<code><a href="#topic+tfam_inertia">tfam_inertia</a>()</code>,
<code><a href="#topic+tfs_inertia">tfs_inertia</a>()</code>,
<code><a href="#topic+tfs_lambda">tfs_lambda</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a 3x3 matrix
  ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Calculate the matrix of transfer functions using default arguments
  ( tfmat&lt;-tfam_lambda(A) )

  # Plot the result using the S3 method
  plot(tfmat)

  # Plot the transfer function of element [3,2] without using the S3 method
  par(mfrow=c(1,1))
  par(mar=c(5,4,4,2)+0.1)
  plot(tfmat$lambda[3,2,]~tfmat$p[3,2,],xlab="p",ylab="lambda",type="l")

  # Create a new matrix with fission of adults
  B &lt;- A; B[2,3] &lt;- 0.9; B

  # Calculate the matrix of transfer functions using chosen arguments
  # that give the exact structure of the new matrix
  # and perturb a minimum of half the value of an element and
  # a maximum of double the value of an element
  ( etype &lt;- matrix(c(NA, "F", "F", "P", "P", "F", NA, "P", "P"), 
                  ncol=3, byrow=TRUE) )
  ( tfmat2 &lt;- tfam_lambda(B, elementtype=etype, Flim=c(-0.5,2),
                      Plim=c(-0.5,2)) )

  # Plot the new matrix of transfer functions using the S3 method
  plot(tfmat2)
    
</code></pre>

<hr>
<h2 id='tfs_inertia'>Calculate sensitivity of inertia using transfer functions</h2><span id='topic+tfs_inertia'></span><span id='topic+tfsm_inertia'></span>

<h3>Description</h3>

<p>Calculate the sensitivity of population inertia of a population matrix 
projection model using differentiation of the transfer function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfs_inertia(A, d=NULL, e=NULL, vector="n", bound=NULL, startval=0.001, 
            tolerance=1e-10,return.fit=FALSE,plot.fit=FALSE)
tfsm_inertia(A,vector="n",bound=NULL,startval=0.001,tolerance=1e-10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tfs_inertia_+3A_a">A</code></td>
<td>
<p>a square, primitive, nonnegative numeric matrix of any dimension</p>
</td></tr>
<tr><td><code id="tfs_inertia_+3A_d">d</code>, <code id="tfs_inertia_+3A_e">e</code></td>
<td>
<p>numeric vectors that determine the perturbation structure 
(see details).</p>
</td></tr>
<tr><td><code id="tfs_inertia_+3A_vector">vector</code></td>
<td>
<p>(optional) a numeric vector or one-column matrix describing 
the age/stage distribution ('demographic structure') used to calculate the
transfer function of a 'case-specific' inertia</p>
</td></tr>
<tr><td><code id="tfs_inertia_+3A_bound">bound</code></td>
<td>
<p>(optional) specifies whether the transfer funciton of an upper 
or lower bound on inertia should be calculated (see details).</p>
</td></tr>
<tr><td><code id="tfs_inertia_+3A_startval">startval</code></td>
<td>
<p><code>tfs_inertia</code> calculates the limit of the derivative 
of the transfer function as lambda of the perturbed matrix approaches the 
dominant eigenvalue of <code>A</code> (see details). <code>startval</code> provides a 
starting value for the algorithm: the smaller <code>startval</code> is, the quicker 
the algorithm should converge.</p>
</td></tr>
<tr><td><code id="tfs_inertia_+3A_tolerance">tolerance</code></td>
<td>
<p>the tolerance level for determining convergence (see
details).</p>
</td></tr>
<tr><td><code id="tfs_inertia_+3A_return.fit">return.fit</code></td>
<td>
<p>if <code>TRUE</code> (and only if <code>d</code> and <code>e</code> are
specified), the lambda and sensitivity values obtained
from the convergence algorithm are returned alongside the sensitivity at the
limit.</p>
</td></tr>
<tr><td><code id="tfs_inertia_+3A_plot.fit">plot.fit</code></td>
<td>
<p>if <code>TRUE</code> then convergence of the algorithm is plotted
as sensitivity~lambda.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tfs_inertia</code> and <code>tfsm_inertia</code> differentiate a transfer function to
find sensitivity of population inertia to perturbations.
</p>
<p><code>tfs_inertia</code> evaluates the transfer function of a specific perturbation 
structure. The perturbation structure is determined by <code>d%*%t(e)</code>. 
Therefore, the rows to be perturbed are determined by <code>d</code> and the 
columns to be perturbed are determined by <code>e</code>. The values in d and e 
determine the relative perturbation magnitude. For example, if only entry
[3,2] of a 3 by 3 matrix is to be perturbed, then <code>d = c(0,0,1)</code> and 
<code>e = c(0,1,0)</code>. If entries [3,2] and [3,3] are to be perturbed with the 
magnitude of perturbation to [3,2] half that of [3,3] then <code>d = c(0,0,1)</code> 
and <code>e = c(0,0.5,1)</code>. <code>d</code> and <code>e</code> may also be expressed as 
numeric one-column matrices, e.g. <code>d = matrix(c(0,0,1), ncol=1)</code>, 
<code>e = matrix(c(0,0.5,1), ncol=1)</code>. See Hodgson et al. (2006) for more 
information on perturbation structures.
</p>
<p><code>tfsm_inertia</code> returns a matrix of sensitivity values for observed
transitions (similar to that obtained when using <code><a href="#topic+sens">sens</a></code> to
evaluate sensitivity of asymptotic growth), where a separate transfer function 
for each nonzero element of <code>A</code> is calculated (each element perturbed 
independently of the others).
</p>
<p>The formula used by <code>tfs_inertia</code> and <code>tfsm_inertia</code> cannot be
evaluated at lambda-max, therefore it is necessary to find the limit of the
formula as lambda approaches lambda-max. This is done using a bisection
method, starting at a value of lambda-max + <code>startval</code>. <code>startval</code>
should be small, to avoid the potential of false convergence. The algorithm
continues until successive sensitivity calculations are within an accuracy
of one another, determined by <code>tolerance</code>: a <code>tolerance</code> of 1e-10
means that the sensitivity calculation should be accurate to 10 decimal
places. However, as the limit approaches lambda-max, matrices are no longer
invertible (singular): if matrices are found to be singular then
<code>tolerance</code> should be relaxed and made larger.
</p>
<p>For <code>tfs_inertia</code>, there is an extra option to return and/or plot the above
fitting process using <code>return.fit=TRUE</code> and <code>plot.fit=TRUE</code>
respectively.
</p>


<h3>Value</h3>

<p>For <code>tfs_inertia</code>, the sensitivity of inertia (or its bound) to 
the specified perturbation structure. If <code>return.fit=TRUE</code> a list 
containing components:
</p>

<dl>
<dt>sens</dt><dd><p>the sensitivity of inertia (or its bound) to the specified 
perturbation structure</p>
</dd>
<dt>lambda.fit</dt><dd><p>the lambda values obtained in the fitting process</p>
</dd>
<dt>sens.fit</dt><dd><p>the sensitivity values obtained in the fitting process.</p>
</dd></dl>
<p><br />
For <code>tfsm_inertia</code>, a matrix containing sensitivity of inertia
(or its bound) to each separate element of <code>A</code>.

</p>


<h3>References</h3>


<ul>
<li><p> Stott et al. (2012) Methods Ecol. Evol., 3, 673-684.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other TransferFunctionAnalyses: 
<code><a href="#topic+tfa_inertia">tfa_inertia</a>()</code>,
<code><a href="#topic+tfa_lambda">tfa_lambda</a>()</code>,
<code><a href="#topic+tfam_inertia">tfam_inertia</a>()</code>,
<code><a href="#topic+tfam_lambda">tfam_lambda</a>()</code>,
<code><a href="#topic+tfs_lambda">tfs_lambda</a>()</code>
</p>
<p>Other PerturbationAnalyses: 
<code><a href="#topic+elas">elas</a>()</code>,
<code><a href="#topic+sens">sens</a>()</code>,
<code><a href="#topic+tfa_inertia">tfa_inertia</a>()</code>,
<code><a href="#topic+tfa_lambda">tfa_lambda</a>()</code>,
<code><a href="#topic+tfam_inertia">tfam_inertia</a>()</code>,
<code><a href="#topic+tfam_lambda">tfam_lambda</a>()</code>,
<code><a href="#topic+tfs_lambda">tfs_lambda</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a 3x3 matrix
  ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Create an initial stage structure    
  ( initial &lt;- c(1,3,2) )

  # Calculate the sensitivity matrix for the upper bound on inertia
  tfsm_inertia(A, bound="upper",tolerance=1e-7)

  # Calculate the sensitivity of simultaneous perturbation to 
  # A[1,3] and A[2,3] for the lower bound on inertia
  tfs_inertia(A, d=c(1,0,0), e=c(0,1,1), bound="lower")

  # Calculate the sensitivity of simultaneous perturbation to 
  # A[1,3] and A[2,3] for specified initial stage structure
  # and return and plot the fitting process
  tfs_inertia(A, d=c(1,0,0), e=c(0,1,1), vector=initial,tolerance=1e-7,
              return.fit=TRUE,plot.fit=TRUE)

</code></pre>

<hr>
<h2 id='tfs_lambda'>Calculate sensitivity using transfer functions</h2><span id='topic+tfs_lambda'></span><span id='topic+tfsm_lambda'></span>

<h3>Description</h3>

<p>Calculate the sensitivity of the dominant eigenvalue of a population matrix 
projection model using differentiation of the transfer function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfs_lambda(A, d=NULL, e=NULL, startval=0.001, tolerance=1e-10, 
           return.fit=FALSE, plot.fit=FALSE)
tfsm_lambda(A, startval=0.001, tolerance=1e-10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tfs_lambda_+3A_a">A</code></td>
<td>
<p>a square, nonnegative numeric matrix of any dimension.</p>
</td></tr>
<tr><td><code id="tfs_lambda_+3A_d">d</code>, <code id="tfs_lambda_+3A_e">e</code></td>
<td>
<p>numeric vectors that determine the perturbation structure (see
details).</p>
</td></tr>
<tr><td><code id="tfs_lambda_+3A_startval">startval</code></td>
<td>
<p><code>tfs_lambda</code> calculates the limit of the derivative of the
transfer function as lambda of the perturbed matrix approaches the dominant 
eigenvalue of <code>A</code> (see details). <code>startval</code> provides a starting 
value for the algorithm: the smaller <code>startval</code> is, the quicker the 
algorithm should converge.</p>
</td></tr>
<tr><td><code id="tfs_lambda_+3A_tolerance">tolerance</code></td>
<td>
<p>the tolerance level for determining convergence (see
details).</p>
</td></tr>
<tr><td><code id="tfs_lambda_+3A_return.fit">return.fit</code></td>
<td>
<p>if <code>TRUE</code> the lambda and sensitivity values obtained
from the convergence algorithm are returned alongside the sensitivity at the
limit.</p>
</td></tr>
<tr><td><code id="tfs_lambda_+3A_plot.fit">plot.fit</code></td>
<td>
<p>if <code>TRUE</code> then convergence of the algorithm is plotted
as sensitivity~lambda.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tfs_lambda</code> and <code>tfsm_lambda</code> differentiate a transfer function to
find sensitivity of the dominant eigenvalue of <code>A</code> to perturbations. 
This provides an alternative method to using matrix eigenvectors to 
calculate the sensitivity matrix and is useful as it may incorporate a 
greater diversity of perturbation structures.
</p>
<p><code>tfs_lambda</code> evaluates the transfer function of a specific perturbation 
structure. The perturbation structure is determined by <code>d%*%t(e)</code>. 
Therefore, the rows to be perturbed are determined by <code>d</code> and the 
columns to be perturbed are determined by <code>e</code>. The values in d and e 
determine the relative perturbation magnitude. For example, if only entry
[3,2] of a 3 by 3 matrix is to be perturbed, then <code>d = c(0,0,1)</code> and 
<code>e = c(0,1,0)</code>. If entries [3,2] and [3,3] are to be perturbed with the 
magnitude of perturbation to [3,2] half that of [3,3] then <code>d = c(0,0,1)</code> 
and <code>e = c(0,0.5,1)</code>. <code>d</code> and <code>e</code> may also be expressed as 
numeric one-column matrices, e.g. <code>d = matrix(c(0,0,1), ncol=1)</code>, 
<code>e = matrix(c(0,0.5,1), ncol=1)</code>. See Hodgson et al. (2006) for more 
information on perturbation structures.
</p>
<p><code>tfsm_lambda</code> returns a matrix of sensitivity values for observed
transitions (similar to that obtained when using <code><a href="#topic+sens">sens</a></code> to
evaluate sensitivity using eigenvectors), where a separate transfer function 
for each nonzero element of <code>A</code> is calculated (each element perturbed 
independently of the others).
</p>
<p>The formula used by <code>tfs_lambda</code> and <code>tfsm_lambda</code> cannot be
evaluated at lambda-max, therefore it is necessary to find the limit of the
formula as lambda approaches lambda-max. This is done using a bisection
method, starting at a value of lambda-max + <code>startval</code>. <code>startval</code>
should be small, to avoid the potential of false convergence. The algorithm
continues until successive sensitivity calculations are within an accuracy
of one another, determined by <code>tolerance</code>: a <code>tolerance</code> of 1e-10
means that the sensitivity calculation should be accurate to 10 decimal
places. However, as the limit approaches lambda-max, matrices are no longer
invertible (singular): if matrices are found to be singular then
<code>tolerance</code> should be relaxed and made larger.
</p>
<p>For <code>tfs_lambda</code>, there is an extra option to return and/or plot the above
fitting process using <code>return.fit=TRUE</code> and <code>plot.fit=TRUE</code>
respectively.
</p>


<h3>Value</h3>

<p>For <code>tfs_lambda</code>, the sensitivity of lambda-max to the specified
perturbation structure. If <code>return.fit=TRUE</code> a list containing
components:
</p>

<dl>
<dt>sens</dt><dd><p>the sensitivity of lambda-max to the specified perturbation 
structure</p>
</dd>
<dt>lambda.fit</dt><dd><p>the lambda values obtained in the fitting process</p>
</dd>
<dt>sens.fit</dt><dd><p>the sensitivity values obtained in the fitting process.</p>
</dd></dl>
<p><br />
For <code>tfsm_lambda</code>, a matrix containing sensitivity of lambda-max 
to each element of <code>A</code>.

</p>


<h3>References</h3>


<ul>
<li><p> Hodgson et al. (2006) J. Theor. Biol., 70, 214-224.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other TransferFunctionAnalyses: 
<code><a href="#topic+tfa_inertia">tfa_inertia</a>()</code>,
<code><a href="#topic+tfa_lambda">tfa_lambda</a>()</code>,
<code><a href="#topic+tfam_inertia">tfam_inertia</a>()</code>,
<code><a href="#topic+tfam_lambda">tfam_lambda</a>()</code>,
<code><a href="#topic+tfs_inertia">tfs_inertia</a>()</code>
</p>
<p>Other PerturbationAnalyses: 
<code><a href="#topic+elas">elas</a>()</code>,
<code><a href="#topic+sens">sens</a>()</code>,
<code><a href="#topic+tfa_inertia">tfa_inertia</a>()</code>,
<code><a href="#topic+tfa_lambda">tfa_lambda</a>()</code>,
<code><a href="#topic+tfam_inertia">tfam_inertia</a>()</code>,
<code><a href="#topic+tfam_lambda">tfam_lambda</a>()</code>,
<code><a href="#topic+tfs_inertia">tfs_inertia</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a 3x3 matrix
  ( A &lt;- matrix(c(0,1,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Calculate the sensitivity matrix
  tfsm_lambda(A)

  # Calculate the sensitivity of simultaneous perturbation to 
  # A[1,2] and A[1,3]
  tfs_lambda(A, d=c(1,0,0), e=c(0,1,1))

  # Calculate the sensitivity of simultaneous perturbation to 
  # A[1,2] and A[1,3] and return and plot the fitting process
  tfs_lambda(A, d=c(1,0,0), e=c(0,1,1),
             return.fit=TRUE, plot.fit=TRUE)

</code></pre>

<hr>
<h2 id='Tort'>Desert tortoise matrix</h2><span id='topic+Tort'></span>

<h3>Description</h3>

<p>Matrix Projection Model for the desert tortoise <em>Gopherus agassizii</em> 
with medium fecundity. The matrix is based on a population in the Western 
Mojave desert. Stages are based on age and size 
(carapace length in mm):<br />
Stage 1: Yearling (age 0-1)<br />
Stage 2: Juvenile 1 (&lt;60 mm)<br />
Stage 3: Juvenile 2 (90-99mm)<br />
Stage 4: Immature 1 (100-139mm)<br />
Stage 5: Immature 2 (140-179mm)<br />
Stage 6: Subadult (180-207mm)<br />
Stage 7: Adult 1 (208-239mm)<br />
Stage 8: Adult 2 (&gt;240mm).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Tort)
</code></pre>


<h3>Format</h3>

<p>Object of class <code>matrix</code>
</p>


<h3>References</h3>


<ul>
<li><p> Doak et al. (1994) Ecol. Appl., 4, 446-460.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  # read in data and view
  data(Tort)
  Tort

</code></pre>

<hr>
<h2 id='truelambda'>Calculate asymptotic growth</h2><span id='topic+truelambda'></span>

<h3>Description</h3>

<p>Calculate the true asymptotic growth of a population matrix projection model
from the model projection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>truelambda(A, vector = "n", accuracy = 1e-07, iterations = 1e+05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="truelambda_+3A_a">A</code></td>
<td>
<p>a square, non-negative numeric matrix of any dimension</p>
</td></tr>
<tr><td><code id="truelambda_+3A_vector">vector</code></td>
<td>
<p>(optional) a numeric vector or one-column matrix describing 
the age/stage distribution used to calculate the projection.</p>
</td></tr>
<tr><td><code id="truelambda_+3A_accuracy">accuracy</code></td>
<td>
<p>the accuracy with which to determine convergence on 
asymptotic growth, expressed as a proportion (see details).</p>
</td></tr>
<tr><td><code id="truelambda_+3A_iterations">iterations</code></td>
<td>
<p>the maximum number of iterations of the model before the 
code breaks.  For slowly-converging models and/or high specified convergence
accuracy, this may need to be increased.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>truelambda</code> works by simulating the given model and manually determining 
growth when convergence to the given <code>accuracy</code> is reached. Convergence 
on an asymptotic growth is deemed to have been reached when the growth of the 
model stays within the window determined by <code>accuracy</code> for 10*s 
iterations of the model, with s equal to the dimension of <code>A</code>. For example, 
projection of an 8 by 8 matrix with convergence accuracy of 1e-2 is deemed to 
have converged on asymptotic growth when 10*8=80 consecutive iterations of the 
model have a growth within 1-1e-2=0.99 (i.e. 99%) and 1+1e-2=1.01 (i.e. 101%) 
of each other.
</p>
<p>If <code>vector</code> is specified, then the asymptotic growth of the projection of 
<code>vector</code> through <code>A</code> is returned. If <code>vector="n"</code> then 
asymptotic growths of the set of 'stage-biased' vectors are calculated. These 
projections are achieved using a set of standard basis vectors equal in number 
to the dimension of <code>A</code>. These have every element equal to 0, except for 
a single element equal to 1, i.e. for a matrix of dimension 3, the set of 
stage-biased vectors are: <code>c(1,0,0)</code>, <code>c(0,1,0)</code> and 
<code>c(0,0,1)</code>.
</p>
<p>Asymptotic growth should be equal to the dominant eigenvalue of the matrix. For
non-ergodic models this may not be the case: asymptotic growth will depend on
the population structure that's projected. <code>truelambda</code> provides a means
to check what the true asymptotic growth of a non-ergodic model is.
</p>


<h3>Value</h3>

<p>If <code>vector</code> is specified, a numeric vector of length 2 giving the range in 
which asymptoticgrowth of the model lies.
</p>
<p>If <code>vector</code> is not specified, a 2-column matrix with each row giving the 
range in which asymptotic growth lies for its corresponding stage-biased 
projection: the number of rows is equal to the dimension of <code>A</code>; the first 
row is the range when projecting [1,0,0,...], the second entry is the range when 
projecting [0,1,0,...], etc.
</p>


<h3>References</h3>


<ul>
<li><p> Stott et al. (2010) Methods Ecol. Evol., 1, 242-252.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other ConvergenceMeasures: 
<code><a href="#topic+convt">convt</a>()</code>,
<code><a href="#topic+dr">dr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a 3x3 irreducible PPM
  ( A &lt;- matrix(c(0,0,2,0.5,0.1,0,0,0.6,0.6), byrow=TRUE, ncol=3) )

  # Create an initial stage structure
  ( initial &lt;- c(1,3,2) )

  # Calculate the true asymptotic growth of the stage-biased
  # projections of A
  truelambda(A)

  # Calculate the true asymptotic growth of the projection of
  # A and initial
  truelambda(A, vector=initial)

  # Create a 3x3 reducible, nonergodic PPM
  B&lt;-A; B[3,2] &lt;- 0; B

  # Calculate the true asymptotic growth of the 3 stage-biased
  # projections of B
  truelambda(B)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
