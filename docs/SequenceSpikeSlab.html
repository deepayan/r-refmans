<!DOCTYPE html><html lang="en"><head><title>Help for package SequenceSpikeSlab</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SequenceSpikeSlab}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SequenceSpikeSlab-package'><p>Fast Exact Bayesian Inference for the Sparse Normal Means Model</p></a></li>
<li><a href='#fast_spike_slab_beta'><p>Compute marginal posterior estimates for beta-spike-and-slab prior</p></a></li>
<li><a href='#general_sequence_model'><p>Compute marginal posterior estimates</p></a></li>
<li><a href='#SSS_discrete_spike_slab'><p>Compute marginal posterior probabilities (slab probabilities) that data points have</p>
non-zero mean for the discretized spike-and-slab prior.</a></li>
<li><a href='#SSS_discretize_Lambda'><p>Given a prior Lambda on the alpha-parameter in the spike-and-slab model,</p>
make a discretized version of Lambda that is only supported on a grid of
approximately m * sqrt(n) discrete values of alpha. This discretized
version of Lambda is required as input for
<code>SSS_discrete_spike_slab</code>.
NB Lambda needs to satisfy a technical condition from the
paper that guarantees its density does not vary too rapidly. For
Lambda=Beta(kappa,lambda) use <code>SSS_discretize_Lambda_beta</code>
instead.</a></li>
<li><a href='#SSS_discretize_Lambda_beta'><p>Given prior Lambda=Beta(kappa,lambda) on the alpha-parameter in the</p>
spike-and-slab model, make a discretized version of Lambda that is only
supported on a grid of approximately m * sqrt(n) discrete values of alpha.
This discretized version of Lambda is required as input for
SSS_discrete_spike_slab.</a></li>
<li><a href='#SSS_hierarchical_prior'><p>Compute marginal posterior probabilities (slab probabilities) that data points have</p>
non-zero mean for the hierarchical prior.</a></li>
<li><a href='#SSS_hierarchical_prior_binomial'><p>Compute marginal posterior probabilities (slab probabilities) that data points have</p>
non-zero mean using the general hierarchical prior algorithm, but specialized to
the Beta[kappa,lambda]-binomial prior. This function is equivalent to calling
<code>SSS_hierarchical_prior</code> with
logprior = lbeta(kappa+(0:n),lambda+n-(0:n)) - lbeta(kappa,lambda) + lchoose(n,0:n),
but more convenient when using the Beta[kappa,lambda]-binomial prior and with a
minor interior optimization that avoids calculating the choose explicitly.</a></li>
<li><a href='#SSS_log_phi_psi_Cauchy'><p>Calculate log of phi and psi marginal densities for Cauchy(gamma) slab</p></a></li>
<li><a href='#SSS_log_phi_psi_Laplace'><p>Calculate log of phi and psi marginal densities for Laplace(lambda) slab</p></a></li>
<li><a href='#SSS_make_beta_grid'><p>Creates a vector of uniformly spaced grid points in the beta parametrization</p>
Ensures the number of generated grid points is &gt;= mingridpoints (which does
not have to be integer), and that their number is always odd so there is always
a grid point at pi/4.</a></li>
<li><a href='#SSS_postmean_Cauchy'><p>Compute posterior means of data points for the Cauchy(gamma) slab</p></a></li>
<li><a href='#SSS_postmean_Laplace'><p>Compute posterior means of data points for the Laplace(lambda) slab</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Exact Bayesian Model Selection Methods for the Sparse Normal
Sequence Model</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Steven de Rooij [aut],
  Tim van Erven [cre, aut],
  Botond Szabo [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tim van Erven &lt;tim@timvanerven.nl&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains fast functions to calculate the exact Bayes posterior
    for the Sparse Normal Sequence Model, implementing the algorithms
    described in Van Erven and Szabo (2021,
    &lt;<a href="https://doi.org/10.1214%2F20-BA1227">doi:10.1214/20-BA1227</a>&gt;). For general hierarchical
    priors, sample sizes up to 10,000 are feasible within half an hour
    on a standard laptop. For beta-binomial spike-and-slab priors, a
    faster algorithm is provided, which can handle sample sizes of
    100,000 in half an hour. In the implementation, special care has
    been taken to assure numerical stability of the methods even for
    such large sample sizes.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.18), RcppProgress (&ge; 0.4.1), selectiveInference
(&ge; 1.2.5)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppProgress</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-08 12:29:47 UTC; tve</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-08 12:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='SequenceSpikeSlab-package'>Fast Exact Bayesian Inference for the Sparse Normal Means Model</h2><span id='topic+SequenceSpikeSlab'></span><span id='topic+SequenceSpikeSlab-package'></span>

<h3>Description</h3>

<p>The SequenceSpikeSlab package provides fast algorithms for exact Bayesian inference in the
sparse normal sequence model. It implements the methods of Van Erven and Szabo, 2021.
Special care has been taken to make the methods scale to large data sets, and to minimize
numerical errors (which arise in all software because floating point numbers are
represented with finite precision).
</p>


<h3>Details</h3>

<p>There are two main functions:
<code><a href="#topic+general_sequence_model">general_sequence_model</a></code> and <code><a href="#topic+fast_spike_slab_beta">fast_spike_slab_beta</a></code>.
</p>
<p>For more details see the help vignette:
<code>vignette("SequenceSpikeSlab-vignette", package="SequenceSpikeSlab")</code>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Tim van Erven <a href="mailto:tim@timvanerven.nl">tim@timvanerven.nl</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Steven de Rooij <a href="mailto:steven.de.rooij@gmail.com">steven.de.rooij@gmail.com</a>
</p>
</li>
<li><p> Botond Szabo <a href="mailto:botond.szabo@unibocconi.it">botond.szabo@unibocconi.it</a>
</p>
</li></ul>


<hr>
<h2 id='fast_spike_slab_beta'>Compute marginal posterior estimates for beta-spike-and-slab prior</h2><span id='topic+fast_spike_slab_beta'></span>

<h3>Description</h3>

<p>Computes marginal posterior probabilities (slab probabilities) that data points have
non-zero mean for the spike-and-slab prior with a Beta(beta_kappa,beta_lambda) prior
on the mixing parameter. The posterior mean is also provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_spike_slab_beta(
  x,
  sigma = 1,
  m = 20,
  slab = "Laplace",
  Laplace_lambda = 0.5,
  Cauchy_gamma = 1,
  beta_kappa = 1,
  beta_lambda,
  show_progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fast_spike_slab_beta_+3A_x">x</code></td>
<td>
<p>Vector of n data points</p>
</td></tr>
<tr><td><code id="fast_spike_slab_beta_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation of the Gaussian noise in the data. May also be set to &quot;auto&quot;,
in which case sigma is estimated using the estimateSigma function from the selectiveInference
package</p>
</td></tr>
<tr><td><code id="fast_spike_slab_beta_+3A_m">m</code></td>
<td>
<p>The number of discretization points used is proportional to m*sqrt(n). The larger m, the
better the approximation, but the runtime also increases linearly with m. The default m=20 usually
gives sufficient numerical precision.</p>
</td></tr>
<tr><td><code id="fast_spike_slab_beta_+3A_slab">slab</code></td>
<td>
<p>Slab distribution. Must be either &quot;Laplace&quot; or &quot;Cauchy&quot;.</p>
</td></tr>
<tr><td><code id="fast_spike_slab_beta_+3A_laplace_lambda">Laplace_lambda</code></td>
<td>
<p>Parameter of the Laplace slab</p>
</td></tr>
<tr><td><code id="fast_spike_slab_beta_+3A_cauchy_gamma">Cauchy_gamma</code></td>
<td>
<p>Parameter of the Cauchy slab</p>
</td></tr>
<tr><td><code id="fast_spike_slab_beta_+3A_beta_kappa">beta_kappa</code></td>
<td>
<p>Parameter of the beta-distribution</p>
</td></tr>
<tr><td><code id="fast_spike_slab_beta_+3A_beta_lambda">beta_lambda</code></td>
<td>
<p>Parameter of the beta-distribution. Default value=n+1</p>
</td></tr>
<tr><td><code id="fast_spike_slab_beta_+3A_show_progress">show_progress</code></td>
<td>
<p>Boolean that indicates whether to show a progress bar</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The run-time is O(m*n^(3/2)) on n data points, which means that doubling the size of the data
leads to an increase in computation time by approximately a factor of 2*sqrt(2)=2.8. Data sets of
size n=100,000 should be feasible within approximately 30 minutes.
</p>


<h3>Value</h3>

<p>list (postprobs, postmean, sigma), where postprobs is a vector of marginal posterior slab
probabilities that <code class="reqn">x[i]</code> has non-zero mean for <code class="reqn">i=1,...,n</code>; postmean is a vector with
the posterior mean for the <code class="reqn">x[i]</code>; and sigma is the value of sigma (this may be of
interest when the sigma=&quot;auto&quot; option is used)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Illustrate that fast_spike_slab_beta is a faster way to compute the same results as
# general_sequence_model on the beta-binomial prior

# Generate data
n &lt;- 500          # sample size
n_signal &lt;- 25    # number of non-zero theta
A &lt;- 5            # signal strength
theta &lt;- c(rep(A,n_signal), rep(0,n-n_signal))
x &lt;- theta + rnorm(n, sd=1)

# Choose slab
slab &lt;- "Cauchy"
Cauchy_gamma &lt;- 1

cat("Running fast_spike_slab_beta (fast for very large n)...\n")
res_fss &lt;- fast_spike_slab_beta(x, sigma=1, slab=slab, Cauchy_gamma=Cauchy_gamma)

cat("Running general_sequence_model (slower for very large n)...\n")
res_gsm &lt;- general_sequence_model(x, sigma=1, slab=slab,
                                  log_prior="beta-binomial", Cauchy_gamma=Cauchy_gamma)

cat("Maximum difference in marginal posterior slab probabilities:",
    max(abs(res_gsm$postprobs - res_fss$postprobs)))
cat("\nMaximum difference in posterior means:",
    max(abs(res_gsm$postmean - res_fss$postmean)), "\n")

# Plot means
M=max(abs(x))+1
plot(1:n, x, pch=20, ylim=c(-M,M), col='green', xlab="", ylab="",
     main="Posterior Means (Same for Both Methods)")
points(1:n, theta, pch=20, col='blue')
points(1:n, res_gsm$postmean, pch=20, col='black', cex=0.6)
points(1:n, res_fss$postmean, pch=20, col='magenta', cex=0.6)
legend("topright", legend=c("general_sequence_model", "fast_spike_slab_beta",
                            "data", "truth"),
       col=c("black", "magenta", "green", "blue"), pch=20, cex=0.7)
</code></pre>

<hr>
<h2 id='general_sequence_model'>Compute marginal posterior estimates</h2><span id='topic+general_sequence_model'></span>

<h3>Description</h3>

<p>This function computes marginal posterior probabilities (slab probabilities) that data points have
non-zero mean for the general hierarchical prior in the sparse normal sequence model. The posterior
mean is also provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>general_sequence_model(
  x,
  sigma = 1,
  slab = "Laplace",
  log_prior = "beta-binomial",
  Laplace_lambda = 0.5,
  Cauchy_gamma = 1,
  beta_kappa = 1,
  beta_lambda,
  show_progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="general_sequence_model_+3A_x">x</code></td>
<td>
<p>Vector of n data points</p>
</td></tr>
<tr><td><code id="general_sequence_model_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation of the Gaussian noise in the data. May also be set to &quot;auto&quot;,
in which case sigma is estimated using the estimateSigma function from the selectiveInference
package</p>
</td></tr>
<tr><td><code id="general_sequence_model_+3A_slab">slab</code></td>
<td>
<p>Slab distribution. Must be either &quot;Laplace&quot; or &quot;Cauchy&quot;.</p>
</td></tr>
<tr><td><code id="general_sequence_model_+3A_log_prior">log_prior</code></td>
<td>
<p>Vector of length n+1 containing the logarithms of the prior probabilities pi_n(s)
that the number of spikes is equal to s for s=0,...,n. It is allowed to use an unnormalized
prior that does
not sum to 1, because adding any constant to the log-prior probabilities does not change the
result. Instead of a vector, log_prior may also be set to &quot;beta-binomial&quot; as a
short-hand for log_prior = lbeta(beta_kappa+(0:n),beta_lambda+n-(0:n))
- lbeta(beta_kappa,beta_lambda) + lchoose(n,0:n).</p>
</td></tr>
<tr><td><code id="general_sequence_model_+3A_laplace_lambda">Laplace_lambda</code></td>
<td>
<p>Parameter of the Laplace slab</p>
</td></tr>
<tr><td><code id="general_sequence_model_+3A_cauchy_gamma">Cauchy_gamma</code></td>
<td>
<p>Parameter of the Cauchy slab</p>
</td></tr>
<tr><td><code id="general_sequence_model_+3A_beta_kappa">beta_kappa</code></td>
<td>
<p>Parameter of the beta-distribution in the beta-binomial prior</p>
</td></tr>
<tr><td><code id="general_sequence_model_+3A_beta_lambda">beta_lambda</code></td>
<td>
<p>Parameter of the beta-distribution in the beta-binomial prior. Default value=n+1</p>
</td></tr>
<tr><td><code id="general_sequence_model_+3A_show_progress">show_progress</code></td>
<td>
<p>Boolean that indicates whether to show a progress bar</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The run-time is O(n^2) on n data points, which means that doubling the size of the data
leads to an increase in computation time by approximately a factor of 4. Data sets of
size n=25,000 should be feasible within approximately 30 minutes.
</p>


<h3>Value</h3>

<p>list (postprobs, postmean, sigma), where postprobs is a vector of marginal posterior slab
probabilities that <code class="reqn">x[i]</code> has non-zero mean for <code class="reqn">i=1,...,n</code>; postmean is a vector with
the posterior mean for the <code class="reqn">x[i]</code>; and sigma is the value of sigma (this may be of
interest when the sigma=&quot;auto&quot; option is used)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Experiments similar to those of Castilo, Van der Vaart, 2012

# Generate data
n &lt;- 500           # sample size
n_signal &lt;- 25     # number of non-zero theta
A &lt;- 5             # signal strength
theta &lt;- c(rep(A,n_signal), rep(0,n-n_signal))
x &lt;- theta + rnorm(n, sd=1)

# Choose slab
slab &lt;- "Laplace"
Laplace_lambda &lt;- 0.5

# Prior 1
kappa1 &lt;- 0.4   # hyperparameter
logprior1 &lt;- c(0,-kappa1*(1:n)*log(n*3/(1:n)))
res1 &lt;- general_sequence_model(x, sigma=1,
                               slab=slab,
                               log_prior=logprior1,
                               Laplace_lambda=Laplace_lambda)
print("Prior 1: Elements with marginal posterior probability &gt;= 0.5:")
print(which(res1$postprobs &gt;= 0.5))

# Prior 2
kappa2 &lt;- 0.8   # hyperparameter
logprior2 &lt;- kappa2*lchoose(2*n-0:n,n)
res2 &lt;- general_sequence_model(x, sigma=1,
                               slab=slab,
                               log_prior=logprior2,
                               Laplace_lambda=Laplace_lambda)
print("Prior 2: Elements with marginal posterior probability &gt;= 0.5:")
print(which(res2$postprobs &gt;= 0.5))

# Prior 3
beta_kappa &lt;- 1      # hyperparameter
beta_lambda &lt;- n+1   # hyperparameter
res3 &lt;- general_sequence_model(x, sigma=1,
                               slab=slab,
                               log_prior="beta-binomial",
                               Laplace_lambda=Laplace_lambda)
print("Prior 3: Elements with marginal posterior probability &gt;= 0.5:")
print(which(res3$postprobs &gt;= 0.5))

# Plot means for all priors
M=max(abs(x))+1
plot(1:n, x, pch=20, ylim=c(-M,M), col='green', xlab="", ylab="", main="Posterior Means")
points(1:n, theta, pch=20, col='blue')
points(1:n, res1$postmean, pch=20, col='black', cex=0.6)
points(1:n, res2$postmean, pch=20, col='magenta', cex=0.6)
points(1:n, res3$postmean, pch=20, col='red', cex=0.6)
legend("topright", legend=c("posterior mean 1", "posterior mean 2", "posterior mean 3",
                            "data", "truth"),
       col=c("black", "magenta", "red", "green", "blue"), pch=20, cex=0.7)
</code></pre>

<hr>
<h2 id='SSS_discrete_spike_slab'>Compute marginal posterior probabilities (slab probabilities) that data points have
non-zero mean for the discretized spike-and-slab prior.</h2><span id='topic+SSS_discrete_spike_slab'></span>

<h3>Description</h3>

<p>Compute marginal posterior probabilities (slab probabilities) that data points have
non-zero mean for the discretized spike-and-slab prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SSS_discrete_spike_slab(log_phi_psi, dLambda, show_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SSS_discrete_spike_slab_+3A_log_phi_psi">log_phi_psi</code></td>
<td>
<p>List {logphi, logpsi} containing two vectors of the same length n
that represent a preprocessed version of the data. logphi and logpsi should contain
the logs of the phi and psi densities of the data points, as produced for instance
by <code><a href="#topic+SSS_log_phi_psi_Laplace">SSS_log_phi_psi_Laplace</a></code> or <code><a href="#topic+SSS_log_phi_psi_Cauchy">SSS_log_phi_psi_Cauchy</a></code></p>
</td></tr>
<tr><td><code id="SSS_discrete_spike_slab_+3A_dlambda">dLambda</code></td>
<td>
<p>Discretized Lambda prior, as generated by either
discretize_Lambda or discretize_Lambda_beta.</p>
</td></tr>
<tr><td><code id="SSS_discrete_spike_slab_+3A_show_progress">show_progress</code></td>
<td>
<p>Boolean that indicates whether to show a progress bar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector with marginal posterior slab probabilities that <code class="reqn">x[i]</code> has
non-zero mean for <code class="reqn">i=1,...,n</code>.
</p>

<hr>
<h2 id='SSS_discretize_Lambda'>Given a prior Lambda on the alpha-parameter in the spike-and-slab model,
make a discretized version of Lambda that is only supported on a grid of
approximately m * sqrt(n) discrete values of alpha. This discretized
version of Lambda is required as input for
<code><a href="#topic+SSS_discrete_spike_slab">SSS_discrete_spike_slab</a></code>.
NB Lambda needs to satisfy a technical condition from the
paper that guarantees its density does not vary too rapidly. For
Lambda=Beta(kappa,lambda) use <code><a href="#topic+SSS_discretize_Lambda_beta">SSS_discretize_Lambda_beta</a></code>
instead.</h2><span id='topic+SSS_discretize_Lambda'></span>

<h3>Description</h3>

<p>Given a prior Lambda on the alpha-parameter in the spike-and-slab model,
make a discretized version of Lambda that is only supported on a grid of
approximately m * sqrt(n) discrete values of alpha. This discretized
version of Lambda is required as input for
<code><a href="#topic+SSS_discrete_spike_slab">SSS_discrete_spike_slab</a></code>.
NB Lambda needs to satisfy a technical condition from the
paper that guarantees its density does not vary too rapidly. For
Lambda=Beta(kappa,lambda) use <code><a href="#topic+SSS_discretize_Lambda_beta">SSS_discretize_Lambda_beta</a></code>
instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SSS_discretize_Lambda(m = 20, n, log_Lambda_cdf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SSS_discretize_Lambda_+3A_m">m</code></td>
<td>
<p>A multiplier for the number of discretization points</p>
</td></tr>
<tr><td><code id="SSS_discretize_Lambda_+3A_n">n</code></td>
<td>
<p>The sample size</p>
</td></tr>
<tr><td><code id="SSS_discretize_Lambda_+3A_log_lambda_cdf">log_Lambda_cdf</code></td>
<td>
<p>A function that takes as input a value of alpha and
calculates the log of the cumulative distribution function of Lambda at alpha</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List (alpha_grid, log_probs), where alpha_grid is a vector with the
generated grid points, and log_probs are the logs of the prior probabilities
of these grid points for the discretized Lambda prior.
</p>

<hr>
<h2 id='SSS_discretize_Lambda_beta'>Given prior Lambda=Beta(kappa,lambda) on the alpha-parameter in the
spike-and-slab model, make a discretized version of Lambda that is only
supported on a grid of approximately m * sqrt(n) discrete values of alpha.
This discretized version of Lambda is required as input for
SSS_discrete_spike_slab.</h2><span id='topic+SSS_discretize_Lambda_beta'></span>

<h3>Description</h3>

<p>Given prior Lambda=Beta(kappa,lambda) on the alpha-parameter in the
spike-and-slab model, make a discretized version of Lambda that is only
supported on a grid of approximately m * sqrt(n) discrete values of alpha.
This discretized version of Lambda is required as input for
SSS_discrete_spike_slab.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SSS_discretize_Lambda_beta(m = 20, n, kappa, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SSS_discretize_Lambda_beta_+3A_m">m</code></td>
<td>
<p>A multiplier for the number of discretization points</p>
</td></tr>
<tr><td><code id="SSS_discretize_Lambda_beta_+3A_n">n</code></td>
<td>
<p>The sample size</p>
</td></tr>
<tr><td><code id="SSS_discretize_Lambda_beta_+3A_kappa">kappa</code></td>
<td>
<p>Parameter of the prior. Needs to be at least 0.5.</p>
</td></tr>
<tr><td><code id="SSS_discretize_Lambda_beta_+3A_lambda">lambda</code></td>
<td>
<p>Parameter of the prior. Needs to be at least 0.5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List (alpha_grid, log_probs), where alpha_grid is a vector with the
generated grid points, and log_probs are the logs of the prior probabilities
of these grid points for the discretized Lambda prior.
</p>

<hr>
<h2 id='SSS_hierarchical_prior'>Compute marginal posterior probabilities (slab probabilities) that data points have
non-zero mean for the hierarchical prior.</h2><span id='topic+SSS_hierarchical_prior'></span>

<h3>Description</h3>

<p>Compute marginal posterior probabilities (slab probabilities) that data points have
non-zero mean for the hierarchical prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SSS_hierarchical_prior(log_phi_psi, logprior, show_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SSS_hierarchical_prior_+3A_log_phi_psi">log_phi_psi</code></td>
<td>
<p>List {logphi, logpsi} containing two vectors of the same length n
that represent a preprocessed version of the data. logphi and logpsi should contain
the logs of the phi and psi densities of the data points, as produced for instance
by <code><a href="#topic+SSS_log_phi_psi_Laplace">SSS_log_phi_psi_Laplace</a></code> or <code><a href="#topic+SSS_log_phi_psi_Cauchy">SSS_log_phi_psi_Cauchy</a></code></p>
</td></tr>
<tr><td><code id="SSS_hierarchical_prior_+3A_logprior">logprior</code></td>
<td>
<p>vector of length n+1 with components logprior[p]=log(pi_n(p)) for
<code class="reqn">p=0,...,n</code></p>
</td></tr>
<tr><td><code id="SSS_hierarchical_prior_+3A_show_progress">show_progress</code></td>
<td>
<p>Boolean that indicates whether to show a progress bar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector with marginal posterior slab probabilities that <code class="reqn">x[i]</code> has
non-zero mean for <code class="reqn">i=1,...,n</code>.
</p>

<hr>
<h2 id='SSS_hierarchical_prior_binomial'>Compute marginal posterior probabilities (slab probabilities) that data points have
non-zero mean using the general hierarchical prior algorithm, but specialized to
the Beta[kappa,lambda]-binomial prior. This function is equivalent to calling
<code><a href="#topic+SSS_hierarchical_prior">SSS_hierarchical_prior</a></code> with
logprior = lbeta(kappa+(0:n),lambda+n-(0:n)) - lbeta(kappa,lambda) + lchoose(n,0:n),
but more convenient when using the Beta[kappa,lambda]-binomial prior and with a
minor interior optimization that avoids calculating the choose explicitly.</h2><span id='topic+SSS_hierarchical_prior_binomial'></span>

<h3>Description</h3>

<p>Compute marginal posterior probabilities (slab probabilities) that data points have
non-zero mean using the general hierarchical prior algorithm, but specialized to
the Beta[kappa,lambda]-binomial prior. This function is equivalent to calling
<code><a href="#topic+SSS_hierarchical_prior">SSS_hierarchical_prior</a></code> with
logprior = lbeta(kappa+(0:n),lambda+n-(0:n)) - lbeta(kappa,lambda) + lchoose(n,0:n),
but more convenient when using the Beta[kappa,lambda]-binomial prior and with a
minor interior optimization that avoids calculating the choose explicitly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SSS_hierarchical_prior_binomial(
  log_phi_psi,
  kappa,
  lambda,
  show_progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SSS_hierarchical_prior_binomial_+3A_log_phi_psi">log_phi_psi</code></td>
<td>
<p>List {logphi, logpsi} containing two vectors of the same length n
that represent a preprocessed version of the data. logphi and logpsi should contain
the logs of the phi and psi densities of the data points, as produced for instance
by <code><a href="#topic+SSS_log_phi_psi_Laplace">SSS_log_phi_psi_Laplace</a></code> or <code><a href="#topic+SSS_log_phi_psi_Cauchy">SSS_log_phi_psi_Cauchy</a></code></p>
</td></tr>
<tr><td><code id="SSS_hierarchical_prior_binomial_+3A_kappa">kappa</code></td>
<td>
<p>First parameter of the beta-distribution</p>
</td></tr>
<tr><td><code id="SSS_hierarchical_prior_binomial_+3A_lambda">lambda</code></td>
<td>
<p>Second parameter of the beta-distribution</p>
</td></tr>
<tr><td><code id="SSS_hierarchical_prior_binomial_+3A_show_progress">show_progress</code></td>
<td>
<p>Boolean that indicates whether to show a progress bar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector with marginal posterior slab probabilities that <code class="reqn">x[i]</code> has
non-zero mean for <code class="reqn">i=1,...,n</code>.
</p>

<hr>
<h2 id='SSS_log_phi_psi_Cauchy'>Calculate log of phi and psi marginal densities for Cauchy(gamma) slab</h2><span id='topic+SSS_log_phi_psi_Cauchy'></span>

<h3>Description</h3>

<p>Calculate log of densities phi and psi for data vector x, where
</p>
<p style="text-align: center;"><code class="reqn">phi[i] = Normal(x[i], sigma^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">psi[i]) = E_Cauchy(\theta)[Normal(x[i] - \theta, sigma^2)]</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>SSS_log_phi_psi_Cauchy(x, sigma, gamma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SSS_log_phi_psi_Cauchy_+3A_x">x</code></td>
<td>
<p>data vector</p>
</td></tr>
<tr><td><code id="SSS_log_phi_psi_Cauchy_+3A_sigma">sigma</code></td>
<td>
<p>standard deviation of observations</p>
</td></tr>
<tr><td><code id="SSS_log_phi_psi_Cauchy_+3A_gamma">gamma</code></td>
<td>
<p>parameter of Cauchy slab density</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list (phi, psi), containing logs of phi and psi densities
</p>

<hr>
<h2 id='SSS_log_phi_psi_Laplace'>Calculate log of phi and psi marginal densities for Laplace(lambda) slab</h2><span id='topic+SSS_log_phi_psi_Laplace'></span>

<h3>Description</h3>

<p>Calculate log of densities phi and psi for data vector x, where
</p>
<p style="text-align: center;"><code class="reqn">phi[i] = Normal(x[i], sigma^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">psi[i]) = E_Laplace(\theta)[Normal(x[i] - \theta, sigma^2)]</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>SSS_log_phi_psi_Laplace(x, sigma, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SSS_log_phi_psi_Laplace_+3A_x">x</code></td>
<td>
<p>data vector</p>
</td></tr>
<tr><td><code id="SSS_log_phi_psi_Laplace_+3A_sigma">sigma</code></td>
<td>
<p>standard deviation of observations</p>
</td></tr>
<tr><td><code id="SSS_log_phi_psi_Laplace_+3A_lambda">lambda</code></td>
<td>
<p>parameter of Laplace slab density</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list (phi, psi), containing logs of phi and psi densities
</p>

<hr>
<h2 id='SSS_make_beta_grid'>Creates a vector of uniformly spaced grid points in the beta parametrization
Ensures the number of generated grid points is &gt;= mingridpoints (which does
not have to be integer), and that their number is always odd so there is always 
a grid point at pi/4.</h2><span id='topic+SSS_make_beta_grid'></span>

<h3>Description</h3>

<p>Creates a vector of uniformly spaced grid points in the beta parametrization
Ensures the number of generated grid points is &gt;= mingridpoints (which does
not have to be integer), and that their number is always odd so there is always 
a grid point at pi/4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SSS_make_beta_grid(minngridpoints)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SSS_make_beta_grid_+3A_minngridpoints">minngridpoints</code></td>
<td>
<p>Minimum number of grid points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of betagrid points
</p>

<hr>
<h2 id='SSS_postmean_Cauchy'>Compute posterior means of data points for the Cauchy(gamma) slab</h2><span id='topic+SSS_postmean_Cauchy'></span>

<h3>Description</h3>

<p>Compute posterior means of data points for the Cauchy(gamma) slab
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SSS_postmean_Cauchy(x, logpsi, postprobs, sigma, gamma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SSS_postmean_Cauchy_+3A_x">x</code></td>
<td>
<p>Data vector of length n</p>
</td></tr>
<tr><td><code id="SSS_postmean_Cauchy_+3A_logpsi">logpsi</code></td>
<td>
<p>Vector of length n that represents a preprocessed version of the data.
It should contain the logs of the psi densities of the data points, as produced 
by <code><a href="#topic+SSS_log_phi_psi_Cauchy">SSS_log_phi_psi_Cauchy</a></code>.</p>
</td></tr>
<tr><td><code id="SSS_postmean_Cauchy_+3A_postprobs">postprobs</code></td>
<td>
<p>Vector of marginal posterior slab probabilities that <code class="reqn">x[i]</code> has
non-zero mean for <code class="reqn">i=1,...,n</code>.</p>
</td></tr>
<tr><td><code id="SSS_postmean_Cauchy_+3A_sigma">sigma</code></td>
<td>
<p>standard deviation of observations</p>
</td></tr>
<tr><td><code id="SSS_postmean_Cauchy_+3A_gamma">gamma</code></td>
<td>
<p>parameter of Cauchy slab density</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of n posterior means
</p>

<hr>
<h2 id='SSS_postmean_Laplace'>Compute posterior means of data points for the Laplace(lambda) slab</h2><span id='topic+SSS_postmean_Laplace'></span>

<h3>Description</h3>

<p>Compute posterior means of data points for the Laplace(lambda) slab
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SSS_postmean_Laplace(x, logpsi, postprobs, sigma, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SSS_postmean_Laplace_+3A_x">x</code></td>
<td>
<p>Data vector of length n</p>
</td></tr>
<tr><td><code id="SSS_postmean_Laplace_+3A_logpsi">logpsi</code></td>
<td>
<p>Vector of length n that represents a preprocessed version of the data.
It should contain the logs of the psi densities of the data points, as produced 
by <code><a href="#topic+SSS_log_phi_psi_Laplace">SSS_log_phi_psi_Laplace</a></code>.</p>
</td></tr>
<tr><td><code id="SSS_postmean_Laplace_+3A_postprobs">postprobs</code></td>
<td>
<p>Vector of marginal posterior slab probabilities that <code class="reqn">x[i]</code> has
non-zero mean for <code class="reqn">i=1,...,n</code>.</p>
</td></tr>
<tr><td><code id="SSS_postmean_Laplace_+3A_sigma">sigma</code></td>
<td>
<p>standard deviation of observations</p>
</td></tr>
<tr><td><code id="SSS_postmean_Laplace_+3A_lambda">lambda</code></td>
<td>
<p>parameter of Laplace slab density</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of n posterior means
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
