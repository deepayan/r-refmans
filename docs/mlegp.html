<!DOCTYPE html><html lang="en"><head><title>Help for package mlegp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mlegp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mlegp-package'>
<p>mlegp package</p></a></li>
<li><a href='#createGP'><p> creates a Gaussian process object</p></a></li>
<li><a href='#createWindow'><p> Gaussian Process Plotting Functions</p></a></li>
<li><a href='#CV'><p> Gaussian process cross-validation</p></a></li>
<li><a href='#gp.list'><p> Gaussian Process Lists</p></a></li>
<li><a href='#is.gp'><p> Gaussian Process and Gaussian Process Lists</p></a></li>
<li><a href='#mlegp'><p> mlegp: maximum likelihood estimation of Gaussian process parameters</p></a></li>
<li><a href='#mlegp-internal'><p> Internal Functions for Gaussian Processes</p></a></li>
<li><a href='#mlegp-naming-functions'><p> mlegp naming functions</p></a></li>
<li><a href='#mlegp-nugget-related'><p> Gaussian Process Nugget Related Functions</p></a></li>
<li><a href='#mlegp-parameter-lookup'><p> Parameter Lookup Functions</p></a></li>
<li><a href='#mlegp-svd-functions'><p> Singular Value Decomposition functions for mlegp</p></a></li>
<li><a href='#plot.gp'><p> Diagnostic Plots for Gaussian processes</p></a></li>
<li><a href='#plot.gp.list'><p> Diagnostics Plots for Gaussian Process Lists</p></a></li>
<li><a href='#plotObservedEffects'><p> Plot Observed Values Vs. Each Dimension of the Design Matrix</p></a></li>
<li><a href='#predict.gp'><p> Gaussian Process Predictions</p></a></li>
<li><a href='#print.gp'><p> Gaussian Process Summary Information</p></a></li>
<li><a href='#print.gp.list'><p> Gaussian Process List Summary Information</p></a></li>
<li><a href='#summary.gp'><p> Gaussian Process Summary Information</p></a></li>
<li><a href='#summary.gp.list'><p> Gaussian Process List Summary Information</p></a></li>
<li><a href='#uniqueSummary'><p> Summary of outputs for each unique input</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Maximum Likelihood Estimates of Gaussian Processes</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-03-07</td>
</tr>
<tr>
<td>Author:</td>
<td>Garrett M. Dancik</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Garrett M. Dancik &lt;dancikg@easternct.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>snowfall</td>
</tr>
<tr>
<td>Description:</td>
<td>Maximum likelihood Gaussian process modeling for
        univariate and multi-dimensional outputs with diagnostic plots 
        following Santner et al (2003) &lt;<a href="https://doi.org/10.1007%2F978-1-4757-3799-8">doi:10.1007/978-1-4757-3799-8</a>&gt;.
        Contact the maintainer for a package version that includes 
        sensitivity analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-10 13:03:59 UTC; dancikg</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-10 13:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mlegp-package'>
mlegp package
</h2><span id='topic+mlegp-package'></span>

<h3>Description</h3>

<p>Maximum likelihood Gaussian process modeling for univariate and multi-dimensional outputs with diagnostic plots and sensitivity analysis. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> mlegp</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2007-12-05</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> Gnu General Public License (Version 3)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>This package obtains maximum likelihood estimates of Gaussian processes (GPs) for univariate and multi-dimensional outputs, for Gaussian processes with product exponential correlation structure; a constant or linear regression mean function; no nugget term, constant nugget term, or a nugget matrix that can be specified up to a multiplicative constant. The latter provides some flexibility for using GPs to model heteroscedastic responses.
</p>
<p>Multi-dimensional output can be modelled by fitting independent GPs to each output, or to the most important principle component weights following singular value decomposition of the output. Plotting of main effects for functional output is also implemented.
</p>
<p>Contact the maintainer for a package version that implements sensitivity analysis including Functional Analysis of Variance (FANOVA) decomposition, plotting functions to obtain diagnostic plots, main effects, and two-way factor interactions.
</p>
<p>For a complete list of functions, use 'library(help=&quot;mlegp&quot;)'.
</p>


<h3>Author(s)</h3>

<p> Garrett M. Dancik <a href="mailto:dancikg@easternct.edu">dancikg@easternct.edu</a> </p>


<h3>References</h3>

<p>Santner, T.J. Williams, B.J., Notz, W., 2003. The Design and Analysis of Computer Experiments (New York: Springer).
</p>
<p>Schonlau, M. and Welch, W. 2006. Screening the Input Variables to a Computer Model Via Analysis of Variance and Visualization, in Screening: Methods for Experimentation in Industry, Drug Discovery, and Genetics. A Dean and S. Lewis, eds. (New York: Springer). 
</p>
<p>Heitmann, K., Higdon, D., Nakhleh, C., Habib, S., 2006. Cosmic Calibration. The Astrophysical Journal, 646, 2, L1-L4.
</p>
<p><a href="https://github.com/gdancik/mlegp/">https://github.com/gdancik/mlegp/</a> 
</p>

<hr>
<h2 id='createGP'> creates a Gaussian process object </h2><span id='topic+createGP'></span>

<h3>Description</h3>

<p>creates a Gaussian process <code>gp</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createGP(X, Z, beta, a, meanReg, sig2, nugget, 
         param.names = 1:dim(X)[2], constantMean = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createGP_+3A_x">X</code></td>
<td>
<p> the design matrix </p>
</td></tr>
<tr><td><code id="createGP_+3A_z">Z</code></td>
<td>
<p> output obtained from the design matrix <code>X</code>, as a vector or a 1-column matrix </p>
</td></tr>
<tr><td><code id="createGP_+3A_beta">beta</code></td>
<td>
<p> vector of correlation coefficients </p>
</td></tr>
<tr><td><code id="createGP_+3A_a">a</code></td>
<td>
<p> vector of smoothness parameters in the correlation function (if <code>mlegp</code> is used, these will be 2) </p>
</td></tr>
<tr><td><code id="createGP_+3A_meanreg">meanReg</code></td>
<td>
<p> the constant mean if <code>constantMean</code> = 1, otherwise the regression coefficients of the mean function such that <code>meanReg</code> pre-multiplied by (1 X) will produce the mean matrix  </p>
</td></tr>
<tr><td><code id="createGP_+3A_sig2">sig2</code></td>
<td>
<p> the unconditional variance of the Gaussian process </p>
</td></tr>
<tr><td><code id="createGP_+3A_nugget">nugget</code></td>
<td>
<p> the constant nugget or a vector of length <code>nrow(X)</code> corresponding to the diagonal nugget matrix </p>
</td></tr>
<tr><td><code id="createGP_+3A_param.names">param.names</code></td>
<td>
<p> optional vector of parameter names (with length equal to <code>ncol(X)</code></p>
</td></tr>
<tr><td><code id="createGP_+3A_constantmean">constantMean</code></td>
<td>
<p> 1 if the Gaussian process has a constant mean; 0 otherwise </p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>gp</code> that contains the following components:
</p>
<table role = "presentation">
<tr><td><code>Z</code></td>
<td>
<p>matrix of observations</p>
</td></tr>
<tr><td><code>numObs</code></td>
<td>
<p> number of observations</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the design matrix</p>
</td></tr>
<tr><td><code>numDim</code></td>
<td>
<p> number of dimensions of X</p>
</td></tr> 
<tr><td><code>constantMean</code></td>
<td>
<p>1 if GP has a constant mean; 0 otherwise</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the mean matrix</p>
</td></tr>
<tr><td><code>Bhat</code></td>
<td>
<p>mean function regression coefficients</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>correlation parameters</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>smoothness parameters in correlation function</p>
</td></tr>
<tr><td><code>sig2</code></td>
<td>
<p>unconditional variance of predicted expected output</p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p>vector of parameter names, corresponding to columns of <code>X</code></p>
</td></tr>
<tr><td><code>invVarMatrix</code></td>
<td>
<p>inverse var-cov matrix</p>
</td></tr>
<tr><td><code>nugget</code></td>
<td>
<p>constant nugget or vector corresponding to the diagonal nugget matrix for a single observation generated from each element in <code>X</code> </p>
</td></tr>
<tr><td><code>loglike</code></td>
<td>
<p>the log likelihood of the observations</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>results from cross-validation, where
<code>cv[,1]</code> are the cross-validated predictions
<code>cv[,2]</code> are the variances of the cross-validated predictions</p>
</td></tr>
</table>


<h3>Note</h3>

<p> this function is called by <code>mlegp</code> and should not be called by the user </p>


<h3>Author(s)</h3>

<p> Garrett M. Dancik <a href="mailto:dancikg@easternct.edu">dancikg@easternct.edu</a> </p>


<h3>References</h3>

 <p><a href="https://github.com/gdancik/mlegp/">https://github.com/gdancik/mlegp/</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+mlegp">mlegp</a></code> </p>

<hr>
<h2 id='createWindow'> Gaussian Process Plotting Functions </h2><span id='topic+createWindow'></span>

<h3>Description</h3>

<p>sets the number of sections on the current device based on the number of figures to draw
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createWindow(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createWindow_+3A_n">n</code></td>
<td>
<p> the number of figures to draw </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sets the graphical device so that the number of columns (ncol) is trunc(sqrt(n)) and the number of rows is ceiling(n/ncol)
</p>
<p>This function is called by <code>mlegp</code> plotting functions that construct separate graphs for multiple parameters
</p>


<h3>Author(s)</h3>

<p> Garrett M. Dancik <a href="mailto:dancikg@easternct.edu">dancikg@easternct.edu</a> </p>


<h3>References</h3>

 <p><a href="https://github.com/gdancik/mlegp/">https://github.com/gdancik/mlegp/</a> </p>


<h3>See Also</h3>

<p> This function may be used by <code><a href="#topic+plot.gp">plot.gp</a></code>, among others </p>

<hr>
<h2 id='CV'> Gaussian process cross-validation  </h2><span id='topic+CV'></span><span id='topic+calcPredictionErrorCV'></span><span id='topic+predictNewYCV'></span>

<h3>Description</h3>

<p>For a Gaussian process, calculates cross-validated predictions and the variance of cross-validated predictions for all points of the design. These are cross-validated in the sense that when predicting output at design point x, all observations at x are removed from the collection of observed outputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CV(gp, predictObserved = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CV_+3A_gp">gp</code></td>
<td>
<p> an object of type <code>gp</code> </p>
</td></tr>
<tr><td><code id="CV_+3A_predictobserved">predictObserved</code></td>
<td>
<p> if <code>TRUE</code> (the default), the variance of a predicted observation is calculated (and a nugget term is added);  if <code>FALSE</code>, the variance of a predicted mean response is calculated (and a nugget term is NOT added)
</p>
</td></tr>
<tr><td><code id="CV_+3A_verbose">verbose</code></td>
<td>
<p> if <code>TRUE</code>, status is displayed following the cross-validation of each observation </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix where the first column corresponds to the cross-validated predictions and the second column corresponds to the variance of the cross-validated predictions
</p>


<h3>Author(s)</h3>

<p> Garrett M. Dancik <a href="mailto:dancikg@easternct.edu">dancikg@easternct.edu</a> </p>


<h3>References</h3>

 <p><a href="https://github.com/gdancik/mlegp">https://github.com/gdancik/mlegp</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+predict.gp">predict.gp</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## fit a single Gaussian process ##
x = -5:5; y1 = sin(x) + rnorm(length(x),sd=.1)
fit1 = mlegp(x, y1)

cv = CV(fit1)  ## note that cv is the same as fit1$cv

</code></pre>

<hr>
<h2 id='gp.list'> Gaussian Process Lists </h2><span id='topic+gp.list'></span>

<h3>Description</h3>

<p>Creates an object of type <code>gp.list</code>, given a list of Gaussian processes fit to separate sets of observations, or a list of Gaussian processes fit to principle component weights to approximate output of high dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gp.list(..., param.names = NULL, UD = NULL, gp.names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gp.list_+3A_...">...</code></td>
<td>
<p> either a <code>list</code> object, where each element is a Gaussian process; or several objects of type <code>gp</code> </p>
</td></tr>
<tr><td><code id="gp.list_+3A_param.names">param.names</code></td>
<td>
<p> optionally, the parameter names corresponding to the columns of the design matrix of all Gaussian processes. By default, this will be equal to the parameter names of the first Gaussian process in <code>...</code></p>
</td></tr>
<tr><td><code id="gp.list_+3A_ud">UD</code></td>
<td>
<p> the UD matrix, if the Gaussian process is fit to principle component weights </p>
</td></tr>
<tr><td><code id="gp.list_+3A_gp.names">gp.names</code></td>
<td>
<p> optionally, a vector of names for the Gaussian processes, defaulting to &lsquo;gp \#1&rsquo;, &lsquo;gp \#2&rsquo;, ...
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>gp.list</code> object is a <code>list</code> object, where the first k elements correspond to k Gaussian processes passed in as <code>...</code>. This makes it straightforward to access a single Gaussian process. In addition, <code>gp.list</code> contains components:
</p>
<table role = "presentation">
<tr><td><code>params</code></td>
<td>
<p>a vector of parameter names, corresponding to the columns of the design matrix</p>
</td></tr>
<tr><td><code>numGPs</code></td>
<td>
<p>the number of Gaussian processes in the list</p>
</td></tr>
<tr><td><code>numDim</code></td>
<td>
<p>the number of parameters in the design matrix</p>
</td></tr>
<tr><td><code>numObs</code></td>
<td>
<p>the number of observations</p>
</td></tr>
<tr><td><code>names</code></td>
<td>
<p>the names of the Gaussian processes</p>
</td></tr>
</table>


<h3>Note</h3>

 
<p>currently, we require that all Gaussian processes have the same dimension (number of columns in the design matrix) and the same number of observations
</p>
<p>this function is called by <code>mlegp</code> and should not be called by the user
</p>


<h3>Author(s)</h3>

<p> Garrett M. Dancik <a href="mailto:dancikg@easternct.edu">dancikg@easternct.edu</a> </p>


<h3>References</h3>

 <p><a href="https://github.com/gdancik/mlegp/">https://github.com/gdancik/mlegp/</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+mlegp">mlegp</a></code>, <code><a href="#topic+mlegp-svd-functions">mlegp-svd-functions</a></code> for more details about the UD matrix </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x = -5:5
  y1 = sin(x) + rnorm(length(x), sd=.1)
  y2 = sin(x) + rnorm(length(x), sd = .5)

  ## create the gp.list object ## 
  fitMulti = mlegp(x, cbind(y1,y2))

  plot(fitMulti)
 
  fitMulti   ## print summary of of the fitted Gaussian process list
  fitMulti[[2]]  ## print summary for the 2nd Gaussian process 

</code></pre>

<hr>
<h2 id='is.gp'> Gaussian Process and Gaussian Process Lists </h2><span id='topic+is.gp'></span><span id='topic+is.gp.list'></span>

<h3>Description</h3>

<p>Test for a Gaussian process object or a Gaussian process list object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.gp(x)
is.gp.list(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.gp_+3A_x">x</code></td>
<td>
<p> object to be tested </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is.gp</code> returns <code>TRUE</code> or <code>FALSE</code>, depending on whether its argument inherits the <code>gp</code> class or not
</p>
<p><code>is.gp.list</code> returns <code>TRUE</code> or <code>FALSE</code>, depending on whether its argument inherits the <code>gp.list</code> class or not
</p>


<h3>Author(s)</h3>

<p> Garrett M. Dancik <a href="mailto:dancikg@easternct.edu">dancikg@easternct.edu</a> </p>


<h3>References</h3>

 <p><a href="https://github.com/gdancik/mlegp/">https://github.com/gdancik/mlegp/</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## fit a single Gaussian process ##
x = -5:5; y1 = sin(x) + rnorm(length(x),sd=.1)
fit1 = mlegp(x, y1)

is.gp(fit1)       ## returns TRUE
is.gp.list(fit1)  ## returns FALSE
</code></pre>

<hr>
<h2 id='mlegp'> mlegp: maximum likelihood estimation of Gaussian process parameters </h2><span id='topic+mlegp'></span><span id='topic+mlegp2'></span><span id='topic+fitGPfromR'></span>

<h3>Description</h3>

<p>Finds maximum likelihood estimates of Gaussian process parameters for a vector (or matrix) of one (or more) responses. For multiple responses, the user chooses between fitting independent Gaussian processes to the separate responses or fitting independent Gaussian processes to principle component weights obtained through singular value decomposition of the output. The latter is useful for functional output or data rich situations. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlegp(X, Z, constantMean = 1, nugget = NULL, nugget.known = 0, 
      min.nugget = 0, param.names = NULL, gp.names = NULL, 
	  PC.UD = NULL, PC.num = NULL, PC.percent = NULL, 
	  simplex.ntries = 5, simplex.maxiter = 500, simplex.reltol = 1e-8,  
	  BFGS.maxiter = 500, BFGS.tol = 0.01, BFGS.h = 1e-10, seed = 0, 
      verbose = 1, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlegp_+3A_x">X</code></td>
<td>
<p> the design matrix </p>
</td></tr>
<tr><td><code id="mlegp_+3A_z">Z</code></td>
<td>
<p> vector or matrix of observations; corresponding to the rows of <code>X</code> </p>
</td></tr>
<tr><td><code id="mlegp_+3A_constantmean">constantMean</code></td>
<td>
<p> a value of 1 indicates that each Gaussian process will have a constant mean; otherwise the mean function will be a linear regression in <code>X</code>, plus an intercept term </p>
</td></tr>
<tr><td><code id="mlegp_+3A_nugget">nugget</code></td>
<td>
<p> if nugget.known is 1, a fixed value to use for the nugget or a vector corresponding to the fixed diagonal nugget matrix; otherwise, either a positive initial value for the nugget term which will be estimated, or a vector corresponding to the diagonal nugget matrix up to a multiplicative constant. If <code>NULL</code> (the default), <code>mlegp</code> estimates a nugget term only if there are replicates in the design matrix, see details</p>
</td></tr>
<tr><td><code id="mlegp_+3A_nugget.known">nugget.known</code></td>
<td>
<p>1 if a plug-in estimate of the nugget will be used; 0 otherwise</p>
</td></tr>
<tr><td><code id="mlegp_+3A_min.nugget">min.nugget</code></td>
<td>
<p> minimum value of the nugget term; 0 by default </p>
</td></tr>
<tr><td><code id="mlegp_+3A_param.names">param.names</code></td>
<td>
<p> a vector of parameter names, corresponding to the columns of X; parameter names are
&lsquo;p1&rsquo;, &lsquo;p2&rsquo;, ... by default </p>
</td></tr>
<tr><td><code id="mlegp_+3A_gp.names">gp.names</code></td>
<td>
<p> a vector of GP names, corresponding to the GPs fit to each column of <code>Z</code> or each PC weight </p>
</td></tr>
<tr><td><code id="mlegp_+3A_pc.ud">PC.UD</code></td>
<td>
<p> the UD matrix if <code>Z</code> is a matrix of principle component weights; see <code><a href="#topic+mlegp-svd-functions">mlegp-svd-functions</a></code> </p>
</td></tr>
<tr><td><code id="mlegp_+3A_pc.num">PC.num</code></td>
<td>
<p> the number of principle component weights to keep in the singular value decomposition of <code>Z</code> </p>
</td></tr>
<tr><td><code id="mlegp_+3A_pc.percent">PC.percent</code></td>
<td>
<p> if not <code>NULL</code> the number of principle component weights kept is the minimum number that accounts for <code>PC.percent</code> of the total variance of the matrix <code>Z</code> </p>
</td></tr>
<tr><td><code id="mlegp_+3A_simplex.ntries">simplex.ntries</code></td>
<td>
<p> the number of simplexes to run </p>
</td></tr>
<tr><td><code id="mlegp_+3A_simplex.maxiter">simplex.maxiter</code></td>
<td>
<p> maximum number of evaluations / simplex </p>
</td></tr>
<tr><td><code id="mlegp_+3A_simplex.reltol">simplex.reltol</code></td>
<td>
<p> relative tolerance for simplex method, defaulting to 1e-16 </p>
</td></tr>
<tr><td><code id="mlegp_+3A_bfgs.maxiter">BFGS.maxiter</code></td>
<td>
<p> maximum number of iterations for BFGS method </p>
</td></tr>
<tr><td><code id="mlegp_+3A_bfgs.tol">BFGS.tol</code></td>
<td>
<p> stopping condition for BFGS method is when norm(gradient) &lt; BFGS.tol * max(1, norm(x)), where x is the parameter vector and norm is the Euclidian norm </p>
</td></tr>
<tr><td><code id="mlegp_+3A_bfgs.h">BFGS.h</code></td>
<td>
<p> derivatives are approximated as [f(x+BFGS.h) - f(x)] / BFGS.h)  </p>
</td></tr>
<tr><td><code id="mlegp_+3A_seed">seed</code></td>
<td>
<p> the random number seed </p>
</td></tr>
<tr><td><code id="mlegp_+3A_verbose">verbose</code></td>
<td>
<p> a value of '1' or '2' will result in status updates being printed; a value of '2' results in more information </p>
</td></tr>
<tr><td><code id="mlegp_+3A_parallel">parallel</code></td>
<td>
<p> if TRUE will fit GPs in parallel to each column of Z, or each set of PC weights; See details </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls the C function fitGPFromR which in turn calls fitGP (both in the file fit_gp.h) to fit each Gaussian process.
</p>
<p>Separate Gaussian processes are fit to the observations in each column of <code>Z</code>. Maximum likelihood estimates for correlation and nugget parameters are found through numerical methods (i.e., the Nelder-Mead Simplex and the L-BFGS method), while maximum likelihood estimates of the mean regression parameters and overall variance are calculated in closed form (given the correlation and (scaled) nugget parameters). Multiple simplexes are run, and estimates from the best simplex are used as initial values to the gradient (L-BFGS) method. 
</p>
<p>Gaussian processes are fit to principle component weights by utilizing the singular value decomposition (SVD) of <code>Z</code>, Z = UDVprime. Columns of <code>Z</code> should correspond to a single k-dimensional observation (e.g., functional output of a computer model, evaluated at a particular input)      
</p>
<p>In the complete SVD, <code>Z</code> is k x m, and r = min(k,m), <code>U</code> is k x r, <code>D</code> is r x r, containing the singular values along the diagonal, and <code>Vprime</code> is r x m. The output <code>Z</code> is approximated by keeping l &lt; r singular values, keeping a UD matrix of dimension k x l, and the <code>Vprime</code> matrix of dimension l x m. Each column of <code>Vprime</code> now contains l principle component weights, which can be used to reconstruct the functional output.        
</p>
<p>If nugget.known = 1, nugget = NULL, and replicate observations are present, the nugget will be fixed at its best linear unbiased estimate (a weighted average of sample variances). 
For each column of Z, a GP will be fit to a collection of sample means rather than all observations. This is the recommended approach as it is more accurate and computationally more efficient. 
</p>
<p>Parallel support is provided through the package <code>snowfall</code> which allows multiple GPs to be fit in parallel. The user must set up the cluster using <code>sfInit</code> and call <code>sfLibrary(mlegp)</code> to load the library onto the slave nodes. Note: GP fitting is not recommended when the number of observations are large (&gt; 100), in which case sequential GP fitting is faster. </p>


<h3>Value</h3>

<p>an object of class <code>gp.list</code> if Z has more than 1 column, otherwise an object of class <code>gp</code> 
</p>


<h3>Note</h3>

<p> The random number seed is 0 by default, but should be randomly set by the user
</p>
<p>In some situations, especially for noiseless data, it may be desirable to force a nugget term in order to make the variance-covariance matrix of the Gaussian process more stable; this can be done by setting the argument <code>min.nugget</code>.
</p>
<p>If fitting multiple Gaussian processes, the arguments <code>min.nugget</code> and <code>nugget</code> apply to all Gaussian processes being fit.
</p>
<p>In some cases, the variance-covariance matrix is stable in C but not stable in R. When this happens, this function will attempt to impose a minimum value for the nugget term, and this will be reported. However, the user is encouraged to refit the GP and manually setting the argument <code>min.nugget</code> in <code>mlegp</code>.
</p>
<p>When fitting Gaussian processes to principle component weights, a minimum of two principle component weights must be used.
</p>


<h3>Author(s)</h3>

<p> Garrett M. Dancik <a href="mailto:dancikg@easternct.edu">dancikg@easternct.edu</a> </p>


<h3>References</h3>

 
<p>Santner, T.J. Williams, B.J., Notz, W., 2003. The Design and Analysis of Computer Experiments (New York: Springer).
</p>
<p>Heitmann, K., Higdon, D., Nakhleh, C., Habib, S., 2006. Cosmic Calibration. The Astrophysical Journal, 646, 2, L1-L4.
</p>
<p>Dancik, GM and Dorman, KS (2008). mlegp: statistical analysis for
computer models of biological systems using R. Bioinformatics 24(17), pp. 1966-1967
</p>
<p><a href="https://github.com/gdancik/mlegp/">https://github.com/gdancik/mlegp/</a> 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+createGP">createGP</a></code> for details of the <code>gp</code> object; <code><a href="#topic+gp.list">gp.list</a></code> for details of the <code>gp.list</code> object; <code><a href="#topic+mlegp-svd-functions">mlegp-svd-functions</a></code> for details on fitting Gaussian processes to high-dimensional data using principle component weights; the L-BFGS method uses C code written by Naoaki Okazaki (http://www.chokkan.org/software/liblbfgs)  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###### fit a single Gaussian process ######
x = -5:5; y1 = sin(x) + rnorm(length(x),sd=.1)
fit1 = mlegp(x, y1)

## summary and diagnostic plots ##
summary(fit1)
plot(fit1)

###### fit a single Gaussian process when replciates are present ######
x = kronecker(-5:5, rep(1,3))
y = x + rnorm(length(x))

## recommended approach: GP fit to sample means; nugget calcualted from sample variances ##
fit1 = mlegp(x,y, nugget.known = 1)

## original approach: GP fit to all observations; look for MLE of nugget ##
fit2 = mlegp(x,y)


###### fit multiple Gaussian processes to multiple observations ######
x = -5:5 
y1 = sin(x) + rnorm(length(x),sd=.1)
y2 = sin(x) + 2*x + rnorm(length(x), sd = .1)
fitMulti = mlegp(x, cbind(y1,y2))

## summary and diagnostic plots ##
summary(fitMulti)
plot(fitMulti)


###### fit multiple Gaussian processes using principle component weights ######

## generate functional output ##
x = seq(-5,5,by=.2)
p = 1:50
y = matrix(0,length(p), length(x))
for (i in p) {
	y[i,] = sin(x) + i + rnorm(length(x), sd  = .01)
}

## we now have 10 functional observations (each of length 100) ##
for (i in p) {
	plot(x,y[i,], type = "l", col = i, ylim = c(min(y), max(y)))
	par(new=TRUE)
}

## fit GPs to the two most important principle component weights ##
numPCs = 2
fitPC = mlegp(p, t(y), PC.num = numPCs)
plot(fitPC) ## diagnostics

## reconstruct the output Y = UDV'
Vprime = matrix(0,numPCs,length(p))
Vprime[1,] = predict(fitPC[[1]])
Vprime[2,] = predict(fitPC[[2]])

predY = fitPC$UD%*%Vprime
m1 = min(y[39,], predY[,39])
m2 = max(y[39,], predY[,39])

plot(x, y[39,], type="l", lty = 1, ylim = c(m1,m2), ylab = "original y" )
par(new=TRUE)
plot(x, predY[,39], type = "p", col = "red", ylim = c(m1,m2), ylab = "predicted y" )

## Not run: 
### fit GPs in parallel ###
library(snowfall)
sfInit(parallel = TRUE, cpus = 2, slaveOutfile = "slave.out")
sfLibrary(mlegp)
fitPC = mlegp(p, t(y), PC.num = 2, parallel = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='mlegp-internal'> Internal Functions for Gaussian Processes </h2><span id='topic+mlegp-internal'></span><span id='topic+calcVarMatrix'></span><span id='topic+calcCorOneObs'></span><span id='topic+calcLogLike'></span><span id='topic+calcLogLikeManual'></span><span id='topic+gpObs'></span><span id='topic+gpDim'></span>

<h3>Description</h3>

<p>Internal Functions for Gaussian Processes
</p>


<h3>Details</h3>

<p>These functions should not be called by the user
</p>


<h3>Author(s)</h3>

<p> Garrett M. Dancik <a href="mailto:dancikg@easternct.edu">dancikg@easternct.edu</a> </p>


<h3>References</h3>

 <p><a href="https://github.com/gdancik/mlegp/">https://github.com/gdancik/mlegp/</a> </p>

<hr>
<h2 id='mlegp-naming-functions'> mlegp naming functions </h2><span id='topic+mlegp-naming-functions'></span><span id='topic+setParams'></span><span id='topic+setGPNames'></span>

<h3>Description</h3>

<p>Functions that set the design matrix parameter names in a Gaussian process or Gaussian process list or the names of the Gaussian processes in a Gaussian process list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setParams(x, s)
setGPNames(x, s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlegp-naming-functions_+3A_x">x</code></td>
<td>
<p> an object of type <code>gp</code> or <code>gp.list</code> </p>
</td></tr>
<tr><td><code id="mlegp-naming-functions_+3A_s">s</code></td>
<td>
<p> a vector of parameter names or Gaussian process names to set </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>setParams</code> sets the parameter names of a Gaussian process (<code>gp</code>) object or of all Gaussian processes in a Gaussian process list (<code>gp.list</code>) object. <code>setGPNames</code> sets the names of the Gaussian processes in an object of type <code>gp.list</code>
</p>


<h3>Value</h3>

<p>the object <code>x</code> with parameter or Gaussian process names set   
</p>


<h3>Note</h3>

<p>Parameter and Gaussian process names are used in the output of various plotting functions. Both of these can also be set when the Gaussian process (list) is created by <code><a href="#topic+mlegp">mlegp</a></code>
</p>


<h3>Author(s)</h3>

<p> Garrett M. Dancik <a href="mailto:dancikg@easternct.edu">dancikg@easternct.edu</a> </p>


<h3>References</h3>

 <p><a href="https://github.com/gdancik/mlegp/">https://github.com/gdancik/mlegp/</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+mlegp">mlegp</a></code> for setting parameter and Gaussian process names during object creation </p>


<h3>Examples</h3>

<pre><code class='language-R'>## fit multiple Gaussian processes to multiple observations ##
x = -5:5
y1 = sin(x) + rnorm(length(x),sd=.1)
y2 = sin(x) + 2*x + rnorm(length(x), sd = .1)
fitMulti = mlegp(x, cbind(y1,y2))

## plot diagnostics with default gp names ##
plot(fitMulti)

## change names and plot again ##
fitMulti = setGPNames(fitMulti, c("y1", "y2"))
plot(fitMulti)

## plot diagnostic for the first Gaussian process, predicted vs. parameter ##
plot(fitMulti[[1]], type = 2)

## change parameter names (of all Gaussian processes) and plot again ##
fitMulti = setParams(fitMulti, "param 1")
plot(fitMulti[[1]], type = 2)
</code></pre>

<hr>
<h2 id='mlegp-nugget-related'> Gaussian Process Nugget Related Functions </h2><span id='topic+nugget'></span><span id='topic+varPerReps'></span><span id='topic+estimateNugget'></span><span id='topic+anyReps'></span>

<h3>Description</h3>

<p>Functions for detecting replicates and for calculating sample variance at specific design points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varPerReps(X, Y)
estimateNugget(X, Y)
anyReps(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlegp-nugget-related_+3A_x">X</code></td>
<td>
<p> the design matrix </p>
</td></tr>
<tr><td><code id="mlegp-nugget-related_+3A_y">Y</code></td>
<td>
<p> a vector (or 1 column matrix) of observations </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>varPerReps</code> returns a 1-column matrix where element i corresponds to the sample variance in observations corresponding to design point X[i]
</p>
<p><code>estimateNugget</code> returns a double calculated by taking the mean of the matrix returned by <code>varPerReps</code>
</p>
<p><code>anyReps</code> returns <code>TRUE</code> if two or more rows of <code>X</code> are identical
</p>


<h3>Note</h3>

  
<p>These functions are used by <code>mlegp</code> to set an initial value of the nugget when a constant nugget is being estimated. The function <code>varPerReps</code> may also be useful for specifying the form of the nugget matrix for use with <code>mlegp</code>. 
</p>


<h3>Author(s)</h3>

<p> Garrett M. Dancik <a href="mailto:dancikg@easternct.edu">dancikg@easternct.edu</a> </p>


<h3>References</h3>

 <p><a href="https://github.com/gdancik/mlegp/">https://github.com/gdancik/mlegp/</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = matrix(c(1,1,2,3,3))   # the design matrix
y = matrix(c(5,6,7,0,10))  # output

anyReps(x)
varPerReps(x,y)
estimateNugget(x,y)

</code></pre>

<hr>
<h2 id='mlegp-parameter-lookup'> Parameter Lookup Functions </h2><span id='topic+paramLookup'></span><span id='topic+toParamIndexes'></span><span id='topic+matchIndexes'></span>

<h3>Description</h3>

<p>These functions are used to match the name of a parameter with its position in a parameter list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toParamIndexes(m, string)
matchIndexes(m, string)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlegp-parameter-lookup_+3A_m">m</code></td>
<td>
<p> a vector of names of the parameters of interest </p>
</td></tr>
<tr><td><code id="mlegp-parameter-lookup_+3A_string">string</code></td>
<td>
<p> a vector of parameter names </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector where element i contains the position of <code>m[i]</code> in <code>string</code>
</p>
<p>if <code>m</code> contains integers and <code>toParamIndexes</code> is called, <code>m</code> will be returned, without a check of whether
or not the indices are valid
</p>
<p>if <code>m[i]</code> is not an element of <code>string</code>, <code>toParamIndexes</code> will display an error, whereas <code>matchIndexes</code> will return <code>NA</code>
</p>


<h3>Note</h3>

  
<p>this function does not need to be called by the user; it exists so that the user can pass in a vector of parameter numbers or parameter names to various functions when specifying a subset of the parameters of the Gaussian process design matrix
</p>
<p>for <code>toParamIndexes</code>, <code>m</code> can contain integers or characters, but cannot contain both 
</p>


<h3>Author(s)</h3>

<p> Garrett M. Dancik <a href="mailto:dancikg@easternct.edu">dancikg@easternct.edu</a> </p>


<h3>References</h3>

 <p><a href="https://github.com/gdancik/mlegp/">https://github.com/gdancik/mlegp/</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
param.names = c("one", "two", "three")
toParamIndexes(c("one", "three"), param.names)
#toParamIndexes(c("four"), param.names) # will give an error
</code></pre>

<hr>
<h2 id='mlegp-svd-functions'> Singular Value Decomposition functions for mlegp </h2><span id='topic+mlegp-svd-functions'></span><span id='topic+pcweights'></span><span id='topic+getSingularValues'></span><span id='topic+numSingularValues'></span><span id='topic+singularValueImportance'></span>

<h3>Description</h3>

<p>Functions that deal with the singular value decomposition of an output Y, for use with Gaussian process lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcweights(Y, weights.num = NULL, cutoff = 99)
getSingularValues(Y)
singularValueImportance(Y)
numSingularValues(Y, cutoff = 99)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlegp-svd-functions_+3A_y">Y</code></td>
<td>
<p> the output to decompose, where each column of <code>Y</code> correspond to k-dimensional output </p>
</td></tr>
<tr><td><code id="mlegp-svd-functions_+3A_weights.num">weights.num</code></td>
<td>
<p> optionally, the number of principle component weights to keep </p>
</td></tr>
<tr><td><code id="mlegp-svd-functions_+3A_cutoff">cutoff</code></td>
<td>
<p> if specified, <code>weights.num</code> is set to correspond to number of principle component weights that account for <code>cutoff</code> percent of the total variation in <code>Y</code>; if both <code>cutoff</code> and <code>weights.num</code> are specified, <code>weights.num</code> will be used</p>
</td></tr></table>


<h3>Details</h3>

<p>Utilizes the singular value decomposition (SVD) of <code>Y</code>, Y = UDVprime. Columns of <code>Y</code> should correspond to a single k-dimensional observation (e.g., functional output of a computer model, evaluated at a particular input).      
</p>
<p>For a k x m matrix <code>Y</code>, and r = min(k,m), in the complete SVD, <code>U</code> is k x r, <code>D</code> is r x r, containing the singular values along the diagonal, and <code>Vprime</code> is r x m. The output <code>Y</code> is approximated by keeping l &lt; r singular values, keeping a UD matrix of dimension k x l, and the <code>Vprime</code> matrix of dimension l x m. Each column of <code>Vprime</code> now contains l principle component weights, which can be used to reconstruct the functional output.        
</p>


<h3>Value</h3>

<p><code>pcweights</code> returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>UD</code></td>
<td>
<p>the UD matrix corresponding to the number of principle components kept</p>
</td></tr>
<tr><td><code>Vprime</code></td>
<td>
<p>The Vprime matrix corresponding to the number of principle components kept</p>
</td></tr>
</table>
<p>Note: the number of principle component weights kept is equal to dim(UD)[2]
</p>
<p><code>getSingularValues</code> returns a matrix containing the singular values of <code>Y</code>
</p>
<p><code>numSingularValues</code> returns the minimum number of singular values accounting for <code>cutoff</code> percent of the variation in <code>Y</code>
</p>
<p><code>singularValueImportance</code> returns a matrix where element i corresponds to the percentage of total variation in <code>Y</code> accounted for by the first i singular values 
</p>


<h3>Note</h3>

<p> these functions are utilized by <code>mlegp</code> to fit Gaussian processes to principle component weights</p>


<h3>Author(s)</h3>

<p> Garrett M. Dancik <a href="mailto:dancikg@easternct.edu">dancikg@easternct.edu</a> </p>


<h3>References</h3>

<p> Heitmann, K., Higdon, D., Nakhleh, C., Habib, S., 2006. Cosmic Calibration. The Astrophysical Journal, 646, 2, L1-L4.
</p>
<p><a href="https://github.com/gdancik/mlegp/">https://github.com/gdancik/mlegp/</a> 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+mlegp">mlegp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>

## create functional output that varies based on parameter 'p' ##
x = seq(-5,5,by=.2)
p = 1:50
y = matrix(0,length(p), length(x))
for (i in p) {
	y[i,] = sin(x) + i + rnorm(length(x), sd  = .1)
}

singularValueImportance(t(y))
numSingularValues(t(y), cutoff = 99.99)

</code></pre>

<hr>
<h2 id='plot.gp'> Diagnostic Plots for Gaussian processes </h2><span id='topic+plot.gp'></span>

<h3>Description</h3>

<p>Cross-Validated Diagnostic Plots for Gaussian Processes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
plot(x, type = 0, params = NULL, sds = 1, CI.at.point = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.gp_+3A_x">x</code></td>
<td>
<p> an object of class <code>gp</code> </p>
</td></tr>
<tr><td><code id="plot.gp_+3A_type">type</code></td>
<td>
<p> the type of graph to plot, 0 by default (see Details) </p>
</td></tr>
<tr><td><code id="plot.gp_+3A_params">params</code></td>
<td>
<p> for graph types 2 and 3, a vector of parameter names (or parameter indices) to plot against. By default, all parameters are looked at </p>
</td></tr>
<tr><td><code id="plot.gp_+3A_sds">sds</code></td>
<td>
<p> the number of standard deviations to use for confidence bands/intervals, for graph types 0-3 </p>
</td></tr>
<tr><td><code id="plot.gp_+3A_ci.at.point">CI.at.point</code></td>
<td>
<p> if TRUE, will plot confidence intervals at each predicted point, rather than bands, which is the default</p>
</td></tr>
<tr><td><code id="plot.gp_+3A_...">...</code></td>
<td>
<p> additional arguments to plot, but cannot overwrite xlab or ylab</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All plots involve cross-validated predictions and/or cross-validated standardized residuals. The cross-validation is in the sense that for predictions made at design point x, all observations at design point x are removed from the training set. 
</p>
<p>Where relevant, open circles correspond to Gaussian process predictions, black lines correspond to the observations, and red lines correspond to confidence bands. The argument <code>type</code> determines the type of graph displayed, and is one of the following integers:<br />
</p>

<table>
<tr>
 <td style="text-align: left;">
		</td><td style="text-align: left;"> 0 for observed vs. predicted AND observed vs. standardized residual (default),</td>
</tr>
<tr>
 <td style="text-align: left;"> 
		</td><td style="text-align: left;"> 1 for observed vs. predicted only,</td>
</tr>
<tr>
 <td style="text-align: left;">
		</td><td style="text-align: left;"> 2 for parameter vs. predicted for all parameters,</td>
</tr>
<tr>
 <td style="text-align: left;">
		</td><td style="text-align: left;"> 3 for parameter vs. standardized residual for all parameters,</td>
</tr>
<tr>
 <td style="text-align: left;">
		</td><td style="text-align: left;"> 4 for normal quantile plot and histogram of standardized residuals </td>
</tr>

</table>
 


<h3>Author(s)</h3>

<p> Garrett M. Dancik <a href="mailto:dancikg@easternct.edu">dancikg@easternct.edu</a> </p>


<h3>References</h3>

 <p><a href="https://github.com/gdancik/mlegp/">https://github.com/gdancik/mlegp/</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+CV">CV</a></code> for cross-validation, <code><a href="#topic+plot.gp.list">plot.gp.list</a></code> for plotting <code>gp.list</code> objects </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## fit the gp ##
x = seq(-5,5,by=.5)
y = sin(x) + rnorm(length(x), sd=.1)
fit = mlegp(x,y)

## plot diagnostics ##
plot(fit)
plot(fit, type = 2)
</code></pre>

<hr>
<h2 id='plot.gp.list'> Diagnostics Plots for Gaussian Process Lists </h2><span id='topic+plot.gp.list'></span>

<h3>Description</h3>

<p>Cross-validated Diagnostic Plots For Gaussian Process Lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp.list'
plot(x, sds = 1, CI.at.point = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.gp.list_+3A_x">x</code></td>
<td>
<p> an object of class <code>gp.list</code> </p>
</td></tr>
<tr><td><code id="plot.gp.list_+3A_sds">sds</code></td>
<td>
<p> the number of standard deviations to use for confidence bands / intervals</p>
</td></tr>
<tr><td><code id="plot.gp.list_+3A_ci.at.point">CI.at.point</code></td>
<td>
<p> if TRUE, will plot confidence intervals around each predicted point, rather than bands, which is the default</p>
</td></tr>
<tr><td><code id="plot.gp.list_+3A_...">...</code></td>
<td>
<p> not used; for compatibility with <code>plot.gp</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>All plots involve cross-validated predictions and/or cross-validated standardized residuals. The cross-validation is in the sense that for predictions made at design point <code>x</code>, all observations at design point <code>x</code> are removed from the training set. 
</p>
<p>Where relevant, open circles correspond to Gaussian process output, black lines correspond to the observations, and red lines correspond to confidence bands.
</p>
<p>For each Gaussian process in <code>x</code>, <code>plot.gp</code> is called using graph type 1, which plots cross-validated predictions vs. observed values.
</p>


<h3>Author(s)</h3>

<p> Garrett M. Dancik <a href="mailto:dancikg@easternct.edu">dancikg@easternct.edu</a> </p>


<h3>References</h3>

 <p><a href="https://github.com/gdancik/mlegp/">https://github.com/gdancik/mlegp/</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.gp">plot.gp</a></code>, <code><a href="#topic+CV">CV</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create data for multiple responses ##
x = seq(-5,5)
z1 = 10 - 5*x + rnorm(length(x))
z2 = 4 - 5*x + rnorm(length(x))
z3 = 7*sin(x) + rnorm(length(x))

## fit multiple Gaussian processes ##
fitMulti = mlegp(x, cbind(z1,z2,z3))

## plot diagnostics ##
plot(fitMulti)

</code></pre>

<hr>
<h2 id='plotObservedEffects'> Plot Observed Values Vs. Each Dimension of the Design Matrix </h2><span id='topic+plotObservedEffects'></span><span id='topic+plotObservedEffectsDefault'></span><span id='topic+plotObservedEffects.gp'></span>

<h3>Description</h3>

<p>Constructs multiple graphs, plotting each parameter from the design matrix on the x-axis and observations on the y-axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotObservedEffects(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotObservedEffects_+3A_x">x</code></td>
<td>
<p> an object of class <code>gp</code> or a design matrix </p>
</td></tr>
<tr><td><code id="plotObservedEffects_+3A_...">...</code></td>
<td>
<p> if x is a design matrix, a vector of observations;
if x is of class <code>gp</code>, a vector of parameter numbers or parameter names to plot (by default, all parameters will be graphed)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if <code>x</code> is NOT of class <code>gp</code> (i.e., <code>x</code> is a design matrix), all columns of <code>x</code> will be plotted separately against the vector of observations
</p>
<p>if <code>x</code> is of class <code>gp</code>, the specified columns of the design matrix of <code>x</code> will be plotted against the the observations
</p>


<h3>Note</h3>

<p> It is often useful to use this function before fitting the gaussian process, to check that the observations
are valid 
</p>


<h3>Author(s)</h3>

<p> Garrett M. Dancik <a href="mailto:dancikg@easternct.edu">dancikg@easternct.edu</a> </p>


<h3>References</h3>

 <p><a href="https://github.com/gdancik/mlegp/">https://github.com/gdancik/mlegp/</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create the design and output matrices ##
x1 = kronecker(seq(0,1,by=.25), rep(1,5))
x2 = rep(seq(0,1,by=.25),5)
z = 4 * x1 - 2*x2 + x1 * x2 + rnorm(length(x1), sd = 0.001)

## look at the observed effects prior to fitting the GP ##
plotObservedEffects(cbind(x1,x2), z)

## fit the Gaussian process ##
fit = mlegp(cbind(x1,x2), z, param.names = c("x1", "x2"))

## look at the observed effects of the fitted GP (which are same as above)
plotObservedEffects(fit)

</code></pre>

<hr>
<h2 id='predict.gp'> Gaussian Process Predictions </h2><span id='topic+predict.gp'></span><span id='topic+predictMu'></span><span id='topic+predictNewZ'></span><span id='topic+calcPredictionError'></span><span id='topic+predict.gp.list'></span>

<h3>Description</h3>

<p>Gaussian Process Predictions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
predict(object, newData = object$X, se.fit = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.gp_+3A_object">object</code></td>
<td>
<p> an object of class <code>gp</code> </p>
</td></tr>
<tr><td><code id="predict.gp_+3A_newdata">newData</code></td>
<td>
<p> an optional data frame or matrix with rows corresponding to inputs for which to predict.
If omitted, the design matrix <code>X</code> of <code>object</code> is used. </p>
</td></tr>
<tr><td><code id="predict.gp_+3A_se.fit">se.fit</code></td>
<td>
<p> a switch indicating if standard errors are desired </p>
</td></tr>
<tr><td><code id="predict.gp_+3A_...">...</code></td>
<td>
<p> for compatibility with generic method <code>predict</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Gaussian process is used to predict output at the design points <code>newData</code>; if the logical <code>se.fit</code> is set to <code>TRUE</code>, standard errors (standard deviations of the predicted values) are also calculated. Note that if the Gaussian process contains a nugget term, these standard deviations correspond to standard deviations of predicted expected values, and NOT standard deviations of predicted observations. However, the latter can be obtained by noting that the variance of a predicted observation equals the variance of the predicted expected value plus a nugget term.
</p>
<p>If <code>newData</code> is equal to the design matrix of <code>object</code> (the default), and there is no nugget term, the Gaussian process interpolates the observations and the
predictions will be identical to component <code>Z</code> of <code>object</code>. For cross-validation, the function <code>CV</code> should be used. 
</p>


<h3>Value</h3>

<p><code>predict.gp</code> produces a vector of predictions. If <code>se.fit</code> is <code>TRUE</code>, a list with the following components is returned:
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>vector as above</p>
</td></tr>
<tr><td><code>se.fit</code></td>
<td>
<p>standard error of the predictions</p>
</td></tr>
</table>


<h3>Note</h3>

<p> for predictions with <code>gp.list</code> objects, call <code>predict.gp</code> separately for each gp in the list
</p>


<h3>Author(s)</h3>

<p> Garrett M. Dancik <a href="mailto:dancikg@easternct.edu">dancikg@easternct.edu</a> </p>


<h3>References</h3>

 <p><a href="https://github.com/gdancik/mlegp/">https://github.com/gdancik/mlegp/</a> </p>


<h3>See Also</h3>

<p>For cross-validated predictions, see <code><a href="#topic+CV">CV</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = -5:5; y = sin(x) + rnorm(length(x), sd = 0.001)
fit = mlegp(x,y)
predict(fit, matrix(c(2.4, 3.2)))
## predictions at design points match the observations 
## (because there is no nugget)
round(predict(fit) - fit$Z, 6)   

# this is not necessarily true if there is a nugget
fit = mlegp(x,y, min.nugget = 0.01)
round(predict(fit) - fit$Z,6)   

</code></pre>

<hr>
<h2 id='print.gp'> Gaussian Process Summary Information </h2><span id='topic+print.gp'></span>

<h3>Description</h3>

<p>prints a summary of a Gaussian process object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.gp_+3A_x">x</code></td>
<td>
<p> an object of class <code>gp</code> </p>
</td></tr>
<tr><td><code id="print.gp_+3A_...">...</code></td>
<td>
<p> for compatibility with generic method <code>print</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>prints a summary of the Gaussian process object <code>x</code>, by calling <code>summary.gp</code>
</p>


<h3>Author(s)</h3>

<p> Garrett M. Dancik <a href="mailto:dancikg@easternct.edu">dancikg@easternct.edu</a> </p>


<h3>References</h3>

 <p><a href="https://github.com/gdancik/mlegp/">https://github.com/gdancik/mlegp/</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+summary.gp">summary.gp</a> for more description of the output</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = -5:5; y1 = sin(x) + rnorm(length(x),sd=.1)
fit1 = mlegp(x, y1)
print(fit1)

</code></pre>

<hr>
<h2 id='print.gp.list'> Gaussian Process List Summary Information </h2><span id='topic+print.gp.list'></span>

<h3>Description</h3>

<p>prints a summary of a Gaussian process list object, or (a subset) of its components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp.list'
print(x, nums = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.gp.list_+3A_x">x</code></td>
<td>
<p> an object of class <code>gp.list</code> </p>
</td></tr>
<tr><td><code id="print.gp.list_+3A_nums">nums</code></td>
<td>
<p> optionally, a vector of integers corresponding to Gaussian processes in the list to summarize  </p>
</td></tr>
<tr><td><code id="print.gp.list_+3A_...">...</code></td>
<td>
<p> for compatibility with generic method <code>print</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>if <code>nums</code> is <code>NULL</code>, prints summary information for the Gaussian process list object <code>x</code>, using <code>summary.gp.list</code>
</p>
<p>if <code>nums</code> is not <code>NULL</code>, prints summary information for each Gaussian process specified by <code>nums</code>, using <code>summary.gp</code>
</p>


<h3>Author(s)</h3>

<p> Garrett M. Dancik <a href="mailto:dancikg@easternct.edu">dancikg@easternct.edu</a> </p>


<h3>References</h3>

 <p><a href="https://github.com/gdancik/mlegp/">https://github.com/gdancik/mlegp/</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+summary.gp.list">summary.gp.list</a></code>, <code><a href="#topic+summary.gp">summary.gp</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = -5:5 
y1 = sin(x) + rnorm(length(x),sd=.1)
y2 = sin(x) + 2*x + rnorm(length(x), sd = .1)
fitMulti = mlegp(x, cbind(y1,y2))
print(fitMulti)  ## summary of the Gaussian process list
print(fitMulti, nums = 1:2) ## summary of Gaussian processes 1 and 2

</code></pre>

<hr>
<h2 id='summary.gp'> Gaussian Process Summary Information </h2><span id='topic+summary.gp'></span>

<h3>Description</h3>

<p>prints a summary of a Gaussian process object 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.gp_+3A_object">object</code></td>
<td>
<p> an object of class <code>gp</code> </p>
</td></tr>
<tr><td><code id="summary.gp_+3A_...">...</code></td>
<td>
<p> for compatibility with generic method <code>summary</code> </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>prints a summary of the Gaussian process object <code>object</code>. Output should be self explanatory, except for possibly CV RMSE, the cross-validated root mean squared error (the average squared difference between the observations and cross-validated predictions); and CV RMaxSE, the maximum cross-validated root squared error. If the design in the Gaussian process object contains any replicates, the root mean pure error (RMPE), which is the square root of the average within replicate variance and the root max pure error (RMaxPE) are also reported.   
</p>


<h3>Author(s)</h3>

<p> Garrett M. Dancik <a href="mailto:dancikg@easternct.edu">dancikg@easternct.edu</a> </p>


<h3>References</h3>

 <p><a href="https://github.com/gdancik/mlegp/">https://github.com/gdancik/mlegp/</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+createGP">createGP</a></code> for details of the Gaussian process object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## no replicates in the design matrix ##
x1 = -5:5; y1 = sin(x1) + rnorm(length(x1),sd=.1)
fit1 = mlegp(x1, y1)
summary(fit1)

## with replicates in the design matrix ##
x2 = kronecker(x1, rep(1,3)) 
y2 = sin(x2) + rnorm(length(x2), sd = .1)
fit2 = mlegp(x2,y2)
summary(fit2)

</code></pre>

<hr>
<h2 id='summary.gp.list'> Gaussian Process List Summary Information </h2><span id='topic+summary.gp.list'></span>

<h3>Description</h3>

<p>prints a summary of a Gaussian process list object, or (a subset) of its components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp.list'
summary(object, nums = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.gp.list_+3A_object">object</code></td>
<td>
<p> an object of type <code>gp.list</code> </p>
</td></tr>
<tr><td><code id="summary.gp.list_+3A_nums">nums</code></td>
<td>
<p> optionally, a vector of integers corresponding to Gaussian processes in the list to summarize  </p>
</td></tr>
<tr><td><code id="summary.gp.list_+3A_...">...</code></td>
<td>
<p> for compatibility with generic method <code>summary</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>if <code>nums</code> is <code>NULL</code>, prints out a summary of the Gaussian process list
</p>
<p>if <code>nums</code> is not <code>NULL</code>, displays a summary of the Gaussian processes specified by <code>nums</code> by calling <code>summary.gp</code> for each Gaussian process
</p>


<h3>Author(s)</h3>

<p> Garrett M. Dancik <a href="mailto:dancikg@easternct.edu">dancikg@easternct.edu</a> </p>


<h3>References</h3>

 <p><a href="https://github.com/gdancik/mlegp/">https://github.com/gdancik/mlegp/</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+summary.gp">summary.gp</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x = -5:5 
y1 = sin(x) + rnorm(length(x),sd=.1)
y2 = sin(x) + 2*x + rnorm(length(x), sd = .1)
fitMulti = mlegp(x, cbind(y1,y2))
summary(fitMulti)  ## summary of the Gaussian process list
summary(fitMulti, nums = 1:2) ## summary of Gaussian processes 1 and 2
</code></pre>

<hr>
<h2 id='uniqueSummary'> Summary of outputs for each unique input </h2><span id='topic+uniqueSummary'></span>

<h3>Description</h3>

<p>Finds sample means and variances for a matrix of observations when replicates are present
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniqueSummary(X,Y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uniqueSummary_+3A_x">X</code></td>
<td>
<p> matrix of inputs </p>
</td></tr>
<tr><td><code id="uniqueSummary_+3A_y">Y</code></td>
<td>
<p> matrix of outputs corresponding to x </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>uniqueSummary</code> calculates sample means and variances for each unique input. For input values with no replicates, the sample variance will be &lsquo;NA&rsquo;. This function is used by <code>mlegp</code> to fit a GP to a collection of means observations at each design point.  
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>reps</code></td>
<td>
<p>the number of reps for each unique design point</p>
</td></tr>
<tr><td><code>uniqueX</code></td>
<td>
<p>the input matrix with duplicate inputs removed</p>
</td></tr>
<tr><td><code>uniqueMeans</code></td>
<td>
<p>sample means corresponding to each unique input</p>
</td></tr>
<tr><td><code>uniqueVar</code></td>
<td>
<p>sample variances corresponding to each unique input</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Garrett M. Dancik <a href="mailto:dancikg@easternct.edu">dancikg@easternct.edu</a> </p>


<h3>References</h3>

 <p><a href="https://github.com/gdancik/mlegp/">https://github.com/gdancik/mlegp/</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x = c(1,1,2,2,3)
y = x + rnorm(length(x))
uniqueSummary(x,y)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
