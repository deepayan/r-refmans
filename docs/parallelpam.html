<!DOCTYPE html><html><head><title>Help for package parallelpam</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {parallelpam}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ApplyPAM'><p>ApplyPAM</p></a></li>
<li><a href='#CalcAndWriteDissimilarityMatrix'><p>CalcAndWriteDissimilarityMatrix</p></a></li>
<li><a href='#CalculateSilhouette'><p>CalculateSilhouette</p></a></li>
<li><a href='#ClassifAsDataFrame'><p>ClassifAsDataFrame</p></a></li>
<li><a href='#CsvToJMat'><p>CsvToJMat</p></a></li>
<li><a href='#FilterBySilhouetteQuantile'><p>FilterBySilhouetteQuantile</p></a></li>
<li><a href='#FilterBySilhouetteThreshold'><p>FilterBySilhouetteThreshold</p></a></li>
<li><a href='#FilterJMatByName'><p>FilterJMatByName</p></a></li>
<li><a href='#GetJCol'><p>GetJCol</p></a></li>
<li><a href='#GetJColByName'><p>GetJColByName</p></a></li>
<li><a href='#GetJColNames'><p>GetJColNames</p></a></li>
<li><a href='#GetJManyCols'><p>GetJManyCols</p></a></li>
<li><a href='#GetJManyColsByNames'><p>GetJManyColsByNames</p></a></li>
<li><a href='#GetJManyRows'><p>GetJManyRows</p></a></li>
<li><a href='#GetJManyRowsByNames'><p>GetJManyRowsByNames</p></a></li>
<li><a href='#GetJNames'><p>GetJNames</p></a></li>
<li><a href='#GetJRow'><p>GetJRow</p></a></li>
<li><a href='#GetJRowByName'><p>GetJRowByName</p></a></li>
<li><a href='#GetJRowNames'><p>GetJRowNames</p></a></li>
<li><a href='#GetSubdiag'><p>GetSubdiag</p></a></li>
<li><a href='#GetTD'><p>GetTD</p></a></li>
<li><a href='#JMatInfo'><p>JMatInfo</p></a></li>
<li><a href='#JMatToCsv'><p>JMatToCsv</p></a></li>
<li><a href='#JWriteBin'><p>JWriteBin</p></a></li>
<li><a href='#NumSilToClusterSil'><p>NumSilToClusterSil</p></a></li>
<li><a href='#ParallelpamSetDebug'><p>ParallelpamSetDebug</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Parallel Partitioning-Around-Medoids (PAM) for Big Sets of Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4</td>
</tr>
<tr>
<td>Author:</td>
<td>Juan Domingo <a href="https://orcid.org/0000-0003-4728-6256"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Guillermo Ayala <a href="https://orcid.org/0000-0002-6231-2865"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Spanish Ministry of Science and Innovation, MCIN/AEI
    &lt;doi:10.13039/501100011033&gt; [fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Juan Domingo &lt;Juan.Domingo@uv.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Application of the Partitioning-Around-Medoids (PAM) clustering algorithm described in Schubert, E. and Rousseeuw, P.J.:
        "Fast and eager k-medoids clustering: O(k) runtime improvement of the PAM, CLARA, and CLARANS algorithms." Information Systems,
        vol. 101, p. 101804, (2021). &lt;<a href="https://doi.org/10.1016%2Fj.is.2021.101804">doi:10.1016/j.is.2021.101804</a>&gt;.
	It uses a binary format for storing and retrieval of matrices developed for the 'jmatrix' package but the functionality of 'jmatrix'
	is included here, so you do not need to install it. Also, it is used by package 'scellpam', so if you have installed it, you do not need
	to install this package.
	PAM can be applied to sets of data whose dissimilarity matrix can be very big. It has been tested with up to 100.000 points.
	It does this with the help of the code developed for other package, 'jmatrix', which allows the matrix not to be loaded in 'R' memory (which
	would force it to be of double type) but it gets from disk, which allows using float (or even smaller data types). Moreover, the
	dissimilarity matrix is calculated in parallel if the computer has several cores so it can open many threads. The initial part
	of the PAM algorithm can be done with the BUILD or LAB algorithms; the BUILD algorithm has been implemented in parallel. The optimization
	phase implements the FastPAM1 algorithm, also in parallel. Finally, calculation of silhouette is available and also implemented in parallel.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.8), memuse (&ge; 4.2.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, cluster</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-07 16:18:49 UTC; jdomingo</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-09 13:40:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='ApplyPAM'>ApplyPAM</h2><span id='topic+ApplyPAM'></span>

<h3>Description</h3>

<p>A function to implement the Partitioning-around-medoids algorithm described in<br /> 
Schubert, E. and Rousseeuw, P.J.: &quot;Fast and eager k-medoids clustering: O(k) runtime improvement of the PAM, CLARA, and CLARANS algorithms.&quot;<br />
Information Systems, vol. 101, p. 101804, 2021.<br />
doi: https://doi.org/10.1016/j.is.2021.101804<br />
Notice that the actual values of the vectors (instances) are not needed. To recover them, look at the data matrix
used to generate the distance matrix.<br />
The number of instances, N, is not passed since dissimilarity matrix is NxN and therefore its size indicates the N value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ApplyPAM(
  dissim_file,
  k,
  init_method = "BUILD",
  initial_med = NULL,
  max_iter = 1000L,
  nthreads = 0L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ApplyPAM_+3A_dissim_file">dissim_file</code></td>
<td>
<p>A string with the name of the binary file that contains the symmetric matrix of dissimilarities. Such matrix
should have been generated by CalcAndWriteDissimilarityMatrix and it must be a symmetric matrix.</p>
</td></tr>
<tr><td><code id="ApplyPAM_+3A_k">k</code></td>
<td>
<p>A possitive integer (the desired number of medoids).</p>
</td></tr>
<tr><td><code id="ApplyPAM_+3A_init_method">init_method</code></td>
<td>
<p>One of the strings 'PREV', 'BUILD' or 'LAB'. See meaning of initialization algorithms BUILD and LAB in the original paper.<br />
'PREV' should be used exclusively to start the second part of the algorithm (optimization) from a initial set of medoids generated by a former call.<br />
Default: BUILD.</p>
</td></tr>
<tr><td><code id="ApplyPAM_+3A_initial_med">initial_med</code></td>
<td>
<p>A vector with initial medoids to start optimization. It is to be used only by the 'PREV' method and it will have been obtained as the first
element (L$med) of the two-element list returned by a previous call to this function used in just-initialize mode (max_iter=0).<br />
Default: empty vector.</p>
</td></tr>
<tr><td><code id="ApplyPAM_+3A_max_iter">max_iter</code></td>
<td>
<p>The maximum number of allowed iterations. 0 means stop immediately after finding initial medoids.<br />
Default: 1000</p>
</td></tr>
<tr><td><code id="ApplyPAM_+3A_nthreads">nthreads</code></td>
<td>
<p>The number of used threads.<br />
-1 means don't use threads (serial implementation).<br />
0 means let the program choose according to the number of cores and of points.<br />
Any other number forces this number of threads. Choosing more than the number of available cores is allowed, but discouraged.<br />
Default: 0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With respect to the returned value, L$med has as many components<br />
as requested medoids and L$clasif has as many components as instances.<br />
Medoids are expressed in L$med by its number in the array of points (row in the dissimilarity matrix) starting at 1 (R convention).<br />
L$clasif contains the number of the medoid (i.e.: the cluster) to which each instance has been assigned, according to their order in<br />
L$med (also from 1).<br />
This means that if L$clasif[p] is m, the point p belongs to the<br />
class grouped around medoid L$med[m].<br />
Moreover, if the dissimilarity matrix contains as metadata<br />
(row names) the point names, the returned vector is a R-named vector with such names.
</p>


<h3>Value</h3>

<p>L[&quot;med&quot;,&quot;clasif&quot;] A list of two numeric vectors. See section Details for more information<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Synthetic problem: 10 random seeds with coordinates in [0..20]
# to which random values in [-0.1..0.1] are added
M&lt;-matrix(0,100,500)
rownames(M)&lt;-paste0("rn",c(1:100))
for (i in (1:10))
{
 p&lt;-20*runif(500)
 Rf &lt;- matrix(0.2*(runif(5000)-0.5),nrow=10)
 for (k in (1:10))
 {
  M[10*(i-1)+k,]=p+Rf[k,]
 }
}
tmpfile1=paste0(tempdir(),"/pamtest.bin")
JWriteBin(M,tmpfile1,dtype="float",dmtype="full")
tmpdisfile1=paste0(tempdir(),"/pamDL2.bin")
CalcAndWriteDissimilarityMatrix(tmpfile1,tmpdisfile1,distype="L2",restype="float",nthreads=0)
L &lt;- ApplyPAM(tmpdisfile1,10,init_method="BUILD")
# Final value of sum of distances to closest medoid
GetTD(L,tmpdisfile1)
# Medoids:
L$med
# Medoid in which each individual has been classified
n&lt;-names(L$med)
n[L$clasif]
</code></pre>

<hr>
<h2 id='CalcAndWriteDissimilarityMatrix'>CalcAndWriteDissimilarityMatrix</h2><span id='topic+CalcAndWriteDissimilarityMatrix'></span>

<h3>Description</h3>

<p>Writes a binary symmetric matrix with the dissimilarities between ROWS of the data stored in a binary matrix in the jmatrix/parallelpam package format.<br />
The input matrix of vectors can be a full or a sparse matrix and the algorithm has been modified to calculate faster for sparse matrices.<br />
Output matrix type can be float or double type (but look at the comments in 'Details').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcAndWriteDissimilarityMatrix(
  ifname,
  ofname,
  distype = "L2",
  restype = "float",
  comment = "",
  nthreads = 0L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalcAndWriteDissimilarityMatrix_+3A_ifname">ifname</code></td>
<td>
<p>A string with the name of the file containing the counts as a binary matrix.</p>
</td></tr>
<tr><td><code id="CalcAndWriteDissimilarityMatrix_+3A_ofname">ofname</code></td>
<td>
<p>A string with the name of the binary output file to contain the symmetric dissimilarity matrix.</p>
</td></tr>
<tr><td><code id="CalcAndWriteDissimilarityMatrix_+3A_distype">distype</code></td>
<td>
<p>The dissimilarity to be calculated. It must be one of these strings: 'L1', 'L2', 'Pearson', 'Cos' or 'WEuc'.<br />
Respectively: L1 (Manhattan), L2 (Euclidean), Pearson (Pearson dissimilarity), Cos (cosine distance), WEuc (weigthed Euclidean, with inverse-stdevs as weights).<br />
Default: 'L2'.</p>
</td></tr>
<tr><td><code id="CalcAndWriteDissimilarityMatrix_+3A_restype">restype</code></td>
<td>
<p>The data type of the result. It can be one of the strings 'float' or 'double'. Default: float (and don't change it unless you REALLY need to...).</p>
</td></tr>
<tr><td><code id="CalcAndWriteDissimilarityMatrix_+3A_comment">comment</code></td>
<td>
<p>Comment to be added to the dissimilary matrix. Default: &quot;&quot; (no comment)</p>
</td></tr>
<tr><td><code id="CalcAndWriteDissimilarityMatrix_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of threads to be used for the parallel calculations with this meaning:<br />
-1: don't use threads.<br />
0: let the function choose according to the number of rows and to the number of available cores.<br />
Any possitive number &gt; 1: use that number of threads. You can use even more than cores, but this is discouraged and raises a warning.<br />
Default: 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter restype forces the output to be a matrix of either floats or doubles. Precision of float is normally good enough; but if you need
double precision (may be because you expect your results to be in a large range, two to three orders of magnitude), change it.<br />
Nevertheless, notice that this at the expense of double memory usage, which is QUADRATIC with the number of individuals (rows) in your input matrix.
</p>


<h3>Value</h3>

<p>No return value, called for side effects (creates a file)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(50000),nrow=100)
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",
          comment="Full matrix of floats, 100 rows, 500 columns")
JMatInfo(tmpfile1)
tmpdisfile1=paste0(tempdir(),"/RfullfloatDis.bin")
# Distance file calculated from the matrix stored as full
CalcAndWriteDissimilarityMatrix(tmpfile1,tmpdisfile1,distype="L2",
                         restype="float",comment="L2 distance matrix from full",nthreads=0)
JMatInfo(tmpdisfile1)
tmpfile2=paste0(tempdir(),"/Rsparsefloat.bin")
JWriteBin(Rf,tmpfile2,dtype="float",dmtype="sparse",
                         comment="Sparse matrix of floats, 100 rows, 500 columns")
JMatInfo(tmpfile2)
# Distance file calculated from the matrix stored as sparse
tmpdisfile2=paste0(tempdir(),"/RsparsefloatDis.bin")
CalcAndWriteDissimilarityMatrix(tmpfile2,tmpdisfile2,distype="L2",
                         restype="float",comment="L2 distance matrix from sparse",nthreads=0)
JMatInfo(tmpdisfile2)
# Read both versions
Dfu&lt;-GetJManyRows(tmpdisfile1,c(1:nrow(Rf)))
Dsp&lt;-GetJManyRows(tmpdisfile2,c(1:nrow(Rf)))
# and compare them
max(Dfu-Dsp)
</code></pre>

<hr>
<h2 id='CalculateSilhouette'>CalculateSilhouette</h2><span id='topic+CalculateSilhouette'></span>

<h3>Description</h3>

<p>Calculates the silhouette of each point of those classified by a clustering algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateSilhouette(cl, fdist, nthreads = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalculateSilhouette_+3A_cl">cl</code></td>
<td>
<p>The array of classification with the number of the class to which each point belongs to. This number must be in 1..number_of_classes.<br />
This function takes something like the L$clasif array which is the second element of the list returned by ApplyPAM</p>
</td></tr>
<tr><td><code id="CalculateSilhouette_+3A_fdist">fdist</code></td>
<td>
<p>The binary file containing the symmetric matrix with the dissimilarities between points (usually, generated by a call to CalcAndWriteDissimilarityMatrix)</p>
</td></tr>
<tr><td><code id="CalculateSilhouette_+3A_nthreads">nthreads</code></td>
<td>
<p>The number of used threads for parallel calculation.<br />
-1 means don't use threads (serial implementation).<br />
0 means let the program choose according to the number of cores and of points.<br />
Any other number forces this number of threads. Choosing more than the number of available cores is allowed, but discouraged.<br />
Default: 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sil       Numeric vector with the values of the silhouette for each point, in the same order in which points are in cl.<br />
If cl is a named vector sil will be a named vector, too, with the same names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Synthetic problem: 10 random seeds with coordinates in [0..20]
# to which random values in [-0.1..0.1] are added
M&lt;-matrix(0,100,500)
rownames(M)&lt;-paste0("rn",c(1:100))
for (i in (1:10))
{
 p&lt;-20*runif(500)
 Rf &lt;- matrix(0.2*(runif(5000)-0.5),nrow=10)
 for (k in (1:10))
 {
  M[10*(i-1)+k,]=p+Rf[k,]
 }
}
tmpfile1=paste0(tempdir(),"/pamtest.bin")
JWriteBin(M,tmpfile1,dtype="float",dmtype="full")
tmpdisfile1=paste0(tempdir(),"/pamDL2.bin")
CalcAndWriteDissimilarityMatrix(tmpfile1,tmpdisfile1,distype="L2",restype="float",nthreads=0)
L &lt;- ApplyPAM(tmpdisfile1,10,init_method="BUILD")
sil &lt;- CalculateSilhouette(L$clasif,tmpdisfile1)
# Histogram of the silhouette. In this synthetic problem, almost 1 for all points
hist(sil)
</code></pre>

<hr>
<h2 id='ClassifAsDataFrame'>ClassifAsDataFrame</h2><span id='topic+ClassifAsDataFrame'></span>

<h3>Description</h3>

<p>Returns the results of the classification returned by ApplyPAM as a R dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClassifAsDataFrame(L, fdist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClassifAsDataFrame_+3A_l">L</code></td>
<td>
<p>The list returned by ApplyPAM with fields L$med and<br />
L$clasif with the numbers of the medoids and the classification of each point</p>
</td></tr>
<tr><td><code id="ClassifAsDataFrame_+3A_fdist">fdist</code></td>
<td>
<p>The binary file containing the symmetric matrix with the dissimilarities between points (usually, generated by 
a call to CalcAndWriteDissimilarityMatrix).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dataframe has three columns: PointName (name of each point), NNPointName (name of the point which is the center of the cluster to which PointName belongs to)
and NNDistance (distance between the points PointName and NNPointName).
Medoids are identified by the fact that PointName and NNPointName are equal, or equivalently, NNDistance is 0.
</p>


<h3>Value</h3>

<p>Df    Dataframe with columns PointName, NNPointName and NNDistance. See Details for description.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Synthetic problem: 10 random seeds with coordinates in [0..20]
# to which random values in [-0.1..0.1] are added
M&lt;-matrix(0,100,500)
rownames(M)&lt;-paste0("rn",c(1:100))
for (i in (1:10))
{
 p&lt;-20*runif(500)
 Rf &lt;- matrix(0.2*(runif(5000)-0.5),nrow=10)
 for (k in (1:10))
 {
  M[10*(i-1)+k,]=p+Rf[k,]
 }
}
tmpfile1=paste0(tempdir(),"/pamtest.bin")
JWriteBin(M,tmpfile1,dtype="float",dmtype="full")
tmpdisfile1=paste0(tempdir(),"/pamDL2.bin")
CalcAndWriteDissimilarityMatrix(tmpfile1,tmpdisfile1,distype="L2",restype="float",nthreads=0)
L &lt;- ApplyPAM(tmpdisfile1,10,init_method="BUILD")
df &lt;- ClassifAsDataFrame(L,tmpdisfile1)
df
# Identification of medoids:
which(df[,3]==0)
# Verification they are the same as in L (in different order)
L$med
</code></pre>

<hr>
<h2 id='CsvToJMat'>CsvToJMat</h2><span id='topic+CsvToJMat'></span>

<h3>Description</h3>

<p>Gets a csv/tsv file and writes to a disk file the binary matrix of counts contained in it in the jmatrix binary format.<br />
First line of the .csv is supposed to have the field names.<br />
First column of each line is supposed to have the row name.<br />
The fields are supposed to be separated by one occurrence of a character-field sepparator (usually, comma or tab)
.tsv files can be read with this function, too, setting the csep argument to '\t'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CsvToJMat(
  ifname,
  ofname,
  mtype = "sparse",
  csep = ",",
  ctype = "raw",
  valuetype = "float",
  transpose = FALSE,
  comment = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CsvToJMat_+3A_ifname">ifname</code></td>
<td>
<p>A string with the name of the .csv/.tsv text file.</p>
</td></tr>
<tr><td><code id="CsvToJMat_+3A_ofname">ofname</code></td>
<td>
<p>A string with the name of the binary output file.</p>
</td></tr>
<tr><td><code id="CsvToJMat_+3A_mtype">mtype</code></td>
<td>
<p>A string to indicate the matrix type: 'full', 'sparse' or 'symmetric'. Default: 'sparse'</p>
</td></tr>
<tr><td><code id="CsvToJMat_+3A_csep">csep</code></td>
<td>
<p>The character used as separator in the .csv file. Default: ',' (comma) (Set to '\t' for .tsv)</p>
</td></tr>
<tr><td><code id="CsvToJMat_+3A_ctype">ctype</code></td>
<td>
<p>The string 'raw' or 'log1' to write raw counts or log(counts+1), or the normalized versions, 'rawn' and 'log1n', which normalize ALWAYS BY COLUMNS (before transposition, if requested to transpose). The logarithm is taken base 2. Default: raw</p>
</td></tr>
<tr><td><code id="CsvToJMat_+3A_valuetype">valuetype</code></td>
<td>
<p>The data type to store the matrix. It must be one of the strings 'uint32', 'float' or 'double'. Default: float</p>
</td></tr>
<tr><td><code id="CsvToJMat_+3A_transpose">transpose</code></td>
<td>
<p>Boolean to indicate if the matrix should be transposed before writing. See Details for a comment about this. Default: FALSE</p>
</td></tr>
<tr><td><code id="CsvToJMat_+3A_comment">comment</code></td>
<td>
<p>A comment to be stored with the matrix. Default: &quot;&quot; (no comment)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter transpose has the default value of FALSE. But don't forget to set it to TRUE if you want the cells
(which in single cell common practice are by columns) to be written by rows. This will be needed later to calculate
the dissimilarity matrix, if this is the next step of your workflow. See help of CalcAndWriteDissimilarityMatrix
</p>
<p>Special note for loading symmetric matrices:<br />
If you use this function to load what you expect to be a symmetric matrix from a .csv file, remember that the input table
MUST be square, but only the lower-diagonal matrix will be stored, including the main diagonal. The rest of the input table is
completely ignored, except to check that there are values in it. It is not checked if the table really represents a
symmetric matrix or not.<br />
Furthermore, symmetric matrices can only be loaded in raw mode, i.e.: no normalization is allowed, and they cannot be transposed.
</p>


<h3>Value</h3>

<p>No return value, called for side effects (creates a file)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Since we have no a .csv file to test, we will generate one with another funcion of this package
Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
tmpfile2=paste0(tempdir(),"/Rfullfloat2.bin")
tmpcsvfile1=paste0(tempdir(),"/Rfullfloat.csv")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
JMatToCsv(tmpfile1,tmpcsvfile1)
CsvToJMat(tmpcsvfile1,tmpfile2)
# It can be checked that files Rfullfloat.bin and Rfullfloat2.bin contain the same data
# (even they differ in the comment, which has been eliminated when converting to csv)
</code></pre>

<hr>
<h2 id='FilterBySilhouetteQuantile'>FilterBySilhouetteQuantile</h2><span id='topic+FilterBySilhouetteQuantile'></span>

<h3>Description</h3>

<p>Takes a silhouette, as returned by CalculateSilhouette, the list of medoids and class assignments, as returned by ApplyPam,
a quantile and the matrices of values and dissimilarities and constructs the corresponding matrices clearing off the points whose silhoutte is
below the lower quantile, except if they are medoids.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FilterBySilhouetteQuantile(
  s,
  L,
  fallcounts,
  ffilcounts,
  falldissim,
  ffildissim,
  q = 0.2,
  addcom = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FilterBySilhouetteQuantile_+3A_s">s</code></td>
<td>
<p>A numeric vector with the sihouette coefficient of each point in a classification, as returned by CalculateSilhouette.</p>
</td></tr>
<tr><td><code id="FilterBySilhouetteQuantile_+3A_l">L</code></td>
<td>
<p>A list of two numeric vectors, L$med and L$clasif, obtained normally as the object returned by ApplyPAM.</p>
</td></tr>
<tr><td><code id="FilterBySilhouetteQuantile_+3A_fallcounts">fallcounts</code></td>
<td>
<p>A string with the name of the binary file containing the matrix of data per point. It can be either a full or a sparse matrix.</p>
</td></tr>
<tr><td><code id="FilterBySilhouetteQuantile_+3A_ffilcounts">ffilcounts</code></td>
<td>
<p>A string with the name of the binary file that will contain the selected points. It will have the same character (full/sparse) and type of the complete file.</p>
</td></tr>
<tr><td><code id="FilterBySilhouetteQuantile_+3A_falldissim">falldissim</code></td>
<td>
<p>A string with the name of the binary file containing the dissimilarity matrix of the complete set of points. It must be a symmetric matrix.</p>
</td></tr>
<tr><td><code id="FilterBySilhouetteQuantile_+3A_ffildissim">ffildissim</code></td>
<td>
<p>A string with the name of the binary file that will contain  the dissimilarity matrix for the remaining points. It will be a symmetric matrix of.</p>
</td></tr>
<tr><td><code id="FilterBySilhouetteQuantile_+3A_q">q</code></td>
<td>
<p>Quantile to filter. All points whose silhouette is below this quantile will be filtered out. Default: 0.2</p>
</td></tr>
<tr><td><code id="FilterBySilhouetteQuantile_+3A_addcom">addcom</code></td>
<td>
<p>Boolean to indicate if a comment must be appended to the current comment of values and dissimilarity matrices to indicate that they are the result of a filtering process. This comment is automatically generated and contains the value of quantile q. Succesive applications add comments at the end of those already present. Default: TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The renumbering of indices in the returned cluster may seem confusing at first but it was the way of fitting this with the rest
of the package. Anyway, notice that if the numeric vectors in the input parameter L were named vectors, the point names are appropriately kept
in the result so point identity is preserved. Moreover, if the values and dissimilarity input matrices had row and/or column names, they
are preserved in the filtered matrices, too.
</p>


<h3>Value</h3>

<p>Lr[&quot;med&quot;,&quot;clasif&quot;] A list of two numeric vectors.<br />
Lr$med is a modification of the correponding first element of the passed L parameter.<br />
Lr$clasif has as many components as remaining instances.<br />
Since points will have been removed, medoid numbering is modified. Therefore, Lr$med has the NEW index of each medoid in the filtered set.<br />
Lr$clasif contains the number of the medoid (i.e.: the cluster) to which each instance has been assigned, and therefore does not change.<br />
All indexes start at 1 (R convention). Please, see Details section<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Synthetic problem: 10 random seeds with coordinates in [0..20]
# to which random values in [-0.1..0.1] are added
M&lt;-matrix(0,100,500)
rownames(M)&lt;-paste0("rn",c(1:100))
for (i in (1:10))
{
 p&lt;-20*runif(500)
 Rf &lt;- matrix(0.2*(runif(5000)-0.5),nrow=10)
 for (k in (1:10))
 {
  M[10*(i-1)+k,]=p+Rf[k,]
 }
}
tmpfile1=paste0(tempdir(),"/pamtest.bin")
JWriteBin(M,tmpfile1,dtype="float",dmtype="full")
tmpdisfile1=paste0(tempdir(),"/pamDl2.bin")
CalcAndWriteDissimilarityMatrix(tmpfile1,tmpdisfile1,distype="L2",restype="float",nthreads=0)
L &lt;- ApplyPAM(tmpdisfile1,10,init_method="BUILD")
# Which are the medoids
L$med
sil &lt;- CalculateSilhouette(L$clasif,tmpdisfile1)
tmpfiltfile1=paste0(tempdir(),"/pamtestfilt.bin")
tmpfiltdisfile1=paste0(tempdir(),"/pamDL2filt.bin")
Lf&lt;-FilterBySilhouetteQuantile(sil,L,tmpfile1,tmpfiltfile1,tmpdisfile1,tmpfiltdisfile1,
                               q=0.4,addcom=TRUE)
# The new medoids are the same points but renumbered, since the L$clasif array has less points
Lf$med
</code></pre>

<hr>
<h2 id='FilterBySilhouetteThreshold'>FilterBySilhouetteThreshold</h2><span id='topic+FilterBySilhouetteThreshold'></span>

<h3>Description</h3>

<p>Takes a silhouette, as returned by CalculateSilhouette, the list of medoids and class assignments, as returned by ApplyPam,
a threshold and the matrices of values and dissimilarities and constructs the corresponding matrices clearing off the points whose silhoutte is
below the threshold, except if they are medoids.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FilterBySilhouetteThreshold(
  s,
  L,
  fallcounts,
  ffilcounts,
  falldissim,
  ffildissim,
  thres = 0,
  addcom = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FilterBySilhouetteThreshold_+3A_s">s</code></td>
<td>
<p>A numeric vector with the sihouette coefficient of each point in a classification, as returned by CalculateSilhouette.</p>
</td></tr>
<tr><td><code id="FilterBySilhouetteThreshold_+3A_l">L</code></td>
<td>
<p>A list of two numeric vectors, L$med and L$clasif, obtained normally as the object returned by ApplyPAM.</p>
</td></tr>
<tr><td><code id="FilterBySilhouetteThreshold_+3A_fallcounts">fallcounts</code></td>
<td>
<p>A string with the name of the binary file containing the matrix of values per point. It can be either a full or a sparse matrix.</p>
</td></tr>
<tr><td><code id="FilterBySilhouetteThreshold_+3A_ffilcounts">ffilcounts</code></td>
<td>
<p>A string with the name of the binary file that will contain the selected points. It will have the same character (full/sparse) and type of the complete file.</p>
</td></tr>
<tr><td><code id="FilterBySilhouetteThreshold_+3A_falldissim">falldissim</code></td>
<td>
<p>A string with the name of the binary file containing the dissimilarity matrix of the complete set of points. It must be a symmetric matrix.</p>
</td></tr>
<tr><td><code id="FilterBySilhouetteThreshold_+3A_ffildissim">ffildissim</code></td>
<td>
<p>A string with the name of the binary file that will contain  the dissimilarity matrix for the remaining points. It will be a symmetric matrix.</p>
</td></tr>
<tr><td><code id="FilterBySilhouetteThreshold_+3A_thres">thres</code></td>
<td>
<p>Threshold to filter. All points whose silhouette is below this threshold will be filtered out. Default: 0.0 (remember that silhouette is in [-1..1])</p>
</td></tr>
<tr><td><code id="FilterBySilhouetteThreshold_+3A_addcom">addcom</code></td>
<td>
<p>Boolean to indicate if a comment must be appended to the current comment of values and dissimilarity matrices to indicate that they are the result of a filtering process. This comment is automatically generated and contains the value of threshold t. Succesive applications add comments at the end of those already present. Default: TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The renumbering of indices in the returned cluster may seem confusing at first but it was the way of fitting this with the rest
of the package. Anyway, notice that if the numeric vectors in the input parameter L were named vectors, the point names are appropriately kept
in the result so point identity is preserved. Moreover, if the values and dissimilarity input matrices had row and/or column names, they
are preserved in the filtered matrices, too.
</p>


<h3>Value</h3>

<p>Lr[&quot;med&quot;,&quot;clasif&quot;] A list of two numeric vectors.<br />
Lr$med is a modification of the correponding first element of the passed L parameter.<br />
Lr$clasif has as many components as remaining instances.<br />
Since points will have been removed, medoid numbering is modified. Therefore, Lr$med has the NEW index of each medoid in the filtered set.<br />
Lr$clasif contains the number of the medoid (i.e.: the cluster) to which each instance has been assigned, and therefore does not change.<br />
All indexes start at 1 (R convention). Please, see Details section<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Synthetic problem: 10 random seeds with coordinates in [0..20]
# to which random values in [-0.1..0.1] are added
M&lt;-matrix(0,100,500)
rownames(M)&lt;-paste0("rn",c(1:100))
for (i in (1:10))
{
 p&lt;-20*runif(500)
 Rf &lt;- matrix(0.2*(runif(5000)-0.5),nrow=10)
 for (k in (1:10))
 {
  M[10*(i-1)+k,]=p+Rf[k,]
 }
}
tmpfile1=paste0(tempdir(),"/pamtest.bin")
JWriteBin(M,tmpfile1,dtype="float",dmtype="full")
tmpdisfile1=paste0(tempdir(),"/pamDl2.bin")
CalcAndWriteDissimilarityMatrix(tmpfile1,tmpdisfile1,distype="L2",restype="float",nthreads=0)
L &lt;- ApplyPAM(tmpdisfile1,10,init_method="BUILD")
# Which are the medoids
L$med
sil &lt;- CalculateSilhouette(L$clasif,tmpdisfile1)
tmpfiltfile1=paste0(tempdir(),"/pamtestfilt.bin")
tmpfiltdisfile1=paste0(tempdir(),"/pamDL2filt.bin")
Lf&lt;-FilterBySilhouetteThreshold(sil,L,tmpfile1,tmpfiltfile1,tmpdisfile1,tmpfiltdisfile1,
                               thres=0.4,addcom=TRUE)
# The new medoids are the same points but renumbered, since the L$clasif array has less points
Lf$med
</code></pre>

<hr>
<h2 id='FilterJMatByName'>FilterJMatByName</h2><span id='topic+FilterJMatByName'></span>

<h3>Description</h3>

<p>Takes a jmatrix binary file containing a table with rows and columns and filters it by name, eliminating the rows or columns whose whose names are not in certain list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FilterJMatByName(fname, Gn, filname, namesat = "rows")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FilterJMatByName_+3A_fname">fname</code></td>
<td>
<p>A string with the file name of the original table</p>
</td></tr>
<tr><td><code id="FilterJMatByName_+3A_gn">Gn</code></td>
<td>
<p>A list of R strings with the names of the rows or columns that must remain. All others will be filtered out</p>
</td></tr>
<tr><td><code id="FilterJMatByName_+3A_filname">filname</code></td>
<td>
<p>A string with the file name of the filtered table</p>
</td></tr>
<tr><td><code id="FilterJMatByName_+3A_namesat">namesat</code></td>
<td>
<p>The string &quot;rows&quot; or &quot;cols&quot; indicating if the searched names are in the rows or in the columns of the original table. Default: &quot;rows&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the table has no list of names in the requested dimension (rows or colums), an error is rised.<br />
The row or column names whose names are not found obviosuly cannot remain, and the program rises a warning indicating for which row/column names this happens.<br />
The matrix contained in the filtered file will have the same nature (full or sparse) and the same data type as the original.<br />
This function can be used to filter either by row or by column name, with appropriate usage of parameter namesat
</p>


<h3>Value</h3>

<p>No return value, called for side effects (creates a file)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
tmpfile2=paste0(tempdir(),"/Rfullfloatrowfilt.bin")
tmpfile3=paste0(tempdir(),"/Rfullfloatrowcolfilt.bin")
tmpcsvfile1=paste0(tempdir(),"/Rfullfloat.csv")
tmpcsvfile3=paste0(tempdir(),"/Rfullfloatrowcolfilt.csv")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
# Let's keep only rows A, C and E
FilterJMatByName(tmpfile1,c("A","C","E"),tmpfile2,namesat="rows")
# and from the result, let's keep only columns b, d and g
FilterJMatByName(tmpfile2,c("b","d","g"),tmpfile3,namesat="cols")
JMatToCsv(tmpfile1,tmpcsvfile1)
JMatToCsv(tmpfile3,tmpcsvfile3)
# You can now compare both ASCII/csv files
</code></pre>

<hr>
<h2 id='GetJCol'>GetJCol</h2><span id='topic+GetJCol'></span>

<h3>Description</h3>

<p>Returns (as a R numeric vector) the requested column number from the matrix contained in a jmatrix binary file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetJCol(fname, ncol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetJCol_+3A_fname">fname</code></td>
<td>
<p>String with the file name that contains the binary data.</p>
</td></tr>
<tr><td><code id="GetJCol_+3A_ncol">ncol</code></td>
<td>
<p>The number of the column to be returned, in R-numbering (from 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the values of elements in the requested column
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
Rf[,3]
vf&lt;-GetJCol(tmpfile1,3)
vf
</code></pre>

<hr>
<h2 id='GetJColByName'>GetJColByName</h2><span id='topic+GetJColByName'></span>

<h3>Description</h3>

<p>Returns (as a R numeric vector) the requested named column from the matrix contained in a jmatrix binary file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetJColByName(fname, colname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetJColByName_+3A_fname">fname</code></td>
<td>
<p>String with the file name that contains the binary data.</p>
</td></tr>
<tr><td><code id="GetJColByName_+3A_colname">colname</code></td>
<td>
<p>The name of the column to be returned. If the matrix has no column names, or the name is not found, an empty vector is returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the values of elements in the requested column
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
Rf[,"c"]
vf&lt;-GetJColByName(tmpfile1,"c")
vf
</code></pre>

<hr>
<h2 id='GetJColNames'>GetJColNames</h2><span id='topic+GetJColNames'></span>

<h3>Description</h3>

<p>Returns a R StringVector with the column names of a matrix stored in the binary format of package jmatrix, if it has them stored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetJColNames(fname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetJColNames_+3A_fname">fname</code></td>
<td>
<p>String with the file name that contains the binary data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A R StringVector with the column names, or the empty vector if the binaryfile has no column names as metadata.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
cn&lt;-GetJColNames(tmpfile1)
cn
</code></pre>

<hr>
<h2 id='GetJManyCols'>GetJManyCols</h2><span id='topic+GetJManyCols'></span>

<h3>Description</h3>

<p>Returns (as a R numeric matrix) the columns with the requested column numbers from the matrix contained in a jmatrix binary file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetJManyCols(fname, extcols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetJManyCols_+3A_fname">fname</code></td>
<td>
<p>String with the file name that contains the binary data.</p>
</td></tr>
<tr><td><code id="GetJManyCols_+3A_extcols">extcols</code></td>
<td>
<p>A numeric vector with the indexes of the columns to be extracted, in R-numbering (from 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with the values of elements in the requested columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
vc&lt;-GetJManyCols(tmpfile1,c(1,4))
vc
</code></pre>

<hr>
<h2 id='GetJManyColsByNames'>GetJManyColsByNames</h2><span id='topic+GetJManyColsByNames'></span>

<h3>Description</h3>

<p>Returns (as a R numeric matrix) the columns with the requested column names from the matrix contained in a jmatrix binary file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetJManyColsByNames(fname, extcolnames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetJManyColsByNames_+3A_fname">fname</code></td>
<td>
<p>String with the file name that contains the binary data.</p>
</td></tr>
<tr><td><code id="GetJManyColsByNames_+3A_extcolnames">extcolnames</code></td>
<td>
<p>A vector of RStrings with the names of the columns to be extracted. If the binary file has no column names, or _any_ of the column names is not present, an empty matrix is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with the values of elements in the requested columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
Rf[,c(1,4)]
vf&lt;-GetJManyColsByNames(tmpfile1,c("a","d"))
vf
</code></pre>

<hr>
<h2 id='GetJManyRows'>GetJManyRows</h2><span id='topic+GetJManyRows'></span>

<h3>Description</h3>

<p>Returns (as a R numeric matrix) the rows with the requested row numbers from the matrix contained in a jmatrix binary file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetJManyRows(fname, extrows)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetJManyRows_+3A_fname">fname</code></td>
<td>
<p>String with the file name that contains the binary data.</p>
</td></tr>
<tr><td><code id="GetJManyRows_+3A_extrows">extrows</code></td>
<td>
<p>A numeric vector with the indexes of the rows to be extracted, in R-numbering (from 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with the values of elements in the requested rows
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
Rf[c(1,4),]
vc&lt;-GetJManyRows(tmpfile1,c(1,4))
vc
</code></pre>

<hr>
<h2 id='GetJManyRowsByNames'>GetJManyRowsByNames</h2><span id='topic+GetJManyRowsByNames'></span>

<h3>Description</h3>

<p>Returns (as a R numeric matrix) the rows with the requested row names from the matrix contained in a jmatrix binary file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetJManyRowsByNames(fname, extrownames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetJManyRowsByNames_+3A_fname">fname</code></td>
<td>
<p>String with the file name that contains the binary data.</p>
</td></tr>
<tr><td><code id="GetJManyRowsByNames_+3A_extrownames">extrownames</code></td>
<td>
<p>A vector of RStrings with the names of the rows to be extracted. If the binary file has no row names, or _any_ of the row names is not present, an empty matrix is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with the values of elements in the requested rows
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
Rf[c("A","C"),]
vf&lt;-GetJManyRowsByNames(tmpfile1,c("A","C"))
vf
</code></pre>

<hr>
<h2 id='GetJNames'>GetJNames</h2><span id='topic+GetJNames'></span>

<h3>Description</h3>

<p>Returns a R list of two elements, rownames and colnames, each of them being a R StringVector with the corresponding names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetJNames(fname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetJNames_+3A_fname">fname</code></td>
<td>
<p>String with the file name that contains the binary data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>N[&quot;rownames&quot;,&quot;colnames&quot;]: A list with two elements named rownames and colnames which are R StringVectors.
If the binary file has no row or column names as metadata BOTH will be returned as empty vectors, even if one of them exists.
If you want to extract only one, use either GetJRowNames or GetJColNames, as appropriate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
N&lt;-GetJNames(tmpfile1)
N["rownames"]
N["colnames"]
</code></pre>

<hr>
<h2 id='GetJRow'>GetJRow</h2><span id='topic+GetJRow'></span>

<h3>Description</h3>

<p>Returns (as a R numeric vector) the requested row number from the matrix contained in a jmatrix binary file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetJRow(fname, nrow)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetJRow_+3A_fname">fname</code></td>
<td>
<p>String with the file name that contains the binary data.</p>
</td></tr>
<tr><td><code id="GetJRow_+3A_nrow">nrow</code></td>
<td>
<p>The number of the row to be returned, in R-numbering (from 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the values of elements in the requested row
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
Rf[3,]
vf&lt;-GetJRow(tmpfile1,3)
vf
</code></pre>

<hr>
<h2 id='GetJRowByName'>GetJRowByName</h2><span id='topic+GetJRowByName'></span>

<h3>Description</h3>

<p>Returns (as a R numeric vector) the requested named row from the matrix contained in a jmatrix binary file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetJRowByName(fname, rowname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetJRowByName_+3A_fname">fname</code></td>
<td>
<p>String with the file name that contains the binary data.</p>
</td></tr>
<tr><td><code id="GetJRowByName_+3A_rowname">rowname</code></td>
<td>
<p>The name of the row to be returned. If the matrix has no row names, or the name is not found, an empty vector is returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the values of elements in the requested row
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
Rf["C",]
vf&lt;-GetJRowByName(tmpfile1,"C")
vf
</code></pre>

<hr>
<h2 id='GetJRowNames'>GetJRowNames</h2><span id='topic+GetJRowNames'></span>

<h3>Description</h3>

<p>Returns a R StringVector with the row names of a matrix stored in the binary format of package jmatrix, if it has them stored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetJRowNames(fname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetJRowNames_+3A_fname">fname</code></td>
<td>
<p>String with the file name that contains the binary data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A R StringVector with the row names, or the empty vector if the binary file has no row names as metadata.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
rn&lt;-GetJRowNames(tmpfile1)
rn
</code></pre>

<hr>
<h2 id='GetSubdiag'>GetSubdiag</h2><span id='topic+GetSubdiag'></span>

<h3>Description</h3>

<p>Takes a symmetric matrix and returns a vector with all its elements under the main diagonal (without those at the diagonal itself)
Done as an instrumental function to check the PAM in package cluster. To be removed in final version of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetSubdiag(fname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetSubdiag_+3A_fname">fname</code></td>
<td>
<p>The name of the file with the dissimilarity matrix in jmatrix binary format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector with the values under the main diagonal, sorted by columns (i.e.: m(2,1) .. m(n,1), m(3,2)..m(n,2),..., m(n-1,n))
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rns &lt;- matrix(runif(49),nrow=7)
Rsym &lt;- 0.5*(Rns+t(Rns))
rownames(Rsym) &lt;- c("A","B","C","D","E","F","G")
colnames(Rsym) &lt;- c("a","b","c","d","e","f","g")
tmpfile1=paste0(tempdir(),"/Rsymfloat.bin")
JWriteBin(Rsym,tmpfile1,dtype="float",dmtype="symmetric")
d&lt;-GetSubdiag(tmpfile1)
Rsym
d
</code></pre>

<hr>
<h2 id='GetTD'>GetTD</h2><span id='topic+GetTD'></span>

<h3>Description</h3>

<p>Function that takes a PAM classification (as returned by ApplyPAM) and the dissimilarity matrix and returns the value of the TD function
(sum of dissimilarities between each point and its closest medoid, divided by the number of points).
This function is mainly for debugging/internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetTD(L, dissim_file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetTD_+3A_l">L</code></td>
<td>
<p>A list of two numeric vectors, L[&quot;med&quot;,&quot;clasif&quot;], as returned by ApplyPAM (please, consult the help of ApplyPAM for details)</p>
</td></tr>
<tr><td><code id="GetTD_+3A_dissim_file">dissim_file</code></td>
<td>
<p>A string with the name of the binary file that contains the symmetric matrix of dissimilarities. Such matrix
should have been generated by CalcAndWriteDissimilarityMatrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TD          The value of the TD function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Synthetic problem: 10 random seeds with coordinates in [0..20]
# to which random values in [-0.1..0.1] are added
M&lt;-matrix(0,100,500)
rownames(M)&lt;-paste0("rn",c(1:100))
for (i in (1:10))
{
 p&lt;-20*runif(500)
 Rf &lt;- matrix(0.2*(runif(5000)-0.5),nrow=10)
 for (k in (1:10))
 {
  M[10*(i-1)+k,]=p+Rf[k,]
 }
}
tmpfile1=paste0(tempdir(),"/pamtest.bin")
tmpdisfile1=paste0(tempdir(),"/pamDL2.bin")
JWriteBin(M,tmpfile1,dtype="float",dmtype="full")
CalcAndWriteDissimilarityMatrix(tmpfile1,tmpdisfile1,distype="L2",restype="float",nthreads=0)
L &lt;- ApplyPAM(tmpdisfile1,10,init_method="BUILD")
# Final value of sum of distances to closest medoid
GetTD(L,tmpdisfile1)
</code></pre>

<hr>
<h2 id='JMatInfo'>JMatInfo</h2><span id='topic+JMatInfo'></span>

<h3>Description</h3>

<p>Shows in the screen or writes to a file information about a matrix stored in the binary format of package jmatrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JMatInfo(fname, fres = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JMatInfo_+3A_fname">fname</code></td>
<td>
<p>String with the file name that contains the binary data.</p>
</td></tr>
<tr><td><code id="JMatInfo_+3A_fres">fres</code></td>
<td>
<p>String with the name of the file to write the information. Default: &quot;&quot; (information is written to the console)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for its side effects (writes on screen or creates a file)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
JMatInfo(tmpfile1)
</code></pre>

<hr>
<h2 id='JMatToCsv'>JMatToCsv</h2><span id='topic+JMatToCsv'></span>

<h3>Description</h3>

<p>Writes a binary matrix in the jmatrix package format as a .csv file. This is mainly for checking/inspection and
to load the data from R as read.csv, if the memory of having all data as doubles allows doing such thing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JMatToCsv(ifile, csvfile, csep = ",", withquotes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JMatToCsv_+3A_ifile">ifile</code></td>
<td>
<p>String with the file name that contains the binary data.</p>
</td></tr>
<tr><td><code id="JMatToCsv_+3A_csvfile">csvfile</code></td>
<td>
<p>String with the file name that will contain the data as csv.</p>
</td></tr>
<tr><td><code id="JMatToCsv_+3A_csep">csep</code></td>
<td>
<p>Character used as separator. Default: , (comma)</p>
</td></tr>
<tr><td><code id="JMatToCsv_+3A_withquotes">withquotes</code></td>
<td>
<p>boolean to mark if row and column names in the .csv file must be written surrounded by doble quotes. Default: FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The numbers are written to text with as many decimal places as allowed by its data type (internally obtained
with std::numeric_limits&lt;type&gt;::max_digits10)<br />
NOTE ON READING FROM R: to read the .csv files exported by this function you MUST use the R function read.csv
(not read.table) AND set its argument row.names to 1, since we always write a first column with the row names,
even if the binary matrix does not store them; in this case they are simply &quot;1&quot;,&quot;2&quot;,...
</p>


<h3>Value</h3>

<p>No return value, called for side effects (creates a file)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
tmpcsvfile1=paste0(tempdir(),"/Rfullfloat.csv")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
JMatToCsv(tmpfile1,tmpcsvfile1)
</code></pre>

<hr>
<h2 id='JWriteBin'>JWriteBin</h2><span id='topic+JWriteBin'></span>

<h3>Description</h3>

<p>Writes a R matrix to a disk file as a binary matrix in the jmatrix format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JWriteBin(M, fname, dtype = "float", dmtype = "full", comment = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JWriteBin_+3A_m">M</code></td>
<td>
<p>The R matrix to be written</p>
</td></tr>
<tr><td><code id="JWriteBin_+3A_fname">fname</code></td>
<td>
<p>The name of the file to write</p>
</td></tr>
<tr><td><code id="JWriteBin_+3A_dtype">dtype</code></td>
<td>
<p>The data type of the matrix to be written: one of the strings 'short', 'int', 'long', 'float' or 'double'. Default: 'float'</p>
</td></tr>
<tr><td><code id="JWriteBin_+3A_dmtype">dmtype</code></td>
<td>
<p>The matrix type: one of the strings 'full', 'sparse' or 'symmetric'. Default: 'full'</p>
</td></tr>
<tr><td><code id="JWriteBin_+3A_comment">comment</code></td>
<td>
<p>A optional string with the comment to be added as metadata. Default: &quot;&quot; (empty string, no added comment)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this function cautiously. Differently to the functions to get one or more rows or columns from the binary file,
which book only the memory strictly needed for the vector/matrix and do not load all the binary file in memory,
this function books the full matrix in the requested data type and writes it later so with very big matrices
you might run out of memory.<br />
Type 'int' is really long int (8-bytes in most modern machines) so using 'int' or 'long' is equivalent.<br />
Type is coerced from double (the internal type of R matrices) to the requested type, which may provoke a loose of precision.<br />
If M is a named-R matrix, row and column names are written as metadata, too.<br />
Also, if you write as symmetric a matrix which is not such, only the lower-diagonal part will be written.
The rest of the data will be lost. In this case, if the matrix has row and column names, only row names are written.
</p>


<h3>Value</h3>

<p>No return value, called for side effects (creates a file)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Rf &lt;- matrix(runif(48),nrow=6)
rownames(Rf) &lt;- c("A","B","C","D","E","F")
colnames(Rf) &lt;- c("a","b","c","d","e","f","g","h")
tmpfile1=paste0(tempdir(),"/Rfullfloat.bin")
JWriteBin(Rf,tmpfile1,dtype="float",dmtype="full",comment="Full matrix of floats")
</code></pre>

<hr>
<h2 id='NumSilToClusterSil'>NumSilToClusterSil</h2><span id='topic+NumSilToClusterSil'></span>

<h3>Description</h3>

<p>Takes a silhouette in the form of a NumericVector, as returned by CalculateSilhouette, and returns it as a numeric matrix appropriate to be plotted by the package 'cluster'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NumSilToClusterSil(cl, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NumSilToClusterSil_+3A_cl">cl</code></td>
<td>
<p>The array of classification with the number of the class to which each point belongs to. This number must be in 1..number_of_classes.<br />
This function takes something like the L$clasif array which is the second element of the list returned by ApplyPAM</p>
</td></tr>
<tr><td><code id="NumSilToClusterSil_+3A_s">s</code></td>
<td>
<p>The numeric value of the silhouette for each point, with points in the same order as they appear in cl.<br />
This is the vector returned by a call to CalculateSilhouette with the same value of parameter cl.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sp       A silhouette in the format of the cluster package which is a NumericMatrix with as many rows as points and three columns: cluster, neighbor and sil_width.<br />
Its structure and dimension names are as in package 'cluster', which allows to use it with the silhouette plotting functions of such package<br />
This means you can do library(cluster) followed by plot(NumSilToClusterSil(cl,s)) to get a beatiful plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Synthetic problem: 10 random seeds with coordinates in [0..20]
# to which random values in [-0.1..0.1] are added
M&lt;-matrix(0,100,500)
rownames(M)&lt;-paste0("rn",c(1:100))
for (i in (1:10))
{
 p&lt;-20*runif(500)
 Rf &lt;- matrix(0.2*(runif(5000)-0.5),nrow=10)
 for (k in (1:10))
 {
  M[10*(i-1)+k,]=p+Rf[k,]
 }
}
tmpfile1=paste0(tempdir(),"/pamtest.bin")
JWriteBin(M,tmpfile1,dtype="float",dmtype="full")
tmpdisfile1=paste0(tempdir(),"/pamDL2.bin")
CalcAndWriteDissimilarityMatrix(tmpfile1,tmpdisfile1,distype="L2",restype="float",nthreads=0)
L &lt;- ApplyPAM(tmpdisfile1,10,init_method="BUILD")
sil &lt;- CalculateSilhouette(L$clasif,tmpdisfile1)
sp &lt;- NumSilToClusterSil(L$clasif,sil)
library(cluster)
plot(sp)
</code></pre>

<hr>
<h2 id='ParallelpamSetDebug'>ParallelpamSetDebug</h2><span id='topic+ParallelpamSetDebug'></span>

<h3>Description</h3>

<p>Sets debugging in parallelpam package to ON (with TRUE) or OFF (with FALSE) for both parts of it.<br />
On package load the default status is OFF.<br />
Setting debugging of any part to ON shows a message. Setting to OFF does not show anything (since debugging is OFF...)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ParallelpamSetDebug(deb = TRUE, debjmat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ParallelpamSetDebug_+3A_deb">deb</code></td>
<td>
<p>boolean, TRUE to generate debug messages for the PAM algorithm and silhouette calculation and FALSE to turn them off. Default: true.</p>
</td></tr>
<tr><td><code id="ParallelpamSetDebug_+3A_debjmat">debjmat</code></td>
<td>
<p>boolean, TRUE to generate debug messages for the jmatrix part inside this package and FALSE to turn them off. Default: false</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects (internal boolean flag changed)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ParallelpamSetDebug(TRUE,debjmat=TRUE)
ParallelpamSetDebug(TRUE,debjmat=FALSE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
