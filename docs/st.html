<!DOCTYPE html><html lang="en"><head><title>Help for package st</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {st}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#st-package'><p>The st package</p></a></li>
<li><a href='#choedata'><p>A Subset of the Choe et al. (2005) &ldquo;Golden Spike&rdquo; Experiment</p></a></li>
<li><a href='#cst.stat'><p>Correlation-Shared t-Statistic</p></a></li>
<li><a href='#diffmean.stat'><p>Difference of Means (&ldquo;Fold Change&rdquo;) and Rank Products Statistic</p></a></li>
<li><a href='#lait.stat'><p>Correlation-Predicted t-Statistic</p></a></li>
<li><a href='#regularizedt'><p>Various (Regularized) t Statistics</p></a></li>
<li><a href='#shrinkcat.stat'><p>Correlation-Adjusted t Score (CAT score)</p></a></li>
<li><a href='#shrinkt.stat'><p>The Shrinkage t Statistic</p></a></li>
<li><a href='#st-internal'><p>Internal st Functions</p></a></li>
<li><a href='#studentt.stat'><p>(Paired) Student t Statistic</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.2.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-11-26</td>
</tr>
<tr>
<td>Title:</td>
<td>Shrinkage t Statistic and Correlation-Adjusted t-Score</td>
</tr>
<tr>
<td>Author:</td>
<td>Rainer Opgen-Rhein, Verena Zuber, and Korbinian Strimmer.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Korbinian Strimmer &lt;strimmerlab@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2), sda (&ge; 1.3.8), fdrtool (&ge; 1.2.17), corpcor (&ge;
1.6.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>limma, samr</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the "shrinkage t" statistic 
   introduced in Opgen-Rhein and Strimmer (2007) &lt;<a href="https://doi.org/10.2202%2F1544-6115.1252">doi:10.2202/1544-6115.1252</a>&gt; and 
   a shrinkage estimate of the "correlation-adjusted t-score" (CAT score) described 
   in Zuber and Strimmer (2009) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtp460">doi:10.1093/bioinformatics/btp460</a>&gt;.  
   It also offers a convenient interface  to a number of other regularized 
   t-statistics commonly employed in high-dimensional case-control studies.    </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://strimmerlab.github.io/software/st/">https://strimmerlab.github.io/software/st/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-26 14:11:03 UTC; strimmer</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-27 06:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='st-package'>The st package</h2><span id='topic+st-package'></span>

<h3>Description</h3>

<p>This package implements the &quot;shrinkage t&quot; statistic 
described in Opgen-Rhein and Strimmer (2007) and a shrinkage estimate
of the &quot;correlation-adjusted t-score&quot; (cat score) introduced in
Zuber and Strimmer (2009).  It also offers a convenient interface 
to a number of other regularized t-statistics commonly 
employed in high-dimensional case-control studies.    
</p>


<h3>Author(s)</h3>

<p>Rainer Opgen-Rhein, Verena Zuber, and 
Korbinian Strimmer (<a href="https://strimmerlab.github.io/">https://strimmerlab.github.io/</a>)</p>


<h3>References</h3>

<p>See website: <a href="https://strimmerlab.github.io/software/st/">https://strimmerlab.github.io/software/st/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shrinkt.stat">shrinkt.stat</a></code>, 
<code><a href="#topic+shrinkcat.stat">shrinkcat.stat</a></code>, 
<code><a href="#topic+studentt.stat">studentt.stat</a></code>, 
<code><a href="#topic+modt.stat">modt.stat</a></code>, 
<code><a href="#topic+cst.stat">cst.stat</a></code>, 
<code><a href="#topic+lait.stat">lait.stat</a></code>.
</p>

<hr>
<h2 id='choedata'>A Subset of the Choe et al. (2005) &ldquo;Golden Spike&rdquo; Experiment</h2><span id='topic+choe2.mat'></span><span id='topic+choe2.L'></span><span id='topic+choe2.degenes'></span><span id='topic+choe2.mapping'></span><span id='topic+choe2.probe.name'></span><span id='topic+choe2.symbol.name'></span>

<h3>Description</h3>

<p>These data are expression levels for a subset of the genes
investigated in the Choe et al. (2005) &ldquo;Golden Spike&rdquo;
Affymetrix case-control experiment.  
</p>
<p>From the original data the 2,535 probe sets for <em>spike-ins with 
ratio 1:1 were removed</em>, leaving in total 11,475 genes with 
3 replicates per group, and  1,331 known differentially 
expressed genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(choedata)
</code></pre>


<h3>Format</h3>

<p><code>choe2.mat</code> is a matrix of dimension  6 times 11,475. It contains
the samples in its rows and the genes in its columns.
</p>
<p><code>choe2.L</code> describes the case control-structure of the experiment,
and  <code>choe2.degenes</code> indicates the known differentially expressed genes.
<code>choe2.symbol.name</code>,
<code>choe2.probe.name</code>, and
<code>choe2.mapping</code> provide additional information on the investigated genes.
</p>


<h3>References</h3>

<p>Choe, S. E., M. Boutros, A. M. Michelson, G. M. Church, and M. ~S. Halfon.
2005. Preferred analysis methods for Affymetrix GeneChips revealed
by a wholly defined control data set.
<em>Genome Biology </em> <b>6</b>, R16.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load st library
library("st")

# load data set
data(choedata)

# 6 samples, 11,475 genes
dim(choe2.mat)

# two groups (case vs. control
choe2.L

# 1,331 differentially expressed genes
sum(choe2.degenes)

# further information on genes
choe2.symbol.name
choe2.probe.name
choe2.mapping 
</code></pre>

<hr>
<h2 id='cst.stat'>Correlation-Shared t-Statistic</h2><span id='topic+cst.stat'></span><span id='topic+cst.fun'></span>

<h3>Description</h3>

<p><code>shrinkcat.stat</code> and <code>shrinkcat.fun</code> compute 
the &ldquo;correlation-shared&rdquo; t-statistic of Tibshirani and Wassermann (2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cst.stat(X, L, verbose=TRUE)
cst.fun(L, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cst.stat_+3A_x">X</code></td>
<td>
<p>data matrix. Note that the <em>columns</em> correspond to variables (&ldquo;genes&rdquo;)
and the <em>rows</em> to samples.</p>
</td></tr>
<tr><td><code id="cst.stat_+3A_l">L</code></td>
<td>
<p>vector with class labels for the two groups. </p>
</td></tr>
<tr><td><code id="cst.stat_+3A_verbose">verbose</code></td>
<td>
<p>print out some (more or less useful) information during computation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The correlation-shared t-statistic for a gene is computed as 
the average of  t-scores correlated with that gene. For mathematical
details see Tibshirani and Wasserman (2006).
</p>


<h3>Value</h3>

<p><code>cst.stat</code> returns a vector containing correlation-shared t-statistic for each variable/gene.
</p>
<p>The corresponding <code>cst.fun</code> functions return a function that
computes the correlation-shared t-statistic when applied to a data matrix
(this is very useful for simulations).
</p>


<h3>Author(s)</h3>

<p>Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>


<h3>References</h3>

<p>Tibshirani, R., and L. Wasserman. 2006.  Correlation-sharing for detection of differential gene expression.
See <a href="https://arxiv.org/abs/math/0608061">https://arxiv.org/abs/math/0608061</a> for publication details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shrinkcat.stat">shrinkcat.stat</a></code>, <code><a href="#topic+lait.stat">lait.stat</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># load st library 
library("st")

# prostate data set
data(singh2002)
X = singh2002$x
L = singh2002$y

dim(X)      # 102 6033 
length(L)   # 102

# correlation shared t statistic
## Not run: 
score = cst.stat(X, L)
idx = order(abs(score), decreasing=TRUE)
idx[1:10]
# [1]  610 1720  364  332  914 3940 4546 1068  579 4331

## End(Not run)

# compared with:

# Student t statistic
score = studentt.stat(X, L)
idx = order(abs(score), decreasing=TRUE)
idx[1:10]
# [1]  610 1720  364  332  914 3940 4546 1068  579 4331


# for the same example using the shrinkage cat score see shrinkcat.stat() 

</code></pre>

<hr>
<h2 id='diffmean.stat'>Difference of Means (&ldquo;Fold Change&rdquo;) and Rank Products Statistic</h2><span id='topic+diffmean.stat'></span><span id='topic+diffmean.fun'></span><span id='topic+rankprod.stat'></span><span id='topic+rankprod.fun'></span>

<h3>Description</h3>

<p>These function compute the difference of group means (&ldquo;fold change&rdquo;) and the
related rank products statistic of Breitling et al. (2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffmean.stat(X, L)
diffmean.fun(L)
rankprod.stat(X, L)
rankprod.fun(L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diffmean.stat_+3A_x">X</code></td>
<td>
<p>data matrix. Note that the <em>columns</em> correspond to variables (&ldquo;genes&rdquo;)
and the <em>rows</em> to samples.</p>
</td></tr>
<tr><td><code id="diffmean.stat_+3A_l">L</code></td>
<td>
<p>factor containing class labels for the two groups.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>diffmean.*</code> computes the difference of means (i.e. the fold-change for log-transformed data).
</p>
<p><code>rankprod.*</code> computes the two-sided rank products statistic, i.e. the geometric mean of the
ranks of the pairwise absolute mean differences (Breitling et al. 2004).  Note that for consistency with the other functions in this package the <em>complement</em> of the averaged ranks is returned 
(i.e. rank 1 becomes <code>ncol(X)</code>, rank 2 becomes <code>ncol(X)-1</code>, etc.). 
</p>


<h3>Value</h3>

<p>The *.stat functions directly return the respective statistic for each variable.
</p>
<p>The corresponding *.fun functions return a function that produces the respective
statistics when applied to a data matrix (this is very useful for simulations).
</p>


<h3>Author(s)</h3>

<p>Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>
<p>This function is in part based on code from Henry Wirth.
</p>


<h3>References</h3>

<p>Breitling, R., et al. 2004. Rank products: a simple, yet powerful, new method
to detect differentially regulated genes in replicated microarray experiments.
FEBS Letters <b>573</b>:83-9.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+studentt.stat">studentt.stat</a></code>,<code><a href="#topic+shrinkt.stat">shrinkt.stat</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># load st library 
library("st")

# load Choe et al. (2005) data
data(choedata)
X &lt;- choe2.mat
dim(X) # 6 11475  
L &lt;- choe2.L
L

# L may also contain some real labels
L = c("group 1", "group 1", "group 1", "group 2", "group 2", "group 2")


# difference of means resp. fold change statistic
score = diffmean.stat(X, L)
order(abs(score), decreasing=TRUE)[1:10]
# [1]  4790  6620  1022 10979   970    35  2693  5762  5885     2

# two-sided rank products statistic
score = rankprod.stat(X, L)
order(score, decreasing=TRUE)[1:10]
# [1]  4790  1022 10979  6620    35  2693   970  5762  5885     2

</code></pre>

<hr>
<h2 id='lait.stat'>Correlation-Predicted t-Statistic</h2><span id='topic+lait.stat'></span><span id='topic+lait.fun'></span><span id='topic+lai.tscore'></span>

<h3>Description</h3>

<p><code>lait.stat</code>, <code>laicat.fun</code>, and <code>lai.tscore</code>
compute   the &ldquo;correlation-predicted&rdquo; t-statistic of Lai (2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lait.stat(X, L, f=0.2, verbose=TRUE)
lait.fun(L, f=0.2, verbose=TRUE)
lai.tscore(gene, tscore, corr, f=0.2, plot=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lait.stat_+3A_x">X</code></td>
<td>
<p>data matrix. Note that the <em>columns</em> correspond to variables (&ldquo;genes&rdquo;)
and the <em>rows</em> to samples.</p>
</td></tr>
<tr><td><code id="lait.stat_+3A_l">L</code></td>
<td>
<p>vector with class labels for the two groups. </p>
</td></tr>
<tr><td><code id="lait.stat_+3A_verbose">verbose</code></td>
<td>
<p>print out some (more or less useful) information during computation.</p>
</td></tr>
<tr><td><code id="lait.stat_+3A_f">f</code></td>
<td>
<p>smoother span used in <code><a href="#topic+lowess">lowess</a></code> (default value: 0.2)</p>
</td></tr>
<tr><td><code id="lait.stat_+3A_gene">gene</code></td>
<td>
<p>the gene for which the Lai t-score is computed</p>
</td></tr>
<tr><td><code id="lait.stat_+3A_tscore">tscore</code></td>
<td>
<p>a vector with t-scores</p>
</td></tr>
<tr><td><code id="lait.stat_+3A_corr">corr</code></td>
<td>
<p>a matrix containing correlations</p>
</td></tr>
<tr><td><code id="lait.stat_+3A_plot">plot</code></td>
<td>
<p>show scatter plot correlations versus t-scores with predicted t-score</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The correlation-predicted t-statistic for a gene is 
the t-score predicted by local linear regression using all other
genes.  For mathematical details see Lai (2008).
</p>


<h3>Value</h3>

<p><code>lait.stat</code> returns a vector containing correlation-predicted t-statistic for each variable/gene.
</p>
<p>The corresponding <code>lait.fun</code> functions return a function that
computes the correlation-shared t-statistic when applied to a data matrix
(this is very useful for simulations).
</p>
<p>The function <code>lai.tscore</code> allows to compute the correlation-predicted t-statistic
for a gene given a correlation matrix and a vector of t-statistics.
</p>


<h3>Author(s)</h3>

<p>Verena Zuber and Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>


<h3>References</h3>

<p>Lai, Y.. 2008.  Genome-wide co-expression based prediction of differential expression.
Bioinformatics <b>24</b>:666-673.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shrinkcat.stat">shrinkcat.stat</a></code>, <code><a href="#topic+cst.stat">cst.stat</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># load st library 
library("st")

# prostate data set
data(singh2002)
X = singh2002$x
L = singh2002$y

dim(X)      # 102 6033 
length(L)   # 102

# compute correlation-predicted t-score for various choices
# of smoothing span 

## Not run: 

score1 = lait.stat(X, L, f=0.1)
idx1 = order(abs(score1), decreasing=TRUE)
idx1[1:10]
# 1072  297 1130 4495 4523 4041 1089  955  373 3848

score3 = lait.stat(X, L, f=0.3)
idx3 = order(abs(score3), decreasing=TRUE)
idx3[1:10]
# 1130  962 1688 1223  583 1118  955  297  698 1219

score5 = lait.stat(X, L, f=0.5)
idx5 = order(abs(score5), decreasing=TRUE)
idx5[1:10]
#  698  962 1223 1219  739 1172  583  694 3785 3370 

score7 = lait.stat(X, L, f=0.7)
idx7 = order(abs(score7), decreasing=TRUE)
idx7[1:10]
#  698  739 1219  962 3785  725  694  735 3370 1172


# pick the one with highest correlation to Student t score
t = studentt.stat(X, L)
cor(t, score1, method="spearman") # 0.4265832
cor(t, score3, method="spearman") # 0.471273
cor(t, score5, method="spearman") # 0.4750564
cor(t, score7, method="spearman") # 0.4666669

# focus on gene 19
t = studentt.stat(X, L)
R = cor(centroids(X, L, lambda.var=0, centered.data=TRUE,
              verbose=TRUE)$centered.data)

lai.tscore(gene=19, t, R, f=0.5, plot=TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='regularizedt'>Various (Regularized) t Statistics</h2><span id='topic+efront.stat'></span><span id='topic+efront.fun'></span><span id='topic+sam.stat'></span><span id='topic+sam.fun'></span><span id='topic+samL1.stat'></span><span id='topic+samL1.fun'></span><span id='topic+modt.stat'></span><span id='topic+modt.fun'></span>

<h3>Description</h3>

<p>These functions provide a simple interface to a variety of (regularized) t statistics
that are commonly used in the analysis of high-dimensional case-control studies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efront.stat(X, L, verbose=TRUE)
efront.fun(L, verbose=TRUE)
sam.stat(X, L)
sam.fun(L)
samL1.stat(X, L, method=c("lowess", "cor"), plot=FALSE, verbose=TRUE)
samL1.fun(L, method=c("lowess", "cor"), plot=FALSE, verbose=TRUE)
modt.stat(X, L)
modt.fun(L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regularizedt_+3A_x">X</code></td>
<td>
<p>data matrix. Note that the <em>columns</em> correspond to variables (&ldquo;genes&rdquo;)
and the <em>rows</em> to samples.</p>
</td></tr>
<tr><td><code id="regularizedt_+3A_l">L</code></td>
<td>
<p>factor containing class labels for the two groups.  </p>
</td></tr>
<tr><td><code id="regularizedt_+3A_method">method</code></td>
<td>
<p>determines how the smoothing parameter is estimated (applies only to improved SAM statistic <code>samL1</code>).</p>
</td></tr>
<tr><td><code id="regularizedt_+3A_plot">plot</code></td>
<td>
<p>output diagnostic plot (applies only to improved SAM statistic <code>samL1</code>).</p>
</td></tr>
<tr><td><code id="regularizedt_+3A_verbose">verbose</code></td>
<td>
<p>print out some (more or less useful) information during computation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>efront.*</code> computes the t statistic using the 90 % rule of Efron et al. (2001).
</p>
<p><code>sam.*</code> computes the SAM t statistic of Tusher et al. (2001).
Note that this requires the additional installation of the &ldquo;samr&rdquo; package.
</p>
<p><code>samL1.*</code> computes the improved SAM t statistic of Wu (2005).
Note that part of the code in this function is based on the R code providec
by B. Wu.
</p>
<p><code>modt.*</code> computes the moderated t statistic of Smyth (2004).
Note that this requires the additional installation of the &ldquo;limma&rdquo; package.
</p>
<p>All the above statistics are compared relative to each other 
and relative to the shrinkage t statistic in Opgen-Rhein and Strimmer (2007).
</p>


<h3>Value</h3>

<p>The *.stat functions directly return the respective statistic for each variable.
</p>
<p>The corresponding *.fun functions return a function that produces the respective
statistics when applied to a data matrix (this is very useful for simulations).
</p>


<h3>Author(s)</h3>

<p>Rainer Opgen-Rhein 
and
Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>


<h3>References</h3>

<p>Opgen-Rhein, R., and K. Strimmer. 2007. Accurate ranking of 
differentially expressed genes by a distribution-free shrinkage 
approach.  
Statist. Appl. Genet. Mol. Biol. <b>6</b>:9.
&lt;DOI:10.2202/1544-6115.1252&gt; 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diffmean.stat">diffmean.stat</a></code>, <code><a href="#topic+studentt.stat">studentt.stat</a></code>, <code><a href="#topic+shrinkt.stat">shrinkt.stat</a></code>, <code><a href="#topic+shrinkcat.stat">shrinkcat.stat</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># load st library 
library("st")

# load Choe et al. (2005) data
data(choedata)
X &lt;- choe2.mat
dim(X) # 6 11475  
L &lt;- choe2.L
L

# L may also contain some real labels
L = c("group 1", "group 1", "group 1", "group 2", "group 2", "group 2")


# Efron t statistic (90 % rule)
score = efront.stat(X, L)
order(score^2, decreasing=TRUE)[1:10]
# [1]  4790 10979 11068  1022    50   724  5762    43 10936  9939

# sam statistic
# (requires "samr" package)
#score = sam.stat(X, L)
#order(score^2, decreasing=TRUE)[1:10]
#[1]  4790 10979  1022  5762    35   970    50 11068 10905  2693

# improved sam statistic
#score = samL1.stat(X, L)
#order(score^2, decreasing=TRUE)[1:10]
#[1]  1  2  3  4  5  6  7  8  9 10
# here all scores are zero!

# moderated t statistic
# (requires "limma" package)
#score = modt.stat(X, L)
#order(score^2, decreasing=TRUE)[1:10]
# [1]  4790 10979  1022  5762    35    50 11068   970 10905    43

# shrinkage t statistic
score = shrinkt.stat(X, L)
order(score^2, decreasing=TRUE)[1:10]
#[1] 10979 11068    50  1022   724  5762    43  4790 10936  9939
</code></pre>

<hr>
<h2 id='shrinkcat.stat'>Correlation-Adjusted t Score (CAT score)</h2><span id='topic+shrinkcat.stat'></span><span id='topic+shrinkcat.fun'></span>

<h3>Description</h3>

<p><code>shrinkcat.stat</code> and <code>shrinkcat.fun</code> compute a shrinkage
estimate of the &ldquo;correlation-adjusted t score&rdquo;
of Zuber and Strimmer (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shrinkcat.stat(X, L, lambda, lambda.var, lambda.freqs, var.equal=TRUE, 
   paired=FALSE, verbose=TRUE)
shrinkcat.fun(L, lambda, lambda.var, lambda.freqs, var.equal=TRUE, 
   verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shrinkcat.stat_+3A_x">X</code></td>
<td>
<p>data matrix. Note that the <em>columns</em> correspond to variables (&ldquo;genes&rdquo;)
and the <em>rows</em> to samples.</p>
</td></tr>
<tr><td><code id="shrinkcat.stat_+3A_l">L</code></td>
<td>
<p>factor with class labels for the two groups. If only a single label is given then a one-sample CAT score against 0 is computed. </p>
</td></tr>
<tr><td><code id="shrinkcat.stat_+3A_lambda">lambda</code></td>
<td>
<p>Shrinkage intensity for the correlation matrix. If not specified it is 
estimated from the data. <code>lambda=0</code> implies no shrinkage
and <code>lambda=1</code> complete shrinkage. </p>
</td></tr>
<tr><td><code id="shrinkcat.stat_+3A_lambda.var">lambda.var</code></td>
<td>
<p>Shrinkage intensity for the variances. If not specified it is 
estimated from the data. <code>lambda.var=0</code> implies no shrinkage
and <code>lambda.var=1</code> complete shrinkage. </p>
</td></tr>
<tr><td><code id="shrinkcat.stat_+3A_lambda.freqs">lambda.freqs</code></td>
<td>
<p>Shrinkage intensity for the frequencies. If not specified it is 
estimated from the data. <code>lambda.freqs=0</code> implies no shrinkage (i.e. empirical frequencies).</p>
</td></tr>
<tr><td><code id="shrinkcat.stat_+3A_var.equal">var.equal</code></td>
<td>
<p>assume equal (default) or unequal variances in each group.</p>
</td></tr>
<tr><td><code id="shrinkcat.stat_+3A_paired">paired</code></td>
<td>
<p>compute paired CAT score (default is to use unpaired CAT score).</p>
</td></tr>
<tr><td><code id="shrinkcat.stat_+3A_verbose">verbose</code></td>
<td>
<p>print out some (more or less useful) information during computation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The CAT (&ldquo;correlation-adjusted t&rdquo;) score is the product of the square root of the
inverse correlation matrix with a vector of t scores. The CAT score thus describes the 
contribution of each individual feature in separating the two groups, 
after removing the effect of all other features.
</p>
<p>In Zuber and Strimmer (2009)
it is shown that the CAT score is
a natural criterion to rank features in the presence of correlation.
If there is no correlation, the CAT score reduces to the usual t score
(hence in this case the estimate from <code>shrinkcat.stat</code> equals that from <code><a href="#topic+shrinkt.stat">shrinkt.stat</a></code>).
</p>
<p>The function <code><a href="sda.html#topic+catscore">catscore</a></code> implements multi-class CAT scores.
</p>


<h3>Value</h3>

<p><code>shrinkcat.stat</code> returns a vector containing a shrinkage estimate of the
&ldquo;CAT score&rdquo;  for each variable/gene.
</p>
<p>The corresponding <code>shrinkcat.fun</code> functions return a function that
computes the cat score when applied to a data matrix
(this is very useful for simulations).
</p>
<p>The scale factor in the &rdquo;shrinkage CAT&rdquo; statistic is computed from the estimated frequencies
(to use the standard empirical scale factor set  <code>lambda.freqs=0</code>).
</p>


<h3>Author(s)</h3>

<p>Verena Zuber 
and
Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>


<h3>References</h3>

<p>Zuber, V., and K. Strimmer. 2009.  Gene ranking and biomarker discovery under correlation.
Bioinformatics 25: 2700-2707.
&lt;DOI:10.1093/bioinformatics/btp460&gt;
</p>


<h3>See Also</h3>

<p><code><a href="sda.html#topic+catscore">catscore</a></code>, <code><a href="#topic+shrinkt.stat">shrinkt.stat</a></code>, <code><a href="#topic+cst.stat">cst.stat</a></code>, <code><a href="#topic+lait.stat">lait.stat</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># load st library 
library("st")

# prostate data set
data(singh2002)
X = singh2002$x
L = singh2002$y

dim(X)      # 102 6033 
length(L)   # 102


# shrinkage cat statistic
score = shrinkcat.stat(X, L)
idx = order(score^2, decreasing=TRUE)
idx[1:10]
# 610  364 1720 3647 3375  332 3282 3991 1557  914

# compute q-values and local false discovery rates
library("fdrtool")
fdr.out = fdrtool(as.vector(score))
sum(fdr.out$qval &lt; 0.05)
sum(fdr.out$lfdr &lt; 0.2)


# compared with:

# shrinkage t statistic 
score = shrinkt.stat(X, L)
idx = order(score^2, decreasing=TRUE)
idx[1:10]
# 610 1720 3940  914  364  332 3647 4331  579 1068

# shrinkage CAT score with zero correlation among predictors
# is the same as shrinkage t
score2 = shrinkcat.stat(X, L, lambda=1)
sum((score2-score)^2)


# Student t statistic
score = studentt.stat(X, L)
idx = order(score^2, decreasing=TRUE)
idx[1:10]
# 610 1720  364  332  914 3940 4546 1068  579 4331

# shrinkage CAT score with zero correlation and no shrinkage 
# is the same as student t
score2 = shrinkcat.stat(X, L, lambda=1, lambda.var=0, lambda.freqs=0,
  verbose=FALSE)
sum((score2-score)^2)


# difference of means ("Fold Change")
score = diffmean.stat(X, L)
idx = order(abs(score), decreasing=TRUE)
idx[1:10]
# 735  610  694  298  698  292  739 3940  702  721


## paired CAT score

# we drop two cancer cases to make samples size equal in
# the two groups to allow to compute paired statistic
X = X[1:100,]
L = L[1:100]
sum(L=="cancer") # 50
sum(L=="healthy") # 50

# paired shrinkage CAT score
scat.paired = shrinkcat.stat(X, L, paired=TRUE)

# for zero correlation the paired shrinkage CAT score
# reduces to the paired shrinkage t score
score = shrinkt.stat(X, L, paired=TRUE, verbose=FALSE)
score2 = shrinkcat.stat(X, L, lambda=1, paired=TRUE, verbose=FALSE)
sum((score-score2)^2)

</code></pre>

<hr>
<h2 id='shrinkt.stat'>The Shrinkage t Statistic</h2><span id='topic+shrinkt.stat'></span><span id='topic+shrinkt.fun'></span>

<h3>Description</h3>

<p><code>shrinkt.stat</code> and <code>shrinkt.fun</code> compute the &ldquo;shrinkage t&rdquo; statistic
of Opgen-Rhein and Strimmer (2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shrinkt.stat(X, L, lambda.var, lambda.freqs, var.equal=TRUE, 
   paired=FALSE, verbose=TRUE)
shrinkt.fun(L, lambda.var, lambda.freqs, var.equal=TRUE, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shrinkt.stat_+3A_x">X</code></td>
<td>
<p>data matrix. Note that the <em>columns</em> correspond to variables (&ldquo;genes&rdquo;)
and the <em>rows</em> to samples.</p>
</td></tr>
<tr><td><code id="shrinkt.stat_+3A_l">L</code></td>
<td>
<p>factor with class labels for the two groups. If only a single label is given then a one-sample t-score against 0 is computed. </p>
</td></tr>
<tr><td><code id="shrinkt.stat_+3A_lambda.var">lambda.var</code></td>
<td>
<p>Shrinkage intensity for the variances. If not specified it is 
estimated from the data. <code>lambda.var=0</code> implies no shrinkage
and <code>lambda.var=1</code> complete shrinkage. </p>
</td></tr>
<tr><td><code id="shrinkt.stat_+3A_lambda.freqs">lambda.freqs</code></td>
<td>
<p>Shrinkage intensity for the frequencies. If not specified it is 
estimated from the data. <code>lambda.freqs=0</code> implies no shrinkage (i.e. empirical frequencies).</p>
</td></tr>
<tr><td><code id="shrinkt.stat_+3A_var.equal">var.equal</code></td>
<td>
<p>assume equal (default) or unequal variances in each group.</p>
</td></tr>
<tr><td><code id="shrinkt.stat_+3A_paired">paired</code></td>
<td>
<p>compute paired t-score (default is to use unpaired t-score).</p>
</td></tr>
<tr><td><code id="shrinkt.stat_+3A_verbose">verbose</code></td>
<td>
<p>print out some (more or less useful) information during computation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &ldquo;shrinkage t&rdquo; statistic is similar to the usual t statistic, with the
replacement of the sample variances by corresponding shrinkage estimates.
These are derived in a distribution-free fashion and with little a priori
assumptions.   Using the &ldquo;shrinkage t&rdquo; statistic procduces highly accurate rankings -
see Opgen-Rhein and Strimmer (2007).  
</p>
<p>The&ldquo;shrinkage t&rdquo; statistic can be generalized to include gene-wise correlation,
see <code><a href="#topic+shrinkcat.stat">shrinkcat.stat</a></code>.
</p>
<p>The scale factor in the &rdquo;shrinkage t&rdquo; statistic is computed from the estimated frequencies
(to use the standard empirical scale factor set  <code>lambda.freqs=0</code>).
</p>


<h3>Value</h3>

<p><code>shrinkt.stat</code> returns a vector containing the &ldquo;shrinkage t&rdquo; 
statistic for each variable/gene.
</p>
<p>The corresponding <code>shrinkt.fun</code> functions return a function that
produces the &ldquo;shrinkage t&rdquo; statistics when applied to a data matrix
(this is very useful for simulations).
</p>


<h3>Author(s)</h3>

<p>Rainer Opgen-Rhein, Verena Zuber, 
and
Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>


<h3>References</h3>

<p>Opgen-Rhein, R., and K. Strimmer. 2007. Accurate ranking of 
differentially expressed genes by a distribution-free shrinkage 
approach.  
Statist. Appl. Genet. Mol. Biol. <b>6</b>:9.
&lt;DOI:10.2202/1544-6115.1252&gt;  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+studentt.stat">studentt.stat</a></code>,
<code><a href="#topic+diffmean.stat">diffmean.stat</a></code>,
<code><a href="#topic+shrinkcat.stat">shrinkcat.stat</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># load st library 
library("st")

# load Choe et al. (2005) data
data(choedata)
X &lt;- choe2.mat
dim(X) # 6 11475  
L &lt;- choe2.L
L

# L may also contain some real labels
L = c("group 1", "group 1", "group 1", "group 2", "group 2", "group 2")

# shrinkage t statistic (equal variances)
score = shrinkt.stat(X, L)
order(score^2, decreasing=TRUE)[1:10]

# [1] 10979 11068    50  1022   724  5762    43  4790 10936  9939
#  lambda.var (variances):  0.3882
#  lambda.freqs (frequencies):  1

# shrinkage t statistic (unequal variances)
score = shrinkt.stat(X, L, var.equal=FALSE)
order(score^2, decreasing=TRUE)[1:10]

# [1] 11068    50 10979   724    43  1022  5762 10936  9939  9769
#  lambda.var class #1 and class #2 (variances):  0.3673   0.3362
#  lambda.freqs (frequencies): 1

# compute q-values and local false discovery rates
library("fdrtool")
fdr.out = fdrtool(score) 
sum( fdr.out$qval &lt; 0.05 )
sum( fdr.out$lfdr &lt; 0.2 )
fdr.out$param


# computation of paired t-score

# paired shrinkage t statistic
score = shrinkt.stat(X, L, paired=TRUE)
order(score^2, decreasing=TRUE)[1:10]
# [1] 50  4790  5393 11068  5762 10238  9939   708   728    68


# if there is no shrinkage the paired shrinkage t score reduces
# to the conventional paired student t statistic
score = studentt.stat(X, L, paired=TRUE)
score2 = shrinkt.stat(X, L, lambda.var=0, lambda.freqs=0, paired=TRUE, verbose=FALSE)
sum((score-score2)^2)

</code></pre>

<hr>
<h2 id='st-internal'>Internal st Functions</h2><span id='topic+pvt.samL1.get.lambda'></span><span id='topic+pvt.groupcat'></span>

<h3>Description</h3>

<p>Internal st functions.
</p>


<h3>Note</h3>

<p>These are not to be called by the user (or in some cases are just
waiting for proper documentation to be written).
</p>

<hr>
<h2 id='studentt.stat'>(Paired) Student t Statistic</h2><span id='topic+studentt.stat'></span><span id='topic+studentt.fun'></span>

<h3>Description</h3>

<p>These functions provide a simple interface to compute (paired) Student t statistics
in the analysis of high-dimensional case-control studies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>studentt.stat(X, L, var.equal=TRUE, paired=FALSE)
studentt.fun(L, var.equal=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="studentt.stat_+3A_x">X</code></td>
<td>
<p>data matrix. Note that the <em>columns</em> correspond to variables (&ldquo;genes&rdquo;)
and the <em>rows</em> to samples.</p>
</td></tr>
<tr><td><code id="studentt.stat_+3A_l">L</code></td>
<td>
<p>factor with class labels for the two groups. If only a single label is given then a one-sample t score against 0 is computed.</p>
</td></tr>
<tr><td><code id="studentt.stat_+3A_var.equal">var.equal</code></td>
<td>
<p>assume equal (default) or unequal variances in each group.</p>
</td></tr>
<tr><td><code id="studentt.stat_+3A_paired">paired</code></td>
<td>
<p>compute paired t-score (default is to use unpaired t-score).</p>
</td></tr>
</table>
<p>d</p>


<h3>Value</h3>

<p>The studentt.stat function returns a vector containing the t-statistic for each variable.  It can be specified whether the variances in the two groups are equal. A paired t-score can also be computed.
</p>
<p>The studentt.fun function returns a function that computes the t-score
statistics when applied to a data matrix (useful for simulations).
</p>


<h3>Author(s)</h3>

<p>Verena Zuber and
Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shrinkt.stat">shrinkt.stat</a></code>, <code><a href="#topic+shrinkcat.stat">shrinkcat.stat</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># load st library 
library("st")

# load Choe et al. (2005) data
data(choedata)
X &lt;- choe2.mat
dim(X) # 6 11475  
L &lt;- choe2.L
L

# L may also contain some real labels
L = c("group 1", "group 1", "group 1", "group 2", "group 2", "group 2")

# student t statistic (equal variances)
score = studentt.stat(X, L)
order(score^2, decreasing=TRUE)[1:10]
# [1] 11068   724  9990 11387 11310  9985  9996 11046    43    50

# the same computed with standard R methods (slower!)
#score2 = apply(X, 2, function(x) t.test(x ~ L, var.equal=TRUE)$statistic)
#sum((score-score2)^2)

# student t statistic (unequal variances)
score = studentt.stat(X, L, var.equal=FALSE)
order(score^2, decreasing=TRUE)[1:10]
# [1] 11068   724  9990 11387 11310  9985  9996 11046    43    50

# the same computed with standard R methods (slower!)
#score2 = apply(X, 2, function(x) t.test(x ~ L, var.equal=FALSE)$statistic)
#sum((score-score2)^2)

# paired student t statistic
score = studentt.stat(X, L, paired=TRUE)
order(score^2, decreasing=TRUE)[1:10]
# [1] 9985  7239  5393 11387 11310  9942 10238  9996 11015 11276

# the same computed with standard R methods (slower!)
#score2 = apply(X, 2, function(x) t.test(x ~ L, paired=TRUE)$statistic)
#sum((score-score2)^2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
