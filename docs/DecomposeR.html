<!DOCTYPE html><html lang="en"><head><title>Help for package DecomposeR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DecomposeR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#approx.cor'><p>Correlation of time-series with different sampling rate</p></a></li>
<li><a href='#as.emd'><p>Create / Check emd objects</p></a></li>
<li><a href='#as.pulse'><p>Create / Check pulse objects</p></a></li>
<li><a href='#check.emd'><p>Check an EMD object</p></a></li>
<li><a href='#condense'><p>Condenses columns of matrix</p></a></li>
<li><a href='#DecomposeR'><p>DecomposeR: Empirical Mode Decomposition for Cyclostratigraphy</p></a></li>
<li><a href='#DecomposeR.Datasets'><p>Datasets for Testing DecomposeR</p></a></li>
<li><a href='#dq.algorithm'><p>Calculates instantaneous frequency of freqeuncy carriers using the DQ</p>
method</a></li>
<li><a href='#extremist'><p>Gives local extrema and zero crossings intervals</p></a></li>
<li><a href='#extricate'><p>Extricate a signal: an EEMD algorithm</p></a></li>
<li><a href='#gzc'><p>Calculates instantaneous frequency using the GZC method</p></a></li>
<li><a href='#gzc.algorithm'><p>Calculates instantaneous frequency of simplified IMF using the GZC</p>
method</a></li>
<li><a href='#gzc.departure'><p>departure of instantaneous frequency to generalized zero-crossing</p></a></li>
<li><a href='#HilbertEnvelope'><p>Instantaneous amplitude</p></a></li>
<li><a href='#HilbertTransform'><p>The Hilbert transform</p></a></li>
<li><a href='#inst.pulse'><p>Computes instantaneous frequency using the Hilbert transform</p></a></li>
<li><a href='#inst.ratio'><p>Computes instantaneous ratio of frequency</p></a></li>
<li><a href='#InstantaneousFrequency'><p>Derive instantaneous frequency</p></a></li>
<li><a href='#integrity'><p>Integrity of a decomposition</p></a></li>
<li><a href='#is.ratio'><p>Check ratio objects</p></a></li>
<li><a href='#is.simp.emd'><p>Tests for simplified EMD</p></a></li>
<li><a href='#mode.in'><p>Add / Remove / Bind modes in emd objects</p></a></li>
<li><a href='#n.extrema'><p>Number of extrema/zero-crossings</p></a></li>
<li><a href='#normalise'><p>Empirical AM and FM decomposition</p></a></li>
<li><a href='#oscillate'><p>Modify a signal using a Van der Pol oscillator</p></a></li>
<li><a href='#parsimony'><p>Parsimony of a decomposition</p></a></li>
<li><a href='#pile.down'><p>Destacks a pile.up() signal</p></a></li>
<li><a href='#pile.up'><p>Repeat and stack a signal in central and line symmetry</p></a></li>
<li><a href='#plot_emd'><p>Plot a decomposition</p></a></li>
<li><a href='#plot_hex'><p>Group and/or log-scale hexagonal binning</p></a></li>
<li><a href='#plot_hist'><p>Group and/or log-scale histogram</p></a></li>
<li><a href='#plot_imf'><p>Plot IMFs characteristics</p></a></li>
<li><a href='#plot_pulse'><p>Visualise the instantaneous frequencies and amplitudes of a</p>
decomposition</a></li>
<li><a href='#plot_ratio'><p>Visualise the instantaneous frequencies ratios of a</p>
decomposition</a></li>
<li><a href='#PrecisionTester'><p>Test numerically determined instantaneous frequency against exact</p>
instantaneous frequency</a></li>
<li><a href='#ratios'><p>Computes ratios of numerical values</p></a></li>
<li><a href='#repl.out'><p>Remove / Bind replicates in emd objects</p></a></li>
<li><a href='#respace'><p>Interpolate with even spacing</p></a></li>
<li><a href='#simp.emd'><p>Simplifies the components of an EMD</p></a></li>
<li><a href='#simple.ssa'><p>Simple SSA decomposition</p></a></li>
<li><a href='#symmetry'><p>Symmetry of components</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Empirical Mode Decomposition for Cyclostratigraphy</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.6</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastien Wouters [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastien Wouters &lt;wouterseb@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools to apply Ensemble Empirical Mode 
    Decomposition (EEMD) for cyclostratigraphy purposes. Mainly: a new 
    algorithm, extricate, that performs EEMD in seconds, a linear interpolation 
    algorithm  using the greatest rational common divisor of depth or time, 
    different algorithms to compute instantaneous amplitude, frequency and  
    ratios of frequencies, and functions to verify and visualise the outputs.
    The functions were developed during the CRASH project (Checking the 
    Reproducibility of Astrochronology in the Hauterivian). When using for 
    publication please cite Wouters, S., Crucifix, M., Sinnesael, M., Da Silva, 
    A.C., Zeeden, C., Zivanovic, M., Boulvain, F., Devleeschouwer, X., 2022, 
    "A decomposition approach to cyclostratigraphic signal processing". 
    Earth-Science Reviews 225 (103894).
    &lt;<a href="https://doi.org/10.1016%2Fj.earscirev.2021.103894">doi:10.1016/j.earscirev.2021.103894</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, utils, usethis, tictoc, StratigrapheR (&ge;
1.1.1), grid, hexbin, colorRamps, dplyr (&ge; 1.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>EMD, Rssa, astrochron, tidyverse</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-02 09:27:42 UTC; User</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-02 15:50:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='approx.cor'>Correlation of time-series with different sampling rate</h2><span id='topic+approx.cor'></span>

<h3>Description</h3>

<p>Allows to correlate time-series having different sampling rate,
if they have a comparable depth or time scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approx.cor(xy1, dt1, xy2, dt2, plot = T, output = T, type = "p", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="approx.cor_+3A_xy1">xy1</code></td>
<td>
<p>intensity values for the first data set</p>
</td></tr>
<tr><td><code id="approx.cor_+3A_dt1">dt1</code></td>
<td>
<p>depth or time scale for the first data set</p>
</td></tr>
<tr><td><code id="approx.cor_+3A_xy2">xy2</code></td>
<td>
<p>intensity values for the second data set</p>
</td></tr>
<tr><td><code id="approx.cor_+3A_dt2">dt2</code></td>
<td>
<p>depth or time scale for the second data set</p>
</td></tr>
<tr><td><code id="approx.cor_+3A_plot">plot</code></td>
<td>
<p>whether to plot</p>
</td></tr>
<tr><td><code id="approx.cor_+3A_output">output</code></td>
<td>
<p>whether to output</p>
</td></tr>
<tr><td><code id="approx.cor_+3A_type">type</code></td>
<td>
<p>type of points in the plot (see help page of <code>lines()</code> for
details)</p>
</td></tr>
<tr><td><code id="approx.cor_+3A_...">...</code></td>
<td>
<p>additional parameters to feed to the <code>lines()</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of correlation ($cor), slope ($slope), intercept ($intercept)
(two values for each: interpolation to fit dt1 and dt2 respectively), and of
the xy1 and xy2 values, interpolated for dt1 ($df1) and df2 ($df2)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

n &lt;- 600
t &lt;- seq_len(n)

p1 &lt;- 30
p2 &lt;- 240

xy.pure &lt;- (1 + 0.6 * sin(t*2*pi/p2)) * sin(t*2*pi/p1)  + 2 * sin(t*2*pi/p2)

xy &lt;- xy.pure + rnorm(n, sd = 0.5)

inter_dt &lt;- round(runif(length(xy), min = 0.5, max = 1.5),1)

dt.pure &lt;- cumsum(inter_dt)

keep &lt;- runif(length(dt.pure)) &lt; 0.5

xy &lt;- xy[keep]
dt &lt;- dt.pure[keep] + rnorm(sum(keep), -0.2, 0.2)

par(mfrow = c(1,2))

plot(xy, dt, type = "o", pch = 19)

plot(xy.pure, dt.pure, type = "o", pch = 19)

par(mfrow = c(1,1))

out &lt;- approx.cor(xy, dt, xy.pure, dt.pure)

out$cor
out$slope
out$intercept

</code></pre>

<hr>
<h2 id='as.emd'>Create / Check emd objects</h2><span id='topic+as.emd'></span><span id='topic+is.emd'></span>

<h3>Description</h3>

<p>Allows to convert the result of a decomposition into a standard
list. The warnings of the is.emd checking function allow to identify the
problems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.emd(
  xy,
  dt,
  imf,
  residue = NULL,
  ini = NULL,
  mode = NULL,
  repl = 1,
  order = NA
)

is.emd(emd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.emd_+3A_xy">xy</code></td>
<td>
<p>a vector of length n for the original signal at each dt</p>
</td></tr>
<tr><td><code id="as.emd_+3A_dt">dt</code></td>
<td>
<p>a vector of length n for the depth or time reference</p>
</td></tr>
<tr><td><code id="as.emd_+3A_imf">imf</code></td>
<td>
<p>a data.frame or matrix of n rows of the IMFs</p>
</td></tr>
<tr><td><code id="as.emd_+3A_residue">residue</code></td>
<td>
<p>a vector of length n for the residue of the decomposition</p>
</td></tr>
<tr><td><code id="as.emd_+3A_ini">ini</code></td>
<td>
<p>an optional vector of length n of the eventual initial Intrinsic
Mode Function xy would be a demodulation of, if it is a demodulation.</p>
</td></tr>
<tr><td><code id="as.emd_+3A_mode">mode</code></td>
<td>
<p>the mode sequence index to give to each replicated IMFs</p>
</td></tr>
<tr><td><code id="as.emd_+3A_repl">repl</code></td>
<td>
<p>the id of each replicates. The length of unique(repl) defines the
amount of replicates.</p>
</td></tr>
<tr><td><code id="as.emd_+3A_order">order</code></td>
<td>
<p>the order of the imf, typically from higher frequency to lower
frequency</p>
</td></tr>
<tr><td><code id="as.emd_+3A_emd">emd</code></td>
<td>
<p>an emd object to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list made of $xy (original signal), $dt (depth/time), $m (a matrix
of the decomposition), $repl (the replicate id of each point) and
$mode (the mode id of each point).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

n &lt;- 600
t &lt;- seq_len(n)

p1 &lt;- 30
p2 &lt;- 240

s30  &lt;- (1 + 0.6 * sin(t*2*pi/p2)) * sin(t*2*pi/p1)
s240 &lt;- 2 * sin(t*2*pi/p2)
sn   &lt;- rnorm(n, sd = 0.5)

xy &lt;- s30 + s240 + sn

inter_dt &lt;- round(runif(length(xy), min = 0.5, max = 1.5),1)

dt  &lt;- cumsum(inter_dt)

dec &lt;- as.emd(xy = xy, dt = dt, imf = matrix(c(sn, s30, s240), ncol = 3))

plot_emd(dec, pdf = FALSE)

is.emd(dec)

## Not run: 
dec$xy &lt;- 1
is.emd(dec)
## End(Not run)

</code></pre>

<hr>
<h2 id='as.pulse'>Create / Check pulse objects</h2><span id='topic+as.pulse'></span><span id='topic+is.pulse'></span>

<h3>Description</h3>

<p>Allows to convert instantaneous frequency determination results
into a single 'pulse' object. This is the format generated by inst.pulse
(and gzc if <code>output = 2</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.pulse(
  dt,
  f,
  a = NULL,
  m = NULL,
  idt = NULL,
  mode = NULL,
  repl = 1,
  order = NA
)

is.pulse(pulse)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.pulse_+3A_dt">dt</code></td>
<td>
<p>a vector of length n for the depth or time reference</p>
</td></tr>
<tr><td><code id="as.pulse_+3A_f">f</code></td>
<td>
<p>a data.frame or matrix of n rows of the instantaneous frequencies</p>
</td></tr>
<tr><td><code id="as.pulse_+3A_a">a</code></td>
<td>
<p>a data.frame or matrix of n rows of the instantaneous amplitudes</p>
</td></tr>
<tr><td><code id="as.pulse_+3A_m">m</code></td>
<td>
<p>a data.frame or matrix of n rows of the components from which the
frequencies and amplitudes were computed from</p>
</td></tr>
<tr><td><code id="as.pulse_+3A_idt">idt</code></td>
<td>
<p>data.frame or matrix of n rows of identity tuning: new dt
coordinates to remove the frequency modulation</p>
</td></tr>
<tr><td><code id="as.pulse_+3A_mode">mode</code></td>
<td>
<p>the mode sequence index to give to each replicated IMFs</p>
</td></tr>
<tr><td><code id="as.pulse_+3A_repl">repl</code></td>
<td>
<p>a vector for the number of replicates or a matrix,
indicating in which replicate set each point is</p>
</td></tr>
<tr><td><code id="as.pulse_+3A_order">order</code></td>
<td>
<p>the order of the imf, typically from higher frequency to lower
frequency</p>
</td></tr>
<tr><td><code id="as.pulse_+3A_pulse">pulse</code></td>
<td>
<p>a pulse object to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list made of $dt (depth/time), $f (instantaneous frequency),
$a (instantaneous amplitude) if a is provided, $repl (the replicate id of
each point) and $mode (the mode id of each point).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

n &lt;- 600
dt &lt;- seq_len(n)

p1 &lt;- 30
p2 &lt;- 240

s30  &lt;- (1 + 0.6 * sin(dt*2*pi/p2)) * sin(dt*2*pi/p1)
s240 &lt;- 2 * sin(dt*2*pi/p2)

xy &lt;- s30 + s240

dec &lt;- as.emd(xy = xy, dt = dt, imf = matrix(c(s30, s240), ncol = 2))

plot_emd(dec, pdf = FALSE, style = 1)

pulse &lt;- inst.pulse(dec, last = TRUE, breaks = 200, bins = 40, cut = 10)

is.pulse(pulse)

simp.pulse &lt;- as.pulse(pulse$dt, pulse$f)

str(simp.pulse)

</code></pre>

<hr>
<h2 id='check.emd'>Check an EMD object</h2><span id='topic+check.emd'></span>

<h3>Description</h3>

<p>Provides an ensemble of check on the quality of a decomposition
presented as an emd object (see <code><a href="#topic+as.emd">as.emd</a></code> for more information)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.emd(emd, xy = NULL, timelimit = 15)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.emd_+3A_emd">emd</code></td>
<td>
<p>an amd object to test</p>
</td></tr>
<tr><td><code id="check.emd_+3A_xy">xy</code></td>
<td>
<p>the original signal that was decomposed: this parameter is simply
to insure that you are indeed comparing the decomposition to the original
signal, and not cheating by providing the sum of your decomposition</p>
</td></tr>
<tr><td><code id="check.emd_+3A_timelimit">timelimit</code></td>
<td>
<p>a time limit for the computation of the greatest common
rational divisor. A too long time may be indicative of a problem, typically
depth/time values that are not rounded adequately.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(50)

h &lt;- rnorm(n = 1000)

dt &lt;- seq_len(length(h))

alpha &lt;- 0.95

for(i in dt[-1]) h[i] &lt;- alpha *  h[i-1] + h[i]

set.seed(42)

em &lt;- extricate(h, dt, nimf = 7, repl = 1, comb = 100, sifting = 4,
                factor_noise = 20, unit_noise = "native", speak = TRUE)

## Not run: 
plot_emd(em, adapt.axis = TRUE)
## End(Not run)

check.emd(em, h)

</code></pre>

<hr>
<h2 id='condense'>Condenses columns of matrix</h2><span id='topic+condense'></span>

<h3>Description</h3>

<p>Condenses columns of a matrix by averaging or summing
them. The condensing can be done partially: a multiple of the repetitions can
be averaged or summed to keep some repetitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condense(m, n, fun = "mean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="condense_+3A_m">m</code></td>
<td>
<p>matrix of repeated signal, each column being a repetition</p>
</td></tr>
<tr><td><code id="condense_+3A_n">n</code></td>
<td>
<p>the number of repetitions that will be averaged/summed</p>
</td></tr>
<tr><td><code id="condense_+3A_fun">fun</code></td>
<td>
<p>the function to apply to each repetition: &quot;mean&quot; or &quot;sum&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with n times less columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(rep(seq(100, 800, 100), each = 10) + rep(1:10, 8), ncol = 8)

m

condense(m, 4)

</code></pre>

<hr>
<h2 id='DecomposeR'>DecomposeR: Empirical Mode Decomposition for Cyclostratigraphy</h2><span id='topic+DecomposeR'></span>

<h3>Description</h3>

<p>This package provides tools to apply Ensemble Empirical Mode
Decomposition (EEMD) for cyclostratigraphy purposes. It proposes a new
algorithm, that performs EEMD in seconds, a linear interpolation algorithm
using the greatest rational common divisor of depth or time, different
algorithms to compute instantaneous amplitude, frequency and ratios of
frequencies, and functions to verify and visualise the outputs.
</p>


<h3>Details</h3>

<p>Package: DecomposeR
</p>
<p>Type: R package
</p>
<p>Version: 1.0.6 (begin of 2023)
</p>
<p>License: GPL-3
</p>


<h3>Note</h3>

<p>If you want to use this package for publication or research
purposes, please cite Wouters, S., Crucifix, M., Sinnesael, M., Da Silva,
A.C., Zeeden, C., Zivanovic, M., Boulvain, F., Devleeschouwer, X., 2022,
&quot;A decomposition approach to cyclostratigraphic signal processing&quot;.
Earth-Science Reviews 225 (103894).
&lt;doi:10.1016/j.earscirev.2021.103894&gt;.
</p>


<h3>Author(s)</h3>

<p>Sebastien Wouters
</p>
<p>Maintainer: Sebastien Wouters <a href="mailto:wouterseb@gmail.com">wouterseb@gmail.com</a>
</p>

<hr>
<h2 id='DecomposeR.Datasets'>Datasets for Testing DecomposeR</h2><span id='topic+DecomposeR.Datasets'></span><span id='topic+ace'></span><span id='topic+cip1'></span><span id='topic+cip1_raw'></span><span id='topic+cip1_input'></span><span id='topic+cip2'></span><span id='topic+cip3'></span><span id='topic+z13'></span><span id='topic+z13amp'></span><span id='topic+w17'></span><span id='topic+sc97amp'></span><span id='topic+La04_pre_0_20'></span><span id='topic+La04_ecc_6_8'></span><span id='topic+La04_obl_6_8'></span><span id='topic+La04_pre_obl_5_9'></span>

<h3>Description</h3>

<p>Datasets for testing DecomposeR: the <code>ace</code> dataset is from
from Sinnesael et al. (2016), the <code>cip2</code> and <code>cip3</code> data sets are
from the signals 2 and 3 of the CIP project (Sinnesael et al., 2019),
respectively, and <code>cip1</code>
was derived from <code>cip1_raw</code> which is a rasterisation of the .tif image
provided as signal 1 of the CIP project. A real case study is also provided,
out of ODP 926 in Ceara Rise, limited between 5 &amp; 9 Millions
of years ago (Ma): the data sets z13 and z13amp are from Zeeden et al., 2013,
and are respectively the greyscale, and its amplitude modulation for the
eccentricity; w17 is from Wilkens et al., 2017, which proposes
a revised splice for magnetic susceptibility; sc97amp is the
amplitude modulation of eccentricity as it was calculated on the magnetic
susceptibility by Shackleton &amp; Crowhurst (1997). Excerpts from the Laskar
et al., 2004 solution are further provided from
<a href="http://vo.imcce.fr/insola/earth/online/earth/online/index.php">http://vo.imcce.fr/insola/earth/online/earth/online/index.php</a>: they are
the insolation input for the CIP1 signal (cip1_imput), and various solutions
for precession, eccentricity and obliquity for given time intervals (in
millions of years ago): La04_pre_0_20, La04_ecc_6_8, La04_obl_6_8 &amp;
La04_pre_obl_5_9.
</p>


<h3>Details</h3>


<dl>
<dt><strong>xy</strong></dt><dd><p>Values of the signal</p>
</dd>
<dt><strong>pre</strong></dt><dd><p>Values of the signal</p>
</dd>
<dt><strong>dt</strong></dt><dd><p>Depth or time of the signal</p>
</dd>
<dt><strong>age</strong></dt><dd><p>Tuned age of the signal</p>
</dd>
</dl>



<h3>References</h3>

<p>Laskar, J., Robutel, P., Joutel, F., Gastineau, M. Correia, A. C. M., &amp;
Levrard, B. (2004). A long-term numerical solution for the insolation of the
Earth. Astronomy &amp; Astrophysics. 428. 261-285.
<a href="https://doi.org/10.1051/0004-6361%3A20041335">doi:10.1051/0004-6361:20041335</a>
</p>
<p>Shackleton, N. J., &amp; Crowhurst, S. (1997). Sediment fluxes based on an
orbitally tuned time scale 5 Ma to 14 Ma, site 926. Proceedings of the Ocean
Drilling Program, Scientific Results. 154.
<a href="https://doi.org/10.2973/odp.proc.sr.154.102.1997">doi:10.2973/odp.proc.sr.154.102.1997</a>
</p>
<p>Sinnesael, M., Zivanovic, M., De Vleeschouwer,
D., Claeys, P. &amp; Schoukens, J. (2016). Astronomical component
estimation (ACE v.1) by time-variant sinusoidal modeling. Geoscientific
Model Development. 9. 3517-3531.
<a href="https://doi.org/10.5194/gmd-9-3517-2016">doi:10.5194/gmd-9-3517-2016</a>
</p>
<p>Sinnesael, M., De Vleeschouwer, D., Zeeden, C., et al. (2019). The
Cyclostratigraphy Intercomparison Project (CIP): consistency, merits and
pitfalls. Earth-Science Reviews. 199. 102965.
<a href="https://doi.org/10.1016/j.earscirev.2019.102965">doi:10.1016/j.earscirev.2019.102965</a>
</p>
<p>Wilkens, R. H., Westerhold, T., Drury A. D., Lyle , M., Gorgas, T., Tian, J.
(2017). Revisiting the Ceara Rise, equatorial Atlantic Ocean: isotope
stratigraphy of ODP Leg 154 from 0 to 5Ma. Climate of the Past. 13. 779-793.
<a href="https://doi.org/10.5194/cp-13-779-2017">doi:10.5194/cp-13-779-2017</a>
</p>
<p>Zeeden, C., Hilgen, F., Westerhold, T., Lourens, L., Röhl, U. &amp; Bickert, T.
(2013). Revised Miocene splice, astronomical tuning and calcareous plankton
biochronology of ODP Site 926 between 5 and 14.4 Ma. Palaeogeography,
Palaeoclimatology, Palaeoecology. 369. 430–451.
<a href="https://doi.org/10.1016/j.palaeo.2012.11.009">doi:10.1016/j.palaeo.2012.11.009</a>
</p>

<hr>
<h2 id='dq.algorithm'>Calculates instantaneous frequency of freqeuncy carriers using the DQ
method</h2><span id='topic+dq.algorithm'></span>

<h3>Description</h3>

<p>Calculates instantaneous frequency of frequency carriers using
the direct quadrature method from Huang et al., 2009.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dq.algorithm(fc, dt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dq.algorithm_+3A_fc">fc</code></td>
<td>
<p>a matrix of amplitude between -1 and 1, making up the frequency
carrier</p>
</td></tr>
<tr><td><code id="dq.algorithm_+3A_dt">dt</code></td>
<td>
<p>a vector of depth or time values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the depth/time (dt), frequency (f), and identity tuning
(idt), i.e. depths adapted to transform the frequency carrier into a cosine
of period 1.
</p>


<h3>References</h3>

<p>Huang, Norden E., Zhaohua Wu, Steven R. Long, Kenneth C. Arnold,
Xianyao Chen, and Karin Blank. 2009. &quot;On Instantaneous Frequency&quot;. Advances
in Adaptive Data Analysis 01 (02): 177–229.
https://doi.org/10.1142/S1793536909000096.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 600

t &lt;- seq_len(n)

p1 &lt;- 30

xy &lt;- sin(t*2*pi/p1 + 50)

int &lt;- c(rep(1, 99 + 100), seq(1,3,2/100), seq(3,1,-2/100), rep(1,100 + 99))

dt &lt;- cumsum(int)

cond &lt;- dt &lt; 75

xy &lt;- xy[!cond]
dt &lt;- dt[!cond]/1.2 - 62.5

res &lt;- dq.algorithm(xy, dt)

opar &lt;- par("mfrow")

par(mfrow = c(3,1))

plot(dt, xy, type = "o", pch = 19, main = "Frequency carrier")

plot(dt, 1/res$f, pch = 19, type = "l", log = "y", lwd = 2, ylim = c(25,80),
     main = "Period (Direct Quadrature method)", ylab = "Period")

plot(res$idt[,1], xy, type = "o", pch = 19,
     main = "Identity tuning", axes = FALSE, ylab = "xy", xlab = "dt")

ap &lt;- approx(x = dt, y = res$idt[,1], xout = seq(0,600, by = 20))

axis(1, at = ap$y, labels = ap$x)
axis(2)
box()

par(mfrow = opar)

</code></pre>

<hr>
<h2 id='extremist'>Gives local extrema and zero crossings intervals</h2><span id='topic+extremist'></span>

<h3>Description</h3>

<p>Gives local minimas, maximas and zero crossings. Optimised for
large data sets; the sky is the limit (and by the sky I mean the ability of
R and your computer to memorise large data sets; but within this limit the
algorithm can handle millions of points quickly).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extremist(xy, bound = FALSE, local = TRUE, zc = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extremist_+3A_xy">xy</code></td>
<td>
<p>the values where to find the local extremas</p>
</td></tr>
<tr><td><code id="extremist_+3A_bound">bound</code></td>
<td>
<p>whether to consider the first and last points as both
minima and maxima, for special purposes. Default is F, has it should be.</p>
</td></tr>
<tr><td><code id="extremist_+3A_local">local</code></td>
<td>
<p>whether to consider the first and last points as local
minima and maxima, if TRUE by default, otherwise these first and last points
will be ignored</p>
</td></tr>
<tr><td><code id="extremist_+3A_zc">zc</code></td>
<td>
<p>whether to return the zero crossings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the indexes of the left (l) and right (r) boundaries for
the minima (minindex), maxima (maxindex) and zero crossing (cross), along
with the number of extrema and zero crossings
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Function script ----

xy &lt;- c(1,0,0,0,4,5,5,0.5,-0.5,0.5,0,2,2,1,-1,-1,1,1,0,0,-4,-2,2,1,0,0.5,0,
        NA, 0.5,0,-0.5,3,2,3,0,0.5,4,4,0)

impressme &lt;- 0 # Increase up to 5 or 6 to be impressed (bugs if your system
               # can't handle the size of the data).
               # If you increase it, do not run the plot script.

xy &lt;- rep(xy, round(10^impressme))

print(paste("You are running ", length(xy), " points", sep = ""))

res &lt;- extremist(xy)



# Plot script: do not run if you increase the impressme parameter ----

mini &lt;- unique(c(res$minindex[[1]], res$minindex[[2]]))
maxi &lt;- unique(c(res$maxindex[[1]], res$maxindex[[2]]))
zeri &lt;- unique(c(res$cross[[1]], res$cross[[2]]))

l &lt;- length(xy)

opar &lt;- par("mfrow")

par(mfrow = c(3,1))

plot(1:l, xy, type = "o",pch = 19)
points(mini, xy[mini], pch = 19, col = "blue")

plot(1:l, xy, type = "o",pch = 19)
points(maxi, xy[maxi], pch = 19, col = "red")

plot(1:l, xy, type = "o",pch = 19)
points(zeri, xy[zeri], pch = 19, col = "green")
abline(h = 0, col = "grey")

par(mfrow = opar)

</code></pre>

<hr>
<h2 id='extricate'>Extricate a signal: an EEMD algorithm</h2><span id='topic+extricate'></span>

<h3>Description</h3>

<p>Performes EEMD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extricate(
  xy,
  dt,
  nimf,
  ini = NULL,
  repl = 1,
  comb = 100,
  mirror_noise = TRUE,
  factor_noise = 3,
  unit_noise = "1stdiff",
  sifting = 1,
  output_sifting = FALSE,
  remove = "lin.trend",
  bind = FALSE,
  speak = FALSE,
  plot_process = FALSE,
  pdf = TRUE,
  name = "extricate",
  ext = ".pdf",
  dir = tempdir(),
  width = 10,
  height = 20,
  track = TRUE,
  openfile = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extricate_+3A_xy">xy</code></td>
<td>
<p>signal, maybe linearly interpolated to have regular sampling
interval</p>
</td></tr>
<tr><td><code id="extricate_+3A_dt">dt</code></td>
<td>
<p>depth/time</p>
</td></tr>
<tr><td><code id="extricate_+3A_nimf">nimf</code></td>
<td>
<p>number of modes/components/intrinsic mode functions to decompose
the signal into</p>
</td></tr>
<tr><td><code id="extricate_+3A_ini">ini</code></td>
<td>
<p>an optional vector of length n of the eventual initial Intrinsic
Mode Function xy would be a demodulation of, if it is a demodulation. In that
case the mode indexes will start at 2.</p>
</td></tr>
<tr><td><code id="extricate_+3A_repl">repl</code></td>
<td>
<p>the amount of decompositions to output</p>
</td></tr>
<tr><td><code id="extricate_+3A_comb">comb</code></td>
<td>
<p>the amount of decompositions each output decomposition will be a
combination of. Has to be a multiple of 2 (even and odd extension stacks
have to be combined in any case)</p>
</td></tr>
<tr><td><code id="extricate_+3A_mirror_noise">mirror_noise</code></td>
<td>
<p>whether to generate a mirrored noise signal (for even and
odd extension) that will cancel perfectly when combining the decompositions</p>
</td></tr>
<tr><td><code id="extricate_+3A_factor_noise">factor_noise</code></td>
<td>
<p>a factor for the amplitude of white noise (finite
amplitude obtained via <code><a href="stats.html#topic+runif">runif</a></code>). By default it will be
multiplied with the mean of the lagged-one difference to define the noise
amplitude</p>
</td></tr>
<tr><td><code id="extricate_+3A_unit_noise">unit_noise</code></td>
<td>
<p>whether to multiply factor_noise by the mean of the
lagged-one difference (unit_noise = &quot;1stdiff&quot;) or not (unit_noise =
&quot;native&quot;)</p>
</td></tr>
<tr><td><code id="extricate_+3A_sifting">sifting</code></td>
<td>
<p>amount of iterations of the sifting process</p>
</td></tr>
<tr><td><code id="extricate_+3A_output_sifting">output_sifting</code></td>
<td>
<p>whether to output each sifting</p>
</td></tr>
<tr><td><code id="extricate_+3A_remove">remove</code></td>
<td>
<p>whether to remove the linear trend (remove = &quot;lin.trend&quot;) or
the mean (remove = &quot;mean&quot;) prior to decomposition. The removed part will be
added back after the decomposition. If remove is anything else, nothing will
be removed, which can be problematic for the even and odd extension scheme
used.</p>
</td></tr>
<tr><td><code id="extricate_+3A_bind">bind</code></td>
<td>
<p>whether to bind the removed linear trend or mean to the last
component (T), or to add it as another component (F)</p>
</td></tr>
<tr><td><code id="extricate_+3A_speak">speak</code></td>
<td>
<p>whether to print a sentence at each sifting: it gives the stack
(even or odd), the mode number and sifting number</p>
</td></tr>
<tr><td><code id="extricate_+3A_plot_process">plot_process</code></td>
<td>
<p>whether to have a plot of the entire sifting process.
This slows down the algorithm, use with low 'repl' and 'comb' values for
visualisation purposes</p>
</td></tr>
<tr><td><code id="extricate_+3A_pdf">pdf</code></td>
<td>
<p>whether the plot be directly set as a pdf file</p>
</td></tr>
<tr><td><code id="extricate_+3A_name">name</code>, <code id="extricate_+3A_ext">ext</code>, <code id="extricate_+3A_dir">dir</code>, <code id="extricate_+3A_width">width</code>, <code id="extricate_+3A_height">height</code>, <code id="extricate_+3A_track">track</code>, <code id="extricate_+3A_openfile">openfile</code></td>
<td>
<p>arguments to provide to
pdfDisplay if plot_process and pdf are TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list made of $xy (original signal), $dt (depth/time), $m (a matrix
of the decomposition), $repl (the replicate id of each point) and
$mode (the mode id of each point). If output_sifting is TRUE, additional
$even_sifting and $odd_sifting data.tables are provided, giving the
condensed siftings for the even and odd extensions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

n &lt;- 600
t &lt;- seq_len(n)

p1 &lt;- 30
p2 &lt;- 240

xy &lt;- (1 + 0.6 * sin(t*2*pi/p2)) * sin(t*2*pi/p1)  + 2 * sin(t*2*pi/p2) +
  rnorm(n, sd = 0.5) + t * 0.01

inter_dt &lt;- round(runif(length(xy), min = 0.5, max = 1.5),1)

dt &lt;- cumsum(inter_dt)

dec &lt;- extricate(xy, dt, nimf = 7, repl = 1, comb = 40, factor_noise = 10,
                 sifting = 10, speak = TRUE, output_sifting = TRUE)

integrity(xy, dec)

parsimony(dec)

plot_emd(dec, select = c(4, 6), pdf = FALSE)
## Not run: 
plot_emd(dec, li = list(v = 0), dir = tempdir())
## End(Not run)

</code></pre>

<hr>
<h2 id='gzc'>Calculates instantaneous frequency using the GZC method</h2><span id='topic+gzc'></span>

<h3>Description</h3>

<p>Calculates instantaneous frequency using the Generalised
Zero-Crossing method from Huang et al., 2009. General wrapper for the
<code><a href="#topic+gzc.algorithm">gzc.algorithm</a></code> function that does all the actual work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gzc(
  emd = NULL,
  ini = NULL,
  m = NULL,
  dt = NULL,
  repl = 1,
  mode = NULL,
  dtout = NULL,
  output = 1,
  warn = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gzc_+3A_emd">emd</code></td>
<td>
<p>emd-type object</p>
</td></tr>
<tr><td><code id="gzc_+3A_ini">ini</code></td>
<td>
<p>an optional vector of length n of the eventual initial Intrinsic
Mode Function xy would be a demodulation of, if it is a demodulation. It will
be integrated to the results as mode 1.</p>
</td></tr>
<tr><td><code id="gzc_+3A_m">m</code></td>
<td>
<p>a matrix of the amplitude values (xy) of the components, each
column being a component. Each column should have the same number of non NA
values. Vectors, for 1 component, are accepted. Is overridden by emd.</p>
</td></tr>
<tr><td><code id="gzc_+3A_dt">dt</code></td>
<td>
<p>the depth or time value. Is overridden by emd.</p>
</td></tr>
<tr><td><code id="gzc_+3A_repl">repl</code></td>
<td>
<p>the amount of replicates in m. Is overridden by emd.</p>
</td></tr>
<tr><td><code id="gzc_+3A_mode">mode</code></td>
<td>
<p>the mode sequence index to give to each replicated IMFs</p>
</td></tr>
<tr><td><code id="gzc_+3A_dtout">dtout</code></td>
<td>
<p>the dt values to sample the frequency and amplitude from if
<code>output = 2</code>.</p>
</td></tr>
<tr><td><code id="gzc_+3A_output">output</code></td>
<td>
<p>the style of the output, whether 0, 1 or 2. 0 provides the raw
output of <code><a href="#topic+gzc.algorithm">gzc.algorithm</a></code>, 1 and 2 provides a matrix with $dt
(depth/time), $f (frequency) and $a ()amplitude, but with <code>output = 1</code>
the matrix provides the dt only at the extremas and zero-crossings, whereas
with <code>output = 2</code> the dt values
are the ones provided with the <code>dtout</code> parameter. 1 is better for
plots, 2 allows easier calculations to be performed downstream.</p>
</td></tr>
<tr><td><code id="gzc_+3A_warn">warn</code></td>
<td>
<p>whether to warn if the sampling interval defined by the
<code>dtout</code> parameter is to small (redirected from
<code>StratigrapheR::tie.lim</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>depending on the output parameter:
</p>
<p><code>output = 0</code> provides the raw output of <code><a href="#topic+gzc.algorithm">gzc.algorithm</a></code>,
with $ldt and $rdt (the left and right boundaries of the depth/time
intervals), $f (frequency) and $a (amplitude). To that are added $repl (the
replicate id) and $mode (the mode id)
</p>
<p><code>output = 1</code> or <code>2</code> provides a matrix with $dt,
$f and $a, but with <code>output = 1</code> the matrix provides the dt only at
the extremas and zero-crossings, whereas with <code>output = 2</code> the dt values
are the ones provided with the <code>out</code> parameter. <code>1</code> is better for
plots, <code>2</code> allows easier calculations to be performed downstream.
</p>


<h3>References</h3>

<p>Huang, Norden E., Zhaohua Wu, Steven R. Long, Kenneth C. Arnold,
Xianyao Chen, and Karin Blank. 2009. &quot;On Instantaneous Frequency&quot;. Advances
in Adaptive Data Analysis 01 (02): 177–229.
https://doi.org/10.1142/S1793536909000096.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

n &lt;- 600
t &lt;- seq_len(n)

p1 &lt;- 30
p2 &lt;- 240

xy &lt;- (1 + 0.6 * sin(t*2*pi/p2)) * sin(t*2*pi/p1)  + 2 * sin(t*2*pi/p2) +
  rnorm(n, sd = 0.5) + t * 0.01

inter_dt &lt;- round(runif(length(xy), min = 0.5, max = 1.5),1)

dt &lt;- cumsum(inter_dt)
dec &lt;- extricate(xy, dt, nimf = 7, repl = 1, comb = 50,
                  factor_noise = 10, sifting = 10, speak = TRUE)

## Not run: 
plot_emd(dec, dir = tempdir())
## End(Not run)

integrity(xy, dec)
parsimony(dec)

res &lt;- gzc(dec)

numb &lt;- 4

opar &lt;- par('mfrow')

par(mfrow = c(1,2))

plot(dec$m[,numb], dec$dt, type = "l",
     main = paste("Mode", numb, " + Amplitude"),
     xlab = "xy", ylab = "dt", ylim = c(0, 600))
lines(res$a[,numb], res$dt[,numb], col = "red", lwd = 2)

plot(1/res$f[,numb], res$dt[,numb], ylim = c(0,600),
     xlab = "Period", ylab = "dt", log = "x",
     type = "l", col = "red", lwd = 2, main = "Period")

par(mfrow = opar)

</code></pre>

<hr>
<h2 id='gzc.algorithm'>Calculates instantaneous frequency of simplified IMF using the GZC
method</h2><span id='topic+gzc.algorithm'></span>

<h3>Description</h3>

<p>Calculates instantaneous frequency of simplified IMF using the
Generalised Zero-Crossing method from Huang et al., 2009.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gzc.algorithm(xy, dt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gzc.algorithm_+3A_xy">xy</code></td>
<td>
<p>a matrix of amplitude</p>
</td></tr>
<tr><td><code id="gzc.algorithm_+3A_dt">dt</code></td>
<td>
<p>a vector of depth or time values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the GZC method is precise to 1/4th of a period, so the results are
provided between left and right points, i.e. either an extrema or a
zero-crossing.
</p>


<h3>Value</h3>

<p>a list of $ldt (left position), $rdt (right position), $f
(frequency) and $a (amplitude)
</p>


<h3>References</h3>

<p>Huang, Norden E., Zhaohua Wu, Steven R. Long, Kenneth C. Arnold,
Xianyao Chen, and Karin Blank. 2009. ‘On Instantaneous Frequency’. Advances
in Adaptive Data Analysis 01 (02): 177–229.
https://doi.org/10.1142/S1793536909000096.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xyi  &lt;- c(0.5,0,-0.5,0,0.5,0,-0.5,0,0.5,0,-0.5,0,0.5,0,-0.5,0,0.5,0,-0.5,0,
         1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1)

dti &lt;- 1:length(xyi)

d &lt;- simp.emd(m = xyi, dt = dti)

xy &lt;- d$xy
dt &lt;- d$dt

res &lt;- gzc.algorithm(xy, dt)

opar &lt;- par('mfrow')

par(mfrow = c(2,1))

plot(dti, xyi, pch = 19, type = "o", ylab = "xy", xlab = "dt")
points(dt, xy, pch = 19, col = "green")
points(res$ldt, res$a, pch = 19, col = "red")
points(res$rdt, res$a, pch = 19, col = "red")

plot(dt, rep(max(res$f, na.rm = TRUE), length(dt)), type = "n",
     ylab = "Frequency", xlab = "dt",
     ylim = c(0, 2 * max(res$f, na.rm = TRUE)))
points(res$ldt, res$f, pch = 19)
points(res$rdt, res$f, pch = 19)

par(mfrow = opar)

</code></pre>

<hr>
<h2 id='gzc.departure'>departure of instantaneous frequency to generalized zero-crossing</h2><span id='topic+gzc.departure'></span>

<h3>Description</h3>

<p>departure of instantaneous frequency to generalized
zero-crossing of instantaneous freqeuncy. The departure is calculated as the
exponential of the absolute difference of logarithms
of frequencies obtained using a robust generalized zero-crossing method
through the <code><a href="#topic+gzc">gzc</a></code> function (where the components are simplified
into extrema separated by zero-crossings) and instantaneous frequency
computed from another method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gzc.departure(
  pulse = NULL,
  dt = NULL,
  m = NULL,
  f = NULL,
  repl = 1,
  mode = NULL,
  simplify = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gzc.departure_+3A_pulse">pulse</code></td>
<td>
<p>a pulse object object</p>
</td></tr>
<tr><td><code id="gzc.departure_+3A_dt">dt</code></td>
<td>
<p>the depth or time. Is overridden by pulse.</p>
</td></tr>
<tr><td><code id="gzc.departure_+3A_m">m</code></td>
<td>
<p>a matrix of the modes to calculate the gzc frequency from. Is
overridden by pulse.</p>
</td></tr>
<tr><td><code id="gzc.departure_+3A_f">f</code></td>
<td>
<p>a matrix of the frequencies to compare to gzc.</p>
</td></tr>
<tr><td><code id="gzc.departure_+3A_repl">repl</code></td>
<td>
<p>the amount of replicates in m. Is overridden by emd.</p>
</td></tr>
<tr><td><code id="gzc.departure_+3A_mode">mode</code></td>
<td>
<p>the mode sequence index to give to each replicated IMFs.
Is overridden by emd.</p>
</td></tr>
<tr><td><code id="gzc.departure_+3A_simplify">simplify</code></td>
<td>
<p>whether to average the value for each component of each
replicate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If simplify is TRUE, the function returns the average gzc departure
as a data frame where the columns stand for the modes and the rows for the
replicates. If simplify if FALSE, the function returns the functions returns
local gzc departure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

n &lt;- 600
t &lt;- seq_len(n)

p1 &lt;- 30
p2 &lt;- 240

xy &lt;- (1 + 0.6 * sin(t*2*pi/p2)) * sin(t*2*pi/p1)  + 2 * sin(t*2*pi/p2) +
  rnorm(n, sd = 0.5) + t * 0.01

inter_dt &lt;- round(runif(length(xy), min = 0.5, max = 1.5),1)

dt &lt;- cumsum(inter_dt)

dec1 &lt;- extricate(xy, dt, nimf = 5, repl = 1, comb = 10, sifting = 1,
                 factor_noise = 10, bind = TRUE, speak = TRUE)

dec2 &lt;- extricate(xy, dt, nimf = 6, repl = 1, comb = 100, sifting = 5,
                  factor_noise = 50, bind = TRUE, speak = TRUE)

## Not run: 
plot_emd(dec1, name = "EMD 1", dir = tempdir())
plot_emd(dec2, name = "EMD 2", dir = tempdir())
## End(Not run)

parsimony(dec1)
parsimony(dec2)

f1 &lt;- inst.pulse(dec1, plot = FALSE)
f2 &lt;- inst.pulse(dec2, plot = FALSE)

gzc.departure(f1)
gzc.departure(f2)

</code></pre>

<hr>
<h2 id='HilbertEnvelope'>Instantaneous amplitude</h2><span id='topic+HilbertEnvelope'></span>

<h3>Description</h3>

<p>Generates the instantaneous amplitude of an analytic signal
given by <code><a href="#topic+HilbertTransform">HilbertTransform</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HilbertEnvelope(asig)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HilbertEnvelope_+3A_asig">asig</code></td>
<td>
<p>The analytic signal returned by <code><a href="#topic+HilbertTransform">HilbertTransform</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>envelope	Instantaneous amplitude
</p>


<h3>Author(s)</h3>

<p>Daniel C. Bowman (in the hht package)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HilbertTransform">HilbertTransform</a></code>, <code><a href="#topic+InstantaneousFrequency">InstantaneousFrequency</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tt &lt;- seq(1000) * 0.01
sig &lt;- sin(4 * pi * tt) + sin(3.4 * pi * tt)
asig &lt;- HilbertTransform(sig)
env &lt;- HilbertEnvelope(asig)
plot(tt, sig, type = "l")
lines(tt, env, col = "red")
lines(tt, -env, col = "red")

</code></pre>

<hr>
<h2 id='HilbertTransform'>The Hilbert transform</h2><span id='topic+HilbertTransform'></span>

<h3>Description</h3>

<p>Creates the analytic signal using the Hilbert transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HilbertTransform(sig)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HilbertTransform_+3A_sig">sig</code></td>
<td>
<p>Signal to transform.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates the real and imaginary parts of a signal.
</p>


<h3>Value</h3>

<p>asig Analytic signal
</p>


<h3>Author(s)</h3>

<p>Daniel C. Bowman (in the hht package)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HilbertEnvelope">HilbertEnvelope</a></code>, <code><a href="#topic+InstantaneousFrequency">InstantaneousFrequency</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tt   &lt;- seq(1000) * 0.01
sig  &lt;- sin(pi * tt)
asig &lt;- HilbertTransform(sig)

plot(tt, sig, xlim = c(0, 12))

lines(tt, Re(asig), col = "green")
lines(tt, Im(asig), col = "red")
legend("topright", col = c("black", "green", "red"),
       lty = c(NA, 1, 1), pch = c(1, NA, NA),
       legend = c("Signal", "Real", "Imaginary"))

</code></pre>

<hr>
<h2 id='inst.pulse'>Computes instantaneous frequency using the Hilbert transform</h2><span id='topic+inst.pulse'></span>

<h3>Description</h3>

<p>Calculates instantaneous frequency using the Hilbert transform
(HT), normalised Hilbert transform (NHT) or the direct quadrature (DQ)
methods. Normalisation is done for NHT and DQ using Huang et al., 2009
algorithm, but the empirical normalisation scheme can fail due to overshoot
or undershoot of the spline. Additional research is necessary for that last
feature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inst.pulse(
  emd = NULL,
  imf = NULL,
  m = NULL,
  dt = NULL,
  ini = NULL,
  repl = 1,
  mode = NULL,
  last = FALSE,
  plot = TRUE,
  method = "HT",
  delta = NULL,
  tolerance = 8,
  relative = TRUE,
  breaks = 500,
  bins = 100,
  cut = 18,
  lines = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inst.pulse_+3A_emd">emd</code></td>
<td>
<p>an emd object</p>
</td></tr>
<tr><td><code id="inst.pulse_+3A_imf">imf</code></td>
<td>
<p>a matrix of same frequency modes to calculate the frequency from.
Is overridden by emd. This allows to calculate and visualise the results
for single IMFs more clearly than in a population plot.</p>
</td></tr>
<tr><td><code id="inst.pulse_+3A_m">m</code></td>
<td>
<p>a matrix of the modes to calculate the frequency from. Is overridden
by emd and imf.</p>
</td></tr>
<tr><td><code id="inst.pulse_+3A_dt">dt</code></td>
<td>
<p>the depth or time. Is overridden by emd.</p>
</td></tr>
<tr><td><code id="inst.pulse_+3A_ini">ini</code></td>
<td>
<p>an optional vector of length n of the eventual initial Intrinsic
Mode Function xy would be a demodulation of, if it is a demodulation. It will
be integrated to the results as mode 1.</p>
</td></tr>
<tr><td><code id="inst.pulse_+3A_repl">repl</code></td>
<td>
<p>the amount of replicates in m. Is overridden by emd.</p>
</td></tr>
<tr><td><code id="inst.pulse_+3A_mode">mode</code></td>
<td>
<p>the mode sequence index to give to each replicated IMFs.
Is overridden by emd.</p>
</td></tr>
<tr><td><code id="inst.pulse_+3A_last">last</code></td>
<td>
<p>whether to use the last mode (trend/residue).</p>
</td></tr>
<tr><td><code id="inst.pulse_+3A_plot">plot</code></td>
<td>
<p>whether to have a plot summary of the output.</p>
</td></tr>
<tr><td><code id="inst.pulse_+3A_method">method</code></td>
<td>
<p>the IF calculation method: &quot;HT&quot; for Hilbert transform
(default), &quot;NHT&quot; for normalised Hilbert transform, and &quot;DQ&quot; for direct
quadrature. The two last require normalisation, which can sometimes fail.</p>
</td></tr>
<tr><td><code id="inst.pulse_+3A_delta">delta</code>, <code id="inst.pulse_+3A_tolerance">tolerance</code>, <code id="inst.pulse_+3A_relative">relative</code></td>
<td>
<p>parameters to feed to <code><a href="#topic+respace">respace</a></code>
for interpolation</p>
</td></tr>
<tr><td><code id="inst.pulse_+3A_breaks">breaks</code>, <code id="inst.pulse_+3A_bins">bins</code>, <code id="inst.pulse_+3A_cut">cut</code></td>
<td>
<p>parameter for the plots: <code>breaks</code> is fed to
<code><a href="#topic+plot_hist">plot_hist</a></code>, <code>bins</code> is fed to <code><a href="#topic+plot_hex">plot_hex</a></code>, and
cut defines the number of color cuts for <code><a href="#topic+plot_hex">plot_hex</a></code>. For better
control use <code><a href="#topic+plot_hist">plot_hist</a></code> and <code><a href="#topic+plot_hex">plot_hex</a></code> directly.</p>
</td></tr>
<tr><td><code id="inst.pulse_+3A_lines">lines</code></td>
<td>
<p>the period of lines to be added to the plots for better
visualisation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list made of $dt (depth/time), $f (instantaneous frequency), $a
(instantaneous amplitude),$repl (the replicate id of each point) and
$mode (the mode id of each point)
</p>


<h3>References</h3>

<p>Huang, Norden E., Zhaohua Wu, Steven R. Long, Kenneth C. Arnold,
Xianyao Chen, and Karin Blank. 2009. &quot;On Instantaneous Frequency&quot;. Advances
in Adaptive Data Analysis 01 (02): 177–229.
https://doi.org/10.1142/S1793536909000096.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

n &lt;- 600
t &lt;- seq_len(n)

p1 &lt;- 30
p2 &lt;- 240

xy &lt;- (1 + 0.6 * sin(t*2*pi/p2)) * sin(t*2*pi/p1)  + 2 * sin(t*2*pi/p2) +
  rnorm(n, sd = 0.5) + t * 0.01

inter_dt &lt;- round(runif(length(xy), min = 0.5, max = 1.5),1)

dt &lt;- cumsum(inter_dt)
dec &lt;- extricate(xy, dt, nimf = 7, repl = 10, comb = 10,
                  factor_noise = 10, sifting = 10, speak = FALSE)
## Not run: 
plot_emd(dec, dir = tempdir())
## End(Not run)

integrity(xy, dec)
parsimony(dec)

ht   &lt;- inst.pulse(dec, lines = c(30, 240))
gzcr &lt;- gzc(dec)

imf &lt;- dec$m[,4]

inst.pulse(imf = imf, dt = dt, method = "DQ")

</code></pre>

<hr>
<h2 id='inst.ratio'>Computes instantaneous ratio of frequency</h2><span id='topic+inst.ratio'></span>

<h3>Description</h3>

<p>Computes instantaneous ratio of frequency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inst.ratio(
  pulse = NULL,
  dt = NULL,
  f = NULL,
  a = NULL,
  repl = 1,
  plot = TRUE,
  sqrt.rpwr = TRUE,
  style = "b",
  select = NA,
  bins = 100,
  cut = 18,
  lines = NULL,
  width = 10,
  height = 10,
  name = "Ratio",
  ext = ".pdf",
  dir = tempdir(),
  track = TRUE,
  openfile = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inst.ratio_+3A_pulse">pulse</code></td>
<td>
<p>a pulse object (created by inst.pulse for instance)</p>
</td></tr>
<tr><td><code id="inst.ratio_+3A_dt">dt</code></td>
<td>
<p>depth/time. Is overridden by pulse.</p>
</td></tr>
<tr><td><code id="inst.ratio_+3A_f">f</code></td>
<td>
<p>instantaneous frequency. Is overridden by pulse.</p>
</td></tr>
<tr><td><code id="inst.ratio_+3A_a">a</code></td>
<td>
<p>instantaneous amplitude. Is overridden by pulse.</p>
</td></tr>
<tr><td><code id="inst.ratio_+3A_repl">repl</code></td>
<td>
<p>number of replicates in f</p>
</td></tr>
<tr><td><code id="inst.ratio_+3A_plot">plot</code></td>
<td>
<p>whether to plot an output</p>
</td></tr>
<tr><td><code id="inst.ratio_+3A_sqrt.rpwr">sqrt.rpwr</code>, <code id="inst.ratio_+3A_style">style</code>, <code id="inst.ratio_+3A_select">select</code>, <code id="inst.ratio_+3A_bins">bins</code>, <code id="inst.ratio_+3A_cut">cut</code>, <code id="inst.ratio_+3A_lines">lines</code>, <code id="inst.ratio_+3A_width">width</code>, <code id="inst.ratio_+3A_height">height</code></td>
<td>
<p>parameters to feed
to <code><a href="#topic+plot_ratio">plot_ratio</a></code> for the plots</p>
</td></tr>
<tr><td><code id="inst.ratio_+3A_name">name</code>, <code id="inst.ratio_+3A_ext">ext</code>, <code id="inst.ratio_+3A_dir">dir</code>, <code id="inst.ratio_+3A_track">track</code>, <code id="inst.ratio_+3A_openfile">openfile</code></td>
<td>
<p>parameters to feed to
<code>pdfDisplay</code> in <code><a href="#topic+plot_ratio">plot_ratio</a></code> for pdf plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of depth/time ($dt), frequency ($f), ratio of frequency
($ratio), if a is provided; the ratio power ($rpwr) i.e. the multiplication
of the instantaneous amplitudes of the modes two by two, the replicates id
($repl)and id for the first and second frequency modes used for the ratio
($l for the first, $r for the second, or $lr for the two combined)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

n    &lt;- 600
time &lt;- seq_len(n)

p1 &lt;- 30
p2 &lt;- 240

xy &lt;- (1 + 0.6 * sin(time *2*pi/p2)) * sin(time *2*pi/p1)  +
  2 * sin(time *2*pi/p2) + rnorm(n, sd = 0.5)

inter_dt &lt;- round(runif(length(xy), min = 0.5, max = 1.5),1)

dt &lt;- cumsum(inter_dt)

dec &lt;- extricate(xy, dt, nimf = 7, sifting = 10,
                repl = 10, comb = 10, factor_noise = 10,
                speak = TRUE)

## Not run: 
plot_emd(dec, dir = tempdir())
## End(Not run)

integrity(xy, dec)
parsimony(dec)

ht    &lt;- inst.pulse(dec, lines = c(30, 240))
ratio &lt;- inst.ratio(ht, style = "s", lines = 8)

</code></pre>

<hr>
<h2 id='InstantaneousFrequency'>Derive instantaneous frequency</h2><span id='topic+InstantaneousFrequency'></span>

<h3>Description</h3>

<p>Calculates instantaneous frequency from an analytic signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InstantaneousFrequency(asig, tt, method = "arctan", lag = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="InstantaneousFrequency_+3A_asig">asig</code></td>
<td>
<p>Analytic signal produced by <code><a href="#topic+HilbertTransform">HilbertTransform</a></code></p>
</td></tr>
<tr><td><code id="InstantaneousFrequency_+3A_tt">tt</code></td>
<td>
<p>Sample times</p>
</td></tr>
<tr><td><code id="InstantaneousFrequency_+3A_method">method</code></td>
<td>
<p>How the instantaneous frequency is calculated. &quot;<code>arctan</code>&quot;
uses the arctangent of the real and imaginary parts of the Hilbert transform,
taking the numerical derivative of phase for frequency. &quot;<code>chain</code>&quot; uses
the  analytical derivative of the arctangent function prior to performing the
numerical calculation.</p>
</td></tr>
<tr><td><code id="InstantaneousFrequency_+3A_lag">lag</code></td>
<td>
<p>Differentiation lag, see the <code>diff</code> function in the
<code>base</code> package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>instfreq	Instantaneous frequency in 1/time
</p>


<h3>Note</h3>

<p>The &quot;<code>arctan</code>&quot; method was adapted from the <code>hilbertspec</code>
function in the <code>EMD</code> package.
</p>
<p>!!IMPORTANT!! The numeric differentiation may be unstable for certain
signals. For example, high frequency sinusoids near the Nyquist frequency
can give inaccurate results when using the &quot;<code>chain</code>&quot; method. When in
doubt, use the <code><a href="#topic+PrecisionTester">PrecisionTester</a></code> function to check your results!
</p>


<h3>Author(s)</h3>

<p>Daniel C. Bowman (in the hht package)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PrecisionTester">PrecisionTester</a></code>
</p>

<hr>
<h2 id='integrity'>Integrity of a decomposition</h2><span id='topic+integrity'></span>

<h3>Description</h3>

<p>The function additions each component of a decomposition by
depth/time, subtract it with the original signal, and provides the absolute
of this subtraction. This is allows to verify if the
decomposition is computed correctly.
</p>
<p>The bulk value is the cumulated value of this proxy. If the decomposition
is done right the value should be very small, but non-zero due to the
floating-point arithmetics used by computers that generate tiny errors. Its
actually interesting: the first computations of the orbital solutions were
strongly affected by this error, as the chaotic behaviour of the equations
enhanced the effect of these tiny tiny errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrity(xy, emd = NULL, m = NULL, repl = 1, bulk = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="integrity_+3A_xy">xy</code></td>
<td>
<p>the signal</p>
</td></tr>
<tr><td><code id="integrity_+3A_emd">emd</code></td>
<td>
<p>an emd object to test. The emd$xy original signal is not used,
to avoid confusion: you always have to provide the xy signal yourself.</p>
</td></tr>
<tr><td><code id="integrity_+3A_m">m</code></td>
<td>
<p>a matrix with columns of same length that xy, made of the
decomposition of the signal. Is overridden by emd.</p>
</td></tr>
<tr><td><code id="integrity_+3A_repl">repl</code></td>
<td>
<p>the replication of decompositions in m. Is overridden by emd.</p>
</td></tr>
<tr><td><code id="integrity_+3A_bulk">bulk</code></td>
<td>
<p>whether to have a bulk value each decomposition replication, or
for each dt of each replication</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with each column being a replication, or a list of bulk
values for each replication
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

n &lt;- 600
t &lt;- seq_len(n)

p1 &lt;- 30
p2 &lt;- 240

xy &lt;- (1 + 0.6 * sin(t*2*pi/p2)) * sin(t*2*pi/p1)  + 2 * sin(t*2*pi/p2) +
  rnorm(n, sd = 0.5)

inter_dt &lt;- round(runif(length(xy), min = 0.5, max = 1.5),1)

dt &lt;- cumsum(inter_dt)

dec &lt;- extricate(xy, dt, nimf = 7, repl = 10, comb = 10, factor_noise = 10,
                 sifting = 10, speak = TRUE, output_sifting = TRUE)

integrity(xy, dec)

</code></pre>

<hr>
<h2 id='is.ratio'>Check ratio objects</h2><span id='topic+is.ratio'></span>

<h3>Description</h3>

<p>Check ratio objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.ratio(ratio)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.ratio_+3A_ratio">ratio</code></td>
<td>
<p>a ratio object to check</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

n &lt;- 600
t &lt;- seq_len(n)

p1 &lt;- 30
p2 &lt;- 240

xy &lt;- (1 + 0.6 * sin(t*2*pi/p2)) * sin(t*2*pi/p1)  + 2 * sin(t*2*pi/p2) +
  rnorm(n, sd = 0.5)

inter_dt &lt;- round(runif(length(xy), min = 0.5, max = 1.5),1)

dt &lt;- cumsum(inter_dt)

dec &lt;- extricate(xy, dt, nimf = 7, sifting = 10,
                 repl = 10, comb = 10, factor_noise = 10,
                 speak = TRUE)

ht    &lt;- inst.pulse(dec, plot = FALSE)
ratio &lt;- inst.ratio(ht, plot = FALSE)

is.ratio(ratio)

</code></pre>

<hr>
<h2 id='is.simp.emd'>Tests for simplified EMD</h2><span id='topic+is.simp.emd'></span>

<h3>Description</h3>

<p>Tests whether each column of a matrix is an alternation of
-minima zero-crossing maxima zero-crossing-
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.simp.emd(xy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.simp.emd_+3A_xy">xy</code></td>
<td>
<p>a vector or matrix of values to test</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>xytest1 &lt;- c(0.5, 1,-1,-0.85,-0.5,-1,-0.5,-1,1,0.5,0,-1,0,
             1,-1,0,1,2,-2,1,2,1,3,0,-1,-1,3,0)

xytest2 &lt;- c(0, 1,-1,-0.85,-0.5,-1,-0.5,-1,1,0.5,0,0,
             1,1,1,1,2,-2,1,2,1,3,0,-1,-1,3,0)

dat1 &lt;- simp.emd(m = xytest1, dt = 1:length(xytest1))

dat2 &lt;- simp.emd(m = xytest2, dt = 1:length(xytest2))

is.simp.emd(dat1$xy)

is.simp.emd(dat2$xy)

# There is a problem when two maxima or minima are separeted by a point at 0
# that does not cross any further, creating a false simplified IMF. THis is
# not considered as a simplified IMF by this function. However this scenario
# should be very rare in EMDs, but you never really know.

</code></pre>

<hr>
<h2 id='mode.in'>Add / Remove / Bind modes in emd objects</h2><span id='topic+mode.in'></span><span id='topic+mode.out'></span><span id='topic+mode.bind'></span>

<h3>Description</h3>

<p>Add / Remove / Bind modes in emd objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mode.in(emd, xy, mode = NA, adjust = TRUE, name = "Added")

mode.out(obj, keep = NULL, lose = NULL, adjust = F, reorder = F)

mode.bind(emd, mode = NA, xy = NULL, adjust = T, name = "bound")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mode.in_+3A_emd">emd</code></td>
<td>
<p>emd-type object</p>
</td></tr>
<tr><td><code id="mode.in_+3A_xy">xy</code></td>
<td>
<p>an Instrinsic Mode Function to add</p>
</td></tr>
<tr><td><code id="mode.in_+3A_mode">mode</code>, <code id="mode.in_+3A_keep">keep</code>, <code id="mode.in_+3A_lose">lose</code></td>
<td>
<p>[mode.in] the position where to add the mode /
[mode.out] the modes to keep or lose / [mode.bind] the modes to merge</p>
</td></tr>
<tr><td><code id="mode.in_+3A_adjust">adjust</code></td>
<td>
<p>whether to adapt the initial signal of an emd object ($xy in
the emd object) when adding or removing a mode</p>
</td></tr>
<tr><td><code id="mode.in_+3A_name">name</code></td>
<td>
<p>the name of the new mode</p>
</td></tr>
<tr><td><code id="mode.in_+3A_obj">obj</code></td>
<td>
<p>emd or pulse type object</p>
</td></tr>
<tr><td><code id="mode.in_+3A_reorder">reorder</code></td>
<td>
<p>whether to reinitialise the index of modes when suppressing
one</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

n &lt;- 600
t &lt;- seq_len(n)

p1 &lt;- 30
p2 &lt;- 240

xy &lt;- (1 + 0.6 * sin(t*2*pi/p2)) * sin(t*2*pi/p1)  + 2 * sin(t*2*pi/p2) +
  rnorm(n, sd = 0.5)

inter_dt &lt;- round(runif(length(xy), min = 0.5, max = 1.5),1)

dt &lt;- cumsum(inter_dt)

dec &lt;- extricate(xy, dt, nimf = 7, sifting = 10,
                 repl = 10, comb = 10, factor_noise = 10,
                 speak = TRUE)

opar &lt;- par('mfrow')

par(mfrow = c(2,1))

integrity(xy, dec)

ht  &lt;- inst.pulse(dec, plot = FALSE)

plot_hist(x = 1/ht$f, breaks = 500, id = ht$mode,
          xlog = TRUE, text = TRUE, xlab = "Period",
          main = "Initial Decomposition")

bound &lt;- mode.bind(dec, mode = c(6,7))

ht2  &lt;- inst.pulse(bound, plot = FALSE)

plot_hist(x = 1/ht2$f, breaks = 500, id = ht2$mode,
          xlog = TRUE, text = TRUE, xlab = "Period",
          main = "Binding of modes 6 and 7")

par(mfrow = opar)

## Not run: 
plot_emd(bound, dir = tempdir(), adapt.axis = TRUE)
## End(Not run)

</code></pre>

<hr>
<h2 id='n.extrema'>Number of extrema/zero-crossings</h2><span id='topic+n.extrema'></span>

<h3>Description</h3>

<p>Computes the number of extrema and zero-crossings for different
groups of data, by their id or separated by NA values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.extrema(
  xy,
  id = NULL,
  use.names = TRUE,
  bound = FALSE,
  local = FALSE,
  zc = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n.extrema_+3A_xy">xy</code></td>
<td>
<p>signal or decomposed signal</p>
</td></tr>
<tr><td><code id="n.extrema_+3A_id">id</code></td>
<td>
<p>the id for different groups. If any NA value is in xy, it will
also separate two groups of data</p>
</td></tr>
<tr><td><code id="n.extrema_+3A_use.names">use.names</code></td>
<td>
<p>whether to use the names in id</p>
</td></tr>
<tr><td><code id="n.extrema_+3A_bound">bound</code>, <code id="n.extrema_+3A_local">local</code>, <code id="n.extrema_+3A_zc">zc</code></td>
<td>
<p>parameters to feed to <code><a href="#topic+extremist">extremist</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the number of minima ($n.min), maxima ($n.max), and, if
zc = TRUE, zero-crossings ($n.cross)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

n &lt;- 600
t &lt;- seq_len(n)

p1 &lt;- 30
p2 &lt;- 240

xy &lt;- (1 + 0.6 * sin(t*2*pi/p2)) * sin(t*2*pi/p1)  + 2 * sin(t*2*pi/p2) +
  rnorm(n, sd = 0.5)

xy &lt;- xy - mean(xy)

inter_dt &lt;- round(runif(length(xy), min = 0.5, max = 1.5),1)

dt &lt;- cumsum(inter_dt)

dec &lt;- extricate(xy, dt, nimf = 7, sifting = 10,
                repl = 1, comb = 40, factor_noise = 10,
                speak = TRUE)

integrity(xy, dec)
parsimony(dec)

n.extrema(dec$m, dec$mode)

plot_emd(dec, select = c(6,8,9), pdf = FALSE, adapt.axis = TRUE)
## Not run: 
plot_emd(dec, li = list(v = 0), adapt.axis = TRUE, dir = tempdir())
## End(Not run)

</code></pre>

<hr>
<h2 id='normalise'>Empirical AM and FM decomposition</h2><span id='topic+normalise'></span><span id='topic+normalize'></span>

<h3>Description</h3>

<p>Applies the normalisation scheme of Huang et al., 2009 to
decompose any Intrinsic Mode Functions obtained (usually via Empirical Mode
Decomposition) into an Frequency Modulated component of amplitude 1, also
called carrier, and its Amplitude Modulated enveloppe. The carrier can then
be used to compute the instantaneous frequency via the Normalised Hilbert
Transform (NHT) or by calculating its Direct Quadrature (DQ) (Huang et al.,
2009). HOWEVER THIS FUNCTION CAN FAIL due to overshoot or undershoot of the
spline fitting. Additional research is necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalise(emd = NULL, m = NULL, dt = NULL, repl = 1, last = TRUE, speak = TRUE)

normalize(emd = NULL, m = NULL, dt = NULL, repl = 1, last = TRUE, speak = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalise_+3A_emd">emd</code></td>
<td>
<p>an emd object</p>
</td></tr>
<tr><td><code id="normalise_+3A_m">m</code></td>
<td>
<p>a matrix of the modes to calculate the amplitude and the frequency
carrier from. Is overridden by emd.</p>
</td></tr>
<tr><td><code id="normalise_+3A_dt">dt</code></td>
<td>
<p>the depth or time. Is overridden by emd.</p>
</td></tr>
<tr><td><code id="normalise_+3A_repl">repl</code></td>
<td>
<p>the amount of replicates in m. Is overridden by emd.</p>
</td></tr>
<tr><td><code id="normalise_+3A_last">last</code></td>
<td>
<p>whether to use the last mode (trend/residue).</p>
</td></tr>
<tr><td><code id="normalise_+3A_speak">speak</code></td>
<td>
<p>whether to print a sentence at each iteration</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of two matrices: $fc (frequency carrier) and $a (instantaneous
amplitude)
</p>


<h3>References</h3>

<p>Huang, Norden E., Zhaohua Wu, Steven R. Long, Kenneth C. Arnold,
Xianyao Chen, and Karin Blank. 2009. ‘On Instantaneous Frequency’. Advances
in Adaptive Data Analysis 01 (02): 177–229.
https://doi.org/10.1142/S1793536909000096.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

n &lt;- 600
t &lt;- seq_len(n)

p1 &lt;- 30
p2 &lt;- 240

xy &lt;- (1 + 0.6 * sin(t*2*pi/p2)) * sin(t*2*pi/p1)  + 2 * sin(t*2*pi/p2) +
        rnorm(n, sd = 0.5)

inter_dt &lt;- round(runif(length(xy), min = 0.5, max = 1.5),1)

dt &lt;- cumsum(inter_dt)

dec &lt;- extricate(xy, dt, nimf = 7, sifting = 10,
               repl = 1, comb = 100, factor_noise = 10,
               speak = TRUE)

plot_emd(dec, pdf = FALSE, select = 4)

integrity(xy, dec)
parsimony(dec)

m  &lt;- dec$m

res &lt;- normalise(dt = dt, m = m, last = FALSE)

numb &lt;- 4

opar &lt;- par('mfrow')

par(mfrow = c(1,2))

plot(m[,numb], dt, type = "l", xlab = "xy",
     main = paste("Mode", numb, "and AM enveloppe"))
lines(res$a[,numb], dt, col = "red", lty = 5, lwd = 2)

plot(res$fc[,numb], dt, type = "l", xlab = "xy",
     main = "FM carrier")

par(mfrow = opar)

</code></pre>

<hr>
<h2 id='oscillate'>Modify a signal using a Van der Pol oscillator</h2><span id='topic+oscillate'></span>

<h3>Description</h3>

<p>Modify a signal using a Van der Pol oscillator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oscillate(
  xy,
  dt,
  period,
  delta = 0.05,
  damp = 5e-05,
  f.noise = 5,
  f.signal = 0.95,
  dx = function(x, y, beta, damp) beta * y - x * (x^2 + y^2 - 1) * damp,
  dy = function(x, y, beta, damp) -beta * x - y * (x^2 + y^2 - 1) * damp,
  xi = if (length(xy) != 0) xy[1] else 0.5,
  yi = if (length(xy) != 0) xy[1] else 0.5,
  normalise = TRUE,
  limit = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oscillate_+3A_xy">xy</code></td>
<td>
<p>initial signal (vector or matrix)</p>
</td></tr>
<tr><td><code id="oscillate_+3A_dt">dt</code></td>
<td>
<p>depth/time (same length than length/rows of xy)</p>
</td></tr>
<tr><td><code id="oscillate_+3A_period">period</code></td>
<td>
<p>the period of the oscillator (length 1 or n)</p>
</td></tr>
<tr><td><code id="oscillate_+3A_delta">delta</code></td>
<td>
<p>the sampling interval for iteration (length 1 or n)</p>
</td></tr>
<tr><td><code id="oscillate_+3A_damp">damp</code></td>
<td>
<p>damping parameter</p>
</td></tr>
<tr><td><code id="oscillate_+3A_f.noise">f.noise</code></td>
<td>
<p>a factor of the amount of noise (length 1 or n)</p>
</td></tr>
<tr><td><code id="oscillate_+3A_f.signal">f.signal</code></td>
<td>
<p>a factor of the amount of signal (length 1 or n)</p>
</td></tr>
<tr><td><code id="oscillate_+3A_dx">dx</code>, <code id="oscillate_+3A_dy">dy</code></td>
<td>
<p>the differentials used in the oscillator. They should be
provided as functions needing x, y, beta (2*pi/period) and damp (damping)
parameters</p>
</td></tr>
<tr><td><code id="oscillate_+3A_xi">xi</code></td>
<td>
<p>the initial x value</p>
</td></tr>
<tr><td><code id="oscillate_+3A_yi">yi</code></td>
<td>
<p>the initial y value</p>
</td></tr>
<tr><td><code id="oscillate_+3A_normalise">normalise</code></td>
<td>
<p>whether to recenter the output signal on the initial signal</p>
</td></tr>
<tr><td><code id="oscillate_+3A_limit">limit</code></td>
<td>
<p>whether to warn when parameters are irrealistic (subjective)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

n &lt;- 800

dt &lt;- seq(0,n, 1)

p1 &lt;- 100
p2 &lt;- 40

xy &lt;- (1 + 0.6 * sin(dt*2*pi/p1)) * sin(dt*2*pi/p2)  + 2 * sin(dt*2*pi/p1) + 1

xyout &lt;- oscillate(xy, dt, period = 30)

opar &lt;- par("mfrow")

par(mfrow = c(1,1))

plot(xy, dt, type = "l",
     main = "Initial signal (bold) &amp; oscillated signal (dashed)",
     lwd = 2, xlim = c(-4, 6))
lines(xyout, dt, type = "l", col = "grey50", lwd = 2, lty = 5)

par(mfrow = opar)

</code></pre>

<hr>
<h2 id='parsimony'>Parsimony of a decomposition</h2><span id='topic+parsimony'></span>

<h3>Description</h3>

<p>The function additions the absolute values of each component of
a decomposition by depth/time, and computes the ratio of that with the
absolute values of the signal. This is done either by depth/time or on the
time/depth-cumulated signal (i.e. the bulk signal).
</p>
<p>This is a proxy for parsimony: it is the factor of amplitude added by the
decomposition. A perfect decomposition, that does not 'invent' wiggles,
should approach 1, but will logically always be higher. However it is
influenced by the absolute value of the initial signal: if the original
signal is not centered around 0, the parsimony is not significative (it
will artificially be closer to 1). To correct for that, the residue (part of
the decomposition that is not centered around zero) has to be removed from
the original signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parsimony(
  emd = NULL,
  xy = NULL,
  m = NULL,
  mode = NULL,
  repl = 1,
  bulk = TRUE,
  correct = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parsimony_+3A_emd">emd</code></td>
<td>
<p>an emd object</p>
</td></tr>
<tr><td><code id="parsimony_+3A_xy">xy</code></td>
<td>
<p>the signal</p>
</td></tr>
<tr><td><code id="parsimony_+3A_m">m</code></td>
<td>
<p>a matrix with columns of same length that xy, made of the
decomposition of the signal</p>
</td></tr>
<tr><td><code id="parsimony_+3A_mode">mode</code></td>
<td>
<p>the mode sequence index to give to each replicated IMFs</p>
</td></tr>
<tr><td><code id="parsimony_+3A_repl">repl</code></td>
<td>
<p>the replication of decompositions in m</p>
</td></tr>
<tr><td><code id="parsimony_+3A_bulk">bulk</code></td>
<td>
<p>whether to have a bulk value each decomposition replication, or
for each dt of each replication</p>
</td></tr>
<tr><td><code id="parsimony_+3A_correct">correct</code></td>
<td>
<p>the modes to remove from the original signal and decomposition
for a significative parsimony calculation. If NA,
it removes the last mode, considered as the residue. Can be a vector of
several integers, standing for the columns of m. If NULL, no mode is removed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with each column being a replication, or a list of bulk
values for each replication
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

n &lt;- 500

dt &lt;- seq_len(n)
xy &lt;- rnorm(n, mean = 0, sd = 1) + 10

dec &lt;- extricate(xy, dt, nimf = 7, comb = 10, sifting = 10,
                 factor_noise = 1, speak = TRUE)
## Not run: 
plot_emd(dec, dir = tempdir())
## End(Not run)

parsimony(dec, correct = NULL)

parsimony(dec)

</code></pre>

<hr>
<h2 id='pile.down'>Destacks a pile.up() signal</h2><span id='topic+pile.down'></span>

<h3>Description</h3>

<p>Destacks a signal stacked by <code><a href="#topic+pile.up">pile.up</a></code> by averaging
each repetition back to n multiples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pile.down(x, stack, even, n = length(unique(stack$id)) - 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pile.down_+3A_x">x</code></td>
<td>
<p>Treated signal</p>
</td></tr>
<tr><td><code id="pile.down_+3A_stack">stack</code></td>
<td>
<p>Initial stack from which the x signal is from</p>
</td></tr>
<tr><td><code id="pile.down_+3A_even">even</code></td>
<td>
<p>Whether the x signal comes from even extension part of the
initial stack (if FALSE, it would come from the odd extension part)</p>
</td></tr>
<tr><td><code id="pile.down_+3A_n">n</code></td>
<td>
<p>The multiple of destacking (has to be a multiple of n/2 (n being the
parameter used in <code><a href="#topic+pile.up">pile.up</a></code>), in other words a multiple of
length(unique(stack$id)) - 2 (minus 2 as the upper an lower extension are to
be removed)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix or a vector of the destacked signal
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

n &lt;- 200
t &lt;- seq_len(n)

p1 &lt;- 25
p2 &lt;- 75

xy &lt;- (1 + 0.6 * sin(t*2*pi/p2)) * sin(t*2*pi/p1)  + 2 * sin(t*2*pi/p2) +
  rnorm(n, sd = 0.5)

inter_dt &lt;- round(runif(length(xy), min = 0.5, max = 1.5),1)
inter_dt[20] &lt;- 20

dt &lt;- cumsum(inter_dt)

opar &lt;- par()$mfrow
par(mfrow = c(1,1))

res &lt;- pile.up(xy, dt, 4)

par(mfrow = c(2,1))
plot(res$ndt, res$even, type = "l", col = "blue")
plot(res$ndt, res$odd,  type = "l", col = "red")

par(mfrow = c(opar))

# Small number of repetitions ----

opar &lt;- par("mfrow")
par(mfrow = c(1,2))

stack &lt;- pile.up(xy, dt, 10)

signal &lt;- stack$even + runif(length(stack$even), -3, 3)

res &lt;- pile.down(signal, stack, even = TRUE, n = 5)

plot(xy, dt, type = "l", lwd = 2, main = "Low number of repetitions")
lines(res, dt,  type = "l", lty = 5, col = "red")

# High number of repetitions ----

stack &lt;- pile.up(xy, dt, 1000)

signal &lt;- stack$even + runif(length(stack$even), -3, 3)

res &lt;- pile.down(signal, stack, even = TRUE, n = 500)

plot(xy, dt, type = "l", lwd = 2, main = "High number of repetitions")
lines(res, dt,  type = "l", lty = 5, col = "red")

par(mfrow = c(opar))

</code></pre>

<hr>
<h2 id='pile.up'>Repeat and stack a signal in central and line symmetry</h2><span id='topic+pile.up'></span>

<h3>Description</h3>

<p>Repeats and stacks a signal duplicated in central (even) and
line (odd) symmetry to apply Ensemble Empirical Mode Decomposition (EEMD) on
one single vector following the simple boundary rule of Zeng and He (2004).
This allows to avoid the iterations that are typical of EEMD. A complete
set of signal is added by default at the upper and lower part of the stack,
to be removed in the end process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pile.up(xy, dt, n, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pile.up_+3A_xy">xy</code></td>
<td>
<p>the signal</p>
</td></tr>
<tr><td><code id="pile.up_+3A_dt">dt</code></td>
<td>
<p>the depth/time positions of each xy</p>
</td></tr>
<tr><td><code id="pile.up_+3A_n">n</code></td>
<td>
<p>the number of replicates you want. It has to be a multiple of two,
as you will generate two stacks: the even and the odd one.</p>
</td></tr>
<tr><td><code id="pile.up_+3A_warn">warn</code></td>
<td>
<p>whether you want to be annoyed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe of the original dt (odt), the stack-modified dt (ndt),
the inversion factor to change the even stack into the odd one and
vice-versa (invert), the even xy stack (even) and the odd one (odd)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

n &lt;- 200
t &lt;- seq_len(n)

p1 &lt;- 25
p2 &lt;- 75

xy &lt;- (1 + 0.6 * sin(t*2*pi/p2)) * sin(t*2*pi/p1)  + 2 * sin(t*2*pi/p2) +
  rnorm(n, sd = 0.5)

inter_dt &lt;- round(runif(length(xy), min = 0.5, max = 1.5),1)
inter_dt[20] &lt;- 20

dt &lt;- cumsum(inter_dt)

opar &lt;- par()$mfrow
par(mfrow = c(1,1))

res &lt;- pile.up(xy, dt, 4)

par(mfrow = c(2,1))
plot(res$ndt, res$even, type = "l", col = "blue")
plot(res$ndt, res$odd,  type = "l", col = "red")

par(mfrow = c(opar))

</code></pre>

<hr>
<h2 id='plot_emd'>Plot a decomposition</h2><span id='topic+plot_emd'></span>

<h3>Description</h3>

<p>General plot for a complete decomposition (that can be
summed back to the original signal)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_emd(
  emd = NULL,
  xy = NULL,
  ini = NULL,
  dt = NULL,
  m = NULL,
  mode = NULL,
  repl = 1,
  size.xy = 5,
  size.dt = 25,
  style = 2,
  xylim = NULL,
  dtlim = NULL,
  inilim = NULL,
  vertical = TRUE,
  adapt.axis = FALSE,
  adapt.last = TRUE,
  select = NULL,
  over = NULL,
  s = list(type = "o", pch = 19, cex = 0.5),
  o = list(type = "l", col = "blue", lwd = 2),
  i = list(type = "o", pch = 19, cex = 0.5),
  e = list(type = "l", col = "red", lwd = 2),
  la = list(h = c(), v = c(), col = "red", xpd = FALSE),
  ls = list(),
  li = list(col = "grey", lty = 5),
  box = TRUE,
  ax = list(),
  ay = list(),
  parg = list(),
  title = TRUE,
  t1 = "Signal",
  t2 = "Mode",
  pdf = TRUE,
  name = "EMD",
  ext = ".pdf",
  dir = tempdir(),
  track = TRUE,
  openfile = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_emd_+3A_emd">emd</code></td>
<td>
<p>an emd object</p>
</td></tr>
<tr><td><code id="plot_emd_+3A_xy">xy</code></td>
<td>
<p>the original signal. Is overridden by emd.</p>
</td></tr>
<tr><td><code id="plot_emd_+3A_ini">ini</code></td>
<td>
<p>an optional vector of length n of the eventual initial Intrinsic
Mode Function xy would be a demodulation of, if it is a demodulation.</p>
</td></tr>
<tr><td><code id="plot_emd_+3A_dt">dt</code></td>
<td>
<p>the depth/time. Is overridden by emd.</p>
</td></tr>
<tr><td><code id="plot_emd_+3A_m">m</code></td>
<td>
<p>a matrix with columns of same length that xy, made of the
decomposition of the signal. Is overridden by emd.</p>
</td></tr>
<tr><td><code id="plot_emd_+3A_mode">mode</code></td>
<td>
<p>which modes/decompositions to plot</p>
</td></tr>
<tr><td><code id="plot_emd_+3A_repl">repl</code></td>
<td>
<p>the replication of decompositions in m. Is overridden by emd.</p>
</td></tr>
<tr><td><code id="plot_emd_+3A_size.xy">size.xy</code>, <code id="plot_emd_+3A_size.dt">size.dt</code></td>
<td>
<p>the size i inches of each individual plot in pdf</p>
</td></tr>
<tr><td><code id="plot_emd_+3A_style">style</code></td>
<td>
<p>whether to not plot the original signal (style = 0), to plot it
as the first signal (style = 1), or to plot it before each individual mode
(style = 2, is the default)</p>
</td></tr>
<tr><td><code id="plot_emd_+3A_xylim">xylim</code>, <code id="plot_emd_+3A_dtlim">dtlim</code>, <code id="plot_emd_+3A_inilim">inilim</code></td>
<td>
<p>the boundaries for the plots (inilim stands for the
xy boundaries of the plot of the initial IMF xy is a demodulation of, if
applicable)</p>
</td></tr>
<tr><td><code id="plot_emd_+3A_vertical">vertical</code></td>
<td>
<p>whether to have the depth/time [dt] axis vertically
(geologist convention) or horizontaly (climatologist convention)</p>
</td></tr>
<tr><td><code id="plot_emd_+3A_adapt.axis">adapt.axis</code></td>
<td>
<p>whether to let the plot adapt the axis to see the
variability of the decompositions. The default os to have a comparable x axis
for each plots</p>
</td></tr>
<tr><td><code id="plot_emd_+3A_adapt.last">adapt.last</code></td>
<td>
<p>whether to adapt the last plot as a residue (if TRUE the
x axis will be identical to the one of the signal, not centered on 0)</p>
</td></tr>
<tr><td><code id="plot_emd_+3A_select">select</code></td>
<td>
<p>the components to plot</p>
</td></tr>
<tr><td><code id="plot_emd_+3A_over">over</code></td>
<td>
<p>which modes/decompositions will be cumulated and added to the
signal plotted at their left or above them (if style = 2)</p>
</td></tr>
<tr><td><code id="plot_emd_+3A_s">s</code>, <code id="plot_emd_+3A_o">o</code>, <code id="plot_emd_+3A_i">i</code>, <code id="plot_emd_+3A_e">e</code></td>
<td>
<p>lists of parameters to feed lines, for the original signal,
the cumulated modes/decompositions overlapping it, the
modes/decompositions themselves, and the enveloppe of the initial signal
used for demodulation if it applies, respectively.</p>
</td></tr>
<tr><td><code id="plot_emd_+3A_la">la</code>, <code id="plot_emd_+3A_ls">ls</code>, <code id="plot_emd_+3A_li">li</code></td>
<td>
<p>lists of parameters to provide the abline function (makes
personalised lines for you to have a better grasp of the data). la will plot
on all panels, ls on the signal ones, and li on the modes ones.</p>
</td></tr>
<tr><td><code id="plot_emd_+3A_box">box</code></td>
<td>
<p>whether to draw boxes around the plots</p>
</td></tr>
<tr><td><code id="plot_emd_+3A_ax">ax</code>, <code id="plot_emd_+3A_ay">ay</code></td>
<td>
<p>lists of parameters to feed minorAxis, the function making the
axes, for the x and y axes</p>
</td></tr>
<tr><td><code id="plot_emd_+3A_parg">parg</code></td>
<td>
<p>list of parameters to feed par</p>
</td></tr>
<tr><td><code id="plot_emd_+3A_title">title</code></td>
<td>
<p>whether to write titles</p>
</td></tr>
<tr><td><code id="plot_emd_+3A_t1">t1</code></td>
<td>
<p>the title for the signal</p>
</td></tr>
<tr><td><code id="plot_emd_+3A_t2">t2</code></td>
<td>
<p>the title for the modes</p>
</td></tr>
<tr><td><code id="plot_emd_+3A_pdf">pdf</code></td>
<td>
<p>whether to plot as a pdf</p>
</td></tr>
<tr><td><code id="plot_emd_+3A_name">name</code>, <code id="plot_emd_+3A_ext">ext</code>, <code id="plot_emd_+3A_dir">dir</code>, <code id="plot_emd_+3A_track">track</code>, <code id="plot_emd_+3A_openfile">openfile</code></td>
<td>
<p>parameters for the pdfDisplay function,
namely the name of the pdf file, its extension (if you want to make a .svg
file you can), the directory of the file, whether to track the changes
(if you use sumatrapdf as a default pdf reader you can set it to F and it
will avoid creating too many pdf files), and whether to directly open the
file</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

n &lt;- 600
t &lt;- seq_len(n)

p1 &lt;- 30
p2 &lt;- 240

xy &lt;- (1 + 0.6 * sin(t*2*pi/p2)) * sin(t*2*pi/p1)  + 2 * sin(t*2*pi/p2) +
  rnorm(n, sd = 0.5) + 0.01 * t

inter_dt &lt;- round(runif(length(xy), min = 0.5, max = 1.5),1)

dt &lt;- cumsum(inter_dt)

dec &lt;- extricate(xy, dt, nimf = 7,
                 repl = 10, comb = 10, factor_noise = 10,
                 speak = TRUE)

plot_emd(dec, select = c(4,6), pdf = FALSE)
## Not run: 
plot_emd(dec, dir = tempdir())
## End(Not run)


</code></pre>

<hr>
<h2 id='plot_hex'>Group and/or log-scale hexagonal binning</h2><span id='topic+plot_hex'></span>

<h3>Description</h3>

<p>Group and/or log-scale hexagonal binning. Provides a legend
indicating the count representations. USES THE GRID GRAPHICAL SYSTEM, BASE
GRAPHICS NOT SUPPORTED. To add lines, polygons or text, use the l, g and t
arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_hex(
  x,
  y,
  id = NA,
  select = NA,
  uniform = TRUE,
  bins = 60,
  xbnds = range(x, na.rm = TRUE),
  ybnds = range(y, na.rm = TRUE),
  xlim = xbnds,
  ylim = ybnds,
  log = "",
  shape = 1,
  mincnt = 1,
  maxcnt = NA,
  colorcut = seq(0, 1, length = 17),
  colramp = function(n) matlab.like(length(colorcut) - 1),
  trans = NULL,
  inv = NULL,
  border = NULL,
  lwd = 0.1,
  cex = 1,
  main = "",
  xlab = "x",
  ylab = "y",
  xaxis = TRUE,
  yaxis = TRUE,
  xaxs = "r",
  yaxs = "r",
  box = TRUE,
  mar = c(0.15, 0.125, 0.15, 0.2),
  legend = TRUE,
  leg_sep = 0.1,
  xpd_hex = 0.75,
  xpd_leg = 1.5,
  l = list(x = NULL, y = NULL, default.units = "native"),
  g = list(x = NULL, y = NULL, default.units = "native"),
  t = list(label = NULL, default.units = "native"),
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_hex_+3A_x">x</code>, <code id="plot_hex_+3A_y">y</code></td>
<td>
<p>vectors giving the coordinates of the bivariate data points to be
binned.</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_id">id</code></td>
<td>
<p>a vector of ids for each x value, to separate different groups of
data</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_select">select</code></td>
<td>
<p>the groups of ids to plot</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_uniform">uniform</code></td>
<td>
<p>whether to keep the creaks defined by the entire matrixes when
selecting only a part of it</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_bins">bins</code></td>
<td>
<p>the number of bins partitioning the range of xbnds.</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_xbnds">xbnds</code>, <code id="plot_hex_+3A_ybnds">ybnds</code></td>
<td>
<p>horizontal and vertical limits of the binning region in
x or y units respectively; must be numeric vector of length 2.</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_xlim">xlim</code>, <code id="plot_hex_+3A_ylim">ylim</code></td>
<td>
<p>the limits of the plot</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_log">log</code></td>
<td>
<p>a character string which contains &quot;x&quot; if the x axis is to be
logarithmic, &quot;y&quot; if the y axis is to be logarithmic and &quot;xy&quot; or &quot;yx&quot; if both
axes are to be logarithmic.</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_shape">shape</code></td>
<td>
<p>the theoretical shape = yheight/xwidth of the plotting. This
adapts the form of the hexagons accordingly.</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_mincnt">mincnt</code>, <code id="plot_hex_+3A_maxcnt">maxcnt</code></td>
<td>
<p>fraction of cell area for the lowest and largest count,
respectively</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_colorcut">colorcut</code></td>
<td>
<p>vector of values covering [0, 1] that determine hexagon color
class boundaries and hexagon legend size boundaries. Alternatively, an
integer (&lt;= maxcnt) specifying the number of equispaced colorcut values in
[0,1].</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_colramp">colramp</code></td>
<td>
<p>function accepting an integer n as an argument and returning n
colors.</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_trans">trans</code></td>
<td>
<p>a transformation function for the counts such as
<code><a href="base.html#topic+log10">log10</a></code></p>
</td></tr>
<tr><td><code id="plot_hex_+3A_inv">inv</code></td>
<td>
<p>the inverse transformation function (if
<code>trans = <a href="base.html#topic+log10">log10</a></code>, <code>inv</code> should for instance be
<code>function(x) 10^x</code>.</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_border">border</code></td>
<td>
<p>the color of the border of the hexagons. By default it will be
the color of the filling</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_lwd">lwd</code></td>
<td>
<p>the width of the border of the hexagons.</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_cex">cex</code></td>
<td>
<p>the magnification of text.</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_main">main</code></td>
<td>
<p>main title.</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_xlab">xlab</code>, <code id="plot_hex_+3A_ylab">ylab</code></td>
<td>
<p>x and y axis labels respectively.</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_xaxis">xaxis</code>, <code id="plot_hex_+3A_yaxis">yaxis</code></td>
<td>
<p>whether to plot the x and y axes respectively.</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_xaxs">xaxs</code>, <code id="plot_hex_+3A_yaxs">yaxs</code></td>
<td>
<p>The style of axis interval calculation to be used for the
axes. By default the style &quot;r&quot; (regular) first extends the data range by 4
percent at each end and then finds an axis with pretty labels that fits
within the extended range. Style &quot;i&quot; (internal) just finds an axis with
pretty labels that fits within the original data range.</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_box">box</code></td>
<td>
<p>whether to plot a box.</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_mar">mar</code></td>
<td>
<p>a numerical vector of the form c(bottom, left, top, right) which
gives the room the give to the margins in Normalised Parent Coordinates
(see <code>grid</code> package for more information)</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_legend">legend</code></td>
<td>
<p>whether to plot the legend.</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_leg_sep">leg_sep</code></td>
<td>
<p>the distance between hexagons and text f the legend in
Normalised Parent Coordinates left on the right margin</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_xpd_hex">xpd_hex</code></td>
<td>
<p>factor to expand the legend hexagons</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_xpd_leg">xpd_leg</code></td>
<td>
<p>factor to expand the height of the legend</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_l">l</code></td>
<td>
<p>a list of arguments to feed to <code>grid::grid.polyline</code>
ATTENTION the grid package has to be loaded</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_g">g</code></td>
<td>
<p>a list of arguments to feed to <code>grid::grid.polygon</code>
ATTENTION the grid package has to be loaded</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_t">t</code></td>
<td>
<p>a list of arguments to feed to <code>grid::grid.text</code>
ATTENTION the grid package has to be loaded</p>
</td></tr>
<tr><td><code id="plot_hex_+3A_plot">plot</code></td>
<td>
<p>whether to plot. If FALSE, returns a grob.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(grid) # To use the gpar function

set.seed(42)

n &lt;- 600
t &lt;- seq_len(n)

p1 &lt;- 30
p2 &lt;- 240

xy &lt;- (1 + 0.6 * sin(t*2*pi/p2)) * sin(t*2*pi/p1)  + 2 * sin(t*2*pi/p2) +
        rnorm(n, sd = 0.5)

inter_dt &lt;- round(runif(length(xy), min = 0.5, max = 1.5),1)

dt &lt;- cumsum(inter_dt)

dec &lt;- extricate(xy, dt, nimf = 7, sifting = 10,
                repl = 10, comb = 10, factor_noise = 10,
                 speak = FALSE)

## Not run: 
plot_emd(dec, dir = tempdir())
## End(Not run)

integrity(xy, dec)
parsimony(dec)

ht  &lt;- inst.pulse(dec, plot = FALSE)

plot_hex(x = 1/ht$f, y = ht$a, bins = 100, ybnds = c(0,2),
         log = "x", trans = log10, inv = function(x) 10^x,
         main = "Spectral Population", xlab = "Period", ylab = "Amplitude")

plot_hex(x = 1/ht$f, y = ht$a, bins = 100, ybnds = c(0,2),
         log = "x", trans = log10, inv = function(x) 10^x,
         main = "Spectral Population", xlab = "Period", ylab = "Amplitude",
         id = ht$mode, select = c(4,6,7),
         l = list(x = c(30, 30, 240, 240), y = unit(c(0,1,0,1), "npc"),
                 id = c(1,1,2,2), gp = gpar(col = c("red", "blue"), lwd = 2)),
        g = list(x = c(18, 50, 50, 18, 18, 50, 50, 18),
                 y = c(0, 0, 1.9, 1.9, 2.05, 2.05, 1.95, 1.95),
                 id = c(1,1,1,1,2,2,2,2),
                 gp = gpar(col = c("red", NA), fill = c(NA, "white"), lwd = 2)),
        t = list(label = "Mode 4", x = 30, y = 2, gp = gpar(col = "red")))

</code></pre>

<hr>
<h2 id='plot_hist'>Group and/or log-scale histogram</h2><span id='topic+plot_hist'></span>

<h3>Description</h3>

<p>Specialised histogram: allows to work in log-scale (for x) and
to distinguish different groups of data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_hist(
  x,
  breaks = 100,
  id = NA,
  select = NA,
  pile = TRUE,
  line = FALSE,
  mids = FALSE,
  xlim = NA,
  ylim = NA,
  xlog = FALSE,
  axes = TRUE,
  xa = list(),
  ya = list(),
  main = "",
  xlab = "X",
  ylab = "Counts",
  col = NA,
  border = NA,
  text = FALSE,
  labels = NA,
  t = list(adj = c(0.5, -2), font = 2),
  add = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_hist_+3A_x">x</code></td>
<td>
<p>vector or matrix</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_breaks">breaks</code></td>
<td>
<p>one of:
</p>

<ul>
<li><p>a vector giving the breakpoints between histogram cells,
</p>
</li>
<li><p>a function to compute the vector of breakpoints,
</p>
</li>
<li><p>a single number giving the number of cells for the histogram,
</p>
</li>
<li><p>a character string naming an algorithm to compute the number of cells
(see ‘Details’ in <code><a href="graphics.html#topic+hist">hist</a></code>),
</p>
</li>
<li><p>a function to compute the number of cells.
</p>
</li></ul>

<p>In the last three cases the number is a suggestion only; as the breakpoints
will be set to pretty values, the number is limited to 1e6 (with a warning if
it was larger). If breaks is a function, the x vector is supplied to it as
the only argument (and the number of breaks is only limited by the amount of
available memory).</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_id">id</code></td>
<td>
<p>a vector of ids for each x value, to separate different groups of
data</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_select">select</code></td>
<td>
<p>a vector of id values idenifying the groups of data to plot and
their order</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_pile">pile</code></td>
<td>
<p>whether to cumulate the different one on the other</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_line">line</code></td>
<td>
<p>whether to plot as lines or rectangles</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_mids">mids</code></td>
<td>
<p>if lines is TRUE, whether the nodes of the lines are the middle
positions or the upper corner of the rectangles.</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_xlim">xlim</code>, <code id="plot_hist_+3A_ylim">ylim</code></td>
<td>
<p>the boundaries for the plots. If ylim = NA the upper ylim
will be increased by 10% to allow for text (see 'text' parameter)</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_xlog">xlog</code></td>
<td>
<p>whether to set the x axis in log scale</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_axes">axes</code></td>
<td>
<p>whether to plot the axes</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_xa">xa</code>, <code id="plot_hist_+3A_ya">ya</code></td>
<td>
<p>list of arguments to feed minorAxis for the x and y axes
respectively</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_main">main</code>, <code id="plot_hist_+3A_xlab">xlab</code>, <code id="plot_hist_+3A_ylab">ylab</code></td>
<td>
<p>the main title and the labels of the x and y axes</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_col">col</code></td>
<td>
<p>a function or a character vector defining the colors of the
different modes</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_border">border</code></td>
<td>
<p>the colour of the borders, by default identical to col</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_text">text</code></td>
<td>
<p>if there are different groups, whether to add a number above
each of them to distinguish them</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_labels">labels</code></td>
<td>
<p>the labels to put on top of each group</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_t">t</code></td>
<td>
<p>a list of parameters to feed text()</p>
</td></tr>
<tr><td><code id="plot_hist_+3A_add">add</code></td>
<td>
<p>whether to add the plot to a preexisting plot</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

n &lt;- 600
t &lt;- seq_len(n)

p1 &lt;- 30
p2 &lt;- 240

xy &lt;- (1 + 0.6 * sin(t*2*pi/p2)) * sin(t*2*pi/p1)  + 2 * sin(t*2*pi/p2) +
  rnorm(n, sd = 0.5) + t * 0.01

inter_dt &lt;- round(runif(length(xy), min = 0.5, max = 1.5),1)

dt &lt;- cumsum(inter_dt)

dec &lt;- extricate(xy, dt, nimf = 7, sifting = 10,
                 repl = 10, comb = 10, factor_noise = 10,
                 speak = FALSE)
## Not run: 
plot_emd(dec, dir = tempdir())
## End(Not run)

integrity(xy, dec)
parsimony(dec)

ht  &lt;- inst.pulse(dec, plot = FALSE)

opar &lt;- par('mfrow')

par(mfrow = c(2,1))

plot_hist(x = 1/ht$f, breaks = 500,
          xlog = TRUE, xlab = "Period")

plot_hist(x = 1/ht$f, breaks = 500, id = ht$mode,
          xlog = TRUE, text = TRUE, add = TRUE, line = TRUE, pile = FALSE)

abline(v = c(p1, p2), col = "red", lwd = 2, lty = 5)

plot_hist(x = 1/ht$f, breaks = 500, id = ht$mode,
          xlog = TRUE, text = TRUE, xlab = "Period")

abline(v = c(p1, p2), col = "red", lwd = 2, lty = 5)

par(mfrow = opar)

</code></pre>

<hr>
<h2 id='plot_imf'>Plot IMFs characteristics</h2><span id='topic+plot_imf'></span>

<h3>Description</h3>

<p>General plot for the envelope, instantaneous frequency (period)
and identity tuning of an intrinsic mode function (IMF)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_imf(
  pulse,
  dtlim = NULL,
  xylim = NULL,
  flim = NULL,
  fclim = NULL,
  dtline = NULL,
  fline = NULL,
  fcline = NULL,
  vertical = FALSE,
  n = 10,
  at.maj = NULL,
  ls = list(type = "o", pch = 19),
  le1 = list(lwd = 2),
  le2 = list(lty = 2),
  lid = list(type = "p", pch = 19),
  lcos = list(),
  ldt = list(lty = 5, lwd = 2),
  lf = list(lty = 5),
  lfc = list(lty = 5),
  box = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_imf_+3A_pulse">pulse</code></td>
<td>
<p>a pulse object</p>
</td></tr>
<tr><td><code id="plot_imf_+3A_dtlim">dtlim</code>, <code id="plot_imf_+3A_xylim">xylim</code>, <code id="plot_imf_+3A_flim">flim</code>, <code id="plot_imf_+3A_fclim">fclim</code></td>
<td>
<p>the boundaries for the plots, respectively for
the depth/time, amplitude, frequency and freqeuncy carrier</p>
</td></tr>
<tr><td><code id="plot_imf_+3A_dtline">dtline</code>, <code id="plot_imf_+3A_fline">fline</code>, <code id="plot_imf_+3A_fcline">fcline</code></td>
<td>
<p>coordinates to add vertical/horizontal lines</p>
</td></tr>
<tr><td><code id="plot_imf_+3A_vertical">vertical</code></td>
<td>
<p>whether to have the depth/time [dt] axis vertically</p>
</td></tr>
<tr><td><code id="plot_imf_+3A_n">n</code></td>
<td>
<p>the the number of intervals defined by minor ticks
(geologist convention) or horizontaly (climatologist convention)</p>
</td></tr>
<tr><td><code id="plot_imf_+3A_at.maj">at.maj</code></td>
<td>
<p>the positions at which major tick-marks are to be drawn.</p>
</td></tr>
<tr><td><code id="plot_imf_+3A_ls">ls</code>, <code id="plot_imf_+3A_le1">le1</code>, <code id="plot_imf_+3A_le2">le2</code>, <code id="plot_imf_+3A_lid">lid</code>, <code id="plot_imf_+3A_lcos">lcos</code></td>
<td>
<p>lists of parameters to feed lines, for the
original signal, the upper and lower envelope, the identity tuning, and the
cosine line in the identity tuning</p>
</td></tr>
<tr><td><code id="plot_imf_+3A_ldt">ldt</code>, <code id="plot_imf_+3A_lf">lf</code>, <code id="plot_imf_+3A_lfc">lfc</code></td>
<td>
<p>lists of parameters to provide the abline function (makes
personalised lines for you to have a better grasp of the data).</p>
</td></tr>
<tr><td><code id="plot_imf_+3A_box">box</code></td>
<td>
<p>whether to draw boxes around the plots</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the line in the identity tuning plot is a genuine cosine,
independent from the signal. This is evident when riding waves generate
dephasing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 600

t &lt;- seq_len(n)

p1 &lt;- 30
p2 &lt;- 40 * 21

am &lt;- sin(t*2*pi/p2 + 50) + 0.03

xy &lt;- sin(t*2*pi/p1 + 50) * 3 * am

int &lt;- c(rep(1, 99 + 100), seq(1,3,2/100), seq(3,1,-2/100), rep(1,100 + 99))

dt &lt;- cumsum(int)

samp &lt;- approx(dt, xy, xout = seq(1,802, by = 2))

xy &lt;- samp$y
dt &lt;- samp$x

e &lt;- normalise(m = xy, dt = dt)$a

cond &lt;- dt &lt; 75

xy &lt;- xy[!cond]
dt &lt;- (dt[!cond] - 75) / 1.2
e  &lt;- e[!cond]

dq   &lt;- dq.algorithm(xy/e, dt)

pulse &lt;- as.pulse(dt = dt, m = xy, f = dq$f, a = e, idt = dq$idt,
                  repl = 1)

plot_imf(pulse, fline = 25, dtline = c(222, 489))

</code></pre>

<hr>
<h2 id='plot_pulse'>Visualise the instantaneous frequencies and amplitudes of a
decomposition</h2><span id='topic+plot_pulse'></span>

<h3>Description</h3>

<p>Visualise the instantaneous frequencies and amplitudes of a
decomposition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_pulse(
  pulse,
  style = "b",
  breaks = 500,
  bins = 100,
  cut = 18,
  lines = NULL,
  keep = NULL,
  lose = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_pulse_+3A_pulse">pulse</code></td>
<td>
<p>a pulse object (created by <code><a href="#topic+inst.pulse">inst.pulse</a></code> or
<code><a href="#topic+as.pulse">as.pulse</a></code>)</p>
</td></tr>
<tr><td><code id="plot_pulse_+3A_style">style</code></td>
<td>
<p>whether to plot the distribution of frequency ('d'), the
spectral population ('p') or both ('b', is the default)</p>
</td></tr>
<tr><td><code id="plot_pulse_+3A_breaks">breaks</code>, <code id="plot_pulse_+3A_bins">bins</code>, <code id="plot_pulse_+3A_cut">cut</code></td>
<td>
<p>parameter for the plots: <code>breaks</code> is fed to
<code><a href="#topic+plot_hist">plot_hist</a></code>, <code>bins</code> is fed to <code><a href="#topic+plot_hex">plot_hex</a></code>, and
<code>cut</code> defines the number of color cuts for <code><a href="#topic+plot_hex">plot_hex</a></code>.
For better control use <code><a href="#topic+plot_hist">plot_hist</a></code> and <code><a href="#topic+plot_hex">plot_hex</a></code>
directly.</p>
</td></tr>
<tr><td><code id="plot_pulse_+3A_lines">lines</code></td>
<td>
<p>the period of lines to be added to the plots for better
visualisation</p>
</td></tr>
<tr><td><code id="plot_pulse_+3A_keep">keep</code>, <code id="plot_pulse_+3A_lose">lose</code></td>
<td>
<p>which modes to plot or to not (keep overrides lose)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

n &lt;- 600
t &lt;- seq_len(n)

p1 &lt;- 30
p2 &lt;- 240

xy &lt;- (1 + 0.6 * sin(t*2*pi/p2)) * sin(t*2*pi/p1)  + 2 * sin(t*2*pi/p2) +
  rnorm(n, sd = 0.5) + t * 0.01

inter_dt &lt;- round(runif(length(xy), min = 0.5, max = 1.5),1)

dt &lt;- cumsum(inter_dt)
dec &lt;- extricate(xy, dt, nimf = 7, sifting = 10, repl = 10, comb = 10,
                 factor_noise = 10, speak = TRUE)

## Not run: 
plot_emd(dec, dir = tempdir())
## End(Not run)


integrity(xy, dec)
parsimony(dec)

ht   &lt;- inst.pulse(dec, plot = FALSE)

plot_pulse(ht, lines = c(30, 240))

</code></pre>

<hr>
<h2 id='plot_ratio'>Visualise the instantaneous frequencies ratios of a
decomposition</h2><span id='topic+plot_ratio'></span>

<h3>Description</h3>

<p>Visualise the instantaneous frequencies ratios of a
decomposition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ratio(
  ratio,
  sqrt.rpwr = TRUE,
  style = "b",
  select = NA,
  bins = 100,
  cut = 18,
  lines = NULL,
  plot = TRUE,
  width = 10,
  height = 10,
  name = "Ratio",
  ext = ".pdf",
  dir = tempdir(),
  track = TRUE,
  openfile = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_ratio_+3A_ratio">ratio</code></td>
<td>
<p>a ratio object (created by <code><a href="#topic+inst.ratio">inst.ratio</a></code></p>
</td></tr>
<tr><td><code id="plot_ratio_+3A_sqrt.rpwr">sqrt.rpwr</code></td>
<td>
<p>whether to use the square root of ratio power (i.e. the
square root of the multiplication of the instantaneous amplitudes of the
modes two by two) rather than the ratio power itself.</p>
</td></tr>
<tr><td><code id="plot_ratio_+3A_style">style</code></td>
<td>
<p>whether to plot a single plot in the graphics device ('s'), the
to plot an ensemble of all the ratios combinations in a pdf ('e'), or both
('b', is the default)</p>
</td></tr>
<tr><td><code id="plot_ratio_+3A_select">select</code></td>
<td>
<p>the groups of ratios combinations to plot in the single plot
(in the &quot;1/2&quot; form)</p>
</td></tr>
<tr><td><code id="plot_ratio_+3A_bins">bins</code>, <code id="plot_ratio_+3A_cut">cut</code></td>
<td>
<p>parameter for the plots: <code>bins</code> is fed to
<code><a href="#topic+plot_hex">plot_hex</a></code>, and <code>cut</code> defines the number of color cuts for
<code><a href="#topic+plot_hex">plot_hex</a></code>. For better control use <code><a href="#topic+plot_hex">plot_hex</a></code>
directly.</p>
</td></tr>
<tr><td><code id="plot_ratio_+3A_lines">lines</code></td>
<td>
<p>the ratio of lines to be added to the plots for better
visualisation</p>
</td></tr>
<tr><td><code id="plot_ratio_+3A_plot">plot</code></td>
<td>
<p>whether to plot. Otherwise output a grob of the single plot.</p>
</td></tr>
<tr><td><code id="plot_ratio_+3A_width">width</code>, <code id="plot_ratio_+3A_height">height</code></td>
<td>
<p>the width  and height in inches of each separate plot
in the ensemble of all the ratios combinations</p>
</td></tr>
<tr><td><code id="plot_ratio_+3A_name">name</code>, <code id="plot_ratio_+3A_ext">ext</code>, <code id="plot_ratio_+3A_dir">dir</code>, <code id="plot_ratio_+3A_track">track</code>, <code id="plot_ratio_+3A_openfile">openfile</code></td>
<td>
<p>parameters for the pdfDisplay function,
namely the name of the pdf file, its extension (if you want to make a .svg
file you can), the directory of the file, whether to track the changes
(if you use sumatrapdf as a default pdf reader you can set it to F and it
will avoid creating too many pdf files), and whether to directly open the
file</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

n &lt;- 600
t &lt;- seq_len(n)

p1 &lt;- 30
p2 &lt;- 240

xy &lt;- (1 + 0.6 * sin(t*2*pi/p2)) * sin(t*2*pi/p1)  + 2 * sin(t*2*pi/p2) +
  rnorm(n, sd = 0.5) + t * 0.01

inter_dt &lt;- round(runif(length(xy), min = 0.5, max = 1.5),1)

dt &lt;- cumsum(inter_dt)
dec &lt;- extricate(xy, dt, nimf = 7, sifting = 10,
                 repl = 10, comb = 10,
                 factor_noise = 10, speak = TRUE)
## Not run: 
plot_emd(dec, dir = tempdir())
## End(Not run)

integrity(xy, dec)
parsimony(dec)

ht    &lt;- inst.pulse(dec, plot = FALSE)
ratio &lt;- inst.ratio(ht, plot = FALSE)

plot_ratio(ratio, lines = c(8), style = "s")
plot_ratio(ratio, lines = c(8), style = "s", select = c("4/6"))
## Not run: 
plot_ratio(ratio, lines = c(8), style = "e", dir = tempdir())
## End(Not run)

</code></pre>

<hr>
<h2 id='PrecisionTester'>Test numerically determined instantaneous frequency against exact
instantaneous frequency</h2><span id='topic+PrecisionTester'></span>

<h3>Description</h3>

<p>This function compares the performance of
<code><a href="#topic+InstantaneousFrequency">InstantaneousFrequency</a></code> against signals of known instantaneous
frequency. The known signal is of the form
</p>
<p style="text-align: center;"><code class="reqn"> x(t) = a\sin(\omega_{1} + \varphi_{1}) + b\sin(\omega_{2} +
\varphi_{2}) + c</code>
</p>

<p>One can create quite complicated signals by choosing the various amplitude,
frequency, and phase constants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PrecisionTester(
  tt = seq(0, 10, by = 0.01),
  method = "arctan",
  lag = 1,
  a = 1,
  b = 1,
  c = 1,
  omega.1 = 2 * pi,
  omega.2 = 4 * pi,
  phi.1 = 0,
  phi.2 = pi/6,
  plot.signal = TRUE,
  plot.instfreq = TRUE,
  plot.error = TRUE,
  new.device = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PrecisionTester_+3A_tt">tt</code></td>
<td>
<p>Sample times.</p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_method">method</code></td>
<td>
<p>How the numeric instantaneous frequency is calculated, see
<code><a href="#topic+InstantaneousFrequency">InstantaneousFrequency</a></code></p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_lag">lag</code></td>
<td>
<p>Differentiation lag, see the <code>diff</code> function in the
<code>base</code> package</p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_a">a</code></td>
<td>
<p>Amplitude coefficient for the first sinusoid.</p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_b">b</code></td>
<td>
<p>Amplitude coefficient for the second sinusoid.</p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_c">c</code></td>
<td>
<p>DC shift</p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_omega.1">omega.1</code></td>
<td>
<p>Frequency of the first sinusoid.</p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_omega.2">omega.2</code></td>
<td>
<p>Frequency of the second sinusoid.</p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_phi.1">phi.1</code></td>
<td>
<p>Phase shift of the first sinusoid.</p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_phi.2">phi.2</code></td>
<td>
<p>Phase shift of the second sinusoid.</p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_plot.signal">plot.signal</code></td>
<td>
<p>Whether to show the time series.</p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_plot.instfreq">plot.instfreq</code></td>
<td>
<p>Whether to show the instantaneous frequencies, comparing
the numerical and analytical result.</p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_plot.error">plot.error</code></td>
<td>
<p>Whether to show the difference between the numerical and
analytical result.</p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_new.device">new.device</code></td>
<td>
<p>Whether to open each plot as a new plot window (defaults to
TRUE). However, Sweave doesn't like <code>dev.new()</code>. If you want to use
<code>PrecisionTester</code> in Sweave, be sure that new.device = FALSE</p>
</td></tr>
<tr><td><code id="PrecisionTester_+3A_...">...</code></td>
<td>
<p>Plotting parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>instfreq$sig</code></td>
<td>
<p>The time series</p>
</td></tr>
<tr><td><code>instfreq$analytic</code></td>
<td>
<p>The exact instantaneous frequency</p>
</td></tr>
<tr><td><code>instfreq$numeric</code></td>
<td>
<p>The numerically-derived instantaneous frequency from
<code><a href="#topic+InstantaneousFrequency">InstantaneousFrequency</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel C. Bowman (in the hht package)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+InstantaneousFrequency">InstantaneousFrequency</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simple signal

tt &lt;- seq(0, 10, by = 0.01)
a &lt;- 1
b &lt;- 0
c &lt;- 0
omega.1 &lt;- 30 * pi
omega.2 &lt;- 0
phi.1 &lt;- 0
phi.2 &lt;- 0

PrecisionTester(tt, method = "arctan", lag = 1, a, b, c,
                omega.1, omega.2, phi.1, phi.2, new.device = FALSE)

#That was nice - what happens if we use the "chain" method...?

PrecisionTester(tt, method = "chain", lag = 1, a, b, c,
                omega.1, omega.2, phi.1, phi.2, new.device = FALSE)

#Big problems!  Let's increase the sample rate

tt &lt;- seq(0, 10, by = 0.0005)
PrecisionTester(tt, method = "chain", lag = 1, a, b, c,
                omega.1, omega.2, phi.1, phi.2, new.device = FALSE)

#That's better

#Frequency modulations caused by signal that is not symmetric about 0

tt &lt;- seq(0, 10, by = 0.01)
a &lt;- 1
b &lt;- 0
c &lt;- 0.25
omega.1 &lt;- 2 * pi
omega.2 &lt;- 0
phi.1 &lt;- 0
phi.2 &lt;- 0

PrecisionTester(tt, method = "arctan", lag = 1, a, b, c,
                omega.1, omega.2, phi.1, phi.2, new.device = FALSE)

#Non-uniform sample rate
set.seed(628)
tt &lt;- sort(runif(500, 0, 10))
a &lt;- 1
b &lt;- 0
c &lt;- 0
omega.1 &lt;- 2 * pi
omega.2 &lt;- 0
phi.1 &lt;- 0
phi.2 &lt;- 0

PrecisionTester(tt, method = "arctan", lag = 1, a, b, c,
                omega.1, omega.2, phi.1, phi.2, new.device = FALSE)
</code></pre>

<hr>
<h2 id='ratios'>Computes ratios of numerical values</h2><span id='topic+ratios'></span>

<h3>Description</h3>

<p>Computes ratios of numerical values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ratios(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ratios_+3A_x">x</code></td>
<td>
<p>values to compute the ratio from</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe of $ratio, $x1 and $x2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ratios(c(20,40,100,400))

</code></pre>

<hr>
<h2 id='repl.out'>Remove / Bind replicates in emd objects</h2><span id='topic+repl.out'></span><span id='topic+repl.bind'></span>

<h3>Description</h3>

<p>Remove / Bind replicates in emd objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repl.out(emd, keep = NULL, lose = NULL, reorder = FALSE)

repl.bind(emd, comb)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repl.out_+3A_emd">emd</code></td>
<td>
<p>emd-type object</p>
</td></tr>
<tr><td><code id="repl.out_+3A_keep">keep</code>, <code id="repl.out_+3A_lose">lose</code></td>
<td>
<p>the modes to keep or lose</p>
</td></tr>
<tr><td><code id="repl.out_+3A_reorder">reorder</code></td>
<td>
<p>whether to reinitialise the index of replicates when
suppressing one</p>
</td></tr>
<tr><td><code id="repl.out_+3A_comb">comb</code></td>
<td>
<p>the number of replicates that have to be bound together</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

n &lt;- 600
t &lt;- seq_len(n)

p1 &lt;- 30
p2 &lt;- 240

xy &lt;- (1 + 0.6 * sin(t*2*pi/p2)) * sin(t*2*pi/p1)  + 2 * sin(t*2*pi/p2) +
  rnorm(n, sd = 0.5) + t * 0.01

inter_dt &lt;- round(runif(length(xy), min = 0.5, max = 1.5),1)

dt &lt;- cumsum(inter_dt)

dec &lt;- extricate(xy, dt, nimf = 7, sifting = 10,
                 repl = 20, comb = 2, factor_noise = 10,
                 speak = TRUE, output_sifting = TRUE)

reduced  &lt;- repl.out(dec, keep = c(3,4))

parsimony(reduced)

plot_emd(reduced, pdf = FALSE, select = c(4,6))

combined &lt;- repl.bind(dec, 10)

parsimony(combined)

plot_emd(combined, pdf = FALSE, select = c(4,6))

</code></pre>

<hr>
<h2 id='respace'>Interpolate with even spacing</h2><span id='topic+respace'></span>

<h3>Description</h3>

<p>Interpolate with even spacing. Can determine on its own the
most conservative sampling interval (using the Greatest Common Rational
Divisor)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>respace(
  dt,
  xy = NULL,
  delta = NULL,
  tolerance = 8,
  relative = TRUE,
  n.warn = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="respace_+3A_dt">dt</code></td>
<td>
<p>depth/time (same length than length/rows of xy)</p>
</td></tr>
<tr><td><code id="respace_+3A_xy">xy</code></td>
<td>
<p>signal (vector or matrix)</p>
</td></tr>
<tr><td><code id="respace_+3A_delta">delta</code></td>
<td>
<p>the new sampling interval. If NULL, uses the Greatest Common
Rational Divisor</p>
</td></tr>
<tr><td><code id="respace_+3A_tolerance">tolerance</code>, <code id="respace_+3A_relative">relative</code></td>
<td>
<p>parameters for the <code>divisor</code> function
(<code>StratigrapheR</code> package), to compute the Greatest Common
Rational Divisor</p>
</td></tr>
<tr><td><code id="respace_+3A_n.warn">n.warn</code></td>
<td>
<p>the amount of interpolated points in between the largest
interval above which a warning is provided. This warning can be useful to
avoid needlessly long outputs, which might make any subsequent computation
take too much time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of interpolated xy and dt values ($xy and $dt), plus a vector
of logicals indicating whether each point was part of the initial input or
was added by interpolation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

n &lt;- 50
t &lt;- seq_len(n)

xy &lt;- (1 + 0.6 * sin(t*0.025)) * sin(t*0.2)  + 2 * sin(t*0.025) +
        rnorm(n, sd = 0.5)

inter_dt &lt;- round(runif(length(xy), min = 0.5, max = 1.5), 1)

dt &lt;- cumsum(inter_dt)

res &lt;- respace(xy = xy, dt = dt)

opar &lt;- par("mfrow")

par(mfrow = c(1,1))

plot(res$xy, res$dt, type = "l")
points(res$xy[res$initial], res$dt[res$initial], pch = 19, col = "green")
points(res$xy[!res$initial], res$dt[!res$initial],
       pch = 19, col = "red", cex = 0.5)

par(mfrow = opar)

</code></pre>

<hr>
<h2 id='simp.emd'>Simplifies the components of an EMD</h2><span id='topic+simp.emd'></span>

<h3>Description</h3>

<p>Simplifies the component of an EMD to only extremas and
zero-crossings, and outputs problematic extrema: multiple extrema (extrema
not separated by zero-crossings) and crossing extrema (extrema at zero).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simp.emd(emd = NULL, m = NULL, dt = NULL, repl = 1, use.names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simp.emd_+3A_emd">emd</code></td>
<td>
<p>emd-type object</p>
</td></tr>
<tr><td><code id="simp.emd_+3A_m">m</code></td>
<td>
<p>a matrix of the amplitude values (xy) of the components, each
column being a component. Each column should have the same number of non NA
values. Vectors, for 1 component, are accepted. Is overridden by emd.</p>
</td></tr>
<tr><td><code id="simp.emd_+3A_dt">dt</code></td>
<td>
<p>the depth or time value. Is overridden by emd.</p>
</td></tr>
<tr><td><code id="simp.emd_+3A_repl">repl</code></td>
<td>
<p>the amount of replicates in m. Is overridden by emd.</p>
</td></tr>
<tr><td><code id="simp.emd_+3A_use.names">use.names</code></td>
<td>
<p>whether to use the column names to identify problematic
extrema</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the depth or time values ($dt) of the simplified IMF
(Intrinsic Mode Function), of their amplitude ($xy), and of the position
and component of problematic multiple extrema ($multiple_extrema) and
crossing extrema ($crossing_extrema)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xytest &lt;- c(0.5, 1,-1,-0.85,-0.5,-1,-0.5,-1,1,0.5,0,0,
            1,-1,0,1,2,-2,1,2,1,3,0,-1,-1,3,0)

repeatafterme &lt;- 2

m  &lt;- matrix(rep(xytest,repeatafterme), ncol = repeatafterme)
dt &lt;- 1:length(xytest)

res &lt;- simp.emd(m = m, dt = dt, repl = repeatafterme)

opar &lt;- par("mfrow")

par(mfrow = c(1,1))

plot(dt, xytest, type = "o", pch = 19)
abline(h = 0, col = "grey")

me &lt;- res$multiple_extrema$dt[res$multiple_extrema$repl == 1]
ce &lt;- res$crossing_extrema$dt[res$multiple_extrema$repl == 1]

abline(v = me, col = "orange")
abline(v = ce, col = "darkred")

points(res$dt[,1], res$xy[,1], col = "red", pch = 19)

par(mfrow = opar)

</code></pre>

<hr>
<h2 id='simple.ssa'>Simple SSA decomposition</h2><span id='topic+simple.ssa'></span>

<h3>Description</h3>

<p>Simple wrapper for Singular Spectrum Analysis, using the
functions of the Rssa package (which is not installed by default by the
DecomposeR package, you should install it independently). This function
allows unevenly sampled data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple.ssa(xy, dt, n = 10, remove = "trend", groups = list(), plot = T, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simple.ssa_+3A_xy">xy</code></td>
<td>
<p>signal to be decomposed</p>
</td></tr>
<tr><td><code id="simple.ssa_+3A_dt">dt</code></td>
<td>
<p>depth/time</p>
</td></tr>
<tr><td><code id="simple.ssa_+3A_n">n</code></td>
<td>
<p>maximum amount of components</p>
</td></tr>
<tr><td><code id="simple.ssa_+3A_remove">remove</code></td>
<td>
<p>whether to remove a linear trend (&quot;trend&quot;, is the default),
a mean value (&quot;mean&quot;), or to decompose as is (any other value)</p>
</td></tr>
<tr><td><code id="simple.ssa_+3A_groups">groups</code></td>
<td>
<p>which components to regroup (list of the indices of elementary
components to be regrouped, the entries of the list can be named, see
the reconstruct() function in the Rssa package for more information)</p>
</td></tr>
<tr><td><code id="simple.ssa_+3A_plot">plot</code></td>
<td>
<p>whether to show a visualisation of the importance of each
component</p>
</td></tr>
<tr><td><code id="simple.ssa_+3A_...">...</code></td>
<td>
<p>any arguments to by given to the ssa() function (see Rssa package
for more information)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list made of $xy (original signal), $dt (depth/time), $m (a matrix
of the decomposition), $repl (the replicate id of each point) and $mode (the
mode id of each point).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

n &lt;- 600
t &lt;- seq_len(n)

p1 &lt;- 30
p2 &lt;- 240

xy &lt;- (1 + 0.6 * sin(t*2*pi/p2)) * sin(t*2*pi/p1)  + 2 * sin(t*2*pi/p2) +
  rnorm(n, sd = 0.5) + 0.01 * t

inter_dt &lt;- round(runif(length(xy), min = 0.5, max = 1.5),1)

dt &lt;- cumsum(inter_dt)

res &lt;- simple.ssa(xy, dt, groups = list(c(1,2), c= 3:10))

parsimony(res)

integrity(xy, res)

## Not run: 
plot_emd(res, style = 1)
## End(Not run)

</code></pre>

<hr>
<h2 id='symmetry'>Symmetry of components</h2><span id='topic+symmetry'></span>

<h3>Description</h3>

<p>The function returns the highest factor of amplitude either in
negative or positive values. This quantifies the symmetry of components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symmetry(xy, names = "num")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="symmetry_+3A_xy">xy</code></td>
<td>
<p>signal (vector or matrix)</p>
</td></tr>
<tr><td><code id="symmetry_+3A_names">names</code></td>
<td>
<p>the names to use for the resulting vector. If NULL no names are
provided, if NA its the names of the columns of the xy matrix, if &quot;num&quot; it
the column index of the matrix xy</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)

n &lt;- 600
t &lt;- seq_len(n)

p1 &lt;- 30
p2 &lt;- 240

xy &lt;- (1 + 0.6 * sin(t*2*pi/p2)) * sin(t*2*pi/p1)  + 2 * sin(t*2*pi/p2) +
  rnorm(n, sd = 0.5) + t * 0.01

inter_dt &lt;- round(runif(length(xy), min = 0.5, max = 1.5),1)

dt &lt;- cumsum(inter_dt)

dec &lt;- extricate(xy, dt, nimf = 7, sifting = 10,
                 repl = 1, comb = 40, factor_noise = 10,
                 speak = TRUE, output_sifting = TRUE)

symmetry(dec$m)

plot_emd(dec, select = c(6,8,9), pdf = FALSE, adapt.axis = TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
