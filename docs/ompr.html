<!DOCTYPE html><html><head><title>Help for package ompr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ompr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ompr'><p>A package to Model (Mixed) Integer Programs</p></a></li>
<li><a href='#add_constraint'><p>Add a constraint</p></a></li>
<li><a href='#add_variable'><p>Add a variable to the model</p></a></li>
<li><a href='#additional_solver_output'><p>Retrieve additional solver specific output</p></a></li>
<li><a href='#as_colwise'><p>As_colwise</p></a></li>
<li><a href='#colwise'><p>Format variables colwise</p></a></li>
<li><a href='#extract_constraints'><p>Extract the constraint matrix, the right hand side and the sense from a model</p></a></li>
<li><a href='#get_column_duals'><p>Gets the column duals of a solution</p></a></li>
<li><a href='#get_row_duals'><p>Gets the row duals of a solution</p></a></li>
<li><a href='#get_solution'><p>Get variable values from a solution</p></a></li>
<li><a href='#LinearVariableCollection-class'><p>An S4 class that represents a collection of variables</p></a></li>
<li><a href='#MILPModel'><p>Experimental: Create a new MILP Model</p></a></li>
<li><a href='#MIPModel'><p>Create a new MIP Model</p></a></li>
<li><a href='#nconstraints'><p>Number of variables (rows) of the model</p></a></li>
<li><a href='#new_solution'><p>Create a new solution</p></a></li>
<li><a href='#nvars'><p>Number of variables of a model</p></a></li>
<li><a href='#objective_function'><p>Extract the objective function from a model</p></a></li>
<li><a href='#objective_value'><p>Extract the numerical objective value from a solution</p></a></li>
<li><a href='#set_bounds'><p>Set the bounds of a variable</p></a></li>
<li><a href='#set_objective'><p>Set the model objective</p></a></li>
<li><a href='#solve_model'><p>Solve a model</p></a></li>
<li><a href='#solver_status'><p>Get the solver status from a solution</p></a></li>
<li><a href='#sum_over'><p>Sum over indexes</p></a></li>
<li><a href='#variable_bounds'><p>Variable lower and upper bounds of a model</p></a></li>
<li><a href='#variable_keys'><p>Get all unique names of the model variables</p></a></li>
<li><a href='#variable_types'><p>Variable types of a model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Model and Solve Mixed Integer Linear Programs</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Model mixed integer linear programs in an algebraic way directly in R.
             The model is solver-independent and thus offers the possibility
             to solve a model with different solvers. It currently only supports
             linear constraints and objective functions. See the 'ompr'
             website <a href="https://dirkschumacher.github.io/ompr/">https://dirkschumacher.github.io/ompr/</a> for more information,
             documentation and examples.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dirkschumacher/ompr">https://github.com/dirkschumacher/ompr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dirkschumacher/ompr/issues">https://github.com/dirkschumacher/ompr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>lazyeval, rlang (&ge; 0.2.0), listcomp (&ge; 0.4.0), methods,
data.table, Matrix, fastmap</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, magrittr, testthat</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>Yes</td>
</tr>
<tr>
<td>Collate:</td>
<td>'abstract-model-impl.R' 'helper.R'
'linear-optimization-model-impl.R'
'linear-optimization-model-linear-constraints.R'
'linear-optimization-model-linear-functions.R' 'model-api.R'
'milp-impl.R' 'milp-linearopt-variables.R' 'ompr-package.R'
'solution-api.R' 'solution-impl.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-09 06:12:03 UTC; dsp</td>
</tr>
<tr>
<td>Author:</td>
<td>Dirk Schumacher [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dirk Schumacher &lt;mail@dirk-schumacher.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-09 08:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ompr'>A package to Model (Mixed) Integer Programs</h2><span id='topic+ompr'></span><span id='topic+ompr-package'></span>

<h3>Description</h3>

<p>A package to model (mixed) integer programs.
It provides an algebraic way to model mixed integer linear
optimization problems directly in R.
The model is solver-independent and thus offers the possibility
to solve a model with different solvers. See the ompr
website &lt;https://dirkschumacher.github.io/ompr/&gt; for more information, documentation and examples.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Dirk Schumacher <a href="mailto:mail@dirk-schumacher.net">mail@dirk-schumacher.net</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/dirkschumacher/ompr">https://github.com/dirkschumacher/ompr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/dirkschumacher/ompr/issues">https://github.com/dirkschumacher/ompr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='add_constraint'>Add a constraint</h2><span id='topic+add_constraint'></span><span id='topic+add_constraint_'></span>

<h3>Description</h3>

<p>Add one or more constraints to the model using quantifiers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_constraint(.model, .constraint_expr, ..., .show_progress_bar = TRUE)

add_constraint_(
  .model,
  .constraint_expr,
  ...,
  .dots,
  .show_progress_bar = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_constraint_+3A_.model">.model</code></td>
<td>
<p>the model</p>
</td></tr>
<tr><td><code id="add_constraint_+3A_.constraint_expr">.constraint_expr</code></td>
<td>
<p>the constraint. Must be a linear (in)equality with
operator &quot;&lt;=&quot;, &quot;==&quot; or &quot;&gt;=&quot;.</p>
</td></tr>
<tr><td><code id="add_constraint_+3A_...">...</code></td>
<td>
<p>quantifiers for the indexed variables. For all combinations of
bound variables a new constraint is created. In addition
you can add filter expressions</p>
</td></tr>
<tr><td><code id="add_constraint_+3A_.show_progress_bar">.show_progress_bar</code></td>
<td>
<p>displays a progressbar when adding multiple
constraints</p>
</td></tr>
<tr><td><code id="add_constraint_+3A_.dots">.dots</code></td>
<td>
<p>Used to work around non-standard evaluation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Model with new constraints added
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
MIPModel() %&gt;%
  add_variable(x[i], i = 1:5) %&gt;%
  # creates 5 constraints
  add_constraint(x[i] &gt;= 1, i = 1:5) %&gt;%
  # you can also use filter expressions
  add_constraint(x[i] &gt;= 1, i = 1:5, i %% 2 == 0) %&gt;%
  # and depent on other indexes
  add_constraint(x[j] &gt;= 1, i = 1:10, j = 1:i, j &lt;= 5)
</code></pre>

<hr>
<h2 id='add_variable'>Add a variable to the model</h2><span id='topic+add_variable'></span><span id='topic+add_variable_'></span>

<h3>Description</h3>

<p>A variable can either be a name or an indexed name. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_variable(.model, .variable, ..., type = "continuous", lb = -Inf, ub = Inf)

add_variable_(
  .model,
  .variable,
  ...,
  type = "continuous",
  lb = -Inf,
  ub = Inf,
  .dots
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_variable_+3A_.model">.model</code></td>
<td>
<p>the model</p>
</td></tr>
<tr><td><code id="add_variable_+3A_.variable">.variable</code></td>
<td>
<p>the variable name/definition</p>
</td></tr>
<tr><td><code id="add_variable_+3A_...">...</code></td>
<td>
<p>quantifiers for the indexed variable. Including filters</p>
</td></tr>
<tr><td><code id="add_variable_+3A_type">type</code></td>
<td>
<p>must be either continuous, integer or binary</p>
</td></tr>
<tr><td><code id="add_variable_+3A_lb">lb</code></td>
<td>
<p>the lower bound of the variable</p>
</td></tr>
<tr><td><code id="add_variable_+3A_ub">ub</code></td>
<td>
<p>the upper bound of the variable</p>
</td></tr>
<tr><td><code id="add_variable_+3A_.dots">.dots</code></td>
<td>
<p>Used to work around non-standard evaluation.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
MIPModel() %&gt;%
  add_variable(x) %&gt;% # creates 1 variable named x
  add_variable(y[i],
    i = 1:10, i %% 2 == 0,
    type = "binary"
  ) # creates 4 variables
</code></pre>

<hr>
<h2 id='additional_solver_output'>Retrieve additional solver specific output</h2><span id='topic+additional_solver_output'></span>

<h3>Description</h3>

<p>Retrieve additional solver specific output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>additional_solver_output(solution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="additional_solver_output_+3A_solution">solution</code></td>
<td>
<p>a solution object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of named entries. What is in that list is determined
by the solver function. For <code>ompr.roi</code> this is usually a solver specific
message and status information.
</p>

<hr>
<h2 id='as_colwise'>As_colwise</h2><span id='topic+as_colwise'></span>

<h3>Description</h3>

<p>Convert lists or vectors to colwise semantic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_colwise(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_colwise_+3A_x">x</code></td>
<td>
<p>a list of numeric vectors or a numeric vector</p>
</td></tr>
</table>

<hr>
<h2 id='colwise'>Format variables colwise</h2><span id='topic+colwise'></span>

<h3>Description</h3>

<p>This function should be used if you to expand a variable
across columns and not rows. When passing a vector of indexes
to MILPModel variable, it creates a new row for each vector element.
With colwise you can create columns instead. Please see the examples
below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colwise(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colwise_+3A_...">...</code></td>
<td>
<p>create a colwise vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'colwise' is probably the concept that is likely to change in the future.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# vectors create matrix rows
# x[1, 1]
# x[2, 1]
# x[3, 1]
x[1:3, 1]

# colwise() creates columns per row
# 1 * x[1, 1] + 2 * x[1, 2] + 3 * x[1, 3]
colwise(1, 2, 3) * x[1, colwise(1, 2, 3)]

# or you have multiple rows and columns and different coefficients
# 1 * x[1, 1] + 2 * x[1, 2] + 3 * x[1, 3]
# 4 * x[2, 1] + 5 * x[2, 2] + 6 * x[1, 3]
colwise(1:6) * x[1:2, colwise(1:3)]
# in the example above, the colwise vector multiplied with the variable
# has an element per row and column
# in general, it can be a multiple of number of columns

# you can also combine the two
# x[1, 1]
# x[2, 1] + x[2, 2]
# x[3, 1] + x[3, 2] + x[3, 2]
x[1:3, colwise(1, 1:2, 1:3)]

## End(Not run)
</code></pre>

<hr>
<h2 id='extract_constraints'>Extract the constraint matrix, the right hand side and the sense from a model</h2><span id='topic+extract_constraints'></span>

<h3>Description</h3>

<p>Extract the constraint matrix, the right hand side and the sense from a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_constraints(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_constraints_+3A_model">model</code></td>
<td>
<p>the model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with three named elements.
'matrix' the (sparse) constraint matrix from the Matrix package.
'rhs' is the right hand side vector in the order of the matrix.
'sense' is a vector of the constraint senses
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
model &lt;- MIPModel() %&gt;%
  add_variable(x[i], i = 1:3) %&gt;%
  add_variable(y[i], i = 1:3) %&gt;%
  add_constraint(x[i] + y[i] &lt;= 1, i = 1:3)
extract_constraints(model)
</code></pre>

<hr>
<h2 id='get_column_duals'>Gets the column duals of a solution</h2><span id='topic+get_column_duals'></span>

<h3>Description</h3>

<p>Gets the column duals of a solution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_column_duals(solution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_column_duals_+3A_solution">solution</code></td>
<td>
<p>a solution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a numeric vector with one element per column or 'NA_real_'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
result &lt;- MIPModel() %&gt;%
  add_variable(x[i], i = 1:5) %&gt;%
  add_variable(y[i, j], i = 1:5, j = 1:5) %&gt;%
  add_constraint(x[i] &gt;= 1, i = 1:5) %&gt;%
  set_bounds(x[i], lb = 3, i = 1:3) %&gt;%
  set_objective(sum_over(i * x[i], i = 1:5)) %&gt;%
  solve_model(with_ROI("glpk"))

get_column_duals(result)

## End(Not run)

</code></pre>

<hr>
<h2 id='get_row_duals'>Gets the row duals of a solution</h2><span id='topic+get_row_duals'></span>

<h3>Description</h3>

<p>Gets the row duals of a solution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_row_duals(solution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_row_duals_+3A_solution">solution</code></td>
<td>
<p>a solution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a numeric vector with one element per row or 'NA_real_'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
result &lt;- MIPModel() %&gt;%
  add_variable(x[i], i = 1:5) %&gt;%
  add_variable(y[i, j], i = 1:5, j = 1:5) %&gt;%
  add_constraint(x[i] &gt;= 1, i = 1:5) %&gt;%
  set_bounds(x[i], lb = 3, i = 1:3) %&gt;%
  set_objective(sum_expr(i * x[i], i = 1:5)) %&gt;%
  solve_model(with_ROI("glpk"))

get_row_duals(result)

## End(Not run)
</code></pre>

<hr>
<h2 id='get_solution'>Get variable values from a solution</h2><span id='topic+get_solution'></span><span id='topic+get_solution_'></span>

<h3>Description</h3>

<p>Get variable values from a solution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_solution(solution, expr, type = "primal")

get_solution_(solution, expr, type = "primal")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_solution_+3A_solution">solution</code></td>
<td>
<p>the solution object</p>
</td></tr>
<tr><td><code id="get_solution_+3A_expr">expr</code></td>
<td>
<p>a variable expression. You can partially bind indexes.</p>
</td></tr>
<tr><td><code id="get_solution_+3A_type">type</code></td>
<td>
<p>optional, either &quot;primal&quot; or &quot;dual&quot;. The default value is &quot;primal&quot;.
If &quot;primal&quot; it returns the primal solution, otherwise the column duals.
Especially the dual values depend on the solver. If no duals are calculated,
the function stops with an error message.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame. One row for each variable instance
and a column for each index.
Unless it is a single variable, then it returns a single number.
Please note that in case of a <code>data.frame</code> there is no
guarantee about the ordering of the rows. This could change
in future <code>ompr</code> versions. Please always use the indexes
to retrieve the correct values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(magrittr)
result &lt;- MIPModel() %&gt;%
  add_variable(x[i], i = 1:5) %&gt;%
  add_variable(y[i, j], i = 1:5, j = 1:5) %&gt;%
  add_constraint(x[i] &gt;= 1, i = 1:5) %&gt;%
  set_bounds(x[i], lb = 3, i = 1:3) %&gt;%
  set_objective(0) %&gt;%
  solve_model(with_ROI("glpk"))
solution &lt;- get_solution(result, x[i])
solution2 &lt;- get_solution(result, y[i, 1])
solution3 &lt;- get_solution(result, y[i, j])
duals &lt;- get_solution(result, x[i], type = "dual")

## End(Not run)

</code></pre>

<hr>
<h2 id='LinearVariableCollection-class'>An S4 class that represents a collection of variables</h2><span id='topic+LinearVariableCollection-class'></span><span id='topic+LinearVariable-class'></span><span id='topic+LinearVariableSum-class'></span><span id='topic++2A+2CLinearVariableSum+2Cnumeric-method'></span><span id='topic++2A+2Cnumeric+2CLinearVariableSum-method'></span><span id='topic+-+2CLinearVariableSum+2Cnumeric-method'></span><span id='topic+-+2Cnumeric+2CLinearVariableSum-method'></span><span id='topic++2B+2CLinearVariableSum+2CLinearVariableSum-method'></span><span id='topic+-+2CLinearVariableSum+2CLinearVariableSum-method'></span><span id='topic++2B+2CLinearVariableSum+2CLinearVariableCollection-method'></span><span id='topic++2B+2CLinearVariableCollection+2CLinearVariableSum-method'></span><span id='topic+-+2CLinearVariableCollection+2CLinearVariableSum-method'></span><span id='topic+-+2CLinearVariableSum+2CLinearVariableCollection-method'></span><span id='topic++2B+2CLinearVariableSum+2Cnumeric-method'></span><span id='topic++2B+2Cnumeric+2CLinearVariableSum-method'></span><span id='topic+-+2CLinearVariableSum+2Cmissing-method'></span><span id='topic+-+2CLinearVariableCollection+2Cmissing-method'></span><span id='topic++2B+2CLinearVariableSum+2Cmissing-method'></span><span id='topic++2B+2CLinearVariableCollection+2Cmissing-method'></span><span id='topic++2B+2CLinearVariableCollection+2Cnumeric-method'></span><span id='topic++2B+2Cnumeric+2CLinearVariableCollection-method'></span><span id='topic+-+2CLinearVariableCollection+2Cnumeric-method'></span><span id='topic+-+2Cnumeric+2CLinearVariableCollection-method'></span><span id='topic++2F+2CLinearVariableCollection+2Cnumeric-method'></span><span id='topic++2F+2CLinearVariableSum+2Cnumeric-method'></span><span id='topic++2B+2CLinearVariableCollection+2CLinearVariableCollection-method'></span><span id='topic+-+2CLinearVariableCollection+2CLinearVariableCollection-method'></span><span id='topic++2A+2CLinearVariableCollection+2Cnumeric-method'></span><span id='topic++2A+2Cnumeric+2CLinearVariableCollection-method'></span><span id='topic++5B+2CLinearVariableCollection+2CANY+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>It will multiply the numeric vector with both the constant and the variable in
'LinearVariableSum'
</p>
<p>It will multiply the numeric vector with both the constant and the variable in
'LinearVariableSum'
</p>
<p>Equivalent to 'e1 + -1 * e2'
</p>
<p>Equivalent to '(-1 * e2) - (-1 * e1)'
</p>
<p>Add two object of 'LinearVariableSum'. I.e. variables + constants
</p>
<p>Equivalent to 'e1 + (-1) * e2'
</p>
<p>Adds the variables in the rhs to the variables in the lhs and returns another 'LinearVariableSum'.
</p>
<p>Equivalent to 'e2 + e1'
</p>
<p>Equivalent to '-1 * (e2 - e1)'
</p>
<p>Equivalent to 'e1 + -1 * e2'
</p>
<p>Adds a constant (rhs) to constant slot of the lhs object.
</p>
<p>Equivalent to 'e2 + e1'
</p>
<p>Equivalent to 'e1 * (-1)'
</p>
<p>Equivalent to 'e1 * (-1)'
</p>
<p>Equivalent to 'e1'
</p>
<p>Equivalent to 'e1'
</p>
<p>Adds a constant numeric vector to a variable. The constant needs to be a vector of length 1.
</p>
<p>Equivalent to 'e2 + e1'
</p>
<p>Equivalent to 'e1 + -1 * e2'
</p>
<p>Equivalent to '(-1 * e2) - (-1 * e1)'
</p>
<p>Equivalent to 'e1 * (1 / e2)'
</p>
<p>Equivalent to 'e1 * (1 / e2)'
</p>
<p>Adds two variables together. Same values for variable, row and col will be added. Everything else merged.
</p>
<p>Equivalent to 'e1 + -1 * e2'
</p>
<p>Multiplies the coefficients rowwise with a given numeric vector.
If the numeric vector is a 'linear_transposed_vector', it will multiply the vector
with each variable per row.
</p>
<p>Equivalent to 'e2 * e1'
</p>
<p>This creates a new variable collection as a subset of the previously defined indexed variable.
A variable collection essentially is a data frame having values for rows and columns of the final model matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LinearVariableSum,numeric'
e1 * e2

## S4 method for signature 'numeric,LinearVariableSum'
e1 * e2

## S4 method for signature 'LinearVariableSum,numeric'
e1 - e2

## S4 method for signature 'numeric,LinearVariableSum'
e1 - e2

## S4 method for signature 'LinearVariableSum,LinearVariableSum'
e1 + e2

## S4 method for signature 'LinearVariableSum,LinearVariableSum'
e1 - e2

## S4 method for signature 'LinearVariableSum,LinearVariableCollection'
e1 + e2

## S4 method for signature 'LinearVariableCollection,LinearVariableSum'
e1 + e2

## S4 method for signature 'LinearVariableCollection,LinearVariableSum'
e1 - e2

## S4 method for signature 'LinearVariableSum,LinearVariableCollection'
e1 - e2

## S4 method for signature 'LinearVariableSum,numeric'
e1 + e2

## S4 method for signature 'numeric,LinearVariableSum'
e1 + e2

## S4 method for signature 'LinearVariableSum,missing'
e1 - e2

## S4 method for signature 'LinearVariableCollection,missing'
e1 - e2

## S4 method for signature 'LinearVariableSum,missing'
e1 + e2

## S4 method for signature 'LinearVariableCollection,missing'
e1 + e2

## S4 method for signature 'LinearVariableCollection,numeric'
e1 + e2

## S4 method for signature 'numeric,LinearVariableCollection'
e1 + e2

## S4 method for signature 'LinearVariableCollection,numeric'
e1 - e2

## S4 method for signature 'numeric,LinearVariableCollection'
e1 - e2

## S4 method for signature 'LinearVariableCollection,numeric'
e1 / e2

## S4 method for signature 'LinearVariableSum,numeric'
e1 / e2

## S4 method for signature 'LinearVariableCollection,LinearVariableCollection'
e1 + e2

## S4 method for signature 'LinearVariableCollection,LinearVariableCollection'
e1 - e2

## S4 method for signature 'LinearVariableCollection,numeric'
e1 * e2

## S4 method for signature 'numeric,LinearVariableCollection'
e1 * e2

## S4 method for signature 'LinearVariableCollection,ANY,ANY,missing'
x[i, j, ..., drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LinearVariableCollection-class_+3A_e1">e1</code></td>
<td>
<p>a numeric value</p>
</td></tr>
<tr><td><code id="LinearVariableCollection-class_+3A_e2">e2</code></td>
<td>
<p>an object of type 'LinearVariableCollection'</p>
</td></tr>
<tr><td><code id="LinearVariableCollection-class_+3A_x">x</code></td>
<td>
<p>an object of type 'LinearVariableCollection'</p>
</td></tr>
<tr><td><code id="LinearVariableCollection-class_+3A_i">i</code></td>
<td>
<p>a numeric vector or a colwise vector/list</p>
</td></tr>
<tr><td><code id="LinearVariableCollection-class_+3A_j">j</code></td>
<td>
<p>a numeric vector or a colwise vector/list</p>
</td></tr>
<tr><td><code id="LinearVariableCollection-class_+3A_...">...</code></td>
<td>
<p>more a numeric vectors or a colwise vector/list</p>
</td></tr>
<tr><td><code id="LinearVariableCollection-class_+3A_drop">drop</code></td>
<td>
<p>do not use this parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of type 'LinearVariableSum'
</p>
<p>Returns an object of type 'LinearVariableSum'
</p>
<p>Returns an object of type 'LinearVariableSum'
</p>
<p>an object of type 'LinearVariableSum'
</p>
<p>a new object of type 'LinearVariableCollection'
</p>


<h3>Slots</h3>


<dl>
<dt><code>variables</code></dt><dd><p>a data frame hold the variable coefficients. One line for reach variable, row and column.</p>
</dd>
<dt><code>index_mapping</code></dt><dd><p>a function that takes a variable name as character and returns a mapping table that maps column ids to variable indexes.</p>
</dd>
<dt><code>variable</code></dt><dd><p>a linear variable collection with just one index '1'</p>
</dd>
<dt><code>constant</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>variables</code></dt><dd><p>a variable collection</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# vectors create matrix rows
# x[1, 1]
# x[2, 1]
# x[3, 1]
x[1:3, 1]

# colwise() creates columns per row
# 1 * x[1, 1] + 2 * x[1, 2] + 3 * x[1, 3]
colwise(1, 2, 3) * x[1, colwise(1, 2, 3)]

# you can also combine the two
# x[1, 1]
# x[2, 1] + x[2, 2]
# x[3, 1] + x[3, 2] + x[3, 2]
x[1:3, colwise(1, 1:2, 1:3)]

## End(Not run)
</code></pre>

<hr>
<h2 id='MILPModel'>Experimental: Create a new MILP Model</h2><span id='topic+MILPModel'></span>

<h3>Description</h3>

<p>Create an an empty mixed-integer linear programming model that is
about 1000 times faster than 'MIPModel'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MILPModel()
</code></pre>


<h3>Details</h3>

<p>Please only use it if you can deal with potential API changes in the future.
When you use 'MILPModel' make sure to always model your problem with
'MIPModel' as well, just to make sure you get the same results.
</p>
<p>It is also always a good idea to test your model with very small input sizes
and examine the coefficients and rows of the constraint matrix.
</p>

<hr>
<h2 id='MIPModel'>Create a new MIP Model</h2><span id='topic+MIPModel'></span>

<h3>Description</h3>

<p>Create a new MIP Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MIPModel()
</code></pre>

<hr>
<h2 id='nconstraints'>Number of variables (rows) of the model</h2><span id='topic+nconstraints'></span>

<h3>Description</h3>

<p>Number of variables (rows) of the model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nconstraints(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nconstraints_+3A_model">model</code></td>
<td>
<p>the model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer equal to the number of variables. A
variable is here a column in the resulting constraint matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
model &lt;- MIPModel() %&gt;%
  add_variable(x) %&gt;%
  add_variable(y[i], i = 1:10)
nconstraints(model) # 11
</code></pre>

<hr>
<h2 id='new_solution'>Create a new solution</h2><span id='topic+new_solution'></span>

<h3>Description</h3>

<p>This function/class should only be used if you develop your own solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_solution(
  model,
  objective_value,
  status,
  solution,
  solution_column_duals = function() NA_real_,
  solution_row_duals = function() NA_real_,
  additional_solver_output = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_solution_+3A_model">model</code></td>
<td>
<p>the optimization model that was solved</p>
</td></tr>
<tr><td><code id="new_solution_+3A_objective_value">objective_value</code></td>
<td>
<p>a numeric objective value</p>
</td></tr>
<tr><td><code id="new_solution_+3A_status">status</code></td>
<td>
<p>the status of the solution</p>
</td></tr>
<tr><td><code id="new_solution_+3A_solution">solution</code></td>
<td>
<p>a named numeric vector containing the primal solution values</p>
</td></tr>
<tr><td><code id="new_solution_+3A_solution_column_duals">solution_column_duals</code></td>
<td>
<p>A function without arguments that returns a numeric vector containing the column dual solution values. 'NA_real_', if no column duals are available/defined.</p>
</td></tr>
<tr><td><code id="new_solution_+3A_solution_row_duals">solution_row_duals</code></td>
<td>
<p>A function without arguments that returns a numeric vector containing the column dual solution values. 'NA_real_', if no column duals are available/defined.</p>
</td></tr>
<tr><td><code id="new_solution_+3A_additional_solver_output">additional_solver_output</code></td>
<td>
<p>A named list of additional solver information</p>
</td></tr>
</table>

<hr>
<h2 id='nvars'>Number of variables of a model</h2><span id='topic+nvars'></span>

<h3>Description</h3>

<p>Number of variables of a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nvars(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nvars_+3A_model">model</code></td>
<td>
<p>the model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with three named elements.
'binary' =&gt; number of binary variables,
'integer' =&gt; number of integer variables,
'continuous' =&gt; number of continuous variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
model &lt;- MIPModel() %&gt;%
  add_variable(x[i], i = 1:10, type = "binary") %&gt;%
  add_variable(y[i], i = 1:5, type = "continuous") %&gt;%
  add_variable(z[i], i = 1:2, type = "integer")
nvars(model)
</code></pre>

<hr>
<h2 id='objective_function'>Extract the objective function from a model</h2><span id='topic+objective_function'></span>

<h3>Description</h3>

<p>Extract the objective function from a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objective_function(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objective_function_+3A_model">model</code></td>
<td>
<p>the model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two named elements, 'solution' and 'constant'.
'solution' is a sparse vector from the Matrix package.
'constant' is a constant that needs to be added to get the final obj. value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
model &lt;- MIPModel() %&gt;%
  add_variable(x[i], i = 1:5) %&gt;%
  set_objective(sum_over(i * x[i], i = 1:5) + 10)
objective_function(model)
</code></pre>

<hr>
<h2 id='objective_value'>Extract the numerical objective value from a solution</h2><span id='topic+objective_value'></span>

<h3>Description</h3>

<p>Extract the numerical objective value from a solution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objective_value(solution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objective_value_+3A_solution">solution</code></td>
<td>
<p>a solution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric single item vector
</p>

<hr>
<h2 id='set_bounds'>Set the bounds of a variable</h2><span id='topic+set_bounds'></span><span id='topic+set_bounds_'></span>

<h3>Description</h3>

<p>Change the lower and upper bounds of a named variable,
indexed variable or a group of variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_bounds(.model, .variable, ..., lb = NULL, ub = NULL)

set_bounds_(.model, .variable, ..., lb = NULL, ub = NULL, .dots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_bounds_+3A_.model">.model</code></td>
<td>
<p>the model</p>
</td></tr>
<tr><td><code id="set_bounds_+3A_.variable">.variable</code></td>
<td>
<p>the variable name/definition or a linear constraint</p>
</td></tr>
<tr><td><code id="set_bounds_+3A_...">...</code></td>
<td>
<p>quantifiers for the indexed variable</p>
</td></tr>
<tr><td><code id="set_bounds_+3A_lb">lb</code></td>
<td>
<p>the lower bound of the variable.</p>
</td></tr>
<tr><td><code id="set_bounds_+3A_ub">ub</code></td>
<td>
<p>the upper bound of the variable
</p>
<p>For <code>MIPModel</code> you can also pass (in)equalities to define bounds. Please
look at the examples.</p>
</td></tr>
<tr><td><code id="set_bounds_+3A_.dots">.dots</code></td>
<td>
<p>Used to work around non-standard evaluation.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
MIPModel() %&gt;%
  add_variable(x[i], i = 1:5) %&gt;%
  add_constraint(x[i] &gt;= 1, i = 1:5) %&gt;% # creates 5 constraints
  set_bounds(x[i], lb = 3, i = 1:3) %&gt;%
  variable_bounds()

MIPModel() %&gt;%
  add_variable(x[i], i = 1:5) %&gt;%
  set_bounds(x[i] &lt;= i, i = 1:5) %&gt;% # upper bound
  set_bounds(x[i] &gt;= 0, i = 1:5) %&gt;% # lower bound
  set_bounds(x[5] == 45) %&gt;%
  variable_bounds()
</code></pre>

<hr>
<h2 id='set_objective'>Set the model objective</h2><span id='topic+set_objective'></span><span id='topic+set_objective_'></span>

<h3>Description</h3>

<p>Set the model objective
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_objective(model, expression, sense = c("max", "min"))

set_objective_(model, expression, sense = c("max", "min"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_objective_+3A_model">model</code></td>
<td>
<p>the model</p>
</td></tr>
<tr><td><code id="set_objective_+3A_expression">expression</code></td>
<td>
<p>the linear objective as a sum of variables and constants</p>
</td></tr>
<tr><td><code id="set_objective_+3A_sense">sense</code></td>
<td>
<p>the model sense. Must be either &quot;max&quot; or &quot;min&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Model with a new objective function definition
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
MIPModel() %&gt;%
  add_variable(x, lb = 2) %&gt;%
  add_variable(y, lb = 40) %&gt;%
  set_objective(x + y, sense = "min")
</code></pre>

<hr>
<h2 id='solve_model'>Solve a model</h2><span id='topic+solve_model'></span>

<h3>Description</h3>

<p>Solve a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve_model(model, solver)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve_model_+3A_model">model</code></td>
<td>
<p>the model</p>
</td></tr>
<tr><td><code id="solve_model_+3A_solver">solver</code></td>
<td>
<p>a function mapping a model to a solution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>solver(model)
</p>

<hr>
<h2 id='solver_status'>Get the solver status from a solution</h2><span id='topic+solver_status'></span>

<h3>Description</h3>

<p>Get the solver status from a solution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solver_status(solution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solver_status_+3A_solution">solution</code></td>
<td>
<p>a solution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector being either &quot;infeasible&quot;, &quot;optimal&quot;, &quot;unbounded&quot;, &quot;userlimit&quot; or &quot;error
</p>

<hr>
<h2 id='sum_over'>Sum over indexes</h2><span id='topic+sum_over'></span><span id='topic+sum_expr'></span>

<h3>Description</h3>

<p>This functions helps to create summations over indexes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_over(.expr, ...)

sum_expr(.expr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_over_+3A_.expr">.expr</code></td>
<td>
<p>an expression that can be expanded to a sum</p>
</td></tr>
<tr><td><code id="sum_over_+3A_...">...</code></td>
<td>
<p>bind variables in expr using dots. See examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the sum over all the indexes
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_constraint">add_constraint</a></code>
</p>
<p><code><a href="#topic+set_objective">set_objective</a></code>
</p>
<p>Please note that <code>sum_expr</code> is deprecated when used together with
<code>MIPModel</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (FALSE) {
  # create a sum from x_1 to x_10
  sum_over(x[i], i = 1:10)
  # create a sum from x_2 to x_10 with even indexes
  sum_over(x[i], i = 1:10, i %% 2 == 0)
  sum_over(x[i, j], i = 1:10, j = 1:i)
}
</code></pre>

<hr>
<h2 id='variable_bounds'>Variable lower and upper bounds of a model</h2><span id='topic+variable_bounds'></span>

<h3>Description</h3>

<p>Variable lower and upper bounds of a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variable_bounds(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variable_bounds_+3A_model">model</code></td>
<td>
<p>the model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two components 'lower' and 'upper' each
having a numeric vector of bounds. One for each variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
model &lt;- MIPModel() %&gt;%
  add_variable(x, type = "binary") %&gt;%
  add_variable(y, type = "continuous", lb = 2) %&gt;%
  add_variable(z, type = "integer", ub = 3)
variable_bounds(model)
</code></pre>

<hr>
<h2 id='variable_keys'>Get all unique names of the model variables</h2><span id='topic+variable_keys'></span>

<h3>Description</h3>

<p>Get all unique names of the model variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variable_keys(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variable_keys_+3A_model">model</code></td>
<td>
<p>the model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector ordered in the same way
as the constraint matrix columns and objective vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
model &lt;- MIPModel() %&gt;%
  add_variable(x[i], i = 1:3)
variable_keys(model)
</code></pre>

<hr>
<h2 id='variable_types'>Variable types of a model</h2><span id='topic+variable_types'></span>

<h3>Description</h3>

<p>One component for each variable in the correct order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variable_types(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variable_types_+3A_model">model</code></td>
<td>
<p>the model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a factor with levels binary, continuous, integer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
model &lt;- MIPModel() %&gt;%
  add_variable(x, type = "binary") %&gt;%
  add_variable(y, type = "continuous") %&gt;%
  add_variable(z, type = "integer")
variable_types(model)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
