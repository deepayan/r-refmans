<!DOCTYPE html><html lang="en"><head><title>Help for package SimSeq</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SimSeq}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SimSeq-package'><p>Nonparametric Simulation of RNA-Seq Data</p></a></li>
<li><a href='#CalcPvalWilcox'>
<p>Calculate P-values of Differential Expression</p></a></li>
<li><a href='#kidney'>
<p>Kidney Renal Clear Cell Carcinoma [KIRC] RNA-Seq data</p></a></li>
<li><a href='#SimData'><p>SimData</p></a></li>
<li><a href='#SortData'>
<p>SortData</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Nonparametric Simulation of RNA-Seq Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2015-11-22</td>
</tr>
<tr>
<td>Author:</td>
<td>Samuel Benidt</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Samuel Benidt &lt;sgbenidt@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>fdrtool</td>
</tr>
<tr>
<td>Description:</td>
<td>RNA sequencing analysis methods are often derived by relying on hypothetical parametric models for read counts that are not likely to be precisely satisfied in practice. Methods are often tested by analyzing data that have been simulated according to the assumed model. This testing strategy can result in an overly optimistic view of the performance of an RNA-seq analysis method. We develop a data-based simulation algorithm for RNA-seq data. The vector of read counts simulated for a given experimental unit has a joint distribution that closely matches the distribution of a source RNA-seq dataset provided by the user. Users control the proportion of genes simulated to be differentially expressed (DE) and can provide a vector of weights to control the distribution of effect sizes. The algorithm requires a matrix of RNA-seq read counts with large sample sizes in at least two treatment groups. Many datasets are available that fit this standard.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2015-11-23 09:19:01 UTC; Samuel</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2015-11-23 12:33:58</td>
</tr>
</table>
<hr>
<h2 id='SimSeq-package'>Nonparametric Simulation of RNA-Seq Data</h2><span id='topic+SimSeq-package'></span><span id='topic+SimSeq'></span>

<h3>Description</h3>

<p>RNA sequencing analysis methods are often derived by relying on hypothetical parametric models for read counts that are not likely to be precisely satisfied in practice. Methods are often tested by analyzing data that have been simulated according to the assumed model. This testing strategy can result in an overly optimistic view of the performance of an RNA-seq analysis method. We develop a data-based simulation algorithm for RNA-seq data. The vector of read counts simulated for a given experimental unit has a joint distribution that closely matches the distribution of a source RNA-seq dataset provided by the user. Users control the proportion of genes simulated to be differentially expressed (DE) and can provide a vector of weights to control the distribution of effect sizes. The algorithm requires a matrix of RNA-seq read counts with large sample sizes in at least two treatment groups. Many datasets are available that fit this standard.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> SimSeq</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.4.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2015-11-22</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>SimSeq performs data based simulation of RNA-Seq data creating a dataset with a known list of DE and EE genes. The core function that implements of the methodology of SimSeq is the SimData function.
</p>


<h3>Author(s)</h3>

<p>Samuel Benidt
</p>
<p>Maintainer: Samuel Benidt &lt;sgbenidt@gmail.com&gt;
</p>

<hr>
<h2 id='CalcPvalWilcox'>
Calculate P-values of Differential Expression
</h2><span id='topic+CalcPvalWilcox'></span>

<h3>Description</h3>

<p>A function called within SimData. Calculates the P-value of differential expression for each gene under either Wilcoxin signed rank test (paired data) or rank sum test (unpaired data). The vector of differences used in the test is based off of the log of the counts for each gene plus 1 divided by their respective multiplicative normalization factors provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcPvalWilcox(counts, treatment, replic = NULL, sort.method, 
               sorted = FALSE, norm.factors, exact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalcPvalWilcox_+3A_counts">counts</code></td>
<td>

<p>A matrix of counts where each row specifies a gene and each column specifies a replicate.
</p>
</td></tr>
<tr><td><code id="CalcPvalWilcox_+3A_treatment">treatment</code></td>
<td>

<p>A vector specifying the treatment group for each column of the counts matrix. Only two treatment groups of either paired or unpaired data are allowed.
</p>
</td></tr>
<tr><td><code id="CalcPvalWilcox_+3A_replic">replic</code></td>
<td>

<p>A vector specifying the replicate for each column of the counts matrix when there is paired data; optional if data is unpaired.
</p>
</td></tr>
<tr><td><code id="CalcPvalWilcox_+3A_sort.method">sort.method</code></td>
<td>

<p>Character vector specifying one of &quot;unpaired&quot; or &quot;paired&quot;, depending on the structure of the data.
</p>
</td></tr>
<tr><td><code id="CalcPvalWilcox_+3A_sorted">sorted</code></td>
<td>

<p>logical vector specifying whether data has already gone through SortData function. Defaults to FALSE.
</p>
</td></tr>
<tr><td><code id="CalcPvalWilcox_+3A_norm.factors">norm.factors</code></td>
<td>

<p>A positive numeric vector of multiplicative normalization factors for each column of the counts matrix.
</p>
</td></tr>
<tr><td><code id="CalcPvalWilcox_+3A_exact">exact</code></td>
<td>

<p>Specifies whether an exact signed rank test (paired) or exact ranksum test (unpaired) should be used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>probs: a vector of p-values of differential expression for each gene.
</p>


<h3>Author(s)</h3>

<p>Samuel Benidt &lt;sgbenidt@gmail.com&gt;
</p>

<hr>
<h2 id='kidney'>
Kidney Renal Clear Cell Carcinoma [KIRC] RNA-Seq data
</h2><span id='topic+kidney'></span>

<h3>Description</h3>

<p>The KIRC RNA-seq dataset from The Cancer Genome Atlas containing 20531 genes and 72 paired columns of data with rows corresponding to genes and columns corresponding to replicates; replic vector specifies replicates and treatment vector specifies non-tumor and tumor group samples respectively within replicate.
</p>
<p>The maximum possible sample size that can be simulated with this dataset is 36 replicates in each of two treatment groups. However, it is recommended to use a sample size of 20 or lower for simulation studies to ensure each simulated dataset is sufficiently different from the other simulated datasets.
</p>
<p>Disclaimer: 
The version of the KIRC dataset provided is:
unc.edu_KIRC.IlluminaHiSeq_RNASeqV2.Level_3.1.5.0. 
</p>
<p>The Cancer Genome Atlas updates its datasets periodically. The latest version of the KIRC dataset can always be downloaded from:
https://tcga-data.nci.nih.gov/tcga/. 
</p>
<p>Please appropriately reference the source below when using this dataset. The source code used to assemble this dataset is provided below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(kidney)</code></pre>


<h3>Format</h3>

<p>List containing:
</p>

<ul>
<li><p> counts: matrix of RNA-seq data for 20531 sampled genes and 72 paired columns from individuals with Kidney Renal Clear Cell Carcinoma.
</p>
</li>
<li><p> replic: vector detailing which column in counts matrix belongs to each individual.
</p>
</li>
<li><p> treatment: vector detailing whether each column in counts matrix is a non-tumor or tumor sample.
</p>
</li></ul>



<h3>Source</h3>

<p>https://tcga-data.nci.nih.gov/tcga/
</p>
<p>The Cancer Genome Atlas Research Network (2013). Comprehensive molecular characterization of clear cell renal cell carcinoma. Nature, 499(7456), 43-49.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(kidney)

## Not run: 
### Source code used to assemble KIRC dataset

### load in SimSeq package for sorting counts matrix
library(SimSeq)

### htmlToText function used to scrape barcode data from uuid
htmlToText &lt;- function(input, ...) {
  ###---PACKAGES ---###
  library(RCurl)
  library(XML) 
  
  ###--- LOCAL FUNCTIONS ---###
  # Determine how to grab html for a single input element
  evaluate_input &lt;- function(input) {    
    # if input is a .html file
    if(file.exists(input)) {
      char.vec &lt;- readLines(input, warn = FALSE)
      return(paste(char.vec, collapse = ""))
    }
    
    # if input is html text
    if(grepl("&lt;/html&gt;", input, fixed = TRUE)) return(input)
    
    # if input is a URL, probably should use a regex here instead?
    if(!grepl(" ", input)) {
      # downolad SSL certificate in case of https problem
      if(!file.exists("cacert.perm")) {
        download.file(url = "http://curl.haxx.se/ca/cacert.pem", destfile = "cacert.perm")
      }
      return(getURL(input, followlocation = TRUE, cainfo = "cacert.perm"))
    }
    
    # return NULL if none of the conditions above apply
    return(NULL)
  }
  
  # convert HTML to plain text
  convert_html_to_text &lt;- function(html) {
    doc &lt;- htmlParse(html, asText = TRUE)
    text &lt;- xpathSApply(doc, paste0("//text()",
                   "[not(ancestor::script)][not(ancestor::style)]",
                   "[not(ancestor::noscript)][not(ancestor::form)]"), xmlValue)
    return(text)
  }
  
  # format text vector into one character string
  collapse_text &lt;- function(txt) {
    return(paste(txt, collapse = " "))
  }
  
  ###--- MAIN ---###
  # STEP 1: Evaluate input
  html.list &lt;- lapply(input, evaluate_input)
  
  # STEP 2: Extract text from HTML
  text.list &lt;- lapply(html.list, convert_html_to_text)
  
  # STEP 3: Return text
  text.vector &lt;- sapply(text.list, collapse_text)
  return(text.vector)
}

### Specify path name for folder containing raw counts for each sample
mainDir &lt;- getwd()
folder.path &lt;- "unc.edu_KIRC.IlluminaHiSeq_RNASeqV2.Level_3.1.5.0"

### Determine list of files containing summarized raw counts
file.list &lt;- dir(file.path(mainDir, folder.path))
keep &lt;- grepl("genes.results", file.list)
file.list &lt;- file.list[keep]

### Create summarized count matrix.
### Get n.row and n.col for summarized count matrix number of genes in first
### sample and number of total samples from file.list

file.temp &lt;- file.path(mainDir, folder.path, file.list[1])
n.row &lt;- nrow(read.table(file = file.temp, header = TRUE))
n.col &lt;- length(file.list)

### initialize counts matrix
counts &lt;- matrix(NA, nrow = n.row, ncol = n.col)

### get gene id's
gene.id &lt;- read.table(file.temp, header = TRUE, stringsAsFactors = FALSE)$gene_id

### read in raw read counts from file.list
for(i in 1:n.col){
  file.temp &lt;- file.path(mainDir, folder.path, file.list[i])
  counts[, i] &lt;- read.table(file.temp, header = TRUE)$raw_count
}

### Data was summarized using RSEM software which produces non_integer 
### counts for ambiguous reads. Counts are rounded as a preprocessing
### step.
counts &lt;- round(counts)

### Cast counts matrix as integer type
counts &lt;- matrix(as.integer(counts), nrow = nrow(counts), ncol = ncol(counts))

### Get uuid's for each sample
uuid &lt;- substr(file.list, start = 9, stop = 44)

### Create urls from uuid list
urls &lt;- paste(rep("https://tcga-data.nci.nih.gov/uuid/uuidws/mapping/xml/uuid/",
                  length(uuid)), uuid, sep = "")

### Scrape barcodes from urls
l &lt;- length(urls)
barcodes &lt;- vector("character", l)
for(i in 1:l){
  barcodes[i] &lt;- htmlToText(urls[i])
}


barcodes &lt;- substr(barcodes, start = 1, stop = 28)

### Get metadata on which samples were taken from each individual, 
### tumor type of sample, etc. from barcodes for each sample
metadata &lt;- data.frame(barcodes, stringsAsFactors = FALSE)

### Study Participant
metadata$participant &lt;- substr(barcodes, start = 9, stop = 12)

### Sample type code. See:
### https://tcga-data.nci.nih.gov/datareports/codeTablesReport.htm?codeTable=Sample%20type
### for full list of codes and details on TCGA barcodes.
### 01: Primary Solid Tumor
### 02: Recurrent Solid Tumor
### 05: Additional New Primary
### 06: Metastatic Tumor
### 11: Solid Tissue Normal
metadata$type &lt;- substr(barcodes, start = 14, stop = 15)

### Only keep Primary Solid Tumor and Solid Tissue Normal
keep.metadata &lt;- metadata$type == "01" | metadata$type == "11"
metadata &lt;- metadata[keep.metadata, ]
counts &lt;- counts[, keep.metadata]

### Code from 01 to Tumor and 11 to Non-Tumor for easy identifiability
metadata$tumor &lt;- "Non-Tumor"
metadata$tumor[metadata$type == "01"] &lt;- "Tumor"

### tag participant, type, and tumor as factors
metadata$participant &lt;- as.factor(metadata$participant)
metadata$type &lt;-as.factor(metadata$type)
metadata$tumor &lt;- as.factor(metadata$tumor)

### Sort and subset down to paired data
sorting &lt;- 
  SortData(counts, treatment = metadata$tumor, 
           replic = metadata$participant, sort.method = "paired")$sorting

counts &lt;- counts[, sorting]
metadata &lt;- metadata[sorting, ]
metadata$participant &lt;- factor(metadata$participant)

### Add in attributes of counts matrix
dimnames(counts) &lt;- list(gene.id, metadata$barcodes)
attr(counts, "uuid") &lt;- uuid

kidney &lt;- vector("list", 3)
kidney[[1]] &lt;- counts
kidney[[2]] &lt;- metadata$participant
kidney[[3]] &lt;- metadata$tumor
names(kidney) &lt;- c("counts", "replic", "treatment")

###Save file
save(kidney, file = "kidney.rda")

## End(Not run)
</code></pre>

<hr>
<h2 id='SimData'>SimData</h2><span id='topic+SimData'></span>

<h3>Description</h3>

<p>Given a matrix of RNA-seq data with large samples sizes in at least two treatment groups, SimData simulates a new matrix of RNA-seq data with a known list of differentially expressed (DE) and equivalently expressed (EE) genes from the original data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimData(counts, treatment, replic = NULL, sort.method, k.ind, 
  n.genes = NULL, n.diff = NULL, norm.factors = NULL, 
  samp.independent = FALSE, genes.select = NULL, genes.diff = NULL, switch.trt = FALSE,
  probs = NULL, weights = NULL, exact = FALSE, power = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SimData_+3A_counts">counts</code></td>
<td>

<p>A matrix of counts where each row specifies a gene and each column specifies a replicate.
</p>
</td></tr>
<tr><td><code id="SimData_+3A_treatment">treatment</code></td>
<td>

<p>A vector specifying the treatment group for each column of the counts matrix. Only two treatment groups of either paired or unpaired data are allowed.
</p>
</td></tr>
<tr><td><code id="SimData_+3A_replic">replic</code></td>
<td>

<p>A vector specifying the replicate for each column of the counts matrix when there is paired data; optional if data is unpaired.
</p>
</td></tr>
<tr><td><code id="SimData_+3A_sort.method">sort.method</code></td>
<td>

<p>One of either &quot;paired&quot; or &quot;unpaired&quot;, depending on the structure of the counts matrix.
</p>
</td></tr>
<tr><td><code id="SimData_+3A_k.ind">k.ind</code></td>
<td>

<p>The number of experimental units to be simulated for each treatment group.
</p>
</td></tr>
<tr><td><code id="SimData_+3A_n.genes">n.genes</code></td>
<td>

<p>The number of genes to be subsetted from the counts matrix in the simulation. Must be less than the total number of rows in the counts matrix and greater than n.diff. Optional if genes.select vector is specified.
</p>
</td></tr>
<tr><td><code id="SimData_+3A_n.diff">n.diff</code></td>
<td>

<p>The number of genes simulated to be differentially expressed. Must be less than n.genes. Optional if genes.diff vector is specified.
</p>
</td></tr>
<tr><td><code id="SimData_+3A_norm.factors">norm.factors</code></td>
<td>

<p>A positive numeric vector of multiplicative normalization factors for each column of the counts matrix.  Will default to CalcNormFactors function from the package edgeR with method = &quot;TMM&quot;.
</p>
</td></tr>
<tr><td><code id="SimData_+3A_samp.independent">samp.independent</code></td>
<td>

<p>Should columns be resampled for each gene. (Defaults to FALSE - setting to TRUE is not recommended.)
</p>
</td></tr>
<tr><td><code id="SimData_+3A_genes.select">genes.select</code></td>
<td>

<p>A vector specifying genes to be subsetted from the counts matrix in the simulation. Can be either a logical vector or a numeric vector indicating the rows of the counts matrix to be used. Optional if n.genes is specified.
</p>
</td></tr>
<tr><td><code id="SimData_+3A_genes.diff">genes.diff</code></td>
<td>

<p>A vector specifying genes to be differentially expressed in the simulation. Genes selected to be differentially expressed must be a subset of the genes selected in the genes.select vector. Can be either logical vector with length equal to genes selected or a numeric vector indicating the rows of the counts matrix to be used. Optional if n.diff is specified.
</p>
</td></tr>
<tr><td><code id="SimData_+3A_switch.trt">switch.trt</code></td>
<td>

<p>Logical specifying which treatment group should be sampled from for EE genes. Default is first treatment group.  
</p>
</td></tr>
<tr><td><code id="SimData_+3A_probs">probs</code></td>
<td>

<p>Optional vector specifying the p-value of differential expression for each gene to be used in the estimate of empirical Bayes probability for each gene. If not provided and weights are not specified, SimData will perform either a signed rank test (paired case) or a rank sum test (unpaired) case for each gene in the counts matrix.
</p>
</td></tr>
<tr><td><code id="SimData_+3A_weights">weights</code></td>
<td>

<p>Optional vector specifying weights to be used for sampling which genes are to be differentially expressed in the simulation. If null, weights will be calculated using the fdrtool function from the package 'fdrtool' to calculate one minus local fdr. If desired, the sampling of differentially expressed genes can be done without respect to any weights by providing a vector of ones.
</p>
</td></tr>
<tr><td><code id="SimData_+3A_exact">exact</code></td>
<td>

<p>Specifies whether an exact signed rank test (paired) or exact ranksum test (unpaired) should be used.
</p>
</td></tr>
<tr><td><code id="SimData_+3A_power">power</code></td>
<td>

<p>Transorms the weights for each gene by raising each weights to some power. Must be greater than 0. Default is set to 1.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>SimData simulates an RNA-seq matrix of counts from a large source RNA-sequence dataset using a resampling based approach. If you use the Kidney Cancer (KIRC) dataset from the The Cancer Genome Atlas as the source RNA-seq counts matrix in the SimData function, please cite The Cancer Genome Atlas Research Network (2013) in any publications.
</p>


<h3>Value</h3>

<p>List containing:
</p>
<table role = "presentation">
<tr><td><code>counts</code></td>
<td>
<p>matrix of simulated RNA-seq data with known list of DE and EE genes.</p>
</td></tr>
<tr><td><code>treament</code></td>
<td>
<p>a numeric vector specifying the treatment group structure in the new simulated counts matrix.</p>
</td></tr>
<tr><td><code>genes.subset</code></td>
<td>
<p>all genes included in the simulated matrix. The i-th entry corresponds to the i-th row of the simulated counts matrix.</p>
</td></tr>
<tr><td><code>DE.genes</code></td>
<td>
<p>vector of genes used for differential expression in the simulated counts matrix.</p>
</td></tr>
<tr><td><code>DE.ind</code></td>
<td>
<p>logical vector indicating which genes are differentially expressed in the simulated counts matrix.</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>vector of lenght 3*k.ind specifying which columns were used in the simulation. The first k.ind columns were used to simulate the first treatment group. The last 2*k.ind columns were used to simulate the second treatment group. If switch.trt equals TRUE, then the first 2*k.ind columns were used to simulate the first treatment group and the last k.ind columns were used to simulate the second treatment group.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Samuel Benidt &lt;sgbenidt@gmail.com&gt;
</p>


<h3>Source</h3>

<p>Benidt, S., and Nettleton, D. (2015). SimSeq: a nonparametric approach to simulation of RNA-sequence datasets. Bioinformatics. 31, 2131-2140.
</p>
<p>The Cancer Genome Atlas Research Network (2013). Comprehensive molecular characterization of clear cell renal cell carcinoma. Nature, 499(7456), 43-49.
</p>
<p>https://tcga-data.nci.nih.gov/tcga/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(kidney)
counts &lt;- kidney$counts # Matrix of read counts from KIRC dataset
replic &lt;- kidney$replic # Replic vector indicating paired columns
treatment &lt;- kidney$treatment # Treatment vector indicating Non-Tumor or Tumor columns

nf &lt;- apply(counts, 2, quantile, 0.75)

library(fdrtool)

## Not run: 

  ### Example 1: Simulate Matrix with 1000 DE genes and 4000 EE genes
  data.sim &lt;- SimData(counts = counts, replic = replic, treatment = treatment, 
                      sort.method = "paired", k.ind = 5, n.genes = 5000, n.diff = 1000,
                      norm.factors = nf)
  
  ### Example 2: Calculate weights vector beforehand to save run time in
  ### repeated simulations
  sort.list &lt;- SortData(counts = counts, treatment = treatment, replic = replic,
                        sort.method = "paired", norm.factors = nf)
  counts &lt;- sort.list$counts
  replic &lt;- sort.list$replic
  treatment &lt;- sort.list$treatment
  nf &lt;- sort.list$norm.factors
  
  probs &lt;- CalcPvalWilcox(counts, treatment, sort.method = "paired", 
                          sorted = TRUE, norm.factors = nf, exact = FALSE)
  weights &lt;- 1 - fdrtool(probs, statistic = "pvalue", plot = FALSE, verbose = FALSE)$lfdr 
  
  data.sim &lt;- SimData(counts = counts, replic = replic, treatment = treatment, 
                      sort.method = "paired", k.ind = 5, n.genes = 5000, n.diff = 1000,
                      weights = weights, norm.factors = nf)
  
  ### Example 3: Specify which genes you want to use in the simulation
  
  # Randomly sample genes or feed in the exact genes you wish to use
  genes.diff &lt;- sample(1:nrow(counts), size = 1000, prob = weights)
  genes &lt;- c(sample(1:nrow(counts)[-genes.diff], 4000), genes.diff)
  
  data.sim &lt;- SimData(counts = counts, replic = replic, treatment = treatment, 
                      sort.method = "paired", k.ind = 5, genes.select = genes,
                      genes.diff = genes.diff, weights = weights, norm.factors = nf)
  
  ### Example 4: Simulate matrix with DE genes having log base 2 fold change greater than 1
  
  # add one to counts matrix to avoid infinities when taking logs
  tumor.mean &lt;- rowMeans(log2((counts[, treatment == "Tumor"] + 1) %*% 
    diag(1/nf[treatment == "Tumor"])))
  nontumor.mean &lt;- rowMeans(log2((counts[, treatment == "Non-Tumor"] + 1) %*% 
    diag(1/nf[treatment == "Non-Tumor"])))
  
  lfc &lt;- tumor.mean - nontumor.mean
  weights.zero &lt;- abs(lfc) &lt; 1
  weights[weights.zero] &lt;- 0

  data.sim &lt;- SimData(counts = counts, replic = replic, treatment = treatment, 
                      sort.method = "paired", k.ind = 5, n.genes = 5000, n.diff = 1000,
                      weights = weights, norm.factors = nf)
  
  ### Example 5: Simulate three treatment groups:
  ### 3 Different types of Differential Expression Allowed
  ### First Group Diff, Second and Third group Equal
  ### Second Group Diff, First and Third group Equal
  ### Third Group Diff, First and Second group Equal
  
  k &lt;- 5 # Sample Size in Each treatment group
  
  ### Sample DE genes beforehand
  N &lt;- nrow(counts)
  genes.de &lt;- sample(1:N, size = 1000, prob = weights) # Sample all DE genes
  DE1 &lt;- genes.de[1:333] # Sample DE genes with first trt diff
  DE2 &lt;- genes.de[334:666] # Sample DE genes with sec trt diff
  DE3 &lt;- genes.de[667:1000] # Sample DE genes with third trt diff
  EE &lt;- sample( (1:N)[-genes.de], size = 4000) #Sample EE genes
  
  genes.tot &lt;- c(EE, genes.de)
  genes.de1 &lt;- union(DE2, EE) #Assign DE genes for first sim
  genes.de2 &lt;- union(DE2, DE3) #Assign DE genes for second sim
  
  data.sim1 &lt;- SimData(counts = counts, replic = replic, treatment = treatment, 
                       sort.method = "paired", k.ind = k, genes.select = genes.tot,
                       genes.diff = genes.de1, weights = weights, norm.factors = nf)
  
  #remove pairs of columns used in first simulation
  cols.rm &lt;- c(data.sim1$col[1:(2*k)], data.sim1$col[1:(2*k)] + 1)
  counts.new &lt;- counts[, -cols.rm]
  nf.new &lt;- nf[-cols.rm]
  replic.new &lt;- replic[-cols.rm]
  treatment.new &lt;- treatment[-cols.rm]
  
  ### Set switch.trt = TRUE for second sim
  data.sim2 &lt;- SimData(counts = counts.new, replic = replic.new, treatment = treatment.new, 
                       sort.method = "paired", k.ind = k, genes.select = genes.tot,
                       genes.diff = genes.de2, weights = weights, norm.factors = nf.new,
                       switch.trt = TRUE)
  
  ### Remove first k.ind entries from first sim and combine two count matrices
  counts.sim &lt;- cbind(data.sim1$counts[, -(1:k)],  data.sim2$counts)
  
  ### treatment group levels for simulated matrix
  trt.grp &lt;- rep(NA, 5000)
  trt.grp[is.element(data.sim1$genes.subset, DE1)] &lt;- "DE_First_Trt"
  trt.grp[is.element(data.sim1$genes.subset, DE2)] &lt;- "DE_Second_Trt"
  trt.grp[is.element(data.sim1$genes.subset, DE3)] &lt;- "DE_Third_Trt"
  trt.grp[is.element(data.sim1$genes.subset, EE)] &lt;- "EE"

## End(Not run)


</code></pre>

<hr>
<h2 id='SortData'>
SortData
</h2><span id='topic+SortData'></span>

<h3>Description</h3>

<p>A function called in SimData used to trim and sort the matrix of counts provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SortData(counts, treatment, replic = NULL, sort.method, norm.factors = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SortData_+3A_counts">counts</code></td>
<td>

<p>A matrix of counts where each row specifies a gene and each column specifies a replicate.
</p>
</td></tr>
<tr><td><code id="SortData_+3A_treatment">treatment</code></td>
<td>

<p>A vector specifying the treatment group for each column of the counts matrix. Only two treatment groups of either paired or unpaired data are allowed.
</p>
</td></tr>
<tr><td><code id="SortData_+3A_replic">replic</code></td>
<td>

<p>A vector specifying the replicate for each column of the counts matrix when there is paired data; optional if data is unpaired.
</p>
</td></tr>
<tr><td><code id="SortData_+3A_sort.method">sort.method</code></td>
<td>

<p>Character vector specifying one of &quot;unpaired&quot; or &quot;paired&quot;, depending on the structure of the data.
</p>
</td></tr>
<tr><td><code id="SortData_+3A_norm.factors">norm.factors</code></td>
<td>

<p>An optional positive numeric vector of multiplicative normalization factors for each column of the counts matrix. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing:
</p>
<table role = "presentation">
<tr><td><code>counts</code></td>
<td>
<p>sorted and trimmed matrix of counts.</p>
</td></tr>
<tr><td><code>replic</code></td>
<td>
<p>sorted and trimmed replic vector.</p>
</td></tr>
<tr><td><code>treatment</code></td>
<td>
<p>sorted and trimmed treatment vector.</p>
</td></tr>
<tr><td><code>norm.factors</code></td>
<td>
<p>sorted and trimmed offset vector.</p>
</td></tr>
<tr><td><code>sorting</code></td>
<td>
<p>sorting vector used to sort and trim.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Samuel Benidt &lt;sgbenidt@gmail.com&gt;
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
