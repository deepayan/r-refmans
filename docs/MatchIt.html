<!DOCTYPE html><html><head><title>Help for package MatchIt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MatchIt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MatchIt-package'><p>MatchIt: Nonparametric Preprocessing for Parametric Causal Inference</p></a></li>
<li><a href='#add_s.weights'><p>Add sampling weights to a <code>matchit</code> object</p></a></li>
<li><a href='#distance'><p>Propensity scores and other distance measures</p></a></li>
<li><a href='#lalonde'><p>Data from National Supported Work Demonstration and PSID, as analyzed by</p>
Dehejia and Wahba (1999).</a></li>
<li><a href='#mahalanobis_dist'><p>Compute a Distance Matrix</p></a></li>
<li><a href='#match.data'><p>Construct a matched dataset from a <code>matchit</code> object</p></a></li>
<li><a href='#matchit'><p>Matching for Causal Inference</p></a></li>
<li><a href='#method_cardinality'><p>Cardinality Matching</p></a></li>
<li><a href='#method_cem'><p>Coarsened Exact Matching</p></a></li>
<li><a href='#method_exact'><p>Exact Matching</p></a></li>
<li><a href='#method_full'><p>Optimal Full Matching</p></a></li>
<li><a href='#method_genetic'><p>Genetic Matching</p></a></li>
<li><a href='#method_nearest'><p>Nearest Neighbor Matching</p></a></li>
<li><a href='#method_optimal'><p>Optimal Pair Matching</p></a></li>
<li><a href='#method_quick'><p>Fast Generalized Full Matching</p></a></li>
<li><a href='#method_subclass'><p>Subclassification</p></a></li>
<li><a href='#plot.matchit'><p>Generate Balance Plots after Matching and Subclassification</p></a></li>
<li><a href='#plot.summary.matchit'><p>Generate a Love Plot of Standardized Mean Differences</p></a></li>
<li><a href='#rbind.matchdata'><p>Append matched datasets together</p></a></li>
<li><a href='#summary.matchit'><p>View a balance summary of a <code>matchit</code> object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>4.5.5</td>
</tr>
<tr>
<td>Title:</td>
<td>Nonparametric Preprocessing for Parametric Causal Inference</td>
</tr>
<tr>
<td>Description:</td>
<td>Selects matched samples of the original treated and
    control groups with similar covariate distributions &ndash; can be
    used to match exactly on covariates, to match on propensity
    scores, or perform a variety of other matching procedures.  The
    package also implements a series of recommendations offered in
    Ho, Imai, King, and Stuart (2007) &lt;<a href="https://doi.org/10.1093%2Fpan%2Fmpl013">doi:10.1093/pan/mpl013</a>&gt;. (The 
    'gurobi' package, which is not on CRAN, is optional and comes with 
    an installation of the Gurobi Optimizer, available at 
    <a href="https://www.gurobi.com">https://www.gurobi.com</a>.)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>backports (&ge; 1.1.9), chk (&ge; 0.8.1), rlang (&ge; 1.1.0), Rcpp,
utils, stats, graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>optmatch (&ge; 0.10.6), Matching, rgenoud, quickmatch (&ge;
0.2.1), nnet, rpart, mgcv, CBPS (&ge; 0.17), dbarts, randomForest
(&ge; 4.7-1), glmnet (&ge; 4.0), gbm (&ge; 2.1.7), cobalt (&ge; 4.2.3),
boot, marginaleffects (&ge; 0.11.0), sandwich (&ge; 2.5-1),
survival, RcppProgress (&ge; 0.4.2), highs, Rglpk, Rsymphony,
gurobi, knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppProgress</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://kosukeimai.github.io/MatchIt/">https://kosukeimai.github.io/MatchIt/</a>,
<a href="https://github.com/kosukeimai/MatchIt">https://github.com/kosukeimai/MatchIt</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kosukeimai/MatchIt/issues">https://github.com/kosukeimai/MatchIt/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-12 22:26:23 UTC; NoahGreifer</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Ho <a href="https://orcid.org/0000-0002-2195-5469"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Kosuke Imai <a href="https://orcid.org/0000-0002-2748-1022"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Gary King <a href="https://orcid.org/0000-0002-5327-7631"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Elizabeth Stuart <a href="https://orcid.org/0000-0002-9042-8611"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Alex Whitworth [ctb],
  Noah Greifer <a href="https://orcid.org/0000-0003-3067-7154"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Noah Greifer &lt;noah.greifer@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-13 06:40:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='MatchIt-package'>MatchIt: Nonparametric Preprocessing for Parametric Causal Inference</h2><span id='topic+MatchIt'></span><span id='topic+MatchIt-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Selects matched samples of the original treated and control groups with similar covariate distributions &ndash; can be used to match exactly on covariates, to match on propensity scores, or perform a variety of other matching procedures. The package also implements a series of recommendations offered in Ho, Imai, King, and Stuart (2007) <a href="https://doi.org/10.1093/pan/mpl013">doi:10.1093/pan/mpl013</a>. (The 'gurobi' package, which is not on CRAN, is optional and comes with an installation of the Gurobi Optimizer, available at <a href="https://www.gurobi.com">https://www.gurobi.com</a>.)
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Noah Greifer <a href="mailto:noah.greifer@gmail.com">noah.greifer@gmail.com</a> (<a href="https://orcid.org/0000-0003-3067-7154">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Daniel Ho <a href="mailto:daniel.e.ho@gmail.com">daniel.e.ho@gmail.com</a> (<a href="https://orcid.org/0000-0002-2195-5469">ORCID</a>)
</p>
</li>
<li><p> Kosuke Imai <a href="mailto:imai@harvard.edu">imai@harvard.edu</a> (<a href="https://orcid.org/0000-0002-2748-1022">ORCID</a>)
</p>
</li>
<li><p> Gary King <a href="mailto:king@harvard.edu">king@harvard.edu</a> (<a href="https://orcid.org/0000-0002-5327-7631">ORCID</a>)
</p>
</li>
<li><p> Elizabeth Stuart <a href="mailto:estuart@jhu.edu">estuart@jhu.edu</a> (<a href="https://orcid.org/0000-0002-9042-8611">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Alex Whitworth <a href="mailto:whitworth.alex@gmail.com">whitworth.alex@gmail.com</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://kosukeimai.github.io/MatchIt/">https://kosukeimai.github.io/MatchIt/</a>
</p>
</li>
<li> <p><a href="https://github.com/kosukeimai/MatchIt">https://github.com/kosukeimai/MatchIt</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/kosukeimai/MatchIt/issues">https://github.com/kosukeimai/MatchIt/issues</a>
</p>
</li></ul>


<hr>
<h2 id='add_s.weights'>Add sampling weights to a <code>matchit</code> object</h2><span id='topic+add_s.weights'></span>

<h3>Description</h3>

<p>Adds sampling weights to a <code>matchit</code> object so that they are
incorporated into balance assessment and creation of the weights. This would
typically only be used when an argument to <code>s.weights</code> was not supplied
to <code><a href="#topic+matchit">matchit()</a></code> (i.e., because they were not to be included in the estimation
of the propensity score) but sampling weights are required for generalizing
an effect to the correct population. Without adding sampling weights to the
<code>matchit</code> object, balance assessment tools (i.e., <code><a href="#topic+summary.matchit">summary.matchit()</a></code>
and <code><a href="#topic+plot.matchit">plot.matchit()</a></code>) will not calculate balance statistics correctly, and
the weights produced by <code><a href="#topic+match.data">match.data()</a></code> and <code><a href="#topic+get_matches">get_matches()</a></code> will not
incorporate the sampling weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_s.weights(m, s.weights = NULL, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_s.weights_+3A_m">m</code></td>
<td>
<p>a <code>matchit</code> object; the output of a call to <code><a href="#topic+matchit">matchit()</a></code>,
typically with the <code>s.weights</code> argument unspecified.</p>
</td></tr>
<tr><td><code id="add_s.weights_+3A_s.weights">s.weights</code></td>
<td>
<p>an numeric vector of sampling weights to be added to the
<code>matchit</code> object. Can also be specified as a string containing the name
of variable in <code>data</code> to be used or a one-sided formula with the
variable on the right-hand side (e.g., <code>~ SW</code>).</p>
</td></tr>
<tr><td><code id="add_s.weights_+3A_data">data</code></td>
<td>
<p>a data frame containing the sampling weights if given as a
string or formula. If unspecified, <code>add_s.weights()</code> will attempt to find
the dataset using the environment of the <code>matchit</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>matchit</code> object with an <code>s.weights</code> component
containing the supplied sampling weights. If <code>s.weights = NULL</code>, the original
<code>matchit</code> object is returned.
</p>


<h3>Author(s)</h3>

<p>Noah Greifer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matchit">matchit()</a></code>; <code><a href="#topic+match.data">match.data()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde")

# Generate random sampling weights, just
# for this example
sw &lt;- rchisq(nrow(lalonde), 2)

# NN PS match using logistic regression PS that doesn't
# include sampling weights
m.out &lt;- matchit(treat ~ age + educ + race + nodegree +
                   married  + re74 + re75, data = lalonde)

m.out

# Add s.weights to the matchit object
m.out &lt;- add_s.weights(m.out, sw)

m.out #note additional output

# Check balance; note that sample sizes incorporate
# s.weights
summary(m.out, improvement = FALSE)

</code></pre>

<hr>
<h2 id='distance'>Propensity scores and other distance measures</h2><span id='topic+distance'></span>

<h3>Description</h3>

<p>Several matching methods require or can involve the distance between treated
and control units. Options include the Mahalanobis distance, propensity
score distance, or distance between user-supplied values. Propensity scores
are also used for common support via the <code>discard</code> options and for
defining calipers. This page documents the options that can be supplied to
the <code>distance</code> argument to <code><a href="#topic+matchit">matchit()</a></code>.
</p>


<h3>Allowable options</h3>

<p>There are four ways to specify the <code>distance</code> argument: 1) as a string containing the name of a method for
estimating propensity scores, 2) as a string containing the name of a method
for computing pairwise distances from the covariates, 3) as a vector of
values whose pairwise differences define the distance between units, or 4)
as a distance matrix containing all pairwise distances. The options are
detailed below.
</p>


<h4>Propensity score estimation methods</h4>

<p>When <code>distance</code> is specified as the name of a method for estimating propensity scores
(described below), a propensity score is estimated using the variables in
<code>formula</code> and the method corresponding to the given argument. This
propensity score can be used to compute the distance between units as the
absolute difference between the propensity scores of pairs of units.
Propensity scores can also be used to create calipers and common support
restrictions, whether or not they are used in the actual distance measure
used in the matching, if any.
</p>
<p>In addition to the <code>distance</code> argument, two other arguments can be
specified that relate to the estimation and manipulation of the propensity
scores. The <code>link</code> argument allows for different links to be used in
models that require them such as generalized linear models, for which the
logit and probit links are allowed, among others. In addition to specifying
the link, the <code>link</code> argument can be used to specify whether the
propensity score or the linearized version of the propensity score should be
used; by specifying <code>link = "linear.{link}"</code>, the linearized version
will be used.
</p>
<p>The <code>distance.options</code> argument can also be specified, which should be
a list of values passed to the propensity score-estimating function, for
example, to choose specific options or tuning parameters for the estimation
method. If <code>formula</code>, <code>data</code>, or <code>verbose</code> are not supplied
to <code>distance.options</code>, the corresponding arguments from
<code>matchit()</code> will be automatically supplied. See the Examples for
demonstrations of the uses of <code>link</code> and <code>distance.options</code>. When
<code>s.weights</code> is supplied in the call to <code>matchit()</code>, it will
automatically be passed to the propensity score-estimating function as the
<code>weights</code> argument unless otherwise described below.
</p>
<p>The following methods for estimating propensity scores are allowed:
</p>

<dl>
<dt><code>"glm"</code></dt><dd><p> The propensity scores are estimated using
a generalized linear model (e.g., logistic regression). The <code>formula</code>
supplied to <code>matchit()</code> is passed directly to <code><a href="stats.html#topic+glm">glm()</a></code>, and
<code><a href="stats.html#topic+predict.glm">predict.glm()</a></code> is used to compute the propensity scores. The <code>link</code>
argument can be specified as a link function supplied to <code><a href="stats.html#topic+binomial">binomial()</a></code>, e.g.,
<code>"logit"</code>, which is the default. When <code>link</code> is prepended by
<code>"linear."</code>, the linear predictor is used instead of the predicted
probabilities. <code>distance = "glm"</code> with <code>link = "logit"</code> (logistic
regression) is the default in <code>matchit()</code>. (This used to be able to be requested as <code>distance = "ps"</code>, which still works.)</p>
</dd>
<dt><code>"gam"</code></dt><dd>
<p>The propensity scores are estimated using a generalized additive model. The
<code>formula</code> supplied to <code>matchit()</code> is passed directly to
<code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>, and <code><a href="mgcv.html#topic+predict.gam">mgcv::predict.gam()</a></code> is used to compute the propensity
scores. The <code>link</code> argument can be specified as a link function
supplied to <code><a href="stats.html#topic+binomial">binomial()</a></code>, e.g., <code>"logit"</code>, which is the default. When
<code>link</code> is prepended by <code>"linear."</code>, the linear predictor is used
instead of the predicted probabilities. Note that unless the smoothing
functions <code><a href="mgcv.html#topic+s">mgcv::s()</a></code>, <code><a href="mgcv.html#topic+te">mgcv::te()</a></code>, <code><a href="mgcv.html#topic+ti">mgcv::ti()</a></code>, or <code><a href="mgcv.html#topic+t2">mgcv::t2()</a></code> are
used in <code>formula</code>, a generalized additive model is identical to a
generalized linear model and will estimate the same propensity scores as
<code>glm()</code>. See the documentation for <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>,
<code><a href="mgcv.html#topic+formula.gam">mgcv::formula.gam()</a></code>, and <code><a href="mgcv.html#topic+gam.models">mgcv::gam.models()</a></code> for more information on
how to specify these models. Also note that the formula returned in the
<code>matchit()</code> output object will be a simplified version of the supplied
formula with smoothing terms removed (but all named variables present). </p>
</dd>
<dt><code>"gbm"</code></dt><dd><p> The propensity scores are estimated using a
generalized boosted model. The <code>formula</code> supplied to <code>matchit()</code>
is passed directly to <code><a href="gbm.html#topic+gbm">gbm::gbm()</a></code>, and <code><a href="gbm.html#topic+predict.gbm">gbm::predict.gbm()</a></code> is used to
compute the propensity scores. The optimal tree is chosen using 5-fold
cross-validation by default, and this can be changed by supplying an
argument to <code>method</code> to <code>distance.options</code>; see <code><a href="gbm.html#topic+gbm.perf">gbm::gbm.perf()</a></code>
for details. The <code>link</code> argument can be specified as <code>"linear"</code> to
use the linear predictor instead of the predicted probabilities. No other
links are allowed. The tuning parameter defaults differ from
<code>gbm::gbm()</code>; they are as follows: <code>n.trees = 1e4</code>,
<code>interaction.depth = 3</code>, <code>shrinkage = .01</code>, <code>bag.fraction = 1</code>, <code>cv.folds = 5</code>, <code>keep.data = FALSE</code>. These are the same
defaults as used in <em>WeightIt</em> and <em>twang</em>, except for
<code>cv.folds</code> and <code>keep.data</code>. Note this is not the same use of
generalized boosted modeling as in <em>twang</em>; here, the number of trees is
chosen based on cross-validation or out-of-bag error, rather than based on
optimizing balance. <span class="pkg">twang</span> should not be cited when using this method
to estimate propensity scores. </p>
</dd>
<dt><code>"lasso"</code>, <code>"ridge"</code>, <code>"elasticnet"</code></dt><dd><p> The propensity
scores are estimated using a lasso, ridge, or elastic net model,
respectively. The <code>formula</code> supplied to <code>matchit()</code> is processed
with <code><a href="stats.html#topic+model.matrix">model.matrix()</a></code> and passed to <code><a href="glmnet.html#topic+cv.glmnet">glmnet::cv.glmnet()</a></code>, and
<code><a href="glmnet.html#topic+predict.cv.glmnet">glmnet::predict.cv.glmnet()</a></code> is used to compute the propensity scores. The
<code>link</code> argument can be specified as a link function supplied to
<code><a href="stats.html#topic+binomial">binomial()</a></code>, e.g., <code>"logit"</code>, which is the default. When <code>link</code>
is prepended by <code>"linear."</code>, the linear predictor is used instead of
the predicted probabilities. When <code>link = "log"</code>, a Poisson model is
used. For <code>distance = "elasticnet"</code>, the <code>alpha</code> argument, which
controls how to prioritize the lasso and ridge penalties in the elastic net,
is set to .5 by default and can be changed by supplying an argument to
<code>alpha</code> in <code>distance.options</code>. For <code>"lasso"</code> and
<code>"ridge"</code>, <code>alpha</code> is set to 1 and 0, respectively, and cannot be
changed. The <code>cv.glmnet()</code> defaults are used to select the tuning
parameters and generate predictions and can be modified using
<code>distance.options</code>. If the <code>s</code> argument is passed to
<code>distance.options</code>, it will be passed to <code>predict.cv.glmnet()</code>.
Note that because there is a random component to choosing the tuning
parameter, results will vary across runs unless a <a href="base.html#topic+set.seed">seed</a> is
set. </p>
</dd>
<dt><code>"rpart"</code></dt><dd><p> The propensity scores are estimated using a
classification tree. The <code>formula</code> supplied to <code>matchit()</code> is
passed directly to <code><a href="rpart.html#topic+rpart">rpart::rpart()</a></code>, and <code><a href="rpart.html#topic+predict.rpart">rpart::predict.rpart()</a></code> is used
to compute the propensity scores. The <code>link</code> argument is ignored, and
predicted probabilities are always returned as the distance measure. </p>
</dd>
<dt><code>"randomforest"</code></dt><dd><p> The propensity scores are estimated using a
random forest. The <code>formula</code> supplied to <code>matchit()</code> is passed
directly to <code><a href="randomForest.html#topic+randomForest">randomForest::randomForest()</a></code>, and
<code><a href="randomForest.html#topic+predict.randomForest">randomForest::predict.randomForest()</a></code> is used to compute the propensity
scores. The <code>link</code> argument is ignored, and predicted probabilities are
always returned as the distance measure.</p>
</dd>
<dt><code>"nnet"</code></dt><dd><p> The
propensity scores are estimated using a single-hidden-layer neural network.
The <code>formula</code> supplied to <code>matchit()</code> is passed directly to
<code><a href="nnet.html#topic+nnet">nnet::nnet()</a></code>, and <code><a href="stats.html#topic+fitted">fitted()</a></code> is used to compute the propensity scores.
The <code>link</code> argument is ignored, and predicted probabilities are always
returned as the distance measure. An argument to <code>size</code> must be
supplied to <code>distance.options</code> when using <code>method = "nnet"</code>. </p>
</dd>
<dt><code>"cbps"</code></dt><dd><p> The propensity scores are estimated using the
covariate balancing propensity score (CBPS) algorithm, which is a form of
logistic regression where balance constraints are incorporated to a
generalized method of moments estimation of of the model coefficients. The
<code>formula</code> supplied to <code>matchit()</code> is passed directly to
<code><a href="CBPS.html#topic+CBPS">CBPS::CBPS()</a></code>, and <code><a href="stats.html#topic+fitted">fitted()</a></code> is used to compute the propensity
scores. The <code>link</code> argument can be specified as <code>"linear"</code> to use
the linear predictor instead of the predicted probabilities. No other links
are allowed. The <code>estimand</code> argument supplied to <code>matchit()</code> will
be used to select the appropriate estimand for use in defining the balance
constraints, so no argument needs to be supplied to <code>ATT</code> in
<code>CBPS</code>. </p>
</dd>
<dt><code>"bart"</code></dt><dd><p> The propensity scores are estimated
using Bayesian additive regression trees (BART). The <code>formula</code> supplied
to <code>matchit()</code> is passed directly to <code><a href="dbarts.html#topic+bart2">dbarts::bart2()</a></code>,
and <code><a href="dbarts.html#topic+fitted.bart">dbarts::fitted.bart()</a></code> is used to compute the propensity
scores. The <code>link</code> argument can be specified as <code>"linear"</code> to use
the linear predictor instead of the predicted probabilities. When
<code>s.weights</code> is supplied to <code>matchit()</code>, it will not be passed to
<code>bart2</code> because the <code>weights</code> argument in <code>bart2</code> does not
correspond to sampling weights. </p>
</dd>
</dl>




<h4>Methods for computing distances from covariates</h4>

<p>The following methods involve computing a distance matrix from the covariates themselves
without estimating a propensity score. Calipers on the distance measure and
common support restrictions cannot be used, and the <code>distance</code>
component of the output object will be empty because no propensity scores
are estimated. The <code>link</code> and <code>distance.options</code> arguments are
ignored with these methods. See the individual matching methods pages for
whether these distances are allowed and how they are used. Each of these
distance measures can also be calculated outside <code>matchit()</code> using its
<a href="#topic+euclidean_dist">corresponding function</a>.
</p>

<dl>
<dt><code>"euclidean"</code></dt><dd><p> The Euclidean distance is the raw
distance between units, computed as </p>
<p style="text-align: center;"><code class="reqn">d_{ij} = \sqrt{(x_i - x_j)(x_i -
x_j)'}</code>
</p>
<p> It is sensitive to the scale of the covariates, so covariates with
larger scales will take higher priority. </p>
</dd>
<dt><code>"scaled_euclidean"</code></dt><dd><p> The scaled Euclidean distance is the
Euclidean distance computed on the scaled (i.e., standardized) covariates.
This ensures the covariates are on the same scale. The covariates are
standardized using the pooled within-group standard deviations, computed by
treatment group-mean centering each covariate before computing the standard
deviation in the full sample. </p>
</dd>
<dt><code>"mahalanobis"</code></dt><dd><p> The
Mahalanobis distance is computed as </p>
<p style="text-align: center;"><code class="reqn">d_{ij} = \sqrt{(x_i -
x_j)\Sigma^{-1}(x_i - x_j)'}</code>
</p>
<p> where <code class="reqn">\Sigma</code> is the pooled within-group
covariance matrix of the covariates, computed by treatment group-mean
centering each covariate before computing the covariance in the full sample.
This ensures the variables are on the same scale and accounts for the
correlation between covariates. </p>
</dd>
<dt><code>"robust_mahalanobis"</code></dt><dd><p> The
robust rank-based Mahalanobis distance is the Mahalanobis distance computed
on the ranks of the covariates with an adjustment for ties. It is described
in Rosenbaum (2010, ch. 8) as an alternative to the Mahalanobis distance
that handles outliers and rare categories better than the standard
Mahalanobis distance but is not affinely invariant. </p>
</dd>
</dl>

<p>To perform Mahalanobis distance matching <em>and</em> estimate propensity
scores to be used for a purpose other than matching, the <code>mahvars</code>
argument should be used along with a different specification to
<code>distance</code>. See the individual matching method pages for details on how
to use <code>mahvars</code>.
</p>



<h4>Distances supplied as a numeric vector or matrix</h4>

<p><code>distance</code> can also be supplied as a numeric vector whose values will be taken to
function like propensity scores; their pairwise difference will define the
distance between units. This might be useful for supplying propensity scores
computed outside <code>matchit()</code> or resupplying <code>matchit()</code> with
propensity scores estimated previously without having to recompute them.
</p>
<p><code>distance</code> can also be supplied as a matrix whose values represent the
pairwise distances between units. The matrix should either be a square, with
a row and column for each unit (e.g., as the output of a call to
<code style="white-space: pre;">&#8288;as.matrix(&#8288;</code><code><a href="stats.html#topic+dist">dist</a></code><code style="white-space: pre;">&#8288;(.))&#8288;</code>), or have as many rows as there are treated
units and as many columns as there are control units (e.g., as the output of
a call to <code><a href="#topic+mahalanobis_dist">mahalanobis_dist()</a></code> or <code><a href="optmatch.html#topic+match_on">optmatch::match_on()</a></code>). Distance values
of <code>Inf</code> will disallow the corresponding units to be matched. When
<code>distance</code> is a supplied as a numeric vector or matrix, <code>link</code> and
<code>distance.options</code> are ignored.
</p>



<h3>Note</h3>

<p>In versions of <em>MatchIt</em> prior to 4.0.0, <code>distance</code> was
specified in a slightly different way. When specifying arguments using the
old syntax, they will automatically be converted to the corresponding method
in the new syntax but a warning will be thrown. <code>distance = "logit"</code>,
the old default, will still work in the new syntax, though <code style="white-space: pre;">&#8288;distance = "glm", link = "logit"&#8288;</code> is preferred (note that these are the default
settings and don't need to be made explicit).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("lalonde")

# Linearized probit regression PS:
m.out1 &lt;- matchit(treat ~ age + educ + race + married +
                    nodegree + re74 + re75, data = lalonde,
                  distance = "glm", link = "linear.probit")

# GAM logistic PS with smoothing splines (s()):
m.out2 &lt;- matchit(treat ~ s(age) + s(educ) + race + married +
                    nodegree + re74 + re75, data = lalonde,
                  distance = "gam")
summary(m.out2$model)


# CBPS for ATC matching w/replacement, using the just-
# identified version of CBPS (setting method = "exact"):
m.out3 &lt;- matchit(treat ~ age + educ + race + married +
                    nodegree + re74 + re75, data = lalonde,
                  distance = "cbps", estimand = "ATC",
                  distance.options = list(method = "exact"),
                  replace = TRUE)

# Mahalanobis distance matching - no PS estimated
m.out4 &lt;- matchit(treat ~ age + educ + race + married +
                    nodegree + re74 + re75, data = lalonde,
                  distance = "mahalanobis")

m.out4$distance #NULL

# Mahalanobis distance matching with PS estimated
# for use in a caliper; matching done on mahvars
m.out5 &lt;- matchit(treat ~ age + educ + race + married +
                    nodegree + re74 + re75, data = lalonde,
                  distance = "glm", caliper = .1,
                  mahvars = ~ age + educ + race + married +
                                nodegree + re74 + re75)

summary(m.out5)

# User-supplied propensity scores
p.score &lt;- fitted(glm(treat ~ age + educ + race + married +
                        nodegree + re74 + re75, data = lalonde,
                      family = binomial))

m.out6 &lt;- matchit(treat ~ age + educ + race + married +
                    nodegree + re74 + re75, data = lalonde,
                  distance = p.score)

# User-supplied distance matrix using optmatch::match_on()

dist_mat &lt;- optmatch::match_on(
              treat ~ age + educ + race + nodegree +
                married + re74 + re75, data = lalonde,
              method = "rank_mahalanobis")

m.out7 &lt;- matchit(treat ~ age + educ + race + nodegree +
                    married + re74 + re75, data = lalonde,
                  distance = dist_mat)

</code></pre>

<hr>
<h2 id='lalonde'>Data from National Supported Work Demonstration and PSID, as analyzed by
Dehejia and Wahba (1999).</h2><span id='topic+lalonde'></span>

<h3>Description</h3>

<p>This is a subsample of the data from the treated group in the National
Supported Work Demonstration (NSW) and the comparison sample from the
Population Survey of Income Dynamics (PSID). This data was previously
analyzed extensively by Lalonde (1986) and Dehejia and Wahba (1999).
</p>


<h3>Format</h3>

<p>A data frame with 614 observations (185 treated, 429 control).
There are 9 variables measured for each individual.
</p>

<ul>
<li><p> &quot;treat&quot;
is the treatment assignment (1=treated, 0=control).
</p>
</li>
<li><p> &quot;age&quot; is age in years.
</p>
</li>
<li><p> &quot;educ&quot; is education in number of years of schooling.
</p>
</li>
<li><p> &quot;race&quot; is the individual's race/ethnicity, (Black, Hispanic, or White). Note
previous versions of this dataset used indicator variables <code>black</code> and
<code>hispan</code> instead of a single race variable.
</p>
</li>
<li><p> &quot;married&quot; is an
indicator for married (1=married, 0=not married).
</p>
</li>
<li><p> &quot;nodegree&quot; is an
indicator for whether the individual has a high school degree (1=no degree,
0=degree).
</p>
</li>
<li><p> &quot;re74&quot; is income in 1974, in U.S. dollars.
</p>
</li>
<li><p> &quot;re75&quot; is
income in 1975, in U.S. dollars.
</p>
</li>
<li><p> &quot;re78&quot; is income in 1978, in U.S.
dollars. </p>
</li></ul>

<p>&quot;treat&quot; is the treatment variable, &quot;re78&quot; is the outcome, and the
others are pre-treatment covariates.
</p>


<h3>References</h3>

<p>Lalonde, R. (1986). Evaluating the econometric evaluations of
training programs with experimental data. <em>American Economic Review</em> 76:
604-620.
</p>
<p>Dehejia, R.H. and Wahba, S. (1999).  Causal Effects in Nonexperimental
Studies: Re-Evaluating the Evaluation of Training Programs.  <em>Journal of the
American Statistical Association</em> 94: 1053-1062.
</p>

<hr>
<h2 id='mahalanobis_dist'>Compute a Distance Matrix</h2><span id='topic+mahalanobis_dist'></span><span id='topic+euclidean_dist'></span><span id='topic+scaled_euclidean_dist'></span><span id='topic+robust_mahalanobis_dist'></span>

<h3>Description</h3>

<p>The functions compute a distance matrix, either for a single dataset (i.e.,
the distances between all pairs of units) or for two groups defined by a
splitting variable (i.e., the distances between all units in one group and
all units in the other). These distance matrices include the Mahalanobis
distance, Euclidean distance, scaled Euclidean distance, and robust
(rank-based) Mahalanobis distance. These functions can be used as inputs to
the <code>distance</code> argument to <code><a href="#topic+matchit">matchit()</a></code> and are used to compute the
corresponding distance matrices within <code>matchit()</code> when named.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mahalanobis_dist(
  formula = NULL,
  data = NULL,
  s.weights = NULL,
  var = NULL,
  discarded = NULL,
  ...
)

scaled_euclidean_dist(
  formula = NULL,
  data = NULL,
  s.weights = NULL,
  var = NULL,
  discarded = NULL,
  ...
)

robust_mahalanobis_dist(
  formula = NULL,
  data = NULL,
  s.weights = NULL,
  discarded = NULL,
  ...
)

euclidean_dist(formula = NULL, data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mahalanobis_dist_+3A_formula">formula</code></td>
<td>
<p>a formula with the treatment (i.e., splitting variable) on
the left side and the covariates used to compute the distance matrix on the
right side. If there is no left-hand-side variable, the distances will be
computed between all pairs of units. If <code>NULL</code>, all the variables in
<code>data</code> will be used as covariates.</p>
</td></tr>
<tr><td><code id="mahalanobis_dist_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables named in <code>formula</code>.
If <code>formula</code> is <code>NULL</code>, all variables in <code>data</code> will be used
as covariates.</p>
</td></tr>
<tr><td><code id="mahalanobis_dist_+3A_s.weights">s.weights</code></td>
<td>
<p>when <code>var = NULL</code>, an optional vector of sampling
weights used to compute the variances used in the Mahalanobis, scaled
Euclidean, and robust Mahalanobis distances.</p>
</td></tr>
<tr><td><code id="mahalanobis_dist_+3A_var">var</code></td>
<td>
<p>for <code>mahalanobis_dist()</code>, a covariance matrix used to scale
the covariates. For <code>scaled_euclidean_dist()</code>, either a covariance
matrix (from which only the diagonal elements will be used) or a vector of
variances used to scale the covariates. If <code>NULL</code>, these values will be
calculated using formulas described in Details.</p>
</td></tr>
<tr><td><code id="mahalanobis_dist_+3A_discarded">discarded</code></td>
<td>
<p>a <code>logical</code> vector denoting which units are to be
discarded or not. This is used only when <code>var = NULL</code>. The scaling
factors will be computed only using the non-discarded units, but the
distance matrix will be computed for all units (discarded and
non-discarded).</p>
</td></tr>
<tr><td><code id="mahalanobis_dist_+3A_...">...</code></td>
<td>
<p>ignored. Included to make cycling through these functions
easier without having to change the arguments supplied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <strong>Euclidean distance</strong> (computed using <code>euclidean_dist()</code>) is
the raw distance between units, computed as </p>
<p style="text-align: center;"><code class="reqn">d_{ij} = \sqrt{(x_i -
x_j)(x_i - x_j)'}</code>
</p>
<p> where <code class="reqn">x_i</code> and <code class="reqn">x_j</code> are vectors of covariates
for units <code class="reqn">i</code> and <code class="reqn">j</code>, respectively. The Euclidean distance is
sensitive to the scales of the variables and their redundancy (i.e.,
correlation). It should probably not be used for matching unless all of the
variables have been previously scaled appropriately or are already on the
same scale. It forms the basis of the other distance measures.
</p>
<p>The <strong>scaled Euclidean distance</strong> (computed using
<code>scaled_euclidean_dist()</code>) is the Euclidean distance computed on the
scaled covariates. Typically the covariates are scaled by dividing by their
standard deviations, but any scaling factor can be supplied using the
<code>var</code> argument. This leads to a distance measure computed as
</p>
<p style="text-align: center;"><code class="reqn">d_{ij} = \sqrt{(x_i - x_j)S_d^{-1}(x_i - x_j)'}</code>
</p>
<p> where <code class="reqn">S_d</code> is a
diagonal matrix with the squared scaling factors on the diagonal. Although
this measure is not sensitive to the scales of the variables (because they
are all placed on the same scale), it is still sensitive to redundancy among
the variables. For example, if 5 variables measure approximately the same
construct (i.e., are highly correlated) and 1 variable measures another
construct, the first construct will have 5 times as much influence on the
distance between units as the second construct. The Mahalanobis distance
attempts to address this issue.
</p>
<p>The <strong>Mahalanobis distance</strong> (computed using <code>mahalanobis_dist()</code>)
is computed as </p>
<p style="text-align: center;"><code class="reqn">d_{ij} = \sqrt{(x_i - x_j)S^{-1}(x_i - x_j)'}</code>
</p>
<p> where
<code class="reqn">S</code> is a scaling matrix, typically the covariance matrix of the
covariates. It is essentially equivalent to the Euclidean distance computed
on the scaled principal components of the covariates. This is the most
popular distance matrix for matching because it is not sensitive to the
scale of the covariates and accounts for redundancy between them. The
scaling matrix can also be supplied using the <code>var</code> argument.
</p>
<p>The Mahalanobis distance can be sensitive to outliers and long-tailed or
otherwise non-normally distributed covariates and may not perform well with
categorical variables due to prioritizing rare categories over common ones.
One solution is the rank-based <strong>robust Mahalanobis distance</strong>
(computed using <code>robust_mahalanobis_dist()</code>), which is computed by
first replacing the covariates with their ranks (using average ranks for
ties) and rescaling each ranked covariate by a constant scaling factor
before computing the usual Mahalanobis distance on the rescaled ranks.
</p>
<p>The Mahalanobis distance and its robust variant are computed internally by
transforming the covariates in such a way that the Euclidean distance
computed on the scaled covariates is equal to the requested distance. For
the Mahalanobis distance, this involves replacing the covariates vector
<code class="reqn">x_i</code> with <code class="reqn">x_iS^{-.5}</code>, where <code class="reqn">S^{-.5}</code> is the Cholesky
decomposition of the (generalized) inverse of the covariance matrix <code class="reqn">S</code>.
</p>
<p>When a left-hand-side splitting variable is present in <code>formula</code> and
<code>var = NULL</code> (i.e., so that the scaling matrix is computed internally),
the covariance matrix used is the &quot;pooled&quot; covariance matrix, which
essentially is a weighted average of the covariance matrices computed
separately within each level of the splitting variable to capture
within-group variation and reduce sensitivity to covariate imbalance. This
is also true of the scaling factors used in the scaled Euclidean distance.
</p>


<h3>Value</h3>

<p>A numeric distance matrix. When <code>formula</code> has a left-hand-side
(treatment) variable, the matrix will have one row for each treated unit and
one column for each control unit. Otherwise, the matrix will have one row
and one column for each unit.
</p>


<h3>Author(s)</h3>

<p>Noah Greifer
</p>


<h3>References</h3>

<p>Rosenbaum, P. R. (2010). <em>Design of observational studies</em>.
Springer.
</p>
<p>Rosenbaum, P. R., &amp; Rubin, D. B. (1985). Constructing a Control Group Using
Multivariate Matched Sampling Methods That Incorporate the Propensity Score.
<em>The American Statistician</em>, 39(1), 33–38. <a href="https://doi.org/10.2307/2683903">doi:10.2307/2683903</a>
</p>
<p>Rubin, D. B. (1980). Bias Reduction Using Mahalanobis-Metric Matching.
<em>Biometrics</em>, 36(2), 293–298. <a href="https://doi.org/10.2307/2529981">doi:10.2307/2529981</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distance">distance</a></code>, <code><a href="#topic+matchit">matchit()</a></code>, <code><a href="stats.html#topic+dist">dist()</a></code> (which is used
internally to compute Euclidean distances)
</p>
<p><code><a href="optmatch.html#topic+match_on">optmatch::match_on()</a></code>, which provides similar functionality but with fewer
options and a focus on efficient storage of the output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde")

# Computing the scaled Euclidean distance between all units:
d &lt;- scaled_euclidean_dist(~ age + educ + race + married,
                           data = lalonde)

# Another interface using the data argument:
dat &lt;- subset(lalonde, select = c(age, educ, race, married))
d &lt;- scaled_euclidean_dist(data = dat)

# Computing the Mahalanobis distance between treated and
# control units:
d &lt;- mahalanobis_dist(treat ~ age + educ + race + married,
                      data = lalonde)

# Supplying a covariance matrix or vector of variances (note:
# a bit more complicated with factor variables)
dat &lt;- subset(lalonde, select = c(age, educ, married, re74))
vars &lt;- sapply(dat, var)

d &lt;- scaled_euclidean_dist(data = dat, var = vars)

# Same result:
d &lt;- scaled_euclidean_dist(data = dat, var = diag(vars))

# Discard units:
discard &lt;- sample(c(TRUE, FALSE), nrow(lalonde),
                  replace = TRUE, prob = c(.2, .8))

d &lt;- mahalanobis_dist(treat ~ age + educ + race + married,
                      data = lalonde, discarded = discard)
dim(d) #all units present in distance matrix
table(lalonde$treat)

</code></pre>

<hr>
<h2 id='match.data'>Construct a matched dataset from a <code>matchit</code> object</h2><span id='topic+match.data'></span><span id='topic+get_matches'></span>

<h3>Description</h3>

<p><code>match.data()</code> and <code>get_matches()</code> create a data frame with
additional variables for the distance measure, matching weights, and
subclasses after matching. This dataset can be used to estimate treatment
effects after matching or subclassification. <code>get_matches()</code> is most
useful after matching with replacement; otherwise, <code>match.data()</code> is
more flexible. See Details below for the difference between them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match.data(
  object,
  group = "all",
  distance = "distance",
  weights = "weights",
  subclass = "subclass",
  data = NULL,
  include.s.weights = TRUE,
  drop.unmatched = TRUE
)

get_matches(
  object,
  distance = "distance",
  weights = "weights",
  subclass = "subclass",
  id = "id",
  data = NULL,
  include.s.weights = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match.data_+3A_object">object</code></td>
<td>
<p>a <code>matchit</code> object; the output of a call to <code><a href="#topic+matchit">matchit()</a></code>.</p>
</td></tr>
<tr><td><code id="match.data_+3A_group">group</code></td>
<td>
<p>which group should comprise the matched dataset: <code>"all"</code>
for all units, <code>"treated"</code> for just treated units, or <code>"control"</code>
for just control units. Default is <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="match.data_+3A_distance">distance</code></td>
<td>
<p>a string containing the name that should be given to the
variable containing the distance measure in the data frame output. Default
is <code>"distance"</code>, but <code>"prop.score"</code> or similar might be a good
alternative if propensity scores were used in matching. Ignored if a
distance measure was not supplied or estimated in the call to
<code>matchit()</code>.</p>
</td></tr>
<tr><td><code id="match.data_+3A_weights">weights</code></td>
<td>
<p>a string containing the name that should be given to the
variable containing the matching weights in the data frame output. Default
is <code>"weights"</code>.</p>
</td></tr>
<tr><td><code id="match.data_+3A_subclass">subclass</code></td>
<td>
<p>a string containing the name that should be given to the
variable containing the subclasses or matched pair membership in the data
frame output. Default is <code>"subclass"</code>.</p>
</td></tr>
<tr><td><code id="match.data_+3A_data">data</code></td>
<td>
<p>a data frame containing the original dataset to which the
computed output variables (<code>distance</code>, <code>weights</code>, and/or
<code>subclass</code>) should be appended. If empty, <code>match.data()</code> and
<code>get_matches()</code> will attempt to find the dataset using the environment
of the <code>matchit</code> object, which can be unreliable; see Notes.</p>
</td></tr>
<tr><td><code id="match.data_+3A_include.s.weights">include.s.weights</code></td>
<td>
<p><code>logical</code>; whether to multiply the estimated
weights by the sampling weights supplied to <code>matchit()</code>, if any.
Default is <code>TRUE</code>. If <code>FALSE</code>, the weights in the
<code>match.data()</code> or <code>get_matches()</code> output should be multiplied by
the sampling weights before being supplied to the function estimating the
treatment effect in the matched data.</p>
</td></tr>
<tr><td><code id="match.data_+3A_drop.unmatched">drop.unmatched</code></td>
<td>
<p><code>logical</code>; whether the returned data frame should
contain all units (<code>FALSE</code>) or only units that were matched (i.e., have
a matching weight greater than zero) (<code>TRUE</code>). Default is <code>TRUE</code>
to drop unmatched units.</p>
</td></tr>
<tr><td><code id="match.data_+3A_id">id</code></td>
<td>
<p>a string containing the name that should be given to the variable
containing the unit IDs in the data frame output. Default is <code>"id"</code>.
Only used with <code>get_matches()</code>; for <code>match.data()</code>, the units IDs
are stored in the row names of the returned data frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>match.data()</code> creates a dataset with one row per unit. It will be
identical to the dataset supplied except that several new columns will be
added containing information related to the matching. When
<code>drop.unmatched = TRUE</code>, the default, units with weights of zero, which
are those units that were discarded by common support or the caliper or were
simply not matched, will be dropped from the dataset, leaving only the
subset of matched units. The idea is for the output of <code>match.data()</code>
to be used as the dataset input in calls to <code>glm()</code> or similar to
estimate treatment effects in the matched sample. It is important to include
the weights in the estimation of the effect and its standard error. The
subclass column, when created, contains pair or subclass membership and
should be used to estimate the effect and its standard error. Subclasses
will only be included if there is a <code>subclass</code> component in the
<code>matchit</code> object, which does not occur with matching with replacement,
in which case <code>get_matches()</code> should be used. See
<code>vignette("estimating-effects")</code> for information on how to use
<code>match.data()</code> output to estimate effects.
</p>
<p><code>get_matches()</code> is similar to <code>match.data()</code>; the primary
difference occurs when matching is performed with replacement, i.e., when
units do not belong to a single matched pair. In this case, the output of
<code>get_matches()</code> will be a dataset that contains one row per unit for
each pair they are a part of. For example, if matching was performed with
replacement and a control unit was matched to two treated units, that
control unit will have two rows in the output dataset, one for each pair it
is a part of. Weights are computed for each row, and, for control units, are equal to the
inverse of the number of control units in each control unit's subclass; treated units get a weight of 1.
Unmatched units are dropped. An additional column with unit IDs will be
created (named using the <code>id</code> argument) to identify when the same unit
is present in multiple rows. This dataset structure allows for the inclusion
of both subclass membership and repeated use of units, unlike the output of
<code>match.data()</code>, which lacks subclass membership when matching is done
with replacement. A <code>match.matrix</code> component of the <code>matchit</code>
object must be present to use <code>get_matches()</code>; in some forms of
matching, it is absent, in which case <code>match.data()</code> should be used
instead. See <code>vignette("estimating-effects")</code> for information on how to
use <code>get_matches()</code> output to estimate effects after matching with
replacement.
</p>


<h3>Value</h3>

<p>A data frame containing the data supplied in the <code>data</code> argument or in the
original call to <code>matchit()</code> with the computed
output variables appended as additional columns, named according the
arguments above. For <code>match.data()</code>, the <code>group</code> and
<code>drop.unmatched</code> arguments control whether only subsets of the data are
returned. See Details above for how <code>match.data()</code> and
<code>get_matches()</code> differ. Note that <code>get_matches</code> sorts the data by
subclass and treatment status, unlike <code>match.data()</code>, which uses the
order of the data.
</p>
<p>The returned data frame will contain the variables in the original data set
or dataset supplied to <code>data</code> and the following columns:
</p>
<table>
<tr><td><code>distance</code></td>
<td>
<p>The propensity score, if estimated or supplied to the
<code>distance</code> argument in <code>matchit()</code> as a vector.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>The computed matching weights. These must be used in effect
estimation to correctly incorporate the matching.</p>
</td></tr>
<tr><td><code>subclass</code></td>
<td>
<p>Matching
strata membership. Units with the same value are in the same stratum.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>The ID of each unit, corresponding to the row names in the
original data or dataset supplied to <code>data</code>. Only included in
<code>get_matches</code> output. This column can be used to identify which rows
belong to the same unit since the same unit may appear multiple times if
reused in matching with replacement.</p>
</td></tr>
</table>
<p>These columns will take on the name supplied to the corresponding arguments
in the call to <code>match.data()</code> or <code>get_matches()</code>. See Examples for
an example of rename the <code>distance</code> column to <code>"prop.score"</code>.
</p>
<p>If <code>data</code> or the original dataset supplied to <code>matchit()</code> was a
<code>data.table</code> or <code>tbl</code>, the <code>match.data()</code> output will have
the same class, but the <code>get_matches()</code> output will always be a base R
<code>data.frame</code>.
</p>
<p>In addition to their base class (e.g., <code>data.frame</code> or <code>tbl</code>),
returned objects have the class <code>matchdata</code> or <code>getmatches</code>. This
class is important when using <code><a href="#topic+rbind.matchdata">rbind()</a></code> to
append matched datasets.
</p>


<h3>Note</h3>

<p>The most common way to use <code>match.data()</code> and
<code>get_matches()</code> is by supplying just the <code>matchit</code> object, e.g.,
as <code>match.data(m.out)</code>. A data set will first be searched in the
environment of the <code>matchit</code> formula, then in the calling environment
of <code>match.data()</code> or <code>get_matches()</code>, and finally in the
<code>model</code> component of the <code>matchit</code> object if a propensity score
was estimated.
</p>
<p>When called from an environment different from the one in which
<code>matchit()</code> was originally called and a propensity score was not
estimated (or was but with <code>discard</code> not <code>"none"</code> and
<code>reestimate = TRUE</code>), this syntax may not work because the original
dataset used to construct the matched dataset will not be found. This can
occur when <code>matchit()</code> was run within an <code><a href="base.html#topic+lapply">lapply()</a></code> or
<code>purrr::map()</code> call. The solution, which is recommended in all cases,
is simply to supply the original dataset to the <code>data</code> argument of
<code>match.data()</code>, e.g., as <code>match.data(m.out, data = original_data)</code>, as demonstrated in the Examples.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matchit">matchit()</a></code>; <code><a href="#topic+rbind.matchdata">rbind.matchdata()</a></code>
</p>
<p><code>vignette("estimating-effects")</code> for uses of <code>match.data()</code> and
<code>get_matches()</code> in estimating treatment effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde")

# 4:1 matching w/replacement
m.out1 &lt;- matchit(treat ~ age + educ + married +
                    race + nodegree + re74 + re75,
                  data = lalonde, replace = TRUE,
                  caliper = .05, ratio = 4)

m.data1 &lt;- match.data(m.out1, data = lalonde,
                      distance = "prop.score")
dim(m.data1) #one row per matched unit
head(m.data1, 10)

g.matches1 &lt;- get_matches(m.out1, data = lalonde,
                          distance = "prop.score")
dim(g.matches1) #multiple rows per matched unit
head(g.matches1, 10)

</code></pre>

<hr>
<h2 id='matchit'>Matching for Causal Inference</h2><span id='topic+matchit'></span><span id='topic+print.matchit'></span>

<h3>Description</h3>

<p><code>matchit()</code> is the main function of <em>MatchIt</em> and performs
pairing, subset selection, and subclassification with the aim of creating
treatment and control groups balanced on included covariates. <em>MatchIt</em>
implements the suggestions of Ho, Imai, King, and Stuart (2007) for
improving parametric statistical models by preprocessing data with
nonparametric matching methods.
</p>
<p>This page documents the overall use of <code>matchit()</code>, but for specifics
of how <code>matchit()</code> works with individual matching methods, see the
individual pages linked in the Details section below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchit(
  formula,
  data = NULL,
  method = "nearest",
  distance = "glm",
  link = "logit",
  distance.options = list(),
  estimand = "ATT",
  exact = NULL,
  mahvars = NULL,
  antiexact = NULL,
  discard = "none",
  reestimate = FALSE,
  s.weights = NULL,
  replace = FALSE,
  m.order = NULL,
  caliper = NULL,
  std.caliper = TRUE,
  ratio = 1,
  verbose = FALSE,
  include.obj = FALSE,
  ...
)

## S3 method for class 'matchit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchit_+3A_formula">formula</code></td>
<td>
<p>a two-sided <code><a href="stats.html#topic+formula">formula</a></code> object containing the treatment and
covariates to be used in creating the distance measure used in the matching.
This formula will be supplied to the functions that estimate the distance
measure. The formula should be specified as <code>A ~ X1 + X2 + ...</code> where
<code>A</code> represents the treatment variable and <code>X1</code> and <code>X2</code> are
covariates.</p>
</td></tr>
<tr><td><code id="matchit_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables named in <code>formula</code>
and possible other arguments. If not found in <code>data</code>, the variables
will be sought in the environment.</p>
</td></tr>
<tr><td><code id="matchit_+3A_method">method</code></td>
<td>
<p>the matching method to be used. The allowed methods are
<code><a href="#topic+method_nearest">&quot;nearest&quot;</a></code> for nearest neighbor matching (on
the propensity score by default), <code><a href="#topic+method_optimal">&quot;optimal&quot;</a></code>
for optimal pair matching, <code><a href="#topic+method_full">&quot;full&quot;</a></code> for optimal
full matching, <code><a href="#topic+method_genetic">&quot;genetic&quot;</a></code> for genetic
matching, <code><a href="#topic+method_cem">&quot;cem&quot;</a></code> for coarsened exact matching,
<code><a href="#topic+method_exact">&quot;exact&quot;</a></code> for exact matching,
<code><a href="#topic+method_cardinality">&quot;cardinality&quot;</a></code> for cardinality and
template matching, and <code><a href="#topic+method_subclass">&quot;subclass&quot;</a></code> for
subclassification. When set to <code>NULL</code>, no matching will occur, but
propensity score estimation and common support restrictions will still occur
if requested. See the linked pages for each method for more details on what
these methods do, how the arguments below are used by each on, and what
additional arguments are allowed.</p>
</td></tr>
<tr><td><code id="matchit_+3A_distance">distance</code></td>
<td>
<p>the distance measure to be used. Can be either the name of a
method of estimating propensity scores (e.g., <code>"glm"</code>), the name of a
method of computing a distance matrix from the covariates (e.g.,
<code>"mahalanobis"</code>), a vector of already-computed distance measures, or a
matrix of pairwise distances. See <code><a href="#topic+distance">distance</a></code> for allowable
options. The default is <code>"glm"</code> for propensity scores estimated with
logistic regression using <code><a href="stats.html#topic+glm">glm()</a></code>. Ignored for some methods; see individual
methods pages for information on whether and how the distance measure is
used.</p>
</td></tr>
<tr><td><code id="matchit_+3A_link">link</code></td>
<td>
<p>when <code>distance</code> is specified as a string, an additional
argument controlling the link function used in estimating the distance
measure. Allowable options depend on the specific <code>distance</code> value
specified. See <code><a href="#topic+distance">distance</a></code> for allowable options with each
option. The default is <code>"logit"</code>, which, along with <code>distance = "glm"</code>, identifies the default measure as logistic regression propensity
scores.</p>
</td></tr>
<tr><td><code id="matchit_+3A_distance.options">distance.options</code></td>
<td>
<p>a named list containing additional arguments
supplied to the function that estimates the distance measure as determined
by the argument to <code>distance</code>. See <a href="#topic+distance">distance</a> for an
example of its use.</p>
</td></tr>
<tr><td><code id="matchit_+3A_estimand">estimand</code></td>
<td>
<p>a string containing the name of the target estimand desired.
Can be one of <code>"ATT"</code> or <code>"ATC"</code>. Some methods accept <code>"ATE"</code>
as well. Default is <code>"ATT"</code>. See Details and the individual methods
pages for information on how this argument is used.</p>
</td></tr>
<tr><td><code id="matchit_+3A_exact">exact</code></td>
<td>
<p>for methods that allow it, for which variables exact matching
should take place. Can be specified as a string containing the names of
variables in <code>data</code> to be used or a one-sided formula with the desired
variables on the right-hand side (e.g., <code>~ X3 + X4</code>). See the
individual methods pages for information on whether and how this argument is
used.</p>
</td></tr>
<tr><td><code id="matchit_+3A_mahvars">mahvars</code></td>
<td>
<p>for methods that allow it, on which variables Mahalanobis
distance matching should take place when <code>distance</code> corresponds to
propensity scores. Usually used to perform Mahalanobis distance matching
within propensity score calipers, where the propensity scores are computed
using <code>formula</code> and <code>distance</code>. Can be specified as a string
containing the names of variables in <code>data</code> to be used or a one-sided
formula with the desired variables on the right-hand side (e.g., <code>~ X3 + X4</code>). See the individual methods pages for information on whether and how
this argument is used.</p>
</td></tr>
<tr><td><code id="matchit_+3A_antiexact">antiexact</code></td>
<td>
<p>for methods that allow it, for which variables anti-exact
matching should take place. Anti-exact matching ensures paired individuals
do not have the same value of the anti-exact matching variable(s). Can be
specified as a string containing the names of variables in <code>data</code> to be
used or a one-sided formula with the desired variables on the right-hand
side (e.g., <code>~ X3 + X4</code>). See the individual methods pages for
information on whether and how this argument is used.</p>
</td></tr>
<tr><td><code id="matchit_+3A_discard">discard</code></td>
<td>
<p>a string containing a method for discarding units outside a
region of common support. When a propensity score is estimated or supplied
to <code>distance</code> as a vector, the options are <code>"none"</code>,
<code>"treated"</code>, <code>"control"</code>, or <code>"both"</code>. For <code>"none"</code>, no
units are discarded for common support. Otherwise, units whose propensity
scores fall outside the corresponding region are discarded. Can also be a
<code>logical</code> vector where <code>TRUE</code> indicates the unit is to be
discarded. Default is <code>"none"</code> for no common support restriction. See
Details.</p>
</td></tr>
<tr><td><code id="matchit_+3A_reestimate">reestimate</code></td>
<td>
<p>if <code>discard</code> is not <code>"none"</code> and propensity
scores are estimated, whether to re-estimate the propensity scores in the
remaining sample. Default is <code>FALSE</code> to use the propensity scores
estimated in the original sample.</p>
</td></tr>
<tr><td><code id="matchit_+3A_s.weights">s.weights</code></td>
<td>
<p>an optional numeric vector of sampling weights to be
incorporated into propensity score models and balance statistics. Can also
be specified as a string containing the name of variable in <code>data</code> to
be used or a one-sided formula with the variable on the right-hand side
(e.g., <code>~ SW</code>). Not all propensity score models accept sampling
weights; see <a href="#topic+distance">distance</a> for information on which do and do not,
and see <code>vignette("sampling-weights")</code> for details on how to use
sampling weights in a matching analysis.</p>
</td></tr>
<tr><td><code id="matchit_+3A_replace">replace</code></td>
<td>
<p>for methods that allow it, whether matching should be done
with replacement (<code>TRUE</code>), where control units are allowed to be
matched to several treated units, or without replacement (<code>FALSE</code>),
where control units can only be matched to one treated unit each. See the
individual methods pages for information on whether and how this argument is
used. Default is <code>FALSE</code> for matching without replacement.</p>
</td></tr>
<tr><td><code id="matchit_+3A_m.order">m.order</code></td>
<td>
<p>for methods that allow it, the order that the matching takes
place. Allowable options depend on the matching method. The default of
<code>NULL</code> corresponds to <code>"largest"</code> when a propensity score is
estimated or supplied as a vector and <code>"data"</code> otherwise.</p>
</td></tr>
<tr><td><code id="matchit_+3A_caliper">caliper</code></td>
<td>
<p>for methods that allow it, the width(s) of the caliper(s) to
use in matching. Should be a numeric vector with each value named according
to the variable to which the caliper applies. To apply to the distance
measure, the value should be unnamed. See the individual methods pages for
information on whether and how this argument is used. The default is
<code>NULL</code> for no caliper.</p>
</td></tr>
<tr><td><code id="matchit_+3A_std.caliper">std.caliper</code></td>
<td>
<p><code>logical</code>; when a caliper is specified, whether the
the caliper is in standard deviation units (<code>TRUE</code>) or raw units
(<code>FALSE</code>). Can either be of length 1, applying to all calipers, or of
length equal to the length of <code>caliper</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="matchit_+3A_ratio">ratio</code></td>
<td>
<p>for methods that allow it, how many control units should be
matched to each treated unit in k:1 matching. Should be a single integer
value. See the individual methods pages for information on whether and how
this argument is used. The default is 1 for 1:1 matching.</p>
</td></tr>
<tr><td><code id="matchit_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>; whether information about the matching
process should be printed to the console. What is printed depends on the
matching method. Default is <code>FALSE</code> for no printing other than
warnings.</p>
</td></tr>
<tr><td><code id="matchit_+3A_include.obj">include.obj</code></td>
<td>
<p><code>logical</code>; whether to include any objects created in
the matching process in the output, i.e., by the functions from other
packages <code>matchit()</code> calls. What is included depends on the matching
method. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="matchit_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the functions used in the
matching process. See the individual methods pages for information on what
additional arguments are allowed for each method. Ignored for <code>print()</code>.</p>
</td></tr>
<tr><td><code id="matchit_+3A_x">x</code></td>
<td>
<p>a <code>matchit</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details for the various matching methods can be found at the following help
pages:
</p>

<ul>
<li> <p><code><a href="#topic+method_nearest">method_nearest</a></code> for nearest neighbor matching
</p>
</li>
<li> <p><code><a href="#topic+method_optimal">method_optimal</a></code> for optimal pair matching
</p>
</li>
<li> <p><code><a href="#topic+method_full">method_full</a></code> for optimal full matching
</p>
</li>
<li> <p><code><a href="#topic+method_genetic">method_genetic</a></code> for genetic matching
</p>
</li>
<li> <p><code><a href="#topic+method_cem">method_cem</a></code> for coarsened exact matching
</p>
</li>
<li> <p><code><a href="#topic+method_exact">method_exact</a></code> for exact matching
</p>
</li>
<li> <p><code><a href="#topic+method_cardinality">method_cardinality</a></code> for cardinality and template matching
</p>
</li>
<li> <p><code><a href="#topic+method_subclass">method_subclass</a></code> for subclassification
</p>
</li></ul>

<p>The pages contain information on what the method does, which of the arguments above are
allowed with them and how they are interpreted, and what additional
arguments can be supplied to further tune the method. Note that the default
method with no arguments supplied other than <code>formula</code> and <code>data</code>
is 1:1 nearest neighbor matching without replacement on a propensity score
estimated using a logistic regression of the treatment on the covariates.
This is not the same default offered by other matching programs, such as
those in <em>Matching</em>, <code>teffects</code> in Stata, or <code style="white-space: pre;">&#8288;PROC PSMATCH&#8288;</code>
in SAS, so care should be taken if trying to replicate the results of those
programs.
</p>
<p>When <code>method = NULL</code>, no matching will occur, but any propensity score
estimation and common support restriction will. This can be a simple way to
estimate the propensity score for use in future matching specifications
without having to re-estimate it each time. The <code>matchit()</code> output with
no matching can be supplied to <code>summary()</code> to examine balance prior to
matching on any of the included covariates and on the propensity score if
specified. All arguments other than <code>distance</code>, <code>discard</code>, and
<code>reestimate</code> will be ignored.
</p>
<p>See <a href="#topic+distance">distance</a> for details on the several ways to
specify the <code>distance</code>, <code>link</code>, and <code>distance.options</code>
arguments to estimate propensity scores and create distance measures.
</p>
<p>When the treatment variable is not a <code>0/1</code> variable, it will be coerced
to one and returned as such in the <code>matchit()</code> output (see section
Value, below). The following rules are used: 1) if <code>0</code> is one of the
values, it will be considered the control and the other value the treated;
2) otherwise, if the variable is a factor, <code>levels(treat)[1]</code> will be
considered control and the other variable the treated; 3) otherwise,
<code>sort(unique(treat))[1]</code> will be considered control and the other value
the treated. It is safest to ensure the treatment variable is a <code>0/1</code>
variable.
</p>
<p>The <code>discard</code> option implements a common support restriction. It can
only be used when a distance measure is an estimated propensity score or supplied as a vector and is ignored for some matching
methods. When specified as <code>"treated"</code>, treated units whose distance
measure is outside the range of distance measures of the control units will
be discarded. When specified as <code>"control"</code>, control units whose
distance measure is outside the range of distance measures of the treated
units will be discarded. When specified as <code>"both"</code>, treated and
control units whose distance measure is outside the intersection of the
range of distance measures of the treated units and the range of distance
measures of the control units will be discarded. When <code>reestimate = TRUE</code> and <code>distance</code> corresponds to a propensity score-estimating
function, the propensity scores are re-estimated in the remaining units
prior to being used for matching or calipers.
</p>
<p>Caution should be used when interpreting effects estimated with various
values of <code>estimand</code>. Setting <code>estimand = "ATT"</code> doesn't
necessarily mean the average treatment effect in the treated is being
estimated; it just means that for matching methods, treated units will be
untouched and given weights of 1 and control units will be matched to them
(and the opposite for <code>estimand = "ATC"</code>). If a caliper is supplied or
treated units are removed for common support or some other reason (e.g.,
lacking matches when using exact matching), the actual estimand targeted is
not the ATT but the treatment effect in the matched sample. The argument to
<code>estimand</code> simply triggers which units are matched to which, and for
stratification-based methods (exact matching, CEM, full matching, and
subclassification), determines the formula used to compute the
stratification weights.
</p>


<h4>How Matching Weights Are Computed</h4>

<p>Matching weights are computed in one of two ways depending on whether matching was done with replacement
or not.
</p>
<p>For matching <em>without</em> replacement (except for cardinality matching), each
unit is assigned to a subclass, which represents the pair they are a part of
(in the case of k:1 matching) or the stratum they belong to (in the case of
exact matching, coarsened exact matching, full matching, or
subclassification). The formula for computing the weights depends on the
argument supplied to <code>estimand</code>. A new &quot;stratum propensity score&quot;
(<code>sp</code>) is computed as the proportion of units in each stratum that are
in the treated group, and all units in that stratum are assigned that
stratum propensity score. This is distinct from the propensity score used for matching, if any. Weights are then computed using the standard formulas for
inverse probability weights with the stratum propensity score inserted: for the ATT, weights are 1 for the treated
units and <code>sp/(1-sp)</code> for the control units; for the ATC, weights are
<code>(1-sp)/sp</code> for the treated units and 1 for the control units; for the
ATE, weights are <code>1/sp</code> for the treated units and <code>1/(1-sp)</code> for the
control units. For cardinality matching, all matched units receive a weight
of 1.
</p>
<p>For matching <em>with</em> replacement, units are not assigned to unique strata. For
the ATT, each treated unit gets a weight of 1. Each control unit is weighted
as the sum of the inverse of the number of control units matched to the same
treated unit across its matches. For example, if a control unit was matched
to a treated unit that had two other control units matched to it, and that
same control was matched to a treated unit that had one other control unit
matched to it, the control unit in question would get a weight of 1/3 + 1/2
= 5/6. For the ATC, the same is true with the treated and control labels
switched. The weights are computed using the <code>match.matrix</code> component
of the <code>matchit()</code> output object.
</p>
<p>In each treatment group, weights are divided by the mean of the nonzero
weights in that treatment group to make the weights sum to the number of
units in that treatment group. If sampling weights are included through the
<code>s.weights</code> argument, they will be included in the <code>matchit()</code>
output object but not incorporated into the matching weights.
<code><a href="#topic+match.data">match.data()</a></code>, which extracts the matched set from a <code>matchit</code> object,
combines the matching weights and sampling weights.
</p>



<h3>Value</h3>

<p>When <code>method</code> is something other than <code>"subclass"</code>, a
<code>matchit</code> object with the following components:
</p>
<table>
<tr><td><code>match.matrix</code></td>
<td>
<p>a matrix containing the matches. The rownames correspond
to the treated units and the values in each row are the names (or indices)
of the control units matched to each treated unit. When treated units are
matched to different numbers of control units (e.g., with exact matching or
matching with a caliper), empty spaces will be filled with <code>NA</code>. Not
included when <code>method</code> is <code>"full"</code>, <code>"cem"</code> (unless <code>k2k = TRUE</code>), <code>"exact"</code>, or <code>"cardinality"</code>.</p>
</td></tr>
<tr><td><code>subclass</code></td>
<td>
<p>a factor
containing matching pair/stratum membership for each unit. Unmatched units
will have a value of <code>NA</code>. Not included when <code>replace = TRUE</code>.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>a numeric vector of estimated matching weights. Unmatched and
discarded units will have a weight of zero.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>the fit object of
the model used to estimate propensity scores when <code>distance</code> is
specified and not <code>"mahalanobis"</code> or a numeric vector. When
<code>reestimate = TRUE</code>, this is the model estimated after discarding
units.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>a data frame of covariates mentioned in <code>formula</code>,
<code>exact</code>, <code>mahvars</code>, and <code>antiexact</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the <code>matchit()</code> call.</p>
</td></tr>
<tr><td><code>info</code></td>
<td>
<p>information on the matching method and
distance measures used.</p>
</td></tr>
<tr><td><code>estimand</code></td>
<td>
<p>the argument supplied to
<code>estimand</code>.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the <code>formula</code> supplied.</p>
</td></tr>
<tr><td><code>treat</code></td>
<td>
<p>a vector of treatment status converted to zeros (0) and ones
(1) if not already in that format.</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>a vector of distance
values (i.e., propensity scores) when <code>distance</code> is supplied as a
method of estimating propensity scores or a numeric vector.</p>
</td></tr>
<tr><td><code>discarded</code></td>
<td>
<p>a logical vector denoting whether each observation was
discarded (<code>TRUE</code>) or not (<code>FALSE</code>) by the argument to
<code>discard</code>.</p>
</td></tr>
<tr><td><code>s.weights</code></td>
<td>
<p>the vector of sampling weights supplied to
the <code>s.weights</code> argument, if any.</p>
</td></tr>
<tr><td><code>exact</code></td>
<td>
<p>a one-sided formula
containing the variables, if any, supplied to <code>exact</code>.</p>
</td></tr>
<tr><td><code>mahvars</code></td>
<td>
<p>a one-sided formula containing the variables, if any,
supplied to <code>mahvars</code>.</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>when <code>include.obj = TRUE</code>, an
object containing the intermediate results of the matching procedure. See
the individual methods pages for what this component will contain.</p>
</td></tr>
</table>
<p>When <code>method = "subclass"</code>, a <code>matchit.subclass</code> object with the same
components as above except that <code>match.matrix</code> is excluded and one
additional component, <code>q.cut</code>, is included, containing a vector of the
distance measure cutpoints used to define the subclasses. See
<code><a href="#topic+method_subclass">method_subclass</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>Daniel Ho (<a href="mailto:dho@law.stanford.edu">dho@law.stanford.edu</a>); Kosuke Imai
(<a href="mailto:imai@harvard.edu">imai@harvard.edu</a>); Gary King (<a href="mailto:king@harvard.edu">king@harvard.edu</a>);
Elizabeth Stuart (<a href="mailto:estuart@jhsph.edu">estuart@jhsph.edu</a>)
</p>
<p>Version 4.0.0 update by Noah Greifer (<a href="mailto:noah.greifer@gmail.com">noah.greifer@gmail.com</a>)
</p>


<h3>References</h3>

<p>Ho, D. E., Imai, K., King, G., &amp; Stuart, E. A. (2007). Matching
as Nonparametric Preprocessing for Reducing Model Dependence in Parametric
Causal Inference. <em>Political Analysis</em>, 15(3), 199–236. <a href="https://doi.org/10.1093/pan/mpl013">doi:10.1093/pan/mpl013</a>
</p>
<p>Ho, D. E., Imai, K., King, G., &amp; Stuart, E. A. (2011). MatchIt:
Nonparametric Preprocessing for Parametric Causal Inference. <em>Journal of
Statistical Software</em>, 42(8). <a href="https://doi.org/10.18637/jss.v042.i08">doi:10.18637/jss.v042.i08</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.matchit">summary.matchit()</a></code> for balance assessment after matching, <code><a href="#topic+plot.matchit">plot.matchit()</a></code> for plots of covariate balance and propensity score overlap after matching.
</p>
<p><code>vignette("MatchIt")</code> for an introduction to matching with
<em>MatchIt</em>; <code>vignette("matching-methods")</code> for descriptions of the
variety of matching methods and options available;
<code>vignette("assessing-balance")</code> for information on assessing the
quality of a matching specification; <code>vignette("estimating-effects")</code>
for instructions on how to estimate treatment effects after matching; and
<code>vignette("sampling-weights")</code> for a guide to using <em>MatchIt</em> with
sampling weights.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("lalonde")

# Default: 1:1 NN PS matching w/o replacement

m.out1 &lt;- matchit(treat ~ age + educ + race + nodegree +
                   married + re74 + re75, data = lalonde)
m.out1
summary(m.out1)

# 1:1 NN Mahalanobis distance matching w/ replacement and
# exact matching on married and race

m.out2 &lt;- matchit(treat ~ age + educ + race + nodegree +
                   married + re74 + re75, data = lalonde,
                   distance = "mahalanobis", replace = TRUE,
                   exact = ~ married + race)
m.out2
summary(m.out2, un = TRUE)

# 2:1 NN Mahalanobis distance matching within caliper defined
# by a probit pregression PS

m.out3 &lt;- matchit(treat ~ age + educ + race + nodegree +
                   married + re74 + re75, data = lalonde,
                   distance = "glm", link = "probit",
                   mahvars = ~ age + educ + re74 + re75,
                   caliper = .1, ratio = 2)
m.out3
summary(m.out3, un = TRUE)

# Optimal full PS matching for the ATE within calipers on
# PS, age, and educ

m.out4 &lt;- matchit(treat ~ age + educ + race + nodegree +
                   married + re74 + re75, data = lalonde,
                   method = "full", estimand = "ATE",
                   caliper = c(.1, age = 2, educ = 1),
                   std.caliper = c(TRUE, FALSE, FALSE))
m.out4
summary(m.out4, un = TRUE)

# Subclassification on a logistic PS with 10 subclasses after
# discarding controls outside common support of PS

s.out1 &lt;- matchit(treat ~ age + educ + race + nodegree +
                   married + re74 + re75, data = lalonde,
                   method = "subclass", distance = "glm",
                   discard = "control", subclass = 10)
s.out1
summary(s.out1, un = TRUE)

</code></pre>

<hr>
<h2 id='method_cardinality'>Cardinality Matching</h2><span id='topic+method_cardinality'></span>

<h3>Description</h3>

<p>In <code><a href="#topic+matchit">matchit()</a></code>, setting <code>method = "cardinality"</code> performs cardinality
matching and other forms of matching that use mixed integer programming.
Rather than forming pairs, cardinality matching selects the largest subset
of units that satisfies user-supplied balance constraints on mean
differences. One of several available optimization programs can be used to
solve the mixed integer program. The default is the GLPK library as
implemented in the <em>Rglpk</em> package, but performance can be dramatically
improved using the HiGHS and the <em>highs</em> package, which are free, or Gurobi and the <em>gurobi</em> package, for which there is a
free academic license.
</p>
<p>This page details the allowable arguments with <code>method = "cardinality"</code>. See <code><a href="#topic+matchit">matchit()</a></code> for an explanation of what each argument
means in a general context and how it can be specified.
</p>
<p>Below is how <code>matchit()</code> is used for cardinality matching:
</p>
<pre>
matchit(formula,
        data = NULL,
        method = "cardinality",
        estimand = "ATT",
        exact = NULL,
        mahvars = NULL,
        s.weights = NULL,
        ratio = 1,
        verbose = FALSE,
        tols = .05,
        std.tols = TRUE,
        solver = "glpk",
        ...) </pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="method_cardinality_+3A_formula">formula</code></td>
<td>
<p>a two-sided <a href="stats.html#topic+formula">formula</a> object containing the treatment and
covariates to be balanced.</p>
</td></tr>
<tr><td><code id="method_cardinality_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables named in <code>formula</code>.
If not found in <code>data</code>, the variables will be sought in the
environment.</p>
</td></tr>
<tr><td><code id="method_cardinality_+3A_method">method</code></td>
<td>
<p>set here to <code>"cardinality"</code>.</p>
</td></tr>
<tr><td><code id="method_cardinality_+3A_estimand">estimand</code></td>
<td>
<p>a string containing the desired estimand. Allowable options
include <code>"ATT"</code>, <code>"ATC"</code>, and <code>"ATE"</code>. See Details.</p>
</td></tr>
<tr><td><code id="method_cardinality_+3A_exact">exact</code></td>
<td>
<p>for which variables exact matching should take place. Separate
optimization will occur within each subgroup of the exact matching
variables.</p>
</td></tr>
<tr><td><code id="method_cardinality_+3A_mahvars">mahvars</code></td>
<td>
<p>which variables should be used for pairing after subset selection. Can only be set when <code>ratio</code> is a whole number. See Details.</p>
</td></tr>
<tr><td><code id="method_cardinality_+3A_s.weights">s.weights</code></td>
<td>
<p>the variable containing sampling weights to be incorporated
into the optimization. The balance constraints refer to the product of the
sampling weights and the matching weights, and the sum of the product of the
sampling and matching weights will be maximized.</p>
</td></tr>
<tr><td><code id="method_cardinality_+3A_ratio">ratio</code></td>
<td>
<p>the desired ratio of control to treated units. Can be set to
<code>NA</code> to maximize sample size without concern for this ratio. See
Details.</p>
</td></tr>
<tr><td><code id="method_cardinality_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>; whether information about the matching
process should be printed to the console.</p>
</td></tr>
<tr><td><code id="method_cardinality_+3A_...">...</code></td>
<td>
<p>additional arguments that control the matching specification:
</p>

<dl>
<dt><code>tols</code></dt><dd> <p><code>numeric</code>; a vector of imbalance
tolerances for mean differences, one for each covariate in <code>formula</code>.
If only one value is supplied, it is applied to all. See <code>std.tols</code>
below. Default is <code>.05</code> for standardized mean differences of at most
.05 for all covariates between the treatment groups in the matched sample.
</p>
</dd>
<dt><code>std.tols</code></dt><dd> <p><code>logical</code>; whether each entry in <code>tols</code>
corresponds to a raw or standardized mean difference. If only one value is
supplied, it is applied to all. Default is <code>TRUE</code> for standardized mean
differences. The standardization factor is the pooled standard deviation
when <code>estimand = "ATE"</code>, the standard deviation of the treated group
when <code>estimand = "ATT"</code>, and the standard deviation of the control
group when <code>estimand = "ATC"</code> (the same as used in
<code><a href="#topic+summary.matchit">summary.matchit()</a></code>).</p>
</dd>
<dt><code>solver</code></dt><dd><p> the name of solver to use to
solve the optimization problem. Available options include <code>"highs"</code>, <code>"glpk"</code>,
<code>"symphony"</code>, and <code>"gurobi"</code> for HiGHS (implemented in the <em>highs</em> package), GLPK (implemented in the
<em>Rglpk</em> package), SYMPHONY (implemented in the <em>Rsymphony</em>
package), and Gurobi (implemented in the <em>gurobi</em> package),
respectively. The differences between them are in speed and solving ability.
GLPK (the default) and HiGHS are the easiest to install, but Gurobi is recommended as
it consistently outperforms other solvers and can find solutions even when
others can't, and in less time. Gurobi is proprietary but can be used with a
free trial or academic license. SYMPHONY may not produce reproducible
results, even with a seed set.  </p>
</dd>
<dt><code>time</code></dt><dd><p> the maximum amount of
time before the optimization routine aborts, in seconds. Default is 120 (2
minutes). For large problems, this should be set much higher.  </p>
</dd>
</dl>

<p>The arguments <code>distance</code> (and related arguments), <code>replace</code>, <code>m.order</code>, and <code>caliper</code> (and related arguments) are ignored with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Cardinality and Profile Matching</h4>

<p>Two types of matching are
available with <code>method = "cardinality"</code>: cardinality matching and
profile matching.
</p>
<p><strong>Cardinality matching</strong> finds the largest matched set that satisfies the
balance constraints between treatment groups, with the additional constraint
that the ratio of the number of matched control to matched treated units is
equal to <code>ratio</code> (1 by default), mimicking k:1 matching. When not all
treated units are included in the matched set, the estimand no longer
corresponds to the ATT, so cardinality matching should be avoided if
retaining the ATT is desired. To request cardinality matching,
<code>estimand</code> should be set to <code>"ATT"</code> or <code>"ATC"</code> and
<code>ratio</code> should be set to a positive integer. 1:1 cardinality matching
is the default method when no arguments are specified.
</p>
<p><strong>Profile matching</strong> finds the largest matched set that satisfies balance
constraints between each treatment group and a specified target sample. When
<code>estimand = "ATT"</code>, it will find the largest subset of the control
units that satisfies the balance constraints with respect to the treated
group, which is left intact. When <code>estimand = "ATE"</code>, it will find the
largest subsets of the treated group and of the control group that are
balanced to the overall sample. To request profile matching for the ATT,
<code>estimand</code> should be set to <code>"ATT"</code> and <code>ratio</code> to <code>NA</code>.
To request profile matching for the ATE, <code>estimand</code> should be set to
<code>"ATE"</code> and <code>ratio</code> can be set either to <code>NA</code> to maximize the
size of each sample independently or to a positive integer to ensure that
the ratio of matched control units to matched treated treats is fixed,
mimicking k:1 matching. Unlike cardinality matching, profile matching
retains the requested estimand if a solution is found.
</p>
<p>Neither method involves creating pairs in the matched set, but it is
possible to perform an additional round of pairing within the matched sample
after cardinality matching or profile matching for the ATE with a fixed whole number
sample size ratio by supplying the desired pairing variables to <code>mahvars</code>. Doing so will trigger <a href="#topic+method_optimal">optimal matching</a> using <code>optmatch::pairmatch()</code> on the Mahalanobis distance computed using the variables supplied to <code>mahvars</code>. The balance or composition of the matched sample will not change, but additional
precision and robustness can be gained by forming the pairs.
</p>
<p>The weights are scaled so that the sum of the weights in each group is equal
to the number of matched units in the smaller group when cardinality
matching or profile matching for the ATE, and scaled so that the sum of the
weights in the control group is equal to the number of treated units when
profile matching for the ATT. When the sample sizes of the matched groups
is the same (i.e., when <code>ratio = 1</code>), no scaling is done. Robust
standard errors should be used in effect estimation after cardinality or
profile matching (and cluster-robust standard errors if additional pairing
is done in the matched sample). See <code>vignette("estimating-effects")</code>
for more information.
</p>



<h4>Specifying Balance Constraints</h4>

<p>The balance constraints are on
the (standardized) mean differences between the matched treatment groups for
each covariate. Balance constraints should be set by supplying arguments to
<code>tols</code> and <code>std.tols</code>. For example, setting <code>tols = .1</code> and
<code>std.tols = TRUE</code> requests that all the mean differences in the matched
sample should be within .1 standard deviations for each covariate. Different
tolerances can be set for different variables; it might be beneficial to
constrain the mean differences for highly prognostic covariates more tightly
than for other variables. For example, one could specify <code style="white-space: pre;">&#8288;tols = c(.001, .05), std.tols = c(TRUE, FALSE)&#8288;</code>
to request that the standardized
mean difference for the first covariate is less than .001 and the raw mean
difference for the second covariate is less than .05. The values should be
specified in the order they appear in <code>formula</code>, except when
interactions are present. One can run the following code:
</p>
<pre>MatchIt:::get_assign(model.matrix(~X1*X2 + X3, data = data))[-1]</pre>
<p>which will output a vector of numbers and the variable to which each number
corresponds; the first entry in <code>tols</code> corresponds to the variable
labeled 1, the second to the variable labeled 2, etc.
</p>



<h4>Dealing with Errors and Warnings</h4>

<p>When the optimization cannot be
solved at all, or at least within the time frame specified in the argument
to <code>time</code>, an error or warning will appear. Unfortunately, it is hard
to know exactly the cause of the failure and what measures should be taken
to rectify it.
</p>
<p>A warning that says <code>"The optimizer failed to find an optimal solution in the time alotted. The returned solution may not be optimal."</code> usually
means that an optimal solution may be possible to find with more time, in
which case <code>time</code> should be increased or a faster solver should be
used. Even with this warning, a potentially usable solution will be
returned, so don't automatically take it to mean the optimization failed.
Sometimes, when there are multiple solutions with the same resulting sample
size, the optimizers will stall at one of them, not thinking it has found
the optimum. The result should be checked to see if it can be used as the
solution.
</p>
<p>An error that says <code>"The optimization problem may be infeasible."</code>
usually means that there is a issue with the optimization problem, i.e.,
that there is no possible way to satisfy the constraints. To rectify this,
one can try relaxing the constraints by increasing the value of <code>tols</code>
or use another solver. Sometimes Gurobi can solve problems that the other
solvers cannot.
</p>



<h3>Outputs</h3>

<p>Most outputs described in <code><a href="#topic+matchit">matchit()</a></code> are returned with
<code>method = "cardinality"</code>. Unless <code>mahvars</code> is specified, the <code>match.matrix</code> and <code>subclass</code>
components are omitted because no pairing or subclassification is done. When
<code>include.obj = TRUE</code> in the call to <code>matchit()</code>, the output of the
optimization function will be included in the output. When <code>exact</code> is
specified, this will be a list of such objects, one for each stratum of the
exact variables.
</p>


<h3>References</h3>

<p>In a manuscript, you should reference the solver used in the
optimization. For example, a sentence might read:
</p>
<p><em>Cardinality matching was performed using the MatchIt package (Ho, Imai, King, &amp; Stuart, 2011) in R with the optimization performed by HiGHs (Huangfu &amp; Hall, 2018).</em>
</p>
<p>See <code>vignette("matching-methods")</code> for more literature on cardinality
matching.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matchit">matchit()</a></code> for a detailed explanation of the inputs and outputs of
a call to <code>matchit()</code>.
</p>
<p><em><a href="https://CRAN.R-project.org/package=designmatch"><span class="pkg">designmatch</span></a></em>, which performs cardinality and profile matching with many more options and
more flexibility. The implementations of cardinality matching differ between
<em>MatchIt</em> and <em>designmatch</em>, so their results might differ.
</p>
<p><em><a href="https://CRAN.R-project.org/package=optweight"><span class="pkg">optweight</span></a></em>, which offers similar functionality but in the context of weighting rather
than matching.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde")

#Choose your solver; "gurobi" is best, "highs" is free and
#easy to install
solver &lt;- "highs"

# 1:1 cardinality matching
m.out1 &lt;- matchit(treat ~ age + educ + re74,
                  data = lalonde, method = "cardinality",
                  estimand = "ATT", ratio = 1,
                  tols = .2, solver = solver)
m.out1
summary(m.out1)

# Profile matching for the ATT
m.out2 &lt;- matchit(treat ~ age + educ + re74,
                  data = lalonde, method = "cardinality",
                  estimand = "ATT", ratio = NA,
                  tols = .2, solver = solver)
m.out2
summary(m.out2, un = FALSE)

# Profile matching for the ATE
m.out3 &lt;- matchit(treat ~ age + educ + re74,
                  data = lalonde, method = "cardinality",
                  estimand = "ATE", ratio = NA,
                  tols = .2, solver = solver)
m.out3
summary(m.out3, un = FALSE)


# Pairing after 1:1 cardinality matching:
m.out1b &lt;- matchit(treat ~ age + educ + re74,
                   data = lalonde, method = "cardinality",
                   estimand = "ATT", ratio = 1,
                   tols = .15, solver = solver,
                   mahvars = ~ age + educ + re74)

# Note that balance doesn't change but pair distances
# are lower for the paired-upon variables
summary(m.out1b, un = FALSE)
summary(m.out1, un = FALSE)

# In these examples, a high tol was used and
# few covariate matched on in order to not take too long;
# with real data, tols should be much lower and more
# covariates included if possible.

</code></pre>

<hr>
<h2 id='method_cem'>Coarsened Exact Matching</h2><span id='topic+method_cem'></span>

<h3>Description</h3>

<p>In <code><a href="#topic+matchit">matchit()</a></code>, setting <code>method = "cem"</code> performs coarsened exact
matching. With coarsened exact matching, covariates are coarsened into bins,
and a complete cross of the coarsened covariates is used to form subclasses
defined by each combination of the coarsened covariate levels. Any subclass
that doesn't contain both treated and control units is discarded, leaving
only subclasses containing treatment and control units that are exactly
equal on the coarsened covariates. The coarsening process can be controlled
by an algorithm or by manually specifying cutpoints and groupings. The
benefits of coarsened exact matching are that the tradeoff between exact
matching and approximate balancing can be managed to prevent discarding too
many units, which can otherwise occur with exact matching.
</p>
<p>This page details the allowable arguments with <code>method = "cem"</code>. See
<code><a href="#topic+matchit">matchit()</a></code> for an explanation of what each argument means in a general
context and how it can be specified.
</p>
<p>Below is how <code>matchit()</code> is used for coarsened exact matching:
</p>
<pre>
matchit(formula,
        data = NULL,
        method = "cem",
        estimand = "ATT",
        s.weights = NULL,
        verbose = FALSE,
        ...) </pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="method_cem_+3A_formula">formula</code></td>
<td>
<p>a two-sided <a href="stats.html#topic+formula">formula</a> object containing the treatment and
covariates to be used in creating the subclasses defined by a full cross of
the coarsened covariate levels.</p>
</td></tr>
<tr><td><code id="method_cem_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables named in <code>formula</code>.
If not found in <code>data</code>, the variables will be sought in the
environment.</p>
</td></tr>
<tr><td><code id="method_cem_+3A_method">method</code></td>
<td>
<p>set here to <code>"cem"</code>.</p>
</td></tr>
<tr><td><code id="method_cem_+3A_estimand">estimand</code></td>
<td>
<p>a string containing the desired estimand. Allowable options
include <code>"ATT"</code>, <code>"ATC"</code>, and <code>"ATE"</code>. The estimand controls
how the weights are computed; see the Computing Weights section at
<code><a href="#topic+matchit">matchit()</a></code> for details. When <code>k2k = TRUE</code> (see below), <code>estimand</code>
also controls how the matching is done.</p>
</td></tr>
<tr><td><code id="method_cem_+3A_s.weights">s.weights</code></td>
<td>
<p>the variable containing sampling weights to be incorporated
into balance statistics or the scaling factors when <code>k2k = TRUE</code> and
certain methods are used.</p>
</td></tr>
<tr><td><code id="method_cem_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>; whether information about the matching
process should be printed to the console.</p>
</td></tr>
<tr><td><code id="method_cem_+3A_...">...</code></td>
<td>
<p>additional arguments to control the matching process.
</p>

<dl>
<dt><code>grouping</code></dt><dd><p> a named list with an (optional) entry
for each categorical variable to be matched on. Each element should itself
be a list, and each entry of the sublist should be a vector containing
levels of the variable that should be combined to form a single level. Any
categorical variables not included in <code>grouping</code> will remain as they
are in the data, which means exact matching, with no coarsening, will take
place on these variables. See Details.  </p>
</dd>
<dt><code>cutpoints</code></dt><dd><p> a named list with an (optional) entry for each numeric variable to be matched on.
Each element describes a way of coarsening the corresponding variable. They
can be a vector of cutpoints that demarcate bins, a single number giving the
number of bins, or a string corresponding to a method of computing the
number of bins. Allowable strings include <code>"sturges"</code>, <code>"scott"</code>,
and <code>"fd"</code>, which use the functions
<code><a href="grDevices.html#topic+nclass">grDevices::nclass.Sturges()</a></code>, <code><a href="grDevices.html#topic+nclass">grDevices::nclass.scott()</a></code>,
and <code><a href="grDevices.html#topic+nclass">grDevices::nclass.FD()</a></code>, respectively. The default is
<code>"sturges"</code> for variables that are not listed or if no argument is
supplied. Can also be a single value to be applied to all numeric variables.
See Details.  </p>
</dd>
<dt><code>k2k</code></dt><dd> <p><code>logical</code>; whether 1:1 matching should
occur within the matched strata. If <code>TRUE</code> nearest neighbor matching
without replacement will take place within each stratum, and any unmatched
units will be dropped (e.g., if there are more treated than control units in
the stratum, the treated units without a match will be dropped). The
<code>k2k.method</code> argument controls how the distance between units is
calculated.  </p>
</dd>
<dt><code>k2k.method</code></dt><dd> <p><code>character</code>; how the distance
between units should be calculated if <code>k2k = TRUE</code>. Allowable arguments
include <code>NULL</code> (for random matching), any argument to
<code><a href="#topic+distance">distance()</a></code> for computing a distance matrix from covariates
(e.g., <code>"mahalanobis"</code>), or any allowable argument to <code>method</code> in
<code><a href="stats.html#topic+dist">dist()</a></code>. Matching will take place on the original
(non-coarsened) variables. The default is <code>"mahalanobis"</code>.  </p>
</dd>
<dt><code>mpower</code></dt><dd><p> if <code>k2k.method = "minkowski"</code>, the power used in
creating the distance. This is passed to the <code>p</code> argument of <code><a href="stats.html#topic+dist">dist()</a></code>.</p>
</dd>
</dl>

<p>The arguments <code>distance</code> (and related arguments), <code>exact</code>, <code>mahvars</code>, <code>discard</code> (and related arguments), <code>replace</code>, <code>m.order</code>, <code>caliper</code> (and related arguments), and <code>ratio</code> are ignored with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the coarsening is such that there are no exact matches with the coarsened
variables, the <code>grouping</code> and <code>cutpoints</code> arguments can be used to
modify the matching specification. Reducing the number of cutpoints or
grouping some variable values together can make it easier to find matches.
See Examples below. Removing variables can also help (but they will likely
not be balanced unless highly correlated with the included variables). To
take advantage of coarsened exact matching without failing to find any
matches, the covariates can be manually coarsened outside of
<code>matchit()</code> and then supplied to the <code>exact</code> argument in a call to
<code>matchit()</code> with another matching method.
</p>
<p>Setting <code>k2k = TRUE</code> is equivalent to first doing coarsened exact
matching with <code>k2k = FALSE</code> and then supplying stratum membership as an
exact matching variable (i.e., in <code>exact</code>) to another call to
<code>matchit()</code> with <code>method = "nearest"</code>, <code>distance = "mahalanobis"</code> and an argument to <code>discard</code> denoting unmatched units.
It is also equivalent to performing nearest neighbor matching supplying
coarsened versions of the variables to <code>exact</code>, except that
<code>method = "cem"</code> automatically coarsens the continuous variables. The
<code>estimand</code> argument supplied with <code>method = "cem"</code> functions the
same way it would in these alternate matching calls, i.e., by determining
the &quot;focal&quot; group that controls the order of the matching.
</p>


<h4>Grouping and Cutpoints</h4>

<p>The <code>grouping</code> and <code>cutpoints</code>
arguments allow one to fine-tune the coarsening of the covariates.
<code>grouping</code> is used for combining categories of categorical covariates
and <code>cutpoints</code> is used for binning numeric covariates. The values
supplied to these arguments should be iteratively changed until a matching
solution that balances covariate balance and remaining sample size is
obtained. The arguments are described below.
</p>


<h5><code>grouping</code></h5>

<p>The argument to <code>grouping</code> must be a list, where each component has the
name of a categorical variable, the levels of which are to be combined. Each
component must itself be a list; this list contains one or more vectors of
levels, where each vector corresponds to the levels that should be combined
into a single category. For example, if a variable <code>amount</code> had levels
<code>"none"</code>, <code>"some"</code>, and <code>"a lot"</code>, one could enter
<code>grouping = list(amount = list(c("none"), c("some", "a lot")))</code>, which
would group <code>"some"</code> and <code>"a lot"</code> into a single category and
leave <code>"none"</code> in its own category. Any levels left out of the list for
each variable will be left alone (so <code>c("none")</code> could have been
omitted from the previous code). Note that if a categorical variable does
not appear in <code>grouping</code>, it will not be coarsened, so exact matching
will take place on it. <code>grouping</code> should not be used for numeric
variables with more than a few values; use <code>cutpoints</code>, described below, instead.
</p>



<h5><code>cutpoints</code></h5>

<p>The argument to <code>cutpoints</code> must also be a list, where each component
has the name of a numeric variables that is to be binned. (As a shortcut, it
can also be a single value that will be applied to all numeric variables).
Each component can take one of three forms: a vector of cutpoints that
separate the bins, a single number giving the number of bins, or a string
corresponding to an algorithm used to compute the number of bins. Any values
at a boundary will be placed into the higher bin; e.g., if the cutpoints
were <code>c(0, 5, 10)</code>, values of 5 would be placed into the same bin as
values of 6, 7, 8, or 9, and values of 10 would be placed into a different
bin. Internally, values of <code>-Inf</code> and <code>Inf</code> are appended to the
beginning and end of the range. When given as a single number defining the
number of bins, the bin boundaries are the maximum and minimum values of the
variable with bin boundaries evenly spaced between them, i.e., not
quantiles. A value of 0 will not perform any binning (equivalent to exact
matching on the variable), and a value of 1 will remove the variable from
the exact matching variables but it will be still used for pair matching
when <code>k2k = TRUE</code>. The allowable strings include <code>"sturges"</code>,
<code>"scott"</code>, and <code>"fd"</code>, which use the corresponding binning method,
and <code>"q#"</code> where <code style="white-space: pre;">&#8288;#&#8288;</code> is a number, which splits the variable into
<code style="white-space: pre;">&#8288;#&#8288;</code> equally-sized bins (i.e., quantiles).
</p>
<p>An example of a way to supply an argument to <code>cutpoints</code> would be the
following:
</p>
<pre>
cutpoints = list(X1 = 4,
                 X2 = c(1.7, 5.5, 10.2),
                 X3 = "scott",
                 X4 = "q5") </pre>
<p>This would split <code>X1</code> into 4 bins, <code>X2</code>
into bins based on the provided boundaries, <code>X3</code> into a number of bins
determined by <code><a href="grDevices.html#topic+nclass">grDevices::nclass.scott()</a></code>, and <code>X4</code> into
quintiles. All other numeric variables would be split into a number of bins
determined by <code><a href="grDevices.html#topic+nclass">grDevices::nclass.Sturges()</a></code>, the default.
</p>




<h3>Outputs</h3>

<p>All outputs described in <code><a href="#topic+matchit">matchit()</a></code> are returned with
<code>method = "cem"</code> except for <code>match.matrix</code>. When <code>k2k = TRUE</code>, a <code>match.matrix</code> component with the matched pairs is also
included. <code>include.obj</code> is ignored.
</p>


<h3>Note</h3>

<p>This method does not rely on the <em>cem</em> package, instead using
code written for <em>MatchIt</em>, but its design is based on the original
<em>cem</em> functions. Versions of <em>MatchIt</em> prior to 4.1.0 did rely on
<em>cem</em>, so results may differ between versions. There are a few
differences between the ways <em>MatchIt</em> and <em>cem</em> (and older
versions of <em>MatchIt</em>) differ in executing coarsened exact matching,
described below.
</p>

<ul>
<li><p> In <em>MatchIt</em>, when a single number is
supplied to <code>cutpoints</code>, it describes the number of bins; in
<em>cem</em>, it describes the number of cutpoints separating bins. The
<em>MatchIt</em> method is closer to how <code><a href="graphics.html#topic+hist">hist()</a></code> processes breaks points to
create bins.
</p>
</li>
<li><p> In <em>MatchIt</em>, values on the cutpoint boundaries will
be placed into the higher bin; in <em>cem</em>, they are placed into the lower
bin. To avoid consequences of this choice, ensure the bin boundaries do not
coincide with observed values of the variables.
</p>
</li>
<li><p> When <code>cutpoints</code> are used, <code>"ss"</code> (for Shimazaki-Shinomoto's rule) can be used in
<em>cem</em> but not in <em>MatchIt</em>.
</p>
</li>
<li><p> When <code>k2k = TRUE</code>, <em>MatchIt</em> matches on the original variables (scaled), whereas
<em>cem</em> matches on the coarsened variables. Because the variables are
already exactly matched on the coarsened variables, matching in <em>cem</em>
is equivalent to random matching within strata.
</p>
</li>
<li><p> When <code>k2k = TRUE</code>, in <em>MatchIt</em> matched units are identified by pair membership, and the
original stratum membership prior to 1:1 matching is discarded. In
<em>cem</em>, pairs are not identified beyond the stratum the members are part of.
</p>
</li>
<li><p> When <code>k2k = TRUE</code>, <code>k2k.method = "mahalanobis"</code> can be
requested in <em>MatchIt</em> but not in <em>cem</em>.
</p>
</li></ul>



<h3>References</h3>

<p>In a manuscript, you don't need to cite another package when
using <code>method = "cem"</code> because the matching is performed completely
within <em>MatchIt</em>. For example, a sentence might read:
</p>
<p><em>Coarsened exact matching was performed using the MatchIt package (Ho,
Imai, King, &amp; Stuart, 2011) in R.</em>
</p>
<p>It would be a good idea to cite the following article, which develops the
theory behind coarsened exact matching:
</p>
<p>Iacus, S. M., King, G., &amp; Porro, G. (2012). Causal Inference without Balance
Checking: Coarsened Exact Matching. <em>Political Analysis</em>, 20(1), 1–24. <a href="https://doi.org/10.1093/pan/mpr013">doi:10.1093/pan/mpr013</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matchit">matchit()</a></code> for a detailed explanation of the inputs and outputs of
a call to <code>matchit()</code>.
</p>
<p>The <em>cem</em> package, upon which this method is based and which provided
the workhorse in previous versions of <em>MatchIt</em>.
</p>
<p><code><a href="#topic+method_exact">method_exact</a></code> for exact matching, which performs exact matching
on the covariates without coarsening.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde")

# Coarsened exact matching on age, race, married, and educ with educ
# coarsened into 5 bins and race coarsened into 2 categories,
# grouping "white" and "hispan" together
m.out1 &lt;- matchit(treat ~ age + race + married + educ, data = lalonde,
                  method = "cem", cutpoints = list(educ = 5),
                  grouping = list(race = list(c("white", "hispan"),
                                              c("black"))))
m.out1
summary(m.out1)

# The same but requesting 1:1 Mahalanobis distance matching with
# the k2k and k2k.method argument. Note the remaining number of units
# is smaller than when retaining the full matched sample.
m.out2 &lt;- matchit(treat ~ age + race + married + educ, data = lalonde,
                  method = "cem", cutpoints = list(educ = 5),
                  grouping = list(race = list(c("white", "hispan"),
                                              "black")),
                  k2k = TRUE, k2k.method = "mahalanobis")
m.out2
summary(m.out2, un = FALSE)

</code></pre>

<hr>
<h2 id='method_exact'>Exact Matching</h2><span id='topic+method_exact'></span>

<h3>Description</h3>

<p>In <code><a href="#topic+matchit">matchit()</a></code>, setting <code>method = "exact"</code> performs exact matching.
With exact matching, a complete cross of the covariates is used to form
subclasses defined by each combination of the covariate levels. Any subclass
that doesn't contain both treated and control units is discarded, leaving
only subclasses containing treatment and control units that are exactly
equal on the included covariates. The benefits of exact matching are that
confounding due to the covariates included is completely eliminated,
regardless of the functional form of the treatment or outcome models. The
problem is that typically many units will be discarded, sometimes
dramatically reducing precision and changing the target population of
inference. To use exact matching in combination with another matching method
(i.e., to exact match on some covariates and some other form of matching on
others), use the <code>exact</code> argument with that method.
</p>
<p>This page details the allowable arguments with <code>method = "exact"</code>. See
<code><a href="#topic+matchit">matchit()</a></code> for an explanation of what each argument means in a general
context and how it can be specified.
</p>
<p>Below is how <code>matchit()</code> is used for exact matching:
</p>
<pre>
matchit(formula,
        data = NULL,
        method = "exact",
        estimand = "ATT",
        s.weights = NULL,
        verbose = FALSE,
        ...)
</pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="method_exact_+3A_formula">formula</code></td>
<td>
<p>a two-sided <a href="stats.html#topic+formula">formula</a> object containing the treatment and
covariates to be used in creating the subclasses defined by a full cross of
the covariate levels.</p>
</td></tr>
<tr><td><code id="method_exact_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables named in <code>formula</code>.
If not found in <code>data</code>, the variables will be sought in the
environment.</p>
</td></tr>
<tr><td><code id="method_exact_+3A_method">method</code></td>
<td>
<p>set here to <code>"exact"</code>.</p>
</td></tr>
<tr><td><code id="method_exact_+3A_estimand">estimand</code></td>
<td>
<p>a string containing the desired estimand. Allowable options
include <code>"ATT"</code>, <code>"ATC"</code>, and <code>"ATE"</code>. The estimand controls
how the weights are computed; see the Computing Weights section at
<code><a href="#topic+matchit">matchit()</a></code> for details.</p>
</td></tr>
<tr><td><code id="method_exact_+3A_s.weights">s.weights</code></td>
<td>
<p>the variable containing sampling weights to be incorporated
into balance statistics. These weights do not affect the matching process.</p>
</td></tr>
<tr><td><code id="method_exact_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>; whether information about the matching
process should be printed to the console.</p>
</td></tr>
<tr><td><code id="method_exact_+3A_...">...</code></td>
<td>
<p>ignored.
</p>
<p>The arguments <code>distance</code> (and related arguments), <code>exact</code>, <code>mahvars</code>, <code>discard</code> (and related arguments), <code>replace</code>, <code>m.order</code>, <code>caliper</code> (and related arguments), and <code>ratio</code> are ignored with a warning.</p>
</td></tr>
</table>


<h3>Outputs</h3>

<p>All outputs described in <code><a href="#topic+matchit">matchit()</a></code> are returned with
<code>method = "exact"</code> except for <code>match.matrix</code>. This is because
matching strata are not indexed by treated units as they are in some other
forms of matching. <code>include.obj</code> is ignored.
</p>


<h3>References</h3>

<p>In a manuscript, you don't need to cite another package when
using <code>method = "exact"</code> because the matching is performed completely
within <em>MatchIt</em>. For example, a sentence might read:
</p>
<p><em>Exact matching was performed using the MatchIt package (Ho, Imai,
King, &amp; Stuart, 2011) in R.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matchit">matchit()</a></code> for a detailed explanation of the inputs and outputs of
a call to <code>matchit()</code>. The <code>exact</code> argument can be used with other
methods to perform exact matching in combination with other matching
methods.
</p>
<p><a href="#topic+method_cem">method_cem</a> for coarsened exact matching, which performs exact
matching on coarsened versions of the covariates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde")

# Exact matching on age, race, married, and educ
m.out1 &lt;- matchit(treat ~ age + race + married + educ, data = lalonde,
                  method = "exact")
m.out1
summary(m.out1)

</code></pre>

<hr>
<h2 id='method_full'>Optimal Full Matching</h2><span id='topic+method_full'></span>

<h3>Description</h3>

<p>In <code><a href="#topic+matchit">matchit()</a></code>, setting <code>method = "full"</code> performs optimal full
matching, which is a form of subclassification wherein all units, both
treatment and control (i.e., the &quot;full&quot; sample), are assigned to a subclass
and receive at least one match. The matching is optimal in the sense that
that sum of the absolute distances between the treated and control units in
each subclass is as small as possible. The method relies on and is a wrapper
for <code><a href="optmatch.html#topic+fullmatch">optmatch::fullmatch()</a></code>.
</p>
<p>Advantages of optimal full matching include that the matching order is not
required to be specified, units do not need to be discarded, and it is less
likely that extreme within-subclass distances will be large, unlike with
standard subclassification. The primary output of full matching is a set of
matching weights that can be applied to the matched sample; in this way,
full matching can be seen as a robust alternative to propensity score
weighting, robust in the sense that the propensity score model does not need
to be correct to estimate the treatment effect without bias. Note: with large samples, the optimization may fail or run very slowly; one can try using <code><a href="#topic+method_quick">method = &quot;quick&quot;</a></code> instead, which also performs full matching but can be much faster.
</p>
<p>This page details the allowable arguments with <code>method = "full"</code>.
See <code><a href="#topic+matchit">matchit()</a></code> for an explanation of what each argument means in a general
context and how it can be specified.
</p>
<p>Below is how <code>matchit()</code> is used for optimal full matching:
</p>
<pre>
matchit(formula,
        data = NULL,
        method = "full",
        distance = "glm",
        link = "logit",
        distance.options = list(),
        estimand = "ATT",
        exact = NULL,
        mahvars = NULL,
        anitexact = NULL,
        discard = "none",
        reestimate = FALSE,
        s.weights = NULL,
        caliper = NULL,
        std.caliper = TRUE,
        verbose = FALSE,
        ...)
</pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="method_full_+3A_formula">formula</code></td>
<td>
<p>a two-sided <a href="stats.html#topic+formula">formula</a> object containing the treatment and
covariates to be used in creating the distance measure used in the matching.
This formula will be supplied to the functions that estimate the distance
measure.</p>
</td></tr>
<tr><td><code id="method_full_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables named in <code>formula</code>.
If not found in <code>data</code>, the variables will be sought in the
environment.</p>
</td></tr>
<tr><td><code id="method_full_+3A_method">method</code></td>
<td>
<p>set here to <code>"full"</code>.</p>
</td></tr>
<tr><td><code id="method_full_+3A_distance">distance</code></td>
<td>
<p>the distance measure to be used. See <code><a href="#topic+distance">distance</a></code>
for allowable options. Can be supplied as a distance matrix.</p>
</td></tr>
<tr><td><code id="method_full_+3A_link">link</code></td>
<td>
<p>when <code>distance</code> is specified as a method of estimating
propensity scores, an additional argument controlling the link function used
in estimating the distance measure. See <code><a href="#topic+distance">distance</a></code> for allowable
options with each option.</p>
</td></tr>
<tr><td><code id="method_full_+3A_distance.options">distance.options</code></td>
<td>
<p>a named list containing additional arguments
supplied to the function that estimates the distance measure as determined
by the argument to <code>distance</code>.</p>
</td></tr>
<tr><td><code id="method_full_+3A_estimand">estimand</code></td>
<td>
<p>a string containing the desired estimand. Allowable options
include <code>"ATT"</code>, <code>"ATC"</code>, and <code>"ATE"</code>. The estimand controls
how the weights are computed; see the Computing Weights section at
<code><a href="#topic+matchit">matchit()</a></code> for details.</p>
</td></tr>
<tr><td><code id="method_full_+3A_exact">exact</code></td>
<td>
<p>for which variables exact matching should take place.</p>
</td></tr>
<tr><td><code id="method_full_+3A_mahvars">mahvars</code></td>
<td>
<p>for which variables Mahalanobis distance matching should take
place when <code>distance</code> corresponds to a propensity score (e.g., for
caliper matching or to discard units for common support). If specified, the
distance measure will not be used in matching.</p>
</td></tr>
<tr><td><code id="method_full_+3A_antiexact">antiexact</code></td>
<td>
<p>for which variables ant-exact matching should take place.
Anti-exact matching is processed using <code><a href="optmatch.html#topic+antiExactMatch">optmatch::antiExactMatch()</a></code>.</p>
</td></tr>
<tr><td><code id="method_full_+3A_discard">discard</code></td>
<td>
<p>a string containing a method for discarding units outside a
region of common support. Only allowed when <code>distance</code> corresponds to a
propensity score.</p>
</td></tr>
<tr><td><code id="method_full_+3A_reestimate">reestimate</code></td>
<td>
<p>if <code>discard</code> is not <code>"none"</code>, whether to
re-estimate the propensity score in the remaining sample prior to matching.</p>
</td></tr>
<tr><td><code id="method_full_+3A_s.weights">s.weights</code></td>
<td>
<p>the variable containing sampling weights to be incorporated
into propensity score models and balance statistics.</p>
</td></tr>
<tr><td><code id="method_full_+3A_caliper">caliper</code></td>
<td>
<p>the width(s) of the caliper(s) used for caliper matching.
Calipers are processed by <code><a href="optmatch.html#topic+caliper">optmatch::caliper()</a></code>. See Notes and Examples.</p>
</td></tr>
<tr><td><code id="method_full_+3A_std.caliper">std.caliper</code></td>
<td>
<p><code>logical</code>; when calipers are specified, whether they
are in standard deviation units (<code>TRUE</code>) or raw units (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="method_full_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>; whether information about the matching
process should be printed to the console.</p>
</td></tr>
<tr><td><code id="method_full_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="optmatch.html#topic+fullmatch">optmatch::fullmatch()</a></code>.
Allowed arguments include <code>min.controls</code>, <code>max.controls</code>,
<code>omit.fraction</code>, <code>mean.controls</code>, <code>tol</code>, and <code>solver</code>.
See the <code><a href="optmatch.html#topic+fullmatch">optmatch::fullmatch()</a></code> documentation for details. In general,
<code>tol</code> should be set to a low number (e.g., <code>1e-7</code>) to get a more
precise solution.
</p>
<p>The arguments <code>replace</code>, <code>m.order</code>, and <code>ratio</code> are ignored with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Mahalanobis Distance Matching</h4>

<p>Mahalanobis distance matching can be done one of two ways:
</p>

<ol>
<li>
<p>If no propensity score needs to be estimated, <code>distance</code> should be
set to <code>"mahalanobis"</code>, and Mahalanobis distance matching will occur
using all the variables in <code>formula</code>. Arguments to <code>discard</code> and
<code>mahvars</code> will be ignored, and a caliper can only be placed on named
variables. For example, to perform simple Mahalanobis distance matching, the
following could be run:
</p>
<pre>
matchit(treat ~ X1 + X2, method = "nearest",
        distance = "mahalanobis") </pre>
<p>With this code, the Mahalanobis distance is computed using <code>X1</code> and
<code>X2</code>, and matching occurs on this distance. The <code>distance</code>
component of the <code>matchit()</code> output will be empty.

</p>
</li>
<li>
<p>If a propensity score needs to be estimated for any reason, e.g., for
common support with <code>discard</code> or for creating a caliper,
<code>distance</code> should be whatever method is used to estimate the propensity
score or a vector of distance measures, i.e., it should not be
<code>"mahalanobis"</code>. Use <code>mahvars</code> to specify the variables used to
create the Mahalanobis distance. For example, to perform Mahalanobis within
a propensity score caliper, the following could be run:
</p>
<pre>
matchit(treat ~ X1 + X2 + X3, method = "nearest",
        distance =  "glm", caliper = .25,
        mahvars = ~ X1 + X2) </pre>
<p>With this code, <code>X1</code>, <code>X2</code>, and <code>X3</code> are used to estimate the
propensity score (using the <code>"glm"</code> method, which by default is
logistic regression), which is used to create a matching caliper. The actual
matching occurs on the Mahalanobis distance computed only using <code>X1</code>
and <code>X2</code>, which are supplied to <code>mahvars</code>. Units whose propensity
score difference is larger than the caliper will not be paired, and some
treated units may therefore not receive a match. The estimated propensity
scores will be included in the <code>distance</code> component of the
<code>matchit()</code> output. See Examples.

</p>
</li></ol>




<h3>Outputs</h3>

<p>All outputs described in <code><a href="#topic+matchit">matchit()</a></code> are returned with
<code>method = "full"</code> except for <code>match.matrix</code>. This is because
matching strata are not indexed by treated units as they are in some other
forms of matching. When <code>include.obj = TRUE</code> in the call to
<code>matchit()</code>, the output of the call to <code><a href="optmatch.html#topic+fullmatch">optmatch::fullmatch()</a></code> will be
included in the output. When <code>exact</code> is specified, this will be a list
of such objects, one for each stratum of the <code>exact</code> variables.
</p>


<h3>Note</h3>

<p>Calipers can only be used when <code>min.controls</code> is left at its
default.
</p>
<p>The option <code>"optmatch_max_problem_size"</code> is automatically set to
<code>Inf</code> during the matching process, different from its default in
<em>optmatch</em>. This enables matching problems of any size to be run, but
may also let huge, infeasible problems get through and potentially take a
long time or crash R. See <code><a href="optmatch.html#topic+setMaxProblemSize">optmatch::setMaxProblemSize()</a></code> for more details.
</p>


<h3>References</h3>

<p>In a manuscript, be sure to cite the following paper if using
<code>matchit()</code> with <code>method = "full"</code>:
</p>
<p>Hansen, B. B., &amp; Klopfer, S. O. (2006). Optimal Full Matching and Related
Designs via Network Flows. <em>Journal of Computational and Graphical Statistics</em>,
15(3), 609–627. <a href="https://doi.org/10.1198/106186006X137047">doi:10.1198/106186006X137047</a>
</p>
<p>For example, a sentence might read:
</p>
<p><em>Optimal full matching was performed using the MatchIt package (Ho,
Imai, King, &amp; Stuart, 2011) in R, which calls functions from the optmatch
package (Hansen &amp; Klopfer, 2006).</em>
</p>
<p>Theory is also developed in the following article:
</p>
<p>Hansen, B. B. (2004). Full Matching in an Observational Study of Coaching
for the SAT. Journal of the American Statistical Association, 99(467),
609–618. <a href="https://doi.org/10.1198/016214504000000647">doi:10.1198/016214504000000647</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matchit">matchit()</a></code> for a detailed explanation of the inputs and outputs of
a call to <code>matchit()</code>.
</p>
<p><code><a href="optmatch.html#topic+fullmatch">optmatch::fullmatch()</a></code>, which is the workhorse.
</p>
<p><code><a href="#topic+method_optimal">method_optimal</a></code> for optimal pair matching, which is a special
case of optimal full matching, and which relies on similar machinery.
Results from <code>method = "optimal"</code> can be replicated with <code>method = "full"</code> by setting <code>min.controls</code>, <code>max.controls</code>, and
<code>mean.controls</code> to the desired <code>ratio</code>.
</p>
<p><code><a href="#topic+method_quick">method_quick</a></code> for fast generalized quick matching, which is very similar to optimal full matching but can be dramatically faster at the expense of optimality and is less customizable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde")

# Optimal full PS matching
m.out1 &lt;- matchit(treat ~ age + educ + race + nodegree +
                    married + re74 + re75, data = lalonde,
                  method = "full")
m.out1
summary(m.out1)

# Optimal full Mahalanobis distance matching within a PS caliper
m.out2 &lt;- matchit(treat ~ age + educ + race + nodegree +
                    married + re74 + re75, data = lalonde,
                  method = "full", caliper = .01,
                  mahvars = ~ age + educ + re74 + re75)
m.out2
summary(m.out2, un = FALSE)

# Optimal full Mahalanobis distance matching within calipers
# of 500 on re74 and re75
m.out3 &lt;- matchit(treat ~ age + educ + re74 + re75,
                  data = lalonde, distance = "mahalanobis",
                  method = "full",
                  caliper = c(re74 = 500, re75 = 500),
                  std.caliper = FALSE)
m.out3
summary(m.out3, addlvariables = ~race + nodegree + married,
        data = lalonde, un = FALSE)

</code></pre>

<hr>
<h2 id='method_genetic'>Genetic Matching</h2><span id='topic+method_genetic'></span>

<h3>Description</h3>

<p>In <code><a href="#topic+matchit">matchit()</a></code>, setting <code>method = "genetic"</code> performs genetic matching.
Genetic matching is a form of nearest neighbor matching where distances are
computed as the generalized Mahalanobis distance, which is a generalization
of the Mahalanobis distance with a scaling factor for each covariate that
represents the importance of that covariate to the distance. A genetic
algorithm is used to select the scaling factors. The scaling factors are
chosen as those which maximize a criterion related to covariate balance,
which can be chosen, but which by default is the smallest p-value in
covariate balance tests among the covariates. This method relies on and is a
wrapper for <code><a href="Matching.html#topic+GenMatch">Matching::GenMatch()</a></code> and <code><a href="Matching.html#topic+Match">Matching::Match()</a></code>, which use
<code><a href="rgenoud.html#topic+genoud">rgenoud::genoud()</a></code> to perform the optimization using the genetic
algorithm.
</p>
<p>This page details the allowable arguments with <code>method = "genetic"</code>.
See <code><a href="#topic+matchit">matchit()</a></code> for an explanation of what each argument means in a general
context and how it can be specified.
</p>
<p>Below is how <code>matchit()</code> is used for genetic matching:
</p>
<pre>
matchit(formula,
        data = NULL,
        method = "genetic",
        distance = "glm",
        link = "logit",
        distance.options = list(),
        estimand = "ATT",
        exact = NULL,
        mahvars = NULL,
        antiexact = NULL,
        discard = "none",
        reestimate = FALSE,
        s.weights = NULL,
        replace = FALSE,
        m.order = NULL,
        caliper = NULL,
        ratio = 1,
        verbose = FALSE,
        ...) </pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="method_genetic_+3A_formula">formula</code></td>
<td>
<p>a two-sided <a href="stats.html#topic+formula">formula</a> object containing the treatment and
covariates to be used in creating the distance measure used in the matching.
This formula will be supplied to the functions that estimate the distance
measure and is used to determine the covariates whose balance is to be
optimized.</p>
</td></tr>
<tr><td><code id="method_genetic_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables named in <code>formula</code>.
If not found in <code>data</code>, the variables will be sought in the
environment.</p>
</td></tr>
<tr><td><code id="method_genetic_+3A_method">method</code></td>
<td>
<p>set here to <code>"genetic"</code>.</p>
</td></tr>
<tr><td><code id="method_genetic_+3A_distance">distance</code></td>
<td>
<p>the distance measure to be used. See <code><a href="#topic+distance">distance</a></code>
for allowable options. When set to a method of estimating propensity scores
or a numeric vector of distance values, the distance measure is included
with the covariates in <code>formula</code> to be supplied to the generalized
Mahalanobis distance matrix unless <code>mahvars</code> is specified. Otherwise,
only the covariates in <code>formula</code> are supplied to the generalized
Mahalanobis distance matrix to have their scaling factors chosen.
<code>distance</code> <em>cannot</em> be supplied as a distance matrix. Supplying
any method of computing a distance matrix (e.g., <code>"mahalanobis"</code>) has
the same effect of omitting propensity score but does not affect how the
distance between units is computed otherwise.</p>
</td></tr>
<tr><td><code id="method_genetic_+3A_link">link</code></td>
<td>
<p>when <code>distance</code> is specified as a method of estimating
propensity scores, an additional argument controlling the link function used
in estimating the distance measure. See <code><a href="#topic+distance">distance</a></code> for allowable
options with each option.</p>
</td></tr>
<tr><td><code id="method_genetic_+3A_distance.options">distance.options</code></td>
<td>
<p>a named list containing additional arguments
supplied to the function that estimates the distance measure as determined
by the argument to <code>distance</code>.</p>
</td></tr>
<tr><td><code id="method_genetic_+3A_estimand">estimand</code></td>
<td>
<p>a string containing the desired estimand. Allowable options
include <code>"ATT"</code> and <code>"ATC"</code>. See Details.</p>
</td></tr>
<tr><td><code id="method_genetic_+3A_exact">exact</code></td>
<td>
<p>for which variables exact matching should take place.</p>
</td></tr>
<tr><td><code id="method_genetic_+3A_mahvars">mahvars</code></td>
<td>
<p>when a distance corresponds to a propensity score (e.g., for
caliper matching or to discard units for common support), which covariates
should be supplied to the generalized Mahalanobis distance matrix for
matching. If unspecified, all variables in <code>formula</code> will be supplied
to the distance matrix. Use <code>mahvars</code> to only supply a subset. Even if
<code>mahvars</code> is specified, balance will be optimized on all covariates in
<code>formula</code>. See Details.</p>
</td></tr>
<tr><td><code id="method_genetic_+3A_antiexact">antiexact</code></td>
<td>
<p>for which variables ant-exact matching should take place.
Anti-exact matching is processed using the <code>restrict</code> argument to
<code>Matching::GenMatch()</code> and <code>Matching::Match()</code>.</p>
</td></tr>
<tr><td><code id="method_genetic_+3A_discard">discard</code></td>
<td>
<p>a string containing a method for discarding units outside a
region of common support. Only allowed when <code>distance</code> corresponds to a
propensity score.</p>
</td></tr>
<tr><td><code id="method_genetic_+3A_reestimate">reestimate</code></td>
<td>
<p>if <code>discard</code> is not <code>"none"</code>, whether to
re-estimate the propensity score in the remaining sample prior to matching.</p>
</td></tr>
<tr><td><code id="method_genetic_+3A_s.weights">s.weights</code></td>
<td>
<p>the variable containing sampling weights to be incorporated
into propensity score models and balance statistics. These are also supplied
to <code>GenMatch()</code> for use in computing the balance t-test p-values in the
process of matching.</p>
</td></tr>
<tr><td><code id="method_genetic_+3A_replace">replace</code></td>
<td>
<p>whether matching should be done with replacement.</p>
</td></tr>
<tr><td><code id="method_genetic_+3A_m.order">m.order</code></td>
<td>
<p>the order that the matching takes place. Allowable options
include <code>"largest"</code>, where matching takes place in descending order of
distance measures; <code>"smallest"</code>, where matching takes place in ascending
order of distance measures; <code>"random"</code>, where matching takes place
in a random order; and <code>"data"</code> where matching takes place based on the
order of units in the data. When <code>m.order = "random"</code>, results may differ
across different runs of the same code unless a seed is set and specified
with <code><a href="base.html#topic+set.seed">set.seed()</a></code>. The default of <code>NULL</code> corresponds to <code>"largest"</code> when a
propensity score is estimated or supplied as a vector and <code>"data"</code>
otherwise.</p>
</td></tr>
<tr><td><code id="method_genetic_+3A_caliper">caliper</code></td>
<td>
<p>the width(s) of the caliper(s) used for caliper matching. See
Details and Examples.</p>
</td></tr>
<tr><td><code id="method_genetic_+3A_std.caliper">std.caliper</code></td>
<td>
<p><code>logical</code>; when calipers are specified, whether they
are in standard deviation units (<code>TRUE</code>) or raw units (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="method_genetic_+3A_ratio">ratio</code></td>
<td>
<p>how many control units should be matched to each treated unit
for k:1 matching. Should be a single integer value.</p>
</td></tr>
<tr><td><code id="method_genetic_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>; whether information about the matching
process should be printed to the console. When <code>TRUE</code>, output from
<code>GenMatch()</code> with <code>print.level = 2</code> will be displayed. Default is
<code>FALSE</code> for no printing other than warnings.</p>
</td></tr>
<tr><td><code id="method_genetic_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="Matching.html#topic+GenMatch">Matching::GenMatch()</a></code>.
Potentially useful options include <code>pop.size</code>, <code>max.generations</code>,
and <code>fit.func</code>. If <code>pop.size</code> is not specified, a warning from
<em>Matching</em> will be thrown reminding you to change it. Note that the
<code>ties</code> and <code>CommonSupport</code> arguments are set to <code>FALSE</code> and
cannot be changed. If <code>distance.tolerance</code> is not specified, it is set
to 0, whereas the default in <em>Matching</em> is 1e-5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In genetic matching, covariates play three roles: 1) as the variables on
which balance is optimized, 2) as the variables in the generalized
Mahalanobis distance between units, and 3) in estimating the propensity
score. Variables supplied to <code>formula</code> are always used for role (1), as
the variables on which balance is optimized. When <code>distance</code>
corresponds to a propensity score, the covariates are also used to estimate
the propensity score (unless it is supplied). When <code>mahvars</code> is
specified, the named variables will form the covariates that go into the
distance matrix. Otherwise, the variables in <code>formula</code> along with the
propensity score will go into the distance matrix. This leads to three ways
to use <code>distance</code> and <code>mahvars</code> to perform the matching:
</p>

<ol>
<li><p>When <code>distance</code> corresponds to a propensity score and <code>mahvars</code>
<em>is not</em> specified, the covariates in <code>formula</code> along with the
propensity score are used to form the generalized Mahalanobis distance
matrix. This is the default and most typical use of <code>method = "genetic"</code> in <code>matchit()</code>.

</p>
</li>
<li><p>When <code>distance</code> corresponds to a propensity score and <code>mahvars</code>
<em>is</em> specified, the covariates in <code>mahvars</code> are used to form the
generalized Mahalanobis distance matrix. The covariates in <code>formula</code>
are used to estimate the propensity score and have their balance optimized
by the genetic algorithm. The propensity score is not included in the
generalized Mahalanobis distance matrix.

</p>
</li>
<li><p>When <code>distance</code> is a method of computing a distance matrix
(e.g.,<code>"mahalanobis"</code>), no propensity score is estimated, and the
covariates in <code>formula</code> are used to form the generalized Mahalanobis
distance matrix. Which specific method is supplied has no bearing on how the
distance matrix is computed; it simply serves as a signal to omit estimation
of a propensity score.

</p>
</li></ol>

<p>When a caliper is specified, any variables mentioned in <code>caliper</code>,
possibly including the propensity score, will be added to the matching
variables used to form the generalized Mahalanobis distance matrix. This is
because <em>Matching</em> doesn't allow for the separation of caliper
variables and matching variables in genetic matching.
</p>


<h4>Estimand</h4>

<p>The <code>estimand</code> argument controls whether control
units are selected to be matched with treated units (<code>estimand = "ATT"</code>) or treated units are selected to be matched with control units
(<code>estimand = "ATC"</code>). The &quot;focal&quot; group (e.g., the treated units for
the ATT) is typically made to be the smaller treatment group, and a warning
will be thrown if it is not set that way unless <code>replace = TRUE</code>.
Setting <code>estimand = "ATC"</code> is equivalent to swapping all treated and
control labels for the treatment variable. When <code>estimand = "ATC"</code>, the
default <code>m.order</code> is <code>"smallest"</code>, and the <code>match.matrix</code>
component of the output will have the names of the control units as the
rownames and be filled with the names of the matched treated units (opposite
to when <code>estimand = "ATT"</code>). Note that the argument supplied to
<code>estimand</code> doesn't necessarily correspond to the estimand actually
targeted; it is merely a switch to trigger which treatment group is
considered &quot;focal&quot;. Note that while <code>GenMatch()</code> and <code>Match()</code>
support the ATE as an estimand, <code>matchit()</code> only supports the ATT and
ATC for genetic matching.
</p>



<h3>Outputs</h3>

<p>All outputs described in <code><a href="#topic+matchit">matchit()</a></code> are returned with
<code>method = "genetic"</code>. When <code>replace = TRUE</code>, the <code>subclass</code>
component is omitted. When <code>include.obj = TRUE</code> in the call to
<code>matchit()</code>, the output of the call to <code><a href="Matching.html#topic+GenMatch">Matching::GenMatch()</a></code> will be
included in the output.
</p>


<h3>References</h3>

<p>In a manuscript, be sure to cite the following papers if using
<code>matchit()</code> with <code>method = "genetic"</code>:
</p>
<p>Diamond, A., &amp; Sekhon, J. S. (2013). Genetic matching for estimating causal
effects: A general multivariate matching method for achieving balance in
observational studies. Review of Economics and Statistics, 95(3), 932–945. <a href="https://doi.org/10.1162/REST_a_00318">doi:10.1162/REST_a_00318</a>
</p>
<p>Sekhon, J. S. (2011). Multivariate and Propensity Score Matching Software
with Automated Balance Optimization: The Matching package for R. Journal of
Statistical Software, 42(1), 1–52. <a href="https://doi.org/10.18637/jss.v042.i07">doi:10.18637/jss.v042.i07</a>
</p>
<p>For example, a sentence might read:
</p>
<p><em>Genetic matching was performed using the MatchIt package (Ho, Imai,
King, &amp; Stuart, 2011) in R, which calls functions from the Matching package
(Diamond &amp; Sekhon, 2013; Sekhon, 2011).</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matchit">matchit()</a></code> for a detailed explanation of the inputs and outputs of
a call to <code>matchit()</code>.
</p>
<p><code><a href="Matching.html#topic+GenMatch">Matching::GenMatch()</a></code> and <code><a href="Matching.html#topic+Match">Matching::Match()</a></code>, which do the work.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde")

# 1:1 genetic matching with PS as a covariate
m.out1 &lt;- matchit(treat ~ age + educ + race + nodegree +
                    married + re74 + re75, data = lalonde,
                  method = "genetic",
                  pop.size = 10) #use much larger pop.size
m.out1
summary(m.out1)

# 2:1 genetic matching with replacement without PS
m.out2 &lt;- matchit(treat ~ age + educ + race + nodegree +
                    married + re74 + re75, data = lalonde,
                  method = "genetic", replace = TRUE,
                  ratio = 2, distance = "mahalanobis",
                  pop.size = 10) #use much larger pop.size
m.out2
summary(m.out2, un = FALSE)

# 1:1 genetic matching on just age, educ, re74, and re75
# within calipers on PS and educ; other variables are
# used to estimate PS
m.out3 &lt;- matchit(treat ~ age + educ + race + nodegree +
                    married + re74 + re75, data = lalonde,
                  method = "genetic",
                  mahvars = ~ age + educ + re74 + re75,
                  caliper = c(.05, educ = 2),
                  std.caliper = c(TRUE, FALSE),
                  pop.size = 10) #use much larger pop.size
m.out3
summary(m.out3, un = FALSE)

</code></pre>

<hr>
<h2 id='method_nearest'>Nearest Neighbor Matching</h2><span id='topic+method_nearest'></span>

<h3>Description</h3>

<p>In <code><a href="#topic+matchit">matchit()</a></code>, setting <code>method = "nearest"</code> performs greedy nearest
neighbor matching. A distance is computed between each treated unit and each
control unit, and, one by one, each treated unit is assigned a control unit
as a match. The matching is &quot;greedy&quot; in the sense that there is no action
taken to optimize an overall criterion; each match is selected without
considering the other matches that may occur subsequently.
</p>
<p>This page details the allowable arguments with <code>method = "nearest"</code>.
See <code><a href="#topic+matchit">matchit()</a></code> for an explanation of what each argument means in a general
context and how it can be specified.
</p>
<p>Below is how <code>matchit()</code> is used for nearest neighbor matching:
</p>
<pre>
matchit(formula,
        data = NULL,
        method = "nearest",
        distance = "glm",
        link = "logit",
        distance.options = list(),
        estimand = "ATT",
        exact = NULL,
        mahvars = NULL,
        antiexact = NULL,
        discard = "none",
        reestimate = FALSE,
        s.weights = NULL,
        replace = TRUE,
        m.order = NULL,
        caliper = NULL,
        ratio = 1,
        min.controls = NULL,
        max.controls = NULL,
        verbose = FALSE,
        ...) </pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="method_nearest_+3A_formula">formula</code></td>
<td>
<p>a two-sided <a href="stats.html#topic+formula">formula</a> object containing the treatment and
covariates to be used in creating the distance measure used in the matching.</p>
</td></tr>
<tr><td><code id="method_nearest_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables named in <code>formula</code>.
If not found in <code>data</code>, the variables will be sought in the
environment.</p>
</td></tr>
<tr><td><code id="method_nearest_+3A_method">method</code></td>
<td>
<p>set here to <code>"nearest"</code>.</p>
</td></tr>
<tr><td><code id="method_nearest_+3A_distance">distance</code></td>
<td>
<p>the distance measure to be used. See <code><a href="#topic+distance">distance</a></code>
for allowable options. Can be supplied as a distance matrix.</p>
</td></tr>
<tr><td><code id="method_nearest_+3A_link">link</code></td>
<td>
<p>when <code>distance</code> is specified as a method of estimating
propensity scores, an additional argument controlling the link function used
in estimating the distance measure. See <code><a href="#topic+distance">distance</a></code> for allowable
options with each option.</p>
</td></tr>
<tr><td><code id="method_nearest_+3A_distance.options">distance.options</code></td>
<td>
<p>a named list containing additional arguments
supplied to the function that estimates the distance measure as determined
by the argument to <code>distance</code>.</p>
</td></tr>
<tr><td><code id="method_nearest_+3A_estimand">estimand</code></td>
<td>
<p>a string containing the desired estimand. Allowable options
include <code>"ATT"</code> and <code>"ATC"</code>. See Details.</p>
</td></tr>
<tr><td><code id="method_nearest_+3A_exact">exact</code></td>
<td>
<p>for which variables exact matching should take place.</p>
</td></tr>
<tr><td><code id="method_nearest_+3A_mahvars">mahvars</code></td>
<td>
<p>for which variables Mahalanobis distance matching should take
place when <code>distance</code> corresponds to a propensity score (e.g., for
caliper matching or to discard units for common support). If specified, the
distance measure will not be used in matching.</p>
</td></tr>
<tr><td><code id="method_nearest_+3A_antiexact">antiexact</code></td>
<td>
<p>for which variables ant-exact matching should take place.</p>
</td></tr>
<tr><td><code id="method_nearest_+3A_discard">discard</code></td>
<td>
<p>a string containing a method for discarding units outside a
region of common support. Only allowed when <code>distance</code> corresponds to a
propensity score.</p>
</td></tr>
<tr><td><code id="method_nearest_+3A_reestimate">reestimate</code></td>
<td>
<p>if <code>discard</code> is not <code>"none"</code>, whether to
re-estimate the propensity score in the remaining sample prior to matching.</p>
</td></tr>
<tr><td><code id="method_nearest_+3A_s.weights">s.weights</code></td>
<td>
<p>the variable containing sampling weights to be incorporated
into propensity score models and balance statistics.</p>
</td></tr>
<tr><td><code id="method_nearest_+3A_replace">replace</code></td>
<td>
<p>whether matching should be done with replacement.</p>
</td></tr>
<tr><td><code id="method_nearest_+3A_m.order">m.order</code></td>
<td>
<p>the order that the matching takes place. Allowable options
include <code>"largest"</code>, where matching takes place in descending order of
distance measures; <code>"smallest"</code>, where matching takes place in ascending
order of distance measures; <code>"closest"</code>, where matching takes place in
order of the distance between units; <code>"random"</code>, where matching takes place
in a random order; and <code>"data"</code> where matching takes place based on the
order of units in the data. When <code>m.order = "random"</code>, results may differ
across different runs of the same code unless a seed is set and specified
with <code><a href="base.html#topic+set.seed">set.seed()</a></code>. The default of <code>NULL</code> corresponds to <code>"largest"</code> when a
propensity score is estimated or supplied as a vector and <code>"data"</code>
otherwise.</p>
</td></tr>
<tr><td><code id="method_nearest_+3A_caliper">caliper</code></td>
<td>
<p>the width(s) of the caliper(s) used for caliper matching. See
Details and Examples.</p>
</td></tr>
<tr><td><code id="method_nearest_+3A_std.caliper">std.caliper</code></td>
<td>
<p><code>logical</code>; when calipers are specified, whether they
are in standard deviation units (<code>TRUE</code>) or raw units (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="method_nearest_+3A_ratio">ratio</code></td>
<td>
<p>how many control units should be matched to each treated unit
for k:1 matching. For variable ratio matching, see section &quot;Variable Ratio
Matching&quot; in Details below.</p>
</td></tr>
<tr><td><code id="method_nearest_+3A_min.controls">min.controls</code>, <code id="method_nearest_+3A_max.controls">max.controls</code></td>
<td>
<p>for variable ratio matching, the minimum
and maximum number of controls units to be matched to each treated unit. See
section &quot;Variable Ratio Matching&quot; in Details below.</p>
</td></tr>
<tr><td><code id="method_nearest_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>; whether information about the matching
process should be printed to the console. When <code>TRUE</code>, a progress bar
implemented using <em>RcppProgress</em> will be displayed.</p>
</td></tr>
<tr><td><code id="method_nearest_+3A_...">...</code></td>
<td>
<p>additional arguments that control the matching specification:
</p>

<dl>
<dt><code>reuse.max</code></dt><dd> <p><code>numeric</code>; the maximum number of
times each control can be used as a match. Setting <code>reuse.max = 1</code>
corresponds to matching without replacement (i.e., <code>replace = FALSE</code>),
and setting <code>reuse.max = Inf</code> corresponds to traditional matching with
replacement (i.e., <code>replace = TRUE</code>) with no limit on the number of
times each control unit can be matched. Other values restrict the number of
times each control can be matched when matching with replacement.
<code>replace</code> is ignored when <code>reuse.max</code> is specified.  </p>
</dd>
<dt><code>unit.id</code></dt><dd><p> one or more variables containing a unit ID for each
observation, i.e., in case multiple observations correspond to the same
unit. Once a control observation has been matched, no other observation with
the same unit ID can be used as matches. This ensures each control unit is
used only once even if it has multiple observations associated with it.
Omitting this argument is the same as giving each observation a unique ID.
Ignored when <code>replace = TRUE</code>.  </p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>



<h4>Mahalanobis Distance Matching</h4>

<p>Mahalanobis distance matching can be done one of two ways:
</p>

<ol>
<li><p>If no propensity score needs to be estimated, <code>distance</code> should be
set to <code>"mahalanobis"</code>, and Mahalanobis distance matching will occur
using all the variables in <code>formula</code>. Arguments to <code>discard</code> and
<code>mahvars</code> will be ignored, and a caliper can only be placed on named
variables. For example, to perform simple Mahalanobis distance matching, the
following could be run:
</p>
<pre>
matchit(treat ~ X1 + X2, method = "nearest",
        distance = "mahalanobis") </pre>
<p>With this code, the Mahalanobis distance is computed using <code>X1</code> and
<code>X2</code>, and matching occurs on this distance. The <code>distance</code>
component of the <code>matchit()</code> output will be empty.

</p>
</li>
<li><p>If a propensity score needs to be estimated for any reason, e.g., for
common support with <code>discard</code> or for creating a caliper,
<code>distance</code> should be whatever method is used to estimate the propensity
score or a vector of distance measures. Use <code>mahvars</code> to specify the
variables used to create the Mahalanobis distance. For example, to perform
Mahalanobis within a propensity score caliper, the following could be run:
</p>
<pre>
matchit(treat ~ X1 + X2 + X3, method = "nearest",
        distance = "glm", caliper = .25,
        mahvars = ~ X1 + X2) </pre>
<p>With this code, <code>X1</code>, <code>X2</code>, and <code>X3</code> are used to estimate the
propensity score (using the <code>"glm"</code> method, which by default is
logistic regression), which is used to create a matching caliper. The actual
matching occurs on the Mahalanobis distance computed only using <code>X1</code>
and <code>X2</code>, which are supplied to <code>mahvars</code>. Units whose propensity
score difference is larger than the caliper will not be paired, and some
treated units may therefore not receive a match. The estimated propensity
scores will be included in the <code>distance</code> component of the
<code>matchit()</code> output. See Examples.

</p>
</li></ol>




<h4>Estimand</h4>

<p>The <code>estimand</code> argument controls whether control units are selected to be
matched with treated units (<code>estimand = "ATT"</code>) or treated units are
selected to be matched with control units (<code>estimand = "ATC"</code>). The
&quot;focal&quot; group (e.g., the treated units for the ATT) is typically made to be
the smaller treatment group, and a warning will be thrown if it is not set
that way unless <code>replace = TRUE</code>. Setting <code>estimand = "ATC"</code> is
equivalent to swapping all treated and control labels for the treatment
variable. When <code>estimand = "ATC"</code>, the default <code>m.order</code> is
<code>"smallest"</code>, and the <code>match.matrix</code> component of the output will
have the names of the control units as the rownames and be filled with the
names of the matched treated units (opposite to when <code>estimand = "ATT"</code>). Note that the argument supplied to <code>estimand</code> doesn't
necessarily correspond to the estimand actually targeted; it is merely a
switch to trigger which treatment group is considered &quot;focal&quot;.
</p>



<h4>Variable Ratio Matching</h4>

<p><code>matchit()</code> can perform variable
ratio &quot;extremal&quot; matching as described by Ming and Rosenbaum (2000). This
method tends to result in better balance than fixed ratio matching at the
expense of some precision. When <code>ratio &gt; 1</code>, rather than requiring all
treated units to receive <code>ratio</code> matches, each treated unit is assigned
a value that corresponds to the number of control units they will be matched
to. These values are controlled by the arguments <code>min.controls</code> and
<code>max.controls</code>, which correspond to <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>,
respectively, in Ming and Rosenbaum (2000), and trigger variable ratio
matching to occur. Some treated units will receive <code>min.controls</code>
matches and others will receive <code>max.controls</code> matches (and one unit
may have an intermediate number of matches); how many units are assigned
each number of matches is determined by the algorithm described in Ming and
Rosenbaum (2000, p119). <code>ratio</code> controls how many total control units
will be matched: <code>n1 * ratio</code> control units will be matched, where
<code>n1</code> is the number of treated units, yielding the same total number of
matched controls as fixed ratio matching does.
</p>
<p>Variable ratio matching cannot be used with Mahalanobis distance matching or
when <code>distance</code> is supplied as a matrix. The calculations of the
numbers of control units each treated unit will be matched to occurs without
consideration of <code>caliper</code> or <code>discard</code>. <code>ratio</code> does not
have to be an integer but must be greater than 1 and less than <code>n0/n1</code>,
where <code>n0</code> and <code>n1</code> are the number of control and treated units,
respectively. Setting <code>ratio = n0/n1</code> performs a crude form of full
matching where all control units are matched. If <code>min.controls</code> is not
specified, it is set to 1 by default. <code>min.controls</code> must be less than
<code>ratio</code>, and <code>max.controls</code> must be greater than <code>ratio</code>. See
Examples below for an example of their use.
</p>



<h4>Using <code>m.order = "closest"</code></h4>

<p>As of version 4.6.0, <code>m.order</code> can be set to <code>"closest"</code>, which works regardless of how the distance measure is specified. This matches in order of the distance between units. The closest pair of units across all potential pairs of units will be matched first; the second closest pair of all potential pairs will be matched second, etc. This ensures that the best possible matches are given priority, and in that sense performs similarly to <code>m.order = "smallest"</code>.
</p>



<h3>Outputs</h3>

<p>All outputs described in <code><a href="#topic+matchit">matchit()</a></code> are returned with
<code>method = "nearest"</code>. When <code>replace = TRUE</code>, the <code>subclass</code>
component is omitted. <code>include.obj</code> is ignored.
</p>


<h3>Note</h3>

<p>Sometimes an error will be produced by <em>Rcpp</em> along the lines of
<code>"function 'Rcpp_precious_remove' not provided by package 'Rcpp'"</code>. It
is not immediately clear why this happens, though
<a href="https://lists.r-forge.r-project.org/pipermail/rcpp-devel/2021-July/010648.html">this</a>
thread appears to provide some insight. In a fresh session, run
<code style="white-space: pre;">&#8288;remove.packages(c("MatchIt", "Rcpp")); install.packages("MatchIt")&#8288;</code>.
This should sync <em>MatchIt</em> and <em>Rcpp</em> and ensure they work
correctly.
</p>


<h3>References</h3>

<p>In a manuscript, you don't need to cite another package when
using <code>method = "nearest"</code> because the matching is performed completely
within <em>MatchIt</em>. For example, a sentence might read:
</p>
<p><em>Nearest neighbor matching was performed using the MatchIt package (Ho, Imai, King, &amp; Stuart, 2011) in R.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matchit">matchit()</a></code> for a detailed explanation of the inputs and outputs of
a call to <code>matchit()</code>.
</p>
<p><code><a href="#topic+method_optimal">method_optimal()</a></code> for optimal pair matching, which is similar to
nearest neighbor matching except that an overall distance criterion is
minimized.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("lalonde")

# 1:1 greedy NN matching on the PS
m.out1 &lt;- matchit(treat ~ age + educ + race + nodegree +
                    married + re74 + re75, data = lalonde,
                  method = "nearest")
m.out1
summary(m.out1)

# 3:1 NN Mahalanobis distance matching with
# replacement within a PS caliper
m.out2 &lt;- matchit(treat ~ age + educ + race + nodegree +
                    married + re74 + re75, data = lalonde,
                  method = "nearest", replace = TRUE,
                  mahvars = ~ age + educ + re74 + re75,
                  ratio = 3, caliper = .02)
m.out2
summary(m.out2, un = FALSE)

# 1:1 NN Mahalanobis distance matching within calipers
# on re74 and re75 and exact matching on married and race
m.out3 &lt;- matchit(treat ~ age + educ + re74 + re75, data = lalonde,
                  method = "nearest", distance = "mahalanobis",
                  exact = ~ married + race,
                  caliper = c(re74 = .2, re75 = .15))
m.out3
summary(m.out3, un = FALSE)

# 2:1 variable ratio NN matching on the PS
m.out4 &lt;- matchit(treat ~ age + educ + race + nodegree +
                    married + re74 + re75, data = lalonde,
                  method = "nearest", ratio = 2,
                  min.controls = 1, max.controls = 12)
m.out4
summary(m.out4, un = FALSE)

# Some units received 1 match and some received 12
table(table(m.out4$subclass[m.out4$treat == 0]))

</code></pre>

<hr>
<h2 id='method_optimal'>Optimal Pair Matching</h2><span id='topic+method_optimal'></span>

<h3>Description</h3>

<p>In <code><a href="#topic+matchit">matchit()</a></code>, setting <code>method = "optimal"</code> performs optimal pair
matching. The matching is optimal in the sense that that sum of the absolute
pairwise distances in the matched sample is as small as possible. The method
functionally relies on <code><a href="optmatch.html#topic+fullmatch">optmatch::fullmatch()</a></code>.
</p>
<p>Advantages of optimal pair matching include that the matching order is not
required to be specified and it is less likely that extreme within-pair
distances will be large, unlike with nearest neighbor matching. Generally,
however, as a subset selection method, optimal pair matching tends to
perform similarly to nearest neighbor matching in that similar subsets of
units will be selected to be matched.
</p>
<p>This page details the allowable arguments with <code>method = "optmatch"</code>.
See <code><a href="#topic+matchit">matchit()</a></code> for an explanation of what each argument means in a general
context and how it can be specified.
</p>
<p>Below is how <code>matchit()</code> is used for optimal pair matching:
</p>
<pre>
matchit(formula,
        data = NULL,
        method = "optimal",
        distance = "glm",
        link = "logit",
        distance.options = list(),
        estimand = "ATT",
        exact = NULL,
        mahvars = NULL,
        antiexact = NULL,
        discard = "none",
        reestimate = FALSE,
        s.weights = NULL,
        ratio = 1,
        min.controls = NULL,
        max.controls = NULL,
        verbose = FALSE,
        ...) </pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="method_optimal_+3A_formula">formula</code></td>
<td>
<p>a two-sided <a href="stats.html#topic+formula">formula</a> object containing the treatment and
covariates to be used in creating the distance measure used in the matching.
This formula will be supplied to the functions that estimate the distance
measure.</p>
</td></tr>
<tr><td><code id="method_optimal_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables named in <code>formula</code>.
If not found in <code>data</code>, the variables will be sought in the
environment.</p>
</td></tr>
<tr><td><code id="method_optimal_+3A_method">method</code></td>
<td>
<p>set here to <code>"optimal"</code>.</p>
</td></tr>
<tr><td><code id="method_optimal_+3A_distance">distance</code></td>
<td>
<p>the distance measure to be used. See <code><a href="#topic+distance">distance</a></code>
for allowable options. Can be supplied as a distance matrix.</p>
</td></tr>
<tr><td><code id="method_optimal_+3A_link">link</code></td>
<td>
<p>when <code>distance</code> is specified as a method of estimating
propensity scores, an additional argument controlling the link function used
in estimating the distance measure. See <code><a href="#topic+distance">distance</a></code> for allowable
options with each option.</p>
</td></tr>
<tr><td><code id="method_optimal_+3A_distance.options">distance.options</code></td>
<td>
<p>a named list containing additional arguments
supplied to the function that estimates the distance measure as determined
by the argument to <code>distance</code>.</p>
</td></tr>
<tr><td><code id="method_optimal_+3A_estimand">estimand</code></td>
<td>
<p>a string containing the desired estimand. Allowable options
include <code>"ATT"</code> and <code>"ATC"</code>. See Details.</p>
</td></tr>
<tr><td><code id="method_optimal_+3A_exact">exact</code></td>
<td>
<p>for which variables exact matching should take place.</p>
</td></tr>
<tr><td><code id="method_optimal_+3A_mahvars">mahvars</code></td>
<td>
<p>for which variables Mahalanobis distance matching should take
place when <code>distance</code> corresponds to a propensity score (e.g., for
caliper matching or to discard units for common support). If specified, the
distance measure will not be used in matching.</p>
</td></tr>
<tr><td><code id="method_optimal_+3A_antiexact">antiexact</code></td>
<td>
<p>for which variables ant-exact matching should take place.
Anti-exact matching is processed using <code><a href="optmatch.html#topic+antiExactMatch">optmatch::antiExactMatch()</a></code>.</p>
</td></tr>
<tr><td><code id="method_optimal_+3A_discard">discard</code></td>
<td>
<p>a string containing a method for discarding units outside a
region of common support. Only allowed when <code>distance</code> is not
<code>"mahalanobis"</code> and not a matrix.</p>
</td></tr>
<tr><td><code id="method_optimal_+3A_reestimate">reestimate</code></td>
<td>
<p>if <code>discard</code> is not <code>"none"</code>, whether to
re-estimate the propensity score in the remaining sample prior to matching.</p>
</td></tr>
<tr><td><code id="method_optimal_+3A_s.weights">s.weights</code></td>
<td>
<p>the variable containing sampling weights to be incorporated
into propensity score models and balance statistics.</p>
</td></tr>
<tr><td><code id="method_optimal_+3A_ratio">ratio</code></td>
<td>
<p>how many control units should be matched to each treated unit
for k:1 matching. For variable ratio matching, see section &quot;Variable Ratio
Matching&quot; in Details below.</p>
</td></tr>
<tr><td><code id="method_optimal_+3A_min.controls">min.controls</code>, <code id="method_optimal_+3A_max.controls">max.controls</code></td>
<td>
<p>for variable ratio matching, the minimum
and maximum number of controls units to be matched to each treated unit. See
section &quot;Variable Ratio Matching&quot; in Details below.</p>
</td></tr>
<tr><td><code id="method_optimal_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>; whether information about the matching
process should be printed to the console. What is printed depends on the
matching method. Default is <code>FALSE</code> for no printing other than
warnings.</p>
</td></tr>
<tr><td><code id="method_optimal_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="optmatch.html#topic+fullmatch">optmatch::fullmatch()</a></code>.
Allowed arguments include <code>tol</code> and <code>solver</code>. See the
<code><a href="optmatch.html#topic+fullmatch">optmatch::fullmatch()</a></code> documentation for details. In general, <code>tol</code>
should be set to a low number (e.g., <code>1e-7</code>) to get a more precise
solution.
</p>
<p>The arguments <code>replace</code>, <code>caliper</code>, and <code>m.order</code> are ignored with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Mahalanobis Distance Matching</h4>

<p>Mahalanobis distance matching can be done one of two ways:
</p>

<ol>
<li><p>If no propensity score needs to be estimated, <code>distance</code> should be
set to <code>"mahalanobis"</code>, and Mahalanobis distance matching will occur
using all the variables in <code>formula</code>. Arguments to <code>discard</code> and
<code>mahvars</code> will be ignored. For example, to perform simple Mahalanobis
distance matching, the following could be run:
</p>
<pre>
matchit(treat ~ X1 + X2, method = "nearest",
        distance = "mahalanobis") </pre>
<p>With this code, the Mahalanobis distance is computed using <code>X1</code> and
<code>X2</code>, and matching occurs on this distance. The <code>distance</code>
component of the <code>matchit()</code> output will be empty.

</p>
</li>
<li><p>If a propensity score needs to be estimated for common support with
<code>discard</code>, <code>distance</code> should be whatever method is used to
estimate the propensity score or a vector of distance measures, i.e., it
should not be <code>"mahalanobis"</code>. Use <code>mahvars</code> to specify the
variables used to create the Mahalanobis distance. For example, to perform
Mahalanobis after discarding units outside the common support of the
propensity score in both groups, the following could be run:
</p>
<pre>
matchit(treat ~ X1 + X2 + X3, method = "nearest",
        distance = "glm", discard = "both",
        mahvars = ~ X1 + X2) </pre>
<p>With this code, <code>X1</code>, <code>X2</code>, and <code>X3</code> are used to estimate the
propensity score (using the <code>"glm"</code> method, which by default is
logistic regression), which is used to identify the common support. The
actual matching occurs on the Mahalanobis distance computed only using
<code>X1</code> and <code>X2</code>, which are supplied to <code>mahvars</code>. The estimated
propensity scores will be included in the <code>distance</code> component of the
<code>matchit()</code> output.

</p>
</li></ol>




<h4>Estimand</h4>

<p>The <code>estimand</code> argument controls whether control units are selected to be matched with treated units
(<code>estimand = "ATT"</code>) or treated units are selected to be matched with
control units (<code>estimand = "ATC"</code>). The &quot;focal&quot; group (e.g., the
treated units for the ATT) is typically made to be the smaller treatment
group, and a warning will be thrown if it is not set that way unless
<code>replace = TRUE</code>. Setting <code>estimand = "ATC"</code> is equivalent to
swapping all treated and control labels for the treatment variable. When
<code>estimand = "ATC"</code>, the <code>match.matrix</code> component of the output
will have the names of the control units as the rownames and be filled with
the names of the matched treated units (opposite to when <code>estimand = "ATT"</code>). Note that the argument supplied to <code>estimand</code> doesn't
necessarily correspond to the estimand actually targeted; it is merely a
switch to trigger which treatment group is considered &quot;focal&quot;.
</p>



<h4>Variable Ratio Matching</h4>

<p><code>matchit()</code> can perform variable
ratio matching, which involves matching a different number of control units
to each treated unit. When <code>ratio &gt; 1</code>, rather than requiring all
treated units to receive <code>ratio</code> matches, the arguments to
<code>max.controls</code> and <code>min.controls</code> can be specified to control the
maximum and minimum number of matches each treated unit can have.
<code>ratio</code> controls how many total control units will be matched: <code>n1 * ratio</code> control units will be matched, where <code>n1</code> is the number of
treated units, yielding the same total number of matched controls as fixed
ratio matching does.
</p>
<p>Variable ratio matching can be used with any <code>distance</code> specification.
<code>ratio</code> does not have to be an integer but must be greater than 1 and
less than <code>n0/n1</code>, where <code>n0</code> and <code>n1</code> are the number of
control and treated units, respectively. Setting <code>ratio = n0/n1</code>
performs a restricted form of full matching where all control units are
matched. If <code>min.controls</code> is not specified, it is set to 1 by default.
<code>min.controls</code> must be less than <code>ratio</code>, and <code>max.controls</code>
must be greater than <code>ratio</code>. See the Examples section of
<code><a href="#topic+method_nearest">method_nearest()</a></code> for an example of their use, which is the same
as it is with optimal matching.
</p>



<h3>Outputs</h3>

<p>All outputs described in <code><a href="#topic+matchit">matchit()</a></code> are returned with
<code>method = "optimal"</code>. When <code>include.obj = TRUE</code> in the call to
<code>matchit()</code>, the output of the call to <code>optmatch::fullmatch()</code> will be
included in the output. When <code>exact</code> is specified, this will be a list
of such objects, one for each stratum of the <code>exact</code> variables.
</p>


<h3>Note</h3>

<p>Optimal pair matching is a restricted form of optimal full matching
where the number of treated units in each subclass is equal to 1, whereas in
unrestricted full matching, multiple treated units can be assigned to the
same subclass. <code><a href="optmatch.html#topic+pairmatch">optmatch::pairmatch()</a></code> is simply a wrapper for
<code><a href="optmatch.html#topic+fullmatch">optmatch::fullmatch()</a></code>, which performs optimal full matching and is the
workhorse for <code><a href="#topic+method_full">method_full</a></code>. In the same way, <code>matchit()</code>
uses <code>optmatch::fullmatch()</code> under the hood, imposing the restrictions that
make optimal full matching function like optimal pair matching (which is
simply to set <code>min.controls &gt;= 1</code> and to pass <code>ratio</code> to the
<code>mean.controls</code> argument). This distinction is not important for
regular use but may be of interest to those examining the source code.
</p>
<p>The option <code>"optmatch_max_problem_size"</code> is automatically set to
<code>Inf</code> during the matching process, different from its default in
<em>optmatch</em>. This enables matching problems of any size to be run, but
may also let huge, infeasible problems get through and potentially take a
long time or crash R. See <code><a href="optmatch.html#topic+setMaxProblemSize">optmatch::setMaxProblemSize()</a></code> for more details.
</p>


<h3>References</h3>

<p>In a manuscript, be sure to cite the following paper if using
<code>matchit()</code> with <code>method = "optimal"</code>:
</p>
<p>Hansen, B. B., &amp; Klopfer, S. O. (2006). Optimal Full Matching and Related
Designs via Network Flows. Journal of Computational and Graphical
Statistics, 15(3), 609–627. <a href="https://doi.org/10.1198/106186006X137047">doi:10.1198/106186006X137047</a>
</p>
<p>For example, a sentence might read:
</p>
<p><em>Optimal pair matching was performed using the MatchIt package (Ho,
Imai, King, &amp; Stuart, 2011) in R, which calls functions from the optmatch
package (Hansen &amp; Klopfer, 2006).</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matchit">matchit()</a></code> for a detailed explanation of the inputs and outputs of
a call to <code>matchit()</code>.
</p>
<p><code><a href="optmatch.html#topic+fullmatch">optmatch::fullmatch()</a></code>, which is the workhorse.
</p>
<p><code><a href="#topic+method_full">method_full</a></code> for optimal full matching, of which optimal pair
matching is a special case, and which relies on similar machinery.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde")

#1:1 optimal PS matching with exact matching on race
m.out1 &lt;- matchit(treat ~ age + educ + race + nodegree +
                    married + re74 + re75, data = lalonde,
                  method = "optimal", exact = ~race)
m.out1
summary(m.out1)

#2:1 optimal matching on the scaled Euclidean distance
m.out2 &lt;- matchit(treat ~ age + educ + race + nodegree +
                    married + re74 + re75, data = lalonde,
                  method = "optimal", ratio = 2,
                  distance = "scaled_euclidean")
m.out2
summary(m.out2, un = FALSE)

</code></pre>

<hr>
<h2 id='method_quick'>Fast Generalized Full Matching</h2><span id='topic+method_quick'></span>

<h3>Description</h3>

<p>In <code><a href="#topic+matchit">matchit()</a></code>, setting <code>method = "quick"</code> performs generalized full
matching, which is a form of subclassification wherein all units, both
treatment and control (i.e., the &quot;full&quot; sample), are assigned to a subclass
and receive at least one match. It uses an algorithm that is extremely fast
compared to optimal full matching, which is why it is labeled as &quot;quick&quot;, at the
expense of true optimality. The method is described in Sävje, Higgins, &amp; Sekhon (2021). The method relies on and is a wrapper
for <code><a href="quickmatch.html#topic+quickmatch">quickmatch::quickmatch()</a></code>.
</p>
<p>Advantages of generalized full matching include that the matching order is not
required to be specified, units do not need to be discarded, and it is less
likely that extreme within-subclass distances will be large, unlike with
standard subclassification. The primary output of generalized full matching is a set of
matching weights that can be applied to the matched sample; in this way,
generalized full matching can be seen as a robust alternative to propensity score
weighting, robust in the sense that the propensity score model does not need
to be correct to estimate the treatment effect without bias.
</p>
<p>This page details the allowable arguments with <code>method = "quick"</code>.
See <code><a href="#topic+matchit">matchit()</a></code> for an explanation of what each argument means in a general
context and how it can be specified.
</p>
<p>Below is how <code>matchit()</code> is used for generalized full matching:
</p>
<pre>
matchit(formula,
        data = NULL,
        method = "quick",
        distance = "glm",
        link = "logit",
        distance.options = list(),
        estimand = "ATT",
        exact = NULL,
        mahvars = NULL,
        discard = "none",
        reestimate = FALSE,
        s.weights = NULL,
        caliper = NULL,
        std.caliper = TRUE,
        verbose = FALSE,
        ...)
</pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="method_quick_+3A_formula">formula</code></td>
<td>
<p>a two-sided <a href="stats.html#topic+formula">formula</a> object containing the treatment and
covariates to be used in creating the distance measure used in the matching.
This formula will be supplied to the functions that estimate the distance
measure.</p>
</td></tr>
<tr><td><code id="method_quick_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables named in <code>formula</code>.
If not found in <code>data</code>, the variables will be sought in the
environment.</p>
</td></tr>
<tr><td><code id="method_quick_+3A_method">method</code></td>
<td>
<p>set here to <code>"quick"</code>.</p>
</td></tr>
<tr><td><code id="method_quick_+3A_distance">distance</code></td>
<td>
<p>the distance measure to be used. See <code><a href="#topic+distance">distance</a></code>
for allowable options. Cannot be supplied as a matrix.</p>
</td></tr>
<tr><td><code id="method_quick_+3A_link">link</code></td>
<td>
<p>when <code>distance</code> is specified as a method of estimating
propensity scores, an additional argument controlling the link function used
in estimating the distance measure. See <code><a href="#topic+distance">distance</a></code> for allowable
options with each option.</p>
</td></tr>
<tr><td><code id="method_quick_+3A_distance.options">distance.options</code></td>
<td>
<p>a named list containing additional arguments
supplied to the function that estimates the distance measure as determined
by the argument to <code>distance</code>.</p>
</td></tr>
<tr><td><code id="method_quick_+3A_estimand">estimand</code></td>
<td>
<p>a string containing the desired estimand. Allowable options
include <code>"ATT"</code>, <code>"ATC"</code>, and <code>"ATE"</code>. The estimand controls
how the weights are computed; see the Computing Weights section at
<code><a href="#topic+matchit">matchit()</a></code> for details.</p>
</td></tr>
<tr><td><code id="method_quick_+3A_exact">exact</code></td>
<td>
<p>for which variables exact matching should take place.</p>
</td></tr>
<tr><td><code id="method_quick_+3A_mahvars">mahvars</code></td>
<td>
<p>for which variables Mahalanobis distance matching should take
place when <code>distance</code> corresponds to a propensity score (e.g., to discard units for common support). If specified, the
distance measure will not be used in matching.</p>
</td></tr>
<tr><td><code id="method_quick_+3A_discard">discard</code></td>
<td>
<p>a string containing a method for discarding units outside a
region of common support. Only allowed when <code>distance</code> corresponds to a
propensity score.</p>
</td></tr>
<tr><td><code id="method_quick_+3A_reestimate">reestimate</code></td>
<td>
<p>if <code>discard</code> is not <code>"none"</code>, whether to
re-estimate the propensity score in the remaining sample prior to matching.</p>
</td></tr>
<tr><td><code id="method_quick_+3A_s.weights">s.weights</code></td>
<td>
<p>the variable containing sampling weights to be incorporated
into propensity score models and balance statistics.</p>
</td></tr>
<tr><td><code id="method_quick_+3A_caliper">caliper</code></td>
<td>
<p>the width of the caliper used for caliper matching. A caliper can only be placed on the propensity score.</p>
</td></tr>
<tr><td><code id="method_quick_+3A_std.caliper">std.caliper</code></td>
<td>
<p><code>logical</code>; when a caliper is specified, whether it
is in standard deviation units (<code>TRUE</code>) or raw units (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="method_quick_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>; whether information about the matching
process should be printed to the console.</p>
</td></tr>
<tr><td><code id="method_quick_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="quickmatch.html#topic+quickmatch">quickmatch::quickmatch()</a></code>. Allowed arguments include <code>treatment_constraints</code>, <code>size_constraint</code>, <code>target</code>, and other arguments passed to <code>scclust::sc_clustering()</code> (see <code><a href="quickmatch.html#topic+quickmatch">quickmatch::quickmatch()</a></code> for details). In particular, changing <code>seed_method</code> from its default can improve performance.
No arguments will be passed to <code>distances::distances()</code>.
</p>
<p>The arguments <code>replace</code>, <code>ratio</code>, <code>min.controls</code>, <code>max.controls</code>, <code>m.order</code>, and <code>antiexact</code> are ignored with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generalized full matching is similar to optimal full matching, but has some additional flexibility that can be controlled by some of the extra arguments available. By default, <code>method = "quick"</code> performs a standard full match in which all units are matched (unless restricted by the caliper) and assigned to a subclass. Each subclass could contain multiple units from each treatment group. The subclasses are chosen to minimize the largest within-subclass distance between units (including between units of the same treatment group). Notably, generalized full matching requires less memory and can run much faster than optimal full matching and optimal pair matching and, in some cases, even than nearest neighbor matching, and it can be used with huge datasets (e.g., in the millions) while running in under a minute.
</p>


<h3>Outputs</h3>

<p>All outputs described in <code><a href="#topic+matchit">matchit()</a></code> are returned with
<code>method = "quick"</code> except for <code>match.matrix</code>. This is because
matching strata are not indexed by treated units as they are in some other
forms of matching. When <code>include.obj = TRUE</code> in the call to
<code>matchit()</code>, the output of the call to <code><a href="quickmatch.html#topic+quickmatch">quickmatch::quickmatch()</a></code> will be
included in the output. When <code>exact</code> is specified, this will be a list
of such objects, one for each stratum of the <code>exact</code> variables.
</p>


<h3>References</h3>

<p>In a manuscript, be sure to cite the <em>quickmatch</em> package if using
<code>matchit()</code> with <code>method = "quick"</code>:
</p>
<p>Sävje, F., Sekhon, J., &amp; Higgins, M. (2018). quickmatch: Quick generalized full matching. <a href="https://CRAN.R-project.org/package=quickmatch">https://CRAN.R-project.org/package=quickmatch</a>
</p>
<p>For example, a sentence might read:
</p>
<p><em>Generalized full matching was performed using the MatchIt package (Ho,
Imai, King, &amp; Stuart, 2011) in R, which calls functions from the quickmatch
package (Savje, Sekhon, &amp; Higgins, 2018).</em>
</p>
<p>You should also cite the following paper, which develops and describes the method:
</p>
<p>Sävje, F., Higgins, M. J., &amp; Sekhon, J. S. (2021). Generalized Full Matching. <em>Political Analysis</em>, 29(4), 423–447. <a href="https://doi.org/10.1017/pan.2020.32">doi:10.1017/pan.2020.32</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matchit">matchit()</a></code> for a detailed explanation of the inputs and outputs of
a call to <code>matchit()</code>.
</p>
<p><code><a href="quickmatch.html#topic+quickmatch">quickmatch::quickmatch()</a></code>, which is the workhorse.
</p>
<p><code><a href="#topic+method_full">method_full</a></code> for optimal full matching, which is nearly the same but offers more customizability and more optimal solutions at the cost of speed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde")

# Generalize full PS matching
m.out1 &lt;- matchit(treat ~ age + educ + race + nodegree +
                    married + re74 + re75, data = lalonde,
                  method = "quick")
m.out1
summary(m.out1)

</code></pre>

<hr>
<h2 id='method_subclass'>Subclassification</h2><span id='topic+method_subclass'></span>

<h3>Description</h3>

<p>In <code><a href="#topic+matchit">matchit()</a></code>, setting <code>method = "subclass"</code> performs
subclassification on the distance measure (i.e., propensity score).
Treatment and control units are placed into subclasses based on quantiles of
the propensity score in the treated group, in the control group, or overall,
depending on the desired estimand. Weights are computed based on the
proportion of treated units in each subclass. Subclassification implemented
here does not rely on any other package.
</p>
<p>This page details the allowable arguments with <code>method = "subclass"</code>.
See <code><a href="#topic+matchit">matchit()</a></code> for an explanation of what each argument means in a general
context and how it can be specified.
</p>
<p>Below is how <code>matchit()</code> is used for subclassification:
</p>
<pre>
matchit(formula,
        data = NULL,
        method = "subclass",
        distance = "glm",
        link = "logit",
        distance.options = list(),
        estimand = "ATT",
        discard = "none",
        reestimate = FALSE,
        s.weights = NULL,
        verbose = FALSE,
        ...) </pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="method_subclass_+3A_formula">formula</code></td>
<td>
<p>a two-sided <a href="stats.html#topic+formula">formula</a> object containing the treatment and
covariates to be used in creating the distance measure used in the
subclassification.</p>
</td></tr>
<tr><td><code id="method_subclass_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables named in <code>formula</code>.
If not found in <code>data</code>, the variables will be sought in the
environment.</p>
</td></tr>
<tr><td><code id="method_subclass_+3A_method">method</code></td>
<td>
<p>set here to <code>"subclass"</code>.</p>
</td></tr>
<tr><td><code id="method_subclass_+3A_distance">distance</code></td>
<td>
<p>the distance measure to be used. See <code><a href="#topic+distance">distance</a></code>
for allowable options. Must be a vector of distance scores or the name of a method of estimating propensity scores.</p>
</td></tr>
<tr><td><code id="method_subclass_+3A_link">link</code></td>
<td>
<p>when <code>distance</code> is specified as a string, an additional
argument controlling the link function used in estimating the distance
measure. See <code><a href="#topic+distance">distance</a></code> for allowable options with each option.</p>
</td></tr>
<tr><td><code id="method_subclass_+3A_distance.options">distance.options</code></td>
<td>
<p>a named list containing additional arguments
supplied to the function that estimates the distance measure as determined
by the argument to <code>distance</code>.</p>
</td></tr>
<tr><td><code id="method_subclass_+3A_estimand">estimand</code></td>
<td>
<p>the target <code>estimand</code>. If <code>"ATT"</code>, the default,
subclasses are formed based on quantiles of the distance measure in the
treated group; if <code>"ATC"</code>, subclasses are formed based on quantiles of
the distance measure in the control group; if <code>"ATE"</code>, subclasses are
formed based on quantiles of the distance measure in the full sample. The
estimand also controls how the subclassification weights are computed; see
the Computing Weights section at <code><a href="#topic+matchit">matchit()</a></code> for details.</p>
</td></tr>
<tr><td><code id="method_subclass_+3A_discard">discard</code></td>
<td>
<p>a string containing a method for discarding units outside a
region of common support.</p>
</td></tr>
<tr><td><code id="method_subclass_+3A_reestimate">reestimate</code></td>
<td>
<p>if <code>discard</code> is not <code>"none"</code>, whether to
re-estimate the propensity score in the remaining sample prior to
subclassification.</p>
</td></tr>
<tr><td><code id="method_subclass_+3A_s.weights">s.weights</code></td>
<td>
<p>the variable containing sampling weights to be incorporated
into propensity score models and balance statistics.</p>
</td></tr>
<tr><td><code id="method_subclass_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>; whether information about the matching
process should be printed to the console.</p>
</td></tr>
<tr><td><code id="method_subclass_+3A_...">...</code></td>
<td>
<p>additional arguments that control the subclassification:
</p>

<dl>
<dt><code>subclass</code></dt><dd><p>either the number of subclasses desired
or a vector of quantiles used to divide the distance measure into
subclasses. Default is 6.</p>
</dd>
<dt><code>min.n</code></dt><dd><p> the minimum number of
units of each treatment group that are to be assigned each subclass. If the
distance measure is divided in such a way that fewer than <code>min.n</code> units
of a treatment group are assigned a given subclass, units from other
subclasses will be reassigned to fill the deficient subclass. Default is 1.
</p>
</dd>
</dl>

<p>The arguments <code>exact</code>, <code>mahvars</code>, <code>replace</code>, <code>m.order</code>, <code>caliper</code> (and related arguments), and <code>ratio</code> are ignored with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After subclassification, effect estimates can be computed separately in the
subclasses and combined, or a single marginal effect can be estimated by
using the weights in the full sample. When using the weights, the method is
sometimes referred to as marginal mean weighting through stratification
(MMWS; Hong, 2010) or fine stratification weighting (Desai et al., 2017).
The weights can be interpreted just like inverse probability weights. See <code>vignette("estimating-effects")</code> for details.
</p>
<p>Changing <code>min.n</code> can change the quality of the weights. Generally, a
low <code>min.w</code> will yield better balance because subclasses only contain
units with relatively similar distance values, but may yield higher variance
because extreme weights can occur due to there being few members of a
treatment group in some subclasses. When <code>min.n = 0</code>, some subclasses may fail to
contain units from both treatment groups, in which case all units in such subclasses
will be dropped.
</p>
<p>Note that subclassification weights can also be estimated using
<em>WeightIt</em>, which provides some additional methods for estimating
propensity scores. Where propensity score-estimation methods overlap, both
packages will yield the same weights.
</p>


<h3>Outputs</h3>

<p>All outputs described in <code><a href="#topic+matchit">matchit()</a></code> are returned with
<code>method = "subclass"</code> except that <code>match.matrix</code> is excluded and
one additional component, <code>q.cut</code>, is included, containing a vector of
the distance measure cutpoints used to define the subclasses. Note that when
<code>min.n &gt; 0</code>, the subclass assignments may not strictly obey the
quantiles listed in <code>q.cut</code>. <code>include.obj</code> is ignored.
</p>


<h3>References</h3>

<p>In a manuscript, you don't need to cite another package when
using <code>method = "subclass"</code> because the subclassification is performed
completely within <em>MatchIt</em>. For example, a sentence might read:
</p>
<p><em>Propensity score subclassification was performed using the MatchIt
package (Ho, Imai, King, &amp; Stuart, 2011) in R.</em>
</p>
<p>It may be a good idea to cite Hong (2010) or Desai et al. (2017) if the
treatment effect is estimated using the subclassification weights.
</p>
<p>Desai, R. J., Rothman, K. J., Bateman, B. . T., Hernandez-Diaz, S., &amp;
Huybrechts, K. F. (2017). A Propensity-score-based Fine Stratification
Approach for Confounding Adjustment When Exposure Is Infrequent:
Epidemiology, 28(2), 249–257. <a href="https://doi.org/10.1097/EDE.0000000000000595">doi:10.1097/EDE.0000000000000595</a>
</p>
<p>Hong, G. (2010). Marginal mean weighting through stratification: Adjustment
for selection bias in multilevel data. Journal of Educational and Behavioral
Statistics, 35(5), 499–531. <a href="https://doi.org/10.3102/1076998609359785">doi:10.3102/1076998609359785</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matchit">matchit()</a></code> for a detailed explanation of the inputs and outputs of
a call to <code>matchit()</code>.
</p>
<p><code><a href="#topic+method_full">method_full</a></code> for optimal full matching and <code><a href="#topic+method_quick">method_quick</a></code> for generalized full matching, which are similar to
subclassification except that the number of subclasses and subclass
membership are chosen to optimize the within-subclass distance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde")

# PS subclassification for the ATT with 7 subclasses
s.out1 &lt;- matchit(treat ~ age + educ + race + nodegree +
                    married + re74 + re75, data = lalonde,
                  method = "subclass", subclass = 7)
s.out1
summary(s.out1, subclass = TRUE)

# PS subclassification for the ATE with 10 subclasses
# and at least 2 units in each group per subclass
s.out2 &lt;- matchit(treat ~ age + educ + race + nodegree +
                    married + re74 + re75, data = lalonde,
                  method = "subclass", subclass = 10,
                  estimand = "ATE", min.n = 2)
s.out2
summary(s.out2)

</code></pre>

<hr>
<h2 id='plot.matchit'>Generate Balance Plots after Matching and Subclassification</h2><span id='topic+plot.matchit'></span><span id='topic+plot.matchit.subclass'></span>

<h3>Description</h3>

<p>Generates plots displaying distributional balance and overlap on covariates
and propensity scores before and after matching and subclassification. For
displaying balance solely on covariate standardized mean differences, see
<code><a href="#topic+plot.summary.matchit">plot.summary.matchit()</a></code>. The plots here can be used to assess to what
degree covariate and propensity score distributions are balanced and how
weighting and discarding affect the distribution of propensity scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matchit'
plot(x, type = "qq", interactive = TRUE, which.xs = NULL, data = NULL, ...)

## S3 method for class 'matchit.subclass'
plot(x, type = "qq", interactive = TRUE, which.xs = NULL, subclass, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.matchit_+3A_x">x</code></td>
<td>
<p>a <code>matchit</code> object; the output of a call to <code><a href="#topic+matchit">matchit()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.matchit_+3A_type">type</code></td>
<td>
<p>the type of plot to display. Options include <code>"qq"</code>,
<code>"ecdf"</code>, <code>"density"</code>, <code>"jitter"</code>, and <code>"histogram"</code>.
See Details. Default is <code>"qq"</code>. Abbreviations allowed.</p>
</td></tr>
<tr><td><code id="plot.matchit_+3A_interactive">interactive</code></td>
<td>
<p><code>logical</code>; whether the graphs should be displayed in
an interactive way. Only applies for <code>type = "qq"</code>, <code>"ecdf"</code>,
<code>"density"</code>, and <code>"jitter"</code>. See Details.</p>
</td></tr>
<tr><td><code id="plot.matchit_+3A_which.xs">which.xs</code></td>
<td>
<p>with <code>type = "qq"</code>, <code>"ecdf"</code>, or <code>"density"</code>,
for which covariate(s) plots should be displayed. Factor variables should be
named by the original variable name rather than the names of individual
dummy variables created after expansion with <code>model.matrix</code>. Can be supplied as a character vector or a one-sided formula.</p>
</td></tr>
<tr><td><code id="plot.matchit_+3A_data">data</code></td>
<td>
<p>an optional data frame containing variables named in <code>which.xs</code> but not present in the <code>matchit</code> object.</p>
</td></tr>
<tr><td><code id="plot.matchit_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="graphics.html#topic+plot">plot()</a></code> to control the appearance of the
plot. Not all options are accepted.</p>
</td></tr>
<tr><td><code id="plot.matchit_+3A_subclass">subclass</code></td>
<td>
<p>with subclassification and <code>type = "qq"</code>,
<code>"ecdf"</code>, or <code>"density"</code>, whether to display balance for
individual subclasses, and, if so, for which ones. Can be <code>TRUE</code>
(display plots for all subclasses), <code>FALSE</code> (display plots only in
aggregate), or the indices (e.g., <code>1:6</code>) of the specific subclasses for
which to display balance. When unspecified, if <code>interactive = TRUE</code>,
you will be asked for which subclasses plots are desired, and otherwise,
plots will be displayed only in aggregate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.matchit()</code> makes one of five different plots depending on the
argument supplied to <code>type</code>. The first three, <code>"qq"</code>,
<code>"ecdf"</code>, and <code>"density"</code>, assess balance on the covariates. When
<code>interactive = TRUE</code>, plots for three variables will be displayed at a
time, and the prompt in the console allows you to move on to the next set of
variables. When <code>interactive = FALSE</code>, multiple pages are plotted at
the same time, but only the last few variables will be visible in the
displayed plot. To see only a few specific variables at a time, use the
<code>which.xs</code> argument to display plots for just those variables. If fewer
than three variables are available (after expanding factors into their
dummies), <code>interactive</code> is ignored.
</p>
<p>With <code>type = "qq"</code>, empirical quantile-quantile (eQQ) plots are created
for each covariate before and after matching. The plots involve
interpolating points in the smaller group based on the weighted quantiles of
the other group. When points are approximately on the 45-degree line, the
distributions in the treatment and control groups are approximately equal.
Major deviations indicate departures from distributional balance. With
variable with fewer than 5 unique values, points are jittered to more easily
visualize counts.
</p>
<p>With <code>type = "ecdf"</code>, empirical cumulative distribution function (eCDF)
plots are created for each covariate before and after matching. Two eCDF
lines are produced in each plot: a gray one for control units and a black
one for treated units. Each point on the lines corresponds to the proportion
of units (or proportionate share of weights) less than or equal to the
corresponding covariate value (on the x-axis). Deviations between the lines
on the same plot indicates distributional imbalance between the treatment
groups for the covariate. The eCDF and eQQ statistics in <code><a href="#topic+summary.matchit">summary.matchit()</a></code>
correspond to these plots: the eCDF max (also known as the
Kolmogorov-Smirnov statistic) and mean are the largest and average vertical
distance between the lines, and the eQQ max and mean are the largest and
average horizontal distance between the lines.
</p>
<p>With <code>type = "density"</code>, density plots are created for each covariate
before and after matching. Two densities are produced in each plot: a gray
one for control units and a black one for treated units. The x-axis
corresponds to the value of the covariate and the y-axis corresponds to the
density or probability of that covariate value in the corresponding group.
For binary covariates, bar plots are produced, having the same
interpretation. Deviations between the black and gray lines represent
imbalances in the covariate distribution; when the lines coincide (i.e.,
when only the black line is visible), the distributions are identical.
</p>
<p>The last two plots, <code>"jitter"</code> and <code>"histogram"</code>, visualize the
distance (i.e., propensity score) distributions. These plots are more for
heuristic purposes since the purpose of matching is to achieve balance on
the covariates themselves, not the propensity score.
</p>
<p>With <code>type = "jitter"</code>, a jitter plot is displayed for distance values
before and after matching. This method requires a distance variable (e.g., a
propensity score) to have been estimated or supplied in the call to
<code>matchit()</code>. The plot displays individuals values for matched and
unmatched treatment and control units arranged horizontally by their
propensity scores. Points are jitter so counts are easier to see. The size
of the points increases when they receive higher weights. When
<code>interactive = TRUE</code>, you can click on points in the graph to identify
their rownames and indices to further probe extreme values, for example.
With subclassification, vertical lines representing the subclass boundaries
are overlay on the plots.
</p>
<p>With <code>type = "histogram"</code>, a histogram of distance values is displayed
for the treatment and control groups before and after matching. This method
requires a distance variable (e.g., a propensity score) to have been
estimated or supplied in the call to <code>matchit()</code>. With
subclassification, vertical lines representing the subclass boundaries are
overlay on the plots.
</p>
<p>With all methods, sampling weights are incorporated into the weights if
present.
</p>


<h3>Note</h3>

<p>Sometimes, bugs in the plotting functions can cause strange layout or
size issues. Running <code><a href="graphics.html#topic+frame">frame()</a></code> or <code><a href="grDevices.html#topic+dev.off">dev.off()</a></code> can be used to reset the
plotting pane (note the latter will delete any plots in the plot history).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.matchit">summary.matchit()</a></code> for numerical summaries of balance, including
those that rely on the eQQ and eCDF plots.
</p>
<p><code><a href="#topic+plot.summary.matchit">plot.summary.matchit()</a></code> for plotting standardized mean differences in a
Love plot.
</p>
<p><code><a href="cobalt.html#topic+bal.plot">cobalt::bal.plot()</a></code> for displaying distributional balance in several other
ways that are more easily customizable and produce <em>ggplot2</em> objects.
<em>cobalt</em> functions natively support <code>matchit</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("lalonde")

m.out &lt;- matchit(treat ~ age + educ + married +
                   race + re74, data = lalonde,
                 method = "nearest")
plot(m.out, type = "qq", interactive = FALSE,
     which.xs = ~age + educ + re74)
plot(m.out, type = "histogram")

s.out &lt;- matchit(treat ~ age + educ + married +
                   race + nodegree + re74 + re75,
                 data = lalonde, method = "subclass")
plot(s.out, type = "density", interactive = FALSE,
     which.xs = ~age + educ + re74,
     subclass = 3)
plot(s.out, type = "jitter", interactive = FALSE)

</code></pre>

<hr>
<h2 id='plot.summary.matchit'>Generate a Love Plot of Standardized Mean Differences</h2><span id='topic+plot.summary.matchit'></span>

<h3>Description</h3>

<p>Generates a Love plot, which is a dot plot with variable names on the y-axis
and standardized mean differences on the x-axis. Each point represents the
standardized mean difference of the corresponding covariate in the matched
or unmatched sample. Love plots are a simple way to display covariate
balance before and after matching. The plots are generated using
<code><a href="graphics.html#topic+dotchart">dotchart()</a></code> and <code><a href="graphics.html#topic+points">points()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.matchit'
plot(
  x,
  abs = TRUE,
  var.order = "data",
  threshold = c(0.1, 0.05),
  position = "bottomright",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.summary.matchit_+3A_x">x</code></td>
<td>
<p>a <code>summary.matchit</code> object; the output of a call to
<code><a href="#topic+summary.matchit">summary.matchit()</a></code>. The <code>standardize</code> argument must be set to
<code>TRUE</code> (which is the default) in the call to <code>summary</code>.</p>
</td></tr>
<tr><td><code id="plot.summary.matchit_+3A_abs">abs</code></td>
<td>
<p><code>logical</code>; whether the standardized mean differences should
be displayed in absolute value (<code>TRUE</code>, default) or not <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.summary.matchit_+3A_var.order">var.order</code></td>
<td>
<p>how the variables should be ordered. Allowable options
include <code>"data"</code>, ordering the variables as they appear in the
<code>summary</code> output; <code>"unmatched"</code>, ordered the variables based on
their standardized mean differences before matching; <code>"matched"</code>,
ordered the variables based on their standardized mean differences after
matching; and <code>"alphabetical"</code>, ordering the variables alphabetically.
Default is <code>"data"</code>. Abbreviations allowed.</p>
</td></tr>
<tr><td><code id="plot.summary.matchit_+3A_threshold">threshold</code></td>
<td>
<p>numeric values at which to place vertical lines indicating
a balance threshold. These can make it easier to see for which variables
balance has been achieved given a threshold. Multiple values can be supplied
to add multiple lines. When <code>abs = FALSE</code>, the lines will be displayed
on both sides of zero. The lines are drawn with <code>abline</code> with the
linetype (<code>lty</code>) argument corresponding to the order of the entered
variables (see options at <code><a href="graphics.html#topic+par">par()</a></code>). The default is <code>c(.1, .05)</code> for a
solid line (<code>lty = 1</code>) at .1 and a dashed line (<code>lty = 2</code>) at .05,
indicating acceptable and good balance, respectively. Enter a value as
<code>NA</code> to skip that value of <code>lty</code> (e.g., <code>c(NA, .05)</code> to have
only a dashed vertical line at .05).</p>
</td></tr>
<tr><td><code id="plot.summary.matchit_+3A_position">position</code></td>
<td>
<p>the position of the legend. Should be one of the allowed
keyword options supplied to <code>x</code> in <code><a href="graphics.html#topic+legend">legend()</a></code> (e.g., <code>"right"</code>,
<code>"bottomright"</code>, etc.). Default is <code>"bottomright"</code>. Set to
<code>NULL</code> for no legend to be included. Note that the legend will cover up
points if you are not careful; setting <code>var.order</code> appropriately can
help in avoiding this.</p>
</td></tr>
<tr><td><code id="plot.summary.matchit_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For matching methods other than subclassification,
<code>plot.summary.matchit</code> uses <code>x$sum.all[,"Std. Mean Diff."]</code> and
<code>x$sum.matched[,"Std. Mean Diff."]</code> as the x-axis values. For
subclassification, in addition to points for the unadjusted and aggregate
subclass balance, numerals representing balance in individual subclasses are
plotted if <code>subclass = TRUE</code> in the call to <code>summary</code>. Aggregate
subclass standardized mean differences are taken from
<code>x$sum.across[,"Std. Mean Diff."]</code> and the subclass-specific mean
differences are taken from <code>x$sum.subclass</code>.
</p>


<h3>Value</h3>

<p>A plot is displayed, and <code>x</code> is invisibly returned.
</p>


<h3>Author(s)</h3>

<p>Noah Greifer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.matchit">summary.matchit()</a></code>, <code><a href="graphics.html#topic+dotchart">dotchart()</a></code>
</p>
<p><code><a href="cobalt.html#topic+love.plot">cobalt::love.plot()</a></code> is a more flexible and sophisticated function to make
Love plots and is also natively compatible with <code>matchit</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde")
m.out &lt;- matchit(treat ~ age + educ + married +
                   race + re74, data = lalonde,
                 method = "nearest")
plot(summary(m.out, interactions = TRUE),
     var.order = "unmatched")

s.out &lt;- matchit(treat ~ age + educ + married +
                   race + nodegree + re74 + re75,
                 data = lalonde, method = "subclass")
plot(summary(s.out, subclass = TRUE),
     var.order = "unmatched", abs = FALSE)

</code></pre>

<hr>
<h2 id='rbind.matchdata'>Append matched datasets together</h2><span id='topic+rbind.matchdata'></span><span id='topic+rbind.getmatches'></span>

<h3>Description</h3>

<p>These functions are <code><a href="base.html#topic+rbind">rbind()</a></code> methods for objects resulting from calls to
<code><a href="#topic+match.data">match.data()</a></code> and <code><a href="#topic+get_matches">get_matches()</a></code>. They function nearly identically to
<code>rbind.data.frame()</code>; see Details for how they differ.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matchdata'
rbind(..., deparse.level = 1)

## S3 method for class 'getmatches'
rbind(..., deparse.level = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind.matchdata_+3A_...">...</code></td>
<td>
<p>Two or more <code>matchdata</code> or <code>getmatches</code> objects the
output of calls to <code><a href="#topic+match.data">match.data()</a></code> and <code><a href="#topic+get_matches">get_matches()</a></code>, respectively.
Supplied objects must either be all <code>matchdata</code> objects or all
<code>getmatches</code> objects.</p>
</td></tr>
<tr><td><code id="rbind.matchdata_+3A_deparse.level">deparse.level</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+rbind">rbind()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rbind()</code> appends two or more datasets row-wise. This can be useful
when matching was performed separately on subsets of the original data and
they are to be combined into a single dataset for effect estimation. Using
the regular <code>data.frame</code> method for <code>rbind()</code> would pose a
problem, however; the <code>subclass</code> variable would have repeated names
across different datasets, even though units only belong to the subclasses
in their respective datasets. <code>rbind.matchdata()</code> renames the
subclasses so that the correct subclass membership is maintained.
</p>
<p>The supplied matched datasets must be generated from the same original
dataset, that is, having the same variables in it. The added components
(e.g., weights, subclass) can be named differently in different datasets but
will be changed to have the same name in the output.
</p>
<p><code>rbind.getmatches()</code> and <code>rbind.matchdata()</code> are identical.
</p>


<h3>Value</h3>

<p>An object of the same class as those supplied to it (i.e., a
<code>matchdata</code> object if <code>matchdata</code> objects are supplied and a
<code>getmatches</code> object if <code>getmatches</code> objects are supplied).
<code><a href="base.html#topic+rbind">rbind()</a></code> is called on the objects after adjusting the variables so that the
appropriate method will be dispatched corresponding to the class of the
original data object.
</p>


<h3>Author(s)</h3>

<p>Noah Greifer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+match.data">match.data()</a></code>, <code><a href="base.html#topic+rbind">rbind()</a></code>
</p>
<p>See <code>vignettes("estimating-effects")</code> for details on using
<code>rbind()</code> for effect estimation after subsetting the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde")

# Matching based on race subsets
m.out_b &lt;- matchit(treat ~ age + educ + married +
                    nodegree + re74 + re75,
                  data = subset(lalonde, race == "black"))
md_b &lt;- match.data(m.out_b)

m.out_h &lt;- matchit(treat ~ age + educ + married +
                    nodegree + re74 + re75,
                  data = subset(lalonde, race == "hispan"))
md_h &lt;- match.data(m.out_h)

m.out_w &lt;- matchit(treat ~ age + educ + married +
                    nodegree + re74 + re75,
                  data = subset(lalonde, race == "white"))
md_w &lt;- match.data(m.out_w)

#Bind the datasets together
md_all &lt;- rbind(md_b, md_h, md_w)

#Subclass conflicts are avoided
levels(md_all$subclass)

</code></pre>

<hr>
<h2 id='summary.matchit'>View a balance summary of a <code>matchit</code> object</h2><span id='topic+summary.matchit'></span><span id='topic+summary.matchit.subclass'></span><span id='topic+print.summary.matchit'></span><span id='topic+print.summary.matchit.subclass'></span>

<h3>Description</h3>

<p>Computes and prints balance statistics for <code>matchit</code> and
<code>matchit.subclass</code> objects. Balance should be assessed to ensure the
matching or subclassification was effective at eliminating treatment group
imbalance and should be reported in the write-up of the results of the
analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matchit'
summary(
  object,
  interactions = FALSE,
  addlvariables = NULL,
  standardize = TRUE,
  data = NULL,
  pair.dist = TRUE,
  un = TRUE,
  improvement = FALSE,
  ...
)

## S3 method for class 'matchit.subclass'
summary(
  object,
  interactions = FALSE,
  addlvariables = NULL,
  standardize = TRUE,
  data = NULL,
  pair.dist = FALSE,
  subclass = FALSE,
  un = TRUE,
  improvement = FALSE,
  ...
)

## S3 method for class 'summary.matchit'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.matchit_+3A_object">object</code></td>
<td>
<p>a <code>matchit</code> object; the output of a call to <code><a href="#topic+matchit">matchit()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.matchit_+3A_interactions">interactions</code></td>
<td>
<p><code>logical</code>; whether to compute balance statistics
for two-way interactions and squares of covariates. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.matchit_+3A_addlvariables">addlvariables</code></td>
<td>
<p>additional variable for which balance statistics are to
be computed along with the covariates in the <code>matchit</code> object. Can be
entered in one of three ways: as a data frame of covariates with as many
rows as there were units in the original <code>matchit()</code> call, as a string
containing the names of variables in <code>data</code>, or as a right-sided
<code>formula</code> with the additional variables (and possibly their
transformations) found in <code>data</code>, the environment, or the
<code>matchit</code> object. Balance on squares and interactions of the additional
variables will be included if <code>interactions = TRUE</code>.</p>
</td></tr>
<tr><td><code id="summary.matchit_+3A_standardize">standardize</code></td>
<td>
<p><code>logical</code>; whether to compute standardized
(<code>TRUE</code>) or unstandardized (<code>FALSE</code>) statistics. The standardized
statistics are the standardized mean difference and the mean and maximum of
the difference in the (weighted) empirical cumulative distribution functions
(ECDFs). The unstandardized statistics are the raw mean difference and the
mean and maximum of the quantile-quantile (QQ) difference. Variance ratios
are produced either way. See Details below. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="summary.matchit_+3A_data">data</code></td>
<td>
<p>a optional data frame containing variables named in
<code>addlvariables</code> if specified as a string or formula.</p>
</td></tr>
<tr><td><code id="summary.matchit_+3A_pair.dist">pair.dist</code></td>
<td>
<p><code>logical</code>; whether to compute average absolute pair
distances. For matching methods that don't include a <code>match.matrix</code>
component in the output (i.e., exact matching, coarsened exact matching,
full matching, and subclassification), computing pair differences can take a
long time, especially for large datasets and with many covariates. For other
methods (i.e., nearest neighbor, optimal, and genetic matching), computation
is fairly quick. Default is <code>FALSE</code> for subclassification and
<code>TRUE</code> otherwise.</p>
</td></tr>
<tr><td><code id="summary.matchit_+3A_un">un</code></td>
<td>
<p><code>logical</code>; whether to compute balance statistics for the
unmatched sample. Default <code>TRUE</code>; set to <code>FALSE</code> for more concise
output.</p>
</td></tr>
<tr><td><code id="summary.matchit_+3A_improvement">improvement</code></td>
<td>
<p><code>logical</code>; whether to compute the percent reduction
in imbalance. Default <code>FALSE</code>. Ignored if <code>un = FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.matchit_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="summary.matchit_+3A_subclass">subclass</code></td>
<td>
<p>after subclassification, whether to display balance for
individual subclasses, and, if so, for which ones. Can be <code>TRUE</code>
(display balance for all subclasses), <code>FALSE</code> (display balance only in
aggregate), or the indices (e.g., <code>1:6</code>) of the specific subclasses for
which to display balance. When anything other than <code>FALSE</code>, aggregate
balance statistics will not be displayed. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.matchit_+3A_x">x</code></td>
<td>
<p>a <code>summay.matchit</code> or <code>summary.matchit.subclass</code> object;
the output of a call to <code>summary()</code>.</p>
</td></tr>
<tr><td><code id="summary.matchit_+3A_digits">digits</code></td>
<td>
<p>the number of digits to round balance statistics to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary()</code> computes a balance summary of a <code>matchit</code> object. This
include balance before and after matching or subclassification, as well as
the percent improvement in balance. The variables for which balance
statistics are computed are those included in the <code>formula</code>,
<code>exact</code>, and <code>mahvars</code> arguments to <code><a href="#topic+matchit">matchit()</a></code>, as well as the
distance measure if <code>distance</code> is was supplied as a numeric vector or
method of estimating propensity scores. The <code>X</code> component of the
<code>matchit</code> object is used to supply the covariates.
</p>
<p>The standardized mean differences are computed both before and after
matching or subclassification as the difference in treatment group means
divided by a standardization factor computed in the unmatched (original)
sample. The standardization factor depends on the argument supplied to
<code>estimand</code> in <code>matchit()</code>: for <code>"ATT"</code>, it is the standard
deviation in the treated group; for <code>"ATC"</code>, it is the standard
deviation in the control group; for <code>"ATE"</code>, it is the square root of
the average of the variances within each treatment group. The post-matching
mean difference is computed with weighted means in the treatment groups
using the matching or subclassification weights.
</p>
<p>The variance ratio is computed as the ratio of the treatment group
variances. Variance ratios are not computed for binary variables because
their variance is a function solely of their mean. After matching, weighted
variances are computed using the formula used in <code><a href="stats.html#topic+cov.wt">cov.wt()</a></code>. The percent
reduction in bias is computed using the log of the variance ratios.
</p>
<p>The eCDF difference statistics are computed by creating a (weighted) eCDF
for each group and taking the difference between them for each covariate
value. The eCDF is a function that outputs the (weighted) proportion of
units with covariate values at or lower than the input value. The maximum
eCDF difference is the same thing as the Kolmogorov-Smirnov statistic. The
values are bounded at zero and one, with values closer to zero indicating
good overlap between the covariate distributions in the treated and control
groups. For binary variables, all eCDF differences are equal to the
(weighted) difference in proportion and are computed that way.
</p>
<p>The QQ difference statistics are computed by creating two samples of the
same size by interpolating the values of the larger one. The values are
arranged in order for each sample. The QQ difference for each quantile is
the difference between the observed covariate values at that quantile
between the two groups. The difference is on the scale of the original
covariate. Values close to zero indicate good overlap between the covariate
distributions in the treated and control groups. A weighted interpolation is
used for post-matching QQ differences. For binary variables, all QQ
differences are equal to the (weighted) difference in proportion and are
computed that way.
</p>
<p>The pair distance is the average of the absolute differences of a variable
between pairs. For example, if a treated unit was paired with four control
units, that set of units would contribute four absolute differences to the
average. Within a subclass, each combination of treated and control unit
forms a pair that contributes once to the average. The pair distance is
described in Stuart and Green (2008) and is the value that is minimized when
using optimal (full) matching. When <code>standardize = TRUE</code>, the
standardized versions of the variables are used, where the standardization
factor is as described above for the standardized mean differences. Pair
distances are not computed in the unmatched sample (because there are no
pairs). Because pair distance can take a while to compute, especially with
large datasets or for many covariates, setting <code>pair.dist = FALSE</code> is
one way to speed up <code>summary()</code>.
</p>
<p>The effective sample size (ESS) is a measure of the size of a hypothetical
unweighted sample with roughly the same precision as a weighted sample. When
non-uniform matching weights are computed (e.g., as a result of full
matching, matching with replacement, or subclassification), the ESS can be
used to quantify the potential precision remaining in the matched sample.
The ESS will always be less than or equal to the matched sample size,
reflecting the loss in precision due to using the weights. With non-uniform
weights, it is printed in the sample size table; otherwise, it is removed
because it does not contain additional information above the matched sample
size.
</p>
<p>After subclassification, the aggregate balance statistics are computed using
the subclassification weights rather than averaging across subclasses.
</p>
<p>All balance statistics (except pair differences) are computed incorporating
the sampling weights supplied to <code>matchit()</code>, if any. The unadjusted
balance statistics include the sampling weights and the adjusted balance
statistics use the matching weights multiplied by the sampling weights.
</p>
<p>When printing, <code>NA</code> values are replaced with periods (<code>.</code>), and
the pair distance column in the unmatched and percent balance improvement
components of the output are omitted.
</p>


<h3>Value</h3>

<p>For <code>matchit</code> objects, a <code>summary.matchit</code> object, which
is a list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the original call to <code><a href="#topic+matchit">matchit()</a></code></p>
</td></tr>
<tr><td><code>nn</code></td>
<td>
<p>a matrix of the
sample sizes in the original (unmatched) and matched samples</p>
</td></tr>
<tr><td><code>sum.all</code></td>
<td>
<p>if <code>un = TRUE</code>, a matrix of balance statistics for each
covariate in the original (unmatched) sample</p>
</td></tr>
<tr><td><code>sum.matched</code></td>
<td>
<p>a matrix of
balance statistics for each covariate in the matched sample</p>
</td></tr>
<tr><td><code>reduction</code></td>
<td>
<p>if <code>improvement = TRUE</code>, a matrix of the percent
reduction in imbalance for each covariate in the matched sample</p>
</td></tr>
</table>
<p>For <code>match.subclass</code> objects, a <code>summary.matchit.subclass</code> object,
which is a list as above containing the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the original call to <code><a href="#topic+matchit">matchit()</a></code></p>
</td></tr>
<tr><td><code>sum.all</code></td>
<td>
<p>if <code>un = TRUE</code>, a matrix of balance statistics for each covariate in the original
sample</p>
</td></tr>
<tr><td><code>sum.subclass</code></td>
<td>
<p>if <code>subclass</code> is not <code>FALSE</code>, a list
of matrices of balance statistics for each subclass</p>
</td></tr>
<tr><td><code>sum.across</code></td>
<td>
<p>a
matrix of balance statistics for each covariate computed using the
subclassification weights</p>
</td></tr>
<tr><td><code>reduction</code></td>
<td>
<p>if <code>improvement = TRUE</code>, a
matrix of the percent reduction in imbalance for each covariate in the
matched sample</p>
</td></tr>
<tr><td><code>qn</code></td>
<td>
<p>a matrix of sample sizes within each subclass</p>
</td></tr>
<tr><td><code>nn</code></td>
<td>
<p>a matrix of the sample sizes in the original (unmatched) and
matched samples</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary()</a></code> for the generic method; <code><a href="#topic+plot.summary.matchit">plot.summary.matchit()</a></code> for
making a Love plot from <code>summary()</code> output.
</p>
<p><code><a href="cobalt.html#topic+bal.tab.matchit">cobalt::bal.tab.matchit()</a></code>, which also displays balance for <code>matchit</code>
objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde")
m.out &lt;- matchit(treat ~ age + educ + married +
                   race + re74, data = lalonde,
                 method = "nearest", exact = ~ married,
                 replace = TRUE)
summary(m.out, interactions = TRUE)

s.out &lt;- matchit(treat ~ age + educ + married +
                   race + nodegree + re74 + re75,
                 data = lalonde, method = "subclass")
summary(s.out, addlvariables = ~log(age) + I(re74==0))
summary(s.out, subclass = TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
