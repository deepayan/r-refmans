<!DOCTYPE html><html><head><title>Help for package rtables</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rtables}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_colcounts'><p>Add the column population counts to the header</p></a></li>
<li><a href='#add_combo_facet'><p>Add a combination facet in postprocessing</p></a></li>
<li><a href='#add_existing_table'><p>Add an already calculated table to the layout</p></a></li>
<li><a href='#add_overall_col'><p>Add Overall Column</p></a></li>
<li><a href='#add_overall_level'><p>Add an virtual 'overall' level to split</p></a></li>
<li><a href='#additional_fun_params'><p>Additional parameters within analysis and content functions</p>
(<code>afun/cfun</code>)</a></li>
<li><a href='#all_zero_or_na'><p>Trimming and Pruning Criteria</p></a></li>
<li><a href='#analyze'><p>Generate Rows Analyzing Variables Across Columns</p></a></li>
<li><a href='#analyze_colvars'><p>Generate Rows Analyzing Different Variables Across Columns</p></a></li>
<li><a href='#AnalyzeVarSplit'><p>Define a subset tabulation/analysis</p></a></li>
<li><a href='#append_topleft'><p>Append a description to the 'top-left' materials for the layout</p></a></li>
<li><a href='#as_html'><p>Convert an <code>rtable</code> object to a <code>shiny.tag</code> html object</p></a></li>
<li><a href='#asvec'><p>convert to a vector</p></a></li>
<li><a href='#basic_table'><p>Layout with 1 column and zero rows</p></a></li>
<li><a href='#brackets'><p>Retrieve and assign elements of a <code>TableTree</code></p></a></li>
<li><a href='#build_table'><p>Create a table from a layout and data</p></a></li>
<li><a href='#cbind_rtables'><p><code>cbind</code> two <code>rtables</code></p></a></li>
<li><a href='#cell_values'><p>Retrieve cell values by row and column path</p></a></li>
<li><a href='#CellValue'><p>Cell Value constructor</p></a></li>
<li><a href='#clayout'><p>Column information/structure accessors</p></a></li>
<li><a href='#clear_indent_mods'><p>Clear All Indent Mods from a Table</p></a></li>
<li><a href='#collect_leaves'><p>Collect leaves of a table tree</p></a></li>
<li><a href='#compare_rtables'><p>Compare two rtables</p></a></li>
<li><a href='#compat_args'><p>Compatibility Arg Conventions</p></a></li>
<li><a href='#constr_args'><p>Constructor Arg Conventions</p></a></li>
<li><a href='#cont_n_allcols'><p>Score functions for sorting <code>TableTrees</code></p></a></li>
<li><a href='#content_table'><p>Retrieve or set Content Table from a <code>TableTree</code></p></a></li>
<li><a href='#counts_wpcts'><p>Analysis function to count levels of a factor with percentage of the column total</p></a></li>
<li><a href='#custom_split_funs'><p>Custom Split Functions</p></a></li>
<li><a href='#data.frame_export'><p>Generate a Result Data Frame</p></a></li>
<li><a href='#df_to_tt'><p>Create <code>ElementaryTable</code> from data.frame</p></a></li>
<li><a href='#do_base_split'><p>Apply Basic Split (For Use In Custom Split Functions)</p></a></li>
<li><a href='#drop_facet_levels'><p>Preprocessing Functions for use in make_split_fun</p></a></li>
<li><a href='#ElementaryTable-class'><p><code>TableTree</code> classes</p></a></li>
<li><a href='#EmptyColInfo'><p>Empty table, column, split objects</p></a></li>
<li><a href='#export_as_docx'><p>Export as word document</p></a></li>
<li><a href='#export_as_tsv'><p>Create Enriched flat value table with paths</p></a></li>
<li><a href='#find_degen_struct'><p>Find degenerate (sub)structures within a table (Experimental)</p></a></li>
<li><a href='#format_rcell'><p>Format <code>rcell</code></p></a></li>
<li><a href='#gen_args'><p>General Argument Conventions</p></a></li>
<li><a href='#get_formatted_cells'><p>get formatted cells</p></a></li>
<li><a href='#head'><p>Head and tail methods</p></a></li>
<li><a href='#horizontal_sep'><p>Access or recursively set header-body separator for tables</p></a></li>
<li><a href='#in_rows'><p>Create multiple rows in analysis or summary functions</p></a></li>
<li><a href='#indent'><p>Change indentation of all <code>rrows</code> in an <code>rtable</code></p></a></li>
<li><a href='#indent_string'><p>Indent Strings</p></a></li>
<li><a href='#insert_row_at_path'><p>Insert Row at Path</p></a></li>
<li><a href='#insert_rrow'><p>[DEPRECATED] insert <code>rrows</code> at (before) a specific location</p></a></li>
<li><a href='#InstantiatedColumnInfo-class'><p><code>InstantiatedColumnInfo</code></p></a></li>
<li><a href='#internal_methods'><p>combine <code>SplitVector</code> objects</p></a></li>
<li><a href='#is_rtable'><p>Check if an object is a valid <code>rtable</code></p></a></li>
<li><a href='#label_at_path'><p>Label at Path</p></a></li>
<li><a href='#LabelRow'><p>Row classes and constructors</p></a></li>
<li><a href='#length,CellValue-method'><p>Length of a Cell value</p></a></li>
<li><a href='#list_wrap_x'><p>Returns a function that coerces the return values of f to a list</p></a></li>
<li><a href='#lyt_args'><p>Layouting Function Arg Conventions</p></a></li>
<li><a href='#make_afun'><p>Create custom analysis function wrapping existing function</p></a></li>
<li><a href='#make_col_df'><p>Column Layout Summary</p></a></li>
<li><a href='#make_split_fun'><p>Create a Custom Splitting Function</p></a></li>
<li><a href='#make_split_result'><p>Construct split result object</p></a></li>
<li><a href='#manual_cols'><p>Manual column declaration</p></a></li>
<li><a href='#ManualSplit'><p>Manually defined split</p></a></li>
<li><a href='#matrix_form,VTableTree-method'><p>Transform <code>rtable</code> to a list of matrices which can be used for outputting</p></a></li>
<li><a href='#MultiVarSplit'><p>Split between two or more different variables</p></a></li>
<li><a href='#names,VTableNodeInfo-method'><p>Names of a <code>TableTree</code></p></a></li>
<li><a href='#no_colinfo'><p>Exported for use in tern</p></a></li>
<li><a href='#nrow,VTableTree-method'><p>Table Dimensions</p></a></li>
<li><a href='#obj_avar'><p>Row attribute accessors</p></a></li>
<li><a href='#obj_name,VNodeInfo-method'><p>Methods for generics in the <code>formatters</code> package</p></a></li>
<li><a href='#pag_tt_indices'><p>Pagination of a <code>TableTree</code></p></a></li>
<li><a href='#prune_table'><p>Recursively prune a <code>TableTree</code></p></a></li>
<li><a href='#qtable_layout'><p>Generalized Frequency Table</p></a></li>
<li><a href='#rbindl_rtables'><p><code>rbind</code> <code>TableTree</code> and related objects</p></a></li>
<li><a href='#rcell'><p>Cell value constructors</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rheader'><p>Create a header</p></a></li>
<li><a href='#row_footnotes'><p>Referential Footnote Accessors</p></a></li>
<li><a href='#row_paths'><p>Return List with Table Row/Col Paths</p></a></li>
<li><a href='#row_paths_summary'><p>Print Row/Col Paths Summary</p></a></li>
<li><a href='#rrow'><p>row</p></a></li>
<li><a href='#rrowl'><p><code>rrowl</code></p></a></li>
<li><a href='#rtable'><p>Create a Table</p></a></li>
<li><a href='#sanitize_table_struct'><p>Sanitize degenerate table structures (Experimental)</p></a></li>
<li><a href='#section_div'><p>Section dividers getter and setter</p></a></li>
<li><a href='#select_all_levels'><p>Add Combination Levels to split</p></a></li>
<li><a href='#sf_args'><p>Split Function Arg Conventions</p></a></li>
<li><a href='#simple_analysis'><p>Default tabulation</p></a></li>
<li><a href='#sort_at_path'><p>Sorting a Table at a Specific Path</p></a></li>
<li><a href='#spl_context'><p>.spl_context within analysis and split functions</p></a></li>
<li><a href='#spl_context_to_disp_path'><p>Translate spl_context to Path for display in error messages</p></a></li>
<li><a href='#spl_variable'><p>Variable Associated With a Split</p></a></li>
<li><a href='#split_cols_by'><p>Declaring a column-split based on levels of a variable</p></a></li>
<li><a href='#split_cols_by_cuts'><p>Split on static or dynamic cuts of the data</p></a></li>
<li><a href='#split_cols_by_multivar'><p>Associate Multiple Variables with Columns</p></a></li>
<li><a href='#split_funcs'><p>Split functions</p></a></li>
<li><a href='#split_rows_by'><p>Add Rows according to levels of a variable</p></a></li>
<li><a href='#split_rows_by_multivar'><p>Associate Multiple Variables with Rows</p></a></li>
<li><a href='#summarize_row_groups'><p>Add a content row of summary counts</p></a></li>
<li><a href='#summarize_rows'><p>summarize_rows</p></a></li>
<li><a href='#table_shell'><p>Table shells</p></a></li>
<li><a href='#table_structure'><p>Summarize Table</p></a></li>
<li><a href='#top_left'><p>Top Left Material (Experimental)</p></a></li>
<li><a href='#tostring'><p>Convert an <code>rtable</code> object to a string</p></a></li>
<li><a href='#tree_children'><p>Retrieve or set the direct children of a Tree-style object</p></a></li>
<li><a href='#trim_levels_in_facets'><p>Trim Levels of Another Variable From Each Facet (Postprocessing split step)</p></a></li>
<li><a href='#trim_levels_to_map'><p>Trim Levels to map</p></a></li>
<li><a href='#trim_rows'><p>Trim rows from a populated table without regard for table structure</p></a></li>
<li><a href='#trim_zero_rows'><p>Trim Zero Rows</p></a></li>
<li><a href='#tt_at_path'><p>Get or set table elements at specified path</p></a></li>
<li><a href='#tt_to_flextable'><p>Create a <code>FlexTable</code> from an <code>rtables</code> table</p></a></li>
<li><a href='#update_ref_indexing'><p>Update footnote indexes on a built table</p></a></li>
<li><a href='#validate_table_struct'><p>Validate and Assert valid table structure (Experimental).</p></a></li>
<li><a href='#value_formats'><p>Value Formats</p></a></li>
<li><a href='#VarLevelSplit-class'><p>Split on levels within a variable</p></a></li>
<li><a href='#vars_in_layout'><p>List Variables required by a pre-data table layout</p></a></li>
<li><a href='#VarStaticCutSplit-class'><p>Splits for cutting by values of a numeric variable</p></a></li>
<li><a href='#Viewer'><p>Display an <code>rtable</code> object in the Viewer pane in RStudio or in a browser</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Reporting Tables</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-07</td>
</tr>
<tr>
<td>Description:</td>
<td>Reporting tables often have structure that goes beyond simple
    rectangular data. The 'rtables' package provides a framework for
    declaring complex multi-level tabulations and then applying them to
    data. This framework models both tabulation and the resulting tables
    as hierarchical, tree-like objects which support sibling sub-tables,
    arbitrary splitting or grouping of data in row and column dimensions,
    cells containing multiple values, and the concept of contextual
    summary computations. A convenient pipe-able interface is provided for
    declaring table layouts and the corresponding computations, and then
    applying them to data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a> | file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/insightsengineering/rtables">https://github.com/insightsengineering/rtables</a>,
<a href="https://insightsengineering.github.io/rtables/">https://insightsengineering.github.io/rtables/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/insightsengineering/rtables/issues">https://github.com/insightsengineering/rtables/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>formatters (&ge; 0.5.5), magrittr (&ge; 1.5), methods, R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate (&ge; 2.1.0), htmltools (&ge; 0.5.4), stats, stringi (&ge;
1.6)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>broom (&ge; 0.7.10), car (&ge; 3.0-13), dplyr (&ge; 1.0.5),
flextable (&ge; 0.8.4), knitr (&ge; 1.42), officer (&ge; 0.5.0),
r2rtf (&ge; 0.3.2), survival (&ge; 3.3-1), testthat (&ge; 3.0.4),
tibble (&ge; 3.2.1), tidyr (&ge; 1.1.3), xml2 (&ge; 1.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/verdepcheck:</td>
<td>insightsengineering/formatters,
tidyverse/magrittr, rstudio/htmltools, tidymodels/broom,
cran/car, mllg/checkmate, tidyverse/dplyr,
davidgohel/flextable, yihui/knitr, davidgohel/officer,
Merck/r2rtf, r-lib/testthat, tidyverse/tibble, tidyverse/tidyr,
r-lib/xml2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'00tabletrees.R' 'Viewer.R' 'argument_conventions.R'
'as_html.R' 'utils.R' 'colby_constructors.R'
'compare_rtables.R' 'deprecated.R' 'format_rcell.R' 'indent.R'
'make_subset_expr.R' 'simple_analysis.R' 'split_funs.R'
'make_split_fun.R' 'summary.R' 'tree_accessors.R'
'tt_afun_utils.R' 'tt_compare_tables.R' 'tt_compatibility.R'
'tt_dotabulation.R' 'tt_paginate.R' 'tt_pos_and_access.R'
'tt_showmethods.R' 'tt_sort.R' 'tt_test_afuns.R'
'tt_toString.R' 'tt_export.R' 'index_footnotes.R'
'tt_from_df.R' 'validate_table_struct.R' 'zzz_constants.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-07 23:31:36 UTC; rstudio</td>
</tr>
<tr>
<td>Author:</td>
<td>Gabriel Becker [aut] (Original creator of the package),
  Adrian Waddell [aut],
  Daniel Sabanés Bové [ctb],
  Maximilian Mordig [ctb],
  Davide Garolini [ctb],
  Emily de la Rua [ctb],
  Abinaya Yogasekaram [ctb],
  Joe Zhu [ctb, cre],
  F. Hoffmann-La Roche AG [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joe Zhu &lt;joe.zhu@roche.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-08 10:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_colcounts'>Add the column population counts to the header</h2><span id='topic+add_colcounts'></span>

<h3>Description</h3>

<p>Add the data derived column counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_colcounts(lyt, format = "(N=xx)")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_colcounts_+3A_lyt">lyt</code></td>
<td>
<p>layout object pre-data used for tabulation</p>
</td></tr>
<tr><td><code id="add_colcounts_+3A_format">format</code></td>
<td>
<p><code>FormatSpec</code>. Format associated with this split. Formats can be
declared via strings (<code>"xx.x"</code>) or function. In cases such as
<code>analyze</code> calls, they can character vectors or lists of functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is often the case that the the column counts derived from the
input data to <code>build_table</code> is not representative of the population counts.
For example, if events are counted in the table and the header should
display the number of subjects and not the total number of events. In that
case use the <code>col_count</code> argument in <code>build_table</code> to control the counts
displayed in the table header.
</p>


<h3>Value</h3>

<p>A <code>PreDataTableLayouts</code> object suitable for passing to further
layouting functions, and to <code>build_table</code>.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  add_colcounts() %&gt;%
  split_rows_by("RACE", split_fun = drop_split_levels) %&gt;%
  analyze("AGE", afun = function(x) list(min = min(x), max = max(x)))
lyt

tbl &lt;- build_table(lyt, DM)
tbl

</code></pre>

<hr>
<h2 id='add_combo_facet'>Add a combination facet in postprocessing</h2><span id='topic+add_combo_facet'></span><span id='topic+add_overall_facet'></span>

<h3>Description</h3>

<p>Add a combination facet during postprocessing stage in a custom split fun.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_combo_facet(name, label = name, levels, extra = list())

add_overall_facet(name, label, extra = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_combo_facet_+3A_name">name</code></td>
<td>
<p>character(1). Name for the resulting facet (for use in pathing, etc).</p>
</td></tr>
<tr><td><code id="add_combo_facet_+3A_label">label</code></td>
<td>
<p>character(1). Label for the resulting facet.</p>
</td></tr>
<tr><td><code id="add_combo_facet_+3A_levels">levels</code></td>
<td>
<p>character. Vector of levels to  combine within the resulting facet.</p>
</td></tr>
<tr><td><code id="add_combo_facet_+3A_extra">extra</code></td>
<td>
<p>list. Extra arguments to be passed to analysis functions applied
within the resulting facet.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>add_combo_facet</code>, the data associated with the resulting
facet will be the data associated with the facets for each level in
<code>levels</code>, <code>rbound</code> together. In particular, this means that if those levels
are overlapping, data that appears in both will be duplicated.
</p>


<h3>Value</h3>

<p>a function which can be used within the <code>post</code> argument in
<code>make_split_fun</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_split_fun">make_split_fun</a></code>
</p>
<p>Other make_custom_split: 
<code><a href="#topic+drop_facet_levels">drop_facet_levels</a>()</code>,
<code><a href="#topic+make_split_fun">make_split_fun</a>()</code>,
<code><a href="#topic+make_split_result">make_split_result</a>()</code>,
<code><a href="#topic+trim_levels_in_facets">trim_levels_in_facets</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mysplfun &lt;- make_split_fun(post = list(
  add_combo_facet("A_B",
    label = "Arms A+B",
    levels = c("A: Drug X", "B: Placebo")
  ),
  add_overall_facet("ALL", label = "All Arms")
))

lyt &lt;- basic_table(show_colcounts = TRUE) %&gt;%
  split_cols_by("ARM", split_fun = mysplfun) %&gt;%
  analyze("AGE")

tbl &lt;- build_table(lyt, DM)

</code></pre>

<hr>
<h2 id='add_existing_table'>Add an already calculated table to the layout</h2><span id='topic+add_existing_table'></span>

<h3>Description</h3>

<p>Add an already calculated table to the layout
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_existing_table(lyt, tt, indent_mod = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_existing_table_+3A_lyt">lyt</code></td>
<td>
<p>layout object pre-data used for tabulation</p>
</td></tr>
<tr><td><code id="add_existing_table_+3A_tt">tt</code></td>
<td>
<p><code>TableTree</code> (or related class). A <code>TableTree</code> object representing a
populated table.</p>
</td></tr>
<tr><td><code id="add_existing_table_+3A_indent_mod">indent_mod</code></td>
<td>
<p>numeric. Modifier for the default indent position for the
structure created by this function(subtable, content table, or row)
<em>and all of that structure's children</em>. Defaults to 0, which
corresponds to the unmodified default behavior.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>PreDataTableLayouts</code> object suitable for passing to further
layouting functions, and to <code>build_table</code>.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lyt1 &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  analyze("AGE", afun = mean, format = "xx.xx")

tbl1 &lt;- build_table(lyt1, DM)
tbl1

lyt2 &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  analyze("AGE", afun = sd, format = "xx.xx") %&gt;%
  add_existing_table(tbl1)

tbl2 &lt;- build_table(lyt2, DM)
tbl2

table_structure(tbl2)
row_paths_summary(tbl2)

</code></pre>

<hr>
<h2 id='add_overall_col'>Add Overall Column</h2><span id='topic+add_overall_col'></span>

<h3>Description</h3>

<p>This function will <em>only</em> add an overall
column at the <em>top</em> level of splitting, NOT within
existing column splits.
See <code><a href="#topic+add_overall_level">add_overall_level</a></code> for the recommended
way to add overall columns more generally within existing splits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_overall_col(lyt, label)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_overall_col_+3A_lyt">lyt</code></td>
<td>
<p>layout object pre-data used for tabulation</p>
</td></tr>
<tr><td><code id="add_overall_col_+3A_label">label</code></td>
<td>
<p>character(1). A label (not to be confused with the name) for the
object/structure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>PreDataTableLayouts</code> object suitable for passing to further
layouting functions, and to <code>build_table</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_overall_level">add_overall_level()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  add_overall_col("All Patients") %&gt;%
  analyze("AGE")
lyt

tbl &lt;- build_table(lyt, DM)
tbl

</code></pre>

<hr>
<h2 id='add_overall_level'>Add an virtual 'overall' level to split</h2><span id='topic+add_overall_level'></span>

<h3>Description</h3>

<p>Add an virtual 'overall' level to split
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_overall_level(
  valname = "Overall",
  label = valname,
  extra_args = list(),
  first = TRUE,
  trim = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_overall_level_+3A_valname">valname</code></td>
<td>
<p>character(1). 'Value' to be assigned to the implicit
all-observations split level. Defaults to <code>"Overall"</code></p>
</td></tr>
<tr><td><code id="add_overall_level_+3A_label">label</code></td>
<td>
<p>character(1). A label (not to be confused with the name) for the
object/structure.</p>
</td></tr>
<tr><td><code id="add_overall_level_+3A_extra_args">extra_args</code></td>
<td>
<p>list. Extra arguments to be passed to the tabulation
function. Element position in the list corresponds to the children of this
split. Named elements in the child-specific lists are ignored if they do
not match a formal argument of the tabulation function.</p>
</td></tr>
<tr><td><code id="add_overall_level_+3A_first">first</code></td>
<td>
<p>logical(1). Should the implicit level appear first (<code>TRUE</code>)
or last <code>FALSE</code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="add_overall_level_+3A_trim">trim</code></td>
<td>
<p>logical(1). Should splits corresponding with 0 observations be
kept when tabulating.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a closure suitable for use as a splitting function (<code>splfun</code>)
when creating a table layout
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM", split_fun = add_overall_level("All Patients",
    first = FALSE
  )) %&gt;%
  analyze("AGE")

tbl &lt;- build_table(lyt, DM)
tbl

lyt2 &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("RACE",
    split_fun = add_overall_level("All Ethnicities")
  ) %&gt;%
  summarize_row_groups(label_fstr = "%s (n)") %&gt;%
  analyze("AGE")
lyt2

tbl2 &lt;- build_table(lyt2, DM)
tbl2

</code></pre>

<hr>
<h2 id='additional_fun_params'>Additional parameters within analysis and content functions
(<code>afun/cfun</code>)</h2><span id='topic+additional_fun_params'></span>

<h3>Description</h3>

<p>It is possible to add specific parameters to <code>afun</code> and <code>cfun</code>, in <a href="#topic+analyze">analyze</a>
and <a href="#topic+summarize_row_groups">summarize_row_groups</a> respectively. These parameters grant access to
relevant information like the row split structure (see <a href="#topic+spl_context">spl_context</a>) and the
predefined baseline (<code>.ref_group</code>).
</p>


<h3>Details</h3>

<p>We list and describe here all the parameters that can be added to a custom
analysis function:
</p>

<dl>
<dt>.N_col</dt><dd><p>column-wise N (column count) for the full column being
tabulated within</p>
</dd>
<dt>.N_total</dt><dd><p>overall N (all observation count, defined as sum of column
counts) for the tabulation</p>
</dd>
<dt>.N_row</dt><dd><p>row-wise N (row group count) for the group of observations
being analyzed (i.e. with no column-based subsetting)</p>
</dd>
<dt>.df_row</dt><dd><p>data.frame for observations in the row group being analyzed
(i.e. with no column-based subsetting)</p>
</dd>
<dt>.var</dt><dd><p>variable that is analyzed</p>
</dd>
<dt>.ref_group</dt><dd><p>data.frame or vector of subset corresponding to the
<code>ref_group</code> column including subsetting defined by row-splitting.
Optional and only required/meaningful if a <code>ref_group</code> column has been
defined</p>
</dd>
<dt>.ref_full</dt><dd><p>data.frame or vector of subset corresponding to the
<code>ref_group</code> column without subsetting defined by row-splitting. Optional
and only required/meaningful if a <code>ref_group</code> column has been defined</p>
</dd>
<dt>.in_ref_col</dt><dd><p>boolean indicates if calculation is done for cells
within the reference column</p>
</dd>
<dt>.spl_context</dt><dd><p>data.frame, each row gives information about a
previous/'ancestor' split state. See <code><a href="#topic+spl_context">spl_context</a></code></p>
</dd>
<dt>.alt_df_row</dt><dd><p>data.frame, i.e. the <code>alt_count_df</code> after
row splitting. It can be used with <code>.all_col_exprs</code> and <code>.spl_context</code>
information to retrieve current faceting, but for <code>alt_count_df</code>.
It can be an empty table if all the entries are filtered out.</p>
</dd>
<dt>.alt_df</dt><dd><p>data.frame, <code>.alt_df_row</code> but filtered by columns expression.
This data present the same faceting of main data <code>df</code>. This also filters
<code>NAs</code> out if related parameters are set to (e.g. <code>inclNAs</code> in <a href="#topic+analyze">analyze</a>).
Similarly to <code>.alt_df_row</code>, it can be an empty table if all the entries
are filtered out.</p>
</dd>
<dt>.all_col_exprs</dt><dd><p>list of expressions. Each of them represents a
different column splitting.</p>
</dd>
<dt>.all_col_counts</dt><dd><p>vector of integers. Each of them represents the global
count for each column. It differs if <code>alt_counts_df</code> is used
(see <a href="#topic+build_table">build_table</a>).</p>
</dd>
</dl>



<h3>Note</h3>

<p>If any of these formals is specified incorrectly or not
present in the tabulation machinery, it will be as if missing. For
example<code>.ref_group</code> will be missing if no baseline is previously defined
during data splitting (via <code>ref_group</code> parameters in, e.g., <a href="#topic+split_rows_by">split_rows_by</a>).
Similarly, if no <code>alt_counts_df</code> is provided into <a href="#topic+build_table">build_table</a>,
<code>.alt_df_row</code> and <code>.alt_df</code> will not be present.
</p>

<hr>
<h2 id='all_zero_or_na'>Trimming and Pruning Criteria</h2><span id='topic+all_zero_or_na'></span><span id='topic+all_zero'></span><span id='topic+content_all_zeros_nas'></span><span id='topic+prune_empty_level'></span><span id='topic+prune_zeros_only'></span><span id='topic+low_obs_pruner'></span>

<h3>Description</h3>

<p>Criteria functions (and constructors thereof) for trimming and pruning
tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_zero_or_na(tr)

all_zero(tr)

content_all_zeros_nas(tt, criteria = all_zero_or_na)

prune_empty_level(tt)

prune_zeros_only(tt)

low_obs_pruner(min, type = c("sum", "mean"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_zero_or_na_+3A_tr">tr</code></td>
<td>
<p><code>TableRow</code> (or related class). A <code>TableRow</code> object representing a
single row within a populated table.</p>
</td></tr>
<tr><td><code id="all_zero_or_na_+3A_tt">tt</code></td>
<td>
<p><code>TableTree</code> (or related class). A <code>TableTree</code> object representing a
populated table.</p>
</td></tr>
<tr><td><code id="all_zero_or_na_+3A_criteria">criteria</code></td>
<td>
<p>function. Function which takes a <code>TableRow</code> object and returns
<code>TRUE</code> if that row should be removed. Defaults to
<code><a href="#topic+all_zero_or_na">all_zero_or_na</a></code></p>
</td></tr>
<tr><td><code id="all_zero_or_na_+3A_min">min</code></td>
<td>
<p>numeric(1). (<code>low_obs_pruner</code> only). Minimum aggregate count value.
Subtables whose combined/average count are below this threshold will be
pruned</p>
</td></tr>
<tr><td><code id="all_zero_or_na_+3A_type">type</code></td>
<td>
<p>character(1). How count values should be aggregated. Must be
<code>"sum"</code> (the default) or <code>"mean"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>all_zero_or_na</code> returns <code>TRUE</code> (and thus indicates
trimming/pruning) for any <em>non-<code>LabelRow</code></em> <code>TableRow</code> which contain
only any mix of <code>NA</code> (including <code>NaN</code>), <code>0</code>, <code>Inf</code> and
<code>-Inf</code> values.
</p>
<p><code>all_zero</code> returns <code>TRUE</code> for any non-Label row which
contains only (non-missing) zero values.
</p>
<p><code>content_all_zeros_nas</code> Prunes a subtable if a) it has a
content table with exactly one row in it, and b) <code>all_zero_or_na</code>
returns <code>TRUE</code> for that single content row. In practice, when the
default summary/content function is used, this represents pruning any
subtable which corresponds to an empty set of the input data (e.g., because
a factor variable was used in <code><a href="#topic+split_rows_by">split_rows_by</a></code> but not all
levels were present in the data).
</p>
<p><code>prune_empty_level</code> combines <code>all_zero_or_na</code> behavior for
<code>TableRow</code> objects, <code>content_all_zeros_nas</code> on
<code>content_table(tt)</code> for <code>TableTree</code> objects, and an additional
check that returns <code>TRUE</code> if the <code>tt</code> has no children.
</p>
<p><code>prune_zeros_only</code> behaves as <code>prune_empty_level</code> does,
except that like <code>all_zero</code> it prunes only in the case of all
non-missing zero values.
</p>
<p><code>low_obs_pruner</code> is a <em>constructor function</em> which, when
called, returns a pruning criteria function which will prune on content
rows by comparing sum or mean (dictated by <code>type</code>) of the count
portions of the cell values (defined as the first value per cell regardless
of how many values per cell there are) against <code>min</code>.
</p>


<h3>Value</h3>

<p>A logical value indicating whether <code>tr</code> should be included
(<code>TRUE</code>) or pruned (<code>FALSE</code>) during pruning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prune_table">prune_table()</a></code>, <code><a href="#topic+trim_rows">trim_rows()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adsl &lt;- ex_adsl
levels(adsl$SEX) &lt;- c(levels(ex_adsl$SEX), "OTHER")
adsl$AGE[adsl$SEX == "UNDIFFERENTIATED"] &lt;- 0
adsl$BMRKR1 &lt;- 0

tbl_to_prune &lt;- basic_table() %&gt;%
  analyze("BMRKR1") %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("SEX") %&gt;%
  summarize_row_groups() %&gt;%
  split_rows_by("STRATA1") %&gt;%
  summarize_row_groups() %&gt;%
  analyze("AGE") %&gt;%
  build_table(adsl)

tbl_to_prune %&gt;% prune_table(all_zero_or_na)

tbl_to_prune %&gt;% prune_table(all_zero)

tbl_to_prune %&gt;% prune_table(content_all_zeros_nas)

tbl_to_prune %&gt;% prune_table(prune_empty_level)

tbl_to_prune %&gt;% prune_table(prune_zeros_only)

min_prune &lt;- low_obs_pruner(70, "sum")
tbl_to_prune %&gt;% prune_table(min_prune)

</code></pre>

<hr>
<h2 id='analyze'>Generate Rows Analyzing Variables Across Columns</h2><span id='topic+analyze'></span>

<h3>Description</h3>

<p>Adding <em>analyzed variables</em> to our table layout defines the primary
tabulation to be performed. We do this by adding calls to <code>analyze</code>
and/or <code><a href="#topic+analyze_colvars">analyze_colvars</a></code> into our layout pipeline. As with adding
further splitting, the tabulation will occur at the current/next level of
nesting by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze(
  lyt,
  vars,
  afun = simple_analysis,
  var_labels = vars,
  table_names = vars,
  format = NULL,
  na_str = NA_character_,
  nested = TRUE,
  inclNAs = FALSE,
  extra_args = list(),
  show_labels = c("default", "visible", "hidden"),
  indent_mod = 0L,
  section_div = NA_character_
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze_+3A_lyt">lyt</code></td>
<td>
<p>layout object pre-data used for tabulation</p>
</td></tr>
<tr><td><code id="analyze_+3A_vars">vars</code></td>
<td>
<p>character vector. Multiple variable names.</p>
</td></tr>
<tr><td><code id="analyze_+3A_afun">afun</code></td>
<td>
<p>function. Analysis function, must take <code>x</code> or <code>df</code> as
its first parameter. Can optionally take other parameters which will be
populated by the tabulation framework. See Details in
<code><a href="#topic+analyze">analyze</a></code>.</p>
</td></tr>
<tr><td><code id="analyze_+3A_var_labels">var_labels</code></td>
<td>
<p>character. Variable labels for 1 or more variables</p>
</td></tr>
<tr><td><code id="analyze_+3A_table_names">table_names</code></td>
<td>
<p>character. Names for the tables representing each atomic
analysis. Defaults to <code>var</code>.</p>
</td></tr>
<tr><td><code id="analyze_+3A_format">format</code></td>
<td>
<p><code>FormatSpec</code>. Format associated with this split. Formats can be
declared via strings (<code>"xx.x"</code>) or function. In cases such as
<code>analyze</code> calls, they can character vectors or lists of functions.</p>
</td></tr>
<tr><td><code id="analyze_+3A_na_str">na_str</code></td>
<td>
<p>character(1). String that should be displayed when the value of <code>x</code> is missing.
Defaults to <code>"NA"</code>.</p>
</td></tr>
<tr><td><code id="analyze_+3A_nested">nested</code></td>
<td>
<p>boolean. Should this layout instruction be applied within the
existing layout structure <em>if possible</em> (<code>TRUE</code>, the default) or as a
new top-level element ('FALSE). Ignored if it would nest a split underneath
analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="analyze_+3A_inclnas">inclNAs</code></td>
<td>
<p>boolean. Should observations with NA in the <code>var</code>
variable(s) be included when performing this analysis. Defaults to
<code>FALSE</code></p>
</td></tr>
<tr><td><code id="analyze_+3A_extra_args">extra_args</code></td>
<td>
<p>list. Extra arguments to be passed to the tabulation
function. Element position in the list corresponds to the children of this
split. Named elements in the child-specific lists are ignored if they do
not match a formal argument of the tabulation function.</p>
</td></tr>
<tr><td><code id="analyze_+3A_show_labels">show_labels</code></td>
<td>
<p>character(1). Should the variable labels for corresponding
to the variable(s) in <code>vars</code> be visible in the resulting table.</p>
</td></tr>
<tr><td><code id="analyze_+3A_indent_mod">indent_mod</code></td>
<td>
<p>numeric. Modifier for the default indent position for the
structure created by this function(subtable, content table, or row)
<em>and all of that structure's children</em>. Defaults to 0, which
corresponds to the unmodified default behavior.</p>
</td></tr>
<tr><td><code id="analyze_+3A_section_div">section_div</code></td>
<td>
<p>character(1). String which should be repeated as a section
divider after each group defined by this split instruction, or
<code>NA_character_</code> (the default) for no section divider.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When non-NULL <code>format</code> is used to specify formats for all generated
rows, and can be a character vector, a function, or a list of functions. It
will be repped out to the number of rows once this is known during the
tabulation process, but will be overridden by formats specified within
<code>rcell</code> calls in <code>afun</code>.
</p>
<p>The analysis function (<code>afun</code>) should take as its first parameter either
<code>x</code> or <code>df</code>. Which of these the function accepts changes the
behavior when tabulation is performed.
</p>

<ul>
<li>
<p>If <code>afun</code>'s first parameter is x, it will receive the corresponding
subset <em>vector</em> of data from the relevant column (from <code>var</code>
here) of the raw data being used to build the table.

</p>
</li>
<li>
<p>If <code>afun</code>'s first parameter is <code>df</code>, it will receive the
corresponding subset <em>data.frame</em> (i.e. all columns) of the raw data
being tabulated

</p>
</li></ul>

<p>In addition to differentiation on the first argument, the analysis function
can optionally accept a number of other parameters which, <em>if and only
if</em> present in the formals will be passed to the function by the tabulation
machinery. These are listed and described in <code><a href="#topic+additional_fun_params">additional_fun_params</a></code>.
</p>


<h3>Value</h3>

<p>A <code>PreDataTableLayouts</code> object suitable for passing to further
layouting functions, and to <code>build_table</code>.
</p>


<h3>Note</h3>

<p>None of the arguments described in the Details section
can be overridden via <code>extra_args</code> or when calling
<code><a href="#topic+make_afun">make_afun</a></code>. <code>.N_col</code> and <code>.N_total</code> can
be overridden via the <code>col_counts</code> argument to
<code><a href="#topic+build_table">build_table</a></code>. Alternative values for the others
must be calculated within <code>afun</code> based on a combination
of extra arguments and the unmodified values provided by the
tabulation framework.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  analyze("AGE", afun = list_wrap_x(summary), format = "xx.xx")
lyt

tbl &lt;- build_table(lyt, DM)
tbl

lyt2 &lt;- basic_table() %&gt;%
  split_cols_by("Species") %&gt;%
  analyze(head(names(iris), -1), afun = function(x) {
    list(
      "mean / sd" = rcell(c(mean(x), sd(x)), format = "xx.xx (xx.xx)"),
      "range" = rcell(diff(range(x)), format = "xx.xx")
    )
  })
lyt2

tbl2 &lt;- build_table(lyt2, iris)
tbl2

</code></pre>

<hr>
<h2 id='analyze_colvars'>Generate Rows Analyzing Different Variables Across Columns</h2><span id='topic+analyze_colvars'></span>

<h3>Description</h3>

<p>Generate Rows Analyzing Different Variables Across Columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze_colvars(
  lyt,
  afun,
  format = NULL,
  na_str = NA_character_,
  nested = TRUE,
  extra_args = list(),
  indent_mod = 0L,
  inclNAs = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze_colvars_+3A_lyt">lyt</code></td>
<td>
<p>layout object pre-data used for tabulation</p>
</td></tr>
<tr><td><code id="analyze_colvars_+3A_afun">afun</code></td>
<td>
<p>function or list. Function(s) to be used to calculate the values
in each column.  The list will be repped out as needed and matched by
position with the columns during tabulation. This functions accepts the same
parameters as <a href="#topic+analyze">analyze</a> like <code>afun</code> and <code>format</code>. For further information see
<code><a href="#topic+additional_fun_params">additional_fun_params</a></code>.</p>
</td></tr>
<tr><td><code id="analyze_colvars_+3A_format">format</code></td>
<td>
<p><code>FormatSpec</code>. Format associated with this split. Formats can be
declared via strings (<code>"xx.x"</code>) or function. In cases such as
<code>analyze</code> calls, they can character vectors or lists of functions.</p>
</td></tr>
<tr><td><code id="analyze_colvars_+3A_na_str">na_str</code></td>
<td>
<p>character(1). String that should be displayed when the value of <code>x</code> is missing.
Defaults to <code>"NA"</code>.</p>
</td></tr>
<tr><td><code id="analyze_colvars_+3A_nested">nested</code></td>
<td>
<p>boolean. Should this layout instruction be applied within the
existing layout structure <em>if possible</em> (<code>TRUE</code>, the default) or as a
new top-level element ('FALSE). Ignored if it would nest a split underneath
analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="analyze_colvars_+3A_extra_args">extra_args</code></td>
<td>
<p>list. Extra arguments to be passed to the tabulation
function. Element position in the list corresponds to the children of this
split. Named elements in the child-specific lists are ignored if they do
not match a formal argument of the tabulation function.</p>
</td></tr>
<tr><td><code id="analyze_colvars_+3A_indent_mod">indent_mod</code></td>
<td>
<p>numeric. Modifier for the default indent position for the
structure created by this function(subtable, content table, or row)
<em>and all of that structure's children</em>. Defaults to 0, which
corresponds to the unmodified default behavior.</p>
</td></tr>
<tr><td><code id="analyze_colvars_+3A_inclnas">inclNAs</code></td>
<td>
<p>boolean. Should observations with NA in the <code>var</code>
variable(s) be included when performing this analysis. Defaults to
<code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>PreDataTableLayouts</code> object suitable for passing to further
layouting functions, and to <code>build_table</code>.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>


<h3>See Also</h3>

<p><code><a href="#topic+split_cols_by_multivar">split_cols_by_multivar()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
ANL &lt;- DM %&gt;% mutate(value = rnorm(n()), pctdiff = runif(n()))

## toy example where we take the mean of the first variable and the
## count of &gt;.5 for the second.
colfuns &lt;- list(
  function(x) rcell(mean(x), format = "xx.x"),
  function(x) rcell(sum(x &gt; .5), format = "xx")
)

lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_cols_by_multivar(c("value", "pctdiff")) %&gt;%
  split_rows_by("RACE",
    split_label = "ethnicity",
    split_fun = drop_split_levels
  ) %&gt;%
  summarize_row_groups() %&gt;%
  analyze_colvars(afun = colfuns)
lyt

tbl &lt;- build_table(lyt, ANL)
tbl

lyt2 &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_cols_by_multivar(c("value", "pctdiff"),
    varlabels = c("Measurement", "Pct Diff")
  ) %&gt;%
  split_rows_by("RACE",
    split_label = "ethnicity",
    split_fun = drop_split_levels
  ) %&gt;%
  summarize_row_groups() %&gt;%
  analyze_colvars(afun = mean, format = "xx.xx")

tbl2 &lt;- build_table(lyt2, ANL)
tbl2

</code></pre>

<hr>
<h2 id='AnalyzeVarSplit'>Define a subset tabulation/analysis</h2><span id='topic+AnalyzeVarSplit'></span><span id='topic+AnalyzeColVarSplit'></span><span id='topic+AnalyzeMultiVars'></span>

<h3>Description</h3>

<p>Define a subset tabulation/analysis
</p>
<p>Define a subset tabulation/analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AnalyzeVarSplit(
  var,
  split_label = var,
  afun,
  defrowlab = "",
  cfun = NULL,
  cformat = NULL,
  split_format = NULL,
  split_na_str = NA_character_,
  inclNAs = FALSE,
  split_name = var,
  extra_args = list(),
  indent_mod = 0L,
  label_pos = "default",
  cvar = "",
  section_div = NA_character_
)

AnalyzeColVarSplit(
  afun,
  defrowlab = "",
  cfun = NULL,
  cformat = NULL,
  split_format = NULL,
  split_na_str = NA_character_,
  inclNAs = FALSE,
  split_name = "",
  extra_args = list(),
  indent_mod = 0L,
  label_pos = "default",
  cvar = "",
  section_div = NA_character_
)

AnalyzeMultiVars(
  var,
  split_label = "",
  afun,
  defrowlab = "",
  cfun = NULL,
  cformat = NULL,
  split_format = NULL,
  split_na_str = NA_character_,
  inclNAs = FALSE,
  .payload = NULL,
  split_name = NULL,
  extra_args = list(),
  indent_mod = 0L,
  child_labels = c("default", "topleft", "visible", "hidden"),
  child_names = var,
  cvar = "",
  section_div = NA_character_
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AnalyzeVarSplit_+3A_var">var</code></td>
<td>
<p>string, variable name</p>
</td></tr>
<tr><td><code id="AnalyzeVarSplit_+3A_split_label">split_label</code></td>
<td>
<p>string. Label string to be associated with the table
generated by the split. Not to be confused with labels assigned to each
child (which are based on the data and type of split during tabulation).</p>
</td></tr>
<tr><td><code id="AnalyzeVarSplit_+3A_afun">afun</code></td>
<td>
<p>function. Analysis function, must take <code>x</code> or <code>df</code> as
its first parameter. Can optionally take other parameters which will be
populated by the tabulation framework. See Details in
<code><a href="#topic+analyze">analyze</a></code>.</p>
</td></tr>
<tr><td><code id="AnalyzeVarSplit_+3A_defrowlab">defrowlab</code></td>
<td>
<p>character. Default row labels if they are not specified by
the return value of <code>afun</code></p>
</td></tr>
<tr><td><code id="AnalyzeVarSplit_+3A_cfun">cfun</code></td>
<td>
<p>list/function/NULL. tabulation function(s) for creating content
rows. Must accept <code>x</code> or <code>df</code> as first parameter. Must accept
<code>labelstr</code> as the second argument. Can optionally accept all optional
arguments accepted by analysis functions. See <code><a href="#topic+analyze">analyze</a></code>.</p>
</td></tr>
<tr><td><code id="AnalyzeVarSplit_+3A_cformat">cformat</code></td>
<td>
<p>format spec. Format for content rows</p>
</td></tr>
<tr><td><code id="AnalyzeVarSplit_+3A_split_format">split_format</code></td>
<td>
<p><code>FormatSpec</code>. Default format associated with the split
being created.</p>
</td></tr>
<tr><td><code id="AnalyzeVarSplit_+3A_split_na_str">split_na_str</code></td>
<td>
<p>character. NA string vector for use with <code>split_format</code>.</p>
</td></tr>
<tr><td><code id="AnalyzeVarSplit_+3A_inclnas">inclNAs</code></td>
<td>
<p>boolean. Should observations with NA in the <code>var</code>
variable(s) be included when performing this analysis. Defaults to
<code>FALSE</code></p>
</td></tr>
<tr><td><code id="AnalyzeVarSplit_+3A_split_name">split_name</code></td>
<td>
<p>string. Name associated with this split (for pathing, etc)</p>
</td></tr>
<tr><td><code id="AnalyzeVarSplit_+3A_extra_args">extra_args</code></td>
<td>
<p>list. Extra arguments to be passed to the tabulation
function. Element position in the list corresponds to the children of this
split. Named elements in the child-specific lists are ignored if they do
not match a formal argument of the tabulation function.</p>
</td></tr>
<tr><td><code id="AnalyzeVarSplit_+3A_indent_mod">indent_mod</code></td>
<td>
<p>numeric. Modifier for the default indent position for the
structure created by this function(subtable, content table, or row)
<em>and all of that structure's children</em>. Defaults to 0, which
corresponds to the unmodified default behavior.</p>
</td></tr>
<tr><td><code id="AnalyzeVarSplit_+3A_label_pos">label_pos</code></td>
<td>
<p>character(1). Location the variable label should be
displayed, Accepts <code>"hidden"</code> (default for non-analyze row splits), <code>"visible"</code>,
<code>"topleft"</code>, and - for analyze splits only - <code>"default"</code>.  For analyze calls,
<code>"default"</code> indicates that the variable should be visible if and only if
multiple variables are analyzed at the same level of nesting.</p>
</td></tr>
<tr><td><code id="AnalyzeVarSplit_+3A_cvar">cvar</code></td>
<td>
<p>character(1). The variable, if any, which the content function
should accept. Defaults to NA.</p>
</td></tr>
<tr><td><code id="AnalyzeVarSplit_+3A_section_div">section_div</code></td>
<td>
<p>character(1). String which should be repeated as a section
divider after each group defined by this split instruction, or
<code>NA_character_</code> (the default) for no section divider.</p>
</td></tr>
<tr><td><code id="AnalyzeVarSplit_+3A_.payload">.payload</code></td>
<td>
<p>Used internally, not intended to be set by end users.</p>
</td></tr>
<tr><td><code id="AnalyzeVarSplit_+3A_child_labels">child_labels</code></td>
<td>
<p>string. One of <code>"default"</code>, <code>"visible"</code>,
<code>"hidden"</code>. What should the display behavior be for the  labels (i.e.
label rows) of the children of this split. Defaults to <code>"default"</code>
which flags the label row as visible only if the child has 0 content rows.</p>
</td></tr>
<tr><td><code id="AnalyzeVarSplit_+3A_child_names">child_names</code></td>
<td>
<p>character. Names to be given to the sub splits contained
by a compound split (typically a <code>AnalyzeMultiVars</code> split object).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>AnalyzeVarSplit</code> object.
</p>
<p>An <code>AnalyzeMultiVars</code> split object.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>

<hr>
<h2 id='append_topleft'>Append a description to the 'top-left' materials for the layout</h2><span id='topic+append_topleft'></span>

<h3>Description</h3>

<p>This function <em>adds</em> <code>newlines</code> to the current
set of &quot;top-left materials&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append_topleft(lyt, newlines)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append_topleft_+3A_lyt">lyt</code></td>
<td>
<p>layout object pre-data used for tabulation</p>
</td></tr>
<tr><td><code id="append_topleft_+3A_newlines">newlines</code></td>
<td>
<p>character. The new line(s) to be added to the materials</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adds <code>newlines</code> to the set of strings representing the 'top-left'
materials declared in the layout (the content displayed to the left of
the column labels when the resulting tables are printed).
</p>
<p>Top-left material strings are stored and then displayed <em>exactly as is</em>,
no structure or indenting is applied to them either when they are added
or when they are displayed.
</p>


<h3>Value</h3>

<p>A <code>PreDataTableLayouts</code> object suitable for passing to further
layouting functions, and to <code>build_table</code>.
</p>


<h3>Note</h3>

<p>Currently, where in the construction of the layout this is called
makes no difference, as it is independent of the actual splitting keywords.
This may change in the future.
</p>
<p>This function is experimental, its name and the details of
its behavior are subject to change in future versions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+top_left">top_left()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

DM2 &lt;- DM %&gt;% mutate(RACE = factor(RACE), SEX = factor(SEX))

lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_cols_by("SEX") %&gt;%
  split_rows_by("RACE") %&gt;%
  append_topleft("Ethnicity") %&gt;%
  analyze("AGE") %&gt;%
  append_topleft("  Age")

tbl &lt;- build_table(lyt, DM2)
tbl

</code></pre>

<hr>
<h2 id='as_html'>Convert an <code>rtable</code> object to a <code>shiny.tag</code> html object</h2><span id='topic+as_html'></span>

<h3>Description</h3>

<p>The returned <code>html</code> object can be immediately used in <code>shiny</code> and <code>rmarkdown</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_html(
  x,
  width = NULL,
  class_table = "table table-condensed table-hover",
  class_tr = NULL,
  class_th = NULL,
  link_label = NULL,
  bold = c("header"),
  header_sep_line = TRUE,
  no_spaces_between_cells = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_html_+3A_x">x</code></td>
<td>
<p><code>rtable</code> object</p>
</td></tr>
<tr><td><code id="as_html_+3A_width">width</code></td>
<td>
<p>a string to indicate the desired width of the table. Common input formats include a
percentage of the viewer window width (e.g. <code>"100%"</code>) or a distance value (e.g. <code>"300px"</code>).
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="as_html_+3A_class_table">class_table</code></td>
<td>
<p>class for <code>table</code> tag</p>
</td></tr>
<tr><td><code id="as_html_+3A_class_tr">class_tr</code></td>
<td>
<p>class for <code>tr</code> tag</p>
</td></tr>
<tr><td><code id="as_html_+3A_class_th">class_th</code></td>
<td>
<p>class for <code>th</code> tag</p>
</td></tr>
<tr><td><code id="as_html_+3A_link_label">link_label</code></td>
<td>
<p>link anchor label (not including <code style="white-space: pre;">&#8288;tab:&#8288;</code> prefix) for the table.</p>
</td></tr>
<tr><td><code id="as_html_+3A_bold">bold</code></td>
<td>
<p>elements in table output that should be bold. Options are <code>"main_title"</code>, <code>"subtitles"</code>,
<code>"header"</code>, <code>"row_names"</code>, <code>"label_rows"</code>, and <code>"content_rows"</code> (which includes any non-label rows).
Defaults to <code>"header"</code>.</p>
</td></tr>
<tr><td><code id="as_html_+3A_header_sep_line">header_sep_line</code></td>
<td>
<p>whether a black line should be printed to under the table header. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="as_html_+3A_no_spaces_between_cells">no_spaces_between_cells</code></td>
<td>
<p>whether spaces between table cells should be collapsed. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>shiny.tag</code> object representing <code>x</code> in HTML.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tbl &lt;- rtable(
  header = LETTERS[1:3],
  format = "xx",
  rrow("r1", 1, 2, 3),
  rrow("r2", 4, 3, 2, indent = 1),
  rrow("r3", indent = 2)
)

as_html(tbl)

as_html(tbl, class_table = "table", class_tr = "row")

as_html(tbl, bold = c("header", "row_names"))

## Not run: 
Viewer(tbl)

## End(Not run)

</code></pre>

<hr>
<h2 id='asvec'>convert to a vector</h2><span id='topic+asvec'></span><span id='topic+as.vector+2CVTableTree-method'></span>

<h3>Description</h3>

<p>Convert an <code>rtables</code> framework object into a vector, if possible.
This is unlikely to be useful in realistic scenarios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'VTableTree'
as.vector(x, mode = "any")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asvec_+3A_x">x</code></td>
<td>
<p>ANY. The object to be converted to a vector</p>
</td></tr>
<tr><td><code id="asvec_+3A_mode">mode</code></td>
<td>
<p>character(1). Passed on to <code><a href="base.html#topic+as.vector">as.vector</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the chosen mode (or an error is raised if more than one row was present).
</p>


<h3>Note</h3>

<p>This only works for a table with a single row or a row object.
</p>

<hr>
<h2 id='basic_table'>Layout with 1 column and zero rows</h2><span id='topic+basic_table'></span>

<h3>Description</h3>

<p>Every layout must start with a basic table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basic_table(
  title = "",
  subtitles = character(),
  main_footer = character(),
  prov_footer = character(),
  header_section_div = NA_character_,
  show_colcounts = FALSE,
  colcount_format = "(N=xx)",
  inset = 0L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basic_table_+3A_title">title</code></td>
<td>
<p>character(1). Main title (<code><a href="formatters.html#topic+main_title">main_title()</a></code>) is a single string.
Ignored for subtables.</p>
</td></tr>
<tr><td><code id="basic_table_+3A_subtitles">subtitles</code></td>
<td>
<p>character. Subtitles (<code><a href="formatters.html#topic+subtitles">subtitles()</a></code>) can be vector of strings, where
every element is printed in a separate line. Ignored for subtables.</p>
</td></tr>
<tr><td><code id="basic_table_+3A_main_footer">main_footer</code></td>
<td>
<p>character. Main global (non-referential) footer materials
(<code><a href="formatters.html#topic+main_footer">main_footer()</a></code>). If it is a vector of strings, they will be printed on separate
lines.</p>
</td></tr>
<tr><td><code id="basic_table_+3A_prov_footer">prov_footer</code></td>
<td>
<p>character. Provenance-related global footer materials
(<code><a href="formatters.html#topic+prov_footer">prov_footer()</a></code>). It can be also a vector of strings, printed on different lines.
Generally should not be modified by hand.</p>
</td></tr>
<tr><td><code id="basic_table_+3A_header_section_div">header_section_div</code></td>
<td>
<p>character(1). String which will be used to divide the header
from the table. See <code><a href="#topic+header_section_div">header_section_div()</a></code> for getter and setter of these.
Please consider changing last element of <code><a href="#topic+section_div">section_div()</a></code> when concatenating
tables that need a divider between them.</p>
</td></tr>
<tr><td><code id="basic_table_+3A_show_colcounts">show_colcounts</code></td>
<td>
<p>logical(1). Should column counts be displayed in the
resulting table when this layout is applied to data</p>
</td></tr>
<tr><td><code id="basic_table_+3A_colcount_format">colcount_format</code></td>
<td>
<p>character(1). Format for use when displaying the
column counts. Must be 1d, or 2d where one component is a percent. See
details.</p>
</td></tr>
<tr><td><code id="basic_table_+3A_inset">inset</code></td>
<td>
<p>numeric(1). Number of spaces to inset the table header, table
body, referential footnotes, and main_footer, as compared to alignment
of title, subtitle, and provenance footer. Defaults to 0 (no inset).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>colcount_format</code> is ignored if <code>show_colcounts</code> is <code>FALSE</code> (the default).
When <code>show_colcounts</code> is <code>TRUE</code>, and <code>colcount_format</code> is 2-dimensional with
a percent component, the value component for the percent is always populated
with <code>1</code> (i.e. 100%). 1d formats are used to render the counts exactly as they
normally would be, while 2d formats which don't include a percent, and all 3d
formats result in an error. Formats in the form of functions are not supported for
<code>colcount</code> format. See <code><a href="formatters.html#topic+list_formats">formatters::list_valid_format_labels()</a></code> for
the list of valid format labels to select from.
</p>


<h3>Value</h3>

<p>A <code>PreDataTableLayouts</code> object suitable for passing to further
layouting functions, and to <code>build_table</code>.
</p>


<h3>Note</h3>


<ul>
<li><p> Because percent components in <code>colcount_format</code> are <em>always</em>
populated with the value 1, we can get arguably strange results, such as
that individual arm columns and a combined &quot;all patients&quot; column all
list &quot;100%&quot; as their percentage, even though the individual arm columns
represent strict subsets of the all patients column.
</p>
</li>
<li><p> Note that subtitles (<code><a href="formatters.html#topic+subtitles">subtitles()</a></code>) and footers (<code><a href="formatters.html#topic+main_footer">main_footer()</a></code> and <code><a href="formatters.html#topic+prov_footer">prov_footer()</a></code>)
that spans more than one line can be supplied as a character vector to maintain
indentation on multiple lines.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
lyt &lt;- basic_table() %&gt;%
  analyze("AGE", afun = mean)

tbl &lt;- build_table(lyt, DM)
tbl

lyt2 &lt;- basic_table(
  title = "Title of table",
  subtitles = c("a number", "of subtitles"),
  main_footer = "test footer",
  prov_footer = paste(
    "test.R program, executed at",
    Sys.time()
  )
) %&gt;%
  split_cols_by("ARM") %&gt;%
  analyze("AGE", mean)

tbl2 &lt;- build_table(lyt2, DM)
tbl2

lyt3 &lt;- basic_table(
  show_colcounts = TRUE,
  colcount_format = "xx. (xx.%)"
) %&gt;%
  split_cols_by("ARM")

</code></pre>

<hr>
<h2 id='brackets'>Retrieve and assign elements of a <code>TableTree</code></h2><span id='topic+brackets'></span><span id='topic++5B+3C-+2CVTableTree+2CANY+2CANY+2Clist-method'></span><span id='topic++5B+2CVTableTree+2Clogical+2Clogical-method'></span>

<h3>Description</h3>

<p>Retrieve and assign elements of a <code>TableTree</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'VTableTree,ANY,ANY,list'
x[i, j, ...] &lt;- value

## S4 method for signature 'VTableTree,logical,logical'
x[i, j, ..., drop = FALSE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brackets_+3A_x">x</code></td>
<td>
<p><code>TableTree</code></p>
</td></tr>
<tr><td><code id="brackets_+3A_i">i</code></td>
<td>
<p>index</p>
</td></tr>
<tr><td><code id="brackets_+3A_j">j</code></td>
<td>
<p>index</p>
</td></tr>
<tr><td><code id="brackets_+3A_...">...</code></td>
<td>
<p>Includes
</p>

<dl>
<dt><em>keep_topleft</em></dt><dd><p>logical(1) (<code>[</code> only) Should the <code>top-left</code>
material for the table be retained after subsetting. Defaults to <code>TRUE</code> if
all rows are included (i.e. subsetting was by column), and drops it otherwise.</p>
</dd>
<dt><em>keep_titles</em></dt><dd><p>logical(1) Should title information be retained. Defaults to <code>FALSE</code>.</p>
</dd>
<dt><em>keep_footers</em></dt><dd><p>logical(1) Should non-referential footer
information be retained. Defaults to <code>keep_titles</code>.</p>
</dd>
<dt><em>reindex_refs</em></dt><dd><p>logical(1). Should referential footnotes be
re-indexed as if the resulting subset is the entire table. Defaults to
<code>TRUE</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="brackets_+3A_value">value</code></td>
<td>
<p>Replacement value (list, <code>TableRow</code>, or <code>TableTree</code>)</p>
</td></tr>
<tr><td><code id="brackets_+3A_drop">drop</code></td>
<td>
<p>logical(1). Should the value in the cell be returned if one
cell is selected by the combination of <code>i</code> and <code>j</code>. It is not possible
to return a vector of values. To do so please consider using <code><a href="#topic+cell_values">cell_values()</a></code>.
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>by default, subsetting drops the information about title, subtitle,
main footer, provenance footer, and <code>topleft</code>. If only a column is selected
and all rows are kept, the <code>topleft</code> information remains as default. Any
referential footnote is kept whenever the subset table contains the
referenced element.
</p>


<h3>Value</h3>

<p>a <code>TableTree</code> (or <code>ElementaryTable</code>) object, unless a
single cell was selected with <code>drop=TRUE</code>, in which case the (possibly
multi-valued) fully stripped raw value of the selected cell.
</p>


<h3>Note</h3>

<p>subsetting always preserve the original order, even if provided
indexes do not preserve it. If sorting is needed, please consider
using <code>sort_at_path()</code>. Also note that <code>character</code> indices are treated as paths,
not vectors of names in both <code>[</code> and <code style="white-space: pre;">&#8288;[&lt;-&#8288;</code>.
</p>


<h3>See Also</h3>

<p>Regarding sorting: <code>sort_at_path()</code> and how to understand path
structure: <code>summarize_row_groups()</code>, and <code>summarize_col_groups()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lyt &lt;- basic_table(
  title = "Title",
  subtitles = c("Sub", "titles"),
  prov_footer = "prov footer",
  main_footer = "main footer"
) %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("SEX") %&gt;%
  analyze(c("AGE"))

tbl &lt;- build_table(lyt, DM)
top_left(tbl) &lt;- "Info"
tbl

# As default header, footer, and topleft information is lost
tbl[1, ]
tbl[1:2, 2]

# Also boolean filters can work
tbl[, c(FALSE, TRUE, FALSE)]

# If drop = TRUE, the content values are directly retrieved
tbl[2, 1]
tbl[2, 1, drop = TRUE]

# Drop works also if vectors are selected, but not matrices
tbl[, 1, drop = TRUE]
tbl[2, , drop = TRUE]
tbl[1, 1, drop = TRUE] # NULL because it is a label row
tbl[2, 1:2, drop = TRUE] # vectors can be returned only with cell_values()
tbl[1:2, 1:2, drop = TRUE] # no dropping because it is a matrix

# If all rows are selected, topleft is kept by default
tbl[, 2]
tbl[, 1]

# It is possible to deselect values
tbl[-2, ]
tbl[, -1]

# Values can be reassigned
tbl[2, 1] &lt;- rcell(999)
tbl[2, ] &lt;- list(rrow("FFF", 888, 666, 777))
tbl[6, ] &lt;- list(-111, -222, -333)
tbl

# We can keep some information from the original table if we need
tbl[1, 2, keep_titles = TRUE]
tbl[1, 2, keep_footers = TRUE, keep_titles = FALSE]
tbl[1, 2, keep_footers = FALSE, keep_titles = TRUE]
tbl[1, 2, keep_footers = TRUE]
tbl[1, 2, keep_topleft = TRUE]

# Keeps the referential footnotes when subset contains them
fnotes_at_path(tbl, rowpath = c("SEX", "M", "AGE", "Mean")) &lt;- "important"
tbl[4, 1]
tbl[2, 1] # None present

# We can reindex referential footnotes, so that the new table does not depend
#  on the original one
fnotes_at_path(tbl, rowpath = c("SEX", "U", "AGE", "Mean")) &lt;- "important"
tbl[, 1] # both present
tbl[5:6, 1] # {1} because it has been indexed again
tbl[5:6, 1, reindex_refs = FALSE] # {2} -&gt; not reindexed

# Note that order can not be changed with subsetting
tbl[c(4, 3, 1), c(3, 1)] # It preserves order and wanted selection

</code></pre>

<hr>
<h2 id='build_table'>Create a table from a layout and data</h2><span id='topic+build_table'></span>

<h3>Description</h3>

<p>Layouts are used to describe a table pre-data. <code>build_table</code> is used to
create a table using a layout and a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_table(
  lyt,
  df,
  alt_counts_df = NULL,
  col_counts = NULL,
  col_total = if (is.null(alt_counts_df)) nrow(df) else nrow(alt_counts_df),
  topleft = NULL,
  hsep = default_hsep(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_table_+3A_lyt">lyt</code></td>
<td>
<p>layout object pre-data used for tabulation</p>
</td></tr>
<tr><td><code id="build_table_+3A_df">df</code></td>
<td>
<p>dataset (<code>data.frame</code> or <code>tibble</code>)</p>
</td></tr>
<tr><td><code id="build_table_+3A_alt_counts_df">alt_counts_df</code></td>
<td>
<p>dataset (<code>data.frame</code> or <code>tibble</code>). Alternative full data
the rtables framework will use (<em>only</em>) when calculating column
counts.</p>
</td></tr>
<tr><td><code id="build_table_+3A_col_counts">col_counts</code></td>
<td>
<p>numeric (or <code>NULL</code>). Deprecated. If non-null, column counts
which override those calculated automatically during tabulation. Must
specify &quot;counts&quot; for <em>all</em> resulting columns if non-NULL. <code>NA</code>
elements will be replaced with the automatically calculated counts.</p>
</td></tr>
<tr><td><code id="build_table_+3A_col_total">col_total</code></td>
<td>
<p>integer(1). The total observations across all columns.
Defaults to <code>nrow(df)</code>.</p>
</td></tr>
<tr><td><code id="build_table_+3A_topleft">topleft</code></td>
<td>
<p>character. Override values for the &quot;top left&quot; material to be
displayed during printing.</p>
</td></tr>
<tr><td><code id="build_table_+3A_hsep">hsep</code></td>
<td>
<p>character(1). Set of character(s) to be repeated as the separator
between the header and body of the table when rendered as text. Defaults to
a connected horizontal line (unicode 2014) in locals that use a UTF
charset, and to <code>-</code> elsewhere (with a once per session warning). See
<code><a href="formatters.html#topic+default_horizontal_sep">formatters::set_default_hsep()</a></code> for further information.</p>
</td></tr>
<tr><td><code id="build_table_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>alt_counts_df</code> is specified, column counts are calculated by
applying the exact column subsetting expressions determined when applying
column splitting to the main data (<code>df</code>) to <code>alt_counts_df</code> and
counting the observations in each resulting subset.
</p>
<p>In particular, this means that in the case of splitting based on cuts of the
data, any dynamic cuts will have been calculated based on <code>df</code> and
simply re-used for the count calculation.
</p>


<h3>Value</h3>

<p>A <code>TableTree</code> or <code>ElementaryTable</code> object representing the
table created by performing the tabulations declared in <code>lyt</code> to the
data <code>df</code>.
</p>


<h3>Note</h3>

<p>When overriding the column counts or totals care must be taken that,
e.g., <code>length()</code> or <code>nrow()</code> are not called within tabulation functions,
because those will NOT give the overridden counts. Writing/using tabulation
functions which accept <code>.N_col</code> and <code>.N_total</code> or do not rely on
column counts at all (even implicitly) is the only way to ensure overridden
counts are fully respected.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lyt &lt;- basic_table() %&gt;%
  split_cols_by("Species") %&gt;%
  analyze("Sepal.Length", afun = function(x) {
    list(
      "mean (sd)" = rcell(c(mean(x), sd(x)), format = "xx.xx (xx.xx)"),
      "range" = diff(range(x))
    )
  })

lyt

tbl &lt;- build_table(lyt, iris)
tbl

# analyze multiple variables
lyt2 &lt;- basic_table() %&gt;%
  split_cols_by("Species") %&gt;%
  analyze(c("Sepal.Length", "Petal.Width"), afun = function(x) {
    list(
      "mean (sd)" = rcell(c(mean(x), sd(x)), format = "xx.xx (xx.xx)"),
      "range" = diff(range(x))
    )
  })

tbl2 &lt;- build_table(lyt2, iris)
tbl2

# an example more relevant for clinical trials with column counts
lyt3 &lt;- basic_table(show_colcounts = TRUE) %&gt;%
  split_cols_by("ARM") %&gt;%
  analyze("AGE", afun = function(x) {
    setNames(as.list(fivenum(x)), c(
      "minimum", "lower-hinge", "median",
      "upper-hinge", "maximum"
    ))
  })

tbl3 &lt;- build_table(lyt3, DM)
tbl3

tbl4 &lt;- build_table(lyt3, subset(DM, AGE &gt; 40))
tbl4

# with column counts calculated based on different data
miniDM &lt;- DM[sample(1:NROW(DM), 100), ]
tbl5 &lt;- build_table(lyt3, DM, alt_counts_df = miniDM)
tbl5

tbl6 &lt;- build_table(lyt3, DM, col_counts = 1:3)
tbl6
</code></pre>

<hr>
<h2 id='cbind_rtables'><code>cbind</code> two <code>rtables</code></h2><span id='topic+cbind_rtables'></span>

<h3>Description</h3>

<p><code>cbind</code> two <code>rtables</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbind_rtables(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cbind_rtables_+3A_x">x</code></td>
<td>
<p>A table or row object</p>
</td></tr>
<tr><td><code id="cbind_rtables_+3A_...">...</code></td>
<td>
<p>1 or more further objects of the same class as <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formal table object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rtable(c("A", "B"), rrow("row 1", 1, 2), rrow("row 2", 3, 4))

y &lt;- rtable("C", rrow("row 1", 5), rrow("row 2", 6))

z &lt;- rtable("D", rrow("row 1", 9), rrow("row 2", 10))

t1 &lt;- cbind_rtables(x, y)
t1

t2 &lt;- cbind_rtables(x, y, z)
t2

col_paths_summary(t1)
col_paths_summary(t2)

</code></pre>

<hr>
<h2 id='cell_values'>Retrieve cell values by row and column path</h2><span id='topic+cell_values'></span><span id='topic+value_at'></span><span id='topic+value_at+2CVTableTree-method'></span>

<h3>Description</h3>

<p>Retrieve cell values by row and column path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell_values(tt, rowpath = NULL, colpath = NULL, omit_labrows = TRUE)

value_at(tt, rowpath = NULL, colpath = NULL)

## S4 method for signature 'VTableTree'
value_at(tt, rowpath = NULL, colpath = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell_values_+3A_tt">tt</code></td>
<td>
<p><code>TableTree</code> (or related class). A <code>TableTree</code> object representing a
populated table.</p>
</td></tr>
<tr><td><code id="cell_values_+3A_rowpath">rowpath</code></td>
<td>
<p>character. Path in row-split space to the desired row(s). Can
include <code>"@content"</code>.</p>
</td></tr>
<tr><td><code id="cell_values_+3A_colpath">colpath</code></td>
<td>
<p>character. Path in column-split space to the desired
column(s). Can include <code>"*"</code>.</p>
</td></tr>
<tr><td><code id="cell_values_+3A_omit_labrows">omit_labrows</code></td>
<td>
<p>logical(1). Should label rows underneath <code>rowpath</code>
be omitted (<code>TRUE</code>, the default), or return empty lists of cell
&quot;values&quot; (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>for <code>cell_values</code>, a <em>list</em> (regardless of the type of
value the cells hold). if <code>rowpath</code> defines a path to a single row,
<code>cell_values</code> returns the list of cell values for that row, otherwise
a list of such lists, one for each row captured underneath <code>rowpath</code>.
This occurs after subsetting to <code>colpath</code> has occurred.
</p>
<p>For <code>value_at</code> the &quot;unwrapped&quot; value of a single cell, or an error, if
the combination of <code>rowpath</code> and <code>colpath</code> do not define the
location of a single cell in <code>tt</code>.
</p>


<h3>Note</h3>

<p><code>cell_values</code> will return a single cell's value wrapped in a list.
Use <code>value_at</code> to receive the &quot;bare&quot; cell value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_cols_by("SEX") %&gt;%
  split_rows_by("RACE") %&gt;%
  summarize_row_groups() %&gt;%
  split_rows_by("STRATA1") %&gt;%
  analyze("AGE")

library(dplyr) ## for mutate
tbl &lt;- build_table(lyt, DM %&gt;%
  mutate(SEX = droplevels(SEX), RACE = droplevels(RACE)))

row_paths_summary(tbl)
col_paths_summary(tbl)

cell_values(
  tbl, c("RACE", "ASIAN", "STRATA1", "B"),
  c("ARM", "A: Drug X", "SEX", "F")
)

# it's also possible to access multiple values by being less specific
cell_values(
  tbl, c("RACE", "ASIAN", "STRATA1"),
  c("ARM", "A: Drug X", "SEX", "F")
)
cell_values(tbl, c("RACE", "ASIAN"), c("ARM", "A: Drug X", "SEX", "M"))


## any arm, male columns from the ASIAN content (i.e. summary) row
cell_values(
  tbl, c("RACE", "ASIAN", "@content"),
  c("ARM", "B: Placebo", "SEX", "M")
)
cell_values(
  tbl, c("RACE", "ASIAN", "@content"),
  c("ARM", "*", "SEX", "M")
)

## all columns
cell_values(tbl, c("RACE", "ASIAN", "STRATA1", "B"))

## all columns for the Combination arm
cell_values(
  tbl, c("RACE", "ASIAN", "STRATA1", "B"),
  c("ARM", "C: Combination")
)

cvlist &lt;- cell_values(
  tbl, c("RACE", "ASIAN", "STRATA1", "B", "AGE", "Mean"),
  c("ARM", "B: Placebo", "SEX", "M")
)
cvnolist &lt;- value_at(
  tbl, c("RACE", "ASIAN", "STRATA1", "B", "AGE", "Mean"),
  c("ARM", "B: Placebo", "SEX", "M")
)
stopifnot(identical(cvlist[[1]], cvnolist))
</code></pre>

<hr>
<h2 id='CellValue'>Cell Value constructor</h2><span id='topic+CellValue'></span>

<h3>Description</h3>

<p>Cell Value constructor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CellValue(
  val,
  format = NULL,
  colspan = 1L,
  label = NULL,
  indent_mod = NULL,
  footnotes = NULL,
  align = NULL,
  format_na_str = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CellValue_+3A_val">val</code></td>
<td>
<p>ANY. value in the cell exactly as it should be passed to a
formatter or returned when extracted</p>
</td></tr>
<tr><td><code id="CellValue_+3A_format">format</code></td>
<td>
<p><code>FormatSpec</code>. Format associated with this split. Formats can be
declared via strings (<code>"xx.x"</code>) or function. In cases such as
<code>analyze</code> calls, they can character vectors or lists of functions.</p>
</td></tr>
<tr><td><code id="CellValue_+3A_colspan">colspan</code></td>
<td>
<p>integer(1). Column span value.</p>
</td></tr>
<tr><td><code id="CellValue_+3A_label">label</code></td>
<td>
<p>character(1). A label (not to be confused with the name) for the
object/structure.</p>
</td></tr>
<tr><td><code id="CellValue_+3A_indent_mod">indent_mod</code></td>
<td>
<p>numeric. Modifier for the default indent position for the
structure created by this function(subtable, content table, or row)
<em>and all of that structure's children</em>. Defaults to 0, which
corresponds to the unmodified default behavior.</p>
</td></tr>
<tr><td><code id="CellValue_+3A_footnotes">footnotes</code></td>
<td>
<p>list or <code>NULL</code>. Referential footnote messages for the cell.</p>
</td></tr>
<tr><td><code id="CellValue_+3A_align">align</code></td>
<td>
<p>character(1) or <code>NULL</code>. Alignment the value should be rendered with.
It defaults to <code>"center"</code> if <code>NULL</code> is used. See <code><a href="formatters.html#topic+list_formats">formatters::list_valid_aligns()</a></code>
for currently supported alignments.</p>
</td></tr>
<tr><td><code id="CellValue_+3A_format_na_str">format_na_str</code></td>
<td>
<p>character(1). String which should be displayed when
formatted if this cell's value(s) are all NA.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object representing the value within a single cell within a
populated table. The underlying structure of this object is an
implementation detail and should not be relied upon beyond calling
accessors for the class.
</p>

<hr>
<h2 id='clayout'>Column information/structure accessors</h2><span id='topic+clayout'></span><span id='topic+clayout+2CVTableNodeInfo-method'></span><span id='topic+clayout+2CPreDataTableLayouts-method'></span><span id='topic+clayout+2CANY-method'></span><span id='topic+clayout+3C-'></span><span id='topic+clayout+3C-+2CPreDataTableLayouts-method'></span><span id='topic+col_info'></span><span id='topic+col_info+2CVTableNodeInfo-method'></span><span id='topic+col_info+3C-'></span><span id='topic+col_info+3C-+2CTableRow-method'></span><span id='topic+col_info+3C-+2CElementaryTable-method'></span><span id='topic+col_info+3C-+2CTableTree-method'></span><span id='topic+coltree'></span><span id='topic+coltree+2CInstantiatedColumnInfo-method'></span><span id='topic+coltree+2CPreDataTableLayouts-method'></span><span id='topic+coltree+2CPreDataColLayout-method'></span><span id='topic+coltree+2CLayoutColTree-method'></span><span id='topic+coltree+2CVTableTree-method'></span><span id='topic+coltree+2CTableRow-method'></span><span id='topic+col_exprs'></span><span id='topic+col_exprs+2CPreDataTableLayouts-method'></span><span id='topic+col_exprs+2CPreDataColLayout-method'></span><span id='topic+col_exprs+2CInstantiatedColumnInfo-method'></span><span id='topic+col_counts'></span><span id='topic+col_counts+2CInstantiatedColumnInfo-method'></span><span id='topic+col_counts+2CVTableNodeInfo-method'></span><span id='topic+col_counts+3C-'></span><span id='topic+col_counts+3C-+2CInstantiatedColumnInfo-method'></span><span id='topic+col_counts+3C-+2CVTableNodeInfo-method'></span><span id='topic+col_total'></span><span id='topic+col_total+2CInstantiatedColumnInfo-method'></span><span id='topic+col_total+2CVTableNodeInfo-method'></span><span id='topic+col_total+3C-'></span><span id='topic+col_total+3C-+2CInstantiatedColumnInfo-method'></span><span id='topic+col_total+3C-+2CVTableNodeInfo-method'></span>

<h3>Description</h3>

<p>Column information/structure accessors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clayout(obj)

## S4 method for signature 'VTableNodeInfo'
clayout(obj)

## S4 method for signature 'PreDataTableLayouts'
clayout(obj)

## S4 method for signature 'ANY'
clayout(obj)

clayout(object) &lt;- value

## S4 replacement method for signature 'PreDataTableLayouts'
clayout(object) &lt;- value

col_info(obj)

## S4 method for signature 'VTableNodeInfo'
col_info(obj)

col_info(obj) &lt;- value

## S4 replacement method for signature 'TableRow'
col_info(obj) &lt;- value

## S4 replacement method for signature 'ElementaryTable'
col_info(obj) &lt;- value

## S4 replacement method for signature 'TableTree'
col_info(obj) &lt;- value

coltree(obj, df = NULL, rtpos = TreePos())

## S4 method for signature 'InstantiatedColumnInfo'
coltree(obj, df = NULL, rtpos = TreePos())

## S4 method for signature 'PreDataTableLayouts'
coltree(obj, df = NULL, rtpos = TreePos())

## S4 method for signature 'PreDataColLayout'
coltree(obj, df = NULL, rtpos = TreePos())

## S4 method for signature 'LayoutColTree'
coltree(obj, df = NULL, rtpos = TreePos())

## S4 method for signature 'VTableTree'
coltree(obj, df = NULL, rtpos = TreePos())

## S4 method for signature 'TableRow'
coltree(obj, df = NULL, rtpos = TreePos())

col_exprs(obj, df = NULL)

## S4 method for signature 'PreDataTableLayouts'
col_exprs(obj, df = NULL)

## S4 method for signature 'PreDataColLayout'
col_exprs(obj, df = NULL)

## S4 method for signature 'InstantiatedColumnInfo'
col_exprs(obj, df = NULL)

col_counts(obj, path = NULL)

## S4 method for signature 'InstantiatedColumnInfo'
col_counts(obj, path = NULL)

## S4 method for signature 'VTableNodeInfo'
col_counts(obj, path = NULL)

col_counts(obj, path = NULL) &lt;- value

## S4 replacement method for signature 'InstantiatedColumnInfo'
col_counts(obj, path = NULL) &lt;- value

## S4 replacement method for signature 'VTableNodeInfo'
col_counts(obj, path = NULL) &lt;- value

col_total(obj)

## S4 method for signature 'InstantiatedColumnInfo'
col_total(obj)

## S4 method for signature 'VTableNodeInfo'
col_total(obj)

col_total(obj) &lt;- value

## S4 replacement method for signature 'InstantiatedColumnInfo'
col_total(obj) &lt;- value

## S4 replacement method for signature 'VTableNodeInfo'
col_total(obj) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clayout_+3A_obj">obj</code></td>
<td>
<p>ANY. The object for the accessor to access or modify</p>
</td></tr>
<tr><td><code id="clayout_+3A_object">object</code></td>
<td>
<p>The object to modify in-place</p>
</td></tr>
<tr><td><code id="clayout_+3A_value">value</code></td>
<td>
<p>The new value</p>
</td></tr>
<tr><td><code id="clayout_+3A_df">df</code></td>
<td>
<p>data.frame/NULL. Data to use if the column information is being
generated from a  Pre-Data layout object</p>
</td></tr>
<tr><td><code id="clayout_+3A_rtpos">rtpos</code></td>
<td>
<p><code>TreePos</code>. Root position.</p>
</td></tr>
<tr><td><code id="clayout_+3A_path">path</code></td>
<td>
<p>character or NULL. <code>col_counts</code> getter and setter only.
Path (in column structure).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>LayoutColTree</code> object.
</p>
<p>Various column information, depending on the accessor used.
</p>

<hr>
<h2 id='clear_indent_mods'>Clear All Indent Mods from a Table</h2><span id='topic+clear_indent_mods'></span><span id='topic+clear_indent_mods+2CVTableTree-method'></span><span id='topic+clear_indent_mods+2CTableRow-method'></span>

<h3>Description</h3>

<p>Clear All Indent Mods from a Table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clear_indent_mods(tt)

## S4 method for signature 'VTableTree'
clear_indent_mods(tt)

## S4 method for signature 'TableRow'
clear_indent_mods(tt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clear_indent_mods_+3A_tt">tt</code></td>
<td>
<p><code>TableTree</code> (or related class). A <code>TableTree</code> object representing a
populated table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same class as <code>tt</code>, with all indent mods set to zero.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lyt1 &lt;- basic_table() %&gt;%
  summarize_row_groups("STUDYID", label_fstr = "overall summary") %&gt;%
  split_rows_by("AEBODSYS", child_labels = "visible") %&gt;%
  summarize_row_groups("STUDYID", label = "subgroup summary") %&gt;%
  analyze("AGE", indent_mod = -1L)

tbl1 &lt;- build_table(lyt1, ex_adae)
tbl1
clear_indent_mods(tbl1)
</code></pre>

<hr>
<h2 id='collect_leaves'>Collect leaves of a table tree</h2><span id='topic+collect_leaves'></span>

<h3>Description</h3>

<p>Collect leaves of a table tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collect_leaves(tt, incl.cont = TRUE, add.labrows = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collect_leaves_+3A_tt">tt</code></td>
<td>
<p><code>TableTree</code> (or related class). A <code>TableTree</code> object representing a
populated table.</p>
</td></tr>
<tr><td><code id="collect_leaves_+3A_incl.cont">incl.cont</code></td>
<td>
<p>logical. Include rows from content tables within the tree. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="collect_leaves_+3A_add.labrows">add.labrows</code></td>
<td>
<p>logical. Include label rows. Defaults to <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>TableRow</code> objects for all rows in the table
</p>

<hr>
<h2 id='compare_rtables'>Compare two rtables</h2><span id='topic+compare_rtables'></span>

<h3>Description</h3>

<p>Prints a matrix where <code>.</code> means cell matches, <code>X</code> means cell does
cells do not match, <code>+</code> cell (row) is missing, and <code>-</code> cell (row)
should not be there. If <code>structure</code> is set to <code>TRUE</code>, <code>C</code> indicates
columnar structure mismatch, <code>R</code> indicates row-structure mismatch, and
<code>S</code> indicates mismatch in both row and column structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_rtables(
  object,
  expected,
  tol = 0.1,
  comp.attr = TRUE,
  structure = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_rtables_+3A_object">object</code></td>
<td>
<p><code>rtable</code> to test</p>
</td></tr>
<tr><td><code id="compare_rtables_+3A_expected">expected</code></td>
<td>
<p><code>rtable</code> expected</p>
</td></tr>
<tr><td><code id="compare_rtables_+3A_tol">tol</code></td>
<td>
<p>numerical tolerance</p>
</td></tr>
<tr><td><code id="compare_rtables_+3A_comp.attr">comp.attr</code></td>
<td>
<p>boolean. Compare format of cells. Other attributes are
silently ignored.</p>
</td></tr>
<tr><td><code id="compare_rtables_+3A_structure">structure</code></td>
<td>
<p>boolean. Should structure (in the form of column and row
paths to cells) be compared. Currently defaults to <code>FALSE</code>, but this is
subject to change in future versions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of class <code>"rtables_diff"</code> representing the differences
between <code>object</code> and <code>expected</code> as described above.
</p>


<h3>Note</h3>

<p>In its current form <code>compare_rtables</code> does not take structure into
account, only row and cell position.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
t1 &lt;- rtable(header = c("A", "B"), format = "xx", rrow("row 1", 1, 2))
t2 &lt;- rtable(header = c("A", "B", "C"), format = "xx", rrow("row 1", 1, 2, 3))

compare_rtables(object = t1, expected = t2)

if (interactive()) {
  Viewer(t1, t2)
}

expected &lt;- rtable(
  header = c("ARM A\nN=100", "ARM B\nN=200"),
  format = "xx",
  rrow("row 1", 10, 15),
  rrow(),
  rrow("section title"),
  rrow("row colspan", rcell(c(.345543, .4432423), colspan = 2, format = "(xx.xx, xx.xx)"))
)

expected

object &lt;- rtable(
  header = c("ARM A\nN=100", "ARM B\nN=200"),
  format = "xx",
  rrow("row 1", 10, 15),
  rrow("section title"),
  rrow("row colspan", rcell(c(.345543, .4432423), colspan = 2, format = "(xx.xx, xx.xx)"))
)

compare_rtables(object, expected, comp.attr = FALSE)

object &lt;- rtable(
  header = c("ARM A\nN=100", "ARM B\nN=200"),
  format = "xx",
  rrow("row 1", 10, 15),
  rrow(),
  rrow("section title")
)

compare_rtables(object, expected)

object &lt;- rtable(
  header = c("ARM A\nN=100", "ARM B\nN=200"),
  format = "xx",
  rrow("row 1", 14, 15.03),
  rrow(),
  rrow("section title"),
  rrow("row colspan", rcell(c(.345543, .4432423), colspan = 2, format = "(xx.xx, xx.xx)"))
)

compare_rtables(object, expected)

object &lt;- rtable(
  header = c("ARM A\nN=100", "ARM B\nN=200"),
  format = "xx",
  rrow("row 1", 10, 15),
  rrow(),
  rrow("section title"),
  rrow("row colspan", rcell(c(.345543, .4432423), colspan = 2, format = "(xx.x, xx.x)"))
)

compare_rtables(object, expected)
</code></pre>

<hr>
<h2 id='compat_args'>Compatibility Arg Conventions</h2><span id='topic+compat_args'></span>

<h3>Description</h3>

<p>Compatibility Arg Conventions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compat_args(.lst, row.name, format, indent, label, inset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compat_args_+3A_.lst">.lst</code></td>
<td>
<p>list. An already-collected list of arguments to be used instead
of the elements of <code>...</code>. Arguments passed via <code>...</code> will be
ignored if this is specified.</p>
</td></tr>
<tr><td><code id="compat_args_+3A_row.name">row.name</code></td>
<td>
<p>if <code>NULL</code> then an empty string is used as
<code>row.name</code> of the <code><a href="#topic+rrow">rrow</a></code>.</p>
</td></tr>
<tr><td><code id="compat_args_+3A_format">format</code></td>
<td>
<p>character(1) or function. The format label (string) or
formatter function to apply to the cell values passed via <code>...</code>. See
<code><a href="formatters.html#topic+list_valid_format_labels">list_valid_format_labels</a></code> for currently supported
format labels.</p>
</td></tr>
<tr><td><code id="compat_args_+3A_indent">indent</code></td>
<td>
<p>deprecated.</p>
</td></tr>
<tr><td><code id="compat_args_+3A_label">label</code></td>
<td>
<p>character(1). A label (not to be confused with the name) for the
object/structure.</p>
</td></tr>
<tr><td><code id="compat_args_+3A_inset">inset</code></td>
<td>
<p>integer(1). The table inset for the row or table being
constructed. See <code><a href="formatters.html#topic+table_inset">table_inset</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL (this is an argument template dummy function)
</p>


<h3>See Also</h3>

<p>Other conventions: 
<code><a href="#topic+constr_args">constr_args</a>()</code>,
<code><a href="#topic+gen_args">gen_args</a>()</code>,
<code><a href="#topic+lyt_args">lyt_args</a>()</code>,
<code><a href="#topic+sf_args">sf_args</a>()</code>
</p>

<hr>
<h2 id='constr_args'>Constructor Arg Conventions</h2><span id='topic+constr_args'></span>

<h3>Description</h3>

<p>Constructor Arg Conventions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constr_args(
  kids,
  cont,
  lev,
  iscontent,
  cinfo,
  labelrow,
  vals,
  cspan,
  label_pos,
  cindent_mod,
  cvar,
  label,
  cextra_args,
  child_names,
  title,
  subtitles,
  main_footer,
  prov_footer,
  footnotes,
  page_title,
  page_prefix,
  section_div,
  trailing_section_div,
  split_na_str,
  cna_str,
  inset,
  table_inset,
  header_section_div
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constr_args_+3A_kids">kids</code></td>
<td>
<p>list. List of direct children.</p>
</td></tr>
<tr><td><code id="constr_args_+3A_cont">cont</code></td>
<td>
<p><code>ElementaryTable</code>. Content table.</p>
</td></tr>
<tr><td><code id="constr_args_+3A_lev">lev</code></td>
<td>
<p>integer. Nesting level (roughly, indentation level in practical
terms).</p>
</td></tr>
<tr><td><code id="constr_args_+3A_iscontent">iscontent</code></td>
<td>
<p>logical. Is the <code>TableTree</code>/<code>ElementaryTable</code> being constructed
the content table for another <code>TableTree</code>.</p>
</td></tr>
<tr><td><code id="constr_args_+3A_cinfo">cinfo</code></td>
<td>
<p><code>InstantiatedColumnInfo</code> (or NULL). Column structure for the
object being created.</p>
</td></tr>
<tr><td><code id="constr_args_+3A_labelrow">labelrow</code></td>
<td>
<p><code>LabelRow</code>. The <code>LabelRow</code> object to assign to this Table.
Constructed from <code>label</code> by default if not specified.</p>
</td></tr>
<tr><td><code id="constr_args_+3A_vals">vals</code></td>
<td>
<p>list. cell values for the row</p>
</td></tr>
<tr><td><code id="constr_args_+3A_cspan">cspan</code></td>
<td>
<p>integer. Column span. <code>1</code> indicates no spanning.</p>
</td></tr>
<tr><td><code id="constr_args_+3A_label_pos">label_pos</code></td>
<td>
<p>character(1). Location the variable label should be
displayed, Accepts <code>"hidden"</code> (default for non-analyze row splits), <code>"visible"</code>,
<code>"topleft"</code>, and - for analyze splits only - <code>"default"</code>.  For analyze calls,
<code>"default"</code> indicates that the variable should be visible if and only if
multiple variables are analyzed at the same level of nesting.</p>
</td></tr>
<tr><td><code id="constr_args_+3A_cindent_mod">cindent_mod</code></td>
<td>
<p>numeric(1). The indent modifier for the content tables
generated by this split.</p>
</td></tr>
<tr><td><code id="constr_args_+3A_cvar">cvar</code></td>
<td>
<p>character(1). The variable, if any, which the content function
should accept. Defaults to NA.</p>
</td></tr>
<tr><td><code id="constr_args_+3A_label">label</code></td>
<td>
<p>character(1). A label (not to be confused with the name) for the
object/structure.</p>
</td></tr>
<tr><td><code id="constr_args_+3A_cextra_args">cextra_args</code></td>
<td>
<p>list. Extra arguments to be passed to the content function
when tabulating row group summaries.</p>
</td></tr>
<tr><td><code id="constr_args_+3A_child_names">child_names</code></td>
<td>
<p>character. Names to be given to the sub splits contained
by a compound split (typically a <code>AnalyzeMultiVars</code> split object).</p>
</td></tr>
<tr><td><code id="constr_args_+3A_title">title</code></td>
<td>
<p>character(1). Main title (<code><a href="formatters.html#topic+main_title">main_title()</a></code>) is a single string.
Ignored for subtables.</p>
</td></tr>
<tr><td><code id="constr_args_+3A_subtitles">subtitles</code></td>
<td>
<p>character. Subtitles (<code><a href="formatters.html#topic+subtitles">subtitles()</a></code>) can be vector of strings, where
every element is printed in a separate line. Ignored for subtables.</p>
</td></tr>
<tr><td><code id="constr_args_+3A_main_footer">main_footer</code></td>
<td>
<p>character. Main global (non-referential) footer materials
(<code><a href="formatters.html#topic+main_footer">main_footer()</a></code>). If it is a vector of strings, they will be printed on separate
lines.</p>
</td></tr>
<tr><td><code id="constr_args_+3A_prov_footer">prov_footer</code></td>
<td>
<p>character. Provenance-related global footer materials
(<code><a href="formatters.html#topic+prov_footer">prov_footer()</a></code>). It can be also a vector of strings, printed on different lines.
Generally should not be modified by hand.</p>
</td></tr>
<tr><td><code id="constr_args_+3A_footnotes">footnotes</code></td>
<td>
<p>list or NULL. Referential footnotes to be applied at current
level. In post-processing, this can be achieved with <code><a href="#topic+fnotes_at_path+3C-">fnotes_at_path&lt;-</a></code>.</p>
</td></tr>
<tr><td><code id="constr_args_+3A_page_title">page_title</code></td>
<td>
<p>character. Page specific title(s).</p>
</td></tr>
<tr><td><code id="constr_args_+3A_page_prefix">page_prefix</code></td>
<td>
<p>character(1). Prefix, to be appended with the split value,
when forcing pagination between the children of this split/table</p>
</td></tr>
<tr><td><code id="constr_args_+3A_section_div">section_div</code></td>
<td>
<p>character(1). String which should be repeated as a section
divider after each group defined by this split instruction, or
<code>NA_character_</code> (the default) for no section divider.</p>
</td></tr>
<tr><td><code id="constr_args_+3A_trailing_section_div">trailing_section_div</code></td>
<td>
<p>character(1). String which will be used as a section
divider after the printing of the last row contained in this (sub)-table,
unless that row is also the last table row to be printed overall, or
<code>NA_character_</code> for none (the default). When generated via layouting, this
would correspond to the <code>section_div</code> of the split under which this table
represents a single facet.</p>
</td></tr>
<tr><td><code id="constr_args_+3A_split_na_str">split_na_str</code></td>
<td>
<p>character. NA string vector for use with <code>split_format</code>.</p>
</td></tr>
<tr><td><code id="constr_args_+3A_cna_str">cna_str</code></td>
<td>
<p>character. NA string for use with <code>cformat</code> for content
table.</p>
</td></tr>
<tr><td><code id="constr_args_+3A_inset">inset</code></td>
<td>
<p>numeric(1). Number of spaces to inset the table header, table
body, referential footnotes, and main_footer, as compared to alignment
of title, subtitle, and provenance footer. Defaults to 0 (no inset).</p>
</td></tr>
<tr><td><code id="constr_args_+3A_table_inset">table_inset</code></td>
<td>
<p>numeric(1). Number of spaces to inset the table header, table
body, referential footnotes, and main_footer, as compared to alignment
of title, subtitle, and provenance footer. Defaults to 0 (no inset).</p>
</td></tr>
<tr><td><code id="constr_args_+3A_header_section_div">header_section_div</code></td>
<td>
<p>character(1). String which will be used to divide the header
from the table. See <code><a href="#topic+header_section_div">header_section_div()</a></code> for getter and setter of these.
Please consider changing last element of <code><a href="#topic+section_div">section_div()</a></code> when concatenating
tables that need a divider between them.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL (this is an argument template dummy function)
</p>


<h3>See Also</h3>

<p>Other conventions: 
<code><a href="#topic+compat_args">compat_args</a>()</code>,
<code><a href="#topic+gen_args">gen_args</a>()</code>,
<code><a href="#topic+lyt_args">lyt_args</a>()</code>,
<code><a href="#topic+sf_args">sf_args</a>()</code>
</p>

<hr>
<h2 id='cont_n_allcols'>Score functions for sorting <code>TableTrees</code></h2><span id='topic+cont_n_allcols'></span><span id='topic+cont_n_onecol'></span>

<h3>Description</h3>

<p>Score functions for sorting <code>TableTrees</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cont_n_allcols(tt)

cont_n_onecol(j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cont_n_allcols_+3A_tt">tt</code></td>
<td>
<p><code>TableTree</code> (or related class). A <code>TableTree</code> object representing a
populated table.</p>
</td></tr>
<tr><td><code id="cont_n_allcols_+3A_j">j</code></td>
<td>
<p>numeric(1). Number of column used for scoring.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value indicating score according to the relevant
metric for <code>tt</code>, to be used when sorting.
</p>


<h3>See Also</h3>

<p>For examples and details please read main documentation
<code><a href="#topic+sort_at_path">sort_at_path()</a></code> and relevant vignette
((<a href="https://insightsengineering.github.io/rtables/main/articles/sorting_pruning.html">Sorting and Pruning</a>))
</p>

<hr>
<h2 id='content_table'>Retrieve or set Content Table from a <code>TableTree</code></h2><span id='topic+content_table'></span><span id='topic+content_table+3C-'></span>

<h3>Description</h3>

<p>Returns the content table of <code>obj</code> if it is a <code>TableTree</code> object, or <code>NULL</code> otherwise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>content_table(obj)

content_table(obj) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="content_table_+3A_obj">obj</code></td>
<td>
<p><code>TableTree</code>. The <code>TableTree</code></p>
</td></tr>
<tr><td><code id="content_table_+3A_value">value</code></td>
<td>
<p><code>ElementaryTable</code>. The new content table for <code>obj</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>ElementaryTable</code> containing the (top level) <em>content rows</em> of <code>obj</code> ( or <code>NULL</code>
if <code>obj</code> is not a formal table object).
</p>

<hr>
<h2 id='counts_wpcts'>Analysis function to count levels of a factor with percentage of the column total</h2><span id='topic+counts_wpcts'></span>

<h3>Description</h3>

<p>Analysis function to count levels of a factor with percentage of the column total
</p>


<h3>Usage</h3>

<pre><code class='language-R'>counts_wpcts(x, .N_col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="counts_wpcts_+3A_x">x</code></td>
<td>
<p>factor. Vector of data, provided by rtables pagination machinery</p>
</td></tr>
<tr><td><code id="counts_wpcts_+3A_.n_col">.N_col</code></td>
<td>
<p>integer(1). Total count for the column, provided by rtables pagination machinery</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>RowsVerticalSection</code> object with counts (and percents) for each level of the factor
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
counts_wpcts(DM$SEX, 400)
</code></pre>

<hr>
<h2 id='custom_split_funs'>Custom Split Functions</h2><span id='topic+custom_split_funs'></span>

<h3>Description</h3>

<p>Split functions provide the work-horse for <code>rtables</code>'s
generalized partitioning. These functions accept a (sub)set of incoming
data, a split object, and return 'splits' of that data.
</p>


<h3>Custom Splitting Function Details</h3>

<p>User-defined custom split functions can perform any type of computation on
the incoming data provided that they meet the contract for generating
'splits' of the incoming data 'based on' the split object.
</p>
<p>Split functions are functions that accept:
</p>

<dl>
<dt>df</dt><dd><p>data.frame of incoming data to be split</p>
</dd>
<dt>spl</dt><dd><p>a Split object. this is largely an internal detail custom
functions will not need to worry about, but  <code>obj_name(spl)</code>, for
example, will give the name of the split as it will appear in paths in the
resulting table</p>
</dd>
<dt>vals</dt><dd><p>Any pre-calculated values. If given non-null values, the values
returned should match these. Should be NULL in most cases and can likely be
ignored</p>
</dd>
<dt>labels</dt><dd><p>Any pre-calculated value labels. Same as above for
<code>values</code></p>
</dd>
<dt>trim</dt><dd><p>If <code>TRUE</code>, resulting splits that are empty should be
removed</p>
</dd>
<dt>(Optional) .spl_context</dt><dd><p>a data.frame describing previously performed
splits which collectively arrived at <code>df</code></p>
</dd>
</dl>

<p>The function must then output a <code>named list</code> with the following
elements:
</p>

<dl>
<dt>values</dt><dd><p>The vector of all values corresponding to the splits of
<code>df</code></p>
</dd>
<dt>datasplit</dt><dd><p>a list of data.frames representing the groupings of the
actual observations from <code>df</code>.</p>
</dd>
<dt>labels</dt><dd><p>a character vector giving a string label for each value listed
in the <code>values</code> element above</p>
</dd>
<dt>(Optional) extras</dt><dd><p>If present, extra arguments are to be passed to summary
and analysis functions whenever they are executed on the corresponding
element of <code>datasplit</code> or a subset thereof</p>
</dd>
</dl>

<p>One way to generate custom splitting functions is to wrap existing split
functions and modify either the incoming data before they are called or
their outputs.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_split_fun">make_split_fun()</a></code> for the API for creating custom split functions,
and <a href="#topic+split_funcs">split_funcs</a> for a variety of pre-defined split functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example of a picky split function. The number of values in the column variable
# var decrees if we are going to print also the column with all observation
# or not.

picky_splitter &lt;- function(var) {
  # Main layout function
  function(df, spl, vals, labels, trim) {
    orig_vals &lt;- vals

    # Check for number of levels if all are selected
    if (is.null(vals)) {
      vec &lt;- df[[var]]
      vals &lt;- unique(vec)
    }

    # Do a split with or without All obs
    if (length(vals) == 1) {
      do_base_split(spl = spl, df = df, vals = vals, labels = labels, trim = trim)
    } else {
      fnc_tmp &lt;- add_overall_level("Overall", label = "All Obs", first = FALSE)
      fnc_tmp(df = df, spl = spl, vals = orig_vals, trim = trim)
    }
  }
}

# Data sub-set
d1 &lt;- subset(ex_adsl, ARM == "A: Drug X" | (ARM == "B: Placebo" &amp; SEX == "F"))
d1 &lt;- subset(d1, SEX %in% c("M", "F"))
d1$SEX &lt;- factor(d1$SEX)

# This table uses the number of values in the SEX column to add the overall col or not
lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM", split_fun = drop_split_levels) %&gt;%
  split_cols_by("SEX", split_fun = picky_splitter("SEX")) %&gt;%
  analyze("AGE", show_labels = "visible")
tbl &lt;- build_table(lyt, d1)
tbl

</code></pre>

<hr>
<h2 id='data.frame_export'>Generate a Result Data Frame</h2><span id='topic+data.frame_export'></span><span id='topic+as_result_df'></span><span id='topic+result_df_specs'></span><span id='topic+path_enriched_df'></span>

<h3>Description</h3>

<p>Collection of utilities to exctract <code>data.frame</code> from <code>TableTree</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_result_df(tt, spec = "v0_experimental", simplify = FALSE, ...)

result_df_specs()

path_enriched_df(tt, path_fun = collapse_path, value_fun = collapse_values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.frame_export_+3A_tt">tt</code></td>
<td>
<p><code>TableTree</code> (or related class). A <code>TableTree</code> object representing a
populated table.</p>
</td></tr>
<tr><td><code id="data.frame_export_+3A_spec">spec</code></td>
<td>
<p>character(1). The specification to use to
extract the result data frame. See details</p>
</td></tr>
<tr><td><code id="data.frame_export_+3A_simplify">simplify</code></td>
<td>
<p>logical(1). If <code>TRUE</code>, the result data frame will have only visible
labels and result columns.</p>
</td></tr>
<tr><td><code id="data.frame_export_+3A_...">...</code></td>
<td>
<p>Passed to spec-specific result data frame conversion function. Currently it can be
one or more of the following parameters (valid only for <code>v0_experimental</code> spec for now):
</p>

<ul>
<li> <p><code>expand_colnames</code>: when <code>TRUE</code>, the result data frame will have expanded column names above the usual
output. This is useful when the result data frame is used for further processing.
</p>
</li>
<li> <p><code>simplify</code>: when <code>TRUE</code>, the result data frame will have only visible labels and result columns.
</p>
</li>
<li> <p><code>as_strings</code>: when <code>TRUE</code>, the result data frame will have all values as strings, as they appear
in the final table (it can also be retrieved from <code>matrix_form(tt)$strings</code>). This is also true for
column counts if <code>expand_colnames = TRUE</code>.
</p>
</li>
<li> <p><code>as_viewer</code>: when <code>TRUE</code>, the result data frame will have all values as they appear in the final table,
i.e. with the same precision and numbers, but in easy-to-use numeric form.
</p>
</li></ul>
</td></tr>
<tr><td><code id="data.frame_export_+3A_path_fun">path_fun</code></td>
<td>
<p>function. Function to transform paths into single-string
row/column names.</p>
</td></tr>
<tr><td><code id="data.frame_export_+3A_value_fun">value_fun</code></td>
<td>
<p>function. Function to transform cell values into cells of
the data.frame. Defaults to <code>collapse_values</code> which creates strings
where multi-valued cells are collapsed together, separated by <code>|</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as_result_df()</code>: Result data frame specifications may differ in the exact information
they include and the form in which they represent it. Specifications whose names end in &quot;_experimental&quot;
are subject to change without notice, but specifications without the &quot;_experimental&quot;
suffix will remain available <em>including any bugs in their construction</em> indefinitely.
</p>


<h3>Value</h3>

<p><code>result_df_specs()</code>: returns a named list of result data frame extraction functions by &quot;specification&quot;.
</p>
<p><code>path_enriched_df()</code>: returns a data frame of <code>tt</code>'s cell values (processed by
<code>value_fun</code>, with columns named by the full column paths (processed by
<code>path_fun</code> and an additional <code>row_path</code> column with the row paths
(processed by by <code>path_fun</code>).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>result_df_specs()</code>: list of functions that extract result data frames from <code>TableTree</code>s.
</p>
</li>
<li> <p><code>path_enriched_df()</code>: transform <code>TableTree</code> object to Path-Enriched <code>data.frame</code>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("STRATA1") %&gt;%
  analyze(c("AGE", "BMRKR2"))

tbl &lt;- build_table(lyt, ex_adsl)
as_result_df(tbl)

result_df_specs()

lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  analyze(c("AGE", "BMRKR2"))

tbl &lt;- build_table(lyt, ex_adsl)
path_enriched_df(tbl)

</code></pre>

<hr>
<h2 id='df_to_tt'>Create <code>ElementaryTable</code> from data.frame</h2><span id='topic+df_to_tt'></span>

<h3>Description</h3>

<p>Create <code>ElementaryTable</code> from data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_to_tt(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df_to_tt_+3A_df">df</code></td>
<td>
<p>data.frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>ElementaryTable</code> object with unnested columns corresponding to
<code>names(df)</code> and row labels corresponding to <code>row.names(df)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df_to_tt(mtcars)

</code></pre>

<hr>
<h2 id='do_base_split'>Apply Basic Split (For Use In Custom Split Functions)</h2><span id='topic+do_base_split'></span>

<h3>Description</h3>

<p>This function is intended for use inside custom split functions. It applies
the current split <em>as if it had no custom splitting function</em> so that
those default splits can be further manipulated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_base_split(spl, df, vals = NULL, labels = NULL, trim = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_base_split_+3A_spl">spl</code></td>
<td>
<p>A Split object defining a partitioning or analysis/tabulation of
the data.</p>
</td></tr>
<tr><td><code id="do_base_split_+3A_df">df</code></td>
<td>
<p>dataset (<code>data.frame</code> or <code>tibble</code>)</p>
</td></tr>
<tr><td><code id="do_base_split_+3A_vals">vals</code></td>
<td>
<p>ANY. Already calculated/known values of the split. Generally
should be left as <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="do_base_split_+3A_labels">labels</code></td>
<td>
<p>character. Labels associated with <code>vals</code>. Should be
<code>NULL</code> when <code>vals</code> is, which should almost always be the case.</p>
</td></tr>
<tr><td><code id="do_base_split_+3A_trim">trim</code></td>
<td>
<p>logical(1). Should groups corresponding to empty data subsets be
removed. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the result of the split being applied as if it had no custom split
function, see <code><a href="#topic+custom_split_funs">custom_split_funs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
uneven_splfun &lt;- function(df, spl, vals = NULL, labels = NULL, trim = FALSE) {
  ret &lt;- do_base_split(spl, df, vals, labels, trim)
  if (NROW(df) == 0) {
    ret &lt;- lapply(ret, function(x) x[1])
  }
  ret
}

lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_cols_by_multivar(c("USUBJID", "AESEQ", "BMRKR1"),
    varlabels = c("N", "E", "BMR1"),
    split_fun = uneven_splfun
  ) %&gt;%
  analyze_colvars(list(
    USUBJID = function(x, ...) length(unique(x)),
    AESEQ = max,
    BMRKR1 = mean
  ))

tbl &lt;- build_table(lyt, subset(ex_adae, as.numeric(ARM) &lt;= 2))
tbl
</code></pre>

<hr>
<h2 id='drop_facet_levels'>Preprocessing Functions for use in make_split_fun</h2><span id='topic+drop_facet_levels'></span>

<h3>Description</h3>

<p>This function is intended for use as a preprocessing
component in <code>make_split_fun</code>, and should not be called
directly by end users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_facet_levels(df, spl, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_facet_levels_+3A_df">df</code></td>
<td>
<p>data.frame. The incoming data corresponding with the parent facet</p>
</td></tr>
<tr><td><code id="drop_facet_levels_+3A_spl">spl</code></td>
<td>
<p>Split.</p>
</td></tr>
<tr><td><code id="drop_facet_levels_+3A_...">...</code></td>
<td>
<p>dots. This is used internally to pass parameters.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>make_split_fun
</p>
<p>Other make_custom_split: 
<code><a href="#topic+add_combo_facet">add_combo_facet</a>()</code>,
<code><a href="#topic+make_split_fun">make_split_fun</a>()</code>,
<code><a href="#topic+make_split_result">make_split_result</a>()</code>,
<code><a href="#topic+trim_levels_in_facets">trim_levels_in_facets</a>()</code>
</p>

<hr>
<h2 id='ElementaryTable-class'><code>TableTree</code> classes</h2><span id='topic+ElementaryTable-class'></span><span id='topic+ElementaryTable'></span><span id='topic+TableTree-class'></span><span id='topic+TableTree'></span>

<h3>Description</h3>

<p><code>TableTree</code> classes
</p>
<p>Table Constructors and Classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ElementaryTable(
  kids = list(),
  name = "",
  lev = 1L,
  label = "",
  labelrow = LabelRow(lev = lev, label = label, vis = !isTRUE(iscontent) &amp;&amp; !is.na(label)
    &amp;&amp; nzchar(label)),
  rspans = data.frame(),
  cinfo = NULL,
  iscontent = NA,
  var = NA_character_,
  format = NULL,
  na_str = NA_character_,
  indent_mod = 0L,
  title = "",
  subtitles = character(),
  main_footer = character(),
  prov_footer = character(),
  header_section_div = NA_character_,
  hsep = default_hsep(),
  trailing_section_div = NA_character_,
  inset = 0L
)

TableTree(
  kids = list(),
  name = if (!is.na(var)) var else "",
  cont = EmptyElTable,
  lev = 1L,
  label = name,
  labelrow = LabelRow(lev = lev, label = label, vis = nrow(cont) == 0 &amp;&amp; !is.na(label) &amp;&amp;
    nzchar(label)),
  rspans = data.frame(),
  iscontent = NA,
  var = NA_character_,
  cinfo = NULL,
  format = NULL,
  na_str = NA_character_,
  indent_mod = 0L,
  title = "",
  subtitles = character(),
  main_footer = character(),
  prov_footer = character(),
  page_title = NA_character_,
  hsep = default_hsep(),
  header_section_div = NA_character_,
  trailing_section_div = NA_character_,
  inset = 0L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ElementaryTable-class_+3A_kids">kids</code></td>
<td>
<p>list. List of direct children.</p>
</td></tr>
<tr><td><code id="ElementaryTable-class_+3A_name">name</code></td>
<td>
<p>character(1). Name of the split/table/row being created. Defaults
to same as the corresponding label, but is not required to be.</p>
</td></tr>
<tr><td><code id="ElementaryTable-class_+3A_lev">lev</code></td>
<td>
<p>integer. Nesting level (roughly, indentation level in practical
terms).</p>
</td></tr>
<tr><td><code id="ElementaryTable-class_+3A_label">label</code></td>
<td>
<p>character(1). A label (not to be confused with the name) for the
object/structure.</p>
</td></tr>
<tr><td><code id="ElementaryTable-class_+3A_labelrow">labelrow</code></td>
<td>
<p><code>LabelRow</code>. The <code>LabelRow</code> object to assign to this Table.
Constructed from <code>label</code> by default if not specified.</p>
</td></tr>
<tr><td><code id="ElementaryTable-class_+3A_rspans">rspans</code></td>
<td>
<p>data.frame. Currently stored but otherwise ignored.</p>
</td></tr>
<tr><td><code id="ElementaryTable-class_+3A_cinfo">cinfo</code></td>
<td>
<p><code>InstantiatedColumnInfo</code> (or NULL). Column structure for the
object being created.</p>
</td></tr>
<tr><td><code id="ElementaryTable-class_+3A_iscontent">iscontent</code></td>
<td>
<p>logical. Is the <code>TableTree</code>/<code>ElementaryTable</code> being constructed
the content table for another <code>TableTree</code>.</p>
</td></tr>
<tr><td><code id="ElementaryTable-class_+3A_var">var</code></td>
<td>
<p>string, variable name</p>
</td></tr>
<tr><td><code id="ElementaryTable-class_+3A_format">format</code></td>
<td>
<p><code>FormatSpec</code>. Format associated with this split. Formats can be
declared via strings (<code>"xx.x"</code>) or function. In cases such as
<code>analyze</code> calls, they can character vectors or lists of functions.</p>
</td></tr>
<tr><td><code id="ElementaryTable-class_+3A_na_str">na_str</code></td>
<td>
<p>character(1). String that should be displayed when the value of <code>x</code> is missing.
Defaults to <code>"NA"</code>.</p>
</td></tr>
<tr><td><code id="ElementaryTable-class_+3A_indent_mod">indent_mod</code></td>
<td>
<p>numeric. Modifier for the default indent position for the
structure created by this function(subtable, content table, or row)
<em>and all of that structure's children</em>. Defaults to 0, which
corresponds to the unmodified default behavior.</p>
</td></tr>
<tr><td><code id="ElementaryTable-class_+3A_title">title</code></td>
<td>
<p>character(1). Main title (<code><a href="formatters.html#topic+main_title">main_title()</a></code>) is a single string.
Ignored for subtables.</p>
</td></tr>
<tr><td><code id="ElementaryTable-class_+3A_subtitles">subtitles</code></td>
<td>
<p>character. Subtitles (<code><a href="formatters.html#topic+subtitles">subtitles()</a></code>) can be vector of strings, where
every element is printed in a separate line. Ignored for subtables.</p>
</td></tr>
<tr><td><code id="ElementaryTable-class_+3A_main_footer">main_footer</code></td>
<td>
<p>character. Main global (non-referential) footer materials
(<code><a href="formatters.html#topic+main_footer">main_footer()</a></code>). If it is a vector of strings, they will be printed on separate
lines.</p>
</td></tr>
<tr><td><code id="ElementaryTable-class_+3A_prov_footer">prov_footer</code></td>
<td>
<p>character. Provenance-related global footer materials
(<code><a href="formatters.html#topic+prov_footer">prov_footer()</a></code>). It can be also a vector of strings, printed on different lines.
Generally should not be modified by hand.</p>
</td></tr>
<tr><td><code id="ElementaryTable-class_+3A_header_section_div">header_section_div</code></td>
<td>
<p>character(1). String which will be used to divide the header
from the table. See <code><a href="#topic+header_section_div">header_section_div()</a></code> for getter and setter of these.
Please consider changing last element of <code><a href="#topic+section_div">section_div()</a></code> when concatenating
tables that need a divider between them.</p>
</td></tr>
<tr><td><code id="ElementaryTable-class_+3A_hsep">hsep</code></td>
<td>
<p>character(1). Set of character(s) to be repeated as the separator
between the header and body of the table when rendered as text. Defaults to
a connected horizontal line (unicode 2014) in locals that use a UTF
charset, and to <code>-</code> elsewhere (with a once per session warning). See
<code><a href="formatters.html#topic+default_horizontal_sep">formatters::set_default_hsep()</a></code> for further information.</p>
</td></tr>
<tr><td><code id="ElementaryTable-class_+3A_trailing_section_div">trailing_section_div</code></td>
<td>
<p>character(1). String which will be used as a section
divider after the printing of the last row contained in this (sub)-table,
unless that row is also the last table row to be printed overall, or
<code>NA_character_</code> for none (the default). When generated via layouting, this
would correspond to the <code>section_div</code> of the split under which this table
represents a single facet.</p>
</td></tr>
<tr><td><code id="ElementaryTable-class_+3A_inset">inset</code></td>
<td>
<p>numeric(1). Number of spaces to inset the table header, table
body, referential footnotes, and main_footer, as compared to alignment
of title, subtitle, and provenance footer. Defaults to 0 (no inset).</p>
</td></tr>
<tr><td><code id="ElementaryTable-class_+3A_cont">cont</code></td>
<td>
<p><code>ElementaryTable</code>. Content table.</p>
</td></tr>
<tr><td><code id="ElementaryTable-class_+3A_page_title">page_title</code></td>
<td>
<p>character. Page specific title(s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formal object representing a populated table.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>

<hr>
<h2 id='EmptyColInfo'>Empty table, column, split objects</h2><span id='topic+EmptyColInfo'></span><span id='topic+EmptyElTable'></span><span id='topic+EmptyRootSplit'></span><span id='topic+EmptyAllSplit'></span>

<h3>Description</h3>

<p>Empty objects of various types to compare against efficiently.
</p>

<hr>
<h2 id='export_as_docx'>Export as word document</h2><span id='topic+export_as_docx'></span><span id='topic+section_properties_portrait'></span><span id='topic+section_properties_landscape'></span><span id='topic+margins_potrait'></span><span id='topic+margins_landscape'></span>

<h3>Description</h3>

<p>From a table, produce a self-contained word document or attach it to a template word
file (<code>template_file</code>). This function is based on <code><a href="#topic+tt_to_flextable">tt_to_flextable()</a></code> transformer and
<code>officer</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_as_docx(
  tt,
  file,
  doc_metadata = NULL,
  titles_as_header = FALSE,
  footers_as_text = TRUE,
  template_file = NULL,
  section_properties = NULL
)

section_properties_portrait()

section_properties_landscape()

margins_potrait()

margins_landscape()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_as_docx_+3A_tt">tt</code></td>
<td>
<p><code>TableTree</code> (or related class). A <code>TableTree</code> object representing a
populated table.</p>
</td></tr>
<tr><td><code id="export_as_docx_+3A_file">file</code></td>
<td>
<p>character(1). String that indicates the final file output. It needs to have <code>.docx</code>
extension.</p>
</td></tr>
<tr><td><code id="export_as_docx_+3A_doc_metadata">doc_metadata</code></td>
<td>
<p>list of character(1)s. Any value that can be used as metadata by
<code>?officer::set_doc_properties</code>. Important text values are <code style="white-space: pre;">&#8288;title, subject, creator, description&#8288;</code>
while <code>created</code> is a date object.</p>
</td></tr>
<tr><td><code id="export_as_docx_+3A_titles_as_header">titles_as_header</code></td>
<td>
<p>logical(1). Defaults to <code>TRUE</code> for <code><a href="#topic+tt_to_flextable">tt_to_flextable()</a></code>, so the
table is self-contained as it makes additional header rows for <code><a href="formatters.html#topic+main_title">main_title()</a></code>
string and <code><a href="formatters.html#topic+subtitles">subtitles()</a></code> character vector (one per element). <code>FALSE</code> is suggested
for <code><a href="#topic+export_as_docx">export_as_docx()</a></code>. This adds titles and subtitles as a text paragraph above
the table. Same style is applied.</p>
</td></tr>
<tr><td><code id="export_as_docx_+3A_footers_as_text">footers_as_text</code></td>
<td>
<p>logical(1). Defaults to <code>FALSE</code> for <code><a href="#topic+tt_to_flextable">tt_to_flextable()</a></code>, so
the table is self-contained with the flextable definition of footnotes. <code>TRUE</code> is
used for <code><a href="#topic+export_as_docx">export_as_docx()</a></code> to add the footers as a new paragraph after the table.
Same style is applied, but with a smaller font.</p>
</td></tr>
<tr><td><code id="export_as_docx_+3A_template_file">template_file</code></td>
<td>
<p>character(1). Template file that <code>officer</code> will use as a starting
point for the final document. It will attach the table and use the defaults defined in
the template file. Output will be doc <code>file</code> nonetheless.</p>
</td></tr>
<tr><td><code id="export_as_docx_+3A_section_properties">section_properties</code></td>
<td>
<p><code>officer::prop_section</code> object. Here you can set margins and page
size.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>section_properties_portrait()</code>: helper function that defines standard portrait properties for tables.
</p>
</li>
<li> <p><code>section_properties_landscape()</code>: helper function that defines standard landscape properties for tables.
</p>
</li>
<li> <p><code>margins_potrait()</code>: helper function that defines standard portrait margins for tables.
</p>
</li>
<li> <p><code>margins_landscape()</code>: helper function that defines standard landscape margins for tables.
</p>
</li></ul>


<h3>Note</h3>

<p><code>export_as_docx()</code> does not have many options available. We suggest, if you need
specific formats and details to use <code><a href="#topic+tt_to_flextable">tt_to_flextable()</a></code> first and then <code>export_as_docx</code>.
Only <code>title_as_header</code> and <code>footer_as_text</code> need to be specified again if changed in
<code>tt_to_flextable()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tt_to_flextable">tt_to_flextable()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  analyze(c("AGE", "BMRKR2", "COUNTRY"))

tbl &lt;- build_table(lyt, ex_adsl)

# See how section_properties_portrait function is built for custom
## Not run: 
tf &lt;- tempfile(fileext = ".docx")
export_as_docx(tbl, file = tf, section_properties = section_properties_portrait())

## End(Not run)

</code></pre>

<hr>
<h2 id='export_as_tsv'>Create Enriched flat value table with paths</h2><span id='topic+export_as_tsv'></span><span id='topic+import_from_tsv'></span>

<h3>Description</h3>

<p>This function creates a flat tabular file of cell values and
corresponding paths via <code><a href="#topic+path_enriched_df">path_enriched_df()</a></code>. I then
writes that data.frame out as a <code>tsv</code> file.
</p>
<p>By default (i.e. when <code>value_func</code> is not specified,
List columns where at least one value has length &gt; 1 are collapsed
to character vectors by collapsing the list element with <code>"|"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_as_tsv(
  tt,
  file = NULL,
  path_fun = collapse_path,
  value_fun = collapse_values
)

import_from_tsv(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_as_tsv_+3A_tt">tt</code></td>
<td>
<p><code>TableTree</code> (or related class). A <code>TableTree</code> object representing a
populated table.</p>
</td></tr>
<tr><td><code id="export_as_tsv_+3A_file">file</code></td>
<td>
<p>character(1). The path of the file to written to or read from.</p>
</td></tr>
<tr><td><code id="export_as_tsv_+3A_path_fun">path_fun</code></td>
<td>
<p>function. Function to transform paths into single-string
row/column names.</p>
</td></tr>
<tr><td><code id="export_as_tsv_+3A_value_fun">value_fun</code></td>
<td>
<p>function. Function to transform cell values into cells of
the data.frame. Defaults to <code>collapse_values</code> which creates strings
where multi-valued cells are collapsed together, separated by <code>|</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> silently for <code>export_as_tsv</code>, a data.frame with
re-constituted list values for <code>export_as_tsv</code>.
</p>


<h3>Note</h3>

<p>There is currently no round-trip capability for this type of export.
You can read values exported this way back in via <code>import_from_tsv</code>
but you will receive only the data.frame version back, NOT a <code>TableTree</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+path_enriched_df">path_enriched_df()</a></code> for the underlying function that does the work.
</p>

<hr>
<h2 id='find_degen_struct'>Find degenerate (sub)structures within a table (Experimental)</h2><span id='topic+find_degen_struct'></span>

<h3>Description</h3>

<p>Find degenerate (sub)structures within a table (Experimental)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_degen_struct(tt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_degen_struct_+3A_tt">tt</code></td>
<td>
<p><code>TableTree</code>
</p>
<p>This function returns a list with the row-paths to all
structural subtables which contain no data rows (
even if they have associated content rows).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of character vectors representing the
row paths, if any, to degenerate substructures within
the table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>find_degen_struct(rtable("hi"))

</code></pre>

<hr>
<h2 id='format_rcell'>Format <code>rcell</code></h2><span id='topic+format_rcell'></span>

<h3>Description</h3>

<p>This is a wrapper around
<code><a href="formatters.html#topic+format_value">formatters::format_value</a></code> for use with
<code>CellValue</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_rcell(
  x,
  format,
  output = c("ascii", "html"),
  na_str = obj_na_str(x) %||% "NA",
  pr_row_format = NULL,
  pr_row_na_str = NULL,
  shell = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_rcell_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+CellValue">CellValue</a></code>, or a raw value.</p>
</td></tr>
<tr><td><code id="format_rcell_+3A_format">format</code></td>
<td>
<p>character(1) or function. The format label (string) or
formatter function to apply to <code>x</code>.</p>
</td></tr>
<tr><td><code id="format_rcell_+3A_output">output</code></td>
<td>
<p>character(1). Output type.</p>
</td></tr>
<tr><td><code id="format_rcell_+3A_na_str">na_str</code></td>
<td>
<p>character(1). String that should be displayed when the value of
<code>x</code> is missing. Defaults to <code>"NA"</code>.</p>
</td></tr>
<tr><td><code id="format_rcell_+3A_pr_row_format">pr_row_format</code></td>
<td>
<p>list of default format coming from the general row.</p>
</td></tr>
<tr><td><code id="format_rcell_+3A_pr_row_na_str">pr_row_na_str</code></td>
<td>
<p>list of default <code>"NA"</code> string coming from the general row.</p>
</td></tr>
<tr><td><code id="format_rcell_+3A_shell">shell</code></td>
<td>
<p>logical(1). Should the formats themselves be returned instead of the
values with formats applied. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>formatted text representing the cell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cll &lt;- CellValue(pi, format = "xx.xxx")
format_rcell(cll)

# Cell values precedes the row values
cll &lt;- CellValue(pi, format = "xx.xxx")
format_rcell(cll, pr_row_format = "xx.x")

# Similarly for NA values
cll &lt;- CellValue(NA, format = "xx.xxx", format_na_str = "This is THE NA")
format_rcell(cll, pr_row_na_str = "This is NA")

</code></pre>

<hr>
<h2 id='gen_args'>General Argument Conventions</h2><span id='topic+gen_args'></span>

<h3>Description</h3>

<p>General Argument Conventions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_args(
  df,
  alt_counts_df,
  spl,
  pos,
  tt,
  tr,
  verbose,
  colwidths,
  obj,
  x,
  value,
  object,
  path,
  label,
  label_pos,
  cvar,
  topleft,
  page_prefix,
  hsep,
  indent_size,
  section_div,
  na_str,
  inset,
  table_inset,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_args_+3A_df">df</code></td>
<td>
<p>dataset (<code>data.frame</code> or <code>tibble</code>)</p>
</td></tr>
<tr><td><code id="gen_args_+3A_alt_counts_df">alt_counts_df</code></td>
<td>
<p>dataset (<code>data.frame</code> or <code>tibble</code>). Alternative full data
the rtables framework will use (<em>only</em>) when calculating column
counts.</p>
</td></tr>
<tr><td><code id="gen_args_+3A_spl">spl</code></td>
<td>
<p>A Split object defining a partitioning or analysis/tabulation of
the data.</p>
</td></tr>
<tr><td><code id="gen_args_+3A_pos">pos</code></td>
<td>
<p>numeric.  Which top-level set of nested splits should the new
layout feature be added to. Defaults to the current</p>
</td></tr>
<tr><td><code id="gen_args_+3A_tt">tt</code></td>
<td>
<p><code>TableTree</code> (or related class). A <code>TableTree</code> object representing a
populated table.</p>
</td></tr>
<tr><td><code id="gen_args_+3A_tr">tr</code></td>
<td>
<p><code>TableRow</code> (or related class). A <code>TableRow</code> object representing a
single row within a populated table.</p>
</td></tr>
<tr><td><code id="gen_args_+3A_verbose">verbose</code></td>
<td>
<p>logical(1). Should extra debugging messages be shown. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="gen_args_+3A_colwidths">colwidths</code></td>
<td>
<p>numeric vector. Column widths for use with vertical pagination.</p>
</td></tr>
<tr><td><code id="gen_args_+3A_obj">obj</code></td>
<td>
<p>ANY. The object for the accessor to access or modify</p>
</td></tr>
<tr><td><code id="gen_args_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="gen_args_+3A_value">value</code></td>
<td>
<p>The new value</p>
</td></tr>
<tr><td><code id="gen_args_+3A_object">object</code></td>
<td>
<p>The object to modify in-place</p>
</td></tr>
<tr><td><code id="gen_args_+3A_path">path</code></td>
<td>
<p>character. A vector path for a position within the structure of a
<code>tabletree</code>. Each element represents a subsequent choice amongst the children
of the previous choice.</p>
</td></tr>
<tr><td><code id="gen_args_+3A_label">label</code></td>
<td>
<p>character(1). A label (not to be confused with the name) for the
object/structure.</p>
</td></tr>
<tr><td><code id="gen_args_+3A_label_pos">label_pos</code></td>
<td>
<p>character(1). Location the variable label should be
displayed, Accepts <code>"hidden"</code> (default for non-analyze row splits), <code>"visible"</code>,
<code>"topleft"</code>, and - for analyze splits only - <code>"default"</code>.  For analyze calls,
<code>"default"</code> indicates that the variable should be visible if and only if
multiple variables are analyzed at the same level of nesting.</p>
</td></tr>
<tr><td><code id="gen_args_+3A_cvar">cvar</code></td>
<td>
<p>character(1). The variable, if any, which the content function
should accept. Defaults to NA.</p>
</td></tr>
<tr><td><code id="gen_args_+3A_topleft">topleft</code></td>
<td>
<p>character. Override values for the &quot;top left&quot; material to be
displayed during printing.</p>
</td></tr>
<tr><td><code id="gen_args_+3A_page_prefix">page_prefix</code></td>
<td>
<p>character(1). Prefix, to be appended with the split value,
when forcing pagination between the children of this split/table</p>
</td></tr>
<tr><td><code id="gen_args_+3A_hsep">hsep</code></td>
<td>
<p>character(1). Set of character(s) to be repeated as the separator
between the header and body of the table when rendered as text. Defaults to
a connected horizontal line (unicode 2014) in locals that use a UTF
charset, and to <code>-</code> elsewhere (with a once per session warning). See
<code><a href="formatters.html#topic+default_horizontal_sep">formatters::set_default_hsep()</a></code> for further information.</p>
</td></tr>
<tr><td><code id="gen_args_+3A_indent_size">indent_size</code></td>
<td>
<p>numeric(1). Number of spaces to use per indent level.
Defaults to 2</p>
</td></tr>
<tr><td><code id="gen_args_+3A_section_div">section_div</code></td>
<td>
<p>character(1). String which should be repeated as a section
divider after each group defined by this split instruction, or
<code>NA_character_</code> (the default) for no section divider.</p>
</td></tr>
<tr><td><code id="gen_args_+3A_na_str">na_str</code></td>
<td>
<p>character(1). String that should be displayed when the value of <code>x</code> is missing.
Defaults to <code>"NA"</code>.</p>
</td></tr>
<tr><td><code id="gen_args_+3A_inset">inset</code></td>
<td>
<p>numeric(1). Number of spaces to inset the table header, table
body, referential footnotes, and main_footer, as compared to alignment
of title, subtitle, and provenance footer. Defaults to 0 (no inset).</p>
</td></tr>
<tr><td><code id="gen_args_+3A_table_inset">table_inset</code></td>
<td>
<p>numeric(1). Number of spaces to inset the table header, table
body, referential footnotes, and main_footer, as compared to alignment
of title, subtitle, and provenance footer. Defaults to 0 (no inset).</p>
</td></tr>
<tr><td><code id="gen_args_+3A_...">...</code></td>
<td>
<p>Passed on to methods or tabulation functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL (this is an argument template dummy function)
</p>


<h3>See Also</h3>

<p>Other conventions: 
<code><a href="#topic+compat_args">compat_args</a>()</code>,
<code><a href="#topic+constr_args">constr_args</a>()</code>,
<code><a href="#topic+lyt_args">lyt_args</a>()</code>,
<code><a href="#topic+sf_args">sf_args</a>()</code>
</p>

<hr>
<h2 id='get_formatted_cells'>get formatted cells</h2><span id='topic+get_formatted_cells'></span><span id='topic+get_formatted_cells+2CTableTree-method'></span><span id='topic+get_formatted_cells+2CElementaryTable-method'></span><span id='topic+get_formatted_cells+2CTableRow-method'></span><span id='topic+get_formatted_cells+2CLabelRow-method'></span><span id='topic+get_cell_aligns'></span><span id='topic+get_cell_aligns+2CTableTree-method'></span><span id='topic+get_cell_aligns+2CElementaryTable-method'></span><span id='topic+get_cell_aligns+2CTableRow-method'></span><span id='topic+get_cell_aligns+2CLabelRow-method'></span>

<h3>Description</h3>

<p>get formatted cells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_formatted_cells(obj, shell = FALSE)

## S4 method for signature 'TableTree'
get_formatted_cells(obj, shell = FALSE)

## S4 method for signature 'ElementaryTable'
get_formatted_cells(obj, shell = FALSE)

## S4 method for signature 'TableRow'
get_formatted_cells(obj, shell = FALSE)

## S4 method for signature 'LabelRow'
get_formatted_cells(obj, shell = FALSE)

get_cell_aligns(obj)

## S4 method for signature 'TableTree'
get_cell_aligns(obj)

## S4 method for signature 'ElementaryTable'
get_cell_aligns(obj)

## S4 method for signature 'TableRow'
get_cell_aligns(obj)

## S4 method for signature 'LabelRow'
get_cell_aligns(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_formatted_cells_+3A_obj">obj</code></td>
<td>
<p>ANY. The object for the accessor to access or modify</p>
</td></tr>
<tr><td><code id="get_formatted_cells_+3A_shell">shell</code></td>
<td>
<p>logical(1). Should the formats themselves be returned instead of the
values with formats applied. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the formatted print-strings for all (body) cells in <code>obj</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

iris2 &lt;- iris %&gt;%
  group_by(Species) %&gt;%
  mutate(group = as.factor(rep_len(c("a", "b"), length.out = n()))) %&gt;%
  ungroup()

tbl &lt;- basic_table() %&gt;%
  split_cols_by("Species") %&gt;%
  split_cols_by("group") %&gt;%
  analyze(c("Sepal.Length", "Petal.Width"), afun = list_wrap_x(summary), format = "xx.xx") %&gt;%
  build_table(iris2)

get_formatted_cells(tbl)
</code></pre>

<hr>
<h2 id='head'>Head and tail methods</h2><span id='topic+head'></span><span id='topic+head+2CVTableTree-method'></span><span id='topic+tail'></span><span id='topic+tail+2CVTableTree-method'></span>

<h3>Description</h3>

<p>Head and tail methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>head(x, ...)

## S4 method for signature 'VTableTree'
head(
  x,
  n = 6,
  ...,
  keep_topleft = TRUE,
  keep_titles = TRUE,
  keep_footers = keep_titles,
  reindex_refs = FALSE
)

tail(x, ...)

## S4 method for signature 'VTableTree'
tail(
  x,
  n = 6,
  ...,
  keep_topleft = TRUE,
  keep_titles = TRUE,
  keep_footers = keep_titles,
  reindex_refs = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="head_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td></tr>
<tr><td><code id="head_+3A_n">n</code></td>
<td>
<p>an integer vector of length up to <code>dim(x)</code> (or 1,
for non-dimensioned objects).  A <code>logical</code> is silently coerced to
integer.  Values specify the indices to be
selected in the corresponding dimension (or along the length) of the
object. A positive value of <code>n[i]</code> includes the first/last
<code>n[i]</code> indices in that dimension, while a negative value
excludes the last/first <code>abs(n[i])</code>, including all remaining
indices. <code>NA</code> or non-specified values (when <code>length(n) &lt;
      length(dim(x))</code>) select all indices in that dimension. Must
contain at least one non-missing value.</p>
</td></tr>
<tr><td><code id="head_+3A_keep_topleft">keep_topleft</code></td>
<td>
<p>logical(1). If <code>TRUE</code> (the default),
top_left material for the table will be carried over to the
subset.</p>
</td></tr>
<tr><td><code id="head_+3A_keep_titles">keep_titles</code></td>
<td>
<p>logical(1).  If <code>TRUE</code> (the default),
all title material for the table will be carried over to the
subset.</p>
</td></tr>
<tr><td><code id="head_+3A_keep_footers">keep_footers</code></td>
<td>
<p>logical(1). If <code>TRUE</code>, all footer material for the table
will be carried over to the subset. It defaults to <code>keep_titles</code>.</p>
</td></tr>
<tr><td><code id="head_+3A_reindex_refs">reindex_refs</code></td>
<td>
<p>logical(1). Defaults to <code>FALSE</code>. If <code>TRUE</code>,
referential footnotes will be reindexed for the subset.</p>
</td></tr>
</table>

<hr>
<h2 id='horizontal_sep'>Access or recursively set header-body separator for tables</h2><span id='topic+horizontal_sep'></span><span id='topic+horizontal_sep+2CVTableTree-method'></span><span id='topic+horizontal_sep+3C-'></span><span id='topic+horizontal_sep+3C-+2CVTableTree-method'></span><span id='topic+horizontal_sep+3C-+2CTableRow-method'></span>

<h3>Description</h3>

<p>Access or recursively set header-body separator for tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>horizontal_sep(obj)

## S4 method for signature 'VTableTree'
horizontal_sep(obj)

horizontal_sep(obj) &lt;- value

## S4 replacement method for signature 'VTableTree'
horizontal_sep(obj) &lt;- value

## S4 replacement method for signature 'TableRow'
horizontal_sep(obj) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="horizontal_sep_+3A_obj">obj</code></td>
<td>
<p>ANY. The object for the accessor to access or modify</p>
</td></tr>
<tr><td><code id="horizontal_sep_+3A_value">value</code></td>
<td>
<p>character(1). String to use as new header/body separator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>for <code>horizontal_sep</code> the string acting as the header separator.
for <code style="white-space: pre;">&#8288;horizontal_sep&lt;-&#8288;</code>, the <code>obj</code>, with the new header separator
applied recursively to it and all its subtables.
</p>

<hr>
<h2 id='in_rows'>Create multiple rows in analysis or summary functions</h2><span id='topic+in_rows'></span>

<h3>Description</h3>

<p>define the cells that get placed into multiple rows in <code>afun</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_rows(
  ...,
  .list = NULL,
  .names = NULL,
  .labels = NULL,
  .formats = NULL,
  .indent_mods = NULL,
  .cell_footnotes = list(NULL),
  .row_footnotes = list(NULL),
  .aligns = NULL,
  .format_na_strs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in_rows_+3A_...">...</code></td>
<td>
<p>single row defining expressions</p>
</td></tr>
<tr><td><code id="in_rows_+3A_.list">.list</code></td>
<td>
<p>list. list cell content, usually <code>rcells</code>, the <code>.list</code> is
concatenated to <code>...</code></p>
</td></tr>
<tr><td><code id="in_rows_+3A_.names">.names</code></td>
<td>
<p>character or NULL. Names of the returned list/structure.</p>
</td></tr>
<tr><td><code id="in_rows_+3A_.labels">.labels</code></td>
<td>
<p>character or NULL. labels for the defined rows</p>
</td></tr>
<tr><td><code id="in_rows_+3A_.formats">.formats</code></td>
<td>
<p>character or NULL. Formats for the values</p>
</td></tr>
<tr><td><code id="in_rows_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>integer or NULL. Indent modifications for the defined
rows.</p>
</td></tr>
<tr><td><code id="in_rows_+3A_.cell_footnotes">.cell_footnotes</code></td>
<td>
<p>list. Referential footnote messages to be associated
by name with <em>cells</em>.</p>
</td></tr>
<tr><td><code id="in_rows_+3A_.row_footnotes">.row_footnotes</code></td>
<td>
<p>list. Referential footnotes messages to be associated
by name with <em>rows</em>.</p>
</td></tr>
<tr><td><code id="in_rows_+3A_.aligns">.aligns</code></td>
<td>
<p>character or NULL. Alignments for the cells. Standard for <code>NULL</code>
is <code>"center"</code>. See <code><a href="formatters.html#topic+list_formats">formatters::list_valid_aligns()</a></code> for currently supported
alignments.</p>
</td></tr>
<tr><td><code id="in_rows_+3A_.format_na_strs">.format_na_strs</code></td>
<td>
<p>character or NULL. NA strings for the cells</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>RowsVerticalSection</code> object (or <code>NULL</code>). The details of
this object should be considered an internal implementation detail.
</p>


<h3>Note</h3>

<p>In post-processing, referential footnotes can also be added using row and column
paths with <code><a href="#topic+fnotes_at_path+3C-">fnotes_at_path&lt;-</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+analyze">analyze()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>in_rows(1, 2, 3, .names = c("a", "b", "c"))
in_rows(1, 2, 3, .labels = c("a", "b", "c"))
in_rows(1, 2, 3, .names = c("a", "b", "c"), .labels = c("AAA", "BBB", "CCC"))

in_rows(.list = list(a = 1, b = 2, c = 3))
in_rows(1, 2, .list = list(3), .names = c("a", "b", "c"))

lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  analyze("AGE", afun = function(x) {
    in_rows(
      "Mean (sd)" = rcell(c(mean(x), sd(x)), format = "xx.xx (xx.xx)"),
      "Range" = rcell(range(x), format = "xx.xx - xx.xx")
    )
  })

tbl &lt;- build_table(lyt, ex_adsl)
tbl

</code></pre>

<hr>
<h2 id='indent'>Change indentation of all <code>rrows</code> in an <code>rtable</code></h2><span id='topic+indent'></span>

<h3>Description</h3>

<p>Change indentation of all <code>rrows</code> in an <code>rtable</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indent(x, by = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indent_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+rtable">rtable</a></code> object</p>
</td></tr>
<tr><td><code id="indent_+3A_by">by</code></td>
<td>
<p>integer to increase indentation of rows. Can be negative. If final indentation is smaller than 0 then the
indentation is set to 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> with its indent modifier incremented by <code>by</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_setosa &lt;- iris$Species == "setosa"
m_tbl &lt;- rtable(
  header = rheader(
    rrow(row.name = NULL, rcell("Sepal.Length", colspan = 2), rcell("Petal.Length", colspan = 2)),
    rrow(NULL, "mean", "median", "mean", "median")
  ),
  rrow(
    row.name = "All Species",
    mean(iris$Sepal.Length), median(iris$Sepal.Length),
    mean(iris$Petal.Length), median(iris$Petal.Length),
    format = "xx.xx"
  ),
  rrow(
    row.name = "Setosa",
    mean(iris$Sepal.Length[is_setosa]), median(iris$Sepal.Length[is_setosa]),
    mean(iris$Petal.Length[is_setosa]), median(iris$Petal.Length[is_setosa]),
    format = "xx.xx"
  )
)
indent(m_tbl)
indent(m_tbl, 2)

</code></pre>

<hr>
<h2 id='indent_string'>Indent Strings</h2><span id='topic+indent_string'></span>

<h3>Description</h3>

<p>Used in rtables to indent row names for the ASCII output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indent_string(x, indent = 0, incr = 2, including_newline = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indent_string_+3A_x">x</code></td>
<td>
<p>a character vector</p>
</td></tr>
<tr><td><code id="indent_string_+3A_indent">indent</code></td>
<td>
<p>a vector of length <code>length(x)</code> with non-negative integers</p>
</td></tr>
<tr><td><code id="indent_string_+3A_incr">incr</code></td>
<td>
<p>non-negative integer: number of spaces per indent level</p>
</td></tr>
<tr><td><code id="indent_string_+3A_including_newline">including_newline</code></td>
<td>
<p>boolean: should newlines also be indented</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> indented by left-padding with <code>indent*incr</code> white-spaces.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>indent_string("a", 0)
indent_string("a", 1)
indent_string(letters[1:3], 0:2)
indent_string(paste0(letters[1:3], "\n", LETTERS[1:3]), 0:2)

</code></pre>

<hr>
<h2 id='insert_row_at_path'>Insert Row at Path</h2><span id='topic+insert_row_at_path'></span><span id='topic+insert_row_at_path+2CVTableTree+2CDataRow-method'></span><span id='topic+insert_row_at_path+2CVTableTree+2CANY-method'></span>

<h3>Description</h3>

<p>Insert a row into an existing table directly before or directly after an existing
data (i.e., non-content and non-label) row, specified by its path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert_row_at_path(tt, path, value, after = FALSE)

## S4 method for signature 'VTableTree,DataRow'
insert_row_at_path(tt, path, value, after = FALSE)

## S4 method for signature 'VTableTree,ANY'
insert_row_at_path(tt, path, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insert_row_at_path_+3A_tt">tt</code></td>
<td>
<p><code>TableTree</code> (or related class). A <code>TableTree</code> object representing a
populated table.</p>
</td></tr>
<tr><td><code id="insert_row_at_path_+3A_path">path</code></td>
<td>
<p>character. A vector path for a position within the structure of a
<code>tabletree</code>. Each element represents a subsequent choice amongst the children
of the previous choice.</p>
</td></tr>
<tr><td><code id="insert_row_at_path_+3A_value">value</code></td>
<td>
<p>The new value</p>
</td></tr>
<tr><td><code id="insert_row_at_path_+3A_after">after</code></td>
<td>
<p>logical(1). Should <code>value</code> be added as a row directly before (<code>FALSE</code>,
the default) or after (<code>TRUE</code>) the row specified by <code>path</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+DataRow">DataRow()</a></code> <code><a href="#topic+rrow">rrow()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lyt &lt;- basic_table() %&gt;%
  split_rows_by("COUNTRY", split_fun = keep_split_levels(c("CHN", "USA"))) %&gt;%
  analyze("AGE")

tbl &lt;- build_table(lyt, DM)

tbl2 &lt;- insert_row_at_path(
  tbl, c("COUNTRY", "CHN", "AGE", "Mean"),
  rrow("new row", 555)
)
tbl2

tbl3 &lt;- insert_row_at_path(tbl2, c("COUNTRY", "CHN", "AGE", "Mean"),
  rrow("new row redux", 888),
  after = TRUE
)
tbl3
</code></pre>

<hr>
<h2 id='insert_rrow'>[DEPRECATED] insert <code>rrows</code> at (before) a specific location</h2><span id='topic+insert_rrow'></span>

<h3>Description</h3>

<p>This function is deprecated and will be removed in a future release of
<code>rtables</code>. Please use <code><a href="#topic+insert_row_at_path">insert_row_at_path</a></code> or
<code><a href="#topic+label_at_path">label_at_path</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert_rrow(tbl, rrow, at = 1, ascontent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insert_rrow_+3A_tbl">tbl</code></td>
<td>
<p><code>rtable</code></p>
</td></tr>
<tr><td><code id="insert_rrow_+3A_rrow">rrow</code></td>
<td>
<p><code>rrow</code> to append to <code>rtable</code></p>
</td></tr>
<tr><td><code id="insert_rrow_+3A_at">at</code></td>
<td>
<p>position into which to put the <code>rrow</code>, defaults to beginning (i.e. 1)</p>
</td></tr>
<tr><td><code id="insert_rrow_+3A_ascontent">ascontent</code></td>
<td>
<p>logical. Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>TableTree</code> of the same specific class as <code>tbl</code>
</p>


<h3>Note</h3>

<p>Label rows (i.e. a row with no data values, only a <code>row.name</code>) can only be
inserted at positions which do not already contain a label row when there
is a non-trivial nested row structure in <code>tbl</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>o &lt;- options(warn = 0)
lyt &lt;- basic_table() %&gt;%
  split_cols_by("Species") %&gt;%
  analyze("Sepal.Length")

tbl &lt;- build_table(lyt, iris)

insert_rrow(tbl, rrow("Hello World"))
insert_rrow(tbl, rrow("Hello World"), at = 2)

lyt2 &lt;- basic_table() %&gt;%
  split_cols_by("Species") %&gt;%
  split_rows_by("Species") %&gt;%
  analyze("Sepal.Length")

tbl2 &lt;- build_table(lyt2, iris)

insert_rrow(tbl2, rrow("Hello World"))
insert_rrow(tbl2, rrow("Hello World"), at = 2)
insert_rrow(tbl2, rrow("Hello World"), at = 4)

insert_rrow(tbl2, rrow("new row", 5, 6, 7))

insert_rrow(tbl2, rrow("new row", 5, 6, 7), at = 3)

options(o)
</code></pre>

<hr>
<h2 id='InstantiatedColumnInfo-class'><code>InstantiatedColumnInfo</code></h2><span id='topic+InstantiatedColumnInfo-class'></span><span id='topic+InstantiatedColumnInfo'></span>

<h3>Description</h3>

<p><code>InstantiatedColumnInfo</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InstantiatedColumnInfo(
  treelyt = LayoutColTree(),
  csubs = list(expression(TRUE)),
  extras = list(list()),
  cnts = NA_integer_,
  total_cnt = NA_integer_,
  dispcounts = FALSE,
  countformat = "(N=xx)",
  count_na_str = "",
  topleft = character()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InstantiatedColumnInfo-class_+3A_treelyt">treelyt</code></td>
<td>
<p><code>LayoutColTree</code>.</p>
</td></tr>
<tr><td><code id="InstantiatedColumnInfo-class_+3A_csubs">csubs</code></td>
<td>
<p>list. List of subsetting expressions</p>
</td></tr>
<tr><td><code id="InstantiatedColumnInfo-class_+3A_extras">extras</code></td>
<td>
<p>list. Extra arguments associated with the columns</p>
</td></tr>
<tr><td><code id="InstantiatedColumnInfo-class_+3A_cnts">cnts</code></td>
<td>
<p>integer. Counts.</p>
</td></tr>
<tr><td><code id="InstantiatedColumnInfo-class_+3A_total_cnt">total_cnt</code></td>
<td>
<p>integer(1). Total observations represented across all
columns.</p>
</td></tr>
<tr><td><code id="InstantiatedColumnInfo-class_+3A_dispcounts">dispcounts</code></td>
<td>
<p>logical(1). Should the counts be displayed as header info when
the associated table is printed.</p>
</td></tr>
<tr><td><code id="InstantiatedColumnInfo-class_+3A_countformat">countformat</code></td>
<td>
<p>character(1). Format for the counts if they are displayed</p>
</td></tr>
<tr><td><code id="InstantiatedColumnInfo-class_+3A_count_na_str">count_na_str</code></td>
<td>
<p>character. NA string to be used when formatting counts. Defaults
to <code>""</code>.</p>
</td></tr>
<tr><td><code id="InstantiatedColumnInfo-class_+3A_topleft">topleft</code></td>
<td>
<p>character. Override values for the &quot;top left&quot; material to be
displayed during printing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>InstantiateadColumnInfo</code> object.
</p>

<hr>
<h2 id='internal_methods'>combine <code>SplitVector</code> objects</h2><span id='topic+internal_methods'></span><span id='topic+c+2CSplitVector-method'></span><span id='topic+split_rows'></span><span id='topic+split_rows+2CNULL-method'></span><span id='topic+split_rows+2CPreDataRowLayout-method'></span><span id='topic+split_rows+2CSplitVector-method'></span><span id='topic+split_rows+2CPreDataTableLayouts-method'></span><span id='topic+split_rows+2CANY-method'></span><span id='topic+cmpnd_last_rowsplit'></span><span id='topic+cmpnd_last_rowsplit+2CNULL-method'></span><span id='topic+cmpnd_last_rowsplit+2CPreDataRowLayout-method'></span><span id='topic+cmpnd_last_rowsplit+2CSplitVector-method'></span><span id='topic+cmpnd_last_rowsplit+2CPreDataTableLayouts-method'></span><span id='topic+cmpnd_last_rowsplit+2CANY-method'></span><span id='topic+split_cols'></span><span id='topic+split_cols+2CNULL-method'></span><span id='topic+split_cols+2CPreDataColLayout-method'></span><span id='topic+split_cols+2CSplitVector-method'></span><span id='topic+split_cols+2CPreDataTableLayouts-method'></span><span id='topic+split_cols+2CANY-method'></span><span id='topic+.add_row_summary'></span><span id='topic+.add_row_summary+2CPreDataTableLayouts-method'></span><span id='topic+.add_row_summary+2CPreDataRowLayout-method'></span><span id='topic+.add_row_summary+2CSplitVector-method'></span><span id='topic+.add_row_summary+2CSplit-method'></span><span id='topic+fix_dyncuts'></span><span id='topic+fix_dyncuts+2CSplit-method'></span><span id='topic+fix_dyncuts+2CVarDynCutSplit-method'></span><span id='topic+fix_dyncuts+2CVTableTree-method'></span><span id='topic+fix_dyncuts+2CPreDataRowLayout-method'></span><span id='topic+fix_dyncuts+2CPreDataColLayout-method'></span><span id='topic+fix_dyncuts+2CSplitVector-method'></span><span id='topic+fix_dyncuts+2CPreDataTableLayouts-method'></span><span id='topic+summarize_rows_inner'></span><span id='topic+summarize_rows_inner+2CTableTree-method'></span><span id='topic+summarize_rows_inner+2CElementaryTable-method'></span><span id='topic+summarize_rows_inner+2CTableRow-method'></span><span id='topic+summarize_rows_inner+2CLabelRow-method'></span><span id='topic+table_structure_inner'></span><span id='topic+str'></span><span id='topic+str+2CVTableTree-method'></span><span id='topic+table_structure_inner+2CTableTree-method'></span><span id='topic+table_structure_inner+2CElementaryTable-method'></span><span id='topic+table_structure_inner+2CTableRow-method'></span><span id='topic+table_structure_inner+2CLabelRow-method'></span><span id='topic+nrow+2CTableRow-method'></span><span id='topic+ncol+2CTableRow-method'></span><span id='topic+ncol+2CLabelRow-method'></span><span id='topic+ncol+2CInstantiatedColumnInfo-method'></span><span id='topic+tree_children+2CVTree-method'></span><span id='topic+tree_children+2CVTableTree-method'></span><span id='topic+tree_children+2CANY-method'></span><span id='topic+tree_children+3C-+2CVTree-method'></span><span id='topic+tree_children+3C-+2CVTableTree-method'></span><span id='topic+content_table+2CTableTree-method'></span><span id='topic+content_table+2CANY-method'></span><span id='topic+content_table+3C-+2CTableTree+2CElementaryTable-method'></span><span id='topic+next_rpos'></span><span id='topic+next_rpos+2CPreDataTableLayouts-method'></span><span id='topic+next_rpos+2CPreDataRowLayout-method'></span><span id='topic+next_rpos+2CANY-method'></span><span id='topic+next_cpos'></span><span id='topic+next_cpos+2CPreDataTableLayouts-method'></span><span id='topic+next_cpos+2CPreDataColLayout-method'></span><span id='topic+next_cpos+2CANY-method'></span><span id='topic+last_rowsplit'></span><span id='topic+last_rowsplit+2CNULL-method'></span><span id='topic+last_rowsplit+2CSplitVector-method'></span><span id='topic+last_rowsplit+2CPreDataRowLayout-method'></span><span id='topic+last_rowsplit+2CPreDataTableLayouts-method'></span><span id='topic+rlayout'></span><span id='topic+rlayout+2CPreDataTableLayouts-method'></span><span id='topic+rlayout+2CANY-method'></span><span id='topic+rlayout+3C-'></span><span id='topic+rlayout+3C-+2CPreDataTableLayouts-method'></span><span id='topic+tree_pos'></span><span id='topic+tree_pos+2CVLayoutNode-method'></span><span id='topic+pos_subset'></span><span id='topic+pos_subset+2CTreePos-method'></span><span id='topic+pos_subset+2CVLayoutNode-method'></span><span id='topic+pos_splits'></span><span id='topic+pos_splits+2CTreePos-method'></span><span id='topic+pos_splits+2CVLayoutNode-method'></span><span id='topic+pos_splvals'></span><span id='topic+pos_splvals+2CTreePos-method'></span><span id='topic+pos_splvals+2CVLayoutNode-method'></span><span id='topic+pos_splval_labels'></span><span id='topic+pos_splval_labels+2CTreePos-method'></span><span id='topic+spl_payload'></span><span id='topic+spl_payload+2CSplit-method'></span><span id='topic+spl_payload+3C-'></span><span id='topic+spl_payload+3C-+2CSplit-method'></span><span id='topic+spl_label_var'></span><span id='topic+spl_label_var+2CVarLevelSplit-method'></span><span id='topic+spl_label_var+2CSplit-method'></span><span id='topic+tt_labelrow'></span><span id='topic+tt_labelrow+2CVTableTree-method'></span><span id='topic+tt_labelrow+3C-'></span><span id='topic+tt_labelrow+3C-+2CVTableTree+2CLabelRow-method'></span><span id='topic+labelrow_visible'></span><span id='topic+labelrow_visible+2CVTableTree-method'></span><span id='topic+labelrow_visible+2CLabelRow-method'></span><span id='topic+labelrow_visible+2CVAnalyzeSplit-method'></span><span id='topic+labelrow_visible+3C-'></span><span id='topic+labelrow_visible+3C-+2CVTableTree-method'></span><span id='topic+labelrow_visible+3C-+2CLabelRow-method'></span><span id='topic+labelrow_visible+3C-+2CVAnalyzeSplit-method'></span><span id='topic+label_kids'></span><span id='topic+label_kids+2CSplit-method'></span><span id='topic+label_kids+3C-'></span><span id='topic+label_kids+3C-+2CSplit+2Ccharacter-method'></span><span id='topic+label_kids+3C-+2CSplit+2Clogical-method'></span><span id='topic+vis_label'></span><span id='topic+vis_label+2CSplit-method'></span><span id='topic+label_position'></span><span id='topic+label_position+2CSplit-method'></span><span id='topic+label_position+2CVAnalyzeSplit-method'></span><span id='topic+label_position+3C-'></span><span id='topic+label_position+3C-+2CSplit-method'></span><span id='topic+content_fun'></span><span id='topic+content_fun+2CSplit-method'></span><span id='topic+content_fun+3C-'></span><span id='topic+content_fun+3C-+2CSplit-method'></span><span id='topic+analysis_fun'></span><span id='topic+analysis_fun+2CAnalyzeVarSplit-method'></span><span id='topic+analysis_fun+2CAnalyzeColVarSplit-method'></span><span id='topic+split_fun'></span><span id='topic+split_fun+2CCustomizableSplit-method'></span><span id='topic+split_fun+2CSplit-method'></span><span id='topic+split_fun+3C-'></span><span id='topic+split_fun+3C-+2CCustomizableSplit-method'></span><span id='topic+split_fun+3C-+2CSplit-method'></span><span id='topic+content_extra_args'></span><span id='topic+content_extra_args+2CSplit-method'></span><span id='topic+content_extra_args+3C-'></span><span id='topic+content_extra_args+3C-+2CSplit-method'></span><span id='topic+content_var'></span><span id='topic+content_var+2CSplit-method'></span><span id='topic+content_var+3C-'></span><span id='topic+content_var+3C-+2CSplit-method'></span><span id='topic+avar_inclNAs'></span><span id='topic+avar_inclNAs+2CVAnalyzeSplit-method'></span><span id='topic+avar_inclNAs+3C-'></span><span id='topic+avar_inclNAs+3C-+2CVAnalyzeSplit-method'></span><span id='topic+spl_labelvar'></span><span id='topic+spl_labelvar+2CVarLevelSplit-method'></span><span id='topic+spl_child_order'></span><span id='topic+spl_child_order+2CVarLevelSplit-method'></span><span id='topic+spl_child_order+3C-'></span><span id='topic+spl_child_order+3C-+2CVarLevelSplit-method'></span><span id='topic+spl_child_order+2CManualSplit-method'></span><span id='topic+spl_child_order+2CMultiVarSplit-method'></span><span id='topic+spl_child_order+2CAllSplit-method'></span><span id='topic+spl_child_order+2CVarStaticCutSplit-method'></span><span id='topic+root_spl'></span><span id='topic+root_spl+2CPreDataAxisLayout-method'></span><span id='topic+root_spl+3C-'></span><span id='topic+root_spl+3C-+2CPreDataAxisLayout-method'></span><span id='topic+spanned_values'></span><span id='topic+spanned_values+2CTableRow-method'></span><span id='topic+spanned_values+2CLabelRow-method'></span><span id='topic+spanned_cells'></span><span id='topic+spanned_cells+2CTableRow-method'></span><span id='topic+spanned_cells+2CLabelRow-method'></span><span id='topic+spanned_values+3C-'></span><span id='topic+spanned_values+3C-+2CTableRow-method'></span><span id='topic+spanned_values+3C-+2CLabelRow-method'></span><span id='topic+obj_na_str+3C-+2CCellValue-method'></span><span id='topic+obj_na_str+3C-+2CVTableNodeInfo-method'></span><span id='topic+obj_na_str+3C-+2CSplit-method'></span><span id='topic+obj_na_str+2CVTableNodeInfo-method'></span><span id='topic+set_format_recursive'></span><span id='topic+set_format_recursive+2CTableRow-method'></span><span id='topic+set_format_recursive+2CLabelRow-method'></span><span id='topic+content_format'></span><span id='topic+content_format+2CSplit-method'></span><span id='topic+content_format+3C-'></span><span id='topic+content_format+3C-+2CSplit-method'></span><span id='topic+content_na_str'></span><span id='topic+content_na_str+2CSplit-method'></span><span id='topic+content_na_str+3C-'></span><span id='topic+content_na_str+3C-+2CSplit-method'></span><span id='topic+collect_leaves+2CTableTree-method'></span><span id='topic+collect_leaves+2CElementaryTable-method'></span><span id='topic+collect_leaves+2CVTree-method'></span><span id='topic+collect_leaves+2CVLeaf-method'></span><span id='topic+collect_leaves+2CNULL-method'></span><span id='topic+collect_leaves+2CANY-method'></span><span id='topic+row_cspans'></span><span id='topic+row_cspans+2CTableRow-method'></span><span id='topic+row_cspans+2CLabelRow-method'></span><span id='topic+row_cspans+3C-'></span><span id='topic+row_cspans+3C-+2CTableRow-method'></span><span id='topic+row_cspans+3C-+2CLabelRow-method'></span><span id='topic+cell_cspan'></span><span id='topic+cell_cspan+2CCellValue-method'></span><span id='topic+cell_cspan+3C-'></span><span id='topic+cell_cspan+3C-+2CCellValue-method'></span><span id='topic+cell_align'></span><span id='topic+cell_align+2CCellValue-method'></span><span id='topic+cell_align+3C-'></span><span id='topic+cell_align+3C-+2CCellValue-method'></span><span id='topic+tt_level'></span><span id='topic+tt_level+2CVNodeInfo-method'></span><span id='topic+tt_level+3C-'></span><span id='topic+tt_level+3C-+2CVNodeInfo-method'></span><span id='topic+tt_level+3C-+2CVTableTree-method'></span><span id='topic+indent_mod'></span><span id='topic+indent_mod+2CSplit-method'></span><span id='topic+indent_mod+2CVTableNodeInfo-method'></span><span id='topic+indent_mod+2CANY-method'></span><span id='topic+indent_mod+2CRowsVerticalSection-method'></span><span id='topic+indent_mod+3C-'></span><span id='topic+indent_mod+3C-+2CSplit-method'></span><span id='topic+indent_mod+3C-+2CVTableNodeInfo-method'></span><span id='topic+indent_mod+3C-+2CCellValue-method'></span><span id='topic+indent_mod+3C-+2CRowsVerticalSection-method'></span><span id='topic+content_indent_mod'></span><span id='topic+content_indent_mod+2CSplit-method'></span><span id='topic+content_indent_mod+2CVTableNodeInfo-method'></span><span id='topic+content_indent_mod+3C-'></span><span id='topic+content_indent_mod+3C-+2CSplit-method'></span><span id='topic+content_indent_mod+3C-+2CVTableNodeInfo-method'></span><span id='topic+rawvalues'></span><span id='topic+rawvalues+2CValueWrapper-method'></span><span id='topic+rawvalues+2CLevelComboSplitValue-method'></span><span id='topic+rawvalues+2Clist-method'></span><span id='topic+rawvalues+2CANY-method'></span><span id='topic+rawvalues+2CCellValue-method'></span><span id='topic+rawvalues+2CTreePos-method'></span><span id='topic+rawvalues+2CRowsVerticalSection-method'></span><span id='topic+value_names'></span><span id='topic+value_names+2CANY-method'></span><span id='topic+value_names+2CTreePos-method'></span><span id='topic+value_names+2Clist-method'></span><span id='topic+value_names+2CValueWrapper-method'></span><span id='topic+value_names+2CLevelComboSplitValue-method'></span><span id='topic+value_names+2CRowsVerticalSection-method'></span><span id='topic+value_labels'></span><span id='topic+value_labels+2CANY-method'></span><span id='topic+value_labels+2CTreePos-method'></span><span id='topic+value_labels+2Clist-method'></span><span id='topic+value_labels+2CRowsVerticalSection-method'></span><span id='topic+value_labels+2CValueWrapper-method'></span><span id='topic+value_labels+2CLevelComboSplitValue-method'></span><span id='topic+value_labels+2CMultiVarSplit-method'></span><span id='topic+spl_varlabels'></span><span id='topic+spl_varlabels+2CMultiVarSplit-method'></span><span id='topic+spl_varlabels+3C-'></span><span id='topic+spl_varlabels+3C-+2CMultiVarSplit-method'></span><span id='topic+splv_extra'></span><span id='topic+splv_extra+2CSplitValue-method'></span><span id='topic+splv_extra+3C-'></span><span id='topic+splv_extra+3C-+2CSplitValue-method'></span><span id='topic+split_exargs'></span><span id='topic+split_exargs+2CSplit-method'></span><span id='topic+split_exargs+3C-'></span><span id='topic+split_exargs+3C-+2CSplit-method'></span><span id='topic+col_extra_args'></span><span id='topic+col_extra_args+2CInstantiatedColumnInfo-method'></span><span id='topic+col_extra_args+2CPreDataTableLayouts-method'></span><span id='topic+col_extra_args+2CPreDataColLayout-method'></span><span id='topic+col_extra_args+2CLayoutColTree-method'></span><span id='topic+col_extra_args+2CLayoutColLeaf-method'></span><span id='topic+disp_ccounts'></span><span id='topic+disp_ccounts+2CVTableTree-method'></span><span id='topic+disp_ccounts+2CInstantiatedColumnInfo-method'></span><span id='topic+disp_ccounts+2CPreDataTableLayouts-method'></span><span id='topic+disp_ccounts+2CPreDataColLayout-method'></span><span id='topic+disp_ccounts+3C-'></span><span id='topic+disp_ccounts+3C-+2CVTableTree-method'></span><span id='topic+disp_ccounts+3C-+2CInstantiatedColumnInfo-method'></span><span id='topic+disp_ccounts+3C-+2CPreDataColLayout-method'></span><span id='topic+disp_ccounts+3C-+2CLayoutColTree-method'></span><span id='topic+disp_ccounts+3C-+2CPreDataTableLayouts-method'></span><span id='topic+colcount_format'></span><span id='topic+colcount_format+2CInstantiatedColumnInfo-method'></span><span id='topic+colcount_format+2CVTableNodeInfo-method'></span><span id='topic+colcount_format+2CPreDataColLayout-method'></span><span id='topic+colcount_format+2CPreDataTableLayouts-method'></span><span id='topic+colcount_format+3C-'></span><span id='topic+colcount_format+3C-+2CInstantiatedColumnInfo-method'></span><span id='topic+colcount_format+3C-+2CVTableNodeInfo-method'></span><span id='topic+colcount_format+3C-+2CPreDataColLayout-method'></span><span id='topic+colcount_format+3C-+2CPreDataTableLayouts-method'></span><span id='topic+as.vector+2CTableRow-method'></span><span id='topic+as.vector+2CElementaryTable-method'></span><span id='topic+spl_cuts'></span><span id='topic+spl_cuts+2CVarStaticCutSplit-method'></span><span id='topic+spl_cutlabels'></span><span id='topic+spl_cutlabels+2CVarStaticCutSplit-method'></span><span id='topic+spl_cutfun'></span><span id='topic+spl_cutfun+2CVarDynCutSplit-method'></span><span id='topic+spl_cutlabelfun'></span><span id='topic+spl_cutlabelfun+2CVarDynCutSplit-method'></span><span id='topic+spl_is_cmlcuts'></span><span id='topic+spl_is_cmlcuts+2CVarDynCutSplit-method'></span><span id='topic+spl_varnames'></span><span id='topic+spl_varnames+2CMultiVarSplit-method'></span><span id='topic+spl_varnames+3C-'></span><span id='topic+spl_varnames+3C-+2CMultiVarSplit-method'></span><span id='topic+row_footnotes+2CTableRow-method'></span><span id='topic+row_footnotes+2CRowsVerticalSection-method'></span><span id='topic+row_footnotes+3C-+2CTableRow-method'></span><span id='topic+row_footnotes+2CVTableTree-method'></span><span id='topic+cell_footnotes+2CCellValue-method'></span><span id='topic+cell_footnotes+2CTableRow-method'></span><span id='topic+cell_footnotes+2CLabelRow-method'></span><span id='topic+cell_footnotes+2CVTableTree-method'></span><span id='topic+cell_footnotes+3C-+2CCellValue-method'></span><span id='topic+cell_footnotes+3C-+2CDataRow-method'></span><span id='topic+cell_footnotes+3C-+2CContentRow-method'></span><span id='topic+col_fnotes_here+3C-+2CANY-method'></span><span id='topic+col_footnotes+2CLayoutColTree-method'></span><span id='topic+col_footnotes+2CLayoutColLeaf-method'></span><span id='topic+col_footnotes+3C-+2CLayoutColTree-method'></span><span id='topic+col_footnotes+3C-+2CLayoutColLeaf-method'></span><span id='topic+col_footnotes+2CVTableTree-method'></span><span id='topic+ref_index+2CRefFootnote-method'></span><span id='topic+ref_index+3C-+2CRefFootnote-method'></span><span id='topic+ref_symbol+2CRefFootnote-method'></span><span id='topic+ref_symbol+3C-+2CRefFootnote-method'></span><span id='topic+ref_msg+2CRefFootnote-method'></span><span id='topic+fnotes_at_path+3C-+2CVTableTree+2Ccharacter-method'></span><span id='topic+fnotes_at_path+3C-+2CVTableTree+2CNULL-method'></span><span id='topic+rbind2+2CVTableNodeInfo+2Cmissing-method'></span><span id='topic+tt_at_path+2CVTableTree-method'></span><span id='topic+tt_at_path+3C-+2CVTableTree+2CANY+2CVTableTree-method'></span><span id='topic+tt_at_path+3C-+2CVTableTree+2CANY+2CNULL-method'></span><span id='topic+tt_at_path+3C-+2CVTableTree+2CANY+2CTableRow-method'></span><span id='topic++5B+3C-+2CVTableTree+2CANY+2CANY+2CCellValue-method'></span><span id='topic++5B+2CVTableTree+2Clogical+2CANY-method'></span><span id='topic++5B+2CVTableTree+2Clogical+2Cmissing-method'></span><span id='topic++5B+2CVTableTree+2CANY+2Clogical-method'></span><span id='topic++5B+2CVTableTree+2CANY+2Cmissing-method'></span><span id='topic++5B+2CVTableTree+2Cmissing+2CANY-method'></span><span id='topic++5B+2CVTableTree+2CANY+2Ccharacter-method'></span><span id='topic++5B+2CVTableTree+2Ccharacter+2CANY-method'></span><span id='topic++5B+2CVTableTree+2Ccharacter+2Ccharacter-method'></span><span id='topic++5B+2CVTableTree+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+2CVTableTree+2Cnumeric+2Cnumeric-method'></span><span id='topic+cell_values+2CVTableTree-method'></span><span id='topic+cell_values+2CTableRow-method'></span><span id='topic+cell_values+2CLabelRow-method'></span><span id='topic+value_at+2CTableRow-method'></span><span id='topic+value_at+2CLabelRow-method'></span><span id='topic+print+2CVTableTree-method'></span><span id='topic+show+2CVTableTree-method'></span>

<h3>Description</h3>

<p>These are internal methods that are documented only to satisfy
<code style="white-space: pre;">&#8288;R CMD check&#8288;</code>. End users should pay no attention to this documentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SplitVector'
c(x, ...)

split_rows(lyt = NULL, spl, pos, cmpnd_fun = AnalyzeMultiVars)

## S4 method for signature ''NULL''
split_rows(lyt = NULL, spl, pos, cmpnd_fun = AnalyzeMultiVars)

## S4 method for signature 'PreDataRowLayout'
split_rows(lyt = NULL, spl, pos, cmpnd_fun = AnalyzeMultiVars)

## S4 method for signature 'SplitVector'
split_rows(lyt = NULL, spl, pos, cmpnd_fun = AnalyzeMultiVars)

## S4 method for signature 'PreDataTableLayouts'
split_rows(lyt, spl, pos)

## S4 method for signature 'ANY'
split_rows(lyt, spl, pos)

cmpnd_last_rowsplit(lyt, spl, constructor)

## S4 method for signature ''NULL''
cmpnd_last_rowsplit(lyt, spl, constructor)

## S4 method for signature 'PreDataRowLayout'
cmpnd_last_rowsplit(lyt, spl, constructor)

## S4 method for signature 'SplitVector'
cmpnd_last_rowsplit(lyt, spl, constructor)

## S4 method for signature 'PreDataTableLayouts'
cmpnd_last_rowsplit(lyt, spl, constructor)

## S4 method for signature 'ANY'
cmpnd_last_rowsplit(lyt, spl, constructor)

split_cols(lyt = NULL, spl, pos)

## S4 method for signature ''NULL''
split_cols(lyt = NULL, spl, pos)

## S4 method for signature 'PreDataColLayout'
split_cols(lyt = NULL, spl, pos)

## S4 method for signature 'SplitVector'
split_cols(lyt = NULL, spl, pos)

## S4 method for signature 'PreDataTableLayouts'
split_cols(lyt = NULL, spl, pos)

## S4 method for signature 'ANY'
split_cols(lyt = NULL, spl, pos)

.add_row_summary(
  lyt,
  label,
  cfun,
  child_labels = c("default", "visible", "hidden"),
  cformat = NULL,
  cna_str = "-",
  indent_mod = 0L,
  cvar = "",
  extra_args = list()
)

## S4 method for signature 'PreDataTableLayouts'
.add_row_summary(
  lyt,
  label,
  cfun,
  child_labels = c("default", "visible", "hidden"),
  cformat = NULL,
  cna_str = "-",
  indent_mod = 0L,
  cvar = "",
  extra_args = list()
)

## S4 method for signature 'PreDataRowLayout'
.add_row_summary(
  lyt,
  label,
  cfun,
  child_labels = c("default", "visible", "hidden"),
  cformat = NULL,
  cna_str = "-",
  indent_mod = 0L,
  cvar = "",
  extra_args = list()
)

## S4 method for signature 'SplitVector'
.add_row_summary(
  lyt,
  label,
  cfun,
  child_labels = c("default", "visible", "hidden"),
  cformat = NULL,
  cna_str = "-",
  indent_mod = 0L,
  cvar = "",
  extra_args = list()
)

## S4 method for signature 'Split'
.add_row_summary(
  lyt,
  label,
  cfun,
  child_labels = c("default", "visible", "hidden"),
  cformat = NULL,
  cna_str = "-",
  indent_mod = 0L,
  cvar = "",
  extra_args = list()
)

fix_dyncuts(spl, df)

## S4 method for signature 'Split'
fix_dyncuts(spl, df)

## S4 method for signature 'VarDynCutSplit'
fix_dyncuts(spl, df)

## S4 method for signature 'VTableTree'
fix_dyncuts(spl, df)

## S4 method for signature 'PreDataRowLayout'
fix_dyncuts(spl, df)

## S4 method for signature 'PreDataColLayout'
fix_dyncuts(spl, df)

## S4 method for signature 'SplitVector'
fix_dyncuts(spl, df)

## S4 method for signature 'PreDataTableLayouts'
fix_dyncuts(spl, df)

summarize_rows_inner(obj, depth = 0, indent = 0)

## S4 method for signature 'TableTree'
summarize_rows_inner(obj, depth = 0, indent = 0)

## S4 method for signature 'ElementaryTable'
summarize_rows_inner(obj, depth = 0, indent = 0)

## S4 method for signature 'TableRow'
summarize_rows_inner(obj, depth = 0, indent = 0)

## S4 method for signature 'LabelRow'
summarize_rows_inner(obj, depth = 0, indent = 0)

table_structure_inner(obj, depth = 0, indent = 0, print_indent = 0)

str(object, ...)

## S4 method for signature 'VTableTree'
str(object, max.level = 3L, ...)

## S4 method for signature 'TableTree'
table_structure_inner(obj, depth = 0, indent = 0, print_indent = 0)

## S4 method for signature 'ElementaryTable'
table_structure_inner(obj, depth = 0, indent = 0, print_indent = 0)

## S4 method for signature 'TableRow'
table_structure_inner(obj, depth = 0, indent = 0, print_indent = 0)

## S4 method for signature 'LabelRow'
table_structure_inner(obj, depth = 0, indent = 0, print_indent = 0)

## S4 method for signature 'TableRow'
nrow(x)

## S4 method for signature 'TableRow'
ncol(x)

## S4 method for signature 'LabelRow'
ncol(x)

## S4 method for signature 'InstantiatedColumnInfo'
ncol(x)

## S4 method for signature 'VTree'
tree_children(x)

## S4 method for signature 'VTableTree'
tree_children(x)

## S4 method for signature 'ANY'
tree_children(x)

## S4 replacement method for signature 'VTree'
tree_children(x) &lt;- value

## S4 replacement method for signature 'VTableTree'
tree_children(x) &lt;- value

## S4 method for signature 'TableTree'
content_table(obj)

## S4 method for signature 'ANY'
content_table(obj)

## S4 replacement method for signature 'TableTree,ElementaryTable'
content_table(obj) &lt;- value

next_rpos(obj, nested = TRUE, for_analyze = FALSE)

## S4 method for signature 'PreDataTableLayouts'
next_rpos(obj, nested = TRUE, for_analyze = FALSE)

## S4 method for signature 'PreDataRowLayout'
next_rpos(obj, nested = TRUE, for_analyze = FALSE)

## S4 method for signature 'ANY'
next_rpos(obj, nested)

next_cpos(obj, nested = TRUE)

## S4 method for signature 'PreDataTableLayouts'
next_cpos(obj, nested = TRUE)

## S4 method for signature 'PreDataColLayout'
next_cpos(obj, nested = TRUE)

## S4 method for signature 'ANY'
next_cpos(obj, nested = TRUE)

last_rowsplit(obj)

## S4 method for signature ''NULL''
last_rowsplit(obj)

## S4 method for signature 'SplitVector'
last_rowsplit(obj)

## S4 method for signature 'PreDataRowLayout'
last_rowsplit(obj)

## S4 method for signature 'PreDataTableLayouts'
last_rowsplit(obj)

rlayout(obj)

## S4 method for signature 'PreDataTableLayouts'
rlayout(obj)

## S4 method for signature 'ANY'
rlayout(obj)

rlayout(object) &lt;- value

## S4 replacement method for signature 'PreDataTableLayouts'
rlayout(object) &lt;- value

tree_pos(obj)

## S4 method for signature 'VLayoutNode'
tree_pos(obj)

pos_subset(obj)

## S4 method for signature 'TreePos'
pos_subset(obj)

## S4 method for signature 'VLayoutNode'
pos_subset(obj)

pos_splits(obj)

## S4 method for signature 'TreePos'
pos_splits(obj)

## S4 method for signature 'VLayoutNode'
pos_splits(obj)

pos_splvals(obj)

## S4 method for signature 'TreePos'
pos_splvals(obj)

## S4 method for signature 'VLayoutNode'
pos_splvals(obj)

pos_splval_labels(obj)

## S4 method for signature 'TreePos'
pos_splval_labels(obj)

spl_payload(obj)

## S4 method for signature 'Split'
spl_payload(obj)

spl_payload(obj) &lt;- value

## S4 replacement method for signature 'Split'
spl_payload(obj) &lt;- value

spl_label_var(obj)

## S4 method for signature 'VarLevelSplit'
spl_label_var(obj)

## S4 method for signature 'Split'
spl_label_var(obj)

tt_labelrow(obj)

## S4 method for signature 'VTableTree'
tt_labelrow(obj)

tt_labelrow(obj) &lt;- value

## S4 replacement method for signature 'VTableTree,LabelRow'
tt_labelrow(obj) &lt;- value

labelrow_visible(obj)

## S4 method for signature 'VTableTree'
labelrow_visible(obj)

## S4 method for signature 'LabelRow'
labelrow_visible(obj)

## S4 method for signature 'VAnalyzeSplit'
labelrow_visible(obj)

labelrow_visible(obj) &lt;- value

## S4 replacement method for signature 'VTableTree'
labelrow_visible(obj) &lt;- value

## S4 replacement method for signature 'LabelRow'
labelrow_visible(obj) &lt;- value

## S4 replacement method for signature 'VAnalyzeSplit'
labelrow_visible(obj) &lt;- value

label_kids(spl)

## S4 method for signature 'Split'
label_kids(spl)

label_kids(spl) &lt;- value

## S4 replacement method for signature 'Split,character'
label_kids(spl) &lt;- value

## S4 replacement method for signature 'Split,logical'
label_kids(spl) &lt;- value

vis_label(spl)

## S4 method for signature 'Split'
vis_label(spl)

label_position(spl)

## S4 method for signature 'Split'
label_position(spl)

## S4 method for signature 'VAnalyzeSplit'
label_position(spl)

label_position(spl) &lt;- value

## S4 replacement method for signature 'Split'
label_position(spl) &lt;- value

content_fun(obj)

## S4 method for signature 'Split'
content_fun(obj)

content_fun(object) &lt;- value

## S4 replacement method for signature 'Split'
content_fun(object) &lt;- value

analysis_fun(obj)

## S4 method for signature 'AnalyzeVarSplit'
analysis_fun(obj)

## S4 method for signature 'AnalyzeColVarSplit'
analysis_fun(obj)

split_fun(obj)

## S4 method for signature 'CustomizableSplit'
split_fun(obj)

## S4 method for signature 'Split'
split_fun(obj)

split_fun(obj) &lt;- value

## S4 replacement method for signature 'CustomizableSplit'
split_fun(obj) &lt;- value

## S4 replacement method for signature 'Split'
split_fun(obj) &lt;- value

content_extra_args(obj)

## S4 method for signature 'Split'
content_extra_args(obj)

content_extra_args(object) &lt;- value

## S4 replacement method for signature 'Split'
content_extra_args(object) &lt;- value

content_var(obj)

## S4 method for signature 'Split'
content_var(obj)

content_var(object) &lt;- value

## S4 replacement method for signature 'Split'
content_var(object) &lt;- value

avar_inclNAs(obj)

## S4 method for signature 'VAnalyzeSplit'
avar_inclNAs(obj)

avar_inclNAs(obj) &lt;- value

## S4 replacement method for signature 'VAnalyzeSplit'
avar_inclNAs(obj) &lt;- value

spl_labelvar(obj)

## S4 method for signature 'VarLevelSplit'
spl_labelvar(obj)

spl_child_order(obj)

## S4 method for signature 'VarLevelSplit'
spl_child_order(obj)

spl_child_order(obj) &lt;- value

## S4 replacement method for signature 'VarLevelSplit'
spl_child_order(obj) &lt;- value

## S4 method for signature 'ManualSplit'
spl_child_order(obj)

## S4 method for signature 'MultiVarSplit'
spl_child_order(obj)

## S4 method for signature 'AllSplit'
spl_child_order(obj)

## S4 method for signature 'VarStaticCutSplit'
spl_child_order(obj)

root_spl(obj)

## S4 method for signature 'PreDataAxisLayout'
root_spl(obj)

root_spl(obj) &lt;- value

## S4 replacement method for signature 'PreDataAxisLayout'
root_spl(obj) &lt;- value

spanned_values(obj)

## S4 method for signature 'TableRow'
spanned_values(obj)

## S4 method for signature 'LabelRow'
spanned_values(obj)

spanned_cells(obj)

## S4 method for signature 'TableRow'
spanned_cells(obj)

## S4 method for signature 'LabelRow'
spanned_cells(obj)

spanned_values(obj) &lt;- value

## S4 replacement method for signature 'TableRow'
spanned_values(obj) &lt;- value

## S4 replacement method for signature 'LabelRow'
spanned_values(obj) &lt;- value

## S4 replacement method for signature 'CellValue'
obj_na_str(obj) &lt;- value

## S4 replacement method for signature 'VTableNodeInfo'
obj_na_str(obj) &lt;- value

## S4 replacement method for signature 'Split'
obj_na_str(obj) &lt;- value

## S4 method for signature 'VTableNodeInfo'
obj_na_str(obj)

set_format_recursive(obj, format, na_str, override = FALSE)

## S4 method for signature 'TableRow'
set_format_recursive(obj, format, na_str, override = FALSE)

## S4 method for signature 'LabelRow'
set_format_recursive(obj, format, override = FALSE)

content_format(obj)

## S4 method for signature 'Split'
content_format(obj)

content_format(obj) &lt;- value

## S4 replacement method for signature 'Split'
content_format(obj) &lt;- value

content_na_str(obj)

## S4 method for signature 'Split'
content_na_str(obj)

content_na_str(obj) &lt;- value

## S4 replacement method for signature 'Split'
content_na_str(obj) &lt;- value

## S4 method for signature 'TableTree'
collect_leaves(tt, incl.cont = TRUE, add.labrows = FALSE)

## S4 method for signature 'ElementaryTable'
collect_leaves(tt, incl.cont = TRUE, add.labrows = FALSE)

## S4 method for signature 'VTree'
collect_leaves(tt, incl.cont = TRUE, add.labrows = FALSE)

## S4 method for signature 'VLeaf'
collect_leaves(tt, incl.cont = TRUE, add.labrows = FALSE)

## S4 method for signature ''NULL''
collect_leaves(tt, incl.cont = TRUE, add.labrows = FALSE)

## S4 method for signature 'ANY'
collect_leaves(tt, incl.cont = TRUE, add.labrows = FALSE)

row_cspans(obj)

## S4 method for signature 'TableRow'
row_cspans(obj)

## S4 method for signature 'LabelRow'
row_cspans(obj)

row_cspans(obj) &lt;- value

## S4 replacement method for signature 'TableRow'
row_cspans(obj) &lt;- value

## S4 replacement method for signature 'LabelRow'
row_cspans(obj) &lt;- value

cell_cspan(obj)

## S4 method for signature 'CellValue'
cell_cspan(obj)

cell_cspan(obj) &lt;- value

## S4 replacement method for signature 'CellValue'
cell_cspan(obj) &lt;- value

cell_align(obj)

## S4 method for signature 'CellValue'
cell_align(obj)

cell_align(obj) &lt;- value

## S4 replacement method for signature 'CellValue'
cell_align(obj) &lt;- value

tt_level(obj)

## S4 method for signature 'VNodeInfo'
tt_level(obj)

tt_level(obj) &lt;- value

## S4 replacement method for signature 'VNodeInfo'
tt_level(obj) &lt;- value

## S4 replacement method for signature 'VTableTree'
tt_level(obj) &lt;- value

indent_mod(obj)

## S4 method for signature 'Split'
indent_mod(obj)

## S4 method for signature 'VTableNodeInfo'
indent_mod(obj)

## S4 method for signature 'ANY'
indent_mod(obj)

## S4 method for signature 'RowsVerticalSection'
indent_mod(obj)

indent_mod(obj) &lt;- value

## S4 replacement method for signature 'Split'
indent_mod(obj) &lt;- value

## S4 replacement method for signature 'VTableNodeInfo'
indent_mod(obj) &lt;- value

## S4 replacement method for signature 'CellValue'
indent_mod(obj) &lt;- value

## S4 replacement method for signature 'RowsVerticalSection'
indent_mod(obj) &lt;- value

content_indent_mod(obj)

## S4 method for signature 'Split'
content_indent_mod(obj)

## S4 method for signature 'VTableNodeInfo'
content_indent_mod(obj)

content_indent_mod(obj) &lt;- value

## S4 replacement method for signature 'Split'
content_indent_mod(obj) &lt;- value

## S4 replacement method for signature 'VTableNodeInfo'
content_indent_mod(obj) &lt;- value

rawvalues(obj)

## S4 method for signature 'ValueWrapper'
rawvalues(obj)

## S4 method for signature 'LevelComboSplitValue'
rawvalues(obj)

## S4 method for signature 'list'
rawvalues(obj)

## S4 method for signature 'ANY'
rawvalues(obj)

## S4 method for signature 'CellValue'
rawvalues(obj)

## S4 method for signature 'TreePos'
rawvalues(obj)

## S4 method for signature 'RowsVerticalSection'
rawvalues(obj)

value_names(obj)

## S4 method for signature 'ANY'
value_names(obj)

## S4 method for signature 'TreePos'
value_names(obj)

## S4 method for signature 'list'
value_names(obj)

## S4 method for signature 'ValueWrapper'
value_names(obj)

## S4 method for signature 'LevelComboSplitValue'
value_names(obj)

## S4 method for signature 'RowsVerticalSection'
value_names(obj)

value_labels(obj)

## S4 method for signature 'ANY'
value_labels(obj)

## S4 method for signature 'TreePos'
value_labels(obj)

## S4 method for signature 'list'
value_labels(obj)

## S4 method for signature 'RowsVerticalSection'
value_labels(obj)

## S4 method for signature 'ValueWrapper'
value_labels(obj)

## S4 method for signature 'LevelComboSplitValue'
value_labels(obj)

## S4 method for signature 'MultiVarSplit'
value_labels(obj)

spl_varlabels(obj)

## S4 method for signature 'MultiVarSplit'
spl_varlabels(obj)

spl_varlabels(object) &lt;- value

## S4 replacement method for signature 'MultiVarSplit'
spl_varlabels(object) &lt;- value

splv_extra(obj)

## S4 method for signature 'SplitValue'
splv_extra(obj)

splv_extra(obj) &lt;- value

## S4 replacement method for signature 'SplitValue'
splv_extra(obj) &lt;- value

split_exargs(obj)

## S4 method for signature 'Split'
split_exargs(obj)

split_exargs(obj) &lt;- value

## S4 replacement method for signature 'Split'
split_exargs(obj) &lt;- value

col_extra_args(obj, df = NULL)

## S4 method for signature 'InstantiatedColumnInfo'
col_extra_args(obj, df = NULL)

## S4 method for signature 'PreDataTableLayouts'
col_extra_args(obj, df = NULL)

## S4 method for signature 'PreDataColLayout'
col_extra_args(obj, df = NULL)

## S4 method for signature 'LayoutColTree'
col_extra_args(obj, df = NULL)

## S4 method for signature 'LayoutColLeaf'
col_extra_args(obj, df = NULL)

disp_ccounts(obj)

## S4 method for signature 'VTableTree'
disp_ccounts(obj)

## S4 method for signature 'InstantiatedColumnInfo'
disp_ccounts(obj)

## S4 method for signature 'PreDataTableLayouts'
disp_ccounts(obj)

## S4 method for signature 'PreDataColLayout'
disp_ccounts(obj)

disp_ccounts(obj) &lt;- value

## S4 replacement method for signature 'VTableTree'
disp_ccounts(obj) &lt;- value

## S4 replacement method for signature 'InstantiatedColumnInfo'
disp_ccounts(obj) &lt;- value

## S4 replacement method for signature 'PreDataColLayout'
disp_ccounts(obj) &lt;- value

## S4 replacement method for signature 'LayoutColTree'
disp_ccounts(obj) &lt;- value

## S4 replacement method for signature 'PreDataTableLayouts'
disp_ccounts(obj) &lt;- value

colcount_format(obj)

## S4 method for signature 'InstantiatedColumnInfo'
colcount_format(obj)

## S4 method for signature 'VTableNodeInfo'
colcount_format(obj)

## S4 method for signature 'PreDataColLayout'
colcount_format(obj)

## S4 method for signature 'PreDataTableLayouts'
colcount_format(obj)

colcount_format(obj) &lt;- value

## S4 replacement method for signature 'InstantiatedColumnInfo'
colcount_format(obj) &lt;- value

## S4 replacement method for signature 'VTableNodeInfo'
colcount_format(obj) &lt;- value

## S4 replacement method for signature 'PreDataColLayout'
colcount_format(obj) &lt;- value

## S4 replacement method for signature 'PreDataTableLayouts'
colcount_format(obj) &lt;- value

## S4 method for signature 'TableRow'
as.vector(x, mode = "any")

## S4 method for signature 'ElementaryTable'
as.vector(x, mode = "any")

spl_cuts(obj)

## S4 method for signature 'VarStaticCutSplit'
spl_cuts(obj)

spl_cutlabels(obj)

## S4 method for signature 'VarStaticCutSplit'
spl_cutlabels(obj)

spl_cutfun(obj)

## S4 method for signature 'VarDynCutSplit'
spl_cutfun(obj)

spl_cutlabelfun(obj)

## S4 method for signature 'VarDynCutSplit'
spl_cutlabelfun(obj)

spl_is_cmlcuts(obj)

## S4 method for signature 'VarDynCutSplit'
spl_is_cmlcuts(obj)

spl_varnames(obj)

## S4 method for signature 'MultiVarSplit'
spl_varnames(obj)

spl_varnames(object) &lt;- value

## S4 replacement method for signature 'MultiVarSplit'
spl_varnames(object) &lt;- value

## S4 method for signature 'TableRow'
row_footnotes(obj)

## S4 method for signature 'RowsVerticalSection'
row_footnotes(obj)

## S4 replacement method for signature 'TableRow'
row_footnotes(obj) &lt;- value

## S4 method for signature 'VTableTree'
row_footnotes(obj)

## S4 method for signature 'CellValue'
cell_footnotes(obj)

## S4 method for signature 'TableRow'
cell_footnotes(obj)

## S4 method for signature 'LabelRow'
cell_footnotes(obj)

## S4 method for signature 'VTableTree'
cell_footnotes(obj)

## S4 replacement method for signature 'CellValue'
cell_footnotes(obj) &lt;- value

## S4 replacement method for signature 'DataRow'
cell_footnotes(obj) &lt;- value

## S4 replacement method for signature 'ContentRow'
cell_footnotes(obj) &lt;- value

## S4 replacement method for signature 'ANY'
col_fnotes_here(obj) &lt;- value

## S4 method for signature 'LayoutColTree'
col_footnotes(obj)

## S4 method for signature 'LayoutColLeaf'
col_footnotes(obj)

## S4 replacement method for signature 'LayoutColTree'
col_footnotes(obj) &lt;- value

## S4 replacement method for signature 'LayoutColLeaf'
col_footnotes(obj) &lt;- value

## S4 method for signature 'VTableTree'
col_footnotes(obj)

## S4 method for signature 'RefFootnote'
ref_index(obj)

## S4 replacement method for signature 'RefFootnote'
ref_index(obj) &lt;- value

## S4 method for signature 'RefFootnote'
ref_symbol(obj)

## S4 replacement method for signature 'RefFootnote'
ref_symbol(obj) &lt;- value

## S4 method for signature 'RefFootnote'
ref_msg(obj)

## S4 replacement method for signature 'VTableTree,character'
fnotes_at_path(obj, rowpath = NULL, colpath = NULL, reset_idx = TRUE) &lt;- value

## S4 replacement method for signature 'VTableTree,'NULL''
fnotes_at_path(obj, rowpath = NULL, colpath = NULL, reset_idx = TRUE) &lt;- value

## S4 method for signature 'VTableNodeInfo,missing'
rbind2(x, y)

## S4 method for signature 'VTableTree'
tt_at_path(tt, path, ...)

## S4 replacement method for signature 'VTableTree,ANY,VTableTree'
tt_at_path(tt, path, ...) &lt;- value

## S4 replacement method for signature 'VTableTree,ANY,'NULL''
tt_at_path(tt, path, ...) &lt;- value

## S4 replacement method for signature 'VTableTree,ANY,TableRow'
tt_at_path(tt, path, ...) &lt;- value

## S4 replacement method for signature 'VTableTree,ANY,ANY,CellValue'
x[i, j, ...] &lt;- value

## S4 method for signature 'VTableTree,logical,ANY'
x[i, j, ..., drop = FALSE]

## S4 method for signature 'VTableTree,logical,missing'
x[i, j, ..., drop = FALSE]

## S4 method for signature 'VTableTree,ANY,logical'
x[i, j, ..., drop = FALSE]

## S4 method for signature 'VTableTree,ANY,missing'
x[i, j, ..., drop = FALSE]

## S4 method for signature 'VTableTree,missing,ANY'
x[i, j, ..., drop = FALSE]

## S4 method for signature 'VTableTree,ANY,character'
x[i, j, ..., drop = FALSE]

## S4 method for signature 'VTableTree,character,ANY'
x[i, j, ..., drop = FALSE]

## S4 method for signature 'VTableTree,character,character'
x[i, j, ..., drop = FALSE]

## S4 method for signature 'VTableTree,missing,numeric'
x[i, j, ..., drop = FALSE]

## S4 method for signature 'VTableTree,numeric,numeric'
x[i, j, ..., drop = FALSE]

## S4 method for signature 'VTableTree'
cell_values(tt, rowpath = NULL, colpath = NULL, omit_labrows = TRUE)

## S4 method for signature 'TableRow'
cell_values(tt, rowpath = NULL, colpath = NULL, omit_labrows = TRUE)

## S4 method for signature 'LabelRow'
cell_values(tt, rowpath = NULL, colpath = NULL, omit_labrows = TRUE)

## S4 method for signature 'TableRow'
value_at(tt, rowpath = NULL, colpath = NULL)

## S4 method for signature 'LabelRow'
value_at(tt, rowpath = NULL, colpath = NULL)

## S4 method for signature 'VTableTree'
print(x, ...)

## S4 method for signature 'VTableTree'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internal_methods_+3A_x">x</code></td>
<td>
<p>The object.</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_...">...</code></td>
<td>
<p>Splits or <code>SplitVector</code> objects</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_lyt">lyt</code></td>
<td>
<p>layout object pre-data used for tabulation</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_spl">spl</code></td>
<td>
<p>Split. The split.</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_pos">pos</code></td>
<td>
<p>numeric(1). Intended for internal use.</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_cmpnd_fun">cmpnd_fun</code></td>
<td>
<p>function. Intended for internal use.</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_constructor">constructor</code></td>
<td>
<p>function.</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_label">label</code></td>
<td>
<p>character(1). A label (not to be confused with the name) for the
object/structure.</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_cfun">cfun</code></td>
<td>
<p>list/function/NULL. tabulation function(s) for creating content
rows. Must accept <code>x</code> or <code>df</code> as first parameter. Must accept
<code>labelstr</code> as the second argument. Can optionally accept all optional
arguments accepted by analysis functions. See <code><a href="#topic+analyze">analyze</a></code>.</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_child_labels">child_labels</code></td>
<td>
<p>string. One of <code>"default"</code>, <code>"visible"</code>,
<code>"hidden"</code>. What should the display behavior be for the  labels (i.e.
label rows) of the children of this split. Defaults to <code>"default"</code>
which flags the label row as visible only if the child has 0 content rows.</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_cformat">cformat</code></td>
<td>
<p>format spec. Format for content rows</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_cna_str">cna_str</code></td>
<td>
<p>character. NA string for use with <code>cformat</code> for content
table.</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_indent_mod">indent_mod</code></td>
<td>
<p>numeric. Modifier for the default indent position for the
structure created by this function(subtable, content table, or row)
<em>and all of that structure's children</em>. Defaults to 0, which
corresponds to the unmodified default behavior.</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_cvar">cvar</code></td>
<td>
<p>character(1). The variable, if any, which the content function
should accept. Defaults to NA.</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_extra_args">extra_args</code></td>
<td>
<p>list. Extra arguments to be passed to the tabulation
function. Element position in the list corresponds to the children of this
split. Named elements in the child-specific lists are ignored if they do
not match a formal argument of the tabulation function.</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_df">df</code></td>
<td>
<p>dataset (<code>data.frame</code> or <code>tibble</code>)</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_obj">obj</code></td>
<td>
<p>The object.</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_depth">depth</code></td>
<td>
<p>depth in tree</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_indent">indent</code></td>
<td>
<p>indent</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_print_indent">print_indent</code></td>
<td>
<p>indent for print</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_object">object</code></td>
<td>
<p>a table object</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_max.level">max.level</code></td>
<td>
<p>numeric(1). Passed to <code>utils::str</code>. Defaults to 3 for the
<code>VTableTree</code> method, unlike the underlying default of <code>NA</code>. <code>NA</code> is <em>not</em>
appropriate for <code>VTableTree</code> objects.</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_value">value</code></td>
<td>
<p>The new value</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_nested">nested</code></td>
<td>
<p>boolean. Should this layout instruction be applied within the
existing layout structure <em>if possible</em> (<code>TRUE</code>, the default) or as a
new top-level element ('FALSE). Ignored if it would nest a split underneath
analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_for_analyze">for_analyze</code></td>
<td>
<p>logical(1).</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_format">format</code></td>
<td>
<p><code>FormatSpec</code>. Format associated with this split. Formats can be
declared via strings (<code>"xx.x"</code>) or function. In cases such as
<code>analyze</code> calls, they can character vectors or lists of functions.</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_na_str">na_str</code></td>
<td>
<p>character(1). String that should be displayed when the value of <code>x</code> is missing.
Defaults to <code>"NA"</code>.</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_override">override</code></td>
<td>
<p>logical(1).</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_tt">tt</code></td>
<td>
<p><code>TableTree</code> (or related class). A <code>TableTree</code> object representing a
populated table.</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_incl.cont">incl.cont</code></td>
<td>
<p>logical. Include rows from content tables within the tree. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="internal_methods_+3A_add.labrows">add.labrows</code></td>
<td>
<p>logical. Include label rows. Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="internal_methods_+3A_mode">mode</code></td>
<td>
<p>character(1). Passed on to <code><a href="base.html#topic+as.vector">as.vector</a></code></p>
</td></tr>
<tr><td><code id="internal_methods_+3A_rowpath">rowpath</code></td>
<td>
<p>character or NULL. Path within row structure. <code>NULL</code>
indicates the footnote should go on the column rather than cell.</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_colpath">colpath</code></td>
<td>
<p>character or NULL. Path within column structure. <code>NULL</code>
indicates footnote should go on the row rather than cell</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_reset_idx">reset_idx</code></td>
<td>
<p>logical(1). Should the numbering for referential footnotes
be immediately recalculated. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_y">y</code></td>
<td>
<p>Second element to be <code>rbound</code> via <code>rbind2</code></p>
</td></tr>
<tr><td><code id="internal_methods_+3A_path">path</code></td>
<td>
<p>character. A vector path for a position within the structure of a
<code>tabletree</code>. Each element represents a subsequent choice amongst the children
of the previous choice.</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_i">i</code></td>
<td>
<p>index</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_j">j</code></td>
<td>
<p>index</p>
</td></tr>
<tr><td><code id="internal_methods_+3A_drop">drop</code></td>
<td>
<p>logical(1). Should the value in the cell be returned if one
cell is selected by the combination of <code>i</code> and <code>j</code>. It is not possible
to return a vector of values. To do so please consider using <code><a href="#topic+cell_values">cell_values()</a></code>.
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Various, but should be considered implementation details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

iris2 &lt;- iris %&gt;%
  group_by(Species) %&gt;%
  mutate(group = as.factor(rep_len(c("a", "b"), length.out = n()))) %&gt;%
  ungroup()

lyt &lt;- basic_table() %&gt;%
  split_cols_by("Species") %&gt;%
  split_cols_by("group") %&gt;%
  analyze(c("Sepal.Length", "Petal.Width"),
    afun = list_wrap_x(summary),
    format = "xx.xx"
  )

tbl &lt;- build_table(lyt, iris2)

indent_mod(tbl)
indent_mod(tbl) &lt;- 1L
tbl
</code></pre>

<hr>
<h2 id='is_rtable'>Check if an object is a valid <code>rtable</code></h2><span id='topic+is_rtable'></span>

<h3>Description</h3>

<p>Check if an object is a valid <code>rtable</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_rtable(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_rtable_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is a formal Table object, <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_rtable(build_table(basic_table(), iris))
</code></pre>

<hr>
<h2 id='label_at_path'>Label at Path</h2><span id='topic+label_at_path'></span><span id='topic+label_at_path+3C-'></span>

<h3>Description</h3>

<p>Gets or sets the label at a path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_at_path(tt, path)

label_at_path(tt, path) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="label_at_path_+3A_tt">tt</code></td>
<td>
<p><code>TableTree</code> (or related class). A <code>TableTree</code> object representing a
populated table.</p>
</td></tr>
<tr><td><code id="label_at_path_+3A_path">path</code></td>
<td>
<p>character. A vector path for a position within the structure of a
<code>tabletree</code>. Each element represents a subsequent choice amongst the children
of the previous choice.</p>
</td></tr>
<tr><td><code id="label_at_path_+3A_value">value</code></td>
<td>
<p>The new value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>path</code> resolves to a single row, the label for that row
is retrieved or set. If, instead, <code>path</code> resolves to a subtable,
the text for the row-label associated with that path is retrieved
or set. In the subtable case, if the label text is set to a non-NA
value, the <code>labelrow</code> will be set to visible, even if it was not before.
Similarly, if the label row text for a subtable is set to NA,
the label row will bet set to non-visible, so the row will not
appear at all when the table is printed.
</p>


<h3>Note</h3>

<p>When changing the row labels for content rows, it is important to
path all the way to the <em>row</em>. Paths ending in <code>"@content"</code> will
not exhibit the behavior you want, and are thus an error. See
<code><a href="#topic+row_paths">row_paths</a></code> for help determining the full paths to content
rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lyt &lt;- basic_table() %&gt;%
  split_rows_by("COUNTRY", split_fun = keep_split_levels(c("CHN", "USA"))) %&gt;%
  analyze("AGE")

tbl &lt;- build_table(lyt, DM)

label_at_path(tbl, c("COUNTRY", "CHN"))

label_at_path(tbl, c("COUNTRY", "USA")) &lt;- "United States"
tbl
</code></pre>

<hr>
<h2 id='LabelRow'>Row classes and constructors</h2><span id='topic+LabelRow'></span><span id='topic+DataRow-class'></span><span id='topic+ContentRow-class'></span><span id='topic+LabelRow-class'></span><span id='topic+.tablerow'></span><span id='topic+DataRow'></span><span id='topic+ContentRow'></span>

<h3>Description</h3>

<p>Row classes and constructors
</p>
<p>Row constructors and Classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LabelRow(
  lev = 1L,
  label = "",
  name = label,
  vis = !is.na(label) &amp;&amp; nzchar(label),
  cinfo = EmptyColInfo,
  indent_mod = 0L,
  table_inset = 0L,
  trailing_section_div = NA_character_
)

.tablerow(
  vals = list(),
  name = "",
  lev = 1L,
  label = name,
  cspan = rep(1L, length(vals)),
  cinfo = EmptyColInfo,
  var = NA_character_,
  format = NULL,
  na_str = NA_character_,
  klass,
  indent_mod = 0L,
  footnotes = list(),
  table_inset = 0L,
  trailing_section_div = NA_character_
)

DataRow(...)

ContentRow(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LabelRow_+3A_lev">lev</code></td>
<td>
<p>integer. Nesting level (roughly, indentation level in practical
terms).</p>
</td></tr>
<tr><td><code id="LabelRow_+3A_label">label</code></td>
<td>
<p>character(1). A label (not to be confused with the name) for the
object/structure.</p>
</td></tr>
<tr><td><code id="LabelRow_+3A_name">name</code></td>
<td>
<p>character(1). Name of the split/table/row being created. Defaults
to same as the corresponding label, but is not required to be.</p>
</td></tr>
<tr><td><code id="LabelRow_+3A_vis">vis</code></td>
<td>
<p>logical. Should the row be visible (<code>LabelRow</code> only).</p>
</td></tr>
<tr><td><code id="LabelRow_+3A_cinfo">cinfo</code></td>
<td>
<p><code>InstantiatedColumnInfo</code> (or NULL). Column structure for the
object being created.</p>
</td></tr>
<tr><td><code id="LabelRow_+3A_indent_mod">indent_mod</code></td>
<td>
<p>numeric. Modifier for the default indent position for the
structure created by this function(subtable, content table, or row)
<em>and all of that structure's children</em>. Defaults to 0, which
corresponds to the unmodified default behavior.</p>
</td></tr>
<tr><td><code id="LabelRow_+3A_table_inset">table_inset</code></td>
<td>
<p>numeric(1). Number of spaces to inset the table header, table
body, referential footnotes, and main_footer, as compared to alignment
of title, subtitle, and provenance footer. Defaults to 0 (no inset).</p>
</td></tr>
<tr><td><code id="LabelRow_+3A_trailing_section_div">trailing_section_div</code></td>
<td>
<p>character(1). String which will be used as a section
divider after the printing of the last row contained in this (sub)-table,
unless that row is also the last table row to be printed overall, or
<code>NA_character_</code> for none (the default). When generated via layouting, this
would correspond to the <code>section_div</code> of the split under which this table
represents a single facet.</p>
</td></tr>
<tr><td><code id="LabelRow_+3A_vals">vals</code></td>
<td>
<p>list. cell values for the row</p>
</td></tr>
<tr><td><code id="LabelRow_+3A_cspan">cspan</code></td>
<td>
<p>integer. Column span. <code>1</code> indicates no spanning.</p>
</td></tr>
<tr><td><code id="LabelRow_+3A_var">var</code></td>
<td>
<p>string, variable name</p>
</td></tr>
<tr><td><code id="LabelRow_+3A_format">format</code></td>
<td>
<p><code>FormatSpec</code>. Format associated with this split. Formats can be
declared via strings (<code>"xx.x"</code>) or function. In cases such as
<code>analyze</code> calls, they can character vectors or lists of functions.</p>
</td></tr>
<tr><td><code id="LabelRow_+3A_na_str">na_str</code></td>
<td>
<p>character(1). String that should be displayed when the value of <code>x</code> is missing.
Defaults to <code>"NA"</code>.</p>
</td></tr>
<tr><td><code id="LabelRow_+3A_klass">klass</code></td>
<td>
<p>Internal detail.</p>
</td></tr>
<tr><td><code id="LabelRow_+3A_footnotes">footnotes</code></td>
<td>
<p>list or NULL. Referential footnotes to be applied at current
level. In post-processing, this can be achieved with <code><a href="#topic+fnotes_at_path+3C-">fnotes_at_path&lt;-</a></code>.</p>
</td></tr>
<tr><td><code id="LabelRow_+3A_...">...</code></td>
<td>
<p>passed to shared constructor (<code>.tablerow</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formal object representing a table row of the constructed type.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>

<hr>
<h2 id='length+2CCellValue-method'>Length of a Cell value</h2><span id='topic+length+2CCellValue-method'></span>

<h3>Description</h3>

<p>Length of a Cell value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'CellValue'
length(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="length+2B2CCellValue-method_+3A_x">x</code></td>
<td>
<p>x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Always returns <code>1L</code>
</p>

<hr>
<h2 id='list_wrap_x'>Returns a function that coerces the return values of f to a list</h2><span id='topic+list_wrap_x'></span><span id='topic+list_wrap_df'></span>

<h3>Description</h3>

<p>Returns a function that coerces the return values of f to a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_wrap_x(f)

list_wrap_df(f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_wrap_x_+3A_f">f</code></td>
<td>
<p>The function to wrap.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>list_wrap_x</code> generates a wrapper which takes <code>x</code> as its
first argument, while <code>list_wrap_df</code> generates an otherwise identical
wrapper function whose first argument is named <code>df</code>.
</p>
<p>We provide both because when using the functions as tabulation in
<code><a href="#topic+analyze">analyze</a></code>, functions which take <code>df</code> as their first
argument are passed the full subset dataframe, while those which accept
anything else notably including <code>x</code> are passed only the relevant
subset of the variable being analyzed.
</p>


<h3>Value</h3>

<p>A function which calls <code>f</code> and converts the result to a list of
<code>CellValue</code> objects.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
summary(iris$Sepal.Length)

f &lt;- list_wrap_x(summary)
f(x = iris$Sepal.Length)

f2 &lt;- list_wrap_df(summary)
f2(df = iris$Sepal.Length)

</code></pre>

<hr>
<h2 id='lyt_args'>Layouting Function Arg Conventions</h2><span id='topic+lyt_args'></span>

<h3>Description</h3>

<p>Layouting Function Arg Conventions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lyt_args(
  lyt,
  var,
  vars,
  label,
  labels_var,
  varlabels,
  varnames,
  split_format,
  split_na_str,
  nested,
  format,
  cfun,
  cformat,
  cna_str,
  split_fun,
  split_name,
  split_label,
  afun,
  inclNAs,
  valorder,
  ref_group,
  compfun,
  label_fstr,
  child_labels,
  extra_args,
  name,
  cuts,
  cutlabels,
  cutfun,
  cutlabelfun,
  cumulative,
  indent_mod,
  show_labels,
  label_pos,
  var_labels,
  cvar,
  table_names,
  topleft,
  align,
  page_by,
  page_prefix,
  format_na_str,
  section_div,
  na_str
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lyt_args_+3A_lyt">lyt</code></td>
<td>
<p>layout object pre-data used for tabulation</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_var">var</code></td>
<td>
<p>string, variable name</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_vars">vars</code></td>
<td>
<p>character vector. Multiple variable names.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_label">label</code></td>
<td>
<p>character(1). A label (not to be confused with the name) for the
object/structure.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_labels_var">labels_var</code></td>
<td>
<p>string, name of variable containing labels to be displayed
for the values of <code>var</code></p>
</td></tr>
<tr><td><code id="lyt_args_+3A_varlabels">varlabels</code></td>
<td>
<p>character vector. Labels for <code>vars</code></p>
</td></tr>
<tr><td><code id="lyt_args_+3A_varnames">varnames</code></td>
<td>
<p>character vector. Names for <code>vars</code> which will appear in
pathing. When <code>vars</code> are all unique this will be the variable names.
If not, these will be variable names with suffixes as necessary to enforce
uniqueness.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_split_format">split_format</code></td>
<td>
<p><code>FormatSpec</code>. Default format associated with the split
being created.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_split_na_str">split_na_str</code></td>
<td>
<p>character. NA string vector for use with <code>split_format</code>.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_nested">nested</code></td>
<td>
<p>boolean. Should this layout instruction be applied within the
existing layout structure <em>if possible</em> (<code>TRUE</code>, the default) or as a
new top-level element ('FALSE). Ignored if it would nest a split underneath
analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_format">format</code></td>
<td>
<p><code>FormatSpec</code>. Format associated with this split. Formats can be
declared via strings (<code>"xx.x"</code>) or function. In cases such as
<code>analyze</code> calls, they can character vectors or lists of functions.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_cfun">cfun</code></td>
<td>
<p>list/function/NULL. tabulation function(s) for creating content
rows. Must accept <code>x</code> or <code>df</code> as first parameter. Must accept
<code>labelstr</code> as the second argument. Can optionally accept all optional
arguments accepted by analysis functions. See <code><a href="#topic+analyze">analyze</a></code>.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_cformat">cformat</code></td>
<td>
<p>format spec. Format for content rows</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_cna_str">cna_str</code></td>
<td>
<p>character. NA string for use with <code>cformat</code> for content
table.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_split_fun">split_fun</code></td>
<td>
<p>function/NULL. custom splitting function See
<code><a href="#topic+custom_split_funs">custom_split_funs</a></code></p>
</td></tr>
<tr><td><code id="lyt_args_+3A_split_name">split_name</code></td>
<td>
<p>string. Name associated with this split (for pathing, etc)</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_split_label">split_label</code></td>
<td>
<p>string. Label string to be associated with the table
generated by the split. Not to be confused with labels assigned to each
child (which are based on the data and type of split during tabulation).</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_afun">afun</code></td>
<td>
<p>function. Analysis function, must take <code>x</code> or <code>df</code> as
its first parameter. Can optionally take other parameters which will be
populated by the tabulation framework. See Details in
<code><a href="#topic+analyze">analyze</a></code>.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_inclnas">inclNAs</code></td>
<td>
<p>boolean. Should observations with NA in the <code>var</code>
variable(s) be included when performing this analysis. Defaults to
<code>FALSE</code></p>
</td></tr>
<tr><td><code id="lyt_args_+3A_valorder">valorder</code></td>
<td>
<p>character vector. Order that the split children should appear
in resulting table.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_ref_group">ref_group</code></td>
<td>
<p>character. Value of <code>var</code> to be taken as the
ref_group/control to be compared against.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_compfun">compfun</code></td>
<td>
<p>function/string. The comparison function which accepts the
analysis function outputs for two different partitions and returns a single
value. Defaults to subtraction. If a string, taken as the name of a
function.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_label_fstr">label_fstr</code></td>
<td>
<p>string. An <code>sprintf</code> style format string containing. For
non-comparison splits, it can contain  up to one <code>"%s"</code> which takes
the current split value and generates the row/column label.
Comparison-based splits it can contain up to two <code>"%s"</code>.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_child_labels">child_labels</code></td>
<td>
<p>string. One of <code>"default"</code>, <code>"visible"</code>,
<code>"hidden"</code>. What should the display behavior be for the  labels (i.e.
label rows) of the children of this split. Defaults to <code>"default"</code>
which flags the label row as visible only if the child has 0 content rows.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_extra_args">extra_args</code></td>
<td>
<p>list. Extra arguments to be passed to the tabulation
function. Element position in the list corresponds to the children of this
split. Named elements in the child-specific lists are ignored if they do
not match a formal argument of the tabulation function.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_name">name</code></td>
<td>
<p>character(1). Name of the split/table/row being created. Defaults
to same as the corresponding label, but is not required to be.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_cuts">cuts</code></td>
<td>
<p>numeric. Cuts to use</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_cutlabels">cutlabels</code></td>
<td>
<p>character (or NULL). Labels for the cuts</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_cutfun">cutfun</code></td>
<td>
<p>function. Function which accepts the <em>full vector</em> of
<code>var</code> values and returns cut points to be used (via <code>cut</code>) when
splitting data during tabulation</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_cutlabelfun">cutlabelfun</code></td>
<td>
<p>function. Function which returns either labels for the
cuts or NULL when passed the return value of <code>cutfun</code></p>
</td></tr>
<tr><td><code id="lyt_args_+3A_cumulative">cumulative</code></td>
<td>
<p>logical. Should the cuts be treated as cumulative. Defaults
to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="lyt_args_+3A_indent_mod">indent_mod</code></td>
<td>
<p>numeric. Modifier for the default indent position for the
structure created by this function(subtable, content table, or row)
<em>and all of that structure's children</em>. Defaults to 0, which
corresponds to the unmodified default behavior.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_show_labels">show_labels</code></td>
<td>
<p>character(1). Should the variable labels for corresponding
to the variable(s) in <code>vars</code> be visible in the resulting table.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_label_pos">label_pos</code></td>
<td>
<p>character(1). Location the variable label should be
displayed, Accepts <code>"hidden"</code> (default for non-analyze row splits), <code>"visible"</code>,
<code>"topleft"</code>, and - for analyze splits only - <code>"default"</code>.  For analyze calls,
<code>"default"</code> indicates that the variable should be visible if and only if
multiple variables are analyzed at the same level of nesting.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_var_labels">var_labels</code></td>
<td>
<p>character. Variable labels for 1 or more variables</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_cvar">cvar</code></td>
<td>
<p>character(1). The variable, if any, which the content function
should accept. Defaults to NA.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_table_names">table_names</code></td>
<td>
<p>character. Names for the tables representing each atomic
analysis. Defaults to <code>var</code>.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_topleft">topleft</code></td>
<td>
<p>character. Override values for the &quot;top left&quot; material to be
displayed during printing.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_align">align</code></td>
<td>
<p>character(1) or <code>NULL</code>. Alignment the value should be rendered with.
It defaults to <code>"center"</code> if <code>NULL</code> is used. See <code><a href="formatters.html#topic+list_formats">formatters::list_valid_aligns()</a></code>
for currently supported alignments.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_page_by">page_by</code></td>
<td>
<p>logical(1). Should pagination be forced between different
children resulting form this split. An error will rise if the selected split
does not contain at least one value that is not <code>NA</code>.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_page_prefix">page_prefix</code></td>
<td>
<p>character(1). Prefix, to be appended with the split value,
when forcing pagination between the children of this split/table</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_format_na_str">format_na_str</code></td>
<td>
<p>character(1). String which should be displayed when
formatted if this cell's value(s) are all NA.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_section_div">section_div</code></td>
<td>
<p>character(1). String which should be repeated as a section
divider after each group defined by this split instruction, or
<code>NA_character_</code> (the default) for no section divider.</p>
</td></tr>
<tr><td><code id="lyt_args_+3A_na_str">na_str</code></td>
<td>
<p>character(1). String that should be displayed when the value of <code>x</code> is missing.
Defaults to <code>"NA"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL (this is an argument template dummy function)
</p>


<h3>See Also</h3>

<p>Other conventions: 
<code><a href="#topic+compat_args">compat_args</a>()</code>,
<code><a href="#topic+constr_args">constr_args</a>()</code>,
<code><a href="#topic+gen_args">gen_args</a>()</code>,
<code><a href="#topic+sf_args">sf_args</a>()</code>
</p>

<hr>
<h2 id='make_afun'>Create custom analysis function wrapping existing function</h2><span id='topic+make_afun'></span>

<h3>Description</h3>

<p>Create custom analysis function wrapping existing function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_afun(
  fun,
  .stats = NULL,
  .formats = NULL,
  .labels = NULL,
  .indent_mods = NULL,
  .ungroup_stats = NULL,
  .format_na_strs = NULL,
  ...,
  .null_ref_cells = ".in_ref_col" %in% names(formals(fun))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_afun_+3A_fun">fun</code></td>
<td>
<p>function. The function to be wrapped in a new customized analysis
fun. Should return named list.</p>
</td></tr>
<tr><td><code id="make_afun_+3A_.stats">.stats</code></td>
<td>
<p>character. Names of elements to keep from <code>fun</code>'s full
output.</p>
</td></tr>
<tr><td><code id="make_afun_+3A_.formats">.formats</code></td>
<td>
<p>ANY. vector/list of formats to override any defaults applied
by <code>fun</code>.</p>
</td></tr>
<tr><td><code id="make_afun_+3A_.labels">.labels</code></td>
<td>
<p>character. Vector of labels to override defaults returned by
<code>fun</code></p>
</td></tr>
<tr><td><code id="make_afun_+3A_.indent_mods">.indent_mods</code></td>
<td>
<p>integer. Named vector of indent modifiers for the
generated rows.</p>
</td></tr>
<tr><td><code id="make_afun_+3A_.ungroup_stats">.ungroup_stats</code></td>
<td>
<p>character. Vector of names, which must match elements
of <code>.stats</code></p>
</td></tr>
<tr><td><code id="make_afun_+3A_.format_na_strs">.format_na_strs</code></td>
<td>
<p>ANY. vector/list of <code>na</code> strings to override any
defaults applied by <code>fun</code>.</p>
</td></tr>
<tr><td><code id="make_afun_+3A_...">...</code></td>
<td>
<p>dots. Additional arguments to <code>fun</code> which effectively become
new defaults. These can still be overridden by <code>extra_args</code> within a split.</p>
</td></tr>
<tr><td><code id="make_afun_+3A_.null_ref_cells">.null_ref_cells</code></td>
<td>
<p>logical(1). Should cells for the reference column be
NULL-ed by the returned analysis function. Defaults to <code>TRUE</code> if
<code>fun</code> accepts <code>.in_ref_col</code> as a formal argument. Note this
argument occurs after <code>...</code> so it must be <em>fully</em> specified  by
name when set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function suitable for use in <code><a href="#topic+analyze">analyze</a></code> with element
selection, reformatting, and relabeling performed automatically.
</p>


<h3>Note</h3>

<p>setting <code>.ungroup_stats</code> to non-null changes the <em>structure</em>
of the  value(s) returned by <code>fun</code>, rather than just labeling
(<code>.labels</code>), formatting (<code>.formats</code>), and selecting amongst
(<code>.stats</code>) them. This means that subsequent <code>make_afun</code> calls to
customize the output further both can and must operate on the new
structure, <em>NOT</em> the original structure returned by <code>fun</code>. See
the final pair of examples below.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+analyze">analyze()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
s_summary &lt;- function(x) {
  stopifnot(is.numeric(x))

  list(
    n = sum(!is.na(x)),
    mean_sd = c(mean = mean(x), sd = sd(x)),
    min_max = range(x)
  )
}

s_summary(iris$Sepal.Length)

a_summary &lt;- make_afun(
  fun = s_summary,
  .formats = c(n = "xx", mean_sd = "xx.xx (xx.xx)", min_max = "xx.xx - xx.xx"),
  .labels = c(n = "n", mean_sd = "Mean (sd)", min_max = "min - max")
)

a_summary(x = iris$Sepal.Length)

a_summary2 &lt;- make_afun(a_summary, .stats = c("n", "mean_sd"))

a_summary2(x = iris$Sepal.Length)

a_summary3 &lt;- make_afun(a_summary, .formats = c(mean_sd = "(xx.xxx, xx.xxx)"))



s_foo &lt;- function(df, .N_col, a = 1, b = 2) {
  list(
    nrow_df = nrow(df),
    .N_col = .N_col,
    a = a,
    b = b
  )
}

s_foo(iris, 40)

a_foo &lt;- make_afun(s_foo,
  b = 4,
  .formats = c(nrow_df = "xx.xx", ".N_col" = "xx.", a = "xx", b = "xx.x"),
  .labels = c(
    nrow_df = "Nrow df",
    ".N_col" = "n in cols", a = "a value", b = "b value"
  ),
  .indent_mods = c(nrow_df = 2L, a = 1L)
)

a_foo(iris, .N_col = 40)
a_foo2 &lt;- make_afun(a_foo, .labels = c(nrow_df = "Number of Rows"))
a_foo2(iris, .N_col = 40)

# grouping and further customization
s_grp &lt;- function(df, .N_col, a = 1, b = 2) {
  list(
    nrow_df = nrow(df),
    .N_col = .N_col,
    letters = list(
      a = a,
      b = b
    )
  )
}
a_grp &lt;- make_afun(s_grp,
  b = 3,
  .labels = c(
    nrow_df = "row count",
    .N_col = "count in column"
  ),
  .formats = c(nrow_df = "xx.", .N_col = "xx."),
  .indent_mod = c(letters = 1L),
  .ungroup_stats = "letters"
)
a_grp(iris, 40)
a_aftergrp &lt;- make_afun(a_grp,
  .stats = c("nrow_df", "b"),
  .formats = c(b = "xx.")
)
a_aftergrp(iris, 40)

s_ref &lt;- function(x, .in_ref_col, .ref_group) {
  list(
    mean_diff = mean(x) - mean(.ref_group)
  )
}

a_ref &lt;- make_afun(s_ref,
  .labels = c(mean_diff = "Mean Difference from Ref")
)
a_ref(iris$Sepal.Length, .in_ref_col = TRUE, 1:10)
a_ref(iris$Sepal.Length, .in_ref_col = FALSE, 1:10)

</code></pre>

<hr>
<h2 id='make_col_df'>Column Layout Summary</h2><span id='topic+make_col_df'></span>

<h3>Description</h3>

<p>Generate a structural summary of the columns of an
rtables table and return it as a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_col_df(tt, colwidths = NULL, visible_only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_col_df_+3A_tt">tt</code></td>
<td>
<p>ANY. Object representing the table-like object to be summarized.</p>
</td></tr>
<tr><td><code id="make_col_df_+3A_colwidths">colwidths</code></td>
<td>
<p>numeric. Internal detail do not set manually.</p>
</td></tr>
<tr><td><code id="make_col_df_+3A_visible_only">visible_only</code></td>
<td>
<p>logical(1). Should only visible aspects of the table structure be reflected in this summary.
Defaults to <code>TRUE</code>. May not be supported by all methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used for Pagination
</p>

<hr>
<h2 id='make_split_fun'>Create a Custom Splitting Function</h2><span id='topic+make_split_fun'></span>

<h3>Description</h3>

<p>Create a Custom Splitting Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_split_fun(pre = list(), core_split = NULL, post = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_split_fun_+3A_pre">pre</code></td>
<td>
<p>list.  Zero or  more functions  which  operate on  the
incoming data and return a new data frame that should split via
<code>core_split</code>. They will be called on the data in the order they
appear in the list.</p>
</td></tr>
<tr><td><code id="make_split_fun_+3A_core_split">core_split</code></td>
<td>
<p>function or NULL. If not NULL,  a function which
accepts the same arguments  do_base_split does, and returns the
same type of named list.   Custom functions which override this
behavior cannot be used in column splits.</p>
</td></tr>
<tr><td><code id="make_split_fun_+3A_post">post</code></td>
<td>
<p>list. Zero or  more functions which should be called on
the list output by splitting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Custom split  functions can be  thought of  as (up to)  3 different
types of manipulations of the splitting process
</p>

<ol>
<li><p> Preprocessing of the incoming data to be split
</p>
</li>
<li><p> (Row-splitting only) Customization of the core mapping of incoming data to facets, and
</p>
</li>
<li><p> Postprocessing operations on the set of facets (groups) generated by the split.
</p>
</li></ol>

<p>This  function  provides  an   interface  to  create  custom  split
functions by implementing and specifying sets of operations in each
of those classes of customization independently.
</p>
<p>Preprocessing  functions (1),  must  accept:  <code>df</code>, <code>spl</code>,  <code>vals</code>,
<code>labels</code>,  and  can  optionally accept  <code>.spl_context</code>.  They  then
manipulate  <code>df</code> (the  incoming data  for the  split) and  return a
modified data.frame.  This modified  data.frame <em>must</em>  contain all
columns present in the incoming  data.frame, but can add columns if
necessary (though we note that these  new columns cannot be used in
the layout as split or analysis variables, because they will not be
present when validity checking is done).
</p>
<p>The  preprocessing   component  is   useful  for  things   such  as
manipulating factor  levels, e.g.,  to trim  unobserved ones  or to
reorder levels based on observed counts, etc.
</p>
<p>Customization of core splitting (2)  is currently only supported in
row  splits.  Core  splitting functions  override  the  fundamental
splitting procedure,  and are only  necessary in rare  cases. These
must  accept  <code>spl</code>, <code>df</code>,  <code>vals</code>,  <code>labels</code>,  and can  optionally
accept <code>.spl_context</code>. They must return a named list with elements,
all of  the same  length, as follows:  - <code>datasplit</code>  (containing a
list of data.frames), -  <code>values</code> containing values associated with
the   facets,   which   must   be   <code>character</code>   or   <code>SplitValue</code>
objects. These  values will  appear in the  paths of  the resulting
table.  - <code>labels</code> containing  the character labels associated with
<code>values</code>
</p>
<p>Postprocessing functions  (3) must  accept the  result of  the core
split  as  their  first  argument  (which  as  of  writing  can  be
anything), in addition  to <code>spl</code>, and <code>fulldf</code>,  and can optionally
accept <code>.spl_context</code>. They must each  return a modified version of
the same structure specified above for core splitting.
</p>
<p>In both the pre- and  post-processing cases, multiple functions can
be specified. When this happens,  they are applied sequentially, in
the order they  appear in the list passed to  the relevant argument
(<code>pre</code> and <code>post</code>, respectively).
</p>


<h3>Value</h3>

<p>A function for use as a custom split function.
</p>


<h3>See Also</h3>

<p><a href="#topic+custom_split_funs">custom_split_funs</a> for a more detailed discussion on what
custom split functions do.
</p>
<p>Other make_custom_split: 
<code><a href="#topic+add_combo_facet">add_combo_facet</a>()</code>,
<code><a href="#topic+drop_facet_levels">drop_facet_levels</a>()</code>,
<code><a href="#topic+make_split_result">make_split_result</a>()</code>,
<code><a href="#topic+trim_levels_in_facets">trim_levels_in_facets</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mysplitfun &lt;- make_split_fun(
  pre = list(drop_facet_levels),
  post = list(add_overall_facet("ALL", "All Arms"))
)


basic_table(show_colcounts = TRUE) %&gt;%
  split_cols_by("ARM", split_fun = mysplitfun) %&gt;%
  analyze("AGE") %&gt;%
  build_table(subset(DM, ARM %in% c("B: Placebo", "C: Combination")))

## post (and pre) arguments can take multiple functions, here
## we add an overall facet and the reorder the facets
reorder_facets &lt;- function(splret, spl, fulldf, ...) {
  ord &lt;- order(names(splret$values))
  make_split_result(
    splret$values[ord],
    splret$datasplit[ord],
    splret$labels[ord]
  )
}

mysplitfun2 &lt;- make_split_fun(
  pre = list(drop_facet_levels),
  post = list(
    add_overall_facet("ALL", "All Arms"),
    reorder_facets
  )
)
basic_table(show_colcounts = TRUE) %&gt;%
  split_cols_by("ARM", split_fun = mysplitfun2) %&gt;%
  analyze("AGE") %&gt;%
  build_table(subset(DM, ARM %in% c("B: Placebo", "C: Combination")))

very_stupid_core &lt;- function(spl, df, vals, labels, .spl_context) {
  make_split_result(c("stupid", "silly"),
    datasplit = list(df[1:10, ], df[11:30, ]),
    labels = c("first 10", "second 20")
  )
}

dumb_30_facet &lt;- add_combo_facet("dumb",
  label = "thirty patients",
  levels = c("stupid", "silly")
)
nonsense_splfun &lt;- make_split_fun(
  core_split = very_stupid_core,
  post = list(dumb_30_facet)
)

## recall core split overriding is not supported in column space
## currently, but we can see it in action in row space

lyt_silly &lt;- basic_table() %&gt;%
  split_rows_by("ARM", split_fun = nonsense_splfun) %&gt;%
  summarize_row_groups() %&gt;%
  analyze("AGE")
silly_table &lt;- build_table(lyt_silly, DM)
silly_table
</code></pre>

<hr>
<h2 id='make_split_result'>Construct split result object</h2><span id='topic+make_split_result'></span><span id='topic+add_to_split_result'></span>

<h3>Description</h3>

<p>These functions can be  used to create or add to  a split result in
functions which implement core  splitting or post-processing within
a custom split function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_split_result(values, datasplit, labels, extras = NULL)

add_to_split_result(splres, values, datasplit, labels, extras = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_split_result_+3A_values">values</code></td>
<td>
<p>character  or <code>list(SplitValue)</code>. The values associated
with each facet</p>
</td></tr>
<tr><td><code id="make_split_result_+3A_datasplit">datasplit</code></td>
<td>
<p><code>list(data.frame)</code>. The  facet data for  each facet
generated in the split</p>
</td></tr>
<tr><td><code id="make_split_result_+3A_labels">labels</code></td>
<td>
<p>character. The labels associated with each facet</p>
</td></tr>
<tr><td><code id="make_split_result_+3A_extras">extras</code></td>
<td>
<p>NULL or list.  Extra values associated with  each of
the facets which  will be passed to  analysis functions applied
within the facet.</p>
</td></tr>
<tr><td><code id="make_split_result_+3A_splres">splres</code></td>
<td>
<p>list. A list representing the result of splitting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions does various housekeeping to ensure that the split result
list is as the rtables internals expect it, most of which are not
relevant to end users.
</p>


<h3>Value</h3>

<p>a named list representing the facets generated by the split
with elements  <code>values</code>, <code>datasplit</code>,  and <code>labels</code>,  which are
the same length and correspond to each other elementwise.
</p>


<h3>See Also</h3>

<p>Other make_custom_split: 
<code><a href="#topic+add_combo_facet">add_combo_facet</a>()</code>,
<code><a href="#topic+drop_facet_levels">drop_facet_levels</a>()</code>,
<code><a href="#topic+make_split_fun">make_split_fun</a>()</code>,
<code><a href="#topic+trim_levels_in_facets">trim_levels_in_facets</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>splres &lt;- make_split_result(
  values = c("hi", "lo"),
  datasplit = list(hi = mtcars, lo = mtcars[1:10, ]),
  labels = c("more data", "less data")
)

splres2 &lt;- add_to_split_result(splres,
  values = "med",
  datasplit = list(med = mtcars[1:20, ]),
  labels = "kinda some data"
)
</code></pre>

<hr>
<h2 id='manual_cols'>Manual column declaration</h2><span id='topic+manual_cols'></span>

<h3>Description</h3>

<p>Manual column declaration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manual_cols(..., .lst = list(...))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manual_cols_+3A_...">...</code></td>
<td>
<p>One or more vectors of levels to appear in the column space. If
more than one set of levels is given, the values of the second are nested
within each value of the first, and so on.</p>
</td></tr>
<tr><td><code id="manual_cols_+3A_.lst">.lst</code></td>
<td>
<p>A list of sets of levels, by default populated via
<code>list(...)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>InstantiatedColumnInfo</code> object, suitable for use declaring the
column structure for a manually constructed table.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple one level column space
rows &lt;- lapply(1:5, function(i) {
  DataRow(rep(i, times = 3))
})
tbl &lt;- TableTree(kids = rows, cinfo = manual_cols(split = c("a", "b", "c")))
tbl

# manually declared nesting
tbl2 &lt;- TableTree(
  kids = list(DataRow(as.list(1:4))),
  cinfo = manual_cols(
    Arm = c("Arm A", "Arm B"),
    Gender = c("M", "F")
  )
)
tbl2

</code></pre>

<hr>
<h2 id='ManualSplit'>Manually defined split</h2><span id='topic+ManualSplit'></span>

<h3>Description</h3>

<p>Manually defined split
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ManualSplit(
  levels,
  label,
  name = "manual",
  extra_args = list(),
  indent_mod = 0L,
  cindent_mod = 0L,
  cvar = "",
  cextra_args = list(),
  label_pos = "visible",
  page_prefix = NA_character_,
  section_div = NA_character_
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ManualSplit_+3A_levels">levels</code></td>
<td>
<p>character. Levels of the split (i.e. the children of the manual
split)</p>
</td></tr>
<tr><td><code id="ManualSplit_+3A_label">label</code></td>
<td>
<p>character(1). A label (not to be confused with the name) for the
object/structure.</p>
</td></tr>
<tr><td><code id="ManualSplit_+3A_name">name</code></td>
<td>
<p>character(1). Name of the split/table/row being created. Defaults
to same as the corresponding label, but is not required to be.</p>
</td></tr>
<tr><td><code id="ManualSplit_+3A_extra_args">extra_args</code></td>
<td>
<p>list. Extra arguments to be passed to the tabulation
function. Element position in the list corresponds to the children of this
split. Named elements in the child-specific lists are ignored if they do
not match a formal argument of the tabulation function.</p>
</td></tr>
<tr><td><code id="ManualSplit_+3A_indent_mod">indent_mod</code></td>
<td>
<p>numeric. Modifier for the default indent position for the
structure created by this function(subtable, content table, or row)
<em>and all of that structure's children</em>. Defaults to 0, which
corresponds to the unmodified default behavior.</p>
</td></tr>
<tr><td><code id="ManualSplit_+3A_cindent_mod">cindent_mod</code></td>
<td>
<p>numeric(1). The indent modifier for the content tables
generated by this split.</p>
</td></tr>
<tr><td><code id="ManualSplit_+3A_cvar">cvar</code></td>
<td>
<p>character(1). The variable, if any, which the content function
should accept. Defaults to NA.</p>
</td></tr>
<tr><td><code id="ManualSplit_+3A_cextra_args">cextra_args</code></td>
<td>
<p>list. Extra arguments to be passed to the content function
when tabulating row group summaries.</p>
</td></tr>
<tr><td><code id="ManualSplit_+3A_label_pos">label_pos</code></td>
<td>
<p>character(1). Location the variable label should be
displayed, Accepts <code>"hidden"</code> (default for non-analyze row splits), <code>"visible"</code>,
<code>"topleft"</code>, and - for analyze splits only - <code>"default"</code>.  For analyze calls,
<code>"default"</code> indicates that the variable should be visible if and only if
multiple variables are analyzed at the same level of nesting.</p>
</td></tr>
<tr><td><code id="ManualSplit_+3A_page_prefix">page_prefix</code></td>
<td>
<p>character(1). Prefix, to be appended with the split value,
when forcing pagination between the children of this split/table</p>
</td></tr>
<tr><td><code id="ManualSplit_+3A_section_div">section_div</code></td>
<td>
<p>character(1). String which should be repeated as a section
divider after each group defined by this split instruction, or
<code>NA_character_</code> (the default) for no section divider.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ManualSplit</code> object.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>

<hr>
<h2 id='matrix_form+2CVTableTree-method'>Transform <code>rtable</code> to a list of matrices which can be used for outputting</h2><span id='topic+matrix_form+2CVTableTree-method'></span>

<h3>Description</h3>

<p>Although <code>rtables</code> are represented as a tree data structure when outputting the table to ASCII or HTML
it is useful to map the <code>rtable</code> to an in between state with the formatted cells in a matrix form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'VTableTree'
matrix_form(
  obj,
  indent_rownames = FALSE,
  expand_newlines = TRUE,
  indent_size = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_form+2B2CVTableTree-method_+3A_obj">obj</code></td>
<td>
<p>ANY. The object for the accessor to access or modify</p>
</td></tr>
<tr><td><code id="matrix_form+2B2CVTableTree-method_+3A_indent_rownames">indent_rownames</code></td>
<td>
<p>logical(1), if TRUE the column with the row names in
the <code>strings</code> matrix of has indented row names (strings pre-fixed)</p>
</td></tr>
<tr><td><code id="matrix_form+2B2CVTableTree-method_+3A_expand_newlines">expand_newlines</code></td>
<td>
<p>logical(1). Should the matrix form generated
expand  rows  whose  values   contain  newlines  into  multiple
'physical'  rows  (as  they  will  appear  when  rendered  into
ASCII). Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="matrix_form+2B2CVTableTree-method_+3A_indent_size">indent_size</code></td>
<td>
<p>numeric(1). Number of spaces to use per indent level.
Defaults to 2</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The strings in the return object are defined as follows: row labels are those
determined by <code>make_row_df</code> and cell values are determined using
<code>get_formatted_cells</code>. (Column labels are calculated using a
non-exported internal function.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<dl>
<dt>strings</dt><dd><p>The content, as it should be printed, of the top-left
material, column headers, row labels , and cell values of <code>tt</code></p>
</dd>
<dt>spans</dt><dd><p>The column-span information for each print-string in the strings
matrix</p>
</dd>
<dt>aligns</dt><dd><p>The text alignment for each print-string in the strings matrix</p>
</dd>
<dt>display</dt><dd><p>Whether each print-string in the strings matrix should be
printed or not</p>
</dd></dl>
<p>.
</p>
<dl>
<dt>row_info</dt><dd><p>the data.frame generated by <code>make_row_df</code></p>
</dd>
</dl>

<p>With an additional <code>nrow_header</code> attribute indicating the number of
pseudo &quot;rows&quot;  the column structure defines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

iris2 &lt;- iris %&gt;%
  group_by(Species) %&gt;%
  mutate(group = as.factor(rep_len(c("a", "b"), length.out = n()))) %&gt;%
  ungroup()

lyt &lt;- basic_table() %&gt;%
  split_cols_by("Species") %&gt;%
  split_cols_by("group") %&gt;%
  analyze(c("Sepal.Length", "Petal.Width"),
    afun = list_wrap_x(summary), format = "xx.xx"
  )

lyt

tbl &lt;- build_table(lyt, iris2)

matrix_form(tbl)
</code></pre>

<hr>
<h2 id='MultiVarSplit'>Split between two or more different variables</h2><span id='topic+MultiVarSplit'></span>

<h3>Description</h3>

<p>Split between two or more different variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MultiVarSplit(
  vars,
  split_label = "",
  varlabels = NULL,
  varnames = NULL,
  cfun = NULL,
  cformat = NULL,
  cna_str = NA_character_,
  split_format = NULL,
  split_na_str = NA_character_,
  split_name = "multivars",
  child_labels = c("default", "visible", "hidden"),
  extra_args = list(),
  indent_mod = 0L,
  cindent_mod = 0L,
  cvar = "",
  cextra_args = list(),
  label_pos = "visible",
  split_fun = NULL,
  page_prefix = NA_character_,
  section_div = NA_character_
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MultiVarSplit_+3A_vars">vars</code></td>
<td>
<p>character vector. Multiple variable names.</p>
</td></tr>
<tr><td><code id="MultiVarSplit_+3A_split_label">split_label</code></td>
<td>
<p>string. Label string to be associated with the table
generated by the split. Not to be confused with labels assigned to each
child (which are based on the data and type of split during tabulation).</p>
</td></tr>
<tr><td><code id="MultiVarSplit_+3A_varlabels">varlabels</code></td>
<td>
<p>character vector. Labels for <code>vars</code></p>
</td></tr>
<tr><td><code id="MultiVarSplit_+3A_varnames">varnames</code></td>
<td>
<p>character vector. Names for <code>vars</code> which will appear in
pathing. When <code>vars</code> are all unique this will be the variable names.
If not, these will be variable names with suffixes as necessary to enforce
uniqueness.</p>
</td></tr>
<tr><td><code id="MultiVarSplit_+3A_cfun">cfun</code></td>
<td>
<p>list/function/NULL. tabulation function(s) for creating content
rows. Must accept <code>x</code> or <code>df</code> as first parameter. Must accept
<code>labelstr</code> as the second argument. Can optionally accept all optional
arguments accepted by analysis functions. See <code><a href="#topic+analyze">analyze</a></code>.</p>
</td></tr>
<tr><td><code id="MultiVarSplit_+3A_cformat">cformat</code></td>
<td>
<p>format spec. Format for content rows</p>
</td></tr>
<tr><td><code id="MultiVarSplit_+3A_cna_str">cna_str</code></td>
<td>
<p>character. NA string for use with <code>cformat</code> for content
table.</p>
</td></tr>
<tr><td><code id="MultiVarSplit_+3A_split_format">split_format</code></td>
<td>
<p><code>FormatSpec</code>. Default format associated with the split
being created.</p>
</td></tr>
<tr><td><code id="MultiVarSplit_+3A_split_na_str">split_na_str</code></td>
<td>
<p>character. NA string vector for use with <code>split_format</code>.</p>
</td></tr>
<tr><td><code id="MultiVarSplit_+3A_split_name">split_name</code></td>
<td>
<p>string. Name associated with this split (for pathing, etc)</p>
</td></tr>
<tr><td><code id="MultiVarSplit_+3A_child_labels">child_labels</code></td>
<td>
<p>string. One of <code>"default"</code>, <code>"visible"</code>,
<code>"hidden"</code>. What should the display behavior be for the  labels (i.e.
label rows) of the children of this split. Defaults to <code>"default"</code>
which flags the label row as visible only if the child has 0 content rows.</p>
</td></tr>
<tr><td><code id="MultiVarSplit_+3A_extra_args">extra_args</code></td>
<td>
<p>list. Extra arguments to be passed to the tabulation
function. Element position in the list corresponds to the children of this
split. Named elements in the child-specific lists are ignored if they do
not match a formal argument of the tabulation function.</p>
</td></tr>
<tr><td><code id="MultiVarSplit_+3A_indent_mod">indent_mod</code></td>
<td>
<p>numeric. Modifier for the default indent position for the
structure created by this function(subtable, content table, or row)
<em>and all of that structure's children</em>. Defaults to 0, which
corresponds to the unmodified default behavior.</p>
</td></tr>
<tr><td><code id="MultiVarSplit_+3A_cindent_mod">cindent_mod</code></td>
<td>
<p>numeric(1). The indent modifier for the content tables
generated by this split.</p>
</td></tr>
<tr><td><code id="MultiVarSplit_+3A_cvar">cvar</code></td>
<td>
<p>character(1). The variable, if any, which the content function
should accept. Defaults to NA.</p>
</td></tr>
<tr><td><code id="MultiVarSplit_+3A_cextra_args">cextra_args</code></td>
<td>
<p>list. Extra arguments to be passed to the content function
when tabulating row group summaries.</p>
</td></tr>
<tr><td><code id="MultiVarSplit_+3A_label_pos">label_pos</code></td>
<td>
<p>character(1). Location the variable label should be
displayed, Accepts <code>"hidden"</code> (default for non-analyze row splits), <code>"visible"</code>,
<code>"topleft"</code>, and - for analyze splits only - <code>"default"</code>.  For analyze calls,
<code>"default"</code> indicates that the variable should be visible if and only if
multiple variables are analyzed at the same level of nesting.</p>
</td></tr>
<tr><td><code id="MultiVarSplit_+3A_split_fun">split_fun</code></td>
<td>
<p>function/NULL. custom splitting function See
<code><a href="#topic+custom_split_funs">custom_split_funs</a></code></p>
</td></tr>
<tr><td><code id="MultiVarSplit_+3A_page_prefix">page_prefix</code></td>
<td>
<p>character(1). Prefix, to be appended with the split value,
when forcing pagination between the children of this split/table</p>
</td></tr>
<tr><td><code id="MultiVarSplit_+3A_section_div">section_div</code></td>
<td>
<p>character(1). String which should be repeated as a section
divider after each group defined by this split instruction, or
<code>NA_character_</code> (the default) for no section divider.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>MultiVarSplit</code> object.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>

<hr>
<h2 id='names+2CVTableNodeInfo-method'>Names of a <code>TableTree</code></h2><span id='topic+names+2CVTableNodeInfo-method'></span><span id='topic+names+2CInstantiatedColumnInfo-method'></span><span id='topic+names+2CLayoutColTree-method'></span><span id='topic+row.names+2CVTableTree-method'></span>

<h3>Description</h3>

<p>Names of a <code>TableTree</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'VTableNodeInfo'
names(x)

## S4 method for signature 'InstantiatedColumnInfo'
names(x)

## S4 method for signature 'LayoutColTree'
names(x)

## S4 method for signature 'VTableTree'
row.names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names+2B2CVTableNodeInfo-method_+3A_x">x</code></td>
<td>
<p>the object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>TableTrees</code> with more than one level of splitting in columns, the names are defined to be the top-level
split values repped out across the columns that they span.
</p>


<h3>Value</h3>

<p>The column names of <code>x</code>, as defined in the details above.
</p>

<hr>
<h2 id='no_colinfo'>Exported for use in tern</h2><span id='topic+no_colinfo'></span><span id='topic+no_colinfo+2CVTableNodeInfo-method'></span><span id='topic+no_colinfo+2CInstantiatedColumnInfo-method'></span>

<h3>Description</h3>

<p>Does the <code>table</code>/<code>row</code>/<code>InstantiatedColumnInfo</code> object contain no column structure information?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>no_colinfo(obj)

## S4 method for signature 'VTableNodeInfo'
no_colinfo(obj)

## S4 method for signature 'InstantiatedColumnInfo'
no_colinfo(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="no_colinfo_+3A_obj">obj</code></td>
<td>
<p>ANY. The object for the accessor to access or modify</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the object has no/empty instantiated column information,
<code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='nrow+2CVTableTree-method'>Table Dimensions</h2><span id='topic+nrow+2CVTableTree-method'></span><span id='topic+ncol+2CVTableNodeInfo-method'></span><span id='topic+dim+2CVTableNodeInfo-method'></span>

<h3>Description</h3>

<p>Table Dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'VTableTree'
nrow(x)

## S4 method for signature 'VTableNodeInfo'
ncol(x)

## S4 method for signature 'VTableNodeInfo'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nrow+2B2CVTableTree-method_+3A_x">x</code></td>
<td>
<p><code>TableTree</code> or <code>ElementaryTable</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of rows (<code>nrow</code>), columns (<code>ncol</code>) or both (<code>dim</code>) of the object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  analyze(c("SEX", "AGE"))

tbl &lt;- build_table(lyt, ex_adsl)

dim(tbl)
nrow(tbl)
ncol(tbl)

NROW(tbl)
NCOL(tbl)

</code></pre>

<hr>
<h2 id='obj_avar'>Row attribute accessors</h2><span id='topic+obj_avar'></span><span id='topic+obj_avar+2CTableRow-method'></span><span id='topic+obj_avar+2CElementaryTable-method'></span><span id='topic+row_cells'></span><span id='topic+row_cells+2CTableRow-method'></span><span id='topic+row_cells+3C-'></span><span id='topic+row_cells+3C-+2CTableRow-method'></span><span id='topic+row_values'></span><span id='topic+row_values+2CTableRow-method'></span><span id='topic+row_values+3C-'></span><span id='topic+row_values+3C-+2CTableRow-method'></span><span id='topic+row_values+3C-+2CLabelRow-method'></span>

<h3>Description</h3>

<p>Row attribute accessors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obj_avar(obj)

## S4 method for signature 'TableRow'
obj_avar(obj)

## S4 method for signature 'ElementaryTable'
obj_avar(obj)

row_cells(obj)

## S4 method for signature 'TableRow'
row_cells(obj)

row_cells(obj) &lt;- value

## S4 replacement method for signature 'TableRow'
row_cells(obj) &lt;- value

row_values(obj)

## S4 method for signature 'TableRow'
row_values(obj)

row_values(obj) &lt;- value

## S4 replacement method for signature 'TableRow'
row_values(obj) &lt;- value

## S4 replacement method for signature 'LabelRow'
row_values(obj) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obj_avar_+3A_obj">obj</code></td>
<td>
<p>ANY. The object for the accessor to access or modify</p>
</td></tr>
<tr><td><code id="obj_avar_+3A_value">value</code></td>
<td>
<p>The new value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>various, depending on the accessor called.
</p>

<hr>
<h2 id='obj_name+2CVNodeInfo-method'>Methods for generics in the <code>formatters</code> package</h2><span id='topic+obj_name+2CVNodeInfo-method'></span><span id='topic+obj_name+2CSplit-method'></span><span id='topic+obj_name+3C-+2CVNodeInfo-method'></span><span id='topic+obj_name+3C-+2CSplit-method'></span><span id='topic+obj_label+2CSplit-method'></span><span id='topic+obj_label+2CTableRow-method'></span><span id='topic+obj_label+2CVTableTree-method'></span><span id='topic+obj_label+2CValueWrapper-method'></span><span id='topic+obj_label+3C-+2CSplit-method'></span><span id='topic+obj_label+3C-+2CTableRow-method'></span><span id='topic+obj_label+3C-+2CValueWrapper-method'></span><span id='topic+obj_label+3C-+2CVTableTree-method'></span><span id='topic+obj_format+2CVTableNodeInfo-method'></span><span id='topic+obj_format+2CCellValue-method'></span><span id='topic+obj_format+2CSplit-method'></span><span id='topic+obj_format+3C-+2CVTableNodeInfo-method'></span><span id='topic+obj_format+3C-+2CSplit-method'></span><span id='topic+obj_format+3C-+2CCellValue-method'></span><span id='topic+obj_na_str+2CSplit-method'></span><span id='topic+main_title+2CVTitleFooter-method'></span><span id='topic+main_title+3C-+2CVTitleFooter-method'></span><span id='topic+main_title+2CTableRow-method'></span><span id='topic+subtitles+2CVTitleFooter-method'></span><span id='topic+subtitles+3C-+2CVTitleFooter-method'></span><span id='topic+subtitles+2CTableRow-method'></span><span id='topic+main_footer+2CVTitleFooter-method'></span><span id='topic+main_footer+3C-+2CVTitleFooter-method'></span><span id='topic+main_footer+2CTableRow-method'></span><span id='topic+prov_footer+2CVTitleFooter-method'></span><span id='topic+prov_footer+3C-+2CVTitleFooter-method'></span><span id='topic+prov_footer+2CTableRow-method'></span><span id='topic+table_inset+2CVTableNodeInfo-method'></span><span id='topic+table_inset+2CPreDataTableLayouts-method'></span><span id='topic+table_inset+3C-+2CVTableNodeInfo-method'></span><span id='topic+table_inset+3C-+2CPreDataTableLayouts-method'></span><span id='topic+table_inset+3C-+2CInstantiatedColumnInfo-method'></span><span id='topic+formatters_methods'></span><span id='topic+nlines+2CTableRow-method'></span><span id='topic+nlines+2CLabelRow-method'></span><span id='topic+nlines+2CRefFootnote-method'></span><span id='topic+nlines+2CInstantiatedColumnInfo-method'></span><span id='topic+make_row_df+2CVTableTree-method'></span><span id='topic+make_row_df+2CTableRow-method'></span><span id='topic+make_row_df+2CLabelRow-method'></span>

<h3>Description</h3>

<p>See the <code>formatters</code> documentation for descriptions of these generics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'VNodeInfo'
obj_name(obj)

## S4 method for signature 'Split'
obj_name(obj)

## S4 replacement method for signature 'VNodeInfo'
obj_name(obj) &lt;- value

## S4 replacement method for signature 'Split'
obj_name(obj) &lt;- value

## S4 method for signature 'Split'
obj_label(obj)

## S4 method for signature 'TableRow'
obj_label(obj)

## S4 method for signature 'VTableTree'
obj_label(obj)

## S4 method for signature 'ValueWrapper'
obj_label(obj)

## S4 replacement method for signature 'Split'
obj_label(obj) &lt;- value

## S4 replacement method for signature 'TableRow'
obj_label(obj) &lt;- value

## S4 replacement method for signature 'ValueWrapper'
obj_label(obj) &lt;- value

## S4 replacement method for signature 'VTableTree'
obj_label(obj) &lt;- value

## S4 method for signature 'VTableNodeInfo'
obj_format(obj)

## S4 method for signature 'CellValue'
obj_format(obj)

## S4 method for signature 'Split'
obj_format(obj)

## S4 replacement method for signature 'VTableNodeInfo'
obj_format(obj) &lt;- value

## S4 replacement method for signature 'Split'
obj_format(obj) &lt;- value

## S4 replacement method for signature 'CellValue'
obj_format(obj) &lt;- value

## S4 method for signature 'Split'
obj_na_str(obj)

## S4 method for signature 'VTitleFooter'
main_title(obj)

## S4 replacement method for signature 'VTitleFooter'
main_title(obj) &lt;- value

## S4 method for signature 'TableRow'
main_title(obj)

## S4 method for signature 'VTitleFooter'
subtitles(obj)

## S4 replacement method for signature 'VTitleFooter'
subtitles(obj) &lt;- value

## S4 method for signature 'TableRow'
subtitles(obj)

## S4 method for signature 'VTitleFooter'
main_footer(obj)

## S4 replacement method for signature 'VTitleFooter'
main_footer(obj) &lt;- value

## S4 method for signature 'TableRow'
main_footer(obj)

## S4 method for signature 'VTitleFooter'
prov_footer(obj)

## S4 replacement method for signature 'VTitleFooter'
prov_footer(obj) &lt;- value

## S4 method for signature 'TableRow'
prov_footer(obj)

## S4 method for signature 'VTableNodeInfo'
table_inset(obj)

## S4 method for signature 'PreDataTableLayouts'
table_inset(obj)

## S4 replacement method for signature 'VTableNodeInfo'
table_inset(obj) &lt;- value

## S4 replacement method for signature 'PreDataTableLayouts'
table_inset(obj) &lt;- value

## S4 replacement method for signature 'InstantiatedColumnInfo'
table_inset(obj) &lt;- value

## S4 method for signature 'TableRow'
nlines(x, colwidths = NULL, max_width = NULL)

## S4 method for signature 'LabelRow'
nlines(x, colwidths = NULL, max_width = NULL)

## S4 method for signature 'RefFootnote'
nlines(x, colwidths = NULL, max_width = NULL)

## S4 method for signature 'InstantiatedColumnInfo'
nlines(x, colwidths = NULL, max_width = NULL)

## S4 method for signature 'VTableTree'
make_row_df(
  tt,
  colwidths = NULL,
  visible_only = TRUE,
  rownum = 0,
  indent = 0L,
  path = character(),
  incontent = FALSE,
  repr_ext = 0L,
  repr_inds = integer(),
  sibpos = NA_integer_,
  nsibs = NA_integer_,
  max_width = NULL
)

## S4 method for signature 'TableRow'
make_row_df(
  tt,
  colwidths = NULL,
  visible_only = TRUE,
  rownum = 0,
  indent = 0L,
  path = "root",
  incontent = FALSE,
  repr_ext = 0L,
  repr_inds = integer(),
  sibpos = NA_integer_,
  nsibs = NA_integer_,
  max_width = NULL
)

## S4 method for signature 'LabelRow'
make_row_df(
  tt,
  colwidths = NULL,
  visible_only = TRUE,
  rownum = 0,
  indent = 0L,
  path = "root",
  incontent = FALSE,
  repr_ext = 0L,
  repr_inds = integer(),
  sibpos = NA_integer_,
  nsibs = NA_integer_,
  max_width = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obj_name+2B2CVNodeInfo-method_+3A_obj">obj</code></td>
<td>
<p>ANY. The object for the accessor to access or modify</p>
</td></tr>
<tr><td><code id="obj_name+2B2CVNodeInfo-method_+3A_value">value</code></td>
<td>
<p>The new value</p>
</td></tr>
<tr><td><code id="obj_name+2B2CVNodeInfo-method_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="obj_name+2B2CVNodeInfo-method_+3A_colwidths">colwidths</code></td>
<td>
<p>numeric vector. Column widths for use with vertical pagination.</p>
</td></tr>
<tr><td><code id="obj_name+2B2CVNodeInfo-method_+3A_max_width">max_width</code></td>
<td>
<p>numeric(1). Width strings should be wrapped to
when determining how many lines they require.</p>
</td></tr>
<tr><td><code id="obj_name+2B2CVNodeInfo-method_+3A_tt">tt</code></td>
<td>
<p><code>TableTree</code> (or related class). A <code>TableTree</code> object representing a
populated table.</p>
</td></tr>
<tr><td><code id="obj_name+2B2CVNodeInfo-method_+3A_visible_only">visible_only</code></td>
<td>
<p>logical(1). Should only visible aspects of the table structure be reflected in this summary.
Defaults to <code>TRUE</code>. May not be supported by all methods.</p>
</td></tr>
<tr><td><code id="obj_name+2B2CVNodeInfo-method_+3A_rownum">rownum</code></td>
<td>
<p>numeric(1). Internal detail do not set manually.</p>
</td></tr>
<tr><td><code id="obj_name+2B2CVNodeInfo-method_+3A_indent">indent</code></td>
<td>
<p>integer(1). Internal detail do not set manually.</p>
</td></tr>
<tr><td><code id="obj_name+2B2CVNodeInfo-method_+3A_path">path</code></td>
<td>
<p>character. A vector path for a position within the structure of a
<code>tabletree</code>. Each element represents a subsequent choice amongst the children
of the previous choice.</p>
</td></tr>
<tr><td><code id="obj_name+2B2CVNodeInfo-method_+3A_incontent">incontent</code></td>
<td>
<p>logical(1). Internal detail do not set manually.</p>
</td></tr>
<tr><td><code id="obj_name+2B2CVNodeInfo-method_+3A_repr_ext">repr_ext</code></td>
<td>
<p>integer(1). Internal detail do not set manually.</p>
</td></tr>
<tr><td><code id="obj_name+2B2CVNodeInfo-method_+3A_repr_inds">repr_inds</code></td>
<td>
<p>integer. Internal detail do not set manually.</p>
</td></tr>
<tr><td><code id="obj_name+2B2CVNodeInfo-method_+3A_sibpos">sibpos</code></td>
<td>
<p>integer(1). Internal detail do not set manually.</p>
</td></tr>
<tr><td><code id="obj_name+2B2CVNodeInfo-method_+3A_nsibs">nsibs</code></td>
<td>
<p>integer(1). Internal detail do not set manually.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When  <code>visible_only</code> is  <code>TRUE</code> (the  default),
methods should  return a  data.frame with  exactly one  row per
visible  row in  the table-like  object.  This  is useful  when
reasoning about  how a table  will print, but does  not reflect
the full pathing space of the structure (though the paths which
are given will all work as is).
</p>
<p>If  supported,  when  <code>visible_only</code>  is  <code>FALSE</code>,  every
structural element of the table (in row-space) will be reflected in
the  returned data.frame,  meaning the  full pathing-space  will be
represented but some rows in  the layout summary will not represent
printed rows in the table as it is displayed.
</p>
<p>Most arguments beyond <code>tt</code> and <code>visible_only</code> are present so that
<code>make_row_df</code> methods can call <code>make_row_df</code> recursively and retain information,
and should not be set during a top-level call
</p>


<h3>Value</h3>

<p>for getters, the current value of the component being accessed
on <code>obj</code>, for setters, a modified copy of <code>obj</code> with the new value.
</p>


<h3>Note</h3>

<p>the technically present root tree node is excluded from the summary returned by
both <code>make_row_df</code> and <code>make_col_df</code> (see <code>rtables::make_col_df</code>), as it is simply the
row/column structure of <code>tt</code> and thus not useful for pathing or pagination.
</p>

<hr>
<h2 id='pag_tt_indices'>Pagination of a <code>TableTree</code></h2><span id='topic+pag_tt_indices'></span><span id='topic+paginate_table'></span>

<h3>Description</h3>

<p>Paginate  an  <code>rtables</code> table  in  the  vertical and/or  horizontal
direction, as required for the specified page size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pag_tt_indices(
  tt,
  lpp = 15,
  min_siblings = 2,
  nosplitin = character(),
  colwidths = NULL,
  max_width = NULL,
  verbose = FALSE
)

paginate_table(
  tt,
  page_type = "letter",
  font_family = "Courier",
  font_size = 8,
  lineheight = 1,
  landscape = FALSE,
  pg_width = NULL,
  pg_height = NULL,
  margins = c(top = 0.5, bottom = 0.5, left = 0.75, right = 0.75),
  lpp = NA_integer_,
  cpp = NA_integer_,
  min_siblings = 2,
  nosplitin = character(),
  colwidths = NULL,
  tf_wrap = FALSE,
  max_width = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pag_tt_indices_+3A_tt">tt</code></td>
<td>
<p><code>TableTree</code> (or related class). A <code>TableTree</code> object representing a
populated table.</p>
</td></tr>
<tr><td><code id="pag_tt_indices_+3A_lpp">lpp</code></td>
<td>
<p>numeric. Maximum lines per page including (re)printed header and context rows</p>
</td></tr>
<tr><td><code id="pag_tt_indices_+3A_min_siblings">min_siblings</code></td>
<td>
<p>numeric. Minimum sibling rows which must appear on either side of pagination row for a
mid-subtable split to be valid. Defaults to 2.</p>
</td></tr>
<tr><td><code id="pag_tt_indices_+3A_nosplitin">nosplitin</code></td>
<td>
<p>character. List of names of sub-tables where page-breaks are not allowed, regardless of other
considerations. Defaults to none.</p>
</td></tr>
<tr><td><code id="pag_tt_indices_+3A_colwidths">colwidths</code></td>
<td>
<p>numeric vector. Column widths for use with vertical pagination.</p>
</td></tr>
<tr><td><code id="pag_tt_indices_+3A_max_width">max_width</code></td>
<td>
<p>integer(1), character(1) or <code>NULL</code>. Width that title
and   footer   (including   footnotes)  materials   should   be
word-wrapped to. If <code>NULL</code>, it is  set to the current print width
of the  session (<code>getOption("width")</code>). If set to <code>"auto"</code>,
the width of the table (plus any table inset) is used. Ignored
completely if <code>tf_wrap</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pag_tt_indices_+3A_verbose">verbose</code></td>
<td>
<p>logical(1). Should extra debugging messages be shown. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pag_tt_indices_+3A_page_type">page_type</code></td>
<td>
<p>character(1).   Name   of  a  page  type.   See
<code>page_types</code>.   Ignored when  <code>pg_width</code> and  <code>pg_height</code>
are set directly.</p>
</td></tr>
<tr><td><code id="pag_tt_indices_+3A_font_family">font_family</code></td>
<td>
<p>character(1). Name of a font family. An error
will be thrown if the family named is not monospaced. Defaults
to Courier.</p>
</td></tr>
<tr><td><code id="pag_tt_indices_+3A_font_size">font_size</code></td>
<td>
<p>numeric(1). Font size, defaults to 12.</p>
</td></tr>
<tr><td><code id="pag_tt_indices_+3A_lineheight">lineheight</code></td>
<td>
<p>numeric(1). Line height, defaults to 1.</p>
</td></tr>
<tr><td><code id="pag_tt_indices_+3A_landscape">landscape</code></td>
<td>
<p>logical(1). Should the  dimensions of <code>page_type</code>
be inverted  for landscape?  Defaults to  <code>FALSE</code>, ignored when
<code>pg_width</code> and <code>pg_height</code> are set directly.</p>
</td></tr>
<tr><td><code id="pag_tt_indices_+3A_pg_width">pg_width</code></td>
<td>
<p>numeric(1). Page width in inches.</p>
</td></tr>
<tr><td><code id="pag_tt_indices_+3A_pg_height">pg_height</code></td>
<td>
<p>numeric(1). Page height in inches.</p>
</td></tr>
<tr><td><code id="pag_tt_indices_+3A_margins">margins</code></td>
<td>
<p>numeric(4). Named numeric vector containing <code>'bottom'</code>,
<code>'left'</code>, <code>'top'</code>, and <code>'right'</code> margins in inches. Defaults
to <code>.5</code> inches for both vertical margins and <code>.75</code> for both
horizontal margins.</p>
</td></tr>
<tr><td><code id="pag_tt_indices_+3A_cpp">cpp</code></td>
<td>
<p>numeric(1) or NULL. Width (in characters) of the pages for
horizontal pagination. <code>NA</code> (the default) indicates <code>cpp</code> should be inferred from
the page size; <code>NULL</code> indicates no horizontal pagination should be done
regardless of page size.</p>
</td></tr>
<tr><td><code id="pag_tt_indices_+3A_tf_wrap">tf_wrap</code></td>
<td>
<p>logical(1). Should  the texts for  title, subtitle,
and footnotes be wrapped?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rtables</code> pagination is context aware,  meaning that label rows and
row-group summaries  (content rows)  are repeated  after (vertical)
pagination, as  appropriate. This allows the  reader to immediately
understand where they are in the table after turning to a new page,
but does  also mean that a  rendered, paginated table will  take up
more  lines of  text than  rendering the  table without  pagination
would.
</p>
<p>Pagination also takes into account word-wrapping of title, footer,
column-label, and formatted cell value content.
</p>
<p>Vertical pagination information (pagination data.frame) is created
using (<code>make_row_df</code>)
</p>
<p>Horizontal  pagination  is  performed   by  creating  a  pagination
dataframe for  the columns,  and then  applying the  same algorithm
used for vertical pagination to it.
</p>
<p>If physical page size and font information are specified, these are
used  to  derive  lines-per-page  (<code>lpp</code>)  and  characters-per-page
(<code>cpp</code>) values.
</p>
<p>The full multi-direction pagination algorithm then is as follows:
</p>

<ol>
<li><p> Adjust <code>lpp</code> and <code>cpp</code> to account for rendered elements that are not rows (columns)
</p>
</li></ol>


<ul>
<li><p> titles/footers/column labels, and horizontal dividers in the vertical pagination case
</p>
</li>
<li><p> row-labels, table_inset, and top-left materials in the horizontal case
</p>
</li></ul>


<ol>
<li><p> Perform 'forced pagination' representing page-by row splits, generating 1 or more tables
</p>
</li>
<li><p> Perform vertical pagination separately on each table generated in (1)
</p>
</li>
<li><p> Perform horizontal pagination <strong>on the entire table</strong> and apply the results to each table
page generated in (1)-(2)
</p>
</li>
<li><p> Return a list of subtables representing full bi-directional pagination
</p>
</li></ol>

<p>Pagination in both directions is done using the <em>Core Pagination Algorithm</em>
implemented in the <code>formatters</code> package:
</p>


<h3>Value</h3>

<p>for <code>pag_tt_indices</code> a list of paginated-groups of row-indices of <code>tt</code>. For <code>paginate_table</code>,
The subtables defined by subsetting by the indices defined by <code>pag_tt_indices</code>.
</p>


<h3>Pagination Algorithm</h3>

<p>Pagination  is performed independently in  the vertical  and horizontal
directions based solely on a <em>pagination data.frame</em>, which includes the
following information for each row/column:
</p>

<ul>
<li><p> number of  lines/characters rendering the row  will take <strong>after
word-wrapping</strong> (<code>self_extent</code>)
</p>
</li>
<li><p> the indices (<code>reprint_inds</code>)  and number of lines (<code>par_extent</code>)
of the rows which act as <strong>context</strong> for the row
</p>
</li>
<li><p> the row's number of siblings and position within its siblings
</p>
</li></ul>

<p>Given <code>lpp</code>  (<code>cpp</code>) already  adjusted for rendered  elements which
are  not rows/columns  and a  dataframe of  pagination information,
pagination is  performed via  the following  algorithm, and  with a
<code>start = 1</code>:
</p>
<p>Core Pagination Algorithm:
</p>

<ol>
<li><p> Initial guess for pagination point is <code>start + lpp</code> (<code>start + cpp</code>)
</p>
</li>
<li><p> While the guess is not a valid pagination position, and <code>guess &gt; start</code>, decrement guess and repeat
</p>
</li></ol>


<ul>
<li><p> an error is thrown if all possible pagination positions between
<code>start</code> and <code>start + lpp</code> (<code>start + cpp</code>) would ever be <code style="white-space: pre;">&#8288;&lt; start&#8288;</code>
after decrementing
</p>
</li></ul>


<ol>
<li><p> Retain pagination index
</p>
</li>
<li><p> if pagination  point was less than  <code>NROW(tt)</code> (<code>ncol(tt)</code>), set
<code>start</code> to <code>pos + 1</code>, and repeat steps (1) - (4).
</p>
</li></ol>

<p>Validating pagination position:
</p>
<p>Given an (already adjusted) <code>lpp</code> or <code>cpp</code> value, a pagination is invalid if:
</p>

<ul>
<li><p> The rows/columns on the page would take  more than (adjusted) <code>lpp</code> lines/<code>cpp</code>
characters to render <strong>including</strong>
</p>

<ul>
<li><p> word-wrapping
</p>
</li>
<li><p> (vertical only) context repetition
</p>
</li></ul>

</li>
<li><p> (vertical only) footnote messages  and or section divider lines
take up too many lines after rendering rows
</p>
</li>
<li><p> (vertical only) row is a label or content (row-group summary) row
</p>
</li>
<li><p> (vertical only)  row at the pagination point  has siblings, and
it has less than <code>min_siblings</code> preceding or following siblings
</p>
</li>
<li><p> pagination would occur within a sub-table listed in <code>nosplitin</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
s_summary &lt;- function(x) {
  if (is.numeric(x)) {
    in_rows(
      "n" = rcell(sum(!is.na(x)), format = "xx"),
      "Mean (sd)" = rcell(c(mean(x, na.rm = TRUE), sd(x, na.rm = TRUE)),
        format = "xx.xx (xx.xx)"
      ),
      "IQR" = rcell(IQR(x, na.rm = TRUE), format = "xx.xx"),
      "min - max" = rcell(range(x, na.rm = TRUE), format = "xx.xx - xx.xx")
    )
  } else if (is.factor(x)) {
    vs &lt;- as.list(table(x))
    do.call(in_rows, lapply(vs, rcell, format = "xx"))
  } else {
    (
      stop("type not supported")
    )
  }
}


lyt &lt;- basic_table() %&gt;%
  split_cols_by(var = "ARM") %&gt;%
  analyze(c("AGE", "SEX", "BEP01FL", "BMRKR1", "BMRKR2", "COUNTRY"), afun = s_summary)

tbl &lt;- build_table(lyt, ex_adsl)
tbl

nrow(tbl)

row_paths_summary(tbl)

tbls &lt;- paginate_table(tbl, lpp = 15)
mf &lt;- matrix_form(tbl, indent_rownames = TRUE)
w_tbls &lt;- propose_column_widths(mf) # so that we have the same column widths


tmp &lt;- lapply(tbls, function(tbli) {
  cat(toString(tbli, widths = w_tbls))
  cat("\n\n")
  cat("~~~~ PAGE BREAK ~~~~")
  cat("\n\n")
})

</code></pre>

<hr>
<h2 id='prune_table'>Recursively prune a <code>TableTree</code></h2><span id='topic+prune_table'></span>

<h3>Description</h3>

<p>Recursively prune a <code>TableTree</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune_table(
  tt,
  prune_func = prune_empty_level,
  stop_depth = NA_real_,
  depth = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune_table_+3A_tt">tt</code></td>
<td>
<p><code>TableTree</code> (or related class). A <code>TableTree</code> object representing a
populated table.</p>
</td></tr>
<tr><td><code id="prune_table_+3A_prune_func">prune_func</code></td>
<td>
<p>function. A Function to be called on each subtree which
returns TRUE if the entire subtree should be removed.</p>
</td></tr>
<tr><td><code id="prune_table_+3A_stop_depth">stop_depth</code></td>
<td>
<p>numeric(1). The depth after which subtrees should not be
checked for pruning. Defaults to <code>NA</code> which indicates pruning should
happen at all levels</p>
</td></tr>
<tr><td><code id="prune_table_+3A_depth">depth</code></td>
<td>
<p>numeric(1). Used internally, not intended to be set by the end
user.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>TableTree</code> pruned via recursive application of <code>prune_func</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prune_empty_level">prune_empty_level()</a></code> for details on this and several other basic
pruning functions included in the <code>rtables</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adsl &lt;- ex_adsl
levels(adsl$SEX) &lt;- c(levels(ex_adsl$SEX), "OTHER")

tbl_to_prune &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("SEX") %&gt;%
  summarize_row_groups() %&gt;%
  split_rows_by("STRATA1") %&gt;%
  summarize_row_groups() %&gt;%
  analyze("AGE") %&gt;%
  build_table(adsl)

tbl_to_prune %&gt;% prune_table()

</code></pre>

<hr>
<h2 id='qtable_layout'>Generalized Frequency Table</h2><span id='topic+qtable_layout'></span><span id='topic+qtable'></span>

<h3>Description</h3>

<p>This function provides a convenience interface for
generating generalizations of a 2-way frequency table. Row and column
space can be facetted by variables, and an analysis function can be specified.
</p>
<p>The function then builds a layout with the specified layout and applies it to
the data provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtable_layout(
  data,
  row_vars = character(),
  col_vars = character(),
  avar = NULL,
  row_labels = NULL,
  afun = NULL,
  summarize_groups = FALSE,
  title = "",
  subtitles = character(),
  main_footer = character(),
  prov_footer = character(),
  show_colcounts = TRUE,
  drop_levels = TRUE,
  ...,
  .default_rlabel = NULL
)

qtable(
  data,
  row_vars = character(),
  col_vars = character(),
  avar = NULL,
  row_labels = NULL,
  afun = NULL,
  summarize_groups = FALSE,
  title = "",
  subtitles = character(),
  main_footer = character(),
  prov_footer = character(),
  show_colcounts = TRUE,
  drop_levels = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qtable_layout_+3A_data">data</code></td>
<td>
<p>data.frame. The data to tabulate.</p>
</td></tr>
<tr><td><code id="qtable_layout_+3A_row_vars">row_vars</code></td>
<td>
<p>character. The names of variables to be used in row facetting.</p>
</td></tr>
<tr><td><code id="qtable_layout_+3A_col_vars">col_vars</code></td>
<td>
<p>character. The names of variables to be used in column facetting.</p>
</td></tr>
<tr><td><code id="qtable_layout_+3A_avar">avar</code></td>
<td>
<p>character(1). The variable to be analyzed. Defaults to the first variable in <code>data</code>.</p>
</td></tr>
<tr><td><code id="qtable_layout_+3A_row_labels">row_labels</code></td>
<td>
<p>character or NULL. Row label(s) which should be applied to the analysis rows. length must match
the number of rows generated by <code>afun</code>. See details.</p>
</td></tr>
<tr><td><code id="qtable_layout_+3A_afun">afun</code></td>
<td>
<p>function. The function to generate the analysis row cell values. This can be a proper analysis
function, or a function which returns a vector or list. Vectors are taken as multi-valued single cells, whereas
lists are interpreted as multiple cells.</p>
</td></tr>
<tr><td><code id="qtable_layout_+3A_summarize_groups">summarize_groups</code></td>
<td>
<p>logical(1). Should each level of nesting include marginal summary rows. Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="qtable_layout_+3A_title">title</code></td>
<td>
<p>character(1). Main title (<code><a href="formatters.html#topic+main_title">main_title()</a></code>) is a single string.
Ignored for subtables.</p>
</td></tr>
<tr><td><code id="qtable_layout_+3A_subtitles">subtitles</code></td>
<td>
<p>character. Subtitles (<code><a href="formatters.html#topic+subtitles">subtitles()</a></code>) can be vector of strings, where
every element is printed in a separate line. Ignored for subtables.</p>
</td></tr>
<tr><td><code id="qtable_layout_+3A_main_footer">main_footer</code></td>
<td>
<p>character. Main global (non-referential) footer materials
(<code><a href="formatters.html#topic+main_footer">main_footer()</a></code>). If it is a vector of strings, they will be printed on separate
lines.</p>
</td></tr>
<tr><td><code id="qtable_layout_+3A_prov_footer">prov_footer</code></td>
<td>
<p>character. Provenance-related global footer materials
(<code><a href="formatters.html#topic+prov_footer">prov_footer()</a></code>). It can be also a vector of strings, printed on different lines.
Generally should not be modified by hand.</p>
</td></tr>
<tr><td><code id="qtable_layout_+3A_show_colcounts">show_colcounts</code></td>
<td>
<p>logical(1). Should column counts be displayed in the
resulting table when this layout is applied to data</p>
</td></tr>
<tr><td><code id="qtable_layout_+3A_drop_levels">drop_levels</code></td>
<td>
<p>logical(1). Should unobserved factor levels be dropped during facetting. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="qtable_layout_+3A_...">...</code></td>
<td>
<p>passed to <code>afun</code>, if specified. Otherwise ignored.</p>
</td></tr>
<tr><td><code id="qtable_layout_+3A_.default_rlabel">.default_rlabel</code></td>
<td>
<p>character(1). This is an implementation detail that should not be set by end users.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a table  with a single top-level structure in
both row and column dimensions  involving faceting by 0 or more
variables in each.
</p>
<p>The display  of the table depends on certain
details  of the  tabulation.   In  the case  of  an <code>afun</code> which
returns a single  cell's contents (either a scalar  or a vector
of 2 or 3 elements), the  label rows for the deepest-nested row
facets will be hidden and the labels used there will be used as
the analysis row labels. In the case of an <code>afun</code> which returns a
list (corresponding to  multiple cells), the names  of the list
will be used as the analysis  row labels and the deepest-nested
facet row labels will be visible.
</p>
<p>The  table  will  be  annotated   in  the  top-left  area  with  an
informative  label displaying  the analysis  variable (<code>avar</code>),  if
set,  and  the  function   used  (captured  via  substitute)  where
possible, or 'count' if not. One exception where the user may
directly modify the top-left area (via <code>row_labels</code>) is the case of
a table with row facets and an <code>afun</code> which returns a single row.
</p>


<h3>Value</h3>

<p>for <code>qtable</code> a built TableTree object representing the desired table,
for <code>qtable_layout</code>, a <code>PreDataTableLayouts</code> object declaring the structure of
the desired table, suitable for passing to <code>build_table</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
qtable(ex_adsl)
qtable(ex_adsl, row_vars = "ARM")
qtable(ex_adsl, col_vars = "ARM")
qtable(ex_adsl, row_vars = "SEX", col_vars = "ARM")
qtable(ex_adsl, row_vars = c("COUNTRY", "SEX"), col_vars = c("ARM", "STRATA1"))
qtable(ex_adsl,
  row_vars = c("COUNTRY", "SEX"),
  col_vars = c("ARM", "STRATA1"), avar = "AGE", afun = mean
)
summary_list &lt;- function(x, ...) as.list(summary(x))
qtable(ex_adsl, row_vars = "SEX", col_vars = "ARM", avar = "AGE", afun = summary_list)
suppressWarnings(qtable(ex_adsl,
  row_vars = "SEX",
  col_vars = "ARM", avar = "AGE", afun = range
))
</code></pre>

<hr>
<h2 id='rbindl_rtables'><code>rbind</code> <code>TableTree</code> and related objects</h2><span id='topic+rbindl_rtables'></span><span id='topic+rbind+2CVTableNodeInfo-method'></span><span id='topic+rbind'></span><span id='topic+rbind2+2CVTableNodeInfo+2CANY-method'></span>

<h3>Description</h3>

<p><code>rbind</code> <code>TableTree</code> and related objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbindl_rtables(x, gap = 0, check_headers = TRUE)

## S4 method for signature 'VTableNodeInfo'
rbind(..., deparse.level = 1)

## S4 method for signature 'VTableNodeInfo,ANY'
rbind2(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbindl_rtables_+3A_x">x</code></td>
<td>
<p><code>VTableNodeInfo</code>. <code>TableTree</code>, <code>ElementaryTable</code> or <code>TableRow</code> object.</p>
</td></tr>
<tr><td><code id="rbindl_rtables_+3A_gap">gap</code></td>
<td>
<p>deprecated. Ignored.</p>
</td></tr>
<tr><td><code id="rbindl_rtables_+3A_check_headers">check_headers</code></td>
<td>
<p>deprecated. Ignored.</p>
</td></tr>
<tr><td><code id="rbindl_rtables_+3A_...">...</code></td>
<td>
<p>ANY. Elements to be stacked.</p>
</td></tr>
<tr><td><code id="rbindl_rtables_+3A_deparse.level">deparse.level</code></td>
<td>
<p>numeric(1). Currently Ignored.</p>
</td></tr>
<tr><td><code id="rbindl_rtables_+3A_y">y</code></td>
<td>
<p><code>VTableNodeInfo</code>. <code>TableTree</code>, <code>ElementaryTable</code> or <code>TableRow</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formal table object.
</p>


<h3>Note</h3>

<p>When objects are rbinded, titles and footer information is retained from the first object (if any exists) if all
other objects have no titles/footers or have identical titles/footers. Otherwise, all titles/footers are removed
and must be set for the bound table via the <code><a href="formatters.html#topic+main_title">main_title()</a></code>, <code><a href="formatters.html#topic+subtitles">subtitles()</a></code>, <code><a href="formatters.html#topic+main_footer">main_footer()</a></code>, and <code><a href="formatters.html#topic+prov_footer">prov_footer()</a></code>
functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtbl &lt;- rtable(
  header = rheader(
    rrow(row.name = NULL, rcell("Sepal.Length", colspan = 2), rcell("Petal.Length", colspan = 2)),
    rrow(NULL, "mean", "median", "mean", "median")
  ),
  rrow(
    row.name = "All Species",
    mean(iris$Sepal.Length), median(iris$Sepal.Length),
    mean(iris$Petal.Length), median(iris$Petal.Length),
    format = "xx.xx"
  )
)

mtbl2 &lt;- with(subset(iris, Species == "setosa"), rtable(
  header = rheader(
    rrow(row.name = NULL, rcell("Sepal.Length", colspan = 2), rcell("Petal.Length", colspan = 2)),
    rrow(NULL, "mean", "median", "mean", "median")
  ),
  rrow(
    row.name = "Setosa",
    mean(Sepal.Length), median(Sepal.Length),
    mean(Petal.Length), median(Petal.Length),
    format = "xx.xx"
  )
))

rbind(mtbl, mtbl2)
rbind(mtbl, rrow(), mtbl2)
rbind(mtbl, rrow("aaa"), indent(mtbl2))
</code></pre>

<hr>
<h2 id='rcell'>Cell value constructors</h2><span id='topic+rcell'></span><span id='topic+non_ref_rcell'></span>

<h3>Description</h3>

<p>Construct a cell value and associate formatting, labeling,
indenting, and column spanning information with it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcell(
  x,
  format = NULL,
  colspan = 1L,
  label = NULL,
  indent_mod = NULL,
  footnotes = NULL,
  align = NULL,
  format_na_str = NULL
)

non_ref_rcell(
  x,
  is_ref,
  format = NULL,
  colspan = 1L,
  label = NULL,
  indent_mod = NULL,
  refval = NULL,
  align = "center",
  format_na_str = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcell_+3A_x">x</code></td>
<td>
<p>ANY. Cell value.</p>
</td></tr>
<tr><td><code id="rcell_+3A_format">format</code></td>
<td>
<p>character(1) or function. The format label (string) or
<code>formatters</code> function to apply to <code>x</code>. See
<code><a href="formatters.html#topic+list_formats">formatters::list_valid_format_labels()</a></code> for currently supported
format labels.</p>
</td></tr>
<tr><td><code id="rcell_+3A_colspan">colspan</code></td>
<td>
<p>integer(1). Column span value.</p>
</td></tr>
<tr><td><code id="rcell_+3A_label">label</code></td>
<td>
<p>character(1). Label or <code>NULL</code>. If non-null, it will be looked at
when determining row labels.</p>
</td></tr>
<tr><td><code id="rcell_+3A_indent_mod">indent_mod</code></td>
<td>
<p>numeric. Modifier for the default indent position for the
structure created by this function(subtable, content table, or row)
<em>and all of that structure's children</em>. Defaults to 0, which
corresponds to the unmodified default behavior.</p>
</td></tr>
<tr><td><code id="rcell_+3A_footnotes">footnotes</code></td>
<td>
<p>list or <code>NULL</code>. Referential footnote messages for the cell.</p>
</td></tr>
<tr><td><code id="rcell_+3A_align">align</code></td>
<td>
<p>character(1) or <code>NULL</code>. Alignment the value should be rendered with.
It defaults to <code>"center"</code> if <code>NULL</code> is used. See <code><a href="formatters.html#topic+list_formats">formatters::list_valid_aligns()</a></code>
for currently supported alignments.</p>
</td></tr>
<tr><td><code id="rcell_+3A_format_na_str">format_na_str</code></td>
<td>
<p>character(1). String which should be displayed when
formatted if this cell's value(s) are all NA.</p>
</td></tr>
<tr><td><code id="rcell_+3A_is_ref">is_ref</code></td>
<td>
<p>logical(1).  Are  we  in  the reference  column  (i.e.
.in_ref_col should be passed to this argument)</p>
</td></tr>
<tr><td><code id="rcell_+3A_refval">refval</code></td>
<td>
<p>ANY. Value to use when in the reference column. Defaults
to <code>NULL</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>non_ref_rcell</code> provides the common <em>blank for cells in
the reference column, this value otherwise</em>, and should be passed the value
of <code>.in_ref_col</code> when it is used.
</p>


<h3>Value</h3>

<p>An object representing the value within a single cell within a
populated table. The underlying structure of this object is an
implementation detail and should not be relied upon beyond calling
accessors for the class.
</p>


<h3>Note</h3>

<p>Currently column spanning is only supported for defining header
structure.
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+export_as_txt'></span><span id='topic+export_as_pdf'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>formatters</dt><dd><p><code><a href="formatters.html#topic+export_as_pdf">export_as_pdf</a></code>, <code><a href="formatters.html#topic+export_as_txt">export_as_txt</a></code></p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  analyze(c("AGE", "BMRKR2", "COUNTRY"))

tbl &lt;- build_table(lyt, ex_adsl)

cat(export_as_txt(tbl, file = NULL, paginate = TRUE, lpp = 8))

## Not run: 
tf &lt;- tempfile(fileext = ".txt")
export_as_txt(tbl, file = tf)
system2("cat", tf)

## End(Not run)

lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  analyze(c("AGE", "BMRKR2", "COUNTRY"))

tbl &lt;- build_table(lyt, ex_adsl)

## Not run: 
tf &lt;- tempfile(fileext = ".pdf")
export_as_pdf(tbl, file = tf, pg_height = 4)
tf &lt;- tempfile(fileext = ".pdf")
export_as_pdf(tbl, file = tf, lpp = 8)

## End(Not run)

</code></pre>

<hr>
<h2 id='rheader'>Create a header</h2><span id='topic+rheader'></span>

<h3>Description</h3>

<p>Create a header
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rheader(..., format = "xx", .lst = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rheader_+3A_...">...</code></td>
<td>
<p>row specifications (either as character vectors or the output
from <code><a href="#topic+rrow">rrow</a></code> or <code><a href="#topic+DataRow">DataRow</a></code>, <code><a href="#topic+LabelRow">LabelRow</a></code>,
etc.</p>
</td></tr>
<tr><td><code id="rheader_+3A_format">format</code></td>
<td>
<p>character(1) or function. The format label (string) or
formatter function to apply to the cell values passed via <code>...</code>. See
<code><a href="formatters.html#topic+list_valid_format_labels">list_valid_format_labels</a></code> for currently supported
format labels.</p>
</td></tr>
<tr><td><code id="rheader_+3A_.lst">.lst</code></td>
<td>
<p>list. An already-collected list of arguments to be used instead
of the elements of <code>...</code>. Arguments passed via <code>...</code> will be
ignored if this is specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>InstantiatedColumnInfo</code> object.
</p>


<h3>See Also</h3>

<p>Other compatibility: 
<code><a href="#topic+rrowl">rrowl</a>()</code>,
<code><a href="#topic+rrow">rrow</a>()</code>,
<code><a href="#topic+rtable">rtable</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
h1 &lt;- rheader(c("A", "B", "C"))

h2 &lt;- rheader(
  rrow(NULL, rcell("group 1", colspan = 2), rcell("group 2", colspan = 2)),
  rrow(NULL, "A", "B", "A", "B")
)

h1

h2

</code></pre>

<hr>
<h2 id='row_footnotes'>Referential Footnote Accessors</h2><span id='topic+row_footnotes'></span><span id='topic+row_footnotes+3C-'></span><span id='topic+cell_footnotes'></span><span id='topic+cell_footnotes+3C-'></span><span id='topic+col_fnotes_here'></span><span id='topic+col_fnotes_here+2CANY-method'></span><span id='topic+col_fnotes_here+3C-'></span><span id='topic+col_footnotes'></span><span id='topic+col_footnotes+3C-'></span><span id='topic+ref_index'></span><span id='topic+ref_index+3C-'></span><span id='topic+ref_symbol'></span><span id='topic+ref_symbol+3C-'></span><span id='topic+ref_msg'></span><span id='topic+fnotes_at_path+3C-'></span>

<h3>Description</h3>

<p>Get and set referential footnotes on aspects of a built table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_footnotes(obj)

row_footnotes(obj) &lt;- value

cell_footnotes(obj)

cell_footnotes(obj) &lt;- value

col_fnotes_here(obj)

## S4 method for signature 'ANY'
col_fnotes_here(obj)

col_fnotes_here(obj) &lt;- value

col_footnotes(obj)

col_footnotes(obj) &lt;- value

ref_index(obj)

ref_index(obj) &lt;- value

ref_symbol(obj)

ref_symbol(obj) &lt;- value

ref_msg(obj)

fnotes_at_path(obj, rowpath = NULL, colpath = NULL, reset_idx = TRUE) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row_footnotes_+3A_obj">obj</code></td>
<td>
<p>ANY. The object for the accessor to access or modify</p>
</td></tr>
<tr><td><code id="row_footnotes_+3A_value">value</code></td>
<td>
<p>The new value</p>
</td></tr>
<tr><td><code id="row_footnotes_+3A_rowpath">rowpath</code></td>
<td>
<p>character or NULL. Path within row structure. <code>NULL</code>
indicates the footnote should go on the column rather than cell.</p>
</td></tr>
<tr><td><code id="row_footnotes_+3A_colpath">colpath</code></td>
<td>
<p>character or NULL. Path within column structure. <code>NULL</code>
indicates footnote should go on the row rather than cell</p>
</td></tr>
<tr><td><code id="row_footnotes_+3A_reset_idx">reset_idx</code></td>
<td>
<p>logical(1). Should the numbering for referential footnotes
be immediately recalculated. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+row_paths">row_paths()</a></code>, <code><a href="#topic+col_paths">col_paths()</a></code>,
<code><a href="#topic+row_paths_summary">row_paths_summary()</a></code>, <code><a href="#topic+col_paths_summary">col_paths_summary()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># How to add referencial footnotes after having created a table
lyt &lt;- basic_table() %&gt;%
  split_rows_by("SEX", page_by = TRUE) %&gt;%
  analyze("AGE")

tbl &lt;- build_table(lyt, DM)
tbl &lt;- trim_rows(tbl)
# Check the row and col structure to add precise references
# row_paths(tbl)
# col_paths(t)
# row_paths_summary(tbl)
# col_paths_summary(tbl)

# Add the citation numbers on the table and relative references in the footnotes
fnotes_at_path(tbl, rowpath = c("SEX", "F", "AGE", "Mean")) &lt;- "Famous paper 1"
fnotes_at_path(tbl, rowpath = c("SEX", "UNDIFFERENTIATED")) &lt;- "Unfamous paper 2"
# tbl

</code></pre>

<hr>
<h2 id='row_paths'>Return List with Table Row/Col Paths</h2><span id='topic+row_paths'></span><span id='topic+col_paths'></span>

<h3>Description</h3>

<p>Return List with Table Row/Col Paths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_paths(x)

col_paths(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row_paths_+3A_x">x</code></td>
<td>
<p>an <code>rtable</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of paths to each row/column within <code>x</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cell_values">cell_values()</a></code>, <code><a href="#topic+fnotes_at_path+3C-">fnotes_at_path&lt;-</a></code>,
<code><a href="#topic+row_paths_summary">row_paths_summary()</a></code>, <code><a href="#topic+col_paths_summary">col_paths_summary()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  analyze(c("SEX", "AGE"))

tbl &lt;- build_table(lyt, ex_adsl)
tbl

row_paths(tbl)
col_paths(tbl)

cell_values(tbl, c("AGE", "Mean"), c("ARM", "B: Placebo"))

</code></pre>

<hr>
<h2 id='row_paths_summary'>Print Row/Col Paths Summary</h2><span id='topic+row_paths_summary'></span><span id='topic+col_paths_summary'></span>

<h3>Description</h3>

<p>Print Row/Col Paths Summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_paths_summary(x)

col_paths_summary(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row_paths_summary_+3A_x">x</code></td>
<td>
<p>an <code>rtable</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame summarizing the row- or column-structure of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

ex_adsl_MF &lt;- ex_adsl %&gt;% filter(SEX %in% c("M", "F"))

lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_cols_by("SEX", split_fun = drop_split_levels) %&gt;%
  analyze(c("AGE", "BMRKR2"))

tbl &lt;- build_table(lyt, ex_adsl_MF)
tbl

df &lt;- row_paths_summary(tbl)
df

col_paths_summary(tbl)

# manually constructed table
tbl2 &lt;- rtable(
  rheader(
    rrow(
      "row 1", rcell("a", colspan = 2),
      rcell("b", colspan = 2)
    ),
    rrow("h2", "a", "b", "c", "d")
  ),
  rrow("r1", 1, 2, 1, 2), rrow("r2", 3, 4, 2, 1)
)
col_paths_summary(tbl2)
</code></pre>

<hr>
<h2 id='rrow'>row</h2><span id='topic+rrow'></span>

<h3>Description</h3>

<p>row
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrow(row.name = "", ..., format = NULL, indent = 0, inset = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rrow_+3A_row.name">row.name</code></td>
<td>
<p>if <code>NULL</code> then an empty string is used as
<code>row.name</code> of the <code><a href="#topic+rrow">rrow</a></code>.</p>
</td></tr>
<tr><td><code id="rrow_+3A_...">...</code></td>
<td>
<p>cell values</p>
</td></tr>
<tr><td><code id="rrow_+3A_format">format</code></td>
<td>
<p>character(1) or function. The format label (string) or
formatter function to apply to the cell values passed via <code>...</code>. See
<code><a href="formatters.html#topic+list_valid_format_labels">list_valid_format_labels</a></code> for currently supported
format labels.</p>
</td></tr>
<tr><td><code id="rrow_+3A_indent">indent</code></td>
<td>
<p>deprecated.</p>
</td></tr>
<tr><td><code id="rrow_+3A_inset">inset</code></td>
<td>
<p>integer(1). The table inset for the row or table being
constructed. See <code><a href="formatters.html#topic+table_inset">table_inset</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A row object of the context-appropriate type (label or data)
</p>


<h3>See Also</h3>

<p>Other compatibility: 
<code><a href="#topic+rheader">rheader</a>()</code>,
<code><a href="#topic+rrowl">rrowl</a>()</code>,
<code><a href="#topic+rtable">rtable</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rrow("ABC", c(1, 2), c(3, 2), format = "xx (xx.%)")
rrow("")

</code></pre>

<hr>
<h2 id='rrowl'><code>rrowl</code></h2><span id='topic+rrowl'></span>

<h3>Description</h3>

<p><code>rrowl</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrowl(row.name, ..., format = NULL, indent = 0, inset = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rrowl_+3A_row.name">row.name</code></td>
<td>
<p>if <code>NULL</code> then an empty string is used as
<code>row.name</code> of the <code><a href="#topic+rrow">rrow</a></code>.</p>
</td></tr>
<tr><td><code id="rrowl_+3A_...">...</code></td>
<td>
<p>values in vector/list form</p>
</td></tr>
<tr><td><code id="rrowl_+3A_format">format</code></td>
<td>
<p>character(1) or function. The format label (string) or
formatter function to apply to the cell values passed via <code>...</code>. See
<code><a href="formatters.html#topic+list_valid_format_labels">list_valid_format_labels</a></code> for currently supported
format labels.</p>
</td></tr>
<tr><td><code id="rrowl_+3A_indent">indent</code></td>
<td>
<p>deprecated.</p>
</td></tr>
<tr><td><code id="rrowl_+3A_inset">inset</code></td>
<td>
<p>integer(1). The table inset for the row or table being
constructed. See <code><a href="formatters.html#topic+table_inset">table_inset</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A row object of the context-appropriate type (label or data)
</p>


<h3>See Also</h3>

<p>Other compatibility: 
<code><a href="#topic+rheader">rheader</a>()</code>,
<code><a href="#topic+rrow">rrow</a>()</code>,
<code><a href="#topic+rtable">rtable</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rrowl("a", c(1, 2, 3), format = "xx")
rrowl("a", c(1, 2, 3), c(4, 5, 6), format = "xx")


rrowl("N", table(iris$Species))
rrowl("N", table(iris$Species), format = "xx")

x &lt;- tapply(iris$Sepal.Length, iris$Species, mean, simplify = FALSE)

rrow(row.name = "row 1", x)
rrow("ABC", 2, 3)

rrowl(row.name = "row 1", c(1, 2), c(3, 4))
rrow(row.name = "row 2", c(1, 2), c(3, 4))
</code></pre>

<hr>
<h2 id='rtable'>Create a Table</h2><span id='topic+rtable'></span><span id='topic+rtablel'></span>

<h3>Description</h3>

<p>Create a Table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtable(header, ..., format = NULL, hsep = default_hsep(), inset = 0L)

rtablel(header, ..., format = NULL, hsep = default_hsep(), inset = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtable_+3A_header">header</code></td>
<td>
<p>Information defining the header (column structure) of the table.
This can be as row objects (legacy), character vectors or a
<code>InstantiatedColumnInfo</code> object.</p>
</td></tr>
<tr><td><code id="rtable_+3A_...">...</code></td>
<td>
<p>Rows to place in the table.</p>
</td></tr>
<tr><td><code id="rtable_+3A_format">format</code></td>
<td>
<p>character(1) or function. The format label (string) or
formatter function to apply to the cell values passed via <code>...</code>. See
<code><a href="formatters.html#topic+list_valid_format_labels">list_valid_format_labels</a></code> for currently supported
format labels.</p>
</td></tr>
<tr><td><code id="rtable_+3A_hsep">hsep</code></td>
<td>
<p>character(1). Set of character(s) to be repeated as the separator
between the header and body of the table when rendered as text. Defaults to
a connected horizontal line (unicode 2014) in locals that use a UTF
charset, and to <code>-</code> elsewhere (with a once per session warning). See
<code><a href="formatters.html#topic+default_horizontal_sep">formatters::set_default_hsep()</a></code> for further information.</p>
</td></tr>
<tr><td><code id="rtable_+3A_inset">inset</code></td>
<td>
<p>integer(1). The table inset for the row or table being
constructed. See <code><a href="formatters.html#topic+table_inset">table_inset</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a formal table object of the appropriate type (<code>ElementaryTable</code>
or <code>TableTree</code>)
</p>


<h3>See Also</h3>

<p>Other compatibility: 
<code><a href="#topic+rheader">rheader</a>()</code>,
<code><a href="#topic+rrowl">rrowl</a>()</code>,
<code><a href="#topic+rrow">rrow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rtable(
  header = LETTERS[1:3],
  rrow("one to three", 1, 2, 3),
  rrow("more stuff", rcell(pi, format = "xx.xx"), "test", "and more")
)


# Table with multirow header
sel &lt;- iris$Species == "setosa"
mtbl &lt;- rtable(
  header = rheader(
    rrow(
      row.name = NULL, rcell("Sepal.Length", colspan = 2),
      rcell("Petal.Length", colspan = 2)
    ),
    rrow(NULL, "mean", "median", "mean", "median")
  ),
  rrow(
    row.name = "All Species",
    mean(iris$Sepal.Length), median(iris$Sepal.Length),
    mean(iris$Petal.Length), median(iris$Petal.Length),
    format = "xx.xx"
  ),
  rrow(
    row.name = "Setosa",
    mean(iris$Sepal.Length[sel]), median(iris$Sepal.Length[sel]),
    mean(iris$Petal.Length[sel]), median(iris$Petal.Length[sel])
  )
)

mtbl

names(mtbl) # always first row of header

# Single row header

tbl &lt;- rtable(
  header = c("Treatement\nN=100", "Comparison\nN=300"),
  format = "xx (xx.xx%)",
  rrow("A", c(104, .2), c(100, .4)),
  rrow("B", c(23, .4), c(43, .5)),
  rrow(""),
  rrow("this is a very long section header"),
  rrow("estimate", rcell(55.23, "xx.xx", colspan = 2)),
  rrow("95% CI", indent = 1, rcell(c(44.8, 67.4), format = "(xx.x, xx.x)", colspan = 2))
)
tbl

row.names(tbl)
names(tbl)


# Subsetting
tbl[1, ]
tbl[, 1]

tbl[1, 2]
tbl[2, 1]

tbl[3, 2]
tbl[5, 1]
tbl[5, 2]

# # Data Structure methods
dim(tbl)
nrow(tbl)
ncol(tbl)
names(tbl)


# Colspans

tbl2 &lt;- rtable(
  c("A", "B", "C", "D", "E"),
  format = "xx",
  rrow("r1", 1, 2, 3, 4, 5),
  rrow("r2", rcell("sp2", colspan = 2), "sp1", rcell("sp2-2", colspan = 2))
)

tbl2

</code></pre>

<hr>
<h2 id='sanitize_table_struct'>Sanitize degenerate table structures (Experimental)</h2><span id='topic+sanitize_table_struct'></span>

<h3>Description</h3>

<p>Experimental function to correct structure
of degenerate tables by adding messaging rows to empty
sub-structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sanitize_table_struct(tt, empty_msg = "-- This Section Contains No Data --")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sanitize_table_struct_+3A_tt">tt</code></td>
<td>
<p><code>TableTree</code></p>
</td></tr>
<tr><td><code id="sanitize_table_struct_+3A_empty_msg">empty_msg</code></td>
<td>
<p>character(1). The string which should be spanned across
the inserted empty rows.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function locates degenerate portions of the table (including the table
overall in the case of a table with no data rows) and inserts a row
which spans all columns with the message <code>empty_msg</code> at each one,
generating a table guaranteed to be non-degenerate.
</p>


<h3>Value</h3>

<p>If <code>tt</code> is already valid, it is returned unmodified. If <code>tt</code> is
degenerate, a modified, non-degenerate version of the table is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sanitize_table_struct(rtable("cool beans"))

lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("SEX") %&gt;%
  summarize_row_groups()

## Degenerate because it doesn't have any analyze calls -&gt; no data rows
badtab &lt;- build_table(lyt, DM)
sanitize_table_struct(badtab)
</code></pre>

<hr>
<h2 id='section_div'>Section dividers getter and setter</h2><span id='topic+section_div'></span><span id='topic+section_div+2CVTableTree-method'></span><span id='topic+section_div+2Clist-method'></span><span id='topic+section_div+2CTableRow-method'></span><span id='topic+section_div+3C-'></span><span id='topic+section_div+3C-+2CVTableTree-method'></span><span id='topic+section_div+3C-+2Clist-method'></span><span id='topic+section_div+3C-+2CTableRow-method'></span><span id='topic+section_div+3C-+2CLabelRow-method'></span><span id='topic+header_section_div'></span><span id='topic+header_section_div+2CPreDataTableLayouts-method'></span><span id='topic+header_section_div+2CVTableTree-method'></span><span id='topic+header_section_div+3C-'></span><span id='topic+header_section_div+3C-+2CPreDataTableLayouts-method'></span><span id='topic+header_section_div+3C-+2CVTableTree-method'></span>

<h3>Description</h3>

<p><code>section_div</code> can be used to set or get the section divider for a table object
produced by <code><a href="#topic+build_table">build_table()</a></code>. When assigned in post-processing (<code style="white-space: pre;">&#8288;section_div&lt;-&#8288;</code>)
the table can have a section divider after every row, each assigned independently.
If assigning during layout creation, only <code><a href="#topic+split_rows_by">split_rows_by()</a></code> (and its related row-wise
splits) and <code><a href="#topic+analyze">analyze()</a></code> have a <code>section_div</code> parameter that will produce separators
between split sections and data subgroups, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>section_div(obj)

## S4 method for signature 'VTableTree'
section_div(obj)

## S4 method for signature 'list'
section_div(obj)

## S4 method for signature 'TableRow'
section_div(obj)

section_div(obj, only_sep_sections = FALSE) &lt;- value

## S4 replacement method for signature 'VTableTree'
section_div(obj, only_sep_sections = FALSE) &lt;- value

## S4 replacement method for signature 'list'
section_div(obj, only_sep_sections = FALSE) &lt;- value

## S4 replacement method for signature 'TableRow'
section_div(obj, only_sep_sections = FALSE) &lt;- value

## S4 replacement method for signature 'LabelRow'
section_div(obj, only_sep_sections = FALSE) &lt;- value

header_section_div(obj)

## S4 method for signature 'PreDataTableLayouts'
header_section_div(obj)

## S4 method for signature 'VTableTree'
header_section_div(obj)

header_section_div(obj) &lt;- value

## S4 replacement method for signature 'PreDataTableLayouts'
header_section_div(obj) &lt;- value

## S4 replacement method for signature 'VTableTree'
header_section_div(obj) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="section_div_+3A_obj">obj</code></td>
<td>
<p>Table object. This can be of any class that inherits from <code>VTableTree</code>
or <code>TableRow</code>/<code>LabelRow</code>.</p>
</td></tr>
<tr><td><code id="section_div_+3A_only_sep_sections">only_sep_sections</code></td>
<td>
<p>logical(1). Defaults to <code>FALSE</code> for <code style="white-space: pre;">&#8288;section_div&lt;-&#8288;</code>. Allows
you to set the section divider only for sections that are splits or analyses if the number of
values is less than the number of rows in the table. If <code>TRUE</code>, the section divider will
be set for all rows of the table.</p>
</td></tr>
<tr><td><code id="section_div_+3A_value">value</code></td>
<td>
<p>character. Vector of single characters to use as section dividers. Each character
is repeated such that all section dividers span the width of the table. Each character that is
not <code>NA_character_</code> will produce a trailing separator for each row of the table. <code>value</code> length
should reflect the number of rows, or be between 1 and the number of splits/levels.
See the Details section below for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assigned value to section divider must be a character vector. If any value is <code>NA_character_</code>
the section divider will be absent for that row or section. When you want to only affect sections
or splits, please use <code>only_sep_sections</code> or provide a shorter vector than the number of rows.
Ideally, the length of the vector should be less than the number of splits with, eventually, the
leaf-level, i.e. <code>DataRow</code> where analyze results are. Note that if only one value is inserted,
only the first split will be affected.
If <code>only_sep_sections = TRUE</code>, which is the default for <code>section_div()</code> produced from the table
construction, the section divider will be set for all the splits and eventually analyses, but
not for the header or each row of the table. This can be set with <code>header_section_div</code> in
<code><a href="#topic+basic_table">basic_table()</a></code> or, eventually, with <code>hsep</code> in <code><a href="#topic+build_table">build_table()</a></code>. If <code>FALSE</code>, the section
divider will be set for all the rows of the table.
</p>


<h3>Value</h3>

<p>The section divider string. Each line that does not have a trailing separator
will have <code>NA_character_</code> as section divider.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+basic_table">basic_table()</a></code> parameter <code>header_section_div</code> for a global section divider.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data
df &lt;- data.frame(
  cat = c(
    "really long thing its so ", "long"
  ),
  value = c(6, 3, 10, 1)
)
fast_afun &lt;- function(x) list("m" = rcell(mean(x), format = "xx."), "m/2" = max(x) / 2)

tbl &lt;- basic_table() %&gt;%
  split_rows_by("cat", section_div = "~") %&gt;%
  analyze("value", afun = fast_afun, section_div = " ") %&gt;%
  build_table(df)

# Getter
section_div(tbl)

# Setter
section_div(tbl) &lt;- letters[seq_len(nrow(tbl))]
tbl

# last letter can appear if there is another table
rbind(tbl, tbl)

# header_section_div
header_section_div(tbl) &lt;- "+"
tbl

</code></pre>

<hr>
<h2 id='select_all_levels'>Add Combination Levels to split</h2><span id='topic+select_all_levels'></span><span id='topic+add_combo_levels'></span>

<h3>Description</h3>

<p>Add Combination Levels to split
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_all_levels

add_combo_levels(combosdf, trim = FALSE, first = FALSE, keep_levels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_all_levels_+3A_combosdf">combosdf</code></td>
<td>
<p><code>data.frame</code>/<code>tbl_df</code>. Columns <code>valname</code>, <code>label</code>, <code>levelcombo</code>,
<code>exargs</code>. Of which <code>levelcombo</code> and <code>exargs</code> are list columns. Passing the
<code>select_all_levels</code> object as a value in the <code>comblevels</code> column
indicates that an overall/all-observations level should be created.</p>
</td></tr>
<tr><td><code id="select_all_levels_+3A_trim">trim</code></td>
<td>
<p>logical(1). Should splits corresponding with 0 observations be
kept when tabulating.</p>
</td></tr>
<tr><td><code id="select_all_levels_+3A_first">first</code></td>
<td>
<p>logical(1). Should the created split level be placed first in
the levels (<code>TRUE</code>) or last (<code>FALSE</code>, the default).</p>
</td></tr>
<tr><td><code id="select_all_levels_+3A_keep_levels">keep_levels</code></td>
<td>
<p>character or NULL. If non-NULL, the levels to retain
across both combination and individual levels.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>AllLevelsSentinel</code> of length 0.
</p>


<h3>Value</h3>

<p>a closure suitable for use as a splitting function (<code>splfun</code>)
when creating a table layout
</p>


<h3>Note</h3>

<p>Analysis or summary functions for which the order matters should never
be used within the tabulation framework.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
combodf &lt;- tribble(
  ~valname, ~label, ~levelcombo, ~exargs,
  "A_B", "Arms A+B", c("A: Drug X", "B: Placebo"), list(),
  "A_C", "Arms A+C", c("A: Drug X", "C: Combination"), list()
)

lyt &lt;- basic_table(show_colcounts = TRUE) %&gt;%
  split_cols_by("ARM", split_fun = add_combo_levels(combodf)) %&gt;%
  analyze("AGE")

tbl &lt;- build_table(lyt, DM)
tbl

lyt1 &lt;- basic_table(show_colcounts = TRUE) %&gt;%
  split_cols_by("ARM",
    split_fun = add_combo_levels(combodf,
      keep_levels = c(
        "A_B",
        "A_C"
      )
    )
  ) %&gt;%
  analyze("AGE")

tbl1 &lt;- build_table(lyt1, DM)
tbl1

smallerDM &lt;- droplevels(subset(DM, SEX %in% c("M", "F") &amp;
  grepl("^(A|B)", ARM)))
lyt2 &lt;- basic_table(show_colcounts = TRUE) %&gt;%
  split_cols_by("ARM", split_fun = add_combo_levels(combodf[1, ])) %&gt;%
  split_cols_by("SEX",
    split_fun = add_overall_level("SEX_ALL", "All Genders")
  ) %&gt;%
  analyze("AGE")

lyt3 &lt;- basic_table(show_colcounts = TRUE) %&gt;%
  split_cols_by("ARM", split_fun = add_combo_levels(combodf)) %&gt;%
  split_rows_by("SEX",
    split_fun = add_overall_level("SEX_ALL", "All Genders")
  ) %&gt;%
  summarize_row_groups() %&gt;%
  analyze("AGE")

tbl3 &lt;- build_table(lyt3, smallerDM)
tbl3
</code></pre>

<hr>
<h2 id='sf_args'>Split Function Arg Conventions</h2><span id='topic+sf_args'></span>

<h3>Description</h3>

<p>Split Function Arg Conventions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_args(trim, label, first)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_args_+3A_trim">trim</code></td>
<td>
<p>logical(1). Should splits corresponding with 0 observations be
kept when tabulating.</p>
</td></tr>
<tr><td><code id="sf_args_+3A_label">label</code></td>
<td>
<p>character(1). A label (not to be confused with the name) for the
object/structure.</p>
</td></tr>
<tr><td><code id="sf_args_+3A_first">first</code></td>
<td>
<p>logical(1). Should the created split level be placed first in
the levels (<code>TRUE</code>) or last (<code>FALSE</code>, the default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL (this is an argument template dummy function)
</p>


<h3>See Also</h3>

<p>Other conventions: 
<code><a href="#topic+compat_args">compat_args</a>()</code>,
<code><a href="#topic+constr_args">constr_args</a>()</code>,
<code><a href="#topic+gen_args">gen_args</a>()</code>,
<code><a href="#topic+lyt_args">lyt_args</a>()</code>
</p>

<hr>
<h2 id='simple_analysis'>Default tabulation</h2><span id='topic+simple_analysis'></span><span id='topic+simple_analysis+2Cnumeric-method'></span><span id='topic+simple_analysis+2Clogical-method'></span><span id='topic+simple_analysis+2Cfactor-method'></span><span id='topic+simple_analysis+2CANY-method'></span>

<h3>Description</h3>

<p>This function is used when <code><a href="#topic+analyze">analyze</a></code> is invoked
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple_analysis(x, ...)

## S4 method for signature 'numeric'
simple_analysis(x, ...)

## S4 method for signature 'logical'
simple_analysis(x, ...)

## S4 method for signature 'factor'
simple_analysis(x, ...)

## S4 method for signature 'ANY'
simple_analysis(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simple_analysis_+3A_x">x</code></td>
<td>
<p>the <em>already split</em> data being tabulated for a particular cell/set of cells</p>
</td></tr>
<tr><td><code id="simple_analysis_+3A_...">...</code></td>
<td>
<p>passed on directly</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has the following behavior given particular types of inputs:
</p>

<dl>
<dt>numeric</dt><dd><p>calls <code><a href="base.html#topic+mean">mean</a></code> on <code>x</code></p>
</dd>
<dt>logical</dt><dd><p>calls <code><a href="base.html#topic+sum">sum</a></code> on <code>x</code></p>
</dd>
<dt>factor</dt><dd><p>calls <code><a href="base.html#topic+length">length</a></code> on <code>x</code></p>
</dd>
</dl>

<p><code>in_rows</code> is called on the resulting value(s).
</p>
<p>All other classes of input currently lead to an error.
</p>


<h3>Value</h3>

<p>an <code>RowsVerticalSection</code> object (or <code>NULL</code>). The details of
this object should be considered an internal implementation detail.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker and Adrian Waddell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simple_analysis(1:3)
simple_analysis(iris$Species)
simple_analysis(iris$Species == "setosa")
</code></pre>

<hr>
<h2 id='sort_at_path'>Sorting a Table at a Specific Path</h2><span id='topic+sort_at_path'></span>

<h3>Description</h3>

<p>Main sorting function to order the substructure of a <code>TableTree</code>
at a particular Path in the table tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_at_path(
  tt,
  path,
  scorefun,
  decreasing = NA,
  na.pos = c("omit", "last", "first"),
  .prev_path = character()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_at_path_+3A_tt">tt</code></td>
<td>
<p><code>TableTree</code> (or related class). A <code>TableTree</code> object representing a
populated table.</p>
</td></tr>
<tr><td><code id="sort_at_path_+3A_path">path</code></td>
<td>
<p>character. A vector path for a position within the structure of a
<code>tabletree</code>. Each element represents a subsequent choice amongst the children
of the previous choice.</p>
</td></tr>
<tr><td><code id="sort_at_path_+3A_scorefun">scorefun</code></td>
<td>
<p>function. Scoring function, should accept the type of
children directly under the position at <code>path</code> (either <code>VTableTree</code>,
<code>VTableRow</code>, or <code>VTableNodeInfo</code>, which covers both) and return a numeric value
to be sorted.</p>
</td></tr>
<tr><td><code id="sort_at_path_+3A_decreasing">decreasing</code></td>
<td>
<p>logical(1). Should the the scores generated by
<code>scorefun</code> be sorted in decreasing order. If unset (the default of
<code>NA</code>), it is set to <code>TRUE</code> if the generated scores are numeric
and <code>FALSE</code> if they are characters.</p>
</td></tr>
<tr><td><code id="sort_at_path_+3A_na.pos">na.pos</code></td>
<td>
<p>character(1). What should be done with children (sub-trees/rows)
with <code>NA</code> scores. Defaults to <code>"omit"</code>, which removes them, other
allowed values are <code>"last"</code>  and <code>"first"</code> which indicate where
they should be placed in the order.</p>
</td></tr>
<tr><td><code id="sort_at_path_+3A_.prev_path">.prev_path</code></td>
<td>
<p>character. Internal detail, do not set manually.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>path</code> here can include the &quot;wildcard&quot; <code>"*"</code> as a step,
which translates roughly to <em>any</em> node/branching element and means
that each child at that step will be <em>separately</em> sorted based on
<code>scorefun</code> and the remaining <code>path</code> entries. This can occur
multiple times in a path.
</p>
<p>Note that sorting needs a deeper understanding of table structure in
<code>rtables</code>. Please consider reading related vignette
(<a href="https://insightsengineering.github.io/rtables/main/articles/sorting_pruning.html">Sorting and Pruning</a>)
and explore table structure with useful functions like <code><a href="#topic+table_structure">table_structure()</a></code>
and <code><a href="#topic+row_paths_summary">row_paths_summary()</a></code>. It is also very important to understand the
difference between &quot;content&quot; rows and &quot;data&quot; rows. The first one analyzes
and describes the split variable generally and is generated with
<code><a href="#topic+summarize_row_groups">summarize_row_groups()</a></code>, while the second one is commonly produced by
calling one of the various <code><a href="#topic+analyze">analyze()</a></code> instances.
</p>
<p>Built-in score functions are <code><a href="#topic+cont_n_allcols">cont_n_allcols()</a></code> and <code><a href="#topic+cont_n_onecol">cont_n_onecol()</a></code>.
They are both working with content rows (coming from <code><a href="#topic+summarize_row_groups">summarize_row_groups()</a></code>)
while a custom score function needs to be used on <code>DataRow</code>s. Here, some
useful descriptor and accessor functions (coming from related vignette):
</p>

<ul>
<li> <p><code><a href="#topic+cell_values">cell_values()</a></code> - Retrieves a named list of a <code>TableRow</code> or
<code>TableTree</code> object's values.
</p>
</li>
<li> <p><code><a href="formatters.html#topic+obj_name">obj_name()</a></code> - Retrieves the name of an object. Note this can differ
from the label that is displayed (if any is) when printing.
</p>
</li>
<li> <p><code><a href="formatters.html#topic+obj_label">obj_label()</a></code> - Retrieves the display label of an object. Note this
can differ from the name that appears in the path.
</p>
</li>
<li> <p><code><a href="#topic+content_table">content_table()</a></code> - Retrieves a <code>TableTree</code> object's content table
(which contains its summary rows).
</p>
</li>
<li> <p><code><a href="#topic+tree_children">tree_children()</a></code> - Retrieves a <code>TableTree</code> object's direct children
(either subtables, rows or possibly a mix thereof, though that
should not happen in practice).
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>TableTree</code> with the same structure as <code>tt</code> with the exception
that the requested sorting has been done at <code>path</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cont_n_allcols">cont_n_allcols()</a></code> and <code><a href="#topic+cont_n_onecol">cont_n_onecol()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating a table to sort

# Function that gives two statistics per table-tree "leaf"
more_analysis_fnc &lt;- function(x) {
  in_rows(
    "median" = median(x),
    "mean" = mean(x),
    .formats = "xx.x"
  )
}

# Main layout of the table
raw_lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by(
    "RACE",
    split_fun = drop_and_remove_levels("WHITE") # dropping WHITE levels
  ) %&gt;%
  summarize_row_groups() %&gt;%
  split_rows_by("STRATA1") %&gt;%
  summarize_row_groups() %&gt;%
  analyze("AGE", afun = more_analysis_fnc)

# Creating the table and pruning empty and NAs
tbl &lt;- build_table(raw_lyt, DM) %&gt;%
  prune_table()

# Peek at the table structure to understand how it is built
table_structure(tbl)

#  Sorting only ASIAN sub-table, or, in other words, sorting STRATA elements for
# the ASIAN group/row-split. This uses content_table() accessor function as it
# is a "ContentRow". In this case, we also base our sorting only on the second column.
sort_at_path(tbl, c("ASIAN", "STRATA1"), cont_n_onecol(2))

# Custom scoring function that is working on "DataRow"s
scorefun &lt;- function(tt) {
  # Here we could use browser()
  sum(unlist(row_values(tt))) # Different accessor function
}
# Sorting mean and median for all the AGE leaves!
sort_at_path(tbl, c("RACE", "*", "STRATA1", "*", "AGE"), scorefun)

</code></pre>

<hr>
<h2 id='spl_context'>.spl_context within analysis and split functions</h2><span id='topic+spl_context'></span>

<h3>Description</h3>

<p><code>.spl_context</code> is an optional parameter for any of <code>rtables</code>' special
functions, them being <code>afun</code> (analysis function in <a href="#topic+analyze">analyze</a>),
<code>cfun</code> (content or label function in <a href="#topic+summarize_row_groups">summarize_row_groups</a>),
or <code>split_fun</code> (e.g. for <a href="#topic+split_rows_by">split_rows_by</a>).
</p>


<h3>Details</h3>

<p>The <code>.spl_context</code> <code>data.frame</code> gives information about the subsets of data
corresponding to the splits within-which the current <code>analyze</code> action is
nested. Taken together, these correspond to the path that the resulting (set
of) rows the analysis function is creating, although the information is in a
slightly different form. Each split (which correspond to groups of rows in
the resulting table), as well as the initial 'root' &quot;split&quot;, is represented
via the following columns:
</p>

<dl>
<dt>split</dt><dd><p>The name of the split (often the variable being split in the
simple case)</p>
</dd>
<dt>value</dt><dd><p>The string representation of the value at that split</p>
</dd>
<dt>full_parent_df</dt><dd><p>a dataframe containing the full data (i.e. across all
columns) corresponding to the path defined by the combination of <code>split</code>
and <code>value</code> of this row <em>and all rows above this row</em></p>
</dd>
<dt>all_cols_n</dt><dd><p>the number of observations  corresponding to this row
grouping (union of all columns)</p>
</dd>
<dt><em>(row-split and analyze contexts only)</em> &lt;1 column for each
column in the table structure</dt><dd><p> These list columns (named the same as
<code>names(col_exprs(tab))</code>) contain logical vectors corresponding to
the subset of this row's <code>full_parent_df</code> corresponding to that column</p>
</dd>
<dt>cur_col_id</dt><dd><p>Identifier of the current column. This may be an internal
name, constructed by pasting the column path together</p>
</dd>
<dt>cur_col_subset</dt><dd><p>List column containing logical vectors indicating the
subset of that row's <code>full_parent_df</code> for the column currently being
created by the analysis function</p>
</dd>
<dt>cur_col_expr</dt><dd><p>List of current column expression. This may be used to
filter <code>.alt_df_row</code> or any external data by column. Filtering <code>.alt_df_row</code>
by columns produces <code>.alt_df</code>.</p>
</dd>
<dt>cur_col_n</dt><dd><p>integer column containing the observation counts for that
split</p>
</dd>
<dt>cur_col_split</dt><dd><p>Current column split names. This is recovered from the
current column path</p>
</dd>
<dt>cur_col_split_val</dt><dd><p>Current column split values. This is recovered from the
current column path</p>
</dd>
</dl>

<p><em>note Within analysis functions that accept <code>.spl_context</code>, the
<code>all_cols_n</code> and <code>cur_col_n</code> columns of the dataframe will contain the 'true'
observation counts corresponding to the row-group and row-group x column
subsets of the data. These numbers will not, and currently cannot, reflect
alternate column observation counts provided by the <code>alt_counts_df</code>,
<code>col_counts</code> or <code>col_total</code> arguments to <code><a href="#topic+build_table">build_table</a></code></em>
</p>

<hr>
<h2 id='spl_context_to_disp_path'>Translate spl_context to Path for display in error messages</h2><span id='topic+spl_context_to_disp_path'></span>

<h3>Description</h3>

<p>Translate spl_context to Path for display in error messages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spl_context_to_disp_path(ctx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spl_context_to_disp_path_+3A_ctx">ctx</code></td>
<td>
<p>data.frame. The <code>spl_context</code> data.frame where the error occurred</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string containing a description of the row path corresponding
to the <code>ctx</code>
</p>

<hr>
<h2 id='spl_variable'>Variable Associated With a Split</h2><span id='topic+spl_variable'></span><span id='topic+spl_variable+2CVarLevelSplit-method'></span><span id='topic+spl_variable+2CVarDynCutSplit-method'></span><span id='topic+spl_variable+2CVarStaticCutSplit-method'></span><span id='topic+spl_variable+2CSplit-method'></span>

<h3>Description</h3>

<p>This function  is intended  for use  when writing  custom splitting
logic.  In  cases where  the  split  is  associated with  a  single
variable, the  name of that variable  will be returned. At  time of
writing     this    includes     splits    generated     via    the
<code><a href="#topic+split_rows_by">split_rows_by</a></code>, <code><a href="#topic+split_cols_by">split_cols_by</a></code>,
<code><a href="#topic+split_rows_by_cuts">split_rows_by_cuts</a></code>, <code><a href="#topic+split_cols_by_cuts">split_cols_by_cuts</a></code>,
<code><a href="#topic+split_rows_by_cutfun">split_rows_by_cutfun</a></code>, and
<code><a href="#topic+split_cols_by_cutfun">split_cols_by_cutfun</a></code> layout directives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spl_variable(spl)

## S4 method for signature 'VarLevelSplit'
spl_variable(spl)

## S4 method for signature 'VarDynCutSplit'
spl_variable(spl)

## S4 method for signature 'VarStaticCutSplit'
spl_variable(spl)

## S4 method for signature 'Split'
spl_variable(spl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spl_variable_+3A_spl">spl</code></td>
<td>
<p>Split. The split object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>for splits with a single variable associated with them, the split, for others, an error is raised.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_split_fun">make_split_fun</a></code>
</p>

<hr>
<h2 id='split_cols_by'>Declaring a column-split based on levels of a variable</h2><span id='topic+split_cols_by'></span>

<h3>Description</h3>

<p>Will generate children for each subset of a categorical variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_cols_by(
  lyt,
  var,
  labels_var = var,
  split_label = var,
  split_fun = NULL,
  format = NULL,
  nested = TRUE,
  child_labels = c("default", "visible", "hidden"),
  extra_args = list(),
  ref_group = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_cols_by_+3A_lyt">lyt</code></td>
<td>
<p>layout object pre-data used for tabulation</p>
</td></tr>
<tr><td><code id="split_cols_by_+3A_var">var</code></td>
<td>
<p>string, variable name</p>
</td></tr>
<tr><td><code id="split_cols_by_+3A_labels_var">labels_var</code></td>
<td>
<p>string, name of variable containing labels to be displayed
for the values of <code>var</code></p>
</td></tr>
<tr><td><code id="split_cols_by_+3A_split_label">split_label</code></td>
<td>
<p>string. Label string to be associated with the table
generated by the split. Not to be confused with labels assigned to each
child (which are based on the data and type of split during tabulation).</p>
</td></tr>
<tr><td><code id="split_cols_by_+3A_split_fun">split_fun</code></td>
<td>
<p>function/NULL. custom splitting function See
<code><a href="#topic+custom_split_funs">custom_split_funs</a></code></p>
</td></tr>
<tr><td><code id="split_cols_by_+3A_format">format</code></td>
<td>
<p><code>FormatSpec</code>. Format associated with this split. Formats can be
declared via strings (<code>"xx.x"</code>) or function. In cases such as
<code>analyze</code> calls, they can character vectors or lists of functions.</p>
</td></tr>
<tr><td><code id="split_cols_by_+3A_nested">nested</code></td>
<td>
<p>boolean. Should this layout instruction be applied within the
existing layout structure <em>if possible</em> (<code>TRUE</code>, the default) or as a
new top-level element ('FALSE). Ignored if it would nest a split underneath
analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="split_cols_by_+3A_child_labels">child_labels</code></td>
<td>
<p>string. One of <code>"default"</code>, <code>"visible"</code>,
<code>"hidden"</code>. What should the display behavior be for the  labels (i.e.
label rows) of the children of this split. Defaults to <code>"default"</code>
which flags the label row as visible only if the child has 0 content rows.</p>
</td></tr>
<tr><td><code id="split_cols_by_+3A_extra_args">extra_args</code></td>
<td>
<p>list. Extra arguments to be passed to the tabulation
function. Element position in the list corresponds to the children of this
split. Named elements in the child-specific lists are ignored if they do
not match a formal argument of the tabulation function.</p>
</td></tr>
<tr><td><code id="split_cols_by_+3A_ref_group">ref_group</code></td>
<td>
<p>character(1) or <code>NULL</code>. Level of <code>var</code> which should be
considered ref_group/reference</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>PreDataTableLayouts</code> object suitable for passing to further
layouting functions, and to <code>build_table</code>.
</p>


<h3>Custom Splitting Function Details</h3>

<p>User-defined custom split functions can perform any type of computation on
the incoming data provided that they meet the contract for generating
'splits' of the incoming data 'based on' the split object.
</p>
<p>Split functions are functions that accept:
</p>

<dl>
<dt>df</dt><dd><p>data.frame of incoming data to be split</p>
</dd>
<dt>spl</dt><dd><p>a Split object. this is largely an internal detail custom
functions will not need to worry about, but  <code>obj_name(spl)</code>, for
example, will give the name of the split as it will appear in paths in the
resulting table</p>
</dd>
<dt>vals</dt><dd><p>Any pre-calculated values. If given non-null values, the values
returned should match these. Should be NULL in most cases and can likely be
ignored</p>
</dd>
<dt>labels</dt><dd><p>Any pre-calculated value labels. Same as above for
<code>values</code></p>
</dd>
<dt>trim</dt><dd><p>If <code>TRUE</code>, resulting splits that are empty should be
removed</p>
</dd>
<dt>(Optional) .spl_context</dt><dd><p>a data.frame describing previously performed
splits which collectively arrived at <code>df</code></p>
</dd>
</dl>

<p>The function must then output a <code>named list</code> with the following
elements:
</p>

<dl>
<dt>values</dt><dd><p>The vector of all values corresponding to the splits of
<code>df</code></p>
</dd>
<dt>datasplit</dt><dd><p>a list of data.frames representing the groupings of the
actual observations from <code>df</code>.</p>
</dd>
<dt>labels</dt><dd><p>a character vector giving a string label for each value listed
in the <code>values</code> element above</p>
</dd>
<dt>(Optional) extras</dt><dd><p>If present, extra arguments are to be passed to summary
and analysis functions whenever they are executed on the corresponding
element of <code>datasplit</code> or a subset thereof</p>
</dd>
</dl>

<p>One way to generate custom splitting functions is to wrap existing split
functions and modify either the incoming data before they are called or
their outputs.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  analyze(c("AGE", "BMRKR2"))

tbl &lt;- build_table(lyt, ex_adsl)
tbl

# Let's look at the splits in more detail

lyt1 &lt;- basic_table() %&gt;% split_cols_by("ARM")
lyt1

# add an analysis (summary)
lyt2 &lt;- lyt1 %&gt;%
  analyze(c("AGE", "COUNTRY"),
    afun = list_wrap_x(summary),
    format = "xx.xx"
  )
lyt2

tbl2 &lt;- build_table(lyt2, DM)
tbl2

# By default sequentially adding layouts results in nesting
library(dplyr)
DM_MF &lt;- DM %&gt;%
  filter(SEX %in% c("M", "F")) %&gt;%
  mutate(SEX = droplevels(SEX))

lyt3 &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_cols_by("SEX") %&gt;%
  analyze(c("AGE", "COUNTRY"),
    afun = list_wrap_x(summary),
    format = "xx.xx"
  )
lyt3

tbl3 &lt;- build_table(lyt3, DM_MF)
tbl3

# nested=TRUE vs not
lyt4 &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("SEX", split_fun = drop_split_levels) %&gt;%
  split_rows_by("RACE", split_fun = drop_split_levels) %&gt;%
  analyze("AGE")
lyt4

tbl4 &lt;- build_table(lyt4, DM)
tbl4

lyt5 &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("SEX", split_fun = drop_split_levels) %&gt;%
  analyze("AGE") %&gt;%
  split_rows_by("RACE", nested = FALSE, split_fun = drop_split_levels) %&gt;%
  analyze("AGE")
lyt5

tbl5 &lt;- build_table(lyt5, DM)
tbl5

</code></pre>

<hr>
<h2 id='split_cols_by_cuts'>Split on static or dynamic cuts of the data</h2><span id='topic+split_cols_by_cuts'></span><span id='topic+split_rows_by_cuts'></span><span id='topic+split_cols_by_cutfun'></span><span id='topic+split_cols_by_quartiles'></span><span id='topic+split_rows_by_quartiles'></span><span id='topic+split_rows_by_cutfun'></span>

<h3>Description</h3>

<p>Create columns (or row splits) based on values (such as quartiles) of
<code>var</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_cols_by_cuts(
  lyt,
  var,
  cuts,
  cutlabels = NULL,
  split_label = var,
  nested = TRUE,
  cumulative = FALSE
)

split_rows_by_cuts(
  lyt,
  var,
  cuts,
  cutlabels = NULL,
  split_label = var,
  format = NULL,
  na_str = NA_character_,
  nested = TRUE,
  cumulative = FALSE,
  label_pos = "hidden",
  section_div = NA_character_
)

split_cols_by_cutfun(
  lyt,
  var,
  cutfun = qtile_cuts,
  cutlabelfun = function(x) NULL,
  split_label = var,
  nested = TRUE,
  extra_args = list(),
  cumulative = FALSE
)

split_cols_by_quartiles(
  lyt,
  var,
  split_label = var,
  nested = TRUE,
  extra_args = list(),
  cumulative = FALSE
)

split_rows_by_quartiles(
  lyt,
  var,
  split_label = var,
  format = NULL,
  na_str = NA_character_,
  nested = TRUE,
  child_labels = c("default", "visible", "hidden"),
  extra_args = list(),
  cumulative = FALSE,
  indent_mod = 0L,
  label_pos = "hidden",
  section_div = NA_character_
)

split_rows_by_cutfun(
  lyt,
  var,
  cutfun = qtile_cuts,
  cutlabelfun = function(x) NULL,
  split_label = var,
  format = NULL,
  na_str = NA_character_,
  nested = TRUE,
  child_labels = c("default", "visible", "hidden"),
  extra_args = list(),
  cumulative = FALSE,
  indent_mod = 0L,
  label_pos = "hidden",
  section_div = NA_character_
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_cols_by_cuts_+3A_lyt">lyt</code></td>
<td>
<p>layout object pre-data used for tabulation</p>
</td></tr>
<tr><td><code id="split_cols_by_cuts_+3A_var">var</code></td>
<td>
<p>string, variable name</p>
</td></tr>
<tr><td><code id="split_cols_by_cuts_+3A_cuts">cuts</code></td>
<td>
<p>numeric. Cuts to use</p>
</td></tr>
<tr><td><code id="split_cols_by_cuts_+3A_cutlabels">cutlabels</code></td>
<td>
<p>character (or NULL). Labels for the cuts</p>
</td></tr>
<tr><td><code id="split_cols_by_cuts_+3A_split_label">split_label</code></td>
<td>
<p>string. Label string to be associated with the table
generated by the split. Not to be confused with labels assigned to each
child (which are based on the data and type of split during tabulation).</p>
</td></tr>
<tr><td><code id="split_cols_by_cuts_+3A_nested">nested</code></td>
<td>
<p>boolean. Should this layout instruction be applied within the
existing layout structure <em>if possible</em> (<code>TRUE</code>, the default) or as a
new top-level element ('FALSE). Ignored if it would nest a split underneath
analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="split_cols_by_cuts_+3A_cumulative">cumulative</code></td>
<td>
<p>logical. Should the cuts be treated as cumulative. Defaults
to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="split_cols_by_cuts_+3A_format">format</code></td>
<td>
<p><code>FormatSpec</code>. Format associated with this split. Formats can be
declared via strings (<code>"xx.x"</code>) or function. In cases such as
<code>analyze</code> calls, they can character vectors or lists of functions.</p>
</td></tr>
<tr><td><code id="split_cols_by_cuts_+3A_na_str">na_str</code></td>
<td>
<p>character(1). String that should be displayed when the value of <code>x</code> is missing.
Defaults to <code>"NA"</code>.</p>
</td></tr>
<tr><td><code id="split_cols_by_cuts_+3A_label_pos">label_pos</code></td>
<td>
<p>character(1). Location the variable label should be
displayed, Accepts <code>"hidden"</code> (default for non-analyze row splits), <code>"visible"</code>,
<code>"topleft"</code>, and - for analyze splits only - <code>"default"</code>.  For analyze calls,
<code>"default"</code> indicates that the variable should be visible if and only if
multiple variables are analyzed at the same level of nesting.</p>
</td></tr>
<tr><td><code id="split_cols_by_cuts_+3A_section_div">section_div</code></td>
<td>
<p>character(1). String which should be repeated as a section
divider after each group defined by this split instruction, or
<code>NA_character_</code> (the default) for no section divider.</p>
</td></tr>
<tr><td><code id="split_cols_by_cuts_+3A_cutfun">cutfun</code></td>
<td>
<p>function. Function which accepts the full vector of <code>var</code>
values and returns cut points to be passed to <code>cut</code>.</p>
</td></tr>
<tr><td><code id="split_cols_by_cuts_+3A_cutlabelfun">cutlabelfun</code></td>
<td>
<p>function. Function which returns either labels for the
cuts or NULL when passed the return value of <code>cutfun</code></p>
</td></tr>
<tr><td><code id="split_cols_by_cuts_+3A_extra_args">extra_args</code></td>
<td>
<p>list. Extra arguments to be passed to the tabulation
function. Element position in the list corresponds to the children of this
split. Named elements in the child-specific lists are ignored if they do
not match a formal argument of the tabulation function.</p>
</td></tr>
<tr><td><code id="split_cols_by_cuts_+3A_child_labels">child_labels</code></td>
<td>
<p>string. One of <code>"default"</code>, <code>"visible"</code>,
<code>"hidden"</code>. What should the display behavior be for the  labels (i.e.
label rows) of the children of this split. Defaults to <code>"default"</code>
which flags the label row as visible only if the child has 0 content rows.</p>
</td></tr>
<tr><td><code id="split_cols_by_cuts_+3A_indent_mod">indent_mod</code></td>
<td>
<p>numeric. Modifier for the default indent position for the
structure created by this function(subtable, content table, or row)
<em>and all of that structure's children</em>. Defaults to 0, which
corresponds to the unmodified default behavior.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For dynamic cuts, the cut is transformed into a static cut by
<code><a href="#topic+build_table">build_table</a></code> <em>based on the full dataset</em>, before
proceeding. Thus even when nested within another split in column/row space,
the resulting split will reflect the overall values (e.g., quartiles) in the
dataset, NOT the values for subset  it is nested under.
</p>


<h3>Value</h3>

<p>A <code>PreDataTableLayouts</code> object suitable for passing to further
layouting functions, and to <code>build_table</code>.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# split_cols_by_cuts
lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_cols_by_cuts("AGE",
    split_label = "Age",
    cuts = c(0, 25, 35, 1000),
    cutlabels = c("young", "medium", "old")
  ) %&gt;%
  analyze(c("BMRKR2", "STRATA2")) %&gt;%
  append_topleft("counts")

tbl &lt;- build_table(lyt, ex_adsl)
tbl

# split_rows_by_cuts
lyt2 &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by_cuts("AGE",
    split_label = "Age",
    cuts = c(0, 25, 35, 1000),
    cutlabels = c("young", "medium", "old")
  ) %&gt;%
  analyze(c("BMRKR2", "STRATA2")) %&gt;%
  append_topleft("counts")


tbl2 &lt;- build_table(lyt2, ex_adsl)
tbl2

# split_cols_by_quartiles

lyt3 &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_cols_by_quartiles("AGE", split_label = "Age") %&gt;%
  analyze(c("BMRKR2", "STRATA2")) %&gt;%
  append_topleft("counts")

tbl3 &lt;- build_table(lyt3, ex_adsl)
tbl3

# split_rows_by_quartiles
lyt4 &lt;- basic_table(show_colcounts = TRUE) %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by_quartiles("AGE", split_label = "Age") %&gt;%
  analyze("BMRKR2") %&gt;%
  append_topleft(c("Age Quartiles", " Counts BMRKR2"))

tbl4 &lt;- build_table(lyt4, ex_adsl)
tbl4

# split_cols_by_cutfun
cutfun &lt;- function(x) {
  cutpoints &lt;- c(
    min(x),
    mean(x),
    max(x)
  )

  names(cutpoints) &lt;- c("", "Younger", "Older")
  cutpoints
}

lyt5 &lt;- basic_table() %&gt;%
  split_cols_by_cutfun("AGE", cutfun = cutfun) %&gt;%
  analyze("SEX")

tbl5 &lt;- build_table(lyt5, ex_adsl)
tbl5

# split_rows_by_cutfun
lyt6 &lt;- basic_table() %&gt;%
  split_cols_by("SEX") %&gt;%
  split_rows_by_cutfun("AGE", cutfun = cutfun) %&gt;%
  analyze("BMRKR2")

tbl6 &lt;- build_table(lyt6, ex_adsl)
tbl6

</code></pre>

<hr>
<h2 id='split_cols_by_multivar'>Associate Multiple Variables with Columns</h2><span id='topic+split_cols_by_multivar'></span>

<h3>Description</h3>

<p>In some cases, the variable to be ultimately analyzed is most naturally
defined on a column, not a row basis. When we need columns to reflect
different variables entirely, rather than different levels of a single
variable, we use <code>split_cols_by_multivar</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_cols_by_multivar(
  lyt,
  vars,
  split_fun = NULL,
  varlabels = vars,
  varnames = NULL,
  nested = TRUE,
  extra_args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_cols_by_multivar_+3A_lyt">lyt</code></td>
<td>
<p>layout object pre-data used for tabulation</p>
</td></tr>
<tr><td><code id="split_cols_by_multivar_+3A_vars">vars</code></td>
<td>
<p>character vector. Multiple variable names.</p>
</td></tr>
<tr><td><code id="split_cols_by_multivar_+3A_split_fun">split_fun</code></td>
<td>
<p>function/NULL. custom splitting function See
<code><a href="#topic+custom_split_funs">custom_split_funs</a></code></p>
</td></tr>
<tr><td><code id="split_cols_by_multivar_+3A_varlabels">varlabels</code></td>
<td>
<p>character vector. Labels for <code>vars</code></p>
</td></tr>
<tr><td><code id="split_cols_by_multivar_+3A_varnames">varnames</code></td>
<td>
<p>character vector. Names for <code>vars</code> which will appear in
pathing. When <code>vars</code> are all unique this will be the variable names.
If not, these will be variable names with suffixes as necessary to enforce
uniqueness.</p>
</td></tr>
<tr><td><code id="split_cols_by_multivar_+3A_nested">nested</code></td>
<td>
<p>boolean. Should this layout instruction be applied within the
existing layout structure <em>if possible</em> (<code>TRUE</code>, the default) or as a
new top-level element ('FALSE). Ignored if it would nest a split underneath
analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="split_cols_by_multivar_+3A_extra_args">extra_args</code></td>
<td>
<p>list. Extra arguments to be passed to the tabulation
function. Element position in the list corresponds to the children of this
split. Named elements in the child-specific lists are ignored if they do
not match a formal argument of the tabulation function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>PreDataTableLayouts</code> object suitable for passing to further
layouting functions, and to <code>build_table</code>.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>


<h3>See Also</h3>

<p><code><a href="#topic+analyze_colvars">analyze_colvars()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
ANL &lt;- DM %&gt;% mutate(value = rnorm(n()), pctdiff = runif(n()))

## toy example where we take the mean of the first variable and the
## count of &gt;.5 for the second.
colfuns &lt;- list(
  function(x) in_rows(mean = mean(x), .formats = "xx.x"),
  function(x) in_rows("# x &gt; 5" = sum(x &gt; .5), .formats = "xx")
)

lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_cols_by_multivar(c("value", "pctdiff")) %&gt;%
  split_rows_by("RACE",
    split_label = "ethnicity",
    split_fun = drop_split_levels
  ) %&gt;%
  summarize_row_groups() %&gt;%
  analyze_colvars(afun = colfuns)
lyt

tbl &lt;- build_table(lyt, ANL)
tbl

</code></pre>

<hr>
<h2 id='split_funcs'>Split functions</h2><span id='topic+split_funcs'></span><span id='topic+remove_split_levels'></span><span id='topic+keep_split_levels'></span><span id='topic+drop_split_levels'></span><span id='topic+drop_and_remove_levels'></span><span id='topic+reorder_split_levels'></span><span id='topic+trim_levels_in_group'></span>

<h3>Description</h3>

<p>Split functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_split_levels(excl)

keep_split_levels(only, reorder = TRUE)

drop_split_levels(df, spl, vals = NULL, labels = NULL, trim = FALSE)

drop_and_remove_levels(excl)

reorder_split_levels(neworder, newlabels = neworder, drlevels = TRUE)

trim_levels_in_group(innervar, drop_outlevs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_funcs_+3A_excl">excl</code></td>
<td>
<p>character. Levels to be excluded (they will not be reflected in
the resulting table structure regardless of presence in the data).</p>
</td></tr>
<tr><td><code id="split_funcs_+3A_only">only</code></td>
<td>
<p>character. Levels to retain (all others will be dropped).</p>
</td></tr>
<tr><td><code id="split_funcs_+3A_reorder">reorder</code></td>
<td>
<p>logical(1). Should the order of <code>only</code> be used as the
order of the children of the split. defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="split_funcs_+3A_df">df</code></td>
<td>
<p>dataset (<code>data.frame</code> or <code>tibble</code>)</p>
</td></tr>
<tr><td><code id="split_funcs_+3A_spl">spl</code></td>
<td>
<p>A Split object defining a partitioning or analysis/tabulation of
the data.</p>
</td></tr>
<tr><td><code id="split_funcs_+3A_vals">vals</code></td>
<td>
<p>ANY. For internal use only.</p>
</td></tr>
<tr><td><code id="split_funcs_+3A_labels">labels</code></td>
<td>
<p>character. Labels to use for the remaining levels instead of
the existing ones.</p>
</td></tr>
<tr><td><code id="split_funcs_+3A_trim">trim</code></td>
<td>
<p>logical(1). Should splits corresponding with 0 observations be
kept when tabulating.</p>
</td></tr>
<tr><td><code id="split_funcs_+3A_neworder">neworder</code></td>
<td>
<p>character. New order or factor levels.</p>
</td></tr>
<tr><td><code id="split_funcs_+3A_newlabels">newlabels</code></td>
<td>
<p>character. Labels for (new order of) factor levels</p>
</td></tr>
<tr><td><code id="split_funcs_+3A_drlevels">drlevels</code></td>
<td>
<p>logical(1). Should levels in the data which do not appear in
<code>neworder</code> be dropped. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="split_funcs_+3A_innervar">innervar</code></td>
<td>
<p>character(1). Variable whose factor levels should be trimmed
(e.g., empty levels dropped) <em>separately within each grouping defined
at this point in the structure</em></p>
</td></tr>
<tr><td><code id="split_funcs_+3A_drop_outlevs">drop_outlevs</code></td>
<td>
<p>logical(1). Should empty levels in the variable being
split on (i.e. the 'outer' variable, not <code>innervar</code>) be dropped?
Defaults to <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a closure suitable for use as a splitting function (<code>splfun</code>)
when creating a table layout
</p>


<h3>Custom Splitting Function Details</h3>

<p>User-defined custom split functions can perform any type of computation on
the incoming data provided that they meet the contract for generating
'splits' of the incoming data 'based on' the split object.
</p>
<p>Split functions are functions that accept:
</p>

<dl>
<dt>df</dt><dd><p>data.frame of incoming data to be split</p>
</dd>
<dt>spl</dt><dd><p>a Split object. this is largely an internal detail custom
functions will not need to worry about, but  <code>obj_name(spl)</code>, for
example, will give the name of the split as it will appear in paths in the
resulting table</p>
</dd>
<dt>vals</dt><dd><p>Any pre-calculated values. If given non-null values, the values
returned should match these. Should be NULL in most cases and can likely be
ignored</p>
</dd>
<dt>labels</dt><dd><p>Any pre-calculated value labels. Same as above for
<code>values</code></p>
</dd>
<dt>trim</dt><dd><p>If <code>TRUE</code>, resulting splits that are empty should be
removed</p>
</dd>
<dt>(Optional) .spl_context</dt><dd><p>a data.frame describing previously performed
splits which collectively arrived at <code>df</code></p>
</dd>
</dl>

<p>The function must then output a <code>named list</code> with the following
elements:
</p>

<dl>
<dt>values</dt><dd><p>The vector of all values corresponding to the splits of
<code>df</code></p>
</dd>
<dt>datasplit</dt><dd><p>a list of data.frames representing the groupings of the
actual observations from <code>df</code>.</p>
</dd>
<dt>labels</dt><dd><p>a character vector giving a string label for each value listed
in the <code>values</code> element above</p>
</dd>
<dt>(Optional) extras</dt><dd><p>If present, extra arguments are to be passed to summary
and analysis functions whenever they are executed on the corresponding
element of <code>datasplit</code> or a subset thereof</p>
</dd>
</dl>

<p>One way to generate custom splitting functions is to wrap existing split
functions and modify either the incoming data before they are called or
their outputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("COUNTRY",
    split_fun = remove_split_levels(c(
      "USA", "CAN",
      "CHE", "BRA"
    ))
  ) %&gt;%
  analyze("AGE")

tbl &lt;- build_table(lyt, DM)
tbl

lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("COUNTRY",
    split_fun = keep_split_levels(c("USA", "CAN", "BRA"))
  ) %&gt;%
  analyze("AGE")

tbl &lt;- build_table(lyt, DM)
tbl
lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("SEX", split_fun = drop_split_levels) %&gt;%
  analyze("AGE")

tbl &lt;- build_table(lyt, DM)
tbl
lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("SEX", split_fun = drop_and_remove_levels(c("M", "U"))) %&gt;%
  analyze("AGE")

tbl &lt;- build_table(lyt, DM)
tbl
</code></pre>

<hr>
<h2 id='split_rows_by'>Add Rows according to levels of a variable</h2><span id='topic+split_rows_by'></span>

<h3>Description</h3>

<p>Add Rows according to levels of a variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_rows_by(
  lyt,
  var,
  labels_var = var,
  split_label = var,
  split_fun = NULL,
  format = NULL,
  na_str = NA_character_,
  nested = TRUE,
  child_labels = c("default", "visible", "hidden"),
  label_pos = "hidden",
  indent_mod = 0L,
  page_by = FALSE,
  page_prefix = split_label,
  section_div = NA_character_
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_rows_by_+3A_lyt">lyt</code></td>
<td>
<p>layout object pre-data used for tabulation</p>
</td></tr>
<tr><td><code id="split_rows_by_+3A_var">var</code></td>
<td>
<p>string, variable name</p>
</td></tr>
<tr><td><code id="split_rows_by_+3A_labels_var">labels_var</code></td>
<td>
<p>string, name of variable containing labels to be displayed
for the values of <code>var</code></p>
</td></tr>
<tr><td><code id="split_rows_by_+3A_split_label">split_label</code></td>
<td>
<p>string. Label string to be associated with the table
generated by the split. Not to be confused with labels assigned to each
child (which are based on the data and type of split during tabulation).</p>
</td></tr>
<tr><td><code id="split_rows_by_+3A_split_fun">split_fun</code></td>
<td>
<p>function/NULL. custom splitting function See
<code><a href="#topic+custom_split_funs">custom_split_funs</a></code></p>
</td></tr>
<tr><td><code id="split_rows_by_+3A_format">format</code></td>
<td>
<p><code>FormatSpec</code>. Format associated with this split. Formats can be
declared via strings (<code>"xx.x"</code>) or function. In cases such as
<code>analyze</code> calls, they can character vectors or lists of functions.</p>
</td></tr>
<tr><td><code id="split_rows_by_+3A_na_str">na_str</code></td>
<td>
<p>character(1). String that should be displayed when the value of <code>x</code> is missing.
Defaults to <code>"NA"</code>.</p>
</td></tr>
<tr><td><code id="split_rows_by_+3A_nested">nested</code></td>
<td>
<p>boolean. Should this layout instruction be applied within the
existing layout structure <em>if possible</em> (<code>TRUE</code>, the default) or as a
new top-level element ('FALSE). Ignored if it would nest a split underneath
analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="split_rows_by_+3A_child_labels">child_labels</code></td>
<td>
<p>string. One of <code>"default"</code>, <code>"visible"</code>,
<code>"hidden"</code>. What should the display behavior be for the  labels (i.e.
label rows) of the children of this split. Defaults to <code>"default"</code>
which flags the label row as visible only if the child has 0 content rows.</p>
</td></tr>
<tr><td><code id="split_rows_by_+3A_label_pos">label_pos</code></td>
<td>
<p>character(1). Location the variable label should be
displayed, Accepts <code>"hidden"</code> (default for non-analyze row splits), <code>"visible"</code>,
<code>"topleft"</code>, and - for analyze splits only - <code>"default"</code>.  For analyze calls,
<code>"default"</code> indicates that the variable should be visible if and only if
multiple variables are analyzed at the same level of nesting.</p>
</td></tr>
<tr><td><code id="split_rows_by_+3A_indent_mod">indent_mod</code></td>
<td>
<p>numeric. Modifier for the default indent position for the
structure created by this function(subtable, content table, or row)
<em>and all of that structure's children</em>. Defaults to 0, which
corresponds to the unmodified default behavior.</p>
</td></tr>
<tr><td><code id="split_rows_by_+3A_page_by">page_by</code></td>
<td>
<p>logical(1). Should pagination be forced between different
children resulting form this split. An error will rise if the selected split
does not contain at least one value that is not <code>NA</code>.</p>
</td></tr>
<tr><td><code id="split_rows_by_+3A_page_prefix">page_prefix</code></td>
<td>
<p>character(1). Prefix, to be appended with the split value,
when forcing pagination between the children of this split/table</p>
</td></tr>
<tr><td><code id="split_rows_by_+3A_section_div">section_div</code></td>
<td>
<p>character(1). String which should be repeated as a section
divider after each group defined by this split instruction, or
<code>NA_character_</code> (the default) for no section divider.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>PreDataTableLayouts</code> object suitable for passing to further
layouting functions, and to <code>build_table</code>.
</p>


<h3>Custom Splitting Function Details</h3>

<p>User-defined custom split functions can perform any type of computation on
the incoming data provided that they meet the contract for generating
'splits' of the incoming data 'based on' the split object.
</p>
<p>Split functions are functions that accept:
</p>

<dl>
<dt>df</dt><dd><p>data.frame of incoming data to be split</p>
</dd>
<dt>spl</dt><dd><p>a Split object. this is largely an internal detail custom
functions will not need to worry about, but  <code>obj_name(spl)</code>, for
example, will give the name of the split as it will appear in paths in the
resulting table</p>
</dd>
<dt>vals</dt><dd><p>Any pre-calculated values. If given non-null values, the values
returned should match these. Should be NULL in most cases and can likely be
ignored</p>
</dd>
<dt>labels</dt><dd><p>Any pre-calculated value labels. Same as above for
<code>values</code></p>
</dd>
<dt>trim</dt><dd><p>If <code>TRUE</code>, resulting splits that are empty should be
removed</p>
</dd>
<dt>(Optional) .spl_context</dt><dd><p>a data.frame describing previously performed
splits which collectively arrived at <code>df</code></p>
</dd>
</dl>

<p>The function must then output a <code>named list</code> with the following
elements:
</p>

<dl>
<dt>values</dt><dd><p>The vector of all values corresponding to the splits of
<code>df</code></p>
</dd>
<dt>datasplit</dt><dd><p>a list of data.frames representing the groupings of the
actual observations from <code>df</code>.</p>
</dd>
<dt>labels</dt><dd><p>a character vector giving a string label for each value listed
in the <code>values</code> element above</p>
</dd>
<dt>(Optional) extras</dt><dd><p>If present, extra arguments are to be passed to summary
and analysis functions whenever they are executed on the corresponding
element of <code>datasplit</code> or a subset thereof</p>
</dd>
</dl>

<p>One way to generate custom splitting functions is to wrap existing split
functions and modify either the incoming data before they are called or
their outputs.
</p>


<h3>Note</h3>

<p>If <code>var</code> is a factor with empty unobserved levels and
<code>labels_var</code> is specified, it must also be a factor
with the same number of levels as <code>var</code>. Currently the
error that occurs when this is not the case is not very informative,
but that will change in the future.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("RACE", split_fun = drop_split_levels) %&gt;%
  analyze("AGE", mean, var_labels = "Age", format = "xx.xx")

tbl &lt;- build_table(lyt, DM)
tbl

lyt2 &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("RACE") %&gt;%
  analyze("AGE", mean, var_labels = "Age", format = "xx.xx")

tbl2 &lt;- build_table(lyt2, DM)
tbl2

lyt3 &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_cols_by("SEX") %&gt;%
  summarize_row_groups(label_fstr = "Overall (N)") %&gt;%
  split_rows_by("RACE",
    split_label = "Ethnicity", labels_var = "ethn_lab",
    split_fun = drop_split_levels
  ) %&gt;%
  summarize_row_groups("RACE", label_fstr = "%s (n)") %&gt;%
  analyze("AGE", var_labels = "Age", afun = mean, format = "xx.xx")

lyt3

library(dplyr)
DM2 &lt;- DM %&gt;%
  filter(SEX %in% c("M", "F")) %&gt;%
  mutate(
    SEX = droplevels(SEX),
    gender_lab = c(
      "F" = "Female", "M" = "Male",
      "U" = "Unknown",
      "UNDIFFERENTIATED" = "Undifferentiated"
    )[SEX],
    ethn_lab = c(
      "ASIAN" = "Asian",
      "BLACK OR AFRICAN AMERICAN" = "Black or African American",
      "WHITE" = "White",
      "AMERICAN INDIAN OR ALASKA NATIVE" = "American Indian or Alaska Native",
      "MULTIPLE" = "Multiple",
      "NATIVE HAWAIIAN OR OTHER PACIFIC ISLANDER" =
        "Native Hawaiian or Other Pacific Islander",
      "OTHER" = "Other", "UNKNOWN" = "Unknown"
    )[RACE]
  )

tbl3 &lt;- build_table(lyt3, DM2)
tbl3

</code></pre>

<hr>
<h2 id='split_rows_by_multivar'>Associate Multiple Variables with Rows</h2><span id='topic+split_rows_by_multivar'></span>

<h3>Description</h3>

<p>When we need rows to reflect different variables rather than different
levels of a single variable, we use <code>split_rows_by_multivar</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_rows_by_multivar(
  lyt,
  vars,
  split_fun = NULL,
  split_label = "",
  varlabels = vars,
  format = NULL,
  na_str = NA_character_,
  nested = TRUE,
  child_labels = c("default", "visible", "hidden"),
  indent_mod = 0L,
  section_div = NA_character_,
  extra_args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_rows_by_multivar_+3A_lyt">lyt</code></td>
<td>
<p>layout object pre-data used for tabulation</p>
</td></tr>
<tr><td><code id="split_rows_by_multivar_+3A_vars">vars</code></td>
<td>
<p>character vector. Multiple variable names.</p>
</td></tr>
<tr><td><code id="split_rows_by_multivar_+3A_split_fun">split_fun</code></td>
<td>
<p>function/NULL. custom splitting function See
<code><a href="#topic+custom_split_funs">custom_split_funs</a></code></p>
</td></tr>
<tr><td><code id="split_rows_by_multivar_+3A_split_label">split_label</code></td>
<td>
<p>string. Label string to be associated with the table
generated by the split. Not to be confused with labels assigned to each
child (which are based on the data and type of split during tabulation).</p>
</td></tr>
<tr><td><code id="split_rows_by_multivar_+3A_varlabels">varlabels</code></td>
<td>
<p>character vector. Labels for <code>vars</code></p>
</td></tr>
<tr><td><code id="split_rows_by_multivar_+3A_format">format</code></td>
<td>
<p><code>FormatSpec</code>. Format associated with this split. Formats can be
declared via strings (<code>"xx.x"</code>) or function. In cases such as
<code>analyze</code> calls, they can character vectors or lists of functions.</p>
</td></tr>
<tr><td><code id="split_rows_by_multivar_+3A_na_str">na_str</code></td>
<td>
<p>character(1). String that should be displayed when the value of <code>x</code> is missing.
Defaults to <code>"NA"</code>.</p>
</td></tr>
<tr><td><code id="split_rows_by_multivar_+3A_nested">nested</code></td>
<td>
<p>boolean. Should this layout instruction be applied within the
existing layout structure <em>if possible</em> (<code>TRUE</code>, the default) or as a
new top-level element ('FALSE). Ignored if it would nest a split underneath
analyses, which is not allowed.</p>
</td></tr>
<tr><td><code id="split_rows_by_multivar_+3A_child_labels">child_labels</code></td>
<td>
<p>string. One of <code>"default"</code>, <code>"visible"</code>,
<code>"hidden"</code>. What should the display behavior be for the  labels (i.e.
label rows) of the children of this split. Defaults to <code>"default"</code>
which flags the label row as visible only if the child has 0 content rows.</p>
</td></tr>
<tr><td><code id="split_rows_by_multivar_+3A_indent_mod">indent_mod</code></td>
<td>
<p>numeric. Modifier for the default indent position for the
structure created by this function(subtable, content table, or row)
<em>and all of that structure's children</em>. Defaults to 0, which
corresponds to the unmodified default behavior.</p>
</td></tr>
<tr><td><code id="split_rows_by_multivar_+3A_section_div">section_div</code></td>
<td>
<p>character(1). String which should be repeated as a section
divider after each group defined by this split instruction, or
<code>NA_character_</code> (the default) for no section divider.</p>
</td></tr>
<tr><td><code id="split_rows_by_multivar_+3A_extra_args">extra_args</code></td>
<td>
<p>list. Extra arguments to be passed to the tabulation
function. Element position in the list corresponds to the children of this
split. Named elements in the child-specific lists are ignored if they do
not match a formal argument of the tabulation function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>PreDataTableLayouts</code> object suitable for passing to further
layouting functions, and to <code>build_table</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+split_rows_by">split_rows_by()</a></code> for typical row splitting, and
<code><a href="#topic+split_cols_by_multivar">split_cols_by_multivar()</a></code> to perform the same type of split on a column basis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by_multivar(c("SEX", "STRATA1")) %&gt;%
  summarize_row_groups() %&gt;%
  analyze(c("AGE", "SEX"))

tbl &lt;- build_table(lyt, DM)
tbl

</code></pre>

<hr>
<h2 id='summarize_row_groups'>Add a content row of summary counts</h2><span id='topic+summarize_row_groups'></span>

<h3>Description</h3>

<p>Add a content row of summary counts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_row_groups(
  lyt,
  var = "",
  label_fstr = "%s",
  format = "xx (xx.x%)",
  na_str = "-",
  cfun = NULL,
  indent_mod = 0L,
  extra_args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_row_groups_+3A_lyt">lyt</code></td>
<td>
<p>layout object pre-data used for tabulation</p>
</td></tr>
<tr><td><code id="summarize_row_groups_+3A_var">var</code></td>
<td>
<p>string, variable name</p>
</td></tr>
<tr><td><code id="summarize_row_groups_+3A_label_fstr">label_fstr</code></td>
<td>
<p>string. An <code>sprintf</code> style format string containing. For
non-comparison splits, it can contain  up to one <code>"%s"</code> which takes
the current split value and generates the row/column label.
Comparison-based splits it can contain up to two <code>"%s"</code>.</p>
</td></tr>
<tr><td><code id="summarize_row_groups_+3A_format">format</code></td>
<td>
<p><code>FormatSpec</code>. Format associated with this split. Formats can be
declared via strings (<code>"xx.x"</code>) or function. In cases such as
<code>analyze</code> calls, they can character vectors or lists of functions.</p>
</td></tr>
<tr><td><code id="summarize_row_groups_+3A_na_str">na_str</code></td>
<td>
<p>character(1). String that should be displayed when the value of <code>x</code> is missing.
Defaults to <code>"NA"</code>.</p>
</td></tr>
<tr><td><code id="summarize_row_groups_+3A_cfun">cfun</code></td>
<td>
<p>list/function/NULL. tabulation function(s) for creating content
rows. Must accept <code>x</code> or <code>df</code> as first parameter. Must accept
<code>labelstr</code> as the second argument. Can optionally accept all optional
arguments accepted by analysis functions. See <code><a href="#topic+analyze">analyze</a></code>.</p>
</td></tr>
<tr><td><code id="summarize_row_groups_+3A_indent_mod">indent_mod</code></td>
<td>
<p>numeric. Modifier for the default indent position for the
structure created by this function(subtable, content table, or row)
<em>and all of that structure's children</em>. Defaults to 0, which
corresponds to the unmodified default behavior.</p>
</td></tr>
<tr><td><code id="summarize_row_groups_+3A_extra_args">extra_args</code></td>
<td>
<p>list. Extra arguments to be passed to the tabulation
function. Element position in the list corresponds to the children of this
split. Named elements in the child-specific lists are ignored if they do
not match a formal argument of the tabulation function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>format</code> expects 1 value (i.e. it is specified as a format string
and <code>xx</code> appears for two values (i.e. <code>xx</code> appears twice in the
format string) or is specified as a function, then both raw and percent of
column total counts are calculated. If <code>format</code> is a format string where
<code>xx</code> appears only one time, only raw counts are used.
</p>
<p><code>cfun</code> must accept <code>x</code> or <code>df</code> as its first argument. For the <code>df</code> argument
<code>cfun</code> will receive the subset <code>data.frame</code> corresponding with the row-
and column-splitting for the cell being calculated. Must accept <code>labelstr</code> as
the second parameter, which accepts the <code>label</code> of the level of the parent
split currently being summarized. Can additionally take any optional argument
supported by analysis functions. (see <code><a href="#topic+analyze">analyze</a></code>).
</p>
<p>In addition, if complex custom functions are needed, we suggest checking the
available <a href="#topic+additional_fun_params">additional_fun_params</a> that apply here as for <code>afun</code>.
</p>


<h3>Value</h3>

<p>A <code>PreDataTableLayouts</code> object suitable for passing to further
layouting functions, and to <code>build_table</code>.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
DM2 &lt;- subset(DM, COUNTRY %in% c("USA", "CAN", "CHN"))

lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("COUNTRY", split_fun = drop_split_levels) %&gt;%
  summarize_row_groups(label_fstr = "%s (n)") %&gt;%
  analyze("AGE", afun = list_wrap_x(summary), format = "xx.xx")
lyt

tbl &lt;- build_table(lyt, DM2)
tbl

row_paths_summary(tbl) # summary count is a content table


## use a cfun and extra_args to customize summarization
## behavior
sfun &lt;- function(x, labelstr, trim) {
  in_rows(
    c(mean(x, trim = trim), trim),
    .formats = "xx.x (xx.x%)",
    .labels = sprintf(
      "%s (Trimmed mean and trim %%)",
      labelstr
    )
  )
}

lyt2 &lt;- basic_table(show_colcounts = TRUE) %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("COUNTRY", split_fun = drop_split_levels) %&gt;%
  summarize_row_groups("AGE",
    cfun = sfun,
    extra_args = list(trim = .2)
  ) %&gt;%
  analyze("AGE", afun = list_wrap_x(summary), format = "xx.xx") %&gt;%
  append_topleft(c("Country", "  Age"))

tbl2 &lt;- build_table(lyt2, DM2)
tbl2

</code></pre>

<hr>
<h2 id='summarize_rows'>summarize_rows</h2><span id='topic+summarize_rows'></span>

<h3>Description</h3>

<p><code>summarize_rows</code> is deprecated in favor of <code>make_row_df</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_rows(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_rows_+3A_obj">obj</code></td>
<td>
<p><code>VTableTree</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame summarizing the rows in <code>obj</code>.
</p>

<hr>
<h2 id='table_shell'>Table shells</h2><span id='topic+table_shell'></span><span id='topic+table_shell_str'></span>

<h3>Description</h3>

<p>A table shell is a rendering of the table which maintains the structure, but does not
display the values, rather displaying the formatting instructions for each cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_shell(
  tt,
  widths = NULL,
  col_gap = 3,
  hsep = default_hsep(),
  tf_wrap = FALSE,
  max_width = NULL
)

table_shell_str(
  tt,
  widths = NULL,
  col_gap = 3,
  hsep = default_hsep(),
  tf_wrap = FALSE,
  max_width = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_shell_+3A_tt">tt</code></td>
<td>
<p><code>TableTree</code> (or related class). A <code>TableTree</code> object representing a
populated table.</p>
</td></tr>
<tr><td><code id="table_shell_+3A_widths">widths</code></td>
<td>
<p>numeric (or  <code>NULL</code>). (proposed) widths for the columns
of <code>x</code>. The expected length  of this numeric vector can be
retrieved with  <code>ncol() + 1</code>  as the  column of row  names must
also be considered.</p>
</td></tr>
<tr><td><code id="table_shell_+3A_col_gap">col_gap</code></td>
<td>
<p>numeric(1). Space (in characters) between columns</p>
</td></tr>
<tr><td><code id="table_shell_+3A_hsep">hsep</code></td>
<td>
<p>character(1). Characters to repeat to create
header/body separator line. If <code>NULL</code>, the object value will be
used. If <code>" "</code>, an empty separator will be printed. Check <code><a href="formatters.html#topic+default_hsep">default_hsep()</a></code>
for more information.</p>
</td></tr>
<tr><td><code id="table_shell_+3A_tf_wrap">tf_wrap</code></td>
<td>
<p>logical(1). Should  the texts for  title, subtitle,
and footnotes be wrapped?</p>
</td></tr>
<tr><td><code id="table_shell_+3A_max_width">max_width</code></td>
<td>
<p>integer(1), character(1) or <code>NULL</code>. Width that title
and   footer   (including   footnotes)  materials   should   be
word-wrapped to. If <code>NULL</code>, it is  set to the current print width
of the  session (<code>getOption("width")</code>). If set to <code>"auto"</code>,
the width of the table (plus any table inset) is used. Ignored
completely if <code>tf_wrap</code> is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>for <code>table_shell_str</code> the string representing the table shell, for <code>table_shell</code>,
<code>NULL</code>, as the function is called for the side effect of printing the shell to the console
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

iris2 &lt;- iris %&gt;%
  group_by(Species) %&gt;%
  mutate(group = as.factor(rep_len(c("a", "b"), length.out = n()))) %&gt;%
  ungroup()

lyt &lt;- basic_table() %&gt;%
  split_cols_by("Species") %&gt;%
  split_cols_by("group") %&gt;%
  analyze(c("Sepal.Length", "Petal.Width"), afun = list_wrap_x(summary), format = "xx.xx")

tbl &lt;- build_table(lyt, iris2)
table_shell(tbl)
</code></pre>

<hr>
<h2 id='table_structure'>Summarize Table</h2><span id='topic+table_structure'></span>

<h3>Description</h3>

<p>Summarize Table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_structure(x, detail = c("subtable", "row"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_structure_+3A_x">x</code></td>
<td>
<p>a table object</p>
</td></tr>
<tr><td><code id="table_structure_+3A_detail">detail</code></td>
<td>
<p>either <code>row</code> or <code>subtable</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>currently no return value. Called for the side-effect of printing a
row- or subtable-structure summary of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

iris2 &lt;- iris %&gt;%
  group_by(Species) %&gt;%
  mutate(group = as.factor(rep_len(c("a", "b"), length.out = n()))) %&gt;%
  ungroup()

lyt &lt;- basic_table() %&gt;%
  split_cols_by("Species") %&gt;%
  split_cols_by("group") %&gt;%
  analyze(c("Sepal.Length", "Petal.Width"),
    afun = list_wrap_x(summary),
    format = "xx.xx"
  )

tbl &lt;- build_table(lyt, iris2)
tbl

row_paths(tbl)

table_structure(tbl)

table_structure(tbl, detail = "row")
</code></pre>

<hr>
<h2 id='top_left'>Top Left Material (Experimental)</h2><span id='topic+top_left'></span><span id='topic+top_left+2CVTableTree-method'></span><span id='topic+top_left+2CInstantiatedColumnInfo-method'></span><span id='topic+top_left+2CPreDataTableLayouts-method'></span><span id='topic+top_left+3C-'></span><span id='topic+top_left+3C-+2CVTableTree-method'></span><span id='topic+top_left+3C-+2CInstantiatedColumnInfo-method'></span><span id='topic+top_left+3C-+2CPreDataTableLayouts-method'></span>

<h3>Description</h3>

<p>A <code>TableTree</code> object can have <em>top left material</em> which is a sequence
of strings which are printed in the area of the table between the column header display
and the label of the first row.  These functions access and modify that material.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>top_left(obj)

## S4 method for signature 'VTableTree'
top_left(obj)

## S4 method for signature 'InstantiatedColumnInfo'
top_left(obj)

## S4 method for signature 'PreDataTableLayouts'
top_left(obj)

top_left(obj) &lt;- value

## S4 replacement method for signature 'VTableTree'
top_left(obj) &lt;- value

## S4 replacement method for signature 'InstantiatedColumnInfo'
top_left(obj) &lt;- value

## S4 replacement method for signature 'PreDataTableLayouts'
top_left(obj) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="top_left_+3A_obj">obj</code></td>
<td>
<p>ANY. The object for the accessor to access or modify</p>
</td></tr>
<tr><td><code id="top_left_+3A_value">value</code></td>
<td>
<p>The new value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector representing the top-left material of <code>obj</code> (or
<code>obj</code> after modification, in the case of the setter).
</p>

<hr>
<h2 id='tostring'>Convert an <code>rtable</code> object to a string</h2><span id='topic+tostring'></span><span id='topic+toString+2CVTableTree-method'></span>

<h3>Description</h3>

<p>Transform a complex object into a string representation ready
to be printed or written to a plain-text file
</p>
<p>All objects that are printed to console pass by <code>toString</code>. This function allows
fundamental formatting specifications for the final output, like column widths and
relative wrapping (<code>width</code>), title and footer wrapping (<code>tf_wrap = TRUE</code> and
<code>max_width</code>), or horizontal separator character (e.g. <code>hsep = "+"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'VTableTree'
toString(
  x,
  widths = NULL,
  col_gap = 3,
  hsep = horizontal_sep(x),
  indent_size = 2,
  tf_wrap = FALSE,
  max_width = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tostring_+3A_x">x</code></td>
<td>
<p>ANY. Object to be prepared for rendering.</p>
</td></tr>
<tr><td><code id="tostring_+3A_widths">widths</code></td>
<td>
<p>numeric (or  <code>NULL</code>). (proposed) widths for the columns
of <code>x</code>. The expected length  of this numeric vector can be
retrieved with  <code>ncol() + 1</code>  as the  column of row  names must
also be considered.</p>
</td></tr>
<tr><td><code id="tostring_+3A_col_gap">col_gap</code></td>
<td>
<p>numeric(1). Space (in characters) between columns</p>
</td></tr>
<tr><td><code id="tostring_+3A_hsep">hsep</code></td>
<td>
<p>character(1). Characters to repeat to create
header/body separator line. If <code>NULL</code>, the object value will be
used. If <code>" "</code>, an empty separator will be printed. Check <code><a href="formatters.html#topic+default_hsep">default_hsep()</a></code>
for more information.</p>
</td></tr>
<tr><td><code id="tostring_+3A_indent_size">indent_size</code></td>
<td>
<p>numeric(1). Number of spaces to use per indent level.
Defaults to 2</p>
</td></tr>
<tr><td><code id="tostring_+3A_tf_wrap">tf_wrap</code></td>
<td>
<p>logical(1). Should  the texts for  title, subtitle,
and footnotes be wrapped?</p>
</td></tr>
<tr><td><code id="tostring_+3A_max_width">max_width</code></td>
<td>
<p>integer(1), character(1) or <code>NULL</code>. Width that title
and   footer   (including   footnotes)  materials   should   be
word-wrapped to. If <code>NULL</code>, it is  set to the current print width
of the  session (<code>getOption("width")</code>). If set to <code>"auto"</code>,
the width of the table (plus any table inset) is used. Ignored
completely if <code>tf_wrap</code> is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Manual insertion of newlines is not supported when <code>tf_wrap</code> is on
and will result in a warning and undefined wrapping behavior. Passing
vectors of already split strings remains supported, however in this
case each string is word-wrapped separately with the behavior
described above.
</p>


<h3>Value</h3>

<p>a string representation of <code>x</code> as it appears when printed.
</p>


<h3>See Also</h3>

<p><code><a href="formatters.html#topic+wrap_string">wrap_string()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

iris2 &lt;- iris %&gt;%
  group_by(Species) %&gt;%
  mutate(group = as.factor(rep_len(c("a", "b"), length.out = n()))) %&gt;%
  ungroup()

lyt &lt;- basic_table() %&gt;%
  split_cols_by("Species") %&gt;%
  split_cols_by("group") %&gt;%
  analyze(c("Sepal.Length", "Petal.Width"), afun = list_wrap_x(summary), format = "xx.xx")

tbl &lt;- build_table(lyt, iris2)

cat(toString(tbl, col_gap = 3))
</code></pre>

<hr>
<h2 id='tree_children'>Retrieve or set the direct children of a Tree-style object</h2><span id='topic+tree_children'></span><span id='topic+tree_children+3C-'></span>

<h3>Description</h3>

<p>Retrieve or set the direct children of a Tree-style object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_children(x)

tree_children(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_children_+3A_x">x</code></td>
<td>
<p>An object with a Tree structure</p>
</td></tr>
<tr><td><code id="tree_children_+3A_value">value</code></td>
<td>
<p>New list of children.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of direct children of <code>x</code>
</p>

<hr>
<h2 id='trim_levels_in_facets'>Trim Levels of Another Variable From Each Facet (Postprocessing split step)</h2><span id='topic+trim_levels_in_facets'></span>

<h3>Description</h3>

<p>Trim Levels of Another Variable From Each Facet (Postprocessing split step)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_levels_in_facets(innervar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_levels_in_facets_+3A_innervar">innervar</code></td>
<td>
<p>character. The variable(s) to trim (remove
unobserved levels) independently within each facet.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function suitable for use in the <code>pre</code>
(list) argument of <code>make_split_fun</code>
</p>


<h3>See Also</h3>

<p>make_split_fun
</p>
<p>Other make_custom_split: 
<code><a href="#topic+add_combo_facet">add_combo_facet</a>()</code>,
<code><a href="#topic+drop_facet_levels">drop_facet_levels</a>()</code>,
<code><a href="#topic+make_split_fun">make_split_fun</a>()</code>,
<code><a href="#topic+make_split_result">make_split_result</a>()</code>
</p>

<hr>
<h2 id='trim_levels_to_map'>Trim Levels to map</h2><span id='topic+trim_levels_to_map'></span>

<h3>Description</h3>

<p>This split function constructor creates a split function which trims
levels of a variable to reflect restrictions on the possible
combinations of two or more variables which are split by
(along the same axis) within a layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_levels_to_map(map = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_levels_to_map_+3A_map">map</code></td>
<td>
<p>data.frame. A data.frame defining allowed combinations of
variables. Any combination at the level of this split not present in the
map will be removed from the data, both for the variable being split and
those present in the data but not associated with this split or any parents
of it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When splitting occurs, the map is subset to the values of all
previously performed splits. The levels of the variable being split are
then pruned to only those still present within this subset of the map
representing the current hierarchical splitting context.
</p>
<p>Splitting is then performed via the <code><a href="#topic+keep_split_levels">keep_split_levels</a></code> split
function.
</p>
<p>Each resulting element of the partition is then further trimmed by pruning
values of any remaining variables specified in the map to those values
allowed under the combination of the previous and current split.
</p>


<h3>Value</h3>

<p>a fun
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trim_levels_in_group">trim_levels_in_group()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>map &lt;- data.frame(
  LBCAT = c("CHEMISTRY", "CHEMISTRY", "CHEMISTRY", "IMMUNOLOGY"),
  PARAMCD = c("ALT", "CRP", "CRP", "IGA"),
  ANRIND = c("LOW", "LOW", "HIGH", "HIGH"),
  stringsAsFactors = FALSE
)

lyt &lt;- basic_table() %&gt;%
  split_rows_by("LBCAT") %&gt;%
  split_rows_by("PARAMCD", split_fun = trim_levels_to_map(map = map)) %&gt;%
  analyze("ANRIND")
tbl &lt;- build_table(lyt, ex_adlb)
</code></pre>

<hr>
<h2 id='trim_rows'>Trim rows from a populated table without regard for table structure</h2><span id='topic+trim_rows'></span>

<h3>Description</h3>

<p>Trim rows from a populated table without regard for table structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_rows(tt, criteria = all_zero_or_na)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_rows_+3A_tt">tt</code></td>
<td>
<p><code>TableTree</code> (or related class). A <code>TableTree</code> object representing a
populated table.</p>
</td></tr>
<tr><td><code id="trim_rows_+3A_criteria">criteria</code></td>
<td>
<p>function. Function which takes a <code>TableRow</code> object and returns
<code>TRUE</code> if that row should be removed. Defaults to
<code><a href="#topic+all_zero_or_na">all_zero_or_na</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will be deprecated in the future in favor of the more
elegant and versatile <code><a href="#topic+prune_table">prune_table()</a></code> function which can perform the
same function as <code>trim_rows()</code> but is more powerful as it takes table
structure into account.
</p>


<h3>Value</h3>

<p>The table with rows that have only NA or 0 cell values removed
</p>


<h3>Note</h3>

<p>Visible <code>LabelRow</code>s are including in this trimming, which can lead
to either all label rows being trimmed or label rows remaining when all
data rows have been trimmed, depending on what <code>criteria</code> returns when
called on a <code>LabelRow</code> object. To avoid this, use the
structurally-aware <code><a href="#topic+prune_table">prune_table</a></code> machinery instead.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prune_table">prune_table()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adsl &lt;- ex_adsl
levels(adsl$SEX) &lt;- c(levels(ex_adsl$SEX), "OTHER")

tbl_to_trim &lt;- basic_table() %&gt;%
  analyze("BMRKR1") %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("SEX") %&gt;%
  summarize_row_groups() %&gt;%
  split_rows_by("STRATA1") %&gt;%
  summarize_row_groups() %&gt;%
  analyze("AGE") %&gt;%
  build_table(adsl)

tbl_to_trim %&gt;% trim_rows()

tbl_to_trim %&gt;% trim_rows(all_zero)

</code></pre>

<hr>
<h2 id='trim_zero_rows'>Trim Zero Rows</h2><span id='topic+trim_zero_rows'></span>

<h3>Description</h3>

<p>Trim Zero Rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_zero_rows(tbl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_zero_rows_+3A_tbl">tbl</code></td>
<td>
<p>table object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>rtable</code> object
</p>

<hr>
<h2 id='tt_at_path'>Get or set table elements at specified path</h2><span id='topic+tt_at_path'></span><span id='topic+tt_at_path+3C-'></span>

<h3>Description</h3>

<p>Get or set table elements at specified path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tt_at_path(tt, path, ...)

tt_at_path(tt, path, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tt_at_path_+3A_tt">tt</code></td>
<td>
<p><code>TableTree</code> (or related class). A <code>TableTree</code> object representing a
populated table.</p>
</td></tr>
<tr><td><code id="tt_at_path_+3A_path">path</code></td>
<td>
<p>character. A vector path for a position within the structure of a
<code>tabletree</code>. Each element represents a subsequent choice amongst the children
of the previous choice.</p>
</td></tr>
<tr><td><code id="tt_at_path_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
<tr><td><code id="tt_at_path_+3A_value">value</code></td>
<td>
<p>The new value</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Setting <code>NULL</code> at a defined path removes the corresponding sub table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Accessing sub table.
lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("SEX") %&gt;%
  split_rows_by("BMRKR2") %&gt;%
  analyze("AGE")

tbl &lt;- build_table(lyt, ex_adsl) %&gt;% prune_table()
sub_tbl &lt;- tt_at_path(tbl, path = c("SEX", "F", "BMRKR2"))

# Removing sub table.
tbl2 &lt;- tbl
tt_at_path(tbl2, path = c("SEX", "F")) &lt;- NULL
tbl2

# Setting sub table.
lyt3 &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_rows_by("SEX") %&gt;%
  analyze("BMRKR2")

tbl3 &lt;- build_table(lyt3, ex_adsl) %&gt;% prune_table()

tt_at_path(tbl3, path = c("SEX", "F", "BMRKR2")) &lt;- sub_tbl
tbl3

</code></pre>

<hr>
<h2 id='tt_to_flextable'>Create a <code>FlexTable</code> from an <code>rtables</code> table</h2><span id='topic+tt_to_flextable'></span><span id='topic+theme_docx_default'></span>

<h3>Description</h3>

<p>Principally used for export (<code><a href="#topic+export_as_docx">export_as_docx()</a></code>), this function produces a <code>flextable</code>
from an <code>rtables</code> table. If <code>theme = NULL</code>, <code>rtables</code>-like style will be used. Otherwise,
<code><a href="#topic+theme_docx_default">theme_docx_default()</a></code> will produce a <code>.docx</code>-friendly table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tt_to_flextable(
  tt,
  theme = theme_docx_default(tt),
  border = flextable::fp_border_default(width = 0.5),
  indent_size = NULL,
  titles_as_header = TRUE,
  footers_as_text = FALSE,
  counts_in_newline = FALSE,
  paginate = FALSE,
  lpp = NULL,
  cpp = NULL,
  ...,
  colwidths = propose_column_widths(matrix_form(tt, indent_rownames = TRUE)),
  tf_wrap = !is.null(cpp),
  max_width = cpp,
  total_width = 10
)

theme_docx_default(
  tt = NULL,
  font = "Arial",
  font_size = 9,
  bold = c("header", "content_rows", "label_rows"),
  bold_manual = NULL,
  border = flextable::fp_border_default(width = 0.5)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tt_to_flextable_+3A_tt">tt</code></td>
<td>
<p><code>TableTree</code> (or related class). A <code>TableTree</code> object representing a
populated table.</p>
</td></tr>
<tr><td><code id="tt_to_flextable_+3A_theme">theme</code></td>
<td>
<p>function(1). Defaults to <code>theme_docx_default(tt)</code>. It expects a
a theme function that is designed internally as a function of a <code>flextable</code> object
and changes its layout and style. If set to <code>NULL</code>, it will produce a table similar
to <code>rtables</code> default.</p>
</td></tr>
<tr><td><code id="tt_to_flextable_+3A_border">border</code></td>
<td>
<p><code>officer</code> border object. Defaults to <code>officer::fp_border(width = 0.5)</code>.</p>
</td></tr>
<tr><td><code id="tt_to_flextable_+3A_indent_size">indent_size</code></td>
<td>
<p>integer(1). If <code>NULL</code>, the default indent size of the table (see
<code><a href="formatters.html#topic+matrix_form">matrix_form()</a></code> <code>indent_size</code>) is used. To work with <code>docx</code>, any size is multiplied
by 2 mm (5.67 pt) as default.</p>
</td></tr>
<tr><td><code id="tt_to_flextable_+3A_titles_as_header">titles_as_header</code></td>
<td>
<p>logical(1). Defaults to <code>TRUE</code> for <code><a href="#topic+tt_to_flextable">tt_to_flextable()</a></code>, so the
table is self-contained as it makes additional header rows for <code><a href="formatters.html#topic+main_title">main_title()</a></code>
string and <code><a href="formatters.html#topic+subtitles">subtitles()</a></code> character vector (one per element). <code>FALSE</code> is suggested
for <code><a href="#topic+export_as_docx">export_as_docx()</a></code>. This adds titles and subtitles as a text paragraph above
the table. Same style is applied.</p>
</td></tr>
<tr><td><code id="tt_to_flextable_+3A_footers_as_text">footers_as_text</code></td>
<td>
<p>logical(1). Defaults to <code>FALSE</code> for <code><a href="#topic+tt_to_flextable">tt_to_flextable()</a></code>, so
the table is self-contained with the flextable definition of footnotes. <code>TRUE</code> is
used for <code><a href="#topic+export_as_docx">export_as_docx()</a></code> to add the footers as a new paragraph after the table.
Same style is applied, but with a smaller font.</p>
</td></tr>
<tr><td><code id="tt_to_flextable_+3A_counts_in_newline">counts_in_newline</code></td>
<td>
<p>logical(1). Defaults to <code>FALSE</code>. In <code>rtables</code> text printing
(<code><a href="formatters.html#topic+tostring">formatters::toString()</a></code>), the column counts, i.e. <code>(N=xx)</code>, is always on a new line.
We noticed that for <code>docx</code> exports could be necessary to have it on the same line.</p>
</td></tr>
<tr><td><code id="tt_to_flextable_+3A_paginate">paginate</code></td>
<td>
<p>logical(1). If you need <code>.docx</code> export and you use
<code>export_as_docx</code>, we suggest relying on <code>word</code> pagination system. Cooperation
between the two mechanisms is not guaranteed. This option splits <code>tt</code> in different
&quot;pages&quot; as multiple <code>flextables</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tt_to_flextable_+3A_lpp">lpp</code></td>
<td>
<p>numeric. Maximum lines per page including (re)printed header and context rows</p>
</td></tr>
<tr><td><code id="tt_to_flextable_+3A_cpp">cpp</code></td>
<td>
<p>numeric(1) or NULL. Width (in characters) of the pages for
horizontal pagination. <code>NA</code> (the default) indicates <code>cpp</code> should be inferred from
the page size; <code>NULL</code> indicates no horizontal pagination should be done
regardless of page size.</p>
</td></tr>
<tr><td><code id="tt_to_flextable_+3A_...">...</code></td>
<td>
<p>Passed on to methods or tabulation functions.</p>
</td></tr>
<tr><td><code id="tt_to_flextable_+3A_colwidths">colwidths</code></td>
<td>
<p>numeric vector. Column widths for use with vertical pagination.</p>
</td></tr>
<tr><td><code id="tt_to_flextable_+3A_tf_wrap">tf_wrap</code></td>
<td>
<p>logical(1). Should  the texts for  title, subtitle,
and footnotes be wrapped?</p>
</td></tr>
<tr><td><code id="tt_to_flextable_+3A_max_width">max_width</code></td>
<td>
<p>integer(1), character(1) or <code>NULL</code>. Width that title
and   footer   (including   footnotes)  materials   should   be
word-wrapped to. If <code>NULL</code>, it is  set to the current print width
of the  session (<code>getOption("width")</code>). If set to <code>"auto"</code>,
the width of the table (plus any table inset) is used. Ignored
completely if <code>tf_wrap</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tt_to_flextable_+3A_total_width">total_width</code></td>
<td>
<p>numeric(1). Total width in inches for the resulting
<code>flextable(s)</code>. Defaults to 10.</p>
</td></tr>
<tr><td><code id="tt_to_flextable_+3A_font">font</code></td>
<td>
<p>character(1). Defaults to <code>"Arial"</code>. If the font is not vailable, <code>flextable</code>
default is used.</p>
</td></tr>
<tr><td><code id="tt_to_flextable_+3A_font_size">font_size</code></td>
<td>
<p>integer(1). Positive integerish value that defaults to 9.</p>
</td></tr>
<tr><td><code id="tt_to_flextable_+3A_bold">bold</code></td>
<td>
<p>character vector. It can be any combination of <code>c("header", "content_rows", "label_rows")</code>. The first one renders all column names bold (not <code>topleft</code> content).
Second and third option use <code><a href="formatters.html#topic+make_row_df">make_row_df()</a></code> to render content or/and label
rows as bold.</p>
</td></tr>
<tr><td><code id="tt_to_flextable_+3A_bold_manual">bold_manual</code></td>
<td>
<p>named list. List of indexes lists. See example for needed structure.
Accepted groupings/names are <code>c("header", "body")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>flextable</code> object.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>theme_docx_default()</code>: main theme function for <code><a href="#topic+export_as_docx">export_as_docx()</a></code>
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+export_as_docx">export_as_docx()</a></code>
</p>
<p><code><a href="#topic+export_as_docx">export_as_docx()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>analysisfun &lt;- function(x, ...) {
  in_rows(
    row1 = 5,
    row2 = c(1, 2),
    .row_footnotes = list(row1 = "row 1 - row footnote"),
    .cell_footnotes = list(row2 = "row 2 - cell footnote")
  )
}

lyt &lt;- basic_table(
  title = "Title says Whaaaat", subtitles = "Oh, ok.",
  main_footer = "ha HA! Footer!"
) %&gt;%
  split_cols_by("ARM") %&gt;%
  analyze("AGE", afun = analysisfun)

tbl &lt;- build_table(lyt, ex_adsl)
# rtables style
tt_to_flextable(tbl, theme = NULL)

tt_to_flextable(tbl, theme = theme_docx_default(tbl, font_size = 7))

# Custom theme
special_bold &lt;- list(
  "header" = list("i" = 1, "j" = c(1, 3)),
  "body" = list("i" = c(1, 2), "j" = 1)
)
custom_theme &lt;- theme_docx_default(tbl,
  font_size = 10,
  font = "Brush Script MT",
  border = flextable::fp_border_default(color = "pink", width = 2),
  bold = NULL,
  bold_manual = special_bold
)
tt_to_flextable(tbl,
  border = flextable::fp_border_default(color = "pink", width = 2),
  theme = custom_theme
)

</code></pre>

<hr>
<h2 id='update_ref_indexing'>Update footnote indexes on a built table</h2><span id='topic+update_ref_indexing'></span>

<h3>Description</h3>

<p>Re-indexes footnotes within a built table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_ref_indexing(tt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_ref_indexing_+3A_tt">tt</code></td>
<td>
<p><code>TableTree</code> (or related class). A <code>TableTree</code> object representing a
populated table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After adding or removing  referential footnotes manually,
or  after subsetting  a table,  the reference  indexes (i.e.  the
number associated  with specific  footnotes) may  be incorrect.
This function recalculates these based on the full table.
</p>


<h3>Note</h3>

<p>In the future this should not generally need to be called
manually.
</p>

<hr>
<h2 id='validate_table_struct'>Validate and Assert valid table structure (Experimental).</h2><span id='topic+validate_table_struct'></span><span id='topic+assert_valid_table'></span>

<h3>Description</h3>

<p>Validate and Assert valid table structure (Experimental).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_table_struct(tt)

assert_valid_table(tt, warn_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_table_struct_+3A_tt">tt</code></td>
<td>
<p><code>TableTree</code>
</p>
<p>A <code>TableTree</code> (<code>rtables</code>-built table) is considered degenerate if
</p>

<ol>
<li><p>it contains no subtables or data rows (content rows do not count)
</p>
</li>
<li><p>it contains a subtable which is degenerate by the criterion above
</p>
</li></ol>

<p><code>validate_table_struct</code> assesses whether <code>tt</code> has a valid (non-degenerate)
structure.
</p>
<p><code>assert_valid_table</code> asserts a table must have a valid structure,
and throws an informative error (the default) or warning (if <code>warn_only</code>
is <code>TRUE</code>) if the table is degenerate (has invalid structure or
contains one or more invalid substructures</p>
</td></tr>
<tr><td><code id="validate_table_struct_+3A_warn_only">warn_only</code></td>
<td>
<p>logical(1). Should a warning be thrown instead of an error?
Defaults to <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>for <code>validate_table_struct</code> a logical value indicating valid structure;
<code>assert_valid_table</code> is called for its side-effect of throwing an error
or warning for degenerate tables.
</p>


<h3>Note</h3>

<p>This function is experimental and the exact text of the warning/error
is subject to change in future releases.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>validate_table_struct(rtable("hahaha"))
## Not run: 
assert_valid_table(rtable("oops"))

## End(Not run)

</code></pre>

<hr>
<h2 id='value_formats'>Value Formats</h2><span id='topic+value_formats'></span><span id='topic+value_formats+2CANY-method'></span><span id='topic+value_formats+2CTableRow-method'></span><span id='topic+value_formats+2CLabelRow-method'></span><span id='topic+value_formats+2CVTableTree-method'></span>

<h3>Description</h3>

<p>Returns a matrix of formats for the cells in a table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>value_formats(obj, default = obj_format(obj))

## S4 method for signature 'ANY'
value_formats(obj, default = obj_format(obj))

## S4 method for signature 'TableRow'
value_formats(obj, default = obj_format(obj))

## S4 method for signature 'LabelRow'
value_formats(obj, default = obj_format(obj))

## S4 method for signature 'VTableTree'
value_formats(obj, default = obj_format(obj))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="value_formats_+3A_obj">obj</code></td>
<td>
<p>A table or row object.</p>
</td></tr>
<tr><td><code id="value_formats_+3A_default">default</code></td>
<td>
<p><code>FormatSpec</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix (storage mode list) containing the effective format for each
cell position in the table (including 'virtual' cells implied by label rows,
whose formats are always <code>NULL</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lyt &lt;- basic_table() %&gt;%
  split_rows_by("RACE", split_fun = keep_split_levels(c("ASIAN", "WHITE"))) %&gt;%
  analyze("AGE")

tbl &lt;- build_table(lyt, DM)
value_formats(tbl)
</code></pre>

<hr>
<h2 id='VarLevelSplit-class'>Split on levels within a variable</h2><span id='topic+VarLevelSplit-class'></span><span id='topic+VarLevelSplit'></span><span id='topic+VarLevWBaselineSplit'></span>

<h3>Description</h3>

<p>Split on levels within a variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VarLevelSplit(
  var,
  split_label,
  labels_var = NULL,
  cfun = NULL,
  cformat = NULL,
  cna_str = NA_character_,
  split_fun = NULL,
  split_format = NULL,
  split_na_str = NA_character_,
  valorder = NULL,
  split_name = var,
  child_labels = c("default", "visible", "hidden"),
  extra_args = list(),
  indent_mod = 0L,
  label_pos = c("topleft", "hidden", "visible"),
  cindent_mod = 0L,
  cvar = "",
  cextra_args = list(),
  page_prefix = NA_character_,
  section_div = NA_character_
)

VarLevWBaselineSplit(
  var,
  ref_group,
  labels_var = var,
  split_label,
  split_fun = NULL,
  label_fstr = "%s - %s",
  cfun = NULL,
  cformat = NULL,
  cna_str = NA_character_,
  cvar = "",
  split_format = NULL,
  split_na_str = NA_character_,
  valorder = NULL,
  split_name = var,
  extra_args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VarLevelSplit-class_+3A_var">var</code></td>
<td>
<p>string, variable name</p>
</td></tr>
<tr><td><code id="VarLevelSplit-class_+3A_split_label">split_label</code></td>
<td>
<p>string. Label string to be associated with the table
generated by the split. Not to be confused with labels assigned to each
child (which are based on the data and type of split during tabulation).</p>
</td></tr>
<tr><td><code id="VarLevelSplit-class_+3A_labels_var">labels_var</code></td>
<td>
<p>string, name of variable containing labels to be displayed
for the values of <code>var</code></p>
</td></tr>
<tr><td><code id="VarLevelSplit-class_+3A_cfun">cfun</code></td>
<td>
<p>list/function/NULL. tabulation function(s) for creating content
rows. Must accept <code>x</code> or <code>df</code> as first parameter. Must accept
<code>labelstr</code> as the second argument. Can optionally accept all optional
arguments accepted by analysis functions. See <code><a href="#topic+analyze">analyze</a></code>.</p>
</td></tr>
<tr><td><code id="VarLevelSplit-class_+3A_cformat">cformat</code></td>
<td>
<p>format spec. Format for content rows</p>
</td></tr>
<tr><td><code id="VarLevelSplit-class_+3A_cna_str">cna_str</code></td>
<td>
<p>character. NA string for use with <code>cformat</code> for content
table.</p>
</td></tr>
<tr><td><code id="VarLevelSplit-class_+3A_split_fun">split_fun</code></td>
<td>
<p>function/NULL. custom splitting function See
<code><a href="#topic+custom_split_funs">custom_split_funs</a></code></p>
</td></tr>
<tr><td><code id="VarLevelSplit-class_+3A_split_format">split_format</code></td>
<td>
<p><code>FormatSpec</code>. Default format associated with the split
being created.</p>
</td></tr>
<tr><td><code id="VarLevelSplit-class_+3A_split_na_str">split_na_str</code></td>
<td>
<p>character. NA string vector for use with <code>split_format</code>.</p>
</td></tr>
<tr><td><code id="VarLevelSplit-class_+3A_valorder">valorder</code></td>
<td>
<p>character vector. Order that the split children should appear
in resulting table.</p>
</td></tr>
<tr><td><code id="VarLevelSplit-class_+3A_split_name">split_name</code></td>
<td>
<p>string. Name associated with this split (for pathing, etc)</p>
</td></tr>
<tr><td><code id="VarLevelSplit-class_+3A_child_labels">child_labels</code></td>
<td>
<p>string. One of <code>"default"</code>, <code>"visible"</code>,
<code>"hidden"</code>. What should the display behavior be for the  labels (i.e.
label rows) of the children of this split. Defaults to <code>"default"</code>
which flags the label row as visible only if the child has 0 content rows.</p>
</td></tr>
<tr><td><code id="VarLevelSplit-class_+3A_extra_args">extra_args</code></td>
<td>
<p>list. Extra arguments to be passed to the tabulation
function. Element position in the list corresponds to the children of this
split. Named elements in the child-specific lists are ignored if they do
not match a formal argument of the tabulation function.</p>
</td></tr>
<tr><td><code id="VarLevelSplit-class_+3A_indent_mod">indent_mod</code></td>
<td>
<p>numeric. Modifier for the default indent position for the
structure created by this function(subtable, content table, or row)
<em>and all of that structure's children</em>. Defaults to 0, which
corresponds to the unmodified default behavior.</p>
</td></tr>
<tr><td><code id="VarLevelSplit-class_+3A_label_pos">label_pos</code></td>
<td>
<p>character(1). Location the variable label should be
displayed, Accepts <code>"hidden"</code> (default for non-analyze row splits), <code>"visible"</code>,
<code>"topleft"</code>, and - for analyze splits only - <code>"default"</code>.  For analyze calls,
<code>"default"</code> indicates that the variable should be visible if and only if
multiple variables are analyzed at the same level of nesting.</p>
</td></tr>
<tr><td><code id="VarLevelSplit-class_+3A_cindent_mod">cindent_mod</code></td>
<td>
<p>numeric(1). The indent modifier for the content tables
generated by this split.</p>
</td></tr>
<tr><td><code id="VarLevelSplit-class_+3A_cvar">cvar</code></td>
<td>
<p>character(1). The variable, if any, which the content function
should accept. Defaults to NA.</p>
</td></tr>
<tr><td><code id="VarLevelSplit-class_+3A_cextra_args">cextra_args</code></td>
<td>
<p>list. Extra arguments to be passed to the content function
when tabulating row group summaries.</p>
</td></tr>
<tr><td><code id="VarLevelSplit-class_+3A_page_prefix">page_prefix</code></td>
<td>
<p>character(1). Prefix, to be appended with the split value,
when forcing pagination between the children of this split/table</p>
</td></tr>
<tr><td><code id="VarLevelSplit-class_+3A_section_div">section_div</code></td>
<td>
<p>character(1). String which should be repeated as a section
divider after each group defined by this split instruction, or
<code>NA_character_</code> (the default) for no section divider.</p>
</td></tr>
<tr><td><code id="VarLevelSplit-class_+3A_ref_group">ref_group</code></td>
<td>
<p>character. Value of <code>var</code> to be taken as the
ref_group/control to be compared against.</p>
</td></tr>
<tr><td><code id="VarLevelSplit-class_+3A_label_fstr">label_fstr</code></td>
<td>
<p>string. An <code>sprintf</code> style format string containing. For
non-comparison splits, it can contain  up to one <code>"%s"</code> which takes
the current split value and generates the row/column label.
Comparison-based splits it can contain up to two <code>"%s"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>VarLevelSplit</code> object.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>

<hr>
<h2 id='vars_in_layout'>List Variables required by a pre-data table layout</h2><span id='topic+vars_in_layout'></span><span id='topic+vars_in_layout+2CPreDataTableLayouts-method'></span><span id='topic+vars_in_layout+2CPreDataAxisLayout-method'></span><span id='topic+vars_in_layout+2CSplitVector-method'></span><span id='topic+vars_in_layout+2CSplit-method'></span><span id='topic+vars_in_layout+2CCompoundSplit-method'></span><span id='topic+vars_in_layout+2CManualSplit-method'></span>

<h3>Description</h3>

<p>List Variables required by a pre-data table layout
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vars_in_layout(lyt)

## S4 method for signature 'PreDataTableLayouts'
vars_in_layout(lyt)

## S4 method for signature 'PreDataAxisLayout'
vars_in_layout(lyt)

## S4 method for signature 'SplitVector'
vars_in_layout(lyt)

## S4 method for signature 'Split'
vars_in_layout(lyt)

## S4 method for signature 'CompoundSplit'
vars_in_layout(lyt)

## S4 method for signature 'ManualSplit'
vars_in_layout(lyt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vars_in_layout_+3A_lyt">lyt</code></td>
<td>
<p>The Layout (or a component thereof)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This will walk the  layout declaration and return a vector
of the  names of the unique  variables that are used  in any of
the following ways:
</p>

<ul>
<li><p>Variable being split on (directly or via cuts)
</p>
</li>
<li><p>Element of a Multi-variable column split
</p>
</li>
<li><p>Content variable
</p>
</li>
<li><p>Value-label variable
</p>
</li></ul>



<h3>Value</h3>

<p>A character vector containing the unique variables explicitly used in the layout (see Notes).
</p>


<h3>Note</h3>

<p>This function will not detect dependencies implicit in
analysis or summary functions which accept <code>x</code> or <code>df</code> and then
rely on the existence of particular variables not being split on/
analyzed.
</p>
<p>The order these variable names appear within the return vector
is undefined and should not be relied upon.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lyt &lt;- basic_table() %&gt;%
  split_cols_by("ARM") %&gt;%
  split_cols_by("SEX") %&gt;%
  summarize_row_groups(label_fstr = "Overall (N)") %&gt;%
  split_rows_by("RACE",
    split_label = "Ethnicity", labels_var = "ethn_lab",
    split_fun = drop_split_levels
  ) %&gt;%
  summarize_row_groups("RACE", label_fstr = "%s (n)") %&gt;%
  analyze("AGE", var_labels = "Age", afun = mean, format = "xx.xx")

vars_in_layout(lyt)

</code></pre>

<hr>
<h2 id='VarStaticCutSplit-class'>Splits for cutting by values of a numeric variable</h2><span id='topic+VarStaticCutSplit-class'></span><span id='topic+make_static_cut_split'></span><span id='topic+CumulativeCutSplit-class'></span><span id='topic+VarDynCutSplit-class'></span><span id='topic+VarDynCutSplit'></span>

<h3>Description</h3>

<p>Splits for cutting by values of a numeric variable
</p>
<p>Create static cut or static cumulative cut split
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_static_cut_split(
  var,
  split_label,
  cuts,
  cutlabels = NULL,
  cfun = NULL,
  cformat = NULL,
  cna_str = NA_character_,
  split_format = NULL,
  split_na_str = NA_character_,
  split_name = var,
  child_labels = c("default", "visible", "hidden"),
  extra_args = list(),
  indent_mod = 0L,
  cindent_mod = 0L,
  cvar = "",
  cextra_args = list(),
  label_pos = "visible",
  cumulative = FALSE,
  page_prefix = NA_character_,
  section_div = NA_character_
)

VarDynCutSplit(
  var,
  split_label,
  cutfun,
  cutlabelfun = function(x) NULL,
  cfun = NULL,
  cformat = NULL,
  cna_str = NA_character_,
  split_format = NULL,
  split_na_str = NA_character_,
  split_name = var,
  child_labels = c("default", "visible", "hidden"),
  extra_args = list(),
  cumulative = FALSE,
  indent_mod = 0L,
  cindent_mod = 0L,
  cvar = "",
  cextra_args = list(),
  label_pos = "visible",
  page_prefix = NA_character_,
  section_div = NA_character_
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VarStaticCutSplit-class_+3A_var">var</code></td>
<td>
<p>string, variable name</p>
</td></tr>
<tr><td><code id="VarStaticCutSplit-class_+3A_split_label">split_label</code></td>
<td>
<p>string. Label string to be associated with the table
generated by the split. Not to be confused with labels assigned to each
child (which are based on the data and type of split during tabulation).</p>
</td></tr>
<tr><td><code id="VarStaticCutSplit-class_+3A_cuts">cuts</code></td>
<td>
<p>numeric. Cuts to use</p>
</td></tr>
<tr><td><code id="VarStaticCutSplit-class_+3A_cutlabels">cutlabels</code></td>
<td>
<p>character (or NULL). Labels for the cuts</p>
</td></tr>
<tr><td><code id="VarStaticCutSplit-class_+3A_cfun">cfun</code></td>
<td>
<p>list/function/NULL. tabulation function(s) for creating content
rows. Must accept <code>x</code> or <code>df</code> as first parameter. Must accept
<code>labelstr</code> as the second argument. Can optionally accept all optional
arguments accepted by analysis functions. See <code><a href="#topic+analyze">analyze</a></code>.</p>
</td></tr>
<tr><td><code id="VarStaticCutSplit-class_+3A_cformat">cformat</code></td>
<td>
<p>format spec. Format for content rows</p>
</td></tr>
<tr><td><code id="VarStaticCutSplit-class_+3A_cna_str">cna_str</code></td>
<td>
<p>character. NA string for use with <code>cformat</code> for content
table.</p>
</td></tr>
<tr><td><code id="VarStaticCutSplit-class_+3A_split_format">split_format</code></td>
<td>
<p><code>FormatSpec</code>. Default format associated with the split
being created.</p>
</td></tr>
<tr><td><code id="VarStaticCutSplit-class_+3A_split_na_str">split_na_str</code></td>
<td>
<p>character. NA string vector for use with <code>split_format</code>.</p>
</td></tr>
<tr><td><code id="VarStaticCutSplit-class_+3A_split_name">split_name</code></td>
<td>
<p>string. Name associated with this split (for pathing, etc)</p>
</td></tr>
<tr><td><code id="VarStaticCutSplit-class_+3A_child_labels">child_labels</code></td>
<td>
<p>string. One of <code>"default"</code>, <code>"visible"</code>,
<code>"hidden"</code>. What should the display behavior be for the  labels (i.e.
label rows) of the children of this split. Defaults to <code>"default"</code>
which flags the label row as visible only if the child has 0 content rows.</p>
</td></tr>
<tr><td><code id="VarStaticCutSplit-class_+3A_extra_args">extra_args</code></td>
<td>
<p>list. Extra arguments to be passed to the tabulation
function. Element position in the list corresponds to the children of this
split. Named elements in the child-specific lists are ignored if they do
not match a formal argument of the tabulation function.</p>
</td></tr>
<tr><td><code id="VarStaticCutSplit-class_+3A_indent_mod">indent_mod</code></td>
<td>
<p>numeric. Modifier for the default indent position for the
structure created by this function(subtable, content table, or row)
<em>and all of that structure's children</em>. Defaults to 0, which
corresponds to the unmodified default behavior.</p>
</td></tr>
<tr><td><code id="VarStaticCutSplit-class_+3A_cindent_mod">cindent_mod</code></td>
<td>
<p>numeric(1). The indent modifier for the content tables
generated by this split.</p>
</td></tr>
<tr><td><code id="VarStaticCutSplit-class_+3A_cvar">cvar</code></td>
<td>
<p>character(1). The variable, if any, which the content function
should accept. Defaults to NA.</p>
</td></tr>
<tr><td><code id="VarStaticCutSplit-class_+3A_cextra_args">cextra_args</code></td>
<td>
<p>list. Extra arguments to be passed to the content function
when tabulating row group summaries.</p>
</td></tr>
<tr><td><code id="VarStaticCutSplit-class_+3A_label_pos">label_pos</code></td>
<td>
<p>character(1). Location the variable label should be
displayed, Accepts <code>"hidden"</code> (default for non-analyze row splits), <code>"visible"</code>,
<code>"topleft"</code>, and - for analyze splits only - <code>"default"</code>.  For analyze calls,
<code>"default"</code> indicates that the variable should be visible if and only if
multiple variables are analyzed at the same level of nesting.</p>
</td></tr>
<tr><td><code id="VarStaticCutSplit-class_+3A_cumulative">cumulative</code></td>
<td>
<p>logical. Should the cuts be treated as cumulative. Defaults
to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="VarStaticCutSplit-class_+3A_page_prefix">page_prefix</code></td>
<td>
<p>character(1). Prefix, to be appended with the split value,
when forcing pagination between the children of this split/table</p>
</td></tr>
<tr><td><code id="VarStaticCutSplit-class_+3A_section_div">section_div</code></td>
<td>
<p>character(1). String which should be repeated as a section
divider after each group defined by this split instruction, or
<code>NA_character_</code> (the default) for no section divider.</p>
</td></tr>
<tr><td><code id="VarStaticCutSplit-class_+3A_cutfun">cutfun</code></td>
<td>
<p>function. Function which accepts the <em>full vector</em> of
<code>var</code> values and returns cut points to be used (via <code>cut</code>) when
splitting data during tabulation</p>
</td></tr>
<tr><td><code id="VarStaticCutSplit-class_+3A_cutlabelfun">cutlabelfun</code></td>
<td>
<p>function. Function which returns either labels for the
cuts or NULL when passed the return value of <code>cutfun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>VarStaticCutSplit</code>, <code>CumulativeCutSplit</code> object for
<code>make_static_cut_split</code>, or a <code>VarDynCutSplit</code> object for
<code>VarDynCutSplit()</code>
</p>

<hr>
<h2 id='Viewer'>Display an <code><a href="#topic+rtable">rtable</a></code> object in the Viewer pane in RStudio or in a browser</h2><span id='topic+Viewer'></span>

<h3>Description</h3>

<p>The table will be displayed using the bootstrap styling for tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Viewer(x, y = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Viewer_+3A_x">x</code></td>
<td>
<p>object of class <code>rtable</code> or <code>shiny.tag</code> (defined in <code>htmltools</code> package)</p>
</td></tr>
<tr><td><code id="Viewer_+3A_y">y</code></td>
<td>
<p>optional second argument of same type as <code>x</code></p>
</td></tr>
<tr><td><code id="Viewer_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+as_html">as_html</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>not meaningful. Called for the side effect of opening a browser or viewer pane.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
  sl5 &lt;- factor(iris$Sepal.Length &gt; 5,
    levels = c(TRUE, FALSE),
    labels = c("S.L &gt; 5", "S.L &lt;= 5")
  )

  df &lt;- cbind(iris, sl5 = sl5)

  lyt &lt;- basic_table() %&gt;%
    split_cols_by("sl5") %&gt;%
    analyze("Sepal.Length")

  tbl &lt;- build_table(lyt, df)

  Viewer(tbl)
  Viewer(tbl, tbl)


  tbl2 &lt;- htmltools::tags$div(
    class = "table-responsive",
    as_html(tbl, class_table = "table")
  )

  Viewer(tbl, tbl2)
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
