<!DOCTYPE html><html><head><title>Help for package jackalope</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {jackalope}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#jackalope-package'><p>jackalope: A Swift, Versatile Phylogenomic and High-Throughput Sequencing Simulator</p></a></li>
<li><a href='#create_genome'><p>Create a reference genome.</p></a></li>
<li><a href='#create_haplotypes'><p>Create haplotypes from a reference genome.</p></a></li>
<li><a href='#evo_rates'><p>Table of evolutionary rates.</p></a></li>
<li><a href='#haplotypes'><p>An R6 Class Representing Haploid Variants</p></a></li>
<li><a href='#haps_functions'><p>Organize higher-level information for creating haplotypes.</p></a></li>
<li><a href='#haps_gtrees'><p>Organize information to create haplotypes using gene trees</p></a></li>
<li><a href='#haps_phylo'><p>Organize information to create haplotypes using phylogenetic tree(s)</p></a></li>
<li><a href='#haps_ssites'><p>Organize information to create haplotypes using segregating sites matrices</p></a></li>
<li><a href='#haps_theta'><p>Organize information to create haplotypes using theta parameter</p></a></li>
<li><a href='#haps_vcf'><p>Organize information to create haplotypes using a VCF file</p></a></li>
<li><a href='#illumina'><p>Create and write Illumina reads to FASTQ file(s).</p></a></li>
<li><a href='#indels'><p>Insertions and deletions (indels) specification</p></a></li>
<li><a href='#pacbio'><p>Create and write PacBio reads to FASTQ file(s).</p></a></li>
<li><a href='#read_fasta'><p>Read a fasta file.</p></a></li>
<li><a href='#ref_genome'><p>R6 Class Representing a Reference Genome</p></a></li>
<li><a href='#sub_models'><p>Construct necessary information for substitution models.</p></a></li>
<li><a href='#write_fasta'><p>Write a <code>ref_genome</code> or <code>haplotypes</code> object to a FASTA file.</p></a></li>
<li><a href='#write_vcf'><p>Write haplotype info from a <code>haplotypes</code> object to a VCF file.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Swift, Versatile Phylogenomic and High-Throughput Sequencing
Simulator</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Simply and efficiently
    simulates (i) variants from reference genomes and (ii) reads from both Illumina 
    <a href="https://www.illumina.com/">https://www.illumina.com/</a>
    and Pacific Biosciences (PacBio) <a href="https://www.pacb.com/">https://www.pacb.com/</a> platforms. 
    It can either read reference genomes from FASTA files or simulate new ones.
    Genomic variants can be simulated using summary statistics, phylogenies, 
    Variant Call Format (VCF) files, and coalescent simulations—the latter of which
    can include selection, recombination, and demographic fluctuations.
    'jackalope' can simulate single, paired-end, or mate-pair Illumina reads, 
    as well as PacBio reads.
    These simulations include sequencing errors, mapping qualities, multiplexing,
    and optical/polymerase chain reaction (PCR) duplicates.
    Simulating Illumina sequencing is based on ART
    by Huang et al. (2012) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtr708">doi:10.1093/bioinformatics/btr708</a>&gt;.
    PacBio sequencing simulation is based on 
    SimLoRD  by Stöcker et al. (2016) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtw286">doi:10.1093/bioinformatics/btw286</a>&gt;.
    All outputs can be written to standard file formats.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, R6, Rcpp (&ge; 0.12.11), zlibbioc</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppProgress, Rhtslib, zlibbioc</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>coala, knitr, markdown, rmarkdown, scrm, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/lucasnell/jackalope">https://github.com/lucasnell/jackalope</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lucasnell/jackalope/issues">https://github.com/lucasnell/jackalope/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-28 20:26:32 UTC; lucasnell</td>
</tr>
<tr>
<td>Author:</td>
<td>Lucas A. Nell <a href="https://orcid.org/0000-0003-3209-0517"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cph, aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lucas A. Nell &lt;lucnell@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-28 21:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='jackalope-package'>jackalope: A Swift, Versatile Phylogenomic and High-Throughput Sequencing Simulator</h2><span id='topic+jackalope'></span><span id='topic+jackalope-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Simply and efficiently simulates (i) variants from reference genomes and (ii) reads from both Illumina <a href="https://www.illumina.com/">https://www.illumina.com/</a> and Pacific Biosciences (PacBio) <a href="https://www.pacb.com/">https://www.pacb.com/</a> platforms. It can either read reference genomes from FASTA files or simulate new ones. Genomic variants can be simulated using summary statistics, phylogenies, Variant Call Format (VCF) files, and coalescent simulations—the latter of which can include selection, recombination, and demographic fluctuations. 'jackalope' can simulate single, paired-end, or mate-pair Illumina reads, as well as PacBio reads. These simulations include sequencing errors, mapping qualities, multiplexing, and optical/polymerase chain reaction (PCR) duplicates. Simulating Illumina sequencing is based on ART by Huang et al. (2012) <a href="https://doi.org/10.1093/bioinformatics/btr708">doi:10.1093/bioinformatics/btr708</a>. PacBio sequencing simulation is based on SimLoRD by Stöcker et al. (2016) <a href="https://doi.org/10.1093/bioinformatics/btw286">doi:10.1093/bioinformatics/btw286</a>. All outputs can be written to standard file formats.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Lucas A. Nell <a href="mailto:lucnell@gmail.com">lucnell@gmail.com</a> (<a href="https://orcid.org/0000-0003-3209-0517">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/lucasnell/jackalope">https://github.com/lucasnell/jackalope</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/lucasnell/jackalope/issues">https://github.com/lucasnell/jackalope/issues</a>
</p>
</li></ul>


<hr>
<h2 id='create_genome'>Create a reference genome.</h2><span id='topic+create_genome'></span>

<h3>Description</h3>

<p>Random chromosomes are generated to create a new <code>ref_genome</code> object.
Note that this function will never generate empty chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_genome(
  n_chroms,
  len_mean,
  len_sd = 0,
  pi_tcag = rep(0.25, 4),
  n_threads = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_genome_+3A_n_chroms">n_chroms</code></td>
<td>
<p>Number of chromosomes.</p>
</td></tr>
<tr><td><code id="create_genome_+3A_len_mean">len_mean</code></td>
<td>
<p>Mean for the gamma distribution of chromosome sizes.</p>
</td></tr>
<tr><td><code id="create_genome_+3A_len_sd">len_sd</code></td>
<td>
<p>Standard deviation for the gamma distribution of chromosome sizes.
If set to <code>&lt;= 0</code>, all chromosomes will be the same length. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="create_genome_+3A_pi_tcag">pi_tcag</code></td>
<td>
<p>Vector of length 4 containing the nucleotide equilibrium frequencies
for &quot;T&quot;, &quot;C&quot;, &quot;A&quot;, and &quot;G&quot;, respectively. Defaults to <code>rep(0.25, 4)</code>.</p>
</td></tr>
<tr><td><code id="create_genome_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads to use for parallel processing. This argument is
ignored if OpenMP is not enabled. Defaults to <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+ref_genome">ref_genome</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
genome &lt;- create_genome(10, 100e3, 100, pi_tcag = c(0.1, 0.2, 0.3, 0.4))

</code></pre>

<hr>
<h2 id='create_haplotypes'>Create haplotypes from a reference genome.</h2><span id='topic+create_haplotypes'></span>

<h3>Description</h3>

<p>Uses one of multiple methods to create variant haplotypes from a reference genome.
See <code><a href="#topic+haps_functions">haps_functions</a></code> for the methods available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_haplotypes(
  reference,
  haps_info,
  sub = NULL,
  ins = NULL,
  del = NULL,
  epsilon = 0.03,
  n_threads = 1,
  show_progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_haplotypes_+3A_reference">reference</code></td>
<td>
<p>A <code>ref_genome</code> object from which to generate haplotypes.
This argument is required.</p>
</td></tr>
<tr><td><code id="create_haplotypes_+3A_haps_info">haps_info</code></td>
<td>
<p>Output from one of the <code><a href="#topic+haps_functions">haps_functions</a></code>.
These functions organize higher-level information for use here.
See <code><a href="#topic+haps_functions">haps_functions</a></code> for brief descriptions and links to each method.
If this argument is <code>NULL</code>, all arguments other than <code>reference</code> are ignored,
and an empty <code>haplotypes</code> object with no haplotypes is returned.
This is designed for use when you'd like to add mutations manually.
If you create a blank <code>haplotypes</code> object, you can use its <code>add_haps</code> method
to add haplotypes manually.</p>
</td></tr>
<tr><td><code id="create_haplotypes_+3A_sub">sub</code></td>
<td>
<p>Output from one of the <code><a href="#topic+sub_models">sub_models</a></code> functions that organizes
information for the substitution models.
See <code><a href="#topic+sub_models">sub_models</a></code> for more information on these models and
their required parameters.
This argument is ignored if you are using a VCF file to create haplotypes.
Passing <code>NULL</code> to this argument results in no substitutions.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="create_haplotypes_+3A_ins">ins</code></td>
<td>
<p>Output from the <code><a href="#topic+indels">indels</a></code> function that specifies rates
of insertions by length.
This argument is ignored if you are using a VCF file to create haplotypes.
Passing <code>NULL</code> to this argument results in no insertions.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="create_haplotypes_+3A_del">del</code></td>
<td>
<p>Output from the <code><a href="#topic+indels">indels</a></code> function that specifies rates
of deletions by length.
This argument is ignored if you are using a VCF file to create haplotypes.
Passing <code>NULL</code> to this argument results in no deletions.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="create_haplotypes_+3A_epsilon">epsilon</code></td>
<td>
<p>Error control parameter for the &quot;tau-leaping&quot; approximation to
the Doob–Gillespie algorithm, as used for the indel portion of the simulations.
Smaller values result in a closer approximation.
Larger values are less exact but faster.
Values must be <code style="white-space: pre;">&#8288;&gt;= 0&#8288;</code> and <code style="white-space: pre;">&#8288;&lt; 1&#8288;</code>.
For more information on the approximation, see Cao et al. (2006) and
Wieder et al. (2011), listed below.
If <code>epsilon</code> is <code>0</code>, then it reverts to the exact Doob–Gillespie algorithm.
Defaults to <code>0.03</code>.</p>
</td></tr>
<tr><td><code id="create_haplotypes_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads to use for parallel processing.
This argument is ignored if OpenMP is not enabled.
Threads are spread across chromosomes, so it
doesn't make sense to supply more threads than chromosomes in the reference genome.
Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="create_haplotypes_+3A_show_progress">show_progress</code></td>
<td>
<p>Boolean for whether to show a progress bar during processing.
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+haplotypes">haplotypes</a></code> object.
</p>


<h3>References</h3>

<p>Cao, Y., D. T. Gillespie, and L. R. Petzold. 2006. Efficient step size
selection for the tau-leaping simulation method.
<em>The Journal of Chemical Physics</em> <strong>124</strong>(4): 044109.
</p>
<p>Doob, J. L. 1942. Topics in the theory of markoff chains.
<em>Transactions of the American Mathematical Society</em> <strong>52</strong>(1): 37–64.
</p>
<p>Gillespie, D. T. 1976. A general method for numerically simulating the stochastic time
evolution of coupled chemical reactions. <em>Journal of Computational Physics</em>
<strong>22</strong>(4): 403–434.
</p>
<p>Wieder, N., R. H. Fink, and F. von Wegner. 2011. Exact and approximate stochastic
simulation of intracellular calcium dynamics.
<em>Journal of Biomedicine and Biotechnology</em> <strong>2011</strong>: 572492.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- create_genome(10, 1000)
v_phylo &lt;- create_haplotypes(r, haps_phylo(ape::rcoal(5)), sub_JC69(0.1))
v_theta &lt;- create_haplotypes(r, haps_theta(0.001, 5), sub_K80(0.1, 0.2))

</code></pre>

<hr>
<h2 id='evo_rates'>Table of evolutionary rates.</h2><span id='topic+evo_rates'></span>

<h3>Description</h3>

<p>From Table 1 in Sung et al. (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evo_rates
</code></pre>


<h3>Format</h3>

<p>A data frame with 15 rows and 8 variables:
</p>

<dl>
<dt><code>domain</code></dt><dd><p>Either <code>Bacteria</code> or <code>Eukarya</code> for what type of organism
the species is.</p>
</dd>
<dt><code>species</code></dt><dd><p>Species name.</p>
</dd>
<dt><code>Ge</code></dt><dd><p>Effective genome size using only coding DNA.</p>
</dd>
<dt><code>Gc_Gnc</code></dt><dd><p>Effective genome size using coding DNA and non-coding DNA that is
under purifying selection.</p>
</dd>
<dt><code>indels</code></dt><dd><p>Rate of insertions and deletions (<code class="reqn">10^{-10}</code>
events per site per generation).</p>
</dd>
<dt><code>subs</code></dt><dd><p>Base-substitution mutation rate (<code class="reqn">10^{-10}</code>
events per site per generation).</p>
</dd>
<dt><code>Ne</code></dt><dd><p>Effective population size (<code class="reqn">\times 10^{6}</code>).</p>
</dd>
<dt><code>theta_s</code></dt><dd><p>Population mutation rate estimated using <code class="reqn">\theta_s</code>.</p>
</dd>
<dt><code>pi_s</code></dt><dd><p>Population mutation rate estimated using <code class="reqn">\pi_s</code>.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://doi.org/10.1534/g3.116.030890">doi:10.1534/g3.116.030890</a>
</p>


<h3>References</h3>

<p>Sung, W., M. S. Ackerman, M. M. Dillon, T. G. Platt, C. Fuqua, V. S. Cooper, and
M. Lynch. 2016. Evolution of the insertion-deletion mutation rate across the
tree of life. <em>G3: Genes | Genomes | Genetics</em> <strong>6</strong>:2583–2591.
</p>

<hr>
<h2 id='haplotypes'>An R6 Class Representing Haploid Variants</h2><span id='topic+haplotypes'></span>

<h3>Description</h3>

<p>Interactive wrapper for a pointer to a C++ object that stores information about
variant haplotypes from a single reference genome.
</p>


<h3>Details</h3>

<p>This class should NEVER be created using <code>haplotypes$new</code>.
Only use <code>create_haplotypes</code>.
Because this class wraps a pointer to a C++ object, there are no fields to
manipulate directly.
All manipulations are done through this class's methods.
</p>


<h3>Connections to <code>ref_genome</code> objects</h3>

<p>Regarding the <code>ref_genome</code> object you use to create a <code>haplotypes</code> object, you should
note the following:
</p>

<ul>
<li> <p><strong>This point is the most important.</strong>
Both the <code>ref_genome</code> and <code>haplotypes</code> objects use the same underlying
C++ object to store reference genome information.
Thus, if you make any changes to the <code>ref_genome</code> object, those changes will
also show up in the <code>haplotypes</code> object.
For example, if you make a <code>haplotypes</code> object named <code>V</code>
based on an existing <code>ref_genome</code> object named <code>R</code>,
then you merge chromosomes in <code>R</code>,
<code>V</code> will now have merged chromosomes.
If you've already started adding mutations to <code>V</code>,
then all the indexes used to store those mutations will be inaccurate.
So when you do anything with <code>V</code> later, your R session will crash
or have errors.
<strong>The lesson here is that you shouldn't edit the reference
genome after using it to create haplotypes.</strong>
</p>
</li>
<li><p> If a <code>ref_genome</code> object is used to create a <code>haplotypes</code>
object, deleting the <code>ref_genome</code> object won't cause issues with
the <code>haplotypes</code> object.
However, the <code>haplotypes</code> class doesn't provide methods to edit
chromosomes, so only remove the <code>ref_genome</code> object when you're done
editing the reference genome.
</p>
</li></ul>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-haplotypes-new"><code>haplotypes$new()</code></a>
</p>
</li>
<li> <p><a href="#method-haplotypes-print"><code>haplotypes$print()</code></a>
</p>
</li>
<li> <p><a href="#method-haplotypes-ptr"><code>haplotypes$ptr()</code></a>
</p>
</li>
<li> <p><a href="#method-haplotypes-n_chroms"><code>haplotypes$n_chroms()</code></a>
</p>
</li>
<li> <p><a href="#method-haplotypes-n_haps"><code>haplotypes$n_haps()</code></a>
</p>
</li>
<li> <p><a href="#method-haplotypes-sizes"><code>haplotypes$sizes()</code></a>
</p>
</li>
<li> <p><a href="#method-haplotypes-chrom_names"><code>haplotypes$chrom_names()</code></a>
</p>
</li>
<li> <p><a href="#method-haplotypes-hap_names"><code>haplotypes$hap_names()</code></a>
</p>
</li>
<li> <p><a href="#method-haplotypes-chrom"><code>haplotypes$chrom()</code></a>
</p>
</li>
<li> <p><a href="#method-haplotypes-gc_prop"><code>haplotypes$gc_prop()</code></a>
</p>
</li>
<li> <p><a href="#method-haplotypes-nt_prop"><code>haplotypes$nt_prop()</code></a>
</p>
</li>
<li> <p><a href="#method-haplotypes-set_names"><code>haplotypes$set_names()</code></a>
</p>
</li>
<li> <p><a href="#method-haplotypes-add_haps"><code>haplotypes$add_haps()</code></a>
</p>
</li>
<li> <p><a href="#method-haplotypes-dup_haps"><code>haplotypes$dup_haps()</code></a>
</p>
</li>
<li> <p><a href="#method-haplotypes-rm_haps"><code>haplotypes$rm_haps()</code></a>
</p>
</li>
<li> <p><a href="#method-haplotypes-add_sub"><code>haplotypes$add_sub()</code></a>
</p>
</li>
<li> <p><a href="#method-haplotypes-add_ins"><code>haplotypes$add_ins()</code></a>
</p>
</li>
<li> <p><a href="#method-haplotypes-add_del"><code>haplotypes$add_del()</code></a>
</p>
</li></ul>


<hr>
<a id="method-haplotypes-new"></a>



<h4>Method <code>new()</code></h4>

<p>Do NOT use this; only use <code>create_haplotypes</code> to make new <code>haplotypes</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>haplotypes$new(genomes_ptr, reference_ptr)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>genomes_ptr</code></dt><dd><p>An <code>externalptr</code> object pointing to a C++ object that
stores the information about the haplotypes.</p>
</dd>
<dt><code>reference_ptr</code></dt><dd><p>An <code>externalptr</code> object pointing to a C++ object that
stores the information about the reference genome.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-haplotypes-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print a <code>haplotypes</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>haplotypes$print()</pre></div>


<hr>
<a id="method-haplotypes-ptr"></a>



<h4>Method <code>ptr()</code></h4>

<p>View pointer to underlying C++ object (this is not useful to end users).
</p>


<h5>Usage</h5>

<div class="r"><pre>haplotypes$ptr()</pre></div>



<h5>Returns</h5>

<p>An <code>externalptr</code> object.
</p>


<hr>
<a id="method-haplotypes-n_chroms"></a>



<h4>Method <code>n_chroms()</code></h4>

<p>View number of chromosomes.
</p>


<h5>Usage</h5>

<div class="r"><pre>haplotypes$n_chroms()</pre></div>



<h5>Returns</h5>

<p>Integer number of chromosomes.
</p>


<hr>
<a id="method-haplotypes-n_haps"></a>



<h4>Method <code>n_haps()</code></h4>

<p>View number of haplotypes.
</p>


<h5>Usage</h5>

<div class="r"><pre>haplotypes$n_haps()</pre></div>



<h5>Returns</h5>

<p>Integer number of haplotypes.
</p>


<hr>
<a id="method-haplotypes-sizes"></a>



<h4>Method <code>sizes()</code></h4>

<p>View chromosome sizes for one haplotype.
</p>


<h5>Usage</h5>

<div class="r"><pre>haplotypes$sizes(hap_ind)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>hap_ind</code></dt><dd><p>Index for the focal haplotype.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Integer vector of chromosome sizes for focal haplotype.
</p>


<hr>
<a id="method-haplotypes-chrom_names"></a>



<h4>Method <code>chrom_names()</code></h4>

<p>View chromosome names.
</p>


<h5>Usage</h5>

<div class="r"><pre>haplotypes$chrom_names()</pre></div>



<h5>Returns</h5>

<p>Character vector of chromosome names.
</p>


<hr>
<a id="method-haplotypes-hap_names"></a>



<h4>Method <code>hap_names()</code></h4>

<p>View haplotype names.
</p>


<h5>Usage</h5>

<div class="r"><pre>haplotypes$hap_names()</pre></div>



<h5>Returns</h5>

<p>Character vector of haplotype names.
</p>


<hr>
<a id="method-haplotypes-chrom"></a>



<h4>Method <code>chrom()</code></h4>

<p>View one haplotype chromosome.
</p>


<h5>Usage</h5>

<div class="r"><pre>haplotypes$chrom(hap_ind, chrom_ind)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>hap_ind</code></dt><dd><p>Index for the focal haplotype.</p>
</dd>
<dt><code>chrom_ind</code></dt><dd><p>Index for the focal chromosome.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A single string representing the chosen haplotype chromosome's DNA
sequence.
</p>


<hr>
<a id="method-haplotypes-gc_prop"></a>



<h4>Method <code>gc_prop()</code></h4>

<p>View GC proportion for part of one haplotype chromosome.
</p>


<h5>Usage</h5>

<div class="r"><pre>haplotypes$gc_prop(hap_ind, chrom_ind, start, end)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>hap_ind</code></dt><dd><p>Index for the focal haplotype.</p>
</dd>
<dt><code>chrom_ind</code></dt><dd><p>Index for the focal chromosome.</p>
</dd>
<dt><code>start</code></dt><dd><p>Point on the chromosome at which to start the calculation
(inclusive).</p>
</dd>
<dt><code>end</code></dt><dd><p>Point on the chromosome at which to end the calculation
(inclusive).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A double in the range <code style="white-space: pre;">&#8288;[0,1]&#8288;</code> representing the proportion of DNA
sequence that is either <code>G</code> or <code>C</code>.
</p>


<hr>
<a id="method-haplotypes-nt_prop"></a>



<h4>Method <code>nt_prop()</code></h4>

<p>View nucleotide content for part of one haplotype chromosome
</p>


<h5>Usage</h5>

<div class="r"><pre>haplotypes$nt_prop(nt, hap_ind, chrom_ind, start, end)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nt</code></dt><dd><p>Which nucleotide to calculate the proportion that the DNA
sequence is made of. Must be one of <code>T</code>, <code>C</code>, <code>A</code>, <code>G</code>, or <code>N</code>.</p>
</dd>
<dt><code>hap_ind</code></dt><dd><p>Index for the focal haplotype.</p>
</dd>
<dt><code>chrom_ind</code></dt><dd><p>Index for the focal chromosome.</p>
</dd>
<dt><code>start</code></dt><dd><p>Point on the chromosome at which to start the calculation
(inclusive).</p>
</dd>
<dt><code>end</code></dt><dd><p>Point on the chromosome at which to end the calculation
(inclusive).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A double in the range <code style="white-space: pre;">&#8288;[0,1]&#8288;</code> representing the proportion of DNA
sequence that is <code>nt</code>.
</p>


<hr>
<a id="method-haplotypes-set_names"></a>



<h4>Method <code>set_names()</code></h4>

<p>Change haplotype names.
</p>


<h5>Usage</h5>

<div class="r"><pre>haplotypes$set_names(new_names)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>new_names</code></dt><dd><p>Vector of new names to use. This must be the same length as
the number of current names.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This <code>R6</code> object, invisibly.
</p>


<hr>
<a id="method-haplotypes-add_haps"></a>



<h4>Method <code>add_haps()</code></h4>

<p>Add one or more blank, named haplotypes
</p>


<h5>Usage</h5>

<div class="r"><pre>haplotypes$add_haps(new_names)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>new_names</code></dt><dd><p>Vector of name(s) for the new haplotype(s).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This <code>R6</code> object, invisibly.
</p>


<hr>
<a id="method-haplotypes-dup_haps"></a>



<h4>Method <code>dup_haps()</code></h4>

<p>Duplicate one or more haplotypes by name.
</p>


<h5>Usage</h5>

<div class="r"><pre>haplotypes$dup_haps(hap_names, new_names = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>hap_names</code></dt><dd><p>Vector of existing haplotype name(s) that you want to
duplicate.</p>
</dd>
<dt><code>new_names</code></dt><dd><p>Optional vector specifying the names of the duplicates.
If <code>NULL</code>, their names are auto-generated. Defaults to <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This <code>R6</code> object, invisibly.
</p>


<hr>
<a id="method-haplotypes-rm_haps"></a>



<h4>Method <code>rm_haps()</code></h4>

<p>Remove one or more haplotypes by name.
</p>


<h5>Usage</h5>

<div class="r"><pre>haplotypes$rm_haps(hap_names)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>hap_names</code></dt><dd><p>Vector of existing haplotype name(s) that you want to remove.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This <code>R6</code> object, invisibly.
</p>


<hr>
<a id="method-haplotypes-add_sub"></a>



<h4>Method <code>add_sub()</code></h4>

<p>Manually add a substitution.
</p>


<h5>Usage</h5>

<div class="r"><pre>haplotypes$add_sub(hap_ind, chrom_ind, pos, nt)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>hap_ind</code></dt><dd><p>Index for the focal haplotype.</p>
</dd>
<dt><code>chrom_ind</code></dt><dd><p>Index for the focal chromosome.</p>
</dd>
<dt><code>pos</code></dt><dd><p>Position at which to add the mutation.</p>
</dd>
<dt><code>nt</code></dt><dd><p>Single character representing the nucleotide to change the
current one to.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This <code>R6</code> object, invisibly.
</p>


<hr>
<a id="method-haplotypes-add_ins"></a>



<h4>Method <code>add_ins()</code></h4>

<p>Manually add an insertion.
</p>


<h5>Usage</h5>

<div class="r"><pre>haplotypes$add_ins(hap_ind, chrom_ind, pos, nts)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>hap_ind</code></dt><dd><p>Index for the focal haplotype.</p>
</dd>
<dt><code>chrom_ind</code></dt><dd><p>Index for the focal chromosome.</p>
</dd>
<dt><code>pos</code></dt><dd><p>Position at which to add the mutation.</p>
</dd>
<dt><code>nts</code></dt><dd><p>String representing the nucleotide(s) that will be inserted after
the designated position.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This <code>R6</code> object, invisibly.
</p>
<div class="sourceCode"><pre>\item{`add_del(hap_ind, chrom_ind, pos, n_nts)`}{Manually add a deletion
    for a given haplotype (`hap_ind`), chromosome (`chrom_ind`), and position (`pos`).
    The designated number of nucleotides to delete (`n_nts`) will be deleted
    starting at `pos`, unless `pos` is near the chromosome end and doesn't have
    `n_nts` nucleotides to remove; it simply stops at the chromosome end in
    this case.}
</pre></div>


<hr>
<a id="method-haplotypes-add_del"></a>



<h4>Method <code>add_del()</code></h4>

<p>Manually add a deletion.
</p>


<h5>Usage</h5>

<div class="r"><pre>haplotypes$add_del(hap_ind, chrom_ind, pos, n_nts)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>hap_ind</code></dt><dd><p>Index for the focal haplotype.</p>
</dd>
<dt><code>chrom_ind</code></dt><dd><p>Index for the focal chromosome.</p>
</dd>
<dt><code>pos</code></dt><dd><p>Position at which to add the mutation.</p>
</dd>
<dt><code>n_nts</code></dt><dd><p>Single integer specifying the number of nucleotides to delete.
These will be deleted starting at <code>pos</code>.
If <code>pos</code> is near the chromosome end and doesn't have <code>n_nts</code> nucleotides
to remove, it simply removes nucleotides from <code>pos</code> to the chromosome end.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This <code>R6</code> object, invisibly.
</p>




<h3>See Also</h3>

<p><code><a href="#topic+create_haplotypes">create_haplotypes</a></code>
</p>

<hr>
<h2 id='haps_functions'>Organize higher-level information for creating haplotypes.</h2><span id='topic+haps_functions'></span>

<h3>Description</h3>

<p>The following functions organize information that gets passed to <code>create_haplotypes</code>
to generate haplotypes from a reference genome.
Each function represents a method of generation and starts with <code>"haps_"</code>.
The first three are phylogenomic methods, and all functions but <code>haps_vcf</code>
will use molecular evolution information when passed to <code>create_haplotypes</code>.
</p>


<h3>Details</h3>


<dl>
<dt><code><a href="#topic+haps_theta">haps_theta</a></code></dt><dd><p>Uses an estimate for theta, the population-scaled
mutation rate, and a desired number of haplotypes.</p>
</dd>
<dt><code><a href="#topic+haps_phylo">haps_phylo</a></code></dt><dd><p>Uses phylogenetic tree(s) from <code>phylo</code>
object(s) or NEWICK file(s), one tree per chromosome or one for all
chromosomes.</p>
</dd>
<dt><code><a href="#topic+haps_gtrees">haps_gtrees</a></code></dt><dd><p>Uses gene trees, either in the form of
an object from the <code>scrm</code> or <code>coala</code> package or
a file containing output in the style of the <code>ms</code> program.</p>
</dd>
<dt><code><a href="#topic+haps_ssites">haps_ssites</a></code></dt><dd><p>Uses matrices of segregating sites,
either in the form of
<code>scrm</code> or <code>coala</code> coalescent-simulator object(s), or
a <code>ms</code>-style output file.</p>
</dd>
<dt><code><a href="#topic+haps_vcf">haps_vcf</a></code></dt><dd><p>Uses a haplotype call format (VCF) file that
directly specifies haplotypes.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+create_haplotypes">create_haplotypes</a></code>
</p>

<hr>
<h2 id='haps_gtrees'>Organize information to create haplotypes using gene trees</h2><span id='topic+haps_gtrees'></span><span id='topic+write_gtrees'></span>

<h3>Description</h3>

<p>This function organizes higher-level information for creating haplotypes from
gene trees output from coalescent simulations.
Note that all gene trees must be rooted and binary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haps_gtrees(obj = NULL, fn = NULL)

write_gtrees(gtrees, out_prefix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="haps_gtrees_+3A_obj">obj</code></td>
<td>
<p>Object containing gene trees.
This can be one of the following:
(1) A single <code>list</code> with a <code>trees</code> field inside. This field must
contain a set of gene trees for each chromosome.
(2) A list of lists, each sub-list containing a <code>trees</code> field of
length 1. The top-level list must be of the same length as the
number of chromosomes.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="haps_gtrees_+3A_fn">fn</code></td>
<td>
<p>A single string specifying the name of the file containing
the <code>ms</code>-style coalescent output with gene trees.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="haps_gtrees_+3A_gtrees">gtrees</code></td>
<td>
<p>A <code>haps_gtrees_info</code> object output from <code>haps_gtrees</code>.</p>
</td></tr>
<tr><td><code id="haps_gtrees_+3A_out_prefix">out_prefix</code></td>
<td>
<p>Prefix for the output file of gene trees.
The extension will be <code>.trees</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the <code>obj</code> argument is designed after the <code>trees</code> fields in the output from
the <code>scrm</code> and <code>coala</code> packages.
(These packages are not required to be installed when installing <code>jackalope</code>.)
To get gene trees, make sure to add <code>+ sumstat_trees()</code>
to the <code>coalmodel</code> for <code>coala</code>, or
make sure that <code>"-T"</code> is present in <code>args</code> for <code>scrm</code>.
If using either of these packages, I encourage you to cite them. For citation
information, see output from <code>citation("scrm")</code> or <code>citation("coala")</code>.
</p>
<p>If using an output file from a command-line program like <code>ms</code>/<code>msms</code>,
add the <code>-T</code> option.
</p>


<h3>Value</h3>

<p>A <code>haps_gtrees_info</code> object containing information used in <code>create_haplotypes</code>
to create variant haplotypes.
This class is just a wrapper around a list of NEWICK tree strings, one for
each gene tree, which you can view (but not change) using the object's
<code>trees()</code> method.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>write_gtrees()</code>: Write gene trees to ms-style output file.
</p>
</li></ul>

<hr>
<h2 id='haps_phylo'>Organize information to create haplotypes using phylogenetic tree(s)</h2><span id='topic+haps_phylo'></span>

<h3>Description</h3>

<p>This function organizes higher-level information for creating haplotypes from
phylogenetic tree(s) output as <code>phylo</code> or <code>multiPhylo</code> objects
(both from the <code>ape</code> package) or NEWICK files.
Note that all phylogenetic trees must be rooted and binary.
If using this function, I encourage you to cite <code>ape</code>. For citation
information, see output from <code>citation("ape")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haps_phylo(obj = NULL, fn = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="haps_phylo_+3A_obj">obj</code></td>
<td>
<p>Object containing phylogenetic tree(s).
This can be (1) a single <code>phylo</code> object
that represents all chromosomes in the genome or
(2) a <code>list</code> or <code>multiPhylo</code> object containing a <code>phylo</code> object for
each reference chromosome.
In the latter case, phylogenies will be assigned to chromosomes in the
order provided.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="haps_phylo_+3A_fn">fn</code></td>
<td>
<p>One or more string(s), each of which specifies the file name
of a NEWICK file containing a phylogeny.
If one name is provided, that phylogeny will be used for all chromosomes.
If more than one is provided, there must be a phylogeny for each reference
genome chromosome, and phylogenies will be assigned to chromosomes
in the order provided.
Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>?ape::write.tree</code> for writing phylogenies to an output file.
</p>


<h3>Value</h3>

<p>A <code>haps_phylo_info</code> object containing information used in <code>create_haplotypes</code>
to create variant haplotypes.
This class is just a wrapper around a list containing phylogenetic tree
information for each reference chromosome, which you can view (but not change)
using the object's <code>phylo()</code> method.
</p>

<hr>
<h2 id='haps_ssites'>Organize information to create haplotypes using segregating sites matrices</h2><span id='topic+haps_ssites'></span>

<h3>Description</h3>

<p>This function organizes higher-level information for creating haplotypes from
matrices of segregating sites output from coalescent simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haps_ssites(obj = NULL, fn = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="haps_ssites_+3A_obj">obj</code></td>
<td>
<p>Object containing segregating sites information.
This can be one of the following:
(1) A single <code>list</code> with a <code>seg_sites</code> field inside. This field must
contain a matrix for segregating sites for each chromosome.
The matrix itself should contain the haplotype information, coded
using 0s and 1s: 0s indicate the ancestral state and 1s indicate
mutant.
The matrix column names should indicate the positions of the polymorphisms on the
chromosome.
If positions are in the range <code style="white-space: pre;">&#8288;(0,1)&#8288;</code>, they're assumed to come from an infinite-
sites model and are relative positions.
If positions are integers in the range <code style="white-space: pre;">&#8288;[0, chromosome length - 1]&#8288;</code>
or <code style="white-space: pre;">&#8288;[1, chromosome length]&#8288;</code>, they're assumed to come from an finite-sites
model and are absolute positions.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="haps_ssites_+3A_fn">fn</code></td>
<td>
<p>A single string specifying the name of the file containing
the <code>ms</code>-style coalescent output with segregating site info.
Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For what the <code>seg_sites</code> field should look like in a list, see output from the
<code>scrm</code> or <code>coala</code> package.
(These packages are not required to be installed when installing
<code>jackalope</code>.)
If using either of these packages, I encourage you to cite them. For citation
information, see output from <code>citation("scrm")</code> or <code>citation("coala")</code>.
</p>


<h3>Value</h3>

<p>A <code>haps_ssites_info</code> object containing information used in <code>create_haplotypes</code>
to create variant haplotypes.
This class is just a wrapper around a list of matrices of segregating site info,
which you can view (but not change) using the object's <code>mats()</code> method.
</p>

<hr>
<h2 id='haps_theta'>Organize information to create haplotypes using theta parameter</h2><span id='topic+haps_theta'></span>

<h3>Description</h3>

<p>This function organizes higher-level information for creating haplotypes from
the population-scaled mutation rate and a desired number of haplotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haps_theta(theta, n_haps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="haps_theta_+3A_theta">theta</code></td>
<td>
<p>Population-scaled mutation rate.</p>
</td></tr>
<tr><td><code id="haps_theta_+3A_n_haps">n_haps</code></td>
<td>
<p>Number of desired haplotypes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>haps_theta_info</code> object containing information used in <code>create_haplotypes</code>
to create variant haplotypes.
This class is just a wrapper around a list containing the phylogenetic tree
and <code>theta</code> parameter, which you can view (but not change) using the object's
<code>phylo()</code> and <code>theta()</code> methods, respectively.
</p>

<hr>
<h2 id='haps_vcf'>Organize information to create haplotypes using a VCF file</h2><span id='topic+haps_vcf'></span>

<h3>Description</h3>

<p>This function organizes higher-level information for creating haplotypes from
Variant Call Format (VCF) files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haps_vcf(fn, print_names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="haps_vcf_+3A_fn">fn</code></td>
<td>
<p>A single string specifying the name of the VCF file</p>
</td></tr>
<tr><td><code id="haps_vcf_+3A_print_names">print_names</code></td>
<td>
<p>Logical for whether to print all unique chromosome names from
the VCF file when VCF chromosome names don't match those from the reference genome.
This printing doesn't happen until this object is passed to <code>create_haplotypes</code>.
This can be useful for troubleshooting.
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>haps_vcf_info</code> object containing information used in <code>create_haplotypes</code>
to create variant haplotypes.
This class is just a wrapper around a list containing the arguments to this
function, which you can view (but not change) using the object's <code>fn()</code> and
<code>print_names()</code> methods.
</p>

<hr>
<h2 id='illumina'>Create and write Illumina reads to FASTQ file(s).</h2><span id='topic+illumina'></span>

<h3>Description</h3>

<p>From either a reference genome or set of variant haplotypes, create Illumina reads
from error profiles and write them to FASTQ output file(s).
I encourage you to cite the reference below in addition to <code>jackalope</code> if you use
this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>illumina(obj,
         out_prefix,
         n_reads,
         read_length,
         paired,
         frag_mean = 400,
         frag_sd = 100,
         matepair = FALSE,
         seq_sys = NULL,
         profile1 = NULL,
         profile2 = NULL,
         ins_prob1 = 0.00009,
         del_prob1 = 0.00011,
         ins_prob2 = 0.00015,
         del_prob2 = 0.00023,
         frag_len_min = NULL,
         frag_len_max = NULL,
         haplotype_probs = NULL,
         barcodes = NULL,
         prob_dup = 0.02,
         sep_files = FALSE,
         compress = FALSE,
         comp_method = "bgzip",
         n_threads = 1L,
         read_pool_size = 1000L,
         show_progress = FALSE,
         overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="illumina_+3A_obj">obj</code></td>
<td>
<p>Sequencing object of class <code>ref_genome</code> or <code>haplotypes</code>.</p>
</td></tr>
<tr><td><code id="illumina_+3A_out_prefix">out_prefix</code></td>
<td>
<p>Prefix for the output file(s), including entire path except
for the file extension.</p>
</td></tr>
<tr><td><code id="illumina_+3A_n_reads">n_reads</code></td>
<td>
<p>Number of reads you want to create.</p>
</td></tr>
<tr><td><code id="illumina_+3A_read_length">read_length</code></td>
<td>
<p>Length of reads.</p>
</td></tr>
<tr><td><code id="illumina_+3A_paired">paired</code></td>
<td>
<p>Logical for whether to use paired-end reads.
This argument is changed to <code>TRUE</code> if <code>matepair</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="illumina_+3A_frag_mean">frag_mean</code></td>
<td>
<p>Mean of the Gamma distribution that generates fragment sizes.
Defaults to <code>400</code>.</p>
</td></tr>
<tr><td><code id="illumina_+3A_frag_sd">frag_sd</code></td>
<td>
<p>Standard deviation of the Gamma distribution that generates
fragment sizes.
Defaults to <code>100</code>.</p>
</td></tr>
<tr><td><code id="illumina_+3A_matepair">matepair</code></td>
<td>
<p>Logical for whether to simulate mate-pair reads.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="illumina_+3A_seq_sys">seq_sys</code></td>
<td>
<p>Full or abbreviated name of sequencing system to use.
See &quot;Sequencing systems&quot; section for options.
See &quot;Sequencing profiles&quot; section for more information on how this argument,
<code>profile1</code>, and <code>profile2</code> are used to specify profiles.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="illumina_+3A_profile1">profile1</code></td>
<td>
<p>Custom profile file for read 1.
See &quot;Sequencing profiles&quot; section for more information on how this argument,
<code>profile2</code>, and <code>seq_sys</code> are used to specify profiles.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="illumina_+3A_profile2">profile2</code></td>
<td>
<p>Custom profile file for read 2.
See &quot;Sequencing profiles&quot; section for more information on how this argument,
<code>profile1</code>, and <code>seq_sys</code> are used to specify profiles.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="illumina_+3A_ins_prob1">ins_prob1</code></td>
<td>
<p>Insertion probability for read 1. Defaults to <code>0.00009</code>.</p>
</td></tr>
<tr><td><code id="illumina_+3A_del_prob1">del_prob1</code></td>
<td>
<p>Deletion probability for read 1. Defaults to <code>0.00011</code>.</p>
</td></tr>
<tr><td><code id="illumina_+3A_ins_prob2">ins_prob2</code></td>
<td>
<p>Insertion probability for read 2. Defaults to <code>0.00015</code>.</p>
</td></tr>
<tr><td><code id="illumina_+3A_del_prob2">del_prob2</code></td>
<td>
<p>Deletion probability for read 2. Defaults to <code>0.00023</code>.</p>
</td></tr>
<tr><td><code id="illumina_+3A_frag_len_min">frag_len_min</code></td>
<td>
<p>Minimum fragment size. A <code>NULL</code> value results in the read length.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="illumina_+3A_frag_len_max">frag_len_max</code></td>
<td>
<p>Maximum fragment size.
A <code>NULL</code> value results in <code>2^32-1</code>, the maximum allowed value.
Defaults to <code>NULL</code></p>
</td></tr>
<tr><td><code id="illumina_+3A_haplotype_probs">haplotype_probs</code></td>
<td>
<p>Relative probability of sampling each haplotype.
This is ignored if sequencing a reference genome.
<code>NULL</code> results in all having the same probability.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="illumina_+3A_barcodes">barcodes</code></td>
<td>
<p>Character vector of barcodes for each haplotype, or a single barcode
if sequencing a reference genome. <code>NULL</code> results in no barcodes.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="illumina_+3A_prob_dup">prob_dup</code></td>
<td>
<p>A single number indicating the probability of duplicates.
Defaults to <code>0.02</code>.</p>
</td></tr>
<tr><td><code id="illumina_+3A_sep_files">sep_files</code></td>
<td>
<p>Logical indicating whether to make separate files for each haplotype.
This argument is coerced to <code>FALSE</code> if the <code>obj</code> argument is not
a <code>haplotypes</code> object.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="illumina_+3A_compress">compress</code></td>
<td>
<p>Logical specifying whether or not to compress output file, or
an integer specifying the level of compression, from 1 to 9.
If <code>TRUE</code>, a compression level of <code>6</code> is used.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="illumina_+3A_comp_method">comp_method</code></td>
<td>
<p>Character specifying which type of compression to use if any
is desired. Options include <code>"gzip"</code> and <code>"bgzip"</code>.
This is ignored if <code>compress</code> is <code>FALSE</code>, and it throws an error if
it's set to <code>"gzip"</code> when <code>n_threads &gt; 1</code> (since I don't have a method to
do gzip compression in parallel).
Defaults to <code>"bgzip"</code>.</p>
</td></tr>
<tr><td><code id="illumina_+3A_n_threads">n_threads</code></td>
<td>
<p>The number of threads to use in processing.
If <code>compress</code> is <code>TRUE</code> or <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code> (indicating compressed output),
setting <code>n_threads</code> to <code>2</code> or more makes this function first create an
uncompressed file/files using <code>n_threads</code> threads, then compress that/those
file/files also using <code>n_threads</code> threads.
There is no speed increase if you try to use multiple threads to create
compressed output on the fly, so that option is not included.
If you want to be conservative with disk space (by not having an uncompressed
file present even temporarily), set <code>n_threads</code> to <code>1</code>.
Threads are NOT spread across chromosomes or haplotypes, so you don't need to
think about these when choosing this argument's value.
However, all threads write to the same file/files, so there are diminishing
returns for providing many threads.
This argument is ignored if the package was not compiled with OpenMP.
Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="illumina_+3A_read_pool_size">read_pool_size</code></td>
<td>
<p>The number of reads to store before writing to disk.
Increasing this number should improve speed but take up more memory.
Defaults to <code>1000</code>.</p>
</td></tr>
<tr><td><code id="illumina_+3A_show_progress">show_progress</code></td>
<td>
<p>Logical for whether to show a progress bar.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="illumina_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical for whether to overwrite existing FASTQ file(s) of the
same name, if they exist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned.
</p>


<h3>Sequencing profiles</h3>

<p>This section outlines how to use the <code>seq_sys</code>, <code>profile1</code>,
and <code>profile2</code> arguments.
If all arguments are <code>NULL</code> (their defaults), a sequencing system is chosen
based on the read length.
If, however, one or more arguments has been provided, then how they're provided
should depend on whether you want single- or paired-end reads.
</p>
<p><strong>For single-end reads</strong>
</p>

<ul>
<li> <p><code>profile2</code> should be <code>NULL</code>.
</p>
</li>
<li><p> Only <code>seq_sys</code> or <code>profile1</code> should be provided, not both.
</p>
</li></ul>

<p><strong>For paired-end reads</strong>
</p>

<ul>
<li><p> If providing <code>seq_sys</code>, don't provide either <code>profile1</code> or <code>profile2</code>.
</p>
</li>
<li><p> If providing <code>profile1</code>, you must also provide <code>profile2</code> (they can be the
same if you want) and you cannot provide <code>seq_sys</code>.
</p>
</li></ul>



<h3>Sequencing systems</h3>

<p>Sequencing system options are the following, where, for each system,
&quot;name&quot; is the full name, &quot;abbrev&quot; is the abbreviated name,
&quot;max_len&quot; indicates the maximum allowed read length,
and
&quot;paired&quot; indicates whether paired-end sequencing is allowed.
</p>

<table>
<tr>
 <td style="text-align: left;">
name                 </td><td style="text-align: left;"> abbrev   </td><td style="text-align: left;"> max_len </td><td style="text-align: left;"> paired </td>
</tr>
<tr>
 <td style="text-align: left;">
Genome Analyzer I    </td><td style="text-align: left;"> GA1      </td><td style="text-align: left;"> 44      </td><td style="text-align: left;"> Yes   </td>
</tr>
<tr>
 <td style="text-align: left;">
Genome Analyzer II   </td><td style="text-align: left;"> GA2      </td><td style="text-align: left;"> 75      </td><td style="text-align: left;"> Yes   </td>
</tr>
<tr>
 <td style="text-align: left;">
HiSeq 1000           </td><td style="text-align: left;"> HS10     </td><td style="text-align: left;"> 100     </td><td style="text-align: left;"> Yes   </td>
</tr>
<tr>
 <td style="text-align: left;">
HiSeq 2000           </td><td style="text-align: left;"> HS20     </td><td style="text-align: left;"> 100     </td><td style="text-align: left;"> Yes   </td>
</tr>
<tr>
 <td style="text-align: left;">
HiSeq 2500           </td><td style="text-align: left;"> HS25     </td><td style="text-align: left;"> 150     </td><td style="text-align: left;"> Yes   </td>
</tr>
<tr>
 <td style="text-align: left;">
HiSeqX v2.5 PCR free </td><td style="text-align: left;"> HSXn     </td><td style="text-align: left;"> 150     </td><td style="text-align: left;"> Yes   </td>
</tr>
<tr>
 <td style="text-align: left;">
HiSeqX v2.5 TruSeq   </td><td style="text-align: left;"> HSXt     </td><td style="text-align: left;"> 150     </td><td style="text-align: left;"> Yes   </td>
</tr>
<tr>
 <td style="text-align: left;">
MiniSeq TruSeq       </td><td style="text-align: left;"> MinS     </td><td style="text-align: left;"> 50      </td><td style="text-align: left;"> No    </td>
</tr>
<tr>
 <td style="text-align: left;">
MiSeq v1             </td><td style="text-align: left;"> MSv1     </td><td style="text-align: left;"> 250     </td><td style="text-align: left;"> Yes   </td>
</tr>
<tr>
 <td style="text-align: left;">
MiSeq v3             </td><td style="text-align: left;"> MSv3     </td><td style="text-align: left;"> 250     </td><td style="text-align: left;"> Yes   </td>
</tr>
<tr>
 <td style="text-align: left;">
NextSeq 500 v2       </td><td style="text-align: left;"> NS50     </td><td style="text-align: left;"> 75      </td><td style="text-align: left;"> Yes   </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>ID lines</h3>

<p>The ID lines for FASTQ files are formatted as such:
</p>
<p><code style="white-space: pre;">&#8288;@&lt;genome name&gt;-&lt;chromosome name&gt;-&lt;starting position&gt;-&lt;strand&gt;[/&lt;read#&gt;]&#8288;</code>
</p>
<p>where the part in <code style="white-space: pre;">&#8288;[]&#8288;</code> is only for paired-end Illumina reads, and where <code style="white-space: pre;">&#8288;genome name&#8288;</code>
is always <code>REF</code> for reference genomes (as opposed to haplotypes).
</p>


<h3>References</h3>

<p>Huang, W., L. Li, J. R. Myers, and G. T. Marth. 2012. ART: a next-generation
sequencing read simulator. <em>Bioinformatics</em> <strong>28</strong>:593–594.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rg &lt;- create_genome(10, 100e3, 100)
dir &lt;- tempdir(TRUE)
illumina(rg, paste0(dir, "/illumina_reads"), n_reads = 100,
         read_length = 100, paired = FALSE)


</code></pre>

<hr>
<h2 id='indels'>Insertions and deletions (indels) specification</h2><span id='topic+indels'></span>

<h3>Description</h3>

<p>Construct necessary information for insertions and deletions (indels) that will
be used in <code>create_haplotypes</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indels(rate, max_length = 10, a = NULL, rel_rates = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indels_+3A_rate">rate</code></td>
<td>
<p>Single number specifying the overall indel rate among all lengths.</p>
</td></tr>
<tr><td><code id="indels_+3A_max_length">max_length</code></td>
<td>
<p>Maximum length of indels. Defaults to <code>10</code>.</p>
</td></tr>
<tr><td><code id="indels_+3A_a">a</code></td>
<td>
<p>Extra parameter necessary for generating rates from a Lavalette distribution.
See Details for more info. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="indels_+3A_rel_rates">rel_rates</code></td>
<td>
<p>A numeric vector of relative rates for each indel length
from 1 to the maximum length.
If provided, all arguments other than <code>rate</code> are ignored.
Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All indels require the <code>rate</code> parameter, which specifies
the overall indels rate among all lengths.
The <code>rate</code> parameter is ultimately combined with a vector of relative rates among
the different lengths of indels from 1 to the maximum possible length.
There are three different ways to specify/generate relative-rate values.
</p>

<ol>
<li><p> Assume that rates are proportional to <code>exp(-L)</code> for indel length
<code>L</code> from 1 to the maximum length (Albers et al. 2011).
This method will be used if the following arguments are provided:
</p>

<ul>
<li> <p><code>rate</code>
</p>
</li>
<li> <p><code>max_length</code>
</p>
</li></ul>

</li>
<li><p> Generate relative rates from a Lavalette distribution
(Fletcher and Yang 2009), where the rate for length <code>L</code> is proportional to
<code>{L * max_length / (max_length - L + 1)}^(-a)</code>.
This method will be used if the following arguments are provided:
</p>

<ul>
<li> <p><code>rate</code>
</p>
</li>
<li> <p><code>max_length</code>
</p>
</li>
<li> <p><code>a</code>
</p>
</li></ul>

</li>
<li><p> Directly specify values by providing a numeric vector of relative
rates for each insertion/deletion length from 1 to the maximum length.
This method will be used if the following arguments are provided:
</p>

<ul>
<li> <p><code>rate</code>
</p>
</li>
<li> <p><code>rel_rates</code>
</p>
</li></ul>

</li></ol>



<h3>Value</h3>

<p>An <code>indel_info</code> object, which is an R6 class that wraps the info needed for
the <code>create_haplotypes</code> function.
It does not allow the user to directly manipulate the info inside, as that
should be done using this function.
You can use the <code>rates()</code> method to view the indel rates by size.
</p>


<h3>References</h3>

<p>Albers, C. A., G. Lunter, D. G. MacArthur, G. McVean, W. H. Ouwehand, and R. Durbin.
2011. Dindel: accurate indel calls from short-read data. Genome Research 21:961–973.
</p>
<p>Fletcher, W., and Z. Yang. 2009. INDELible: a flexible simulator of
biological sequence evolution. Molecular Biology and Evolution 26:1879–1888.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># relative rates are proportional to `exp(-L)` for indel
# length `L` from 1 to 5:
indel_rates1 &lt;- indels(0.1, max_length = 5)

# relative rates are proportional to Lavalette distribution
# for length from 1 to 10:
indel_rates2 &lt;- indels(0.2, max_length = 10, a = 1.1)

# relative rates are all the same for lengths from 1 to 100:
indel_rates3 &lt;- indels(0.2, rel_rates = rep(1, 100))



</code></pre>

<hr>
<h2 id='pacbio'>Create and write PacBio reads to FASTQ file(s).</h2><span id='topic+pacbio'></span>

<h3>Description</h3>

<p>From either a reference genome or set of variant haplotypes, create PacBio reads
and write them to FASTQ output file(s).
I encourage you to cite the reference below in addition to <code>jackalope</code> if you use
this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pacbio(obj,
       out_prefix,
       n_reads,
       chi2_params_s = c(0.01214, -5.12, 675, 48303.0732881,
                         1.4691051212330266),
       chi2_params_n = c(0.00189237136, 2.53944970, 5500),
       max_passes = 40,
       sqrt_params = c(0.5, 0.2247),
       norm_params = c(0, 0.2),
       prob_thresh = 0.2,
       ins_prob = 0.11,
       del_prob = 0.04,
       sub_prob = 0.01,
       min_read_length = 50,
       lognorm_read_length = c(0.200110276521, -10075.4363813,
                               17922.611306),
       custom_read_lengths = NULL,
       prob_dup = 0.0,
       haplotype_probs = NULL,
       sep_files = FALSE,
       compress = FALSE,
       comp_method = "bgzip",
       n_threads = 1L,
       read_pool_size = 100L,
       show_progress = FALSE,
       overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pacbio_+3A_obj">obj</code></td>
<td>
<p>Sequencing object of class <code>ref_genome</code> or <code>haplotypes</code>.</p>
</td></tr>
<tr><td><code id="pacbio_+3A_out_prefix">out_prefix</code></td>
<td>
<p>Prefix for the output file(s), including entire path except
for the file extension.</p>
</td></tr>
<tr><td><code id="pacbio_+3A_n_reads">n_reads</code></td>
<td>
<p>Number of reads you want to create.</p>
</td></tr>
<tr><td><code id="pacbio_+3A_chi2_params_s">chi2_params_s</code></td>
<td>
<p>Vector containing the 5 parameters for the curve determining
the scale parameter for the chi^2 distribution.
Defaults to <code>c(0.01214, -5.12, 675, 48303.0732881, 1.4691051212330266)</code>.</p>
</td></tr>
<tr><td><code id="pacbio_+3A_chi2_params_n">chi2_params_n</code></td>
<td>
<p>Vector containing the 3 parameters for the function
determining the n parameter for the chi^2 distribution.
Defaults to <code>c(0.00189237136, 2.53944970, 5500)</code>.</p>
</td></tr>
<tr><td><code id="pacbio_+3A_max_passes">max_passes</code></td>
<td>
<p>Maximal number of passes for one molecule.
Defaults to <code>40</code>.</p>
</td></tr>
<tr><td><code id="pacbio_+3A_sqrt_params">sqrt_params</code></td>
<td>
<p>Vector containing the 2 parameters for the square root
function for the quality increase.
Defaults to <code>c(0.5, 0.2247)</code>.</p>
</td></tr>
<tr><td><code id="pacbio_+3A_norm_params">norm_params</code></td>
<td>
<p>Vector containing the 2 parameters for normal distributed
noise added to quality increase square root function
Defaults to <code>c(0, 0.2)</code>.</p>
</td></tr>
<tr><td><code id="pacbio_+3A_prob_thresh">prob_thresh</code></td>
<td>
<p>Upper bound for the modified total error probability.
Defaults to <code>0.2</code>.</p>
</td></tr>
<tr><td><code id="pacbio_+3A_ins_prob">ins_prob</code></td>
<td>
<p>Probability for insertions for reads with one pass.
Defaults to <code>0.11</code>.</p>
</td></tr>
<tr><td><code id="pacbio_+3A_del_prob">del_prob</code></td>
<td>
<p>Probability for deletions for reads with one pass.
Defaults to <code>0.04</code>.</p>
</td></tr>
<tr><td><code id="pacbio_+3A_sub_prob">sub_prob</code></td>
<td>
<p>Probability for substitutions for reads with one pass.
Defaults to <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="pacbio_+3A_min_read_length">min_read_length</code></td>
<td>
<p>Minium read length for lognormal distribution.
Defaults to <code>50</code>.</p>
</td></tr>
<tr><td><code id="pacbio_+3A_lognorm_read_length">lognorm_read_length</code></td>
<td>
<p>Vector containing the 3 parameters for lognormal
read length distribution.
Defaults to <code>c(0.200110276521, -10075.4363813, 17922.611306)</code>.</p>
</td></tr>
<tr><td><code id="pacbio_+3A_custom_read_lengths">custom_read_lengths</code></td>
<td>
<p>Sample read lengths from a vector or column in a
matrix; if a matrix, the second column specifies the sampling weights.
If <code>NULL</code>, it samples read lengths from the lognormal distribution
using parameters in <code>lognorm_read_length</code>.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pacbio_+3A_prob_dup">prob_dup</code></td>
<td>
<p>A single number indicating the probability of duplicates.
Defaults to <code>0.0</code>.</p>
</td></tr>
<tr><td><code id="pacbio_+3A_haplotype_probs">haplotype_probs</code></td>
<td>
<p>Relative probability of sampling each haplotype.
This is ignored if sequencing a reference genome.
<code>NULL</code> results in all having the same probability.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pacbio_+3A_sep_files">sep_files</code></td>
<td>
<p>Logical indicating whether to make separate files for each haplotype.
This argument is coerced to <code>FALSE</code> if the <code>obj</code> argument is not
a <code>haplotypes</code> object.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pacbio_+3A_compress">compress</code></td>
<td>
<p>Logical specifying whether or not to compress output file, or
an integer specifying the level of compression, from 1 to 9.
If <code>TRUE</code>, a compression level of <code>6</code> is used.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pacbio_+3A_comp_method">comp_method</code></td>
<td>
<p>Character specifying which type of compression to use if any
is desired. Options include <code>"gzip"</code> and <code>"bgzip"</code>.
This is ignored if <code>compress</code> is <code>FALSE</code>, and it throws an error if
it's set to <code>"gzip"</code> when <code>n_threads &gt; 1</code> (since I don't have a method to
do gzip compression in parallel).
Defaults to <code>"bgzip"</code>.</p>
</td></tr>
<tr><td><code id="pacbio_+3A_n_threads">n_threads</code></td>
<td>
<p>The number of threads to use in processing.
If <code>compress</code> is <code>TRUE</code> or <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code> (indicating compressed output),
setting <code>n_threads</code> to <code>2</code> or more makes this function first create an
uncompressed file/files using <code>n_threads</code> threads, then compress that/those
file/files also using <code>n_threads</code> threads.
There is no speed increase if you try to use multiple threads to create
compressed output on the fly, so that option is not included.
If you want to be conservative with disk space (by not having an uncompressed
file present even temporarily), set <code>n_threads</code> to <code>1</code>.
Threads are NOT spread across chromosomes or haplotypes, so you don't need to
think about these when choosing this argument's value.
However, all threads write to the same file/files, so there are diminishing
returns for providing many threads.
This argument is ignored if the package was not compiled with OpenMP.
Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="pacbio_+3A_read_pool_size">read_pool_size</code></td>
<td>
<p>The number of reads to store before writing to disk.
Increasing this number should improve speed but take up more memory.
Defaults to <code>100</code>.</p>
</td></tr>
<tr><td><code id="pacbio_+3A_show_progress">show_progress</code></td>
<td>
<p>Logical for whether to show a progress bar.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pacbio_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical for whether to overwrite existing FASTQ file(s) of the
same name, if they exist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned.
</p>


<h3>ID lines</h3>

<p>The ID lines for FASTQ files are formatted as such:
</p>
<p><code style="white-space: pre;">&#8288;@&lt;genome name&gt;-&lt;chromosome name&gt;-&lt;starting position&gt;-&lt;strand&gt;&#8288;</code>
</p>
<p>where <code style="white-space: pre;">&#8288;genome name&#8288;</code> is always <code>REF</code> for reference genomes (as opposed to haplotypes).
</p>


<h3>References</h3>

<p>Stöcker, B. K., J. Köster, and S. Rahmann. 2016. SimLoRD: simulation of long
read data. <em>Bioinformatics</em> <strong>32</strong>:2704–2706.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rg &lt;- create_genome(10, 100e3, 100)
dir &lt;- tempdir(TRUE)
pacbio(rg, paste0(dir, "/pacbio_reads"), n_reads = 100)


</code></pre>

<hr>
<h2 id='read_fasta'>Read a fasta file.</h2><span id='topic+read_fasta'></span>

<h3>Description</h3>

<p>Accepts uncompressed and gzipped fasta files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_fasta(fasta_files, fai_files = NULL, cut_names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_fasta_+3A_fasta_files">fasta_files</code></td>
<td>
<p>File name(s) of the fasta file(s).</p>
</td></tr>
<tr><td><code id="read_fasta_+3A_fai_files">fai_files</code></td>
<td>
<p>File name(s) of the fasta index file(s).
Providing this argument speeds up the reading process significantly.
If this argument is provided, it must be the same length as the <code>fasta_files</code>
argument.
Defaults to <code>NULL</code>, which indicates the fasta file(s) is/are not indexed.</p>
</td></tr>
<tr><td><code id="read_fasta_+3A_cut_names">cut_names</code></td>
<td>
<p>Boolean for whether to cut chromosome names at the first space.
This argument is ignored if <code>fai_file</code> is not <code>NULL</code>.
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+ref_genome">ref_genome</a></code> object.
</p>

<hr>
<h2 id='ref_genome'>R6 Class Representing a Reference Genome</h2><span id='topic+ref_genome'></span>

<h3>Description</h3>

<p>Interactive wrapper for a pointer to a C++ object that stores reference genome
information.
</p>


<h3>Details</h3>

<p>This class should NEVER be created using <code>ref_genome$new</code>.
Only use <code>read_fasta</code> or <code>create_genome</code>.
Because this class wraps a pointer to a C++ object, there are no fields to
manipulate directly.
All manipulations are done through this class's methods.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ref_genome-new"><code>ref_genome$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ref_genome-print"><code>ref_genome$print()</code></a>
</p>
</li>
<li> <p><a href="#method-ref_genome-ptr"><code>ref_genome$ptr()</code></a>
</p>
</li>
<li> <p><a href="#method-ref_genome-n_chroms"><code>ref_genome$n_chroms()</code></a>
</p>
</li>
<li> <p><a href="#method-ref_genome-sizes"><code>ref_genome$sizes()</code></a>
</p>
</li>
<li> <p><a href="#method-ref_genome-chrom_names"><code>ref_genome$chrom_names()</code></a>
</p>
</li>
<li> <p><a href="#method-ref_genome-chrom"><code>ref_genome$chrom()</code></a>
</p>
</li>
<li> <p><a href="#method-ref_genome-gc_prop"><code>ref_genome$gc_prop()</code></a>
</p>
</li>
<li> <p><a href="#method-ref_genome-nt_prop"><code>ref_genome$nt_prop()</code></a>
</p>
</li>
<li> <p><a href="#method-ref_genome-set_names"><code>ref_genome$set_names()</code></a>
</p>
</li>
<li> <p><a href="#method-ref_genome-clean_names"><code>ref_genome$clean_names()</code></a>
</p>
</li>
<li> <p><a href="#method-ref_genome-add_chroms"><code>ref_genome$add_chroms()</code></a>
</p>
</li>
<li> <p><a href="#method-ref_genome-rm_chroms"><code>ref_genome$rm_chroms()</code></a>
</p>
</li>
<li> <p><a href="#method-ref_genome-merge_chroms"><code>ref_genome$merge_chroms()</code></a>
</p>
</li>
<li> <p><a href="#method-ref_genome-filter_chroms"><code>ref_genome$filter_chroms()</code></a>
</p>
</li>
<li> <p><a href="#method-ref_genome-replace_Ns"><code>ref_genome$replace_Ns()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ref_genome-new"></a>



<h4>Method <code>new()</code></h4>

<p>Do NOT use this; only use <code>read_fasta</code> or <code>create_genome</code> to make a
new <code>ref_genome</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ref_genome$new(genome_ptr)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>genome_ptr</code></dt><dd><p>An <code>externalptr</code> object pointing to a C++ object that stores
the information about the reference genome.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ref_genome-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print a <code>ref_genome</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ref_genome$print()</pre></div>


<hr>
<a id="method-ref_genome-ptr"></a>



<h4>Method <code>ptr()</code></h4>

<p>View pointer to underlying C++ object (this is not useful to end users).
</p>


<h5>Usage</h5>

<div class="r"><pre>ref_genome$ptr()</pre></div>



<h5>Returns</h5>

<p>An <code>externalptr</code> object.
</p>


<hr>
<a id="method-ref_genome-n_chroms"></a>



<h4>Method <code>n_chroms()</code></h4>

<p>View number of chromosomes.
</p>


<h5>Usage</h5>

<div class="r"><pre>ref_genome$n_chroms()</pre></div>



<h5>Returns</h5>

<p>Integer number of chromosomes.
</p>


<hr>
<a id="method-ref_genome-sizes"></a>



<h4>Method <code>sizes()</code></h4>

<p>View chromosome sizes.
</p>


<h5>Usage</h5>

<div class="r"><pre>ref_genome$sizes()</pre></div>



<h5>Returns</h5>

<p>Integer vector of chromosome sizes.
</p>


<hr>
<a id="method-ref_genome-chrom_names"></a>



<h4>Method <code>chrom_names()</code></h4>

<p>View chromosome names.
</p>


<h5>Usage</h5>

<div class="r"><pre>ref_genome$chrom_names()</pre></div>



<h5>Returns</h5>

<p>Character vector of chromosome names.
</p>


<hr>
<a id="method-ref_genome-chrom"></a>



<h4>Method <code>chrom()</code></h4>

<p>View one reference chromosome.
</p>


<h5>Usage</h5>

<div class="r"><pre>ref_genome$chrom(chrom_ind)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>chrom_ind</code></dt><dd><p>Index for the focal chromosome.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A single string representing the chosen chromosome's DNA sequence.
</p>


<hr>
<a id="method-ref_genome-gc_prop"></a>



<h4>Method <code>gc_prop()</code></h4>

<p>View GC proportion for part of one reference chromosome.
</p>


<h5>Usage</h5>

<div class="r"><pre>ref_genome$gc_prop(chrom_ind, start, end)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>chrom_ind</code></dt><dd><p>Index for the focal chromosome.</p>
</dd>
<dt><code>start</code></dt><dd><p>Point on the chromosome at which to start the calculation
(inclusive).</p>
</dd>
<dt><code>end</code></dt><dd><p>Point on the chromosome at which to end the calculation
(inclusive).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A double in the range <code style="white-space: pre;">&#8288;[0,1]&#8288;</code> representing the proportion of DNA
sequence that is either <code>G</code> or <code>C</code>.
</p>


<hr>
<a id="method-ref_genome-nt_prop"></a>



<h4>Method <code>nt_prop()</code></h4>

<p>View nucleotide content for part of one reference chromosome
</p>


<h5>Usage</h5>

<div class="r"><pre>ref_genome$nt_prop(nt, chrom_ind, start, end)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nt</code></dt><dd><p>Which nucleotide to calculate the proportion that the DNA
sequence is made of. Must be one of <code>T</code>, <code>C</code>, <code>A</code>, <code>G</code>, or <code>N</code>.</p>
</dd>
<dt><code>chrom_ind</code></dt><dd><p>Index for the focal chromosome.</p>
</dd>
<dt><code>start</code></dt><dd><p>Point on the chromosome at which to start the calculation
(inclusive).</p>
</dd>
<dt><code>end</code></dt><dd><p>Point on the chromosome at which to end the calculation
(inclusive).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A double in the range <code style="white-space: pre;">&#8288;[0,1]&#8288;</code> representing the proportion of DNA
sequence that is <code>nt</code>.
</p>


<hr>
<a id="method-ref_genome-set_names"></a>



<h4>Method <code>set_names()</code></h4>

<p>Change chromosome names.
</p>


<h5>Usage</h5>

<div class="r"><pre>ref_genome$set_names(new_names)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>new_names</code></dt><dd><p>Vector of new names to use. This must be the same length as
the number of current names.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This <code>R6</code> object, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>ref &lt;- create_genome(4, 10)
ref$set_names(c("a", "b", "c", "d"))

</pre>
</div>


<hr>
<a id="method-ref_genome-clean_names"></a>



<h4>Method <code>clean_names()</code></h4>

<p>Clean chromosome names, converting <code style="white-space: pre;">&#8288;" :;=%,\\|/\"\'"&#8288;</code> to <code>"_"</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ref_genome$clean_names()</pre></div>



<h5>Returns</h5>

<p>This <code>R6</code> object, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>ref &lt;- create_genome(4, 10)
ref$set_names(c("a:", "b|", "c;", "d'"))
ref$clean_names()

</pre>
</div>


<hr>
<a id="method-ref_genome-add_chroms"></a>



<h4>Method <code>add_chroms()</code></h4>

<p>Add one or more chromosomes.
</p>


<h5>Usage</h5>

<div class="r"><pre>ref_genome$add_chroms(new_chroms, new_names = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>new_chroms</code></dt><dd><p>Character vector of DNA strings representing new chromosomes.</p>
</dd>
<dt><code>new_names</code></dt><dd><p>Optional character vector of names for the new chromosomes.
It should be the same length as <code>new_chroms</code>.
If <code>NULL</code>, new names will be automatically generated. Defaults to <code>NULL</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This <code>R6</code> object, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>ref &lt;- create_genome(4, 10)
ref$add_chroms("TCAGTCAG")
</pre>
</div>


<hr>
<a id="method-ref_genome-rm_chroms"></a>



<h4>Method <code>rm_chroms()</code></h4>

<p>Remove one or more chromosomes by name
</p>


<h5>Usage</h5>

<div class="r"><pre>ref_genome$rm_chroms(chrom_names)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>chrom_names</code></dt><dd><p>Vector of the name(s) of the chromosome(s) to remove.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This <code>R6</code> object, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>ref &lt;- create_genome(4, 10)
ref$set_names(c("a", "b", "c", "d"))
ref$rm_chroms("b")

</pre>
</div>


<hr>
<a id="method-ref_genome-merge_chroms"></a>



<h4>Method <code>merge_chroms()</code></h4>

<p>Merge chromosomes into one.
</p>


<h5>Usage</h5>

<div class="r"><pre>ref_genome$merge_chroms(chrom_names)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>chrom_names</code></dt><dd><p>Vector of the names of the chromosomes to merge into one.
Duplicates are not allowed, and chromosomes are merged in the order
they're provided.
If this is <code>NULL</code>, then all chromosomes are merged after first
shuffling their order.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This <code>R6</code> object, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>ref &lt;- create_genome(4, 10)
ref$merge_chroms(ref$chrom_names()[1:2])
ref$merge_chroms(NULL)

</pre>
</div>


<hr>
<a id="method-ref_genome-filter_chroms"></a>



<h4>Method <code>filter_chroms()</code></h4>

<p>Filter chromosomes by size or for a proportion of total bases.
</p>


<h5>Usage</h5>

<div class="r"><pre>ref_genome$filter_chroms(threshold, method)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>threshold</code></dt><dd><p>Number used as a threshold. If <code>method == "size"</code>,
then this is the minimum length of a chromosome that will remain after
filtering.
If <code>method == "prop"</code>, chromosomes are first size-sorted, then
the largest <code>N</code> chromosomes are retained that allow at least
<code style="white-space: pre;">&#8288;threshold * sum(&lt;all chromosome sizes&gt;)&#8288;</code> base pairs remaining after
filtering.</p>
</dd>
<dt><code>method</code></dt><dd><p>String indicating which filter method to use: chromosome size
(<code>method = "size"</code>) or proportion of total bases (<code>method = "prop"</code>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This <code>R6</code> object, invisibly.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>ref &lt;- create_genome(4, 100, 50)
ref$filter_chroms(90, "size")
ref$filter_chroms(0.4, "prop")

</pre>
</div>


<hr>
<a id="method-ref_genome-replace_Ns"></a>



<h4>Method <code>replace_Ns()</code></h4>

<p>Replace <code>N</code>s in the reference genome.
</p>


<h5>Usage</h5>

<div class="r"><pre>ref_genome$replace_Ns(pi_tcag, n_threads = 1, show_progress = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pi_tcag</code></dt><dd><p>Numeric vector (length 4) indicating the sampling weights
for <code>T</code>, <code>C</code>, <code>A</code>, and <code>G</code>, respectively, for generating new nucleotides
with which to replace the <code>N</code>s.</p>
</dd>
<dt><code>n_threads</code></dt><dd><p>Optional integer specifying the threads to use.
Ignored if the package wasn't compiled with OpenMP. Defaults to <code>1</code>.</p>
</dd>
<dt><code>show_progress</code></dt><dd><p>Optional logical indicating whether to show a
progress bar. Defaults to <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This <code>R6</code> object, invisibly.
</p>




<h3>See Also</h3>

<p><code><a href="#topic+read_fasta">read_fasta</a></code> <code><a href="#topic+create_genome">create_genome</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `ref_genome$set_names`
## ------------------------------------------------

ref &lt;- create_genome(4, 10)
ref$set_names(c("a", "b", "c", "d"))


## ------------------------------------------------
## Method `ref_genome$clean_names`
## ------------------------------------------------

ref &lt;- create_genome(4, 10)
ref$set_names(c("a:", "b|", "c;", "d'"))
ref$clean_names()


## ------------------------------------------------
## Method `ref_genome$add_chroms`
## ------------------------------------------------

ref &lt;- create_genome(4, 10)
ref$add_chroms("TCAGTCAG")

## ------------------------------------------------
## Method `ref_genome$rm_chroms`
## ------------------------------------------------

ref &lt;- create_genome(4, 10)
ref$set_names(c("a", "b", "c", "d"))
ref$rm_chroms("b")


## ------------------------------------------------
## Method `ref_genome$merge_chroms`
## ------------------------------------------------

ref &lt;- create_genome(4, 10)
ref$merge_chroms(ref$chrom_names()[1:2])
ref$merge_chroms(NULL)


## ------------------------------------------------
## Method `ref_genome$filter_chroms`
## ------------------------------------------------

ref &lt;- create_genome(4, 100, 50)
ref$filter_chroms(90, "size")
ref$filter_chroms(0.4, "prop")

</code></pre>

<hr>
<h2 id='sub_models'>Construct necessary information for substitution models.</h2><span id='topic+sub_models'></span><span id='topic+sub_JC69'></span><span id='topic+sub_K80'></span><span id='topic+sub_F81'></span><span id='topic+sub_HKY85'></span><span id='topic+sub_F84'></span><span id='topic+sub_TN93'></span><span id='topic+sub_GTR'></span><span id='topic+sub_UNREST'></span>

<h3>Description</h3>

<p>For a more detailed explanation, see <code>vignette("sub-models")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sub_JC69(lambda, mu = 1, gamma_shape = NULL, gamma_k = 5, invariant = 0)

sub_K80(alpha, beta, mu = 1, gamma_shape = NULL, gamma_k = 5, invariant = 0)

sub_F81(pi_tcag, mu = 1, gamma_shape = NULL, gamma_k = 5, invariant = 0)

sub_HKY85(
  pi_tcag,
  alpha,
  beta,
  mu = 1,
  gamma_shape = NULL,
  gamma_k = 5,
  invariant = 0
)

sub_F84(
  pi_tcag,
  beta,
  kappa,
  mu = 1,
  gamma_shape = NULL,
  gamma_k = 5,
  invariant = 0
)

sub_TN93(
  pi_tcag,
  alpha_1,
  alpha_2,
  beta,
  mu = 1,
  gamma_shape = NULL,
  gamma_k = 5,
  invariant = 0
)

sub_GTR(
  pi_tcag,
  abcdef,
  mu = 1,
  gamma_shape = NULL,
  gamma_k = 5,
  invariant = 0
)

sub_UNREST(Q, mu = 1, gamma_shape = NULL, gamma_k = 5, invariant = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sub_models_+3A_lambda">lambda</code></td>
<td>
<p>Substitution rate for all possible substitutions.</p>
</td></tr>
<tr><td><code id="sub_models_+3A_mu">mu</code></td>
<td>
<p>Total rate of substitutions. Defaults to <code>1</code>, which makes branch lengths
in units of substitutions per site. Passing <code>NULL</code> results in no scaling.</p>
</td></tr>
<tr><td><code id="sub_models_+3A_gamma_shape">gamma_shape</code></td>
<td>
<p>Numeric shape parameter for discrete Gamma distribution used for
among-site variability. Values must be greater than zero.
If this parameter is <code>NULL</code>, among-site variability is not included.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="sub_models_+3A_gamma_k">gamma_k</code></td>
<td>
<p>The number of categories to split the discrete Gamma distribution
into. Values must be an integer in the range <code style="white-space: pre;">&#8288;[2,255]&#8288;</code>.
This argument is ignored if <code>gamma_shape</code> is <code>NA</code>.
Defaults to <code>5</code>.</p>
</td></tr>
<tr><td><code id="sub_models_+3A_invariant">invariant</code></td>
<td>
<p>Proportion of sites that are invariant.
Values must be in the range <code style="white-space: pre;">&#8288;[0,1)&#8288;</code>.
Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="sub_models_+3A_alpha">alpha</code></td>
<td>
<p>Substitution rate for transitions.</p>
</td></tr>
<tr><td><code id="sub_models_+3A_beta">beta</code></td>
<td>
<p>Substitution rate for transversions.</p>
</td></tr>
<tr><td><code id="sub_models_+3A_pi_tcag">pi_tcag</code></td>
<td>
<p>Vector of length 4 indicating the equilibrium distributions of
T, C, A, and G respectively. Values must be &gt;= 0, and
they are forced to sum to 1.</p>
</td></tr>
<tr><td><code id="sub_models_+3A_kappa">kappa</code></td>
<td>
<p>The transition/transversion rate ratio.</p>
</td></tr>
<tr><td><code id="sub_models_+3A_alpha_1">alpha_1</code></td>
<td>
<p>Substitution rate for T &lt;-&gt; C transition.</p>
</td></tr>
<tr><td><code id="sub_models_+3A_alpha_2">alpha_2</code></td>
<td>
<p>Substitution rate for A &lt;-&gt; G transition.</p>
</td></tr>
<tr><td><code id="sub_models_+3A_abcdef">abcdef</code></td>
<td>
<p>A vector of length 6 that contains the off-diagonal elements
for the substitution rate matrix.
See <code>vignette("sub-models")</code> for how the values are ordered in the matrix.</p>
</td></tr>
<tr><td><code id="sub_models_+3A_q">Q</code></td>
<td>
<p>Matrix of substitution rates for &quot;T&quot;, &quot;C&quot;, &quot;A&quot;, and &quot;G&quot;, respectively.
Item <code>Q[i,j]</code> is the rate of substitution from nucleotide <code>i</code> to nucleotide <code>j</code>.
Do not include indel rates here!
Values on the diagonal are calculated inside the function so are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>sub_info</code> object, which is an R6 class that wraps the info needed for
the <code>create_haplotypes</code> function.
It does not allow the user to directly manipulate the info inside, as that
should be done using the <code>sub_models</code> functions.
You can use the following methods from the class to view information:
</p>

<dl>
<dt><code>Q()</code></dt><dd><p>View a list of substitution rate matrices,
one for each Gamma category.</p>
</dd>
<dt><code>pi_tcag()</code></dt><dd><p>View the equilibrium nucleotide frequencies.</p>
</dd>
<dt><code>gammas()</code></dt><dd><p>View the discrete Gamma-class values.</p>
</dd>
<dt><code>invariant()</code></dt><dd><p>View the proportion of invariant sites.</p>
</dd>
<dt><code>model()</code></dt><dd><p>View the substitution model.</p>
</dd>
<dt><code>U()</code></dt><dd><p>View list of the <code>U</code> matrices (one matrix per Gamma category)
used for calculating transition-probability matrices.
This is empty for UNREST models.</p>
</dd>
<dt><code>Ui()</code></dt><dd><p>View list of the <code>U^-1</code> matrices (one matrix per Gamma category)
used for calculating transition-probability matrices.
This is empty for UNREST models.</p>
</dd>
<dt><code>L()</code></dt><dd><p>View list of the lambda vectors (one vector per Gamma category)
used for calculating transition-probability matrices.
This is empty for UNREST models.</p>
</dd>
</dl>



<h3>Functions</h3>


<ul>
<li> <p><code>sub_JC69()</code>: JC69 model.
</p>
</li>
<li> <p><code>sub_K80()</code>: K80 model.
</p>
</li>
<li> <p><code>sub_F81()</code>: F81 model.
</p>
</li>
<li> <p><code>sub_HKY85()</code>: HKY85 model.
</p>
</li>
<li> <p><code>sub_F84()</code>: F84 model.
</p>
</li>
<li> <p><code>sub_TN93()</code>: TN93 model.
</p>
</li>
<li> <p><code>sub_GTR()</code>: GTR model.
</p>
</li>
<li> <p><code>sub_UNREST()</code>: UNREST model.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+create_haplotypes">create_haplotypes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Same substitution rate for all types:
obj_JC69 &lt;- sub_JC69(lambda = 0.1)

# Transitions 2x more likely than transversions:
obj_K80 &lt;- sub_K80(alpha = 0.2, beta = 0.1)

# Incorporating equilibrium frequencies:
obj_HKY85 &lt;- sub_HKY85(pi_tcag = c(0.1, 0.2, 0.3, 0.4),
                       alpha = 0.2, beta = 0.1)

# 10-category Gamma distribution for among-site variability:
obj_K80 &lt;- sub_K80(alpha = 0.2, beta = 0.1,
                   gamma_shape = 1, gamma_k = 10)

# Invariant sites:
obj_K80 &lt;- sub_K80(alpha = 0.2, beta = 0.1,
                   invariant = 0.25)

</code></pre>

<hr>
<h2 id='write_fasta'>Write a <code>ref_genome</code> or <code>haplotypes</code> object to a FASTA file.</h2><span id='topic+write_fasta'></span>

<h3>Description</h3>

<p>This file produces 1 FASTA file for a <code>ref_genome</code> object and one file
for each haplotype in a <code>haplotypes</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_fasta(
  obj,
  out_prefix,
  compress = FALSE,
  comp_method = "bgzip",
  text_width = 80,
  show_progress = FALSE,
  n_threads = 1,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_fasta_+3A_obj">obj</code></td>
<td>
<p>A <code>ref_genome</code> or <code>haplotypes</code> object.</p>
</td></tr>
<tr><td><code id="write_fasta_+3A_out_prefix">out_prefix</code></td>
<td>
<p>Prefix for the output file.</p>
</td></tr>
<tr><td><code id="write_fasta_+3A_compress">compress</code></td>
<td>
<p>Logical specifying whether or not to compress output file, or
an integer specifying the level of compression, from 1 to 9.
If <code>TRUE</code>, a compression level of <code>6</code> is used.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="write_fasta_+3A_comp_method">comp_method</code></td>
<td>
<p>Character specifying which type of compression to use if any
is desired. Options include <code>"gzip"</code> and <code>"bgzip"</code>.
This is ignored if <code>compress</code> is <code>FALSE</code>. Defaults to <code>"bgzip"</code>.</p>
</td></tr>
<tr><td><code id="write_fasta_+3A_text_width">text_width</code></td>
<td>
<p>The number of characters per line in the output fasta file.
Defaults to <code>80</code>.</p>
</td></tr>
<tr><td><code id="write_fasta_+3A_show_progress">show_progress</code></td>
<td>
<p>Logical for whether to show a progress bar.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="write_fasta_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads to use if writing from a <code>haplotypes</code> object.
Threads are split among haplotypes, so it's not useful to provide more threads
than haplotypes.
This argument is ignored if <code>obj</code> is a <code>ref_genome</code> object, or if
OpenMP is not enabled.
Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="write_fasta_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical for whether to overwrite existing file(s) of the
same name, if they exist. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>

<hr>
<h2 id='write_vcf'>Write haplotype info from a <code>haplotypes</code> object to a VCF file.</h2><span id='topic+write_vcf'></span>

<h3>Description</h3>

<p>Compression in this function always uses <code>"bgzip"</code> for compatibility with <code>"tabix"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_vcf(
  haps,
  out_prefix,
  compress = FALSE,
  sample_matrix = NULL,
  show_progress = FALSE,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_vcf_+3A_haps">haps</code></td>
<td>
<p>A <code>haplotypes</code> object.</p>
</td></tr>
<tr><td><code id="write_vcf_+3A_out_prefix">out_prefix</code></td>
<td>
<p>Prefix for the output file.</p>
</td></tr>
<tr><td><code id="write_vcf_+3A_compress">compress</code></td>
<td>
<p>Logical specifying whether or not to compress output file, or
an integer specifying the level of compression, from 1 to 9.
If <code>TRUE</code>, a compression level of <code>6</code> is used.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="write_vcf_+3A_sample_matrix">sample_matrix</code></td>
<td>
<p>Matrix to specify how haplotypes are grouped into samples
if samples are not haploid. There should be one row for each sample, and
each row should contain indices or names for the haplotypes present in that sample.
Indices/names for haplotypes cannot be repeated.
Instead of repeating indices here, you should use the <code>dup_haps</code>
method of the <code>haplotypes</code> class to duplicate the necessary haplotype(s).
The number of columns indicates the ploidy level: 2 columns for diploid,
3 for triploid, 4 for tetraploid, and so on;
there is no limit to the ploidy level.
If this argument is <code>NULL</code>, it's assumed that each haplotype is its own
separate sample.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="write_vcf_+3A_show_progress">show_progress</code></td>
<td>
<p>Logical for whether to show a progress bar.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="write_vcf_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical for whether to overwrite existing file(s) of the
same name, if they exist. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
