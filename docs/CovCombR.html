<!DOCTYPE html><html><head><title>Help for package CovCombR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CovCombR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CovCombR-package'>
<p>Combine Partial Covariance / Relationship Matrices</p></a></li>
<li><a href='#BarleyPheno'><p>Phenotype data from 194 phenotype trials</p></a></li>
<li><a href='#CovComb'>
<p>Programs to combine partially observed (high dimensional) covariance matrices. Combining datasets this way, using relationships, is an alternative to imputation.</p></a></li>
<li><a href='#GetVarCov'>
<p>Asymptotic variance-covariance of the estimators</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Combine Partial Covariance / Relationship Matrices</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-01-08</td>
</tr>
<tr>
<td>Author:</td>
<td>Deniz Akdemir, Mohamed Somo, Julio Isidro Sanchez</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Deniz Akdemir &lt;deniz.akdemir.work@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Combine partial covariance matrices using a Wishart-EM algorithm. 
    Methods are described in the November 2019 article by Akdemir et al. 
    <a href="https://www.biorxiv.org/content/10.1101/857425v1">https://www.biorxiv.org/content/10.1101/857425v1</a>.
    It can be used to combine partially overlapping covariance matrices 
    from independent trials, partially overlapping multi-view relationship
    data from genomic experiments, partially overlapping Gaussian graphs
    described by their covariance structures. 
    High dimensional covariance estimation, 
    multi-view data integration.
    high dimensional covariance graph estimation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, nlme, CholWishart</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, plyr, spcov, qgraph, igraph</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-01-13 21:57:38 UTC; denizakdemir</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-01-18 11:30:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='CovCombR-package'>
Combine Partial Covariance / Relationship Matrices
</h2><span id='topic+CovCombR-package'></span><span id='topic+CovCombR'></span>

<h3>Description</h3>

<p>Combine partial covariance matrices using a Wishart-EM algorithm. 
    Methods are described in the November 2019 article by Akdemir et al. 
    &lt;https://www.biorxiv.org/content/10.1101/857425v1&gt;.
    It can be used to combine partially overlapping covariance matrices 
    from independent trials, partially overlapping multi-view relationship
    data from genomic experiments, partially overlapping Gaussian graphs
    described by their covariance structures. 
    High dimensional covariance estimation, 
    multi-view data integration.
    high dimensional covariance graph estimation.
</p>


<h3>Details</h3>

<p>The input to the main program CovComb is a list of partial covariance matrices. The output is an estimated combined (high dimensional) covariance matrix. The output of the algorithm, the completed covariance matrix, can be used to make inferences about unobserved covariances, as an input to sparse covariance estimation algorithms, in covariance graph estimation, in discriminant analysis.
</p>


<h3>Author(s)</h3>

<p>Deniz Akdemir, Mohamed Somo, Julio Isidro Sanchez
</p>
<p>Maintainer: Deniz Akdemir &lt;deniz.akdemir.work@gmail.com&gt;
</p>


<h3>References</h3>

<p>Adventures in Multi-Omics I: Combining heterogeneous data sets via relationships matrices Deniz Akdemir, Julio Isidro Sanchez. &lt;https://www.biorxiv.org/content/10.1101/857425v1&gt;.
</p>

<hr>
<h2 id='BarleyPheno'>Phenotype data from 194 phenotype trials</h2><span id='topic+BarleyPheno'></span>

<h3>Description</h3>

<p>The data was downloaded from &lt;https://triticeaetoolbox.org/barley/&gt; and curated. The data is in list format. Each element in the list is data from one phenotypic trial concerning a sample of traits. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(BarleyPheno)
</code></pre>

<hr>
<h2 id='CovComb'>
Programs to combine partially observed (high dimensional) covariance matrices. Combining datasets this way, using relationships, is an alternative to imputation.
</h2><span id='topic+CovComb'></span>

<h3>Description</h3>

<p>Use for combining partially observed covariance matrices.
This function can be used for combining data from independent experiments by combining the estimated covariance or relationship matrices learned from each of the experiments. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CovComb(Klist = NULL, Kinvlist = NULL,
lambda = 1, w = 1, nu = 1000,
maxiter = 500, miniter = 100, Kinit = NULL, 
tolparconv = 1e-04,
loglik=FALSE, plotll=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovComb_+3A_klist">Klist</code></td>
<td>

<p>A list of covariance / relationship matrices with row and column names to be combined.
</p>
</td></tr>
<tr><td><code id="CovComb_+3A_kinvlist">Kinvlist</code></td>
<td>

<p>A list of inverse covariance / relationship matrices with row and column names to be combined, default NULL.
</p>
</td></tr>
<tr><td><code id="CovComb_+3A_lambda">lambda</code></td>
<td>

<p>A scalar learning rate parameter, between 0 and 1. 1 is the default value. 
</p>
</td></tr>
<tr><td><code id="CovComb_+3A_w">w</code></td>
<td>

<p>Weight parameter, a vector of the same length as Klist, elements corresponding to weights assigned to each of the covariance matrices. Default is 1. 
</p>
</td></tr>
<tr><td><code id="CovComb_+3A_nu">nu</code></td>
<td>

<p>Degrees of freedom parameter. It is either a scalar (same degrees of freeom to each of the covariance component) or a vector of the same length as Klist elements of which correspond to each of the covariance matrices. Currently, only scalar nu is accepted. Default is 1000. the value of nu needs to be larger than the variables in the covariance matrix.
</p>
</td></tr>
<tr><td><code id="CovComb_+3A_maxiter">maxiter</code></td>
<td>

<p>Maximum number of iterations before stop. Default value is 500.
</p>
</td></tr>
<tr><td><code id="CovComb_+3A_miniter">miniter</code></td>
<td>

<p>Minimum number of iterations before the convergence criterion is checked. Default value is 100.
</p>
</td></tr>
<tr><td><code id="CovComb_+3A_kinit">Kinit</code></td>
<td>

<p>Initial estimate of the combined covariance matrix. Default value is an identity matrix. 
</p>
</td></tr>
<tr><td><code id="CovComb_+3A_tolparconv">tolparconv</code></td>
<td>

<p>The minimum change in convergence criteria before stopping the algorithm unless the maxiter is reached. This is not evaluated in the first miniter iterations. Default value is 1e-4.
</p>
</td></tr>
<tr><td><code id="CovComb_+3A_loglik">loglik</code></td>
<td>

<p>Logical with default FALSE. Return the path of the log-likelihood or not.
</p>
</td></tr>
<tr><td><code id="CovComb_+3A_plotll">plotll</code></td>
<td>

<p>Logical with default FALSE. Plot the path of the log-likelihood or not.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">A=\left\{a_1, a_2, \ldots, a_m \right\}</code> be the set of not necessarily disjoint subsets of genotypes covering a set of <code class="reqn">K</code> (i.e., <code class="reqn">K= \cup_{i=1}^m a_i</code>) with total <code class="reqn">n</code> genotypes. Let <code class="reqn">G_{a_1}, G_{a_2},\ldots, G_{a_m}</code> be the corresponding sample of covariance matrices.
</p>
<p>Starting from an initial estimate <code class="reqn">\Sigma^{(0)}=\nu\Psi^{(0)},</code> the Wishart EM-Algorithm repeats updating the estimate of the covariance matrix until convergence: 
</p>
<p style="text-align: center;"><code class="reqn">  \Psi^{(t+1)} =\frac{1}{\nu m}\sum_{a\in A}P_a\left[ \begin{array}{cc}
          G_{aa} &amp; G_{aa}(B^{(t)}_{b|a})'  \\
          B^{(t)}_{b|a}G_{aa} &amp; \nu \Psi^{(t)}_{bb|a}+ B^{(t)}_{b|a}G_{aa}(B^{(t)}_{b|a})'
        \end{array}\right]P'_a</code>
</p>

<p>where <code class="reqn">B^{(t)}_{b|a}=\Psi^{(t)}_{ab}(\Psi^{(t)}_{aa})^{-1},</code> <code class="reqn">\Psi^{(t)}_{bb|a}=\Psi^{(t)}_{bb}-\Psi^{(t)}_{ab}(\Psi^{(t)}_{aa})^{-1}\Psi^{(t)}_{ba},</code> <code class="reqn">a</code>  is the set of genotypes in the given partial covariance matrix and <code class="reqn">b</code> is the set difference of <code class="reqn">K</code> and <code class="reqn">a.</code> The matrices <code class="reqn">P_a</code> are permutation matrices that put each matrix in the sum in the same order. The initial value, <code class="reqn">\Sigma^{(0)}</code> is usually assumed to be an identity matrix of dimesion <code class="reqn">n.</code>  The estimate <code class="reqn">\Psi^{(T)}</code> at the last iteration converts to the estimated covariance with <code class="reqn">\Sigma^{(T)}=\nu\Psi^{(T)}.</code>
</p>
<p>A weighted version of this algorithm can be obtained replacing <code class="reqn">G_{aa}</code> in above equations with <code class="reqn">G^{(w_a)}_{aa}=w_aG_{aa}+(1-w_a)\nu\Psi^{(T)}</code> for a vector of weights <code class="reqn">(w_1,w_2,\ldots, w_m)'.</code>
</p>


<h3>Value</h3>

<p>Combined covariance matrix estimate. if loglik is TRUE, the this is a list with first element equal to the covariance estimate, second element in the list is the path of the log-likelihood.
</p>


<h3>Author(s)</h3>

<p>Deniz Akdemir // Maintainer: Deniz Akdemir
<a href="mailto:deniz.akdemir.work@gmail.com">deniz.akdemir.work@gmail.com</a>
</p>


<h3>References</h3>

<p>- Adventures in Multi-Omics I: Combining heterogeneous data sets via relationships matrices. Deniz Akdemir, Julio Isidro Sanchez. bioRxiv, November 28, 2019
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####Using Iris data for a simple example
data(iris)
colnames(iris)&lt;-c("S.L","S.W","P.L","P.W","Species")
iris$Species
##Setting seed for reproducability.
set.seed(1234)

###The input of the CovComb is a list of partial 
#covariance matrices for the species 'virginica'.
CovList&lt;-vector(mode="list", length=3)
CovList[[1]]&lt;-cov(iris[sample(101:150,20),c(1,2)])
CovList[[2]]&lt;-cov(iris[sample(101:150,25),c(1,3)])
CovList[[3]]&lt;-cov(iris[sample(101:150,30),c(2,4)])
###Note that the covariances between the variables 
##1 and 2, 2 and 3, and 3 and 4 are not observed in 
##the above. We will use these covariance matrices 
##to obtain a 4 by 4 covariance matrix that estimates 
##these unobserved covariances.

library(CovCombR)
outCovComb&lt;-CovComb(CovList, nu=40)
###
#####Compare the results with what we would get
#if we observed all data. 
outCovComb
cov(iris[101:150,1:4])

####Compare the same based on correlations.
cov2cor(outCovComb)
cov2cor(cov(iris[101:150,1:4]))

####Here is a simple plot for visual comparison.

image(cov2cor(outCovComb),xlab="", ylab="", axes = FALSE, main="Combined")
axis(1, at = seq(0, 1, length=4),labels=rownames(outCovComb), las=2)
axis(2, at = seq(0, 1, length=4),labels=rownames(outCovComb), las=2)
image(cov2cor(cov(iris[101:150,1:4])),xlab="", ylab="", axes = FALSE,
main="All Data")
axis(1, at = seq(0, 1, length=4),labels=colnames(iris[,1:4]), las=2)
axis(2, at = seq(0, 1, length=4),labels=colnames(iris[,1:4]), las=2)



#### Using Weights
outCovCombhtedwgt&lt;-CovComb(CovList, nu=75,w=c(20/75,25/75,30/75))
cov2cor(outCovCombhtedwgt)



####Refit and plot log-likelihood path
outCovCombhtedwgt&lt;-CovComb(CovList, nu=75,w=c(20/75,25/75,30/75),
loglik=TRUE, plotll=TRUE)



#### For small problems (when the sample size
## moderate and the number of variables is small),
## we can try using optimization to estimate the degrees of freedom 
## parameter nu. Nevetheless, this is not always satisfactory. 
## The value of nu does not change the 
## estimate of the covariance, but it is 
## important for evaluating estimation errors. 
negativellfornu&lt;-function(nu){
outCovComb&lt;-CovComb(CovList, nu=ceiling(nu), loglik=TRUE, plotll=FALSE)
return(-max(outCovComb[[2]]))
}


optout&lt;-optimize(negativellfornu,interval=c(20,100),tol=1e-3)
est.df&lt;-ceiling(optout$minimum)
est.df
#&gt; est.df= 39


####### Estimated nu can be used as an input
## to other statistical procedures
## such as hypothesis testing about 
## the covariance parameters, graphical modeling, 
## sparse covariance estimation, etc,....

</code></pre>

<hr>
<h2 id='GetVarCov'>
Asymptotic variance-covariance of the estimators
</h2><span id='topic+GetVarCov'></span>

<h3>Description</h3>

<p>Obtain the asymptotic covariance metrix for the combined covariance estimate. you need to run the <code>CovComb</code> first and then use the estimated covariace matrix as an input to this function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetVarCov(Hmat, Klist, nu = 100, w=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetVarCov_+3A_hmat">Hmat</code></td>
<td>

<p>The estimated covariace matrix. Output from <code>CovComb</code>.
</p>
</td></tr>
<tr><td><code id="GetVarCov_+3A_klist">Klist</code></td>
<td>

<p>A list of covariance / relationship matrices with row and column names to be combined.
</p>
</td></tr>
<tr><td><code id="GetVarCov_+3A_w">w</code></td>
<td>

<p>Weight parameter, a vector of the same length as Klist, elements corresponding to weights assigned to each of the covariance matrices. Default is 1. 
</p>
</td></tr>
<tr><td><code id="GetVarCov_+3A_nu">nu</code></td>
<td>

<p>Degrees of freedom parameter. It is either a scalar (same degrees of freeom to each of the covariance component) or a vector of the same length as Klist elements of which correspond to each of the covariance matrices. Currently, only scalar nu is accepted. Default is 1000. the value of nu needs to be larger than the variables in the covariance matrix.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Asymptotic sampling covariance matrix for the combined covariance estimate. The diagonals elements correspond to the sampling variances of the covariance estimates.  
</p>


<h3>Author(s)</h3>

<p>Deniz Akdemir // Maintainer: Deniz Akdemir
<a href="mailto:deniz.akdemir.work@gmail.com">deniz.akdemir.work@gmail.com</a>
</p>


<h3>References</h3>

<p>- Adventures in Multi-Omics I: Combining heterogeneous data sets via relationships matrices. Deniz Akdemir, Julio Isidro Sanchez. bioRxiv, November 28, 2019
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mtcars")
my_data &lt;- mtcars[, c(1,3,4,5)]
dim(my_data)
# print the first few rows
head(my_data)
#ArtificiaLly making 3 partial covariance matrices! 
#These are the partial covariances obtained from 
#independent  multi-view experiments.
set.seed(123)
cov12&lt;-cov(my_data[sample(nrow(my_data),20),1:2])
cov23&lt;-cov(my_data[sample(nrow(my_data),20),2:3])
cov34&lt;-cov(my_data[sample(nrow(my_data),20),3:4])

# Combine covariances using the package
Combined&lt;-CovComb(Klist=list(cov12,cov23,cov34))
# Get asyptotic sampling variance- covariance matrix.  
SEMAT&lt;-GetVarCov(Hmat=Combined,
Klist=list(cov12,cov23,cov34),nu=20,w=1)
## Square root of the diagonal elements are 
## the asymptotic standard errors. 
round(sqrt(diag(SEMAT)),3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
