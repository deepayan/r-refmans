<!DOCTYPE html><html><head><title>Help for package ngspatial</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ngspatial}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#A'>
<p>Adjacency matrix for the infant mortality data.</p></a></li>
<li><a href='#adjacency.matrix'><p>Return an adjacency matrix for a square lattice.</p></a></li>
<li><a href='#autologistic'><p>Fit a centered autologistic model using maximum pseudolikelihood estimation or MCMC for Bayesian inference.</p></a></li>
<li><a href='#infant'>
<p>Infant mortality data.</p></a></li>
<li><a href='#negbinomial'><p>Family function for negative binomial GLMs.</p></a></li>
<li><a href='#rautologistic'><p>Return a perfect sample from a centered autologistic model.</p></a></li>
<li><a href='#residuals.autologistic'><p>Extract model residuals.</p></a></li>
<li><a href='#residuals.sparse.sglmm'><p>Extract model residuals.</p></a></li>
<li><a href='#sparse.sglmm'><p>Fit a sparse SGLMM.</p></a></li>
<li><a href='#summary.autologistic'><p>Print a summary of a centered autologistic model fit.</p></a></li>
<li><a href='#summary.sparse.sglmm'><p>Print a summary of a sparse SGLMM fit.</p></a></li>
<li><a href='#vcov.autologistic'><p>Return the estimated covariance matrix for an <code>autologistic</code> model object.</p></a></li>
<li><a href='#vcov.sparse.sglmm'><p>Return the covariance matrix of the regression parameters of a <code>sparse.sglmm</code> model object.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.2-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-05-08</td>
</tr>
<tr>
<td>Title:</td>
<td>Fitting the Centered Autologistic and Sparse Spatial Generalized
Linear Mixed Models for Areal Data</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Author:</td>
<td>John Hughes &lt;drjphughesjr@gmail.com&gt; and Xiaohui Cui</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Hughes &lt;drjphughesjr@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>Rcpp, batchmeans</td>
</tr>
<tr>
<td>Suggests:</td>
<td>parallel, pbapply</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for analyzing spatial data, especially non-
    Gaussian areal data. The current version supports the sparse restricted
    spatial regression model of Hughes and Haran (2013) &lt;<a href="https://doi.org/10.1111%2Fj.1467-9868.2012.01041.x">doi:10.1111/j.1467-9868.2012.01041.x</a>&gt;,
	the centered autologistic model of Caragea and Kaiser (2009) &lt;<a href="https://doi.org/10.1198%2Fjabes.2009.07032">doi:10.1198/jabes.2009.07032</a>&gt;,
	and the Bayesian spatial filtering model of Hughes (2017) &lt;<a href="https://arxiv.org/abs/1706.04651">arXiv:1706.04651</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RcppModules:</td>
<td>ngspatialmod</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-05-08 13:33:18 UTC; jphughesjr</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-05-08 16:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='A'>
Adjacency matrix for the infant mortality data.
</h2><span id='topic+A'></span>

<h3>Description</h3>

<p>A contains the adjacency matrix for the infant mortality data analyzed in (Hughes and Haran, 2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(A)</code></pre>


<h3>Source</h3>

<p>The data were obtained from the 2008 Area Resource File (ARF), a county-level database maintained by the Bureau of Health Professions, Health Resources and Services Administration, US Department of Health and Human Services.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(A)
</code></pre>

<hr>
<h2 id='adjacency.matrix'>Return an adjacency matrix for a square lattice.</h2><span id='topic+adjacency.matrix'></span>

<h3>Description</h3>

<p>Return an adjacency matrix for a square lattice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjacency.matrix(m, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjacency.matrix_+3A_m">m</code></td>
<td>
<p>the number of rows in the lattice.</p>
</td></tr>
<tr><td><code id="adjacency.matrix_+3A_n">n</code></td>
<td>
<p>the number of columns in the lattice. Defaults to <code>NULL</code>. If missing, the lattice is assumed to be <code>m</code> by <code>m</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function builds the adjacency matrix for the <code>m</code> by <code>n</code> square lattice.
</p>


<h3>Value</h3>

<p>A matrix <code class="reqn">A</code> of 0s and 1s, where <code class="reqn">A_{ij}</code> is equal to 1 iff vertices <code class="reqn">i</code> and <code class="reqn">j</code> are adjacent.
</p>

<hr>
<h2 id='autologistic'>Fit a centered autologistic model using maximum pseudolikelihood estimation or MCMC for Bayesian inference.</h2><span id='topic+autologistic'></span>

<h3>Description</h3>

<p>Fit a centered autologistic model using maximum pseudolikelihood estimation or MCMC for Bayesian inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autologistic(formula, data, A, method = c("PL", "Bayes"), model = TRUE,
  x = FALSE, y = FALSE, verbose = FALSE, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autologistic_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code>: a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="autologistic_+3A_data">data</code></td>
<td>
<p>an optional data frame, list, or environment (or object coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the variables in the model. If not found in <code>data</code>, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>autologistic</code> is called.</p>
</td></tr>
<tr><td><code id="autologistic_+3A_a">A</code></td>
<td>
<p>the adjacency matrix for the underlying graph. The matrix need not be binary, but it must be numeric and symmetric.</p>
</td></tr>
<tr><td><code id="autologistic_+3A_method">method</code></td>
<td>
<p>the method to use for inference. &ldquo;<code>PL</code>&rdquo; (the default) enables maximum pseudolikelihood estimation, and &ldquo;<code>Bayes</code>&rdquo; enables Bayesian inference.</p>
</td></tr>
<tr><td><code id="autologistic_+3A_model">model</code></td>
<td>
<p>a logical value indicating whether the model frame should be included as a component of the returned value.</p>
</td></tr>
<tr><td><code id="autologistic_+3A_x">x</code></td>
<td>
<p>a logical value indicating whether the model matrix used in the fitting process should be returned as a component of the returned value.</p>
</td></tr>
<tr><td><code id="autologistic_+3A_y">y</code></td>
<td>
<p>a logical value indicating whether the response vector used in the fitting process should be returned as a component of the returned value.</p>
</td></tr>
<tr><td><code id="autologistic_+3A_verbose">verbose</code></td>
<td>
<p>a logical value indicating whether to print various messages to the screen, including progress updates when <code>method</code> is &ldquo;<code>Bayes</code>&rdquo;. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="autologistic_+3A_control">control</code></td>
<td>
<p>a list of the following control parameters.
</p>

<dl>
<dt><code>confint</code></dt><dd><p> (PL) the method for computing confidence intervals. The possible values are &ldquo;<code>sandwich</code>&rdquo; (the default), &ldquo;<code>bootstrap</code>&rdquo;, and &ldquo;<code>none</code>&rdquo;.</p>
</dd>
<dt><code>sigma</code></dt><dd><p> (Bayes) the common standard deviation for <code class="reqn">\beta</code>'s prior distribution. Defaults to 1,000.</p>
</dd>
<dt><code>eta.max</code></dt><dd><p> (Bayes) the right endpoint for <code class="reqn">\eta</code>'s prior distribution. Defaults to 2.</p>
</dd>
<dt><code>bootit</code></dt><dd><p> (PL) the size of the bootstrap sample. This applies when <code>confint</code> is &ldquo;<code>sandwich</code>&rdquo; or &ldquo;<code>bootstrap</code>&rdquo;, since samples from the fitted model are needed in both cases. Defaults to 1,000.</p>
</dd>
<dt><code>trainit</code></dt><dd><p> (Bayes) the length of the training run. Defaults to 100,000.</p>
</dd>
<dt><code>minit</code></dt><dd><p> (Bayes) the minimum number of posterior samples. Defaults to 100,000.</p>
</dd>
<dt><code>maxit</code></dt><dd><p> (Bayes) the maximum number of posterior samples. Defaults to 1,000,000.</p>
</dd>
<dt><code>tol</code></dt><dd><p> (Bayes) the tolerance. Defaults to 0.01.</p>
</dd>
<dt><code>parallel</code></dt><dd><p> (PL) a logical value indicating whether to parallelize the bootstrap. This defaults to <code>TRUE</code> if the <span class="pkg">parallel</span> package is available.</p>
</dd>
<dt><code>type</code></dt><dd><p> (PL) the cluster type, one of &ldquo;<code>FORK</code>&rdquo;, &ldquo;<code>MPI</code>&rdquo;, &ldquo;<code>NWS</code>&rdquo;, &ldquo;<code>PSOCK</code>&rdquo;, or &ldquo;<code>SOCK</code>&rdquo; (default).</p>
</dd>
<dt><code>nodes</code></dt><dd><p> (PL) the number of slave nodes to create.</p>
</dd></dl>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the centered autologistic model of Caragea and Kaiser (2009) using maximum pseudolikelihood estimation or MCMC for Bayesian inference. 
The joint distribution for the centered autologistic model is 
</p>
<p style="text-align: center;"><code class="reqn">\pi(Z\mid\theta)=c(\theta)^{-1}\exp\left(Z^\prime X\beta - \eta Z^\prime A\mu + \frac{\eta}{2}Z^\prime AZ\right),</code>
</p>

<p>where <code class="reqn">\theta = (\beta^\prime, \eta)^\prime</code> is the parameter vector, <code class="reqn">c(\theta)</code> is an intractable normalizing function, <code class="reqn">Z</code> is the response vector, <code class="reqn">X</code> is the design matrix, 
<code class="reqn">\beta</code> is a <code class="reqn">(p-1)</code>-vector of regression coefficients, <code class="reqn">A</code> is the adjacency matrix for the underlying graph, <code class="reqn">\mu</code> is the vector of independence expectations, 
and <code class="reqn">\eta</code> is the spatial dependence parameter. 
<br />
<br />
Maximum pseudolikelihood estimation sidesteps the intractability of <code class="reqn">c(\theta)</code> by maximizing the product of the conditional likelihoods.
Confidence intervals are then obtained using a parametric bootstrap or a normal approximation, i.e., sandwich estimation. The bootstrap datasets are generated by perfect sampling (<code><a href="#topic+rautologistic">rautologistic</a></code>).
The bootstrap samples can be generated in parallel using the <span class="pkg">parallel</span> package.
<br />
<br />
Bayesian inference is obtained using the auxiliary variable algorithm of Moller et al. (2006).
The auxiliary variables are generated by perfect sampling.
<br />
<br />
The prior distributions are (1) zero-mean normal with independent coordinates for <code class="reqn">\beta</code>, and (2) uniform for <code class="reqn">\eta</code>.
The common standard deviation for the normal prior can be supplied by the user as control parameter <code>sigma</code>. The default is 1,000. The uniform prior has support [0, 2] by default, but the right endpoint can be supplied (as control parameter <code>eta.max</code>) by the user. 
<br />
<br />
The posterior covariance matrix of <code class="reqn">\theta</code> is estimated using samples obtained during a training run. The default number of iterations for the training run is 100,000, but this can be controlled by the user (via parameter <code>trainit</code>). The estimated covariance matrix is then used as the proposal variance for a Metropolis-Hastings random walk. The proposal distribution is normal. The posterior samples obtained during the second run are used for inference. The length of the run can be controlled by the user via parameters <code>minit</code>, <code>maxit</code>, and <code>tol</code>. The first determines the minimum number of iterations. If <code>minit</code> has been reached, the sampler will terminate when <code>maxit</code> is reached or all Monte Carlo standard errors are smaller than <code>tol</code>, whichever happens first. The default values for <code>minit</code>, <code>maxit</code>, and <code>tol</code> are 100,000; 1,000,000; and 0.01, respectively.
</p>


<h3>Value</h3>

<p><code>autologistic</code> returns an object of class &ldquo;<code>autologistic</code>&rdquo;, which is a list containing the following components.
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>the point estimate of <code class="reqn">\theta</code>.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted mean values, obtained by transforming the linear predictors by the inverse of the link function.</p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>
<p>the linear fit on link scale.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the response residuals.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the size of the bootstrap/posterior sample.</p>
</td></tr>
<tr><td><code>sample</code></td>
<td>
<p>(where relevant) an <code>iter</code> by <code class="reqn">p</code> matrix containing the bootstrap/posterior samples.</p>
</td></tr>
<tr><td><code>mcse</code></td>
<td>
<p>(where relevant) a <code class="reqn">p</code>-vector of Monte Carlo standard errors.</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>(where relevant) the estimated sandwich matrix.</p>
</td></tr>
<tr><td><code>accept</code></td>
<td>
<p>(Bayes) the acceptance rate for the MCMC sampler.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>if requested (the default), the <code>y</code> vector used.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>if requested, the model matrix.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>if requested (the default), the model frame.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the formula supplied.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the method used for inference.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>the integer code returned by <code><a href="stats.html#topic+optim">optim</a></code> subsequent to optimizing the pseudolikelihood.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>a character string to go along with <code>convergence</code>.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code><a href="stats.html#topic+terms">terms</a></code> object used.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the <code>data</code> argument.</p>
</td></tr>
<tr><td><code>xlevels</code></td>
<td>
<p>(where relevant) a record of the levels of the factors used in fitting.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>a list containing the names and values of the control parameters.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>the value of the negative log pseudolikelihood at its minimum.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Caragea, P. and Kaiser, M. (2009) Autologistic models with interpretable parameters. <em>Journal of Agricultural, Biological, and Environmental Statistics</em>, <b>14</b>(3), 281&ndash;300.
</p>
<p>Hughes, J., Haran, M. and Caragea, P. C. (2011) Autologistic models for binary data on a lattice. <em>Environmetrics</em>, <b>22</b>(7), 857&ndash;871.
</p>
<p>Moller, J., Pettitt, A., Berthelsen, K., and Reeves, R. (2006) An efficient Markov chain Monte Carlo method for distributions with intractable normalising constants. <em>Biometrika</em>, <b>93</b>(2), 451&ndash;458.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rautologistic">rautologistic</a></code>, <code><a href="#topic+residuals.autologistic">residuals.autologistic</a></code>, <code><a href="#topic+summary.autologistic">summary.autologistic</a></code>, <code><a href="#topic+vcov.autologistic">vcov.autologistic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Use the 20 x 20 square lattice as the underlying graph.

n = 20
A = adjacency.matrix(n)

# Assign coordinates to each vertex such that the coordinates are restricted to the unit square
# centered at the origin.

x = rep(0:(n - 1) / (n - 1), times = n) - 0.5
y = rep(0:(n - 1) / (n - 1), each = n) - 0.5
X = cbind(x, y)                                 # Use the vertex locations as spatial covariates.
beta = c(2, 2)                                  # These are the regression coefficients.
col1 = "white"
col2 = "black"
colfunc = colorRampPalette(c(col1, col2))

# Simulate a dataset with the above mentioned regression component and eta equal to 0.6. This
# value of eta corresponds to dependence that is moderate in strength.

theta = c(beta, eta = 0.6)
set.seed(123456)
Z = rautologistic(X, A, theta)

# Find the MPLE, and do not compute confidence intervals.

fit = autologistic(Z ~ X - 1, A = A, control = list(confint = "none"))
summary(fit)

# The following examples are not executed by default since the computation is time consuming.

# Compute confidence intervals based on the normal approximation. Estimate the "filling" in the
# sandwich matrix using a parallel parametric bootstrap, where the computation is distributed
# across six cores on the host workstation.

# set.seed(123456)
# fit = autologistic(Z ~ X - 1, A = A, verbose = TRUE,
#                   control = list(confint = "sandwich", nodes = 6))
# summary(fit)

# Compute confidence intervals based on a parallel parametric bootstrap. Use a bootstrap sample
# of size 500, and distribute the computation across six cores on the host workstation.

# set.seed(123456)
# fit = autologistic(Z ~ X - 1, A = A, verbose = TRUE,
#                   control = list(confint = "bootstrap", bootit = 500, nodes = 6))
# summary(fit)

# Do MCMC for Bayesian inference. The length of the training run will be 10,000, and
# the length of the subsequent inferential run will be at least 10,000.

# set.seed(123456)
# fit = autologistic(Z ~ X - 1, A = A, verbose = TRUE, method = "Bayes",
#                   control = list(trainit = 10000, minit = 10000, sigma = 1000))
# summary(fit)
</code></pre>

<hr>
<h2 id='infant'>
Infant mortality data.
</h2><span id='topic+infant'></span>

<h3>Description</h3>

<p>infant contains the infant mortality data analyzed in (Hughes and Haran, 2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(infant)</code></pre>


<h3>Source</h3>

<p>The data were obtained from the 2008 Area Resource File (ARF), a county-level database maintained by the Bureau of Health Professions, Health Resources and Services Administration, US Department of Health and Human Services.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(infant)
</code></pre>

<hr>
<h2 id='negbinomial'>Family function for negative binomial GLMs.</h2><span id='topic+negbinomial'></span>

<h3>Description</h3>

<p>Provides the information required to apply a sparse SGLMM to conditionally negative binomial outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>negbinomial(theta = stop("'theta' must be specified."), link = "log")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="negbinomial_+3A_theta">theta</code></td>
<td>
<p>the dispersion parameter (must be positive).</p>
</td></tr>
<tr><td><code id="negbinomial_+3A_link">link</code></td>
<td>
<p>the link function, as a character string, name, or one-element character vector, specifying one of <code>log</code>, <code>sqrt</code>, or <code>identity</code>, or an object of class &ldquo;<code><a href="stats.html#topic+family">link-glm</a></code>&rdquo;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &ldquo;<code>family</code>&rdquo;, a list of functions and expressions needed to fit a negative binomial GLM.
</p>

<hr>
<h2 id='rautologistic'>Return a perfect sample from a centered autologistic model.</h2><span id='topic+rautologistic'></span>

<h3>Description</h3>

<p>Return a perfect sample from a centered autologistic model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rautologistic(X, A, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rautologistic_+3A_x">X</code></td>
<td>
<p>the design matrix.</p>
</td></tr>
<tr><td><code id="rautologistic_+3A_a">A</code></td>
<td>
<p>the adjacency matrix for the underlying graph. The matrix need not be binary, but it must be numeric and symmetric.</p>
</td></tr>
<tr><td><code id="rautologistic_+3A_theta">theta</code></td>
<td>
<p>the vector of parameter values: <code class="reqn">\theta = (\beta^\prime, \eta)^\prime</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements a perfect sampler for the centered autologistic model. The sampler employs coupling from the past.
</p>


<h3>Value</h3>

<p>A vector that is distributed exactly according to the centered autologistic model with the given design matrix and parameter values.
</p>


<h3>References</h3>

<p>Moller, J. (1999) Perfect simulation of conditionally specified models. <em>Journal of the Royal Statistical Society, Series B, Methodological</em>, <b>61</b>, 251&ndash;264.
</p>
<p>Propp, J. G. and Wilson, D. B. (1996) Exact sampling with coupled Markov chains and applications to statistical mechanics. <em>Random Structures and Algorithms</em>, <b>9</b>(1-2), 223&ndash;252.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Use the 20 x 20 square lattice as the underlying graph.

n = 20
A = adjacency.matrix(n)

# Assign coordinates to each vertex such that the coordinates are restricted to the unit square
# centered at the origin.

x = rep(0:(n - 1) / (n - 1), times = n) - 0.5
y = rep(0:(n - 1) / (n - 1), each = n) - 0.5
X = cbind(x, y)                                 # Use the vertex locations as spatial covariates.
beta = c(2, 2)                                  # These are the regression coefficients.

# Simulate a dataset with the above mentioned regression component and eta equal to 0.6. This
# value of eta corresponds to dependence that is moderate in strength.

theta = c(beta, eta = 0.6)
set.seed(123456)
Z = rautologistic(X, A, theta)
</code></pre>

<hr>
<h2 id='residuals.autologistic'>Extract model residuals.</h2><span id='topic+residuals.autologistic'></span>

<h3>Description</h3>

<p>Extract model residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'autologistic'
residuals(object, type = c("deviance", "pearson",
  "response"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.autologistic_+3A_object">object</code></td>
<td>
<p>an object of class <code>autologistic</code>, typically the result of a call to <code><a href="#topic+autologistic">autologistic</a></code>.</p>
</td></tr>
<tr><td><code id="residuals.autologistic_+3A_type">type</code></td>
<td>
<p>the type of residuals that should be returned. The alternatives are &ldquo;<code>deviance</code>&rdquo; (default), &ldquo;<code>pearson</code>&rdquo;, and &ldquo;<code>response</code>&rdquo;.</p>
</td></tr>
<tr><td><code id="residuals.autologistic_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of residuals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+autologistic">autologistic</a></code>, <code><a href="stats.html#topic+residuals.glm">residuals.glm</a></code>
</p>

<hr>
<h2 id='residuals.sparse.sglmm'>Extract model residuals.</h2><span id='topic+residuals.sparse.sglmm'></span>

<h3>Description</h3>

<p>Extract model residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sparse.sglmm'
residuals(object, type = c("deviance", "pearson",
  "response"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.sparse.sglmm_+3A_object">object</code></td>
<td>
<p>an object of class <code>sparse.sglmm</code>, typically the result of a call to <code><a href="#topic+sparse.sglmm">sparse.sglmm</a></code>.</p>
</td></tr>
<tr><td><code id="residuals.sparse.sglmm_+3A_type">type</code></td>
<td>
<p>the type of residuals that should be returned. The alternatives are &ldquo;<code>deviance</code>&rdquo; (default), &ldquo;<code>pearson</code>&rdquo;, and &ldquo;<code>response</code>&rdquo;.</p>
</td></tr>
<tr><td><code id="residuals.sparse.sglmm_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of residuals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sparse.sglmm">sparse.sglmm</a></code>, <code><a href="stats.html#topic+residuals.glm">residuals.glm</a></code>
</p>

<hr>
<h2 id='sparse.sglmm'>Fit a sparse SGLMM.</h2><span id='topic+sparse.sglmm'></span>

<h3>Description</h3>

<p>Fit a sparse SGLMM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse.sglmm(formula, family = gaussian, data, offset, A, method = c("BSF",
  "RSR"), attractive = 50, repulsive = 0, tol = 0.01, minit = 10000,
  maxit = 1e+06, tune = list(), hyper = list(), model = TRUE,
  x = FALSE, y = FALSE, verbose = FALSE, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparse.sglmm_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code>: a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="sparse.sglmm_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to be used in the model. This can be a character string naming a family function, a family function, or the result of a call to a family function. (See <code><a href="stats.html#topic+family">family</a></code> for details of family functions.) Supported families are <code>binomial</code>, <code>gaussian</code> (default), <code>negbinomial</code>, and <code>poisson</code>.</p>
</td></tr>
<tr><td><code id="sparse.sglmm_+3A_data">data</code></td>
<td>
<p>an optional data frame, list, or environment (or object coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the variables in the model. If not found in <code>data</code>, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>sparse.sglmm</code> is called.</p>
</td></tr>
<tr><td><code id="sparse.sglmm_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known component to be included in the linear predictor during fitting. This should be <code>NULL</code> or a numeric vector of length equal to the number of cases. One or more <code><a href="stats.html#topic+offset">offset</a></code> terms can be included in the formula instead or as well, and if more than one is specified their sum is used. See <code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="sparse.sglmm_+3A_a">A</code></td>
<td>
<p>the adjacency matrix for the underlying graph.</p>
</td></tr>
<tr><td><code id="sparse.sglmm_+3A_method">method</code></td>
<td>
<p>the basis to use. The options are Bayesian spatial filtering (&ldquo;<code>BSF</code>&rdquo;) and restricted spatial regression (&ldquo;<code>RSR</code>&rdquo;).</p>
</td></tr>
<tr><td><code id="sparse.sglmm_+3A_attractive">attractive</code></td>
<td>
<p>the number of attractive Moran eigenvectors to use. The default is 50. See &lsquo;Details&rsquo; for more information.</p>
</td></tr>
<tr><td><code id="sparse.sglmm_+3A_repulsive">repulsive</code></td>
<td>
<p>the number of repulsive Moran eigenvectors to use. The default is 0. See &lsquo;Details&rsquo; for more information.</p>
</td></tr>
<tr><td><code id="sparse.sglmm_+3A_tol">tol</code></td>
<td>
<p>a tolerance. If all Monte Carlo standard errors are smaller than <code>tol</code>, no more samples are drawn from the posterior. The default is 0.01.</p>
</td></tr>
<tr><td><code id="sparse.sglmm_+3A_minit">minit</code></td>
<td>
<p>the minimum sample size. This should be large enough to permit accurate estimation of Monte Carlo standard errors. The default is 10,000.</p>
</td></tr>
<tr><td><code id="sparse.sglmm_+3A_maxit">maxit</code></td>
<td>
<p>the maximum sample size. Sampling from the posterior terminates when all Monte Carlo standard errors are smaller than <code>tol</code> or when <code>maxit</code> samples have been drawn, whichever happens first. The default is 1,000,000.</p>
</td></tr>
<tr><td><code id="sparse.sglmm_+3A_tune">tune</code></td>
<td>
<p>(where relevant) a list containing <code>sigma.s</code>, <code>sigma.h</code>, and <code>sigma.theta</code>. These are the standard deviations for the <code class="reqn">\gamma</code>, <code class="reqn">\delta</code>, and <code class="reqn">\theta</code> proposals, respectively.</p>
</td></tr>
<tr><td><code id="sparse.sglmm_+3A_hyper">hyper</code></td>
<td>
<p>a list containing <code>sigma.b</code>, the prior standard deviation for <code class="reqn">\beta</code>, and (where relevant) <code>a.h</code> and <code>b.h</code>, the parameters of the gamma prior for <code class="reqn">\tau_h</code>.</p>
</td></tr>
<tr><td><code id="sparse.sglmm_+3A_model">model</code></td>
<td>
<p>a logical value indicating whether the model frame should be included as a component of the returned value.</p>
</td></tr>
<tr><td><code id="sparse.sglmm_+3A_x">x</code></td>
<td>
<p>a logical value indicating whether the model matrix used in the fitting process should be returned as a component of the returned value.</p>
</td></tr>
<tr><td><code id="sparse.sglmm_+3A_y">y</code></td>
<td>
<p>a logical value indicating whether the response vector used in the fitting process should be returned as a component of the returned value.</p>
</td></tr>
<tr><td><code id="sparse.sglmm_+3A_verbose">verbose</code></td>
<td>
<p>a logical value indicating whether to print MCMC progress to the screen. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sparse.sglmm_+3A_parallel">parallel</code></td>
<td>
<p>(for parallelized computation of the Moran operator) a list containing <code>type</code> and <code>nodes</code>, the cluster type and number of slave nodes, respectively. The former must be one of &ldquo;<code>FORK</code>&rdquo;, &ldquo;<code>MPI</code>&rdquo;, &ldquo;<code>NWS</code>&rdquo;, &ldquo;<code>PSOCK</code>&rdquo;, or &ldquo;<code>SOCK</code>&rdquo; (default). The latter must be a whole number greater than 1. This argument defaults to <code>FALSE</code>, in which case the matrix multiplications are not parallelized.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the sparse restricted spatial regression model of Hughes and Haran (2013), or the Bayesian spatial filtering model of Hughes (2017). The first stage of the model is </p>
<p style="text-align: center;"><code class="reqn">g(\mu_i)=x_i^\prime\beta+m_i^\prime\gamma\hspace{1 cm}(i=1,\dots,n)</code>
</p>
<p> or, in vectorized form, </p>
<p style="text-align: center;"><code class="reqn">g(\mu)=X\beta+M\gamma,</code>
</p>
<p> where <code class="reqn">X</code> is the design matrix, <code class="reqn">\beta</code> is a <code class="reqn">p</code>-vector of regression coefficients, the columns of <code class="reqn">M</code> are <code class="reqn">q</code> eigenvectors of the Moran operator, and <code class="reqn">\gamma</code> are spatial random effects. Arguments <code>attractive</code> and <code>repulsive</code> can be used to control the number of eigenvectors used. The default values are 50 and 0, respectively, which corresponds to pure spatial smoothing. Inclusion of some repulsive eigenvectors can be advantageous in certain applications.<br /><br /> The second stage, i.e., the prior for <code class="reqn">\gamma</code>, is </p>
<p style="text-align: center;"><code class="reqn">p(\gamma\mid\tau_s)\propto\tau_s^{q/2}\exp\left(-\frac{\tau_s}{2}\gamma^\prime M^\prime QM\gamma\right),</code>
</p>
<p> where <code class="reqn">\tau_s</code> is a smoothing parameter and <code class="reqn">Q</code> is the graph Laplacian.<br /><br /> The prior for <code class="reqn">\beta</code> is spherical <code class="reqn">p</code>-variate normal with mean zero and common standard deviation <code>sigma.b</code>, which defaults to 1,000. The prior for <code class="reqn">\tau_s</code> is gamma with parameters 0.5 and 2,000. The same prior is used for <code class="reqn">\theta</code> (when family is <code>negbinomial</code>).<br /><br /> When the response is normally distributed, the identity link is assumed, in which case the first stage is </p>
<p style="text-align: center;"><code class="reqn">\mu=X\beta+M\gamma+M\delta,</code>
</p>
<p> where <code class="reqn">\delta</code> are heterogeneity random effects. When the response is Poisson distributed, heterogeneity random effects are optional. In any case, the prior on <code class="reqn">\delta</code> is spherical <code class="reqn">q</code>-variate normal with mean zero and common variance <code class="reqn">1/\tau_h</code>. The prior for <code class="reqn">\tau_h</code> is gamma with parameters <code class="reqn">a_h</code> and <code class="reqn">b_h</code>, the values of which are controlled by the user through argument <code>hyper</code>.<br /><br /> If the response is Bernoulli, negative binomial, or Poisson, <code class="reqn">\beta</code> and <code class="reqn">\gamma</code> are updated using Metropolis-Hastings random walks with normal proposals. The proposal covariance matrix for <code class="reqn">\beta</code> is the estimated asymptotic covariance matrix from a <code><a href="stats.html#topic+glm">glm</a></code> fit to the data (see <code><a href="stats.html#topic+vcov">vcov</a></code>). The proposal for <code class="reqn">\gamma</code> is spherical normal with common standard deviation <code>sigma.s</code>.<br /><br /> The updates for <code class="reqn">\tau_s</code> and <code class="reqn">\tau_h</code> are Gibbs updates irrespective of the response distribution.<br /><br /> If the response is Poisson distributed and heterogeneity random effects are included, those random effects are updated using a Metropolis-Hastings random walk with a spherical normal proposal. The common standard deviation is <code>sigma.h</code>.<br /><br /> If the response is normally distributed, all updates are Gibbs updates.<br /><br /> If the response is negative binomial, the dispersion parameter <code class="reqn">\theta</code> is updated using a Metropolis-Hastings random walk with a normal proposal. Said proposal has standard deviation <code>sigma.theta</code>, which can be provided by the user as an element of argument <code>tune</code>.
</p>


<h3>Value</h3>

<p><code>sparse.sglmm</code> returns an object of class &ldquo;<code>sparse.sglmm</code>&rdquo;, which is a list containing the following components.
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>the estimated regression coefficients.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted mean values, obtained by transforming the linear predictors by the inverse of the link function.</p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>
<p>the linear fit on link scale.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the response residuals.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the size of the posterior sample.</p>
</td></tr>
<tr><td><code>beta.sample</code></td>
<td>
<p>an <code>iter</code> by <code class="reqn">p</code> matrix containing the posterior samples for <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code>gamma.sample</code></td>
<td>
<p>an <code>iter</code> by <code class="reqn">q</code> matrix containing the posterior samples for <code class="reqn">\gamma</code>.</p>
</td></tr>
<tr><td><code>delta.sample</code></td>
<td>
<p>(where relevant) an <code>iter</code> by <code class="reqn">q</code> matrix containing the posterior samples for <code class="reqn">\delta</code>.</p>
</td></tr>
<tr><td><code>theta.sample</code></td>
<td>
<p>(where relevant) a vector containing the posterior samples for <code class="reqn">\theta</code>.</p>
</td></tr>
<tr><td><code>tau.s.sample</code></td>
<td>
<p>a vector containing the posterior samples for <code class="reqn">\tau_s</code>.</p>
</td></tr>
<tr><td><code>tau.h.sample</code></td>
<td>
<p>(where relevant) a vector containing the posterior samples for <code class="reqn">\tau_h</code>.</p>
</td></tr>
<tr><td><code>gamma.est</code></td>
<td>
<p>the estimate of <code class="reqn">\gamma</code>.</p>
</td></tr>
<tr><td><code>delta.est</code></td>
<td>
<p>(where relevant) the estimate of <code class="reqn">\delta</code>.</p>
</td></tr>
<tr><td><code>tau.s.est</code></td>
<td>
<p>the estimate of <code class="reqn">\tau_s</code>.</p>
</td></tr>
<tr><td><code>tau.h.est</code></td>
<td>
<p>(where relevant) the estimate of <code class="reqn">\tau_h</code>.</p>
</td></tr>
<tr><td><code>theta.est</code></td>
<td>
<p>(where relevant) the estimate of <code class="reqn">\theta</code>.</p>
</td></tr>
<tr><td><code>beta.mcse</code></td>
<td>
<p>the Monte Carlo standard errors for <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code>gamma.mcse</code></td>
<td>
<p>the Monte Carlo standard errors for <code class="reqn">\gamma</code>.</p>
</td></tr>
<tr><td><code>delta.mcse</code></td>
<td>
<p>(where relevant) the Monte Carlo standard errors for <code class="reqn">\delta</code>.</p>
</td></tr>
<tr><td><code>tau.s.mcse</code></td>
<td>
<p>the Monte Carlo standard error for <code class="reqn">\tau_s</code>.</p>
</td></tr>
<tr><td><code>tau.h.mcse</code></td>
<td>
<p>(where relevant) the Monte Carlo standard error for <code class="reqn">\tau_h</code>.</p>
</td></tr>
<tr><td><code>theta.mcse</code></td>
<td>
<p>(where relevant) the Monte Carlo standard error for <code class="reqn">\theta</code>.</p>
</td></tr>
<tr><td><code>D.bar</code></td>
<td>
<p>the goodness of fit component of the DIC.</p>
</td></tr>
<tr><td><code>pD</code></td>
<td>
<p>the penalty component of the DIC.</p>
</td></tr>
<tr><td><code>dic</code></td>
<td>
<p>the deviance information criterion.</p>
</td></tr>
<tr><td><code>beta.accept</code></td>
<td>
<p>the acceptance rate for <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code>gamma.accept</code></td>
<td>
<p>the acceptance rate for <code class="reqn">\gamma</code>.</p>
</td></tr>
<tr><td><code>delta.accept</code></td>
<td>
<p>(where relevant) the acceptance rate for <code class="reqn">\delta</code>.</p>
</td></tr>
<tr><td><code>theta.accept</code></td>
<td>
<p>(where relevant) the acceptance rate for <code class="reqn">\theta</code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>if requested (the default), the <code>y</code> vector used.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>if requested, the model matrix.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>if requested, the matrix of Moran eigenvectors.</p>
</td></tr>
<tr><td><code>eigen.values</code></td>
<td>
<p>if requested, the spectrum of the Moran operator.</p>
</td></tr>
<tr><td><code>hyper</code></td>
<td>
<p>a list containing the names and values of the hyperparameters.</p>
</td></tr>
<tr><td><code>tune</code></td>
<td>
<p>a list containing the names and values of the tuning parameters.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>if requested (the default), the model frame.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the formula supplied.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code><a href="stats.html#topic+terms">terms</a></code> object used.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the <code>data</code> argument.</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>the offset vector used.</p>
</td></tr>
<tr><td><code>xlevels</code></td>
<td>
<p>(where relevant) a record of the levels of the factors used in fitting.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hughes, J. and Haran, M. (2013) Dimension reduction and alleviation of confounding for spatial generalized linear mixed models. <em>Journal of the Royal Statistical Society, Series B</em>, <b>75</b>(1), 139&ndash;159.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+residuals.sparse.sglmm">residuals.sparse.sglmm</a></code>, <code><a href="#topic+summary.sparse.sglmm">summary.sparse.sglmm</a></code>, <code><a href="#topic+vcov.sparse.sglmm">vcov.sparse.sglmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

The following code duplicates the analysis described in (Hughes and Haran, 2013). The data are
infant mortality data for 3,071 US counties. We do a spatial Poisson regression with offset.

data(infant)
infant$low_weight = infant$low_weight / infant$births
attach(infant)
Z = deaths
X = cbind(1, low_weight, black, hispanic, gini, affluence, stability)
data(A)
set.seed(123456)
fit = sparse.sglmm(Z ~ X - 1 + offset(log(births)), family = poisson, A = A, method = "RSR",
                   tune = list(sigma.s = 0.02), verbose = TRUE)
summary(fit)

## End(Not run) 
</code></pre>

<hr>
<h2 id='summary.autologistic'>Print a summary of a centered autologistic model fit.</h2><span id='topic+summary.autologistic'></span>

<h3>Description</h3>

<p>Print a summary of a centered autologistic model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'autologistic'
summary(object, alpha = 0.05, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.autologistic_+3A_object">object</code></td>
<td>
<p>an object of class <code>autologistic</code>, typically the result of a call to <code><a href="#topic+autologistic">autologistic</a></code>.</p>
</td></tr>
<tr><td><code id="summary.autologistic_+3A_alpha">alpha</code></td>
<td>
<p>the significance level for the quantile/HPD intervals. The default is 0.05.</p>
</td></tr>
<tr><td><code id="summary.autologistic_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to display. The default is 4.</p>
</td></tr>
<tr><td><code id="summary.autologistic_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function displays (1) the call to <code><a href="#topic+autologistic">autologistic</a></code>, (2) the values of the control parameters, (3) a table of estimates, and (4) the size of the bootstrap/posterior sample. Each row of the table of estimates shows a parameter estimate, the confidence or HPD interval for the parameter, and, where applicable, the Monte Carlo standard error.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+autologistic">autologistic</a></code>
</p>

<hr>
<h2 id='summary.sparse.sglmm'>Print a summary of a sparse SGLMM fit.</h2><span id='topic+summary.sparse.sglmm'></span>

<h3>Description</h3>

<p>Print a summary of a sparse SGLMM fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sparse.sglmm'
summary(object, alpha = 0.05, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sparse.sglmm_+3A_object">object</code></td>
<td>
<p>an object of class <code>sparse.sglmm</code>, typically the result of a call to <code><a href="#topic+sparse.sglmm">sparse.sglmm</a></code>.</p>
</td></tr>
<tr><td><code id="summary.sparse.sglmm_+3A_alpha">alpha</code></td>
<td>
<p>the significance level used to compute the HPD intervals. The default is 0.05.</p>
</td></tr>
<tr><td><code id="summary.sparse.sglmm_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to display. The default is 4.</p>
</td></tr>
<tr><td><code id="summary.sparse.sglmm_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function displays (1) the call to <code><a href="#topic+sparse.sglmm">sparse.sglmm</a></code>, (2) the values of the hyperparameters and tuning parameters, (3) a table of estimates, (4) the DIC value for the fit, and (5) the number of posterior samples. Each row of the table of estimates shows an estimated regression coefficient, the HPD interval for the coefficient, and the Monte Carlo standard error.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sparse.sglmm">sparse.sglmm</a></code>
</p>

<hr>
<h2 id='vcov.autologistic'>Return the estimated covariance matrix for an <code>autologistic</code> model object.</h2><span id='topic+vcov.autologistic'></span>

<h3>Description</h3>

<p>Return the estimated covariance matrix for an <code>autologistic</code> model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'autologistic'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.autologistic_+3A_object">object</code></td>
<td>
<p>a fitted <code>autologistic</code> model object.</p>
</td></tr>
<tr><td><code id="vcov.autologistic_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An estimate of the covariance matrix of the parameters (in a Bayesian setting), or an estimate of the covariance matrix of the maximum pseudolikelihood estimator of the parameters.
</p>

<hr>
<h2 id='vcov.sparse.sglmm'>Return the covariance matrix of the regression parameters of a <code>sparse.sglmm</code> model object.</h2><span id='topic+vcov.sparse.sglmm'></span>

<h3>Description</h3>

<p>Return the covariance matrix of the regression parameters of a <code>sparse.sglmm</code> model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sparse.sglmm'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.sparse.sglmm_+3A_object">object</code></td>
<td>
<p>a fitted <code>sparse.sglmm</code> model object.</p>
</td></tr>
<tr><td><code id="vcov.sparse.sglmm_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An estimate of the posterior covariance matrix of the regression coefficients.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
