<!DOCTYPE html><html><head><title>Help for package EloSteepness</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EloSteepness}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#EloSteepness-package'><p>The 'EloSteepness' package.</p></a></li>
<li><a href='#catch_warnings'><p>catch warnings alongside results without returning warning</p></a></li>
<li><a href='#davids_steepness'><p>David's scores and steepness with Bayesian flavor</p></a></li>
<li><a href='#elo_steepness_from_matrix'><p>steepness based on Bayesian Elo-rating</p></a></li>
<li><a href='#elo_steepness_from_sequence'><p>steepness based on Bayesian Elo-rating</p></a></li>
<li><a href='#generate_interaction_probs'><p>generate dyadic interaction probabilities for a group with fixed individual</p>
and dyadic biases</a></li>
<li><a href='#plot_matrix'><p>plot (rather than print) a matrix</p></a></li>
<li><a href='#plot_scores'><p>plot posteriors of individual scores</p></a></li>
<li><a href='#plot_steepness'><p>plot steepness density</p></a></li>
<li><a href='#plot_steepness_regression'><p>plot steepness regression</p></a></li>
<li><a href='#prep_data_for_rstan'><p>prepare data for stan call</p></a></li>
<li><a href='#remove_dyads'><p>remove interactions from matrix to increase sparseness</p></a></li>
<li><a href='#repeatability_steepness'><p>steepness via repeatability (cf aniDom package)</p></a></li>
<li><a href='#sampler_diagnostics'><p>catch Stan sampling issues without throwing a warning</p></a></li>
<li><a href='#scores'><p>numeric summaries of individual scores</p></a></li>
<li><a href='#simple_steep_gen'><p>generate dominance interactions with specified steepness</p></a></li>
<li><a href='#steepness_precis'><p>numeric summary of steepness</p></a></li>
<li><a href='#summary.elo_steepness'><p>summary</p></a></li>
<li><a href='#upward_steepness'><p>proportion of interactions against the rank order</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian Dominance Hierarchy Steepness via Elo Rating and
David's Scores</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-21</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christof Neumann &lt;christofneumann1@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Obtain Bayesian posterior distributions of dominance hierarchy steepness (Neumann and Fischer (2023) &lt;<a href="https://doi.org/10.1111%2F2041-210X.14021">doi:10.1111/2041-210X.14021</a>&gt;). Steepness estimation is based on Bayesian implementations of either Elo-rating or David's scores. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), EloRating</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rcpp (&ge; 0.12.0), RcppParallel (&ge; 5.0.1), rstan (&ge;
2.26.0), rstantools (&ge; 2.1.1), aniDom</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
RcppParallel (&ge; 5.0.1), rstan (&ge; 2.26.0), StanHeaders (&ge;
2.26.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, bookdown, xtable, knitr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gobbios/EloSteepness">https://github.com/gobbios/EloSteepness</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gobbios/EloSteepness/issues">https://github.com/gobbios/EloSteepness/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-20 21:59:13 UTC; cneumann</td>
</tr>
<tr>
<td>Author:</td>
<td>Christof Neumann <a href="https://orcid.org/0000-0002-0236-1219"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-21 00:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='EloSteepness-package'>The 'EloSteepness' package.</h2><span id='topic+EloSteepness-package'></span><span id='topic+EloSteepness'></span>

<h3>Description</h3>

<p>Dominance Hierarchy Steepness Via Elo Rating
</p>

<hr>
<h2 id='catch_warnings'>catch warnings alongside results without returning warning</h2><span id='topic+catch_warnings'></span>

<h3>Description</h3>

<p>helper function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catch_warnings(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="catch_warnings_+3A_expr">expr</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> expression to evaluate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list where the first entry is the result of <code>expr</code> and the
second provides information about warnings
</p>


<h3>Source</h3>

<p><code>demo(error.catching)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>log(3)
catch_warnings(log(3))

# produces warning
# log(-3)
# catch it
catch_warnings(log(-3))

# produces error
# log("x")
# catch it
catch_warnings(log("x"))
</code></pre>

<hr>
<h2 id='davids_steepness'>David's scores and steepness with Bayesian flavor</h2><span id='topic+davids_steepness'></span>

<h3>Description</h3>

<p>David's scores and steepness with Bayesian flavor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>davids_steepness(mat, silent = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="davids_steepness_+3A_mat">mat</code></td>
<td>
<p>square interaction matrix</p>
</td></tr>
<tr><td><code id="davids_steepness_+3A_silent">silent</code></td>
<td>
<p>logical, suppress warnings (default is <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="davids_steepness_+3A_...">...</code></td>
<td>
<p>additional arguments for <code><a href="rstan.html#topic+sampling">sampling</a>()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with results of the modelling fitting, containing the
following list items:
</p>

<dl>
<dt><code>steepness</code></dt><dd><p>a one-column matrix with the posterior samples
for steepness. Each row is one iteration.</p>
</dd>
<dt><code>norm_ds</code></dt><dd><p>an matrix with posterior normalized
David's scores for each individual. Each column is one individual.
Each row is one iteration.</p>
</dd>
<dt><code>ids</code></dt><dd><p>a character vector with individual ID codes as supplied
in <code>mat</code></p>
</dd>
<dt><code>diagnostics</code></dt><dd><p>a list with information regarding sampling
problems</p>
</dd>
<dt><code>stanfit</code></dt><dd><p>the actual <code><a href="rstan.html#topic+stanfit">stanfit</a></code> object</p>
</dd>
<dt><code>mat</code></dt><dd><p>the input matrix</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(dommats, package = "EloRating")
res &lt;- davids_steepness(dommats$elephants, refresh = 0)
plot_steepness(res)
</code></pre>

<hr>
<h2 id='elo_steepness_from_matrix'>steepness based on Bayesian Elo-rating</h2><span id='topic+elo_steepness_from_matrix'></span>

<h3>Description</h3>

<p>for interaction data with unknown sequence of observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elo_steepness_from_matrix(
  mat,
  algo = c("fixed_sd", "original", "fixed_k"),
  n_rand = NULL,
  silent = FALSE,
  k = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elo_steepness_from_matrix_+3A_mat">mat</code></td>
<td>
<p>square interaction matrix</p>
</td></tr>
<tr><td><code id="elo_steepness_from_matrix_+3A_algo">algo</code></td>
<td>
<p>character, either <code>"fixed_sd"</code>, <code>"original"</code>, or
<code>"fixed_k"</code>.This determines which algorithm
to estimate Elo-ratings is used. Default is
<code>"fixed_sd"</code>, which is a slight modification from
Goffe et al's original code. <code>"fixed_k"</code> fixes the k
parameter ('shift coefficient' in Goffe et al) to
the set value rather than estimating it from the data.</p>
</td></tr>
<tr><td><code id="elo_steepness_from_matrix_+3A_n_rand">n_rand</code></td>
<td>
<p>numeric, number of randomized sequences. Default is
<code>NULL</code>, which uses a rule of thumb to determine the
number (see below for more details).</p>
</td></tr>
<tr><td><code id="elo_steepness_from_matrix_+3A_silent">silent</code></td>
<td>
<p>logical, suppress warnings (default is <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="elo_steepness_from_matrix_+3A_k">k</code></td>
<td>
<p>numeric, provides a fixed k parameter. This only has effects if
<code>algo = "fixed_k"</code>. At its default <code>NULL</code> a value of
0.4 is used.</p>
</td></tr>
<tr><td><code id="elo_steepness_from_matrix_+3A_...">...</code></td>
<td>
<p>additional arguments for <code><a href="rstan.html#topic+sampling">sampling</a>()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of randomizations is set in the following way, unless
a specific number is provided. If there are more than 500
observed interactions, <code>n_rand = 5</code>. If there are less than
100 interactions, <code>n_rand = 50</code>. In the remaining cases,
<code>n_rand = 20</code>.
</p>
<p>If the function call produces warnings about divergent transitions,
large Rhat values or low effective sample sizes, increase the
number of iterations (via <code>iter=</code>) and/or adjust the
sampling controls (e.g.
via <code>control = list(adapt_delta = 0.9)</code>).
</p>
<p>If the argument <code>seed = </code> is supplied, its value will be passed to
<code><a href="rstan.html#topic+sampling">sampling</a>()</code> to ensure reproducibility of the
MCMC sampling, but the same seed will then also apply
to the randomization of the interaction sequence order(s).
</p>


<h3>Value</h3>

<p>a list with results of the modelling fitting, containing the
following list items:
</p>

<dl>
<dt><code>steepness</code></dt><dd><p>a matrix with the posterior samples for steepness.
Each column corresponds to one randomization (as
set via <code>n_rand</code>). Each row is one iteration.</p>
</dd>
<dt><code>cumwinprobs</code></dt><dd><p>an array with posterior cumulative winning
probabilities for each individual.</p>
</dd>
<dt><code>k</code></dt><dd><p>an array with posterior k values.</p>
</dd>
<dt><code>ids</code></dt><dd><p>a character vector with individual ID codes as supplied
in <code>mat</code></p>
</dd>
<dt><code>diagnostics</code></dt><dd><p>a list with information regarding sampling
problems</p>
</dd>
<dt><code>stanfit</code></dt><dd><p>the actual <code><a href="rstan.html#topic+stanfit">stanfit</a></code> object</p>
</dd>
<dt><code>mat</code></dt><dd><p>the input matrix</p>
</dd>
<dt><code>algo</code></dt><dd><p>character, describing whether the original fitting
algorithm was used (<code>"original"</code>) or the one with fixed SD
of start ratings (<code>"fixed_sd"</code>)</p>
</dd>
<dt><code>sequence_supplied</code></dt><dd><p>logical, were data supplied as matrix
(<code>FALSE</code>) or as sequence via winner/loser vector (<code>TRUE</code>)</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(dommats, package = "EloRating")
# using small numbers for iterations etc to speed up running time
res &lt;- elo_steepness_from_matrix(dommats$elephants, n_rand = 1, cores = 2,
                                 iter = 800, warmup = 300, 
                                 refresh = 0, chains = 2, seed = 1)
plot_steepness(res)


# use the original underlying algorithm by Goffe et al 2018
# will warn about divergent iterations and low effective sample sizes
# but warnings can be caught/suppressed by setting silent = TRUE

res &lt;- elo_steepness_from_matrix(dommats$elephants, n_rand = 1,
                                 algo = "original", silent = TRUE,
                                 iter = 1000, warmup = 500, refresh = 0)
res$diagnostics

# or the sampling can be tweaked to achieve better convergence:
# (this still might produce some divergent transitions on occasion)
# (and the number of iterations should be set higher)
res &lt;- elo_steepness_from_matrix(dommats$elephants, n_rand = 1, chains = 2,
                                 algo = "original", silent = TRUE, seed = 1,
                                 iter = 1000, warmup = 500, refresh = 0,
                                 control = list(adapt_delta = 0.99))
res$diagnostics

</code></pre>

<hr>
<h2 id='elo_steepness_from_sequence'>steepness based on Bayesian Elo-rating</h2><span id='topic+elo_steepness_from_sequence'></span>

<h3>Description</h3>

<p>for interaction data with known sequence of observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elo_steepness_from_sequence(
  winner,
  loser,
  algo = c("fixed_sd", "original", "fixed_k"),
  silent = FALSE,
  k = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elo_steepness_from_sequence_+3A_winner">winner</code></td>
<td>
<p>character (or factor) of winning individuals</p>
</td></tr>
<tr><td><code id="elo_steepness_from_sequence_+3A_loser">loser</code></td>
<td>
<p>character (or factor) of losing individuals</p>
</td></tr>
<tr><td><code id="elo_steepness_from_sequence_+3A_algo">algo</code></td>
<td>
<p>character, either <code>"fixed_sd"</code>, <code>"original"</code>, or
<code>"fixed_k"</code>.This determines which algorithm
to estimate Elo-ratings is used. Default is
<code>"fixed_sd"</code>, which is a slight modification from
Goffe et al's original code. <code>"fixed_k"</code> fixes the k
parameter ('shift coefficient' in Goffe et al) to
the set value rather than estimating it from the data.</p>
</td></tr>
<tr><td><code id="elo_steepness_from_sequence_+3A_silent">silent</code></td>
<td>
<p>logical, suppress warnings (default is <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="elo_steepness_from_sequence_+3A_k">k</code></td>
<td>
<p>numeric, provides a fixed k parameter. This only has effects if
<code>algo = "fixed_k"</code>. At its default <code>NULL</code> a value of
0.4 is used.</p>
</td></tr>
<tr><td><code id="elo_steepness_from_sequence_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>sampling()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with results of the model fitting
(see <code><a href="#topic+elo_steepness_from_matrix">elo_steepness_from_matrix</a></code>) for details
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adv, package = "EloRating")
res &lt;- elo_steepness_from_sequence(winner = adv$winner, loser = adv$loser,
                                   cores = 1, chains = 2, iter = 1000, 
                                   warmup = 500, seed = 1, refresh = 0)
plot_steepness(res)

</code></pre>

<hr>
<h2 id='generate_interaction_probs'>generate dyadic interaction probabilities for a group with fixed individual
and dyadic biases</h2><span id='topic+generate_interaction_probs'></span>

<h3>Description</h3>

<p>generate dyadic interaction probabilities for a group with fixed individual
and dyadic biases
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_interaction_probs(n_ind, id_bias = 0, rank_bias = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_interaction_probs_+3A_n_ind">n_ind</code></td>
<td>
<p>numeric, number of individuals</p>
</td></tr>
<tr><td><code id="generate_interaction_probs_+3A_id_bias">id_bias</code></td>
<td>
<p>numeric, between 0 and 1. If 0 all individual are equally
likely to interact. If 1, some individuals have higher propensities
to interact</p>
</td></tr>
<tr><td><code id="generate_interaction_probs_+3A_rank_bias">rank_bias</code></td>
<td>
<p>numeric, between 0 and 1. If 0 there is no relationship
between rank distance and interaction propensity. If 1 there is a
strong relationship: dyads closer in rank interact more often.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

x &lt;- generate_interaction_probs(n_ind = 10, id_bias = 0.2, rank_bias = 1)
rankdiff &lt;- x[, 2] - x[, 1]
interactprob &lt;- x[, "final"]
# closer in rank (smaller rank diff) = interaction more likely
plot(rankdiff, interactprob)

x &lt;- generate_interaction_probs(n_ind = 10, id_bias = 0.2, rank_bias = 0)
rankdiff &lt;- x[, 2] - x[, 1]
interactprob &lt;- x[, "final"]
# approx. equal probs for all dyads regardless of rank diff
plot(rankdiff, interactprob)


x &lt;- generate_interaction_probs(n_ind = 10, id_bias = 0, rank_bias = 0)
interactprob &lt;- x[, "final"]
y &lt;- sample(1:nrow(x), 1000, replace = TRUE, prob = interactprob)
y &lt;- as.numeric(x[y, 1:2])
# approx. equal numbers of interactions per ID
sort(table(y))

# skewed interaction numbers
x &lt;- generate_interaction_probs(n_ind = 10, id_bias = 1, rank_bias = 0)
interactprob &lt;- x[, "final"]
y &lt;- sample(1:nrow(x), 1000, replace = TRUE, prob = interactprob)
y &lt;- as.numeric(x[y, 1:2])
sort(table(y))
</code></pre>

<hr>
<h2 id='plot_matrix'>plot (rather than print) a matrix</h2><span id='topic+plot_matrix'></span>

<h3>Description</h3>

<p>a helper function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_matrix(mat, greyout = NULL, prunkcol = NULL, label_col = "black")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_matrix_+3A_mat">mat</code></td>
<td>
<p>square matrix</p>
</td></tr>
<tr><td><code id="plot_matrix_+3A_greyout">greyout</code></td>
<td>
<p>numeric, the values to be grayed out</p>
</td></tr>
<tr><td><code id="plot_matrix_+3A_prunkcol">prunkcol</code></td>
<td>
<p>color value, which if set to some color will highlight
unknown relationships with rectangles of that color.</p>
</td></tr>
<tr><td><code id="plot_matrix_+3A_label_col">label_col</code></td>
<td>
<p>color values for column and row labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot and an invisible list with coordinates and
content of the matrix to be plotted
</p>

<hr>
<h2 id='plot_scores'>plot posteriors of individual scores</h2><span id='topic+plot_scores'></span>

<h3>Description</h3>

<p>either summed winning probabilities or David's scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_scores(
  x,
  adjustpar = 4,
  color = TRUE,
  subset_ids = NULL,
  include_others = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_scores_+3A_x">x</code></td>
<td>
<p>result from <code><a href="#topic+elo_steepness_from_matrix">elo_steepness_from_matrix</a></code>,
<code><a href="#topic+elo_steepness_from_sequence">elo_steepness_from_sequence</a></code> or
<code><a href="#topic+davids_steepness">davids_steepness</a></code></p>
</td></tr>
<tr><td><code id="plot_scores_+3A_adjustpar">adjustpar</code></td>
<td>
<p>numeric, parameter for smoothing posterior of individual
scores</p>
</td></tr>
<tr><td><code id="plot_scores_+3A_color">color</code></td>
<td>
<p>logical, default is <code>TRUE</code> where individuals get
color-coded. If <code>FALSE</code>: a gray scale is used. It is
also possible to hand over a vector with colors, which then
must correspond in length to the number of individuals.</p>
</td></tr>
<tr><td><code id="plot_scores_+3A_subset_ids">subset_ids</code></td>
<td>
<p>character, plot only those individual codes. Default is
<code>NULL</code>, i.e. all individuals are included in the plot.</p>
</td></tr>
<tr><td><code id="plot_scores_+3A_include_others">include_others</code></td>
<td>
<p>logical, should other IDs (those <em>not</em> in
<code>subset_ids</code>) be included as contours. Default is <code>TRUE</code>.
This only has an effect if <code>subset_ids</code> is different from
<code>NULL</code>,</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dommats, package = "EloRating")

res &lt;- elo_steepness_from_matrix(dommats$elephants, n_rand = 1,
                                 silent = TRUE, refresh = 0,
                                 iter = 1000, warmup = 500)
plot_scores(res)

res &lt;- davids_steepness(dommats$elephants, refresh = 0)
plot_scores(res)
plot_scores(res, color = FALSE)
plot_scores(res, adjustpar = 0.3)
</code></pre>

<hr>
<h2 id='plot_steepness'>plot steepness density</h2><span id='topic+plot_steepness'></span>

<h3>Description</h3>

<p>plot steepness density
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_steepness(x, adjustpar = 1.5, print_numbers = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_steepness_+3A_x">x</code></td>
<td>
<p>result from <code><a href="#topic+elo_steepness_from_matrix">elo_steepness_from_matrix</a></code>,
<code><a href="#topic+elo_steepness_from_sequence">elo_steepness_from_sequence</a></code> or
<code><a href="#topic+davids_steepness">davids_steepness</a></code></p>
</td></tr>
<tr><td><code id="plot_steepness_+3A_adjustpar">adjustpar</code></td>
<td>
<p>numeric, parameter for smoothing posterior of individual
scores</p>
</td></tr>
<tr><td><code id="plot_steepness_+3A_print_numbers">print_numbers</code></td>
<td>
<p>logical, if <code>TRUE</code> (default) print numeric
summaries into into the plot and omit them if <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("dommats", package = "EloRating")
m &lt;- dommats$elephants
res &lt;- elo_steepness_from_matrix(m, n_rand = 3, refresh = 0, cores = 2, 
                                 iter = 1000, warmup = 500)
plot_steepness(res)

</code></pre>

<hr>
<h2 id='plot_steepness_regression'>plot steepness regression</h2><span id='topic+plot_steepness_regression'></span>

<h3>Description</h3>

<p>visually combine individual scores with group-level steepness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_steepness_regression(
  x,
  adjust = 3,
  color = TRUE,
  width_fac = 0.1,
  axis_extend = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_steepness_regression_+3A_x">x</code></td>
<td>
<p>result from <code><a href="#topic+elo_steepness_from_matrix">elo_steepness_from_matrix</a></code>,
<code><a href="#topic+elo_steepness_from_sequence">elo_steepness_from_sequence</a></code> or
<code><a href="#topic+davids_steepness">davids_steepness</a></code></p>
</td></tr>
<tr><td><code id="plot_steepness_regression_+3A_adjust">adjust</code></td>
<td>
<p>numeric, parameter for smoothing posterior of individual scores</p>
</td></tr>
<tr><td><code id="plot_steepness_regression_+3A_color">color</code></td>
<td>
<p>logical, default is <code>TRUE</code> where individuals get color-
coded. If <code>FALSE</code>: a gray scale is used. It is also possible
to hand over a vector with colors, which then must be correspond
in length to the number of individuals.</p>
</td></tr>
<tr><td><code id="plot_steepness_regression_+3A_width_fac">width_fac</code></td>
<td>
<p>numeric, relative width of posterior distributions. This is
actually affects the 'height' but since the posteriors are rotated it
visually represents width.</p>
</td></tr>
<tr><td><code id="plot_steepness_regression_+3A_axis_extend">axis_extend</code></td>
<td>
<p>numeric, an extension factor to extend the horizontal
axis to leave space for the posteriors. When set to 0 the axis stops
at <em>n</em> (the number of individuals, which represents the
lowest rank).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bonobos", package = "EloRating")
res &lt;- davids_steepness(bonobos, refresh = 0, iter = 1000)
plot_steepness_regression(res, width_fac = 0.5)
</code></pre>

<hr>
<h2 id='prep_data_for_rstan'>prepare data for stan call</h2><span id='topic+prep_data_for_rstan'></span>

<h3>Description</h3>

<p>prepare data for stan call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_data_for_rstan(mat, n_rand = 1, silent = FALSE, for_elo_model = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_data_for_rstan_+3A_mat">mat</code></td>
<td>
<p>square interaction matrix</p>
</td></tr>
<tr><td><code id="prep_data_for_rstan_+3A_n_rand">n_rand</code></td>
<td>
<p>numeric, number of randomizations</p>
</td></tr>
<tr><td><code id="prep_data_for_rstan_+3A_silent">silent</code></td>
<td>
<p>logical, omit printing messages regarding non-fatal data
issues. Default is <code>FALSE</code>, i.e. do print messages.</p>
</td></tr>
<tr><td><code id="prep_data_for_rstan_+3A_for_elo_model">for_elo_model</code></td>
<td>
<p>logical, output ready for Elo steepness (default,
<code>TRUE</code>). If <code>FALSE</code>, prep for David's score steepness.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list that is formatted so that it can be handed over to the
respective Stan models
</p>

<hr>
<h2 id='remove_dyads'>remove interactions from matrix to increase sparseness</h2><span id='topic+remove_dyads'></span>

<h3>Description</h3>

<p>remove interactions from matrix to increase sparseness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_dyads(
  m,
  removal_mode = c("mix", "by_interaction", "by_dyad"),
  stop_at = 0.5,
  max_out = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_dyads_+3A_m">m</code></td>
<td>
<p>input matrix</p>
</td></tr>
<tr><td><code id="remove_dyads_+3A_removal_mode">removal_mode</code></td>
<td>
<p>character, should interactions be removed interaction by
interaction (<code>"by_interaction"</code>), or by removing one dyad
entirely at a time (<code>"by_dyad"</code>). Default is <code>"mix"</code>, i.e.
a random mix between the two strategies.</p>
</td></tr>
<tr><td><code id="remove_dyads_+3A_stop_at">stop_at</code></td>
<td>
<p>numeric, fraction of unknown relationships to be reached</p>
</td></tr>
<tr><td><code id="remove_dyads_+3A_max_out">max_out</code></td>
<td>
<p>numeric, the number of matrices to be returned maximally.
This is useful if the input matrix is fairly large. If set, this
will return the input matrix plus <code>max_out</code> randomly selected
matrices from the remaining produced matrices. So in fact, the output
comprises <code>max_out + 1</code> matrices (subject to the <code>stop_at</code>
specification).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two items. <code>$summary</code> is a data frame with an
overview. <code>matrices</code> contains the actual interaction
matrices with increasing proportion of unknown relationships.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bonobos)
res &lt;- remove_dyads(bonobos)
res$summary
length(res$matrices)
lapply(res$matrices, prunk)

res &lt;- remove_dyads(bonobos, max_out = 2)
# first plus two randomly selected = 3 matrices
length(res$matrices)
res$summary
</code></pre>

<hr>
<h2 id='repeatability_steepness'>steepness via repeatability (cf aniDom package)</h2><span id='topic+repeatability_steepness'></span>

<h3>Description</h3>

<p>steepness via repeatability (cf aniDom package)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repeatability_steepness(mat, n_rand = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repeatability_steepness_+3A_mat">mat</code></td>
<td>
<p>square interaction matrix</p>
</td></tr>
<tr><td><code id="repeatability_steepness_+3A_n_rand">n_rand</code></td>
<td>
<p>numeric, number of randomized sequences
(default is <code>1000</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a steepness value
</p>


<h3>References</h3>

<p>Sanchez-Tojar et al 2018
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bonobos, package = "EloRating")
repeatability_steepness(bonobos, n_rand = 20)
</code></pre>

<hr>
<h2 id='sampler_diagnostics'>catch Stan sampling issues without throwing a warning</h2><span id='topic+sampler_diagnostics'></span>

<h3>Description</h3>

<p>catch Stan sampling issues without throwing a warning
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampler_diagnostics(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampler_diagnostics_+3A_object">object</code></td>
<td>
<p><code><a href="rstan.html#topic+stanfit">stanfit</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list regarding any sampling issues encountered during fitting
</p>

<hr>
<h2 id='scores'>numeric summaries of individual scores</h2><span id='topic+scores'></span>

<h3>Description</h3>

<p>either based on summed winning probabilities or David's scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scores(x, quantiles = c(0.045, 0.955), elo_scores = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scores_+3A_x">x</code></td>
<td>
<p>result from <code><a href="#topic+elo_steepness_from_matrix">elo_steepness_from_matrix</a></code>,
<code><a href="#topic+elo_steepness_from_sequence">elo_steepness_from_sequence</a></code> or
<code><a href="#topic+davids_steepness">davids_steepness</a></code></p>
</td></tr>
<tr><td><code id="scores_+3A_quantiles">quantiles</code></td>
<td>
<p>numeric, the quantiles to be returned</p>
</td></tr>
<tr><td><code id="scores_+3A_elo_scores">elo_scores</code></td>
<td>
<p>logical, with default <code>FALSE</code>.
If <code>TRUE</code> Elo-ratings are returned,
rather than the default summed winning probabilities. This
argument has no consequences if <code>x</code> is the result of
<code><a href="#topic+davids_steepness">davids_steepness</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with one line per individual, providing
summaries of posteriors for individual scores
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("bonobos", package = "EloRating")
res &lt;- davids_steepness(bonobos, refresh = 0, cores = 2)
scores(res)

data("dommats", package = "EloRating")
m &lt;- dommats$elephants
res &lt;- elo_steepness_from_matrix(m, n_rand = 1, refresh = 0,
                                 iter = 1000, warmup = 500)
scores(res)

</code></pre>

<hr>
<h2 id='simple_steep_gen'>generate dominance interactions with specified steepness</h2><span id='topic+simple_steep_gen'></span>

<h3>Description</h3>

<p>generate dominance interactions with specified steepness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple_steep_gen(
  n_ind,
  n_int,
  steep,
  id_bias = 0,
  rank_bias = 0,
  sequential = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simple_steep_gen_+3A_n_ind">n_ind</code></td>
<td>
<p>integer, the number of individuals</p>
</td></tr>
<tr><td><code id="simple_steep_gen_+3A_n_int">n_int</code></td>
<td>
<p>integer, the number of interactions</p>
</td></tr>
<tr><td><code id="simple_steep_gen_+3A_steep">steep</code></td>
<td>
<p>numeric (between 0 and 1), the desired steepness value</p>
</td></tr>
<tr><td><code id="simple_steep_gen_+3A_id_bias">id_bias</code></td>
<td>
<p>numeric, between 0 and 1. If 0 all individual are equally
likely to interact. If 1, some individuals have higher propensities
to interact.</p>
</td></tr>
<tr><td><code id="simple_steep_gen_+3A_rank_bias">rank_bias</code></td>
<td>
<p>numeric, between 0 and 1. If 0 there is no relationship
between rank distance and interaction propensity. If 1 there is a
strong relationship: dyads closer in rank interact more often.</p>
</td></tr>
<tr><td><code id="simple_steep_gen_+3A_sequential">sequential</code></td>
<td>
<p>logical, default is <code>TRUE</code>. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Initially (and this is still the default), the function generated
interactions and their outcomes sequentially: first a dyad
was chosen that interacted and then its winner was determined.
This was repeated for as many interactions as set by <code>n_int=</code>.
</p>
<p>The same results can be achieved much
more efficiently by first setting the number of interactions per
dyad and then looping through all dyads and then generate the
interactions and their outcomes per dyad. This can be achieved by
setting <code>sequential = FALSE</code>. In this latter case the
'sequence' of interactions reported in the results is just a
randomized version of all interactions, whereas in the former case
there is a 'natural sequence' (although it is meaningless because
the sequence is irrelevant with respect to outcomes of individual
interactions (the system is stable)).
</p>


<h3>Value</h3>

<p>a list with the first item being the interactions in sequence form
(<code>$sequence</code>). The second item (<code>$matrix</code>) is the
square interaction matrix and the third item (<code>$settings</code>)
is a list with input settings (including probabilities to interact
for each dyad).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- simple_steep_gen(n_ind = 5, n_int = 30, steep = 0.99)
res$sequence
res$matrix


library(EloRating)
steeps &lt;- runif(20, 0, 1)
nids &lt;- sample(6:10, length(steeps), TRUE)
mats &lt;- sapply(1:length(steeps), function(x) {
  simple_steep_gen(nids[x], nids[x] ^ 2.5, steeps[x], 0)[[2]]
 })
obs_steeps &lt;- unlist(lapply(mats, function(x)steepness(x)[1]))
plot(steeps, obs_steeps, xlim = c(0, 1), ylim = c(0, 1))
abline(0, 1)
</code></pre>

<hr>
<h2 id='steepness_precis'>numeric summary of steepness</h2><span id='topic+steepness_precis'></span>

<h3>Description</h3>

<p>numeric summary of steepness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>steepness_precis(x, quantiles = c(0.055, 0.25, 0.75, 0.945))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="steepness_precis_+3A_x">x</code></td>
<td>
<p>result from <code><a href="#topic+elo_steepness_from_matrix">elo_steepness_from_matrix</a></code>,
<code><a href="#topic+elo_steepness_from_sequence">elo_steepness_from_sequence</a></code> or
<code><a href="#topic+davids_steepness">davids_steepness</a></code></p>
</td></tr>
<tr><td><code id="steepness_precis_+3A_quantiles">quantiles</code></td>
<td>
<p>numeric, the quantiles to be returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with one row providing a summary of the
steepness posterior
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dommats, package = "EloRating")

res &lt;- elo_steepness_from_matrix(dommats$elephants, n_rand = 1, iter = 1000,
                                 silent = TRUE, refresh = 0)
steepness_precis(res)
</code></pre>

<hr>
<h2 id='summary.elo_steepness'>summary</h2><span id='topic+summary.elo_steepness'></span><span id='topic+summary.david_steepness'></span>

<h3>Description</h3>

<p>summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'elo_steepness'
summary(object, ...)

## S3 method for class 'david_steepness'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.elo_steepness_+3A_object">object</code></td>
<td>
<p>result from <code><a href="#topic+elo_steepness_from_matrix">elo_steepness_from_matrix</a></code>,
<code><a href="#topic+elo_steepness_from_sequence">elo_steepness_from_sequence</a></code> or
<code><a href="#topic+davids_steepness">davids_steepness</a></code></p>
</td></tr>
<tr><td><code id="summary.elo_steepness_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods (ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing returned. Called for side effects of textual output
to console.
</p>

<hr>
<h2 id='upward_steepness'>proportion of interactions against the rank order</h2><span id='topic+upward_steepness'></span>

<h3>Description</h3>

<p>proportion of interactions against the rank order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upward_steepness(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upward_steepness_+3A_mat">mat</code></td>
<td>
<p>square interaction matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value of upward steepness
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bonobos, package ="EloRating")
upward_steepness(bonobos)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
