<!DOCTYPE html><html lang="en"><head><title>Help for package TSCI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TSCI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef.tsci'><p>Extract Model Coefficients of TSCI Fits.</p></a></li>
<li><a href='#confint.tsci'><p>Confidence Intervals of Treatment Effect Estimates for TSCI Fits.</p></a></li>
<li><a href='#create_interactions'><p>Interactions as Violation Space Candidates</p></a></li>
<li><a href='#create_monomials'><p>Monomials as Violation Space Candidates</p></a></li>
<li><a href='#print.summary.tsci'><p>Print Content of summary.tsci Object.</p></a></li>
<li><a href='#print.tsci'><p>Print Content of tsci Object.</p></a></li>
<li><a href='#summary.tsci'><p>Summarizing Two Stage Curvature Identification Fits</p></a></li>
<li><a href='#tsci_boosting'><p>Two Stage Curvature Identification with Boosting</p></a></li>
<li><a href='#tsci_forest'><p>Two Stage Curvature Identification with Random Forests</p></a></li>
<li><a href='#tsci_poly'><p>Two Stage Curvature Identification with Polynomial Basis Expansion</p></a></li>
<li><a href='#tsci_secondstage'><p>Two Stage Curvature Identification with User Provided Hat Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Tools for Causal Inference with Possibly Invalid Instrumental
Variables</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Two stage curvature identification with machine learning for causal 
    inference in settings when instrumental variable regression is not suitable
    because of potentially invalid instrumental variables. Based on Guo and 
    Buehlmann (2022) "Two Stage Curvature Identification with Machine Learning: 
    Causal Inference with Possibly Invalid Instrumental Variables"
    &lt;<a href="https://doi.org/10.48550/arXiv.2203.12808">doi:10.48550/arXiv.2203.12808</a>&gt;. The vignette is available in Carl, Emmenegger, BÃ¼hlmann and Guo (2023) 
    "TSCI: two stage curvature identification for causal inference with 
    invalid instruments" &lt;<a href="https://doi.org/10.48550/arXiv.2304.00513">doi:10.48550/arXiv.2304.00513</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dlcarl/TSCI">https://github.com/dlcarl/TSCI</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fda, MASS, testthat (&ge; 3.0.0), withr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>xgboost, Rfast, stats, ranger, parallel, fastDummies</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-09 18:29:54 UTC; david</td>
</tr>
<tr>
<td>Author:</td>
<td>David Carl <a href="https://orcid.org/0000-0003-0615-0133"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Corinne Emmenegger
    <a href="https://orcid.org/0000-0003-0353-8888"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Wei Yuan [aut],
  Mengchu Zheng [aut],
  Zijian Guo <a href="https://orcid.org/0000-0002-2888-7016"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Carl &lt;david.carl@phd.unibocconi.it&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-09 18:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='coef.tsci'>Extract Model Coefficients of TSCI Fits.</h2><span id='topic+coef.tsci'></span>

<h3>Description</h3>

<p>Extract Model Coefficients of TSCI Fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsci'
coef(object, parm = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.tsci_+3A_object">object</code></td>
<td>
<p>an object of class 'tsci'.</p>
</td></tr>
<tr><td><code id="coef.tsci_+3A_parm">parm</code></td>
<td>
<p>a specification for which treatment effect estimates should be returned.
Either a vector of numbers or a vector of names or 'all'.
If missing, the treatment effect estimate by violation space selection is returned.
If 'all', the treatment effect estimates for all violation space candidates are returned.</p>
</td></tr>
<tr><td><code id="coef.tsci_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficients extracted form the model object <code>object</code>.
</p>

<hr>
<h2 id='confint.tsci'>Confidence Intervals of Treatment Effect Estimates for TSCI Fits.</h2><span id='topic+confint.tsci'></span>

<h3>Description</h3>

<p>Confidence Intervals of Treatment Effect Estimates for TSCI Fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsci'
confint(object, parm = NULL, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.tsci_+3A_object">object</code></td>
<td>
<p>an object of class 'tsci'.</p>
</td></tr>
<tr><td><code id="confint.tsci_+3A_parm">parm</code></td>
<td>
<p>a specification of the parameters for which confidence intervals should be calculated.
Either a vector of numbers or a vector of names or 'all'.
If missing, the confidence interval of treatment effect estimate by violation space selection is returned.
If 'all', the confidence intervals for all violation space candidates are returned.</p>
</td></tr>
<tr><td><code id="confint.tsci_+3A_level">level</code></td>
<td>
<p>the confidence level required.</p>
</td></tr>
<tr><td><code id="confint.tsci_+3A_...">...</code></td>
<td>
<p>additional argument(s) for methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix containing the confidence intervals.
</p>

<hr>
<h2 id='create_interactions'>Interactions as Violation Space Candidates</h2><span id='topic+create_interactions'></span>

<h3>Description</h3>

<p>Interactions as Violation Space Candidates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_interactions(Z, X = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_interactions_+3A_z">Z</code></td>
<td>
<p>observations of the instrumental variable(s). Either a numeric vector of length n
or a numeric matrix with dimension n by s.</p>
</td></tr>
<tr><td><code id="create_interactions_+3A_x">X</code></td>
<td>
<p>observations of baseline covariate(s) for which interactions with the instrumental variable(s) should
be part of the violation space candidates. Either a numeric vector of length n
or a numeric matrix with dimension n by p or <code>NULL</code>
(if only interactions between the instrumental variales itself should be part
of the violation space candidates).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list. The first element contains the observations of the
instrumental variable(s) <code>Z</code>. The second element contains all interactions between
the instrumental variable(s) and the baseline covariate(s) <code>X</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Z &lt;- matrix(rnorm(100 * 3), nrow = 100, ncol = 3)
X &lt;- matrix(rnorm(100 * 3), nrow = 100, ncol = 3)
vio_space &lt;- create_interactions(Z = Z, X = X)
</code></pre>

<hr>
<h2 id='create_monomials'>Monomials as Violation Space Candidates</h2><span id='topic+create_monomials'></span>

<h3>Description</h3>

<p>Monomials as Violation Space Candidates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_monomials(Z, degree, type = c("monomials_main", "monomials_full"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_monomials_+3A_z">Z</code></td>
<td>
<p>observations of the instrumental variable(s). Either a numeric vector of length n
or a numeric matrix with dimension n by s.</p>
</td></tr>
<tr><td><code id="create_monomials_+3A_degree">degree</code></td>
<td>
<p>The degree up to which monomials should be created. Either a single positive integer or a vector of length s containing positive integers.</p>
</td></tr>
<tr><td><code id="create_monomials_+3A_type">type</code></td>
<td>
<p>One out of <code>monomials_main</code> or <code>monomials_full</code>. <br />
<code>monomials_main</code> creates the monomials for the polynomials of each instrumental variable up to degree <code>degree</code>. <br />
<code>monomials_full</code> creates the monomials for the polynomials of a combination of all instrumental variables up to degree <code>degree</code>. <br />
Default is <code>monomials_full</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>assuming there are 3 instrumental variables Z1, Z2, and Z3 and <code>degree</code> = c(d1, d2, d3) with d1 &lt; d2 &lt; d3,
<code>monomials_main</code> creates the monomials of the polynomials (Z1 + 1)^d1, (Z2 + 1)^d2, (Z3 + 1)^d3 without the constants and
<code>monomials_full</code> creates the monomials (Z1 + Z2 + Z3), (Z1 + Z2 + Z3)^2, ..., (Z1 + Z2 + Z3)^d3 without the constants and excluding
monomials that are products of Z1^d or Z2^d with d &gt; d1 resp. d &gt; d2.
Thus <code>type</code> = <code>monomials_main</code> does not include interactions between the instrumental variables.
</p>


<h3>Value</h3>

<p>A list. Each element is a matrix consisting of the monomials to be added to
the next violation space candidate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Z &lt;- matrix(rnorm(100 * 3), nrow = 100, ncol = 3)
vio_space &lt;- create_monomials(Z = Z, degree = 4, type = "monomials_full")
</code></pre>

<hr>
<h2 id='print.summary.tsci'>Print Content of summary.tsci Object.</h2><span id='topic+print.summary.tsci'></span>

<h3>Description</h3>

<p>Print Content of summary.tsci Object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.tsci'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.tsci_+3A_x">x</code></td>
<td>
<p>an object of class 'summary.tsci'.</p>
</td></tr>
<tr><td><code id="print.summary.tsci_+3A_digits">digits</code></td>
<td>
<p>number of significant digits to display.</p>
</td></tr>
<tr><td><code id="print.summary.tsci_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='print.tsci'>Print Content of tsci Object.</h2><span id='topic+print.tsci'></span>

<h3>Description</h3>

<p>Print Content of tsci Object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsci'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.tsci_+3A_x">x</code></td>
<td>
<p>an object of class 'tsci'.</p>
</td></tr>
<tr><td><code id="print.tsci_+3A_digits">digits</code></td>
<td>
<p>number of significant digits to display.</p>
</td></tr>
<tr><td><code id="print.tsci_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.tsci'>Summarizing Two Stage Curvature Identification Fits</h2><span id='topic+summary.tsci'></span>

<h3>Description</h3>

<p>Summarizing Two Stage Curvature Identification Fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsci'
summary(object, extended_output = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.tsci_+3A_object">object</code></td>
<td>
<p>an object of class 'tsci'.</p>
</td></tr>
<tr><td><code id="summary.tsci_+3A_extended_output">extended_output</code></td>
<td>
<p>logical. If <code>TRUE</code> are more detailed summary is returned.</p>
</td></tr>
<tr><td><code id="summary.tsci_+3A_...">...</code></td>
<td>
<p>arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class 'summary.tsci' containing the following elements:
</p>

<dl>
<dt><code>coefficient</code></dt><dd><p>a data frame with columns for the estimated treatment coefficient, its standard error, confidence interval and (two-sided) p-value.</p>
</dd>
<dt><code>invalidity</code></dt><dd><p>a vector containing the number of times the instrumental variable(s) were considered valid, invalid or too weak to perform the test.</p>
</dd>
<dt><code>viospace_selection</code></dt><dd><p>a data frame with columns for the number of times each of the violation space candidate was selected by comparison,
the conservative method and as the largest violation space candidate for which the instrumental variable was considered to be strong enough.</p>
</dd>
<dt><code>treatment_model</code></dt><dd><p>a data frame with information about the method used to fit the treatment model.</p>
</dd>
<dt><code>sample_size_A1</code></dt><dd><p>the number of observations in the subset used to fit the outcome model.</p>
</dd>
<dt><code>sample_size_A2</code></dt><dd><p>the number of observations in the subset used to train the parameters for fitting the treatment model.</p>
</dd>
<dt><code>n_splits</code></dt><dd><p>the number of sample splits performed.</p>
</dd>
<dt><code>mult_split_method</code></dt><dd><p>the method used to calculate the standard errors and p-values if <code>n_splits</code> is larger than 1.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>the significance level used.</p>
</dd>
<dt><code>iv_strength</code></dt><dd><p>a data frame with columns containing the estimated instrumental variable strength and the estimated instrumental variable strength threshold
for each violation space candidate. Will only be returned if <code>extended_output</code> is true.</p>
</dd>
<dt><code>coefficients_all</code></dt><dd><p>a data frame with columns for the estimated treatment coefficients, its standard errors, confidence intervals and (two-sided) p-values for
each violation space candidate.</p>
</dd>
</dl>


<hr>
<h2 id='tsci_boosting'>Two Stage Curvature Identification with Boosting</h2><span id='topic+tsci_boosting'></span>

<h3>Description</h3>

<p><code>tsci_boosting</code> implements Two Stage Curvature Identification
(Guo and Buehlmann 2022) with boosting. Through a data-dependent way, it
tests for the smallest sufficiently large violation space among a pre-specified
sequence of nested violation space candidates. Point and uncertainty estimates
of the treatment effect for all violation space candidates including the
selected violation space will be returned amongst other relevant statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsci_boosting(
  Y,
  D,
  Z,
  X = NULL,
  W = X,
  vio_space,
  create_nested_sequence = TRUE,
  sel_method = c("comparison", "conservative"),
  split_prop = 2/3,
  nrounds = 50,
  eta = 0.3,
  max_depth = c(1:6),
  subsample = 1,
  colsample_bytree = 1,
  early_stopping = TRUE,
  nfolds = 5,
  self_predict = FALSE,
  sd_boot = TRUE,
  iv_threshold = 10,
  threshold_boot = TRUE,
  alpha = 0.05,
  intercept = TRUE,
  parallel = c("no", "multicore", "snow"),
  nsplits = 10,
  mult_split_method = c("FWER", "DML"),
  ncores = 1,
  cl = NULL,
  raw_output = NULL,
  B = 300
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsci_boosting_+3A_y">Y</code></td>
<td>
<p>observations of the outcome variable. Either a numeric vector of length n
or a numeric matrix with dimension n by 1.
If outcome variable is binary use dummy encoding.</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_d">D</code></td>
<td>
<p>observations of the treatment variable. Either a numeric vector of length n
or a numeric matrix with dimension n by 1.
If treatment variable is binary use dummy encoding.</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_z">Z</code></td>
<td>
<p>observations of the instrumental variable(s). Either a vector of length n
or a matrix with dimension n by s.
If observations are not numeric dummy encoding will be applied.</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_x">X</code></td>
<td>
<p>observations of baseline covariate(s). Either a vector of length n
or a matrix with dimension n by p or <code>NULL</code>
(if no covariates should be included).
If observations are not numeric dummy encoding will be applied.</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_w">W</code></td>
<td>
<p>(transformed) observations of baseline covariate(s) used to fit the outcome model. Either a vector of length n
or a matrix with dimension n by p_w or <code>NULL</code>
(if no covariates should be included).
If observations are not numeric dummy encoding will be applied.</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_vio_space">vio_space</code></td>
<td>
<p>list with vectors of length n and/or matrices with n rows as elements to
specify the violation space candidates.
If observations are not numeric dummy encoding will be applied.
See Details for more information.</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_create_nested_sequence">create_nested_sequence</code></td>
<td>
<p>logical. If <code>TRUE</code>, the violation space candidates (in form of matrices)
are defined sequentially starting with an empty violation matrix and subsequently
adding the next element of <code>vio_space</code> to the current violation matrix.
If <code>FALSE,</code> the violation space candidates (in form of matrices) are defined as the empty space and the elements of <code>vio_space</code>.
See Details for more information.</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_sel_method">sel_method</code></td>
<td>
<p>The selection method used to estimate the treatment effect. Either &quot;comparison&quot; or &quot;conservative&quot;. See Details.</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_split_prop">split_prop</code></td>
<td>
<p>proportion of observations used to fit the outcome model. Has to be a value in (0, 1).</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_nrounds">nrounds</code></td>
<td>
<p>number of boosting iterations.
Can either be a single integer value or a vector of integer values to try.</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_eta">eta</code></td>
<td>
<p>learning rate of the boosting algorithm.
Can either be a single numeric value or a vector of numeric values to try.</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_max_depth">max_depth</code></td>
<td>
<p>maximal tree depth.
Can either be a single integer value or a vector of integer values to try.</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_subsample">subsample</code></td>
<td>
<p>subsample ratio of the training instance.
Can either be a single numeric value or a vector of numeric values to try.
Has to be a numeric value in (0, 1].</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_colsample_bytree">colsample_bytree</code></td>
<td>
<p>subsample ratio of columns when constructing each tree.
Can either be a single numeric value or a vector of numeric values to try.
Has to be a numeric value in (0, 1].</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_early_stopping">early_stopping</code></td>
<td>
<p>logical. If <code>TRUE</code>, early stopping will be applied to
choose the optimal number of boosting iteration using the cross-validation mean squared error.</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_nfolds">nfolds</code></td>
<td>
<p>a positive integer value specifying the number of folds used for cross-validation to choose best parameter combination.</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_self_predict">self_predict</code></td>
<td>
<p>logical. If <code>FALSE</code>, it sets the diagonal of the hat matrix
of each tree to zero to avoid self-prediction and rescales the off-diagonal elements accordingly.</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_sd_boot">sd_boot</code></td>
<td>
<p>logical. if <code>TRUE</code>, it determines the standard error using a bootstrap approach.</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_iv_threshold">iv_threshold</code></td>
<td>
<p>a numeric value specifying the minimum of the threshold of IV strength test.</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_threshold_boot">threshold_boot</code></td>
<td>
<p>logical. if <code>TRUE</code>, it determines the threshold of the IV strength using a bootstrap approach.
If <code>FALSE</code>, it does not perform a bootstrap. See Details.</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_alpha">alpha</code></td>
<td>
<p>the significance level. Has to be a numeric value between 0 and 1.</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_intercept">intercept</code></td>
<td>
<p>logical. If <code>TRUE</code>, an intercept is included in the outcome model.</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_parallel">parallel</code></td>
<td>
<p>one out of <code>"no"</code>, <code>"multicore"</code>, or <code>"snow"</code> specifying the parallelization method used.</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_nsplits">nsplits</code></td>
<td>
<p>number of times the data will be split. Has to be an integer larger or equal 1. See Details.</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_mult_split_method">mult_split_method</code></td>
<td>
<p>method to calculate the standard errors, p-values and to construct the confidence intervals if multi-splitting is performed.
Default is &quot;DML&quot; if <code>nsplits</code> == 1 and &quot;FWER&quot; otherwise. See Details.</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_ncores">ncores</code></td>
<td>
<p>the number of cores to use. Has to be an integer value larger or equal 1.</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_cl">cl</code></td>
<td>
<p>either a parallel or snow cluster or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_raw_output">raw_output</code></td>
<td>
<p>logical. If <code>TRUE</code>, the coefficient and standard error estimates of each split will be returned.
This is only needed for the use of the function <code>confint</code> if <code>mult_split_method</code> equals &quot;FWER&quot;. Default is
<code>TRUE</code> if <code>mult_split_method</code> is <code>TRUE</code> and <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="tsci_boosting_+3A_b">B</code></td>
<td>
<p>number of bootstrap samples. Has to be a positive integer value.
Bootstrap methods are used to calculate the IV strength threshold if <code>threshold_boot</code> is <code>TRUE</code> and for the violation space selection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The treatment and outcome models are assumed to be of the following forms:
</p>
<p style="text-align: center;"><code class="reqn">D_i = f(Z_i, X_i) + \delta_i</code>
</p>

<p style="text-align: center;"><code class="reqn">Y_i = \beta \cdot D_i + h(Z_i, X_i) + \phi(X_i) + \epsilon_i</code>
</p>

<p>where <code class="reqn">f(Z_i, X_i)</code> is estimated using L2 boosting with regression trees as base learners,
<code class="reqn">h(Z_i X_i)</code> is approximated using the violation space candidates and <code class="reqn">\phi(X_i)</code> is approximated by
a linear combination of the columns in <code>W</code>. The errors are allowed to be heteroscedastic.
To avoid overfitting bias the data is randomly split into two subsets <code class="reqn">A1</code> and <code class="reqn">A2</code>
where the proportion of observations in the two sets is specified by <code>split_prop</code>.
<code class="reqn">A2</code> is used to train the random forest and <code class="reqn">A1</code> is used to perform violation space selection
and to estimate the treatment effect. <br /> <br />
The package <code>xgboost</code> is used for boosting. If any of <code>nrounds</code>,
<code>eta</code>, <code>max_depth</code>, <code>subsample</code> or <code>colsample_bytree</code> has more than one value,
the best parameter combination is chosen by minimizing the cross-validation mean squared error. <br /> <br />
The violation space candidates should be in a nested sequence as the violation space selection is performed
by comparing the treatment estimate obtained by each violation space candidate with the estimates of all
violation space candidates further down the list <code>vio_space</code> that provide enough IV strength. Only if no
significant difference was found in all of those comparisons, the violation space
candidate will be selected. If <code>sel_method</code> is 'comparison', the treatment effect estimate of this
violation space candidate will be returned. If <code>sel_method</code> is 'conservative', the treatment effect estimate
of the successive violation space candidate will be returned provided that the IV strength is large enough.
The specification of suitable violation space candidates is a crucial step because a poor approximation
of <code class="reqn">g(Z_i, X_i)</code> might not address the bias caused by the violation of the IV assumption sufficiently well.
The function <code><a href="#topic+create_monomials">create_monomials</a></code> can be used to create a predefined sequence of
violation space candidates consisting of monomials.
The function <code><a href="#topic+create_interactions">create_interactions</a></code> can be used to create a predefined sequence of
violation space candidates consisting of two-way interactions between the instrumens themselves and between
the instruments and the instruments and baseline covariates.  <br /> <br />
<code>W</code> should be chosen to be flexible enough to approximate the functional form of <code class="reqn">\phi</code> well
as otherwise the treatment estimator might be biased. <br /> <br />
The instrumental variable(s) are considered strong enough for violation space candidate <code class="reqn">V_q</code> if the estimated IV strength using this
violation space candidate is larger than the obtained value of the threshold of the IV strength.
The formula of the threshold of the IV strength has the form
<code class="reqn">\min \{\max \{ 2 \cdot \mathrm{Trace} [ \mathrm{M} (V_q) ], \mathrm{iv{\_}threshold} \} + S (V_q), 40 \}</code> if <code>threshold_boot</code> is <code>TRUE</code>, and
<code class="reqn">\min \{\max \{ 2 \cdot \mathrm{Trace} [ \mathrm{M} (V_q) ], \mathrm{iv{\_}threshold} \}, 40 \}</code> if <code>threshold_boot</code> is <code>FALSE</code>. The matrix
<code class="reqn">\mathrm{M} (V_q)</code> depends on the hat matrix obtained from estimating <code class="reqn">f(Z_i, X_i)</code>, the violation space candidate <code class="reqn">V_q</code> and
the variables to include in the outcome model <code>W</code>. <code class="reqn">S (V_q)</code> is obtained using a bootstrap and aims to adjust for the estimation error
of the IV strength.
Usually, the value of the threshold of the IV strength obtained using the bootstrap approach is larger.
Thus, using <code>threshold_boot</code> equals <code>TRUE</code> leads to a more conservative IV strength test.
For more information see subsection 3.3 in Guo and Buehlmann (2022).<br /> <br />
<code>nsplits</code> specifies the number of data splits that should be performed.
For each data split the output statistics such as the point estimates of the
treatment effect are calculated. Those statistics will then be aggregated
over the different data splits. It is recommended to perform multiple data splits
as data splitting introduces additional randomness. By aggregating the results
of multiple data splits, the effects of this randomness can be decreased.
If <code>nsplits</code> is larger than 1, point estimates are aggregated by medians.
Standard errors, p-values and confidence intervals are obtained by the method
specified by the parameter <code>mult_split_method</code>. 'DML' uses the approach by
Chernozhukov et al. (2018). 'FWER' uses the approach by Meinshausen et al. (2009)
and controls for the family-wise error rate. 'FWER' does not provide standard errors.
For large sample sizes, a large values for <code>nsplits</code> can lead to a high
running time as for each split a new hat matrix must be calculated. <br /> <br />
There are three possibilities to set the argument <code>parallel</code>, namely
<code>"no"</code> for serial evaluation (default),
<code>"multicore"</code> for parallel evaluation using forking,
and <code>"snow"</code> for parallel evaluation using a parallel
socket cluster. It is recommended to select <a href="base.html#topic+RNGkind">RNGkind</a>
(<code>"L'Ecuyer-CMRG"</code>) and to set a seed to ensure that the parallel
computing of the package <code>TSCI</code> is reproducible.
This ensures that each processor receives a different substream of the
pseudo random number generator stream.
Thus, the results are reproducible if the arguments (including <code>ncores</code>)
remain unchanged.
There is an optional argument <code>cl</code> to specify a custom cluster
if <code>parallel = "snow"</code>. <br /> <br />
See also Carl et al. (2023) for more details.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt><code>Coef_all</code></dt><dd><p>a series of point estimates of the treatment effect
obtained by the different violation space candidates.</p>
</dd>
<dt><code>sd_all</code></dt><dd><p>standard errors of the estimates of the treatmnet effect
obtained by the different violation space candidates.</p>
</dd>
<dt><code>pval_all</code></dt><dd><p>p-values of the treatment effect estimates obtained by the
different violation space candidates.</p>
</dd>
<dt><code>CI_all</code></dt><dd><p>confidence intervals for the treatment effect obtained by the
different violation space candidates.</p>
</dd>
<dt><code>Coef_sel</code></dt><dd><p>the point estimator of the treatment effect obtained by
the selected violation space candidate(s).</p>
</dd>
<dt><code>sd_sel</code></dt><dd><p>the standard error of Coef_sel.</p>
</dd>
<dt><code>pval_sel</code></dt><dd><p>p-value of the treatment effect estimate obtained by the
selected violation space candidate(s).</p>
</dd>
<dt><code>CI_sel</code></dt><dd><p>confidence interval for the treatment effect obtained by
the selected violation space candidate(s).</p>
</dd>
<dt><code>iv_str</code></dt><dd><p>IV strength using the different violation space candidates.</p>
</dd>
<dt><code>iv_thol</code></dt><dd><p>the threshold for the IV strength using the different violation space candidates.</p>
</dd>
<dt><code>Qmax</code></dt><dd><p>the frequency each violation space candidate was the largest violation space candidate
for which the IV strength was considered large enough determined by the IV strength test over the multiple data splits.
If 0, the IV Strength test failed for the first violation space candidate.
Otherwise, violation space selection was performed.</p>
</dd>
<dt><code>q_comp</code></dt><dd><p>the frequency each violation space candidate was selected by the comparison method over the multiple data splits.</p>
</dd>
<dt><code>q_cons</code></dt><dd><p>the frequency each violation space candidate was selected by the conservative method over the multiple data splits.</p>
</dd>
<dt><code>invalidity</code></dt><dd><p>the frequency the instrumental variable(s) were considered valid, invalid or too weak to test for violations.
The instrumental variables are considered too weak to test for violations if the IV strength is already too weak using the first
violation space candidate (besides the empty violation space). Testing for violations is always performed by using the comparison method.</p>
</dd>
<dt><code>mse</code></dt><dd><p>the out-of-sample mean squared error of the fitted treatment model.</p>
</dd>
<dt><code>FirstStage_model</code></dt><dd><p>the method used to fit the treatment model.</p>
</dd>
<dt><code>n_A1</code></dt><dd><p>number of observations in A1.</p>
</dd>
<dt><code>n_A2</code></dt><dd><p>number of observations in A2.</p>
</dd>
<dt><code>nsplits</code></dt><dd><p>number of data splits performed.</p>
</dd>
<dt><code>mult_split_method</code></dt><dd><p>the method used to calculate the standard errors and p-values.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>the significance level used.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p>Zijian Guo, and Peter Buehlmann. Two Stage Curvature Identification with
Machine Learning: Causal Inference with Possibly Invalid Instrumental Variables.
<em>arXiv:2203.12808</em>, 2022
</p>
</li>
<li><p>Nicolai Meinshausen, Lukas Meier, and Peter Buehlmann. P-values for high-dimensional
regression. <em>Journal of the American Statistical Association</em>,
104(488):1671-1681, 2009. 16, 18
</p>
</li>
<li><p>Victor Chernozhukov, Denis Chetverikov, Mert Demirer, Esther Duflo, Christian Hansen,
Whitney Newey, and James Robins. Double/debiased machine learning for treatment
and structural parameters: Double/debiased machine learning.
<em>The Econometrics Journal</em>, 21(1), 2018. 4, 16, 18
</p>
</li>
<li><p>David Carl, Corinne Emmenegger, Peter Buehlmann, and Zijian Guo. TSCI:
two stage curvature identification for causal inference with invalid instruments.
<em>arXiv:2304.00513</em>, 2023
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+tsci_forest">tsci_forest</a></code> for TSCI with random forest. <br /> <br />
<code><a href="#topic+tsci_poly">tsci_poly</a></code> for TSCI with polynomial basis expansion. <br /> <br />
<code><a href="#topic+tsci_secondstage">tsci_secondstage</a></code> for TSCI with user provided hat matrix. <br /> <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### a small example without baseline covariates
if (require("MASS")) {
  # sample size
  n &lt;- 100
  # the IV strength
  a &lt;- 1
  # the violation strength
  tau &lt;- 1
  # true effect
  beta &lt;- 1
  # treatment model
  f &lt;- function(x) {1 + a * (x + x^2)}
  # outcome model
  g &lt;- function(x) {1 + tau * x}

  # generate data
  mu_error &lt;- rep(0, 2)
  Cov_error &lt;- matrix(c(1, 0.5, 0.5, 1), 2, 2)
  Error &lt;- MASS::mvrnorm(n, mu_error, Cov_error)
  # instrumental variable
  Z &lt;- rnorm(n)
  # treatment variable
  D &lt;- f(Z) + Error[, 1]
  # outcome variable
  Y &lt;- beta * D + g(Z) + Error[, 2]

  # Two Stage L2 Boosting
  # create violation space candidates
  vio_space &lt;- create_monomials(Z, 2, "monomials_main")
  # perform two stage curvature identification
  output_BO &lt;- tsci_boosting(Y, D, Z, vio_space = vio_space, nsplits = 1,
                             max_depth = 2, nrounds = 10, B = 100)
  summary(output_BO)
}
</code></pre>

<hr>
<h2 id='tsci_forest'>Two Stage Curvature Identification with Random Forests</h2><span id='topic+tsci_forest'></span>

<h3>Description</h3>

<p><code>tsci_forest</code> implements Two Stage Curvature Identification
(Guo and Buehlmann 2022) with random forests. Through a data-dependent way, it
tests for the smallest sufficiently large violation space among a pre-specified
sequence of nested violation space candidates. Point and uncertainty estimates
of the treatment effect for all violation space candidates including the
selected violation space will be returned amongst other relevant statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsci_forest(
  Y,
  D,
  Z,
  X = NULL,
  W = X,
  vio_space,
  create_nested_sequence = TRUE,
  sel_method = c("comparison", "conservative"),
  split_prop = 2/3,
  num_trees = 200,
  mtry = NULL,
  max_depth = 0,
  min_node_size = c(5, 10, 20),
  self_predict = FALSE,
  sd_boot = TRUE,
  iv_threshold = 10,
  threshold_boot = TRUE,
  alpha = 0.05,
  nsplits = 10,
  mult_split_method = c("FWER", "DML"),
  intercept = TRUE,
  parallel = c("no", "multicore", "snow"),
  ncores = 1,
  cl = NULL,
  raw_output = NULL,
  B = 300
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsci_forest_+3A_y">Y</code></td>
<td>
<p>observations of the outcome variable. Either a numeric vector of length n
or a numeric matrix with dimension n by 1.
If outcome variable is binary use dummy encoding.</p>
</td></tr>
<tr><td><code id="tsci_forest_+3A_d">D</code></td>
<td>
<p>observations of the treatment variable. Either a numeric vector of length n
or a numeric matrix with dimension n by 1.
If treatment variable is binary use dummy encoding.</p>
</td></tr>
<tr><td><code id="tsci_forest_+3A_z">Z</code></td>
<td>
<p>observations of the instrumental variable(s). Either a vector of length n
or a matrix with dimension n by s.
If observations are not numeric dummy encoding will be applied.</p>
</td></tr>
<tr><td><code id="tsci_forest_+3A_x">X</code></td>
<td>
<p>observations of baseline covariate(s). Either a vector of length n
or a matrix with dimension n by p or <code>NULL</code>
(if no covariates should be included).
If observations are not numeric dummy encoding will be applied.</p>
</td></tr>
<tr><td><code id="tsci_forest_+3A_w">W</code></td>
<td>
<p>(transformed) observations of baseline covariate(s) used to fit the outcome model. Either a vector of length n
or a matrix with dimension n by p_w or <code>NULL</code>
(if no covariates should be included).
If observations are not numeric dummy encoding will be applied.</p>
</td></tr>
<tr><td><code id="tsci_forest_+3A_vio_space">vio_space</code></td>
<td>
<p>list with vectors of length n and/or matrices with n rows as elements to
specify the violation space candidates.
If observations are not numeric dummy encoding will be applied.
See Details for more information.</p>
</td></tr>
<tr><td><code id="tsci_forest_+3A_create_nested_sequence">create_nested_sequence</code></td>
<td>
<p>logical. If <code>TRUE</code>, the violation space candidates (in form of matrices)
are defined sequentially starting with an empty violation matrix and subsequently
adding the next element of <code>vio_space</code> to the current violation matrix.
If <code>FALSE,</code> the violation space candidates (in form of matrices) are defined as the empty space and the elements of <code>vio_space</code>.
See Details for more information.</p>
</td></tr>
<tr><td><code id="tsci_forest_+3A_sel_method">sel_method</code></td>
<td>
<p>the selection method used to estimate the treatment effect. Either &quot;comparison&quot; or &quot;conservative&quot;. See Details.</p>
</td></tr>
<tr><td><code id="tsci_forest_+3A_split_prop">split_prop</code></td>
<td>
<p>proportion of observations used to fit the outcome model. Has to be a numeric value in (0, 1).</p>
</td></tr>
<tr><td><code id="tsci_forest_+3A_num_trees">num_trees</code></td>
<td>
<p>number of trees in random forests.
Can either be a single integer value or a vector of integer values to try.</p>
</td></tr>
<tr><td><code id="tsci_forest_+3A_mtry">mtry</code></td>
<td>
<p>number of covariates to possibly split at in each node of the tree of the random forest.
Can either be a single integer value or a vector of integer values to try.
Can also be a list of single argument function(s) returning an integer value, given the number of independent variables.
The values have to be positive integers not larger than the number of independent variables in the treatment model. Default
is to try all integer values between one-third of the independent variables and two-thirds of the independent variables.</p>
</td></tr>
<tr><td><code id="tsci_forest_+3A_max_depth">max_depth</code></td>
<td>
<p>maximal tree depth in random forests.
Can either be a single integer value or a vector of integer values to try.
0 correspond to unlimited depth.</p>
</td></tr>
<tr><td><code id="tsci_forest_+3A_min_node_size">min_node_size</code></td>
<td>
<p>minimal size of each leaf node in the random forest.
Can either be a single integer value or a vector of integer values to try.</p>
</td></tr>
<tr><td><code id="tsci_forest_+3A_self_predict">self_predict</code></td>
<td>
<p>logical. If <code>FALSE</code>, it sets the diagonal of the hat matrix
of each tree to zero to avoid self-prediction and rescales the off-diagonal elements accordingly.</p>
</td></tr>
<tr><td><code id="tsci_forest_+3A_sd_boot">sd_boot</code></td>
<td>
<p>logical. if <code>TRUE</code>, it determines the standard error using a bootstrap approach.</p>
</td></tr>
<tr><td><code id="tsci_forest_+3A_iv_threshold">iv_threshold</code></td>
<td>
<p>a numeric value specifying the minimum of the threshold of IV strength test.</p>
</td></tr>
<tr><td><code id="tsci_forest_+3A_threshold_boot">threshold_boot</code></td>
<td>
<p>logical. If <code>TRUE</code>, it determines the threshold of the IV strength using a bootstrap approach.
If <code>FALSE</code>, it does not perform a bootstrap. See Details.</p>
</td></tr>
<tr><td><code id="tsci_forest_+3A_alpha">alpha</code></td>
<td>
<p>the significance level. Has to be a numeric value between 0 and 1.</p>
</td></tr>
<tr><td><code id="tsci_forest_+3A_nsplits">nsplits</code></td>
<td>
<p>number of times the data will be split. Has to be an integer larger or equal 1. See Details.</p>
</td></tr>
<tr><td><code id="tsci_forest_+3A_mult_split_method">mult_split_method</code></td>
<td>
<p>method to calculate the standard errors, p-values and to construct the confidence intervals if multi-splitting is performed.
Default is &quot;DML&quot; if <code>nsplits</code> == 1 and &quot;FWER&quot; otherwise. See Details.</p>
</td></tr>
<tr><td><code id="tsci_forest_+3A_intercept">intercept</code></td>
<td>
<p>logical. If <code>TRUE</code>, an intercept is included in the outcome model.</p>
</td></tr>
<tr><td><code id="tsci_forest_+3A_parallel">parallel</code></td>
<td>
<p>one out of <code>"no"</code>, <code>"multicore"</code>, or <code>"snow"</code>
specifying the parallelization method used. See Details.</p>
</td></tr>
<tr><td><code id="tsci_forest_+3A_ncores">ncores</code></td>
<td>
<p>the number of cores to use. Has to be an integer value larger or equal 1.</p>
</td></tr>
<tr><td><code id="tsci_forest_+3A_cl">cl</code></td>
<td>
<p>either a parallel or snow cluster or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="tsci_forest_+3A_raw_output">raw_output</code></td>
<td>
<p>logical. If <code>TRUE</code>, the coefficient and standard error estimates of each split will be returned.
This is only needed for the use of the function <code>confint</code> if <code>mult_split_method</code> equals &quot;FWER&quot;. Default is
<code>TRUE</code> if <code>mult_split_method</code> is <code>TRUE</code> and <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="tsci_forest_+3A_b">B</code></td>
<td>
<p>number of bootstrap samples. Has to be a positive integer value.
Bootstrap methods are used to calculate the IV strength threshold if <code>threshold_boot</code> is <code>TRUE</code> and for the violation space selection.
It is also used to calculate the standard error if <code>sd_boot</code> is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The treatment and outcome models are assumed to be of the following forms:
</p>
<p style="text-align: center;"><code class="reqn">D_i = f(Z_i, X_i) + \delta_i</code>
</p>

<p style="text-align: center;"><code class="reqn">Y_i = \beta \cdot D_i + h(Z_i, X_i) + \phi(X_i) + \epsilon_i</code>
</p>

<p>where <code class="reqn">f(Z_i, X_i)</code> is estimated using a random forest,
<code class="reqn">h(Z_i X_i)</code> is approximated using the violation space candidates and <code class="reqn">\phi(X_i)</code> is approximated by
a linear combination of the columns in <code>W</code>. The errors are allowed to be heteroscedastic.
To avoid overfitting bias the data is randomly split into two subsets <code class="reqn">A1</code> and <code class="reqn">A2</code>
where the proportion of observations in the two sets is specified by <code>split_prop</code>.
<code class="reqn">A2</code> is used to train the random forest and <code class="reqn">A1</code> is used to perform violation space selection
and to estimate the treatment effect. <br /> <br />
The package <code>ranger</code> is used to fit the random forest. If any of <code>num_trees</code>,
<code>max_depth</code> or <code>min_node_size</code> has more than one value,
the best parameter combination is chosen by minimizing the out-of-bag mean squared error. <br /> <br />
The violation space candidates should be in a nested sequence as the violation space selection is performed
by comparing the treatment estimate obtained by each violation space candidate with the estimates of all
violation space candidates further down the list <code>vio_space</code> that provide enough IV strength. Only if no
significant difference was found in all of those comparisons, the violation space
candidate will be selected. If <code>sel_method</code> is 'comparison', the treatment effect estimate of this
violation space candidate will be returned. If <code>sel_method</code> is 'conservative', the treatment effect estimate
of the successive violation space candidate will be returned provided that the IV strength is large enough.
The specification of suitable violation space candidates is a crucial step because a poor approximation
of <code class="reqn">g(Z_i, X_i)</code> might not address the bias caused by the violation of the IV assumption sufficiently well.
The function <code><a href="#topic+create_monomials">create_monomials</a></code> can be used to create a predefined sequence of
violation space candidates consisting of monomials.
The function <code><a href="#topic+create_interactions">create_interactions</a></code> can be used to create a predefined sequence of
violation space candidates consisting of two-way interactions between the instrumens themselves and between
the instruments and the instruments and baseline covariates.  <br /> <br />
The instrumental variable(s) are considered strong enough for violation space candidate <code class="reqn">V_q</code> if the estimated IV strength using this
violation space candidate is larger than the obtained value of the threshold of the IV strength.
The formula of the threshold of the IV strength has the form
<code class="reqn">\min \{\max \{ 2 \cdot \mathrm{Trace} [ \mathrm{M} (V_q) ], \mathrm{iv{\_}threshold} \} + S (V_q), 40 \}</code> if <code>threshold_boot</code> is <code>TRUE</code>, and
<code class="reqn">\min \{\max \{ 2 \cdot \mathrm{Trace} [ \mathrm{M} (V_q) ], \mathrm{iv{\_}threshold} \}, 40 \}</code> if <code>threshold_boot</code> is <code>FALSE</code>. The matrix
<code class="reqn">\mathrm{M} (V_q)</code> depends on the hat matrix obtained from estimating <code class="reqn">f(Z_i, X_i)</code>, the violation space candidate <code class="reqn">V_q</code> and
the variables to include in the outcome model <code>W</code>. <code class="reqn">S (V_q)</code> is obtained using a bootstrap and aims to adjust for the estimation error
of the IV strength.
Usually, the value of the threshold of the IV strength obtained using the bootstrap approach is larger.
Thus, using <code>threshold_boot</code> equals <code>TRUE</code> leads to a more conservative IV strength test.
For more information see subsection 3.3 in Guo and Buehlmann (2022).<br /> <br />
<code>nsplits</code> specifies the number of data splits that should be performed.
For each data split the output statistics such as the point estimates of the
treatment effect are calculated. Those statistics will then be aggregated
over the different data splits. It is recommended to perform multiple data splits
as data splitting introduces additional randomness. By aggregating the results
of multiple data splits, the effects of this randomness can be decreased.
If <code>nsplits</code> is larger than 1, point estimates are aggregated by medians.
Standard errors, p-values and confidence intervals are obtained by the method
specified by the parameter <code>mult_split_method</code>. 'DML' uses the approach by
Chernozhukov et al. (2018). 'FWER' uses the approach by Meinshausen et al. (2009)
and controls for the family-wise error rate. 'FWER' does not provide standard errors.
For large sample sizes, a large values for <code>nsplits</code> can lead to a high
running time as for each split a new hat matrix must be calculated. <br /> <br />
There are three possibilities to set the argument <code>parallel</code>, namely
<code>"no"</code> for serial evaluation (default),
<code>"multicore"</code> for parallel evaluation using forking,
and <code>"snow"</code> for parallel evaluation using a parallel
socket cluster. It is recommended to select <a href="base.html#topic+RNGkind">RNGkind</a>
(<code>"L'Ecuyer-CMRG"</code>) and to set a seed to ensure that the parallel
computing of the package <code>TSCI</code> is reproducible.
This ensures that each processor receives a different substream of the
pseudo random number generator stream.
Thus, the results are reproducible if the arguments (including <code>ncores</code>)
remain unchanged.
There is an optional argument <code>cl</code> to specify a custom cluster
if <code>parallel = "snow"</code>. <br /> <br />
Results obtained on different operating systems might differ even when the same
seed is set. The reason for this lies in the way the random forest algorithm in
<code>ranger</code> is implemented. Currently, we are not aware of a solution to
ensure reproducibility across operating systems when using <code>tsci_forest</code>.
However, <code><a href="#topic+tsci_boosting">tsci_boosting</a></code>, <code><a href="#topic+tsci_poly">tsci_poly</a></code> and
<code><a href="#topic+tsci_secondstage">tsci_secondstage</a></code> do not have this issue.
</p>
<p>See also Carl et al. (2023) for more details.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt><code>Coef_all</code></dt><dd><p>a series of point estimates of the treatment effect
obtained by the different violation space candidates.</p>
</dd>
<dt><code>sd_all</code></dt><dd><p>standard errors of the estimates of the treatmnet effect
obtained by the different violation space candidates.</p>
</dd>
<dt><code>pval_all</code></dt><dd><p>p-values of the treatment effect estimates obtained by the
different violation space candidates.</p>
</dd>
<dt><code>CI_all</code></dt><dd><p>confidence intervals for the treatment effect obtained by the
different violation space candidates.</p>
</dd>
<dt><code>Coef_sel</code></dt><dd><p>the point estimator of the treatment effect obtained by
the selected violation space candidate(s).</p>
</dd>
<dt><code>sd_sel</code></dt><dd><p>the standard error of Coef_sel.</p>
</dd>
<dt><code>pval_sel</code></dt><dd><p>p-value of the treatment effect estimate obtained by the
selected violation space candidate(s).</p>
</dd>
<dt><code>CI_sel</code></dt><dd><p>confidence interval for the treatment effect obtained by
the selected violation space candidate(s).</p>
</dd>
<dt><code>iv_str</code></dt><dd><p>IV strength using the different violation space candidates.</p>
</dd>
<dt><code>iv_thol</code></dt><dd><p>the threshold for the IV strength using the different violation space candidates.</p>
</dd>
<dt><code>Qmax</code></dt><dd><p>the frequency each violation space candidate was the largest violation space candidate
for which the IV strength was considered large enough determined by the IV strength test over the multiple data splits.
If 0, the IV Strength test failed for the first violation space candidate.
Otherwise, violation space selection was performed.</p>
</dd>
<dt><code>q_comp</code></dt><dd><p>the frequency each violation space candidate was selected by the comparison method over the multiple data splits.</p>
</dd>
<dt><code>q_cons</code></dt><dd><p>the frequency each violation space candidate was selected by the conservative method over the multiple data splits.</p>
</dd>
<dt><code>invalidity</code></dt><dd><p>the frequency the instrumental variable(s) were considered valid, invalid or too weak to test for violations.
The instrumental variables are considered too weak to test for violations if the IV strength is already too weak using the first
violation space candidate (besides the empty violation space). Testing for violations is always performed by using the comparison method.</p>
</dd>
<dt><code>mse</code></dt><dd><p>the out-of-sample mean squared error of the fitted treatment model.</p>
</dd>
<dt><code>FirstStage_model</code></dt><dd><p>the method used to fit the treatment model.</p>
</dd>
<dt><code>n_A1</code></dt><dd><p>number of observations in A1.</p>
</dd>
<dt><code>n_A2</code></dt><dd><p>number of observations in A2.</p>
</dd>
<dt><code>nsplits</code></dt><dd><p>number of data splits performed.</p>
</dd>
<dt><code>mult_split_method</code></dt><dd><p>the method used to calculate the standard errors and p-values.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>the significance level used.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p>Zijian Guo, and Peter Buehlmann. Two Stage Curvature Identification with
Machine Learning: Causal Inference with Possibly Invalid Instrumental Variables.
<em>arXiv:2203.12808</em>, 2022
</p>
</li>
<li><p>Nicolai Meinshausen, Lukas Meier, and Peter Buehlmann. P-values for high-dimensional
regression. <em>Journal of the American Statistical Association</em>,
104(488):1671-1681, 2009. 16, 18
</p>
</li>
<li><p>Victor Chernozhukov, Denis Chetverikov, Mert Demirer, Esther Duflo, Christian Hansen,
Whitney Newey, and James Robins. Double/debiased machine learning for treatment
and structural parameters: Double/debiased machine learning.
<em>The Econometrics Journal</em>, 21(1), 2018. 4, 16, 18
</p>
</li>
<li><p>David Carl, Corinne Emmenegger, Peter Buehlmann, and Zijian Guo. TSCI:
two stage curvature identification for causal inference with invalid instruments.
<em>arXiv:2304.00513</em>, 2023
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+tsci_boosting">tsci_boosting</a></code> for TSCI with boosting. <br /> <br />
<code><a href="#topic+tsci_poly">tsci_poly</a></code> for TSCI with polynomial basis expansion. <br /> <br />
<code><a href="#topic+tsci_secondstage">tsci_secondstage</a></code> for TSCI with user provided hat matrix. <br /> <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### a small example without baseline covariates
if (require("MASS")) {
  # sample size
  n &lt;- 100
  # the IV strength
  a &lt;- 1
  # the violation strength
  tau &lt;- 1
  # true effect
  beta &lt;- 1
  # treatment model
  f &lt;- function(x) {1 + a * (x + x^2)}
  # outcome model
  g &lt;- function(x) {1 + tau * x}

  # generate data
  mu_error &lt;- rep(0, 2)
  Cov_error &lt;- matrix(c(1, 0.5, 0.5, 1), 2, 2)
  Error &lt;- MASS::mvrnorm(n, mu_error, Cov_error)
  # instrumental variable
  Z &lt;- rnorm(n)
  # treatment variable
  D &lt;- f(Z) + Error[, 1]
  # outcome variable
  Y &lt;- beta * D + g(Z) + Error[, 2]

  # Two Stage Random Forest
  # create violation space candidates
  vio_space &lt;- create_monomials(Z, 2, "monomials_main")
  # perform two stage curvature identification
  output_RF &lt;- tsci_forest(Y, D, Z, vio_space = vio_space, nsplits = 1,
                           num_trees = 50, B = 100)
  summary(output_RF)
}
</code></pre>

<hr>
<h2 id='tsci_poly'>Two Stage Curvature Identification with Polynomial Basis Expansion</h2><span id='topic+tsci_poly'></span>

<h3>Description</h3>

<p><code>tsci_poly</code> implements Two Stage Curvature Identification
(Guo and Buehlmann 2022) with a basis expansion by monomials. Through a data-dependent way it
tests for the smallest sufficiently large violation space among a pre-specified
sequence of nested violation space candidates. Point and uncertainty estimates
of the treatment effect for all violation space candidates including the
selected violation space will be returned amongst other relevant statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsci_poly(
  Y,
  D,
  Z,
  X = NULL,
  W = X,
  vio_space = NULL,
  create_nested_sequence = TRUE,
  sel_method = c("comparison", "conservative"),
  min_order = 1,
  max_order = 10,
  exact_order = NULL,
  order_selection_method = c("grid search", "backfitting"),
  max_iter = 100,
  conv_tol = 10^-6,
  gcv = FALSE,
  nfolds = 5,
  sd_boot = TRUE,
  iv_threshold = 10,
  threshold_boot = TRUE,
  alpha = 0.05,
  intercept = TRUE,
  B = 300
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsci_poly_+3A_y">Y</code></td>
<td>
<p>observations of the outcome variable. Either a numeric vector of length n
or a numeric matrix with dimension n by 1.
If outcome variable is binary use dummy encoding.</p>
</td></tr>
<tr><td><code id="tsci_poly_+3A_d">D</code></td>
<td>
<p>observations of the treatment variable. Either a numeric vector of length n
or a numeric matrix with dimension n by 1.
If treatment variable is binary use dummy encoding.</p>
</td></tr>
<tr><td><code id="tsci_poly_+3A_z">Z</code></td>
<td>
<p>observations of the instrumental variable(s). Either a vector of length n
or a matrix with dimension n by s.
If observations are not numeric dummy encoding will be applied.</p>
</td></tr>
<tr><td><code id="tsci_poly_+3A_x">X</code></td>
<td>
<p>observations of baseline covariate(s). Either a vector of length n
or a matrix with dimension n by p or <code>NULL</code>
(if no covariates should be included).
If observations are not numeric dummy encoding will be applied.</p>
</td></tr>
<tr><td><code id="tsci_poly_+3A_w">W</code></td>
<td>
<p>(transformed) observations of baseline covariate(s) used to fit the outcome model. Either a vector of length n
or a matrix with dimension n by p_w or <code>NULL</code>
(if no covariates should be included).
If observations are not numeric dummy encoding will be applied.</p>
</td></tr>
<tr><td><code id="tsci_poly_+3A_vio_space">vio_space</code></td>
<td>
<p>either <code>NULL</code> or a list with numeric vectors of length n and/or numeric matrices with n rows as elements to
specify the violation space candidates.
If observations are not numeric dummy encoding will be applied.
See Details for more information.
If <code>NULL</code>, then the violation space candidates are chosen to be a nested sequence
of monomials with degree depending on the orders of the polynomials used to fit
the treatment model.</p>
</td></tr>
<tr><td><code id="tsci_poly_+3A_create_nested_sequence">create_nested_sequence</code></td>
<td>
<p>logical. If <code>TRUE</code>, the violation space candidates (in form of matrices)
are defined sequentially starting with an empty violation matrix and subsequently
adding the next element of <code>vio_space</code> to the current violation matrix.
If <code>FALSE,</code> the violation space candidates (in form of matrices) are defined as the empty space and the elements of <code>vio_space</code>.
See Details for more information.</p>
</td></tr>
<tr><td><code id="tsci_poly_+3A_sel_method">sel_method</code></td>
<td>
<p>The selection method used to estimate the treatment effect. Either &quot;comparison&quot; or &quot;conservative&quot;. See Details.</p>
</td></tr>
<tr><td><code id="tsci_poly_+3A_min_order">min_order</code></td>
<td>
<p>either a single integer value or a vector of integer values of length s specifying
the smallest order of polynomials to use in the selection of the treatment model. If a
single integer value is provided, the polynomials of all instrumental variables use this value.</p>
</td></tr>
<tr><td><code id="tsci_poly_+3A_max_order">max_order</code></td>
<td>
<p>either a single integer value or a vector of integer values of length s specifying
the largest order of polynomials to use in the selection of the treatment model. If a
single integer value is provided, the polynomials of all instrumental variables use this value.</p>
</td></tr>
<tr><td><code id="tsci_poly_+3A_exact_order">exact_order</code></td>
<td>
<p>either a single integer value or a vector of integer values of length s specifying
the exact order of polynomials to use in the treatment model. If a
single integer value is provided, the polynomials of all instrumental variables use this value.</p>
</td></tr>
<tr><td><code id="tsci_poly_+3A_order_selection_method">order_selection_method</code></td>
<td>
<p>method used to select the best fitting order of polynomials
for the treatment model. Must be either 'grid search' or 'backfitting'.
'grid search' can be very slow if the number of instruments is large.</p>
</td></tr>
<tr><td><code id="tsci_poly_+3A_max_iter">max_iter</code></td>
<td>
<p>number of iterations used in the backfitting algorithm if <code>order_selection_method</code> is 'backfitting'.
Has to be a positive integer value.</p>
</td></tr>
<tr><td><code id="tsci_poly_+3A_conv_tol">conv_tol</code></td>
<td>
<p>tolerance of convergence in the backfitting algorithm if <code>order_selection_method</code> is 'backfitting'.</p>
</td></tr>
<tr><td><code id="tsci_poly_+3A_gcv">gcv</code></td>
<td>
<p>logical. If <code>TRUE</code>, the generalized cross-validation mean squared error is used
to determine the best fitting order of polynomials for the treatment model.
If <code>FALSE</code>, k-fold cross-validation is used instead.</p>
</td></tr>
<tr><td><code id="tsci_poly_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds used for the k-fold cross-validation if <code>gcv</code> is <code>FALSE</code>.
Has to be a positive integer value.</p>
</td></tr>
<tr><td><code id="tsci_poly_+3A_sd_boot">sd_boot</code></td>
<td>
<p>logical. if <code>TRUE</code>, it determines the standard error using a bootstrap approach.</p>
</td></tr>
<tr><td><code id="tsci_poly_+3A_iv_threshold">iv_threshold</code></td>
<td>
<p>a numeric value specifying the minimum of the threshold of IV strength test.</p>
</td></tr>
<tr><td><code id="tsci_poly_+3A_threshold_boot">threshold_boot</code></td>
<td>
<p>logical. if <code>TRUE</code>, it determines the threshold of the IV strength using a bootstrap approach.
If <code>FALSE</code>, it does not perform a bootstrap. See Details.</p>
</td></tr>
<tr><td><code id="tsci_poly_+3A_alpha">alpha</code></td>
<td>
<p>the significance level. Has to be a numeric value between 0 and 1.</p>
</td></tr>
<tr><td><code id="tsci_poly_+3A_intercept">intercept</code></td>
<td>
<p>logical. If <code>TRUE</code>, an intercept is included in the outcome model.</p>
</td></tr>
<tr><td><code id="tsci_poly_+3A_b">B</code></td>
<td>
<p>number of bootstrap samples. Has to be a positive integer value.
Bootstrap methods are used to calculate the iv strength threshold if <code>threshold_boot</code> is <code>TRUE</code> and for the violation space selection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The treatment and outcome models are assumed to be of the following forms:
</p>
<p style="text-align: center;"><code class="reqn">D_i = f(Z_i, X_i) + \delta_i</code>
</p>

<p style="text-align: center;"><code class="reqn">Y_i = \beta \cdot D_i + h(Z_i, X_i) + \phi(X_i) + \epsilon_i</code>
</p>

<p>where <code class="reqn">f(Z_i, X_i)</code> is estimated using a polynomial basis expansion of the instrumental variables
and a linear combination of the baseline covariates,
<code class="reqn">h(Z_i X_i)</code> is approximated using the violation space candidates and <code class="reqn">\phi(X_i)</code> is approximated by
a linear combination of the columns in <code>W</code>. The errors are allowed to be heteroscedastic. <br /> <br />
The violation space candidates should be in a nested sequence as the violation space selection is performed
by comparing the treatment estimate obtained by each violation space candidate with the estimates of all
violation space candidates further down the list <code>vio_space</code> that provide enough IV strength. Only if no
significant difference was found in all of those comparisons, the violation space
candidate will be selected. If <code>sel_method</code> is 'comparison', the treatment effect estimate of this
violation space candidate will be returned. If <code>sel_method</code> is 'conservative', the treatment effect estimate
of the successive violation space candidate will be returned provided that the IV strength is large enough.
If <code>vio_space</code> is <code>NULL</code> the violation space candidates are chosen to be a nested sequence
of polynomials of the instrumental variables up to the degrees used to fit the treatment model.
This guarantees that the possible spaces of the violation will be tested.
If the functional form of the outcome model is not well-known it is advisable to use the default values
for <code>W</code> and <code>vio_space</code>. <br /> <br />
The instrumental variable(s) are considered strong enough for violation space candidate <code class="reqn">V_q</code> if the estimated IV strength using this
violation space candidate is larger than the obtained value of the threshold of the IV strength.
The formula of the threshold of the IV strength has the form
<code class="reqn">\min \{\max \{ 2 \cdot \mathrm{Trace} [ \mathrm{M} (V_q) ], \mathrm{iv{\_}threshold} \} + S (V_q), 40 \}</code> if <code>threshold_boot</code> is <code>TRUE</code>, and
<code class="reqn">\min \{\max \{ 2 \cdot \mathrm{Trace} [ \mathrm{M} (V_q) ], \mathrm{iv{\_}threshold} \}, 40 \}</code> if <code>threshold_boot</code> is <code>FALSE</code>. The matrix
<code class="reqn">\mathrm{M} (V_q)</code> depends on the hat matrix obtained from estimating <code class="reqn">f(Z_i, X_i)</code>, the violation space candidate <code class="reqn">V_q</code> and
the variables to include in the outcome model <code>W</code>. <code class="reqn">S (V_q)</code> is obtained using a bootstrap and aims to adjust for the estimation error
of the IV strength.
Usually, the value of the threshold of the IV strength obtained using the bootstrap approach is larger.
Thus, using <code>threshold_boot</code> equals <code>TRUE</code> leads to a more conservative IV strength test.
For more information see subsection 3.3 in Guo and Buehlmann (2022). <br /> <br />
See also Carl et al. (2023) for more details.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt><code>Coef_all</code></dt><dd><p>a series of point estimates of the treatment effect
obtained by the different violation space candidates.</p>
</dd>
<dt><code>sd_all</code></dt><dd><p>standard errors of the estimates of the treatmnet effect
obtained by the different violation space candidates.</p>
</dd>
<dt><code>pval_all</code></dt><dd><p>p-values of the treatment effect estimates obtained by the
different violation space candidates.</p>
</dd>
<dt><code>CI_all</code></dt><dd><p>confidence intervals for the treatment effect obtained by the
different violation space candidates.</p>
</dd>
<dt><code>Coef_sel</code></dt><dd><p>the point estimator of the treatment effect obtained by
the selected violation space candidate(s).</p>
</dd>
<dt><code>sd_sel</code></dt><dd><p>the standard error of Coef_sel.</p>
</dd>
<dt><code>pval_sel</code></dt><dd><p>p-value of the treatment effect estimate obtained by the
selected violation space candidate(s).</p>
</dd>
<dt><code>CI_sel</code></dt><dd><p>confidence interval for the treatment effect obtained by
the selected violation space candidate(s).</p>
</dd>
<dt><code>iv_str</code></dt><dd><p>IV strength using the different violation space candidates.</p>
</dd>
<dt><code>iv_thol</code></dt><dd><p>the threshold for the IV strength using the different violation space candidates.</p>
</dd>
<dt><code>Qmax</code></dt><dd><p>the violation space candidate that was the largest violation space candidate
for which the IV strength was considered large enough determined by the IV strength test.
If 0, the IV Strength test failed for the first violation space candidate.
Otherwise, violation space selection was performed.</p>
</dd>
<dt><code>q_comp</code></dt><dd><p>the violation space candidate that was selected by the comparison method over the multiple data splits.</p>
</dd>
<dt><code>q_cons</code></dt><dd><p>the violation space candidate that was selected by the conservative method over the multiple data splits.</p>
</dd>
<dt><code>invalidity</code></dt><dd><p>shows whether the instrumental variable(s) were considered valid, invalid or too weak to test for violations.
The instrumental variables are considered too weak to test for violations if the IV strength is already too weak using the first
violation space candidate (besides the empty violation space). Testing for violations is always performed by using the comparison method.</p>
</dd>
<dt><code>mse</code></dt><dd><p>the out-of-sample mean squared error of the treatment model.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p>Zijian Guo, and Peter Buehlmann. Two Stage Curvature Identification with
Machine Learning: Causal Inference with Possibly Invalid Instrumental Variables.
<em>arXiv:2203.12808</em>, 2022
</p>
</li>
<li><p>David Carl, Corinne Emmenegger, Peter Buehlmann, and Zijian Guo. TSCI:
two stage curvature identification for causal inference with invalid instruments.
<em>arXiv:2304.00513</em>, 2023
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+tsci_forest">tsci_forest</a></code> for TSCI with random forest. <br /> <br />
<code><a href="#topic+tsci_boosting">tsci_boosting</a></code> for TSCI with boosting. <br /> <br />
<code><a href="#topic+tsci_secondstage">tsci_secondstage</a></code> for TSCI with user provided hat matrix. <br /> <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### a small example without baseline covariates
if (require("MASS")) {
  # sample size
  n &lt;- 100
  # the IV strength
  a &lt;- 1
  # the violation strength
  tau &lt;- 1
  # true effect
  beta &lt;- 1
  # treatment model
  f &lt;- function(x) {1 + a * (x + x^2)}
  # outcome model
  g &lt;- function(x) {1 + tau * x}

  # generate data
  mu_error &lt;- rep(0, 2)
  Cov_error &lt;- matrix(c(1, 0.5, 0.5, 1), 2, 2)
  Error &lt;- MASS::mvrnorm(n, mu_error, Cov_error)
  # instrumental variable
  Z &lt;- rnorm(n)
  # treatment variable
  D &lt;- f(Z) + Error[, 1]
  # outcome variable
  Y &lt;- beta * D + g(Z) + Error[, 2]

  # Two Stage Polynomials
  output_PO &lt;- tsci_poly(Y, D, Z, max_order = 3, max_iter = 20, B = 100)
  summary(output_PO)
}
</code></pre>

<hr>
<h2 id='tsci_secondstage'>Two Stage Curvature Identification with User Provided Hat Matrix</h2><span id='topic+tsci_secondstage'></span>

<h3>Description</h3>

<p><code>tsci_secondstage</code> implements Two Stage Curvature Identification
(Guo and Buehlmann 2022) for a user-provided hat matrix. Through a data-dependent way it
tests for the smallest sufficiently large violation space among a pre-specified
sequence of nested violation space candidates. Point and uncertainty estimates
of the treatment effect for all violation space candidates including the
selected violation space will be returned amongst other relevant statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsci_secondstage(
  Y,
  D,
  Z,
  W = NULL,
  vio_space,
  create_nested_sequence = TRUE,
  weight,
  A1_ind = NULL,
  sel_method = c("comparison", "conservative"),
  sd_boot = TRUE,
  iv_threshold = 10,
  threshold_boot = TRUE,
  alpha = 0.05,
  intercept = TRUE,
  B = 300
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsci_secondstage_+3A_y">Y</code></td>
<td>
<p>observations of the outcome variable. Either a numeric vector of length n
or a numeric matrix with dimension n by 1.
If outcome variable is binary use dummy encoding.</p>
</td></tr>
<tr><td><code id="tsci_secondstage_+3A_d">D</code></td>
<td>
<p>observations of the treatment variable. Either a numeric vector of length n
or a numeric matrix with dimension n by 1.
If treatment variable is binary use dummy encoding.</p>
</td></tr>
<tr><td><code id="tsci_secondstage_+3A_z">Z</code></td>
<td>
<p>observations of the instrumental variable(s). Either a vector of length n
or a matrix with dimension n by s.
If observations are not numeric dummy encoding will be applied.</p>
</td></tr>
<tr><td><code id="tsci_secondstage_+3A_w">W</code></td>
<td>
<p>(transformed) observations of baseline covariate(s) used to fit the outcome model. Either a vector of length n
or a matrix with dimension n by p_w or <code>NULL</code>
(if no covariates should be included).
If observations are not numeric dummy encoding will be applied.</p>
</td></tr>
<tr><td><code id="tsci_secondstage_+3A_vio_space">vio_space</code></td>
<td>
<p>list with vectors of length n and/or matrices with n rows as elements to
specify the violation space candidates.
If observations are not numeric dummy encoding will be applied.
See Details for more information.</p>
</td></tr>
<tr><td><code id="tsci_secondstage_+3A_create_nested_sequence">create_nested_sequence</code></td>
<td>
<p>logical. If <code>TRUE</code>, the violation space candidates (in form of matrices)
are defined sequentially starting with an empty violation matrix and subsequently
adding the next element of <code>vio_space</code> to the current violation matrix.
If <code>FALSE,</code> the violation space candidates (in form of matrices) are defined as the empty space and the elements of <code>vio_space</code>.
See Details for more information.</p>
</td></tr>
<tr><td><code id="tsci_secondstage_+3A_weight">weight</code></td>
<td>
<p>the hat matrix of the treatment model.</p>
</td></tr>
<tr><td><code id="tsci_secondstage_+3A_a1_ind">A1_ind</code></td>
<td>
<p>indices of the observations that wil be used to fit the outcome model.
Must be of same length as the number of rows and columns of <code>weight</code>.
If <code>NULL</code>, all observations will be used.</p>
</td></tr>
<tr><td><code id="tsci_secondstage_+3A_sel_method">sel_method</code></td>
<td>
<p>The selection method used to estimate the treatment effect. Either &quot;comparison&quot; or &quot;conservative&quot;. See Details.</p>
</td></tr>
<tr><td><code id="tsci_secondstage_+3A_sd_boot">sd_boot</code></td>
<td>
<p>logical. if <code>TRUE</code>, it determines the standard error using a bootstrap approach.</p>
</td></tr>
<tr><td><code id="tsci_secondstage_+3A_iv_threshold">iv_threshold</code></td>
<td>
<p>a numeric value specifying the minimum of the threshold of IV strength test.</p>
</td></tr>
<tr><td><code id="tsci_secondstage_+3A_threshold_boot">threshold_boot</code></td>
<td>
<p>logical. if <code>TRUE</code>, it determines the threshold of the IV strength using a bootstrap approach.
If <code>FALSE</code>, it does not perform a bootstrap. See Details.</p>
</td></tr>
<tr><td><code id="tsci_secondstage_+3A_alpha">alpha</code></td>
<td>
<p>the significance level. Has to be a numeric value between 0 and 1.</p>
</td></tr>
<tr><td><code id="tsci_secondstage_+3A_intercept">intercept</code></td>
<td>
<p>logical. If <code>TRUE</code>, an intercept is included in the outcome model.</p>
</td></tr>
<tr><td><code id="tsci_secondstage_+3A_b">B</code></td>
<td>
<p>number of bootstrap samples. Has to be a positive integer value.
Bootstrap methods are used to calculate the iv strength threshold if <code>threshold_boot</code> is <code>TRUE</code> and for the violation space selection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The treatment and outcome models are assumed to be of the following forms:
</p>
<p style="text-align: center;"><code class="reqn">D_i = f(Z_i, X_i) + \delta_i</code>
</p>

<p style="text-align: center;"><code class="reqn">Y_i = \beta \cdot D_i + h(Z_i, X_i) + \phi(X_i) + \epsilon_i</code>
</p>

<p>where <code class="reqn">f(Z_i, X_i)</code> is estimated using a random forest,
<code class="reqn">h(Z_i X_i)</code> is approximated using the hat matrix <code>weight</code> provided by the user and
<code class="reqn">\phi(X_i)</code> is approximated by a linear combination of the columns in <code>W</code>.
The errors are allowed to be heteroscedastic. <code class="reqn">A1</code> is used to perform violation space selection
and to estimate the treatment effect. <br /> <br />
The violation space candidates should be in a nested sequence as the violation space selection is performed
by comparing the treatment estimate obtained by each violation space candidate with the estimates of all
violation space candidates further down the list <code>vio_space</code> that provide enough IV strength. Only if no
significant difference was found in all of those comparisons, the violation space
candidate will be selected. If <code>sel_method</code> is 'comparison', the treatment effect estimate of this
violation space candidate will be returned. If <code>sel_method</code> is 'conservative', the treatment effect estimate
of the successive violation space candidate will be returned provided that the IV strength is large enough.
The specification of suitable violation space candidates is a crucial step because a poor approximation
of <code class="reqn">g(Z_i, X_i)</code> might not address the bias caused by the violation of the IV assumption sufficiently well.
The function <code><a href="#topic+create_monomials">create_monomials</a></code> can be used to create a predefined sequence of
violation space candidates consisting of monomials.
The function <code><a href="#topic+create_interactions">create_interactions</a></code> can be used to create a predefined sequence of
violation space candidates consisting of two-way interactions between the instrumens themselves and between
the instruments and the instruments and baseline covariates.  <br /> <br />
The instrumental variable(s) are considered strong enough for violation space candidate <code class="reqn">V_q</code> if the estimated IV strength using this
violation space candidate is larger than the obtained value of the threshold of the IV strength.
The formula of the threshold of the IV strength has the form
<code class="reqn">\min \{\max \{ 2 \cdot \mathrm{Trace} [ \mathrm{M} (V_q) ], \mathrm{iv{\_}threshold} \} + S (V_q), 40 \}</code> if <code>threshold_boot</code> is <code>TRUE</code>, and
<code class="reqn">\min \{\max \{ 2 \cdot \mathrm{Trace} [ \mathrm{M} (V_q) ], \mathrm{iv{\_}threshold} \}, 40 \}</code> if <code>threshold_boot</code> is <code>FALSE</code>. The matrix
<code class="reqn">\mathrm{M} (V_q)</code> depends on the hat matrix obtained from estimating <code class="reqn">f(Z_i, X_i)</code>, the violation space candidate <code class="reqn">V_q</code> and
the variables to include in the outcome model <code>W</code>. <code class="reqn">S (V_q)</code> is obtained using a bootstrap and aims to adjust for the estimation error
of the IV strength.
Usually, the value of the threshold of the IV strength obtained using the bootstrap approach is larger.
Thus, using <code>threshold_boot</code> equals <code>TRUE</code> leads to a more conservative IV strength test.
For more information see subsection 3.3 in Guo and Buehlmann (2022).<br /> <br />
See also Carl et al. (2023) for more details.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt><code>Coef_all</code></dt><dd><p>a series of point estimates of the treatment effect
obtained by the different violation space candidates.</p>
</dd>
<dt><code>sd_all</code></dt><dd><p>standard errors of the estimates of the treatmnet effect
obtained by the different violation space candidates.</p>
</dd>
<dt><code>pval_all</code></dt><dd><p>p-values of the treatment effect estimates obtained by the
different violation space candidates.</p>
</dd>
<dt><code>CI_all</code></dt><dd><p>confidence intervals for the treatment effect obtained by the
different violation space candidates.</p>
</dd>
<dt><code>Coef_sel</code></dt><dd><p>the point estimator of the treatment effect obtained by
the selected violation space candidate(s).</p>
</dd>
<dt><code>sd_sel</code></dt><dd><p>the standard error of Coef_sel.</p>
</dd>
<dt><code>pval_sel</code></dt><dd><p>p-value of the treatment effect estimate obtained by the
selected violation space candidate(s).</p>
</dd>
<dt><code>CI_sel</code></dt><dd><p>confidence interval for the treatment effect obtained by
the selected violation space candidate(s).</p>
</dd>
<dt><code>iv_str</code></dt><dd><p>IV strength using the different violation space candidates.</p>
</dd>
<dt><code>iv_thol</code></dt><dd><p>the threshold for the IV strength using the different violation space candidates.</p>
</dd>
<dt><code>Qmax</code></dt><dd><p>the violation space candidate that was the largest violation space candidate
for which the IV strength was considered large enough determined by the IV strength test.
If 0, the IV Strength test failed for the first violation space candidate.
Otherwise, violation space selection was performed.</p>
</dd>
<dt><code>q_comp</code></dt><dd><p>the violation space candidate that was selected by the comparison method over the multiple data splits.</p>
</dd>
<dt><code>q_cons</code></dt><dd><p>the violation space candidate that was selected by the conservative method over the multiple data splits.</p>
</dd>
<dt><code>invalidity</code></dt><dd><p>shows whether the instrumental variable(s) were considered valid, invalid or too weak to test for violations.
The instrumental variables are considered too weak to test for violations if the IV strength is already too weak using the first
violation space candidate (besides the empty violation space). Testing for violations is always performed by using the comparison method.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p>Zijian Guo, and Peter Buehlmann. Two Stage Curvature Identification with
Machine Learning: Causal Inference with Possibly Invalid Instrumental Variables.
<em>arXiv:2203.12808</em>, 2022
</p>
</li>
<li><p>Nicolai Meinshausen, Lukas Meier, and Peter Buehlmann. P-values for high-dimensional
regression. <em>Journal of the American Statistical Association</em>,
104(488):1671-1681, 2009. 16, 18
</p>
</li>
<li><p>Victor Chernozhukov, Denis Chetverikov, Mert Demirer, Esther Duflo, Christian Hansen,
Whitney Newey, and James Robins. Double/debiased machine learning for treatment
and structural parameters: Double/debiased machine learning.
<em>The Econometrics Journal</em>, 21(1), 2018. 4, 16, 18
</p>
</li>
<li><p>David Carl, Corinne Emmenegger, Peter Buehlmann, and Zijian Guo. TSCI:
two stage curvature identification for causal inference with invalid instruments.
<em>arXiv:2304.00513</em>, 2023
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+tsci_boosting">tsci_boosting</a></code> for TSCI with boosting. <br /> <br />
<code><a href="#topic+tsci_forest">tsci_forest</a></code> for TSCI with random forest. <br /> <br />
<code><a href="#topic+tsci_poly">tsci_poly</a></code> for TSCI with polynomial basis expansion. <br /> <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### a small example without baseline covariates
if (require("MASS")) {
  # sample size
  n &lt;- 100
  # the IV strength
  a &lt;- 1
  # the violation strength
  tau &lt;- 1
  # true effect
  beta &lt;- 1
  # treatment model
  f &lt;- function(x) {1 + a * (x + x^2)}
  # outcome model
  g &lt;- function(x) {1 + tau * x}

  # generate data
  mu_error &lt;- rep(0, 2)
  Cov_error &lt;- matrix(c(1, 0.5, 0.5, 1), 2, 2)
  Error &lt;- MASS::mvrnorm(n, mu_error, Cov_error)
  # instrumental variable
  Z &lt;- rnorm(n)
  # treatment variable
  D &lt;- f(Z) + Error[, 1]
  # outcome variable
  Y &lt;- beta * D + g(Z) + Error[, 2]

  # Two Stage User Defined
  # get hat matrix of treatment model
  A &lt;- cbind(1, Z, Z^2, Z^3)
  weight &lt;- A %*% chol2inv(chol(t(A) %*% A)) %*% t(A)
  # create violation space candidates
  vio_space &lt;- create_monomials(Z, 2, "monomials_main")
  # perform two stage curvature identification
  output_UD &lt;- tsci_secondstage(Y, D, Z, vio_space = vio_space, weight = weight,
                                B = 100)
  summary(output_UD)
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
