<!DOCTYPE html><html><head><title>Help for package timetools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {timetools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%included%'><p>test inclusion of 2 &lsquo;POSIXcti&rsquo; objects</p></a></li>
<li><a href='#%intersect%'><p>intersects 2 &lsquo;POSIXcti&rsquo; objects</p></a></li>
<li><a href='#as.data.frame'><p>Convert an object to a data.frame</p></a></li>
<li><a href='#changeSupport'><p>Function to change time support of TimeIntervalDataFrame</p></a></li>
<li><a href='#compute.lim'><p>Calculate limits for plotting</p></a></li>
<li><a href='#continuous'><p>Test if a time object is continuous/set an time object continuous.</p></a></li>
<li><a href='#duration'><p>Extract duration of a Time object</p></a></li>
<li><a href='#homogeneous'><p>Test if a time object is homogeneous</p></a></li>
<li><a href='#interval'><p>Extract time intervals of a time object.</p></a></li>
<li><a href='#ops.numeric'><p>define generic function to compare anything to a numeric</p></a></li>
<li><a href='#origin'><p>1970-01-01 GMT</p></a></li>
<li><a href='#overlapping'><p>Test if any interval of a time intervals object intersect another</p></a></li>
<li><a href='#period'><p>Test or extract different properties of Time objects</p></a></li>
<li><a href='#POSIXcti'><p>Class <code>"POSIXcti"</code></p></a></li>
<li><a href='#POSIXctp'><p>Class <code>"POSIXctp"</code></p></a></li>
<li><a href='#POSIXst'><p>Class <code>"POSIXst"</code></p></a></li>
<li><a href='#regular'><p>Test if a time object is regular</p></a></li>
<li><a href='#split'><p>Divide into Groups and Reassemble (Time*DataFrame objects and POSIXct*)</p></a></li>
<li><a href='#SubtimeDataFrame'><p>Class <code>"SubtimeDataFrame"</code></p></a></li>
<li><a href='#tapply'><p>Apply a Function Over a time properties</p></a></li>
<li><a href='#TimeInstantDataFrame'><p>Class <code>"TimeInstantDataFrame"</code></p></a></li>
<li><a href='#TimeIntervalDataFrame'><p>Class <code>"TimeIntervalDataFrame"</code></p></a></li>
<li><a href='#timetools-package'>
<p>Seasonal/Sequential (Instants/Durations, Even or not) Time Series</p></a></li>
<li><a href='#timezone'><p>Get or set timezone property</p></a></li>
<li><a href='#unit'><p>define valid units for time objects/retrieve-set time unit of a time object</p></a></li>
<li><a href='#when'><p>Retrieve the 'timestamp' of a Time*DataFrame</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Seasonal/Sequential (Instants/Durations, Even or not) Time
Series</td>
</tr>
<tr>
<td>Version:</td>
<td>1.15.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-28</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Author:</td>
<td>Vladislav Navel</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vladislav Navel &lt;vnavel@yahoo.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Objects to manipulate sequential and seasonal time series. Sequential time series based on time instants and time durations are handled. Both can be regularly or unevenly spaced (overlapping durations are allowed). Only POSIX* format are used for dates and times. The following classes are provided : 'POSIXcti', 'POSIXctp', 'TimeIntervalDataFrame', 'TimeInstantDataFrame', 'SubtimeDataFrame' ; methods to switch from a class to another and to modify the time support of series (hourly time series to daily time series for instance) are also defined. Tools provided can be used for instance to handle environmental monitoring data (not always produced on a regular time base).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://sourceforge.net/projects/timetools/">https://sourceforge.net/projects/timetools/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-28 14:45:23 UTC; vnavel</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-29 10:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25included+25'>test inclusion of 2 &lsquo;POSIXcti&rsquo; objects</h2><span id='topic++25included+25'></span>

<h3>Description</h3>

<p>This function test if the first &lsquo;POSIXcti&rsquo; object
is included in the second.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  

  i1 %included% i2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25included+2B25_+3A_i1">i1</code></td>
<td>
<p>is this object included in the second object ?</p>
</td></tr>
<tr><td><code id="+2B25included+2B25_+3A_i2">i2</code></td>
<td>
<p>is this object include the first one ?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to see all existing methods :
methods ('\%included\%')
</code></pre>

<hr>
<h2 id='+25intersect+25'>intersects 2 &lsquo;POSIXcti&rsquo; objects</h2><span id='topic++25intersect+25'></span>

<h3>Description</h3>

<p>This function allows to find the intersection of two
objects of the same class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  

  i1 %intersect% i2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25intersect+2B25_+3A_i1">i1</code></td>
<td>
<p>first object to intersect</p>
</td></tr>
<tr><td><code id="+2B25intersect+2B25_+3A_i2">i2</code></td>
<td>
<p>second object to intersect</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of the same class of parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to see all existing methods :
methods ('\%intersect\%')
</code></pre>

<hr>
<h2 id='as.data.frame'>Convert an object to a data.frame</h2><span id='topic+as.data.frame'></span><span id='topic+as.data.frame.TimeInstantDataFrame'></span><span id='topic+as.data.frame.TimeIntervalDataFrame'></span><span id='topic+as.data.frame.SubtimeDataFrame'></span>

<h3>Description</h3>

<p>Convert an object to a <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'TimeInstantDataFrame'
as.data.frame(x, row.names=NULL, optional=FALSE,
  	include.dates=FALSE, ...)
  ## S3 method for class 'TimeIntervalDataFrame'
as.data.frame(x, row.names=NULL, optional=FALSE,
  	include.dates=FALSE, ...)
  ## S3 method for class 'SubtimeDataFrame'
as.data.frame(x, row.names=NULL, optional=FALSE,
  	include.dates=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame_+3A_x">x</code></td>
<td>
<p>TimeIntervalDataFrame, TimeInstantDataFrame or SubtimeDataFrame</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_row.names">row.names</code></td>
<td>

<p>‘NULL’ or a character vector giving the row names for the
data frame.  Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_optional">optional</code></td>
<td>

<p>logical. If ‘TRUE’, setting row names and converting column
names (to syntactic names: see ‘make.names’) is optional.</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_include.dates">include.dates</code></td>
<td>
<p>should time properties be included in the data.frame 
as a column ? (or 2 columns for TimeIntervalDataFrame)</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code>
</p>

<hr>
<h2 id='changeSupport'>Function to change time support of TimeIntervalDataFrame</h2><span id='topic+changeSupport'></span><span id='topic+changeSupport+2CTimeIntervalDataFrame+2Ccharacter+2Cnumeric-method'></span><span id='topic+changeSupport+2CTimeIntervalDataFrame+2CPOSIXctp+2Cnumeric-method'></span><span id='topic+changeSupport+2CTimeIntervalDataFrame+2CTimeIntervalDataFrame+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Methods that allows to agregate AND disagregate
homogeneous AND heterogeneous time data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  changeSupport(from, to, min.coverage, FUN = NULL,
    weights.arg = NULL, split.from = FALSE,
    merge.from = TRUE, ...)

  ## S4 method for signature 'TimeIntervalDataFrame,POSIXctp,numeric'
changeSupport(from, to, min.coverage, FUN=NULL,
				 weights.arg=NULL, split.from=FALSE,
				 merge.from=TRUE, ...)
  ## S4 method for signature 
## 'TimeIntervalDataFrame,TimeIntervalDataFrame,numeric'
changeSupport(from, to, min.coverage,
				FUN=NULL, weights.arg=NULL,
				split.from=FALSE, merge.from=TRUE, ...)
  ## S4 method for signature 'TimeIntervalDataFrame,character,numeric'
changeSupport(from, to, min.coverage, FUN=NULL,
				 weights.arg=NULL, split.from=FALSE,
				 merge.from=TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="changeSupport_+3A_from">from</code></td>
<td>
<p><code><a href="#topic+TimeIntervalDataFrame">TimeIntervalDataFrame</a></code> for wich
the time support is to change</p>
</td></tr>
<tr><td><code id="changeSupport_+3A_to">to</code></td>
<td>
<p>an object indicating the new support, see
specific sections</p>
</td></tr>
<tr><td><code id="changeSupport_+3A_min.coverage">min.coverage</code></td>
<td>
<p>a numeric between 0 and 1 indicating
the percentage of valid values over each interval to
allow an aggregation. NA is returned if the percentage is
not reach. In changeSupport, when values are aggregated,
intervals are not allowed to overlap. When a function
(FUN) has a na.rm argument, the na.rm=TRUE behaviour is
met if na.rm is set to TRUE and min.coverage to 0 (zero)
; the na.rm=FALSE behaviour is met if na.rm is set to
FALSE whatever is the value of min.coverage.
If min.coverage si as.numeric(NA), the function FUN is 
apply on all data within the interval, without checking
if there is any overlapping. In this case, the result
of the transformation must be analysed carefully.</p>
</td></tr>
<tr><td><code id="changeSupport_+3A_fun">FUN</code></td>
<td>
<p>function use to agregate data of from. By
default <code><a href="base.html#topic+mean">mean</a></code> if &lsquo;from&rsquo; is
<code><a href="#topic+homogeneous">homogeneous</a></code>.
<code><a href="stats.html#topic+weighted.mean">weighted.mean</a></code> otherwise.</p>
</td></tr>
<tr><td><code id="changeSupport_+3A_weights.arg">weights.arg</code></td>
<td>
<p>if FUN has a &lsquo;weight&rsquo; argument,
this parameter must be a character naming the weight
argument. For instance, if FUN is
<code><a href="stats.html#topic+weighted.mean">weighted.mean</a></code>, then weights.arg is
<code>'w'</code>.</p>
</td></tr>
<tr><td><code id="changeSupport_+3A_...">...</code></td>
<td>
<p>arguments for FUN or for other methods</p>
</td></tr>
<tr><td><code id="changeSupport_+3A_split.from">split.from</code></td>
<td>
<p>logical indicating if data in
&lsquo;from&rsquo; can be used for several intervals of the
new time support (see &lsquo;details&rsquo;).</p>
</td></tr>
<tr><td><code id="changeSupport_+3A_merge.from">merge.from</code></td>
<td>
<p>logical indicating if data in
&lsquo;from&rsquo; can be merged over interval of the new time
support.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Agregating homogeneous data is for example to calculate
daily means of time series from hourly time series.
</p>
<p>Agregating heterogeneous data is for example to calculate
annual means of time series from monthly time series
(because each month doesn(t have identical weight).
</p>
<p>In above cases, the <code>min.coverage</code> allows to control
if means should be calculated or not : for the monthly
case, if there are <code>NA</code> values and the time coverage
of &lsquo;not NA&rsquo; values is lower <code>min.coverage</code>
the result will be <code>NA</code> ; if time coverage is higher
than <code>min.coverage</code>, the annual mean will be
&lsquo;estimated&rsquo; by the mean of available data.
</p>
<p>Disagregating data is more &lsquo;articficial&rsquo; and is
disabled by default (with the <code>split.from</code>
argument). This argument is also used to precise if one
value can be use for agregation in more than one interval
in the resulting TimeIntervalDataFrame (for sliding
intervals for instance). Here are some examples of time
disagregration : </p>
 <ul>
<li><p> A weekly mean can be
dispatched over the days of the week.  By default, the
value attribuated to each day is the value of the week,
but this can be changed by using a special function
(<code>FUN</code> argument). </p>
</li>
<li><p> The value of a variable is
known from monday at 15 hours to tuesday at 15 hours and
from tuesday at 15 hours to wednesday at 15 hours. To
&lsquo;evaluate&rsquo; the value of the variable for tuesday
can be estimated by doing a weigthed mean between the two
values. Weights are determined by the intersection
between each interval and tuesday. Here weights will be
<code>0.625</code> (15/24) and <code>0.375</code> (9/24) (In this
case, disagration is combined with a
&lsquo;reagregation&rsquo;). </p>
</li></ul>

<p>These are &lsquo;trivial&rsquo; examples but many other usage
can be found for these methods. Other functions than
<code>weighted.mean</code> or <code>mean</code> can be used. The Qair
package (in its legislative part) gives several examples
of usage (this package is not availables on CRAN but see
&lsquo;references&rsquo; to know where you can find it).
</p>


<h3>Value</h3>

<p><code><a href="#topic+TimeIntervalDataFrame">TimeIntervalDataFrame</a></code>
</p>


<h3>from=TimeIntervalDataFrame, to=TimeIntervalDataFrame</h3>

<p><code>to</code> is a TimeIntervalDataFrame. The method will try
to adapt data of <code>from</code> over interval of <code>to</code>.
The returned object is the <code>to</code>
TimeIntervalDataFrame with new columns corresponding of
those of <code>from</code>.
</p>
<p>If merge.from is TRUE, values affected for each interval
of <code>to</code> will be calculated with all data in the
interval. If split.from is TRUE, values partially in the
interval will also be used for calculation.
</p>
<p>If merge.from is FALSE, values affected for each interval
of <code>to</code> will be the one inside this interval. If
several values are inside the interval, <code>NA</code> will be
affected. If split.from is TRUE, a value partially inside
the interval is considered as being inside it. So if
there is no other values in the interval, this value will
be affected, else <code>NA</code> will be affected.
</p>


<h3>from=TimeIntervalDataFrame, to=character</h3>

<p><code>to</code> is one of 'year', 'month', 'day', 'hour',
'minute' or 'second'. It defines the period
(<code><a href="#topic+POSIXctp">POSIXctp</a></code>) to use to build the new
TimeIntervalDataFrame on which <code>from</code> will be
agregated (or disagregated).
</p>
<p>So first, an &lsquo;empty&rsquo; (no data)
TimeIntervalDataFrame is created, and then, the
agregation is done accordingly to the
&lsquo;from=TimeIntervalDataFrame,
to=TimeIntervalDataFrame&rsquo; section.
</p>


<h3>from=TimeIntervalDataFrame, to=POSIXctp</h3>

<p><code>to</code> is period (see <code><a href="#topic+POSIXctp">POSIXctp</a></code>). It
defines the base of the new TimeIntervalDataFrame on
which <code>from</code> will be agregated (or disagregated).
</p>
<p>So first, an &lsquo;empty&rsquo; (no data)
TimeIntervalDataFrame is created, and then, the
agregation is done accordingly to the
&lsquo;from=TimeIntervalDataFrame,
to=TimeIntervalDataFrame&rsquo; section.
</p>


<h3>References</h3>

<p>Qair-package :
<a href="https://sourceforge.net/projects/packagerqair/">https://sourceforge.net/projects/packagerqair/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TimeIntervalDataFrame">TimeIntervalDataFrame</a></code>,
<code><a href="#topic+POSIXcti">POSIXcti</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ti3 &lt;- TimeIntervalDataFrame (
       c('2010-01-01', '2010-01-02', '2010-01-04'), NULL,
       'UTC', data.frame(ex3=c(6, 1.5)))

# weighted mean over a period of 3 days with at least 75% of
# coverage (NA is retunr if not)
ti3
d &lt;- POSIXctp(unit='day')
changeSupport (ti3, 3L*d, 0.75)

ti4 &lt;- TimeIntervalDataFrame (
	c('2010-01-01', '2010-01-02', '2010-01-04',
	  '2010-01-07', '2010-01-09', '2010-01-10'), NULL,
         'UTC', data.frame(ex4=c(6, 1.5, 5, 3, NA)))

# weighted mean over a period of 3 days with at least 75% of
# coverage (NA is retunr if not) or 50%
ti4
changeSupport (ti4, 3L*d, 0.75)
changeSupport (ti4, 3L*d, 0.5)

# use of split.from
ti1 &lt;- RegularTimeIntervalDataFrame('2011-01-01', '2011-02-01', 'hour')
ti1$value &lt;- 1:nrow(ti1)
# we can calculate sliding mean over periods of 24 hours.
# first lets build the corresponding TimeIntervalDataFrame
ti2 &lt;- RegularTimeIntervalDataFrame('2011-01-01', '2011-02-01', 'hour', 'day')
# if we try to 'project' ti1 over ti2 it won't work :
summary (changeSupport (ti1[1:200,], ti2[1:200,], 0))
# all data are NA because 'spliting' is not enabled. Let's enable it :
summary (changeSupport (ti1[1:200,], ti2[1:200,], 0, split.from=TRUE))
</code></pre>

<hr>
<h2 id='compute.lim'>Calculate limits for plotting</h2><span id='topic+compute.lim'></span>

<h3>Description</h3>

<p>This function retunrn a 2 elements vectors (numeric)
which can be use as graph limits (xlim, ylim, rlim, etc.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  compute.lim(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.lim_+3A_x">x</code></td>
<td>
<p>'numeric' for which limits must be calculated</p>
</td></tr>
<tr><td><code id="compute.lim_+3A_na.rm">na.rm</code></td>
<td>
<p>boolean should NA values be removed before
calculation ?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric of length 2
</p>

<hr>
<h2 id='continuous'>Test if a time object is continuous/set an time object continuous.</h2><span id='topic+continuous'></span><span id='topic+continuous+3C-'></span><span id='topic+continuous+3C--methods'></span><span id='topic+continuous-methods'></span>

<h3>Description</h3>

<p>For Time objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  continuous(x, ...)
  continuous(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="continuous_+3A_x">x</code></td>
<td>
<p>object to test</p>
</td></tr>
<tr><td><code id="continuous_+3A_value">value</code></td>
<td>
<p>logical indicating whether x must be 'continuify' or not.</p>
</td></tr>
<tr><td><code id="continuous_+3A_...">...</code></td>
<td>
<p>arguments to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For objects based on time intervals. After ordering
intervals, test if the end of an interval is the start of
the next interval. If any interval overlap another one,
it returns <code>FALSE</code>.
</p>
<p>If not any interval overlap another, and the object is
not continuous, the object can be set 'continuous' with
</p>
<p><code>continuous(obj) &lt;- TRUE</code>
</p>
<p>Intervals will be added such as the object can pass the
test describe below. The data is filled with NA values.
</p>


<h3>Value</h3>

<p>Logical indicating if the object is continuous or not.
</p>
<p>or
</p>
<p>The object set continous.
</p>


<h3>See Also</h3>

<p><a href="#topic+TimeIntervalDataFrame">TimeIntervalDataFrame</a>, <a href="#topic+POSIXcti">POSIXcti</a>
</p>

<hr>
<h2 id='duration'>Extract duration of a Time object</h2><span id='topic+duration'></span><span id='topic+duration-methods'></span>

<h3>Description</h3>

<p>For Time objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  duration(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duration_+3A_x">x</code></td>
<td>
<p>object from which get the duration</p>
</td></tr>
<tr><td><code id="duration_+3A_...">...</code></td>
<td>
<p>arguments to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <a href="#topic+POSIXcti">time intervals</a> it returns a vector of
integers indicating, for each time interval, the duration of 
the interval in seconds.
</p>
<p>For <a href="#topic+POSIXctp">time periods</a> it returns a vector of 
integers indicating the duration of each time period using
its own time unit. For instance :
</p>
<p><code>duration(POSIXctp(1:2, c('month', 'year')))</code>
<code>&gt; 1 2</code>
</p>


<h3>See Also</h3>

<p><a href="#topic+POSIXcti">POSIXcti</a>, <a href="#topic+POSIXctp">POSIXctp</a>
</p>

<hr>
<h2 id='homogeneous'>Test if a time object is homogeneous</h2><span id='topic+homogeneous'></span><span id='topic+homogeneous-methods'></span>

<h3>Description</h3>

<p>For objects based on time intervals
(<code><a href="#topic+POSIXcti">POSIXcti</a></code>). Test if intervals of the object
are &lsquo;homogeneous&rsquo; : if the period of each interval
is the same.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  homogeneous(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="homogeneous_+3A_x">x</code></td>
<td>
<p>object to test for homogeneity</p>
</td></tr>
<tr><td><code id="homogeneous_+3A_...">...</code></td>
<td>
<p>arguments to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical indicating if 'x' is homogeneous or not.
</p>


<h3>See Also</h3>

<p><a href="#topic+TimeIntervalDataFrame">TimeIntervalDataFrame</a>, <a href="#topic+POSIXcti">POSIXcti</a>
</p>

<hr>
<h2 id='interval'>Extract time intervals of a time object.</h2><span id='topic+interval'></span><span id='topic+interval-methods'></span>

<h3>Description</h3>

<p>For objects based on time intervals. Return
<code><a href="#topic+POSIXcti">POSIXcti</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  interval(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interval_+3A_x">x</code></td>
<td>
<p>object from which get time intervals</p>
</td></tr>
<tr><td><code id="interval_+3A_...">...</code></td>
<td>
<p>arguments to or from other methods</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+TimeIntervalDataFrame">TimeIntervalDataFrame</a>, <a href="#topic+POSIXcti">POSIXcti</a>
</p>

<hr>
<h2 id='ops.numeric'>define generic function to compare anything to a numeric</h2><span id='topic+Ops+2CANY+2Cnumeric-method'></span><span id='topic+ops.numeric'></span><span id='topic+Ops+2Cnumeric+2CANY-method'></span>

<h3>Description</h3>

<p>define generic function to compare anything to a numeric
</p>

<hr>
<h2 id='origin'>1970-01-01 GMT</h2><span id='topic+origin'></span>

<h3>Description</h3>

<p>Origin is the date-time for 1970-01-01 GMT in POSIXct
format. This date-time is the origin for the numbering
system used by POSIXct, POSIXlt, chron, and Date classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  origin
</code></pre>


<h3>Format</h3>

<p>POSIXt[1:1], format: &quot;1970-01-01 01:00:00&quot;</p>


<h3>Details</h3>

<p>The original implementation of this 'object' is in the
lubridate package.
</p>


<h3>Author(s)</h3>

<p>Garrett Grolemund &quot;grolemund at rice.edu&quot;, Hadley Wickham
&quot;h.wickham at gmail.com&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>origin
# "1970-01-01 GMT"
</code></pre>

<hr>
<h2 id='overlapping'>Test if any interval of a time intervals object intersect another</h2><span id='topic+overlapping'></span><span id='topic+overlapping-methods'></span><span id='topic+overlapping+2CTimeIntervalDataFrame+2CANY-method'></span><span id='topic+overlapping+2CTimeIntervalDataFrame+2Clogical-method'></span>

<h3>Description</h3>

<p>For objects based on time intervals. Test if any interval
overlap another one. Because the test can be ressource
consuming, it stops at the first case encoutered that
does not satisfy this condition. The two indices
corresponding are printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  overlapping(x, idx, ...)

  ## S4 method for signature 'TimeIntervalDataFrame,ANY'
overlapping(x, idx, ...)
  ## S4 method for signature 'TimeIntervalDataFrame,logical'
overlapping(x, idx, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlapping_+3A_x">x</code></td>
<td>
<p>object to test for overlapping</p>
</td></tr>
<tr><td><code id="overlapping_+3A_idx">idx</code></td>
<td>
<p>Logical set to TRUE if indexes of all overlapping
intervals are to retrieve.</p>
</td></tr>
<tr><td><code id="overlapping_+3A_...">...</code></td>
<td>
<p>arguments to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical indicating if 'x' has any overlapping time interval.
</p>


<h3>See Also</h3>

<p><a href="#topic+TimeIntervalDataFrame">TimeIntervalDataFrame</a>, <a href="#topic+POSIXcti">POSIXcti</a>
</p>

<hr>
<h2 id='period'>Test or extract different properties of Time objects</h2><span id='topic+period'></span><span id='topic+period-methods'></span>

<h3>Description</h3>

<p>For objects based on time intervals. Return
<code><a href="#topic+POSIXctp">POSIXctp</a></code> of the object if it is homogeneous
and continuous.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  period(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="period_+3A_x">x</code></td>
<td>
<p>object from which get the period</p>
</td></tr>
<tr><td><code id="period_+3A_...">...</code></td>
<td>
<p>arguments to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a time period object if possible. An error occur if not.
</p>


<h3>See Also</h3>

<p><a href="#topic+TimeIntervalDataFrame">TimeIntervalDataFrame</a>,
<a href="#topic+POSIXctp">POSIXctp</a>
</p>

<hr>
<h2 id='POSIXcti'>Class <code>"POSIXcti"</code></h2><span id='topic+POSIXcti-class'></span><span id='topic+POSIXcti'></span><span id='topic+length+2CPOSIXcti-method'></span><span id='topic+show+2CPOSIXcti-method'></span><span id='topic++5B.POSIXcti'></span><span id='topic++5B+3C-.POSIXcti'></span><span id='topic+print.POSIXcti'></span><span id='topic+summary.POSIXcti'></span><span id='topic+head.POSIXcti'></span><span id='topic+tail.POSIXcti'></span><span id='topic+c.POSIXcti'></span><span id='topic+unique.POSIXcti'></span><span id='topic+match+2CPOSIXcti+2CPOSIXcti-method'></span><span id='topic++25in+25+2CPOSIXcti+2CPOSIXcti-method'></span><span id='topic+split.POSIXcti'></span><span id='topic+rep.POSIXcti'></span><span id='topic+as.POSIXcti'></span><span id='topic+as.POSIXcti.logical'></span><span id='topic+duration+2CPOSIXcti-method'></span><span id='topic+format.POSIXcti'></span><span id='topic+start.POSIXcti'></span><span id='topic+end.POSIXcti'></span><span id='topic++25included+25.POSIXcti'></span><span id='topic++25intersect+25.POSIXcti'></span><span id='topic+Ops.POSIXcti'></span><span id='topic++3C.POSIXcti'></span><span id='topic++3C+3D.POSIXcti'></span><span id='topic++3D+3D.POSIXcti'></span><span id='topic++21+3D.POSIXcti'></span><span id='topic++3E+3D.POSIXcti'></span><span id='topic++3E.POSIXcti'></span><span id='topic++2B+2CPOSIXcti+2CPOSIXctp-method'></span><span id='topic++2B+2CPOSIXctp+2CPOSIXcti-method'></span><span id='topic+-+2CPOSIXcti+2CPOSIXctp-method'></span>

<h3>Description</h3>

<p>S4 class that defines 'time interval' objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>POSIXcti(start, end, timezone='UTC', ...)
as.POSIXcti(from, ...)

  ## S3 method for class 'POSIXcti'
x[i, ...]
  ## S3 replacement method for class 'POSIXcti'
x[i] &lt;- value
  ## S3 method for class 'POSIXcti'
c(...)
  ## S3 method for class 'POSIXcti'
split(x, f, drop=FALSE, ...)
  ## S3 method for class 'POSIXcti'
rep(x, ...)
  ## S3 method for class 'POSIXcti'
unique(x, incomparables=FALSE, ...)
  ## S3 method for class 'POSIXcti'
i1 %intersect% i2

  ## S3 method for class 'POSIXcti'
start(x, ...)
  ## S3 method for class 'POSIXcti'
end(x, ...)
  ## S4 method for signature 'POSIXcti'
duration(x, ...)

  ## S4 method for signature 'POSIXcti'
length(x)

  ## S3 method for class 'POSIXcti'
print(x, ...)
  ## S3 method for class 'POSIXcti'
format(x, format = "%Y-%m-%d %H:%M:%S", ...)
  ## S3 method for class 'POSIXcti'
summary(object, ...)
  ## S3 method for class 'POSIXcti'
head(x, ...)
  ## S3 method for class 'POSIXcti'
tail(x, ...)
  ## S4 method for signature 'POSIXcti'
show(object)

  ## S4 method for signature 'POSIXcti,POSIXcti'
match(x, table, nomatch = NA_integer_, incomparables=NULL)
  ## S4 method for signature 'POSIXcti,POSIXcti'
x %in% table

  ## S3 method for class 'POSIXcti'
Ops(e1, e2)

  ## S3 method for class 'POSIXcti'
i1 %included% i2

  ## S4 method for signature 'POSIXcti,POSIXctp'
e1 + e2
  ## S4 method for signature 'POSIXctp,POSIXcti'
e1 + e2
  ## S4 method for signature 'POSIXcti,POSIXctp'
e1 - e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="POSIXcti_+3A_start">start</code></td>
<td>
<p><code><a href="base.html#topic+POSIXct">POSIXct</a></code> object indicating the beginning of the time
interval.</p>
</td></tr>
<tr><td><code id="POSIXcti_+3A_end">end</code></td>
<td>
<p><code><a href="base.html#topic+POSIXct">POSIXct</a></code> object indicating the end of the time interval.</p>
</td></tr>
<tr><td><code id="POSIXcti_+3A_timezone">timezone</code></td>
<td>
<p><code>character</code> indicating the timezone in which the time
interval is set. See <code><a href="base.html#topic+timezone">timezone</a></code>.</p>
</td></tr>
<tr><td><code id="POSIXcti_+3A_from">from</code></td>
<td>
<p>Object to convert to a time interval (actually works only for
<code>NA</code>).</p>
</td></tr>
<tr><td><code id="POSIXcti_+3A_x">x</code></td>
<td>
<p><code>POSIXcti</code> object on which the method has to be applied.</p>
</td></tr>
<tr><td><code id="POSIXcti_+3A_i">i</code></td>
<td>
<p>index (<code>logical</code> or <code>numeric</code>) of the time interval objects.</p>
</td></tr>
<tr><td><code id="POSIXcti_+3A_value">value</code></td>
<td>
<p>New <code>POSIXcti</code> object.</p>
</td></tr>
<tr><td><code id="POSIXcti_+3A_f">f</code></td>
<td>
<p><code><a href="base.html#topic+factor">factor</a></code> used to group the <code>POSIXcti</code> elements.</p>
</td></tr>
<tr><td><code id="POSIXcti_+3A_drop">drop</code></td>
<td>
<p>Argument specific to the split method. See <code>link[base]{split}</code>
documentation.</p>
</td></tr>
<tr><td><code id="POSIXcti_+3A_format">format</code></td>
<td>
<p><code>character</code> indicating the format to use to represent
the time interval. See sectopn &lsquo;Text representation&rsquo; below
for further details.</p>
</td></tr>
<tr><td><code id="POSIXcti_+3A_object">object</code></td>
<td>
<p><code>POSIXcti</code> object on which the method has to be applied.</p>
</td></tr>
<tr><td><code id="POSIXcti_+3A_table">table</code></td>
<td>
<p>The values (<code>POSIXcti</code> vector) to be matched against. See 
<code><a href="base.html#topic+match">match</a></code> for further details.</p>
</td></tr>
<tr><td><code id="POSIXcti_+3A_nomatch">nomatch</code></td>
<td>
<p>The value to be returned i nthe case when no match is found.
See  <code><a href="base.html#topic+match">match</a></code> for further details.</p>
</td></tr>
<tr><td><code id="POSIXcti_+3A_incomparables">incomparables</code></td>
<td>
<p>A vector of values that cannot be matched.
See  <code><a href="base.html#topic+match">match</a></code> for further details.</p>
</td></tr>
<tr><td><code id="POSIXcti_+3A_e1">e1</code></td>
<td>
<p>For (&lt;, &lt;=, !=, ==, &gt;=, &gt;) <code>POSIXcti</code> to compare ; otherwise
a <code>POSIXcti</code> to shift by a time period (<code><a href="#topic+POSIXctp">POSIXctp</a></code>) or
a <code><a href="#topic+POSIXctp">POSIXctp</a></code> by which a <code>POSIXcti</code> has to be shift.</p>
</td></tr>
<tr><td><code id="POSIXcti_+3A_e2">e2</code></td>
<td>
<p>For (&lt;, &lt;=, !=, ==, &gt;=, &gt;) <code>POSIXcti</code> to compare ; otherwise
a <code>POSIXcti</code> to shift by a time period (<code><a href="#topic+POSIXctp">POSIXctp</a></code>) or
a <code><a href="#topic+POSIXctp">POSIXctp</a></code> by which a <code>POSIXcti</code> has to be shift.</p>
</td></tr>
<tr><td><code id="POSIXcti_+3A_i1">i1</code></td>
<td>
<p><code>POSIXcti</code> to test/intersect. See <code><a href="#topic++25included+25">%included%</a></code> and 
<code><a href="#topic++25intersect+25">%intersect%</a></code> for further details.</p>
</td></tr>
<tr><td><code id="POSIXcti_+3A_i2">i2</code></td>
<td>
<p><code>POSIXcti</code> to test/intersect. See <code><a href="#topic++25included+25">%included%</a></code> and 
<code><a href="#topic++25intersect+25">%intersect%</a></code> for further details.</p>
</td></tr>
<tr><td><code id="POSIXcti_+3A_...">...</code></td>
<td>
<p>More arguments.</p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>Objects of this class represent time intervals. One object is actually a
vector of time intervals and so can have a length of one for a single
time interval or a length of &lsquo;n&rsquo; for &lsquo;n&rsquo; time intervals.
</p>


<h3>Slots</h3>


<dl>
<dt><code>start</code>:</dt><dd><p>Object of class <code>"POSIXct"</code> corresponding to the
beginning of the interval.</p>
</dd>
<dt><code>duration</code>:</dt><dd><p>integer indicating in seconds the duration of
intervals.</p>
</dd>
</dl>



<h3>Accessing to POSIXcti properties</h3>

<p>A POSIXcti has several properties. Because a POSIXcti is a vector of 
time intervals, the class has a <code><a href="base.html#topic+length">length</a></code> function. Other
properties are time properties : <code><a href="stats.html#topic+start">start</a></code>, <code><a href="stats.html#topic+end">end</a></code>
and <code><a href="#topic+duration">duration</a></code> allow to access to the corresponding properties.
The <code>duration</code> of a time interval is the number of seconds for which
the interval last.
</p>


<h3>Manipulating POSIXcti</h3>

<p>Manipulating <code>POSIXcti</code> means acting on <code>POSIXcti</code>s like on classical
vectors. Methods available for this task allow to extract or replace parts of
a <code>POSIXcti</code> (with the usual '[' operator), and to
concatenate (<code><a href="base.html#topic+c">c</a></code>) or split <code>POSIXcti</code>
(<code><a href="base.html#topic+split">split</a></code>). A <code><a href="base.html#topic+unique">unique</a></code> and a <code><a href="base.html#topic+rep">rep</a></code>
method are defined to uniquify or repeat elements of a <code>POSIXcti</code>.
</p>
<p><code><a href="base.html#topic+match">match</a></code> and <code><a href="base.html#topic++25in+25">%in%</a></code> methods have also been
defined to find <code>POSIXctp</code> objects among others.
</p>
<p>Last, the <code><a href="#topic++25intersect+25">%intersect%</a></code> method allow to intersect two
<code>POSIXcti</code>.
</p>


<h3>Text representation</h3>

<p>To represent a <code>POSIXcti</code> available functions are <code><a href="base.html#topic+print">print</a></code>,
<code><a href="base.html#topic+summary">summary</a></code>, <code><a href="utils.html#topic+head">head</a></code>,
<code><a href="utils.html#topic+tail">tail</a></code>, <code><a href="methods.html#topic+show">show</a></code> and <code>format</code>.
</p>
<p>The five first functions work the same way that their generic definition.
</p>
<p><code>POSIXcti</code> are formatted by pasting the character strings 
representing both start and end of each intervals. 
Start and end's format can be specified with the <code>format</code>
argument according to the basic <a href="base.html#topic+format.POSIXct">format.POSIXct</a> function.
</p>


<h3>Testing two POSIXcti</h3>

<p>To test two POSIXcti the differents operators of comparison are used. One 
more is defined : <code><a href="#topic++25included+25">%included%</a></code>. If the <code>POSIXcti</code> compared
have a different length, the shorter is recycled over the longer so the 
resulting vector (a logical vector) has length equal to the longer object.
</p>
<p>Comparisons are made element by element. The result for a single comparison
is given there :
</p>

<dl>
<dt>e1 &lt; e2</dt><dd><p>TRUE if <code>end(e1) &lt;= start(e2)</code>.</p>
</dd>
<dt>e1 &lt;= e2</dt><dd><p>TRUE if <code>start(e1) &lt;= start(e2) &amp; end(e1) &lt;= end(e2)</code>.</p>
</dd>
<dt>e1 != e2</dt><dd><p>TRUE if <code>start(e1) != start(e2) | duration(e1) != duration(e2)</code>.</p>
</dd>
<dt>e1 == e2</dt><dd><p>TRUE if <code>start(e1) == start(e2) &amp; duration(e1) == duration(e2)</code>.</p>
</dd>
<dt>e1 &gt;= e2</dt><dd><p>TRUE if <code>start(e1) &gt;= start(e2) &amp; end(e1) &gt;= end(e2)</code>.</p>
</dd>
<dt>e1 &gt; e2</dt><dd><p>TRUE if <code>end(e1) &gt;= start(e2)</code>.</p>
</dd>
<dt>i1 %included% i2</dt><dd><p>TRUE if <code>start(i1) &gt;= start(i2) &amp; end(i1) &lt;= end(i2)</code>.</p>
</dd>
</dl>



<h3>Mathematical operations on POSIXcti</h3>

<p>&lsquo;Mathematical&rsquo; operations are actually &lsquo;time lagging&rsquo; for 
<code>POSIXcti</code>. A 
<code><a href="#topic+POSIXctp">time period</a></code> is added/removed to both start and end
of intervals. The available operations are :
</p>

<ul>
<li><p> POSIXcti + POSIXctp
</p>
</li>
<li><p> POSIXctp + POISXcti
</p>
</li>
<li><p> POSIXcti - POSIXctp
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="base.html#topic+POSIXct">POSIXct</a></code>, <code><a href="#topic+TimeIntervalDataFrame">TimeIntervalDataFrame</a></code>,
<code><a href="#topic+POSIXst">POSIXst</a></code>, <code><a href="#topic+POSIXctp">POSIXctp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # time interval : january of year 2013
  jan &lt;- POSIXcti('2013-01-01', '2013-02-01')
  jan

  # the complete year
  y2013 &lt;- POSIXcti('2013-01-01', '2014-01-01')
  y2013

  # is jan in 2013 ?
  jan %included% y2013

  # intersection
  jan %intersect% y2013

</code></pre>

<hr>
<h2 id='POSIXctp'>Class <code>"POSIXctp"</code></h2><span id='topic+POSIXctp-class'></span><span id='topic+POSIXctp'></span><span id='topic+as.POSIXctp'></span><span id='topic+as.POSIXctp.logical'></span><span id='topic++5B.POSIXctp'></span><span id='topic++5B+3C-.POSIXctp'></span><span id='topic+c.POSIXctp'></span><span id='topic+split.POSIXctp'></span><span id='topic+rep.POSIXctp'></span><span id='topic+unique.POSIXctp'></span><span id='topic+length+2CPOSIXctp-method'></span><span id='topic+unit+2CPOSIXctp-method'></span><span id='topic+unit+3C-+2CPOSIXctp-method'></span><span id='topic+duration+2CPOSIXctp-method'></span><span id='topic+print.POSIXctp'></span><span id='topic+format.POSIXctp'></span><span id='topic+show+2CPOSIXctp-method'></span><span id='topic+summary.POSIXctp'></span><span id='topic+head.POSIXctp'></span><span id='topic+tail.POSIXctp'></span><span id='topic+match+2CPOSIXctp+2CPOSIXctp-method'></span><span id='topic+match+2CPOSIXctp+2CANY-method'></span><span id='topic++25in+25+2CPOSIXctp+2CANY-method'></span><span id='topic+Ops.POSIXctp'></span><span id='topic++3C.POSIXctp'></span><span id='topic++3C+3D.POSIXctp'></span><span id='topic++3D+3D.POSIXctp'></span><span id='topic++21+3D.POSIXctp'></span><span id='topic++3E+3D.POSIXctp'></span><span id='topic++3E.POSIXctp'></span><span id='topic++2A+2Cnumeric+2CPOSIXctp-method'></span><span id='topic++2A+2CPOSIXctp+2Cnumeric-method'></span><span id='topic++2B+2CPOSIXctp+2CPOSIXctp-method'></span><span id='topic+-+2CPOSIXctp+2CPOSIXctp-method'></span><span id='topic++2B+2CPOSIXct+2CPOSIXctp-method'></span><span id='topic++2B+2CPOSIXctp+2CPOSIXct-method'></span><span id='topic+-+2CPOSIXct+2CPOSIXctp-method'></span><span id='topic+as.numeric+2CPOSIXctp-method'></span>

<h3>Description</h3>

<p>Class that defines 'periods of time' objects such as 'one month', 'two months', 
'three hours', 'four minutes', etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>POSIXctp(duration, unit)
as.POSIXctp(from, ...)

  ## S3 method for class 'POSIXctp'
x[i, ...]
  ## S3 replacement method for class 'POSIXctp'
x[i] &lt;- value
  ## S3 method for class 'POSIXctp'
c(...)
  ## S3 method for class 'POSIXctp'
split(x, f, drop=FALSE, ...)
  ## S3 method for class 'POSIXctp'
rep(x, ...)
  ## S3 method for class 'POSIXctp'
unique(x, incomparables=FALSE, ...)

  ## S4 method for signature 'POSIXctp'
unit(x, ...)
  ## S4 replacement method for signature 'POSIXctp'
unit(object) &lt;- value
  ## S4 method for signature 'POSIXctp'
duration(x, ...)

  ## S4 method for signature 'POSIXctp'
length(x)

  ## S3 method for class 'POSIXctp'
print(x, ...)
  ## S3 method for class 'POSIXctp'
format(x, ...)
  ## S3 method for class 'POSIXctp'
summary(object, ...)
  ## S3 method for class 'POSIXctp'
head(x, ...)
  ## S3 method for class 'POSIXctp'
tail(x, ...)
  ## S4 method for signature 'POSIXctp'
show(object)

  ## S4 method for signature 'POSIXctp,POSIXctp'
match(x, table, nomatch = NA_integer_, incomparables=NULL)
  ## S4 method for signature 'POSIXctp,ANY'
match(x, table, nomatch = NA_integer_, incomparables=NULL)
  ## S4 method for signature 'POSIXctp,ANY'
x %in% table

  ## S3 method for class 'POSIXctp'
Ops(e1, e2)

  ## S4 method for signature 'numeric,POSIXctp'
e1 * e2
  ## S4 method for signature 'POSIXctp,numeric'
e1 * e2
  ## S4 method for signature 'POSIXctp,POSIXctp'
e1 + e2
  ## S4 method for signature 'POSIXctp,POSIXctp'
e1 - e2

  ## S4 method for signature 'POSIXct,POSIXctp'
e1 + e2
  ## S4 method for signature 'POSIXctp,POSIXct'
e1 + e2
  ## S4 method for signature 'POSIXct,POSIXctp'
e1 - e2

  ## S4 method for signature 'POSIXctp'
as.numeric(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="POSIXctp_+3A_duration">duration</code></td>
<td>
<p>A vector <code>integer</code> indicating the duration of period (2 for 
2 monthes, 1 for 1 year, etc). If a vector of <code>numeric</code> is given, it 
will coerced to an <code>integer</code>. Can be missing, see details below.</p>
</td></tr>
<tr><td><code id="POSIXctp_+3A_unit">unit</code></td>
<td>
<p>A vector of factors defined by <code><a href="#topic+POSIXt.units">POSIXt.units</a></code>() or
a vector of <code>character</code> corresponding to the previous factors.
See details below.</p>
</td></tr>
<tr><td><code id="POSIXctp_+3A_from">from</code></td>
<td>
<p>Object to convert to a period of time (actually works only for
<code>NA</code>).</p>
</td></tr>
<tr><td><code id="POSIXctp_+3A_x">x</code></td>
<td>
<p><code>POSIXctp</code> object on which the method has to be applied.</p>
</td></tr>
<tr><td><code id="POSIXctp_+3A_i">i</code></td>
<td>
<p>index (<code>logical</code> or <code>numeric</code>) of the POSIXctp objects.</p>
</td></tr>
<tr><td><code id="POSIXctp_+3A_value">value</code></td>
<td>
<p>New <code>POSIXctp</code> object.</p>
</td></tr>
<tr><td><code id="POSIXctp_+3A_f">f</code></td>
<td>
<p><code><a href="base.html#topic+factor">factor</a></code> used to group the <code>POSIXctp</code> elements.</p>
</td></tr>
<tr><td><code id="POSIXctp_+3A_drop">drop</code></td>
<td>
<p>Argument specific to the split method. See <code>link[base]{split}</code>
documentation.</p>
</td></tr>
<tr><td><code id="POSIXctp_+3A_object">object</code></td>
<td>
<p><code>POSIXctp</code> object on which the method has to be applied.</p>
</td></tr>
<tr><td><code id="POSIXctp_+3A_table">table</code></td>
<td>
<p>The values (<code>POSIXctp</code>) to be matched against. See 
<code><a href="base.html#topic+match">match</a></code> for further details.</p>
</td></tr>
<tr><td><code id="POSIXctp_+3A_nomatch">nomatch</code></td>
<td>
<p>The value to be returned i nthe case when no match is found.
See  <code><a href="base.html#topic+match">match</a></code> for further details.</p>
</td></tr>
<tr><td><code id="POSIXctp_+3A_incomparables">incomparables</code></td>
<td>
<p>A vector of values that cannot be matched.
See  <code><a href="base.html#topic+match">match</a></code> for further details.</p>
</td></tr>
<tr><td><code id="POSIXctp_+3A_e1">e1</code></td>
<td>
<p><code>POSIXctp</code>, <code>numeric</code> or <code><a href="base.html#topic+POSIXct">POSIXct</a></code>. See details.</p>
</td></tr>
<tr><td><code id="POSIXctp_+3A_e2">e2</code></td>
<td>
<p><code>POSIXctp</code>, <code>numeric</code> or <code><a href="base.html#topic+POSIXct">POSIXct</a></code>. See details.</p>
</td></tr>
<tr><td><code id="POSIXctp_+3A_...">...</code></td>
<td>
<p>More arguments.</p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>Objects of this class are used to represent periods of times such
as &lsquo;one hour&rsquo;, &lsquo;two seconds&rsquo;, &lsquo;three years&rsquo;, etc.
Partial periods of time are not allowed (&lsquo;1.5 hours&rsquo; will be coerced
to an integer value using <code><a href="base.html#topic+as.integer">as.integer</a></code>).
</p>
<p>POSIXctp (&lsquo;p&rsquo; stands for&lsquo;period&rsquo;) has only one unit.
So &lsquo;one hour and 2 seconds&rsquo; is not defined.
</p>
<p>One object is actually a  vector of periods of time and so can have a
length of one for a single period of time or a length of &lsquo;n&rsquo;
for &lsquo;n&rsquo; periods of time.
</p>


<h3>Slots</h3>


<dl>
<dt><code>duration</code>:</dt><dd><p>integer corresponding to the length of the period.</p>
</dd>
<dt><code>unit</code>:</dt><dd><p>factor indicating the time unit
of the period. See <code><a href="#topic+POSIXt.units">POSIXt.units</a></code> to know available
units.</p>
</dd>
</dl>



<h3>Accessing to POSIXctp properties</h3>

<p>A POSIXctp has several properties. Because a POSIXctp is a vector of 
periodes of time, the class has a <code><a href="base.html#topic+length">length</a></code> function. Other
properties are time properties : <code><a href="#topic+unit">unit</a></code>
and <code><a href="#topic+duration">duration</a></code> allow to access to the corresponding properties.
The <code>duration</code> of a period of time is an integer corresponding of the
time that the period last, in its time unit. The unit of a period of time 
is an ordered factor as the one defined by <code><a href="#topic+POSIXt.units">POSIXt.units</a></code>.
</p>
<p>A <code>POSIXctp</code> can be converted to another time unit base (for instance
2 hours make 120 minutes). For that purpose the function <code>unit&lt;-</code> is 
defined. The conversion will be effective only if the new unit can be exactly
defined as a multiple of the old one
(&lsquo;hour&rsquo; to  &lsquo;second&rsquo;, ok ; &lsquo;year&rsquo; to &lsquo;month&rsquo;, ok
; &lsquo;month&rsquo; to &lsquo;minute&rsquo; , NOT ok ; etc.
When conversion can not be done, the result has its unit unchanged.
</p>


<h3>Manipulating POSIXctp</h3>

<p>Manipulating <code>POSIXctp</code> means acting on <code>POSIXctp</code>s like on classical
vectors. Methods available for this task allow to extract or replace parts of
a <code>POSIXctp</code> (with the usual '[' operator), and to
concatenate (<code><a href="base.html#topic+c">c</a></code>) or split <code>POSIXctp</code>
(<code><a href="base.html#topic+split">split</a></code>). A <code><a href="base.html#topic+unique">unique</a></code> and a <code><a href="base.html#topic+rep">rep</a></code>
method are defined to uniquify or repeat elements of a <code>POSIXctp</code>.
</p>
<p><code><a href="base.html#topic+match">match</a></code> and <code><a href="base.html#topic++25in+25">%in%</a></code> methods have also been
defined to find <code>POSIXctp</code> objects among others.
</p>


<h3>Text representation</h3>

<p>To represent a <code>POSIXctp</code> available functions are <code><a href="base.html#topic+print">print</a></code>,
<code><a href="base.html#topic+summary">summary</a></code>, <code><a href="utils.html#topic+head">head</a></code>,
<code><a href="utils.html#topic+tail">tail</a></code>, <code><a href="methods.html#topic+show">show</a></code> and <code>format</code>.
</p>
<p>The five first functions work the same way that their generic definition.
</p>
<p><code>POSIXctp</code> are formatted by pasting their duration (<code>integer</code>)
with their unit (and with an &lsquo;s&rsquo; if relevant).
</p>


<h3>Testing two POSIXctp</h3>

<p>To test two POSIXctp the differents operators of comparison are used. 
If the <code>POSIXctp</code> compared
have a different length, the shorter is recycled over the longer so the 
resulting vector (a logical vector) has length equal to the longer object.
</p>
<p>Comparisons are made element by element. For a single comparison, first 
elements are converted into the same unit. If this is not possible,
FALSE is returned if the test is &lsquo;==&rsquo;, TRUE if the test is &lsquo;!=&rsquo;,
NA otherwise (elements can not be compared) ; else durations of elements are
compared and the result of this comparison is returned.
</p>


<h3>Mathematical operations on POSIXctp</h3>

<p><code>POSIXctp</code> can be added (or substracted) to differents type of objects :
to other <code>POSIXctp</code>, to <code>POSIXct</code>, to <code>POSIXcti</code>  and to
<code>POSIXst</code>.  <code>POSIXctp</code> can also be multiplied by <code>numeric</code>.
</p>
<p>For all operations, if the two arguments
have a different length, the shorter is recycled over the longer so the 
resulting vector (a logical vector) has length equal to the longer object.
</p>
<p>Basic mathematical operation for <code>POSIXctp</code> are (negative periods of
time can be defined !!) :
</p>

<ul>
<li><p> integer * POSIXctp
</p>
</li>
<li><p> POSIXctp * integer
</p>
</li>
<li><p> POSIXctp + POSIXctp
</p>
</li>
<li><p> POSIXctp - POSIxctp
</p>
</li></ul>

<p>When <code>POSIXctp</code>s do not have the same unit, an attempt is made to convert
one to the unit of  the other, if it successes the operation is done otherwise
NA is returned.
</p>
<p>Mathematical operations with <code>POSIXct</code>, <code>POSIXcti</code> and <code>POSIXst</code>
are actually time lagging. A <code>POSIXct</code> to which a <code>POSIXctp</code> is 
added is lagged by the time periods indicated ; for a  <code>POSIXcti</code>, start
and end are lagged by the time periods. 
For <code>POSIXst</code>, units of the <code>POSIXst</code> must be identical : the object
is then lagged by the time periods (if the result is higher than the maximum
the result is recycled at the begining. For instance :
<code>saturday + 2 days = monday</code>).
</p>

<ul>
<li><p> POSIXct + POSIXctp 
</p>
</li>
<li><p> POSIXctp + POISXct
</p>
</li>
<li><p> POSIXct - POSIXctp
</p>
</li>
<li><p> .
</p>
</li>
<li><p> POSIXcti + POSIXctp 
</p>
</li>
<li><p> POSIXctp + POISXcti
</p>
</li>
<li><p> POSIXcti - POSIXctp
</p>
</li>
<li><p> .
</p>
</li>
<li><p> POSIXst + POSIXctp 
</p>
</li>
<li><p> POSIXctp + POISXst
</p>
</li>
<li><p> POSIXst - POSIXctp
</p>
</li></ul>



<h3>Changing class</h3>

<p><code>POSIXctp</code> can be converted to <code>numeric</code> with the <code>as.numeric</code>
method. The duration of the object is returned.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+POSIXct">POSIXct</a></code>, <code><a href="#topic+POSIXcti">POSIXcti</a></code>, 
<code><a href="#topic+POSIXst">POSIXst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("POSIXctp")
</code></pre>

<hr>
<h2 id='POSIXst'>Class <code>"POSIXst"</code></h2><span id='topic+POSIXst-class'></span><span id='topic+POSIXst'></span><span id='topic+POSIXst.default'></span><span id='topic+POSIXst.integer'></span><span id='topic+POSIXst.numeric'></span><span id='topic+POSIXst.POSIXct'></span><span id='topic+POSIXst.POSIXlt'></span><span id='topic+POSIXst.TimeInstantDataFrame'></span><span id='topic+POSIXst.TimeIntervalDataFrame'></span><span id='topic+day'></span><span id='topic+day+2CANY-method'></span><span id='topic+day-methods'></span><span id='topic+hour'></span><span id='topic+hour+2CANY-method'></span><span id='topic+hour-methods'></span><span id='topic+minute'></span><span id='topic+minute+2CANY-method'></span><span id='topic+minute-methods'></span><span id='topic+month'></span><span id='topic+month+2CANY-method'></span><span id='topic+month-methods'></span><span id='topic+second'></span><span id='topic+second+2CANY-method'></span><span id='topic+second-methods'></span><span id='topic+year'></span><span id='topic+year+2CANY-method'></span><span id='topic+year-methods'></span><span id='topic++5B.POSIXst'></span><span id='topic++5B+3C-.POSIXst'></span><span id='topic+c.POSIXst'></span><span id='topic+split.POSIXst'></span><span id='topic+rep.POSIXst'></span><span id='topic+seq.POSIXst'></span><span id='topic+unique.POSIXst'></span><span id='topic+duplicated.POSIXst'></span><span id='topic+unit.POSIXst'></span><span id='topic+of.POSIXst'></span><span id='topic+timezone.POSIXst'></span><span id='topic+length+2CPOSIXst-method'></span><span id='topic+print.POSIXst'></span><span id='topic+format.POSIXst'></span><span id='topic+summary.POSIXst'></span><span id='topic+head.POSIXst'></span><span id='topic+tail.POSIXst'></span><span id='topic+show+2CPOSIXst-method'></span><span id='topic+match+2CPOSIXst+2CPOSIXst-method'></span><span id='topic+match+2CPOSIXst+2CANY-method'></span><span id='topic++25in+25+2CPOSIXst+2CANY-method'></span><span id='topic+Ops.POSIXst'></span><span id='topic++3C.POSIXst'></span><span id='topic++3C+3D.POSIXst'></span><span id='topic++3D+3D.POSIXst'></span><span id='topic++21+3D.POSIXst'></span><span id='topic++3E+3D.POSIXst'></span><span id='topic++3E.POSIXst'></span><span id='topic+-+2CPOSIXst+2CPOSIXst-method'></span><span id='topic++2B+2CPOSIXst+2CPOSIXctp-method'></span><span id='topic++2B+2CPOSIXctp+2CPOSIXst-method'></span><span id='topic+-+2CPOSIXst+2CPOSIXctp-method'></span><span id='topic+as.numeric+2CPOSIXst-method'></span>

<h3>Description</h3>

<p>Class to define POSIXst object such as hours of day, seconds of year, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
POSIXst(x, unit, of = NULL, tz = "UTC", ...)
  ## Default S3 method:
 POSIXst(x, unit, of = NULL, tz = "UTC", ...)
  ## S3 method for class 'integer'
 POSIXst(x, unit, of = NULL, tz = "UTC", ...)
  ## S3 method for class 'numeric'
 POSIXst(x, unit, of = NULL, tz = "UTC", ...)
  ## S3 method for class 'POSIXct'
 POSIXst(x, unit, of = NULL, tz = attributes(x)$tzone, ...)
  ## S3 method for class 'POSIXlt'
 POSIXst(x, unit, of = NULL, tz = attributes(x)$tzone, ...)
  ## S3 method for class 'TimeInstantDataFrame'
 POSIXst(x, unit, of = NULL, tz = timezone(x), ...)
  ## S3 method for class 'TimeIntervalDataFrame'
 POSIXst(x, unit, of = NULL, tz = timezone(x), ..., cursor = NULL)

year(x, ...)
month(x, ...)
day(x, of, ...)
hour(x, of, ...)
minute(x, of, ...)
second(x, of, ...)

  ## S3 method for class 'POSIXst'
x[i]
  ## S3 replacement method for class 'POSIXst'
x[i] &lt;- value
  ## S3 method for class 'POSIXst'
c(...)
  ## S3 method for class 'POSIXst'
split(x, f, drop=FALSE, ...)
  ## S3 method for class 'POSIXst'
rep(x, ...)
  ## S3 method for class 'POSIXst'
seq(from, to, ...)
  ## S3 method for class 'POSIXst'
unique(x, incomparables=FALSE, ...)
  ## S3 method for class 'POSIXst'
duplicated(x, incomparables=FALSE, ...)

  ## S3 method for class 'POSIXst'
unit(x, ...)
  ## S3 method for class 'POSIXst'
of(x, ...)
  ## S3 method for class 'POSIXst'
timezone(object)

  ## S4 method for signature 'POSIXst'
length(x)

  ## S3 method for class 'POSIXst'
print(x, ...)
  ## S3 method for class 'POSIXst'
format(x, format, ...)
  ## S3 method for class 'POSIXst'
summary(object, ...)
  ## S3 method for class 'POSIXst'
head(x, ...)
  ## S3 method for class 'POSIXst'
tail(x, ...)
  ## S4 method for signature 'POSIXst'
show(object)

  ## S4 method for signature 'POSIXst,POSIXst'
match(x, table, nomatch = NA_integer_, incomparables=NULL)
  ## S4 method for signature 'POSIXst,ANY'
match(x, table, nomatch = NA_integer_, incomparables=NULL)
  ## S4 method for signature 'POSIXst,ANY'
x %in% table

  ## S3 method for class 'POSIXst'
Ops(e1, e2)

  ## S4 method for signature 'POSIXst,POSIXctp'
e1 + e2
  ## S4 method for signature 'POSIXctp,POSIXst'
e1 + e2
  ## S4 method for signature 'POSIXst,POSIXctp'
e1 - e2

  ## S4 method for signature 'POSIXst,POSIXst'
e1 - e2

  ## S4 method for signature 'POSIXst'
as.numeric(x, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="POSIXst_+3A_x">x</code></td>
<td>
<p>object to convert into POSIXst or <code>POSIXst</code> object on which the
method has to be applied.</p>
</td></tr>
<tr><td><code id="POSIXst_+3A_unit">unit</code></td>
<td>
<p>indicates the subtime part to extract ('year', 'month', 'day',
'hour', 'minute', 'second')</p>
</td></tr>
<tr><td><code id="POSIXst_+3A_of">of</code></td>
<td>
<p>used to specify the main period from wich the is to extract
('year', 'month', day', 'hour', 'minute'). Not used for
&lsquo;unit in c('year', 'month')&rsquo;.</p>
</td></tr>
<tr><td><code id="POSIXst_+3A_tz">tz</code></td>
<td>
<p>if needed, specifies th timezone of POSIXst</p>
</td></tr>
<tr><td><code id="POSIXst_+3A_cursor">cursor</code></td>
<td>
<p>for TimeIntervalDataFrame, if not NULL, the object is first
coerced to a TimeInstantDataFrame using the
<code><a href="#topic+as.TimeInstantDataFrame">as.TimeInstantDataFrame</a></code> method.</p>
</td></tr>
<tr><td><code id="POSIXst_+3A_i">i</code></td>
<td>
<p>index (<code>logical</code> or <code>numeric</code>) of the POSIXst objects.</p>
</td></tr>
<tr><td><code id="POSIXst_+3A_value">value</code></td>
<td>
<p>New <code>POSIXst</code> object.</p>
</td></tr>
<tr><td><code id="POSIXst_+3A_f">f</code></td>
<td>
<p><code><a href="base.html#topic+factor">factor</a></code> used to group the <code>POSIXst</code> elements.</p>
</td></tr>
<tr><td><code id="POSIXst_+3A_drop">drop</code></td>
<td>
<p>Argument specific to the split method. See <code>link[base]{split}</code>
documentation.</p>
</td></tr>
<tr><td><code id="POSIXst_+3A_object">object</code></td>
<td>
<p><code>POSIXst</code> object on which the method has to be applied.</p>
</td></tr>
<tr><td><code id="POSIXst_+3A_format">format</code></td>
<td>
<p>Character string to precise the desired format. See section
&lsquo;Text representation&rsquo; below for details.</p>
</td></tr>
<tr><td><code id="POSIXst_+3A_table">table</code></td>
<td>
<p>The values (<code>POSIXst</code>) to be matched against. See 
<code><a href="base.html#topic+match">match</a></code> for further details.</p>
</td></tr>
<tr><td><code id="POSIXst_+3A_nomatch">nomatch</code></td>
<td>
<p>The value to be returned i nthe case when no match is found.
See  <code><a href="base.html#topic+match">match</a></code> for further details.</p>
</td></tr>
<tr><td><code id="POSIXst_+3A_incomparables">incomparables</code></td>
<td>
<p>A vector of values that cannot be matched.
See  <code><a href="base.html#topic+match">match</a></code> for further details.</p>
</td></tr>
<tr><td><code id="POSIXst_+3A_e1">e1</code></td>
<td>
<p><code>POSIXst</code> or <code><a href="#topic+POSIXctp">POSIXctp</a></code>. See details.</p>
</td></tr>
<tr><td><code id="POSIXst_+3A_e2">e2</code></td>
<td>
<p><code>POSIXst</code> or <code><a href="#topic+POSIXctp">POSIXctp</a></code>. See details.</p>
</td></tr>
<tr><td><code id="POSIXst_+3A_from">from</code>, <code id="POSIXst_+3A_to">to</code></td>
<td>
<p>starting and end values to sequence, see <code><a href="base.html#topic+seq">seq</a></code></p>
</td></tr>
<tr><td><code id="POSIXst_+3A_...">...</code></td>
<td>
<p>More arguments.</p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>Objects of this class are used to represent subtimes. A subtime (or a
&lsquo;POSIXst&rsquo;, &lsquo;st&rsquo; stand for Sub and Time)  is a subdivision  of
time :
</p>

<ul>
<li><p> second of a minute ;
</p>
</li>
<li><p> second of an hour ;
</p>
</li>
<li><p> second of a day ;
</p>
</li>
<li><p> second of a week ;
</p>
</li>
<li><p> second of a month ;
</p>
</li>
<li><p> second of a year ;
</p>
</li>
<li><p> minute of an hour ;
</p>
</li>
<li><p> minute of a day ;
</p>
</li>
<li> <p>...
</p>
</li>
<li><p> minute of a year ;
</p>
</li>
<li> <p>...
</p>
</li>
<li><p> month of year ;
</p>
</li>
<li><p> year AD (after death).
</p>
</li></ul>

<p>A POSIXst is a kind of time object composed of 2 units and
a positionnal integer. 
The main unit can be accessed via the &lsquo;of&rsquo; function ;
the sub unit can be accessed via the &lsquo;unit&rsquo; function.
The positionnal integer correspond to the value of the subtime object.
Consequently, a subtime <code>st</code> is the <code>value</code>th <code>unit(st)</code>
of <code>of(st)</code>.
</p>
<p>The range of valid values for each kind of POSIXst is defined accordingly
to the <code><a href="base.html#topic+DateTimeClasses">DateTimeClasses</a></code> definitions. For instance 
valid values for seconds of hour are 0 to 61, valid values for 
day of week are 0 to 6, etc.
</p>
<p>To define POSIXst objects see POSIXst section below.
</p>
<p>One object is actually a  vector of subtimes and so can have a length of one
for a single subtime or a length of &lsquo;n&rsquo; for &lsquo;n&rsquo; subtimes.
</p>
<p>Last, a POSIXst object has a &lsquo;timezone&rsquo; slots. This is defined
for compatibility reason with POSIXct object and also with
<code><a href="#topic+TimeInstantDataFrame">TimeInstantDataFrame</a></code>,  <code><a href="#topic+TimeIntervalDataFrame">TimeIntervalDataFrame</a></code> and 
<code><a href="#topic+SubtimeDataFrame">SubtimeDataFrame</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>subtime</code>:</dt><dd><p>Object of class <code>"integer"</code> corresponding to the
actual value of each subtime.</p>
</dd>
<dt><code>unit</code>:</dt><dd><p>factor representing a time unit. It represents the
subdvision of time (in 'second of year' it corresponds to 'second').
See <code><a href="#topic+POSIXt.units">POSIXt.units</a></code>.</p>
</dd>
<dt><code>of</code>:</dt><dd><p>factor representing a time unit. It represents the main
time unit (in 'second of year' it corresponds to 'year'). See
<code><a href="#topic+POSIXt.units">POSIXt.units</a></code>.</p>
</dd>
<dt><code>timezone</code>:</dt><dd><p>Object of class <code>"character"</code> indicating the
timezone of the POSIXst object.</p>
</dd>
</dl>



<h3>POSIXst</h3>

<p><code>POSIXst</code> objects can be created from various other class objects.
For this purpose the <code>POSIXst</code> method has been defined. 
</p>
<p>First, if &lsquo;x&rsquo; is missing, an empty factor with the appropriated levels
(according to &lsquo;unit and of&rsquo;) is returned.
</p>
<p>A <code>POSIXst</code> can be created from an integer or a numeric. If so,
&lsquo;unit&rsquo;
and &lsquo;of&rsquo; msute be supplied (see arguments section above). The &lsquo;tz&rsquo;
argument can be supplied (numeric will be converted to an integer). In both 
cases,  values of the integer/numeric must be in the right range 
(see <code><a href="base.html#topic+DateTimeClasses">DateTimeClasses</a></code>.
</p>
<p>A <code>POSIXst</code> can be created from a <code><a href="base.html#topic+POSIXct">POSIXct</a></code> or
<code><a href="base.html#topic+POSIXlt">POSIXlt</a></code> object. In this case, the subtime (POSIxst) is extracted
in the units indicated by &lsquo;unit&rsquo; and &lsquo;of&rsquo; arguments. The 
&lsquo;tz&rsquo; argument indicates the timezone of the resulting object (it doesn't
do any conversion on the POSIXl,ct objects).
</p>
<p>Finally, <code>POSIXst</code> can be extracted from <code><a href="#topic+TimeInstantDataFrame">TimeInstantDataFrame</a></code>
and  <code><a href="#topic+TimeIntervalDataFrame">TimeIntervalDataFrame</a></code>. For the first type of object, the 
method is applied to the time instants (which are <code>POSIXct</code>). For the 
latter, because a time interval can contains several POSIXst of one kind (for
instance a day contains all 'hours of day'), the result of this method  
TimeIntervalDataFrame is a list of POSIXst. Each element of the list contains
the POSIXsts asked for corresponding to each row of the TimeIntervalDataFrame
object. If &lsquo;cursor&rsquo; is supplied, the TimeIntervalDataFrame is first
converted to a TimeInstantDataFrame (see <code><a href="#topic+as.TimeInstantDataFrame">as.TimeInstantDataFrame</a></code>
for details).
</p>


<h3>year(...), month(...), day(...), hour(...), minute(...) and second(...)</h3>

<p><code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code> and
<code>second</code> are methods defined to extract the adequat information from a
time object. These functions are wrappers to <code>POSIXst</code>.
</p>
<p>Each of these methods call POSIXst replacing the <code>unit</code> argument with its
own name :
<code>minute(x, of='day')</code> will call
<code>POSIXst(x, unit='minute', of='day')</code>
</p>


<h3>Accessing to POSIXst properties</h3>

<p>A POSIXst has several properties. Because a POSIXst is a vector of 
subtimes, the class has a <code><a href="base.html#topic+length">length</a></code> function. Other
properties are time properties : <code><a href="#topic+unit">unit</a></code>, <code><a href="#topic+of">of</a></code>
and <code><a href="#topic+timezone">timezone</a></code> allow to access to the corresponding properties.
The &lsquo;unit&rsquo; and &lsquo;of&rsquo; of a subtime 
is an ordered factor as the one defined by <code><a href="#topic+POSIXt.units">POSIXt.units</a></code>.
</p>
<p>For more informations on timezone, see the
<a href="base.html#topic+timezone">page of the manual</a>.
</p>


<h3>Manipulating POSIXst</h3>

<p>Manipulating <code>POSIXst</code> means acting on <code>POSIXst</code>s like on classical
vectors. Methods available for this task allow to extract or replace parts of
a <code>POSIXst</code> (with the usual '[' operator), and to
concatenate (<code><a href="base.html#topic+c">c</a></code>) or split <code>POSIXst</code>
(<code><a href="base.html#topic+split">split</a></code>). A <code><a href="base.html#topic+unique">unique</a></code>, a  <code><a href="base.html#topic+duplicated">duplicated</a></code>, a <code><a href="base.html#topic+rep">rep</a></code>
and a <code><a href="base.html#topic+seq">seq</a></code>
methods are defined to uniquify, repeat or sequence elements of a <code>POSIXst</code>.
</p>
<p><code><a href="base.html#topic+match">match</a></code> and <code><a href="base.html#topic++25in+25">%in%</a></code> methods have also been
defined to find <code>POSIXst</code> objects among others.
</p>


<h3>Text representation</h3>

<p>To represent a <code>POSIXst</code> available functions are <code><a href="base.html#topic+print">print</a></code>,
<code><a href="base.html#topic+summary">summary</a></code>, <code><a href="utils.html#topic+head">head</a></code>,
<code><a href="utils.html#topic+tail">tail</a></code>, <code><a href="methods.html#topic+show">show</a></code> and <code>format</code>.
</p>
<p>The five first functions work the same way that their generic definition.
</p>
<p>'POSIXst' are formatted according to the <code>format</code> argument which must
respect the following rules.
</p>

<ul>
<li><p> %v value
</p>
</li>
<li><p> %s subtime unit (slot &lsquo;unit&rsquo;)
</p>
</li>
<li><p> %m main unit (slot &lsquo;of&rsquo;)
</p>
</li>
<li><p> %a Abbreviated weekday name in the current locale.
</p>
</li>
<li><p> %A Full weekday name in the current locale.
</p>
</li>
<li><p> %b Abbreviated month name in the current locale.
</p>
</li>
<li><p> %B Full month name in the current locale.
</p>
</li>
<li><p> %r timezone
</p>
</li>
<li><p> %p place of subtime (ie the string part of 1st, 2nd, 10th, etc.)
</p>
</li></ul>



<h3>Testing two POSIXst</h3>

<p>To test two POSIXst the differents operators of comparison are used. 
If the <code>POSIXst</code> compared
have a different length, the shorter is recycled over the longer so the 
resulting vector (a logical vector) has length equal to the longer object.
</p>
<p>Comparisons are made element by element. Two <code>POSIXst</code> with a different
&lsquo;unit&rsquo; or a different &lsquo;of&rsquo; are differents (TRUE if test is
&lsquo;!=&rsquo;, FALSE if &lsquo;==&rsquo; NA otherwise). If they have identical
&lsquo;unit&rsquo; and &lsquo;of&rsquo; the comparison is made over subtime slots.
</p>


<h3>Mathematical operations on POSIXst</h3>

<p><code>POSIXst</code> can be added and substracted to <code><a href="#topic+POSIXctp">POSIXctp</a></code>.
<code>POSIXst</code> can also be substracted (and only substracted) to <code>POSIXst</code>.
</p>
<p>For all operations, if the two arguments
have a different length, the shorter is recycled over the longer so the 
resulting vector (a logical vector) has length equal to the longer object.
</p>
<p>Mathematical operations with <code>POSIXctp</code> are actually time lagging. Units
of the <code>POSIXctp</code> must be identical to the <code>POSIXst</code>'s : the object
is then lagged by the time periods (if the result is higher than the maximum
the result is recycled at the begining. For instance :
<code>saturday + 2 days = monday</code>).
</p>

<ul>
<li><p> POSIXst + POSIXctp 
</p>
</li>
<li><p> POSIXctp + POISXst
</p>
</li>
<li><p> POSIXst - POSIXctp
</p>
</li></ul>

<p>Substracting a <code>POSIXst</code> to another result in a <code><a href="#topic+POSIXctp">POSIXctp</a></code>.
For instance <code>wednesday - monday = 2 days</code>.
</p>


<h3>Changing class</h3>

<p><code>POSIXst</code> can be converted to <code>numeric</code> with the <code>as.numeric</code>
method. The subtime slot of the object is returned.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+POSIXct">POSIXct</a></code>, <code><a href="#topic+POSIXcti">POSIXcti</a></code>, <code><a href="#topic+POSIXctp">POSIXctp</a></code>,
<code><a href="#topic+TimeIntervalDataFrame">TimeIntervalDataFrame</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("POSIXst")
</code></pre>

<hr>
<h2 id='regular'>Test if a time object is regular</h2><span id='topic+regular'></span><span id='topic+regular-methods'></span>

<h3>Description</h3>

<p>Test for regularity of a time object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  regular(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regular_+3A_x">x</code></td>
<td>
<p>object to test, from which get or set a
property</p>
</td></tr>
<tr><td><code id="regular_+3A_...">...</code></td>
<td>
<p>arguments to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Test if the object is regular. A TimeInstantDataFrame is
regular if all instants are equally spaced. A
TimeIntervalDataFrame is regular if it is <a href="#topic+homogeneous">homogeneous</a> and
all interval's starts are equally spaced.
</p>


<h3>Value</h3>

<p>boolean indicating if x is regular or not
</p>


<h3>See Also</h3>

<p><a href="#topic+TimeIntervalDataFrame">TimeIntervalDataFrame</a>,
<a href="#topic+TimeInstantDataFrame">TimeInstantDataFrame</a>
</p>

<hr>
<h2 id='split'>Divide into Groups and Reassemble (Time*DataFrame objects and POSIXct*)</h2><span id='topic+split'></span><span id='topic+split+2CANY+2CPOSIXst-method'></span><span id='topic+split+2CANY+2CPOSIXctp-method'></span><span id='topic+split+2CANY+2CPOSIXcti-method'></span><span id='topic+split+2CTimeIntervalDataFrame+2CPOSIXcti-method'></span><span id='topic+split+2CTimeIntervalDataFrame+2CPOSIXctp-method'></span><span id='topic+split+2CTimeIntervalDataFrame+2CTimeIntervalDataFrame-method'></span>

<h3>Description</h3>

<p>&lsquo;split&rsquo; divides the data in the vector &lsquo;x&rsquo;
into the groups defined by &lsquo;f&rsquo;.  The replacement
forms replace values corresponding to such a division.
Here are listed &lsquo;split&rsquo; methods defined for Time
objects defined in the timetools package
<code><a href="#topic+POSIXst">POSIXst</a></code>, <code><a href="#topic+POSIXcti">POSIXcti</a></code>, etc.). See
sections below for complete list of methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'ANY,POSIXctp'
split(x, f, drop = FALSE, ...)
  ## S4 method for signature 'ANY,POSIXcti'
split(x, f, drop = FALSE, ...)
  ## S4 method for signature 'ANY,POSIXst'
split(x, f, drop = FALSE, ...)

  ## S4 method for signature 'TimeIntervalDataFrame,TimeIntervalDataFrame'
split(x, f, ..., split.x=FALSE, keep.f=TRUE)
  ## S4 method for signature 'TimeIntervalDataFrame,POSIXcti'
split(x, f, ..., split.x=FALSE)
  ## S4 method for signature 'TimeIntervalDataFrame,POSIXctp'
split(x, f, ...,  split.x=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_+3A_x">x</code></td>
<td>
<p>data frame containing values to be divided into groups.
TimeIntervalDataFrame as data.frame.</p>
</td></tr>
<tr><td><code id="split_+3A_f">f</code></td>
<td>
<p>Can be of different kind. Is used to defined the grouping.
See details below.</p>
</td></tr>
<tr><td><code id="split_+3A_drop">drop</code></td>
<td>
<p>logical indicating if levels that do not
occur should be dropped (if <code>f</code> is a <code>factor</code>
or a list).</p>
</td></tr>
<tr><td><code id="split_+3A_...">...</code></td>
<td>
<p>further potential arguments passed to
methods.</p>
</td></tr>
<tr><td><code id="split_+3A_split.x">split.x</code></td>
<td>
<p>logical indicating if data in <code>x</code>
that are over several intervals or not completely included in
one interval of <code>f</code> must be 'cut' to
fit to new intervals (TRUE) or ignored (FALSE).</p>
</td></tr>
<tr><td><code id="split_+3A_keep.f">keep.f</code></td>
<td>
<p>logical indicating if <code>f</code> values must be kept
on the resulting list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each new split method defined in
<code><a href="#topic+timetools">timetools</a></code> a short description is given
there.
</p>


<h3>Value</h3>

<p>The value returned from ‘split’ is a list of vectors
containing the values for the groups.  The components of
the list are named by the levels of <code>f</code> (after converting
to a factor). The class of each element of the list is the one 
of the initial <code>x</code> structure.
</p>


<h3>Split over POSIX*t* objects</h3>

<p>Since POSIXst, POSIXctp and POSIXcti objects are similar to vector
it must be possible to split other type of objects against those ones.
</p>

<dl>
<dt>split(x, '<a href="#topic+POSIXctp">POSIXctp</a>', drop=FALSE, ...)</dt><dd><p>'POSIXctp' is first
cast as character (using format) and then the split is done.</p>
</dd>
<dt>split(x, '<a href="#topic+POSIXcti">POSIXcti</a>', drop=FALSE, ...)</dt><dd><p>'POSIXcti' is first
cast as character (using format) and then the split is done.
The <code>...</code> argument is used to specify the format if needed.</p>
</dd>
<dt>split(x, '<a href="#topic+POSIXst">POSIXst</a>', drop=FALSE, ...)</dt><dd><p>'POSIXst' is first
cast as numeric and then the split is done.</p>
</dd>
</dl>



<h3>split('TimeIntervalDataFrame', 'TimeIntervalDataFrame', ..., split.x = FALSE, keep.f = TRUE)</h3>

<p>Split a TimeIntervalDataFrame into another TimeIntervalDataFrame.
</p>
<p>The method takes each time interval of the first TimeIntervalDataFrame
(TitDF) and searches with which time intervals of the second it
intersects.
</p>
<p>Each time interval of the first TItDF can intersect with
none, one or several time intervals of the second TItDF. The arguments
'split.x' is defined to tell the method what to do : </p>

<ul>
<li><p>if the time interval in the first TItDF (ti1) doesn't match
any in the second TItDF, nothing to do
</p>
</li>
<li><p>if it (ti1) matches one in the second TItDF (ti2) and is
included inside it, it (ti1) is entirely taken in the final result
</p>
</li>
<li><p>if it (ti1) intersects one and only one (ti2) inside the second
TItDF, (ti1) is truncated to be included inside (ti2) if 'split.x' is
TRUE and (ti1) is removed if 'split.x' is FALSE
</p>
</li>
<li><p>if it (ti1) is over several time intervals of the second TItDF
(ti2.a, ti2.b, etc.) :</p>

<ul>
<li><p>if 'split.x' is TRUE, (ti1) is truncated into each ti2.x to be
included inside each one
</p>
</li>
<li><p>if 'split.x' is FALSE, (ti1) is removed.
</p>
</li></ul>


</li></ul>



<h3>split('TimeIntervalDataFrame', 'POSIXctp', ..., split.x = FALSE)</h3>

<p>Split a TimeIntervalDataFrame into a time period (of length 1).
A TimeIntervalDataFrame is created (cf TimeIntervalDataFrame
constructor) and the the above method is called.
</p>


<h3>split('TimeIntervalDataFrame', 'POSIXcti', ..., split.x = FALSE)</h3>

<p>Split a TimeIntervalDataFrame into time intervals (POSIXcti).
It is exactly the same as splitting a TimeIntervalDataFrame into
another except that 'f' has not data.
</p>
<p>So a TimeIntervalDataFrame is created according to 'f' and the 
the above method is called.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+split">split</a></code>,
<code><a href="#topic+TimeIntervalDataFrame-class">TimeIntervalDataFrame-class</a></code>,
<code><a href="#topic+POSIXcti">POSIXcti</a></code>,
<code><a href="#topic+POSIXst-class">POSIXst-class</a></code>, <code><a href="#topic+POSIXctp-class">POSIXctp-class</a></code>
</p>

<hr>
<h2 id='SubtimeDataFrame'>Class <code>"SubtimeDataFrame"</code></h2><span id='topic+SubtimeDataFrame-class'></span><span id='topic+SubtimeDataFrame'></span><span id='topic+as.SubtimeDataFrame'></span><span id='topic++24+2CSubtimeDataFrame-method'></span><span id='topic++24+3C-+2CSubtimeDataFrame-method'></span><span id='topic++5B.SubtimeDataFrame'></span><span id='topic++5B+3C-.SubtimeDataFrame'></span><span id='topic++5B+5B+2CSubtimeDataFrame-method'></span><span id='topic++5B+5B+3C-.SubtimeDataFrame'></span><span id='topic+split.SubtimeDataFrame'></span><span id='topic+merge.SubtimeDataFrame'></span><span id='topic+lapply+2CSubtimeDataFrame-method'></span><span id='topic+timezone+2CSubtimeDataFrame-method'></span><span id='topic+when+2CSubtimeDataFrame-method'></span><span id='topic+unit.SubtimeDataFrame'></span><span id='topic+of.SubtimeDataFrame'></span><span id='topic+dim+2CSubtimeDataFrame-method'></span><span id='topic+length+2CSubtimeDataFrame-method'></span><span id='topic+names+2CSubtimeDataFrame-method'></span><span id='topic+names+3C-+2CSubtimeDataFrame-method'></span><span id='topic+ncol+2CSubtimeDataFrame-method'></span><span id='topic+nrow+2CSubtimeDataFrame-method'></span><span id='topic+row.names.SubtimeDataFrame'></span><span id='topic+row.names+3C-.SubtimeDataFrame'></span><span id='topic+print.SubtimeDataFrame'></span><span id='topic+summary.SubtimeDataFrame'></span><span id='topic+head.SubtimeDataFrame'></span><span id='topic+tail.SubtimeDataFrame'></span><span id='topic+show+2CSubtimeDataFrame-method'></span><span id='topic+plot.SubtimeDataFrame'></span><span id='topic+points.SubtimeDataFrame'></span><span id='topic+lines.SubtimeDataFrame'></span><span id='topic+barplot.SubtimeDataFrame'></span><span id='topic+as.SubtimeDataFrame'></span><span id='topic+as.SubtimeDataFrame.TimeInstantDataFrame'></span><span id='topic+as.SubtimeDataFrame.TimeIntervalDataFrame'></span>

<h3>Description</h3>

<p>Class to hold subtime data such a day of week, month of year, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SubtimeDataFrame(when, data = NULL, ...)

as.SubtimeDataFrame(x, unit, of, ...)
  ## S3 method for class 'TimeInstantDataFrame'
as.SubtimeDataFrame(x, unit, of, FUN=NULL, ...)
  ## S3 method for class 'TimeIntervalDataFrame'
as.SubtimeDataFrame(x, unit, of, FUN=NULL, cursor=NULL, ...)

  ## S4 method for signature 'SubtimeDataFrame'
x$name
  ## S4 replacement method for signature 'SubtimeDataFrame'
x$name &lt;- value
  ## S3 method for class 'SubtimeDataFrame'
x[i, j, drop=FALSE]
  ## S3 replacement method for class 'SubtimeDataFrame'
x[i, j] &lt;- value
  ## S4 method for signature 'SubtimeDataFrame'
x [[i, j, ...]]
  ## S3 replacement method for class 'SubtimeDataFrame'
x[[i, j]] &lt;- value

  ## S3 method for class 'SubtimeDataFrame'
merge(x, y, by, all=TRUE, sort=FALSE, ...)
  ## S3 method for class 'SubtimeDataFrame'
split(x, f, drop=FALSE, ...)
  ## S4 method for signature 'SubtimeDataFrame'
lapply(X, FUN, ...)

  ## S4 method for signature 'SubtimeDataFrame'
timezone(object)
  ## S4 method for signature 'SubtimeDataFrame'
when(x, ...)
  ## S3 method for class 'SubtimeDataFrame'
unit(x, ...)
  ## S3 method for class 'SubtimeDataFrame'
of(x, ...)

  ## S4 method for signature 'SubtimeDataFrame'
dim(x)
  ## S4 method for signature 'SubtimeDataFrame'
length(x)
  ## S4 method for signature 'SubtimeDataFrame'
names(x)
  ## S4 replacement method for signature 'SubtimeDataFrame'
names(x) &lt;- value
  ## S4 method for signature 'SubtimeDataFrame'
ncol(x)
  ## S4 method for signature 'SubtimeDataFrame'
nrow(x)
  ## S3 method for class 'SubtimeDataFrame'
row.names(x)
  ## S3 replacement method for class 'SubtimeDataFrame'
row.names(x) &lt;- value

  ## S3 method for class 'SubtimeDataFrame'
print(x, ...)
  ## S3 method for class 'SubtimeDataFrame'
summary(object, ...)
  ## S3 method for class 'SubtimeDataFrame'
head(x, ...)
  ## S3 method for class 'SubtimeDataFrame'
tail(x, ...)
  ## S4 method for signature 'SubtimeDataFrame'
show(object)

  ## S3 method for class 'SubtimeDataFrame'
plot(
    x, y=NULL, type='p', lty=1:6, lwd=1, pch=1:25, col=NULL,
    xlim=NULL, ylim=NULL, log='', main='', sub='', xlab='', ylab='',
    ann=par('ann'), axes=TRUE, asp=NA, as.is=TRUE, format=NULL, ...)
  ## S3 method for class 'SubtimeDataFrame'
points(
    x, y=NULL, type='p', lty=1:6, lwd=1, pch=1:25, col=NULL, as.is=TRUE, ...)
  ## S3 method for class 'SubtimeDataFrame'
lines(
    x, y=NULL, type='l', lty=1:6, lwd=1, pch=1:25, col=NULL, as.is=TRUE, ...)
  ## S3 method for class 'SubtimeDataFrame'
barplot(height, format='', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SubtimeDataFrame_+3A_when">when</code></td>
<td>
<p><code><a href="#topic+POSIXst">POSIXst</a></code>.</p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_data">data</code></td>
<td>
<p>a data.frame with as much rows as needed for the created object. Can
be <code>NULL</code> (hence the data.frame has zero column and as much rows
as needed).</p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_x">x</code></td>
<td>
<p>object to convert to a TimeInstantDataFrame or
SubtimeDataFrame object (to modify, to extract or to test)</p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_unit">unit</code></td>
<td>
<p>indicates the subtime part to extract
('year', 'month', 'day', 'hour', 'minute', 'second').</p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_of">of</code></td>
<td>
<p>used to specify the main period from wich the
is to extract ('year', 'month', 'day', 'hour', 'minute').
Not used for &lsquo;unit in c('year', 'month')&rsquo;.</p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_fun">FUN</code></td>
<td>
<p>function to use for the agregation (if wanted,
see &lsquo;details&rsquo;)</p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_cursor">cursor</code></td>
<td>
<p>For TimeIntervalDataFrame, it indicates
where the TimeInstant must be taken. If <code>0</code>, start
of each intervals is taken as instant ; if <code>1</code> end
of each intervals is taken as instant.  Any other value
will determine a weigthed instant between start and end
(actually, value higher than 1 or lower than 0 will give
instant outside this range).</p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_i">i</code></td>
<td>
<p>indices specifying elements to extract or replace. (See
<code><a href="base.html#topic+Extract">Extract</a></code>)</p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_j">j</code></td>
<td>
<p>indices specifying elements to extract or replace. (See
<code><a href="base.html#topic+Extract">Extract</a></code>)</p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_name">name</code></td>
<td>
<p>A litteral character string or a name. (See
<code><a href="base.html#topic+Extract">Extract</a></code>)</p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_drop">drop</code></td>
<td>
<p>Used for compatibility with data.frame methods.</p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_value">value</code></td>
<td>
<p>New value for the object designated (data.frame, names, row.names,
etc.).</p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_y">y</code></td>
<td>
<p>SubtimeDataFrame to merge with x</p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_all">all</code></td>
<td>
<p>logical; see <code><a href="base.html#topic+merge">merge</a></code></p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_by">by</code></td>
<td>
<p>specifications of the columns used for merging.</p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_sort">sort</code></td>
<td>
<p>logical; if TRUE the resulting merged SubtimeDataFrame is 
ordered according to 'when' values.</p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_f">f</code></td>
<td>
<p>a 'factor' in the sense that ‘as.factor(f)’ defines the
grouping, or a list of such factors in which case their
interaction is used for the grouping. See <code><a href="#topic+split">split</a></code>.</p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_x">X</code></td>
<td>
<p>a SubtimeDataFrame on which the FUN must be applied.</p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_object">object</code></td>
<td>
<p>SubtimeDataFrame object (to modify, to extract or to test)</p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_type">type</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_lty">lty</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_lwd">lwd</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_pch">pch</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_col">col</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_xlim">xlim</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_ylim">ylim</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_log">log</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_main">main</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_sub">sub</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_xlab">xlab</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_ylab">ylab</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_ann">ann</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_axes">axes</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_asp">asp</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_as.is">as.is</code></td>
<td>
<p>should data be represented incrementally (the first row
is given an x-value of 1, the second of 2, ... the last of n)(TRUE) or
should data be grouped by their subtime (all value corresponding
to monday are drawn at an x-value of 1) (FALSE) ?</p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_height">height</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+barplot">barplot</a></code></p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_format">format</code></td>
<td>
<p>for barplot see <code><a href="graphics.html#topic+barplot">barplot</a></code>, 
otherwise a string to format the x-labels according to the format
method of POSIXst objects (see 'Text representation' of <code><a href="#topic+POSIXst">POSIXst</a></code>).</p>
</td></tr>
<tr><td><code id="SubtimeDataFrame_+3A_...">...</code></td>
<td>
<p>More arguments.</p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>Formally, the class consists of a <code><a href="base.html#topic+data.frame">data.frame</a></code>
and, for each row, a <code><a href="#topic+POSIXst">POSIXst</a></code> (or subtime).
This class is provided to deal with subtime data. This class
is compatible
with <code><a href="#topic+TimeIntervalDataFrame-class">TimeIntervalDataFrame</a></code>
and <code><a href="#topic+TimeIntervalDataFrame-class">TimeInstantDataFrame</a></code>.
</p>
<p>The construction of the class allows to manipulate objects as if they
were data.frame (see &lsquo;Access to data&rsquo; and &lsquo;Access to data properties&rsquo;).
Several functions are also available to access to time properties (see &lsquo;Access
to time properties&rsquo;).
</p>
<p>Methods are also available to facilitate the representations of instances of that class :
see &lsquo;graphic representation&rsquo; and &lsquo;text representation&rsquo;.
</p>
<p>Finally, some specific methods allow to easily deal with agregation of data over time
properties (day, hour, week, special or specific time).
</p>


<h3>SubtimeDataFrame constructors</h3>

<p>Objects can be created by calls of the form
</p>

<ul>
<li> <p><code>new("SubtimeDataFrame", ...)</code> ... argument must be replaced
by named arguments coresponding to slots of a SubtimeDataFrame (see below).
See also <code><a href="methods.html#topic+new">new</a></code>.
</p>
</li>
<li> <p><code>SubtimeDataFrame (when, data=NULL, ...)</code>
Arguments of the function correspond to object slots.
</p>
</li>
<li><p><code>as.SubtimeDataFrame (from, representation, cursor=NULL, FUN=mean, ...)</code>
Converting object to SubtimeDataFrame.
Conversion from a TimeIntervalDataFrame to a
SubtimeDataFrame can be direct or after agregation.
</p>
<p>For a direct conversion (where date are only replaced by
the desired subtime), FUN must be NULL.
</p>
<p>For an agregateed conversion, the function to use must be
indicated by the FUN arg and all arguments to pass to
this function can be given (namely).
</p>
</li></ul>



<h3>Slots</h3>


<dl>
<dt><code>when</code>:</dt><dd><p>Object of class <code>"POSIXst"</code>  
corresponding to the instant of each row of
the <code>data.frame</code>.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"data.frame"</code>  data contained
by the object.</p>
</dd>
</dl>



<h3>Accessing to and manipulating data</h3>

<p>The SubtimeDataFrame class is defined to works like the data.frame class
with the difference that a subtime (<code><a href="#topic+POSIXst">POSIXst</a></code>) is
attached to each rows of the data.frame. Thus to access and manipulate
data of a TimeInstantDataFrame the following methods are defined : 
'$', '$&lt;-', '[', '[&lt;-', '[[', '[[&lt;-'. See <code><a href="base.html#topic+Extract">Extract</a></code> for 
details.
</p>
<p>Other methods have been defined to allow some operations over
TimeInstantDataFrame :
</p>

<ul>
<li><p>  merge to join two (or more) SubtimeDataFrame (see 
<code><a href="base.html#topic+merge">merge</a></code>),
</p>
</li>
<li><p> a SubtimeDataFrame can be splitted exactly the same way that
a data.frame can (see <code><a href="base.html#topic+split">split</a></code> in the base
package),
</p>
</li>
<li><p> a function can be applied over each column of a TimeIntervalDataFrame
via the lapply function provided that the function return one value (in
this case the resulting value is a <code><a href="#topic+TimeIntervalDataFrame">TimeIntervalDataFrame</a></code>
beginning at the first instant of the object and ending at the latest one),
or as much values as the number of rows of the object (in this case the
SubtimeDataFrame given in argument in returned with the new values
calculated).
</p>
</li></ul>

<p>Because a SubtimeDataFrame works more or less like a data.frame, 
the following methods work on a SubtimeDataFrame :
<code><a href="base.html#topic+dim">dim</a></code>,
<code><a href="base.html#topic+length">length</a></code>,
<code><a href="base.html#topic+names">names</a></code>,
<code><a href="base.html#topic+names+3C-">names&lt;-</a></code>,
<code><a href="base.html#topic+ncol">ncol</a></code>,
<code><a href="base.html#topic+nrow">nrow</a></code>,
<code><a href="base.html#topic+row.names">row.names</a></code>,
<code><a href="base.html#topic+row.names+3C-">row.names&lt;-</a></code>.
</p>


<h3>Access to time properties</h3>

<p>A SubtimeDataFrame can be tested for a few time properties :
</p>

<dl>
<dt>timezone</dt><dd><p>gives or sets the timezone of the SubtimeDataFrame ;</p>
</dd>
<dt>when</dt><dd><p>returns a POSIXst object with the time instant of the 
SubtimeDataFrame.</p>
</dd>
<dt>unit</dt><dd><p>returns the unit of the time instant of the 
SubtimeDataFrame.</p>
</dd>
<dt>of</dt><dd><p>returns the 'of' of the time instant of the 
SubtimeDataFrame.</p>
</dd>
</dl>



<h3>Graphic representation</h3>

<p>To plot a <code>SubtimeDataFrame</code> available functions are
<code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+lines">lines</a></code>,
<code><a href="graphics.html#topic+points">points</a></code> and <code><a href="graphics.html#topic+barplot">barplot</a></code>.
</p>
<p>These functions works more or less like their generic definition.
</p>


<h3>Text representation</h3>

<p>To represent a <code>SubtimeDataFrame</code> available functions are
<code><a href="base.html#topic+print.data.frame">print</a></code>,
<code><a href="base.html#topic+data.frame">summary</a></code>, <code><a href="utils.html#topic+head">head</a></code>,
<code><a href="utils.html#topic+tail">tail</a></code> and <code><a href="methods.html#topic+show">show</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TimeInstantDataFrame">TimeInstantDataFrame</a></code>, <code><a href="#topic+TimeIntervalDataFrame">TimeIntervalDataFrame</a></code>,
<code><a href="#topic+POSIXst">POSIXst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("SubtimeDataFrame")
</code></pre>

<hr>
<h2 id='tapply'>Apply a Function Over a time properties</h2><span id='topic+tapply'></span><span id='topic+tapply+2CTimeIntervalDataFrame+2CPOSIXcti-method'></span><span id='topic+tapply+2CTimeIntervalDataFrame+2CPOSIXctp-method'></span><span id='topic+tapply+2CTimeIntervalDataFrame+2CTimeIntervalDataFrame-method'></span>

<h3>Description</h3>

<p>Apply a function over a Time*DataFrame that is first
splitted into several sets according to time properties
specified by INDEX.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'TimeIntervalDataFrame,TimeIntervalDataFrame'
tapply(X, INDEX, FUN, ...,
       min.coverage=1, weights.arg=NULL, merge.X=TRUE, split.X=FALSE,
       keep.INDEX=TRUE,default=NA, simplify=TRUE)

  ## S4 method for signature 'TimeIntervalDataFrame,POSIXctp'
tapply(X, INDEX, FUN, ...,
       min.coverage=1, weights.arg=NULL, merge.X=TRUE, split.X=FALSE,
      default=NA, simplify=TRUE)

  ## S4 method for signature 'TimeIntervalDataFrame,POSIXcti'
tapply(X, INDEX, FUN, ...,
       min.coverage=1, weights.arg=NULL, merge.X=TRUE, split.X=FALSE,
      default=NA, simplify=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tapply_+3A_x">X</code></td>
<td>
<p>a <code><a href="#topic+TimeIntervalDataFrame">TimeIntervalDataFrame</a></code> or a
<code><a href="#topic+TimeInstantDataFrame">TimeInstantDataFrame</a></code></p>
</td></tr>
<tr><td><code id="tapply_+3A_index">INDEX</code></td>
<td>
<p>an object corresponding to or containing a
time properties. Classes available depend on X. See
sections below to know all (X, INDEX) combination
defined.</p>
</td></tr>
<tr><td><code id="tapply_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied.</p>
</td></tr>
<tr><td><code id="tapply_+3A_...">...</code></td>
<td>
<p>optional arguments to 'FUN'.</p>
</td></tr>
<tr><td><code id="tapply_+3A_simplify">simplify</code></td>
<td>
<p>if FALSE a list of
&lsquo;Time*DataFrame&rsquo; is returned ; if TRUE
&lsquo;tapply&rsquo; try to reduce the list to a single
&lsquo;Time*DataFrame&rsquo;.</p>
</td></tr>
<tr><td><code id="tapply_+3A_default">default</code></td>
<td>
<p>argument inherited from the <span class="pkg">base</span> function,
currently unused; see <code><a href="base.html#topic+tapply">tapply</a></code>.</p>
</td></tr>
<tr><td><code id="tapply_+3A_min.coverage">min.coverage</code></td>
<td>
<p>a numeric between 0 and 1 indicating
the percentage of valid values over each interval to
allow an aggregation. NA is returned if the percentage is
not reach. In that configuration (min.coverage between 0
and 1, overlapping intervals are not allowed). When a
function (FUN) has a na.rm argument, the na.rm=TRUE
behaviour is met if na.rm is set to TRUE and min.coverage
to 0 (zero) ; the na.rm=FALSE behaviour is met if na.rm
is set to FALSE whatever is the value of min.coverage. If
min.coverage is set to NA, time coverage of the resulting
interval is not checked. Moreover, overlapping of X
intervals is not checked. Thus the aggregation is done
according to &lsquo;weights.arg&rsquo; argument (if given).</p>
</td></tr>
<tr><td><code id="tapply_+3A_weights.arg">weights.arg</code></td>
<td>
<p>if FUN has a &lsquo;weight&rsquo; argument,
this parameter must be a character naming the weight
argument. For instance, if FUN is
<code><a href="stats.html#topic+weighted.mean">weighted.mean</a></code>, then weights.arg is
<code>'w'</code>.</p>
</td></tr>
<tr><td><code id="tapply_+3A_merge.x">merge.X</code></td>
<td>
<p>logical indicating if data in &lsquo;X&rsquo;
can be merged over interval of the new time support.</p>
</td></tr>
<tr><td><code id="tapply_+3A_split.x">split.X</code></td>
<td>
<p>logical indicating if data in &lsquo;X&rsquo;
that are over several intervals of 'INDEX' must be 'cut'
to fit to new intervals (TRUE) or ignored (FALSE).</p>
</td></tr>
<tr><td><code id="tapply_+3A_keep.index">keep.INDEX</code></td>
<td>
<p>logical indicating if INDEX values must
be kept on the resulting list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are equivalent to old
<code><a href="#topic+changeSupport">changeSupport</a></code> methods. Instead of having
the core splitting algorithm in it, it uses the
<code><a href="#topic+split">split</a></code> methods. Be aware that default
parametres values between the two families
(&lsquo;changeSupport&rsquo; and &lsquo;tapply&rsquo;) are not
necessarily the same.
</p>
<p>Users are encouraged to use &lsquo;tapply&rsquo; instead of
&lsquo;changeSupport&rsquo; since new versions of
&lsquo;changeSupport&rsquo; are only wrappers to tapply.
</p>


<h3>signature(TimeIntervalDataFrame, TimeIntervalDataFrame)</h3>

<p>split <code><a href="#topic+TimeIntervalDataFrame">TimeIntervalDataFrame</a></code> over another
<code><a href="#topic+TimeIntervalDataFrame">TimeIntervalDataFrame</a></code> and then apply a
function over each elements of the list.
</p>


<h3>signature(TimeIntervalDataFrame, POSIXctp)</h3>

<p>split a <code><a href="#topic+TimeIntervalDataFrame">TimeIntervalDataFrame</a></code> against
regular time intervals with a period defined by INDEX (a
<code><a href="#topic+POSIXctp">POSIXctp</a></code>). Then a function is applied over
each elements of the list.
</p>


<h3>signature(TimeIntervalDataFrame, POSIXcti)</h3>

<p>split <code><a href="#topic+TimeIntervalDataFrame">TimeIntervalDataFrame</a></code> against
specified intervals (<code><a href="#topic+POSIXcti">POSIXcti</a></code>). and then
apply a function over each elements of the list.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+tapply">tapply</a></code>,
<code><a href="#topic+TimeIntervalDataFrame-class">TimeIntervalDataFrame-class</a></code>,
<code><a href="#topic+TimeInstantDataFrame-class">TimeInstantDataFrame-class</a></code>,
<code><a href="#topic+SubtimeDataFrame-class">SubtimeDataFrame-class</a></code>,
<code><a href="#topic+changeSupport">changeSupport</a></code>,
<code><a href="#topic+POSIXcti-class">POSIXcti-class</a></code>,
<code><a href="#topic+POSIXst-class">POSIXst-class</a></code>, <code><a href="#topic+POSIXctp-class">POSIXctp-class</a></code>
</p>

<hr>
<h2 id='TimeInstantDataFrame'>Class <code>"TimeInstantDataFrame"</code></h2><span id='topic+TimeInstantDataFrame-class'></span><span id='topic+TimeInstantDataFrame'></span><span id='topic+RegularTimeInstantDataFrame'></span><span id='topic++24+2CTimeInstantDataFrame-method'></span><span id='topic++24+3C-+2CTimeInstantDataFrame-method'></span><span id='topic++5B.TimeInstantDataFrame'></span><span id='topic++5B+3C-.TimeInstantDataFrame'></span><span id='topic++5B+5B+2CTimeInstantDataFrame-method'></span><span id='topic++5B+5B+3C-.TimeInstantDataFrame'></span><span id='topic+Ops+2CTimeInstantDataFrame+2Cnumeric-method'></span><span id='topic+Ops+2Cnumeric+2CTimeInstantDataFrame-method'></span><span id='topic+rbind.TimeInstantDataFrame'></span><span id='topic+merge.TimeInstantDataFrame'></span><span id='topic+split.TimeInstantDataFrame'></span><span id='topic+lapply+2CTimeInstantDataFrame-method'></span><span id='topic+regular+2CTimeInstantDataFrame-method'></span><span id='topic+timezone+2CTimeInstantDataFrame-method'></span><span id='topic+timezone+3C-+2CTimeInstantDataFrame-method'></span><span id='topic+when+2CTimeInstantDataFrame-method'></span><span id='topic+dim+2CTimeInstantDataFrame-method'></span><span id='topic+length+2CTimeInstantDataFrame-method'></span><span id='topic+names+2CTimeInstantDataFrame-method'></span><span id='topic+names+3C-+2CTimeInstantDataFrame-method'></span><span id='topic+ncol+2CTimeInstantDataFrame-method'></span><span id='topic+nrow+2CTimeInstantDataFrame-method'></span><span id='topic+row.names.TimeInstantDataFrame'></span><span id='topic+row.names+3C-.TimeInstantDataFrame'></span><span id='topic+print.TimeInstantDataFrame'></span><span id='topic+summary.TimeInstantDataFrame'></span><span id='topic+head.TimeInstantDataFrame'></span><span id='topic+tail.TimeInstantDataFrame'></span><span id='topic+show+2CTimeInstantDataFrame-method'></span><span id='topic+plot.TimeInstantDataFrame'></span><span id='topic+points.TimeInstantDataFrame'></span><span id='topic+lines.TimeInstantDataFrame'></span><span id='topic+barplot.TimeInstantDataFrame'></span><span id='topic+as.TimeInstantDataFrame'></span><span id='topic+as.TimeInstantDataFrame.TimeIntervalDataFrame'></span>

<h3>Description</h3>

<p>Class to hold time data that ARE 'instantaneous'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  TimeInstantDataFrame(when, timezone = "UTC", data = NULL, sort=FALSE, ...)

  as.TimeInstantDataFrame(from, ...)
  ## S3 method for class 'TimeIntervalDataFrame'
as.TimeInstantDataFrame(from, cursor = NULL, ...)

  RegularTimeInstantDataFrame(from, to, by, timezone = "UTC", data = NULL)

  ## S4 method for signature 'TimeInstantDataFrame'
x$name
  ## S4 replacement method for signature 'TimeInstantDataFrame'
x$name &lt;- value
  ## S3 method for class 'TimeInstantDataFrame'
x[i, j, drop=FALSE]
  ## S3 replacement method for class 'TimeInstantDataFrame'
x[i, j] &lt;- value
  ## S4 method for signature 'TimeInstantDataFrame'
x [[i, j, ...]]
  ## S3 replacement method for class 'TimeInstantDataFrame'
x[[i, j]] &lt;- value

  ## S3 method for class 'TimeInstantDataFrame'
rbind(...)
  ## S3 method for class 'TimeInstantDataFrame'
merge(x, y, by, all=TRUE, tz='UTC', sort=TRUE, ...)
  ## S3 method for class 'TimeInstantDataFrame'
split(x, f, drop=FALSE, ...)
  ## S4 method for signature 'TimeInstantDataFrame'
lapply(X, FUN, ...)

  ## S4 method for signature 'TimeInstantDataFrame'
regular(x, ...)
  ## S4 method for signature 'TimeInstantDataFrame'
timezone(object)
  ## S4 replacement method for signature 'TimeInstantDataFrame'
timezone(object) &lt;- value
  ## S4 method for signature 'TimeInstantDataFrame'
when(x, ...)

  ## S4 method for signature 'TimeInstantDataFrame'
dim(x)
  ## S4 method for signature 'TimeInstantDataFrame'
length(x)
  ## S4 method for signature 'TimeInstantDataFrame'
names(x)
  ## S4 replacement method for signature 'TimeInstantDataFrame'
names(x) &lt;- value
  ## S4 method for signature 'TimeInstantDataFrame'
ncol(x)
  ## S4 method for signature 'TimeInstantDataFrame'
nrow(x)
  ## S3 method for class 'TimeInstantDataFrame'
row.names(x)
  ## S3 replacement method for class 'TimeInstantDataFrame'
row.names(x) &lt;- value

  ## S3 method for class 'TimeInstantDataFrame'
print(x, tz=NULL, ...)
  ## S3 method for class 'TimeInstantDataFrame'
summary(object, ...)
  ## S3 method for class 'TimeInstantDataFrame'
head(x, tz, ...)
  ## S3 method for class 'TimeInstantDataFrame'
tail(x, tz, ...)
  ## S4 method for signature 'TimeInstantDataFrame'
show(object)

  ## S3 method for class 'TimeInstantDataFrame'
plot(x, y=NULL, type="p",
	lty=1:6, lwd=1, pch=1:25, col=NULL,
	xlim=NULL, ylim=NULL, log, main, sub, xlab, ylab,
	ann=par("ann"), axes=TRUE, asp=NA, ...)
  ## S3 method for class 'TimeInstantDataFrame'
points(x, y=NULL, type="p",
	lty=1:6, lwd=1, pch=1:25, col=NULL, ...)
  ## S3 method for class 'TimeInstantDataFrame'
lines(x, y=NULL, type="l",
	lty=1:6, lwd=1, pch=1:25, col=NULL, ...)
  ## S3 method for class 'TimeInstantDataFrame'
barplot(height, format='', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TimeInstantDataFrame_+3A_when">when</code></td>
<td>
<p>POSIXct or character representing a time with a valid format (see
<code><a href="base.html#topic+as.POSIXct">POSIXct</a></code>). It gives the instant of each
row.</p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_timezone">timezone</code></td>
<td>
<p>character representing a valid timezone (see
<code><a href="base.html#topic+timezone">timezone</a></code>).</p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_data">data</code></td>
<td>
<p>a data.frame with as much rows as needed for the created object. Can
be <code>NULL</code> (hence the data.frame has zero column and as much rows
as needed).</p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_from">from</code></td>
<td>

<dl>
<dt>as.TimeInstantDataFrame</dt><dd><p>object to convert to a TimeInstantDataFrame</p>
</dd>
<dt>RegularTimeInstantDataFrame</dt><dd>
<p>POSIXct or character representing a time with a valid format (see
<code><a href="base.html#topic+as.POSIXct">POSIXct</a></code>). It represents the start of the
object.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_cursor">cursor</code></td>
<td>
<p>To convert TimeIntervalDataFrame,
it indicates where the TimeInstant
must be taken. If <code>0</code>, start of each intervals is taken as
instant ; if <code>1</code> end of each intervals is taken as instant.
Any other value will determine a weigthed instant between start and
end (actually, value higher than 1 or lower than 0 will give instant
outside this range).</p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_to">to</code></td>
<td>
<p>POSIXct or character representing a time with a valid format (see
<code><a href="base.html#topic+as.POSIXct">POSIXct</a></code>). It represents the end of the
object. If missing, its value is deduced from &lsquo;from&rsquo;,
&lsquo;by&rsquo; and &lsquo;data&rsquo;.</p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_by">by</code></td>
<td>

<dl>
<dt>RegularTimeInstantDataFrame</dt><dd><p>a <code><a href="#topic+POSIXctp">POSIXctp</a></code> object indicating
the increment to use between instants of the object.</p>
</dd>
<dt>merge</dt><dd><p>specifications of the columns used for merging.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_x">x</code></td>
<td>
<p>TimeInstantDataFrame object (to modify, to extract or to test)</p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_i">i</code></td>
<td>
<p>indices specifying elements to extract or replace. (See
<code><a href="base.html#topic+Extract">Extract</a></code>)</p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_j">j</code></td>
<td>
<p>indices specifying elements to extract or replace. (See
<code><a href="base.html#topic+Extract">Extract</a></code>)</p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_name">name</code></td>
<td>
<p>A litteral character string or a name. (See
<code><a href="base.html#topic+Extract">Extract</a></code>)</p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_drop">drop</code></td>
<td>
<p>Used for compatibility with data.frame methods.</p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_value">value</code></td>
<td>
<p>New value for the object designated (data.frame, names, row.names,
etc.).</p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_y">y</code></td>
<td>
<p>TimeInstantDataFrame to merge with x</p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_all">all</code></td>
<td>
<p>logical; see <code><a href="base.html#topic+merge">merge</a></code></p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_tz">tz</code></td>
<td>
<p>character representing a valid timezone (see
<code><a href="base.html#topic+timezone">timezone</a></code>).</p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_sort">sort</code></td>
<td>
<p>logical; if TRUE the resulting built/merged TimeInstantDataFrame is 
ordered according to 'when' values.</p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_f">f</code></td>
<td>
<p>a 'factor' in the sense that ‘as.factor(f)’ defines the
grouping, or a list of such factors in which case their
interaction is used for the grouping. See <code><a href="#topic+split">split</a></code>.</p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_x">X</code></td>
<td>
<p>a TimeInstantDataFrame on which the FUN must be applied.</p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_fun">FUN</code></td>
<td>
<p>function to apply over eahc columns of X.</p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_object">object</code></td>
<td>
<p>TimeInstantDataFrame object (to modify, to extract or to test)</p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_type">type</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_lty">lty</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_lwd">lwd</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_pch">pch</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_col">col</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_xlim">xlim</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_ylim">ylim</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_log">log</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_main">main</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_sub">sub</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_xlab">xlab</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_ylab">ylab</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_ann">ann</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_axes">axes</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_asp">asp</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_height">height</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+barplot">barplot</a></code></p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_format">format</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+barplot">barplot</a></code></p>
</td></tr>
<tr><td><code id="TimeInstantDataFrame_+3A_...">...</code></td>
<td>
<p>More arguments.</p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>Formally, the class consists of a <code><a href="base.html#topic+data.frame">data.frame</a></code>
and, for each row, a <code><a href="base.html#topic+POSIXct">POSIXct</a></code>.
This class is provided to deal with punctual time data. Many 
of such classes are defined in other packages. This one is defined
mainly to provide a &lsquo;punctual&rsquo; class compatible
with <code><a href="#topic+TimeIntervalDataFrame-class">TimeIntervalDataFrame</a></code>
and <code><a href="#topic+SubtimeDataFrame-class">SubtimeDataFrame</a></code>.
</p>
<p>The construction of the class allows to manipulate objects as if they
were data.frame (see &lsquo;Access to data&rsquo; and &lsquo;Access to data
properties&rsquo;).
</p>


<h3>Slots</h3>


<dl>
<dt><code>instant</code>:</dt><dd><p>Object of class <code>"POSIXct"</code> corresponding to
the instant of each row of the <code>data.frame</code>.</p>
</dd>
<dt><code>timezone</code>:</dt><dd><p>Object of class <code>"character"</code> indicating the
timezone of data both for representation and calculation.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"data.frame"</code>  data contained by
the object.</p>
</dd>
</dl>



<h3>TimeInstantDataFrame constructors</h3>

<p>Objects can be created by calls of the form
</p>

<ul>
<li> <p><code>new("TimeInstantDataFrame", ...)</code> ... argument must be replaced
by named arguments coresponding to slots of a TimeInstantDataFrame (see below).
See also <code><a href="methods.html#topic+new">new</a></code>.
</p>
</li>
<li> <p><code>TimeInstantDataFrame (when, timezone='UTC', data=NULL, ...)</code>
Arguments of the function correspond to object slots.
</p>
</li>
<li> <p><code>RegularTimeInstantDataFrame (from, to, by, timezone='UTC', data=NULL)</code>, Wrapper to construct TimeInstantDataFrame with specific properties. Instants
of the TimeInstantDataFrame go from 'from' to 'to' regularly spaced by 
'by', which is a <code><a href="#topic+POSIXctp">POSIXctp</a></code> or an object which can be coerced to.
</p>
</li>
<li> <p><code>as.TimeInstantDataFrame (from, ...)</code> Converting object to
TimeInstantDataFrame.
</p>
</li></ul>



<h3>Math</h3>

<p>Every functions defined in the Ops group (see <code><a href="methods.html#topic+Ops">Ops</a></code>)
can be used width a TimeInstantDataFrame and numeric :
</p>

<ul>
<li><p><code>tidf * 2</code>
</p>
</li>
<li><p><code>2 * tidf</code>
</p>
</li>
<li><p><code>2:10 == tidf</code>
</p>
</li>
<li><p><code>2^tidf</code>
</p>
</li>
<li><p><code>tidf^2</code>
</p>
</li></ul>



<h3>Accessing to and manipulating data</h3>

<p>The TimeInstantDataFrame class is defined to works like the data.frame class
with the difference that a time instant (<code><a href="base.html#topic+POSIXct">POSIXct</a></code>) is
attached to each rows of the data.frame. Thus to access and manipulate
data of a TimeInstantDataFrame the following methods are defined : 
'$', '$&lt;-', '[', '[&lt;-', '[[', '[[&lt;-'. See <code><a href="base.html#topic+Extract">Extract</a></code> for 
details.
</p>
<p>With &lsquo;[&rsquo; operator, a selection by dates is also available. If
&lsquo;i&rsquo; and or &lsquo;j&rsquo; are POSIXt or strings that can be 
converted to POSIXct (see below), they are considered as the 
minimal and maximal time limits : all datas between those are selected.
A string that can be converted to a POSIXct is (in this case only) a
string composed of 3 parts separated by white space : 
'YYYY-MM-DD HH:MM:SS tz'. The second and third parts are options, thus
accepted format are :</p>

<ul>
<li><p> 'YYYY-MM-DD'
</p>
</li>
<li><p> 'YYYY-MM-DD tz'
</p>
</li>
<li><p> 'YYYY-MM-DD HH:MM:SS'
</p>
</li>
<li><p> 'YYYY-MM-DD HH:MM:SS tz'
</p>
</li></ul>
<p>. If timezone is not given, it is assumed to be the same as the one
of the object on which the selection is done.
</p>
<p>Other methods have been defined to allow some operations over
TimeInstantDataFrame :
</p>

<ul>
<li><p> rbind and merge to join two (or more)
TimeInstantDataFrame (see <code><a href="base.html#topic+rbind">rbind</a></code> and
<code><a href="base.html#topic+merge">merge</a></code>),
</p>
</li>
<li><p> a TimeInstantDataFrame can be splitted exactly the same way that
a data.frame can (see <code><a href="base.html#topic+split">split</a></code> in the base
package),
</p>
</li>
<li><p> a function can be applied over each column of a TimeInstantDataFrame
via the lapply function. If the function returns one value,
the resulting value is a <code><a href="#topic+TimeIntervalDataFrame">TimeIntervalDataFrame</a></code>
beginning at the first instant of the object and ending at the latest one ;
else if the function returns as much values as the number of rows of
the object, the TimeInstantDataFrame given in argument is returned with
the new calculated values ; on others cases, a non-TimeInstantDataFrame
object is returned.
</p>
</li></ul>

<p>Because a TimeInstantDataFrame works more or less like a data.frame, 
the following methods work on a TimeInstantDataFrame :
<code><a href="base.html#topic+dim">dim</a></code>,
<code><a href="base.html#topic+length">length</a></code>,
<code><a href="base.html#topic+names">names</a></code>,
<code><a href="base.html#topic+names+3C-">names&lt;-</a></code>,
<code><a href="base.html#topic+ncol">ncol</a></code>,
<code><a href="base.html#topic+nrow">nrow</a></code>,
<code><a href="base.html#topic+row.names">row.names</a></code>,
<code><a href="base.html#topic+row.names+3C-">row.names&lt;-</a></code>.
</p>


<h3>Access to time properties</h3>

<p>A TimeInstantDataFrame can be tested for a few time properties :
</p>

<dl>
<dt>regular</dt><dd><p>TRUE if all time instants are equally spaced ;</p>
</dd>
<dt>timezone</dt><dd><p>gives or sets the timezone of the TimeInstantDataFrame ;</p>
</dd>
<dt>when</dt><dd><p>returns a POSIXct object with the time instant of the 
TimeInstantDataFrame.</p>
</dd>
</dl>



<h3>Graphic representation</h3>

<p>To plot a <code>TimeInstantDataFrame</code> available functions are
<code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+lines">lines</a></code>,
<code><a href="graphics.html#topic+points">points</a></code> and <code><a href="graphics.html#topic+barplot">barplot</a></code>.
</p>
<p>These functions works more or less like their generic definition.
</p>


<h3>Text representation</h3>

<p>To represent a <code>TimeInstantDataFrame</code> available functions are
<code><a href="base.html#topic+print.data.frame">print</a></code>,
<code><a href="base.html#topic+data.frame">summary</a></code>, <code><a href="utils.html#topic+head">head</a></code>,
<code><a href="utils.html#topic+tail">tail</a></code> and <code><a href="methods.html#topic+show">show</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TimeIntervalDataFrame">TimeIntervalDataFrame</a></code>, <code><a href="#topic+SubtimeDataFrame">SubtimeDataFrame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("TimeInstantDataFrame")
</code></pre>

<hr>
<h2 id='TimeIntervalDataFrame'>Class <code>"TimeIntervalDataFrame"</code></h2><span id='topic+TimeIntervalDataFrame-class'></span><span id='topic+TimeIntervalDataFrame'></span><span id='topic+RegularTimeIntervalDataFrame'></span><span id='topic++24+2CTimeIntervalDataFrame-method'></span><span id='topic++24+3C-+2CTimeIntervalDataFrame-method'></span><span id='topic++5B.TimeIntervalDataFrame'></span><span id='topic++5B+3C-.TimeIntervalDataFrame'></span><span id='topic++5B+5B+2CTimeIntervalDataFrame-method'></span><span id='topic++5B+5B+3C-.TimeIntervalDataFrame'></span><span id='topic+Ops+2CTimeIntervallDataFrame+2Cnumeric-method'></span><span id='topic+Ops+2Cnumeric+2CTimeIntervalDataFrame-method'></span><span id='topic+rbind.TimeIntervalDataFrame'></span><span id='topic+merge.TimeIntervalDataFrame'></span><span id='topic+split.TimeIntervalDataFrame'></span><span id='topic+lapply+2CTimeIntervalDataFrame-method'></span><span id='topic+tapply+2CTimeIntervalDataFrame-method'></span><span id='topic+changeSupport+2CTimeIntervalDataFrame-method'></span><span id='topic+continuous+2CTimeIntervalDataFrame-method'></span><span id='topic+continuous+3C-+2CTimeIntervalDataFrame-method'></span><span id='topic+homogeneous+2CTimeIntervalDataFrame-method'></span><span id='topic+period+2CTimeIntervalDataFrame-method'></span><span id='topic+overlapping+2CTimeIntervalDataFrame-method'></span><span id='topic+regular+2CTimeIntervalDataFrame-method'></span><span id='topic+timezone+2CTimeIntervalDataFrame-method'></span><span id='topic+timezone+3C-+2CTimeIntervalDataFrame-method'></span><span id='topic+start.TimeIntervalDataFrame'></span><span id='topic+end.TimeIntervalDataFrame'></span><span id='topic+when+2CTimeIntervalDataFrame-method'></span><span id='topic+interval+2CTimeIntervalDataFrame-method'></span><span id='topic+dim+2CTimeIntervalDataFrame-method'></span><span id='topic+length+2CTimeIntervalDataFrame-method'></span><span id='topic+names+2CTimeIntervalDataFrame-method'></span><span id='topic+names+3C-+2CTimeIntervalDataFrame-method'></span><span id='topic+ncol+2CTimeIntervalDataFrame-method'></span><span id='topic+nrow+2CTimeIntervalDataFrame-method'></span><span id='topic+row.names.TimeIntervalDataFrame'></span><span id='topic+row.names+3C-.TimeIntervalDataFrame'></span><span id='topic+print.TimeIntervalDataFrame'></span><span id='topic+summary.TimeIntervalDataFrame'></span><span id='topic+head.TimeIntervalDataFrame'></span><span id='topic+tail.TimeIntervalDataFrame'></span><span id='topic+show+2CTimeIntervalDataFrame-method'></span><span id='topic+plot.TimeIntervalDataFrame'></span><span id='topic+points.TimeIntervalDataFrame'></span><span id='topic+lines.TimeIntervalDataFrame'></span><span id='topic+barplot.TimeIntervalDataFrame'></span><span id='topic+as.TimeIntervalDataFrame'></span><span id='topic+as.TimeIntervalDataFrame.TimeInstantDataFrame'></span>

<h3>Description</h3>

<p>Class to hold time data that are NOT 'punctual'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  TimeIntervalDataFrame(start, end = NULL,
    timezone = "UTC", data = NULL, period = NULL, sort=FALSE, ...)

  as.TimeIntervalDataFrame(from, ...)
  ## S3 method for class 'TimeInstantDataFrame'
as.TimeIntervalDataFrame(from, period, ...)

  RegularTimeIntervalDataFrame(from, to, by, period, timezone = "UTC", data = NULL)

  ## S4 method for signature 'TimeIntervalDataFrame'
x$name
  ## S4 replacement method for signature 'TimeIntervalDataFrame'
x$name &lt;- value
  ## S3 method for class 'TimeIntervalDataFrame'
x[i, j, drop=FALSE]
  ## S3 replacement method for class 'TimeIntervalDataFrame'
x[i, j] &lt;- value
  ## S4 method for signature 'TimeIntervalDataFrame'
x [[i, j, ...]]
  ## S3 replacement method for class 'TimeIntervalDataFrame'
x[[i, j]] &lt;- value

  ## S3 method for class 'TimeIntervalDataFrame'
rbind(...)
  ## S3 method for class 'TimeIntervalDataFrame'
merge(x, y, by, all=TRUE, tz='UTC', sort=TRUE, ...)
  ## S3 method for class 'TimeIntervalDataFrame'
split(x, f, drop=FALSE, ...)
  ## S4 method for signature 'TimeIntervalDataFrame'
lapply(X, FUN, ...)

  ## S4 method for signature 'TimeIntervalDataFrame'
tapply(X, INDEX, FUN, ...,
       min.coverage=1, weights.arg=NULL, merge.X=TRUE, split.X=FALSE,
       keep.INDEX=TRUE, simplify=TRUE)
  ## S4 method for signature 'TimeIntervalDataFrame'
changeSupport(from, to,
       min.coverage, FUN=NULL, weights.arg=NULL,
       split.from=FALSE, merge.from=TRUE, ...)

  ## S4 method for signature 'TimeIntervalDataFrame'
continuous(x, ...)
  ## S4 replacement method for signature 'TimeIntervalDataFrame'
continuous(x) &lt;- value
  ## S4 method for signature 'TimeIntervalDataFrame'
homogeneous(x, ...)
  ## S4 method for signature 'TimeIntervalDataFrame'
period(x, ...)
  ## S4 method for signature 'TimeIntervalDataFrame'
overlapping(x, ...)
  ## S4 method for signature 'TimeIntervalDataFrame'
regular(x, ...)
  ## S4 method for signature 'TimeIntervalDataFrame'
timezone(object)
  ## S4 replacement method for signature 'TimeIntervalDataFrame'
timezone(object) &lt;- value
  ## S3 method for class 'TimeIntervalDataFrame'
start(x, ...)
  ## S3 method for class 'TimeIntervalDataFrame'
end(x, ...)
  ## S4 method for signature 'TimeIntervalDataFrame'
when(x, ...)
  ## S4 method for signature 'TimeIntervalDataFrame'
interval(x, ...)

  ## S4 method for signature 'TimeIntervalDataFrame'
dim(x)
  ## S4 method for signature 'TimeIntervalDataFrame'
length(x)
  ## S4 method for signature 'TimeIntervalDataFrame'
names(x)
  ## S4 replacement method for signature 'TimeIntervalDataFrame'
names(x) &lt;- value
  ## S4 method for signature 'TimeIntervalDataFrame'
ncol(x)
  ## S4 method for signature 'TimeIntervalDataFrame'
nrow(x)
  ## S3 method for class 'TimeIntervalDataFrame'
row.names(x)
  ## S3 replacement method for class 'TimeIntervalDataFrame'
row.names(x) &lt;- value

  ## S3 method for class 'TimeIntervalDataFrame'
print(x, tz=NULL, ...)
  ## S3 method for class 'TimeIntervalDataFrame'
summary(object, ...)
  ## S3 method for class 'TimeIntervalDataFrame'
head(x, tz, ...)
  ## S3 method for class 'TimeIntervalDataFrame'
tail(x, tz, ...)
  ## S4 method for signature 'TimeIntervalDataFrame'
show(object)

  ## S3 method for class 'TimeIntervalDataFrame'
plot(x, y=NULL, cursor=NULL,
    type='p', lty=1:6, lwd=1, pch=1:25, col=NULL,
    xlim=NULL, ylim=NULL, log='', main='', sub='', xlab='', ylab='',
    ann=par('ann'), axes=TRUE, asp=NA, ...)
  ## S3 method for class 'TimeIntervalDataFrame'
points(x, y=NULL, cursor=NULL, type='p',
    lty=1:6, lwd=1, pch=1:25, col=NULL, ...)
  ## S3 method for class 'TimeIntervalDataFrame'
lines(x, y=NULL, cursor=NULL, type='l',
    lty=1:6, lwd=1, pch=1:25, col=NULL, ...)
  ## S3 method for class 'TimeIntervalDataFrame'
barplot(height, format='', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TimeIntervalDataFrame_+3A_start">start</code></td>
<td>
<p>POSIXct or character representing a time with a valid format
(see <code><a href="base.html#topic+as.POSIXct">POSIXct</a></code>). It gives the begining
of each interval.</p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_end">end</code></td>
<td>
<p>POSIXct or character representing a time with a valid format
(see <code><a href="base.html#topic+as.POSIXct">POSIXct</a></code>). It gives the end
of each interval. If NULL, see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_timezone">timezone</code></td>
<td>
<p>character representing a valid timezone (see
<code><a href="base.html#topic+timezone">timezone</a></code>).</p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_data">data</code></td>
<td>
<p>a data.frame with as much rows as the length
of &lsquo;start&rsquo; and end, or with one row less than the
length of &lsquo;start&rsquo; if &lsquo;end&rsquo; is <code>NULL</code>.
Can be <code>NULL</code> (hence the data.frame has zero column
and as much rows as needed).</p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_period">period</code></td>
<td>


<dl>
<dt>TimeIntervalDataFrame</dt><dd>
<p>if not NULL, a <code><a href="#topic+POSIXctp">POSIXctp</a></code> or a
character that can be converted to a
<code><a href="#topic+POSIXctp">POSIXctp</a></code> (see argument &lsquo;unit&rsquo; of
POSIXctp function). See Details to know how to use this
argument.</p>
</dd>
<dt>as.TimeIntervalDataFrame</dt><dd>
<p><code><a href="#topic+POSIXctp">POSIXctp</a></code> object indicating
the period to add to &lsquo;when&rsquo; slot of <code>from</code> to
determine the end of the new period (the &lsquo;when&rsquo; is
used for the start of period)</p>
</dd>
<dt>RegularTimeIntervalDataFrame</dt><dd>
<p>a <code><a href="#topic+POSIXctp">POSIXctp</a></code> object indicating the period of each
interval. If missing, it is given the value of <code>by</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_from">from</code></td>
<td>

<dl>
<dt>as.TimeIntervalDataFrame</dt><dd><p>object to convert to a TimeIntervalDataFrame</p>
</dd>
<dt>RegularTimeIntervalDataFrame</dt><dd>
<p>POSIXct or character representing a time with a valid format (see
<code><a href="base.html#topic+as.POSIXct">POSIXct</a></code>). It represents the start of the
object.</p>
</dd>
<dt>changeSupport</dt><dd><p>see <code><a href="#topic+changeSupport">changeSupport</a></code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_to">to</code></td>
<td>

<dl>
<dt>RegularTimeIntervalDataFrame</dt><dd>
<p>POSIXct or character representing a time with a valid format (see
<code><a href="base.html#topic+as.POSIXct">POSIXct</a></code>). It represents the end of the
object. If missing, its value is deduced from &lsquo;from&rsquo;,
&lsquo;by&rsquo; and &lsquo;data&rsquo;.</p>
</dd>
<dt>changeSupport</dt><dd><p>see <code><a href="#topic+changeSupport">changeSupport</a></code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_by">by</code></td>
<td>

<dl>
<dt>RegularTimeIntervalDataFrame</dt><dd><p>a <code><a href="#topic+POSIXctp">POSIXctp</a></code> object
indicating the increment to use between the start of each interval.</p>
</dd>
<dt>merge</dt><dd><p>specifications of the columns used for merging.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_x">x</code></td>
<td>
<p>TimeIntervalDataFrame object (to modify, to extract or to test)</p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_i">i</code></td>
<td>
<p>indices specifying elements to extract or replace. (See
<code><a href="base.html#topic+Extract">Extract</a></code>)</p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_j">j</code></td>
<td>
<p>indices specifying elements to extract or replace. (See
<code><a href="base.html#topic+Extract">Extract</a></code>)</p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_name">name</code></td>
<td>
<p>A litteral character string or a name. (See
<code><a href="base.html#topic+Extract">Extract</a></code>)</p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_drop">drop</code></td>
<td>
<p>Used for compatibility with data.frame methods.</p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_value">value</code></td>
<td>
<p>New value for the object designated (data.frame, names, row.names,
etc.).</p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_y">y</code></td>
<td>
<p>TimeIntervalDataFrame to merge with x</p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_all">all</code></td>
<td>
<p>logical; see <code><a href="base.html#topic+merge">merge</a></code></p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_tz">tz</code></td>
<td>
<p>character representing a valid timezone (see
<code><a href="base.html#topic+timezone">timezone</a></code>).</p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_sort">sort</code></td>
<td>
<p>logical; if TRUE the resulting built/merged TimeIntervalDataFrame is 
ordered according to 'when' values.</p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_f">f</code></td>
<td>
<p>a 'factor' in the sense that ‘as.factor(f)’ defines the
grouping, or a list of such factors in which case their
interaction is used for the grouping. See <code><a href="#topic+split">split</a></code>.</p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_x">X</code></td>
<td>


<dl>
<dt>lapply</dt><dd><p>a TimeIntervalDataFrame on which the FUN must be applied.</p>
</dd>
<dt>tapply</dt><dd><p>see <code><a href="#topic+tapply">tapply</a></code> for details</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_fun">FUN</code></td>
<td>


<dl>
<dt>lapply</dt><dd><p>function to apply over each columns of X.</p>
</dd>
<dt>tapply,changeSupport</dt><dd><p>see <code><a href="#topic+tapply">tapply</a></code> for details</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_index">INDEX</code>, <code id="TimeIntervalDataFrame_+3A_min.coverage">min.coverage</code>, <code id="TimeIntervalDataFrame_+3A_weights.arg">weights.arg</code>, <code id="TimeIntervalDataFrame_+3A_merge.x">merge.X</code>, <code id="TimeIntervalDataFrame_+3A_split.x">split.X</code>, <code id="TimeIntervalDataFrame_+3A_keep.index">keep.INDEX</code>, <code id="TimeIntervalDataFrame_+3A_simplify">simplify</code>, <code id="TimeIntervalDataFrame_+3A_split.from">split.from</code>, <code id="TimeIntervalDataFrame_+3A_merge.from">merge.from</code></td>
<td>

<p>see <code><a href="#topic+tapply">tapply</a></code> and/or <code><a href="#topic+changeSupport">changeSupport</a></code>
for details.</p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_object">object</code></td>
<td>
<p>TimeIntervalDataFrame object (to modify, to extract or to test)</p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_type">type</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_lty">lty</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_lwd">lwd</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_pch">pch</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_col">col</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_xlim">xlim</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_ylim">ylim</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_log">log</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_main">main</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_sub">sub</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_xlab">xlab</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_ylab">ylab</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_ann">ann</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_axes">axes</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_asp">asp</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_cursor">cursor</code></td>
<td>
<p>To convert TimeIntervalDataFrame to a TimeInstantDataFrame
before plotting (see <code><a href="#topic+TimeInstantDataFrame">TimeInstantDataFrame</a></code>,
it indicates where the TimeInstant
must be taken. If <code>0</code>, start of each intervals is taken as
instant ; if <code>1</code> end of each intervals is taken as instant.
Any other value will determine a weigthed instant between start and
end (actually, value higher than 1 or lower than 0 will give instant
outside this range).</p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_height">height</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+barplot">barplot</a></code></p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_format">format</code></td>
<td>
<p>plotting argument, see <code><a href="graphics.html#topic+barplot">barplot</a></code></p>
</td></tr>
<tr><td><code id="TimeIntervalDataFrame_+3A_...">...</code></td>
<td>
<p>More arguments.</p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>Formally, the class consists of a <code><a href="base.html#topic+data.frame">data.frame</a></code>
and, for each row, two <code><a href="base.html#topic+POSIXct">POSIXct</a></code> that can
be summarize as time interval with the <code><a href="#topic+POSIXcti">POSIXcti</a></code> class.
This allows to manipulate at once time data without any 
restriction on time representation : data can occur at different time, 
data can be discontinuous, data can be heterogeneous (not lasting
for a unique period), data can overlay each other, etc.
There are several methods to test/deal/ensure that
these properties are respected or not, see below.
</p>
<p>The construction of the class allows to manipulate objects as if they
were data.frame (see &lsquo;Access to data&rsquo; and &lsquo;Access to
data properties&rsquo;). Several functions are also available to access to
time properties (see &lsquo;Access to time properties&rsquo;).
</p>
<p>Methods are also available to facilitate the representations of
instances of that class : see &lsquo;graphic representation&rsquo; and
&lsquo;text representation&rsquo;.
</p>
<p>Finally, some specific methods allow to easily deal with agregation of
data over time properties (day, hour, week, special or specific time
intervals).
</p>


<h3>Slots</h3>


<dl>
<dt><code>start</code>:</dt><dd><p>Object of class <code>"POSIXct"</code> 
corresponding to the start of each row of
the <code>data.frame</code>.</p>
</dd>
<dt><code>end</code>:</dt><dd><p>Object of class <code>"POSIXct"</code>
corresponding to the end of each row of
the <code>data.frame</code>.</p>
</dd>
<dt><code>timezone</code>:</dt><dd><p>Object of class <code>"character"</code>
indicating the timezone of data both for 
representation and calculation.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"data.frame"</code> data contained
by the object.</p>
</dd>
</dl>



<h3>TimeIntervalDataFrame constructors</h3>

<p>Objects can be created by calls of the form
</p>

<ul>
<li> <p><code>new("TimeIntervalDataFrame", ...)</code> ... argument must be
replaced by named arguments coresponding to slots of a
TimeIntervalDataFrame (see below). See also <code><a href="methods.html#topic+new">new</a></code>.
</p>
</li>
<li><p><code>TimeIntervalDataFrame (start, end=NULL, timezone='UTC', data=NULL, ...)</code>
Arguments of the function correspond to object slots.
If both <code>start</code> and <code>end</code> are given, they must
have the same length. They are used to define the
intervals of the object. If <code>data</code> is also given, it
must have a number of rows identical to the length of
<code>start</code> and <code>end</code>.
</p>
<p>If only <code>start</code> is given, a continuous (see
<code><a href="#topic+continuous">continuous</a></code>) TimeIntervalDataFrame is built.
The first element of <code>start</code> is the start of the
first interval, the second element is the end of the
first interval and the start of the second interval. The
last element of <code>start</code> is only the end of the last
interval. This is why <code>data</code>, if given, must be one
row shorter than <code>start</code>.
</p>
<p>If period is given it must be a <code><a href="#topic+POSIXctp">POSIXctp</a></code>
object (or a valid character) and &lsquo;start&rsquo; and
&lsquo;end&rsquo; must have length equal to 1. In that case, a
TimeIntervalDataFrame will be created with start date
equal to start &lsquo;floored&rsquo; by the unit of
&lsquo;period&rsquo;, end date &lsquo;ceiled&rsquo; by the unit of
&lsquo;period&rsquo; and with enough intervals of
&lsquo;period&rsquo; length to fit. If &lsquo;data&rsquo; given, it
must have a number of rows equal to the number of
intervals calculated.
</p>
</li>
<li> <p><code>RegularTimeIntervalDataFrame (from, to, by, period, timezone='UTC', data=NULL)</code>
Wrapper to construct TimeIntervalDataFrame with specific properties (see
details of each argument).
</p>
</li>
<li> <p><code>as.TimeIntervalDataFrame (from, ...)</code>
Converting object to TimeIntervalDataFrame.
</p>
</li></ul>



<h3>Math</h3>

<p>Every functions defined in the Ops group (see <code><a href="methods.html#topic+Ops">Ops</a></code>)
can be used width a TimeIntervalDataFrame and numeric :
</p>

<ul>
<li><p><code>tidf * 2</code>
</p>
</li>
<li><p><code>2 * tidf</code>
</p>
</li>
<li><p><code>2:10 == tidf</code>
</p>
</li>
<li><p><code>2^tidf</code>
</p>
</li>
<li><p><code>tidf^2</code>
</p>
</li></ul>



<h3>Accessing to and manipulating data</h3>

<p>The TimeIntervalDataFrame class is defined to works like the data.frame class
with the difference that a time interval (<code><a href="#topic+POSIXcti">POSIXcti</a></code>) is
attached to each rows of the data.frame. Thus to access and manipulate
data of a TimeIntervalDataFrame the following methods are defined : 
'$', '$&lt;-', '[', '[&lt;-', '[[', '[[&lt;-'. See <code><a href="base.html#topic+Extract">Extract</a></code> for 
details.
</p>
<p>With &lsquo;[&rsquo; operator, a selection by dates is also available. If
&lsquo;i&rsquo; and or &lsquo;j&rsquo; are POSIXt or strings that can be 
converted to POSIXct (see below), they are considered as the 
minimal and maximal time limits : all datas between those are selected.
A string that can be converted to a POSIXct is (in this case only) a
string composed of 3 parts separated by white space : 
'YYYY-MM-DD HH:MM:SS tz'. The second and third parts are options, thus
accepted format are :</p>

<ul>
<li><p> 'YYYY-MM-DD'
</p>
</li>
<li><p> 'YYYY-MM-DD tz'
</p>
</li>
<li><p> 'YYYY-MM-DD HH:MM:SS'
</p>
</li>
<li><p> 'YYYY-MM-DD HH:MM:SS tz'
</p>
</li></ul>
<p>. If timezone is not given, it is assumed to be the same as the one
of the object on which the selection is done.
</p>
<p>Other methods have been defined to allow some operations on
TimeIntervalDataFrame :
</p>

<ul>
<li><p> rbind and merge to join two (or more)
TimeIntervalDataFrame (see <code><a href="base.html#topic+rbind">rbind</a></code> and
<code><a href="base.html#topic+merge">merge</a></code>),
</p>
</li>
<li><p> a TimeIntervalDataFrame can be splitted exactly the same way that
a data.frame can (see <code><a href="base.html#topic+split">split</a></code> in the base
package) and some more possibilities have been defined (see <code><a href="#topic+split">split</a></code>
in the timetools package),
</p>
</li>
<li><p> a function can be applied over each column of a TimeIntervalDataFrame
via the lapply function. If the function returns one value,
the resulting value is a <code><a href="#topic+TimeIntervalDataFrame">TimeIntervalDataFrame</a></code>
beginning at the first instant of the object and ending at the latest one ;
else if the function returns as much values as the number of rows of
the object, the TimeIntervalDataFrame given in argument is returned with
the new calculated values ; on others cases, a non-TimeInterevalDataFrame
object is returned.
</p>
</li>
<li><p> 'tapply' can split a TimeIntervalDataFrame and then apply a function
over each group (see <code><a href="#topic+tapply">tapply</a></code>),
</p>
</li>
<li><p> 'changeSupport' act like the 'tapply' function but with
a different default behaviour (see <code><a href="#topic+changeSupport">changeSupport</a></code>).
</p>
</li></ul>

<p>Because a TimeIntervalDataFrame works more or less like a data.frame, 
the following methods work on a TimeIntervalDataFrame :
<code><a href="base.html#topic+dim">dim</a></code>,
<code><a href="base.html#topic+length">length</a></code>,
<code><a href="base.html#topic+names">names</a></code>,
<code><a href="base.html#topic+names+3C-">names&lt;-</a></code>,
<code><a href="base.html#topic+ncol">ncol</a></code>,
<code><a href="base.html#topic+nrow">nrow</a></code>,
<code><a href="base.html#topic+row.names">row.names</a></code>,
<code><a href="base.html#topic+row.names+3C-">row.names&lt;-</a></code>.
</p>


<h3>Access/modify to time properties</h3>

<p>A TimeIntervamDataFrame can be tested for a few time properties :
</p>

<dl>
<dt>continuous</dt><dd><p>see <code><a href="#topic+continuous">continuous</a></code> ;</p>
</dd>
<dt>homogeneous</dt><dd><p>see <code><a href="#topic+homogeneous">homogeneous</a></code> ;</p>
</dd>
<dt>period</dt><dd><p>see <code><a href="#topic+period">period</a></code> ;</p>
</dd>
<dt>overlapping</dt><dd><p>see <code><a href="#topic+overlapping">overlapping</a></code> ;</p>
</dd>
<dt>regular</dt><dd><p>TRUE if all time intervals are equally spaced ;</p>
</dd>
<dt>timezone</dt><dd><p>gives or sets the timezone of the TimeIntervalDataFrame ;</p>
</dd>
<dt>start</dt><dd><p>returns a POSIXct object with the start time of each 
intervals ;</p>
</dd>
<dt>end</dt><dd><p>returns a POSIXct object with the end time of each intervals ;</p>
</dd>
<dt>when</dt><dd><p>returns a POSIXcti, i.e. the intervals of the object ;</p>
</dd>
<dt>interval</dt><dd><p>returns a POSIXcti, i.e. the intervals of the object.</p>
</dd>
</dl>



<h3>Graphic representation</h3>

<p>To plot a <code>TimeIntervalDataFrame</code> available functions are
<code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+lines">lines</a></code>,
<code><a href="graphics.html#topic+points">points</a></code> and <code><a href="graphics.html#topic+barplot">barplot</a></code>.
</p>
<p>These functions works more or less like their generic definition.
</p>


<h3>Text representation</h3>

<p>To represent a <code>TimeIntervalDataFrame</code> available functions are
<code><a href="base.html#topic+print.data.frame">print</a></code>,
<code><a href="base.html#topic+data.frame">summary</a></code>, <code><a href="utils.html#topic+head">head</a></code>,
<code><a href="utils.html#topic+tail">tail</a></code> and <code><a href="methods.html#topic+show">show</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TimeInstantDataFrame">TimeInstantDataFrame</a></code>, <code><a href="#topic+SubtimeDataFrame">SubtimeDataFrame</a></code>,
<code><a href="#topic+POSIXcti">POSIXcti</a></code>, <code><a href="#topic+POSIXctp">POSIXctp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("TimeIntervalDataFrame")
</code></pre>

<hr>
<h2 id='timetools-package'>
Seasonal/Sequential (Instants/Durations, Even or not) Time Series
</h2><span id='topic+timetools-package'></span><span id='topic+timetools'></span>

<h3>Description</h3>

<p>Objects to manipulate sequential and seasonal time series. Sequential time
series based on time instants and time durations are handled. Both can be
regularly or unevenly spaced (overlapping durations are allowed).
</p>
<p>Only POSIX* format are used for dates and times.
</p>
<p>The following classes are provided : POSIXcti, POSIXctp,
TimeIntervalDataFrame, TimeInstantDataFrame, SubtimeDataFrame ;
methods to switch from a class to another and to modify the time support
of series (hourly time series to daily time series for instance) are also
defined.
</p>
<p>Tools provided can be used for instance to handle environmental monitoring
data (not always produced on a regular time base).
</p>


<h3>Author(s)</h3>

<p>Vladislav Navel &lt;vnavel@yahoo.fr&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TimeInstantDataFrame">TimeInstantDataFrame</a></code>, <code><a href="#topic+TimeIntervalDataFrame">TimeIntervalDataFrame</a></code>,
<code><a href="#topic+changeSupport">changeSupport</a></code>, 
<code><a href="#topic+SubtimeDataFrame">SubtimeDataFrame</a></code>, <code><a href="#topic+POSIXcti">POSIXcti</a></code>, <code><a href="#topic+POSIXctp">POSIXctp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ti1 &lt;- TimeIntervalDataFrame (
	c('2010-01-01', '2010-02-01'), c('2010-02-01', '2010-02-02'),
	'UTC', data.frame(ex1=1:2) )

ti2 &lt;- TimeIntervalDataFrame (
	c('2010-01-01', '2010-02-01', '2010-02-02'), NULL,
	'UTC', data.frame(ex1=1:2) )

all.equal (ti1, ti2)

ti3 &lt;- TimeIntervalDataFrame (
	c('2010-01-01', '2010-01-02', '2010-01-04'), NULL,
	'UTC', data.frame(ex3=c(6, 1.5)))

# weighted mean over a period of 3 days with at least 75% of
# coverage (NA is retunr if not)
ti3
d &lt;- POSIXctp(unit='day')
changeSupport (ti3, 3L*d, 0.75)


ti4 &lt;- TimeIntervalDataFrame (
	c('2010-01-01', '2010-01-02', '2010-01-04', 
	  '2010-01-07', '2010-01-09', '2010-01-10'), NULL,
	'UTC', data.frame(ex4=c(6, 1.5, 5, 3, NA)))

# weighted mean over a period of 3 days with at least 75% of
# coverage (NA is retunr if not) or 50%
ti4
changeSupport (ti4, 3L*d, 0.75)
changeSupport (ti4, 3L*d, 0.5)


</code></pre>

<hr>
<h2 id='timezone'>Get or set timezone property</h2><span id='topic+timezone'></span><span id='topic+timezone+3C-'></span><span id='topic+timezone+3C--methods'></span><span id='topic+timezone-methods'></span>

<h3>Description</h3>

<p>get or set the timezone of the time object (see
<code><a href="base.html#topic+timezone">timezone</a></code> in the base package).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  timezone(object)
  timezone(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timezone_+3A_object">object</code></td>
<td>
<p>object to get or set timezone property. </p>
</td></tr>
<tr><td><code id="timezone_+3A_value">value</code></td>
<td>
<p>specify the new value for timezone. See 
<a href="base.html#topic+timezone">timezone</a> in the base package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Changing the timezone of an object consist in reprojecting
time coordinates from a system of reference to another.
That is to say that not only the &lsquo;timezone&rsquo; attribute
is changed : for instance '2012-02-01 14:OO UTC' will
be changed in '2012-02-01 15:00 CET' if &lsquo;timezone&rsquo; is set
to &lsquo;CET&rsquo; (French local time).
</p>

<hr>
<h2 id='unit'>define valid units for time objects/retrieve-set time unit of a time object</h2><span id='topic+units'></span><span id='topic+POSIXt.units'></span><span id='topic+unit'></span><span id='topic+unit-methods'></span><span id='topic+unit+3C-'></span><span id='topic+unit+3C--methods'></span><span id='topic+of'></span>

<h3>Description</h3>

<p>The timetools package use a set of valid time units which are
roughly : year, month, week, day, hour, minute, second. 
They can be combined in <code><a href="#topic+POSIXst-class">subtime objects</a></code>.
For instance : month of year, minute of day, minute of week, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  POSIXt.units(x = NULL, ...)

  unit(x, ...)
  unit(object) &lt;- value
  of(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unit_+3A_x">x</code></td>
<td>
<p>a character string representing the needed
units for <code>POSIXt.units</code>. The object from which
the time unit is to retrieve.</p>
</td></tr>
<tr><td><code id="unit_+3A_object">object</code></td>
<td>
<p>POSIXctp to which the unit is to be
changed</p>
</td></tr>
<tr><td><code id="unit_+3A_value">value</code></td>
<td>
<p>a character or a <code><a href="#topic+POSIXt.units">POSIXt.units</a></code>
indicating the new units of object.</p>
</td></tr>
<tr><td><code id="unit_+3A_...">...</code></td>
<td>
<p>arguments to or from other methods</p>
</td></tr>
</table>


<h3>POSIXt.units(x = NULL, ...)</h3>

<p>With no argument, the function return a factor
containing the valid time units. With an argument, it
returns the units asked for.
</p>


<h3>unit(x, ...)</h3>

<p>Return the time unit of the object. In case 'x' is a 
<code><a href="#topic+POSIXst">POSIXst</a></code>, the unit is the 'left' part of 
its unit : if 'x' is a 'minute of day', 'unit' will return
'minute'.
</p>


<h3>of(x, ...)</h3>

<p>For <code><a href="#topic+POSIXst">POSIXst</a></code> only, it return the 'right' part
of the unit of 'x' : if 'x' is a 'minute of day', 'of' will return
'day'.
</p>

<hr>
<h2 id='when'>Retrieve the 'timestamp' of a Time*DataFrame</h2><span id='topic+when'></span><span id='topic+when-methods'></span>

<h3>Description</h3>

<p>For Time objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  when(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="when_+3A_x">x</code></td>
<td>
<p>object from which get the timestamp</p>
</td></tr>
<tr><td><code id="when_+3A_...">...</code></td>
<td>
<p>arguments to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If TimeInstantDataFrame, return the instants of the object ;
</p>
<p>if TimeIntervalDataFrame, return the intervals of the object.
</p>
<p>if SubtimeDataFrame, return the <a href="#topic+POSIXst">POSIXst</a> of the object.
</p>


<h3>See Also</h3>

<p><a href="#topic+TimeIntervalDataFrame">TimeIntervalDataFrame</a>, <a href="#topic+POSIXcti">POSIXcti</a>, 
<a href="#topic+TimeInstantDataFrame">TimeInstantDataFrame</a>, <a href="base.html#topic+POSIXct">POSIXct</a>,
<a href="#topic+SubtimeDataFrame">SubtimeDataFrame</a>, <a href="#topic+POSIXst">POSIXst</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
