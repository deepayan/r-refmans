<!DOCTYPE html><html><head><title>Help for package oddnet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {oddnet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#oddnet-package'><p>oddnet: Anomaly Detection in Temporal Networks</p></a></li>
<li><a href='#anomalous_networks'><p>Identifies anomalous networks from a series of temporal networks.</p></a></li>
<li><a href='#compute_features'><p>Computes features for each network.</p></a></li>
<li><a href='#lad'><p>Laplacian Eigen Value method by Shenyang Huang, Yasmeen Hitti, Guillaume Rabusseau</p>
and Reihaneh Rabbany from their KDD'20 paper Laplacian Change Point Detection for Dynamic Graphs</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Anomaly Detection in Temporal Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sevvandi Kandanaarachchi &lt;sevvandik@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Anomaly detection in dynamic, temporal networks. The package 
    'oddnet' uses a feature-based method to identify anomalies. First, it computes 
    many features for each network. Then it models the features using time series 
    methods. Using time series residuals it detects anomalies. This way, the 
    temporal dependencies are accounted for when identifying anomalies 
    (Kandanaarachchi, Hyndman 2022) &lt;<a href="https://doi.org/10.48550/arXiv.2210.07407">doi:10.48550/arXiv.2210.07407</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, fable, fabletools, igraph, lookout, pcaPP, rlang,
tibble, tidyr, tsibble, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DDoutlier, feasts, knitr, rmarkdown, rTensor, urca</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://sevvandi.github.io/oddnet/">https://sevvandi.github.io/oddnet/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-11 11:44:19 UTC; kan092</td>
</tr>
<tr>
<td>Author:</td>
<td>Sevvandi Kandanaarachchi
    <a href="https://orcid.org/0000-0002-0337-0395"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Rob Hyndman <a href="https://orcid.org/0000-0002-2140-5352"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-11 12:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='oddnet-package'>oddnet: Anomaly Detection in Temporal Networks</h2><span id='topic+oddnet-package'></span>

<h3>Description</h3>

<p>Anomaly detection in dynamic, temporal networks. The package 'oddnet' uses a feature-based method to identify anomalies. First, it computes many features for each network. Then it models the features using time series methods. Using time series residuals it detects anomalies. This way, the temporal dependencies are accounted for when identifying anomalies (Kandanaarachchi, Hyndman 2022) <a href="https://arxiv.org/abs/2210.07407">arXiv:2210.07407</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Sevvandi Kandanaarachchi <a href="mailto:sevvandik@gmail.com">sevvandik@gmail.com</a> (<a href="https://orcid.org/0000-0002-0337-0395">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Rob Hyndman <a href="mailto:rob.hyndman@monash.edu">rob.hyndman@monash.edu</a> (<a href="https://orcid.org/0000-0002-2140-5352">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://sevvandi.github.io/oddnet/">https://sevvandi.github.io/oddnet/</a>
</p>
</li></ul>


<hr>
<h2 id='anomalous_networks'>Identifies anomalous networks from a series of temporal networks.</h2><span id='topic+anomalous_networks'></span>

<h3>Description</h3>

<p>This function identifies anomalous networks from a series of temporal networks. It uses graph
theoretic features to transform networks to a feature space. This function has parameters for
feature computation, scaling, robust PCA and anomaly detection procedures.   ADD MORE DESCRIPTION.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anomalous_networks(
  networks,
  alpha = 0.05,
  dd = 2,
  trim = 0.005,
  na_action = NULL,
  vert_attr = FALSE,
  attr_name = NULL,
  attr_mat = NULL,
  fast = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anomalous_networks_+3A_networks">networks</code></td>
<td>
<p>The input series of temporal networks given in a list with each network denoted
by its adjacency matrix.</p>
</td></tr>
<tr><td><code id="anomalous_networks_+3A_alpha">alpha</code></td>
<td>
<p>An anomaly detection parameter. The level of significance for the anomaly detection
algorithm lookout. Default is 0.05.</p>
</td></tr>
<tr><td><code id="anomalous_networks_+3A_dd">dd</code></td>
<td>
<p>A robust PCA parameter. The number of reduced dimensions in robust PCA. Default is 2.</p>
</td></tr>
<tr><td><code id="anomalous_networks_+3A_trim">trim</code></td>
<td>
<p>A scaling parameter. The percentage used to compute trimmed mean and trimmed standard
deviation. Default is 0.5 percent.</p>
</td></tr>
<tr><td><code id="anomalous_networks_+3A_na_action">na_action</code></td>
<td>
<p>The action for NA valued features.</p>
</td></tr>
<tr><td><code id="anomalous_networks_+3A_vert_attr">vert_attr</code></td>
<td>
<p>A feature computation parameter. If <code>TRUE</code> the network nodes/vertices have
attributes.</p>
</td></tr>
<tr><td><code id="anomalous_networks_+3A_attr_name">attr_name</code></td>
<td>
<p>A feature computation parameter. The name of the network vertex attribute. Only a
single attribute can be specified.</p>
</td></tr>
<tr><td><code id="anomalous_networks_+3A_attr_mat">attr_mat</code></td>
<td>
<p>A feature computation parameter. If network nodes/vertices have attributes, the list of attribute
matrices for each network can be given using this feature.</p>
</td></tr>
<tr><td><code id="anomalous_networks_+3A_fast">fast</code></td>
<td>
<p>If set to <code>TRUE</code> will avoid computing time consuming features.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object imported from lookout.
</p>


<h3>See Also</h3>

<p>[lookout::lookout()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We generate a series of networks and add an anomaly at 50th network.
set.seed(1)
networks &lt;- list()
p.or.m.seq &lt;- rep(0.1, 50)
p.or.m.seq[20] &lt;- 0.3  # anomalous network at 20
for(i in 1:50){
  gr &lt;- igraph::erdos.renyi.game(50, p.or.m = p.or.m.seq[i])
  networks[[i]] &lt;- igraph::as_adjacency_matrix(gr)
}
anomalous_networks(networks, fast = TRUE)


</code></pre>

<hr>
<h2 id='compute_features'>Computes features for each network.</h2><span id='topic+compute_features'></span>

<h3>Description</h3>

<p>This function computes features for each network using graph theoretic constructs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_features(gr, attributes = FALSE, attr_name = NULL, fast = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_features_+3A_gr">gr</code></td>
<td>
<p>The network or graph as an <code>igraph</code> object.</p>
</td></tr>
<tr><td><code id="compute_features_+3A_attributes">attributes</code></td>
<td>
<p>If the network nodes/vertices have attributes, then <code>attributes = TRUE</code>.</p>
</td></tr>
<tr><td><code id="compute_features_+3A_attr_name">attr_name</code></td>
<td>
<p>The name of the node/vertex attribute. Only a single attribute can
be specified.</p>
</td></tr>
<tr><td><code id="compute_features_+3A_fast">fast</code></td>
<td>
<p>If set to <code>TRUE</code> will avoid computing time consuming features.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A network features object containing 20 graph-theoretic features.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
gr &lt;- igraph::erdos.renyi.game(100, 0.05)
compute_features(gr)


</code></pre>

<hr>
<h2 id='lad'>Laplacian Eigen Value method by Shenyang Huang, Yasmeen Hitti, Guillaume Rabusseau
and Reihaneh Rabbany from their KDD'20 paper Laplacian Change Point Detection for Dynamic Graphs</h2><span id='topic+lad'></span>

<h3>Description</h3>

<p>Laplacian Eigen Value method by Shenyang Huang, Yasmeen Hitti, Guillaume Rabusseau
and Reihaneh Rabbany from their KDD'20 paper Laplacian Change Point Detection for Dynamic Graphs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lad(matlist, k = NULL, short_win, long_win, alpha = 0.05, from_file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lad_+3A_matlist">matlist</code></td>
<td>
<p>The matrix list, where each matrix is an adjacency matrix of the graph.</p>
</td></tr>
<tr><td><code id="lad_+3A_k">k</code></td>
<td>
<p>The number of eigen values to connsider</p>
</td></tr>
<tr><td><code id="lad_+3A_short_win">short_win</code></td>
<td>
<p>The length of the shorter windows</p>
</td></tr>
<tr><td><code id="lad_+3A_long_win">long_win</code></td>
<td>
<p>The length of the longer windows</p>
</td></tr>
<tr><td><code id="lad_+3A_alpha">alpha</code></td>
<td>
<p>The threshold to declare anomalies</p>
</td></tr>
<tr><td><code id="lad_+3A_from_file">from_file</code></td>
<td>
<p>This is an additional parameter only if a file needs to be read</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class lad. LAD is a window based method. It considers short and a long
windows.  The lad object has anomalous scores when taking into account short and long windows
along with the identified anomalies for both short and long windows.
</p>


<h3>References</h3>

<p>Huang, S., Hitti, Y., Rabusseau, G., &amp; Rabbany, R. (2020). Laplacian Change
Point Detection for Dynamic Graphs. Proceedings of the ACM SIGKDD International Conference
on Knowledge Discovery and Data Mining, 349–358. https://doi.org/10.1145/3394486.3403077
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We generate a series of networks and add an anomaly at 50th network.
set.seed(1)
networks &lt;- list()
p.or.m.seq &lt;- rep(0.05, 50)
p.or.m.seq[20] &lt;- 0.2  # anomalous network at 20
for(i in 1:50){
  gr &lt;- igraph::erdos.renyi.game(100, p.or.m = p.or.m.seq[i])
  networks[[i]] &lt;- igraph::as_adjacency_matrix(gr)
}
ladobj &lt;- lad(networks, k = 6, short_win = 2, long_win = 4)
ladobj

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
