<!DOCTYPE html><html><head><title>Help for package wrTopDownFrag</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {wrTopDownFrag}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AAfragSettings'><p>Settings for AA fragments</p></a></li>
<li><a href='#addMassModif'><p>Add modifications to peptide mass</p></a></li>
<li><a href='#checkModTy'><p>Check &amp; complete mixed of variable and fixed modifications</p></a></li>
<li><a href='#combinateAllAndSum'><p>Full combinatorial and cumulative values</p></a></li>
<li><a href='#countChildrenParent'><p>Identify Children/Parent settings as a+b=c</p></a></li>
<li><a href='#countPotModifAAs'><p>Make table with counts of potential modification sites</p></a></li>
<li><a href='#evalIsoFragm'><p>Evaluate selected lines of pepTab (iso-mass) for preferential cutting sites</p></a></li>
<li><a href='#fragmentSeq'><p>Fragment protein or peptide sequence</p></a></li>
<li><a href='#identifFixedModif'><p>Identify Fixed Modifications</p></a></li>
<li><a href='#makeFragments'><p>Make terminal and internal fragments from proteins</p></a></li>
<li><a href='#plotNTheor'><p>Plot the number of theoretical random fragments</p></a></li>
<li><a href='#scoreChargeCatch'><p>Scoring of charge catching potential for peptides</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Internal Fragment Identification from Top-Down Mass Spectrometry</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Wolfgang Raffelsberger [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wolfgang Raffelsberger &lt;w.raffelsberger@unistra.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Top-Down mass spectrometry aims to identify entire proteins as well as their (post-translational) modifications or ions bound (eg Chen et al (2018) &lt;<a href="https://doi.org/10.1021%2Facs.analchem.7b04747">doi:10.1021/acs.analchem.7b04747</a>&gt;). 
    The pattern of internal fragments (Haverland et al (2017) &lt;<a href="https://doi.org/10.1007%2Fs13361-017-1635-x">doi:10.1007/s13361-017-1635-x</a>&gt;) may reveal important information about the original structure of the proteins studied 
    (Skinner et al (2018) &lt;<a href="https://doi.org/10.1038%2Fnchembio.2515">doi:10.1038/nchembio.2515</a>&gt; and Li et al (2018) &lt;<a href="https://doi.org/10.1038%2Fnchem.2908">doi:10.1038/nchem.2908</a>&gt;). 
    However, the number of possible internal fragments gets huge with longer proteins and subsequent identification of internal fragments remains challenging, 
    in particular since the the accuracy of measurements with current mass spectrometers represents a limiting factor.   
    This package attempts to deal with the complexity of internal fragments and allows identification of terminal and internal fragments from deconvoluted mass-spectrometry data. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, stats, utils, wrMisc, wrProteo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BiocParallel, boot, data.tree, fdrtool, knitr, limma,
parallel, preprocessCore, RColorBrewer, rmarkdown, wrGraph</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-09-01 09:17:27 UTC; wraff</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-09-08 08:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AAfragSettings'>Settings for AA fragments</h2><span id='topic+AAfragSettings'></span>

<h3>Description</h3>

<p>This function provides basic settings for what types of fragments may accomodate which type of modifications :  $knownMods: information about which modifications may be considered, $specAAMod: specifc AA sites (if applicable),  $specAAMod: specifc AA sites (if applicable).
For example, here 'p' codes for gain of mass for HPO3 only at S, T and Y residues.
Note: $knownMods$Nterm and $knownMods$Cterm are treated as mutually exclusive
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AAfragSettings(outTy = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AAfragSettings_+3A_outty">outTy</code></td>
<td>
<p>(character) default &quot;all&quot; or any of the list-elements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list ($knownMods, $knspecAAMods, $modChem, $neutralLossOrGain)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeFragments">makeFragments</a></code>,  <code><a href="#topic+fragmentSeq">fragmentSeq</a></code>, <code><a href="wrProteo.html#topic+massDeFormula">massDeFormula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>AAfragSettings()
</code></pre>

<hr>
<h2 id='addMassModif'>Add modifications to peptide mass</h2><span id='topic+addMassModif'></span>

<h3>Description</h3>

<p>Adjust/add mass for modifications from 'modTy' to all peptides in 'pepTab' based on count 'cou' of occurances of modifications :
Either fixed or variable modifications will be added to the mass of initial peptides from argument <code>papTab</code>.
Terminal ionization (like 'b' or 'y' -fragments) is treated as fixed modification and the resulting masses will correspond to standard mono-protonated ions.
Since variable and fixed modification types can't be run in a single instance, the function has to get calles twice, it is recommended to always start with the fixed modfications,
In the case of fixed modifications (like defining 'b' or 'y' fragments) neutral peptide masses should be given to add the corresponding mass-shift (and to obtain mono-protonated ions).
In case of variable modifications (like 'd' or 'p'), the corresponding ions from the fixed modifications should get furnished to add the corresponding mass-shift,
the masses resulting from the initial fixed modifications run can be used.  
Note, that transforming a neutral precursor M into MH+ is also considered a modification. 
The results are also correct with obligatory fragments that can't occur the same time (eg x &amp; y ions can't be same time, need to make add'l lines...).
This function has a multiprocessor mode, with small data-sets (like the toy example below) there is typcally no gain in performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addMassModif(
  cou,
  pepTab,
  combTerm,
  modTy,
  lastIndex = NULL,
  modChem = NULL,
  basVarMod = "basMod",
  massTy = "mono",
  knownMods = NULL,
  nProc = 1,
  parallDefault = TRUE,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addMassModif_+3A_cou">cou</code></td>
<td>
<p>(list) list of matrixes with counts for number of modifications per peptide</p>
</td></tr>
<tr><td><code id="addMassModif_+3A_peptab">pepTab</code></td>
<td>
<p>(matrix) table with peptide properties</p>
</td></tr>
<tr><td><code id="addMassModif_+3A_combterm">combTerm</code></td>
<td>
<p>(matrix) table with separate rows for $basMod that are exclusive (ie can't be accumulated, eg x &amp; y ions)</p>
</td></tr>
<tr><td><code id="addMassModif_+3A_modty">modTy</code></td>
<td>
<p>(character) list of modification types to be considered</p>
</td></tr>
<tr><td><code id="addMassModif_+3A_lastindex">lastIndex</code></td>
<td>
<p>(integer) index-1 (ie last index from prev matrix) from which new peptide-variants should start from</p>
</td></tr>
<tr><td><code id="addMassModif_+3A_modchem">modChem</code></td>
<td>
<p>(character) optional modifications</p>
</td></tr>
<tr><td><code id="addMassModif_+3A_basvarmod">basVarMod</code></td>
<td>
<p>(character) toggle if fixed ('basMod') or variable ('varMod') modificatons should be calculated</p>
</td></tr>
<tr><td><code id="addMassModif_+3A_massty">massTy</code></td>
<td>
<p>(character) default 'mono'</p>
</td></tr>
<tr><td><code id="addMassModif_+3A_knownmods">knownMods</code></td>
<td>
<p>(list) optional custom definition whoch modification is N-term, etc (see <code><a href="#topic+AAfragSettings">AAfragSettings</a></code></p>
</td></tr>
<tr><td><code id="addMassModif_+3A_nproc">nProc</code></td>
<td>
<p>(integer) number of processors in case of multi-processor use (requires Bioconductor package <code>BiocParallel</code>)</p>
</td></tr>
<tr><td><code id="addMassModif_+3A_paralldefault">parallDefault</code></td>
<td>
<p>(logical) for use of other/previously set <code>register(bpstart())</code> in case <code>.parCombinateAllAndSum</code> is called</p>
</td></tr>
<tr><td><code id="addMassModif_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="addMassModif_+3A_debug">debug</code></td>
<td>
<p>(logical) for bug-tracking: more/enhanced messages and intermediate objects written in global name-space</p>
</td></tr>
<tr><td><code id="addMassModif_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of $pepTab (table of peptide as single charge positive ions), $abc ('representative' list of all combinations to add). Main result in $pepTab
</p>


<h3>See Also</h3>

<p><code><a href="wrMisc.html#topic+convToNum">convToNum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pep1 &lt;- c(pe1="KPEPTI")
# The table of possible terminal fragments (for simplicity terminal only)
pepTab1 &lt;- makeFragments(pep1, min=3, max=7, internFra=FALSE)
# Which fragment may be subject to how many modification (including ionization by H+)
cou1 &lt;- countPotModifAAs(pepTab=pepTab1, modTy=list(basMod=c("b","y")))
# Add modifications (here: ionize all pepptides by H+)
preMa1 &lt;- addMassModif(cou=cou1$cou, pepTab=pepTab1, combTerm=cou1$combTerm, 
  modTy=list(basMod=c("b","y")), basVarMod="basMod")
preMa1

## Example including variable modifications
modT3 &lt;- list(basMod=c("b","y"),varMod=c("p","h","d"))
cou3 &lt;- countPotModifAAs(pepTab=pepTab1, modTy=modT3)
## Now we re-use/inject the results for the fixed modificatons
preMa3 &lt;- addMassModif(cou=cou3$cou, pepTab=preMa1$pepTab, combTerm=cou1$combTerm, 
  modTy=modT3, basVarMod="varMod")
head(preMa3$pepTab,12)
</code></pre>

<hr>
<h2 id='checkModTy'>Check &amp; complete mixed of variable and fixed modifications</h2><span id='topic+checkModTy'></span>

<h3>Description</h3>

<p>Check &amp; complete settings for mixed of variable and fixed modifications.
The final format is a list with $basMod, $varMod and $varMo2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkModTy(modTy, knownMods = NULL, silent = TRUE, callFrom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkModTy_+3A_modty">modTy</code></td>
<td>
<p>(character) list of modification types to be considered</p>
</td></tr>
<tr><td><code id="checkModTy_+3A_knownmods">knownMods</code></td>
<td>
<p>(character) optonal custom list of known modifications, default from <code>AAfragSettings(outTy="all")$knownMods</code></p>
</td></tr>
<tr><td><code id="checkModTy_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="checkModTy_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>corrected list of mixed of variable and fixed modifications ($basMod, $varMod and $varMo2)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AAfragSettings">AAfragSettings</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>modTy1 &lt;- list(basMod=c("b","y","h"),varMod=c("p","o","q"))
checkModTy(modTy1)
</code></pre>

<hr>
<h2 id='combinateAllAndSum'>Full combinatorial and cumulative values</h2><span id='topic+combinateAllAndSum'></span>

<h3>Description</h3>

<p>Use for all preparing all combinations of non-compulsatory, ie variable, mass modifications
Variable modifications may or may not be present. Thus, for a given amino-acid with a variable modification two versions of the molecular weight need to be considered.
Most (variable) modifications are linked to a type of amino acid, like serine-residues for phosphorlylation.
Thus in this case, each instance of the amino acid in question may or may not be modified. 
So, for example if there are 2 serines, 0, 1 or 2 phosphorylation modifications may be present. 
For this reason the is the argument <code>nMax</code> to stay within biologically relevant ranges (external knowledge) and reduce complexity significantly.    
Some modifications are exclusive to others, argument <code>notSingle</code> : An (artificially occuring) de-phosphorylation event during fragmentation can only happen if the amino acid was already phosphorylated in the first place.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combinateAllAndSum(
  nMax,
  modVal,
  notSingle = NULL,
  silent = TRUE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combinateAllAndSum_+3A_nmax">nMax</code></td>
<td>
<p>(integer or data.frame with 1 line) maximum number of modifications</p>
</td></tr>
<tr><td><code id="combinateAllAndSum_+3A_modval">modVal</code></td>
<td>
<p>(numeric, has to have names !) the change of molecular mass introduced by given modifications (as specified by the name of the value)</p>
</td></tr>
<tr><td><code id="combinateAllAndSum_+3A_notsingle">notSingle</code></td>
<td>
<p>(character) names of 'modVal' where 1st element of 'notSingle'  cannot happen/appear if 2nd element not present (eg de-phospho/phosphorylation)</p>
</td></tr>
<tr><td><code id="combinateAllAndSum_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="combinateAllAndSum_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named (concatenated names of modVal) numeric vector
</p>


<h3>See Also</h3>

<p><code><a href="wrMisc.html#topic+convToNum">convToNum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## to follow easily the results, hypothetical mass-modification values were chosen
mo1 &lt;- c(a=10, b=1, c=0.1, d=0.01); nMa1 &lt;- c(1,2,0,3)
combinateAllAndSum(nMa1, mo1)
## # like 'b' for phospho &amp; 'd' for de-phospho (which can't happen without phospho event)
combinateAllAndSum(nMa1, mo1, notSingle=c("d","b"))    
</code></pre>

<hr>
<h2 id='countChildrenParent'>Identify Children/Parent settings as a+b=c</h2><span id='topic+countChildrenParent'></span>

<h3>Description</h3>

<p>This functions helps identifying fragments ('parent') characterized by a start- and end-position, that got split into 2  'children' fragments. 
So, each one of the new 'children' conserves either the start- or end-site of the parent and the the remaining ends are on consecutive positions.
For example if the sequence 'BCDEFG' (parent) gets split into 'BCD' (positions 1-3) and 'EFG' (positions 4-6), 
this will be identified as a children/parent 'family' which could be represented as 'a+b=c' case.
Note : At this point only settings with 2 children are considered, for more complex scenarions one may build trees using <code><a href="wrMisc.html#topic+buildTree">buildTree</a></code> (however, this function does not identify 'parents').
In proteomics-applications some start- and end-sites may occur multiple times, representing eg unmodified and modified versions of the same basal peptide-sequence.
Such duplicated start- and end-cases are handeled as allowed, a 'child' (characterized by its start- and end-position) may occur multiple times, and the 
corresponding redundant rownames (eg peptide sequence like 'BCD') will be conserved. However, information reflecting eg different peptide modifications must be stored separately.
If redudant start- and end-sites accur with different row-names, repeated start- and end-sites will display <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countChildrenParent(
  fragments,
  output = "count",
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countChildrenParent_+3A_fragments">fragments</code></td>
<td>
<p>(matrix or data.frame) integer values in 1st column, for start site of fragment, and in 2nd column as end-sites of fragments, rownames as IDs</p>
</td></tr>
<tr><td><code id="countChildrenParent_+3A_output">output</code></td>
<td>
<p>(character) choose simply returning results as counts or as list with <code>$counts</code> and <code>$detailIndex</code> (list with details showing each child1,child2 &amp; parent)</p>
</td></tr>
<tr><td><code id="countChildrenParent_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="countChildrenParent_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either numeric vector with cumulated counts (corresponding to rows of <code>fragments</code>) or list with $count and $detailIndex (list with indexes refering to non-redundant entries of all a+b=c settings identified)
</p>


<h3>See Also</h3>

<p><code><a href="wrMisc.html#topic+simpleFragFig">simpleFragFig</a></code> for graphical representation,<code>countSameStartEnd</code>; for building longer consecutive trees (without identification of 'parent') <code><a href="wrMisc.html#topic+buildTree">buildTree</a></code> and  <code>contribToContigPerFrag</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>frag3 &lt;- cbind(beg=c(4,2,3,7,13,13,15, 2,9,2,9), end=c(14,6,12,8,18,20,20, 8,12,12,18)) 
rownames(frag3) &lt;- c("K","A","E","B","C","D","F", "H","G","I","J")
countChildrenParent(frag3)
## example with duplicate start- and end-position positions
frag3c &lt;- cbind(beg=c(4,2,3,7, 7,13, 13,13,15, 2,9,2,9,9),
  end=c(14,6,12,8, 8,18, 18,20,20, 8,12,12,12,18))
rownames(frag3c) &lt;- c("K","A","E", "B","B", "C","C","D","F", "H","G","I","G","J")
countChildrenParent(frag3c, out="det")

</code></pre>

<hr>
<h2 id='countPotModifAAs'>Make table with counts of potential modification sites</h2><span id='topic+countPotModifAAs'></span>

<h3>Description</h3>

<p>Makes table 'cou' with counts of (potential) modification sites based on column 'seq' in matrix 'pepTab'.
Note: if multiple N-or C-term modifs, then only the first is shown in resulting table 'cou'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countPotModifAAs(
  pepTab,
  modTy,
  maxMod = c(p = 3, h = 1, k = 1, o = 1, m = 1, n = 1, u = 1, r = 1, s = 1),
  specAAMod = NULL,
  knownMods = NULL,
  silent = FALSE,
  callFrom = NULL,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countPotModifAAs_+3A_peptab">pepTab</code></td>
<td>
<p>(matrix) peptide sequences, start and end sites, typically result from <code><a href="#topic+makeFragments">makeFragments</a></code></p>
</td></tr>
<tr><td><code id="countPotModifAAs_+3A_modty">modTy</code></td>
<td>
<p>(list) modifications : $basMod for character vector of fixed modifications and $varMod for variable modifications. For one letter-code see AAfragSettings(&quot;modChem&quot;)</p>
</td></tr>
<tr><td><code id="countPotModifAAs_+3A_maxmod">maxMod</code></td>
<td>
<p>(integer) maximal number variable modifications will be considered in given fragment (may increase complexity and RAM consumption)</p>
</td></tr>
<tr><td><code id="countPotModifAAs_+3A_specaamod">specAAMod</code></td>
<td>
<p>(list) optional custom list showing which AA to be considered with which (one-letter) modification code (default <code><a href="#topic+AAfragSettings">AAfragSettings</a></code>)</p>
</td></tr>
<tr><td><code id="countPotModifAAs_+3A_knownmods">knownMods</code></td>
<td>
<p>(list) optional custom list showing which modification appears at what type of location, eg N-terminal, internal ... (default <code><a href="#topic+AAfragSettings">AAfragSettings</a></code>)</p>
</td></tr>
<tr><td><code id="countPotModifAAs_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="countPotModifAAs_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
<tr><td><code id="countPotModifAAs_+3A_debug">debug</code></td>
<td>
<p>(logical) for bug-tracking: more/enhanced messages and intermediate objects written in global name-space</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of matrixes $cou and $combTerm, with number of modifications per peptides (line in 'pepTab') for basMod, varMod &amp; varMo2
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AAfragSettings">AAfragSettings</a></code>, <code><a href="#topic+makeFragments">makeFragments</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>protP2 &lt;- c(mesp="MESPEPTIDES", pepe="PEPEPEP")
pepTab1 &lt;- makeFragments(protTab=protP2, minFra=6, internFr=TRUE, massTy="mono")
cou1 &lt;- countPotModifAAs(pepTab=pepTab1, modTy=list(basMod=c("b","y"),
  varMod=c("p","h")), debug=FALSE)
modTy2 &lt;- list(basMod=c("b","y","h"), varMod=c("x","p","o","q","e","j"))
cou2 &lt;- countPotModifAAs(pepTab=pepTab1, modTy=modTy2)
</code></pre>

<hr>
<h2 id='evalIsoFragm'>Evaluate selected lines of pepTab (iso-mass) for preferential cutting sites</h2><span id='topic+evalIsoFragm'></span>

<h3>Description</h3>

<p>Evaluate selected lines of pepTab (iso-mass) for preferential cutting sites. Such sites are taken by default from <code>.prefFragPattern()</code> simplified from a publication 
by the Kelleher group (Haverland 2017, J Am Soc Mass Spectrom) or can be furnished by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalIsoFragm(
  z,
  prefFragPat = NULL,
  seqCol = "seq",
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalIsoFragm_+3A_z">z</code></td>
<td>
<p>(matrix) main input, must contain cols specified as seqCol and &quot;no&quot;,&quot;tailAA&quot;,&quot;precAA&quot;</p>
</td></tr>
<tr><td><code id="evalIsoFragm_+3A_preffragpat">prefFragPat</code></td>
<td>
<p>(matrix) specifies preferential fragmentation (which combination of AA to consider cols cTer,nTer,score), default made by <code>.prefFragPattern()</code></p>
</td></tr>
<tr><td><code id="evalIsoFragm_+3A_seqcol">seqCol</code></td>
<td>
<p>(character) column names for the column containing the sequence to search for preferential cutting sites</p>
</td></tr>
<tr><td><code id="evalIsoFragm_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="evalIsoFragm_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allows easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>line ID-numbers (pepTab[,&quot;no&quot;]) for those below median score (ie to remove from pepTab) or NULL if nothing to remove due to preferential fragmentation
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeFragments">makeFragments</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>peTab &lt;- matrix(c("9","13","14","15", "LPVIAGHEAAG","PVIAGHEAAGI","EKKPFSI","KKPFSIE", 
  "P","L","E","E", "I","V","E","E"),nr=4,dimnames=list(NULL,c("no","seq","precAA","tailAA")))
evalIsoFragm(peTab)
</code></pre>

<hr>
<h2 id='fragmentSeq'>Fragment protein or peptide sequence</h2><span id='topic+fragmentSeq'></span>

<h3>Description</h3>

<p>Makes internal/terminal fragments of a SINGLE peptide/protein input (as single letter amino-acid code) and returns list of all possible sequences ($full, $Nter, $Cter, $inter).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fragmentSeq(
  sequ,
  minSize = 3,
  maxSize = 300,
  internFragments = TRUE,
  separTerm = FALSE,
  keepRedSeqs = TRUE,
  prefName = NULL,
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fragmentSeq_+3A_sequ">sequ</code></td>
<td>
<p>(character, length=1) sequence used for fragmenting, as as mono-aminoacid letter code (so that cuting will be perfomed between all the letters/characters)</p>
</td></tr>
<tr><td><code id="fragmentSeq_+3A_minsize">minSize</code></td>
<td>
<p>(integer) min number of AA residues for considering peptide fragments</p>
</td></tr>
<tr><td><code id="fragmentSeq_+3A_maxsize">maxSize</code></td>
<td>
<p>(integer) max number of AA residues for considering peptide fragments</p>
</td></tr>
<tr><td><code id="fragmentSeq_+3A_internfragments">internFragments</code></td>
<td>
<p>(logical) logical (return only terminal fragments if 'FALSE')</p>
</td></tr>
<tr><td><code id="fragmentSeq_+3A_separterm">separTerm</code></td>
<td>
<p>(logical) if 'TRUE', separate N-terminal, C-terminal and internal fragments in list</p>
</td></tr>
<tr><td><code id="fragmentSeq_+3A_keepredseqs">keepRedSeqs</code></td>
<td>
<p>(logical) if 'FALSE' remove fragments with redundant content (but my be from different origin in 'sequ'); remove redundant so far only when no separation of Nterm/Cterm/intern as list</p>
</td></tr>
<tr><td><code id="fragmentSeq_+3A_prefname">prefName</code></td>
<td>
<p>(logical) alternative name for all fragments (default the sequence itself), avoid separators '.' and '-'</p>
</td></tr>
<tr><td><code id="fragmentSeq_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="fragmentSeq_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with mass
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeFragments">makeFragments</a></code>;   <code><a href="wrProteo.html#topic+convAASeq2mass">convAASeq2mass</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fragmentSeq("ABCDE")
fragmentSeq("ABCDE", minSize=3, internFragments=FALSE)
fragmentSeq("ABCDE", minSize=3, internFragments=TRUE)

## Run multiple peptides/proteins
twoPep &lt;- cbind(c("a","ABCABCA"), c("e","EFGEFGEF"))
apply(twoPep, 2, function(x) fragmentSeq(x[2], mi=3, kee=FALSE, sep=TRUE, pre=x[1]))

## Ubiquitin example
P0CG48 &lt;- "MQIFVKTLTGKTITLEVEPSDTIENVKAKIQDKEGIPPDQQRLIFAGKQLEDGRTLSDYNIQKESTLHLVLRLRGG"  
system.time( fra1 &lt;- (fragmentSeq(P0CG48, mi=5, kee=FALSE)))      # &lt; 0.5 sec  

</code></pre>

<hr>
<h2 id='identifFixedModif'>Identify Fixed Modifications</h2><span id='topic+identifFixedModif'></span>

<h3>Description</h3>

<p>Identify peptide/protein fragment based on experimental m/z values 'expMass' for given range of aa-length.
Internally all possible fragments will be predicted and their mass compared to the experimental values (argument <code>expMass</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identifFixedModif(
  prot,
  expMass,
  minFragSize = 5,
  maxFragSize = 60,
  indexStart = 1,
  suplPepTab = NULL,
  internFra = TRUE,
  filtChargeCatch = TRUE,
  maxMod = c(p = 3, h = 1, k = 1, o = 1, m = 1, n = 1, u = 1, r = 1, s = 1),
  modTy = NULL,
  specModif = NULL,
  knownMods = NULL,
  identMeas = "ppm",
  limitIdent = 5,
  filtAmbiguous = FALSE,
  recalibrate = FALSE,
  chargeCatchFilter = TRUE,
  massTy = "mono",
  prefFragPat = NULL,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identifFixedModif_+3A_prot">prot</code></td>
<td>
<p>(character) amino-acid sequene of peptide or protein</p>
</td></tr>
<tr><td><code id="identifFixedModif_+3A_expmass">expMass</code></td>
<td>
<p>(numeric) erperimental masses to identify peptides from</p>
</td></tr>
<tr><td><code id="identifFixedModif_+3A_minfragsize">minFragSize</code></td>
<td>
<p>(integer) min number of AA residues for considering peptide fragments</p>
</td></tr>
<tr><td><code id="identifFixedModif_+3A_maxfragsize">maxFragSize</code></td>
<td>
<p>(integer) max number of AA residues for considering peptide fragments</p>
</td></tr>
<tr><td><code id="identifFixedModif_+3A_indexstart">indexStart</code></td>
<td>
<p>(integer) for starting at correct index (if not 1)</p>
</td></tr>
<tr><td><code id="identifFixedModif_+3A_suplpeptab">suplPepTab</code></td>
<td>
<p>(matrix) additional peptides to be add to theoretical peptides</p>
</td></tr>
<tr><td><code id="identifFixedModif_+3A_internfra">internFra</code></td>
<td>
<p>(logical) decide whether internal fragments should be cosiered</p>
</td></tr>
<tr><td><code id="identifFixedModif_+3A_filtchargecatch">filtChargeCatch</code></td>
<td>
<p>(logical) by default removing of all fragments not containing a (polar) charge-cathing residue</p>
</td></tr>
<tr><td><code id="identifFixedModif_+3A_maxmod">maxMod</code></td>
<td>
<p>(integer) maximum number of residue modifications to be consiered in fragments (values &gt;1 will increase complexity and RAM consumption)</p>
</td></tr>
<tr><td><code id="identifFixedModif_+3A_modty">modTy</code></td>
<td>
<p>(character) type of fixed and variable modifications</p>
</td></tr>
<tr><td><code id="identifFixedModif_+3A_specmodif">specModif</code></td>
<td>
<p>(list) supplemental custom fixed or variable modifications (eg Zn++ at given residue)</p>
</td></tr>
<tr><td><code id="identifFixedModif_+3A_knownmods">knownMods</code></td>
<td>
<p>(character) optional custom alternative to <code>AAfragSettings(ou="all")$knownMods</code></p>
</td></tr>
<tr><td><code id="identifFixedModif_+3A_identmeas">identMeas</code></td>
<td>
<p>(character) default 'ppm'</p>
</td></tr>
<tr><td><code id="identifFixedModif_+3A_limitident">limitIdent</code></td>
<td>
<p>(character) thershold for identification in 'identMeas' units</p>
</td></tr>
<tr><td><code id="identifFixedModif_+3A_filtambiguous">filtAmbiguous</code></td>
<td>
<p>(logical) allows filtering/removing ambiguous results (ie same mass peptides)</p>
</td></tr>
<tr><td><code id="identifFixedModif_+3A_recalibrate">recalibrate</code></td>
<td>
<p>(logical or numeric) may be direct recalibration-factor (numeric,length=1), if 'TRUE'  fresh determination of 'recalibFact' or 'FALSE' (no action);  final recalibration-factor used exported in result as $recalibFact</p>
</td></tr>
<tr><td><code id="identifFixedModif_+3A_chargecatchfilter">chargeCatchFilter</code></td>
<td>
<p>(logical) optionally remove all peptides not containing charge-catch AAs (K, R, H, defined via <code>.chargeCatchingAA()</code> )</p>
</td></tr>
<tr><td><code id="identifFixedModif_+3A_massty">massTy</code></td>
<td>
<p>(character) 'mono' or 'average'</p>
</td></tr>
<tr><td><code id="identifFixedModif_+3A_preffragpat">prefFragPat</code></td>
<td>
<p>(numeric) pattern for preferential fragmentation (see also Haverland 2017), if <code>NULL</code> default will be taken (in function <code>evalIsoFragm</code>) from <code>.prefFragPattern()</code></p>
</td></tr>
<tr><td><code id="identifFixedModif_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="identifFixedModif_+3A_debug">debug</code></td>
<td>
<p>(logical) additional messages and objects exportet to current session for debugging</p>
</td></tr>
<tr><td><code id="identifFixedModif_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list, ie result of massMatch() on 'pepTab' and 'expMass'
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeFragments">makeFragments</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>protP &lt;- c(protP="PEPTIDEKR")
obsMassX &lt;- cbind(a=c(199.1077,296.1605,397.2082,510.2922,625.3192),
  b=c(227.1026,324.1554,425.2031,538.2871,653.3141),
  x=c(729.2937,600.2511,503.1984,402.1507,289.0666),
  y=c(703.3145,574.2719,477.2191,376.1714,263.0874))
rownames(obsMassX) &lt;- c("E","P","T","I","D")       # all 1 &amp; 7 ions not included
identP1 &lt;- identifFixedModif(prot=protP, expMass=as.numeric(obsMassX), minFragSize=2, 
  maxFragSize=7,modTy=list(basMod=c("b","y")))     # looks ok
identP2 &lt;- identifFixedModif(prot=protP, expMass=as.numeric(obsMassX), minFragSize=2, 
 maxFragSize=7, modTy=list(basMod=c("a","x"), varMod=c("h","o","r","m")))
 head(identP1$preMa,n=17)     # predicted masses incl fixed modif
 head(identP2$preMa,n=17)     # predicted masses incl fixed modif 
</code></pre>

<hr>
<h2 id='makeFragments'>Make terminal and internal fragments from proteins</h2><span id='topic+makeFragments'></span>

<h3>Description</h3>

<p>Makes terminal and internal fragments based on protein-sequence and present as matrix including heading and/or tailing amino-acid or theoretical molecular mass of all fragments.
As the number of theoretically possible fragments increases with the size of the peptide/protein treated it is recommended to adopt arguments like <code>masFragSize</code> to 
realizstic values for the type of mass spectrometer used, since efficient filtering will reduce considerably the amount of memory (RAM) needed and will improve overal performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeFragments(
  protTab,
  minFragSize = 6,
  maxFragSize = 300,
  internFra = TRUE,
  knownMods = NULL,
  redRedundSeq = FALSE,
  prefFragPat = NULL,
  remNonConfPrefFragm = TRUE,
  ambigLab = c(duplSequence = "duplSequence", isoMass = "isoMass"),
  massTy = "mono",
  specModif = NULL,
  silent = FALSE,
  debug = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeFragments_+3A_prottab">protTab</code></td>
<td>
<p>(character or matrix) named vector of protein-seqences to fragment or matrix (character) with lines for initial proteins/peptides, cols as name/sequence/mass</p>
</td></tr>
<tr><td><code id="makeFragments_+3A_minfragsize">minFragSize</code></td>
<td>
<p>(integer) minimum number of amino-acids for being considered</p>
</td></tr>
<tr><td><code id="makeFragments_+3A_maxfragsize">maxFragSize</code></td>
<td>
<p>(integer) maximum number of amino-acids for being considered</p>
</td></tr>
<tr><td><code id="makeFragments_+3A_internfra">internFra</code></td>
<td>
<p>(logical) toggle if internal framents will be produced or not</p>
</td></tr>
<tr><td><code id="makeFragments_+3A_knownmods">knownMods</code></td>
<td>
<p>(character) optional custom alternative to <code>AAfragSettings(ou="all")$knownMods</code></p>
</td></tr>
<tr><td><code id="makeFragments_+3A_redredundseq">redRedundSeq</code></td>
<td>
<p>(logical) reduce redundant sequences to 1st appearance in all further treatments</p>
</td></tr>
<tr><td><code id="makeFragments_+3A_preffragpat">prefFragPat</code></td>
<td>
<p>(matrix) for preferential fragmentation rules (see also <code>.prefFragPattern</code>)</p>
</td></tr>
<tr><td><code id="makeFragments_+3A_remnonconfpreffragm">remNonConfPrefFragm</code></td>
<td>
<p>(logical) allows to remove (peptide-)fragments non conform with preferential fragmentation rules (using <code>evalIsoFragm</code>)</p>
</td></tr>
<tr><td><code id="makeFragments_+3A_ambiglab">ambigLab</code></td>
<td>
<p>(character) text-labels for ambiguities (first for duplicated sequences second for iso-mass)</p>
</td></tr>
<tr><td><code id="makeFragments_+3A_massty">massTy</code></td>
<td>
<p>(character) default 'mono' for mono-isotopic masses (alterative 'average')</p>
</td></tr>
<tr><td><code id="makeFragments_+3A_specmodif">specModif</code></td>
<td>
<p>(list) supplemental custom fixed or variable modifications (eg Zn++ at given residue)</p>
</td></tr>
<tr><td><code id="makeFragments_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="makeFragments_+3A_debug">debug</code></td>
<td>
<p>(logical) for bug-tracking: more/enhanced messages</p>
</td></tr>
<tr><td><code id="makeFragments_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with fragment sequence, mass, start- and end-position, heading and tailing AA (or NA if terminal fragment)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeFragments">makeFragments</a></code>;  <code><a href="#topic+evalIsoFragm">evalIsoFragm</a></code>, from package <a href="https://CRAN.R-project.org/package=wrProteo">wrProteo</a> <code><a href="wrProteo.html#topic+convAASeq2mass">convAASeq2mass</a></code>, <code><a href="wrProteo.html#topic+AAmass">AAmass</a></code>, <code><a href="wrProteo.html#topic+massDeFormula">massDeFormula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>protP &lt;- c(protP="PEPTIDE")
pepT1 &lt;- makeFragments(protTab=protP, minFragSize=2, maxFragSize=9, internFra=TRUE)
tail(pepT1)
</code></pre>

<hr>
<h2 id='plotNTheor'>Plot the number of theoretical random fragments</h2><span id='topic+plotNTheor'></span>

<h3>Description</h3>

<p>This simple function allows plotting the expected number of theoretical fragments from random fragmentation of peptides/proteins (in mass spectrometry).
Here, only the pure fragmentation without any variable fragmentation is considered, all fragment-sizes are included (ie, no gating). 
For simplicity, possible (variable) modifications like loss of neutrals, etc, are not considered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotNTheor(
  x,
  tit = "Number of term and intern fragm",
  xlab = "Number of aa",
  ylab = "",
  col = 2:3,
  log = "",
  mark = NULL,
  cexMark = 0.75
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotNTheor_+3A_x">x</code></td>
<td>
<p>(integer) length (in amino-acids) of input peptides/proteins to be considered</p>
</td></tr>
<tr><td><code id="plotNTheor_+3A_tit">tit</code></td>
<td>
<p>(character) custom title</p>
</td></tr>
<tr><td><code id="plotNTheor_+3A_xlab">xlab</code></td>
<td>
<p>(character) custom x-axis label</p>
</td></tr>
<tr><td><code id="plotNTheor_+3A_ylab">ylab</code></td>
<td>
<p>(character) custom y-axis label</p>
</td></tr>
<tr><td><code id="plotNTheor_+3A_col">col</code></td>
<td>
<p>(character or integer) cutsom colors</p>
</td></tr>
<tr><td><code id="plotNTheor_+3A_log">log</code></td>
<td>
<p>(character) define which axis should be log (use &quot;xy&quot; for drawing both x- and y-axis as log-scale)</p>
</td></tr>
<tr><td><code id="plotNTheor_+3A_mark">mark</code></td>
<td>
<p>(matrix) first column for text and second column for where it should be stated along the top border of the figure (x-coordinate)</p>
</td></tr>
<tr><td><code id="plotNTheor_+3A_cexmark">cexMark</code></td>
<td>
<p>(numeric) cex expansion-factor for text from argument <code>mark</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>figure only
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AAfragSettings">AAfragSettings</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>marks &lt;- data.frame(name=c("Ubiquitin\n76aa", "Glutamate dehydrogenase 1\n501aa"),
  length=c(76,501))
plotNTheor(x=20:750, log="", mark=marks)
</code></pre>

<hr>
<h2 id='scoreChargeCatch'>Scoring of charge catching potential for peptides</h2><span id='topic+scoreChargeCatch'></span>

<h3>Description</h3>

<p>Make score based on cumulative search for AA with given potential to catch charge (H+, or optionally any charge).
Note : at current cumulative scoring large peptides may get priviliged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoreChargeCatch(
  resTab,
  pepCol = "seq",
  scale01 = TRUE,
  chargeMode = "pos",
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scoreChargeCatch_+3A_restab">resTab</code></td>
<td>
<p>(matrix or data.frame) matrix or data.frame of results for SINGLE protein (here only the column specified with argument 'pepCol' will be used)</p>
</td></tr>
<tr><td><code id="scoreChargeCatch_+3A_pepcol">pepCol</code></td>
<td>
<p>(character) column name of 'resTab' containing the peptide sequence to be scored</p>
</td></tr>
<tr><td><code id="scoreChargeCatch_+3A_scale01">scale01</code></td>
<td>
<p>(logical) linear rescale output to maximum 1.0</p>
</td></tr>
<tr><td><code id="scoreChargeCatch_+3A_chargemode">chargeMode</code></td>
<td>
<p>(character) this value may be 'pos' (default) for the positively charged amino-acids K,R and H or, 
if this argument has any other value, than all charged amino-acids (K,R,H, S,T,N,Q, D,E, W and Y) will be considered.</p>
</td></tr>
<tr><td><code id="scoreChargeCatch_+3A_silent">silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td></tr>
<tr><td><code id="scoreChargeCatch_+3A_callfrom">callFrom</code></td>
<td>
<p>(character) allow easier tracking of message(s) produced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with score for each peptide of resTab (even if <code>scale01=TRUE</code> minimum may be &gt;0 if all peptides do contain charge-catching AAs)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fragmentSeq">fragmentSeq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>resTa &lt;- matrix(c(1:4,"PEPTID","PEPTIK","PEPTRK","AGV"), ncol=2,
  dimnames=list(NULL,c("predInd","seq"))) 
scoreChargeCatch(resTa)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
