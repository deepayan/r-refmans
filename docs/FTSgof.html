<!DOCTYPE html><html lang="en-US"><head><title>Help for package FTSgof</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FTSgof}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dgp.far'><p>FAR(p) Data Generator</p></a></li>
<li><a href='#dgp.fgarch'><p>Functional ARCH/GARCH Process Generator</p></a></li>
<li><a href='#dgp.ou'><p>Ornstein–Uhlenbeck Process Generator</p></a></li>
<li><a href='#EF'><p>Daily Eurodollar Futures Curves</p></a></li>
<li><a href='#fACF'><p>Functional Autocorrelation Function (fACF) Plot</p></a></li>
<li><a href='#fACF_test'><p>Test based on fACF</p></a></li>
<li><a href='#fCH_test'><p>Test for Conditional Heteroscedasticity of Functional Time Series</p></a></li>
<li><a href='#fport_eda'><p>Exploratory Data Analysis for Functional Time Series.</p></a></li>
<li><a href='#fport_gof'><p>Goodness-of-fit Tests for Functional Times Series</p></a></li>
<li><a href='#fport_wn'><p>White Noise Hypothesis Tests for Functional Times Series</p></a></li>
<li><a href='#fSACF'><p>Functional Spherical Autocorrelation Function (fSACF) Plot</p></a></li>
<li><a href='#fSACF_test'><p>Test based on fSACF</p></a></li>
<li><a href='#gof_far'><p>Goodness-of-fit test for FAR(1)</p></a></li>
<li><a href='#gof_fGARCH'><p>Goodness-of-fit Test for Functional ARCH/GARCH Model</p></a></li>
<li><a href='#OCIDR'><p>Convert Original Price Data to OCIDRs</p></a></li>
<li><a href='#rainbow3D'><p>3D Rainbow Plot for Functional Time Series</p></a></li>
<li><a href='#sp500'><p>S&amp;P 500 Index Price Data</p></a></li>
<li><a href='#Spanish_elec'><p>Spanish electricity daily price profiles</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>White Noise and Goodness-of-Fit Tests for Functional Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mihyun Kim &lt;mihyun.kim@mail.wvu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>It offers comprehensive tools for the analysis of functional
    time series data, focusing on white noise hypothesis testing and
    goodness-of-fit evaluations, alongside functions for
    simulating data and advanced visualization techniques, such as 3D
    rainbow plots. These methods are described in Kokoszka, Rice, and Shang (2017)  &lt;<a href="https://doi.org/10.1016%2Fj.jmva.2017.08.004">doi:10.1016/j.jmva.2017.08.004</a>&gt;, 
    Yeh, Rice, and Dubin (2023) &lt;<a href="https://doi.org/10.1214%2F23-EJS2112">doi:10.1214/23-EJS2112</a>&gt;, Kim, Kokoszka, and Rice (2023) &lt;<a href="https://doi.org/10.1214%2F23-ss143">doi:10.1214/23-ss143</a>&gt;, and 
    Rice, Wirjanto, and Zhao (2020) &lt;<a href="https://doi.org/10.1111%2Fjtsa.12532">doi:10.1111/jtsa.12532</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>sde, graphics, stats, rgl, fda, nloptr, sfsmisc, MASS</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/veritasmih/FTSgof">https://github.com/veritasmih/FTSgof</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/veritasmih/FTSgof/issues">https://github.com/veritasmih/FTSgof/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>XQuartz (https://www.xquartz.org/)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-02 20:49:12 UTC; mk00095</td>
</tr>
<tr>
<td>Author:</td>
<td>Mihyun Kim [aut, cre],
  Chi-Kuang Yeh <a href="https://orcid.org/0000-0001-7057-2096"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Yuqian Zhao [aut],
  Gregory Rice [ctb]</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-03 19:30:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='dgp.far'>FAR(p) Data Generator</h2><span id='topic+dgp.far'></span>

<h3>Description</h3>

<p>It generates functional data that follows a functional autoregressive process of order <code class="reqn">p</code>, denoted as FAR(p). The generated data consists of curves evaluated at discrete grid points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgp.far(J, N, S = 0.5, p = 1, kernel = "Gaussian", burn_in = 50)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dgp.far_+3A_j">J</code></td>
<td>
<p>The number of grid points for each curve observation.</p>
</td></tr>
<tr><td><code id="dgp.far_+3A_n">N</code></td>
<td>
<p>The sample size, representing the number of curves to be generated.</p>
</td></tr>
<tr><td><code id="dgp.far_+3A_s">S</code></td>
<td>
<p>The serial dependence factor for the kernel used in the FAR(p) process. Default is 0.5.</p>
</td></tr>
<tr><td><code id="dgp.far_+3A_p">p</code></td>
<td>
<p>The order of the autoregressive process. Default is 1.</p>
</td></tr>
<tr><td><code id="dgp.far_+3A_kernel">kernel</code></td>
<td>
<p>The type of kernel function <code class="reqn">\psi</code> used for the autoregressive process. Can be &quot;Gaussian&quot; or &quot;Wiener&quot;. Default is &quot;Gaussian&quot;.</p>
</td></tr>
<tr><td><code id="dgp.far_+3A_burn_in">burn_in</code></td>
<td>
<p>The number of initial points discarded to eliminate transient effects. Default is 50.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functional autoregressive model of order <code class="reqn">p</code> is given by:
</p>
<p style="text-align: center;"><code class="reqn">X_i(t) -\mu(t) = \sum_{j=1}^{p} \Psi(X_{i-j}-\mu)(t) + \epsilon_i(t),</code>
</p>

<p>where <code class="reqn">\Psi(X)(t) = \int \psi(t,s)X(s) dt</code> is the kernel operator, and <code class="reqn">\epsilon_i(t)</code> are i.i.d. errors generated from a standard Brownian motion process.
The mean function <code class="reqn">\mu</code> is assumed to be zero in the generating process.
</p>


<h3>Value</h3>

<p>A <code class="reqn">J \times N</code> matrix where each column contains a curve evaluated at <code class="reqn">J</code> grid points, generated from the FAR(p) model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate discrete evaluations of 200 curves, each observed at 50 grid points.
yd_far = dgp.far(J = 50, N = 200, S = 0.7, p = 2, kernel = "Gaussian", burn_in = 50)


</code></pre>

<hr>
<h2 id='dgp.fgarch'>Functional ARCH/GARCH Process Generator</h2><span id='topic+dgp.fgarch'></span>

<h3>Description</h3>

<p>It generates functional curve data following the functional ARCH(1) or GARCH(1,1) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgp.fgarch(J, N, type, alpha_par = NULL, beta_par = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dgp.fgarch_+3A_j">J</code></td>
<td>
<p>The number of grid point in each curve observation.</p>
</td></tr>
<tr><td><code id="dgp.fgarch_+3A_n">N</code></td>
<td>
<p>The sample size.</p>
</td></tr>
<tr><td><code id="dgp.fgarch_+3A_type">type</code></td>
<td>
<p>A string to switch data generating process between &quot;arch&quot; - functional ARCH and &quot;garch&quot; - functional GARCH.</p>
</td></tr>
<tr><td><code id="dgp.fgarch_+3A_alpha_par">alpha_par</code></td>
<td>
<p>The ARCH kernel coefficient function in the conditional volatility equation. If it is missing, &quot;<code class="reqn">12 t (1-t) s (1-s)</code>&quot; is used to generate FGARCH, and &quot;<code class="reqn">16 t (1-t) s (1-s)</code>&quot; is used to generate FARCH, for <code class="reqn">t\in[0,1]</code> and <code class="reqn">s\in[0,1]</code>.</p>
</td></tr>
<tr><td><code id="dgp.fgarch_+3A_beta_par">beta_par</code></td>
<td>
<p>The GARCH kernel coefficient function in the conditional volatility equation. If it is missing, &quot;<code class="reqn">12 t (1-t) s (1-s)</code>&quot; is used to generate FGARCH, for <code class="reqn">t\in[0,1]</code> and <code class="reqn">s\in[0,1]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">X_i(t)</code> follows an FARCH(1) process,<br />
<code class="reqn">X_i(t)=\sigma_i(t)\varepsilon_i(t)</code>, <code class="reqn">t \in [0,1]</code>,<br />
<code class="reqn">\sigma_i^2(t)=\omega(t)+\int \alpha(t,s) X^2_{i-1}(s)ds</code>.<br />
</p>
<p>If <code class="reqn">X_i(t)</code> follows an FGARCH(1,1) process,<br />
<code class="reqn">X_i(t)=\sigma_i(t)\varepsilon_i(t)</code>, <code class="reqn">t \in [0,1]</code>,<br />
<code class="reqn">\sigma_i^2(t)=\omega(t)+\int \alpha(t,s) X^2_{i-1}(s)ds+\int \beta(t,s) \sigma^2_{i-1}(s)ds</code>,<br />
where the innovation <code class="reqn">\varepsilon_i(t)</code> follows an Ornstein–Uhlenbeck process <code><a href="#topic+dgp.ou">dgp.ou</a></code>, and the constant coefficient <code class="reqn">\omega(t)=0.1t(1-t)</code>.
</p>


<h3>Value</h3>

<p>List of generated processes:
</p>
<p>garch_mat: FARCH/GARCH sequences, where the finite realization of curves are stored in columns;
</p>
<p>sigma_mat: Conditional volatility sequences,  where the finite realization of curves are stored in columns.
</p>


<h3>References</h3>

<p>[1] Hormann, S., Horvath, L., Reeder, R. (2013). A functional version of the ARCH model. Econometric Theory. 29(2), 267-288. &lt;doi:10.1017/S0266466612000345&gt;.<br />
[2] Aue, A., Horvath, L., F. Pellatt, D. (2017). Functional generalized autoregressive conditional heteroskedasticity. Journal of Time Series Analysis. 38(1), 3-21. &lt;doi:10.1111/jtsa.12192&gt;.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dgp.ou">dgp.ou</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate discrete evaluations of 100 fGARCH curves that
# each curve is realized on 50 grid points.
yd = dgp.fgarch(J = 50, N = 100, type = "garch")
yd_garch = yd$garch_mat

</code></pre>

<hr>
<h2 id='dgp.ou'>Ornstein–Uhlenbeck Process Generator</h2><span id='topic+dgp.ou'></span>

<h3>Description</h3>

<p>It generates iid functional curve data following the Ornstein–Uhlenbeck process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgp.ou(J, N)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dgp.ou_+3A_j">J</code></td>
<td>
<p>The number of grid points in each curve observation.</p>
</td></tr>
<tr><td><code id="dgp.ou_+3A_n">N</code></td>
<td>
<p>The sample size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Ornstein–Uhlenbeck process is given by:
<code class="reqn">x_i(t)=e^{-t/2}W_i(e^t)</code>, <code class="reqn">t \in [0,1]</code>,<br />
where <code class="reqn">W_i(t)</code> is a standard Brownian Motion.
</p>


<h3>Value</h3>

<p>A (grid points) x (number of observations) matrix for iid sequences, where the finite realization of curves are stored in columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Generate discrete evaluations of 100 iid curves
# that each curve is realized on 50 grid points.
yd_ou = dgp.ou(J = 50, N = 100)


</code></pre>

<hr>
<h2 id='EF'>Daily Eurodollar Futures Curves</h2><span id='topic+EF'></span>

<h3>Description</h3>

<p>This dataset contains daily Eurodollar futures curves from February 9, 1998 to June 5, 1998 (<code class="reqn">N=82</code>).
A Eurodollar futures contract represents an obligation to deliver 1,000,000 USD to a bank
outside the United States at a specified time.
The Eurodollar futures curves consist of daily settlement prices for these contracts,
available at monthly delivery dates for the first six months and quarterly delivery dates
up to 10 years into the future. These curves are preprocessed using cubic splines,
following Kargin and Onatski (2008), to transform the raw data into smooth curves on
a grid of 114 equally spaced points (<code class="reqn">J=114</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(EF)
</code></pre>


<h3>Format</h3>

<p>A matrix with columns representing
the daily settlement prices as observed functions.
</p>


<h3>References</h3>

<p>Kargin V, Onatski A (2008). Curve forecasting by functional autoregression. Journal of
Multivariate Analysis, 99, 2508–2526.
</p>

<hr>
<h2 id='fACF'>Functional Autocorrelation Function (fACF) Plot</h2><span id='topic+fACF'></span>

<h3>Description</h3>

<p>This function provides a graphical summary of the fACF of a functional time series (FTS) across different time lags <code class="reqn">h = 1:H</code>.
It also plots the <code class="reqn">100 (1-\alpha)\%</code> confidence bounds, developed under both weak white noise (WWN) and strong white noise (SWN) assumptions for all lags <code class="reqn">h = 1:H</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fACF(f_data, H = 20, alpha = 0.05, wwn_bound = FALSE, M = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fACF_+3A_f_data">f_data</code></td>
<td>
<p>A <code class="reqn">J \times N</code> matrix of functional time series data, where <code class="reqn">J</code> is the number of discrete points in a grid and <code class="reqn">N</code> is the sample size.</p>
</td></tr>
<tr><td><code id="fACF_+3A_h">H</code></td>
<td>
<p>A positive integer value. The maximum lag for which to compute the coefficients and confidence bounds.</p>
</td></tr>
<tr><td><code id="fACF_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value between 0 and 1 specifying the significance level to be used for the confidence bounds.</p>
</td></tr>
<tr><td><code id="fACF_+3A_wwn_bound">wwn_bound</code></td>
<td>
<p>A Boolean value allowing the user to turn on the WWN bound. FALSE by default. Speeds down computation when TRUE.</p>
</td></tr>
<tr><td><code id="fACF_+3A_m">M</code></td>
<td>
<p>A positive integer value. The number of Monte-Carlo simulations used to compute the confidence bounds under the WWN assumption. 
If <code class="reqn">M = NULL, M = \text{floor}((\max(150 - N, 0) + \max(100 - J, 0) + (J / \sqrt{2})))</code>,
ensuring that the number of Monte Carlo simulations is adequate based on the dataset size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes and plots functional autocorrelation coefficients at lag <code class="reqn">h</code>, for <code class="reqn">h \in 1:H</code>. Given functional observations, <code class="reqn">X_1,\ldots, X_N</code>, the sample autocovariance kernel at lag <code class="reqn">h</code> can be computed by
</p>
<p style="text-align: center;"><code class="reqn">
\hat{\gamma}_{N,h}(t,s)=\frac{1}{N}\sum_{i=1}^{N-h} (X_i(t)-\bar{X}_N(t))(X_{i+h}(s)-\bar{X}_N(s)),\ \ \ \ 0 \le h &lt; N,
</code>
</p>

<p>where <code class="reqn">\bar{X}_N(t) = \frac{1}{N} \sum_{i=1}^N X_i(t)</code>. Then, the fACF at lag <code class="reqn">h</code> is defined by measuring
the magnitude (<code class="reqn">L^2</code>-norm) of the lagged autocovariance kernel <code class="reqn">\hat\gamma_{N,h}</code>:
</p>
<p style="text-align: center;"><code class="reqn">
\hat\rho_h =\frac{\|\hat{\gamma}_{N,h}\|}{\int \hat{\gamma}_{N,0}(t,t)dt}, \ \ \ \ \|\hat{\gamma}_{N,h}\|^2=\iint  \hat{\gamma}_{N,h}^2(t,s) dtds.
</code>
</p>

<p>This function plots estimated asymptotic <code class="reqn">100 (1-\alpha)\%</code> confidence bounds under the WWN assumption.
Additionally, it computes similar (constant) bounds under the SWN assumption.
</p>


<h3>Value</h3>

<p>Plot of the estimated functional autocorrelation coefficients for lags <code class="reqn">h \in 1:H</code> with the WWN
<code class="reqn">100 (1-\alpha)\%</code> upper confidence bound for each lag, as well as the constant SWN
<code class="reqn">100 (1-\alpha)\%</code> upper confidence bound.
</p>


<h3>References</h3>

<p>[1] Kokoszka P., Rice G., Shang H.L. (2017). Inference for the autocovariance of a functional time series
under conditional heteroscedasticity. Journal of Multivariate Analysis, 162, 32-50.
</p>
<p>[2] Mestre G., Portela J., Rice G., Roque A. M. S., Alonso E. (2021). Functional time series model identification
and diagnosis by means of auto-and partial autocorrelation analysis. Computational Statistics &amp; Data Analysis, 155, 107108.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Spanish_elec) # Daily Spanish electricity price profiles
fACF(Spanish_elec)
fACF(Spanish_elec, H=10, wwn_bound=TRUE)


</code></pre>

<hr>
<h2 id='fACF_test'>Test based on fACF</h2><span id='topic+fACF_test'></span>

<h3>Description</h3>

<p>This function performs a hypothesis test using a test statistic computed from functional autocovariance kernels of a FTS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fACF_test(
  f_data,
  H = 10,
  iid = FALSE,
  M = NULL,
  pplot = FALSE,
  alpha = 0.05,
  suppress_raw_output = FALSE,
  suppress_print_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fACF_test_+3A_f_data">f_data</code></td>
<td>
<p>A <code class="reqn">J \times N</code> matrix of functional time series data, where <code class="reqn">J</code> is the number of discrete points in a grid and <code class="reqn">N</code> is the sample size.</p>
</td></tr>
<tr><td><code id="fACF_test_+3A_h">H</code></td>
<td>
<p>A positive integer specifying the maximum lag for which test statistic is computed.</p>
</td></tr>
<tr><td><code id="fACF_test_+3A_iid">iid</code></td>
<td>
<p>A Boolean value. If given TRUE, the hypothesis test will use the strong-white
noise (SWN) assumption instead of the weak white noise (WWN) assumption.</p>
</td></tr>
<tr><td><code id="fACF_test_+3A_m">M</code></td>
<td>
<p>A positive integer specifying the number of Monte Carlo simulations used to approximate the null distribution under the WWN assumption.
If <code class="reqn">M = NULL, M = \text{floor}((\max(150 - N, 0) + \max(100 - J, 0) + (J / \sqrt{2})))</code>,
ensuring that the number of Monte Carlo simulations is adequate based on the dataset size.</p>
</td></tr>
<tr><td><code id="fACF_test_+3A_pplot">pplot</code></td>
<td>
<p>A Boolean value. If TRUE, the function will produce a plot of p-values of the test
as a function of maximum lag <code class="reqn">H</code>, ranging from <code class="reqn">H=1</code> to <code class="reqn">H=20</code>, which may increase the computation time.</p>
</td></tr>
<tr><td><code id="fACF_test_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value between 0 and 1 indicating the significance level for the test.</p>
</td></tr>
<tr><td><code id="fACF_test_+3A_suppress_raw_output">suppress_raw_output</code></td>
<td>
<p>A Boolean value. If TRUE, the function will not return the list
containing the p-value, quantile, and statistic.</p>
</td></tr>
<tr><td><code id="fACF_test_+3A_suppress_print_output">suppress_print_output</code></td>
<td>
<p>A Boolean value. If TRUE, the function will not print any
output to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test statistic is the sum of the squared <code class="reqn">L^2</code>-norm of the sample autocovariance kernels:
</p>
<p style="text-align: center;"><code class="reqn">
KRS_{N,H} = N \sum_{h=1}^H \|\hat{\gamma}_{N,h}\|^2,
</code>
</p>

<p>where
<code class="reqn">
   \hat{\gamma}_{N,h}(t,s)=N^{-1}\sum_{i=1}^{N-h} (X_i(t)-\bar{X}_N(t))(X_{i+h}(s)-\bar{X}_N(s))</code>,
<code class="reqn">\bar{X}_N(t) = N^{-1} \sum_{i=1}^N X_i(t)</code>.
This test assesses the cumulative significance of lagged autocovariance kernels, up to a
user-selected maximum lag <code class="reqn">H</code>. A higher value of <code class="reqn">KRS_{N,H}</code> suggests a potential
departure of the observed series from white noise process. The approximated null
distribution of this statistic is developed under both the strong and weak white noise assumptions.
</p>


<h3>Value</h3>

<p>If suppress_raw_output = FALSE, a list that includes the test statistic, the <code class="reqn">(1-\alpha)</code> quantile of the
limiting distribution, and the p-value from the specified hypothesis test. Additionally, if suppress_print_output = FALSE,
a summary is printed with a brief explanation of the test, the p-value, and relevant details about the test procedure.
</p>


<h3>References</h3>

<p>[1] Kokoszka P., Rice G., Shang H.L. (2017). Inference for the autocovariance of a functional time series
under conditional heteroscedasticity. Journal of Multivariate Analysis, 162, 32-50.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp500) # S&amp;P500 index
fACF_test(OCIDR(sp500), H = 10, pplot=TRUE)

</code></pre>

<hr>
<h2 id='fCH_test'>Test for Conditional Heteroscedasticity of Functional Time Series</h2><span id='topic+fCH_test'></span>

<h3>Description</h3>

<p>It tests the null hypothesis that the objective functional curve data is not conditionally heteroscedastic. If a small p-value rejects the null hypothesis,  the curves exhibit conditional heteroscedasticity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fCH_test(f_data, H = 10, stat_Method = "functional", pplot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fCH_test_+3A_f_data">f_data</code></td>
<td>
<p>A <code class="reqn">J \times N</code> matrix of functional time series data, where <code class="reqn">J</code> is the number of discrete points in a grid and <code class="reqn">N</code> is the sample size.</p>
</td></tr>
<tr><td><code id="fCH_test_+3A_h">H</code></td>
<td>
<p>A positive integer specifying the maximum lag for which test statistic is computed.</p>
</td></tr>
<tr><td><code id="fCH_test_+3A_stat_method">stat_Method</code></td>
<td>
<p>A string specifying the test method to be used in the &quot;ch&quot; test. Options include:
</p>

<dl>
<dt>&quot;norm&quot;</dt><dd><p>Uses <code class="reqn">V_{N,H}</code>.</p>
</dd>
<dt>&quot;functional&quot;</dt><dd><p>Uses <code class="reqn">M_{N,H}</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fCH_test_+3A_pplot">pplot</code></td>
<td>
<p>A Boolean value. If TRUE, the function will produce a plot of p-values of the test
as a function of maximum lag <code class="reqn">H</code>, ranging from <code class="reqn">H=1</code> to <code class="reqn">H=20</code>, which may increase the computation time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the objective curve data <code class="reqn">X_i(t)</code>, for <code class="reqn">1\leq i \leq N</code>, <code class="reqn">t\in[0,1]</code>, the test aims at distinguishing the hypotheses:<br /> <br />
<code class="reqn">H_0</code>: the sequence <code class="reqn">X_i(t)</code> is IID; <br />
<code class="reqn">H_1</code>: the sequence <code class="reqn">X_i(t)</code> is conditionally heteroscedastic. <br /> <br />
Two portmanteau type statistics are applied: <br /> <br />
1. the norm-based statistic: <code class="reqn">V_{N,H}=N\sum_{h=1}^H\hat{\gamma}^2_{X^2}(h)</code>, where <code class="reqn">\hat{\gamma}^2_{X^2}(h)</code> is the sample autocorrelation of the time series <code class="reqn">||X_1||^2,\dots,||X_N||^2</code>, and <code class="reqn">H</code> is a pre-set maximum lag length.<br /> <br />
2. the fully functional statistic <code class="reqn">M_{N,H}=N\sum_{h=1}^H||\hat{\gamma}_{X^2,N,h}||^2</code>, where the autocovariance kernel <code class="reqn">\hat{\gamma}_{X^2,N,h}(t,s)=N^{-1}\sum_{i=1}^{N-h}[X_i^2(t)-\bar{X}^2(t)][X^2_{i+h}(s)-\bar{X}(s)]</code>, for <code class="reqn">||\cdot ||</code> is the <code class="reqn">L^2</code> norm, and <code class="reqn">\bar{X}^2(t)=N^{-1}\sum_{i=1}^N X^2_i(t)</code>.
</p>


<h3>Value</h3>

<p>A list that includes the test statistic and the p-value will be returned.
</p>


<h3>References</h3>

<p>Rice, G., Wirjanto, T., Zhao, Y. (2020). Tests for conditional heteroscedasticity of functional data. Journal of Time Series Analysis. 41(6), 733-758. &lt;doi:10.1111/jtsa.12532&gt;.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# generate discrete evaluations of the iid curves under the null hypothesis.
yd_ou = dgp.ou(50, 100)

# test the conditional heteroscedasticity.
fCH_test(yd_ou, H=5, stat_Method="functional")

</code></pre>

<hr>
<h2 id='fport_eda'>Exploratory Data Analysis for Functional Time Series.</h2><span id='topic+fport_eda'></span>

<h3>Description</h3>

<p>This function sequentially displays the fACF plot, the fSACF and the rainbow plot of a functional time series (FTS) for comprehensive exploratory data analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fport_eda(f_data, H = 20, alpha = 0.05, wwn_bound = FALSE, M = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fport_eda_+3A_f_data">f_data</code></td>
<td>
<p>A <code class="reqn">J \times N</code> matrix of FTS data, where <code class="reqn">J</code> is the number of discrete points in a grid and <code class="reqn">N</code> is the sample size.</p>
</td></tr>
<tr><td><code id="fport_eda_+3A_h">H</code></td>
<td>
<p>A positive integer representing the maximum lag for computing the coefficients and confidence bounds. This value determines the range of lags included in the fACF and fSACF plots.</p>
</td></tr>
<tr><td><code id="fport_eda_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value between 0 and 1 indicating the significance level for the confidence bounds in the fACF and fSACF plots.</p>
</td></tr>
<tr><td><code id="fport_eda_+3A_wwn_bound">wwn_bound</code></td>
<td>
<p>A Boolean value allowing the user to turn on the WWN bound in the fACF plot. FALSE by default. Speeds down computation when TRUE.</p>
</td></tr>
<tr><td><code id="fport_eda_+3A_m">M</code></td>
<td>
<p>A positive integer value. The number of Monte-Carlo simulations used to compute the confidence bounds under the WWN assumption. 
If <code class="reqn">M = NULL, M = \text{floor}((\max(150 - N, 0) + \max(100 - J, 0) + (J / \sqrt{2})))</code>,
ensuring that the number of Monte Carlo simulations is adequate based on the dataset size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function sequentially displays the rainbow plot, the fACF plot, and the fSACF of an FTS for comprehensive exploratory data analysis.
See the help page of <code><a href="#topic+rainbow3D">rainbow3D</a></code>, <code><a href="#topic+fACF">fACF</a></code>, <code><a href="#topic+fSACF">fSACF</a></code>, for more details.
</p>


<h3>Value</h3>

<p>A 3D rainbow plot, a fACF plot for lags <code class="reqn">h \in 1:H</code> with the WWN
<code class="reqn">(1-\alpha)100 \%</code> upper confidence bound and the constant strong white noise (SWN)
<code class="reqn">(1-\alpha)100 \%</code> upper confidence bound, and a fSACF plot for lags <code class="reqn">h \in 1:H</code> with the SWN
<code class="reqn">(1-\alpha)100 \%</code> upper and lower confidence bounds.
</p>


<h3>References</h3>

<p>[1] Kokoszka P., Rice G., Shang H.L. (2017). Inference for the autocovariance of a functional time series
under conditional heteroscedasticity. Journal of Multivariate Analysis, 162, 32-50.
</p>
<p>[2] Mestre G., Portela J., Rice G., Roque A. M. S., Alonso E. (2021). Functional time series model identification
and diagnosis by means of auto-and partial autocorrelation analysis. Computational Statistics &amp; Data Analysis, 155, 107108.
</p>
<p>[3] Yeh CK, Rice G, Dubin JA (2023). “Functional spherical autocorrelation: A robust estimate of
the autocorrelation of a functional time series.” Electronic Journal of Statistics, 17, 650–687.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Spanish_elec) # Daily Spanish electricity price profiles
fport_eda(Spanish_elec)


</code></pre>

<hr>
<h2 id='fport_gof'>Goodness-of-fit Tests for Functional Times Series</h2><span id='topic+fport_gof'></span>

<h3>Description</h3>

<p>It computes three different goodness-of-fit tests for functional time series. All goodness-of-fit tests in this package are accessible through this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fport_gof(
  f_data,
  test = "far",
  H = 10,
  M = NULL,
  pplot = FALSE,
  residual = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fport_gof_+3A_f_data">f_data</code></td>
<td>
<p>A <code class="reqn">J \times N</code> matrix of functional time series data, where <code class="reqn">J</code> is the number of discrete points in a grid and <code class="reqn">N</code> is the sample size.</p>
</td></tr>
<tr><td><code id="fport_gof_+3A_test">test</code></td>
<td>
<p>A string specifying the goodness-of-fit test. Currently available tests are referred
to by their string handles: &quot;far&quot;, &quot;arch&quot; and &quot;garch&quot;. Please see the Details section of the documentation.</p>
</td></tr>
<tr><td><code id="fport_gof_+3A_h">H</code></td>
<td>
<p>A positive integer specifying the maximum lag for which test statistics are computed.</p>
</td></tr>
<tr><td><code id="fport_gof_+3A_m">M</code></td>
<td>
<p>A positive integer specifying the number of Monte Carlo simulations used to approximate the null distribution in the &quot;far&quot; test, and the number of basis functions used in the &quot;arch&quot; and &quot;garch&quot; tests. 
If <code class="reqn">M = NULL</code>, then for the &quot;far&quot; test, <code class="reqn">M</code> is calculated as <code class="reqn">\text{floor}((\max(150 - N, 0) + \max(100 - J, 0) + (J / \sqrt{2})))</code>, ensuring the number of Monte Carlo simulations is adequate based on the dataset size.
For the &quot;arch&quot; or &quot;garch&quot; test, <code class="reqn">M</code> is set to 1.</p>
</td></tr>
<tr><td><code id="fport_gof_+3A_pplot">pplot</code></td>
<td>
<p>A Boolean value. If TRUE, the function will produce a plot of p-values of the test
as a function of maximum lag <code class="reqn">H</code>, ranging from <code class="reqn">H=1</code> to <code class="reqn">H=20</code>, which may increase the computation time.</p>
</td></tr>
<tr><td><code id="fport_gof_+3A_residual">residual</code></td>
<td>
<p>A data frame. If TRUE, the function will provide the residuals obtained from fitting the FAR(1) model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function conducts goodness-of-fit tests for functional time series data,
providing several testing options:
</p>
<p>1. When test = &quot;far&quot;, it tests the goodness-of-fit of the FAR(1) model.
The function fits the FAR(1) model to the input data and then applies the test statistic <code class="reqn">KRS_{N,H}</code>, as described in <code><a href="#topic+fport_wn">fport_wn</a></code>, to the residuals.
The null distribution of the test statistic accounts for the dependence structure present in the residuals.
The optional parameters for this test are 'fdata', 'test', 'H', 'M', 'pplot' and 'residual'.
</p>
<p>2. When test = &quot;arch&quot; or &quot;garch&quot;, it tests the goodness-of-fit of the fARCH(1) or fGARCH(1,1) models.
It fits the model to the input data and applies the test <code class="reqn">M_{N,H}</code> in <code><a href="#topic+fport_wn">fport_wn</a></code> to the model residuals.
The asymptotic distribution is adjusted to account for the estimation effect,
because the model residual depends on the joint asymptotics of the innovation process and
the estimated parameters. We assume that the kernel parameters are consistently estimated
by the Least Squares method proposed in Aue et al. (2017).
Then, the asymptotic distribution of the statistic <code class="reqn">M_{N,H}</code> is given in Theorem 3.1
in Rice et al. (2020).
The optional parameters for this test are 'fdata', 'test', 'H', 'M', and 'pplot'.
</p>


<h3>Value</h3>

<p>A summary is printed with a brief explanation of the test and the p-value.
</p>


<h3>References</h3>

<p>[1] Kim, M., Kokoszka, P., &amp; Rice, G. (2023). White noise testing for functional time series. Statistic Surveys, 17, 119-168.
</p>
<p>[2] Aue, A., Horvath, L., F. Pellatt, D. (2017). Functional generalized autoregressive conditional heteroskedasticity. Journal of Time Series Analysis. 38(1), 3-21. &lt;doi:10.1111/jtsa.12192&gt;.<br />
</p>
<p>[3] Rice, G., Wirjanto, T., Zhao, Y. (2020). Tests for conditional heteroscedasticity of functional data. Journal of Time Series Analysis. 41(6), 733-758. &lt;doi:10.1111/jtsa.12532&gt;.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Spanish_elec)
fport_gof(Spanish_elec, test = "far", H = 20, pplot=TRUE)

data(sp500)
fport_gof(OCIDR(sp500), test = "arch", M = 1, H = 5)
fport_gof(OCIDR(sp500), test = "garch", M = 1, H = 10)

</code></pre>

<hr>
<h2 id='fport_wn'>White Noise Hypothesis Tests for Functional Times Series</h2><span id='topic+fport_wn'></span>

<h3>Description</h3>

<p>It computes a variety of white noise tests for functional times series (FTS) data. All white noise tests in this package are accessible through this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fport_wn(
  f_data,
  test = "autocovariance",
  H = 10,
  iid = FALSE,
  M = NULL,
  stat_Method = "functional",
  pplot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fport_wn_+3A_f_data">f_data</code></td>
<td>
<p>A <code class="reqn">J \times N</code> matrix of functional time series data, where <code class="reqn">J</code> is the number of discrete points in a grid and <code class="reqn">N</code> is the sample size.</p>
</td></tr>
<tr><td><code id="fport_wn_+3A_test">test</code></td>
<td>
<p>A string specifying the hypothesis test. Currently available tests are referred
to by their string handles: &quot;autocovariance&quot;, &quot;spherical&quot; and &quot;ch&quot;. Please see the Details section of the documentation.</p>
</td></tr>
<tr><td><code id="fport_wn_+3A_h">H</code></td>
<td>
<p>A positive integer specifying the maximum lag for which test statistics are computed.</p>
</td></tr>
<tr><td><code id="fport_wn_+3A_iid">iid</code></td>
<td>
<p>A Boolean value used in the &quot;autocovariance&quot; test. If given TRUE, the hypothesis test will use the strong-white
noise (SWN) assumption instead of the weak white noise (WWN) assumption.</p>
</td></tr>
<tr><td><code id="fport_wn_+3A_m">M</code></td>
<td>
<p>A positive integer specifying the number of Monte Carlo simulations used to approximate the null distribution in the &quot;autocovariance&quot; test under the WWN assumption.
If <code class="reqn">M = NULL, M = \text{floor}((\max(150 - N, 0) + \max(100 - J, 0) + (J / \sqrt{2})))</code>,
ensuring that the number of Monte Carlo simulations is adequate based on the dataset size.</p>
</td></tr>
<tr><td><code id="fport_wn_+3A_stat_method">stat_Method</code></td>
<td>
<p>A string specifying the test method to be used in the &quot;ch&quot; test. Options include:
</p>

<dl>
<dt>&quot;norm&quot;</dt><dd><p>Uses <code class="reqn">V_{N,H}</code>.</p>
</dd>
<dt>&quot;functional&quot;</dt><dd><p>Uses <code class="reqn">M_{N,H}</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fport_wn_+3A_pplot">pplot</code></td>
<td>
<p>A Boolean value. If TRUE, the function will produce a plot of p-values of the test
as a function of maximum lag <code class="reqn">H</code>, ranging from <code class="reqn">H=1</code> to <code class="reqn">H=20</code>, which may increase the computation time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs white noise hypothesis testing for functional time series (FTS) data. It offers several types of tests:
</p>
<p>1. Test based on fACF (test = &quot;autocovariance&quot;):
This test evaluates the sum of the squared <code class="reqn">L^2</code>-norm of the sample autocovariance kernels:
</p>
<p style="text-align: center;"><code class="reqn">
   KRS_{N,H} = N \sum_{h=1}^H \|\hat{\gamma}_{N,h}\|^2,
   </code>
</p>

<p>where
<code class="reqn">
   \hat{\gamma}_{N,h}(t,s)=\frac{1}{N}\sum_{i=1}^{N-h} (X_i(t)-\bar{X}_N(t))(X_{i+h}(s)-\bar{X}_N(s))</code>,
<code class="reqn">\bar{X}_N(t) = \frac{1}{N} \sum_{i=1}^N X_i(t)</code>
It assesses the cumulative significance of lagged autocovariance kernels up to a user-specified maximum lag <code class="reqn">H</code>.
A higher value of <code class="reqn">KRS_{N,H}</code> suggests a potential departure from a white noise process.
The null distribution is approximated under both strong and weak white noise assumptions.
Optional parameters include 'f_data', 'test', 'H', 'iid', 'M', and 'pplot'.
</p>
<p>2. Test based on fSACF (test = &quot;spherical&quot;):
This test evaluates the sum of the squared <code class="reqn">L^2</code>-norm of the sample spherical autocorrelation coefficients:
</p>
<p style="text-align: center;"><code class="reqn">
   S_{N,H} = N \sum_{h=1}^H \|\tilde{\rho}_{h}\|^2,
   </code>
</p>

<p>where <code class="reqn">\tilde\rho_h=\frac{1}{N}\sum_{i=1}^{N-h} \langle \frac{X_i - \tilde{\mu}}{\|X_i - \tilde{\mu}\|}, \frac{X_{i+h} - \tilde{\mu}}{\|X_{i+h} - \tilde{\mu}\|} \rangle</code>,
and <code class="reqn">\tilde{\mu}</code> is the estimated spatial median of the series.
It assesses the cumulative significance of lagged spherical autocorrelation coefficients up to a user-specified maximum lag <code class="reqn">H</code>.
A higher value of <code class="reqn">S_{N,H}</code> suggests a potential departure from a white noise process.
The null distribution is approximated under strong white noise assumptions.
Optional parameters include 'f_data', 'test', 'H', and 'pplot'.
</p>
<p>3. Test for Conditional Heteroscedasticity (test = &quot;ch&quot;):
This test investigates whether the functional time series exhibits conditional heteroscedasticity. Two portmanteau-type statistics are used:
</p>

<ul>
<li><p> Norm-based statistic: <code class="reqn">V_{N,H} = N \sum_{h=1}^H \hat{\gamma}^2_{X^2}(h)</code>, where <code class="reqn">\hat{\gamma}^2_{X^2}(h)</code> is the sample autocorrelation of the time series <code class="reqn">||X_1||^2, \dots, ||X_N||^2</code>, with <code class="reqn">H</code> as the maximum lag length.
</p>
</li>
<li><p> Fully functional statistic: <code class="reqn">M_{N,H} = N \sum_{h=1}^H \|\hat{\gamma}_{X^2,N,h}\|^2</code>, where <code class="reqn">\hat{\gamma}_{X^2,N,h}(t,s) = \frac{1}{N} \sum_{i=1}^{N-h} [X_i^2(t) - \bar{X}^2(t)][X^2_{i+h}(s) - \bar{X}(s)]</code>, with <code class="reqn">\|\cdot\|</code> representing the <code class="reqn">L^2</code> norm and <code class="reqn">\bar{X}^2(t) = \frac{1}{N} \sum_{i=1}^N X_i^2(t)</code>.
</p>
</li></ul>

<p>Optional parameters for this test include 'f_data', 'test', 'H', 'stat_Method', and 'pplot'.
</p>


<h3>Value</h3>

<p>A summary is printed with a brief explanation of the test and the p-value.
</p>


<h3>References</h3>

<p>[1] Kokoszka P., Rice G., Shang H.L. (2017). Inference for the autocovariance of a functional time series
under conditional heteroscedasticity. Journal of Multivariate Analysis, 162, 32-50.
</p>
<p>[2] Yeh CK, Rice G, Dubin JA (2023). “Functional spherical autocorrelation: A robust estimate of
the autocorrelation of a functional time series.” Electronic Journal of Statistics, 17, 650–687.
</p>
<p>[3] Rice, G., Wirjanto, T., Zhao, Y. (2020). Tests for conditional heteroscedasticity of functional
data. Journal of Time Series Analysis. 41(6), 733-758. &lt;doi:10.1111/jtsa.12532&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Spanish_elec)
fport_wn(Spanish_elec, test = "autocovariance", pplot = TRUE)
fport_wn(Spanish_elec, test = "spherical", H = 15, pplot = TRUE)

# generate fARCH(1)
yd_arch &lt;- dgp.fgarch(J = 50, N = 200, type = "arch")$garch_mat
fport_wn(yd_arch, test = "ch", H = 20, stat_Method = "norm", pplot = TRUE)
fport_wn(yd_arch, test = "ch", H = 20, stat_Method = "functional", pplot = TRUE)



</code></pre>

<hr>
<h2 id='fSACF'>Functional Spherical Autocorrelation Function (fSACF) Plot</h2><span id='topic+fSACF'></span>

<h3>Description</h3>

<p>This function offers a graphical summary of the fSACF of a functional time series (FTS) across different time lags <code class="reqn">h = 1:H</code>.
It also plots <code class="reqn">100 \times (1-\alpha)\%</code>  confidence bounds developed under strong white noise (SWN) assumption for all lags <code class="reqn">h = 1:H</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fSACF(f_data, H = 20, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fSACF_+3A_f_data">f_data</code></td>
<td>
<p>A <code class="reqn">J \times N</code> matrix of functional time series data, where <code class="reqn">J</code> is the number of discrete points in a grid and <code class="reqn">N</code> is the sample size.</p>
</td></tr>
<tr><td><code id="fSACF_+3A_h">H</code></td>
<td>
<p>A positive integer value. The maximum lag for which to compute the coefficients and confidence bounds.</p>
</td></tr>
<tr><td><code id="fSACF_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value between 0 and 1 specifying the significance level to be used for the confidence bounds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes and plots functional spherical autocorrelation coefficients at lag <code class="reqn">h</code>, for <code class="reqn">h = 1:H</code>.
The fSACF at lag <code class="reqn">h</code> is computed by the average of the inner product of lagged pairs of
the series <code class="reqn">X_i</code> and <code class="reqn">X_{i+h}</code> that have been centered and scaled:
</p>
<p style="text-align: center;"><code class="reqn">
\tilde\rho_h=\frac{1}{N}\sum_{i=1}^{N-h} \langle \frac{X_i - \tilde{\mu}}{\|X_i - \tilde{\mu}\|}, \frac{X_{i+h} - \tilde{\mu}}{\|X_{i+h} - \tilde{\mu}\|} \rangle,\ \ \ \ 0 \le h &lt; N,
</code>
</p>

<p>where <code class="reqn">\tilde{\mu}</code> is the estimated spatial median of the series.
It also computes estimated asymptotic <code class="reqn">(1-\alpha)100 \%</code> confidence lower and upper bounds, under the SWN assumption.
</p>


<h3>Value</h3>

<p>Plot of the estimated autocorrelation coefficients for lags <code class="reqn">h</code> in <code class="reqn">1:H</code> with the SWN
<code class="reqn">(1-\alpha)100 \%</code> upper and lower confidence bounds for each lag.
</p>


<h3>References</h3>

<p>[1] Yeh C.K., Rice G., Dubin J.A. (2023). Functional spherical autocorrelation: A robust estimate of
the autocorrelation of a functional time series. Electronic Journal of Statistics, 17, 650–687.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Spanish_elec) # Daily Spanish electricity price profiles
fSACF(Spanish_elec)

</code></pre>

<hr>
<h2 id='fSACF_test'>Test based on fSACF</h2><span id='topic+fSACF_test'></span>

<h3>Description</h3>

<p>This function performs a hypothesis test using a test statistic computed from functional spherical autocorrelation coefficients of a FTS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fSACF_test(
  f_data,
  H = 10,
  alpha = 0.05,
  pplot = FALSE,
  suppress_raw_output = FALSE,
  suppress_print_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fSACF_test_+3A_f_data">f_data</code></td>
<td>
<p>A <code class="reqn">J \times N</code> matrix of functional time series data, where <code class="reqn">J</code> represents the number of discrete points in a grid and <code class="reqn">N</code> represents the sample size.</p>
</td></tr>
<tr><td><code id="fSACF_test_+3A_h">H</code></td>
<td>
<p>A positive integer specifying the maximum lag for which test statistic is computed.</p>
</td></tr>
<tr><td><code id="fSACF_test_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value between 0 and 1 indicating the significance level for the test.</p>
</td></tr>
<tr><td><code id="fSACF_test_+3A_pplot">pplot</code></td>
<td>
<p>A Boolean value. If TRUE, the function will produce a plot of p-values of the test
as a function of maximum lag <code class="reqn">H</code>, ranging from <code class="reqn">H=1</code> to <code class="reqn">H=20</code>, which may increase the computation time.</p>
</td></tr>
<tr><td><code id="fSACF_test_+3A_suppress_raw_output">suppress_raw_output</code></td>
<td>
<p>A Boolean value. If TRUE, the function will not return the list
containing the p-value, quantile, and statistic.</p>
</td></tr>
<tr><td><code id="fSACF_test_+3A_suppress_print_output">suppress_print_output</code></td>
<td>
<p>A Boolean value. If TRUE, the function will not print any
output to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test statistic is the sum of the squared <code class="reqn">L^2</code>-norm of the sample spherical autocorrelation coefficients:
</p>
<p style="text-align: center;"><code class="reqn">
S_{N,H} = N \sum_{h=1}^H \|\tilde{\rho}_{h}\|^2,
</code>
</p>

<p>where <code class="reqn">\tilde\rho_h=\frac{1}{N}\sum_{i=1}^{N-h} \langle \frac{X_i - \tilde{\mu}}{\|X_i - \tilde{\mu}\|}, \frac{X_{i+h} - \tilde{\mu}}{\|X_{i+h} - \tilde{\mu}\|} \rangle</code>,
and <code class="reqn">\tilde{\mu}</code> is the estimated spatial median of the series.
This test assesses the cumulative significance of lagged spherical autocorrelation coefficients, up to a
user-selected maximum lag <code class="reqn">H</code>. A higher value of <code class="reqn">S_{N,H}</code> suggests a potential
departure of the observed series from white noise process. The approximated null
distribution of this statistic is developed under the strong white noise assumptions.
</p>


<h3>Value</h3>

<p>If suppress_raw_output = FALSE, a list containing the test statistic, the <code class="reqn">(1-\alpha)</code> quantile of the
limiting distribution, and the p-value computed from the specified hypothesis test. Also prints output
containing a short description of the test, the p-value, and additional information about the test if
suppress_print_output = FALSE.
</p>


<h3>References</h3>

<p>[1] Yeh CK, Rice G, Dubin JA (2023). “Functional spherical autocorrelation: A robust estimate of
the autocorrelation of a functional time series.” Electronic Journal of Statistics, 17, 650–687.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Spanish_elec)
fACF_test(Spanish_elec, H = 20)

</code></pre>

<hr>
<h2 id='gof_far'>Goodness-of-fit test for FAR(1)</h2><span id='topic+gof_far'></span>

<h3>Description</h3>

<p>It fits a FAR(1) model and then assesses the cumulative significance of lagged
autocovariance operators from the model residuals, up to a user-selected maximum lag <code class="reqn">H</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gof_far(
  f_data,
  H = 10,
  M = NULL,
  alpha = 0.05,
  pplot = FALSE,
  residual = FALSE,
  suppress_raw_output = FALSE,
  suppress_print_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gof_far_+3A_f_data">f_data</code></td>
<td>
<p>A <code class="reqn">J \times N</code> matrix of functional time series data, where <code class="reqn">J</code> is the number of discrete points in a grid and <code class="reqn">N</code> is the sample size.</p>
</td></tr>
<tr><td><code id="gof_far_+3A_h">H</code></td>
<td>
<p>A positive integer specifying the maximum lag for which test statistics are computed.</p>
</td></tr>
<tr><td><code id="gof_far_+3A_m">M</code></td>
<td>
<p>A positive integer specifying the number of Monte Carlo simulations used to approximate the null distribution.
If <code class="reqn">M = NULL, M = \text{floor}((\max(150 - N, 0) + \max(100 - J, 0) + (J / \sqrt{2})))</code>,
ensuring that the number of Monte Carlo simulations is adequate based on the dataset size.</p>
</td></tr>
<tr><td><code id="gof_far_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value between 0 and 1 specifying the significance level.</p>
</td></tr>
<tr><td><code id="gof_far_+3A_pplot">pplot</code></td>
<td>
<p>A Boolean value. If TRUE, the function will produce a plot of p-values of the test
as a function of maximum lag <code class="reqn">H</code>, ranging from <code class="reqn">H=1</code> to <code class="reqn">H=20</code>, which may increase the computation time.</p>
</td></tr>
<tr><td><code id="gof_far_+3A_residual">residual</code></td>
<td>
<p>A data frame. If TRUE, the function will provide the residuals obtained from fitting the FAR(1) model.</p>
</td></tr>
<tr><td><code id="gof_far_+3A_suppress_raw_output">suppress_raw_output</code></td>
<td>
<p>A Boolean value, FALSE by default. If TRUE, the function will not return the list
containing the p-value, quantile, and statistic.</p>
</td></tr>
<tr><td><code id="gof_far_+3A_suppress_print_output">suppress_print_output</code></td>
<td>
<p>A Boolean value, FALSE by default. If TRUE, the function will not print any
output to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If suppress_raw_output = FALSE, a list containing the test statistic, the <code class="reqn">(1-\alpha)</code> quantile of the
limiting distribution, and the p-value computed from the specified hypothesis test. Also prints output
containing a short description of the test, the p-value, and additional information about the test if
suppress_print_output = FALSE.
</p>


<h3>References</h3>

<p>[1] Kim, M., Kokoszka, P., &amp; Rice, G. (2023). White noise testing for functional time series. Statistic Surveys, 17, 119-168.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
yd_far &lt;- dgp.far(J=50, N=100, S=0.7, p=2, kernel = "Gaussian", burn_in = 50)
gof_far(yd_far, H=5, pplot=TRUE)

</code></pre>

<hr>
<h2 id='gof_fGARCH'>Goodness-of-fit Test for Functional ARCH/GARCH Model</h2><span id='topic+gof_fGARCH'></span>

<h3>Description</h3>

<p>It tests the goodness-of-fit of functional ARCH/GARCH models by accounting for the effect of functional GARCH parameter estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gof_fGARCH(f_data, M, model, H = 10, pplot = NULL, max_eval = 10000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gof_fGARCH_+3A_f_data">f_data</code></td>
<td>
<p>A <code class="reqn">J \times N</code> matrix of functional time series data, where <code class="reqn">J</code> is the number of discrete points in a grid and <code class="reqn">N</code> is the sample size.</p>
</td></tr>
<tr><td><code id="gof_fGARCH_+3A_m">M</code></td>
<td>
<p>A positive integer specifying the number of basis functions.</p>
</td></tr>
<tr><td><code id="gof_fGARCH_+3A_model">model</code></td>
<td>
<p>A string to indicate which model will be estimated: &quot;arch&quot; - FARCH(1); &quot;garch&quot; - FGARCH(1,1).</p>
</td></tr>
<tr><td><code id="gof_fGARCH_+3A_h">H</code></td>
<td>
<p>A positive integer specifying the maximum lag for which test statistics are computed.</p>
</td></tr>
<tr><td><code id="gof_fGARCH_+3A_pplot">pplot</code></td>
<td>
<p>A Boolean value. If TRUE, the function will produce a plot of p-values of the test
as a function of maximum lag <code class="reqn">H</code>, ranging from <code class="reqn">H=1</code> to <code class="reqn">H=20</code>, which may increase the computation time.</p>
</td></tr>
<tr><td><code id="gof_fGARCH_+3A_max_eval">max_eval</code></td>
<td>
<p>The maximum number of evaluations of the optimization function, used in the &quot;arch&quot; and &quot;garch&quot; tests.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It tests the goodness-of-fit of the fARCH(1) or fGARCH(1,1) models.
It fits the model to the input data and applies the test <code class="reqn">M_{N,H}</code> in <code><a href="#topic+fport_wn">fport_wn</a></code> to the model residuals.
The asymptotic distribution is adjusted to account for the estimation effect,
because the model residual depends on the joint asymptotics of the innovation process and
the estimated parameters. We assume that the kernel parameters are consistently estimated
by the Least Squares method proposed in Aue et al. (2017).
Then, the asymptotic distribution of the statistic <code class="reqn">M_{N,H}</code> is given in Theorem 3.1
in Rice et al. (2020).
</p>


<h3>Value</h3>

<p>p-value.
</p>


<h3>References</h3>

<p>[1] Aue, A., Horvath, L., F. Pellatt, D. (2017). Functional generalized autoregressive conditional heteroskedasticity. Journal of Time Series Analysis. 38(1), 3-21. &lt;doi:10.1111/jtsa.12192&gt;.<br />
</p>
<p>[2] Rice, G., Wirjanto, T., Zhao, Y. (2020). Tests for conditional heteroscedasticity of functional data. Journal of Time Series Analysis. 41(6), 733-758. &lt;doi:10.1111/jtsa.12532&gt;.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# generate discrete evaluations of the FGARCH process.
set.seed(42)
yd = dgp.fgarch(J=50, N=200, type = "garch")$garch_mat

# test the adequacy of the FARCH(1) model.
gof_fGARCH(yd, M=2, model = "arch", H=10, pplot=TRUE)

</code></pre>

<hr>
<h2 id='OCIDR'>Convert Original Price Data to OCIDRs</h2><span id='topic+OCIDR'></span>

<h3>Description</h3>

<p>This function converts original price data into over-night cumulative intraday return curves (OCIDRs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OCIDR(f_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OCIDR_+3A_f_data">f_data</code></td>
<td>
<p>A <code class="reqn">J \times N</code> matrix of functional time series data, where <code class="reqn">J</code> is the number of discrete points in a grid and <code class="reqn">N</code> is the sample size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of OCIDRs with dimensions <code class="reqn">J \times (N-1)</code>, where <code class="reqn">J</code> is the number of discrete grid points and <code class="reqn">N-1</code> is the adjusted sample size.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp500)
OCIDR(sp500)

</code></pre>

<hr>
<h2 id='rainbow3D'>3D Rainbow Plot for Functional Time Series</h2><span id='topic+rainbow3D'></span>

<h3>Description</h3>

<p>This function creates a 3D rainbow plot of a functional time series (FTS) using the <code>rgl</code> package.
The data is color-coded using a rainbow color scheme, with earlier curves in red and later curves in violet.
A 360-degree interactive view is available through an embedded widget.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rainbow3D(f_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rainbow3D_+3A_f_data">f_data</code></td>
<td>
<p>A <code class="reqn">J \times N</code> matrix of functional time series data, where <code class="reqn">J</code> is the number of discrete points in the grid and <code class="reqn">N</code> is the sample size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3D rainbow plot of the functional time series data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Spanish_elec) # Daily Spanish electricity price profiles
rainbow3D(Spanish_elec)

data(sp500) # S&amp;P500 index data
rainbow3D(OCIDR(sp500))

</code></pre>

<hr>
<h2 id='sp500'>S&amp;P 500 Index Price Data</h2><span id='topic+sp500'></span>

<h3>Description</h3>

<p>This dataset contains S&amp;P 500 index prices, given in percentages, for all full trading days
between January 3, 2017 and January 2, 2018, observed at a 1-minute frequency (390 grid points per day).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sp500)
</code></pre>


<h3>Format</h3>

<p>A matrix with rows representing minute-by-minute time points and columns representing intraday prices.
</p>


<h3>Source</h3>

<p><a href="https://finance.yahoo.com/">https://finance.yahoo.com/</a>
</p>

<hr>
<h2 id='Spanish_elec'>Spanish electricity daily price profiles</h2><span id='topic+Spanish_elec'></span>

<h3>Description</h3>

<p>This dataset contains daily electricity price profiles from the Day-Ahead Spanish Electricity Market.
The original data consists of hourly electricity spot prices, which have been transformed into daily functional profiles.
The dataset covers the period from January 1, 2014, to December 31, 2014.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Spanish_elec)
</code></pre>


<h3>Format</h3>

<p>A matrix with rows representing hourly time points and columns representing the daily price profiles as observed functions.
</p>


<h3>Source</h3>

<p><code>fdaACF</code>, <a href="https://www.esios.ree.es/es/analisis/600">https://www.esios.ree.es/es/analisis/600</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
