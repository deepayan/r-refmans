<!DOCTYPE html><html><head><title>Help for package DGM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DGM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#binom.nettest'><p>Performes a binomial test with FDR correction for network edge occurrence.</p></a></li>
<li><a href='#center'><p>Mean centers timeseries in a 2D array timeseries x nodes,</p>
i.e. each timeseries of each node has mean of zero.</a></li>
<li><a href='#cor2adj'><p>Threshold correlation matrix to match a given number of edges.</p></a></li>
<li><a href='#corTs'><p>Mean correlation of time series across subjects.</p></a></li>
<li><a href='#dgm.group'><p>A group is a list containing restructured data from subejcts for easier group analysis.</p></a></li>
<li><a href='#diag.delta'><p>Quick diagnostics on delta.</p></a></li>
<li><a href='#dlm.lpl'><p>Calculate the log predictive likelihood for a specified set of parents and a fixed delta.</p></a></li>
<li><a href='#dlm.retro'><p>Calculate the location and scale parameters for the time-varying coefficients</p>
given all the observations. West, M. &amp; Harrison, J., 1997. Bayesian Forecasting
and Dynamic Models. Springer New York.</a></li>
<li><a href='#dlmLplCpp'><p>C++ implementation of the dlm.lpl</p></a></li>
<li><a href='#exhaustive.search'><p>A function for an exhaustive search, calculates the optimum value of the discount factor.</p></a></li>
<li><a href='#getAdjacency'><p>Get adjacency and associated likelihoods (LPL) and disount factros (df) of winning models.</p></a></li>
<li><a href='#getIncompleteNodes'><p>Checks results and returns job number for incomplete nodes.</p></a></li>
<li><a href='#getModel'><p>Extract specific parent model with assocated df and ME from complete model space.</p></a></li>
<li><a href='#getModelNr'><p>Get model number from a set of parents.</p></a></li>
<li><a href='#getWinner'><p>Get winner network by maximazing log predictive likelihood (LPL)</p>
from a set of models.</a></li>
<li><a href='#gplotMat'><p>Plots network as adjacency matrix.</p></a></li>
<li><a href='#mergeModels'><p>Merges forward and backward model store.</p></a></li>
<li><a href='#model.generator'><p>A function to generate all the possible models.</p></a></li>
<li><a href='#myts'><p>Network simulation data.</p></a></li>
<li><a href='#node'><p>Runs exhaustive search on a single node and saves results in txt file.</p></a></li>
<li><a href='#patel'><p>Patel.</p></a></li>
<li><a href='#patel.group'><p>A group is a list containing restructured data from subejcts for easier group analysis.</p></a></li>
<li><a href='#perf'><p>Performance of estimates, such as sensitivity, specificity, and more.</p></a></li>
<li><a href='#priors.spec'><p>Specify the priors. Without inputs, defaults will be used.</p></a></li>
<li><a href='#prop.nettest'><p>Comparing two population proportions on the network with FDR correction.</p></a></li>
<li><a href='#pruning'><p>Get pruned adjacency network.</p></a></li>
<li><a href='#rand.test'><p>Randomization test for Patel's kappa. Creates a distribution of values</p>
kappa under the null hypothesis.</a></li>
<li><a href='#read.subject'><p>Reads single subject's network from txt files.</p></a></li>
<li><a href='#reshapeTs'><p>Reshapes a 2D concatenated time series into 3D according to no. of subjects and volumes.</p></a></li>
<li><a href='#rmdiag'><p>Removes diagonal of NA's from matrix.</p></a></li>
<li><a href='#rmna'><p>Removes NAs from matrix.</p></a></li>
<li><a href='#rmRecipLow'><p>Removes reciprocal connections in the lower diagnoal of the network matrix.</p></a></li>
<li><a href='#scaleTs'><p>Scaling data. Zero centers and scales the nodes (SD=1).</p></a></li>
<li><a href='#stepwise.backward'><p>Stepise backward non-exhaustive greedy search, calculates the optimum value of the discount factor.</p></a></li>
<li><a href='#stepwise.combine'><p>Stepise combine</p></a></li>
<li><a href='#stepwise.forward'><p>Stepise forward non-exhaustive greedy search, calculates the optimum value of the discount factor.</p></a></li>
<li><a href='#subject'><p>Estimate subject's full network: runs exhaustive search on very node.</p></a></li>
<li><a href='#symmetric'><p>Turns asymetric network into an symmetric network. Helper function to</p>
determine the detection of a connection while ignoring directionality.</a></li>
<li><a href='#ttest.nettest'><p>Comparing connectivity strenght of two groups with FDR correction.</p></a></li>
<li><a href='#utestdata'><p>Results from v.1.0 for unit tests.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.7.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-12-05</td>
</tr>
<tr>
<td>Title:</td>
<td>Dynamic Graphical Models</td>
</tr>
<tr>
<td>Author:</td>
<td>Simon Schwab &lt;schw4b@gmail.com&gt;, Ruth Harbord &lt;r.harbord@warwick.ac.uk&gt;,
    Lilia Costa &lt;liliacosta@ufba.br&gt;, Thomas Nichols &lt;t.e.nichols@warwick.ac.uk&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Simon Schwab &lt;schw4b@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.0), data.table (&ge; 1.10.0), reshape2 (&ge; 1.4.2),
ggplot2 (&ge; 2.2.1), coin (&ge; 1.2)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Dynamic graphical models for multivariate time series data to estimate directed
    dynamic networks in functional magnetic resonance imaging (fMRI), see Schwab et
    al. (2017) &lt;<a href="https://doi.org/10.1016%2Fj.neuroimage.2018.03.074">doi:10.1016/j.neuroimage.2018.03.074</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/schw4b/DGM">https://github.com/schw4b/DGM</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/schw4b/DGM/issues">https://github.com/schw4b/DGM/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-12-05 14:37:37 UTC; simon</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-12-05 15:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='binom.nettest'>Performes a binomial test with FDR correction for network edge occurrence.</h2><span id='topic+binom.nettest'></span>

<h3>Description</h3>

<p>Performes a binomial test with FDR correction for network edge occurrence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binom.nettest(adj, alter = "two.sided", fdr = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binom.nettest_+3A_adj">adj</code></td>
<td>
<p>adjacency matrix, nodes x nodes x subj, or nodes x nodes x runs x subj.</p>
</td></tr>
<tr><td><code id="binom.nettest_+3A_alter">alter</code></td>
<td>
<p>type of binomial test, &quot;two.sided&quot; (default), &quot;less&quot;, or &quot;greater&quot;</p>
</td></tr>
<tr><td><code id="binom.nettest_+3A_fdr">fdr</code></td>
<td>
<p>false discovery rate (FDR) control, default is 0.05.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>store list with results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some sample binary 5-node network structures for N=20, then perform
# significance testing.
N=20
x = rmdiag(array(rbinom(n=5*5*N, size=1, prob=0.10), dim=c(5,5,N)))
x[1,2,2:N]=1; x[2,3,seq(1,N,2)]=1 # add some consitent edges
A = apply(x, c(1,2), mean)
l = binom.nettest(x)

</code></pre>

<hr>
<h2 id='center'>Mean centers timeseries in a 2D array timeseries x nodes,
i.e. each timeseries of each node has mean of zero.</h2><span id='topic+center'></span>

<h3>Description</h3>

<p>Mean centers timeseries in a 2D array timeseries x nodes,
i.e. each timeseries of each node has mean of zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="center_+3A_x">X</code></td>
<td>
<p>2D array with dimensions timeseries x nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>M 2D array.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("utestdata")
myts=center(myts)


</code></pre>

<hr>
<h2 id='cor2adj'>Threshold correlation matrix to match a given number of edges.</h2><span id='topic+cor2adj'></span>

<h3>Description</h3>

<p>Threshold correlation matrix to match a given number of edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor2adj(R, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor2adj_+3A_r">R</code></td>
<td>
<p>correlation matrix.</p>
</td></tr>
<tr><td><code id="cor2adj_+3A_n">n</code></td>
<td>
<p>number of edges.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A thresholded matrix.
</p>

<hr>
<h2 id='corTs'>Mean correlation of time series across subjects.</h2><span id='topic+corTs'></span>

<h3>Description</h3>

<p>Mean correlation of time series across subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corTs(ts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corTs_+3A_ts">ts</code></td>
<td>
<p>a 3D time series time series x nodes x subjects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>M correlation matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create some sample data with 200 samples,
# 5 nodes, and 2 subjects
ts = array(rnorm(200*5*2), dim=c(200,5,2))
M = corTs(ts)

</code></pre>

<hr>
<h2 id='dgm.group'>A group is a list containing restructured data from subejcts for easier group analysis.</h2><span id='topic+dgm.group'></span>

<h3>Description</h3>

<p>A group is a list containing restructured data from subejcts for easier group analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgm.group(subj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dgm.group_+3A_subj">subj</code></td>
<td>
<p>a list of subjects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>group a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create some sample data with 200 samples,
# 3 nodes, and 2 subjects
ts = array(rnorm(200*3*2), dim=c(200,3,2))
mysubs=list()
mysubs[[1]]=subject(ts[,,1])
mysubs[[2]]=subject(ts[,,2])
g=dgm.group(mysubs)

</code></pre>

<hr>
<h2 id='diag.delta'>Quick diagnostics on delta.</h2><span id='topic+diag.delta'></span>

<h3>Description</h3>

<p>Quick diagnostics on delta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diag.delta(path, id, nodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diag.delta_+3A_path">path</code></td>
<td>
<p>path to results files.</p>
</td></tr>
<tr><td><code id="diag.delta_+3A_id">id</code></td>
<td>
<p>subject identifier.</p>
</td></tr>
<tr><td><code id="diag.delta_+3A_nodes">nodes</code></td>
<td>
<p>number of nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x array node model's delta
</p>

<hr>
<h2 id='dlm.lpl'>Calculate the log predictive likelihood for a specified set of parents and a fixed delta.</h2><span id='topic+dlm.lpl'></span>

<h3>Description</h3>

<p>Calculate the log predictive likelihood for a specified set of parents and a fixed delta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlm.lpl(Yt, Ft, delta, priors = priors.spec())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dlm.lpl_+3A_yt">Yt</code></td>
<td>
<p>the vector of observed time series, length <code>T</code>.</p>
</td></tr>
<tr><td><code id="dlm.lpl_+3A_ft">Ft</code></td>
<td>
<p>the matrix of covariates, dim = number of thetas (<code>p</code>) x number of time
points (<code>T</code>), usually a row of 1s to represent an intercept and the time series of
the parent nodes.</p>
</td></tr>
<tr><td><code id="dlm.lpl_+3A_delta">delta</code></td>
<td>
<p>discount factor (scalar).</p>
</td></tr>
<tr><td><code id="dlm.lpl_+3A_priors">priors</code></td>
<td>
<p>list with prior hyperparameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>mt</code></td>
<td>
<p>the vector or matrix of the posterior mean (location parameter), dim = <code>p x T</code>.</p>
</td></tr>
<tr><td><code>Ct</code></td>
<td>
<p>and <code>CSt</code> the posterior scale matrix <code>C_{t}</code> is <code>C_{t} = C*_{t} x S_{t}</code>,
with dim = <code>p x p x T</code>, where <code>S_{t}</code> is a point estimate for the observation variance
<code>phi^{-1}</code></p>
</td></tr>
<tr><td><code>Rt</code></td>
<td>
<p>and <code>RSt</code> the prior scale matrix <code>R_{t}</code> is <code>R_{t} = R*_{t} x S_{t-1}</code>,
with dim = <code>p x p x T</code>, where <code>S_{t-1}</code> is a point estimate for the observation
variance <code>phi^{-1}</code> at the previous time point.</p>
</td></tr>
<tr><td><code>nt</code></td>
<td>
<p>and <code>dt</code> the vectors of the updated hyperparameters for the precision <code>phi</code>
with length <code>T</code>.</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>the vector of the point estimate for the observation variance <code>phi^{-1}</code> with
length <code>T</code>.</p>
</td></tr>
<tr><td><code>ft</code></td>
<td>
<p>the vector of the one-step forecast location parameter with length <code>T</code>.</p>
</td></tr>
<tr><td><code>Qt</code></td>
<td>
<p>the vector of the one-step forecast scale parameter with length <code>T</code>.</p>
</td></tr>
<tr><td><code>ets</code></td>
<td>
<p>the vector of the standardised forecast residuals with length <code>T</code>,
<code class="reqn">\newline</code> defined as <code>(Y_{t} - f_{t}) / sqrt (Q_{t})</code>.</p>
</td></tr>
<tr><td><code>lpl</code></td>
<td>
<p>the vector of the Log Predictive Likelihood with length <code>T</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>West, M. &amp; Harrison, J., 1997. Bayesian Forecasting and Dynamic Models. Springer New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("utestdata")
Yt = myts[,1]
Ft = t(cbind(1,myts[,2:5]))
m = dlm.lpl(Yt, Ft, 0.7)


</code></pre>

<hr>
<h2 id='dlm.retro'>Calculate the location and scale parameters for the time-varying coefficients 
given all the observations. West, M. &amp; Harrison, J., 1997. Bayesian Forecasting
and Dynamic Models. Springer New York.</h2><span id='topic+dlm.retro'></span>

<h3>Description</h3>

<p>Calculate the location and scale parameters for the time-varying coefficients 
given all the observations. West, M. &amp; Harrison, J., 1997. Bayesian Forecasting
and Dynamic Models. Springer New York.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlm.retro(mt, CSt, RSt, nt, dt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dlm.retro_+3A_mt">mt</code></td>
<td>
<p>the vector or matrix of the posterior mean (location parameter), dim = <code>p x T</code>, 
where <code>p</code> is the number of thetas (at any time <code>t</code>) and <code>T</code> is the number of time points</p>
</td></tr>
<tr><td><code id="dlm.retro_+3A_cst">CSt</code></td>
<td>
<p>the posterior scale matrix with dim = <code>p x p x T</code> (unscaled by the observation variance)</p>
</td></tr>
<tr><td><code id="dlm.retro_+3A_rst">RSt</code></td>
<td>
<p>the prior scale matrix with dim = <code>p x p x T</code> (unscaled by the observation variance)</p>
</td></tr>
<tr><td><code id="dlm.retro_+3A_nt">nt</code></td>
<td>
<p>vector of the updated hyperparameters for the precision <code>phi</code> with length <code>T</code></p>
</td></tr>
<tr><td><code id="dlm.retro_+3A_dt">dt</code></td>
<td>
<p>vector of the updated hyperparameters for the precision <code>phi</code> with length <code>T</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>smt = the location parameter of the retrospective distribution with dimension <code>p x T</code>
sCt = the scale matrix of the retrospective distribution with dimension <code>p x p x T</code>
</p>

<hr>
<h2 id='dlmLplCpp'>C++ implementation of the dlm.lpl</h2><span id='topic+dlmLplCpp'></span>

<h3>Description</h3>

<p>C++ implementation of the dlm.lpl
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlmLplCpp(Yt_, Ft_, delta, m0_, CS0_, n0, d0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dlmLplCpp_+3A_yt_">Yt_</code></td>
<td>
<p>the vector of observed time series</p>
</td></tr>
<tr><td><code id="dlmLplCpp_+3A_ft_">Ft_</code></td>
<td>
<p>the matrix of covariates</p>
</td></tr>
<tr><td><code id="dlmLplCpp_+3A_delta">delta</code></td>
<td>
<p>discount factor</p>
</td></tr>
<tr><td><code id="dlmLplCpp_+3A_m0_">m0_</code></td>
<td>
<p>the value of the prior mean</p>
</td></tr>
<tr><td><code id="dlmLplCpp_+3A_cs0_">CS0_</code></td>
<td>
<p>controls the scaling of the prior variance</p>
</td></tr>
<tr><td><code id="dlmLplCpp_+3A_n0">n0</code></td>
<td>
<p>prior hypermarameter</p>
</td></tr>
<tr><td><code id="dlmLplCpp_+3A_d0">d0</code></td>
<td>
<p>prior hypermarameter</p>
</td></tr>
</table>

<hr>
<h2 id='exhaustive.search'>A function for an exhaustive search, calculates the optimum value of the discount factor.</h2><span id='topic+exhaustive.search'></span>

<h3>Description</h3>

<p>A function for an exhaustive search, calculates the optimum value of the discount factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exhaustive.search(
  Data,
  node,
  nbf = 15,
  delta = seq(0.5, 1, 0.01),
  cpp = TRUE,
  priors = priors.spec()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exhaustive.search_+3A_data">Data</code></td>
<td>
<p>Dataset with dimension number of time points T x Number of nodes Nn.</p>
</td></tr>
<tr><td><code id="exhaustive.search_+3A_node">node</code></td>
<td>
<p>The node to find parents for.</p>
</td></tr>
<tr><td><code id="exhaustive.search_+3A_nbf">nbf</code></td>
<td>
<p>Log Predictive Likelihood will sum from (and including) this time point.</p>
</td></tr>
<tr><td><code id="exhaustive.search_+3A_delta">delta</code></td>
<td>
<p>a vector of potential values for the discount factor.</p>
</td></tr>
<tr><td><code id="exhaustive.search_+3A_cpp">cpp</code></td>
<td>
<p>boolean true (default): fast C++ implementation, false: native R code.</p>
</td></tr>
<tr><td><code id="exhaustive.search_+3A_priors">priors</code></td>
<td>
<p>list with prior hyperparameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>model.store a matrix with the model, LPL and chosen discount factor for all possible models.
runtime an estimate of the run time of the function, using proc.time().
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("utestdata")
result=exhaustive.search(myts,3)

</code></pre>

<hr>
<h2 id='getAdjacency'>Get adjacency and associated likelihoods (LPL) and disount factros (df) of winning models.</h2><span id='topic+getAdjacency'></span>

<h3>Description</h3>

<p>Get adjacency and associated likelihoods (LPL) and disount factros (df) of winning models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAdjacency(winner, nodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAdjacency_+3A_winner">winner</code></td>
<td>
<p>2D matrix.</p>
</td></tr>
<tr><td><code id="getAdjacency_+3A_nodes">nodes</code></td>
<td>
<p>number of nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>adj, 2D adjacency matrix.
</p>

<hr>
<h2 id='getIncompleteNodes'>Checks results and returns job number for incomplete nodes.</h2><span id='topic+getIncompleteNodes'></span>

<h3>Description</h3>

<p>Checks results and returns job number for incomplete nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getIncompleteNodes(path, ids, Nr, Nn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getIncompleteNodes_+3A_path">path</code></td>
<td>
<p>path to results.</p>
</td></tr>
<tr><td><code id="getIncompleteNodes_+3A_ids">ids</code></td>
<td>
<p>subjects ids.</p>
</td></tr>
<tr><td><code id="getIncompleteNodes_+3A_nr">Nr</code></td>
<td>
<p>Number of runs.</p>
</td></tr>
<tr><td><code id="getIncompleteNodes_+3A_nn">Nn</code></td>
<td>
<p>Number of nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>jobs job numbers
</p>

<hr>
<h2 id='getModel'>Extract specific parent model with assocated df and ME from complete model space.</h2><span id='topic+getModel'></span>

<h3>Description</h3>

<p>Extract specific parent model with assocated df and ME from complete model space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getModel(models, parents)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getModel_+3A_models">models</code></td>
<td>
<p>a 2D model matrix.</p>
</td></tr>
<tr><td><code id="getModel_+3A_parents">parents</code></td>
<td>
<p>a vector with parent nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mod specific parent model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("utestdata")
r=exhaustive.search(myts,3)
# get model with parents 1, 2, and 4.
m=getModel(r$model.store,c(1,2,4))

</code></pre>

<hr>
<h2 id='getModelNr'>Get model number from a set of parents.</h2><span id='topic+getModelNr'></span>

<h3>Description</h3>

<p>Get model number from a set of parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getModelNr(models, parents)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getModelNr_+3A_models">models</code></td>
<td>
<p>a 2D model matrix.</p>
</td></tr>
<tr><td><code id="getModelNr_+3A_parents">parents</code></td>
<td>
<p>a vector with parent nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nr model number.
</p>

<hr>
<h2 id='getWinner'>Get winner network by maximazing log predictive likelihood (LPL)
from a set of models.</h2><span id='topic+getWinner'></span>

<h3>Description</h3>

<p>Get winner network by maximazing log predictive likelihood (LPL)
from a set of models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWinner(models, nodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getWinner_+3A_models">models</code></td>
<td>
<p>2D matrix, or 3D models x node.</p>
</td></tr>
<tr><td><code id="getWinner_+3A_nodes">nodes</code></td>
<td>
<p>number of nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>winner array with highest scored model(s).
</p>

<hr>
<h2 id='gplotMat'>Plots network as adjacency matrix.</h2><span id='topic+gplotMat'></span>

<h3>Description</h3>

<p>Plots network as adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gplotMat(
  adj,
  title = NULL,
  colMapLabel = NULL,
  hasColMap = NULL,
  lim = c(0, 1),
  gradient = c("white", "orange", "red"),
  nodeLabels = waiver(),
  axisTextSize = 12,
  xAngle = 0,
  titleTextSize = 12,
  barWidth = 1,
  textSize = 12
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gplotMat_+3A_adj">adj</code></td>
<td>
<p>2D adjacency matrix.</p>
</td></tr>
<tr><td><code id="gplotMat_+3A_title">title</code></td>
<td>
<p>title.</p>
</td></tr>
<tr><td><code id="gplotMat_+3A_colmaplabel">colMapLabel</code></td>
<td>
<p>label for colormap.</p>
</td></tr>
<tr><td><code id="gplotMat_+3A_hascolmap">hasColMap</code></td>
<td>
<p>FALSE turns off color map, default is NULL (on).</p>
</td></tr>
<tr><td><code id="gplotMat_+3A_lim">lim</code></td>
<td>
<p>vector with min and max value, data outside this range will be removed.</p>
</td></tr>
<tr><td><code id="gplotMat_+3A_gradient">gradient</code></td>
<td>
<p>gradient colors.</p>
</td></tr>
<tr><td><code id="gplotMat_+3A_nodelabels">nodeLabels</code></td>
<td>
<p>node labels.</p>
</td></tr>
<tr><td><code id="gplotMat_+3A_axistextsize">axisTextSize</code></td>
<td>
<p>text size of the y and x tick labels.</p>
</td></tr>
<tr><td><code id="gplotMat_+3A_xangle">xAngle</code></td>
<td>
<p>orientation of the x tick labels.</p>
</td></tr>
<tr><td><code id="gplotMat_+3A_titletextsize">titleTextSize</code></td>
<td>
<p>text size of the title.</p>
</td></tr>
<tr><td><code id="gplotMat_+3A_barwidth">barWidth</code></td>
<td>
<p>width of the colorbar.</p>
</td></tr>
<tr><td><code id="gplotMat_+3A_textsize">textSize</code></td>
<td>
<p>width of the colorbar.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some sample binary 5-node network structures for N=20, then compute
# proportion at each edge
N=20
x = array(rbinom(n=5*5*N, size=1, prob=0.30), dim=c(5,5,N))
A = apply(x, c(1,2), mean)

gplotMat(A, title = "network", colMapLabel = '%', barWidth = 0.3)


</code></pre>

<hr>
<h2 id='mergeModels'>Merges forward and backward model store.</h2><span id='topic+mergeModels'></span>

<h3>Description</h3>

<p>Merges forward and backward model store.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeModels(fw, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeModels_+3A_fw">fw</code></td>
<td>
<p>forward model.</p>
</td></tr>
<tr><td><code id="mergeModels_+3A_bw">bw</code></td>
<td>
<p>backward model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>m model store.
</p>

<hr>
<h2 id='model.generator'>A function to generate all the possible models.</h2><span id='topic+model.generator'></span>

<h3>Description</h3>

<p>A function to generate all the possible models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.generator(Nn, node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.generator_+3A_nn">Nn</code></td>
<td>
<p>number of nodes; the number of columns of the dataset can be used.</p>
</td></tr>
<tr><td><code id="model.generator_+3A_node">node</code></td>
<td>
<p>The node to find parents for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output.model = a matrix with dimensions (Nn-1) x number of models, where number of models = 2^(Nn-1).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m=model.generator(5,1)

</code></pre>

<hr>
<h2 id='myts'>Network simulation data.</h2><span id='topic+myts'></span>

<h3>Description</h3>

<p>Simulation 22 5 node net from Smith et al. 2011 (only first subject).
</p>

<hr>
<h2 id='node'>Runs exhaustive search on a single node and saves results in txt file.</h2><span id='topic+node'></span>

<h3>Description</h3>

<p>Runs exhaustive search on a single node and saves results in txt file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node(
  X,
  n,
  id = NULL,
  nbf = 15,
  delta = seq(0.5, 1, 0.01),
  cpp = TRUE,
  priors = priors.spec(),
  path = getwd(),
  method = "exhaustive"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_+3A_x">X</code></td>
<td>
<p>array with dimensions timeseries x nodes.</p>
</td></tr>
<tr><td><code id="node_+3A_n">n</code></td>
<td>
<p>node number.</p>
</td></tr>
<tr><td><code id="node_+3A_id">id</code></td>
<td>
<p>subject ID. If set, results are saved to a txt file.</p>
</td></tr>
<tr><td><code id="node_+3A_nbf">nbf</code></td>
<td>
<p>Log Predictive Likelihood will sum from (and including) this time point.</p>
</td></tr>
<tr><td><code id="node_+3A_delta">delta</code></td>
<td>
<p>a vector of potential values for the discount factor.#'</p>
</td></tr>
<tr><td><code id="node_+3A_cpp">cpp</code></td>
<td>
<p>boolean true (default): fast C++ implementation, false: native R code.</p>
</td></tr>
<tr><td><code id="node_+3A_priors">priors</code></td>
<td>
<p>list with prior hyperparameters.</p>
</td></tr>
<tr><td><code id="node_+3A_path">path</code></td>
<td>
<p>a path where results are written.</p>
</td></tr>
<tr><td><code id="node_+3A_method">method</code></td>
<td>
<p>can be exhaustive (default), forward, backward, or both.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>store list with results.
</p>

<hr>
<h2 id='patel'>Patel.</h2><span id='topic+patel'></span>

<h3>Description</h3>

<p>Patel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patel(X, lower = 0.1, upper = 0.9, bin = 0.75, TK = 0, TT = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patel_+3A_x">X</code></td>
<td>
<p>time x node 2D matrix.</p>
</td></tr>
<tr><td><code id="patel_+3A_lower">lower</code></td>
<td>
<p>percentile cuttoff.</p>
</td></tr>
<tr><td><code id="patel_+3A_upper">upper</code></td>
<td>
<p>percentile cuttoff for 0-1 scaling.</p>
</td></tr>
<tr><td><code id="patel_+3A_bin">bin</code></td>
<td>
<p>threshold for conversion to binary values.</p>
</td></tr>
<tr><td><code id="patel_+3A_tk">TK</code></td>
<td>
<p>significance threshold for connection strength kappa.</p>
</td></tr>
<tr><td><code id="patel_+3A_tt">TT</code></td>
<td>
<p>significance threshold for direction tau.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>PT list with strengths kappa, direction tau, and net structure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some sample data
x=array(rnorm(200*5), dim=c(200,5))
p=patel(x)
</code></pre>

<hr>
<h2 id='patel.group'>A group is a list containing restructured data from subejcts for easier group analysis.</h2><span id='topic+patel.group'></span>

<h3>Description</h3>

<p>A group is a list containing restructured data from subejcts for easier group analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patel.group(subj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patel.group_+3A_subj">subj</code></td>
<td>
<p>a list of subjects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>group a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create some sample data with 200 samples,
# 3 nodes, and 2 subjects
ts = array(rnorm(200*3*2), dim=c(200,3,2))
mysubs=list()
mysubs[[1]]=patel(ts[,,1])
mysubs[[2]]=patel(ts[,,2])
g=patel.group(mysubs)
</code></pre>

<hr>
<h2 id='perf'>Performance of estimates, such as sensitivity, specificity, and more.</h2><span id='topic+perf'></span>

<h3>Description</h3>

<p>Performance of estimates, such as sensitivity, specificity, and more.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perf(x, true)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perf_+3A_x">x</code></td>
<td>
<p>estimated binary network matrix.</p>
</td></tr>
<tr><td><code id="perf_+3A_true">true</code></td>
<td>
<p>true binary network matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p list with results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trueNet=matrix(c(0,0,0,1,0,0,0,1,0),3,3)
am=matrix(c(0,0,0,1,0,1,0,1,0),3,3)
p=perf(am, trueNet)
</code></pre>

<hr>
<h2 id='priors.spec'>Specify the priors. Without inputs, defaults will be used.</h2><span id='topic+priors.spec'></span>

<h3>Description</h3>

<p>Specify the priors. Without inputs, defaults will be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>priors.spec(m0 = 0, CS0 = 3, n0 = 0.001, d0 = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="priors.spec_+3A_m0">m0</code></td>
<td>
<p>the value of the prior mean at time <code>t=0</code>, scalar (assumed to be the same
for all nodes). The default is zero.</p>
</td></tr>
<tr><td><code id="priors.spec_+3A_cs0">CS0</code></td>
<td>
<p>controls the scaling of the prior variance matrix <code>C*_{0}</code> at time 
<code>t=0</code>. The default is 3, giving a non-informative prior for <code>C*_{0}, 3 x (p x p)</code>
identity matrix. <code>p</code> is the number of thetas.</p>
</td></tr>
<tr><td><code id="priors.spec_+3A_n0">n0</code></td>
<td>
<p>prior hyperparameter of precision <code>phi ~ G(n_{0}/2; d_{0}/2)</code>. The default
is a non-informative prior, with <code>n0 = d0 = 0.001</code>. <code>n0</code> has to be higher than 0.</p>
</td></tr>
<tr><td><code id="priors.spec_+3A_d0">d0</code></td>
<td>
<p>prior hyperparameter of precision <code>phi ~ G(n_{0}/2; d_{0}/2)</code>. The default
is a non-informative prior, with <code>n0 = d0 = 0.001</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At time <code>t=0</code>, <code>(theta_{0} | D_{0}, phi) ~ N(m_{0},C*_{0} x phi^{-1})</code>,
where <code>D_{0}</code> denotes the set of initial information.
</p>


<h3>Value</h3>

<p><code>priors</code> a list with the prior hyperparameters. Relevant to <code><a href="#topic+dlm.lpl">dlm.lpl</a>,
 <a href="#topic+exhaustive.search">exhaustive.search</a>, <a href="#topic+node">node</a>, <a href="#topic+subject">subject</a></code>.
</p>


<h3>References</h3>

<p>West, M. &amp; Harrison, J., 1997. Bayesian Forecasting and Dynamic Models. Springer New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pr=priors.spec()
pr=priors.spec(n0=0.002)
</code></pre>

<hr>
<h2 id='prop.nettest'>Comparing two population proportions on the network with FDR correction.</h2><span id='topic+prop.nettest'></span>

<h3>Description</h3>

<p>Comparing two population proportions on the network with FDR correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop.nettest(x1, n1, x2, n2, alpha = 0.05, fdr = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop.nettest_+3A_x1">x1</code></td>
<td>
<p>network matrix with successes in group 1.</p>
</td></tr>
<tr><td><code id="prop.nettest_+3A_n1">n1</code></td>
<td>
<p>sample size group 1.</p>
</td></tr>
<tr><td><code id="prop.nettest_+3A_x2">x2</code></td>
<td>
<p>network matrix with successes in group 2.</p>
</td></tr>
<tr><td><code id="prop.nettest_+3A_n2">n2</code></td>
<td>
<p>sample size group 2.</p>
</td></tr>
<tr><td><code id="prop.nettest_+3A_alpha">alpha</code></td>
<td>
<p>alpha level for uncorrected test.</p>
</td></tr>
<tr><td><code id="prop.nettest_+3A_fdr">fdr</code></td>
<td>
<p>alpha level for FDR.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>store List with test statistics and p-values.
</p>

<hr>
<h2 id='pruning'>Get pruned adjacency network.</h2><span id='topic+pruning'></span>

<h3>Description</h3>

<p>Get pruned adjacency network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pruning(adj, models, winner, e = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pruning_+3A_adj">adj</code></td>
<td>
<p>list with network adjacency from getAdjacency().</p>
</td></tr>
<tr><td><code id="pruning_+3A_models">models</code></td>
<td>
<p>list of models.</p>
</td></tr>
<tr><td><code id="pruning_+3A_winner">winner</code></td>
<td>
<p>matrix 2D with winning models.</p>
</td></tr>
<tr><td><code id="pruning_+3A_e">e</code></td>
<td>
<p>bayes factor for network pruning.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>thr list with pruned network adjacency.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("utestdata")
# select only 3-nodes to speed-up this example
sub=subject(myts[,1:3])
p=pruning(sub$adj, sub$models, sub$winner)
</code></pre>

<hr>
<h2 id='rand.test'>Randomization test for Patel's kappa. Creates a distribution of values
kappa under the null hypothesis.</h2><span id='topic+rand.test'></span>

<h3>Description</h3>

<p>Randomization test for Patel's kappa. Creates a distribution of values
kappa under the null hypothesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rand.test(X, alpha = 0.05, K = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rand.test_+3A_x">X</code></td>
<td>
<p>time x node x subjects 3D matrix.</p>
</td></tr>
<tr><td><code id="rand.test_+3A_alpha">alpha</code></td>
<td>
<p>sign. level</p>
</td></tr>
<tr><td><code id="rand.test_+3A_k">K</code></td>
<td>
<p>number of randomizations, default is 1000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>stat lower and upper significance thresholds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create some sample data with 200 samples,
# 3 nodes, and 2 subjects
ts = array(rnorm(200*3*5), dim=c(200,3,5))
mysubs=list()
mysubs[[1]]=patel(ts[,,1])
mysubs[[2]]=patel(ts[,,2])
mysubs[[3]]=patel(ts[,,3])
mysubs[[4]]=patel(ts[,,4])
mysubs[[5]]=patel(ts[,,5])
g=patel.group(mysubs)
r=rand.test(rmdiag(g$kappa), K=100)
</code></pre>

<hr>
<h2 id='read.subject'>Reads single subject's network from txt files.</h2><span id='topic+read.subject'></span>

<h3>Description</h3>

<p>Reads single subject's network from txt files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.subject(path, id, nodes, modelStore = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.subject_+3A_path">path</code></td>
<td>
<p>path.</p>
</td></tr>
<tr><td><code id="read.subject_+3A_id">id</code></td>
<td>
<p>identifier to select all subjects' nodes, e.g. pattern containing subject ID and session number.</p>
</td></tr>
<tr><td><code id="read.subject_+3A_nodes">nodes</code></td>
<td>
<p>number of nodes.</p>
</td></tr>
<tr><td><code id="read.subject_+3A_modelstore">modelStore</code></td>
<td>
<p>can be set to false to save memory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>store list with results.
</p>

<hr>
<h2 id='reshapeTs'>Reshapes a 2D concatenated time series into 3D according to no. of subjects and volumes.</h2><span id='topic+reshapeTs'></span>

<h3>Description</h3>

<p>Reshapes a 2D concatenated time series into 3D according to no. of subjects and volumes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reshapeTs(ts, N, V)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reshapeTs_+3A_ts">ts</code></td>
<td>
<p>a 2D time series volumes x nodes.</p>
</td></tr>
<tr><td><code id="reshapeTs_+3A_n">N</code></td>
<td>
<p>No. of subjects.</p>
</td></tr>
<tr><td><code id="reshapeTs_+3A_v">V</code></td>
<td>
<p>No. of volumes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>M 3D matrix, time series x nodes x subjects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Let's say subjects are concatenated in a 2D matrix
# (samples x nodes), with each having 200 samples.
# generate some sample data
N=20
Nn=5
x = array(rnorm(200*N*Nn), dim=c(200*N,Nn))
ts = reshapeTs(x,N,200)

</code></pre>

<hr>
<h2 id='rmdiag'>Removes diagonal of NA's from matrix.</h2><span id='topic+rmdiag'></span>

<h3>Description</h3>

<p>Removes diagonal of NA's from matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmdiag(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmdiag_+3A_m">M</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with diagonal of 0's.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M=array(rnorm(3*3), dim=c(3,3))
M[as.logical(diag(3))] = NA
M=rmna(M)
</code></pre>

<hr>
<h2 id='rmna'>Removes NAs from matrix.</h2><span id='topic+rmna'></span>

<h3>Description</h3>

<p>Removes NAs from matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmna(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmna_+3A_m">M</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with NAs removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M=array(NA, dim=c(3,3))
M[1,2]=0.9
M=rmna(M)
</code></pre>

<hr>
<h2 id='rmRecipLow'>Removes reciprocal connections in the lower diagnoal of the network matrix.</h2><span id='topic+rmRecipLow'></span>

<h3>Description</h3>

<p>Removes reciprocal connections in the lower diagnoal of the network matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmRecipLow(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmRecipLow_+3A_m">M</code></td>
<td>
<p>adjacency matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>M adjacency matrix without reciprocal connections.
</p>

<hr>
<h2 id='scaleTs'>Scaling data. Zero centers and scales the nodes (SD=1).</h2><span id='topic+scaleTs'></span>

<h3>Description</h3>

<p>Scaling data. Zero centers and scales the nodes (SD=1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleTs(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaleTs_+3A_x">X</code></td>
<td>
<p>time x node 2D matrix, or 3D with subjects as the 3rd dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>S centered and scaled matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create some sample data
ts = array(rnorm(200*5, mean=5, sd=10), dim=c(200,5))
ts = scaleTs(ts)

</code></pre>

<hr>
<h2 id='stepwise.backward'>Stepise backward non-exhaustive greedy search, calculates the optimum value of the discount factor.</h2><span id='topic+stepwise.backward'></span>

<h3>Description</h3>

<p>Stepise backward non-exhaustive greedy search, calculates the optimum value of the discount factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepwise.backward(
  Data,
  node,
  nbf = 15,
  delta = seq(0.5, 1, 0.01),
  max.break = TRUE,
  priors = priors.spec()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepwise.backward_+3A_data">Data</code></td>
<td>
<p>Dataset with dimension number of time points <code>T</code> x number of nodes <code>Nn</code>.</p>
</td></tr>
<tr><td><code id="stepwise.backward_+3A_node">node</code></td>
<td>
<p>The node to find parents for.</p>
</td></tr>
<tr><td><code id="stepwise.backward_+3A_nbf">nbf</code></td>
<td>
<p>The Log Predictive Likelihood will sum from (and including) this time point.</p>
</td></tr>
<tr><td><code id="stepwise.backward_+3A_delta">delta</code></td>
<td>
<p>A vector of values for the discount factor.</p>
</td></tr>
<tr><td><code id="stepwise.backward_+3A_max.break">max.break</code></td>
<td>
<p>If <code>TRUE</code>, the code will break if adding / removing parents does not
improve the LPL. If <code>FALSE</code>, the code will continue to the zero parent / all parent model.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stepwise.backward_+3A_priors">priors</code></td>
<td>
<p>List with prior hyperparameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>model.store The parents, LPL and chosen discount factor for the subset of models scored using this method.
</p>

<hr>
<h2 id='stepwise.combine'>Stepise combine</h2><span id='topic+stepwise.combine'></span>

<h3>Description</h3>

<p>Stepise combine
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepwise.combine(
  Data,
  node,
  nbf = 15,
  delta = seq(0.5, 1, 0.01),
  max.break = TRUE,
  priors = priors.spec()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepwise.combine_+3A_data">Data</code></td>
<td>
<p>Dataset with dimension number of time points <code>T</code> x number of nodes <code>Nn</code>.</p>
</td></tr>
<tr><td><code id="stepwise.combine_+3A_node">node</code></td>
<td>
<p>The node to find parents for.</p>
</td></tr>
<tr><td><code id="stepwise.combine_+3A_nbf">nbf</code></td>
<td>
<p>The Log Predictive Likelihood will sum from (and including) this time point.</p>
</td></tr>
<tr><td><code id="stepwise.combine_+3A_delta">delta</code></td>
<td>
<p>A vector of values for the discount factor.</p>
</td></tr>
<tr><td><code id="stepwise.combine_+3A_max.break">max.break</code></td>
<td>
<p>If <code>TRUE</code>, the code will break if adding / removing parents does not
improve the LPL. If <code>FALSE</code>, the code will continue to the zero parent / all parent model.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stepwise.combine_+3A_priors">priors</code></td>
<td>
<p>List with prior hyperparameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>model.store The parents, LPL and chosen discount factor for the subset of models scored using this method.
</p>

<hr>
<h2 id='stepwise.forward'>Stepise forward non-exhaustive greedy search, calculates the optimum value of the discount factor.</h2><span id='topic+stepwise.forward'></span>

<h3>Description</h3>

<p>Stepise forward non-exhaustive greedy search, calculates the optimum value of the discount factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepwise.forward(
  Data,
  node,
  nbf = 15,
  delta = seq(0.5, 1, 0.01),
  max.break = TRUE,
  priors = priors.spec()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepwise.forward_+3A_data">Data</code></td>
<td>
<p>Dataset with dimension number of time points <code>T</code> x number of nodes <code>Nn</code>.</p>
</td></tr>
<tr><td><code id="stepwise.forward_+3A_node">node</code></td>
<td>
<p>The node to find parents for.</p>
</td></tr>
<tr><td><code id="stepwise.forward_+3A_nbf">nbf</code></td>
<td>
<p>The Log Predictive Likelihood will sum from (and including) this time point.</p>
</td></tr>
<tr><td><code id="stepwise.forward_+3A_delta">delta</code></td>
<td>
<p>A vector of values for the discount factor.</p>
</td></tr>
<tr><td><code id="stepwise.forward_+3A_max.break">max.break</code></td>
<td>
<p>If <code>TRUE</code>, the code will break if adding / removing parents does not
improve the LPL. If <code>FALSE</code>, the code will continue to the zero parent / all parent model.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stepwise.forward_+3A_priors">priors</code></td>
<td>
<p>List with prior hyperparameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>model.store The parents, LPL and chosen discount factor for the subset of models scored using this method.
</p>

<hr>
<h2 id='subject'>Estimate subject's full network: runs exhaustive search on very node.</h2><span id='topic+subject'></span>

<h3>Description</h3>

<p>Estimate subject's full network: runs exhaustive search on very node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subject(
  X,
  id = NULL,
  nbf = 15,
  delta = seq(0.5, 1, 0.01),
  cpp = TRUE,
  priors = priors.spec(),
  path = getwd(),
  method = "exhaustive"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subject_+3A_x">X</code></td>
<td>
<p>array with dimensions timeseries x nodes.</p>
</td></tr>
<tr><td><code id="subject_+3A_id">id</code></td>
<td>
<p>subject ID. If set, results are saved to a txt file.</p>
</td></tr>
<tr><td><code id="subject_+3A_nbf">nbf</code></td>
<td>
<p>Log Predictive Likelihood will sum from (and including) this time point.</p>
</td></tr>
<tr><td><code id="subject_+3A_delta">delta</code></td>
<td>
<p>a vector of potential values for the discount factor.</p>
</td></tr>
<tr><td><code id="subject_+3A_cpp">cpp</code></td>
<td>
<p>boolean true (default): fast C++ implementation, false: native R code.</p>
</td></tr>
<tr><td><code id="subject_+3A_priors">priors</code></td>
<td>
<p>list with prior hyperparameters.</p>
</td></tr>
<tr><td><code id="subject_+3A_path">path</code></td>
<td>
<p>a path where results are written.</p>
</td></tr>
<tr><td><code id="subject_+3A_method">method</code></td>
<td>
<p>ether exhaustive, foward, backward, or both.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>store list with results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("utestdata")
# select only 3-nodes to speed-up this example
sub=subject(myts[,1:3]) 
sub=subject(myts[,1:3], method="both")

</code></pre>

<hr>
<h2 id='symmetric'>Turns asymetric network into an symmetric network. Helper function to
determine the detection of a connection while ignoring directionality.</h2><span id='topic+symmetric'></span>

<h3>Description</h3>

<p>Turns asymetric network into an symmetric network. Helper function to
determine the detection of a connection while ignoring directionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symmetric(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symmetric_+3A_m">M</code></td>
<td>
<p>3D matrix nodes x nodes x subjects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3D matrix nodes x nodes x subjects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M=array(NA, dim=c(3,3,2))
M[,,1]=matrix(c(0,0,0,1,0,0,0,1,0),3,3)
M[,,2]=matrix(c(0,0,0,1,0,0,0,0,0),3,3)
M_=symmetric(M)
</code></pre>

<hr>
<h2 id='ttest.nettest'>Comparing connectivity strenght of two groups with FDR correction.</h2><span id='topic+ttest.nettest'></span>

<h3>Description</h3>

<p>Comparing connectivity strenght of two groups with FDR correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ttest.nettest(m, g, alpha = 0.05, fdr = 0.05, perm = FALSE, n_perm = 9999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ttest.nettest_+3A_m">m</code></td>
<td>
<p>matrix with Nn x Nn x N.</p>
</td></tr>
<tr><td><code id="ttest.nettest_+3A_g">g</code></td>
<td>
<p>group assignment, vector of type factor of size N.</p>
</td></tr>
<tr><td><code id="ttest.nettest_+3A_alpha">alpha</code></td>
<td>
<p>alpha level for uncorrected test.</p>
</td></tr>
<tr><td><code id="ttest.nettest_+3A_fdr">fdr</code></td>
<td>
<p>FDR alpha level.</p>
</td></tr>
<tr><td><code id="ttest.nettest_+3A_perm">perm</code></td>
<td>
<p>optional permuation test, default is false.</p>
</td></tr>
<tr><td><code id="ttest.nettest_+3A_n_perm">n_perm</code></td>
<td>
<p>number of permutations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>store List with test statistics and p-values.
</p>

<hr>
<h2 id='utestdata'>Results from v.1.0 for unit tests.</h2><span id='topic+utestdata'></span>

<h3>Description</h3>

<p>Some LPL values (n2 parent of n1 Simulation 22) to test against.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
