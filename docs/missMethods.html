<!DOCTYPE html><html><head><title>Help for package missMethods</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {missMethods}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#apply_imputation'><p>Apply a function for imputation</p></a></li>
<li><a href='#count_NA'><p>Count the number of <code>NA</code>s</p></a></li>
<li><a href='#delete_MAR_1_to_x'><p>Create MAR values using MAR1:x</p></a></li>
<li><a href='#delete_MAR_censoring'><p>Create MAR values using a censoring mechanism</p></a></li>
<li><a href='#delete_MAR_one_group'><p>Create MAR values by deleting values in one of two groups</p></a></li>
<li><a href='#delete_MAR_rank'><p>Create MAR values using a ranking mechanism</p></a></li>
<li><a href='#delete_MCAR'><p>Create MCAR values</p></a></li>
<li><a href='#delete_MNAR_1_to_x'><p>Create MNAR values using MNAR1:x</p></a></li>
<li><a href='#delete_MNAR_censoring'><p>Create MNAR values using a censoring mechanism</p></a></li>
<li><a href='#delete_MNAR_one_group'><p>Create MNAR values by deleting values in one of two groups</p></a></li>
<li><a href='#delete_MNAR_rank'><p>Create MNAR values using a ranking mechanism</p></a></li>
<li><a href='#evaluate_imputation_parameters'><p>Evaluate estimated parameters after imputation</p></a></li>
<li><a href='#evaluate_imputed_values'><p>Evaluate imputed values</p></a></li>
<li><a href='#evaluate_parameters'><p>Evaluate estimated parameters</p></a></li>
<li><a href='#impute_EM'><p>EM imputation</p></a></li>
<li><a href='#impute_expected_values'><p>Impute expected values</p></a></li>
<li><a href='#impute_hot_deck_in_classes'><p>Hot deck imputation in imputation classes</p></a></li>
<li><a href='#impute_in_classes'><p>Impute in classes</p></a></li>
<li><a href='#impute_LS_adaptive'><p>LSimpute_adaptive</p></a></li>
<li><a href='#impute_LS_array'><p>LSimpute_array</p></a></li>
<li><a href='#impute_LS_combined'><p>LSimpute_combined</p></a></li>
<li><a href='#impute_LS_gene'><p>LSimpute_gene</p></a></li>
<li><a href='#impute_mean'><p>Mean imputation</p></a></li>
<li><a href='#impute_median'><p>Median imputation</p></a></li>
<li><a href='#impute_mode'><p>Mode imputation</p></a></li>
<li><a href='#impute_sRHD'><p>Simple random hot deck imputation</p></a></li>
<li><a href='#median.factor'><p>Median for ordered factors</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Methods for Missing Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Supply functions for the creation and handling of missing
    data as well as tools to evaluate missing data methods. Nearly all
    possibilities of generating missing data discussed by Santos et al.
    (2019) &lt;<a href="https://doi.org/10.1109%2FACCESS.2019.2891360">doi:10.1109/ACCESS.2019.2891360</a>&gt; and some additional are
    implemented.  Functions are supplied to compare parameter estimates
    and imputed values to true values to evaluate missing data methods.
    Evaluations of these types are done, for example, by Cetin-Berber et
    al. (2019) &lt;<a href="https://doi.org/10.1177%2F0013164418805532">doi:10.1177/0013164418805532</a>&gt; and Kim et al. (2005)
    &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbth499">doi:10.1093/bioinformatics/bth499</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/torockel/missMethods">https://github.com/torockel/missMethods</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/torockel/missMethods/issues">https://github.com/torockel/missMethods/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>mvtnorm, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, knitr, lpSolve, norm, rmarkdown, testthat (&ge;
2.1.0), tibble</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-16 14:46:50 UTC; toro5213</td>
</tr>
<tr>
<td>Author:</td>
<td>Tobias Rockel [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tobias Rockel &lt;Rockel.To@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-16 15:16:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='apply_imputation'>Apply a function for imputation</h2><span id='topic+apply_imputation'></span>

<h3>Description</h3>

<p>Apply a function for imputation over rows, columns or combinations of both
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_imputation(
  ds,
  FUN = mean,
  type = "columnwise",
  convert_tibble = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_imputation_+3A_ds">ds</code></td>
<td>
<p>A data frame or matrix with missing values.</p>
</td></tr>
<tr><td><code id="apply_imputation_+3A_fun">FUN</code></td>
<td>
<p>The function to be applied for imputation.</p>
</td></tr>
<tr><td><code id="apply_imputation_+3A_type">type</code></td>
<td>
<p>A string specifying the values used for imputation; one of:
&quot;columnwise&quot;, &quot;rowwise&quot;, &quot;total&quot;, &quot;Two-Way&quot; or &quot;Winer&quot;  (see details).</p>
</td></tr>
<tr><td><code id="apply_imputation_+3A_convert_tibble">convert_tibble</code></td>
<td>
<p>If <code>ds</code> is a tibble, should it be converted
(see section A note for tibble users).</p>
</td></tr>
<tr><td><code id="apply_imputation_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functionality of <code>apply_imputation</code> is inspired by the
<code><a href="base.html#topic+apply">apply</a></code> function. The function applies a function
<code>FUN</code> to impute the missing values in <code>ds</code>. <code>FUN</code> must be a
function, which takes a vector as input and returns exactly one value. The
argument <code>type</code> is comparable to <code><a href="base.html#topic+apply">apply</a></code>'s
<code>MARGIN</code> argument. It specifies the values that are used for the
calculation of the imputation values. For example, <code>type = "columnwise"</code>
and <code>FUN = mean</code> will impute the mean of the observed values in a column
for all missing values in this column. In contrast, <code>type = "rowwise"</code>
and <code>FUN = mean</code> will impute the mean of the observed values in a row
for all missing values in this row.
</p>
<p>List of all implemented <code>types</code>:
</p>

<ul>
<li><p>&quot;columnwise&quot; (the default): imputes column by column; all observed
values of a column are given  to <code>FUN</code> and the returned value is used
as the imputation value for all missing values of the column.
</p>
</li>
<li><p>&quot;rowwise&quot;: imputes row by row; all observed values of a row are given
to <code>FUN</code> and the returned value is used as the imputation value for all
missing values of the row.
</p>
</li>
<li><p>&quot;total&quot;: All observed values of <code>ds</code> are given to <code>FUN</code> and
the returned value is used as the imputation value for all missing values of
<code>ds</code>.
</p>
</li>
<li><p>&quot;Winer&quot;: The mean value from &quot;columnwise&quot; and &quot;rowwise&quot; is used as the
imputation value.
</p>
</li>
<li><p>&quot;Two-Way&quot;: The sum of the values from &quot;columnwise&quot; and &quot;rowwise&quot; minus
&quot;total&quot; is used as the imputation value.
</p>
</li></ul>

<p>If no value can be given to <code>FUN</code> (for example, if no value in a column
is observed and <code>type = "columnwise"</code>), then a warning will be issued
and no value will be imputed in the corresponding column or row.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>ds</code> with imputed missing values.
</p>


<h3>A note for tibble users</h3>

<p>If you use tibbles and <code>convert_tibble</code> is <code>TRUE</code> the tibble is
first converted to a data frame, then imputed and converted back. If
<code>convert_tibble</code> is <code>FALSE</code> no conversion is done. However,
depending on the tibble and the package version of tibble you use,
imputation may not be possible and some errors will be thrown.
</p>


<h3>References</h3>

<p>Beland, S., Pichette, F., &amp; Jolani, S. (2016). Impact on
Cronbach's <code class="reqn">\alpha</code> of simple treatment methods for missing
data. <em>The Quantitative Methods for Psychology</em>, 12(1), 57-73.
</p>


<h3>See Also</h3>

<p>A convenient interface exists for common cases like mean imputation:
<code><a href="#topic+impute_mean">impute_mean</a></code>, <code><a href="#topic+impute_median">impute_median</a></code>,
<code><a href="#topic+impute_mode">impute_mode</a></code>. All these functions
call <code>apply_imputation</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ds &lt;- data.frame(X = 1:20, Y = 101:120)
ds_mis &lt;- delete_MCAR(ds, 0.2)
ds_imp_app &lt;- apply_imputation(ds_mis, FUN = mean, type = "total")
# the same result can be achieved via impute_mean():
ds_imp_mean &lt;- impute_mean(ds_mis, type = "total")
all.equal(ds_imp_app, ds_imp_mean)
</code></pre>

<hr>
<h2 id='count_NA'>Count the number of <code>NA</code>s</h2><span id='topic+count_NA'></span>

<h3>Description</h3>

<p>Count the number of <code>NA</code> values in a vector, matrix or data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_NA(x, type = "default")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_NA_+3A_x">x</code></td>
<td>
<p>a vector, matrix or data frame, in which <code>NA</code> values are counted</p>
</td></tr>
<tr><td><code id="count_NA_+3A_type">type</code></td>
<td>
<p>How to count the <code>NA</code> values. Possible choices:
</p>

<ul>
<li><p> &quot;default&quot;: If <code>x</code> is a matrix or a data frame, the number of missing
values per column is returned. If <code>x</code> is something else, the total number
of missing values in <code>x</code> is returned.
</p>
</li>
<li><p> &quot;all&quot;: The number of all missing values in <code>x</code> is returned.
</p>
</li>
<li><p> &quot;cols&quot;: The number of missing values per column is returned.
</p>
</li>
<li><p> &quot;rows&quot;: The number of missing values per row is returned.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of missing values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>count_NA(c(1, NA, 3, NA, 5, NA))
test_df &lt;- data.frame(X1 = rep(c(1, NA), 5), X2 = c(1:9, NA))
count_NA(test_df)
count_NA(test_df, "cols") # the default
count_NA(test_df, "rows")
count_NA(test_df, "all")
</code></pre>

<hr>
<h2 id='delete_MAR_1_to_x'>Create MAR values using MAR1:x</h2><span id='topic+delete_MAR_1_to_x'></span>

<h3>Description</h3>

<p>Create missing at random (MAR) values using MAR1:x in a data frame or
a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_MAR_1_to_x(
  ds,
  p,
  cols_mis,
  cols_ctrl,
  x,
  cutoff_fun = median,
  prop = 0.5,
  use_lpSolve = TRUE,
  ordered_as_unordered = FALSE,
  n_mis_stochastic = FALSE,
  x_stochastic = FALSE,
  add_realized_x = FALSE,
  ...,
  miss_cols,
  ctrl_cols,
  stochastic
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_MAR_1_to_x_+3A_ds">ds</code></td>
<td>
<p>A data frame or matrix in which missing values will be created.</p>
</td></tr>
<tr><td><code id="delete_MAR_1_to_x_+3A_p">p</code></td>
<td>
<p>A numeric vector with length one or equal to length <code>cols_mis</code>;
the probability that a value is missing.</p>
</td></tr>
<tr><td><code id="delete_MAR_1_to_x_+3A_cols_mis">cols_mis</code></td>
<td>
<p>A vector of column names or indices of columns in which
missing values will be created.</p>
</td></tr>
<tr><td><code id="delete_MAR_1_to_x_+3A_cols_ctrl">cols_ctrl</code></td>
<td>
<p>A vector of column names or indices of columns, which
controls the creation of missing values in <code>cols_mis</code>. Must be of the
same length as <code>cols_mis</code>.</p>
</td></tr>
<tr><td><code id="delete_MAR_1_to_x_+3A_x">x</code></td>
<td>
<p>Numeric with length one (0 &lt; x &lt; <code>Inf</code>); odds are 1 to x for
the probability of a value to be missing in group 1 against the probability
of a value to be missing  in group 2 (see details).</p>
</td></tr>
<tr><td><code id="delete_MAR_1_to_x_+3A_cutoff_fun">cutoff_fun</code></td>
<td>
<p>Function that calculates the cutoff values in the
<code>cols_ctrl</code>.</p>
</td></tr>
<tr><td><code id="delete_MAR_1_to_x_+3A_prop">prop</code></td>
<td>
<p>Numeric of length one; (minimum) proportion of rows in group 1
(only used for unordered factors).</p>
</td></tr>
<tr><td><code id="delete_MAR_1_to_x_+3A_use_lpsolve">use_lpSolve</code></td>
<td>
<p>Logical; should lpSolve be used for the determination of
groups, if <code>cols_ctrl[i]</code> is an unordered factor.</p>
</td></tr>
<tr><td><code id="delete_MAR_1_to_x_+3A_ordered_as_unordered">ordered_as_unordered</code></td>
<td>
<p>Logical; should ordered factors be treated as
unordered factors.</p>
</td></tr>
<tr><td><code id="delete_MAR_1_to_x_+3A_n_mis_stochastic">n_mis_stochastic</code></td>
<td>
<p>Logical, should the number of missing values be
stochastic? If <code>n_mis_stochastic = TRUE</code>, the number of missing values
for a column with missing values <code>cols_mis[i]</code> is a random variable
with expected value <code>nrow(ds) * p[i]</code>. If <code>n_mis_stochastic =
FALSE</code>, the number of missing values will be deterministic. Normally, the
number of missing values for a column with missing values
<code>cols_mis[i]</code> is <code>round(nrow(ds) * p[i])</code>. Possible deviations
from this value, if any exists, are documented in Details.</p>
</td></tr>
<tr><td><code id="delete_MAR_1_to_x_+3A_x_stochastic">x_stochastic</code></td>
<td>
<p>Logical; should the odds be stochastic or deterministic.</p>
</td></tr>
<tr><td><code id="delete_MAR_1_to_x_+3A_add_realized_x">add_realized_x</code></td>
<td>
<p>Logical; if TRUE the realized odds for cols_mis will
be returned (as attribute).</p>
</td></tr>
<tr><td><code id="delete_MAR_1_to_x_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>cutoff_fun</code>.</p>
</td></tr>
<tr><td><code id="delete_MAR_1_to_x_+3A_miss_cols">miss_cols</code></td>
<td>
<p>Deprecated, use <code>cols_mis</code> instead.</p>
</td></tr>
<tr><td><code id="delete_MAR_1_to_x_+3A_ctrl_cols">ctrl_cols</code></td>
<td>
<p>Deprecated, use <code>cols_ctrl</code> instead.</p>
</td></tr>
<tr><td><code id="delete_MAR_1_to_x_+3A_stochastic">stochastic</code></td>
<td>
<p>Deprecated, use <code>n_mis_stochastic</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates missing at random (MAR) values in the columns
specified by the argument <code>cols_mis</code>.
The probability for missing values is controlled by <code>p</code>.
If <code>p</code> is a single number, then the overall probability for a value to
be missing will be <code>p</code> in all columns of <code>cols_mis</code>.
(Internally <code>p</code> will be replicated to a vector of the same length as
<code>cols_mis</code>.
So, all <code>p[i]</code> in the following sections will be equal to the given
single number <code>p</code>.)
Otherwise, <code>p</code> must be of the same length as <code>cols_mis</code>.
In this case, the overall probability for a value to be missing will be
<code>p[i]</code> in the column <code>cols_mis[i]</code>.
The position of the missing values in <code>cols_mis[i]</code> is controlled by
<code>cols_ctrl[i]</code>.
The following procedure is applied for each pair of <code>cols_ctrl[i]</code> and
<code>cols_mis[i]</code> to determine the positions of missing values:
</p>
<p>At first, the rows of <code>ds</code> are divided into two groups.
Therefore, the <code>cutoff_fun</code> calculates a cutoff value for
<code>cols_ctrl[i]</code> (via <code>cutoff_fun(ds[, cols_ctrl[i]], ...)</code>).
The group 1 consists of the rows, whose values in
<code>cols_ctrl[i]</code> are below the calculated cutoff value.
If the so defined group 1 is empty, the rows that have a value equal to the
cutoff value will be added to this group (otherwise, these rows will
belong to group 2).
The group 2 consists of the remaining rows, which are not part of group 1.
Now the probabilities for the rows in the two groups are set in the way
that the odds are 1:x against a missing value in <code>cols_mis[i]</code> for the
rows in group 1 compared to the rows in group 2.
That means, the probability for a value to be missing in group 1 divided by
the probability for a value to be missing in group 2 equals 1 divided
by x.
For example, for two equal sized groups 1 and 2, ideally the number of NAs in
group 1 divided by the number of NAs in group 2 should equal 1 divided by x.
But there are some restrictions, which can lead to some deviations from the
odds 1:x (see below).
</p>
<p>If <code>x_stochastic</code> and <code>n_mis_stochastic</code> are false (the default),
then exactly <code>round(nrow(ds) * p[i])</code> values will be set <code>NA</code> in
column <code>cols_mis[i]</code>.
To achieve this, it is possible that the true odds differ from 1:x.
The number of observations that are deleted in group 1 and group 2 are
chosen to minimize the absolute difference between the realized odds and 1:x.
Furthermore, if <code>round(nrow(ds) * p[i])</code> == 0, then no missing value
will be created in <code>cols_mis[i]</code>.
</p>
<p>If <code>x_stochastic</code> is true, the rows from the two groups will get
sampling weights proportional to 1 (group 1) and x (group 2). If
<code>n_mis_stochastic</code> is false, these weights are given to
<code><a href="base.html#topic+sample">sample</a></code> via the argument <code>prob</code> and exactly
<code>round(nrow(ds) * p[i])</code> values will be set <code>NA</code>. If
<code>n_mis_stochastic</code> is true, the sampling weights will be scaled and
compared to uniform random numbers. The scaling is done in such a way to get
expected <code>nrow(ds) * p[i]</code> missing values in <code>cols_mis[i]</code>.
</p>
<p>If <code>p</code> is high and <code>x</code> is too high or too low, it is possible that
the odds 1:x and the proportion of missing values <code>p</code> cannot be
realized together.
For example, if <code>p[i]</code> = 0.9, then a maximum of <code>x</code> = 1.25 is
possible (assuming that  exactly 50 % of the values are below and 50 % of
the values are above the cutoff value in <code>cols_ctrl[i]</code>).
If a combination of <code>p</code> and <code>x</code> that cannot be realized together
is given to <code>delete_MAR_1_to_x</code>, then a warning will be generated and
<code>x</code> will be adjusted in such a way that <code>p</code> can be realized as
given to the function. The warning can be silenced by setting the option
<code>missMethods.warn.too.high.p</code> to false.
</p>
<p>The argument <code>add_realized_x</code> controls whether the x of the realized
odds are added to the return value or not.
If <code>add_realized_x = TRUE</code>, then the realized x values for all
<code>cols_mis</code> will be added as an attribute to the returned object.
For <code>x_stochastic = TRUE</code> these realized x will differ from the given
<code>x</code> most of the time and will change if the function is rerun without
setting a seed.
For <code>x_stochastic = FALSE</code>, it is also possible that the realized odds
differ (see above). However, the realized odds will be constant over multiple
runs.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>ds</code> with missing values.
</p>


<h3>Treatment of factors</h3>

<p>If <code>ds[, cols_ctrl[i]]</code> is an unordered factor, then the concept of a
cutoff value is not meaningful and cannot be applied.
Instead, a combinations of the levels of the unordered factor is searched that
</p>

<ul>
<li><p>guarantees at least a proportion of <code>prop</code> rows are in group 1
</p>
</li>
<li><p>minimize the difference between <code>prop</code> and the proportion of
rows in group 1.
</p>
</li></ul>

<p>This can be seen as a binary search problem, which is solved by the solver
from the package <code>lpSolve</code>, if <code>use_lpSolve = TRUE</code>.
If <code>use_lpSolve = FALSE</code>, a very simple heuristic is applied.
The heuristic only guarantees that at least a proportion of <code>prop</code> rows
are in group 1.
The choice <code>use_lpSolve = FALSE</code> is not recommend and should only be
considered, if the solver of lpSolve fails.
</p>
<p>If <code>ordered_as_unordered = TRUE</code>, then ordered factors will be treated
like unordered factors and the same binary search problem will be solved for
both types of factors.
If <code>ordered_as_unordered = FALSE</code> (the default), then ordered factors
will be grouped via <code>cutoff_fun</code> as described in Details.
</p>


<h3>References</h3>

<p>Santos, M. S., Pereira, R. C., Costa, A. F., Soares, J. P.,
Santos, J., &amp; Abreu, P. H. (2019). Generating Synthetic Missing Data: A
Review by Missing Mechanism. <em>IEEE Access</em>, 7, 11651-11667
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delete_MNAR_1_to_x">delete_MNAR_1_to_x</a></code>
</p>
<p>Other functions to create MAR: 
<code><a href="#topic+delete_MAR_censoring">delete_MAR_censoring</a>()</code>,
<code><a href="#topic+delete_MAR_one_group">delete_MAR_one_group</a>()</code>,
<code><a href="#topic+delete_MAR_rank">delete_MAR_rank</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ds &lt;- data.frame(X = 1:20, Y = 101:120)
delete_MAR_1_to_x(ds, 0.2, "X", "Y", 3)
# beware of small datasets and x_stochastic = FALSE
attr(delete_MAR_1_to_x(ds, 0.4, "X", "Y", 3, add_realized_x = TRUE), "realized_x")
attr(delete_MAR_1_to_x(ds, 0.4, "X", "Y", 4, add_realized_x = TRUE), "realized_x")
attr(delete_MAR_1_to_x(ds, 0.4, "X", "Y", 5, add_realized_x = TRUE), "realized_x")
attr(delete_MAR_1_to_x(ds, 0.4, "X", "Y", 7, add_realized_x = TRUE), "realized_x")
# p = 0.4 and 20 values -&gt; 8 missing values, possible combinations:
# either 6 above 2 below (x = 3) or
# 7 above and 1 below (x = 7)
# Too high combination of p and x:
tryCatch(delete_MAR_1_to_x(ds, 0.9, "X", "Y", 3), warning = function(w) w)
</code></pre>

<hr>
<h2 id='delete_MAR_censoring'>Create MAR values using a censoring mechanism</h2><span id='topic+delete_MAR_censoring'></span>

<h3>Description</h3>

<p>Create missing at random (MAR) values using a censoring mechanism in a data
frame or a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_MAR_censoring(
  ds,
  p,
  cols_mis,
  cols_ctrl,
  n_mis_stochastic = FALSE,
  where = "lower",
  sorting = TRUE,
  miss_cols,
  ctrl_cols
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_MAR_censoring_+3A_ds">ds</code></td>
<td>
<p>A data frame or matrix in which missing values will be created.</p>
</td></tr>
<tr><td><code id="delete_MAR_censoring_+3A_p">p</code></td>
<td>
<p>A numeric vector with length one or equal to length <code>cols_mis</code>;
the probability that a value is missing.</p>
</td></tr>
<tr><td><code id="delete_MAR_censoring_+3A_cols_mis">cols_mis</code></td>
<td>
<p>A vector of column names or indices of columns in which
missing values will be created.</p>
</td></tr>
<tr><td><code id="delete_MAR_censoring_+3A_cols_ctrl">cols_ctrl</code></td>
<td>
<p>A vector of column names or indices of columns, which
controls the creation of missing values in <code>cols_mis</code>. Must be of the
same length as <code>cols_mis</code>.</p>
</td></tr>
<tr><td><code id="delete_MAR_censoring_+3A_n_mis_stochastic">n_mis_stochastic</code></td>
<td>
<p>Logical, should the number of missing values be
stochastic? If <code>n_mis_stochastic = TRUE</code>, the number of missing values
for a column with missing values <code>cols_mis[i]</code> is a random variable
with expected value <code>nrow(ds) * p[i]</code>. If <code>n_mis_stochastic =
FALSE</code>, the number of missing values will be deterministic. Normally, the
number of missing values for a column with missing values
<code>cols_mis[i]</code> is <code>round(nrow(ds) * p[i])</code>. Possible deviations
from this value, if any exists, are documented in Details.</p>
</td></tr>
<tr><td><code id="delete_MAR_censoring_+3A_where">where</code></td>
<td>
<p>Controls where missing values are created; one of &quot;lower&quot;,
&quot;upper&quot; or &quot;both&quot; (see details).</p>
</td></tr>
<tr><td><code id="delete_MAR_censoring_+3A_sorting">sorting</code></td>
<td>
<p>Logical; should sorting be used or a quantile as a threshold.</p>
</td></tr>
<tr><td><code id="delete_MAR_censoring_+3A_miss_cols">miss_cols</code></td>
<td>
<p>Deprecated, use <code>cols_mis</code> instead.</p>
</td></tr>
<tr><td><code id="delete_MAR_censoring_+3A_ctrl_cols">ctrl_cols</code></td>
<td>
<p>Deprecated, use <code>cols_ctrl</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates missing at random (MAR) values in the columns
specified by the argument <code>cols_mis</code>.
The probability for missing values is controlled by <code>p</code>.
If <code>p</code> is a single number, then the overall probability for a value to
be missing will be <code>p</code> in all columns of <code>cols_mis</code>.
(Internally <code>p</code> will be replicated to a vector of the same length as
<code>cols_mis</code>.
So, all <code>p[i]</code> in the following sections will be equal to the given
single number <code>p</code>.)
Otherwise, <code>p</code> must be of the same length as <code>cols_mis</code>.
In this case, the overall probability for a value to be missing will be
<code>p[i]</code> in the column <code>cols_mis[i]</code>.
The position of the missing values in <code>cols_mis[i]</code> is controlled by
<code>cols_ctrl[i]</code>.
The following procedure is applied for each pair of <code>cols_ctrl[i]</code> and
<code>cols_mis[i]</code> to determine the positions of missing values:
</p>
<p>The default behavior (<code>sorting = TRUE</code>) of this function is to first
sort the column <code>cols_ctrl[i]</code>. Then missing values in
<code>cols_mis[i]</code> are created in the rows with the <code>round(nrow(ds) *
p[i])</code> smallest values. This censors approximately the proportion of
<code>p[i]</code> rows of smallest values in <code>cols_ctrl[i]</code> in
<code>cols_mis[i]</code>. Hence, the name of the function.
</p>
<p>If <code>where = "upper"</code>, instead of the rows with the smallest values, the
rows with the highest values will be selected. For <code>where = "both"</code>, the
one half of the <code>round(nrow(ds) * p[i])</code> rows with missing values will
be the rows with the smallest values and the other half will be the rows with
the highest values. So the censoring rows are dived to the highest and
smallest values of <code>cols_ctrl[i]</code>. For odd <code>round(nrow(ds) * p[i])</code>
one more value is set <code>NA</code> among the smallest values.
</p>
<p>If <code>n_mis_stochastic = TRUE</code> and <code>sorting = TRUE</code> the procedure is
lightly altered. In this case, at first the <code>floor(nrow(ds) * p[i])</code>
rows with the smallest values (<code>where = "lower"</code>) are set NA. If
<code>nrow(ds) * p[i] &gt; floor(nrow(ds) * p[i])</code>, the row with the next
greater value will be set NA with a probability to get expected
<code>nrow(ds) * p[i]</code> missing values. For <code>where = "upper"</code> this
&quot;random&quot; missing value will be the next smallest. For <code>where = "both"</code>
this &quot;random&quot; missing value will be the next greatest of the smallest values.
</p>
<p>If <code>sorting = FALSE</code>, the rows of <code>ds</code> will not be sorted. Instead,
a quantile will be calculated (using <code><a href="stats.html#topic+quantile">quantile</a></code>). If
<code>where = "lower"</code>, the <code>quantile(ds[, cols_ctrl[i]], p[i])</code> will be
calculated and all rows with values in <code>ds[, cols_ctrl[i]]</code> below this
quantile will have missing values in <code>cols_mis[i]</code>. For <code>where =
"upper"</code>, the <code>quantile(ds[, cols_ctrl[i]], 1 - p[i])</code> will be
calculated and all rows with values above this quantile will have missing
values. For <code>where = "both"</code>, the <code>quantile(ds[, cols_ctrl[i]],
p[i] / 2)</code> and <code>quantile(ds[, cols_ctrl[i]], 1 -  p[i] / 2)</code> will be
calculated. All rows with values in <code>cols_ctrl[i]</code> below the first
quantile or above the second quantile will have missing values in
<code>cols_mis[i]</code>.
</p>
<p>For <code>sorting = FALSE</code> only <code>n_mis_stochastic = FALSE</code> is
implemented at the moment.
</p>
<p>The option <code>sorting = TRUE</code> with <code>n_mis_stochastic = FALSE</code> will
always create exactly <code>round(nrow(ds) * p[i])</code> missing values in
<code>cols_mis[i]</code>. With <code>n_mis_stochastic = TRUE</code>) sorting will result
in <code>floor(nrow(ds) * p[i])</code> or <code>ceiling(nrow(ds) * p[i])</code> missing
values in <code>cols_mis[i]</code>. For <code>sorting = FALSE</code>, the number of
missing values will normally be close to <code>nrow(ds) * p[i]</code>. But for
<code>cols_ctrl</code> with many duplicates the choice <code>sorting = FALSE</code> can
be problematic, because of the calculation of <code>quantile(ds[,
cols_ctrl[i]], p[i])</code> and setting values <code>NA</code> below this threshold (see
examples). So, in most cases <code>sorting = TRUE</code> is recommended.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>ds</code> with missing values.
</p>


<h3>References</h3>

<p>Santos, M. S., Pereira, R. C., Costa, A. F., Soares, J. P.,
Santos, J., &amp; Abreu, P. H. (2019). Generating Synthetic Missing Data: A
Review by Missing Mechanism. <em>IEEE Access</em>, 7, 11651-11667
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delete_MNAR_censoring">delete_MNAR_censoring</a></code>
</p>
<p>Other functions to create MAR: 
<code><a href="#topic+delete_MAR_1_to_x">delete_MAR_1_to_x</a>()</code>,
<code><a href="#topic+delete_MAR_one_group">delete_MAR_one_group</a>()</code>,
<code><a href="#topic+delete_MAR_rank">delete_MAR_rank</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ds &lt;- data.frame(X = 1:20, Y = 101:120)
delete_MAR_censoring(ds, 0.2, "X", "Y")
# many dupplicated values can be problematic for sorting = FALSE:
ds_many_dup &lt;- data.frame(X = 1:20, Y = c(rep(0, 10), rep(1, 10)))
delete_MAR_censoring(ds_many_dup, 0.2, "X", "Y") # 4 NAs as expected
quantile(ds_many_dup$Y, 0.2) # 0
# No value is BELOW 0 in ds_many_dup$Y, so no missing values will be created:
delete_MAR_censoring(ds_many_dup, 0.2, "X", "Y", sorting = FALSE) # No NA!
</code></pre>

<hr>
<h2 id='delete_MAR_one_group'>Create MAR values by deleting values in one of two groups</h2><span id='topic+delete_MAR_one_group'></span>

<h3>Description</h3>

<p>Create missing at random (MAR) values by deleting values in one of two
groups in a data frame or a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_MAR_one_group(
  ds,
  p,
  cols_mis,
  cols_ctrl,
  cutoff_fun = median,
  prop = 0.5,
  use_lpSolve = TRUE,
  ordered_as_unordered = FALSE,
  n_mis_stochastic = FALSE,
  ...,
  miss_cols,
  ctrl_cols,
  stochastic
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_MAR_one_group_+3A_ds">ds</code></td>
<td>
<p>A data frame or matrix in which missing values will be created.</p>
</td></tr>
<tr><td><code id="delete_MAR_one_group_+3A_p">p</code></td>
<td>
<p>A numeric vector with length one or equal to length <code>cols_mis</code>;
the probability that a value is missing.</p>
</td></tr>
<tr><td><code id="delete_MAR_one_group_+3A_cols_mis">cols_mis</code></td>
<td>
<p>A vector of column names or indices of columns in which
missing values will be created.</p>
</td></tr>
<tr><td><code id="delete_MAR_one_group_+3A_cols_ctrl">cols_ctrl</code></td>
<td>
<p>A vector of column names or indices of columns, which
controls the creation of missing values in <code>cols_mis</code>. Must be of the
same length as <code>cols_mis</code>.</p>
</td></tr>
<tr><td><code id="delete_MAR_one_group_+3A_cutoff_fun">cutoff_fun</code></td>
<td>
<p>Function that calculates the cutoff values in the
<code>cols_ctrl</code>.</p>
</td></tr>
<tr><td><code id="delete_MAR_one_group_+3A_prop">prop</code></td>
<td>
<p>Numeric of length one; (minimum) proportion of rows in group 1
(only used for unordered factors).</p>
</td></tr>
<tr><td><code id="delete_MAR_one_group_+3A_use_lpsolve">use_lpSolve</code></td>
<td>
<p>Logical; should lpSolve be used for the determination of
groups, if <code>cols_ctrl[i]</code> is an unordered factor.</p>
</td></tr>
<tr><td><code id="delete_MAR_one_group_+3A_ordered_as_unordered">ordered_as_unordered</code></td>
<td>
<p>Logical; should ordered factors be treated as
unordered factors.</p>
</td></tr>
<tr><td><code id="delete_MAR_one_group_+3A_n_mis_stochastic">n_mis_stochastic</code></td>
<td>
<p>Logical, should the number of missing values be
stochastic? If <code>n_mis_stochastic = TRUE</code>, the number of missing values
for a column with missing values <code>cols_mis[i]</code> is a random variable
with expected value <code>nrow(ds) * p[i]</code>. If <code>n_mis_stochastic =
FALSE</code>, the number of missing values will be deterministic. Normally, the
number of missing values for a column with missing values
<code>cols_mis[i]</code> is <code>round(nrow(ds) * p[i])</code>. Possible deviations
from this value, if any exists, are documented in Details.</p>
</td></tr>
<tr><td><code id="delete_MAR_one_group_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>cutoff_fun</code>.</p>
</td></tr>
<tr><td><code id="delete_MAR_one_group_+3A_miss_cols">miss_cols</code></td>
<td>
<p>Deprecated, use <code>cols_mis</code> instead.</p>
</td></tr>
<tr><td><code id="delete_MAR_one_group_+3A_ctrl_cols">ctrl_cols</code></td>
<td>
<p>Deprecated, use <code>cols_ctrl</code> instead.</p>
</td></tr>
<tr><td><code id="delete_MAR_one_group_+3A_stochastic">stochastic</code></td>
<td>
<p>Deprecated, use <code>n_mis_stochastic</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates missing at random (MAR) values in the columns
specified by the argument <code>cols_mis</code>.
The probability for missing values is controlled by <code>p</code>.
If <code>p</code> is a single number, then the overall probability for a value to
be missing will be <code>p</code> in all columns of <code>cols_mis</code>.
(Internally <code>p</code> will be replicated to a vector of the same length as
<code>cols_mis</code>.
So, all <code>p[i]</code> in the following sections will be equal to the given
single number <code>p</code>.)
Otherwise, <code>p</code> must be of the same length as <code>cols_mis</code>.
In this case, the overall probability for a value to be missing will be
<code>p[i]</code> in the column <code>cols_mis[i]</code>.
The position of the missing values in <code>cols_mis[i]</code> is controlled by
<code>cols_ctrl[i]</code>.
The following procedure is applied for each pair of <code>cols_ctrl[i]</code> and
<code>cols_mis[i]</code> to determine the positions of missing values:
</p>
<p>At first, the rows of <code>ds</code> are divided into two groups.
Therefore, the <code>cutoff_fun</code> calculates a cutoff value for
<code>cols_ctrl[i]</code> (via <code>cutoff_fun(ds[, cols_ctrl[i]], ...)</code>.
The group 1 consists of the rows, whose values in
<code>cols_ctrl[i]</code> are below the calculated cutoff value.
If the so defined group 1 is empty, the rows that are equal to the
cutoff value will be added to this group (otherwise, these rows will
belong to group 2).
The group 2 consists of the remaining rows, which are not part of group 1.
Now one of these two groups is chosen randomly.
In the chosen group, values are deleted in <code>cols_mis[i]</code>.
In the other group, no missing values will be created in <code>cols_mis[i]</code>.
</p>
<p>If <code>p</code> is too high, it is possible that a group contains not enough
objects to reach <code>nrow(ds) * p</code> missing values. In this case, <code>p</code>
is reduced to the maximum possible value (given the (random) group with
missing data) and a warning is given. Obviously this case will occur
regularly, if <code>p &gt; 0.5</code>. Therefore, this function should normally not be
called with <code>p &gt; 0.5</code>. However, this can occur for smaller values
of <code>p</code>, too (depending on the grouping). The warning can be silenced by
setting the option <code>missMethods.warn.too.high.p</code> to false.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>ds</code> with missing values.
</p>


<h3>Treatment of factors</h3>

<p>If <code>ds[, cols_ctrl[i]]</code> is an unordered factor, then the concept of a
cutoff value is not meaningful and cannot be applied.
Instead, a combinations of the levels of the unordered factor is searched that
</p>

<ul>
<li><p>guarantees at least a proportion of <code>prop</code> rows are in group 1
</p>
</li>
<li><p>minimize the difference between <code>prop</code> and the proportion of
rows in group 1.
</p>
</li></ul>

<p>This can be seen as a binary search problem, which is solved by the solver
from the package <code>lpSolve</code>, if <code>use_lpSolve = TRUE</code>.
If <code>use_lpSolve = FALSE</code>, a very simple heuristic is applied.
The heuristic only guarantees that at least a proportion of <code>prop</code> rows
are in group 1.
The choice <code>use_lpSolve = FALSE</code> is not recommend and should only be
considered, if the solver of lpSolve fails.
</p>
<p>If <code>ordered_as_unordered = TRUE</code>, then ordered factors will be treated
like unordered factors and the same binary search problem will be solved for
both types of factors.
If <code>ordered_as_unordered = FALSE</code> (the default), then ordered factors
will be grouped via <code>cutoff_fun</code> as described in Details.
</p>


<h3>References</h3>

<p>Santos, M. S., Pereira, R. C., Costa, A. F., Soares, J. P.,
Santos, J., &amp; Abreu, P. H. (2019). Generating Synthetic Missing Data: A
Review by Missing Mechanism. <em>IEEE Access</em>, 7, 11651-11667
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delete_MNAR_one_group">delete_MNAR_one_group</a></code>
</p>
<p>Other functions to create MAR: 
<code><a href="#topic+delete_MAR_1_to_x">delete_MAR_1_to_x</a>()</code>,
<code><a href="#topic+delete_MAR_censoring">delete_MAR_censoring</a>()</code>,
<code><a href="#topic+delete_MAR_rank">delete_MAR_rank</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ds &lt;- data.frame(X = 1:20, Y = 101:120)
delete_MAR_one_group(ds, 0.2, "X", "Y")
</code></pre>

<hr>
<h2 id='delete_MAR_rank'>Create MAR values using a ranking mechanism</h2><span id='topic+delete_MAR_rank'></span>

<h3>Description</h3>

<p>Create missing at random (MAR) values using a ranking mechanism in a data
frame or a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_MAR_rank(
  ds,
  p,
  cols_mis,
  cols_ctrl,
  n_mis_stochastic = FALSE,
  ties.method = "average",
  miss_cols,
  ctrl_cols
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_MAR_rank_+3A_ds">ds</code></td>
<td>
<p>A data frame or matrix in which missing values will be created.</p>
</td></tr>
<tr><td><code id="delete_MAR_rank_+3A_p">p</code></td>
<td>
<p>A numeric vector with length one or equal to length <code>cols_mis</code>;
the probability that a value is missing.</p>
</td></tr>
<tr><td><code id="delete_MAR_rank_+3A_cols_mis">cols_mis</code></td>
<td>
<p>A vector of column names or indices of columns in which
missing values will be created.</p>
</td></tr>
<tr><td><code id="delete_MAR_rank_+3A_cols_ctrl">cols_ctrl</code></td>
<td>
<p>A vector of column names or indices of columns, which
controls the creation of missing values in <code>cols_mis</code>. Must be of the
same length as <code>cols_mis</code>.</p>
</td></tr>
<tr><td><code id="delete_MAR_rank_+3A_n_mis_stochastic">n_mis_stochastic</code></td>
<td>
<p>Logical, should the number of missing values be
stochastic? If <code>n_mis_stochastic = TRUE</code>, the number of missing values
for a column with missing values <code>cols_mis[i]</code> is a random variable
with expected value <code>nrow(ds) * p[i]</code>. If <code>n_mis_stochastic =
FALSE</code>, the number of missing values will be deterministic. Normally, the
number of missing values for a column with missing values
<code>cols_mis[i]</code> is <code>round(nrow(ds) * p[i])</code>. Possible deviations
from this value, if any exists, are documented in Details.</p>
</td></tr>
<tr><td><code id="delete_MAR_rank_+3A_ties.method">ties.method</code></td>
<td>
<p>How ties are handled. Passed to <code><a href="base.html#topic+rank">rank</a></code>.</p>
</td></tr>
<tr><td><code id="delete_MAR_rank_+3A_miss_cols">miss_cols</code></td>
<td>
<p>Deprecated, use <code>cols_mis</code> instead.</p>
</td></tr>
<tr><td><code id="delete_MAR_rank_+3A_ctrl_cols">ctrl_cols</code></td>
<td>
<p>Deprecated, use <code>cols_ctrl</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates missing at random (MAR) values in the columns
specified by the argument <code>cols_mis</code>.
The probability for missing values is controlled by <code>p</code>.
If <code>p</code> is a single number, then the overall probability for a value to
be missing will be <code>p</code> in all columns of <code>cols_mis</code>.
(Internally <code>p</code> will be replicated to a vector of the same length as
<code>cols_mis</code>.
So, all <code>p[i]</code> in the following sections will be equal to the given
single number <code>p</code>.)
Otherwise, <code>p</code> must be of the same length as <code>cols_mis</code>.
In this case, the overall probability for a value to be missing will be
<code>p[i]</code> in the column <code>cols_mis[i]</code>.
The position of the missing values in <code>cols_mis[i]</code> is controlled by
<code>cols_ctrl[i]</code>.
The following procedure is applied for each pair of <code>cols_ctrl[i]</code> and
<code>cols_mis[i]</code> to determine the positions of missing values:
</p>
<p>At first, the probability for a value to be missing is calculated. This
probability for a missing value in a row of <code>cols_mis[i]</code> is
proportional to the rank of the value in <code>cols_ctrl[i]</code> in the same row.
If <code>n_mis_stochastic = FALSE</code> these probabilities are given to the
<code>prob</code> argument of <code><a href="base.html#topic+sample">sample</a></code>. If <code>n_mis_stochastic
= TRUE</code>, they are scaled to sum up to <code>nrow(ds) * p[i]</code>. Then for each
probability a uniformly distributed random number is generated. If this
random number is less than the probability, the value in <code>cols_mis[i]</code>
is set <code>NA</code>.
</p>
<p>The ranks are calculated via <code><a href="base.html#topic+rank">rank</a></code>.
The argument <code>ties.method</code> is directly passed to this function.
Possible choices for <code>ties.method</code> are documented in
<code><a href="base.html#topic+rank">rank</a></code>.
</p>
<p>For high values of <code>p</code> it is mathematically not possible to get
probabilities proportional to the ranks. In this case, a warning is given.
This warning can be silenced by setting the option
<code>missMethods.warn.too.high.p</code> to false.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>ds</code> with missing values.
</p>


<h3>References</h3>

<p>Santos, M. S., Pereira, R. C., Costa, A. F., Soares, J. P.,
Santos, J., &amp; Abreu, P. H. (2019). Generating Synthetic Missing Data: A
Review by Missing Mechanism. <em>IEEE Access</em>, 7, 11651-11667
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+rank">rank</a></code>, <code><a href="#topic+delete_MNAR_rank">delete_MNAR_rank</a></code>
</p>
<p>Other functions to create MAR: 
<code><a href="#topic+delete_MAR_1_to_x">delete_MAR_1_to_x</a>()</code>,
<code><a href="#topic+delete_MAR_censoring">delete_MAR_censoring</a>()</code>,
<code><a href="#topic+delete_MAR_one_group">delete_MAR_one_group</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ds &lt;- data.frame(X = 1:20, Y = 101:120)
delete_MAR_rank(ds, 0.2, "X", "Y")
</code></pre>

<hr>
<h2 id='delete_MCAR'>Create MCAR values</h2><span id='topic+delete_MCAR'></span>

<h3>Description</h3>

<p>Create missing completely at random (MCAR) values in a data frame or a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_MCAR(
  ds,
  p,
  cols_mis = seq_len(ncol(ds)),
  n_mis_stochastic = FALSE,
  p_overall = FALSE,
  miss_cols,
  stochastic
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_MCAR_+3A_ds">ds</code></td>
<td>
<p>A data frame or matrix in which missing values will be created.</p>
</td></tr>
<tr><td><code id="delete_MCAR_+3A_p">p</code></td>
<td>
<p>A numeric vector with length one or equal to length <code>cols_mis</code>;
the probability that a value is missing.</p>
</td></tr>
<tr><td><code id="delete_MCAR_+3A_cols_mis">cols_mis</code></td>
<td>
<p>A vector of column names or indices of columns in which
missing values will be created.</p>
</td></tr>
<tr><td><code id="delete_MCAR_+3A_n_mis_stochastic">n_mis_stochastic</code></td>
<td>
<p>Logical, should the number of missing values be
stochastic? If <code>n_mis_stochastic = TRUE</code>, the number of missing values
for a column with missing values <code>cols_mis[i]</code> is a random variable
with expected value <code>nrow(ds) * p[i]</code>. If <code>n_mis_stochastic =
FALSE</code>, the number of missing values will be deterministic. Normally, the
number of missing values for a column with missing values
<code>cols_mis[i]</code> is <code>round(nrow(ds) * p[i])</code>. Possible deviations
from this value, if any exists, are documented in Details.</p>
</td></tr>
<tr><td><code id="delete_MCAR_+3A_p_overall">p_overall</code></td>
<td>
<p>Logical; see details.</p>
</td></tr>
<tr><td><code id="delete_MCAR_+3A_miss_cols">miss_cols</code></td>
<td>
<p>Deprecated, use <code>cols_mis</code> instead.</p>
</td></tr>
<tr><td><code id="delete_MCAR_+3A_stochastic">stochastic</code></td>
<td>
<p>Deprecated, use <code>n_mis_stochastic</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates missing completely at random (MCAR) values in
the dataset <code>ds</code>.
The proportion of missing values is specified with <code>p</code>.
The columns in which missing values are created can be set via <code>cols_mis</code>.
If <code>cols_mis</code> is not specified, then missing values are created in
all columns of <code>ds</code>.
</p>
<p>The probability for missing values is controlled by <code>p</code>. If <code>p</code> is
a single number, then the overall probability for a value to be missing will
be <code>p</code> in all columns of <code>cols_mis</code>. (Internally <code>p</code> will be
replicated to a vector of the same length as <code>cols_mis</code>. So, all
<code>p[i]</code> in the following sections will be equal to the given single
number <code>p</code>.) Otherwise, <code>p</code> must be of the same length as
<code>cols_mis</code>. In this case, the overall probability for a value to be
missing will be <code>p[i]</code> in the column <code>cols_mis[i]</code>.
</p>
<p>If <code>n_mis_stochastic = FALSE</code> and <code>p_overall = FALSE</code> (the default), then
exactly <code>round(nrow(ds) * p[i])</code> values will be set <code>NA</code> in column
<code>cols_mis[i]</code>. If <code>n_mis_stochastic = FALSE</code> and <code>p_overall =
TRUE</code>, then <code>p</code> must be of length one and exactly <code>round(nrow(ds) *
p * length(cols_mis))</code> values will be set NA (over all columns in
<code>cols_mis</code>). This can result in a proportion of missing values in every
<code>miss_col</code> unequal to <code>p</code>, but the proportion of missing values in
all columns together will be close to <code>p</code>.
</p>
<p>If <code>n_mis_stochastic = TRUE</code>, then each value in column
<code>cols_mis[i]</code> has probability <code>p[i]</code> to be missing (independently
of all other values). Therefore, the number of missing values in
<code>cols_mis[i]</code> is a random variable with a binomial distribution
<em>B</em>(<code>nrow(ds)</code>, <code>p[i]</code>). This can (and will most of the time)
lead to more or less missing values than <code>round(nrow(ds) * p[i])</code> in
column <code>cols_mis[i]</code>. If <code>n_mis_stochastic = TRUE</code>, then the
argument <code>p_overall</code> is ignored because it is superfluous.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>ds</code> with missing values.
</p>


<h3>References</h3>

<p>Santos, M. S., Pereira, R. C., Costa, A. F., Soares, J. P.,
Santos, J., &amp; Abreu, P. H. (2019). Generating Synthetic Missing Data: A
Review by Missing Mechanism. <em>IEEE Access</em>, 7, 11651-11667
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ds &lt;- data.frame(X = 1:20, Y = 101:120)
delete_MCAR(ds, 0.2)
</code></pre>

<hr>
<h2 id='delete_MNAR_1_to_x'>Create MNAR values using MNAR1:x</h2><span id='topic+delete_MNAR_1_to_x'></span>

<h3>Description</h3>

<p>Create missing not at random (MNAR) values using MNAR1:x in a data frame or
a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_MNAR_1_to_x(
  ds,
  p,
  cols_mis,
  x,
  cutoff_fun = median,
  prop = 0.5,
  use_lpSolve = TRUE,
  ordered_as_unordered = FALSE,
  n_mis_stochastic = FALSE,
  x_stochastic = FALSE,
  add_realized_x = FALSE,
  ...,
  miss_cols,
  stochastic
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_MNAR_1_to_x_+3A_ds">ds</code></td>
<td>
<p>A data frame or matrix in which missing values will be created.</p>
</td></tr>
<tr><td><code id="delete_MNAR_1_to_x_+3A_p">p</code></td>
<td>
<p>A numeric vector with length one or equal to length <code>cols_mis</code>;
the probability that a value is missing.</p>
</td></tr>
<tr><td><code id="delete_MNAR_1_to_x_+3A_cols_mis">cols_mis</code></td>
<td>
<p>A vector of column names or indices of columns in which
missing values will be created.</p>
</td></tr>
<tr><td><code id="delete_MNAR_1_to_x_+3A_x">x</code></td>
<td>
<p>Numeric with length one (0 &lt; x &lt; <code>Inf</code>); odds are 1 to x for
the probability of a value to be missing in group 1 against the probability
of a value to be missing  in group 2 (see details).</p>
</td></tr>
<tr><td><code id="delete_MNAR_1_to_x_+3A_cutoff_fun">cutoff_fun</code></td>
<td>
<p>Function that calculates the cutoff values in the
<code>cols_ctrl</code>.</p>
</td></tr>
<tr><td><code id="delete_MNAR_1_to_x_+3A_prop">prop</code></td>
<td>
<p>Numeric of length one; (minimum) proportion of rows in group 1
(only used for unordered factors).</p>
</td></tr>
<tr><td><code id="delete_MNAR_1_to_x_+3A_use_lpsolve">use_lpSolve</code></td>
<td>
<p>Logical; should lpSolve be used for the determination of
groups, if <code>cols_ctrl[i]</code> is an unordered factor.</p>
</td></tr>
<tr><td><code id="delete_MNAR_1_to_x_+3A_ordered_as_unordered">ordered_as_unordered</code></td>
<td>
<p>Logical; should ordered factors be treated as
unordered factors.</p>
</td></tr>
<tr><td><code id="delete_MNAR_1_to_x_+3A_n_mis_stochastic">n_mis_stochastic</code></td>
<td>
<p>Logical, should the number of missing values be
stochastic? If <code>n_mis_stochastic = TRUE</code>, the number of missing values
for a column with missing values <code>cols_mis[i]</code> is a random variable
with expected value <code>nrow(ds) * p[i]</code>. If <code>n_mis_stochastic =
FALSE</code>, the number of missing values will be deterministic. Normally, the
number of missing values for a column with missing values
<code>cols_mis[i]</code> is <code>round(nrow(ds) * p[i])</code>. Possible deviations
from this value, if any exists, are documented in Details.</p>
</td></tr>
<tr><td><code id="delete_MNAR_1_to_x_+3A_x_stochastic">x_stochastic</code></td>
<td>
<p>Logical; should the odds be stochastic or deterministic.</p>
</td></tr>
<tr><td><code id="delete_MNAR_1_to_x_+3A_add_realized_x">add_realized_x</code></td>
<td>
<p>Logical; if TRUE the realized odds for cols_mis will
be returned (as attribute).</p>
</td></tr>
<tr><td><code id="delete_MNAR_1_to_x_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>cutoff_fun</code>.</p>
</td></tr>
<tr><td><code id="delete_MNAR_1_to_x_+3A_miss_cols">miss_cols</code></td>
<td>
<p>Deprecated, use <code>cols_mis</code> instead.</p>
</td></tr>
<tr><td><code id="delete_MNAR_1_to_x_+3A_stochastic">stochastic</code></td>
<td>
<p>Deprecated, use <code>n_mis_stochastic</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>delete_MNAR_1_to_x</code> and <code><a href="#topic+delete_MAR_1_to_x">delete_MAR_1_to_x</a></code> are sisters. The only difference between these two functions is the column that controls the generation of missing values. In <code><a href="#topic+delete_MAR_1_to_x">delete_MAR_1_to_x</a></code> a separate column <code>cols_ctrl[i]</code> controls the generation of missing values in <code>cols_mis[i]</code>. In contrast, in <code>delete_MNAR_1_to_x</code> the generation of missing values in <code>cols_mis[i]</code> is controlled by <code>cols_mis[i]</code> itself. All other aspects are identical for both functions. Therefore, further details can be found in <code><a href="#topic+delete_MAR_1_to_x">delete_MAR_1_to_x</a></code>.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>ds</code> with missing values.
</p>


<h3>References</h3>

<p>Santos, M. S., Pereira, R. C., Costa, A. F., Soares, J. P.,
Santos, J., &amp; Abreu, P. H. (2019). Generating Synthetic Missing Data: A
Review by Missing Mechanism. <em>IEEE Access</em>, 7, 11651-11667
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delete_MAR_1_to_x">delete_MAR_1_to_x</a></code>
</p>
<p>Other functions to create MNAR: 
<code><a href="#topic+delete_MNAR_censoring">delete_MNAR_censoring</a>()</code>,
<code><a href="#topic+delete_MNAR_one_group">delete_MNAR_one_group</a>()</code>,
<code><a href="#topic+delete_MNAR_rank">delete_MNAR_rank</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ds &lt;- data.frame(X = 1:20, Y = 101:120)
delete_MNAR_1_to_x(ds, 0.2, "X", x = 3)
</code></pre>

<hr>
<h2 id='delete_MNAR_censoring'>Create MNAR values using a censoring mechanism</h2><span id='topic+delete_MNAR_censoring'></span>

<h3>Description</h3>

<p>Create missing not at random (MNAR) values using a censoring mechanism in a
data frame or a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_MNAR_censoring(
  ds,
  p,
  cols_mis,
  n_mis_stochastic = FALSE,
  where = "lower",
  sorting = TRUE,
  miss_cols
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_MNAR_censoring_+3A_ds">ds</code></td>
<td>
<p>A data frame or matrix in which missing values will be created.</p>
</td></tr>
<tr><td><code id="delete_MNAR_censoring_+3A_p">p</code></td>
<td>
<p>A numeric vector with length one or equal to length <code>cols_mis</code>;
the probability that a value is missing.</p>
</td></tr>
<tr><td><code id="delete_MNAR_censoring_+3A_cols_mis">cols_mis</code></td>
<td>
<p>A vector of column names or indices of columns in which
missing values will be created.</p>
</td></tr>
<tr><td><code id="delete_MNAR_censoring_+3A_n_mis_stochastic">n_mis_stochastic</code></td>
<td>
<p>Logical, should the number of missing values be
stochastic? If <code>n_mis_stochastic = TRUE</code>, the number of missing values
for a column with missing values <code>cols_mis[i]</code> is a random variable
with expected value <code>nrow(ds) * p[i]</code>. If <code>n_mis_stochastic =
FALSE</code>, the number of missing values will be deterministic. Normally, the
number of missing values for a column with missing values
<code>cols_mis[i]</code> is <code>round(nrow(ds) * p[i])</code>. Possible deviations
from this value, if any exists, are documented in Details.</p>
</td></tr>
<tr><td><code id="delete_MNAR_censoring_+3A_where">where</code></td>
<td>
<p>Controls where missing values are created; one of &quot;lower&quot;,
&quot;upper&quot; or &quot;both&quot; (see details).</p>
</td></tr>
<tr><td><code id="delete_MNAR_censoring_+3A_sorting">sorting</code></td>
<td>
<p>Logical; should sorting be used or a quantile as a threshold.</p>
</td></tr>
<tr><td><code id="delete_MNAR_censoring_+3A_miss_cols">miss_cols</code></td>
<td>
<p>Deprecated, use <code>cols_mis</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>delete_MNAR_censoring</code> and <code><a href="#topic+delete_MAR_censoring">delete_MAR_censoring</a></code> are sisters. The only difference between these two functions is the column that controls the generation of missing values. In <code><a href="#topic+delete_MAR_censoring">delete_MAR_censoring</a></code> a separate column <code>cols_ctrl[i]</code> controls the generation of missing values in <code>cols_mis[i]</code>. In contrast, in <code>delete_MNAR_censoring</code> the generation of missing values in <code>cols_mis[i]</code> is controlled by <code>cols_mis[i]</code> itself. All other aspects are identical for both functions. Therefore, further details can be found in <code><a href="#topic+delete_MAR_censoring">delete_MAR_censoring</a></code>.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>ds</code> with missing values.
</p>


<h3>References</h3>

<p>Santos, M. S., Pereira, R. C., Costa, A. F., Soares, J. P.,
Santos, J., &amp; Abreu, P. H. (2019). Generating Synthetic Missing Data: A
Review by Missing Mechanism. <em>IEEE Access</em>, 7, 11651-11667
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delete_MAR_censoring">delete_MAR_censoring</a></code>
</p>
<p>Other functions to create MNAR: 
<code><a href="#topic+delete_MNAR_1_to_x">delete_MNAR_1_to_x</a>()</code>,
<code><a href="#topic+delete_MNAR_one_group">delete_MNAR_one_group</a>()</code>,
<code><a href="#topic+delete_MNAR_rank">delete_MNAR_rank</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ds &lt;- data.frame(X = 1:20, Y = 101:120)
delete_MNAR_censoring(ds, 0.2, "X")
</code></pre>

<hr>
<h2 id='delete_MNAR_one_group'>Create MNAR values by deleting values in one of two groups</h2><span id='topic+delete_MNAR_one_group'></span>

<h3>Description</h3>

<p>Create missing not at random (MNAR) values by deleting values in one of two
groups in a data frame or a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_MNAR_one_group(
  ds,
  p,
  cols_mis,
  cutoff_fun = median,
  prop = 0.5,
  use_lpSolve = TRUE,
  ordered_as_unordered = FALSE,
  n_mis_stochastic = FALSE,
  ...,
  miss_cols,
  stochastic
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_MNAR_one_group_+3A_ds">ds</code></td>
<td>
<p>A data frame or matrix in which missing values will be created.</p>
</td></tr>
<tr><td><code id="delete_MNAR_one_group_+3A_p">p</code></td>
<td>
<p>A numeric vector with length one or equal to length <code>cols_mis</code>;
the probability that a value is missing.</p>
</td></tr>
<tr><td><code id="delete_MNAR_one_group_+3A_cols_mis">cols_mis</code></td>
<td>
<p>A vector of column names or indices of columns in which
missing values will be created.</p>
</td></tr>
<tr><td><code id="delete_MNAR_one_group_+3A_cutoff_fun">cutoff_fun</code></td>
<td>
<p>Function that calculates the cutoff values in the
<code>cols_ctrl</code>.</p>
</td></tr>
<tr><td><code id="delete_MNAR_one_group_+3A_prop">prop</code></td>
<td>
<p>Numeric of length one; (minimum) proportion of rows in group 1
(only used for unordered factors).</p>
</td></tr>
<tr><td><code id="delete_MNAR_one_group_+3A_use_lpsolve">use_lpSolve</code></td>
<td>
<p>Logical; should lpSolve be used for the determination of
groups, if <code>cols_ctrl[i]</code> is an unordered factor.</p>
</td></tr>
<tr><td><code id="delete_MNAR_one_group_+3A_ordered_as_unordered">ordered_as_unordered</code></td>
<td>
<p>Logical; should ordered factors be treated as
unordered factors.</p>
</td></tr>
<tr><td><code id="delete_MNAR_one_group_+3A_n_mis_stochastic">n_mis_stochastic</code></td>
<td>
<p>Logical, should the number of missing values be
stochastic? If <code>n_mis_stochastic = TRUE</code>, the number of missing values
for a column with missing values <code>cols_mis[i]</code> is a random variable
with expected value <code>nrow(ds) * p[i]</code>. If <code>n_mis_stochastic =
FALSE</code>, the number of missing values will be deterministic. Normally, the
number of missing values for a column with missing values
<code>cols_mis[i]</code> is <code>round(nrow(ds) * p[i])</code>. Possible deviations
from this value, if any exists, are documented in Details.</p>
</td></tr>
<tr><td><code id="delete_MNAR_one_group_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>cutoff_fun</code>.</p>
</td></tr>
<tr><td><code id="delete_MNAR_one_group_+3A_miss_cols">miss_cols</code></td>
<td>
<p>Deprecated, use <code>cols_mis</code> instead.</p>
</td></tr>
<tr><td><code id="delete_MNAR_one_group_+3A_stochastic">stochastic</code></td>
<td>
<p>Deprecated, use <code>n_mis_stochastic</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>delete_MNAR_one_group</code> and <code><a href="#topic+delete_MAR_one_group">delete_MAR_one_group</a></code> are sisters. The only difference between these two functions is the column that controls the generation of missing values. In <code><a href="#topic+delete_MAR_one_group">delete_MAR_one_group</a></code> a separate column <code>cols_ctrl[i]</code> controls the generation of missing values in <code>cols_mis[i]</code>. In contrast, in <code>delete_MNAR_one_group</code> the generation of missing values in <code>cols_mis[i]</code> is controlled by <code>cols_mis[i]</code> itself. All other aspects are identical for both functions. Therefore, further details can be found in <code><a href="#topic+delete_MAR_one_group">delete_MAR_one_group</a></code>.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>ds</code> with missing values.
</p>


<h3>References</h3>

<p>Santos, M. S., Pereira, R. C., Costa, A. F., Soares, J. P.,
Santos, J., &amp; Abreu, P. H. (2019). Generating Synthetic Missing Data: A
Review by Missing Mechanism. <em>IEEE Access</em>, 7, 11651-11667
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delete_MAR_one_group">delete_MAR_one_group</a></code>
</p>
<p>Other functions to create MNAR: 
<code><a href="#topic+delete_MNAR_1_to_x">delete_MNAR_1_to_x</a>()</code>,
<code><a href="#topic+delete_MNAR_censoring">delete_MNAR_censoring</a>()</code>,
<code><a href="#topic+delete_MNAR_rank">delete_MNAR_rank</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ds &lt;- data.frame(X = 1:20, Y = 101:120)
delete_MNAR_one_group(ds, 0.2, "X")
</code></pre>

<hr>
<h2 id='delete_MNAR_rank'>Create MNAR values using a ranking mechanism</h2><span id='topic+delete_MNAR_rank'></span>

<h3>Description</h3>

<p>Create missing not at random (MNAR) values using a ranking mechanism in a
data frame or a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_MNAR_rank(
  ds,
  p,
  cols_mis,
  n_mis_stochastic = FALSE,
  ties.method = "average",
  miss_cols
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_MNAR_rank_+3A_ds">ds</code></td>
<td>
<p>A data frame or matrix in which missing values will be created.</p>
</td></tr>
<tr><td><code id="delete_MNAR_rank_+3A_p">p</code></td>
<td>
<p>A numeric vector with length one or equal to length <code>cols_mis</code>;
the probability that a value is missing.</p>
</td></tr>
<tr><td><code id="delete_MNAR_rank_+3A_cols_mis">cols_mis</code></td>
<td>
<p>A vector of column names or indices of columns in which
missing values will be created.</p>
</td></tr>
<tr><td><code id="delete_MNAR_rank_+3A_n_mis_stochastic">n_mis_stochastic</code></td>
<td>
<p>Logical, should the number of missing values be
stochastic? If <code>n_mis_stochastic = TRUE</code>, the number of missing values
for a column with missing values <code>cols_mis[i]</code> is a random variable
with expected value <code>nrow(ds) * p[i]</code>. If <code>n_mis_stochastic =
FALSE</code>, the number of missing values will be deterministic. Normally, the
number of missing values for a column with missing values
<code>cols_mis[i]</code> is <code>round(nrow(ds) * p[i])</code>. Possible deviations
from this value, if any exists, are documented in Details.</p>
</td></tr>
<tr><td><code id="delete_MNAR_rank_+3A_ties.method">ties.method</code></td>
<td>
<p>How ties are handled. Passed to <code><a href="base.html#topic+rank">rank</a></code>.</p>
</td></tr>
<tr><td><code id="delete_MNAR_rank_+3A_miss_cols">miss_cols</code></td>
<td>
<p>Deprecated, use <code>cols_mis</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>delete_MNAR_rank</code> and <code><a href="#topic+delete_MAR_rank">delete_MAR_rank</a></code> are sisters. The only difference between these two functions is the column that controls the generation of missing values. In <code><a href="#topic+delete_MAR_rank">delete_MAR_rank</a></code> a separate column <code>cols_ctrl[i]</code> controls the generation of missing values in <code>cols_mis[i]</code>. In contrast, in <code>delete_MNAR_rank</code> the generation of missing values in <code>cols_mis[i]</code> is controlled by <code>cols_mis[i]</code> itself. All other aspects are identical for both functions. Therefore, further details can be found in <code><a href="#topic+delete_MAR_rank">delete_MAR_rank</a></code>.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>ds</code> with missing values.
</p>


<h3>References</h3>

<p>Santos, M. S., Pereira, R. C., Costa, A. F., Soares, J. P.,
Santos, J., &amp; Abreu, P. H. (2019). Generating Synthetic Missing Data: A
Review by Missing Mechanism. <em>IEEE Access</em>, 7, 11651-11667
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delete_MAR_rank">delete_MAR_rank</a></code>
</p>
<p>Other functions to create MNAR: 
<code><a href="#topic+delete_MNAR_1_to_x">delete_MNAR_1_to_x</a>()</code>,
<code><a href="#topic+delete_MNAR_censoring">delete_MNAR_censoring</a>()</code>,
<code><a href="#topic+delete_MNAR_one_group">delete_MNAR_one_group</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ds &lt;- data.frame(X = 1:20, Y = 101:120)
delete_MNAR_rank(ds, 0.2, "X")
</code></pre>

<hr>
<h2 id='evaluate_imputation_parameters'>Evaluate estimated parameters after imputation</h2><span id='topic+evaluate_imputation_parameters'></span>

<h3>Description</h3>

<p>Compares estimated parameters after imputation to true parameters or
estimates based on the original dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_imputation_parameters(
  ds_imp,
  ds_orig = NULL,
  pars_true = NULL,
  parameter = "mean",
  criterion = "RMSE",
  cols_which = seq_len(ncol(ds_imp)),
  tolerance = sqrt(.Machine$double.eps),
  ...,
  imp_ds,
  true_pars,
  which_cols
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_imputation_parameters_+3A_ds_imp">ds_imp</code></td>
<td>
<p>A data frame or matrix with imputed values.</p>
</td></tr>
<tr><td><code id="evaluate_imputation_parameters_+3A_ds_orig">ds_orig</code></td>
<td>
<p>A data frame or matrix with original (true) values.</p>
</td></tr>
<tr><td><code id="evaluate_imputation_parameters_+3A_pars_true">pars_true</code></td>
<td>
<p>True parameters, normally a vector or a matrix.</p>
</td></tr>
<tr><td><code id="evaluate_imputation_parameters_+3A_parameter">parameter</code></td>
<td>
<p>A string specifying the estimated parameters for comparison.</p>
</td></tr>
<tr><td><code id="evaluate_imputation_parameters_+3A_criterion">criterion</code></td>
<td>
<p>A string specifying the used criterion for comparing the
imputed and original values.</p>
</td></tr>
<tr><td><code id="evaluate_imputation_parameters_+3A_cols_which">cols_which</code></td>
<td>
<p>Indices or names of columns used for evaluation.</p>
</td></tr>
<tr><td><code id="evaluate_imputation_parameters_+3A_tolerance">tolerance</code></td>
<td>
<p>Numeric, only used for <code>criterion = "precision"</code>:
numeric differences smaller than tolerance are treated as zero/equal.</p>
</td></tr>
<tr><td><code id="evaluate_imputation_parameters_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the function for parameter estimation.</p>
</td></tr>
<tr><td><code id="evaluate_imputation_parameters_+3A_imp_ds">imp_ds</code></td>
<td>
<p>Deprecated, renamed to <code>ds_imp</code>.</p>
</td></tr>
<tr><td><code id="evaluate_imputation_parameters_+3A_true_pars">true_pars</code></td>
<td>
<p>Deprecated, renamed to <code>pars_true</code>.</p>
</td></tr>
<tr><td><code id="evaluate_imputation_parameters_+3A_which_cols">which_cols</code></td>
<td>
<p>Deprecated, renamed to <code>cols_which</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either <code>ds_orig</code> or <code>pars_true</code> must be supplied and the
other one must be <code>NULL</code> (default: both are <code>NULL</code>, just supply
one, see examples). The following <code>parameter</code>s are implemented:
&quot;mean&quot;, &quot;median&quot;, &quot;var&quot;, &quot;sd&quot;, &quot;quantile&quot;, &quot;cov&quot;, &quot;cov_only&quot;, cor&quot;, &quot;cor_only&quot;.
Some details follow:
</p>

<ul>
<li><p>&quot;var&quot;, &quot;cov&quot; and &quot;cov_only&quot;: For &quot;var&quot; only the variances of the
columns (the diagonal elements of the covariance matrix) are compared. For
&quot;cov&quot; the whole covariance matrix is compared. For &quot;cov_only&quot; only the upper
triangle (excluding the diagonal) of the covariance matrix is compared.
</p>
</li>
<li><p>&quot;cor&quot;, &quot;cor_only&quot;: For &quot;cor&quot; the whole correlation matrix is compared.
For &quot;cor_only&quot; only the upper triangle (excluding the diagonal) of the
correlation matrix is compared.
</p>
</li>
<li><p>&quot;quantile&quot;: the quantiles can be set via the additional
argument <code>probs</code> (see examples). Otherwise, the default quantiles from
<code><a href="stats.html#topic+quantile">quantile</a></code> will be used.
</p>
</li></ul>

<p>The argument <code>cols_which</code> allows the selection of columns for comparison
(see examples). If <code>pars_true</code> is used, it is assumed that only relevant
parameters are supplied (see examples).
</p>
<p>Possible choices for the argument <code>criterion</code> are documented in
<code><a href="#topic+evaluate_imputed_values">evaluate_imputed_values</a></code>
</p>


<h3>Value</h3>

<p>A numeric vector of length one.
</p>


<h3>References</h3>

<p>Cetin-Berber, D. D., Sari, H. I., &amp; Huggins-Manley, A. C. (2019).
Imputation Methods to Deal With Missing Responses in Computerized Adaptive
Multistage Testing. <em>Educational and psychological measurement</em>,
79(3), 495-511.
</p>


<h3>See Also</h3>

<p>Other evaluation functions: 
<code><a href="#topic+evaluate_imputed_values">evaluate_imputed_values</a>()</code>,
<code><a href="#topic+evaluate_parameters">evaluate_parameters</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># only ds_orig known
ds_orig &lt;- data.frame(X = 1:10, Y = 101:101)
ds_imp &lt;- impute_mean(delete_MCAR(ds_orig, 0.4))
evaluate_imputation_parameters(ds_imp, ds_orig = ds_orig)

# true parameters known
ds_orig &lt;- data.frame(X = rnorm(100), Y = rnorm(100, mean = 10))
ds_imp &lt;- impute_mean(delete_MCAR(ds_orig, 0.3))
evaluate_imputation_parameters(ds_imp, pars_true = c(0, 10), parameter = "mean")
evaluate_imputation_parameters(ds_imp, pars_true = c(1, 1), parameter = "var")

# set quantiles
evaluate_imputation_parameters(ds_imp,
  pars_true = c(qnorm(0.3), qnorm(0.3, mean = 10)),
  parameter = "quantile", probs = 0.3
)

# compare only column Y
evaluate_imputation_parameters(ds_imp,
  pars_true = c(Y = 10), parameter = "mean",
  cols_which = "Y"
)
</code></pre>

<hr>
<h2 id='evaluate_imputed_values'>Evaluate imputed values</h2><span id='topic+evaluate_imputed_values'></span>

<h3>Description</h3>

<p>Compare imputed to true values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_imputed_values(
  ds_imp,
  ds_orig,
  criterion = "RMSE",
  M = NULL,
  cols_which = seq_len(ncol(ds_imp)),
  tolerance = sqrt(.Machine$double.eps),
  imp_ds,
  orig_ds,
  which_cols
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_imputed_values_+3A_ds_imp">ds_imp</code></td>
<td>
<p>A data frame or matrix with imputed values.</p>
</td></tr>
<tr><td><code id="evaluate_imputed_values_+3A_ds_orig">ds_orig</code></td>
<td>
<p>A data frame or matrix with original (true) values.</p>
</td></tr>
<tr><td><code id="evaluate_imputed_values_+3A_criterion">criterion</code></td>
<td>
<p>A string specifying the used criterion for comparing the
imputed and original values.</p>
</td></tr>
<tr><td><code id="evaluate_imputed_values_+3A_m">M</code></td>
<td>
<p>NULL (the default) or a missing data indicator matrix. The missing
data indicator matrix is normally created via <code>is.na(ds_mis)</code>, where
<code>ds_mis</code> is the dataset after deleting values from <code>ds_orig</code>.</p>
</td></tr>
<tr><td><code id="evaluate_imputed_values_+3A_cols_which">cols_which</code></td>
<td>
<p>Indices or names of columns used for evaluation.</p>
</td></tr>
<tr><td><code id="evaluate_imputed_values_+3A_tolerance">tolerance</code></td>
<td>
<p>Numeric, only used for <code>criterion = "precision"</code>:
numeric differences smaller than tolerance are treated as zero/equal.</p>
</td></tr>
<tr><td><code id="evaluate_imputed_values_+3A_imp_ds">imp_ds</code></td>
<td>
<p>Deprecated, renamed to <code>ds_imp</code>.</p>
</td></tr>
<tr><td><code id="evaluate_imputed_values_+3A_orig_ds">orig_ds</code></td>
<td>
<p>Deprecated, renamed to <code>ds_orig</code>.</p>
</td></tr>
<tr><td><code id="evaluate_imputed_values_+3A_which_cols">which_cols</code></td>
<td>
<p>Deprecated, renamed to <code>cols_which</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following <code>criterion</code>s are implemented to compare the
imputed values to the true values:
</p>

<ul>
<li><p>&quot;RMSE&quot; (the default): The Root Mean Squared Error between the imputed
and true values
</p>
</li>
<li><p>&quot;bias&quot;: The mean difference between the imputed and the true values
</p>
</li>
<li><p>&quot;cor&quot;: The correlation between the imputed and true values
</p>
</li>
<li><p>&quot;MAE&quot;: The Mean Absolute Error between the imputed and true values
</p>
</li>
<li><p>&quot;MSE&quot;: The Mean Squared Error between the imputed and true values
</p>
</li>
<li><p>&quot;NRMSE_col_mean&quot;: For every column the RMSE divided by the mean of the
true values is calculated. Then these columnwise values are squared and
averaged. Finally, the square root of this average is returned.
</p>
</li>
<li><p>&quot;NRMSE_col_mean_sq&quot;: For every column the RMSE divided by the square
root of the mean of the squared true values is calculated. Then these
columnwise values are squared and averaged. Finally, the square root of this
average is returned.
</p>
</li>
<li><p>&quot;NRMSE_col_sd&quot;: For every column the RMSE divided by the standard
deviation of all true values is calculated. Then these columnwise values are
squared and averaged. Finally, the square root of this average is returned.
</p>
</li>
<li><p>&quot;NRMSE_tot_mean&quot;: RMSE divided by the mean of all true values
</p>
</li>
<li><p>&quot;NRMSE_tot_mean_sq&quot;: RMSE divided by the square root of the mean of
all squared true values
</p>
</li>
<li><p>&quot;NRMSE_tot_sd&quot;: RMSE divided by the standard deviation of all true values
</p>
</li>
<li><p>&quot;nr_equal&quot;: number of imputed values that are equal to the true values
</p>
</li>
<li><p>&quot;nr_NA&quot;: number of values in <code>ds_imp</code> that are NA (not imputed)
</p>
</li>
<li><p>&quot;precision&quot;: proportion of imputed values that are equal to the true values
</p>
</li></ul>

<p>Additionally there are relative versions of bias and MAE implemented. In the
relative versions, the differences are divided by the absolute values of the
true values. These relative versions can be selected via &quot;bias_rel&quot; and
&quot;MAE_rel&quot;. The &quot;NRMSE_tot_&quot; and &quot;NRMSE_col_&quot; are equal, if the columnwise
normalization values are equal to the total normalization value (see
examples).
</p>
<p>The argument <code>cols_which</code> allows the selection of columns
for comparison (see examples).
</p>
<p>If <code>M = NULL</code> (the default), then all values of <code>ds_imp</code> and
<code>ds_orig</code> will be used for the calculation of the evaluation criterion.
If a missing data indicator matrix is given via <code>M</code>, only the truly
imputed values (values that are marked as missing via <code>M</code>) will be used
for the calculation. If you want to provide <code>M</code>, <code>M</code> must be a
logical matrix of the same dimensions as <code>ds_orig</code> and missing values
must be coded as TRUE. This is the standard behavior, if you use
<code><a href="Matrix.html#topic+is.na">is.na</a></code> on a dataset with missing values to generate
<code>M</code> (see examples). It is possible to combine <code>M</code> and
<code>cols_which</code>.
</p>


<h3>Value</h3>

<p>A numeric vector of length one.
</p>


<h3>References</h3>

<p>Kim, H., Golub, G. H., &amp; Park, H. (2005). Missing value
estimation for DNA microarray gene expression data: local least squares
imputation. <em>Bioinformatics</em>, 21(2), 187-198.
</p>


<h3>See Also</h3>

<p>Other evaluation functions: 
<code><a href="#topic+evaluate_imputation_parameters">evaluate_imputation_parameters</a>()</code>,
<code><a href="#topic+evaluate_parameters">evaluate_parameters</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ds_orig &lt;- data.frame(X = 1:10, Y = 101:110)
ds_mis &lt;- delete_MCAR(ds_orig, 0.3)
ds_imp &lt;- impute_mean(ds_mis)
# compare all values from ds_orig and ds_imp
evaluate_imputed_values(ds_imp, ds_orig)
# compare only the imputed values
M &lt;- is.na(ds_mis)
evaluate_imputed_values(ds_imp, ds_orig, M = M)
# compare only the imputed values in column X
evaluate_imputed_values(ds_imp, ds_orig, M = M, cols_which = "X")

# NRMSE_tot_mean and NRMSE_col_mean are equal, if columnwise means are equal
ds_orig &lt;- data.frame(X = 1:10, Y = 10:1)
ds_mis &lt;- delete_MCAR(ds_orig, 0.3)
ds_imp &lt;- impute_mean(ds_mis)
evaluate_imputed_values(ds_imp, ds_orig, "NRMSE_tot_mean")
evaluate_imputed_values(ds_imp, ds_orig, "NRMSE_col_mean")
</code></pre>

<hr>
<h2 id='evaluate_parameters'>Evaluate estimated parameters</h2><span id='topic+evaluate_parameters'></span>

<h3>Description</h3>

<p>Compare estimated parameters to true parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_parameters(
  pars_est,
  pars_true,
  criterion = "RMSE",
  tolerance = sqrt(.Machine$double.eps),
  est_pars,
  true_pars
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_parameters_+3A_pars_est">pars_est</code></td>
<td>
<p>A vector or matrix of estimated parameters.</p>
</td></tr>
<tr><td><code id="evaluate_parameters_+3A_pars_true">pars_true</code></td>
<td>
<p>True parameters, normally a vector or a matrix.</p>
</td></tr>
<tr><td><code id="evaluate_parameters_+3A_criterion">criterion</code></td>
<td>
<p>A string specifying the used criterion for comparing the
imputed and original values.</p>
</td></tr>
<tr><td><code id="evaluate_parameters_+3A_tolerance">tolerance</code></td>
<td>
<p>Numeric, only used for <code>criterion = "precision"</code>:
numeric differences smaller than tolerance are treated as zero/equal.</p>
</td></tr>
<tr><td><code id="evaluate_parameters_+3A_est_pars">est_pars</code></td>
<td>
<p>Deprecated, renamed to <code>pars_est</code>.</p>
</td></tr>
<tr><td><code id="evaluate_parameters_+3A_true_pars">true_pars</code></td>
<td>
<p>Deprecated, renamed to <code>pars_true</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The same <code>criterion</code>s are implemented for
<code>evaluate_parameters</code> and <code><a href="#topic+evaluate_imputed_values">evaluate_imputed_values</a></code>.
The possible choices are documented in <code><a href="#topic+evaluate_imputed_values">evaluate_imputed_values</a></code>.
</p>


<h3>Value</h3>

<p>A numeric vector of length one.
</p>


<h3>References</h3>

<p>Cetin-Berber, D. D., Sari, H. I., &amp; Huggins-Manley, A. C. (2019).
Imputation Methods to Deal With Missing Responses in Computerized Adaptive
Multistage Testing. <em>Educational and psychological measurement</em>,
79(3), 495-511.
</p>


<h3>See Also</h3>

<p>Other evaluation functions: 
<code><a href="#topic+evaluate_imputation_parameters">evaluate_imputation_parameters</a>()</code>,
<code><a href="#topic+evaluate_imputed_values">evaluate_imputed_values</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>evaluate_parameters(1:4, 2:5, "RMSE")
</code></pre>

<hr>
<h2 id='impute_EM'>EM imputation</h2><span id='topic+impute_EM'></span>

<h3>Description</h3>

<p>Impute missing values in a data frame or a matrix using parameters estimated
via EM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_EM(
  ds,
  stochastic = TRUE,
  maxits = 1000,
  criterion = 1e-04,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_EM_+3A_ds">ds</code></td>
<td>
<p>A data frame or matrix with missing values.</p>
</td></tr>
<tr><td><code id="impute_EM_+3A_stochastic">stochastic</code></td>
<td>
<p>Logical; see details.</p>
</td></tr>
<tr><td><code id="impute_EM_+3A_maxits">maxits</code></td>
<td>
<p>Maximum number of iterations for the EM, passed to
<code><a href="norm.html#topic+em.norm">norm::em.norm()</a></code>.</p>
</td></tr>
<tr><td><code id="impute_EM_+3A_criterion">criterion</code></td>
<td>
<p>If maximum relative difference in parameter estimates is
below this threshold, the EM algorithm stops. Argument is directly passed
to <code><a href="norm.html#topic+em.norm">norm::em.norm()</a></code>.</p>
</td></tr>
<tr><td><code id="impute_EM_+3A_verbose">verbose</code></td>
<td>
<p>Should messages be given for special cases (see details)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At first parameters are estimated via <code><a href="norm.html#topic+em.norm">norm::em.norm()</a></code>. Then these
parameters are used in regression like models to impute the missing values.
If <code>stochachstic = FALSE</code>, the expected values (given the observed values and
the estimated parameters via EM) are imputed for the missing values of an
object. If <code>stochastic = TRUE</code>, residuals from a multivariate normal
distribution are added to these expected values.
</p>
<p>If all values in a row are <code>NA</code> or the required part of the covariance matrix
for the calculation of the expected values is not invertible, parts of the
estimated mean vector will be imputed. If <code>stochastic = TRUE</code>, residuals will
be added to these values. If <code>verbose = TRUE</code>, a message will be given for
these rows.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>ds</code> with imputed missing values.
</p>
<p>The number of EM iterations are added as an attribute (<code>iterations</code>).
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="norm.html#topic+em.norm">norm::em.norm()</a></code>, which estimates the parameters
</p>
</li>
<li> <p><code><a href="#topic+impute_expected_values">impute_expected_values()</a></code>, which calculates the imputation values
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>ds_orig &lt;- mvtnorm::rmvnorm(100, rep(0, 7))
ds_mis &lt;- delete_MCAR(ds_orig, p = 0.2)
ds_imp &lt;- impute_EM(ds_mis, stochastic = FALSE)
</code></pre>

<hr>
<h2 id='impute_expected_values'>Impute expected values</h2><span id='topic+impute_expected_values'></span>

<h3>Description</h3>

<p>Impute the missing values with expected values given the observed values and
estimated parameters assuming a multivariate normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_expected_values(
  ds,
  mu,
  S,
  stochastic = FALSE,
  M = is.na(ds),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_expected_values_+3A_ds">ds</code></td>
<td>
<p>A data frame or matrix with missing values.</p>
</td></tr>
<tr><td><code id="impute_expected_values_+3A_mu">mu</code></td>
<td>
<p>Vector of means for the variables.</p>
</td></tr>
<tr><td><code id="impute_expected_values_+3A_s">S</code></td>
<td>
<p>Covariance matrix of the variables.</p>
</td></tr>
<tr><td><code id="impute_expected_values_+3A_stochastic">stochastic</code></td>
<td>
<p>Logical, should residuals be added to the expected values.</p>
</td></tr>
<tr><td><code id="impute_expected_values_+3A_m">M</code></td>
<td>
<p>Missing data indicator matrix.</p>
</td></tr>
<tr><td><code id="impute_expected_values_+3A_verbose">verbose</code></td>
<td>
<p>Should messages be given for special cases (see details)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Normally, this function is called by other imputation function and should not
be called directly. The function imputes the missing values assuming a
multivariate normal distribution. This is equivalent to imputing the least
squares estimate of the missing values in some kind of way.
</p>
<p>If no values is observed in a row or a relevant submatrix of the
covariance matrix (<code>S_22</code>) is not invertible, the missing values are imputed
with (parts of) <code>mu</code> (plus a residuum, if <code>stochastich = TRUE</code>). If
<code>verbose = TRUE</code>, these cases will be listed in a message. Otherwise, they
will be imputed silently.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>ds</code> with imputed missing values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ds_orig &lt;- mvtnorm::rmvnorm(100, rep(0, 2))
ds_mis &lt;- delete_MCAR(ds_orig, p = 0.2)
# impute using true parameters:
ds_imp &lt;- impute_expected_values(ds_mis, mu = c(0, 0), diag(1, 2))
</code></pre>

<hr>
<h2 id='impute_hot_deck_in_classes'>Hot deck imputation in imputation classes</h2><span id='topic+impute_hot_deck_in_classes'></span>

<h3>Description</h3>

<p>Impute missing values in a data frame or a matrix using a hot deck within
imputation classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_hot_deck_in_classes(
  ds,
  cols_class,
  type = "cols_seq",
  breaks = Inf,
  use_quantiles = FALSE,
  min_objs_in_class = 1,
  min_obs_comp = 0,
  min_obs_per_col = 1,
  donor_limit = Inf,
  add_imputation_classes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_hot_deck_in_classes_+3A_ds">ds</code></td>
<td>
<p>A data frame or matrix with missing values.</p>
</td></tr>
<tr><td><code id="impute_hot_deck_in_classes_+3A_cols_class">cols_class</code></td>
<td>
<p>Columns that are used for constructing the imputation
classes.</p>
</td></tr>
<tr><td><code id="impute_hot_deck_in_classes_+3A_type">type</code></td>
<td>
<p>The type of hot deck (for details, see <code><a href="#topic+impute_sRHD">impute_sRHD()</a></code>).</p>
</td></tr>
<tr><td><code id="impute_hot_deck_in_classes_+3A_breaks">breaks</code></td>
<td>
<p>Number of intervals / levels a column is broken into (see
<code><a href="base.html#topic+cut">cut()</a></code>, which is used internally for cutting numeric columns). If <code>breaks = Inf</code> (the default), every unique value of a column can be in a separate
class (if no other restrictions apply).</p>
</td></tr>
<tr><td><code id="impute_hot_deck_in_classes_+3A_use_quantiles">use_quantiles</code></td>
<td>
<p>Should quantiles be used for cutting numeric vectors?
Normally, <code><a href="base.html#topic+cut">cut()</a></code> divides the range of an vector into equal spaced
intervals. If <code>use_quantiles = TRUE</code>, the classes will be of roughly equal
content.</p>
</td></tr>
<tr><td><code id="impute_hot_deck_in_classes_+3A_min_objs_in_class">min_objs_in_class</code></td>
<td>
<p>Minimum number of objects (rows) in an imputation class.</p>
</td></tr>
<tr><td><code id="impute_hot_deck_in_classes_+3A_min_obs_comp">min_obs_comp</code></td>
<td>
<p>Minimum number of completely observed objects (rows) in an
imputation class.</p>
</td></tr>
<tr><td><code id="impute_hot_deck_in_classes_+3A_min_obs_per_col">min_obs_per_col</code></td>
<td>
<p>Minimum number of observed values in every column of
an imputation class.</p>
</td></tr>
<tr><td><code id="impute_hot_deck_in_classes_+3A_donor_limit">donor_limit</code></td>
<td>
<p>Minimum odds between incomplete and complete values in a
column, if <code>type = cols_seq</code>. If <code>type = sim_comp</code>, minimum odds between
incomplete and complete rows. For <code>type = sim_part</code> the donor limit option
is not implemented and <code>donor_limit</code> should be <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="impute_hot_deck_in_classes_+3A_add_imputation_classes">add_imputation_classes</code></td>
<td>
<p>Should imputation classes be added as
attributes to the imputed dataset?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a combination of <code><a href="#topic+impute_in_classes">impute_in_classes()</a></code> and <code><a href="#topic+impute_sRHD">impute_sRHD()</a></code>.
It applies <code><a href="#topic+impute_sRHD">impute_sRHD()</a></code> inside of imputation classes (adjustment cells),
which are constructed via <code><a href="#topic+impute_in_classes">impute_in_classes()</a></code>. More details can be found in
these two functions.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>ds</code> with imputed missing values.
</p>


<h3>References</h3>

<p>Andridge, R.R. and Little, R.J.A. (2010), A Review of Hot Deck Imputation for
Survey Non-response. International Statistical Review, 78: 40-64.
doi:10.1111/j.1751-5823.2010.00103.x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+impute_in_classes">impute_in_classes()</a></code>, which is used for the construction of the imputation
classes.
</p>
<p><code><a href="#topic+impute_sRHD">impute_sRHD()</a></code>, which is used for the imputation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>impute_hot_deck_in_classes(data.frame(
  X = c(rep("A", 10), rep("B", 10)),
  Y = c(rep(NA, 5), 106:120)
),
"X",
donor_limit = 1
)
</code></pre>

<hr>
<h2 id='impute_in_classes'>Impute in classes</h2><span id='topic+impute_in_classes'></span>

<h3>Description</h3>

<p>Apply an imputation function inside imputation classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_in_classes(
  ds,
  cols_class,
  FUN,
  breaks = Inf,
  use_quantiles = FALSE,
  min_objs_in_class = 1,
  min_obs_comp = 0,
  min_obs_per_col = 1,
  donor_limit = Inf,
  dl_type = "cols_seq",
  add_imputation_classes = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_in_classes_+3A_ds">ds</code></td>
<td>
<p>A data frame or matrix with missing values.</p>
</td></tr>
<tr><td><code id="impute_in_classes_+3A_cols_class">cols_class</code></td>
<td>
<p>Columns that are used for constructing the imputation
classes.</p>
</td></tr>
<tr><td><code id="impute_in_classes_+3A_fun">FUN</code></td>
<td>
<p>An imputation function that is applied to impute the missing
values.</p>
</td></tr>
<tr><td><code id="impute_in_classes_+3A_breaks">breaks</code></td>
<td>
<p>Number of intervals / levels a column is broken into (see
<code><a href="base.html#topic+cut">cut()</a></code>, which is used internally for cutting numeric columns). If <code>breaks = Inf</code> (the default), every unique value of a column can be in a separate
class (if no other restrictions apply).</p>
</td></tr>
<tr><td><code id="impute_in_classes_+3A_use_quantiles">use_quantiles</code></td>
<td>
<p>Should quantiles be used for cutting numeric vectors?
Normally, <code><a href="base.html#topic+cut">cut()</a></code> divides the range of an vector into equal spaced
intervals. If <code>use_quantiles = TRUE</code>, the classes will be of roughly equal
content.</p>
</td></tr>
<tr><td><code id="impute_in_classes_+3A_min_objs_in_class">min_objs_in_class</code></td>
<td>
<p>Minimum number of objects (rows) in an imputation class.</p>
</td></tr>
<tr><td><code id="impute_in_classes_+3A_min_obs_comp">min_obs_comp</code></td>
<td>
<p>Minimum number of completely observed objects (rows) in an
imputation class.</p>
</td></tr>
<tr><td><code id="impute_in_classes_+3A_min_obs_per_col">min_obs_per_col</code></td>
<td>
<p>Minimum number of observed values in every column of
an imputation class.</p>
</td></tr>
<tr><td><code id="impute_in_classes_+3A_donor_limit">donor_limit</code></td>
<td>
<p>Minimum odds between incomplete and complete values in a
column, if <code>dl_type = cols_seq</code>. If <code>dl_type = sim_comp</code>, minimum odds
between incomplete and complete rows.</p>
</td></tr>
<tr><td><code id="impute_in_classes_+3A_dl_type">dl_type</code></td>
<td>
<p>See <code>donor_limit</code>.</p>
</td></tr>
<tr><td><code id="impute_in_classes_+3A_add_imputation_classes">add_imputation_classes</code></td>
<td>
<p>Should imputation classes be added as
attributes to the imputed dataset?</p>
</td></tr>
<tr><td><code id="impute_in_classes_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Imputation classes (sometimes also called adjustment cells) are
build using cross-validation of all <code>cols_class</code>. The classes are
collapsed, if they do not satisfy all of the criteria defined by
<code>min_objs_in_class</code>, <code>min_obs_comp</code>, <code>min_obs_per_col</code> and <code>donor_limit</code>.
Collapsing starts from the last value of <code>cols_class</code>. Internally, a mixture
of collapsing and early stopping is used for the construction of the
classes.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>ds</code> with imputed missing values.
</p>


<h3>References</h3>

<p>Andridge, R.R. and Little, R.J.A. (2010), A Review of Hot Deck
Imputation for Survey Non-response. International Statistical Review, 78:
40-64. doi:10.1111/j.1751-5823.2010.00103.x
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Mean imputation in classes
impute_in_classes(data.frame(X = 1:5, Y = c(NA, 12:15)), "X",
  impute_mean,
  min_obs_per_col = 2
)
</code></pre>

<hr>
<h2 id='impute_LS_adaptive'>LSimpute_adaptive</h2><span id='topic+impute_LS_adaptive'></span>

<h3>Description</h3>

<p>Perform LSimpute_adaptive as described by Bo et al. (2004)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_LS_adaptive(
  ds,
  k = 10,
  eps = 1e-06,
  min_common_obs = 5,
  r_max_min = 100,
  p_mis_sim = 0.05,
  warn_r_max = FALSE,
  verbose_gene = FALSE,
  verbose_array = FALSE,
  verbose_gene_p = FALSE,
  verbose_array_p = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_LS_adaptive_+3A_ds">ds</code></td>
<td>
<p>A data frame or matrix with missing values.</p>
</td></tr>
<tr><td><code id="impute_LS_adaptive_+3A_k">k</code></td>
<td>
<p>Directly passed to <code><a href="#topic+impute_LS_gene">impute_LS_gene()</a></code>.</p>
</td></tr>
<tr><td><code id="impute_LS_adaptive_+3A_eps">eps</code></td>
<td>
<p>Directly passed to <code><a href="#topic+impute_LS_gene">impute_LS_gene()</a></code>.</p>
</td></tr>
<tr><td><code id="impute_LS_adaptive_+3A_min_common_obs">min_common_obs</code></td>
<td>
<p>Directly passed to <code><a href="#topic+impute_LS_gene">impute_LS_gene()</a></code>.</p>
</td></tr>
<tr><td><code id="impute_LS_adaptive_+3A_r_max_min">r_max_min</code></td>
<td>
<p>Minimum number of nearest genes used for imputation. The
default value (100) corresponds to the choice of Bo et al. (2004).</p>
</td></tr>
<tr><td><code id="impute_LS_adaptive_+3A_p_mis_sim">p_mis_sim</code></td>
<td>
<p>Percentage of observed values that are set <code>NA</code> to estimate
the mixing coefficient <em>p</em>. The default value (0.05) corresponds to the
choice of Bo et al. (2004).</p>
</td></tr>
<tr><td><code id="impute_LS_adaptive_+3A_warn_r_max">warn_r_max</code></td>
<td>
<p>Should a warning be given, if <code>r_max_min</code> is set too high?</p>
</td></tr>
<tr><td><code id="impute_LS_adaptive_+3A_verbose_gene">verbose_gene</code></td>
<td>
<p>Should <code>impute_LS_gene()</code> be <code>verbose</code>?</p>
</td></tr>
<tr><td><code id="impute_LS_adaptive_+3A_verbose_array">verbose_array</code></td>
<td>
<p>Should <code>impute_LS_array()</code> be <code>verbose</code>?</p>
</td></tr>
<tr><td><code id="impute_LS_adaptive_+3A_verbose_gene_p">verbose_gene_p</code></td>
<td>
<p>Should <code>impute_LS_gene()</code> be <code>verbose</code> while estimating
<em>p</em>?</p>
</td></tr>
<tr><td><code id="impute_LS_adaptive_+3A_verbose_array_p">verbose_array_p</code></td>
<td>
<p>Should <code>impute_LS_array()</code> be <code>verbose</code> while
estimating <em>p</em>?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs LSimpute_adaptive as described by Bo et al. (2004).The function assumes that the genes are the rows of <code>ds</code>.
</p>
<p>LSimpute_adaptive combines imputation values from <code><a href="#topic+impute_LS_gene">impute_LS_gene()</a></code> and
<code><a href="#topic+impute_LS_array">impute_LS_array()</a></code> using a local (adaptive) approach for the mixing
coefficient <em>p</em>.
</p>
<p>If the dataset is too small or has too many missing values, there are some
fallback systems implemented. First, if <code>ncol(ds) &lt;= min_common_obs</code>
(normally, this should not the case!), values are imputed through
<code><a href="#topic+impute_LS_array">impute_LS_array()</a></code>. Second, <code>r_max_min</code> is automatically adjusted, if it is
too high. In this case, a warning will be given, if <code>warn_r_max = TRUE</code>.
Third, if there are not enough observed values in a row (less than
<code>min_common_obs</code>), the calculation of the mixing coefficient is not possible
and missing values of these rows are imputed with the values from
<code>impute_LS_array()</code>.
</p>
<p>The amount of feedback given from <code>impute_LS_gene()</code> and <code>impute_LS_array()</code>
is controlled via <code>verbose_gene</code>, <code>verbose_array</code>, <code>verbose_gene_p</code> and
<code>verbose_array_p</code>. The last two control the amount of feedback while
estimating <em>p</em> and the first two the amount of feedback during the estimation
of the values that are mixed with <em>p</em>. Internally,  the imputed dataset from
<code>impute_LS_gene()</code> is passed on to <code>impute_LS_array()</code>. Therefore, all
messages from <code>impute_LS_gene()</code> are truly from <code>impute_LS_gene()</code> and not a
part of <code>impute_LS_array()</code>, which never calls <code>impute_LS_gene()</code> in this
case. Furthermore, all messages from <code><a href="#topic+impute_expected_values">impute_expected_values()</a></code> belong to
<code>impute_LS_array()</code>.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>ds</code> with imputed missing values.
</p>


<h3>References</h3>

<p>Bo, T. H., Dysvik, B., &amp; Jonassen, I. (2004). LSimpute: accurate estimation of missing values in microarray data with least squares methods. Nucleic acids research, 32(3), e34
</p>


<h3>See Also</h3>

<p>Other LSimpute functions: 
<code><a href="#topic+impute_LS_array">impute_LS_array</a>()</code>,
<code><a href="#topic+impute_LS_combined">impute_LS_combined</a>()</code>,
<code><a href="#topic+impute_LS_gene">impute_LS_gene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
ds_mis &lt;- delete_MCAR(mvtnorm::rmvnorm(100, rep(0, 10)), 0.1)
ds_imp &lt;- impute_LS_adaptive(ds_mis)
</code></pre>

<hr>
<h2 id='impute_LS_array'>LSimpute_array</h2><span id='topic+impute_LS_array'></span>

<h3>Description</h3>

<p>Perform LSimpute_array as described by Bo et al. (2004)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_LS_array(
  ds,
  k = 10,
  eps = 1e-06,
  min_common_obs = 5,
  ds_impute_LS_gene = NULL,
  verbose_gene = FALSE,
  verbose_expected_values = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_LS_array_+3A_ds">ds</code></td>
<td>
<p>A data frame or matrix with missing values.</p>
</td></tr>
<tr><td><code id="impute_LS_array_+3A_k">k</code></td>
<td>
<p>Directly passed to <code><a href="#topic+impute_LS_gene">impute_LS_gene()</a></code>.</p>
</td></tr>
<tr><td><code id="impute_LS_array_+3A_eps">eps</code></td>
<td>
<p>Directly passed to <code><a href="#topic+impute_LS_gene">impute_LS_gene()</a></code>.</p>
</td></tr>
<tr><td><code id="impute_LS_array_+3A_min_common_obs">min_common_obs</code></td>
<td>
<p>Directly passed to <code><a href="#topic+impute_LS_gene">impute_LS_gene()</a></code>.</p>
</td></tr>
<tr><td><code id="impute_LS_array_+3A_ds_impute_ls_gene">ds_impute_LS_gene</code></td>
<td>
<p>Result of imputing <code>ds</code> with <code>ds_impute_LS_gene()</code>,
if this already exists (see details).</p>
</td></tr>
<tr><td><code id="impute_LS_array_+3A_verbose_gene">verbose_gene</code></td>
<td>
<p>Should <code>impute_LS_gene()</code> be <code>verbose</code>?</p>
</td></tr>
<tr><td><code id="impute_LS_array_+3A_verbose_expected_values">verbose_expected_values</code></td>
<td>
<p>Should <code>impute_expected_values()</code> be <code>verbose</code>?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs LSimpute_array as described by Bo et al. (2004).The function assumes that the genes are the rows of <code>ds</code>.
</p>
<p>The mean vector and covariance matrix for the imputation in LSimpute_array is
based on a imputed dataset from LSimpute_gene. This dataset can be supplied
directly via <code>ds_impute_LS_gene</code> or will automatically be created with
<code><a href="#topic+impute_LS_gene">impute_LS_gene()</a></code> (if <code>ds_impute_LS_gene</code> is <code>NULL</code>). The imputation values
are the expected values given the estimated parameters and the observed
values. They are calculated via <code><a href="#topic+impute_expected_values">impute_expected_values()</a></code>. The amount of
feedback from these two functions is controlled via <code>verbose_gene</code>  and
<code>verbose_expected_values</code>. The values of these two arguments are passed on to
the argument <code>verbose</code> from <code>impute_LS_gene()</code> and
<code>impute_expected_values()</code>.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>ds</code> with imputed missing values.
</p>


<h3>References</h3>

<p>Bo, T. H., Dysvik, B., &amp; Jonassen, I. (2004). LSimpute: accurate estimation of missing values in microarray data with least squares methods. Nucleic acids research, 32(3), e34
</p>


<h3>See Also</h3>

<p>Other LSimpute functions: 
<code><a href="#topic+impute_LS_adaptive">impute_LS_adaptive</a>()</code>,
<code><a href="#topic+impute_LS_combined">impute_LS_combined</a>()</code>,
<code><a href="#topic+impute_LS_gene">impute_LS_gene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
ds_mis &lt;- delete_MCAR(mvtnorm::rmvnorm(100, rep(0, 10)), 0.1)
ds_imp &lt;- impute_LS_array(ds_mis)
</code></pre>

<hr>
<h2 id='impute_LS_combined'>LSimpute_combined</h2><span id='topic+impute_LS_combined'></span>

<h3>Description</h3>

<p>Perform LSimpute_combined as described by Bo et al. (2004)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_LS_combined(
  ds,
  k = 10,
  eps = 1e-06,
  min_common_obs = 5,
  p_mis_sim = 0.05,
  verbose_gene = FALSE,
  verbose_array = FALSE,
  verbose_gene_p = FALSE,
  verbose_array_p = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_LS_combined_+3A_ds">ds</code></td>
<td>
<p>A data frame or matrix with missing values.</p>
</td></tr>
<tr><td><code id="impute_LS_combined_+3A_k">k</code></td>
<td>
<p>Directly passed to <code><a href="#topic+impute_LS_gene">impute_LS_gene()</a></code>.</p>
</td></tr>
<tr><td><code id="impute_LS_combined_+3A_eps">eps</code></td>
<td>
<p>Directly passed to <code><a href="#topic+impute_LS_gene">impute_LS_gene()</a></code>.</p>
</td></tr>
<tr><td><code id="impute_LS_combined_+3A_min_common_obs">min_common_obs</code></td>
<td>
<p>Directly passed to <code><a href="#topic+impute_LS_gene">impute_LS_gene()</a></code>.</p>
</td></tr>
<tr><td><code id="impute_LS_combined_+3A_p_mis_sim">p_mis_sim</code></td>
<td>
<p>Percentage of observed values that are set <code>NA</code> to estimate
the mixing coefficient <em>p</em>. The default value (0.05) corresponds to the
choice of Bo et al. (2004).</p>
</td></tr>
<tr><td><code id="impute_LS_combined_+3A_verbose_gene">verbose_gene</code></td>
<td>
<p>Should <code>impute_LS_gene()</code> be <code>verbose</code>?</p>
</td></tr>
<tr><td><code id="impute_LS_combined_+3A_verbose_array">verbose_array</code></td>
<td>
<p>Should <code>impute_LS_array()</code> be <code>verbose</code>?</p>
</td></tr>
<tr><td><code id="impute_LS_combined_+3A_verbose_gene_p">verbose_gene_p</code></td>
<td>
<p>Should <code>impute_LS_gene()</code> be <code>verbose</code> while estimating
<em>p</em>?</p>
</td></tr>
<tr><td><code id="impute_LS_combined_+3A_verbose_array_p">verbose_array_p</code></td>
<td>
<p>Should <code>impute_LS_array()</code> be <code>verbose</code> while
estimating <em>p</em>?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs LSimpute_combined as described by Bo et al. (2004).The function assumes that the genes are the rows of <code>ds</code>.
</p>
<p>LSimpute_combined combines imputation values from <code><a href="#topic+impute_LS_gene">impute_LS_gene()</a></code> and
<code><a href="#topic+impute_LS_array">impute_LS_array()</a></code> using a global approach for the mixing coefficient <em>p</em>.
The amount of feedback given from these underlying functions is controlled
via <code style="white-space: pre;">&#8288;verbose_gene, verbose_array, verbose_gene_p, verbose_array_p&#8288;</code>. The last
two control the amount of feedback while estimating <em>p</em> and the first two
the amount of feedback during the estimation of the values that are mixed
with <em>p</em>. Internally,  the imputed dataset from <code>impute_LS_gene()</code> is passed
on to <code>impute_LS_array()</code>. Therefore, all messages from <code>impute_LS_gene()</code>
are truly from <code>impute_LS_gene()</code> and not a part of <code>impute_LS_array()</code>,
which never calls <code>impute_LS_gene()</code> in this case. Furthermore, all messages
from <code><a href="#topic+impute_expected_values">impute_expected_values()</a></code> belong to <code>impute_LS_array()</code>.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>ds</code> with imputed missing values.
</p>


<h3>References</h3>

<p>Bo, T. H., Dysvik, B., &amp; Jonassen, I. (2004). LSimpute: accurate estimation of missing values in microarray data with least squares methods. Nucleic acids research, 32(3), e34
</p>


<h3>See Also</h3>

<p>Other LSimpute functions: 
<code><a href="#topic+impute_LS_adaptive">impute_LS_adaptive</a>()</code>,
<code><a href="#topic+impute_LS_array">impute_LS_array</a>()</code>,
<code><a href="#topic+impute_LS_gene">impute_LS_gene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
ds_mis &lt;- delete_MCAR(mvtnorm::rmvnorm(100, rep(0, 10)), 0.1)
ds_imp &lt;- impute_LS_combined(ds_mis)
</code></pre>

<hr>
<h2 id='impute_LS_gene'>LSimpute_gene</h2><span id='topic+impute_LS_gene'></span>

<h3>Description</h3>

<p>Perform LSimpute_gene as described by Bo et al. (2004)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_LS_gene(
  ds,
  k = 10,
  eps = 1e-06,
  min_common_obs = 5,
  return_r_max = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_LS_gene_+3A_ds">ds</code></td>
<td>
<p>A data frame or matrix with missing values.</p>
</td></tr>
<tr><td><code id="impute_LS_gene_+3A_k">k</code></td>
<td>
<p>Number of most correlated genes used for the imputation of a gene.</p>
</td></tr>
<tr><td><code id="impute_LS_gene_+3A_eps">eps</code></td>
<td>
<p>Used in the calculation of the weights (Bo et al. (2004) used
<code>eps = 1e-6</code>).</p>
</td></tr>
<tr><td><code id="impute_LS_gene_+3A_min_common_obs">min_common_obs</code></td>
<td>
<p>A row can only take part in the imputation of another
row, if both rows share at least <code>min_common_obs</code> columns with no missing
values.</p>
</td></tr>
<tr><td><code id="impute_LS_gene_+3A_return_r_max">return_r_max</code></td>
<td>
<p>Logical; normally, this should be <code>FALSE</code>. <code>TRUE</code> is
used inside of <code>impute_LS_adaptive()</code> to speed up some computations.</p>
</td></tr>
<tr><td><code id="impute_LS_gene_+3A_verbose">verbose</code></td>
<td>
<p>Should messages be given for special cases (see details)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs LSimpute_gene as described by Bo et al. (2004).The function assumes that the genes are the rows of <code>ds</code>.
</p>
<p>Bo et al. (2004) seem to have chosen <code>min_common_obs = 5</code>. However, they did
not document this behavior. This value emerged from inspecting
imputation results from the  original jar-file, which is provided by Bo et
al. (2004).
</p>
<p>If there are less than <code>min_common_obs</code> observed values in a row and at least
one observed value, the mean of the observed row values is imputed. If no
value is observed in a row, the observed column means are imputed for the
missing row values. This is the only known difference between this function
and the original one from Bo et al. (2004). The original function would not
impute such a row and return a dataset with missing values in this row. There
is one more case that needs a special treatment: If no suitable row can be
found to impute a row, the mean of the observed values is imputed, too. If
<code>verbose = TRUE</code>, a message will be given for the encountered instances of
the described special cases. If <code>verbose = FALSE</code>, the function will deal
with theses cases silently.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>ds</code> with imputed missing values.
</p>
<p>If <code>return_r_max = TRUE</code>, a list with the imputed dataset and r_max.
</p>


<h3>References</h3>

<p>Bo, T. H., Dysvik, B., &amp; Jonassen, I. (2004). LSimpute: accurate estimation of missing values in microarray data with least squares methods. Nucleic acids research, 32(3), e34
</p>


<h3>See Also</h3>

<p>Other LSimpute functions: 
<code><a href="#topic+impute_LS_adaptive">impute_LS_adaptive</a>()</code>,
<code><a href="#topic+impute_LS_array">impute_LS_array</a>()</code>,
<code><a href="#topic+impute_LS_combined">impute_LS_combined</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
ds_mis &lt;- delete_MCAR(mvtnorm::rmvnorm(100, rep(0, 10)), 0.1)
ds_imp &lt;- impute_LS_gene(ds_mis)
</code></pre>

<hr>
<h2 id='impute_mean'>Mean imputation</h2><span id='topic+impute_mean'></span>

<h3>Description</h3>

<p>Impute an observed mean for the missing values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_mean(ds, type = "columnwise", convert_tibble = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_mean_+3A_ds">ds</code></td>
<td>
<p>A data frame or matrix with missing values.</p>
</td></tr>
<tr><td><code id="impute_mean_+3A_type">type</code></td>
<td>
<p>A string specifying the values used for imputation; one of:
&quot;columnwise&quot;, &quot;rowwise&quot;, &quot;total&quot;, &quot;Two-Way&quot; or &quot;Winer&quot;  (see details).</p>
</td></tr>
<tr><td><code id="impute_mean_+3A_convert_tibble">convert_tibble</code></td>
<td>
<p>If <code>ds</code> is a tibble, should it be converted
(see section A note for tibble users).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For every missing value the mean of some observed values is imputed.
The observed values to be used are specified via <code>type</code>.
For example, <code>type = "columnwise"</code> (the default) imputes the mean of
the observed values in a column for all missing values in the column.
This is normally meant, if someone speaks of &quot;imputing the mean&quot; or
&quot;mean imputation&quot;.
</p>
<p>Other options for <code>type</code> are: &quot;rowwise&quot;, &quot;total&quot;, &quot;Winer&quot; and
&quot;Two-way&quot;.
The option &quot;rowwise&quot; imputes all missing values in a row with the mean of the
observed values in the same row.
&quot;total&quot; will impute every missing value with the mean of all observed values
in <code>ds</code>.
&quot;Winer&quot; imputes the mean of the rowwise and columnwise mean.
Beland et al. (2016) called this method &quot;Winer&quot; and they attributed the
method to Winer (1971).
&quot;Two-way&quot; imputes the sum of rowwise and columnwise mean minus the total mean.
This method was suggested by D.B Rubin to Bernaards &amp; Sijtsma, K. (2000).
</p>


<h3>Value</h3>

<p>An object of the same class as <code>ds</code> with imputed missing values.
</p>


<h3>A note for tibble users</h3>

<p>If you use tibbles and <code>convert_tibble</code> is <code>TRUE</code> the tibble is
first converted to a data frame, then imputed and converted back. If
<code>convert_tibble</code> is <code>FALSE</code> no conversion is done. However,
depending on the tibble and the package version of tibble you use,
imputation may not be possible and some errors will be thrown.
</p>


<h3>References</h3>

<p>Beland, S., Pichette, F., &amp; Jolani, S. (2016). Impact on Cronbach's
<code class="reqn">\alpha</code> of simple treatment methods for missing data.
<em>The Quantitative Methods for Psychology</em>, 12(1), 57-73.
</p>
<p>Bernaards, C. A., &amp; Sijtsma, K. (2000). Influence of imputation and EM
methods on factor analysis when item nonresponse in questionnaire data is
nonignorable. <em>Multivariate Behavioral Research</em>, 35(3), 321-364.
</p>
<p>Winer, B. J. (1971). <em>Statistical principles in experimental design (2ed ed.)</em>
New York: McGraw-Hill
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apply_imputation">apply_imputation</a></code> the workhorse for this function.
</p>
<p>Other location parameter imputation functions: 
<code><a href="#topic+impute_median">impute_median</a>()</code>,
<code><a href="#topic+impute_mode">impute_mode</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ds &lt;- data.frame(X = 1:20, Y = 101:120)
ds_mis &lt;- delete_MCAR(ds, 0.2)
ds_imp &lt;- impute_mean(ds_mis)
# completely observed columns can be of any type:
ds_mis_char &lt;- cbind(ds_mis, letters[1:20])
ds_imp_char &lt;- impute_mean(ds_mis_char)
</code></pre>

<hr>
<h2 id='impute_median'>Median imputation</h2><span id='topic+impute_median'></span>

<h3>Description</h3>

<p>Impute an observed median value for every missing value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_median(
  ds,
  type = "columnwise",
  ordered_low = FALSE,
  convert_tibble = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_median_+3A_ds">ds</code></td>
<td>
<p>A data frame or matrix with missing values.</p>
</td></tr>
<tr><td><code id="impute_median_+3A_type">type</code></td>
<td>
<p>A string specifying the values used for imputation; one of:
&quot;columnwise&quot;, &quot;rowwise&quot;, &quot;total&quot;, &quot;Two-Way&quot; or &quot;Winer&quot;  (see details).</p>
</td></tr>
<tr><td><code id="impute_median_+3A_ordered_low">ordered_low</code></td>
<td>
<p>Logical; used for the calculation of the median from
ordered factors (for details see: <a href="#topic+median.factor">median.factor</a>).</p>
</td></tr>
<tr><td><code id="impute_median_+3A_convert_tibble">convert_tibble</code></td>
<td>
<p>If <code>ds</code> is a tibble, should it be converted
(see section A note for tibble users).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function behaves exactly like <code><a href="#topic+impute_mean">impute_mean</a></code>.
The only difference is that it imputes a median instead of a mean.
All <code>type</code>s from <code><a href="#topic+impute_mean">impute_mean</a></code> are also implemented for
<code>impute_median</code>.
They are documented in <code><a href="#topic+impute_mean">impute_mean</a></code> and
<code><a href="#topic+apply_imputation">apply_imputation</a></code>.
The function <code><a href="stats.html#topic+median">median</a></code> is used for the calculation of
the median values for imputation.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>ds</code> with imputed missing values.
</p>


<h3>A note for tibble users</h3>

<p>If you use tibbles and <code>convert_tibble</code> is <code>TRUE</code> the tibble is
first converted to a data frame, then imputed and converted back. If
<code>convert_tibble</code> is <code>FALSE</code> no conversion is done. However,
depending on the tibble and the package version of tibble you use,
imputation may not be possible and some errors will be thrown.
</p>


<h3>References</h3>

<p>Beland, S., Pichette, F., &amp; Jolani, S. (2016). Impact on Cronbach's
<code class="reqn">\alpha</code> of simple treatment methods for missing data.
<em>The Quantitative Methods for Psychology</em>, 12(1), 57-73.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apply_imputation">apply_imputation</a></code> the workhorse for this function.
</p>
<p><code><a href="stats.html#topic+median">median</a></code>, <code><a href="#topic+median.factor">median.factor</a></code>
</p>
<p>Other location parameter imputation functions: 
<code><a href="#topic+impute_mean">impute_mean</a>()</code>,
<code><a href="#topic+impute_mode">impute_mode</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ds &lt;- data.frame(X = 1:20, Y = ordered(LETTERS[1:20]))
ds_mis &lt;- delete_MCAR(ds, 0.2)
ds_imp &lt;- impute_median(ds_mis)
# completely observed columns can be of any type:
ds_mis_char &lt;- cbind(ds_mis, letters[1:20])
ds_imp_char &lt;- impute_median(ds_mis_char)
</code></pre>

<hr>
<h2 id='impute_mode'>Mode imputation</h2><span id='topic+impute_mode'></span>

<h3>Description</h3>

<p>Impute an observed mode value for every missing value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_mode(ds, type = "columnwise", convert_tibble = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_mode_+3A_ds">ds</code></td>
<td>
<p>A data frame or matrix with missing values.</p>
</td></tr>
<tr><td><code id="impute_mode_+3A_type">type</code></td>
<td>
<p>A string specifying the values used for imputation; one of:
&quot;columnwise&quot;, &quot;rowwise&quot;, &quot;total&quot;, &quot;Two-Way&quot; or &quot;Winer&quot;  (see details).</p>
</td></tr>
<tr><td><code id="impute_mode_+3A_convert_tibble">convert_tibble</code></td>
<td>
<p>If <code>ds</code> is a tibble, should it be converted
(see section A note for tibble users).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function behaves exactly like <code><a href="#topic+impute_mean">impute_mean</a></code>. The only
difference is that it imputes a mode instead of a mean. All <code>type</code>s
from <code><a href="#topic+impute_mean">impute_mean</a></code> are also implemented for <code>impute_mode</code>.
They are documented in <code><a href="#topic+impute_mean">impute_mean</a></code> and
<code><a href="#topic+apply_imputation">apply_imputation</a></code>.
</p>
<p>A mode value of a vector <em>x</em> is a most frequent value of <em>x</em>.
If this value is not unique, the first occurring mode value in <em>x</em> will
be used as imputation value.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>ds</code> with imputed missing values.
</p>


<h3>References</h3>

<p>Beland, S., Pichette, F., &amp; Jolani, S. (2016). Impact on Cronbach's
<code class="reqn">\alpha</code> of simple treatment methods for missing data.
<em>The Quantitative Methods for Psychology</em>, 12(1), 57-73.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apply_imputation">apply_imputation</a></code> the workhorse for this function.
</p>
<p>Other location parameter imputation functions: 
<code><a href="#topic+impute_mean">impute_mean</a>()</code>,
<code><a href="#topic+impute_median">impute_median</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ds &lt;- data.frame(X = c(1:12, rep(8, 8)), Y = 101:120)
ds_mis &lt;- delete_MCAR(ds, 0.2)
ds_imp &lt;- impute_mode(ds_mis)
</code></pre>

<hr>
<h2 id='impute_sRHD'>Simple random hot deck imputation</h2><span id='topic+impute_sRHD'></span>

<h3>Description</h3>

<p>Impute missing values in a data frame or a matrix using a simple random hot
deck
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_sRHD(ds, type = "cols_seq", donor_limit = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_sRHD_+3A_ds">ds</code></td>
<td>
<p>A data frame or matrix with missing values.</p>
</td></tr>
<tr><td><code id="impute_sRHD_+3A_type">type</code></td>
<td>
<p>The type of hot deck; the default (&quot;cols_seq&quot;) is a random hot
deck that imputes each column separately. Other choices are &quot;sim_comp&quot; and
&quot;sim_part&quot;. Both impute all missing values in an object (row)
simultaneously using a single donor object. The difference between the two
types is the choice of objects that can act as donors. &quot;sim_comp:&quot; only
completely observed objects can be donors. &quot;sim_part&quot;: all objects that
have no missing values in the missing parts of a recipient can be donors.</p>
</td></tr>
<tr><td><code id="impute_sRHD_+3A_donor_limit">donor_limit</code></td>
<td>
<p>Numeric of length one or &quot;min&quot;; how many times an object
can be a donor. Default is <code>Inf</code> (no restriction).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three types of simple random hot decks implemented. They can be
selected via <code>type</code>:
</p>

<ul>
<li><p>&quot;cols_seq&quot; (the default): Each variable (column) is handled
separately. If an object (row) has a missing value in a variable (column),
then one of the observed values in the same variable is chosen randomly and
the missing value is replaced with this chosen value. This is done for all
missing values.
</p>
</li>
<li><p>&quot;sim_comp&quot;: All missing variables (columns) of an object are imputed together
(&quot;simultaneous&quot;). For every object with missing values (such an object is
called a recipient in hot deck terms), one complete object is chosen randomly
and all missing values of the recipient are imputed with the values from the
complete object. A complete object used for imputation is called a donor.
</p>
</li>
<li><p>&quot;sim_part&quot;: All missing variables (columns) of an object are imputed
together (&quot;simultaneous&quot;). For every object with missing values (recipient)
one donor is chosen. The donor must have observed values in all the variables
that are missing in the recipient. The donor is allowed to have unobserved
values in the non-missing parts of the recipient. So, in contrast to
&quot;sim_comp&quot;, the donor can be partly incomplete. </p>
</li></ul>

<p>The parameter <code>donor_limit</code> controls how often an object can be a donor.
This parameter is only implemented for types &quot;cols_seq&quot; and &quot;sim_comp&quot;. If
<code>type = "sim_part"</code> and <code>donor_limit</code> is not <code>Inf</code>, then an
error will be thrown. For &quot;sim_comp&quot; the default value (<code>Inf</code>) allows
every object to be a donor for an infinite number of times (there is no
restriction on the times an object can be a donor). If a numeric value less
than <code>Inf</code> is chosen, then every object can be a donor at most
<code>donor_limit</code> times. For example <code>donor_limit = 1</code> ensures that
every object donates at most one time. If there are only few complete objects
and <code>donor_limit</code> is set too low, then an imputation might not be
possible with the chosen <code>donor_limit</code>. In this case, the
<code>donor_limit</code> will be adjusted (see examples). Setting <code>donor_limit
= "min"</code> chooses automatically the minimum value for <code>donor_limit</code> that
allows imputation of all missing values. For <code>type = "cols_seq"</code> the
donor limit is applied for every column separately.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>ds</code> with imputed missing values.
</p>


<h3>References</h3>

<p>Andridge, R. R., &amp; Little, R. J. (2010). A review of hot deck
imputation for survey non-response. <em>International statistical review</em>,
78(1), 40-64.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ds &lt;- data.frame(X = 1:20, Y = 101:120)
ds_mis &lt;- delete_MCAR(ds, 0.2)
ds_imp &lt;- impute_sRHD(ds_mis)

# Warning: donor limit to low
ds_mis_one_donor &lt;- ds
ds_mis_one_donor[1:19, "X"] &lt;- NA
impute_sRHD(ds_mis_one_donor, donor_limit = 3)

</code></pre>

<hr>
<h2 id='median.factor'>Median for ordered factors</h2><span id='topic+median.factor'></span>

<h3>Description</h3>

<p>Compute the median of an ordered factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'factor'
median(x, na.rm = FALSE, ordered_low = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="median.factor_+3A_x">x</code></td>
<td>
<p>An ordered factor (for unordered factors an error will be thrown).</p>
</td></tr>
<tr><td><code id="median.factor_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical; should <code>NA</code> be removed before computation?</p>
</td></tr>
<tr><td><code id="median.factor_+3A_ordered_low">ordered_low</code></td>
<td>
<p>Logical; only used if the length of x is even and the two
middle values are unequal (see details).</p>
</td></tr>
<tr><td><code id="median.factor_+3A_...">...</code></td>
<td>
<p>Not used in this function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, the median for an ordered factor is not implemented in base R.
This function is a remedy for this. It allows the computation of &ldquo;a
median&rdquo; for ordered factors (see below) and overwrites the error message for
unordered factors from <code><a href="stats.html#topic+median">median.default</a></code> (hence, the
function name is median.factor and not median.ordered).
</p>
<p>If the length of <code>x</code> is odd, then the median will be the middle value
of the sorted list of elements from <code>x</code>. If the length of <code>x</code> is
even and the two middle values of the sorted list of elements from <code>x</code>
are equal, then the median is one of these (equal) middle values. The only
problematic case is an even length <code>x</code> with unequal middle values. In
this case, the median of a numeric vector is normally defined as the mean of
the two middle values. However, for ordered factors the mean is not defined.
The argument <code>ordered_low</code> cures this problem. If <code>ordered_low =
FALSE</code> (the default), then the larger of the two middle values is returned
(this value is called &lsquo;hi-median&rsquo; in <code><a href="stats.html#topic+mad">mad</a></code>). If
<code>ordered_low = TRUE</code>, then the smaller of the two middle values is
returned (this value is called &lsquo;low-median&rsquo; in
<code><a href="stats.html#topic+mad">mad</a></code>).
</p>


<h3>Value</h3>

<p>a length-one factor
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ord_factor_odd &lt;- ordered(letters[1:5])
median(ord_factor_odd) # calls median.factor, if package is loaded

# If only base R is loaded, median.default will be called
# and will throw an error:
tryCatch(median.default(ord_factor_odd), error = function(e) e)

ord_factor_even &lt;- ordered(letters[1:4])
median(ord_factor_even, ordered_low = FALSE)
median(ord_factor_even, ordered_low = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
