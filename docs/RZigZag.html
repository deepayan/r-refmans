<!DOCTYPE html><html lang="en"><head><title>Help for package RZigZag</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RZigZag}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RZigZag'><p>RZigZag</p></a></li>
<li><a href='#BPSGaussian'><p>BPSGaussian</p></a></li>
<li><a href='#BPSIIDGaussian'><p>BPSIIDGaussian</p></a></li>
<li><a href='#BPSStudentT'><p>BPSStudentT</p></a></li>
<li><a href='#DiscreteSamples'><p>DiscreteSamples</p></a></li>
<li><a href='#EstimateCovarianceMatrix'><p>EstimateCovarianceMatrix</p></a></li>
<li><a href='#EstimateESS'><p>EstimateESS</p></a></li>
<li><a href='#EstimateMoment'><p>EstimateMoment</p></a></li>
<li><a href='#ZigZagGaussian'><p>ZigZagGaussian</p></a></li>
<li><a href='#ZigZagIIDGaussian'><p>ZigZagIIDGaussian</p></a></li>
<li><a href='#ZigZagLogistic'><p>ZigZagLogistic</p></a></li>
<li><a href='#ZigZagStudentT'><p>ZigZagStudentT</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Zig-Zag Sampler</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-07-20</td>
</tr>
<tr>
<td>Author:</td>
<td>Joris Bierkens</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joris Bierkens &lt;j.bierkens@vu.nl&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the Zig-Zag algorithm (Bierkens, Fearnhead, Roberts, 2016) &lt;<a href="https://doi.org/10.48550/arXiv.1607.03188">doi:10.48550/arXiv.1607.03188</a>&gt; applied and Bouncy Particle Sampler &lt;<a href="https://doi.org/10.48550/arXiv.1510.02451">doi:10.48550/arXiv.1510.02451</a>&gt; for a Gaussian target and Student distribution.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.3)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-07-20 05:46:34 UTC; joris</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-07-20 08:00:04</td>
</tr>
</table>
<hr>
<h2 id='RZigZag'>RZigZag</h2><span id='topic+RZigZag'></span><span id='topic+RZigZag-package'></span>

<h3>Description</h3>

<p>Implements various piecewise deterministic Monte Carlo methods, including the Zig-Zag Sampler (Bierkens, Fearnhead, Roberts, 2019, <a href="https://arxiv.org/abs/1607.03188">https://arxiv.org/abs/1607.03188</a>) and the Bouncy Particle Sampler (BPS, Bouchard-Côté et al., 2017, <a href="https://arxiv.org/abs/1510.02451">https://arxiv.org/abs/1510.02451</a>).
Typical usage consists of first creating a &quot;skeleton&quot; consisting of &quot;events&quot;, which can be used directly for plotting trajectories.
The skeleton may be post-processed to extract information, such as as moment and covariance estimates, discrete samples at fixed time intervals along the trajectory, effective sample size and asymptotic variance.
</p>


<h3>Details</h3>

<p>This package currently consists of the following functions for generating skeletons:
<code><a href="#topic+ZigZagLogistic">ZigZagLogistic</a></code> for logistic regression, <code><a href="#topic+ZigZagGaussian">ZigZagGaussian</a></code> for multivariate Gaussian, <code><a href="#topic+ZigZagIIDGaussian">ZigZagIIDGaussian</a></code> for a IID Gaussian target using Zig-Zag, <code><a href="#topic+ZigZagStudentT">ZigZagStudentT</a></code> for spherically symmetric or factorized Student-t distribution, <code><a href="#topic+BPSGaussian">BPSGaussian</a></code> for multivariate Gaussian using BPS, <code><a href="#topic+BPSIIDGaussian">BPSIIDGaussian</a></code> for a IID Gaussian target using BPS, <code><a href="#topic+BPSStudentT">BPSStudentT</a></code> for BPS applied to a spherically symmetric or factorized Student-t distribution.
Furthermore the package contains the following functions for post-processing:
<code><a href="#topic+EstimateESS">EstimateESS</a></code> (to estimate asymptotic variance and effective sample size for individual coordinates), <code><a href="#topic+EstimateMoment">EstimateMoment</a></code>, <code><a href="#topic+EstimateCovarianceMatrix">EstimateCovarianceMatrix</a></code> and <code><a href="#topic+DiscreteSamples">DiscreteSamples</a></code>.
</p>


<h3>Author(s)</h3>

<p>Joris Bierkens
</p>
<p>With thanks to Matt Moores, <a href="https://mattstats.wordpress.com/">https://mattstats.wordpress.com/</a>, for his help in getting from C++ code to a CRAN-ready Rcpp based package.
</p>

<hr>
<h2 id='BPSGaussian'>BPSGaussian</h2><span id='topic+BPSGaussian'></span>

<h3>Description</h3>

<p>Applies the BPS Sampler to a Gaussian target distribution, as detailed in Bouchard-Côté et al, 2017.
Assume potential of the form </p>
<p style="text-align: center;"><code class="reqn">U(x) = (x - mu)^T V (x - mu)/2,</code>
</p>
<p> i.e. a Gaussian with mean vector <code>mu</code> and covariance matrix <code>inv(V)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BPSGaussian(V, mu, n_iter = -1L, finalTime = -1, x0 = numeric(0),
  v0 = numeric(0), refresh_rate = 1, unit_velocity = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BPSGaussian_+3A_v">V</code></td>
<td>
<p>the inverse covariance matrix (or precision matrix) of the Gaussian target distribution.</p>
</td></tr>
<tr><td><code id="BPSGaussian_+3A_mu">mu</code></td>
<td>
<p>mean of the Gaussian target distribution</p>
</td></tr>
<tr><td><code id="BPSGaussian_+3A_n_iter">n_iter</code></td>
<td>
<p>Number of algorithm iterations; will result in the equivalent amount of skeleton points in Gaussian case because no rejections are needed.</p>
</td></tr>
<tr><td><code id="BPSGaussian_+3A_finaltime">finalTime</code></td>
<td>
<p>If provided and nonnegative, run the BPS sampler until a trajectory of continuous time length finalTime is obtained (ignoring the value of <code>n_iterations</code>)</p>
</td></tr>
<tr><td><code id="BPSGaussian_+3A_x0">x0</code></td>
<td>
<p>starting point (optional, if not specified taken to be the origin)</p>
</td></tr>
<tr><td><code id="BPSGaussian_+3A_v0">v0</code></td>
<td>
<p>starting direction (optional, if not specified taken to be a random vector)</p>
</td></tr>
<tr><td><code id="BPSGaussian_+3A_refresh_rate">refresh_rate</code></td>
<td>
<p><code>lambda_refresh</code></p>
</td></tr>
<tr><td><code id="BPSGaussian_+3A_unit_velocity">unit_velocity</code></td>
<td>
<p>TRUE indicates velocities uniform on unit sphere, FALSE (default) indicates standard normal velocities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following objects:
</p>
<p><code>Times</code>: Vector of switching times
</p>
<p><code>Positions</code>: Matrix whose columns are locations of switches. The number of columns is identical to the length of <code>skeletonTimes</code>. Be aware that the skeleton points themselves are NOT samples from the target distribution.
</p>
<p><code>Velocities</code>: Matrix whose columns are velocities just after switches. The number of columns is identical to the length of <code>skeletonTimes</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>V &lt;- matrix(c(3,1,1,3),nrow=2)
mu &lt;- c(2,2)
x0 &lt;- c(0,0)
result &lt;- BPSGaussian(V, mu, n_iter = 100, x0 = x0)
plot(result$Positions[1,], result$Positions[2,],type='l',asp=1)
</code></pre>

<hr>
<h2 id='BPSIIDGaussian'>BPSIIDGaussian</h2><span id='topic+BPSIIDGaussian'></span>

<h3>Description</h3>

<p>Applies the Bouncy Particle Sampler to a IID Gaussian distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BPSIIDGaussian(variance, dim = 1L, n_iter = -1L, finalTime = -1,
  x0 = numeric(0), v0 = numeric(0), refresh_rate = 1,
  unit_velocity = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BPSIIDGaussian_+3A_variance">variance</code></td>
<td>
<p>scalar indicating variance</p>
</td></tr>
<tr><td><code id="BPSIIDGaussian_+3A_dim">dim</code></td>
<td>
<p>dimension</p>
</td></tr>
<tr><td><code id="BPSIIDGaussian_+3A_n_iter">n_iter</code></td>
<td>
<p>Number of algorithm iterations; will result in the equivalent amount of skeleton points in Gaussian case because no rejections are needed.</p>
</td></tr>
<tr><td><code id="BPSIIDGaussian_+3A_finaltime">finalTime</code></td>
<td>
<p>If provided and nonnegative, run the sampler until a trajectory of continuous time length finalTime is obtained (ignoring the value of <code>n_iterations</code>)</p>
</td></tr>
<tr><td><code id="BPSIIDGaussian_+3A_x0">x0</code></td>
<td>
<p>starting point (optional, if not specified taken to be the origin)</p>
</td></tr>
<tr><td><code id="BPSIIDGaussian_+3A_v0">v0</code></td>
<td>
<p>starting direction (optional, if not specified taken to be a random vector)</p>
</td></tr>
<tr><td><code id="BPSIIDGaussian_+3A_refresh_rate">refresh_rate</code></td>
<td>
<p><code>lambda_refresh</code></p>
</td></tr>
<tr><td><code id="BPSIIDGaussian_+3A_unit_velocity">unit_velocity</code></td>
<td>
<p>TRUE indicates velocities uniform on unit sphere, FALSE (default) indicates standard normal velocities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following objects:
</p>
<p><code>Times</code>: Vector of switching times
</p>
<p><code>Positions</code>: Matrix whose columns are locations of switches. The number of columns is identical to the length of <code>skeletonTimes</code>. Be aware that the skeleton points themselves are NOT samples from the target distribution.
</p>
<p><code>Velocities</code>: Matrix whose columns are velocities just after switches. The number of columns is identical to the length of <code>skeletonTimes</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- BPSIIDGaussian(1, 2, 1000)
plot(result$Positions[2,], result$Positions[1,],type='l',asp=1)
</code></pre>

<hr>
<h2 id='BPSStudentT'>BPSStudentT</h2><span id='topic+BPSStudentT'></span>

<h3>Description</h3>

<p>Applies the Zig-Zag Sampler to a Student T distribution (IID or spherically symmetric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BPSStudentT(dof, dim = 1L, n_iter = -1L, finalTime = -1,
  x0 = numeric(0), v0 = numeric(0), sphericallySymmetric = TRUE,
  refresh_rate = 1, unit_velocity = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BPSStudentT_+3A_dof">dof</code></td>
<td>
<p>scalar indicating degrees of freedom</p>
</td></tr>
<tr><td><code id="BPSStudentT_+3A_dim">dim</code></td>
<td>
<p>dimension</p>
</td></tr>
<tr><td><code id="BPSStudentT_+3A_n_iter">n_iter</code></td>
<td>
<p>Number of algorithm iterations; will result in the equivalent amount of skeleton points in Gaussian case because no rejections are needed.</p>
</td></tr>
<tr><td><code id="BPSStudentT_+3A_finaltime">finalTime</code></td>
<td>
<p>If provided and nonnegative, run the sampler until a trajectory of continuous time length finalTime is obtained (ignoring the value of <code>n_iterations</code>)</p>
</td></tr>
<tr><td><code id="BPSStudentT_+3A_x0">x0</code></td>
<td>
<p>starting point (optional, if not specified taken to be the origin)</p>
</td></tr>
<tr><td><code id="BPSStudentT_+3A_v0">v0</code></td>
<td>
<p>starting direction (optional, if not specified taken to be a random vector)</p>
</td></tr>
<tr><td><code id="BPSStudentT_+3A_sphericallysymmetric">sphericallySymmetric</code></td>
<td>
<p>boolean. If false, sample iid Student T distribution, if true (default) sample spherically summetric Student t dsitribution.</p>
</td></tr>
<tr><td><code id="BPSStudentT_+3A_refresh_rate">refresh_rate</code></td>
<td>
<p><code>lambda_refresh</code></p>
</td></tr>
<tr><td><code id="BPSStudentT_+3A_unit_velocity">unit_velocity</code></td>
<td>
<p>TRUE indicates velocities uniform on unit sphere, FALSE (default) indicates standard normal velocities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following objects:
</p>
<p><code>Times</code>: Vector of switching times
</p>
<p><code>Positions</code>: Matrix whose columns are locations of switches. The number of columns is identical to the length of <code>skeletonTimes</code>. Be aware that the skeleton points themselves are NOT samples from the target distribution.
</p>
<p><code>Velocities</code>: Matrix whose columns are velocities just after switches. The number of columns is identical to the length of <code>skeletonTimes</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dim = 2
dof = 4
result &lt;- BPSStudentT(dof, dim, n_iter=1000,sphericallySymmetric = TRUE)
plot(result$Positions[1,], result$Positions[2,],type='l',asp=1)
</code></pre>

<hr>
<h2 id='DiscreteSamples'>DiscreteSamples</h2><span id='topic+DiscreteSamples'></span>

<h3>Description</h3>

<p>Extract discrete samples from a skeleton
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiscreteSamples(skeletonList, n_samples, coordinate = -1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DiscreteSamples_+3A_skeletonlist">skeletonList</code></td>
<td>
<p>a piecewise deterministic skeleton (consisting of Times, Points and Velocities) returned by a sampler</p>
</td></tr>
<tr><td><code id="DiscreteSamples_+3A_n_samples">n_samples</code></td>
<td>
<p>number of samples to obtain</p>
</td></tr>
<tr><td><code id="DiscreteSamples_+3A_coordinate">coordinate</code></td>
<td>
<p>if specified, only obtain samples of the specified coordinate, otherwise obtain samples of all coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the extracted samples and the times (on the continuous time scale) at which the samples are extracted
</p>

<hr>
<h2 id='EstimateCovarianceMatrix'>EstimateCovarianceMatrix</h2><span id='topic+EstimateCovarianceMatrix'></span>

<h3>Description</h3>

<p>Estimates the covariance matrix of a piecewise deterministic skeleton
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EstimateCovarianceMatrix(skeletonList, coordinate = -1L,
  zeroMeans = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EstimateCovarianceMatrix_+3A_skeletonlist">skeletonList</code></td>
<td>
<p>a piecewise deterministic skeleton (consisting of Times, Points and Velocities) returned by a sampler</p>
</td></tr>
<tr><td><code id="EstimateCovarianceMatrix_+3A_coordinate">coordinate</code></td>
<td>
<p>if specified, only estimate the variance of the specified coordinate, otherwise estimate the covariance matrix of all coordinates</p>
</td></tr>
<tr><td><code id="EstimateCovarianceMatrix_+3A_zeromeans">zeroMeans</code></td>
<td>
<p>if TRUE do not estimate means but assume a centered distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the estimated moment
</p>

<hr>
<h2 id='EstimateESS'>EstimateESS</h2><span id='topic+EstimateESS'></span>

<h3>Description</h3>

<p>Estimates the effective sample size (ESS) of a piecewise deterministic skeleton
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EstimateESS(skeletonList, n_batches = 100L, coordinate = -1L,
  zeroMeans = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EstimateESS_+3A_skeletonlist">skeletonList</code></td>
<td>
<p>a piecewise deterministic skeleton (consisting of Times, Points and Velocities) returned by a sampler</p>
</td></tr>
<tr><td><code id="EstimateESS_+3A_n_batches">n_batches</code></td>
<td>
<p>optional argument indicating the number of batches to use in the batch means estimation method</p>
</td></tr>
<tr><td><code id="EstimateESS_+3A_coordinate">coordinate</code></td>
<td>
<p>if specified, only estimate the ESS of the specified coordinate, otherwise estimate the ESS of all coordinates</p>
</td></tr>
<tr><td><code id="EstimateESS_+3A_zeromeans">zeroMeans</code></td>
<td>
<p>if TRUE do not estimate means but assume a centered distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the estimated asymptotic variance, ESS and estimated covariance matrix
</p>

<hr>
<h2 id='EstimateMoment'>EstimateMoment</h2><span id='topic+EstimateMoment'></span>

<h3>Description</h3>

<p>Estimates the p-th moment of a piecewise deterministic skeleton
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EstimateMoment(skeletonList, p, coordinate = -1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EstimateMoment_+3A_skeletonlist">skeletonList</code></td>
<td>
<p>a piecewise deterministic skeleton (consisting of Times, Points and Velocities) returned by a sampler</p>
</td></tr>
<tr><td><code id="EstimateMoment_+3A_p">p</code></td>
<td>
<p>moment to estimate</p>
</td></tr>
<tr><td><code id="EstimateMoment_+3A_coordinate">coordinate</code></td>
<td>
<p>if specified, only estimate the ESS of the specified coordinate, otherwise estimate the ESS of all coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the estimated moment
</p>

<hr>
<h2 id='ZigZagGaussian'>ZigZagGaussian</h2><span id='topic+ZigZagGaussian'></span>

<h3>Description</h3>

<p>Applies the Zig-Zag Sampler to a Gaussian target distribution, as detailed in Bierkens, Fearnhead, Roberts, The Zig-Zag Process and Super-Efficient Sampling for Bayesian Analysis of Big Data, 2016.
Assume potential of the form </p>
<p style="text-align: center;"><code class="reqn">U(x) = (x - mu)^T V (x - mu)/2,</code>
</p>
<p> i.e. a Gaussian with mean vector <code>mu</code> and covariance matrix <code>inv(V)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZigZagGaussian(V, mu, n_iter = -1L, finalTime = -1, x0 = numeric(0),
  v0 = numeric(0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ZigZagGaussian_+3A_v">V</code></td>
<td>
<p>the inverse covariance matrix (or precision matrix) of the Gaussian target distribution.</p>
</td></tr>
<tr><td><code id="ZigZagGaussian_+3A_mu">mu</code></td>
<td>
<p>mean of the Gaussian target distribution</p>
</td></tr>
<tr><td><code id="ZigZagGaussian_+3A_n_iter">n_iter</code></td>
<td>
<p>Number of algorithm iterations; will result in the equivalent amount of skeleton points in Gaussian case because no rejections are needed.</p>
</td></tr>
<tr><td><code id="ZigZagGaussian_+3A_finaltime">finalTime</code></td>
<td>
<p>If provided and nonnegative, run the sampler until a trajectory of continuous time length finalTime is obtained (ignoring the value of <code>n_iterations</code>)</p>
</td></tr>
<tr><td><code id="ZigZagGaussian_+3A_x0">x0</code></td>
<td>
<p>starting point (optional, if not specified taken to be the origin)</p>
</td></tr>
<tr><td><code id="ZigZagGaussian_+3A_v0">v0</code></td>
<td>
<p>starting direction (optional, if not specified taken to be +1 in every component)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following objects:
</p>
<p><code>Times</code>: Vector of switching times
</p>
<p><code>Positions</code>: Matrix whose columns are locations of switches. The number of columns is identical to the length of <code>skeletonTimes</code>. Be aware that the skeleton points themselves are NOT samples from the target distribution.
</p>
<p><code>Velocities</code>: Matrix whose columns are velocities just after switches. The number of columns is identical to the length of <code>skeletonTimes</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>V &lt;- matrix(c(3,1,1,3),nrow=2)
mu &lt;- c(2,2)
result &lt;- ZigZagGaussian(V, mu, 100)
plot(result$Positions[1,], result$Positions[2,],type='l',asp=1)
</code></pre>

<hr>
<h2 id='ZigZagIIDGaussian'>ZigZagIIDGaussian</h2><span id='topic+ZigZagIIDGaussian'></span>

<h3>Description</h3>

<p>Applies the Zig-Zag Sampler to a IID Gaussian distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZigZagIIDGaussian(variance, dim = 1L, n_iter = -1L, finalTime = -1,
  x0 = numeric(0), v0 = numeric(0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ZigZagIIDGaussian_+3A_variance">variance</code></td>
<td>
<p>scalar indicating variance</p>
</td></tr>
<tr><td><code id="ZigZagIIDGaussian_+3A_dim">dim</code></td>
<td>
<p>dimension</p>
</td></tr>
<tr><td><code id="ZigZagIIDGaussian_+3A_n_iter">n_iter</code></td>
<td>
<p>Number of algorithm iterations; will result in the equivalent amount of skeleton points in Gaussian case because no rejections are needed.</p>
</td></tr>
<tr><td><code id="ZigZagIIDGaussian_+3A_finaltime">finalTime</code></td>
<td>
<p>If provided and nonnegative, run the sampler until a trajectory of continuous time length finalTime is obtained (ignoring the value of <code>n_iterations</code>)</p>
</td></tr>
<tr><td><code id="ZigZagIIDGaussian_+3A_x0">x0</code></td>
<td>
<p>starting point (optional, if not specified taken to be the origin)</p>
</td></tr>
<tr><td><code id="ZigZagIIDGaussian_+3A_v0">v0</code></td>
<td>
<p>starting direction (optional, if not specified taken to be +1 in every component)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following objects:
</p>
<p><code>Times</code>: Vector of switching times
</p>
<p><code>Positions</code>: Matrix whose columns are locations of switches. The number of columns is identical to the length of <code>skeletonTimes</code>. Be aware that the skeleton points themselves are NOT samples from the target distribution.
</p>
<p><code>Velocities</code>: Matrix whose columns are velocities just after switches. The number of columns is identical to the length of <code>skeletonTimes</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- ZigZagIIDGaussian(1, 2, 1000)
plot(result$Positions[2,], result$Positions[1,],type='l',asp=1)
</code></pre>

<hr>
<h2 id='ZigZagLogistic'>ZigZagLogistic</h2><span id='topic+ZigZagLogistic'></span>

<h3>Description</h3>

<p>Applies the Zig-Zag Sampler to logistic regression, as detailed in Bierkens, Fearnhead, Roberts, The Zig-Zag Process and Super-Efficient Sampling for Bayesian Analysis of Big Data, 2019.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZigZagLogistic(dataX, dataY, n_iter = -1L, finalTime = -1,
  x0 = numeric(0), v0 = numeric(0), cv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ZigZagLogistic_+3A_datax">dataX</code></td>
<td>
<p>Design matrix containing observations of the independent variables x. The i-th row represents the i-th observation with components x_i,1, ..., x_i,d.</p>
</td></tr>
<tr><td><code id="ZigZagLogistic_+3A_datay">dataY</code></td>
<td>
<p>Vector of length n containing 0, 1-valued observations of the dependent variable y.</p>
</td></tr>
<tr><td><code id="ZigZagLogistic_+3A_n_iter">n_iter</code></td>
<td>
<p>Number of algorithm iterations; will result in the equivalent amount of skeleton points in Gaussian case because no rejections are needed.</p>
</td></tr>
<tr><td><code id="ZigZagLogistic_+3A_finaltime">finalTime</code></td>
<td>
<p>If provided and nonnegative, run the sampler until a trajectory of continuous time length finalTime is obtained (ignoring the value of <code>n_iterations</code>)</p>
</td></tr>
<tr><td><code id="ZigZagLogistic_+3A_x0">x0</code></td>
<td>
<p>starting point (optional, if not specified taken to be the origin)</p>
</td></tr>
<tr><td><code id="ZigZagLogistic_+3A_v0">v0</code></td>
<td>
<p>starting direction (optional, if not specified taken to be +1 in every component)</p>
</td></tr>
<tr><td><code id="ZigZagLogistic_+3A_cv">cv</code></td>
<td>
<p>optional boolean to indicate the use of subsampling with control variates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following objects:
</p>
<p><code>Times</code>: Vector of switching times
</p>
<p><code>Positions</code>: Matrix whose columns are locations of switches. The number of columns is identical to the length of <code>skeletonTimes</code>. Be aware that the skeleton points themselves are NOT samples from the target distribution.
</p>
<p><code>Velocities</code>: Matrix whose columns are velocities just after switches. The number of columns is identical to the length of <code>skeletonTimes</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("RZigZag")

generate.logistic.data &lt;- function(beta, n.obs) {
  dim &lt;- length(beta)
  dataX &lt;- cbind(rep(1.0,n.obs), matrix(rnorm((dim -1) * n.obs), ncol = dim -1));
  vals &lt;- dataX %*% as.vector(beta)
    generateY &lt;- function(p) { rbinom(1, 1, p)}
  dataY &lt;- sapply(1/(1 + exp(-vals)), generateY)
    return(list(dataX = dataX, dataY = dataY))
}

beta &lt;- c(1,2)
data &lt;- generate.logistic.data(beta, 1000)
result &lt;- ZigZagLogistic(data$dataX, data$dataY, 1000)
plot(result$Positions[1,], result$Positions[2,],type='l',asp=1)
</code></pre>

<hr>
<h2 id='ZigZagStudentT'>ZigZagStudentT</h2><span id='topic+ZigZagStudentT'></span>

<h3>Description</h3>

<p>Applies the Zig-Zag Sampler to a Student T distribution (IID or spherically symmetric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZigZagStudentT(dof, dim = 1L, n_iter = -1L, finalTime = -1,
  x0 = numeric(0), v0 = numeric(0), sphericallySymmetric = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ZigZagStudentT_+3A_dof">dof</code></td>
<td>
<p>scalar indicating degrees of freedom</p>
</td></tr>
<tr><td><code id="ZigZagStudentT_+3A_dim">dim</code></td>
<td>
<p>dimension</p>
</td></tr>
<tr><td><code id="ZigZagStudentT_+3A_n_iter">n_iter</code></td>
<td>
<p>Number of algorithm iterations; will result in the equivalent amount of skeleton points in Gaussian case because no rejections are needed.</p>
</td></tr>
<tr><td><code id="ZigZagStudentT_+3A_finaltime">finalTime</code></td>
<td>
<p>If provided and nonnegative, run the sampler until a trajectory of continuous time length finalTime is obtained (ignoring the value of <code>n_iterations</code>)</p>
</td></tr>
<tr><td><code id="ZigZagStudentT_+3A_x0">x0</code></td>
<td>
<p>starting point (optional, if not specified taken to be the origin)</p>
</td></tr>
<tr><td><code id="ZigZagStudentT_+3A_v0">v0</code></td>
<td>
<p>starting direction (optional, if not specified taken to be +1 in every component)</p>
</td></tr>
<tr><td><code id="ZigZagStudentT_+3A_sphericallysymmetric">sphericallySymmetric</code></td>
<td>
<p>boolean. If false, sample iid Student T distribution, if true (default) sample spherically summetric Student t dsitribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following objects:
</p>
<p><code>Times</code>: Vector of switching times
</p>
<p><code>Positions</code>: Matrix whose columns are locations of switches. The number of columns is identical to the length of <code>skeletonTimes</code>. Be aware that the skeleton points themselves are NOT samples from the target distribution.
</p>
<p><code>Velocities</code>: Matrix whose columns are velocities just after switches. The number of columns is identical to the length of <code>skeletonTimes</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dim = 2
dof = 4
result &lt;- ZigZagStudentT(dof, dim, n_iter=1000, sphericallySymmetric = TRUE)
plot(result$Positions[1,], result$Positions[2,],type='l',asp=1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
