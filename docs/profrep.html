<!DOCTYPE html><html><head><title>Help for package profrep</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {profrep}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calculate_crossovers'><p>Calculate the Number of Crossovers</p></a></li>
<li><a href='#clean_data'><p>Clean Data by Interpolating Missing Values</p></a></li>
<li><a href='#do_ordering'><p>Score and Order Data</p></a></li>
<li><a href='#example_two_point_data'><p>Example Data: Two Point Data</p></a></li>
<li><a href='#find_next_good_datapoint'><p>What Is the Next Non-Null Data Point?</p></a></li>
<li><a href='#get_vars'><p>Calculate Group Variance</p></a></li>
<li><a href='#profrep'><p>Perform Profile Repeatability</p></a></li>
<li><a href='#retrieve_good_data'><p>Retrieve Indices of Non-Missing Data for a Specific Time Point</p></a></li>
<li><a href='#score_dfs'><p>Compute Profile Repeatability Score</p></a></li>
<li><a href='#score_individual_df'><p>Score an Individual Data Frame</p></a></li>
<li><a href='#sigmoid'><p>Calculates the sigmoid function of the input</p></a></li>
<li><a href='#sparrow_repeatability_three_point'><p>Example Data: Sparrow Repeatability (3 Point Data)</p></a></li>
<li><a href='#synthetic_data_four_point'><p>Example Data: Synthetic 4-Point Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Profile Repeatability</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates profile repeatability for replicate stress response 
  curves, or similar time-series data. Profile repeatability is an individual 
  repeatability metric that uses the variances at each timepoint, the maximum 
  variance, the number of crossings (lines that cross over each other), and 
  the number of replicates to compute the repeatability score. 
  For more information see Reed et al. (2019) &lt;<a href="https://doi.org/10.1016%2Fj.ygcen.2018.09.015">doi:10.1016/j.ygcen.2018.09.015</a>&gt;. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ubeattie.github.io/profrep/">https://ubeattie.github.io/profrep/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ubeattie/profrep/issues">https://github.com/ubeattie/profrep/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-01 20:50:46 UTC; cleanaccount</td>
</tr>
<tr>
<td>Author:</td>
<td>Ursula K. Beattie <a href="https://orcid.org/0000-0002-7131-3712"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut, cph],
  David Harris [aut, cph],
  L. Michael Romero <a href="https://orcid.org/0000-0002-8854-8884"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  J. Michael Reed <a href="https://orcid.org/0000-0002-3571-2652"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Zachary R. Weaver <a href="https://orcid.org/0000-0001-6314-0690"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ursula K. Beattie &lt;ursula.beattie@tufts.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-04 16:40:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='calculate_crossovers'>Calculate the Number of Crossovers</h2><span id='topic+calculate_crossovers'></span>

<h3>Description</h3>

<p>Calculate the Number of Crossovers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_crossovers(individual_df, n_trials, n_replicates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_crossovers_+3A_individual_df">individual_df</code></td>
<td>
<p>A data frame containing the individual dataset.</p>
</td></tr>
<tr><td><code id="calculate_crossovers_+3A_n_trials">n_trials</code></td>
<td>
<p>The total number of trials in the dataset (the number of rows)</p>
</td></tr>
<tr><td><code id="calculate_crossovers_+3A_n_replicates">n_replicates</code></td>
<td>
<p>The total number of replicates in each trial (the number of columns - 2)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the number of crossovers in a dataset by comparing
the values of replicates across multiple trials. It assumes that missing
values (NAs) have been interpolated using the <code>clean_data</code> function.
</p>


<h3>Value</h3>

<p>The number of crossovers detected in the dataset.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clean_data">clean_data</a></code> for information on data cleaning.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- matrix(
   c(
     1, 60, 1, 2, 3, 4, 5,   # No NA values
     1, 90, 9, NA, 4, NA, 2,  # NA Values in row
     1, 120, 3, 6, NA, NA, 9  # Consecutive NA values
    ),
    nrow = 3,
    byrow=TRUE
)
n_trials &lt;- nrow(data)
n_replicates &lt;- ncol(data) - 2
crossovers &lt;- calculate_crossovers(data, n_trials, n_replicates)
cat("Number of crossovers:", crossovers, "\n")

</code></pre>

<hr>
<h2 id='clean_data'>Clean Data by Interpolating Missing Values</h2><span id='topic+clean_data'></span>

<h3>Description</h3>

<p>Clean Data by Interpolating Missing Values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_data(data, n_trials, n_replicates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_data_+3A_data">data</code></td>
<td>
<p>A data frame containing the dataset to be cleaned.</p>
</td></tr>
<tr><td><code id="clean_data_+3A_n_trials">n_trials</code></td>
<td>
<p>The total number of rows in the dataset.</p>
</td></tr>
<tr><td><code id="clean_data_+3A_n_replicates">n_replicates</code></td>
<td>
<p>The total number of replicate columns in each row.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function cleans a dataset by interpolating missing values in the replicate
columns of each row using neighboring values. If the data frame ends in null values
(the last columns are nulls), it will extrapolate from the last value. If the
first value is null, it will loop around and pull from the last replicate to
perform the interpolation between the last replicate and the second replicate.
</p>


<h3>Value</h3>

<p>A cleaned data frame with missing values interpolated.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_next_good_datapoint">find_next_good_datapoint</a></code> for details on the interpolation process.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_data &lt;- matrix(
   c(
     1, 60, 1, 2, 3, 4, 5,   # No NA values
     1, 90, 9, NA, 4, NA, 2,  # NA Values in row
     1, 120, 3, 6, NA, NA, 9  # Consecutive NA values
    ),
    nrow = 3,
    byrow=TRUE
 )
cleaned_data &lt;- clean_data(my_data, n_trials = 3, n_replicates = 5)
print(my_data)
print(cleaned_data)

</code></pre>

<hr>
<h2 id='do_ordering'>Score and Order Data</h2><span id='topic+do_ordering'></span>

<h3>Description</h3>

<p>Score and Order Data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_ordering(
  n_trials,
  id_list,
  df_list,
  n_replicates,
  verbose = FALSE,
  sort = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_ordering_+3A_n_trials">n_trials</code></td>
<td>
<p>The number of rows an individual sample will have.</p>
</td></tr>
<tr><td><code id="do_ordering_+3A_id_list">id_list</code></td>
<td>
<p>The list of unique individual or sample names</p>
</td></tr>
<tr><td><code id="do_ordering_+3A_df_list">df_list</code></td>
<td>
<p>The list of data frames per unique individual</p>
</td></tr>
<tr><td><code id="do_ordering_+3A_n_replicates">n_replicates</code></td>
<td>
<p>The number of replicates in the study.</p>
</td></tr>
<tr><td><code id="do_ordering_+3A_verbose">verbose</code></td>
<td>
<p>A boolean parameter the defaults to FALSE. Determines whether messages are printed.</p>
</td></tr>
<tr><td><code id="do_ordering_+3A_sort">sort</code></td>
<td>
<p>A boolean parameter that defaults to TRUE. If TRUE, sorts the returned data frame by score. If FALSE, returns the data in the individual order it was provided in</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs the ordering of input data by scoring each individual data frame.
</p>
<p>The main function of the package, this will send each individuals data out
for scoring. Then, when all scores are computed, it will order the result
data frame by score and assign a rank.
</p>
<p>Ranks are assigned with ties allowed - if N individuals have a tie, their rank
is averaged. For example, if the max score is 1, and two individuals have
that score, their rank is 1.5
</p>


<h3>Value</h3>

<p>Returns a data frame of the results, in the following form:
</p>
<div class="sourceCode"><pre>     - Column 1: "individual" - the unique identifier of an individual or sample
     - Column 2: "n_crossings" - the calculated number of crossings.
     - Column 3: "max_variance" - the maximum of the variances of the replicate measurements at a single time for the individual or sample.
     - Column 4: "ave_variance" - the average of the variances of the replicate measurements at a single time for the individual or sample.
     - Column 5: "base_score" - the original, unnormalized profile repeatability score. Smaller numbers rank higher.
     - Column 6: "final_score" - the base score, normalized by the sigmoid function. Constrained to be between 0 and 1. Scores closer to 1 rank higher.
     - Column 7: "rank" - the calculated ranking of the individual or sample, against all other individuals or samples in the data set.
</pre></div>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
    col_a = c('A', 'A', 'B', 'B'),
    col_b = c(5, 15, 5, 15),
    col_c = c(5, 10, 1, 2),
    col_d = c(10, 15, 3, 4)
  )
id_list &lt;- unique(df[, 1])
individuals &lt;- list()
for (i in 1:length(id_list)) {
  individuals[[i]] &lt;- df[df[, 1] == id_list[i], ]
}
ret_df &lt;- do_ordering(n_trials=2, id_list=id_list, df_list=individuals, n_replicates=2)
print(ret_df)

</code></pre>

<hr>
<h2 id='example_two_point_data'>Example Data: Two Point Data</h2><span id='topic+example_two_point_data'></span>

<h3>Description</h3>

<p>An example of data that one would perform profile repeatability on.
Consists of 9 individual animals, with corticosterone data taken at 2 timepoints (n_trials = 2), baseline (time = 3) and stress-induced (time = 30).
Then, there are 28 replicate columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_two_point_data
</code></pre>


<h3>Format</h3>



<h4><code>example_two_point_data</code></h4>

<p>A dataframe with 10 rows and 30 columns:
</p>

<dl>
<dt>Animal</dt><dd><p>The animal name/unique identifier</p>
</dd>
<dt>Time</dt><dd><p>The time of the measurement, in days.</p>
</dd>
<dt>SD.DR</dt><dd><p>The name of the replicate column.</p>
</dd>
</dl>




<h3>Source</h3>

<p>This data was extracted from Romero &amp; Rich 2007 (Comp Biochem. Physiol. Part A Mol. Integr. Physiol. 147, 562-568. https://doi.org/10.1016/j.cbpa.2007.02.004)
</p>

<hr>
<h2 id='find_next_good_datapoint'>What Is the Next Non-Null Data Point?</h2><span id='topic+find_next_good_datapoint'></span>

<h3>Description</h3>

<p>What Is the Next Non-Null Data Point?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_next_good_datapoint(data_row, index, n_replicates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_next_good_datapoint_+3A_data_row">data_row</code></td>
<td>
<p>A numeric vector representing the data row.</p>
</td></tr>
<tr><td><code id="find_next_good_datapoint_+3A_index">index</code></td>
<td>
<p>The index of the current data point.</p>
</td></tr>
<tr><td><code id="find_next_good_datapoint_+3A_n_replicates">n_replicates</code></td>
<td>
<p>The total number of replicates (length of the row)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a data row, an index, and the number of replicates (the number of elements in the row),
this function finds the next good data point in the row.
</p>
<p>A good data point is a non-missing value (not NA) with a non-empty string.
</p>


<h3>Value</h3>

<p>The next good data point or -999 if none is found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_row &lt;- c(NA, 3, 2, NA, 5)
index &lt;- 1
n_replicates &lt;- 5
find_next_good_datapoint(data_row, index, n_replicates) # expect 3

</code></pre>

<hr>
<h2 id='get_vars'>Calculate Group Variance</h2><span id='topic+get_vars'></span>

<h3>Description</h3>

<p>Calculate Group Variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_vars(individual_array, n_replicates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_vars_+3A_individual_array">individual_array</code></td>
<td>
<p>The array of data for an individual</p>
</td></tr>
<tr><td><code id="get_vars_+3A_n_replicates">n_replicates</code></td>
<td>
<p>The number of replicate groups</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the given individual array, for all rows of times, computes the variance in values
over replicates.
</p>
<p>Returns these variances, sum of all values (for all times and replicates),
sum of all these values squared, and the number of values.
</p>


<h3>Value</h3>

<p>A list, where the elements are:
</p>
<div class="sourceCode"><pre>     1. variances: A vector of the variances of the sample
     2. total_sum: The sum of all the measurements in the sample
     3. ssq: The sum of all the squares of the measurements in the sample
     4. num_measurements: The total number of measurements in the sample that are not null
</pre></div>


<h3>Examples</h3>

<pre><code class='language-R'>arr &lt;- data.frame(
  individual=c("a", "a"),
  time=c(5, 15),
  col_a=c(1, 2),
  col_b=c(2, 3)
)
variance_return &lt;- get_vars(individual_array=arr, n_replicates=2)
print(variance_return)

</code></pre>

<hr>
<h2 id='profrep'>Perform Profile Repeatability</h2><span id='topic+profrep'></span>

<h3>Description</h3>

<p>Perform Profile Repeatability
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profrep(df, n_timepoints, sort = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profrep_+3A_df">df</code></td>
<td>
<p>The input data frame, of minimum shape 3 rows by 4 columns. This can be read in
from a csv or another data frame stored in memory. It is assumed
that the data frame is of the following structure:
Column 1 is the unique identifier of an individual animal or sample
Column 2 is the time of the sample
Column 3-N are the columns of replicate data.
Row 1 is assumed to be header strings for each column.</p>
</td></tr>
<tr><td><code id="profrep_+3A_n_timepoints">n_timepoints</code></td>
<td>
<p>The number of rows an individual sample will have. For example,
if the replicates were collected for individual 1 at times 15
and 30, for replicates A and B, the data frame would look like:
</p>
<div class="sourceCode"><pre>            | id | time | A | B |
            |:--:|:----:|:-:|:-:|
            | 1  | 15 | 1 | 2 |
            | 1  | 30 | 3 | 4 |
</pre></div></td></tr>
<tr><td><code id="profrep_+3A_sort">sort</code></td>
<td>
<p>A boolean parameter that defaults to TRUE. If TRUE, sorts the returned data frame by score. If FALSE, returns the data in the individual order in which it was provided.</p>
</td></tr>
<tr><td><code id="profrep_+3A_verbose">verbose</code></td>
<td>
<p>A boolean parameter that defaults to FALSE. Determines whether messages are printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the profile repeatability measure of the input data according to
the method in Reed et al., 2019, J. Gen. Comp. Endocrinol. (270).
</p>


<h3>Value</h3>

<p>Returns a data frame of the results, in the following form:
</p>

<ul>
<li><p> Column 1: &quot;individual&quot; - the unique identifier of an individual or sample
</p>
</li>
<li><p> Column 2: &quot;n_crossings&quot; - the calculated number of crossings.
</p>
</li>
<li><p> Column 3: &quot;max_variance&quot; - the maximum of the variances of the replicate measurements at a single time for the individual or sample.
</p>
</li>
<li><p> Column 4: &quot;ave_variance&quot; - the average of the variances of the replicate measurements at a single time for the individual or sample.
</p>
</li>
<li><p> Column 5: &quot;base_score&quot; - the original, unnormalized profile repeatability score. Smaller numbers rank higher.
</p>
</li>
<li><p> Column 6: &quot;final_score&quot; - the base score, normalized by the sigmoid function. Constrained to be between 0 and 1. Scores closer to 1 rank higher.
</p>
</li>
<li><p> Column 7: &quot;rank&quot; - the calculated ranking of the individual or sample, against all other individuals or samples in the data set.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+do_ordering">do_ordering</a></code> for the main data processing function.
</p>
<p><code><a href="#topic+calculate_crossovers">calculate_crossovers</a></code> for how the number of crossings are calculated.
</p>
<p><code><a href="#topic+score_individual_df">score_individual_df</a></code> for how the score is calculated for an individual or sample.
</p>
<p><code><a href="#topic+clean_data">clean_data</a></code> for how missing replicate values are handled.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_data &lt;- profrep::example_two_point_data
results &lt;- profrep::profrep(df=test_data, n_timepoints=2)
print(results)

</code></pre>

<hr>
<h2 id='retrieve_good_data'>Retrieve Indices of Non-Missing Data for a Specific Time Point</h2><span id='topic+retrieve_good_data'></span>

<h3>Description</h3>

<p>This function retrieves the indices of non-missing data values at a specific
time point from an individual array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retrieve_good_data(individual_array, t, n_replicates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="retrieve_good_data_+3A_individual_array">individual_array</code></td>
<td>
<p>A data matrix or data frame representing individual
data, where rows correspond to time points and columns correspond to
replicates and variables.</p>
</td></tr>
<tr><td><code id="retrieve_good_data_+3A_t">t</code></td>
<td>
<p>The time point for which you want to retrieve non-missing data
indices.</p>
</td></tr>
<tr><td><code id="retrieve_good_data_+3A_n_replicates">n_replicates</code></td>
<td>
<p>The number of replicates in the data matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the indices of non-missing data values
at the specified time point <code>t</code>. If there are no non-missing values or
only one non-missing value, <code>NULL</code> is returned.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+which">which</a></code> function for finding the indices of non-missing values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
individual_data &lt;- matrix(c(NA, 2, NA, 4, 5, NA), nrow = 1)
retrieve_good_data(individual_data, t = 1, n_replicates = 3)

</code></pre>

<hr>
<h2 id='score_dfs'>Compute Profile Repeatability Score</h2><span id='topic+score_dfs'></span>

<h3>Description</h3>

<p>Compute Profile Repeatability Score
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score_dfs(id_list, df_list, n_replicates, n_trials, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score_dfs_+3A_id_list">id_list</code></td>
<td>
<p>The list of the names of the individuals</p>
</td></tr>
<tr><td><code id="score_dfs_+3A_df_list">df_list</code></td>
<td>
<p>A list of data frames, each of which correspond to one of the names in the individual list</p>
</td></tr>
<tr><td><code id="score_dfs_+3A_n_replicates">n_replicates</code></td>
<td>
<p>The number of replicate columns (number of columns in a df in df_list)</p>
</td></tr>
<tr><td><code id="score_dfs_+3A_n_trials">n_trials</code></td>
<td>
<p>The number of trials per individual (number of rows in a df in df_list)</p>
</td></tr>
<tr><td><code id="score_dfs_+3A_verbose">verbose</code></td>
<td>
<p>A boolean parameter the defaults to FALSE. Determines whether messages are printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Works on multiple elements of data.
</p>
<p>Splits the data into the data frame for a particular individual from
the id_list, then calculates metrics to compute the profile repeatability
score. Returns a data frame with the individuals name and the score.
</p>


<h3>Value</h3>

<p>A dataframe of the calculated metrics. The column structure is as follows:
</p>
<div class="sourceCode"><pre>     - Column 1: "individual" - the unique identifier of an individual or sample
     - Column 2: "n_crossings" - the calculated number of crossings.
     - Column 3: "max_variance" - the maximum of the variances of the replicate measurements at a single time for the individual or sample.
     - Column 4: "ave_variance" - the average of the variances of the replicate measurements at a single time for the individual or sample.
     - Column 5: "base_score" - the original, unnormalized profile repeatability score. Smaller numbers rank higher.
     - Column 6: "final_score" - the base score, normalized by the sigmoid function. Constrained to be between 0 and 1. Scores closer to 1 rank higher.
</pre></div>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
    col_a = c('A', 'A', 'B', 'B'),
    col_b = c(5, 15, 5, 15),
    col_c = c(5, 10, 1, 2),
    col_d = c(10, 15, 3, 4)
  )
id_list &lt;- unique(df[, 1])
individuals &lt;- list()
for (i in 1:length(id_list)) {
  individuals[[i]] &lt;- df[df[, 1] == id_list[i], ]
}
ret_df &lt;- score_dfs(id_list=id_list, df_list=individuals, n_replicates=2, n_trials=2)
print(ret_df)

</code></pre>

<hr>
<h2 id='score_individual_df'>Score an Individual Data Frame</h2><span id='topic+score_individual_df'></span>

<h3>Description</h3>

<p>Score an Individual Data Frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score_individual_df(
  individual_df,
  n_trials,
  n_replicates,
  max_variance,
  variance_set
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score_individual_df_+3A_individual_df">individual_df</code></td>
<td>
<p>A data frame containing individual data.</p>
</td></tr>
<tr><td><code id="score_individual_df_+3A_n_trials">n_trials</code></td>
<td>
<p>The total number of trials in the data frame.</p>
</td></tr>
<tr><td><code id="score_individual_df_+3A_n_replicates">n_replicates</code></td>
<td>
<p>The total number of replicates in each trial.</p>
</td></tr>
<tr><td><code id="score_individual_df_+3A_max_variance">max_variance</code></td>
<td>
<p>The maximum allowed variance value.</p>
</td></tr>
<tr><td><code id="score_individual_df_+3A_variance_set">variance_set</code></td>
<td>
<p>A vector of variance values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates a score for an individual data frame based on various factors,
including the number of crossovers, maximum variance, and a set of variances.
</p>
<p>The score is computed as follows:
</p>

<ul>
<li><p> It factors in the number of crossovers using a scaling factor.
</p>
</li>
<li><p> It considers the maximum variance value in the variance set.
</p>
</li>
<li><p> It adds a component based on the average of variance values.
</p>
</li>
<li><p> It includes a scaled component of the number of crossovers.
</p>
</li></ul>



<h3>Value</h3>

<p>A list calculated for the individual data frame. Contains two values:
</p>

<ol>
<li><p> n_crossings: The number of crossover events in the data.
</p>
</li>
<li><p> base_score: The un-normalized profile repeatability score for the data.
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+calculate_crossovers">calculate_crossovers</a></code> for information on crossovers calculation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arr &lt;- data.frame(
  individual=c("a", "a"),
  time=c(5, 15),
  col_a=c(1, 2),
  col_b=c(2, 3)
)
variance_set &lt;- c(0.5, 0.5)
max_variance &lt;- 0.5
score_list &lt;- score_individual_df(
  individual_df=arr,
  n_trials=2,
  n_replicates=2,
  max_variance=max_variance,
  variance_set=variance_set
)
print(score_list)

</code></pre>

<hr>
<h2 id='sigmoid'>Calculates the sigmoid function of the input</h2><span id='topic+sigmoid'></span>

<h3>Description</h3>

<p>Calculates the sigmoid function of the input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigmoid(float)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigmoid_+3A_float">float</code></td>
<td>
<p>A float number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A float number which is the result of the sigmoid function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sigmoid(0)
sigmoid(2)

</code></pre>

<hr>
<h2 id='sparrow_repeatability_three_point'>Example Data: Sparrow Repeatability (3 Point Data)</h2><span id='topic+sparrow_repeatability_three_point'></span>

<h3>Description</h3>

<p>An example of data that one would perform profile repeatability on.
Consists of 12 individual animals, with corticosterone data taken at 3 times (n_trials = 3), baseline (time = 0) and two stress-induced (time = 15 and 30).
Then, there are 10 replicate columns. This example also shows what happens
when there are null data records for some individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparrow_repeatability_three_point
</code></pre>


<h3>Format</h3>



<h4><code>sparrow_repeatability_three_point</code></h4>

<p>A dataframe with 36 rows and 12 columns:
</p>

<dl>
<dt>Animal</dt><dd><p>The animal name/unique identifier</p>
</dd>
<dt>TIME</dt><dd><p>The time of the measurement, in days</p>
</dd>
<dt>LD.500</dt><dd><p>The name of the replicate column</p>
</dd>
</dl>




<h3>Source</h3>

<p>This data was extracted from Rich &amp; Romero 2001 (J. Comp. Physiol. Part B Biochem. Syst. Environ. Physiol. 171, 543-647. https://doi.org/10.1007/s003600100204)
</p>

<hr>
<h2 id='synthetic_data_four_point'>Example Data: Synthetic 4-Point Data</h2><span id='topic+synthetic_data_four_point'></span>

<h3>Description</h3>

<p>An example of data that one would perform profile repeatability on.
The data is synthetic data created for testing purposes and is designed to span a range of perceived repeatability scores.
Consists of 11 individual animals, with data taken at 4 times (n_trials = 4), baseline (time = 0) and three stress-induced (time = 15, 30, and 45).
Then, there are four replicate columns. Replicate column names refer to
sample tests performed on the animal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synthetic_data_four_point
</code></pre>


<h3>Format</h3>



<h4><code>synthetic_data_four_point</code></h4>

<p>A dataframe with 44 rows and 6 columns:
</p>

<dl>
<dt>Animal</dt><dd><p>The animal name/unique identifier</p>
</dd>
<dt>TIME</dt><dd><p>The time of the measurement (unit not important)</p>
</dd>
<dt>A</dt><dd><p>The (unimportant) name of a replicate column.</p>
</dd>
<dt>B</dt><dd><p>The (unimportant) name of a replicate column.</p>
</dd>
<dt>C</dt><dd><p>The (unimportant) name of a replicate column.</p>
</dd>
<dt>D</dt><dd><p>The (unimportant) name of a replicate column.</p>
</dd>
</dl>




<h3>Source</h3>

<p>Data created for testing purposes by Reed et al., 2019 (Gen. Comp. Endocrinol. 270, 1-9. https://doi.org/10.1016/j.ygcen.2018.09.015)
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
