<!DOCTYPE html><html><head><title>Help for package proftools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {proftools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rgl-package'><p>Tools for examining R profile output</p></a></li>
<li><a href='#annotateSource'><p> Annotate Source Files</p></a></li>
<li><a href='#callTreeGraphs'><p> Call Tree Graphs</p></a></li>
<li><a href='#filterProfileData'><p> Filter Profile Data</p></a></li>
<li><a href='#flatProfile'><p>Flat Profile for Rprof Profile Data</p></a></li>
<li><a href='#hotPaths'><p> Hot Paths in Profile Data</p></a></li>
<li><a href='#plot.proftools_profData'><p>Plot Profile Data</p></a></li>
<li><a href='#plotProfileCallGraph'><p> Plot Call Graph for Rprof Profile Data</p></a></li>
<li><a href='#printProfileCallGraph'><p> Print Call Graph for Rprof Profile Data</p></a></li>
<li><a href='#profileCallGraph2Dot'><p> Write Call Graph for Rprof Profile Data to Graphviz Dot File</p></a></li>
<li><a href='#profileExpr'><p> Read Rprof Profile Data</p></a></li>
<li><a href='#readProfileData'><p> Read Rprof Profile Data</p></a></li>
<li><a href='#styles'><p>Style Specifications for Call Graphs</p></a></li>
<li><a href='#summaries'><p>Basic Profile Data Summaries</p></a></li>
<li><a href='#utils'><p>Profile Data Utilities</p></a></li>
<li><a href='#writeCallgrindFile'><p> Write Out Profile Data in Callgrind Format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Profile Output Processing Tools for R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.99-3</td>
</tr>
<tr>
<td>Author:</td>
<td>Luke Tierney and Riad Jarjour</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for examining Rprof profile output.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luke Tierney &lt;luke-tierney@uiowa.edu&gt;</td>
</tr>
<tr>
<td>Suggests:</td>
<td>graph,Rgraphviz,boot,knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-07-07 20:17:11 UTC; luke</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-07-08 06:20:23 UTC</td>
</tr>
</table>
<hr>
<h2 id='rgl-package'>Tools for examining R profile output</h2><span id='topic+proftools-package'></span><span id='topic+proftools'></span>

<h3>Description</h3>

<p>Tools for examining and displaying ouptut from the <code>Rprof</code> R
profiling tool.
</p>


<h3>Details</h3>

<p><span class="pkg">proftools</span> provides a set of tools for summarizing and displaying
time profile outpus produced by R's <code><a href="utils.html#topic+Rprof">Rprof</a></code>.
</p>
<p>The starting point for a profiling analysis using <span class="pkg">proftools</span> is
to profile code using <code><a href="utils.html#topic+Rprof">Rprof</a></code> and then use
<code><a href="#topic+readProfileData">readProfileData</a></code> to read in the profile data into a
sutable format for furhter processing. An alternative is to use the
<code><a href="#topic+profileExpr">profileExpr</a></code> function to handle profiling and reading in
one step. The function <code><a href="#topic+filterProfileData">filterProfileData</a></code> can be used to
narrow the profile data to particular regions of interest.
</p>
<p>The summary functions <code><a href="#topic+funSummary">funSummary</a></code> and
<code><a href="#topic+callSummary">callSummary</a></code> produce summaries at the function and call
level. <code><a href="#topic+pathSummary">pathSummary</a></code> produces a summary for each unique
call stack, or path; and <code><a href="#topic+hotPaths">hotPaths</a></code> identifies produces
path data ordered to show the hottest paths first.
</p>
<p>If source information is recorded when profiling then
<code><a href="#topic+srcSummary">srcSummary</a></code> to show profiling by source lines, and
<code><a href="#topic+annotateSource">annotateSource</a></code> produces an annotated version of the
source files.
</p>
<p>The <code><a href="graphics.html#topic+plot">plot</a></code> method for profile data objects can produce
call graphs, tree maps, flame graphs, and time graphs; the
<code>type</code> argument choses the particular visualization to
produce. These graphs can also be produced by the functions
<code><a href="#topic+plotProfileCallGraph">plotProfileCallGraph</a></code>, <code><a href="#topic+calleeTreeMap">calleeTreeMap</a></code>, and
<code><a href="#topic+flameGraph">flameGraph</a></code>.
</p>
<p>The function <code><a href="#topic+writeCallgrindFile">writeCallgrindFile</a></code> writes a file for use
by the codekcachegrind program available on some operating
systems.
</p>
<p><code><a href="#topic+flatProfile">flatProfile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pd &lt;- readProfileData(system.file("samples", "glmEx.out", package="proftools"))
funSummary(pd)
callSummary(pd)
pathSummary(pd)
hotPaths(pd)
plot(pd)
plot(filterProfileData(pd, focus = "glm", self.pct=1, total.pct=10))
</code></pre>

<hr>
<h2 id='annotateSource'> Annotate Source Files </h2><span id='topic+annotateSource'></span>

<h3>Description</h3>

<p>Annotates source files with profile information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotateSource(pd, value = c("pct", "time", "hits"), GC = TRUE,
               sep = ":  ", show = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotateSource_+3A_pd">pd</code></td>
<td>
<p>profile data as returned by <code>readProfileData</code>.</p>
</td></tr>
<tr><td><code id="annotateSource_+3A_value">value</code></td>
<td>
<p>character; show result as percentage, time, or hits.</p>
</td></tr>
<tr><td><code id="annotateSource_+3A_gc">GC</code></td>
<td>
<p>logical; include GC information or not.</p>
</td></tr>
<tr><td><code id="annotateSource_+3A_sep">sep</code></td>
<td>
<p>character; separator between profile info and source
lines.</p>
</td></tr>
<tr><td><code id="annotateSource_+3A_show">show</code></td>
<td>
<p>logical; if true, show files with <code>file.show</code>.</p>
</td></tr>
<tr><td><code id="annotateSource_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>file.show</code>.</p>
</td></tr>	   
</table>


<h3>Details</h3>

<p>For lines that appear in the stack trace the percent time and,
optionally, GC time are shown before each line.
</p>


<h3>Value</h3>

<p>A list of character vectors of the annotated file lines.</p>


<h3>Author(s)</h3>

<p> Luke Tierney </p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+Rprof">Rprof</a></code>,
<code><a href="utils.html#topic+summaryRprof">summaryRprof</a></code>,
<code><a href="#topic+flatProfile">flatProfile</a></code>,
<code><a href="#topic+filterProfileData">filterProfileData</a></code>,
<code><a href="#topic+readProfileData">readProfileData</a></code>,
<code><a href="#topic+srcSummary">srcSummary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This defines the function rw()
source(system.file("samples", "rw.R", package="proftools"))

## Execute the function and collect profile data
Rprof(tmp &lt;- tempfile(), gc.profiling = TRUE, line.profiling = TRUE)
w &lt;- rw(200000)
Rprof(NULL)
pd &lt;- readProfileData(tmp)
unlink(tmp)

## Annotate the sources
annotateSource(pd)
</code></pre>

<hr>
<h2 id='callTreeGraphs'> Call Tree Graphs </h2><span id='topic+flameGraph'></span><span id='topic+calleeTreeMap'></span><span id='topic+identify.proftools_calleeTreeMap'></span><span id='topic+identify.proftools_flameGraph'></span>

<h3>Description</h3>

<p>Produce a flame graph or a callee tree map for the call tree in a profile
stack trace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flameGraph(pd, svgfile, order = c("hot", "alpha", "time"),
           colormap = NULL, srclines = FALSE, cex = 0.75,
           main = "Call Graph", tooltip = FALSE)

calleeTreeMap(pd, srclines = FALSE, cex = 0.75, colormap = NULL,
              main = "Callee Tree Map", squarify = FALSE, border = NULL)

## S3 method for class 'proftools_calleeTreeMap'
identify(x, n = 1, print = FALSE, ...)

## S3 method for class 'proftools_flameGraph'
identify(x, n = 1, print = FALSE,
                                        outline = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="callTreeGraphs_+3A_pd">pd</code></td>
<td>
<p>profile data as returned by <code>readProfileData</code>.</p>
</td></tr>
<tr><td><code id="callTreeGraphs_+3A_svgfile">svgfile</code></td>
<td>
<p>character; name for SVG output file.</p>
</td></tr>
<tr><td><code id="callTreeGraphs_+3A_order">order</code></td>
<td>
<p>character; see details below.</p>
</td></tr>
<tr><td><code id="callTreeGraphs_+3A_colormap">colormap</code></td>
<td>
<p>a function or <code>NULL</code>; see details below.</p>
</td></tr>
<tr><td><code id="callTreeGraphs_+3A_srclines">srclines</code></td>
<td>
<p>logical; include source information, if available, or not.</p>
</td></tr>
<tr><td><code id="callTreeGraphs_+3A_cex">cex</code></td>
<td>
<p>numeric character expansion value.</p>
</td></tr>
<tr><td><code id="callTreeGraphs_+3A_main">main</code></td>
<td>
<p>character; plot title.</p>
</td></tr>
<tr><td><code id="callTreeGraphs_+3A_tooltip">tooltip</code></td>
<td>
<p>logical; whether SVG should show details in tooltips.</p>
</td></tr>
<tr><td><code id="callTreeGraphs_+3A_border">border</code></td>
<td>
<p>character or <code>NULL</code>; border color for rectangles.</p>
</td></tr>
<tr><td><code id="callTreeGraphs_+3A_squarify">squarify</code></td>
<td>
<p>logical; whether the squarified tiling algorithm should
be used.</p>
</td></tr>
<tr><td><code id="callTreeGraphs_+3A_x">x</code></td>
<td>
<p><code>flameGraph</code> of <code>calleeTreeMap</code> object to use.</p>
</td></tr>
<tr><td><code id="callTreeGraphs_+3A_n">n</code></td>
<td>
<p>integer; number of items to identify.</p>
</td></tr>
<tr><td><code id="callTreeGraphs_+3A_print">print</code></td>
<td>
<p>logical; whether to print result on each click.</p>
</td></tr>
<tr><td><code id="callTreeGraphs_+3A_outline">outline</code></td>
<td>
<p>logical; whether to outline rectangles corresponding to
identified call.</p>
</td></tr>
<tr><td><code id="callTreeGraphs_+3A_...">...</code></td>
<td>
<p>Further arguments for the identify methods; currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>calleeTreeMap</code> shows a tree map of the calls in a stack trace's
call tree. The tiling algorithm used depends on the <code>squarify</code>
argument.  If <code>squarify</code> is <code>TRUE</code> then the
<em>squarified</em> algorithm is used; otherwise, the longer side is
partitioned.
</p>
<p><code>flameGraph</code> produces a <em>flame graph</em> of the call tree. The
vertical positions of rectangles represent call depth on the
stack. The widths of the rectangles represent the amount of time spent
in a call at a particular call or set of calls at a particular depth.
The <code>order</code> argument determines the ordering of call rectangles
at a particular level within a call at the lower level. The
<code>"alpha"</code> ordering orders the calls alphabetically; <code>"hot"</code>
uses the hot path ordering with the call with the largest amount of
time first. The <code>"time"</code> ordering preserves the original time
ordering within the stack trace file.
</p>
<p>Default colors are based on the <code>rainbow</code> palette. Alternative
colors can be specified by a <code>colormap</code> function. This function
is called with three argument vectors, with one element for each
rectangle. The arguments are the function name, call depth, and number
of hits.
</p>
<p>The results returned by <code>flameGraph</code> and <code>calleeTreeMap</code> can
be passed to <code>identify</code>. The <code>identify</code> method for
<code>calleeTreeMap</code> returns a list of the call stacks for the
identified rectangles. The <code>identify</code> method for <code>flameGraph</code>
returns a character vector of the labels of the identified rectangles.
</p>


<h3>Value</h3>

<p>Objects that can be used with <code>identify</code>.</p>


<h3>Author(s)</h3>

<p> Luke Tierney </p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+Rprof">Rprof</a></code>,
<code><a href="utils.html#topic+summaryRprof">summaryRprof</a></code>,
<code><a href="#topic+flatProfile">flatProfile</a></code>,
<code><a href="#topic+filterProfileData">filterProfileData</a></code>,
<code><a href="#topic+readProfileData">readProfileData</a></code>,
<code><a href="#topic+plotProfileCallGraph">plotProfileCallGraph</a></code>,
<code><a href="#topic+profileCallGraph2Dot">profileCallGraph2Dot</a></code>,
<code><a href="#topic+hotPaths">hotPaths</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pd &lt;- readProfileData(system.file("samples", "glmEx.out", package="proftools"))
flameGraph(pd)
calleeTreeMap(pd)
</code></pre>

<hr>
<h2 id='filterProfileData'> Filter Profile Data </h2><span id='topic+filterProfileData'></span>

<h3>Description</h3>

<p>Allow profile data to be filtered on several criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterProfileData(pd, ..., normalize = FALSE, regex = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterProfileData_+3A_pd">pd</code></td>
<td>
<p>profile data as returned by <code>readProfileData</code>.</p>
</td></tr>
<tr><td><code id="filterProfileData_+3A_...">...</code></td>
<td>
<p>filter specifications is <code>filter = value</code> form as
described below.</p>
</td></tr>
<tr><td><code id="filterProfileData_+3A_normalize">normalize</code></td>
<td>
<p>logical; if true the total hit count is set to the
total number of hits in the reduced profile data; otherwise the
original value is retained.</p>
</td></tr>
<tr><td><code id="filterProfileData_+3A_regex">regex</code></td>
<td>
<p>logical; if true the specifications in <code>select</code>, and
<code>omit</code>, and <code>focus</code> filters are treated as regular
expressions; otherwise exact matches are required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to make plots and summaries more readable or
relevant by removing functions that are not of direct interest or have
low hit counts.
</p>
<p>Filters are specified in <code>filter = value</code> form with <code>value</code>
typically specifying a filter level or argument. Possible filters and
their argument values are:
</p>

<dl>
<dt><code>select</code></dt><dd><p>character vector specifying names of functions;
call stacks not containing functions matching any of these names
are dropped.</p>
</dd>
<dt><code>omit</code></dt><dd><p>character vector specifying names of functions; call
stacks containing functions matching any of these names are dropped.</p>
</dd>
<dt><code>focus</code></dt><dd><p>character vector specifying names of functions; call
stacks not containing functions matching any of these names are
dropped, and functions at the bottom of the stack not matching the
<code>focus</code> specification are dropped.</p>
</dd>
<dt><code>skip</code></dt><dd><p>integer; the number of elements to trim from the
bottom of the stacks.</p>
</dd>
<dt><code>maxdepth</code></dt><dd><p>integer; stacks are truncated to have at most
<code>maxdepth</code> elements.</p>
</dd>
<dt><code>self.pct</code></dt><dd><p>numeric; functions at the bottom of the
stacks with self percentages below this value are removed.</p>
</dd>
<dt><code>total.pct</code></dt><dd><p>numeric; functions at the top of the stacks with
total percentages below this value are removed.</p>
</dd>
<dt><code>interval</code></dt><dd><p>inter vector of length 2 specifying first and last
sample to use.</p>
</dd>
<dt><code>merge.pct</code></dt><dd><p>numeric; functions at the top of the stacks
are removed and stack traces merged until each retained trace accounts
for at least this percentage of run time.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A reduced profile data structure.</p>


<h3>Author(s)</h3>

<p> Luke Tierney </p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+Rprof">Rprof</a></code>,
<code><a href="utils.html#topic+summaryRprof">summaryRprof</a></code>,
<code><a href="#topic+flatProfile">flatProfile</a></code>,
<code><a href="#topic+readProfileData">readProfileData</a></code>,
<code><a href="#topic+plotProfileCallGraph">plotProfileCallGraph</a></code>,
<code><a href="#topic+profileCallGraph2Dot">profileCallGraph2Dot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pd &lt;- readProfileData(system.file("samples", "glmEx.out", package="proftools"))
plotProfileCallGraph(pd)
plotProfileCallGraph(filterProfileData(pd, self.pct = 1))
plotProfileCallGraph(filterProfileData(pd, self.pct = 1, total.pct = 10))
plotProfileCallGraph(filterProfileData(pd, select = "glm", self.pct=1,
                                       total.pct=10))
</code></pre>

<hr>
<h2 id='flatProfile'>Flat Profile for Rprof Profile Data</h2><span id='topic+flatProfile'></span>

<h3>Description</h3>

<p>Computes a flat profile reflecting time spent in functions themselves
(self) and functions plus callees (total).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatProfile(pd, byTotal = TRUE, GC = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flatProfile_+3A_pd">pd</code></td>
<td>
<p>profile data as returned by <code>readProfileData</code>.</p>
</td></tr>
<tr><td><code id="flatProfile_+3A_bytotal">byTotal</code></td>
<td>
<p>logical; sort by total time if true, self time if not. </p>
</td></tr>
<tr><td><code id="flatProfile_+3A_gc">GC</code></td>
<td>
<p>logical; include GC information or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>byTotal</code> is true then the result is analogous to the
<code>by.total</code> component of the result returned by <code>summaryRprof</code>.
Otherwise, the result is analogous to the <code>by.self</code> component
returned by <code>summaryRprof</code> but with an additional cumulative 
self times column.  The result returned when <code>byTotal</code> is not true
is analogous to the flat profile produced by <code>gprof</code>.
</p>


<h3>Value</h3>

<p>A matrix with one row per function recorded in the profile data.
</p>


<h3>Author(s)</h3>

<p> Luke Tierney </p>


<h3>References</h3>

<p> User manual for <code>gprof</code>, the GNU profiler. </p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+Rprof">Rprof</a></code>,
<code><a href="utils.html#topic+summaryRprof">summaryRprof</a></code>,
<code><a href="#topic+readProfileData">readProfileData</a></code>,
<code><a href="#topic+plotProfileCallGraph">plotProfileCallGraph</a></code>,
<code><a href="#topic+printProfileCallGraph">printProfileCallGraph</a></code>,
<code><a href="#topic+profileCallGraph2Dot">profileCallGraph2Dot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pd &lt;- readProfileData(system.file("samples", "glmEx.out", package="proftools"))
flatProfile(pd)
flatProfile(pd, FALSE)
</code></pre>

<hr>
<h2 id='hotPaths'> Hot Paths in Profile Data </h2><span id='topic+hotPaths'></span>

<h3>Description</h3>

<p>Computes and displays hot paths in profiling data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hotPaths(pd, value = c("pct", "time", "hits"), self = TRUE,
         srclines = TRUE, GC = FALSE, memory = FALSE, maxdepth = 10,
         self.pct = 0, total.pct = 0, short = ". ", nlines = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hotPaths_+3A_pd">pd</code></td>
<td>
<p>profile data as returned by <code>readProfileData</code>.</p>
</td></tr>
<tr><td><code id="hotPaths_+3A_value">value</code></td>
<td>
<p>character; show result as percentage, time, or hits.</p>
</td></tr>
<tr><td><code id="hotPaths_+3A_self">self</code></td>
<td>
<p>logical; include self time for each stack in the result.</p>
</td></tr>
<tr><td><code id="hotPaths_+3A_srclines">srclines</code></td>
<td>
<p>logical; include source information, if available, or not.</p>
</td></tr>
<tr><td><code id="hotPaths_+3A_gc">GC</code></td>
<td>
<p>logical; include GC information or not.</p>
</td></tr>
<tr><td><code id="hotPaths_+3A_memory">memory</code></td>
<td>
<p>logical; include memory use information or not.</p>
</td></tr>
<tr><td><code id="hotPaths_+3A_maxdepth">maxdepth</code></td>
<td>
<p>integer; stacks are truncated to have at most
<code>maxdepth</code> elements.</p>
</td></tr>
<tr><td><code id="hotPaths_+3A_self.pct">self.pct</code></td>
<td>
<p>numeric; stacks with self percent values below this
level are dropped.</p>
</td></tr>
<tr><td><code id="hotPaths_+3A_total.pct">total.pct</code></td>
<td>
<p>numeric; stacks with total percent values below this
level are dropped.</p>
</td></tr>
<tr><td><code id="hotPaths_+3A_short">short</code></td>
<td>
<p>character; abbreviation to be used for functions lower on
the stack.</p>
</td></tr>
<tr><td><code id="hotPaths_+3A_nlines">nlines</code></td>
<td>
<p>integer; number of lines to show. The lines shown are
the ones with the highest total percentage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hot path ordering sorts stacks in the profile data first by the
frequency with which the bottom functions on the stack are called, with
highest frequency first, then within each bottom function by the
frequency of the bottom two, and so on. Examining the result of
<code>hotPaths</code> starting with low values of <code>maxdepth</code> and then
moving to higher levels is a useful way to expore where the
computational effort is concentrated.
</p>


<h3>Value</h3>

<p>A data frame designed to produce a useful printed result.</p>


<h3>Author(s)</h3>

<p> Luke Tierney </p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+Rprof">Rprof</a></code>,
<code><a href="utils.html#topic+summaryRprof">summaryRprof</a></code>,
<code><a href="#topic+flatProfile">flatProfile</a></code>,
<code><a href="#topic+filterProfileData">filterProfileData</a></code>,
<code><a href="#topic+readProfileData">readProfileData</a></code>,
<code><a href="#topic+plotProfileCallGraph">plotProfileCallGraph</a></code>,
<code><a href="#topic+profileCallGraph2Dot">profileCallGraph2Dot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pd &lt;- readProfileData(system.file("samples", "glmEx.out", package="proftools"))
hotPaths(pd)
hotPaths(pd, maxdepth = 8)
</code></pre>

<hr>
<h2 id='plot.proftools_profData'>Plot Profile Data</h2><span id='topic+plot.proftools_profData'></span>

<h3>Description</h3>

<p>Plot method for objects of class <code>"proftools_profData"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'proftools_profData'
plot(x, type = c("call", "tree", "flame", "time"),
                                  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.proftools_profData_+3A_x">x</code></td>
<td>
<p>an object of class <code>"proftools_profData"</code>.</p>
</td></tr>
<tr><td><code id="plot.proftools_profData_+3A_type">type</code></td>
<td>
<p>the type of plot to be drawn; default is a call graph.</p>
</td></tr>
<tr><td><code id="plot.proftools_profData_+3A_...">...</code></td>
<td>
<p>additional arguments for specific plot types.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the <code>type</code> argument the profile data <code>plot</code>
method calls <code>link{plotProfileCallGraph}</code>,
<code><a href="#topic+calleeTreeMap">calleeTreeMap</a></code>, or <code><a href="#topic+flameGraph">flameGraph</a></code> with
<code>order = "hot"</code> or <code>orter = "time"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotProfileCallGraph">plotProfileCallGraph</a></code>,
<code><a href="#topic+calleeTreeMap">calleeTreeMap</a></code>, <code><a href="#topic+flameGraph">flameGraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pd &lt;- readProfileData(system.file("samples", "glmEx.out", package="proftools"))
plot(pd)
plot(pd, style = plain.style)
plot(pd, type = "call")
plot(pd, type = "flame")
</code></pre>

<hr>
<h2 id='plotProfileCallGraph'> Plot Call Graph for Rprof Profile Data </h2><span id='topic+plotProfileCallGraph'></span>

<h3>Description</h3>

<p>Uses the <span class="pkg">graph</span> and <span class="pkg">Rgraphviz</span> packages to plot a call graph for
profile data produced by <code>Rprof</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotProfileCallGraph(pd, layout = "dot",
                     score = c("none", "total", "self"),
                     transfer = function(x) x, nodeColorMap = NULL,
                     edgeColorMap = NULL, mergeCycles = FALSE,
                     edgesColored = FALSE, rankDir = c("TB", "LR"),
                     nodeDetails = FALSE, edgeDetails = FALSE,
                     nodeSizeScore = c("none", "total", "self"),
                     edgeSizeScore = c("none", "total"),
                     shape = "ellipse", style, GC = TRUE,
                     maxnodes = NA, total.pct = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotProfileCallGraph_+3A_pd">pd</code></td>
<td>
<p>profile data as returned by <code>readProfileData</code>.</p>
</td></tr>
<tr><td><code id="plotProfileCallGraph_+3A_layout">layout</code></td>
<td>
<p>The layout method to use: One of <code>"dot"</code>,
<code>"neato"</code>, and <code>"twopi"</code>.</p>
</td></tr>
<tr><td><code id="plotProfileCallGraph_+3A_score">score</code></td>
<td>
<p> character string specifying whether to use total time
or self time for coloring nodes/edges; no color used if
missing. </p>
</td></tr>
<tr><td><code id="plotProfileCallGraph_+3A_transfer">transfer</code></td>
<td>
<p> function; maps score values in unit interval to unit
interval </p>
</td></tr>
<tr><td><code id="plotProfileCallGraph_+3A_nodecolormap">nodeColorMap</code>, <code id="plotProfileCallGraph_+3A_edgecolormap">edgeColorMap</code></td>
<td>
<p> character vectors of color
specifications as produced by <code>rainbow</code>; <code>transfer</code> of
score is mapped to color </p>
</td></tr>
<tr><td><code id="plotProfileCallGraph_+3A_mergecycles">mergeCycles</code></td>
<td>
<p> logical; whether to merge each cycle of recursion into
a single node </p>
</td></tr>
<tr><td><code id="plotProfileCallGraph_+3A_edgescolored">edgesColored</code></td>
<td>
<p> logical; whether to color edges </p>
</td></tr>
<tr><td><code id="plotProfileCallGraph_+3A_rankdir">rankDir</code></td>
<td>
<p> The direction that the plot is laid out in, one of
either <code>"TB"</code> for Top-to-Bottom or <code>"LR"</code> for
Left-to-Right.  The default value is <code>"LR"</code>.  This
argument is only useful for <code>dot</code> layouts.</p>
</td></tr>
<tr><td><code id="plotProfileCallGraph_+3A_nodedetails">nodeDetails</code>, <code id="plotProfileCallGraph_+3A_edgedetails">edgeDetails</code></td>
<td>
<p>logical; whether count information
should be shown.</p>
</td></tr>
<tr><td><code id="plotProfileCallGraph_+3A_nodesizescore">nodeSizeScore</code></td>
<td>
<p>character; value to encode in the size of the nodes.</p>
</td></tr>
<tr><td><code id="plotProfileCallGraph_+3A_edgesizescore">edgeSizeScore</code></td>
<td>
<p>character; value to encode in the width of the edges.</p>
</td></tr>
<tr><td><code id="plotProfileCallGraph_+3A_shape">shape</code></td>
<td>
<p> character; node shape.</p>
</td></tr>
<tr><td><code id="plotProfileCallGraph_+3A_style">style</code></td>
<td>
<p>named list of values for arguments <code>score</code> through
<code>layout</code> to use if not explicitly supplied.</p>
</td></tr>
<tr><td><code id="plotProfileCallGraph_+3A_...">...</code></td>
<td>
<p> additional arguments for the <code>graphNEL</code> <code>plot</code>
method.</p>
</td></tr>
<tr><td><code id="plotProfileCallGraph_+3A_gc">GC</code></td>
<td>
<p>logical; include GC information or not.</p>
</td></tr>
<tr><td><code id="plotProfileCallGraph_+3A_maxnodes">maxnodes</code></td>
<td>
<p>integer; maximal number of nodes to use; nodes with
lower total hit counts are dropped.</p>
</td></tr>
<tr><td><code id="plotProfileCallGraph_+3A_total.pct">total.pct</code></td>
<td>
<p>numeric; if positive, nodes with hit percentages
below this level are dropped.</p>
</td></tr>	      
</table>


<h3>Details</h3>

<p>Color is used to encode the fraction of total or self time spent in
each function or call.  The scores used correspond to the values in
the printed representation produced by <code>printProfileCallGraph</code>.
For now, see the <code>gprof</code> manual for further details.  The color
encoding for a score <code>s</code> and a color map <code>m</code> is
<code>m[ceiling(length(m) * transfer(s))]</code>
</p>
<p>A style can be specified to set options to a set of cvalues that work
well together.
</p>


<h3>Value</h3>

<p>Used for side effect.</p>


<h3>Note</h3>

<p>Because of lazy evaluation, nested calls like <code>f(g(x))</code>
appear in the profile graph as <code>f</code> or one of its callees
calling <code>g</code>.
</p>
<p>Calls to functions with names containing a <code>|</code> character are
dropped as they cause problems in the <span class="pkg">graph</span> package.
</p>


<h3>Author(s)</h3>

<p> Luke Tierney </p>


<h3>References</h3>

<p>User manual for <code>gprof</code>, the GNU profiler.
</p>
<p>Graphviz: <a href="https://graphviz.gitlab.io/download/">https://graphviz.gitlab.io/download/</a>
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+Rprof">Rprof</a></code>,
<code><a href="utils.html#topic+summaryRprof">summaryRprof</a></code>,
<code><a href="#topic+readProfileData">readProfileData</a></code>,
<code><a href="#topic+flatProfile">flatProfile</a></code>,
<code><a href="#topic+profileCallGraph2Dot">profileCallGraph2Dot</a></code>
<code><a href="#topic+printProfileCallGraph">printProfileCallGraph</a></code>
<code><a href="#topic+plain.style">plain.style</a></code>
<code><a href="#topic+google.style">google.style</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pd &lt;- readProfileData(system.file("samples", "glmEx.out", package="proftools"))
plotProfileCallGraph(pd)
plotProfileCallGraph(pd, score = "none")
plotProfileCallGraph(pd, style = plain.style, score = "total")
</code></pre>

<hr>
<h2 id='printProfileCallGraph'> Print Call Graph for Rprof Profile Data </h2><span id='topic+printProfileCallGraph'></span>

<h3>Description</h3>

<p>Prints a representation of the call graph for profile data produced
by <code>Rprof</code>.  Output can be directed to a connection or a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printProfileCallGraph(pd, file = stdout(), percent = TRUE, GC = TRUE,
                      maxnodes = NA, total.pct = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printProfileCallGraph_+3A_pd">pd</code></td>
<td>
<p>profile data as returned by <code>readProfileData</code>.</p>
</td></tr>
<tr><td><code id="printProfileCallGraph_+3A_file">file</code></td>
<td>
<p> a connection or the name of the file where the profile
graph will be written. </p>
</td></tr>
<tr><td><code id="printProfileCallGraph_+3A_percent">percent</code></td>
<td>
<p> logical; if true use percent of total time; otherwise
use time in seconds </p>
</td></tr>
<tr><td><code id="printProfileCallGraph_+3A_gc">GC</code></td>
<td>
<p>logical; include GC information or not.</p>
</td></tr>
<tr><td><code id="printProfileCallGraph_+3A_maxnodes">maxnodes</code></td>
<td>
<p>integer; maximal number of nodes to use; nodes with
lower total hit counts are dropped.</p>
</td></tr>
<tr><td><code id="printProfileCallGraph_+3A_total.pct">total.pct</code></td>
<td>
<p>numeric; if positive, nodes with hit percentages
below this level are dropped.</p>
</td></tr>	      
</table>


<h3>Details</h3>

<p><code>printProfileCallGraph</code> produces a printed representation of
the call graph for profile data produced by <code>Rprof</code>.  The
representation is analogous to the call graph produced by
<code>gprof</code> with a few minor changes.  Eventually more complete
documentation of the format will be provided here; for now, reading
the <code>gprof</code> manual section on the call graph should help
understanding this output.  The output is similar enough to
gprof output for the <code>cgprof</code> script to be able to produce a
visual representation of the call graph via Graphviz.
</p>


<h3>Value</h3>

<p>Used for side effect.</p>


<h3>Note</h3>

<p>Because of lazy evaluation, nested calls like <code>f(g(x))</code>
appear in the profile graph as <code>f</code> or one of its callees
calling <code>g</code>.
</p>


<h3>Author(s)</h3>

<p> Luke Tierney </p>


<h3>References</h3>

<p>User manual for <code>gprof</code>, the GNU profiler.
</p>
<p><code>cgprof</code>: <a href="http://mvertes.free.fr/">http://mvertes.free.fr/</a>
</p>
<p>Graphviz: <a href="http://www.research.att.com/sw/tools/graphviz/">http://www.research.att.com/sw/tools/graphviz/</a>
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+Rprof">Rprof</a></code>,
<code><a href="utils.html#topic+summaryRprof">summaryRprof</a></code>,
<code><a href="#topic+flatProfile">flatProfile</a></code>,
<code><a href="#topic+readProfileData">readProfileData</a></code>,
<code><a href="#topic+plotProfileCallGraph">plotProfileCallGraph</a></code>,
<code><a href="#topic+profileCallGraph2Dot">profileCallGraph2Dot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pd &lt;- readProfileData(system.file("samples", "glmEx.out", package="proftools"))
printProfileCallGraph(pd)
## Not run: 
## If you have graphviz and cgprof installed on a UNIX-like system
## then in R do:

pd &lt;- readProfileData(system.file("samples", "glmEx.out", package="proftools"))
printProfileCallGraph(pd, "foo.graph")

## and then in a shell do (to use the interactive dotty):

cgprof -TX foo.graph

## or (to create a postscript version and view with gv):

cgprof -Tps foo.graph &gt; foo.ps
gv foo.ps
  
## End(Not run)
</code></pre>

<hr>
<h2 id='profileCallGraph2Dot'> Write Call Graph for Rprof Profile Data to Graphviz Dot File </h2><span id='topic+profileCallGraph2Dot'></span>

<h3>Description</h3>

<p>Prints a Graphviz .dot file representation of the call graph for profile
data produced by <code>Rprof</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profileCallGraph2Dot(pd, score = c("none", "total", "self"),
                     transfer = function(x) x, nodeColorMap = NULL,
                     edgeColorMap = NULL, filename = "Rprof.dot",
                     landscape = FALSE, mergeCycles = FALSE,
                     edgesColored = FALSE,
                     rankDir = c("TB", "LR"),
                     nodeDetails = FALSE, edgeDetails = FALSE,
                     nodeSizeScore = c("none", "total", "self"),
                     edgeSizeScore = c("none", "total"),
                     center = FALSE, size, shape = "ellipse",
                     layout = "dot", style, GC = TRUE,
                     maxnodes = NA, total.pct = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profileCallGraph2Dot_+3A_pd">pd</code></td>
<td>
<p>profile data as returned by <code>readProfileData</code>.</p>
</td></tr>
<tr><td><code id="profileCallGraph2Dot_+3A_score">score</code></td>
<td>
<p> character string specifying whether to use total time
or self time for coloring nodes/edges; no color used if
missing. </p>
</td></tr>
<tr><td><code id="profileCallGraph2Dot_+3A_transfer">transfer</code></td>
<td>
<p> function; maps score values in unit interval to unit
interval </p>
</td></tr>
<tr><td><code id="profileCallGraph2Dot_+3A_nodecolormap">nodeColorMap</code>, <code id="profileCallGraph2Dot_+3A_edgecolormap">edgeColorMap</code></td>
<td>
<p> character vectors of color
specifications as produced by <code>rainbow</code>; <code>transfer</code> of
score is mapped to color </p>
</td></tr>
<tr><td><code id="profileCallGraph2Dot_+3A_filename">filename</code></td>
<td>
<p> name of <code>.dot</code> file </p>
</td></tr>
<tr><td><code id="profileCallGraph2Dot_+3A_landscape">landscape</code></td>
<td>
<p> logical; whether to add the <code>rotate=90</code> option to
the <code>.dot</code> file </p>
</td></tr>
<tr><td><code id="profileCallGraph2Dot_+3A_mergecycles">mergeCycles</code></td>
<td>
<p> logical; whether to merge each cycle of recursion into
a single node </p>
</td></tr>
<tr><td><code id="profileCallGraph2Dot_+3A_edgescolored">edgesColored</code></td>
<td>
<p> logical; whether to color edges </p>
</td></tr>
<tr><td><code id="profileCallGraph2Dot_+3A_rankdir">rankDir</code></td>
<td>
<p> character; value to use for the <code>rankdir=</code> option to
specify the direction that the plot is laid out using
the <code>dot</code> layout; must be either <code>"TB"</code> for
Top-to-Bottom or <code>"LR"</code> for Left-to-Right.  The
default value is <code>"LR"</code>.</p>
</td></tr>
<tr><td><code id="profileCallGraph2Dot_+3A_nodedetails">nodeDetails</code>, <code id="profileCallGraph2Dot_+3A_edgedetails">edgeDetails</code></td>
<td>
<p>logical; whether count information
should be shown.</p>
</td></tr>
<tr><td><code id="profileCallGraph2Dot_+3A_nodesizescore">nodeSizeScore</code></td>
<td>
<p>character; value to encode in the size of the nodes.</p>
</td></tr>
<tr><td><code id="profileCallGraph2Dot_+3A_edgesizescore">edgeSizeScore</code></td>
<td>
<p>character; value to encode in the width of the edges.</p>
</td></tr>
<tr><td><code id="profileCallGraph2Dot_+3A_center">center</code></td>
<td>
<p> logical; whether to add the <code>center=1</code> option to
the <code>.dot</code> file. </p>
</td></tr>
<tr><td><code id="profileCallGraph2Dot_+3A_size">size</code></td>
<td>
<p> character; string to add as <code>size=</code> option in the
<code>.dot</code> file. </p>
</td></tr>
<tr><td><code id="profileCallGraph2Dot_+3A_shape">shape</code></td>
<td>
<p> character; node shape.</p>
</td></tr>
<tr><td><code id="profileCallGraph2Dot_+3A_layout">layout</code></td>
<td>
<p> character; layout method to use.</p>
</td></tr>
<tr><td><code id="profileCallGraph2Dot_+3A_style">style</code></td>
<td>
<p>named list of values for arguments <code>score</code> through
<code>layout</code> to use if not explicitly supplied.</p>
</td></tr>
<tr><td><code id="profileCallGraph2Dot_+3A_gc">GC</code></td>
<td>
<p>logical; include GC information or not.</p>
</td></tr>
<tr><td><code id="profileCallGraph2Dot_+3A_maxnodes">maxnodes</code></td>
<td>
<p>integer; maximal number of nodes to use; nodes with
lower total hit counts are dropped.</p>
</td></tr>
<tr><td><code id="profileCallGraph2Dot_+3A_total.pct">total.pct</code></td>
<td>
<p>numeric; if positive, nodes with hit percentages
below this level are dropped.</p>
</td></tr>	      
</table>


<h3>Details</h3>

<p>Writes the call graph as a Graphviz <code>.dot</code> file. Color is used
to encode the fraction total or self time spent in each function or
call.  The scores used correspond to the values in the printed
representation produced by <code>printProfileCallGraph</code>.  For now,
see the <code>gprof</code> manual for further details.  The color encoding
for a score <code>s</code> and a color map <code>m</code> is
<code>ceiling(length(m) * transfer(s))</code>
</p>
<p>A style can be specified to set options to a set of cvalues that work
well together.
</p>


<h3>Value</h3>

<p>Used for side effect.</p>


<h3>Note</h3>

<p>Because of lazy evaluation, nested calls like <code>f(g(x))</code>
appear in the profile graph as <code>f</code> or one of its callees
calling <code>g</code>.
</p>
<p>Calls to functions with names containing a <code>|</code> character are
dropped as they cause problems in the <span class="pkg">graph</span> package.
</p>


<h3>Author(s)</h3>

<p> Luke Tierney </p>


<h3>References</h3>

<p>User manual for <code>gprof</code>, the GNU profiler.
</p>
<p>Graphviz: <a href="https://graphviz.gitlab.io/download/">https://graphviz.gitlab.io/download/</a>
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+Rprof">Rprof</a></code>,
<code><a href="utils.html#topic+summaryRprof">summaryRprof</a></code>,
<code><a href="#topic+readProfileData">readProfileData</a></code>,
<code><a href="#topic+flatProfile">flatProfile</a></code>,
<code><a href="#topic+plotProfileCallGraph">plotProfileCallGraph</a></code>,
<code><a href="#topic+printProfileCallGraph">printProfileCallGraph</a></code>
<code><a href="#topic+plain.style">plain.style</a></code>
<code><a href="#topic+google.style">google.style</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pd &lt;- readProfileData(system.file("samples", "glmEx.out", package="proftools"))
tmp &lt;- tempfile()
profileCallGraph2Dot(pd, filename = tmp)
file.show(tmp)
unlink(tmp)

## Not run: 
## If you have graphviz installed on a UNIX-like system
## then in R do:

tmp.dot &lt;- tempfile()
tmp.pdf &lt;- tempfile()

profileCallGraph2Dot(pd, filename = tmp.dot)
system(sprintf("dot -Tpdf -o
browseURL(sprintf("file://

profileCallGraph2Dot(pd, filename = tmp.dot)
system(sprintf("dot -Tpdf -o
browseURL(sprintf("file://

unlink(tmp.dot)
unlink(tmp.pdf)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='profileExpr'> Read Rprof Profile Data </h2><span id='topic+profileExpr'></span>

<h3>Description</h3>

<p>Return profile data collected while evaluating an expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profileExpr(expr, GC = TRUE, srclines = TRUE, memory = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profileExpr_+3A_expr">expr</code></td>
<td>
<p>Valid <span class="rlang"><b>R</b></span> expression to be profiled.</p>
</td></tr>
<tr><td><code id="profileExpr_+3A_srclines">srclines</code></td>
<td>
<p>logical; include source information, if available, or not.</p>
</td></tr>
<tr><td><code id="profileExpr_+3A_gc">GC</code></td>
<td>
<p>logical; include GC information or not.</p>
</td></tr>
<tr><td><code id="profileExpr_+3A_memory">memory</code></td>
<td>
<p>logical; include memory use information or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>profileExpr</code> uses <code><a href="utils.html#topic+Rprof">Rprof</a></code> to profile execution of
<code>expr</code> and returns the profile data read in using
<code><a href="#topic+readProfileData">readProfileData</a></code>.  By default GC and source information
are included in the profile data. If memory profiling is supported,
memory use information is also included by default.
</p>


<h3>Value</h3>

<p>R representation of Rprof data.
</p>


<h3>Author(s)</h3>

<p> Luke Tierney </p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+Rprof">Rprof</a></code>,
<code><a href="#topic+funSummary">funSummary</a></code>,
<code><a href="#topic+srcSummary">srcSummary</a></code>,
<code><a href="#topic+plotProfileCallGraph">plotProfileCallGraph</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This defines the function rw()
source(system.file("samples", "rw.R", package="proftools"))

## Execute the function and collect profile data
pd &lt;- profileExpr(rw(200000))

## Examine the profiel data
funSummary(pd)
callSummary(pd)
hotPaths(pd)
srcSummary(pd)
plotProfileCallGraph(pd)
</code></pre>

<hr>
<h2 id='readProfileData'> Read Rprof Profile Data </h2><span id='topic+readProfileData'></span><span id='topic+readRStudioProfileCacheData'></span>

<h3>Description</h3>

<p>Reads in Rprof profile data for further processing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readProfileData(filename = "Rprof.out")
readRStudioProfileCacheData()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readProfileData_+3A_filename">filename</code></td>
<td>
<p>Name of a file produced by <code>Rprof()</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>readProfileData</code> reads the data in the file produced by
<code>Rprof</code> into a data structure for processing by other functions.
The details of the structure are subject to change.
</p>
<p><code>readRStudioProfileCacheData</code> returns the data for the most
recent profiling run in the RStudio profile cache, or <code>NULL</code>
if no data is available.
</p>


<h3>Value</h3>

<p>R representation of Rprof data,
</p>


<h3>Author(s)</h3>

<p> Luke Tierney </p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+Rprof">Rprof</a></code>,
<code><a href="utils.html#topic+summaryRprof">summaryRprof</a></code>,
<code><a href="#topic+flatProfile">flatProfile</a></code>,
<code><a href="#topic+plotProfileCallGraph">plotProfileCallGraph</a></code>,
<code><a href="#topic+printProfileCallGraph">printProfileCallGraph</a></code>,
<code><a href="#topic+profileCallGraph2Dot">profileCallGraph2Dot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pd &lt;- readProfileData(system.file("samples", "glmEx.out", package="proftools"))
flatProfile(pd)
flatProfile(pd, FALSE)
</code></pre>

<hr>
<h2 id='styles'>Style Specifications for Call Graphs</h2><span id='topic+plain.style'></span><span id='topic+google.style'></span>

<h3>Description</h3>

<p>Styles providing coordinated settings of display parameters for the
call graph display functions <code>plotProfileCallGraph</code> and
<code>profileCallGraph2Dot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plain.style
google.style
</code></pre>


<h3>Details</h3>

<p>The <code>plain.style</code> style corresponds to the default parameter settings
in the display functions. It can be used as the basis for creating a
new custom style.
</p>
<p>The <code>google.style</code> style is based on the display style used in the
<code>pprof</code> tool from the Google Performance Tools suite.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>layout</code></td>
<td>
<p>The layout method to use: One of <code>"dot"</code>,
<code>"neato"</code>, and <code>"twopi"</code>.</p>
</td></tr>
<tr><td><code>score</code></td>
<td>
<p> character string specifying whether to use total time
or self time for coloring nodes/edges; no color used if
missing. </p>
</td></tr>
<tr><td><code>transfer</code></td>
<td>
<p> function; maps score values in unit interval to unit
interval </p>
</td></tr>
<tr><td><code>nodeColorMap</code>, <code>edgeColorMap</code></td>
<td>
<p> character vectors of color
specifications as produced by <code>rainbow</code>; <code>transfer</code> of
score is mapped to color </p>
</td></tr>
<tr><td><code>mergeCycles</code></td>
<td>
<p> logical; whether to merge each cycle of recursion into
a single node </p>
</td></tr>
<tr><td><code>edgesColored</code></td>
<td>
<p> logical; whether to color edges </p>
</td></tr>
<tr><td><code>rankDir</code></td>
<td>
<p> The direction that the plot is laid out in, one of
either <code>"TB"</code> for Top-to-Bottom or <code>"LR"</code> for
Left-to-Right.  The default value is <code>"LR"</code>.  This
argument is only useful for <code>dot</code> layouts.</p>
</td></tr>
<tr><td><code>nodeDetails</code>, <code>edgeDetails</code></td>
<td>
<p>logical; whether count information
should be shown.</p>
</td></tr>
<tr><td><code>nodeSizeScore</code></td>
<td>
<p>character; value to encode in the size of the nodes.</p>
</td></tr>
<tr><td><code>edgeSizeScore</code></td>
<td>
<p>character; value to encode in the width of the edges.</p>
</td></tr>
<tr><td><code>shape</code></td>
<td>
<p> character; node shape.</p>
</td></tr>
<tr><td><code>maxnodes</code></td>
<td>
<p>integer; maximal number of nodes to use; nodes with
lower total hit counts are dropped.</p>
</td></tr>
<tr><td><code>total.pct</code></td>
<td>
<p>numeric; if positive, nodes with hit percentages
below this level are dropped.</p>
</td></tr>	      
</table>


<h3>Author(s)</h3>

<p> Luke Tierney </p>


<h3>References</h3>

 <p><a href="https://gperftools.github.io/gperftools/cpuprofile.html">https://gperftools.github.io/gperftools/cpuprofile.html</a>.</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+Rprof">Rprof</a></code>,
<code><a href="#topic+flatProfile">flatProfile</a></code>,
<code><a href="utils.html#topic+summaryRprof">summaryRprof</a></code>,
<code><a href="#topic+readProfileData">readProfileData</a></code>,
<code><a href="#topic+plotProfileCallGraph">plotProfileCallGraph</a></code>,
<code><a href="#topic+printProfileCallGraph">printProfileCallGraph</a></code>,
<code><a href="#topic+profileCallGraph2Dot">profileCallGraph2Dot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pd &lt;- readProfileData(system.file("samples", "glmEx.out", package="proftools"))
plotProfileCallGraph(pd, style = plain.style)
plotProfileCallGraph(pd, style = google.style)
</code></pre>

<hr>
<h2 id='summaries'>Basic Profile Data Summaries</h2><span id='topic+funSummary'></span><span id='topic+callSummary'></span><span id='topic+pathSummary'></span><span id='topic+srcSummary'></span>

<h3>Description</h3>

<p>Functions to summarize profile data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funSummary(pd, byTotal = TRUE, value = c("pct", "time", "hits"),
           srclines = TRUE, GC = TRUE, memory = FALSE, self.pct = 0, total.pct = 0)
callSummary(pd, byTotal = TRUE, value = c("pct", "time", "hits"),
            srclines = TRUE, GC = TRUE, memory = FALSE, self.pct = 0, total.pct = 0)
pathSummary(pd, value = c("pct", "time", "hits"),
            srclines = FALSE, GC = TRUE, memory = FALSE, total.pct = 0, ...)
srcSummary(pd, byTotal = TRUE, value = c("pct", "time", "hits"),
           GC = TRUE, memory = FALSE, total.pct = 0, source = TRUE,
           width = getOption("width"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaries_+3A_pd">pd</code></td>
<td>
<p>profile data as returned by <code>readProfileData</code>.</p>
</td></tr>
<tr><td><code id="summaries_+3A_bytotal">byTotal</code></td>
<td>
<p>logical; sort by total or by self time.</p>
</td></tr>
<tr><td><code id="summaries_+3A_value">value</code></td>
<td>
<p>character; show result as percentage, time, or hits.</p>
</td></tr>
<tr><td><code id="summaries_+3A_srclines">srclines</code></td>
<td>
<p>logical; include source information, if available, or not.</p>
</td></tr>
<tr><td><code id="summaries_+3A_gc">GC</code></td>
<td>
<p>logical; include GC information or not.</p>
</td></tr>
<tr><td><code id="summaries_+3A_memory">memory</code></td>
<td>
<p>logical; include memory use information or not.</p>
</td></tr>
<tr><td><code id="summaries_+3A_self.pct">self.pct</code></td>
<td>
<p>numeric; functions at the bottom of the stacks with
self percentages below this value are removed.</p>
</td></tr>
<tr><td><code id="summaries_+3A_total.pct">total.pct</code></td>
<td>
<p>numeric; functions at the top of the stacks with
total percentages below this value are removed.</p>
</td></tr>
<tr><td><code id="summaries_+3A_source">source</code></td>
<td>
<p>logical; if true, include source lines if available.</p>
</td></tr>
<tr><td><code id="summaries_+3A_width">width</code></td>
<td>
<p>maximal line length to use; source lines are abbreviated
to fit if necessary.</p>
</td></tr>
<tr><td><code id="summaries_+3A_...">...</code></td>
<td>
<p>arguments to control path formatting; not useful at this
time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>funSummary</code> returns a summary of the time spent in each
function, or each call site if source information is available and
requested. It is similar to <code>flatProfile</code>.
</p>
<p><code>callSummary</code> provides a breakdown by calls, again with an option
of distinguishing call and callee sites if source information is
available.
</p>
<p><code>pathSummary</code> returns a summary of time spent in each unique call
path contained in the profile data.
</p>
<p>For profile data containing source information <code>srcSummary</code>
returns a summary of time spent in each file line recorded in the
profile data.
</p>


<h3>Value</h3>

<p>A data frame of summary information.
</p>


<h3>Author(s)</h3>

<p> Luke Tierney </p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+Rprof">Rprof</a></code>,
<code><a href="#topic+flatProfile">flatProfile</a></code>,
<code><a href="utils.html#topic+summaryRprof">summaryRprof</a></code>,
<code><a href="#topic+readProfileData">readProfileData</a></code>,
<code><a href="#topic+plotProfileCallGraph">plotProfileCallGraph</a></code>,
<code><a href="#topic+printProfileCallGraph">printProfileCallGraph</a></code>,
<code><a href="#topic+profileCallGraph2Dot">profileCallGraph2Dot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pd &lt;- readProfileData(system.file("samples", "glmEx.out", package="proftools"))
funSummary(pd)
callSummary(pd)
pathSummary(pd)
</code></pre>

<hr>
<h2 id='utils'>Profile Data Utilities</h2><span id='topic+profileDataCycles'></span>

<h3>Description</h3>

<p>Utility functions for developing new profile data analysis tools.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  profileDataCycles(pd, GC)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utils_+3A_pd">pd</code></td>
<td>
<p>profile data as returned by <code>readProfileData</code>.</p>
</td></tr>
<tr><td><code id="utils_+3A_gc">GC</code></td>
<td>
<p>logical; include GC information or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are experimental and subject to change.
</p>


<h3>Author(s)</h3>

<p> Luke Tierney </p>

<hr>
<h2 id='writeCallgrindFile'> Write Out Profile Data in Callgrind Format </h2><span id='topic+writeCallgrindFile'></span>

<h3>Description</h3>

<p>Writes the profile data in callgrind format suitable for use with
<code>kcachegrind</code> or <code>qcachegrind</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeCallgrindFile(pd, file = "Rprof.cg", GC = TRUE, dropSource = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeCallgrindFile_+3A_pd">pd</code></td>
<td>
<p>profile data as returned by <code>readProfileData</code>.</p>
</td></tr>
<tr><td><code id="writeCallgrindFile_+3A_file">file</code></td>
<td>
<p> a connection or the name of the file where the callgrind
output will be written. </p>
</td></tr>
<tr><td><code id="writeCallgrindFile_+3A_gc">GC</code></td>
<td>
<p> logical; if true include GC information. </p>
</td></tr>
<tr><td><code id="writeCallgrindFile_+3A_dropsource">dropSource</code></td>
<td>
<p> logical; if true drop initial stack entried from a
<code>source</code> call and add a top level marker. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The callgrind format is used by Valgrind's callgrind tool. The KDE
tool <code>kcachegrind</code> can be used to display the file;
<code>kcachegrind</code> displays the summary statistics, a call graph, and
annotated source code if source information is
available. <code>kcachegrind</code> is available in Linux and Windows; on
Mac OSX <code>qcachegrind</code> is available.
</p>


<h3>Value</h3>

<p>Used for side effect.</p>


<h3>Author(s)</h3>

<p> Luke Tierney </p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+Rprof">Rprof</a></code>,
<code><a href="utils.html#topic+summaryRprof">summaryRprof</a></code>,
<code><a href="#topic+flatProfile">flatProfile</a></code>,
<code><a href="#topic+readProfileData">readProfileData</a></code>,
<code><a href="#topic+plotProfileCallGraph">plotProfileCallGraph</a></code>,
<code><a href="#topic+profileCallGraph2Dot">profileCallGraph2Dot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pd &lt;- readProfileData(system.file("samples", "glmEx.out", package="proftools"))
tmp &lt;- tempfile()
writeCallgrindFile(pd, file = tmp)
file.show(tmp)
unlink(tmp)
## Not run: 
## If you have kcachegrind installed on a UNIX-like system then do:
tmp &lt;- tempfile()
writeCallgrindFile(pd, file = tmp)
system(sprintf("kcachegrind 
unlink(tmp)
  
## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
