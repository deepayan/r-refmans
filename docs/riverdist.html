<!DOCTYPE html><html lang="en"><head><title>Help for package riverdist</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {riverdist}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#riverdist-package'>
<p>River Network Distance Computation and Applications</p></a></li>
<li><a href='#abstreams'><p>Dataset: A-B Streams</p></a></li>
<li><a href='#abstreams0'><p>Dataset: A-B Streams 0</p></a></li>
<li><a href='#addcumuldist'><p>Add Cumulative Distance to a River Network</p></a></li>
<li><a href='#addverts'><p>Add Vertices To Maintain a Minimum Distance Between Vertices</p></a></li>
<li><a href='#buildlookup'><p>Build Lookup Tables for Fast Distance Computation</p></a></li>
<li><a href='#buildsegroutes'><p>Build Segment Routes</p></a></li>
<li><a href='#calculateconnections'><p>Calculate the Connectivity Matrix for a River Network</p></a></li>
<li><a href='#checkbraided'><p>Check for Braiding in a River Network</p></a></li>
<li><a href='#checkbraidedTF'><p>Check for Braiding in a River Network</p></a></li>
<li><a href='#cleanup'><p>Interactive Cleanup of a River Network</p></a></li>
<li><a href='#cleanup_verts'><p>Interactive Cleanup of the Vertices of Individual Segments</p></a></li>
<li><a href='#connectsegs'><p>Connect Segments</p></a></li>
<li><a href='#densityanomaly'><p>Plot Difference from Mean Kernel Density Using River Distance</p></a></li>
<li><a href='#detectroute'><p>Detect Route</p></a></li>
<li><a href='#dissolve'><p>Dissolve</p></a></li>
<li><a href='#fakefish'><p>Dataset: Fakefish</p></a></li>
<li><a href='#fakefish_density'><p>Dataset: Fakefish Density</p></a></li>
<li><a href='#Gulk'><p>Dataset: Gulkana River</p></a></li>
<li><a href='#highlightseg'><p>Highlight Segments</p></a></li>
<li><a href='#homerange'><p>Home Range</p></a></li>
<li><a href='#homerange-class'><p>The &quot;homerange&quot; Class</p></a></li>
<li><a href='#homerangeoverlap'><p>Home Range Overlap</p></a></li>
<li><a href='#isflowconnected'><p>Check Flow-Connectedness</p></a></li>
<li><a href='#Kenai1'><p>Dataset: Kenai River 1</p></a></li>
<li><a href='#Kenai2'><p>Dataset: Kenai River 2</p></a></li>
<li><a href='#Kenai3'><p>Dataset: Kenai River 3</p></a></li>
<li><a href='#kfunc'><p>Plotting K-functions for a Set of Surveys</p></a></li>
<li><a href='#KilleyW'><p>Dataset: Killey River, West Channel</p></a></li>
<li><a href='#Koyukuk0'><p>Dataset: Koyukuk River 0</p></a></li>
<li><a href='#Koyukuk1'><p>Dataset: Koyukuk River 1</p></a></li>
<li><a href='#Koyukuk2'><p>Dataset: Koyukuk River 2</p></a></li>
<li><a href='#line2network'><p>Create a River Network Object from a Shapefile</p></a></li>
<li><a href='#line98'><p>Dataset: Line 98 of Kenai River 1 (Long-Lat)</p></a></li>
<li><a href='#makeriverdensity'><p>Calculate Kernel Density Using River Distance</p></a></li>
<li><a href='#mapbyname'><p>Map Segments by Name</p></a></li>
<li><a href='#matbysurveylist'><p>Generate List of Distance Matrix Between Observations, for All Individuals</p></a></li>
<li><a href='#mouthdist'><p>Distance From Mouth</p></a></li>
<li><a href='#mouthdistbysurvey'><p>Distance From Mouth for All Observations of Individuals</p></a></li>
<li><a href='#pdist'><p>Pythagorean Distance</p></a></li>
<li><a href='#pdisttot'><p>Total Pythagorean Distance</p></a></li>
<li><a href='#plot.homerange'><p>Plot Home Range</p></a></li>
<li><a href='#plot.riverdensity'><p>Plot Kernel Density Using River Distance</p></a></li>
<li><a href='#plot.rivernetwork'><p>Plotting a River Network</p></a></li>
<li><a href='#plothomerangeoverlap'><p>Plot Home Range Overlap</p></a></li>
<li><a href='#plotmatbysurveylist'><p>Plot Upstream Distance Between Observations of All Individuals</p></a></li>
<li><a href='#plotriverdensitypoints'><p>Plot Points Used for Kernel Density</p></a></li>
<li><a href='#plotseq'><p>Plot Sequence of Observations</p></a></li>
<li><a href='#pointshp2segvert'><p>Convert a Point Shapefile to River Locations</p></a></li>
<li><a href='#removeduplicates'><p>Remove Duplicates</p></a></li>
<li><a href='#removemicrosegs'><p>Remove Segments that are Smaller than the Connectivity Tolerance</p></a></li>
<li><a href='#removeunconnected'><p>Remove Unconnected Segments</p></a></li>
<li><a href='#riverdensity'><p>The &quot;riverdensity&quot; Class</p></a></li>
<li><a href='#riverdirection'><p>River Direction</p></a></li>
<li><a href='#riverdirectionmat'><p>River Direction Matrix</p></a></li>
<li><a href='#riverdirectionmatbysurvey'><p>River Direction Matrix of All Observations of an Individual</p></a></li>
<li><a href='#riverdirectionseq'><p>River Travel Direction Between Sequential Observations</p></a></li>
<li><a href='#riverdirectiontofrom'><p>River Direction Matrix between Two Datasets</p></a></li>
<li><a href='#riverdistance'><p>River Distance</p></a></li>
<li><a href='#riverdistancelist'><p>Multiple River Distances</p></a></li>
<li><a href='#riverdistancemat'><p>River Distance Matrix</p></a></li>
<li><a href='#riverdistancematbysurvey'><p>River Distance Matrix of All Observations of an Individual</p></a></li>
<li><a href='#riverdistanceseq'><p>River Distance Between Sequential Observations</p></a></li>
<li><a href='#riverdistancetofrom'><p>River Distance Matrix between Two Datasets</p></a></li>
<li><a href='#rivernetwork'><p>The &quot;rivernetwork&quot; Class</p></a></li>
<li><a href='#riverpoints'><p>Draw Points from River Locations</p></a></li>
<li><a href='#routelist'><p>Detect Multiple Routes</p></a></li>
<li><a href='#segvert2xy'><p>Convert River Locations to XY coordinates</p></a></li>
<li><a href='#sequenceverts'><p>Store Vertices in Ascending Sequence</p></a></li>
<li><a href='#setmouth'><p>Specify the Segment and Vertex of the Mouth of a River Network Object.</p></a></li>
<li><a href='#showends'><p>Identify Vertex Coordinates of Segment Endpoints</p></a></li>
<li><a href='#smallset'><p>Dataset: Smallset</p></a></li>
<li><a href='#splitsegmentat'><p>Split a Segment at a Specified Vertex</p></a></li>
<li><a href='#splitsegments'><p>Split Segments by Endpoint Proximity</p></a></li>
<li><a href='#topologydots'><p>Check Connectivity of a River Network Object</p></a></li>
<li><a href='#trimriver'><p>Trim a River Network Object to Specified Segments</p></a></li>
<li><a href='#trimtopoints'><p>Trim a River Network to a Set of X-Y Coordinates</p></a></li>
<li><a href='#upstream'><p>Upstream River Distance</p></a></li>
<li><a href='#upstreammat'><p>Upstream Distance Matrix</p></a></li>
<li><a href='#upstreammatbysurvey'><p>Upstream Distance Matrix of All Observations of an Individual</p></a></li>
<li><a href='#upstreamseq'><p>Upstream Distance Between Sequential Observations</p></a></li>
<li><a href='#upstreamtofrom'><p>Upstream Distance Matrix between Two Datasets</p></a></li>
<li><a href='#whoconnected'><p>Check Which Segments are Connected to a Given Segment.</p></a></li>
<li><a href='#xy2segvert'><p>Convert XY Coordinates to River Locations</p></a></li>
<li><a href='#zoomtoseg'><p>Zoom to segment</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>River Network Distance Computation and Applications</td>
</tr>
<tr>
<td>Version:</td>
<td>0.17.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-07</td>
</tr>
<tr>
<td>Author:</td>
<td>Matt Tyers [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matt Tyers &lt;matttyersstat@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Reads river network shape files and computes network distances.
    Also included are a variety of computation and graphical tools designed
    for fisheries telemetry research, such as minimum home range, kernel density
    estimation, and clustering analysis using empirical k-functions with
    a bootstrap envelope.  Tools are also provided for editing the river
    networks, meaning there is no reliance on external software.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>sf (&ge; 1.0-14), methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, tibble, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cran.r-project.org/package=riverdist">https://cran.r-project.org/package=riverdist</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mbtyers/riverdist/issues">https://github.com/mbtyers/riverdist/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-07 17:54:21 UTC; mbtyers</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-07 18:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='riverdist-package'>
River Network Distance Computation and Applications
</h2><span id='topic+riverdist-package'></span><span id='topic+riverdist'></span>

<h3>Description</h3>

<p>Reads river network shape files and computes network distances.
Also included are a variety of computation and graphical tools designed 
for fisheries telemetry research, such as minimum home range, kernel density 
estimation, and clustering analysis using empirical k-functions with 
a bootstrap envelope.  Tools are also provided for editing the river 
networks, meaning there is no reliance on external software.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> riverdist</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.17.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-11-07</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The riverdist package provides tools for distance calculation along a river network.  The river network is imported from a projected shapefile.  Spatial point data may be imported from a shapefile as well, or directly from coordinates.
</p>
<p>Some basic formatting of the river shapefile may be necessary.  If available, formatting in a geographic information system (GIS) prior to importing into R is recommended (projecting, spatial trimming to the study area, and possibly dissolving river segments), but the riverdist package and its dependencies also include tools for accomplishing the necessary formatting within R.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>
<p>Maintainer: Matt Tyers &lt;matttyersstat@gmail.com&gt;
</p>

<hr>
<h2 id='abstreams'>Dataset: A-B Streams</h2><span id='topic+abstreams'></span>

<h3>Description</h3>

<p>A complex river network object, a subset of the streams in the Absaroka-Beartooth Wilderness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(abstreams)
</code></pre>


<h3>Format</h3>

<p>A river network object, see <a href="#topic+rivernetwork">rivernetwork</a>
</p>

<hr>
<h2 id='abstreams0'>Dataset: A-B Streams 0</h2><span id='topic+abstreams0'></span>

<h3>Description</h3>

<p>An unusably messy river network object, included for the purpose of testing river network editing functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(abstreams0)
</code></pre>


<h3>Format</h3>

<p>A river network object, see <a href="#topic+rivernetwork">rivernetwork</a>
</p>

<hr>
<h2 id='addcumuldist'>Add Cumulative Distance to a River Network</h2><span id='topic+addcumuldist'></span>

<h3>Description</h3>

<p>Adds a vector of cumulative distances to a river network.  Called internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addcumuldist(rivers)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addcumuldist_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>"rivernetwork"</code> containing all
spatial and topological information.  See <a href="#topic+rivernetwork-class">rivernetwork-class</a>.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Gulk1 &lt;- addcumuldist(rivers=Gulk)
</code></pre>

<hr>
<h2 id='addverts'>Add Vertices To Maintain a Minimum Distance Between Vertices</h2><span id='topic+addverts'></span>

<h3>Description</h3>

<p>In certain cases, such as when there is a lake within a river system, there may be long, straight lines in a river network with vertices only at either end.
In these cases, any point data along these stretches would be snapped to the vertices at either end.  This function automatically
adds equally-spaced vertices along the straight line, according to a specified minimum allowable distance between vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addverts(rivers, mindist = 500)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addverts_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use.</p>
</td></tr>
<tr><td><code id="addverts_+3A_mindist">mindist</code></td>
<td>
<p>The minimum distance to use between vertices.  Defaults to 500.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new river network object with the specified segments connected (see <a href="#topic+rivernetwork">rivernetwork</a>)
</p>


<h3>Note</h3>

<p>This function is called within <a href="#topic+cleanup">cleanup</a>, which is recommended in most cases.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p>line2network
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Kenai3)
Kenai3split &lt;- addverts(Kenai3,mindist=200)

zoomtoseg(seg=c(47,74,78), rivers=Kenai3)
points(Kenai3$lines[[74]])        # vertices before adding

zoomtoseg(seg=c(47,74,78), rivers=Kenai3split)
points(Kenai3split$lines[[74]])   # vertices after adding
</code></pre>

<hr>
<h2 id='buildlookup'>Build Lookup Tables for Fast Distance Computation</h2><span id='topic+buildlookup'></span>

<h3>Description</h3>

<p>Adds lookup tables for distance computation, dramatically
reducing computation time.  It may take some time to calculate,
particularly in a braided network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildlookup(rivers)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildlookup_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A rivernetwork object, with a new list element, <code>$distlookup</code>, a
list of three matrices.  Element <code>[i,j]</code> of each matrix corresponds to
the route between segment <code>i</code> and <code>j</code>.  The
<code>distlookup$middist</code> matrix gives the total distance of the &quot;middle&quot;
of each route (between the starting and ending segments&quot;), and the
<code>distlookup$starttop</code> and <code>distlookup$endtop</code> matrices have value
<code>TRUE</code>, <code>FALSE</code>, or <code>NA</code> if the segments at the beginning or
end of the route are connected to the rest of the route at the top of the
coordinate matrix, bottom of the coordinate matrix, or if the route is
contained to just one segment, respectively. (See <a href="#topic+rivernetwork">rivernetwork</a>.)
</p>


<h3>Note</h3>

<p>This will add three n by n matrices to the river network object, which
will be very large if the river network has many segments.
</p>
<p>This function is called within <a href="#topic+cleanup">cleanup</a>, which is recommended in
most cases.  It is also called within <a href="#topic+buildsegroutes">buildsegroutes</a>, and will add
lookup tables by default if there are fewer than 400 segments in the river
network.
</p>
<p>This function can still be called in the presence of a braided network, but all resulting distances used in subsequent analyses will be the shortest route.
</p>
<p>If segment routes (<code>$segroutes</code>) are not present, this function may take a very long time to run.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(abstreams)

abstreams1 &lt;- buildlookup(abstreams)
</code></pre>

<hr>
<h2 id='buildsegroutes'>Build Segment Routes</h2><span id='topic+buildsegroutes'></span>

<h3>Description</h3>

<p>Adds the travel routes from the mouth (lowest point) of a river 
network to each segment, and (optionally) distance lookup tables.  This
greatly reduces the time needed to detect routes, making distance
calculation much more efficient, particularly in the case of multiple
distance calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildsegroutes(rivers, lookup = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildsegroutes_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
<tr><td><code id="buildsegroutes_+3A_lookup">lookup</code></td>
<td>
<p>Whether to build lookup tables as well.  This may take
some time, but will result in even faster distance computation in analyses
(see <a href="#topic+buildlookup">buildlookup</a>).  Because of the object size returned, this may
not be advisable in a large river network (more than a few hundred
segments).  Accepts <code>TRUE</code> or <code>FALSE</code>, and defaults to
<code>NULL</code>.  If the default value is accepted, lookup tables will be built
if the river network has 400 segments or fewer.</p>
</td></tr>
<tr><td><code id="buildsegroutes_+3A_verbose">verbose</code></td>
<td>
<p>Whether or not to print the segment number the function is 
currently building a route for (used for error checking).  Defaults to 
FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A rivernetwork object, with a new list element, <code>$segroutes</code>, 
which gives the route from the mouth to each rivernetwork segment. 
Optionally, it may add <code>$distlookup</code>, distance lookup tables for even
faster distance computation. (See <a href="#topic+rivernetwork">rivernetwork</a>.)
</p>


<h3>Note</h3>

<p>In the event of braiding (multiple channels), it is likely that there 
will be differences in the routes detected.  If this is the case, building 
routes will likely result in a shorter and more efficient route. 
Regardless, extreme caution is always advised in the event of braiding.
</p>
<p>The mouth segment and vertex must be specified (see <a href="#topic+setmouth">setmouth</a>).
</p>
<p>This function is called within <a href="#topic+cleanup">cleanup</a>, which is recommended in
most cases.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(abstreams)
plot(x=abstreams)
abstreams1 &lt;- abstreams
abstreams1$segroutes &lt;- NULL #taking out the $segroutes component

# before
tstart &lt;- Sys.time()
detectroute(start=120, end=111, rivers=abstreams1)
Sys.time() - tstart

# after
tstart &lt;- Sys.time()
detectroute(start=120, end=111, rivers=abstreams)
Sys.time() - tstart
</code></pre>

<hr>
<h2 id='calculateconnections'>Calculate the Connectivity Matrix for a River Network</h2><span id='topic+calculateconnections'></span>

<h3>Description</h3>

<p>Calculates the connectivity matrix for a river network, during import and editing.  Called internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateconnections(lines, tolerance)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculateconnections_+3A_lines">lines</code></td>
<td>
<p>A list of coordinate matrices, each corresponding to a line segment.</p>
</td></tr>
<tr><td><code id="calculateconnections_+3A_tolerance">tolerance</code></td>
<td>
<p>The spatial tolerance for establishing connectivity.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with topological information.  See the <code>$connections</code> element of the <a href="#topic+rivernetwork-class">rivernetwork-class</a>.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Gulk_connections &lt;- calculateconnections(lines=Gulk$lines, tolerance=Gulk$tolerance)
</code></pre>

<hr>
<h2 id='checkbraided'>Check for Braiding in a River Network</h2><span id='topic+checkbraided'></span>

<h3>Description</h3>

<p>Detects braiding (multiple flow channels between two locations)
within a river network object.  Braiding can either be checked for in the
route between two segments, or in the river network as a whole.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkbraided(rivers, startseg = NULL, endseg = NULL, progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkbraided_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to check.</p>
</td></tr>
<tr><td><code id="checkbraided_+3A_startseg">startseg</code></td>
<td>
<p>Starting segment of a route to investigate.  If this and
<code>endseg</code> are <code>NULL</code>, the full river network will be checked.</p>
</td></tr>
<tr><td><code id="checkbraided_+3A_endseg">endseg</code></td>
<td>
<p>Starting segment of a route to investigate.  If this and
<code>startseg</code> are <code>NULL</code>, the full river network will be checked.</p>
</td></tr>
<tr><td><code id="checkbraided_+3A_progress">progress</code></td>
<td>
<p>Whether to show the progress bar.  Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is called within <a href="#topic+cleanup">cleanup</a>, which is recommended in most cases.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk)
plot(x=Gulk)
checkbraided(rivers=Gulk)

data(KilleyW)
plot(x=KilleyW)
checkbraided(rivers=KilleyW)

Kenai3.subset &lt;- trimriver(trimto=c(22,2,70,30,15,98,96,89,52,3), rivers=Kenai3)
plot(x=Kenai3.subset)

checkbraided(startseg=1, endseg=7, rivers=Kenai3.subset)
checkbraided(startseg=1, endseg=5, rivers=Kenai3.subset)
</code></pre>

<hr>
<h2 id='checkbraidedTF'>Check for Braiding in a River Network</h2><span id='topic+checkbraidedTF'></span>

<h3>Description</h3>

<p>Detects braiding (multiple flow channels between two locations)
within a river network object, and returns a logical value for specifying braiding within a river network object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkbraidedTF(rivers, toreturn = "rivers", progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkbraidedTF_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to check.</p>
</td></tr>
<tr><td><code id="checkbraidedTF_+3A_toreturn">toreturn</code></td>
<td>
<p>Specifying <code>toreturn="rivers"</code> (the default) will return a river network object with a value of <code>TRUE</code> or <code>FALSE</code> assigned to the <code>$braided</code> element of the river network object.  Specifying <code>toreturn="logical"</code> will just return <code>TRUE</code> if braiding is detected or <code>FALSE</code> if no braiding is detected.  Specifying <code>toreturn="routes"</code> will return the first two differing routes detected, which may be useful in identifying where the problem lies.</p>
</td></tr>
<tr><td><code id="checkbraidedTF_+3A_progress">progress</code></td>
<td>
<p>Whether to show the progress bar.  Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is called within <a href="#topic+cleanup">cleanup</a>, which is recommended in most cases.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk,KilleyW)
Gulk &lt;- setmouth(seg=1, vert=1, rivers=Gulk)
plot(x=Gulk)
checkbraidedTF(rivers=Gulk, toreturn="logical")

KilleyW &lt;- setmouth(seg=1, vert=288, rivers=KilleyW)
plot(x=KilleyW)
checkbraidedTF(rivers=KilleyW, toreturn="logical")
checkbraidedTF(rivers=KilleyW, toreturn="routes")

KilleyW.1 &lt;- checkbraidedTF(rivers=KilleyW, toreturn="rivers")
str(KilleyW.1)
</code></pre>

<hr>
<h2 id='cleanup'>Interactive Cleanup of a River Network</h2><span id='topic+cleanup'></span>

<h3>Description</h3>

<p>This is the recommended function to use for cleanup of a river
network.  It calls all available river network editing functions in
appropriate sequence, detecting which are needed or recommended, and
prompts user input wherever necessary.
</p>
<p>Currently, it automatically calls <a href="#topic+removeduplicates">removeduplicates</a>, prompts the user
whether to run <a href="#topic+dissolve">dissolve</a>, automatically runs <a href="#topic+removemicrosegs">removemicrosegs</a>
and <a href="#topic+splitsegments">splitsegments</a> if needed, provides user prompts for
<a href="#topic+addverts">addverts</a> and <a href="#topic+setmouth">setmouth</a>, detects if segments are unconnected
and provides user prompts for <a href="#topic+removeunconnected">removeunconnected</a> or
<a href="#topic+connectsegs">connectsegs</a>, automatically runs <a href="#topic+checkbraidedTF">checkbraidedTF</a>, and prompts
the user whether to run <a href="#topic+buildsegroutes">buildsegroutes</a> if no braiding is detected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleanup(rivers)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cleanup_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new river network object, see
<a href="#topic+rivernetwork">rivernetwork</a>
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p>line2network
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(abstreams0,Koyukuk0,Kenai1)

# abstreams_fixed &lt;- cleanup(abstreams0)
# Koyukuk &lt;- cleanup(Koyukuk0)
# Kenai &lt;- cleanup(Kenai1)
</code></pre>

<hr>
<h2 id='cleanup_verts'>Interactive Cleanup of the Vertices of Individual Segments</h2><span id='topic+cleanup_verts'></span>

<h3>Description</h3>

<p>A trial version of a function for deep-cleaning a river network.
</p>
<p>Sometimes a shapefile contains errors that are not obvious at an initial check, 
typically vertices that should not be there.  
</p>
<p>This function steps through each segment in sequence, and allows the user to 
interactively remove vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleanup_verts(rivers, startwith = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cleanup_verts_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
<tr><td><code id="cleanup_verts_+3A_startwith">startwith</code></td>
<td>
<p>The segment (number) to start with, defaulting to <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new river network object, see
<a href="#topic+rivernetwork">rivernetwork</a>
</p>


<h3>Note</h3>

<p>Stepping through a large and messy river network can be time-consuming.  
To resume a cleanup session, use the <code>startwith=</code> argument and the last 
returned river network.  For example, if <code>rivers1 &lt;- cleanup_verts(rivers)</code> 
were initially called and the user selected &quot;save &amp; close&quot; at segment 100, 
cleanup can be resumed by calling <code>rivers2 &lt;- cleanup_verts(rivers1, startwith=100)</code>.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p>line2network
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(abstreams0,Koyukuk0,Kenai1)

# abstreams_fixed1 &lt;- cleanup_verts(abstreams0)
# Koyukuk &lt;- cleanup(Koyukuk0)
# Kenai &lt;- cleanup(Kenai1)
</code></pre>

<hr>
<h2 id='connectsegs'>Connect Segments</h2><span id='topic+connectsegs'></span>

<h3>Description</h3>

<p>Provides a method to manually connect unconnected segments
within a river network.  The nearest endpoint (or vertex) of the second segment is
added as a new vertex to the first, and the network topology is then updated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connectsegs(
  connect,
  connectto,
  nearestvert = TRUE,
  rivers,
  calcconnections = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="connectsegs_+3A_connect">connect</code></td>
<td>
<p>The segment(s) to connect to the network.  Typically, this is the
segment that is disconnected from the rest of the river network.  A vector of segments may be used.</p>
</td></tr>
<tr><td><code id="connectsegs_+3A_connectto">connectto</code></td>
<td>
<p>The segment(s) to connect it (them) to.  Typically, this is a segment
that is connected to the rest of the river network.  A vector of segments may be used, corresponding to that used in <code>connect=</code>.</p>
</td></tr>
<tr><td><code id="connectsegs_+3A_nearestvert">nearestvert</code></td>
<td>
<p>Whether to connect at the nearest vertex and split the
segment (<code>FALSE</code>), or connect at the nearest endpoint (<code>TRUE</code>). 
Defaults to <code>TRUE</code>.  A vector may be used, corresponding to those used in <code>connect=</code> and <code>connectto=</code>.</p>
</td></tr>
<tr><td><code id="connectsegs_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use.</p>
</td></tr>
<tr><td><code id="connectsegs_+3A_calcconnections">calcconnections</code></td>
<td>
<p>Whether to recalculate all connections. 
Defaults to <code>TRUE</code>.  Setting to <code>FALSE</code> is not recommended unless many connections are to be made, in which case connections can be calculated afterward.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new river network object with the specified segments connected (see
<a href="#topic+rivernetwork">rivernetwork</a>)
</p>


<h3>Note</h3>

<p>This function is called within <a href="#topic+cleanup">cleanup</a>, which is recommended in
most cases.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p>line2network
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Koyukuk0)
plot(Koyukuk0, ylim=c(1930500,1931500), xlim=c(194900,195100))
topologydots(Koyukuk0, add=TRUE)

Koyukuk0.1 &lt;- connectsegs(connect=21, connectto=20, rivers=Koyukuk0)
plot(Koyukuk0.1,ylim=c(1930500,1931500), xlim=c(194900,195100))
topologydots(Koyukuk0.1, add=TRUE)

# or the vector version
zoomtoseg(seg=21:23, rivers=Koyukuk0)
Koyukuk0.2 &lt;- connectsegs(connect=c(20,21,22), connectto=c(21,22,23), 
    nearestvert=c(FALSE,FALSE,TRUE), rivers=Koyukuk0)
zoomtoseg(seg=21:23, rivers=Koyukuk0.2)
topologydots(Koyukuk0.2, add=TRUE)
</code></pre>

<hr>
<h2 id='densityanomaly'>Plot Difference from Mean Kernel Density Using River Distance</h2><span id='topic+densityanomaly'></span>

<h3>Description</h3>

<p>Plots kernel density anomaly for each survey, which is defined as 
the difference between kernel density for each survey and mean kernel density 
across all surveys.  The intent of this function is to highlight areas in which 
density is higher or lower for specific surveys than it is on average.
</p>
<p>The input argument is an object returned from <a href="#topic+makeriverdensity">makeriverdensity</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densityanomaly(
  x,
  whichplots = NULL,
  method = c("overlap", "both", "positive", "negative"),
  negative_ramp = "blue",
  positive_ramp = "red",
  parmfrow = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="densityanomaly_+3A_x">x</code></td>
<td>
<p>An object returned from <a href="#topic+makeriverdensity">makeriverdensity</a>.</p>
</td></tr>
<tr><td><code id="densityanomaly_+3A_whichplots">whichplots</code></td>
<td>
<p>A vector of plots to produce, if multiple plots are 
produced.  For example, specifying <code>whichplot=c(2,3,4)</code> will result in
only the second, third, and fourth plots of the sequence being produced. 
Accepting the default (<code>NULL</code>) will result in all plots being 
produced.  Note: this will also be the set of kernel densities used to 
calculate the mean kernel density and thereby differences from mean kernel
density.</p>
</td></tr>
<tr><td><code id="densityanomaly_+3A_method">method</code></td>
<td>
<p>Whether to produce plots for positive and negative anomalies
overlayed (<code>"overlay"</code>), in sequence (<code>"both"</code>), or positive or 
negative only (<code>"positive"</code> or <code>"negative"</code>).</p>
</td></tr>
<tr><td><code id="densityanomaly_+3A_negative_ramp">negative_ramp</code></td>
<td>
<p>Color ramp to use for negative anomaly (see <a href="#topic+plot.riverdensity">plot.riverdensity</a>
for more details).  Defaults to <code>"blue"</code>.</p>
</td></tr>
<tr><td><code id="densityanomaly_+3A_positive_ramp">positive_ramp</code></td>
<td>
<p>Color ramp to use for negative anomaly (see <a href="#topic+plot.riverdensity">plot.riverdensity</a>
for more details).  Defaults to <code>"red"</code>.</p>
</td></tr>
<tr><td><code id="densityanomaly_+3A_parmfrow">parmfrow</code></td>
<td>
<p>Optional argument to <code>par(mfrow)=</code>, which may be useful if
<code>method="both"</code>.  Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="densityanomaly_+3A_...">...</code></td>
<td>
<p>Additional arguments to <a href="#topic+plot.riverdensity">plot.riverdensity</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+makeriverdensity">makeriverdensity</a>, <a href="#topic+plot.riverdensity">plot.riverdensity</a>, <a href="#topic+plotriverdensitypoints">plotriverdensitypoints</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk, fakefish)

Gulk_dens &lt;- makeriverdensity(seg=fakefish$seg, vert=fakefish$vert, rivers=Gulk, 
  survey=fakefish$flight.date)
  
# first, the behavior of plot.riverdensity
# # 10 plots will be created, recommend calling par(mfrow=c(2,5))
plot(x=Gulk_dens)

# next, showing densityanomaly
densityanomaly(x=Gulk_dens, parmfrow=c(2,5))
densityanomaly(x=Gulk_dens, method="negative", parmfrow=c(2,5))
densityanomaly(x=Gulk_dens, method="positive", parmfrow=c(2,5))
</code></pre>

<hr>
<h2 id='detectroute'>Detect Route</h2><span id='topic+detectroute'></span>

<h3>Description</h3>

<p>Called internally within <a href="#topic+riverdistance">riverdistance</a>.  Detects the 
sequential route from one river network segment to another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detectroute(
  start,
  end,
  rivers,
  verbose = FALSE,
  stopiferror = TRUE,
  algorithm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detectroute_+3A_start">start</code></td>
<td>
<p>Segment number of the start of the route</p>
</td></tr>
<tr><td><code id="detectroute_+3A_end">end</code></td>
<td>
<p>Segment number of the end of the route</p>
</td></tr>
<tr><td><code id="detectroute_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
<tr><td><code id="detectroute_+3A_verbose">verbose</code></td>
<td>
<p>Whether or not to print all routes being considered (used for 
error checking).  Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="detectroute_+3A_stopiferror">stopiferror</code></td>
<td>
<p>Whether or not to exit with an error if a route cannot be
found.  If this is set to <code>FALSE</code> and a route cannot be found,
<code>detectroute()</code> will return <code>NA</code>.  Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="detectroute_+3A_algorithm">algorithm</code></td>
<td>
<p>Which route detection algorithm to use.  If set to <code>NULL</code> (the default), the function will automatically make a selection.  Choices are:
</p>

<ul>
<li><p> Setting <code>algorithm="sequential"</code> will be quite slow, and may give inaccurate results in the event of braiding.  This algorithm returns the first complete route detected, which may not be the shortest.  This algorithm is not recommended in almost all cases, but is retained as an option for certain checks.  It will not be used unless specified.
</p>
</li>
<li><p> Setting <code>algorithm="Dijkstra"</code> will be much faster, and will return the shortest route in the event of braiding.  If braiding is present or unknown, this will be the algorithm automatically chosen.
</p>
</li>
<li><p> Setting <code>algorithm="segroutes"</code> will be the fastest of all, but will only return results in a non-braided network.  This will be the algorithm automatically selected if segment routes are present - see <a href="#topic+buildsegroutes">buildsegroutes</a>.</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of segment numbers corresponding to the ordered route.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk)
plot(x=Gulk, cex=1)

detectroute(start=6, end=14, rivers=Gulk)

tstart &lt;- Sys.time()
detectroute(start=120, end=111, rivers=abstreams, algorithm="sequential")
tend &lt;- Sys.time()
tend - tstart

data(abstreams)
tstart &lt;- Sys.time()
detectroute(start=120, end=111, rivers=abstreams, algorithm="Dijkstra")
tend &lt;- Sys.time()
tend - tstart

tstart &lt;- Sys.time()
detectroute(start=120, end=111, rivers=abstreams, algorithm="segroutes")
tend &lt;- Sys.time()
tend - tstart
</code></pre>

<hr>
<h2 id='dissolve'>Dissolve</h2><span id='topic+dissolve'></span>

<h3>Description</h3>

<p>Acts like a spatial dissolve within a GIS environment.  Simplifies a river network object by combining &quot;runs&quot; of segments with no other connections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dissolve(rivers)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dissolve_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new river network object with segments combined
</p>


<h3>Note</h3>

<p>This function is called within <a href="#topic+cleanup">cleanup</a>, which is recommended in most cases.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p>line2network
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Kenai2)
plot(x=Kenai2)

Kenai2dissolve &lt;- dissolve(rivers=Kenai2)
plot(x=Kenai2dissolve)
</code></pre>

<hr>
<h2 id='fakefish'>Dataset: Fakefish</h2><span id='topic+fakefish'></span>

<h3>Description</h3>

<p>A set of observations of Fakefish on the Gulkana River and its tributaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fakefish)
</code></pre>


<h3>Format</h3>

<p>A data frame
</p>


<h3>Details</h3>

 
<ul>
<li> <p><code>x</code>. X-coordinate of observation (Alaska Albers Equal Area). Note that the locations do not align with the river network object. 
</p>
</li>
<li> <p><code>y</code>. Y-coordinate of observation 
</p>
</li>
<li> <p><code>seg</code>. River segment (with x- and y-coordinates snapped to river network object) 
</p>
</li>
<li> <p><code>vert</code>. River vertex
</p>
</li>
<li> <p><code>fish.id</code>. Numeric identifier for each fish (individual fish were observed more than once) 
</p>
</li>
<li> <p><code>flight</code>. Numeric identifier for each telemetry flight 
</p>
</li>
<li> <p><code>flight.date</code>. Date of each telemetry flight 
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+Gulk">Gulk</a>
</p>

<hr>
<h2 id='fakefish_density'>Dataset: Fakefish Density</h2><span id='topic+fakefish_density'></span>

<h3>Description</h3>

<p>An object created by <a href="#topic+riverdensity">riverdensity</a>, describing the density of Fakefish points in the Gulkana River during ten surveys.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fakefish_density)
</code></pre>


<h3>Format</h3>

<p>A river density object, see <a href="#topic+riverdensity">riverdensity</a>, <a href="#topic+plotriverdensity">plotriverdensity</a>, <a href="#topic+riverdensity-class">riverdensity-class</a>
</p>


<h3>Details</h3>

<p>Intended for plotting using <a href="#topic+plotriverdensity">plotriverdensity</a>.
</p>

<hr>
<h2 id='Gulk'>Dataset: Gulkana River</h2><span id='topic+Gulk'></span>

<h3>Description</h3>

<p>A stretch of Gulkana River and tributaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Gulk)
</code></pre>


<h3>Format</h3>

<p>A river network object, see <a href="#topic+rivernetwork">rivernetwork</a>
</p>

<hr>
<h2 id='highlightseg'>Highlight Segments</h2><span id='topic+highlightseg'></span>

<h3>Description</h3>

<p>Plots a river network object and displays specified segments in 
bold, for easy identification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>highlightseg(seg, rivers, cex = 0.8, lwd = 3, add = FALSE, color = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="highlightseg_+3A_seg">seg</code></td>
<td>
<p>A vector of segments to highlight</p>
</td></tr>
<tr><td><code id="highlightseg_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
<tr><td><code id="highlightseg_+3A_cex">cex</code></td>
<td>
<p>The character expansion factor to use for segment labels</p>
</td></tr>
<tr><td><code id="highlightseg_+3A_lwd">lwd</code></td>
<td>
<p>The line width to use for highlighted segments</p>
</td></tr>
<tr><td><code id="highlightseg_+3A_add">add</code></td>
<td>
<p>Whether to add the highlighted segments to an existing plot 
(<code>TRUE</code>) or call a new plot (<code>FALSE</code>).  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="highlightseg_+3A_color">color</code></td>
<td>
<p>Whether to display segment labels as the same color as the 
segments.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="highlightseg_+3A_...">...</code></td>
<td>
<p>Additional plotting arguments (see <a href="graphics.html#topic+par">par</a>)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Kenai3)
plot(Kenai3)
highlightseg(seg=c(10,30,68),rivers=Kenai3)
</code></pre>

<hr>
<h2 id='homerange'>Home Range</h2><span id='topic+homerange'></span>

<h3>Description</h3>

<p>Returns the minimum observed home range for multiple
observations of each individual fish.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homerange(
  unique = NULL,
  survey = NULL,
  seg,
  vert,
  rivers,
  map = FALSE,
  algorithm = NULL,
  main = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="homerange_+3A_unique">unique</code></td>
<td>
<p>A vector of unique identifiers for each fish.  If the default (<code>NULL</code>) is used, the function will assume all observations come from a single individual.</p>
</td></tr>
<tr><td><code id="homerange_+3A_survey">survey</code></td>
<td>
<p>A vector of survey identifiers for each fish.  This argument is not needed for home range calculation, but can affect plotting (see <a href="#topic+plot.homerange">plot.homerange</a>).</p>
</td></tr>
<tr><td><code id="homerange_+3A_seg">seg</code></td>
<td>
<p>A vector of river locations (segment component).</p>
</td></tr>
<tr><td><code id="homerange_+3A_vert">vert</code></td>
<td>
<p>A vector of river locations (vertex component).</p>
</td></tr>
<tr><td><code id="homerange_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use.</p>
</td></tr>
<tr><td><code id="homerange_+3A_map">map</code></td>
<td>
<p>Deprecated, use <a href="#topic+plot.homerange">plot.homerange</a> for plotting instead.  Originally, whether to produce sanity-check maps
of observed locations and calculated home range for each fish.</p>
</td></tr>
<tr><td><code id="homerange_+3A_algorithm">algorithm</code></td>
<td>
<p>Which route detection algorithm to use (<code>"Dijkstra"</code>,
<code>"sequential"</code>, or <code>"segroutes"</code>).  If left as <code>NULL</code> (the
default), the function will automatically make a selection.  See
<a href="#topic+detectroute">detectroute</a> for more details.</p>
</td></tr>
<tr><td><code id="homerange_+3A_main">main</code></td>
<td>
<p>Deprecated, use <a href="#topic+plot.homerange">plot.homerange</a> for plotting instead.  Originally, plot title, if <code>map</code> is set to <code>TRUE</code>.  If unspecified, the unique ID will be used for the title.</p>
</td></tr>
<tr><td><code id="homerange_+3A_...">...</code></td>
<td>
<p>Deprecated, use <a href="#topic+plot.homerange">plot.homerange</a> for plotting instead.  Originally, additional plotting arguments, if <code>map</code> is set to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the <a href="#topic+homerange-class">homerange-class</a>.  The <code>$ranges</code> element is a data frame with two columns: <code>$ID</code> is a list of unique fish
(as specified by <code>unique=</code>), and <code>$range</code> is calculated minimum
home range, in the units of the coordinate system (this will likely be
meters).  The other elements are used for plotting, see <a href="#topic+homerange-class">homerange-class</a> for more details.
</p>


<h3>Note</h3>

<p>Building routes from the river mouth to each river network segment and/or distance lookup tables will
greatly reduce computation time (see <a href="#topic+buildsegroutes">buildsegroutes</a>).
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+plot.homerange">plot.homerange</a>, <a href="#topic+homerangeoverlap">homerangeoverlap</a>, <a href="#topic+plothomerangeoverlap">plothomerangeoverlap</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk, fakefish)
ranges &lt;- with(fakefish, homerange(unique=fish.id, survey=flight, seg=seg, vert=vert, rivers=Gulk))
ranges

# 19 plots will be produced, recommend calling par(mfrow=c(4,5))
plot(ranges)
plot(ranges,cumulative=TRUE,label=TRUE)

homerangeoverlap(ranges)

plothomerangeoverlap(ranges)
with(fakefish, riverpoints(seg=seg, vert=vert, rivers=Gulk))
</code></pre>

<hr>
<h2 id='homerange-class'>The &quot;homerange&quot; Class</h2><span id='topic+homerange-class'></span>

<h3>Description</h3>

<p>A class that holds information computed from the <a href="#topic+homerange">homerange</a> function.  Contains all information for plotting in <a href="#topic+plot.homerange">plot.homerange</a>.
</p>


<h3>Elements</h3>


<dl>
<dt><code>ranges</code>:</dt><dd><p>Object of class <code>"data.frame"</code>. Contains a column of the identifiers for each individual, and a column of the associated home ranges.</p>
</dd>
<dt><code>subseg_n</code>:</dt><dd><p>List of the number of times each subsegment was traveled.  The first level of the list corresponds to individual, the second level to river segment.</p>
</dd>
<dt><code>subseg_length</code>:</dt><dd><p>List of lengths of each subsegment.</p>
</dd>
<dt><code>seg, vert, unique, rivers</code>:</dt><dd><p>All inputs from the original <a href="#topic+homerange">homerange</a> call.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matt Tyers
</p>

<hr>
<h2 id='homerangeoverlap'>Home Range Overlap</h2><span id='topic+homerangeoverlap'></span>

<h3>Description</h3>

<p>Returns matrices describing the overlap of the minimum observed home range for multiple
observations of each individual fish.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homerangeoverlap(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="homerangeoverlap_+3A_x">x</code></td>
<td>
<p>An object returned from <a href="#topic+homerange">homerange</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three matrices, with <code>$either</code> giving the distances represented by the union of home ranges of each pair of individuals, and <code>$both</code> giving the distances represented by the intersection of home ranges of each pair of individuals.  Element <code>$prop_both</code> gives the proportion of overlap, defined as intersection/union.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+homerange">homerange</a>, <a href="#topic+plot.homerange">plot.homerange</a>, <a href="#topic+plothomerangeoverlap">plothomerangeoverlap</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk, fakefish)
ranges &lt;- with(fakefish, homerange(unique=fish.id, survey=flight, seg=seg, vert=vert, rivers=Gulk))
ranges

# 19 plots will be produced, recommend calling par(mfrow=c(4,5))
plot(ranges)
plot(ranges,cumulative=TRUE,label=TRUE)

homerangeoverlap(ranges)

plothomerangeoverlap(ranges)
with(fakefish, riverpoints(seg=seg, vert=vert, rivers=Gulk))
</code></pre>

<hr>
<h2 id='isflowconnected'>Check Flow-Connectedness</h2><span id='topic+isflowconnected'></span>

<h3>Description</h3>

<p>Checks to see if two segments are flow-connected.  Called internally within <a href="#topic+riverdirection">riverdirection</a> and <a href="#topic+upstream">upstream</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isflowconnected(seg1, seg2, rivers, stopiferror = TRUE, algorithm = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isflowconnected_+3A_seg1">seg1</code></td>
<td>
<p>First input segment</p>
</td></tr>
<tr><td><code id="isflowconnected_+3A_seg2">seg2</code></td>
<td>
<p>Second input segment</p>
</td></tr>
<tr><td><code id="isflowconnected_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
<tr><td><code id="isflowconnected_+3A_stopiferror">stopiferror</code></td>
<td>
<p>Whether or not to exit with an error if a route cannot be
found.  If this is set to <code>FALSE</code> and a route cannot be found,
the function will return <code>NA</code> in the appropriate entry.  Defaults to <code>TRUE</code>.  See <a href="#topic+detectroute">detectroute</a>.</p>
</td></tr>
<tr><td><code id="isflowconnected_+3A_algorithm">algorithm</code></td>
<td>
<p>Which route detection algorithm to use (<code>"Dijkstra"</code>,
<code>"sequential"</code>, or <code>"segroutes"</code>).  If left as <code>NULL</code> (the
default), the function will automatically make a selection.  See
<a href="#topic+detectroute">detectroute</a> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical <code>TRUE</code> if the two segments are flow-connected, <code>FALSE</code> if they are not
</p>


<h3>Note</h3>

<p>The river mouth must be specified (see <a href="#topic+setmouth">setmouth</a>).
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk)
plot(Gulk)

Gulk &lt;- setmouth(seg=1, vert=1, rivers=Gulk)

isflowconnected(seg1=13, seg2=14, rivers=Gulk)
isflowconnected(seg1=13, seg2=1, rivers=Gulk)
</code></pre>

<hr>
<h2 id='Kenai1'>Dataset: Kenai River 1</h2><span id='topic+Kenai1'></span>

<h3>Description</h3>

<p>A first pass at a messy river network object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Kenai1)
</code></pre>


<h3>Format</h3>

<p>A river network object, see <a href="#topic+rivernetwork">rivernetwork</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+Kenai2">Kenai2</a>, <a href="#topic+Kenai3">Kenai3</a>
</p>

<hr>
<h2 id='Kenai2'>Dataset: Kenai River 2</h2><span id='topic+Kenai2'></span>

<h3>Description</h3>

<p>A second pass at a messy river network object.  In this iteration of cleanup,
several non-connected segments have been removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Kenai2)
</code></pre>


<h3>Format</h3>

<p>A river network object, see <a href="#topic+rivernetwork">rivernetwork</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+Kenai1">Kenai1</a>, <a href="#topic+Kenai3">Kenai3</a>
</p>

<hr>
<h2 id='Kenai3'>Dataset: Kenai River 3</h2><span id='topic+Kenai3'></span>

<h3>Description</h3>

<p>A third pass at a messy river network object.  In this iteration of cleanup,
several non-connected segments have been removed, and several series of
segments have been dissolved into single segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Kenai3)
</code></pre>


<h3>Format</h3>

<p>A river network object, see <a href="#topic+rivernetwork">rivernetwork</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+Kenai1">Kenai1</a>, <a href="#topic+Kenai2">Kenai2</a>
</p>

<hr>
<h2 id='kfunc'>Plotting K-functions for a Set of Surveys</h2><span id='topic+kfunc'></span>

<h3>Description</h3>

<p>Plots K-functions for locations in each of a set of surveys.  In
this implementation, this can be interpreted as the proportion of 
additional fish within a given distance.  This will increase as a function 
of distance, and may provide evidence of clustering or dispersion features,
particularly if the envelope is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kfunc(
  seg,
  vert,
  survey = NULL,
  rivers,
  lwd = 2,
  envelope = TRUE,
  envreps = 1000,
  envcol = "grey80",
  envborder = NA,
  maxdist = NULL,
  xlab = "Distance",
  ylab = "% within",
  showN = TRUE,
  whichplots = NULL,
  returnoutput = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kfunc_+3A_seg">seg</code></td>
<td>
<p>A vector of river locations (segment)</p>
</td></tr>
<tr><td><code id="kfunc_+3A_vert">vert</code></td>
<td>
<p>A vector of river locations (vertex)</p>
</td></tr>
<tr><td><code id="kfunc_+3A_survey">survey</code></td>
<td>
<p>A vector of survey IDs corresponding to the values of 
<code>seg</code> and <code>vert</code>.  Defaults to <code>NULL</code>.  If this argument is 
used, K-functions will be calculated for each unique survey, and separate 
plots will be produced.</p>
</td></tr>
<tr><td><code id="kfunc_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
<tr><td><code id="kfunc_+3A_lwd">lwd</code></td>
<td>
<p>Line width used for plotting.  Defaults to 2.</p>
</td></tr>
<tr><td><code id="kfunc_+3A_envelope">envelope</code></td>
<td>
<p>Whether to construct and display a 95 percent confidence 
envelope (see note.)  Defaults to <code>TRUE</code> if <code>survey</code> is specified, and is automatically <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="kfunc_+3A_envreps">envreps</code></td>
<td>
<p>Number of bootstrap replicates to use for envelope 
calculation.  Defaults to 1000.</p>
</td></tr>
<tr><td><code id="kfunc_+3A_envcol">envcol</code></td>
<td>
<p>Color to use for envelope plotting.  Defaults to 
<code>"grey80"</code>.</p>
</td></tr>
<tr><td><code id="kfunc_+3A_envborder">envborder</code></td>
<td>
<p>Border color to use for envelope plotting.  Defaults to 
<code>NA</code>, which will result in no border being plotted.</p>
</td></tr>
<tr><td><code id="kfunc_+3A_maxdist">maxdist</code></td>
<td>
<p>Maximum distance (x-axis value) for plotting.  The default 
value (<code>NULL</code>) will result in an appropriate value being chosen.</p>
</td></tr>
<tr><td><code id="kfunc_+3A_xlab">xlab</code></td>
<td>
<p>X-coordinate label for plotting</p>
</td></tr>
<tr><td><code id="kfunc_+3A_ylab">ylab</code></td>
<td>
<p>Y-coordinate label for plotting</p>
</td></tr>
<tr><td><code id="kfunc_+3A_shown">showN</code></td>
<td>
<p>Whether to show the sample size for each survey in each plot 
title.  Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="kfunc_+3A_whichplots">whichplots</code></td>
<td>
<p>A vector of plots to produce, if multiple plots are 
produced.  For example, specifying <code>whichplot=c(2,3,4)</code> will result in
only the second, third, and fourth plots of the sequence being produced. 
Accepting the default (<code>NULL</code>) will result in all plots being 
produced.</p>
</td></tr>
<tr><td><code id="kfunc_+3A_returnoutput">returnoutput</code></td>
<td>
<p>Whether to return output instead of producing a plot.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kfunc_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>K-function envelopes for each survey are constructed by bootstrapping 
all within-survey distances, that is, the distances between all individuals
within each survey, for all surveys.  This results in a confidence envelope
under the assumption that spacing is independent of survey; therefore a
survey K-function outside the envelope provides evidence of clustering or 
dispersal in that survey that is outside the typical range.  An envelope is not available if only one survey is plotted.
</p>
<p>A K-function above the envelope for a given distance range provides
evidence of a greater number of individuals than expected at that distance
range (clustering); A K-function below the envelope for a given distance
range provides evidence of a smaller number of individuals than expected at
that distance range (dispersal).
</p>
<p>This function is distance-computation intensive, and will be extremely slow-running if a river network is used that does not have segment routes and/or distance lookup tables for fast distance computation.  See <a href="#topic+buildsegroutes">buildsegroutes</a> and/or <a href="#topic+buildlookup">buildlookup</a> for more information.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk, fakefish)

# # 10 plots will be created - recommend calling
# # par(mfrow=c(3,4))

kfunc(seg=fakefish$seg, vert=fakefish$vert, rivers=Gulk, survey=fakefish$flight,
envreps=100, maxdist=200000)

# # This shows relatively high amounts of clustering for surveys 1 and 8,
# # and relatively high amounts of dispersal in surveys 5 and 6.


# # plotting the survey locations that led to this calculation, for comparison

# # 10 plots will be created - recommend calling
# # par(mfrow=c(3,4))
for(i in 1:10) {
  plot(x=Gulk, segmentnum=FALSE, color=FALSE, main=i)
  riverpoints(seg=fakefish$seg[fakefish$flight==i], 
  vert=fakefish$vert[fakefish$flight==i], rivers=Gulk, col=2, pch=15)
}
</code></pre>

<hr>
<h2 id='KilleyW'>Dataset: Killey River, West Channel</h2><span id='topic+KilleyW'></span>

<h3>Description</h3>

<p>A messy and braided section of the Kenai River network - actually a subset of <a href="#topic+Kenai3">Kenai3</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(KilleyW)
</code></pre>


<h3>Format</h3>

<p>A river network object, see <a href="#topic+rivernetwork">rivernetwork</a>
</p>

<hr>
<h2 id='Koyukuk0'>Dataset: Koyukuk River 0</h2><span id='topic+Koyukuk0'></span>

<h3>Description</h3>

<p>An unusably messy river network object, included for the purpose of testing river network editing functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Koyukuk0)
</code></pre>


<h3>Format</h3>

<p>A river network object, see <a href="#topic+rivernetwork">rivernetwork</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+Koyukuk1">Koyukuk1</a>, <a href="#topic+Koyukuk2">Koyukuk2</a>
</p>

<hr>
<h2 id='Koyukuk1'>Dataset: Koyukuk River 1</h2><span id='topic+Koyukuk1'></span>

<h3>Description</h3>

<p>A first pass at a messy river network object.  The way it was dissolved in
ArcGIS makes the endpoints appear disconnected to <a href="#topic+line2network">line2network</a> and the
topologies do not work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Koyukuk1)
</code></pre>


<h3>Format</h3>

<p>A river network object, see <a href="#topic+rivernetwork">rivernetwork</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+Koyukuk2">Koyukuk2</a>
</p>

<hr>
<h2 id='Koyukuk2'>Dataset: Koyukuk River 2</h2><span id='topic+Koyukuk2'></span>

<h3>Description</h3>

<p>A second pass at a messy river network object, with topologies fixed from <a href="#topic+Koyukuk1">Koyukuk1</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Koyukuk2)
</code></pre>


<h3>Format</h3>

<p>A river network object, see <a href="#topic+rivernetwork">rivernetwork</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+Koyukuk1">Koyukuk1</a>
</p>

<hr>
<h2 id='line2network'>Create a River Network Object from a Shapefile</h2><span id='topic+line2network'></span>

<h3>Description</h3>

<p>Uses <a href="sf.html#topic+read_sf">read_sf</a> in package 'sf' to read a river 
shapefile, and establishes connectivity of segment endpoints based on 
spatial proximity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>line2network(
  sf = NULL,
  path = ".",
  layer = NA,
  tolerance = 100,
  reproject = NULL,
  autofix = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="line2network_+3A_sf">sf</code></td>
<td>
<p>Optional input as an <a href="sf.html#topic+sf">sf</a> object, if shapefile has 
already been read into the R environment.</p>
</td></tr>
<tr><td><code id="line2network_+3A_path">path</code></td>
<td>
<p>File path, default is the current working directory.</p>
</td></tr>
<tr><td><code id="line2network_+3A_layer">layer</code></td>
<td>
<p>Name of the shapefile, without the .shp extension.</p>
</td></tr>
<tr><td><code id="line2network_+3A_tolerance">tolerance</code></td>
<td>
<p>Snapping tolerance of segment endpoints to determine 
connectivity.  Default is 100, therefore care should be exercised when 
working with larger units of distance, such as km.</p>
</td></tr>
<tr><td><code id="line2network_+3A_reproject">reproject</code></td>
<td>
<p>A valid projection, if the shapefile is to be 
re-projected.  Re-projection is done using <a href="sf.html#topic+st_transform">st_transform</a> in 
package 'sf'.</p>
</td></tr>
<tr><td><code id="line2network_+3A_autofix">autofix</code></td>
<td>
<p>Whether to automatically apply two corrections: removal of 
duplicate segments, and segments with lengths shorter than the connectivity 
tolerance.  Defaults to 'TRUE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>"rivernetwork"</code> containing all
spatial and topological information.  See <a href="#topic+rivernetwork-class">rivernetwork-class</a>.
</p>


<h3>Note</h3>

<p>Since distance can only be calculated using projected coordinates, 
<code>line2network()</code> will generate an error if a non-projected input 
shapefile is detected.  To resolve this, the shapefile can be re-projected 
in a GIS environment, or using <code>reproject=</code>, shown in the second 
example below.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers, Jemma Stachelek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filepath &lt;- system.file("extdata", package="riverdist")

Gulk_UTM5 &lt;- line2network(path=filepath, layer="Gulk_UTM5")
plot(Gulk_UTM5)

## Reading directly from an sf object

sf &lt;- sf::read_sf(dsn = filepath, layer = "Gulk_UTM5")
Gulk_UTM5 &lt;- line2network(sf=sf)
plot(Gulk_UTM5)

## Re-projecting in Alaska Albers Equal Area projection:

AKalbers &lt;- "+proj=aea +lat_1=55 +lat_2=65 +lat_0=50 +lon_0=-154 
    +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80"
    
Gulk_AKalbers &lt;- line2network(path=filepath, layer="Gulk_UTM5", reproject=AKalbers)
plot(Gulk_AKalbers)

</code></pre>

<hr>
<h2 id='line98'>Dataset: Line 98 of Kenai River 1 (Long-Lat)</h2><span id='topic+line98'></span>

<h3>Description</h3>

<p>A matrix of coordinates in longitude-latitude, used to illustrate coordinate
transformation.  Coordinates come from arbitrary line number 98 in the Kenai
River 1 shapefile, rendered in long-lat.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(line98)
</code></pre>


<h3>Format</h3>

<p>A matrix of values
</p>

<hr>
<h2 id='makeriverdensity'>Calculate Kernel Density Using River Distance</h2><span id='topic+makeriverdensity'></span>

<h3>Description</h3>

<p>Uses spatial point data (segment and vertex) to calculate a 
kernel density object to use in the output class plotting method,<a href="#topic+plot.riverdensity">plot.riverdensity</a>. Scaled kernel 
density is calculated at approximately regularly-spaced locations, with 
spacing specified by the user.
</p>
<p>If an argument is used in the <code>survey</code> field, kernel densities will be
calculated for each unique value of <code>survey</code>, resulting in a separate 
plot for each.
</p>
<p>The purpose of this function is to generate a kernel density object to plot
using plot(), see <a href="#topic+plot.riverdensity">plot.riverdensity</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeriverdensity(
  seg,
  vert,
  rivers,
  survey = NULL,
  kernel = "gaussian",
  bw = NULL,
  resolution = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeriverdensity_+3A_seg">seg</code></td>
<td>
<p>A vector of river locations (segment)</p>
</td></tr>
<tr><td><code id="makeriverdensity_+3A_vert">vert</code></td>
<td>
<p>A vector of river locations (vertex)</p>
</td></tr>
<tr><td><code id="makeriverdensity_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
<tr><td><code id="makeriverdensity_+3A_survey">survey</code></td>
<td>
<p>A vector of survey IDs corresponding to the values of 
<code>seg</code> and <code>vert</code>.  If this argument is used, kernel densities 
will be calculated for each unique survey, and separate plots will be 
produced.</p>
</td></tr>
<tr><td><code id="makeriverdensity_+3A_kernel">kernel</code></td>
<td>
<p>The type of density kernel to use.  Allowed types are 
<code>"gaussian"</code> (normal) and <code>"rect"</code> (rectangular, giving simple 
density).  Defaults to <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="makeriverdensity_+3A_bw">bw</code></td>
<td>
<p>The kernel bandwidth to use.  If <code>kernel</code> is set to 
<code>"gaussian"</code>, this provides the standard deviation of the gaussian 
(normal) kernel to use.  If <code>kernel</code> is set to <code>"rect"</code>, this 
provides the half-width of the rectangular kernel, or the distance to use 
in simple density.  Accepting the default (<code>NULL</code>) will result in the 
function determining a value to use, based on the total length of the river
network and the value of the <code>resolution</code> argument.</p>
</td></tr>
<tr><td><code id="makeriverdensity_+3A_resolution">resolution</code></td>
<td>
<p>The approximate spacing of the river locations used for
kernel density calculation.  Accepting the default (<code>NULL</code>) will
result in the function determining a value to use, based on the total
length of the river network.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A river density object, see <a href="#topic+riverdensity-class">riverdensity-class</a>.
</p>


<h3>Note</h3>

<p>It is likely that calculation will be very slow.  Use of this function 
with a river network for which segment routes has not yet been calculated 
is not recommended.
</p>
<p>This function is distance-computation intensive, and may be slow-running if a river network is used that does not have segment routes and/or distance lookup tables for fast distance computation.  See <a href="#topic+buildsegroutes">buildsegroutes</a> and/or <a href="#topic+buildlookup">buildlookup</a> for more information.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+plot.riverdensity">plot.riverdensity</a>, <a href="#topic+densityanomaly">densityanomaly</a>, <a href="#topic+plotriverdensitypoints">plotriverdensitypoints</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk, fakefish)

Gulk_dens &lt;- makeriverdensity(seg=fakefish$seg, vert=fakefish$vert, rivers=Gulk, 
  survey=fakefish$flight.date)
  
# # 10 plots will be created, recommend calling par(mfrow=c(2,5))
plot(x=Gulk_dens)
</code></pre>

<hr>
<h2 id='mapbyname'>Map Segments by Name</h2><span id='topic+mapbyname'></span>

<h3>Description</h3>

<p>Provides a check that river network segments were appropriately
named.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapbyname(rivers, scale = TRUE, cex = 0.6, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mapbyname_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use.  Function checks segment names
contained in the river network object.</p>
</td></tr>
<tr><td><code id="mapbyname_+3A_scale">scale</code></td>
<td>
<p>Whether or not to give x- and y-axes the same scale</p>
</td></tr>
<tr><td><code id="mapbyname_+3A_cex">cex</code></td>
<td>
<p>Global character expansion factor for plotting</p>
</td></tr>
<tr><td><code id="mapbyname_+3A_...">...</code></td>
<td>
<p>Additional plotting arguments (see <a href="graphics.html#topic+par">par</a>)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk)
str(Gulk)

Gulk$names &lt;- c("Gulkana River","Trib 1","West Fork","Gulkana River","Trib 1",
                "West Fork","Trib 2","West Fork","Twelvemile Creek","Gulkana River",
                "Middle Fork","Gulkana River","Middle Fork","Hungry Hollow")
str(Gulk)

mapbyname(rivers=Gulk)
</code></pre>

<hr>
<h2 id='matbysurveylist'>Generate List of Distance Matrix Between Observations, for All Individuals</h2><span id='topic+matbysurveylist'></span>

<h3>Description</h3>

<p>Returns a list of matrices, each giving the river distance, direction, or upstream travel distance between all observations of
one unique fish.  This function is principally intended for producing an object to plot in <a href="#topic+plotmatbysurveylist">plotmatbysurveylist</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matbysurveylist(
  unique,
  survey,
  seg,
  vert,
  rivers,
  indiv = NULL,
  method = "upstream",
  flowconnected = FALSE,
  net = FALSE,
  stopiferror = TRUE,
  algorithm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matbysurveylist_+3A_unique">unique</code></td>
<td>
<p>A vector of unique identifiers for each fish.</p>
</td></tr>
<tr><td><code id="matbysurveylist_+3A_survey">survey</code></td>
<td>
<p>A vector of identifiers for each survey.  It is recommended to 
use a numeric or date format (see <a href="base.html#topic+as.Date">as.Date</a>) to preserve survey order.</p>
</td></tr>
<tr><td><code id="matbysurveylist_+3A_seg">seg</code></td>
<td>
<p>A vector of river locations (segment component).</p>
</td></tr>
<tr><td><code id="matbysurveylist_+3A_vert">vert</code></td>
<td>
<p>A vector of river locations (vertex component).</p>
</td></tr>
<tr><td><code id="matbysurveylist_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use.</p>
</td></tr>
<tr><td><code id="matbysurveylist_+3A_indiv">indiv</code></td>
<td>
<p>A vector of unique individuals to use.  Accepting the default (<code>NULL</code>) will result in a matrix being returned for all unique individuals.</p>
</td></tr>
<tr><td><code id="matbysurveylist_+3A_method">method</code></td>
<td>
<p>Which general method to use.  Setting <code>method="distance"</code> will compute distance for each pair of observation, setting <code>method="direction"</code> will compute direction between each pair of observation, and setting <code>method="upstream"</code> will compute directional (upstream) distance between each pair of observation.  Defaults to <code>"upstream"</code>.</p>
</td></tr>
<tr><td><code id="matbysurveylist_+3A_flowconnected">flowconnected</code></td>
<td>
<p>Optional parameter to pass to the distance or direction calculation.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="matbysurveylist_+3A_net">net</code></td>
<td>
<p>Optional parameter to pass to the distance or direction calculation.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="matbysurveylist_+3A_stopiferror">stopiferror</code></td>
<td>
<p>Optional parameter to pass to the distance or direction calculation.  Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="matbysurveylist_+3A_algorithm">algorithm</code></td>
<td>
<p>Optional parameter to pass to the distance or direction calculation.  Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with each element corresponding to a unique fish.  Each list element is the output from either <a href="#topic+riverdistancematbysurvey">riverdistancematbysurvey</a>, <a href="#topic+riverdirectionmatbysurvey">riverdirectionmatbysurvey</a>, or <a href="#topic+upstreammatbysurvey">upstreammatbysurvey</a>.
</p>


<h3>Note</h3>

<p>Building routes from the river mouth to each river network segment and/or distance lookup tables will
greatly reduce computation time (see <a href="#topic+buildsegroutes">buildsegroutes</a>).
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+riverdistance">riverdistance</a>, <a href="#topic+riverdirection">riverdirection</a>, <a href="#topic+upstream">upstream</a>, <a href="#topic+riverdistancematbysurvey">riverdistancematbysurvey</a>, <a href="#topic+riverdirectionmatbysurvey">riverdirectionmatbysurvey</a>, <a href="#topic+upstreammatbysurvey">upstreammatbysurvey</a>, <a href="#topic+plotmatbysurveylist">plotmatbysurveylist</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk, smallset)
matbysurveylist &lt;- matbysurveylist(unique=smallset$id, survey=smallset$flight, seg=smallset$seg, 
   vert=smallset$vert, rivers=Gulk)
plotmatbysurveylist(matbysurveylist)
plotmatbysurveylist(matbysurveylist,type="confint")
plotmatbysurveylist(matbysurveylist,type="dotplot")
   
data(fakefish)
# matbysurveylist &lt;- matbysurveylist(unique=fakefish$fish.id, survey=fakefish$flight, 
#   seg=fakefish$seg, vert=fakefish$vert, rivers=Gulk)
# plotmatbysurveylist(matbysurveylist)
</code></pre>

<hr>
<h2 id='mouthdist'>Distance From Mouth</h2><span id='topic+mouthdist'></span>

<h3>Description</h3>

<p>Calculates distance from river locations (given as vectors of segment and
vertex) and the specified mouth of the river network.  The mouth must first
be specified (see <a href="#topic+setmouth">setmouth</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mouthdist(seg, vert, rivers, stopiferror = TRUE, algorithm = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mouthdist_+3A_seg">seg</code></td>
<td>
<p>Vector of segments</p>
</td></tr>
<tr><td><code id="mouthdist_+3A_vert">vert</code></td>
<td>
<p>Vector of vertices</p>
</td></tr>
<tr><td><code id="mouthdist_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
<tr><td><code id="mouthdist_+3A_stopiferror">stopiferror</code></td>
<td>
<p>Whether or not to exit with an error if a route cannot be
found.  If this is set to <code>FALSE</code> and a route cannot be found,
the function will return <code>NA</code> in the appropriate entry.  Defaults to <code>TRUE</code>.  See <a href="#topic+detectroute">detectroute</a>.</p>
</td></tr>
<tr><td><code id="mouthdist_+3A_algorithm">algorithm</code></td>
<td>
<p>Which route detection algorithm to use (<code>"Dijkstra"</code>,
<code>"sequential"</code>, or <code>"segroutes"</code>).  If left as <code>NULL</code> (the
default), the function will automatically make a selection.  See
<a href="#topic+detectroute">detectroute</a> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Distance (numeric)
</p>


<h3>Note</h3>

<p>Building routes from the river mouth to each river network segment and/or distance lookup tables will
greatly reduce computation time (see <a href="#topic+buildsegroutes">buildsegroutes</a>).
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk)

# Mouth must be specified
Gulk$mouth$mouth.seg &lt;- 1
Gulk$mouth$mouth.vert &lt;- 1

mouthdist(seg=4, vert=40, rivers=Gulk)
mouthdist(seg=c(4,5), vert=c(40,20), rivers=Gulk)
</code></pre>

<hr>
<h2 id='mouthdistbysurvey'>Distance From Mouth for All Observations of Individuals</h2><span id='topic+mouthdistbysurvey'></span>

<h3>Description</h3>

<p>Calculates distance from the mouth of a river network to all 
observations of each individual (given as segment and vertex). and the 
specified mouth of the river network.  The mouth must first be specified 
(see <a href="#topic+setmouth">setmouth</a>).  Returns a matrix of distances, with a row for each 
unique individual and a column for each survey.
</p>
<p>A plotting method is provided for the output; see <a href="#topic+plotseq">plotseq</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mouthdistbysurvey(
  unique,
  survey,
  seg,
  vert,
  rivers,
  logical = NULL,
  stopiferror = TRUE,
  algorithm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mouthdistbysurvey_+3A_unique">unique</code></td>
<td>
<p>A vector of identifiers for each fish.</p>
</td></tr>
<tr><td><code id="mouthdistbysurvey_+3A_survey">survey</code></td>
<td>
<p>A vector of identifiers for each survey.  It is recommended to
use a numeric or date format (see <a href="base.html#topic+as.Date">as.Date</a>) to preserve survey order.</p>
</td></tr>
<tr><td><code id="mouthdistbysurvey_+3A_seg">seg</code></td>
<td>
<p>A vector of river locations (segment)</p>
</td></tr>
<tr><td><code id="mouthdistbysurvey_+3A_vert">vert</code></td>
<td>
<p>A vector pf rover coordinates (vertex)</p>
</td></tr>
<tr><td><code id="mouthdistbysurvey_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
<tr><td><code id="mouthdistbysurvey_+3A_logical">logical</code></td>
<td>
<p>A boolean vector that can be used for subsetting - if used, 
<code>mouthdistbysurvey()</code> will only return distances in which a specified
condition is met.</p>
</td></tr>
<tr><td><code id="mouthdistbysurvey_+3A_stopiferror">stopiferror</code></td>
<td>
<p>Whether or not to exit with an error if a route cannot be 
found.  If this is set to <code>FALSE</code> and a route cannot be found, the 
function will return <code>NA</code> in the appropriate entry.  Defaults to 
<code>TRUE</code>.  See <a href="#topic+detectroute">detectroute</a>.</p>
</td></tr>
<tr><td><code id="mouthdistbysurvey_+3A_algorithm">algorithm</code></td>
<td>
<p>Which route detection algorithm to use (<code>"Dijkstra"</code>, 
<code>"sequential"</code>, or <code>"segroutes"</code>).  If left as <code>NULL</code> (the 
default), the function will automatically make a selection.  See 
<a href="#topic+detectroute">detectroute</a> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of river network distances (numeric), with each row
corresponding to a unique fish and each column corresponding to a unique
survey.  Values of <code>NA</code> indicate the individual not being located
during the survey in question.
</p>


<h3>Note</h3>

<p>Building routes from the river mouth to each river network segment and/or distance lookup tables will
greatly reduce computation time (see <a href="#topic+buildsegroutes">buildsegroutes</a>).
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+plotseq">plotseq</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk, fakefish)

seqbysurvey &lt;- mouthdistbysurvey(unique=fakefish$fish.id, survey=fakefish$flight.date, 
    seg=fakefish$seg, vert=fakefish$vert, rivers=Gulk)
seqbysurvey
plotseq(seqbysurvey)
</code></pre>

<hr>
<h2 id='pdist'>Pythagorean Distance</h2><span id='topic+pdist'></span>

<h3>Description</h3>

<p>Pythagorean distance between two points.  Called internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdist(p1, p2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pdist_+3A_p1">p1</code></td>
<td>
<p>X-Y coordinates of point 1</p>
</td></tr>
<tr><td><code id="pdist_+3A_p2">p2</code></td>
<td>
<p>X-Y coordinates of point 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Distance (numeric)
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>point1 &lt;- c(1,3)
point2 &lt;- c(4,7)

pdist(point1,point2)
</code></pre>

<hr>
<h2 id='pdisttot'>Total Pythagorean Distance</h2><span id='topic+pdisttot'></span>

<h3>Description</h3>

<p>Total Pythagorean distance of a sequence of points.  Called internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdisttot(xy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pdisttot_+3A_xy">xy</code></td>
<td>
<p>A matrix of X-Y coordinates of the sequence of points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Distance (numeric)
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>points &lt;- matrix(c(1:10), nrow=5, ncol=2, byrow=FALSE)

pdisttot(xy=points)
</code></pre>

<hr>
<h2 id='plot.homerange'>Plot Home Range</h2><span id='topic+plot.homerange'></span>

<h3>Description</h3>

<p>Plotting method for home range, the minimum observed home range for multiple
observations of each individual fish.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'homerange'
plot(
  x,
  cumulative = FALSE,
  lwd = 3,
  maxlwd = 10,
  col = 4,
  pch = 21,
  label = FALSE,
  main = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.homerange_+3A_x">x</code></td>
<td>
<p>An object returned from <a href="#topic+homerange">homerange</a>.</p>
</td></tr>
<tr><td><code id="plot.homerange_+3A_cumulative">cumulative</code></td>
<td>
<p>Whether to plot travel as cumulative, with line thickness depending on the number of times a given region was traveled by a given individual.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.homerange_+3A_lwd">lwd</code></td>
<td>
<p>The line width for plotting homerange, or minimum line width if <code>cumulative</code> is <code>TRUE</code>.  Defaults to 3.</p>
</td></tr>
<tr><td><code id="plot.homerange_+3A_maxlwd">maxlwd</code></td>
<td>
<p>The maximum line width if <code>cumulative</code> is <code>TRUE</code>.  Defaults to 10.</p>
</td></tr>
<tr><td><code id="plot.homerange_+3A_col">col</code></td>
<td>
<p>The line color to use.  Defaults to <code>"blue"</code>.</p>
</td></tr>
<tr><td><code id="plot.homerange_+3A_pch">pch</code></td>
<td>
<p>The point character to use for individual points.  Defaults to open circles, the color of lines.</p>
</td></tr>
<tr><td><code id="plot.homerange_+3A_label">label</code></td>
<td>
<p>Whether to add survey labels to individual points, if used in <a href="#topic+homerange">homerange</a>.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.homerange_+3A_main">main</code></td>
<td>
<p>Plot title.  If the default <code>NULL</code> is used, plots will be titled according to unique individual.</p>
</td></tr>
<tr><td><code id="plot.homerange_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters, see <a href="#topic+plot.rivernetwork">plot.rivernetwork</a>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Tyers, bug fix by Jordy Bernard
</p>


<h3>See Also</h3>

<p><a href="#topic+homerange">homerange</a>, <a href="#topic+homerangeoverlap">homerangeoverlap</a>, <a href="#topic+plothomerangeoverlap">plothomerangeoverlap</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk, fakefish)
ranges &lt;- with(fakefish, homerange(unique=fish.id, survey=flight, seg=seg, vert=vert, rivers=Gulk))
ranges

# 19 plots will be produced, recommend calling par(mfrow=c(4,5))
plot(ranges)
plot(ranges,cumulative=TRUE,label=TRUE)

homerangeoverlap(ranges)

plothomerangeoverlap(ranges)
with(fakefish, riverpoints(seg=seg, vert=vert, rivers=Gulk))
</code></pre>

<hr>
<h2 id='plot.riverdensity'>Plot Kernel Density Using River Distance</h2><span id='topic+plot.riverdensity'></span><span id='topic+plotriverdensity'></span>

<h3>Description</h3>

<p>Produces a kernel density plot from a kernel density object 
created by <a href="#topic+makeriverdensity">makeriverdensity</a>.
</p>
<p>If the kernel density object includes densities from multiple surveys, a 
new plot will be created for each survey.
</p>
<p>Densities can be displayed using either line widths, color, or both.
</p>
<p>The relative densities that are displayed in the plot are calculated 
according to the form (density/maxdensity)^pwr, with the value of pwr set 
by the <code>pwr</code> argument.  Setting <code>pwr</code> to a value less than 1 
allows smaller values to be more visible on the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'riverdensity'
plot(
  x,
  whichplots = NULL,
  points = TRUE,
  bycol = TRUE,
  bylwd = TRUE,
  maxlwd = 10,
  pwr = 0.7,
  scalebyN = TRUE,
  ramp = c("grey", "gray", "red", "green", "blue", "heat", "stoplight", "rainbow"),
  lwd = 1,
  linecol = NULL,
  denscol = NULL,
  alpha = 1,
  dark = 1,
  showN = TRUE,
  main = NULL,
  xlab = "",
  ylab = "",
  add = FALSE,
  scalebar = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.riverdensity_+3A_x">x</code></td>
<td>
<p>A river density object created by <a href="#topic+makeriverdensity">makeriverdensity</a>.</p>
</td></tr>
<tr><td><code id="plot.riverdensity_+3A_whichplots">whichplots</code></td>
<td>
<p>A vector of plots to produce, if multiple plots are 
produced.  For example, specifying <code>whichplot=c(2,3,4)</code> will result in
only the second, third, and fourth plots of the sequence being produced. 
Accepting the default (<code>NULL</code>) will result in all plots being 
produced.</p>
</td></tr>
<tr><td><code id="plot.riverdensity_+3A_points">points</code></td>
<td>
<p>Whether to add the points used for density calculation. 
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.riverdensity_+3A_bycol">bycol</code></td>
<td>
<p>Whether to use a color ramp to show densities.  Defaults to 
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.riverdensity_+3A_bylwd">bylwd</code></td>
<td>
<p>Whether to use line thickness to show densities.  Defaults to 
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.riverdensity_+3A_maxlwd">maxlwd</code></td>
<td>
<p>The maximum line width to use if <code>bylwd</code> is set to 
<code>TRUE</code>.  Defaults to 10.</p>
</td></tr>
<tr><td><code id="plot.riverdensity_+3A_pwr">pwr</code></td>
<td>
<p>The power to use in the nonlinear transformation calculating the 
relative density values to be displayed (see above.)  Defaults to 0.7.</p>
</td></tr>
<tr><td><code id="plot.riverdensity_+3A_scalebyn">scalebyN</code></td>
<td>
<p>Whether to display relative density values scaled by sample
size.  Specifying <code>scalebyN=TRUE</code> will show larger density values
associated with surveys with more points, and may be more appropriate for
displaying total density.  Specifying <code>scalebyN=FALSE</code> will allow
surveys with smaller sample sizes to be plotted with similar density values
as those with larger sample sizes, and may be more appropriate for
displaying relative density.  Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.riverdensity_+3A_ramp">ramp</code></td>
<td>
<p>The color ramp used to display densities if <code>bycol</code> is set 
to <code>TRUE</code>.  Allowed values are <code>"grey"</code> (or <code>"gray"</code>), 
<code>"red"</code>, <code>"green"</code>, <code>"blue"</code>, <code>"heat"</code>, 
<code>"stoplight"</code>, and <code>"rainbow"</code>.  Defaults to <code>"grey"</code>.</p>
</td></tr>
<tr><td><code id="plot.riverdensity_+3A_lwd">lwd</code></td>
<td>
<p>The line width to use for background lines if <code>bylwd</code> is set 
to <code>TRUE</code>, or all lines if <code>bylwd</code> is set to <code>FALSE</code>. 
Defaults to 1.</p>
</td></tr>
<tr><td><code id="plot.riverdensity_+3A_linecol">linecol</code></td>
<td>
<p>The line color to use for background lines if <code>bycol</code> is 
set to <code>FALSE</code>.  If the default 'NULL' is accepted, <code>"black"</code> lines will be drawn.</p>
</td></tr>
<tr><td><code id="plot.riverdensity_+3A_denscol">denscol</code></td>
<td>
<p>The line color to use for showing density if <code>bycol</code> is 
set to <code>FALSE</code>.  If the default 'NULL' is accepted, <code>"black"</code> lines will be drawn.</p>
</td></tr>
<tr><td><code id="plot.riverdensity_+3A_alpha">alpha</code></td>
<td>
<p>The opacity value for lines.  This could potentially allow 
multiple density plots to be overlayed with different colors.</p>
</td></tr>
<tr><td><code id="plot.riverdensity_+3A_dark">dark</code></td>
<td>
<p>A color-saturation adjustment, with values in [0,1].  A value of 
1 uses the true colors, and a value less than 1 will render the colors as 
slightly darker (less saturated), which may be appear better.  Defaults to 
1.</p>
</td></tr>
<tr><td><code id="plot.riverdensity_+3A_shown">showN</code></td>
<td>
<p>Whether to automatically include the number of points used as 
part of the plot title(s).</p>
</td></tr>
<tr><td><code id="plot.riverdensity_+3A_main">main</code></td>
<td>
<p>Plot title(s), either given as a single text string which is 
repeated if multiple plots are produced, or a vector of text strings (one 
for each plot produced).  If multiple plots are produced (resulting from 
multiple surveys), accepting the default (<code>NULL</code>) will result in each 
unique value of survey being used as the plot title, along with the sample 
size if <code>showN</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.riverdensity_+3A_xlab">xlab</code></td>
<td>
<p>X-axis label</p>
</td></tr>
<tr><td><code id="plot.riverdensity_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis label</p>
</td></tr>
<tr><td><code id="plot.riverdensity_+3A_add">add</code></td>
<td>
<p>Whether to produce a new plot (<code>FALSE</code>), or add to an 
existing plot (<code>TRUE</code>).  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.riverdensity_+3A_scalebar">scalebar</code></td>
<td>
<p>Whether to add a scale bar to plot(s).  Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.riverdensity_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+makeriverdensity">makeriverdensity</a>, <a href="#topic+densityanomaly">densityanomaly</a>, <a href="#topic+plotriverdensitypoints">plotriverdensitypoints</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk, fakefish)

Gulk_dens &lt;- makeriverdensity(seg=fakefish$seg, vert=fakefish$vert, rivers=Gulk, 
  survey=fakefish$flight.date)
  
# # 10 plots will be created, recommend calling par(mfrow=c(2,5))
plot(x=Gulk_dens)
</code></pre>

<hr>
<h2 id='plot.rivernetwork'>Plotting a River Network</h2><span id='topic+plot.rivernetwork'></span><span id='topic+mapriver'></span>

<h3>Description</h3>

<p>S3 plotting method for the <a href="#topic+rivernetwork-class">rivernetwork-class</a>.  
Produces a map of all river segments of a river network object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rivernetwork'
plot(
  x,
  segmentnum = TRUE,
  offset = TRUE,
  lwd = 1,
  cex = 0.6,
  scale = TRUE,
  color = TRUE,
  empty = FALSE,
  linecol = 1,
  xlab = "",
  ylab = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.rivernetwork_+3A_x">x</code></td>
<td>
<p>The river network object to plot</p>
</td></tr>
<tr><td><code id="plot.rivernetwork_+3A_segmentnum">segmentnum</code></td>
<td>
<p>Whether or not to plot segment numbers (defaults to TRUE)</p>
</td></tr>
<tr><td><code id="plot.rivernetwork_+3A_offset">offset</code></td>
<td>
<p>Whether to offset segment numbers from lines (defaults to TRUE)</p>
</td></tr>
<tr><td><code id="plot.rivernetwork_+3A_lwd">lwd</code></td>
<td>
<p>Line width</p>
</td></tr>
<tr><td><code id="plot.rivernetwork_+3A_cex">cex</code></td>
<td>
<p>Global character expansion factor for plotting</p>
</td></tr>
<tr><td><code id="plot.rivernetwork_+3A_scale">scale</code></td>
<td>
<p>Whether or not to give x- and y-axes the same scale</p>
</td></tr>
<tr><td><code id="plot.rivernetwork_+3A_color">color</code></td>
<td>
<p>How to differentiate segments.  If <code>color==TRUE</code> (default),
segments will be drawn in solid lines with differing colors.  If
<code>color==FALSE</code>, segments will be drawn in the same color with differing line
types.</p>
</td></tr>
<tr><td><code id="plot.rivernetwork_+3A_empty">empty</code></td>
<td>
<p>Creates an empty plot if set to <code>TRUE</code>.  Suppresses 
differentiation by line type if <code>color==FALSE</code>, and suppresses segment 
number labels.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.rivernetwork_+3A_linecol">linecol</code></td>
<td>
<p>Line color to use if <code>empty</code> is <code>TRUE</code> or 
<code>color</code> is <code>FALSE</code>.  Defaults to black.</p>
</td></tr>
<tr><td><code id="plot.rivernetwork_+3A_xlab">xlab</code></td>
<td>
<p>Label for X-axis (defaults to &quot;&quot;)</p>
</td></tr>
<tr><td><code id="plot.rivernetwork_+3A_ylab">ylab</code></td>
<td>
<p>Label for Y-axis (defaults to &quot;&quot;)</p>
</td></tr>
<tr><td><code id="plot.rivernetwork_+3A_...">...</code></td>
<td>
<p>Additional plotting arguments (see <a href="graphics.html#topic+par">par</a>)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is intended to provide basic visual checks for the user,
not for any real mapping.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk)
plot(x=Gulk)
</code></pre>

<hr>
<h2 id='plothomerangeoverlap'>Plot Home Range Overlap</h2><span id='topic+plothomerangeoverlap'></span>

<h3>Description</h3>

<p>Produces a plot of the overlap of the minimum observed home range for multiple
observations of each individual fish, with line thickness illustrating the respective number of individuals' homeranges represented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plothomerangeoverlap(x, lwd = 3, maxlwd = 10, col = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plothomerangeoverlap_+3A_x">x</code></td>
<td>
<p>An object returned from <a href="#topic+homerange">homerange</a>.</p>
</td></tr>
<tr><td><code id="plothomerangeoverlap_+3A_lwd">lwd</code></td>
<td>
<p>Minimum line width to use, defaults to 3.</p>
</td></tr>
<tr><td><code id="plothomerangeoverlap_+3A_maxlwd">maxlwd</code></td>
<td>
<p>Maximum line width to use, defaults to 10.</p>
</td></tr>
<tr><td><code id="plothomerangeoverlap_+3A_col">col</code></td>
<td>
<p>Line color to use, defaults to <code>"blue"</code>.</p>
</td></tr>
<tr><td><code id="plothomerangeoverlap_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters, see <a href="#topic+plot.rivernetwork">plot.rivernetwork</a>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+homerange">homerange</a>, <a href="#topic+plot.homerange">plot.homerange</a>, <a href="#topic+homerangeoverlap">homerangeoverlap</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk, fakefish)
ranges &lt;- with(fakefish, homerange(unique=fish.id, survey=flight, seg=seg, vert=vert, rivers=Gulk))
ranges

# 19 plots will be produced, recommend calling par(mfrow=c(4,5))
plot(ranges)
plot(ranges,cumulative=TRUE,label=TRUE)

homerangeoverlap(ranges)

plothomerangeoverlap(ranges)
with(fakefish, riverpoints(seg=seg, vert=vert, rivers=Gulk))
</code></pre>

<hr>
<h2 id='plotmatbysurveylist'>Plot Upstream Distance Between Observations of All Individuals</h2><span id='topic+plotmatbysurveylist'></span>

<h3>Description</h3>

<p>Produces a matrix of plots (boxplots are default), with plot <code>[i,j]</code> giving the
distribution of upstream distances from observation <code>i</code> to observation
<code>j</code>, for all individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotmatbysurveylist(matbysurveylist, type = "boxplot", showN = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotmatbysurveylist_+3A_matbysurveylist">matbysurveylist</code></td>
<td>
<p>A list of distance matrices returned from <a href="#topic+matbysurveylist">matbysurveylist</a>.</p>
</td></tr>
<tr><td><code id="plotmatbysurveylist_+3A_type">type</code></td>
<td>
<p>If <code>type</code> is set to <code>"boxplot"</code>, boxplots will be 
produced for each cell.  If <code>type</code> is set to <code>"confint"</code>, lines 
denoting an approximate 95 percent confidence interval for the mean will be 
produced instead.  If <code>type</code> is set to <code>"dotplot"</code>, a jittered
dotplot will be produced for each cell, which will be the most appropriate
if sample sizes are small.  Defaults to <code>"boxplot"</code>.</p>
</td></tr>
<tr><td><code id="plotmatbysurveylist_+3A_shown">showN</code></td>
<td>
<p>Whether to display the sample size for each cell.  Defaults to
TRUE.</p>
</td></tr>
<tr><td><code id="plotmatbysurveylist_+3A_...">...</code></td>
<td>
<p>Additional plotting arguments.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Building routes from the river mouth to each river network segment and/or distance lookup tables will
greatly reduce computation time (see <a href="#topic+buildsegroutes">buildsegroutes</a>).
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+upstream">upstream</a>, <a href="#topic+upstreammatbysurvey">upstreammatbysurvey</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk, smallset)
matbysurveylist &lt;- matbysurveylist(unique=smallset$id, survey=smallset$flight, seg=smallset$seg, 
   vert=smallset$vert, rivers=Gulk)
plotmatbysurveylist(matbysurveylist)
plotmatbysurveylist(matbysurveylist,type="confint")
plotmatbysurveylist(matbysurveylist,type="dotplot")
   
data(fakefish)
# matbysurveylist &lt;- matbysurveylist(unique=fakefish$fish.id, survey=fakefish$flight, 
#   seg=fakefish$seg, vert=fakefish$vert, rivers=Gulk)
# plotmatbysurveylist(matbysurveylist)
</code></pre>

<hr>
<h2 id='plotriverdensitypoints'>Plot Points Used for Kernel Density</h2><span id='topic+plotriverdensitypoints'></span>

<h3>Description</h3>

<p>Plots the points used to calculate a kernel density object 
in <a href="#topic+makeriverdensity">makeriverdensity</a>.
</p>
<p>This function is intended as a visual check that a sufficient resolution was used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotriverdensitypoints(riverdensity)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotriverdensitypoints_+3A_riverdensity">riverdensity</code></td>
<td>
<p>A river density object created by <a href="#topic+makeriverdensity">makeriverdensity</a>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+makeriverdensity">makeriverdensity</a>, <a href="#topic+plot.riverdensity">plot.riverdensity</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk, fakefish)

Gulk_dens &lt;- makeriverdensity(seg=fakefish$seg, vert=fakefish$vert, rivers=Gulk)

plotriverdensitypoints(riverdensity=Gulk_dens)
</code></pre>

<hr>
<h2 id='plotseq'>Plot Sequence of Observations</h2><span id='topic+plotseq'></span>

<h3>Description</h3>

<p>Plots the sequence of observations or movements of each individual (given as 
segment and vertex).  This function is primarily intended for use with 
<a href="#topic+mouthdistbysurvey">mouthdistbysurvey</a>, but will also work with <a href="#topic+riverdistanceseq">riverdistanceseq</a> and 
<a href="#topic+upstreamseq">upstreamseq</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotseq(
  seqbysurvey,
  type = "boxplot",
  xlab = "",
  ylab = "",
  main = "",
  cex.axisX = 0.8,
  lowerbound = NULL,
  upperbound = NULL,
  boundtype = "negative",
  surveysareDates = F,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotseq_+3A_seqbysurvey">seqbysurvey</code></td>
<td>
<p>A matrix returned from <a href="#topic+mouthdistbysurvey">mouthdistbysurvey</a>, 
<a href="#topic+riverdistanceseq">riverdistanceseq</a>, or <a href="#topic+upstreamseq">upstreamseq</a>.</p>
</td></tr>
<tr><td><code id="plotseq_+3A_type">type</code></td>
<td>
<p>The type of plot to generate.  Options are 
<code>"boxplot"</code>,<code>"dotplot"</code>,<code>"boxline"</code>,or <code>"dotline"</code>. 
Defaults to <code>"boxplot"</code>.</p>
</td></tr>
<tr><td><code id="plotseq_+3A_xlab">xlab</code></td>
<td>
<p>X-axis label</p>
</td></tr>
<tr><td><code id="plotseq_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis label</p>
</td></tr>
<tr><td><code id="plotseq_+3A_main">main</code></td>
<td>
<p>Plot title</p>
</td></tr>
<tr><td><code id="plotseq_+3A_cex.axisx">cex.axisX</code></td>
<td>
<p>Character expansion factor for X-axis labels</p>
</td></tr>
<tr><td><code id="plotseq_+3A_lowerbound">lowerbound</code></td>
<td>
<p>An optional vector of lower survey bounds</p>
</td></tr>
<tr><td><code id="plotseq_+3A_upperbound">upperbound</code></td>
<td>
<p>An optional vector of upper survey bounds</p>
</td></tr>
<tr><td><code id="plotseq_+3A_boundtype">boundtype</code></td>
<td>
<p>Method of plotting survey bounds.  Options are
<code>"positive"</code>, <code>"negative"</code> (default), and <code>"lines"</code>.</p>
</td></tr>
<tr><td><code id="plotseq_+3A_surveysaredates">surveysareDates</code></td>
<td>
<p>If surveys are in Date format (see <a href="base.html#topic+as.Date">as.Date</a>), a
value of <code>TRUE</code> allows the x-coordinates points to be spaced apart
according to date, not equidistantly.  Defaults to <code>FALSE</code>.  Any formatting of 
the survey variable must be done within the original call to <a href="#topic+mouthdistbysurvey">mouthdistbysurvey</a>, 
<a href="#topic+riverdistanceseq">riverdistanceseq</a>, or <a href="#topic+upstreamseq">upstreamseq</a>.  Dates must already be formatted as dates,
or in the form <code>"YYYY-MM-DD"</code> or <code>"YYYY/MM/DD"</code>.</p>
</td></tr>
<tr><td><code id="plotseq_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Plots are intended as descriptive only.  Any ANOVA-like inference that 
is suggested from these plots is strongly discouraged.  The user is instead
advised to use a mixed-effects model or some other inferential tool that 
accounts for repeated-measures and/or temporal autocorrelation.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk, fakefish)

x &lt;- mouthdistbysurvey(unique=fakefish$fish.id, survey=fakefish$flight.date, 
    seg=fakefish$seg, vert=fakefish$vert, rivers=Gulk)
    
plotseq(seqbysurvey=x)
plotseq(seqbysurvey=x, type="boxline")
plotseq(seqbysurvey=x, type="dotplot")
plotseq(seqbysurvey=x, type="dotline")

plotseq(seqbysurvey=x, type="dotline", surveysareDates=TRUE)

from_upstreamseq &lt;- upstreamseq(unique=fakefish$fish.id, 
   survey=fakefish$flight, seg=fakefish$seg, vert=fakefish$vert, 
   rivers=Gulk)
plotseq(seqbysurvey=from_upstreamseq)
</code></pre>

<hr>
<h2 id='pointshp2segvert'>Convert a Point Shapefile to River Locations</h2><span id='topic+pointshp2segvert'></span>

<h3>Description</h3>

<p>This function reads a point shapefile and determines the closest
vertex in the river network to each point of XY data, returning a data
frame with river locations, defined as segment numbers and vertex
numbers, along with the data table read from the input shapefile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointshp2segvert(path = ".", layer, rivers)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pointshp2segvert_+3A_path">path</code></td>
<td>
<p>File path, default is the current working directory.</p>
</td></tr>
<tr><td><code id="pointshp2segvert_+3A_layer">layer</code></td>
<td>
<p>Name of the shapefile, without the .shp extension.</p>
</td></tr>
<tr><td><code id="pointshp2segvert_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of river locations, with segment numbers in
<code>$seg</code>, vertex numbers in <code>$vert</code>, snapping distances in 
<code>$snapdist</code>, snapped x- and y-coordinates in <code>$snap_x</code> and <code>$snap_y</code>,
and the remaining columns
corresponding to the data table in the input point shapefile.
</p>


<h3>Note</h3>

<p>If the input shapefile is detected to be in a different projection than
the river network, the input shapefile will be re-projected before
conversion to river locations.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+xy2segvert">xy2segvert</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filepath &lt;- system.file("extdata", package="riverdist")

fakefish_UTM5 &lt;- pointshp2segvert(path=filepath, layer="fakefish_UTM5", rivers=Gulk)
head(fakefish_UTM5)

plot(x=Gulk)
points(fakefish_UTM5$x, fakefish_UTM5$y)
riverpoints(seg=fakefish_UTM5$seg, vert=fakefish_UTM5$vert, rivers=Gulk, pch=16, col=2)

</code></pre>

<hr>
<h2 id='removeduplicates'>Remove Duplicates</h2><span id='topic+removeduplicates'></span>

<h3>Description</h3>

<p>Removes duplicated line segments, which can sometimes exist within a shapefile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeduplicates(rivers)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="removeduplicates_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new river network object with duplicated segments removed, see <a href="#topic+rivernetwork">rivernetwork</a>
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p>line2network
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(abstreams0)
zoomtoseg(seg=c(170,171,157),rivers=abstreams0)

abstreams1 &lt;- removeduplicates(rivers=abstreams0)
zoomtoseg(seg=c(166,167,154),rivers=abstreams1)
</code></pre>

<hr>
<h2 id='removemicrosegs'>Remove Segments that are Smaller than the Connectivity Tolerance</h2><span id='topic+removemicrosegs'></span>

<h3>Description</h3>

<p>Automatically detects and removes segments with total displacement (straight-line distance between endpoints) less than the connectivity tolerance.  These segments do not serve any real purpose, are bypassed in routes, and cannot be dissolved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removemicrosegs(rivers)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="removemicrosegs_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new river network object with the specified segments connected (see <a href="#topic+rivernetwork">rivernetwork</a>)
</p>


<h3>Note</h3>

<p>This function is called within <a href="#topic+cleanup">cleanup</a>, which is recommended in most cases.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p>line2network
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(abstreams0)
abstreams1 &lt;- removemicrosegs(abstreams0)
</code></pre>

<hr>
<h2 id='removeunconnected'>Remove Unconnected Segments</h2><span id='topic+removeunconnected'></span>

<h3>Description</h3>

<p>Detects and removes segments that are not connected to the river mouth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeunconnected(rivers)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="removeunconnected_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is called within <a href="#topic+cleanup">cleanup</a>, which is recommended in most cases.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Koyukuk2)
Koy_subset &lt;- trimriver(trimto=c(30,28,29,3,19,27,4),rivers=Koyukuk2)
Koy_subset &lt;- setmouth(seg=1,vert=427,rivers=Koy_subset)
plot(Koy_subset)

Koy_subset_trim &lt;- removeunconnected(Koy_subset)
plot(Koy_subset_trim)
</code></pre>

<hr>
<h2 id='riverdensity'>The &quot;riverdensity&quot; Class</h2><span id='topic+riverdensity'></span><span id='topic+riverdensity-class'></span>

<h3>Description</h3>

<p>A class that holds density information computed from point data along a river network.
</p>


<h3>Details</h3>

<p>Created by <a href="#topic+makeriverdensity">makeriverdensity</a> from point data and a river network.  Contains all information for plotting in <a href="#topic+plot.riverdensity">plot.riverdensity</a>.
</p>


<h3>Elements</h3>


<dl>
<dt><code>densities</code>:</dt><dd><p>Object of class <code>"list"</code>. Each list element corresponds to a unique value of survey.  Each element is itself of class <code>"list"</code>, with each element corresponding to a segment from the associated river network.  Each element is a vector of class <code>"numeric"</code>, with values equal to the scaled densities calculated at the river network vertices stored in <code>$densverts</code> of the associated river network segment.</p>
</dd>
<dt><code>endptverts</code>:</dt><dd><p>List of vectors of class <code>"numeric"</code>.  Each list element is a vector of the vertices of the endpoints of the subsegments considered for density calculation.  Each list element corresponds to a river segment from the associated river network.</p>
</dd>
<dt><code>densverts</code>:</dt><dd><p>List of vectors of class <code>"numeric"</code>.  Each element is a vector of the vertices of the points of the subsegments considered for density calculation, that were used for density calculation.  Each list element corresponds to a river segment from the associated river network.</p>
</dd>
<dt><code>pointsegs</code>:</dt><dd><p>Vector of class <code>"numeric"</code>.  Defined as the segment numbers of the point data used for density calculation.</p>
</dd>
<dt><code>pointverts</code>:</dt><dd><p>Vector of class <code>"numeric"</code>.  Defined as the vertex numbers of the point data used for density calculation.</p>
</dd>
<dt><code>survey</code>:</dt><dd><p>Vector of class <code>"numeric"</code> or class <code>"character"</code>.  Defined as the survey identifiers associated with the point data used for density calculation.</p>
</dd>
<dt><code>rivers</code>:</dt><dd><p>Object of class <code>"rivernetwork"</code> ; see <a href="#topic+rivernetwork-class">rivernetwork-class</a></p>
</dd></dl>
<p>.

</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>

<hr>
<h2 id='riverdirection'>River Direction</h2><span id='topic+riverdirection'></span>

<h3>Description</h3>

<p>Calculates direction of travel between two points.  Only works
if river mouth (lowest point) has been specified (see <a href="#topic+setmouth">setmouth</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riverdirection(
  startseg,
  endseg,
  startvert,
  endvert,
  rivers,
  flowconnected = FALSE,
  stopiferror = TRUE,
  algorithm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="riverdirection_+3A_startseg">startseg</code></td>
<td>
<p>Segment number of the start of the route</p>
</td></tr>
<tr><td><code id="riverdirection_+3A_endseg">endseg</code></td>
<td>
<p>Segment number of the end of the route</p>
</td></tr>
<tr><td><code id="riverdirection_+3A_startvert">startvert</code></td>
<td>
<p>Vertex number of the start of the route</p>
</td></tr>
<tr><td><code id="riverdirection_+3A_endvert">endvert</code></td>
<td>
<p>Vertex number of the end of the route</p>
</td></tr>
<tr><td><code id="riverdirection_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
<tr><td><code id="riverdirection_+3A_flowconnected">flowconnected</code></td>
<td>
<p>If <code>TRUE</code>, only returns direction if the two input segments are flow-connected.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="riverdirection_+3A_stopiferror">stopiferror</code></td>
<td>
<p>Whether or not to exit with an error if a route cannot be
found.  If this is set to <code>FALSE</code> and a route cannot be found,
the function will return <code>NA</code> in the appropriate entry.  Defaults to <code>TRUE</code>.  See <a href="#topic+detectroute">detectroute</a>.</p>
</td></tr>
<tr><td><code id="riverdirection_+3A_algorithm">algorithm</code></td>
<td>
<p>Which route detection algorithm to use (<code>"Dijkstra"</code>,
<code>"sequential"</code>, or <code>"segroutes"</code>).  If left as <code>NULL</code> (the
default), the function will automatically make a selection.  See
<a href="#topic+detectroute">detectroute</a> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Direction: &quot;up&quot;, &quot;down&quot;, or &quot;0&quot; (character).  Returns NA if <code>flowconnected==TRUE</code> and the two segments are not flow-connected.
</p>


<h3>Note</h3>

<p>Building routes from the river mouth to each river network segment and/or distance lookup tables will
greatly reduce computation time (see <a href="#topic+buildsegroutes">buildsegroutes</a>).
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+setmouth">setmouth</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk)

# Mouth must be specified
Gulk$mouth$mouth.seg &lt;- 1
Gulk$mouth$mouth.vert &lt;- 1

plot(x=Gulk)
riverdirection(startseg=6, endseg=3, startvert=40, endvert=40, rivers=Gulk)
</code></pre>

<hr>
<h2 id='riverdirectionmat'>River Direction Matrix</h2><span id='topic+riverdirectionmat'></span>

<h3>Description</h3>

<p>Returns a matrix of calculated travel direction between every
point and every other point of given river locations (segment and
vertex), or of a subset.  The mouth (lowest point) segment and vertex must
be specified (see <a href="#topic+setmouth">setmouth</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riverdirectionmat(
  seg,
  vert,
  rivers,
  logical = NULL,
  ID = NULL,
  flowconnected = FALSE,
  stopiferror = TRUE,
  algorithm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="riverdirectionmat_+3A_seg">seg</code></td>
<td>
<p>A vector of river locations (segment component).</p>
</td></tr>
<tr><td><code id="riverdirectionmat_+3A_vert">vert</code></td>
<td>
<p>A vector of river locations (vertex component).</p>
</td></tr>
<tr><td><code id="riverdirectionmat_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
<tr><td><code id="riverdirectionmat_+3A_logical">logical</code></td>
<td>
<p>A boolean vector that can be used for subsetting - if used,
<code>riverdirectionmat()</code> will only return pairwise distances in which a
specified condition is met.</p>
</td></tr>
<tr><td><code id="riverdirectionmat_+3A_id">ID</code></td>
<td>
<p>a vector of observation IDs for aid in interpreting the output
table</p>
</td></tr>
<tr><td><code id="riverdirectionmat_+3A_flowconnected">flowconnected</code></td>
<td>
<p>If <code>TRUE</code>, only returns direction if the input segments are flow-connected.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="riverdirectionmat_+3A_stopiferror">stopiferror</code></td>
<td>
<p>Whether or not to exit with an error if a route cannot be
found.  If this is set to <code>FALSE</code> and a route cannot be found,
the function will return <code>NA</code> in the appropriate entry.  Defaults to <code>TRUE</code>.  See <a href="#topic+detectroute">detectroute</a>.</p>
</td></tr>
<tr><td><code id="riverdirectionmat_+3A_algorithm">algorithm</code></td>
<td>
<p>Which route detection algorithm to use (<code>"Dijkstra"</code>,
<code>"sequential"</code>, or <code>"segroutes"</code>).  If left as <code>NULL</code> (the
default), the function will automatically make a selection.  See
<a href="#topic+detectroute">detectroute</a> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of directions (character) with rows and columns labeled by
corresponding values of <code>ID</code>.  See <a href="#topic+riverdirection">riverdirection</a> for additional information.
</p>


<h3>Note</h3>

<p>Building routes from the river mouth to each river network segment and/or distance lookup tables will
greatly reduce computation time (see <a href="#topic+buildsegroutes">buildsegroutes</a>).
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+riverdirection">riverdirection</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk, fakefish)

# Mouth must be specified
Gulk$mouth$mouth.seg &lt;- 1
Gulk$mouth$mouth.vert &lt;- 1

logi1 &lt;- (fakefish$flight.date==as.Date("2015-11-25"))

riverdirectionmat(seg=fakefish$seg, vert=fakefish$vert, rivers=Gulk, logical=logi1)
</code></pre>

<hr>
<h2 id='riverdirectionmatbysurvey'>River Direction Matrix of All Observations of an Individual</h2><span id='topic+riverdirectionmatbysurvey'></span>

<h3>Description</h3>

<p>Returns a matrix of travel direction between all observations of
one unique fish.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riverdirectionmatbysurvey(
  indiv,
  unique,
  survey,
  seg,
  vert,
  rivers,
  full = TRUE,
  flowconnected = FALSE,
  stopiferror = TRUE,
  algorithm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="riverdirectionmatbysurvey_+3A_indiv">indiv</code></td>
<td>
<p>The unique identifier of the fish in question.</p>
</td></tr>
<tr><td><code id="riverdirectionmatbysurvey_+3A_unique">unique</code></td>
<td>
<p>A vector of identifiers for each fish.</p>
</td></tr>
<tr><td><code id="riverdirectionmatbysurvey_+3A_survey">survey</code></td>
<td>
<p>A vector of identifiers for each survey.  It is recommended to
use a numeric or date format (see <a href="base.html#topic+as.Date">as.Date</a>) to preserve survey order.</p>
</td></tr>
<tr><td><code id="riverdirectionmatbysurvey_+3A_seg">seg</code></td>
<td>
<p>A vector of river locations (segment component).</p>
</td></tr>
<tr><td><code id="riverdirectionmatbysurvey_+3A_vert">vert</code></td>
<td>
<p>A vector of river locations (vertex component).</p>
</td></tr>
<tr><td><code id="riverdirectionmatbysurvey_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use.</p>
</td></tr>
<tr><td><code id="riverdirectionmatbysurvey_+3A_full">full</code></td>
<td>
<p>Whether to return the full matrix, with <code>NA</code> values for
missing data (<code>TRUE</code>), or a the subset of rows and columns
corresponding to successful observations.  Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="riverdirectionmatbysurvey_+3A_flowconnected">flowconnected</code></td>
<td>
<p>If <code>TRUE</code>, only returns direction if the input segments are flow-connected.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="riverdirectionmatbysurvey_+3A_stopiferror">stopiferror</code></td>
<td>
<p>Whether or not to exit with an error if a route cannot be
found.  If this is set to <code>FALSE</code> and a route cannot be found, the
function will return <code>NA</code> in the appropriate entry.  Defaults to
<code>TRUE</code>.  See <a href="#topic+detectroute">detectroute</a>.</p>
</td></tr>
<tr><td><code id="riverdirectionmatbysurvey_+3A_algorithm">algorithm</code></td>
<td>
<p>Which route detection algorithm to use (<code>"Dijkstra"</code>,
<code>"sequential"</code>, or <code>"segroutes"</code>).  If left as <code>NULL</code> (the
default), the function will automatically make a selection.  See
<a href="#topic+detectroute">detectroute</a> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of directions (character), with rows and columns defined by
survey.  In the resulting matrix, the element with the row identified as
<code>A</code> and column identified as <code>B</code> is defined as the direction
traveled from survey A to survey B.  Therefore, it is likely that only the
upper triangle of the matrix will be of interest.
</p>


<h3>Note</h3>

<p>Building routes from the river mouth to each river network segment and/or distance lookup tables will
greatly reduce computation time (see <a href="#topic+buildsegroutes">buildsegroutes</a>).
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+riverdirection">riverdirection</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk, fakefish)
riverdirectionmatbysurvey(indiv=1, unique=fakefish$fish.id, survey=fakefish$flight,
      seg=fakefish$seg, vert=fakefish$vert, rivers=Gulk)
     
riverdirectionmatbysurvey(indiv=1, unique=fakefish$fish.id, survey=fakefish$flight,
      seg=fakefish$seg, vert=fakefish$vert, rivers=Gulk, full=FALSE)
</code></pre>

<hr>
<h2 id='riverdirectionseq'>River Travel Direction Between Sequential Observations</h2><span id='topic+riverdirectionseq'></span>

<h3>Description</h3>

<p>Returns a matrix of directions traveled by unique fish between
sequential surveys.  The mouth (lowest point) segment and vertex must be
specified (see <a href="#topic+setmouth">setmouth</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riverdirectionseq(
  unique,
  survey,
  seg,
  vert,
  rivers,
  logical = NULL,
  flowconnected = FALSE,
  stopiferror = TRUE,
  algorithm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="riverdirectionseq_+3A_unique">unique</code></td>
<td>
<p>A vector of identifiers for each fish.</p>
</td></tr>
<tr><td><code id="riverdirectionseq_+3A_survey">survey</code></td>
<td>
<p>A vector of identifiers for each survey.  It is recommended to use a numeric or date format (see <a href="base.html#topic+as.Date">as.Date</a>) to preserve survey order.</p>
</td></tr>
<tr><td><code id="riverdirectionseq_+3A_seg">seg</code></td>
<td>
<p>A vector of river locations (segment component).</p>
</td></tr>
<tr><td><code id="riverdirectionseq_+3A_vert">vert</code></td>
<td>
<p>A vector of river locations (vertex component).</p>
</td></tr>
<tr><td><code id="riverdirectionseq_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use.</p>
</td></tr>
<tr><td><code id="riverdirectionseq_+3A_logical">logical</code></td>
<td>
<p>A boolean vector that can be used for subsetting - if used,
<code>riverdirectionseq()</code> will only return pairwise distances in which a
specified condition is met.</p>
</td></tr>
<tr><td><code id="riverdirectionseq_+3A_flowconnected">flowconnected</code></td>
<td>
<p>If <code>TRUE</code>, only returns direction if the input segments are flow-connected.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="riverdirectionseq_+3A_stopiferror">stopiferror</code></td>
<td>
<p>Whether or not to exit with an error if a route cannot be
found.  If this is set to <code>FALSE</code> and a route cannot be found,
the function will return <code>NA</code> in the appropriate entry.  Defaults to <code>TRUE</code>.  See <a href="#topic+detectroute">detectroute</a>.</p>
</td></tr>
<tr><td><code id="riverdirectionseq_+3A_algorithm">algorithm</code></td>
<td>
<p>Which route detection algorithm to use (<code>"Dijkstra"</code>,
<code>"sequential"</code>, or <code>"segroutes"</code>).  If left as <code>NULL</code> (the
default), the function will automatically make a selection.  See
<a href="#topic+detectroute">detectroute</a> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of directions (character), with rows defined by unique
fish and columns defined by observation increment (1 to 2, 2 to 3, etc.)  See <a href="#topic+riverdirection">riverdirection</a> for additional information.
</p>


<h3>Note</h3>

<p>Building routes from the river mouth to each river network segment and/or distance lookup tables will
greatly reduce computation time (see <a href="#topic+buildsegroutes">buildsegroutes</a>).
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+riverdirection">riverdirection</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk, fakefish)

# Mouth must be specified
Gulk$mouth$mouth.seg &lt;- 1
Gulk$mouth$mouth.vert &lt;- 1

riverdirectionseq(unique=fakefish$fish.id, survey=fakefish$flight, seg=fakefish$seg,
   vert=fakefish$vert, rivers=Gulk)

riverdirectionseq(unique=fakefish$fish.id, survey=fakefish$flight.date, seg=fakefish$seg,
   vert=fakefish$vert, rivers=Gulk)
</code></pre>

<hr>
<h2 id='riverdirectiontofrom'>River Direction Matrix between Two Datasets</h2><span id='topic+riverdirectiontofrom'></span>

<h3>Description</h3>

<p>Returns a matrix of directions between each river location in two datasets, with one expressed as rows and the other expressed as columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riverdirectiontofrom(
  seg1,
  vert1,
  seg2,
  vert2,
  rivers,
  logical1 = NULL,
  logical2 = NULL,
  ID1 = NULL,
  ID2 = NULL,
  flowconnected = FALSE,
  stopiferror = TRUE,
  algorithm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="riverdirectiontofrom_+3A_seg1">seg1</code></td>
<td>
<p>First vector of river locations (segment component).  These are expressed as rows in the output matrix.</p>
</td></tr>
<tr><td><code id="riverdirectiontofrom_+3A_vert1">vert1</code></td>
<td>
<p>First vector of river locations (vertex component).  These are expressed as rows in the output matrix.</p>
</td></tr>
<tr><td><code id="riverdirectiontofrom_+3A_seg2">seg2</code></td>
<td>
<p>Second vector of river locations (segment component).  These are expressed as columns in the output matrix.</p>
</td></tr>
<tr><td><code id="riverdirectiontofrom_+3A_vert2">vert2</code></td>
<td>
<p>Second vector of river locations (vertex component).  These are expressed as columns in the output matrix.</p>
</td></tr>
<tr><td><code id="riverdirectiontofrom_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use.</p>
</td></tr>
<tr><td><code id="riverdirectiontofrom_+3A_logical1">logical1</code></td>
<td>
<p>A boolean vector that can be used for subsetting.  If used,
<code>riverdirectiontofrom</code> will only return directions in which a
specified condition is met for the first dataset.</p>
</td></tr>
<tr><td><code id="riverdirectiontofrom_+3A_logical2">logical2</code></td>
<td>
<p>A boolean vector that can be used for subsetting.  If used,
<code>riverdirectiontofrom</code> will only return directions in which a
specified condition is met for the second dataset.</p>
</td></tr>
<tr><td><code id="riverdirectiontofrom_+3A_id1">ID1</code></td>
<td>
<p>a vector of observation IDs for the first dataset that will be used as row names in the output matrix.</p>
</td></tr>
<tr><td><code id="riverdirectiontofrom_+3A_id2">ID2</code></td>
<td>
<p>a vector of observation IDs for the second dataset that will be used as column names in the output matrix.</p>
</td></tr>
<tr><td><code id="riverdirectiontofrom_+3A_flowconnected">flowconnected</code></td>
<td>
<p>If <code>TRUE</code>, only returns distance if the input segments are flow-connected.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="riverdirectiontofrom_+3A_stopiferror">stopiferror</code></td>
<td>
<p>Whether or not to exit with an error if a route cannot be
found.  If this is set to <code>FALSE</code> and a route cannot be found,
the function will return <code>NA</code> in the appropriate entry.  Defaults to <code>TRUE</code>.  See <a href="#topic+detectroute">detectroute</a>.</p>
</td></tr>
<tr><td><code id="riverdirectiontofrom_+3A_algorithm">algorithm</code></td>
<td>
<p>Which route detection algorithm to use (<code>"Dijkstra"</code>,
<code>"sequential"</code>, or <code>"segroutes"</code>).  If left as <code>NULL</code> (the
default), the function will automatically make a selection.  See
<a href="#topic+detectroute">detectroute</a> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of directions (character) with rows and columns labeled by corresponding values of <code>ID</code>.  See <a href="#topic+riverdirection">riverdirection</a> for additional information.
</p>


<h3>Note</h3>

<p>Building routes from the river mouth to each river network segment and/or distance lookup tables will
greatly reduce computation time (see <a href="#topic+buildsegroutes">buildsegroutes</a>).
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+riverdirection">riverdirection</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk)

streamlocs.seg &lt;- c(1,8,11)
streamlocs.vert &lt;- c(50,70,90)
streamlocs.ID &lt;- c("A","B","C")

fish.seg &lt;- c(1,4,9,12,14)
fish.vert &lt;- c(10,11,12,13,14)
fish.ID &lt;- c("fish1","fish2","fish3","fish4","fish5")

Gulk &lt;- setmouth(seg=1, vert=1, rivers=Gulk)

riverdirectiontofrom(seg1=streamlocs.seg, vert1=streamlocs.vert,
  seg2=fish.seg, vert2=fish.vert, rivers=Gulk,
  ID1=streamlocs.ID, ID2=fish.ID)

logi1 &lt;- streamlocs.ID=="B" | streamlocs.ID=="C"
logi2 &lt;- fish.ID!="fish3"

riverdirectiontofrom(seg1=streamlocs.seg, vert1=streamlocs.vert,
  seg2=fish.seg, vert2=fish.vert, rivers=Gulk, logical1=logi1,
  logical2=logi2, ID1=streamlocs.ID, ID2=fish.ID)
</code></pre>

<hr>
<h2 id='riverdistance'>River Distance</h2><span id='topic+riverdistance'></span>

<h3>Description</h3>

<p>Calculates the total river network distance between two points 
on the river network, given in river locations (segment and vertex).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riverdistance(
  startseg = NULL,
  endseg = NULL,
  startvert,
  endvert,
  rivers,
  path = NULL,
  map = FALSE,
  add = FALSE,
  stopiferror = TRUE,
  algorithm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="riverdistance_+3A_startseg">startseg</code></td>
<td>
<p>Segment number of the start of the route</p>
</td></tr>
<tr><td><code id="riverdistance_+3A_endseg">endseg</code></td>
<td>
<p>Segment number of the end of the route</p>
</td></tr>
<tr><td><code id="riverdistance_+3A_startvert">startvert</code></td>
<td>
<p>Vertex number of the start of the route</p>
</td></tr>
<tr><td><code id="riverdistance_+3A_endvert">endvert</code></td>
<td>
<p>Vertex number of the end of the route</p>
</td></tr>
<tr><td><code id="riverdistance_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
<tr><td><code id="riverdistance_+3A_path">path</code></td>
<td>
<p>(optional) The vector-format route of segment numbers can also be
supplied instead of the starting and ending segments.</p>
</td></tr>
<tr><td><code id="riverdistance_+3A_map">map</code></td>
<td>
<p>Whether or not to draw a sanity-check map, showing the calculated 
route in entirety.  Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="riverdistance_+3A_add">add</code></td>
<td>
<p>If <code>map==TRUE</code>, whether to add the route drawing to an
existing plot (<code>add=TRUE</code>) or produce a new plot (<code>add=FALSE</code>).</p>
</td></tr>
<tr><td><code id="riverdistance_+3A_stopiferror">stopiferror</code></td>
<td>
<p>Whether or not to exit with an error if a route cannot be 
found.  If this is set to <code>FALSE</code> and a route cannot be found, 
<code>riverdistance()</code> will return <code>NA</code>.  Defaults to <code>TRUE</code>. 
See <a href="#topic+detectroute">detectroute</a>.</p>
</td></tr>
<tr><td><code id="riverdistance_+3A_algorithm">algorithm</code></td>
<td>
<p>Which route detection algorithm to use (<code>"Dijkstra"</code>,
<code>"sequential"</code>, or <code>"segroutes"</code>).  If left as <code>NULL</code> (the
default), the function will automatically make a selection.  See
<a href="#topic+detectroute">detectroute</a> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Total route distance, in the units of the coordinate system used 
(this will likely be meters).
</p>


<h3>Note</h3>

<p>If a distance lookup table (<code>$distlookup</code>) is present in the river network object, accepting <code>NULL</code> will bypass route detection and return distance automatically, the fastest algorithm of all.  This is done automatically in <a href="#topic+buildsegroutes">buildsegroutes</a>, but can be called directly using <a href="#topic+buildlookup">buildlookup</a>.
</p>
<p>Building routes from the river mouth to each river network segment and/or distance lookup tables will
greatly reduce computation time (see <a href="#topic+buildsegroutes">buildsegroutes</a>).
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk)
riverdistance(startseg=6, endseg=14, startvert=100, endvert=200, rivers=Gulk)
riverdistance(startvert=100, endvert=200, path=c(6,3,4,10,11,14), rivers=Gulk)
riverdistance(startseg=6, endseg=14, startvert=100, endvert=200, rivers=Gulk, map=TRUE)
      
# speed comparison: 

data(abstreams)

tstart &lt;- Sys.time()
riverdistance(startseg=120, startvert=10, endseg=131, endvert=10, rivers=abstreams, 
              algorithm="sequential")
Sys.time()- tstart

tstart &lt;- Sys.time()
riverdistance(startseg=120, startvert=10, endseg=131, endvert=10, rivers=abstreams, 
              algorithm="Dijkstra")
Sys.time()- tstart

tstart &lt;- Sys.time()
riverdistance(startseg=120, startvert=10, endseg=131, endvert=10, rivers=abstreams)

# Note: it is not necessary to specify the algorithm here: the distance function
# will automatically select the fastest algorithm unless otherwise specified.
Sys.time()- tstart

</code></pre>

<hr>
<h2 id='riverdistancelist'>Multiple River Distances</h2><span id='topic+riverdistancelist'></span>

<h3>Description</h3>

<p>Used to calculate a list of possible river distances, in the
event of braiding.  Calls <a href="#topic+routelist">routelist</a> to detect a list of routes from
one river location to another, and uses <a href="#topic+riverdistance">riverdistance</a> to calculate
the distances along those routes.  Different routes are detected by
randomly reordering the segment numbers of the input river network object,
thus changing the internal hierarchy of segment selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riverdistancelist(startseg, endseg, startvert, endvert, rivers, reps = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="riverdistancelist_+3A_startseg">startseg</code></td>
<td>
<p>Segment number of the start of the route</p>
</td></tr>
<tr><td><code id="riverdistancelist_+3A_endseg">endseg</code></td>
<td>
<p>Segment number of the end of the route</p>
</td></tr>
<tr><td><code id="riverdistancelist_+3A_startvert">startvert</code></td>
<td>
<p>Vertex number of the start of the route</p>
</td></tr>
<tr><td><code id="riverdistancelist_+3A_endvert">endvert</code></td>
<td>
<p>Vertex number of the end of the route</p>
</td></tr>
<tr><td><code id="riverdistancelist_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
<tr><td><code id="riverdistancelist_+3A_reps">reps</code></td>
<td>
<p>Deprecated.  Was the number of randomized reorderings to try.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two objects, <code>$routes</code> being a list of detected routes in
ascending order by distance, and <code>$distances</code> being the respective distances
along the routes detected.
</p>


<h3>Note</h3>

<p>Since this function uses randomization, there is no guarantee that the
list of routes will be comprehensive.  Larger numbers of reps can be tried,
but computation can be slow, particularly in the presence of a complex
river network.  It may be advantageous to use <a href="#topic+trimriver">trimriver</a> to create a
smaller, more specific river network object to work with.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(KilleyW)
plot(x=KilleyW)

Killey.dists &lt;- riverdistancelist(startseg=1, endseg=16, startvert=100, endvert=25,
   rivers=KilleyW)
Killey.dists  # 18 routes are detected.

# mapping the shortest route detected... 
riverdistance(startvert=100, endvert=25, path=Killey.dists$routes[[1]], rivers=KilleyW, map=TRUE)

# mapping the shortest longest detected... 
riverdistance(startvert=100, endvert=25, path=Killey.dists$routes[[18]], rivers=KilleyW, map=TRUE)
</code></pre>

<hr>
<h2 id='riverdistancemat'>River Distance Matrix</h2><span id='topic+riverdistancemat'></span>

<h3>Description</h3>

<p>Returns a matrix of distances between every point and every
other point of given river locations (segment and vertex), or of a subset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riverdistancemat(
  seg,
  vert,
  rivers,
  logical = NULL,
  ID = NULL,
  stopiferror = TRUE,
  algorithm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="riverdistancemat_+3A_seg">seg</code></td>
<td>
<p>A vector of river locations (segment component).</p>
</td></tr>
<tr><td><code id="riverdistancemat_+3A_vert">vert</code></td>
<td>
<p>A vector of river locations (vertex component).</p>
</td></tr>
<tr><td><code id="riverdistancemat_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use.</p>
</td></tr>
<tr><td><code id="riverdistancemat_+3A_logical">logical</code></td>
<td>
<p>A boolean vector that can be used for subsetting.  If used,
<code>riverdistancemat</code> will only return pairwise distances in which a
specified condition is met.</p>
</td></tr>
<tr><td><code id="riverdistancemat_+3A_id">ID</code></td>
<td>
<p>a vector of observation IDs for aid in interpreting the output
table</p>
</td></tr>
<tr><td><code id="riverdistancemat_+3A_stopiferror">stopiferror</code></td>
<td>
<p>Whether or not to exit with an error if a route cannot be
found.  If this is set to <code>FALSE</code> and a route cannot be found,
the function will return <code>NA</code> in the appropriate entry.  Defaults to <code>TRUE</code>.  See <a href="#topic+detectroute">detectroute</a></p>
</td></tr>
<tr><td><code id="riverdistancemat_+3A_algorithm">algorithm</code></td>
<td>
<p>Which route detection algorithm to use (<code>"Dijkstra"</code>,
<code>"sequential"</code>, or <code>"segroutes"</code>).  If left as <code>NULL</code> (the
default), the function will automatically make a selection.  See
<a href="#topic+detectroute">detectroute</a> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of distances (numeric) with rows and columns labeled by corresponding values of <code>ID</code>.
</p>


<h3>Note</h3>

<p>Building routes from the river mouth to each river network segment and/or distance lookup tables will
greatly reduce computation time (see <a href="#topic+buildsegroutes">buildsegroutes</a>).
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+riverdistance">riverdistance</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk, fakefish)

logi1 &lt;- (fakefish$flight.date==as.Date("2015-11-25"))

riverdistancemat(seg=fakefish$seg, vert=fakefish$vert, rivers=Gulk, logical=logi1)
</code></pre>

<hr>
<h2 id='riverdistancematbysurvey'>River Distance Matrix of All Observations of an Individual</h2><span id='topic+riverdistancematbysurvey'></span>

<h3>Description</h3>

<p>Returns a matrix of network distances between all observations
of one unique fish.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riverdistancematbysurvey(
  indiv,
  unique,
  survey,
  seg,
  vert,
  rivers,
  full = TRUE,
  stopiferror = TRUE,
  algorithm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="riverdistancematbysurvey_+3A_indiv">indiv</code></td>
<td>
<p>The unique identifier of the fish in question.</p>
</td></tr>
<tr><td><code id="riverdistancematbysurvey_+3A_unique">unique</code></td>
<td>
<p>A vector of identifiers for each fish.</p>
</td></tr>
<tr><td><code id="riverdistancematbysurvey_+3A_survey">survey</code></td>
<td>
<p>A vector of identifiers for each survey.  It is recommended to
use a numeric or date format (see <a href="base.html#topic+as.Date">as.Date</a>) to preserve survey order.</p>
</td></tr>
<tr><td><code id="riverdistancematbysurvey_+3A_seg">seg</code></td>
<td>
<p>A vector of river locations (segment component).</p>
</td></tr>
<tr><td><code id="riverdistancematbysurvey_+3A_vert">vert</code></td>
<td>
<p>A vector of river locations (vertex component).</p>
</td></tr>
<tr><td><code id="riverdistancematbysurvey_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use.</p>
</td></tr>
<tr><td><code id="riverdistancematbysurvey_+3A_full">full</code></td>
<td>
<p>Whether to return the full matrix, with <code>NA</code> values for
missing data (<code>TRUE</code>), or a the subset of rows and columns
corresponding to successful observations.  Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="riverdistancematbysurvey_+3A_stopiferror">stopiferror</code></td>
<td>
<p>Whether or not to exit with an error if a route cannot be
found.  If this is set to <code>FALSE</code> and a route cannot be found, the
function will return <code>NA</code> in the appropriate entry.  Defaults to
<code>TRUE</code>.  See <a href="#topic+detectroute">detectroute</a>.</p>
</td></tr>
<tr><td><code id="riverdistancematbysurvey_+3A_algorithm">algorithm</code></td>
<td>
<p>Which route detection algorithm to use (<code>"Dijkstra"</code>,
<code>"sequential"</code>, or <code>"segroutes"</code>).  If left as <code>NULL</code> (the
default), the function will automatically make a selection.  See
<a href="#topic+detectroute">detectroute</a> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of distances (numeric), with rows and columns defined by
survey.
</p>


<h3>Note</h3>

<p>Building routes from the river mouth to each river network segment and/or distance lookup tables will
greatly reduce computation time (see <a href="#topic+buildsegroutes">buildsegroutes</a>).
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+riverdistance">riverdistance</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk, fakefish)
riverdistancematbysurvey(indiv=1, unique=fakefish$fish.id, survey=fakefish$flight,
      seg=fakefish$seg, vert=fakefish$vert, rivers=Gulk)
     
riverdistancematbysurvey(indiv=1, unique=fakefish$fish.id, survey=fakefish$flight,
      seg=fakefish$seg, vert=fakefish$vert, rivers=Gulk, full=FALSE)
</code></pre>

<hr>
<h2 id='riverdistanceseq'>River Distance Between Sequential Observations</h2><span id='topic+riverdistanceseq'></span>

<h3>Description</h3>

<p>Returns a matrix of distances traveled by unique fish, between
sequential surveys.  A plotting method is also provided for the output; see <a href="#topic+plotseq">plotseq</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riverdistanceseq(
  unique,
  survey,
  seg,
  vert,
  rivers,
  logical = NULL,
  stopiferror = TRUE,
  algorithm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="riverdistanceseq_+3A_unique">unique</code></td>
<td>
<p>A vector of identifiers for each fish.</p>
</td></tr>
<tr><td><code id="riverdistanceseq_+3A_survey">survey</code></td>
<td>
<p>A vector of identifiers for each survey.  It is recommended to use a numeric or date format (see <a href="base.html#topic+as.Date">as.Date</a>) to preserve survey order.</p>
</td></tr>
<tr><td><code id="riverdistanceseq_+3A_seg">seg</code></td>
<td>
<p>A vector of river locations (segment component).</p>
</td></tr>
<tr><td><code id="riverdistanceseq_+3A_vert">vert</code></td>
<td>
<p>A vector of river locations (vertex component).</p>
</td></tr>
<tr><td><code id="riverdistanceseq_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use.</p>
</td></tr>
<tr><td><code id="riverdistanceseq_+3A_logical">logical</code></td>
<td>
<p>A boolean vector that can be used for subsetting.  If used,
<code>riverdistanceseq()</code> will only return pairwise distances in which a
specified condition is met.</p>
</td></tr>
<tr><td><code id="riverdistanceseq_+3A_stopiferror">stopiferror</code></td>
<td>
<p>Whether or not to exit with an error if a route cannot be
found.  If this is set to <code>FALSE</code> and a route cannot be found,
the function will return <code>NA</code> in the appropriate entry.  Defaults to <code>TRUE</code>.  See <a href="#topic+detectroute">detectroute</a>.</p>
</td></tr>
<tr><td><code id="riverdistanceseq_+3A_algorithm">algorithm</code></td>
<td>
<p>Which route detection algorithm to use (<code>"Dijkstra"</code>,
<code>"sequential"</code>, or <code>"segroutes"</code>).  If left as <code>NULL</code> (the
default), the function will automatically make a selection.  See
<a href="#topic+detectroute">detectroute</a> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of distances (numeric), with rows defined by unique fish and columns defined by observation increment (1 to 2, 2 to 3, etc.)
</p>


<h3>Note</h3>

<p>Building routes from the river mouth to each river network segment and/or distance lookup tables will
greatly reduce computation time (see <a href="#topic+buildsegroutes">buildsegroutes</a>).
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+riverdistance">riverdistance</a>, <a href="#topic+plotseq">plotseq</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk, fakefish)
riverdistanceseq(unique=fakefish$fish.id, survey=fakefish$flight,
      seg=fakefish$seg, vert=fakefish$vert, rivers=Gulk)
     
seqbysurvey &lt;- riverdistanceseq(unique=fakefish$fish.id, survey=fakefish$flight.date,
      seg=fakefish$seg, vert=fakefish$vert, rivers=Gulk)
seqbysurvey
plotseq(seqbysurvey)
</code></pre>

<hr>
<h2 id='riverdistancetofrom'>River Distance Matrix between Two Datasets</h2><span id='topic+riverdistancetofrom'></span>

<h3>Description</h3>

<p>Returns a matrix of distances between each river location in two datasets, with one expressed as rows and the other expressed as columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riverdistancetofrom(
  seg1,
  vert1,
  seg2,
  vert2,
  rivers,
  logical1 = NULL,
  logical2 = NULL,
  ID1 = NULL,
  ID2 = NULL,
  stopiferror = TRUE,
  algorithm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="riverdistancetofrom_+3A_seg1">seg1</code></td>
<td>
<p>First vector of river locations (segment component).  These are expressed as rows in the output matrix.</p>
</td></tr>
<tr><td><code id="riverdistancetofrom_+3A_vert1">vert1</code></td>
<td>
<p>First vector of river locations (vertex component).  These are expressed as rows in the output matrix.</p>
</td></tr>
<tr><td><code id="riverdistancetofrom_+3A_seg2">seg2</code></td>
<td>
<p>Second vector of river locations (segment component).  These are expressed as columns in the output matrix.</p>
</td></tr>
<tr><td><code id="riverdistancetofrom_+3A_vert2">vert2</code></td>
<td>
<p>Second vector of river locations (vertex component).  These are expressed as columns in the output matrix.</p>
</td></tr>
<tr><td><code id="riverdistancetofrom_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use.</p>
</td></tr>
<tr><td><code id="riverdistancetofrom_+3A_logical1">logical1</code></td>
<td>
<p>A boolean vector that can be used for subsetting.  If used,
<code>riverdistancetofrom</code> will only return distances in which a
specified condition is met for the first dataset.</p>
</td></tr>
<tr><td><code id="riverdistancetofrom_+3A_logical2">logical2</code></td>
<td>
<p>A boolean vector that can be used for subsetting.  If used,
<code>riverdistancetofrom</code> will only return distances in which a
specified condition is met for the second dataset.</p>
</td></tr>
<tr><td><code id="riverdistancetofrom_+3A_id1">ID1</code></td>
<td>
<p>a vector of observation IDs for the first dataset that will be used as row names in the output matrix.</p>
</td></tr>
<tr><td><code id="riverdistancetofrom_+3A_id2">ID2</code></td>
<td>
<p>a vector of observation IDs for the second dataset that will be used as column names in the output matrix.</p>
</td></tr>
<tr><td><code id="riverdistancetofrom_+3A_stopiferror">stopiferror</code></td>
<td>
<p>Whether or not to exit with an error if a route cannot be
found.  If this is set to <code>FALSE</code> and a route cannot be found,
the function will return <code>NA</code> in the appropriate entry.  Defaults to <code>TRUE</code>.  See <a href="#topic+detectroute">detectroute</a>.</p>
</td></tr>
<tr><td><code id="riverdistancetofrom_+3A_algorithm">algorithm</code></td>
<td>
<p>Which route detection algorithm to use (<code>"Dijkstra"</code>,
<code>"sequential"</code>, or <code>"segroutes"</code>).  If left as <code>NULL</code> (the
default), the function will automatically make a selection.  See
<a href="#topic+detectroute">detectroute</a> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of distances (numeric) with rows and columns labeled by corresponding values of <code>ID</code>.
</p>


<h3>Note</h3>

<p>Building routes from the river mouth to each river network segment and/or distance lookup tables will
greatly reduce computation time (see <a href="#topic+buildsegroutes">buildsegroutes</a>).
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+riverdistance">riverdistance</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk)

streamlocs.seg &lt;- c(1,8,11)
streamlocs.vert &lt;- c(50,70,90)
streamlocs.ID &lt;- c("A","B","C")

fish.seg &lt;- c(1,4,9,12,14)
fish.vert &lt;- c(10,11,12,13,14)
fish.ID &lt;- c("fish1","fish2","fish3","fish4","fish5")

riverdistancetofrom(seg1=streamlocs.seg, vert1=streamlocs.vert,
  seg2=fish.seg, vert2=fish.vert, rivers=Gulk, ID1=streamlocs.ID, ID2=fish.ID)

logi1 &lt;- streamlocs.ID=="B" | streamlocs.ID=="C"
logi2 &lt;- fish.ID!="fish3"

riverdistancetofrom(seg1=streamlocs.seg, vert1=streamlocs.vert,
  seg2=fish.seg, vert2=fish.vert, rivers=Gulk, logical1=logi1, logical2=logi2,
  ID1=streamlocs.ID, ID2=fish.ID)
</code></pre>

<hr>
<h2 id='rivernetwork'>The &quot;rivernetwork&quot; Class</h2><span id='topic+rivernetwork'></span><span id='topic+rivernetwork-class'></span>

<h3>Description</h3>

<p>A class that holds spatial coordinates for river networks, as well as network topology and attributes.
</p>


<h3>Details</h3>

<p>Created by <a href="#topic+line2network">line2network</a> from an input line shapefile.  Contains all information for network distance calculation, plotting, etc. in the 'riverdist' package.
</p>
<p>Plotting methods are described in <a href="#topic+plot.rivernetwork">plot.rivernetwork</a>.
</p>


<h3>Elements</h3>


<dl>
<dt><code>sf</code>:</dt><dd><p>Object of class <code>"sf"</code> from package 'sf'; see <a href="sf.html#topic+sf">sf</a>.  This is the original object as read by <a href="sf.html#topic+read_sf">read_sf</a>, and is preserved to maintain plotting capability.</p>
</dd>
<dt><code>sf_current</code>:</dt><dd><p>Object of class <code>"sf"</code> from package 'sf'; see <a href="sf.html#topic+sf">sf</a>.  This is an updated <a href="sf.html#topic+sf">sf</a> object generated from the coordinates in the 'lines' element, incorporating any changes to geometry.  Any corresponding data will be dropped.</p>
</dd>
<dt><code>lines</code>:</dt><dd><p>Object of class <code>"list"</code>.  Each list element is a matrix of XY coordinates of the vertices of a single river segment.</p>
</dd>
<dt><code>connections</code>:</dt><dd><p>Object of class <code>"matrix"</code>, with <code>"numeric"</code> elements.  Defined as a square matrix, with elements describing the type of connection detected between line segments.
</p>

<ul>
<li><p> A value of 1 in element <code>[i,j]</code> indicates that the beginning of segment <code>i</code> is connected to the beginning of segment <code>j</code>.
</p>
</li>
<li><p> A value of 2 in element <code>[i,j]</code> indicates that the beginning of segment <code>i</code> is connected to the end of segment <code>j</code>.
</p>
</li>
<li><p> A value of 3 in element <code>[i,j]</code> indicates that the end of segment <code>i</code> is connected to the beginning of segment <code>j</code>.
</p>
</li>
<li><p> A value of 4 in element <code>[i,j]</code> indicates that the end of segment <code>i</code> is connected to the end of segment <code>j</code>.
</p>
</li>
<li><p> A value of 5 in element <code>[i,j]</code> indicates that segments <code>i</code> and <code>j</code> are connected at both beginning and end.
</p>
</li>
<li><p> A value of 6 in element <code>[i,j]</code> indicates that the beginning of segment <code>i</code> is connected to the end of segment <code>j</code>, and the end of segment <code>i</code> is connected to the beginning of segment <code>j</code>.
</p>
</li>
<li><p> A value of NA in element <code>[i,j]</code> indicates that segments <code>i</code> and <code>j</code> are not connected.</p>
</li></ul>
</dd>
<dt><code>lengths</code>:</dt><dd><p>Vector of class <code>"numeric"</code>.  Defined as the calculated total lengths of each river segment.</p>
</dd>
<dt><code>names</code>:</dt><dd><p>Vector of class <code>"character"</code>.  Defined as the names of each river segment.</p>
</dd>
<dt><code>mouth</code>:</dt><dd><p>Object of class <code>"list"</code>, with two elements.  Element <code>mouth.seg</code> gives the segment number of the mouth (lowest point) of the river network, and <code>mouth.vert</code> gives the vertex number.</p>
</dd>
<dt><code>sequenced</code>:</dt><dd><p><code>"logical"</code>: has value of TRUE if line vertices have been stored in upstream sequence using <a href="#topic+sequenceverts">sequenceverts</a>.</p>
</dd>
<dt><code>tolerance</code>:</dt><dd><p><code>"numeric"</code>: the spatial tolerance that was used in determining river segment endpoint connectivity; see <a href="#topic+line2network">line2network</a>, <a href="#topic+splitsegments">splitsegments</a>.</p>
</dd>
<dt><code>units</code>:</dt><dd><p><code>"character"</code>: the spatial units detected from the input shapefile.</p>
</dd>
<dt><code>braided</code>:</dt><dd><p><code>"logical"</code>: Has value of <code>TRUE</code> if <a href="#topic+checkbraidedTF">checkbraidedTF</a> has detected braiding, <code>FALSE</code> if no braiding has been detected, and <code>NA</code> if braiding has not yet been checked.</p>
</dd>
<dt><code>cumuldist</code>:</dt><dd><p>List of class <code>"numeric"</code>: Each element is a vector of cumulative distances along each river segment, beginning with 0.</p>
</dd>
<dt><code>segroutes</code>:</dt><dd><p>Object of class <code>"list"</code>, with each element defined as a vector of class <code>"numeric"</code>, describing the route from the mouth segment to the specific segment.  This element only exists if <a href="#topic+buildsegroutes">buildsegroutes</a> has been run, and can greatly speed up route and distance calculation.</p>
</dd>
<dt><code>distlookup</code>:</dt><dd><p>List of three matrices, of class <code>"numeric"</code> or <code>"logical"</code>.  Element <code>[i,j]</code> of each matrix corresponds to
the route between segment <code>i</code> and <code>j</code>.  The
<code>distlookup$middist</code> matrix gives the total distance of the &quot;middle&quot;
of each route (between the starting and ending segments&quot;), and the
<code>distlookup$starttop</code> and <code>distlookup$endtop</code> matrices have value
<code>TRUE</code>, <code>FALSE</code>, or <code>NA</code> if the segments at the beginning or
end of the route are connected to the rest of the route at the top of the
coordinate matrix, bottom of the coordinate matrix, or if the route is
contained to just one segment, respectively. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matt Tyers
</p>

<hr>
<h2 id='riverpoints'>Draw Points from River Locations</h2><span id='topic+riverpoints'></span>

<h3>Description</h3>

<p>Adds points to an active plot.  Works like <a href="graphics.html#topic+points">points</a> 
but with river locations (segments and vertices) rather than xy coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riverpoints(seg, vert, rivers, pch = 1, col = 1, jitter = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="riverpoints_+3A_seg">seg</code></td>
<td>
<p>A vector of segments</p>
</td></tr>
<tr><td><code id="riverpoints_+3A_vert">vert</code></td>
<td>
<p>A vector of vertices</p>
</td></tr>
<tr><td><code id="riverpoints_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
<tr><td><code id="riverpoints_+3A_pch">pch</code></td>
<td>
<p>Point character, as a vector or single value</p>
</td></tr>
<tr><td><code id="riverpoints_+3A_col">col</code></td>
<td>
<p>Point color, as a vector or single value</p>
</td></tr>
<tr><td><code id="riverpoints_+3A_jitter">jitter</code></td>
<td>
<p>Maximum amount of random noise to add to &quot;jitter&quot; points if 
desired, so points do not overlap one another</p>
</td></tr>
<tr><td><code id="riverpoints_+3A_...">...</code></td>
<td>
<p>Additional arguments for <a href="graphics.html#topic+points">points</a></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fakefish,Gulk)

plot(x=Gulk, xlim=c(862000,882000), ylim=c(6978000,6993000))
points(x=fakefish$x, y=fakefish$y, pch=16, col=2)
riverpoints(seg=fakefish$seg, vert=fakefish$vert, rivers=Gulk, pch=15, col=4)

plot(x=Gulk, empty=TRUE)
with(fakefish, riverpoints(seg=seg, vert=vert, rivers=Gulk, 
       pch=16, col=flight, jitter=1000))
</code></pre>

<hr>
<h2 id='routelist'>Detect Multiple Routes</h2><span id='topic+routelist'></span>

<h3>Description</h3>

<p>Called internally within <a href="#topic+riverdistancelist">riverdistancelist</a>.  Detects all possible routes from one river network segment to another, in the event
of braiding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>routelist(startseg, endseg, rivers, reps = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="routelist_+3A_startseg">startseg</code></td>
<td>
<p>Segment number of the start of the route</p>
</td></tr>
<tr><td><code id="routelist_+3A_endseg">endseg</code></td>
<td>
<p>Segment number of the end of the route</p>
</td></tr>
<tr><td><code id="routelist_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
<tr><td><code id="routelist_+3A_reps">reps</code></td>
<td>
<p>Deprecated.  Was used in a previous version using randomization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors, each describing a route in segment numbers.
</p>


<h3>Note</h3>

<p>The previous version of this function returned many possible routes using randomization - this algorithm now computes all possible routes.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(KilleyW)
plot(x=KilleyW)

routelist(startseg=1, endseg=16, rivers=KilleyW)
</code></pre>

<hr>
<h2 id='segvert2xy'>Convert River Locations to XY coordinates</h2><span id='topic+segvert2xy'></span>

<h3>Description</h3>

<p>This function is almost the reverse of <a href="#topic+xy2segvert">xy2segvert</a>, and
returns a data frame of the XY spatial coordinates corresponding to vectors
of segment and vertex.  It should be noted that this only returns the spatial
coordinates from the river network itself, and will not necessarily correspond
to the original set of point data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segvert2xy(seg, vert, rivers)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segvert2xy_+3A_seg">seg</code></td>
<td>
<p>A vector of river segments to transform</p>
</td></tr>
<tr><td><code id="segvert2xy_+3A_vert">vert</code></td>
<td>
<p>A vector of river vertices to transform</p>
</td></tr>
<tr><td><code id="segvert2xy_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of XY coordinates, given as <code>$snap_x</code> and <code>$snap_y</code>..
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+xy2segvert">xy2segvert</a>, <a href="#topic+pointshp2segvert">pointshp2segvert</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk,fakefish)
head(fakefish)

xy_from_segvert &lt;- segvert2xy(seg=fakefish$seg, vert=fakefish$vert, 
                   rivers=Gulk)
head(xy_from_segvert)

plot(x=Gulk, xlim=c(862000,882000), ylim=c(6978000,6993000))
points(x=fakefish$x, y=fakefish$y, pch=16, col=2)

points(x=xy_from_segvert$snap_x, y=xy_from_segvert$snap_y, pch=15, col=4)
</code></pre>

<hr>
<h2 id='sequenceverts'>Store Vertices in Ascending Sequence</h2><span id='topic+sequenceverts'></span>

<h3>Description</h3>

<p>Rearranges the vertices of a river network object so that 
vertices are stored sequentially moving up river for all segments 
(coordinates [1,] are the bottom of each segment).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sequenceverts(rivers)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sequenceverts_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new river network object (see <a href="#topic+rivernetwork">rivernetwork</a>)
</p>


<h3>Note</h3>

<p>Even without calling <code>sequenceverts</code>, the vertices will be stored 
sequentially - either moving up river or down for a given segment.  What 
<code>sequenceverts()</code> adds is a standardized direction.
</p>
<p>Currently, no function in package 'riverdist' requires the vertices to be stored 
sequentially.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+line2network">line2network</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk)
Gulk &lt;- setmouth(seg=1, vert=1, rivers=Gulk)
str(Gulk)

Gulk.dir &lt;- sequenceverts(rivers=Gulk)
str(Gulk.dir)
</code></pre>

<hr>
<h2 id='setmouth'>Specify the Segment and Vertex of the Mouth of a River Network Object.</h2><span id='topic+setmouth'></span>

<h3>Description</h3>

<p>Provides a user-friendly way of specifying the segment and
vertex of the mouth (lowest point) of a river network object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setmouth(seg, vert, rivers)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setmouth_+3A_seg">seg</code></td>
<td>
<p>The segment number to store for the mouth</p>
</td></tr>
<tr><td><code id="setmouth_+3A_vert">vert</code></td>
<td>
<p>The vertex number to store for the mouth</p>
</td></tr>
<tr><td><code id="setmouth_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new river network object (see <a href="#topic+rivernetwork">rivernetwork</a>)
</p>


<h3>Note</h3>

<p>The mouth segment and vertex can also be specified using direct
assignment to the <code>$mouth$seg</code> and <code>$mouth$vert</code> components of the river network
object.
</p>
<p>This function is called within <a href="#topic+cleanup">cleanup</a>, which is recommended in most cases.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+line2network">line2network</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk)

# say we know that segment 1 is the lowest segment in this river network, but we don't know 
# which end is the mouth.
showends(seg=1, rivers=Gulk)

# this means that the mouth is row 1, so we can specify this:
Gulk &lt;- setmouth(seg=1, vert=1, rivers=Gulk)
</code></pre>

<hr>
<h2 id='showends'>Identify Vertex Coordinates of Segment Endpoints</h2><span id='topic+showends'></span>

<h3>Description</h3>

<p>Identifies the vertex coordinates (row numbers) of the endpoints
of a given segment.  The main purpose is determining which of the endpoints
is the mouth (or lowest point) of the river system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showends(seg, rivers)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="showends_+3A_seg">seg</code></td>
<td>
<p>The segment (number) to check</p>
</td></tr>
<tr><td><code id="showends_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is called within <a href="#topic+cleanup">cleanup</a>, which is recommended in most cases.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk)

# say we know that segment 1 is the lowest segment in this river network, but we don't know 
# which end is the mouth.
showends(seg=1, rivers=Gulk)

# this means that the mouth is row 1, so we can specify this:
Gulk &lt;- setmouth(seg=1, vert=1, rivers=Gulk)
</code></pre>

<hr>
<h2 id='smallset'>Dataset: Smallset</h2><span id='topic+smallset'></span>

<h3>Description</h3>

<p>A small set of observations of fakefish on the Gulkana River and its tributaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(smallset)
</code></pre>


<h3>Format</h3>

<p>A data frame
</p>


<h3>Details</h3>

 
<ul>
<li> <p><code>x</code>. X-coordinate of observation (Alaska Albers Equal Area). Note that the locations do not align with the river network object. 
</p>
</li>
<li> <p><code>y</code>. Y-coordinate of observation 
</p>
</li>
<li> <p><code>seg</code>. River segment 
</p>
</li>
<li> <p><code>vert</code>. River vertex
</p>
</li>
<li> <p><code>fish.id</code>. Numeric identifier for each fish (individual fish were observed more than once) 
</p>
</li>
<li> <p><code>flight</code>. Numeric identifier for each telemetry flight
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+Gulk">Gulk</a>
</p>

<hr>
<h2 id='splitsegmentat'>Split a Segment at a Specified Vertex</h2><span id='topic+splitsegmentat'></span>

<h3>Description</h3>

<p>Splits a segment at a specified vertex, creating two new segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitsegmentat(seg, vert, rivers)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splitsegmentat_+3A_seg">seg</code></td>
<td>
<p>The segment to split</p>
</td></tr>
<tr><td><code id="splitsegmentat_+3A_vert">vert</code></td>
<td>
<p>The vertex to split it at</p>
</td></tr>
<tr><td><code id="splitsegmentat_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new, updated river network object
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+line2network">line2network</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk)
plot(x=Gulk)

Gulk2 &lt;- splitsegmentat(seg=1, vert=400, rivers=Gulk)
plot(x=Gulk2)
</code></pre>

<hr>
<h2 id='splitsegments'>Split Segments by Endpoint Proximity</h2><span id='topic+splitsegments'></span>

<h3>Description</h3>

<p>Detects cases in which segments should be split to establish
appropriate topology, and splits them.  Specifically, it looks for segment
endpoints intersecting (or within a tolerance of) another
segment.  It then splits the intersected segment at the point where the
endpoint of the other segment breaks it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitsegments(
  rivers,
  tolerance = NULL,
  splitthese = NULL,
  splitthemat = NULL,
  one2one = FALSE,
  append = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splitsegments_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
<tr><td><code id="splitsegments_+3A_tolerance">tolerance</code></td>
<td>
<p>The spatial snapping tolerance to use for detecting
intersection.  If a NULL value is used (default), it will default to the
tolerance that was used in river network creation in <a href="#topic+line2network">line2network</a>.</p>
</td></tr>
<tr><td><code id="splitsegments_+3A_splitthese">splitthese</code></td>
<td>
<p>An optional vector of target segments to split.  If this argument is used, only these segments will be split.  If the default (<code>NULL</code>) is accepted, all segments will be used.</p>
</td></tr>
<tr><td><code id="splitsegments_+3A_splitthemat">splitthemat</code></td>
<td>
<p>An optional vector of segments (endpoints) to use for splitting.  If this argument is used, segments will only be split at the endpoints of these segments.  If the default (<code>NULL</code>) is accepted, all segments will be used.</p>
</td></tr>
<tr><td><code id="splitsegments_+3A_one2one">one2one</code></td>
<td>
<p>Logical, indicating a one-to-one correspondence between arguments <code>splitthese</code> and <code>splitthemat</code>.  Defaults to <code>FALSE</code>,</p>
</td></tr>
<tr><td><code id="splitsegments_+3A_append">append</code></td>
<td>
<p>Logical, indicating how to organize the output river network.  If <code>TRUE</code>, appends newly-created segments to the end of <code>$lines</code>, rather than retaining original line ordering.  This may be useful in retaining original line ID.  Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new, updated river network object
</p>


<h3>Note</h3>

<p>This function is called within <a href="#topic+cleanup">cleanup</a>, which is recommended in most cases.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+line2network">line2network</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Koyukuk1)
topologydots(rivers=Koyukuk1)
# Segments 7, 8, 13, and 16 need to be split so topologies will work.  
# Since endpoints are not in the same place, they are not detected as 
# being connected.
plot(x=Koyukuk1)

Koyukuk1split &lt;- splitsegments(rivers=Koyukuk1)
topologydots(rivers=Koyukuk1split)
plot(x=Koyukuk1split)

# if only segment 17 were to be split in three places
plot(x=splitsegments(rivers=Koyukuk1, splitthese=c(7,7,7),
        splitthemat=c(14,5,12)))
        
# if only segment 16 were to be split, showing behavior of append=
plot(x=splitsegments(rivers=Koyukuk1, splitthese=c(7,7,7),
        splitthemat=c(14,5,12), append=TRUE))
</code></pre>

<hr>
<h2 id='topologydots'>Check Connectivity of a River Network Object</h2><span id='topic+topologydots'></span>

<h3>Description</h3>

<p>Produces a graphical check of the connectivity of a river 
network object.  It produces a <a href="base.html#topic+plot">plot</a> of the river network object,
and overlays red dots at non-connected endpoints and green dots at 
connected endpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topologydots(rivers, add = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="topologydots_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to check</p>
</td></tr>
<tr><td><code id="topologydots_+3A_add">add</code></td>
<td>
<p>Whether call a new plot (<code>FALSE</code>) or add dots to an existing
plot (<code>TRUE</code>).  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="topologydots_+3A_...">...</code></td>
<td>
<p>Additional plotting arguments (see <a href="graphics.html#topic+par">par</a>)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+line2network">line2network</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk)
topologydots(rivers=Gulk)
</code></pre>

<hr>
<h2 id='trimriver'>Trim a River Network Object to Specified Segments</h2><span id='topic+trimriver'></span>

<h3>Description</h3>

<p>Removes line segments from a river network object.  User can 
specify which segments to remove (<code>trim</code>) or which segments to 
keep (<code>trimto</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimriver(trim = NULL, trimto = NULL, rivers)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trimriver_+3A_trim">trim</code></td>
<td>
<p>Vector of line segments to remove</p>
</td></tr>
<tr><td><code id="trimriver_+3A_trimto">trimto</code></td>
<td>
<p>Vector of line segments to keep</p>
</td></tr>
<tr><td><code id="trimriver_+3A_rivers">rivers</code></td>
<td>
<p>The river network object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new river network object
</p>


<h3>Note</h3>

<p>Specifying segments in both trim and trimto arguments will result in an error.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+line2network">line2network</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Kenai1)
plot(x=Kenai1)

Kenai1.trim &lt;- trimriver(trim=c(46,32,115,174,169,114,124,142,80), rivers=Kenai1)
plot(x=Kenai1.trim)
 
Kenai1.trim.2 &lt;- trimriver(trimto=c(20,57,118,183,45,162,39,98,19), rivers=Kenai1)
plot(x=Kenai1.trim.2)
</code></pre>

<hr>
<h2 id='trimtopoints'>Trim a River Network to a Set of X-Y Coordinates</h2><span id='topic+trimtopoints'></span>

<h3>Description</h3>

<p>Removes line segments from a river network object that are not
adjacent to a set of point data, given in X-Y coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimtopoints(x, y, rivers, method = "snap", dist = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trimtopoints_+3A_x">x</code></td>
<td>
<p>Vector of x-coordinates of point data to buffer around</p>
</td></tr>
<tr><td><code id="trimtopoints_+3A_y">y</code></td>
<td>
<p>Vector of y-coordinates of point data to buffer around</p>
</td></tr>
<tr><td><code id="trimtopoints_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
<tr><td><code id="trimtopoints_+3A_method">method</code></td>
<td>
<p>Three methods are available.  If <code>"snap"</code> is specified
(the default), only the closest segment to each point is retained.   If
<code>"snaproute"</code> is specified, segments are also retained that will
maintain total connectivity in the resulting river network.  If
<code>"buffer"</code> is specified, all segments with endpoints or midpoints
within <code>dist</code> units of the input locations are retained.</p>
</td></tr>
<tr><td><code id="trimtopoints_+3A_dist">dist</code></td>
<td>
<p>Distance to use for buffering, if <code>method="buffer"</code>.  If
this is not specified, the maximum spread in the x- and y- direction will
be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new river network object (see <a href="#topic+rivernetwork">rivernetwork</a>)
</p>


<h3>Note</h3>

<p>If <code>method=="buffer"</code>, only distances to segment endpoints 
and midpoints are checked, and still only whole segments are removed.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+line2network">line2network</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Koyukuk2)
x &lt;- c(139241.0, 139416.1, 124600.1, 122226.8)
y &lt;- c(1917577, 1913864, 1898723, 1898792)

plot(x=Koyukuk2)
points(x, y, pch=15, col=4)
legend(par("usr")[1], par("usr")[4], legend="points to buffer around", pch=15, col=4, cex=.6)

Koyukuk2.buf1 &lt;- trimtopoints(x, y, rivers=Koyukuk2, method="snap")
plot(x=Koyukuk2.buf1)
points(x, y, pch=15, col=4)

Koyukuk2.buf2 &lt;- trimtopoints(x, y, rivers=Koyukuk2, method="snaproute")
plot(x=Koyukuk2.buf2)
points(x, y, pch=15, col=4)

Koyukuk2.buf3 &lt;- trimtopoints(x, y, rivers=Koyukuk2, method="buffer", dist=1000)
plot(x=Koyukuk2.buf3)
points(x, y, pch=15, col=4)
</code></pre>

<hr>
<h2 id='upstream'>Upstream River Distance</h2><span id='topic+upstream'></span>

<h3>Description</h3>

<p>Calculates river network distances as +/-, defined as
upriver/downriver.
</p>
<p>Specifying <code>net=TRUE</code> will compute net upriver distance (3 river km
down a tributary and then 15 river km up the mainstem will mean 12 rkm net.
Otherwise the function will return 18 rkm upriver travel.)
</p>
<p>The mouth (lowest point) segment and vertex must be specified (see
<a href="#topic+setmouth">setmouth</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upstream(
  startseg,
  endseg,
  startvert,
  endvert,
  rivers,
  flowconnected = FALSE,
  net = FALSE,
  stopiferror = TRUE,
  algorithm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="upstream_+3A_startseg">startseg</code></td>
<td>
<p>Segment number of the start of the route</p>
</td></tr>
<tr><td><code id="upstream_+3A_endseg">endseg</code></td>
<td>
<p>Segment number of the end of the route</p>
</td></tr>
<tr><td><code id="upstream_+3A_startvert">startvert</code></td>
<td>
<p>Vertex number of the start of the route</p>
</td></tr>
<tr><td><code id="upstream_+3A_endvert">endvert</code></td>
<td>
<p>Vertex number of the end of the route</p>
</td></tr>
<tr><td><code id="upstream_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
<tr><td><code id="upstream_+3A_flowconnected">flowconnected</code></td>
<td>
<p>If <code>TRUE</code>, only returns distance if the two input segments are flow-connected.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="upstream_+3A_net">net</code></td>
<td>
<p>Whether to calculate net distance (<code>net=TRUE</code>) or total
distance (<code>net=FALSE</code>)</p>
</td></tr>
<tr><td><code id="upstream_+3A_stopiferror">stopiferror</code></td>
<td>
<p>Whether or not to exit with an error if a route cannot be
found.  If this is set to <code>FALSE</code> and a route cannot be found,
the function will return <code>NA</code> in the appropriate entry.  Defaults to <code>TRUE</code>.  See <a href="#topic+detectroute">detectroute</a>.</p>
</td></tr>
<tr><td><code id="upstream_+3A_algorithm">algorithm</code></td>
<td>
<p>Which route detection algorithm to use (<code>"Dijkstra"</code>,
<code>"sequential"</code>, or <code>"segroutes"</code>).  If left as <code>NULL</code> (the
default), the function will automatically make a selection.  See
<a href="#topic+detectroute">detectroute</a> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Upstream distance (numeric).  Returns NA if <code>flowconnected</code> has value <code>TRUE</code> and the two segments are not flow-connected.
</p>


<h3>Note</h3>

<p>Building routes from the river mouth to each river network segment and/or distance lookup tables will
greatly reduce computation time (see <a href="#topic+buildsegroutes">buildsegroutes</a>).
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+setmouth">setmouth</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk)

# Mouth must be specified
Gulk$mouth$mouth.seg &lt;- 1
Gulk$mouth$mouth.vert &lt;- 1

plot(x=Gulk)
riverpoints(seg=c(6,4), vert=c(140,140), pch=16, col=2, rivers=Gulk)
upstream(startseg=6, endseg=4, startvert=140, endvert=40, rivers=Gulk, net=TRUE)
upstream(startseg=6, endseg=4, startvert=140, endvert=40, rivers=Gulk, net=FALSE)
upstream(startseg=6, endseg=4, startvert=140, endvert=40, rivers=Gulk, flowconnected=TRUE)
</code></pre>

<hr>
<h2 id='upstreammat'>Upstream Distance Matrix</h2><span id='topic+upstreammat'></span>

<h3>Description</h3>

<p>Returns a matrix of upstream distance between every point and
every other point of given river locations (segment and vertex), or of a
subset.  The mouth (lowest point) segment and vertex must be specified
(see <a href="#topic+setmouth">setmouth</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upstreammat(
  seg,
  vert,
  rivers,
  logical = NULL,
  ID = NULL,
  flowconnected = FALSE,
  net = FALSE,
  stopiferror = TRUE,
  algorithm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="upstreammat_+3A_seg">seg</code></td>
<td>
<p>A vector of river locations (segment component).</p>
</td></tr>
<tr><td><code id="upstreammat_+3A_vert">vert</code></td>
<td>
<p>A vector of river locations (vertex component).</p>
</td></tr>
<tr><td><code id="upstreammat_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use.</p>
</td></tr>
<tr><td><code id="upstreammat_+3A_logical">logical</code></td>
<td>
<p>A boolean vector that can be used for subsetting - if used,
riverdirectionseq() will only return pairwise distances in which a
specified condition is met.</p>
</td></tr>
<tr><td><code id="upstreammat_+3A_id">ID</code></td>
<td>
<p>a vector of observation IDs for aid in interpreting the output
table</p>
</td></tr>
<tr><td><code id="upstreammat_+3A_flowconnected">flowconnected</code></td>
<td>
<p>If <code>TRUE</code>, only returns distance if the input segments are flow-connected.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="upstreammat_+3A_net">net</code></td>
<td>
<p>Whether to calculate net upstream distance (net=TRUE) or total
distance (net=FALSE, default).  See <a href="#topic+upstream">upstream</a>.</p>
</td></tr>
<tr><td><code id="upstreammat_+3A_stopiferror">stopiferror</code></td>
<td>
<p>Whether or not to exit with an error if a route cannot be
found.  If this is set to <code>FALSE</code> and a route cannot be found,
the function will return <code>NA</code> in the appropriate entry.  Defaults to <code>TRUE</code>.  See <a href="#topic+detectroute">detectroute</a>.</p>
</td></tr>
<tr><td><code id="upstreammat_+3A_algorithm">algorithm</code></td>
<td>
<p>Which route detection algorithm to use (<code>"Dijkstra"</code>,
<code>"sequential"</code>, or <code>"segroutes"</code>).  If left as <code>NULL</code> (the
default), the function will automatically make a selection.  See
<a href="#topic+detectroute">detectroute</a> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of upstream distances (numeric) with rows and columns
labeled by corresponding values of <code>ID</code>.  See <a href="#topic+upstream">upstream</a> for additional information.
</p>


<h3>Note</h3>

<p>Building routes from the river mouth to each river network segment and/or distance lookup tables will
greatly reduce computation time (see <a href="#topic+buildsegroutes">buildsegroutes</a>).
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+upstream">upstream</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk, fakefish)

# Mouth must be specified
Gulk$mouth$mouth.seg &lt;- 1
Gulk$mouth$mouth.vert &lt;- 1

logi1 &lt;- (fakefish$flight.date==as.Date("2015-11-25"))

upstreammat(seg=fakefish$seg, vert=fakefish$vert, rivers=Gulk, logical=logi1)
</code></pre>

<hr>
<h2 id='upstreammatbysurvey'>Upstream Distance Matrix of All Observations of an Individual</h2><span id='topic+upstreammatbysurvey'></span>

<h3>Description</h3>

<p>Returns a matrix of upstream travel distance between all observations of
one unique fish.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upstreammatbysurvey(
  indiv,
  unique,
  survey,
  seg,
  vert,
  rivers,
  full = TRUE,
  flowconnected = FALSE,
  net = FALSE,
  stopiferror = TRUE,
  algorithm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="upstreammatbysurvey_+3A_indiv">indiv</code></td>
<td>
<p>The unique identifier of the fish in question.</p>
</td></tr>
<tr><td><code id="upstreammatbysurvey_+3A_unique">unique</code></td>
<td>
<p>A vector of identifiers for each fish.</p>
</td></tr>
<tr><td><code id="upstreammatbysurvey_+3A_survey">survey</code></td>
<td>
<p>A vector of identifiers for each survey.  It is recommended to
use a numeric or date format (see <a href="base.html#topic+as.Date">as.Date</a>) to preserve survey order.</p>
</td></tr>
<tr><td><code id="upstreammatbysurvey_+3A_seg">seg</code></td>
<td>
<p>A vector of river locations (segment component).</p>
</td></tr>
<tr><td><code id="upstreammatbysurvey_+3A_vert">vert</code></td>
<td>
<p>A vector of river locations (vertex component).</p>
</td></tr>
<tr><td><code id="upstreammatbysurvey_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use.</p>
</td></tr>
<tr><td><code id="upstreammatbysurvey_+3A_full">full</code></td>
<td>
<p>Whether to return the full matrix, with <code>NA</code> values for
missing data (<code>TRUE</code>), or a the subset of rows and columns
corresponding to successful observations.  Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="upstreammatbysurvey_+3A_flowconnected">flowconnected</code></td>
<td>
<p>If <code>TRUE</code>, only returns direction if the input segments are flow-connected.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="upstreammatbysurvey_+3A_net">net</code></td>
<td>
<p>Whether to calculate net upstream distance (net=TRUE) or total
distance (net=FALSE, default).</p>
</td></tr>
<tr><td><code id="upstreammatbysurvey_+3A_stopiferror">stopiferror</code></td>
<td>
<p>Whether or not to exit with an error if a route cannot be
found.  If this is set to <code>FALSE</code> and a route cannot be found, the
function will return <code>NA</code> in the appropriate entry.  Defaults to
<code>TRUE</code>.  See <a href="#topic+detectroute">detectroute</a>.</p>
</td></tr>
<tr><td><code id="upstreammatbysurvey_+3A_algorithm">algorithm</code></td>
<td>
<p>Which route detection algorithm to use (<code>"Dijkstra"</code>,
<code>"sequential"</code>, or <code>"segroutes"</code>).  If left as <code>NULL</code> (the
default), the function will automatically make a selection.  See
<a href="#topic+detectroute">detectroute</a> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of upstream distances (numeric), with rows and columns defined by
survey.  In the resulting matrix, the element with the row identified as
<code>A</code> and column identified as <code>B</code> is defined as the upstream distance
traveled from survey A to survey B.  Therefore, it is likely that only the
upper triangle of the matrix will be of interest.
</p>


<h3>Note</h3>

<p>Building routes from the river mouth to each river network segment and/or distance lookup tables will
greatly reduce computation time (see <a href="#topic+buildsegroutes">buildsegroutes</a>).
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+upstream">upstream</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk, fakefish)
upstreammatbysurvey(indiv=1, unique=fakefish$fish.id, survey=fakefish$flight,
      seg=fakefish$seg, vert=fakefish$vert, rivers=Gulk)
     
upstreammatbysurvey(indiv=1, unique=fakefish$fish.id, survey=fakefish$flight,
      seg=fakefish$seg, vert=fakefish$vert, rivers=Gulk, full=FALSE)
</code></pre>

<hr>
<h2 id='upstreamseq'>Upstream Distance Between Sequential Observations</h2><span id='topic+upstreamseq'></span>

<h3>Description</h3>

<p>Returns a matrix of distance with direction by unique fish
between sequential surveys.  The mouth (lowest point) segment and vertex
must be specified (see <a href="#topic+setmouth">setmouth</a>).  A plotting method is provided for the output; see <a href="#topic+plotseq">plotseq</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upstreamseq(
  unique,
  survey,
  seg,
  vert,
  rivers,
  logical = NULL,
  flowconnected = FALSE,
  net = FALSE,
  stopiferror = TRUE,
  algorithm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="upstreamseq_+3A_unique">unique</code></td>
<td>
<p>A vector of identifiers for each fish.</p>
</td></tr>
<tr><td><code id="upstreamseq_+3A_survey">survey</code></td>
<td>
<p>A vector of identifiers for each survey.  It is recommended to use a numeric or date format (see <a href="base.html#topic+as.Date">as.Date</a>) to preserve survey order.</p>
</td></tr>
<tr><td><code id="upstreamseq_+3A_seg">seg</code></td>
<td>
<p>A vector of river locations (segment component).</p>
</td></tr>
<tr><td><code id="upstreamseq_+3A_vert">vert</code></td>
<td>
<p>A vector of river locations (vertex component).</p>
</td></tr>
<tr><td><code id="upstreamseq_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use.</p>
</td></tr>
<tr><td><code id="upstreamseq_+3A_logical">logical</code></td>
<td>
<p>A boolean vector that can be used for subsetting - if used,
<code>upstreamseq()</code> will only return pairwise distances in which a
specified condition is met.</p>
</td></tr>
<tr><td><code id="upstreamseq_+3A_flowconnected">flowconnected</code></td>
<td>
<p>If <code>TRUE</code>, only returns distance if the input segments are flow-connected.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="upstreamseq_+3A_net">net</code></td>
<td>
<p>Whether to calculate net upstream distance (net=TRUE) or total
distance (net=FALSE, default).</p>
</td></tr>
<tr><td><code id="upstreamseq_+3A_stopiferror">stopiferror</code></td>
<td>
<p>Whether or not to exit with an error if a route cannot be
found.  If this is set to <code>FALSE</code> and a route cannot be found,
the function will return <code>NA</code> in the appropriate entry.  Defaults to <code>TRUE</code>.  See <a href="#topic+detectroute">detectroute</a>.</p>
</td></tr>
<tr><td><code id="upstreamseq_+3A_algorithm">algorithm</code></td>
<td>
<p>Which route detection algorithm to use (<code>"Dijkstra"</code>,
<code>"sequential"</code>, or <code>"segroutes"</code>).  If left as <code>NULL</code> (the
default), the function will automatically make a selection.  See
<a href="#topic+detectroute">detectroute</a> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of upstream distances (numeric), with rows defined by
unique fish and columns defined by observation increment (1 to 2, 2 to 3,
etc.)  See <a href="#topic+upstream">upstream</a> for additional information.
</p>


<h3>Note</h3>

<p>Returns either net upstream distance (net=TRUE) or total distance
(net=FALSE, default).  See <a href="#topic+upstream">upstream</a>.
</p>
<p>Building routes from the river mouth to each river network segment and/or distance lookup tables will
greatly reduce computation time (see <a href="#topic+buildsegroutes">buildsegroutes</a>).
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+upstream">upstream</a>, <a href="#topic+plotseq">plotseq</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk, fakefish)

# Mouth must be specified
Gulk$mouth$mouth.seg &lt;- 1
Gulk$mouth$mouth.vert &lt;- 1

upstreamseq(unique=fakefish$fish.id, survey=fakefish$flight, seg=fakefish$seg,
      vert=fakefish$vert, rivers=Gulk)

seqbysurvey &lt;- upstreamseq(unique=fakefish$fish.id, survey=fakefish$flight.date, seg=fakefish$seg,
      vert=fakefish$vert, rivers=Gulk)
seqbysurvey
plotseq(seqbysurvey)
</code></pre>

<hr>
<h2 id='upstreamtofrom'>Upstream Distance Matrix between Two Datasets</h2><span id='topic+upstreamtofrom'></span>

<h3>Description</h3>

<p>Returns a matrix of upstream distances between each river location in two datasets, with one expressed as rows and the other expressed as columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upstreamtofrom(
  seg1,
  vert1,
  seg2,
  vert2,
  rivers,
  logical1 = NULL,
  logical2 = NULL,
  ID1 = NULL,
  ID2 = NULL,
  net = FALSE,
  flowconnected = FALSE,
  stopiferror = TRUE,
  algorithm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="upstreamtofrom_+3A_seg1">seg1</code></td>
<td>
<p>First vector of river locations (segment component).  These are expressed as rows in the output matrix.</p>
</td></tr>
<tr><td><code id="upstreamtofrom_+3A_vert1">vert1</code></td>
<td>
<p>First vector of river locations (vertex component).  These are expressed as rows in the output matrix.</p>
</td></tr>
<tr><td><code id="upstreamtofrom_+3A_seg2">seg2</code></td>
<td>
<p>Second vector of river locations (segment component).  These are expressed as columns in the output matrix.</p>
</td></tr>
<tr><td><code id="upstreamtofrom_+3A_vert2">vert2</code></td>
<td>
<p>Second vector of river locations (vertex component).  These are expressed as columns in the output matrix.</p>
</td></tr>
<tr><td><code id="upstreamtofrom_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use.</p>
</td></tr>
<tr><td><code id="upstreamtofrom_+3A_logical1">logical1</code></td>
<td>
<p>A boolean vector that can be used for subsetting.  If used,
<code>upstreamtofrom</code> will only return upstream distances in which a
specified condition is met for the first dataset.</p>
</td></tr>
<tr><td><code id="upstreamtofrom_+3A_logical2">logical2</code></td>
<td>
<p>A boolean vector that can be used for subsetting.  If used,
<code>upstreamtofrom</code> will only return upstream distances in which a
specified condition is met for the second dataset.</p>
</td></tr>
<tr><td><code id="upstreamtofrom_+3A_id1">ID1</code></td>
<td>
<p>a vector of observation IDs for the first dataset that will be used as row names in the output matrix.</p>
</td></tr>
<tr><td><code id="upstreamtofrom_+3A_id2">ID2</code></td>
<td>
<p>a vector of observation IDs for the second dataset that will be used as column names in the output matrix.</p>
</td></tr>
<tr><td><code id="upstreamtofrom_+3A_net">net</code></td>
<td>
<p>Whether to calculate net upstream distance (<code>TRUE</code>) or signed total distance (<code>FALSE</code>).  See <a href="#topic+upstream">upstream</a>.</p>
</td></tr>
<tr><td><code id="upstreamtofrom_+3A_flowconnected">flowconnected</code></td>
<td>
<p>If <code>TRUE</code>, only returns distance if the input segments are flow-connected.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="upstreamtofrom_+3A_stopiferror">stopiferror</code></td>
<td>
<p>Whether or not to exit with an error if a route cannot be
found.  If this is set to <code>FALSE</code> and a route cannot be found,
the function will return <code>NA</code> in the appropriate entry.  Defaults to <code>TRUE</code>.  See <a href="#topic+detectroute">detectroute</a>.</p>
</td></tr>
<tr><td><code id="upstreamtofrom_+3A_algorithm">algorithm</code></td>
<td>
<p>Which route detection algorithm to use (<code>"Dijkstra"</code>,
<code>"sequential"</code>, or <code>"segroutes"</code>).  If left as <code>NULL</code> (the
default), the function will automatically make a selection.  See
<a href="#topic+detectroute">detectroute</a> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of upstream distances (numeric) with rows and columns labeled by corresponding values of <code>ID</code>.  See <a href="#topic+upstream">upstream</a> for additional information.
</p>


<h3>Note</h3>

<p>Building routes from the river mouth to each river network segment and/or distance lookup tables will
greatly reduce computation time (see <a href="#topic+buildsegroutes">buildsegroutes</a>).
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+upstream">upstream</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk)

streamlocs.seg &lt;- c(1,8,11)
streamlocs.vert &lt;- c(50,70,90)
streamlocs.ID &lt;- c("A","B","C")

fish.seg &lt;- c(1,4,9,12,14)
fish.vert &lt;- c(10,11,12,13,14)
fish.ID &lt;- c("fish1","fish2","fish3","fish4","fish5")

Gulk &lt;- setmouth(seg=1, vert=1, rivers=Gulk)

upstreamtofrom(seg1=streamlocs.seg, vert1=streamlocs.vert,
  seg2=fish.seg, vert2=fish.vert, rivers=Gulk,
  ID1=streamlocs.ID, ID2=fish.ID)

logi1 &lt;- streamlocs.ID=="B" | streamlocs.ID=="C"
logi2 &lt;- fish.ID!="fish3"

upstreamtofrom(seg1=streamlocs.seg, vert1=streamlocs.vert,
  seg2=fish.seg, vert2=fish.vert, rivers=Gulk, logical1=logi1,
  logical2=logi2, ID1=streamlocs.ID, ID2=fish.ID)
</code></pre>

<hr>
<h2 id='whoconnected'>Check Which Segments are Connected to a Given Segment.</h2><span id='topic+whoconnected'></span>

<h3>Description</h3>

<p>Returns which segments are connected to a specified segment within a river network.  It may be useful for error checking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whoconnected(seg, rivers)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="whoconnected_+3A_seg">seg</code></td>
<td>
<p>The segment to check</p>
</td></tr>
<tr><td><code id="whoconnected_+3A_rivers">rivers</code></td>
<td>
<p>The river network object it belongs to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of segment numbers
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk)
plot(Gulk)
whoconnected(seg=4, rivers=Gulk)
</code></pre>

<hr>
<h2 id='xy2segvert'>Convert XY Coordinates to River Locations</h2><span id='topic+xy2segvert'></span>

<h3>Description</h3>

<p>This function determines the closest vertex in the river network
to each point of XY data and returns a list of river locations, defined 
as segment numbers and vertex numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xy2segvert(x, y, rivers)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xy2segvert_+3A_x">x</code></td>
<td>
<p>A vector of x-coordinates to transform</p>
</td></tr>
<tr><td><code id="xy2segvert_+3A_y">y</code></td>
<td>
<p>A vector of y-coordinates to transform</p>
</td></tr>
<tr><td><code id="xy2segvert_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of river locations, with segment numbers in <code>$seg</code>, 
vertex numbers in <code>$vert</code>, and the snapping distance for each point in 
<code>$snapdist</code>.  Two additional columns are <code>$snap_x</code> and <code>$snap_y</code>,
which give the x- and y-coordinates snapped to the river network.
</p>


<h3>Note</h3>

<p>Conversion to river locations is only valid if the input XY 
coordinates and river network are in the same projected coordinate system. 
Point data in geographic coordinates can be projected using 
<a href="sf.html#topic+sf_project">sf_project</a> in package 'sf', and an example is shown below.
</p>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>See Also</h3>

<p><a href="#topic+pointshp2segvert">pointshp2segvert</a>, <a href="#topic+segvert2xy">segvert2xy</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Gulk,fakefish)
head(fakefish)

fakefish.riv &lt;- xy2segvert(x=fakefish$x, y=fakefish$y, rivers=Gulk)
head(fakefish.riv)

plot(x=Gulk, xlim=c(862000,882000), ylim=c(6978000,6993000))
points(fakefish$x, fakefish$y, pch=16, col=2)
riverpoints(seg=fakefish.riv$seg, vert=fakefish.riv$vert, rivers=Gulk, pch=15, col=4)


## converting a matrix of points stored in long-lat to Alaska Albers Equal Area:
data(line98, Kenai1)
head(line98)  # note that coordinates are stored in long-lat, NOT lat-long

line98albers &lt;- sf::sf_project(pts=line98, to="+proj=aea +lat_1=55 +lat_2=65 
    +lat_0=50 +lon_0=-154 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs 
    +ellps=GRS80")
head(line98albers)

zoomtoseg(seg=c(162,19), rivers=Kenai1)
points(line98albers)
</code></pre>

<hr>
<h2 id='zoomtoseg'>Zoom to segment</h2><span id='topic+zoomtoseg'></span>

<h3>Description</h3>

<p>Calls <a href="#topic+plot.rivernetwork">plot.rivernetwork</a> and automatically zooms to a specified
segment or vector of segments.  Not intended for any real mapping - just
investigating and error checking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zoomtoseg(seg, rivers, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zoomtoseg_+3A_seg">seg</code></td>
<td>
<p>A segment or vector of segments to zoom to</p>
</td></tr>
<tr><td><code id="zoomtoseg_+3A_rivers">rivers</code></td>
<td>
<p>The river network object to use</p>
</td></tr>
<tr><td><code id="zoomtoseg_+3A_...">...</code></td>
<td>
<p>Additional plotting arguments (see <a href="graphics.html#topic+par">par</a>)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Tyers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Kenai3)
plot(x=Kenai3)

# checking out a particularly messy region...
zoomtoseg(c(110,63), rivers=Kenai3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
