<!DOCTYPE html><html><head><title>Help for package biogram</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {biogram}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#biogram-package'><p>biogram - analysis of biological sequences using n-grams</p></a></li>
<li><a href='#aaprop'><p>Normalized amino acids properties</p></a></li>
<li><a href='#add_1grams'><p>Add 1-grams</p></a></li>
<li><a href='#as.data.frame.feature_test'><p>Coerce feature_test object to a data frame</p></a></li>
<li><a href='#binarize'><p>Binarize</p></a></li>
<li><a href='#calc_criterion'><p>Calculate value of criterion</p></a></li>
<li><a href='#calc_cs'><p>Calculate Chi-squared-based measure</p></a></li>
<li><a href='#calc_ed'><p>Calculate encoding distance</p></a></li>
<li><a href='#calc_ig'><p>Calculate IG for single feature</p></a></li>
<li><a href='#calc_kl'><p>Calculate KL divergence of features</p></a></li>
<li><a href='#calc_pi'><p>Calculate partition index</p></a></li>
<li><a href='#calc_si'><p>Compute similarity index</p></a></li>
<li><a href='#check_criterion'><p>Check chosen criterion</p></a></li>
<li><a href='#cluster_reg_exp'><p>Clustering of sequences based on regular expression</p></a></li>
<li><a href='#code_ngrams'><p>Code n-grams</p></a></li>
<li><a href='#construct_ngrams'><p>Construct and filter n-grams</p></a></li>
<li><a href='#count_multigrams'><p>Detect and count multiple n-grams in sequences</p></a></li>
<li><a href='#count_ngrams'><p>Count n-grams in sequences</p></a></li>
<li><a href='#count_specified'><p>Count specified n-grams</p></a></li>
<li><a href='#count_total'><p>Count total number of n-grams</p></a></li>
<li><a href='#create_encoding'><p>Create encoding</p></a></li>
<li><a href='#create_feature_target'><p>Create feature according to given contingency matrix</p></a></li>
<li><a href='#create_ngrams'><p>Get all possible n-Grams</p></a></li>
<li><a href='#criterion_distribution'><p>criterion_distribution class</p></a></li>
<li><a href='#cut.feature_test'><p>Categorize tested features</p></a></li>
<li><a href='#decode_ngrams'><p>Decode n-grams</p></a></li>
<li><a href='#degenerate'><p>Degenerate protein sequence</p></a></li>
<li><a href='#degenerate_ngrams'><p>Degenerate n-grams</p></a></li>
<li><a href='#distr_crit'><p>Compute criterion distribution</p></a></li>
<li><a href='#encoding2df'><p>Convert encoding to data frame</p></a></li>
<li><a href='#fast_crosstable'><p>2d cross-tabulation</p></a></li>
<li><a href='#feature_test'><p>feature_test class</p></a></li>
<li><a href='#full2simple'><p>Convert encoding from full to simple format</p></a></li>
<li><a href='#gap_ngrams'><p>Gap n-grams</p></a></li>
<li><a href='#generate_sequence'><p>Generate sequence</p></a></li>
<li><a href='#generate_single_region'><p>Generate single region</p></a></li>
<li><a href='#generate_single_unigram'><p>Generate single unigram</p></a></li>
<li><a href='#generate_unigrams'><p>Generate unigrams</p></a></li>
<li><a href='#get_ngrams_ind'><p>Get indices of n-grams</p></a></li>
<li><a href='#human_cleave'><p>Human signal peptides cleavage sites</p></a></li>
<li><a href='#is_ngram'><p>Validate n-gram</p></a></li>
<li><a href='#l2n'><p>Convert letters to numbers</p></a></li>
<li><a href='#list2matrix'><p>Convert list of sequences to matrix</p></a></li>
<li><a href='#n2l'><p>Convert numbers to letters</p></a></li>
<li><a href='#ngrams2df'><p>n-grams to data frame</p></a></li>
<li><a href='#plot.criterion_distribution'><p>Plot criterion distribution</p></a></li>
<li><a href='#position_ngrams'><p>Position n-grams</p></a></li>
<li><a href='#print.feature_test'><p>Print tested features</p></a></li>
<li><a href='#read_fasta'><p>Read FASTA files</p></a></li>
<li><a href='#regenerate'><p>Regenerate n-grams</p></a></li>
<li><a href='#regional_param'><p>regional_param class</p></a></li>
<li><a href='#seq2ngrams'><p>Extract n-grams from sequence</p></a></li>
<li><a href='#simple2full'><p>Convert encoding from simple to full format</p></a></li>
<li><a href='#summary.feature_test'><p>Summarize tested features</p></a></li>
<li><a href='#table_ngrams'><p>Tabulate n-grams</p></a></li>
<li><a href='#test_features'><p>Permutation test for feature selection</p></a></li>
<li><a href='#validate_encoding'><p>Validate encoding</p></a></li>
<li><a href='#write_encoding'><p>Write encodings to a file</p></a></li>
<li><a href='#write_fasta'><p>Write FASTA files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>N-Gram Analysis of Biological Sequences</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.3</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-03-31</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for extraction and analysis of various
    n-grams (k-mers) derived from biological sequences (proteins
    or nucleic acids). Contains QuiPT (quick permutation test) for fast
    feature-filtering of the n-gram data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/michbur/biogram">https://github.com/michbur/biogram</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/michbur/biogram/issues">https://github.com/michbur/biogram/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), slam</td>
</tr>
<tr>
<td>Imports:</td>
<td>combinat, entropy, partitions</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, knitr, testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-03-31 13:55:56 UTC; michal</td>
</tr>
<tr>
<td>Author:</td>
<td>Michal Burdukiewicz
    <a href="https://orcid.org/0000-0001-8926-582X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut],
  Piotr Sobczyk [aut],
  Chris Lauber [aut],
  Dominik Rafacz [aut],
  Katarzyna Sidorczuk
    <a href="https://orcid.org/0000-0001-6576-9054"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michal Burdukiewicz &lt;michalburdukiewicz@gmail.com&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-03-31 14:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='biogram-package'>biogram - analysis of biological sequences using n-grams</h2><span id='topic+biogram-package'></span><span id='topic+biogram'></span>

<h3>Description</h3>

<p><code>biogram</code> package is a toolbox for the analysis of
nucleic acid and protein sequences using n-grams. Possible applications include
motif discovery, feature selection, clustering, and classification.
</p>


<h3>n-grams</h3>

<p>n-grams (k-tuples) are sets of <code>n</code> characters derived from the input sequence(s).
They may form continuous sub-sequences or be discontinuous. For example, from the 
sequence of nucleotides <code>AATA</code> one can extract the following continuous 
2-grams (bigrams): <code>AA</code>, <code>AT</code> and <code>TA</code>. Moreover, there are two
possible bigrams separated by a single space: <code>A_T</code> and <code>A_A</code>, and one
bigram separated by two spaces: <code>A__A</code>.
</p>
<p>Another important n-gram parameter is its position. Instead of just counting n-grams,
one may want to count how many n-grams occur at a given position in multiple (e.g. related)
sequences. For example, in the sequences <code>AATA</code> and <code>AACA</code> there is only one
bigram at position 1: <code>AA</code>, but there are two bigrams at position two: <code>AT</code> and
<code>AC</code>. The following notation is used for position-specific n-grams: <code>1_AA</code>,
<code>2_AT</code>, <code>2_AC</code>.
</p>
<p>In the <code>biogram</code> package, the <code><a href="#topic+count_ngrams">count_ngrams</a></code> function is used for
counting and extracting n-grams. Using the <code>d</code> argument the user can specify the
distance between elements of the n-grams. The <code>pos</code> argument can be used to enable
position specificity.
</p>


<h3>n-gram data dimensionality</h3>

<p>We note that n-grams suffer from the curse of dimensionality. For example, for a peptide
of length 6 <code class="reqn">20^{n}</code> n-grams and <code class="reqn">6 \times 20^{n}</code> positioned n-grams are possible.
Data sets of such an enormous size are hard to manage and analyze in R.
</p>
<p>The <code>biogram</code> package deals with both of the abovementioned problems. It uses 
innate properties of the n-gram data which usually can be represented by sparse
matrices. Data storage is done using functionalities from the <code>slam</code> package. To ease 
the selection of significant features, <code>biogram</code> provides the user with QuiPT, 
a very fast permutation test for binary data (see <code><a href="#topic+test_features">test_features</a></code>).
</p>
<p>Another way of reducing dimensionality is the aggregation of sequence residues into more 
general groups. For example, all positively-charged amino acids may be aggregated into
one group. This action can be performed using the <code><a href="#topic+degenerate">degenerate</a></code> function.
</p>
<p>Encoding of amino acids can easu sequence analysis, but multidimensional 
objects as the aggregations of amino acids are not easily comparable. We introduced the 
encoding distance, a measure defining the distance between encodings. It can be computed 
using the <code><a href="#topic+calc_ed">calc_ed</a></code> function.
</p>


<h3>Author(s)</h3>

<p>Michal Burdukiewicz, Piotr Sobczyk, Chris Lauber
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use data set from package
data(human_cleave)
# first nine columns represent subsequent nine amino acids from cleavage sites
# degenerate the sequence to reduce the dimensionality of the problem
# (use five groups instead of 20 amino acids)
deg_seqs &lt;- degenerate(human_cleave[, 1L:9], 
                      list(`a` = c(1, 6, 8, 10, 11, 18), 
                           `b` = c(2, 13, 14, 16, 17), 
                           `c` = c(5, 19, 20), 
                           `d` = c(7, 9, 12, 15), 
                           'e' = c(3, 4)))
# EXAMPLE 1 - extract significant trigrams
# extract trigrams
trigrams &lt;- count_ngrams(deg_seqs, 3, letters[1L:5], pos = TRUE)
# select features that differ between the two target groups using QuiPT
test1 &lt;- test_features(human_cleave[, "tar"], trigrams)
# see a summary of the results
summary(test1)
# aggregate features in groups based on their p-value
gr &lt;- cut(test1)
# get position map of the most significant n-grams
position_ngrams(gr[[1]])
# transform the most significant n-grams to more readable form
decode_ngrams(gr[[1]])

# EXAMPLE 2 - search for specific n-grams
# the n-grams of the interest are a_a (a-gap-a) and e_e (e-gap-e) on the
# 3rd and 4th position
# firstly code n-grams in biogram notation and add position information
coded &lt;- code_ngrams(c("a_a", "c_c"))
# add position information
coded &lt;- c(paste0("3_", coded), paste0("4_", coded))
# count only the features of the interest
bigrams &lt;- count_specified(deg_seqs, coded)
# test which of the features of the interest is significant
test2 &lt;- test_features(human_cleave[, "tar"], bigrams)
cut(test2)
</code></pre>

<hr>
<h2 id='aaprop'>Normalized amino acids properties</h2><span id='topic+aaprop'></span>

<h3>Description</h3>

<p>Normalized (0-1) 554 amino acid properties as retreived from AAIndex database 
(release 9.1) enriched with contactivity of amino acids.
</p>


<h3>Format</h3>

<p>A data frames with 20 columns and 600 rows.
</p>


<h3>Details</h3>

<p>Following properties are included (AAIndex key: description of the property)
</p>
 
<dl>
<dt>ANDN920101</dt><dd><p>alpha-CH chemical shifts (Andersen et al., 1992)</p>
</dd>
<dt>ARGP820101</dt><dd><p>Hydrophobicity index (Argos et al., 1982)</p>
</dd>
<dt>ARGP820102</dt><dd><p>Signal sequence helical potential (Argos et al., 1982)</p>
</dd>
<dt>ARGP820103</dt><dd><p>Membrane-buried preference parameters (Argos et al., 1982)</p>
</dd>
<dt>BEGF750101</dt><dd><p>Conformational parameter of inner helix (Beghin-Dirkx, 1975)</p>
</dd>
<dt>BEGF750102</dt><dd><p>Conformational parameter of beta-structure (Beghin-Dirkx,
1975)</p>
</dd>
<dt>BEGF750103</dt><dd><p>Conformational parameter of beta-turn (Beghin-Dirkx, 1975)</p>
</dd>
<dt>BHAR880101</dt><dd><p>Average flexibility indices (Bhaskaran-Ponnuswamy, 1988)</p>
</dd>
<dt>BIGC670101</dt><dd><p>Residue volume (Bigelow, 1967)</p>
</dd>
<dt>BIOV880101</dt><dd><p>Information value for accessibility; average fraction 35%
(Biou et al., 1988)</p>
</dd>
<dt>BIOV880102</dt><dd><p>Information value for accessibility; average fraction 23%
(Biou et al., 1988)</p>
</dd>
<dt>BROC820101</dt><dd><p>Retention coefficient in TFA (Browne et al., 1982)</p>
</dd>
<dt>BROC820102</dt><dd><p>Retention coefficient in HFBA (Browne et al., 1982)</p>
</dd>
<dt>BULH740101</dt><dd><p>Transfer free energy to surface (Bull-Breese, 1974)</p>
</dd>
<dt>BULH740102</dt><dd><p>Apparent partial specific volume (Bull-Breese, 1974)</p>
</dd>
<dt>BUNA790101</dt><dd><p>alpha-NH chemical shifts (Bundi-Wuthrich, 1979)</p>
</dd>
<dt>BUNA790102</dt><dd><p>alpha-CH chemical shifts (Bundi-Wuthrich, 1979)</p>
</dd>
<dt>BUNA790103</dt><dd><p>Spin-spin coupling constants 3JHalpha-NH (Bundi-Wuthrich,
1979)</p>
</dd>
<dt>BURA740101</dt><dd><p>Normalized frequency of alpha-helix (Burgess et al., 1974)</p>
</dd>
<dt>BURA740102</dt><dd><p>Normalized frequency of extended structure (Burgess et al.,
1974)</p>
</dd>
<dt>CHAM810101</dt><dd><p>Steric parameter (Charton, 1981)</p>
</dd>
<dt>CHAM820101</dt><dd><p>Polarizability parameter (Charton-Charton, 1982)</p>
</dd>
<dt>CHAM820102</dt><dd><p>Free energy of solution in water, kcal/mole (Charton-Charton,
1982)</p>
</dd>
<dt>CHAM830101</dt><dd><p>The Chou-Fasman parameter of the coil conformation
(Charton-Charton, 1983)</p>
</dd>
<dt>CHAM830102</dt><dd><p>A parameter defined from the residuals obtained from the best
correlation of the Chou-Fasman parameter of beta-sheet (Charton-Charton, 1983)</p>
</dd>
<dt>CHAM830103</dt><dd><p>The number of atoms in the side chain labelled 1+1
(Charton-Charton, 1983)</p>
</dd>
<dt>CHAM830104</dt><dd><p>The number of atoms in the side chain labelled 2+1
(Charton-Charton, 1983)</p>
</dd>
<dt>CHAM830105</dt><dd><p>The number of atoms in the side chain labelled 3+1
(Charton-Charton, 1983)</p>
</dd>
<dt>CHAM830106</dt><dd><p>The number of bonds in the longest chain (Charton-Charton,
1983)</p>
</dd>
<dt>CHAM830107</dt><dd><p>A parameter of charge transfer capability (Charton-Charton,
1983)</p>
</dd>
<dt>CHAM830108</dt><dd><p>A parameter of charge transfer donor capability
(Charton-Charton, 1983)</p>
</dd>
<dt>CHOC750101</dt><dd><p>Average volume of buried residue (Chothia, 1975)</p>
</dd>
<dt>CHOC760101</dt><dd><p>Residue accessible surface area in tripeptide (Chothia,
1976)</p>
</dd>
<dt>CHOC760102</dt><dd><p>Residue accessible surface area in folded protein (Chothia,
1976)</p>
</dd>
<dt>CHOC760103</dt><dd><p>Proportion of residues 95% buried (Chothia, 1976)</p>
</dd>
<dt>CHOC760104</dt><dd><p>Proportion of residues 100% buried (Chothia, 1976)</p>
</dd>
<dt>CHOP780101</dt><dd><p>Normalized frequency of beta-turn (Chou-Fasman, 1978a)</p>
</dd>
<dt>CHOP780201</dt><dd><p>Normalized frequency of alpha-helix (Chou-Fasman, 1978b)</p>
</dd>
<dt>CHOP780202</dt><dd><p>Normalized frequency of beta-sheet (Chou-Fasman, 1978b)</p>
</dd>
<dt>CHOP780203</dt><dd><p>Normalized frequency of beta-turn (Chou-Fasman, 1978b)</p>
</dd>
<dt>CHOP780204</dt><dd><p>Normalized frequency of N-terminal helix (Chou-Fasman,
1978b)</p>
</dd>
<dt>CHOP780205</dt><dd><p>Normalized frequency of C-terminal helix (Chou-Fasman,
1978b)</p>
</dd>
<dt>CHOP780206</dt><dd><p>Normalized frequency of N-terminal non helical region
(Chou-Fasman, 1978b)</p>
</dd>
<dt>CHOP780207</dt><dd><p>Normalized frequency of C-terminal non helical region
(Chou-Fasman, 1978b)</p>
</dd>
<dt>CHOP780208</dt><dd><p>Normalized frequency of N-terminal beta-sheet (Chou-Fasman,
1978b)</p>
</dd>
<dt>CHOP780209</dt><dd><p>Normalized frequency of C-terminal beta-sheet (Chou-Fasman,
1978b)</p>
</dd>
<dt>CHOP780210</dt><dd><p>Normalized frequency of N-terminal non beta region
(Chou-Fasman, 1978b)</p>
</dd>
<dt>CHOP780211</dt><dd><p>Normalized frequency of C-terminal non beta region
(Chou-Fasman, 1978b)</p>
</dd>
<dt>CHOP780212</dt><dd><p>Frequency of the 1st residue in turn (Chou-Fasman, 1978b)</p>
</dd>
<dt>CHOP780213</dt><dd><p>Frequency of the 2nd residue in turn (Chou-Fasman, 1978b)</p>
</dd>
<dt>CHOP780214</dt><dd><p>Frequency of the 3rd residue in turn (Chou-Fasman, 1978b)</p>
</dd>
<dt>CHOP780215</dt><dd><p>Frequency of the 4th residue in turn (Chou-Fasman, 1978b)</p>
</dd>
<dt>CHOP780216</dt><dd><p>Normalized frequency of the 2nd and 3rd residues in turn
(Chou-Fasman, 1978b)</p>
</dd>
<dt>CIDH920101</dt><dd><p>Normalized hydrophobicity scales for alpha-proteins (Cid et
al., 1992)</p>
</dd>
<dt>CIDH920102</dt><dd><p>Normalized hydrophobicity scales for beta-proteins (Cid et
al., 1992)</p>
</dd>
<dt>CIDH920103</dt><dd><p>Normalized hydrophobicity scales for alpha+beta-proteins (Cid
et al., 1992)</p>
</dd>
<dt>CIDH920104</dt><dd><p>Normalized hydrophobicity scales for alpha/beta-proteins (Cid
et al., 1992)</p>
</dd>
<dt>CIDH920105</dt><dd><p>Normalized average hydrophobicity scales (Cid et al., 1992)</p>
</dd>
<dt>COHE430101</dt><dd><p>Partial specific volume (Cohn-Edsall, 1943)</p>
</dd>
<dt>CRAJ730101</dt><dd><p>Normalized frequency of middle helix (Crawford et al., 1973)</p>
</dd>
<dt>CRAJ730102</dt><dd><p>Normalized frequency of beta-sheet (Crawford et al., 1973)</p>
</dd>
<dt>CRAJ730103</dt><dd><p>Normalized frequency of turn (Crawford et al., 1973)</p>
</dd>
<dt>DAWD720101</dt><dd><p>Size (Dawson, 1972)</p>
</dd>
<dt>DAYM780101</dt><dd><p>Amino acid composition (Dayhoff et al., 1978a)</p>
</dd>
<dt>DAYM780201</dt><dd><p>Relative mutability (Dayhoff et al., 1978b)</p>
</dd>
<dt>DESM900101</dt><dd><p>Membrane preference for cytochrome b: MPH89 (Degli Esposti et
al., 1990)</p>
</dd>
<dt>DESM900102</dt><dd><p>Average membrane preference: AMP07 (Degli Esposti et al.,
1990)</p>
</dd>
<dt>EISD840101</dt><dd><p>Consensus normalized hydrophobicity scale (Eisenberg, 1984)</p>
</dd>
<dt>EISD860101</dt><dd><p>Solvation free energy (Eisenberg-McLachlan, 1986)</p>
</dd>
<dt>EISD860102</dt><dd><p>Atom-based hydrophobic moment (Eisenberg-McLachlan, 1986)</p>
</dd>
<dt>EISD860103</dt><dd><p>Direction of hydrophobic moment (Eisenberg-McLachlan, 1986)</p>
</dd>
<dt>FASG760101</dt><dd><p>Molecular weight (Fasman, 1976)</p>
</dd>
<dt>FASG760102</dt><dd><p>Melting point (Fasman, 1976)</p>
</dd>
<dt>FASG760103</dt><dd><p>Optical rotation (Fasman, 1976)</p>
</dd>
<dt>FASG760104</dt><dd><p>pK-N (Fasman, 1976)</p>
</dd>
<dt>FASG760105</dt><dd><p>pK-C (Fasman, 1976)</p>
</dd>
<dt>FAUJ830101</dt><dd><p>Hydrophobic parameter pi (Fauchere-Pliska, 1983)</p>
</dd>
<dt>FAUJ880101</dt><dd><p>Graph shape index (Fauchere et al., 1988)</p>
</dd>
<dt>FAUJ880102</dt><dd><p>Smoothed upsilon steric parameter (Fauchere et al., 1988)</p>
</dd>
<dt>FAUJ880103</dt><dd><p>Normalized van der Waals volume (Fauchere et al., 1988)</p>
</dd>
<dt>FAUJ880104</dt><dd><p>STERIMOL length of the side chain (Fauchere et al., 1988)</p>
</dd>
<dt>FAUJ880105</dt><dd><p>STERIMOL minimum width of the side chain (Fauchere et al.,
1988)</p>
</dd>
<dt>FAUJ880106</dt><dd><p>STERIMOL maximum width of the side chain (Fauchere et al.,
1988)</p>
</dd>
<dt>FAUJ880107</dt><dd><p>N.m.r. chemical shift of alpha-carbon (Fauchere et al.,
1988)</p>
</dd>
<dt>FAUJ880108</dt><dd><p>Localized electrical effect (Fauchere et al., 1988)</p>
</dd>
<dt>FAUJ880109</dt><dd><p>Number of hydrogen bond donors (Fauchere et al., 1988)</p>
</dd>
<dt>FAUJ880110</dt><dd><p>Number of full nonbonding orbitals (Fauchere et al., 1988)</p>
</dd>
<dt>FAUJ880111</dt><dd><p>Positive charge (Fauchere et al., 1988)</p>
</dd>
<dt>FAUJ880112</dt><dd><p>Negative charge (Fauchere et al., 1988)</p>
</dd>
<dt>FAUJ880113</dt><dd><p>pK-a(RCOOH) (Fauchere et al., 1988)</p>
</dd>
<dt>FINA770101</dt><dd><p>Helix-coil equilibrium constant (Finkelstein-Ptitsyn, 1977)</p>
</dd>
<dt>FINA910101</dt><dd><p>Helix initiation parameter at posision i-1 (Finkelstein et
al., 1991)</p>
</dd>
<dt>FINA910102</dt><dd><p>Helix initiation parameter at posision i,i+1,i+2 (Finkelstein
et al., 1991)</p>
</dd>
<dt>FINA910103</dt><dd><p>Helix termination parameter at posision j-2,j-1,j
(Finkelstein et al., 1991)</p>
</dd>
<dt>FINA910104</dt><dd><p>Helix termination parameter at posision j+1 (Finkelstein et
al., 1991)</p>
</dd>
<dt>GARJ730101</dt><dd><p>Partition coefficient (Garel et al., 1973)</p>
</dd>
<dt>GEIM800101</dt><dd><p>Alpha-helix indices (Geisow-Roberts, 1980)</p>
</dd>
<dt>GEIM800102</dt><dd><p>Alpha-helix indices for alpha-proteins (Geisow-Roberts,
1980)</p>
</dd>
<dt>GEIM800103</dt><dd><p>Alpha-helix indices for beta-proteins (Geisow-Roberts, 1980)</p>
</dd>
<dt>GEIM800104</dt><dd><p>Alpha-helix indices for alpha/beta-proteins (Geisow-Roberts,
1980)</p>
</dd>
<dt>GEIM800105</dt><dd><p>Beta-strand indices (Geisow-Roberts, 1980)</p>
</dd>
<dt>GEIM800106</dt><dd><p>Beta-strand indices for beta-proteins (Geisow-Roberts, 1980)</p>
</dd>
<dt>GEIM800107</dt><dd><p>Beta-strand indices for alpha/beta-proteins (Geisow-Roberts,
1980)</p>
</dd>
<dt>GEIM800108</dt><dd><p>Aperiodic indices (Geisow-Roberts, 1980)</p>
</dd>
<dt>GEIM800109</dt><dd><p>Aperiodic indices for alpha-proteins (Geisow-Roberts, 1980)</p>
</dd>
<dt>GEIM800110</dt><dd><p>Aperiodic indices for beta-proteins (Geisow-Roberts, 1980)</p>
</dd>
<dt>GEIM800111</dt><dd><p>Aperiodic indices for alpha/beta-proteins (Geisow-Roberts,
1980)</p>
</dd>
<dt>GOLD730101</dt><dd><p>Hydrophobicity factor (Goldsack-Chalifoux, 1973)</p>
</dd>
<dt>GOLD730102</dt><dd><p>Residue volume (Goldsack-Chalifoux, 1973)</p>
</dd>
<dt>GRAR740101</dt><dd><p>Composition (Grantham, 1974)</p>
</dd>
<dt>GRAR740102</dt><dd><p>Polarity (Grantham, 1974)</p>
</dd>
<dt>GRAR740103</dt><dd><p>Volume (Grantham, 1974)</p>
</dd>
<dt>GUYH850101</dt><dd><p>Partition energy (Guy, 1985)</p>
</dd>
<dt>HOPA770101</dt><dd><p>Hydration number (Hopfinger, 1971), Cited by Charton-Charton
(1982)</p>
</dd>
<dt>HOPT810101</dt><dd><p>Hydrophilicity value (Hopp-Woods, 1981)</p>
</dd>
<dt>HUTJ700101</dt><dd><p>Heat capacity (Hutchens, 1970)</p>
</dd>
<dt>HUTJ700102</dt><dd><p>Absolute entropy (Hutchens, 1970)</p>
</dd>
<dt>HUTJ700103</dt><dd><p>Entropy of formation (Hutchens, 1970)</p>
</dd>
<dt>ISOY800101</dt><dd><p>Normalized relative frequency of alpha-helix (Isogai et al.,
1980)</p>
</dd>
<dt>ISOY800102</dt><dd><p>Normalized relative frequency of extended structure (Isogai
et al., 1980)</p>
</dd>
<dt>ISOY800103</dt><dd><p>Normalized relative frequency of bend (Isogai et al., 1980)</p>
</dd>
<dt>ISOY800104</dt><dd><p>Normalized relative frequency of bend R (Isogai et al.,
1980)</p>
</dd>
<dt>ISOY800105</dt><dd><p>Normalized relative frequency of bend S (Isogai et al.,
1980)</p>
</dd>
<dt>ISOY800106</dt><dd><p>Normalized relative frequency of helix end (Isogai et al.,
1980)</p>
</dd>
<dt>ISOY800107</dt><dd><p>Normalized relative frequency of double bend (Isogai et al.,
1980)</p>
</dd>
<dt>ISOY800108</dt><dd><p>Normalized relative frequency of coil (Isogai et al., 1980)</p>
</dd>
<dt>JANJ780101</dt><dd><p>Average accessible surface area (Janin et al., 1978)</p>
</dd>
<dt>JANJ780102</dt><dd><p>Percentage of buried residues (Janin et al., 1978)</p>
</dd>
<dt>JANJ780103</dt><dd><p>Percentage of exposed residues (Janin et al., 1978)</p>
</dd>
<dt>JANJ790101</dt><dd><p>Ratio of buried and accessible molar fractions (Janin, 1979)</p>
</dd>
<dt>JANJ790102</dt><dd><p>Transfer free energy (Janin, 1979)</p>
</dd>
<dt>JOND750101</dt><dd><p>Hydrophobicity (Jones, 1975)</p>
</dd>
<dt>JOND750102</dt><dd><p>pK (-COOH) (Jones, 1975)</p>
</dd>
<dt>JOND920101</dt><dd><p>Relative frequency of occurrence (Jones et al., 1992)</p>
</dd>
<dt>JOND920102</dt><dd><p>Relative mutability (Jones et al., 1992)</p>
</dd>
<dt>JUKT750101</dt><dd><p>Amino acid distribution (Jukes et al., 1975)</p>
</dd>
<dt>JUNJ780101</dt><dd><p>Sequence frequency (Jungck, 1978)</p>
</dd>
<dt>KANM800101</dt><dd><p>Average relative probability of helix (Kanehisa-Tsong, 1980)</p>
</dd>
<dt>KANM800102</dt><dd><p>Average relative probability of beta-sheet (Kanehisa-Tsong,
1980)</p>
</dd>
<dt>KANM800103</dt><dd><p>Average relative probability of inner helix (Kanehisa-Tsong,
1980)</p>
</dd>
<dt>KANM800104</dt><dd><p>Average relative probability of inner beta-sheet
(Kanehisa-Tsong, 1980)</p>
</dd>
<dt>KARP850101</dt><dd><p>Flexibility parameter for no rigid neighbors (Karplus-Schulz,
1985)</p>
</dd>
<dt>KARP850102</dt><dd><p>Flexibility parameter for one rigid neighbor (Karplus-Schulz,
1985)</p>
</dd>
<dt>KARP850103</dt><dd><p>Flexibility parameter for two rigid neighbors
(Karplus-Schulz, 1985)</p>
</dd>
<dt>KHAG800101</dt><dd><p>The Kerr-constant increments (Khanarian-Moore, 1980)</p>
</dd>
<dt>KLEP840101</dt><dd><p>Net charge (Klein et al., 1984)</p>
</dd>
<dt>KRIW710101</dt><dd><p>Side chain interaction parameter (Krigbaum-Rubin, 1971)</p>
</dd>
<dt>KRIW790101</dt><dd><p>Side chain interaction parameter (Krigbaum-Komoriya, 1979)</p>
</dd>
<dt>KRIW790102</dt><dd><p>Fraction of site occupied by water (Krigbaum-Komoriya, 1979)</p>
</dd>
<dt>KRIW790103</dt><dd><p>Side chain volume (Krigbaum-Komoriya, 1979)</p>
</dd>
<dt>KYTJ820101</dt><dd><p>Hydropathy index (Kyte-Doolittle, 1982)</p>
</dd>
<dt>LAWE840101</dt><dd><p>Transfer free energy, CHP/water (Lawson et al., 1984)</p>
</dd>
<dt>LEVM760101</dt><dd><p>Hydrophobic parameter (Levitt, 1976)</p>
</dd>
<dt>LEVM760102</dt><dd><p>Distance between C-alpha and centroid of side chain (Levitt,
1976)</p>
</dd>
<dt>LEVM760103</dt><dd><p>Side chain angle theta(AAR) (Levitt, 1976)</p>
</dd>
<dt>LEVM760104</dt><dd><p>Side chain torsion angle phi(AAAR) (Levitt, 1976)</p>
</dd>
<dt>LEVM760105</dt><dd><p>Radius of gyration of side chain (Levitt, 1976)</p>
</dd>
<dt>LEVM760106</dt><dd><p>van der Waals parameter R0 (Levitt, 1976)</p>
</dd>
<dt>LEVM760107</dt><dd><p>van der Waals parameter epsilon (Levitt, 1976)</p>
</dd>
<dt>LEVM780101</dt><dd><p>Normalized frequency of alpha-helix, with weights (Levitt,
1978)</p>
</dd>
<dt>LEVM780102</dt><dd><p>Normalized frequency of beta-sheet, with weights (Levitt,
1978)</p>
</dd>
<dt>LEVM780103</dt><dd><p>Normalized frequency of reverse turn, with weights (Levitt,
1978)</p>
</dd>
<dt>LEVM780104</dt><dd><p>Normalized frequency of alpha-helix, unweighted (Levitt,
1978)</p>
</dd>
<dt>LEVM780105</dt><dd><p>Normalized frequency of beta-sheet, unweighted (Levitt,
1978)</p>
</dd>
<dt>LEVM780106</dt><dd><p>Normalized frequency of reverse turn, unweighted (Levitt,
1978)</p>
</dd>
<dt>LEWP710101</dt><dd><p>Frequency of occurrence in beta-bends (Lewis et al., 1971)</p>
</dd>
<dt>LIFS790101</dt><dd><p>Conformational preference for all beta-strands
(Lifson-Sander, 1979)</p>
</dd>
<dt>LIFS790102</dt><dd><p>Conformational preference for parallel beta-strands
(Lifson-Sander, 1979)</p>
</dd>
<dt>LIFS790103</dt><dd><p>Conformational preference for antiparallel beta-strands
(Lifson-Sander, 1979)</p>
</dd>
<dt>MANP780101</dt><dd><p>Average surrounding hydrophobicity (Manavalan-Ponnuswamy,
1978)</p>
</dd>
<dt>MAXF760101</dt><dd><p>Normalized frequency of alpha-helix (Maxfield-Scheraga,
1976)</p>
</dd>
<dt>MAXF760102</dt><dd><p>Normalized frequency of extended structure
(Maxfield-Scheraga, 1976)</p>
</dd>
<dt>MAXF760103</dt><dd><p>Normalized frequency of zeta R (Maxfield-Scheraga, 1976)</p>
</dd>
<dt>MAXF760104</dt><dd><p>Normalized frequency of left-handed alpha-helix
(Maxfield-Scheraga, 1976)</p>
</dd>
<dt>MAXF760105</dt><dd><p>Normalized frequency of zeta L (Maxfield-Scheraga, 1976)</p>
</dd>
<dt>MAXF760106</dt><dd><p>Normalized frequency of alpha region (Maxfield-Scheraga,
1976)</p>
</dd>
<dt>MCMT640101</dt><dd><p>Refractivity (McMeekin et al., 1964), Cited by Jones (1975)</p>
</dd>
<dt>MEEJ800101</dt><dd><p>Retention coefficient in HPLC, pH7.4 (Meek, 1980)</p>
</dd>
<dt>MEEJ800102</dt><dd><p>Retention coefficient in HPLC, pH2.1 (Meek, 1980)</p>
</dd>
<dt>MEEJ810101</dt><dd><p>Retention coefficient in NaClO4 (Meek-Rossetti, 1981)</p>
</dd>
<dt>MEEJ810102</dt><dd><p>Retention coefficient in NaH2PO4 (Meek-Rossetti, 1981)</p>
</dd>
<dt>MEIH800101</dt><dd><p>Average reduced distance for C-alpha (Meirovitch et al.,
1980)</p>
</dd>
<dt>MEIH800102</dt><dd><p>Average reduced distance for side chain (Meirovitch et al.,
1980)</p>
</dd>
<dt>MEIH800103</dt><dd><p>Average side chain orientation angle (Meirovitch et al.,
1980)</p>
</dd>
<dt>MIYS850101</dt><dd><p>Effective partition energy (Miyazawa-Jernigan, 1985)</p>
</dd>
<dt>NAGK730101</dt><dd><p>Normalized frequency of alpha-helix (Nagano, 1973)</p>
</dd>
<dt>NAGK730102</dt><dd><p>Normalized frequency of bata-structure (Nagano, 1973)</p>
</dd>
<dt>NAGK730103</dt><dd><p>Normalized frequency of coil (Nagano, 1973)</p>
</dd>
<dt>NAKH900101</dt><dd><p>AA composition of total proteins (Nakashima et al., 1990)</p>
</dd>
<dt>NAKH900102</dt><dd><p>SD of AA composition of total proteins (Nakashima et al.,
1990)</p>
</dd>
<dt>NAKH900103</dt><dd><p>AA composition of mt-proteins (Nakashima et al., 1990)</p>
</dd>
<dt>NAKH900104</dt><dd><p>Normalized composition of mt-proteins (Nakashima et al.,
1990)</p>
</dd>
<dt>NAKH900105</dt><dd><p>AA composition of mt-proteins from animal (Nakashima et al.,
1990)</p>
</dd>
<dt>NAKH900106</dt><dd><p>Normalized composition from animal (Nakashima et al., 1990)</p>
</dd>
<dt>NAKH900107</dt><dd><p>AA composition of mt-proteins from fungi and plant (Nakashima
et al., 1990)</p>
</dd>
<dt>NAKH900108</dt><dd><p>Normalized composition from fungi and plant (Nakashima et
al., 1990)</p>
</dd>
<dt>NAKH900109</dt><dd><p>AA composition of membrane proteins (Nakashima et al., 1990)</p>
</dd>
<dt>NAKH900110</dt><dd><p>Normalized composition of membrane proteins (Nakashima et
al., 1990)</p>
</dd>
<dt>NAKH900111</dt><dd><p>Transmembrane regions of non-mt-proteins (Nakashima et al.,
1990)</p>
</dd>
<dt>NAKH900112</dt><dd><p>Transmembrane regions of mt-proteins (Nakashima et al.,
1990)</p>
</dd>
<dt>NAKH900113</dt><dd><p>Ratio of average and computed composition (Nakashima et al.,
1990)</p>
</dd>
<dt>NAKH920101</dt><dd><p>AA composition of CYT of single-spanning proteins
(Nakashima-Nishikawa, 1992)</p>
</dd>
<dt>NAKH920102</dt><dd><p>AA composition of CYT2 of single-spanning proteins
(Nakashima-Nishikawa, 1992)</p>
</dd>
<dt>NAKH920103</dt><dd><p>AA composition of EXT of single-spanning proteins
(Nakashima-Nishikawa, 1992)</p>
</dd>
<dt>NAKH920104</dt><dd><p>AA composition of EXT2 of single-spanning proteins
(Nakashima-Nishikawa, 1992)</p>
</dd>
<dt>NAKH920105</dt><dd><p>AA composition of MEM of single-spanning proteins
(Nakashima-Nishikawa, 1992)</p>
</dd>
<dt>NAKH920106</dt><dd><p>AA composition of CYT of multi-spanning proteins
(Nakashima-Nishikawa, 1992)</p>
</dd>
<dt>NAKH920107</dt><dd><p>AA composition of EXT of multi-spanning proteins
(Nakashima-Nishikawa, 1992)</p>
</dd>
<dt>NAKH920108</dt><dd><p>AA composition of MEM of multi-spanning proteins
(Nakashima-Nishikawa, 1992)</p>
</dd>
<dt>NISK800101</dt><dd><p>8 A contact number (Nishikawa-Ooi, 1980)</p>
</dd>
<dt>NISK860101</dt><dd><p>14 A contact number (Nishikawa-Ooi, 1986)</p>
</dd>
<dt>NOZY710101</dt><dd><p>Transfer energy, organic solvent/water (Nozaki-Tanford,
1971)</p>
</dd>
<dt>OOBM770101</dt><dd><p>Average non-bonded energy per atom (Oobatake-Ooi, 1977)</p>
</dd>
<dt>OOBM770102</dt><dd><p>Short and medium range non-bonded energy per atom
(Oobatake-Ooi, 1977)</p>
</dd>
<dt>OOBM770103</dt><dd><p>Long range non-bonded energy per atom (Oobatake-Ooi, 1977)</p>
</dd>
<dt>OOBM770104</dt><dd><p>Average non-bonded energy per residue (Oobatake-Ooi, 1977)</p>
</dd>
<dt>OOBM770105</dt><dd><p>Short and medium range non-bonded energy per residue
(Oobatake-Ooi, 1977)</p>
</dd>
<dt>OOBM850101</dt><dd><p>Optimized beta-structure-coil equilibrium constant (Oobatake
et al., 1985)</p>
</dd>
<dt>OOBM850102</dt><dd><p>Optimized propensity to form reverse turn (Oobatake et al.,
1985)</p>
</dd>
<dt>OOBM850103</dt><dd><p>Optimized transfer energy parameter (Oobatake et al., 1985)</p>
</dd>
<dt>OOBM850104</dt><dd><p>Optimized average non-bonded energy per atom (Oobatake et
al., 1985)</p>
</dd>
<dt>OOBM850105</dt><dd><p>Optimized side chain interaction parameter (Oobatake et al.,
1985)</p>
</dd>
<dt>PALJ810101</dt><dd><p>Normalized frequency of alpha-helix from LG (Palau et al.,
1981)</p>
</dd>
<dt>PALJ810102</dt><dd><p>Normalized frequency of alpha-helix from CF (Palau et al.,
1981)</p>
</dd>
<dt>PALJ810103</dt><dd><p>Normalized frequency of beta-sheet from LG (Palau et al.,
1981)</p>
</dd>
<dt>PALJ810104</dt><dd><p>Normalized frequency of beta-sheet from CF (Palau et al.,
1981)</p>
</dd>
<dt>PALJ810105</dt><dd><p>Normalized frequency of turn from LG (Palau et al., 1981)</p>
</dd>
<dt>PALJ810106</dt><dd><p>Normalized frequency of turn from CF (Palau et al., 1981)</p>
</dd>
<dt>PALJ810107</dt><dd><p>Normalized frequency of alpha-helix in all-alpha class (Palau
et al., 1981)</p>
</dd>
<dt>PALJ810108</dt><dd><p>Normalized frequency of alpha-helix in alpha+beta class
(Palau et al., 1981)</p>
</dd>
<dt>PALJ810109</dt><dd><p>Normalized frequency of alpha-helix in alpha/beta class
(Palau et al., 1981)</p>
</dd>
<dt>PALJ810110</dt><dd><p>Normalized frequency of beta-sheet in all-beta class (Palau
et al., 1981)</p>
</dd>
<dt>PALJ810111</dt><dd><p>Normalized frequency of beta-sheet in alpha+beta class (Palau
et al., 1981)</p>
</dd>
<dt>PALJ810112</dt><dd><p>Normalized frequency of beta-sheet in alpha/beta class (Palau
et al., 1981)</p>
</dd>
<dt>PALJ810113</dt><dd><p>Normalized frequency of turn in all-alpha class (Palau et
al., 1981)</p>
</dd>
<dt>PALJ810114</dt><dd><p>Normalized frequency of turn in all-beta class (Palau et al.,
1981)</p>
</dd>
<dt>PALJ810115</dt><dd><p>Normalized frequency of turn in alpha+beta class (Palau et
al., 1981)</p>
</dd>
<dt>PALJ810116</dt><dd><p>Normalized frequency of turn in alpha/beta class (Palau et
al., 1981)</p>
</dd>
<dt>PARJ860101</dt><dd><p>HPLC parameter (Parker et al., 1986)</p>
</dd>
<dt>PLIV810101</dt><dd><p>Partition coefficient (Pliska et al., 1981)</p>
</dd>
<dt>PONP800101</dt><dd><p>Surrounding hydrophobicity in folded form (Ponnuswamy et al.,
1980)</p>
</dd>
<dt>PONP800102</dt><dd><p>Average gain in surrounding hydrophobicity (Ponnuswamy et
al., 1980)</p>
</dd>
<dt>PONP800103</dt><dd><p>Average gain ratio in surrounding hydrophobicity (Ponnuswamy
et al., 1980)</p>
</dd>
<dt>PONP800104</dt><dd><p>Surrounding hydrophobicity in alpha-helix (Ponnuswamy et al.,
1980)</p>
</dd>
<dt>PONP800105</dt><dd><p>Surrounding hydrophobicity in beta-sheet (Ponnuswamy et al.,
1980)</p>
</dd>
<dt>PONP800106</dt><dd><p>Surrounding hydrophobicity in turn (Ponnuswamy et al., 1980)</p>
</dd>
<dt>PONP800107</dt><dd><p>Accessibility reduction ratio (Ponnuswamy et al., 1980)</p>
</dd>
<dt>PONP800108</dt><dd><p>Average number of surrounding residues (Ponnuswamy et al.,
1980)</p>
</dd>
<dt>PRAM820101</dt><dd><p>Intercept in regression analysis (Prabhakaran-Ponnuswamy,
1982)</p>
</dd>
<dt>PRAM820102</dt><dd><p>Slope in regression analysis x 1.0E1 (Prabhakaran-Ponnuswamy,
1982)</p>
</dd>
<dt>PRAM820103</dt><dd><p>Correlation coefficient in regression analysis
(Prabhakaran-Ponnuswamy, 1982)</p>
</dd>
<dt>PRAM900101</dt><dd><p>Hydrophobicity (Prabhakaran, 1990)</p>
</dd>
<dt>PRAM900102</dt><dd><p>Relative frequency in alpha-helix (Prabhakaran, 1990)</p>
</dd>
<dt>PRAM900103</dt><dd><p>Relative frequency in beta-sheet (Prabhakaran, 1990)</p>
</dd>
<dt>PRAM900104</dt><dd><p>Relative frequency in reverse-turn (Prabhakaran, 1990)</p>
</dd>
<dt>PTIO830101</dt><dd><p>Helix-coil equilibrium constant (Ptitsyn-Finkelstein, 1983)</p>
</dd>
<dt>PTIO830102</dt><dd><p>Beta-coil equilibrium constant (Ptitsyn-Finkelstein, 1983)</p>
</dd>
<dt>QIAN880101</dt><dd><p>Weights for alpha-helix at the window position of -6
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880102</dt><dd><p>Weights for alpha-helix at the window position of -5
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880103</dt><dd><p>Weights for alpha-helix at the window position of -4
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880104</dt><dd><p>Weights for alpha-helix at the window position of -3
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880105</dt><dd><p>Weights for alpha-helix at the window position of -2
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880106</dt><dd><p>Weights for alpha-helix at the window position of -1
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880107</dt><dd><p>Weights for alpha-helix at the window position of 0
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880108</dt><dd><p>Weights for alpha-helix at the window position of 1
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880109</dt><dd><p>Weights for alpha-helix at the window position of 2
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880110</dt><dd><p>Weights for alpha-helix at the window position of 3
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880111</dt><dd><p>Weights for alpha-helix at the window position of 4
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880112</dt><dd><p>Weights for alpha-helix at the window position of 5
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880113</dt><dd><p>Weights for alpha-helix at the window position of 6
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880114</dt><dd><p>Weights for beta-sheet at the window position of -6
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880115</dt><dd><p>Weights for beta-sheet at the window position of -5
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880116</dt><dd><p>Weights for beta-sheet at the window position of -4
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880117</dt><dd><p>Weights for beta-sheet at the window position of -3
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880118</dt><dd><p>Weights for beta-sheet at the window position of -2
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880119</dt><dd><p>Weights for beta-sheet at the window position of -1
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880120</dt><dd><p>Weights for beta-sheet at the window position of 0
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880121</dt><dd><p>Weights for beta-sheet at the window position of 1
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880122</dt><dd><p>Weights for beta-sheet at the window position of 2
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880123</dt><dd><p>Weights for beta-sheet at the window position of 3
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880124</dt><dd><p>Weights for beta-sheet at the window position of 4
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880125</dt><dd><p>Weights for beta-sheet at the window position of 5
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880126</dt><dd><p>Weights for beta-sheet at the window position of 6
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880127</dt><dd><p>Weights for coil at the window position of -6
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880128</dt><dd><p>Weights for coil at the window position of -5
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880129</dt><dd><p>Weights for coil at the window position of -4
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880130</dt><dd><p>Weights for coil at the window position of -3
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880131</dt><dd><p>Weights for coil at the window position of -2
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880132</dt><dd><p>Weights for coil at the window position of -1
(Qian-Sejnowski, 1988)</p>
</dd>
<dt>QIAN880133</dt><dd><p>Weights for coil at the window position of 0 (Qian-Sejnowski,
1988)</p>
</dd>
<dt>QIAN880134</dt><dd><p>Weights for coil at the window position of 1 (Qian-Sejnowski,
1988)</p>
</dd>
<dt>QIAN880135</dt><dd><p>Weights for coil at the window position of 2 (Qian-Sejnowski,
1988)</p>
</dd>
<dt>QIAN880136</dt><dd><p>Weights for coil at the window position of 3 (Qian-Sejnowski,
1988)</p>
</dd>
<dt>QIAN880137</dt><dd><p>Weights for coil at the window position of 4 (Qian-Sejnowski,
1988)</p>
</dd>
<dt>QIAN880138</dt><dd><p>Weights for coil at the window position of 5 (Qian-Sejnowski,
1988)</p>
</dd>
<dt>QIAN880139</dt><dd><p>Weights for coil at the window position of 6 (Qian-Sejnowski,
1988)</p>
</dd>
<dt>RACS770101</dt><dd><p>Average reduced distance for C-alpha (Rackovsky-Scheraga,
1977)</p>
</dd>
<dt>RACS770102</dt><dd><p>Average reduced distance for side chain (Rackovsky-Scheraga,
1977)</p>
</dd>
<dt>RACS770103</dt><dd><p>Side chain orientational preference (Rackovsky-Scheraga,
1977)</p>
</dd>
<dt>RACS820101</dt><dd><p>Average relative fractional occurrence in A0(i)
(Rackovsky-Scheraga, 1982)</p>
</dd>
<dt>RACS820102</dt><dd><p>Average relative fractional occurrence in AR(i)
(Rackovsky-Scheraga, 1982)</p>
</dd>
<dt>RACS820103</dt><dd><p>Average relative fractional occurrence in AL(i)
(Rackovsky-Scheraga, 1982)</p>
</dd>
<dt>RACS820104</dt><dd><p>Average relative fractional occurrence in EL(i)
(Rackovsky-Scheraga, 1982)</p>
</dd>
<dt>RACS820105</dt><dd><p>Average relative fractional occurrence in E0(i)
(Rackovsky-Scheraga, 1982)</p>
</dd>
<dt>RACS820106</dt><dd><p>Average relative fractional occurrence in ER(i)
(Rackovsky-Scheraga, 1982)</p>
</dd>
<dt>RACS820107</dt><dd><p>Average relative fractional occurrence in A0(i-1)
(Rackovsky-Scheraga, 1982)</p>
</dd>
<dt>RACS820108</dt><dd><p>Average relative fractional occurrence in AR(i-1)
(Rackovsky-Scheraga, 1982)</p>
</dd>
<dt>RACS820109</dt><dd><p>Average relative fractional occurrence in AL(i-1)
(Rackovsky-Scheraga, 1982)</p>
</dd>
<dt>RACS820110</dt><dd><p>Average relative fractional occurrence in EL(i-1)
(Rackovsky-Scheraga, 1982)</p>
</dd>
<dt>RACS820111</dt><dd><p>Average relative fractional occurrence in E0(i-1)
(Rackovsky-Scheraga, 1982)</p>
</dd>
<dt>RACS820112</dt><dd><p>Average relative fractional occurrence in ER(i-1)
(Rackovsky-Scheraga, 1982)</p>
</dd>
<dt>RACS820113</dt><dd><p>Value of theta(i) (Rackovsky-Scheraga, 1982)</p>
</dd>
<dt>RACS820114</dt><dd><p>Value of theta(i-1) (Rackovsky-Scheraga, 1982)</p>
</dd>
<dt>RADA880101</dt><dd><p>Transfer free energy from chx to wat (Radzicka-Wolfenden,
1988)</p>
</dd>
<dt>RADA880102</dt><dd><p>Transfer free energy from oct to wat (Radzicka-Wolfenden,
1988)</p>
</dd>
<dt>RADA880103</dt><dd><p>Transfer free energy from vap to chx (Radzicka-Wolfenden,
1988)</p>
</dd>
<dt>RADA880104</dt><dd><p>Transfer free energy from chx to oct (Radzicka-Wolfenden,
1988)</p>
</dd>
<dt>RADA880105</dt><dd><p>Transfer free energy from vap to oct (Radzicka-Wolfenden,
1988)</p>
</dd>
<dt>RADA880106</dt><dd><p>Accessible surface area (Radzicka-Wolfenden, 1988)</p>
</dd>
<dt>RADA880107</dt><dd><p>Energy transfer from out to in(95%buried)
(Radzicka-Wolfenden, 1988)</p>
</dd>
<dt>RADA880108</dt><dd><p>Mean polarity (Radzicka-Wolfenden, 1988)</p>
</dd>
<dt>RICJ880101</dt><dd><p>Relative preference value at N&quot; (Richardson-Richardson,
1988)</p>
</dd>
<dt>RICJ880102</dt><dd><p>Relative preference value at N' (Richardson-Richardson,
1988)</p>
</dd>
<dt>RICJ880103</dt><dd><p>Relative preference value at N-cap (Richardson-Richardson,
1988)</p>
</dd>
<dt>RICJ880104</dt><dd><p>Relative preference value at N1 (Richardson-Richardson,
1988)</p>
</dd>
<dt>RICJ880105</dt><dd><p>Relative preference value at N2 (Richardson-Richardson,
1988)</p>
</dd>
<dt>RICJ880106</dt><dd><p>Relative preference value at N3 (Richardson-Richardson,
1988)</p>
</dd>
<dt>RICJ880107</dt><dd><p>Relative preference value at N4 (Richardson-Richardson,
1988)</p>
</dd>
<dt>RICJ880108</dt><dd><p>Relative preference value at N5 (Richardson-Richardson,
1988)</p>
</dd>
<dt>RICJ880109</dt><dd><p>Relative preference value at Mid (Richardson-Richardson,
1988)</p>
</dd>
<dt>RICJ880110</dt><dd><p>Relative preference value at C5 (Richardson-Richardson,
1988)</p>
</dd>
<dt>RICJ880111</dt><dd><p>Relative preference value at C4 (Richardson-Richardson,
1988)</p>
</dd>
<dt>RICJ880112</dt><dd><p>Relative preference value at C3 (Richardson-Richardson,
1988)</p>
</dd>
<dt>RICJ880113</dt><dd><p>Relative preference value at C2 (Richardson-Richardson,
1988)</p>
</dd>
<dt>RICJ880114</dt><dd><p>Relative preference value at C1 (Richardson-Richardson,
1988)</p>
</dd>
<dt>RICJ880115</dt><dd><p>Relative preference value at C-cap (Richardson-Richardson,
1988)</p>
</dd>
<dt>RICJ880116</dt><dd><p>Relative preference value at C' (Richardson-Richardson,
1988)</p>
</dd>
<dt>RICJ880117</dt><dd><p>Relative preference value at C&quot; (Richardson-Richardson,
1988)</p>
</dd>
<dt>ROBB760101</dt><dd><p>Information measure for alpha-helix (Robson-Suzuki, 1976)</p>
</dd>
<dt>ROBB760102</dt><dd><p>Information measure for N-terminal helix (Robson-Suzuki,
1976)</p>
</dd>
<dt>ROBB760103</dt><dd><p>Information measure for middle helix (Robson-Suzuki, 1976)</p>
</dd>
<dt>ROBB760104</dt><dd><p>Information measure for C-terminal helix (Robson-Suzuki,
1976)</p>
</dd>
<dt>ROBB760105</dt><dd><p>Information measure for extended (Robson-Suzuki, 1976)</p>
</dd>
<dt>ROBB760106</dt><dd><p>Information measure for pleated-sheet (Robson-Suzuki, 1976)</p>
</dd>
<dt>ROBB760107</dt><dd><p>Information measure for extended without H-bond
(Robson-Suzuki, 1976)</p>
</dd>
<dt>ROBB760108</dt><dd><p>Information measure for turn (Robson-Suzuki, 1976)</p>
</dd>
<dt>ROBB760109</dt><dd><p>Information measure for N-terminal turn (Robson-Suzuki,
1976)</p>
</dd>
<dt>ROBB760110</dt><dd><p>Information measure for middle turn (Robson-Suzuki, 1976)</p>
</dd>
<dt>ROBB760111</dt><dd><p>Information measure for C-terminal turn (Robson-Suzuki,
1976)</p>
</dd>
<dt>ROBB760112</dt><dd><p>Information measure for coil (Robson-Suzuki, 1976)</p>
</dd>
<dt>ROBB760113</dt><dd><p>Information measure for loop (Robson-Suzuki, 1976)</p>
</dd>
<dt>ROBB790101</dt><dd><p>Hydration free energy (Robson-Osguthorpe, 1979)</p>
</dd>
<dt>ROSG850101</dt><dd><p>Mean area buried on transfer (Rose et al., 1985)</p>
</dd>
<dt>ROSG850102</dt><dd><p>Mean fractional area loss (Rose et al., 1985)</p>
</dd>
<dt>ROSM880101</dt><dd><p>Side chain hydropathy, uncorrected for solvation (Roseman,
1988)</p>
</dd>
<dt>ROSM880102</dt><dd><p>Side chain hydropathy, corrected for solvation (Roseman,
1988)</p>
</dd>
<dt>ROSM880103</dt><dd><p>Loss of Side chain hydropathy by helix formation (Roseman,
1988)</p>
</dd>
<dt>SIMZ760101</dt><dd><p>Transfer free energy (Simon, 1976), Cited by Charton-Charton
(1982)</p>
</dd>
<dt>SNEP660101</dt><dd><p>Principal component I (Sneath, 1966)</p>
</dd>
<dt>SNEP660102</dt><dd><p>Principal component II (Sneath, 1966)</p>
</dd>
<dt>SNEP660103</dt><dd><p>Principal component III (Sneath, 1966)</p>
</dd>
<dt>SNEP660104</dt><dd><p>Principal component IV (Sneath, 1966)</p>
</dd>
<dt>SUEM840101</dt><dd><p>Zimm-Bragg parameter s at 20 C (Sueki et al., 1984)</p>
</dd>
<dt>SUEM840102</dt><dd><p>Zimm-Bragg parameter sigma x 1.0E4 (Sueki et al., 1984)</p>
</dd>
<dt>SWER830101</dt><dd><p>Optimal matching hydrophobicity (Sweet-Eisenberg, 1983)</p>
</dd>
<dt>TANS770101</dt><dd><p>Normalized frequency of alpha-helix (Tanaka-Scheraga, 1977)</p>
</dd>
<dt>TANS770102</dt><dd><p>Normalized frequency of isolated helix (Tanaka-Scheraga,
1977)</p>
</dd>
<dt>TANS770103</dt><dd><p>Normalized frequency of extended structure (Tanaka-Scheraga,
1977)</p>
</dd>
<dt>TANS770104</dt><dd><p>Normalized frequency of chain reversal R (Tanaka-Scheraga,
1977)</p>
</dd>
<dt>TANS770105</dt><dd><p>Normalized frequency of chain reversal S (Tanaka-Scheraga,
1977)</p>
</dd>
<dt>TANS770106</dt><dd><p>Normalized frequency of chain reversal D (Tanaka-Scheraga,
1977)</p>
</dd>
<dt>TANS770107</dt><dd><p>Normalized frequency of left-handed helix (Tanaka-Scheraga,
1977)</p>
</dd>
<dt>TANS770108</dt><dd><p>Normalized frequency of zeta R (Tanaka-Scheraga, 1977)</p>
</dd>
<dt>TANS770109</dt><dd><p>Normalized frequency of coil (Tanaka-Scheraga, 1977)</p>
</dd>
<dt>TANS770110</dt><dd><p>Normalized frequency of chain reversal (Tanaka-Scheraga,
1977)</p>
</dd>
<dt>VASM830101</dt><dd><p>Relative population of conformational state A (Vasquez et
al., 1983)</p>
</dd>
<dt>VASM830102</dt><dd><p>Relative population of conformational state C (Vasquez et
al., 1983)</p>
</dd>
<dt>VASM830103</dt><dd><p>Relative population of conformational state E (Vasquez et
al., 1983)</p>
</dd>
<dt>VELV850101</dt><dd><p>Electron-ion interaction potential (Veljkovic et al., 1985)</p>
</dd>
<dt>VENT840101</dt><dd><p>Bitterness (Venanzi, 1984)</p>
</dd>
<dt>VHEG790101</dt><dd><p>Transfer free energy to lipophilic phase (von
Heijne-Blomberg, 1979)</p>
</dd>
<dt>WARP780101</dt><dd><p>Average interactions per side chain atom (Warme-Morgan,
1978)</p>
</dd>
<dt>WEBA780101</dt><dd><p>RF value in high salt chromatography (Weber-Lacey, 1978)</p>
</dd>
<dt>WERD780101</dt><dd><p>Propensity to be buried inside (Wertz-Scheraga, 1978)</p>
</dd>
<dt>WERD780102</dt><dd><p>Free energy change of epsilon(i) to epsilon(ex)
(Wertz-Scheraga, 1978)</p>
</dd>
<dt>WERD780103</dt><dd><p>Free energy change of alpha(Ri) to alpha(Rh) (Wertz-Scheraga,
1978)</p>
</dd>
<dt>WERD780104</dt><dd><p>Free energy change of epsilon(i) to alpha(Rh)
(Wertz-Scheraga, 1978)</p>
</dd>
<dt>WOEC730101</dt><dd><p>Polar requirement (Woese, 1973)</p>
</dd>
<dt>WOLR810101</dt><dd><p>Hydration potential (Wolfenden et al., 1981)</p>
</dd>
<dt>WOLS870101</dt><dd><p>Principal property value z1 (Wold et al., 1987)</p>
</dd>
<dt>WOLS870102</dt><dd><p>Principal property value z2 (Wold et al., 1987)</p>
</dd>
<dt>WOLS870103</dt><dd><p>Principal property value z3 (Wold et al., 1987)</p>
</dd>
<dt>YUTK870101</dt><dd><p>Unfolding Gibbs energy in water, pH7.0 (Yutani et al., 1987)</p>
</dd>
<dt>YUTK870102</dt><dd><p>Unfolding Gibbs energy in water, pH9.0 (Yutani et al., 1987)</p>
</dd>
<dt>YUTK870103</dt><dd><p>Activation Gibbs energy of unfolding, pH7.0 (Yutani et al.,
1987)</p>
</dd>
<dt>YUTK870104</dt><dd><p>Activation Gibbs energy of unfolding, pH9.0 (Yutani et al.,
1987)</p>
</dd>
<dt>ZASB820101</dt><dd><p>Dependence of partition coefficient on ionic strength
(Zaslavsky et al., 1982)</p>
</dd>
<dt>ZIMJ680101</dt><dd><p>Hydrophobicity (Zimmerman et al., 1968)</p>
</dd>
<dt>ZIMJ680102</dt><dd><p>Bulkiness (Zimmerman et al., 1968)</p>
</dd>
<dt>ZIMJ680103</dt><dd><p>Polarity (Zimmerman et al., 1968)</p>
</dd>
<dt>ZIMJ680104</dt><dd><p>Isoelectric point (Zimmerman et al., 1968)</p>
</dd>
<dt>ZIMJ680105</dt><dd><p>RF rank (Zimmerman et al., 1968)</p>
</dd>
<dt>AURR980101</dt><dd><p>Normalized positional residue frequency at helix termini
N4'(Aurora-Rose, 1998)</p>
</dd>
<dt>AURR980102</dt><dd><p>Normalized positional residue frequency at helix termini N&quot;'
(Aurora-Rose, 1998)</p>
</dd>
<dt>AURR980103</dt><dd><p>Normalized positional residue frequency at helix termini N&quot;
(Aurora-Rose, 1998)</p>
</dd>
<dt>AURR980104</dt><dd><p>Normalized positional residue frequency at helix termini
N'(Aurora-Rose, 1998)</p>
</dd>
<dt>AURR980105</dt><dd><p>Normalized positional residue frequency at helix termini Nc
(Aurora-Rose, 1998)</p>
</dd>
<dt>AURR980106</dt><dd><p>Normalized positional residue frequency at helix termini N1
(Aurora-Rose, 1998)</p>
</dd>
<dt>AURR980107</dt><dd><p>Normalized positional residue frequency at helix termini N2
(Aurora-Rose, 1998)</p>
</dd>
<dt>AURR980108</dt><dd><p>Normalized positional residue frequency at helix termini N3
(Aurora-Rose, 1998)</p>
</dd>
<dt>AURR980109</dt><dd><p>Normalized positional residue frequency at helix termini N4
(Aurora-Rose, 1998)</p>
</dd>
<dt>AURR980110</dt><dd><p>Normalized positional residue frequency at helix termini N5
(Aurora-Rose, 1998)</p>
</dd>
<dt>AURR980111</dt><dd><p>Normalized positional residue frequency at helix termini C5
(Aurora-Rose, 1998)</p>
</dd>
<dt>AURR980112</dt><dd><p>Normalized positional residue frequency at helix termini C4
(Aurora-Rose, 1998)</p>
</dd>
<dt>AURR980113</dt><dd><p>Normalized positional residue frequency at helix termini C3
(Aurora-Rose, 1998)</p>
</dd>
<dt>AURR980114</dt><dd><p>Normalized positional residue frequency at helix termini C2
(Aurora-Rose, 1998)</p>
</dd>
<dt>AURR980115</dt><dd><p>Normalized positional residue frequency at helix termini C1
(Aurora-Rose, 1998)</p>
</dd>
<dt>AURR980116</dt><dd><p>Normalized positional residue frequency at helix termini Cc
(Aurora-Rose, 1998)</p>
</dd>
<dt>AURR980117</dt><dd><p>Normalized positional residue frequency at helix termini C'
(Aurora-Rose, 1998)</p>
</dd>
<dt>AURR980118</dt><dd><p>Normalized positional residue frequency at helix termini C&quot;
(Aurora-Rose, 1998)</p>
</dd>
<dt>AURR980119</dt><dd><p>Normalized positional residue frequency at helix termini C&quot;'
(Aurora-Rose, 1998)</p>
</dd>
<dt>AURR980120</dt><dd><p>Normalized positional residue frequency at helix termini C4'
(Aurora-Rose, 1998)</p>
</dd>
<dt>ONEK900101</dt><dd><p>Delta G values for the peptides extrapolated to 0 M urea
(O'Neil-DeGrado, 1990)</p>
</dd>
<dt>ONEK900102</dt><dd><p>Helix formation parameters (delta delta G) (O'Neil-DeGrado,
1990)</p>
</dd>
<dt>VINM940101</dt><dd><p>Normalized flexibility parameters (B-values), average
(Vihinen et al., 1994)</p>
</dd>
<dt>VINM940102</dt><dd><p>Normalized flexibility parameters (B-values) for each residue
surrounded by none rigid neighbours (Vihinen et al., 1994)</p>
</dd>
<dt>VINM940103</dt><dd><p>Normalized flexibility parameters (B-values) for each residue
surrounded by one rigid neighbours (Vihinen et al., 1994)</p>
</dd>
<dt>VINM940104</dt><dd><p>Normalized flexibility parameters (B-values) for each residue
surrounded by two rigid neighbours (Vihinen et al., 1994)</p>
</dd>
<dt>MUNV940101</dt><dd><p>Free energy in alpha-helical conformation (Munoz-Serrano,
1994)</p>
</dd>
<dt>MUNV940102</dt><dd><p>Free energy in alpha-helical region (Munoz-Serrano, 1994)</p>
</dd>
<dt>MUNV940103</dt><dd><p>Free energy in beta-strand conformation (Munoz-Serrano,
1994)</p>
</dd>
<dt>MUNV940104</dt><dd><p>Free energy in beta-strand region (Munoz-Serrano, 1994)</p>
</dd>
<dt>MUNV940105</dt><dd><p>Free energy in beta-strand region (Munoz-Serrano, 1994)</p>
</dd>
<dt>WIMW960101</dt><dd><p>Free energies of transfer of AcWl-X-LL peptides from bilayer
interface to water (Wimley-White, 1996)</p>
</dd>
<dt>KIMC930101</dt><dd><p>Thermodynamic beta sheet propensity (Kim-Berg, 1993)</p>
</dd>
<dt>MONM990101</dt><dd><p>Turn propensity scale for transmembrane helices (Monne et
al., 1999)</p>
</dd>
<dt>BLAM930101</dt><dd><p>Alpha helix propensity of position 44 in T4 lysozyme (Blaber
et al., 1993)</p>
</dd>
<dt>PARS000101</dt><dd><p>p-Values of mesophilic proteins based on the distributions of
B values (Parthasarathy-Murthy, 2000)</p>
</dd>
<dt>PARS000102</dt><dd><p>p-Values of thermophilic proteins based on the distributions
of B values (Parthasarathy-Murthy, 2000)</p>
</dd>
<dt>KUMS000101</dt><dd><p>Distribution of amino acid residues in the 18 non-redundant
families of thermophilic proteins (Kumar et al., 2000)</p>
</dd>
<dt>KUMS000102</dt><dd><p>Distribution of amino acid residues in the 18 non-redundant
families of mesophilic proteins (Kumar et al., 2000)</p>
</dd>
<dt>KUMS000103</dt><dd><p>Distribution of amino acid residues in the alpha-helices in
thermophilic proteins (Kumar et al., 2000)</p>
</dd>
<dt>KUMS000104</dt><dd><p>Distribution of amino acid residues in the alpha-helices in
mesophilic proteins (Kumar et al., 2000)</p>
</dd>
<dt>TAKK010101</dt><dd><p>Side-chain contribution to protein stability (kJ/mol)
(Takano-Yutani, 2001)</p>
</dd>
<dt>FODM020101</dt><dd><p>Propensity of amino acids within pi-helices
(Fodje-Al-Karadaghi, 2002)</p>
</dd>
<dt>NADH010101</dt><dd><p>Hydropathy scale based on self-information values in the
two-state model (5% accessibility) (Naderi-Manesh et al., 2001)</p>
</dd>
<dt>NADH010102</dt><dd><p>Hydropathy scale based on self-information values in the
two-state model (9% accessibility) (Naderi-Manesh et al., 2001)</p>
</dd>
<dt>NADH010103</dt><dd><p>Hydropathy scale based on self-information values in the
two-state model (16% accessibility) (Naderi-Manesh et al., 2001)</p>
</dd>
<dt>NADH010104</dt><dd><p>Hydropathy scale based on self-information values in the
two-state model (20% accessibility) (Naderi-Manesh et al., 2001)</p>
</dd>
<dt>NADH010105</dt><dd><p>Hydropathy scale based on self-information values in the
two-state model (25% accessibility) (Naderi-Manesh et al., 2001)</p>
</dd>
<dt>NADH010106</dt><dd><p>Hydropathy scale based on self-information values in the
two-state model (36% accessibility) (Naderi-Manesh et al., 2001)</p>
</dd>
<dt>NADH010107</dt><dd><p>Hydropathy scale based on self-information values in the
two-state model (50% accessibility) (Naderi-Manesh et al., 2001)</p>
</dd>
<dt>MONM990201</dt><dd><p>Averaged turn propensities in a transmembrane helix (Monne et
al., 1999)</p>
</dd>
<dt>KOEP990101</dt><dd><p>Alpha-helix propensity derived from designed sequences
(Koehl-Levitt, 1999)</p>
</dd>
<dt>KOEP990102</dt><dd><p>Beta-sheet propensity derived from designed sequences
(Koehl-Levitt, 1999)</p>
</dd>
<dt>CEDJ970101</dt><dd><p>Composition of amino acids in extracellular proteins
(percent) (Cedano et al., 1997)</p>
</dd>
<dt>CEDJ970102</dt><dd><p>Composition of amino acids in anchored proteins (percent)
(Cedano et al., 1997)</p>
</dd>
<dt>CEDJ970103</dt><dd><p>Composition of amino acids in membrane proteins (percent)
(Cedano et al., 1997)</p>
</dd>
<dt>CEDJ970104</dt><dd><p>Composition of amino acids in intracellular proteins
(percent) (Cedano et al., 1997)</p>
</dd>
<dt>CEDJ970105</dt><dd><p>Composition of amino acids in nuclear proteins (percent)
(Cedano et al., 1997)</p>
</dd>
<dt>FUKS010101</dt><dd><p>Surface composition of amino acids in intracellular proteins
of thermophiles (percent) (Fukuchi-Nishikawa, 2001)</p>
</dd>
<dt>FUKS010102</dt><dd><p>Surface composition of amino acids in intracellular proteins
of mesophiles (percent) (Fukuchi-Nishikawa, 2001)</p>
</dd>
<dt>FUKS010103</dt><dd><p>Surface composition of amino acids in extracellular proteins
of mesophiles (percent) (Fukuchi-Nishikawa, 2001)</p>
</dd>
<dt>FUKS010104</dt><dd><p>Surface composition of amino acids in nuclear proteins
(percent) (Fukuchi-Nishikawa, 2001)</p>
</dd>
<dt>FUKS010105</dt><dd><p>Interior composition of amino acids in intracellular proteins
of thermophiles (percent) (Fukuchi-Nishikawa, 2001)</p>
</dd>
<dt>FUKS010106</dt><dd><p>Interior composition of amino acids in intracellular proteins
of mesophiles (percent) (Fukuchi-Nishikawa, 2001)</p>
</dd>
<dt>FUKS010107</dt><dd><p>Interior composition of amino acids in extracellular proteins
of mesophiles (percent) (Fukuchi-Nishikawa, 2001)</p>
</dd>
<dt>FUKS010108</dt><dd><p>Interior composition of amino acids in nuclear proteins
(percent) (Fukuchi-Nishikawa, 2001)</p>
</dd>
<dt>FUKS010109</dt><dd><p>Entire chain composition of amino acids in intracellular
proteins of thermophiles (percent) (Fukuchi-Nishikawa, 2001)</p>
</dd>
<dt>FUKS010110</dt><dd><p>Entire chain composition of amino acids in intracellular
proteins of mesophiles (percent) (Fukuchi-Nishikawa, 2001)</p>
</dd>
<dt>FUKS010111</dt><dd><p>Entire chain composition of amino acids in extracellular
proteins of mesophiles (percent) (Fukuchi-Nishikawa, 2001)</p>
</dd>
<dt>FUKS010112</dt><dd><p>Entire chain compositino of amino acids in nuclear proteins
(percent) (Fukuchi-Nishikawa, 2001)</p>
</dd>
<dt>AVBF000101</dt><dd><p>Screening coefficients gamma, local (Avbelj, 2000)</p>
</dd>
<dt>AVBF000102</dt><dd><p>Screening coefficients gamma, non-local (Avbelj, 2000)</p>
</dd>
<dt>AVBF000103</dt><dd><p>Slopes tripeptide, FDPB VFF neutral (Avbelj, 2000)</p>
</dd>
<dt>AVBF000104</dt><dd><p>Slopes tripeptides, LD VFF neutral (Avbelj, 2000)</p>
</dd>
<dt>AVBF000105</dt><dd><p>Slopes tripeptide, FDPB VFF noside (Avbelj, 2000)</p>
</dd>
<dt>AVBF000106</dt><dd><p>Slopes tripeptide FDPB VFF all (Avbelj, 2000)</p>
</dd>
<dt>AVBF000107</dt><dd><p>Slopes tripeptide FDPB PARSE neutral (Avbelj, 2000)</p>
</dd>
<dt>AVBF000108</dt><dd><p>Slopes dekapeptide, FDPB VFF neutral (Avbelj, 2000)</p>
</dd>
<dt>AVBF000109</dt><dd><p>Slopes proteins, FDPB VFF neutral (Avbelj, 2000)</p>
</dd>
<dt>YANJ020101</dt><dd><p>Side-chain conformation by gaussian evolutionary method (Yang
et al., 2002)</p>
</dd>
<dt>MITS020101</dt><dd><p>Amphiphilicity index (Mitaku et al., 2002)</p>
</dd>
<dt>TSAJ990101</dt><dd><p>Volumes including the crystallographic waters using the
ProtOr (Tsai et al., 1999)</p>
</dd>
<dt>TSAJ990102</dt><dd><p>Volumes not including the crystallographic waters using the
ProtOr (Tsai et al., 1999)</p>
</dd>
<dt>COSI940101</dt><dd><p>Electron-ion interaction potential values (Cosic, 1994)</p>
</dd>
<dt>PONP930101</dt><dd><p>Hydrophobicity scales (Ponnuswamy, 1993)</p>
</dd>
<dt>WILM950101</dt><dd><p>Hydrophobicity coefficient in RP-HPLC, C18 with
0.1%TFA/MeCN/H2O (Wilce et al. 1995)</p>
</dd>
<dt>WILM950102</dt><dd><p>Hydrophobicity coefficient in RP-HPLC, C8 with
0.1%TFA/MeCN/H2O (Wilce et al. 1995)</p>
</dd>
<dt>WILM950103</dt><dd><p>Hydrophobicity coefficient in RP-HPLC, C4 with
0.1%TFA/MeCN/H2O (Wilce et al. 1995)</p>
</dd>
<dt>WILM950104</dt><dd><p>Hydrophobicity coefficient in RP-HPLC, C18 with
0.1%TFA/2-PrOH/MeCN/H2O (Wilce et al. 1995)</p>
</dd>
<dt>KUHL950101</dt><dd><p>Hydrophilicity scale (Kuhn et al., 1995)</p>
</dd>
<dt>GUOD860101</dt><dd><p>Retention coefficient at pH 2 (Guo et al., 1986)</p>
</dd>
<dt>JURD980101</dt><dd><p>Modified Kyte-Doolittle hydrophobicity scale (Juretic et al.,
1998)</p>
</dd>
<dt>BASU050101</dt><dd><p>Interactivity scale obtained from the contact matrix
(Bastolla et al., 2005)</p>
</dd>
<dt>BASU050102</dt><dd><p>Interactivity scale obtained by maximizing the mean of
correlation coefficient over single-domain globular proteins (Bastolla et al.,
2005)</p>
</dd>
<dt>BASU050103</dt><dd><p>Interactivity scale obtained by maximizing the mean of
correlation coefficient over pairs of sequences sharing the TIM barrel fold
(Bastolla et al., 2005)</p>
</dd>
<dt>SUYM030101</dt><dd><p>Linker propensity index (Suyama-Ohara, 2003)</p>
</dd>
<dt>PUNT030101</dt><dd><p>Knowledge-based membrane-propensity scale from 1D_Helix in
MPtopo databases (Punta-Maritan, 2003)</p>
</dd>
<dt>PUNT030102</dt><dd><p>Knowledge-based membrane-propensity scale from 3D_Helix in
MPtopo databases (Punta-Maritan, 2003)</p>
</dd>
<dt>GEOR030101</dt><dd><p>Linker propensity from all dataset (George-Heringa, 2003)</p>
</dd>
<dt>GEOR030102</dt><dd><p>Linker propensity from 1-linker dataset (George-Heringa,
2003)</p>
</dd>
<dt>GEOR030103</dt><dd><p>Linker propensity from 2-linker dataset (George-Heringa,
2003)</p>
</dd>
<dt>GEOR030104</dt><dd><p>Linker propensity from 3-linker dataset (George-Heringa,
2003)</p>
</dd>
<dt>GEOR030105</dt><dd><p>Linker propensity from small dataset (linker length is less
than six residues) (George-Heringa, 2003)</p>
</dd>
<dt>GEOR030106</dt><dd><p>Linker propensity from medium dataset (linker length is
between six and 14 residues) (George-Heringa, 2003)</p>
</dd>
<dt>GEOR030107</dt><dd><p>Linker propensity from long dataset (linker length is greater
than 14 residues) (George-Heringa, 2003)</p>
</dd>
<dt>GEOR030108</dt><dd><p>Linker propensity from helical (annotated by DSSP) dataset
(George-Heringa, 2003)</p>
</dd>
<dt>GEOR030109</dt><dd><p>Linker propensity from non-helical (annotated by DSSP)
dataset (George-Heringa, 2003)</p>
</dd>
<dt>ZHOH040101</dt><dd><p>The stability scale from the knowledge-based atom-atom
potential (Zhou-Zhou, 2004)</p>
</dd>
<dt>ZHOH040102</dt><dd><p>The relative stability scale extracted from mutation
experiments (Zhou-Zhou, 2004)</p>
</dd>
<dt>ZHOH040103</dt><dd><p>Buriability (Zhou-Zhou, 2004)</p>
</dd>
<dt>BAEK050101</dt><dd><p>Linker index (Bae et al., 2005)</p>
</dd>
<dt>HARY940101</dt><dd><p>Mean volumes of residues buried in protein interiors (Harpaz
et al., 1994)</p>
</dd>
<dt>PONJ960101</dt><dd><p>Average volumes of residues (Pontius et al., 1996)</p>
</dd>
<dt>DIGM050101</dt><dd><p>Hydrostatic pressure asymmetry index, PAI (Di Giulio, 2005)</p>
</dd>
<dt>WOLR790101</dt><dd><p>Hydrophobicity index (Wolfenden et al., 1979)</p>
</dd>
<dt>OLSK800101</dt><dd><p>Average internal preferences (Olsen, 1980)</p>
</dd>
<dt>KIDA850101</dt><dd><p>Hydrophobicity-related index (Kidera et al., 1985)</p>
</dd>
<dt>GUYH850102</dt><dd><p>Apparent partition energies calculated from Wertz-Scheraga
index (Guy, 1985)</p>
</dd>
<dt>GUYH850103</dt><dd><p>Apparent partition energies calculated from Robson-Osguthorpe
index (Guy, 1985)</p>
</dd>
<dt>GUYH850104</dt><dd><p>Apparent partition energies calculated from Janin index (Guy,
1985)</p>
</dd>
<dt>GUYH850105</dt><dd><p>Apparent partition energies calculated from Chothia index
(Guy, 1985)</p>
</dd>
<dt>ROSM880104</dt><dd><p>Hydropathies of amino acid side chains, neutral form
(Roseman, 1988)</p>
</dd>
<dt>ROSM880105</dt><dd><p>Hydropathies of amino acid side chains, pi-values in pH 7.0
(Roseman, 1988)</p>
</dd>
<dt>JACR890101</dt><dd><p>Weights from the IFH scale (Jacobs-White, 1989)</p>
</dd>
<dt>COWR900101</dt><dd><p>Hydrophobicity index, 3.0 pH (Cowan-Whittaker, 1990)</p>
</dd>
<dt>BLAS910101</dt><dd><p>Scaled side chain hydrophobicity values (Black-Mould, 1991)</p>
</dd>
<dt>CASG920101</dt><dd><p>Hydrophobicity scale from native protein structures
(Casari-Sippl, 1992)</p>
</dd>
<dt>CORJ870101</dt><dd><p>NNEIG index (Cornette et al., 1987)</p>
</dd>
<dt>CORJ870102</dt><dd><p>SWEIG index (Cornette et al., 1987)</p>
</dd>
<dt>CORJ870103</dt><dd><p>PRIFT index (Cornette et al., 1987)</p>
</dd>
<dt>CORJ870104</dt><dd><p>PRILS index (Cornette et al., 1987)</p>
</dd>
<dt>CORJ870105</dt><dd><p>ALTFT index (Cornette et al., 1987)</p>
</dd>
<dt>CORJ870106</dt><dd><p>ALTLS index (Cornette et al., 1987)</p>
</dd>
<dt>CORJ870107</dt><dd><p>TOTFT index (Cornette et al., 1987)</p>
</dd>
<dt>CORJ870108</dt><dd><p>TOTLS index (Cornette et al., 1987)</p>
</dd>
<dt>MIYS990101</dt><dd><p>Relative partition energies derived by the Bethe
approximation (Miyazawa-Jernigan, 1999)</p>
</dd>
<dt>MIYS990102</dt><dd><p>Optimized relative partition energies - method A
(Miyazawa-Jernigan, 1999)</p>
</dd>
<dt>MIYS990103</dt><dd><p>Optimized relative partition energies - method B
(Miyazawa-Jernigan, 1999)</p>
</dd>
<dt>MIYS990104</dt><dd><p>Optimized relative partition energies - method C
(Miyazawa-Jernigan, 1999)</p>
</dd>
<dt>MIYS990105</dt><dd><p>Optimized relative partition energies - method D
(Miyazawa-Jernigan, 1999)</p>
</dd>
<dt>ENGD860101</dt><dd><p>Hydrophobicity index (Engelman et al., 1986)</p>
</dd>
<dt>FASG890101</dt><dd><p>Hydrophobicity index (Fasman, 1989)</p>
</dd>
<dt>K6.5</dt><dd><p>Values of Wc in proteins from class Beta, cutoff 6 A, 
separation 5 (Wozniak, 2014)</p>
</dd>
<dt>K8.5</dt><dd><p>Values of Wc in proteins from class Beta, cutoff 8 A, 
separation 5 (Wozniak, 2014)</p>
</dd>
<dt>K12.5</dt><dd><p>Values of Wc in proteins from class Beta, cutoff 12 A, 
separation 5 (Wozniak, 2014)</p>
</dd>
<dt>K6.15</dt><dd><p>Values of Wc in proteins from class Beta, cutoff 6 A, 
separation 15 (Wozniak, 2014)</p>
</dd>
<dt>K8.15</dt><dd><p>Values of Wc in proteins from class Beta, cutoff 8 A, 
separation 15 (Wozniak, 2014)</p>
</dd>
<dt>K12.15</dt><dd><p>Values of Wc in proteins from class Beta, cutoff 12 A, 
separation 15 (Wozniak, 2014)</p>
</dd>
</dl>



<h3>Source</h3>

<p>AAIndex database.
</p>


<h3>References</h3>

<p>Kawashima, S. and Kanehisa, M. (2000) AAindex: amino acid 
index database. Nucleic Acids Res., 28:374.
</p>
<p>Wozniak, P. and Kotulska M. (2014) Characteristics of protein 
residue-residue contacts and their application in contact prediction.
20(11):2497
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(aaprop)

</code></pre>

<hr>
<h2 id='add_1grams'>Add 1-grams</h2><span id='topic+add_1grams'></span>

<h3>Description</h3>

<p>Builds (n+1)-grams from n-grams.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_1grams(ngram, u, seq_length)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_1grams_+3A_ngram">ngram</code></td>
<td>
<p>a single n-gram.</p>
</td></tr>
<tr><td><code id="add_1grams_+3A_u">u</code></td>
<td>
<p><code>integer</code>, <code>numeric</code> or <code>character</code> vector of all possible 
unigrams.</p>
</td></tr>
<tr><td><code id="add_1grams_+3A_seq_length">seq_length</code></td>
<td>
<p>length of an origin sequence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>n-grams are built by pasting every possible unigram in the every possible free 
position. The total length of n-gram (n plus total distance between elements of the n-gram) 
is limited by the length of an origin sequence, because the n-gram cannot be longer than 
an origin sequence.
</p>


<h3>Value</h3>

<p>vector of n-grams (where <code>n</code> is equal to the <code>n</code> of the input plus one).
</p>


<h3>See Also</h3>

<p>Reverse function: <code><a href="#topic+gap_ngrams">gap_ngrams</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>add_1grams("1_2.3.4_3.0", 1L:4, 8)

add_1grams("a.a_1", c("a", "b", "c"), 4)
</code></pre>

<hr>
<h2 id='as.data.frame.feature_test'>Coerce feature_test object to a data frame</h2><span id='topic+as.data.frame.feature_test'></span>

<h3>Description</h3>

<p>Coerce results of <code><a href="#topic+test_features">test_features</a></code> function to a 
<code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'feature_test'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  stringsAsFactors = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.feature_test_+3A_x">x</code></td>
<td>
<p>object of class <code><a href="#topic+feature_test">feature_test</a></code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.feature_test_+3A_row.names">row.names</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="as.data.frame.feature_test_+3A_optional">optional</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="as.data.frame.feature_test_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>logical: should the character vector be converted 
to a factor?.</p>
</td></tr>
<tr><td><code id="as.data.frame.feature_test_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with four columns: names of n-gram, p-values,
occurrences in positive and negative sequences.
</p>

<hr>
<h2 id='binarize'>Binarize</h2><span id='topic+binarize'></span>

<h3>Description</h3>

<p>Binarizes a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binarize(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binarize_+3A_x">x</code></td>
<td>
<p><code>matrix</code> or <code><a href="slam.html#topic+simple_triplet_matrix">simple_triplet_matrix</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>matrix</code> or <code><a href="slam.html#topic+simple_triplet_matrix">simple_triplet_matrix</a></code> 
(depending on the input).
</p>

<hr>
<h2 id='calc_criterion'>Calculate value of criterion</h2><span id='topic+calc_criterion'></span>

<h3>Description</h3>

<p>Computes a chosen statistical criterion for each feature versus target vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_criterion(target, features, criterion_function)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_criterion_+3A_target">target</code></td>
<td>
<p><code>integer</code> vector with target information (e.g. class labels).</p>
</td></tr>
<tr><td><code id="calc_criterion_+3A_features">features</code></td>
<td>
<p><code>integer</code> matrix of features with number of rows equal 
to the length of the target vector.</p>
</td></tr>
<tr><td><code id="calc_criterion_+3A_criterion_function">criterion_function</code></td>
<td>
<p>a function calculating criterion. For a full list, see 
<code><a href="#topic+test_features">test_features</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The permutation test implemented in <code>biogram</code> uses several criterions to filter 
important features. Each can be used by <code><a href="#topic+test_features">test_features</a></code> by specifying the 
<code>criterion</code> parameter.
</p>


<h3>Value</h3>

<p>a <code>integer</code> vector of length equal to the number of features 
containing computed information gain values.
</p>


<h3>Note</h3>

<p>Both <code>target</code> and <code>features</code> must be binary, i.e. contain only 0 
and 1 values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+test_features">test_features</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar &lt;- sample(0L:1, 100, replace = TRUE)
feats &lt;- matrix(sample(0L:1, 400, replace = TRUE), ncol = 4)

# Information Gain
calc_criterion(tar, feats, calc_ig)

# hi-squared-based measure
calc_criterion(tar, feats, calc_cs)

# Kullback-Leibler divergence
calc_criterion(tar, feats, calc_kl)
</code></pre>

<hr>
<h2 id='calc_cs'>Calculate Chi-squared-based measure</h2><span id='topic+calc_cs'></span>

<h3>Description</h3>

<p>Computes Chi-squared-based measure between features and target vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_cs(feature, target, len_target, pos_target)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_cs_+3A_feature">feature</code></td>
<td>
<p>feature vector.</p>
</td></tr>
<tr><td><code id="calc_cs_+3A_target">target</code></td>
<td>
<p>target.</p>
</td></tr>
<tr><td><code id="calc_cs_+3A_len_target">len_target</code></td>
<td>
<p>length of the target vector.</p>
</td></tr>
<tr><td><code id="calc_cs_+3A_pos_target">pos_target</code></td>
<td>
<p>number of positive cases in the target vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> vector of length 1 representing computed Chi-square values.
</p>


<h3>Note</h3>

<p>Both <code>target</code> and <code>features</code> must be binary, i.e. contain only 0 
and 1 values.
</p>
<p>The function was designed to be as fast as possible subroutine of 
<code><a href="#topic+calc_criterion">calc_criterion</a></code> and might be cumbersome if directly called by a user.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+test_features">test_features</a></code>.
</p>
<p><code><a href="stats.html#topic+chisq.test">chisq.test</a></code> - Pearson's chi-squared test for count data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar &lt;- sample(0L:1, 100, replace = TRUE)
feat &lt;- sample(0L:1, 100, replace = TRUE)
calc_cs(feat, tar, 100, sum(tar))
</code></pre>

<hr>
<h2 id='calc_ed'>Calculate encoding distance</h2><span id='topic+calc_ed'></span>

<h3>Description</h3>

<p>Computes the encoding distance between two encodings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_ed(a, b, prop = NULL, measure)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_ed_+3A_a">a</code></td>
<td>
<p>encoding (see <code><a href="#topic+validate_encoding">validate_encoding</a></code> for more information 
about the required structure of encoding).</p>
</td></tr>
<tr><td><code id="calc_ed_+3A_b">b</code></td>
<td>
<p>encoding to which <code>a</code> should be compared. Must have equal number 
of groups or less than <code>a</code>. Both <code>a</code> and b must have the the same 
number of elements.</p>
</td></tr>
<tr><td><code id="calc_ed_+3A_prop">prop</code></td>
<td>
<p><code>matrix</code> of physicochemical properties to normalize the 
encoding distance.  Each column should 
represent properties of the single amino acid/nucleotide. If <code>NULL</code>,
encoding distance is not normalized.</p>
</td></tr>
<tr><td><code id="calc_ed_+3A_measure">measure</code></td>
<td>
<p><code>character</code> vector of length one specifying the measure. 
Currently avaible measures are <code>"pi"</code> (partition index) and 
<code>"si"</code> (similarity index).
If the parameter <code>prop</code> is supplied, the encoding distance is normalized by the 
factor equal to the sum of distances for each group in <code>a</code> and the closest group 
in <code>b</code>. The position of a group is defined as the mean value of properties of 
amino acids or nucleotides belonging the group.
</p>
<p>See the package vignette for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an encoding distance.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_si">calc_si</a></code>: compute the similarity index of two encodings.
<code><a href="#topic+encoding2df">encoding2df</a></code>: converts an encoding to a data frame.
<code><a href="#topic+validate_encoding">validate_encoding</a></code>: validate a structure of an encoding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># calculate encoding distance between two encodings of amino acids
aa1 = list(`1` = c("g", "a", "p", "v", "m", "l", "i"), 
           `2` = c("k", "h"), 
           `3` = c("d", "e"), 
           `4` = c("f", "r", "w", "y", "s", "t", "c", "n", "q"))

aa2 = list(`1` = c("g", "a", "p", "v", "m", "l", "q"), 
           `2` = c("k", "h", "d", "e", "i"), 
           `3` = c("f", "r", "w", "y", "s", "t", "c", "n"))
calc_ed(aa1, aa2, measure = "pi") 
    
# the encoding distance between two identical encodings is 0
calc_ed(aa1, aa1, measure = "pi") 
</code></pre>

<hr>
<h2 id='calc_ig'>Calculate IG for single feature</h2><span id='topic+calc_ig'></span>

<h3>Description</h3>

<p>Computes information gain of single feature and target vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_ig(feature, target, len_target, pos_target)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_ig_+3A_feature">feature</code></td>
<td>
<p>feature vector.</p>
</td></tr>
<tr><td><code id="calc_ig_+3A_target">target</code></td>
<td>
<p>target.</p>
</td></tr>
<tr><td><code id="calc_ig_+3A_len_target">len_target</code></td>
<td>
<p>length of the target vector.</p>
</td></tr>
<tr><td><code id="calc_ig_+3A_pos_target">pos_target</code></td>
<td>
<p>number of positive cases in the target vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The information gain term is used here (improperly) as a synonym of mutual 
information. It is defined as:
</p>
<p style="text-align: center;"><code class="reqn">IG(X; Y) = \sum_{y \in Y} \sum_{x \in X} p(x, y) \log \left(\frac{p(x, y)}{p(x) p(y)}  \right)</code>
</p>

<p>In biogram package information gain is computed using following relationship: 
<code class="reqn">IG = E(S) - E(S|F)</code>
</p>


<h3>Value</h3>

<p>A <code>numeric</code> vector of length 1 representing information gain in nats.
</p>


<h3>Note</h3>

<p>During calculations <code class="reqn">0 \log 0  = 0</code>. For a justification see References. 
</p>
<p>The function was designed to be afast subroutine of 
<code><a href="#topic+calc_criterion">calc_criterion</a></code> and might be cumbersome if directly called by a user.
</p>


<h3>References</h3>

<p>Cover TM, Thomas JA <em>Elements of Information Theory, 2nd Edition</em>
Wiley, 2006.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar &lt;- sample(0L:1, 100, replace = TRUE)
feat &lt;- sample(0L:1, 100, replace = TRUE)
calc_ig(feat, tar, 100, sum(tar))
</code></pre>

<hr>
<h2 id='calc_kl'>Calculate KL divergence of features</h2><span id='topic+calc_kl'></span>

<h3>Description</h3>

<p>Computes Kullback-Leibler divergence between features and target vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_kl(feature, target, len_target, pos_target)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_kl_+3A_feature">feature</code></td>
<td>
<p>feature vector.</p>
</td></tr>
<tr><td><code id="calc_kl_+3A_target">target</code></td>
<td>
<p>target.</p>
</td></tr>
<tr><td><code id="calc_kl_+3A_len_target">len_target</code></td>
<td>
<p>length of the target vector.</p>
</td></tr>
<tr><td><code id="calc_kl_+3A_pos_target">pos_target</code></td>
<td>
<p>number of positive cases in the target vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> vector of length 1 representing Kullback-Leibler divergence 
value.
</p>


<h3>Note</h3>

<p>Both <code>target</code> and <code>features</code> must be binary, i.e. contain only 0 
and 1 values.
</p>
<p>The function was designed to be as fast as possible subroutine of 
<code><a href="#topic+calc_criterion">calc_criterion</a></code> and might be cumbersome if directly called by a user.
</p>


<h3>References</h3>

<p>Kullback S, Leibler RA <em>On information and sufficiency</em>. Annals
of Mathematical Statistics 22 (1):79-86, 1951.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+test_features">test_features</a></code>.
Kullback-Leibler divergence is calculated using <code><a href="entropy.html#topic+KL.plugin">KL.plugin</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar &lt;- sample(0L:1, 100, replace = TRUE)
feat &lt;- sample(0L:1, 100, replace = TRUE)
calc_kl(feat, tar, 100, sum(tar))
</code></pre>

<hr>
<h2 id='calc_pi'>Calculate partition index</h2><span id='topic+calc_pi'></span>

<h3>Description</h3>

<p>Computes the encoding distance between two encodings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_pi(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_pi_+3A_a">a</code></td>
<td>
<p>encoding (see <code><a href="#topic+validate_encoding">validate_encoding</a></code> for more information 
about the required structure of encoding).</p>
</td></tr>
<tr><td><code id="calc_pi_+3A_b">b</code></td>
<td>
<p>encoding to which <code>a</code> should be compared. Must have equal number 
of groups or less than <code>a</code>. Both <code>a</code> and b must have the the same 
number of elements.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The encoding distance between <code>a</code> and <code>b</code> is defined as the 
minimum number of amino acids that have to be moved between subgroups of encoding 
to make <code>a</code> identical to <code>b</code> (order of subgroups in the encoding and amino 
acids in a group is unimportant).
</p>
<p>If the parameter <code>prop</code> is supplied, the encoding distance is normalized by the 
factor equal to the sum of distances for each group in <code>a</code> and the closest group 
in <code>b</code>. The position of a group is defined as the mean value of properties of 
amino acids or nucleotides belonging the group.
</p>
<p>See the package vignette for more details.
</p>


<h3>Value</h3>

<p>an encoding distance.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_si">calc_si</a></code>: compute the similarity index of two encodings.
<code><a href="#topic+encoding2df">encoding2df</a></code>: converts an encoding to a data frame.
<code><a href="#topic+validate_encoding">validate_encoding</a></code>: validate a structure of an encoding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># calculate encoding distance between two encodings of amino acids
aa1 = list(`1` = c("g", "a", "p", "v", "m", "l", "i"), 
           `2` = c("k", "h"), 
           `3` = c("d", "e"), 
           `4` = c("f", "r", "w", "y", "s", "t", "c", "n", "q"))

aa2 = list(`1` = c("g", "a", "p", "v", "m", "l", "q"), 
           `2` = c("k", "h", "d", "e", "i"), 
           `3` = c("f", "r", "w", "y", "s", "t", "c", "n"))
calc_pi(aa1, aa2) 
    
# the encoding distance between two identical encodings is 0
calc_pi(aa1, aa1) 
 
</code></pre>

<hr>
<h2 id='calc_si'>Compute similarity index</h2><span id='topic+calc_si'></span>

<h3>Description</h3>

<p>Computes similarity index between two encodings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_si(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_si_+3A_a">a</code></td>
<td>
<p>encoding (see <code><a href="#topic+validate_encoding">validate_encoding</a></code> for more information 
about the required structure of encoding).</p>
</td></tr>
<tr><td><code id="calc_si_+3A_b">b</code></td>
<td>
<p>encoding to which <code>a</code> should be compared. Must have equal number 
of groups or less than <code>a</code>. Both <code>a</code> and b must have the the same 
number of elements.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Briefly, the similarity index is a fraction of elements that have 
the same pairing in both encodings. Pairing is a binary variable, that has 
value 1 if two elements are in the same group and 0 if not. For more details, 
see references.
</p>


<h3>Value</h3>

<p>the value of similarity index.
</p>


<h3>References</h3>

<p>Stephenson, J.D., and Freeland, S.J. (2013). Unearthing the Root 
of Amino Acid Similarity. J Mol Evol 77, 159-169.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_ed">calc_ed</a></code>: calculate the encoding distance between two encodings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example from Stephenson &amp; Freeland, 2013 (Fig. 6)
enc1 &lt;- list(`1` = "A",
             `2` = c("F", "E"),
             `3` = c("C", "D", "G"))

enc2 &lt;- list(`1` = c("A", "G"),
             `2` = c("C", "D", "E", "F"))

enc3 &lt;- list(`1` = c("D", "G"),
             `2` = c("E", "F"),
             `3` = c("A", "C"))
             
calc_si(enc1, enc2)
calc_si(enc2, enc3)
calc_si(enc1, enc3)
</code></pre>

<hr>
<h2 id='check_criterion'>Check chosen criterion</h2><span id='topic+check_criterion'></span>

<h3>Description</h3>

<p>Checks if the criterion is viable or matches it to the list of implemented
criterions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_criterion(input_criterion, criterion_names = c("ig", "kl", "cs"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_criterion_+3A_input_criterion">input_criterion</code></td>
<td>
<p><code>character</code> string, criterion from input.</p>
</td></tr>
<tr><td><code id="check_criterion_+3A_criterion_names">criterion_names</code></td>
<td>
<p>list of implemented criterions, always in lowercase.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of three:
</p>

<ul>
<li><p>criterion name,
</p>
</li>
<li><p>its function,
</p>
</li>
<li><p>nice name for outputs.
</p>
</li></ul>



<h3>See Also</h3>

<p>Calculate the value of criterion: <code><a href="#topic+calc_criterion">calc_criterion</a></code>.
</p>

<hr>
<h2 id='cluster_reg_exp'>Clustering of sequences based on regular expression</h2><span id='topic+cluster_reg_exp'></span>

<h3>Description</h3>

<p>Clusters sequences hierarchically with regular expressions.
At each step we minimize number of degrees of freedom for all regular
expressions needed to describe the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_reg_exp(ngrams)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_reg_exp_+3A_ngrams">ngrams</code></td>
<td>
<p>list of elements</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Regular expression is a list of the length equal to the length
of the input sequences. Each element of the list represents a position in 
the sequence and contains amino acid, that are likely to occure on this
position.
</p>


<h3>Value</h3>

<p>List of four
</p>

<ul>
<li><p>&quot;regExps&quot;regular expression in best clustering
</p>
</li>
<li><p>&quot;seqClustering&quot;clustering of sequences in best clustering
</p>
</li>
<li><p>&quot;allRegExps&quot;all regular expressions.
</p>
</li>
<li><p>&quot;allIndices&quot;all clusterings
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(human_cleave)
#cluster_reg_exp is computationally expensive

results &lt;- cluster_reg_exp(human_cleave[1L:10, 1L:4])

</code></pre>

<hr>
<h2 id='code_ngrams'>Code n-grams</h2><span id='topic+code_ngrams'></span>

<h3>Description</h3>

<p>Code human-friendly representation of n-grams into a biogram format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>code_ngrams(decoded_ngrams)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="code_ngrams_+3A_decoded_ngrams">decoded_ngrams</code></td>
<td>
<p>a <code>character</code> vector of decoded n-grams.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>character</code> vector of n-grams.
</p>


<h3>See Also</h3>

<p>Inverse function: <code><a href="#topic+decode_ngrams">decode_ngrams</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>code_ngrams(c("11_2", "1__12", "222"))
code_ngrams(c("aaa_b", "d__aa", "abd"))
</code></pre>

<hr>
<h2 id='construct_ngrams'>Construct and filter n-grams</h2><span id='topic+construct_ngrams'></span>

<h3>Description</h3>

<p>Builds and selects important n-grams stepwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_ngrams(
  target,
  seq,
  u,
  n_max,
  conf_level = 0.95,
  gap = TRUE,
  use_heuristics = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_ngrams_+3A_target">target</code></td>
<td>
<p><code>integer</code> vector with target information (e.g. class labels).</p>
</td></tr>
<tr><td><code id="construct_ngrams_+3A_seq">seq</code></td>
<td>
<p>a vector or matrix describing sequence(s).</p>
</td></tr>
<tr><td><code id="construct_ngrams_+3A_u">u</code></td>
<td>
<p><code>integer</code>, <code>numeric</code> or <code>character</code> vector of all
possible unigrams.</p>
</td></tr>
<tr><td><code id="construct_ngrams_+3A_n_max">n_max</code></td>
<td>
<p>size of constructed n-grams.</p>
</td></tr>
<tr><td><code id="construct_ngrams_+3A_conf_level">conf_level</code></td>
<td>
<p>confidence level.</p>
</td></tr>
<tr><td><code id="construct_ngrams_+3A_gap">gap</code></td>
<td>
<p><code>logical</code>, if <code>TRUE</code> gaps are used. See Details.</p>
</td></tr>
<tr><td><code id="construct_ngrams_+3A_use_heuristics">use_heuristics</code></td>
<td>
<p>if <code>FALSE</code> then all n-grams are tested. This may
slow down computations significantly</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>construct_ngrams</code> starts by 
extracting unigrams from the sequences, pasting them together in all combination and 
choosing from them significant features (with p-value below <code>conf_level</code>). The 
chosen n-grams are further extended to the specified by <code>n_max</code> size by pasting 
unigrams at both ends.
</p>
<p>The <code>gap</code> parameter determines if <code>construct_ngrams</code> performs the
feature selection on exact n-grams (<code>gap</code> equal to FALSE) or on all features in the 
Hamming distance 1 from the n-gram (<code>gap</code> equal to TRUE).
</p>


<h3>Value</h3>

<p>a vector of n-grams.
</p>


<h3>See Also</h3>

<p>Feature filtering method: <code><a href="#topic+test_features">test_features</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># to make the example faster, we run construct_ngrams() on the 
# subset of data
deg_seqs &lt;- degenerate(human_cleave[c(1L:100, 801L:900), 1L:9],
list(`1` = c(1, 6, 8, 10, 11, 18),
     `2` = c(2, 13, 14, 16, 17),
     `3` = c(5, 19, 20),
     `4` = c(7, 9, 12, 15),
     '5' = c(3, 4)))
bigrams &lt;- construct_ngrams(human_cleave[c(1L:100, 801L:900), "tar"], deg_seqs, 1L:5, 2)
</code></pre>

<hr>
<h2 id='count_multigrams'>Detect and count multiple n-grams in sequences</h2><span id='topic+count_multigrams'></span>

<h3>Description</h3>

<p>A convinient wrapper around <code><a href="#topic+count_ngrams">count_ngrams</a></code> for counting multiple
values of <code>n</code> and <code>d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_multigrams(
  ns,
  ds = rep(0, length(ns)),
  seq,
  u,
  pos = FALSE,
  scale = FALSE,
  threshold = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_multigrams_+3A_ns">ns</code></td>
<td>
<p><code>numeric</code> vector of n-grams' sizes. See Details.</p>
</td></tr>
<tr><td><code id="count_multigrams_+3A_ds">ds</code></td>
<td>
<p><code>list</code> of distances between elements of n-grams. Each element of the list
is a vector used as distance for the respective n-gram size given by the <code>ns</code>
parameter.</p>
</td></tr>
<tr><td><code id="count_multigrams_+3A_seq">seq</code></td>
<td>
<p>a vector or matrix describing sequence(s).</p>
</td></tr>
<tr><td><code id="count_multigrams_+3A_u">u</code></td>
<td>
<p><code>integer</code>, <code>numeric</code> or <code>character</code> vector of all
possible unigrams.</p>
</td></tr>
<tr><td><code id="count_multigrams_+3A_pos">pos</code></td>
<td>
<p><code>logical</code>, if <code>TRUE</code> position-specific n_grams are counted.</p>
</td></tr>
<tr><td><code id="count_multigrams_+3A_scale">scale</code></td>
<td>
<p><code>logical</code>, if <code>TRUE</code> output data is normalized. May be
applied only to the counts of n-grams without position information. See <code>Details</code>.</p>
</td></tr>
<tr><td><code id="count_multigrams_+3A_threshold">threshold</code></td>
<td>
<p><code>integer</code>, if not equal to 0, data is binarized into
two groups (larger or equal to threshold vs. smaller than threshold).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ns</code> vector and <code>ds</code> vector must have equal length. Elements of 
<code>ds</code> vector are used as equivalents of <code>d</code> parameter for respective values 
of <code>ns</code>. For example, if <code>ns</code> is <code>c(4, 4, 4)</code>, the <code>ds</code> must be a list of 
length 3. Each element of the <code>ds</code> list must have length 3 or 1, as appropriate
for a <code>d</code> parameter in <code>count_ngrams</code> function.
</p>


<h3>Value</h3>

<p>An <code>integer</code> matrix with named columns. The naming conventions are the same
as in <code><a href="#topic+count_ngrams">count_ngrams</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seqs &lt;- matrix(sample(1L:4, 600, replace = TRUE), ncol = 50)
count_multigrams(c(3, 1), list(c(1, 0), 0), seqs, 1L:4, pos = TRUE)
# if ds parameter is not present, n-grams are calculated for distance 0
count_multigrams(c(3, 1), seq = seqs, u = 1L:4)

# calculate three times n-gram with the same length, but different distances between
# elements
count_multigrams(c(4, 4, 4), list(c(2, 0, 1), c(2, 1, 0), c(0, 1, 2)), 
                 seqs, 1L:4, pos = TRUE)
</code></pre>

<hr>
<h2 id='count_ngrams'>Count n-grams in sequences</h2><span id='topic+count_ngrams'></span>

<h3>Description</h3>

<p>Counts all n-grams or position-specific n-grams present in the input sequence(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_ngrams(seq, n, u, d = 0, pos = FALSE, scale = FALSE, threshold = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_ngrams_+3A_seq">seq</code></td>
<td>
<p>a vector or matrix describing sequence(s).</p>
</td></tr>
<tr><td><code id="count_ngrams_+3A_n">n</code></td>
<td>
<p><code>integer</code> size of n-gram.</p>
</td></tr>
<tr><td><code id="count_ngrams_+3A_u">u</code></td>
<td>
<p><code>integer</code>, <code>numeric</code> or <code>character</code> vector of all
possible unigrams.</p>
</td></tr>
<tr><td><code id="count_ngrams_+3A_d">d</code></td>
<td>
<p><code>integer</code> vector of distances between elements of n-gram (0 means 
consecutive elements). See Details.</p>
</td></tr>
<tr><td><code id="count_ngrams_+3A_pos">pos</code></td>
<td>
<p><code>logical</code>, if <code>TRUE</code> position-specific n_grams are counted.</p>
</td></tr>
<tr><td><code id="count_ngrams_+3A_scale">scale</code></td>
<td>
<p><code>logical</code>, if <code>TRUE</code> output data is normalized. May be
applied only to the counts of n-grams without position information. See <code>Details</code>.</p>
</td></tr>
<tr><td><code id="count_ngrams_+3A_threshold">threshold</code></td>
<td>
<p><code>integer</code>, if not equal to 0, data is binarized into
two groups (larger or equal to threshold vs. smaller than threshold).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>distance</code> vector should be always <code>n</code> - 1 in length.
For example when <code>n</code> = 3, <code>d</code> = c(1,2) means A_A__A. For <code>n</code> = 4, 
<code>d</code> = c(2,0,1) means A__AA_A. If vector <code>d</code> has length 1, it is recycled to
length <code>n</code> - 1.
</p>
<p>n-gram names follow a specific convention and have three parts for position-specific
n-grams and two parts otherwise. The parts are separated by <code>_</code>. The <code>.</code> symbol
is used to separate elements within a part. The general naming scheme is 
<code>POSITION_NGRAM_DISTANCE</code>. The optional <code>POSITION</code> part of the name indicates
the actual position of the n-gram in the sequence(s) and will be present 
only if <code>pos</code> = <code>TRUE</code>. This part is always a single integer. The <code>NGRAM</code>
part of the name is a sequence of elements in the n-gram. For example, <code>4.2.2</code>
indicates the n-gram 422 (e.g. TCC). The <code>DISTANCE</code> part of the name is a vector of
distance(s). For example, <code>0.0</code> indicates zero distances (continuous n-grams), while
<code>1.2</code> represents distances for the n-gram A_A__A.
</p>
<p>Examples of n-gram names:
</p>

<ul>
<li><p>46_4.4.4_0.1 : trigram 44_4 on position 46
</p>
</li>
<li><p>12_2.1_2     : bigram 2__1 on position 12
</p>
</li>
<li><p>8_1.1.1_0.0  : continuous trigram 111 on position 8
</p>
</li>
<li><p>1.1.1_0.0    : continuous trigram 111 without position information
</p>
</li></ul>



<h3>Value</h3>

<p>a <code><a href="slam.html#topic+simple_triplet_matrix">simple_triplet_matrix</a></code> where columns represent
n-grams and rows sequences. See <code>Details</code> for specifics of the naming convention.
</p>


<h3>Note</h3>

<p>By default, the counted n-gram data is stored in a memory-saving format.
To convert an object to a 'classical' matrix use the <code><a href="base.html#topic+as.matrix">as.matrix</a></code>
function. See examples for further information.
</p>


<h3>See Also</h3>

<p>Create vector of possible n-grams: <code><a href="#topic+create_ngrams">create_ngrams</a></code>.
</p>
<p>Extract n-grams from sequence(s): <code><a href="#topic+seq2ngrams">seq2ngrams</a></code>.
</p>
<p>Get indices of n-grams: <code><a href="#topic+get_ngrams_ind">get_ngrams_ind</a></code>.
</p>
<p>Count n-grams for multiple values of n: <code><a href="#topic+count_multigrams">count_multigrams</a></code>.
</p>
<p>Count only specified n-grams: <code><a href="#topic+count_specified">count_specified</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># count trigrams without position information for nucleotides
count_ngrams(sample(1L:4, 50, replace = TRUE), 3, 1L:4, pos = FALSE)
# count position-specific trigrams from multiple nucleotide sequences
seqs &lt;- matrix(sample(1L:4, 600, replace = TRUE), ncol = 50)
ngrams &lt;- count_ngrams(seqs, 3, 1L:4, pos = TRUE)
# output results of the n-gram counting to screen
as.matrix(ngrams)
</code></pre>

<hr>
<h2 id='count_specified'>Count specified n-grams</h2><span id='topic+count_specified'></span>

<h3>Description</h3>

<p>Counts specified n-grams in the input sequence(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_specified(seq, ngrams)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_specified_+3A_seq">seq</code></td>
<td>
<p>vector or matrix describing sequence(s).</p>
</td></tr>
<tr><td><code id="count_specified_+3A_ngrams">ngrams</code></td>
<td>
<p>vector of n-grams.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+count_specified">count_specified</a></code> counts only selected n-grams declared by
user in the <code>ngrams</code> parameter. Declared n-grams must be written using the
<code>biogram</code> notation.
</p>


<h3>Value</h3>

<p>A <code><a href="slam.html#topic+simple_triplet_matrix">simple_triplet_matrix</a></code> where columns represent
n-grams and rows sequences.
</p>


<h3>See Also</h3>

<p>Count all possible n-grams: <code><a href="#topic+count_ngrams">count_ngrams</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seqs &lt;- matrix(c(1, 2, 2, 1, 2, 1, 2, 1, 1, 2, 3, 4, 1, 2, 2, 4), nrow = 2)
count_specified(seqs, ngrams = c("1.1.1_0.0", "2.2.2_0.0", "1.1.2_0.0"))

seqs &lt;- matrix(sample(1L:5, 200, replace = TRUE), nrow = 20)
count_specified(seqs, ngrams = c("2_4.2_0", "2_1.4_0", "3_1.3_0",
                                 "2_4.2_1", "2_1.4_1", "3_1.3_1",
                                 "2_4.2_2", "2_1.4_2", "3_1.3_2"))
</code></pre>

<hr>
<h2 id='count_total'>Count total number of n-grams</h2><span id='topic+count_total'></span>

<h3>Description</h3>

<p>Computes total number of n-grams that can be extracted from sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_total(seq, n, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_total_+3A_seq">seq</code></td>
<td>
<p>a vector or matrix describing sequence(s).</p>
</td></tr>
<tr><td><code id="count_total_+3A_n">n</code></td>
<td>
<p><code>integer</code> size of n-gram.</p>
</td></tr>
<tr><td><code id="count_total_+3A_d">d</code></td>
<td>
<p><code>integer</code> vector of distances between elements of n-gram (0 means 
consecutive elements). See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The maximum number of possible n-grams is limited by their length 
and the distance between elements of the n-gram.
</p>


<h3>Value</h3>

<p>An <code>integer</code> rperesenting the total number of n-grams.
</p>


<h3>Note</h3>

<p>A format of <code>d</code> vector is discussed in Details of 
<code><a href="#topic+count_ngrams">count_ngrams</a></code>. The maximum
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seqs &lt;- matrix(sample(1L:4, 600, replace = TRUE), ncol = 50)
# make several sequences shorter by replacing them partially with NA
seqs[8L:11, 46L:50] &lt;- NA
seqs[1L, 31L:50] &lt;- NA
count_total(seqs, 3, c(1, 0))
</code></pre>

<hr>
<h2 id='create_encoding'>Create encoding</h2><span id='topic+create_encoding'></span>

<h3>Description</h3>

<p>Reduces an alphabet using physicochemical properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_encoding(prop, len)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_encoding_+3A_prop">prop</code></td>
<td>
<p><code>matrix</code> of properties with number of column equal to the 
length of the alphabet. Column must be named after elements of the 
alphabet. Each row represents a different physicochemical property.</p>
</td></tr>
<tr><td><code id="create_encoding_+3A_len">len</code></td>
<td>
<p>length of the resulting encoding. Must be larger than zero and 
smaller than number of elements in the alphabet.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The encoding is a list of groups to which elements of an alphabet 
should be reduced. All elements of the alphabet (all 
amino acids or all nucleotides) should appear in the encoding.
</p>


<h3>Value</h3>

<p>An encoding.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_ed">calc_ed</a></code>: calculate the encoding distance between two encodings.
<code><a href="#topic+encoding2df">encoding2df</a></code>: converts an encoding to a data frame.
<code><a href="#topic+validate_encoding">validate_encoding</a></code>: validate a structure of an encoding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>enc1 = list(`1` = c("a", "t"), 
            `2` = c("g", "c"))
encoding2df(enc1)
</code></pre>

<hr>
<h2 id='create_feature_target'>Create feature according to given contingency matrix</h2><span id='topic+create_feature_target'></span>

<h3>Description</h3>

<p>Creates a matrix of features and target based on the values from contingency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_feature_target(n11, n01, n10, n00)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_feature_target_+3A_n11">n11</code></td>
<td>
<p>number of elements for which both target and feature equal 1.</p>
</td></tr>
<tr><td><code id="create_feature_target_+3A_n01">n01</code></td>
<td>
<p>number of elements for which target and feature equal 1,0 
respectively.</p>
</td></tr>
<tr><td><code id="create_feature_target_+3A_n10">n10</code></td>
<td>
<p>number of elements for which target and feature equal 0,1 
respectively.</p>
</td></tr>
<tr><td><code id="create_feature_target_+3A_n00">n00</code></td>
<td>
<p>number of elements for which both target and feature equal 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of 2 columns and n11+n10+n01+n00 rows. Columns represent
target and feature vectors, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># equivalent of 
#         target
# feature 10 375
#        15 600
target_feature &lt;- create_feature_target(10, 375, 15, 600)
</code></pre>

<hr>
<h2 id='create_ngrams'>Get all possible n-Grams</h2><span id='topic+create_ngrams'></span>

<h3>Description</h3>

<p>Creates the vector of all possible n_grams (for given <code>n</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_ngrams(n, u, possible_grams = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_ngrams_+3A_n">n</code></td>
<td>
<p><code>integer</code> size of n-gram.</p>
</td></tr>
<tr><td><code id="create_ngrams_+3A_u">u</code></td>
<td>
<p><code>integer</code>, <code>numeric</code> or <code>character</code> vector of all
possible unigrams.</p>
</td></tr>
<tr><td><code id="create_ngrams_+3A_possible_grams">possible_grams</code></td>
<td>
<p>number of possible n-grams. If not <code>NULL</code> n-grams do not
contain information about position</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Details section of <code><a href="#topic+count_ngrams">count_ngrams</a></code> for more 
information about n-grams naming convention. The possible information about distance 
must be added by hand (see examples).
</p>


<h3>Value</h3>

<p>a character vector. Elements of n-gram are separated by dot.
</p>


<h3>Note</h3>

<p>Input data must be a matrix or data frame of numeric elements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># bigrams for standard aminoacids
create_ngrams(2, 1L:20)
# bigrams for standard aminoacids with positions, 10 amino acid long sequence, so 
# only 9 bigrams can be located in sequence
create_ngrams(2, 1L:20, 9)
# bigrams for DNA with positions, 10 nucleotide long sequence, distance 1, so only 
# 8 bigrams in sequence
# paste0 adds information about distance at the end of n-gram
paste0(create_ngrams(2, 1L:4, 8), "_0")
</code></pre>

<hr>
<h2 id='criterion_distribution'>criterion_distribution class</h2><span id='topic+criterion_distribution'></span>

<h3>Description</h3>

<p>A result of <code><a href="#topic+distr_crit">distr_crit</a></code> function.
</p>


<h3>Details</h3>

<p>An object of class <code>criterion_distribution</code> is a numeric matrix.
</p>


<h3>Data</h3>


<dl>
<dt>1st column:</dt><dd><p>possible values of criterion.</p>
</dd>
<dt>2nd column:</dt><dd><p>probability density function.</p>
</dd>
<dt>3rd column:</dt><dd><p>cumulative distribution function.</p>
</dd>
</dl>



<h3>Attributes</h3>


<dl>
<dt>plot_data</dt><dd><p>A matrix with values of the criterion and their probabilities.</p>
</dd>
<dt>nice_name</dt><dd><p>'Nice' name of the criterion.</p>
</dd>
</dl>


<hr>
<h2 id='cut.feature_test'>Categorize tested features</h2><span id='topic+cut.feature_test'></span>

<h3>Description</h3>

<p>Categorizes results of <code><a href="#topic+test_features">test_features</a></code> function into groups based on their 
significance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'feature_test'
cut(x, split = "significances", breaks = c(0, 1e-04, 0.01, 0.05, 1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut.feature_test_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+feature_test">feature_test</a></code>.</p>
</td></tr>
<tr><td><code id="cut.feature_test_+3A_split">split</code></td>
<td>
<p>attribute along which output should be categorized. Possible values are
<code>"significances"</code>, <code>"positives"</code> and <code>"negatives"</code>. See <code>Value</code>.</p>
</td></tr>
<tr><td><code id="cut.feature_test_+3A_breaks">breaks</code></td>
<td>
<p>a vector of significances of frequencies along which n-grams are aggregated. 
See description of <code><a href="base.html#topic+cut">cut</a></code> function and <code>Details</code>.</p>
</td></tr>
<tr><td><code id="cut.feature_test_+3A_...">...</code></td>
<td>
<p>further parameters accepted by the <code><a href="base.html#topic+cut">cut</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of function depends on the <code>split</code> parameter. 
The function returns a named list of length equal to the length 
of <code>significances</code> (when <code>split</code> equals <code>"significances"</code>) or 
<code>frequencies</code> (when <code>split</code> equals <code>"positives"</code> or <code>"negatives"</code>)
minus one. Each elements of the list contains names of the n-grams belonging to the given 
significance or frequency group.
</p>

<hr>
<h2 id='decode_ngrams'>Decode n-grams</h2><span id='topic+decode_ngrams'></span>

<h3>Description</h3>

<p>Transforms a vector of n-grams into a human-friendly form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decode_ngrams(ngrams)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decode_ngrams_+3A_ngrams">ngrams</code></td>
<td>
<p>a <code>character</code> vector of n-grams.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>character</code> vector of length equal to the number of n-grams.
</p>


<h3>Note</h3>

<p>Decoded n-grams lose the position information.
</p>


<h3>See Also</h3>

<p>Validate n-gram structure: <code><a href="#topic+is_ngram">is_ngram</a></code>.
</p>
<p>Inverse function: <code><a href="#topic+code_ngrams">code_ngrams</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>decode_ngrams(c("2_1.1.2_0.1", "3_1.1.2_2.0", "3_2.2.2_0.0"))
</code></pre>

<hr>
<h2 id='degenerate'>Degenerate protein sequence</h2><span id='topic+degenerate'></span>

<h3>Description</h3>

<p>'Degenerates' amino acid or nucleic sequence by aggregating 
elements to bigger groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degenerate(seq, element_groups)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degenerate_+3A_seq">seq</code></td>
<td>
<p><code>character</code> vector or matrix representing single sequence.</p>
</td></tr>
<tr><td><code id="degenerate_+3A_element_groups">element_groups</code></td>
<td>
<p>encoding of elements: list of groups to which elements 
of sequence should be aggregated. Must have unique names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> vector or matrix (if input is a matrix) 
containing aggregated elements.
</p>


<h3>Note</h3>

<p>Characters not present in the <code>element_groups</code> will be converted to NA with a 
warning.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+l2n">l2n</a></code> to easily convert information stored in biological sequences from 
letters to numbers.
<code><a href="#topic+calc_ed">calc_ed</a></code> to calculate distance between encodings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample_seq &lt;- c(1, 3, 1, 3, 4, 4, 3, 1, 2)
table(sample_seq)

# aggregate sequence to purins and pyrimidines
deg_seq &lt;- degenerate(sample_seq, list(w = c(1, 4), s = c(2, 3)))
table(deg_seq)
</code></pre>

<hr>
<h2 id='degenerate_ngrams'>Degenerate n-grams</h2><span id='topic+degenerate_ngrams'></span>

<h3>Description</h3>

<p>'Degenerates' n-grams by aggregating amino acid or nucleotide elements
into bigger groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degenerate_ngrams(x, element_groups, binarize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degenerate_ngrams_+3A_x">x</code></td>
<td>
<p>object containing n-grams.</p>
</td></tr>
<tr><td><code id="degenerate_ngrams_+3A_element_groups">element_groups</code></td>
<td>
<p>encoding of elements: list of groups to which elements 
of n-grams should be aggregated. Must have unique names.</p>
</td></tr>
<tr><td><code id="degenerate_ngrams_+3A_binarize">binarize</code></td>
<td>
<p>logical indicating if n-grams should be binarized</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> vector or matrix (if input is a matrix) 
containing degenerated n-grams.
</p>

<hr>
<h2 id='distr_crit'>Compute criterion distribution</h2><span id='topic+distr_crit'></span>

<h3>Description</h3>

<p>Computes criterion distribution under null hypothesis for all contingency 
tables possible for a feature and a target.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distr_crit(target, feature, criterion = "ig", iter_limit = 200)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distr_crit_+3A_target">target</code></td>
<td>
<p>{0,1}-valued target vector. See Details.</p>
</td></tr>
<tr><td><code id="distr_crit_+3A_feature">feature</code></td>
<td>
<p>{0,1}-valued feature vector. See Details.</p>
</td></tr>
<tr><td><code id="distr_crit_+3A_criterion">criterion</code></td>
<td>
<p>criterion used for calculations of distribution. 
See <code><a href="#topic+calc_criterion">calc_criterion</a></code> for the list of avaible criteria.</p>
</td></tr>
<tr><td><code id="distr_crit_+3A_iter_limit">iter_limit</code></td>
<td>
<p>limit the number of calculated contingence matrices. If
<code>NULL</code>, computes all possible contingence matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>both <code>target</code> and <code>feature</code> vectors may contain only 0 
and 1.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+criterion_distribution">criterion_distribution</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_criterion">calc_criterion</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>target_feature &lt;- create_feature_target(10, 375, 15, 600) 
distr_crit(target = target_feature[,1], feature = target_feature[,2])
</code></pre>

<hr>
<h2 id='encoding2df'>Convert encoding to data frame</h2><span id='topic+encoding2df'></span>

<h3>Description</h3>

<p>Converts an encoding to a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encoding2df(x, sort = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encoding2df_+3A_x">x</code></td>
<td>
<p>encoding.</p>
</td></tr>
<tr><td><code id="encoding2df_+3A_sort">sort</code></td>
<td>
<p>if <code>TRUE</code> rows are sorted according to elements.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The encoding is a list of groups to which elements of an alphabet 
should be reduced. All elements of the alphabet (all 
amino acids or all nucleotides) should appear in the encoding.
</p>


<h3>Value</h3>

<p>data frame with two columns. First column represents an index of a 
group in the supplied encoding and the second column contains all elements of 
the encoding.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_ed">calc_ed</a></code>: calculate the encoding distance between two encodings.
<code><a href="#topic+encoding2df">encoding2df</a></code>: converts an encoding to a data frame.
<code><a href="#topic+validate_encoding">validate_encoding</a></code>: validate a structure of an encoding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>create_encoding(aaprop[1L:5, ], 5)
</code></pre>

<hr>
<h2 id='fast_crosstable'>2d cross-tabulation</h2><span id='topic+fast_crosstable'></span>

<h3>Description</h3>

<p>Quickly cross-tabulates two binary vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_crosstable(target, len_target, pos_target, feature)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast_crosstable_+3A_target">target</code></td>
<td>
<p>target.</p>
</td></tr>
<tr><td><code id="fast_crosstable_+3A_len_target">len_target</code></td>
<td>
<p>length of the target vector.</p>
</td></tr>
<tr><td><code id="fast_crosstable_+3A_pos_target">pos_target</code></td>
<td>
<p>number of positive cases in the target vector.</p>
</td></tr>
<tr><td><code id="fast_crosstable_+3A_feature">feature</code></td>
<td>
<p>feature vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input looks odd, but the function was build to be fast
subroutine of <code><a href="#topic+calc_ig">calc_ig</a></code>, which works on
many features but only one target.
</p>


<h3>Value</h3>

<p>a vector of length four: 
</p>

<ol>
<li><p> target +, feature+
</p>
</li>
<li><p> target +, feature-
</p>
</li>
<li><p> target -, feature+
</p>
</li>
<li><p> target -, feature-
</p>
</li></ol>



<h3>Note</h3>

<p>Binary vector means a numeric vector with 0 or 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar &lt;- sample(0L:1, 100, replace = TRUE)
feat &lt;- sample(0L:1, 100, replace = TRUE)
fast_crosstable(tar, length(tar), sum(tar),  feat)
</code></pre>

<hr>
<h2 id='feature_test'>feature_test class</h2><span id='topic+feature_test'></span>

<h3>Description</h3>

<p>A result of <code><a href="#topic+test_features">test_features</a></code> function.
</p>


<h3>Details</h3>

<p>An object of the <code>feature_test</code> class is a numeric vector of p-values. 
Additional attributes characterizes futher the details of test which returned these 
p-values.
</p>


<h3>Attributes</h3>


<dl>
<dt>criterion</dt><dd><p>the criterion used in permutation test.</p>
</dd>
<dt>adjust</dt><dd><p>the name of p-value adjusting method.</p>
</dd>
<dt>times</dt><dd><p>the number of permutations.  If QuiPT was chosen <code>NA</code>.</p>
</dd>
<dt>occ</dt><dd><p>frequency of features splitted in subset based on the value of target.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Methods: 
</p>

<ul>
<li> <p><code><a href="#topic+as.data.frame.feature_test">as.data.frame.feature_test</a></code>
</p>
</li>
<li> <p><code><a href="#topic+cut.feature_test">cut.feature_test</a></code>
</p>
</li>
<li> <p><code><a href="#topic+print.feature_test">print.feature_test</a></code>
</p>
</li>
<li> <p><code><a href="#topic+summary.feature_test">summary.feature_test</a></code>
</p>
</li></ul>


<hr>
<h2 id='full2simple'>Convert encoding from full to simple format</h2><span id='topic+full2simple'></span>

<h3>Description</h3>

<p>Converts an encoding from the full format to the simple format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>full2simple(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="full2simple_+3A_x">x</code></td>
<td>
<p>encoding.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>aa1 = list(`1` = c("g", "a", "p", "v", "m", "l", "i"), 
           `2` = c("k", "h"), 
           `3` = c("d", "e"), 
           `4` = c("f", "r", "w", "y", "s", "t", "c", "n", "q"))
full2simple(aa1)

</code></pre>

<hr>
<h2 id='gap_ngrams'>Gap n-grams</h2><span id='topic+gap_ngrams'></span>

<h3>Description</h3>

<p>Introduces gaps in the n-grams.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gap_ngrams(ngrams)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gap_ngrams_+3A_ngrams">ngrams</code></td>
<td>
<p>a vector of positioned n-grams (as created by <code><a href="#topic+count_ngrams">count_ngrams</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A single element of the input n-gram at a time will be replaced 
by a gap. For example, introducing gaps in n-gram <code>2_1.1.2_0.1</code> 
will results in three n-grams: <code>3_1.2_1</code> (where the <code>2_1_0</code> unigram 
was replaced by a gap), <code>2_1.2_2</code> and <code>2_1.1_0</code>.
</p>


<h3>Value</h3>

<p>A <code>character</code> vector of (n-1)-grams with introduced gaps.
</p>


<h3>See Also</h3>

<p>Reverse function: <code><a href="#topic+add_1grams">add_1grams</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gap_ngrams(c("2_1.1.2_0.1", "3_1.1.2_0.0", "3_2.2.2_0.0"))
gap_ngrams(c("1.1.2_0.1", "1.1.2_0.0", "2.2.2_0.0"))
</code></pre>

<hr>
<h2 id='generate_sequence'>Generate sequence</h2><span id='topic+generate_sequence'></span>

<h3>Description</h3>

<p>Generate a sequences using an alphabet of unigrams and set of rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_sequence(alphabet, regions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_sequence_+3A_alphabet">alphabet</code></td>
<td>
<p>the unigram alphabet. Columns are equivalent to unigrams 
and rows to particular properties.</p>
</td></tr>
<tr><td><code id="generate_sequence_+3A_regions">regions</code></td>
<td>
<p>a list of rules describing regions.</p>
</td></tr>
</table>

<hr>
<h2 id='generate_single_region'>Generate single region</h2><span id='topic+generate_single_region'></span>

<h3>Description</h3>

<p>Generate a region using an alphabet of unigrams and considering provided 
set of rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_single_region(alphabet, reg_len, prop_ranges, exactness)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_single_region_+3A_alphabet">alphabet</code></td>
<td>
<p>the unigram alphabet. Columns are equivalent to unigrams 
and rows to particular properties.</p>
</td></tr>
<tr><td><code id="generate_single_region_+3A_reg_len">reg_len</code></td>
<td>
<p>the number of unigrams inside the region.</p>
</td></tr>
<tr><td><code id="generate_single_region_+3A_prop_ranges">prop_ranges</code></td>
<td>
<p>required intervals of properties of unigrams in the region. 
See Details.</p>
</td></tr>
<tr><td><code id="generate_single_region_+3A_exactness">exactness</code></td>
<td>
<p>a <code>numeric</code> value between 0 and 1 defining how stricly 
unigrams are kept within <code>prop_ranges</code>. If 1, only unigrams within 
<code>prop_ranges</code> are inside the region. if 0.9, there is 10
unigrams that are not in the <code>prop_ranges</code> will be inside the region.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>props1 &lt;- list(P1 = c(0, 0.5), 
               P2 = c(0.2, 0.4),
               P3 = c(0.5, 1),
               P4 = c(0, 0))

props2 &lt;- list(P1 = c(0.5, 1), 
               P2 = c(0.4, 1),
               P3 = c(0, 0.5),
               P4 = c(1, 1))


alph &lt;- generate_unigrams(c(replicate(8, props1, simplify = FALSE),
                            replicate(12, props2, simplify = FALSE)),
                          unigram_names = letters[1L:20])

rules1 &lt;- list(P1 = c(0.5, 1), 
               P2 = c(0.4, 1),
               P3 = c(0, 0.5),
               P4 = c(1, 1))

generate_single_region(alph, 10, rules1, 0.9)
</code></pre>

<hr>
<h2 id='generate_single_unigram'>Generate single unigram</h2><span id='topic+generate_single_unigram'></span>

<h3>Description</h3>

<p>Assign randomly generated properties to a single unigram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_single_unigram(unigram_ranges)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_single_unigram_+3A_unigram_ranges">unigram_ranges</code></td>
<td>
<p>list of ranges containing respective properties. If named, 
names are preserved.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>generate_single_unigram</code> is a helper function for 
<code><a href="#topic+generate_unigrams">generate_unigrams</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>generate_single_unigram(list(P1 = c(0, 0.5), 
                             P2 = c(0.2, 0.4),
                             P3 = c(0.5, 1),
                             P4 = c(0, 0)))

</code></pre>

<hr>
<h2 id='generate_unigrams'>Generate unigrams</h2><span id='topic+generate_unigrams'></span>

<h3>Description</h3>

<p>Generates an alphabet of unigrams based on given list of properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_unigrams(unigram_list, unigram_names = NULL, prop_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_unigrams_+3A_unigram_list">unigram_list</code></td>
<td>
<p>a list of unigrams' parameters. See Details.</p>
</td></tr>
<tr><td><code id="generate_unigrams_+3A_unigram_names">unigram_names</code></td>
<td>
<p>names of unigrams. If not <code>NULL</code>, will
overwrite any existing unigram names.</p>
</td></tr>
<tr><td><code id="generate_unigrams_+3A_prop_names">prop_names</code></td>
<td>
<p>names of properties. If not <code>NULL</code>, will 
overwrite any existing names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unigram parameters are represented as a list of intervals, where 
each interval corresponds to a different property. The function generate 
unigrams randomly choosing values of properties from given intervals 
using uniform distribution. All lists of ranges should have the same length, 
which equils to describing each unigram using the same properties.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>props1 &lt;- list(P1 = c(0, 0.5), 
               P2 = c(0.2, 0.4),
               P3 = c(0.5, 1),
               P4 = c(0, 0))

props2 &lt;- list(P1 = c(0.5, 1), 
               P2 = c(0.4, 1),
               P3 = c(0, 0.5),
               P4 = c(1, 1))


alph &lt;- generate_unigrams(c(replicate(8, props1, simplify = FALSE),
                          replicate(12, props2, simplify = FALSE)),
                          unigram_names = letters[1L:20])
                          
</code></pre>

<hr>
<h2 id='get_ngrams_ind'>Get indices of n-grams</h2><span id='topic+get_ngrams_ind'></span>

<h3>Description</h3>

<p>Computes list of n-gram elements positions in sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ngrams_ind(len_seq, n, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ngrams_ind_+3A_len_seq">len_seq</code></td>
<td>
<p><code>integer</code> value describing sequence's length.</p>
</td></tr>
<tr><td><code id="get_ngrams_ind_+3A_n">n</code></td>
<td>
<p><code>integer</code> size of n-gram.</p>
</td></tr>
<tr><td><code id="get_ngrams_ind_+3A_d">d</code></td>
<td>
<p><code>integer</code> vector of distances between elements of n-gram (0 means 
consecutive elements). See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A format of <code>d</code> vector is discussed in Details of 
<code><a href="#topic+count_ngrams">count_ngrams</a></code>.
</p>


<h3>Value</h3>

<p>A list with number of elements equal to <code>n</code>. Every element is a 
vector containing locations of given n-gram letter. For example, first element of
list contain indices of first letter of all n-grams. The attribute <code>d</code>
of output contains distances between letter used to compute locations 
(see Details).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># positions trigrams in sequence of length 10
get_ngrams_ind(10, 9, 0)
</code></pre>

<hr>
<h2 id='human_cleave'>Human signal peptides cleavage sites</h2><span id='topic+human_cleave'></span>

<h3>Description</h3>

<p>A set of 648 cleavage sites and 648 parts of mature proteins shortly after cleavage sites 
derived from human proteome.
</p>


<h3>Format</h3>

<p>A data frame with 1296 observations on the following 10 variables. Columns from
<code>P1</code> to <code>P9</code> describes positions in an extracted peptide. <code>tar</code> is a target vector. It
has value 1 if a peptide is a cleavage site and 0 if not.
</p>


<h3>Details</h3>

<p>Each peptide in the data set is nine amino acid residues long. In case of cleavage sites,
the clevage is located between fifth and sixth peptide.
The non-cleavage sites are parts of mature proteins starting five positions after cleavage site.
</p>


<h3>Note</h3>

<p>Amino acid residues were recoded as integers.
</p>


<h3>Source</h3>

<p><a href="http://www.uniprot.org/">UniProt</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(human_cleave)
table(human_cleave[, 1])

</code></pre>

<hr>
<h2 id='is_ngram'>Validate n-gram</h2><span id='topic+is_ngram'></span>

<h3>Description</h3>

<p>Checks if the character string may be used as an n-gram and its notation follows specific 
convention of <code>biogram</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_ngram(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_ngram_+3A_x">x</code></td>
<td>
<p><code>character</code> string representing single n-gram.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if n-gram's notation is correct, <code>FALSE</code> if not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(is_ngram("1_1.1.1_0.0"))
print(is_ngram("not_ngram"))
</code></pre>

<hr>
<h2 id='l2n'>Convert letters to numbers</h2><span id='topic+l2n'></span>

<h3>Description</h3>

<p>Converts biological sequence from letter to number notation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l2n(seq, seq_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l2n_+3A_seq">seq</code></td>
<td>
<p><code>character</code> vector or matrix representing single sequence.</p>
</td></tr>
<tr><td><code id="l2n_+3A_seq_type">seq_type</code></td>
<td>
<p>the type of sequence. Can be <code>rna</code>, <code>dna</code> or <code>prot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>numeric</code> vector or matrix containing converted elements.
</p>


<h3>See Also</h3>

<p><code>l2n</code> is a wrapper around <code><a href="#topic+degenerate">degenerate</a></code>.
</p>
<p>Inverse function: <code><a href="#topic+n2l">n2l</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample_seq &lt;- c("a", "d", "d", "g", "a", "g", "n", "a", "l")
l2n(sample_seq, "prot")
</code></pre>

<hr>
<h2 id='list2matrix'>Convert list of sequences to matrix</h2><span id='topic+list2matrix'></span>

<h3>Description</h3>

<p>Converts list of sequences to matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list2matrix(seq_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list2matrix_+3A_seq_list">seq_list</code></td>
<td>
<p>list of sequences (e.g. as returned by 
the <code><a href="seqinr.html#topic+read.fasta">read.fasta</a></code> function).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the number of rows equal to the number of sequences and the 
number of columns equal to the length of the longest sequence.
</p>


<h3>Note</h3>

<p>Since matrix must have specified number of columns, ends of shorter sequences are 
completed with NAs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>list2matrix(list(s1 = c("c", "g", "g", "t"),
                 s2 = c("g", "t", "c", "t", "t", "g"),
                 s3 = c("a", "a", "t")))
</code></pre>

<hr>
<h2 id='n2l'>Convert numbers to letters</h2><span id='topic+n2l'></span>

<h3>Description</h3>

<p>Converts biological sequence from number to letter notation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n2l(seq, seq_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n2l_+3A_seq">seq</code></td>
<td>
<p><code>integer</code> vector or matrix representing single sequence.</p>
</td></tr>
<tr><td><code id="n2l_+3A_seq_type">seq_type</code></td>
<td>
<p>the type of sequence. Can be <code>rna</code>, <code>dna</code> or <code>prot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>character</code> vector or matrix containing converted elements.
</p>


<h3>See Also</h3>

<p><code>n2l</code> is a wrapper around <code><a href="#topic+degenerate">degenerate</a></code>.
</p>
<p>Inverse function: <code><a href="#topic+l2n">l2n</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample_seq &lt;- c(1, 3, 3, 6, 1, 6, 12, 1, 10)
n2l(sample_seq, "prot")
</code></pre>

<hr>
<h2 id='ngrams2df'>n-grams to data frame</h2><span id='topic+ngrams2df'></span>

<h3>Description</h3>

<p>Tranforms a vector of n-grams into a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ngrams2df(ngrams)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ngrams2df_+3A_ngrams">ngrams</code></td>
<td>
<p>a <code>character</code> vector of n-grams.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with 2 (in case of n-grams without known position) or
three columns (n-grams with position information).
</p>


<h3>See Also</h3>

<p>Decode n-grams: <code><a href="#topic+decode_ngrams">decode_ngrams</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ngrams2df(c("2_1.1.2_0.0", "3_1.1.2_0.0", "3_2.2.2_0.0", "2_1.1_0"))
</code></pre>

<hr>
<h2 id='plot.criterion_distribution'>Plot criterion distribution</h2><span id='topic+plot.criterion_distribution'></span>

<h3>Description</h3>

<p>Plots results of <code><a href="#topic+distr_crit">distr_crit</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'criterion_distribution'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.criterion_distribution_+3A_x">x</code></td>
<td>
<p>object of class <code><a href="#topic+criterion_distribution">criterion_distribution</a></code>.</p>
</td></tr>
<tr><td><code id="plot.criterion_distribution_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>target_feature &lt;- create_feature_target(10, 375, 15, 600) 
example_result &lt;- distr_crit(target = target_feature[,1], 
                             feature = target_feature[,2])
plot(example_result)

# a ggplot2 plot
library(ggplot2)
ggplot_distr &lt;- function(x) {
b &lt;- data.frame(cbind(x=as.numeric(rownames(attr(x, "plot_data"))), 
                      attr(x, "plot_data")))
d1 &lt;- cbind(b[,c(1,2)], attr(x, "nice_name"))
d2 &lt;- cbind(b[,c(1,3)], "Probability")
colnames(d1) &lt;- c("x", "y", "panel")
colnames(d2) &lt;- c("x", "y", "panel")
d &lt;- rbind(d1, d2)
p &lt;- ggplot(data = d, mapping = aes(x = x, y = y)) + 
  facet_grid(panel~., scale="free") + 
  geom_freqpoly(data= d2, aes(color=y), stat = "identity") + 
  scale_fill_brewer(palette = "Set1") + 
  geom_point(data=d1, aes(size=y), stat = "identity") + 
  guides(color = "none") + 
  guides(size = "none") + 
  xlab("Number of cases with feature=1 and target=1") + ylab("")
p
}
ggplot_distr(example_result)

</code></pre>

<hr>
<h2 id='position_ngrams'>Position n-grams</h2><span id='topic+position_ngrams'></span>

<h3>Description</h3>

<p>Tranforms a vector of positioned n-grams into a list of positions filled with n-grams 
that start on them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_ngrams(ngrams, df = FALSE, unigrams_output = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position_ngrams_+3A_ngrams">ngrams</code></td>
<td>
<p>a vector of positioned n-grams (as created by <code><a href="#topic+count_ngrams">count_ngrams</a></code>).</p>
</td></tr>
<tr><td><code id="position_ngrams_+3A_df">df</code></td>
<td>
<p>logical, if <code>TRUE</code> returns a data frame, if <code>FALSE</code> returns a list.</p>
</td></tr>
<tr><td><code id="position_ngrams_+3A_unigrams_output">unigrams_output</code></td>
<td>
<p>logical, if <code>TRUE</code> extracts unigrams from the data and returns
information about their position.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>df</code> is <code>FALSE</code>, returns a list of length equal to the number of unique 
n-gram starts present in n-grams. Each element of the list contains n-grams that start on 
this position. If <code>df</code> is <code>FALSE</code>, returns a data frame where first column contains 
n-grams and the second column represent their start positions.
</p>


<h3>See Also</h3>

<p>Transform n-gram name to human-friendly form: <code><a href="#topic+decode_ngrams">decode_ngrams</a></code>.
</p>
<p>Validate n-gram structure: <code><a href="#topic+is_ngram">is_ngram</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># position data in the list format
position_ngrams(c("2_1.1.2_0.1", "3_1.1.2_0.0", "3_2.2.2_0.0"))
# position data in the data frame format
position_ngrams(c("2_1.1.2_0.1", "3_1.1.2_0.0", "3_2.2.2_0.0"), df = TRUE)
</code></pre>

<hr>
<h2 id='print.feature_test'>Print tested features</h2><span id='topic+print.feature_test'></span>

<h3>Description</h3>

<p>Prints results of <code><a href="#topic+test_features">test_features</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'feature_test'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.feature_test_+3A_x">x</code></td>
<td>
<p>object of class <code><a href="#topic+feature_test">feature_test</a></code>.</p>
</td></tr>
<tr><td><code id="print.feature_test_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="base.html#topic+print.default">print.default</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing.
</p>

<hr>
<h2 id='read_fasta'>Read FASTA files</h2><span id='topic+read_fasta'></span>

<h3>Description</h3>

<p>A lightweight tool to read nucleic or amino-acid sequences from a file 
in FASTA format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_fasta(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_fasta_+3A_file">file</code></td>
<td>
<p>the name of the file which the data are to be read from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of sequences.
</p>


<h3>See Also</h3>

<p><code><a href="seqinr.html#topic+read.fasta">read.fasta</a></code>: heavier function for processing FASTA files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  read_fasta("https://www.uniprot.org/uniprot/P28307.fasta")
  
## End(Not run)
</code></pre>

<hr>
<h2 id='regenerate'>Regenerate n-grams</h2><span id='topic+regenerate'></span>

<h3>Description</h3>

<p>'Regenerates' amino acid or nucleic sequence written in a simplified 
alphabet by converting groups to regular expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regenerate(x, element_groups)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regenerate_+3A_x">x</code></td>
<td>
<p><code>character</code> string representing single n-gram.</p>
</td></tr>
<tr><td><code id="regenerate_+3A_element_groups">element_groups</code></td>
<td>
<p>encoding of elements: list of groups to which elements 
of sequence should be aggregated. Must have unique names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> string representing a POSIX regular expression.
</p>


<h3>Note</h3>

<p>Gaps (<code>_</code>) will be converted to any possible character from the alphabet
(nucleotides or amino acids).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+degenerate">degenerate</a></code> to easily convert information stored in biological sequences from 
letters to numbers.
<code><a href="#topic+calc_ed">calc_ed</a></code> to calculate distance between simplified alphabets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>regenerate("ssw", list(w = c(1, 4), s = c(2, 3)))
</code></pre>

<hr>
<h2 id='regional_param'>regional_param class</h2><span id='topic+regional_param'></span>

<h3>Description</h3>

<p>List of rules defining the region.
</p>


<h3>Details</h3>

<p>An object of the <code>regional_param</code> class is a list consisting of all rules 
necessary to properly build a region.
</p>


<h3>Attributes</h3>


<dl>
<dt>reg_len</dt><dd><p>the number of unigrams inside the region. Might be 0</p>
</dd>
<dt>prop_ranges</dt><dd><p>required intervals of properties of unigrams in the region</p>
</dd>
<dt>exactness</dt><dd><p>a <code>numeric</code> value between 0 and 1 defining how stricly 
unigrams are kept within <code>prop_ranges</code>. If 1, only unigrams within 
<code>prop_ranges</code> are inside the region. if 0.9, there is 10
unigrams that are not in the <code>prop_ranges</code> will be inside the region.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+generate_sequence">generate_sequence</a></code>
</p>

<hr>
<h2 id='seq2ngrams'>Extract n-grams from sequence</h2><span id='topic+seq2ngrams'></span>

<h3>Description</h3>

<p>Extracts vector of n-grams present in sequence(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq2ngrams(seq, n, u, d = 0, pos = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq2ngrams_+3A_seq">seq</code></td>
<td>
<p>a vector or matrix describing sequence(s).</p>
</td></tr>
<tr><td><code id="seq2ngrams_+3A_n">n</code></td>
<td>
<p><code>integer</code> size of n-gram.</p>
</td></tr>
<tr><td><code id="seq2ngrams_+3A_u">u</code></td>
<td>
<p><code>integer</code>, <code>numeric</code> or <code>character</code> vector of all
possible unigrams.</p>
</td></tr>
<tr><td><code id="seq2ngrams_+3A_d">d</code></td>
<td>
<p><code>integer</code> vector of distances between elements of n-gram (0 means 
consecutive elements). See Details.</p>
</td></tr>
<tr><td><code id="seq2ngrams_+3A_pos">pos</code></td>
<td>
<p><code>logical</code>, if <code>TRUE</code> position-specific n_grams are counted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A format of <code>d</code> vector is discussed in Details of 
<code><a href="#topic+count_ngrams">count_ngrams</a></code>.
</p>


<h3>Value</h3>

<p>A <code>character</code> matrix of n-grams, where every row corresponds to a
different sequence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># trigrams from multiple sequences
seqs &lt;- matrix(sample(1L:4, 600, replace = TRUE), ncol = 50)
seq2ngrams(seqs, 3, 1L:4)
</code></pre>

<hr>
<h2 id='simple2full'>Convert encoding from simple to full format</h2><span id='topic+simple2full'></span>

<h3>Description</h3>

<p>Converts an encoding from the simple format to the full format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple2full(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simple2full_+3A_x">x</code></td>
<td>
<p>encoding (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The encoding should be named. Each name should correspond to a different
amino acid or nucleotide.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aa1 = structure(c("1", "4", "3", "3", "4", "1", "2", "1", "2", "1", 
                  "1", "4", "1", "4", "4", "4", "4", "1", "4", "4"), 
                .Names = c("a", "c", "d", "e", "f", "g", "h", "i", 
                           "k", "l", "m", "n", "p", "q", 
                           "r", "s", "t", "v", "w", "y"))
simple2full(aa1)

</code></pre>

<hr>
<h2 id='summary.feature_test'>Summarize tested features</h2><span id='topic+summary.feature_test'></span>

<h3>Description</h3>

<p>Summarizes results of <code><a href="#topic+test_features">test_features</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'feature_test'
summary(object, conf_level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.feature_test_+3A_object">object</code></td>
<td>
<p>of class <code><a href="#topic+feature_test">feature_test</a></code>.</p>
</td></tr>
<tr><td><code id="summary.feature_test_+3A_conf_level">conf_level</code></td>
<td>
<p>confidence level. A feature with p-value equal to or smaller than the 
confidence is considered significant.</p>
</td></tr>
<tr><td><code id="summary.feature_test_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing.
</p>

<hr>
<h2 id='table_ngrams'>Tabulate n-grams</h2><span id='topic+table_ngrams'></span>

<h3>Description</h3>

<p>Builds a contingency table of the n-gram counts versus their class labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_ngrams(seq, ngrams, target)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_ngrams_+3A_seq">seq</code></td>
<td>
<p>vector or matrix describing sequence(s).</p>
</td></tr>
<tr><td><code id="table_ngrams_+3A_ngrams">ngrams</code></td>
<td>
<p>vector of n-grams.</p>
</td></tr>
<tr><td><code id="table_ngrams_+3A_target">target</code></td>
<td>
<p><code>integer</code> vector with target information (e.g. class labels). 
Must have at least two values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with the number of columns equal to the length of the 
<code>target</code> plus 1. The first column contains names of the n-grams. Further 
columns represents counts of n-grams for respective value of the
<code>target</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seqs_pos &lt;- matrix(sample(c("a", "c", "g", "t"), 100, replace = TRUE, 
            prob = c(0.2, 0.4, 0.35, 0.05)), ncol = 5)
seqs_neg &lt;- matrix(sample(c("a", "c", "g", "t"), 100, replace = TRUE), 
            ncol = 5)
tab &lt;- table_ngrams(seq = rbind(seqs_pos, seqs_neg), 
                    ngrams = c("1_c.t_0", "1_g.g_0", "2_t.c_0", "2_g.g_0", "3_c.c_0", "3_g.c_0"), 
                    target = c(rep(1, 20), rep(0, 20)))
# see the results
print(tab)
# easily plot the results using ggplot2
</code></pre>

<hr>
<h2 id='test_features'>Permutation test for feature selection</h2><span id='topic+test_features'></span>

<h3>Description</h3>

<p>Performs a feature selection on positioned n-gram data using a Fisher's 
permutation test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_features(
  target,
  features,
  criterion = "ig",
  adjust = "BH",
  threshold = 1,
  quick = TRUE,
  times = 1e+05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_features_+3A_target">target</code></td>
<td>
<p><code>integer</code> vector with target information (e.g. class labels).</p>
</td></tr>
<tr><td><code id="test_features_+3A_features">features</code></td>
<td>
<p><code>integer</code> matrix of features with number of rows equal 
to the length of the target vector.</p>
</td></tr>
<tr><td><code id="test_features_+3A_criterion">criterion</code></td>
<td>
<p>criterion used in permutation test. See Details 
for the list of possible criterions.</p>
</td></tr>
<tr><td><code id="test_features_+3A_adjust">adjust</code></td>
<td>
<p>name of p-value adjustment method. See <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>
for the list of possible values. If <code>NULL</code>, p-values are not adjusted.</p>
</td></tr>
<tr><td><code id="test_features_+3A_threshold">threshold</code></td>
<td>
<p><code>integer</code>. Features that occur less than <code>threshold</code>
and more often than <code>nrow(features)-threshold</code> are discarded from the permutation 
test.</p>
</td></tr>
<tr><td><code id="test_features_+3A_quick">quick</code></td>
<td>
<p><code>logical</code>, if <code>TRUE</code> Quick Permutation Test (QuiPT) is used. If 
<code>FALSE</code>, normal permutation test is performed.</p>
</td></tr>
<tr><td><code id="test_features_+3A_times">times</code></td>
<td>
<p>number of times procedure should be repeated. Ignored if <code>quick</code> is 
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since the procedure involves multiple testing, it is advisable to use one
of the avaible p-value adjustment methods. Such methods can be used directly by 
specifying the <code>adjust</code> parameter.
</p>
<p>Available criterions:
</p>

<dl>
<dt>ig</dt><dd><p>Information Gain: <code><a href="#topic+calc_ig">calc_ig</a></code>.</p>
</dd>
<dt>kl</dt><dd><p>Kullback-Leibler divergence: <code><a href="#topic+calc_kl">calc_kl</a></code>.</p>
</dd>
<dt>cs</dt><dd><p>Chi-squared-based measure: <code><a href="#topic+calc_cs">calc_cs</a></code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>an object of class <code><a href="#topic+feature_test">feature_test</a></code>.
</p>


<h3>Note</h3>

<p>Both <code>target</code> and <code>features</code> must be binary, i.e. contain only 0 
and 1 values.
</p>
<p>Features occuring too often and too rarely are considered not informative and may be 
removed using the threshold parameter.
</p>


<h3>References</h3>

<p>Radivojac P, Obradovic Z, Dunker AK, Vucetic S, 
<em>Feature selection filters based on the permutation test</em> in 
Machine Learning: ECML 2004, 15th European 
Conference on Machine Learning, Springer, 2004.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+binarize">binarize</a></code> - binarizes input data.
</p>
<p><code><a href="#topic+calc_criterion">calc_criterion</a></code> - computes selected criterion.
</p>
<p><code><a href="#topic+distr_crit">distr_crit</a></code> - distribution of criterion used in QuiPT.
</p>
<p><code><a href="#topic+summary.feature_test">summary.feature_test</a></code> - summary of results.
</p>
<p><code><a href="#topic+cut.feature_test">cut.feature_test</a></code> - aggregates test results in groups based on feature's
p-value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># significant feature
tar_feat1 &lt;- create_feature_target(10, 390, 0, 600) 
# significant feature
tar_feat2 &lt;- create_feature_target(9, 391, 1, 599)
# insignificant feature
tar_feat3 &lt;- create_feature_target(198, 202, 300, 300)
test_res &lt;- test_features(tar_feat1[, 1], cbind(tar_feat1[, 2], tar_feat2[, 2], 
                          tar_feat3[, 2]))
summary(test_res)
cut(test_res)

# real data example
# we will analyze only a subsample of a dataset to make analysis quicker
ids &lt;- c(1L:100, 701L:800)
deg_seqs &lt;- degenerate(human_cleave[ids, 1L:9], 
                       list(`a` = c(1, 6, 8, 10, 11, 18), 
                            `b` = c(2, 5, 13, 14, 16, 17, 19, 20), 
                            `c` = c(3, 4, 7, 9, 12, 15)))

# positioned n-grams example
bigrams_pos &lt;- count_ngrams(deg_seqs, 2, letters[1L:3], pos = TRUE)
test_features(human_cleave[ids, 10], bigrams_pos)

# unpositioned n-grams example, binarization required
bigrams_notpos &lt;- count_ngrams(deg_seqs, 2, letters[1L:3], pos = TRUE)
test_features(human_cleave[ids, 10], binarize(bigrams_notpos))
</code></pre>

<hr>
<h2 id='validate_encoding'>Validate encoding</h2><span id='topic+validate_encoding'></span>

<h3>Description</h3>

<p>Checks the structure of an encoding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_encoding(x, u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_encoding_+3A_x">x</code></td>
<td>
<p>encoding.</p>
</td></tr>
<tr><td><code id="validate_encoding_+3A_u">u</code></td>
<td>
<p><code>integer</code>, <code>numeric</code> or <code>character</code> vector of all
elements belonging to the encoding. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The encoding is a list of groups to which elements of an alphabet 
should be reduced. All elements of the alphabet (all 
amino acids or all nucleotides) should appear in the encoding.
</p>


<h3>Value</h3>

<p><code>TRUE</code> if the <code>x</code> is a correctly reduced <code>u</code>, 
<code>FALSE</code> in any other cases.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_ed">calc_ed</a></code>: calculate the encoding distance between two encodings.
<code><a href="#topic+encoding2df">encoding2df</a></code>: converts an encoding to a data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>enc1 = list(`1` = c("a", "t"), 
            `2` = c("g", "c"))
# see if enc1 is the correctly reduced nucleotide (DNA) alphabet
validate_encoding(enc1, c("a", "c", "g", "t"))

# enc1 is not the RNA alphabet, so the results is FALSE
validate_encoding(enc1, c("a", "c", "g", "u"))

# validate_encoding works also on other notations
enc2 = list(a = c(1, 4),
            b = c(2, 3))
validate_encoding(enc2, 1L:4)
</code></pre>

<hr>
<h2 id='write_encoding'>Write encodings to a file</h2><span id='topic+write_encoding'></span>

<h3>Description</h3>

<p>Saves a list of encodings (or a single encoding to the file).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_encoding(x, file = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_encoding_+3A_x">x</code></td>
<td>
<p>encoding or list of encodings.</p>
</td></tr>
<tr><td><code id="write_encoding_+3A_file">file</code></td>
<td>
<p>ither a character string naming a file or a 
<code><a href="base.html#topic+connection">connection</a></code> 
open for writing. &quot;&quot; indicates output to the console.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>aa1 = list(`1` = c("g", "a", "p", "v", "m", "l", "i"), 
           `2` = c("k", "h"), 
           `3` = c("d", "e"), 
           `4` = c("f", "r", "w", "y", "s", "t", "c", "n", "q"))
write_encoding(aa1)

</code></pre>

<hr>
<h2 id='write_fasta'>Write FASTA files</h2><span id='topic+write_fasta'></span>

<h3>Description</h3>

<p>A lightweight tool to read nucleic or amino-acid sequences from a file 
in FASTA format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_fasta(seq, file, nchar = 80)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_fasta_+3A_seq">seq</code></td>
<td>
<p>a list of sequences.</p>
</td></tr>
<tr><td><code id="write_fasta_+3A_file">file</code></td>
<td>
<p>the name of the output file.</p>
</td></tr>
<tr><td><code id="write_fasta_+3A_nchar">nchar</code></td>
<td>
<p>the number of characters per line.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="seqinr.html#topic+write.fasta">write.fasta</a></code>: heavier function for writing FASTA files.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
