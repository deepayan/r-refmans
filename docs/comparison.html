<!DOCTYPE html><html><head><title>Help for package comparison</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {comparison}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#comparison-package'><p>comparison: Multivariate Likelihood Ratio Calculation and Evaluation</p></a></li>
<li><a href='#calc.ece'><p>Empirical cross-entropy (ECE) calculation</p></a></li>
<li><a href='#calcLR'><p>Calculate the likelihood ratio</p></a></li>
<li><a href='#calibrate.set'><p>Calculate the calibrated set of idea LRs</p></a></li>
<li><a href='#glass'><p>Glass composition data for seven elements from 200 glass items.</p></a></li>
<li><a href='#logistic.apply.calibration'><p>Calculate the calibrated LRs with the model precomputed</p></a></li>
<li><a href='#logistic.calibrate.get.model'><p>Compute and returns the logistic regression for a dataset</p></a></li>
<li><a href='#logistic.calibrate.set'><p>Calculate the calibrated set of LRs with the logistic regression</p></a></li>
<li><a href='#makeCompItem'><p>Create a <code>compitem</code> object.</p></a></li>
<li><a href='#makeCompVar'><p>Compute integrated means and covariances</p></a></li>
<li><a href='#plot.ece'><p>An S3 plot method for objects of class <code>ece</code></p></a></li>
<li><a href='#print.compitem'><p>S3 method for class <code>compitem</code></p></a></li>
<li><a href='#two.level.comparison.items'><p>Create a <code>compitem</code> object.</p></a></li>
<li><a href='#two.level.components'><p>Compute integrated means and covariances</p></a></li>
<li><a href='#two.level.density.LR'><p>Calculate the likelihood ratio using multivariate KDEs</p></a></li>
<li><a href='#two.level.lindley.LR'><p>Likelihood ratio calculation using Lindley's approach</p></a></li>
<li><a href='#two.level.normal.LR'><p>Likelihood ratio calculation - normal</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-22</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Likelihood Ratio Calculation and Evaluation</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for calculating and evaluating likelihood ratios from uni/multivariate continuous observations.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>isotone, CVglasso, methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jmcurran/comparison">https://github.com/jmcurran/comparison</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jmcurran/comparison/issues">https://github.com/jmcurran/comparison/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-25 15:06:19 UTC; jcur002</td>
</tr>
<tr>
<td>Author:</td>
<td>David Lucy [aut],
  James Curran [aut, cre],
  Agnieszka Martyna [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James Curran &lt;j.curran@auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-25 15:30:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='comparison-package'>comparison: Multivariate Likelihood Ratio Calculation and Evaluation</h2><span id='topic+comparison'></span><span id='topic+comparison-package'></span>

<h3>Description</h3>

<p>Functions for calculating and evaluating likelihood ratios from uni/multivariate continuous observations.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: James Curran <a href="mailto:j.curran@auckland.ac.nz">j.curran@auckland.ac.nz</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> David Lucy <a href="mailto:d.lucy@lancaster.ac.uk">d.lucy@lancaster.ac.uk</a>
</p>
</li>
<li><p> Agnieszka Martyna <a href="mailto:ag.rzepecka@gmail.com">ag.rzepecka@gmail.com</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/jmcurran/comparison">https://github.com/jmcurran/comparison</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/jmcurran/comparison/issues">https://github.com/jmcurran/comparison/issues</a>
</p>
</li></ul>


<hr>
<h2 id='calc.ece'>Empirical cross-entropy (ECE) calculation</h2><span id='topic+calc.ece'></span>

<h3>Description</h3>

<p>Calculates the empirical cross-entropy (ECE) for likelihood ratios from a
sequence same and different item comparisons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.ece(LR.ss, LR.ds, prior = seq(from = 0.01, to = 0.99, length = 99))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc.ece_+3A_lr.ss">LR.ss</code></td>
<td>
<p>a vector of likelihood ratios (LRs) from same source
calculations</p>
</td></tr>
<tr><td><code id="calc.ece_+3A_lr.ds">LR.ds</code></td>
<td>
<p>a vector of LRs from different source calculations</p>
</td></tr>
<tr><td><code id="calc.ece_+3A_prior">prior</code></td>
<td>
<p>a vector of ordinates for the prior in ascending order, and
between 0 and 1. Default is 99 divisions of 0.01 to 0.99.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Acknowledgements</h4>

<p>The function to calculate the values of the likelihood ratio for the
<code>calibrated.set</code> draws heavily upon the <code>opt_loglr.m</code> function from
Niko Brummer's FoCal package for Matlab.
</p>



<h3>Value</h3>

<p>Returns an S3 object of class <code>ece</code>
</p>


<h3>Author(s)</h3>

<p>David Lucy
</p>


<h3>References</h3>

<p>Ramos, D. &amp; Gonzalez-Rodriguez, J. (2008) Cross-entropy analysis
of the information in forensic speaker recognition; IEEE Odyssey.
Zadora, G. &amp; Ramos, D. (2010) Evaluation of glass samples for forensic purposes -
an application of likelihood ratio model and information-theoretical
approach. Chemometrics and Intelligent Laboratory: 102; 63-83.
</p>


<h3>See Also</h3>

<p><code><a href="isotone.html#topic+gpava">isotone::gpava()</a></code>, <code><a href="#topic+calibrate.set">calibrate.set()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>LR.same = c(0.5, 2, 4, 6, 8, 10) 		# the same has 1 LR &lt; 1
LR.different = c(0.2, 0.4, 0.6, 0.8, 1.1) 	# the different has 1 LR &gt; 1
ece.1 = calc.ece(LR.same, LR.different)	# simplest invocation
plot(ece.1)					# use plot method
</code></pre>

<hr>
<h2 id='calcLR'>Calculate the likelihood ratio</h2><span id='topic+calcLR'></span>

<h3>Description</h3>

<p>Takes a <code>compitem</code> object which represents some control item, and a
<code>compitem</code> object which represents a recovered item, then uses information
from a <code>compcovar</code> object, which represents the information from the
population, to calculate a likelihood ratio (LR) as a measure of the evidence
given by the observations for the same/different source propositions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcLR(control, recovered, background, method = c("mvn", "kde", "lindley"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcLR_+3A_control">control</code></td>
<td>
<p>a <code>compitem</code> object with the control item information.</p>
</td></tr>
<tr><td><code id="calcLR_+3A_recovered">recovered</code></td>
<td>
<p>a <code>compitem</code> object with the recovered item information.</p>
</td></tr>
<tr><td><code id="calcLR_+3A_background">background</code></td>
<td>
<p>a <code>compcovar</code> object with the population information.</p>
</td></tr>
<tr><td><code id="calcLR_+3A_method">method</code></td>
<td>
<p>a choice of the method used to calculate the LR. Presently there
are three methods, <code>"mvn"</code> - multivariate normal approximation, <code>"kde"</code> - (multivariate) kernel
density estimates and <code>"lindely"</code> which uses the method published by Lindley (1977).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an estimate of the likelihood ratio
</p>


<h3>References</h3>

<p>Aitken, C.G.G. &amp; Lucy, D. (2004) Evaluation of trace evidence in the form of multivariate data. <em>Applied Statistics</em>: <b>53</b>(1); 109-122.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(glass)

controlMeasurements = subset(glass, item == "s1")
control = makeCompItem(item ~ logKO + logCaO + logFeO, 
                       data = controlMeasurements[1:6,])
recovered.1 = makeCompItem(item ~ logKO + logCaO + logFeO, 
                       data = controlMeasurements[7:12,])
recoveredMeasurements = subset(glass, item == "s2")
recovered.2 = makeCompItem(item ~ logKO + logCaO + logFeO,
                           data = recoveredMeasurements[7:12,])
                           
background = makeCompVar(item ~ logKO + logCaO + logFeO, data = glass)
                           
## Same source comparison using a multivariate normal (MVN) approximation
calcLR(control, recovered.1, background)

## Same source comparison using a multivariate kernel density estimate (MVK) approximation
calcLR(control, recovered.1, background, "kde")

## Different source comparison using a multivariate normal (MVN) approximation
calcLR(control, recovered.2, background)

## Different source comparison using a multivariate kernel density estimate (MVK) approximation
calcLR(control, recovered.2, background, "kde")

</code></pre>

<hr>
<h2 id='calibrate.set'>Calculate the calibrated set of idea LRs</h2><span id='topic+calibrate.set'></span>

<h3>Description</h3>

<p>Calculates and returns the calibrated set of <code style="white-space: pre;">&#8288;ideal' LRs from the observed LRs using the penalised adjacent violators algorithm. This is very much a rewrite of Nico Brummer's &#8288;</code>optloglr()' function for Matlab.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrate.set(
  LR.ss,
  LR.ds,
  method = c("raw", "laplace"),
  ties = c("none", "primary", "secondary", "tertiary")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrate.set_+3A_lr.ss">LR.ss</code></td>
<td>
<p>a vector of likelihood ratios for the comparisons of items known to be from the same source</p>
</td></tr>
<tr><td><code id="calibrate.set_+3A_lr.ds">LR.ds</code></td>
<td>
<p>a vector of likelihood ratios for the comparisons of items known to be from different sources</p>
</td></tr>
<tr><td><code id="calibrate.set_+3A_method">method</code></td>
<td>
<p>the method used to perform the calculation, either <code>"raw"</code> or <code>"laplace"</code></p>
</td></tr>
<tr><td><code id="calibrate.set_+3A_ties">ties</code></td>
<td>
<p>method to solve ties in the predictors list, either <code>"none"</code> (not solved) or <code>"primary"</code>, <code>"secondary"</code> or <code>"tertiary"</code> (passed to the isotone::gpava() function)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an internal function, and is not meant to be called directly. However
it has been exported just in case.
</p>


<h3>Value</h3>

<p>a <code>list</code> with two items: </p>

<dl>
<dt>LR.cal.ss</dt><dd><p>calibrated LRs for the comparison for same set</p>
</dd>
<dt>LR.cal.ds</dt><dd><p>calibrated LRs for the comparison for different set</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>David Lucy
</p>


<h3>References</h3>

<p>Ramos, D. &amp; Gonzalez-Rodriguez, J. (2008) Cross-entropy analysis of the information in forensic speaker recognition; IEEE Odyssey.
</p>
<p>de Leeuw, J. &amp; Hornik, K. &amp; Mair, P., (2009), Isotone Optimization in R: Pool-Adjacent-Violators Algorithm (PAVA) and Active Set Methods, https://www.jstatsoft.org/article/view/v032i05
</p>


<h3>See Also</h3>

<p><code><a href="isotone.html#topic+gpava">isotone::gpava()</a></code>, <code><a href="#topic+calc.ece">calc.ece()</a></code>
</p>

<hr>
<h2 id='glass'>Glass composition data for seven elements from 200 glass items.</h2><span id='topic+glass'></span>

<h3>Description</h3>

<p>These data are from Grzegorz (Greg) Zadora at the <a href="http://ies.krakow.pl/">Institute of Forensic Research</a> in
Krakow, Poland. They are the log of the ratios of each
element to oxygen, so logNaO is the log(10) of the Sodium to Oxygen ratio,
and logAlO is the log of the Aluminium to Oxygen ratio. The instrumental
method was SEM-EDX.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(glass)
</code></pre>


<h3>Format</h3>

<p>a <code>data.frame</code> with 2400 rows and 9 columns.
</p>

<dl>
<dt>item</dt><dd><p>factor</p>
</dd></dl>
<p>200 levels - which item the measurements came from
</p>
<dl>
<dt>fragment</dt><dd><p>factor</p>
</dd></dl>
<p>4 levels - which of the four fragments from each item the observations were made
upon
</p>
<dl>
<dt>logNaO</dt><dd><p>numeric</p>
</dd></dl>
<p>log of sodium concentration to oxygen concentration
</p>
<dl>
<dt>logMgO</dt><dd><p>numeric</p>
</dd></dl>
<p>log of magnesium concentration to oxygen concentration
</p>
<dl>
<dt>logAlO</dt><dd><p>numeric</p>
</dd></dl>
<p>log of aluminium concentration to oxygen concentration
</p>
<dl>
<dt>logSiO</dt><dd><p>numeric</p>
</dd></dl>
<p>log of silicon concentration to oxygen concentration
</p>
<dl>
<dt>logKO</dt><dd><p>numeric</p>
</dd></dl>
<p>log of potassium concentration to oxygen concentration
</p>
<dl>
<dt>logCaO</dt><dd><p>numeric</p>
</dd></dl>
<p>log of calcium concentration to oxygen concentration
</p>
<dl>
<dt>logFeO</dt><dd><p>numeric</p>
</dd></dl>
<p>log of iron concentration to oxygen concentration

</p>


<h3>Details</h3>

<p>The <code>item</code> indicates the object the glass came from. The levels for each item
are unique to that item. The <code>fragment</code> can be considered a sub-item. When
collecting these observations Greg took a glass object, say a jam jar, he
would then break it, and extract four fragments. Each fragment would be
measured three times upon different parts of that fragment. The fragment
labels are repeated, so, for example, fragment &quot;f1&quot; from item &quot;s2&quot; has
nothing whatsoever to do with fragment &quot;f1&quot; from item &quot;s101&quot;.
</p>
<p>For two level models use <code>item</code> as the lower level - three level models can
use the additional information from the individual fragments.
</p>


<h3>Source</h3>

<p>Grzegorz Zadora <a href="http://ies.krakow.pl/">Institute of Forensic Research</a>, Krakow, Poland.
</p>


<h3>References</h3>

<p>Aitken, C.G.G. Zadora, G. &amp; Lucy, D. (2007) A Two-Level Model for
Evidence Evaluation. <em>Journal of Forensic Sciences</em>: <b>52</b>(2);
412-419.
</p>

<hr>
<h2 id='logistic.apply.calibration'>Calculate the calibrated LRs with the model precomputed</h2><span id='topic+logistic.apply.calibration'></span>

<h3>Description</h3>

<p>This function perform the logistic calibration on the provided data.
In the context of likelihood ratios, the 'ideal' value for the LR is Infinity for the same source dataset, and 0 for the different-sources dataset.
The 'post' values are fixed to 1 for the same source and 0 for the same different-sources datasets (corresponding to the posterior probability P(H_ss|E)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logistic.apply.calibration(LR, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logistic.apply.calibration_+3A_lr">LR</code></td>
<td>
<p>a vector of likelihood ratios to be calibrated (raw values).</p>
</td></tr>
<tr><td><code id="logistic.apply.calibration_+3A_model">model</code></td>
<td>
<p>a logistic.calibrate.set() fitted model to be applied. This variable can be the reture of the logistic.calibrate.set() or the logistic.calibrate.set()$fit variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> with the calibrated LR values
</p>


<h3>Author(s)</h3>

<p>Marco De Donno
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logistic.calibrate.set">logistic.calibrate.set()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # the list of LRs for the same source proposition
LR.same = c(0.5, 2, 4, 6, 8, 10)
# the list of LRs for the different source proposition
LR.different = c(0.2, 0.4, 0.6, 0.8, 1.1)
# compute the logistic calibration on the data
model = logistic.calibrate.get.model(LR.same, LR.different) 
 # the list of news LRs (to be calibrated)
LR.unknown = c(0.6, 0.7, 1.2, 5)
# compute the calibrated LRs for the list with the model
logistic.apply.calibration(LR.unknown, model)

</code></pre>

<hr>
<h2 id='logistic.calibrate.get.model'>Compute and returns the logistic regression for a dataset</h2><span id='topic+logistic.calibrate.get.model'></span>

<h3>Description</h3>

<p>Compute and returns the logistic regression for a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logistic.calibrate.get.model(LR.ss, LR.ds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logistic.calibrate.get.model_+3A_lr.ss">LR.ss</code></td>
<td>
<p>a vector of likelihood ratios for the comparisons of items known
to be from the same source</p>
</td></tr>
<tr><td><code id="logistic.calibrate.get.model_+3A_lr.ds">LR.ds</code></td>
<td>
<p>a vector of likelihood ratios for the comparisons of items known
to be from different sources</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> with multiple items: </p>

<dl>
<dt>coefficients</dt><dd><p>coefficients of the fitted model</p>
</dd>
<dt>prior.odds</dt><dd><p>prior odds for the input data</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Marco De Donno
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logistic.apply.calibration">logistic.apply.calibration()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the list of LRs for the same source proposition
LR.same = c(0.5, 2, 4, 6, 8, 10)
# the list of LRs for the different source proposition
LR.different = c(0.2, 0.4, 0.6, 0.8, 1.1)
# compute the logistic calibration on the data
logistic.calibrate.get.model(LR.same, LR.different) 

</code></pre>

<hr>
<h2 id='logistic.calibrate.set'>Calculate the calibrated set of LRs with the logistic regression</h2><span id='topic+logistic.calibrate.set'></span>

<h3>Description</h3>

<p>Calculate the calibrated set of LRs with the logistic regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logistic.calibrate.set(LR.ss, LR.ds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logistic.calibrate.set_+3A_lr.ss">LR.ss</code></td>
<td>
<p>a vector of likelihood ratios for the comparisons of items known to be from the same source</p>
</td></tr>
<tr><td><code id="logistic.calibrate.set_+3A_lr.ds">LR.ds</code></td>
<td>
<p>a vector of likelihood ratios for the comparisons of items known to be from different sources</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> with multiple items: </p>

<dl>
<dt>prior.odds</dt><dd><p>prior odds for the input data</p>
</dd>
<dt>coefficients</dt><dd><p>coefficients of the fitted model</p>
</dd>
<dt>data</dt><dd><p>The input and calibrated data</p>
</dd>
<dt>LR.cal.ss</dt><dd><p>The calibrated data for the same source list</p>
</dd>
<dt>LR.cal.ds</dt><dd><p>The calibrated data for the different-sources list</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Marco De Donno
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logistic.apply.calibration">logistic.apply.calibration()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>LR.same = c(0.5, 2, 4, 6, 8, 10)              # the list of LRs for the same source proposition
LR.different = c(0.2, 0.4, 0.6, 0.8, 1.1)     # the list of LRs for the different source proposition
logistic.calibrate.set(LR.same, LR.different) # compute the logistic calibration on the data

</code></pre>

<hr>
<h2 id='makeCompItem'>Create a <code>compitem</code> object.</h2><span id='topic+makeCompItem'></span><span id='topic+makeCompItem.formula'></span>

<h3>Description</h3>

<p>This function creates a <code>compitem</code> from a set of observations
on items to be deemed control, or a recovered, items. For example,
a set of elemental concentration measurements on a sample of glass
fragments taken from a crime scene source such as a window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeCompItem(x, ...)

## S3 method for class 'formula'
makeCompItem(x, data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeCompItem_+3A_x">x</code></td>
<td>
<p>a <code>matrix</code> or <code>data.frame</code> or a <code>formula</code></p>
</td></tr>
<tr><td><code id="makeCompItem_+3A_...">...</code></td>
<td>
<p>other arguments that may be passed to the function.</p>
</td></tr>
<tr><td><code id="makeCompItem_+3A_data">data</code></td>
<td>
<p>if <code>x</code> is a formula, then the user must supply a <code>data.frame</code>
containing the observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>compitem</code>
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>makeCompItem(formula)</code>: Create a <code>compitem</code> object using a formula.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>David Lucy and James Curran
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load Greg Zadora's glass data
data(glass)

# calculate a compitem object representing the control item
controlMeasurements = subset(glass, item == "s1", select = c(logKO, logCaO, logFeO))
control = makeCompItem(controlMeasurements)

# example using the formula interface
controlMeasurements = subset(glass, item == "s1")
control = makeCompItem(item ~ logKO + logCaO + logFeO, data = controlMeasurements)
 
</code></pre>

<hr>
<h2 id='makeCompVar'>Compute integrated means and covariances</h2><span id='topic+makeCompVar'></span><span id='topic+makeCompVar.default'></span><span id='topic+makeCompVar.formula'></span>

<h3>Description</h3>

<p>Takes a large sample from the background population and calculates the within
and between covariance matrices, a vector of means, a vector of the counts of
replicates for each item from the sample, and other bits needed to make up a
<code>compcovar</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeCompVar(x, ...)

## Default S3 method:
makeCompVar(x, item.column, ...)

## S3 method for class 'formula'
makeCompVar(x, data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeCompVar_+3A_x">x</code></td>
<td>
<p>a <code>matrix</code>, or <code>data.frame</code>, of observations, with cases in rows,
and properties as columns, or a <code>formula</code>.</p>
</td></tr>
<tr><td><code id="makeCompVar_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
<tr><td><code id="makeCompVar_+3A_item.column">item.column</code></td>
<td>
<p>an integer indicating which column gives the item.</p>
</td></tr>
<tr><td><code id="makeCompVar_+3A_data">data</code></td>
<td>
<p>if <code>x</code> is a <code>formula</code>, then the user must supply a <code>data.frame</code>
containing the observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses ML estimation at the moment - this will almost certainly change in the future and
hopefully allow regularisation methods to get a more stable (and non-singular) estimate.
</p>


<h3>Value</h3>

<p>an object of class <code>compvar</code>
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>makeCompVar(default)</code>: Create a <code>compvar</code> object using a formula.
</p>
</li>
<li> <p><code>makeCompVar(formula)</code>: Create a <code>compvar</code> object using a formula.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>David Lucy and James Curran
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load Greg Zadora's glass data
data(glass)

# calculate a compcovar object based upon glass
# using K, Ca and Fe - warning - could take time
# on slower machines
background = subset(glass, select = c(item, logKO, logCaO, logFeO))
Z1 = makeCompVar(background, 1)

# Use the formula interface
Z2 = makeCompVar(item ~ logKO + logCaO + logFeO, data = glass)
</code></pre>

<hr>
<h2 id='plot.ece'>An S3 plot method for objects of class <code>ece</code></h2><span id='topic+plot.ece'></span>

<h3>Description</h3>

<p>An S3 plot method for objects of class <code>ece</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ece'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ece_+3A_x">x</code></td>
<td>
<p>an S3 object of class <code>ece</code> which is generated from <code><a href="#topic+calc.ece">calc.ece()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.ece_+3A_...">...</code></td>
<td>
<p>other arguments that are passed to the <code>plot</code> generic.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Lucy
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc.ece">calc.ece()</a></code>
</p>

<hr>
<h2 id='print.compitem'>S3 method for class <code>compitem</code></h2><span id='topic+print.compitem'></span>

<h3>Description</h3>

<p>S3 method for class <code>compitem</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'compitem'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.compitem_+3A_x">x</code></td>
<td>
<p>an object of class <code>compitem</code> created by <code><a href="#topic+makeCompItem">makeCompItem()</a></code></p>
</td></tr>
<tr><td><code id="print.compitem_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='two.level.comparison.items'>Create a <code>compitem</code> object.</h2><span id='topic+two.level.comparison.items'></span>

<h3>Description</h3>

<p>This function creates a <code>compitem</code> object from a <code>data.frame</code> or <code>matrix</code> of
observations from an item to be deemed a control, or a recovered, item.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>two.level.comparison.items(data, data.columns)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="two.level.comparison.items_+3A_data">data</code></td>
<td>
<p>a <code>matrix</code> or <code>data.frame</code> of observed properties from either
the control item, or the recovered item</p>
</td></tr>
<tr><td><code id="two.level.comparison.items_+3A_data.columns">data.columns</code></td>
<td>
<p>vector of integers giving which columns in <code>data</code> are
the observations of the properties</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>compitem</code>
</p>


<h4>Note</h4>

<p>This function is deprecated and will eventually be replaced by <code><a href="#topic+makeCompItem">makeCompItem()</a></code>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'># load Greg Zadora's glass data
data(glass)

# calculate a compitem object representing the control item
control = two.level.comparison.items(glass[1:6,], c(7,8,9))
</code></pre>

<hr>
<h2 id='two.level.components'>Compute integrated means and covariances</h2><span id='topic+two.level.components'></span>

<h3>Description</h3>

<p>Takes a large sample from the background population and calculates the within
and between covariance matrices, a vector of means, a vector of the counts of
replicates for each item from the sample, and other bits needed to make up a
<code>compcovar</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>two.level.components(data, data.columns, item.column)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="two.level.components_+3A_data">data</code></td>
<td>
<p>a <code>matrix</code>, or <code>data.frame</code>, of observations, with cases in rows,
and properties as columns</p>
</td></tr>
<tr><td><code id="two.level.components_+3A_data.columns">data.columns</code></td>
<td>
<p>a <code>vector</code> indicating which columns are the properties</p>
</td></tr>
<tr><td><code id="two.level.components_+3A_item.column">item.column</code></td>
<td>
<p>an integer indicating which column gives the item</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses ML estimation at the moment - this will almost certainly change in the future and
hopefully allow regularisation methods to get a more stable (and non-singular) estimate.
</p>


<h3>Value</h3>

<p>an object of class <code>compvar</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load Greg Zadora's glass data
data(glass)

# calculate a compcovar object based upon glass
# using K, Ca and Fe - warning - could take time
# on slower machines
Z = two.level.components(glass, c(7,8,9), 1)
</code></pre>

<hr>
<h2 id='two.level.density.LR'>Calculate the likelihood ratio using multivariate KDEs</h2><span id='topic+two.level.density.LR'></span>

<h3>Description</h3>

<p>Takes a <code>compitem</code> object which represents some control item, and a
<code>compitem</code> object which represents a recovered item, then uses information
from a <code>compcovar</code> object, which represents the
information from the population, to calculate a likelihood ratio as a measure
of the evidence given by the observations for the same/different source
propositions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>two.level.density.LR(control, recovered, background)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="two.level.density.LR_+3A_control">control</code></td>
<td>
<p>a <code>compitem</code> object with the control item information.</p>
</td></tr>
<tr><td><code id="two.level.density.LR_+3A_recovered">recovered</code></td>
<td>
<p>a <code>compitem</code> object with the recovered item information.</p>
</td></tr>
<tr><td><code id="two.level.density.LR_+3A_background">background</code></td>
<td>
<p>a <code>compcovar</code> object with the population information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an estimate of the likelihood ratio
</p>


<h3>References</h3>

<p>Aitken, C.G.G. &amp; Lucy, D. (2004) Evaluation of trace evidence in the form of multivariate data. <em>Applied Statistics</em>: <b>53</b>(1); 109-122.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(comparison)
# load Greg Zadora's glass data
data(glass)

# calculate a compcovar object based upon glass
# using K, Ca and Fe - warning - could take time
# on slower machines
Z = two.level.components(glass, c(7,8,9), 1)

# calculate a compitem object representing the control item
control = two.level.comparison.items(glass[1:6,], c(7,8,9))

# calculate a compitem object representing the recovered item
# known to be from the same item (item 1)
recovered.1 = two.level.comparison.items(glass[7:12,], c(7,8,9))

# calculate a compitem object representing the recovered item
# known to be from a different item (item 2)
recovered.2 = two.level.comparison.items(glass[19:24,], c(7,8,9))


# calculate the likelihood ratio for a known
# same source comparison - should be 20.59322
# 2020-08-01 Both this version and the previous version return 20.58967
lr.1 = two.level.density.LR(control, recovered.1, Z)
lr.1

# calculate the likelihood ratio for a known
# different source comparison - should be 0.02901532
# 2020-08-01 Both this version and the previous version return 0.01161392
lr.2 = two.level.density.LR(control, recovered.2, Z)
lr.2
</code></pre>

<hr>
<h2 id='two.level.lindley.LR'>Likelihood ratio calculation using Lindley's approach</h2><span id='topic+two.level.lindley.LR'></span>

<h3>Description</h3>

<p>Takes a <code>compitem</code> object which represents some control item, and a
<code>compitem</code> object which represents a recovered item, then uses information
from a <code>compcovar</code> object, which represents the information from the
population, to calculate a likelihood ratio as a measure of the evidence
given by the observations for the same/different source propositions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>two.level.lindley.LR(control, recovered, background)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="two.level.lindley.LR_+3A_control">control</code></td>
<td>
<p>a <code>compitem</code> object with the control item information</p>
</td></tr>
<tr><td><code id="two.level.lindley.LR_+3A_recovered">recovered</code></td>
<td>
<p>a <code>compitem</code> object with the recovered item information</p>
</td></tr>
<tr><td><code id="two.level.lindley.LR_+3A_background">background</code></td>
<td>
<p>a <code>compcovar</code> object with the population information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Does the likelihood ratio calculations for a two-level model
assuming that the between item distribution is univariate normal. This
function is taken from the approach devised by Denis Lindley in his 1977
paper (details below) and represents the progenitor of all the functions in
this package.
</p>


<h3>Value</h3>

<p>an estimate of the likelihood ratio
</p>


<h3>Author(s)</h3>

<p>David Lucy
</p>


<h3>References</h3>

<p>Lindley, D. (1977) A problem in forensic Science. <em>Biometrika</em>: <b>64</b>; 207-213.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load Greg Zadora's glass data
data(glass)

# calculate a compcovar object based upon dat
# using K
Z = two.level.components(glass, 7, 1)

# calculate a compitem object representing the control item
control = two.level.comparison.items(glass[1:6,], 7)

# calculate a compitem object representing the recovered item
# known to be from the same item (item 1)
recovered.1 = two.level.comparison.items(glass[7:12,], 7)

# calculate a compitem object representing the recovered item
# known to be from a different item (item 2)
recovered.2 = two.level.comparison.items(glass[19:24,], 7)


# calculate the likelihood ratio for a known
# same source comparison - should be 6.323941
# This value is 6.323327 in this version and in the last version written by David (1.0-4)
lr.1 = two.level.lindley.LR(control, recovered.1, Z)
lr.1

# calculate the likelihood ratio for a known
# different source comparison - should be 0.004422907
# This value is 0.004421978 in this version and the last version written by David (1.0-4)
lr.2 = two.level.lindley.LR(control, recovered.2, Z)
lr.2
</code></pre>

<hr>
<h2 id='two.level.normal.LR'>Likelihood ratio calculation - normal</h2><span id='topic+two.level.normal.LR'></span>

<h3>Description</h3>

<p>Takes a <code>compitem</code> object which represents some control item, and a
<code>compitem</code> object which represents a recovered item, then uses information
from a <code>compcovar</code> object, which represents the information from the
population, to calculate a likelihood ratio as a measure of the evidence
given by the observations for the same/different source propositions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>two.level.normal.LR(control, recovered, background)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="two.level.normal.LR_+3A_control">control</code></td>
<td>
<p>a <code>compitem</code> object with the control item information</p>
</td></tr>
<tr><td><code id="two.level.normal.LR_+3A_recovered">recovered</code></td>
<td>
<p>a <code>compitem</code> object with the recovered item information</p>
</td></tr>
<tr><td><code id="two.level.normal.LR_+3A_background">background</code></td>
<td>
<p>a <code>compcovar</code> object with the population information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Does the likelihood ratio calculations for a two-level model
assuming that the between item distribution is uni/multivariate normal.
</p>


<h3>Value</h3>

<p>an estimate of the likelihood ratio
</p>


<h3>Author(s)</h3>

<p>Agnieszka Martyna and David Lucy
</p>


<h3>References</h3>

<p>Aitken, C.G.G. &amp; Lucy, D. (2004) Evaluation of trace evidence in the form of multivariate data. <em>Applied Statistics</em>: <b>53</b>(1); 109-122.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load Greg Zadora's glass data
data(glass)

# calculate a compcovar object based upon glass
# using K, Ca and Fe - warning - could take time
# on slower machines
Z &lt;- two.level.components(glass, c(7,8,9), 1)

# calculate a compitem object representing the control item
control &lt;- two.level.comparison.items(glass[1:6,], c(7,8,9))

# calculate a compitem object representing the recovered item
# known to be from the same item (item 1)
recovered.1 &lt;- two.level.comparison.items(glass[7:12,], c(7,8,9))

# calculate a compitem object representing the recovered item
# known to be from a different item (item 2)
recovered.2 &lt;- two.level.comparison.items(glass[19:24,], c(7,8,9))


# calculate the likelihood ratio for a known
# same source comparison - should be 51.16539
# This value is 51.14243 in this version and the last version David wrote (1.0-4)
lr.1 &lt;- two.level.normal.LR(control, recovered.1, Z)
lr.1
# calculate the likelihood ratio for a known
# different source comparison - should be 0.02901532
# This value is 0.02899908 in this version and the last version David wrote (1.0-4)
lr.2 &lt;- two.level.normal.LR(control, recovered.2, Z)
lr.2
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
