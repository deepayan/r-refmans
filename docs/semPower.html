<!DOCTYPE html><html lang="en"><head><title>Help for package semPower</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {semPower}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#semPower'><p>semPower: Power analyses for structural equation models (SEM).</p></a></li>
<li><a href='#checkBounded'><p>checkBounded</p></a></li>
<li><a href='#checkComparisonModel'><p>checkComparisonModel</p></a></li>
<li><a href='#checkDataGenerationTypes'><p>checkDataGenerationTypes</p></a></li>
<li><a href='#checkEllipsis'><p>checkEllipsis</p></a></li>
<li><a href='#checkMissingTypes'><p>checkMissingTypes</p></a></li>
<li><a href='#checkNullEffect'><p>checkNullEffect</p></a></li>
<li><a href='#checkPositive'><p>checkPositive</p></a></li>
<li><a href='#checkPositiveDefinite'><p>checkPositiveDefinite</p></a></li>
<li><a href='#checkPowerTypes'><p>checkPowerTypes</p></a></li>
<li><a href='#checkSquare'><p>checkSquare</p></a></li>
<li><a href='#checkSymmetricSquare'><p>checkSymmetricSquare</p></a></li>
<li><a href='#doSim'><p>doSim</p></a></li>
<li><a href='#genData'><p>genData</p></a></li>
<li><a href='#genData.IG'><p>genData.IG</p></a></li>
<li><a href='#genData.mnonr'><p>genData.mnonr</p></a></li>
<li><a href='#genData.normal'><p>genData.normal</p></a></li>
<li><a href='#genData.RK'><p>genData.RK</p></a></li>
<li><a href='#genData.VM'><p>genData.VM</p></a></li>
<li><a href='#genLambda'><p>genLambda</p></a></li>
<li><a href='#genModelString'><p>genModelString</p></a></li>
<li><a href='#getAGFI.F'><p>getAGFI.F</p></a></li>
<li><a href='#getBetadiff'><p>getBetadiff</p></a></li>
<li><a href='#getCFI.Sigma'><p>getCFI.Sigma</p></a></li>
<li><a href='#getCFI.Sigma.mgroups'><p>getCFI.Sigma.mgroups</p></a></li>
<li><a href='#getChiSquare.F'><p>getChiSquare.F</p></a></li>
<li><a href='#getChiSquare.NCP'><p>getChiSquare.NCP</p></a></li>
<li><a href='#getDiscrepancyFunctionFromFittingFunction'><p>getDiscrepancyFunctionFromFittingFunction</p></a></li>
<li><a href='#getErrorDiff'><p>getErrorDiff</p></a></li>
<li><a href='#getF'><p>getF</p></a></li>
<li><a href='#getF.AGFI'><p>getF.AGFI</p></a></li>
<li><a href='#getF.GFI'><p>getF.GFI</p></a></li>
<li><a href='#getF.Mc'><p>getF.Mc</p></a></li>
<li><a href='#getF.RMSEA'><p>getF.RMSEA</p></a></li>
<li><a href='#getF.Sigma'><p>getF.Sigma</p></a></li>
<li><a href='#getFittingFunctionFromEstimator'><p>getFittingFunctionFromEstimator</p></a></li>
<li><a href='#getFormattedResults'><p>getFormattedResults</p></a></li>
<li><a href='#getFormattedSimulationResults'><p>getFormattedResults</p></a></li>
<li><a href='#getGFI.F'><p>getGFI.F</p></a></li>
<li><a href='#getIndices.F'><p>getIndices.F</p></a></li>
<li><a href='#getKSdistance'><p>getKSdistance</p></a></li>
<li><a href='#getLavOptions'><p>getLavOptions</p></a></li>
<li><a href='#getMc.F'><p>getMc.F</p></a></li>
<li><a href='#getNCP'><p>getNCP</p></a></li>
<li><a href='#getPhi.B'><p>getPhi.B</p></a></li>
<li><a href='#getPsi.B'><p>getPsi.B</p></a></li>
<li><a href='#getRMSEA.F'><p>getRMSEA.F</p></a></li>
<li><a href='#getSRMR.Sigma'><p>getSRMR.Sigma</p></a></li>
<li><a href='#getSRMR.Sigma.mgroups'><p>getSRMR.Sigma.mgroups</p></a></li>
<li><a href='#getWLSv'><p>getWLSv</p></a></li>
<li><a href='#makeRestrictionsLavFriendly'><p>makeRestrictionsLavFriendly</p></a></li>
<li><a href='#orderLavCov'><p>orderLavCov</p></a></li>
<li><a href='#orderLavMu'><p>orderLavMu</p></a></li>
<li><a href='#orderLavResults'><p>orderLavResults</p></a></li>
<li><a href='#powerPrepare'><p>powerPrepare</p></a></li>
<li><a href='#semPower.aPriori'><p>semPower.aPriori</p></a></li>
<li><a href='#semPower.compromise'><p>semPower.compromise</p></a></li>
<li><a href='#semPower.genSigma'><p>semPower.genSigma</p></a></li>
<li><a href='#semPower.getDf'><p>semPower.getDf</p></a></li>
<li><a href='#semPower.postHoc'><p>semPower.postHoc</p></a></li>
<li><a href='#semPower.powerARMA'><p>semPower.powerARMA</p></a></li>
<li><a href='#semPower.powerAutoreg'><p>semPower.powerAutoreg</p></a></li>
<li><a href='#semPower.powerBifactor'><p>semPower.powerBifactor</p></a></li>
<li><a href='#semPower.powerCFA'><p>semPower.powerCFA</p></a></li>
<li><a href='#semPower.powerCLPM'><p>semPower.powerCLPM</p></a></li>
<li><a href='#semPower.powerLav'><p>semPower.powerLav</p></a></li>
<li><a href='#semPower.powerLGCM'><p>semPower.powerLGCM</p></a></li>
<li><a href='#semPower.powerLI'><p>semPower.powerLI</p></a></li>
<li><a href='#semPower.powerMediation'><p>semPower.powerMediation</p></a></li>
<li><a href='#semPower.powerMI'><p>semPower.powerMI</p></a></li>
<li><a href='#semPower.powerPath'><p>semPower.powerPath</p></a></li>
<li><a href='#semPower.powerPlot'><p>semPower.powerPlot</p></a></li>
<li><a href='#semPower.powerPlot.byEffect'><p>semPower.powerPlot.byEffect</p></a></li>
<li><a href='#semPower.powerPlot.byN'><p>semPower.powerPlot.byN</p></a></li>
<li><a href='#semPower.powerRegression'><p>semPower.powerRegression</p></a></li>
<li><a href='#semPower.powerRICLPM'><p>semPower.powerRICLPM</p></a></li>
<li><a href='#semPower.showPlot'><p>semPower.showPlot</p></a></li>
<li><a href='#simulate'><p>simulate</p></a></li>
<li><a href='#summary.semPower.aPriori'><p>summary.semPower.aPriori</p></a></li>
<li><a href='#summary.semPower.compromise'><p>summary.sempower.compromise</p></a></li>
<li><a href='#summary.semPower.postHoc'><p>semPower.postHoc.summary</p></a></li>
<li><a href='#validateInput'><p>validateInput</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Power Analyses for SEM</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a-priori, post-hoc, and compromise power-analyses
    for structural equation models (SEM).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a> | <a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/moshagen/semPower">https://github.com/moshagen/semPower</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/moshagen/semPower/issues">https://github.com/moshagen/semPower/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bookdown, covsim, doFuture, foreach, future, knitr, lavaan,
mnonr, progressr, rmarkdown,</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-29 10:25:37 UTC; morten</td>
</tr>
<tr>
<td>Author:</td>
<td>Morten Moshagen <a href="https://orcid.org/0000-0002-2929-7288"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Martina Bader <a href="https://orcid.org/0000-0002-5706-8933"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Morten Moshagen &lt;morten.moshagen@uni-ulm.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-29 10:40:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='semPower'>semPower: Power analyses for structural equation models (SEM).</h2><span id='topic+semPower-package'></span><span id='topic+semPower'></span>

<h3>Description</h3>

<p>semPower allows for performing a-priori, post-hoc, and compromise power-analyses for structural equation models (SEM).
</p>
<p>Perform a power analysis. This is a wrapper function for a-priori, post-hoc, and compromise power analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semPower(type, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semPower_+3A_type">type</code></td>
<td>
<p>type of power analysis, one of <code>'a-priori'</code>, <code>'post-hoc'</code>, <code>'compromise'</code>.</p>
</td></tr>
<tr><td><code id="semPower_+3A_...">...</code></td>
<td>
<p>other parameters related to the specific type of power analysis requested.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> A-priori power analysis <code><a href="#topic+semPower.aPriori">semPower.aPriori</a></code> computes the required N, given an effect, alpha, power, and the model df
</p>
</li>
<li><p> Post-hoc power analysis <code><a href="#topic+semPower.postHoc">semPower.postHoc</a></code> computes the achieved power, given an effect, alpha, N, and the model df
</p>
</li>
<li><p> Compromise power analysis <code><a href="#topic+semPower.compromise">semPower.compromise</a></code> computes the implied alpha and power, given an effect, the alpha/beta ratio, N, and the model df
</p>
</li></ul>

<p>In SEM, the discrepancy between H0 and H1 (the magnitude of effect) refers to the difference in fit between two models. If only one model is defined (which is the default), power refers to the global chi-square test. If both models are explicitly defined, power is computed for nested model tests.  semPower allows for expressing the magnitude of effect by one of the following measures: F0, RMSEA, Mc, GFI, or AGFI.
</p>
<p>Alternatively, the implied effect can also be computed from the discrepancy between the population (or a certain model-implied) covariance matrix defining H0 and the hypothesized (model-implied) covariance matrix from a nested model defining H1. See the examples below how to use this feature in conjunction with lavaan.
</p>


<h3>Value</h3>

<p>list
</p>


<h3>Author(s)</h3>

<p>Morten Moshagen <a href="mailto:morten.moshagen@uni-ulm.de">morten.moshagen@uni-ulm.de</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/moshagen/semPower">https://github.com/moshagen/semPower</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/moshagen/semPower/issues">https://github.com/moshagen/semPower/issues</a>
</p>
</li></ul>

<p><code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code>, <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code>, <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a-priori power analyses using rmsea = .05 a target power (1-beta) of .80
ap1 &lt;- semPower.aPriori(0.05, 'RMSEA', alpha = .05, beta = .20, df = 200)
summary(ap1)
# generic version
gap1 &lt;- semPower(type = 'a-priori', 0.05, 'RMSEA', alpha = .05, beta = .20, df = 200)
summary(gap1)
# a-priori power analyses using f0 = .75 and a target power of .95
ap2 &lt;- semPower.aPriori(0.75, 'F0', alpha = .05, power = .95, df = 200)
summary(ap2)
# create a plot showing how power varies by N (given a certain effect)
semPower.powerPlot.byN(.05, 'RMSEA', alpha=.05, df=200, power.min=.05, power.max=.99)
# post-hoc power analyses using rmsea = .08
ph &lt;- semPower.postHoc(.08, 'RMSEA', alpha = .05, N = 250, df = 50)
summary(ph)
# generic version
gph1 &lt;- semPower(type = 'post-hoc', .08, 'RMSEA', alpha = .05, N = 250, df = 50)
summary(gph1)
# create a plot showing how power varies by the magnitude of effect (given a certain N)
semPower.powerPlot.byEffect('RMSEA', alpha=.05, N = 100, df=200, effect.min=.001, effect.max=.10)
# compromise power analyses using rmsea = .08 and an abratio of 2
cp &lt;- semPower.compromise(.08, 'RMSEA', abratio = 2, N = 1000, df = 200)
summary(cp)
# generic version
gcp &lt;- semPower(type = 'compromise', .08, 'RMSEA', abratio = 2, N = 1000, df = 200)
summary(gcp)

# use lavaan to define effect through covariance matrices:
## Not run: 
library(lavaan)

# define population model (= H1)
model.pop &lt;- '
f1 =~ .8*x1 + .7*x2 + .6*x3
f2 =~ .7*x4 + .6*x5 + .5*x6
f1 ~~ 1*f1
f2 ~~ 1*f2
f1 ~~ 0.5*f2
'
# define (wrong) H0 model
model.h0 &lt;- '
f1 =~ x1 + x2 + x3
f2 =~ x4 + x5 + x6
f1 ~~ 0*f2
'

# get population covariance matrix; equivalent to a perfectly fitting H1 model
cov.h1 &lt;- fitted(sem(model.pop))$cov
# get covariance matrix as implied by H0 model
res.h0 &lt;- sem(model.h0, sample.cov = cov.h1, sample.nobs = 1000, 
              likelihood='wishart', sample.cov.rescale = F)
df &lt;- res.h0@test[[1]]$df
cov.h0 &lt;- fitted(res.h0)$cov

## do power analyses

# post-hoc
ph &lt;- semPower.postHoc(SigmaHat = cov.h0, Sigma = cov.h1, alpha = .05, N = 1000, df = df)
summary(ph)
# =&gt; Power to reject the H1 model is &gt; .9999 (1-beta = 1-1.347826e-08) with N = 1000 at alpha=.05

# compare:
ph$fmin * (ph$N-1)
fitmeasures(res.h1, 'chisq')
# =&gt; expected chi-square matches empirical chi-square

# a-priori
ap &lt;- semPower.aPriori(SigmaHat = cov.h0, Sigma = cov.h1, alpha = .05, power = .80, df = df)
summary(ap)
# =&gt; N = 194 gives a power of ~80% to reject the H1 model at alpha = .05

# compromise
cp &lt;- semPower.compromise(SigmaHat = cov.h0, Sigma = cov.h1, abratio = 1, N = 1000, df = df)
summary(cp)
# =&gt; A critical Chi-Squared of 33.999 gives balanced alpha-beta
#    error probabilities of alpha=beta=0.000089 with N = 1000.


## End(Not run)

## Not run: 

ap &lt;- semPower(type = 'a-priori', 
               effect = .08, effect.measure = "RMSEA", 
               alpha = .05, beta = .05, df = 200)
summary(ph)

ph &lt;- semPower(type = 'post-hoc', 
               effect = .08, effect.measure = "RMSEA", 
               alpha = .05, N = 250, df = 200)
summary(ph)

cp &lt;- semPower(type = 'compromise', 
               effect = .08, effect.measure = "RMSEA", 
               abratio = 1, N = 250, df = 200)
summary(ph)

## End(Not run)
</code></pre>

<hr>
<h2 id='checkBounded'>checkBounded</h2><span id='topic+checkBounded'></span>

<h3>Description</h3>

<p>Checks whether x is defined and lies within the specified bound, stop otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkBounded(x, message = NULL, bound = c(0, 1), inclusive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkBounded_+3A_x">x</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="checkBounded_+3A_message">message</code></td>
<td>
<p>identifier for x</p>
</td></tr>
<tr><td><code id="checkBounded_+3A_bound">bound</code></td>
<td>
<p>the boundaries, array of size two</p>
</td></tr>
<tr><td><code id="checkBounded_+3A_inclusive">inclusive</code></td>
<td>
<p>whether x might lie on boundary</p>
</td></tr>
</table>

<hr>
<h2 id='checkComparisonModel'>checkComparisonModel</h2><span id='topic+checkComparisonModel'></span>

<h3>Description</h3>

<p>Checks whether comparison is one of <code>'restricted'</code> or <code>'saturated'</code> (or respective shortcuts), stop otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkComparisonModel(comparison)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkComparisonModel_+3A_comparison">comparison</code></td>
<td>
<p>comparison</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns cleaned comparison
</p>

<hr>
<h2 id='checkDataGenerationTypes'>checkDataGenerationTypes</h2><span id='topic+checkDataGenerationTypes'></span>

<h3>Description</h3>

<p>Checks whether data generation type is one of <code>'normal'</code>, <code>'IG'</code>, <code>'mnonr'</code>, <code>'RK'</code>, or <code>'VM'</code>, stop otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkDataGenerationTypes(type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkDataGenerationTypes_+3A_type">type</code></td>
<td>
<p>type</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns cleaned data generation type
</p>

<hr>
<h2 id='checkEllipsis'>checkEllipsis</h2><span id='topic+checkEllipsis'></span>

<h3>Description</h3>

<p>Checks whether <code>...</code> contains arguments related to loadings and to power, stop otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkEllipsis(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkEllipsis_+3A_...">...</code></td>
<td>
<p>the parameters to search.</p>
</td></tr>
</table>

<hr>
<h2 id='checkMissingTypes'>checkMissingTypes</h2><span id='topic+checkMissingTypes'></span>

<h3>Description</h3>

<p>Checks whether missing generation type is one of <code>'mcar'</code>, <code>'mar'</code>, or <code>'nmar'</code>, stop otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkMissingTypes(type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkMissingTypes_+3A_type">type</code></td>
<td>
<p>type</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns cleaned data generation type
</p>

<hr>
<h2 id='checkNullEffect'>checkNullEffect</h2><span id='topic+checkNullEffect'></span>

<h3>Description</h3>

<p>Checks whether <code>nullEffect</code> is one of the valid effects, stop otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkNullEffect(nullEffect, valid, message = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkNullEffect_+3A_nulleffect">nullEffect</code></td>
<td>
<p>nullEffect</p>
</td></tr>
<tr><td><code id="checkNullEffect_+3A_valid">valid</code></td>
<td>
<p>vector of valid effects</p>
</td></tr>
<tr><td><code id="checkNullEffect_+3A_message">message</code></td>
<td>
<p>message</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns cleaned nullEffect
</p>

<hr>
<h2 id='checkPositive'>checkPositive</h2><span id='topic+checkPositive'></span>

<h3>Description</h3>

<p>Checks whether <code>x</code> is defined and a positive number, stop otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkPositive(x, message = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkPositive_+3A_x">x</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="checkPositive_+3A_message">message</code></td>
<td>
<p>identifier for <code>x</code></p>
</td></tr>
</table>

<hr>
<h2 id='checkPositiveDefinite'>checkPositiveDefinite</h2><span id='topic+checkPositiveDefinite'></span>

<h3>Description</h3>

<p>Checks whether <code>x</code> is positive definite, stop otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkPositiveDefinite(x, message = NULL, stop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkPositiveDefinite_+3A_x">x</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="checkPositiveDefinite_+3A_message">message</code></td>
<td>
<p>identifier for <code>x</code></p>
</td></tr>
<tr><td><code id="checkPositiveDefinite_+3A_stop">stop</code></td>
<td>
<p>whether to stop or to throw a warning</p>
</td></tr>
</table>

<hr>
<h2 id='checkPowerTypes'>checkPowerTypes</h2><span id='topic+checkPowerTypes'></span>

<h3>Description</h3>

<p>Checks whether type is one of <code>'a-priori'</code>, <code>'post-hoc'</code>, or <code>'compromise'</code> (or respective shortcuts), stop otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkPowerTypes(type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkPowerTypes_+3A_type">type</code></td>
<td>
<p>type</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns cleaned type
</p>

<hr>
<h2 id='checkSquare'>checkSquare</h2><span id='topic+checkSquare'></span>

<h3>Description</h3>

<p>Checks whether <code>x</code> is a square matrix, stop otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkSquare(x, message = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkSquare_+3A_x">x</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="checkSquare_+3A_message">message</code></td>
<td>
<p>identifier for <code>x</code></p>
</td></tr>
</table>

<hr>
<h2 id='checkSymmetricSquare'>checkSymmetricSquare</h2><span id='topic+checkSymmetricSquare'></span>

<h3>Description</h3>

<p>Checks whether <code>x</code> is a symmetric square matrix, stop otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkSymmetricSquare(x, message = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkSymmetricSquare_+3A_x">x</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="checkSymmetricSquare_+3A_message">message</code></td>
<td>
<p>identifier for <code>x</code></p>
</td></tr>
</table>

<hr>
<h2 id='doSim'>doSim</h2><span id='topic+doSim'></span>

<h3>Description</h3>

<p>Generates random data from population variance-covariance matrix and population means, either
from a multivariate normal distribution, or using one of various approaches to generate
non-normal data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doSim(
  r,
  simData,
  isMultigroup = FALSE,
  modelH0,
  modelH1,
  lavOptions,
  lavOptionsH1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="doSim_+3A_r">r</code></td>
<td>
<p>replication id</p>
</td></tr>
<tr><td><code id="doSim_+3A_simdata">simData</code></td>
<td>
<p>list of datafiles</p>
</td></tr>
<tr><td><code id="doSim_+3A_ismultigroup">isMultigroup</code></td>
<td>
<p>multigroup flag</p>
</td></tr>
<tr><td><code id="doSim_+3A_modelh0">modelH0</code></td>
<td>
<p><code>lavaan</code> model string defining the (incorrect) analysis model.</p>
</td></tr>
<tr><td><code id="doSim_+3A_modelh1">modelH1</code></td>
<td>
<p><code>lavaan</code> model string defining the comparison model. If omitted, the saturated model is the comparison model.</p>
</td></tr>
<tr><td><code id="doSim_+3A_lavoptions">lavOptions</code></td>
<td>
<p>a list of additional options passed to <code>lavaan</code>, e. g., <code>list(estimator = 'mlm')</code> to request robust ML estimation</p>
</td></tr>
<tr><td><code id="doSim_+3A_lavoptionsh1">lavOptionsH1</code></td>
<td>
<p>lavoptions when fitting <code>modelH1</code>. If <code>NULL</code>, the same as <code>lavOptions</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>

<hr>
<h2 id='genData'>genData</h2><span id='topic+genData'></span>

<h3>Description</h3>

<p>Generates random data from population variance-covariance matrix and population means, either
from a multivariate normal distribution, or using one of various approaches to generate
non-normal data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genData(
  N = NULL,
  Sigma = NULL,
  mu = NULL,
  nSets = 1,
  gIdx = NULL,
  modelH0 = NULL,
  simOptions = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genData_+3A_n">N</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="genData_+3A_sigma">Sigma</code></td>
<td>
<p>population covariance matrix.</p>
</td></tr>
<tr><td><code id="genData_+3A_mu">mu</code></td>
<td>
<p>population means.</p>
</td></tr>
<tr><td><code id="genData_+3A_nsets">nSets</code></td>
<td>
<p>number of data sets to generate</p>
</td></tr>
<tr><td><code id="genData_+3A_gidx">gIdx</code></td>
<td>
<p>if not <code>NULL</code>, add gIdx as numeric group index as additional variable to generated data</p>
</td></tr>
<tr><td><code id="genData_+3A_modelh0">modelH0</code></td>
<td>
<p>a <code>lavaan</code> model string, only used to determine the number of factors when <code>type = 'RK'</code></p>
</td></tr>
<tr><td><code id="genData_+3A_simoptions">simOptions</code></td>
<td>
<p>additional arguments specifying the data generation routine</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the generated data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gen &lt;- semPower.genSigma(Phi = .2, loadings = list(rep(.5, 3), rep(.7, 3)))
data &lt;- genData(N = 500, Sigma = gen$Sigma) 

## End(Not run)
</code></pre>

<hr>
<h2 id='genData.IG'>genData.IG</h2><span id='topic+genData.IG'></span>

<h3>Description</h3>

<p>Generates random data conforming to a population variance-covariance matrix using
the independent generator approach (IG, Foldnes &amp; Olsson, 2016) approach
specifying third and fourth moments of the marginals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genData.IG(N = NULL, Sigma = NULL, nSets = 1, skewness = NULL, kurtosis = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genData.IG_+3A_n">N</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="genData.IG_+3A_sigma">Sigma</code></td>
<td>
<p>population covariance matrix.</p>
</td></tr>
<tr><td><code id="genData.IG_+3A_nsets">nSets</code></td>
<td>
<p>number of data sets to generate</p>
</td></tr>
<tr><td><code id="genData.IG_+3A_skewness">skewness</code></td>
<td>
<p>vector specifying skewness for each variable</p>
</td></tr>
<tr><td><code id="genData.IG_+3A_kurtosis">kurtosis</code></td>
<td>
<p>vector specifying excess kurtosis for each variable</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for the respective function of the <code>covsim</code> package.
</p>
<p>For details, see
Foldnes, N. &amp; Olsson, U. H. (2016) A Simple Simulation Technique for Nonnormal Data with Prespecified Skewness, Kurtosis, and Covariance Matrix. <em>Multivariate Behavioral Research, 51</em>, 207-219. 10.1080/00273171.2015.1133274
</p>


<h3>Value</h3>

<p>Returns the generated data
</p>

<hr>
<h2 id='genData.mnonr'>genData.mnonr</h2><span id='topic+genData.mnonr'></span>

<h3>Description</h3>

<p>Generates random data conforming to a population variance-covariance matrix using
the approach by Qu, Liu, &amp; Zhang (2020) specifying Mardia's multivariate skewness and kurtosis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genData.mnonr(
  N = NULL,
  Sigma = NULL,
  nSets = 1,
  skewness = NULL,
  kurtosis = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genData.mnonr_+3A_n">N</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="genData.mnonr_+3A_sigma">Sigma</code></td>
<td>
<p>population covariance matrix.</p>
</td></tr>
<tr><td><code id="genData.mnonr_+3A_nsets">nSets</code></td>
<td>
<p>number of data sets to generate</p>
</td></tr>
<tr><td><code id="genData.mnonr_+3A_skewness">skewness</code></td>
<td>
<p>multivariate skewness. May not be negative.</p>
</td></tr>
<tr><td><code id="genData.mnonr_+3A_kurtosis">kurtosis</code></td>
<td>
<p>multivariate kurtosis. Must be &gt;= 1.641 skewness + p (p + 0.774), where p is the number of variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for the respective function of the <code>mnonr</code> package.
</p>
<p>For details, see
Qu, W., Liu, H., &amp; Zhang, Z. (2020). A method of generating multivariate non-normal random numbers with desired multivariate skewness and kurtosis. <em>Behavior Research Methods, 52</em>, 939-946. doi: 10.3758/s13428-019-01291-5
</p>


<h3>Value</h3>

<p>Returns the generated data
</p>

<hr>
<h2 id='genData.normal'>genData.normal</h2><span id='topic+genData.normal'></span>

<h3>Description</h3>

<p>Generates multivariate normal random data conforming to a population variance-covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genData.normal(N = NULL, Sigma = NULL, nSets = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genData.normal_+3A_n">N</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="genData.normal_+3A_sigma">Sigma</code></td>
<td>
<p>population covariance matrix.</p>
</td></tr>
<tr><td><code id="genData.normal_+3A_nsets">nSets</code></td>
<td>
<p>number of data sets to generate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the generated data
</p>

<hr>
<h2 id='genData.RK'>genData.RK</h2><span id='topic+genData.RK'></span>

<h3>Description</h3>

<p>Generates random data conforming to a population variance-covariance matrix using
the approach by Ruscio &amp; Kaczetow (2008)
specifying distributions for the marginals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genData.RK(
  N = NULL,
  Sigma = NULL,
  nSets = 1,
  distributions = NULL,
  modelH0 = NULL,
  maxIter = 10
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genData.RK_+3A_n">N</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="genData.RK_+3A_sigma">Sigma</code></td>
<td>
<p>population covariance matrix.</p>
</td></tr>
<tr><td><code id="genData.RK_+3A_nsets">nSets</code></td>
<td>
<p>number of data sets to generate</p>
</td></tr>
<tr><td><code id="genData.RK_+3A_distributions">distributions</code></td>
<td>
<p>a list specifying the population distribution and  additional arguments in a list either to apply to all variables (e.g. <code>list(rchisq, list(df = 2))</code>) or a list of lists specifying the distributions for each variable. See examples.</p>
</td></tr>
<tr><td><code id="genData.RK_+3A_modelh0">modelH0</code></td>
<td>
<p>a <code>lavaan</code> model string, only used to determine the number of factors.</p>
</td></tr>
<tr><td><code id="genData.RK_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations, defaults to 10.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on the implementation by Ruscio &amp; Kaczetow (2008).
</p>
<p>For details, see
Ruscio, J., &amp; Kaczetow, W. (2008). Simulating multivariate nonnormal data using an iterative algorithm. <em>Multivariate Behavioral Research, 43</em>, 355-381.
</p>


<h3>Value</h3>

<p>Returns the generated data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
distributions &lt;- list(
  list('rchisq', list(df = 2)),
  list('runif', list(min = 0, max = 1)),
  list('rexp', list(rate = 1))
)
data &lt;- genData.ruscio(N = 100, Sigma = diag(3),
                       distributions = distributions, 
                       modelH0 = 'f =~ x1 + x2 + x3')
                       
distributions &lt;- list(
  list('rnorm', list(mean = 0, sd = 10)),
  list('runif', list(min = 0, max = 1)),
  list('rbeta', list(shape1 = 1, shape2 = 2)),
  list('rexp', list(rate = 1)),
  list('rpois', list(lambda = 4)),
  list('rbinom', list(size = 1, prob = .5))
)
data &lt;- genData.ruscio(N = 100, Sigma = diag(6),
                       distributions = distributions, 
                       modelH0 = 'f1=~x1+x2+x3\nf2=~x4+x5+x6')


## End(Not run)
</code></pre>

<hr>
<h2 id='genData.VM'>genData.VM</h2><span id='topic+genData.VM'></span>

<h3>Description</h3>

<p>Generates random data conforming to a population variance-covariance matrix using
the third-order polynomial method  (Vale &amp; Maurelli, 1983)
specifying third and fourth moments of the marginals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genData.VM(N = NULL, Sigma = NULL, nSets = 1, skewness = NULL, kurtosis = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genData.VM_+3A_n">N</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="genData.VM_+3A_sigma">Sigma</code></td>
<td>
<p>population covariance matrix.</p>
</td></tr>
<tr><td><code id="genData.VM_+3A_nsets">nSets</code></td>
<td>
<p>number of data sets to generate</p>
</td></tr>
<tr><td><code id="genData.VM_+3A_skewness">skewness</code></td>
<td>
<p>vector specifying skewness for each variable</p>
</td></tr>
<tr><td><code id="genData.VM_+3A_kurtosis">kurtosis</code></td>
<td>
<p>vector specifying excess kurtosis for each variable</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a slightly adapted copy of <code>lavaan</code>'s ValeMaurelli1983 implementation
that avoids computing the intermediate correlation for each data sets
and uses Sigma as input.
</p>
<p>For details, see
Vale, C. &amp; Maurelli, V. (1983). Simulating multivariate nonnormal distributions. <em>Psychometrika, 48</em>, 465-471.
</p>


<h3>Value</h3>

<p>Returns the generated data
</p>

<hr>
<h2 id='genLambda'>genLambda</h2><span id='topic+genLambda'></span>

<h3>Description</h3>

<p>Generate a loading matrix Lambda from various shortcuts, each assuming a simple structure.
Either define <code>loadings</code>, or define <code>nIndicator</code> and <code>loadM</code> (and optionally <code>loadSD</code>), or define
<code>nIndicator</code> and <code>loadMinMax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genLambda(
  loadings = NULL,
  nIndicator = NULL,
  loadM = NULL,
  loadSD = NULL,
  loadMinMax = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genLambda_+3A_loadings">loadings</code></td>
<td>
<p>A list providing the loadings by factor, e. g. <code>list(c(.4, .5, .6), c(7, .8, .8))</code> to define two factors with three indicators each with the specified loadings. The vectors must not contain secondary loadings.</p>
</td></tr>
<tr><td><code id="genLambda_+3A_nindicator">nIndicator</code></td>
<td>
<p>Vector indicating the number of indicators for each factor, e. g. <code>c(4, 6)</code> to define two factors with 4 and 6 indicators, respectively</p>
</td></tr>
<tr><td><code id="genLambda_+3A_loadm">loadM</code></td>
<td>
<p>Either a vector giving the mean loadings for each factor or a single number to use for every loading.</p>
</td></tr>
<tr><td><code id="genLambda_+3A_loadsd">loadSD</code></td>
<td>
<p>Either a vector giving the standard deviation of loadings for each factor or a single number, for use in conjunction with <code>loadM</code>. If <code>NULL</code>, SDs are set to zero. Otherwise, loadings are sampled from a normal distribution.</p>
</td></tr>
<tr><td><code id="genLambda_+3A_loadminmax">loadMinMax</code></td>
<td>
<p>A list giving the minimum and maximum loading for each factor or a vector to apply to all factors. If set, loadings are sampled from a uniform distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The loading matrix Lambda.
</p>

<hr>
<h2 id='genModelString'>genModelString</h2><span id='topic+genModelString'></span>

<h3>Description</h3>

<p>Creates <code>lavaan</code> model strings from model matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genModelString(
  Lambda = NULL,
  Phi = NULL,
  Beta = NULL,
  Psi = NULL,
  Theta = NULL,
  tau = NULL,
  Alpha = NULL,
  useReferenceIndicator = !is.null(Beta),
  metricInvariance = NULL,
  nGroups = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genModelString_+3A_lambda">Lambda</code></td>
<td>
<p>Factor loading matrix.</p>
</td></tr>
<tr><td><code id="genModelString_+3A_phi">Phi</code></td>
<td>
<p>Factor correlation (or covariance) matrix. If <code>NULL</code>, all factors are orthogonal.</p>
</td></tr>
<tr><td><code id="genModelString_+3A_beta">Beta</code></td>
<td>
<p>Regression slopes between latent variables (all-y notation).</p>
</td></tr>
<tr><td><code id="genModelString_+3A_psi">Psi</code></td>
<td>
<p>Variance-covariance matrix of latent residuals when <code>Beta</code> is specified. If <code>NULL</code>, a diagonal matrix is assumed.</p>
</td></tr>
<tr><td><code id="genModelString_+3A_theta">Theta</code></td>
<td>
<p>Variance-covariance matrix of manifest residuals. If <code>NULL</code> and <code>Lambda</code> is not a square matrix, <code>Theta</code> is diagonal so that the manifest variances are 1. If <code>NULL</code> and <code>Lambda</code> is square, <code>Theta</code> is 0.</p>
</td></tr>
<tr><td><code id="genModelString_+3A_tau">tau</code></td>
<td>
<p>Intercepts. If <code>NULL</code> and<code> Alpha</code> is set, these are assumed to be zero.</p>
</td></tr>
<tr><td><code id="genModelString_+3A_alpha">Alpha</code></td>
<td>
<p>Factor means. If <code>NULL</code> and <code>tau</code> is set, these are assumed to be zero.</p>
</td></tr>
<tr><td><code id="genModelString_+3A_usereferenceindicator">useReferenceIndicator</code></td>
<td>
<p>Whether to identify factors in accompanying model strings by a reference indicator (<code>TRUE</code>) or by setting their variance to 1 (<code>FALSE</code>). When <code>Beta</code> is defined, a reference indicator is used by default, otherwise the variance approach.</p>
</td></tr>
<tr><td><code id="genModelString_+3A_metricinvariance">metricInvariance</code></td>
<td>
<p>A list containing the factor indices for which the accompanying model strings should apply metric invariance labels, e.g. <code>list(c(1, 2), c(3, 4))</code> to assume invariance for f1 and f2 as well as f3 and f4.</p>
</td></tr>
<tr><td><code id="genModelString_+3A_ngroups">nGroups</code></td>
<td>
<p>(defaults to 1) If &gt; 1 and <code>metricInvariance = TRUE</code>, group specific labels will be used in the measurement model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following <code>lavaan</code> model strings:
</p>
<table role = "presentation">
<tr><td><code>modelPop</code></td>
<td>
<p>population model</p>
</td></tr>
<tr><td><code>modelTrue</code></td>
<td>
<p>&quot;true&quot; analysis model freely estimating all non-zero parameters.</p>
</td></tr>
<tr><td><code>modelTrueCFA</code></td>
<td>
<p>similar to <code>modelTrue</code>, but purely CFA based and thus omitting any regression relationships.</p>
</td></tr>
</table>

<hr>
<h2 id='getAGFI.F'>getAGFI.F</h2><span id='topic+getAGFI.F'></span>

<h3>Description</h3>

<p>Computes AGFI from the minimum of the ML-fit-function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAGFI.F(Fmin, df, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getAGFI.F_+3A_fmin">Fmin</code></td>
<td>
<p>minimum of the ML-fit-function</p>
</td></tr>
<tr><td><code id="getAGFI.F_+3A_df">df</code></td>
<td>
<p>model degrees of freedom</p>
</td></tr>
<tr><td><code id="getAGFI.F_+3A_p">p</code></td>
<td>
<p>number of observed variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns AGFI
</p>

<hr>
<h2 id='getBetadiff'>getBetadiff</h2><span id='topic+getBetadiff'></span>

<h3>Description</h3>

<p>get squared difference between requested and achieved beta on a logscale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBetadiff(
  cN,
  critChi,
  logBetaTarget,
  fmin,
  df,
  weights = NULL,
  simulatedPower = FALSE,
  pkgEnv = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getBetadiff_+3A_cn">cN</code></td>
<td>
<p>current N</p>
</td></tr>
<tr><td><code id="getBetadiff_+3A_critchi">critChi</code></td>
<td>
<p>critical chi-square associated with chosen alpha error</p>
</td></tr>
<tr><td><code id="getBetadiff_+3A_logbetatarget">logBetaTarget</code></td>
<td>
<p>log(desired beta)</p>
</td></tr>
<tr><td><code id="getBetadiff_+3A_fmin">fmin</code></td>
<td>
<p>minimum of the ML fit function</p>
</td></tr>
<tr><td><code id="getBetadiff_+3A_df">df</code></td>
<td>
<p>the model degrees of freedom</p>
</td></tr>
<tr><td><code id="getBetadiff_+3A_weights">weights</code></td>
<td>
<p>sample weights for multiple group models</p>
</td></tr>
<tr><td><code id="getBetadiff_+3A_simulatedpower">simulatedPower</code></td>
<td>
<p>whether to perform a simulated (TRUE) (rather than analytical, FALSE) power analysis.</p>
</td></tr>
<tr><td><code id="getBetadiff_+3A_pkgenv">pkgEnv</code></td>
<td>
<p>local pkgEnv containing iterationCounter.</p>
</td></tr>
<tr><td><code id="getBetadiff_+3A_...">...</code></td>
<td>
<p>other parameter passed to simulate()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>squared difference requested and achieved beta on a log scale
</p>

<hr>
<h2 id='getCFI.Sigma'>getCFI.Sigma</h2><span id='topic+getCFI.Sigma'></span>

<h3>Description</h3>

<p>Computes CFI given the model-implied and the observed (or population) covariance matrix:
<code>CFI = (F_null - F_hyp) / F_null</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCFI.Sigma(SigmaHat, S, muHat = NULL, mu = NULL, fittingFunction = "ML")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCFI.Sigma_+3A_sigmahat">SigmaHat</code></td>
<td>
<p>model implied covariance matrix</p>
</td></tr>
<tr><td><code id="getCFI.Sigma_+3A_s">S</code></td>
<td>
<p>observed (or population) covariance matrix</p>
</td></tr>
<tr><td><code id="getCFI.Sigma_+3A_muhat">muHat</code></td>
<td>
<p>model implied mean vector</p>
</td></tr>
<tr><td><code id="getCFI.Sigma_+3A_mu">mu</code></td>
<td>
<p>observed (or population) mean vector</p>
</td></tr>
<tr><td><code id="getCFI.Sigma_+3A_fittingfunction">fittingFunction</code></td>
<td>
<p>whether to use <code>ML</code> or <code>WLS</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns CFI
</p>

<hr>
<h2 id='getCFI.Sigma.mgroups'>getCFI.Sigma.mgroups</h2><span id='topic+getCFI.Sigma.mgroups'></span>

<h3>Description</h3>

<p>Computes CFI given the model-implied and the observed (or population) covariance matrix for multiple group models.
<code>CFI = (F_null - F_hyp) / F_null</code> applying multiple group sampling weights to <code>F_hyp</code> and <code>F_null</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCFI.Sigma.mgroups(
  SigmaHat,
  S,
  muHat = NULL,
  mu = NULL,
  N,
  fittingFunction = "ML"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCFI.Sigma.mgroups_+3A_sigmahat">SigmaHat</code></td>
<td>
<p>a list of model implied covariance matrix</p>
</td></tr>
<tr><td><code id="getCFI.Sigma.mgroups_+3A_s">S</code></td>
<td>
<p>a list of observed (or population) covariance matrix</p>
</td></tr>
<tr><td><code id="getCFI.Sigma.mgroups_+3A_muhat">muHat</code></td>
<td>
<p>model implied mean vector</p>
</td></tr>
<tr><td><code id="getCFI.Sigma.mgroups_+3A_mu">mu</code></td>
<td>
<p>observed (or population) mean vector</p>
</td></tr>
<tr><td><code id="getCFI.Sigma.mgroups_+3A_n">N</code></td>
<td>
<p>a list of group weights</p>
</td></tr>
<tr><td><code id="getCFI.Sigma.mgroups_+3A_fittingfunction">fittingFunction</code></td>
<td>
<p>whether to use <code>ML</code> or <code>WLS</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns CFI
</p>

<hr>
<h2 id='getChiSquare.F'>getChiSquare.F</h2><span id='topic+getChiSquare.F'></span>

<h3>Description</h3>

<p>Computes the (Wishart-) chi-square from the population minimum of the fit-function:
<code>chi-square = (N - 1) * F0 + df = ncp + df</code>. Note that F0 is the population minimum.
Using F_hat would give <code>chi-square = (N - 1) * F_hat</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getChiSquare.F(Fmin, n, df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getChiSquare.F_+3A_fmin">Fmin</code></td>
<td>
<p>population minimum of the fit-function (can be a list for multiple group models).</p>
</td></tr>
<tr><td><code id="getChiSquare.F_+3A_n">n</code></td>
<td>
<p>number of observations  (can be a list for multiple group models).</p>
</td></tr>
<tr><td><code id="getChiSquare.F_+3A_df">df</code></td>
<td>
<p>model degrees of freedom</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns chi-square
</p>

<hr>
<h2 id='getChiSquare.NCP'>getChiSquare.NCP</h2><span id='topic+getChiSquare.NCP'></span>

<h3>Description</h3>

<p>Computes chi-square from the non-centrality parameter: <code>chi-square = ncp + df</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getChiSquare.NCP(NCP, df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getChiSquare.NCP_+3A_ncp">NCP</code></td>
<td>
<p>non-centrality parameter</p>
</td></tr>
<tr><td><code id="getChiSquare.NCP_+3A_df">df</code></td>
<td>
<p>model degrees of freedom</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns chi-square
</p>

<hr>
<h2 id='getDiscrepancyFunctionFromFittingFunction'>getDiscrepancyFunctionFromFittingFunction</h2><span id='topic+getDiscrepancyFunctionFromFittingFunction'></span>

<h3>Description</h3>

<p>get proper discrepancy function (to measure F0) from fitting function (to obtain SigmaHat)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDiscrepancyFunctionFromFittingFunction(fittingFunction)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDiscrepancyFunctionFromFittingFunction_+3A_fittingfunction">fittingFunction</code></td>
<td>
<p>fittingFunction</p>
</td></tr>
</table>


<h3>Value</h3>

<p>discrepancy function
</p>

<hr>
<h2 id='getErrorDiff'>getErrorDiff</h2><span id='topic+getErrorDiff'></span>

<h3>Description</h3>

<p>Determine the squared log-difference between alpha and beta error given a certain chi-square value from central chi-square(df) and a non-central chi-square(df, ncp) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getErrorDiff(critChiSquare, df, ncp, log.abratio)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getErrorDiff_+3A_critchisquare">critChiSquare</code></td>
<td>
<p>evaluated chi-squared value</p>
</td></tr>
<tr><td><code id="getErrorDiff_+3A_df">df</code></td>
<td>
<p>the model degrees of freedom</p>
</td></tr>
<tr><td><code id="getErrorDiff_+3A_ncp">ncp</code></td>
<td>
<p>the non-centrality parameter</p>
</td></tr>
<tr><td><code id="getErrorDiff_+3A_log.abratio">log.abratio</code></td>
<td>
<p>log(alpha/beta)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>squared difference between alpha and beta on a log scale
</p>

<hr>
<h2 id='getF'>getF</h2><span id='topic+getF'></span>

<h3>Description</h3>

<p>Computes the minimum of the ML-fit-function from known fit indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getF(
  effect,
  effect.measure,
  df = NULL,
  p = NULL,
  SigmaHat = NULL,
  Sigma = NULL,
  muHat = NULL,
  mu = NULL,
  fittingFunction = "ML"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getF_+3A_effect">effect</code></td>
<td>
<p>magnitude of effect</p>
</td></tr>
<tr><td><code id="getF_+3A_effect.measure">effect.measure</code></td>
<td>
<p>measure of effect, one of <code>'fmin'</code>, <code>'rmsea'</code>, <code>'agfi'</code>, <code>'gfi'</code>, <code>'mc'</code></p>
</td></tr>
<tr><td><code id="getF_+3A_df">df</code></td>
<td>
<p>model degrees of freedom</p>
</td></tr>
<tr><td><code id="getF_+3A_p">p</code></td>
<td>
<p>number of observed variables</p>
</td></tr>
<tr><td><code id="getF_+3A_sigmahat">SigmaHat</code></td>
<td>
<p>model implied covariance matrix</p>
</td></tr>
<tr><td><code id="getF_+3A_sigma">Sigma</code></td>
<td>
<p>observed (or population) covariance matrix</p>
</td></tr>
<tr><td><code id="getF_+3A_muhat">muHat</code></td>
<td>
<p>model implied mean vector</p>
</td></tr>
<tr><td><code id="getF_+3A_mu">mu</code></td>
<td>
<p>observed (or population) mean vector</p>
</td></tr>
<tr><td><code id="getF_+3A_fittingfunction">fittingFunction</code></td>
<td>
<p>one of <code>ML</code> (default), <code>WLS</code>, <code>DWLS</code>, <code>ULS</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns Fmin
</p>

<hr>
<h2 id='getF.AGFI'>getF.AGFI</h2><span id='topic+getF.AGFI'></span>

<h3>Description</h3>

<p>Computes the minimum of the ML-fit-function from AGFI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getF.AGFI(AGFI, df, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getF.AGFI_+3A_agfi">AGFI</code></td>
<td>
<p>AGFI</p>
</td></tr>
<tr><td><code id="getF.AGFI_+3A_df">df</code></td>
<td>
<p>model degrees of freedom</p>
</td></tr>
<tr><td><code id="getF.AGFI_+3A_p">p</code></td>
<td>
<p>number of observed variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns Fmin
</p>

<hr>
<h2 id='getF.GFI'>getF.GFI</h2><span id='topic+getF.GFI'></span>

<h3>Description</h3>

<p>Computes the minimum of the ML-fit-function from GFI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getF.GFI(GFI, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getF.GFI_+3A_gfi">GFI</code></td>
<td>
<p>GFI</p>
</td></tr>
<tr><td><code id="getF.GFI_+3A_p">p</code></td>
<td>
<p>number of observed variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns Fmin
</p>

<hr>
<h2 id='getF.Mc'>getF.Mc</h2><span id='topic+getF.Mc'></span>

<h3>Description</h3>

<p>Computes the minimum of the ML-fit-function from Mc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getF.Mc(Mc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getF.Mc_+3A_mc">Mc</code></td>
<td>
<p>Mc</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns Fmin
</p>

<hr>
<h2 id='getF.RMSEA'>getF.RMSEA</h2><span id='topic+getF.RMSEA'></span>

<h3>Description</h3>

<p>Computes the minimum of the ML-fit-function from RMSEA:
<code>F_min = rmsea^2 * df</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getF.RMSEA(RMSEA, df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getF.RMSEA_+3A_rmsea">RMSEA</code></td>
<td>
<p>RMSEA</p>
</td></tr>
<tr><td><code id="getF.RMSEA_+3A_df">df</code></td>
<td>
<p>model degrees of freedom</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns Fmin
</p>

<hr>
<h2 id='getF.Sigma'>getF.Sigma</h2><span id='topic+getF.Sigma'></span>

<h3>Description</h3>

<p>Computes the minimum of the chosen fitting-function given the model-implied and the observed (or population) covariance matrix.
The ML fitting function is:
<code>F_min = tr(S %*% SigmaHat^-1) - p + ln(det(SigmaHat)) - ln(det(S))</code>. When a meanstructure is included,
<code style="white-space: pre;">&#8288;(mu - muHat)' SigmaHat^-1 (mu - muHat)&#8288;</code> is added.
The WLS fitting function is:
<code style="white-space: pre;">&#8288;F_min = (Sij - SijHat)'  V  (Sij - SijHat)&#8288;</code>
where V is the inverse of N times the asymptotic covariance matrix of the sample statistics (Gamma; N x ACOV(mu, vech(S))).
For DWLS, V is the diagonal of the inverse of diag(NACOV), i.e. diag(solve(diag(Gamma))).
For ULS, V = I. ULS has an unknown asymptotic distribution, so it is actually irrelevant, but provided for the sake of completeness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getF.Sigma(SigmaHat, S, muHat = NULL, mu = NULL, fittingFunction = "ML")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getF.Sigma_+3A_sigmahat">SigmaHat</code></td>
<td>
<p>model implied covariance matrix</p>
</td></tr>
<tr><td><code id="getF.Sigma_+3A_s">S</code></td>
<td>
<p>observed (or population) covariance matrix</p>
</td></tr>
<tr><td><code id="getF.Sigma_+3A_muhat">muHat</code></td>
<td>
<p>model implied mean vector</p>
</td></tr>
<tr><td><code id="getF.Sigma_+3A_mu">mu</code></td>
<td>
<p>observed (or population) mean vector</p>
</td></tr>
<tr><td><code id="getF.Sigma_+3A_fittingfunction">fittingFunction</code></td>
<td>
<p>one of <code>ML</code> (default), <code>WLS</code>, <code>DWLS</code>, <code>ULS</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns Fmin
</p>

<hr>
<h2 id='getFittingFunctionFromEstimator'>getFittingFunctionFromEstimator</h2><span id='topic+getFittingFunctionFromEstimator'></span>

<h3>Description</h3>

<p>get proper fitting function (to obtain sigmaHat) for chosen estimator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFittingFunctionFromEstimator(lavOptions)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getFittingFunctionFromEstimator_+3A_lavoptions">lavOptions</code></td>
<td>
<p>lavOptions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fitting function
</p>

<hr>
<h2 id='getFormattedResults'>getFormattedResults</h2><span id='topic+getFormattedResults'></span>

<h3>Description</h3>

<p>Return data.frame containing formatted results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFormattedResults(type, result, digits = 6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getFormattedResults_+3A_type">type</code></td>
<td>
<p>type of power analysis</p>
</td></tr>
<tr><td><code id="getFormattedResults_+3A_result">result</code></td>
<td>
<p>result object (list)</p>
</td></tr>
<tr><td><code id="getFormattedResults_+3A_digits">digits</code></td>
<td>
<p>number of significant digits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>

<hr>
<h2 id='getFormattedSimulationResults'>getFormattedResults</h2><span id='topic+getFormattedSimulationResults'></span>

<h3>Description</h3>

<p>Return data.frame containing formatted results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFormattedSimulationResults(object, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getFormattedSimulationResults_+3A_object">object</code></td>
<td>
<p>result object (list)</p>
</td></tr>
<tr><td><code id="getFormattedSimulationResults_+3A_digits">digits</code></td>
<td>
<p>number of significant digits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>

<hr>
<h2 id='getGFI.F'>getGFI.F</h2><span id='topic+getGFI.F'></span>

<h3>Description</h3>

<p>Computes GFI from the minimum of the ML-fit-function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGFI.F(Fmin, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getGFI.F_+3A_fmin">Fmin</code></td>
<td>
<p>minimum of the ML-fit-function</p>
</td></tr>
<tr><td><code id="getGFI.F_+3A_p">p</code></td>
<td>
<p>number of observed variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns GFI
</p>

<hr>
<h2 id='getIndices.F'>getIndices.F</h2><span id='topic+getIndices.F'></span>

<h3>Description</h3>

<p>Computes known indices from the minimum of the ML-fit-function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getIndices.F(
  fmin,
  df,
  p = NULL,
  SigmaHat = NULL,
  Sigma = NULL,
  muHat = NULL,
  mu = NULL,
  N = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getIndices.F_+3A_fmin">fmin</code></td>
<td>
<p>minimum of the ML-fit-function</p>
</td></tr>
<tr><td><code id="getIndices.F_+3A_df">df</code></td>
<td>
<p>model degrees of freedom</p>
</td></tr>
<tr><td><code id="getIndices.F_+3A_p">p</code></td>
<td>
<p>number of observed variables</p>
</td></tr>
<tr><td><code id="getIndices.F_+3A_sigmahat">SigmaHat</code></td>
<td>
<p>model implied covariance matrix</p>
</td></tr>
<tr><td><code id="getIndices.F_+3A_sigma">Sigma</code></td>
<td>
<p>population covariance matrix</p>
</td></tr>
<tr><td><code id="getIndices.F_+3A_muhat">muHat</code></td>
<td>
<p>model implied means</p>
</td></tr>
<tr><td><code id="getIndices.F_+3A_mu">mu</code></td>
<td>
<p>population means</p>
</td></tr>
<tr><td><code id="getIndices.F_+3A_n">N</code></td>
<td>
<p>list of sample weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of indices
</p>

<hr>
<h2 id='getKSdistance'>getKSdistance</h2><span id='topic+getKSdistance'></span>

<h3>Description</h3>

<p>computes average absulute KS-distance between empirical and asympotic chi-square reference distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getKSdistance(chi, df, ncp = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getKSdistance_+3A_chi">chi</code></td>
<td>
<p>empirical distribution</p>
</td></tr>
<tr><td><code id="getKSdistance_+3A_df">df</code></td>
<td>
<p>df of reference distribution</p>
</td></tr>
<tr><td><code id="getKSdistance_+3A_ncp">ncp</code></td>
<td>
<p>ncp of reference distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>average absolute distance
</p>

<hr>
<h2 id='getLavOptions'>getLavOptions</h2><span id='topic+getLavOptions'></span>

<h3>Description</h3>

<p>returns <code>lavaan</code> options including defaults as set in <code>sem()</code> as a list to be passed to <code>lavaan()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLavOptions(lavOptions = NULL, isCovarianceMatrix = TRUE, nGroups = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getLavOptions_+3A_lavoptions">lavOptions</code></td>
<td>
<p>additional options to be added to (or overwriting) the defaults</p>
</td></tr>
<tr><td><code id="getLavOptions_+3A_iscovariancematrix">isCovarianceMatrix</code></td>
<td>
<p>if <code>TRUE</code>, also adds <code>sample.nobs = 1000</code> and <code>sample.cov.rescale = FALSE</code> to <code>lavoptions</code></p>
</td></tr>
<tr><td><code id="getLavOptions_+3A_ngroups">nGroups</code></td>
<td>
<p>the number of groups, 1 by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of <code>lavaan</code> defaults
</p>

<hr>
<h2 id='getMc.F'>getMc.F</h2><span id='topic+getMc.F'></span>

<h3>Description</h3>

<p>Computes Mc from the minimum of the ML-fit-function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMc.F(Fmin)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMc.F_+3A_fmin">Fmin</code></td>
<td>
<p>minimum of the ML-fit-function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns Mc
</p>

<hr>
<h2 id='getNCP'>getNCP</h2><span id='topic+getNCP'></span>

<h3>Description</h3>

<p>Computes the non-centrality parameter from the population minimum of the fit-function
(dividing by N - 1 following the Wishart likelihood): <code>ncp = (N - 1) * F0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNCP(Fmin, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getNCP_+3A_fmin">Fmin</code></td>
<td>
<p>population minimum of the fit-function (can be a list for multiple group models).</p>
</td></tr>
<tr><td><code id="getNCP_+3A_n">n</code></td>
<td>
<p>number of observations (can be a list for multiple group models).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the implied NCP.
</p>

<hr>
<h2 id='getPhi.B'>getPhi.B</h2><span id='topic+getPhi.B'></span>

<h3>Description</h3>

<p>Computes implied correlations (completely standardized) from Beta matrix, disallowing recursive paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPhi.B(B, lPsi = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPhi.B_+3A_b">B</code></td>
<td>
<p>matrix of regression coefficients (all-y notation). Must only contain non-zero lower-triangular elements, so the first row only includes zeros.</p>
</td></tr>
<tr><td><code id="getPhi.B_+3A_lpsi">lPsi</code></td>
<td>
<p>(lesser) matrix of residual correlations. This is not the Psi matrix, but a lesser version ignoring all variances and containing correlations off the diagonal. Can be omitted for no correlations beyond those implied by B.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the implied correlation matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# mediation model
B &lt;- matrix(c(
  c(.00, .00, .00),
  c(.10, .00, .00),
  c(.20, .30, .00)
), byrow = TRUE, ncol = 3)
Phi &lt;- getPhi.B(B)

# CLPM with residual correlations 
B &lt;- matrix(c(
  c(.00, .00, .00, .00),
  c(.30, .00, .00, .00),
  c(.70, .10, .00, .00),
  c(.20, .70, .00, .00)
), byrow = TRUE, ncol = 4)
lPsi &lt;- matrix(c(
  c(.00, .00, .00, .00),
  c(.00, .00, .00, .00),
  c(.00, .00, .00, .30),
  c(.00, .00, .30, .00)
), byrow = TRUE, ncol = 4)
Phi &lt;- getPhi.B(B, lPsi)

## End(Not run)
</code></pre>

<hr>
<h2 id='getPsi.B'>getPsi.B</h2><span id='topic+getPsi.B'></span>

<h3>Description</h3>

<p>Computes the implied Psi matrix from Beta, when all coefficients in Beta should be standardized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPsi.B(B, sPsi = NULL, standResCov = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPsi.B_+3A_b">B</code></td>
<td>
<p>matrix of regression coefficients (all-y notation). May only contain non-zero values either above or below the diagonal.</p>
</td></tr>
<tr><td><code id="getPsi.B_+3A_spsi">sPsi</code></td>
<td>
<p>matrix of (residual) correlations/covariances. This is not the Psi matrix, but defines the desired correlations/covariances beyond those implied by B. Can be NULL for no correlations. Standardized and unstandardized residual covariances (between endogenous variables) cannot have the same value, so <code>standResCov</code> defines whether to treat these as unstandardized or as standardized.</p>
</td></tr>
<tr><td><code id="getPsi.B_+3A_standrescov">standResCov</code></td>
<td>
<p>whether elements in <code>sPsi</code> referring to residual covariances (between endogenous variables) shall treated as correlation or as covariance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Psi
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# mediation model
B &lt;- matrix(c(
  c(.00, .00, .00),
  c(.10, .00, .00),
  c(.20, .30, .00)
), byrow = TRUE, ncol = 3)
Psi &lt;- getPsi.B(B)

# CLPM with residual correlations 
B &lt;- matrix(c(
  c(.00, .00, .00, .00),
  c(.30, .00, .00, .00),
  c(.70, .10, .00, .00),
  c(.20, .70, .00, .00)
), byrow = TRUE, ncol = 4)
sPsi &lt;- matrix(c(
  c(1, .00, .00, .00),
  c(.00, 1, .00, .00),
  c(.00, .00, 1, .30),
  c(.00, .00, .30, 1)
), byrow = TRUE, ncol = 4)
# so that residual cor is std
Psi &lt;- getPsi.B(B, sPsi, standResCov = TRUE)
# so that residual cor is unsstd
Psi &lt;- getPsi.B(B, sPsi, standResCov = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='getRMSEA.F'>getRMSEA.F</h2><span id='topic+getRMSEA.F'></span>

<h3>Description</h3>

<p>Computes RMSEA from the minimum of the ML-fit-function
<code>F_min = rmsea^2 * df</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRMSEA.F(Fmin, df, nGroups = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getRMSEA.F_+3A_fmin">Fmin</code></td>
<td>
<p>minimum of the ML-fit-function</p>
</td></tr>
<tr><td><code id="getRMSEA.F_+3A_df">df</code></td>
<td>
<p>model degrees of freedom</p>
</td></tr>
<tr><td><code id="getRMSEA.F_+3A_ngroups">nGroups</code></td>
<td>
<p>the number of groups</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns RMSEA
</p>

<hr>
<h2 id='getSRMR.Sigma'>getSRMR.Sigma</h2><span id='topic+getSRMR.Sigma'></span>

<h3>Description</h3>

<p>Computes SRMR given the model-implied and the observed (or population) covariance matrix,
using the Hu &amp; Bentler approach to standardization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSRMR.Sigma(SigmaHat, S, muHat = NULL, mu = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSRMR.Sigma_+3A_sigmahat">SigmaHat</code></td>
<td>
<p>model implied covariance matrix</p>
</td></tr>
<tr><td><code id="getSRMR.Sigma_+3A_s">S</code></td>
<td>
<p>observed (or population) covariance matrix</p>
</td></tr>
<tr><td><code id="getSRMR.Sigma_+3A_muhat">muHat</code></td>
<td>
<p>model implied mean vector</p>
</td></tr>
<tr><td><code id="getSRMR.Sigma_+3A_mu">mu</code></td>
<td>
<p>observed (or population) mean vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns SRMR
</p>

<hr>
<h2 id='getSRMR.Sigma.mgroups'>getSRMR.Sigma.mgroups</h2><span id='topic+getSRMR.Sigma.mgroups'></span>

<h3>Description</h3>

<p>Computes SRMR given the model-implied and the observed (or population) covariance matrix for multiple group models
using the Hu &amp; Bentler approach to standardization and the MPlus approach to multiple group sampling weights
(weight squared sums of residuals).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSRMR.Sigma.mgroups(SigmaHat, S, muHat = NULL, mu = NULL, N)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSRMR.Sigma.mgroups_+3A_sigmahat">SigmaHat</code></td>
<td>
<p>a list of model implied covariance matrices</p>
</td></tr>
<tr><td><code id="getSRMR.Sigma.mgroups_+3A_s">S</code></td>
<td>
<p>a list of observed (or population) covariance matrices</p>
</td></tr>
<tr><td><code id="getSRMR.Sigma.mgroups_+3A_muhat">muHat</code></td>
<td>
<p>model implied mean vector</p>
</td></tr>
<tr><td><code id="getSRMR.Sigma.mgroups_+3A_mu">mu</code></td>
<td>
<p>observed (or population) mean vector</p>
</td></tr>
<tr><td><code id="getSRMR.Sigma.mgroups_+3A_n">N</code></td>
<td>
<p>a list of group weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns SRMR
</p>

<hr>
<h2 id='getWLSv'>getWLSv</h2><span id='topic+getWLSv'></span>

<h3>Description</h3>

<p>Computes the WLS weight matrix as the asymptotic covariance matrix of the sample statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWLSv(S, mu = NULL, diag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getWLSv_+3A_s">S</code></td>
<td>
<p>observed (or population) covariance matrix</p>
</td></tr>
<tr><td><code id="getWLSv_+3A_mu">mu</code></td>
<td>
<p>observed (or population) mean vector</p>
</td></tr>
<tr><td><code id="getWLSv_+3A_diag">diag</code></td>
<td>
<p>weight matrix for DWLS</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns V
</p>

<hr>
<h2 id='makeRestrictionsLavFriendly'>makeRestrictionsLavFriendly</h2><span id='topic+makeRestrictionsLavFriendly'></span>

<h3>Description</h3>

<p>This function is currently orphaned, but we keep it just in case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeRestrictionsLavFriendly(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeRestrictionsLavFriendly_+3A_model">model</code></td>
<td>
<p><code>lavaan</code> model string</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function transforms a <code>lavaan</code> model string into a model string that works reliably
when both equality constrains and value constrains are imposed on the same parameters.
<code>lavaan</code> cannot reliably handle this case, e. g., <code>"a == b \\n a == 0"</code> will not always work.
The solution is to drop the equality constraint and rather apply
the value constraint on each equality constrained parameter, e. g. <code>"a == 0 \n b == 0"</code> will work.
</p>


<h3>Value</h3>

<p>model with  <code>lavaan</code>-friendly constrains
</p>

<hr>
<h2 id='orderLavCov'>orderLavCov</h2><span id='topic+orderLavCov'></span>

<h3>Description</h3>

<p>returns <code>lavaan</code> implied covariance matrix in correct order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderLavCov(lavCov = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderLavCov_+3A_lavcov">lavCov</code></td>
<td>
<p>model implied covariance matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cov in correct order
</p>

<hr>
<h2 id='orderLavMu'>orderLavMu</h2><span id='topic+orderLavMu'></span>

<h3>Description</h3>

<p>returns <code>lavaan</code> implied means in correct order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderLavMu(lavMu = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderLavMu_+3A_lavmu">lavMu</code></td>
<td>
<p>model implied means</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mu in correct order
</p>

<hr>
<h2 id='orderLavResults'>orderLavResults</h2><span id='topic+orderLavResults'></span>

<h3>Description</h3>

<p>returns <code>lavaan</code> implied covariance matrix or mean vector in correct order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderLavResults(lavCov = NULL, lavMu = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderLavResults_+3A_lavcov">lavCov</code></td>
<td>
<p>model implied covariance matrix</p>
</td></tr>
<tr><td><code id="orderLavResults_+3A_lavmu">lavMu</code></td>
<td>
<p>model implied means</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either cov or mu in correct order
</p>

<hr>
<h2 id='powerPrepare'>powerPrepare</h2><span id='topic+powerPrepare'></span>

<h3>Description</h3>

<p>Performs some preparations common to all types of power analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerPrepare(
  type = NULL,
  effect = NULL,
  effect.measure = NULL,
  alpha = NULL,
  beta = NULL,
  power = NULL,
  abratio = NULL,
  N = NULL,
  df = NULL,
  p = NULL,
  SigmaHat = NULL,
  Sigma = NULL,
  muHat = NULL,
  mu = NULL,
  fittingFunction = "ML",
  simulatedPower = FALSE,
  modelH0 = NULL,
  nReplications = NULL,
  minConvergenceRate = NULL,
  lavOptions = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="powerPrepare_+3A_type">type</code></td>
<td>
<p>type of power analysis</p>
</td></tr>
<tr><td><code id="powerPrepare_+3A_effect">effect</code></td>
<td>
<p>effect size specifying the discrepancy between H0 and H1 (a list for multiple group models; a vector of length 2 for effect-size differences)</p>
</td></tr>
<tr><td><code id="powerPrepare_+3A_effect.measure">effect.measure</code></td>
<td>
<p>type of effect, one of <code>"F0"</code>, <code>"RMSEA"</code>, <code>"Mc"</code>, <code>"GFI"</code>, <code>"AGFI"</code></p>
</td></tr>
<tr><td><code id="powerPrepare_+3A_alpha">alpha</code></td>
<td>
<p>alpha error</p>
</td></tr>
<tr><td><code id="powerPrepare_+3A_beta">beta</code></td>
<td>
<p>beta error; set either beta or power</p>
</td></tr>
<tr><td><code id="powerPrepare_+3A_power">power</code></td>
<td>
<p>power (=1 - beta); set either beta or power</p>
</td></tr>
<tr><td><code id="powerPrepare_+3A_abratio">abratio</code></td>
<td>
<p>the ratio of alpha to beta</p>
</td></tr>
<tr><td><code id="powerPrepare_+3A_n">N</code></td>
<td>
<p>the number of observations (a list for multiple group models)</p>
</td></tr>
<tr><td><code id="powerPrepare_+3A_df">df</code></td>
<td>
<p>the model degrees of freedom</p>
</td></tr>
<tr><td><code id="powerPrepare_+3A_p">p</code></td>
<td>
<p>the number of observed variables, required for <code>effect.measure = "GFI"</code> and <code>effect.measure = "AGFI"</code></p>
</td></tr>
<tr><td><code id="powerPrepare_+3A_sigmahat">SigmaHat</code></td>
<td>
<p>model implied covariance matrix (a list for multiple group models). Use in conjunction with <code>Sigma</code> to define <code>effect</code> and <code>effect.measure</code>.</p>
</td></tr>
<tr><td><code id="powerPrepare_+3A_sigma">Sigma</code></td>
<td>
<p>observed (or population) covariance matrix (a list for multiple group models). Use in conjunction with <code>SigmaHat</code> to define <code>effect</code> and <code>effect.measure</code>.</p>
</td></tr>
<tr><td><code id="powerPrepare_+3A_muhat">muHat</code></td>
<td>
<p>model implied mean vector</p>
</td></tr>
<tr><td><code id="powerPrepare_+3A_mu">mu</code></td>
<td>
<p>observed (or population) mean vector</p>
</td></tr>
<tr><td><code id="powerPrepare_+3A_fittingfunction">fittingFunction</code></td>
<td>
<p>one of <code>'ML'</code> (default), <code>'WLS'</code>, <code>'DWLS'</code>, <code>'ULS'</code>. Defines the discrepancy function used to obtain Fmin.</p>
</td></tr>
<tr><td><code id="powerPrepare_+3A_simulatedpower">simulatedPower</code></td>
<td>
<p>whether to perform a simulated (<code>TRUE</code>) (rather than analytical, <code>FALSE</code>) power analysis.</p>
</td></tr>
<tr><td><code id="powerPrepare_+3A_modelh0">modelH0</code></td>
<td>
<p>for simulated power: <code>lavaan</code> model string defining the (incorrect) analysis model.</p>
</td></tr>
<tr><td><code id="powerPrepare_+3A_nreplications">nReplications</code></td>
<td>
<p>for simulated power: number of random samples drawn.</p>
</td></tr>
<tr><td><code id="powerPrepare_+3A_minconvergencerate">minConvergenceRate</code></td>
<td>
<p>for simulated power: the minimum convergence rate required</p>
</td></tr>
<tr><td><code id="powerPrepare_+3A_lavoptions">lavOptions</code></td>
<td>
<p>for simulated power: a list of additional options passed to <code>lavaan</code>, e. g., <code>list(estimator = 'mlm')</code> to request robust ML estimation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>

<hr>
<h2 id='semPower.aPriori'>semPower.aPriori</h2><span id='topic+semPower.aPriori'></span>

<h3>Description</h3>

<p>Performs an a-priori power analysis, i. e., determines the required sample size given alpha, beta (or power: 1 - beta), df, and a measure of effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semPower.aPriori(
  effect = NULL,
  effect.measure = NULL,
  alpha,
  beta = NULL,
  power = NULL,
  N = NULL,
  df = NULL,
  p = NULL,
  SigmaHat = NULL,
  Sigma = NULL,
  muHat = NULL,
  mu = NULL,
  fittingFunction = "ML",
  simulatedPower = FALSE,
  modelH0 = NULL,
  modelH1 = NULL,
  simOptions = NULL,
  lavOptions = NULL,
  lavOptionsH1 = lavOptions,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semPower.aPriori_+3A_effect">effect</code></td>
<td>
<p>effect size specifying the discrepancy between the null hypothesis (H0) and the alternative hypothesis (H1). A list for multiple group models; a vector of length 2 for effect-size differences. Can be <code>NULL</code> if <code>Sigma</code> and <code>SigmaHat</code> are set.</p>
</td></tr>
<tr><td><code id="semPower.aPriori_+3A_effect.measure">effect.measure</code></td>
<td>
<p>type of effect, one of <code>"F0"</code>, <code>"RMSEA"</code>, <code>"Mc"</code>, <code>"GFI"</code>, <code>"AGFI"</code>. Can be <code>NULL</code> if <code>Sigma</code> and <code>SigmaHat</code> are set.</p>
</td></tr>
<tr><td><code id="semPower.aPriori_+3A_alpha">alpha</code></td>
<td>
<p>alpha error</p>
</td></tr>
<tr><td><code id="semPower.aPriori_+3A_beta">beta</code></td>
<td>
<p>beta error; set either <code>beta</code> or <code>power</code>.</p>
</td></tr>
<tr><td><code id="semPower.aPriori_+3A_power">power</code></td>
<td>
<p>power (= 1 - beta); set either <code>beta</code> or <code>power</code>.</p>
</td></tr>
<tr><td><code id="semPower.aPriori_+3A_n">N</code></td>
<td>
<p>a list of sample weights for multiple group power analyses, e.g. <code>list(1, 2)</code> to make the second group twice as large as the first one.</p>
</td></tr>
<tr><td><code id="semPower.aPriori_+3A_df">df</code></td>
<td>
<p>the model degrees of freedom. See <code><a href="#topic+semPower.getDf">semPower.getDf()</a></code> for a way to obtain the df of a specific model.</p>
</td></tr>
<tr><td><code id="semPower.aPriori_+3A_p">p</code></td>
<td>
<p>the number of observed variables, only required for <code>effect.measure = "GFI"</code> and <code>effect.measure = "AGFI"</code>.</p>
</td></tr>
<tr><td><code id="semPower.aPriori_+3A_sigmahat">SigmaHat</code></td>
<td>
<p>can be used instead of <code>effect</code> and <code>effect.measure</code>: model implied covariance matrix (a list for multiple group models). Used in conjunction with <code>Sigma</code> to define the effect.</p>
</td></tr>
<tr><td><code id="semPower.aPriori_+3A_sigma">Sigma</code></td>
<td>
<p>can be used instead of <code>effect</code> and <code>effect.measure</code>: population covariance matrix (a list for multiple group models). Used in conjunction with <code>SigmaHat</code> to define effect.</p>
</td></tr>
<tr><td><code id="semPower.aPriori_+3A_muhat">muHat</code></td>
<td>
<p>can be used instead of <code>effect</code> and <code>effect.measure</code>: model implied mean vector. Used in conjunction with <code>mu</code>. If <code>NULL</code>, no meanstructure is involved.</p>
</td></tr>
<tr><td><code id="semPower.aPriori_+3A_mu">mu</code></td>
<td>
<p>can be used instead of <code>effect</code> and <code>effect.measure</code>: observed (or population) mean vector. Use in conjunction with <code>muHat</code>. If <code>NULL</code>, no meanstructure is involved.</p>
</td></tr>
<tr><td><code id="semPower.aPriori_+3A_fittingfunction">fittingFunction</code></td>
<td>
<p>one of <code>'ML'</code> (default), <code>'WLS'</code>, <code>'DWLS'</code>, <code>'ULS'</code>. Defines the discrepancy function used to obtain Fmin.</p>
</td></tr>
<tr><td><code id="semPower.aPriori_+3A_simulatedpower">simulatedPower</code></td>
<td>
<p>whether to perform a simulated (<code>TRUE</code>, rather than analytical, <code>FALSE</code>) power analysis. Only available if <code>Sigma</code> and <code>modelH0</code> are defined.</p>
</td></tr>
<tr><td><code id="semPower.aPriori_+3A_modelh0">modelH0</code></td>
<td>
<p>for simulated power: <code>lavaan</code> model string defining the (incorrect) analysis model.</p>
</td></tr>
<tr><td><code id="semPower.aPriori_+3A_modelh1">modelH1</code></td>
<td>
<p>for simulated power: <code>lavaan</code> model string defining the comparison model. If omitted, the saturated model is the comparison model.</p>
</td></tr>
<tr><td><code id="semPower.aPriori_+3A_simoptions">simOptions</code></td>
<td>
<p>a list of additional options specifying simulation details, see <code><a href="#topic+simulate">simulate()</a></code> for details.</p>
</td></tr>
<tr><td><code id="semPower.aPriori_+3A_lavoptions">lavOptions</code></td>
<td>
<p>a list of additional options passed to <code>lavaan</code>, e. g., <code>list(estimator = 'mlm')</code> to request robust ML estimation.</p>
</td></tr>
<tr><td><code id="semPower.aPriori_+3A_lavoptionsh1">lavOptionsH1</code></td>
<td>
<p>alternative options passed to <code>lavaan</code> that are only used for the H1 model. If <code>NULL</code>, identical to <code>lavOptions</code>. Probably only useful for multigroup models.</p>
</td></tr>
<tr><td><code id="semPower.aPriori_+3A_...">...</code></td>
<td>
<p>other parameters related to plots, notably <code>plotShow</code>, <code>plotShowLabels</code>, and <code>plotLinewidth</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list. Use <code>summary()</code> to obtain formatted results.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code> <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# determine the required sample size to reject a model showing misspecifications 
# amounting to RMSEA &gt;= .05 on 200 df with a power of 95 % on alpha = .05   
ap &lt;- semPower.aPriori(effect = .05, effect.measure = "RMSEA", 
                       alpha = .05, beta = .05, df = 200)
summary(ap)

# use f0 as effect size metric
ap &lt;- semPower.aPriori(effect = .15, effect.measure = "F0", 
                       alpha = .05, power = .80, df = 200)
summary(ap)

# power analysis for to detect the difference between a model (with df = 200) exhibiting RMSEA = .05
# and a model (with df = 210) exhibiting RMSEA = .06.
ap &lt;- semPower.aPriori(effect = c(.05, .06), effect.measure = "RMSEA", 
                       alpha = .05, power = .80, df = c(200, 210))
summary(ap)

# power analysis based on SigmaHat and Sigma (nonsense example)
ap &lt;- semPower.aPriori(alpha = .05, beta = .05, df = 5, 
                       SigmaHat = diag(4), Sigma = cov(matrix(rnorm(4*1000),  ncol=4)))
summary(ap)

# multiple group example
ap &lt;- semPower.aPriori(effect = list(.05, .10), effect.measure = "F0", 
                       alpha = .05, power = .80, df = 100, 
                       N = list(1, 1))
summary(ap)

# simulated power analysis (nonsense example)
ap &lt;- semPower.aPriori(alpha = .05, beta = .05, df = 200, 
                       SigmaHat = list(diag(4), diag(4)), 
                       Sigma = list(cov(matrix(rnorm(4*1000), ncol=4)), 
                               cov(matrix(rnorm(4*1000), ncol=4))),
                       simulatedPower = TRUE, nReplications = 100)
summary(ap)

## End(Not run)
</code></pre>

<hr>
<h2 id='semPower.compromise'>semPower.compromise</h2><span id='topic+semPower.compromise'></span>

<h3>Description</h3>

<p>Performs a compromise power analysis, i. e., determines the critical chi-square along with the implied alpha error and beta error , given the alpha/beta ratio, a measure of effect, N, and df
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semPower.compromise(
  effect = NULL,
  effect.measure = NULL,
  abratio = 1,
  N,
  df = NULL,
  p = NULL,
  SigmaHat = NULL,
  Sigma = NULL,
  muHat = NULL,
  mu = NULL,
  fittingFunction = "ML",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semPower.compromise_+3A_effect">effect</code></td>
<td>
<p>effect size specifying the discrepancy between the null hypothesis (H0) and the alternative hypothesis (H1). A list for multiple group models; a vector of length 2 for effect-size differences. Can be <code>NULL</code> if <code>Sigma</code> and <code>SigmaHat</code> are set.</p>
</td></tr>
<tr><td><code id="semPower.compromise_+3A_effect.measure">effect.measure</code></td>
<td>
<p>type of effect, one of <code>"F0"</code>, <code>"RMSEA"</code>, <code>"Mc"</code>, <code>"GFI"</code>, <code>"AGFI"</code>. Can be <code>NULL</code> if <code>Sigma</code> and <code>SigmaHat</code> are set.</p>
</td></tr>
<tr><td><code id="semPower.compromise_+3A_abratio">abratio</code></td>
<td>
<p>the ratio of alpha to beta</p>
</td></tr>
<tr><td><code id="semPower.compromise_+3A_n">N</code></td>
<td>
<p>the number of observations  (a list for multiple group models)</p>
</td></tr>
<tr><td><code id="semPower.compromise_+3A_df">df</code></td>
<td>
<p>the model degrees of freedom. See <code><a href="#topic+semPower.getDf">semPower.getDf()</a></code> for a way to obtain the df of a specific model.</p>
</td></tr>
<tr><td><code id="semPower.compromise_+3A_p">p</code></td>
<td>
<p>the number of observed variables, only required for <code>effect.measure = "GFI"</code> and <code>effect.measure = "AGFI"</code>.</p>
</td></tr>
<tr><td><code id="semPower.compromise_+3A_sigmahat">SigmaHat</code></td>
<td>
<p>can be used instead of <code>effect</code> and <code>effect.measure</code>: model implied covariance matrix (a list for multiple group models). Used in conjunction with <code>Sigma</code> to define the effect.</p>
</td></tr>
<tr><td><code id="semPower.compromise_+3A_sigma">Sigma</code></td>
<td>
<p>can be used instead of <code>effect</code> and <code>effect.measure</code>: population covariance matrix (a list for multiple group models). Used in conjunction with <code>SigmaHat</code> to define effect.</p>
</td></tr>
<tr><td><code id="semPower.compromise_+3A_muhat">muHat</code></td>
<td>
<p>can be used instead of <code>effect</code> and <code>effect.measure</code>: model implied mean vector. Used in conjunction with <code>mu</code>. If <code>NULL</code>, no meanstructure is involved.</p>
</td></tr>
<tr><td><code id="semPower.compromise_+3A_mu">mu</code></td>
<td>
<p>can be used instead of <code>effect</code> and <code>effect.measure</code>: observed (or population) mean vector. Use in conjunction with <code>muHat</code>. If <code>NULL</code>, no meanstructure is involved.</p>
</td></tr>
<tr><td><code id="semPower.compromise_+3A_fittingfunction">fittingFunction</code></td>
<td>
<p>one of <code>'ML'</code> (default), <code>'WLS'</code>, <code>'DWLS'</code>, <code>'ULS'</code>. Defines the discrepancy function used to obtain Fmin.</p>
</td></tr>
<tr><td><code id="semPower.compromise_+3A_...">...</code></td>
<td>
<p>other parameters related to plots, notably <code>plotShow</code>, <code>plotShowLabels</code>, and <code>plotLinewidth</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list. Use <code>summary()</code> to obtain formatted results.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code> <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# determine the critical value such that alpha = beta when distinguishing a model
# involving 200 df exhibiting an RMSEA &gt;= .08 from a perfectly fitting model.  
cp &lt;- semPower.compromise(effect = .08, effect.measure = "RMSEA", 
                          abratio = 1, N = 250, df = 200)
summary(cp)


## End(Not run)
</code></pre>

<hr>
<h2 id='semPower.genSigma'>semPower.genSigma</h2><span id='topic+semPower.genSigma'></span>

<h3>Description</h3>

<p>Generate a covariance matrix (and a mean vector) and associated <code>lavaan</code> model strings based on CFA or SEM model matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semPower.genSigma(
  Lambda = NULL,
  Phi = NULL,
  Beta = NULL,
  Psi = NULL,
  Theta = NULL,
  tau = NULL,
  Alpha = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semPower.genSigma_+3A_lambda">Lambda</code></td>
<td>
<p>factor loading matrix. A list for multiple group models. Can also be specified using various shortcuts, see <code><a href="#topic+genLambda">genLambda()</a></code>.</p>
</td></tr>
<tr><td><code id="semPower.genSigma_+3A_phi">Phi</code></td>
<td>
<p>for CFA models, factor correlation (or covariance) matrix or single number giving the correlation between all factors or <code>NULL</code> for uncorrelated factors. A list for multiple group models.</p>
</td></tr>
<tr><td><code id="semPower.genSigma_+3A_beta">Beta</code></td>
<td>
<p>for SEM models, matrix of regression slopes between latent variables (all-y notation). A list for multiple group models.</p>
</td></tr>
<tr><td><code id="semPower.genSigma_+3A_psi">Psi</code></td>
<td>
<p>for SEM models, variance-covariance matrix of latent residuals when <code>Beta</code> is specified. If <code>NULL</code>, a diagonal matrix is assumed. A list for multiple group models.</p>
</td></tr>
<tr><td><code id="semPower.genSigma_+3A_theta">Theta</code></td>
<td>
<p>variance-covariance matrix between manifest residuals. If <code>NULL</code> and <code>Lambda</code> is not a square matrix, <code>Theta</code> is diagonal so that the manifest variances are 1. If <code>NULL</code> and <code>Lambda</code> is square, <code>Theta</code> is 0. A list for multiple group models.</p>
</td></tr>
<tr><td><code id="semPower.genSigma_+3A_tau">tau</code></td>
<td>
<p>vector of intercepts. If <code>NULL</code> and <code>Alpha</code> is set, these are assumed to be zero. If both <code>Alpha</code> and <code>tau</code> are <code>NULL</code>, no means are returned. A list for multiple group models.</p>
</td></tr>
<tr><td><code id="semPower.genSigma_+3A_alpha">Alpha</code></td>
<td>
<p>vector of factor means. If <code>NULL</code> and <code>tau</code> is set, these are assumed to be zero. If both <code>Alpha</code> and <code>tau</code> are <code>NULL</code>, no means are returned. A list for multiple group models.</p>
</td></tr>
<tr><td><code id="semPower.genSigma_+3A_...">...</code></td>
<td>
<p>other</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates the variance-covariance matrix of the <code class="reqn">p</code> observed variables <code class="reqn">\Sigma</code> and their means <code class="reqn">\mu</code> via a confirmatory factor (CFA) model or a more general structural equation model.
</p>
<p>In the CFA model,
</p>
<p style="text-align: center;"><code class="reqn">\Sigma = \Lambda \Phi \Lambda' + \Theta</code>
</p>

<p>where <code class="reqn">\Lambda</code> is the <code class="reqn">p \cdot m</code> loading matrix, <code class="reqn">\Phi</code> is the variance-covariance matrix of the <code class="reqn">m</code> factors, and <code class="reqn">\Theta</code> is the residual variance-covariance matrix of the observed variables. The means are
</p>
<p style="text-align: center;"><code class="reqn">\mu = \tau + \Lambda \alpha</code>
</p>

<p>with the <code class="reqn">p</code> indicator intercepts <code class="reqn">\tau</code> and the <code class="reqn">m</code> factor means <code class="reqn">\alpha</code>.
</p>
<p>In the structural equation model,
</p>
<p style="text-align: center;"><code class="reqn">\Sigma = \Lambda (I - B)^{-1} \Psi [(I - B)^{-1}]'  \Lambda' + \Theta </code>
</p>

<p>where <code class="reqn">B</code> is the <code class="reqn">m \cdot m</code> matrix containing the regression slopes and <code class="reqn">\Psi</code> is the (residual) variance-covariance matrix of the <code class="reqn">m</code> factors. The means are
</p>
<p style="text-align: center;"><code class="reqn">\mu = \tau + \Lambda (I - B)^{-1} \alpha</code>
</p>

<p>In either model, the meanstructure can be omitted, leading to factors with zero means and zero intercepts.
</p>
<p>When <code class="reqn">\Lambda = I</code>, the models above do not contain any factors and reduce to ordinary regression or path models.
</p>
<p>If <code>Phi</code> is defined, a CFA model is used, if <code>Beta</code> is defined, a structural equation model.
When both <code>Phi</code> and <code>Beta</code> are <code>NULL</code>, a CFA model is used with <code class="reqn">\Phi = I</code>, i. e., uncorrelated factors.
When <code>Phi</code> is a single number, all factor correlations are equal to this number.
</p>
<p>When <code>Beta</code> is defined and <code>Psi</code> is <code>NULL</code>, <code class="reqn">\Psi = I</code>.
</p>
<p>When <code>Theta</code> is <code>NULL</code>, <code class="reqn">\Theta</code> is a diagonal matrix with all elements such that the variances of the observed variables are 1. When there is only a single observed indicator for a factor, the corresponding element in <code class="reqn">\Theta</code> is set to zero.
</p>
<p>Instead of providing the loading matrix <code class="reqn">\Lambda</code> via <code>Lambda</code>, there are several shortcuts (see <code><a href="#topic+genLambda">genLambda()</a></code>):
</p>

<ul>
<li> <p><code>loadings</code>: defines the primary loadings for each factor in a list structure, e. g. <code>loadings = list(c(.5, .4, .6), c(.8, .6, .6, .4))</code> defines a two factor model with three indicators loading on the first factor by .5, , 4., and .6, and four indicators loading in the second factor by .8, .6, .6, and .4.
</p>
</li>
<li> <p><code>nIndicator</code>: used in conjunction with <code>loadM</code> or <code>loadMinmax</code>, defines the number of indicators by factor, e. g., <code>nIndicator = c(3, 4)</code> defines a two factor model with three and four indicators for the first and second factor, respectively. <code>nIndicator</code> can also be a single number to define the same number of indicators for each factor.
</p>
</li>
<li> <p><code>loadM</code>: defines the mean loading either for all indicators (if a single number is provided) or separately for each factor (if a vector is provided), e. g. <code>loadM = c(.5, .6)</code> defines the mean loadings of the first factor to equal .5 and those of the second factor do equal .6
</p>
</li>
<li> <p><code>loadSD</code>: used in conjunction with <code>loadM</code>, defines the standard deviations of the loadings. If omitted or NULL, the standard deviations are zero. Otherwise, the loadings are sampled from a normal distribution with N(loadM, loadSD) for each factor.
</p>
</li>
<li> <p><code>loadMinMax</code>: defines the minimum and maximum loading either for all factors or separately for each factor (as a list). The loadings are then sampled from a uniform distribution. For example, <code>loadMinMax = list(c(.4, .6), c(.4, .8))</code> defines the loadings for the first factor lying between .4 and .6, and those for the second factor between .4 and .8.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a list (or list of lists for multiple group models) containing the following components:
</p>
<table role = "presentation">
<tr><td><code>Sigma</code></td>
<td>
<p>implied variance-covariance matrix.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>implied means</p>
</td></tr>
<tr><td><code>Lambda</code></td>
<td>
<p>loading matrix</p>
</td></tr>
<tr><td><code>Phi</code></td>
<td>
<p>covariance matrix of latent variables</p>
</td></tr>
<tr><td><code>Beta</code></td>
<td>
<p>matrix of regression slopes</p>
</td></tr>
<tr><td><code>Psi</code></td>
<td>
<p>residual covariance matrix of latent variables</p>
</td></tr>
<tr><td><code>Theta</code></td>
<td>
<p>residual covariance matrix of observed variables</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>intercepts</p>
</td></tr>
<tr><td><code>Alpha</code></td>
<td>
<p>factor means</p>
</td></tr>
<tr><td><code>modelPop</code></td>
<td>
<p><code>lavaan</code> model string defining the population model</p>
</td></tr>
<tr><td><code>modelTrue</code></td>
<td>
<p><code>lavaan</code> model string defining the &quot;true&quot; analysis model freely estimating all non-zero parameters.</p>
</td></tr>
<tr><td><code>modelTrueCFA</code></td>
<td>
<p><code>lavaan</code> model string defining a model similar to <code>modelTrue</code>, but purely CFA based and thus omitting any regression relationships.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# single factor model with five indicators each loading by .5
gen &lt;- semPower.genSigma(nIndicator = 5, loadM = .5)
gen$Sigma     # implied covariance matrix
gen$modelTrue # analysis model string
gen$modelPop  # population model string

# orthogonal two factor model with four and five indicators each loading by .5
gen &lt;- semPower.genSigma(nIndicator = c(4, 5), loadM = .5)

# correlated (r = .25) two factor model with 
# four indicators loading by .7 on the first factor 
# and five indicators loading by .6 on the second factor
gen &lt;- semPower.genSigma(Phi = .25, nIndicator = c(4, 5), loadM = c(.7, .6))

# correlated three factor model with variying indicators and loadings, 
# factor correlations according to Phi
Phi &lt;- matrix(c(
  c(1.0, 0.2, 0.5),
  c(0.2, 1.0, 0.3),
  c(0.5, 0.3, 1.0)
), byrow = TRUE, ncol = 3)
gen &lt;- semPower.genSigma(Phi = Phi, nIndicator = c(3, 4, 5), 
                         loadM = c(.7, .6, .5))

# same as above, but using a factor loadings matrix
Lambda &lt;- matrix(c(
  c(0.8, 0.0, 0.0),
  c(0.7, 0.0, 0.0),
  c(0.6, 0.0, 0.0),
  c(0.0, 0.7, 0.0),
  c(0.0, 0.8, 0.0),
  c(0.0, 0.5, 0.0),
  c(0.0, 0.4, 0.0),
  c(0.0, 0.0, 0.5),
  c(0.0, 0.0, 0.4),
  c(0.0, 0.0, 0.6),
  c(0.0, 0.0, 0.4),
  c(0.0, 0.0, 0.5)
), byrow = TRUE, ncol = 3)
gen &lt;- semPower.genSigma(Phi = Phi, Lambda = Lambda)

# same as above, but using a reduced loading matrix, i. e.
# only define the primary loadings for each factor
loadings &lt;- list(
  c(0.8, 0.7, 0.6),
  c(0.7, 0.8, 0.5, 0.4),
  c(0.5, 0.4, 0.6, 0.4, 0.5)
)
gen &lt;- semPower.genSigma(Phi = Phi, loadings = loadings)

# Provide Beta for a three factor model
# with 3, 4, and 5 indicators 
# loading by .6, 5, and .4, respectively.
Beta &lt;- matrix(c(
                c(0.0, 0.0, 0.0),
                c(0.3, 0.0, 0.0),  # f2 = .3*f1
                c(0.2, 0.4, 0.0)   # f3 = .2*f1 + .4*f2
               ), byrow = TRUE, ncol = 3)
gen &lt;- semPower.genSigma(Beta = Beta, nIndicator = c(3, 4, 5), 
                         loadM = c(.6, .5, .4))

# two group example: 
# correlated two factor model (r = .25 and .35 in the first and second group, 
# respectively)
# the first factor is indicated by four indicators loading by .7 in the first 
# and .5 in the second group,
# the second factor is indicated by five indicators loading by .6 in the first 
# and .8 in the second group,
# all item intercepts are zero in both groups, 
# the latent means are zero in the first group
# and .25 and .10 in the second group.
gen &lt;- semPower.genSigma(Phi = list(.25, .35), 
                         nIndicator = list(c(4, 5), c(4, 5)), 
                         loadM = list(c(.7, .6), c(.5, .8)), 
                         tau = list(rep(0, 9), rep(0, 9)), 
                         Alpha = list(c(0, 0), c(.25, .10))
                         )
gen[[1]]$Sigma  # implied covariance matrix group 1 
gen[[2]]$Sigma  # implied covariance matrix group 2
gen[[1]]$mu     # implied means group 1 
gen[[2]]$mu     # implied means group 2

## End(Not run)
</code></pre>

<hr>
<h2 id='semPower.getDf'>semPower.getDf</h2><span id='topic+semPower.getDf'></span>

<h3>Description</h3>

<p>Determines the degrees of freedom of a given model provided as <code>lavaan</code> model string. This only returns the regular df and does not account for approaches using scaled df.
This requires the <code>lavaan</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semPower.getDf(lavModel, nGroups = NULL, group.equal = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semPower.getDf_+3A_lavmodel">lavModel</code></td>
<td>
<p>the <code>lavaan</code> model string. Can also include (restrictions on) defined parameters.</p>
</td></tr>
<tr><td><code id="semPower.getDf_+3A_ngroups">nGroups</code></td>
<td>
<p>for multigroup models: the number of groups.</p>
</td></tr>
<tr><td><code id="semPower.getDf_+3A_group.equal">group.equal</code></td>
<td>
<p>for multigroup models: vector defining the type(s) of cross-group equality constraints following the <code>lavaan</code> conventions (<code>loadings</code>, <code>intercepts</code>, <code>means</code>, <code>residuals</code>, <code>residual.covariances</code>, <code>lv.variances</code>, <code>lv.covariances</code>, <code>regressions</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the df of the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
lavModel &lt;- '
f1 =~ x1 + x2 + x3 + x4
f2 =~ x5 + x6 + x7 + x8
f3 =~ y1 + y2 + y3
f3 ~ f1 + f2
'
semPower.getDf(lavModel)

# multigroup version
semPower.getDf(lavModel, nGroups = 3)  
semPower.getDf(lavModel, nGroups = 3, group.equal = c('loadings'))
semPower.getDf(lavModel, nGroups = 3, group.equal = c('loadings', 'intercepts'))

## End(Not run)
</code></pre>

<hr>
<h2 id='semPower.postHoc'>semPower.postHoc</h2><span id='topic+semPower.postHoc'></span>

<h3>Description</h3>

<p>Performs a post-hoc power analysis, i. e., determines power (= 1 - beta) given alpha, df, and and a measure of effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semPower.postHoc(
  effect = NULL,
  effect.measure = NULL,
  alpha,
  N,
  df = NULL,
  p = NULL,
  SigmaHat = NULL,
  Sigma = NULL,
  muHat = NULL,
  mu = NULL,
  fittingFunction = "ML",
  simulatedPower = FALSE,
  modelH0 = NULL,
  modelH1 = NULL,
  simOptions = NULL,
  lavOptions = NULL,
  lavOptionsH1 = lavOptions,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semPower.postHoc_+3A_effect">effect</code></td>
<td>
<p>effect size specifying the discrepancy between the null hypothesis (H0) and the alternative hypothesis (H1). A list for multiple group models; a vector of length 2 for effect-size differences. Can be <code>NULL</code> if <code>Sigma</code> and <code>SigmaHat</code> are set.</p>
</td></tr>
<tr><td><code id="semPower.postHoc_+3A_effect.measure">effect.measure</code></td>
<td>
<p>type of effect, one of <code>"F0"</code>, <code>"RMSEA"</code>, <code>"Mc"</code>, <code>"GFI"</code>, <code>"AGFI"</code>. Can be <code>NULL</code> if <code>Sigma</code> and <code>SigmaHat</code> are set.</p>
</td></tr>
<tr><td><code id="semPower.postHoc_+3A_alpha">alpha</code></td>
<td>
<p>alpha error</p>
</td></tr>
<tr><td><code id="semPower.postHoc_+3A_n">N</code></td>
<td>
<p>the number of observations (a list for multiple group models)</p>
</td></tr>
<tr><td><code id="semPower.postHoc_+3A_df">df</code></td>
<td>
<p>the model degrees of freedom. See <code><a href="#topic+semPower.getDf">semPower.getDf()</a></code> for a way to obtain the df of a specific model.</p>
</td></tr>
<tr><td><code id="semPower.postHoc_+3A_p">p</code></td>
<td>
<p>the number of observed variables, only required for <code>effect.measure = "GFI"</code> and <code>effect.measure = "AGFI"</code>.</p>
</td></tr>
<tr><td><code id="semPower.postHoc_+3A_sigmahat">SigmaHat</code></td>
<td>
<p>can be used instead of <code>effect</code> and <code>effect.measure</code>: model implied covariance matrix (a list for multiple group models). Used in conjunction with <code>Sigma</code> to define the effect.</p>
</td></tr>
<tr><td><code id="semPower.postHoc_+3A_sigma">Sigma</code></td>
<td>
<p>can be used instead of <code>effect</code> and <code>effect.measure</code>: population covariance matrix (a list for multiple group models). Used in conjunction with <code>SigmaHat</code> to define effect.</p>
</td></tr>
<tr><td><code id="semPower.postHoc_+3A_muhat">muHat</code></td>
<td>
<p>can be used instead of <code>effect</code> and <code>effect.measure</code>: model implied mean vector. Used in conjunction with <code>mu</code>. If <code>NULL</code>, no meanstructure is involved.</p>
</td></tr>
<tr><td><code id="semPower.postHoc_+3A_mu">mu</code></td>
<td>
<p>can be used instead of <code>effect</code> and <code>effect.measure</code>: observed (or population) mean vector. Use in conjunction with <code>muHat</code>. If <code>NULL</code>, no meanstructure is involved.</p>
</td></tr>
<tr><td><code id="semPower.postHoc_+3A_fittingfunction">fittingFunction</code></td>
<td>
<p>one of <code>'ML'</code> (default), <code>'WLS'</code>, <code>'DWLS'</code>, <code>'ULS'</code>. Defines the discrepancy function used to obtain Fmin.</p>
</td></tr>
<tr><td><code id="semPower.postHoc_+3A_simulatedpower">simulatedPower</code></td>
<td>
<p>whether to perform a simulated (<code>TRUE</code>, rather than analytical, <code>FALSE</code>) power analysis. Only available if <code>Sigma</code> and <code>modelH0</code> are defined.</p>
</td></tr>
<tr><td><code id="semPower.postHoc_+3A_modelh0">modelH0</code></td>
<td>
<p>for simulated power: <code>lavaan</code> model string defining the (incorrect) analysis model.</p>
</td></tr>
<tr><td><code id="semPower.postHoc_+3A_modelh1">modelH1</code></td>
<td>
<p>for simulated power: <code>lavaan</code> model string defining the comparison model. If omitted, the saturated model is the comparison model.</p>
</td></tr>
<tr><td><code id="semPower.postHoc_+3A_simoptions">simOptions</code></td>
<td>
<p>a list of additional options specifying simulation details, see <code><a href="#topic+simulate">simulate()</a></code> for details.</p>
</td></tr>
<tr><td><code id="semPower.postHoc_+3A_lavoptions">lavOptions</code></td>
<td>
<p>a list of additional options passed to <code>lavaan</code>, e. g., <code>list(estimator = 'mlm')</code> to request robust ML estimation.</p>
</td></tr>
<tr><td><code id="semPower.postHoc_+3A_lavoptionsh1">lavOptionsH1</code></td>
<td>
<p>alternative options passed to <code>lavaan</code> that are only used for the H1 model. If <code>NULL</code>, identical to <code>lavOptions</code>. Probably only useful for multigroup models.</p>
</td></tr>
<tr><td><code id="semPower.postHoc_+3A_...">...</code></td>
<td>
<p>other parameters related to plots, notably <code>plotShow</code>, <code>plotShowLabels</code>, and <code>plotLinewidth</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list. Use <code>summary()</code> to obtain formatted results.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code> <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# achieved power with a sample of N = 250 to detect misspecifications corresponding
# to RMSEA &gt;= .05 on 200 df on alpha = .05.
ph &lt;- semPower.postHoc(effect = .05, effect.measure = "RMSEA", 
                       alpha = .05, N = 250, df = 200)
summary(ph)

# power analysis for to detect the difference between a model (with df = 200) exhibiting RMSEA = .05
# and a model (with df = 210) exhibiting RMSEA = .06.
ph &lt;- semPower.postHoc(effect = c(.05, .06), effect.measure = "RMSEA", 
                       alpha = .05, N = 500, df = c(200, 210))
summary(ph)

# multigroup example
ph &lt;- semPower.postHoc(effect = list(.02, .01), effect.measure = "F0", 
                        alpha = .05, N = list(250, 350), df = 200)
summary(ph)

# power analysis based on SigmaHat and Sigma (nonsense example)
ph &lt;- semPower.postHoc(alpha = .05, N = 1000, df = 5,  
                       SigmaHat = diag(4), 
                       Sigma = cov(matrix(rnorm(4*1000),  ncol=4)))
summary(ph)

# simulated power analysis (nonsense example)
ph &lt;- semPower.aPriori(alpha = .05, N = 500, df = 200,  
                       SigmaHat = list(diag(4), diag(4)), 
                       Sigma = list(cov(matrix(rnorm(4*1000), ncol=4)), 
                                    cov(matrix(rnorm(4*1000), ncol=4))),
                       simulatedPower = TRUE, nReplications = 100)
summary(ph)

## End(Not run)
</code></pre>

<hr>
<h2 id='semPower.powerARMA'>semPower.powerARMA</h2><span id='topic+semPower.powerARMA'></span>

<h3>Description</h3>

<p>Convenience function for performing power analysis on effects in an ARMA model.
This requires the lavaan package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semPower.powerARMA(
  type,
  comparison = "restricted",
  nWaves = NULL,
  autoregEffects = NULL,
  autoregLag1 = autoregEffects,
  autoregLag2 = NULL,
  autoregLag3 = NULL,
  mvAvgLag1 = NULL,
  mvAvgLag2 = NULL,
  mvAvgLag3 = NULL,
  means = NULL,
  variances = NULL,
  waveEqual = NULL,
  groupEqual = NULL,
  nullEffect = NULL,
  nullWhich = NULL,
  nullWhichGroups = NULL,
  invariance = TRUE,
  autocorResiduals = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semPower.powerARMA_+3A_type">type</code></td>
<td>
<p>type of power analysis, one of <code>'a-priori'</code>, <code>'post-hoc'</code>, <code>'compromise'</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerARMA_+3A_comparison">comparison</code></td>
<td>
<p>comparison model, one of <code>'saturated'</code> or <code>'restricted'</code> (the default). This determines the df for power analyses. <code>'saturated'</code> provides power to reject the model when compared to the saturated model, so the df equal the one of the hypothesized model. <code>'restricted'</code> provides power to reject the hypothesized model when compared to an otherwise identical model that just omits the restrictions defined in <code>nullEffect</code>, so the df equal the number of restrictions.</p>
</td></tr>
<tr><td><code id="semPower.powerARMA_+3A_nwaves">nWaves</code></td>
<td>
<p>number of waves, must be &gt;= 2.</p>
</td></tr>
<tr><td><code id="semPower.powerARMA_+3A_autoregeffects">autoregEffects</code></td>
<td>
<p>vector of the lag-1 autoregressive effects, e.g. <code>c(.7, .6)</code> for  autoregressive effects of .7 for <code>X1 -&gt; X2</code> and .6 for <code>X2 -&gt; X3</code>. Must be a list for multiple groups models.</p>
</td></tr>
<tr><td><code id="semPower.powerARMA_+3A_autoreglag1">autoregLag1</code></td>
<td>
<p>alternative name for autoregEffects.</p>
</td></tr>
<tr><td><code id="semPower.powerARMA_+3A_autoreglag2">autoregLag2</code></td>
<td>
<p>vector of lag-2 effects, e.g. <code>c(.2, .1)</code> for lag-2 effects of .2 for <code>X1 -&gt; X3</code> and .1 for <code>X2 -&gt; X4</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerARMA_+3A_autoreglag3">autoregLag3</code></td>
<td>
<p>vector of lag-3 effects, e.g. <code>c(.2)</code> for a lag-3 effect of .2 for <code>X1 -&gt; X4</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerARMA_+3A_mvavglag1">mvAvgLag1</code></td>
<td>
<p>vector of the lag-1 moving average parameters, e.g. <code>c(.4, .3)</code> for moving average parameters of .4 for <code>N1 -&gt; X2</code> and .3 for <code>N2 -&gt; X3</code>. Must be a list for multiple groups models.</p>
</td></tr>
<tr><td><code id="semPower.powerARMA_+3A_mvavglag2">mvAvgLag2</code></td>
<td>
<p>vector of the lag-2 moving average parameters, e.g. <code>c(.3, .2)</code> for moving average parameters effects of .2 for <code>N1 -&gt; X3</code> and .2 for <code>N2 -&gt; X4</code>. Must be a list for multiple groups models.</p>
</td></tr>
<tr><td><code id="semPower.powerARMA_+3A_mvavglag3">mvAvgLag3</code></td>
<td>
<p>vector of the lag-3  moving average parameters, e.g. <code>c(.2)</code> for a moving average parameter of .2 for <code>N1 -&gt; X4</code>. Must be a list for multiple groups models.</p>
</td></tr>
<tr><td><code id="semPower.powerARMA_+3A_means">means</code></td>
<td>
<p>vector of means of <code>X</code>. May be <code>NULL</code> for no meanstructure.</p>
</td></tr>
<tr><td><code id="semPower.powerARMA_+3A_variances">variances</code></td>
<td>
<p>vector of variances of the noise factors <code>N</code> (= residual variances of <code>X</code>).</p>
</td></tr>
<tr><td><code id="semPower.powerARMA_+3A_waveequal">waveEqual</code></td>
<td>
<p>parameters that are assumed to be equal across waves in both the H0 and the H1 model. Because ARMA models are likely not identified when no such constraints are imposed, this may not be empty. Valid are <code>'autoreg'</code>, <code>'autoregLag2'</code>, and  <code>'autoregLag3'</code> for autoregressive effects, <code>'mvAvg'</code>, <code>'mvAvgLag2'</code>, and  <code>'mvAvgLag3'</code> for moving average effects, <code>var</code> for the variance of the noise factors (starting at wave 2), <code>mean</code> for the conditional means of X  (starting at wave 2).</p>
</td></tr>
<tr><td><code id="semPower.powerARMA_+3A_groupequal">groupEqual</code></td>
<td>
<p>parameters that are restricted across groups in both the H0 and the H1 model, when <code>nullEffect</code> implies a multiple group model. Valid are <code>autoreg</code>, <code>mvAvg</code>, <code>var</code>, <code>mean</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerARMA_+3A_nulleffect">nullEffect</code></td>
<td>
<p>defines the hypothesis of interest. Valid are the same arguments as in <code>waveEqual</code> and additionally <code>'autoreg = 0'</code>, <code>'autoregLag2 = 0'</code>, <code>'autoregLag3 = 0'</code>, <code>'mvAvg = 0'</code>, <code>'mvAvgLag2 = 0'</code>, <code>'mvAvgLag3 = 0'</code>,  to constrain the autoregressive or moving average effects to zero, and <code>'autoregA = autoregB'</code>, <code>'mvAvgA = mvAvgB'</code>, <code>'varA = varB'</code>, <code>'meanA = meanB'</code> to constrain the autoregressive (lag-1) effects, moving average (lag-1) effects, variances of the noise factors, or means of the X to be equal across groups.</p>
</td></tr>
<tr><td><code id="semPower.powerARMA_+3A_nullwhich">nullWhich</code></td>
<td>
<p>used in conjunction with <code>nullEffect</code> to identify which parameter to constrain when there are multiple waves and parameters are not constant across waves. For example, <code>nullEffect = 'autoreg = 0'</code> with <code>nullWhich = 2</code> would constrain the second autoregressive effect for X to zero.</p>
</td></tr>
<tr><td><code id="semPower.powerARMA_+3A_nullwhichgroups">nullWhichGroups</code></td>
<td>
<p>for hypothesis involving cross-groups comparisons, vector indicating the groups for which equality constrains should be applied, e.g. <code>c(1, 3)</code> to constrain the relevant parameters of the first and the third group. If <code>NULL</code>, all groups are constrained to equality.</p>
</td></tr>
<tr><td><code id="semPower.powerARMA_+3A_invariance">invariance</code></td>
<td>
<p>whether metric invariance over waves is assumed (<code>TRUE</code>, the default) or not (<code>FALSE</code>). When means are part of the model, invariant intercepts are also assumed. This affects the df when the comparison model is the saturated model and generally affects power (also for comparisons to the restricted model).</p>
</td></tr>
<tr><td><code id="semPower.powerARMA_+3A_autocorresiduals">autocorResiduals</code></td>
<td>
<p>whether the residuals of the indicators of latent variables are autocorrelated over waves (<code>TRUE</code>, the default) or not (<code>FALSE</code>). This affects the df when the comparison model is the saturated model and generally affects power (also for comparisons to the restricted model).</p>
</td></tr>
<tr><td><code id="semPower.powerARMA_+3A_...">...</code></td>
<td>
<p>mandatory further parameters related to the specific type of power analysis requested, see <code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code>, <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code>, and <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>, and parameters specifying the factor model. The order of factors is (X1, X2, ..., X_nWaves). See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a power analysis to reject various hypotheses arising
in models with autoregressive and moving average parameters (ARMA models), where one variable <code>X</code> is repeatedly
assessed at different time points (<code>nWaves</code>), and autoregressive (lag-1 effects; <code>X1 -&gt; X2 -&gt; X3</code>, and optionally lag-2 and lag-3) effects,
and moving average parameters (<code>N1 -&gt;  X2</code>, or equivalently for lag-2 and lag-3 effects) are assumed.
</p>
<p>Relevant hypotheses in arising in an ARMA model are:
</p>

<ul>
<li> <p><code>autoreg</code>: Tests the hypothesis that the autoregressive lag-1 effects are equal across waves (stationarity of autoregressive lag-1 effects).
</p>
</li>
<li> <p><code>autoregLag2</code>: Tests the hypothesis that the autoregressive lag-2 effects are equal across waves (stationarity of autoregressive lag-2 effects).
</p>
</li>
<li> <p><code>autoregLag3</code>: Tests the hypothesis that the autoregressive lag-3 effects are equal across waves (stationarity of autoregressive lag-3 effects).
</p>
</li>
<li> <p><code>mvAvg</code>: Tests the hypothesis that the moving average lag-1 parameters are equal across waves (stationarity of moving average lag-1 effects).
</p>
</li>
<li> <p><code>mvAvgLag2</code>: Tests the hypothesis that the moving average lag-2 parameters are equal across waves (stationarity of moving average lag-2 effects).
</p>
</li>
<li> <p><code>mvAvgLag3</code>: Tests the hypothesis that the moving average lag-3 parameters are equal across waves (stationarity of moving average lag-3 effects).
</p>
</li>
<li> <p><code>var</code>: Tests the hypothesis that the variances of the noise factors N (= the residual variances of X) are equal across waves 2 to nWaves (stationarity of variance).
</p>
</li>
<li> <p><code>mean</code>: Tests the hypothesis that the conditional means of X are equal across waves 2 to nWaves (stationarity of means).
</p>
</li>
<li> <p><code>autoreg = 0</code>, <code>autoregLag2 = 0</code>, <code>autoregLag3 = 0</code>: Tests the hypothesis that the autoregressive effects of the specified lag is zero.
</p>
</li>
<li> <p><code>mvAvg = 0</code>, <code>mvAvgLag2 = 0</code>, <code>mvAvgLag3 = 0</code>: Tests the hypothesis that the moving average parameter of the specified lag is zero.
</p>
</li>
<li> <p><code>autoregA = autoregB</code>: Tests the hypothesis that the autoregressive lag-1 effect is equal across groups.
</p>
</li>
<li> <p><code>mvAvgA = mvAvgB</code>: Tests the hypothesis that the moving average lag-1 parameter is equal across groups.
</p>
</li>
<li> <p><code>varA = varB</code>: Tests the hypothesis that the variance of the noise factors are equal across groups.
</p>
</li>
<li> <p><code>meanA = meanB</code>: Tests the hypothesis that latent means are equal across groups.
</p>
</li></ul>

<p>For hypotheses regarding a simple autoregression, see <code><a href="#topic+semPower.powerAutoreg">semPower.powerAutoreg()</a></code>. For hypotheses regarding a CLPM structure, see <code><a href="#topic+semPower.powerCLPM">semPower.powerCLPM()</a></code>.  For hypotheses regarding longitudinal measurement invariance, see <code><a href="#topic+semPower.powerLI">semPower.powerLI()</a></code>.
</p>
<p>Beyond the arguments explicitly contained in the function call, additional arguments
are required specifying the factor model and the requested type of power analysis.
</p>
<p>Additional arguments related to the <strong>definition of the factor model</strong>:
</p>

<ul>
<li> <p><code>Lambda</code>: The factor loading matrix (with the number of columns equaling the number of factors).
</p>
</li>
<li> <p><code>loadings</code>: Can be used instead of <code>Lambda</code>: Defines the primary loadings for each factor in a list structure, e. g. <code>loadings = list(c(.5, .4, .6), c(.8, .6, .6, .4))</code> defines a two factor model with three indicators loading on the first factor by .5, , 4., and .6, and four indicators loading on the second factor by .8, .6, .6, and .4.
</p>
</li>
<li> <p><code>nIndicator</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>loadM</code>. Defines the number of indicators by factor, e. g., <code>nIndicator = c(3, 4)</code> defines a two factor model with three and four indicators for the first and second factor, respectively. <code>nIndicator</code> can also be a single number to define the same number of indicators for each factor.
</p>
</li>
<li> <p><code>loadM</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>nIndicator</code>. Defines the loading either for all indicators (if a single number is provided) or separately for each factor (if a vector is provided), e. g. <code>loadM = c(.5, .6)</code> defines the loadings of the first factor to equal .5 and those of the second factor do equal .6.
</p>
</li></ul>

<p>So either <code>Lambda</code>, or <code>loadings</code>, or <code>nIndicator</code> and <code>loadM</code> need to be defined. Note that neither may contain the noise factors.
If the model contains observed variables only, use <code>Lambda = diag(x)</code> where <code>x</code> is the number of variables.
</p>
<p>The order of the factors is (X1, X2, ..., X_nWaves).
</p>
<p>Additional arguments related to the requested type of <strong>power analysis</strong>:
</p>

<ul>
<li> <p><code>alpha</code>: The alpha error probability. Required for <code>type = 'a-priori'</code> and <code>type = 'post-hoc'</code>.
</p>
</li>
<li><p> Either <code>beta</code> or <code>power</code>: The beta error probability and the statistical power (1 - beta), respectively. Only for <code>type = 'a-priori'</code>.
</p>
</li>
<li> <p><code>N</code>: The sample size. Always required for <code>type = 'post-hoc'</code> and <code>type = 'compromise'</code>. For <code>type = 'a-priori'</code> and multiple group analysis, <code>N</code> is a list of group weights.
</p>
</li>
<li> <p><code>abratio</code>: The ratio of alpha to beta. Only for <code>type = 'compromise'</code>.
</p>
</li></ul>

<p>If a <strong>simulated power analysis</strong> (<code>simulatedPower = TRUE</code>) is requested, optional arguments can be provided as a list to <code>simOptions</code>:
</p>

<ul>
<li> <p><code>nReplications</code>: The targeted number of simulation runs. Defaults to 250, but larger numbers greatly improve accuracy at the expense of increased computation time.
</p>
</li>
<li> <p><code>minConvergenceRate</code>:  The minimum convergence rate required, defaults to .5. The maximum actual simulation runs are increased by a factor of 1/minConvergenceRate.
</p>
</li>
<li> <p><code>type</code>: specifies whether the data should be generated from a population assuming multivariate normality (<code>'normal'</code>; the default), or based on an approach generating non-normal data (<code>'IG'</code>, <code>'mnonr'</code>, <code>'RC'</code>, or <code>'VM'</code>).
The approaches generating non-normal data require additional arguments detailed below.
</p>
</li>
<li> <p><code>missingVars</code>: vector specifying the variables containing missing data (defaults to NULL).
</p>
</li>
<li> <p><code>missingVarProp</code>: can be used instead of <code>missingVars</code>: The proportion of variables containing missing data (defaults to zero).
</p>
</li>
<li> <p><code>missingProp</code>: The proportion of missingness for variables containing missing data (defaults to zero), either a single value or a vector giving the probabilities for each variable.
</p>
</li>
<li> <p><code>missingMechanism</code>: The missing data mechanism, one of <code>MCAR</code> (the default), <code>MAR</code>, or <code>NMAR</code>.
</p>
</li>
<li> <p><code>nCores</code>: The number of cores to use for parallel processing. Defaults to 1 (= no parallel processing). This requires the <code>doSNOW</code> package.
</p>
</li></ul>

<p><code>type = 'IG'</code> implements the independent generator approach (IG, Foldnes &amp; Olsson, 2016) approach
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors. This requires the <code>covsim</code> package.
</p>
<p><code>type = 'mnonr'</code> implements the approach suggested by Qu, Liu, &amp; Zhang (2020) and requires provision of  Mardia's multivariate skewness (<code>skewness</code>)  and kurtosis  (<code>kurtosis</code>), where
skewness must be non-negative and kurtosis must be at least 1.641 skewness + p (p + 0.774), where p is the number of variables. This requires the <code>mnonr</code> package.
</p>
<p><code>type = 'RK'</code> implements the approach suggested by Ruscio &amp; Kaczetow (2008) and requires provision of the population distributions
of each variable (<code>distributions</code>). <code>distributions</code> must be a list (if all variables shall be based on the same population distribution) or a list of lists.
Each component must specify the population distribution (e.g. <code>rchisq</code>) and additional arguments (<code>list(df = 2)</code>).
</p>
<p><code>type = 'VM'</code> implements the third-order polynomial method (Vale &amp; Maurelli, 1983)
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors.  This requires the <code>semTools</code> package.
</p>


<h3>Value</h3>

<p>a list. Use the <code>summary</code> method to obtain formatted results. Beyond the results of the power analysis and a number of effect size measures, the list contains the following components:
</p>
<table role = "presentation">
<tr><td><code>Sigma</code></td>
<td>
<p>the population covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the population mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td></tr>
<tr><td><code>SigmaHat</code></td>
<td>
<p>the H0 model implied covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code>muHat</code></td>
<td>
<p>the H0 model implied mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td></tr>
<tr><td><code>modelH0</code></td>
<td>
<p><code>lavaan</code> H0 model string.</p>
</td></tr>
<tr><td><code>modelH1</code></td>
<td>
<p><code>lavaan</code> H1 model string or <code>NULL</code> when the comparison refers to the saturated model.</p>
</td></tr>
<tr><td><code>simRes</code></td>
<td>
<p>detailed simulation results when a simulated power analysis (<code>simulatedPower = TRUE</code>) was performed.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+semPower.genSigma">semPower.genSigma()</a></code> <code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code> <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code> <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Determine required N in a 10-wave ARMA model
# to detect that the autoregressive effects differ across waves
# with a power of 80% on alpha = 5%, where
# X is measured by 3 indicators loading by .5 each (at each wave), and
# the autoregressive effects vary between .5 and .7, and
# the moving average parameters are .3 at each wave and
# are assumed to be constant across waves (in both the H0 and the H1 model) and
# there are no lagged effects, and
# metric invariance and autocorrelated residuals are assumed
powerARMA &lt;- semPower.powerARMA(
  'a-priori', alpha = .05, power = .80,
  nWaves = 10,
  autoregLag1 = c(.5, .7, .6, .5, .7, .6, .6, .5, .6),
  mvAvgLag1 = rep(.3, 9),
  variances = rep(1, 10),
  waveEqual = c('mvAvg'),
  nullEffect = 'autoreg',
  nIndicator = rep(3, 10), loadM = .5,
  invariance = TRUE, 
  autocorResiduals = TRUE
)

# show summary
summary(powerARMA)
# optionally use lavaan to verify the model was set-up as intended
lavaan::sem(powerARMA$modelH1, sample.cov = powerARMA$Sigma,
            sample.nobs = powerARMA$requiredN,
            sample.cov.rescale = FALSE)
lavaan::sem(powerARMA$modelH0, sample.cov = powerARMA$Sigma,
            sample.nobs = powerARMA$requiredN,
            sample.cov.rescale = FALSE)


# same as above, but determine power with N = 250 on alpha = .05
powerARMA &lt;- semPower.powerARMA(
  'post-hoc', alpha = .05, N = 250,
  nWaves = 10,
  autoregLag1 = c(.5, .7, .6, .5, .7, .6, .6, .5, .6),
  mvAvgLag1 = rep(.3, 9),
  variances = rep(1, 10),
  waveEqual = c('mvAvg'),
  nullEffect = 'autoreg',
  nIndicator = rep(3, 10), loadM = .5,
  invariance = TRUE, 
  autocorResiduals = TRUE
)

# same as above, but determine the critical chi-square with N = 250 so that alpha = beta
powerARMA &lt;- semPower.powerARMA(
  'compromise', abratio = 1, N = 250,
  nWaves = 10,
  autoregLag1 = c(.5, .7, .6, .5, .7, .6, .6, .5, .6),
  mvAvgLag1 = rep(.3, 9),
  variances = rep(1, 10),
  waveEqual = c('mvAvg'),
  nullEffect = 'autoreg',
  nIndicator = rep(3, 10), loadM = .5,
  invariance = TRUE, 
  autocorResiduals = TRUE
)
  
# same as above, but compare to the saturated model
# (rather than to the less restricted model)
powerARMA &lt;- semPower.powerARMA(
  'a-priori', alpha = .05, power = .80, comparison = 'saturated',
  nWaves = 10,
  autoregLag1 = c(.5, .7, .6, .5, .7, .6, .6, .5, .6),
  mvAvgLag1 = rep(.3, 9),
  variances = rep(1, 10),
  waveEqual = c('mvAvg'),
  nullEffect = 'autoreg',
  nIndicator = rep(3, 10), loadM = .5,
  invariance = TRUE, 
  autocorResiduals = TRUE
)


# same as above, but assume only observed variables
powerARMA &lt;- semPower.powerARMA(
  'a-priori', alpha = .05, power = .80,
  nWaves = 10,
  autoregLag1 = c(.5, .7, .6, .5, .7, .6, .6, .5, .6),
  mvAvgLag1 = rep(.3, 9),
  variances = rep(1, 10),
  waveEqual = c('mvAvg'),
  nullEffect = 'autoreg',
  Lambda = diag(1, 10),
  invariance = TRUE, 
  autocorResiduals = TRUE
)

# same as above, but provide reduced loadings matrix to define that
# X is measured by 3 indicators each loading by .5, .6, .4 (at each wave)
powerARMA &lt;- semPower.powerARMA(
  'a-priori', alpha = .05, power = .80,
  nWaves = 10,
  autoregLag1 = c(.5, .7, .6, .5, .7, .6, .6, .5, .6),
  mvAvgLag1 = rep(.3, 9),
  variances = rep(1, 10),
  waveEqual = c('mvAvg'),
  nullEffect = 'autoreg',
  loadings = list(
    c(.5, .6, .4),  # X1
    c(.5, .6, .4),  # X2
    c(.5, .6, .4),  # X3
    c(.5, .6, .4),  # X4
    c(.5, .6, .4),  # X5
    c(.5, .6, .4),  # X6
    c(.5, .6, .4),  # X7
    c(.5, .6, .4),  # X8
    c(.5, .6, .4),  # X9
    c(.5, .6, .4)   # X10
  ),
  invariance = TRUE, 
  autocorResiduals = TRUE
)

# same as above, but detect that the moving average parameters differ across waves
# with a power of 80% on alpha = 5%, where
# the moving average parameters vary between .05 and .4, and
# the autoregressive effects are .5 at each wave and
# are assumed to be constant across waves (in both the H0 and the H1 model)
powerARMA &lt;- semPower.powerARMA(
  'a-priori', alpha = .05, power = .80,
  nWaves = 10,
  autoregLag1 = rep(.5, 9),
  mvAvgLag1 = c(.1, .05, .2, .1, .1, .3, .4, .4, .4),
  variances = rep(1, 10),
  waveEqual = c('autoreg'),
  nullEffect = 'mvAvg',
  nIndicator = rep(3, 10), loadM = .5,
  invariance = TRUE, 
  autocorResiduals = TRUE
)


# same as above, but detect that the (noise) variances differ across waves
# with a power of 80% on alpha = 5%, where
# the variances vary between 0.5 and 2, and
# the autoregressive effects are .5 at each wave and
# the moving average parameters are .3 at each wave and
# bothj are assumed to be constant across waves (in both the H0 and the H1 model)
powerARMA &lt;- semPower.powerARMA(
  'a-priori', alpha = .05, power = .80,
  nWaves = 10,
  autoregLag1 = rep(.5, 9),
  mvAvgLag1 = rep(.3, 9),
  variances = c(1, .5, .7, .6, .7, .9, 1.2, 1.7, 2.0, 1.5),
  waveEqual = c('autoreg', 'mvAvg'),
  nullEffect = 'var',
  nIndicator = rep(3, 10), loadM = .5,
  invariance = TRUE, 
  autocorResiduals = TRUE
)


# same as above, but include a meanstructure and
# detect that the means differ across waves
# with a power of 80% on alpha = 5%, where
# the means vary between 0 and .5, and
# the autoregressive effects are .5 at each wave and
# the moving average parameters are .3 at each wave and
# the variances are 1 at each wave and
# all are assumed to be constant across waves (in both the H0 and the H1 model) and
# metric and scalar invariance is assumed
powerARMA &lt;- semPower.powerARMA(
  'a-priori', alpha = .05, power = .80,
  nWaves = 10,
  autoregLag1 = rep(.5, 9),
  mvAvgLag1 = rep(.3, 9),
  variances = rep(1, 10),
  means = c(0, .1, .2, .3, .4, .5, .3, .4, .5, .5),
  waveEqual = c('autoreg', 'mvAvg', 'var'),
  nullEffect = 'mean',
  nIndicator = rep(3, 10), loadM = .5,
  invariance = TRUE, 
  autocorResiduals = TRUE
)

# Determine required N in a 10-wave ARMA model
# to detect that the autoregressive lag-2 effects differ from zero
# with a power of 80% on alpha = 5%, where
# the lag-2 autoregressive effects are .2 at each wave and 
# the lag-2 autoregressive effects are .1 at each wave and
# the autoregressive effects are .5 at each wave and
# the moving average parameters are .3 at each wave and
# the noise variances are equal to 1 in each wave,
# and all are assumed to be constant across waves (in both the H0 and the H1 model) and
# metric invariance and autocorrelated residuals are assumed, and
# the autoregressive lag2- and lag3-effects are estimated 
powerARMA &lt;- semPower.powerARMA(
  'a-priori', alpha = .05, power = .80,
  nWaves = 10,
  autoregLag1 = rep(.5, 9),
  autoregLag2 = rep(.2, 8),
  autoregLag3 = rep(.1, 7),
  mvAvgLag1 = rep(.3, 9),
  variances = rep(1, 10),
  waveEqual = c('mvAvg', 'autoreg', 'var', 'autoreglag2', 'autoreglag3'),
  nullEffect = 'autoreglag2 = 0',
  nIndicator = rep(3, 10), loadM = .5,
  invariance = TRUE, 
  autocorResiduals = TRUE
)

# similar as above, but get required N to detect that 
# lag-2 moving average parameters are constant across waves 
powerARMA &lt;- semPower.powerARMA(
  'a-priori', alpha = .05, power = .80,
  nWaves = 10,
  autoregLag1 = rep(.5, 9),
  autoregLag2 = rep(.2, 8),
  mvAvgLag1 = rep(.3, 9),
  mvAvgLag2 = c(.1, .2, .3, .1, .2, .3, .1, .1),
  variances = rep(1, 10),
  waveEqual = c('mvAvg', 'autoreg', 'var', 'autoreglag2'),
  nullEffect = 'mvAvgLag2',
  nIndicator = rep(3, 10), loadM = .5,
  invariance = TRUE
)


# Determine required N in a 5-wave ARMA model
# to detect that the autoregressive effects in group 1
# differ from the ones in group 2, where
# both groups are equal-sized
# with a power of 80% on alpha = 5%, where
# X is measured by 3 indicators loading by .5 each (at each wave and in each group), and
# the autoregressive effects in group 1 are .5 (constant across waves) and
# the autoregressive effects in group 2 are .6 (constant across waves) and
# the moving average parameters are .25 at each wave and in both groups and
# the variances are 1 at each wave and in both groups and 
# all are assumed to be constant across waves (in both the H0 and the H1 model)
# metric invariance (across both waves and groups) and
# autocorrelated residuals are assumed
powerARMA &lt;- semPower.powerARMA(
  'a-priori', alpha = .05, power = .80, N = list(1, 1),
  nWaves = 5,
  autoregLag1 = list(
    c(.5, .5, .5, .5),   # group 1
    c(.6, .6, .6, .6)),  # group 2
  mvAvgLag1 = rep(.25, 4),
  variances = rep(1, 5),
  waveEqual = c('autoreg', 'var', 'mvavg'),
  nullEffect = 'autoregA = autoregB',
  nIndicator = rep(3, 5), loadM = .5,
  invariance = TRUE, 
  autocorResiduals = TRUE
)


# Determine required N in a 5-wave ARMA model
# to detect that the means in group 1
# differ from the means in group 2, where
# both groups are equal-sized
# with a power of 80% on alpha = 5%, where
# X is measured by 3 indicators loading by .5 each (at each wave and in each group), and
# the autoregressive effects are .5 at each wave and in both groups and
# the moving average parameters are .25 at each wave and in both groups and
# the variances are 1 at each wave and in both groups and 
# all are assumed to be constant across waves (in both the H0 and the H1 model) and
# invariance of variances, autoregressive effects, and moving average parameters 
# across groups as well as
# metric and scalar invariance (across both waves and groups) and
# autocorrelated residuals are assumed
powerARMA &lt;- semPower.powerARMA(
  'a-priori', alpha = .05, power = .80, N = list(1, 1),
  nWaves = 5,
  autoregLag1 = list(
    c(.5, .5, .5, .5),   # group 1
    c(.5, .5, .5, .5)),  # group 2
  mvAvgLag1 = rep(.25, 4),
  variances = rep(1, 5),
  means = list(
    c(0, .1, .1, .1, .1),  # group 1
    c(0, .4, .4, .4, .4)   # group 2
  ),
  waveEqual = c('autoreg', 'var', 'mvavg', 'mean'),
  groupEqual = c('var', 'autoreg', 'mvavg'),
  nullEffect = 'meanA = meanB',
  nIndicator = rep(3, 5), loadM = .5,
  invariance = TRUE, 
  autocorResiduals = TRUE
)

# perform a simulated post-hoc power analysis
# with 250 replications
set.seed(300121)
powerARMA &lt;- semPower.powerARMA(
  'post-hoc', alpha = .05, N = 500,
  nWaves = 5,
  autoregLag1 = c(.3, .7, .6, .3),
  mvAvgLag1 = rep(.3, 4),
  variances = rep(1, 5),
  waveEqual = c('mvAvg'),
  nullEffect = 'autoreg',
  nIndicator = rep(3, 5), loadM = .5,
  invariance = TRUE, 
  autocorResiduals = TRUE, 
  simulatedPower = TRUE,
  simOptions = list(nReplications = 250)
)

## End(Not run)
</code></pre>

<hr>
<h2 id='semPower.powerAutoreg'>semPower.powerAutoreg</h2><span id='topic+semPower.powerAutoreg'></span>

<h3>Description</h3>

<p>Convenience function for performing power analysis on effects in an autoregressive model.
This requires the lavaan package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semPower.powerAutoreg(
  type,
  comparison = "restricted",
  nWaves = NULL,
  autoregEffects = NULL,
  lag1Effects = autoregEffects,
  lag2Effects = NULL,
  lag3Effects = NULL,
  means = NULL,
  variances = NULL,
  waveEqual = NULL,
  nullEffect = NULL,
  nullWhich = NULL,
  nullWhichGroups = NULL,
  standardized = TRUE,
  invariance = TRUE,
  autocorResiduals = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semPower.powerAutoreg_+3A_type">type</code></td>
<td>
<p>type of power analysis, one of <code>'a-priori'</code>, <code>'post-hoc'</code>, <code>'compromise'</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerAutoreg_+3A_comparison">comparison</code></td>
<td>
<p>comparison model, one of <code>'saturated'</code> or <code>'restricted'</code> (the default). This determines the df for power analyses. <code>'saturated'</code> provides power to reject the model when compared to the saturated model, so the df equal the one of the hypothesized model. <code>'restricted'</code> provides power to reject the hypothesized model when compared to an otherwise identical model that just omits the restrictions defined in <code>nullEffect</code>, so the df equal the number of restrictions.</p>
</td></tr>
<tr><td><code id="semPower.powerAutoreg_+3A_nwaves">nWaves</code></td>
<td>
<p>number of waves, must be &gt;= 2.</p>
</td></tr>
<tr><td><code id="semPower.powerAutoreg_+3A_autoregeffects">autoregEffects</code></td>
<td>
<p>vector of the autoregressive effects, e.g. <code>c(.7, .6)</code> for  autoregressive effects of .7 for <code>X1 -&gt; X2</code> and .6 for <code>X2 -&gt; X3</code>. Must be a list for multiple groups models.</p>
</td></tr>
<tr><td><code id="semPower.powerAutoreg_+3A_lag1effects">lag1Effects</code></td>
<td>
<p>alternative name for <code>autoregEffects</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerAutoreg_+3A_lag2effects">lag2Effects</code></td>
<td>
<p>vector of lag-2 effects, e.g. <code>c(.2, .1)</code> for lag-2 effects of .2 for <code>X1 -&gt; X3</code> and .1 for <code>X2 -&gt; X4</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerAutoreg_+3A_lag3effects">lag3Effects</code></td>
<td>
<p>vector of lag-3 effects, e.g. <code>c(.2)</code> for a lag-3 effect of .2 for <code>X1 -&gt; X4</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerAutoreg_+3A_means">means</code></td>
<td>
<p>vector of means for <code>X</code>. Can be omitted for no meanstructure.</p>
</td></tr>
<tr><td><code id="semPower.powerAutoreg_+3A_variances">variances</code></td>
<td>
<p>vector of (residual-)variances for <code>X</code>. When omitted and <code>standardized = FALSE</code>, all (residual-)variances are equal to 1. When omitted and <code>standardized = TRUE</code>, the (residual-)variances are determined so that all variances are 1, and will thus typically differ from each other. When provided, <code>standardized</code> must be <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerAutoreg_+3A_waveequal">waveEqual</code></td>
<td>
<p>parameters that are assumed to be equal across waves in both the H0 and the H1 model. Valid are <code>'lag1'</code> (or equivalently <code>'autoreg'</code>), <code>'lag2'</code>, and  <code>'lag3'</code>, or <code>NULL</code> for none (so that all parameters are freely estimated, subject to the constraints defined in <code>nullEffect</code>).</p>
</td></tr>
<tr><td><code id="semPower.powerAutoreg_+3A_nulleffect">nullEffect</code></td>
<td>
<p>defines the hypothesis of interest. Valid are the same arguments as in <code>waveEqual</code> and additionally <code>'lag1 = 0'</code> (or equivalently <code>'autoregX = 0'</code>) <code>'lag2 = 0'</code>, <code>'lag3 = 0'</code> to constrain the autoregressive, lag-2, or lag-3 effects to zero, and <code>'autoregA = autoregB'</code> to the autoregressive effects be equal across groups.</p>
</td></tr>
<tr><td><code id="semPower.powerAutoreg_+3A_nullwhich">nullWhich</code></td>
<td>
<p>used in conjunction with <code>nullEffect</code> to identify which parameter to constrain when there are &gt; 2 waves and parameters are not constant across waves. For example, <code>nullEffect = 'lag1 = 0'</code> with <code>nullWhich = 2</code> would constrain the second autoregressive effect for X to zero.</p>
</td></tr>
<tr><td><code id="semPower.powerAutoreg_+3A_nullwhichgroups">nullWhichGroups</code></td>
<td>
<p>for hypothesis involving cross-groups comparisons, vector indicating the groups for which equality constrains should be applied, e.g. <code>c(1, 3)</code> to constrain the relevant parameters of the first and the third group. If <code>NULL</code>, all groups are constrained to equality.</p>
</td></tr>
<tr><td><code id="semPower.powerAutoreg_+3A_standardized">standardized</code></td>
<td>
<p>whether all parameters should be standardized (<code>TRUE</code>, the default). If <code>FALSE</code>, all regression relations are unstandardized.</p>
</td></tr>
<tr><td><code id="semPower.powerAutoreg_+3A_invariance">invariance</code></td>
<td>
<p>whether metric invariance over waves is assumed (<code>TRUE</code>, the default) or not (<code>FALSE</code>). When means are part of the model, invariant intercepts are also assumed. This affects the df when the comparison model is the saturated model and generally affects power (also for comparisons to the restricted model).</p>
</td></tr>
<tr><td><code id="semPower.powerAutoreg_+3A_autocorresiduals">autocorResiduals</code></td>
<td>
<p>whether the residuals of the indicators of latent variables are autocorrelated over waves (<code>TRUE</code>, the default) or not (<code>FALSE</code>). This affects the df when the comparison model is the saturated model and generally affects power (also for comparisons to the restricted model).</p>
</td></tr>
<tr><td><code id="semPower.powerAutoreg_+3A_...">...</code></td>
<td>
<p>mandatory further parameters related to the specific type of power analysis requested, see <code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code>, <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code>, and <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>, and parameters specifying the factor model. The order of factors is (X1, X2, ..., X_nWaves). See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a power analysis to reject various hypotheses arising
in simple autoregressive (simplex) models, where one variable is repeatedly
assessed at two or more different time points (<code>nWaves</code>), yielding
autoregressive effects (aka lag-1 effects or stabilities, ; <code>X1 -&gt; X2 -&gt; X3</code>), and optionally
lagged effects (<code>X1 -&gt;  X3</code>), variances, and means.
</p>
<p>Relevant hypotheses in arising in an autogressive model are:
</p>

<ul>
<li> <p><code>autoreg</code> or <code>lag1</code>: Tests the hypothesis that the autoregressive (lag-1) effects are equal across waves (stationarity of autoregressive parameters).
</p>
</li>
<li> <p><code>lag2</code>: Tests the hypothesis that the lag-2 effects are equal across waves (stationarity of lag-2 effects).
</p>
</li>
<li> <p><code>lag3</code>: Tests the hypothesis that the lag-3 effects are equal across waves (stationarity of lag-3 effects).
</p>
</li>
<li> <p><code>var</code>: Tests the hypothesis that the residual-variances of X (i.e., X_2, ..., X_nWaves) are equal across waves (stationarity of variance).
</p>
</li>
<li> <p><code>mean</code>: Tests the hypothesis that the conditional means of X (i.e., X_2, ..., X_nWaves) are equal across waves (stationarity of means).
</p>
</li>
<li> <p><code>autoreg = 0</code> or <code>lag1 = 0</code>: Tests the hypothesis that the autoregressive (lag-1) effect of X is zero.
</p>
</li>
<li> <p><code>lag2 = 0</code> and <code>lag3 = 0</code>: Tests the hypothesis that a lag-2 or a lag-3 effect is zero.
</p>
</li>
<li> <p><code>autoregA = autoregB</code> or <code>lag1A = lag1B</code>: : Tests the hypothesis that the autoregressive effect of X is equal across groups.
</p>
</li></ul>

<p>For hypotheses in an ARMA model, see <code><a href="#topic+semPower.powerARMA">semPower.powerARMA()</a></code>. For hypotheses regarding a CLPM structure, see <code><a href="#topic+semPower.powerCLPM">semPower.powerCLPM()</a></code>. For hypotheses regarding longitudinal measurement invariance, see <code><a href="#topic+semPower.powerLI">semPower.powerLI()</a></code>.
</p>
<p>Beyond the arguments explicitly contained in the function call, additional arguments
are required specifying the factor model and the requested type of power analysis.
</p>
<p>Additional arguments related to the <strong>definition of the factor model</strong>:
</p>

<ul>
<li> <p><code>Lambda</code>: The factor loading matrix (with the number of columns equaling the number of factors).
</p>
</li>
<li> <p><code>loadings</code>: Can be used instead of <code>Lambda</code>: Defines the primary loadings for each factor in a list structure, e. g. <code>loadings = list(c(.5, .4, .6), c(.8, .6, .6, .4))</code> defines a two factor model with three indicators loading on the first factor by .5, , 4., and .6, and four indicators loading on the second factor by .8, .6, .6, and .4.
</p>
</li>
<li> <p><code>nIndicator</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>loadM</code>. Defines the number of indicators by factor, e. g., <code>nIndicator = c(3, 4)</code> defines a two factor model with three and four indicators for the first and second factor, respectively. <code>nIndicator</code> can also be a single number to define the same number of indicators for each factor.
</p>
</li>
<li> <p><code>loadM</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>nIndicator</code>. Defines the loading either for all indicators (if a single number is provided) or separately for each factor (if a vector is provided), e. g. <code>loadM = c(.5, .6)</code> defines the loadings of the first factor to equal .5 and those of the second factor do equal .6.
</p>
</li></ul>

<p>So either <code>Lambda</code>, or <code>loadings</code>, or <code>nIndicator</code> and <code>loadM</code> need to be defined.
If the model contains observed variables only, use <code>Lambda = diag(x)</code> where <code>x</code> is the number of variables.
</p>
<p>Note that the order of the factors is (X1, X2, ..., X_nWaves).
</p>
<p>Additional arguments related to the requested type of <strong>power analysis</strong>:
</p>

<ul>
<li> <p><code>alpha</code>: The alpha error probability. Required for <code>type = 'a-priori'</code> and <code>type = 'post-hoc'</code>.
</p>
</li>
<li><p> Either <code>beta</code> or <code>power</code>: The beta error probability and the statistical power (1 - beta), respectively. Only for <code>type = 'a-priori'</code>.
</p>
</li>
<li> <p><code>N</code>: The sample size. Always required for <code>type = 'post-hoc'</code> and <code>type = 'compromise'</code>. For <code>type = 'a-priori'</code> and multiple group analysis, <code>N</code> is a list of group weights.
</p>
</li>
<li> <p><code>abratio</code>: The ratio of alpha to beta. Only for <code>type = 'compromise'</code>.
</p>
</li></ul>

<p>If a <strong>simulated power analysis</strong> (<code>simulatedPower = TRUE</code>) is requested, optional arguments can be provided as a list to <code>simOptions</code>:
</p>

<ul>
<li> <p><code>nReplications</code>: The targeted number of simulation runs. Defaults to 250, but larger numbers greatly improve accuracy at the expense of increased computation time.
</p>
</li>
<li> <p><code>minConvergenceRate</code>:  The minimum convergence rate required, defaults to .5. The maximum actual simulation runs are increased by a factor of 1/minConvergenceRate.
</p>
</li>
<li> <p><code>type</code>: specifies whether the data should be generated from a population assuming multivariate normality (<code>'normal'</code>; the default), or based on an approach generating non-normal data (<code>'IG'</code>, <code>'mnonr'</code>, <code>'RC'</code>, or <code>'VM'</code>).
The approaches generating non-normal data require additional arguments detailed below.
</p>
</li>
<li> <p><code>missingVars</code>: vector specifying the variables containing missing data (defaults to NULL).
</p>
</li>
<li> <p><code>missingVarProp</code>: can be used instead of <code>missingVars</code>: The proportion of variables containing missing data (defaults to zero).
</p>
</li>
<li> <p><code>missingProp</code>: The proportion of missingness for variables containing missing data (defaults to zero), either a single value or a vector giving the probabilities for each variable.
</p>
</li>
<li> <p><code>missingMechanism</code>: The missing data mechanism, one of <code>MCAR</code> (the default), <code>MAR</code>, or <code>NMAR</code>.
</p>
</li>
<li> <p><code>nCores</code>: The number of cores to use for parallel processing. Defaults to 1 (= no parallel processing). This requires the <code>doSNOW</code> package.
</p>
</li></ul>

<p><code>type = 'IG'</code> implements the independent generator approach (IG, Foldnes &amp; Olsson, 2016) approach
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors. This requires the <code>covsim</code> package.
</p>
<p><code>type = 'mnonr'</code> implements the approach suggested by Qu, Liu, &amp; Zhang (2020) and requires provision of  Mardia's multivariate skewness (<code>skewness</code>)  and kurtosis  (<code>kurtosis</code>), where
skewness must be non-negative and kurtosis must be at least 1.641 skewness + p (p + 0.774), where p is the number of variables. This requires the <code>mnonr</code> package.
</p>
<p><code>type = 'RK'</code> implements the approach suggested by Ruscio &amp; Kaczetow (2008) and requires provision of the population distributions
of each variable (<code>distributions</code>). <code>distributions</code> must be a list (if all variables shall be based on the same population distribution) or a list of lists.
Each component must specify the population distribution (e.g. <code>rchisq</code>) and additional arguments (<code>list(df = 2)</code>).
</p>
<p><code>type = 'VM'</code> implements the third-order polynomial method (Vale &amp; Maurelli, 1983)
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors.  This requires the <code>semTools</code> package.
</p>


<h3>Value</h3>

<p>a list. Use the <code>summary</code> method to obtain formatted results. Beyond the results of the power analysis and a number of effect size measures, the list contains the following components:
</p>
<table role = "presentation">
<tr><td><code>Sigma</code></td>
<td>
<p>the population covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the population mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td></tr>
<tr><td><code>SigmaHat</code></td>
<td>
<p>the H0 model implied covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code>muHat</code></td>
<td>
<p>the H0 model implied mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td></tr>
<tr><td><code>modelH0</code></td>
<td>
<p><code>lavaan</code> H0 model string.</p>
</td></tr>
<tr><td><code>modelH1</code></td>
<td>
<p><code>lavaan</code> H1 model string or <code>NULL</code> when the comparison refers to the saturated model.</p>
</td></tr>
<tr><td><code>simRes</code></td>
<td>
<p>detailed simulation results when a simulated power analysis (<code>simulatedPower = TRUE</code>) was performed.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+semPower.genSigma">semPower.genSigma()</a></code> <code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code> <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code> <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Determine required N in a 4-wave autoregressive model
# to detect an autoregressive effect between X1 -&gt; X2 of &gt;= .5
# with a power of 80% on alpha = 5%, where
# X is measured by 3 indicators loading by .5 each (at each wave), and 
# the autoregressive effecst are .5 (X1 -&gt; X2), .7 (X2 -&gt; X3), and .6 (X3 -&gt; X4), and
# there are no lagged effects, and
# metric invariance and autocorrelated residuals are assumed
powerAutoreg &lt;- semPower.powerAutoreg(
  'a-priori', alpha = .05, power = .80,
  nWaves = 4, 
  autoregEffects = c(.5, .7, .6),
  nullEffect = 'autoreg=0',
  nullWhich = 1,
  nIndicator = rep(3, 4), loadM = .5,
  invariance = TRUE, autocorResiduals = TRUE)

# show summary
summary(powerAutoreg)
# optionally use lavaan to verify the model was set-up as intended
lavaan::sem(powerAutoreg$modelH1, sample.cov = powerAutoreg$Sigma,
            sample.nobs = powerAutoreg$requiredN,
            sample.cov.rescale = FALSE)
lavaan::sem(powerAutoreg$modelH0, sample.cov = powerAutoreg$Sigma,
            sample.nobs = powerAutoreg$requiredN,
            sample.cov.rescale = FALSE)


# same as above, but determine power with N = 250 on alpha = .05
powerAutoreg &lt;- semPower.powerAutoreg(
  'post-hoc', alpha = .05, N = 250,
  nWaves = 4, 
  autoregEffects = c(.5, .7, .6),
  nullEffect = 'autoreg=0',
  nullWhich = 1,
  nIndicator = rep(3, 4), loadM = .5,
  invariance = TRUE, autocorResiduals = TRUE)

# same as above, but determine the critical chi-square with N = 250 so that alpha = beta
powerAutoreg &lt;- semPower.powerAutoreg(
  'compromise', abratio = 1, N = 250,
  nWaves = 4, 
  autoregEffects = c(.5, .7, .6),
  nullEffect = 'autoreg=0',
  nullWhich = 1,
  nIndicator = rep(3, 4), loadM = .5,
  invariance = TRUE, autocorResiduals = TRUE)

# same as above, but compare to the saturated model
# (rather than to the less restricted model)
powerAutoreg &lt;- semPower.powerAutoreg(
  'post-hoc', alpha = .05, N = 250,
  comparison = 'saturated',
  nWaves = 4, 
  autoregEffects = c(.5, .7, .6),
  nullEffect = 'autoreg=0',
  nullWhich = 1,
  nIndicator = rep(3, 4), loadM = .5,
  invariance = TRUE, autocorResiduals = TRUE)

# same as above, but assume only observed variables
powerAutoreg &lt;- semPower.powerAutoreg(
  'post-hoc', alpha = .05, N = 250,
  nWaves = 4, 
  autoregEffects = c(.5, .7, .6),
  nullEffect = 'autoreg=0',
  nullWhich = 1,
  Lambda = diag(4))

# same as above, but provide reduced loadings matrix to define that
# X is measured by 3 indicators each loading by .8, .6, .7 (at each wave)
powerAutoreg &lt;- semPower.powerAutoreg(
  'post-hoc', alpha = .05, N = 250,
  nWaves = 4, 
  autoregEffects = c(.5, .7, .6),
  nullEffect = 'autoreg=0',
  nullWhich = 1,
  loadings = list(
    c(.8, .6, .7),   # X1
    c(.8, .6, .7),   # X2
    c(.8, .6, .7),   # X3
    c(.8, .6, .7)    # X4
  ), 
  invariance = TRUE, autocorResiduals = TRUE)

# same as above, but assume wave-constant autoregressive effects
powerAutoreg &lt;- semPower.powerAutoreg(
  'a-priori', alpha = .05, power = .80,
  nWaves = 4, 
  autoregEffects = c(.6, .6, .6),
  waveEqual = c('autoreg'),
  nullEffect = 'autoreg=0',
  nIndicator = rep(3, 4), loadM = .5,
  invariance = TRUE, autocorResiduals = TRUE)


# same as above, but detect that autoregressive effects are not wave-constant
powerAutoreg &lt;- semPower.powerAutoreg(
  'a-priori', alpha = .05, power = .80,
  nWaves = 4, 
  autoregEffects = c(.6, .7, .8),
  nullEffect = 'autoreg',
  nIndicator = rep(3, 4), loadM = .5,
  invariance = TRUE, autocorResiduals = TRUE)

# same as above, but include lag-2 and lag-3 effects
powerAutoreg &lt;- semPower.powerAutoreg(
  'a-priori', alpha = .05, power = .80,
  nWaves = 4, 
  autoregEffects = c(.6, .6, .6),
  lag2Effects = c(.25, .20),
  lag3Effects = c(.15),
  waveEqual = c('autoreg'),
  nullEffect = 'autoreg=0',
  nIndicator = rep(3, 4), loadM = .5,
  invariance = TRUE, autocorResiduals = TRUE)


# same as above, but detect that first lag-2 effect differs from zero
powerAutoreg &lt;- semPower.powerAutoreg(
  'a-priori', alpha = .05, power = .80,
  nWaves = 4, 
  autoregEffects = c(.6, .6, .6),
  lag2Effects = c(.25, .20),
  lag3Effects = c(.15),
  waveEqual = c('autoreg'),
  nullEffect = 'lag2=0',
  nullWhich = 1,
  nIndicator = rep(3, 4), loadM = .5,
  invariance = TRUE, autocorResiduals = TRUE)


# same as above, but assume wave-constant lag2 effects
powerAutoreg &lt;- semPower.powerAutoreg(
  'a-priori', alpha = .05, power = .80,
  nWaves = 4, 
  autoregEffects = c(.6, .6, .6),
  lag2Effects = c(.25, .25),
  lag3Effects = c(.15),
  waveEqual = c('autoreg', 'lag2'),
  nullEffect = 'lag2=0',
  nIndicator = rep(3, 4), loadM = .5,
  invariance = TRUE, autocorResiduals = TRUE)


# same as above, but detect that lag3 effect differs from zero
powerAutoreg &lt;- semPower.powerAutoreg(
  'a-priori', alpha = .05, power = .80,
  nWaves = 4, 
  autoregEffects = c(.6, .6, .6),
  lag2Effects = c(.25, .25),
  lag3Effects = c(.15),
  waveEqual = c('autoreg', 'lag2'),
  nullEffect = 'lag3=0',
  nIndicator = rep(3, 4), loadM = .5,
  invariance = TRUE, autocorResiduals = TRUE)


# Determine required N in a 3-wave autoregressive model
# assuming wave-constant autoregressive effects 
# that the autoregressive effects in group 1
# differ from those in group 2
# with a power of 80% on alpha = 5%, where
# X is measured by 3 indicators loading by .5 each (at each wave and in each group), and 
# the autoregressive effect is .7 in group 1 and
# the autoregressive effect is .5 in group 2 and
# there are no lagged effects, and
# metric invariance over both time and groups and autocorrelated residuals are assumed and
# the groups are equal-sized
powerAutoreg &lt;- semPower.powerAutoreg(
  'a-priori', alpha = .05, power = .80, N = list(1, 1),
  nWaves = 3, 
  autoregEffects = list(
    c(.7, .7),
    c(.5, .5)
  ),
  waveEqual = c('autoreg'),
  nullEffect = 'autoregA = autoregB',
  nullWhich = 1,
  nIndicator = rep(3, 3), loadM = .5,
  invariance = TRUE, autocorResiduals = TRUE)
  
# Determine required N in a 4-wave autoregressive model
# to detect that the factor residual-variances (X2, X3, X4) differ
# with a power of 80% on alpha = 5%, where
# the (residual-)variances are 1, .5, 1.5, and 1, respectively,  
# X is measured by 3 indicators loading by .5 each (at each wave), and
# the autoregressive effects are .6, and
# both the H0 and the H1 assume wave-constant autoregressive effects, and
# there are no lagged effects, and
# metric invariance and autocorrelated residuals are assumed
powerAutoreg &lt;- semPower.powerAutoreg(
  'a-priori', alpha = .05, power = .80,
  nWaves = 4,
  autoregEffects = c(.6, .6, .6),
  variances = c(1, .5, 1.5, 1),
  waveEqual = c('autoreg'),
  nullEffect = 'var',
  nullWhich = 1,
  nIndicator = rep(3, 4), loadM = .5,
  standardized = FALSE,
  invariance = TRUE, 
  autocorResiduals = TRUE)

# same as above, but 
# include latent means and 
# detect that latent means differ and
# assume wave-constant variances and autoregressive parameters for both H0 and H1
powerAutoreg &lt;- semPower.powerAutoreg(
  'a-priori', alpha = .05, power = .80,
  nWaves = 4,
  autoregEffects = c(.6, .6, .6),
  variances = c(1, 1, 1, 1),
  means = c(0, .5, 1, .7),
  waveEqual = c('autoreg', 'var'),
  nullEffect = 'mean',
  nullWhich = 1,
  nIndicator = rep(3, 4), loadM = .5,
  standardized = FALSE,
  invariance = TRUE, 
  autocorResiduals = TRUE)
  
# request a simulated post-hoc power analysis with 500 replications
set.seed(300121)
powerAutoreg &lt;- semPower.powerAutoreg(
  'post-hoc', alpha = .05, N = 500,
  nWaves = 3, 
  autoregEffects = c(.7, .7),
  waveEqual = c('autoreg'),
  nullEffect = 'autoreg = 0',
  nullWhich = 1,
  nIndicator = rep(3, 3), loadM = .5,
  invariance = TRUE, autocorResiduals = TRUE, 
  simulatedPower = TRUE,
  simOptions = list(nReplications = 500)
  )
  

## End(Not run)
</code></pre>

<hr>
<h2 id='semPower.powerBifactor'>semPower.powerBifactor</h2><span id='topic+semPower.powerBifactor'></span>

<h3>Description</h3>

<p>Perform a power analysis for models including one or more bifactors to reject one of the following hypotheses:
(a) a zero correlation between two factors, (b) the equality of two correlations between factors,
or (c) the equality of a correlation between two factors across two or more groups.
This requires the lavaan package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semPower.powerBifactor(
  type,
  comparison = "restricted",
  bfLoadings = NULL,
  bfWhichFactors = NULL,
  Phi = NULL,
  nullEffect = "cor = 0",
  nullWhich = NULL,
  nullWhichGroups = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semPower.powerBifactor_+3A_type">type</code></td>
<td>
<p>type of power analysis, one of <code>'a-priori'</code>, <code>'post-hoc'</code>, <code>'compromise'</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerBifactor_+3A_comparison">comparison</code></td>
<td>
<p>comparison model, one of <code>'saturated'</code> or <code>'restricted'</code> (the default). This determines the df for power analyses. <code>'saturated'</code> provides power to reject the model when compared to the saturated model, so the df equal the one of the hypothesized model. <code>'restricted'</code> provides power to reject the hypothesized model when compared to an otherwise identical model that just omits the restrictions defined in <code>nullEffect</code>, so the df equal the number of restrictions.</p>
</td></tr>
<tr><td><code id="semPower.powerBifactor_+3A_bfloadings">bfLoadings</code></td>
<td>
<p>a single vector or a list containing one or more vectors giving the loadings on each bifactor. For example, list(rep(.6, 10), rep(.6, 10)) defines two bifactors with 10 indicators each, loading by .6 each. Can be a list of lists for multiple group models.</p>
</td></tr>
<tr><td><code id="semPower.powerBifactor_+3A_bfwhichfactors">bfWhichFactors</code></td>
<td>
<p>a list containing one or more vectors defining which (specific) factors defined in the respective arguments in ... are part of the bifactor structure. See details.</p>
</td></tr>
<tr><td><code id="semPower.powerBifactor_+3A_phi">Phi</code></td>
<td>
<p>either a single number defining the correlation between exactly two factors or the factor correlation matrix. Must only contain the bifactor(s) and the covariate(s). Must be a list for multiple group models. Phi assumes the following order (bifactor_1, bifactor_2, ..., bifactor_j, covariate_1,  covariate_2, ...,  covariate_k). See details.</p>
</td></tr>
<tr><td><code id="semPower.powerBifactor_+3A_nulleffect">nullEffect</code></td>
<td>
<p>defines the hypothesis of interest, must be one of <code>'cor = 0'</code> (the default) to test whether a correlation is zero, <code>'corX = corZ'</code> to test for the equality of correlations, and <code>'corA = corB'</code> to test for the equality of a correlation across groups. Define the correlations to be set to equality in <code>nullWhich</code> and the groups in <code>nullWhichGroups</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerBifactor_+3A_nullwhich">nullWhich</code></td>
<td>
<p>vector of size 2 indicating which factor correlation in <code>Phi</code> is hypothesized to equal zero when <code>nullEffect = 'cor = 0'</code>, or to restrict to equality across groups when <code>nullEffect = 'corA = corB'</code>, or list of vectors defining which correlations to restrict to equality when <code>nullEffect = 'corX = corZ'</code>. Can also contain more than two correlations, e.g., <code>list(c(1, 2), c(1, 3), c(2, 3))</code> to set <code>Phi[1, 2] = Phi[1, 3] = Phi[2, 3]</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerBifactor_+3A_nullwhichgroups">nullWhichGroups</code></td>
<td>
<p>for <code>nullEffect = 'corA = corB'</code>, vector indicating the groups for which equality constrains should be applied, e.g. <code>c(1, 3)</code> to constrain the relevant parameters of the first and the third group. If <code>NULL</code>, all groups are constrained to equality.</p>
</td></tr>
<tr><td><code id="semPower.powerBifactor_+3A_...">...</code></td>
<td>
<p>mandatory further parameters related to the specific type of power analysis requested, see <code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code>, <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code>, and <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>, and parameters specifying the factor model concerning the specific factors and the covariate(s). See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a power analysis to reject various hypotheses arising
in a model including a bifactor structure:
</p>

<ul>
<li> <p><code>nullEffect = 'cor = 0'</code>: Tests the hypothesis that the correlation between a bifactor and another factor (which can also be a bifactor) is zero.
</p>
</li>
<li> <p><code>nullEffect = 'corX = corZ'</code>: Tests the hypothesis that two or more correlations involving one or more bifactors are equal to each other.
</p>
</li>
<li> <p><code>nullEffect = 'corA = corB'</code>: Tests the hypothesis that the correlation between the bifactor and another factor (which can also be a  bifactor) is equal in two or more groups (always assuming metric invariance).
</p>
</li></ul>

<p>A bifactor structure is defined by specifying the loadings on the general factor in <code>bfLoadings</code>, the comprised specific
factors in <code>bfWhichFactors</code>, and the loadings on the specific factors in either <code>Lambda</code>, or <code>loadings</code>,
or <code>nIndicator</code> and <code>loadM</code>. The latter arguments also include the loadings defining the
covariate(s).
</p>
<p>The correlations betwen the bifactor(s) and the covariate(s) are defined in <code>Phi</code>, which
must omit the specific factors and only includes the bifactor(s) and the covariate(s) assuming
the following order: (bifactor_1, bifactor_2, ..., bifactor_j, covariate_1,  covariate_2, ...,  covariate_k).
</p>
<p>For example, the following defines a single bifactor with 10 indicators loading by .5 each.
The bifactor structure involves 3 specific factors measured by 3 indicators each, each loading by
.3, .2, and .1 on the respective specific factor (in addition to the loadings on the bifactor).
Furthermore, two covariate with 5 indicators each, all loading by .7, are defined. The correlation
between the covariates is .5, the one between the bifactor and the first and second covariate are
.3 and .2, respectively.
</p>
<div class="sourceCode"><pre>bfLoadings &lt;- rep(.5, 10)
bfWhichFactors &lt;- c(1, 2, 3)
loadings &lt;- list(
  rep(.3, 3),   # specific factor 1
  rep(.2, 3),   # specific factor 2
  rep(.1, 3),   # specific factor 3
  rep(.7, 5),   # covariate 1
  rep(.7, 5)    # covariate 2
)
Phi &lt;- matrix(c(
  c(1, .3, .2),   # bifactor
  c(.3, 1, .5),   # covariate 1
  c(.2, .5, 1)   # covariate 2
), ncol = 3, byrow = TRUE) 
</pre></div>
<p>Beyond the arguments explicitly contained in the function call, additional arguments
are required specifying the factor model and the requested type of power analysis.
</p>
<p>Additional arguments related to the <strong>definition of the factor model</strong> concerning the specific factors and the covariate(s). The loadings on the bifactor must be provided via <code>bfLoadings</code>.
</p>

<ul>
<li> <p><code>Lambda</code>: The factor loading matrix (with the number of columns equaling the number of specific factors and covariates).
</p>
</li>
<li> <p><code>loadings</code>: Can be used instead of <code>Lambda</code>: Defines the primary loadings for each factor in a list structure, e. g. <code>loadings = list(c(.5, .4, .6), c(.8, .6, .6, .4))</code> defines a two factor model with three indicators loading on the first factor by .5, , 4., and .6, and four indicators loading on the second factor by .8, .6, .6, and .4.
</p>
</li>
<li> <p><code>nIndicator</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>loadM</code>. Defines the number of indicators by factor, e. g., <code>nIndicator = c(3, 4)</code> defines a two factor model with three and four indicators for the first and second factor, respectively. <code>nIndicator</code> can also be a single number to define the same number of indicators for each factor.
</p>
</li>
<li> <p><code>loadM</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>nIndicator</code>. Defines the loading either for all indicators (if a single number is provided) or separately for each factor (if a vector is provided), e. g. <code>loadM = c(.5, .6)</code> defines the loadings of the first factor to equal .5 and those of the second factor do equal .6.
</p>
</li></ul>

<p>Additional arguments related to the requested type of <strong>power analysis</strong>:
</p>

<ul>
<li> <p><code>alpha</code>: The alpha error probability. Required for <code>type = 'a-priori'</code> and <code>type = 'post-hoc'</code>.
</p>
</li>
<li><p> Either <code>beta</code> or <code>power</code>: The beta error probability and the statistical power (1 - beta), respectively. Only for <code>type = 'a-priori'</code>.
</p>
</li>
<li> <p><code>N</code>: The sample size. Always required for <code>type = 'post-hoc'</code> and <code>type = 'compromise'</code>. For <code>type = 'a-priori'</code> and multiple group analysis, <code>N</code> is a list of group weights.
</p>
</li>
<li> <p><code>abratio</code>: The ratio of alpha to beta. Only for <code>type = 'compromise'</code>.
</p>
</li></ul>

<p>If a <strong>simulated power analysis</strong> (<code>simulatedPower = TRUE</code>) is requested, optional arguments can be provided as a list to <code>simOptions</code>:
</p>

<ul>
<li> <p><code>nReplications</code>: The targeted number of simulation runs. Defaults to 250, but larger numbers greatly improve accuracy at the expense of increased computation time.
</p>
</li>
<li> <p><code>minConvergenceRate</code>:  The minimum convergence rate required, defaults to .5. The maximum actual simulation runs are increased by a factor of 1/minConvergenceRate.
</p>
</li>
<li> <p><code>type</code>: specifies whether the data should be generated from a population assuming multivariate normality (<code>'normal'</code>; the default), or based on an approach generating non-normal data (<code>'IG'</code>, <code>'mnonr'</code>, <code>'RC'</code>, or <code>'VM'</code>).
The approaches generating non-normal data require additional arguments detailed below.
</p>
</li>
<li> <p><code>missingVars</code>: vector specifying the variables containing missing data (defaults to NULL).
</p>
</li>
<li> <p><code>missingVarProp</code>: can be used instead of <code>missingVars</code>: The proportion of variables containing missing data (defaults to zero).
</p>
</li>
<li> <p><code>missingProp</code>: The proportion of missingness for variables containing missing data (defaults to zero), either a single value or a vector giving the probabilities for each variable.
</p>
</li>
<li> <p><code>missingMechanism</code>: The missing data mechanism, one of <code>MCAR</code> (the default), <code>MAR</code>, or <code>NMAR</code>.
</p>
</li>
<li> <p><code>nCores</code>: The number of cores to use for parallel processing. Defaults to 1 (= no parallel processing). This requires the <code>doSNOW</code> package.
</p>
</li></ul>

<p><code>type = 'IG'</code> implements the independent generator approach (IG, Foldnes &amp; Olsson, 2016) approach
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors. This requires the <code>covsim</code> package.
</p>
<p><code>type = 'mnonr'</code> implements the approach suggested by Qu, Liu, &amp; Zhang (2020) and requires provision of  Mardia's multivariate skewness (<code>skewness</code>)  and kurtosis  (<code>kurtosis</code>), where
skewness must be non-negative and kurtosis must be at least 1.641 skewness + p (p + 0.774), where p is the number of variables. This requires the <code>mnonr</code> package.
</p>
<p><code>type = 'RK'</code> implements the approach suggested by Ruscio &amp; Kaczetow (2008) and requires provision of the population distributions
of each variable (<code>distributions</code>). <code>distributions</code> must be a list (if all variables shall be based on the same population distribution) or a list of lists.
Each component must specify the population distribution (e.g. <code>rchisq</code>) and additional arguments (<code>list(df = 2)</code>).
</p>
<p><code>type = 'VM'</code> implements the third-order polynomial method (Vale &amp; Maurelli, 1983)
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors.  This requires the <code>semTools</code> package.
</p>


<h3>Value</h3>

<p>a list. Use the <code>summary</code> method to obtain formatted results. Beyond the results of the power analysis and a number of effect size measures, the list contains the following components:
</p>
<table role = "presentation">
<tr><td><code>Sigma</code></td>
<td>
<p>the population covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the population mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td></tr>
<tr><td><code>SigmaHat</code></td>
<td>
<p>the H0 model implied covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code>muHat</code></td>
<td>
<p>the H0 model implied mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td></tr>
<tr><td><code>modelH0</code></td>
<td>
<p><code>lavaan</code> H0 model string.</p>
</td></tr>
<tr><td><code>modelH1</code></td>
<td>
<p><code>lavaan</code> H1 model string or <code>NULL</code> when the comparison refers to the saturated model.</p>
</td></tr>
<tr><td><code>simRes</code></td>
<td>
<p>detailed simulation results when a simulated power analysis (<code>simulatedPower = TRUE</code>) was performed.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+semPower.genSigma">semPower.genSigma()</a></code> <code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code> <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code> <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# get required N to detect a correlation of &gt;= .3 between
# a single bifactor with 11 indicators all loadings by .6
# spanning the indicators of 3 specific factors
# with three indicators each, loading by .2, .15, and .25, respectively
# and a covariate measured by 4 indicators loading by .7 each,
# with a power of 95% on alpha = 5%
bfLoadings &lt;- rep(.6, 11)
bfWhichFactors &lt;- c(1, 2, 3)
loadings &lt;- list(
  # specific factors
  rep(.2, 3),
  rep(.15, 3),
  rep(.25, 3),
  # covariate
  rep(.7, 4)
)
Phi &lt;- .3    # bifactor - covariate
powerbifactor &lt;- semPower.powerBifactor(type = 'a-priori',
                                        bfLoadings = bfLoadings,
                                        bfWhichFactors = bfWhichFactors,
                                        Phi = Phi,
                                        nullWhich = c(1, 2),
                                        loadings = loadings,
                                        alpha = .05, beta = .05)
# show summary
summary(powerbifactor)
# optionally use lavaan to verify the model was set-up as intended
lavaan::sem(powerbifactor$modelH1, sample.cov = powerbifactor$Sigma,
            sample.nobs = powerbifactor$requiredN, 
            sample.cov.rescale = FALSE)
lavaan::sem(powerbifactor$modelH0, sample.cov = powerbifactor$Sigma,
            sample.nobs = powerbifactor$requiredN, 
            sample.cov.rescale = FALSE)

# same as above, but determine power with N = 500 on alpha = .05
powerbifactor &lt;- semPower.powerBifactor(type = 'post-hoc',
                                        bfLoadings = bfLoadings,
                                        bfWhichFactors = bfWhichFactors,
                                        Phi = Phi,
                                        nullWhich = c(1, 2),
                                        loadings = loadings,
                                        alpha = .05, N = 500)

# same as above, but determine the critical chi-square with N = 500 so that alpha = beta
powerbifactor &lt;- semPower.powerBifactor(type = 'compromise',
                                        bfLoadings = bfLoadings,
                                        bfWhichFactors = bfWhichFactors,
                                        Phi = Phi,
                                        nullWhich = c(1, 2),
                                        loadings = loadings,
                                        abratio = 1, N = 500)

# same as above, but compare to the saturated model
# (rather than to the less restricted model)
powerbifactor &lt;- semPower.powerBifactor(type = 'a-priori',
                                        comparison = 'saturated',
                                        bfLoadings = bfLoadings,
                                        bfWhichFactors = bfWhichFactors,
                                        Phi = Phi,
                                        nullWhich = c(1, 2),
                                        loadings = loadings,
                                        alpha = .05, beta = .05)

# define two bifactors with 10 indicators each, where
# all loadings are .6 on the first and .5 on the second bifactor.
# the first bifactor spans the indicators of specific factors 1-3,
# the second bifactor spans the indicators of specific factors 4-6,
# all specific factors are measured by three indicators each,
# loadings are .2, .15, .25, .1, .15., and.2, respectively.
# define an additional  covariate measured by 4 indicators loading by .6 each.
# get required N to detect a correlation of &gt;= .3 between the bifactors
# with a power of 95% on alpha = 5%
bfLoadings &lt;- list(rep(.6, 10),
                   rep(.6, 10))
bfWhichFactors &lt;- list(c(1, 2, 3),
                       c(4, 5, 6))
loadings &lt;- list(
  # specific factors for bf1
  rep(.2, 3),
  rep(.15, 3),
  rep(.25, 3),
  # specific factors bf2
  rep(.1, 3),
  rep(.15, 3),
  rep(.2, 3),
  # covariate
  rep(.6, 4)
)
Phi &lt;- diag(3)
Phi[1, 2] &lt;- Phi[2, 1] &lt;- .3    # bifactor1 - bifactor2
Phi[1, 3] &lt;- Phi[3, 1] &lt;- .5    # bifactor1 - covariate
Phi[2, 3] &lt;- Phi[3, 2] &lt;- .1    # bifactor2 - covariate

powerbifactor &lt;- semPower.powerBifactor(type = 'a-priori',
                                        bfLoadings = bfLoadings,
                                        bfWhichFactors = bfWhichFactors,
                                        Phi = Phi,
                                        nullWhich = c(1, 2),
                                        loadings = loadings,
                                        alpha = .05, beta = .05)

# same as above, but get required N to detect that
# the correlation between the first bifactor and the covariate (of r=.5) differs from
# the correlation between the second bifactor and the covariate (of r=.1)
powerbifactor &lt;- semPower.powerBifactor(type = 'a-priori',
                                        bfLoadings = bfLoadings,
                                        bfWhichFactors = bfWhichFactors,
                                        Phi = Phi,
                                        nullEffect = 'corx = corz',
                                        nullWhich = list(c(1, 3), c(2, 3)),
                                        loadings = loadings,
                                        alpha = .05, beta = .05)

# multiple group example: get required N to detect that
# the correlation of a bifactor with 10 indicators
# spanning three specific factors with 3 indicators each
# to a covariate in group 1  (of r = .3)
# differs from the one in group 2 (of r = .1)
bfLoadings &lt;- rep(.6, 10)
bfWhichFactors &lt;- c(1, 2, 3)
loadings &lt;- list(
  # specific factors
  rep(.2, 3),
  rep(.15, 3),
  rep(.25, 3),
  # covariate
  rep(.7, 4)
)
Phi1 &lt;- Phi2 &lt;- diag(2)
Phi1[1, 2] &lt;- Phi1[2, 1] &lt;- .3    # bifactor - covariate
Phi2[1, 2] &lt;- Phi2[2, 1] &lt;- .1    # bifactor - covariate
Phi &lt;- list(Phi1, Phi2)
powerbifactor &lt;- semPower.powerBifactor(type = 'a-priori',
                                        bfLoadings = bfLoadings,
                                        bfWhichFactors = bfWhichFactors,
                                        Phi = Phi,
                                        nullEffect = 'corA = corB',
                                        nullWhich = c(1, 2),
                                        loadings = loadings,
                                        alpha = .05, beta = .05, 
                                        N = list(1, 1))
                                        
# request a simulated post-hoc power analysis with 500 replications.
bfLoadings &lt;- rep(.6, 11)
bfWhichFactors &lt;- c(1, 2, 3)
loadings &lt;- list(
  # specific factors
  rep(.2, 3),
  rep(.15, 3),
  rep(.1, 3),
  # covariate
  rep(.7, 5)
)
Phi &lt;- .2  
set.seed(300121)
powerbifactor &lt;- semPower.powerBifactor(type = 'post-hoc',
                                        bfLoadings = bfLoadings,
                                        bfWhichFactors = bfWhichFactors,
                                        Phi = Phi,
                                        nullWhich = c(1, 2),
                                        loadings = loadings,
                                        alpha = .05, N = 500, 
                                        simulatedPower = TRUE,
                                        simOptions = list(nReplications = 500)
                                        )

## End(Not run)
</code></pre>

<hr>
<h2 id='semPower.powerCFA'>semPower.powerCFA</h2><span id='topic+semPower.powerCFA'></span>

<h3>Description</h3>

<p>Convenience function for performing power analyses for CFA models to reject one of the following hypotheses:
(a) a zero correlation between two factors, (b) the equality of two correlations between factors,
or (c) the equality of a correlation between two factors across two or more groups.
This requires the lavaan package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semPower.powerCFA(
  type,
  comparison = "restricted",
  Phi = NULL,
  nullEffect = "cor = 0",
  nullWhich = NULL,
  nullWhichGroups = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semPower.powerCFA_+3A_type">type</code></td>
<td>
<p>type of power analysis, one of <code>'a-priori'</code>, <code>'post-hoc'</code>, <code>'compromise'</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerCFA_+3A_comparison">comparison</code></td>
<td>
<p>comparison model, one of <code>'saturated'</code> or <code>'restricted'</code> (the default). This determines the df for power analyses. <code>'saturated'</code> provides power to reject the model when compared to the saturated model, so the df equal the one of the hypothesized model. <code>'restricted'</code> provides power to reject the hypothesized model when compared to an otherwise identical model that just omits the restrictions defined in <code>nullEffect</code>, so the df equal the number of restrictions.</p>
</td></tr>
<tr><td><code id="semPower.powerCFA_+3A_phi">Phi</code></td>
<td>
<p>either a single number defining the correlation between exactly two factors or the factor correlation matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code id="semPower.powerCFA_+3A_nulleffect">nullEffect</code></td>
<td>
<p>defines the hypothesis of interest, must be one of <code>'cor = 0'</code> (the default) to test whether a correlation is zero, <code>'corX = corZ'</code> to test for the equality of correlations, <code>'corA = corB'</code> to test for the equality of a correlation across groups, and <code>loading = 0</code> to test whether a loading is zero. Define the correlations to be set to equality in <code>nullWhich</code> and the groups in <code>nullWhichGroups</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerCFA_+3A_nullwhich">nullWhich</code></td>
<td>
<p>vector of size 2 indicating which element in Lambda should equal zero when <code>nullEffect = 'loading = 0'</code>, or which factor correlation in <code>Phi</code> is hypothesized to equal zero when <code>nullEffect = 'cor = 0'</code>, or to restrict to equality across groups when <code>nullEffect = 'corA = corB'</code>, or list of vectors defining which correlations to restrict to equality when <code>nullEffect = 'corX = corZ'</code>. Can also contain more than two correlations, e.g., <code>list(c(1, 2), c(1, 3), c(2, 3))</code> to set <code>Phi[1, 2] = Phi[1, 3] = Phi[2, 3]</code>. If omitted, the correlation between the first and the second factor is targeted, i. e., <code>nullWhich = c(1, 2)</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerCFA_+3A_nullwhichgroups">nullWhichGroups</code></td>
<td>
<p>for <code>nullEffect = 'corA = corB'</code>, vector indicating the groups for which equality constrains should be applied, e.g. <code>c(1, 3)</code> to constrain the relevant parameters of the first and the third group. If <code>NULL</code>, all groups are constrained to equality.</p>
</td></tr>
<tr><td><code id="semPower.powerCFA_+3A_...">...</code></td>
<td>
<p>mandatory further parameters related to the specific type of power analysis requested, see <code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code>, <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code>, and <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>, and parameters specifying the factor model. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a power analysis to reject various hypotheses arising
in standard CFA models:
</p>

<ul>
<li> <p><code>nullEffect = 'loading = 0'</code>: Tests the hypothesis that a loading is zero.
</p>
</li>
<li> <p><code>nullEffect = 'cor = 0'</code>: Tests the hypothesis that the correlation between two factors is zero.
</p>
</li>
<li> <p><code>nullEffect = 'corX = corZ'</code>: Tests the hypothesis that two or more correlations between three or more factors are equal to each other.
</p>
</li>
<li> <p><code>nullEffect = 'corA = corB'</code>: Tests the hypothesis that the correlation between two factors is equal in two or more groups (always assuming metric invariance).
</p>
</li></ul>

<p>For hypotheses regarding regression relationships between factors, see <code><a href="#topic+semPower.powerRegression">semPower.powerRegression()</a></code>.
For hypotheses regarding mediation effects, see <code><a href="#topic+semPower.powerMediation">semPower.powerMediation()</a></code>.
For hypotheses regarding measurement invariance, see <code><a href="#topic+semPower.powerMI">semPower.powerMI()</a></code>.
</p>
<p>Beyond the arguments explicitly contained in the function call, additional arguments
are required specifying the factor model and the requested type of power analysis.
</p>
<p>Additional arguments related to the <strong>definition of the factor model</strong>:
</p>

<ul>
<li> <p><code>Lambda</code>: The factor loading matrix (with the number of columns equaling the number of factors).
</p>
</li>
<li> <p><code>loadings</code>: Can be used instead of <code>Lambda</code>: Defines the primary loadings for each factor in a list structure, e. g. <code>loadings = list(c(.5, .4, .6), c(.8, .6, .6, .4))</code> defines a two factor model with three indicators loading on the first factor by .5, , 4., and .6, and four indicators loading on the second factor by .8, .6, .6, and .4.
</p>
</li>
<li> <p><code>nIndicator</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>loadM</code>. Defines the number of indicators by factor, e. g., <code>nIndicator = c(3, 4)</code> defines a two factor model with three and four indicators for the first and second factor, respectively. <code>nIndicator</code> can also be a single number to define the same number of indicators for each factor.
</p>
</li>
<li> <p><code>loadM</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>nIndicator</code>. Defines the loading either for all indicators (if a single number is provided) or separately for each factor (if a vector is provided), e. g. <code>loadM = c(.5, .6)</code> defines the loadings of the first factor to equal .5 and those of the second factor do equal .6.
</p>
</li></ul>

<p>So either <code>Lambda</code>, or <code>loadings</code>, or <code>nIndicator</code> and <code>loadM</code> need to be defined.
If the model contains observed variables only, use <code>Lambda = diag(x)</code> where <code>x</code> is the number of variables.
</p>
<p>Additional arguments related to the requested type of <strong>power analysis</strong>:
</p>

<ul>
<li> <p><code>alpha</code>: The alpha error probability. Required for <code>type = 'a-priori'</code> and <code>type = 'post-hoc'</code>.
</p>
</li>
<li><p> Either <code>beta</code> or <code>power</code>: The beta error probability and the statistical power (1 - beta), respectively. Only for <code>type = 'a-priori'</code>.
</p>
</li>
<li> <p><code>N</code>: The sample size. Always required for <code>type = 'post-hoc'</code> and <code>type = 'compromise'</code>. For <code>type = 'a-priori'</code> and multiple group analysis, <code>N</code> is a list of group weights.
</p>
</li>
<li> <p><code>abratio</code>: The ratio of alpha to beta. Only for <code>type = 'compromise'</code>.
</p>
</li></ul>

<p>If a <strong>simulated power analysis</strong> (<code>simulatedPower = TRUE</code>) is requested, optional arguments can be provided as a list to <code>simOptions</code>:
</p>

<ul>
<li> <p><code>nReplications</code>: The targeted number of simulation runs. Defaults to 250, but larger numbers greatly improve accuracy at the expense of increased computation time.
</p>
</li>
<li> <p><code>minConvergenceRate</code>:  The minimum convergence rate required, defaults to .5. The maximum actual simulation runs are increased by a factor of 1/minConvergenceRate.
</p>
</li>
<li> <p><code>type</code>: specifies whether the data should be generated from a population assuming multivariate normality (<code>'normal'</code>; the default), or based on an approach generating non-normal data (<code>'IG'</code>, <code>'mnonr'</code>, <code>'RC'</code>, or <code>'VM'</code>).
</p>
</li>
<li> <p><code>missingVars</code>: vector specifying the variables containing missing data (defaults to NULL).
</p>
</li>
<li> <p><code>missingVarProp</code>: can be used instead of <code>missingVars</code>: The proportion of variables containing missing data (defaults to zero).
</p>
</li>
<li> <p><code>missingProp</code>: The proportion of missingness for variables containing missing data (defaults to zero), either a single value or a vector giving the probabilities for each variable.
</p>
</li>
<li> <p><code>missingMechanism</code>: The missing data mechanism, one of <code>MCAR</code> (the default), <code>MAR</code>, or <code>NMAR</code>.
The approaches generating non-normal data require additional arguments detailed below.
</p>
</li>
<li> <p><code>nCores</code>: The number of cores to use for parallel processing. Defaults to 1 (= no parallel processing). This requires the <code>doSNOW</code> package.
</p>
</li></ul>

<p><code>type = 'IG'</code> implements the independent generator approach (IG, Foldnes &amp; Olsson, 2016) approach
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors. This requires the <code>covsim</code> package.
</p>
<p><code>type = 'mnonr'</code> implements the approach suggested by Qu, Liu, &amp; Zhang (2020) and requires provision of  Mardia's multivariate skewness (<code>skewness</code>)  and kurtosis  (<code>kurtosis</code>), where
skewness must be non-negative and kurtosis must be at least 1.641 skewness + p (p + 0.774), where p is the number of variables. This requires the <code>mnonr</code> package.
</p>
<p><code>type = 'RK'</code> implements the approach suggested by Ruscio &amp; Kaczetow (2008) and requires provision of the population distributions
of each variable (<code>distributions</code>). <code>distributions</code> must be a list (if all variables shall be based on the same population distribution) or a list of lists.
Each component must specify the population distribution (e.g. <code>rchisq</code>) and additional arguments (<code>list(df = 2)</code>).
</p>
<p><code>type = 'VM'</code> implements the third-order polynomial method (Vale &amp; Maurelli, 1983)
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors.  This requires the <code>semTools</code> package.
</p>


<h3>Value</h3>

<p>a list. Use the <code>summary</code> method to obtain formatted results. Beyond the results of the power analysis and a number of effect size measures, the list contains the following components:
</p>
<table role = "presentation">
<tr><td><code>Sigma</code></td>
<td>
<p>the population covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the population mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td></tr>
<tr><td><code>SigmaHat</code></td>
<td>
<p>the H0 model implied covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code>muHat</code></td>
<td>
<p>the H0 model implied mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td></tr>
<tr><td><code>modelH0</code></td>
<td>
<p><code>lavaan</code> H0 model string.</p>
</td></tr>
<tr><td><code>modelH1</code></td>
<td>
<p><code>lavaan</code> H1 model string or <code>NULL</code> when the comparison refers to the saturated model.</p>
</td></tr>
<tr><td><code>simRes</code></td>
<td>
<p>detailed simulation results when a simulated power analysis (<code>simulatedPower = TRUE</code>) was performed.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+semPower.genSigma">semPower.genSigma()</a></code> <code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code> <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code> <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# get required N to detect a correlation of &gt;= .2 between two factors
# with a power of 95% on alpha = 5%, where the factors are  
# measured by 5 and 6 indicators, respectively, and all loadings are equal to .5
powercfa &lt;- semPower.powerCFA(type = 'a-priori',
                              Phi = .2, 
                              nIndicator = c(5, 6), loadM = .5,
                              alpha = .05, beta = .05)
# show summary
summary(powercfa)
# optionally use lavaan to verify the model was set-up as intended
lavaan::sem(powercfa$modelH1, sample.cov = powercfa$Sigma, 
sample.nobs = powercfa$requiredN, sample.cov.rescale = FALSE)
lavaan::sem(powercfa$modelH0, sample.cov = powercfa$Sigma, 
sample.nobs = powercfa$requiredN, sample.cov.rescale = FALSE)

# same as above, but determine power with N = 500 on alpha = .05
powercfa &lt;- semPower.powerCFA(type = 'post-hoc',
                              Phi = .2, 
                              nIndicator = c(5, 6), loadM = .5,
                              alpha = .05, N = 500)

# same as above, but determine the critical chi-square with N = 500 so that alpha = beta
powercfa &lt;- semPower.powerCFA(type = 'compromise',
                              Phi = .2, 
                              nIndicator = c(5, 6), loadM = .5,
                              abratio = 1, N = 500)
                              
# same as above, but compare to the saturated model 
# (rather than to the less restricted model)
powercfa &lt;- semPower.powerCFA(type = 'a-priori',
                              comparison = 'saturated',
                              Phi = .2, 
                              nIndicator = c(5, 6), loadM = .5,
                              alpha = .05, beta = .05)
                              
# same as above, but provide a reduced loading matrix defining
# three indicators with loadings of .7, .6, and .5 on the first factor and
# four indicators with loadings of .5, .6, .4, .8 on the second factor 
powercfa &lt;- semPower.powerCFA(type = 'a-priori',
                              Phi = .2, 
                              loadings = list(c(.7, .6, .5), 
                                              c(.5, .6, .4, .8)),
                              alpha = .05, beta = .05)

# detect that the loading of indicator 4 on the first factor differs from zero
Lambda &lt;- matrix(c(
  c(.8, 0),
  c(.4, 0),
  c(.6, 0),
  c(.1, .5),
  c(0, .6),
  c(0, .7)
), ncol = 2, byrow = TRUE)
powercfa &lt;- semPower.powerCFA(type = 'a-priori',
                              Phi = .2,
                              nullEffect = 'loading = 0', 
                              nullWhich = c(4, 1), 
                              Lambda = Lambda,
                              alpha = .05, beta = .05)


# get required N to detect a correlation of &gt;= .3 between factors 1 and 3  
# in a three factor model. Factors are measured by 3 indicators each, and all loadings 
# on the first, second, and third factor are .5, .6, and .7, respectively.
Phi &lt;- matrix(c(
  c(1.00, 0.20, 0.30),
  c(0.20, 1.00, 0.10),
  c(0.30, 0.10, 1.00)
), ncol = 3,byrow = TRUE)

powercfa &lt;- semPower.powerCFA(type = 'a-priori',
                              Phi = Phi,
                              nullWhich = c(1, 3), 
                              nIndicator = c(3, 3, 3), loadM = c(.5, .6, .7),
                              alpha = .05, beta = .05)

# same as above, but ask for N to detect that 
# the correlation between factors 1 and 2 (of r = .2) differs from
# the correlation between factors 2 and 3 (of r = .3).
powercfa &lt;- semPower.powerCFA(type = 'a-priori',
                              Phi = Phi,
                              nullEffect = 'corX = corZ',
                              nullWhich = list(c(1, 2), c(1, 3)), 
                              nIndicator = c(3, 3, 3), loadM = c(.5, .6, .7),
                              alpha = .05, beta = .05)
                              
# same as above, but ask for N to detect that all three correlations are unequal
powercfa &lt;- semPower.powerCFA(type = 'a-priori',
                              Phi = Phi,
                              nullEffect = 'corX = corZ',
                              nullWhich = list(c(1, 2), c(1, 3), c(2, 3)), 
                              nIndicator = c(3, 3, 3), loadM = c(.5, .6, .7),
                              alpha = .05, beta = .05)
                              
# get required N to detect that the correlation between two factors
# in group 1 (of r = .2) differs from the one in group 2 (of r = .4). 
# The measurement model is identical for both groups:
# The first factor is measured by 3 indicators loading by .7 each, 
# the second factor is measured by 6 indicators loading by .5 each.
# Both groups are sized equally (N = list(1, 1)).
powercfa &lt;- semPower.powerCFA(type = 'a-priori', 
                              nullEffect = 'corA = corB',
                              Phi = list(.2, .4), 
                              loadM = c(.7, .5), 
                              nIndicator = c(3, 6), 
                              alpha = .05, beta = .05, N = list(1, 1))

# request a simulated post-hoc power analysis with 500 replications.
set.seed(300121)
powercfa &lt;- semPower.powerCFA(type = 'post-hoc',
                              Phi = .2, 
                              nIndicator = c(5, 6), loadM = .5,
                              alpha = .05, N = 500, 
                              simulatedPower = TRUE, 
                              simOptions = list(nReplications = 500))


## End(Not run)
</code></pre>

<hr>
<h2 id='semPower.powerCLPM'>semPower.powerCLPM</h2><span id='topic+semPower.powerCLPM'></span>

<h3>Description</h3>

<p>Convenience function for performing power analysis on effects in a cross-lagged panel model (CLPM).
This requires the lavaan package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semPower.powerCLPM(
  type,
  comparison = "restricted",
  nWaves = NULL,
  autoregEffects = NULL,
  crossedEffects = NULL,
  rXY = NULL,
  waveEqual = NULL,
  nullEffect = NULL,
  nullWhich = NULL,
  nullWhichGroups = NULL,
  standardized = TRUE,
  standardizedResidualCovariances = TRUE,
  metricInvariance = TRUE,
  autocorResiduals = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semPower.powerCLPM_+3A_type">type</code></td>
<td>
<p>type of power analysis, one of <code>'a-priori'</code>, <code>'post-hoc'</code>, <code>'compromise'</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerCLPM_+3A_comparison">comparison</code></td>
<td>
<p>comparison model, one of <code>'saturated'</code> or <code>'restricted'</code> (the default). This determines the df for power analyses. <code>'saturated'</code> provides power to reject the model when compared to the saturated model, so the df equal the one of the hypothesized model. <code>'restricted'</code> provides power to reject the hypothesized model when compared to an otherwise identical model that just omits the restrictions defined in <code>nullEffect</code>, so the df equal the number of restrictions.</p>
</td></tr>
<tr><td><code id="semPower.powerCLPM_+3A_nwaves">nWaves</code></td>
<td>
<p>number of waves, must be &gt;= 2.</p>
</td></tr>
<tr><td><code id="semPower.powerCLPM_+3A_autoregeffects">autoregEffects</code></td>
<td>
<p>vector of the autoregressive effects of X and Y (constant across waves), or a list of vectors of autoregressive effects for X and Y from wave to wave, e.g. <code>list(c(.7, .6), c(.5, .5))</code> for a autoregressive effect of .7 for <code>X1 -&gt; X2</code> and .6 for <code>X2 -&gt; X3</code> and autoregressive effects of .5 for <code>Y1 -&gt; Y2</code> and <code>Y2 -&gt; Y3</code>. Must be a list of lists for multiple groups models. If the list structure is omitted, no group differences are assumed.</p>
</td></tr>
<tr><td><code id="semPower.powerCLPM_+3A_crossedeffects">crossedEffects</code></td>
<td>
<p>vector of crossed effects of X on Y <code>(X -&gt; Y)</code> and vice versa (both constant across waves), or a list of vectors of crossed effects giving the crossed effect of X on Y (and vice versa) for each wave, e.g. <code>list(c(.2, .3), c(.1, .1))</code> for <code style="white-space: pre;">&#8288;X1 - &gt; Y2&#8288;</code> = .2, <code>X2 -&gt; Y3</code> = .3, <code>Y1 -&gt; Y2</code> = .1, and <code>Y2 -&gt; Y3</code> = .1. Must be a list of lists for multiple groups models. If the list structure is omitted, no group differences are assumed.</p>
</td></tr>
<tr><td><code id="semPower.powerCLPM_+3A_rxy">rXY</code></td>
<td>
<p>vector of (residual-)correlations between X and Y for each wave. If <code>NULL</code>, all (residual-)correlations are zero. Can be a list for multiple groups models, otherwise no group differences are assumed.</p>
</td></tr>
<tr><td><code id="semPower.powerCLPM_+3A_waveequal">waveEqual</code></td>
<td>
<p>parameters that are assumed to be equal across waves in both the H0 and the H1 model. Valid are <code>'autoregX'</code> and <code>'autoregY'</code> for autoregressive effects, <code>'crossedX'</code> and <code>'crossedY'</code> for crossed effects, <code>'corXY'</code> for residual correlations, or <code>NULL</code> for none (so that all parameters are freely estimated, subject to the constraints defined in <code>nullEffect</code>).</p>
</td></tr>
<tr><td><code id="semPower.powerCLPM_+3A_nulleffect">nullEffect</code></td>
<td>
<p>defines the hypothesis of interest. Valid are the same arguments as in <code>waveEqual</code> and additionally <code>'autoregX = 0'</code>, <code>'autoregY = 0'</code>, <code>'crossedX = 0'</code>, <code>'crossedY = 0'</code> to constrain the X or Y autoregressive effects or the crossed effects to zero, <code>'autoregX = autoregY'</code> and <code>'crossedX = crossedY'</code> to constrain them to be equal for X and Y, and <code>'autoregXA = autoregXB'</code>, <code>'autoregYA = autoregYB'</code>, <code>'crossedXA = crossedXB'</code>, <code>'crossedYA = crossedYB'</code> to constrain them to be equal across groups.</p>
</td></tr>
<tr><td><code id="semPower.powerCLPM_+3A_nullwhich">nullWhich</code></td>
<td>
<p>used in conjunction with <code>nullEffect</code> to identify which parameter to constrain when there are &gt; 2 waves and parameters are not constant across waves. For example, <code>nullEffect = 'autoregX = 0'</code> with <code>nullWhich = 2</code> would constrain the second autoregressive effect for X to zero.</p>
</td></tr>
<tr><td><code id="semPower.powerCLPM_+3A_nullwhichgroups">nullWhichGroups</code></td>
<td>
<p>for hypothesis involving cross-groups comparisons, vector indicating the groups for which equality constrains should be applied, e.g. <code>c(1, 3)</code> to constrain the relevant parameters of the first and the third group. If <code>NULL</code>, all groups are constrained to equality.</p>
</td></tr>
<tr><td><code id="semPower.powerCLPM_+3A_standardized">standardized</code></td>
<td>
<p>whether all parameters should be treated as standardized (<code>TRUE</code>, the default), implying that unstandardized and standardized regression relations have the same value. If <code>FALSE</code>, all regression relations are unstandardized.</p>
</td></tr>
<tr><td><code id="semPower.powerCLPM_+3A_standardizedresidualcovariances">standardizedResidualCovariances</code></td>
<td>
<p>whether the residual covariances provided in <code>rXY</code> should be interpreted as correlations. When <code>TRUE</code> (the default) the unstandardized residual covariances differ from the those provided in <code>rXY</code>. When <code>FALSE</code>, the values provided in <code>rXY</code> are the unstandardized residual covariances, and the standardized residual correlations differ.</p>
</td></tr>
<tr><td><code id="semPower.powerCLPM_+3A_metricinvariance">metricInvariance</code></td>
<td>
<p>whether metric invariance over waves is assumed (<code>TRUE</code>, the default) or not (<code>FALSE</code>). This affects the df when the comparison model is the saturated model and generally affects power (also for comparisons to the restricted model).</p>
</td></tr>
<tr><td><code id="semPower.powerCLPM_+3A_autocorresiduals">autocorResiduals</code></td>
<td>
<p>whether the residuals of the indicators of latent variables are autocorrelated over waves (<code>TRUE</code>, the default) or not (<code>FALSE</code>). This affects the df when the comparison model is the saturated model and generally affects power (also for comparisons to the restricted model).</p>
</td></tr>
<tr><td><code id="semPower.powerCLPM_+3A_...">...</code></td>
<td>
<p>mandatory further parameters related to the specific type of power analysis requested, see <code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code>, <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code>, and <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>, and parameters specifying the factor model. The order of factors is (X1, Y1, X2, Y2, ..., X_nWaves, Y_nWaves). See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a power analysis to reject various hypotheses arising
in crossed-lagged panel models (CLPM). In a standard CLPM implemented here,
two variables X and Y are repeatedly assessed at two or more different time points (<code>nWaves</code>), yielding
autoregressive effects (stabilities; X1 -&gt; X2 and Y1 -&gt; Y2),
synchronous effects (X1 &lt;-&gt; Y1, X2 &lt;-&gt; Y2), and cross-lagged effects (X1 -&gt; Y2 and Y1 -&gt; X2).
CLPM including more than two waves are typically implemented assuming that the parameters are constant across waves (<code>waveEqual</code>), and usually omit lag-2 effects (e.g., X1 -&gt; Y3).
CLPM based on latent factors usually assume at least metric invariance of the factors over waves (<code>metricInvariance</code>).
</p>
<p>Relevant hypotheses in arising in a CLPM are:
</p>

<ul>
<li> <p><code>autoregX = 0</code> and <code>autoregY = 0</code>: Tests the hypothesis that the autoregressive effect of X and Y, respectively, is zero.
</p>
</li>
<li> <p><code>crossedX = 0</code> and <code>crossedY = 0</code>: Tests the hypothesis that the crossed effect of X on Y (<code>crossedX</code>) and of Y on X (<code>crossedY</code>), respectively, is zero.
</p>
</li>
<li> <p><code>autoregX = autoregY</code>: Tests the hypothesis that the autoregressive effect of X and Y are equal.
</p>
</li>
<li> <p><code>crossedX = crossedY</code>: Tests the hypothesis that the crossed effect of X on Y (<code>crossedX</code>) and of Y on X (<code>crossedY</code>) are equal.
</p>
</li>
<li> <p><code>autoregX</code> and <code>autoregY</code>: Tests the hypothesis that the autoregressive effect of X and Y, respectively, is equal across waves.
</p>
</li>
<li> <p><code>crossedX</code> and <code>crossedY</code>: Tests the hypothesis that the crossed effect of X on Y (<code>crossedX</code>) and of Y on X (<code>crossedY</code>), respectively, is equal across waves.
</p>
</li>
<li> <p><code>corXY</code>: Tests the hypothesis that the (residual-)correlations between X and Y are equal across waves.
</p>
</li>
<li> <p><code>autoregXA = autoregXB</code> and <code>autoregYA = autoregYB</code>: Tests the hypothesis that the autoregressive effect of either X or Y are equal across groups.
</p>
</li>
<li> <p><code>crossedXA = crossedXB</code> and <code>crossedYA = crossedYB</code>: Tests the hypothesis that the crossed effect of X on Y (<code>crossedX</code>) or of Y on X (<code>crossedY</code>), respectively, is equal across groups.
</p>
</li></ul>

<p>For hypotheses regarding the random-intercept CLPM, see <code><a href="#topic+semPower.powerRICLPM">semPower.powerRICLPM()</a></code>. For hypothesis in autoregressive models, see <code><a href="#topic+semPower.powerAutoreg">semPower.powerAutoreg()</a></code>.
</p>
<p>Beyond the arguments explicitly contained in the function call, additional arguments
are required specifying the factor model and the requested type of power analysis.
</p>
<p>Additional arguments related to the <strong>definition of the factor model</strong>:
</p>

<ul>
<li> <p><code>Lambda</code>: The factor loading matrix (with the number of columns equaling the number of factors).
</p>
</li>
<li> <p><code>loadings</code>: Can be used instead of <code>Lambda</code>: Defines the primary loadings for each factor in a list structure, e. g. <code>loadings = list(c(.5, .4, .6), c(.8, .6, .6, .4))</code> defines a two factor model with three indicators loading on the first factor by .5, , 4., and .6, and four indicators loading on the second factor by .8, .6, .6, and .4.
</p>
</li>
<li> <p><code>nIndicator</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>loadM</code>. Defines the number of indicators by factor, e. g., <code>nIndicator = c(3, 4)</code> defines a two factor model with three and four indicators for the first and second factor, respectively. <code>nIndicator</code> can also be a single number to define the same number of indicators for each factor.
</p>
</li>
<li> <p><code>loadM</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>nIndicator</code>. Defines the loading either for all indicators (if a single number is provided) or separately for each factor (if a vector is provided), e. g. <code>loadM = c(.5, .6)</code> defines the loadings of the first factor to equal .5 and those of the second factor do equal .6.
</p>
</li></ul>

<p>So either <code>Lambda</code>, or <code>loadings</code>, or <code>nIndicator</code> and <code>loadM</code> need to be defined.
If the model contains observed variables only, use <code>Lambda = diag(x)</code> where <code>x</code> is the number of variables.
</p>
<p>Note that the order of the factors is (X1, Y1, X2, Y2, ..., X_nWaves, Y_nWaves), i. e., the first factor is treated as the first measurement of X, the second as the first measurement of Y, the third as the second measurement of X, etc..
</p>
<p>Additional arguments related to the requested type of <strong>power analysis</strong>:
</p>

<ul>
<li> <p><code>alpha</code>: The alpha error probability. Required for <code>type = 'a-priori'</code> and <code>type = 'post-hoc'</code>.
</p>
</li>
<li><p> Either <code>beta</code> or <code>power</code>: The beta error probability and the statistical power (1 - beta), respectively. Only for <code>type = 'a-priori'</code>.
</p>
</li>
<li> <p><code>N</code>: The sample size. Always required for <code>type = 'post-hoc'</code> and <code>type = 'compromise'</code>. For <code>type = 'a-priori'</code> and multiple group analysis, <code>N</code> is a list of group weights.
</p>
</li>
<li> <p><code>abratio</code>: The ratio of alpha to beta. Only for <code>type = 'compromise'</code>.
</p>
</li></ul>

<p>If a <strong>simulated power analysis</strong> (<code>simulatedPower = TRUE</code>) is requested, optional arguments can be provided as a list to <code>simOptions</code>:
</p>

<ul>
<li> <p><code>nReplications</code>: The targeted number of simulation runs. Defaults to 250, but larger numbers greatly improve accuracy at the expense of increased computation time.
</p>
</li>
<li> <p><code>minConvergenceRate</code>:  The minimum convergence rate required, defaults to .5. The maximum actual simulation runs are increased by a factor of 1/minConvergenceRate.
</p>
</li>
<li> <p><code>type</code>: specifies whether the data should be generated from a population assuming multivariate normality (<code>'normal'</code>; the default), or based on an approach generating non-normal data (<code>'IG'</code>, <code>'mnonr'</code>, <code>'RC'</code>, or <code>'VM'</code>).
The approaches generating non-normal data require additional arguments detailed below.
</p>
</li>
<li> <p><code>missingVars</code>: vector specifying the variables containing missing data (defaults to NULL).
</p>
</li>
<li> <p><code>missingVarProp</code>: can be used instead of <code>missingVars</code>: The proportion of variables containing missing data (defaults to zero).
</p>
</li>
<li> <p><code>missingProp</code>: The proportion of missingness for variables containing missing data (defaults to zero), either a single value or a vector giving the probabilities for each variable.
</p>
</li>
<li> <p><code>missingMechanism</code>: The missing data mechanism, one of <code>MCAR</code> (the default), <code>MAR</code>, or <code>NMAR</code>.
</p>
</li>
<li> <p><code>nCores</code>: The number of cores to use for parallel processing. Defaults to 1 (= no parallel processing). This requires the <code>doSNOW</code> package.
</p>
</li></ul>

<p><code>type = 'IG'</code> implements the independent generator approach (IG, Foldnes &amp; Olsson, 2016) approach
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors. This requires the <code>covsim</code> package.
</p>
<p><code>type = 'mnonr'</code> implements the approach suggested by Qu, Liu, &amp; Zhang (2020) and requires provision of  Mardia's multivariate skewness (<code>skewness</code>)  and kurtosis  (<code>kurtosis</code>), where
skewness must be non-negative and kurtosis must be at least 1.641 skewness + p (p + 0.774), where p is the number of variables. This requires the <code>mnonr</code> package.
</p>
<p><code>type = 'RK'</code> implements the approach suggested by Ruscio &amp; Kaczetow (2008) and requires provision of the population distributions
of each variable (<code>distributions</code>). <code>distributions</code> must be a list (if all variables shall be based on the same population distribution) or a list of lists.
Each component must specify the population distribution (e.g. <code>rchisq</code>) and additional arguments (<code>list(df = 2)</code>).
</p>
<p><code>type = 'VM'</code> implements the third-order polynomial method (Vale &amp; Maurelli, 1983)
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors.  This requires the <code>semTools</code> package.
</p>


<h3>Value</h3>

<p>a list. Use the <code>summary</code> method to obtain formatted results. Beyond the results of the power analysis and a number of effect size measures, the list contains the following components:
</p>
<table role = "presentation">
<tr><td><code>Sigma</code></td>
<td>
<p>the population covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the population mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td></tr>
<tr><td><code>SigmaHat</code></td>
<td>
<p>the H0 model implied covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code>muHat</code></td>
<td>
<p>the H0 model implied mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td></tr>
<tr><td><code>modelH0</code></td>
<td>
<p><code>lavaan</code> H0 model string.</p>
</td></tr>
<tr><td><code>modelH1</code></td>
<td>
<p><code>lavaan</code> H1 model string or <code>NULL</code> when the comparison refers to the saturated model.</p>
</td></tr>
<tr><td><code>simRes</code></td>
<td>
<p>detailed simulation results when a simulated power analysis (<code>simulatedPower = TRUE</code>) was performed.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+semPower.genSigma">semPower.genSigma()</a></code> <code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code> <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code> <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Determine required N in a 2-wave CLPM
# to detect a crossed-effect of X (X1 -&gt; Y2) of &gt;= .2 
# with a power of 95% on alpha = 5%, where
# X1 and X2 are measured by 5 indicators loading by .5 each, and
# Y1 and Y2 are measured by 3 indicators loading by .6 each, and
# there is no synchronous correlation between X and Y (rXY = NULL), 
# the stability of X is .8,
# the stability of Y is .7, and
# the crossed-effect of Y (Y1 -&gt; X2) is .1.
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = NULL,
                                nullEffect = 'crossedX = 0',
                                nIndicator = c(5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6),
                                alpha = .05, beta = .05)

# show summary
summary(powerCLPM)
# optionally use lavaan to verify the model was set-up as intended
lavaan::sem(powerCLPM$modelH1, sample.cov = powerCLPM$Sigma,
            sample.nobs = powerCLPM$requiredN, 
            sample.cov.rescale = FALSE)
lavaan::sem(powerCLPM$modelH0, sample.cov = powerCLPM$Sigma,
            sample.nobs = powerCLPM$requiredN, 
            sample.cov.rescale = FALSE)

# same as above, but determine power with N = 500 on alpha = .05
powerCLPM &lt;- semPower.powerCLPM(type = 'post-hoc',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = NULL,
                                nullEffect = 'crossedX = 0',
                                nIndicator = c(5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6),
                                alpha = .05, N = 500)

# same as above, but determine the critical chi-square with N = 500 so that alpha = beta
powerCLPM &lt;- semPower.powerCLPM(type = 'compromise',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = NULL,
                                nullEffect = 'crossedX = 0',
                                nIndicator = c(5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6),
                                abratio = 1, N = 500)

# same as above, but compare to the saturated model
# (rather than to the less restricted model)
powerCLPM &lt;- semPower.powerCLPM(type = 'compromise',
                                comparison = 'saturated',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = NULL,
                                nullEffect = 'crossedX = 0',
                                nIndicator = c(5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6),
                                abratio = 1, N = 500)

# same as above, but assume only observed variables
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = NULL,
                                nullEffect = 'crossedX = 0',
                                Lambda = diag(4),
                                alpha = .05, beta = .05)

# same as above, but provide reduced loadings matrix to define that
# X1 and X2 are measured by 5 indicators each loading by .4, .5, .6, .5, .4 
# Y1 and Y2 are measured by 3 indicators each loading by .8, .6, .7
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = NULL,
                                nullEffect = 'crossedX = 0',
                                loadings = list(
                                  c(.4, .5, .6, .5, .4),    # X1
                                  c(.8, .6, .7),            # Y1
                                  c(.4, .5, .6, .5, .4),    # X2
                                  c(.8, .6, .7)             # Y2
                                ),
                                alpha = .05, beta = .05)

# same as above, but do not assume metric invariance across waves
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = NULL,
                                nullEffect = 'crossedX = 0',
                                nIndicator = c(5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6),
                                metricInvariance = FALSE,
                                alpha = .05, beta = .05)

# same as above, but determine N to detect that the crossed-effect of Y (Y1 -&gt; X2) is &gt;= .1.
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = NULL,
                                nullEffect = 'crossedY = 0',
                                nIndicator = c(5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6),
                                alpha = .05, beta = .05)

# same as above, but determine N to detect that the stability of X (X1 -&gt; X2) is &gt;= .8.
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = NULL,
                                nullEffect = 'autoregX = 0',
                                nIndicator = c(5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6),
                                alpha = .05, beta = .05)

# same as above, but determine N to detect that the stability of Y (Y1 -&gt; Y2) is &gt;= .7.
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = NULL,
                                nullEffect = 'autoregY = 0',
                                nIndicator = c(5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6),
                                alpha = .05, beta = .05)

# same as above, but determine N to detect that 
# the crossed effect of X (X1 -&gt; Y2) of .2 differs from 
# the crossed effect of Y (Y1 -&gt; X2) of .1  
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = NULL,
                                nullEffect = 'crossedX = crossedY',
                                nIndicator = c(5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6),
                                alpha = .05, beta = .05)

# same as above, but determine N to detect that 
# the autoregressive effect of X (X1 -&gt; X2) of .8 differs from 
# the autoregressive effect of Y (Y1 -&gt; Y2) of .7  
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = NULL,
                                nullEffect = 'autoregX = autoregY',
                                nIndicator = c(5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6),
                                alpha = .05, beta = .05)

# same as above, but assume that the synchronous correlation between X and Y 
# is .3 at the first wave, and the respective residual correlation is .2 at the second wave, 
# and determine N to detect that synchronous residual correlation (at wave 2) is =&gt; .2.
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = c(.3, .2),
                                nullEffect = 'corXY = 0',
                                nIndicator = c(5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6),
                                alpha = .05, beta = .05)

# Determine required N in a 3-wave CLPM
# to detect a crossed-effect of X (X1 -&gt; Y2 and X2 -&gt; Y3) of &gt;= .2 
# with a power of 95% on alpha = 5%, where
# the crossed, autoregressive, and synchronous effects of X and Y are equal over waves,
# X1, X2, and X3 are measured by 5 indicators loading by .5 each, and
# Y1, Y2, and Y3 are measured by 3 indicators loading by .6 each, and
# the synchronous correlation between X and Y are .2 across all three waves, and
# the stability of X is .8 across all three waves,
# the stability of Y is .7 across all three waves, and
# the crossed-effect of Y (Y1 -&gt; X2, and Y2 -&gt; Y3) is .1.
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 3,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = c(.2, .2, .2),
                                waveEqual = c('autoregX', 'autoregY', 
                                              'crossedX', 'crossedY'),
                                nullEffect = 'crossedX = 0',
                                nIndicator = c(5, 3, 5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6, .5, .6),
                                alpha = .05, beta = .05)

# Determine required N in a 3-wave CLPM to detect that 
# the crossed-effect of X in wave 1 (X1 -&gt; Y2) of .20 is equal to the 
# the crossed-effect of X in wave 2 (X2 -&gt; Y3) of .10 
# with a power of 95% on alpha = 5%, where
# the autoregressive effects of X and Y are equal over waves,
# X1, X2, and X3 are measured by 5 indicators loading by .5 each, and
# Y1, Y2, and Y3 are measured by 3 indicators loading by .6 each, and
# the synchronous correlation between X and Y are .2, .3, and .4 at the first, 
# second, and third wave, and
# the stability of X is .8 across all three waves,
# the stability of Y is .7 across all three waves, and
# the crossed-effects of Y (Y1 -&gt; X2, and Y2 -&gt; X3) are both .1 
# (but freely estimated for each wave).
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 3,
                                autoregEffects = c(.8, .7), 
                                crossedEffects = list(
                                  c(.20, .10),   # X1 -&gt; Y2, X2 -&gt; Y3
                                  c(.05, .10)),  # Y1 -&gt; X2, Y2 -&gt; X3
                                rXY = c(.2, .3, .4),
                                nullEffect = 'crossedX',
                                waveEqual = c('autoregX', 'autoregY'),
                                nIndicator = c(5, 3, 5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6, .5, .6),
                                alpha = .05, beta = .05)

# same as above, but determine N to detect that 
# the crossed-effect of X at wave 2 is &gt;= .10.
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 3,
                                autoregEffects = c(.8, .7), 
                                crossedEffects = list(
                                  c(.20, .10),   # X1 -&gt; Y2, X2 -&gt; Y3
                                  c(.05, .10)),  # Y1 -&gt; X2, Y2 -&gt; X3
                                rXY = c(.2, .3, .4),
                                nullEffect = 'crossedX',
                                nullWhich = 2,
                                waveEqual = c('autoregX', 'autoregY'),
                                nIndicator = c(5, 3, 5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6, .5, .6),
                                alpha = .05, beta = .05)

# same as above, but determine N to detect that 
# the residual correlation between X and Y at wave 2 (of .3) differs from 
# the residual correlation between X and Y at wave 3 (of .4)
# and define unstandardized parameters
powerCLPM &lt;- semPower.powerCLPM(type = 'a-priori',
                                nWaves = 3,
                                autoregEffects = c(.8, .7), 
                                crossedEffects = list(
                                  c(.20, .10),   # X1 -&gt; Y2, X2 -&gt; Y3
                                  c(.05, .10)),  # Y1 -&gt; X2, Y2 -&gt; X3
                                rXY = c(.2, .3, .4),
                                nullEffect = 'corXY',
                                waveEqual = c('autoregX', 'autoregY'),
                                standardized = FALSE,
                                nIndicator = c(5, 3, 5, 3, 5, 3),
                                loadM = c(.5, .6, .5, .6, .5, .6),
                                alpha = .05, beta = .05)


# multiple group example
# determine power in a 3-wave CLPM to detect that 
# the autoregressive effect of X in group 1 (of .8) differs from the 
# autoregressive effect of X in group 2 (of .6)
# with a 500 observations in both groups on alpha = 5%, where
# the autoregressive effects of X and Y are equal over waves (but not across groups),
# the cross-lagged effects of X and Y are equal over waves (and also across groups),
# X1, X2, and X3 are measured by 5 indicators loading by .5 each, and
# Y1, Y2, and Y3 are measured by 3 indicators loading by .4 each, and
# there are no synchronous correlation between X and Y.
powerCLPM &lt;- semPower.powerCLPM(type = 'post-hoc', alpha = .05, N = list(500, 500),
                                nWaves = 3,
                                autoregEffects = list(
                                # group 1
                                list(c(.8, .8),    # X1 -&gt; X2, X2 -&gt; X3 
                                     c(.7, .7)),   # Y1 -&gt; Y2, Y2 -&gt; Y3
                                # group 2
                                list(c(.6, .6),    # X1 -&gt; X2, X2 -&gt; X3 
                                     c(.7, .7))    # Y1 -&gt; Y2, Y2 -&gt; Y3
                                ),
                                crossedEffects = c(.2, .1),
                                waveEqual = c('autoregX', 'autoregY', 'crossedX', 'crossedY'),
                                rXY = NULL,
                                nullEffect = 'autoregxa=autoregxb',
                                nIndicator = c(5, 3, 5, 3, 5, 3),
                                loadM = c(.5, .4, .5, .4, .5, .4))
                                

# request a simulated post-hoc power analysis with 500 replications.
set.seed(300121)
powerCLPM &lt;- semPower.powerCLPM(type = 'post-hoc',
                                nWaves = 2,
                                autoregEffects = c(.8, .7),
                                crossedEffects = c(.2, .1),
                                rXY = NULL,
                                nullEffect = 'crossedX = 0',
                                Lambda = diag(4),
                                alpha = .05, N = 500, 
                                simulatedPower = TRUE, 
                                simOptions = list(nReplications = 500))

## End(Not run)
</code></pre>

<hr>
<h2 id='semPower.powerLav'>semPower.powerLav</h2><span id='topic+semPower.powerLav'></span>

<h3>Description</h3>

<p>Perform a power analysis given <code>lavaan</code> model strings defining the H0 and the H1 model based on either
a <code>lavaan</code> model string defining the population model or the population covariance matrix Sigma and the population means mu.
This requires the <code>lavaan</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semPower.powerLav(
  type,
  modelPop = NULL,
  modelH0 = NULL,
  modelH1 = NULL,
  fitH1model = TRUE,
  Sigma = NULL,
  mu = NULL,
  fittingFunction = "ML",
  simulatedPower = FALSE,
  lavOptions = NULL,
  lavOptionsH1 = lavOptions,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semPower.powerLav_+3A_type">type</code></td>
<td>
<p>type of power analysis, one of <code>'a-priori'</code>, <code>'post-hoc'</code>, <code>'compromise'</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerLav_+3A_modelpop">modelPop</code></td>
<td>
<p><code>lavaan</code> model string defining the true model. Can be omitted when <code>Sigma</code> is set.</p>
</td></tr>
<tr><td><code id="semPower.powerLav_+3A_modelh0">modelH0</code></td>
<td>
<p><code>lavaan</code> model string defining the (incorrect) analysis model.</p>
</td></tr>
<tr><td><code id="semPower.powerLav_+3A_modelh1">modelH1</code></td>
<td>
<p><code>lavaan</code> model string defining the comparison model. If omitted, the saturated model is the comparison model.</p>
</td></tr>
<tr><td><code id="semPower.powerLav_+3A_fith1model">fitH1model</code></td>
<td>
<p>whether to fit the H1 model. If <code>FALSE</code>, the H1 model is assumed to show the same fit as the saturated model, and only the delta df are computed.</p>
</td></tr>
<tr><td><code id="semPower.powerLav_+3A_sigma">Sigma</code></td>
<td>
<p>can be used instead of <code>modelPop</code>: population covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code id="semPower.powerLav_+3A_mu">mu</code></td>
<td>
<p>can be used instead of <code>modelPop</code>: vector of population means. Can be omitted for no meanstructure. A list for multiple group models.</p>
</td></tr>
<tr><td><code id="semPower.powerLav_+3A_fittingfunction">fittingFunction</code></td>
<td>
<p>one of <code>'ML'</code> (default), <code>'WLS'</code>, <code>'DWLS'</code>, <code>'ULS'</code>. Defines the fitting function used to obtain SigmaHat in analytical power analyses. This also implies a certain discrepancy function used to obtain Fmin.</p>
</td></tr>
<tr><td><code id="semPower.powerLav_+3A_simulatedpower">simulatedPower</code></td>
<td>
<p>whether to perform a simulated (<code>TRUE</code>, rather than analytical, <code>FALSE</code>) power analysis. See <code><a href="#topic+simulate">simulate()</a></code> for additional options.</p>
</td></tr>
<tr><td><code id="semPower.powerLav_+3A_lavoptions">lavOptions</code></td>
<td>
<p>a list of additional options passed to <code>lavaan</code>, e. g., <code>list(estimator = 'mlm')</code> to request robust ML estimation. Mostly useful in conjunction with <code>simulatedPower</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerLav_+3A_lavoptionsh1">lavOptionsH1</code></td>
<td>
<p>alternative options passed to <code>lavaan</code> that are only used for the H1 model. If <code>NULL</code>, identical to <code>lavOptions</code>. Probably only useful for multigroup models.</p>
</td></tr>
<tr><td><code id="semPower.powerLav_+3A_...">...</code></td>
<td>
<p>mandatory further parameters related to the specific type of power analysis requested, see <code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code>, <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code>, and <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function to perform a power analysis based  on a true population covariance matrix Sigma
and a model implied covariance matrix SigmaHat (and optionally the associated mean vectors),
where SigmaHat (and muHat) is determined by fitting a respective H0 model using <code>lavaan</code>,
and Sigma (and mu) can also be provided through a corresponding <code>lavaan</code> model string.
</p>
<p>All <code>semPower</code> convenience functions internally call this function.
</p>
<p>Beyond the arguments explicitly contained in the function call, additional arguments
are required specifying the requested type of <strong>power analysis</strong>:
</p>

<ul>
<li> <p><code>alpha</code>: The alpha error probability. Required for <code>type = 'a-priori'</code> and <code>type = 'post-hoc'</code>.
</p>
</li>
<li><p> Either <code>beta</code> or <code>power</code>: The beta error probability and the statistical power (1 - beta), respectively. Only for <code>type = 'a-priori'</code>.
</p>
</li>
<li> <p><code>N</code>: The sample size. Always required for <code>type = 'post-hoc'</code> and <code>type = 'compromise'</code>. For <code>type = 'a-priori'</code> and multiple group analysis, <code>N</code> is a list of group weights.
</p>
</li>
<li> <p><code>abratio</code>: The ratio of alpha to beta. Only for <code>type = 'compromise'</code>.
</p>
</li></ul>

<p>If a <strong>simulated power analysis</strong> (<code>simulatedPower = TRUE</code>) is requested, optional arguments can be provided as a list to <code>simOptions</code>:
</p>

<ul>
<li> <p><code>nReplications</code>: The targeted number of simulation runs. Defaults to 250, but larger numbers greatly improve accuracy at the expense of increased computation time.
</p>
</li>
<li> <p><code>minConvergenceRate</code>:  The minimum convergence rate required, defaults to .5. The maximum actual simulation runs are increased by a factor of 1/minConvergenceRate.
</p>
</li>
<li> <p><code>type</code>: specifies whether the data should be generated from a population assuming multivariate normality (<code>'normal'</code>; the default), or based on an approach generating non-normal data (<code>'IG'</code>, <code>'mnonr'</code>, <code>'RC'</code>, or <code>'VM'</code>).
The approaches generating non-normal data require additional arguments detailed below.
</p>
</li>
<li> <p><code>missingVars</code>: vector specifying the variables containing missing data (defaults to NULL).
</p>
</li>
<li> <p><code>missingVarProp</code>: can be used instead of <code>missingVars</code>: The proportion of variables containing missing data (defaults to zero).
</p>
</li>
<li> <p><code>missingProp</code>: The proportion of missingness for variables containing missing data (defaults to zero), either a single value or a vector giving the probabilities for each variable.
</p>
</li>
<li> <p><code>missingMechanism</code>: The missing data mechanism, one of <code>MCAR</code> (the default), <code>MAR</code>, or <code>NMAR</code>.
</p>
</li>
<li> <p><code>nCores</code>: The number of cores to use for parallel processing. Defaults to 1 (= no parallel processing). This requires the <code>doSNOW</code> package.
</p>
</li></ul>

<p><code>type = 'IG'</code> implements the independent generator approach (IG, Foldnes &amp; Olsson, 2016) approach
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors. This requires the <code>covsim</code> package.
</p>
<p><code>type = 'mnonr'</code> implements the approach suggested by Qu, Liu, &amp; Zhang (2020) and requires provision of  Mardia's multivariate skewness (<code>skewness</code>)  and kurtosis  (<code>kurtosis</code>), where
skewness must be non-negative and kurtosis must be at least 1.641 skewness + p (p + 0.774), where p is the number of variables. This requires the <code>mnonr</code> package.
</p>
<p><code>type = 'RK'</code> implements the approach suggested by Ruscio &amp; Kaczetow (2008) and requires provision of the population distributions
of each variable (<code>distributions</code>). <code>distributions</code> must be a list (if all variables shall be based on the same population distribution) or a list of lists.
Each component must specify the population distribution (e.g. <code>rchisq</code>) and additional arguments (<code>list(df = 2)</code>).
</p>
<p><code>type = 'VM'</code> implements the third-order polynomial method (Vale &amp; Maurelli, 1983)
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors.  This requires the <code>semTools</code> package.
</p>


<h3>Value</h3>

<p>a list. Use the <code>summary</code> method to obtain formatted results. Beyond the results of the power analysis and a number of effect size measures, the list contains the following components:
</p>
<table role = "presentation">
<tr><td><code>Sigma</code></td>
<td>
<p>the population covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the population mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td></tr>
<tr><td><code>SigmaHat</code></td>
<td>
<p>the H0 model implied covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code>muHat</code></td>
<td>
<p>the H0 model implied mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td></tr>
<tr><td><code>modelH0</code></td>
<td>
<p><code>lavaan</code> H0 model string.</p>
</td></tr>
<tr><td><code>modelH1</code></td>
<td>
<p><code>lavaan</code> H1 model string or <code>NULL</code> when the comparison refers to the saturated model.</p>
</td></tr>
<tr><td><code>simRes</code></td>
<td>
<p>detailed simulation results when a simulated power analysis (<code>simulatedPower = TRUE</code>) was performed.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code> <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code> <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set up two CFA factors with a true correlation of .2
mPop &lt;- '
  f1 =~ .5*x1 + .6*x2 + .4*x3
  f2 =~ .7*x4 + .8*x5 + .3*x6
  x1 ~~ .75*x1
  x2 ~~ .64*x2
  x3 ~~ .84*x3
  x4 ~~ .51*x4
  x5 ~~ .36*x5
  x6 ~~ .91*x6
  f1 ~~ 1*f1
  f2 ~~ 1*f2
  f1 ~~ .2*f2
'
# define the H0 analysis model (restricting the factor correlation to zero) 
mH0 &lt;- '
  f1 =~ x1 + x2 + x3
  f2 =~ x4 + x5 + x6
  f1 ~~ 0*f2
'
# determine N to reject the H0 that the correlation is zero 
# with a power of 95% on alpha = .05
powerLav &lt;- semPower.powerLav(type = 'a-priori', 
                              modelPop = mPop, modelH0 = mH0,
                              alpha = .05, beta = .05)
summary(powerLav)

# same as above, but also define an H1 comparison model 
mH1 &lt;- '
  f1 =~ x1 + x2 + x3
  f2 =~ x4 + x5 + x6
  f1 ~~ f2
'
powerLav &lt;- semPower.powerLav(type = 'a-priori', 
                              modelPop = mPop, modelH0 = mH0, modelH1 = mH1,
                              alpha = .05, beta = .05)

# same as above, but use covariance matrix input instead of modelPop
gen &lt;- semPower.genSigma(Phi = .2, 
                         loadings = list(c(.5, .6, .4), c(.7, .8, .3)))
Sigma &lt;- gen$Sigma
powerLav &lt;- semPower.powerLav(type = 'a-priori', 
                              Sigma = Sigma, modelH0 = mH0,
                              alpha = .05, beta = .05)

# note all of the above is identical to the output provided by the semPower.powerCFA function
powerCFA &lt;- semPower.powerCFA(type = 'a-priori',
                              comparison = 'saturated',
                              Phi = .2, 
                              loadings = list(c(.5, .6, .4), c(.7, .8, .3)), 
                              alpha = .05, beta = .05)

# same as above, but perform simulated power analysis
# with 250 replications using a robust ML test-statistic
set.seed(300121)
powerLav &lt;- semPower.powerLav(type = 'a-priori', 
                              Sigma = Sigma, modelH0 = mH0,
                              alpha = .05, beta = .05, 
                              simulatedPower = TRUE,
                              simOptions = list(nReplications = 250)
                              lavOptions = list(estimator = 'MLM'))

## End(Not run)
</code></pre>

<hr>
<h2 id='semPower.powerLGCM'>semPower.powerLGCM</h2><span id='topic+semPower.powerLGCM'></span>

<h3>Description</h3>

<p>Convenience function for performing power analysis on effects in a latent growth curve model (LGCM).
This requires the lavaan package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semPower.powerLGCM(
  type,
  comparison = "restricted",
  nWaves = NULL,
  means = NULL,
  variances = NULL,
  covariances = NULL,
  quadratic = FALSE,
  timeCodes = NULL,
  ticExogSlopes = NULL,
  ticEndogSlopes = NULL,
  groupEqual = NULL,
  nullEffect = NULL,
  nullWhichGroups = NULL,
  autocorResiduals = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semPower.powerLGCM_+3A_type">type</code></td>
<td>
<p>type of power analysis, one of <code>'a-priori'</code>, <code>'post-hoc'</code>, <code>'compromise'</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerLGCM_+3A_comparison">comparison</code></td>
<td>
<p>comparison model, one of <code>'saturated'</code> or <code>'restricted'</code> (the default). This determines the df for power analyses. <code>'saturated'</code> provides power to reject the model when compared to the saturated model, so the df equal the one of the hypothesized model. <code>'restricted'</code> provides power to reject the hypothesized model when compared to an otherwise identical model that just omits the restrictions defined in <code>nullEffect</code>, so the df equal the number of restrictions.</p>
</td></tr>
<tr><td><code id="semPower.powerLGCM_+3A_nwaves">nWaves</code></td>
<td>
<p>number of waves, must be &gt;= 3 for linear and &gt; 3 for quadratic trends.</p>
</td></tr>
<tr><td><code id="semPower.powerLGCM_+3A_means">means</code></td>
<td>
<p>vector providing the means of the intercept and the linear slope factor (and the quadratic slope factor, if <code>quadratic = TRUE</code>). A list for multiple group models.</p>
</td></tr>
<tr><td><code id="semPower.powerLGCM_+3A_variances">variances</code></td>
<td>
<p>vector providing the variances of the intercept and the linear slope factor (and the quadratic slope factor, if <code>quadratic = TRUE</code>). Can be omitted, if a matrix is provided to <code>covariances</code>. Takes precedence over the diagonal in <code>covariances</code> when both are defined. A list for multiple group models.</p>
</td></tr>
<tr><td><code id="semPower.powerLGCM_+3A_covariances">covariances</code></td>
<td>
<p>either the variance-covariance matrix between the intercept and the slope (and the quadratic slope factor, if <code>quadratic = TRUE</code>), or a single number giving the covariance between intercept and slope factor, or <code>NULL</code> for orthogonal factors. A list for multiple group models.</p>
</td></tr>
<tr><td><code id="semPower.powerLGCM_+3A_quadratic">quadratic</code></td>
<td>
<p>whether to include a quadratic slope factor in addition to a linear slope factor. Defaults to <code>FALSE</code> for no quadratic slope factor.</p>
</td></tr>
<tr><td><code id="semPower.powerLGCM_+3A_timecodes">timeCodes</code></td>
<td>
<p>vector of length <code>nWaves</code> defining the loadings on the slope factor. If omitted, the time codes default to (0, 1, ..., (nWaves - 1)).</p>
</td></tr>
<tr><td><code id="semPower.powerLGCM_+3A_ticexogslopes">ticExogSlopes</code></td>
<td>
<p>vector defining the slopes for an exogenous time-invariant covariate in the prediction of the intercept and slope factors (and the quadratic slope factor, if <code>quadratic = TRUE</code>). Can be omitted for no covariate.</p>
</td></tr>
<tr><td><code id="semPower.powerLGCM_+3A_ticendogslopes">ticEndogSlopes</code></td>
<td>
<p>vector defining the slopes for the intercept and slope factors (and the quadratic slope factor, if <code>quadratic = TRUE</code>) in the prediction of an endogenous time-invariant covariate. Can be omitted for no covariate.</p>
</td></tr>
<tr><td><code id="semPower.powerLGCM_+3A_groupequal">groupEqual</code></td>
<td>
<p>parameters that are restricted across groups in both the H0 and the H1 model, when <code>nullEffect</code> implies a multiple group model. Valid are <code>'imean'</code>, <code>'smean'</code>, <code>'s2mean'</code> to restrict the means of the intercept, linear slope, and quadratic slope factors, and <code>'ivar'</code>, <code>'svar'</code>, <code>'s2var'</code> for their variances, and <code>'iscov'</code>, <code>'is2cov'</code>, <code>'ss2cov'</code> for the covariances between intercept and slope, intercept and quadratic slope, and linear and quadratic slope.</p>
</td></tr>
<tr><td><code id="semPower.powerLGCM_+3A_nulleffect">nullEffect</code></td>
<td>
<p>defines the hypothesis of interest. See details for valid arguments.</p>
</td></tr>
<tr><td><code id="semPower.powerLGCM_+3A_nullwhichgroups">nullWhichGroups</code></td>
<td>
<p>for hypothesis involving cross-groups comparisons, vector indicating the groups for which equality constrains should be applied, e.g. <code>c(1, 3)</code> to constrain the relevant parameters of the first and the third group. If <code>NULL</code>, all groups are constrained to equality.</p>
</td></tr>
<tr><td><code id="semPower.powerLGCM_+3A_autocorresiduals">autocorResiduals</code></td>
<td>
<p>whether the residuals of the indicators of latent variables are autocorrelated over waves (<code>TRUE</code>, the default) or not (<code>FALSE</code>). This is only applied to second order LGCMs. This affects the df when the comparison model is the saturated model and generally affects power (also for comparisons to the restricted model).</p>
</td></tr>
<tr><td><code id="semPower.powerLGCM_+3A_...">...</code></td>
<td>
<p>mandatory further parameters related to the specific type of power analysis requested, see <code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code>, <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code>, and <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>, and parameters specifying the factor model. The order of factors is (X1, X2, ..., X_nWaves, ticExogSlopes, ticEndogSlopes). See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a power analysis to reject various hypotheses arising
in latent growth curve models (LGCM), where one variable <code>X</code> is repeatedly
assessed at different time points (<code>nWaves</code>), and a latent intercept and a
linear (and optionally a quadratic) latent slope factor is assumed.
</p>
<p>Relevant hypotheses in arising in a LCGM are:
</p>

<ul>
<li> <p><code>iMean = 0</code>, <code>sMean = 0</code>, <code>s2Mean = 0</code>: Tests the hypothesis that the mean of the intercept, linear slope, and quadratic slope factors, respectively, is zero.
</p>
</li>
<li> <p><code>iVar = 0</code>, <code>sVar = 0</code>, <code>s2Var = 0</code>: Tests the hypothesis that the variance of the intercept, linear slope, and quadratic slope factors, respectively, is zero.
</p>
</li>
<li> <p><code>isCov = 0</code>: Tests the hypothesis that covariance between the intercept and linear slope factor is zero.
</p>
</li>
<li> <p><code>is2Cov = 0</code>: Tests the hypothesis that covariance between the intercept and quadratic slope factor is zero.
</p>
</li>
<li> <p><code>ss2Cov = 0</code>: Tests the hypothesis that covariance between the linear and the quadratic slope factor is zero.
</p>
</li>
<li> <p><code>betaIT = 0</code>, <code>betaST = 0</code>, <code>betaS2T = 0</code>: Tests the hypothesis that the slope for an exogenous time-invariant covariate in the prediction of the intercept, the linear slope, and the quadratic slope factor, respectively, is zero (<code style="white-space: pre;">&#8288;TIC -&gt; I, S, S2&#8288;</code>).
</p>
</li>
<li> <p><code>betaTI = 0</code>, <code>betaTS = 0</code>, <code>betaTS2 = 0</code>: Tests the hypothesis that the slope the intercept, the linear slope, and the quadratic slope factor, respectively, in the prediction of an endogenous time-invariant covariate is zero (<code style="white-space: pre;">&#8288;I, S, S2 -&gt; TIC&#8288;</code>).
</p>
</li>
<li> <p><code>iMeanA = iMeanB</code>, <code>sMeanA = sMeanB</code>, <code>s2MeanA = s2MeanB</code>: Tests the hypothesis that the means of the intercept, linear slope, and quadratic slope factors, respectively, are equal across groups.
</p>
</li>
<li> <p><code>iVarA = iVarB</code>, <code>sVarA = sVarB</code>, <code>s2VarA = s2VarB</code>: Tests the hypothesis that the variances of the intercept, linear slope, and quadratic slope factors, respectively, are equal across groups.
</p>
</li>
<li> <p><code>isCovA = isCovA</code>: Tests the hypothesis that covariance between the intercept and linear slope factor is equal across groups.
</p>
</li>
<li> <p><code>is2CovA = is2CovA</code>: Tests the hypothesis that the covariance between the intercept and quadratic slope factor is equal across groups.
</p>
</li>
<li> <p><code>ss2CovA = ss2CovA</code>: Tests the hypothesis that the covariance between the linear and quadratic slope factor is equal across groups.
</p>
</li>
<li> <p><code>betaITA = betaITB</code>, <code>betaSTA = betaSTB</code>, <code>betaS2TA = betaS2TB</code>: Tests the hypothesis that the slopes for the time-invariant covariate in the prediction of the intercept, the linear slope, and the quadratic slope factor, respectively, are equal across groups (<code style="white-space: pre;">&#8288;TIC -&gt; I, S, S2&#8288;</code>).
</p>
</li>
<li> <p><code>betaTIA = betaTIB</code>, <code>betaTSA = betaTSB</code>, <code>betaTS2A = betaTS2B</code>: Tests the hypothesis that the slope the intercept, the linear slope, and the quadratic slope factor, respectively, in the prediction of the time-invariant covariate are equal across groups (<code style="white-space: pre;">&#8288;I, S, S2 -&gt; TIC&#8288;</code>).
</p>
</li></ul>

<p>For hypotheses regarding longitudinal invariance, see <code><a href="#topic+semPower.powerLI">semPower.powerLI()</a></code>. For hypotheses regarding a simple autoregression, see <code><a href="#topic+semPower.powerAutoreg">semPower.powerAutoreg()</a></code>. For hypotheses in an ARMA model, see <code><a href="#topic+semPower.powerARMA">semPower.powerARMA()</a></code>.
</p>
<p>Beyond the arguments explicitly contained in the function call, additional arguments
are required specifying the factor model and the requested type of power analysis.
</p>
<p>Additional arguments related to the <strong>definition of the factor model</strong>:
</p>

<ul>
<li> <p><code>Lambda</code>: The factor loading matrix (with the number of columns equaling the number of factors).
</p>
</li>
<li> <p><code>loadings</code>: Can be used instead of <code>Lambda</code>: Defines the primary loadings for each factor in a list structure, e. g. <code>loadings = list(c(.5, .4, .6), c(.8, .6, .6, .4))</code> defines a two factor model with three indicators loading on the first factor by .5, , 4., and .6, and four indicators loading on the second factor by .8, .6, .6, and .4.
</p>
</li>
<li> <p><code>nIndicator</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>loadM</code>. Defines the number of indicators by factor, e. g., <code>nIndicator = c(3, 4)</code> defines a two factor model with three and four indicators for the first and second factor, respectively. <code>nIndicator</code> can also be a single number to define the same number of indicators for each factor.
</p>
</li>
<li> <p><code>loadM</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>nIndicator</code>. Defines the loading either for all indicators (if a single number is provided) or separately for each factor (if a vector is provided), e. g. <code>loadM = c(.5, .6)</code> defines the loadings of the first factor to equal .5 and those of the second factor do equal .6.
</p>
</li></ul>

<p>So either <code>Lambda</code>, or <code>loadings</code>, or <code>nIndicator</code> and <code>loadM</code> need to be defined. Neither may contain entries referring to the intercept and slope factors.
If the model contains observed variables only, use <code>Lambda = diag(x)</code> where <code>x</code> is the number of variables.
</p>
<p>The order of the factors is (X1, X2, ..., X_nWaves, ticExogenous, ticEndogenous). If ticExogenous is undefined, ticEndogenous takes its place.
</p>
<p>Additional arguments related to the requested type of <strong>power analysis</strong>:
</p>

<ul>
<li> <p><code>alpha</code>: The alpha error probability. Required for <code>type = 'a-priori'</code> and <code>type = 'post-hoc'</code>.
</p>
</li>
<li><p> Either <code>beta</code> or <code>power</code>: The beta error probability and the statistical power (1 - beta), respectively. Only for <code>type = 'a-priori'</code>.
</p>
</li>
<li> <p><code>N</code>: The sample size. Always required for <code>type = 'post-hoc'</code> and <code>type = 'compromise'</code>. For <code>type = 'a-priori'</code> and multiple group analysis, <code>N</code> is a list of group weights.
</p>
</li>
<li> <p><code>abratio</code>: The ratio of alpha to beta. Only for <code>type = 'compromise'</code>.
</p>
</li></ul>

<p>If a <strong>simulated power analysis</strong> (<code>simulatedPower = TRUE</code>) is requested, optional arguments can be provided as a list to <code>simOptions</code>:
</p>

<ul>
<li> <p><code>nReplications</code>: The targeted number of simulation runs. Defaults to 250, but larger numbers greatly improve accuracy at the expense of increased computation time.
</p>
</li>
<li> <p><code>minConvergenceRate</code>:  The minimum convergence rate required, defaults to .5. The maximum actual simulation runs are increased by a factor of 1/minConvergenceRate.
</p>
</li>
<li> <p><code>type</code>: specifies whether the data should be generated from a population assuming multivariate normality (<code>'normal'</code>; the default), or based on an approach generating non-normal data (<code>'IG'</code>, <code>'mnonr'</code>, <code>'RC'</code>, or <code>'VM'</code>).
The approaches generating non-normal data require additional arguments detailed below.
</p>
</li>
<li> <p><code>missingVars</code>: vector specifying the variables containing missing data (defaults to NULL).
</p>
</li>
<li> <p><code>missingVarProp</code>: can be used instead of <code>missingVars</code>: The proportion of variables containing missing data (defaults to zero).
</p>
</li>
<li> <p><code>missingProp</code>: The proportion of missingness for variables containing missing data (defaults to zero), either a single value or a vector giving the probabilities for each variable.
</p>
</li>
<li> <p><code>missingMechanism</code>: The missing data mechanism, one of <code>MCAR</code> (the default), <code>MAR</code>, or <code>NMAR</code>.
</p>
</li>
<li> <p><code>nCores</code>: The number of cores to use for parallel processing. Defaults to 1 (= no parallel processing). This requires the <code>doSNOW</code> package.
</p>
</li></ul>

<p><code>type = 'IG'</code> implements the independent generator approach (IG, Foldnes &amp; Olsson, 2016) approach
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors. This requires the <code>covsim</code> package.
</p>
<p><code>type = 'mnonr'</code> implements the approach suggested by Qu, Liu, &amp; Zhang (2020) and requires provision of  Mardia's multivariate skewness (<code>skewness</code>)  and kurtosis  (<code>kurtosis</code>), where
skewness must be non-negative and kurtosis must be at least 1.641 skewness + p (p + 0.774), where p is the number of variables. This requires the <code>mnonr</code> package.
</p>
<p><code>type = 'RK'</code> implements the approach suggested by Ruscio &amp; Kaczetow (2008) and requires provision of the population distributions
of each variable (<code>distributions</code>). <code>distributions</code> must be a list (if all variables shall be based on the same population distribution) or a list of lists.
Each component must specify the population distribution (e.g. <code>rchisq</code>) and additional arguments (<code>list(df = 2)</code>).
</p>
<p><code>type = 'VM'</code> implements the third-order polynomial method (Vale &amp; Maurelli, 1983)
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors.  This requires the <code>semTools</code> package.
</p>


<h3>Value</h3>

<p>a list. Use the <code>summary</code> method to obtain formatted results. Beyond the results of the power analysis and a number of effect size measures, the list contains the following components:
</p>
<table role = "presentation">
<tr><td><code>Sigma</code></td>
<td>
<p>the population covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the population mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td></tr>
<tr><td><code>SigmaHat</code></td>
<td>
<p>the H0 model implied covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code>muHat</code></td>
<td>
<p>the H0 model implied mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td></tr>
<tr><td><code>modelH0</code></td>
<td>
<p><code>lavaan</code> H0 model string.</p>
</td></tr>
<tr><td><code>modelH1</code></td>
<td>
<p><code>lavaan</code> H1 model string or <code>NULL</code> when the comparison refers to the saturated model.</p>
</td></tr>
<tr><td><code>simRes</code></td>
<td>
<p>detailed simulation results when a simulated power analysis (<code>simulatedPower = TRUE</code>) was performed.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+semPower.genSigma">semPower.genSigma()</a></code> <code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code> <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code> <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Determine required N in a 3-wave LGCM model
# to detect that the mean of the slope factor differs from zero
# with a power of 80% on alpha = 5%, where
# X is measured by 3 indicators loading by .5 each (at each wave), and
# the mean of the intercept factor is .5 and
# the mean of the slope factor is .2 and
# the variance of the intercept factor is 1 and
# the variance of the slope factor is .5 and
# the intercept-slope covariance is .25 and
# autocorrelated residuals are assumed
powerLGCM &lt;- semPower.powerLGCM(
  'a-priori', alpha = .05, power = .80,
  nWaves = 3,
  means = c(.5, .2),     # i, s
  variances = c(1, .5),  # i, s
  covariances = .25,
  nullEffect = 'sMean = 0',
  nIndicator = rep(3, 3), loadM = .5,
  autocorResiduals = TRUE
)

# show summary
summary(powerLGCM)
# optionally use lavaan to verify the model was set-up as intended
lavaan::sem(powerLGCM$modelH1, sample.cov = powerLGCM$Sigma,
            sample.mean = powerLGCM$mu,
            sample.nobs = powerLGCM$requiredN,
            sample.cov.rescale = FALSE)
lavaan::sem(powerLGCM$modelH0, sample.cov = powerLGCM$Sigma,
            sample.mean = powerLGCM$mu,
            sample.nobs = powerLGCM$requiredN,
            sample.cov.rescale = FALSE)


# same as above, but determine power with N = 250 on alpha = .05
powerLGCM &lt;- semPower.powerLGCM(
  'post-hoc', alpha = .05, N = 250,
  nWaves = 3,
  means = c(.5, .2),
  variances = c(1, .5),
  covariances = .25,
  nullEffect = 'sMean = 0',
  nIndicator = rep(3, 3), loadM = .5,
  autocorResiduals = TRUE
)

# same as above, but determine the critical chi-square with N = 250 so that alpha = beta
powerLGCM &lt;- semPower.powerLGCM(
  'compromise', abratio = 1, N = 250,
  nWaves = 3,
  means = c(.5, .2),
  variances = c(1, .5),
  covariances = .25,
  nullEffect = 'sMean = 0',
  nIndicator = rep(3, 3), loadM = .5,
  autocorResiduals = TRUE
)

# same as above, but compare to the saturated model
# (rather than to the less restricted model)
powerLGCM &lt;- semPower.powerLGCM(
  'a-priori', alpha = .05, power = .80, comparison = 'saturated',
  nWaves = 3,
  means = c(.5, .2),
  variances = c(1, .5),
  covariances = .25,
  nullEffect = 'sMean = 0',
  nIndicator = rep(3, 3), loadM = .5,
  autocorResiduals = TRUE
)

# same as above, but assume only observed variables
powerLGCM &lt;- semPower.powerLGCM(
  'a-priori', alpha = .05, power = .80, comparison = 'saturated',
  nWaves = 3,
  means = c(.5, .2),
  variances = c(1, .5),
  covariances = .25,
  nullEffect = 'sMean = 0',
  Lambda = diag(3),
  autocorResiduals = TRUE
)

# same as above, but provide reduced loadings matrix to define that
# X is measured by 3 indicators each loading by .5, .6, .4 (at each wave)
powerLGCM &lt;- semPower.powerLGCM(
  'a-priori', alpha = .05, power = .80, comparison = 'saturated',
  nWaves = 3,
  means = c(.5, .2),
  variances = c(1, .5),
  covariances = .25,
  nullEffect = 'sMean = 0',
  loadings = list(
    c(.5, .6, .4),  # X1
    c(.5, .6, .4),  # X2 
    c(.5, .6, .4)   # X3
  ),
  autocorResiduals = TRUE
)

# same as above, but get required N to detect that
# the variance of the intercept factor differs from zero
powerLGCM &lt;- semPower.powerLGCM(
  'a-priori', alpha = .05, power = .80,
  nWaves = 3,
  means = c(.5, .2),
  variances = c(1, .5),
  covariances = .25,
  nullEffect = 'iVar = 0',
  nIndicator = rep(3, 3), loadM = .5,
  autocorResiduals = TRUE
)

# same as above, but get required N to detect that
# the intercept-slope covariance differs from zero
powerLGCM &lt;- semPower.powerLGCM(
  'a-priori', alpha = .05, power = .80,
  nWaves = 3,
  means = c(.5, .2),
  variances = c(1, .5),
  covariances = .25,
  nullEffect = 'iscov = 0',
  nIndicator = rep(3, 3), loadM = .5,
  autocorResiduals = TRUE
)


# include a quadratic slope factor
# and get required N to detect that
# its variance differs from zero.
# provide the variance-covariance matrix
# between intercept, slope, and quadratic slope factors
powerLGCM &lt;- semPower.powerLGCM(
  'a-priori', alpha = .05, power = .80,
  nWaves = 4,
  quadratic = TRUE,
  means = c(.5, .2, .1),
  covariances = matrix(c(
    # i  s   s2
    c(1, .3, .2),
    c(.3, .5, .01),
    c(.2, .01, .1)
  ), ncol = 3, byrow = TRUE),
  nullEffect = 's2var = 0',
  nIndicator = rep(3, 4), loadM = .5,
  autocorResiduals = TRUE
)

# Determine required N in a 3-wave LGCM model
# to detect that the slope of an time-invariant covariate (TIC)
# on the slope factor differs from zero. 
# The TIC is measured by 4 indicators loading
# by .7, .7, .5, and .8. The slope of the TIC in the prediction of
# the intercept factor is .5, and in the prediction of the slope factor is .4.
powerLGCM &lt;- semPower.powerLGCM(
  'a-priori', alpha = .05, power = .80,
  nWaves = 3,
  means = c(.5, .2),
  variances = c(1, .5),
  covariances = .25,
  ticExogSlopes = c(.5, .4),  # i s
  nullEffect = 'betaST = 0',
  loadings = list(
    c(.5, .6, .4),      # X1
    c(.5, .6, .4),      # X2 
    c(.5, .6, .4),      # X3
    c(.7, .7, .5, .8)   # TIC
  ),
  autocorResiduals = TRUE
)

# Determine required N in a 3-wave LGCM model
# to detect that the slope of the slope factor in 
# the prediction of a time-invariant covariate (TIC) differs from zero. 
# The TIC is measured by 4 indicators loading
# by .7, .7, .5, and .8. The slopes of the intercept and the slope factors in
# the prediction of the TIC are .1 and .3, respectively.
powerLGCM &lt;- semPower.powerLGCM(
  'a-priori', alpha = .05, power = .80,
  nWaves = 3,
  means = c(.5, .2),
  variances = c(1, .5),
  covariances = .25,
  ticEndogSlopes = c(.1, .3),  # i s
  nullEffect = 'betaTS = 0',
  loadings = list(
    c(.5, .6, .4),      # X1
    c(.5, .6, .4),      # X2 
    c(.5, .6, .4),      # X3
    c(.7, .7, .5, .8)   # TIC
  ),
  autocorResiduals = TRUE
)

# Determine required N in a 3-wave LGCM model
# to detect that the mean of the slope factor in group 1
# differs from the mean of the slope factor in group 2
# with a power of 80% on alpha = 5%, where
# X is measured by 3 indicators loading by .5 each (at each wave and in each group), and
# the means of the intercept factor in group 1 and 2 are .5 and .25
# the means of the slope factor in group 1 and 2 are .25 and .4
# the variance of the intercept factor is 1 in both groups and
# the variance of the slope factor is .5in both groups and
# the intercept-slope covariance is .25 in both groups and
# autocorrelated residuals are assumed and
# the groups are equal-sized
powerLGCM &lt;- semPower.powerLGCM(
  'a-priori', alpha = .05, power = .80, N = list(1, 1),
  nWaves = 3,
  means = list(
    # i, s
    c(.5, .2),     # group 1 
    c(.25, .4)),   # group 2
  variances = c(1, .5),
  covariances = .25,
  nullEffect = 'sMeanA = sMeanB',
  nIndicator = rep(3, 3), loadM = .5,
  autocorResiduals = TRUE
)

# similar as above, but get required N to detect that
# the intercept-slope covariance differs across groups, 
# assuming that intercept and slope variances are equal across groups.
powerLGCM &lt;- semPower.powerLGCM(
  'a-priori', alpha = .05, power = .80, N = list(1, 1),
  nWaves = 3,
  means = c(.5, .2),  
  variances = c(1, .5),
  covariances = list(
    c(.25), # group 1 
    c(.1)), # group 2
  nullEffect = 'isCovA = isCovB',
  groupEqual = c('ivar', 'svar'),
  nIndicator = rep(3, 3), loadM = .5,
  autocorResiduals = TRUE
)

# perform a simulated post-hoc power analysis
# with 250 replications
set.seed(300121)
powerLGCM &lt;- semPower.powerLGCM(
  'post-hoc', alpha = .05, N = 500,
  nWaves = 3,
  means = c(.5, .2),     # i, s
  variances = c(1, .5),  # i, s
  covariances = .25,
  nullEffect = 'sMean = 0',
  nIndicator = rep(3, 3), loadM = .5,
  autocorResiduals = TRUE,
  simulatedPower = TRUE,
  simOptions = list(nReplications = 250)
)

## End(Not run)
</code></pre>

<hr>
<h2 id='semPower.powerLI'>semPower.powerLI</h2><span id='topic+semPower.powerLI'></span>

<h3>Description</h3>

<p>Convenience function for performing power analyses for hypothesis arising
in longitudinal measurement invariance models concerning a specific level of invariance.
This requires the lavaan package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semPower.powerLI(
  type,
  comparison = NULL,
  nullEffect = NULL,
  autocorResiduals = TRUE,
  Phi = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semPower.powerLI_+3A_type">type</code></td>
<td>
<p>type of power analysis, one of <code>'a-priori'</code>, <code>'post-hoc'</code>, <code>'compromise'</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerLI_+3A_comparison">comparison</code></td>
<td>
<p>comparison model, either <code>'saturated'</code> or one of <code>'configural'</code>, <code>'metric'</code>, <code>'scalar'</code>, <code>'residual'</code>, <code>'covariances'</code>, <code>'means'</code>, or a vector of restrictions in <code>lavaan</code> format (with <code>'none'</code> for no restrictions). See details.</p>
</td></tr>
<tr><td><code id="semPower.powerLI_+3A_nulleffect">nullEffect</code></td>
<td>
<p>defines the hypothesis (i.e., level of invariance) of interest. Accepts the same arguments as <code>comparison</code>. See details.</p>
</td></tr>
<tr><td><code id="semPower.powerLI_+3A_autocorresiduals">autocorResiduals</code></td>
<td>
<p>whether the residuals of the indicators of latent variables are autocorrelated over waves (<code>TRUE</code>, the default) or not (<code>FALSE</code>). This affects the df when the comparison model is the saturated model and generally affects power (also for comparisons to the restricted model).</p>
</td></tr>
<tr><td><code id="semPower.powerLI_+3A_phi">Phi</code></td>
<td>
<p>the factor correlation matrix. Can be <code>NULL</code> for uncorrelated factors.</p>
</td></tr>
<tr><td><code id="semPower.powerLI_+3A_...">...</code></td>
<td>
<p>mandatory further parameters related to the specific type of power analysis requested, see <code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code>, <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code>, and <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>, and parameters specifying the factor model. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a power analysis to reject various hypotheses arising
in the context of longitudinal measurement invariance, where a single attribute is measured repeatedly. The typical - but not in all parts necessary -
sequence concerning the measurement part is (a) configural, (b) metric, (c) scalar, (d) residual invariance,
and concerning the structural part  (e) latent covariances, (f) latent means, where each level of invariance is
compared against the previous level (e.g., scalar vs. metric). Power analysis provides
the power (or the required N) to reject a particular level of invariance.
</p>
<p>For hypotheses regarding multiple group invariance, see <code><a href="#topic+semPower.powerMI">semPower.powerMI()</a></code>. For hypotheses regarding autoregressive models, see <code><a href="#topic+semPower.powerAutoreg">semPower.powerAutoreg()</a></code>. For hypotheses in an ARMA model, see <code><a href="#topic+semPower.powerARMA">semPower.powerARMA()</a></code>.
</p>
<p>There are two ways to specify the models defined in the <code>comparison</code> and the <code>nullEffect</code> arguments. Either, one may
specify a specific level of invariance that includes all previous levels:
</p>

<ul>
<li> <p><code>'configural'</code>: no invariance constraints. Shows the same fit as the saturated model, so only the delta df differ.
</p>
</li>
<li> <p><code>'metric'</code>: all loadings are restricted to equality over measurement occasions. Note that reference scaling is used, so the first indicator should be invariant.
</p>
</li>
<li> <p><code>'scalar'</code>: all loadings and (indicator-)intercepts are restricted to equality.
</p>
</li>
<li> <p><code>'residual'</code>: all loadings, (indicator-)intercepts, and (indicator-)residuals are restricted to equality.
</p>
</li>
<li> <p><code>'covariances'</code>: all loadings, (indicator-)intercepts, (indicator-)residuals, and latent covariances are restricted to equality.
</p>
</li>
<li> <p><code>'means'</code>: all loadings, (indicator-)intercepts, (indicator-)residuals, latent covariances, and latent means are restricted to equality.
</p>
</li></ul>

<p>For example, setting <code>comparison = 'metric'</code> and <code>nullEffect = 'scalar'</code> determines power
to reject the hypothesis that the constraints placed in the scalar invariance model
(restricting loadings and intercepts) over the
metric invariance model (restricting only the loadings) are defensible.
</p>
<p>For greater flexibility, the models can also be defined using <code>lavaan</code> style restrictions as a vector, namely
<code>'none'</code> (no restrictions), <code>'loadings'</code> (loadings), <code>'intercepts'</code> (intercepts), <code>'residuals'</code> (residuals), <code>'lv.covariances'</code> (latent covariances), <code>'means'</code> (latent means).
For instance:
</p>

<ul>
<li> <p><code>'none'</code>: no invariance constraints and thus representing a configural invariance model. Shows the same fit as the saturated model, so only the delta df differ.
</p>
</li>
<li> <p><code>c('loadings')</code>: all loadings are restricted to equality. Note that reference scaling is used, so the first indicator should be invariant.
</p>
</li>
<li> <p><code>c('loadings', 'intercepts')</code>: all loadings and (indicator-)intercepts are restricted to equality.
</p>
</li>
<li> <p><code>c('loadings', 'intercepts', 'residuals')</code>: all loadings, (indicator-)intercepts, and (indicator-)residuals are restricted to equality.
</p>
</li>
<li> <p><code>c('loadings', 'residuals')</code>: all loadings and (indicator-)residuals are restricted to equality.
</p>
</li>
<li> <p><code>c('loadings', 'intercepts', 'means')</code>: all loadings, (indicator-)intercepts, and latent factor means are restricted to equality.
</p>
</li>
<li> <p><code>c('loadings', 'residuals', 'lv.covariances')</code>: all loadings, (indicator-)residuals, and latent factor covariances are restricted to equality.
</p>
</li></ul>

<p>For example, setting <code>comparison = c('loadings')</code> and <code style="white-space: pre;">&#8288;nullEffect = 'c('loadings', 'intercepts')'&#8288;</code>
determines power to reject the hypothesis that the constraints placed in the scalar invariance model
(restricting loadings and intercepts) over the  metric invariance model (restricting only the loadings) are defensible.
Note that variance scaling is used, so invariance of variances (<code>'lv.variances'</code>) is always met. Latent means are identified using single occasion identification.
</p>
<p>Beyond the arguments explicitly contained in the function call, additional arguments
are required specifying the factor model and the requested type of power analysis.
</p>
<p>Additional arguments related to the <strong>definition of the factor model</strong>:
</p>

<ul>
<li> <p><code>Lambda</code>: The factor loading matrix (with the number of columns equaling the number of factors).
</p>
</li>
<li> <p><code>loadings</code>: Can be used instead of <code>Lambda</code>: Defines the primary loadings for each factor in a list structure, e. g. <code>loadings = list(c(.5, .4, .6), c(.8, .6, .6, .4))</code> defines a two factor model with three indicators loading on the first factor by .5, , 4., and .6, and four indicators loading on the second factor by .8, .6, .6, and .4.
</p>
</li>
<li> <p><code>nIndicator</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>loadM</code>. Defines the number of indicators by factor, e. g., <code>nIndicator = c(3, 4)</code> defines a two factor model with three and four indicators for the first and second factor, respectively. <code>nIndicator</code> can also be a single number to define the same number of indicators for each factor.
</p>
</li>
<li> <p><code>loadM</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>nIndicator</code>. Defines the loading either for all indicators (if a single number is provided) or separately for each factor (if a vector is provided), e. g. <code>loadM = c(.5, .6)</code> defines the loadings of the first factor to equal .5 and those of the second factor do equal .6.
</p>
</li>
<li> <p><code>Theta</code>: Variance-covariance matrix of the indicator residuals, which should be a diagonal matrix. Required when residual non-invariance is to be detected. When <code>NULL</code>, Theta is a diagonal matrix with elements such that all variances are 1.
</p>
</li>
<li> <p><code>tau</code>: Defines the indicator intercepts, required whenever a model involves hypotheses about means (e.g., scalar invariance). If <code>NULL</code> and <code>Alpha</code> is set, all intercepts are assumed to equal zero.
</p>
</li>
<li> <p><code>Alpha</code>: Defines the latent means, required whenever a model involves hypotheses about latent means (e.g., latent mean invariance). If <code>NULL</code> and <code>tau</code> is set, all latent means are assumed to equal zero. Because variance scaling is used so that all factor variances are 1, latent mean differences can be interpreted akin to Cohen's d as standardized mean differences.
</p>
</li></ul>

<p>So either <code>Lambda</code>, or <code>loadings</code>, or <code>nIndicator</code> and <code>loadM</code> always need to be defined,
and <code>Theta</code>, <code>tau</code> and <code>Alpha</code> need to be defined for particular levels of invariance.
</p>
<p>Additional arguments related to the requested type of <strong>power analysis</strong>:
</p>

<ul>
<li> <p><code>alpha</code>: The alpha error probability. Required for <code>type = 'a-priori'</code> and <code>type = 'post-hoc'</code>.
</p>
</li>
<li><p> Either <code>beta</code> or <code>power</code>: The beta error probability and the statistical power (1 - beta), respectively. Only for <code>type = 'a-priori'</code>.
</p>
</li>
<li> <p><code>N</code>: The sample size. Always required for <code>type = 'post-hoc'</code> and <code>type = 'compromise'</code>. For <code>type = 'a-priori'</code> and multiple group analysis, <code>N</code> is a list of group weights.
</p>
</li>
<li> <p><code>abratio</code>: The ratio of alpha to beta. Only for <code>type = 'compromise'</code>.
</p>
</li></ul>

<p>If a <strong>simulated power analysis</strong> (<code>simulatedPower = TRUE</code>) is requested, optional arguments can be provided as a list to <code>simOptions</code>:
</p>

<ul>
<li> <p><code>nReplications</code>: The targeted number of simulation runs. Defaults to 250, but larger numbers greatly improve accuracy at the expense of increased computation time.
</p>
</li>
<li> <p><code>minConvergenceRate</code>:  The minimum convergence rate required, defaults to .5. The maximum actual simulation runs are increased by a factor of 1/minConvergenceRate.
</p>
</li>
<li> <p><code>type</code>: specifies whether the data should be generated from a population assuming multivariate normality (<code>'normal'</code>; the default), or based on an approach generating non-normal data (<code>'IG'</code>, <code>'mnonr'</code>, <code>'RC'</code>, or <code>'VM'</code>).
The approaches generating non-normal data require additional arguments detailed below.
</p>
</li>
<li> <p><code>missingVars</code>: vector specifying the variables containing missing data (defaults to NULL).
</p>
</li>
<li> <p><code>missingVarProp</code>: can be used instead of <code>missingVars</code>: The proportion of variables containing missing data (defaults to zero).
</p>
</li>
<li> <p><code>missingProp</code>: The proportion of missingness for variables containing missing data (defaults to zero), either a single value or a vector giving the probabilities for each variable.
</p>
</li>
<li> <p><code>missingMechanism</code>: The missing data mechanism, one of <code>MCAR</code> (the default), <code>MAR</code>, or <code>NMAR</code>.
</p>
</li>
<li> <p><code>nCores</code>: The number of cores to use for parallel processing. Defaults to 1 (= no parallel processing). This requires the <code>doSNOW</code> package.
</p>
</li></ul>

<p><code>type = 'IG'</code> implements the independent generator approach (IG, Foldnes &amp; Olsson, 2016) approach
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors. This requires the <code>covsim</code> package.
</p>
<p><code>type = 'mnonr'</code> implements the approach suggested by Qu, Liu, &amp; Zhang (2020) and requires provision of  Mardia's multivariate skewness (<code>skewness</code>)  and kurtosis  (<code>kurtosis</code>), where
skewness must be non-negative and kurtosis must be at least 1.641 skewness + p (p + 0.774), where p is the number of variables. This requires the <code>mnonr</code> package.
</p>
<p><code>type = 'RK'</code> implements the approach suggested by Ruscio &amp; Kaczetow (2008) and requires provision of the population distributions
of each variable (<code>distributions</code>). <code>distributions</code> must be a list (if all variables shall be based on the same population distribution) or a list of lists.
Each component must specify the population distribution (e.g. <code>rchisq</code>) and additional arguments (<code>list(df = 2)</code>).
</p>
<p><code>type = 'VM'</code> implements the third-order polynomial method (Vale &amp; Maurelli, 1983)
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors.  This requires the <code>semTools</code> package.
</p>


<h3>Value</h3>

<p>a list. Use the <code>summary</code> method to obtain formatted results. Beyond the results of the power analysis and a number of effect size measures, the list contains the following components:
</p>
<table role = "presentation">
<tr><td><code>Sigma</code></td>
<td>
<p>the population covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the population mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td></tr>
<tr><td><code>SigmaHat</code></td>
<td>
<p>the H0 model implied covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code>muHat</code></td>
<td>
<p>the H0 model implied mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td></tr>
<tr><td><code>modelH0</code></td>
<td>
<p><code>lavaan</code> H0 model string.</p>
</td></tr>
<tr><td><code>modelH1</code></td>
<td>
<p><code>lavaan</code> H1 model string or <code>NULL</code> when the comparison refers to the saturated model.</p>
</td></tr>
<tr><td><code>simRes</code></td>
<td>
<p>detailed simulation results when a simulated power analysis (<code>simulatedPower = TRUE</code>) was performed.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+semPower.genSigma">semPower.genSigma()</a></code> <code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code> <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code> <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 


# obtain the required N to reject the hypothesis of metric invariance
# in comparison to the configural invariance model
# with a power of 80% on alpha = 5%
# for amodel involving a two factors (= two measurements) which
# is measured by 5 indicators
# loading by .5 each at the first measurement occasion
# loading by .6 each in the second measurement occasion,
# and assuming autocorrelated residuals
powerLI &lt;- semPower.powerLI(
  type = 'a-priori', alpha = .05, power = .80, 
  comparison = 'configural',
  nullEffect = 'metric',
  nIndicator = c(5, 5),
  loadM = c(.5, .6),
  autocorResiduals = TRUE
)

# show summary
summary(powerLI)

# optionally use lavaan to verify the model was set-up as intended
lavaan::sem(powerLI$modelH1, sample.cov = powerLI$Sigma,
            sample.nobs = 1000, sample.cov.rescale = FALSE)
lavaan::sem(powerLI$modelH0, sample.cov = powerLI$Sigma,
            sample.nobs = 1000, sample.cov.rescale = FALSE)



# same as above, but determine power with N = 500 on alpha = .05
powerLI &lt;- semPower.powerLI(
  type = 'post-hoc', alpha = .05, N = 500, 
  comparison = 'configural',
  nullEffect = 'metric',
  nIndicator = c(5, 5),
  loadM = c(.5, .6),
  autocorResiduals = TRUE
)


# same as above, but determine the critical chi-square with N = 500 in each
# group so that alpha = beta
powerLI &lt;- semPower.powerLI(
  type = 'compromise', abratio = 1, N = 500, 
  comparison = 'configural',
  nullEffect = 'metric',
  nIndicator = c(5, 5),
  loadM = c(.5, .6),
  autocorResiduals = TRUE
)


# same as above, but compare to the saturated model
# (rather than to the configural invariance model)
powerLI &lt;- semPower.powerLI(
  type = 'a-priori', alpha = .05, power = .80, 
  comparison = 'saturated',
  nullEffect = 'metric',
  nIndicator = c(5, 5),
  loadM = c(.5, .6),
  autocorResiduals = TRUE
)


# same as above, but provide individual factor loadings by group using a
# reduced loading matrix to define a  single factor model with three indicators
# loading by .4, .6, .5 at the first measurement occasion and
# loading by .5, .6, .7 at the second measurement occasion 
powerLI &lt;- semPower.powerLI(
  type = 'a-priori', alpha = .05, power = .80, 
  comparison = 'configural',
  nullEffect = 'metric',
  loadings = list(
    c(.4, .6, .5),
    c(.5, .6, .7)
  ),
  autocorResiduals = TRUE
)

# obtain the required N to reject the hypothesis of scalar invariance
# in comparison to the metric invariance model
# with a power of 80% on alpha = 5%
# for a two factor model, where both factors are
# measured by 3 indicators each and all loadings equal .5 (at both measurements),
# all intercepts are 0.0 at the first measurement occasion, but
# all intercepts are 0.2 at the second measurement occasion and
powerLI &lt;- semPower.powerLI(
  type = 'a-priori', alpha = .05, power = .80, 
  comparison = 'metric',
  nullEffect = 'scalar',
  nIndicator = c(5, 5),
  loadM = c(.5, .5),
  tau = c(0, 0, 0, 0, 0, 
          .2, .2, .2, .2, .2),
  autocorResiduals = TRUE
)

# same as above, but use lavaan strings 
powerLI &lt;- semPower.powerLI(
  type = 'a-priori', alpha = .05, power = .80, 
  comparison = c('loadings'),
  nullEffect = c('loadings', 'intercepts'),
  nIndicator = c(5, 5),
  loadM = c(.5, .5),
  tau = c(0, 0, 0, 0, 0, 
          .2, .2, .2, .2, .2),
  autocorResiduals = TRUE
)


# obtain the required N to reject the hypothesis of equal latent means
# in comparison to the scalar invariance model;
# all intercepts are zero in both groups,
# at the first measurement occasion, the latent mean is 0.0,
# at the first measurement occasion, the latent mean is 0.5
powerLI &lt;- semPower.powerLI(
  type = 'a-priori', alpha = .05, power = .80, 
  comparison = c('loadings', 'intercepts'),
  nullEffect = c('loadings', 'intercepts', 'means'),
  nIndicator = c(5, 5),
  loadM = c(.5, .5),
  tau = rep(0, 10),
  Alpha = c(0, .5),
  autocorResiduals = TRUE
)

# obtain the required N to reject the hypothesis of equal covariances
# in comparison to the residual invariance model;
 Phi &lt;- matrix(c(
  c(1, .3, .1),
   c(.3, 1, .2),
   c(.1, .2, 1)
 ), nrow=3, byrow = TRUE)
 powerLI &lt;- semPower.powerLI(
   type = 'a-priori', alpha = .05, power = .80,
   comparison = 'residual',
   nullEffect = 'covariances',
   nIndicator = c(3, 3, 3),
   loadM = c(.5, .5, .5),
   Phi = Phi,
   tau = rep(0, 9)
)   
 
# request a simulated post-hoc power analysis with 250 replications
# to reject the hypothesis of equal latent means.
set.seed(300121)
powerLI &lt;- semPower.powerLI(
  type = 'post-hoc', alpha = .05, N = 500, 
  comparison = c('loadings', 'intercepts'),
  nullEffect = c('loadings', 'intercepts', 'means'),
  nIndicator = c(5, 5),
  loadM = c(.5, .5),
  tau = rep(0, 10),
  Alpha = c(0, .5),
  autocorResiduals = TRUE,
  simulatedPower = TRUE,
  simOptions = list(nReplications = 250)  
)

## End(Not run)
</code></pre>

<hr>
<h2 id='semPower.powerMediation'>semPower.powerMediation</h2><span id='topic+semPower.powerMediation'></span>

<h3>Description</h3>

<p>Convenience function for performing power analysis concerning indirect effect(s) in a mediation model.
This requires the lavaan package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semPower.powerMediation(
  type,
  comparison = "restricted",
  bYX = NULL,
  bMX = NULL,
  bYM = NULL,
  Beta = NULL,
  indirect = NULL,
  nullEffect = "ind = 0",
  nullWhichGroups = NULL,
  standardized = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semPower.powerMediation_+3A_type">type</code></td>
<td>
<p>type of power analysis, one of <code>'a-priori'</code>, <code>'post-hoc'</code>, <code>'compromise'</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerMediation_+3A_comparison">comparison</code></td>
<td>
<p>comparison model, one of <code>'saturated'</code> or <code>'restricted'</code> (the default). This determines the df for power analyses. <code>'saturated'</code> provides power to reject the model when compared to the saturated model, so the df equal the one of the hypothesized model. <code>'restricted'</code> provides power to reject the hypothesized model when compared to an otherwise identical model that just omits the restrictions defined in <code>nullEffect</code>, so the df equal the number of restrictions.</p>
</td></tr>
<tr><td><code id="semPower.powerMediation_+3A_byx">bYX</code></td>
<td>
<p>the slope (direct effect) for X -&gt; Y. A list for multiple group models. Can be <code>NULL</code> if <code>Beta</code> is set.</p>
</td></tr>
<tr><td><code id="semPower.powerMediation_+3A_bmx">bMX</code></td>
<td>
<p>the slope for X -&gt; M. A list for multiple group models. Can be <code>NULL</code> if <code>Beta</code> is set.</p>
</td></tr>
<tr><td><code id="semPower.powerMediation_+3A_bym">bYM</code></td>
<td>
<p>the slope for M -&gt; Y. A list for multiple group models. Can be <code>NULL</code> if <code>Beta</code> is set.</p>
</td></tr>
<tr><td><code id="semPower.powerMediation_+3A_beta">Beta</code></td>
<td>
<p>can be used instead of <code>bYX</code>, <code>bMX</code>, and <code>bYM</code>: matrix of regression weights connecting the latent factors (all-Y notation). Exogenous variables must be in the first row(s), so the upper triangular of Beta must be zero. A list for multiple group models.</p>
</td></tr>
<tr><td><code id="semPower.powerMediation_+3A_indirect">indirect</code></td>
<td>
<p><code>NULL</code> unless <code>Beta</code> is set. Otherwise a list of vectors of size 2 indicating the elements of <code>Beta</code> that define the indirect effect of interest, e.g. <code>list(c(2, 1), c(3, 2))</code>. See details.</p>
</td></tr>
<tr><td><code id="semPower.powerMediation_+3A_nulleffect">nullEffect</code></td>
<td>
<p>defines the hypothesis of interest, must be one of <code>'ind = 0'</code> (the default) to test whether the indirect effect is zero or <code>'indA = indB'</code> to test for the equality of indirect effects across groups. See details.</p>
</td></tr>
<tr><td><code id="semPower.powerMediation_+3A_nullwhichgroups">nullWhichGroups</code></td>
<td>
<p>for <code>nullEffect = 'indA = indB'</code>, vector indicating the groups for which equality constrains should be applied, e.g. <code>c(1, 3)</code> to constrain the relevant parameters of the first and the third group. If <code>NULL</code>, all groups are constrained to equality.</p>
</td></tr>
<tr><td><code id="semPower.powerMediation_+3A_standardized">standardized</code></td>
<td>
<p>whether all parameters should be standardized (<code>TRUE</code>, the default). If <code>FALSE</code>, all regression relations are unstandardized.</p>
</td></tr>
<tr><td><code id="semPower.powerMediation_+3A_...">...</code></td>
<td>
<p>mandatory further parameters related to the specific type of power analysis requested, see <code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code>, <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code>, and <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>, and parameters specifying the factor model. In case of a simple mediation, the order of factors is X, M, Y. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a power analysis to reject various hypotheses arising
in the context of mediation:
</p>

<ul>
<li> <p><code>nullEffect = 'ind = 0'</code>: Tests the hypothesis that an indirect effect is zero.
</p>
</li>
<li> <p><code>nullEffect = 'indA = indB'</code>: Tests the hypothesis that an indirect effect is equal in two or more groups. This is currently only possible for models without latent variables.
</p>
</li></ul>

<p>The indirect effect of interest can be specified in two ways:
</p>

<ul>
<li><p> If a simple mediation involving three variables of the form <code>X -&gt; M -&gt; Y</code> is assumed, the arguments
<code>bYX</code>, <code>bMX</code>, and <code>bYM</code> are used to define the respective slopes, e. g.  <code>bYX = .4</code>, <code>bMX = .5</code>, and <code>bYM = .3</code> translates to
<code style="white-space: pre;">&#8288;X -- .5 --&gt; M -- .3 --&gt; Y&#8288;</code> and  <code style="white-space: pre;">&#8288;X -- .4 --&gt; Y&#8288;</code>.
</p>
</li>
<li><p> More complex mediation structures can be defined by providing the <code>Beta</code> matrix along with <code>indirect</code> specifying which paths define the indirect effect. See examples below.
</p>
</li></ul>

<p>Notes on implementation:
</p>

<ul>
<li><p> For models without latent variables, <code>nullEffect = 'ind = 0'</code> and <code>nullEffect = 'indA = indB'</code> constrain the indirect effect to zero and to equality, respectively, yielding the test described in Tofighi &amp; Kelley (2020).
</p>
</li>
<li><p> For models with latent variables and <code>nullEffect = 'ind = 0'</code>, power is (sometimes roughly) approximated by constraining the smallest slope contained in the indirect effect to zero.
</p>
</li>
<li><p> For models with latent variables multiple groups (i. e., <code>nullEffect = 'indA = indB'</code>), there is currently no way to determine power.
</p>
</li></ul>

<p>Tofighi, D., &amp; Kelley, K. (2020). Improved inference in mediation analysis: Introducing the model-based constrained optimization procedure. <em>Psychological Methods, 25(4)</em>, 496–515. https://doi.org/10.1037/met0000259
</p>
<p>Beyond the arguments explicitly contained in the function call, additional arguments
are required specifying the factor model and the requested type of power analysis.
</p>
<p>Additional arguments related to the <strong>definition of the factor model</strong>:
</p>

<ul>
<li> <p><code>Lambda</code>: The factor loading matrix (with the number of columns equaling the number of factors).
</p>
</li>
<li> <p><code>loadings</code>: Can be used instead of <code>Lambda</code>: Defines the primary loadings for each factor in a list structure, e. g. <code>loadings = list(c(.5, .4, .6), c(.8, .6, .6, .4))</code> defines a two factor model with three indicators loading on the first factor by .5, , 4., and .6, and four indicators loading on the second factor by .8, .6, .6, and .4.
</p>
</li>
<li> <p><code>nIndicator</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>loadM</code>. Defines the number of indicators by factor, e. g., <code>nIndicator = c(3, 4)</code> defines a two factor model with three and four indicators for the first and second factor, respectively. <code>nIndicator</code> can also be a single number to define the same number of indicators for each factor.
</p>
</li>
<li> <p><code>loadM</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>nIndicator</code>. Defines the loading either for all indicators (if a single number is provided) or separately for each factor (if a vector is provided), e. g. <code>loadM = c(.5, .6)</code> defines the loadings of the first factor to equal .5 and those of the second factor do equal .6.
</p>
</li></ul>

<p>So either <code>Lambda</code>, or <code>loadings</code>, or <code>nIndicator</code> and <code>loadM</code> need to be defined.
If the model contains observed variables only, use <code>Lambda = diag(x)</code> where <code>x</code> is the number of variables.
</p>
<p>Note that in case of a simple mediation model involving three variables, the order of the factors is X, M, Y, i. e., the first factor is treated as X, the second as M, and the third as Y. In case of a more complex mediation defined via the <code>Beta</code> matrix, the order of factors matches the order of <code>Beta</code>.
</p>
<p>Additional arguments related to the requested type of <strong>power analysis</strong>:
</p>

<ul>
<li> <p><code>alpha</code>: The alpha error probability. Required for <code>type = 'a-priori'</code> and <code>type = 'post-hoc'</code>.
</p>
</li>
<li><p> Either <code>beta</code> or <code>power</code>: The beta error probability and the statistical power (1 - beta), respectively. Only for <code>type = 'a-priori'</code>.
</p>
</li>
<li> <p><code>N</code>: The sample size. Always required for <code>type = 'post-hoc'</code> and <code>type = 'compromise'</code>. For <code>type = 'a-priori'</code> and multiple group analysis, <code>N</code> is a list of group weights.
</p>
</li>
<li> <p><code>abratio</code>: The ratio of alpha to beta. Only for <code>type = 'compromise'</code>.
</p>
</li></ul>

<p>If a <strong>simulated power analysis</strong> (<code>simulatedPower = TRUE</code>) is requested, optional arguments can be provided as a list to <code>simOptions</code>:
</p>

<ul>
<li> <p><code>nReplications</code>: The targeted number of simulation runs. Defaults to 250, but larger numbers greatly improve accuracy at the expense of increased computation time.
</p>
</li>
<li> <p><code>minConvergenceRate</code>:  The minimum convergence rate required, defaults to .5. The maximum actual simulation runs are increased by a factor of 1/minConvergenceRate.
</p>
</li>
<li> <p><code>type</code>: specifies whether the data should be generated from a population assuming multivariate normality (<code>'normal'</code>; the default), or based on an approach generating non-normal data (<code>'IG'</code>, <code>'mnonr'</code>, <code>'RC'</code>, or <code>'VM'</code>).
The approaches generating non-normal data require additional arguments detailed below.
</p>
</li>
<li> <p><code>missingVars</code>: vector specifying the variables containing missing data (defaults to NULL).
</p>
</li>
<li> <p><code>missingVarProp</code>: can be used instead of <code>missingVars</code>: The proportion of variables containing missing data (defaults to zero).
</p>
</li>
<li> <p><code>missingProp</code>: The proportion of missingness for variables containing missing data (defaults to zero), either a single value or a vector giving the probabilities for each variable.
</p>
</li>
<li> <p><code>missingMechanism</code>: The missing data mechanism, one of <code>MCAR</code> (the default), <code>MAR</code>, or <code>NMAR</code>.
</p>
</li>
<li> <p><code>nCores</code>: The number of cores to use for parallel processing. Defaults to 1 (= no parallel processing). This requires the <code>doSNOW</code> package.
</p>
</li></ul>

<p><code>type = 'IG'</code> implements the independent generator approach (IG, Foldnes &amp; Olsson, 2016) approach
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors. This requires the <code>covsim</code> package.
</p>
<p><code>type = 'mnonr'</code> implements the approach suggested by Qu, Liu, &amp; Zhang (2020) and requires provision of  Mardia's multivariate skewness (<code>skewness</code>)  and kurtosis  (<code>kurtosis</code>), where
skewness must be non-negative and kurtosis must be at least 1.641 skewness + p (p + 0.774), where p is the number of variables. This requires the <code>mnonr</code> package.
</p>
<p><code>type = 'RK'</code> implements the approach suggested by Ruscio &amp; Kaczetow (2008) and requires provision of the population distributions
of each variable (<code>distributions</code>). <code>distributions</code> must be a list (if all variables shall be based on the same population distribution) or a list of lists.
Each component must specify the population distribution (e.g. <code>rchisq</code>) and additional arguments (<code>list(df = 2)</code>).
</p>
<p><code>type = 'VM'</code> implements the third-order polynomial method (Vale &amp; Maurelli, 1983)
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors.  This requires the <code>semTools</code> package.
</p>


<h3>Value</h3>

<p>a list. Use the <code>summary</code> method to obtain formatted results. Beyond the results of the power analysis and a number of effect size measures, the list contains the following components:
</p>
<table role = "presentation">
<tr><td><code>Sigma</code></td>
<td>
<p>the population covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the population mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td></tr>
<tr><td><code>SigmaHat</code></td>
<td>
<p>the H0 model implied covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code>muHat</code></td>
<td>
<p>the H0 model implied mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td></tr>
<tr><td><code>modelH0</code></td>
<td>
<p><code>lavaan</code> H0 model string.</p>
</td></tr>
<tr><td><code>modelH1</code></td>
<td>
<p><code>lavaan</code> H1 model string or <code>NULL</code> when the comparison refers to the saturated model.</p>
</td></tr>
<tr><td><code>simRes</code></td>
<td>
<p>detailed simulation results when a simulated power analysis (<code>simulatedPower = TRUE</code>) was performed.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+semPower.genSigma">semPower.genSigma()</a></code> <code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code> <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code> <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# simple case of X -&gt; M -&gt; Y mediation in the form of
# X -- .30 --&gt; M -- .40 --&gt; Y
# X --------- .25 --------&gt; Y
# determine the required N to detect the indirect effect of &gt;= .12 (= .3 * .4) 
# with a power of 95% on alpha = 5%, where   
# X is measured by 3 indicators loading by .5 each, 
# M is measured by 5 indicators loading by .6 each, 
# Y is measured by 4 indicators loading by .7 each.
powerMed &lt;- semPower.powerMediation(type = 'a-priori',
                                    bYX = .25, bMX = .3, bYM = .4,
                                    nIndicator = c(3, 5, 4),
                                    loadM = c(.5, .6, .7),
                                    alpha = .05, beta = .05)
# show summary
summary(powerMed)
# optionally use lavaan to verify the model was set-up as intended
lavaan::sem(powerMed$modelH1, sample.cov = powerMed$Sigma,
sample.nobs = powerMed$requiredN, sample.cov.rescale = FALSE)
lavaan::sem(powerMed$modelH0, sample.cov = powerMed$Sigma,
sample.nobs = powerMed$requiredN, sample.cov.rescale = FALSE)

# same as above, but determine power with N = 500 on alpha = .05
powerMed &lt;- semPower.powerMediation(type = 'post-hoc',
                                    bYX = .25, bMX = .3, bYM = .4,
                                    nIndicator = c(3, 5, 4),
                                    loadM = c(.5, .6, .7),
                                    alpha = .05, N = 500)

# same as above, but determine the critical chi-square with N = 500 so that alpha = beta
powerMed &lt;- semPower.powerMediation(type = 'compromise',
                                    bYX = .25, bMX = .3, bYM = .4,
                                    nIndicator = c(3, 5, 4),
                                    loadM = c(.5, .6, .7),
                                    abratio = 1, N = 500)

# same as above, but compare to the saturated model
# (rather than to the less restricted model)
powerMed &lt;- semPower.powerMediation(type = 'a-priori',
                                    comparison = 'saturated',
                                    bYX = .25, bMX = .3, bYM = .4,
                                    nIndicator = c(3, 5, 4),
                                    loadM = c(.5, .6, .7),
                                    alpha = .05, beta = .05)

# same as above, but assuming observed variables only (Lambda = diag(3))
powerMed &lt;- semPower.powerMediation(type = 'a-priori',
                                    bYX = .25, bMX = .3, bYM = .4,
                                    Lambda = diag(3),
                                    alpha = .05, beta = .05)


# same mediation model as above, but specifying Beta and indirect
Beta &lt;- matrix(c(
  #   X    M    Y
  c(.00, .00, .00),    # X
  c(.30, .00, .00),    # M
  c(.25, .40, .00)     # Y
), byrow = TRUE, ncol = 3)
powerMed &lt;- semPower.powerMediation(type = 'a-priori',
                                    Beta = Beta, 
                                    indirect = list(c(2, 1), c(3, 2)),
                                    nIndicator = c(3, 5, 4),
                                    loadM = c(.5, .6, .7),
                                    alpha = .05, beta = .05)

# Beta for a more complex mediation hypothesis
# of the form X -- .2 --&gt; M1 -- .3 --&gt; M2 -- .40 -&gt; Y 
# (and all other effects being zero)
# using a reduced loading matrix to define that
# X is measured by 3 indicators loading by .4, .5, .8 
# M1 is measured by 4 indicators loading by .7, .6, .5, .8
# M2 is measured by 5 indicators loading by .5, .6, .3, .4, .6 
# Y is measured by 4 indicators loading by .6, .7, .8
Beta &lt;- matrix(c(
  c(.00, .00, .00, .00),       # X
  c(.20, .00, .00, .00),       # M1
  c(.00, .30, .00, .00),       # M2
  c(.00, .00, .40, .00)        # Y
), byrow = TRUE, ncol = 4)
loadings &lt;- list(
  c(0.4, 0.5, 0.8),           # X
  c(0.7, 0.6, 0.5, 0.8),      # M1
  c(0.5, 0.6, 0.3, 0.4, 0.6), # M2
  c(0.6, 0.7, 0.8)            # Y
)
powerMed &lt;- semPower.powerMediation(type = 'a-priori',
                                    Beta = B, 
                                    indirect = list(c(2, 1), 
                                                    c(3, 2), 
                                                    c(4, 3)),
                                    loadings = loadings,
                                    alpha = .05, beta = .05)

# Determine required N to detect that the indirect effect 
# in group 1 (of .2 * .3 = .09) differs from the indirect effect 
# in group 2 (of .3 * .5 = .15).
# The direct effect of X on Y is .25 in both groups.  
# The model is based on observed variables only (Lambda = diag(3))
# Both groups are sized equally (N = list(1, 1)).
powerMed &lt;- semPower.powerMediation(type = 'a-priori',
                                    nullEffect = 'indA = indB',
                                    bYX = list(.25, .25), 
                                    bMX = list(.2, .3), 
                                    bYM = list(.3, .5),
                                    Lambda = diag(3),
                                    alpha = .05, beta = .05, N = list(1, 1))

# same as above, but specifying Beta 
Beta1 &lt;- matrix(c(
  c(.00, .00, .00),    # X
  c(.20, .00, .00),    # M
  c(.25, .30, .00)     # Y
), byrow = TRUE, ncol = 3)
Beta2 &lt;- matrix(c(
  c(.00, .00, .00),    # X
  c(.30, .00, .00),    # M
  c(.25, .50, .00)     # Y
), byrow = TRUE, ncol = 3)
powerMed &lt;- semPower.powerMediation(type = 'a-priori',
                                    nullEffect = 'indA = indB',
                                    Beta = list(Beta1, Beta2), 
                                    indirect = list(c(2, 1), c(3, 2)),
                                    Lambda = diag(3),
                                    alpha = .05, beta = .05, N = list(1, 1))

# request a simulated post-hoc power analysis with 500 replications.
set.seed(300121)
powerMed &lt;- semPower.powerMediation(type = 'post-hoc',
                                    bYX = .25, bMX = .3, bYM = .4,
                                    nIndicator = c(3, 5, 4),
                                    loadM = c(.5, .6, .7),
                                    alpha = .05, N = 500,
                                    simulatedPower = TRUE, 
                                    simOptions = list(nReplications = 500))

## End(Not run)
</code></pre>

<hr>
<h2 id='semPower.powerMI'>semPower.powerMI</h2><span id='topic+semPower.powerMI'></span>

<h3>Description</h3>

<p>Convenience function for performing power analyses for hypothesis arising
in multigroup measurement invariance models concerning a specific level of invariance.
This requires the lavaan package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semPower.powerMI(type, comparison = NULL, nullEffect = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semPower.powerMI_+3A_type">type</code></td>
<td>
<p>type of power analysis, one of <code>'a-priori'</code>, <code>'post-hoc'</code>, <code>'compromise'</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerMI_+3A_comparison">comparison</code></td>
<td>
<p>comparison model, either <code>'saturated'</code> or one of <code>'configural'</code>, <code>'metric'</code>, <code>'scalar'</code>, <code>'covariances'</code>, or a vector of restrictions in <code>lavaan</code> format (with <code>'none'</code> for no restrictions). See details.</p>
</td></tr>
<tr><td><code id="semPower.powerMI_+3A_nulleffect">nullEffect</code></td>
<td>
<p>defines the hypothesis (i.e., level of invariance) of interest. One of <code>'metric'</code>, <code>'scalar'</code>, <code>'residual'</code>, <code>'covariances'</code>, <code>'means'</code> or a vector of restrictions in <code>lavaan</code> format. See details.</p>
</td></tr>
<tr><td><code id="semPower.powerMI_+3A_...">...</code></td>
<td>
<p>mandatory further parameters related to the specific type of power analysis requested, see <code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code>, <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code>, and <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>, and parameters specifying the factor model. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a power analysis to reject various hypotheses arising
in the context of multigroup measurement invariance. Multigroup invariance models
fit the specified model simultaneously to various groups and place increasingly
restrictive cross-group equality constrains on the model parameters. The typical - but not in all parts necessary -
sequence is (a) configural, (b) metric, (c) scalar, and (d) residual invariance, where each level of invariance is
compared against the previous level (e.g., scalar vs. metric). Power analysis provides
the power (or the required N) to reject a particular level of invariance.
</p>
<p>For hypotheses regarding longitudinal invariance, see <code><a href="#topic+semPower.powerLI">semPower.powerLI()</a></code>.
</p>
<p>The models defined in the <code>comparison</code> and the <code>nullEffect</code> arguments can be specified in two ways. Either specify
a specific level of invariance that includes all previous levels:
</p>

<ul>
<li> <p><code>'configural'</code>: no invariance constraints. Shows the same fit as the saturated model, so only the delta df differ.
</p>
</li>
<li> <p><code>'metric'</code>: all loadings are restricted to equality.
</p>
</li>
<li> <p><code>'scalar'</code>: all loadings and (indicator-)intercepts are restricted to equality.
</p>
</li>
<li> <p><code>'residual'</code>: all loadings, (indicator-)intercepts, and (indicator-)residuals are restricted to equality.
</p>
</li>
<li> <p><code>'covariances'</code>: all loadings, (indicator-)intercepts, and (indicator-)residuals, and latent covariances are restricted to equality.
</p>
</li>
<li> <p><code>'means'</code>: all loadings, (indicator-)intercepts, (indicator-)residuals, latent covariances, and latent means are restricted to equality.
</p>
</li></ul>

<p>For example, setting <code>comparison = 'metric'</code> and <code>nullEffect = 'scalar'</code> determines power
to reject the hypothesis that the constraints placed in the scalar invariance model
(restricting loadings and intercepts) over the
metric invariance model (restricting only the loadings) are defensible.
</p>
<p>For greater flexibility, the models can also be defined using <code>lavaan</code> style <code>group.equal</code> restrictions as a vector:
</p>

<ul>
<li> <p><code>'none'</code>: no invariance constraints and thus representing a configural invariance model. Shows the same fit as the saturated model, so only the delta df differ.
</p>
</li>
<li> <p><code>c('loadings')</code>: all loadings are restricted to equality.
</p>
</li>
<li> <p><code>c('loadings', 'intercepts')</code>: all loadings and (indicator-)intercepts are restricted to equality.
</p>
</li>
<li> <p><code>c('loadings', 'intercepts', 'residuals')</code>: all loadings, (indicator-)intercepts, and (indicator-)residuals are restricted to equality.
</p>
</li>
<li> <p><code>c('loadings', 'residuals')</code>: all loadings and (indicator-)residuals are restricted to equality.
</p>
</li>
<li> <p><code>c('loadings', 'intercepts', 'means')</code>: all loadings, (indicator-)intercepts, and latent factor means are restricted to equality.
</p>
</li></ul>

<p>For example, setting <code>comparison = c('loadings')</code> and <code style="white-space: pre;">&#8288;nullEffect = 'c('loadings', 'intercepts')'&#8288;</code>
determines power to reject the hypothesis that the constraints placed in the scalar invariance model
(restricting loadings and intercepts) over the  metric invariance model (restricting only the loadings) are defensible.
Note that variance scaling is used, so invariance of variances (<code>'lv.variances'</code>) is always met.
</p>
<p>Beyond the arguments explicitly contained in the function call, additional arguments
are required specifying the factor model and the requested type of power analysis.
</p>
<p>Additional arguments related to the <strong>definition of the factor model</strong>:
</p>

<ul>
<li> <p><code>Lambda</code>: The factor loading matrix (with the number of columns equaling the number of factors).
</p>
</li>
<li> <p><code>loadings</code>: Can be used instead of <code>Lambda</code>: Defines the primary loadings for each factor in a list structure, e. g. <code>loadings = list(c(.5, .4, .6), c(.8, .6, .6, .4))</code> defines a two factor model with three indicators loading on the first factor by .5, , 4., and .6, and four indicators loading on the second factor by .8, .6, .6, and .4.
</p>
</li>
<li> <p><code>nIndicator</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>loadM</code>. Defines the number of indicators by factor, e. g., <code>nIndicator = c(3, 4)</code> defines a two factor model with three and four indicators for the first and second factor, respectively. <code>nIndicator</code> can also be a single number to define the same number of indicators for each factor.
</p>
</li>
<li> <p><code>loadM</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>nIndicator</code>. Defines the loading either for all indicators (if a single number is provided) or separately for each factor (if a vector is provided), e. g. <code>loadM = c(.5, .6)</code> defines the loadings of the first factor to equal .5 and those of the second factor do equal .6.
</p>
</li>
<li> <p><code>Theta</code>: Variance-covariance matrix of the indicator residuals, which should be a diagonal matrix. Required when residual non-invariance is to be detected. When <code>NULL</code>, Theta is a diagonal matrix with elements such that all variances are 1.
</p>
</li>
<li> <p><code>tau</code>: Defines the item intercepts, required whenever a model involves hypotheses about means (e.g., scalar invariance). If <code>NULL</code> and <code>Alpha</code> is set, all intercepts are assumed to equal zero.
</p>
</li>
<li> <p><code>Alpha</code>: Defines the latent means, required whenever a model involves hypotheses about latent means (e.g., latent mean invariance). If <code>NULL</code> and <code>tau</code> is set, all latent means are assumed to equal zero. Because variance scaling is used so that all factor variances are 1, latent mean differences can be interpreted akin to Cohen's d as standardized mean differences.
</p>
</li></ul>

<p>So either <code>Lambda</code>, or <code>loadings</code>, or <code>nIndicator</code> and <code>loadM</code> always need to be defined,
and <code>Theta</code>, <code>tau</code> and <code>Alpha</code> need to be defined for particular levels of invariance.
As this function operates on multiple groups, either argument is a list whenever there are
group differences in the respective parameters. When no list is provided, the same
parameter values are assumed for all groups.
</p>
<p>Additional arguments related to the requested type of <strong>power analysis</strong>:
</p>

<ul>
<li> <p><code>alpha</code>: The alpha error probability. Required for <code>type = 'a-priori'</code> and <code>type = 'post-hoc'</code>.
</p>
</li>
<li><p> Either <code>beta</code> or <code>power</code>: The beta error probability and the statistical power (1 - beta), respectively. Only for <code>type = 'a-priori'</code>.
</p>
</li>
<li> <p><code>N</code>: The sample size. Always required for <code>type = 'post-hoc'</code> and <code>type = 'compromise'</code>. For <code>type = 'a-priori'</code> and multiple group analysis, <code>N</code> is a list of group weights.
</p>
</li>
<li> <p><code>abratio</code>: The ratio of alpha to beta. Only for <code>type = 'compromise'</code>.
</p>
</li></ul>

<p>If a <strong>simulated power analysis</strong> (<code>simulatedPower = TRUE</code>) is requested, optional arguments can be provided as a list to <code>simOptions</code>:
</p>

<ul>
<li> <p><code>nReplications</code>: The targeted number of simulation runs. Defaults to 250, but larger numbers greatly improve accuracy at the expense of increased computation time.
</p>
</li>
<li> <p><code>minConvergenceRate</code>:  The minimum convergence rate required, defaults to .5. The maximum actual simulation runs are increased by a factor of 1/minConvergenceRate.
</p>
</li>
<li> <p><code>type</code>: specifies whether the data should be generated from a population assuming multivariate normality (<code>'normal'</code>; the default), or based on an approach generating non-normal data (<code>'IG'</code>, <code>'mnonr'</code>, <code>'RC'</code>, or <code>'VM'</code>).
The approaches generating non-normal data require additional arguments detailed below.
</p>
</li>
<li> <p><code>missingVars</code>: vector specifying the variables containing missing data (defaults to NULL).
</p>
</li>
<li> <p><code>missingVarProp</code>: can be used instead of <code>missingVars</code>: The proportion of variables containing missing data (defaults to zero).
</p>
</li>
<li> <p><code>missingProp</code>: The proportion of missingness for variables containing missing data (defaults to zero), either a single value or a vector giving the probabilities for each variable.
</p>
</li>
<li> <p><code>missingMechanism</code>: The missing data mechanism, one of <code>MCAR</code> (the default), <code>MAR</code>, or <code>NMAR</code>.
</p>
</li>
<li> <p><code>nCores</code>: The number of cores to use for parallel processing. Defaults to 1 (= no parallel processing). This requires the <code>doSNOW</code> package.
</p>
</li></ul>

<p><code>type = 'IG'</code> implements the independent generator approach (IG, Foldnes &amp; Olsson, 2016) approach
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors. This requires the <code>covsim</code> package.
</p>
<p><code>type = 'mnonr'</code> implements the approach suggested by Qu, Liu, &amp; Zhang (2020) and requires provision of  Mardia's multivariate skewness (<code>skewness</code>)  and kurtosis  (<code>kurtosis</code>), where
skewness must be non-negative and kurtosis must be at least 1.641 skewness + p (p + 0.774), where p is the number of variables. This requires the <code>mnonr</code> package.
</p>
<p><code>type = 'RK'</code> implements the approach suggested by Ruscio &amp; Kaczetow (2008) and requires provision of the population distributions
of each variable (<code>distributions</code>). <code>distributions</code> must be a list (if all variables shall be based on the same population distribution) or a list of lists.
Each component must specify the population distribution (e.g. <code>rchisq</code>) and additional arguments (<code>list(df = 2)</code>).
</p>
<p><code>type = 'VM'</code> implements the third-order polynomial method (Vale &amp; Maurelli, 1983)
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors.  This requires the <code>semTools</code> package.
</p>


<h3>Value</h3>

<p>a list. Use the <code>summary</code> method to obtain formatted results. Beyond the results of the power analysis and a number of effect size measures, the list contains the following components:
</p>
<table role = "presentation">
<tr><td><code>Sigma</code></td>
<td>
<p>the population covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the population mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td></tr>
<tr><td><code>SigmaHat</code></td>
<td>
<p>the H0 model implied covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code>muHat</code></td>
<td>
<p>the H0 model implied mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td></tr>
<tr><td><code>modelH0</code></td>
<td>
<p><code>lavaan</code> H0 model string.</p>
</td></tr>
<tr><td><code>modelH1</code></td>
<td>
<p><code>lavaan</code> H1 model string or <code>NULL</code> when the comparison refers to the saturated model.</p>
</td></tr>
<tr><td><code>simRes</code></td>
<td>
<p>detailed simulation results when a simulated power analysis (<code>simulatedPower = TRUE</code>) was performed.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+semPower.genSigma">semPower.genSigma()</a></code> <code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code> <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code> <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# obtain the required N to reject the hypothesis of metric invariance
# in comparison to the configural invariance model 
# with a power of 95% on alpha = 5% 
# assuming equally sized groups (N = list(1, 1)) 
# for a factor model involving a single factor which 
# is measured by 5 indicators (in both groups)
# loading by .5 each in the first group and 
# loading by .6 each in the second group.
powerMI &lt;- semPower.powerMI(type = 'a-priori',
                            comparison = 'configural', 
                            nullEffect = 'metric',
                            nIndicator = list(5, 5),
                            loadM = list(.5, .6),
                            alpha = .05, beta = .05, N = list(1, 1))

# show summary
summary(powerMI)
# optionally use lavaan to verify the model was set-up as intended
lavaan::sem(powerMI$modelH1, sample.cov = list(powerMI$Sigma[[1]], powerMI$Sigma[[2]]),
            sample.nobs = as.list(powerMI$requiredN.g), sample.cov.rescale = FALSE)
lavaan::sem(powerMI$modelH0, sample.cov = list(powerMI$Sigma[[1]], powerMI$Sigma[[2]]),
            sample.nobs = as.list(powerMI$requiredN.g), sample.cov.rescale = FALSE)

# same as above, but determine power with N = 500 in each group on alpha = .05
powerMI &lt;- semPower.powerMI(type = 'post-hoc',
                            comparison = 'configural', 
                            nullEffect = 'metric',
                            nIndicator = 5,
                            loadM = list(.5, .6),
                            alpha = .05, N = list(500, 500))

# same as above, but determine the critical chi-square with N = 500 in each 
# group so that alpha = beta
powerMI &lt;- semPower.powerMI(type = 'compromise',
                            comparison = 'configural', 
                            nullEffect = 'metric',
                            nIndicator = 5,
                            loadM = list(.5, .6),
                            abratio = 1, N = list(500, 500))

# same as above, but compare to the saturated model
# (rather than to the configural invariance model)
powerMI &lt;- semPower.powerMI(type = 'a-priori',
                            comparison = 'saturated', 
                            nullEffect = 'metric',
                            nIndicator = 5,
                            loadM = list(.5, .6),
                            alpha = .05, beta = .05, N = list(1, 1))

# same as above, but provide individual factor loadings by group using a 
# reduced loading matrix to define a  single factor model with three indicators
# loading by .4, .6, .5 in the first group and 
# loading by .5, .6, .7 in the second group
powerMI &lt;- semPower.powerMI(type = 'a-priori',
                            comparison = 'saturated', 
                            nullEffect = 'metric',
                            loadings = list(
                              list(c(.4, .6, .5)), 
                              list(c(.5, .6, .7))),
                            alpha = .05, beta = .05, N = list(1, 1))

# same as above, but make first group twice as large as the second group 
powerMI &lt;- semPower.powerMI(type = 'a-priori',
                            comparison = 'saturated', 
                            nullEffect = 'metric',
                            loadings = list(
                              list(c(.4, .6, .5)), 
                              list(c(.5, .6, .7))),
                            alpha = .05, beta = .05, N = list(2, 1))

# obtain the required N to reject the hypothesis of scalar invariance
# in comparison to the metric invariance model 
# with a power of 95% on alpha = 5% 
# assuming equally sized groups (N = list(1, 1)) 
# for a two factor model, where both factors are  
# measured by 3 indicators each and all loadings equal .5 (in both groups),
# the factor correlation is .3 in both groups, and the
# all intercepts are 0.0 in the first group, but
# the intercepts are .1, .2, .3, .4, .5, .6 in the second group
powerMI &lt;- semPower.powerMI(type = 'a-priori',
                            comparison = 'metric', 
                            nullEffect = 'scalar',
                            Phi = list(.3, .3),
                            nIndicator = list(
                              c(3, 3), 
                              c(3, 3)),
                            loadM = .5,
                            tau = list(
                              rep(0.0, 6), 
                              seq(.1, .6, .1) 
                            ),
                            alpha = .05, beta = .05, N = list(1, 1))

# same as above, but use lavaan group.equal strings 
powerMI &lt;- semPower.powerMI(type = 'a-priori',
                            comparison = c('loadings'), 
                            nullEffect = c('loadings', 'intercepts'),
                            Phi = list(.3, .3),
                            nIndicator = list(
                              c(3, 3), 
                              c(3, 3)),
                            loadM = .5,
                            tau = list(
                              rep(0.0, 6), 
                              seq(.1, .6, .1) 
                            ),
                            alpha = .05, beta = .05, N = list(1, 1))

# same as above, but
# obtain the required N to reject the hypothesis of equal latent means
# in comparison to the scalar invariance model;
# all intercepts are zero in both groups, 
# in the first group, the latent means equal 0.0, 
# in the second group, the latent mean of the factors are 0.0 and 0.5
powerMI &lt;- semPower.powerMI(type = 'a-priori',
                            comparison = c('loadings', 'intercepts'), 
                            nullEffect = c('loadings', 'intercepts', 'means'),
                            Phi = list(.3, .3),
                            nIndicator = list(
                              c(3, 3), 
                              c(3, 3)),
                            loadM = .5,
                            tau = list(
                              rep(0.0, 6), 
                              rep(0.0, 6) 
                            ),
                            Alpha = list(
                              c(0.0, 0.0),
                              c(0.0, 0.5)
                            ),
                            alpha = .05, beta = .05, N = list(1, 1))

# request a simulated post-hoc power analysis with 500 replications
# to reject the hypothesis of metric invariance.
set.seed(300121)
powerMI &lt;- semPower.powerMI(type = 'post-hoc',
                            comparison = 'configural', 
                            nullEffect = 'metric',
                            nIndicator = list(5, 5),
                            loadM = list(.5, .6),
                            alpha = .05, N = list(500, 500), 
                            simulatedPower = TRUE, 
                            simOptions = list(nReplications = 500))
                             

## End(Not run)
</code></pre>

<hr>
<h2 id='semPower.powerPath'>semPower.powerPath</h2><span id='topic+semPower.powerPath'></span>

<h3>Description</h3>

<p>Convenience function for performing power analyses for hypothesis arising
in a generic path model.
This requires the lavaan package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semPower.powerPath(
  type,
  comparison = "restricted",
  Beta,
  Psi = NULL,
  nullEffect = "beta = 0",
  nullWhich = NULL,
  nullWhichGroups = NULL,
  standardized = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semPower.powerPath_+3A_type">type</code></td>
<td>
<p>type of power analysis, one of <code>'a-priori'</code>, <code>'post-hoc'</code>, <code>'compromise'</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerPath_+3A_comparison">comparison</code></td>
<td>
<p>comparison model, one of <code>'saturated'</code> or <code>'restricted'</code> (the default). This determines the df for power analyses. <code>'saturated'</code> provides power to reject the model when compared to the saturated model, so the df equal the one of the hypothesized model. <code>'restricted'</code> provides power to reject the hypothesized model when compared to an otherwise identical model that just omits the restrictions defined in <code>nullEffect</code>, so the df equal the number of restrictions.</p>
</td></tr>
<tr><td><code id="semPower.powerPath_+3A_beta">Beta</code></td>
<td>
<p>matrix of regression slopes between latent variables (all-Y notation). A list for multiple group models. Exogenous variables must occupy the first rows in <code>Beta</code> when <code>standardized = TRUE</code>. See details.</p>
</td></tr>
<tr><td><code id="semPower.powerPath_+3A_psi">Psi</code></td>
<td>
<p>variance-covariance matrix of latent (residual) factors. If <code>standardized = TRUE</code>, the diagonal is ignored and all off-diagonal elements are treated as correlations. If <code>NULL</code>, an identity matrix is assumed. A list for multiple group models. See details.</p>
</td></tr>
<tr><td><code id="semPower.powerPath_+3A_nulleffect">nullEffect</code></td>
<td>
<p>defines the hypothesis of interest, must be one of <code>'beta = 0'</code> (the default) to test whether a regression slope is zero, <code>'betaX = betaZ'</code> to test for the equality of slopes, and <code>'betaX = betaZ'</code> to test for the equality of a slope across groups. Define the slopes to be set to equality in <code>nullWhich</code> and the groups in <code>nullWhichGroups</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerPath_+3A_nullwhich">nullWhich</code></td>
<td>
<p>vector of size 2 indicating which slope in <code>Beta</code> is hypothesized to equal zero when <code>nullEffect = 'beta = 0'</code>, or to restrict to equality across groups when <code>nullEffect = 'betaA = betaB'</code>, or list of vectors defining which correlations to restrict to equality when <code>nullEffect = 'betaX = betaZ'</code>. Can also contain more than two slopes, e.g., <code>list(c(2, 1), c(3, 1), c(3, 2))</code> to set <code>Beta[2, 1] = Beta[3, 1] = Beta[3, 2]</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerPath_+3A_nullwhichgroups">nullWhichGroups</code></td>
<td>
<p>for <code>nullEffect = 'betaA = betaB'</code>, vector indicating the groups for which equality constrains should be applied, e.g. <code>c(1, 3)</code> to constrain the relevant parameters of the first and the third group. If <code>NULL</code>, all groups are constrained to equality.</p>
</td></tr>
<tr><td><code id="semPower.powerPath_+3A_standardized">standardized</code></td>
<td>
<p>whether all parameters should be standardized (<code>TRUE</code>, the default). If <code>FALSE</code>, all regression relations are unstandardized.</p>
</td></tr>
<tr><td><code id="semPower.powerPath_+3A_...">...</code></td>
<td>
<p>mandatory further parameters related to the specific type of power analysis requested, see <code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code>, <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code>, and <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>, and parameters specifying the factor model. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a power analysis to reject a hypothesis arising
in a generic structural equation model specifying regression relations between the factors via the Beta matrix:
</p>

<ul>
<li> <p><code>nullEffect = 'beta = 0'</code>: Tests the hypothesis that a slope is zero.
</p>
</li>
<li> <p><code>nullEffect = 'betaX = betaZ'</code>: Tests the hypothesis that two or more slopes are equal to each other.
</p>
</li>
<li> <p><code>nullEffect = 'betaA = betaB'</code>: Tests the hypothesis that a slope is equal in two or more groups (always assuming metric invariance).
</p>
</li></ul>

<p>This function provides a generic way to perform power analyses (as compared to other functions covering special cases in a more accessible manner).
</p>
<p>A specific hypothesis is defined by setting <code>nullEffect</code> to define the hypothesis type,
<code>nullWhich</code> to define the slope(s) that are targeted, and by providing
the <code>Beta</code> (and optionally the <code>Psi</code>) matrix to define the population structure.
</p>
<p>To understand the structure of <code>Beta</code> and <code>Psi</code>, consider the general structural equation model,
</p>
<p style="text-align: center;"><code class="reqn">\Sigma = \Lambda (I - B)^{-1} \Psi [(I - B)^{-1}]'  \Lambda' + \Theta </code>
</p>

<p>where <code class="reqn">B</code> is the <code class="reqn">m \cdot m</code> matrix containing the regression slopes and <code class="reqn">\Psi</code> is the (residual) variance-covariance matrix of the <code class="reqn">m</code> factors.
</p>
<p>As an example, suppose there are four factors (X1, X2, X3, X4), and Beta is defined as follows:
</p>
<p><code class="reqn">
\begin{array}{lrrrr} 
    &amp; X_1 &amp; X_2 &amp; X_3 &amp; X_4\\ 
X_1 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 \\ 
X_2 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0  \\ 
X_3 &amp; 0.2 &amp; 0.3 &amp; 0.0 &amp; 0.0  \\ 
X_4 &amp; 0.3 &amp; 0.5 &amp; 0.0 &amp; 0.0  \\ 
\end{array}
</code>
</p>
<p>Each row specifies how a particular factor is predicted by the available factors,
so the above implies the following regression relations:
</p>
<p><code class="reqn">
X_1 = 0.0 \cdot X_1 +  0.0 \cdot X_2 + 0.0 \cdot X_3 + 0.0 \cdot X_4 \\
X_2 = 0.0 \cdot X_1 +  0.0 \cdot X_2 + 0.0 \cdot X_3 + 0.0 \cdot X_4 \\
X_3 = 0.2 \cdot X_1 +  0.3 \cdot X_2 + 0.0 \cdot X_3 + 0.0 \cdot X_4 \\
X_4 = 0.3 \cdot X_1 +  0.5 \cdot X_2 + 0.0 \cdot X_3 + 0.0 \cdot X_4 
</code>
</p>
<p>which simplifies to
</p>
<p><code class="reqn">
X_3 = 0.2 \cdot X_1 + 0.3 \cdot X_2 \\
X_4 = 0.3 \cdot X_1 + 0.5 \cdot X_2 
</code>
</p>
<p>Further suppose that Psi is
</p>
<p><code class="reqn">
\begin{array}{lrrrr} 
    &amp; X_1 &amp; X_2 &amp; X_3 &amp; X_4\\ 
X_1 &amp; 1.0 &amp; 0.3 &amp; 0.0 &amp; 0.0 \\ 
X_2 &amp; 0.3 &amp; 1.0 &amp; 0.0 &amp; 0.0 \\ 
X_3 &amp; 0.0 &amp; 0.0 &amp; 1.0 &amp; 0.2 \\ 
X_4 &amp; 0.0 &amp; 0.0 &amp; 0.2 &amp; 1.0 \\ 
\end{array}
</code>
</p>
<p>which implies a correlation between X1 and X2 of .3 and a residual correlation
between X3 and X4 of .2.
</p>
<p>Beyond the arguments explicitly contained in the function call, additional arguments
are required specifying the factor model and the requested type of power analysis.
</p>
<p>Additional arguments related to the <strong>definition of the factor model</strong>:
</p>

<ul>
<li> <p><code>Lambda</code>: The factor loading matrix (with the number of columns equaling the number of factors).
</p>
</li>
<li> <p><code>loadings</code>: Can be used instead of <code>Lambda</code>: Defines the primary loadings for each factor in a list structure, e. g. <code>loadings = list(c(.5, .4, .6), c(.8, .6, .6, .4))</code> defines a two factor model with three indicators loading on the first factor by .5, , 4., and .6, and four indicators loading on the second factor by .8, .6, .6, and .4.
</p>
</li>
<li> <p><code>nIndicator</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>loadM</code>. Defines the number of indicators by factor, e. g., <code>nIndicator = c(3, 4)</code> defines a two factor model with three and four indicators for the first and second factor, respectively. <code>nIndicator</code> can also be a single number to define the same number of indicators for each factor.
</p>
</li>
<li> <p><code>loadM</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>nIndicator</code>. Defines the loading either for all indicators (if a single number is provided) or separately for each factor (if a vector is provided), e. g. <code>loadM = c(.5, .6)</code> defines the loadings of the first factor to equal .5 and those of the second factor do equal .6.
</p>
</li></ul>

<p>So either <code>Lambda</code>, or <code>loadings</code>, or <code>nIndicator</code> and <code>loadM</code> always need to be defined.
</p>
<p>Additional arguments related to the requested type of <strong>power analysis</strong>:
</p>

<ul>
<li> <p><code>alpha</code>: The alpha error probability. Required for <code>type = 'a-priori'</code> and <code>type = 'post-hoc'</code>.
</p>
</li>
<li><p> Either <code>beta</code> or <code>power</code>: The beta error probability and the statistical power (1 - beta), respectively. Only for <code>type = 'a-priori'</code>.
</p>
</li>
<li> <p><code>N</code>: The sample size. Always required for <code>type = 'post-hoc'</code> and <code>type = 'compromise'</code>. For <code>type = 'a-priori'</code> and multiple group analysis, <code>N</code> is a list of group weights.
</p>
</li>
<li> <p><code>abratio</code>: The ratio of alpha to beta. Only for <code>type = 'compromise'</code>.
</p>
</li></ul>

<p>If a <strong>simulated power analysis</strong> (<code>simulatedPower = TRUE</code>) is requested, optional arguments can be provided as a list to <code>simOptions</code>:
</p>

<ul>
<li> <p><code>nReplications</code>: The targeted number of simulation runs. Defaults to 250, but larger numbers greatly improve accuracy at the expense of increased computation time.
</p>
</li>
<li> <p><code>minConvergenceRate</code>:  The minimum convergence rate required, defaults to .5. The maximum actual simulation runs are increased by a factor of 1/minConvergenceRate.
</p>
</li>
<li> <p><code>type</code>: specifies whether the data should be generated from a population assuming multivariate normality (<code>'normal'</code>; the default), or based on an approach generating non-normal data (<code>'IG'</code>, <code>'mnonr'</code>, <code>'RC'</code>, or <code>'VM'</code>).
The approaches generating non-normal data require additional arguments detailed below.
</p>
</li>
<li> <p><code>missingVars</code>: vector specifying the variables containing missing data (defaults to NULL).
</p>
</li>
<li> <p><code>missingVarProp</code>: can be used instead of <code>missingVars</code>: The proportion of variables containing missing data (defaults to zero).
</p>
</li>
<li> <p><code>missingProp</code>: The proportion of missingness for variables containing missing data (defaults to zero), either a single value or a vector giving the probabilities for each variable.
</p>
</li>
<li> <p><code>missingMechanism</code>: The missing data mechanism, one of <code>MCAR</code> (the default), <code>MAR</code>, or <code>NMAR</code>.
</p>
</li>
<li> <p><code>nCores</code>: The number of cores to use for parallel processing. Defaults to 1 (= no parallel processing). This requires the <code>doSNOW</code> package.
</p>
</li></ul>

<p><code>type = 'IG'</code> implements the independent generator approach (IG, Foldnes &amp; Olsson, 2016) approach
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors. This requires the <code>covsim</code> package.
</p>
<p><code>type = 'mnonr'</code> implements the approach suggested by Qu, Liu, &amp; Zhang (2020) and requires provision of  Mardia's multivariate skewness (<code>skewness</code>)  and kurtosis  (<code>kurtosis</code>), where
skewness must be non-negative and kurtosis must be at least 1.641 skewness + p (p + 0.774), where p is the number of variables. This requires the <code>mnonr</code> package.
</p>
<p><code>type = 'RK'</code> implements the approach suggested by Ruscio &amp; Kaczetow (2008) and requires provision of the population distributions
of each variable (<code>distributions</code>). <code>distributions</code> must be a list (if all variables shall be based on the same population distribution) or a list of lists.
Each component must specify the population distribution (e.g. <code>rchisq</code>) and additional arguments (<code>list(df = 2)</code>).
</p>
<p><code>type = 'VM'</code> implements the third-order polynomial method (Vale &amp; Maurelli, 1983)
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors.  This requires the <code>semTools</code> package.
</p>


<h3>Value</h3>

<p>a list. Use the <code>summary</code> method to obtain formatted results. Beyond the results of the power analysis and a number of effect size measures, the list contains the following components:
</p>
<table role = "presentation">
<tr><td><code>Sigma</code></td>
<td>
<p>the population covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the population mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td></tr>
<tr><td><code>SigmaHat</code></td>
<td>
<p>the H0 model implied covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code>muHat</code></td>
<td>
<p>the H0 model implied mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td></tr>
<tr><td><code>modelH0</code></td>
<td>
<p><code>lavaan</code> H0 model string.</p>
</td></tr>
<tr><td><code>modelH1</code></td>
<td>
<p><code>lavaan</code> H1 model string or <code>NULL</code> when the comparison refers to the saturated model.</p>
</td></tr>
<tr><td><code>simRes</code></td>
<td>
<p>detailed simulation results when a simulated power analysis (<code>simulatedPower = TRUE</code>) was performed.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code> <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code> <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# set up pathmodel in the form of
# f2 = .2*f1
# f3 = .3*f2
# f4 = .1*f1 + .4*f3
# obtain the required N to detect that the 
# slope f1 -&gt; f4 is &gt;= .10 
# with a power of 95% on alpha = 5%
# where f1 is measured by 3, f2 by 4, f3 by 5, and f4 by 6 indicators, 
# and all loadings are .5
Beta &lt;- matrix(c(
  c(.00, .00, .00, .00),       # f1
  c(.20, .00, .00, .00),       # f2
  c(.00, .30, .00, .00),       # f3
  c(.10, .00, .40, .00)        # f4
), byrow = TRUE, ncol = 4)
powerPath &lt;- semPower.powerPath(type = 'a-priori',
                                Beta = Beta,
                                nullWhich = c(4, 1),
                                nIndicator = c(3, 4, 5, 6), 
                                loadM = .5,
                                alpha = .05, beta = .05)
# show summary
summary(powerPath)
# optionally use lavaan to verify the model was set-up as intended
lavaan::sem(powerPath$modelH1, sample.cov = powerPath$Sigma,
sample.nobs = powerPath$requiredN, sample.cov.rescale = FALSE)
lavaan::sem(powerPath$modelH0, sample.cov = powerPath$Sigma,
sample.nobs = powerPath$requiredN, sample.cov.rescale = FALSE)

# same as above, but detect that the slope f3 -&gt; f4 is &gt;= .30 
powerPath &lt;- semPower.powerPath(type = 'a-priori',
                                Beta = Beta,
                                nullWhich = c(4, 3),
                                nIndicator = c(3, 4, 5, 6), 
                                loadM = .5,
                                alpha = .05, beta = .05)

# same as above, but detect that 
# the slope f1 -&gt; f2 (of .20) differs from the slope f2 -&gt; f3 (of .30) 
powerPath &lt;- semPower.powerPath(type = 'a-priori',
                                Beta = Beta,
                                nullEffect = 'betaX = betaZ',
                                nullWhich = list(c(2, 1), c(3, 2)),
                                nIndicator = c(3, 4, 5, 6), 
                                loadM = .5,
                                alpha = .05, beta = .05)

# same as above, but consider a multiple group model with equally sized groups, 
# and obtain the required N to detect that the slope 
# in group 1 (of .20) differs from the one in group 2 (of .40)
Beta1 &lt;- Beta2 &lt;- matrix(c(
  c(.00, .00, .00, .00),       # f1
  c(.20, .00, .00, .00),       # f2
  c(.00, .30, .00, .00),       # f3
  c(.10, .00, .40, .00)        # f4
), byrow = TRUE, ncol = 4)
Beta2[2, 1] &lt;- .40
Beta &lt;- list(Beta1, Beta2)
powerPath &lt;- semPower.powerPath(type = 'a-priori',
                                Beta = Beta,
                                nullEffect = 'betaA = betaB',
                                nullWhich = c(2, 1),
                                nIndicator = c(3, 4, 5, 6), 
                                loadM = .5,
                                alpha = .05, beta = .05, N = list(1, 1))

## End(Not run)
</code></pre>

<hr>
<h2 id='semPower.powerPlot'>semPower.powerPlot</h2><span id='topic+semPower.powerPlot'></span>

<h3>Description</h3>

<p>Shows a plot showing power as function of N given the output of a power analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semPower.powerPlot(semPowerRes, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semPower.powerPlot_+3A_sempowerres">semPowerRes</code></td>
<td>
<p>results of a semPower analysis</p>
</td></tr>
<tr><td><code id="semPower.powerPlot_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code><a href="#topic+semPower.powerPlot.byN">semPower.powerPlot.byN()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>powerplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# perform a power analysis
powerCFA &lt;- semPower.powerCFA(type = 'post-hoc', alpha = .05, N = 300,
                              Phi = .15, nIndicator = c(5, 4), loadM = c(.5, .6))
# show plot
semPower.powerPlot(powerCFA)

## End(Not run)
</code></pre>

<hr>
<h2 id='semPower.powerPlot.byEffect'>semPower.powerPlot.byEffect</h2><span id='topic+semPower.powerPlot.byEffect'></span>

<h3>Description</h3>

<p>Shows a plot showing power as function of the effect for a given N and alpha.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semPower.powerPlot.byEffect(
  effect.measure = NULL,
  alpha,
  N,
  df,
  p = NULL,
  effect.min = NULL,
  effect.max = NULL,
  steps = 50,
  linewidth = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semPower.powerPlot.byEffect_+3A_effect.measure">effect.measure</code></td>
<td>
<p>type of effect, one of <code>"F0"</code>, <code>"RMSEA"</code>, <code>"Mc"</code>, <code>"GFI"</code>, <code>"AGFI"</code></p>
</td></tr>
<tr><td><code id="semPower.powerPlot.byEffect_+3A_alpha">alpha</code></td>
<td>
<p>alpha error</p>
</td></tr>
<tr><td><code id="semPower.powerPlot.byEffect_+3A_n">N</code></td>
<td>
<p>the number of observations</p>
</td></tr>
<tr><td><code id="semPower.powerPlot.byEffect_+3A_df">df</code></td>
<td>
<p>the model degrees of freedom</p>
</td></tr>
<tr><td><code id="semPower.powerPlot.byEffect_+3A_p">p</code></td>
<td>
<p>the number of observed variables, required for <code>effect.measure = "GFI"</code> and <code>effect.measure = "AGFI"</code></p>
</td></tr>
<tr><td><code id="semPower.powerPlot.byEffect_+3A_effect.min">effect.min</code></td>
<td>
<p>minimum effect</p>
</td></tr>
<tr><td><code id="semPower.powerPlot.byEffect_+3A_effect.max">effect.max</code></td>
<td>
<p>maximum effect</p>
</td></tr>
<tr><td><code id="semPower.powerPlot.byEffect_+3A_steps">steps</code></td>
<td>
<p>number of steps</p>
</td></tr>
<tr><td><code id="semPower.powerPlot.byEffect_+3A_linewidth">linewidth</code></td>
<td>
<p>linewidth</p>
</td></tr>
</table>


<h3>Value</h3>

<p>powerplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
semPower.powerPlot.byEffect(effect.measure = "RMSEA", alpha = .05, 
                            N = 500, effect.min = .01, effect.max = .15, df = 200)

## End(Not run)
</code></pre>

<hr>
<h2 id='semPower.powerPlot.byN'>semPower.powerPlot.byN</h2><span id='topic+semPower.powerPlot.byN'></span>

<h3>Description</h3>

<p>Shows a plot showing power as function of N for a given effect and alpha.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semPower.powerPlot.byN(
  effect = NULL,
  effect.measure = NULL,
  alpha,
  df,
  p = NULL,
  SigmaHat = NULL,
  Sigma = NULL,
  power.min = alpha,
  power.max = 0.99,
  steps = 50,
  linewidth = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semPower.powerPlot.byN_+3A_effect">effect</code></td>
<td>
<p>effect size specifying the discrepancy between H0 and H1</p>
</td></tr>
<tr><td><code id="semPower.powerPlot.byN_+3A_effect.measure">effect.measure</code></td>
<td>
<p>type of effect, one of <code>"F0"</code>, <code>"RMSEA"</code>, <code>"Mc"</code>, <code>"GFI"</code>, <code>"AGFI"</code></p>
</td></tr>
<tr><td><code id="semPower.powerPlot.byN_+3A_alpha">alpha</code></td>
<td>
<p>alpha error</p>
</td></tr>
<tr><td><code id="semPower.powerPlot.byN_+3A_df">df</code></td>
<td>
<p>the model degrees of freedom</p>
</td></tr>
<tr><td><code id="semPower.powerPlot.byN_+3A_p">p</code></td>
<td>
<p>the number of observed variables, required for <code>effect.measure = "GFI"</code> and <code>effect.measure = "AGFI"</code></p>
</td></tr>
<tr><td><code id="semPower.powerPlot.byN_+3A_sigmahat">SigmaHat</code></td>
<td>
<p>model implied covariance matrix. Use in conjunction with <code style="white-space: pre;">&#8288;Sigma`` to define &#8288;</code>effect<code>and</code>effect.measure'.</p>
</td></tr>
<tr><td><code id="semPower.powerPlot.byN_+3A_sigma">Sigma</code></td>
<td>
<p>population covariance matrix. Use in conjunction with <code>SigmaHat</code> to define <code>effect</code> and <code>effect.measure</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerPlot.byN_+3A_power.min">power.min</code></td>
<td>
<p>minimum power, must not be smaller than <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerPlot.byN_+3A_power.max">power.max</code></td>
<td>
<p>maximum power</p>
</td></tr>
<tr><td><code id="semPower.powerPlot.byN_+3A_steps">steps</code></td>
<td>
<p>number of steps</p>
</td></tr>
<tr><td><code id="semPower.powerPlot.byN_+3A_linewidth">linewidth</code></td>
<td>
<p>linewidth</p>
</td></tr>
</table>


<h3>Value</h3>

<p>powerplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
semPower.powerPlot.byN(effect = .05, effect.measure = "RMSEA", 
                       alpha = .05, power.min = .05, power.max = .99, df = 200)

## End(Not run)
</code></pre>

<hr>
<h2 id='semPower.powerRegression'>semPower.powerRegression</h2><span id='topic+semPower.powerRegression'></span>

<h3>Description</h3>

<p>Convenience function for performing power analysis on slope(s) in a latent regression of the form Y = XB.
This requires the lavaan package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semPower.powerRegression(
  type,
  comparison = "restricted",
  slopes = NULL,
  corXX = NULL,
  nullEffect = "slope = 0",
  nullWhich = NULL,
  nullWhichGroups = NULL,
  standardized = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semPower.powerRegression_+3A_type">type</code></td>
<td>
<p>type of power analysis, one of <code>'a-priori'</code>, <code>'post-hoc'</code>, <code>'compromise'</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerRegression_+3A_comparison">comparison</code></td>
<td>
<p>comparison model, one of <code>'saturated'</code> or <code>'restricted'</code> (the default). This determines the df for power analyses. <code>'saturated'</code> provides power to reject the model when compared to the saturated model, so the df equal the one of the hypothesized model. <code>'restricted'</code> provides power to reject the hypothesized model when compared to an otherwise identical model that just omits the restrictions defined in <code>nullEffect</code>, so the df equal the number of restrictions.</p>
</td></tr>
<tr><td><code id="semPower.powerRegression_+3A_slopes">slopes</code></td>
<td>
<p>vector of slopes (or a single number for a single slope) of the k predictors for Y. A list of slopes for multigroup models.</p>
</td></tr>
<tr><td><code id="semPower.powerRegression_+3A_corxx">corXX</code></td>
<td>
<p>correlation(s) between the k predictors (X). Either <code>NULL</code> for uncorrelated predictors, a single number (for k = 2 predictors), or a matrix. Can also be a list for multigroup models providing the correlations by group of matrices (otherwise, the same correlations are used in all groups).</p>
</td></tr>
<tr><td><code id="semPower.powerRegression_+3A_nulleffect">nullEffect</code></td>
<td>
<p>defines the hypothesis of interest, must be one of <code>'slope = 0'</code> (the default) to test whether a slope is zero, <code>'slopeX = slopeZ'</code> to test for the equality of slopes, or <code>'slopeA = slopeB'</code> to test for the equality of slopes across groups. Define the slopes to set to equality in <code>nullWhich</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerRegression_+3A_nullwhich">nullWhich</code></td>
<td>
<p>single number indicating which slope is hypothesized to equal zero when <code>nullEffect = 'slope = 0'</code>, or indicating which slope to restrict to equality across groups when <code>nullEffect = 'slopeA = slopeB'</code>, or vector defining the slopes to restrict to equality when <code>nullEffect = 'slopeX = slopeZ'</code>. Can also contain more than two slopes, e.g. <code>c(1, 2, 3)</code> to constrain the first three slopes to equality.</p>
</td></tr>
<tr><td><code id="semPower.powerRegression_+3A_nullwhichgroups">nullWhichGroups</code></td>
<td>
<p>for <code>nullEffect = 'slopeA = slopeB'</code>, vector indicating the groups for which equality constrains should be applied, e.g. <code>c(1, 3)</code> to constrain the relevant parameters of the first and the third group. If <code>NULL</code>, all groups are constrained to equality.</p>
</td></tr>
<tr><td><code id="semPower.powerRegression_+3A_standardized">standardized</code></td>
<td>
<p>whether all parameters should be standardized (<code>TRUE</code>, the default). If <code>FALSE</code>, all regression relations are unstandardized.</p>
</td></tr>
<tr><td><code id="semPower.powerRegression_+3A_...">...</code></td>
<td>
<p>mandatory further parameters related to the specific type of power analysis requested, see <code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code>, <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code>, and <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>, and parameters specifying the factor model. The first factor is treated as Y and the subsequent factors as the predictors X_k. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a power analysis to reject various hypotheses arising
in SEM models involving a simple regression relation of the form <code>Y = b_1*X_1 + ... + b_k*X_k</code> between the factors:
</p>

<ul>
<li> <p><code>nullEffect = 'slope = 0'</code>: Tests the hypothesis that the slope for a predictor is zero.
</p>
</li>
<li> <p><code>nullEffect = 'slopeX = slopeZ'</code>: Tests the hypothesis that two or more slopes are equal to each other.
</p>
</li>
<li> <p><code>nullEffect = 'slopeA = slopeB'</code>: Tests the hypothesis that the slope for a predictor is equal in two or more groups (always assuming metric invariance).
</p>
</li></ul>

<p>For hypotheses regarding mediation effects, see <code><a href="#topic+semPower.powerMediation">semPower.powerMediation()</a></code>. For hypothesis in autoregressive models, see  <code><a href="#topic+semPower.powerAutoreg">semPower.powerAutoreg()</a></code>.
</p>
<p>Beyond the arguments explicitly contained in the function call, additional arguments
are required specifying the factor model and the requested type of power analysis.
</p>
<p>Additional arguments related to the <strong>definition of the factor model</strong>:
</p>

<ul>
<li> <p><code>Lambda</code>: The factor loading matrix (with the number of columns equaling the number of factors).
</p>
</li>
<li> <p><code>loadings</code>: Can be used instead of <code>Lambda</code>: Defines the primary loadings for each factor in a list structure, e. g. <code>loadings = list(c(.5, .4, .6), c(.8, .6, .6, .4))</code> defines a two factor model with three indicators loading on the first factor by .5, , 4., and .6, and four indicators loading on the second factor by .8, .6, .6, and .4.
</p>
</li>
<li> <p><code>nIndicator</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>loadM</code>. Defines the number of indicators by factor, e. g., <code>nIndicator = c(3, 4)</code> defines a two factor model with three and four indicators for the first and second factor, respectively. <code>nIndicator</code> can also be a single number to define the same number of indicators for each factor.
</p>
</li>
<li> <p><code>loadM</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>nIndicator</code>. Defines the loading either for all indicators (if a single number is provided) or separately for each factor (if a vector is provided), e. g. <code>loadM = c(.5, .6)</code> defines the loadings of the first factor to equal .5 and those of the second factor do equal .6.
</p>
</li></ul>

<p>So either <code>Lambda</code>, or <code>loadings</code>, or <code>nIndicator</code> and <code>loadM</code> need to be defined.
If the model contains observed variables only, use <code>Lambda = diag(x)</code> where <code>x</code> is the number of variables.
</p>
<p>Note that the first factor acts as the criterion Y, the subsequent factors as predictors X_1 to X_k.
</p>
<p>Additional arguments related to the requested type of <strong>power analysis</strong>:
</p>

<ul>
<li> <p><code>alpha</code>: The alpha error probability. Required for <code>type = 'a-priori'</code> and <code>type = 'post-hoc'</code>.
</p>
</li>
<li><p> Either <code>beta</code> or <code>power</code>: The beta error probability and the statistical power (1 - beta), respectively. Only for <code>type = 'a-priori'</code>.
</p>
</li>
<li> <p><code>N</code>: The sample size. Always required for <code>type = 'post-hoc'</code> and <code>type = 'compromise'</code>. For <code>type = 'a-priori'</code> and multiple group analysis, <code>N</code> is a list of group weights.
</p>
</li>
<li> <p><code>abratio</code>: The ratio of alpha to beta. Only for <code>type = 'compromise'</code>.
</p>
</li></ul>

<p>If a <strong>simulated power analysis</strong> (<code>simulatedPower = TRUE</code>) is requested, optional arguments can be provided as a list to <code>simOptions</code>:
</p>

<ul>
<li> <p><code>nReplications</code>: The targeted number of simulation runs. Defaults to 250, but larger numbers greatly improve accuracy at the expense of increased computation time.
</p>
</li>
<li> <p><code>minConvergenceRate</code>:  The minimum convergence rate required, defaults to .5. The maximum actual simulation runs are increased by a factor of 1/minConvergenceRate.
</p>
</li>
<li> <p><code>type</code>: specifies whether the data should be generated from a population assuming multivariate normality (<code>'normal'</code>; the default), or based on an approach generating non-normal data (<code>'IG'</code>, <code>'mnonr'</code>, <code>'RC'</code>, or <code>'VM'</code>).
The approaches generating non-normal data require additional arguments detailed below.
</p>
</li>
<li> <p><code>missingVars</code>: vector specifying the variables containing missing data (defaults to NULL).
</p>
</li>
<li> <p><code>missingVarProp</code>: can be used instead of <code>missingVars</code>: The proportion of variables containing missing data (defaults to zero).
</p>
</li>
<li> <p><code>missingProp</code>: The proportion of missingness for variables containing missing data (defaults to zero), either a single value or a vector giving the probabilities for each variable.
</p>
</li>
<li> <p><code>missingMechanism</code>: The missing data mechanism, one of <code>MCAR</code> (the default), <code>MAR</code>, or <code>NMAR</code>.
</p>
</li>
<li> <p><code>nCores</code>: The number of cores to use for parallel processing. Defaults to 1 (= no parallel processing). This requires the <code>doSNOW</code> package.
</p>
</li></ul>

<p><code>type = 'IG'</code> implements the independent generator approach (IG, Foldnes &amp; Olsson, 2016) approach
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors. This requires the <code>covsim</code> package.
</p>
<p><code>type = 'mnonr'</code> implements the approach suggested by Qu, Liu, &amp; Zhang (2020) and requires provision of  Mardia's multivariate skewness (<code>skewness</code>)  and kurtosis  (<code>kurtosis</code>), where
skewness must be non-negative and kurtosis must be at least 1.641 skewness + p (p + 0.774), where p is the number of variables. This requires the <code>mnonr</code> package.
</p>
<p><code>type = 'RK'</code> implements the approach suggested by Ruscio &amp; Kaczetow (2008) and requires provision of the population distributions
of each variable (<code>distributions</code>). <code>distributions</code> must be a list (if all variables shall be based on the same population distribution) or a list of lists.
Each component must specify the population distribution (e.g. <code>rchisq</code>) and additional arguments (<code>list(df = 2)</code>).
</p>
<p><code>type = 'VM'</code> implements the third-order polynomial method (Vale &amp; Maurelli, 1983)
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors.  This requires the <code>semTools</code> package.
</p>


<h3>Value</h3>

<p>a list. Use the <code>summary</code> method to obtain formatted results. Beyond the results of the power analysis and a number of effect size measures, the list contains the following components:
</p>
<table role = "presentation">
<tr><td><code>Sigma</code></td>
<td>
<p>the population covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the population mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td></tr>
<tr><td><code>SigmaHat</code></td>
<td>
<p>the H0 model implied covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code>muHat</code></td>
<td>
<p>the H0 model implied mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td></tr>
<tr><td><code>modelH0</code></td>
<td>
<p><code>lavaan</code> H0 model string.</p>
</td></tr>
<tr><td><code>modelH1</code></td>
<td>
<p><code>lavaan</code> H1 model string or <code>NULL</code> when the comparison refers to the saturated model.</p>
</td></tr>
<tr><td><code>simRes</code></td>
<td>
<p>detailed simulation results when a simulated power analysis (<code>simulatedPower = TRUE</code>) was performed.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+semPower.genSigma">semPower.genSigma()</a></code> <code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code> <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code> <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# latent regression of the form `Y = .2*X1 + .3*X2`, where X1 and X2 correlate by .4
# obtain required N to reject the hypothesis that the slope of X1 is zero 
# with a power of 95% on alpha = 5%,   
# where Y is measured by 3 indicators loading by .5 each,
# X1 by 5 indicators loading by .6 each, and
# X2 by 4 indicators loading by .7 each. 
powerReg &lt;- semPower.powerRegression(type = 'a-priori',
                                     slopes = c(.2, .3), corXX = .4, 
                                     nullWhich = 1, 
                                     nIndicator = c(3, 5, 4), 
                                     loadM = c(.5, .6, .7),
                                     alpha = .05, beta = .05)
# show summary
summary(powerReg)
# optionally use lavaan to verify the model was set-up as intended
lavaan::sem(powerReg$modelH1, sample.cov = powerReg$Sigma, 
sample.nobs = powerReg$requiredN, sample.cov.rescale = FALSE)
lavaan::sem(powerReg$modelH0, sample.cov = powerReg$Sigma, 
sample.nobs = powerReg$requiredN, sample.cov.rescale = FALSE)

# same as above, but determine power with N = 500 on alpha = .05 
powerReg &lt;- semPower.powerRegression(type = 'post-hoc',
                                     slopes = c(.2, .3), corXX = .4, 
                                     nullWhich = 1, 
                                     nIndicator = c(3, 5, 4), 
                                     loadM = c(.5, .6, .7),
                                     alpha = .05, N = 500)
                                     
# same as above, but determine the critical chi-square with N = 500 so that alpha = beta 
powerReg &lt;- semPower.powerRegression(type = 'compromise',
                                     slopes = c(.2, .3), corXX = .4, 
                                     nullWhich = 1, 
                                     nIndicator = c(3, 5, 4), 
                                     loadM = c(.5, .6, .7),
                                     abratio = .05, N = 500)
                                     
# same as above, but ask for the required N to detect that the slope of X2 is zero
powerReg &lt;- semPower.powerRegression(type = 'a-priori',
                                     slopes = c(.2, .3), corXX = .4, 
                                     nullWhich = 2, 
                                     nIndicator = c(3, 5, 4), 
                                     loadM = c(.5, .6, .7),
                                     alpha = .05, beta = .05)

# same as above, but define unstandardized slopes
powerReg &lt;- semPower.powerRegression(type = 'a-priori',
                                     slopes = c(.2, .3), corXX = .4,
                                     nullWhich = 2, 
                                     standardized = FALSE,
                                     nIndicator = c(3, 5, 4), 
                                     loadM = c(.5, .6, .7),
                                     alpha = .05, beta = .05)
                                     
# same as above, but compare to the saturated model
# (rather than to the less restricted model)
powerReg &lt;- semPower.powerRegression(type = 'a-priori', 
                                     comparison = 'saturated',
                                     slopes = c(.2, .3), corXX = .4, 
                                     nullWhich = 2, 
                                     nIndicator = c(3, 5, 4), 
                                     loadM = c(.5, .6, .7),
                                     alpha = .05, beta = .05)
                                     
# same as above, but provide a reduced loading matrix defining
# three indicators with loadings of .7, .6, .5 on the first factor (Y),
# four indicators with loadings of .5, .6, .4, .8 on the second factor (X1), and
# three indicators with loadings of .8, .7, .8 on the third factor (X2).
powerReg &lt;- semPower.powerRegression(type = 'a-priori',
                                     slopes = c(.2, .3), corXX = .4, 
                                     nullWhich = 2, 
                                     loadings = list(
                                       c(.7, .6, .5), 
                                       c(.5, .6, .4, .8),
                                       c(.8, .7, .8)),
                                     alpha = .05, beta = .05)
                              
# latent regression of the form `Y = .2*X1 + .3*X2 + .4*X3`, 
# providing the predictor intercorrelation matrix,
# and ask for the required N to detect that the first slope differs from zero.
corXX &lt;- matrix(c(
  #   X1    X2    X3
  c(1.00, 0.20, 0.30),  # X1
  c(0.20, 1.00, 0.10),  # X2
  c(0.30, 0.10, 1.00)   # X3
), ncol = 3,byrow = TRUE)
powerReg &lt;- semPower.powerRegression(type = 'a-priori',
                                     slopes = c(.2, .3, .4), corXX = corXX, 
                                     nullWhich = 1,
                                     nIndicator = c(4, 3, 5, 4),
                                     loadM = c(.5, .5, .6, .7),
                                     alpha = .05, beta = .05)

# same as above, but ask for the required N to detect that 
# the slope for X1 (b = .2) and the slope for X2 (b = .3) differ from each other
powerReg &lt;- semPower.powerRegression(type = 'a-priori',
                                     slopes = c(.2, .3, .4), corXX = corXX, 
                                     nullEffect = 'slopeX = slopeZ', 
                                     nullWhich = c(1, 2),
                                     nIndicator = c(4, 3, 5, 4),
                                     loadM = c(.5, .5, .6, .7),
                                     alpha = .05, beta = .05)
                                     
# same as above, but ask for the required N to reject the hypothesis that 
# all three slopes are equal to each other
powerReg &lt;- semPower.powerRegression(type = 'a-priori',
                                     slopes = c(.2, .3, .4), corXX = corXX, 
                                     nullEffect = 'slopeX = slopeZ', 
                                     nullWhich = c(1, 2, 3),
                                     nIndicator = c(4, 3, 5, 4),
                                     loadM = c(.5, .5, .6, .7),
                                     alpha = .05, beta = .05)
    
# get required N to detect that 
# the slope for X2 group 1 (of b2 = .3) differs from the slope for X2 in group 2 (of b = .0). 
# The remaining slopes are equal in both groups (b1 = .2, b3 = .4).
# The measurement model is identical in both groups:
# The criterion (Y) is measured by 4 indicators loading by .5 each, 
# Predictors X1 and X3 are both measured by 5 indicators loading by .6 each,
# Predictor X2 is measured by 3 indicators loading by .7 each.
# Both groups are sized equally (N = list(1, 1)).
powerReg &lt;- semPower.powerRegression(type = 'a-priori',
                                     slopes = list(c(.2, .3, .4), 
                                     c(.2, .0, .4)), 
                                     corXX = corXX, 
                                     nullEffect = 'slopeA = slopeB', 
                                     nullWhich = 2,
                                     nIndicator = c(4, 5, 3, 5),
                                     loadM = c(.5, .6, .7, .6),
                                     alpha = .05, beta = .05, 
                                     N = list(1, 1))

# request a simulated post-hoc power analysis with 500 replications 
# to detect that the slope of X1 differs from zero.
set.seed(300121)
powerReg &lt;- semPower.powerRegression(type = 'post-hoc',
                                     slopes = c(.2, .1), 
                                     nullWhich = 1,
                                     nIndicator = c(4, 3, 3), loadM = .5,
                                     alpha = .05, N = 500, 
                                     simulatedPower = TRUE, 
                                     simOptions = list(nReplications = 500))

## End(Not run)
</code></pre>

<hr>
<h2 id='semPower.powerRICLPM'>semPower.powerRICLPM</h2><span id='topic+semPower.powerRICLPM'></span>

<h3>Description</h3>

<p>Convenience function for performing power analysis on effects in a random intercept cross-lagged panel model (RI-CLPM).
This requires the lavaan package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semPower.powerRICLPM(
  type,
  comparison = "restricted",
  nWaves = NULL,
  autoregEffects = NULL,
  crossedEffects = NULL,
  rXY = NULL,
  rBXBY = NULL,
  waveEqual = NULL,
  nullEffect = NULL,
  nullWhichGroups = NULL,
  nullWhich = NULL,
  standardized = TRUE,
  metricInvariance = TRUE,
  autocorResiduals = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semPower.powerRICLPM_+3A_type">type</code></td>
<td>
<p>type of power analysis, one of <code>'a-priori'</code>, <code>'post-hoc'</code>, <code>'compromise'</code>.</p>
</td></tr>
<tr><td><code id="semPower.powerRICLPM_+3A_comparison">comparison</code></td>
<td>
<p>comparison model, one of <code>'saturated'</code> or <code>'restricted'</code> (the default). This determines the df for power analyses. <code>'saturated'</code> provides power to reject the model when compared to the saturated model, so the df equal the one of the hypothesized model. <code>'restricted'</code> provides power to reject the hypothesized model when compared to an otherwise identical model that just omits the restrictions defined in <code>nullEffect</code>, so the df equal the number of restrictions.</p>
</td></tr>
<tr><td><code id="semPower.powerRICLPM_+3A_nwaves">nWaves</code></td>
<td>
<p>number of waves, must be &gt;= 3.</p>
</td></tr>
<tr><td><code id="semPower.powerRICLPM_+3A_autoregeffects">autoregEffects</code></td>
<td>
<p>vector of the autoregressive effects of X and Y (constant across waves), or a list of vectors of autoregressive effects for X and Y from wave to wave, e.g. <code>list(c(.7, .6), c(.5, .5))</code> for an autoregressive effect of .7 for X1-&gt;X2 and .6 for X2-&gt;X3 and autoregressive effects of .5 for Y1-&gt;Y2 and Y2-&gt;Y3. Must be a list of lists for multiple groups models. If the list structure is omitted, no group differences are assumed.</p>
</td></tr>
<tr><td><code id="semPower.powerRICLPM_+3A_crossedeffects">crossedEffects</code></td>
<td>
<p>vector of crossed effects of X on Y (X -&gt; Y) and vice versa (both constant across waves), or a list of vectors of crossed effects giving the crossed effect of X on Y (and vice versa) for each wave, e.g. <code>list(c(.2, .3), c(.1, .1))</code> for X1-&gt;Y2 = .2, X2-&gt;Y3 = .3, Y1-&gt;Y2 = .1, and Y2-&gt;Y3 = .1. Must be a list of lists for multiple groups models. If the list structure is omitted, no group differences are assumed.</p>
</td></tr>
<tr><td><code id="semPower.powerRICLPM_+3A_rxy">rXY</code></td>
<td>
<p>vector of (residual-)correlations between X and Y for each wave. If <code>NULL</code>, all (residual-)correlations are zero.  Can be a list for multiple groups models, otherwise no group differences are assumed.</p>
</td></tr>
<tr><td><code id="semPower.powerRICLPM_+3A_rbxby">rBXBY</code></td>
<td>
<p>correlation between random intercept factors. If <code>NULL</code>, the correlation is zero. Must be a list of lists for multiple groups models. If the list structure is omitted, no group differences are assumed.</p>
</td></tr>
<tr><td><code id="semPower.powerRICLPM_+3A_waveequal">waveEqual</code></td>
<td>
<p>parameters that are assumed to be equal across waves in both the H0 and the H1 model. Valid are <code>'autoregX'</code> and <code>'autoregY'</code> for autoregressive effects, <code>'crossedX'</code> and <code>'crossedY'</code> for crossed effects, <code>'corXY'</code> for residual correlations, or <code>NULL</code> for none (so that all parameters are freely estimated, subject to the constraints defined in <code>nullEffect</code>).</p>
</td></tr>
<tr><td><code id="semPower.powerRICLPM_+3A_nulleffect">nullEffect</code></td>
<td>
<p>defines the hypothesis of interest. Valid are the same arguments as in <code>waveEqual</code> and additionally <code>'autoregX = 0'</code>, <code>'autoregY = 0'</code>, <code>'crossedX = 0'</code>, <code>'crossedY = 0'</code> to constrain the X or Y autoregressive effects or the crossed effects to zero, <code>'corBXBY = 0'</code> to constrain the correlation between the random intercepts to zero, and <code>'autoregX = autoregY'</code> and <code>'crossedX = crossedY'</code> to constrain them to be equal for X and Y, and <code>'autoregXA = autoregXB'</code>, <code>'autoregYA = autoregYB'</code>, <code>'crossedXA = crossedXB'</code>, <code>'crossedYA = crossedYB'</code>, and <code>corBXBYA = corBXBYB</code> to constrain them to be equal across groups.</p>
</td></tr>
<tr><td><code id="semPower.powerRICLPM_+3A_nullwhichgroups">nullWhichGroups</code></td>
<td>
<p>for hypothesis involving cross-groups comparisons, vector indicating the groups for which equality constrains should be applied, e.g. <code>c(1, 3)</code> to constrain the relevant parameters of the first and the third group. If <code>NULL</code>, all groups are constrained to equality.</p>
</td></tr>
<tr><td><code id="semPower.powerRICLPM_+3A_nullwhich">nullWhich</code></td>
<td>
<p>used in conjunction with <code>nullEffect</code> to identify which parameter to constrain when there are &gt; 2 waves and parameters are not constant across waves. For example, <code>nullEffect = 'autoregX = 0'</code> with <code>nullWhich = 2</code> would constrain the second autoregressive effect for X to zero.</p>
</td></tr>
<tr><td><code id="semPower.powerRICLPM_+3A_standardized">standardized</code></td>
<td>
<p>whether the autoregressive and cross-lagged parameters should be treated as standardized (<code>TRUE</code>, the default), implying that unstandardized and standardized regression relations have the same value. If <code>FALSE</code>, all regression relations are unstandardized.</p>
</td></tr>
<tr><td><code id="semPower.powerRICLPM_+3A_metricinvariance">metricInvariance</code></td>
<td>
<p>whether metric invariance over waves is assumed (<code>TRUE</code>, the default) or not (<code>FALSE</code>). This affects the df when the comparison model is the saturated model and generally affects power (also for comparisons to the restricted model, where the df are not affected by invariance constraints).</p>
</td></tr>
<tr><td><code id="semPower.powerRICLPM_+3A_autocorresiduals">autocorResiduals</code></td>
<td>
<p>whether the residuals of the indicators of latent variables are autocorrelated over waves (<code>TRUE</code>, the default) or not (<code>FALSE</code>). This affects the df when the comparison model is the saturated model and generally affects power (also for comparisons to the restricted model).</p>
</td></tr>
<tr><td><code id="semPower.powerRICLPM_+3A_...">...</code></td>
<td>
<p>mandatory further parameters related to the specific type of power analysis requested, see <code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code>, <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code>, and <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>, and parameters specifying the factor model. The order of factors is (X1, Y1, X2, Y2, ..., X_nWaves, Y_nWaves). See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a power analysis to reject various hypotheses arising in a random intercept crossed-lagged panel model (RI-CLPM).
In a standard RI-CLPM implemented here, two variables X and Y are repeatedly assessed at three or more different time points (<code>nWaves</code>),
yielding autoregressive effects (<code>X1 -&gt; X2</code>, <code>X2 -&gt; X3</code>, <code>Y1 -&gt; Y2</code>, <code>Y2 -&gt; Y3</code>), synchronous effects (<code style="white-space: pre;">&#8288;X1 &lt;-&gt; Y1&#8288;</code>, <code style="white-space: pre;">&#8288;X2 &lt;-&gt; Y2&#8288;</code>, <code style="white-space: pre;">&#8288;X3 &lt;-&gt; Y3&#8288;</code>), and cross-lagged effects (<code>X1 -&gt; Y2</code>, <code>X2 -&gt; Y3</code>, <code>Y1 -&gt; X2</code>, <code>Y2 -&gt; X3</code>).
RI-CLPMs are typically implemented assuming that the parameters are constant across waves (<code>waveEqual</code>), and usually omit lag-2 effects (e.g., <code>X1 -&gt; Y3</code>).
RI-CLPMs based on latent factors usually assume at least metric invariance of the factors over waves (<code>metricInvariance</code>).
</p>
<p>Relevant hypotheses in arising in a RI-CLPM are:
</p>

<ul>
<li> <p><code>autoregX = 0</code> and <code>autoregY = 0</code>: Tests the hypothesis that the autoregressive effect of X and Y, respectively, is zero.
</p>
</li>
<li> <p><code>crossedX = 0</code> and <code>crossedY = 0</code>: Tests the hypothesis that the crossed effect of X on Y (<code>crossedX</code>) and Y on X (<code>crossedY</code>), respectively, is zero.
</p>
</li>
<li> <p><code>autoregX = autoregY</code>: Tests the hypothesis that the autoregressive effect of X and Y are equal.
</p>
</li>
<li> <p><code>crossedX = crossedY</code>: Tests the hypothesis that the crossed effect of X on Y (<code>crossedX</code>) and Y on X (<code>crossedY</code>) are equal.
</p>
</li>
<li> <p><code>autoregX</code> and <code>autoregY</code>: Tests the hypothesis that the autoregressive effect of X and Y, respectively, is equal across waves.
</p>
</li>
<li> <p><code>crossedX</code> and <code>crossedY</code>: Tests the hypothesis that the crossed effect of X on Y (<code>crossedX</code>) and Y on X (<code>crossedY</code>), respectively, is equal across waves.
</p>
</li>
<li> <p><code>corXY</code>: Tests the hypothesis that the (residual-)correlations between X and Y are equal across waves.
</p>
</li>
<li> <p><code>corBXBY = 0</code>: Tests the hypothesis that the correlation between the random intercept factors of X and Y is zero.
</p>
</li>
<li> <p><code>autoregXA = autoregXB</code> and <code>autoregYA = autoregYB</code>: Tests the hypothesis that the autoregressive effect of either X or Y are equal across groups.
</p>
</li>
<li> <p><code>crossedXA = crossedXB</code> and <code>crossedYA = crossedYB</code>: Tests the hypothesis that the crossed effect of X on Y (<code>crossedX</code>) or of Y on X (<code>crossedY</code>), respectively, is equal across groups.
</p>
</li>
<li> <p><code>corBXBYA = corBXBYB</code>: Tests the hypothesis that the correlation between the random intercept factors is equal across groups.
</p>
</li></ul>

<p>For hypotheses regarding the traditional CLPM, see <code><a href="#topic+semPower.powerCLPM">semPower.powerCLPM()</a></code>.
</p>
<p>Beyond the arguments explicitly contained in the function call, additional arguments
are required specifying the factor model and the requested type of power analysis.
</p>
<p>Additional arguments related to the <strong>definition of the factor model</strong>:
</p>

<ul>
<li> <p><code>Lambda</code>: The factor loading matrix (with the number of columns equaling 2 times the number of waves). Columns should be in order X1, Y1, X2, Y2, ..., X_nWaves, Y_nWaves.
</p>
</li>
<li> <p><code>loadings</code>: Can be used instead of <code>Lambda</code>: Defines the primary loadings for each factor in a list structure ordered by wave, e.g., list(c(.2, .2, .2), c(.4, .4, .4, .4), c(.2, .2, .2), c(.4, .4, .4, .4), c(.2, .2, .2), c(.4, .4, .4, .4)) defines loadings of .2 for the three indicators of X at waves 1-3 and loadings of .4 for the four indicators of Y at waves 1-3. Must not contain secondary loadings.
</p>
</li>
<li> <p><code>nIndicator</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>loadM</code>. Defines the number of indicators for each factor ordered by wave, e.g. c(3, 4, 3, 4, 3, 4) defines three indicators for X at waves 1-3 and four indicators for Y at waves 1-3.
</p>
</li>
<li> <p><code>loadM</code>: Can be used instead of <code>Lambda</code>: Used in conjunction with <code>nIndicator</code>. Defines the loading either for all indicators (if a single number is provided) or separately for each factor at each wave (if a vector is provided), e. g. <code>loadM = c(.5, .6, .5, .6, .5, .6)</code> defines mean loadings of .5 for X at waves 1-3 and mean loadings of .6 for Y at waves 1-3.
</p>
</li></ul>

<p>So either <code>Lambda</code>, or <code>loadings</code>, or <code>nIndicator</code> and <code>loadM</code> need to be defined.
If the model contains observed variables only, use <code>Lambda = diag(x)</code> where <code>x</code> is the number of variables.
</p>
<p>Note that the order of the factors is (X1, Y1, X2, Y2, ..., X_nWaves, Y_nWaves), i. e., the first factor is treated as the first measurement of X, the second as the first measurement of Y, the third as the second measurement of X, etc..
</p>
<p>Additional arguments related to the requested type of <strong>power analysis</strong>:
</p>

<ul>
<li> <p><code>alpha</code>: The alpha error probability. Required for <code>type = 'a-priori'</code> and <code>type = 'post-hoc'</code>.
</p>
</li>
<li><p> Either <code>beta</code> or <code>power</code>: The beta error probability and the statistical power (1 - beta), respectively. Only for <code>type = 'a-priori'</code>.
</p>
</li>
<li> <p><code>N</code>: The sample size. Always required for <code>type = 'post-hoc'</code> and <code>type = 'compromise'</code>. For <code>type = 'a-priori'</code> and multiple group analysis, <code>N</code> is a list of group weights.
</p>
</li>
<li> <p><code>abratio</code>: The ratio of alpha to beta. Only for <code>type = 'compromise'</code>.
</p>
</li></ul>

<p>If a <strong>simulated power analysis</strong> (<code>simulatedPower = TRUE</code>) is requested, optional arguments can be provided as a list to <code>simOptions</code>:
</p>

<ul>
<li> <p><code>nReplications</code>: The targeted number of simulation runs. Defaults to 250, but larger numbers greatly improve accuracy at the expense of increased computation time.
</p>
</li>
<li> <p><code>minConvergenceRate</code>:  The minimum convergence rate required, defaults to .5. The maximum actual simulation runs are increased by a factor of 1/minConvergenceRate.
</p>
</li>
<li> <p><code>type</code>: specifies whether the data should be generated from a population assuming multivariate normality (<code>'normal'</code>; the default), or based on an approach generating non-normal data (<code>'IG'</code>, <code>'mnonr'</code>, <code>'RC'</code>, or <code>'VM'</code>).
The approaches generating non-normal data require additional arguments detailed below.
</p>
</li>
<li> <p><code>missingVars</code>: vector specifying the variables containing missing data (defaults to NULL).
</p>
</li>
<li> <p><code>missingVarProp</code>: can be used instead of <code>missingVars</code>: The proportion of variables containing missing data (defaults to zero).
</p>
</li>
<li> <p><code>missingProp</code>: The proportion of missingness for variables containing missing data (defaults to zero), either a single value or a vector giving the probabilities for each variable.
</p>
</li>
<li> <p><code>missingMechanism</code>: The missing data mechanism, one of <code>MCAR</code> (the default), <code>MAR</code>, or <code>NMAR</code>.
</p>
</li>
<li> <p><code>nCores</code>: The number of cores to use for parallel processing. Defaults to 1 (= no parallel processing). This requires the <code>doSNOW</code> package.
</p>
</li></ul>

<p><code>type = 'IG'</code> implements the independent generator approach (IG, Foldnes &amp; Olsson, 2016) approach
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors. This requires the <code>covsim</code> package.
</p>
<p><code>type = 'mnonr'</code> implements the approach suggested by Qu, Liu, &amp; Zhang (2020) and requires provision of  Mardia's multivariate skewness (<code>skewness</code>)  and kurtosis  (<code>kurtosis</code>), where
skewness must be non-negative and kurtosis must be at least 1.641 skewness + p (p + 0.774), where p is the number of variables. This requires the <code>mnonr</code> package.
</p>
<p><code>type = 'RK'</code> implements the approach suggested by Ruscio &amp; Kaczetow (2008) and requires provision of the population distributions
of each variable (<code>distributions</code>). <code>distributions</code> must be a list (if all variables shall be based on the same population distribution) or a list of lists.
Each component must specify the population distribution (e.g. <code>rchisq</code>) and additional arguments (<code>list(df = 2)</code>).
</p>
<p><code>type = 'VM'</code> implements the third-order polynomial method (Vale &amp; Maurelli, 1983)
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors.  This requires the <code>semTools</code> package.
</p>


<h3>Value</h3>

<p>a list. Use the <code>summary</code> method to obtain formatted results. Beyond the results of the power analysis and a number of effect size measures, the list contains the following components:
</p>
<table role = "presentation">
<tr><td><code>Sigma</code></td>
<td>
<p>the population covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the population mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td></tr>
<tr><td><code>SigmaHat</code></td>
<td>
<p>the H0 model implied covariance matrix. A list for multiple group models.</p>
</td></tr>
<tr><td><code>muHat</code></td>
<td>
<p>the H0 model implied mean vector or <code>NULL</code> when no meanstructure is involved. A list for multiple group models.</p>
</td></tr>
<tr><td><code>modelH0</code></td>
<td>
<p><code>lavaan</code> H0 model string.</p>
</td></tr>
<tr><td><code>modelH1</code></td>
<td>
<p><code>lavaan</code> H1 model string or <code>NULL</code> when the comparison refers to the saturated model.</p>
</td></tr>
<tr><td><code>simRes</code></td>
<td>
<p>detailed simulation results when a simulated power analysis (<code>simulatedPower = TRUE</code>) was performed.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+semPower.genSigma">semPower.genSigma()</a></code> <code><a href="#topic+semPower.aPriori">semPower.aPriori()</a></code> <code><a href="#topic+semPower.postHoc">semPower.postHoc()</a></code> <code><a href="#topic+semPower.compromise">semPower.compromise()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Determine required N in a 3-wave RI-CLPM
# to detect crossed effects of X (X1 -&gt; Y2 and X2 -&gt; Y3) of &gt;= .2
# with a power of 95% on alpha = 5%, where
# X1, X2, and X3 are measured by 5 indicators loading by .5 each, and
# Y1, Y2, and Y3 are measured by 3 indicators loading by .4 each, and
# there is no synchronous correlation between X and Y (rXY = NULL),
# the correlation between the random intercept factors of X and Y (rBXBY) is .1,
# the autoregressive effects of X are .8 (equal across waves),
# the autoregressive effects of Y are .7 (equal across waves), and
# the crossed effects of Y (Y1 -&gt; X2 and Y2 -&gt; X3) are .1 (equal across waves).

powerRICLPM &lt;- semPower.powerRICLPM(type = 'a-priori',
                                    nWaves = 3,
                                    autoregEffects = c(.8, .7),
                                    crossedEffects = c(.2, .1),
                                    waveEqual = c('autoregX', 'autoregY', 
                                                  'crossedX', 'crossedY'),
                                    rXY = NULL,
                                    rBXBY = .1,
                                    nullEffect = 'crossedX = 0',
                                    nIndicator = c(5, 3, 5, 3, 5, 3),
                                    loadM = c(.5, .4, .5, .4, .5, .4),
                                    alpha = .05, beta = .05)

# show summary
summary(powerRICLPM)
# optionally use lavaan to verify the model was set-up as intended
lavaan::sem(powerRICLPM$modelH1, sample.cov = powerRICLPM$Sigma,
            sample.nobs = powerRICLPM$requiredN, sample.cov.rescale = FALSE)
lavaan::sem(powerRICLPM$modelH0, sample.cov = powerRICLPM$Sigma,
            sample.nobs = powerRICLPM$requiredN, sample.cov.rescale = FALSE)


# same as above, but determine power with N = 500 on alpha = .05
powerRICLPM &lt;- semPower.powerRICLPM(type = 'post-hoc',
                                    nWaves = 3,
                                    autoregEffects = c(.8, .7),
                                    crossedEffects = c(.2, .1),
                                    waveEqual = c('autoregX', 'autoregY', 
                                                  'crossedX', 'crossedY'),
                                    rXY = NULL,
                                    rBXBY = .1,
                                    nullEffect = 'crossedX = 0',
                                    nIndicator = c(5, 3, 5, 3, 5, 3),
                                    loadM = c(.5, .4, .5, .4, .5, .4),
                                    alpha = .05, N = 500)


# same as above, but determine the critical chi-square with N = 500 so that alpha = beta
powerRICLPM &lt;- semPower.powerRICLPM(type = 'compromise',
                                    nWaves = 3,
                                    autoregEffects = c(.8, .7),
                                    crossedEffects = c(.2, .1),
                                    waveEqual = c('autoregX', 'autoregY', 
                                                  'crossedX', 'crossedY'),
                                    rXY = NULL,
                                    rBXBY = .1,
                                    nullEffect = 'crossedX = 0',
                                    nIndicator = c(5, 3, 5, 3, 5, 3),
                                    loadM = c(.5, .4, .5, .4, .5, .4),
                                    abratio = 1, N = 500)


# same as above, but compare to the saturated model
# (rather than to the less restricted model)
powerRICLPM &lt;- semPower.powerRICLPM(type = 'compromise',
                                    comparison = 'saturated',
                                    nWaves = 3,
                                    autoregEffects = c(.8, .7),
                                    crossedEffects = c(.2, .1),
                                    waveEqual = c('autoregX', 'autoregY', 
                                                  'crossedX', 'crossedY'),
                                    rXY = NULL,
                                    rBXBY = .1,
                                    nullEffect = 'crossedX = 0',
                                    nIndicator = c(5, 3, 5, 3, 5, 3),
                                    loadM = c(.5, .4, .5, .4, .5, .4),
                                    abratio = 1, N = 500)


# same as above, but assume only observed variables
powerRICLPM &lt;- semPower.powerRICLPM(type = 'a-priori',
                                    nWaves = 3,
                                    autoregEffects = c(.8, .7),
                                    crossedEffects = c(.2, .1),
                                    waveEqual = c('autoregX', 'autoregY', 
                                                  'crossedX', 'crossedY'),
                                    rXY = NULL,
                                    rBXBY = .1,
                                    nullEffect = 'crossedX = 0',
                                    Lambda = diag(6),
                                    alpha = .05, beta = .05)


# same as above, but provide reduced loadings matrix to define that
# X1, X2, and X3 are measured by 5 indicators each loading by .5, .4, .5, .4, .3
# Y1, Y2, and Y3 are measured by 3 indicators each loading by .4, .3, .2
powerRICLPM &lt;- semPower.powerRICLPM(type = 'a-priori',
                                    nWaves = 3,
                                    autoregEffects = c(.8, .7),
                                    crossedEffects = c(.2, .1),
                                    waveEqual = c('autoregX', 'autoregY', 
                                                  'crossedX', 'crossedY'),
                                    rXY = NULL,
                                    rBXBY = .1,
                                    nullEffect = 'crossedX = 0',
                                    loadings = list(
                                      c(.5, .4, .5, .4, .3),    # X1
                                      c(.4, .3, .2),            # Y1
                                      c(.5, .4, .5, .4, .3),    # X2
                                      c(.4, .3, .2),            # Y2
                                      c(.5, .4, .5, .4, .3),    # X3
                                      c(.4, .3, .2)             # Y3
                                    ),
                                    alpha = .05, beta = .05)


# same as above, but do not assume metric invariance across waves
powerRICLPM &lt;- semPower.powerRICLPM(type = 'a-priori',
                                    nWaves = 3,
                                    autoregEffects = c(.8, .7),
                                    crossedEffects = c(.2, .1),
                                    waveEqual = c('autoregX', 'autoregY', 
                                                  'crossedX', 'crossedY'),
                                    rXY = NULL,
                                    rBXBY = .1,
                                    nullEffect = 'crossedX = 0',
                                    nIndicator = c(5, 3, 5, 3, 5, 3),
                                    loadM = c(.5, .4, .5, .4, .5, .4),
                                    metricInvariance = FALSE,
                                    alpha = .05, beta = .05)


# same as above, but determine N to detect that the crossed effect of Y 
# (Y1 -&gt; X2 and Y2 -&gt; X3) is &gt;= .1.
powerRICLPM &lt;- semPower.powerRICLPM(type = 'a-priori',
                                    nWaves = 3,
                                    autoregEffects = c(.8, .7),
                                    crossedEffects = c(.2, .1),
                                    waveEqual = c('autoregX', 'autoregY', 
                                                  'crossedX', 'crossedY'),
                                    rXY = NULL,
                                    rBXBY = .1,
                                    nullEffect = 'crossedY = 0',
                                    nIndicator = c(5, 3, 5, 3, 5, 3),
                                    loadM = c(.5, .4, .5, .4, .5, .4),
                                    alpha = .05, beta = .05)


# same as above, but determine N to detect that the autoregressive effect 
# of X (X1 -&gt; X2 and X2 -&gt; X3) is &gt;= .8.
powerRICLPM &lt;- semPower.powerRICLPM(type = 'a-priori',
                                    nWaves = 3,
                                    autoregEffects = c(.8, .7),
                                    crossedEffects = c(.2, .1),
                                    waveEqual = c('autoregX', 'autoregY', 
                                                  'crossedX', 'crossedY'),
                                    rXY = NULL,
                                    rBXBY = .1,
                                    nullEffect = 'autoregX = 0',
                                    nIndicator = c(5, 3, 5, 3, 5, 3),
                                    loadM = c(.5, .4, .5, .4, .5, .4),
                                    alpha = .05, beta = .05)


# same as above, but determine N to detect that the autoregressive effect 
# of Y (Y1 -&gt; Y2) is &gt;= .7.
powerRICLPM &lt;- semPower.powerRICLPM(type = 'a-priori',
                                    nWaves = 3,
                                    autoregEffects = c(.8, .7),
                                    crossedEffects = c(.2, .1),
                                    waveEqual = c('autoregX', 'autoregY', 
                                                  'crossedX', 'crossedY'),
                                    rXY = NULL,
                                    rBXBY = .1,
                                    nullEffect = 'autoregY = 0',
                                    nIndicator = c(5, 3, 5, 3, 5, 3),
                                    loadM = c(.5, .4, .5, .4, .5, .4),
                                    alpha = .05, beta = .05)


# same as above, but determine N to detect that
# the crossed effect of X (X1 -&gt; Y2) of .2 differs from
# the crossed effect of Y (Y1 -&gt; X2) of .1
powerRICLPM &lt;- semPower.powerRICLPM(type = 'a-priori',
                                    nWaves = 3,
                                    autoregEffects = c(.8, .7),
                                    crossedEffects = c(.2, .1),
                                    waveEqual = c('autoregX', 'autoregY', 
                                                  'crossedX', 'crossedY'),
                                    rXY = NULL,
                                    rBXBY = .1,
                                    nullEffect = 'crossedX = crossedY',
                                    nIndicator = c(5, 3, 5, 3, 5, 3),
                                    loadM = c(.5, .4, .5, .4, .5, .4),
                                    alpha = .05, beta = .05)


# same as above, but determine N to detect that
# the autoregressive effect of X (X1 -&gt; X2) of .8 differs from
# the autoregressive effect of Y (Y1 -&gt; Y2) of .7
powerRICLPM &lt;- semPower.powerRICLPM(type = 'a-priori',
                                    nWaves = 3,
                                    autoregEffects = c(.8, .7),
                                    crossedEffects = c(.2, .1),
                                    waveEqual = c('autoregX', 'autoregY', 
                                                  'crossedX', 'crossedY'),
                                    rXY = NULL,
                                    rBXBY = .1,
                                    nullEffect = 'autoregX = autoregY',
                                    nIndicator = c(5, 3, 5, 3, 5, 3),
                                    loadM = c(.5, .4, .5, .4, .5, .4),
                                    alpha = .05, beta = .05)


# same as above, but determine N to detect that the correlation between the 
# random intercept factors is &gt;= .1
powerRICLPM &lt;- semPower.powerRICLPM(type = 'a-priori',
                                    nWaves = 3,
                                    autoregEffects = c(.8, .7),
                                    crossedEffects = c(.2, .1),
                                    waveEqual = c('autoregX', 'autoregY', 
                                                  'crossedX', 'crossedY'),
                                    rXY = NULL,
                                    rBXBY = .1,
                                    nullEffect = 'corBXBY = 0',
                                    nIndicator = c(5, 3, 5, 3, 5, 3),
                                    loadM = c(.5, .4, .5, .4, .5, .4),
                                    alpha = .05, beta = .05)


# same as above, but assume that the synchronous (residual-)correlations between
#  X and Y are equal across waves, 
# namely a synchronous correlation of .05 at the first wave and residual correlations 
# of .05 at the second and third wave,
# and determine N to detect a crossed effect of X (X1 -&gt; Y2 and X2 -&gt; Y3) of &gt;= .2
powerRICLPM &lt;- semPower.powerRICLPM(type = 'a-priori',
                                    nWaves = 3,
                                    autoregEffects = c(.8, .7),
                                    crossedEffects = c(.2, .1),
                                    waveEqual = c('autoregX', 'autoregY', 
                                                  'crossedX', 'crossedY', 
                                                  'corXY'),
                                    rXY = c(.05, .05, .05),
                                    rBXBY = .1,
                                    nullEffect = 'crossedX = 0',
                                    nIndicator = c(5, 3, 5, 3, 5, 3),
                                    loadM = c(.5, .4, .5, .4, .5, .4),
                                    alpha = .05, beta = .05)


# same as above, but assume that the synchronous correlation between X and Y
# is .3 at the first wave, and the respective residual correlations are .2 at 
# the second wave and .3 at the third wave,
# and determine N to detect that the synchronous residual correlation at wave 2 is =&gt; .2.
powerRICLPM &lt;- semPower.powerRICLPM(type = 'a-priori',
                                    nWaves = 3,
                                    autoregEffects = c(.8, .7),
                                    crossedEffects = c(.2, .1),
                                    waveEqual = c('autoregX', 'autoregY', 
                                                  'crossedX', 'crossedY'),
                                    rXY = c(.3, .2, .3),
                                    rBXBY = .1,
                                    nullEffect = 'corXY = 0',
                                    nullWhich = 2,
                                    nIndicator = c(5, 3, 5, 3, 5, 3),
                                    loadM = c(.5, .4, .5, .4, .5, .4),
                                    alpha = .05, beta = .05)


# Determine required N in a 3-wave RI-CLPM to detect that
# the crossed effect of X at wave 1 (X1 -&gt; Y2) of .20 is equal to the
# the crossed effect of X at wave 2 (X2 -&gt; Y3) of .05
# with a power of 95% on alpha = 5%, where
# the autoregressive effects of X and Y are equal over waves,
# X1, X2, and X3 are measured by 5 indicators loading by .5 each, and
# Y1, Y2, and Y3 are measured by 3 indicators loading by .4 each, and
# the synchronous correlation between X and Y are .2, .3, and .4 at the first, 
# second, and third wave, 
# the correlation between the random intercept factors of X and Y is .1, and
# the autoregressive effect of X is .8 across all three waves,
# the autoregressive effect of Y is .7 across all three waves, and
# the crossed effects of Y (Y1 -&gt; X2, and Y2 -&gt; Y3) are both .1 
# (but freely estimated for each wave).
powerRICLPM &lt;- semPower.powerRICLPM(type = 'a-priori',
                                    nWaves = 3,
                                    autoregEffects = c(.8, .7),
                                    crossedEffects = list(
                                      # X   Y
                                      c(.20, .10),  # wave 1 -&gt; wave 2
                                      c(.05, .10)), # wave 2 -&gt; wave 3
                                    waveEqual = c('autoregX', 'autoregY'),
                                    rXY = c(.2, .3, .4),
                                    rBXBY = .1,
                                    nullEffect = 'crossedX',
                                    nIndicator = c(5, 3, 5, 3, 5, 3),
                                    loadM = c(.5, .4, .5, .4, .5, .4),
                                    alpha = .05, beta = .05)


# same as above, but determine N to detect that
# the crossed effect of X at wave 2 is &gt;= .05.
powerRICLPM &lt;- semPower.powerRICLPM(type = 'a-priori',
                                    nWaves = 3,
                                    autoregEffects = c(.8, .7),
                                    crossedEffects = list(
                                      # X   Y
                                      c(.20, .10),  # wave 1 -&gt; wave 2
                                      c(.05, .10)), # wave 2 -&gt; wave 3
                                    waveEqual = c('autoregX', 'autoregY'),
                                    rXY = c(.2, .3, .4),
                                    rBXBY = .1,
                                    nullEffect = 'crossedX = 0',
                                    nullWhich = 2,
                                    nIndicator = c(5, 3, 5, 3, 5, 3),
                                    loadM = c(.5, .4, .5, .4, .5, .4),
                                    alpha = .05, beta = .05)


# same as above, but determine N to detect that
# the residual correlation between X and Y at wave 2 (of .3) differs from
# the residual correlation between X and Y at wave 3 (of .4).
powerRICLPM &lt;- semPower.powerRICLPM(type = 'a-priori',
                                    nWaves = 3,
                                    autoregEffects = c(.8, .7),
                                    crossedEffects = list(
                                      # X   Y
                                      c(.20, .10),  # wave 1 -&gt; wave 2
                                      c(.05, .10)), # wave 2 -&gt; wave 3
                                    waveEqual = c('autoregX', 'autoregY'),
                                    rXY = c(.2, .3, .4),
                                    rBXBY = .1,
                                    nullEffect = 'corXY',
                                    nIndicator = c(5, 3, 5, 3, 5, 3),
                                    loadM = c(.5, .4, .5, .4, .5, .4),
                                    alpha = .05, beta = .05)


# multigroup example
# Determine the achieved power N in a 3-wave RI-CLPM to detect that
# the crossed effect of X at wave 1 (X1 -&gt; Y2) in group 1 of .25 differs
# from the crossed effect of X at wave 1 (X1 -&gt; Y2) in group 2 of .15,
# where both groups comprise 500 observations and alpha = 5%, and
# the measurement model is equal for both groups, and
# the crossed effects of X (X1 -&gt; Y2, and X2 -&gt; Y3) are .25 and .10 in the first group, 
# the crossed effects of X (X1 -&gt; Y2, and X2 -&gt; Y3) are .15 and .05 in the second group, 
# the crossed effects of Y (Y1 -&gt; X2, and Y2 -&gt; X3) are .05 and .15 in the first group, 
# the crossed effects of Y (Y1 -&gt; X2, and Y2 -&gt; X3) are .01 and .10 in the second group, and
# the autoregressive effects of X (of .5) and Y (of .4) are equal over waves and over groups 
# (but freely estimated in each group).
powerRICLPM &lt;- semPower.powerRICLPM(type = 'post-hoc', alpha = .05, N = list(500, 500),
                                    nWaves = 3,
                                    autoregEffects = c(.5, .4), # group and wave constant 
                                    crossedEffects = list(
                                      # group 1
                                      list(
                                        c(.25, .10),   # X
                                        c(.05, .15)    # Y 
                                      ),
                                      # group 2
                                      list(
                                        c(.15, .05),   # X
                                        c(.01, .10)    # Y 
                                      )
                                    ),
                                    rXY = NULL,        # identity
                                    rBXBY = NULL,      # identity 
                                    nullEffect = 'crossedXA = crossedXB',
                                    nullWhich = 1,
                                    nIndicator = rep(3, 6), 
                                    loadM = c(.5, .6, .5, .6, .5, .6),
                                    metricInvariance = TRUE,
                                    waveEqual = c('autoregX', 'autoregY')
                                    )


# Request a simulated post-hoc power analysis with 500 replications
# to detect crossed effects of X (X1 -&gt; Y2 and X2 -&gt; Y3) of &gt;= .2
# with a power of 95% on alpha = 5% in a RI-CLPM with 3 waves, 
# where there are only observed variables and 
# there is no synchronous correlation between X and Y (rXY = NULL),
# and no correlation between the random intercept factors of X and Y (rBXBY = NULL),
# the autoregressive effects of X are .8 (equal across waves),
# the autoregressive effects of Y are .7 (equal across waves), and
# the crossed effects of Y (Y1 -&gt; X2 and Y2 -&gt; X3) are .1 (equal across waves).
set.seed(300121)
powerRICLPM &lt;- semPower.powerRICLPM(type = 'post-hoc',
                                    nWaves = 3,
                                    autoregEffects = c(.8, .7),
                                    crossedEffects = c(.2, .1),
                                    waveEqual = c('autoregX', 'autoregY', 
                                                  'crossedX', 'crossedY'),
                                    rXY = NULL,
                                    rBXBY = NULL,
                                    nullEffect = 'crossedX = 0',
                                    Lambda = diag(6),
                                    alpha = .05, N = 500,
                                    simulatedPower = TRUE, 
                                    simOptions = list(nReplications = 500))

## End(Not run)
</code></pre>

<hr>
<h2 id='semPower.showPlot'>semPower.showPlot</h2><span id='topic+semPower.showPlot'></span>

<h3>Description</h3>

<p>Shows a plot showing central and non-central chi-square distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semPower.showPlot(chiCrit, ncp, df, linewidth = 1, showLabels = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semPower.showPlot_+3A_chicrit">chiCrit</code></td>
<td>
<p>critical chi-square, e. g. <code>qchisq(alpha, df, ncp = 0, lower.tail = FALSE)</code></p>
</td></tr>
<tr><td><code id="semPower.showPlot_+3A_ncp">ncp</code></td>
<td>
<p>non-centrality parameter under H1</p>
</td></tr>
<tr><td><code id="semPower.showPlot_+3A_df">df</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code id="semPower.showPlot_+3A_linewidth">linewidth</code></td>
<td>
<p>linewidth</p>
</td></tr>
<tr><td><code id="semPower.showPlot_+3A_showlabels">showLabels</code></td>
<td>
<p>whether to add labels</p>
</td></tr>
</table>

<hr>
<h2 id='simulate'>simulate</h2><span id='topic+simulate'></span>

<h3>Description</h3>

<p>Estimates empirical power using a simulation approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate(
  modelH0 = NULL,
  modelH1 = NULL,
  Sigma = NULL,
  mu = NULL,
  N = NULL,
  alpha = NULL,
  simOptions = list(nReplications = 500, minConvergenceRate = 0.75, type = "normal",
    missingVars = NULL, missingVarProp = 0, missingProp = 0, missingMechanism = "MCAR",
    nCores = 1),
  lavOptions = NULL,
  lavOptionsH1 = lavOptions,
  returnFmin = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_+3A_modelh0">modelH0</code></td>
<td>
<p><code>lavaan</code> model string defining the (incorrect) analysis model.</p>
</td></tr>
<tr><td><code id="simulate_+3A_modelh1">modelH1</code></td>
<td>
<p><code>lavaan</code> model string defining the comparison model. If omitted, the saturated model is the comparison model.</p>
</td></tr>
<tr><td><code id="simulate_+3A_sigma">Sigma</code></td>
<td>
<p>population covariance matrix.</p>
</td></tr>
<tr><td><code id="simulate_+3A_mu">mu</code></td>
<td>
<p>population means.</p>
</td></tr>
<tr><td><code id="simulate_+3A_n">N</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="simulate_+3A_alpha">alpha</code></td>
<td>
<p>alpha error probability</p>
</td></tr>
<tr><td><code id="simulate_+3A_simoptions">simOptions</code></td>
<td>
<p>a list of additional options specifying simulation details, see details.</p>
</td></tr>
<tr><td><code id="simulate_+3A_lavoptions">lavOptions</code></td>
<td>
<p>a list of additional options passed to <code>lavaan</code>, e. g., <code>list(estimator = 'mlm')</code> to request robust ML estimation</p>
</td></tr>
<tr><td><code id="simulate_+3A_lavoptionsh1">lavOptionsH1</code></td>
<td>
<p>lavoptions when fitting <code>modelH1</code>. If <code>NULL</code>, the same as <code>lavOptions</code>.</p>
</td></tr>
<tr><td><code id="simulate_+3A_returnfmin">returnFmin</code></td>
<td>
<p>whether to return the mean unbiased Fmin over replications (i. e., <code>fmin_0 = fmin_hat - df/N</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The details of the simulation are specified in <code>simOptions</code>, which is a list that may have the following components:
</p>

<ul>
<li> <p><code>nReplications</code>: The targeted number of valid simulation runs, defaults to 500.
</p>
</li>
<li> <p><code>minConvergenceRate</code>:  The minimum convergence rate required, defaults to .75. The maximum actual simulation runs are increased by a factor of 1/minConvergenceRate.
</p>
</li>
<li> <p><code>type</code>: specifies whether the data should be generated from a population assuming multivariate normality (<code>'normal'</code>; the default), or based on an approach generating non-normal data (<code>'IG'</code>, <code>'mnonr'</code>, <code>'RK'</code>, or <code>'VM'</code>).
The approaches generating non-normal data require additional arguments detailed below.
</p>
</li>
<li> <p><code>missingVars</code>: vector specifying the variables containing missing data (defaults to <code>NULL</code>).
</p>
</li>
<li> <p><code>missingVarProp</code>: can be used instead of <code>missingVars</code>: The proportion of variables containing missing data (defaults to zero).
</p>
</li>
<li> <p><code>missingProp</code>: The proportion of missingness for variables containing missing data (defaults to zero), either a single value or a vector giving the probabilities for each variable.
</p>
</li>
<li> <p><code>missingMechanism</code>: The missing data mechanism, one of <code>'MCAR'</code> (the default), <code>'MAR'</code>, or <code>'NMAR'</code>.
</p>
</li>
<li> <p><code>nCores</code>: The number of cores to use for parallel processing. Defaults to 1 (= no parallel processing). This requires the <code>doFuture</code> package.
</p>
</li></ul>

<p><code>type = 'IG'</code> implements the independent generator approach (IG, Foldnes &amp; Olsson, 2016) approach
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors. This requires the <code>covsim</code> package.
</p>
<p><code>type = 'mnonr'</code> implements the approach suggested by Qu, Liu, &amp; Zhang (2020) and requires provision of  Mardia's multivariate skewness (<code>skewness</code>)  and kurtosis  (<code>kurtosis</code>), where
skewness must be non-negative and kurtosis must be at least 1.641 skewness + p (p + 0.774), where p is the number of variables. This requires the <code>mnonr</code> package.
</p>
<p><code>type = 'RK'</code> implements the approach suggested by Ruscio &amp; Kaczetow (2008) and requires provision of the population distributions
of each variable (<code>distributions</code>). <code>distributions</code> must be a list (if all variables shall be based on the same population distribution) or a list of lists.
Each component must specify the population distribution (e.g. <code>rchisq</code>) and additional arguments (<code>list(df = 2)</code>).
</p>
<p><code>type = 'VM'</code> implements the third-order polynomial method (Vale &amp; Maurelli, 1983)
specifying third and fourth moments of the marginals, and thus requires that skewness (<code>skewness</code>) and excess kurtosis (<code>kurtosis</code>) for each variable are provided as vectors.
</p>
<p>Foldnes, N. &amp; Olsson, U. H. (2016) A Simple Simulation Technique for Nonnormal Data with Prespecified Skewness, Kurtosis, and Covariance Matrix. <em>Multivariate Behavioral Research, 51</em>, 207-219. doi: 10.1080/00273171.2015.1133274
</p>
<p>Qu, W., Liu, H., &amp; Zhang, Z. (2020). A method of generating multivariate non-normal random numbers with desired multivariate skewness and kurtosis. <em>Behavior Research Methods, 52</em>, 939-946. doi: 10.3758/s13428-019-01291-5
</p>
<p>Ruscio, J., &amp; Kaczetow, W. (2008). Simulating multivariate nonnormal data using an iterative algorithm. <em>Multivariate Behavioral Research, 43</em>, 355-381. doi: 10.1080/00273170802285693
</p>
<p>Vale, C. &amp; Maurelli, V. (1983). Simulating multivariate nonnormal distributions. <em>Psychometrika, 48</em>, 465-471.
</p>


<h3>Value</h3>

<p>Returns empirical power: <code>sum(p &lt; alpha) / nReplications</code> or a list (if <code>returnFmin = TRUE</code>) with the following components:
</p>
<table role = "presentation">
<tr><td><code>ePower</code></td>
<td>
<p>the empirical power.</p>
</td></tr>
<tr><td><code>meanFmin</code></td>
<td>
<p>the estimated mean unbiased Fmin over replications (i. e., <code>fmin_0 = fmin_hat - df/N</code>).</p>
</td></tr>
<tr><td><code>meanFminGroups</code></td>
<td>
<p>the estimated mean unbiased Fmin by groups given as a vector, assuming the df spread equally over groups. Therefore, <code>meanFmin != sum(meanFminGroups)</code></p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the model df.</p>
</td></tr>
<tr><td><code>nrep</code></td>
<td>
<p>the number of successful replications.</p>
</td></tr>
<tr><td><code>convergenceRate</code></td>
<td>
<p>the convergence rate of the H0 model.</p>
</td></tr>
<tr><td><code>bChiSq</code></td>
<td>
<p>median chi-square bias of the H1 model</p>
</td></tr>
<tr><td><code>bLambda</code></td>
<td>
<p>average median bias in lambda in the H1 model</p>
</td></tr>
<tr><td><code>bPhi</code></td>
<td>
<p>average median bias in phi in the H1 model</p>
</td></tr>
<tr><td><code>bPsi</code></td>
<td>
<p>average median bias in psi in the H1 model</p>
</td></tr>
<tr><td><code>bBeta</code></td>
<td>
<p>average median bias in beta in the H1 model</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# create Sigma and modelH0 using powerCFA
powerCFA &lt;- semPower.powerCFA(type = 'a-priori', alpha = .05, beta = .05,
                              comparison = 'saturated',
                              Phi = .2, loadings = list(rep(.5, 3), rep(.7, 3)))
                              
# perform simulated power analysis using defaults       
simulate(modelH0 = powerCFA$modelH0, 
         Sigma = powerCFA$Sigma,
         N = powerCFA$requiredN,
         alpha = .05,
         simulatedPower = TRUE)
         

# same with additional options       
simulate(modelH0 = powerCFA$modelH0, 
         Sigma = powerCFA$Sigma,
         N = powerCFA$requiredN,
         alpha = .05,
         simulatedPower = TRUE, 
         simOptions = list(nReplications = 500, 
                           minConvergenceRate = .80, 
                           nCores = 8))


# same with IG as data generation routine
simulate(modelH0 = powerCFA$modelH0, 
         Sigma = powerCFA$Sigma,
         N = powerCFA$requiredN,
         alpha = .05,
         simulatedPower = TRUE, 
         simOptions = list(type = 'IG', 
                           skewness = c(0, 1, -2, 6, 5, 4), 
                           kurtosis = c(-3, 6, 9, 0, 2, -2)))
                           
                           
# same with mnonr as data generation routine
simulate(modelH0 = powerCFA$modelH0, 
         Sigma = powerCFA$Sigma,
         N = powerCFA$requiredN,
         alpha = .05,
         simulatedPower = TRUE, 
         simOptions = list(type = 'mnonr', 
                           skewness = 1, 
                           kurtosis = 50))
                           
                           
# same with RK as data generation routine
distributions &lt;- list(
  list('rnorm', list(mean = 0, sd = 10)),
  list('runif', list(min = 0, max = 1)),
  list('rbeta', list(shape1 = 1, shape2 = 2)),
  list('rexp', list(rate = 1)),
  list('rpois', list(lambda = 4)),
  list('rbinom', list(size = 1, prob = .5))
)
simulate(modelH0 = powerCFA$modelH0, 
         Sigma = powerCFA$Sigma,
         N = powerCFA$requiredN,
         alpha = .05,
         simulatedPower = TRUE, 
         simOptions = list(type = 'RK', 
                           distributions = distributions))

## End(Not run)

</code></pre>

<hr>
<h2 id='summary.semPower.aPriori'>summary.semPower.aPriori</h2><span id='topic+summary.semPower.aPriori'></span>

<h3>Description</h3>

<p>provide summary of a-priori power analyses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'semPower.aPriori'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.semPower.aPriori_+3A_object">object</code></td>
<td>
<p>result object from semPower.aPriori</p>
</td></tr>
<tr><td><code id="summary.semPower.aPriori_+3A_...">...</code></td>
<td>
<p>other</p>
</td></tr>
</table>

<hr>
<h2 id='summary.semPower.compromise'>summary.sempower.compromise</h2><span id='topic+summary.semPower.compromise'></span>

<h3>Description</h3>

<p>provide summary of compromise post-hoc power analyses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'semPower.compromise'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.semPower.compromise_+3A_object">object</code></td>
<td>
<p>result object from semPower.compromise</p>
</td></tr>
<tr><td><code id="summary.semPower.compromise_+3A_...">...</code></td>
<td>
<p>other</p>
</td></tr>
</table>

<hr>
<h2 id='summary.semPower.postHoc'>semPower.postHoc.summary</h2><span id='topic+summary.semPower.postHoc'></span>

<h3>Description</h3>

<p>provide summary of post-hoc power analyses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'semPower.postHoc'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.semPower.postHoc_+3A_object">object</code></td>
<td>
<p>result object from semPower.posthoc</p>
</td></tr>
<tr><td><code id="summary.semPower.postHoc_+3A_...">...</code></td>
<td>
<p>other</p>
</td></tr>
</table>

<hr>
<h2 id='validateInput'>validateInput</h2><span id='topic+validateInput'></span>

<h3>Description</h3>

<p>Validates input for power functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validateInput(
  power.type = NULL,
  effect = NULL,
  effect.measure = NULL,
  alpha = NULL,
  beta = NULL,
  power = NULL,
  abratio = NULL,
  N = NULL,
  df = NULL,
  p = NULL,
  SigmaHat = NULL,
  Sigma = NULL,
  muHat = NULL,
  mu = NULL,
  fittingFunction = "ML",
  simulatedPower = FALSE,
  modelH0 = NULL,
  power.min = alpha,
  power.max = 0.999,
  effect.min = NULL,
  effect.max = NULL,
  steps = 50,
  linewidth = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validateInput_+3A_power.type">power.type</code></td>
<td>
<p>type of power analyses, one of <code>"a-priori"</code>, <code>"post-hoc"</code>, <code>"compromise"</code>, <code>"powerplot.byN"</code>, <code>"powerplot.byEffect"</code></p>
</td></tr>
<tr><td><code id="validateInput_+3A_effect">effect</code></td>
<td>
<p>effect size specifying the discrepancy between H0 and H1</p>
</td></tr>
<tr><td><code id="validateInput_+3A_effect.measure">effect.measure</code></td>
<td>
<p>type of effect, one of <code>"F0"</code>, <code>"RMSEA"</code>, <code>"Mc"</code>, <code>"GFI"</code>, <code>"AGFI"</code></p>
</td></tr>
<tr><td><code id="validateInput_+3A_alpha">alpha</code></td>
<td>
<p>alpha error</p>
</td></tr>
<tr><td><code id="validateInput_+3A_beta">beta</code></td>
<td>
<p>beta error</p>
</td></tr>
<tr><td><code id="validateInput_+3A_power">power</code></td>
<td>
<p>power (= 1 - beta)</p>
</td></tr>
<tr><td><code id="validateInput_+3A_abratio">abratio</code></td>
<td>
<p>ratio alpha/beta</p>
</td></tr>
<tr><td><code id="validateInput_+3A_n">N</code></td>
<td>
<p>the number of observations</p>
</td></tr>
<tr><td><code id="validateInput_+3A_df">df</code></td>
<td>
<p>the model degrees of freedom</p>
</td></tr>
<tr><td><code id="validateInput_+3A_p">p</code></td>
<td>
<p>the number of observed variables, required for <code>effect.measure = "GFI"</code> and <code>effect.measure = "AGFI"</code></p>
</td></tr>
<tr><td><code id="validateInput_+3A_sigmahat">SigmaHat</code></td>
<td>
<p>model implied covariance matrix</p>
</td></tr>
<tr><td><code id="validateInput_+3A_sigma">Sigma</code></td>
<td>
<p>observed (or population) covariance matrix</p>
</td></tr>
<tr><td><code id="validateInput_+3A_muhat">muHat</code></td>
<td>
<p>model implied mean vector</p>
</td></tr>
<tr><td><code id="validateInput_+3A_mu">mu</code></td>
<td>
<p>observed (or population) mean vector</p>
</td></tr>
<tr><td><code id="validateInput_+3A_fittingfunction">fittingFunction</code></td>
<td>
<p>whether to use <code>ML</code> (the default) or <code>WLS</code></p>
</td></tr>
<tr><td><code id="validateInput_+3A_simulatedpower">simulatedPower</code></td>
<td>
<p>whether to perform a simulated (<code>TRUE</code>) (rather than analytical, <code>FALSE</code>) power analysis.</p>
</td></tr>
<tr><td><code id="validateInput_+3A_modelh0">modelH0</code></td>
<td>
<p>for simulated power: <code>lavaan</code> model string defining the (incorrect) analysis model.</p>
</td></tr>
<tr><td><code id="validateInput_+3A_power.min">power.min</code></td>
<td>
<p>for plotting: minimum power</p>
</td></tr>
<tr><td><code id="validateInput_+3A_power.max">power.max</code></td>
<td>
<p>for plotting: maximum power</p>
</td></tr>
<tr><td><code id="validateInput_+3A_effect.min">effect.min</code></td>
<td>
<p>for plotting: minimum effect</p>
</td></tr>
<tr><td><code id="validateInput_+3A_effect.max">effect.max</code></td>
<td>
<p>for plotting: maximum effect</p>
</td></tr>
<tr><td><code id="validateInput_+3A_steps">steps</code></td>
<td>
<p>for plotting: number of sampled points</p>
</td></tr>
<tr><td><code id="validateInput_+3A_linewidth">linewidth</code></td>
<td>
<p>for plotting: linewidth</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
