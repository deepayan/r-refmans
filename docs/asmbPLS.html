<!DOCTYPE html><html><head><title>Help for package asmbPLS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {asmbPLS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#asmbPLS-package'>
<p>Predicting and Classifying Patient Phenotypes with Multi-Omics Data</p></a></li>
<li><a href='#asmbPLS.cv'><p>Cross-validation for asmbPLS to find the best combinations of quantiles for prediction</p></a></li>
<li><a href='#asmbPLS.example'><p>Example data for asmbPLS algorithm</p></a></li>
<li><a href='#asmbPLS.fit'><p>asmbPLS for block-structured data</p></a></li>
<li><a href='#asmbPLS.predict'><p>Using an asmbPLS model for prediction of new samples</p></a></li>
<li><a href='#asmbPLSDA.cv'><p>Cross-validation for asmbPLS-DA to find the best combinations of quantiles for classification</p></a></li>
<li><a href='#asmbPLSDA.example'><p>Example data for asmbPLS-DA algorithm</p></a></li>
<li><a href='#asmbPLSDA.fit'><p>asmbPLS-DA for block-structured data</p></a></li>
<li><a href='#asmbPLSDA.predict'><p>Using an asmbPLS-DA model for classification of new samples</p></a></li>
<li><a href='#asmbPLSDA.vote.fit'><p>asmbPLS-DA vote model fit</p></a></li>
<li><a href='#asmbPLSDA.vote.predict'><p>Using an asmbPLS-DA vote model for classification of new samples</p></a></li>
<li><a href='#mbPLS.fit'><p>mbPLS for block-structured data</p></a></li>
<li><a href='#meanimp'><p>Mean imputation for the survival time</p></a></li>
<li><a href='#plotCor'><p>Graphical output for the asmbPLS-DA framework</p></a></li>
<li><a href='#plotPLS'><p>PLS plot for asmbPLS-DA</p></a></li>
<li><a href='#plotRelevance'><p>Relevance plot for asmbPLS-DA</p></a></li>
<li><a href='#quantileComb'><p>Create the quantile combination set for asmbPLS and asmbPLS-DA</p></a></li>
<li><a href='#to.categorical'><p>Converts a class vector to a binary class matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Predicting and Classifying Patient Phenotypes with Multi-Omics
Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-13</td>
</tr>
<tr>
<td>Description:</td>
<td>Adaptive Sparse Multi-block Partial Least Square, a supervised algorithm, is an extension of the Sparse Multi-block Partial Least Square, which allows different quantiles to be used in different blocks of different partial least square components to decide the proportion of features to be retained. The best combinations of quantiles can be chosen from a set of user-defined quantiles combinations by cross-validation. By doing this, it enables us to do the feature selection for different blocks, and the selected features can then be further used to predict the outcome. For example, in biomedical applications, clinical covariates plus different types of omics data such as microbiome, metabolome, mRNA data, methylation data, copy number variation data might be predictive for patients outcome such as survival time or response to therapy. Different types of data could be put in different blocks and along with survival time to fit the model. The fitted model can then be used to predict the survival for the new samples with the corresponding clinical covariates and omics data. In addition, Adaptive Sparse Multi-block Partial Least Square Discriminant Analysis is also included, which extends Adaptive Sparse Multi-block Partial Least Square for classifying the categorical outcome.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.8), ggplot2, ggpubr, stats</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Author:</td>
<td>Runzhi Zhang [aut, cre],
  Susmita Datta [aut, ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Runzhi Zhang &lt;runzhi.zhang@ufl.edu&gt;</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-13 23:01:41 UTC; zhang</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-17 09:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='asmbPLS-package'>
Predicting and Classifying Patient Phenotypes with Multi-Omics Data
</h2><span id='topic+asmbPLS-package'></span><span id='topic+asmbPLS'></span>

<h3>Description</h3>

<p>Adaptive Sparse Multi-block Partial Least Square, a supervised algorithm, is an extension of the Sparse Multi-block Partial Least Square, which allows different quantiles to be used in different blocks of different partial least square components to decide the proportion of features to be retained. The best combinations of quantiles can be chosen from a set of user-defined quantiles combinations by cross-validation. By doing this, it enables us to do the feature selection for different blocks, and the selected features can then be further used to predict the outcome. For example, in biomedical applications, clinical covariates plus different types of omics data such as microbiome, metabolome, mRNA data, methylation data, copy number variation data might be predictive for patients outcome such as survival time or response to therapy. Different types of data could be put in different blocks and along with survival time to fit the model. The fitted model can then be used to predict the survival for the new samples with the corresponding clinical covariates and omics data. In addition, Adaptive Sparse Multi-block Partial Least Square Discriminant Analysis is also included, which extends Adaptive Sparse Multi-block Partial Least Square for classifying the categorical outcome.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> asmbPLS</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Predicting and Classifying Patient Phenotypes with Multi-Omics
Data</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-04-13</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(
    person("Runzhi", "Zhang", role = c("aut", "cre"), email = "runzhi.zhang@ufl.edu"), 
    person("Susmita", "Datta", role = c("aut", "ths"), email = "susmita.datta@ufl.edu"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Adaptive Sparse Multi-block Partial Least Square, a supervised algorithm, is an extension of the Sparse Multi-block Partial Least Square, which allows different quantiles to be used in different blocks of different partial least square components to decide the proportion of features to be retained. The best combinations of quantiles can be chosen from a set of user-defined quantiles combinations by cross-validation. By doing this, it enables us to do the feature selection for different blocks, and the selected features can then be further used to predict the outcome. For example, in biomedical applications, clinical covariates plus different types of omics data such as microbiome, metabolome, mRNA data, methylation data, copy number variation data might be predictive for patients outcome such as survival time or response to therapy. Different types of data could be put in different blocks and along with survival time to fit the model. The fitted model can then be used to predict the survival for the new samples with the corresponding clinical covariates and omics data. In addition, Adaptive Sparse Multi-block Partial Least Square Discriminant Analysis is also included, which extends Adaptive Sparse Multi-block Partial Least Square for classifying the categorical outcome.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.5.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> Rcpp (&gt;= 1.0.8), ggplot2, ggpubr, stats</td>
</tr>
<tr>
 <td style="text-align: left;">
LinkingTo: </td><td style="text-align: left;"> Rcpp, RcppArmadillo</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 7.2.3</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> true</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> knitr, rmarkdown</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Runzhi Zhang [aut, cre],
  Susmita Datta [aut, ths]</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Runzhi Zhang &lt;runzhi.zhang@ufl.edu&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Archs: </td><td style="text-align: left;"> x64</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
asmbPLS-package         Predicting and Classifying Patient Phenotypes
                        with Multi-Omics Data
asmbPLS.cv              Cross-validation for asmbPLS to find the best
                        combinations of quantiles for prediction
asmbPLS.example         Example data for asmbPLS algorithm
asmbPLS.fit             asmbPLS for block-structured data
asmbPLS.predict         Using an asmbPLS model for prediction of new
                        samples
asmbPLSDA.cv            Cross-validation for asmbPLS-DA to find the
                        best combinations of quantiles for
                        classification
asmbPLSDA.example       Example data for asmbPLS-DA algorithm
asmbPLSDA.fit           asmbPLS-DA for block-structured data
asmbPLSDA.predict       Using an asmbPLS-DA model for classification of
                        new samples
asmbPLSDA.vote.fit      asmbPLS-DA vote model fit
asmbPLSDA.vote.predict
                        Using an asmbPLS-DA vote model for
                        classification of new samples
mbPLS.fit               mbPLS for block-structured data
meanimp                 Mean imputation for the survival time
plotCor                 Graphical output for the asmbPLS-DA framework
plotPLS                 PLS plot for asmbPLS-DA
plotRelevance           Relevance plot for asmbPLS-DA
quantileComb            Create the quantile combination set for asmbPLS
                        and asmbPLS-DA
to.categorical          Converts a class vector to a binary class
                        matrix
</pre>


<h3>Author(s)</h3>

<p>Runzhi Zhang [aut, cre],
  Susmita Datta [aut, ths]
</p>
<p>Maintainer: Runzhi Zhang &lt;runzhi.zhang@ufl.edu&gt;
</p>


<h3>References</h3>

<p>add later
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asmbPLS.fit">asmbPLS.fit</a></code>, <code><a href="#topic+asmbPLS.cv">asmbPLS.cv</a></code>, <code><a href="#topic+asmbPLS.predict">asmbPLS.predict</a></code>, <code><a href="#topic+mbPLS.fit">mbPLS.fit</a></code>, <code><a href="#topic+meanimp">meanimp</a></code>
</p>

<hr>
<h2 id='asmbPLS.cv'>Cross-validation for asmbPLS to find the best combinations of quantiles for prediction</h2><span id='topic+asmbPLS.cv'></span>

<h3>Description</h3>

<p>Function to find the best combinations of quantiles used for prediction via
cross-validation. Usually should be conducted before 
<code><a href="#topic+asmbPLS.fit">asmbPLS.fit</a></code> to obtain the quantile combinations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asmbPLS.cv(
  X.matrix,
  Y.matrix,
  PLS.comp,
  X.dim,
  quantile.comb.table,
  Y.indicator,
  k = 5,
  ncv = 5,
  only.observe = TRUE,
  expected.measure.decrease = 0.05,
  center = TRUE,
  scale = TRUE,
  maxiter = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asmbPLS.cv_+3A_x.matrix">X.matrix</code></td>
<td>
<p>Predictors matrix. Samples in rows, variables in columns.</p>
</td></tr>
<tr><td><code id="asmbPLS.cv_+3A_y.matrix">Y.matrix</code></td>
<td>
<p>Outcome matrix. Samples in rows, this is a matrix with one 
column (continuous variable). The outcome could be imputed survival time or 
other types of continuous outcome. For survival time with right-censored 
survival time and event indicator, the right censored time could be imputed 
by <code><a href="#topic+meanimp">meanimp</a></code>.</p>
</td></tr>
<tr><td><code id="asmbPLS.cv_+3A_pls.comp">PLS.comp</code></td>
<td>
<p>Number of PLS components in asmbPLS.</p>
</td></tr>
<tr><td><code id="asmbPLS.cv_+3A_x.dim">X.dim</code></td>
<td>
<p>A vector containing the number of predictors in each block 
(ordered).</p>
</td></tr>
<tr><td><code id="asmbPLS.cv_+3A_quantile.comb.table">quantile.comb.table</code></td>
<td>
<p>A matrix containing user-defined quantile 
combinations used for CV, whose column number equals to the 
number of blocks.</p>
</td></tr>
<tr><td><code id="asmbPLS.cv_+3A_y.indicator">Y.indicator</code></td>
<td>
<p>A vector containing the event indicator for each sample, 
whose length is equal to the number of samples. This vector allows the ratio 
of observed/unobserved to be the same in the training set and validation set. 
Observed = 1, and unobserved = 0. If other types of outcome data rather than 
survival outcome is used, you can use a vector with all components = 1 
instead.</p>
</td></tr>
<tr><td><code id="asmbPLS.cv_+3A_k">k</code></td>
<td>
<p>The number of folds of CV procedure. The default is 5.</p>
</td></tr>
<tr><td><code id="asmbPLS.cv_+3A_ncv">ncv</code></td>
<td>
<p>The number of repetitions of CV. The default is 5.</p>
</td></tr>
<tr><td><code id="asmbPLS.cv_+3A_only.observe">only.observe</code></td>
<td>
<p>Whether only observed samples in the validation set 
should be used for calculating the MSE for CV. The default is TRUE.</p>
</td></tr>
<tr><td><code id="asmbPLS.cv_+3A_expected.measure.decrease">expected.measure.decrease</code></td>
<td>
<p>The measure you expect to decrease by percent 
after including one more PLS component, which will affect the selection of optimal 
PLS components. The default is 0.05 (5%).</p>
</td></tr>
<tr><td><code id="asmbPLS.cv_+3A_center">center</code></td>
<td>
<p>A logical value indicating whether mean center should be 
implemented for X.matrix and Y.matrix. The default is TRUE.</p>
</td></tr>
<tr><td><code id="asmbPLS.cv_+3A_scale">scale</code></td>
<td>
<p>A logical value indicating whether scale should be 
implemented for X.matrix and Y.matrix. The default is TRUE.</p>
</td></tr>
<tr><td><code id="asmbPLS.cv_+3A_maxiter">maxiter</code></td>
<td>
<p>A integer indicating the maximum number of iteration. The
default number is 100.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>asmbPLS.cv</code> returns a list containing the following components:
</p>
<table>
<tr><td><code>quantile_table_CV</code></td>
<td>
<p>A matrix containing the selected quantile 
combination and the corresponding measures of CV for each PLS component.</p>
</td></tr>
<tr><td><code>optimal_nPLS</code></td>
<td>
<p>Optimal number of PLS components.</p>
</td></tr></table>
<p>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use the example dataset
data(asmbPLS.example)
X.matrix = asmbPLS.example$X.matrix
Y.matrix = asmbPLS.example$Y.matrix
PLS.comp = asmbPLS.example$PLS.comp
X.dim = asmbPLS.example$X.dim
quantile.comb.table.cv = asmbPLS.example$quantile.comb.table.cv
Y.indicator = asmbPLS.example$Y.indicator

## cv to find the best quantile combinations for model fitting
cv.results &lt;- asmbPLS.cv(X.matrix = X.matrix, 
                         Y.matrix = Y.matrix, 
                         PLS.comp = PLS.comp, 
                         X.dim = X.dim, 
                         quantile.comb.table = quantile.comb.table.cv, 
                         Y.indicator = Y.indicator,
                         k = 5,
                         ncv = 3)
quantile.comb &lt;- cv.results$quantile_table_CV[,1:length(X.dim)]
n.PLS &lt;- cv.results$optimal_nPLS
 
## asmbPLS fit
asmbPLS.results &lt;- asmbPLS.fit(X.matrix = X.matrix, 
                               Y.matrix = Y.matrix, 
                               PLS.comp = n.PLS, 
                               X.dim = X.dim, 
                               quantile.comb = quantile.comb)

</code></pre>

<hr>
<h2 id='asmbPLS.example'>Example data for asmbPLS algorithm</h2><span id='topic+asmbPLS.example'></span>

<h3>Description</h3>

<p>Simulated data for asmbPLS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(asmbPLS.example)
</code></pre>


<h3>Format</h3>

<p>A list including 8 components:  
</p>
<p>1) <code>X.matrix</code>, a matrix with 100 samples (rows) and 400 features (columns, 1-200 are microbial taxa, 201-400 are metabolites); 
</p>
<p>2) <code>X.matrix.new</code>, a matrix to be predicted with 100 samples (rows) and 400 features (columns, 1-200 are microbial taxa, 201-400 are metabolites); 
</p>
<p>3) <code>Y.matrix</code>, a matrix with 100 samples (rows) and 1 column (log-transformed survival time); 
</p>
<p>4) <code>X.dim</code>, dimension of the two blocks in X.matrix; 
</p>
<p>5) <code>PLS.comp</code>, selected number of PLS components;
</p>
<p>6) <code>quantile.comb</code>, selected quantile combinations; 
</p>
<p>7) <code>quantile.comb.table.cv</code>, pre-defined quantile combinations for cross validation;
</p>
<p>8) <code>Y.indicator</code>, a vector containing the event indicator for each sample.
</p>

<hr>
<h2 id='asmbPLS.fit'>asmbPLS for block-structured data</h2><span id='topic+asmbPLS.fit'></span>

<h3>Description</h3>

<p>Function to fit the adaptive sparse multi-block partial least square model 
(asmbPLS) with several explanatory blocks <code class="reqn">(X_1, ..., X_B)</code> as our predictors
to explain the outcome Y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asmbPLS.fit(
  X.matrix,
  Y.matrix,
  PLS.comp,
  X.dim,
  quantile.comb,
  center = TRUE,
  scale = TRUE,
  maxiter = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asmbPLS.fit_+3A_x.matrix">X.matrix</code></td>
<td>
<p>Predictors matrix. Samples in rows, variables in columns.</p>
</td></tr>
<tr><td><code id="asmbPLS.fit_+3A_y.matrix">Y.matrix</code></td>
<td>
<p>Outcome matrix. Samples in rows, this is a matrix with one 
column (continuous variable). The outcome could be imputed survival time. 
For survival time with right-censored survival time and event indicator, the 
right censored time could be imputed by <code><a href="#topic+meanimp">meanimp</a></code>.</p>
</td></tr>
<tr><td><code id="asmbPLS.fit_+3A_pls.comp">PLS.comp</code></td>
<td>
<p>Number of PLS components in asmbPLS.</p>
</td></tr>
<tr><td><code id="asmbPLS.fit_+3A_x.dim">X.dim</code></td>
<td>
<p>A vector containing the number of predictors in each block 
(ordered).</p>
</td></tr>
<tr><td><code id="asmbPLS.fit_+3A_quantile.comb">quantile.comb</code></td>
<td>
<p>A matrix containing quantile combinations used for 
different PLS components, whose row number equals to the number of PLS 
components used, column number equals to the number of blocks.</p>
</td></tr>
<tr><td><code id="asmbPLS.fit_+3A_center">center</code></td>
<td>
<p>A logical value indicating whether mean center should be 
implemented for X.matrix and Y.matrix. The default is TRUE.</p>
</td></tr>
<tr><td><code id="asmbPLS.fit_+3A_scale">scale</code></td>
<td>
<p>A logical value indicating whether scale should be 
implemented for X.matrix and Y.matrix. The default is TRUE.</p>
</td></tr>
<tr><td><code id="asmbPLS.fit_+3A_maxiter">maxiter</code></td>
<td>
<p>A integer indicating the maximum number of iteration. The
default number is 100.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>asmbPLS.fit</code> returns a list containing the following components:
</p>
<table>
<tr><td><code>X_dim</code></td>
<td>
<p>A vector containing the number of predictors in each block.</p>
</td></tr>
<tr><td><code>X_weight</code></td>
<td>
<p>A list containing the weights of predictors for different 
blocks in different PLS components.</p>
</td></tr>
<tr><td><code>X_score</code></td>
<td>
<p>A list containing the scores of samples in different blocks
in different PLS components.</p>
</td></tr>
<tr><td><code>X_loading</code></td>
<td>
<p>A list containing the loadings of predictors for different
blocks in different PLS components.</p>
</td></tr>
<tr><td><code>X_super_weight</code></td>
<td>
<p>A matrix containing the super weights of different
blocks for different PLS components.</p>
</td></tr>
<tr><td><code>X_super_score</code></td>
<td>
<p>A matrix containing the super scores of samples for
different PLS components.</p>
</td></tr>
<tr><td><code>Y_weight</code></td>
<td>
<p>A matrix containing the weights of outcome for different 
PLS components.</p>
</td></tr>
<tr><td><code>Y_score</code></td>
<td>
<p>A matrix containing the scores of outcome for different 
PLS components.</p>
</td></tr>
<tr><td><code>X_col_mean</code></td>
<td>
<p>A matrix containing the mean of each predictor for scaling.</p>
</td></tr>
<tr><td><code>Y_col_mean</code></td>
<td>
<p>The mean of outcome matrix for scaling.</p>
</td></tr>
<tr><td><code>X_col_sd</code></td>
<td>
<p>A matrix containing the standard deviation of each predictor
for scaling. Predictor with sd = 0 will be set to 1.</p>
</td></tr>
<tr><td><code>Y_col_sd</code></td>
<td>
<p>The standard deviation of outcome matrix for scaling.</p>
</td></tr>
<tr><td><code>center</code></td>
<td>
<p>A logical value indicating whether mean center is
implemented for X.matrix and Y.matrix.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>A logical value indicating whether scale is implemented for 
X.matrix and Y.matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Use the example dataset
data(asmbPLS.example)
X.matrix = asmbPLS.example$X.matrix
Y.matrix = asmbPLS.example$Y.matrix
PLS.comp = asmbPLS.example$PLS.comp
X.dim = asmbPLS.example$X.dim
quantile.comb = asmbPLS.example$quantile.comb
 
## asmbPLS fit
asmbPLS.results &lt;- asmbPLS.fit(X.matrix = X.matrix, 
                               Y.matrix = Y.matrix, 
                               PLS.comp = PLS.comp, 
                               X.dim = X.dim, 
                               quantile.comb = quantile.comb)

</code></pre>

<hr>
<h2 id='asmbPLS.predict'>Using an asmbPLS model for prediction of new samples</h2><span id='topic+asmbPLS.predict'></span>

<h3>Description</h3>

<p>Derives predictions for new samples from a model fitted by the function
<code><a href="#topic+asmbPLS.fit">asmbPLS.fit</a></code> or <code><a href="#topic+mbPLS.fit">mbPLS.fit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asmbPLS.predict(fit.results, X.matrix.new, PLS.comp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asmbPLS.predict_+3A_fit.results">fit.results</code></td>
<td>
<p>The output of either <code><a href="#topic+asmbPLS.fit">asmbPLS.fit</a></code> or 
<code><a href="#topic+mbPLS.fit">mbPLS.fit</a></code>.</p>
</td></tr>
<tr><td><code id="asmbPLS.predict_+3A_x.matrix.new">X.matrix.new</code></td>
<td>
<p>A predictors matrix, whose predictors are the same as 
the predictors in model fitting.</p>
</td></tr>
<tr><td><code id="asmbPLS.predict_+3A_pls.comp">PLS.comp</code></td>
<td>
<p>Number of PLS components used for prediction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>asmbPLSDA.predict</code> returns a list containing the following components:
</p>
<table>
<tr><td><code>Y_pred</code></td>
<td>
<p>Predicted value for the new sampels.</p>
</td></tr>
<tr><td><code>NewX_super_score</code></td>
<td>
<p>Predicted super score for new samples, which can be
used as predictors for other regression models.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Use the example dataset
data(asmbPLS.example)
X.matrix = asmbPLS.example$X.matrix
X.matrix.new = asmbPLS.example$X.matrix.new
Y.matrix = asmbPLS.example$Y.matrix
PLS.comp = asmbPLS.example$PLS.comp
X.dim = asmbPLS.example$X.dim
quantile.comb = asmbPLS.example$quantile.comb
 
## asmbPLS fit
asmbPLS.results &lt;- asmbPLS.fit(X.matrix = X.matrix, 
                               Y.matrix = Y.matrix, 
                               PLS.comp = PLS.comp, 
                               X.dim = X.dim, 
                               quantile.comb = quantile.comb)

## asmbPLS prediction for the new data, you could use different numbers of 
## PLS components for prediction
## Use only the first PLS component 
Y.pred.1 &lt;- asmbPLS.predict(asmbPLS.results, X.matrix.new, 1)
## Use the first two PLS components
Y.pred.2 &lt;- asmbPLS.predict(asmbPLS.results, X.matrix.new, 2)

</code></pre>

<hr>
<h2 id='asmbPLSDA.cv'>Cross-validation for asmbPLS-DA to find the best combinations of quantiles for classification</h2><span id='topic+asmbPLSDA.cv'></span>

<h3>Description</h3>

<p>Function to find the best combinations of quantiles used for classification via
cross-validation. Usually should be conducted before 
<code><a href="#topic+asmbPLSDA.fit">asmbPLSDA.fit</a></code> to obtain the quantile combinations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asmbPLSDA.cv(
  X.matrix,
  Y.matrix,
  PLS.comp,
  X.dim,
  quantile.comb.table,
  outcome.type,
  method = NULL,
  measure = "B_accuracy",
  k = 5,
  ncv = 5,
  expected.measure.increase = 0.005,
  center = TRUE,
  scale = TRUE,
  maxiter = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asmbPLSDA.cv_+3A_x.matrix">X.matrix</code></td>
<td>
<p>Predictors matrix. Samples in rows, variables in columns.</p>
</td></tr>
<tr><td><code id="asmbPLSDA.cv_+3A_y.matrix">Y.matrix</code></td>
<td>
<p>Outcome matrix. Samples in rows, this is a matrix with one 
column (binary) or multiple columns (more than 2 levels, dummy variables).</p>
</td></tr>
<tr><td><code id="asmbPLSDA.cv_+3A_pls.comp">PLS.comp</code></td>
<td>
<p>Number of PLS components in asmbPLS-DA.</p>
</td></tr>
<tr><td><code id="asmbPLSDA.cv_+3A_x.dim">X.dim</code></td>
<td>
<p>A vector containing the number of predictors in each block 
(ordered).</p>
</td></tr>
<tr><td><code id="asmbPLSDA.cv_+3A_quantile.comb.table">quantile.comb.table</code></td>
<td>
<p>A matrix containing user-defined quantile 
combinations used for CV, whose column number equals to the 
number of blocks.</p>
</td></tr>
<tr><td><code id="asmbPLSDA.cv_+3A_outcome.type">outcome.type</code></td>
<td>
<p>The type of the outcome Y. &quot;<code>binary</code>&quot; for binary 
outcome, and &quot;<code>multiclass</code>&quot; for categorical outcome with more than 2 
levels.</p>
</td></tr>
<tr><td><code id="asmbPLSDA.cv_+3A_method">method</code></td>
<td>
<p>Decision rule used for CV. For binary outcome, the 
methods include &quot;<code>fixed_cutoff</code>&quot;, &quot;<code>Euclidean_distance_X</code>&quot; and
&quot;<code>Mahalanobis_distance_X</code>&quot;. For categorical outcome with more than 2 
levels, the methods include &quot;<code>Max_Y</code>&quot;, &quot;<code>Euclidean_distance_X</code>&quot;,
&quot;<code>Mahalanobis_distance_X</code>&quot;, &quot;<code>Euclidean_distance_Y</code>&quot;, and 
&quot;<code>PCA_Mahalanobis_distance_Y</code>&quot;.</p>
</td></tr>
<tr><td><code id="asmbPLSDA.cv_+3A_measure">measure</code></td>
<td>
<p>Five measures are available: overall accuracy <code>accuracy</code>,
balanced accuracy <code>B_accuracy</code>, precision <code>precision</code>, recall
<code>recall</code>, F1 score <code>F1</code>.</p>
</td></tr>
<tr><td><code id="asmbPLSDA.cv_+3A_k">k</code></td>
<td>
<p>The number of folds of CV procedure. The default is 5.</p>
</td></tr>
<tr><td><code id="asmbPLSDA.cv_+3A_ncv">ncv</code></td>
<td>
<p>The number of repetitions of CV. The default is 5.</p>
</td></tr>
<tr><td><code id="asmbPLSDA.cv_+3A_expected.measure.increase">expected.measure.increase</code></td>
<td>
<p>The measure you expect to increase after 
including one more PLS component, which will affect the selection of optimal 
PLS components. The default is 0.005.</p>
</td></tr>
<tr><td><code id="asmbPLSDA.cv_+3A_center">center</code></td>
<td>
<p>A logical value indicating whether weighted mean center should 
be implemented for <code>X.matrix</code> and <code>Y.matrix</code>. The default is TRUE.</p>
</td></tr>
<tr><td><code id="asmbPLSDA.cv_+3A_scale">scale</code></td>
<td>
<p>A logical value indicating whether scale should be 
implemented for <code>X.matrix</code>. The default is TRUE.</p>
</td></tr>
<tr><td><code id="asmbPLSDA.cv_+3A_maxiter">maxiter</code></td>
<td>
<p>A integer indicating the maximum number of iteration. The
default number is 100.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>asmbPLSDA.cv</code> returns a list containing the following components:
</p>
<table>
<tr><td><code>quantile_table_CV</code></td>
<td>
<p>A matrix containing the selected quantile 
combination and the corresponding measures of CV for each PLS component.</p>
</td></tr>
<tr><td><code>optimal_nPLS</code></td>
<td>
<p>Optimal number of PLS components.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Use the example dataset
data(asmbPLSDA.example)
X.matrix = asmbPLSDA.example$X.matrix
Y.matrix.binary = asmbPLSDA.example$Y.matrix.binary
Y.matrix.multiclass = asmbPLSDA.example$Y.matrix.morethan2levels
X.dim = asmbPLSDA.example$X.dim
PLS.comp = asmbPLSDA.example$PLS.comp
quantile.comb.table.cv = asmbPLSDA.example$quantile.comb.table.cv

## cv to find the best quantile combinations for model fitting (binary outcome)
cv.results.binary &lt;- asmbPLSDA.cv(X.matrix = X.matrix, 
                                  Y.matrix = Y.matrix.binary, 
                                  PLS.comp = PLS.comp, 
                                  X.dim = X.dim, 
                                  quantile.comb.table = quantile.comb.table.cv, 
                                  outcome.type = "binary",
                                  k = 3,
                                  ncv = 3)
quantile.comb.binary &lt;- cv.results.binary$quantile_table_CV[,1:length(X.dim)]
n.PLS.binary &lt;- cv.results.binary$optimal_nPLS

## asmbPLSDA fit using the selected quantile combination (binary outcome)
asmbPLSDA.fit.binary &lt;- asmbPLSDA.fit(X.matrix = X.matrix, 
                                      Y.matrix = Y.matrix.binary, 
                                      PLS.comp = n.PLS.binary, 
                                      X.dim = X.dim, 
                                      quantile.comb = quantile.comb.binary,
                                      outcome.type = "binary")


## cv to find the best quantile combinations for model fitting 
## (categorical outcome with more than 2 levels)
cv.results.multiclass &lt;- asmbPLSDA.cv(X.matrix = X.matrix, 
                                      Y.matrix = Y.matrix.multiclass, 
                                      PLS.comp = PLS.comp, 
                                      X.dim = X.dim, 
                                      quantile.comb.table = quantile.comb.table.cv, 
                                      outcome.type = "multiclass",
                                      k = 3,
                                      ncv = 2)
quantile.comb.multiclass &lt;- cv.results.multiclass$quantile_table_CV[,1:length(X.dim)]
n.PLS.multiclass &lt;- cv.results.multiclass$optimal_nPLS

## asmbPLSDA fit (categorical outcome with more than 2 levels)
asmbPLSDA.fit.multiclass &lt;- asmbPLSDA.fit(X.matrix = X.matrix, 
                                          Y.matrix = Y.matrix.multiclass, 
                                          PLS.comp = n.PLS.multiclass, 
                                          X.dim = X.dim, 
                                          quantile.comb = quantile.comb.multiclass,
                                          outcome.type = "multiclass")

</code></pre>

<hr>
<h2 id='asmbPLSDA.example'>Example data for asmbPLS-DA algorithm</h2><span id='topic+asmbPLSDA.example'></span>

<h3>Description</h3>

<p>Simulated data for asmbPLS-DA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(asmbPLSDA.example)
</code></pre>


<h3>Format</h3>

<p>A list including 8 components:  
</p>
<p>1) <code>X.matrix</code>, a matrix with 100 samples (rows) and 400 features, features 1-200 are from block 1 and features 201-400 are from block 2; 
</p>
<p>2) <code>X.matrix.new</code>, a matrix to be predicted with 100 samples (rows) and 400 features, features 1-200 are from block 1 and features 201-400 are from block 2;  
</p>
<p>3) <code>Y.matrix.binary</code>, a matrix with 100 samples (rows) and 1 column; 
</p>
<p>4) <code>Y.matrix.morethan2levels</code>, a matrix with 100 samples (rows) and 3 columns (3 levels);
</p>
<p>5) <code>X.dim</code>, dimension of the two blocks in X.matrix; 
</p>
<p>6) <code>PLS.comp</code>, selected number of PLS components; 
</p>
<p>7) <code>quantile.comb</code>, selected quantile combinations;
</p>
<p>8) <code>quantile.comb.table.cv</code>, pre-defined quantile combinations for cross validation.
</p>

<hr>
<h2 id='asmbPLSDA.fit'>asmbPLS-DA for block-structured data</h2><span id='topic+asmbPLSDA.fit'></span>

<h3>Description</h3>

<p>Function to fit the adaptive sparse multi-block partial least square 
discriminant analysis (asmbPLS-DA) model with several explanatory blocks 
<code class="reqn">(X_1, ..., X_B)</code> as our predictors to explain the categorical outcome Y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asmbPLSDA.fit(
  X.matrix,
  Y.matrix,
  PLS.comp,
  X.dim,
  quantile.comb,
  outcome.type,
  center = TRUE,
  scale = TRUE,
  maxiter = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asmbPLSDA.fit_+3A_x.matrix">X.matrix</code></td>
<td>
<p>Predictors matrix. Samples in rows, variables in columns</p>
</td></tr>
<tr><td><code id="asmbPLSDA.fit_+3A_y.matrix">Y.matrix</code></td>
<td>
<p>Outcome matrix. Samples in rows, this is a matrix with one 
column (binary) or multiple columns (more than 2 levels, dummy variables).</p>
</td></tr>
<tr><td><code id="asmbPLSDA.fit_+3A_pls.comp">PLS.comp</code></td>
<td>
<p>Number of PLS components in asmbPLS-DA.</p>
</td></tr>
<tr><td><code id="asmbPLSDA.fit_+3A_x.dim">X.dim</code></td>
<td>
<p>A vector containing the number of predictors in each block 
(ordered).</p>
</td></tr>
<tr><td><code id="asmbPLSDA.fit_+3A_quantile.comb">quantile.comb</code></td>
<td>
<p>A matrix containing quantile combinations used for 
different PLS components, whose row number equals to the number of PLS 
components used, column number equals to the number of blocks.</p>
</td></tr>
<tr><td><code id="asmbPLSDA.fit_+3A_outcome.type">outcome.type</code></td>
<td>
<p>The type of the outcome Y. &quot;<code>binary</code>&quot; for binary 
outcome, and &quot;<code>multiclass</code>&quot; for categorical outcome with more than 2 
levels.</p>
</td></tr>
<tr><td><code id="asmbPLSDA.fit_+3A_center">center</code></td>
<td>
<p>A logical value indicating whether weighted mean center should 
be implemented for X.matrix and Y.matrix. The default is TRUE.</p>
</td></tr>
<tr><td><code id="asmbPLSDA.fit_+3A_scale">scale</code></td>
<td>
<p>A logical value indicating whether scale should be 
implemented for X.matrix. The default is TRUE.</p>
</td></tr>
<tr><td><code id="asmbPLSDA.fit_+3A_maxiter">maxiter</code></td>
<td>
<p>A integer indicating the maximum number of iteration. The
default number is 100.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>asmbPLSDA.fit</code> returns a list containing the following components:
</p>
<table>
<tr><td><code>X_dim</code></td>
<td>
<p>A vector containing the number of predictors in each block.</p>
</td></tr>
<tr><td><code>X_weight</code></td>
<td>
<p>A list containing the weights of predictors for different 
blocks in different PLS components.</p>
</td></tr>
<tr><td><code>X_score</code></td>
<td>
<p>A list containing the scores of samples in different blocks
in different PLS components.</p>
</td></tr>
<tr><td><code>X_loading</code></td>
<td>
<p>A list containing the loadings of predictors for different
blocks in different PLS components.</p>
</td></tr>
<tr><td><code>X_super_weight</code></td>
<td>
<p>A matrix containing the super weights of different
blocks for different PLS components.</p>
</td></tr>
<tr><td><code>X_super_score</code></td>
<td>
<p>A matrix containing the super scores of samples for
different PLS components.</p>
</td></tr>
<tr><td><code>Y_weight</code></td>
<td>
<p>A matrix containing the weights of outcome for different 
PLS components.</p>
</td></tr>
<tr><td><code>Y_score</code></td>
<td>
<p>A matrix containing the scores of outcome for different 
PLS components.</p>
</td></tr>
<tr><td><code>X_col_mean</code></td>
<td>
<p>A matrix containing the weighted mean of each predictor 
for scaling.</p>
</td></tr>
<tr><td><code>Y_col_mean</code></td>
<td>
<p>The weighted mean of outcome matrix for scaling.</p>
</td></tr>
<tr><td><code>X_col_sd</code></td>
<td>
<p>A matrix containing the standard deviation (sd) of each 
predictor for scaling. sd for predictors with sd = 0 will be changed to 1.</p>
</td></tr>
<tr><td><code>center</code></td>
<td>
<p>A logical value indicating whether weighted mean center is
implemented for X.matrix and Y.matrix.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>A logical value indicating whether scale is implemented for 
X.matrix.</p>
</td></tr>
<tr><td><code>Outcome_type</code></td>
<td>
<p>The type of the outcome Y. &quot;<code>binary</code>&quot; for binary 
outcome, and &quot;<code>multiclass</code>&quot; for categorical outcome with more than 2
levels.</p>
</td></tr>
<tr><td><code>Y_group</code></td>
<td>
<p>Original Y.matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Use the example dataset
data(asmbPLSDA.example)
X.matrix = asmbPLSDA.example$X.matrix
Y.matrix.binary = asmbPLSDA.example$Y.matrix.binary
Y.matrix.multiclass = asmbPLSDA.example$Y.matrix.morethan2levels
X.dim = asmbPLSDA.example$X.dim
PLS.comp = asmbPLSDA.example$PLS.comp
quantile.comb = asmbPLSDA.example$quantile.comb
 
## asmbPLSDA fit for binary outcome
asmbPLSDA.fit.binary &lt;- asmbPLSDA.fit(X.matrix = X.matrix, 
                                      Y.matrix = Y.matrix.binary, 
                                      PLS.comp = PLS.comp, 
                                      X.dim = X.dim, 
                                      quantile.comb = quantile.comb,
                                      outcome.type = "binary")

## asmbPLSDA fit for categorical outcome with more than 2 levels
asmbPLSDA.fit.multiclass &lt;- asmbPLSDA.fit(X.matrix = X.matrix, 
                                          Y.matrix = Y.matrix.multiclass, 
                                          PLS.comp = PLS.comp, 
                                          X.dim = X.dim, 
                                          quantile.comb = quantile.comb,
                                          outcome.type = "multiclass")

</code></pre>

<hr>
<h2 id='asmbPLSDA.predict'>Using an asmbPLS-DA model for classification of new samples</h2><span id='topic+asmbPLSDA.predict'></span>

<h3>Description</h3>

<p>Derives classification for new samples from a model fitted by the function
<code><a href="#topic+asmbPLSDA.fit">asmbPLSDA.fit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asmbPLSDA.predict(fit.results, X.matrix.new, PLS.comp, method = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asmbPLSDA.predict_+3A_fit.results">fit.results</code></td>
<td>
<p>The output of <code><a href="#topic+asmbPLSDA.fit">asmbPLSDA.fit</a></code></p>
</td></tr>
<tr><td><code id="asmbPLSDA.predict_+3A_x.matrix.new">X.matrix.new</code></td>
<td>
<p>A predictors matrix, whose predictors are the same as 
the predictors in model fitting.</p>
</td></tr>
<tr><td><code id="asmbPLSDA.predict_+3A_pls.comp">PLS.comp</code></td>
<td>
<p>Number of PLS components used for prediction.</p>
</td></tr>
<tr><td><code id="asmbPLSDA.predict_+3A_method">method</code></td>
<td>
<p>Decision rule used for prediction. For binary outcome, the 
methods include &quot;<code>fixed_cutoff</code>&quot; (default), &quot;<code>Euclidean_distance_X</code>&quot; 
and &quot;<code>Mahalanobis_distance_X</code>&quot;. For categorical outcome with more than 2 
levels, the methods include &quot;<code>Max_Y</code>&quot; (default), 
&quot;<code>Euclidean_distance_X</code>&quot;, &quot;<code>Mahalanobis_distance_X</code>&quot;, 
&quot;<code>Euclidean_distance_Y</code>&quot;, and &quot;<code>PCA_Mahalanobis_distance_Y</code>&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>asmbPLSDA.predict</code> returns a list containing the following components:
</p>
<table>
<tr><td><code>Y_pred</code></td>
<td>
<p>Predicted class for the new sampels.</p>
</td></tr>
<tr><td><code>Y_pred_numeric</code></td>
<td>
<p>Predicted Y values for the new samples, different 
decision rules can be used to obtain different Y_pred.</p>
</td></tr>
<tr><td><code>NewX_super_score</code></td>
<td>
<p>Predicted super score for new samples, which can be
used as predictors for other classification algorithms.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Decision rule used for preidction.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Use the example dataset
data(asmbPLSDA.example)
X.matrix = asmbPLSDA.example$X.matrix
X.matrix.new = asmbPLSDA.example$X.matrix.new
Y.matrix.binary = asmbPLSDA.example$Y.matrix.binary
Y.matrix.multiclass = asmbPLSDA.example$Y.matrix.morethan2levels
X.dim = asmbPLSDA.example$X.dim
PLS.comp = asmbPLSDA.example$PLS.comp
quantile.comb = asmbPLSDA.example$quantile.comb
 
## asmbPLSDA fit for binary outcome
asmbPLSDA.fit.binary &lt;- asmbPLSDA.fit(X.matrix = X.matrix, 
                                      Y.matrix = Y.matrix.binary, 
                                      PLS.comp = PLS.comp, 
                                      X.dim = X.dim, 
                                      quantile.comb = quantile.comb,
                                      outcome.type = "binary")

## asmbPLSDA fit for categorical outcome with more than 2 levels
asmbPLSDA.fit.multiclass &lt;- asmbPLSDA.fit(X.matrix = X.matrix, 
                                          Y.matrix = Y.matrix.multiclass,
                                          PLS.comp = PLS.comp, 
                                          X.dim = X.dim, 
                                          quantile.comb = quantile.comb,
                                          outcome.type = "multiclass")

## asmbPLSDA prediction for the new data, you could use different numbers of 
## PLS components for prediction
## Use only the first PLS component 
Y.pred.binary.1 &lt;- asmbPLSDA.predict(asmbPLSDA.fit.binary, 
                                     X.matrix.new, 
                                     PLS.comp = 1)
## Use the first two PLS components                                      
Y.pred.binary.2 &lt;- asmbPLSDA.predict(asmbPLSDA.fit.binary,
                                     X.matrix.new, 
                                     PLS.comp = 2)

## PLS components for prediction
Y.pred.multiclass.1 &lt;- asmbPLSDA.predict(asmbPLSDA.fit.multiclass,
                                         X.matrix.new, 
                                         PLS.comp = 1)
## Use the first two PLS components     
Y.pred.multiclass.2 &lt;- asmbPLSDA.predict(asmbPLSDA.fit.multiclass,
                                         X.matrix.new, 
                                         PLS.comp = 2)

</code></pre>

<hr>
<h2 id='asmbPLSDA.vote.fit'>asmbPLS-DA vote model fit</h2><span id='topic+asmbPLSDA.vote.fit'></span>

<h3>Description</h3>

<p>Function to fit multiple asmbPLS-DA models using cross validation results with 
different decision rules obtained from <code><a href="#topic+asmbPLSDA.cv">asmbPLSDA.cv</a></code>, 
the weight for each model are calculated based on cross-validation accuracy, 
which can be used for <code><a href="#topic+asmbPLSDA.vote.predict">asmbPLSDA.vote.predict</a></code> to obtain
the final classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asmbPLSDA.vote.fit(
  X.matrix,
  Y.matrix,
  X.dim,
  cv.results.list,
  nPLS,
  outcome.type,
  method = "weighted",
  measure = NULL,
  center = TRUE,
  scale = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asmbPLSDA.vote.fit_+3A_x.matrix">X.matrix</code></td>
<td>
<p>Predictors matrix. Samples in rows, variables in columns.</p>
</td></tr>
<tr><td><code id="asmbPLSDA.vote.fit_+3A_y.matrix">Y.matrix</code></td>
<td>
<p>Outcome matrix. Samples in rows, this is a matrix with one 
column (binary) or multiple columns (more than 2 levels, dummy variables).</p>
</td></tr>
<tr><td><code id="asmbPLSDA.vote.fit_+3A_x.dim">X.dim</code></td>
<td>
<p>A vector containing the number of predictors in each block 
(ordered).</p>
</td></tr>
<tr><td><code id="asmbPLSDA.vote.fit_+3A_cv.results.list">cv.results.list</code></td>
<td>
<p>A list containing <code>quantile_table_CV</code> from 
<code><a href="#topic+asmbPLSDA.cv">asmbPLSDA.cv</a></code> using different decision rules, the name
of each element in the list should be the corresponding name of decision 
rule.</p>
</td></tr>
<tr><td><code id="asmbPLSDA.vote.fit_+3A_npls">nPLS</code></td>
<td>
<p>A vector containing the number of PLS components used for 
different decision rules.</p>
</td></tr>
<tr><td><code id="asmbPLSDA.vote.fit_+3A_outcome.type">outcome.type</code></td>
<td>
<p>The type of the outcome Y. &quot;<code>binary</code>&quot; for binary 
outcome, and &quot;<code>multiclass</code>&quot; for categorical outcome with more than 2 
levels.</p>
</td></tr>
<tr><td><code id="asmbPLSDA.vote.fit_+3A_method">method</code></td>
<td>
<p>Vote options. &quot;<code>unweighted</code>&quot; gives each decision rule the 
same weight; &quot;<code>weighted</code>&quot; assigns higher weight to method with higher 
measure, i.e. weight = log(measure/(1-measure)); &quot;<code>ranked</code>&quot; ranks
the given methods based on the average rank of methods using accuracy, 
balanced accuracy, precision, recall and F1 score.</p>
</td></tr>
<tr><td><code id="asmbPLSDA.vote.fit_+3A_measure">measure</code></td>
<td>
<p>Measure to be selected when <code>method</code> is <code>weighted</code>. 
The default is <code>B_accuracy</code>.</p>
</td></tr>
<tr><td><code id="asmbPLSDA.vote.fit_+3A_center">center</code></td>
<td>
<p>A logical value indicating whether weighted mean center should 
be implemented for <code>X.matrix</code> and <code>Y.matrix</code>. The default is TRUE.</p>
</td></tr>
<tr><td><code id="asmbPLSDA.vote.fit_+3A_scale">scale</code></td>
<td>
<p>A logical value indicating whether scale should be 
implemented for <code>X.matrix</code>. The default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>asmbPLSDA.vote.fit</code> returns a list of lists, which can be used as the 
inputs for <code><a href="#topic+asmbPLSDA.vote.predict">asmbPLSDA.vote.predict</a></code>. Each list contains the 
fit information for model with specific decision rule: 
</p>
<table>
<tr><td><code>fit.model</code></td>
<td>
<p>A list containing model fit information.</p>
</td></tr>
<tr><td><code>nPLS</code></td>
<td>
<p>The number of PLS components used.</p>
</td></tr>
<tr><td><code>weight</code></td>
<td>
<p>The weight for this model.</p>
</td></tr>
<tr><td><code>outcome.type</code></td>
<td>
<p>The type of the outcome Y.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Use the example dataset
data(asmbPLSDA.example)
X.matrix = asmbPLSDA.example$X.matrix
X.matrix.new = asmbPLSDA.example$X.matrix.new
Y.matrix.binary = asmbPLSDA.example$Y.matrix.binary
X.dim = asmbPLSDA.example$X.dim
PLS.comp = asmbPLSDA.example$PLS.comp
quantile.comb.table.cv = asmbPLSDA.example$quantile.comb.table.cv

## Cross validaiton based on fixed cutoff
cv.results.cutoff &lt;- asmbPLSDA.cv(X.matrix = X.matrix, 
                                  Y.matrix = Y.matrix.binary,
                                  PLS.comp = PLS.comp, 
                                  X.dim = X.dim, 
                                  quantile.comb.table = quantile.comb.table.cv, 
                                  outcome.type = "binary", 
                                  method = "fixed_cutoff",
                                  k = 3,
                                  ncv = 1)
quantile.comb.cutoff &lt;- cv.results.cutoff$quantile_table_CV

## Cross validation using Euclidean distance of X super score
cv.results.EDX &lt;- asmbPLSDA.cv(X.matrix = X.matrix, 
                               Y.matrix = Y.matrix.binary,
                               PLS.comp = PLS.comp, 
                               X.dim = X.dim, 
                               quantile.comb.table = quantile.comb.table.cv, 
                               outcome.type = "binary", 
                               method = "Euclidean_distance_X",
                               k = 3,
                               ncv = 1)
quantile.comb.EDX &lt;- cv.results.EDX$quantile_table_CV

## Cross validation using Mahalanobis distance of X super score
cv.results.MDX &lt;- asmbPLSDA.cv(X.matrix = X.matrix, 
                                  Y.matrix = Y.matrix.binary,
                                  PLS.comp = PLS.comp, 
                                  X.dim = X.dim, 
                                  quantile.comb.table = quantile.comb.table.cv, 
                                  outcome.type = "binary", 
                                  method = "Mahalanobis_distance_X",
                                  k = 3,
                                  ncv = 1)
quantile.comb.MDX &lt;- cv.results.MDX$quantile_table_CV

#### vote list ####
cv.results.list = list(fixed_cutoff = quantile.comb.cutoff,
                       Euclidean_distance_X = quantile.comb.EDX,
                       Mahalanobis_distance_X = quantile.comb.MDX)

## vote models fit
vote.fit &lt;- asmbPLSDA.vote.fit(X.matrix = X.matrix, 
                               Y.matrix = Y.matrix.binary, 
                               X.dim = X.dim, 
                               nPLS = c(cv.results.cutoff$optimal_nPLS, 
                               cv.results.EDX$optimal_nPLS, 
                               cv.results.MDX$optimal_nPLS),
                               cv.results.list = cv.results.list, 
                               outcome.type = "binary",
                               method = "weighted")

</code></pre>

<hr>
<h2 id='asmbPLSDA.vote.predict'>Using an asmbPLS-DA vote model for classification of new samples</h2><span id='topic+asmbPLSDA.vote.predict'></span>

<h3>Description</h3>

<p>Function to make the classification using the weights and fitted model 
obtained from <code><a href="#topic+asmbPLSDA.vote.fit">asmbPLSDA.vote.fit</a></code>. The final classification 
results are the weighted classification using the decision rules included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asmbPLSDA.vote.predict(fit.results, X.matrix.new)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asmbPLSDA.vote.predict_+3A_fit.results">fit.results</code></td>
<td>
<p>The output of <code><a href="#topic+asmbPLSDA.vote.fit">asmbPLSDA.vote.fit</a></code>.</p>
</td></tr>
<tr><td><code id="asmbPLSDA.vote.predict_+3A_x.matrix.new">X.matrix.new</code></td>
<td>
<p>A predictors matrix, whose predictors are the same as 
the predictors in model fitting.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Y_pred</code></td>
<td>
<p>Predicted class for the new sampels.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Use the example dataset
data(asmbPLSDA.example)
X.matrix = asmbPLSDA.example$X.matrix
X.matrix.new = asmbPLSDA.example$X.matrix.new
Y.matrix.binary = asmbPLSDA.example$Y.matrix.binary
X.dim = asmbPLSDA.example$X.dim
PLS.comp = asmbPLSDA.example$PLS.comp
quantile.comb.table.cv = asmbPLSDA.example$quantile.comb.table.cv

## Cross validaiton based on fixed cutoff
cv.results.cutoff &lt;- asmbPLSDA.cv(X.matrix = X.matrix, 
                                  Y.matrix = Y.matrix.binary,
                                  PLS.comp = PLS.comp, 
                                  X.dim = X.dim, 
                                  quantile.comb.table = quantile.comb.table.cv, 
                                  outcome.type = "binary", 
                                  method = "fixed_cutoff",
                                  k = 3,
                                  ncv = 1)
quantile.comb.cutoff &lt;- cv.results.cutoff$quantile_table_CV

## Cross validation using Euclidean distance of X super score
cv.results.EDX &lt;- asmbPLSDA.cv(X.matrix = X.matrix, 
                               Y.matrix = Y.matrix.binary,
                               PLS.comp = PLS.comp, 
                               X.dim = X.dim, 
                               quantile.comb.table = quantile.comb.table.cv, 
                               outcome.type = "binary", 
                               method = "Euclidean_distance_X",
                               k = 3,
                               ncv = 1)
quantile.comb.EDX &lt;- cv.results.EDX$quantile_table_CV

## Cross validation using Mahalanobis distance of X super score
cv.results.MDX &lt;- asmbPLSDA.cv(X.matrix = X.matrix, 
                                  Y.matrix = Y.matrix.binary,
                                  PLS.comp = PLS.comp, 
                                  X.dim = X.dim, 
                                  quantile.comb.table = quantile.comb.table.cv, 
                                  outcome.type = "binary", 
                                  method = "Mahalanobis_distance_X",
                                  k = 3,
                                  ncv = 1)
quantile.comb.MDX &lt;- cv.results.MDX$quantile_table_CV

#### vote list ####
cv.results.list = list(fixed_cutoff = quantile.comb.cutoff,
                       Euclidean_distance_X = quantile.comb.EDX,
                       Mahalanobis_distance_X = quantile.comb.MDX)

## vote models fit
vote.fit &lt;- asmbPLSDA.vote.fit(X.matrix = X.matrix, 
                               Y.matrix = Y.matrix.binary, 
                               X.dim = X.dim, 
                               nPLS = c(cv.results.cutoff$optimal_nPLS, 
                               cv.results.EDX$optimal_nPLS, 
                               cv.results.MDX$optimal_nPLS),
                               cv.results.list = cv.results.list, 
                               outcome.type = "binary",
                               method = "weighted")

## classification
vote.predict &lt;- asmbPLSDA.vote.predict(vote.fit, X.matrix.new)

</code></pre>

<hr>
<h2 id='mbPLS.fit'>mbPLS for block-structured data</h2><span id='topic+mbPLS.fit'></span>

<h3>Description</h3>

<p>Function to fit the multi-block partial least square model 
(mbPLS) with several explanatory blocks <code class="reqn">(X_1, ..., X_B)</code> as our predictors
to explain the outcome Y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbPLS.fit(
  X.matrix,
  Y.matrix,
  PLS.comp,
  X.dim,
  center = TRUE,
  scale = TRUE,
  maxiter = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mbPLS.fit_+3A_x.matrix">X.matrix</code></td>
<td>
<p>Predictors matrix. Samples in rows, variables in columns.</p>
</td></tr>
<tr><td><code id="mbPLS.fit_+3A_y.matrix">Y.matrix</code></td>
<td>
<p>Outcome matrix. Samples in rows, this is a matrix with one 
column (continuous variable). The outcome could be imputed survival time. 
For survival time with right-censored survival time and event indicator, the 
right censored time could be imputed by <code><a href="#topic+meanimp">meanimp</a></code>.</p>
</td></tr>
<tr><td><code id="mbPLS.fit_+3A_pls.comp">PLS.comp</code></td>
<td>
<p>Number of PLS components in mbPLS.</p>
</td></tr>
<tr><td><code id="mbPLS.fit_+3A_x.dim">X.dim</code></td>
<td>
<p>A vector containing the number of predictors in each block 
(ordered).</p>
</td></tr>
<tr><td><code id="mbPLS.fit_+3A_center">center</code></td>
<td>
<p>A logical value indicating whether mean center should be 
implemented for X.matrix and Y.matrix. The default is TRUE.</p>
</td></tr>
<tr><td><code id="mbPLS.fit_+3A_scale">scale</code></td>
<td>
<p>A logical value indicating whether scale should be 
implemented for X.matrix and Y.matrix. The default is TRUE.</p>
</td></tr>
<tr><td><code id="mbPLS.fit_+3A_maxiter">maxiter</code></td>
<td>
<p>A integer indicating the maximum number of iteration. The
default number is 100.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mbPLS.fit</code> returns a list containing the following components:
</p>
<table>
<tr><td><code>X_dim</code></td>
<td>
<p>A vector containing the number of predictors in each block.</p>
</td></tr>
<tr><td><code>X_weight</code></td>
<td>
<p>A list containing the weights of predictors for different 
blocks in different PLS components.</p>
</td></tr>
<tr><td><code>X_score</code></td>
<td>
<p>A list containing the scores of samples in different blocks
in different PLS components.</p>
</td></tr>
<tr><td><code>X_loading</code></td>
<td>
<p>A list containing the loadings of predictors for different
blocks in different PLS components.</p>
</td></tr>
<tr><td><code>X_super_weight</code></td>
<td>
<p>A matrix containing the super weights of different
blocks for different PLS components.</p>
</td></tr>
<tr><td><code>X_super_score</code></td>
<td>
<p>A matrix containing the super scores of samples for
different PLS components.</p>
</td></tr>
<tr><td><code>Y_weight</code></td>
<td>
<p>A matrix containing the weights of outcome for different 
PLS components.</p>
</td></tr>
<tr><td><code>Y_score</code></td>
<td>
<p>A matrix containing the scores of outcome for different 
PLS components.</p>
</td></tr>
<tr><td><code>X_col_mean</code></td>
<td>
<p>A matrix containing the mean of each predictor for scaling.</p>
</td></tr>
<tr><td><code>Y_col_mean</code></td>
<td>
<p>The mean of outcome matrix for scaling.</p>
</td></tr>
<tr><td><code>X_col_sd</code></td>
<td>
<p>A matrix containing the standard deviation of each predictor
for scaling. Predictor with sd = 0 will be set to 1.</p>
</td></tr>
<tr><td><code>Y_col_sd</code></td>
<td>
<p>The standard deviation of outcome matrix for scaling.</p>
</td></tr>
<tr><td><code>center</code></td>
<td>
<p>A logical value indicating whether mean center is
implemented for X.matrix and Y.matrix.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>A logical value indicating whether scale is implemented for 
X.matrix and Y.matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Use the example dataset
data(asmbPLS.example)
X.matrix = asmbPLS.example$X.matrix 
Y.matrix = asmbPLS.example$Y.matrix
PLS.comp = asmbPLS.example$PLS.comp
X.dim = asmbPLS.example$X.dim
 
## mbPLS fit
mbPLS.results &lt;- mbPLS.fit(X.matrix = X.matrix, 
                           Y.matrix = Y.matrix, 
                           PLS.comp = PLS.comp, 
                           X.dim = X.dim)

</code></pre>

<hr>
<h2 id='meanimp'>Mean imputation for the survival time</h2><span id='topic+meanimp'></span>

<h3>Description</h3>

<p>In this approach, <code class="reqn">\mu</code> can be computed using the familiar sample mean
formula provided the censored values are imputed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanimp(survival.data, round = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanimp_+3A_survival.data">survival.data</code></td>
<td>
<p>A matrix of two columns with the first column indicates
the survival time and the second column indicates the event indicator (1 and 
0, where 1 indicates observed event and 0 indicates unobserved event).</p>
</td></tr>
<tr><td><code id="meanimp_+3A_round">round</code></td>
<td>
<p>Whether survival time should be rounded, default = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>meanimp</code> returns a list containing the following components:
</p>
<table>
<tr><td><code>imputed_table</code></td>
<td>
<p>A matrix containing the original survival data and the 
imputed time.</p>
</td></tr>
<tr><td><code>KM_table</code></td>
<td>
<p>Kaplan-Meier estimator of failure times.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate the survival data
data_test &lt;- matrix(c(1, 1, 1, 2.5, 5, 7, 1, 1, 0, 1, 0, 1), ncol = 2)

## Mean imputation
meanimp(data_test, round = FALSE)

</code></pre>

<hr>
<h2 id='plotCor'>Graphical output for the asmbPLS-DA framework</h2><span id='topic+plotCor'></span>

<h3>Description</h3>

<p>Function to visualize correlations between PLS components from different blocks 
using the model fitted by the function <code><a href="#topic+asmbPLSDA.fit">asmbPLSDA.fit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCor(
  fit.results,
  ncomp = 1,
  block.name = NULL,
  group.name = NULL,
  legend = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCor_+3A_fit.results">fit.results</code></td>
<td>
<p>The output of <code><a href="#topic+asmbPLSDA.fit">asmbPLSDA.fit</a></code>.</p>
</td></tr>
<tr><td><code id="plotCor_+3A_ncomp">ncomp</code></td>
<td>
<p>Which component to plot from each block. Should not be larger 
than the number of PLS components used (<code>PLS.comp</code>) in the function
<code><a href="#topic+asmbPLSDA.fit">asmbPLSDA.fit</a></code>. The default is 1.</p>
</td></tr>
<tr><td><code id="plotCor_+3A_block.name">block.name</code></td>
<td>
<p>A vector containing the named character for each block. It
must be ordered and match each block.</p>
</td></tr>
<tr><td><code id="plotCor_+3A_group.name">group.name</code></td>
<td>
<p>A vector containing the named character for each sample 
group. For <code>binary</code> outcome, first group name matches <code>Y.matrix</code> = 0, 
second group name matches <code>Y.matrix</code> = 1. For <code>multiclass</code> outcome,
<code>i</code>th group name matches <code>i</code>th column of <code>Y.matrix</code> = 1.</p>
</td></tr>
<tr><td><code id="plotCor_+3A_legend">legend</code></td>
<td>
<p>A logical value indicating whether the legend should be added.
The default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns a plot to show correlations between PLS components from 
different blocks. The lower triangular panel indicates Pearson's 
correlation coefficient, and the upper triangular panel the scatter plot.
</p>


<h3>Value</h3>

<p>none
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use the example dataset
data(asmbPLSDA.example)
X.matrix = asmbPLSDA.example$X.matrix
Y.matrix.binary = asmbPLSDA.example$Y.matrix.binary
Y.matrix.multiclass = asmbPLSDA.example$Y.matrix.morethan2levels
X.dim = asmbPLSDA.example$X.dim
PLS.comp = asmbPLSDA.example$PLS.comp
quantile.comb = asmbPLSDA.example$quantile.comb
 
## asmbPLSDA fit for binary outcome
asmbPLSDA.fit.binary &lt;- asmbPLSDA.fit(X.matrix = X.matrix, 
                                      Y.matrix = Y.matrix.binary, 
                                      PLS.comp = PLS.comp, 
                                      X.dim = X.dim, 
                                      quantile.comb = quantile.comb,
                                      outcome.type = "binary")

## asmbPLSDA fit for categorical outcome with more than 2 levels
asmbPLSDA.fit.multiclass &lt;- asmbPLSDA.fit(X.matrix = X.matrix, 
                                          Y.matrix = Y.matrix.multiclass,
                                          PLS.comp = PLS.comp, 
                                          X.dim = X.dim, 
                                          quantile.comb = quantile.comb,
                                          outcome.type = "multiclass")

## visualization with default block.name and group.name using the first PLS component 
plotCor(asmbPLSDA.fit.binary, 1)
plotCor(asmbPLSDA.fit.multiclass, 1)
## custom block.name and group.name
plotCor(asmbPLSDA.fit.binary, 
        ncomp = 1, 
        block.name = c("mRNA", "protein"), 
        group.name = c("control", "case"))
plotCor(asmbPLSDA.fit.multiclass, 
        ncomp = 1, 
        block.name = c("mRNA", "protein"), 
        group.name = c("healthy", "mild", "severe"))


</code></pre>

<hr>
<h2 id='plotPLS'>PLS plot for asmbPLS-DA</h2><span id='topic+plotPLS'></span>

<h3>Description</h3>

<p>Function to visualize cluster of samples using super score of different PLS
components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPLS(fit.results, comp.X = 1, comp.Y = 2, group.name = NULL, legend = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPLS_+3A_fit.results">fit.results</code></td>
<td>
<p>The output of <code><a href="#topic+asmbPLSDA.fit">asmbPLSDA.fit</a></code>.</p>
</td></tr>
<tr><td><code id="plotPLS_+3A_comp.x">comp.X</code></td>
<td>
<p>A integer indicating which PLS component to be used for the 
X.axis. The default is 1.</p>
</td></tr>
<tr><td><code id="plotPLS_+3A_comp.y">comp.Y</code></td>
<td>
<p>A integer indicating which PLS component to be used for the 
Y.axis. The default is 2.</p>
</td></tr>
<tr><td><code id="plotPLS_+3A_group.name">group.name</code></td>
<td>
<p>A vector containing the named character for each sample 
group. For <code>binary</code> outcome, first group name matches <code>Y.matrix</code> = 0, 
second group name matches <code>Y.matrix</code> = 1. For <code>multiclass</code> outcome,
<code>i</code>th group name matches <code>i</code>th column of <code>Y.matrix</code> = 1.</p>
</td></tr>
<tr><td><code id="plotPLS_+3A_legend">legend</code></td>
<td>
<p>A logical value indicating whether the legend should be added.
The default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns a plot to show cluster of samples using super score of 
different PLS components.
</p>


<h3>Value</h3>

<p>none
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use the example dataset
data(asmbPLSDA.example)
X.matrix = asmbPLSDA.example$X.matrix
Y.matrix.binary = asmbPLSDA.example$Y.matrix.binary
Y.matrix.multiclass = asmbPLSDA.example$Y.matrix.morethan2levels
X.dim = asmbPLSDA.example$X.dim
PLS.comp = asmbPLSDA.example$PLS.comp
quantile.comb = asmbPLSDA.example$quantile.comb
 
## asmbPLSDA fit for binary outcome
asmbPLSDA.fit.binary &lt;- asmbPLSDA.fit(X.matrix = X.matrix, 
                                      Y.matrix = Y.matrix.binary, 
                                      PLS.comp = PLS.comp, 
                                      X.dim = X.dim, 
                                      quantile.comb = quantile.comb,
                                      outcome.type = "binary")

## asmbPLSDA fit for categorical outcome with more than 2 levels
asmbPLSDA.fit.multiclass &lt;- asmbPLSDA.fit(X.matrix = X.matrix, 
                                          Y.matrix = Y.matrix.multiclass,
                                          PLS.comp = PLS.comp, 
                                          X.dim = X.dim, 
                                          quantile.comb = quantile.comb,
                                          outcome.type = "multiclass")

## visualization to show the cluster of samples using the first and the second super score
plotPLS(asmbPLSDA.fit.binary, comp.X = 1, comp.Y = 2)
plotPLS(asmbPLSDA.fit.multiclass, comp.X = 1, comp.Y = 2)
## custom group.name
plotPLS(asmbPLSDA.fit.binary, 
        comp.X = 1, 
        comp.Y = 2, 
        group.name = c("control", "case"))
plotPLS(asmbPLSDA.fit.multiclass, 
        comp.X = 1, 
        comp.Y = 2, 
        group.name = c("healthy", "mild", "severe"))


</code></pre>

<hr>
<h2 id='plotRelevance'>Relevance plot for asmbPLS-DA</h2><span id='topic+plotRelevance'></span>

<h3>Description</h3>

<p>Function to visualize the most relevant features (relevant to the outcome) in 
each block.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRelevance(fit.results, n.top = 10, ncomp = 1, block.name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRelevance_+3A_fit.results">fit.results</code></td>
<td>
<p>The output of <code><a href="#topic+asmbPLSDA.fit">asmbPLSDA.fit</a></code> or 
<code><a href="#topic+asmbPLS.fit">asmbPLS.fit</a></code>.</p>
</td></tr>
<tr><td><code id="plotRelevance_+3A_n.top">n.top</code></td>
<td>
<p>A integer indicating the number of the most relevant features to 
be displayed for each block. The default is 10. If the number of selected 
features in the block is smaller than <code>n.top</code>, all the selected features in
that block will be displayed.</p>
</td></tr>
<tr><td><code id="plotRelevance_+3A_ncomp">ncomp</code></td>
<td>
<p>Which component to plot from each block. Should not be larger 
than the number of PLS components used (<code>PLS.comp</code>) in the function
<code><a href="#topic+asmbPLSDA.fit">asmbPLSDA.fit</a></code> or <code><a href="#topic+asmbPLS.fit">asmbPLS.fit</a></code>. 
The default is 1.</p>
</td></tr>
<tr><td><code id="plotRelevance_+3A_block.name">block.name</code></td>
<td>
<p>A vector containing the named character for each block. It
must be ordered and match each block.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns a plot to show the most relevant features for each 
block.
</p>


<h3>Value</h3>

<p>none
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use the example dataset
data(asmbPLSDA.example)
X.matrix = asmbPLSDA.example$X.matrix
Y.matrix.binary = asmbPLSDA.example$Y.matrix.binary
Y.matrix.multiclass = asmbPLSDA.example$Y.matrix.morethan2levels
X.dim = asmbPLSDA.example$X.dim
PLS.comp = asmbPLSDA.example$PLS.comp
quantile.comb = asmbPLSDA.example$quantile.comb
 
## asmbPLSDA fit for binary outcome
asmbPLSDA.fit.binary &lt;- asmbPLSDA.fit(X.matrix = X.matrix, 
                                      Y.matrix = Y.matrix.binary, 
                                      PLS.comp = PLS.comp, 
                                      X.dim = X.dim, 
                                      quantile.comb = quantile.comb,
                                      outcome.type = "binary")

## asmbPLSDA fit for categorical outcome with more than 2 levels
asmbPLSDA.fit.multiclass &lt;- asmbPLSDA.fit(X.matrix = X.matrix, 
                                          Y.matrix = Y.matrix.multiclass,
                                          PLS.comp = PLS.comp, 
                                          X.dim = X.dim, 
                                          quantile.comb = quantile.comb,
                                          outcome.type = "multiclass")

## visualization to show the most relevant features in each block
plotRelevance(asmbPLSDA.fit.binary)
plotRelevance(asmbPLSDA.fit.multiclass)
## custom n.top and block.name
plotRelevance(asmbPLSDA.fit.binary, 
              n.top = 5,
              block.name = c("mRNA", "protein"))
plotRelevance(asmbPLSDA.fit.multiclass, 
              n.top = 7,
              block.name = c("miRNA", "protein"))


</code></pre>

<hr>
<h2 id='quantileComb'>Create the quantile combination set for asmbPLS and asmbPLS-DA</h2><span id='topic+quantileComb'></span>

<h3>Description</h3>

<p>Create the quantile combination set given quantile set for each block.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantileComb(quantile.list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantileComb_+3A_quantile.list">quantile.list</code></td>
<td>
<p>A list containing the quantile set for each block.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The quantile combination used for asmbPLS and asmbPLS-DA models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate quantile set for each block
## For example, we have three blocks
quantile_1 &lt;- c(0.999, 0.9992, 0.9994, 0.9996, 0.9998)
quantile_2 &lt;- c(0.96, 0.97, 0.98, 0.99, 0.995)
quantile_3 &lt;- c(0.95, 0.96, 0.97, 0.98, 0.99)
quantilelist &lt;- list(quantile_1, quantile_2, quantile_3)
quantile.comb &lt;- quantileComb(quantilelist)

</code></pre>

<hr>
<h2 id='to.categorical'>Converts a class vector to a binary class matrix</h2><span id='topic+to.categorical'></span>

<h3>Description</h3>

<p>This function converts a class vector to a binary class matrix, with the number of columns equal to the number of levels in the input vector. Each row of the output matrix corresponds to a single observation in the input vector, and the columns represent the different classes in the input vector. A value of 1 in a particular column indicates that the corresponding observation belongs to that class, while a value of 0 indicates that it does not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to.categorical(categorical.vector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to.categorical_+3A_categorical.vector">categorical.vector</code></td>
<td>
<p>A factor or character vector representing the class labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A binary class matrix with the number of rows equal to the length of the input vector, and the number of columns equal to the number of unique levels in the input vector. The row and column names of the output matrix are set to the levels of the input vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a class vector
vector.test &lt;- factor(c(1,1,1,2,2,2,3,3,3), levels = c(1,2,3))

## Convert the class vector to binary class matrix
output.matrix &lt;- to.categorical(vector.test)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
