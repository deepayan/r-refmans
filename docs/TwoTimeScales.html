<!DOCTYPE html><html lang="en"><head><title>Help for package TwoTimeScales</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TwoTimeScales}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#covariates_plot'><p>Plot of the covariates' effects</p></a></li>
<li><a href='#cumhaz2ts'><p>Cumulative hazard over two time scales</p></a></li>
<li><a href='#cuminc2ts'><p>Cumulative incidence surface over two time scales</p></a></li>
<li><a href='#exposures_events_1d'><p>Bin data on one time scale</p></a></li>
<li><a href='#exposures_events_2d'><p>Bin data on two time scales</p></a></li>
<li><a href='#exposures_events_Lexis'><p>Bin data on the Lexis diagram</p></a></li>
<li><a href='#fit1ts'><p>Fit a smooth hazard model with one time scale</p></a></li>
<li><a href='#fit1tsmodel_ucminf'><p>Numerical optimization of the 1ts model</p></a></li>
<li><a href='#fit2ts'><p>Fit a smooth hazard model with two time scales</p></a></li>
<li><a href='#fit2tsmodel_ucminf'><p>Numerical optimization of the 2ts model</p></a></li>
<li><a href='#get_aic_fit_1d'><p>Return the AIC of 1ts model</p></a></li>
<li><a href='#get_aic_fit_2d'><p>Return the AIC of 2ts model</p></a></li>
<li><a href='#get_bic_fit_1d'><p>Return the BIC of 1ts model</p></a></li>
<li><a href='#get_bic_fit_2d'><p>Return the BIC of 2ts model</p></a></li>
<li><a href='#get_hazard_1d'><p>Get estimated (log-)hazard values with 1 time scale</p></a></li>
<li><a href='#get_hazard_1d_LMM'><p>Get estimated (log-)hazard values with 1 time scale</p></a></li>
<li><a href='#get_hazard_2d'><p>Get estimated (log-)hazard surface with 2 time scales</p></a></li>
<li><a href='#get_hazard_2d_LMM'><p>Get estimated (log-)hazard surface with 2 time scales</p></a></li>
<li><a href='#get_hr'><p>Get the Hazard Ratios with their Standard Errors</p></a></li>
<li><a href='#getAIC_BIC_LMM'><p>Calculates AIC and BIC from object fitted via LMMsolver</p></a></li>
<li><a href='#GLAM_1d_covariates'><p>Fit the 1d GLAM with covariates</p></a></li>
<li><a href='#GLAM_2d_covariates'><p>Fit the 2d GLAM with covariates</p></a></li>
<li><a href='#GLAM_2d_no_covariates'><p>Fit the 2d GLAM without covariates</p></a></li>
<li><a href='#grid_search_1d'><p>Grid search for the optimal 1ts model</p></a></li>
<li><a href='#grid_search_2d'><p>Grid search for the optimal 2ts model</p></a></li>
<li><a href='#haz2ts_summary'><p>Summary function for object of class 'haz2ts'</p></a></li>
<li><a href='#haz2tsLMM_summary'><p>Summary function for object of class 'haz2tsLMM'</p></a></li>
<li><a href='#imageplot_2ts'><p>Image Plot of 2ts hazard</p></a></li>
<li><a href='#imageplot_SE'><p>Image Plot of Standard Errors for the 2ts hazard</p></a></li>
<li><a href='#iwls_1d'><p>Iterative Weighted Least Squares algorithm for 1ts model</p></a></li>
<li><a href='#make_bins'><p>Construct bins over one or more time axes</p></a></li>
<li><a href='#plot_slices'><p>Plot slices of the (log-) hazard</p></a></li>
<li><a href='#plot.haz1ts'><p>Plot method for a haz1ts object.</p></a></li>
<li><a href='#plot.haz1tsLMM'><p>Plot method for a haz1ts object.</p></a></li>
<li><a href='#plot.haz2ts'><p>Plot method for a haz2ts object.</p></a></li>
<li><a href='#plot.haz2tsLMM'><p>Plot method for a haz2tsLMM object.</p></a></li>
<li><a href='#prepare_data'><p>Prepare raw data by binning them in 1d or 2d</p></a></li>
<li><a href='#prepare_data_LMMsolver'><p>Process data to fit model with LMMsolver</p></a></li>
<li><a href='#print.data2ts'><p>Print method for a <code>data2ts</code> object</p></a></li>
<li><a href='#reccolon2ts'><p>Data from the chemotherapy for stace B/C colon cancer study</p></a></li>
<li><a href='#surv2ts'><p>Survival function with two time scales</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Analysis of Event Data with Two Time Scales</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/AngelaCar/TwoTimeScales">https://github.com/AngelaCar/TwoTimeScales</a>,
<a href="https://angelacar.github.io/TwoTimeScales/">https://angelacar.github.io/TwoTimeScales/</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Analyse time to event data with two time scales by estimating a smooth hazard that varies over two time scales and also, if covariates are available, to estimate a proportional hazards model with such a two-dimensional baseline hazard. 
  Functions are provided to prepare the raw data for estimation, to estimate and to plot the two-dimensional smooth hazard. 
  Extension to a competing risks model are implemented. For details about the method please refer to Carollo et al. (2024) &lt;<a href="https://doi.org/10.1002%2Fsim.10297">doi:10.1002/sim.10297</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>colorspace, Epi, fields, JOPS, LMMsolver, popEpi, reshape2,
spam, ucminf, viridis</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/AngelaCar/TwoTimeScales/issues">https://github.com/AngelaCar/TwoTimeScales/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-20 08:58:34 UTC; Carollo</td>
</tr>
<tr>
<td>Author:</td>
<td>Angela Carollo <a href="https://orcid.org/0000-0002-5625-6553"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Paul H.C. Eilers [aut],
  Jutta Gampe [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Angela Carollo &lt;carollo@demogr.mpg.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-23 10:50:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='covariates_plot'>Plot of the covariates' effects</h2><span id='topic+covariates_plot'></span>

<h3>Description</h3>

<p><code>covariates_plot()</code> produces a plot of the covariates' effects (<code class="reqn">\hat\beta</code>)
with confidence intervals, or of the Hazard Ratios (<code class="reqn">\exp(\hat\beta)</code>) with confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covariates_plot(
  fitted_model,
  confidence_lev = 0.95,
  plot_options = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covariates_plot_+3A_fitted_model">fitted_model</code></td>
<td>
<p>A list returned by the function <code>fit2ts</code> or <code>fit1ts</code>.</p>
</td></tr>
<tr><td><code id="covariates_plot_+3A_confidence_lev">confidence_lev</code></td>
<td>
<p>The level of confidence for the CIs. Default is 0.95 (<code class="reqn">\alpha
= 0.05</code>).</p>
</td></tr>
<tr><td><code id="covariates_plot_+3A_plot_options">plot_options</code></td>
<td>
<p>A list of options for the plot:
</p>

<ul>
<li> <p><code>HR</code> A Boolean. If <code>TRUE</code> the HRs with their CIs will be plotted.
Default is <code>FALSE</code> (plot the <code>beta</code> with their CIs).
</p>
</li>
<li> <p><code>symmetric_ci</code> A Boolean. Default is <code>TRUE</code>. If a plot of the HRs is
required (<code>HR == TRUE</code>), then plot symmetrical Confidence Intervals,
based on the SEs for the HRs calculated by delta method.
If <code>FALSE</code>, then CIs are obtained by exponentiating the CIs for the betas.
</p>
</li>
<li> <p><code>main</code> The title of the plot.
</p>
</li>
<li> <p><code>ylab</code> The label for the y-axis.
</p>
</li>
<li> <p><code>ylim</code> A vector with two elements defining the limits for the y-axis.
</p>
</li>
<li> <p><code>col_beta</code> The color for the plot of the covariates' effects.
</p>
</li>
<li> <p><code>pch</code> The symbol for plotting the point estimates.
</p>
</li>
<li> <p><code>cex_main</code> The magnification factor for the main of the plot.
</p>
</li></ul>
</td></tr>
<tr><td><code id="covariates_plot_+3A_...">...</code></td>
<td>
<p>further arguments passed to plot()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the covariates' effects. The different covariates are plotted
on the x-axis, and on the y-axis the effects on the coefficient- or
on the HR-scale are plotted. The main estimate is represented by a
point and the CIs are added as vertical bars.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create some fake data - the bare minimum
id &lt;- 1:20
u &lt;- c(5.43, 3.25, 8.15, 5.53, 7.28, 6.61, 5.91, 4.94, 4.25, 3.86, 4.05, 6.86,
       4.94, 4.46, 2.14, 7.56, 5.55, 7.60, 6.46, 4.96)
s &lt;- c(0.44, 4.89, 0.92, 1.81, 2.02, 1.55, 3.16, 6.36, 0.66, 2.02, 1.22, 3.96,
       7.07, 2.91, 3.38, 2.36, 1.74, 0.06, 5.76, 3.00)
ev &lt;- c(1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1)
x1 &lt;- c(0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0)

fakedata &lt;- as.data.frame(cbind(id, u, s, ev, x1))
covs &lt;- subset(fakedata, select = c("x1"))
fakedata2ts &lt;- prepare_data(u = fakedata$u,
                            s_out = fakedata$s,
                            ev = fakedata$ev,
                            ds = .5,
                            individual = TRUE,
                            covs = covs)
# Fit a fake model - not optimal smoothing
fakemod &lt;- fit2ts(fakedata2ts,
                  optim_method = "grid_search",
                  lrho = list(seq(1 ,1.5 ,.5),
                              seq(1 ,1.5 ,.5)))
# Covariates plot with default options
covariates_plot(fakemod)

# Plot the hazard ratios instead
covariates_plot(fakemod,
                plot_options = list(
                HR = TRUE))

# Change confidence level
covariates_plot(fakemod,
                confidence_lev = .99)
</code></pre>

<hr>
<h2 id='cumhaz2ts'>Cumulative hazard over two time scales</h2><span id='topic+cumhaz2ts'></span>

<h3>Description</h3>

<p>Computes the cumulative hazard surface over two time scales
from a fitted model. The function is also called internally from <code>plot()</code>
if the user wants to plot the cumulative hazard from a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumhaz2ts(
  fitted_model,
  plot_grid = NULL,
  cause = NULL,
  midpoints = FALSE,
  where_slices = NULL,
  direction = c("u", "s", NULL),
  tmax = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cumhaz2ts_+3A_fitted_model">fitted_model</code></td>
<td>
<p>(optional) The output of the function <code>fit2ts</code>.
This is an object of class <code>'haz2ts'</code> or <code>'haz2tsLMM'</code>.</p>
</td></tr>
<tr><td><code id="cumhaz2ts_+3A_plot_grid">plot_grid</code></td>
<td>
<p>(optional) A list containing the parameters to build a new
finer grid of intervals over <code>u</code> and <code>s</code> for plotting. This must be of the
form:
</p>

<ul>
<li> <p><code>plot_grid = list(c(umin, umax, du), c(smin, smax, ds))</code>
where <code>umin</code>, <code>umax</code> and <code>smin</code>, <code>smax</code> are the minimum and maximum values
desired for the grid-points over <code>u</code> and <code>s</code> respectively, and <code>du</code>, <code>ds</code> are
distances between two adjacent points over <code>u</code> and <code>s</code> respectively.
Specifying a new denser grid is used to evaluate the B-spline bases used for
estimation on such grid and plot the estimated surfaces with a greater level
of detail.
If not specified, the plotting is done using the same B-splines bases as
for the estimation. The function will check if the parameters for the grid
provided by the user are compatible with those originally used to construct
the B-splines for estimating the model. If not, the grid will be adjusted
accordingly and a warning will be returned.
</p>
</li></ul>
</td></tr>
<tr><td><code id="cumhaz2ts_+3A_cause">cause</code></td>
<td>
<p>a character string with a short name for the cause (optional).</p>
</td></tr>
<tr><td><code id="cumhaz2ts_+3A_midpoints">midpoints</code></td>
<td>
<p>A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code>, the estimated
quantities are evaluated at the midpoints of the rectangles
(or parallelograms) of the grids, rather than at each grid-point.</p>
</td></tr>
<tr><td><code id="cumhaz2ts_+3A_where_slices">where_slices</code></td>
<td>
<p>A vector of values for the cutting points of the desired
slices of the surface. This option is included mostly for the plotting function.
When using <code>plot.haz2ts()</code>, the user selects <code>which_plot = "cumhaz"</code> and
<code>cumhaz_slices = TRUE</code>, then <code>where_slices</code> indicates the location of the
cutting points over the <code>u</code> time.</p>
</td></tr>
<tr><td><code id="cumhaz2ts_+3A_direction">direction</code></td>
<td>
<p>If cross-sectional one-dimensional curves are plotted, this
indicates whether the cutting points are located on the <code>u</code> time, or on the
<code>s</code> time. For plots of the cumulative hazards, only cutting points over the
<code>u</code> time are meaningful.</p>
</td></tr>
<tr><td><code id="cumhaz2ts_+3A_tmax">tmax</code></td>
<td>
<p>The maximum value of <code>t</code> that should be plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
* <code>Haz</code> a list of estimated hazard and associated SEs
(obtained from the function <code>get_hazard_2d</code>);
* <code>CumHaz</code> the cumulated hazard estimate over <code>u</code> and <code>s</code>;
* <code>cause</code> (if provided) the short name for the cause.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create some fake data - the bare minimum
id &lt;- 1:20
u &lt;- c(5.43, 3.25, 8.15, 5.53, 7.28, 6.61, 5.91, 4.94, 4.25, 3.86, 4.05, 6.86,
       4.94, 4.46, 2.14, 7.56, 5.55, 7.60, 6.46, 4.96)
s &lt;- c(0.44, 4.89, 0.92, 1.81, 2.02, 1.55, 3.16, 6.36, 0.66, 2.02, 1.22, 3.96,
       7.07, 2.91, 3.38, 2.36, 1.74, 0.06, 5.76, 3.00)
ev &lt;- c(1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1)#'

fakedata &lt;- as.data.frame(cbind(id, u, s, ev))
fakedata2ts &lt;- prepare_data(u = fakedata$u,
                            s_out = fakedata$s,
                            ev = fakedata$ev,
                            ds = .5)
# Fit a fake model - not optimal smoothing
fakemod &lt;- fit2ts(fakedata2ts,
                  optim_method = "grid_search",
                  lrho = list(seq(1 ,1.5 ,.5),
                              seq(1 ,1.5 ,.5)))

# Obtain the fake cumulated hazard
fakecumhaz2ts &lt;- cumhaz2ts(fakemod)

</code></pre>

<hr>
<h2 id='cuminc2ts'>Cumulative incidence surface over two time scales</h2><span id='topic+cuminc2ts'></span>

<h3>Description</h3>

<p>Cumulative incidence surface over two time scales
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cuminc2ts(haz = list(), ds, cause = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cuminc2ts_+3A_haz">haz</code></td>
<td>
<p>a list of cause-specific hazards</p>
</td></tr>
<tr><td><code id="cuminc2ts_+3A_ds">ds</code></td>
<td>
<p>the distance between two consecutive intervals over the <code>s</code> time scale.
This has to be equal for all cause-specific hazards</p>
</td></tr>
<tr><td><code id="cuminc2ts_+3A_cause">cause</code></td>
<td>
<p>is an optional vector of short names for the causes. It should
be of the same length as the number of cause-specific cumulated hazards provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with one cumulative incidence matrix for each cause-specific
hazard (named if a vector of short names is passed to <code>cause</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create some fake data - the bare minimum
id &lt;- 1:20
u &lt;- c(5.43, 3.25, 8.15, 5.53, 7.28, 6.61, 5.91, 4.94, 4.25, 3.86, 4.05, 6.86,
       4.94, 4.46, 2.14, 7.56, 5.55, 7.60, 6.46, 4.96)
s &lt;- c(0.44, 4.89, 0.92, 1.81, 2.02, 1.55, 3.16, 6.36, 0.66, 2.02, 1.22, 3.96,
       7.07, 2.91, 3.38, 2.36, 1.74, 0.06, 5.76, 3.00)
ev &lt;- c(1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1)#'

fakedata &lt;- as.data.frame(cbind(id, u, s, ev))
fakedata2ts &lt;- prepare_data(u = fakedata$u,
                            s_out = fakedata$s,
                            ev = fakedata$ev,
                            ds = .5)
# Fit a fake model - not optimal smoothing
fakemod &lt;- fit2ts(fakedata2ts,
                  optim_method = "grid_search",
                  lrho = list(seq(1 ,1.5 ,.5),
                              seq(1 ,1.5 ,.5)))

# Obtain the fake cumulated hazard
fakecumhaz2ts &lt;- cumhaz2ts(fakemod)
# Fake cumulative incidence function 2ts
fakecif2ts &lt;- cuminc2ts(haz = list(fakecumhaz2ts$Haz$hazard),
                        ds = .5)
</code></pre>

<hr>
<h2 id='exposures_events_1d'>Bin data on one time scale</h2><span id='topic+exposures_events_1d'></span>

<h3>Description</h3>

<p><code>exposure_events_1d()</code> computes aggregated measures of exposure
times and event counts starting from individual records of time at entry,
time at exit and event's indicator, over one time scale (<code>s</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exposures_events_1d(s_in = NULL, s_out, ev, bins)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exposures_events_1d_+3A_s_in">s_in</code></td>
<td>
<p>A vector of (possibly left truncated) times at entry. If this is
not provided by the user, the function will consider a value of 0 for all
observations.</p>
</td></tr>
<tr><td><code id="exposures_events_1d_+3A_s_out">s_out</code></td>
<td>
<p>A vector of times at event or censoring.</p>
</td></tr>
<tr><td><code id="exposures_events_1d_+3A_ev">ev</code></td>
<td>
<p>A vector of events' indicators (possible values 0/1).</p>
</td></tr>
<tr><td><code id="exposures_events_1d_+3A_bins">bins</code></td>
<td>
<p>A vector of interval breaks for discretization (see also <code><a href="#topic+make_bins">make_bins()</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The time scale <code>s</code> is divided into bins of equal size, which are
provided as input to the function. Then, the time-at-risk for each
individual is split according to these bins, and an event indicator is
placed in the bin where the exit time is located. Finally, the individual
contributions are summed in each bin to provide a vector of total exposure
time and total event counts. See also <code><a href="#topic+prepare_data">prepare_data()</a></code> to
conveniently prepare individual data for the analysis with one, or two time
scales.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>R</code>  A matrix of dimension <code class="reqn">n</code> by <code class="reqn">ns</code> containing the exposure times for each
individual separately.
</p>
</li>
<li> <p><code>r</code>  A vector of exposure times.
</p>
</li>
<li> <p><code>Y</code>  A matrix of dimension <code class="reqn">n</code> by <code class="reqn">ns</code> containing the event counts for each
individual separately
</p>
</li>
<li> <p><code>y</code>  A vector of event counts.
</p>
</li></ul>

<p>If the length of the input vectors do not match, an error message is
returned.
</p>


<h3>Author(s)</h3>

<p>Angela Carollo <a href="mailto:carollo@demogr.mpg.de">carollo@demogr.mpg.de</a> and Paul Eilers <a href="mailto:p.eilers@erasmus.nl">p.eilers@erasmus.nl</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ---- Bin colon cancer data by time since recurrence ----
# First create vector of bins
bins1ts &lt;- make_bins(s_in = reccolon2ts$entrys, s_out = reccolon2ts$timesr, ds = 30)
bindata &lt;- exposures_events_1d(s_in = reccolon2ts$entrys,
s_out = reccolon2ts$timesr, ev = reccolon2ts$status, bins = bins1ts$bins_s)

</code></pre>

<hr>
<h2 id='exposures_events_2d'>Bin data on two time scales</h2><span id='topic+exposures_events_2d'></span>

<h3>Description</h3>

<p><code>exposures_events_2d()</code> computes individual or aggregated
matrices of exposure times and event counts starting from individual
records of time at entry in the process (measured over the first time
scale), duration at entry in the process (measured over the second time
scale), duration at exit from the process (measured over the second time
scale), and event's indicator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exposures_events_2d(u, s_in = NULL, s_out, ev, bins_list, individual = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exposures_events_2d_+3A_u">u</code></td>
<td>
<p>A vector of fixed times at entry in the process, measured over the
first time scale.</p>
</td></tr>
<tr><td><code id="exposures_events_2d_+3A_s_in">s_in</code></td>
<td>
<p>A vector of (possibly left truncated) times at entry. If this is
not provided by the user, the function will consider a value of 0 for all
observations.</p>
</td></tr>
<tr><td><code id="exposures_events_2d_+3A_s_out">s_out</code></td>
<td>
<p>A vector of times at event or censoring.</p>
</td></tr>
<tr><td><code id="exposures_events_2d_+3A_ev">ev</code></td>
<td>
<p>A vector of events' indicators (possible values 0/1).</p>
</td></tr>
<tr><td><code id="exposures_events_2d_+3A_bins_list">bins_list</code></td>
<td>
<p>is a list with the following (necessary) elements
(usually prepared by <code><a href="#topic+make_bins">make_bins()</a></code>):
</p>

<ul>
<li> <p><code>bins_u</code> a vector of extreme values for the bins over the <code>u</code> axis
</p>
</li>
<li> <p><code>bins_s</code> a vector of extreme values for the bins over the <code>s</code> axis
</p>
</li></ul>
</td></tr>
<tr><td><code id="exposures_events_2d_+3A_individual">individual</code></td>
<td>
<p>A Boolean. Default is <code>FALSE</code>: if <code>FALSE</code> computes the matrices
R and Y collectively for all observations; if <code>TRUE</code> computes the matrices
R and Y separately for each individual record.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fixed-time variable <code>u</code> and the second time scale <code>s</code>
are divided into <code class="reqn">nu</code> and <code class="reqn">ns</code> intervals, respectively. The extremes of these
intervals are provided as input to the function. First, the fixed-time at
entry is located in one of the nu bins that cover the whole range of
<code>u</code>. Then, the time-at-risk for each individual is split according to
the <code class="reqn">ns</code> bins that span the whole range of values for <code>s</code>, and an event
indicator is placed in the bin where the exit time is located. This is done
by calling the function <code>exposure_events_1d</code>. If individual matrices of
exposure and events are required, then the function returns two arrays of
dimension <code class="reqn">nu</code> by <code class="reqn">ns</code> by <code class="reqn">n</code>. If aggregated results are preferred, the
individual contributions are summed in each bin to provide a matrix of
total exposure time and a matrix of total event counts, both of dimensions
<code class="reqn">nu</code> by <code class="reqn">ns</code>. See also <code><a href="#topic+prepare_data">prepare_data()</a></code> to conveniently prepare individual data
for the analysis with one, or two time scales.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>R</code> an array of exposure times: if <code>individual == TRUE</code>,
then <code>R</code> is an array of dimension <code class="reqn">nu</code> by <code class="reqn">ns</code> by <code class="reqn">n</code>,
otherwise is an array of dimension <code class="reqn">nu</code> by <code class="reqn">ns</code>
</p>
</li>
<li> <p><code>Y</code>an array of event counts: if <code>individual == TRUE</code>,
then <code>Y</code> is an array of
dimension <code class="reqn">nu</code> by <code class="reqn">ns</code> by <code class="reqn">n</code>, otherwise is an array of
dimension <code class="reqn">nu</code> by <code class="reqn">ns</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Angela Carollo <a href="mailto:carollo@demogr.mpg.de">carollo@demogr.mpg.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ---- Bin colon cancer data by time at randomization and time since recurrence ----
# First create vectors of bins (using function `make_bins()`)
bins &lt;- make_bins(u = reccolon2ts$timer, s_out = reccolon2ts$timesr,
du = 30, ds = 30)
# Now bin data (note: the s_in argument is omitted because data are not left truncated)
bindata2d &lt;- exposures_events_2d(u = reccolon2ts$timer,
s_out = reccolon2ts$timesr, ev = reccolon2ts$status, bins = bins)

</code></pre>

<hr>
<h2 id='exposures_events_Lexis'>Bin data on the Lexis diagram</h2><span id='topic+exposures_events_Lexis'></span>

<h3>Description</h3>

<p><code>exposures_events_Lexis()</code> computes aggregated matrices of
exposure times and event counts over two time
scales, on the Lexis diagram.
</p>
<p>The time scales are <code>t</code> and <code>s</code>. This function uses functions from
the package <code>popEpi</code> and from the package <code>Epi</code>, and code shared by Bendix Carstensen
on the website bendixcarstensen.com. See also <code><a href="#topic+prepare_data">prepare_data()</a></code>
to conveniently prepare individual data for the analysis with one,
or two time scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exposures_events_Lexis(t_in = NULL, t_out, s_in = NULL, s_out, ev, bins_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exposures_events_Lexis_+3A_t_in">t_in</code></td>
<td>
<p>(optional) A vector of entry times on the time scale <code>t</code>.</p>
</td></tr>
<tr><td><code id="exposures_events_Lexis_+3A_t_out">t_out</code></td>
<td>
<p>(optional) A vector of exit times on the time scale <code>t</code>.</p>
</td></tr>
<tr><td><code id="exposures_events_Lexis_+3A_s_in">s_in</code></td>
<td>
<p>(optional) A vector of entry times on the time scale <code>s</code>.</p>
</td></tr>
<tr><td><code id="exposures_events_Lexis_+3A_s_out">s_out</code></td>
<td>
<p>A vector of exit times on the time scale <code>s</code>.</p>
</td></tr>
<tr><td><code id="exposures_events_Lexis_+3A_ev">ev</code></td>
<td>
<p>A vector of event indicators (possible values 0/1).</p>
</td></tr>
<tr><td><code id="exposures_events_Lexis_+3A_bins_list">bins_list</code></td>
<td>
<p>A list with the following (necessary) elements:
</p>

<ul>
<li> <p><code>bins_t</code> a vector of extreme values for the bins over the <code>t</code> axis.
</p>
</li>
<li> <p><code>nt</code> the number of bins over <code>t</code>.
</p>
</li>
<li> <p><code>bins_s</code> a vector of extreme values for the bins over the <code>t</code> axis.
</p>
</li>
<li> <p><code>ns</code> the number of bins over <code>s</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>R</code> an array of exposure times of dimension <code class="reqn">nt</code> by <code class="reqn">ns</code>
</p>
</li>
<li> <p><code>Y</code> an array of event counts of dimension <code class="reqn">nt</code> by <code class="reqn">ns</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Angela Carollo <a href="mailto:carollo@demogr.mpg.de">carollo@demogr.mpg.de</a>
</p>


<h3>References</h3>

<p>Carstensen B, Plummer M, Laara E, Hills M (2022).
Epi: A Package for Statistical Analysis in Epidemiology.
R package version 2.47.1, https://CRAN.R-project.org/package=Epi.
</p>
<p>Miettinen J, Rantanen M, Seppa K (2023).
popEpi: Functions for Epidemiological Analysis using Population Data.
R package version 0.4.11, https://cran.r-project.org/package=popEpi.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ---- Bin colon cancer data by time since randomization and time since recurrence ----
# First create vectors of bins (using function `make_bins()`)
bins &lt;- make_bins(t_out = reccolon2ts$timedc, s_out = reccolon2ts$timesr,
dt = 90, ds = 90)
# Now bin data (note: the t_in and s_in arguments are omitted because data are not left truncated)
bindata2d &lt;- exposures_events_Lexis(t_out = reccolon2ts$timedc,
s_out = reccolon2ts$timesr, ev = reccolon2ts$status, bins = bins)

</code></pre>

<hr>
<h2 id='fit1ts'>Fit a smooth hazard model with one time scale</h2><span id='topic+fit1ts'></span>

<h3>Description</h3>

<p><code>fit1ts()</code> fits a smooth hazard model with one time scale.
</p>
<p>Three methods are implemented for the search of the optimal smoothing
parameter (and therefore optimal model): a numerical optimization of the
AIC or BIC of the model, a search for the minimum AIC or BIC of the
model over a grid of <code class="reqn">\log_{10}</code> values for the smoothing parameter and the
estimation using a sparse mixed model representation of P-splines.
Construction of the B-splines basis and of the penalty matrix is
incorporated within the function. If a matrix of covariates is provided,
the function will estimate a model with covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit1ts(
  data1ts = NULL,
  y = NULL,
  r = NULL,
  Z = NULL,
  bins = NULL,
  Bbases_spec = list(),
  Wprior = NULL,
  pord = 2,
  optim_method = c("ucminf", "grid_search", "LMMsolver"),
  optim_criterion = c("aic", "bic"),
  lrho = 0,
  ridge = 0,
  control_algorithm = list(),
  par_gridsearch = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit1ts_+3A_data1ts">data1ts</code></td>
<td>
<p>(optional) an object created by the function
<code>prepare_data()</code>. Providing this input is the easiest way to use the function
<code>fit1ts</code>. However, the user can also provide the input data together with
a list of bins, as explained by the following parameters' descriptions.</p>
</td></tr>
<tr><td><code id="fit1ts_+3A_y">y</code></td>
<td>
<p>A vector of event counts of length ns, or an array of dimension ns
by n.</p>
</td></tr>
<tr><td><code id="fit1ts_+3A_r">r</code></td>
<td>
<p>A vector of exposure times of length ns, or an array of dimension ns
by n.</p>
</td></tr>
<tr><td><code id="fit1ts_+3A_z">Z</code></td>
<td>
<p>(optional) A regression matrix of covariates of dimension n by p.</p>
</td></tr>
<tr><td><code id="fit1ts_+3A_bins">bins</code></td>
<td>
<p>a list with the specification for the bins. This is created by
the function <code>prepare_data</code>. Alternatively, a list with the following elements
can be provided:
* <code>bins_s</code> is a vector of intervals for the time scale <code>s</code>.
* <code>mids</code> is a vector with the midpoints of the intervals over <code>s</code>.
* <code>ns</code> is the number of bins over <code>s</code>.</p>
</td></tr>
<tr><td><code id="fit1ts_+3A_bbases_spec">Bbases_spec</code></td>
<td>
<p>A list with the specification for the B-splines basis
with the following elements:
</p>

<ul>
<li> <p><code>bdeg</code> The degree of the B-splines basis. Default is 3 (for cubic B-splines).
</p>
</li>
<li> <p><code>nseg_s</code> The number of segments for the B-splines over <code>s</code>. Default is 10.
</p>
</li>
<li> <p><code>min_s</code> (optional) The lower limit of the domain of <code>Bs</code>.
Default is <code>min(bins_s)</code>.
</p>
</li>
<li> <p><code>max_s</code> (optional) The upper limit of the domain of <code>Bs</code>.
Default is <code>max(bins_s)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fit1ts_+3A_wprior">Wprior</code></td>
<td>
<p>An optional vector of a-priori weights.</p>
</td></tr>
<tr><td><code id="fit1ts_+3A_pord">pord</code></td>
<td>
<p>The order of the penalty. Default is 2.</p>
</td></tr>
<tr><td><code id="fit1ts_+3A_optim_method">optim_method</code></td>
<td>
<p>The method to be used for optimization:
<code>"ucminf"</code> (default) for the numerical optimization of the AIC (or BIC),
<code>"grid_search"</code> for a grid search of the minimum AIC (or BIC)
over a grid of <code class="reqn">\log_{10}(\varrho_s)</code> values, and <code>"LMMsolver"</code> to solve the model
as sparse linear mixed model using the package LMMsolver.</p>
</td></tr>
<tr><td><code id="fit1ts_+3A_optim_criterion">optim_criterion</code></td>
<td>
<p>The criterion to be used for optimization:
<code>"aic"</code> (default) or <code>"bic"</code>. BIC penalized model complexity more strongly
than AIC, so that its usage is recommended when a smoother fit is preferable
(see also Camarda, 2012).</p>
</td></tr>
<tr><td><code id="fit1ts_+3A_lrho">lrho</code></td>
<td>
<p>A number if <code>optim_method == "ucminf"</code>, default is 0.
A vector of values for <code class="reqn">\log_{10}(\varrho_s)</code>  if <code>optim_method == "grid_search"</code>.
In the latter case, if a vector is not provided, a default sequence of
values is used for <code class="reqn">\log_{10}(\varrho_s)</code> .</p>
</td></tr>
<tr><td><code id="fit1ts_+3A_ridge">ridge</code></td>
<td>
<p>A ridge penalty parameter: default is 0.</p>
</td></tr>
<tr><td><code id="fit1ts_+3A_control_algorithm">control_algorithm</code></td>
<td>
<p>A list with optional values for the parameters of
the iterative processes:
</p>

<ul>
<li> <p><code>maxiter</code> The maximum number of iteration for the IWSL algorithm.
Default is 20.
</p>
</li>
<li> <p><code>conv_crit</code> The convergence criteria, expressed as difference between
estimates at iteration i and i+1. Default is <code>1e-5</code>.
</p>
</li>
<li> <p><code>verbose</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> monitors the iteration
process.
</p>
</li>
<li> <p><code>monitor_ev</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> monitors the
evaluation of the model over the <code>log_10(rho_s)</code> values.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fit1ts_+3A_par_gridsearch">par_gridsearch</code></td>
<td>
<p>A list of parameters for the grid_search:
</p>

<ul>
<li> <p><code>plot_aic</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code>, plot the AIC values
over the grid of <code>log_10(rhos)</code> values.
</p>
</li>
<li> <p><code>plot_bic</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code>, plot the BIC values
over the grid of <code>log_10(rhos)</code> values.
</p>
</li>
<li> <p><code>return_aic</code> A Boolean. Default is <code>TRUE</code>. Return the AIC values.
</p>
</li>
<li> <p><code>return_bic</code> A Boolean. Default is <code>TRUE</code>. Return the BIC values.
</p>
</li>
<li> <p><code>mark_optimal</code> A Boolean. Default is <code>TRUE</code>. If the plot of the AIC or BIC
values is returned, marks the optimal <code>log_10(rho_s)</code> in the plot.
</p>
</li>
<li> <p><code>main_aic</code> The title of the AIC plot. Default is <code>"AIC grid"</code>.
</p>
</li>
<li> <p><code>main_bic</code> The title of the BIC plot. Default is <code>"BIC grid"</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Some functions from the R-package <code>LMMsolver</code> are used here.
We refer the interested readers to https://biometris.github.io/LMMsolver/
for more detail on <code>LMMsolver</code> and its usage.
</p>


<h3>Value</h3>

<p>An object of class <code>haz1ts</code>, or of class <code>haz1tsLMM</code>.
For objects of class <code>haz1ts</code> this is
</p>

<ul>
<li> <p><code>optimal_model</code> A list with:
</p>

<ul>
<li> <p><code>alpha</code> The vector of estimated P-splines coefficients of length <code class="reqn">cs</code>.
</p>
</li>
<li> <p><code>SE_alpha</code> The vector of estimated Standard Errors for the <code>alpha</code> coefficients,
of length <code class="reqn">cs</code>.
</p>
</li>
<li> <p><code>beta</code> The vector of estimated covariate coefficients of length <code class="reqn">p</code>
(if model with covariates).
</p>
</li>
<li> <p><code>se_beta</code> The vector of estimated Standard Errors for the
<code>beta</code> coefficients of length <code class="reqn">p</code> (if model with covariates).
</p>
</li>
<li> <p><code>eta</code> or <code>eta0</code>. The vector of values of the (baseline) linear predictor
(log-hazard) of length <code class="reqn">ns</code>.
</p>
</li>
<li> <p><code>H</code> The hat-matrix.
</p>
</li>
<li> <p><code>Cov</code> The full variance-covariance matrix.
</p>
</li>
<li> <p><code>deviance</code> The deviance.
</p>
</li>
<li> <p><code>ed</code> The effective dimension of the model.
</p>
</li>
<li> <p><code>aic</code> The value of the AIC.
</p>
</li>
<li> <p><code>bic</code> The value of the BIC.
</p>
</li>
<li> <p><code>Bbases</code> a list with the B-spline basis <code>Bs</code> (this is a list for
compatibility with functions in 2d).
</p>
</li></ul>

</li>
<li> <p><code>optimal_logrho</code> The optimal value of <code>log10(rho_s)</code>.
</p>
</li>
<li> <p><code>P_optimal</code> The optimal penalty matrix P.
</p>
</li>
<li> <p><code>AIC</code> (if <code>par_gridsearch$return_aic == TRUE</code>) The vector of AIC values.
</p>
</li>
<li> <p><code>BIC</code> (if <code>par_gridsearch$return_bic == TRUE</code>) The vector of BIC values.
</p>
</li></ul>

<p>Objects of class <code>haz1tsLMM</code> have a slight different structure. They are
a list with:
</p>

<ul>
<li> <p><code>optimal_model</code> an object of class <code>LMMsolve</code>
</p>
</li>
<li> <p><code>AIC_BIC</code> a list with, among other things, the AIC and BIC values and the
ED of the model
</p>
</li>
<li> <p><code>n_events</code> the number of events
</p>
</li>
<li> <p><code>ns</code> the number of bins over the s-axis
</p>
</li>
<li> <p><code>cs</code> the number of B-splines over the s-axis
</p>
</li>
<li> <p><code>covariates</code> an indicator for PH model
</p>
</li></ul>



<h3>References</h3>

<p>Boer, Martin P. 2023. “Tensor Product P-Splines Using a Sparse Mixed Model Formulation.”
Statistical Modelling 23 (5-6): 465–79. https://doi.org/10.1177/1471082X231178591.#'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## preparing data - no covariates
dt1ts &lt;- prepare_data(data = reccolon2ts,
                      s_in = "entrys",
                      s_out = "timesr",
                      events = "status",
                      ds = 180)

## fitting the model with fit1ts() - default options, that is ucminf optimization

mod1 &lt;- fit1ts(dt1ts)

## fitting with LMMsolver
mod2 &lt;- fit1ts(dt1ts,
              optim_method = "LMMsolver")

## preparing the data - covariates

dt1ts_cov &lt;- prepare_data(data = reccolon2ts,
                      s_in = "entrys",
                      s_out = "timesr",
                      events = "status",
                      ds = 180,
                      individual = TRUE,
                      covs = c("rx", "node4", "sex"))

## fitting the model with fit1ts() - grid search over only two log_10(rho_s) values

mod3 &lt;- fit1ts(dt1ts_cov,
               optim_method = "grid_search",
               lrho = c(1, 1.5))


</code></pre>

<hr>
<h2 id='fit1tsmodel_ucminf'>Numerical optimization of the 1ts model</h2><span id='topic+fit1tsmodel_ucminf'></span>

<h3>Description</h3>

<p><code>fit1tsmodel_ucminf()</code> performs a numerical optimization of the
AIC or BIC of the one time scale model.
</p>
<p>It finds the optimal values of <code class="reqn">\log_{10}(\varrho_s)</code> and returns the estimated
optimal model.
See also <code><a href="ucminf.html#topic+ucminf">ucminf::ucminf()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit1tsmodel_ucminf(
  r,
  y,
  Z = NULL,
  lrho = 0,
  Bs,
  Ds,
  Wprior = NULL,
  optim_criterion = c("aic", "bic"),
  control_algorithm = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit1tsmodel_ucminf_+3A_r">r</code></td>
<td>
<p>A vector of exposure times of length ns, or an array of dimension ns
by n.</p>
</td></tr>
<tr><td><code id="fit1tsmodel_ucminf_+3A_y">y</code></td>
<td>
<p>A vector of event counts of length ns, or an array of dimension ns
by n.</p>
</td></tr>
<tr><td><code id="fit1tsmodel_ucminf_+3A_z">Z</code></td>
<td>
<p>(optional) A regression matrix of covariates of dimension n by p.</p>
</td></tr>
<tr><td><code id="fit1tsmodel_ucminf_+3A_lrho">lrho</code></td>
<td>
<p>A starting value for <code class="reqn">\log_{10}(\varrho_s)</code>. Default is 0.</p>
</td></tr>
<tr><td><code id="fit1tsmodel_ucminf_+3A_bs">Bs</code></td>
<td>
<p>A matrix of B-splines for the time scale <code>s</code>.</p>
</td></tr>
<tr><td><code id="fit1tsmodel_ucminf_+3A_ds">Ds</code></td>
<td>
<p>The difference matrix of the penalty.</p>
</td></tr>
<tr><td><code id="fit1tsmodel_ucminf_+3A_wprior">Wprior</code></td>
<td>
<p>An optional vector of a-priori weights.</p>
</td></tr>
<tr><td><code id="fit1tsmodel_ucminf_+3A_optim_criterion">optim_criterion</code></td>
<td>
<p>The criterion to be used for optimization:
<code>"aic"</code> (default) or <code>"bic"</code>.</p>
</td></tr>
<tr><td><code id="fit1tsmodel_ucminf_+3A_control_algorithm">control_algorithm</code></td>
<td>
<p>A list with optional values for the parameters of
the iterative processes:
</p>

<ul>
<li> <p><code>maxiter</code> The maximum number of iteration for the IWSL algorithm.
Default is 20.
</p>
</li>
<li> <p><code>conv_crit</code> The convergence criteria, expressed as difference between
estimates at iteration i and i+1. Default is <code>1e-5</code>.
</p>
</li>
<li> <p><code>verbose</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> monitors the iteration
process.
</p>
</li>
<li> <p><code>monitor_ev</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> monitors the
evaluation of the model over the <code>log_10(rho_s)</code> values.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>haz1ts</code> with the following elements:
</p>

<ul>
<li> <p><code>optimal_model</code> A list containing the results of the optimal model.
</p>
</li>
<li> <p><code>optimal_logrho</code> The optimal value of <code>log10(rho_s)</code>.
</p>
</li>
<li> <p><code>P_optimal</code> The optimal penalty matrix P.
</p>
</li></ul>



<h3>References</h3>

<p>Nielsen H, Mortensen S (2024).
<em>ucminf: General-Purpose Unconstrained Non-Linear Optimization</em>.
R package version 1.2.2, <a href="https://CRAN.R-project.org/package=ucminf">https://CRAN.R-project.org/package=ucminf</a>
</p>

<hr>
<h2 id='fit2ts'>Fit a smooth hazard model with two time scales</h2><span id='topic+fit2ts'></span>

<h3>Description</h3>

<p><code>fit2ts()</code> fits a smooth hazard model with two time scales.
</p>
<p>Three methods are implemented for the search of the optimal smoothing
parameters (and therefore optimal model): a numerical optimization of the
AIC or BIC of the model, a search for the minimum AIC or BIC of the
model over a grid of <code>log_10</code> values for the smoothing parameters, and a
solution that uses a sparse mixed model representation of the P-spline model to
estimate the smoothing parameters.
Construction of the B-splines bases and of the penalty matrix is
incorporated within the function. If a matrix of covariates is provided,
the function will estimate a model with covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit2ts(
  data2ts = NULL,
  Y = NULL,
  R = NULL,
  Z = NULL,
  bins = NULL,
  Bbases_spec = list(),
  pord = 2,
  optim_method = c("ucminf", "grid_search", "LMMsolver"),
  optim_criterion = c("aic", "bic"),
  lrho = c(0, 0),
  Wprior = NULL,
  ridge = 0,
  control_algorithm = list(),
  par_gridsearch = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit2ts_+3A_data2ts">data2ts</code></td>
<td>
<p>(optional) an object of class created by the function
<code>prepare_data()</code>. Proving this input is the easiest way to use the function
<code>fit2ts</code>. However, the user can also provide the input data together with
a list of bins, as explained by the following parameters' descriptions.</p>
</td></tr>
<tr><td><code id="fit2ts_+3A_y">Y</code></td>
<td>
<p>A matrix (or 3d-array) of event counts of dimension nu by ns
(or nu by ns by n).</p>
</td></tr>
<tr><td><code id="fit2ts_+3A_r">R</code></td>
<td>
<p>A matrix (or 3d-array) of exposure times of dimension nu by ns
(or nu by ns by n).</p>
</td></tr>
<tr><td><code id="fit2ts_+3A_z">Z</code></td>
<td>
<p>(optional) A regression matrix of covariates values of dimensions
n by p.</p>
</td></tr>
<tr><td><code id="fit2ts_+3A_bins">bins</code></td>
<td>
<p>a list with the specification for the bins. This is created by
the function <code>prepare_data</code>. If a list prepared externally from such function
if provided, it should contain the following elements:
* <code>bins_u</code> A vector of bins extremes for the time scale <code>u</code>.
* <code>midu</code> A vector with the midpoints of the bins over <code>u</code>.
* <code>nu</code> The number of bins over <code>u</code>.
* <code>bins_s</code> A vector of bins extremes for the time scale <code>s</code>.
* <code>mids</code> A vector with the midpoints of the bins over <code>s</code>.
* <code>ns</code> The number of bins over <code>s</code>.</p>
</td></tr>
<tr><td><code id="fit2ts_+3A_bbases_spec">Bbases_spec</code></td>
<td>
<p>A list with the specification for the B-splines basis
with the following elements:
</p>

<ul>
<li> <p><code>bdeg</code> The degree of the B-splines basis. Default is 3 (for cubic B-splines).
</p>
</li>
<li> <p><code>nseg_u</code> The number of segments for the B-splines over <code>u</code>. Default is 10.
</p>
</li>
<li> <p><code>min_u</code> (optional) The lower limit of the domain of <code>Bu</code>.
Default is <code>min(bins_u)</code>.
</p>
</li>
<li> <p><code>max_u</code> (optional) The upper limit of the domain of <code>Bu</code>.
Default is <code>max(bins_u)</code>.
</p>
</li>
<li> <p><code>nseg_s</code> The number of segments for the B-splines over <code>s</code>. Default is 10.
</p>
</li>
<li> <p><code>min_s</code> (optional) The lower limit of the domain of <code>Bs</code>.
Default is <code>min(bins_s)</code>.
</p>
</li>
<li> <p><code>max_s</code> (optional) The upper limit of the domain of <code>Bs</code>.
Default is <code>max(bins_s)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fit2ts_+3A_pord">pord</code></td>
<td>
<p>The order of the penalty. Default is 2.</p>
</td></tr>
<tr><td><code id="fit2ts_+3A_optim_method">optim_method</code></td>
<td>
<p>The method to be used for optimization:
<code>"ucminf"</code> (default) for the numerical optimization of the AIC (or BIC),
<code>"grid_search"</code> for a grid search of the minimum AIC (or BIC)
over a grid of <code>log_10(rho_u)</code> and <code>log_10(rho_s)</code> values,
or <code>"LMMsolver"</code> to solve the model as sparse linear mixed model using the
package LMMsolver.</p>
</td></tr>
<tr><td><code id="fit2ts_+3A_optim_criterion">optim_criterion</code></td>
<td>
<p>The criterion to be used for optimization:
<code>"aic"</code> (default) or <code>"bic"</code>. BIC penalized model complexity more strongly
than AIC, so that its usage is recommended when a smoother fit is preferable
(see also Camarda, 2012).</p>
</td></tr>
<tr><td><code id="fit2ts_+3A_lrho">lrho</code></td>
<td>
<p>A vector of two elements if <code>optim_method == "ucminf"</code>.
Default is <code>c(0,0)</code>. A list of two vectors of values for <code>log_10(rho_u)</code>
and <code>log_10(rho_s)</code> if <code>optim_method == "grid_search"</code>. In the latter case,
if a list with two vectors is not provided, a default sequence of
values is used for both <code>log_10(rho_u)</code> and <code>log_10(rho_s)</code>.</p>
</td></tr>
<tr><td><code id="fit2ts_+3A_wprior">Wprior</code></td>
<td>
<p>An optional matrix of a-priori weights.</p>
</td></tr>
<tr><td><code id="fit2ts_+3A_ridge">ridge</code></td>
<td>
<p>A ridge penalty parameter: default is 0. This is useful when, in
some cases the algorithm shows convergence problems. In this case, set to a small
number, for example <code>1e-4</code>.</p>
</td></tr>
<tr><td><code id="fit2ts_+3A_control_algorithm">control_algorithm</code></td>
<td>
<p>A list with optional values for the parameters of
the iterative processes:
</p>

<ul>
<li> <p><code>maxiter</code> The maximum number of iteration for the IWSL algorithm.
Default is 20.
</p>
</li>
<li> <p><code>conv_crit</code> The convergence criteria, expressed as difference between
estimates at iteration i and i+1. Default is <code>1e-5</code>.
</p>
</li>
<li> <p><code>verbose</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> monitors the iteration
process.
</p>
</li>
<li> <p><code>monitor_ev</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> monitors the
evaluation of the model over the <code>log_10(rho_s)</code> values.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fit2ts_+3A_par_gridsearch">par_gridsearch</code></td>
<td>
<p>A list of parameters for the grid_search:
</p>

<ul>
<li> <p><code>plot_aic</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code>, plot the AIC values
over the grid of <code>log_10(rho_u)</code> and <code>log_10(rho_s)</code> values.
</p>
</li>
<li> <p><code>plot_bic</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code>, plot the BIC values
over the grid of <code>log_10(rho_u)</code> and <code>log_10(rho_s)</code> values.
</p>
</li>
<li> <p><code>return_aic</code> A Boolean. Default is <code>TRUE</code>. Return the AIC values.
</p>
</li>
<li> <p><code>return_bic</code> A Boolean. Default is <code>TRUE</code>. Return the BIC values.
</p>
</li>
<li> <p><code>col</code> The color palette to be used for the AIC/BIC plot. Default is
<code>grDevices::gray.colors(n=10)</code>.
</p>
</li>
<li> <p><code>plot_contour</code> A Boolean. Default is <code>TRUE</code>. Adds white contour lines to
the AIC/BIC plot.
</p>
</li>
<li> <p><code>mark_optimal</code> A Boolean. Default is <code>TRUE</code>. If the plot of the AIC or BIC
values is returned, marks the optimal combination of <code>log_10(rho_u)</code> and
<code>log_10(rho_s)</code> in the plot.
</p>
</li>
<li> <p><code>main_aic</code> The title of the AIC plot. Default is <code>"AIC grid"</code>.
</p>
</li>
<li> <p><code>main_bic</code> The title of the BIC plot. Default is <code>"BIC grid"</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Some functions from the R-package <code>LMMsolver</code> are used here.
We refer the interested readers to https://biometris.github.io/LMMsolver/
for more details on <code>LMMsolver</code> and its usage.
</p>


<h3>Value</h3>

<p>An object of class <code>haz2ts</code>, or of class <code>haz2tsLMM</code>.
For objects of class <code>haz2ts</code> this is
</p>

<ul>
<li> <p><code>optimal_model</code> A list with :
</p>

<ul>
<li> <p><code>Alpha</code> The matrix of estimated P-splines coefficients of dimension
<code class="reqn">c_u</code> by <code class="reqn">c_s</code>.
</p>
</li>
<li> <p><code>Cov_alpha</code> The variance-covariance matrix of the <code>Alpha</code> coefficients,
of dimension <code class="reqn">c_uc_s</code> by <code class="reqn">c_uc_s</code>.
</p>
</li>
<li> <p><code>beta</code> The vector of length p of estimated covariates coefficients
(if model with covariates).
</p>
</li>
<li> <p><code>Cov_beta</code> The variance-covariance matrix of the <code>beta</code> coefficients,
of dimension <code class="reqn">p</code> by <code class="reqn">p</code> (if model with covariates).
</p>
</li>
<li> <p><code>SE_beta</code> The vector of length <code class="reqn">p</code> of estimated Standard Errors for the <code>beta</code>
coefficients (if model with covariates)..
</p>
</li>
<li> <p><code>Eta</code> or <code>Eta0</code> The matrix of values of the (baseline) linear predictor
(log-hazard) of dimension <code class="reqn">n_u</code> by <code class="reqn">n_s</code>.
</p>
</li>
<li> <p><code>H</code> The hat-matrix.
</p>
</li>
<li> <p><code>deviance</code> The deviance.
</p>
</li>
<li> <p><code>ed</code> The effective dimension of the model.
</p>
</li>
<li> <p><code>aic</code> The value of the AIC.
</p>
</li>
<li> <p><code>bic</code> The value of the BIC.
</p>
</li>
<li> <p><code>Bbases</code> a list with the B-spline bases <code>Bu</code> and <code>Bs</code>
</p>
</li></ul>

</li>
<li> <p><code>optimal_logrho</code> A vector with the optimal values of <code>log10(rho_u)</code> and
<code>log10(rho_s)</code>.
</p>
</li>
<li> <p><code>P_optimal</code> The optimal penalty matrix P.
</p>
</li>
<li> <p><code>AIC</code> (if <code>par_gridsearch$return_aic == TRUE</code>) The matrix of AIC values.
</p>
</li>
<li> <p><code>BIC</code> (if <code>par_gridsearch$return_bic == TRUE</code>) The matrix of BIC values.
</p>
</li></ul>

<p>Objects of class <code>haz2tsLMM</code> have a slight different structure. They are
a list with:
</p>

<ul>
<li> <p><code>optimal_model</code> an object of class <code>LMMsolve</code>
</p>
</li>
<li> <p><code>AIC_BIC</code> a list with, among other things, the AIC and BIC values and the
ED of the model
</p>
</li>
<li> <p><code>n_events</code> the number of events
</p>
</li>
<li> <p><code>nu</code> the number of bins over the u-axis
</p>
</li>
<li> <p><code>ns</code> the number of bins over the s-axis
</p>
</li>
<li> <p><code>cu</code> the number of B-splines over the u-axis
</p>
</li>
<li> <p><code>cs</code> the number of B-splines over the s-axis
</p>
</li>
<li> <p><code>covariates</code> an indicator for PH model
</p>
</li></ul>



<h3>References</h3>

<p>Boer, Martin P. 2023. “Tensor Product P-Splines Using a Sparse Mixed Model Formulation.”
Statistical Modelling 23 (5-6): 465–79. https://doi.org/10.1177/1471082X231178591.
Carollo, Angela, Paul H. C. Eilers, Hein Putter, and Jutta Gampe. 2023.
“Smooth Hazards with Multiple Time Scales.” arXiv Preprint:
https://arxiv.org/abs/http://arxiv.org/abs/2305.09342v1
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create some fake data - the bare minimum
id &lt;- 1:20
u &lt;- c(5.43, 3.25, 8.15, 5.53, 7.28, 6.61, 5.91, 4.94, 4.25, 3.86, 4.05, 6.86,
       4.94, 4.46, 2.14, 7.56, 5.55, 7.60, 6.46, 4.96)
s &lt;- c(0.44, 4.89, 0.92, 1.81, 2.02, 1.55, 3.16, 6.36, 0.66, 2.02, 1.22, 3.96,
       7.07, 2.91, 3.38, 2.36, 1.74, 0.06, 5.76, 3.00)
ev &lt;- c(1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1)#'

fakedata &lt;- as.data.frame(cbind(id, u, s, ev))
fakedata2ts &lt;- prepare_data(data = fakedata,
                            u = "u",
                            s_out = "s",
                            ev = "ev",
                            ds = .5)
# Fit a fake model - not optimal smoothing
fit2ts(fakedata2ts,
       optim_method = "grid_search",
       lrho = list(seq(1, 1.5, .5), seq(1, 1.5, .5)))
# For more examples please check the vignettes!!! Running more complicated examples
# here would imply longer running times...

</code></pre>

<hr>
<h2 id='fit2tsmodel_ucminf'>Numerical optimization of the 2ts model</h2><span id='topic+fit2tsmodel_ucminf'></span>

<h3>Description</h3>

<p><code>fit2tsmodel_ucminf()</code> performs a numerical optimization of the
AIC or BIC of the two time scales model.
</p>
<p>It finds the optimal values of <code>log_10(rho_u)</code> and <code>log_10(rho_s)</code>
and returns the estimated optimal model.
See also <code><a href="ucminf.html#topic+ucminf">ucminf::ucminf()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit2tsmodel_ucminf(
  Y,
  R,
  Z = NULL,
  optim_criterion = c("aic", "bic"),
  lrho = c(0, 0),
  Bu,
  Bs,
  Iu,
  Is,
  Du,
  Ds,
  Wprior = NULL,
  ridge = 0,
  control_algorithm = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit2tsmodel_ucminf_+3A_y">Y</code></td>
<td>
<p>A matrix (or 3d-array) of event counts of dimension nu by ns
(or nu by ns by n).</p>
</td></tr>
<tr><td><code id="fit2tsmodel_ucminf_+3A_r">R</code></td>
<td>
<p>A matrix (or 3d-array) of exposure times of dimension nu by ns
(or nu by ns by n).</p>
</td></tr>
<tr><td><code id="fit2tsmodel_ucminf_+3A_z">Z</code></td>
<td>
<p>(optional) A regression matrix of covariates values of dimensions
n by p.</p>
</td></tr>
<tr><td><code id="fit2tsmodel_ucminf_+3A_optim_criterion">optim_criterion</code></td>
<td>
<p>The criterion to be used for optimization:
<code>"aic"</code> (default) or <code>"bic"</code>.</p>
</td></tr>
<tr><td><code id="fit2tsmodel_ucminf_+3A_lrho">lrho</code></td>
<td>
<p>A vector of two elements, the initial values for <code class="reqn">\log_{10}(\varrho_u)</code>
and <code class="reqn">\log_{10}(\varrho_s)</code>.</p>
</td></tr>
<tr><td><code id="fit2tsmodel_ucminf_+3A_bu">Bu</code></td>
<td>
<p>A matrix of B-splines for the <code>u</code> time scale of dimension nu by cu.</p>
</td></tr>
<tr><td><code id="fit2tsmodel_ucminf_+3A_bs">Bs</code></td>
<td>
<p>A matrix of B-splines for the <code>s</code> time scale of dimension ns by cs.</p>
</td></tr>
<tr><td><code id="fit2tsmodel_ucminf_+3A_iu">Iu</code></td>
<td>
<p>An identity matrix of dimension nbu by nbu.</p>
</td></tr>
<tr><td><code id="fit2tsmodel_ucminf_+3A_is">Is</code></td>
<td>
<p>An identity matrix of dimension nbs by nbs.</p>
</td></tr>
<tr><td><code id="fit2tsmodel_ucminf_+3A_du">Du</code></td>
<td>
<p>The difference matrix over <code>u</code>.</p>
</td></tr>
<tr><td><code id="fit2tsmodel_ucminf_+3A_ds">Ds</code></td>
<td>
<p>The difference matrix over <code>s</code>.</p>
</td></tr>
<tr><td><code id="fit2tsmodel_ucminf_+3A_wprior">Wprior</code></td>
<td>
<p>An optional matrix of a-priori weights.</p>
</td></tr>
<tr><td><code id="fit2tsmodel_ucminf_+3A_ridge">ridge</code></td>
<td>
<p>A ridge penalty parameter: default is 0. This is useful when, in
some cases the algorithm shows convergence problems. In this case, set to a small
number, for example <code>1e-4</code>.</p>
</td></tr>
<tr><td><code id="fit2tsmodel_ucminf_+3A_control_algorithm">control_algorithm</code></td>
<td>
<p>A list with optional values for the parameters of
the iterative processes:
</p>

<ul>
<li> <p><code>maxiter</code> The maximum number of iteration for the IWSL algorithm.
Default is 20.
</p>
</li>
<li> <p><code>conv_crit</code> The convergence criteria, expressed as difference between
estimates at iteration i and i+1. Default is <code>1e-5</code>.
</p>
</li>
<li> <p><code>verbose</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> monitors the iteration
process.
</p>
</li>
<li> <p><code>monitor_ev</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> monitors the
evaluation of the model over the <code>log_10(rho_s)</code> values.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>haz2ts</code> with the following elements:
</p>

<ul>
<li> <p><code>optimal_model</code> A list containing the results of the optimal model.
</p>
</li>
<li> <p><code>optimal_logrho</code> A vector with the optimal values of <code>log10(rho_u)</code> and
<code>log10(rho_s)</code>.
</p>
</li>
<li> <p><code>P_optimal</code> The optimal penalty matrix P.
</p>
</li></ul>



<h3>References</h3>

<p>Nielsen H, Mortensen S (2024).
<em>ucminf: General-Purpose Unconstrained Non-Linear Optimization</em>.
R package version 1.2.2, <a href="https://CRAN.R-project.org/package=ucminf">https://CRAN.R-project.org/package=ucminf</a>
</p>

<hr>
<h2 id='get_aic_fit_1d'>Return the AIC of 1ts model</h2><span id='topic+get_aic_fit_1d'></span>

<h3>Description</h3>

<p><code>get_aic_fit_1d()</code> fits the 1ts model with or without individual
level covariates and it returns the AIC of the model.
See also <code>fit1tsmodel_ucminf()</code> and <code>fit1ts()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_aic_fit_1d(
  lrho,
  r,
  y,
  Z = NULL,
  Bs,
  Ds,
  Wprior = NULL,
  control_algorithm = list(maxiter = 20, conv_crit = 1e-05, verbose = FALSE, monitor_ev =
    FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_aic_fit_1d_+3A_lrho">lrho</code></td>
<td>
<p>A starting value for <code class="reqn">\log_{10}(\varrho_s)</code>. Default is 0.</p>
</td></tr>
<tr><td><code id="get_aic_fit_1d_+3A_r">r</code></td>
<td>
<p>A vector of exposure times of length ns, or an array of dimension ns
by n.</p>
</td></tr>
<tr><td><code id="get_aic_fit_1d_+3A_y">y</code></td>
<td>
<p>A vector of event counts of length ns, or an array of dimension ns
by n.</p>
</td></tr>
<tr><td><code id="get_aic_fit_1d_+3A_z">Z</code></td>
<td>
<p>(optional) A regression matrix of covariates of dimension n by p.</p>
</td></tr>
<tr><td><code id="get_aic_fit_1d_+3A_bs">Bs</code></td>
<td>
<p>A matrix of B-splines for the time scale <code>s</code>.</p>
</td></tr>
<tr><td><code id="get_aic_fit_1d_+3A_ds">Ds</code></td>
<td>
<p>The difference matrix of the penalty.</p>
</td></tr>
<tr><td><code id="get_aic_fit_1d_+3A_wprior">Wprior</code></td>
<td>
<p>An optional vector of a-priori weights.</p>
</td></tr>
<tr><td><code id="get_aic_fit_1d_+3A_control_algorithm">control_algorithm</code></td>
<td>
<p>A list with optional values for the parameters of
the iterative processes:
</p>

<ul>
<li> <p><code>maxiter</code> The maximum number of iteration for the IWSL algorithm.
Default is 20.
</p>
</li>
<li> <p><code>conv_crit</code> The convergence criteria, expressed as difference between
estimates at iteration i and i+1. Default is <code>1e-5</code>.
</p>
</li>
<li> <p><code>verbose</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> monitors the iteration
process.
</p>
</li>
<li> <p><code>monitor_ev</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> monitors the
evaluation of the model over the <code>log_10(rho_s)</code> values.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>aic</code> value of the fitted model.
</p>

<hr>
<h2 id='get_aic_fit_2d'>Return the AIC of 2ts model</h2><span id='topic+get_aic_fit_2d'></span>

<h3>Description</h3>

<p><code>get_aic_fit_2d()</code> fits the 2ts model with or without individual
level covariates and it returns the AIC of the model.
See also <code>fit2tsmodel_ucminf()</code> and <code>fit2ts()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_aic_fit_2d(
  lrho,
  R,
  Y,
  Z = NULL,
  Bu,
  Bs,
  Iu,
  Is,
  Du,
  Ds,
  Wprior = NULL,
  ridge = 0,
  control_algorithm = list(maxiter = 20, conv_crit = 1e-05, verbose = FALSE, monitor_ev =
    FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_aic_fit_2d_+3A_lrho">lrho</code></td>
<td>
<p>A vector of two elements, the initial values for <code class="reqn">\log_{10}(\varrho_u)</code>
and <code class="reqn">\log_{10}(\varrho_s)</code>.</p>
</td></tr>
<tr><td><code id="get_aic_fit_2d_+3A_r">R</code></td>
<td>
<p>A matrix (or 3d-array) of exposure times of dimension nu by ns
(or nu by ns by n).</p>
</td></tr>
<tr><td><code id="get_aic_fit_2d_+3A_y">Y</code></td>
<td>
<p>A matrix (or 3d-array) of event counts of dimension nu by ns
(or nu by ns by n).</p>
</td></tr>
<tr><td><code id="get_aic_fit_2d_+3A_z">Z</code></td>
<td>
<p>(optional) A regression matrix of covariates values of dimensions
n by p.</p>
</td></tr>
<tr><td><code id="get_aic_fit_2d_+3A_bu">Bu</code></td>
<td>
<p>A matrix of B-splines for the <code>u</code> time scale of dimension nu by cu.</p>
</td></tr>
<tr><td><code id="get_aic_fit_2d_+3A_bs">Bs</code></td>
<td>
<p>A matrix of B-splines for the <code>s</code> time scale of dimension ns by cs.</p>
</td></tr>
<tr><td><code id="get_aic_fit_2d_+3A_iu">Iu</code></td>
<td>
<p>An identity matrix of dimension nbu by nbu.</p>
</td></tr>
<tr><td><code id="get_aic_fit_2d_+3A_is">Is</code></td>
<td>
<p>An identity matrix of dimension nbs by nbs.</p>
</td></tr>
<tr><td><code id="get_aic_fit_2d_+3A_du">Du</code></td>
<td>
<p>The difference matrix over <code>u</code>.</p>
</td></tr>
<tr><td><code id="get_aic_fit_2d_+3A_ds">Ds</code></td>
<td>
<p>The difference matrix over <code>s</code>.</p>
</td></tr>
<tr><td><code id="get_aic_fit_2d_+3A_wprior">Wprior</code></td>
<td>
<p>An optional matrix of a-priori weights.</p>
</td></tr>
<tr><td><code id="get_aic_fit_2d_+3A_ridge">ridge</code></td>
<td>
<p>A ridge penalty parameter: default is 0. This is useful when, in
some cases the algorithm shows convergence problems. In this case, set to a small
number, for example <code>1e-4</code>.</p>
</td></tr>
<tr><td><code id="get_aic_fit_2d_+3A_control_algorithm">control_algorithm</code></td>
<td>
<p>A list with optional values for the parameters of
the iterative processes:
</p>

<ul>
<li> <p><code>maxiter</code> The maximum number of iteration for the IWSL algorithm.
Default is 20.
</p>
</li>
<li> <p><code>conv_crit</code> The convergence criteria, expressed as difference between
estimates at iteration i and i+1. Default is <code>1e-5</code>.
</p>
</li>
<li> <p><code>verbose</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> monitors the iteration
process.
</p>
</li>
<li> <p><code>monitor_ev</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> monitors the
evaluation of the model over the <code>log_10(rho_s)</code> values.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>aic</code> value of the fitted model.
</p>

<hr>
<h2 id='get_bic_fit_1d'>Return the BIC of 1ts model</h2><span id='topic+get_bic_fit_1d'></span>

<h3>Description</h3>

<p><code>get_bic_fit_1d()</code> fits the 1ts model with or without individual
level covariates and it returns the BIC of the model.
See also <code>fit1tsmodel_ucminf()</code> and <code>fit1ts()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_bic_fit_1d(
  lrho,
  r,
  y,
  Z = NULL,
  Bs,
  Ds,
  Wprior = NULL,
  control_algorithm = list(maxiter = 20, conv_crit = 1e-05, verbose = FALSE, monitor_ev =
    FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_bic_fit_1d_+3A_lrho">lrho</code></td>
<td>
<p>A starting value for <code class="reqn">\log_{10}(\varrho_s)</code>. Default is 0.</p>
</td></tr>
<tr><td><code id="get_bic_fit_1d_+3A_r">r</code></td>
<td>
<p>A vector of exposure times of length ns, or an array of dimension ns
by n.</p>
</td></tr>
<tr><td><code id="get_bic_fit_1d_+3A_y">y</code></td>
<td>
<p>A vector of event counts of length ns, or an array of dimension ns
by n.</p>
</td></tr>
<tr><td><code id="get_bic_fit_1d_+3A_z">Z</code></td>
<td>
<p>(optional) A regression matrix of covariates of dimension n by p.</p>
</td></tr>
<tr><td><code id="get_bic_fit_1d_+3A_bs">Bs</code></td>
<td>
<p>A matrix of B-splines for the time scale <code>s</code>.</p>
</td></tr>
<tr><td><code id="get_bic_fit_1d_+3A_ds">Ds</code></td>
<td>
<p>The difference matrix of the penalty.</p>
</td></tr>
<tr><td><code id="get_bic_fit_1d_+3A_wprior">Wprior</code></td>
<td>
<p>An optional vector of a-priori weights.</p>
</td></tr>
<tr><td><code id="get_bic_fit_1d_+3A_control_algorithm">control_algorithm</code></td>
<td>
<p>A list with optional values for the parameters of
the iterative processes:
</p>

<ul>
<li> <p><code>maxiter</code> The maximum number of iteration for the IWSL algorithm.
Default is 20.
</p>
</li>
<li> <p><code>conv_crit</code> The convergence criteria, expressed as difference between
estimates at iteration i and i+1. Default is <code>1e-5</code>.
</p>
</li>
<li> <p><code>verbose</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> monitors the iteration
process.
</p>
</li>
<li> <p><code>monitor_ev</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> monitors the
evaluation of the model over the <code>log_10(rho_s)</code> values.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>bic</code> value of the fitted model.
</p>

<hr>
<h2 id='get_bic_fit_2d'>Return the BIC of 2ts model</h2><span id='topic+get_bic_fit_2d'></span>

<h3>Description</h3>

<p><code>get_bic_fit_2d()</code> fits the 2ts model with or without individual
level covariates and it returns the BIC of the model.
See also <code>fit2tsmodel_ucminf()</code> and <code>fit2ts()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_bic_fit_2d(
  lrho,
  R,
  Y,
  Z = NULL,
  Bu,
  Bs,
  Iu,
  Is,
  Du,
  Ds,
  Wprior = NULL,
  ridge = 0,
  control_algorithm = list(maxiter = 20, conv_crit = 1e-05, verbose = FALSE, monitor_ev =
    FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_bic_fit_2d_+3A_lrho">lrho</code></td>
<td>
<p>A vector of two elements, the initial values for <code class="reqn">\log_{10}(\varrho_u)</code>
and <code class="reqn">\log_{10}(\varrho_s)</code>.</p>
</td></tr>
<tr><td><code id="get_bic_fit_2d_+3A_r">R</code></td>
<td>
<p>A matrix (or 3d-array) of exposure times of dimension nu by ns
(or nu by ns by n).</p>
</td></tr>
<tr><td><code id="get_bic_fit_2d_+3A_y">Y</code></td>
<td>
<p>A matrix (or 3d-array) of event counts of dimension nu by ns
(or nu by ns by n).</p>
</td></tr>
<tr><td><code id="get_bic_fit_2d_+3A_z">Z</code></td>
<td>
<p>(optional) A regression matrix of covariates values of dimensions
n by p.</p>
</td></tr>
<tr><td><code id="get_bic_fit_2d_+3A_bu">Bu</code></td>
<td>
<p>A matrix of B-splines for the <code>u</code> time scale of dimension nu by cu.</p>
</td></tr>
<tr><td><code id="get_bic_fit_2d_+3A_bs">Bs</code></td>
<td>
<p>A matrix of B-splines for the <code>s</code> time scale of dimension ns by cs.</p>
</td></tr>
<tr><td><code id="get_bic_fit_2d_+3A_iu">Iu</code></td>
<td>
<p>An identity matrix of dimension nbu by nbu.</p>
</td></tr>
<tr><td><code id="get_bic_fit_2d_+3A_is">Is</code></td>
<td>
<p>An identity matrix of dimension nbs by nbs.</p>
</td></tr>
<tr><td><code id="get_bic_fit_2d_+3A_du">Du</code></td>
<td>
<p>The difference matrix over <code>u</code>.</p>
</td></tr>
<tr><td><code id="get_bic_fit_2d_+3A_ds">Ds</code></td>
<td>
<p>The difference matrix over <code>s</code>.</p>
</td></tr>
<tr><td><code id="get_bic_fit_2d_+3A_wprior">Wprior</code></td>
<td>
<p>An optional matrix of a-priori weights.</p>
</td></tr>
<tr><td><code id="get_bic_fit_2d_+3A_ridge">ridge</code></td>
<td>
<p>A ridge penalty parameter: default is 0. This is useful when, in
some cases the algorithm shows convergence problems. In this case, set to a small
number, for example <code>1e-4</code>.</p>
</td></tr>
<tr><td><code id="get_bic_fit_2d_+3A_control_algorithm">control_algorithm</code></td>
<td>
<p>A list with optional values for the parameters of
the iterative processes:
</p>

<ul>
<li> <p><code>maxiter</code> The maximum number of iteration for the IWSL algorithm.
Default is 20.
</p>
</li>
<li> <p><code>conv_crit</code> The convergence criteria, expressed as difference between
estimates at iteration i and i+1. Default is <code>1e-5</code>.
</p>
</li>
<li> <p><code>verbose</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> monitors the iteration
process.
</p>
</li>
<li> <p><code>monitor_ev</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> monitors the
evaluation of the model over the <code>log_10(rho_s)</code> values.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>bic</code> value of the fitted model.
</p>

<hr>
<h2 id='get_hazard_1d'>Get estimated (log-)hazard values with 1 time scale</h2><span id='topic+get_hazard_1d'></span>

<h3>Description</h3>

<p><code>get_hazard_1d()</code> takes as input the results of a model
estimated by <code>fit1ts</code> and it returns the estimated values of the smooth log-hazard
and the smooth hazard together with their standard errors.
</p>
<p>If the model includes covariates, then only the baseline (log-)hazard is returned.
It is possible to provide values that define a new grid for evaluation of the
estimated hazard.
If not specified, the hazard is evaluated on the same grid used for the
binning of the data, and therefore the estimation of the model.
The function will check if the parameters for the new grid
provided by the user are compatible with those originally used to construct
the B-splines for estimating the model. If not, the grid will be adjusted
accordingly and a warning will be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_hazard_1d(fitted_model, plot_grid = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_hazard_1d_+3A_fitted_model">fitted_model</code></td>
<td>
<p>is an object of class <code>"haz1ts"</code>, the output of the function <code>fit1ts()</code>.</p>
</td></tr>
<tr><td><code id="get_hazard_1d_+3A_plot_grid">plot_grid</code></td>
<td>
<p>(optional) A named vector containing the parameters to build a new
grid of intervals over <code>s</code> for plotting the estimated hazard on a finer
grid. This must be of the form: <code>plot_grid = c(smin, smax, ds)</code>,
where <code>smin</code>, <code>smax</code> are the minimum and maximum values desired for the
intervals over <code>s</code>, and <code>ds</code> is the distance between intervals over <code>s</code>. If
not specified, the plotting is done using the same B-splines basis as for
the estimation. The function will check if the parameters for the grid
provided by the user are compatible with those originally used to construct
the B-splines for estimating the model. If not, the grid will be adjusted
accordingly and a warning will be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>new_plot_grid</code> A list of parameters that specify the new grid, of the form
list(&quot;ints&quot;, &quot;smin&quot;, &quot;smax&quot;, &quot;ds&quot;)
</p>
</li>
<li> <p><code>hazard</code> A vector containing the estimated hazard values.
</p>
</li>
<li> <p><code>loghazard</code> A vector containing the estimated log-hazard values.
</p>
</li>
<li> <p><code>log10hazard</code> A vector containing the estimated log10-hazard values.
</p>
</li>
<li> <p><code>SE_hazard</code> A vector containing the estimated SEs for the hazard.
</p>
</li>
<li> <p><code>SE_loghazard</code> A vector containing the estimated SEs for the log-hazard.
</p>
</li>
<li> <p><code>SE_log10hazard</code> A vector containing the estimated SEs for the log10-hazard.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## preparing data - no covariates
dt1ts &lt;- prepare_data(
  data = reccolon2ts,
  s_in = "entrys",
  s_out = "timesr",
  events = "status",
  ds = 180
)

## fitting the model with fit1ts() - default options

mod1 &lt;- fit1ts(dt1ts)
# Obtain 1d hazard
get_hazard_1d(mod1)
# Change grid
get_hazard_1d(mod1,
  plot_grid = c(smin = 0, smax = 2730, ds = 30)
)

</code></pre>

<hr>
<h2 id='get_hazard_1d_LMM'>Get estimated (log-)hazard values with 1 time scale</h2><span id='topic+get_hazard_1d_LMM'></span>

<h3>Description</h3>

<p><code>get_hazard_1d_LMM()</code> takes as input the results of a model
estimated by <code>fit1ts</code> and it returns the estimated values of the smooth log-hazard
and the smooth hazard together with their standard errors.
</p>
<p>If the model includes covariates, then only the baseline (log-)hazard is returned.
It is possible to provide values that define a new grid for evaluation of the
estimated hazard.
If not specified, the hazard is evaluated on the same grid used for the
binning of the data, and therefore the estimation of the model.
The function will check if the parameters for the new grid
provided by the user are compatible with those originally used to construct
the B-splines for estimating the model. If not, the grid will be adjusted
accordingly and a warning will be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_hazard_1d_LMM(fitted_model, plot_grid = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_hazard_1d_LMM_+3A_fitted_model">fitted_model</code></td>
<td>
<p>is an object of class <code>"haz1tsLMM"</code>, the output of the function <code>fit1ts()</code>.</p>
</td></tr>
<tr><td><code id="get_hazard_1d_LMM_+3A_plot_grid">plot_grid</code></td>
<td>
<p>(optional) A named vector containing the parameters to build a new
grid of intervals over <code>s</code> for plotting the estimated hazard on a finer
grid. This must be of the form: <code>plot_grid = c(smin, smax, ds)</code>,
where <code>smin</code>, <code>smax</code> are the minimum and maximum values desired for the
intervals over <code>s</code>, and <code>ds</code> is the distance between intervals over <code>s</code>. If
not specified, the plotting is done using the same B-splines basis as for
the estimation. The function will check if the parameters for the grid
provided by the user are compatible with those originally used to construct
the B-splines for estimating the model. If not, the grid will be adjusted
accordingly and a warning will be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>new_plot_grid</code> A list of parameters that specify the new grid, of the form
list(&quot;ints&quot;, &quot;smin&quot;, &quot;smax&quot;, &quot;ds&quot;)
</p>
</li>
<li> <p><code>hazard</code> A vector containing the estimated hazard values.
</p>
</li>
<li> <p><code>loghazard</code> A vector containing the estimated log-hazard values.
</p>
</li>
<li> <p><code>log10hazard</code> A vector containing the estimated log10-hazard values.
</p>
</li>
<li> <p><code>SE_hazard</code> A vector containing the estimated SEs for the hazard.
</p>
</li>
<li> <p><code>SE_loghazard</code> A vector containing the estimated SEs for the log-hazard.
</p>
</li>
<li> <p><code>SE_log10hazard</code> A vector containing the estimated SEs for the log10-hazard.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## preparing data - no covariates
dt1ts &lt;- prepare_data(
  data = reccolon2ts,
  s_in = "entrys",
  s_out = "timesr",
  events = "status",
  ds = 180
)

## fitting the model with fit1ts()

mod1 &lt;- fit1ts(dt1ts,
  optim_method = "LMMsolver"
)
# Obtain 1d hazard
get_hazard_1d_LMM(mod1)
# Change grid
get_hazard_1d_LMM(mod1,
  plot_grid = c(smin = 0, smax = 2730, ds = 30)
)

</code></pre>

<hr>
<h2 id='get_hazard_2d'>Get estimated (log-)hazard surface with 2 time scales</h2><span id='topic+get_hazard_2d'></span>

<h3>Description</h3>

<p><code>get_hazard_2d()</code> takes as input the results of a model
estimated by <code>fit2ts</code> and it returns the estimated smooth log-hazard
and the smooth hazard together with their standard errors.
</p>
<p>It is possible to provide values that define a new grid for evaluation of the
estimated hazard.
If not specified, the hazard is evaluated on the same grid used for the
binning of the data, and therefore the estimation of the model.
The function will check if the parameters for the new grid
provided by the user are compatible with those originally used to construct
the B-splines for estimating the model. If not, the grid will be adjusted
accordingly and a warning will be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_hazard_2d(
  fitted_model,
  plot_grid = NULL,
  where_slices = NULL,
  direction = c("u", "s", NULL),
  tmax = NULL,
  midpoints = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_hazard_2d_+3A_fitted_model">fitted_model</code></td>
<td>
<p>is an object of class <code>"haz2ts"</code>, the output of the function <code>fit2ts()</code>.</p>
</td></tr>
<tr><td><code id="get_hazard_2d_+3A_plot_grid">plot_grid</code></td>
<td>
<p>(optional) A list containing the parameters to build a new
finer grid of intervals over u and s for plotting. This must be of the
form: <code>plot_grid = list(c(umin, umax, du), c(smin, smax, ds))</code>, where
<code>umin</code>, <code>umax</code> and <code>smin</code>, <code>smax</code> are the minimum and maximum values
desired for the intervals over <code>u</code> and <code>s</code> respectively, and <code>du</code>, <code>ds</code> are
distances between intervals over <code>u</code> and <code>s</code> respectively. Specifying a new
denser grid is used to evaluate the B-spline bases used for estimation on
such grid and plot the estimated surfaces with a greater level of details.
If not specified, the plotting is done using the same B-splines bases as
for the estimation. The function will check if the parameters for the grid
provided by the user are compatible with those originally used to construct
the B-splines for estimating the model. If not, the grid will be adjusted
accordingly and a warning will be returned.</p>
</td></tr>
<tr><td><code id="get_hazard_2d_+3A_where_slices">where_slices</code></td>
<td>
<p>A vector of values for the cutting points of the desired
slices of the surface. If <code>which_plot == "slices"</code>, please provide this
argument. Please also provide this argument in case <code style="white-space: pre;">&#8288;which_plot = "survival&#8288;</code>
or <code style="white-space: pre;">&#8288;which_plot = "cumhaz&#8288;</code> and <code>surv_slices = TRUE</code> or <code>cumhaz_slices = TRUE</code>,
respectively.</p>
</td></tr>
<tr><td><code id="get_hazard_2d_+3A_direction">direction</code></td>
<td>
<p>If <code>which_plot == "slices"</code>, indicates the direction for
cutting the surface. If <code>u</code>, then the surface will be cut at the selected
values of <code>u</code> (indicated by <code>where_slices</code>), hence obtaining one-dimensional
curves over <code>s</code>. If <code>s</code>, then the surface will be cut at the selected values
of <code>s</code> (indicated by <code>where_slices</code>), hence obtaining one-dimensional curves
over <code>u</code>.</p>
</td></tr>
<tr><td><code id="get_hazard_2d_+3A_tmax">tmax</code></td>
<td>
<p>The maximum value of <code>t</code> that should be plotted.</p>
</td></tr>
<tr><td><code id="get_hazard_2d_+3A_midpoints">midpoints</code></td>
<td>
<p>A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code>, the estimated
quantities are evaluated at the midpoints of the rectangles
(or parallelograms) of the grids, rather than at each grid-point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>new_plot_grid</code> A list of parameters that specify the new grid, of the form
list(&quot;intu&quot;, &quot;umin&quot;, &quot;umax&quot;, &quot;du&quot;, &quot;ints&quot;, &quot;smin&quot;, &quot;smax&quot;, &quot;ds&quot;)
</p>
</li>
<li> <p><code>nBu</code> The B-spline basis for <code>u</code>, evaluated over the new grid.
</p>
</li>
<li> <p><code>nBs</code> The B-spline basis for <code>s</code>, evaluated over the new grid.
</p>
</li>
<li> <p><code>hazard</code> A matrix containing the estimated hazard values.
</p>
</li>
<li> <p><code>loghazard</code> A matrix containing the estimated log-hazard values.
</p>
</li>
<li> <p><code>log10hazard</code>A matrix containing the estimated log10-hazard values.
</p>
</li>
<li> <p><code>SE_hazard</code> A matrix containing the estimated SEs for the hazard.
</p>
</li>
<li> <p><code>SE_loghazard</code> A matrix containing the estimated SEs for the log-hazard.
</p>
</li>
<li> <p><code>SE_log10haz</code> A matrix containing the estimated SEs for the log10-hazard.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Create some fake data - the bare minimum
id &lt;- 1:20
u &lt;- c(5.43, 3.25, 8.15, 5.53, 7.28, 6.61, 5.91, 4.94, 4.25, 3.86, 4.05, 6.86,
       4.94, 4.46, 2.14, 7.56, 5.55, 7.60, 6.46, 4.96)
s &lt;- c(0.44, 4.89, 0.92, 1.81, 2.02, 1.55, 3.16, 6.36, 0.66, 2.02, 1.22, 3.96,
       7.07, 2.91, 3.38, 2.36, 1.74, 0.06, 5.76, 3.00)
ev &lt;- c(1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1)#'

fakedata &lt;- as.data.frame(cbind(id, u, s, ev))
fakedata2ts &lt;- prepare_data(data = fakedata,
                            u = "u",
                            s_out = "s",
                            ev = "ev",
                            ds = .5)
# Fit a fake model - not optimal smoothing
fakemod &lt;- fit2ts(fakedata2ts,
                  optim_method = "grid_search",
                  lrho = list(seq(1 ,1.5 ,.5),
                              seq(1 ,1.5 ,.5)))
# Obtain 2d hazard
get_hazard_2d(fakemod)

get_hazard_2d(fakemod,
          plot_grid = list(c(umin = 3, umax = 8.5, du = .1),
                           c(smin = 0, smax = 7.1, ds = .1)))
</code></pre>

<hr>
<h2 id='get_hazard_2d_LMM'>Get estimated (log-)hazard surface with 2 time scales</h2><span id='topic+get_hazard_2d_LMM'></span>

<h3>Description</h3>

<p><code>get_hazard_2d_LMM()</code> takes as input an object of class <code>'haz2tsLMM'</code>
and it returns the estimated smooth log-hazard, the log10-hazard and the
hazard surface together with their standard errors.
</p>
<p>It is possible to provide values that define a new grid for evaluation of the
estimated hazard.
If not specified, the hazard is evaluated on the same grid used for the
binning of the data, and therefore the estimation of the model.
The function will check if the parameters for the new grid
provided by the user are compatible with those originally used to construct
the B-splines for estimating the model. If not, the grid will be adjusted
accordingly and a warning will be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_hazard_2d_LMM(
  fitted_model,
  plot_grid = NULL,
  where_slices = NULL,
  direction = c("u", "s", NULL),
  tmax = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_hazard_2d_LMM_+3A_fitted_model">fitted_model</code></td>
<td>
<p>is an object of class <code>'haz2tsLMM'</code>
the output of the function <code>fit2ts()</code>.</p>
</td></tr>
<tr><td><code id="get_hazard_2d_LMM_+3A_plot_grid">plot_grid</code></td>
<td>
<p>A list containing the parameters to build a new
finer grid of intervals over <code>u</code> and <code>s</code> for plotting. This must be of the
form: <code>plot_grid = list(c(umin, umax, du), c(smin, smax, ds))</code>, where
<code>umin</code>, <code>umax</code> and <code>smin</code>, <code>smax</code> are the minimum and maximum values
desired for the intervals over <code>u</code> and <code>s</code> respectively, and <code>du</code>, <code>ds</code> are
distances between intervals over <code>u</code> and <code>s</code> respectively. Specifying a new
denser grid is used to evaluate the B-spline bases used for estimation on
such grid and plot the estimated surfaces with a greater level of details.
If not specified, the plotting is done using the same B-splines bases as
for the estimation. The function will check if the parameters for the grid
provided by the user are compatible with those originally used to construct
the B-splines for estimating the model. If not, the grid will be adjusted
accordingly and a warning will be returned. While for objects of class 'haz2ts'
this is an optional input, we strongly recommend to provide the plotting
grid for object of class 'haz2tsLMM', given that evaluation of the B-splines
works a bit differently in LMMsolver.</p>
</td></tr>
<tr><td><code id="get_hazard_2d_LMM_+3A_where_slices">where_slices</code></td>
<td>
<p>A vector of values for the cutting points of the desired
slices of the surface. If <code>which_plot == "slices"</code>, please provide this
argument. Please also provide this argument in case <code style="white-space: pre;">&#8288;which_plot = "survival&#8288;</code>
or <code style="white-space: pre;">&#8288;which_plot = "cumhaz&#8288;</code> and <code>surv_slices = TRUE</code> or <code>cumhaz_slices = TRUE</code>,
respectively.</p>
</td></tr>
<tr><td><code id="get_hazard_2d_LMM_+3A_direction">direction</code></td>
<td>
<p>If <code>which_plot == "slices"</code>, indicates the direction for
cutting the surface. If <code>u</code>, then the surface will be cut at the selected
values of <code>u</code> (indicated by <code>where_slices</code>), hence obtaining one-dimensional
curves over <code>s</code>. If <code>s</code>, then the surface will be cut at the selected values
of <code>s</code> (indicated by <code>where_slices</code>), hence obtaining one-dimensional curves
over <code>u</code>.</p>
</td></tr>
<tr><td><code id="get_hazard_2d_LMM_+3A_tmax">tmax</code></td>
<td>
<p>The maximum value of <code>t</code> that should be plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>new_plot_grid</code> A list of parameters that specify the new grid, of the form
list(&quot;intu&quot;, &quot;umin&quot;, &quot;umax&quot;, &quot;du&quot;, &quot;ints&quot;, &quot;smin&quot;, &quot;smax&quot;, &quot;ds&quot;)
</p>
</li>
<li> <p><code>hazard</code> A matrix containing the estimated hazard values.
</p>
</li>
<li> <p><code>loghazard</code> A matrix containing the estimated log-hazard values.
</p>
</li>
<li> <p><code>log10hazard</code>A matrix containing the estimated log10-hazard values.
</p>
</li>
<li> <p><code>SE_hazard</code> A matrix containing the estimated SEs for the hazard.
</p>
</li>
<li> <p><code>SE_loghazard</code> A matrix containing the estimated SEs for the log-hazard.
</p>
</li>
<li> <p><code>SE_log10haz</code> A matrix containing the estimated SEs for the log10-hazard.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Create some fake data - the bare minimum
id &lt;- 1:20
u &lt;- c(
  5.43, 3.25, 8.15, 5.53, 7.28, 6.61, 5.91, 4.94, 4.25, 3.86, 4.05, 6.86,
  4.94, 4.46, 2.14, 7.56, 5.55, 7.60, 6.46, 4.96
)
s &lt;- c(
  0.44, 4.89, 0.92, 1.81, 2.02, 1.55, 3.16, 6.36, 0.66, 2.02, 1.22, 3.96,
  7.07, 2.91, 3.38, 2.36, 1.74, 0.06, 5.76, 3.00
)
ev &lt;- c(1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1) #'

fakedata &lt;- as.data.frame(cbind(id, u, s, ev))
fakedata2ts &lt;- prepare_data(data = fakedata,
                            u = "u",
                            s_out = "s",
                            ev = "ev",
                            ds = .5)
# Fit a fake model - not optimal smoothing
fakemod &lt;- fit2ts(fakedata2ts,
  optim_method = "LMMsolver"
)

# Get hazard
get_hazard_2d_LMM(fakemod)

# Use a finer grid of points
get_hazard_2d_LMM(fakemod,
                 plot_grid = list(c(umin = 3, umax = 8.5, du = .1),
                                  c(smin = 0, smax = 7.1, ds = .1)))

</code></pre>

<hr>
<h2 id='get_hr'>Get the Hazard Ratios with their Standard Errors</h2><span id='topic+get_hr'></span>

<h3>Description</h3>

<p><code>get_hr()</code> takes as input the results of a model with covariates
estimated by <code>fit2ts</code> or <code>fit1ts</code> and returns the estimated hazard ratios
together with their standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_hr(fitted_model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_hr_+3A_fitted_model">fitted_model</code></td>
<td>
<p>A list returned by the function <code>fit2ts</code> or <code>fit1ts</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>HR</code> A vector of hazard ratios (calculated as <code class="reqn">\exp(\hat\beta)</code>).
</p>
</li>
<li> <p><code>SE_HR</code> A vector of Standard Errors for the hazard ratios calculated
via the delta method.
</p>
</li>
<li> <p><code>beta</code> A vector of the estimated <code class="reqn">\hat\beta</code> coefficients.
</p>
</li>
<li> <p><code>SE_beta</code> A vector of the Standard Errors for the beta coefficients.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Create some fake data - the bare minimum
id &lt;- 1:20
u &lt;- c(5.43, 3.25, 8.15, 5.53, 7.28, 6.61, 5.91, 4.94, 4.25, 3.86, 4.05, 6.86,
       4.94, 4.46, 2.14, 7.56, 5.55, 7.60, 6.46, 4.96)
s &lt;- c(0.44, 4.89, 0.92, 1.81, 2.02, 1.55, 3.16, 6.36, 0.66, 2.02, 1.22, 3.96,
       7.07, 2.91, 3.38, 2.36, 1.74, 0.06, 5.76, 3.00)
ev &lt;- c(1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1)
x1 &lt;- c(0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0)

fakedata &lt;- as.data.frame(cbind(id, u, s, ev, x1))
fakedata2ts &lt;- prepare_data(data = fakedata,
                            u = "u",
                            s_out = "s",
                            ev = "ev",
                            ds = .5,
                            individual = TRUE,
                            covs = "x1")
# Fit a fake model - not optimal smoothing
fakemod &lt;- fit2ts(fakedata2ts,
                  optim_method = "grid_search",
                  lrho = list(seq(1, 1.5, .5),
                              seq(1, 1.5, .5)))
get_hr(fakemod)
</code></pre>

<hr>
<h2 id='getAIC_BIC_LMM'>Calculates AIC and BIC from object fitted via LMMsolver</h2><span id='topic+getAIC_BIC_LMM'></span>

<h3>Description</h3>

<p><code>getAIC_BIC_LMM</code> is an utility function that takes an object of class
<code>'LMMsolve'</code> fitted via <code>fit1ts()</code> or <code>fit2ts()</code> and calculates
AIC, BIC and ED.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAIC_BIC_LMM(fit, offset)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getAIC_BIC_LMM_+3A_fit">fit</code></td>
<td>
<p>An object of class <code>"LMMsolve"</code></p>
</td></tr>
<tr><td><code id="getAIC_BIC_LMM_+3A_offset">offset</code></td>
<td>
<p>The vector of exposure times from dataLMM</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with:
* <code>ED</code> effective dimension of the full model;
* <code>EDbase</code> effective dimension of the baseline hazard only;
* <code>Dev</code> deviance;
* <code>AIC</code> the aic;
* <code>BIC</code> the bic;
* <code>n_beta</code> the number of estimated covariate parameters (if PH model).
</p>

<hr>
<h2 id='GLAM_1d_covariates'>Fit the 1d GLAM with covariates</h2><span id='topic+GLAM_1d_covariates'></span>

<h3>Description</h3>

<p><code>GLAM_1d_covariates()</code> fits a GLAM for the hazard with one time
scale, with covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLAM_1d_covariates(
  R,
  Y,
  Bs,
  Z = Z,
  Wprior = NULL,
  P,
  control_algorithm = list(maxiter = 20, conv_crit = 1e-05, verbose = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GLAM_1d_covariates_+3A_r">R</code></td>
<td>
<p>A 2d-array of dimensions ns by n containing exposure times.</p>
</td></tr>
<tr><td><code id="GLAM_1d_covariates_+3A_y">Y</code></td>
<td>
<p>A 2d-array of dimensions ns by n containing event indicators.</p>
</td></tr>
<tr><td><code id="GLAM_1d_covariates_+3A_bs">Bs</code></td>
<td>
<p>A matrix of B-splines for the <code>s</code> time scale of dimension ns by cs.</p>
</td></tr>
<tr><td><code id="GLAM_1d_covariates_+3A_z">Z</code></td>
<td>
<p>A regression matrix of covariates values of dimensions n by p.</p>
</td></tr>
<tr><td><code id="GLAM_1d_covariates_+3A_wprior">Wprior</code></td>
<td>
<p>An optional vector of length ns of a-priori weights.</p>
</td></tr>
<tr><td><code id="GLAM_1d_covariates_+3A_p">P</code></td>
<td>
<p>The penalty matrix of dimension cs by cs.</p>
</td></tr>
<tr><td><code id="GLAM_1d_covariates_+3A_control_algorithm">control_algorithm</code></td>
<td>
<p>A list with optional values for the parameters of
iterative processes:
*<code>maxiter</code> The maximum number of iterations for the IWSL algorithm,
default is 20 .
* <code>conv_crit</code> The convergence criteria, expressed as difference between
estimates at iteration i and i+1, default is <code>1e-5</code>.
* <code>verbose</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code>, monitor the
iteration process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>alpha</code> The vector of estimated P-splines coefficients of length cs.
</p>
</li>
<li> <p><code>SE_alpha</code> The vector of estimated Standard Errors for the <code>alpha</code> coefficients,
of length cs.
</p>
</li>
<li> <p><code>beta</code> The vector of length p of estimated covariates coefficients.
</p>
</li>
<li> <p><code>se_beta</code> The vector of length p of estimated Standard Errors for the <code>beta</code>
coefficients.
</p>
</li>
<li> <p><code>eta0</code> The vector of values of the baseline linear predictor (log-hazard).
</p>
</li>
<li> <p><code>H</code> The hat-matrix.
</p>
</li>
<li> <p><code>Cov</code> The full variance-covariance matrix.
</p>
</li>
<li> <p><code>deviance</code> The deviance.
</p>
</li>
<li> <p><code>ed</code> The effective dimension of the model.
</p>
</li>
<li> <p><code>aic</code> The value of the AIC.
</p>
</li>
<li> <p><code>bic</code> The value of the BIC.
</p>
</li>
<li> <p><code>Bbases</code> a list with the B-spline basis <code>Bs</code> (this is a list for
compatibility with functions in 2d).
</p>
</li></ul>


<hr>
<h2 id='GLAM_2d_covariates'>Fit the 2d GLAM with covariates</h2><span id='topic+GLAM_2d_covariates'></span>

<h3>Description</h3>

<p><code>GLAM_2d_covariates()</code> fits a GLAM for the hazard with two time
scales, with covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLAM_2d_covariates(
  R,
  Y,
  Bu,
  Bs,
  Z,
  Wprior = NULL,
  P,
  ridge = 0,
  control_algorithm = list(maxiter = 20, conv_crit = 1e-05, verbose = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GLAM_2d_covariates_+3A_r">R</code></td>
<td>
<p>A 3d-array of dimensions nu by ns by n containing exposure times.</p>
</td></tr>
<tr><td><code id="GLAM_2d_covariates_+3A_y">Y</code></td>
<td>
<p>A 3d-array of dimensions nu by ns by n containing event indicators.</p>
</td></tr>
<tr><td><code id="GLAM_2d_covariates_+3A_bu">Bu</code></td>
<td>
<p>A matrix of B-splines for the <code>u</code> time scale of dimension nu by cu.</p>
</td></tr>
<tr><td><code id="GLAM_2d_covariates_+3A_bs">Bs</code></td>
<td>
<p>A matrix of B-splines for the <code>s</code> time scale of dimension ns by cs.</p>
</td></tr>
<tr><td><code id="GLAM_2d_covariates_+3A_z">Z</code></td>
<td>
<p>(optional) A regression matrix of covariates values of dimensions
n by p.</p>
</td></tr>
<tr><td><code id="GLAM_2d_covariates_+3A_wprior">Wprior</code></td>
<td>
<p>An optional matrix of a-priori weights.</p>
</td></tr>
<tr><td><code id="GLAM_2d_covariates_+3A_p">P</code></td>
<td>
<p>The penalty matrix of dimension cucs by cucs.</p>
</td></tr>
<tr><td><code id="GLAM_2d_covariates_+3A_ridge">ridge</code></td>
<td>
<p>A ridge penalty parameter: default is 0.</p>
</td></tr>
<tr><td><code id="GLAM_2d_covariates_+3A_control_algorithm">control_algorithm</code></td>
<td>
<p>A list with optional values for the parameters of
the iterative processes:
</p>

<ul>
<li> <p><code>maxiter</code> The maximum number of iteration for the IWSL algorithm.
Default is 20.
</p>
</li>
<li> <p><code>conv_crit</code> The convergence criteria, expressed as difference between
estimates at iteration i and i+1. Default is <code>1e-5</code>.
</p>
</li>
<li> <p><code>verbose</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> monitors the iteration
process.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>Alpha</code> The matrix of estimated P-splines coefficients of dimension
cu by cs.
</p>
</li>
<li> <p><code>Cov_alpha</code> The variance-covariance matrix of the <code>Alpha</code> coefficients,
of dimension cucs by cucs.
</p>
</li>
<li> <p><code>beta</code> The vector of length p of estimated covariates coefficients.
</p>
</li>
<li> <p><code>Cov_beta</code> The variance-covariance matrix of the <code>beta</code> coefficients,
of dimension p by p.
</p>
</li>
<li> <p><code>SE_beta</code> The vector of length p of estimated Standard Errors for the <code>beta</code>
coefficients.
</p>
</li>
<li> <p><code>Eta0</code> The matrix of values of the baseline linear predictor (log-hazard)
of dimension nu by ns.
</p>
</li>
<li> <p><code>H</code> The hat-matrix.
</p>
</li>
<li> <p><code>deviance</code> The deviance.
</p>
</li>
<li> <p><code>ed</code> The effective dimension of the model.
</p>
</li>
<li> <p><code>aic</code> The value of the AIC.
</p>
</li>
<li> <p><code>bic</code> The value of the BIC.
</p>
</li>
<li> <p><code>Bbases</code> a list with the B-spline bases <code>Bu</code> and <code>Bs</code>.
</p>
</li></ul>


<hr>
<h2 id='GLAM_2d_no_covariates'>Fit the 2d GLAM without covariates</h2><span id='topic+GLAM_2d_no_covariates'></span>

<h3>Description</h3>

<p><code>GLAM_2d_no_covariates()</code> fits a GLAM for the hazard with two time
scales, without covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLAM_2d_no_covariates(
  R,
  Y,
  Bu,
  Bs,
  Wprior = NULL,
  P,
  ridge = 0,
  control_algorithm = list(maxiter = 20, conv_crit = 1e-05, verbose = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GLAM_2d_no_covariates_+3A_r">R</code></td>
<td>
<p>A matrix of exposure times of dimension nu by ns.</p>
</td></tr>
<tr><td><code id="GLAM_2d_no_covariates_+3A_y">Y</code></td>
<td>
<p>A matrix of event counts of dimension nu by ns.</p>
</td></tr>
<tr><td><code id="GLAM_2d_no_covariates_+3A_bu">Bu</code></td>
<td>
<p>A matrix of B-splines for the <code>u</code> time scale of dimension nu by cu.</p>
</td></tr>
<tr><td><code id="GLAM_2d_no_covariates_+3A_bs">Bs</code></td>
<td>
<p>A matrix of B-splines for the <code>s</code> time scale of dimension ns by cs.</p>
</td></tr>
<tr><td><code id="GLAM_2d_no_covariates_+3A_wprior">Wprior</code></td>
<td>
<p>An optional matrix of a-priori weights.</p>
</td></tr>
<tr><td><code id="GLAM_2d_no_covariates_+3A_p">P</code></td>
<td>
<p>The penalty matrix of dimension cucs by cucs.</p>
</td></tr>
<tr><td><code id="GLAM_2d_no_covariates_+3A_ridge">ridge</code></td>
<td>
<p>A ridge penalty parameter: default is 0.</p>
</td></tr>
<tr><td><code id="GLAM_2d_no_covariates_+3A_control_algorithm">control_algorithm</code></td>
<td>
<p>A list with optional values for the parameters of
the iterative processes:
</p>

<ul>
<li> <p><code>maxiter</code> The maximum number of iteration for the IWSL algorithm.
Default is 20.
</p>
</li>
<li> <p><code>conv_crit</code> The convergence criteria, expressed as difference between
estimates at iteration i and i+1. Default is <code>1e-5</code>.
</p>
</li>
<li> <p><code>verbose</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> monitors the iteration
process.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>Alpha</code> The matrix of estimated P-splines coefficients of dimension
cu by cs.
</p>
</li>
<li> <p><code>Cov_alpha</code> The variance-covariance matrix of the <code>Alpha</code> coefficients,
of dimension cucs by cucs.
</p>
</li>
<li> <p><code>Eta0</code> The matrix of values of the baseline linear predictor (log-hazard)
of dimension nu by ns.
</p>
</li>
<li> <p><code>H</code> The hat-matrix.
</p>
</li>
<li> <p><code>deviance</code> The deviance.
</p>
</li>
<li> <p><code>ed</code> The effective dimension of the model.
</p>
</li>
<li> <p><code>aic</code> The value of the AIC.
</p>
</li>
<li> <p><code>bic</code> The value of the BIC.
</p>
</li>
<li> <p><code>Bbases</code> a list with the B-spline bases <code>Bu</code> and <code>Bs</code>.
</p>
</li></ul>


<hr>
<h2 id='grid_search_1d'>Grid search for the optimal 1ts model</h2><span id='topic+grid_search_1d'></span>

<h3>Description</h3>

<p><code>grid_search_1d()</code> performs a grid search for the minimum
AIC or BIC of the one time scale model.
</p>
<p>It finds the optimal values of <code>log_10(rho_s)</code> and returns the estimated
optimal model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_search_1d(
  r,
  y,
  Z = NULL,
  lrho,
  Bs,
  Ds,
  Wprior = NULL,
  optim_criterion = c("aic", "bic"),
  control_algorithm = list(maxiter = 20, conv_crit = 1e-05, verbose = FALSE, monitor_ev =
    FALSE),
  par_gridsearch = list(plot_aic = FALSE, plot_bic = FALSE, return_aic = TRUE, return_bic
    = TRUE, mark_optimal = TRUE, main_aic = "AIC grid", main_bic = "BIC grid")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid_search_1d_+3A_r">r</code></td>
<td>
<p>A vector of exposure times of length ns, or an array of dimension ns
by n.</p>
</td></tr>
<tr><td><code id="grid_search_1d_+3A_y">y</code></td>
<td>
<p>A vector of event counts of length ns, or an array of dimension ns
by n.</p>
</td></tr>
<tr><td><code id="grid_search_1d_+3A_z">Z</code></td>
<td>
<p>(optional) A regression matrix of covariates of dimension n by p.</p>
</td></tr>
<tr><td><code id="grid_search_1d_+3A_lrho">lrho</code></td>
<td>
<p>A vector of <code>log_10(rho_s)</code> values.</p>
</td></tr>
<tr><td><code id="grid_search_1d_+3A_bs">Bs</code></td>
<td>
<p>A matrix of B-splines for the time scale <code>s</code>.</p>
</td></tr>
<tr><td><code id="grid_search_1d_+3A_ds">Ds</code></td>
<td>
<p>The difference matrix of the penalty.</p>
</td></tr>
<tr><td><code id="grid_search_1d_+3A_wprior">Wprior</code></td>
<td>
<p>An optional vector of a-priori weights.</p>
</td></tr>
<tr><td><code id="grid_search_1d_+3A_optim_criterion">optim_criterion</code></td>
<td>
<p>The criterion to be used for optimization:
<code>"aic"</code> (default) or <code>"bic"</code>. BIC penalized model complexity more strongly
than AIC, so that its usage is recommended when a smoother fit is preferable
(see also Camarda, 2012).</p>
</td></tr>
<tr><td><code id="grid_search_1d_+3A_control_algorithm">control_algorithm</code></td>
<td>
<p>A list with optional values for the parameters of
the iterative processes:
</p>

<ul>
<li> <p><code>maxiter</code> The maximum number of iteration for the IWSL algorithm.
Default is 20.
</p>
</li>
<li> <p><code>conv_crit</code> The convergence criteria, expressed as difference between
estimates at iteration i and i+1. Default is <code>1e-5</code>.
</p>
</li>
<li> <p><code>verbose</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> monitors the iteration
process.
</p>
</li>
<li> <p><code>monitor_ev</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> monitors the
evaluation of the model over the <code>log_10(rho_s)</code> values.
</p>
</li></ul>
</td></tr>
<tr><td><code id="grid_search_1d_+3A_par_gridsearch">par_gridsearch</code></td>
<td>
<p>A list of parameters for the grid_search:
</p>

<ul>
<li> <p><code>plot_aic</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code>, plot the AIC values
over the grid of <code>log_10(rhos)</code> values.
</p>
</li>
<li> <p><code>plot_bic</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code>, plot the BIC values
over the grid of <code>log_10(rhos)</code> values.
</p>
</li>
<li> <p><code>return_aic</code> A Boolean. Default is <code>TRUE</code>. Return the AIC values.
</p>
</li>
<li> <p><code>return_bic</code> A Boolean. Default is <code>TRUE</code>. Return the BIC values.
</p>
</li>
<li> <p><code>mark_optimal</code> A Boolean. Default is <code>TRUE</code>. If the plot of the AIC or BIC
values is returned, marks the optimal <code>log_10(rho_s)</code> in the plot.
</p>
</li>
<li> <p><code>main_aic</code> The title of the AIC plot. Default is <code>"AIC grid"</code>.
</p>
</li>
<li> <p><code>main_bic</code> The title of the BIC plot. Default is <code>"BIC grid"</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>h1tsfit</code> with the following elements:
</p>

<ul>
<li> <p><code>optimal_model</code> A list containing the results of the optimal model.
</p>
</li>
<li> <p><code>optimal_logrho</code> The optimal value of <code>log10(rho_s)</code>.
</p>
</li>
<li> <p><code>P_optimal</code> The optimal penalty matrix P.
</p>
</li>
<li> <p><code>AIC</code> (if <code>par_gridsearch$return_aic == TRUE</code>) The vector of AIC values.
</p>
</li>
<li> <p><code>BIC</code> (if <code>par_gridsearch$return_bic == TRUE</code>) The vector of BIC values.
</p>
</li></ul>



<h3>References</h3>

<p>Camarda, C. G. (2012). &quot;MortalitySmooth: An R Package for
Smoothing Poisson Counts with P-Splines.&quot;
Journal of Statistical Software, 50(1), 1–24.
https://doi.org/10.18637/jss.v050.i01
</p>

<hr>
<h2 id='grid_search_2d'>Grid search for the optimal 2ts model</h2><span id='topic+grid_search_2d'></span>

<h3>Description</h3>

<p><code>grid_search_2d()</code> performs a grid search for the minimum
AIC or BIC of the two time scales model.
</p>
<p>It finds the optimal values of <code>log_10(rho_u)</code> and <code>log_10(rho_s)</code> and
returns the estimated optimal model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_search_2d(
  lru,
  lrs,
  R,
  Y,
  Bu,
  Bs,
  Z = NULL,
  Iu,
  Is,
  Du,
  Ds,
  Wprior = NULL,
  ridge = 0,
  optim_criterion = c("aic", "bic"),
  control_algorithm = list(maxiter = 20, conv_crit = 1e-05, verbose = FALSE, monitor_ev =
    FALSE),
  par_gridsearch = list(plot_aic = FALSE, plot_bic = FALSE, return_aic = TRUE, return_bic
    = TRUE, col = grey.colors(n = 10), plot_contour = FALSE, mark_optimal = TRUE,
    main_aic = "AIC grid", main_bic = "BIC grid")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid_search_2d_+3A_lru">lru</code></td>
<td>
<p>A vector of <code>log_10(rho_u)</code> values.</p>
</td></tr>
<tr><td><code id="grid_search_2d_+3A_lrs">lrs</code></td>
<td>
<p>A vector of <code>log_10(rho_s)</code> values.</p>
</td></tr>
<tr><td><code id="grid_search_2d_+3A_r">R</code></td>
<td>
<p>A matrix (or 3d-array) of exposure times of dimension nu by ns
(or nu by ns by n).</p>
</td></tr>
<tr><td><code id="grid_search_2d_+3A_y">Y</code></td>
<td>
<p>A matrix (or 3d-array) of event counts of dimension nu by ns
(or nu by ns by n).</p>
</td></tr>
<tr><td><code id="grid_search_2d_+3A_bu">Bu</code></td>
<td>
<p>A matrix of B-splines for the <code>u</code> time scale of dimension nu by cu.</p>
</td></tr>
<tr><td><code id="grid_search_2d_+3A_bs">Bs</code></td>
<td>
<p>A matrix of B-splines for the <code>s</code> time scale of dimension ns by cs.</p>
</td></tr>
<tr><td><code id="grid_search_2d_+3A_z">Z</code></td>
<td>
<p>(optional) A regression matrix of covariates values of dimensions
n by p.</p>
</td></tr>
<tr><td><code id="grid_search_2d_+3A_iu">Iu</code></td>
<td>
<p>An identity matrix of dimension nbu by nbu.</p>
</td></tr>
<tr><td><code id="grid_search_2d_+3A_is">Is</code></td>
<td>
<p>An identity matrix of dimension nbs by nbs.</p>
</td></tr>
<tr><td><code id="grid_search_2d_+3A_du">Du</code></td>
<td>
<p>The difference matrix over <code>u</code>.</p>
</td></tr>
<tr><td><code id="grid_search_2d_+3A_ds">Ds</code></td>
<td>
<p>The difference matrix over <code>s</code>.</p>
</td></tr>
<tr><td><code id="grid_search_2d_+3A_wprior">Wprior</code></td>
<td>
<p>An optional matrix of a-priori weights.</p>
</td></tr>
<tr><td><code id="grid_search_2d_+3A_ridge">ridge</code></td>
<td>
<p>A ridge penalty parameter: default is 0. This is useful when, in
some cases the algorithm shows convergence problems. In this case, set to a small
number, for example <code>1e-4</code>.</p>
</td></tr>
<tr><td><code id="grid_search_2d_+3A_optim_criterion">optim_criterion</code></td>
<td>
<p>The criterion to be used for optimization:
<code>"aic"</code> (default) or <code>"bic"</code>. BIC penalized model complexity more strongly
than AIC, so that its usage is recommended when a smoother fit is preferable
(see also Camarda, 2012).</p>
</td></tr>
<tr><td><code id="grid_search_2d_+3A_control_algorithm">control_algorithm</code></td>
<td>
<p>A list with optional values for the parameters of
the iterative processes:
</p>

<ul>
<li> <p><code>maxiter</code> The maximum number of iteration for the IWSL algorithm.
Default is 20.
</p>
</li>
<li> <p><code>conv_crit</code> The convergence criteria, expressed as difference between
estimates at iteration i and i+1. Default is <code>1e-5</code>.
</p>
</li>
<li> <p><code>verbose</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> monitors the iteration
process.
</p>
</li>
<li> <p><code>monitor_ev</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> monitors the
evaluation of the model over the <code>log_10(rho_s)</code> values.
</p>
</li></ul>
</td></tr>
<tr><td><code id="grid_search_2d_+3A_par_gridsearch">par_gridsearch</code></td>
<td>
<p>A list of parameters for the grid_search:
</p>

<ul>
<li> <p><code>plot_aic</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code>, plot the AIC values
over the grid of <code>log_10(rho_u)</code> and <code>log_10(rho_s)</code> values.
</p>
</li>
<li> <p><code>plot_bic</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code>, plot the BIC values
over the grid of <code>log_10(rho_u)</code> and <code>log_10(rho_s)</code> values.
</p>
</li>
<li> <p><code>return_aic</code> A Boolean. Default is <code>TRUE</code>. Return the AIC values.
</p>
</li>
<li> <p><code>return_bic</code> A Boolean. Default is <code>TRUE</code>. Return the BIC values.
</p>
</li>
<li> <p><code>col</code> The color palette to be used for the AIC/BIC plot. Default is
<code>grDevices::gray.colors(n=10)</code>.
</p>
</li>
<li> <p><code>plot_contour</code> A Boolean. Default is <code>TRUE</code>. Adds white contour lines to
the AIC/BIC plot.
</p>
</li>
<li> <p><code>mark_optimal</code> A Boolean. Default is <code>TRUE</code>. If the plot of the AIC or BIC
values is returned, marks the optimal combination of <code>log_10(rho_u)</code> and
<code>log_10(rho_s)</code> in the plot.
</p>
</li>
<li> <p><code>main_aic</code> The title of the AIC plot. Default is <code>"AIC grid"</code>.
</p>
</li>
<li> <p><code>main_bic</code> The title of the BIC plot. Default is <code>"BIC grid"</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>h2tsfit</code> with the following elements:
</p>

<ul>
<li> <p><code>optimal_model</code> A list containing the results of the optimal model.
</p>
</li>
<li> <p><code>optimal_logrho</code> The optimal couple of <code>log_10(rho_u)</code> and <code>log_10(rho_s)</code>
values.
</p>
</li>
<li> <p><code>P_optimal</code> The optimal penalty matrix P.
</p>
</li>
<li> <p><code>AIC</code> (if <code>par_gridsearch$return_aic == TRUE</code>) The vector of AIC values.
</p>
</li>
<li> <p><code>BIC</code> (if <code>par_gridsearch$return_bic == TRUE</code>) The vector of BIC values.
</p>
</li></ul>



<h3>References</h3>

<p>Camarda, C. G. (2012). &quot;MortalitySmooth: An R Package for
Smoothing Poisson Counts with P-Splines.&quot;
Journal of Statistical Software, 50(1), 1–24.
https://doi.org/10.18637/jss.v050.i01
</p>

<hr>
<h2 id='haz2ts_summary'>Summary function for object of class 'haz2ts'</h2><span id='topic+haz2ts_summary'></span>

<h3>Description</h3>

<p>Summary function for object of class 'haz2ts'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haz2ts_summary(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haz2ts_summary_+3A_x">x</code></td>
<td>
<p>an object of class 'haz2ts' returned by the function <code><a href="#topic+fit2ts">fit2ts()</a></code></p>
</td></tr>
<tr><td><code id="haz2ts_summary_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a printed summary of the fitted model
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create some fake data - the bare minimum
id &lt;- 1:20
u &lt;- c(5.43, 3.25, 8.15, 5.53, 7.28, 6.61, 5.91, 4.94, 4.25, 3.86, 4.05, 6.86,
       4.94, 4.46, 2.14, 7.56, 5.55, 7.60, 6.46, 4.96)
s &lt;- c(0.44, 4.89, 0.92, 1.81, 2.02, 1.55, 3.16, 6.36, 0.66, 2.02, 1.22, 3.96,
       7.07, 2.91, 3.38, 2.36, 1.74, 0.06, 5.76, 3.00)
ev &lt;- c(1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1)#'

fakedata &lt;- as.data.frame(cbind(id, u, s, ev))
fakedata2ts &lt;- prepare_data(data = fakedata,
                            u = "u",
                            s_out = "s",
                            ev = "ev",
                            ds = .5)
# Fit a fake model - not optimal smoothing
fakemod &lt;- fit2ts(fakedata2ts,
                  optim_method = "grid_search",
                  lrho = list(seq(1 ,1.5 ,.5),
                              seq(1 ,1.5 ,.5)))
summary(fakemod)

</code></pre>

<hr>
<h2 id='haz2tsLMM_summary'>Summary function for object of class 'haz2tsLMM'</h2><span id='topic+haz2tsLMM_summary'></span>

<h3>Description</h3>

<p>Summary function for object of class 'haz2tsLMM'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haz2tsLMM_summary(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haz2tsLMM_summary_+3A_x">x</code></td>
<td>
<p>an object of class 'haz2tsLMM' returned by the function <code><a href="#topic+fit2ts">fit2ts()</a></code></p>
</td></tr>
<tr><td><code id="haz2tsLMM_summary_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a printed summary of the fitted model, including optimal smoothing
paramters, the effective dimension ED and the AIC/BIC. For model
with covariates, a regression table is also returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create some fake data - the bare minimum
id &lt;- 1:20
u &lt;- c(
  5.43, 3.25, 8.15, 5.53, 7.28, 6.61, 5.91, 4.94, 4.25, 3.86, 4.05, 6.86,
  4.94, 4.46, 2.14, 7.56, 5.55, 7.60, 6.46, 4.96
)
s &lt;- c(
  0.44, 4.89, 0.92, 1.81, 2.02, 1.55, 3.16, 6.36, 0.66, 2.02, 1.22, 3.96,
  7.07, 2.91, 3.38, 2.36, 1.74, 0.06, 5.76, 3.00
)
ev &lt;- c(1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1) #'

fakedata &lt;- as.data.frame(cbind(id, u, s, ev))
fakedata2ts &lt;- prepare_data(data = fakedata,
                            u = "u",
                            s_out = "s",
                            ev = "ev",
                            ds = .5)
# Fit a fake model - not optimal smoothing
fakemod &lt;- fit2ts(fakedata2ts,
  optim_method = "LMMsolver"
)
summary(fakemod)
</code></pre>

<hr>
<h2 id='imageplot_2ts'>Image Plot of 2ts hazard</h2><span id='topic+imageplot_2ts'></span>

<h3>Description</h3>

<p><code>imageplot_2ts()</code> plots an image of the two time scales hazard (or survival or
cumulative hazard) with contour lines.
This is the default call implemented in plot.haz2ts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imageplot_2ts(x, y, z, plot_options = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imageplot_2ts_+3A_x">x</code></td>
<td>
<p>The coordinates for the x-axis. This is a vector of intervals
over the <code>u</code> axis (default), a matrix with the corner points of
the parallelograms over the <code>t</code> time scale, or a vector of intervals for
the <code>t</code> time scale.</p>
</td></tr>
<tr><td><code id="imageplot_2ts_+3A_y">y</code></td>
<td>
<p>The coordinates for the y-axis. This is a vector of intervals
over the <code>s</code> time scale (default), or a matrix with the corner points of
the parallelograms over the <code>s</code> time scale.</p>
</td></tr>
<tr><td><code id="imageplot_2ts_+3A_z">z</code></td>
<td>
<p>The values of the surface to plot, organized in a matrix with
dimensions compatible with those of <code>x</code> and <code>y</code>. The default is to plot the
hazard.</p>
</td></tr>
<tr><td><code id="imageplot_2ts_+3A_plot_options">plot_options</code></td>
<td>
<p>A list of options for the plot:
</p>

<ul>
<li> <p><code>loghazard</code> A Boolean. Default is <code>FALSE</code>. If <code>FALSE</code> the function
returns a plot of the hazard surface, if <code>TRUE</code> the function returns
a plot of the log-hazard surface.
</p>
</li>
<li> <p><code>log10hazard</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code>,
then a log10-hazard surface is plotted.
</p>
</li>
<li> <p><code>original</code> A Boolean. Default is <code>TRUE</code>. Plot the (log-)hazard in the
(t,s)-plane. If <code>FALSE</code>, the (log-)hazard will be plotted in the (u,s)-plane.
</p>
</li>
<li> <p><code>rectangular_grid</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code>, a
rectangular grid is used for plotting also in the (t,s)-plane as opposed
to the grid of parallelograms used as default in the (t,s)-plane.
</p>
</li>
<li> <p><code>col_palette</code> A function defining the color palette. The default palette
is <code>rev(viridis::plasma())</code>.
</p>
</li>
<li> <p><code>n_shades</code> The number of color shades to plot, default is 50.
</p>
</li>
<li> <p><code>breaks</code> The vector of breaks for the color legend. If <code>n_shades</code> is provided,
this should be of length <code>n_shades + 1</code>. Otherwise, <code>n_shades</code> will be
recalculated accordingly.
</p>
</li>
<li> <p><code>show_legend</code> A Boolean. Default is <code>TRUE</code>. If <code>FALSE</code> no legend will be
plotted, useful for multi-panel figures with common legend. Works only
for plots on rectangular grid!
</p>
</li>
<li> <p><code>tmax</code> The maximum value of <code>t</code> that should be plotted.
</p>
</li>
<li> <p><code>main</code> The title of the plot.
</p>
</li>
<li> <p><code>xlab</code> The label of the first time axis (plotted on the x axis).
</p>
</li>
<li> <p><code>ylab</code> The label of the second time axis (plotted on the y axis).
</p>
</li>
<li> <p><code>xlim</code> A vector with two elements defining the limits of the time scale
on the x axis.
</p>
</li>
<li> <p><code>ylim</code> A vector with two elements defining the limits of the time scale
on the y axis.
</p>
</li>
<li> <p><code>cex_main</code> The magnification to be used for the main title, default is <code>1.2</code>.
</p>
</li>
<li> <p><code>cex_lab</code> The magnification to be used for the axis labels, default is <code>1</code>.
</p>
</li>
<li> <p><code>contour_lines</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> white contour
lines are added to the surfaces.
</p>
</li>
<li> <p><code>contour_col</code> The color for the contour lines. Default is <code>white</code>.
</p>
</li>
<li> <p><code>contour_cex</code> The magnification to be used for the contour lines.
Default is <code>.8</code>.
</p>
</li>
<li> <p><code>contour_nlev</code> The number of contour levels. Default is <code>10</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="imageplot_2ts_+3A_...">...</code></td>
<td>
<p>Further arguments to image.plot or image</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An image plot of an estimated surface.
</p>

<hr>
<h2 id='imageplot_SE'>Image Plot of Standard Errors for the 2ts hazard</h2><span id='topic+imageplot_SE'></span>

<h3>Description</h3>

<p><code>imageplot_SE()</code> plots an image of the SEs of the two time scales hazard with
contour lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imageplot_SE(x, y, z, plot_options = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imageplot_SE_+3A_x">x</code></td>
<td>
<p>The coordinates for the x-axis. This is a vector of intervals
over the <code>u</code> axis (default), a matrix with the corner points of
the parallelograms over the <code>t</code> time scale, or a vector of intervals for the <code>t</code>
time scale.</p>
</td></tr>
<tr><td><code id="imageplot_SE_+3A_y">y</code></td>
<td>
<p>The coordinates for the y-axis. This is a vector of intervals
over the <code>s</code> time scale (default), or a matrix with the corner points of
the parallelograms over the <code>s</code> time scale.</p>
</td></tr>
<tr><td><code id="imageplot_SE_+3A_z">z</code></td>
<td>
<p>The values of the surface to plot, organized in a matrix with
dimensions compatible with those of <code>x</code> and <code>y</code>. These can be the SEs for
the hazard, the SEs for the log-hazard or the SEs for the log10-hazard.</p>
</td></tr>
<tr><td><code id="imageplot_SE_+3A_plot_options">plot_options</code></td>
<td>
<p>A list of options for the plot:
</p>

<ul>
<li> <p><code>loghazard</code> A Boolean. Default is <code>FALSE</code>. If <code>FALSE</code> the function
returns a plot of the standard errors of the hazard surface,
if <code>TRUE</code> the function returns a plot of the standard errors of the
log-hazard surface.
</p>
</li>
<li> <p><code>log10hazard</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code>, the function
returns a plot of the standard errors of the log10-hazard surface
</p>
</li>
<li> <p><code>original</code> A Boolean. Default is <code>TRUE</code>. Plot the (log-)hazard in the
(t,s)-plane. If <code>FALSE</code>, the (log-)hazard will be plotted in the (u,s)-plane.
</p>
</li>
<li> <p><code>rectangular_grid</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code>, a
rectangular grid is used for plotting also in the (t,s)-plane as opposed
to the grid of parallelograms used as default in the (t,s)-plane.
</p>
</li>
<li> <p><code>col_palette</code> A function defining the color palette. The default palette
is <code>rev(colorspace::sequential_hcl(n = 50, "Red-Purple"))</code>.
</p>
</li>
<li> <p><code>n_shades</code> The number of color shades to plot, default is 50.
</p>
</li>
<li> <p><code>breaks</code> The vector of breaks for the color legend. If <code>n_shades</code> is provided,
this should be of length <code>n_shades + 1</code>. Otherwise, <code>n_shades</code> will be
recalculated accordingly.
</p>
</li>
<li> <p><code>show_legend</code> A Boolean. Default is <code>TRUE</code>. If <code>FALSE</code> no legend will be
plotted, useful for multi-panel figures with common legend. Works only
for plots on rectangular grid!
</p>
</li>
<li> <p><code>tmax</code> The maximum value of <code>t</code> that should be plotted.
</p>
</li>
<li> <p><code>main</code> The title of the plot.
</p>
</li>
<li> <p><code>xlab</code> The label of the first time axis (plotted on the x axis).
</p>
</li>
<li> <p><code>ylab</code> The label of the second time axis (plotted on the y axis).
</p>
</li>
<li> <p><code>xlim</code> A vector with two elements defining the limits of the time scale
on the x axis.
</p>
</li>
<li> <p><code>ylim</code> A vector with two elements defining the limits of the time scale
on the y axis.
</p>
</li>
<li> <p><code>cex_main</code> The magnification to be used for the main title, default is <code>1.2</code>.
</p>
</li>
<li> <p><code>cex_lab</code> The magnification to be used for the axis labels, default is <code>1</code>.
</p>
</li>
<li> <p><code>contour_lines</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> white contour
lines are added to the surfaces.
</p>
</li>
<li> <p><code>contour_col</code> The color for the contour lines. Default is <code>white</code>.
</p>
</li>
<li> <p><code>contour_cex</code> The magnification to be used for the contour lines.
Default is <code>.8</code>.
</p>
</li>
<li> <p><code>contour_nlev</code> The number of contour levels. Default is <code>10</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="imageplot_SE_+3A_...">...</code></td>
<td>
<p>Further arguments to image.plot or image</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An image plot of the SEs for the (log-) hazard surface.
</p>

<hr>
<h2 id='iwls_1d'>Iterative Weighted Least Squares algorithm for 1ts model</h2><span id='topic+iwls_1d'></span>

<h3>Description</h3>

<p><code>iwls_1d()</code> fits the 1ts model with IWLS algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iwls_1d(
  r,
  y,
  Bs,
  P,
  Wprior = NULL,
  control_algorithm = list(maxiter = 20, conv_crit = 1e-05, verbose = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iwls_1d_+3A_r">r</code></td>
<td>
<p>A vector of exposure times of length ns.</p>
</td></tr>
<tr><td><code id="iwls_1d_+3A_y">y</code></td>
<td>
<p>A vector of event counts of length ns.</p>
</td></tr>
<tr><td><code id="iwls_1d_+3A_bs">Bs</code></td>
<td>
<p>A matrix of B-splines for the <code>s</code> time scale of dimension ns by cs.</p>
</td></tr>
<tr><td><code id="iwls_1d_+3A_p">P</code></td>
<td>
<p>The penalty matrix of dimension cs by cs.</p>
</td></tr>
<tr><td><code id="iwls_1d_+3A_wprior">Wprior</code></td>
<td>
<p>An optional vector of length ns of a-priori weights.</p>
</td></tr>
<tr><td><code id="iwls_1d_+3A_control_algorithm">control_algorithm</code></td>
<td>
<p>A list with optional values for the parameters of
the iterative processes:
</p>

<ul>
<li> <p><code>maxiter</code> The maximum number of iteration for the IWSL algorithm.
Default is 20.
</p>
</li>
<li> <p><code>conv_crit</code> The convergence criteria, expressed as difference between
estimates at iteration i and i+1. Default is <code>1e-5</code>.
</p>
</li>
<li> <p><code>verbose</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> monitors the iteration
process.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>alpha</code> The vector of estimated P-splines coefficients of length cs.
</p>
</li>
<li> <p><code>SE_alpha</code> The vector of estimated Standard Errors for the <code>alpha</code> coefficients,
of length cs.
</p>
</li>
<li> <p><code>H</code> The hat-matrix.
</p>
</li>
<li> <p><code>Cov</code> The full variance-covariance matrix.
</p>
</li>
<li> <p><code>deviance</code> The deviance.
</p>
</li>
<li> <p><code>ed</code> The effective dimension of the model.
</p>
</li>
<li> <p><code>aic</code> The value of the AIC.
</p>
</li>
<li> <p><code>bic</code> The value of the BIC.
</p>
</li>
<li> <p><code>Bbases</code> a list with the B-spline basis <code>Bs</code> (this is a list for
compatibility with functions in 2d).
</p>
</li></ul>


<hr>
<h2 id='make_bins'>Construct bins over one or more time axes</h2><span id='topic+make_bins'></span>

<h3>Description</h3>

<p><code>make_bins()</code> constructs the bins over the time axes and saves the extremes
of the bins in a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_bins(
  t_in = NULL,
  t_out = NULL,
  u = NULL,
  s_in = NULL,
  s_out,
  min_t = NULL,
  max_t = NULL,
  min_u = NULL,
  max_u = NULL,
  min_s = NULL,
  max_s = NULL,
  dt = NULL,
  du = NULL,
  ds
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_bins_+3A_t_in">t_in</code></td>
<td>
<p>(optional) A vector of entry times on the time scale <code>t</code>.</p>
</td></tr>
<tr><td><code id="make_bins_+3A_t_out">t_out</code></td>
<td>
<p>(optional) A vector of exit times on the time scale <code>t</code>.</p>
</td></tr>
<tr><td><code id="make_bins_+3A_u">u</code></td>
<td>
<p>(optional) A vector of fixed-times at entry in the process.</p>
</td></tr>
<tr><td><code id="make_bins_+3A_s_in">s_in</code></td>
<td>
<p>(optional) A vector of entry times on the time scale <code>s</code>.</p>
</td></tr>
<tr><td><code id="make_bins_+3A_s_out">s_out</code></td>
<td>
<p>A vector of exit times on the time scale <code>s</code>.</p>
</td></tr>
<tr><td><code id="make_bins_+3A_min_t">min_t</code></td>
<td>
<p>(optional) A minimum value for the bins over <code>t</code>.
If <code>NULL</code>, the minimum of <code>t_in</code> will be used.</p>
</td></tr>
<tr><td><code id="make_bins_+3A_max_t">max_t</code></td>
<td>
<p>(optional) A maximum value for the bins over <code>t</code>.
If <code>NULL</code>, the maximum of <code>t_out</code> will be used.</p>
</td></tr>
<tr><td><code id="make_bins_+3A_min_u">min_u</code></td>
<td>
<p>(optional) A minimum value for the bins over <code>u</code>.
If <code>NULL</code>, the minimum of <code>u</code> will be used.</p>
</td></tr>
<tr><td><code id="make_bins_+3A_max_u">max_u</code></td>
<td>
<p>(optional) A maximum value for the bins over <code>u</code>.
If <code>NULL</code>, the maximum of <code>u</code> will be used.</p>
</td></tr>
<tr><td><code id="make_bins_+3A_min_s">min_s</code></td>
<td>
<p>(optional) A minimum value for the bins over <code>s</code>.
If <code>NULL</code>, the minimum of <code>s_in</code> will be used.</p>
</td></tr>
<tr><td><code id="make_bins_+3A_max_s">max_s</code></td>
<td>
<p>(optional) A maximum value for the bins over <code>s</code>.
If <code>NULL</code>, the maximum of <code>s_out</code> will be used.</p>
</td></tr>
<tr><td><code id="make_bins_+3A_dt">dt</code></td>
<td>
<p>(optional) A scalar giving the length of the intervals on the <code>t</code> time scale.</p>
</td></tr>
<tr><td><code id="make_bins_+3A_du">du</code></td>
<td>
<p>(optional) A scalar giving the length of the intervals on the <code>u</code> axis.</p>
</td></tr>
<tr><td><code id="make_bins_+3A_ds">ds</code></td>
<td>
<p>A scalar giving the length of the intervals on the <code>s</code> time scale.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It allows construction of bins over the time scales <code>t</code> and
<code>s</code> and/or over the fixed-time axis <code>u</code>. The time scale
<code>s</code> is always required. See also <code><a href="#topic+prepare_data">prepare_data()</a></code> to conveniently
prepare individual data for the analysis with one, or two time scales.
</p>
<p>A few words about constructing the grid of bins. There is no 'golden rule' or
optimal strategy for setting the number of bins over each time axis, or deciding
on the bins' width. It very much depends on the data structure, however, we
try to give some directions here. First, in most cases, more bins is better
than less bins. A good number is about 30 bins.
However, if data are scarce, the user might want to find a compromise between
having a larger number of bins, and having many bins empty.
Second, the chosen width of the bins (that is <code>du</code> and <code>ds</code>) does depend on
the time unit over which the time scales are measured. For example, if the time
is recorded in days, as in the example below, and several years of follow-up
are available, the user can split the data in bins of width 30 (corresponding
to about one month), 60 (about two months), 90 (about three months), etc.
If the time scale is measured in years, then appropriate width could be 0.25
(corresponding to a quarter of a year), or 0.5 (that is half year). However,
in some cases, time might be measure in completed years, as is often the case
for age. In this scenario, an appropriate bin width is 1.
</p>
<p>Finally, it is always a good idea to plot your data first, and explore the range
of values over which the time scale(s) are recorded. This will give insight
about reasonable values for the arguments <code>min_s</code>, <code>min_u</code>, <code>max_s</code> and <code>max_u</code>
(that in any case are optional).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>bins_t</code> if <code>t_out</code> is provided, this is a vector of bins extremes for the time scale <code>t</code>
</p>
</li>
<li> <p><code>midt</code> if <code>t_out</code> is provided, this is a vector with the midpoints of the bins over <code>t</code>
</p>
</li>
<li> <p><code>nt</code> if <code>t_out</code> is provided, this is the number of bins over <code>t</code>
</p>
</li>
<li> <p><code>bins_u</code> if <code>u</code> is provided, this is a vector of bins extremes for <code>u</code> axis
</p>
</li>
<li> <p><code>midu</code> if <code>u</code> is provided, this is a vector with the midpoints of the bins over <code>u</code>
</p>
</li>
<li> <p><code>nu</code> if <code>u</code> is provided, this is the number of bins over <code>u</code>
</p>
</li>
<li> <p><code>bins_s</code> is a vector of bins extremes for the time scale <code>s</code>
</p>
</li>
<li> <p><code>mids</code> is a vector with the midpoints of the bins over <code>s</code>
</p>
</li>
<li> <p><code>ns</code> is the number of bins over <code>s</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Make bins for colon cancer data by time at randomization and time since recurrence
bins &lt;- make_bins(u = reccolon2ts$timer, s_out = reccolon2ts$timesr,
                 du = 30, ds = 30)
# Make bins for colon cancer data only over time since recurrence
bins &lt;- make_bins(s_out = reccolon2ts$timesr, ds = 60)
</code></pre>

<hr>
<h2 id='plot_slices'>Plot slices of the (log-) hazard</h2><span id='topic+plot_slices'></span>

<h3>Description</h3>

<p><code>plot_slices()</code> plots slices of the (log-)hazard with two time
scales, at selected values of one of the two time dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_slices(x, y, direction, plot_options = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_slices_+3A_x">x</code></td>
<td>
<p>A vector of values for the x-axis. This is a vector of values over
the axis opposite to the one where the sliced are cut.</p>
</td></tr>
<tr><td><code id="plot_slices_+3A_y">y</code></td>
<td>
<p>A matrix of (log-)hazard values.</p>
</td></tr>
<tr><td><code id="plot_slices_+3A_direction">direction</code></td>
<td>
<p>Either <code>"u"</code> or <code>"s"</code>.</p>
</td></tr>
<tr><td><code id="plot_slices_+3A_plot_options">plot_options</code></td>
<td>
<p>A list of options for the plot:
</p>

<ul>
<li> <p><code>loghazard</code> A Boolean. Default is <code>FALSE</code>. If <code>FALSE</code> the function
returns a plot of cross-sections from the hazard surface,
if <code>TRUE</code> the function returns a plot of cross-sections from the
log-hazard surface.
</p>
</li>
<li> <p><code>log10hazard</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> returns a plot of
cross-sections from the log10-hazard surface.
</p>
</li>
<li> <p><code>col_palette</code> A function defining the color palette. The default palette
is <code>grDevices::gray.colors()</code>.
</p>
</li>
<li> <p><code>n_shades</code> The number of color shades to plot, default is 50.
</p>
</li>
<li> <p><code>main</code> The title of the plot.
</p>
</li>
<li> <p><code>xlab</code> The label of the first time axis (plotted on the x axis).
</p>
</li>
<li> <p><code>ylab</code> The label of the second time axis (plotted on the y axis).
</p>
</li>
<li> <p><code>xlim</code> A vector with two elements defining the limits of the time scale
on the x axis.
</p>
</li>
<li> <p><code>ylim</code> A vector with two elements defining the limits of the time scale
on the y axis.
</p>
</li>
<li> <p><code>cex_main</code> The magnification to be used for the main title, default is <code>1.2</code>.
</p>
</li>
<li> <p><code>cex_lab</code> The magnification to be used for the axis labels, default is <code>1</code>.
</p>
</li>
<li> <p><code>lwd</code> The line's width. Default is <code>2</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the slices of the hazard cut at selected points.
</p>

<hr>
<h2 id='plot.haz1ts'>Plot method for a haz1ts object.</h2><span id='topic+plot.haz1ts'></span>

<h3>Description</h3>

<p><code>plot.haz1ts()</code> is a plot method for objects of class <code>haz1ts</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haz1ts'
plot(
  x,
  which_plot = c("hazard", "covariates"),
  plot_grid = NULL,
  plot_options = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.haz1ts_+3A_x">x</code></td>
<td>
<p>The output of the function <code>fit1ts</code>.</p>
</td></tr>
<tr><td><code id="plot.haz1ts_+3A_which_plot">which_plot</code></td>
<td>
<p>The type of plot required. Can be one of <code>"hazard"</code>
(default) or <code>"covariates"</code>.</p>
</td></tr>
<tr><td><code id="plot.haz1ts_+3A_plot_grid">plot_grid</code></td>
<td>
<p>(optional) A named vector containing the parameters to build a new
grid of intervals over <code>s</code> for plotting the estimated hazard on a finer
grid. This must be of the form: <code>plot_grid = c(smin, smax, ds)</code>,
where <code>smin</code>, <code>smax</code> are the minimum and maximum values desired for the
intervals over <code>s</code>, and <code>ds</code> is the distance between intervals over <code>s</code>. If
not specified, the plotting is done using the same B-splines basis as for
the estimation. The function will check if the parameters for the grid
provided by the user are compatible with those originally used to construct
the B-splines for estimating the model. If not, the grid will be adjusted
accordingly and a warning will be returned.</p>
</td></tr>
<tr><td><code id="plot.haz1ts_+3A_plot_options">plot_options</code></td>
<td>
<p>A list with all possible options for any of the plots:
</p>

<ul>
<li> <p><code>loghazard</code> A Boolean. Default is <code>FALSE</code>. If <code>FALSE</code> the function
returns a plot of the hazard curve, if <code>TRUE</code> the function returns
a plot of the log-hazard curve.
</p>
</li>
<li> <p><code>log10hazard</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> it returns a plot
of the log10-hazard curve.
</p>
</li>
<li> <p><code>col</code> The color of the curve plotted. Default is <code>"black"</code>.
</p>
</li>
<li> <p><code>add_CI</code> A Boolean. If <code>TRUE</code> (default) the confidence bands will be added.
</p>
</li>
<li> <p><code>col_CI</code> The color for the confidence bands. The default is the same color
of the curve, with a 50% transparancy level.
</p>
</li>
<li> <p><code>main</code> The title of the plot.
</p>
</li>
<li> <p><code>xlab</code> The label of the time axis (plotted on the x axis).
</p>
</li>
<li> <p><code>ylab</code> The label of the y-axis (hazard, log-hazard or log10-hazard).
</p>
</li>
<li> <p><code>xlim</code> A vector with two elements defining the limits of the time scale
on the x axis.
</p>
</li>
<li> <p><code>ylim</code> A vector with two elements defining the limits of function plotted
on the y axis (hazard, log-hazard or log10-hazard).
</p>
</li>
<li> <p><code>xmin</code> The minimum value on the x-axis.
</p>
</li>
<li> <p><code>ymin</code> The minimum value on the y-axis.
</p>
</li>
<li> <p><code>cex_main</code> The magnification to be used for the main title, default is 1.2 .
</p>
</li>
<li> <p><code>cex_lab</code> The magnification to be used for the axis labels, default is 1 .
</p>
</li>
<li> <p><code>HR</code> A Boolean. If <code>TRUE</code> the HRs with their CIs will be plotted.
Default is <code>FALSE</code> (plot the <code>beta</code> with their CIs).
</p>
</li>
<li> <p><code>symmetric_CI</code> A Boolean. Default is <code>TRUE</code>. If a plot of the HRs is
required (<code>HR == TRUE</code>), then plot symmetrical Confidence Intervals,
based on the SEs for the HRs calculated by delta method.
If <code>FALSE</code>, then CIs are obtained by exponentiating the CIs for the betas.
</p>
</li>
<li> <p><code>confidence</code> The level of confidence for the CIs. Default is .95 (alpha
= 0.05).
</p>
</li>
<li> <p><code>col_beta</code> The color for the plot of the covariates' effects.
</p>
</li>
<li> <p><code>pch</code> The symbol for plotting the point estimates.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.haz1ts_+3A_...">...</code></td>
<td>
<p>Further arguments to plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the type required.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## preparing data - no covariates
dt1ts &lt;- prepare_data(data = reccolon2ts,
                      s_in = "entrys",
                      s_out = "timesr",
                      events = "status",
                      ds = 180)

## fitting the model with fit1ts() - default options

mod1 &lt;- fit1ts(dt1ts)

plot(mod1)

</code></pre>

<hr>
<h2 id='plot.haz1tsLMM'>Plot method for a haz1ts object.</h2><span id='topic+plot.haz1tsLMM'></span>

<h3>Description</h3>

<p><code>plot.haz1tsLMM()</code> is a plot method for objects of class <code>haz1tsLMM</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haz1tsLMM'
plot(
  x,
  which_plot = c("hazard", "covariates"),
  plot_grid = NULL,
  plot_options = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.haz1tsLMM_+3A_x">x</code></td>
<td>
<p>The output of the function <code>fit1ts</code>.</p>
</td></tr>
<tr><td><code id="plot.haz1tsLMM_+3A_which_plot">which_plot</code></td>
<td>
<p>The type of plot required. Can be one of <code>"hazard"</code>
(default) or <code>"covariates"</code>.</p>
</td></tr>
<tr><td><code id="plot.haz1tsLMM_+3A_plot_grid">plot_grid</code></td>
<td>
<p>(optional) A named vector containing the parameters to build a new
grid of intervals over <code>s</code> for plotting the estimated hazard on a finer
grid. This must be of the form: <code>plot_grid = c(smin, smax, ds)</code>,
where <code>smin</code>, <code>smax</code> are the minimum and maximum values desired for the
intervals over <code>s</code>, and <code>ds</code> is the distance between intervals over <code>s</code>. If
not specified, the plotting is done using the same B-splines basis as for
the estimation. The function will check if the parameters for the grid
provided by the user are compatible with those originally used to construct
the B-splines for estimating the model. If not, the grid will be adjusted
accordingly and a warning will be returned.</p>
</td></tr>
<tr><td><code id="plot.haz1tsLMM_+3A_plot_options">plot_options</code></td>
<td>
<p>A list with all possible options for any of the plots:
</p>

<ul>
<li> <p><code>loghazard</code> A Boolean. Default is <code>FALSE</code>. If <code>FALSE</code> the function
returns a plot of the hazard curve, if <code>TRUE</code> the function returns
a plot of the log-hazard curve.
</p>
</li>
<li> <p><code>log10hazard</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> it returns a plot
of the log10-hazard curve.
</p>
</li>
<li> <p><code>col</code> The color of the curve plotted. Default is <code>"black"</code>.
</p>
</li>
<li> <p><code>add_CI</code> A Boolean. If <code>TRUE</code> (default) the confidence bands will be added.
</p>
</li>
<li> <p><code>col_CI</code> The color for the confidence bands. The default is the same color
of the curve, with a 50% transparency level.
</p>
</li>
<li> <p><code>main</code> The title of the plot.
</p>
</li>
<li> <p><code>xlab</code> The label of the time axis (plotted on the x axis).
</p>
</li>
<li> <p><code>ylab</code> The label of the y-axis (hazard, log-hazard or log10-hazard).
</p>
</li>
<li> <p><code>xlim</code> A vector with two elements defining the limits of the time scale
on the x axis.
</p>
</li>
<li> <p><code>ylim</code> A vector with two elements defining the limits of function plotted
on the y axis (hazard, log-hazard or log10-hazard).
</p>
</li>
<li> <p><code>xmin</code> The minimum value on the x-axis.
</p>
</li>
<li> <p><code>ymin</code> The minimum value on the y-axis.
</p>
</li>
<li> <p><code>cex_main</code> The magnification to be used for the main title, default is 1.2 .
</p>
</li>
<li> <p><code>cex_lab</code> The magnification to be used for the axis labels, default is 1 .
</p>
</li>
<li> <p><code>HR</code> A Boolean. If <code>TRUE</code> the HRs with their CIs will be plotted.
Default is <code>FALSE</code> (plot the <code>beta</code> with their CIs).
</p>
</li>
<li> <p><code>symmetric_CI</code> A Boolean. Default is <code>TRUE</code>. If a plot of the HRs is
required (<code>HR == TRUE</code>), then plot symmetrical Confidence Intervals,
based on the SEs for the HRs calculated by delta method.
If <code>FALSE</code>, then CIs are obtained by exponentiating the CIs for the betas.
</p>
</li>
<li> <p><code>confidence</code> The level of confidence for the CIs. Default is .95 (alpha
= 0.05).
</p>
</li>
<li> <p><code>col_beta</code> The color for the plot of the covariates' effects.
</p>
</li>
<li> <p><code>pch</code> The symbol for plotting the point estimates.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.haz1tsLMM_+3A_...">...</code></td>
<td>
<p>Further arguments to plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>obtainSmoothTrend</code> from the R-package <code>LMMsolver</code> is
used here. We refer the interested readers to https://biometris.github.io/LMMsolver/
for more details on <code>LMMsolver</code> and its usage.
</p>


<h3>Value</h3>

<p>A plot of the type required.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## preparing data - no covariates
dt1ts &lt;- prepare_data(data = reccolon2ts,
                      s_in = "entrys",
                      s_out = "timesr",
                      events = "status",
                      ds = 180)

## fitting the model with fit1ts() - default options

mod1 &lt;- fit1ts(dt1ts,
optim_method = "LMMsolver")
plot(mod1)
</code></pre>

<hr>
<h2 id='plot.haz2ts'>Plot method for a haz2ts object.</h2><span id='topic+plot.haz2ts'></span>

<h3>Description</h3>

<p><code>plot.haz2ts()</code> is the plot method for objects of class <code>haz2ts</code>.
It produces several kinds of plots of the fitted model with two
time scales (see <code><a href="#topic+fit2ts">fit2ts()</a></code>), either in the original (t,s) plane, while respecting the
constraint imposed by the relation of the two time scales, or in the
transformed (u,s) plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haz2ts'
plot(
  x,
  plot_grid = NULL,
  which_plot = c("hazard", "covariates", "SE", "slices", "survival", "cumhaz"),
  where_slices = NULL,
  direction = c(NULL, "u", "s"),
  plot_options = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.haz2ts_+3A_x">x</code></td>
<td>
<p>The output of the function <code>fit2ts</code>. This is an object of
class <code>"haz2ts"</code>.</p>
</td></tr>
<tr><td><code id="plot.haz2ts_+3A_plot_grid">plot_grid</code></td>
<td>
<p>(optional) A list containing the parameters to build a new
finer grid of intervals over u and s for plotting. This must be of the
form: <code>plot_grid = list(c(umin, umax, du), c(smin, smax, ds))</code>, where
<code>umin</code>, <code>umax</code> and <code>smin</code>, <code>smax</code> are the minimum and maximum values
desired for the intervals over <code>u</code> and <code>s</code> respectively, and <code>du</code>, <code>ds</code> are
distances between intervals over <code>u</code> and <code>s</code> respectively. Specifying a new
denser grid is used to evaluate the B-spline bases used for estimation on
such grid and plot the estimated surfaces with a greater level of details.
If not specified, the plotting is done using the same B-splines bases as
for the estimation. The function will check if the parameters for the grid
provided by the user are compatible with those originally used to construct
the B-splines for estimating the model. If not, the grid will be adjusted
accordingly and a warning will be returned.</p>
</td></tr>
<tr><td><code id="plot.haz2ts_+3A_which_plot">which_plot</code></td>
<td>
<p>The type of plot required. Can be one of <code>"hazard"</code>
(default), <code>"covariates"</code>, <code>"SE"</code>, <code>"slices"</code>, <code>"survival"</code> or <code>"cumhaz"</code>
(see details section).</p>
</td></tr>
<tr><td><code id="plot.haz2ts_+3A_where_slices">where_slices</code></td>
<td>
<p>A vector of values for the cutting points of the desired
slices of the surface. If <code>which_plot == "slices"</code>, please provide this
argument. Please also provide this argument in case <code style="white-space: pre;">&#8288;which_plot = "survival&#8288;</code>
or <code style="white-space: pre;">&#8288;which_plot = "cumhaz&#8288;</code> and <code>surv_slices = TRUE</code> or <code>cumhaz_slices = TRUE</code>,
respectively.</p>
</td></tr>
<tr><td><code id="plot.haz2ts_+3A_direction">direction</code></td>
<td>
<p>If <code>which_plot == "slices"</code>, indicates the direction for
cutting the surface. If <code>u</code>, then the surface will be cut at the selected
values of <code>u</code> (indicated by <code>where_slices</code>), hence obtaining one-dimensional
curves over <code>s</code>. If <code>s</code>, then the surface will be cut at the selected values
of <code>s</code> (indicated by <code>where_slices</code>), hence obtaining one-dimensional curves
over <code>u</code>.</p>
</td></tr>
<tr><td><code id="plot.haz2ts_+3A_plot_options">plot_options</code></td>
<td>
<p>A list with all possible options for any of the plots:
</p>

<ul>
<li> <p><code>loghazard</code> A Boolean. Default is <code>FALSE</code>. If <code>FALSE</code> the function
returns a plot of the hazard surface, if <code>TRUE</code> the function returns
a plot of the log-hazard surface.
</p>
</li>
<li> <p><code>log10hazard</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code>,
then a log_10 hazard surface is plotted.
</p>
</li>
<li> <p><code>cut_extrapolated</code> A Boolean. Default is <code>TRUE</code>. Cuts away the
extrapolated area of the (log-)hazard surface before plotting.
</p>
</li>
<li> <p><code>rectangular_grid</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code>, a
rectangular grid is used for plotting also in the (t,s)-plane as opposed
to the grid of parallelograms used as default in the (t,s)-plane.
</p>
</li>
<li> <p><code>original</code> A Boolean. Default is <code>TRUE</code>. Plot the (log-)hazard (and/or
the SEs) in the (t,s)-plane. If <code>FALSE</code>, the (log-)hazard (and/or the SEs)
will be plotted in the (u,s)-plane.
</p>
</li>
<li> <p><code>tmax</code> The maximum value of <code>t</code> that should be plotted.
</p>
</li>
<li> <p><code>surv_slices</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> and
<code>which_plot == "survival"</code>, plot survival curves over the time <code>s</code> for
selected values of <code>u</code>, that are cross-sections of the 2D survival surface.
</p>
</li>
<li> <p><code>cumhaz_slices</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> and
<code>which_plot == "cumhaz"</code>, plot cumulative hazards curves over the time <code>s</code> for
selected values of <code>u</code>, that are cross-sections of the 2D cumulative hazard surface.
</p>
</li>
<li> <p><code>midpoints</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code>, the estimated quantities
(hazard, survival, etc.) will be evaluated in the mid-points of the bins
rather than at the extremes. Set to <code>TRUE</code> if plotting estimated number of
events.
</p>
</li>
<li> <p><code>col_palette</code> A function defining the color palette. The default palette
is <code>viridis::rev(plasma())</code>. Specifying the color palette as a function
allows for greater flexibility than passing the palette as a vector.
</p>
</li>
<li> <p><code>n_shades</code> The number of color shades to plot, default is 50.
</p>
</li>
<li> <p><code>breaks</code> The vector of breaks for the color legend. If <code>n_shades</code> is provided,
this should be of length <code>n_shades + 1</code>.
</p>
</li>
<li> <p><code>show_legend</code> A Boolean. Default is <code>TRUE</code>. If <code>FALSE</code> no legend will be
plotted, useful for multi-panel figures with common legend. Works only
for plots on rectangular grid (i.e. transformed (u,s) plane)
</p>
</li>
<li> <p><code>main</code> The title of the plot.
</p>
</li>
<li> <p><code>xlab</code> The label of the first time axis (plotted on the x axis).
</p>
</li>
<li> <p><code>ylab</code> The label of the second time axis (plotted on the y axis).
</p>
</li>
<li> <p><code>xlim</code> A vector with two elements defining the limits of the time scale
on the x axis.
</p>
</li>
<li> <p><code>ylim</code> A vector with two elements defining the limits of the time scale
on the y axis.
</p>
</li>
<li> <p><code>contour_lines</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> white contour
lines are added to the surfaces.
</p>
</li>
<li> <p><code>contour_col</code> The color for the contour lines. Default is <code>white</code>.
</p>
</li>
<li> <p><code>contour_cex</code> The magnification to be used for the contour lines.
Default is <code>.8</code>.
</p>
</li>
<li> <p><code>contour_nlev</code> The number of contour levels desired. Default is 10.
</p>
</li>
<li> <p><code>cex_main</code> The magnification to be used for the main title, default is 1.2 .
</p>
</li>
<li> <p><code>cex_lab</code> The magnification to be used for the axis labels, default is 1 .
</p>
</li>
<li> <p><code>HR</code> A Boolean. If <code>TRUE</code> the HRs with their CIs will be plotted.
Default is <code>FALSE</code> (plot the <code>beta</code> with their CIs).
</p>
</li>
<li> <p><code>symmetric_CI</code> A Boolean. Default is <code>TRUE</code>. If a plot of the HRs is
required (<code>HR == TRUE</code>), then plot symmetrical Confidence Intervals,
based on the SEs for the HRs calculated by delta method.
If <code>FALSE</code>, then CIs are obtained by exponentiating the CIs for the betas.
</p>
</li>
<li> <p><code>confidence</code> The level of confidence for the CIs. Default is .95 (alpha
= 0.05).
</p>
</li>
<li> <p><code>col_beta</code> The color for the plot of the covariates' effects.
</p>
</li>
<li> <p><code>pch</code> The symbol for plotting the point estimates.
</p>
</li>
<li> <p><code>lwd</code> The line width.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.haz2ts_+3A_...">...</code></td>
<td>
<p>Further arguments to image.plot or image</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vignette &quot;visualization&quot; presents and discusses all the different
plotting options for the fitted model over two time scales.
In most of the cases, the user will want to visualize the hazard surface over
the two time scales. This can be plotted on the hazard scale, the log-hazard
scale or the log10-hazard scale, by switching to <code>TRUE</code> the corresponding
argument in <code>plot_options</code>.
The survival and cumulative hazard functions can be plotted as two-dimensional
surfaces over <code>u</code> and <code>s</code> or <code>t</code> and <code>s</code>. However, it is also very informative
to plot them as one-dimensional curves over <code>s</code> (cross-sections or slices).
This is done by selecting <code>which_plot = "survival"</code> and <code>surv_slices = TRUE</code>
in <code>plot_options</code>. Additionally, a vector of values for the cutting points
over the <code>u</code>-axis should be passed to the argument <code>where_slices</code>, together
with setting <code>direction = u</code>.
Similar plot is obtained for the cumulative hazard by selecting <code>which_plot = "cumhaz"</code>,
<code>cumhaz_slices = TRUE</code>, see examples section.
Please, notice that for the survival function and the cumulative hazard, only
cross-sections of the surface for selected values of <code>u</code> (over the <code>s</code> time)
can be plotted.
</p>


<h3>Value</h3>

<p>A plot of the fitted model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create some fake data - the bare minimum
id &lt;- 1:20
u &lt;- c(5.43, 3.25, 8.15, 5.53, 7.28, 6.61, 5.91, 4.94, 4.25, 3.86, 4.05, 6.86,
       4.94, 4.46, 2.14, 7.56, 5.55, 7.60, 6.46, 4.96)
s &lt;- c(0.44, 4.89, 0.92, 1.81, 2.02, 1.55, 3.16, 6.36, 0.66, 2.02, 1.22, 3.96,
       7.07, 2.91, 3.38, 2.36, 1.74, 0.06, 5.76, 3.00)
ev &lt;- c(1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1)#'

fakedata &lt;- as.data.frame(cbind(id, u, s, ev))
fakedata2ts &lt;- prepare_data(u = fakedata$u,
                            s_out = fakedata$s,
                            ev = fakedata$ev,
                            ds = .5)
# Fit a fake model - not optimal smoothing
fakemod &lt;- fit2ts(fakedata2ts,
                  optim_method = "grid_search",
                  lrho = list(seq(1 ,1.5 ,.5),
                              seq(1 ,1.5 ,.5)))

 # plot the hazard surface
 plot(fakemod)

 # plot the survival function as one-dimension curves over `s`
 plot(fakemod,
      which_plot = "survival",
      direction = "u",
      where_slices = c(4, 6, 8),
      plot_options = list(
      surv_slices = TRUE
      ))

# Plot cross-sections of the hazard over `s` for selected values of `u`

plot(fakemod,
  which_plot = "slices",
  where_slices = c(4, 6, 8),
  direction = "u",
  plot_options = list(
    main = "Cross-sections of the hazard",
    xlab = "Time",
    ylab = "Hazard"
  )
)

</code></pre>

<hr>
<h2 id='plot.haz2tsLMM'>Plot method for a haz2tsLMM object.</h2><span id='topic+plot.haz2tsLMM'></span>

<h3>Description</h3>

<p><code>plot.haz2tsLMM()</code> is the plot method for objects of class <code>haz2tsLMM</code>.
It produces plots of the fitted model with two time scales (see <code><a href="#topic+fit2ts">fit2ts()</a></code>),
fitted via LMMsolver. The two-dimensional plots are limited to the transformed
plane, that is only plots over <code>u</code> and <code>s</code> axes are produced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haz2tsLMM'
plot(
  x,
  plot_grid = NULL,
  which_plot = c("hazard", "covariates", "SE", "slices", "survival", "cumhaz"),
  where_slices = NULL,
  direction = c(NULL, "u", "s"),
  plot_options = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.haz2tsLMM_+3A_x">x</code></td>
<td>
<p>The output of the function <code>fit2ts</code>. This is an object of
class <code>"haz2tsLMM"</code>.</p>
</td></tr>
<tr><td><code id="plot.haz2tsLMM_+3A_plot_grid">plot_grid</code></td>
<td>
<p>A list containing the parameters to build a new
finer grid of intervals over <code>u</code> and <code>s</code> for plotting. This must be of the
form: <code>plot_grid = list(c(umin, umax, du), c(smin, smax, ds))</code>, where
<code>umin</code>, <code>umax</code> and <code>smin</code>, <code>smax</code> are the minimum and maximum values
desired for the intervals over <code>u</code> and <code>s</code> respectively, and <code>du</code>, <code>ds</code> are
distances between intervals over <code>u</code> and <code>s</code> respectively. Specifying a new
denser grid is used to evaluate the B-spline bases used for estimation on
such grid and plot the estimated surfaces with a greater level of details.
If not specified, the plotting is done using the same B-splines bases as
for the estimation. The function will check if the parameters for the grid
provided by the user are compatible with those originally used to construct
the B-splines for estimating the model. If not, the grid will be adjusted
accordingly and a warning will be returned. While for objects of class 'haz2ts'
this is an optional input, we strongly recommend to provide the plotting
grid for object of class 'haz2tsLMM', given that evaluation of the B-splines
works a bit differently in LMMsolver.</p>
</td></tr>
<tr><td><code id="plot.haz2tsLMM_+3A_which_plot">which_plot</code></td>
<td>
<p>The type of plot required. Can be one of <code>"hazard"</code>
(default), <code>"covariates"</code>, <code>"SE"</code>, <code>"slices"</code>, <code>"survival"</code> or <code>"cumhaz"</code>
(see details section).</p>
</td></tr>
<tr><td><code id="plot.haz2tsLMM_+3A_where_slices">where_slices</code></td>
<td>
<p>A vector of values for the cutting points of the desired
slices of the surface. If <code>which_plot == "slices"</code>, please provide this
argument. Please also provide this argument in case <code style="white-space: pre;">&#8288;which_plot = "survival&#8288;</code>
or <code style="white-space: pre;">&#8288;which_plot = "cumhaz&#8288;</code> and <code>surv_slices = TRUE</code> or <code>cumhaz_slices = TRUE</code>,
respectively.</p>
</td></tr>
<tr><td><code id="plot.haz2tsLMM_+3A_direction">direction</code></td>
<td>
<p>If <code>which_plot == "slices"</code>, indicates the direction for
cutting the surface. If <code>u</code>, then the surface will be cut at the selected
values of <code>u</code> (indicated by <code>where_slices</code>), hence obtaining one-dimensional
curves over <code>s</code>. If <code>s</code>, then the surface will be cut at the selected values
of <code>s</code> (indicated by <code>where_slices</code>), hence obtaining one-dimensional curves
over <code>u</code>.</p>
</td></tr>
<tr><td><code id="plot.haz2tsLMM_+3A_plot_options">plot_options</code></td>
<td>
<p>A list with all possible options for any of the plots:
</p>

<ul>
<li> <p><code>loghazard</code> A Boolean. Default is <code>FALSE</code>. If <code>FALSE</code> the function
returns a plot of the hazard surface, if <code>TRUE</code> the function returns
a plot of the log-hazard surface.
</p>
</li>
<li> <p><code>log10hazard</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code>,
then a log10 hazard surface is plotted.
</p>
</li>
<li> <p><code>cut_extrapolated</code> A Boolean. Default is <code>TRUE</code>. Cuts away the
extrapolated area of the (log-)hazard surface before plotting.
</p>
</li>
<li> <p><code>tmax</code> The maximum value of <code>t</code> that should be plotted.
</p>
</li>
<li> <p><code>surv_slices</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> and
<code>which_plot == "survival"</code>, plot survival curves over the time <code>s</code> for
selected values of <code>u</code>, that are cross-sections of the 2D survival surface.
</p>
</li>
<li> <p><code>cumhaz_slices</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> and
<code>which_plot == "cumhaz"</code>, plot cumulative hazards curves over the time <code>s</code> for
selected values of <code>u</code>, that are cross-sections of the 2D cumulative hazard surface.
</p>
</li>
<li> <p><code>midpoints</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code>, the estimated quantities
(hazard, survival, etc.) will be evaluated in the mid-points of the bins
rather than at the extremes. Set to <code>TRUE</code> if plotting estimated number of
events.
</p>
</li>
<li> <p><code>col_palette</code> A function defining the color palette. The default palette
is <code>viridis::rev(plasma())</code>. Specifying the color palette as a function
allows for greater flexibility than passing the palette as a vector.
We provide an example on how to create a function from any color palette
below.
</p>
</li>
<li> <p><code>n_shades</code> The number of color shades to plot, default is 50.
</p>
</li>
<li> <p><code>breaks</code> The vector of breaks for the color legend. If <code>n_shades</code> is provided,
this should be of length <code>n_shades + 1</code>.
</p>
</li>
<li> <p><code>show_legend</code> A Boolean. Default is <code>TRUE</code>. If <code>FALSE</code> no legend will be
plotted, useful for multi-panel figures with common legend. Works only
for plots on rectangular grid (i.e. transformed (u,s) plane).
</p>
</li>
<li> <p><code>main</code> The title of the plot.
</p>
</li>
<li> <p><code>xlab</code> The label of the first time axis (plotted on the x axis).
</p>
</li>
<li> <p><code>ylab</code> The label of the second time axis (plotted on the y axis).
</p>
</li>
<li> <p><code>xlim</code> A vector with two elements defining the limits of the time scale
on the x axis.
</p>
</li>
<li> <p><code>ylim</code> A vector with two elements defining the limits of the time scale
on the y axis.
</p>
</li>
<li> <p><code>contour_lines</code> A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code> contour
lines are added to the surfaces.
</p>
</li>
<li> <p><code>contour_col</code> The color for the contour lines. Default is <code>white</code>.
</p>
</li>
<li> <p><code>contour_cex</code> The magnification to be used for the contour lines.
Default is <code>.8</code>.
</p>
</li>
<li> <p><code>contour_nlev</code> The number of contour levels desired. Default is 10.
</p>
</li>
<li> <p><code>cex_main</code> The magnification to be used for the main title, default is 1.2 .
</p>
</li>
<li> <p><code>cex_lab</code> The magnification to be used for the axis labels, default is 1 .
</p>
</li>
<li> <p><code>HR</code> A Boolean. If <code>TRUE</code> the HRs with their CIs will be plotted.
Default is <code>FALSE</code> (plot the <code>beta</code> with their CIs).
</p>
</li>
<li> <p><code>symmetric_CI</code> A Boolean. Default is <code>TRUE</code>. If a plot of the HRs is
required (<code>HR == TRUE</code>), then plot symmetrical Confidence Intervals,
based on the SEs for the HRs calculated by delta method.
If <code>FALSE</code>, then CIs are obtained by exponentiating the CIs for the betas.
</p>
</li>
<li> <p><code>confidence</code> The level of confidence for the CIs. Default is .95 (alpha
= 0.05).
</p>
</li>
<li> <p><code>col_beta</code> The color for the plot of the covariates' effects.
</p>
</li>
<li> <p><code>pch</code> The symbol for plotting the point estimates.
</p>
</li>
<li> <p><code>lwd</code> The line width.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.haz2tsLMM_+3A_...">...</code></td>
<td>
<p>Further arguments to image.plot or image</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vignette &quot;visualization&quot; presents and discusses all the different
plotting options for the fitted model over two time scales.
In most of the cases, the user will want to visualize the hazard surface over
the two time scales. This can be plotted on the hazard scale, the log-hazard
scale or the log10-hazard scale, by switching to <code>TRUE</code> the corresponding
argument in <code>plot_options</code>.
The survival and cumulative hazard functions can be plotted as two-dimensional
surfaces over <code>u</code> and <code>s</code> or <code>t</code> and <code>s</code>. However, it is also very informative
to plot them as one-dimensional curves over <code>s</code> (cross-sections or slices).
This is done by selecting <code>which_plot = "survival"</code> and <code>surv_slices = TRUE</code>
in <code>plot_options</code>. Additionally, a vector of values for the cutting points
over the <code>u</code>-axis should be passed to the argument <code>where_slices</code>, together
with setting <code>direction = u</code>.
Similar plot is obtained for the cumulative hazard by selecting <code>which_plot = "cumhaz"</code>,
<code>cumhaz_slices = TRUE</code>, see examples section.
Please, notice that for the survival function and the cumulative hazard, only
cross-sections of the surface for selected values of <code>u</code> (over the <code>s</code> time)
can be plotted.
</p>
<p>The function <code>obtainSmoothTrend</code> from the R-package <code>LMMsolver</code> is
used here. We refer the interested readers to https://biometris.github.io/LMMsolver/
for more details on <code>LMMsolver</code> and its usage.
</p>


<h3>Value</h3>

<p>A plot of the fitted model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create some fake data - the bare minimum
id &lt;- 1:20
u &lt;- c(5.43, 3.25, 8.15, 5.53, 7.28, 6.61, 5.91, 4.94, 4.25, 3.86, 4.05, 6.86,
       4.94, 4.46, 2.14, 7.56, 5.55, 7.60, 6.46, 4.96)
s &lt;- c(0.44, 4.89, 0.92, 1.81, 2.02, 1.55, 3.16, 6.36, 0.66, 2.02, 1.22, 3.96,
       7.07, 2.91, 3.38, 2.36, 1.74, 0.06, 5.76, 3.00)
ev &lt;- c(1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1)#'

fakedata &lt;- as.data.frame(cbind(id, u, s, ev))
fakedata2ts &lt;- prepare_data(u = fakedata$u,
                            s_out = fakedata$s,
                            ev = fakedata$ev,
                            ds = .5)
# Fit a fake model - not optimal smoothing
fakemod &lt;- fit2ts(fakedata2ts,
                  optim_method = "LMMsolver")

 # plot the hazard surface
 plot(fakemod)
 # plot the survival function as one-dimension curves over `s`
 plot(fakemod,
      which_plot = "survival",
      direction = "u",
      where_slices = c(4, 6, 8),
      plot_options = list(
      surv_slices = TRUE
      ))


# Plot cross-sections of the hazard over `s` for selected values of `u`

plot(fakemod,
  which_plot = "slices",
  where_slices = c(4, 6, 8),
  direction = "u",
  plot_options = list(
    main = "Cross-sections of the hazard",
    xlab = "Time",
    ylab = "Hazard"
  )
)


</code></pre>

<hr>
<h2 id='prepare_data'>Prepare raw data by binning them in 1d or 2d</h2><span id='topic+prepare_data'></span>

<h3>Description</h3>

<p><code>prepare_data()</code> prepares the raw individual time-to-event data
for hazard estimation in 1d or 2d.
</p>
<p>Given the raw data, this function first constructs the bins over one or two
time axes and then computes the aggregated (or individual)
vectors or matrices of exposure times and events indicators. A data.frame with
covariates values can be provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_data(
  data = NULL,
  t_in = NULL,
  t_out = NULL,
  u = NULL,
  s_in = NULL,
  s_out,
  events,
  min_t = NULL,
  max_t = NULL,
  min_u = NULL,
  max_u = NULL,
  min_s = NULL,
  max_s = NULL,
  dt = NULL,
  du = NULL,
  ds,
  individual = FALSE,
  covs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepare_data_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_t_in">t_in</code></td>
<td>
<p>(optional) A vector of entry times on the time scale <code>t</code>.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_t_out">t_out</code></td>
<td>
<p>(optional) A vector of exit times on the time scale <code>t</code>.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_u">u</code></td>
<td>
<p>(optional) A vector of fixed-times at entry in the process.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_s_in">s_in</code></td>
<td>
<p>(optional) A vector of entry times on the time scale <code>s</code>.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_s_out">s_out</code></td>
<td>
<p>A vector of exit times on the time scale <code>s</code>.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_events">events</code></td>
<td>
<p>A vector of event's indicators (possible values 0/1).</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_min_t">min_t</code></td>
<td>
<p>(optional) A minimum value for the bins over <code>t</code>.
If <code>NULL</code>, the minimum of <code>t_in</code> will be used.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_max_t">max_t</code></td>
<td>
<p>(optional) A maximum value for the bins over <code>t</code>.
If <code>NULL</code>, the maximum of <code>t_out</code> will be used.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_min_u">min_u</code></td>
<td>
<p>(optional) A minimum value for the bins over <code>u</code>.
If <code>NULL</code>, the minimum of <code>u</code> will be used.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_max_u">max_u</code></td>
<td>
<p>(optional) A maximum value for the bins over <code>u</code>.
If <code>NULL</code>, the maximum of <code>u</code> will be used.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_min_s">min_s</code></td>
<td>
<p>(optional) A minimum value for the bins over <code>s</code>.
If <code>NULL</code>, the minimum of <code>s_in</code> will be used.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_max_s">max_s</code></td>
<td>
<p>(optional) A maximum value for the bins over <code>s</code>.
If <code>NULL</code>, the maximum of <code>s_out</code> will be used.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_dt">dt</code></td>
<td>
<p>(optional) A scalar giving the length of the intervals on the <code>t</code> time scale.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_du">du</code></td>
<td>
<p>(optional) A scalar giving the length of the intervals on the <code>u</code> axis.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_ds">ds</code></td>
<td>
<p>A scalar giving the length of the intervals on the <code>s</code> time scale.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_individual">individual</code></td>
<td>
<p>A Boolean. Default is <code>FALSE</code>: if <code>FALSE</code> computes the matrices <code>R</code> and <code>Y</code>
collectively for all observations; if <code>TRUE</code> computes the matrices <code>R</code> and <code>Y</code> separately for each individual record.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_covs">covs</code></td>
<td>
<p>A data.frame with the variables to be used as covariates.
The function will create dummy variables for any factor variable passed as argument in <code>covs</code>.
If a variable of class character is passed as argument, it will be converted to factor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A few words about constructing the grid of bins.
Bins are containers for the individual data. There is no 'golden rule' or
optimal strategy for setting the number of bins over each time axis, or deciding
on the bins' width. It very much depends on the data structure, however, we
try to give some directions here. First, in most cases, more bins is better
than less bins. A good number is about 30 bins.
However, if data are scarce, the user might want to find a compromise between
having a larger number of bins, and having many bins empty.
Second, the chosen width of the bins (that is <code>du</code> and <code>ds</code>) does depend on
the time unit over which the time scales are measured. For example, if the time
is recorded in days, as in the example below, and several years of follow-up
are available, the user can split the data in bins of width 30 (corresponding
to about one month), 60 (about two months), 90 (about three months), etc.
If the time scale is measured in years, then appropriate width could be 0.25
(corresponding to a quarter of a year), or 0.5 (that is half year). However,
in some cases, time might be measure in completed years, as is often the case
for age. In this scenario, an appropriate bin width is 1.
</p>
<p>Finally, it is always a good idea to plot the data first, and explore the range
of values over which the time scale(s) are recorded. This will give insight
about reasonable values for the arguments <code>min_s</code>, <code>min_u</code>, <code>max_s</code> and <code>max_u</code>
(that in any case are optional).
</p>
<p>Regarding names of covariates or levels of categorical covariates/factors:
When using &quot;LMMsolver&quot; to fit a model with covariates that which have names
(or factor labels) including a symbol such as &quot;+&quot;, &quot;-&quot;, &quot;&lt;&quot; or &quot;&gt;&quot; will result
in an error. To avoid this, the responsible names (labels) will be rewritten
without mathematical symbols. For example: &quot;Lev+5FU&quot; (in the colon cancer data)
is replaced by &quot;Lev&amp;5FU&quot;.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>bins</code> a list:
</p>

<ul>
<li> <p><code>bins_t</code> if <code>t_out</code> is provided, this is a vector of bins extremes for the time scale <code>t</code>.
</p>
</li>
<li> <p><code>mid_t</code> if <code>t_out</code> is provided, this is a vector with the midpoints of the bins over <code>t</code>.
</p>
</li>
<li> <p><code>nt</code> if <code>t_out</code> is provided, this is the number of bins over <code>t</code>.
</p>
</li>
<li> <p><code>bins_u</code> if <code>u</code> is provided, this is a vector of bins extremes for <code>u</code> axis.
</p>
</li>
<li> <p><code>midu</code> if <code>u</code> is provided, this is a vector with the midpoints of the bins over <code>u</code>.
</p>
</li>
<li> <p><code>nu</code> if <code>u</code> is provided, this is the number of bins over <code>u</code>.
</p>
</li>
<li> <p><code>bins_s</code> is a vector of bins extremes for the time scale <code>s</code>.
</p>
</li>
<li> <p><code>mids</code> is a vector with the midpoints of the bins over <code>s</code>.
</p>
</li>
<li> <p><code>ns</code> is the number of bins over <code>s</code>.
</p>
</li></ul>

</li>
<li> <p><code>bindata</code>:
</p>

<ul>
<li> <p><code>r</code> or <code>R</code> an array of exposure times: if binning the data over
one time scale only this is a vector.
If binning the data over two time scales and if <code>individual == TRUE</code>
then <code>R</code> is an array of dimension nu by ns by n, otherwise it is an
array of dimension nu by ns
</p>
</li>
<li> <p><code>y</code> or <code>Y</code> an array of event counts: if binning the data over one time
scale only this is a vector.
If binning the data over two time scales and if <code>individual == TRUE</code>
then <code>Y</code> is an array of dimension nu by ns by n, otherwise it is an
array of dimension nu by ns
</p>
</li>
<li> <p><code>Z</code> A matrix of covariates' values to be used in the model,
of dimension n by p
</p>
</li></ul>

</li></ul>



<h3>Author(s)</h3>

<p>Angela Carollo <a href="mailto:carollo@demogr.mpg.de">carollo@demogr.mpg.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Bin data over s = time since recurrence only, with intervals of length 30 days
# aggregated data (no covariates)
# The following example provide the vectors of data directly from the dataset
binned_data &lt;- prepare_data(s_out = reccolon2ts$timesr, events = reccolon2ts$status, ds = 30)
# Visualize vector of event counts
print(binned_data$bindata$y)
# Visualize midpoints of the bins
print(binned_data$bins$mids)
# Visualize number of bins
print(binned_data$bins$ns)

# Now, the same thing is done by providing a dataset and the name of all relevant variables
binned_data &lt;- prepare_data(data = reccolon2ts, s_out = "timesr", events = "status", ds = 30)
# Visualize vector of event counts
print(binned_data$bindata$y)

# Now using ds = .3 and the same variable measured in years
binned_data &lt;- prepare_data(s_out = reccolon2ts$timesr_y, events = reccolon2ts$status, ds = .3)
# Visualize vector of exposure timess
print(binned_data$bindata$r)


# Bin data over u = time at recurrence and s = time since recurrence, measured in days
# aggregated data (no covariates)
# Note that if we do not provide du this is taken to be equal to ds
binned_data &lt;- prepare_data(
  u = reccolon2ts$timer, s_out = reccolon2ts$timesr,
  events = reccolon2ts$status, ds = 30
)

# Visualize matrix of event counts
print(binned_data$bindata$Y)

# Visualize midpoints of bins over u
print(binned_data$bins$midu)


# Bin data over u = time at recurrence and s = time since recurrence, measured in day
# individual-level data required
# we provide two covariates: nodes (numerical) and rx (factor)
covs &lt;- subset(reccolon2ts, select = c("nodes", "rx"))
binned_data &lt;- prepare_data(
  u = reccolon2ts$timer, s_out = reccolon2ts$timesr,
  events = reccolon2ts$status, ds = 30, individual = TRUE, covs = covs
)

# Visualize structure of binned data
print(str(binned_data$bindata))

# Alternatevely:
binned_data &lt;- prepare_data(
  data = reccolon2ts,
  u = "timer", s_out = "timesr",
  events = "status", ds = 30, individual = TRUE, covs = c("nodes", "rx")
)

</code></pre>

<hr>
<h2 id='prepare_data_LMMsolver'>Process data to fit model with LMMsolver</h2><span id='topic+prepare_data_LMMsolver'></span>

<h3>Description</h3>

<p>Process data to fit model with LMMsolver
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_data_LMMsolver(Y = Y, R = R, Z = NULL, bins = bins)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepare_data_LMMsolver_+3A_y">Y</code></td>
<td>
<p>A matrix (or 3d-array) of event counts of dimension nu by ns
(or nu by ns by n).</p>
</td></tr>
<tr><td><code id="prepare_data_LMMsolver_+3A_r">R</code></td>
<td>
<p>A matrix (or 3d-array) of exposure times of dimension nu by ns
(or nu by ns by n).</p>
</td></tr>
<tr><td><code id="prepare_data_LMMsolver_+3A_z">Z</code></td>
<td>
<p>(optional) A regression matrix of covariates values of dimensions
n by p.</p>
</td></tr>
<tr><td><code id="prepare_data_LMMsolver_+3A_bins">bins</code></td>
<td>
<p>a list with the specification for the bins. This is created by
the function <code>prepare_data</code>. If a list prepared externally from such function
if provided, it should contain the following elements:
* <code>bins_u</code> A vector of bins extremes for the time scale <code>u</code>.
* <code>midu</code> A vector with the midpoints of the bins over <code>u</code>.
* <code>nu</code> The number of bins over <code>u</code>.
* <code>bins_s</code> A vector of bins extremes for the time scale <code>s</code>.
* <code>mids</code> A vector with the midpoints of the bins over <code>s</code>.
* <code>ns</code> The number of bins over <code>s</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataset in long form to fit the model with LMMsolver
</p>

<hr>
<h2 id='print.data2ts'>Print method for a <code>data2ts</code> object</h2><span id='topic+print.data2ts'></span>

<h3>Description</h3>

<p>Print method for an object of class <code>data2ts</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data2ts'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.data2ts_+3A_x">x</code></td>
<td>
<p>of class <code>data2ts</code>, as prepared by <code><a href="#topic+prepare_data">prepare_data</a></code></p>
</td></tr>
<tr><td><code id="print.data2ts_+3A_...">...</code></td>
<td>
<p>Further arguments to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>


<h3>Author(s)</h3>

<p>Angela Carollo <a href="mailto:carollo@demogr.mpg.de">carollo@demogr.mpg.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Bin the colon cancer data over s (time since recurrence)

dt1ts &lt;- prepare_data(data = reccolon2ts,
                      s_in = "entrys",
                      s_out = "timesr",
                      events = "status",
                      ds = 180)

print(dt1ts)

# Bin the colon cancer data over u (time at recurrence) and s (time since recurrence)
dt2ts &lt;- prepare_data(data = reccolon2ts,
                      u = "timer",
                      s_in = "entrys",
                      s_out = "timesr",
                      events = "status",
                      ds = 180)
print(dt2ts)

</code></pre>

<hr>
<h2 id='reccolon2ts'>Data from the chemotherapy for stace B/C colon cancer study</h2><span id='topic+reccolon2ts'></span>

<h3>Description</h3>

<p>This dataset is a reduced version of the dataset colon from the package
survival (Therneau, T.M. et al., 2022). Each observation is a transition from
recurrence of colon cancer to death or censoring. The time scales are time
from randomization to recurrence, time from randomization to death or
censoring and time from recurrence of the cancer to death or censoring.
Only observations about individuals with a recurrence of the cancer are selected.
Additionally, 7 individuals with exit times from the risk set equal to entry times in the
recurrence state (0 exposure time) were dropped from the sample.
In the original dataset, all times of recurrence are known precisely, so that
after recurrence all individuals are followed right from entry in the state,
without left truncation. To be able to illustrate
how to include left truncated times in the model, artificial left truncated
entry in the 'recurrence' state are introduced for 40 individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(reccolon2ts)
</code></pre>


<h3>Format</h3>



<h4>reccolon2ts A data.table with 461 rows and 25 columns:</h4>


<dl>
<dt>id</dt><dd><p>patient's id</p>
</dd>
<dt>study</dt><dd><p>1 for all patients</p>
</dd>
<dt>rx</dt><dd><p>Treatment - Obs(ervation), Lev(amisole), Lev(amisole)+5-FU</p>
</dd>
<dt>sex</dt><dd><p>1=male, 0=female</p>
</dd>
<dt>age</dt><dd><p>Age at transplant in years</p>
</dd>
<dt>obstruct</dt><dd><p>obstruction of colon by tumor: 1=yes</p>
</dd>
<dt>perfor</dt><dd><p>perforation of colon: 1=yes</p>
</dd>
<dt>adhere</dt><dd><p>adherence to nearby organs: 1=yes</p>
</dd>
<dt>nodes</dt><dd><p>number of lymph nodes with detectable cancer</p>
</dd>
<dt>status</dt><dd><p>censoring status: 0=censoring, 1=event</p>
</dd>
<dt>differ</dt><dd><p>differentiation of tumour: 1=well, 2=moderate, 3=poor</p>
</dd>
<dt>extent</dt><dd><p>extent of local spread: 1=submucosa, 2=muscle, 3=serosa,
4=contigous structures</p>
</dd>
<dt>surg</dt><dd><p>time from surgery to registration: 0=short, 1=long</p>
</dd>
<dt>node4</dt><dd><p>more than 4 positive lymph nodes</p>
</dd>
<dt>etype</dt><dd><p>2 for all patients (2=death)</p>
</dd>
<dt>timedc</dt><dd><p>time in days from randomization to death or censoring</p>
</dd>
<dt>timer</dt><dd><p>time in days from randomization to recurrence</p>
</dd>
<dt>timesr</dt><dd><p>time in days from recurrence to death or censoring</p>
</dd>
<dt>entrys</dt><dd><p>artificial entry time on the time since
recurrence scale. For most of the individual this is 0 (no left
truncation). For 40 individuals a random number between 1 and the exit time
on the time since recurrence scale (timesr) is simulated.</p>
</dd>
<dt>entryt</dt><dd><p>time in days from randomization to observation in the
recurrence state. If the individual is observed from entry in the
recurrence state this is equal to the time at recurrence. If the entry in
the recurrence state is not observed from the beginning, left truncation is
observed. This is not present in the original data, but has been here
introduced artificially for 40 individuals. This is done by first
increasing the time at recurrence by a random number between 1 and the exit
time on the time since recurrence scale. Then, the time at recurrence is
added to the artificial entry time.</p>
</dd>
<dt>timedc_y</dt><dd><p>time in years from randomization to death or censoring</p>
</dd>
<dt>timer_y</dt><dd><p>time in years from randomization to recurrence</p>
</dd>
<dt>entrys_y</dt><dd><p>left truncated entry in the recurrence state measured in
years since recurrence</p>
</dd>
<dt>entryt_y</dt><dd><p>left truncated entry in the recurrence state measured in
years since randomization</p>
</dd>
<dt>timesr_y</dt><dd><p>time in years from recurrence to death or
censoring</p>
</dd> </dl>




<h3>Source</h3>

<p>Therneau, T. (2023). A Package for Survival Analysis in R. R package
version 3.5-3, <a href="https://CRAN.R-project.org/package=survival">https://CRAN.R-project.org/package=survival</a>
</p>


<h3>References</h3>

<p>Moertel, C.G, et al. (1995). Fluorouracil plus Levamisole as
Effective Adjuvant Theraphy after Resection of Stage III Colon Carcinoma: A
Final Report. Annals of Internal Medicine, 122:321-326
</p>
<p>Moerel, C.G., et al. (1990). Levamisole and Fluorouracil for Adjvant
Theraphy of Resected Colon Carcinoma. The New England Journal of Medicine,
322:352-8
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(reccolon2ts)
rm(reccolon2ts)

</code></pre>

<hr>
<h2 id='surv2ts'>Survival function with two time scales</h2><span id='topic+surv2ts'></span>

<h3>Description</h3>

<p>Computes the survival matrix, that contains the probability of not
experiencing an event (of any cause) by time <code>s</code> and fixed entry time <code>u</code>.
The survival function can be obtained from one fitted model with only one
event type, or combining information from several cause-specific hazard
in a competing risks model. In the first case, a fitted object of class <code>'haz2ts'</code>
or <code>'haz2tsLMM'</code> can be passed directly as argument to the function. In the
competing risks framework, the user should provide a list of cause-specific
cumulative hazard matrices. The function is also called internally from <code>plot()</code>
if the user wants to plot the cumulative hazard from a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surv2ts(
  cumhaz = NULL,
  fitted_model = NULL,
  plot_grid = NULL,
  cause = NULL,
  midpoints = FALSE,
  where_slices = NULL,
  direction = c("u", "s", NULL),
  tmax = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surv2ts_+3A_cumhaz">cumhaz</code></td>
<td>
<p>(optional) a list with all the cause-specific cumulated hazard
matrices (minimum one element needs to be supplied).
If more than one cause-specific cumulated hazard is provided,
then they should all be matrices of the same dimension.</p>
</td></tr>
<tr><td><code id="surv2ts_+3A_fitted_model">fitted_model</code></td>
<td>
<p>(optional) The output of the function <code>fit2ts</code>.
This is an object of class <code>'haz2ts'</code> or <code>'haz2tsLMM'</code>.</p>
</td></tr>
<tr><td><code id="surv2ts_+3A_plot_grid">plot_grid</code></td>
<td>
<p>(optional) A list containing the parameters to build a new
finer grid of intervals over <code>u</code> and <code>s</code> for plotting. This must be of the
form:
</p>

<ul>
<li> <p><code>plot_grid = list(c(umin, umax, du), c(smin, smax, ds))</code>
where <code>umin</code>, <code>umax</code> and <code>smin</code>, <code>smax</code> are the minimum and maximum values
desired for the grid-points over <code>u</code> and <code>s</code> respectively, and <code>du</code>, <code>ds</code> are
distances between points over <code>u</code> and <code>s</code> respectively. Specifying a new
denser grid is used to evaluate the B-spline bases used for estimation on
such grid and plot the estimated surfaces with a greater level of details.
If not specified, the plotting is done using the same B-splines bases as
for the estimation. The function will check if the parameters for the grid
provided by the user are compatible with those originally used to construct
the B-splines for estimating the model. If not, the grid will be adjusted
accordingly and a warning will be returned.
</p>
</li></ul>
</td></tr>
<tr><td><code id="surv2ts_+3A_cause">cause</code></td>
<td>
<p>a character string with a short name for the cause (optional).</p>
</td></tr>
<tr><td><code id="surv2ts_+3A_midpoints">midpoints</code></td>
<td>
<p>A Boolean. Default is <code>FALSE</code>. If <code>TRUE</code>, the estimated
quantities are evaluated at the midpoints of the rectangles
(or parallelograms) of the grids, rather than at each grid-point.</p>
</td></tr>
<tr><td><code id="surv2ts_+3A_where_slices">where_slices</code></td>
<td>
<p>A vector of values for the cutting points of the desired
slices of the surface. This option is included mostly for the plotting function.
When using <code>plot.haz2ts()</code>, the user selects <code>which_plot = "survival"</code> and
<code>surv_slices = TRUE</code>, then <code>where_slices</code> indicates the location of the
cutting points over the <code>u</code> time.</p>
</td></tr>
<tr><td><code id="surv2ts_+3A_direction">direction</code></td>
<td>
<p>If cross-sectional one-dimensional curves are plotted, this
indicates whether the cutting points are located on the <code>u</code> time, or on the
<code>s</code> time. For plots of the survival function, only cutting points over the
<code>u</code> time are meaningful.</p>
</td></tr>
<tr><td><code id="surv2ts_+3A_tmax">tmax</code></td>
<td>
<p>The maximum value of <code>t</code> that should be plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix containing the values of the survival function over <code>s</code> and <code>u</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create some fake data - the bare minimum
id &lt;- 1:20
u &lt;- c(5.43, 3.25, 8.15, 5.53, 7.28, 6.61, 5.91, 4.94, 4.25, 3.86, 4.05, 6.86,
       4.94, 4.46, 2.14, 7.56, 5.55, 7.60, 6.46, 4.96)
s &lt;- c(0.44, 4.89, 0.92, 1.81, 2.02, 1.55, 3.16, 6.36, 0.66, 2.02, 1.22, 3.96,
       7.07, 2.91, 3.38, 2.36, 1.74, 0.06, 5.76, 3.00)
ev &lt;- c(1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1)


fakedata &lt;- as.data.frame(cbind(id, u, s, ev))
fakedata2ts &lt;- prepare_data(u = fakedata$u,
                            s_out = fakedata$s,
                            ev = fakedata$ev,
                            ds = .5)
# Fit a fake model - not optimal smoothing
fakemod &lt;- fit2ts(fakedata2ts,
                  optim_method = "grid_search",
                  lrho = list(seq(1 , 1.5, .5),
                              seq(1 , 1.5, .5)))

# Obtain the fake cumulated hazard
fakecumhaz2ts &lt;- cumhaz2ts(fakemod)
# Fake survival curve
fakesurv2ts &lt;- surv2ts(fitted_model = fakemod)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
