<!DOCTYPE html><html lang="en"><head><title>Help for package SEMgraph</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SEMgraph}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alsData'><p>Amyotrophic Lateral Sclerosis (ALS) dataset</p></a></li>
<li><a href='#ancestry'><p>Node ancestry utilities</p></a></li>
<li><a href='#clusterGraph'><p>Topological graph clustering</p></a></li>
<li><a href='#clusterScore'><p>Module scoring</p></a></li>
<li><a href='#colorGraph'><p>Vertex and edge graph coloring on the base of fitting</p></a></li>
<li><a href='#cplot'><p>Subgraph mapping</p></a></li>
<li><a href='#dagitty2graph'><p>Graph conversion from dagitty to igraph</p></a></li>
<li><a href='#extractClusters'><p>Cluster extraction utility</p></a></li>
<li><a href='#factor.analysis'><p>Factor analysis for high dimensional data</p></a></li>
<li><a href='#gplot'><p>Graph plotting with renderGraph</p></a></li>
<li><a href='#graph2dag'><p>Convert directed graphs to directed acyclic graphs (DAGs)</p></a></li>
<li><a href='#graph2dagitty'><p>Graph conversion from igraph to dagitty</p></a></li>
<li><a href='#graph2lavaan'><p>Graph to lavaan model</p></a></li>
<li><a href='#kegg'><p>KEGG interactome</p></a></li>
<li><a href='#kegg.pathways'><p>KEGG pathways</p></a></li>
<li><a href='#lavaan2graph'><p>lavaan model to graph</p></a></li>
<li><a href='#localCI.test'><p>Conditional Independence (CI) local tests of an acyclic graph</p></a></li>
<li><a href='#mergeNodes'><p>Graph nodes merging by a membership attribute</p></a></li>
<li><a href='#modelSearch'><p>Optimal model search strategies</p></a></li>
<li><a href='#orientEdges'><p>Assign edge orientation of an undirected graph</p></a></li>
<li><a href='#pairwiseMatrix'><p>Pairwise plotting of multivariate data</p></a></li>
<li><a href='#parameterEstimates'><p>Parameter Estimates of a fitted SEM</p></a></li>
<li><a href='#pathFinder'><p>Perturbed path search utility</p></a></li>
<li><a href='#properties'><p>Graph properties summary and graph decomposition</p></a></li>
<li><a href='#resizeGraph'><p>Interactome-assisted graph re-seizing</p></a></li>
<li><a href='#sachs'><p>Sachs multiparameter flow cytometry data and consensus model</p></a></li>
<li><a href='#SEMace'><p>Compute the Average Causal Effect (ACE) for a given source-sink pair</p></a></li>
<li><a href='#SEMbap'><p>Bow-free covariance search and data de-correlation</p></a></li>
<li><a href='#SEMdag'><p>Estimate a DAG from an input (or empty) graph</p></a></li>
<li><a href='#SEMdci'><p>SEM-based differential network analysis</p></a></li>
<li><a href='#SEMgsa'><p>SEM-based gene set analysis</p></a></li>
<li><a href='#SEMpath'><p>Search for directed or shortest paths between pairs of source-sink nodes</p></a></li>
<li><a href='#SEMrun'><p>Fit a graph as a Structural Equation Model (SEM)</p></a></li>
<li><a href='#SEMtree'><p>Tree-based structure learning methods</p></a></li>
<li><a href='#Shipley.test'><p>Missing edge testing implied by a DAG with Shipley's basis-set</p></a></li>
<li><a href='#summary.GGM'><p>GGM model summary</p></a></li>
<li><a href='#summary.RICF'><p>RICF model summary</p></a></li>
<li><a href='#transformData'><p>Transform data methods</p></a></li>
<li><a href='#weightGraph'><p>Graph weighting methods</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Network Analysis and Causal Inference Through Structural
Equation Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-20</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimate networks and causal relationships in complex systems through
  Structural Equation Modeling. This package also includes functions for importing,
  weight, manipulate, and fit biological network models within the
  Structural Equation Modeling framework as outlined in the Supplementary Material of
  Grassi M, Palluzzi F, Tarantino B (2022) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtac567">doi:10.1093/bioinformatics/btac567</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/fernandoPalluzzi/SEMgraph">https://github.com/fernandoPalluzzi/SEMgraph</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>igraph (&ge; 1.6.0), lavaan (&ge; 0.6-1), R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>aspect, boot, corpcor, dagitty, flip, gdata, ggm, glasso,
glmnet, graph, mgcv, mvtnorm, pbapply, protoclust, RBGL,
Rgraphviz</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Barbara Tarantino &lt;barbara.tarantino01@universitadipavia.it&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Author:</td>
<td>Mario Grassi [aut],
  Fernando Palluzzi [aut],
  Barbara Tarantino [cre]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-29 13:27:28 UTC; mario</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-29 18:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='alsData'>Amyotrophic Lateral Sclerosis (ALS) dataset</h2><span id='topic+alsData'></span>

<h3>Description</h3>

<p>Expression profiling through high-throughput sequencing 
(RNA-seq) of 139 ALS patients and 21 healthy controls (HCs), 
from Tam et al. (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alsData
</code></pre>


<h3>Format</h3>

<p>alsData is a list of 4 objects:
</p>

<ol>
<li><p> &quot;graph&quot;, ALS graph as the largest connected component of the 
&quot;Amyotrophic lateral sclerosis (ALS)&quot; pathway from KEGG database;
</p>
</li>
<li><p> &quot;exprs&quot;, a matrix of 160 rows (subjects) and 318 columns (genes)
extracted from the original 17695. This subset includes genes from 
KEGG pathways, needed to run SEMgraph examples.
Raw data from the GEO dataset GSE124439 (Tam et al., 2019) were 
pre-processed applying batch effect correction, using the sva R package 
(Leek et al., 2012), to remove data production center and brain area 
biases. Using multidimensional scaling-based clustering, ALS-specific 
and an HC-specific clusters were generated. Misclassified samples were 
blacklisted and removed from the current dataset;
</p>
</li>
<li><p> &quot;group&quot;, a binary group vector of 139 ALS subjects (1) and 21 
healthy controls (0);
</p>
</li>
<li><p> &quot;details&quot;, a data.frame reporting information about included 
and blacklisted samples.
</p>
</li></ol>



<h3>Source</h3>

<p><a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE124439">https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE124439</a>
</p>


<h3>References</h3>

<p>Tam OH, Rozhkov NV, Shaw R, Kim D et al. (2019). Postmortem Cortex 
Samples Identify Distinct Molecular Subtypes of ALS: Retrotransposon 
Activation, Oxidative Stress, and Activated Glia. Cell Reports, 
29(5):1164-1177.e5. &lt;https://doi.org/10.1016/j.celrep.2019.09.066&gt;
</p>
<p>Jeffrey T. Leek, W. Evan Johnson, Hilary S. Parker, Andrew E. Jaffe, 
and John D. Storey (2012). The sva package for removing batch effects 
and other unwanted variation in high-throughput experiments. 
Bioinformatics. Mar 15; 28(6): 882-883. 
&lt;https://doi.org/10.1093/bioinformatics/bts034&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alsData$graph
dim(alsData$exprs)
table(alsData$group)

</code></pre>

<hr>
<h2 id='ancestry'>Node ancestry utilities</h2><span id='topic+ancestry'></span><span id='topic+ancestors'></span><span id='topic+descendants'></span><span id='topic+parents'></span><span id='topic+siblings'></span>

<h3>Description</h3>

<p>Get ancestry for a collection of nodes in a graph.
These functions are wrappers for the original <code>SEMID</code> R package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ancestors(g, nodes)

descendants(g, nodes)

parents(g, nodes)

siblings(g, nodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ancestry_+3A_g">g</code></td>
<td>
<p>An igraph object.</p>
</td></tr>
<tr><td><code id="ancestry_+3A_nodes">nodes</code></td>
<td>
<p>the nodes in the graph of which to get the ancestry.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sorted vector of nodes.
</p>


<h3>References</h3>

<p>Rina Foygel Barber, Mathias Drton and Luca Weihs (2019). SEMID:
Identifiability of Linear Structural Equation Models. R package
version 0.3.2. &lt;https://CRAN.R-project.org/package=SEMID/&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Get all ancestors
an &lt;- V(sachs$graph)[ancestors(sachs$graph, "Erk")]; an

# Get parents
pa &lt;- V(sachs$graph)[parents(sachs$graph, "PKC")]; pa

# Get descendants
de &lt;- V(sachs$graph)[descendants(sachs$graph, "PKA")]; de

# Get siblings
sib &lt;- V(sachs$graph)[siblings(sachs$graph, "PIP3")]; sib

</code></pre>

<hr>
<h2 id='clusterGraph'>Topological graph clustering</h2><span id='topic+clusterGraph'></span>

<h3>Description</h3>

<p>Topological graph clustering methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterGraph(graph, type = "wtc", HM = "none", size = 5, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clusterGraph_+3A_graph">graph</code></td>
<td>
<p>An igraph object.</p>
</td></tr>
<tr><td><code id="clusterGraph_+3A_type">type</code></td>
<td>
<p>Topological clustering methods. If <code>type = "tahc"</code>,
network modules are generated using the tree agglomerative hierarchical
clustering method (Yu et al., 2015). Other non-tree clustering methods
from <code>igraph</code> package include: &quot;wtc&quot;
(default value; walktrap community structure with short random walks),
&quot;ebc&quot; (edge betweeness clustering), &quot;fgc&quot; (fast greedy method), &quot;lbc&quot;
(label propagation method), &quot;lec&quot; (leading eigenvector method), &quot;loc&quot;
(multi-level optimization), &quot;opc&quot; (optimal community structure), &quot;sgc&quot;
(spinglass statistical mechanics).</p>
</td></tr>
<tr><td><code id="clusterGraph_+3A_hm">HM</code></td>
<td>
<p>Hidden model type. Enables the visualization of the hidden
model, gHM. If set to &quot;none&quot; (default), no gHM igraph object is saved.
For each defined hidden module:
(i) if <code>HM = "LV"</code>, a latent variable (LV) will be defined as
common unknown cause acting on cluster nodes; (ii) if <code>HM = "CV"</code>,
cluster nodes will be considered as regressors of a latent composite
variable (CV); (iii) if <code>HM = "UV"</code>, an unmeasured variable (UV)
is defined, where source nodes of the module (i.e., in-degree = 0)
act as common regressors influencing the other nodes via an unmeasured
variable (see also <code><a href="#topic+clusterScore">clusterScore</a></code>).</p>
</td></tr>
<tr><td><code id="clusterGraph_+3A_size">size</code></td>
<td>
<p>Minimum number of nodes per module. By default, a minimum
number of 5 nodes is required.</p>
</td></tr>
<tr><td><code id="clusterGraph_+3A_verbose">verbose</code></td>
<td>
<p>A logical value. If FALSE (default), the gHM igraph
will not be plotted to screen, saving execution time (they will be
returned in output anyway).</p>
</td></tr>
<tr><td><code id="clusterGraph_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If HM is not &quot;none&quot; a list of 2 objects is returned:
</p>

<ol>
<li><p> &quot;gHM&quot;, subgraph containing hidden modules as an igraph object;
</p>
</li>
<li><p> &quot;membership&quot;, cluster membership vector for each node.
</p>
</li></ol>

<p>If HM is &quot;none&quot;, only the cluster membership vector is returned.
</p>


<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>References</h3>

<p>Fortunato S, Hric D. Community detection in networks: A user guide (2016).
Phys Rep; 659: 1-44. &lt;https://dx.doi.org/10.1016/j.physrep.2016.09.002&gt;
</p>
<p>Yu M, Hillebrand A, Tewarie P, Meier J, van Dijk B, Van Mieghem P,
Stam CJ (2015). Hierarchical clustering in minimum spanning trees.
Chaos 25(2): 023107. &lt;https://doi.org/10.1063/1.4908014&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clusterScore">clusterScore</a></code>, <code><a href="#topic+cplot">cplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Clustering ALS graph with WTC method and LV model
G &lt;- properties(alsData$graph)[[1]]
clv &lt;- clusterGraph(graph = G, type = "wtc", HM = "LV")
gplot(clv$gHM, l = "fdp")
table(clv$membership)

</code></pre>

<hr>
<h2 id='clusterScore'>Module scoring</h2><span id='topic+clusterScore'></span>

<h3>Description</h3>

<p>Generate factor scores, principal component scores, or
projection scores of latent, composite, and unmeasured variable modules,
respectively, and fit them with an exogenous group effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterScore(
  graph,
  data,
  group,
  HM = "LV",
  type = "wtc",
  size = 5,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clusterScore_+3A_graph">graph</code></td>
<td>
<p>An igraph object.</p>
</td></tr>
<tr><td><code id="clusterScore_+3A_data">data</code></td>
<td>
<p>A matrix or data.frame. Rows correspond to subjects, and
columns to graph nodes.</p>
</td></tr>
<tr><td><code id="clusterScore_+3A_group">group</code></td>
<td>
<p>A binary vector. This vector must be as long as the number
of subjects. Each vector element must be 1 for cases and 0 for control
subjects.</p>
</td></tr>
<tr><td><code id="clusterScore_+3A_hm">HM</code></td>
<td>
<p>Hidden model type. For each defined hidden module:
(i) if <code>HM = "LV"</code>, a latent variable (LV) will be defined as
common unknown cause acting on cluster nodes; (ii) if <code>HM = "CV"</code>,
cluster nodes will be considered as regressors of a latent composite
variable (CV); (iii) if <code>HM = "UV"</code>, an unmeasured variable (UV)
model will be generated for each module, where source nodes (i.e.,
in-degree = 0) act as common regressors influencing the other nodes
via an unmeasured variable.
By default, HM is set to &quot;LV&quot; (i.e., the latent variable model).</p>
</td></tr>
<tr><td><code id="clusterScore_+3A_type">type</code></td>
<td>
<p>Graph clustering method. If <code>type = "tahc"</code>, network
modules are generated using the tree agglomerative hierarchical
clustering method (Yu et al., 2015).
Other non-tree clustering methods from igraph package include: &quot;wtc&quot;
(default value; walktrap community structure with short random walks),
&quot;ebc&quot; (edge betweenness clustering), &quot;fgc&quot; (fast greedy method), &quot;lbc&quot;
(label propagation method), &quot;lec&quot; (leading eigenvector method), &quot;loc&quot;
(multi-level optimization), &quot;opc&quot; (optimal communiy structure), &quot;sgc&quot;
(spinglass statistical mechanics).
By default, the &quot;wtc&quot; method is used.</p>
</td></tr>
<tr><td><code id="clusterScore_+3A_size">size</code></td>
<td>
<p>Minimum number of nodes per hidden module. By default, a
minimum number of 5 nodes is required.</p>
</td></tr>
<tr><td><code id="clusterScore_+3A_verbose">verbose</code></td>
<td>
<p>A logical value. If TRUE, intermediate graphs will be
displayed during the execution. In addition, a reduced graph with
clusters as nodes will be fitted and showed to screen (see also
<code><a href="#topic+mergeNodes">mergeNodes</a></code>). By default, <code>verbode = FALSE</code>.</p>
</td></tr>
<tr><td><code id="clusterScore_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 3 objects:
</p>

<ol>
<li><p> &quot;fit&quot;, hidden module fitting as a lavaan object;
</p>
</li>
<li><p> &quot;membership&quot;, hidden module nodes membership;
<code><a href="#topic+clusterGraph">clusterGraph</a></code> function;
</p>
</li>
<li><p> &quot;dataHM&quot;, data matrix with cluster scores in first columns.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>References</h3>

<p>Grassi M, Palluzzi F, Tarantino B (2022). SEMgraph: An R Package for Causal Network
Analysis of High-Throughput Data with Structural Equation Models.
Bioinformatics, 38 (20), 4829–4830 &lt;https://doi.org/10.1093/bioinformatics/btac567&gt;
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+clusterGraph">clusterGraph</a></code> and <code><a href="#topic+cplot">cplot</a></code>
for graph clustering.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Nonparanormal(npn) transformation
als.npn &lt;- transformData(alsData$exprs)$data

C &lt;- clusterScore(graph = alsData$graph, data = als.npn,
                  group = alsData$group,
                  HM = "LV",
                  type = "wtc",
                  verbose = FALSE)
summary(C$fit)
head(C$dataHM)
table(C$membership)

</code></pre>

<hr>
<h2 id='colorGraph'>Vertex and edge graph coloring on the base of fitting</h2><span id='topic+colorGraph'></span>

<h3>Description</h3>

<p>Add vertex and edge color attributes to an igraph object,
based on a fitting results data.frame generated by
<code><a href="#topic+SEMrun">SEMrun</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorGraph(
  est,
  graph,
  group,
  method = "none",
  alpha = 0.05,
  vcolor = c("lightblue", "white", "pink"),
  ecolor = c("royalblue3", "gray50", "red2"),
  ewidth = c(1, 2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colorGraph_+3A_est">est</code></td>
<td>
<p>A data.frame of estimated parameters and p-values, derived
from the <code>fit</code> object returned by <code><a href="#topic+SEMrun">SEMrun</a></code>.
As an alternative, the user may provide a &quot;gest&quot; or &quot;dest&quot; data.frame
generated by <code><a href="#topic+SEMrun">SEMrun</a></code>.</p>
</td></tr>
<tr><td><code id="colorGraph_+3A_graph">graph</code></td>
<td>
<p>An igraph object.</p>
</td></tr>
<tr><td><code id="colorGraph_+3A_group">group</code></td>
<td>
<p>group A binary vector. This vector must be as long as the
number of subjects. Each vector element must be 1 for cases and 0
for control subjects.</p>
</td></tr>
<tr><td><code id="colorGraph_+3A_method">method</code></td>
<td>
<p>Multiple testing correction method. One of the values
available in <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>. By default, method is set
to &quot;none&quot; (i.e., no multiple test correction).</p>
</td></tr>
<tr><td><code id="colorGraph_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for node and edge coloring
(by default, <code>alpha = 0.05</code>).</p>
</td></tr>
<tr><td><code id="colorGraph_+3A_vcolor">vcolor</code></td>
<td>
<p>A vector of three color names. The first color is given
to nodes with P-value &lt; alpha and beta &lt; 0, the third color is given
to nodes with P-value &lt; alpha and beta &gt; 0, and the second is given
to nodes with P-value &gt; alpha. By default,
<code>vcolor = c("lightblue", "white", "pink")</code>.</p>
</td></tr>
<tr><td><code id="colorGraph_+3A_ecolor">ecolor</code></td>
<td>
<p>A vector of three color names. The first color is given
to edges with P-value &lt; alpha and regression coefficient &lt; 0, the
third color is given to edges with P-value &lt; alpha and regression
coefficient &gt; 0, and the second is given to edges with P-value &gt; alpha.
By default, <code>vcolor = c("blue", "gray50", "red2")</code>.</p>
</td></tr>
<tr><td><code id="colorGraph_+3A_ewidth">ewidth</code></td>
<td>
<p>A vector of two values. The first value refers to the
basic edge width (i.e., edges with P-value &gt; alpha), while the second
is given to edges with P-value &lt; alpha. By default ewidth = c(1, 2).</p>
</td></tr>
<tr><td><code id="colorGraph_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph object with vertex and edge color and width attributes.
</p>


<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Model fitting: node perturbation
sem1 &lt;- SEMrun(graph = alsData$graph, data = alsData$exprs,
               group = alsData$group,
               fit = 1)
est1 &lt;- parameterEstimates(sem1$fit)

# Model fitting: edge perturbation
sem2 &lt;- SEMrun(graph = alsData$graph, data = alsData$exprs,
               group = alsData$group,
               fit = 2)
est20 &lt;- subset(parameterEstimates(sem2$fit), group == 1)[, -c(4, 5)]
est21 &lt;- subset(parameterEstimates(sem2$fit), group == 2)[, -c(4, 5)]

# Graphs
g &lt;- alsData$graph
x &lt;- alsData$group

old.par &lt;- par(no.readonly = TRUE)
par(mfrow=c(2,2), mar=rep(1,4))
gplot(colorGraph(est = est1, g, group = x, method = "BH"),
      main = "vertex differences")
gplot(colorGraph(est = sem2$dest, g, group = NULL),
      main = "edge differences")
gplot(colorGraph(est = est20, g, group = NULL),
      main = "edges for group = 0")
gplot(colorGraph(est = est21, g, group = NULL),
      main = "edges for group = 1")
par(old.par)


</code></pre>

<hr>
<h2 id='cplot'>Subgraph mapping</h2><span id='topic+cplot'></span>

<h3>Description</h3>

<p>Map groups of nodes onto an input graph, based on a
membership vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cplot(graph, membership, l = layout.auto, map = FALSE, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cplot_+3A_graph">graph</code></td>
<td>
<p>An igraph object.</p>
</td></tr>
<tr><td><code id="cplot_+3A_membership">membership</code></td>
<td>
<p>Cluster membership vector for each node.</p>
</td></tr>
<tr><td><code id="cplot_+3A_l">l</code></td>
<td>
<p>graph layout. One of the <code>igraph</code> layouts.
If this argument is ignored, an automatic layout will be applied.</p>
</td></tr>
<tr><td><code id="cplot_+3A_map">map</code></td>
<td>
<p>A logical value. Visualize cluster mapping over the input
graph. If FALSE (default), visualization will be disabled. For large
graphs, visualization may take long.</p>
</td></tr>
<tr><td><code id="cplot_+3A_verbose">verbose</code></td>
<td>
<p>A logical value. If FALSE (default), the processed
graphs will not be plotted to screen, saving execution time (they will
be returned in output anyway).</p>
</td></tr>
<tr><td><code id="cplot_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list of clusters and cluster mapping as igraph objects.
</p>


<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clusterGraph">clusterGraph</a></code>,
<code><a href="#topic+clusterScore">clusterScore</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Clustering ALS graph with WTC method
G &lt;- alsData$graph
membership &lt;- clusterGraph(graph = G, type = "wtc")
cplot(G, membership, map = TRUE, verbose = FALSE)
cplot(G, membership, map = FALSE, verbose = TRUE)
# The list of cluster graphs !
cg &lt;- cplot(G, membership); cg


</code></pre>

<hr>
<h2 id='dagitty2graph'>Graph conversion from dagitty to igraph</h2><span id='topic+dagitty2graph'></span>

<h3>Description</h3>

<p>Convert a dagitty object to a igraph object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dagitty2graph(dagi, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dagitty2graph_+3A_dagi">dagi</code></td>
<td>
<p>A graph as a dagitty object (&quot;dag&quot; or &quot;pdag&quot;).</p>
</td></tr>
<tr><td><code id="dagitty2graph_+3A_verbose">verbose</code></td>
<td>
<p>A logical value. If TRUE, the output graph is shown.
This argument is FALSE by default.</p>
</td></tr>
<tr><td><code id="dagitty2graph_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph object.
</p>


<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Conversion from igraph to dagitty  (and viceversa)
dagi &lt;- graph2dagitty(sachs$graph, verbose = TRUE)
graph &lt;- dagitty2graph(dagi, verbose = TRUE)

</code></pre>

<hr>
<h2 id='extractClusters'>Cluster extraction utility</h2><span id='topic+extractClusters'></span>

<h3>Description</h3>

<p>Extract and fit clusters from an input graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractClusters(
  graph,
  data,
  group = NULL,
  membership = NULL,
  map = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractClusters_+3A_graph">graph</code></td>
<td>
<p>Input network as an igraph object.</p>
</td></tr>
<tr><td><code id="extractClusters_+3A_data">data</code></td>
<td>
<p>A matrix or data.frame. Rows correspond to subjects, and
columns to graph nodes (variables).</p>
</td></tr>
<tr><td><code id="extractClusters_+3A_group">group</code></td>
<td>
<p>A binary vector. This vector must be as long as the
number of subjects. Each vector element must be 1 for cases and 0
for control subjects. Group specification enables node perturbation
testing. By default, <code>group = NULL</code>.</p>
</td></tr>
<tr><td><code id="extractClusters_+3A_membership">membership</code></td>
<td>
<p>A vector of cluster membership IDs. If NULL, clusters
will be automatically generated with <code><a href="#topic+clusterGraph">clusterGraph</a></code>
using the edge betweenness clustering (&quot;ebc&quot;) algorithm.</p>
</td></tr>
<tr><td><code id="extractClusters_+3A_map">map</code></td>
<td>
<p>Logical value. If TRUE, the plot of the input graph
(coloured by cluster membership) will be generated along with independent
module plots. If the input graph is very large, plotting could be
computationally intensive (by default, <code>map = FALSE</code>).</p>
</td></tr>
<tr><td><code id="extractClusters_+3A_verbose">verbose</code></td>
<td>
<p>Logical value. If TRUE, a plot will be showed for each
cluster.</p>
</td></tr>
<tr><td><code id="extractClusters_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 3 objects:
</p>

<ol>
<li><p> &quot;clusters&quot;, list of clusters as igraph objects;
</p>
</li>
<li><p> &quot;fit&quot;, list of fitting results for each cluster as a lavaan object;
</p>
</li>
<li><p> &quot;dfc&quot;, data.frame of summary results.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Fernando Palluzzi <a href="mailto:fernando.palluzzi@gmail.com">fernando.palluzzi@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Nonparanormal(npn) transformation
als.npn &lt;- transformData(alsData$exprs)$data

adjdata &lt;- SEMbap(alsData$graph, als.npn)$data

# Clusters creation
clusters &lt;- extractClusters(alsData$graph, adjdata, alsData$group)
print(clusters$dfc)
head(parameterEstimates(clusters$fit$HM1))
head(parameterEstimates(clusters$fit$HM2))
head(parameterEstimates(clusters$fit$HM4))
gplot(clusters$clusters$HM2)

# Map cluster on the input graph
g &lt;- alsData$graph
c &lt;- clusters$clusters$HM2
V(g)$color &lt;- ifelse(V(g)$name %in% V(c)$name, "gold", "white")
gplot(g)


</code></pre>

<hr>
<h2 id='factor.analysis'>Factor analysis for high dimensional data</h2><span id='topic+factor.analysis'></span>

<h3>Description</h3>

<p>Wrapper for Factor Analysis with potentially high dimensional variables 
implement in the &quot;cate&quot; R package (Author: Jingshu Wang [aut], Qingyuan Zhao [aut, cre]
Maintainer: Qingyuan Zhao &lt;qz280@cam.ac.uk&gt;) that is optimized for the high dimensional
problem where the number of samples n is less than the number of variables p.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factor.analysis(Y, r = 1, method = "pc")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="factor.analysis_+3A_y">Y</code></td>
<td>
<p>data matrix, a n*p matrix</p>
</td></tr>
<tr><td><code id="factor.analysis_+3A_r">r</code></td>
<td>
<p>number of factors (default, r =1)</p>
</td></tr>
<tr><td><code id="factor.analysis_+3A_method">method</code></td>
<td>
<p>algorithm to be used, &quot;pc&quot; (default) or &quot;ml&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two methods extracted from &quot;cate&quot; are quasi-maximum likelihood (ml), and
principal component analysis (pc). The ml is iteratively solved the EM algorithm
using the PCA solution as the initial value. See Bai and Li (2012) for more details.
</p>


<h3>Value</h3>

<p>a list of objects
</p>

<dl>
<dt>Gamma</dt><dd><p>estimated factor loadings</p>
</dd>
<dt>Z</dt><dd><p>estimated latent factors</p>
</dd>
<dt>Sigma</dt><dd><p>estimated noise variance matrix</p>
</dd>
</dl>



<h3>References</h3>

<p>Jushan Bai and Kunpeng Li (2012). Statistical Analysis of Factor Models of High
Dimension. The Annals of Statistics, 40 (1), 436-465
&lt;https://doi.org/10.1214/11-AOS966&gt; 
</p>
<p>Jingshu Wang and Qingyuan Zhao (2020). cate: High Dimensional Factor Analysis
and Confounder Adjusted Testing and Estimation. R package version 1.1.1.
&lt;https://CRAN.R-project.org/package=cate&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Nonparanormal(npn) transformation
als.npn &lt;- transformData(alsData$exprs)$data

## pc
pc&lt;- factor.analysis(Y = als.npn, r = 2, method = "pc")
head(pc$Gamma)
head(pc$Z)
head(pc$Sigma)

## ml
ml &lt;- factor.analysis(Y = als.npn, r = 2, method = "ml")
head(ml$Gamma)
head(ml$Z)
head(ml$Sigma)

</code></pre>

<hr>
<h2 id='gplot'>Graph plotting with renderGraph</h2><span id='topic+gplot'></span>

<h3>Description</h3>

<p>Wrapper for function renderGraph of the R package
Rgraphwiz.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gplot(
  graph,
  l = "dot",
  main = "",
  cex.main = 1,
  font.main = 1,
  color.txt = "black",
  fontsize = 16,
  cex = 0.6,
  shape = "circle",
  color = "gray70",
  lty = 1,
  lwd = 1,
  w = "auto",
  h = "auto",
  psize = 80,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gplot_+3A_graph">graph</code></td>
<td>
<p>An igraph or graphNEL object.</p>
</td></tr>
<tr><td><code id="gplot_+3A_l">l</code></td>
<td>
<p>Any layout supported by <code>Rgraphviz</code>. It can be one among:
&quot;dot&quot; (default), &quot;neato&quot;, &quot;circo&quot;, &quot;fdp&quot;, &quot;osage&quot;, &quot;twopi&quot;.</p>
</td></tr>
<tr><td><code id="gplot_+3A_main">main</code></td>
<td>
<p>Plot main title (by default, no title is added).</p>
</td></tr>
<tr><td><code id="gplot_+3A_cex.main">cex.main</code></td>
<td>
<p>Main title size (default = 1).</p>
</td></tr>
<tr><td><code id="gplot_+3A_font.main">font.main</code></td>
<td>
<p>Main title font (default = 1). Available options
are: 1 for plain text, 2 for bold, 3 for italics, 4 for bold italics,
and 5 for symbol.</p>
</td></tr>
<tr><td><code id="gplot_+3A_color.txt">color.txt</code></td>
<td>
<p>Node text color (default = &quot;black&quot;).</p>
</td></tr>
<tr><td><code id="gplot_+3A_fontsize">fontsize</code></td>
<td>
<p>Node text size (default = 16).</p>
</td></tr>
<tr><td><code id="gplot_+3A_cex">cex</code></td>
<td>
<p>Another argument to control node text size (default = 0.6).</p>
</td></tr>
<tr><td><code id="gplot_+3A_shape">shape</code></td>
<td>
<p>Node shape (default = &quot;circle&quot;).</p>
</td></tr>
<tr><td><code id="gplot_+3A_color">color</code></td>
<td>
<p>Node border color (default = &quot;gray70&quot;).</p>
</td></tr>
<tr><td><code id="gplot_+3A_lty">lty</code></td>
<td>
<p>Node border outline (default = 1).
Available options include: 0 for blank, 1 for solid line, 2 for dashed,
3 for dotted, 4 for dotdash, 5 for longdash, and 6 for twodash.</p>
</td></tr>
<tr><td><code id="gplot_+3A_lwd">lwd</code></td>
<td>
<p>Node border thickness (default = 1).</p>
</td></tr>
<tr><td><code id="gplot_+3A_w">w</code></td>
<td>
<p>Manual node width (default = &quot;auto&quot;).</p>
</td></tr>
<tr><td><code id="gplot_+3A_h">h</code></td>
<td>
<p>Manual node height (default = &quot;auto&quot;).</p>
</td></tr>
<tr><td><code id="gplot_+3A_psize">psize</code></td>
<td>
<p>Automatic node size (default = 80).</p>
</td></tr>
<tr><td><code id="gplot_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>gplot returns invisibly the graph object produced by Rgraphviz
</p>


<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gplot(sachs$graph, main = "input graph")

sem &lt;- SEMrun(sachs$graph, sachs$pkc)
gplot(sem$graph, main = "output graph")

</code></pre>

<hr>
<h2 id='graph2dag'>Convert directed graphs to directed acyclic graphs (DAGs)</h2><span id='topic+graph2dag'></span>

<h3>Description</h3>

<p>Remove cycles and bidirected edges from a directed graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph2dag(graph, data, bap = FALSE, time.limit = Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph2dag_+3A_graph">graph</code></td>
<td>
<p>A directed graph as an igraph object.</p>
</td></tr>
<tr><td><code id="graph2dag_+3A_data">data</code></td>
<td>
<p>A data matrix with subjects as rows and variables as
columns.</p>
</td></tr>
<tr><td><code id="graph2dag_+3A_bap">bap</code></td>
<td>
<p>If TRUE, a bow-free acyclic path (BAP) is returned
(default = FALSE).</p>
</td></tr>
<tr><td><code id="graph2dag_+3A_time.limit">time.limit</code></td>
<td>
<p>CPU time for the computation, in seconds
(default = Inf).</p>
</td></tr>
<tr><td><code id="graph2dag_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conversion is performed firstly by removing bidirected
edges and then the data matrix is used to compute edge P-values, through
marginal correlation testing (see <code><a href="#topic+weightGraph">weightGraph</a></code>,
r-to-z method). When a cycle is detected, the edge with highest
P-value is removed, breaking the cycle. If the bap argument is TRUE,
a BAP is generated merging the output DAG and the bidirected edges
from the input graph.
</p>


<h3>Value</h3>

<p>A DAG as an igraph object.
</p>


<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dag &lt;- graph2dag(graph = sachs$graph, data = log(sachs$pkc))
old.par &lt;- par(no.readonly = TRUE)
par(mfrow=c(1,2), mar=rep(1, 4))
gplot(sachs$graph, main = "Input graph")
gplot(dag, main = "Output DAG")
par(old.par)

</code></pre>

<hr>
<h2 id='graph2dagitty'>Graph conversion from igraph to dagitty</h2><span id='topic+graph2dagitty'></span>

<h3>Description</h3>

<p>Convert an igraph object to a dagitty object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph2dagitty(graph, graphType = "dag", verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph2dagitty_+3A_graph">graph</code></td>
<td>
<p>A graph as an igraph or as an adjacency matrix.</p>
</td></tr>
<tr><td><code id="graph2dagitty_+3A_graphtype">graphType</code></td>
<td>
<p>character, is one of &quot;dag&quot; (default)' or &quot;pdag&quot;.
DAG can contain the directed (-&gt;) and bi-directed (&lt;-&gt;) edges,
while PDAG can contain the edges: -&gt;, &lt;-&gt;, and the undirected edges
(&ndash;) that represent edges whose direction is not known.</p>
</td></tr>
<tr><td><code id="graph2dagitty_+3A_verbose">verbose</code></td>
<td>
<p>A logical value. If TRUE, the output graph is shown.
This argument is FALSE by default.</p>
</td></tr>
<tr><td><code id="graph2dagitty_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dagitty object.
</p>


<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Graph as an igraph object to dagitty object
G &lt;- graph2dagitty(sachs$graph)
plot(dagitty::graphLayout(G))

</code></pre>

<hr>
<h2 id='graph2lavaan'>Graph to lavaan model</h2><span id='topic+graph2lavaan'></span>

<h3>Description</h3>

<p>Convert an igraph object to a model (lavaan syntax).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph2lavaan(graph, nodes = V(graph)$name, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph2lavaan_+3A_graph">graph</code></td>
<td>
<p>A graph as an igraph object.</p>
</td></tr>
<tr><td><code id="graph2lavaan_+3A_nodes">nodes</code></td>
<td>
<p>Subset of nodes to be included in the model. By default,
all the input graph nodes will be included in the output model.</p>
</td></tr>
<tr><td><code id="graph2lavaan_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A model in lavaan syntax.
</p>


<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Graph (igraph object) to structural model in lavaan syntax
model &lt;- graph2lavaan(sachs$graph)
cat(model, "\n")

</code></pre>

<hr>
<h2 id='kegg'>KEGG interactome</h2><span id='topic+kegg'></span>

<h3>Description</h3>

<p>Interactome generated by merging KEGG pathways 
extracted using the <code>ROntoTools</code> R package (update: Jan, 2025).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kegg
</code></pre>


<h3>Format</h3>

<p>&quot;kegg&quot; is an igraph network object of 4910 nodes and 45200 edges 
corresponding to the union of 231 KEGG pathways.
</p>


<h3>Source</h3>

<p><a href="https://www.genome.jp/kegg/">https://www.genome.jp/kegg/</a>
</p>


<h3>References</h3>

<p>Kanehisa M, Goto S (1999). KEGG: kyoto encyclopedia of genes and genomes. 
Nucleic Acid Research 28(1): 27-30. 
&lt;https://doi.org/10.1093/nar/27.1.29&gt;
</p>
<p>Calin Voichita, Sahar Ansari and Sorin Draghici (2023).
ROntoTools: R Onto-Tools suite. R package version 2.30.0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# KEGG graph
summary(kegg)

# KEGG degrees of freedom
vcount(kegg)*(vcount(kegg) - 1)/2 - ecount(kegg)

</code></pre>

<hr>
<h2 id='kegg.pathways'>KEGG pathways</h2><span id='topic+kegg.pathways'></span>

<h3>Description</h3>

<p>KEGG pathways extracted using the <code>ROntoTools</code>
R package (update: Jan, 2025).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kegg.pathways
</code></pre>


<h3>Format</h3>

<p>&quot;kegg.pathways&quot; is a list of 231 igraph objects corresponding to the
KEGG pathways.
</p>


<h3>Source</h3>

<p><a href="https://www.genome.jp/kegg/">https://www.genome.jp/kegg/</a>
</p>


<h3>References</h3>

<p>Kanehisa M, Goto S (1999). KEGG: kyoto encyclopedia of genes and genomes. 
Nucleic Acid Research 28(1): 27-30. 
&lt;https://doi.org/10.1093/nar/27.1.29&gt;
</p>
<p>Calin Voichita, Sahar Ansari and Sorin Draghici (2023).
ROntoTools: R Onto-Tools suite. R package version 2.30.0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(igraph)

# KEGG pathways
names(kegg.pathways)

i&lt;-which(names(kegg.pathways)=="Type II diabetes mellitus");i
ig&lt;- kegg.pathways[[i]]
summary(ig)
V(ig)$name
E(ig)$weight

gplot(ig, l="fdp", psize=50, main=names(kegg.pathways[i]))



</code></pre>

<hr>
<h2 id='lavaan2graph'>lavaan model to graph</h2><span id='topic+lavaan2graph'></span>

<h3>Description</h3>

<p>Convert a model, specified using lavaan syntax,
to an igraph object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavaan2graph(model, directed = TRUE, psi = TRUE, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lavaan2graph_+3A_model">model</code></td>
<td>
<p>Model specified using lavaan syntax.</p>
</td></tr>
<tr><td><code id="lavaan2graph_+3A_directed">directed</code></td>
<td>
<p>Logical value. If TRUE (default), edge directions from
the model will be preserved. If FALSE, the resulting graph will
be undirected.</p>
</td></tr>
<tr><td><code id="lavaan2graph_+3A_psi">psi</code></td>
<td>
<p>Logical value. If TRUE (default) covariances will be converted
into bidirected graph edges. If FALSE, covariances will be excluded from
the output graph.</p>
</td></tr>
<tr><td><code id="lavaan2graph_+3A_verbose">verbose</code></td>
<td>
<p>Logical value. If TRUE, a plot of the output graph will
be generated. For large graphs, this could significantly increase
computation time. If FALSE (default), graph plotting will be disabled.</p>
</td></tr>
<tr><td><code id="lavaan2graph_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph object.
</p>


<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Writing path diagram in lavaan syntax

model&lt;-"
#path model
Jnk ~ PKA + PKC
P38 ~ PKA + PKC
Akt ~ PKA + PIP3
Erk ~ PKA + Mek
Mek ~ PKA + PKC + Raf
Raf ~ PKA + PKC
PKC ~ PIP2 + Plcg
PIP2 ~ PIP3 + Plcg
Plcg ~ PIP3

#(co)variances
PKA ~~ PIP3
"

# Graph with covariances
G0 &lt;- lavaan2graph(model, psi = TRUE)
plot(G0, layout = layout.circle)

# Graph without covariances
G1 &lt;- lavaan2graph(model, psi = FALSE)
plot(G1, layout = layout.circle)

</code></pre>

<hr>
<h2 id='localCI.test'>Conditional Independence (CI) local tests of an acyclic graph</h2><span id='topic+localCI.test'></span>

<h3>Description</h3>

<p>P-values of one minimal testable implication (with the
smallest possible conditioning set) is returned per missing edge
given an acyclic graph (DAG or BAP) using the function
<code><a href="dagitty.html#topic+impliedConditionalIndependencies">impliedConditionalIndependencies</a></code> plus the
function <code><a href="dagitty.html#topic+localTests">localTests</a></code> from package <code>dagitty</code>.
Without assuming any particular dependence structure, the p-values of
every CI test, in a DAG (BAP), is then combined using the Bonferroni’s
statistic in an overall test of the fitted model, B = K*min(p1,...,pK),
as reviewed in Vovk &amp; Wang (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localCI.test(graph, data, bap = FALSE, limit = 100, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="localCI.test_+3A_graph">graph</code></td>
<td>
<p>A directed graph as an igraph object.</p>
</td></tr>
<tr><td><code id="localCI.test_+3A_data">data</code></td>
<td>
<p>A data matrix with subjects as rows and variables as
columns.</p>
</td></tr>
<tr><td><code id="localCI.test_+3A_bap">bap</code></td>
<td>
<p>If TRUE, the input graph is trasformend in a BAP, if FALSE
(defult) the input graph is reduced in a DAG.</p>
</td></tr>
<tr><td><code id="localCI.test_+3A_limit">limit</code></td>
<td>
<p>An integer value corresponding to the size of the
extracted acyclic graph. Beyond this limit, switch to Shipley's
C-test (Shipley 2000) is enabled to reduce the computational burden.
By default, <code>limit = 100</code>.</p>
</td></tr>
<tr><td><code id="localCI.test_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, LocalCI results will be showed to
screen (default = TRUE).</p>
</td></tr>
<tr><td><code id="localCI.test_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three objects: (i) &quot;dag&quot;: the DAG used to perform the localCI
test (ii) &quot;msep&quot;: the list of all m-separation tests over missing edges in the
input graph and (iii) &quot;mtest&quot;:the overall Bonferroni's P-value.
</p>


<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>References</h3>

<p>Vovk V, Wang R (2020). Combining p-values via averaging. Biometrika
107(4): 791-808. &lt;https://doi.org/10.1093/biomet/asaa027&gt;
</p>
<p>Shipley B (2000). A new inferential test for path models based on DAGs.
Structural Equation Modeling, 7(2): 206-218.
&lt;https://doi.org/10.1207/S15328007SEM0702_4&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Nonparanormal(npn) transformation
als.npn &lt;- transformData(alsData$exprs)$data

sem &lt;- SEMrun(alsData$graph, als.npn)
B_test &lt;- localCI.test(sem$graph, als.npn, verbose = TRUE)

</code></pre>

<hr>
<h2 id='mergeNodes'>Graph nodes merging by a membership attribute</h2><span id='topic+mergeNodes'></span>

<h3>Description</h3>

<p>Merge groups of graph nodes using hierarchical clustering
with prototypes derived from <code><a href="protoclust.html#topic+protoclust">protoclust</a></code> or 
custom membership attribute (e.g., cluster membership derived from
<code><a href="#topic+clusterGraph">clusterGraph</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeNodes(
  graph,
  data,
  h = 0.5,
  membership = NULL,
  HM = NULL,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mergeNodes_+3A_graph">graph</code></td>
<td>
<p>network as an igraph object.</p>
</td></tr>
<tr><td><code id="mergeNodes_+3A_data">data</code></td>
<td>
<p>A matrix or data.frame. Rows correspond to subjects, and
columns to graph nodes. If <code>membership</code> is not NULL, is currently
ignored, <code>data = NULL</code>.</p>
</td></tr>
<tr><td><code id="mergeNodes_+3A_h">h</code></td>
<td>
<p>Cutting the minimax clustering at height, h = 1 - abs(cor(j,k)),
yielding a merged node (and a reduced data set) in which every node in the
cluster has correlation of at least cor(j,k) with the prototype node.
By default, <code>h = 0.5</code>, i.e. cor(j,k) = 0.5.</p>
</td></tr>
<tr><td><code id="mergeNodes_+3A_membership">membership</code></td>
<td>
<p>Cluster membership. A vector of cluster membership
identifiers as numeric values, where vector names correspond to graph
node names. By default, <code>membership = NULL</code>.</p>
</td></tr>
<tr><td><code id="mergeNodes_+3A_hm">HM</code></td>
<td>
<p>Hidden cluster label. If membership is derived from clusterGraph:
HM = &quot;LV&quot;, a latent variable (LV) will be defined as common unknown cause
acting on cluster nodes. If HM = &quot;CV&quot;, cluster nodes will be considered as
regressors of a latent composite variable (CV). Finally, if HM = &quot;UV&quot;, an
unmeasured variable (UV) is defined, where source nodes of the module (i.e.,
in-degree = 0) act as common regressors influencing the other nodes
via an unmeasured variable. By default, <code>HM = NULL</code></p>
</td></tr>
<tr><td><code id="mergeNodes_+3A_verbose">verbose</code></td>
<td>
<p>A logical value. If FALSE (default), the merged graphs will
not be plotted to screen.</p>
</td></tr>
<tr><td><code id="mergeNodes_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hierarchical clustering with prototypes (or Minmax linkage) is
unique in naturally associating a node (the prototypes) with every
interior node of the dendogram. Thus, for each merge we have a single
representative data point for the resulting cluster (Bien, Tibshirani, 2011).
These prototypes can be used to greatly enhance the interpretability of
merging nodes and data reduction for SEM fitting.
</p>


<h3>Value</h3>

<p>A list of 2 objects is returned:
</p>

<ol>
<li><p> &quot;gLM&quot;, A graph with merged nodes as an igraph object;
</p>
</li>
<li><p> &quot;membership&quot;, cluster membership vector for each node.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>References</h3>

<p>Bien J, Tibshirani R (2011). Hierarchical Clustering With Prototypes via
Minimax Linkage. Journal of the American Statistical Association
106(495): 1075-1084. &lt;doi:10.1198/jasa.2011.tm10183&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clusterGraph">clusterGraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Gene memberships with prototypes with h=0.5
G &lt;- properties(alsData$graph)[[1]]
M &lt;- mergeNodes(G, data = alsData$exprs, h = 0.5, verbose=TRUE)

# Gene memberships with EBC method and size=10
m &lt;- clusterGraph(G, type = "ebc", size = 10)
M &lt;- mergeNodes(G, membership = m, HM = "LV", verbose=TRUE)

# Gene memberships defined by user
c1 &lt;- c("5894", "5576", "5567", "572", "598")
c2 &lt;- c("6788", "84152", "2915", "836", "5530")
c3 &lt;- c("5603", "6300", "1432", "5600")
m &lt;- c(rep(1,5), rep(2,5), rep(3,4))
names(m) &lt;- c(c1, c2, c3)
M &lt;- mergeNodes(G, membership = m, HM = "CV", verbose=TRUE)

</code></pre>

<hr>
<h2 id='modelSearch'>Optimal model search strategies</h2><span id='topic+modelSearch'></span>

<h3>Description</h3>

<p>Four model search strategies are implemented combining
<code>SEMdag()</code>, <code>SEMbap()</code>, and <code>resizeGraph()</code> functions.
All strategies estimate a new graph by 1) adjusting (BAP deconfounding) the
the data matrix and 2) re-sizing the output DAG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelSearch(
  graph,
  data,
  gnet = NULL,
  d = 2,
  search = "basic",
  beta = 0,
  method = "BH",
  alpha = 0.05,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelSearch_+3A_graph">graph</code></td>
<td>
<p>Input graph as an igraph object.</p>
</td></tr>
<tr><td><code id="modelSearch_+3A_data">data</code></td>
<td>
<p>A matrix or data.frame. Rows correspond to subjects, and
columns to graph nodes (variables).</p>
</td></tr>
<tr><td><code id="modelSearch_+3A_gnet">gnet</code></td>
<td>
<p>Reference directed network used to validate and import
nodes and interactions.</p>
</td></tr>
<tr><td><code id="modelSearch_+3A_d">d</code></td>
<td>
<p>Maximum allowed geodesic distance for directed or undirected
shortest path search. A distance <code>d = 0</code> disables shortest path
search (fixed in <code>search = "basic"</code>), while <code>d = 1</code> 
(fixed in <code>search = "direct"</code>) only search for directed links
(i.e., no mediators are allowed).
A distance <code>d</code> &gt; 1 (defaults to <code>d = 2</code> for &quot;outer&quot; and
&quot;inner&quot; strategies), will search for shortest paths with at most
<code>d</code> - 1 mediators between nodes sharing a significant estimated
interaction.
Connectors are imported from the reference interactome, as specified
by the argument <code>gnet</code>. If the edges of the reference interactome are
weighted by P-value, as defined by the <code>E(gnet)$pv</code> attribute,
the shortest path with the smallest sum of weights will be chosen (e.g.,
see <code><a href="#topic+weightGraph">weightGraph</a></code> for graph weighting options).</p>
</td></tr>
<tr><td><code id="modelSearch_+3A_search">search</code></td>
<td>
<p>Search strategy. Four model search strategies are available:
</p>

<ul>
<li><p> &quot;outer&quot;. The estimated DAG is re-sized using
<code><a href="#topic+resizeGraph">resizeGraph</a></code> to find new indirect paths (i.e.,
inferred directed connections that may hide new mediators). New
interactions and connectors will be searched and imported from the
reference network (argument <code>gnet</code>, see above). Both DAG and
extended graph complexity can be controlled with <code>beta</code> &gt; 0 and
<code>d</code> &gt; 1 arguments, respectively. The term &quot;outer&quot; means that new
model mediator variables are imported from an external resource (i.e.,
the reference network).
</p>
</li>
<li><p> &quot;inner&quot;. This strategy is analogous to the &quot;outer&quot; one,
but disables external mediator search. In other words, new indirect
paths are generated by adding new interactions of the input model, so
that mediators will be nodes already present in the input graph. The
reference network is still used to validate new model paths. Also in
this case, <code>beta</code> &gt; 0 and <code>d</code> &gt; 1 are used.
</p>
</li>
<li><p> &quot;direct&quot;. The input graph structure is improved through direct
(i.e., adjacent) link search, followed by interaction validation and
import from the reference network, with no mediators (i.e., <code>d = 1</code>).
</p>
</li>
<li><p> &quot;basic&quot; (default). While the previous strategies rely on the
input graph and the reference network to integrate knowledge to the
final model, the &quot;basic&quot; strategy is data-driven. The input graph is
needed to define the topological order. The argument <code>gnet</code> is
set to NULL (i.e., no reference network is needed) and argument
<code>d = 0</code>. Model complexity can be still controlled by setting
<code>beta</code> &gt; 0.
</p>
</li></ul>
</td></tr>
<tr><td><code id="modelSearch_+3A_beta">beta</code></td>
<td>
<p>Numeric value. Minimum absolute LASSO beta coefficient for
a new interaction to be retained in the estimated DAG backbone. Lower
<code>beta</code> values correspond to more complex DAGs.
By default, <code>beta</code> is set to 0 (i.e., maximum complexity).</p>
</td></tr>
<tr><td><code id="modelSearch_+3A_method">method</code></td>
<td>
<p>Multiple testing correction method. One of the values
available in <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>. By default, <code>method</code>
is set to &quot;BH&quot; (i.e., Benjamini-Hochberg multiple test correction).</p>
</td></tr>
<tr><td><code id="modelSearch_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for false discovery rate (FDR) used
for local d-separation tests. This argument is used to
control data de-correlation. A higher <code>alpha</code> level includes more
hidden covariances, thus considering more sources of confounding.
If <code>alpha = 0</code>, data de-correlation is disabled.
By default, <code>alpha = 0.05</code>.</p>
</td></tr>
<tr><td><code id="modelSearch_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, it shows intermediate graphs during the
execution (not recommended for large graphs).</p>
</td></tr>
<tr><td><code id="modelSearch_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Search strategies can be ordered by decreasing conservativeness
respect to the input graph, as: &quot;direct&quot;, &quot;inner&quot;, &quot;outer&quot;, and &quot;basic&quot;.
The first three strategies are knowledge-based, since they require an
input graph and a reference network, together with data, for
knowledge-assisted model improvement. The last one does not require
any reference and the output model structure will be data-driven.
Output model complexity can be limited using arguments <code>d</code> and
<code>beta</code>.
While d is fixed to 0 or 1 in &quot;basic&quot; or &quot;direct&quot;, respectively;
we suggest starting with <code>d = 2</code> (only one mediator)
for the other two strategies.
For knowledge-based strategies, we suggest to to start with
<code>beta = 0</code>. Then, beta can be relaxed (0 to &lt; 0.1) to improve
model fitting, if needed. Since data-driven models can be complex,
we suggest to start from <code>beta = 0</code> when using the &quot;basic&quot; strategy.
The <code>beta</code> value can be relaxed until a good model fit is obtained.
Argument alpha determines the extent of data adjustment: lower alpha
values for FDR correction correspond to a smaller number of significant
confounding factors, hence a weaker correction
(default <code>alpha = 0.05</code>).
</p>


<h3>Value</h3>

<p>The output model as well as the adjusted dataset are returned
as a list of 2 objects:
</p>

<ul>
<li><p> &quot;graph&quot;, the output model as an igraph object;
</p>
</li>
<li><p> &quot;data&quot;, the adjusted dataset.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Comparison among different model estimation strategies

# Nonparanormal(npn) transformation
als.npn &lt;- transformData(alsData$exprs)$data

# Models estimation
m1 &lt;- modelSearch(graph = alsData$graph, data = als.npn, gnet = kegg,
      search = "direct", beta = 0, alpha = 0.05)
m2 &lt;- modelSearch(graph = alsData$graph, data = als.npn, gnet = kegg,
      d = 2, search = "inner", beta = 0, alpha = 0.05)
m3 &lt;- modelSearch(graph = alsData$graph, data = als.npn, gnet = kegg,
      d = 2, search = "outer", beta = 0, alpha = 0.05)
m4 &lt;- modelSearch(graph = alsData$graph, data = als.npn, gnet = NULL,
      search = "basic", beta = 0.1, alpha = 0.05)

# Graphs
#old.par &lt;- par(no.readonly = TRUE)
#par(mfrow=c(2,2), mar= rep(1,4))
gplot(m1$graph, main = "direct graph")
gplot(m2$graph, main = "inner graph")
gplot(m3$graph, main = "outer graph")
gplot(m4$graph, main = "basic graph")
#par(old.par)


</code></pre>

<hr>
<h2 id='orientEdges'>Assign edge orientation of an undirected graph</h2><span id='topic+orientEdges'></span>

<h3>Description</h3>

<p>Assign edge orientation of an undirected graph
through a given reference directed graph. The vertex (color)
and edge (color, width and weight) attributes of the input
undirected graph are preserved in the output directed graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orientEdges(ug, dg, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orientEdges_+3A_ug">ug</code></td>
<td>
<p>An undirected graph as an igraph object.</p>
</td></tr>
<tr><td><code id="orientEdges_+3A_dg">dg</code></td>
<td>
<p>A directed reference graph.</p>
</td></tr>
<tr><td><code id="orientEdges_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A directed graph as an igraph object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Graphs definition
G0 &lt;- as.undirected(sachs$graph)

# Reference graph-based orientation
G1 &lt;- orientEdges(ug = G0, dg = sachs$graph)

# Graphs plotting
old.par &lt;- par(no.readonly = TRUE)
par(mfrow=c(1,2), mar=rep(2,4))
plot(G0, layout=layout.circle, main = "Input undirected graph")
plot(G1, layout=layout.circle, main = "Output directed graph")
par(old.par)

</code></pre>

<hr>
<h2 id='pairwiseMatrix'>Pairwise plotting of multivariate data</h2><span id='topic+pairwiseMatrix'></span>

<h3>Description</h3>

<p>Display a pairwise scatter plot of two datasets for a
random selection of variables. If the second dataset is not given,
the function displays a histogram with normal curve superposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwiseMatrix(x, y = NULL, size = nrow(x), r = 4, c = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairwiseMatrix_+3A_x">x</code></td>
<td>
<p>A matrix or data.frame (n x p) of continuous data.</p>
</td></tr>
<tr><td><code id="pairwiseMatrix_+3A_y">y</code></td>
<td>
<p>A matrix or data.frame (n x q) of continuous data.</p>
</td></tr>
<tr><td><code id="pairwiseMatrix_+3A_size">size</code></td>
<td>
<p>number of rows to be sampled (default <code>size = nrow(x)</code>).</p>
</td></tr>
<tr><td><code id="pairwiseMatrix_+3A_r">r</code></td>
<td>
<p>number of rows of the plot layout (default <code>r = 4</code>).</p>
</td></tr>
<tr><td><code id="pairwiseMatrix_+3A_c">c</code></td>
<td>
<p>number of columns of the plot layout (default <code>c = 4</code>).</p>
</td></tr>
<tr><td><code id="pairwiseMatrix_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>


<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adjdata &lt;- SEMbap(sachs$graph, log(sachs$pkc))$data
rawdata &lt;- log(sachs$pkc)
pairwiseMatrix(adjdata, rawdata, size = 1000)

</code></pre>

<hr>
<h2 id='parameterEstimates'>Parameter Estimates of a fitted SEM</h2><span id='topic+parameterEstimates'></span>

<h3>Description</h3>

<p>Wrapper of the lavaan parameterEstimates() function
for RICF and CGGM algorithms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameterEstimates(fit, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parameterEstimates_+3A_fit">fit</code></td>
<td>
<p>A RICF or constrained GGM fitted model object.</p>
</td></tr>
<tr><td><code id="parameterEstimates_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing the estimated parameters
</p>


<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ricf1 &lt;- SEMrun(sachs$graph, log(sachs$pkc), sachs$group, algo = "ricf")
parameterEstimates(ricf1$fit)

cggm1 &lt;- SEMrun(sachs$graph, log(sachs$pkc), sachs$group, algo = "cggm")
parameterEstimates(cggm1$fit)

</code></pre>

<hr>
<h2 id='pathFinder'>Perturbed path search utility</h2><span id='topic+pathFinder'></span>

<h3>Description</h3>

<p>This function uses <code><a href="#topic+SEMace">SEMace</a></code> to find
significant causal effects between source-sink pairs and
<code><a href="#topic+SEMpath">SEMpath</a></code> to fit them and test their edge
perturbation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pathFinder(
  graph,
  data,
  group = NULL,
  ace = NULL,
  path = "directed",
  method = "BH",
  alpha = 0.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pathFinder_+3A_graph">graph</code></td>
<td>
<p>Input network as an igraph object.</p>
</td></tr>
<tr><td><code id="pathFinder_+3A_data">data</code></td>
<td>
<p>A matrix or data.frame. Rows correspond to subjects, and
columns to graph nodes (variables).</p>
</td></tr>
<tr><td><code id="pathFinder_+3A_group">group</code></td>
<td>
<p>group A binary vector. This vector must be as long as the
number of subjects. Each vector element must be 1 for cases and 0
for control subjects. Group specification enables edge perturbation
testing. By default, <code>group = NULL</code>.</p>
</td></tr>
<tr><td><code id="pathFinder_+3A_ace">ace</code></td>
<td>
<p>A data.frame generated by <code><a href="#topic+SEMace">SEMace</a></code>.
If NULL, <code><a href="#topic+SEMace">SEMace</a></code> will be automatically run.</p>
</td></tr>
<tr><td><code id="pathFinder_+3A_path">path</code></td>
<td>
<p>If <code>path = "directed"</code>, all directed paths between
the two nodes will be included in the fitted model.
If <code>path = "shortest"</code>, only shortest paths will be considered.</p>
</td></tr>
<tr><td><code id="pathFinder_+3A_method">method</code></td>
<td>
<p>Multiple testing correction method. One of the values
available in <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.
By default, <code>method = "BH"</code> (i.e., FDR multiple test correction).</p>
</td></tr>
<tr><td><code id="pathFinder_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for ACE selection (by default,
<code>alpha = 0.05</code>).</p>
</td></tr>
<tr><td><code id="pathFinder_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 3 objects:
</p>

<ul>
<li><p> &quot;paths&quot;, list of paths as igraph objects;
</p>
</li>
<li><p> &quot;fit&quot;, fitting results for each path as a lavaan object;
</p>
</li>
<li><p> &quot;dfp&quot;, a data.frame containing SEM global fitting statistics.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Fernando Palluzzi <a href="mailto:fernando.palluzzi@gmail.com">fernando.palluzzi@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Find and evaluate significantly perturbed paths

# Nonparanormal(npn) transformation
als.npn &lt;- transformData(alsData$exprs)$data

adjData &lt;- SEMbap(alsData$graph, als.npn)$data

paths &lt;- pathFinder(alsData$graph, adjData,
                    group = alsData$group,
                    ace = NULL)

print(paths$dfp)
head(parameterEstimates(paths$fit[[1]]))
gplot(paths$paths[[1]])


</code></pre>

<hr>
<h2 id='properties'>Graph properties summary and graph decomposition</h2><span id='topic+properties'></span>

<h3>Description</h3>

<p>Produces a summary of network properties and returns
graph components (ordered by decreasing size), without self-loops.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>properties(graph, data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="properties_+3A_graph">graph</code></td>
<td>
<p>Input network as an igraph object.</p>
</td></tr>
<tr><td><code id="properties_+3A_data">data</code></td>
<td>
<p>An optional data matrix (default data = NULL) whith rows
corresponding to subjects, and columns to graph nodes (variables).
Nodes will be mapped onto variable names.</p>
</td></tr>
<tr><td><code id="properties_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of graph components, ordered by decreasing size (the first
component is the giant one), without self-loops.
</p>


<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Extract the "Type II diabetes mellitus" pathway:
g &lt;- kegg.pathways[["Type II diabetes mellitus"]]
summary(g)
properties(g)

</code></pre>

<hr>
<h2 id='resizeGraph'>Interactome-assisted graph re-seizing</h2><span id='topic+resizeGraph'></span>

<h3>Description</h3>

<p>An input directed graph is re-sized, removing edges
or adding edges/nodes. This function takes three input graphs: the
first is the input causal model (i.e., a directed graph), and the
second can be either a directed or undirected graph, providing a set
of connections to be checked against a directed reference network
(i.e., the third input) and imported to the first graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resizeGraph(g = list(), gnet, d = 2, v = TRUE, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resizeGraph_+3A_g">g</code></td>
<td>
<p>A list of two graphs as igraph objects, g=list(graph1, graph2).</p>
</td></tr>
<tr><td><code id="resizeGraph_+3A_gnet">gnet</code></td>
<td>
<p>External directed network as an igraph object. The reference
network should have weighted edges, corresponding to their interaction
p-values, as an edge attribute <code>E(gnet)$pv</code>. Then, connections in
<code>graph2</code> will be checked by known connections from the reference network,
intercepted by the minimum-weighted shortest path found among the equivalent
ones by the Dijkstra algorithm, as implemented in the <span class="pkg">igraph</span> function
<code>all_shortest_paths()</code>.</p>
</td></tr>
<tr><td><code id="resizeGraph_+3A_d">d</code></td>
<td>
<p>An integer value indicating the maximum geodesic distance between
two nodes in the interactome to consider the inferred interaction between
the same two nodes in <code>graph2</code> as validated, otherwise the edges are
removed. For instance, if <code>d = 2</code>, two interacting nodes must either
share a direct interaction or being connected through at most one mediator
in the reference interactome (in general, at most <code>d - 1</code> mediators are
allowed). Typical <code>d</code> values include <code>2</code> (at most one mediator), or
<code>mean_distance(gnet)</code> (i.e., the average shortest path length for
the reference network). Setting d = 0, is equivalent to <code>gnet = NULL</code>.</p>
</td></tr>
<tr><td><code id="resizeGraph_+3A_v">v</code></td>
<td>
<p>A logical value. If TRUE (default) new nodes and edges on the
validated shortest path in the reference interactome will be added in the
re-sized graph.</p>
</td></tr>
<tr><td><code id="resizeGraph_+3A_verbose">verbose</code></td>
<td>
<p>A logical value. If FALSE (default), the processed graphs
will not be plotted to screen, saving execution time (for large graphs)</p>
</td></tr>
<tr><td><code id="resizeGraph_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typically, the first graph is an estimated causal graph (DAG),
and the second graph is the output of either <code><a href="#topic+SEMdag">SEMdag</a></code>
or <code><a href="#topic+SEMbap">SEMbap</a></code>. Alternatively, the first graph is an
empthy graph, and the second graph is a external covariance graph.
In the former we use the new inferred causal structure stored in the
<code>dag.new</code> object. In the latter, we use the new inferred covariance
structure stored in the <code>guu</code> object. Both directed (causal) edges
inferred by <code>SEMdag()</code> and covariances (i.e., bidirected edges)
added by <code>SEMbap()</code>, highlight emergent hidden topological
proprieties, absent in the input graph. Estimated directed edges between
nodes X and Y are interpreted as either direct links or direct paths
mediated by hidden connector nodes. Covariances between any two bow-free
nodes X and Y may hide causal relationships, not explicitly represented
in the current model. Conversely, directed edges could be redundant or
artifact, specific to the observed data and could be deleted.
Function <code>resizeGraph()</code> leverage on these concepts to extend/reduce a
causal model, importing new connectors or deleting estimated edges, if they are
present or absent in a given reference network. The whole process may lead to
the discovery of new paths of information flow, and cut edges not corroborate
by a validated network. Since added nodes can already be present in the causal
graph, network resize may create cross-connections between old and new paths
and their possible closure into circuits.
</p>


<h3>Value</h3>

<p>&quot;Ug&quot;, the re-sized graph, the graph union of the causal graph <code>graph1</code>
and the re-sized graph <code>graph2</code>
</p>


<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>References</h3>

<p>Grassi M, Palluzzi F, Tarantino B (2022). SEMgraph: An R Package for Causal Network
Analysis of High-Throughput Data with Structural Equation Models.
Bioinformatics, 38 (20), 4829–4830 &lt;https://doi.org/10.1093/bioinformatics/btac567&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Extract the "Protein processing in endoplasmic reticulum" pathway:

g &lt;- kegg.pathways[["Protein processing in endoplasmic reticulum"]]
G &lt;- properties(g)[[1]]; summary(G)

# Extend a graph using new inferred DAG edges (dag+dag.new):

# Nonparanormal(npn) transformation
als.npn &lt;- transformData(alsData$exprs)$data

dag &lt;- SEMdag(graph = G, data = als.npn, beta = 0.1)
gplot(dag$dag)
ext &lt;- resizeGraph(g=list(dag$dag, dag$dag.new), gnet = kegg, d = 2)
gplot(ext) 

# Create a directed graph from correlation matrix, using
# i) an empty graph as causal graph,
# ii) a covariance graph,
# iii) KEGG as reference:

corr2graph&lt;- function(R, n, alpha=5e-6, ...)
{
	Z &lt;- qnorm(alpha/2, lower.tail=FALSE)
thr &lt;- (exp(2*Z/sqrt(n-3))-1)/(exp(2*Z/sqrt(n-3))+1)
	A &lt;- ifelse(abs(R) &gt; thr, 1, 0)
	diag(A) &lt;- 0
	return(graph_from_adjacency_matrix(A, mode="undirected"))
}

v &lt;- which(colnames(als.npn) %in% V(G)$name)
selectedData &lt;- als.npn[, v]
G0 &lt;- make_empty_graph(n = ncol(selectedData))
V(G0)$name &lt;- colnames(selectedData)
G1 &lt;- corr2graph(R = cor(selectedData), n= nrow(selectedData))
ext &lt;- resizeGraph(g=list(G0, G1), gnet = kegg, d = 2, v = TRUE)

#Graphs
old.par &lt;- par(no.readonly = TRUE)
par(mfrow=c(1,2), mar=rep(1,4))
plot(G1, layout = layout.circle)
plot(ext, layout = layout.circle)
par(old.par)


</code></pre>

<hr>
<h2 id='sachs'>Sachs multiparameter flow cytometry data and consensus model</h2><span id='topic+sachs'></span>

<h3>Description</h3>

<p>Flow cytometry data and causal model from Sachs et al. (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sachs
</code></pre>


<h3>Format</h3>

<p>&quot;sachs&quot; is a list of 5 objects:
</p>

<ol>
<li><p> &quot;rawdata&quot;, a list of 14 data.frames containing raw flow cytometry
data (Sachs et al., 2005);
</p>
</li>
<li><p> &quot;graph&quot;, consensus signaling network;
</p>
</li>
<li><p> &quot;model&quot;, consensus model (lavaan syntax);
</p>
</li>
<li><p> &quot;pkc&quot;, data.frame of 1766 samples and 11 variables, containing
cd3cd28 (baseline) and pma (PKC activation) data;
</p>
</li>
<li><p> &quot;group&quot;, a binary group vector, where 0 is for cd3cd28 samples
(n = 853) and 1 is for pma samples (n = 913).
</p>
</li>
<li><p> &quot;details&quot;, a data.frame containing dataset information.
</p>
</li></ol>



<h3>Source</h3>

<p><a href="https://doi.org/10.1126/science.1105809">doi:10.1126/science.1105809</a>
</p>


<h3>References</h3>

<p>Sachs K, Perez O, Pe'er D, Lauffenburger DA, Nolan GP (2019).
Causal Protein-Signaling Networks Derived from Multiparameter
Single-Cell Data. Science, 308(5721): 523-529.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Dataset content
names(sachs$rawdata)
dim(sachs$pkc)
table(sachs$group)
cat(sachs$model)
gplot(sachs$graph)

</code></pre>

<hr>
<h2 id='SEMace'>Compute the Average Causal Effect (ACE) for a given source-sink pair</h2><span id='topic+SEMace'></span>

<h3>Description</h3>

<p>Compute total effects as ACEs of variables X
on variables Y in a directed acyclic graph (DAG). The ACE will be estimated
as the path coefficient of X (i.e., theta) in the linear equation
Y ~ X + Z. The set Z is defined as the adjustment (or conditioning) set of
Y over X, applying various adjustement sets. Standard errors (SE),
for each ACE, are computed following the <code>lm</code> standard procedure
or a bootstrap-based procedure (see <code><a href="boot.html#topic+boot">boot</a></code> for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEMace(
  graph,
  data,
  group = NULL,
  type = "parents",
  effect = "all",
  method = "BH",
  alpha = 0.05,
  boot = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SEMace_+3A_graph">graph</code></td>
<td>
<p>An igraph object.</p>
</td></tr>
<tr><td><code id="SEMace_+3A_data">data</code></td>
<td>
<p>A matrix or data.frame. Rows correspond to subjects, and
columns to graph nodes (variables).</p>
</td></tr>
<tr><td><code id="SEMace_+3A_group">group</code></td>
<td>
<p>A binary vector. This vector must be as long as the
number of subjects. Each vector element must be 1 for cases and 0
for control subjects. If <code>group = NULL</code> (default), group influence
will not be considered.</p>
</td></tr>
<tr><td><code id="SEMace_+3A_type">type</code></td>
<td>
<p>character Conditioning set Z. If &quot;parents&quot; (default) the
Pearl's back-door set (Pearl, 1998), &quot;minimal&quot; the dagitty minimal set
(Perkovic et al, 2018), or &quot;optimal&quot; the O-set with the smallest
asymptotic variance (Witte et al, 2020) are computed.</p>
</td></tr>
<tr><td><code id="SEMace_+3A_effect">effect</code></td>
<td>
<p>character X to Y effect. If &quot;all&quot; (default) all effects from
X to Y, &quot;source2sink&quot; only effects from source X to sink Y, or &quot;direct&quot;
only direct effects from X to Y are computed.</p>
</td></tr>
<tr><td><code id="SEMace_+3A_method">method</code></td>
<td>
<p>Multiple testing correction method. One of the values
available in <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.
By default, <code>method = "BH"</code> (i.e., FDR multiple test correction).</p>
</td></tr>
<tr><td><code id="SEMace_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for ACE selection (by default,
<code>alpha = 0.05</code>).</p>
</td></tr>
<tr><td><code id="SEMace_+3A_boot">boot</code></td>
<td>
<p>The number of bootstrap samplings enabling bootstrap
computation of ACE standard errors. If <code>NULL</code> (default), bootstrap
is disabled.</p>
</td></tr>
<tr><td><code id="SEMace_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame of ACE estimates between network sources and sinks.
</p>


<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>References</h3>

<p>Pearl J (1998). Graphs, Causality, and Structural Equation Models.
Sociological Methods &amp; Research, 27(2):226-284.
&lt;https://doi.org/10.1177/0049124198027002004&gt;
</p>
<p>Perkovic E, Textor J, Kalisch M, Maathuis MH (2018). Complete graphical
characterization and construction of adjustment sets in Markov equivalence
classes of ancestral graphs. Journal of Machine Learning Research, 18:1-62.
&lt;http://jmlr.org/papers/v18/16-319.html&gt;
</p>
<p>Witte J, Henckel L, Maathuis MH, Didelez V (2020). On efficient
adjustment in causal graphs. Journal of Machine Learning Research, 21:1-45.
&lt;http://jmlr.org/papers/v21/20-175.htm&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ACE without group, O-set, all effects:
ace1 &lt;- SEMace(graph = sachs$graph, data = log(sachs$pkc),
               group = NULL, type = "optimal", effect = "all",
               method = "BH", alpha = 0.05, boot = NULL)
print(ace1)

# ACE with group perturbation, Pa-set, direct effects:
ace2 &lt;- SEMace(graph = sachs$graph, data = log(sachs$pkc),
               group = sachs$group, type = "parents", effect = "direct",
               method = "none", alpha = 0.05, boot = NULL)
print(ace2)

</code></pre>

<hr>
<h2 id='SEMbap'>Bow-free covariance search and data de-correlation</h2><span id='topic+SEMbap'></span>

<h3>Description</h3>

<p><code>SEMbap()</code> function implements different deconfounding
methods to adjust the data matrix by removing latent sources of confounding
encoded in them. The selected methods are either based on: (i) Bow-free
Acyclic Paths (BAP) search, (ii) LVs proxies as additional source nodes of
the data matrix, Y or (iii) spectral transformation of Y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEMbap(
  graph,
  data,
  group = NULL,
  dalgo = "cggm",
  method = "BH",
  alpha = 0.05,
  hcount = "auto",
  cmax = Inf,
  limit = 200,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SEMbap_+3A_graph">graph</code></td>
<td>
<p>An igraph object.</p>
</td></tr>
<tr><td><code id="SEMbap_+3A_data">data</code></td>
<td>
<p>A matrix whith rows corresponding to subjects, and columns to
graph nodes (variables).</p>
</td></tr>
<tr><td><code id="SEMbap_+3A_group">group</code></td>
<td>
<p>A binary vector. This vector must be as long as the
number of subjects. Each vector element must be 1 for cases and 0
for control subjects. If <code>NULL</code> (default), confouding within group
will not be considered.</p>
</td></tr>
<tr><td><code id="SEMbap_+3A_dalgo">dalgo</code></td>
<td>
<p>Deconfounding method. Four algorithms are available: 
</p>

<ul>
<li><p> &quot;cggm&quot; (default). The algorithm make: (i) exhaustive search
of bow-free significant covariances (see details) through  
<code><a href="#topic+Shipley.test">Shipley.test</a></code> function; (ii) estimation of the inverse
of the selected covariance matrix (i.e. the precision matrix, W) through
<code><a href="ggm.html#topic+fitConGraph">fitConGraph</a></code> function; (iii) obtain the de-correlated data
matrix, Z by multiplying the data matrix, Y rightward by the square root of
the estimated precision matrix, Z=YW^(1/2) as suggested by Grassi, Palluzzi
and Tarantino (2022).
</p>
</li>
<li><p> &quot;glpc&quot;. The algorithm first makes an exhaustive search of bow-free
significant covariances through <code><a href="#topic+Shipley.test">Shipley.test</a></code> function.
Once obtained the adjacency matrix, Graph-Laplacian PCA (gLPCA) algorithm
(Jiang et al., 2013) learns a low dimensional representation of the observed
data matrix that incorporates bow-free structure. Then, the DAG is extended
by including the confounding proxies, i.e. LVs, as additional source nodes
defined by last q principal component scores of gLPCA and these LV scores are
added to the data matrix, Z=cbind(LV,Y).
</p>
</li>
<li><p> &quot;pc&quot;. The procedure add additional source nodes to DAG as in &quot;glpc&quot;
algorithm, but confounding proxies are the q principal component scores
extracted by Spectral decomposition (SVD) selecting only graph nodes and
without graph edge information and bow-free covariance search.
</p>
</li>
<li><p> &quot;trim&quot;. Ćevid et al. (2020) suggest multiplying the data
matrix, Y leftward by a well selected spectrum transformation matrix, T
which modifies the singular values of Y, while keeping its singular vectors
intact, Z=TY. Trim transform limits all singular values to be at most some
costant (t), where t = median of the singuar values.
</p>
</li></ul>
</td></tr>
<tr><td><code id="SEMbap_+3A_method">method</code></td>
<td>
<p>Multiple testing correction method. One of the values
available in <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>. By default, <code>method</code>
is set to &quot;BH&quot; (i.e., Benjamini-Hochberg multiple test correction).</p>
</td></tr>
<tr><td><code id="SEMbap_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for false discovery rate (FDR) used
for d-separation test. This argument is used to
control data de-correlation. A higher <code>alpha</code> level includes more
hidden covariances, thus considering more sources of confounding.
If <code>alpha = 0</code>, data de-correlation is disabled. By default,
<code>alpha = 0.05</code>.</p>
</td></tr>
<tr><td><code id="SEMbap_+3A_hcount">hcount</code></td>
<td>
<p>The number of latent (or hidden) variables. By default
<code>hcount="auto"</code>, the hidden count is determined with a
permutation method (see details). Currently ignored if (dalgo =&quot;cggm&quot;
or &quot;trim&quot;).</p>
</td></tr>
<tr><td><code id="SEMbap_+3A_cmax">cmax</code></td>
<td>
<p>Maximum number of parents set, C. This parameter can be
used to perform only those tests where the number of conditioning
variables does not exceed the given value. High-dimensional conditional
independence tests can be very unreliable. By default, cmax = Inf.</p>
</td></tr>
<tr><td><code id="SEMbap_+3A_limit">limit</code></td>
<td>
<p>An integer value corresponding to the graph size (vcount)
tolerance. Beyond this limit, the precision matrix is estimated by
&quot;glasso&quot; algorithm (FHT, 2008) to reduce the computational burden of the
exaustive BAP search of the <code><a href="#topic+Shipley.test">Shipley.test</a></code> procedure.
By default, <code>limit = 200</code>.</p>
</td></tr>
<tr><td><code id="SEMbap_+3A_verbose">verbose</code></td>
<td>
<p>A logical value. If FALSE (default), the processed graphs
will not be plotted to screen.</p>
</td></tr>
<tr><td><code id="SEMbap_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing edges in causal network inference using a directed acyclic
graph (DAG) are frequently hidden by unmeasured confounding variables.
A Bow-free Acyclic Paths (BAP) search is performed with d-separation tests
between all pairs of variables with missing connection in the input DAG,
adding a bidirected edge (i.e., bow-free covariance) to the DAG when there
is an association between them. The d-separation test evaluates if two
variables (Y1, Y2) in a DAG are conditionally independent for a given
conditioning set, C represented in a DAG by the union of the parent sets
of Y1 and Y2 (Shipley, 2000).
A new bow-free covariance is added if there is a significant (Y1, Y2)
association at a significance level <code>alpha</code>, after multiple testing
correction. The selected covariance between pairs of nodes is interpreted
as the effect of a latent variable (LV) acting on both nodes; i.e., the LV
is an unobserved confounder. BAP-based algorithms adjust (or de-correlate)
the observed data matrix by conditioning out the latent triggers responsible
for the nuisance edges.
For &quot;pc&quot; algorithm the number of hidden proxies, q is determined by a permutation
method. It compares the singular values to what they would be if the variables
were independent, which is estimated by permuting the columns of the data matrix,
Y and selects components if their singular values are larger than those of the
permuted data (for a review see Dobriban, 2020).
While for &quot;glpc&quot; algorithm, q is determined by the number of clusters by
spectral clustering through <code><a href="igraph.html#topic+cluster_leading_eigen">cluster_leading_eigen</a></code> function.
If the input graph is not acyclic, a warning message will be raised, and a
cycle-breaking algorithm will be applied (see <code><a href="#topic+graph2dag">graph2dag</a></code>
for details).
</p>


<h3>Value</h3>

<p>A list of four objects:
</p>

<ul>
<li><p> &quot;dag&quot;, the directed acyclic graph (DAG) extracted from input graph.
If (dalgo = &quot;glpc&quot; or &quot;pc&quot;), the DAG also includes LVs as source nodes.
</p>
</li>
<li><p> &quot;guu&quot;, the bow-free covariance graph, BAP = dag + guu. If (dalgo =
&quot;pc&quot; or &quot;trim&quot;), guu is equal to NULL
</p>
</li>
<li><p> &quot;adj&quot;, the adjacency matrix of selected bow-free covariances; i.e, the 
missing edges selected after multiple testing correction. If (dalgo = &quot;pc&quot;
or &quot;trim&quot;), adj matrix is equal to NULL.
</p>
</li>
<li><p> &quot;data&quot;, the adjusted (de-correlated) data matrix or if (dalgo = &quot;glpc&quot;,
or &quot;pc&quot;), the combined data matrix, where the first columns represent LVs
scores and the other columns are the raw data.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>References</h3>

<p>Grassi M, Palluzzi F, Tarantino B (2022). SEMgraph: An R Package for Causal Network
Analysis of High-Throughput Data with Structural Equation Models.
Bioinformatics, 38(20), 4829–4830.
&lt;https://doi.org/10.1093/bioinformatics/btac567&gt;
</p>
<p>Shipley B (2000). A new inferential test for path models based on DAGs.
Structural Equation Modeling, 7(2), 206-218.
&lt;https://doi.org/10.1207/S15328007SEM0702_4&gt;
</p>
<p>Jiang B, Ding C, Bin L, Tang J (2013). Graph-Laplacian PCA: 
Closed-Form Solution and Robustness. IEEE Conference on Computer
Vision and Pattern Recognition, 3492-3498. 
&lt;https://doi.org/10.1109/CVPR.2013.448&gt;
</p>
<p>Ćevid D,  Bühlmann P, Meinshausen N (2020). Spectral deconfounding via
perturbed sparse linear models. J. Mach. Learn. Res, 21(232), 1-41.
&lt;http://jmlr.org/papers/v21/19-545.html&gt;
</p>
<p>Dobriban E (2020). Permuatation methods for Factor Analysis and PCA.
Ann. Statist. 48(5): 2824-2847
&lt;https://doi.org/10.1214/19-AOS1907&gt;
</p>
<p>Friedman J, Hastie T, Tibshirani R (2008). Sparse inverse covariance
estimation with the graphical lasso. Biostatistics, 9(3), 432-441.
&lt;https://doi.org/10.1093/biostatistics/kxm045&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Set function param
graph &lt;- sachs$graph
data &lt;- log(sachs$pkc)
group &lt;-sachs$group

# BAP decounfounding with CGGM (default)
bap &lt;- SEMbap(graph, data, verbose = TRUE)

# SVD decounfounding with trim method
svd &lt;- SEMbap(graph, data, dalgo = "trim")

# Model fitting (with node-perturbation)
sem1 &lt;- SEMrun(graph, data, group)
bap1 &lt;- SEMrun(bap$dag, bap$data, group)
svd1 &lt;- SEMrun(svd$dag, svd$data, group)

</code></pre>

<hr>
<h2 id='SEMdag'>Estimate a DAG from an input (or empty) graph</h2><span id='topic+SEMdag'></span>

<h3>Description</h3>

<p>Two-step extraction of the optimal DAG from an input (or empty)
graph, using in step 1) graph topological order or bottom-up search order,
and in step 2) parent recovery with the LASSO-based algorithm (FHT, 2010),
implemented in <code><a href="glmnet.html#topic+glmnet">glmnet</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEMdag(
  graph,
  data,
  LO = "TO",
  beta = 0,
  eta = 0,
  lambdas = NA,
  penalty = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SEMdag_+3A_graph">graph</code></td>
<td>
<p>An igraph object or a graph with no edges (make_empty_graph(n=0)).</p>
</td></tr>
<tr><td><code id="SEMdag_+3A_data">data</code></td>
<td>
<p>A matrix whith n rows corresponding to subjects, and p columns
to graph nodes (variables).</p>
</td></tr>
<tr><td><code id="SEMdag_+3A_lo">LO</code></td>
<td>
<p>character for linear order method. If LO=&quot;TO&quot; or LO=&quot;TL&quot; the
topological order (resp. level) of the input graph is enabled, while LO=&quot;BU&quot;
the data-driven bottom-up search of vertex (resp. layer) order is performed
using the vertices of the empty graph. By default <code>LO = "TO"</code>.</p>
</td></tr>
<tr><td><code id="SEMdag_+3A_beta">beta</code></td>
<td>
<p>Numeric value. Minimum absolute LASSO beta coefficient for
a new direct link to be retained in the final model. By default,
<code>beta = 0</code>.</p>
</td></tr>
<tr><td><code id="SEMdag_+3A_eta">eta</code></td>
<td>
<p>Numeric value. Minimum fixed eta threshold for bottom-up search
of vertex (eta = 0) or layer (eta &gt; 0) ordering. Use eta = NULL, for estimation
of eta adaptively with half of the sample data. By default, <code>eta = 0</code>.</p>
</td></tr>
<tr><td><code id="SEMdag_+3A_lambdas">lambdas</code></td>
<td>
<p>A vector of regularization LASSO lambda values. If lambdas is
NULL, the <code><a href="glmnet.html#topic+glmnet">glmnet</a></code> default using cross-validation lambdas
is enabled. If lambdas is NA (default), the tuning-free scheme is enabled by
fixing lambdas = sqrt(log(p)/n), as suggested by Janková and van de Geer
(2015) and many others. This will both reduce computational time and provide
the same result at each run.</p>
</td></tr>
<tr><td><code id="SEMdag_+3A_penalty">penalty</code></td>
<td>
<p>A logical value. Separate penalty factors can be applied to
each coefficient. This is a number that multiplies lambda to allow differential
shrinkage. Can be 0 for some variables, which implies no shrinkage, and that
variable is always included in the model. If TRUE (default) weights are based
on the graph edges: 0 (i.e., edge present) and 1 (i.e., missing edge) ensures
that the input edges will be retained in the final model. If FALSE the
<code><a href="glmnet.html#topic+glmnet">glmnet</a></code> default is enabled (all weights equal to 1). Note:
the penalty factors are internally rescaled to sum p (the number of variables).</p>
</td></tr>
<tr><td><code id="SEMdag_+3A_verbose">verbose</code></td>
<td>
<p>A logical value. If FALSE (default), the processed graphs
will not be plotted to screen.</p>
</td></tr>
<tr><td><code id="SEMdag_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The extracted DAG is estimated using the two-step order search approach.
First a vertex (node) or level (layer) order of p nodes is determined, and from
this sort, the DAG can be learned using in step 2) penalized (L1) regressions
(Shojaie and Michailidis, 2010). The estimate linear order are obtained from
<em>a priori</em> graph topological vertex (TO) or level (TL) ordering, or with a
data-driven Bottom-up (BU) approach, assuming a SEM whose error terms have equal
variances (Peters and Bühlmann, 2014). The BU algorithm first estimates the last
element (the terminal vertex) using the diagonal entries of the inverse covariance
matrix with: t = argmin(diag(Omega)), or the terminal layer (&gt; 1 vertices) with
d = diag(Omega)- t &lt; eta. And then, it determines its parents with L1 regression.
After eliminating the last element (or layer) of the ordering, the algorithm applies
the same procedure until a DAG is completely estimated. In high-dimensional data 
(n &lt; p), the inverse covariance matrix is computed by glasso-based algorithm
(FHT, 2008), implemented in <code><a href="glasso.html#topic+glasso">glasso</a></code>. If the input graph is
not acyclic, in TO or TL, a warning message will be raised, and a cycle-breaking
algorithm will be applied (see <code><a href="#topic+graph2dag">graph2dag</a></code> for details).
Output DAG will be colored: vertices in cyan, if they are source nodes, and in
orange, if they are sink nodes, and edges in gray, if they were present in the
input graph, and in green, if they are new edges generated by LASSO screening.
</p>


<h3>Value</h3>

<p>A list of 3 igraph objects plus the vertex ordering:
</p>

<ol>
<li><p> &quot;dag&quot;, the estimated DAG;
</p>
</li>
<li><p> &quot;dag.new&quot;, new estimated connections;
</p>
</li>
<li><p> &quot;dag.old&quot;, connections preserved from the input graph;
</p>
</li>
<li><p> &quot;LO&quot;, the estimated vertex ordering.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>References</h3>

<p>Friedman J, Hastie T, Tibshirani R (2008). Sparse inverse covariance
estimation with the graphical lasso. Biostatistics, 9(3), 432-441.
&lt;https://doi.org/10.1093/biostatistics/kxm045&gt;
</p>
<p>Friedman J, Hastie T, Tibshirani R (2010). Regularization Paths for
Generalized Linear Models via Coordinate Descent.
Journal of Statistical Software, Vol. 33(1), 1-22.
&lt;https://doi.org/10.18637/jss.v033.i01&gt;
</p>
<p>Shojaie A, Michailidis G (2010). Penalized likelihood methods for
estimation of sparse high-dimensional directed acyclic graphs.
Biometrika, 97(3): 519-538. &lt;https://doi.org/10.1093/biomet/asq038&gt;
</p>
<p>Jankova J, van de Geer S (2015). Confidence intervals for high-dimensional
inverse covariance estimation. Electronic Journal of Statistics,
9(1): 1205-1229. &lt;https://doi.org/10.1214/15-EJS1031&gt;
</p>
<p>Peters J, Bühlmann P (2014). Identifiability of Gaussian structural equation
models with equal error variances. Biometrika, 101(1):219–228.
&lt;https://doi.org/10.1093/biomet/ast043&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelSearch">modelSearch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Set function param
ig &lt;- sachs$graph
X &lt;- log(sachs$pkc)
group &lt;- sachs$group

# DAG estimation (default values)
dag0 &lt;- SEMdag(ig, X)
sem0 &lt;- SEMrun(ig, X, group)

# Graphs
old.par &lt;- par(no.readonly = TRUE)
par(mfrow=c(2,2), mar=rep(1,4))
plot(sachs$graph, layout=layout.circle, main="input graph")
plot(dag0$dag, layout=layout.circle, main = "Output DAG")
plot(dag0$dag.old, layout=layout.circle, main = "Inferred old edges")
plot(dag0$dag.new, layout=layout.circle, main = "Inferred new edges")
par(old.par)

# Four DAG estimation
dag1 &lt;- SEMdag(ig, X, LO="TO")
dag2 &lt;- SEMdag(ig, X, LO="TL")
dag3 &lt;- SEMdag(ig, X, LO="BU", eta=0)
dag4 &lt;- SEMdag(ig, X, LO="BU", eta=NULL)

unlist(dag1$LO)
dag2$LO
unlist(dag3$LO)
dag4$LO

# Graphs
old.par &lt;- par(no.readonly = TRUE)
par(mfrow=c(2,2), mar=rep(2,4))
gplot(dag1$dag, main="TO")
gplot(dag2$dag, main="TL")
gplot(dag3$dag, main="BU")
gplot(dag4$dag, main="TLBU")
par(old.par)

</code></pre>

<hr>
<h2 id='SEMdci'>SEM-based differential network analysis</h2><span id='topic+SEMdci'></span>

<h3>Description</h3>

<p>Creates a sub-network with perturbed edges obtained from the
output of <code><a href="#topic+SEMace">SEMace</a></code>, comparable to the procedure in
Jablonski et al (2022), or of <code><a href="#topic+SEMrun">SEMrun</a></code> with two-group
and CGGM solver, comparable to the algorithm 2 in Belyaeva et al (2021). 
To increase the efficiency of computations for large graphs, users can
select to break the network structure into clusters, and select the
topological clustering method (see <code><a href="#topic+clusterGraph">clusterGraph</a></code>).
The function <code><a href="#topic+SEMrun">SEMrun</a></code> is applied iteratively on
each cluster (with size min &gt; 10 and max &lt; 500) to obtain the graph
with the full list of perturbed edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEMdci(graph, data, group, type = "ace", method = "BH", alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SEMdci_+3A_graph">graph</code></td>
<td>
<p>Input network as an igraph object.</p>
</td></tr>
<tr><td><code id="SEMdci_+3A_data">data</code></td>
<td>
<p>A matrix or data.frame. Rows correspond to subjects, and
columns to graph nodes (variables).</p>
</td></tr>
<tr><td><code id="SEMdci_+3A_group">group</code></td>
<td>
<p>A binary vector. This vector must be as long as the number
of subjects. Each vector element must be 1 for cases and 0 for control
subjects.</p>
</td></tr>
<tr><td><code id="SEMdci_+3A_type">type</code></td>
<td>
<p>Average Causal Effect (ACE) with two-group, &quot;parents&quot;
(back-door) adjustement set, and &quot;direct&quot; effects (<code>type = "ace"</code>,
default), or CGGM solver with two-group using a clustering method.
If <code>type = "tahc"</code>, network modules are generated using the tree
agglomerative hierarchical clustering method, or non-tree clustering
methods from igraph package, i.e., <code>type = "wtc"</code> (walktrap community
structure with short random walks), <code>type ="ebc"</code> (edge betweeness
clustering), <code>type = "fgc"</code> (fast greedy method), <code>type = "lbc"</code>
(label propagation method), <code>type = "lec"</code> (leading eigenvector method),
<code>type = "loc"</code> (multi-level optimization), <code>type = "opc"</code> (optimal
community structure), <code>type = "sgc"</code> (spinglass statistical mechanics),
<code>type = "none"</code> (no breaking network structure into clusters).</p>
</td></tr>
<tr><td><code id="SEMdci_+3A_method">method</code></td>
<td>
<p>Multiple testing correction method. One of the values
available in <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>. By default, method is set
to &quot;BH&quot; (i.e., FDR multiple test correction).</p>
</td></tr>
<tr><td><code id="SEMdci_+3A_alpha">alpha</code></td>
<td>
<p>Significance level (default = 0.05) for edge set selection.</p>
</td></tr>
<tr><td><code id="SEMdci_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph object.
</p>


<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>References</h3>

<p>Belyaeva A, Squires C, Uhler C (2021). DCI: learning causal differences
between gene regulatory networks. Bioinformatics, 37(18): 3067–3069.
&lt;https://doi: 10.1093/bioinformatics/btab167&gt;
</p>
<p>Jablonski K, Pirkl M, Ćevid D, Bühlmann P, Beerenwinkel N (2022).
Identifying cancer pathway dysregulations using differential
causal effects. Bioinformatics, 38(6):1550–1559.
&lt;https://doi.org/10.1093/bioinformatics/btab847&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

#load SEMdata package for ALS data with 17K genes:
#devtools::install_github("fernandoPalluzzi/SEMdata")
#library(SEMdata)

# Nonparanormal(npn) transformation
library(huge)
data.npn&lt;- huge.npn(alsData$exprs)
dim(data.npn) #160 17695

# Extract KEGG interactome (max component)
KEGG&lt;- properties(kegg)[[1]]
summary(KEGG)

# KEGG modules with ALS perturbed edges using fast gready clustering
gD&lt;- SEMdci(KEGG, data.npn, alsData$group, type="fgc")
summary(gD)
gcD&lt;- properties(gD)

old.par &lt;- par(no.readonly = TRUE)
par(mfrow=c(2,2), mar=rep(2,4))
gplot(gcD[[1]], l="fdp", main="max component")
gplot(gcD[[2]], l="fdp", main="2nd component")
gplot(gcD[[3]], l="fdp", main="3rd component")
gplot(gcD[[4]], l="fdp", main="4th component")
par(old.par)


## End(Not run)

</code></pre>

<hr>
<h2 id='SEMgsa'>SEM-based gene set analysis</h2><span id='topic+SEMgsa'></span>

<h3>Description</h3>

<p>Gene Set Analysis (GSA) via self-contained test for group
effect on signaling (directed) pathways based on SEM. The core of the
methodology is implemented in the RICF algorithm of <code>SEMrun()</code>,
recovering from RICF output node-specific group effect p-values, and
Brown’s combined permutation p-values of node activation and inhibition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEMgsa(g = list(), data, group, method = "BH", alpha = 0.05, n_rep = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SEMgsa_+3A_g">g</code></td>
<td>
<p>A list of pathways to be tested.</p>
</td></tr>
<tr><td><code id="SEMgsa_+3A_data">data</code></td>
<td>
<p>A matrix or data.frame. Rows correspond to subjects, and
columns to graph nodes (variables).</p>
</td></tr>
<tr><td><code id="SEMgsa_+3A_group">group</code></td>
<td>
<p>A binary vector. This vector must be as long as the number
of subjects. Each vector element must be 1 for cases and 0 for control
subjects.</p>
</td></tr>
<tr><td><code id="SEMgsa_+3A_method">method</code></td>
<td>
<p>Multiple testing correction method. One of the values
available in <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>. By default, method is set
to &quot;BH&quot; (i.e., Benjamini-Hochberg correction).</p>
</td></tr>
<tr><td><code id="SEMgsa_+3A_alpha">alpha</code></td>
<td>
<p>Gene set test significance level (default = 0.05).</p>
</td></tr>
<tr><td><code id="SEMgsa_+3A_n_rep">n_rep</code></td>
<td>
<p>Number of randomization replicates (default = 1000).</p>
</td></tr>
<tr><td><code id="SEMgsa_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For gaining more biological insights into the functional roles
of pre-defined subsets of genes, node perturbation obtained from RICF
fitting has been combined with up- or down-regulation of genes from KEGG
to obtain overall pathway perturbation as follows: 
</p>

<ul>
<li><p> The node perturbation is defined as activated when the minimum among
the p-values is positive; if negative, the status is inhibited. 
</p>
</li>
<li><p> Up- or down- regulation of genes (derived from KEGG database) has
been obtained from the weighted adjacency matrix of each pathway as column
sum of weights over each source node. If the overall sum of node weights
is below 1, the pathway is flagged as down-regulated otherwise as up-regulated. 
</p>
</li>
<li><p> The combination between these two quantities allows to define the
direction (up or down) of gene perturbation. Up- or down regulated gene status,
associated with node inhibition, indicates a decrease in activation (or
increase in inhibition) in cases with respect to control group. Conversely,
up- or down regulated gene status, associated with node activation, indicates
an increase in activation (or decrease in inhibition) in cases with
respect to control group.
</p>
</li></ul>



<h3>Value</h3>

<p>A list of 2 objects:
</p>

<ol>
<li><p> &quot;gsa&quot;, A data.frame reporting the following information for each
pathway in the input list:
</p>

<ul>
<li><p> &quot;No.nodes&quot;, pathway size (number of nodes);
</p>
</li>
<li><p> &quot;No.DEGs&quot;, number of differential espression genes (DEGs) within
the pathway, after multiple test correction with one of the methods
available in <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>;
</p>
</li>
<li><p> &quot;pert&quot;, pathway perturbation status (see details);
</p>
</li>
<li><p> &quot;pNA&quot;, Brown's combined P-value of pathway node activation;
</p>
</li>
<li><p> &quot;pNI&quot;, Brown's combined P-value of pathway node inhibition;
</p>
</li>
<li><p> &quot;PVAL&quot;, Bonferroni combined P-value of pNA, and pNI; i.e.,
2* min(pNA, PNI);
</p>
</li>
<li><p> &quot;ADJP&quot;, Adjusted Bonferroni P-value of pathway perturbation; i.e.,
min(No.pathways * PVAL; 1).
</p>
</li></ul>

</li>
<li><p> &quot;DEG&quot;, a list with DEGs names per pathways.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>References</h3>

<p>Grassi, M., Tarantino, B. SEMgsa: topology-based pathway enrichment analysis with
structural equation models. BMC Bioinformatics 23, 344 (2022).
https://doi.org/10.1186/s12859-022-04884-8
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# Nonparanormal(npn) transformation
als.npn &lt;- transformData(alsData$exprs)$data

# Selection of FTD-ALS pathways from kegg.pathways.Rdata

paths.name &lt;- c("MAPK signaling pathway",
                "Protein processing in endoplasmic reticulum",
                "Endocytosis",
                "Wnt signaling pathway",
                "Neurotrophin signaling pathway",
                "Amyotrophic lateral sclerosis")

j &lt;- which(names(kegg.pathways) %in% paths.name)

GSA &lt;- SEMgsa(kegg.pathways[j], als.npn, alsData$group,
              method = "bonferroni", alpha = 0.05,
              n_rep = 1000)
GSA$gsa
GSA$DEG


## End(Not run)

</code></pre>

<hr>
<h2 id='SEMpath'>Search for directed or shortest paths between pairs of source-sink nodes</h2><span id='topic+SEMpath'></span>

<h3>Description</h3>

<p>Find and fit all directed or shortest paths between two
source-sink nodes of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEMpath(graph, data, group, from, to, path, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SEMpath_+3A_graph">graph</code></td>
<td>
<p>An igraph object.</p>
</td></tr>
<tr><td><code id="SEMpath_+3A_data">data</code></td>
<td>
<p>A matrix or data.frame. Rows correspond to subjects, and
columns to graph nodes (variables).</p>
</td></tr>
<tr><td><code id="SEMpath_+3A_group">group</code></td>
<td>
<p>A binary vector. This vector must be as long as the
number of subjects. Each vector element must be 1 for cases and 0
for control subjects. If <code>NULL</code> (default), group influence will
not be considered.</p>
</td></tr>
<tr><td><code id="SEMpath_+3A_from">from</code></td>
<td>
<p>Starting node name (i.e., source node).</p>
</td></tr>
<tr><td><code id="SEMpath_+3A_to">to</code></td>
<td>
<p>Ending node name (i.e., sink node).</p>
</td></tr>
<tr><td><code id="SEMpath_+3A_path">path</code></td>
<td>
<p>If <code>path = "directed"</code>, all directed paths between
the two nodes will be included in the fitted model.
If <code>path = "shortest"</code>, only shortest paths will be returned.</p>
</td></tr>
<tr><td><code id="SEMpath_+3A_verbose">verbose</code></td>
<td>
<p>Show the directed (or shortest) path between the
given source-sink pair inside the input graph.</p>
</td></tr>
<tr><td><code id="SEMpath_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of four objects: a fitted model object of class
<code><a href="lavaan.html#topic+lavaan">lavaan</a></code> (&quot;fit&quot;), aggregated and node-specific
group effect estimates and P-values (&quot;gest&quot;), the extracted subnetwork
as an igraph object (&quot;graph&quot;), and the input graph with a color
attribute mapping the chosen path (&quot;map&quot;).
</p>


<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Directed path fitting
path &lt;- SEMpath(graph = sachs$graph, data = log(sachs$pkc),
                group = sachs$group,
                from = "PIP3",
                to = "Erk",
                path = "directed")

# Summaries
summary(path$fit)
print(path$gest)

# Graphs
gplot(path$map, main="path from PiP2 to Erk")
plot(path$map, layout=layout.circle, main="path from PiP2 to Erk")

</code></pre>

<hr>
<h2 id='SEMrun'>Fit a graph as a Structural Equation Model (SEM)</h2><span id='topic+SEMrun'></span>

<h3>Description</h3>

<p><code>SEMrun()</code> converts a (directed, undirected, or mixed)
graph to a SEM and fits it. If a binary group variable (i.e., case/control)
is present, node-level or edge-level perturbation is evaluated.
This function can handle loop-containing models, although multiple
links between the same two nodes (including self-loops and mutual
interactions) and bows (i.e., a directed and a bidirected link between
two nodes) are not allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEMrun(
  graph,
  data,
  group = NULL,
  fit = 0,
  algo = "lavaan",
  start = NULL,
  SE = "standard",
  n_rep = 1000,
  limit = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SEMrun_+3A_graph">graph</code></td>
<td>
<p>An igraph object.</p>
</td></tr>
<tr><td><code id="SEMrun_+3A_data">data</code></td>
<td>
<p>A matrix whith rows corresponding to subjects, and
columns to graph nodes (variables).</p>
</td></tr>
<tr><td><code id="SEMrun_+3A_group">group</code></td>
<td>
<p>A binary vector. This vector must be as long as the
number of subjects. Each vector element must be 1 for cases and 0
for control subjects. If <code>NULL</code> (default), group influence will
not be considered.</p>
</td></tr>
<tr><td><code id="SEMrun_+3A_fit">fit</code></td>
<td>
<p>A numeric value indicating the SEM fitting mode.
If <code>fit = 0</code> (default), no group effect is considered.
If <code>fit = 1</code>, a &quot;common&quot; model is used to evaluate group effects
on graph nodes.
If <code>fit = 2</code>, a two-group model is used to evaluate group effects
on graph edges.</p>
</td></tr>
<tr><td><code id="SEMrun_+3A_algo">algo</code></td>
<td>
<p>MLE method used for SEM fitting. If <code>algo = "lavaan"</code>
(default), the SEM will be fitted using the NLMINB solver from
<code>lavaan</code> R package, with standard errors derived from the expected
Fisher information matrix. If <code>algo = "ricf"</code>, the model is fitted
via residual iterative conditional fitting (RICF; Drton et al. 2009),
with standard error derived from randomization or bootstrap procedures.
If <code>algo = "cggm"</code>, model fitting is based on constrained Gaussian
Graphical Modeling (CGGM), with DAG nodewise Lasso procedure and
de-biasing asymptotic inference (Jankova &amp; Van De Geer, 2019).</p>
</td></tr>
<tr><td><code id="SEMrun_+3A_start">start</code></td>
<td>
<p>Starting value of SEM parameters for <code>algo = "lavaan"</code>.
If start is <code>NULL</code> (default), the algorithm will determine the
starting values. If start is a numeric value, it will be used as a
scaling factor for the edge weights in the graph object (graph attribute
<code>E(graph)$weight</code>).
For instance, a scaling factor is useful when weights have fixed values
(e.g., 1 for activated, -1 for repressed, and 0 for unchanged interaction).
Fixed values may compromise model fitting, and scaling them is a safe
option to avoid this problem. As a rule of thumb, to our experience,
<code>start = 0.1</code> generally performs well with (-1, 0, 1) weights.</p>
</td></tr>
<tr><td><code id="SEMrun_+3A_se">SE</code></td>
<td>
<p>If &quot;standard&quot; (default), with <code>algo = "lavaan"</code>,
conventional standard errors are computed based on inverting the observed
information matrix. If &quot;none&quot;, no standard errors are computed.</p>
</td></tr>
<tr><td><code id="SEMrun_+3A_n_rep">n_rep</code></td>
<td>
<p>Number of randomization replicates (default = 1000),
for permutation flip or boostrap samples, if <code>algo = "ricf"</code>.</p>
</td></tr>
<tr><td><code id="SEMrun_+3A_limit">limit</code></td>
<td>
<p>An integer value corresponding to the network size
(i.e., number of nodes). Beyond this limit, the execution under
<code>algo = "lavaan"</code> will run with <code>SE = "none"</code>, if 
<code>fit = 0</code>, or will be ridirected to <code>algo = "ricf"</code>, if
<code>fit = 1</code>, or to <code>algo = "cggm"</code>, if <code>fit = 2</code>.
This redirection is necessary to reduce the computational demand of
standard error estimation by lavaan. Increasing this number will
enforce lavaan execution when <code>algo = "lavaan"</code>.</p>
</td></tr>
<tr><td><code id="SEMrun_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>SEMrun maps data onto the input graph and converts it into a
SEM. Directed connections (X -&gt; Y) are interpreted as direct causal
effects, while undirected, mutual, and bidirected connections are
converted into model covariances. SEMrun output contains different sets
of parameter estimates. Beta coefficients (i.e., direct effects) are
estimated from directed interactions and residual covariances (psi
coefficients) from bidirected, undirected, or mutual interactions.
If a group variable is given, exogenous group effects on nodes (gamma
coefficients) or edges (delta coefficients) will be estimated.
By default, maximum likelihood parameter estimates and P-values for
parameter sets are computed by conventional z-test (= estimate/SE),
and fits it through the <code><a href="lavaan.html#topic+lavaan">lavaan</a></code> function, via
Maximum Likelihood Estimation (estimator = &quot;ML&quot;, default estimator in
<code><a href="lavaan.html#topic+lavOptions">lavOptions</a></code>).
In case of high dimensionality (n.variables &gt;&gt; n.subjects), the covariance
matrix could not be semi-definite positive and thus parameter estimates
could not be done. If this happens, covariance matrix regularization
is enabled using the James-Stein-type shrinkage estimator implemented
in the function <code><a href="corpcor.html#topic+pcor.shrink">pcor.shrink</a></code> of corpcor R package.
Argument <code>fit</code> determines how group influence is evaluated in the
model, as absent (<code>fit = 0</code>), node perturbation (<code>fit = 1</code>),
or edge perturbation (<code>fit = 2</code>). When <code>fit = 1</code>, the group
is modeled as an exogenous variable, influencing all the other graph
nodes. When <code>fit = 2</code>, SEMrun estimates the differences
of the beta and/or psi coefficients (network edges) between groups.
This is equivalent to fit a separate model for cases and controls,
as opposed to one common model perturbed by the exogenous group effect.
Once fitted, the two models are then compared to assess significant
edge (i.e., direct effect) differences (d = beta1 - beta0).
P-values for parameter sets are computed by z-test (= d/SE), through
<code><a href="lavaan.html#topic+lavaan">lavaan</a></code>. As an alternative to standard P-value
calculation, SEMrun may use either RICF (randomization or bootstrap
P-values) or GGM (de-biased asymptotically normal P-values) methods.
These algorithms are much faster than <code><a href="lavaan.html#topic+lavaan">lavaan</a></code>
in case of large input graphs.
</p>


<h3>Value</h3>

<p>A list of 5 objects:
</p>

<ol>
<li><p> &quot;fit&quot;, SEM fitted lavaan, ricf, or cggm object,
depending on the MLE method specified by the <code>algo</code> argument;
</p>
</li>
<li><p> &quot;gest&quot; or &quot;dest&quot;, a data.frame of node-specific
(&quot;gest&quot;) or edge-specific (&quot;dest&quot;) group effect estimates and P-values;
</p>
</li>
<li><p> &quot;model&quot;, SEM model as a string if <code>algo = "lavaan"</code>,
and <code>NULL</code> otherwise;
</p>
</li>
<li><p> &quot;graph&quot;, the induced subgraph of the input network mapped
on data variables. Graph edges (i.e., direct effects) with P-value &lt; 0.05
will be highlighted in red (beta &gt; 0) or blue (beta &lt; 0). If a group
vector is given, nodes with significant group effect (P-value &lt; 0.05)
will be red-shaded (beta &gt; 0) or lightblue-shaded (beta &lt; 0);
</p>
</li>
<li><p> &quot;data&quot;, input data subset mapping graph nodes, plus
group at the first column (if no group is specified, this column will
take NA values).
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>References</h3>

<p>Pearl J (1998). Graphs, Causality, and Structural Equation Models.
Sociological Methods &amp; Research., 27(2):226-284.
&lt;https://doi.org/10.1177/0049124198027002004&gt;
</p>
<p>Yves Rosseel (2012). lavaan: An R Package for Structural Equation
Modeling. Journal of Statistical Software, 48(2): 1-36.
&lt;https://www.jstatsoft.org/v48/i02/&gt;
</p>
<p>Pepe D, Grassi M (2014). Investigating perturbed pathway modules
from gene expression data via Structural Equation Models. BMC
Bioinformatics, 15: 132.
&lt;https://doi.org/10.1186/1471-2105-15-132&gt;
</p>
<p>Drton M, Eichler M, Richardson TS (2009). Computing Maximum Likelihood
Estimated in Recursive Linear Models with Correlated Errors.
Journal of Machine Learning Research, 10(Oct): 2329-2348.
&lt;https://www.jmlr.org/papers/volume10/drton09a/drton09a.pdf&gt;
</p>
<p>Jankova, J., &amp; Van De Geer, S (2019). Inference in high-dimensional
graphical models. In Handbook of Graphical Models (2019).
Chapter 14 (sec. 14.2): 325-349. Chapman &amp; Hall/CRC. ISBN: 9780429463976
</p>
<p>Hastie T, Tibshirani R, Friedman J. (2009). The Elements of Statistical
Learning (2nd ed.). Springer Verlag. ISBN: 978-0-387-84858-7
</p>
<p>Grassi M, Palluzzi F, Tarantino B (2022). SEMgraph: An R Package for Causal Network
Analysis of High-Throughput Data with Structural Equation Models.
Bioinformatics, 38 (20), 4829–4830 &lt;https://doi.org/10.1093/bioinformatics/btac567&gt;
</p>


<h3>See Also</h3>

<p>See <code><a href="ggm.html#topic+fitAncestralGraph">fitAncestralGraph</a></code> and <code><a href="ggm.html#topic+fitConGraph">fitConGraph</a></code>
for RICF algorithm and constrained GGM algorithm details, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### Model fitting (no group effect)

sem0 &lt;- SEMrun(graph = sachs$graph, data = log(sachs$pkc))
summary(sem0$fit)
head(parameterEstimates(sem0$fit))

# Graphs
gplot(sem0$graph, main = "significant edge weights")
plot(sem0$graph, layout = layout.circle, main = "significant edge weights")


#### Model fitting (common model, group effect on nodes)

sem1 &lt;- SEMrun(graph = sachs$graph, data = log(sachs$pkc),
               group = sachs$group)

# Fitting summaries
summary(sem1$fit)
print(sem1$gest)
head(parameterEstimates(sem1$fit))

# Graphs
gplot(sem1$graph, main = "Between group node differences")
plot(sem1$graph, layout = layout.circle, main = "Between group node differences")


#### Two-group model fitting (group effect on edges)

sem2 &lt;- SEMrun(graph = sachs$graph, data = log(sachs$pkc),
               group = sachs$group,
               fit = 2)

# Summaries
summary(sem2$fit)
print(sem2$dest)
head(parameterEstimates(sem2$fit))

# Graphs
gplot(sem2$graph, main = "Between group edge differences")
plot(sem2$graph, layout = layout.circle, main = "Between group edge differences")


# Fitting and visualization of a large pathway:

g &lt;- kegg.pathways[["Neurotrophin signaling pathway"]]
G &lt;- properties(g)[[1]]
summary(G)

# Nonparanormal(npn) transformation
als.npn &lt;- transformData(alsData$exprs)$data

g1 &lt;- SEMrun(G, als.npn, alsData$group, algo = "cggm")$graph
g2 &lt;- SEMrun(g1, als.npn, alsData$group, fit = 2, algo = "cggm")$graph

# extract the subgraph with node and edge differences
g2 &lt;- g2 - E(g2)[-which(E(g2)$color != "gray50")]
g &lt;- properties(g2)[[1]]

# plot graph
E(g)$color&lt;- E(g2)$color[E(g2) %in% E(g)]
gplot(g, l="fdp", psize=40, main="node and edge group differences")


</code></pre>

<hr>
<h2 id='SEMtree'>Tree-based structure learning methods</h2><span id='topic+SEMtree'></span>

<h3>Description</h3>

<p>Four tree-based structure learning methods are implemented
with graph and data-driven algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEMtree(
  graph,
  data,
  seed,
  type = "ST",
  eweight = NULL,
  alpha = 0.05,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SEMtree_+3A_graph">graph</code></td>
<td>
<p>An igraph object.</p>
</td></tr>
<tr><td><code id="SEMtree_+3A_data">data</code></td>
<td>
<p>A matrix or data.frame. Rows correspond to subjects, and
columns to graph nodes (variables).</p>
</td></tr>
<tr><td><code id="SEMtree_+3A_seed">seed</code></td>
<td>
<p>A vector of seed nodes.</p>
</td></tr>
<tr><td><code id="SEMtree_+3A_type">type</code></td>
<td>
<p>Tree-based structure learning method. Four algorithms 
are available:
</p>

<ul>
<li><p> &quot;ST&quot;(default). Steiner Tree (ST) identification via fast Kou's algorithm 
(Kou et al, 1981) connecting a set of seed nodes (called Terminal vertices)
with connector nodes (called Steiner vertices) from input graph as defined
in <code>graph</code> with minimal total distance on its edges. By default the edge
weights are based on the pairwise correlation, 1-abs(cor(j,k)). If input
graph has E(graph)$weight=1, and <code>eweight = "custom"</code>, ST seeks a minimum
subtree (i.e., the subtree with minimal number of edges).
</p>
</li>
<li><p> &quot;CAT&quot;. Causal additive trees (CAT) algorithm as in Jakobsen et al. 
(2022). The argument <code>graph</code> is set to NULL (i.e., no input graph is needed).
In the first step, a (univariate) generalized additive model (GAM) is employed
to estimate the residual variances, var(X(j) - [X(j)|X(k)]) for all j != k,
then use these to construct edge weights as inputs to the Chu–Liu–Edmonds’
algorithm (Chow and Liu, 1968) to recover the arborescence. Argument <code>seed</code>
must be specified to analyse a subset of nodes (variables) of interest.
</p>
</li>
<li><p> &quot;CPDAG&quot;. CLE algorithm for Skeleton Recovery and CPDAG
estimation as in Lou et al. (2021). Together with &quot;CAT&quot; algorithm, &quot;CPDAG&quot; is 
data-driven and the argument <code>graph</code> is set to NULL.
The key idea is to first recover the skeleton of the polytree by applying 
the CLE algorithm to the pairwise sample correlations of the data matrix.
After the skeleton is recovered, the set of all v-structures can be correctly
identified via a simple thresholding approach to pairwise sample correlations.
CPDAG can be found applying iteratively only Rule 1 of Meek (1995).
Argument <code>seed</code> must be specified to analyse a subset of nodes
(variables) of interest.
</p>
</li>
<li><p> &quot;MST&quot;. Minimum Spanning Tree (MST) identification via Prim's algorithm
(Prim, 1957). The latter finds the subset of edges that includes every vertex
of the graph (as defined in <code>graph</code>) such that the sum of the weights 
of the edges can be minimized. The argument <code>seed</code> is set to NULL (i.e.,
no seed nodes are needed).
</p>
</li></ul>
</td></tr>
<tr><td><code id="SEMtree_+3A_eweight">eweight</code></td>
<td>
<p>Edge weight type for igraph object can be externally derived
using <code><a href="#topic+weightGraph">weightGraph</a></code> or from user-defined distances. 
This option determines the weight-to-distance transform. If set to:
</p>

<ul>
<li><p> &quot;NULL&quot; (default), edge weights will be internally computed
equal to 1 - abs(pairwise Pearson's correlation).
</p>
</li>
<li><p> &quot;kegg&quot;, repressing(-1), neutral(0) and activating(+1) kegg
interactions will be multiplied by &quot;zsign&quot; attributes, and positive
(i.e., concordant) values will be set to 1 (minimum distance), while
negative (i.e., discordant) values will be set to 2.
</p>
</li>
<li><p> &quot;zsign&quot;, all significant interactions (abs(zsign) &gt; 0) will be
set to 1 (minimum distance), while non-significant (zsign=0) ones will
be set to 2.
</p>
</li>
<li><p> &quot;pvalue&quot;, edge p-value atributes will be transformed to the
inverse of negative base-10 logarithm, 1/(-log(E(graph)$pv)).
</p>
</li>
<li><p> &quot;custom&quot;, the algorithm will use the distance measure specified
by the user as &quot;weight&quot; edge attribute in the input graph.
</p>
</li></ul>
</td></tr>
<tr><td><code id="SEMtree_+3A_alpha">alpha</code></td>
<td>
<p>Threshold for rejecting a pair of node being independent in 
&quot;CPDAG&quot; algorithm. The latter implements a natural v-structure identification 
procedure by thresholding the pairwise sample correlations over all adjacent 
pairs of edges with some appropriate threshold. By default, 
<code>alpha = 0.05</code>.</p>
</td></tr>
<tr><td><code id="SEMtree_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, it shows the output tree (not recommended for large graphs).</p>
</td></tr>
<tr><td><code id="SEMtree_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tree ia an acyclic graph with p vertices and p-1 edges. The graph method
refers to the  Steiner Tree (ST), a tree from an undirected graph that connect &quot;seed&quot;
with additional nodes in the &quot;most compact&quot; way possible. The data-driven methods
propose fast and scalable procedures based on Chu-Liu–Edmonds’ algorithm (CLE) to
recover a tree from a full graph. The first method, called Causal Additive Trees (CAT)
uses pairwise mutual weights as input for CLE algorithm to recover a directed tree
(an &quot;arborescence&quot;). The second one applies CLE algorithm for skeleton recovery and
extends the skeleton to a tree (a &quot;polytree&quot;) represented by a Completed Partially
Directed Acyclic Graph (CPDAG). Finally, the Minimum Spanning Tree (MST) connecting
an undirected graph with minimal edge weights can be identified.
To note, if the input graph is a directed graph, ST and MST undirected trees are
converted in directed trees using the <code><a href="#topic+orientEdges">orientEdges</a></code> function.
</p>


<h3>Value</h3>

<p>An <code>igraph</code> object. If <code>type = "ST"</code>, seed nodes are 
colored in &quot;aquamarine&quot; and connectors in &quot;white&quot;. If <code>type = "ST"</code> and
<code>type = "MST"</code>, edges are colored in &quot;green&quot; if not present in the input,
graph. If <code>type = "CPDAG"</code>, bidirected edges are colored in &quot;black&quot;
(if the algorithm is not able to establish the direction of the relationship
between x and y).
</p>


<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>References</h3>

<p>Grassi M, Tarantino B (2023). SEMtree: tree-based structure learning methods
with structural equation models. 
Bioinformatics, 39 (6), 4829–4830 &lt;https://doi.org/10.1093/bioinformatics/btad377&gt;
</p>
<p>Kou, L., Markowsky, G., Berman, L. (1981). A fast algorithm for Steiner trees. 
Acta Informatica 15, 141–145. &lt;https://doi.org/10.1007/BF00288961&gt;
</p>
<p>Prim, R.C. (1957). Shortest connection networks and some generalizations Bell
System Technical Journal, 37 1389–1401. 
</p>
<p>Chow, C.K. and Liu, C. (1968). Approximating discrete probability distributions with 
dependence trees. IEEE Transactions on Information Theory, 14(3):462–467.
</p>
<p>Meek, C. (1995). Causal inference and causal explanation with background knowledge.
In Proceedings of the Eleventh conference on Uncertainty in artificial intelligence,
403–410.
</p>
<p>Jakobsen, M, Shah, R., Bühlmann, P., Peters, J. (2022). 
Structure Learning for Directed Trees. arXiv:
&lt;https://doi.org/10.48550/arxiv.2108.08871&gt;.
</p>
<p>Lou, X., Hu, Y., Li, X. (2022). Linear Polytree Structural Equation Models:
Structural Learning and Inverse Correlation Estimation. arXiv:
&lt;https://doi.org/10.48550/arxiv.2107.10955&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Nonparanormal(npn) transformation
als.npn &lt;- transformData(alsData$exprs)$data

# graph-based trees
graph &lt;- alsData$graph
seed &lt;- V(graph)$name[sample(1:vcount(graph), 10)]
tree1 &lt;- SEMtree(graph, als.npn, seed=seed, type="ST", verbose=TRUE)
tree2 &lt;- SEMtree(graph, als.npn, seed=NULL, type="MST", verbose=TRUE)

# data-driven trees
V &lt;- colnames(als.npn)[colnames(als.npn) %in% V(graph)$name]
tree3 &lt;- SEMtree(NULL, als.npn, seed=V, type="CAT", verbose=TRUE)
tree4 &lt;- SEMtree(NULL, als.npn, seed=V, type="CPDAG", alpha=0.05, verbose=TRUE)


</code></pre>

<hr>
<h2 id='Shipley.test'>Missing edge testing implied by a DAG with Shipley's basis-set</h2><span id='topic+Shipley.test'></span>

<h3>Description</h3>

<p>Compute all the P-values of the d-separation tests
implied by the missing edges of a given acyclic graph (DAG).
The conditioning set Z is represented, in a DAG, by the union of the
parent sets of X and Y (Shipley, 2000). 
The results of every test, in a DAG, is then combined using the
Fisher’s statistic in an overall test of the fitted model
C = -2*sum(log(P-value(k))), where C is distributed as a chi-squared
variate with df = 2k, as suggested by Shipley (2000).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Shipley.test(
  graph,
  data,
  MCX2 = FALSE,
  cmax = Inf,
  limit = 100,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Shipley.test_+3A_graph">graph</code></td>
<td>
<p>A directed graph as an igraph object.</p>
</td></tr>
<tr><td><code id="Shipley.test_+3A_data">data</code></td>
<td>
<p>A data matrix with subjects as rows and variables as
columns.</p>
</td></tr>
<tr><td><code id="Shipley.test_+3A_mcx2">MCX2</code></td>
<td>
<p>If TRUE, a Monte Carlo P-value of the combined C test is
enabled using the R code of Shipley extracted from 
&lt;https://github.com/BillShipley/CauseAndCorrelation&gt;.</p>
</td></tr>
<tr><td><code id="Shipley.test_+3A_cmax">cmax</code></td>
<td>
<p>Maximum number of parents set, C. This parameter can be
used to perform only those tests where the number of conditioning
variables does not exceed the given value. High-dimensional conditional
independence tests can be very unreliable. By default, cmax = Inf.</p>
</td></tr>
<tr><td><code id="Shipley.test_+3A_limit">limit</code></td>
<td>
<p>An integer value corresponding to the graph size (vcount)
tolerance. Beyond this limit, multicore computation is enabled to
reduce the computational burden. By default, <code>limit = 100</code>.</p>
</td></tr>
<tr><td><code id="Shipley.test_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, Shipley's test results will be showed to
screen (default = TRUE).</p>
</td></tr>
<tr><td><code id="Shipley.test_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three objects: (i) &quot;dag&quot;:  the DAG used to perform the Shipley
test (ii) &quot;dsep&quot;: the data.frame of all d-separation tests over missing edges in
the DAG and (iii) &quot;ctest&quot;: the overall Shipley's' P-value.
</p>


<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>References</h3>

<p>Shipley B (2000). A new inferential test for path models based on DAGs.
Structural Equation Modeling, 7(2): 206-218.
&lt;https://doi.org/10.1207/S15328007SEM0702_4&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#\donttest{
# Nonparanormal(npn) transformation
als.npn &lt;- transformData(alsData$exprs)$data

sem &lt;- SEMrun(alsData$graph, als.npn)
C_test &lt;- Shipley.test(sem$graph, als.npn, MCX2 = FALSE)
#MC_test &lt;- Shipley.test(sem$graph, als.npn, MCX2 = TRUE)
#}

</code></pre>

<hr>
<h2 id='summary.GGM'>GGM model summary</h2><span id='topic+summary.GGM'></span>

<h3>Description</h3>

<p>Generate a summary for a constrained Gaussian Graphical
Model (GGM) similar to lavaan-formated summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GGM'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.GGM_+3A_object">object</code></td>
<td>
<p>A constrained GGM fitted model object.</p>
</td></tr>
<tr><td><code id="summary.GGM_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Shown the lavaan-formatted summary to console
</p>


<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SEMrun">SEMrun</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sem0 &lt;- SEMrun(sachs$graph, log(sachs$pkc), algo = "cggm")
summary(sem0$fit)

</code></pre>

<hr>
<h2 id='summary.RICF'>RICF model summary</h2><span id='topic+summary.RICF'></span>

<h3>Description</h3>

<p>Generate a summary for a RICF solver similar to
lavaan-formatted summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RICF'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.RICF_+3A_object">object</code></td>
<td>
<p>A RICF fitted model object.</p>
</td></tr>
<tr><td><code id="summary.RICF_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Shown the lavaan-formatted summary to console
</p>


<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SEMrun">SEMrun</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sem1 &lt;- SEMrun(sachs$graph, log(sachs$pkc), sachs$group, algo = "ricf")
summary(sem1$fit)

</code></pre>

<hr>
<h2 id='transformData'>Transform data methods</h2><span id='topic+transformData'></span>

<h3>Description</h3>

<p>Implements various data trasformation methods with
optimal scaling for ordinal or nominal data, and to help relax
the assumption of normality (gaussianity) for continuous data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformData(x, method = "npn", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transformData_+3A_x">x</code></td>
<td>
<p>A matrix or data.frame (n x p). Rows correspond to subjects, and
columns to graph nodes.</p>
</td></tr>
<tr><td><code id="transformData_+3A_method">method</code></td>
<td>
<p>Trasform data method. It can be one of the following:
</p>

<ol>
<li><p> &quot;npn&quot; (default), performs nonparanormal(npn) or semiparametric
Gaussian copula model (Liu et al, 2009), estimating the Gaussian copula
by marginally transforming the variables using smooth ECDF functions.
The npn distribution corresponds to the latent underlying multivariate
normal distribution, preserving the conditional independence structure
of the original variables.
</p>
</li>
<li><p> &quot;spearman&quot;, computes a trigonometric trasformation of Spearman
rho correlation for estimation of latent Gaussian correlations
parameter of a nonparanormal distribution (Harris &amp; Dorton (2013),
and generates the data matrix with the exact same sample covariance
matrix as the estimated one.
</p>
</li>
<li><p> &quot;kendall&quot;, computes a trigonometric trasformation of Kendall
tau correlation for estimation of latent Gaussian correlations
parameter of a nonparanormal distribution (Harris &amp; Dorton (2013),
and generates the data matrix with the exact same sample covariance
matrix as the estimated one.
</p>
</li>
<li><p> &quot;polychoric&quot;, computes the polychoric correlation matrix and
generates the data matrix with the exact same sample covariance matrix
as the estimated one. The polychoric correlation (Olsson, 1974) is a
measure of association between two ordinal variables. It is based on the
assumption that two latent bivariate normally distributed random variables
generate couples of ordinal scores. Tetrachoric (two binary variables) and
biserial (an ordinal and a numeric variables) correlations are special cases.
</p>
</li>
<li><p> &quot;lineals&quot;, performs optimal scaling in order to achieve linearizing
transformations for each bivariate regression between pairwise variables for
subsequent structural equation models using the resulting correlation
matrix computed on the transformed data (de Leeuw, 1988).
</p>
</li>
<li><p> &quot;mca&quot;, performs optimal scaling of categorical data by Multiple
Correspondence Analysis (MCA, a.k.a homogeneity analysis) maximizing
the first eigenvalues of the trasformed correlation matrix. The estimates
of the corresponding structural parameters are consistent if the underlying
latent space of the observed variables is unidimensional.
</p>
</li></ol>
</td></tr>
<tr><td><code id="transformData_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Nonparanormal trasformation is computationally very efficient
and only requires one ECDF pass of the data matrix. Polychoric correlation
matrix is computed with the <code>lavCor()</code> function of the <code>lavaan</code>
package. Optimal scaling (lineals and mca) is performed with the
<code>lineals()</code> and <code>corAspect()</code> functions of the <code>aspect</code>
package (Mair and De Leeuw, 2008). To note, SEM fitting of the generate data
(fake data) must be done with a covariance-based method and bootstrap SE,
i.e., with <code>SEMrun(..., algo="ricf", n_rep=1000)</code>.
</p>


<h3>Value</h3>

<p>A list of 2 objects is returned:
</p>

<ol>
<li><p> &quot;data&quot;, the matrix (n x p) of n observations and p transformed
variables or the matrix (n x p) of simulate observations based on the
selected correlation matrix.  
</p>
</li>
<li><p> &quot;catscores&quot;, the category weights for &quot;lineals&quot; or &quot;mca&quot;
methods or NULL otherwise.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>References</h3>

<p>Liu H, Lafferty J, and Wasserman L (2009). The Nonparanormal: Semiparametric Estimation of
High Dimensional Undirected Graphs. Journal of Machine Learning Research 10(80): 2295-2328
</p>
<p>Harris N, and Drton M (2013). PC Algorithm for Nonparanormal Graphical Models.
Journal of Machine Learning Research 14 (69): 3365-3383
</p>
<p>Olsson U (1979). Maximum likelihood estimation of the polychoric correlation coefficient.
Psychometrika, 44(4), 443-460.
</p>
<p>Mair P, and De Leeuw J (2008). Scaling variables by optimizing correlational and
non-correlational aspects in R. Journal of Statistical Software, 32(9), 1-23.
</p>
<p>de Leeuw J (1988). Multivariate analysis with linearizable regressions. Psychometrika,
53, 437-454.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#... with continuous ALS data
graph&lt;- alsData$graph
data&lt;- alsData$exprs; dim(data)
X&lt;- data[, colnames(data) %in% V(graph)$name]; dim(X)

npn.data&lt;- transformData(X, method="npn")
sem0.npn&lt;- SEMrun(graph, npn.data$data, algo="cggm")

mvnS.data&lt;- transformData(X, method="spearman")
sem0.mvnS&lt;- SEMrun(graph, mvnS.data$data, algo="cggm")

mvnK.data&lt;- transformData(X, method="kendall")
sem0.mvnK&lt;- SEMrun(graph, mvnK.data$data, algo="cggm")

#...with ordinal (K=4 categories) ALS data
Xord &lt;- data.frame(X)
Xord &lt;- as.data.frame(lapply(Xord, cut, 4, labels = FALSE))
colnames(Xord) &lt;- sub("X", "", colnames(Xord))

mvnP.data&lt;- transformData(Xord, method="polychoric")
sem0.mvnP&lt;- SEMrun(graph, mvnP.data$data, algo="cggm")

#...with nominal (K=4 categories) ALS data
mca.data&lt;- transformData(Xord, method="mca")
sem0.mca&lt;- SEMrun(graph, mca.data$data, algo="cggm")
mca.data$catscores
gplot(sem0.mca$graph, l="fdp", main="ALS mca")

# plot colored graphs
#par(mfrow=c(2,2), mar=rep(1,4))
#gplot(sem0.npn$graph, l="fdp", main="ALS npm")
#gplot(sem0.mvnS$graph, l="fdp", main="ALS mvnS")
#gplot(sem0.mvnK$graph, l="fdp", main="ALS mvnK")
#gplot(sem0.mvnP$graph, l="fdp", main="ALS mvnP")

</code></pre>

<hr>
<h2 id='weightGraph'>Graph weighting methods</h2><span id='topic+weightGraph'></span>

<h3>Description</h3>

<p>Add data-driven edge and node weights to the input graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightGraph(graph, data, group = NULL, method = "r2z", limit = 10000, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weightGraph_+3A_graph">graph</code></td>
<td>
<p>An igraph object.</p>
</td></tr>
<tr><td><code id="weightGraph_+3A_data">data</code></td>
<td>
<p>A matrix or data.frame. Rows correspond to subjects, and
columns to graph nodes.</p>
</td></tr>
<tr><td><code id="weightGraph_+3A_group">group</code></td>
<td>
<p>Binary vector. This vector must be as long as the number
of subjects. Each vector element must be 1 for cases and 0 for control
subjects. By default, <code>group = NULL</code>. If group is not NULL, also
node weighting is actived, and node weights correspond to the attribute:
V(graph)$pv (P-value of the z-test = b/SE(b) from simple linear regression
y ~ x, i.e., lm(node ~ group)) and V(graph)$sign (-1 if z&lt;-2, +1 if z&gt;2,
0 otherwise).</p>
</td></tr>
<tr><td><code id="weightGraph_+3A_method">method</code></td>
<td>
<p>Edge weighting method. It can be one of the following:
</p>

<ol>
<li><p> &quot;r2z&quot;, weight edges are defined using Fisher's r-to-z transform
(Fisher, 1915) to test the correlation coefficient of pairs of interacting
nodes, if <code>group=NULL</code>. Otherwise, the difference between group of
the r-to-z trasform will be tested. Edge weights correspond to the attribute:
E(graph)$pv (P-value of the z-test) and E(graph)$sign (-1 if z&lt;-2, +1 if z&gt;2,
0 otherwise).
</p>
</li>
<li><p> &quot;sem&quot;, edge weights are defined by a SEM model that implies 
testing the group effect simultaneously on source and sink nodes.
A new parameter w is defined as the weighted sum of the total effect 
of the group on source and sink nodes, adjusted by node degree centrality. 
Edge weights correspond to the attribute: E(graph)$pv (P-value of the
z-test = w/SE(w)) and E(graph)$sign (-1 if z&lt;-2, +1 if z&gt;2, 0 otherwise). 
Not available if <code>group=NULL</code>.
</p>
</li>
<li><p> &quot;cov&quot;, edge weights are defined by a new parameter w combining 
the group effect on the source node (mean group difference, adjusted 
by source degree centrality), the sink node (mean group difference, 
adjusted by sink degree centrality), and the source&ndash;sink interaction 
(correlation difference). Edge weights correspond to the attribute:
E(graph)$pv (P-value of the z-test = w/SE(w) of the combined difference
of the group over source node, sink node, and their connection) and
E(graph)$sign (-1 if z&lt;-2, +1 if z&gt;2, 0 otherwise).
Not available if <code>group=NULL</code>.
</p>
</li>
<li><p> &quot;cfa&quot;, edge weights are defined by a CFA1 model that implies 
testing the group effect, w on a latent variable (LV) with observed
indicators two interacting nodes, fixing loading coefficients and residual
variances for model identification. Edge weights correspond to the
attribute: E(graph)$pv (P-value of the z-test = w/SE(w) of the group
effect on the LV) and E(graph)$sign (-1 if z&lt;-2, +1 if z&gt;2, 0 otherwise).
Not available if <code>group=NULL</code>.
</p>
</li></ol>
</td></tr>
<tr><td><code id="weightGraph_+3A_limit">limit</code></td>
<td>
<p>An integer value corresponding to the number of graph 
edges. Beyond this limit, multicore computation is enabled to reduce 
the computational burden. By default, <code>limit = 10000</code>.</p>
</td></tr>
<tr><td><code id="weightGraph_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A weighted graph, as an igraph object.
</p>


<h3>Author(s)</h3>

<p>Mario Grassi <a href="mailto:mario.grassi@unipv.it">mario.grassi@unipv.it</a>
</p>


<h3>References</h3>

<p>Grassi M, Tarantino B (2023). [Supplementary material of] SEMtree: tree-based structure
learning methods with structural equation models. 
Bioinformatics, 39 (6), 4829–4830 &lt;https://doi.org/10.1093/bioinformatics/btad377&gt;
</p>
<p>Fisher RA (1915). Frequency Distribution of the Values of the Correlation
Coefficient in Samples from an Indefinitely Large Population. Biometrika,
10(4), 507–521. &lt;doi:10.2307/2331838&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Graph weighting
G &lt;- weightGraph(graph = sachs$graph,
                 data = log(sachs$pkc),
                 group = sachs$group,
                 method = "r2z")

# New edge attributes
head(E(G)$pv); summary(E(G)$pv)
head(E(G)$zsign); table(E(G)$zsign)

# New node attributes
head(V(G)$pv); summary(V(G)$pv)
head(V(G)$zsign); table(V(G)$zsign)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
