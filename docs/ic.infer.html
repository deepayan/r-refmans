<!DOCTYPE html><html><head><title>Help for package ic.infer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ic.infer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ic.infer'><p> Package for inequality-constrained estimation and testing</p></a></li>
<li><a href='#bodyfat'><p> Body fat data from Kutner et al. 2004</p></a></li>
<li><a href='#contr.diff'><p> Contrast function for factors with ordered values that yields increment coefficients</p></a></li>
<li><a href='#grades'><p>Data set grades: Grade point averages by HSR and ACTC</p></a></li>
<li><a href='#ic.est'><p> Functions for order-restricted estimates and printing thereof</p></a></li>
<li><a href='#ic.test'><p> Function for testing inequality-related hypotheses for multivariate</p>
normal random variables</a></li>
<li><a href='#ic.weights'><p> functions for calculating the distributions of normal distribution</p>
order-related likelihood ratio tests</a></li>
<li><a href='#internal.functions'><p> internal functions not intended for the user</p></a></li>
<li><a href='#make.mon.ui'><p> Function for creating the matrix ui for monotonicity (in)equality restrictions</p></a></li>
<li><a href='#or.relimp'><p> Function to calculate relative importance for order-restricted</p>
linear models</a></li>
<li><a href='#orlm'><p> Functions for order restricted linear regression estimation and testing</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Inequality Constrained Inference in Linear Normal Situations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-7</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 2.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>quadprog, mvtnorm, boot, kappalab</td>
</tr>
<tr>
<td>Suggests:</td>
<td>relaimpo</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-04</td>
</tr>
<tr>
<td>Author:</td>
<td>Ulrike Groemping</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ulrike Groemping &lt;ulrike.groemping@bht-berlin.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements inequality constrained inference. This includes parameter estimation in normal (linear) models under linear equality and inequality constraints, as well as normal likelihood ratio tests involving inequality-constrained hypotheses. For inequality-constrained linear models, averaging over R-squared for different orderings of regressors is also included.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://prof.bht-berlin.de/groemping/">https://prof.bht-berlin.de/groemping/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-04 14:27:00 UTC; groemping</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-04 17:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ic.infer'> Package for inequality-constrained estimation and testing </h2><span id='topic+ic.infer'></span><span id='topic+ic.infer-package'></span>

<h3>Description</h3>

<p>Package <code>ic.infer</code> implements estimation and testing for multivariate normal 
expectations with linear equality- and inequality constraints. This also includes 
inference on linear models with linear equality- and inequality constraints on the 
parameters. Decomposition of R-squared is also included for these models.
</p>


<h3>Details</h3>

<p>Function <code>ic.est</code> estimates the constrained expectation of a multivariate normal 
random vector, function <code>ic.test</code> conducts related tests. 
</p>
<p>Function <code>orlm</code> estimates constrained parameters in normal linear models based on 
a linear model object or a covariance matrix. The function offers the possibility of 
bootstrapping the estimates. Tests and confidence intervals are provided by a summary 
function. 
</p>
<p>Function <code>or.relimp</code> decomposes the $R^2$-values analogously to metric 
<code>lmg</code> in package <span class="pkg">relaimpo</span> for unconstrained linear models. 
However, <code>or.relimp</code> is far less comfortable 
to use und subject to severe limitations, since automatic selection of restrictions 
for sub models is not in all cases trivial. 
</p>
<p>The package makes use of various other R packages: <span class="pkg">quadprog</span> is used for 
constrained estimation, <span class="pkg">mvtnorm</span> in calculation of weights for null distributions 
of test statistics, <span class="pkg">kappalab</span> for averaging over orderings in function <code>or.relimp</code>, 
and <span class="pkg">boot</span> for bootstrapping.
</p>
<p>The theory behind inequality-constrained estimation and testing as well as 
functionality of the package are explained in a vignette (Link from within dynamic help: 
<a href="../doc/ic.infer.pdf">../doc/ic.infer.pdf</a>) that is based on Groemping (2010). 
The vignette can also be opened from the command line by <code>vignette("ic.infer")</code>.
</p>


<h3>Value</h3>

<p>The output of function <code>ic.est</code> belongs to S3 class <code>orest</code>. 
</p>
<p>The output of function <code>ic.test</code> belongs to S3 class <code>ict</code>. 
</p>
<p>The output of function <code>orlm</code> belongs to S3 classes <code>orlm</code> and <code>orest</code>. 
</p>
<p>All these classes offer print and summary methods. 
</p>
<p>The output of function <code>or.relimp</code> is a named vector. </p>


<h3>Acknowledgements</h3>

<p>This package uses as an internal function the function <code>nchoosek</code> from <span class="pkg">vsn</span>, 
authored by Wolfgang Huber, available under LGPL.
</p>
<p>It also uses modifications of numerical routines that were provided by John Fox 
in R-help.
</p>
<p>Thanks go to Wiley for permission of incorporating the grades data 
from Table 1.3.1 of Robertson, Wright and Dykstra (1988) into the package.
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping, BHT Berlin </p>


<h3>References</h3>

<p>Groemping, U. (2010). Inference With Linear Equality And Inequality
Constraints Using R: The Package ic.infer. <em>Journal of Statistical Software</em>, 
Forthcoming. 
</p>
<p>Kudo, A. (1963). A multivariate analogue of the one-sided test. 
<em>Biometrika</em> <b>50</b>, 403&ndash;418
</p>
<p>Robertson T, Wright F, Dykstra R (1988). <em>Order-Restricted Inference</em>. 
Wiley, New York.
</p>
<p>Sasabuchi, S. (1980) A test of a multivariate normal mean with composite 
hypotheses determined by linear inequalities. <em>Biometrika</em> 
<b>67</b>, 429&ndash;429
</p>
<p>Shapiro, A. (1988). Towards a unified theory of inequality-constrained 
testing in multivariate analysis. <em>International Statistical Review</em> 
<b>56</b>, 49&ndash;62
</p>
<p>Silvapulle, M.J. and Sen, P.K. (2004). <em>Constrained Statistical Inference</em>. 
Wiley, New York</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+ic.est">ic.est</a></code>, <code><a href="#topic+ic.test">ic.test</a></code>, <code><a href="#topic+orlm">orlm</a></code>,
<code><a href="#topic+or.relimp">or.relimp</a></code>, packages <span class="pkg">boot</span>, <span class="pkg">kappalab</span>, 
<span class="pkg">mvtnorm</span>, <span class="pkg">quadprog</span>, and <span class="pkg">relaimpo</span></p>


<h3>Examples</h3>

<pre><code class='language-R'>## unrestricted linear model for grade point averages
limo &lt;- lm(meanGPA~.-n, weights=n, data=grades)
summary(limo)
## restricted linear model with restrictions that better HSR ranking 
## cannot deteriorate meanGPA
orlimo &lt;- orlm(lm(meanGPA~.-n, weights=n, data=grades), index=2:9, 
       ui=make.mon.ui(grades$HSR))
summary(orlimo, brief=TRUE)
</code></pre>

<hr>
<h2 id='bodyfat'> Body fat data from Kutner et al. 2004 </h2><span id='topic+bodyfat'></span>

<h3>Description</h3>

<p>Data set with three explanatory variables and response variable body fat for 
20 healthy females aged 35-44
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bodyfat
</code></pre>


<h3>Format</h3>

<p>A data frame with four columns:
</p>

<dl>
<dt>Triceps</dt><dd><p>triceps skinfold thickness</p>
</dd>
<dt>Thigh</dt><dd><p>thigh circumference</p>
</dd>
<dt>Midarm</dt><dd><p>midarm circumference</p>
</dd>
<dt>BodyFat</dt><dd><p>body fat</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data set contains three explanatory variables and the response variable body fat for 
20 healthy females aged 35-44. As the variable body fat is very expensive to obtain, 
predicting it with the cheaper dimensional measurements is desirable. There is 
substantial multicollinearity among the explanatory variables.
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping, BHT Berlin </p>


<h3>Source</h3>

<p>Kutner,M., Nachtsheim,C., Neter J., Li, W. (2005, 5th Ed.).
<em>Applied Linear Statistical Models</em>. McGraw-Hill, New York.
</p>
<p>Kutner,M., Nachtsheim,C., Neter J. (2004, 4th Ed.).
<em>Applied Linear Regression Models</em>. McGraw-Hill, New York.
</p>
<p>The data are published on the accompanying CD-Roms of those books 
(Table 1 in Chapter 7) and are also available online 
on the books homepages or from the UCLA website linked below. 
(Note that earlier editions of the bood had Neter as first author 
and included Wasserman as author, but the earlier editions do not have these data.)
</p>


<h3>References</h3>

<p>UCLA: Statistical Consulting Group (without year). Applied Linear Statistical Models by Neter, Kutner, et. al. Chapter 7: Multiple Regression II | SAS Textbook Examples. 
<a href="https://stats.oarc.ucla.edu/sas/examples/alsm/applied-linear-statistical-models-by-neter-kutner-et-al-chapter-7-multiple-regression-ii/">https://stats.oarc.ucla.edu/sas/examples/alsm/applied-linear-statistical-models-by-neter-kutner-et-al-chapter-7-multiple-regression-ii/</a> (accessed October 04, 2023).
</p>

<hr>
<h2 id='contr.diff'> Contrast function for factors with ordered values that yields increment coefficients </h2><span id='topic+contr.diff'></span>

<h3>Description</h3>

<p>Function <code>contr.diff</code> is a contrast function for factors with ordered values. 
Coefficients for factors formatted with <code>contr.diff</code> are the increments 
from the current level to the neighbouring lower level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contr.diff(n, contrasts = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contr.diff_+3A_n">n</code></td>
<td>
<p> vector of levels or integer number of levels</p>
</td></tr>
<tr><td><code id="contr.diff_+3A_contrasts">contrasts</code></td>
<td>
<p> logical indicating whether contrasts should be computed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The design matrix for an ordered factor formatted with <code>contr.diff</code> consists of ones 
for the current level itself and all lower levels. Thus, the estimated coefficients 
for each level are the estimated differences to the next lower level. 
</p>
<p>With this coding, the matrix <code>ui</code> in functions of package <span class="pkg">ic.infer</span> 
can be chosen as the identity matrix for monotonicity constraints on the factor. 
</p>


<h3>Value</h3>

<p>a matrix with a row for each level and a column for each dummy variable 
(when applied to a factor in a linear model). 
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping, BHT Berlin </p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+ic.test">ic.test</a></code>, <code><a href="#topic+ic.est">ic.est</a></code>, 
<code><a href="#topic+orlm">orlm</a></code>, <code><a href="stats.html#topic+contrasts">contrasts</a></code> for other contrast 
functions </p>


<h3>Examples</h3>

<pre><code class='language-R'>## mu, Sigma and covariance matrix
means &lt;- c(3,5,2,7)
## contrast matrix
contr.diff(4)
## design matrix
X &lt;- cbind(rep(1,4),contr.diff(4))
## estimated coefficients
solve(t(X)%*%X,t(X)%*%means)
</code></pre>

<hr>
<h2 id='grades'>Data set grades: Grade point averages by HSR and ACTC</h2><span id='topic+grades'></span>

<h3>Description</h3>

<p>The data set contains first-year grade point averages (GPAs) from 2397 Iowa university
first-years who entered the university of Iowa as freshmen in the fall of 1978. 
The GPAs are separated out by two ordinal variables with 9 categories each, High-School-Ranking
percentiles and ACT Classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grades
</code></pre>


<h3>Format</h3>

<p>A data frame with four columns:
</p>

<dl>
<dt>HSR</dt><dd><p>high-school-ranking percentiles</p>
</dd>
<dt>ACTC</dt><dd><p>ACT classification (ACT is an organization that offers, among other things, 
college entrance exams in the US; up to 1996, ACT stood for &ldquo;American College Testing&rdquo;.)</p>
</dd>
<dt>meanGPA</dt><dd><p>grade point average for the HSR/ACTC combination</p>
</dd>
<dt>n</dt><dd><p>sample size for the HSR/ACTC combination</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Ulrike Groemping, BHT Berlin </p>


<h3>Source</h3>

<p>Robertson T, Wright F, Dykstra R (1988). <em>Order-Restricted Inference</em>. Wiley, New York.
Table 1.3.1, p.13.
</p>
<p>Thanks go to Wiley for granting a complimentary license for embedding the data into the package.
</p>

<hr>
<h2 id='ic.est'> Functions for order-restricted estimates and printing thereof </h2><span id='topic+ic.est'></span><span id='topic+print.orest'></span><span id='topic+summary.orest'></span>

<h3>Description</h3>

<p>Function ic.est estimates a mean vector under linear inequality constraints, 
functions print.orest and summary.orest provide printed results in different 
degrees of detail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ic.est(x, Sigma, ui, ci = NULL, index = 1:nrow(Sigma), meq = 0, 
            tol = sqrt(.Machine$double.eps))
## S3 method for class 'orest'
print(x, digits = max(3, getOption("digits") - 3), scientific = FALSE, ...)
## S3 method for class 'orest'
summary(object, display.unrestr = FALSE, brief = FALSE, 
            digits = max(3, getOption("digits") - 3), scientific = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ic.est_+3A_x">x</code></td>
<td>
<p> for <code>ic.est</code>: unrestricted vector (e.g. mean of a sample of random vectors), 
from which the expected value under linear inequality 
(and perhaps equality) restrictions is to be estimated 
</p>
<p>for <code>print.orest</code>: object of class <code>orest</code> 
(normally produced by <code>ic.est</code> or <code>orlm</code>)</p>
</td></tr>
<tr><td><code id="ic.est_+3A_object">object</code></td>
<td>
<p> for <code>summary.orest</code>: 
object of class <code>orest</code> 
(normally produced by <code>ic.est</code> or <code>orlm</code>)</p>
</td></tr>
<tr><td><code id="ic.est_+3A_sigma">Sigma</code></td>
<td>
<p> covariance or correlation matrix (or any multiple thereof) 
of <code>x</code> </p>
</td></tr>
<tr><td><code id="ic.est_+3A_ui">ui</code></td>
<td>
<p> matrix (or vector in case of one single restriction only) 
defining the left-hand side of the restriction 
</p>
<p><code>ui%*%mu &gt;= ci</code>,
</p>
<p>where mu is the expectation vector of x;         
the first few of these restrictions can be declared equality- instead
of inequality restrictions (cf. argument <code>meq</code>); 
if only part of the elements of mu are subject to restrictions, 
the columns of ui can be restricted to these elements, if their 
index numbers are provided in <code>index</code>
</p>
<p>Rows of <code>ui</code> must be linearly independent; 
in case of linearly dependent rows the function gives an error 
message with a hint which subset of rows is independent.
Note that the restrictions must define a (possibly translated) cone,
i.e. e.g. interval restrictions on a parameter are not permitted. 
</p>
<p>See <code><a href="#topic+contr.diff">contr.diff</a></code> for examples of how to comfortably 
define various types of restriction.</p>
</td></tr>
<tr><td><code id="ic.est_+3A_ci">ci</code></td>
<td>
<p> vector on the right-hand side of the restriction (cf. <code>ui</code>),
defaults to a vector of zeroes </p>
</td></tr>
<tr><td><code id="ic.est_+3A_index">index</code></td>
<td>
<p> index numbers of the components of mu, 
which are subject to the specified constraints 
as <code>ui%*%mu[index] &gt;= ci</code> </p>
</td></tr>
<tr><td><code id="ic.est_+3A_meq">meq</code></td>
<td>
<p> integer number (default 0) giving the number of rows of ui that 
are used for equality restrictions instead of inequality 
restrictions. 
</p>
</td></tr>
<tr><td><code id="ic.est_+3A_tol">tol</code></td>
<td>
<p>numerical tolerance value; 
estimates closer to 0 than tol are set to exactly 0</p>
</td></tr>
<tr><td><code id="ic.est_+3A_digits">digits</code></td>
<td>
<p> number of digits to be used in printing </p>
</td></tr>
<tr><td><code id="ic.est_+3A_scientific">scientific</code></td>
<td>
<p> if <code>FALSE</code>, suppresses scientific representation of 
numbers (default: <code>FALSE</code>) </p>
</td></tr>
<tr><td><code id="ic.est_+3A_...">...</code></td>
<td>
<p> further arguments to <code>print</code> </p>
</td></tr>
<tr><td><code id="ic.est_+3A_display.unrestr">display.unrestr</code></td>
<td>
<p> if TRUE, unrestricted estimate (i.e. <code>object</code>) is also displayed </p>
</td></tr>
<tr><td><code id="ic.est_+3A_brief">brief</code></td>
<td>
<p> if <code>TRUE</code>, suppress printing of restrictions; 
default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>ic.est</code> heavily relies on package <span class="pkg">quadprog</span> for determining 
the optimizer. It is a convenience wrapper for <code>solve.QP</code> from that package. 
The function is guaranteed to work appropriately if the specified restrictions 
determine a (translated) cone.  In that case, the estimate is the projection along 
matrix <code>Sigma</code> onto one of the faces of that cone (including the interior 
as the face of the highest dimension); this means that it minimizes the 
quadratic form <code>t(x-b)%*%solve(Sigma,x-b)</code> among all b that satisfy the 
restrictions <code>ui%*%b&gt;=ci</code> (or, if specified by <code>meq</code>, 
with the first <code>meq</code> restrictions equality instead of inequality restrictions). 
</p>


<h3>Value</h3>

<p>Function <code>ic.est</code> outputs a list with the following elements:
</p>
<table>
<tr><td><code>b.unrestr</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code>b.restr</code></td>
<td>
<p>restricted estimate</p>
</td></tr>
<tr><td><code>Sigma</code></td>
<td>
<p> as input </p>
</td></tr>
<tr><td><code>ui</code></td>
<td>
<p> as input</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p> as input</p>
</td></tr>
<tr><td><code>restr.index</code></td>
<td>
<p> index of components of mu, 
which are subject to the specified constraints as in input index </p>
</td></tr>
<tr><td><code>meq</code></td>
<td>
<p> as input</p>
</td></tr> 
<tr><td><code>iact</code></td>
<td>
<p> active restrictions, i.e. restrictions that are satisfied with 
equality in the solution, as output by <code>solve.QP</code></p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p> Ulrike Groemping, BHT Berlin </p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+ic.test">ic.test</a></code>, <code><a href="#topic+ic.weights">ic.weights</a></code>, 
<code><a href="#topic+orlm">orlm</a></code>, <code>solve.QP</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## different correlation structures
corr.plus &lt;- matrix(c(1,0.9,0.9,1),2,2)
corr.null &lt;- matrix(c(1,0,0,1),2,2)
corr.minus &lt;- matrix(c(1,-0.9,-0.9,1),2,2)
## unrestricted vectors
x1 &lt;- c(1, -1)
x2 &lt;- c(-1, -1)
x3 &lt;- c(10, -1)
## estimation under restriction non-negative orthant
## or first element equal to 0, second non-negative
ice &lt;- ic.est(x1, corr.plus, ui=diag(c(1,1)), ci=c(0,0))
ice
summary(ice)
ice2 &lt;-ic.est(x1, corr.plus, ui=diag(c(1,1)), ci=c(0,0), meq=1)
summary(ice2)
ic.est(x2, corr.plus, ui=diag(c(1,1)), ci=c(0,0))
ic.est(x2, corr.plus, ui=diag(c(1,1)), ci=c(0,0), meq=1)
ic.est(x3, corr.plus, ui=diag(c(1,1)), ci=c(0,0))
ic.est(x3, corr.plus, ui=diag(c(1,1)), ci=c(0,0), meq=1)
ic.est(x1, corr.null, ui=diag(c(1,1)), ci=c(0,0))
ic.est(x1, corr.null, ui=diag(c(1,1)), ci=c(0,0), meq=1)
ic.est(x2, corr.null, ui=diag(c(1,1)), ci=c(0,0))
ic.est(x2, corr.null, ui=diag(c(1,1)), ci=c(0,0), meq=1)
ic.est(x3, corr.null, ui=diag(c(1,1)), ci=c(0,0))
ic.est(x3, corr.null, ui=diag(c(1,1)), ci=c(0,0), meq=1)
ic.est(x1, corr.minus, ui=diag(c(1,1)), ci=c(0,0))
ic.est(x1, corr.minus, ui=diag(c(1,1)), ci=c(0,0), meq=1)
ic.est(x2, corr.minus, ui=diag(c(1,1)), ci=c(0,0))
ic.est(x2, corr.minus, ui=diag(c(1,1)), ci=c(0,0), meq=1)
ic.est(x3, corr.minus, ui=diag(c(1,1)), ci=c(0,0))
ic.est(x3, corr.minus, ui=diag(c(1,1)), ci=c(0,0), meq=1)
## estimation under one element restricted to being non-negative
ic.est(x3, corr.plus, ui=1, ci=0, index=1)
ic.est(x3, corr.plus, ui=1, ci=0, index=2)
</code></pre>

<hr>
<h2 id='ic.test'> Function for testing inequality-related hypotheses for multivariate 
normal random variables </h2><span id='topic+ic.test'></span><span id='topic+print.ict'></span><span id='topic+summary.ict'></span>

<h3>Description</h3>

<p><code>ic.test</code> tests linear inequality hypotheses for multivariate normal 
means by likelihood ratio tests. <code>print</code> and <code>summary</code> functions 
display results in different degrees of detail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ic.test(obj, TP = 1, s2 = 1, df.error = Inf, 
             ui0.11 = diag(rep(1, length(obj$b.restr))), 
             ci0.11 = NULL, meq.alt = 0,
             df = NULL, wt = NULL, tol=sqrt(.Machine$double.eps), ...)
## S3 method for class 'ict'
print(x, digits = max(3, getOption("digits") - 3), scientific = FALSE, ...)
## S3 method for class 'ict'
summary(object, brief = TRUE, digits = max(3, getOption("digits") - 3), 
             scientific = FALSE, tol=sqrt(.Machine$double.eps), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ic.test_+3A_obj">obj</code></td>
<td>
<p> Object of class <code>orest</code> that contains unrestricted and 
restricted estimate, covariance structure, and restriction;
</p>
<p>for objects of class <code>orlm</code> (that inherit from class <code>orest</code>) 
information on <code>s2</code> and <code>df.error</code> is taken from <code>obj</code> 
(i.e. specifications of <code>s2</code> and <code>df.error</code> in the call 
to <code>ic.test</code> are ignored) </p>
</td></tr>
<tr><td><code id="ic.test_+3A_tp">TP</code></td>
<td>
<p> type of test problem, cf. details</p>
</td></tr>
<tr><td><code id="ic.test_+3A_s2">s2</code></td>
<td>
<p> multiplier that modifies the matrix <code>obj$Sigma</code> into 
the (estimated) covariance matrix of the unrestricted estimate;
<code>obj$Sigma</code> may be a covariance matrix (<code>s2</code>=1, default), 
a correlation matrix or an otherwise rescaled 
covariance matrix (e.g. <code>cov.unscaled</code> from a linear model) </p>
</td></tr>
<tr><td><code id="ic.test_+3A_df.error">df.error</code></td>
<td>
<p> error degrees of freedom connected with estimation of s2
(e.g. residual df from linear model);
if <code>df.error</code> &lt; Inf, the test is based on a mixture of 
beta-distributions with parameters <code>df</code>/2 and <code>df.error</code>/2,
otherwise the test is based on a mixture of chi-square distributions 
with degrees of freedom in <code>df</code>. </p>
</td></tr>
<tr><td><code id="ic.test_+3A_ui0.11">ui0.11</code></td>
<td>
<p> matrix (or vector in case of one restriction only) 
for defining (additional) equality restrictions for TP 11
(in addition to restrictions in obj); 
</p>
<p>note that there must be as many columns as there are elements of 
vector b.restr (no extra index vector taken);
</p>
<p>if there is overlap between restrictions in ui0.11 and restrictions 
already present in obj, restrictions already present in obj are 
projected out for ui0.11: 
for example, the default choice for <code>ui0.11</code> means that all elements 
of the expectation are 0; some of these restrictions may already be 
present in <code>obj</code> and are projected out of <code>ui0.11</code> 
by <code>ic.test</code> </p>
</td></tr>
<tr><td><code id="ic.test_+3A_ci0.11">ci0.11</code></td>
<td>
<p> right-hand-side vector for equality restrictions defined by 
<code>ui0.11</code>; so far, these should be 0!</p>
</td></tr>
<tr><td><code id="ic.test_+3A_meq.alt">meq.alt</code></td>
<td>
<p> number of equality restrictions (from beginning) that are 
maintained under the alternative hypothesis (for TP21) </p>
</td></tr>
<tr><td><code id="ic.test_+3A_df">df</code></td>
<td>
<p> optional vector of degrees of freedom for mixed chibar- or beta-
distributions; if omitted, degrees of freedom and weights are calculated;
if given, must be accompanied by corresponding <code>wt</code> </p>
</td></tr>
<tr><td><code id="ic.test_+3A_wt">wt</code></td>
<td>
<p> optional vector of weights for mixed chibar- or beta-
distributions; if omitted, weights are calculated using function 
<code>ic.weights</code>; if given, must be accompanied by corresponding 
<code>df</code> (can be obtained from call to <code>ic.weights</code> or 
from previous runs of <code>ic.test</code> </p>
</td></tr>
<tr><td><code id="ic.test_+3A_x">x</code></td>
<td>
<p> output object from <code>ict.test</code> (of class <code>ict</code>)   </p>
</td></tr>
<tr><td><code id="ic.test_+3A_tol">tol</code></td>
<td>
<p>numerical tolerance value; 
estimates closer to 0 than <code>tol</code> are set to exactly 0</p>
</td></tr>
<tr><td><code id="ic.test_+3A_...">...</code></td>
<td>
<p> Further options, e.g. algorithm for <code><a href="#topic+ic.weights">ic.weights</a></code>  </p>
</td></tr>
<tr><td><code id="ic.test_+3A_digits">digits</code></td>
<td>
<p> number of digits to display </p>
</td></tr>
<tr><td><code id="ic.test_+3A_scientific">scientific</code></td>
<td>
<p> if FALSE, suppresses scientific format; 
default: FALSE </p>
</td></tr>
<tr><td><code id="ic.test_+3A_object">object</code></td>
<td>
<p>  output object from <code>ict.test</code> (of class <code>ict</code>)   </p>
</td></tr>
<tr><td><code id="ic.test_+3A_brief">brief</code></td>
<td>
<p>  if TRUE, requests brief output without restrictions (default), 
otherwise restrictions are shown with indication, which are active    </p>
</td></tr>
</table>


<h3>Details</h3>

<p> The following test problems are implemented:
</p>
<p><code>TP=1</code>: H0: restrictions valid with equality  vs.  H1: at least one inequality
</p>
<p><code>TP=2</code>: H0: all restrictions true  vs.  H1: at least one restriction false
</p>
<p><code>TP=3</code>: H0: restrictions false  vs.  H1: restrictions true (with inequality)
</p>
<p><code>TP=11</code>: H0: restriction valid with equality and further linear equalities
vs.  H1: at least one equality from H0 violated, restriction valid
</p>
<p><code>TP=21</code>: H0: restrictions valid (including some equality restrictions)
vs.  H1: at least one restriction from H0 violated, some equality restrictions
are maintained
</p>
<p>Note that TPs 1 and 11 can reject H0 even if H1 is violated by the data. 
Rejection of H0 does not provide evidence for H1 (but only against H0) in  
these TPs because H1 is not the opposite of H0. The tests concentrate their 
power in H1, but are only guaranteed to observe their level for the stated H0.
</p>
<p>Also note that TP 3 does not make sense if <code>obj</code> involves equality 
restrictions (<code>obj$meq</code>&gt;0). 
</p>
<p>Under TPs 1, 2, 11, and 21, the distributions of test statistics are mixtures 
of chi-square distributions (<code>df.error=Inf</code>) or beta-distributions (<code>df.error</code> finite) 
with different degrees of freedom (chi-square) or parameter combinations (beta). 
Shapiro (1988) gives detailed information on the mixing weights for the 
different scenarios. Basically, there are two different situations: 
</p>
<p>If <code>meq=0</code>, 
the weights are probabilities that a random variable with covariance matrix 
<code>ui%*%cov%*%t(ui)</code> is realized in the positive orthant or its 
lower-dimensional faces, respectively (if <code>ui</code> has too few 
columns, blow up by columns of 0s in appropriate positions) (Shapiro, formulae 
(5.5) or (5.10), respectively). 
</p>
<p>If <code>meq &gt; 0</code> (but not all restrictions are equality restrictions), 
the weights are probabilities that a random variable with covariance matrix the 
inverse of the lower right corner of <code>solve(ui%*%cov%*%t(ui))</code> is realized
in the positive orthant or its lower-dimensional faces, respectively 
(Shapiro, formula (5.9)).
</p>
<p>These weights must then be combined with the appropriate degrees of freedom - 
these can be worked out by realizing that either the null hypothesis or the 
alternative hypothesis has fixed dimension and the respective mixing degrees 
of freedom are obtained by taking the difference to the dimension of the 
respective other hypothesis, which is correct because - given a certain 
dimension of the inequality-restricted estimate, the inequality-restricted 
estimate is a projection onto a linear space of that dimension.
</p>
<p>The test for TP 3 (cf. e.g. Sasabuchi 1980) is based on the intersection-union 
principle and simply obtains its p-value as the maximum p-value from testing 
the individual restrictions.
</p>


<h3>Value</h3>

<p>object of class <code>ict</code>, which is a list containing elements
</p>
<table>
<tr><td><code>TP</code></td>
<td>
<p>test problem identifier (cf. argument <code>TP</code>)</p>
</td></tr>
<tr><td><code>b.unrestr</code></td>
<td>
<p>unrestricted estimate</p>
</td></tr>
<tr><td><code>b.restr</code></td>
<td>
<p>restricted estimate</p>
</td></tr>
<tr><td><code>ui</code></td>
<td>
<p>restriction matrix, LHS</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>restriction vector, RHS</p>
</td></tr>
<tr><td><code>restr.index</code></td>
<td>
<p>elements of mean referred to by <code>ui</code> and <code>ci</code></p>
</td></tr>
<tr><td><code>meq</code></td>
<td>
<p>number of equality restrictions (first <code>meq</code> rows of <code>ui</code>),
<code>meq</code> must not exceed <code>nrow(ui)-1</code></p>
</td></tr>
<tr><td><code>iact</code></td>
<td>
<p>row numbers of active restrictions (all equality restrictions
plus inequality restrictions that are met with equality 
by the solution b.restr)</p>
</td></tr>
<tr><td><code>ui.extra</code></td>
<td>
<p>additional restrictions for <code>TP=11</code>, 
calculated from input parameter <code>ui0.11</code> by projecting out
restrictions present in <code>ui</code> and - if necessary - omitting 
linearly dependent rows</p>
</td></tr>
<tr><td><code>b.eqrestr</code></td>
<td>
<p>equality-restrected estimate for <code>TP=1</code></p>
</td></tr>
<tr><td><code>b.extra.restr</code></td>
<td>
<p>estimate for null hypothesis of <code>TP=11</code> </p>
</td></tr>
<tr><td><code>T</code></td>
<td>
<p>test statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p-value</p>
</td></tr>
<tr><td><code>s2</code></td>
<td>
<p>input parameter</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>matrix with <code>s2*cov</code> equal to covariance matrix of unrestricted estimate</p>
</td></tr>
<tr><td><code>df.error</code></td>
<td>
<p>input parameter</p>
</td></tr>
<tr><td><code>df.bar</code></td>
<td>
<p>vector of degrees of freedom for test statistic distribution, 
cf. also input parameter <code>df</code></p>
</td></tr>
<tr><td><code>wt.bar</code></td>
<td>
<p>vector of weights for test statistic distribution, 
cf. also input parameter <code>wt</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>Package versions up to 1.1-4 had a bug that caused p-values for TP=11 
to be too large.</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping, BHT Berlin </p>


<h3>References</h3>

 
<p>Sasabuchi, S. (1980) A test of a multivariate normal mean with composite 
hypotheses determined by linear inequalities. <em>Biometrika</em> 
<b>67</b>, 429&ndash;429
</p>
<p>Shapiro, A. (1988) Towards a unified theory of inequality-constrained 
testing in multivariate analysis. <em>International Statistical Review</em> 
<b>56</b>, 49&ndash;62</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+ic.est">ic.est</a></code>, <code><a href="#topic+ic.weights">ic.weights</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>corr.plus &lt;- matrix(c(1,0.5,0.5,1),2,2)
corr.null &lt;- matrix(c(1,0,0,1),2,2)
corr.minus &lt;- matrix(c(1,-0.5,-0.5,1),2,2)
## unrestricted vectors
x1 &lt;- c(1, 1)
x2 &lt;- c(-1, 1)
ict1 &lt;- ic.test(ic.est(x1, corr.plus, ui=diag(c(1,1)), ci=c(0,0)))
ict1
summary(ict1)
ic.test(ic.est(x1, corr.plus, ui=diag(c(1,1)), ci=c(0,0)), s2=1, df.error=10)
ic.test(ic.est(x1, corr.minus, ui=diag(c(1,1)), ci=c(0,0)))
ic.test(ic.est(x1, corr.minus, ui=diag(c(1,1)), ci=c(0,0)), s2=1, df.error=10)
ic.test(ic.est(x2, corr.plus, ui=diag(c(1,1)), ci=c(0,0)))
ic.test(ic.est(x2, corr.plus, ui=diag(c(1,1)), ci=c(0,0)), s2=1, df.error=10)
ic.test(ic.est(x2, corr.minus, ui=diag(c(1,1)), ci=c(0,0)))
ic.test(ic.est(x2, corr.minus, ui=diag(c(1,1)), ci=c(0,0)), s2=1, df.error=10)

ict2 &lt;- ic.test(ic.est(x2, corr.plus, ui=diag(c(1,1)), ci=c(0,0)),TP=2)
summary(ict2)
ict3 &lt;- ic.test(ic.est(x1, corr.plus, ui=diag(c(1,1)), ci=c(0,0)),TP=3)
summary(ict3)

ict11 &lt;- ic.test(ic.est(x1, corr.plus, ui=c(1,1), ci=0),TP=11, ui0.11 =c(1,0))
summary(ict11)

## larger example
corr.plus &lt;- diag(1,8)
for (i in 1:7)
   for (j in (i+1):8)
     corr.plus[i,j] &lt;- corr.plus[j,i] &lt;- 0.5
u &lt;- rbind(rep(1,6), c(-1,-1,-1,1,1,1), c(-1,0,1,0,0,0), c(0,0,0,-1,0,1))
ice &lt;- ic.est(c(rep(1,4),rep(4,4)), corr.plus, ui=u, ci=rep(0,4), index=2:7, meq = 1)
ict1 &lt;- ic.test(ice,TP=1)
summary(ict1)
ict2 &lt;- ic.test(ice,TP=2)
summary(ict2)
ict11 &lt;- ic.test(ice,TP=11)
summary(ict11,digits=3)
ice &lt;- ic.est(c(rep(1,4),rep(4,4)), corr.plus, ui=u, ci=rep(0,4), index=2:7)
ict3 &lt;- ic.test(ice, TP=3)
summary(ict3)
</code></pre>

<hr>
<h2 id='ic.weights'> functions for calculating the distributions of normal distribution 
order-related likelihood ratio tests </h2><span id='topic+ic.weights'></span><span id='topic+pbetabar'></span><span id='topic+pchibar'></span>

<h3>Description</h3>

<p>Test statistics of normal distribution-based order-related likelihood ratio 
tests are often distributed as mixtures of chi-square or beta-distributions 
with different parameters. These functions determine the mixing weights and 
the cumulative distribution functions based on these.
They can be directly used and are called by function ic.test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ic.weights(corr, ...)
pchibar(x, df, wt)
pbetabar(x, df1, df2, wt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ic.weights_+3A_corr">corr</code></td>
<td>
 <p><code>corr</code> is the correlation or covariance matrix 
(or any multiple thereof) of the data or coefficients 
for which weights are to be calculated </p>
</td></tr>
<tr><td><code id="ic.weights_+3A_...">...</code></td>
<td>
 <p>... contains further arguments to be given to function 
<code>pmvnorm</code> of package <code>mvtnorm</code> for calculating 
multivariate normal rectangle probabilities; it is possible 
to select an algorithm (default in current version of <code>mvtnorm</code>: 
<code>algorithm = GenzBretz()</code>) and 
to tune weight accuracy by modifying including additional 
parameters into the algorithm specification, 
cf. help for <code>GenzBretz</code></p>
</td></tr>
<tr><td><code id="ic.weights_+3A_x">x</code></td>
<td>
 <p><code>x</code> is the quantile for which the distribution function
is to be calculated </p>
</td></tr>
<tr><td><code id="ic.weights_+3A_df">df</code></td>
<td>
<p> is the vector of the degrees of freedom for the chi-square 
distributions that are mixed into the chibar-square-distribution 
with the proportions given in <code>wt</code>
</p>
</td></tr>
<tr><td><code id="ic.weights_+3A_wt">wt</code></td>
<td>
<p> each element of <code>wt</code> is the mixing weight of the chi-square
distribution with df as in the corresponding element of <code>df</code>;
such weights can be calculated with function <code>ic.weights</code></p>
</td></tr>
<tr><td><code id="ic.weights_+3A_df1">df1</code></td>
<td>
<p> vector of first parameters of the beta-distributions to be 
mixed into the betabar-distribution </p>
</td></tr>
<tr><td><code id="ic.weights_+3A_df2">df2</code></td>
<td>
<p> second parameter of the beta-distributions to be 
mixed into the betabar-distribution; error degrees of freedom
in the tests implemented for linear models in summary.orlm;<br />
NOTE: see details for the (perhaps unexpected) constancy of <code>df2</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>ic.weights</code> uses results by Kudo (1963) 
regarding the calculation of the weights. The weights are the probabilities that 
the projection along its covariance onto the non-negative orthant 
of a multivariate normal random vector with expectation 0 and 
correlation <code>corr</code> lies in faces of dimensions <code>nrow(corr):1</code> 
(in this order). It is known that these probabilities coincide with 
various other useful probabilities related to order-related hypothesis testing,
cf. e.g. Shapiro (1988). Calculation of the weights involves various calls 
to function <code>pmvnorm</code> from package <code>mvtnorm</code>.
</p>
<p>Functions <code>pchibar</code> (taken from package ibdreg) and <code>pbetabar</code> 
calculate cumulative probabilities from mixtures of chi-square and 
beta-distributions, respectively.<br />
IMPORTANT: Contrary to likelihood ratio theory in linear models, the beta 
distributions mixed always use the error sum of squares from the unrestricted model, 
i.e. the smallest possible error sum of squares with a fixed no. of df. Therefore, 
the second df entry is not increased when decreasing the first! 
This is appropriate for the test statistics calculated by functions <code>ic.test</code> 
or <code>summary.orlm</code>, but not necessarily for test statistics obtained elsewhere. 
</p>


<h3>Value</h3>

<p><code>ic.weights</code> returns the vector of weights, 
<code>pchibar</code> and <code>pchibar</code> return the cumulative probability of the 
respective distribution. 
Function <code>ic.weights</code> relies on package <span class="pkg">mvtnorm</span> for determining 
multivariate normal rectangle probabilities. Note that these calculations 
involve Monte Carlo steps so that these weights are not completely repeatable.  
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping, BHT Berlin </p>


<h3>References</h3>

 
<p>Kudo, A. (1963) A multivariate analogue of the one-sided test. 
<em>Biometrika</em> <b>50</b>, 403&ndash;418
</p>
<p>Shapiro, A. (1988) Towards a unified theory of inequality-constrained 
testing in multivariate analysis. <em>International Statistical Review</em> 
<b>56</b>, 49&ndash;62
</p>
<p>Silvapulle, M.J. and Sen, P.K. (2004) <em>Constrained Statistical Inference</em>. 
Wiley, New York</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ic.test">ic.test</a></code>, <code><a href="#topic+orlm">orlm</a></code>, <code>pmvnorm</code>, 
<code>GenzBretz</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- 0.5
corr &lt;- matrix(c(1,0.9,0.9,1),2,2)
print(wt.plus &lt;- ic.weights(corr))
T &lt;- c(z,z)%*%solve(corr,c(z,z))
1-pchibar(T,2:0,wt.plus)
1-pbetabar(T/(T+10),2:0,10,wt.plus)
corr &lt;- matrix(c(1,0,0,1),2,2)
print(wt.0 &lt;- ic.weights(corr))
T &lt;- c(z,z)%*%solve(corr,c(z,z))
1-pchibar(T,2:0,wt.0)
1-pbetabar(T/(T+10),2:0,10,wt.0)
corr &lt;- matrix(c(1,-0.9,-0.9,1),2,2)
print(wt.minus &lt;- ic.weights(corr))
T &lt;- c(z,z)%*%solve(corr,c(z,z))
1-pchibar(T,2:0,wt.minus)
1-pbetabar(T/(T+10),2:0,10,wt.minus)
</code></pre>

<hr>
<h2 id='internal.functions'> internal functions not intended for the user </h2><span id='topic+nchoosek'></span><span id='topic+GaussianElimination'></span><span id='topic+RREF'></span>

<h3>Description</h3>

<p>nchoosek is originally taken from package vsn by Wolfgang Huber,
GaussianElimination and RREF have been provided by John Fox in R-help and
have been modified by the author to provide more output</p>


<h3>Usage</h3>

<pre><code class='language-R'>nchoosek(n, k)    ## not exported, calculates all combinations
GaussianElimination(A, B, tol=sqrt(.Machine$double.eps),
    verbose=FALSE)   ## not exported
RREF(X, ...)    ## not exported, calculates reduced Echelon form
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internal.functions_+3A_n">n</code></td>
<td>
<p> number of elements to choose from </p>
</td></tr>
<tr><td><code id="internal.functions_+3A_k">k</code></td>
<td>
<p> number of elements to choose </p>
</td></tr>
<tr><td><code id="internal.functions_+3A_a">A</code></td>
<td>
<p> argument to <code>GaussianElimination</code> </p>
</td></tr>
<tr><td><code id="internal.functions_+3A_b">B</code></td>
<td>
<p> argument to <code>GaussianElimination</code> </p>
</td></tr>
<tr><td><code id="internal.functions_+3A_tol">tol</code></td>
<td>
<p> argument to <code>GaussianElimination</code> </p>
</td></tr>
<tr><td><code id="internal.functions_+3A_verbose">verbose</code></td>
<td>
<p> argument to <code>GaussianElimination</code> </p>
</td></tr>
<tr><td><code id="internal.functions_+3A_x">X</code></td>
<td>
<p> matrix to be reduced to reduced Echelon form </p>
</td></tr>
<tr><td><code id="internal.functions_+3A_...">...</code></td>
<td>
<p> further arguments to <code>GaussianElimination</code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nchoosek</code> returns all subsets of size <code>k</code>, 
for <code>GaussianElimination</code> and <code>RREF</code> cf. comments in code. 
The latter are used for reducing a matrix with less than full row rank
to a set of linearly independent rows.
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping, BHT Berlin, 
based on code by John Fox and Wolfgang Huber </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ic.test">ic.test</a></code>, <code><a href="#topic+orlm">orlm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- 0.5
corr &lt;- matrix(c(1,0.9,0.9,1),2,2)
print(wt.plus &lt;- ic.weights(corr))
T &lt;- c(z,z)%*%solve(corr,c(z,z))
1-pchibar(T,2:0,wt.plus)
1-pbetabar(T/(T+10),2:0,10,wt.plus)
corr &lt;- matrix(c(1,0,0,1),2,2)
print(wt.0 &lt;- ic.weights(corr))
T &lt;- c(z,z)%*%solve(corr,c(z,z))
1-pchibar(T,2:0,wt.0)
1-pbetabar(T/(T+10),2:0,10,wt.0)
corr &lt;- matrix(c(1,-0.9,-0.9,1),2,2)
print(wt.minus &lt;- ic.weights(corr))
T &lt;- c(z,z)%*%solve(corr,c(z,z))
1-pchibar(T,2:0,wt.minus)
1-pbetabar(T/(T+10),2:0,10,wt.minus)
</code></pre>

<hr>
<h2 id='make.mon.ui'> Function for creating the matrix ui for monotonicity (in)equality restrictions </h2><span id='topic+make.mon.ui'></span>

<h3>Description</h3>

<p>Function <code>make.mon.ui</code> creates the matrix <code>ui</code> for a factor, depending on its coding. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.mon.ui(x, type = "coeff", contr = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.mon.ui_+3A_x">x</code></td>
<td>
<p> an <code>R</code> factor (in case of <code>type = "coeff"</code>) or 
the dimension of the multivariate normal distribution (in case of <code>type = "mean"</code>) </p>
</td></tr>
<tr><td><code id="make.mon.ui_+3A_type">type</code></td>
<td>
<p> the situation for which <code>ui</code> is needed: can be <code>coeff</code> 
for coefficients in a linear model or <code>mean</code> for the expectation vector 
of a multivariate normal distribution</p>
</td></tr>
<tr><td><code id="make.mon.ui_+3A_contr">contr</code></td>
<td>
<p> relevant in case of <code>type = "coeff"</code> only, ignored otherwise;<br />
the contrast with which <code>x</code> is coded;<br />
if the <code>contrasts</code> attribute of <code>x</code> is a character string, 
<code>contr = NULL</code> uses this character string, otherwise <code>contr = NULL</code> 
is identical to <code>contr = "contr.treatment"</code>.  
</p>
<p>Explicit choices for <code>contr</code> can be any of <code>contr.treatment</code>, 
<code>contr.SAS</code>, <code>contr.diff</code> and <code>contr.sum</code>) (must be given in quotes).<br /> 
The other generally-available 
codings (<code>contr.helmert</code> and <code>contr.poly</code>) do not 
easily permit conclusions about monotonicity.<br />
If the value for <code>contr</code> is not compatible with the factors coding, 
an error is thrown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function determines the matrix <code>ui</code> as needed for the functions in 
packge <span class="pkg">ic.infer</span>, when a monotone increase from first to last level 
of the <code>x</code> is under investigation (<code>type = "coeff"</code>) 
or when a monotone increase among the components of the expectation vector is 
investigated (<code>type = "mean"</code>). The respective monotone decrease can be accomodated 
by <code>-make.mon.ui()</code>.
</p>
<p>If the coding of the factor <code>x</code> is explicitly given, the function throws an error 
if the actual coding does not correspond to the specified value of <code>contr</code>.
</p>
<p>Care is needed when using <code>make.mon.ui</code> with a linear model: It is the users responsibility 
to make sure that the coding used in the model corresponds to the coding used in 
<code>make.mon.ui</code>.
</p>


<h3>Value</h3>

<p>a square matrix with as many rows and columns as there are dummy variables 
for the factor 
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping, BHT Berlin </p>


<h3>See Also</h3>

<p> See also <code><a href="stats.html#topic+contrasts">contrasts</a></code> for how to apply contrasts, 
<code><a href="stats.html#topic+contrast">contrast</a></code> for the available contrasts in package <span class="pkg">stats</span>, 
<code><a href="#topic+contr.diff">contr.diff</a></code> for the specific monotonicity contrast function 
from this package. </p>


<h3>Examples</h3>

<pre><code class='language-R'>gifte &lt;- boot::poisons    ## gifte is German for poisons
## default: contr.treatment (with default base 1)
linmod &lt;- lm(1/time~poison+treat, gifte)
summary(orlm(linmod, ui=make.mon.ui(gifte$poison), index=2:3))

## next: contr.diff
contrasts(gifte$poison) &lt;- "contr.diff" 
linmod &lt;- lm(1/time~poison+treat, gifte)
summary(orlm(linmod, ui=make.mon.ui(gifte$poison), index=2:3))

## next: contr.SAS
contrasts(gifte$poison) &lt;- "contr.SAS"
linmod &lt;- lm(1/time~poison+treat, gifte)
summary(orlm(linmod, ui=make.mon.ui(gifte$poison), index=2:3))

## next: contr.sum
contrasts(gifte$poison) &lt;- "contr.sum"
linmod &lt;- lm(1/time~poison+treat, gifte)
summary(orlm(linmod, ui=make.mon.ui(gifte$poison), index=2:3))


</code></pre>

<hr>
<h2 id='or.relimp'> Function to calculate relative importance for order-restricted 
linear models </h2><span id='topic+or.relimp'></span><span id='topic+or.relimp.lm'></span><span id='topic+or.relimp.default'></span><span id='topic+all.R2'></span>

<h3>Description</h3>

<p>The function calculates relative importance by averaging over the variables 
R-squared contributions from all orderings of variables for linear models with 
inequality restrictions on the parameters. 
NOTE: only useful if each restriction refers to exactly one variable,
or if it is adequate to reduce multi-variable restrictions by omitting 
the affected variables but leaving the restriction otherwise intact.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>or.relimp(model, ui, ci = NULL, ...)
## S3 method for class 'lm'
or.relimp(model, ui, ci = NULL, index = 2:length(coef(model)), meq = 0, 
     tol = sqrt(.Machine$double.eps), ...)
     
## Default S3 method:
or.relimp(model, ui, ci = NULL, index = 2:ncol(model), meq = 0, 
     tol = sqrt(.Machine$double.eps), ...)
     
all.R2(covmat, ui, ci = NULL, index = 2:ncol(covmat), meq = 0, 
     tol = sqrt(.Machine$double.eps), ...)
     ## user does not need to call this function
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="or.relimp_+3A_model">model</code></td>
<td>
<p> a linear model object of class <code>lm</code> with data included; 
for function <code>or.relimp</code>, 
all explanatory variables must be numeric (i.e. no factors), 
and higher-order terms (e.g. interactions) are not permitted. 
</p>
<p>OR
</p>
<p>the covariance matrix of the response (first position) and all regressors</p>
</td></tr>
<tr><td><code id="or.relimp_+3A_covmat">covmat</code></td>
<td>
<p> the covariance matrix of the response (first position) and all regressors</p>
</td></tr>
<tr><td><code id="or.relimp_+3A_ui">ui</code></td>
<td>
<p> cf. explanation in <code>link{orlm}</code>;
cf. also details below </p>
</td></tr>
<tr><td><code id="or.relimp_+3A_ci">ci</code></td>
<td>
<p> cf. explanation in <code>link{orlm}</code> </p>
</td></tr>
<tr><td><code id="or.relimp_+3A_index">index</code></td>
<td>
<p> cf. explanation in <code>link{orlm}</code> </p>
</td></tr>
<tr><td><code id="or.relimp_+3A_meq">meq</code></td>
<td>
<p> cf. explanation in <code>link{orlm}</code> </p>
</td></tr>
<tr><td><code id="or.relimp_+3A_tol">tol</code></td>
<td>
<p> cf. explanation in <code>link{orlm}</code> </p>
</td></tr>
<tr><td><code id="or.relimp_+3A_...">...</code></td>
<td>
<p> Further options </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>or.relimp</code> uses function <code>all.R2</code> for 
calculating the R-squared values of all subsets that are subsequently 
handed to function <code>Shapley.value</code> (from package <code>kappalab</code>), 
which takes care of the averaging over ordering. 
</p>
<p>WARNING: In models with subsets of the regressors, the 
columns of the matrix <code>ui</code> referring to regressors outside the 
current subset are simply deleted for the sub model. 
This is only reasonable if either the individual 
constraints refer to individual parameters only (e.g. all 
parameters restricted to be non-negative) or if the constraints 
are still reasonable in the sub model with some variables deleted, 
e.g. perhaps (depending on the application) sum 
of all parameters less or equal to 1.
</p>
<p>WARNING: If the number of regressors (<code>p</code>) is large, the functions 
quickly becomes unmanageable (a vector of size <code>2^p</code> is returned 
or handled in the process.
</p>


<h3>Value</h3>

<p><code>all.R2</code> returns a vector (<code>2^p</code> elements) with all R-squared values 
(<code>p</code> is the number of regressors, vector is ordered from empty to full model 
in natural order (cf. <code>ic.infer:::nchoosek</code> for the order within one model 
size).
</p>
<p><code>or.relimp</code> returns a vector (<code>p</code> elements) with average R-squared 
contributions from all models with respective subset of restrictions 
<code>ui %*% beta &gt;= ci</code> enforced. 
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping, BHT Berlin </p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+orlm">orlm</a></code> for order-restricted linear models and 
<code>calc.relimp</code> from <code>R</code>-package <code>relaimpo</code> for a much more 
comfortable and much faster routine for unrestricted linear models</p>


<h3>Examples</h3>

<pre><code class='language-R'>covswiss &lt;- cov(swiss)
## all R2-values for restricted linear model with restrictions that
## Catholic and Infant.Mortality have non-negative coefficients
R2s &lt;- all.R2(covswiss, ui=rbind(c(0,0,0,1,0),c(0,0,0,0,1)))
R2s

require(kappalab) ## directly using package kappalab
Shapley.value(set.func(R2s))  

### with convenience wrapper from this package
or.relimp(covswiss, ui=rbind(c(0,0,0,1,0),c(0,0,0,0,1)))

### also works on linear models
limo &lt;- lm(swiss)
#or.relimp(limo, ui=rbind(c(0,0,0,1,0),c(0,0,0,0,1)))

## same model using index vector
or.relimp(limo, ui=rbind(c(1,0),c(0,1)), index=5:6)

</code></pre>

<hr>
<h2 id='orlm'> Functions for order restricted linear regression estimation and testing </h2><span id='topic+orlm'></span><span id='topic+orlm.lm'></span><span id='topic+orlm.default'></span><span id='topic+boot.orlm'></span><span id='topic+orlm_forboot.fixed'></span><span id='topic+orlm_forboot'></span><span id='topic+coef.orlm'></span><span id='topic+plot.orlm'></span><span id='topic+print.orlm'></span><span id='topic+summary.orlm'></span>

<h3>Description</h3>

<p>Function orlm calculates order-restricted linear models (linear equality and 
inequality constraints). It uses the internal function boot.orlm for bootstrapping, 
which in turn uses the internal functions orlm_forboot... . 
The remaining functions extract coefficients, provide a residual plot, give a 
short printout or a more extensive summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orlm(model, ui, ci, ...)
## S3 method for class 'lm'
orlm(model, ui, ci, index = 2:length(coef(model)), meq = 0, 
    orig.out = FALSE, boot = FALSE, B = 1000, fixed = FALSE, 
    tol = sqrt(.Machine$double.eps), ...)
## Default S3 method:
orlm(model, ui, ci, index = NULL, meq = 0, 
    tol = sqrt(.Machine$double.eps), df.error = NULL, ...)
boot.orlm(model, B = 1000, fixed = FALSE, ui, ci, index, meq)
orlm_forboot.fixed(data, indices, ...)
orlm_forboot(data, indices, index = index, ...)
## S3 method for class 'orlm'
coef(object, ...)
## S3 method for class 'orlm'
plot(x, caption = "Residuals vs Fitted", 
        panel = if (add.smooth) panel.smooth else points, sub.caption = NULL, 
        main = "", ..., id.n = 3, labels.id = names(x$residuals), cex.id = 0.75, 
        add.smooth = getOption("add.smooth"), label.pos = c(4, 2), 
        cex.caption = 1)
## S3 method for class 'orlm'
print(x, digits = max(3, getOption("digits") - 3), ...)
## S3 method for class 'orlm'
summary(object, display.unrestr = FALSE, brief = FALSE, 
        digits = max(3, getOption("digits") - 3), 
        scientific = FALSE, overall.tests = TRUE, 
        bootCIs = TRUE, bty = "perc", level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orlm_+3A_model">model</code></td>
<td>
<p> a linear model object (class <code>lm</code>) with data included 
</p>
<p>OR
</p>
<p>a covariance matrix of Y and all regressors (in this order)
</p>
</td></tr>
<tr><td><code id="orlm_+3A_ui">ui</code></td>
<td>
<p> matrix (or vector in case of one single restriction only) 
defining the left-hand side of the restriction 
</p>
<p><code>ui%*%beta &gt;= ci</code>,
</p>
<p>where beta is the parameter vector;         
the first few of these restrictions can be declared equality- instead
of inequality restrictions (cf. argument <code>meq</code>); 
if only part of the elements of beta are subject to restrictions, 
the columns of <code>ui</code> can be restricted to these elements, if their 
index numbers are provided in <code>index</code>; by default, <code>index</code> 
excludes the intercept, i.e. the columns of <code>ui</code> refer to the 
non-intercept elements of <code>coef(model)</code>
</p>
<p>Rows of <code>ui</code> must be linearly independent; 
in case of linearly dependent rows the function gives an error 
message with a hint which subset of rows is independent.
Note that the restrictions must define a (possibly translated) cone,
i.e. e.g. interval restrictions on a parameter are not permitted. 
</p>
<p>See <code><a href="#topic+contr.diff">contr.diff</a></code> for examples of how to comfortably 
define various types of restriction.
</p>
</td></tr>
<tr><td><code id="orlm_+3A_ci">ci</code></td>
<td>
<p> vector on the right-hand side of the restriction (cf. <code>ui</code>) </p>
</td></tr>
<tr><td><code id="orlm_+3A_index">index</code></td>
<td>
<p> index numbers of the components of beta, 
which are subject to the specified constraints 
as <code>ui%*%beta[index] &gt;= ci</code>,
default is <code>index = 2:length(coef(model))</code>, 
i.e. <code>ui</code> is supposed to have columns for all coefficients 
except the intercept;
</p>
<p>CAUTIONs: 
</p>
<p>- <code>index</code> refers to the position of the coefficient in the model. 
The first coefficient is usually the intercept (which is therefore 
per default excluded from restrictions).
</p>
<p>- If the intercept is included into restrictions (model with intercept, 
index containing the element <code>1</code>, intercept-related column of ui 
not consisting of zeroes only), R-squared values may become unreasonable, 
if the restriction on the intercept is active. 
</p>
</td></tr>
<tr><td><code id="orlm_+3A_meq">meq</code></td>
<td>
<p> integer number (default 0) giving the number of rows of <code>ui</code> that 
are used for equality restrictions instead of inequality 
restrictions. 
</p>
</td></tr>
<tr><td><code id="orlm_+3A_orig.out">orig.out</code></td>
<td>
<p> should the original model be included in the output list ? 
(default: <code>FALSE</code>) </p>
</td></tr>
<tr><td><code id="orlm_+3A_boot">boot</code></td>
<td>
<p>should bootstrapping be conducted ? (default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="orlm_+3A_b">B</code></td>
<td>
<p> number of bootstrap samples (default: <code>1000</code>) </p>
</td></tr>
<tr><td><code id="orlm_+3A_fixed">fixed</code></td>
<td>
<p> should bootstrapping consider the sample as fixed and bootstrap 
residuals ? (default: <code>FALSE</code>) </p>
</td></tr>
<tr><td><code id="orlm_+3A_data">data</code></td>
<td>
<p> data handed to bootstrap sampling routine </p>
</td></tr>
<tr><td><code id="orlm_+3A_indices">indices</code></td>
<td>
<p> indices for sampling </p>
</td></tr>
<tr><td><code id="orlm_+3A_tol">tol</code></td>
<td>
<p>numerical tolerance value; 
estimates closer to 0 than <code>tol</code> are set to exactly 0</p>
</td></tr>
<tr><td><code id="orlm_+3A_df.error">df.error</code></td>
<td>
<p> error degrees of freedom (number of observations minus 
number of colummns of covariance matrix) for <code>orlm.default</code>;
required in order to calculate adequate covariance matrix and tests; 
valid coefficient estimates can also be obtained for arbitrary 
values of <code>df.error</code>  </p>
</td></tr>
<tr><td><code id="orlm_+3A_...">...</code></td>
<td>
<p> Further options  </p>
</td></tr>
<tr><td><code id="orlm_+3A_object">object</code></td>
<td>
<p>object of class <code>orlm</code> (created by function <code>orlm</code>)</p>
</td></tr>
<tr><td><code id="orlm_+3A_x">x</code></td>
<td>
<p>object of class <code>orlm</code> (created by function <code>orlm</code>)</p>
</td></tr>
<tr><td><code id="orlm_+3A_caption">caption</code></td>
<td>
<p> like in function <code><a href="stats.html#topic+plot.lm">plot.lm</a></code> </p>
</td></tr>
<tr><td><code id="orlm_+3A_panel">panel</code></td>
<td>
<p> like in function <code><a href="stats.html#topic+plot.lm">plot.lm</a></code> </p>
</td></tr>
<tr><td><code id="orlm_+3A_sub.caption">sub.caption</code></td>
<td>
<p> like in function <code><a href="stats.html#topic+plot.lm">plot.lm</a></code> </p>
</td></tr>
<tr><td><code id="orlm_+3A_main">main</code></td>
<td>
<p> like in function <code><a href="stats.html#topic+plot.lm">plot.lm</a></code> </p>
</td></tr>
<tr><td><code id="orlm_+3A_id.n">id.n</code></td>
<td>
<p> like in function <code><a href="stats.html#topic+plot.lm">plot.lm</a></code> </p>
</td></tr>
<tr><td><code id="orlm_+3A_labels.id">labels.id</code></td>
<td>
<p> like in function <code><a href="stats.html#topic+plot.lm">plot.lm</a></code> </p>
</td></tr>
<tr><td><code id="orlm_+3A_cex.id">cex.id</code></td>
<td>
<p> like in function <code><a href="stats.html#topic+plot.lm">plot.lm</a></code> </p>
</td></tr>
<tr><td><code id="orlm_+3A_add.smooth">add.smooth</code></td>
<td>
<p> like in function <code><a href="stats.html#topic+plot.lm">plot.lm</a></code> </p>
</td></tr>
<tr><td><code id="orlm_+3A_label.pos">label.pos</code></td>
<td>
<p> like in function <code><a href="stats.html#topic+plot.lm">plot.lm</a></code> </p>
</td></tr>
<tr><td><code id="orlm_+3A_cex.caption">cex.caption</code></td>
<td>
<p> like in function <code><a href="stats.html#topic+plot.lm">plot.lm</a></code> </p>
</td></tr>
<tr><td><code id="orlm_+3A_digits">digits</code></td>
<td>
<p> number of digits to display </p>
</td></tr>
<tr><td><code id="orlm_+3A_display.unrestr">display.unrestr</code></td>
<td>
<p> if <code>TRUE</code>, also display unrestricted model; 
default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="orlm_+3A_brief">brief</code></td>
<td>
<p> if <code>TRUE</code>, suppress printing of restrictions; 
default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="orlm_+3A_scientific">scientific</code></td>
<td>
<p> if <code>FALSE</code>, suppresses scientific format; 
default: <code>FALSE</code> </p>
</td></tr>
<tr><td><code id="orlm_+3A_overall.tests">overall.tests</code></td>
<td>
<p> if <code>FALSE</code>, suppresses output of overall model tests;
default: <code>TRUE</code>; for models with large sets of restrictions, 
tests can take up substantial time because of weight calculation </p>
</td></tr>
<tr><td><code id="orlm_+3A_bootcis">bootCIs</code></td>
<td>
<p> if <code>FALSE</code>, suppresses bootstrap confidence intervals, even 
though the <code>obj</code> contains a <code>bootout</code> element; 
default: <code>TRUE</code> </p>
</td></tr>
<tr><td><code id="orlm_+3A_bty">bty</code></td>
<td>
<p> type of bootstrap confidence interval; any of 
<code>"perc"</code>, <code>"bca"</code>, <code>"norm"</code> or <code>"basic"</code>, 
cf. function <code>boot.ci</code> from package <code>boot</code>,
default: <code>"perc"</code> </p>
</td></tr>
<tr><td><code id="orlm_+3A_level">level</code></td>
<td>
<p> confidence level for bootstrap confidence intervals,
default: <code>0.95</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>orlm</code> performs order restricted linear model analysis. 
Functions <code>coef.orlm</code>, <code>plot.orlm</code>, <code>print.orlm</code>, and 
<code>summary.orlm</code> provide methods for reporting the results on an object 
of S3 class orlm. The functions directly referring to bootstrapping are internal 
and should not be called by the user but are called from within function <code>orlm</code> 
if option <code>boot</code> is set to <code>TRUE</code>.
</p>
<p>Of course, bootstrapping is not possible, if function <code>orlm</code> is applied 
to a covariance matrix, since the raw data are not available in this case. Also 
note that the intercept is not estimated in this case but can easily be estimated 
from the resulting estimate if the variable means are known (cf. example).
</p>
<p>The output from summary.orlm provides information about the restrictions, 
a comparison of $R^2$-values for unrestricted and restricted model, 
restricted estimates, and 
</p>
<p>- if requested (option <code>boot</code> set to <code>TRUE</code> in function <code>orlm</code> and 
option <code>bootCIs</code> set to <code>TRUE</code> in the summary function)
with bootstrap confidence intervals, 
</p>
<p>- if requested (option <code>overall.tests</code> set to <code>TRUE</code>) 
several restriction-related tests (implemented by calls to <code>ic.test</code>):
The analogue to the overall F-Test in the ordinary linear model is the test of 
all coefficients but intercept equal to 0 within the restricted parameter 
space. In addition, three tests related to the restriction are reported:
</p>
<p>Test 1: H0: Restriction valid with equality  vs. H1: at least one inequality
</p>
<p>Test 2: H0: Restriction valid   vs.  H1: restriction violated
</p>
<p>Test 3: H0: Restriction violated or valid with equality 
vs. H1: all restrictions valid with inequality
</p>
<p>Test 3 is conducted in case of no equality-restrictions only.
</p>


<h3>Value</h3>

<p>The output of function <code>orlm</code> belongs to S3 classes <code>orlm</code> and <code>orest</code>. 
It is a list with the following items:
</p>
<table>
<tr><td><code>b.restr</code></td>
<td>
<p>restricted estimate</p>
</td></tr>
<tr><td><code>b.unrestr</code></td>
<td>
<p>unrestricted estimate</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p>R-squared</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p> residuals of restricted model</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>fitted values of restricted model</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>observation weights </p>
</td></tr>
<tr><td><code>orig.R2</code></td>
<td>
<p>R-squared of unrestricted model</p>
</td></tr>
<tr><td><code>df.error</code></td>
<td>
<p>error degrees of freedom of unrestricted model</p>
</td></tr>
<tr><td><code>s2</code></td>
<td>
<p>MSE of unrestricted model</p>
</td></tr>
<tr><td><code>Sigma</code></td>
<td>
<p>variance covariance matrix of beta-hat in unrestricted model</p>
</td></tr>
<tr><td><code>origmodel</code></td>
<td>
<p>unrestricted model itself (<code>NULL</code>, 
if <code>orig.out=FALSE</code>)</p>
</td></tr>
<tr><td><code>ui</code></td>
<td>
<p> as input</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p> as input</p>
</td></tr>
<tr><td><code>restr.index</code></td>
<td>
<p> the input vector index </p>
</td></tr>
<tr><td><code>meq</code></td>
<td>
<p> as input</p>
</td></tr> 
<tr><td><code>iact</code></td>
<td>
<p> active restrictions, i.e. restrictions that are satisfied with 
equality in the solution, as output by <code>solve.QP</code></p>
</td></tr> 
<tr><td><code>bootout</code></td>
<td>
<p>object of class boot obtained by bootstrapping, 
will be used by summary.orlm for calculating bootstrap confidence 
intervals; <code>NULL</code> if <code>boot=FALSE</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>Package versions up to 1.1-4 had a bug in function ic.test that caused 
the p-value of the overall model test to be too large.</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping, BHT Berlin </p>


<h3>References</h3>

<p> Shapiro, A. (1988) Towards a unified theory of inequality-constrained 
testing in multivariate analysis. <em>International Statistical Review</em> 
<b>56</b>, 49&ndash;62</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+ic.est">ic.est</a></code>, <code><a href="#topic+ic.test">ic.test</a></code>, 
<code><a href="#topic+or.relimp">or.relimp</a></code>, <code>solve.QP</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>limo &lt;- lm(swiss)
## restricted linear model with restrictions that
## - Education and Examination have same coefficient
## - Catholic and Infant.Mortality have non-negative coefficients
orlimo &lt;- orlm(limo, ui=rbind(c(0,1,-1,0,0),c(0,0,0,1,0),c(0,0,0,0,1)), meq=1)
orlimo
plot(orlimo)
summary(orlimo)
## same model using index vector
orlimo &lt;- orlm(limo, ui=rbind(c(1,-1,0,0),c(0,0,1,0),c(0,0,0,1)), index=3:6, meq=1)

## reduced number of bootstrap samples below reasonable size for example run time
orlimo &lt;- orlm(limo, ui=rbind(c(1,-1,0,0),c(0,0,1,0),c(0,0,0,1)), 
    index=3:6, meq=1, boot=TRUE, B=100)
summary(orlimo)

## bootstrap considering data as fixed 
orlimof &lt;- orlm(limo, ui=rbind(c(1,-1,0,0),c(0,0,1,0),c(0,0,0,1)), 
    index=3:6, meq=1, boot=TRUE, B=100, fixed=TRUE)
summary(orlimof, brief=TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
