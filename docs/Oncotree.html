<!DOCTYPE html><html><head><title>Help for package Oncotree</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Oncotree}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Oncotree-package'>
<p>Constructing and evaluating oncogenetic trees</p></a></li>
<li><a href='#ancestors'><p>Find ancestors within an oncogenetic tree.</p></a></li>
<li><a href='#bootstrap'><p>Bootstrap an oncogenetic tree to assess stability</p></a></li>
<li><a href='#distribution.oncotree'><p>Find the event distribution defined by an oncogenetic tree</p></a></li>
<li><a href='#error.rates&lt;-'><p>Set the error rates of an oncotree manually</p></a></li>
<li><a href='#generate.data'><p>Generate random data from an oncogenetic tree</p></a></li>
<li><a href='#internal.oncotree'><p>Undocumented internal functions for the Oncotree package</p></a></li>
<li><a href='#oncotree'><p>Build and display an oncogenetic tree</p></a></li>
<li><a href='#ov.cgh'><p>Ovarian cancer CGH data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimating Oncogenetic Trees</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-26</td>
</tr>
<tr>
<td>Author:</td>
<td>Aniko Szabo, Lisa Pappas</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aniko Szabo &lt;aszabo@mcw.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.3.1), boot</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lattice</td>
</tr>
<tr>
<td>Description:</td>
<td>Construct and evaluate directed tree structures that
   model the process of occurrence of genetic alterations during carcinogenesis
   as described in Szabo, A. and Boucher, K (2002)  &lt;<a href="https://doi.org/10.1016%2FS0025-5564%2802%2900086-X">doi:10.1016/S0025-5564(02)00086-X</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/anikoszabo/Oncotree">https://github.com/anikoszabo/Oncotree</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/anikoszabo/Oncotree/issues">https://github.com/anikoszabo/Oncotree/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-27 22:17:39 UTC; aszabo</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-27 22:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Oncotree-package'>
Constructing and evaluating oncogenetic trees
</h2><span id='topic+Oncotree-package'></span><span id='topic+Oncotree'></span>

<h3>Description</h3>

<p>Oncogenetic trees are directed tree structures that  model the process of
occurrence of genetic alterations during carcinogenesis.
</p>


<h3>Details</h3>

<p>A <b>pure oncogenetic tree</b> is a directed rooted tree <em>T</em> with a
probability <code class="reqn">\pi (e)</code> attached to each edge <em>e</em> such that
for every vertex there is a unique directed path from the root to
it along the edges of the tree. This tree
generates observations on the presence/absence of genetic events the following
way: each edge <em>e</em> is independently retained with probability <code class="reqn">\pi
(e)</code>; the set of vertices that are still reachable from the root 
gives the set of the observed genetic events.
</p>
<p>To describe random deviations from the pure tree model an error model
is added. 
</p>
<p><strong>Error model</strong>
</p>

<ol>
<li><p> The tumor develops according to the pure oncogenetic tree
model
</p>
</li>
<li><p> The presence/absence of each alteration is independently
measured
</p>
</li>
<li><p> If the alteration is present it is not observed with
probability <code class="reqn">\epsilon_-</code>.
</p>
<p>If the alteration is absent it is observed with
probability <code class="reqn">\epsilon_+</code>.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Lisa Pappas, Aniko Szabo
</p>
<p>Maintainer: Aniko Szabo &lt;aszabo@mcw.edu&gt;
</p>


<h3>References</h3>

<p>[1] Desper R., Jiang F., Kallioniemi O.P., Moch H., Papadimitriou C.H., and
Sch\&quot;affer  A.A. (1999) Inferring tree models for oncogenesis from comparative genome
hybridization data. <em>Journal of Computational Biology</em>. <b>6</b>m 37&ndash;51.
[2] Szabo, A. and Boucher, K. (2002) Estimating an oncogenetic
tree when false negative and positives are present. <em>Mathematical Biosciences</em>,
<b>176</b>/2, 219&ndash;236.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(ov.cgh)
  ov.tree &lt;- oncotree.fit(ov.cgh)
  plot(ov.tree, edge.weights="estimated")
</code></pre>

<hr>
<h2 id='ancestors'>Find ancestors within an oncogenetic tree.</h2><span id='topic+ancestors'></span><span id='topic+least.common.ancestor'></span>

<h3>Description</h3>

<p><code>ancestors</code> finds all the ancestors of the given vertex within the tree starting from itself up to the root. <code>least.common.ancestor</code> finds the common ancestor of two vertices that is closest to them (and farthest from the root).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ancestors(otree, vertex)
   least.common.ancestor(otree, v1, v2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ancestors_+3A_otree">otree</code></td>
<td>
<p>An object of class <code>oncotree</code>.</p>
</td></tr>
<tr><td><code id="ancestors_+3A_vertex">vertex</code>, <code id="ancestors_+3A_v1">v1</code>, <code id="ancestors_+3A_v2">v2</code></td>
<td>
<p>Character values giving the names of the nodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>ancestors</code>: a character vector giving the names of the ancestors of <code>vertex</code>. The first element is <code>vertex</code>, and the last one is &ldquo;Root&rdquo;.
</p>
<p>For <code>least.common.ancestor</code>: a character value with the name of the least common ancestor of <code>v1</code> and <code>v2</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+oncotree.fit">oncotree.fit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(ov.cgh)
  ov.tree &lt;- oncotree.fit(ov.cgh)
  ancestors(ov.tree, "4q-")
  ancestors(ov.tree, "Xp-")
  least.common.ancestor(ov.tree, "4q-","Xp-")  #"5q-"
</code></pre>

<hr>
<h2 id='bootstrap'>Bootstrap an oncogenetic tree to assess stability</h2><span id='topic+bootstrap.oncotree'></span><span id='topic+print.boottree'></span><span id='topic+plot.boottree'></span>

<h3>Description</h3>

<p><code>bootstrap.oncotree</code> provides a set of resampling
based estimates of the oncogenetic tree. Both a parametric and 
non-parametric approach is available. The <code>print</code> and 
<code>plot</code> methods provide interfaces for printing a summary and
plotting the resulting set of trees.</p>


<h3>Usage</h3>

<pre><code class='language-R'>   bootstrap.oncotree(otree, R, type = c("nonparametric", "parametric"))
   ## S3 method for class 'boottree'
print(x, ...)
   ## S3 method for class 'boottree'
plot(x, minfreq=NULL, minprop=NULL, nboots=NULL, draw.orig=TRUE,
                           draw.consensus=TRUE, fix.nodes=FALSE, 
                           ask=(prod(par("mfrow"))&lt;ntrees)&amp;&amp;dev.interactive(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap_+3A_otree">otree</code></td>
<td>
<p>An object of class <code>oncotree</code>.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_r">R</code></td>
<td>
<p>The number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_type">type</code></td>
<td>
<p>The type of bootstrap - see Details for explanations.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_x">x</code></td>
<td>
<p>An object of class <code>boottree</code> - the output of <code>bootstrap.oncotree</code></p>
</td></tr>
<tr><td><code id="bootstrap_+3A_minfreq">minfreq</code></td>
<td>
<p>A lower limit on the occurrence frequency of the tree in &ldquo;boottree&rdquo; for plotting. By default, all unique trees are plotted, which can lead to a large number of plots.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_minprop">minprop</code></td>
<td>
<p>A lower limit on the occurrence proportion of the tree in &ldquo;boottree&rdquo; for plotting.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_nboots">nboots</code></td>
<td>
<p>A lower limit on the number of bootstrapped trees plotted.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_draw.orig">draw.orig</code></td>
<td>
<p>logical; if TRUE the original tree is plotted.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_draw.consensus">draw.consensus</code></td>
<td>
<p>logical; if TRUE the consensus tree is plotted (see Details).</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_fix.nodes">fix.nodes</code></td>
<td>
<p>logical; if TRUE, the nodes for all trees are kept in the same position. If <code>node.coords</code>
is passed as an argument to <code><a href="#topic+plot.oncotree">plot.oncotree</a></code>, then those coordinates are used for all trees, otherwise
the coordinates computed for the original tree are used.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_ask">ask</code></td>
<td>
<p>logical; if TRUE, the user is <em>ask</em>ed before each plot, see <code><a href="graphics.html#topic+par">par</a></code>(ask=.).</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_...">...</code></td>
<td>
<p>Ignored for <code>print</code>. Passed to <code><a href="#topic+plot.oncotree">plot.oncotree</a></code>
for the <code>plot</code> method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Parametric bootstrap:</b> This approach assumes that the model is correct. Based on <code>otree</code>, a random data set is generated R times using <code><a href="#topic+generate.data">generate.data</a></code>. An oncogenetic tree is fitted to each of these random data sets. 
</p>
<p><b>Non-parametric bootstrap:</b> The samples (rows) from the data associated with the tree are resampled with replacement R times, each time obtaining a data set with the same sample size. An oncogenetic tree is fitted to each of these resampled data sets. 
</p>
<p>For both approaches, a <em>consensus tree</em> that assigns to each vertex the parent that occurs most frequently in the bootstrapped trees, is also computed.
</p>


<h3>Value</h3>

<p>For <code>bootstrap.oncotree</code>: an object of class <code>boottree</code> with the following components:
</p>
<table>
<tr><td><code>original</code></td>
<td>
<p>The <code>parent</code> component of the original tree (<code>otree</code>).</p>
</td></tr>
<tr><td><code>consensus</code></td>
<td>
<p>A numeric vector with the <code>parent$parent.num</code> component of the consensus tree - this defines the tree structure uniquely.</p>
</td></tr>
<tr><td><code>parent.freq</code></td>
<td>
<p>A matrix giving the number of trees with each possible child-parent edge. The rows correspond to children while the column to parents.</p>
</td></tr>
<tr><td><code>tree.list</code></td>
<td>
<p>A data frame with each row representing a unique tree obtained during the bootstrap.  The &lsquo;Tree&rsquo; variable contains the <code>parent$parent.num</code> component of the tree (each pasted into one dot-separated string), while the &lsquo;Freq&rsquo; variable gives the frequency of the tree among the R bootstrap replicates.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>A character value with the type of the bootstrap performed.</p>
</td></tr>
</table>
<p>For <code>print.boottree</code>:
the original object is returned invisibly. It prints a summary showing the number of replicates, the number of unique trees found, and the number of times that the original tree was obtained.
</p>
<p>For <code>plot.oncotree</code>:
nothing is returned. It is used for its side effect of producing a sequence of plots of the bootstrapped trees. Specifically, it plots the original tree (if <code>draw.orig=TRUE</code>), the consensus tree (if <code>draw.consensus=TRUE</code>), and then the other trees by frequency of occurrence. To limit the number of bootstrapped trees plotted, specify exactly one of <code>minfreq</code>, <code>minprop</code> or <code>nboots</code>. By default, if the session is interactive, the user is asked for confirmation before each new tree is drawn. To avoid this, either use <code>ask=FALSE</code> in the function call, or set up a layout that fits all the trees. 
</p>


<h3>Author(s)</h3>

<p>Lisa Pappas, Aniko Szabo</p>


<h3>See Also</h3>

<p><code><a href="#topic+oncotree.fit">oncotree.fit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>   data(ov.cgh)
   ov.tree &lt;- oncotree.fit(ov.cgh[1:5])
   set.seed(43636)
   ov.b1 &lt;- bootstrap.oncotree(ov.tree, R=100, type="parametric")
   ov.b1
   opar &lt;- par(mfrow=c(3,2), mar=c(2,0,0,0))
   plot(ov.b1, nboots=4)
   plot(ov.b1, nboots=4, fix.nodes=TRUE)
   par(opar)
</code></pre>

<hr>
<h2 id='distribution.oncotree'>Find the event distribution defined by an oncogenetic tree</h2><span id='topic+distribution.oncotree'></span><span id='topic+marginal.distr'></span>

<h3>Description</h3>

<p><code>distribution.oncotree</code> calculates the joint distribution
of the events defined by the tree, while <code>marginal.distr</code>
calculates the marginal probability of occurrence of each event.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   distribution.oncotree(otree, with.probs = TRUE, with.errors=FALSE,
          edge.weights=if (with.errors) "estimated" else "observed")
   marginal.distr(otree, with.errors = TRUE,
          edge.weights=if (with.errors) "estimated" else "observed")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distribution.oncotree_+3A_otree">otree</code></td>
<td>
<p>An object of class <code>oncotree</code>. </p>
</td></tr>
<tr><td><code id="distribution.oncotree_+3A_with.probs">with.probs</code></td>
<td>
<p>A logical value specifying if only the set of
possible outcomes should be returned (if TRUE), or the associated
probabilities of occurrence as well.</p>
</td></tr>
<tr><td><code id="distribution.oncotree_+3A_with.errors">with.errors</code></td>
<td>
<p>A logical value specifying whether false
positive and negative error rates should be incorporated into
the distribution.</p>
</td></tr> 
<tr><td><code id="distribution.oncotree_+3A_edge.weights">edge.weights</code></td>
<td>
<p>A choice of whether the observed or estimated
edge transition probabilities should be used in the calculation
of probabilities. See <code><a href="#topic+oncotree.fit">oncotree.fit</a></code> for explanation
of the difference. By default, estimated edge transition probabilities
if <code>with.errors=TRUE</code> and the observed ones if 
<code>with.errors=FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>distribution.oncotree</code>: a data frame each row of which
gives a possible outcome. 






</p>
<p>For <code>marginal.distr</code>: a named numeric vector - the names
are the event names (+ &lsquo;Root&rsquo;) and the values are the
corresponding marginal probability of occurrence.   
</p>


<h3>Author(s)</h3>

<p>Aniko Szabo</p>


<h3>See Also</h3>

<p><code><a href="#topic+oncotree.fit">oncotree.fit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>   data(ov.cgh)
   ov.tree &lt;- oncotree.fit(ov.cgh[1:5])
   
   #joint distribution
   jj &lt;- distribution.oncotree(ov.tree, edge.weights="obs")
   head(jj)
   # including errors - time/size exponential in number of events
   jj.eps &lt;- distribution.oncotree(ov.tree, with.errors=TRUE)
   head(jj.eps)
  
   #marginal distribution
   marginal.distr(ov.tree, with.error=FALSE)
   #marginal distribution calculated from the joint
   apply(jj[1:ov.tree$nmut], 2, function(x){sum(x*jj$Prob)})
   
   ##Same with errors incorporated
   #marginal distribution
   marginal.distr(ov.tree, with.error=TRUE)
   #marginal distribution calculated from the joint
   apply(jj.eps[1:ov.tree$nmut], 2, function(x){sum(x*jj.eps$Prob)})
   
</code></pre>

<hr>
<h2 id='error.rates+26lt+3B-'>Set the error rates of an oncotree manually</h2><span id='topic+error.rates+3C-'></span>

<h3>Description</h3>

<p>Allows to set the false positive and false negative error rate associated with an object of class <code>oncotree</code> to values other than those found by the optimization in <code><a href="#topic+oncotree.fit">oncotree.fit</a></code>. The estimated edge transition probabilities are updated appropriately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>error.rates(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="error.rates+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>An object of class <code>oncotree</code>.</p>
</td></tr>
<tr><td><code id="error.rates+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>A numeric vector of length 2. The false positive error rate will be set to <code>value[1]</code>, while the false negative error rate to <code>value[2]</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+oncotree.fit">oncotree.fit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(ov.cgh)
  ov.tree &lt;- oncotree.fit(ov.cgh)
  ov.tree
  error.rates(ov.tree) &lt;- c(0,0)
  ov.tree
</code></pre>

<hr>
<h2 id='generate.data'>Generate random data from an oncogenetic tree</h2><span id='topic+generate.data'></span>

<h3>Description</h3>

<p>Generates random event occurrence data based on an oncogenetic
tree model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.data(N, otree, with.errors=TRUE,
          edge.weights=if (with.errors) "estimated" else "observed",
          method=c("S","D1","D2"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.data_+3A_n">N</code></td>
<td>
<p>The required sample size.</p>
</td></tr>
<tr><td><code id="generate.data_+3A_otree">otree</code></td>
<td>
<p>An object of the class <code>oncotree</code>.</p>
</td></tr>
<tr><td><code id="generate.data_+3A_with.errors">with.errors</code></td>
<td>
<p>A logical value specifying whether false
positive and negative errors should be applied.</p>
</td></tr> 
<tr><td><code id="generate.data_+3A_edge.weights">edge.weights</code></td>
<td>
<p>A choice of whether the observed or estimated
edge transition probabilities should be used in the calculation
of probabilities. See <code><a href="#topic+oncotree.fit">oncotree.fit</a></code> for explanation
of the difference. By default, estimated edge transition probabilities
if <code>with.errors=TRUE</code> and the observed ones if 
<code>with.errors=FALSE</code>.</p>
</td></tr>
<tr><td><code id="generate.data_+3A_method">method</code></td>
<td>
<p>Simulation method, see Details for explanation of the options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three choices for the method of simulation; the best choice depends
on the size of the tree, required sample size, and whether errors are needed.
</p>
<p>Method &ldquo;S&rdquo; generates the data based on the conditional probability definition
of the oncogenetic tree, and then &lsquo;corrupts&rsquo; the resulting sample by 
introducing random errors. This method is applicable in all circumstances, but can
be slower than other methods if <code>N</code> is large and <code>with.errors=FALSE</code> 
is used.
</p>
<p>Method &ldquo;D1&rdquo; calculates the joint distribution generated by the
tree exactly (using <code><a href="#topic+distribution.oncotree">distribution.oncotree</a></code>),
and the observations are generated by sampling this distribution. Thus if 
<code>with.errors=TRUE</code> and the tree is large, this method might fail due 
to the exponential growth in the number of potential outcomes. On the 
other hand, for a moderately sized tree and a large desired sample size
<code>N</code> this is the most efficient method.
</p>
<p>Method &ldquo;D2&rdquo; calculates the joint distribution generated by the tree without
false positives/negatives, samples from it, and then &lsquo;corrupts&rsquo; the 
resulting sample. If  <code>with.errors=FALSE</code> is used then this method is 
equivalent to method &ldquo;D1&rdquo;.
</p>


<h3>Value</h3>

<p>A data set where each row is an independent observation.
</p>


<h3>Author(s)</h3>

<p> Aniko Szabo </p>


<h3>See Also</h3>

<p><code><a href="#topic+oncotree.fit">oncotree.fit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>   data(ov.cgh)
   ov.tree &lt;- oncotree.fit(ov.cgh[1:5])
   
   set.seed(7365)
   rd &lt;- generate.data(200, ov.tree, with.errors=TRUE)
   
   #compare timing of methods
   system.time(generate.data(20, ov.tree, with.errors=TRUE, method="S"))
   system.time(generate.data(20, ov.tree, with.errors=TRUE, method="D1"))
   system.time(generate.data(20, ov.tree, with.errors=TRUE, method="D2"))

</code></pre>

<hr>
<h2 id='internal.oncotree'>Undocumented internal functions for the Oncotree package</h2><span id='topic+build.parent'></span><span id='topic+build.plot'></span><span id='topic+formatData'></span>

<h3>Description</h3>

<p>These functions should not be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  build.parent(x)
  build.plot(parent)
  formatData(dataset)
</code></pre>

<hr>
<h2 id='oncotree'>Build and display an oncogenetic tree</h2><span id='topic+oncotree.fit'></span><span id='topic+print.oncotree'></span><span id='topic+plot.oncotree'></span><span id='topic+pstree.oncotree'></span>

<h3>Description</h3>

<p>Build a directed tree structure to model the process of occurrence
of genetic alterations (events) in carcinogenesis. The model is
described in more detail in <code><a href="#topic+Oncotree-package">Oncotree-package</a></code>. Methods for 
printing a short summary, displaying the tree on an R plot, and producing
latex code for drawing the tree (using the &lsquo;pstricks&rsquo; and &lsquo;pst-tree&rsquo; LaTeX packages) 
are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  oncotree.fit(dataset, error.fun = function(x, y){sum((x - y)^2)})
  ## S3 method for class 'oncotree'
print(x, ...)
  ## S3 method for class 'oncotree'
plot(x, edge.weights = c("none", "observed", "estimated"),
    edge.digits=2, node.coords=NULL, plot=TRUE, cex = par("cex"), 
		col.edge=par("col"), col.text=par("col"), col.weight=par("col"),...)
            
  pstree.oncotree(x, edge.weights=c("none","observed","estimated"), edge.digits=2,
                  shape=c("none","oval", "circle", "triangle", "diamond"),
                  pstree.options=list(arrows="-&gt;", treefit="loose", 
                                      arrowscale="1.5 0.8", nodesep="3pt"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oncotree_+3A_dataset">dataset</code></td>
<td>
<p>A data frame or a matrix with variable names as 
a listing of genetic events taking on binary values indicating 
missing (0) or present (1). Each row is an independent sample.</p>
</td></tr>
<tr><td><code id="oncotree_+3A_error.fun">error.fun</code></td>
<td>
<p>A function of two variables that measures the 
deviation of the observed marginal frequencies of the events 
(which will be the first argument in the call) from the estimated ones. 
The false positive and negative error rates are obtained by  minimizing 
<code>error.fun</code>. If <code>error.fun=NULL</code> is used, the error rates are not estimated.</p>
</td></tr>
<tr><td><code id="oncotree_+3A_x">x</code></td>
<td>
<p>An object of class <code>oncotree</code>.</p>
</td></tr>
<tr><td><code id="oncotree_+3A_edge.weights">edge.weights</code></td>
<td>
<p>Choice of edge weights to show on the plot.</p>
</td></tr>
<tr><td><code id="oncotree_+3A_edge.digits">edge.digits</code></td>
<td>
<p>The number of significant digits to use when displaying edge weights.</p>
</td></tr>
<tr><td><code id="oncotree_+3A_node.coords">node.coords</code></td>
<td>
<p>A matrix with node-coordinates or NULL if the coordinates should be
computed automatically (default).</p>
</td></tr>
<tr><td><code id="oncotree_+3A_plot">plot</code></td>
<td>
<p>Logical; indicates whether the tree should be plotted.</p>
</td></tr>
<tr><td><code id="oncotree_+3A_cex">cex</code></td>
<td>
<p>Scaling factor for the text in the nodes.</p>
</td></tr>
<tr><td><code id="oncotree_+3A_col.edge">col.edge</code></td>
<td>
<p>color of the tree edges.</p>
</td></tr>
<tr><td><code id="oncotree_+3A_col.text">col.text</code></td>
<td>
<p>color of the node label.</p>
</td></tr>
<tr><td><code id="oncotree_+3A_col.weight">col.weight</code></td>
<td>
<p>color of the edge weights.</p>
</td></tr>
<tr><td><code id="oncotree_+3A_...">...</code></td>
<td>
<p>Ignored for <code>print</code>. For <code>plot</code> these can
be graphical parameters passed to <code>lines</code> when the edges are
drawn</p>
</td></tr>
<tr><td><code id="oncotree_+3A_shape">shape</code></td>
<td>
<p>The shape of the node in the pst-tree representation.</p>
</td></tr>
<tr><td><code id="oncotree_+3A_pstree.options">pstree.options</code></td>
<td>
<p>Additional options for pst-tree. See the pstricks
documentation for possible values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;pst-tree&rsquo; is a very flexible package, and very detailed formatting of the tree
is possible. <code>pstree.oncotree</code> provides some default settings for drawing
trees, but they can be easily overridden: most options can be set in 
<code>pstree.options</code>, while the appearance of the tree nodes can be controlled
by defining a one-parameter <code>\lab</code> command that gives the desired appearance. 
For example, if red, non-mathematical test is desired in an oval, you could use
<code>\newcommand{\lab}[1]{\Toval[name=#1]{{\red #1}}}</code>.
</p>


<h3>Value</h3>

<p>For <code>oncotree.fit</code>:
an object of class <code>oncotree</code> which has components
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>data frame used, after dropping events with zero observed frequency,
and adding a column for the artificial &lsquo;Root&rsquo; node</p>
</td></tr>
<tr><td><code>nmut</code></td>
<td>
<p>number of tree nodes: the number genetic events present in data +1 for the &lsquo;Root&rsquo; node</p>
</td></tr>
<tr><td><code>parent</code></td>
<td>
<p>a list containing information about the tree structure with the following components
</p>
 
<ul>
<li><p>childa character vector of the event names starting with &lsquo;Root&rsquo;
</p>
</li>
<li><p>parenta character vector of the names of the parents of <code>child</code>
</p>
</li>
<li><p>parent.numa numeric vector with column indices corresponding to <code>parent</code>
</p>
</li>
<li><p>obs.weightsraw edge transition probabilities P(child|parent)
</p>
</li>
<li><p>est.weightsedge transition probabilities adjusted for the error rates <code>eps</code></p>
</li></ul>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>a numeric vector of the depth of each node in the tree (1 for the root, 2 for its children, etc.)</p>
</td></tr>
<tr><td><code>numchild</code></td>
<td>
<p>a numeric vector giving the number of children for each node</p>
</td></tr>
<tr><td><code>levelnodes</code></td>
<td>
<p>a numeric vector of the number of nodes found at each level of the tree</p>
</td></tr>
<tr><td><code>levelgrp</code></td>
<td>
<p>a character matrix with its rows giving the ordered nodes at each level</p>
</td></tr>
<tr><td><code>eps</code></td>
<td>
<p>a numeric vector of length two showing the estimated false positive and negative error rates (if <code>error.fun</code> is not NULL). Do not modify directly, but rather through <code><a href="#topic+error.rates+3C-">error.rates&lt;-</a></code>.</p>
</td></tr>
</table>
<p>For <code>print.oncotree</code>:
</p>
<p>the original object is returned invisibly. It prints a summary showing the number of nodes, the parent-child relationships, and the false positive and negative error rates.
</p>
<p>For <code>plot.oncotree</code>:
</p>
<p>a matrix with node-coordinates is returned invisibly. The column names of the matrix are the
names of the nodes/events (including 'Root'), the rows gives the x- and y-coordinates, respectively.
This matrix provides a valid input for <code>node.coords</code>. If <code>plot=TRUE</code>, a plot of the tree is produced.
</p>
<p>For <code>pstree.oncotree</code>:
</p>
<p>a character string with the LaTeX code needed to draw a tree. <code>\usepackage{pstricks,pst-tree}</code>
is required in the preamble of the LaTeX file, and it should be processed through
a PostScript intermediary (DVIPS or similar) and not through PDFLaTeX.
</p>


<h3>Author(s)</h3>

<p>Lisa Pappas</p>


<h3>References</h3>

<p>Szabo, A. and Boucher, K. (2002) Estimating an oncogenetic tree when false negative and positives are present. Mathematical Biosciences, 176/2, 219-236.</p>


<h3>See Also</h3>

<p><code><a href="#topic+bootstrap.oncotree">bootstrap.oncotree</a></code>,<code><a href="#topic+error.rates+3C-">error.rates&lt;-</a></code>,
<code><a href="#topic+generate.data">generate.data</a></code>,<code><a href="#topic+ancestors">ancestors</a></code>,<code><a href="#topic+distribution.oncotree">distribution.oncotree</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(ov.cgh)
  ov.tree &lt;- oncotree.fit(ov.cgh, error.fun=function(x,y){max(abs(x-y))})
  ov.tree
  nodes &lt;- plot(ov.tree, edge.weights="est")
  #move the Root node to the left
  nodes["x","Root"] &lt;- nodes["x","8q+"]
  plot(ov.tree, node.coords=nodes)
  #output for pstricks+pst-tree
  pstree.oncotree(ov.tree, edge.weights="obs", shape="oval")
</code></pre>

<hr>
<h2 id='ov.cgh'>Ovarian cancer CGH data</h2><span id='topic+ov.cgh'></span>

<h3>Description</h3>

<p>This is a data set obtained using the comparative genomic hybridization
technique (CGH) on samples from papillary serous cystadenocarcinoma
of the ovary. Only the seven most commonly occurring events are
given.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ov.cgh)</code></pre>


<h3>Format</h3>

<p>A data frame with 87 observations on the following 7 variables.
</p>

<dl>
<dt><code>8q+</code></dt><dd><p>a 0/1 indicator of the presence of the &lsquo;8q+&rsquo; event</p>
</dd>
<dt><code>3q+</code></dt><dd><p>a 0/1 indicator of the presence of the &lsquo;3q+&rsquo; event</p>
</dd>
<dt><code>5q-</code></dt><dd><p>a 0/1 indicator of the presence of the &lsquo;5q-&rsquo; event</p>
</dd>
<dt><code>4q-</code></dt><dd><p>a 0/1 indicator of the presence of the &lsquo;4q-&rsquo; event</p>
</dd>
<dt><code>8p-</code></dt><dd><p>a 0/1 indicator of the presence of the &lsquo;8p-&rsquo; event</p>
</dd>
<dt><code>1q+</code></dt><dd><p>a 0/1 indicator of the presence of the &lsquo;1q+&rsquo; event</p>
</dd>
<dt><code>Xp-</code></dt><dd><p>a 0/1 indicator of the presence of the &lsquo;Xp-&rsquo; event</p>
</dd>
</dl>



<h3>Details</h3>

<p>The CGH technique uses fluorescent staining to
detect abnormal (increased or decreased) number of DNA copies.
Often the results are reported as a gain or loss on a certain arm,
without further distinction for specific regions. It is common to 
denote a change in DNA copy number on a specific chromosome arm by prefixing
a &ldquo;-&rdquo; sign for decrease and a &ldquo;+&rdquo; for increase. Thus, 
say, -3q denotes abnormally low DNA copy number on the q arm of
the 3rd chromosome.
</p>


<h3>Source</h3>

<p>NCBI's SKY-CGH database
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(ov.cgh)
  heatmap(data.matrix(ov.cgh), Colv=NA, scale="none", col=c("gray90","red"))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
