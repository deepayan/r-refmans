<!DOCTYPE html><html lang="en"><head><title>Help for package MKpower</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MKpower}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MKpower-package'>
<p>Power Analysis and Sample Size Calculation.</p></a></li>
<li><a href='#hist'><p>Histograms</p></a></li>
<li><a href='#power.ancova'><p>Power Calculation for ANCOVA</p></a></li>
<li><a href='#power.diagnostic.test'><p>Power Calculations for Diagnostic Tests</p></a></li>
<li><a href='#power.hsu.t.test'><p>Power Calculations for Two-sample Hsu t Test</p></a></li>
<li><a href='#power.mpe.atleast.one'><p>Power for at least One Endpoint with Known Covariance</p></a></li>
<li><a href='#power.mpe.known.var'><p>Multiple Co-Primary Endpoints with Known Covariance</p></a></li>
<li><a href='#power.mpe.unknown.var'><p>Multiple Co-Primary Endpoints with Unknown Covariance</p></a></li>
<li><a href='#power.nb.test'><p>Power Calculation for Comparing Two Negative Binomial Rates</p></a></li>
<li><a href='#power.prop1.test'><p>Power Calculations for One-Sample Test for Proportions</p></a></li>
<li><a href='#power.welch.t.test'><p>Power Calculations for Two-sample Welch t Test</p></a></li>
<li><a href='#print.power.mpe.test'><p>Print Methods for Hypothesis Tests, Sample size and Power Calculations</p></a></li>
<li><a href='#qqunif'><p> qq-Plots for Uniform Distribution</p></a></li>
<li><a href='#sim.power.t.test'><p>Monte Carlo Simulations for Empirical Power of Two-sample t-Tests</p></a></li>
<li><a href='#sim.power.wilcox.test'><p>Monte Carlo Simulations for Empirical Power of Wilcoxon-Mann-Whitney Tests</p></a></li>
<li><a href='#sim.ssize.wilcox.test'><p>Sample Size for Wilcoxon Rank Sum and Signed Rank Tests</p></a></li>
<li><a href='#ssize.auc.ci'><p>Sample Size Calculations for AUC</p></a></li>
<li><a href='#ssize.pcc'><p>Sample Size Planning for Developing Classifiers Using High Dimensional Data</p></a></li>
<li><a href='#ssize.propCI'><p>Sample Size Calculation for Confidence Interval of a Proportion</p></a></li>
<li><a href='#ssize.reference.range'><p>Power Calculations for Two-sample Hsu t Test</p></a></li>
<li><a href='#volcano'><p> Volcano Plots</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-23</td>
</tr>
<tr>
<td>Title:</td>
<td>Power Analysis and Sample Size Calculation</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthias Kohl <a href="https://orcid.org/0000-0001-9514-8910"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthias Kohl &lt;Matthias.Kohl@stamats.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, matrixTests(&ge; 0.2), ggplot2, MKdescr, MKinfer(&ge; 0.4),
qqplotr, coin, mvtnorm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Power analysis and sample size calculation for Welch and Hsu (Hedderich and Sachs (2018), ISBN:978-3-662-56657-2) t-tests including Monte-Carlo simulations of empirical power and type-I-error. Power and sample size calculation for Wilcoxon rank sum and signed rank tests via Monte-Carlo simulations. Power and sample size required for the evaluation of a diagnostic test(-system) (Flahault et al. (2005), &lt;<a href="https://doi.org/10.1016%2Fj.jclinepi.2004.12.009">doi:10.1016/j.jclinepi.2004.12.009</a>&gt;; Dobbin and Simon (2007), &lt;<a href="https://doi.org/10.1093%2Fbiostatistics%2Fkxj036">doi:10.1093/biostatistics/kxj036</a>&gt;) as well as for a single proportion (Fleiss et al. (2003), ISBN:978-0-471-52629-2; Piegorsch (2004), &lt;<a href="https://doi.org/10.1016%2Fj.csda.2003.10.002">doi:10.1016/j.csda.2003.10.002</a>&gt;; Thulin (2014), &lt;<a href="https://doi.org/10.1214%2F14-ejs909">doi:10.1214/14-ejs909</a>&gt;), comparing two negative binomial rates (Zhu and Lakkis (2014), &lt;<a href="https://doi.org/10.1002%2Fsim.5947">doi:10.1002/sim.5947</a>&gt;), ANCOVA (Shieh (2020), &lt;<a href="https://doi.org/10.1007%2Fs11336-019-09692-3">doi:10.1007/s11336-019-09692-3</a>&gt;), reference ranges (Jennen-Steinmetz and Wellek (2005), &lt;<a href="https://doi.org/10.1002%2Fsim.2177">doi:10.1002/sim.2177</a>&gt;), multiple primary endpoints (Sozu et al. (2015), ISBN:978-3-319-22005-5), and AUC (Hanley and McNeil (1982), &lt;<a href="https://doi.org/10.1148%2Fradiology.143.1.7063747">doi:10.1148/radiology.143.1.7063747</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stamats/MKpower">https://github.com/stamats/MKpower</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-23 13:56:33 UTC; kohlm</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-23 14:30:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='MKpower-package'>
Power Analysis and Sample Size Calculation.
</h2><span id='topic+MKpower-package'></span><span id='topic+MKpower'></span>

<h3>Description</h3>

<p>Power analysis and sample size calculation for Welch and Hsu 
(Hedderich and Sachs (2018), ISBN:978-3-662-56657-2) t-tests including 
Monte-Carlo simulations of empirical power and type-I-error. 
Power and sample size calculation for Wilcoxon rank sum and signed rank tests 
via Monte-Carlo simulations. Power and sample size required for the evaluation 
of a diagnostic test(-system) (Flahault et al. (2005), 
&lt;doi:10.1016/j.jclinepi.2004.12.009&gt;; Dobbin and Simon (2007), 
&lt;doi:10.1093/biostatistics/kxj036&gt;) as well as for a single proportion 
(Fleiss et al. (2003), ISBN:978-0-471-52629-2; Piegorsch (2004), 
&lt;doi:10.1016/j.csda.2003.10.002&gt;; Thulin (2014), &lt;doi:10.1214/14-ejs909&gt;),  
comparing two negative binomial rates (Zhu and Lakkis (2014), &lt;doi:10.1002/sim.5947&gt;), 
ANCOVA (Shieh (2020), &lt;doi:10.1007/s11336-019-09692-3&gt;), reference 
ranges (Jennen-Steinmetz and Wellek (2005), &lt;doi:10.1002/sim.2177&gt;), 
multiple primary endpoints (Sozu et al. (2015), ISBN:978-3-319-22005-5), 
and AUC (Hanley and McNeil (1982), &lt;doi:10.1148/radiology.143.1.7063747&gt;).
</p>


<h3>Details</h3>

<p>library(MKpower)
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="https://www.stamats.de">https://www.stamats.de</a>
</p>
<p>Maintainer: Matthias Kohl  <a href="mailto:matthias.kohl@stamats.de">matthias.kohl@stamats.de</a></p>

<hr>
<h2 id='hist'>Histograms</h2><span id='topic+hist'></span><span id='topic+hist.sim.power.ttest'></span><span id='topic+hist.sim.power.wtest'></span>

<h3>Description</h3>

<p>Produce histograms for simulations of power and type-I-error of tests.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sim.power.ttest'
hist(x, color.hline = "orange", ...)

## S3 method for class 'sim.power.wtest'
hist(x, color.hline = "orange", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hist_+3A_x">x</code></td>
<td>
<p> object of class <code>sim.power.ttest</code>.</p>
</td></tr>
<tr><td><code id="hist_+3A_color.hline">color.hline</code></td>
<td>
<p> color of horizontal line indicating uniform distribution of p values.</p>
</td></tr>
<tr><td><code id="hist_+3A_...">...</code></td>
<td>
<p> further arguments that may be passed through).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot generates a <code>ggplot2</code> object that is shown. 
</p>
<p>Missing values are handled by the <code>ggplot2</code> functions.
</p>


<h3>Value</h3>

<p>Object of class <code>gg</code> and <code>ggplot</code>.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+hist">hist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>res1 &lt;- sim.power.t.test(nx = 5, rx = rnorm, rx.H0 = rnorm, 
                        ny = 10, ry = function(x) rnorm(x, mean = 3, sd = 3), 
                        ry.H0 = function(x) rnorm(x, sd = 3))
hist(res1)
res2 &lt;- sim.power.wilcox.test(nx = 6, rx = rnorm, rx.H0 = rnorm,
                      ny = 6, ry = function(x) rnorm(x, mean = 2), 
                      ry.H0 = rnorm)
hist(res2)
</code></pre>

<hr>
<h2 id='power.ancova'>Power Calculation for ANCOVA</h2><span id='topic+power.ancova'></span>

<h3>Description</h3>

<p>Compute sample size for ANCOVA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.ancova(n = NULL, mu = NULL, var = 1, nr.covs = 1L, group.ratio = NULL, 
             contr.mat = NULL, sig.level = 0.05, power = NULL, n.max = 1000L,
             rel.tol = .Machine$double.eps^0.25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power.ancova_+3A_n">n</code></td>
<td>
<p>vector of sample sizes per groups.</p>
</td></tr>
<tr><td><code id="power.ancova_+3A_mu">mu</code></td>
<td>
<p>vector of mean values of the groups.</p>
</td></tr>
<tr><td><code id="power.ancova_+3A_var">var</code></td>
<td>
<p>error variance.</p>
</td></tr>
<tr><td><code id="power.ancova_+3A_nr.covs">nr.covs</code></td>
<td>
<p>number of covariates (larger or equal than 1).</p>
</td></tr>
<tr><td><code id="power.ancova_+3A_group.ratio">group.ratio</code></td>
<td>
<p>vector of group sizes relative to group 1; i.e., first 
entry should always be one. If <code>NULL</code>, a balanced design is used.</p>
</td></tr>
<tr><td><code id="power.ancova_+3A_contr.mat">contr.mat</code></td>
<td>
<p>matrix of contrasts (number of columns must be idential to 
number of groups). If <code>NULL</code>, standard ANCOVA contrasts are used; see
examples below.</p>
</td></tr>
<tr><td><code id="power.ancova_+3A_sig.level">sig.level</code></td>
<td>
<p>significance level (type I error probability)</p>
</td></tr>
<tr><td><code id="power.ancova_+3A_power">power</code></td>
<td>
<p>power of test (1 minus type II error probability)</p>
</td></tr>
<tr><td><code id="power.ancova_+3A_n.max">n.max</code></td>
<td>
<p>maximum sample size considered in the computations.</p>
</td></tr>
<tr><td><code id="power.ancova_+3A_rel.tol">rel.tol</code></td>
<td>
<p>relative tolerance passed to function <code>integrate</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exactly one of the parameters <code>n</code> and <code>power</code> must be passed as
<code>NULL</code>, and that parameter is determined from the other.
</p>
<p>The function includes an implementation of the exact approach of Shieh (2020).
It is based on the code provided in the supplement of Shieh (2020), but
uses <code>integrate</code> instead of the trapezoid rule and <code>uniroot</code> for
finding the required sample size.
</p>


<h3>Value</h3>

<p>Object of class <code>"power.htest"</code>, a list of the arguments
(including the computed one) augmented with a <code>note</code> element.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>G. Shieh (2020). Power Analysis and Sample Size Planning in ANCOVA Designs. 
<em>Psychometrika</em> <b>85</b>:101-120. <a href="https://doi.org/10.1007/s11336-019-09692-3">doi:10.1007/s11336-019-09692-3</a>.
</p>
<p>S.E. Maxwell and H.D. Delaney (2004). <em>Designing experiments and analyzing 
data: A model comparison perspective</em> (2nd ed.). Mahwah, 
NJ: Lawrence Erlbaum Associates.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+power.anova.test">power.anova.test</a></code>, <code><a href="stats.html#topic+power.t.test">power.t.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Default matrix of contrasts
## 3 groups
cbind(rep(1,2), -diag(2))
## 4 groups
cbind(rep(1,3), -diag(3))

## Table 1 in Shieh (2020)
power.ancova(mu=c(400, 450, 500), var = 9900, power = 0.8)
power.ancova(n = rep(63/3, 3), mu=c(400, 450, 500), var = 9900)
power.ancova(mu=c(400, 450, 500), var = 9900, power = 0.8, nr.covs = 10)
power.ancova(n = rep(72/3, 3), mu=c(400, 450, 500), var = 9900, nr.covs = 10)

## Table 2 in Shieh (2020)
power.ancova(mu=c(400, 450, 500), var = 7500, power = 0.8)
power.ancova(n = rep(48/3, 3), mu=c(400, 450, 500), var = 7500)
power.ancova(mu=c(400, 450, 500), var = 7500, power = 0.8, nr.covs = 10)
power.ancova(n = rep(60/3, 3), mu=c(400, 450, 500), var = 7500, nr.covs = 10)

## Table 3 in Shieh (2020)
power.ancova(mu=c(400, 450, 500), var = 1900, power = 0.8)
power.ancova(n = rep(18/3, 3), mu=c(400, 450, 500), var = 1900)
power.ancova(mu=c(400, 450, 500), var = 1900, power = 0.8, nr.covs = 10)
power.ancova(n = rep(27/3, 3), mu=c(400, 450, 500), var = 1900, nr.covs = 10)

## ANOVA approach for Table 1-3
power.anova.test(groups = 3, between.var = var(c(400, 450, 500)), 
                 within.var = 10000, power = 0.8)
power.anova.test(n = 63/3, groups = 3, between.var = var(c(400, 450, 500)), 
                 within.var = 10000)

## Table 4 in Shieh (2020)
power.ancova(mu=c(410, 450, 490), var = 9900, power = 0.8)
power.ancova(n = rep(96/3, 3), mu=c(410, 450, 490), var = 9900)
power.ancova(mu=c(410, 450, 490), var = 9900, power = 0.8, nr.covs = 10)
power.ancova(n = rep(105/3, 3), mu=c(410, 450, 490), var = 9900, nr.covs = 10)

## Table 5 in Shieh (2020)
power.ancova(mu=c(410, 450, 490), var = 7500, power = 0.8)
power.ancova(n = rep(72/3, 3), mu=c(410, 450, 490), var = 7500)
power.ancova(mu=c(410, 450, 490), var = 7500, power = 0.8, nr.covs = 10)
power.ancova(n = rep(84/3, 3), mu=c(410, 450, 490), var = 7500, nr.covs = 10)

## Table 6 in Shieh (2020)
power.ancova(mu=c(410, 450, 490), var = 1900, power = 0.8)
power.ancova(n = rep(24/3, 3), mu=c(410, 450, 490), var = 1900)
power.ancova(mu=c(410, 450, 490), var = 1900, power = 0.8, nr.covs = 10)
power.ancova(n = rep(33/3, 3), mu=c(410, 450, 490), var = 1900, nr.covs = 10)

## ANOVA approach for Table 4-6
power.anova.test(groups = 3, between.var = var(c(410, 450, 490)), 
                 within.var = 10000, power = 0.8)
power.anova.test(n = 96/3, groups = 3, between.var = var(c(410, 450, 490)), 
                 within.var = 10000)

###############################################################################
## Example from Maxwell and Delaney (2004) according to Shieh (2020)
###############################################################################
## ANCOVA (balanced design)
power.ancova(n = rep(30/3, 3), mu=c(7.5366, 11.9849, 13.9785), var = 29.0898)
power.ancova(mu=c(7.5366, 11.9849, 13.9785), var = 29.0898, power = 0.8)
power.ancova(mu=c(7.5366, 11.9849, 13.9785), var = 29.0898, power = 0.9)

## ANOVA
power.anova.test(n = 30/3, groups = 3, between.var = var(c(7.5366, 11.9849, 13.9785)), 
                 within.var = 29.0898)
power.anova.test(groups = 3, between.var = var(c(7.5366, 11.9849, 13.9785)), 
                 within.var = 29.0898, power = 0.8)
power.anova.test(groups = 3, between.var = var(c(7.5366, 11.9849, 13.9785)), 
                 within.var = 29.0898, power = 0.9)
                 
## ANCOVA - imbalanced design
power.ancova(mu=c(7.5366, 11.9849, 13.9785), var = 29.0898, power = 0.8, 
             group.ratio = c(1, 1.25, 1.5))
power.ancova(n = c(13, 16, 19), mu=c(7.5366, 11.9849, 13.9785), var = 29.0898,  
             group.ratio = c(1, 1.25, 1.5))
power.ancova(mu=c(7.5366, 11.9849, 13.9785), var = 29.0898, power = 0.8, 
             group.ratio = c(1, 0.8, 2/3))
power.ancova(n = c(17, 14, 12), mu=c(7.5366, 11.9849, 13.9785), var = 29.0898,  
             group.ratio = c(1, 0.8, 2/3))
</code></pre>

<hr>
<h2 id='power.diagnostic.test'>Power Calculations for Diagnostic Tests</h2><span id='topic+power.diagnostic.test'></span><span id='topic+ssize.sens.ci'></span><span id='topic+ssize.spec.ci'></span>

<h3>Description</h3>

<p>Compute sample size, power, delta, or significance level of a diagnostic test
for an expected sensititivy or specificity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.diagnostic.test(sens = NULL, spec = NULL,
                      n = NULL, delta = NULL, sig.level = 0.05,
                      power = NULL, prev = NULL, 
                      method = c("exact", "asymptotic"),
                      NMAX = 1e4)
ssize.sens.ci(sens = NULL, n = NULL, delta = NULL, sig.level = 0.05,
              power = NULL, prev = NULL, method = c("exact", "asymptotic"),
              NMAX = 1e4)
ssize.spec.ci(spec = NULL, n = NULL, delta = NULL, sig.level = 0.05,
              power = NULL, prev = NULL, method = c("exact", "asymptotic"),
              NMAX = 1e4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power.diagnostic.test_+3A_sens">sens</code></td>
<td>
<p>Expected sensitivity; either <code>sens</code> or <code>spec</code> has to be specified.</p>
</td></tr>
<tr><td><code id="power.diagnostic.test_+3A_spec">spec</code></td>
<td>
<p>Expected specificity; either <code>sens</code> or <code>spec</code> has to be specified.</p>
</td></tr>
<tr><td><code id="power.diagnostic.test_+3A_n">n</code></td>
<td>
<p>Number of cases if <code>sens</code> and number of controls if <code>spec</code> is given.</p>
</td></tr>
<tr><td><code id="power.diagnostic.test_+3A_delta">delta</code></td>
<td>
<p><code>sens</code>-<code>delta</code> resp. <code>spec</code>-<code>delta</code> is used as lower
confidence limit</p>
</td></tr>
<tr><td><code id="power.diagnostic.test_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level (Type I error probability)</p>
</td></tr>
<tr><td><code id="power.diagnostic.test_+3A_power">power</code></td>
<td>
<p>Power of test (1 minus Type II error probability)</p>
</td></tr>
<tr><td><code id="power.diagnostic.test_+3A_prev">prev</code></td>
<td>
<p>Expected prevalence, if <code>NULL</code> prevalence is ignored which means <code>prev = 0.5</code>
is assumed.</p>
</td></tr>
<tr><td><code id="power.diagnostic.test_+3A_method">method</code></td>
<td>
<p>exact or asymptotic formula; default <code>"exact"</code>.</p>
</td></tr>
<tr><td><code id="power.diagnostic.test_+3A_nmax">NMAX</code></td>
<td>
<p>Maximum sample size considered in case <code>method = "exact"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either <code>sens</code> or <code>spec</code> has to be specified which leads to 
computations for either cases or controls.
</p>
<p>Exactly one of the parameters <code>n</code>, <code>delta</code>, <code>sig.level</code>, 
and <code>power</code> must be passed as <code>NULL</code>, and that parameter is determined 
from the others. Notice that <code>sig.level</code> has a non-<code>NULL</code> default 
so <code>NULL</code> must be explicitly passed if you want to compute it.
</p>
<p>The computations are based on the formulas given in the Appendix of 
Flahault et al. (2005). Please be careful, in Equation (A1) the numerator
should be squared, in equation (A2) and (A3) the second exponent should be
n-i and not i.
</p>
<p>As noted in Chu and Cole (2007) power is not a monotonically increasing
function in n but rather saw toothed (see also Chernick and Liu (2002)).
Hence, in our calculations we use the more conservative approach II); 
i.e., the minimum sample size <code>n</code> such that the actual power is 
larger or equal <code>power</code> andsuch that for any sample size larger 
than <code>n</code> it also holds that the actual power is larger or equal 
<code>power</code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"power.htest"</code>, a list of the arguments
(including the computed one) augmented with <code>method</code> and
<code>note</code> elements.
</p>


<h3>Note</h3>

<p><code>uniroot</code> is used to solve power equation for unknowns, so
you may see errors from it, notably about inability to bracket the
root when invalid arguments are given.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>A. Flahault, M. Cadilhac, and G. Thomas (2005). Sample size calculation 
should be performed for design accuracy in diagnostic test studies. 
<em>Journal of Clinical Epidemiology</em>, <b>58</b>(8):859-862.
</p>
<p>H. Chu and S.R. Cole (2007). Sample size calculation using exact methods 
in diagnostic test studies. 
<em>Journal of Clinical Epidemiology</em>, <b>60</b>(11):1201-1202.
</p>
<p>M.R. Chernick amd C.Y. Liu (2002). The saw-toothed behavior of power versus 
sample size and software solutions: single binomial proportion using 
exact methods. <em>Am Stat</em>, <b>56</b>:149-155.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+uniroot">uniroot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## see n2 on page 1202 of Chu and Cole (2007)
power.diagnostic.test(sens = 0.99, delta = 0.14, power = 0.95) # 40
power.diagnostic.test(sens = 0.99, delta = 0.13, power = 0.95) # 43
power.diagnostic.test(sens = 0.99, delta = 0.12, power = 0.95) # 47

power.diagnostic.test(sens = 0.98, delta = 0.13, power = 0.95) # 50
power.diagnostic.test(sens = 0.98, delta = 0.11, power = 0.95) # 58

## see page 1201 of Chu and Cole (2007)
power.diagnostic.test(sens = 0.95, delta = 0.1, n = 93) ## 0.957
power.diagnostic.test(sens = 0.95, delta = 0.1, n = 93, power = 0.95, 
                      sig.level = NULL) ## 0.0496
power.diagnostic.test(sens = 0.95, delta = 0.1, n = 102) ## 0.968
power.diagnostic.test(sens = 0.95, delta = 0.1, n = 102, power = 0.95, 
                      sig.level = NULL) ## 0.0471
## yields 102 not 93!
power.diagnostic.test(sens = 0.95, delta = 0.1, power = 0.95)

## function only for sensitivity
ssize.sens.ci(sens = 0.99, delta = 0.14, power = 0.95) # 40

## function only for specificity
ssize.spec.ci(spec = 0.99, delta = 0.13, power = 0.95) # 43
</code></pre>

<hr>
<h2 id='power.hsu.t.test'>Power Calculations for Two-sample Hsu t Test</h2><span id='topic+power.hsu.t.test'></span>

<h3>Description</h3>

<p>Compute the power of the two-sample Hsu t test, or determine parameters
to obtain a target power; see Section 7.4.4 in Hedderich and Sachs (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.hsu.t.test(n = NULL, delta = NULL, sd1 = 1, sd2 = 1, sig.level = 0.05,
                   power = NULL, alternative = c("two.sided", "one.sided"),
                   strict = FALSE, tol = .Machine$double.eps^0.25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power.hsu.t.test_+3A_n">n</code></td>
<td>
<p>number of observations (per group)</p>
</td></tr>
<tr><td><code id="power.hsu.t.test_+3A_delta">delta</code></td>
<td>
<p>(expected) true difference in means</p>
</td></tr>
<tr><td><code id="power.hsu.t.test_+3A_sd1">sd1</code></td>
<td>
<p>(expected) standard deviation of group 1</p>
</td></tr>
<tr><td><code id="power.hsu.t.test_+3A_sd2">sd2</code></td>
<td>
<p>(expected) standard deviation of group 2</p>
</td></tr>
<tr><td><code id="power.hsu.t.test_+3A_sig.level">sig.level</code></td>
<td>
<p>significance level (Type I error probability)</p>
</td></tr>
<tr><td><code id="power.hsu.t.test_+3A_power">power</code></td>
<td>
<p>power of test (1 minus Type II error probability)</p>
</td></tr>
<tr><td><code id="power.hsu.t.test_+3A_alternative">alternative</code></td>
<td>
<p>one- or two-sided test.  Can be abbreviated.</p>
</td></tr>
<tr><td><code id="power.hsu.t.test_+3A_strict">strict</code></td>
<td>
<p>use strict interpretation in two-sided case</p>
</td></tr>
<tr><td><code id="power.hsu.t.test_+3A_tol">tol</code></td>
<td>
<p>numerical tolerance used in root finding, the default
providing (at least) four significant digits.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exactly one of the parameters <code>n</code>, <code>delta</code>, <code>power</code>,
<code>sd1</code>, <code>sd2</code> and <code>sig.level</code> must be passed as <code>NULL</code>,
and that parameter is determined from the others. Notice that the last three
have non-NULL defaults, so NULL must be explicitly passed if you want to
compute them.
</p>
<p>If <code>strict = TRUE</code> is used, the power will include the probability of
rejection in the opposite direction of the true effect, in the two-sided
case. Without this the power will be half the significance level if the
true difference is zero.
</p>


<h3>Value</h3>

<p>Object of class <code>"power.htest"</code>, a list of the arguments
(including the computed one) augmented with <code>method</code> and
<code>note</code> elements.
</p>


<h3>Note</h3>

<p>The function and its documentation was adapted from <code>power.t.test</code>
implemented by Peter Dalgaard and based on previous work by Claus Ekstroem.
</p>
<p><code>uniroot</code> is used to solve the power equation for unknowns, so
you may see errors from it, notably about inability to bracket the
root when invalid arguments are given.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>J. Hedderich, L. Sachs. <em>Angewandte Statistik: Methodensammlung mit R</em>.
Springer 2016.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+power.welch.t.test">power.welch.t.test</a></code>, <code><a href="stats.html#topic+power.t.test">power.t.test</a></code>,
<code><a href="stats.html#topic+t.test">t.test</a></code>, <code><a href="stats.html#topic+uniroot">uniroot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> ## more conservative than classical or Welch t-test
 power.hsu.t.test(n = 20, delta = 1)
 power.hsu.t.test(power = .90, delta = 1)
 power.hsu.t.test(power = .90, delta = 1, alternative = "one.sided")

 ## sd1 = 0.5, sd2 = 1
 power.welch.t.test(delta = 0.5, sd1 = 0.5, sd2 = 1, power = 0.9)
 power.hsu.t.test(delta = 0.5, sd1 = 0.5, sd2 = 1, power = 0.9)

 
 if(require(MKinfer)){
 ## empirical check
 M &lt;- 10000
 ps &lt;- numeric(M)
 for(i in seq_len(M)){
   x &lt;- rnorm(55, mean = 0, sd = 0.5)
   y &lt;- rnorm(55, mean = 0.5, sd = 1.0)
   ps[i] &lt;- hsu.t.test(x, y)$p.value
 }
 ## empirical power
 sum(ps &lt; 0.05)/M
 }

</code></pre>

<hr>
<h2 id='power.mpe.atleast.one'>Power for at least One Endpoint with Known Covariance</h2><span id='topic+power.mpe.atleast.one'></span>

<h3>Description</h3>

<p>The function calculates either sample size or power for continuous multiple
primary endpoints for at least one endpoint with known covariance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.mpe.atleast.one(K, n = NULL, delta = NULL, Sigma, SD, rho, sig.level = 0.05/K,
                             power = NULL, n.max = 1e5, tol = .Machine$double.eps^0.25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power.mpe.atleast.one_+3A_k">K</code></td>
<td>
<p>number of endpoints</p>
</td></tr>
<tr><td><code id="power.mpe.atleast.one_+3A_n">n</code></td>
<td>
<p>optional: sample size</p>
</td></tr>
<tr><td><code id="power.mpe.atleast.one_+3A_delta">delta</code></td>
<td>
<p>expected effect size</p>
</td></tr>
<tr><td><code id="power.mpe.atleast.one_+3A_sigma">Sigma</code></td>
<td>
<p>A covariance of known matrix</p>
</td></tr>
<tr><td><code id="power.mpe.atleast.one_+3A_sd">SD</code></td>
<td>
<p>known standard deviations (length <code>K</code>)</p>
</td></tr>
<tr><td><code id="power.mpe.atleast.one_+3A_rho">rho</code></td>
<td>
<p>known correlations (length <code>0.5*K*(K-1)</code>)</p>
</td></tr>
<tr><td><code id="power.mpe.atleast.one_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level (Type I error probability)</p>
</td></tr>
<tr><td><code id="power.mpe.atleast.one_+3A_power">power</code></td>
<td>
<p>optional: Power of test (1 minus Type II error probability)</p>
</td></tr>
<tr><td><code id="power.mpe.atleast.one_+3A_n.max">n.max</code></td>
<td>
<p>upper end of the interval to be search for <code>n</code> via <code><a href="stats.html#topic+uniroot">uniroot</a></code>.</p>
</td></tr>
<tr><td><code id="power.mpe.atleast.one_+3A_tol">tol</code></td>
<td>
<p>The desired accuracy</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can be used to either compute sample size or power for continuous
multiple primary endpoints with known covariance where a significant difference 
for at least one endpoint is expected.
The implementation is based on the formulas given in the references below.
</p>
<p>The null hypothesis reads <code class="reqn">\mu_{Tk}-\mu_{Ck}\le 0</code> for
all <code class="reqn">k\in\{1,\ldots,K\}</code> where Tk is treatment k,
Ck is control k and K is the number of co-primary endpoints.
</p>
<p>One has to specify either <code>n</code> or <code>power</code>, the other parameter is
determined. Moreover, either covariance matrix <code>Sigma</code> or standard
deviations <code>SD</code> and correlations <code>rho</code> must be given.
</p>


<h3>Value</h3>

<p>Object of class <code>power.mpe.test</code>, a list of arguments (including the
computed one) augmented with method and note elements.
</p>


<h3>Note</h3>

<p>The function first appeared in package <span class="pkg">mpe</span>, which is now archived on CRAN.</p>


<h3>Author(s)</h3>

<p>Srinath Kolampally, Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Sugimoto, T. and Sozu, T. and Hamasaki, T. (2012). A convenient formula for sample
size calculations in clinical trials with multiple co-primary continuous endpoints.
<em>Pharmaceut. Statist.</em>, <b>11</b>: 118-128. doi:10.1002/pst.505
</p>
<p>Sozu, T. and Sugimoto, T. and Hamasaki, T. and Evans, S.R. (2015). <em>Sample
Size Determination in Clinical Trials with Multiple Endpoints</em>. Springer Briefs in
Statistics, ISBN 978-3-319-22005-5.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## compute power
power.mpe.atleast.one(K = 2, delta = c(0.2,0.2), Sigma = diag(c(1,1)), power = 0.8)

## compute sample size
power.mpe.atleast.one(K = 2, delta = c(0.2,0.2), Sigma = diag(c(2,2)), power = 0.9)

## known covariance matrix
Sigma &lt;- matrix(c(1.440, 0.840, 1.296, 0.840,
                  0.840, 1.960, 0.168, 1.568,
                  1.296, 0.168, 1.440, 0.420,
                  0.840, 1.568, 0.420, 1.960), ncol = 4)
## compute power
power.mpe.atleast.one(K = 4, n = 60, delta = c(0.5, 0.75, 0.5, 0.75), Sigma = Sigma)
## equivalent: known SDs and correlation rho
power.mpe.atleast.one(K = 4, n = 60, delta = c(0.5, 0.75, 0.5, 0.75),
                      SD = c(1.2, 1.4, 1.2, 1.4), 
                      rho = c(0.5, 0.9, 0.5, 0.1, 0.8, 0.25))
</code></pre>

<hr>
<h2 id='power.mpe.known.var'>Multiple Co-Primary Endpoints with Known Covariance</h2><span id='topic+power.mpe.known.var'></span>

<h3>Description</h3>

<p>The function calculates either sample size or power for continuous multiple
co-primary endpoints with known covariance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.mpe.known.var(K, n = NULL, delta = NULL, Sigma, SD, rho,
  sig.level = 0.05, power = NULL, n.max = 1e5, tol = .Machine$double.eps^0.25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power.mpe.known.var_+3A_k">K</code></td>
<td>
<p>number of co-primary endpoints</p>
</td></tr>
<tr><td><code id="power.mpe.known.var_+3A_n">n</code></td>
<td>
<p>optional: sample size</p>
</td></tr>
<tr><td><code id="power.mpe.known.var_+3A_delta">delta</code></td>
<td>
<p>expected effect size (length <code>K</code>)</p>
</td></tr>
<tr><td><code id="power.mpe.known.var_+3A_sigma">Sigma</code></td>
<td>
<p>known covariance matrix (dimension <code>K</code> x <code>K</code>)</p>
</td></tr>
<tr><td><code id="power.mpe.known.var_+3A_sd">SD</code></td>
<td>
<p>known standard deviations (length <code>K</code>)</p>
</td></tr>
<tr><td><code id="power.mpe.known.var_+3A_rho">rho</code></td>
<td>
<p>known correlations (length <code>0.5*K*(K-1)</code>)</p>
</td></tr>
<tr><td><code id="power.mpe.known.var_+3A_sig.level">sig.level</code></td>
<td>
<p>significance level (Type I error probability)</p>
</td></tr>
<tr><td><code id="power.mpe.known.var_+3A_power">power</code></td>
<td>
<p>optional: power of test (1 minus Type II error probability)</p>
</td></tr>
<tr><td><code id="power.mpe.known.var_+3A_n.max">n.max</code></td>
<td>
<p>upper end of the interval to be search for <code>n</code> via <code><a href="stats.html#topic+uniroot">uniroot</a></code>.</p>
</td></tr>
<tr><td><code id="power.mpe.known.var_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy for <code><a href="stats.html#topic+uniroot">uniroot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can be used to either compute sample size or power for continuous
multiple co-primary endpoints with known covariance where a multivariate
normal distribution is assumed. The implementation is based on the formulas
given in the references below.
</p>
<p>The null hypothesis reads <code class="reqn">\mu_{Tk}-\mu_{Ck}\le 0</code> for
at least one <code class="reqn">k\in\{1,\ldots,K\}</code> where Tk is treatment k,
Ck is control k and K is the number of co-primary endpoints.
</p>
<p>One has to specify either <code>n</code> or <code>power</code>, the other parameter is
determined. Moreover, either covariance matrix <code>Sigma</code> or standard
deviations <code>SD</code> and correlations <code>rho</code> must be given.
</p>


<h3>Value</h3>

<p>Object of class <code>power.mpe.test</code>, a list of arguments (including the
computed one) augemented with method and note elements.
</p>


<h3>Note</h3>

<p>The function first appeared in package <span class="pkg">mpe</span>, which is now archived on CRAN.</p>


<h3>Author(s)</h3>

<p>Srinath Kolampally, Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Sugimoto, T. and Sozu, T. and Hamasaki, T. (2012). A convenient formula for sample
size calculations in clinical trials with multiple co-primary continuous endpoints.
<em>Pharmaceut. Statist.</em>, <b>11</b>: 118-128. doi:10.1002/pst.505
</p>
<p>Sozu, T. and Sugimoto, T. and Hamasaki, T. and Evans, S.R. (2015). <em>Sample
Size Determination in Clinical Trials with Multiple Endpoints</em>. Springer Briefs in
Statistics, ISBN 978-3-319-22005-5.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+power.mpe.unknown.var">power.mpe.unknown.var</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## compute power
power.mpe.known.var(K = 2, n = 20, delta = c(1,1), Sigma = diag(c(1,1)))

## compute sample size
power.mpe.known.var(K = 2, delta = c(1,1), Sigma = diag(c(2,2)), power = 0.9,
                    sig.level = 0.025)

## known covariance matrix
Sigma &lt;- matrix(c(1.440, 0.840, 1.296, 0.840,
                  0.840, 1.960, 0.168, 1.568,
                  1.296, 0.168, 1.440, 0.420,
                  0.840, 1.568, 0.420, 1.960), ncol = 4)
## compute power
power.mpe.known.var(K = 4, n = 60, delta = c(0.5, 0.75, 0.5, 0.75), Sigma = Sigma)
## equivalent: known SDs and correlation rho
power.mpe.known.var(K = 4, n = 60,delta = c(0.5, 0.75, 0.5, 0.75),
                    SD = c(1.2, 1.4, 1.2, 1.4), 
                    rho = c(0.5, 0.9, 0.5, 0.1, 0.8, 0.25))
</code></pre>

<hr>
<h2 id='power.mpe.unknown.var'>Multiple Co-Primary Endpoints with Unknown Covariance</h2><span id='topic+power.mpe.unknown.var'></span>

<h3>Description</h3>

<p>The function calculates either sample size or power for continuous multiple
co-primary endpoints with unknown covariance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  power.mpe.unknown.var(K, n = NULL, delta = NULL, Sigma, SD, rho, sig.level = 0.05,
                        power = NULL, M = 10000, n.min = NULL, n.max = NULL,
                        tol = .Machine$double.eps^0.25, use.uniroot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power.mpe.unknown.var_+3A_k">K</code></td>
<td>
<p>number of co-primary endpoints</p>
</td></tr>
<tr><td><code id="power.mpe.unknown.var_+3A_n">n</code></td>
<td>
<p>optional: sample size</p>
</td></tr>
<tr><td><code id="power.mpe.unknown.var_+3A_delta">delta</code></td>
<td>
<p>expected effect size (length <code>K</code>)</p>
</td></tr>
<tr><td><code id="power.mpe.unknown.var_+3A_sigma">Sigma</code></td>
<td>
<p>unknown covariance matrix (dimension <code>K</code> x <code>K</code>)</p>
</td></tr>
<tr><td><code id="power.mpe.unknown.var_+3A_sd">SD</code></td>
<td>
<p>unknown standard deviations (length <code>K</code>)</p>
</td></tr>
<tr><td><code id="power.mpe.unknown.var_+3A_rho">rho</code></td>
<td>
<p>unknown correlations (length <code>0.5*K*(K-1)</code>)</p>
</td></tr>
<tr><td><code id="power.mpe.unknown.var_+3A_sig.level">sig.level</code></td>
<td>
<p>significance level (Type I error probability)</p>
</td></tr>
<tr><td><code id="power.mpe.unknown.var_+3A_power">power</code></td>
<td>
<p>optional: power of test (1 minus Type II error probability)</p>
</td></tr>
<tr><td><code id="power.mpe.unknown.var_+3A_m">M</code></td>
<td>
<p>Number of replications for the required simulations.</p>
</td></tr>
<tr><td><code id="power.mpe.unknown.var_+3A_n.min">n.min</code></td>
<td>
<p>Starting point of search interval for sample size</p>
</td></tr>
<tr><td><code id="power.mpe.unknown.var_+3A_n.max">n.max</code></td>
<td>
<p>End point of search interval for sample size, must be larger than <code>n.min</code></p>
</td></tr>
<tr><td><code id="power.mpe.unknown.var_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy for <code><a href="stats.html#topic+uniroot">uniroot</a></code></p>
</td></tr>
<tr><td><code id="power.mpe.unknown.var_+3A_use.uniroot">use.uniroot</code></td>
<td>
<p>Finds one root of one equation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can be used to either compute sample size or power for continuous
multiple co-primary endpoints with unknown covariance. The implementation is
based on the formulas given in the references below.
</p>
<p>The null hypothesis reads <code class="reqn">\mu_{Tk}-\mu_{Ck}\le 0</code> for
at least one <code class="reqn">k\in\{1,\ldots,K\}</code> where Tk is treatment k,
Ck is control k and K is the number of co-primary endpoints.
</p>
<p>One has to specify either <code>n</code> or <code>power</code>, the other parameter is
determined. An approach to calculate sample size <code>n</code>, is to first call
<code><a href="#topic+power.mpe.known.var">power.mpe.known.var</a></code> and use the result as <code>n.min</code>. The input for
<code>n.max</code> must be larger then <code>n.min</code>. Moreover, either covariance
matrix <code>Sigma</code> or standard deviations <code>SD</code> and correlations <code>rho</code>
must be given.
</p>
<p>The sample size is calculated by simulating Wishart distributed random matrices,
hence the results include a certain random variation.
</p>


<h3>Value</h3>

<p>Object of class <code>power.mpe.test</code>, a list of arguments (including the
computed one) augmented with method and note elements.
</p>


<h3>Note</h3>

<p>The function first appeared in package <span class="pkg">mpe</span>, which is now archived on CRAN.</p>


<h3>Author(s)</h3>

<p>Srinath Kolampally, Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Sugimoto, T. and Sozu, T. and Hamasaki, T. (2012). A convenient formula for sample
size calculations in clinical trials with multiple co-primary continuous endpoints.
<em>Pharmaceut. Statist.</em>, <b>11</b>: 118-128. doi:10.1002/pst.505
</p>
<p>Sozu, T. and Sugimoto, T. and Hamasaki, T. and Evans, S.R. (2015). <em>Sample
Size Determination in Clinical Trials with Multiple Endpoints</em>. Springer Briefs in
Statistics, ISBN 978-3-319-22005-5.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+power.mpe.known.var">power.mpe.known.var</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## compute power
## Not run: 
power.mpe.unknown.var(K = 2, n = 20, delta = c(1,1), Sigma = diag(c(1,1)))

## To compute sample size, first assume covariance as known
power.mpe.known.var(K = 2, delta = c(1,1), Sigma = diag(c(2,2)), power = 0.9,
                  sig.level = 0.025)

## The value of n, which is 51, is used as n.min and n.max must be larger
## then n.min so we try 60.
power.mpe.unknown.var(K = 2, delta = c(1,1), Sigma = diag(c(2,2)), power = 0.9,
                  sig.level = 0.025, n.min = 51, n.max = 60)

## More complex example with unknown covariance matrix assumed to be
Sigma &lt;- matrix(c(1.440, 0.840, 1.296, 0.840,
                  0.840, 1.960, 0.168, 1.568,
                  1.296, 0.168, 1.440, 0.420,
                  0.840, 1.568, 0.420, 1.960), ncol = 4)
## compute power
power.mpe.unknown.var(K = 4, n = 90, delta = c(0.5, 0.75, 0.5, 0.75), Sigma = Sigma)
## equivalent: unknown SDs and correlation rho
power.mpe.unknown.var(K = 4, n = 90, delta = c(0.5, 0.75, 0.5, 0.75),
                      SD = c(1.2, 1.4, 1.2, 1.4),
                      rho = c(0.5, 0.9, 0.5, 0.1, 0.8, 0.25))

## End(Not run)</code></pre>

<hr>
<h2 id='power.nb.test'>Power Calculation for Comparing Two Negative Binomial Rates</h2><span id='topic+power.nb.test'></span>

<h3>Description</h3>

<p>Compute sample size or power for comparing two negative binomial rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.nb.test(n = NULL, mu0, mu1, RR, duration = 1, theta, ssize.ratio = 1,
              sig.level = 0.05, power = NULL, alternative = c("two.sided", "one.sided"),
              approach = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power.nb.test_+3A_n">n</code></td>
<td>
<p>Sample size for group 0 (control group).</p>
</td></tr>
<tr><td><code id="power.nb.test_+3A_mu0">mu0</code></td>
<td>
<p>expected rate of events per time unit for group 0</p>
</td></tr>
<tr><td><code id="power.nb.test_+3A_mu1">mu1</code></td>
<td>
<p>expected rate of events per time unit for group 1</p>
</td></tr>
<tr><td><code id="power.nb.test_+3A_rr">RR</code></td>
<td>
<p>ratio of expected event rates: mu1/mu0</p>
</td></tr>
<tr><td><code id="power.nb.test_+3A_duration">duration</code></td>
<td>
<p>(average) treatment duration</p>
</td></tr>
<tr><td><code id="power.nb.test_+3A_theta">theta</code></td>
<td>
<p>theta parameter of negative binomial distribution; see <code><a href="MASS.html#topic+rnegbin">rnegbin</a></code></p>
</td></tr>
<tr><td><code id="power.nb.test_+3A_ssize.ratio">ssize.ratio</code></td>
<td>
<p>ratio of sample sizes: n1/n where n1 is sample size of group 1</p>
</td></tr>
<tr><td><code id="power.nb.test_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level (Type I error probability)</p>
</td></tr>
<tr><td><code id="power.nb.test_+3A_power">power</code></td>
<td>
<p>Power of test (1 minus Type II error probability)</p>
</td></tr>
<tr><td><code id="power.nb.test_+3A_alternative">alternative</code></td>
<td>
<p>one- or two-sided test</p>
</td></tr>
<tr><td><code id="power.nb.test_+3A_approach">approach</code></td>
<td>
<p>1, 2, or 3; see Zhu and Lakkis (2014).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exactly one of the parameters <code>n</code> and <code>power</code> must be passed as
<code>NULL</code>, and that parameter is determined from the other.
</p>
<p>The computations are based on the formulas given in Zhu and Lakkis (2014).
Please be careful, as we are using a slightly different parametrization
(<code>theta</code> = 1/k).
</p>
<p>Zhu and Lakkis (2014) based on their simulation studies recommend to use
their approach 2 or 3.
</p>


<h3>Value</h3>

<p>Object of class <code>"power.htest"</code>, a list of the arguments
(including the computed one) augmented with a <code>note</code> element.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>H. Zhu and H. Lakkis (2014). Sample size calculation for comparing two negative
binomial rates. <em>Statistics in Medicine</em>, <b>33</b>:376-387.
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+rnegbin">rnegbin</a></code>, <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## examples from Table I in Zhu and Lakkis (2014)
## theta = 1/k, RR = rr, mu0 = r0, duration = mu_t
power.nb.test(mu0 = 0.8, RR = 0.85, theta = 1/0.4, duration = 0.75, power = 0.8, approach = 1)
power.nb.test(mu0 = 0.8, RR = 0.85, theta = 1/0.4, duration = 0.75, power = 0.8, approach = 2)
power.nb.test(mu0 = 0.8, RR = 0.85, theta = 1/0.4, duration = 0.75, power = 0.8, approach = 3)

power.nb.test(mu0 = 1.4, RR = 1.15, theta = 1/1.5, duration = 0.75, power = 0.8, approach = 1)
power.nb.test(mu0 = 1.4, RR = 1.15, theta = 1/1.5, duration = 0.75, power = 0.8, approach = 2)
power.nb.test(mu0 = 1.4, RR = 1.15, theta = 1/1.5, duration = 0.75, power = 0.8, approach = 3)


## examples from Table II in Zhu and Lakkis (2014) - seem to be total sample sizes
## can reproduce the results with mu_t = 1.0 (not 0.7!)
power.nb.test(mu0 = 2.0, RR = 0.5, theta = 1, duration = 1.0, ssize.ratio = 1,
              power = 0.8, approach = 1)
power.nb.test(mu0 = 2.0, RR = 0.5, theta = 1, duration = 1.0, ssize.ratio = 1,
              power = 0.8, approach = 2)
power.nb.test(mu0 = 2.0, RR = 0.5, theta = 1, duration = 1.0, ssize.ratio = 1,
              power = 0.8, approach = 3)

power.nb.test(mu0 = 10.0, RR = 1.5, theta = 1/5, duration = 1.0, ssize.ratio = 3/2,
              power = 0.8, approach = 1)
power.nb.test(mu0 = 10.0, RR = 1.5, theta = 1/5, duration = 1.0, ssize.ratio = 3/2,
              power = 0.8, approach = 2)
power.nb.test(mu0 = 10.0, RR = 1.5, theta = 1/5, duration = 1.0, ssize.ratio = 3/2,
              power = 0.8, approach = 3)


## examples from Table III in Zhu and Lakkis (2014)
power.nb.test(mu0 = 5.0, RR = 2.0, theta = 1/0.5, duration = 1, power = 0.8, approach = 1)
power.nb.test(mu0 = 5.0, RR = 2.0, theta = 1/0.5, duration = 1, power = 0.8, approach = 2)
power.nb.test(mu0 = 5.0, RR = 2.0, theta = 1/0.5, duration = 1, power = 0.8, approach = 3)


## examples from Table IV in Zhu and Lakkis (2014)
power.nb.test(mu0 = 5.9/3, RR = 0.4, theta = 0.49, duration = 3, power = 0.9, approach = 1)
power.nb.test(mu0 = 5.9/3, RR = 0.4, theta = 0.49, duration = 3, power = 0.9, approach = 2)
power.nb.test(mu0 = 5.9/3, RR = 0.4, theta = 0.49, duration = 3, power = 0.9, approach = 3)

power.nb.test(mu0 = 13/6, RR = 0.2, theta = 0.52, duration = 6, power = 0.9, approach = 1)
power.nb.test(mu0 = 13/6, RR = 0.2, theta = 0.52, duration = 6, power = 0.9, approach = 2)
power.nb.test(mu0 = 13/6, RR = 0.2, theta = 0.52, duration = 6, power = 0.9, approach = 3)


## see Section 5 of Zhu and Lakkis (2014)
power.nb.test(mu0 = 0.66, RR = 0.8, theta = 1/0.8, duration = 0.9, power = 0.9)
</code></pre>

<hr>
<h2 id='power.prop1.test'>Power Calculations for One-Sample Test for Proportions</h2><span id='topic+power.prop1.test'></span>

<h3>Description</h3>

<p>Compute the power of the one-sample test for proportions, or determine
parameters to obtain a target power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.prop1.test(n = NULL, p1 = NULL, p0 = 0.5, sig.level = 0.05, 
                             power = NULL, 
                             alternative = c("two.sided", "less", "greater"),
                             cont.corr = TRUE, tol = .Machine$double.eps^0.25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power.prop1.test_+3A_n">n</code></td>
<td>
<p>number of observations (per group)</p>
</td></tr>
<tr><td><code id="power.prop1.test_+3A_p1">p1</code></td>
<td>
<p>expected probability</p>
</td></tr>
<tr><td><code id="power.prop1.test_+3A_p0">p0</code></td>
<td>
<p>probability under the null hypothesis</p>
</td></tr>
<tr><td><code id="power.prop1.test_+3A_sig.level">sig.level</code></td>
<td>
<p>significance level (Type I error probability)</p>
</td></tr>
<tr><td><code id="power.prop1.test_+3A_power">power</code></td>
<td>
<p>power of test (1 minus Type II error probability)</p>
</td></tr>
<tr><td><code id="power.prop1.test_+3A_alternative">alternative</code></td>
<td>
<p>one- or two-sided test.  Can be abbreviated.</p>
</td></tr>
<tr><td><code id="power.prop1.test_+3A_cont.corr">cont.corr</code></td>
<td>
<p>use continuity correction</p>
</td></tr>
<tr><td><code id="power.prop1.test_+3A_tol">tol</code></td>
<td>
<p>numerical tolerance used in root finding, the default
providing (at least) four significant digits.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exactly one of the parameters <code>n</code>, <code>p1</code>, <code>power</code>, and 
<code>sig.level</code> must be passed as NULL, and that parameter is determined 
from the others.  Notice that <code>sig.level</code> has a non-NULL default 
so <code>NULL</code> must be explicitly passed if you want it computed.
</p>
<p>The computation is based on the asymptotic formulas provided in Section 2.5.1
of Fleiss et al. (2003). If <code>cont.corr = TRUE</code> a continuity correction 
is applied, which may lead to better approximations of the finite-sample
values.
</p>


<h3>Value</h3>

<p>Object of class <code>"power.htest"</code>, a list of the arguments
(including the computed one) augmented with <code>method</code> and
<code>note</code> elements.
</p>


<h3>Note</h3>

<p>The documentation was adapted from <code><a href="stats.html#topic+power.prop.test">power.prop.test</a></code>.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>J.L. Fleiss, B. Levin and M.C. Paik (2003). 
<em>Statistical Methods for Rates and Proportions</em>. 
Wiley Series in Probability and Statistics.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+power.prop.test">power.prop.test</a></code>, <code><a href="stats.html#topic+prop.test">prop.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>power.prop1.test(p1 = 0.4, power = 0.8)
power.prop1.test(p1 = 0.4, power = 0.8, cont.corr = FALSE)
power.prop1.test(p1 = 0.6, power = 0.8)
power.prop1.test(n = 204, power = 0.8)
power.prop1.test(n = 204, p1 = 0.4, power = 0.8, sig.level = NULL)
power.prop1.test(n = 194, p1 = 0.4, power = 0.8, sig.level = NULL, 
                 cont.corr = FALSE)

power.prop1.test(p1 = 0.1, p0 = 0.3, power = 0.8, alternative = "less")
power.prop1.test(p1 = 0.1, p0 = 0.3, power = 0.8, alternative = "less", 
                 cont.corr = FALSE)
power.prop1.test(n = 31, p0 = 0.3, power = 0.8, alternative = "less")
power.prop1.test(n = 31, p1 = 0.1, p0 = 0.3, power = 0.8, sig.level = NULL, 
                 alternative = "less")


power.prop1.test(p1 = 0.5, p0 = 0.3, power = 0.8, alternative = "greater")
power.prop1.test(p1 = 0.5, p0 = 0.3, power = 0.8, alternative = "greater", 
                 cont.corr = FALSE)
power.prop1.test(n = 40, p0 = 0.3, power = 0.8, alternative = "greater")
power.prop1.test(n = 40, p1 = 0.5, p0 = 0.3, power = 0.8, sig.level = NULL, 
                 alternative = "greater")
</code></pre>

<hr>
<h2 id='power.welch.t.test'>Power Calculations for Two-sample Welch t Test</h2><span id='topic+power.welch.t.test'></span>

<h3>Description</h3>

<p>Compute the power of the two-sample Welch t test, or determine parameters
to obtain a target power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.welch.t.test(n = NULL, delta = NULL, sd1 = 1, sd2 = 1, sig.level = 0.05,
                   power = NULL, alternative = c("two.sided", "one.sided"),
                   strict = FALSE, tol = .Machine$double.eps^0.25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power.welch.t.test_+3A_n">n</code></td>
<td>
<p>number of observations (per group)</p>
</td></tr>
<tr><td><code id="power.welch.t.test_+3A_delta">delta</code></td>
<td>
<p>(expected) true difference in means</p>
</td></tr>
<tr><td><code id="power.welch.t.test_+3A_sd1">sd1</code></td>
<td>
<p>(expected) standard deviation of group 1</p>
</td></tr>
<tr><td><code id="power.welch.t.test_+3A_sd2">sd2</code></td>
<td>
<p>(expected) standard deviation of group 2</p>
</td></tr>
<tr><td><code id="power.welch.t.test_+3A_sig.level">sig.level</code></td>
<td>
<p>significance level (Type I error probability)</p>
</td></tr>
<tr><td><code id="power.welch.t.test_+3A_power">power</code></td>
<td>
<p>power of test (1 minus Type II error probability)</p>
</td></tr>
<tr><td><code id="power.welch.t.test_+3A_alternative">alternative</code></td>
<td>
<p>one- or two-sided test.  Can be abbreviated.</p>
</td></tr>
<tr><td><code id="power.welch.t.test_+3A_strict">strict</code></td>
<td>
<p>use strict interpretation in two-sided case</p>
</td></tr>
<tr><td><code id="power.welch.t.test_+3A_tol">tol</code></td>
<td>
<p>numerical tolerance used in root finding, the default
providing (at least) four significant digits.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exactly one of the parameters <code>n</code>, <code>delta</code>, <code>power</code>,
<code>sd1</code>, <code>sd2</code> and <code>sig.level</code> must be passed as <code>NULL</code>,
and that parameter is determined from the others. Notice that the last three
have non-NULL defaults, so NULL must be explicitly passed if you want to
compute them.
</p>
<p>If <code>strict = TRUE</code> is used, the power will include the probability of
rejection in the opposite direction of the true effect, in the two-sided
case. Without this the power will be half the significance level if the
true difference is zero.
</p>


<h3>Value</h3>

<p>Object of class <code>"power.htest"</code>, a list of the arguments
(including the computed one) augmented with <code>method</code> and
<code>note</code> elements.
</p>


<h3>Note</h3>

<p>The function and its documentation was adapted from <code>power.t.test</code>
implemented by Peter Dalgaard and based on previous work by Claus Ekstroem.
</p>
<p><code>uniroot</code> is used to solve the power equation for unknowns, so
you may see errors from it, notably about inability to bracket the
root when invalid arguments are given.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>S.L. Jan and G. Shieh (2011). Optimal sample sizes for Welch's test under
various allocation and cost considerations. <em>Behav Res Methods</em>, 43,
4:1014-22.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+power.t.test">power.t.test</a></code>, <code><a href="stats.html#topic+t.test">t.test</a></code>, <code><a href="stats.html#topic+uniroot">uniroot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> ## identical results as power.t.test, since sd = sd1 = sd2 = 1
 power.welch.t.test(n = 20, delta = 1)
 power.welch.t.test(power = .90, delta = 1)
 power.welch.t.test(power = .90, delta = 1, alternative = "one.sided")

  ## sd1 = 0.5, sd2 = 1
 power.welch.t.test(delta = 2, sd1 = 0.5, sd2 = 1, power = 0.9)

 
 ## empirical check
 M &lt;- 10000
 pvals.welch &lt;- numeric(M)
 for(i in seq_len(M)){
   x &lt;- rnorm(5, mean = 0, sd = 0.5)
   y &lt;- rnorm(5, mean = 2, sd = 1.0)
   pvals.welch[i] &lt;- t.test(x, y)$p.value
 }
 ## empirical power
 sum(pvals.welch &lt; 0.05)/M
 
</code></pre>

<hr>
<h2 id='print.power.mpe.test'>Print Methods for Hypothesis Tests, Sample size and Power Calculations</h2><span id='topic+print.power.mpe.test'></span>

<h3>Description</h3>

<p>Printing objects of class <code>"power.mpe.test"</code> by simple <code><a href="base.html#topic+print">print</a></code> methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'power.mpe.test'
print(x, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.power.mpe.test_+3A_x">x</code></td>
<td>
<p>object of class <code>"power.mpe.test"</code>.</p>
</td></tr>
<tr><td><code id="print.power.mpe.test_+3A_digits">digits</code></td>
<td>
<p>number of significant digits to be used.</p>
</td></tr>
<tr><td><code id="print.power.mpe.test_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>print</code> method is based on the respective method 
<code>print.power.htest</code> of package <span class="pkg">stats</span>.
</p>
<p>A <code>power.mpe.test</code> object is just a named list of numbers and
character strings, supplemented with <code>method</code> and <code>note</code>
elements.  The <code>method</code> is displayed as a title, the <code>note</code>
as a footnote, and the remaining elements are given in an aligned
&lsquo;name = value&rsquo; format.
</p>


<h3>Value</h3>

<p>the argument <code>x</code>, invisibly, as for all <code><a href="base.html#topic+print">print</a></code>
methods.
</p>


<h3>Note</h3>

<p>The function first appeared in package <span class="pkg">mpe</span>, which is now archived on CRAN.</p>


<h3>Author(s)</h3>

<p>Srinath Kolampally, Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+print.power.htest">print.power.htest</a></code>, <code><a href="#topic+power.mpe.known.var">power.mpe.known.var</a></code>, 
<code><a href="#topic+power.mpe.unknown.var">power.mpe.unknown.var</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(pkv &lt;- power.mpe.known.var(K = 2, delta = c(1,1), Sigma = diag(c(2,2)), power = 0.9,
                            sig.level = 0.025))
print(pkv, digits =  4) # using less digits than default
print(pkv, digits = 12) # using more digits than default
</code></pre>

<hr>
<h2 id='qqunif'> qq-Plots for Uniform Distribution</h2><span id='topic+qqunif'></span><span id='topic+qqunif.default'></span><span id='topic+qqunif.sim.power.ttest'></span><span id='topic+qqunif.sim.power.wtest'></span>

<h3>Description</h3>

<p>Produce qq-plot(s) of the given effect size and p values assuming a uniform distribution. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqunif(x, ...)

## Default S3 method:
qqunif(x, min = 0, max = 1, ...)

## S3 method for class 'sim.power.ttest'
qqunif(x, color.line = "orange", shape = 19, size = 1, 
                           alpha = 1, ...)

## S3 method for class 'sim.power.wtest'
qqunif(x, color.line = "orange", shape = 19, size = 1, 
                           alpha = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qqunif_+3A_x">x</code></td>
<td>
<p> numeric vector or data (object).</p>
</td></tr>
<tr><td><code id="qqunif_+3A_min">min</code></td>
<td>
<p> single numeric, lower limit of the distribution.</p>
</td></tr>
<tr><td><code id="qqunif_+3A_max">max</code></td>
<td>
<p> single numeric, upper limit of the distribution.</p>
</td></tr>
<tr><td><code id="qqunif_+3A_color.line">color.line</code></td>
<td>
<p> color of the line indicating the uniform distribution.</p>
</td></tr>
<tr><td><code id="qqunif_+3A_shape">shape</code></td>
<td>
<p> point shape.</p>
</td></tr>
<tr><td><code id="qqunif_+3A_size">size</code></td>
<td>
<p> point size.</p>
</td></tr>
<tr><td><code id="qqunif_+3A_alpha">alpha</code></td>
<td>
<p> bleding factor (default: no blending.</p>
</td></tr>
<tr><td><code id="qqunif_+3A_...">...</code></td>
<td>
<p> further arguments that may be passed through).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot generates a <code>ggplot2</code> object that is shown. 
</p>
<p>Missing values are handled by the <code>ggplot2</code> functions.
</p>


<h3>Value</h3>

<p>Object of class <code>gg</code> and <code>ggplot</code>.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## default
qqunif(runif(100))

## visualization of empirical power and type-I-error
res1 &lt;- sim.power.t.test(nx = 5, rx = rnorm, rx.H0 = rnorm, 
                        ny = 10, ry = function(x) rnorm(x, mean = 3, sd = 3), 
                        ry.H0 = function(x) rnorm(x, sd = 3))
qqunif(res1, alpha = 0.1)

res2 &lt;- sim.power.wilcox.test(nx = 6, rx = rnorm, rx.H0 = rnorm,
                      ny = 6, ry = function(x) rnorm(x, mean = 2), 
                      ry.H0 = rnorm)
qqunif(res2)
</code></pre>

<hr>
<h2 id='sim.power.t.test'>Monte Carlo Simulations for Empirical Power of Two-sample t-Tests</h2><span id='topic+sim.power.t.test'></span>

<h3>Description</h3>

<p>Simulate the empirical power and type-I-error of two-sample t-tests; i.e.,
classical (equal variances), Welch and Hsu t-tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.power.t.test(nx, rx, rx.H0 = NULL, ny, ry, ry.H0 = NULL, 
                 sig.level = 0.05, conf.int = FALSE, mu = 0, 
                 alternative = c("two.sided", "less", "greater"), 
                 iter = 10000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.power.t.test_+3A_nx">nx</code></td>
<td>
<p> single numeric, sample size of first group.</p>
</td></tr>
<tr><td><code id="sim.power.t.test_+3A_rx">rx</code></td>
<td>
<p> function to simulate the values of first group (assuming H1).</p>
</td></tr>
<tr><td><code id="sim.power.t.test_+3A_rx.h0">rx.H0</code></td>
<td>
 <p><code>NULL</code> or function to simulate the values of first group (assuming H0).</p>
</td></tr>
<tr><td><code id="sim.power.t.test_+3A_ny">ny</code></td>
<td>
<p> single numeric, sample size of second group.</p>
</td></tr>
<tr><td><code id="sim.power.t.test_+3A_ry">ry</code></td>
<td>
<p> function to simulate the values of second group (assuming H1).</p>
</td></tr>
<tr><td><code id="sim.power.t.test_+3A_ry.h0">ry.H0</code></td>
<td>
 <p><code>NULL</code> or function to simulate the values of second group (assuming H0).</p>
</td></tr>
<tr><td><code id="sim.power.t.test_+3A_sig.level">sig.level</code></td>
<td>
<p> significance level (type I error probability)</p>
</td></tr>
<tr><td><code id="sim.power.t.test_+3A_conf.int">conf.int</code></td>
<td>
<p> logical, shall confidence intervals be computed. 
Increases computation time!</p>
</td></tr>
<tr><td><code id="sim.power.t.test_+3A_mu">mu</code></td>
<td>
<p> true value of the location shift for the null hypothesis.</p>
</td></tr>
<tr><td><code id="sim.power.t.test_+3A_alternative">alternative</code></td>
<td>
<p>one- or two-sided test.  Can be abbreviated.</p>
</td></tr>
<tr><td><code id="sim.power.t.test_+3A_iter">iter</code></td>
<td>
<p> single integer, number of interations of the simulations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions <code>rx</code> and <code>ry</code> are used to simulate the data under the
alternative hypothesis H1. If specified, functions <code>rx.H0</code> and <code>ry.H0</code>
simulte the data unter the null hypothesis H0.
</p>
<p>For fast computations functions from package <code>matrixTests</code> are used.
</p>


<h3>Value</h3>

<p>Object of class <code>"sim.power.ttest"</code> with the results of the three t-tests
in the list elements <code>Classical</code>, <code>Welch</code> and <code>Hsu</code>. In addition,
the simulation setup is saved in element <code>SetUp</code>.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>J. Hedderich, L. Sachs. <em>Angewandte Statistik: Methodensammlung mit R</em>.
Springer 2018.
</p>
<p>Hsu, P. (1938). Contribution to the theory of &ldquo;student's&rdquo; t-test as 
applied to the problem of two samples. <em>Statistical Research Memoirs</em> <b>2</b>: 
1-24.
</p>
<p>Student (1908). The Probable Error of a Mean. <em>Biometrika</em>, <b>6</b>(1): 1-25.
</p>
<p>Welch, B. L. (1947). The generalization of &ldquo;Student's&rdquo; problem when several 
different population variances are involved. <em>Biometrika</em>, <b>34</b> 
(1-2): 28-35.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+t.test">t.test</a></code>, <code><a href="MKinfer.html#topic+hsu.t.test">hsu.t.test</a></code>, 
<code><a href="matrixTests.html#topic+ttest">ttest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Equal variance, small sample size
power.t.test(n = 5, delta = 2)
power.welch.t.test(n = 5, delta = 2)
power.hsu.t.test(n = 5, delta = 2)
sim.power.t.test(nx = 5, rx = rnorm, rx.H0 = rnorm,
                 ny = 5, ry = function(x) rnorm(x, mean = 2), ry.H0 = rnorm)

## Equal variance, moderate sample size
power.t.test(n = 25, delta = 0.8)
power.welch.t.test(n = 25, delta = 0.8)
power.hsu.t.test(n = 25, delta = 0.8)
sim.power.t.test(nx = 25, rx = rnorm, rx.H0 = rnorm,
                 ny = 25, ry = function(x) rnorm(x, mean = 0.8), ry.H0 = rnorm)

## Equal variance, high sample size
power.t.test(n = 100, delta = 0.4)
power.welch.t.test(n = 100, delta = 0.4)
power.hsu.t.test(n = 100, delta = 0.4)
sim.power.t.test(nx = 100, rx = rnorm, rx.H0 = rnorm,
                 ny = 100, ry = function(x) rnorm(x, mean = 0.4), ry.H0 = rnorm)

## Unequal variance, small sample size
power.welch.t.test(n = 5, delta = 5, sd1 = 1, sd2 = 3)
power.hsu.t.test(n = 5, delta = 5, sd1 = 1, sd2 = 3)
sim.power.t.test(nx = 5, rx = rnorm, rx.H0 = rnorm, 
                 ny = 5, ry = function(x) rnorm(x, mean = 5, sd = 3), 
                 ry.H0 = function(x) rnorm(x, sd = 3))
                 
## Unequal variance, moderate sample size
power.welch.t.test(n = 25, delta = 1.8, sd1 = 1, sd2 = 3)
power.hsu.t.test(n = 25, delta = 1.8, sd1 = 1, sd2 = 3)
sim.power.t.test(nx = 25, rx = rnorm, rx.H0 = rnorm, 
                 ny = 25, ry = function(x) rnorm(x, mean = 1.8, sd = 3), 
                 ry.H0 = function(x) rnorm(x, sd = 3))
                 
## Unequal variance, high sample size
power.welch.t.test(n = 100, delta = 0.9, sd1 = 1, sd2 = 3)
power.hsu.t.test(n = 100, delta = 0.9, sd1 = 1, sd2 = 3)
sim.power.t.test(nx = 100, rx = rnorm, rx.H0 = rnorm, 
                 ny = 100, ry = function(x) rnorm(x, mean = 0.9, sd = 3), 
                 ry.H0 = function(x) rnorm(x, sd = 3))
                 
## Unequal variance, unequal sample sizes
## small sample sizes
sim.power.t.test(nx = 10, rx = rnorm, rx.H0 = rnorm, 
                 ny = 5, ry = function(x) rnorm(x, mean = 5, sd = 3), 
                 ry.H0 = function(x) rnorm(x, sd = 3))
sim.power.t.test(nx = 5, rx = rnorm, rx.H0 = rnorm, 
                 ny = 10, ry = function(x) rnorm(x, mean = 3, sd = 3), 
                 ry.H0 = function(x) rnorm(x, sd = 3))

## Unequal variance, unequal sample sizes
## moderate sample sizes
sim.power.t.test(nx = 25, rx = rnorm, rx.H0 = rnorm, 
                 ny = 50, ry = function(x) rnorm(x, mean = 1.5, sd = 3), 
                 ry.H0 = function(x) rnorm(x, sd = 3))

## Unequal variance, unequal sample sizes
## high sample sizes
sim.power.t.test(nx = 100, rx = rnorm, rx.H0 = rnorm, 
                 ny = 200, ry = function(x) rnorm(x, mean = 0.6, sd = 3), 
                 ry.H0 = function(x) rnorm(x, sd = 3))
</code></pre>

<hr>
<h2 id='sim.power.wilcox.test'>Monte Carlo Simulations for Empirical Power of Wilcoxon-Mann-Whitney Tests</h2><span id='topic+sim.power.wilcox.test'></span>

<h3>Description</h3>

<p>Simulate the empirical power and type-I-error of Wilcoxon-Mann-Whitney tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.power.wilcox.test(nx, rx, rx.H0 = NULL, ny, ry, ry.H0 = NULL, 
                      alternative = c("two.sided", "less", "greater"), 
                      sig.level = 0.05, conf.int = FALSE, approximate = FALSE,
                      ties = FALSE, iter = 10000, nresample = 10000,
                      parallel = "no", ncpus = 1L, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.power.wilcox.test_+3A_nx">nx</code></td>
<td>
<p> single numeric, sample size of first group.</p>
</td></tr>
<tr><td><code id="sim.power.wilcox.test_+3A_rx">rx</code></td>
<td>
<p> function to simulate the values of first group (assuming H1).</p>
</td></tr>
<tr><td><code id="sim.power.wilcox.test_+3A_rx.h0">rx.H0</code></td>
<td>
 <p><code>NULL</code> or function to simulate the values of first group (assuming H0).</p>
</td></tr>
<tr><td><code id="sim.power.wilcox.test_+3A_ny">ny</code></td>
<td>
<p> single numeric, sample size of second group.</p>
</td></tr>
<tr><td><code id="sim.power.wilcox.test_+3A_ry">ry</code></td>
<td>
<p> function to simulate the values of second group (assuming H1).</p>
</td></tr>
<tr><td><code id="sim.power.wilcox.test_+3A_ry.h0">ry.H0</code></td>
<td>
 <p><code>NULL</code> or function to simulate the values of second group (assuming H0).</p>
</td></tr>
<tr><td><code id="sim.power.wilcox.test_+3A_alternative">alternative</code></td>
<td>
<p>one- or two-sided test.  Can be abbreviated.</p>
</td></tr>
<tr><td><code id="sim.power.wilcox.test_+3A_sig.level">sig.level</code></td>
<td>
<p> significance level (type I error probability)</p>
</td></tr>
<tr><td><code id="sim.power.wilcox.test_+3A_conf.int">conf.int</code></td>
<td>
<p> logical, shall confidence intervals be computed. 
Strongly increases computation time!</p>
</td></tr>
<tr><td><code id="sim.power.wilcox.test_+3A_approximate">approximate</code></td>
<td>
<p> logical, shall an approximate test be computed; 
see <code><a href="coin.html#topic+LocationTests">LocationTests</a></code>. Increases computation time!</p>
</td></tr>
<tr><td><code id="sim.power.wilcox.test_+3A_ties">ties</code></td>
<td>
<p> logical, indicating whether ties may occur. Increases computation time!</p>
</td></tr>
<tr><td><code id="sim.power.wilcox.test_+3A_iter">iter</code></td>
<td>
<p> single positive integer, number of interations of the simulations.</p>
</td></tr>
<tr><td><code id="sim.power.wilcox.test_+3A_nresample">nresample</code></td>
<td>
<p> single positive integer, the number of Monte Carlo replicates 
used for the computation of the approximative reference distribution; 
see <code><a href="coin.html#topic+NullDistribution">NullDistribution</a></code>.</p>
</td></tr>
<tr><td><code id="sim.power.wilcox.test_+3A_parallel">parallel</code></td>
<td>
<p> a character, the type of parallel operation: either <code>"no"</code> 
(default), <code>"multicore"</code> or <code>"snow"</code>; see <code><a href="coin.html#topic+NullDistribution">NullDistribution</a></code>.</p>
</td></tr>
<tr><td><code id="sim.power.wilcox.test_+3A_ncpus">ncpus</code></td>
<td>
<p> a single integer, the number of processes to be used in parallel operation. 
Defaults to 1L; see <code><a href="coin.html#topic+NullDistribution">NullDistribution</a></code>.</p>
</td></tr>
<tr><td><code id="sim.power.wilcox.test_+3A_cl">cl</code></td>
<td>
<p> an object inheriting from class <code>"cluster"</code>, specifying an optional 
parallel or snow cluster if <code>parallel = "snow"</code>. Defaults to NULL; see 
<code><a href="coin.html#topic+NullDistribution">NullDistribution</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions <code>rx</code> and <code>ry</code> are used to simulate the data under the
alternative hypothesis H1. If specified, functions <code>rx.H0</code> and <code>ry.H0</code>
simulte the data unter the null hypothesis H0.
</p>
<p>For fast computations functions from package <code>matrixTests</code> and package
<code>coin</code> are used.
</p>


<h3>Value</h3>

<p>Object of class <code>"sim.power.wtest"</code> with the results of the 
Wilcoxon-Mann-Whitney tests. A list elements <code>Exact</code>, <code>Asymptotic</code> 
and <code>Approximate</code>. In addition, the simulation setup is saved in 
element <code>SetUp</code>.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Mann, H and Withney, D (1947). On a test of whether one of two random variables 
is stochastically larger than the other. <em>Annals of mathematical Statistics</em>,
<b>18</b>, 50-60.
</p>
<p>Wilcoxon, F (1945). Individual Comparisons by Ranking Methods. 
<em>Biometrics Bulletin</em>, <b>1</b>, 80-83.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code>, <code><a href="coin.html#topic+LocationTests">LocationTests</a></code>, 
<code><a href="matrixTests.html#topic+wilcoxon">wilcoxon</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Equal variance, small sample size
power.t.test(n = 5, power = 0.8)
sim.ssize.wilcox.test(rx = rnorm, ry = function(x) rnorm(x, mean = 2), 
                      power = 0.8, n.min = 3, n.max = 10, step.size = 1)
sim.power.wilcox.test(nx = 6, rx = rnorm, rx.H0 = rnorm,
                      ny = 6, ry = function(x) rnorm(x, mean = 2), 
                      ry.H0 = rnorm)
</code></pre>

<hr>
<h2 id='sim.ssize.wilcox.test'>Sample Size for Wilcoxon Rank Sum and Signed Rank Tests</h2><span id='topic+sim.ssize.wilcox.test'></span>

<h3>Description</h3>

<p>Simulate the empirical power of Wilcoxon rank sum and signed rank tests for
computing the required sample size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.ssize.wilcox.test(rx, ry = NULL, mu = 0, sig.level = 0.05, power = 0.8, 
                      type = c("two.sample", "one.sample", "paired"), 
                      alternative = c("two.sided", "less", "greater"),
                      n.min = 10, n.max = 200, step.size = 10, 
                      iter = 10000, BREAK = TRUE, exact = NA, correct = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.ssize.wilcox.test_+3A_rx">rx</code></td>
<td>
<p> function to simulate the values of x, respectively x-y in the paired case.</p>
</td></tr>
<tr><td><code id="sim.ssize.wilcox.test_+3A_ry">ry</code></td>
<td>
<p> function to simulate the values of y in the two-sample case</p>
</td></tr>
<tr><td><code id="sim.ssize.wilcox.test_+3A_mu">mu</code></td>
<td>
<p> true values of the location shift for the null hypothesis.</p>
</td></tr>
<tr><td><code id="sim.ssize.wilcox.test_+3A_sig.level">sig.level</code></td>
<td>
<p> significance level (Type I error probability)</p>
</td></tr>
<tr><td><code id="sim.ssize.wilcox.test_+3A_power">power</code></td>
<td>
<p> two-sample, one-sample or paired test </p>
</td></tr>
<tr><td><code id="sim.ssize.wilcox.test_+3A_type">type</code></td>
<td>
<p> one- or two-sided test.  Can be abbreviated.</p>
</td></tr>
<tr><td><code id="sim.ssize.wilcox.test_+3A_alternative">alternative</code></td>
<td>
<p>one- or two-sided test.  Can be abbreviated.</p>
</td></tr>
<tr><td><code id="sim.ssize.wilcox.test_+3A_n.min">n.min</code></td>
<td>
<p> integer, start value of grid search.</p>
</td></tr>
<tr><td><code id="sim.ssize.wilcox.test_+3A_n.max">n.max</code></td>
<td>
<p> integer, stop value of grid search.</p>
</td></tr>
<tr><td><code id="sim.ssize.wilcox.test_+3A_step.size">step.size</code></td>
<td>
<p> integer, step size used in the grid search.</p>
</td></tr>
<tr><td><code id="sim.ssize.wilcox.test_+3A_iter">iter</code></td>
<td>
<p> integer, number of interations of the simulations.</p>
</td></tr>
<tr><td><code id="sim.ssize.wilcox.test_+3A_break">BREAK</code></td>
<td>
<p> logical, grid search stops when the emperical power is larger
than the requested power.</p>
</td></tr>
<tr><td><code id="sim.ssize.wilcox.test_+3A_exact">exact</code></td>
<td>
<p> logical or NA (default) indicator whether an exact p-value should 
be computed (see Details at <code><a href="matrixTests.html#topic+wilcoxon">wilcoxon</a></code>). A single 
value or a logical vector with values for each observation.</p>
</td></tr>
<tr><td><code id="sim.ssize.wilcox.test_+3A_correct">correct</code></td>
<td>
<p>ogical indicator whether continuity correction should be applied 
in the cases where p-values are obtained using normal approximation. A single 
value or logical vector with values for each observation; see 
<code><a href="matrixTests.html#topic+wilcoxon">wilcoxon</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions <code>rx</code> and <code>ry</code> are used to simulate the data and 
functions <code>row_wilcoxon_twosample</code> and <code>row_wilcoxon_onesample</code> of 
package <span class="pkg">matrixTests</span> are used to efficiently compute the p values of the 
respective test.
</p>
<p>We recommend a two steps procedure: In the first step, start with a wide grid 
and find out in which range of sample size values the intended power will
be achieved. In the second step, the interval identified in the first step 
is used to find the sample size that leads to the required power setting
<code>step.size = 1</code> and <code>BREAK = FALSE</code>. This approach is applied 
in the examples below.
</p>


<h3>Value</h3>

<p>Object of class <code>"power.htest"</code>, a list of the arguments
(including the computed one) augmented with <code>method</code> and
<code>note</code> elements.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Wilcoxon, F (1945). Individual Comparisons by Ranking Methods. 
<em>Biometrics Bulletin</em>, <b>1</b>, 80-83.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code>, <code><a href="matrixTests.html#topic+wilcoxon">wilcoxon</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> 
  ###############################################################################
  ## two-sample
  ## iter = 1000 to reduce check time
  ###############################################################################
  rx &lt;- function(n) rnorm(n, mean = 0, sd = 1) 
  ry &lt;- function(n) rnorm(n, mean = 0.5, sd = 1) 
  sim.ssize.wilcox.test(rx = rx, ry = ry, n.max = 100, iter = 1000)
  sim.ssize.wilcox.test(rx = rx, ry = ry, n.min = 65, n.max = 70, step.size = 1, 
                        iter = 1000, BREAK = FALSE)
  ## compared to
  power.t.test(delta = 0.5, power = 0.8)
  
  rx &lt;- function(n) rnorm(n, mean = 0, sd = 1) 
  ry &lt;- function(n) rnorm(n, mean = 0.5, sd = 1.5) 
  sim.ssize.wilcox.test(rx = rx, ry = ry, n.max = 100, iter = 1000, alternative = "less")
  sim.ssize.wilcox.test(rx = rx, ry = ry, n.min = 85, n.max = 90, step.size = 1, 
                        iter = 1000, BREAK = FALSE, alternative = "less")
  ## compared to
  power.welch.t.test(delta = 0.5, sd = 1, sd2 = 1.5, power = 0.8, alternative = "one.sided")
  
  rx &lt;- function(n) rnorm(n, mean = 0.5, sd = 1)
  ry &lt;- function(n) rnorm(n, mean = 0, sd = 1)
  sim.ssize.wilcox.test(rx = rx, ry = ry, n.max = 100, iter = 1000, alternative = "greater")
  sim.ssize.wilcox.test(rx = rx, ry = ry, n.min = 50, n.max = 55, step.size = 1, 
                        iter = 1000, BREAK = FALSE, alternative = "greater")
  ## compared to
  power.t.test(delta = 0.5, power = 0.8, alternative = "one.sided")
  
  rx &lt;- function(n) rgamma(n, scale = 10, shape = 1)
  ry &lt;- function(n) rgamma(n, scale = 15, shape = 1)
  sim.ssize.wilcox.test(rx = rx, ry = ry, n.max = 200, iter = 1000)
  sim.ssize.wilcox.test(rx = rx, ry = ry, n.min = 125, n.max = 135, step.size = 1, 
                        iter = 1000, BREAK = FALSE)
  
  ###############################################################################
  ## one-sample
  ## iter = 1000 to reduce check time
  ###############################################################################
  rx &lt;- function(n) rnorm(n, mean = 0.5, sd = 1)
  sim.ssize.wilcox.test(rx = rx, mu = 0, type = "one.sample", n.max = 100, iter = 1000)
  sim.ssize.wilcox.test(rx = rx, mu = 0, type = "one.sample", n.min = 33, n.max = 38, 
                        step.size = 1, iter = 1000, BREAK = FALSE)
  ## compared to
  power.t.test(delta = 0.5, power = 0.8, type = "one.sample")
  
  sim.ssize.wilcox.test(rx = rx, mu = 0, type = "one.sample", n.max = 100, iter = 1000,
                        alternative = "greater")
  sim.ssize.wilcox.test(rx = rx, mu = 0, type = "one.sample", n.min = 25, n.max = 30, 
                        step.size = 1, iter = 1000, BREAK = FALSE, alternative = "greater")
  ## compared to
  power.t.test(delta = 0.5, power = 0.8, type = "one.sample", alternative = "one.sided")
  
  sim.ssize.wilcox.test(rx = rx, mu = 1, type = "one.sample", n.max = 100, iter = 1000,
                        alternative = "less")
  sim.ssize.wilcox.test(rx = rx, mu = 1, type = "one.sample", n.min = 20, n.max = 30, 
                        step.size = 1, iter = 1000, BREAK = FALSE, alternative = "less")
  ## compared to
  power.t.test(delta = 0.5, power = 0.8, type = "one.sample", alternative = "one.sided")
  
  rx &lt;- function(n) rgamma(n, scale = 10, shape = 1)
  sim.ssize.wilcox.test(rx = rx, mu = 5, type = "one.sample", n.max = 200, iter = 1000)
  sim.ssize.wilcox.test(rx = rx, mu = 5, type = "one.sample", n.min = 40, n.max = 50, 
                        step.size = 1, iter = 1000, BREAK = FALSE)
  
  ###############################################################################
  ## paired
  ## identical to one-sample, requires random number generating function 
  ## that simulates the difference x-y
  ## iter = 1000 to reduce check time
  ###############################################################################
  rxy &lt;- function(n) rnorm(n, mean = 0.5, sd = 1)
  sim.ssize.wilcox.test(rx = rxy, mu = 0, type = "paired", n.max = 100, 
                        iter = 1000)
  sim.ssize.wilcox.test(rx = rxy, mu = 0, type = "paired", n.min = 33, 
                        n.max = 38, step.size = 1, iter = 1000, BREAK = FALSE)
  ## compared to
  power.t.test(delta = 0.5, power = 0.8, type = "paired")

</code></pre>

<hr>
<h2 id='ssize.auc.ci'>Sample Size Calculations for AUC</h2><span id='topic+ssize.auc.ci'></span>

<h3>Description</h3>

<p>Compute sample size, power, delta, or significance level of a diagnostic test
for an expected AUC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssize.auc.ci(AUC = NULL, delta = NULL, n = NULL, sig.level = 0.05,
             power = NULL, prev = NULL, NMAX = 1e4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssize.auc.ci_+3A_auc">AUC</code></td>
<td>
<p>Expected AUC.</p>
</td></tr>
<tr><td><code id="ssize.auc.ci_+3A_n">n</code></td>
<td>
<p>Total sample size (number of cases + number of controls).</p>
</td></tr>
<tr><td><code id="ssize.auc.ci_+3A_delta">delta</code></td>
<td>
<p><code>AUC</code>-<code>delta</code> is used as lower confidence limit</p>
</td></tr>
<tr><td><code id="ssize.auc.ci_+3A_sig.level">sig.level</code></td>
<td>
<p>Significance level (Type I error probability)</p>
</td></tr>
<tr><td><code id="ssize.auc.ci_+3A_power">power</code></td>
<td>
<p>Assurance probability of confidence interval (1 minus Type II error probability)</p>
</td></tr>
<tr><td><code id="ssize.auc.ci_+3A_prev">prev</code></td>
<td>
<p>Expected prevalence, if <code>NULL</code> prevalence is ignored which means <code>prev = 0.5</code>
is assumed.</p>
</td></tr>
<tr><td><code id="ssize.auc.ci_+3A_nmax">NMAX</code></td>
<td>
<p>Maximum sample size considered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exactly one of the parameters <code>n</code>, <code>delta</code>, <code>sig.level</code>, 
and <code>power</code> must be passed as <code>NULL</code>, and that parameter is determined 
from the others. Notice that <code>sig.level</code> has a non-<code>NULL</code> default 
so <code>NULL</code> must be explicitly passed if you want to compute it.
</p>
<p>The computations use the variance of the AUC derived by Hanley and McNeil (1982)
and incorporate an additional assurance probability (power) as in the approach
of Flahault et al. (2005).
</p>
<p>As noted in Chu and Cole (2007) power is not a monotonically increasing
function in n but rather saw toothed (see also Chernick and Liu (2002)).
Hence, in our calculations we use the more conservative approach II); 
i.e., the minimum sample size <code>n</code> such that the actual power is 
larger or equal <code>power</code> andsuch that for any sample size larger 
than <code>n</code> it also holds that the actual power is larger or equal 
<code>power</code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"power.htest"</code>, a list of the arguments
(including the computed one) augmented with <code>method</code> and
<code>note</code> elements.
</p>


<h3>Note</h3>

<p><code>uniroot</code> is used to solve the equations for unknowns, so
you may see errors from it, notably about inability to bracket the
root when invalid arguments are given.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>A. Flahault, M. Cadilhac, and G. Thomas (2005). Sample size calculation 
should be performed for design accuracy in diagnostic test studies. 
<em>Journal of Clinical Epidemiology</em>, <b>58</b>(8):859-862.
</p>
<p>J.A. Hanley, B.J. McNeil (1982). The meaning and use of the area under a 
receiver operating characteristic (ROC) curve. <em>Radiology</em>, <b>143</b>(1):29-36.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+uniroot">uniroot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## compute n
ssize.auc.ci(AUC = 0.9, delta = 0.05, power = 0.8)
## compute delta
ssize.auc.ci(AUC = 0.9, n = 254, power = 0.8)
## compute power
ssize.auc.ci(AUC = 0.9, n = 254, delta = 0.05)
## compute sig.level
ssize.auc.ci(AUC = 0.9, n = 254, delta = 0.05, power = 0.8, sig.level = NULL)
</code></pre>

<hr>
<h2 id='ssize.pcc'>Sample Size Planning for Developing Classifiers Using High Dimensional Data</h2><span id='topic+ssize.pcc'></span>

<h3>Description</h3>

<p>Calculate sample size for training set in developing classifiers using high
dimensional data. The calculation is based on the probability of correct classification 
(PCC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssize.pcc(gamma, stdFC, prev = 0.5, nrFeatures, sigFeatures = 20, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssize.pcc_+3A_gamma">gamma</code></td>
<td>
<p>tolerance between PCC(infty) and PCC(n).</p>
</td></tr>
<tr><td><code id="ssize.pcc_+3A_stdfc">stdFC</code></td>
<td>
<p>expected standardized fold-change; that is, expected fold-change devided
by within class standard deviation.</p>
</td></tr>
<tr><td><code id="ssize.pcc_+3A_prev">prev</code></td>
<td>
<p>expected prevalence.</p>
</td></tr>
<tr><td><code id="ssize.pcc_+3A_nrfeatures">nrFeatures</code></td>
<td>
<p>number of features (variables) considered.</p>
</td></tr>
<tr><td><code id="ssize.pcc_+3A_sigfeatures">sigFeatures</code></td>
<td>
<p>number of significatn features; default (20) should be sufficient 
for most if not all cases.</p>
</td></tr>
<tr><td><code id="ssize.pcc_+3A_verbose">verbose</code></td>
<td>
<p>print intermediate results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computations are based the algorithm provided in Section~4.2 of 
Dobbin and Simon (2007). Prevalence is incorporated by the simple rough
approach given in Section~4.4 (ibid.).
</p>
<p>The results for prevalence equal to $50%$ are identical to the numbers computed 
by <a href="https://brb.nci.nih.gov/brb/samplesize/samplesize4GE.html">https://brb.nci.nih.gov/brb/samplesize/samplesize4GE.html</a>. For 
other prevalences the numbers differ and are larger for our implementation. 
</p>


<h3>Value</h3>

<p>Object of class <code>"power.htest"</code>, a list of the arguments
(including the computed one) augmented with <code>method</code> and
<code>note</code> elements.
</p>


<h3>Note</h3>

<p><code>optimize</code> is used to solve equation (4.3) of Dobbin and Simon (2007), 
so you may see errors from it.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>K. Dobbin and R. Simon (2007). Sample size planning for developing classifiers 
using high-dimensional DNA microarray data. 
<em>Biostatistics</em>, <b>8</b>(1):101-117.
</p>
<p>K. Dobbin, Y. Zhao, R. Simon (2008). How Large a Training Set is Needed to 
Develop a Classifier for Microarray Data?
<em>Clin Cancer Res.</em>, <b>14</b>(1):108-114.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optimize">optimize</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## see Table 2 of Dobbin et al. (2008)
g &lt;- 0.1
fc &lt;- 1.6
ssize.pcc(gamma = g, stdFC = fc, nrFeatures = 22000)

## see Table 3 of Dobbin et al. (2008)
g &lt;- 0.05
fc &lt;- 1.1
ssize.pcc(gamma = g, stdFC = fc, nrFeatures = 22000)
</code></pre>

<hr>
<h2 id='ssize.propCI'>Sample Size Calculation for Confidence Interval of a Proportion</h2><span id='topic+ssize.propCI'></span><span id='topic+ssize.prop.ci'></span>

<h3>Description</h3>

<p>Compute the sample size for the two-sided confidence interval of a single proportion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssize.prop.ci(prop, width, conf.level = 0.95,  method = "wald-cc")

ssize.propCI(prop, width, conf.level = 0.95,  method = "wald-cc")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssize.propCI_+3A_prop">prop</code></td>
<td>
<p>expected proportion</p>
</td></tr>
<tr><td><code id="ssize.propCI_+3A_width">width</code></td>
<td>
<p>width of the confidence interval</p>
</td></tr>
<tr><td><code id="ssize.propCI_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="ssize.propCI_+3A_method">method</code></td>
<td>
<p> method used to compute the confidence interval; see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation is based on the asymptotic formulas provided in Section 2.5.2
of Fleiss et al. (2003). If <code>method = "wald-cc"</code> a continuity correction 
is applied.
</p>
<p>There are also methods for Jeffreys, Clopper-Pearson, Wilson and the 
Agresti-Coull interval; see also <code><a href="MKinfer.html#topic+binomCI">binomCI</a></code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"power.htest"</code>, a list of the arguments
(including the computed one) augmented with <code>method</code> and
<code>note</code> elements.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>J.L. Fleiss, B. Levin and M.C. Paik (2003). 
<em>Statistical Methods for Rates and Proportions</em>. 
Wiley Series in Probability and Statistics.
</p>
<p>W.W. Piegorsch (2004). Sample sizes for improved binomial confidence intervals. 
<em>Computational Statistics &amp; Data Analysis</em>, <b>46</b>, 309-316.
</p>
<p>M. Thulin (2014). The cost of using exact confidence intervals for a binomial 
proportion. <em>Electronic Journal of Statistics</em>, <b>8</b>(1), 817-840.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+power.prop1.test">power.prop1.test</a></code>, <code><a href="MKinfer.html#topic+binomCI">binomCI</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ssize.propCI(prop = 0.1, width = 0.1)
ssize.propCI(prop = 0.3, width = 0.1)
ssize.propCI(prop = 0.3, width = 0.1, method = "wald")
ssize.propCI(prop = 0.3, width = 0.1, method = "jeffreys")
ssize.propCI(prop = 0.3, width = 0.1, method = "clopper-pearson")
ssize.propCI(prop = 0.3, width = 0.1, method = "wilson")
ssize.propCI(prop = 0.3, width = 0.1, method = "agresti-coull")
</code></pre>

<hr>
<h2 id='ssize.reference.range'>Power Calculations for Two-sample Hsu t Test</h2><span id='topic+ssize.reference.range'></span>

<h3>Description</h3>

<p>Compute the sample size for reference range studies, or determine parameters
for a given sample size; see Jennen-Steinmetz and Wellek (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssize.reference.range(n = NULL, delta = NULL, ref.prob = 0.95, conf.prob = NULL,
                      alternative = c("two.sided", "one.sided"),
                      method = "parametric", exact = TRUE, 
                      tol = .Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssize.reference.range_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="ssize.reference.range_+3A_delta">delta</code></td>
<td>
<p> difference between empirical and target coverage of reference range</p>
</td></tr>
<tr><td><code id="ssize.reference.range_+3A_ref.prob">ref.prob</code></td>
<td>
<p>target coverage of reference range</p>
</td></tr>
<tr><td><code id="ssize.reference.range_+3A_conf.prob">conf.prob</code></td>
<td>
<p>confidence probability to acchieve given difference between empirical and target coverage</p>
</td></tr>
<tr><td><code id="ssize.reference.range_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying <code>"two.sided"</code> (default),
or one-sided reference ranges. You can specify just the initial letter.</p>
</td></tr>
<tr><td><code id="ssize.reference.range_+3A_method">method</code></td>
<td>
<p>either <code>"parametric"</code> or <code>"nonparametric"</code>; see details</p>
</td></tr>
<tr><td><code id="ssize.reference.range_+3A_exact">exact</code></td>
<td>
<p>use exact or approximate method</p>
</td></tr>
<tr><td><code id="ssize.reference.range_+3A_tol">tol</code></td>
<td>
<p>numerical tolerance used in root finding, the default
providing (at least) eight significant digits.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exactly one of the parameters <code>n</code>, <code>delta</code>, <code>ref.prob</code> 
and <code>conf.prob</code> must be passed as <code>NULL</code>, and that parameter is 
determined from the others. In case of <code>ref.prob</code> <code>NULL</code> must be explicitly 
passed if you want to compute it.
</p>
<p>If method <code>"parametric"</code> a normal distribution is assumed for the investigated
quantity.
</p>
<p>If method <code>"nonparametric"</code> an arbitrary continuous probability distribution
is assumed.
</p>
<p>If <code>exact = TRUE</code> is used, the computations use the exact formulas (5) 
and (9) of Jennen-Steinmetz and Wellek (2005).
</p>
<p>If <code>exact = FALSE</code> is used, the computations use the approximate formulas (6) 
and (10) of Jennen-Steinmetz and Wellek (2005).
</p>


<h3>Value</h3>

<p>Object of class <code>"power.htest"</code>, a list of the arguments
(including the computed one) augmented with <code>method</code> and
<code>note</code> elements.
</p>


<h3>Note</h3>

<p><code>uniroot</code> is used to solve the equations for unknowns, so
you may see errors from it, notably about inability to bracket the
root when invalid arguments are given.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>C. Jennen-Steinmetz, S. Wellek (2005). A new approach to sample size calculation
for reference interval studies. <em>Statistics in Medicine</em> 24:3199-3212.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+uniroot">uniroot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## see Table 1 in Jennen-Steinmetz and Wellek (2005)
  ssize.reference.range(delta = 0.03, ref.prob = 0.9, conf.prob = 0.9, 
                        method = "parametric", exact = TRUE)
  ## 135 vs 125 (error in Table 1)
  ssize.reference.range(delta = 0.03, ref.prob = 0.9, conf.prob = 0.9, 
                        method = "nonparametric", exact = TRUE)
  ssize.reference.range(delta = 0.03, ref.prob = 0.9, conf.prob = 0.9, 
                        method = "parametric", exact = FALSE)
  ssize.reference.range(delta = 0.03, ref.prob = 0.9, conf.prob = 0.9, 
                        method = "nonparametric", exact = FALSE)
  
  ssize.reference.range(delta = 0.025, ref.prob = 0.9, conf.prob = 0.9, 
                        method = "parametric", exact = TRUE)
  ssize.reference.range(delta = 0.025, ref.prob = 0.9, conf.prob = 0.9, 
                        method = "nonparametric", exact = TRUE)
  ssize.reference.range(delta = 0.025, ref.prob = 0.9, conf.prob = 0.9, 
                        method = "parametric", exact = FALSE)
  ssize.reference.range(delta = 0.025, ref.prob = 0.9, conf.prob = 0.9, 
                        method = "nonparametric", exact = FALSE)
  
  ssize.reference.range(delta = 0.02, ref.prob = 0.9, conf.prob = 0.9, 
                        method = "parametric", exact = TRUE)
  ## 314 vs. 305 (error Table 1?)
  ssize.reference.range(delta = 0.02, ref.prob = 0.9, conf.prob = 0.9, 
                        method = "nonparametric", exact = TRUE)
  ssize.reference.range(delta = 0.02, ref.prob = 0.9, conf.prob = 0.9, 
                        method = "parametric", exact = FALSE)
  ssize.reference.range(delta = 0.02, ref.prob = 0.9, conf.prob = 0.9, 
                        method = "nonparametric", exact = FALSE)
  
  ssize.reference.range(delta = 0.015, ref.prob = 0.9, conf.prob = 0.9, 
                        method = "parametric", exact = TRUE)
  ssize.reference.range(delta = 0.015, ref.prob = 0.9, conf.prob = 0.9, 
                        method = "nonparametric", exact = TRUE)
  ssize.reference.range(delta = 0.015, ref.prob = 0.9, conf.prob = 0.9, 
                        method = "parametric", exact = FALSE)
  ssize.reference.range(delta = 0.015, ref.prob = 0.9, conf.prob = 0.9, 
                        method = "nonparametric", exact = FALSE)
  
  ssize.reference.range(delta = 0.01, ref.prob = 0.9, conf.prob = 0.9, 
                        method = "parametric", exact = TRUE)
  ssize.reference.range(delta = 0.01, ref.prob = 0.9, conf.prob = 0.9, 
                        method = "nonparametric", exact = TRUE)
  ssize.reference.range(delta = 0.01, ref.prob = 0.9, conf.prob = 0.9, 
                        method = "parametric", exact = FALSE)
  ssize.reference.range(delta = 0.01, ref.prob = 0.9, conf.prob = 0.9, 
                        method = "nonparametric", exact = FALSE)
  
  ssize.reference.range(delta = 0.015, ref.prob = 0.95, conf.prob = 0.9, 
                        method = "parametric", exact = TRUE)
  ssize.reference.range(delta = 0.015, ref.prob = 0.95, conf.prob = 0.9, 
                        method = "nonparametric", exact = TRUE)
  ssize.reference.range(delta = 0.015, ref.prob = 0.95, conf.prob = 0.9, 
                        method = "parametric", exact = FALSE)
  ssize.reference.range(delta = 0.015, ref.prob = 0.95, conf.prob = 0.9, 
                        method = "nonparametric", exact = FALSE)
  
  ssize.reference.range(delta = 0.0125, ref.prob = 0.95, conf.prob = 0.9, 
                        method = "parametric", exact = TRUE)
  ssize.reference.range(delta = 0.0125, ref.prob = 0.95, conf.prob = 0.9, 
                        method = "nonparametric", exact = TRUE)
  ssize.reference.range(delta = 0.0125, ref.prob = 0.95, conf.prob = 0.9, 
                        method = "parametric", exact = FALSE)
  ssize.reference.range(delta = 0.0125, ref.prob = 0.95, conf.prob = 0.9, 
                        method = "nonparametric", exact = FALSE)
  
  ssize.reference.range(delta = 0.01, ref.prob = 0.95, conf.prob = 0.9, 
                        method = "parametric", exact = TRUE)
  ssize.reference.range(delta = 0.01, ref.prob = 0.95, conf.prob = 0.9, 
                        method = "nonparametric", exact = TRUE)
  ssize.reference.range(delta = 0.01, ref.prob = 0.95, conf.prob = 0.9, 
                        method = "parametric", exact = FALSE)
  ssize.reference.range(delta = 0.01, ref.prob = 0.95, conf.prob = 0.9, 
                        method = "nonparametric", exact = FALSE)
  
  ssize.reference.range(delta = 0.0075, ref.prob = 0.95, conf.prob = 0.9, 
                        method = "parametric", exact = TRUE)
  ssize.reference.range(delta = 0.0075, ref.prob = 0.95, conf.prob = 0.9, 
                        method = "nonparametric", exact = TRUE)
  ssize.reference.range(delta = 0.0075, ref.prob = 0.95, conf.prob = 0.9, 
                        method = "parametric", exact = FALSE)
  ssize.reference.range(delta = 0.0075, ref.prob = 0.95, conf.prob = 0.9, 
                        method = "nonparametric", exact = FALSE)
  
  ssize.reference.range(delta = 0.005, ref.prob = 0.95, conf.prob = 0.9, 
                        method = "parametric", exact = TRUE)
  ssize.reference.range(delta = 0.005, ref.prob = 0.95, conf.prob = 0.9, 
                        method = "nonparametric", exact = TRUE)
  ssize.reference.range(delta = 0.005, ref.prob = 0.95, conf.prob = 0.9, 
                        method = "parametric", exact = FALSE)
  ssize.reference.range(delta = 0.005, ref.prob = 0.95, conf.prob = 0.9, 
                        method = "nonparametric", exact = FALSE)
  
  
  ## results are equivalent to one-sided reference range with coverage of 
  ## 95 percent instead of 90 percent; for example
  ssize.reference.range(delta = 0.03, ref.prob = 0.95, conf.prob = 0.9, 
                        method = "parametric", exact = TRUE, alternative = "one.sided")
  ## 135 vs 125 (error in Table 1)
  ssize.reference.range(delta = 0.03, ref.prob = 0.95, conf.prob = 0.9, 
                        method = "nonparametric", exact = TRUE, alternative = "one.sided")
  ssize.reference.range(delta = 0.03, ref.prob = 0.95, conf.prob = 0.9, 
                        method = "parametric", exact = FALSE, alternative = "one.sided")
  ssize.reference.range(delta = 0.03, ref.prob = 0.95, conf.prob = 0.9, 
                        method = "nonparametric", exact = FALSE, alternative = "one.sided")

</code></pre>

<hr>
<h2 id='volcano'> Volcano Plots </h2><span id='topic+volcano'></span><span id='topic+volcano.sim.power.ttest'></span><span id='topic+volcano.sim.power.wtest'></span>

<h3>Description</h3>

<p>Produce volcano plot(s) for simulations of power and type-I-error of tests. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sim.power.ttest'
volcano(x, alpha = 1, shape = 19, 
                                    hex = FALSE, bins = 50, ...)

## S3 method for class 'sim.power.wtest'
volcano(x, alpha = 1, shape = 19, 
                                    hex = FALSE, bins = 50, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="volcano_+3A_x">x</code></td>
<td>
<p> object of class <code>sim.power.ttest</code>.</p>
</td></tr>
<tr><td><code id="volcano_+3A_alpha">alpha</code></td>
<td>
<p> bleding factor (default: no blending.</p>
</td></tr>
<tr><td><code id="volcano_+3A_shape">shape</code></td>
<td>
<p> point shape used.</p>
</td></tr>
<tr><td><code id="volcano_+3A_hex">hex</code></td>
<td>
<p> logical, should hexagonal binning be used.</p>
</td></tr>
<tr><td><code id="volcano_+3A_bins">bins</code></td>
<td>
<p> number of bins used for hexagonal binning.</p>
</td></tr>
<tr><td><code id="volcano_+3A_...">...</code></td>
<td>
<p> further arguments that may be passed through).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot generates a <code>ggplot2</code> object that is shown. 
</p>
<p>Missing values are handled by the <code>ggplot2</code> functions.
</p>


<h3>Value</h3>

<p>Object of class <code>gg</code> and <code>ggplot</code>.
</p>


<h3>Author(s)</h3>

<p> Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>Wikipedia contributors, <em>Volcano plot (statistics)</em>, Wikipedia, The Free Encyclopedia, 
<a href="https://en.wikipedia.org/w/index.php?title=Volcano_plot_(statistics)&amp;oldid=900217316">https://en.wikipedia.org/w/index.php?title=Volcano_plot_(statistics)&amp;oldid=900217316</a> 
(accessed December 25, 2019). 
</p>
<p>For more sophisticated and flexible volcano plots see for instance:
Blighe K, Rana S, Lewis M (2019). EnhancedVolcano: Publication-ready volcano 
plots with enhanced colouring and labeling. R/Bioconductor package.
<a href="https://github.com/kevinblighe/EnhancedVolcano">https://github.com/kevinblighe/EnhancedVolcano</a>.
</p>


<h3>See Also</h3>

<p><code><a href="MKinfer.html#topic+volcano">volcano</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>res1 &lt;- sim.power.t.test(nx = 5, rx = rnorm, rx.H0 = rnorm, 
                        ny = 10, ry = function(x) rnorm(x, mean = 3, sd = 3), 
                        ry.H0 = function(x) rnorm(x, sd = 3))
volcano(res1)

## low number of iterations to reduce computation time
res2 &lt;- sim.power.wilcox.test(nx = 6, rx = rnorm, rx.H0 = rnorm,
                      ny = 6, ry = function(x) rnorm(x, mean = 2), 
                      ry.H0 = rnorm, iter = 100, conf.int = TRUE)
volcano(res2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
