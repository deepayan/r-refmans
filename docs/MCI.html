<!DOCTYPE html><html><head><title>Help for package MCI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MCI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MCI-package'>
<p>Multiplicative Competitive Interaction (MCI) Model</p></a></li>
<li><a href='#DIY1'>
<p>Distance matrix for DIY stores</p></a></li>
<li><a href='#DIY2'>
<p>DIY store information</p></a></li>
<li><a href='#DIY3'>
<p>Data for origins (DIY store customers' places of residence)</p></a></li>
<li><a href='#Freiburg1'>
<p>Distance matrix for grocery stores in Freiburg</p></a></li>
<li><a href='#Freiburg2'>
<p>Statistical districts of Freiburg</p></a></li>
<li><a href='#Freiburg3'>
<p>Grocery stores in Freiburg</p></a></li>
<li><a href='#geom'>
<p>Geometric mean</p></a></li>
<li><a href='#grocery1'>
<p>Grocery store choices in Goettingen</p></a></li>
<li><a href='#grocery2'>
<p>Grocery store market areas in Goettingen</p></a></li>
<li><a href='#huff.attrac'>
<p>Local optimization of attraction values in the Huff Model</p></a></li>
<li><a href='#huff.decay'>
<p>Distance decay function in the Huff model</p></a></li>
<li><a href='#huff.fit'>
<p>Fitting the Huff model using local optimization of attractivity</p></a></li>
<li><a href='#huff.lambda'>
<p>Fitting the distance parameter lambda in the Huff model</p></a></li>
<li><a href='#huff.shares'>
<p>Huff model market share/market area simulations</p></a></li>
<li><a href='#ijmatrix.create'>
<p>Interaction matrix with market shares</p></a></li>
<li><a href='#ijmatrix.crosstab'>
<p>Converting interaction matrix with market shares to crosstable</p></a></li>
<li><a href='#ijmatrix.shares'>
<p>Market shares in interaction matrix</p></a></li>
<li><a href='#lm.beta'>
<p>Beta regression coefficients</p></a></li>
<li><a href='#mci.fit'>
<p>Fitting the MCI model</p></a></li>
<li><a href='#mci.shares'>
<p>MCI market share/market area simulations</p></a></li>
<li><a href='#mci.shares.elast'>
<p>Market share elasticities</p></a></li>
<li><a href='#mci.transmat'>
<p>Log-centering transformation of an MCI interaction matrix</p></a></li>
<li><a href='#mci.transvar'>
<p>Log-centering transformation of one variable in an MCI interaction matrix</p></a></li>
<li><a href='#model.fit'>
<p>Goodness of fit statistics for the Huff model</p></a></li>
<li><a href='#shares.segm'>
<p>Segmentation of market areas by a criterion</p></a></li>
<li><a href='#shares.total'>
<p>Total market shares/market areas</p></a></li>
<li><a href='#shopping1'><p>Point-of-sale survey in Karlsruhe</p></a></li>
<li><a href='#shopping2'>
<p>Distance matrix for the point-of-sale survey in Karlsruhe</p></a></li>
<li><a href='#shopping3'>
<p>Market area data for the point-of-sale survey in Karlsruhe</p></a></li>
<li><a href='#shopping4'>
<p>Grocery store data for the point-of-sale survey in Karlsruhe</p></a></li>
<li><a href='#var.asdummy'>
<p>Creating dummy variables</p></a></li>
<li><a href='#var.correct'>
<p>Correcting MCI input variables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiplicative Competitive Interaction (MCI) Model</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-10-10</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Wieland</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Wieland &lt;thomas.wieland.geo@googlemail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Market area models are used to analyze and predict store choices and market areas concerning retail and service locations. This package implements two market area models (Huff Model, Multiplicative Competitive Interaction Model) into R, while the emphases lie on 1.) fitting these models based on empirical data via OLS regression and nonlinear techniques and 2.) data preparation and processing (esp. interaction matrices and data preparation for the MCI Model).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-10-10 16:45:58 UTC; Thomas</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-10-10 16:55:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='MCI-package'>
Multiplicative Competitive Interaction (MCI) Model
</h2><span id='topic+MCI-package'></span><span id='topic+MCI'></span>

<h3>Description</h3>

<p>The <em>Huff model</em> (Huff 1962, 1963, 1964) is the most popular <em>spatial interaction model</em> for retailing and services and belongs to the family of <em>probabilistic market area models</em>. The basic idea of the model, derived from the <em>Luce choice axiom</em>, is that consumer decisions are not deterministic but probabilistic. Thus, the decision of customers for a shopping location in a competitive environment cannot be predicted exactly. The results of the model are probabilities for these decisions (<em>interaction probabilities</em>), which can be interpreted as market shares of the regarded locations (<code class="reqn">j</code>) in the customer origins (<code class="reqn">i</code>), <code class="reqn">p_{ij}</code> (<em>local market shares</em>). The model results can be regarded as an equilibrium solution (consumer equilibrium) with logically consistent market shares (0 &lt; <code class="reqn">p_{ij}</code> &lt; 1, <code class="reqn">\sum_{j=1}^n{p_{ij} = 1}</code>). From a theoretical perspective, the model is based on an utility function with two explanatory variables (&quot;attraction&quot; of the locations, transport costs between origins and locations), which are weighted by an exponent: <code class="reqn">U_{ij}=A_{j}^\gamma d_{ij}^{-\lambda}</code>. The probability is calculated as the utility quotient: <code class="reqn">p_{ij}=U_{ij}/\sum_{j=1}^n{U_{ij}}</code>. The <em>distance decay function</em> reflecting the disutility of transport costs can also be exponential or logistic. The model can also be used for the estimation of market areas based on location sales or total patronage using nonlinear optimization algorithms. When the &quot;real&quot; local market shares were observed, the model can be parametrized by using the <em>Multiplicative Competitive Interaction (MCI) Model</em>.
</p>
<p>The <em>Multiplicative Competitive Interaction (MCI) Model</em> (Nakanishi/Cooper 1974, 1982) is an econometric model for analyzing market shares and/or market areas in a competitive environment where the market is divided in <code class="reqn">i</code> submarkets (e.g. groups of customers, time periods or geographical regions) and served by <code class="reqn">j</code> suppliers (e.g. firms, brands or locations). The dependent variable of the model is <code class="reqn">p_{ij}</code>, the market shares of <code class="reqn">j</code> in <code class="reqn">i</code>, which are <em>logically consistent</em> (0 &lt; <code class="reqn">p_{ij}</code> &lt; 1, <code class="reqn">\sum_{j=1}^n{p_{ij} = 1}</code>). The market shares depend on the attraction/utility of the alternative <code class="reqn">j</code> in the choice situation/submarket <code class="reqn">i</code>, <code class="reqn">A_{ij}</code> or <code class="reqn">U_{ij}</code>. The model is nonlinear (multiplicative attractivity/utility function with exponential weighting) but can be transformed to be estimated by OLS (ordinary least squares) regression using the multi-step <em>log-centering transformation</em>. Before the <em>log-centering transformation</em> can be applied, which is required for fitting the model, also a re-arrangement of the raw data (e.g. household surveys) in an <em>interaction matrix</em> is necessary. An <em>interaction matrix</em> is a special case of table where every row is an <code class="reqn">i</code> x <code class="reqn">j</code> combination and the market shares of <code class="reqn">j</code> in <code class="reqn">i</code> (<code class="reqn">p_{ij}</code>) are saved in a new column (Linear table, the opposite of crosstable). The MCI model is a special case of market share model (which fulfills the requirement of logical consistency in the output), but can especially be used as a market area model (or <em>spatial MCI model</em>) in retail location analysis since it is an econometric approach to estimate the parameters of the <em>Huff model</em> mentioned above. 
</p>
<p>The functions in this package include fitting the MCI model, MCI shares simulations, the <em>log-centering transformation</em> of MCI datasets, creation of <em>interaction matrices</em> from empirical raw data and several tools for data preparation. Additionally, the package provides applications for the <em>Huff model</em>, including a nonlinear optimization algorithm to estimate market areas on condition that total market areas (customers, sales) of the stores/locations are known.
</p>


<h3>Author(s)</h3>

<p>Thomas Wieland
</p>
<p>Maintainer: Thomas Wieland <a href="mailto:thomas.wieland.geo@googlemail.com">thomas.wieland.geo@googlemail.com</a>
</p>


<h3>References</h3>

<p>Cooper, L. G./Nakanishi, M. (2010): &ldquo;Market-Share Analysis: Evaluating competitive marketing effectiveness&rdquo;. Boston, Dordrecht, London : Kluwer (first published 1988). E-book version from 2010: <a href="http://www.anderson.ucla.edu/faculty/lee.cooper/MCI_Book/BOOKI2010.pdf">http://www.anderson.ucla.edu/faculty/lee.cooper/MCI_Book/BOOKI2010.pdf</a>
</p>
<p>Cliquet, G. (2006): &ldquo;Retail Location Models&rdquo;. In: Cliquet, G. (ed.): <em>Geomarketing. Models and Strategies in Spatial Marketing</em>. London : ISTE. p. 137-163. 
</p>
<p>Guessefeldt, J. (2002): &ldquo;Zur Modellierung von raeumlichen Kaufkraftstroemen in unvollkommenen Maerkten&rdquo;. In: <em>Erdkunde</em>, <b>56</b>, 4, p. 351-370.
</p>
<p>Huff, D. L. (1962): &ldquo;Determination of Intra-Urban Retail Trade Areas&rdquo;. Los Angeles : University of California.
</p>
<p>Huff, D. L. (1963): &ldquo;A Probabilistic Analysis of Shopping Center Trade Areas&rdquo;. In: <em>Land Economics</em>, <b>39</b>, 1, p. 81-90.
</p>
<p>Huff, D. L. (1964): &ldquo;Defining and Estimating a Trading Area&rdquo;. In: <em>Journal of Marketing</em>, <b>28</b>, 4, p. 34-38.
</p>
<p>Huff, D. L./Batsell, R. R. (1975): &ldquo;Conceptual and Operational Problems with Market Share Models of Consumer Spatial Behavior&rdquo;. In: <em>Advances in Consumer Research</em>, <b>2</b>, p. 165-172.
</p>
<p>Huff, D. L./McCallum, D. (2008): &ldquo;Calibrating the Huff Model Using ArcGIS Business Analyst&rdquo;. <em>ESRI White Paper</em>, September 2008. <a href="https://www.esri.com/library/whitepapers/pdfs/calibrating-huff-model.pdf">https://www.esri.com/library/whitepapers/pdfs/calibrating-huff-model.pdf</a>
</p>
<p>Loeffler, G. (1998): &ldquo;Market areas - a methodological reflection on their boundaries&rdquo;. In: <em>GeoJournal</em>, <b>45</b>, 4, p. 265-272.
</p>
<p>Nakanishi, M./Cooper, L. G. (1974): &ldquo;Parameter Estimation for a Multiplicative Competitive Interaction Model - Least Squares Approach&rdquo;. In: <em>Journal of Marketing Research</em>, <b>11</b>, 3, p. 303-311.
</p>
<p>Nakanishi, M./Cooper, L. G. (1982): &ldquo;Simplified Estimation Procedures for MCI Models&rdquo;. In: <em>Marketing Science</em>, <b>1</b>, 3, p. 314-322. 
</p>
<p>Wieland, T. (2013): &ldquo;Einkaufsstaettenwahl, Einzelhandelscluster und raeumliche Versorgungsdisparitaeten - Modellierung von Marktgebieten im Einzelhandel unter Beruecksichtigung von Agglomerationseffekten&rdquo;. In: Schrenk, M./Popovich, V./Zeile, P./Elisei, P. (eds.): REAL CORP 2013. Planning Times. Proceedings of 18th International Conference on Urban Planning, Regional Development and Information Society. Schwechat. p. 275-284. <a href="http://www.corp.at/archive/CORP2013_98.pdf">http://www.corp.at/archive/CORP2013_98.pdf</a>
</p>
<p>Wieland, T. (2015): &ldquo;Raeumliches Einkaufsverhalten und Standortpolitik im Einzelhandel unter Beruecksichtigung von Agglomerationseffekten. Theoretische Erklaerungsansaetze, modellanalytische Zugaenge und eine empirisch-oekonometrische Marktgebietsanalyse anhand eines Fallbeispiels aus dem laendlichen Raum Ostwestfalens/Suedniedersachsens&rdquo;. <em>Geographische Handelsforschung</em>, <b>23</b>. 289 pages. Mannheim : MetaGIS.
</p>
<p>Wieland, T. (2015): &ldquo;Nahversorgung im Kontext raumoekonomischer Entwicklungen im Lebensmitteleinzelhandel - Konzeption und Durchfuehrung einer GIS-gestuetzten Analyse der Strukturen des Lebensmitteleinzelhandels und der Nahversorgung in Freiburg im Breisgau&rdquo;. Projektbericht. Goettingen : GOEDOC, Dokumenten- und Publikationsserver der Georg-August-Universitaet Goettingen. <a href="http://webdoc.sub.gwdg.de/pub/mon/2015/5-wieland.pdf">http://webdoc.sub.gwdg.de/pub/mon/2015/5-wieland.pdf</a>
</p>

<hr>
<h2 id='DIY1'>
Distance matrix for DIY stores
</h2><span id='topic+DIY1'></span>

<h3>Description</h3>

<p>Preliminary stage of an interaction matrix: Distance matrix for 19 origins and six DIY (do-it-yourself) stores (<code class="reqn">i</code> = 19 submarkets x <code class="reqn">j</code> = 6 suppliers) in a German research area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DIY1")</code></pre>


<h3>Format</h3>

<p>A data frame with 114 observations on the following 3 variables.
</p>

<dl>
<dt><code>i_origin</code></dt><dd><p>a factor with 19 levels representing the origins</p>
</dd>
<dt><code>j_destination</code></dt><dd><p>a factor with six levels representing the DIY stores</p>
</dd>
<dt><code>t_ij_min</code></dt><dd><p>a numeric vector containing the travel time (in minutes) from the origins to the stores</p>
</dd>
</dl>



<h3>Source</h3>

<p>Wieland, T. (2015): &ldquo;Raeumliches Einkaufsverhalten und Standortpolitik im Einzelhandel unter Beruecksichtigung von Agglomerationseffekten. Theoretische Erklaerungsansaetze, modellanalytische Zugaenge und eine empirisch-oekonometrische Marktgebietsanalyse anhand eines Fallbeispiels aus dem laendlichen Raum Ostwestfalens/Suedniedersachsens&rdquo;. <em>Geographische Handelsforschung</em>, <b>23</b>. 289 pages. Mannheim : MetaGIS.
</p>


<h3>References</h3>

<p>Wieland, T. (2015): &ldquo;Raeumliches Einkaufsverhalten und Standortpolitik im Einzelhandel unter Beruecksichtigung von Agglomerationseffekten. Theoretische Erklaerungsansaetze, modellanalytische Zugaenge und eine empirisch-oekonometrische Marktgebietsanalyse anhand eines Fallbeispiels aus dem laendlichen Raum Ostwestfalens/Suedniedersachsens&rdquo;. <em>Geographische Handelsforschung</em>, <b>23</b>. 289 pages. Mannheim : MetaGIS.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DIY1)
data(DIY2)
data(DIY3)
# Loading the three DIY store datasets

DIY_alldata &lt;- merge (DIY1, DIY2, by.x = "j_destination", by.y = "j_destination")
# Add store data to distance matrix

huff_DIY &lt;- huff.shares (DIY_alldata, "i_origin", "j_destination", "A_j_salesarea_sqm", 
"t_ij_min", gamma = 1, lambda = -2)
# Calculating Huff local market shares
# Gamma = 1, Lambda = -2

huff_DIY &lt;- merge (huff_DIY, DIY3, by.x = "i_origin", by.y = "district")
# Add data for origins

huff_DIY_total &lt;- shares.total (huff_DIY, "i_origin", "j_destination", "p_ij", 
"population")
# Calculating total market areas (=sums of customers)

colnames(DIY3) &lt;- c("district", "pop")
# Change column name to "pop" (must be other name)

huff.lambda (huff_DIY, "i_origin", "j_destination", "A_j_salesarea_sqm", 
"t_ij_min", gamma = 1, atype = "pow", gamma2 = NULL,
lambda_startv = -1, lambda_endv = -2.5, dtype= "pow",
DIY3, "district", "pop", huff_DIY_total, "suppliers_single", "sum_E_j", 
method = "bisection", iterations = 10)
# Iterative search for the best lambda value using bisection
# Output: gamma and lambda

huff.lambda (huff_DIY, "i_origin", "j_destination", "A_j_salesarea_sqm", 
"t_ij_min", gamma = 1, atype = "pow", gamma2 = NULL,
lambda_startv = -1, lambda_endv = -2.5, dtype= "pow",
DIY3, "district", "pop", huff_DIY_total, "suppliers_single", "sum_E_j", 
method = "bisection", iterations = 10, output = "iterations", show_proc = TRUE)
# Same procedure, output: single iterations  

huff.lambda (huff_DIY, "i_origin", "j_destination", "A_j_salesarea_sqm", 
"t_ij_min", gamma = 1, atype = "pow", gamma2 = NULL,
lambda_startv = -1, lambda_endv = -2.5, dtype= "pow",
DIY3, "district", "pop", huff_DIY_total, "suppliers_single", "sum_E_j", 
method = "compare", iterations = 10, output = "iterations", show_proc = TRUE, plotVal = TRUE)
# Using compare method, output: single iterations and plot 
</code></pre>

<hr>
<h2 id='DIY2'>
DIY store information
</h2><span id='topic+DIY2'></span>

<h3>Description</h3>

<p>The six DIY stores in a German research area, their corresponding DIY chain and sales area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DIY2")</code></pre>


<h3>Format</h3>

<p>A data frame with 6 observations on the following 3 variables.
</p>

<dl>
<dt><code>j_destination</code></dt><dd><p>a factor with six levels representing the DIY stores</p>
</dd>
<dt><code>j_chain</code></dt><dd><p>a factor with five levels containing the store chain</p>
</dd>
<dt><code>A_j_salesarea_sqm</code></dt><dd><p>a numeric vector for the sales area of the DIY stores in sqm</p>
</dd>
</dl>



<h3>Source</h3>

<p>Wieland, T. (2015): &ldquo;Raeumliches Einkaufsverhalten und Standortpolitik im Einzelhandel unter Beruecksichtigung von Agglomerationseffekten. Theoretische Erklaerungsansaetze, modellanalytische Zugaenge und eine empirisch-oekonometrische Marktgebietsanalyse anhand eines Fallbeispiels aus dem laendlichen Raum Ostwestfalens/Suedniedersachsens&rdquo;. <em>Geographische Handelsforschung</em>, <b>23</b>. 289 pages. Mannheim : MetaGIS.
</p>


<h3>References</h3>

<p>Wieland, T. (2015): &ldquo;Raeumliches Einkaufsverhalten und Standortpolitik im Einzelhandel unter Beruecksichtigung von Agglomerationseffekten. Theoretische Erklaerungsansaetze, modellanalytische Zugaenge und eine empirisch-oekonometrische Marktgebietsanalyse anhand eines Fallbeispiels aus dem laendlichen Raum Ostwestfalens/Suedniedersachsens&rdquo;. <em>Geographische Handelsforschung</em>, <b>23</b>. 289 pages. Mannheim : MetaGIS.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DIY1)
data(DIY2)
data(DIY3)
# Loading the three DIY store datasets

DIY_alldata &lt;- merge (DIY1, DIY2, by.x = "j_destination", by.y = "j_destination")
# Add store data to distance matrix

huff_DIY &lt;- huff.shares (DIY_alldata, "i_origin", "j_destination", "A_j_salesarea_sqm", 
"t_ij_min", gamma = 1, lambda = -2)
# Calculating Huff local market shares
# Gamma = 1, Lambda = -2

huff_DIY &lt;- merge (huff_DIY, DIY3, by.x = "i_origin", by.y = "district")
# Add data for origins

huff_DIY_total &lt;- shares.total (huff_DIY, "i_origin", "j_destination", "p_ij", 
"population")
# Calculating total market areas (=sums of customers)

colnames(DIY3) &lt;- c("district", "pop")
# Change column name to "pop" (must be other name)

huff.lambda (huff_DIY, "i_origin", "j_destination", "A_j_salesarea_sqm", 
"t_ij_min", gamma = 1, atype = "pow", gamma2 = NULL,
lambda_startv = -1, lambda_endv = -2.5, dtype= "pow",
DIY3, "district", "pop", huff_DIY_total, "suppliers_single", "sum_E_j", 
method = "bisection", iterations = 10)
# Iterative search for the best lambda value using bisection
# Output: gamma and lambda

huff.lambda (huff_DIY, "i_origin", "j_destination", "A_j_salesarea_sqm", 
"t_ij_min", gamma = 1, atype = "pow", gamma2 = NULL,
lambda_startv = -1, lambda_endv = -2.5, dtype= "pow",
DIY3, "district", "pop", huff_DIY_total, "suppliers_single", "sum_E_j", 
method = "bisection", iterations = 10, output = "iterations", show_proc = TRUE)
# Same procedure, output: single iterations  

huff.lambda (huff_DIY, "i_origin", "j_destination", "A_j_salesarea_sqm", 
"t_ij_min", gamma = 1, atype = "pow", gamma2 = NULL,
lambda_startv = -1, lambda_endv = -2.5, dtype= "pow",
DIY3, "district", "pop", huff_DIY_total, "suppliers_single", "sum_E_j", 
method = "compare", iterations = 10, output = "iterations", show_proc = TRUE, plotVal = TRUE)
# Using compare method, output: single iterations and plot 
</code></pre>

<hr>
<h2 id='DIY3'>
Data for origins (DIY store customers' places of residence)
</h2><span id='topic+DIY3'></span>

<h3>Description</h3>

<p>The 19 origins and the resident population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DIY3")</code></pre>


<h3>Format</h3>

<p>A data frame with 19 observations on the following 2 variables.
</p>

<dl>
<dt><code>district</code></dt><dd><p>a factor with 19 levels representing the origins</p>
</dd>
<dt><code>population</code></dt><dd><p>a numeric vector containing the resident population (2012)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Wieland, T. (2015): &ldquo;Raeumliches Einkaufsverhalten und Standortpolitik im Einzelhandel unter Beruecksichtigung von Agglomerationseffekten. Theoretische Erklaerungsansaetze, modellanalytische Zugaenge und eine empirisch-oekonometrische Marktgebietsanalyse anhand eines Fallbeispiels aus dem laendlichen Raum Ostwestfalens/Suedniedersachsens&rdquo;. <em>Geographische Handelsforschung</em>, <b>23</b>. 289 pages. Mannheim : MetaGIS.
</p>


<h3>References</h3>

<p>Wieland, T. (2015): &ldquo;Raeumliches Einkaufsverhalten und Standortpolitik im Einzelhandel unter Beruecksichtigung von Agglomerationseffekten. Theoretische Erklaerungsansaetze, modellanalytische Zugaenge und eine empirisch-oekonometrische Marktgebietsanalyse anhand eines Fallbeispiels aus dem laendlichen Raum Ostwestfalens/Suedniedersachsens&rdquo;. <em>Geographische Handelsforschung</em>, <b>23</b>. 289 pages. Mannheim : MetaGIS.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DIY1)
data(DIY2)
data(DIY3)
# Loading the three DIY store datasets

DIY_alldata &lt;- merge (DIY1, DIY2, by.x = "j_destination", by.y = "j_destination")
# Add store data to distance matrix

huff_DIY &lt;- huff.shares (DIY_alldata, "i_origin", "j_destination", "A_j_salesarea_sqm", 
"t_ij_min", gamma = 1, lambda = -2)
# Calculating Huff local market shares
# Gamma = 1, Lambda = -2

huff_DIY &lt;- merge (huff_DIY, DIY3, by.x = "i_origin", by.y = "district")
# Add data for origins

huff_DIY_total &lt;- shares.total (huff_DIY, "i_origin", "j_destination", "p_ij", 
"population")
# Calculating total market areas (=sums of customers)

colnames(DIY3) &lt;- c("district", "pop")
# Change column name to "pop" (must be other name)

huff.lambda (huff_DIY, "i_origin", "j_destination", "A_j_salesarea_sqm", 
"t_ij_min", gamma = 1, atype = "pow", gamma2 = NULL,
lambda_startv = -1, lambda_endv = -2.5, dtype= "pow",
DIY3, "district", "pop", huff_DIY_total, "suppliers_single", "sum_E_j", 
method = "bisection", iterations = 10)
# Iterative search for the best lambda value using bisection
# Output: gamma and lambda

huff.lambda (huff_DIY, "i_origin", "j_destination", "A_j_salesarea_sqm", 
"t_ij_min", gamma = 1, atype = "pow", gamma2 = NULL,
lambda_startv = -1, lambda_endv = -2.5, dtype= "pow",
DIY3, "district", "pop", huff_DIY_total, "suppliers_single", "sum_E_j", 
method = "bisection", iterations = 10, output = "iterations", show_proc = TRUE)
# Same procedure, output: single iterations  

huff.lambda (huff_DIY, "i_origin", "j_destination", "A_j_salesarea_sqm", 
"t_ij_min", gamma = 1, atype = "pow", gamma2 = NULL,
lambda_startv = -1, lambda_endv = -2.5, dtype= "pow",
DIY3, "district", "pop", huff_DIY_total, "suppliers_single", "sum_E_j", 
method = "compare", iterations = 10, output = "iterations", show_proc = TRUE, plotVal = TRUE)
# Using compare method, output: single iterations and plot 
</code></pre>

<hr>
<h2 id='Freiburg1'>
Distance matrix for grocery stores in Freiburg
</h2><span id='topic+Freiburg1'></span>

<h3>Description</h3>

<p>Preliminary stage of an interaction matrix: Distance matrix for all statistical 42 districts and all 63 grocery stores (<code class="reqn">i</code> = 42 submarkets x <code class="reqn">j</code> = 63 suppliers) in Freiburg (Germany) including the size of the grocery stores. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Freiburg1")</code></pre>


<h3>Format</h3>

<p>A data frame with 2646 observations on the following 4 variables.
</p>

<dl>
<dt><code>district</code></dt><dd><p>a numeric vector representing the 42 statistical districts of Freiburg</p>
</dd>
<dt><code>store</code></dt><dd><p>a numeric vector identifying the store code of the mentioned grocery store in the study area</p>
</dd>
<dt><code>salesarea</code></dt><dd><p>a numeric vector for the sales area of the grocery stores in sqm</p>
</dd>
<dt><code>distance</code></dt><dd><p>a numeric vector for the distance from the places of residence (statistical districts) to the grocery stores in km</p>
</dd>
</dl>



<h3>Source</h3>

<p>Wieland, T. (2015): &ldquo;Nahversorgung im Kontext raumoekonomischer Entwicklungen im Lebensmitteleinzelhandel - Konzeption und Durchfuehrung einer GIS-gestuetzten Analyse der Strukturen des Lebensmitteleinzelhandels und der Nahversorgung in Freiburg im Breisgau&rdquo;. Projektbericht. Goettingen : GOEDOC, Dokumenten- und Publikationsserver der Georg-August-Universitaet Goettingen. <a href="http://webdoc.sub.gwdg.de/pub/mon/2015/5-wieland.pdf">http://webdoc.sub.gwdg.de/pub/mon/2015/5-wieland.pdf</a>
</p>


<h3>References</h3>

<p>Wieland, T. (2015): &ldquo;Nahversorgung im Kontext raumoekonomischer Entwicklungen im Lebensmitteleinzelhandel - Konzeption und Durchfuehrung einer GIS-gestuetzten Analyse der Strukturen des Lebensmitteleinzelhandels und der Nahversorgung in Freiburg im Breisgau&rdquo;. Projektbericht. Goettingen : GOEDOC, Dokumenten- und Publikationsserver der Georg-August-Universitaet Goettingen. <a href="http://webdoc.sub.gwdg.de/pub/mon/2015/5-wieland.pdf">http://webdoc.sub.gwdg.de/pub/mon/2015/5-wieland.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Freiburg1)
data(Freiburg2)
data(Freiburg3)
# Loads the data

huff_mat &lt;- huff.shares (Freiburg1, "district", "store", "salesarea", "distance")
# Market area estimation using the Huff Model with standard parameters
# (gamma = 1, lambda = -2)

huff_mat_pp &lt;- merge (huff_mat, Freiburg2)
# Adding the purchasing power data for the city districts

huff_total &lt;- shares.total (huff_mat_pp, "district", "store", "p_ij", "ppower")
# Total expected sales and shares

huff_total_control &lt;- merge (huff_total, Freiburg3, by.x = "suppliers_single", 
by.y = "store")

model.fit(huff_total_control$annualsales, huff_total_control$sum_E_j, plotVal = TRUE)
</code></pre>

<hr>
<h2 id='Freiburg2'>
Statistical districts of Freiburg
</h2><span id='topic+Freiburg2'></span>

<h3>Description</h3>

<p>The 42 statistical districts of Freiburg (Germany) and the estimated annual purchasing power for groceries, based on average expenditures and population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Freiburg2")</code></pre>


<h3>Format</h3>

<p>A data frame with 42 observations on the following 2 variables.
</p>

<dl>
<dt><code>district</code></dt><dd><p>a numeric vector representing the 42 statistical districts of Freiburg</p>
</dd>
<dt><code>ppower</code></dt><dd><p>a numeric vector containing the estimated absolute value of annual purchasing power for groceries in the district in EUR</p>
</dd>
</dl>



<h3>Source</h3>

<p>Wieland, T. (2015): &ldquo;Nahversorgung im Kontext raumoekonomischer Entwicklungen im Lebensmitteleinzelhandel - Konzeption und Durchfuehrung einer GIS-gestuetzten Analyse der Strukturen des Lebensmitteleinzelhandels und der Nahversorgung in Freiburg im Breisgau&rdquo;. Projektbericht. Goettingen : GOEDOC, Dokumenten- und Publikationsserver der Georg-August-Universitaet Goettingen. <a href="http://webdoc.sub.gwdg.de/pub/mon/2015/5-wieland.pdf">http://webdoc.sub.gwdg.de/pub/mon/2015/5-wieland.pdf</a>
</p>


<h3>References</h3>

<p>Wieland, T. (2015): &ldquo;Nahversorgung im Kontext raumoekonomischer Entwicklungen im Lebensmitteleinzelhandel - Konzeption und Durchfuehrung einer GIS-gestuetzten Analyse der Strukturen des Lebensmitteleinzelhandels und der Nahversorgung in Freiburg im Breisgau&rdquo;. Projektbericht. Goettingen : GOEDOC, Dokumenten- und Publikationsserver der Georg-August-Universitaet Goettingen. <a href="http://webdoc.sub.gwdg.de/pub/mon/2015/5-wieland.pdf">http://webdoc.sub.gwdg.de/pub/mon/2015/5-wieland.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Freiburg1)
data(Freiburg2)
data(Freiburg3)
# Loads the data

huff_mat &lt;- huff.shares (Freiburg1, "district", "store", "salesarea", "distance")
# Market area estimation using the Huff Model with standard parameters
# (gamma = 1, lambda = -2)

huff_mat_pp &lt;- merge (huff_mat, Freiburg2)
# Adding the purchasing power data for the city districts

huff_total &lt;- shares.total (huff_mat_pp, "district", "store", "p_ij", "ppower")
# Total expected sales and shares

huff_total_control &lt;- merge (huff_total, Freiburg3, by.x = "suppliers_single", 
by.y = "store")

model.fit(huff_total_control$annualsales, huff_total_control$sum_E_j, plotVal = TRUE)
</code></pre>

<hr>
<h2 id='Freiburg3'>
Grocery stores in Freiburg
</h2><span id='topic+Freiburg3'></span>

<h3>Description</h3>

<p>The 63 grocery stores in Freiburg (Germany) and the estimated annual sales in EUR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Freiburg3")</code></pre>


<h3>Format</h3>

<p>A data frame with 63 observations on the following 2 variables.
</p>

<dl>
<dt><code>store</code></dt><dd><p>a numeric vector identifying the store code of the mentioned grocery store in the study area</p>
</dd>
<dt><code>annualsales</code></dt><dd><p>a numeric vector containing the estimated annual sales of the store in EUR</p>
</dd>
</dl>



<h3>Source</h3>

<p>Wieland, T. (2015): &ldquo;Nahversorgung im Kontext raumoekonomischer Entwicklungen im Lebensmitteleinzelhandel - Konzeption und Durchfuehrung einer GIS-gestuetzten Analyse der Strukturen des Lebensmitteleinzelhandels und der Nahversorgung in Freiburg im Breisgau&rdquo;. Projektbericht. Goettingen : GOEDOC, Dokumenten- und Publikationsserver der Georg-August-Universitaet Goettingen. <a href="http://webdoc.sub.gwdg.de/pub/mon/2015/5-wieland.pdf">http://webdoc.sub.gwdg.de/pub/mon/2015/5-wieland.pdf</a>
</p>


<h3>References</h3>

<p>Wieland, T. (2015): &ldquo;Nahversorgung im Kontext raumoekonomischer Entwicklungen im Lebensmitteleinzelhandel - Konzeption und Durchfuehrung einer GIS-gestuetzten Analyse der Strukturen des Lebensmitteleinzelhandels und der Nahversorgung in Freiburg im Breisgau&rdquo;. Projektbericht. Goettingen : GOEDOC, Dokumenten- und Publikationsserver der Georg-August-Universitaet Goettingen. <a href="http://webdoc.sub.gwdg.de/pub/mon/2015/5-wieland.pdf">http://webdoc.sub.gwdg.de/pub/mon/2015/5-wieland.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Freiburg1)
data(Freiburg2)
data(Freiburg3)
# Loads the data

huff_mat &lt;- huff.shares (Freiburg1, "district", "store", "salesarea", "distance")
# Market area estimation using the Huff Model with standard parameters
# (gamma = 1, lambda = -2)

huff_mat_pp &lt;- merge (huff_mat, Freiburg2)
# Adding the purchasing power data for the city districts

huff_total &lt;- shares.total (huff_mat_pp, "district", "store", "p_ij", "ppower")
# Total expected sales and shares

huff_total_control &lt;- merge (huff_total, Freiburg3, by.x = "suppliers_single", 
by.y = "store")

model.fit(huff_total_control$annualsales, huff_total_control$sum_E_j, plotVal = TRUE)
</code></pre>

<hr>
<h2 id='geom'>
Geometric mean
</h2><span id='topic+geom'></span>

<h3>Description</h3>

<p>Computes the geometric mean of a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_+3A_x">x</code></td>
<td>

<p>A numeric vector
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the geometric mean. 
</p>


<h3>Author(s)</h3>

<p>Thomas Wieland
</p>


<h3>Examples</h3>

<pre><code class='language-R'>numvec &lt;- c(10,15,20,25,30)  
# Creates a numeric vector "numvec"
mean(numvec)  
# Mean of numvec
geom(numvec)  
# Geometric mean of numvec
</code></pre>

<hr>
<h2 id='grocery1'>
Grocery store choices in Goettingen
</h2><span id='topic+grocery1'></span>

<h3>Description</h3>

<p>Results from a POS survey in Goettingen (Germany) from June 2015 (raw data). Amongst other things, the participants were asked about their last grocery shopping trip (store choice and expenditures) and their place of residence (ZIP code). The survey dataset contains 179 cases/interviewed individuals. The survey is <em>not</em> representative and should be regarded as an example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("grocery1")</code></pre>


<h3>Format</h3>

<p>A data frame with 179 observations on the following 5 variables.
</p>

<dl>
<dt><code>interview_nr</code></dt><dd><p>a numeric vector, interview/individual identifier</p>
</dd>
<dt><code>store_code</code></dt><dd><p>a factor with 32 levels (<code>ALDI1</code>, <code>ALDI3</code>, ...,  <code>EDEKA1</code>, ... <code>REWE1</code>, ...), identifying the store code of the mentioned grocery store in the study area, data from Wieland (2011)</p>
</dd>
<dt><code>store_chain</code></dt><dd><p>a factor with 11 levels (<code>Aldi</code>, <code>Edeka</code>, <code>Kaufland</code>, ...) for the store chain of the grocery stores in the study area, data from Wieland (2011)</p>
</dd> 
<dt><code>trip_expen</code></dt><dd><p>a numeric vector containing the individual trip expenditures at the last visited grocery store</p>
</dd>
<dt><code>plz_submarket</code></dt><dd><p>a factor with 7 levels (<code>PLZ_37073</code>, <code>PLZ_37075</code>, ...) representing the individuals' place of residence based on the five-digit ZIP codes in the study area</p>
</dd>
</dl>



<h3>Source</h3>

<p>Wieland, T. (2011): &ldquo;Nahversorgung mit Lebensmitteln in Goettingen 2011 - Eine Analyse der Angebotssituation im Goettinger Lebensmitteleinzelhandel unter besonderer Beruecksichtigung der Versorgungsqualitaet&rdquo;. <em>Goettinger Statistik Aktuell</em>, <b>35</b>. Goettingen.
<a href="http://www.goesis.goettingen.de/pdf/Aktuell35.pdf">http://www.goesis.goettingen.de/pdf/Aktuell35.pdf</a>
</p>
<p>Primary empirical sources:
POS (point of sale) survey in the authors' course (&ldquo;Seminar Angewandte Geographie 1: Stadtentwicklung und Citymarketing an einem konkreten Fallbeispiel&rdquo;, University of Goettingen/Institute of Geography, June 2015), own calculations
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grocery2">grocery2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grocery1)
# Loads the data
ijmatrix.create (grocery1, "plz_submarket", "store_code")
# Creates an interaction table with local market shares 
</code></pre>

<hr>
<h2 id='grocery2'>
Grocery store market areas in Goettingen
</h2><span id='topic+grocery2'></span>

<h3>Description</h3>

<p>Market areas of grocery stores in Goettingen, generated from a POS survey in Goettingen (Germany) from June 2015. The survey dataset contains 224 cases (<code class="reqn">i</code> = 7 submarkets x <code class="reqn">j</code> = 32 suppliers). The data is the result of a survey that is <em>not</em> representative (see <em>grocery1</em>) and also biased due to the data preparation. The data should be regarded as an example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("grocery2")</code></pre>


<h3>Format</h3>

<p>A data frame with 224 observations on the following 8 variables.
</p>

<dl>
<dt><code>plz_submarket</code></dt><dd><p>a factor with 7 levels (<code>PLZ_37073</code>,   
<code>PLZ_37075</code>, ...) representing the submarkets (places of residence based 
on the five-digit ZIP codes) in the study area</p>
</dd>
<dt><code>store_code</code></dt><dd><p>a factor with 32 levels (<code>ALDI1</code>, <code>ALDI3</code>, ...,  <code>EDEKA1</code>, ... <code>REWE1</code>, ...), identifying the store code of the mentioned grocery store in the study area, data from Wieland (2011)</p>
</dd>
<dt><code>store_chain</code></dt><dd><p>a factor with 11 levels (<code>Aldi</code>, <code>Edeka</code>, ..., <code>Kaufland</code>, ...) for the store chain of the grocery stores in the study area, data from Wieland (2011)</p>
</dd>
<dt><code>store_type</code></dt><dd><p>a factor with 3 levels for the store type (<code>Biosup</code> = bio-supermarkt, <code>Disc</code> = discounter, <code>Sup</code> = supermarket) </p>
</dd>
<dt><code>salesarea_qm</code></dt><dd><p>a numeric vector for the sales area of the grocery stores in sqm, data from Wieland (2011)</p>
</dd>
<dt><code>pricelevel_euro</code></dt><dd><p>a numeric vector for the price level of the grocery chain (standardized basket in EUR), based on the data from DISQ (2015)</p>
</dd>
<dt><code>dist_km</code></dt><dd><p>a numeric vector for the distance from the places of residence (ZIP codes) to the grocery stores in km</p>
</dd>
<dt><code>p_ij_obs</code></dt><dd><p>a numeric vector for the empirically observed (and corrected) market shares (<code class="reqn">p_{ij}</code>) of the stores in the submarkets</p>
</dd>
</dl>



<h3>Source</h3>

<p>DISQ (Deutsches Institut fuer Servicequalitaet) (2015) &ldquo;Discounter guenstig, Vollsortimenter serviceorientiert. Studie Lebensmittelmaerkte (15.10.2015)&rdquo;. 
<a href="http://disq.de/2015/20151015-Lebensmittelmaerkte.html">http://disq.de/2015/20151015-Lebensmittelmaerkte.html</a>
</p>
<p>Wieland, T. (2011): &ldquo;Nahversorgung mit Lebensmitteln in Goettingen 2011 - Eine Analyse der Angebotssituation im Goettinger Lebensmitteleinzelhandel unter besonderer Beruecksichtigung der Versorgungsqualitaet&rdquo;. <em>Goettinger Statistik Aktuell</em>, <b>35</b>. Goettingen. 
<a href="http://www.goesis.goettingen.de/pdf/Aktuell35.pdf">http://www.goesis.goettingen.de/pdf/Aktuell35.pdf</a>
</p>
<p>Primary empirical sources:
POS (point of sale) survey in the authors' course (&ldquo;Seminar Angewandte Geographie 1: Stadtentwicklung und Citymarketing an einem konkreten Fallbeispiel&rdquo;, University of Goettingen/Institute of Geography, June 2015), own calculations
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grocery1">grocery1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grocery2)
# Loads the data
mci.transmat (grocery2, "plz_submarket", "store_code", "p_ij_obs", "dist_km", "salesarea_qm")
# Applies the log-centering transformation to the dataset using the function mci.transmat
</code></pre>

<hr>
<h2 id='huff.attrac'>
Local optimization of attraction values in the Huff Model
</h2><span id='topic+huff.attrac'></span>

<h3>Description</h3>

<p>This function optimizes the attraction values of suppliers/location in a given Huff interaction matrix to fit empirically observed total values (e.g. annual sales) and calculates market shares/market areas
</p>


<h3>Usage</h3>

<pre><code class='language-R'>huff.attrac(huffdataset, origins, locations, attrac, dist, 
lambda = -2, dtype = "pow", lambda2 = NULL, 
localmarket_dataset, origin_id, localmarket, 
location_dataset, location_id, location_total, 
tolerance = 5, output = "matrix", show_proc = FALSE, 
check_df = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="huff.attrac_+3A_huffdataset">huffdataset</code></td>
<td>

<p>an interaction matrix which is a <code>data.frame</code> containing the origins, locations and the explanatory variables (attraction, transport costs)
</p>
</td></tr>
<tr><td><code id="huff.attrac_+3A_origins">origins</code></td>
<td>

<p>the column in the interaction matrix <code>huffdataset</code> containing the origins (e.g. ZIP codes)
</p>
</td></tr>
<tr><td><code id="huff.attrac_+3A_locations">locations</code></td>
<td>

<p>the column in the interaction matrix <code>huffdataset</code> containing the locations (e.g. store codes)
</p>
</td></tr>
<tr><td><code id="huff.attrac_+3A_attrac">attrac</code></td>
<td>

<p>the column in the interaction matrix <code>huffdataset</code> containing the attraction variable (e.g. sales area)
</p>
</td></tr>
<tr><td><code id="huff.attrac_+3A_dist">dist</code></td>
<td>

<p>the column in the interaction matrix <code>huffdataset</code> containing the transport costs (e.g. travelling time or street distance)
</p>
</td></tr>
<tr><td><code id="huff.attrac_+3A_lambda">lambda</code></td>
<td>

<p>a single numeric value of <code class="reqn">\lambda</code> for the (exponential) weighting of distance (transport costs, default: -2)
</p>
</td></tr>
<tr><td><code id="huff.attrac_+3A_dtype">dtype</code></td>
<td>

<p>Type of distance weighting function: <code>"pow"</code> (power function), <code>"exp"</code> (exponential function) or <code>"logistic"</code> (logistic function) (default: <code>dtype = "pow"</code>)
</p>
</td></tr>
<tr><td><code id="huff.attrac_+3A_lambda2">lambda2</code></td>
<td>

<p>if <code>dtype = "logistic"</code> a second <code class="reqn">\lambda</code> parameter is needed
</p>
</td></tr>
<tr><td><code id="huff.attrac_+3A_localmarket_dataset">localmarket_dataset</code></td>
<td>

<p>A <code>data.frame</code> containing the origins saved in a column which has the same name as in <code>huffdataset</code> and another column containing the local market potential 
</p>
</td></tr>
<tr><td><code id="huff.attrac_+3A_origin_id">origin_id</code></td>
<td>

<p>the column in the dataset <code>localmarket_dataset</code> containing the origins (e.g. statistical districts, ZIP codes)
</p>
</td></tr>
<tr><td><code id="huff.attrac_+3A_localmarket">localmarket</code></td>
<td>

<p>the column in the dataset <code>localmarket_dataset</code> containing the local market potential (e.g. purchasing power, number of customers)
</p>
</td></tr>
<tr><td><code id="huff.attrac_+3A_location_dataset">location_dataset</code></td>
<td>

<p>A <code>data.frame</code> containing the suppliers/locations and their observed total values 
</p>
</td></tr>
<tr><td><code id="huff.attrac_+3A_location_id">location_id</code></td>
<td>

<p>the column in the dataset <code>location_dataset</code> containing the locations (e.g. store codes), <code class="reqn">j</code>, according to the codes in <code>huffdataset</code>
</p>
</td></tr>
<tr><td><code id="huff.attrac_+3A_location_total">location_total</code></td>
<td>

<p>the column in the dataset <code>location_dataset</code> containing the observed total values of suppliers/locations, <code class="reqn">T_{j,obs}</code> (e.g. annual sales, total number of customers)
</p>
</td></tr>
<tr><td><code id="huff.attrac_+3A_tolerance">tolerance</code></td>
<td>

<p>accepted value of absolute percentage error between observed (<code class="reqn">T_{j,obs}</code>) and modeled total values (<code class="reqn">T_{j,exp}</code>) to skip a local optimization of location/supplier <code class="reqn">j</code>
</p>
</td></tr>
<tr><td><code id="huff.attrac_+3A_output">output</code></td>
<td>

<p>Type of function output: <code>output = "matrix"</code> returns a Huff interaction matrix with the optimized attraction values and the expected market shares/market areas. If <code>output = "total"</code>, the old (observed) and the new (expected) total values are returned. If <code>output = "attrac"</code>, the optimized attraction values are returned. </p>
</td></tr>
<tr><td><code id="huff.attrac_+3A_show_proc">show_proc</code></td>
<td>

<p>logical argument that indicates if the function prints messages about the state of process during the work (e.g. &ldquo;Processing variable xyz ...&rdquo; or &ldquo;Variable xyz is regarded as dummy variable&rdquo;). Default: <code>show_proc = FALSE</code> (messages off)
</p>
</td></tr>
<tr><td><code id="huff.attrac_+3A_check_df">check_df</code></td>
<td>

<p>logical argument that indicates if the given dataset is checked for correct input, only for internal use, should not be deselected (default: <code>TRUE</code>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In many cases, only total empirical values of the suppliers/locations can be used for market area estimation. This function fits the <em>Huff model</em> not by estimating the parameters but by optimizing the attraction variable (transport cost weighting by <code class="reqn">\lambda</code> is given) using an optimization algorithm based on the idea of the <em>local optimization of attraction</em> algorithm developed by Guessefeldt (2002) and other model fit approaches. This function consists of a single optimization of every supplier/location. Note that the best results can be achieved by repeating the algorithm while evaluating the results (see the function <code>huff.fit()</code>, which extends this algorithm to a given number of iterations).
</p>


<h3>Value</h3>

<p>The function output can be controlled by the function argument <code>output</code>. If <code>output = "matrix"</code> the function returns a Huff interaction matrix with the optimized attraction values and the expected market shares/market areas. If <code>output = "total"</code>, the old (observed) and the new (expected) total values are returned. If <code>output = "attrac"</code>, the optimized attraction values are returned. All results are <code>data.frame</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Wieland
</p>


<h3>References</h3>

<p>Guessefeldt, J. (2002): &ldquo;Zur Modellierung von raeumlichen Kaufkraftstroemen in unvollkommenen Maerkten&rdquo;. In: <em>Erdkunde</em>, <b>56</b>, 4, p. 351-370.
</p>
<p>Wieland, T. (2015): &ldquo;Nahversorgung im Kontext raumoekonomischer Entwicklungen im Lebensmitteleinzelhandel - Konzeption und Durchfuehrung einer GIS-gestuetzten Analyse der Strukturen des Lebensmitteleinzelhandels und der Nahversorgung in Freiburg im Breisgau&rdquo;. Projektbericht. Goettingen : GOEDOC, Dokumenten- und Publikationsserver der Georg-August-Universitaet Goettingen. <a href="http://webdoc.sub.gwdg.de/pub/mon/2015/5-wieland.pdf">http://webdoc.sub.gwdg.de/pub/mon/2015/5-wieland.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+huff.fit">huff.fit</a></code>, <code><a href="#topic+huff.shares">huff.shares</a></code>, <code><a href="#topic+huff.decay">huff.decay</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Freiburg1)
data(Freiburg2)
data(Freiburg3)
# Loading the three Freiburg datasets

# NOTE: This may take a while!
# huff.attrac(Freiburg1, "district", "store", "salesarea", "distance", lambda = -2, dtype= "pow",
# lambda2 = NULL, Freiburg2, "district", "ppower", Freiburg3, "store", "annualsales", 
# tolerance = 5, output = "total")
# Local optimization of store attraction using the function huff.attrac()
# returns a data frame with total values (observed and expected after optimization)
</code></pre>

<hr>
<h2 id='huff.decay'>
Distance decay function in the Huff model
</h2><span id='topic+huff.decay'></span>

<h3>Description</h3>

<p>This function estimates a distance decay function from observed data and compares different function types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>huff.decay(dataset, x, y, plotFunc = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="huff.decay_+3A_dataset">dataset</code></td>
<td>

<p>A <code>data.frame</code> containing the observed interaction data and the transport costs 
</p>
</td></tr>
<tr><td><code id="huff.decay_+3A_x">x</code></td>
<td>

<p>A numeric vector containing the independent variable, the transport costs (e.g. traveling time or street distance)
</p>
</td></tr>
<tr><td><code id="huff.decay_+3A_y">y</code></td>
<td>

<p>A numeric vector containing the dependent variable, the interaction measure (e.g. local market shares, trip volume, visitors per capita) 
</p>
</td></tr>
<tr><td><code id="huff.decay_+3A_plotfunc">plotFunc</code></td>
<td>

<p>logical argument that indicates if the curves are plotted (default: <code>plotFunc = TRUE</code>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>distance decay function</em> is a classic concept in quantitative economic geography and describes the relationship between transport costs and trip volume between origins (<code class="reqn">i</code>) and a destination (<code class="reqn">j</code>). The dependent variable is an indicator of trip volume, such as local market shares or visitors per capita etc., which are explained by the transport costs between all <code class="reqn">i</code> and the destination <code class="reqn">j</code>, <code class="reqn">d_{ij}</code>. 
</p>
<p>The non-linear modeling of transport costs is a key concept of the <em>Huff model</em> (see the function <code>huff.shares</code>). This function estimates and compares different types of possible <em>distance decay functions</em> (linear, power, exponential, logistic) based on observed interaction data.  
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the function parameters (<code>Intercept</code>, <code>Slope</code>), their p values in the regression function (<code>p Intercept</code>, <code>p Slope</code>) and fitting measures (<code>R-Squared</code>, <code>Adj. R-Squared</code>). Optionally, a plot of the four estimated functions and the observed data.
</p>


<h3>Author(s)</h3>

<p>Thomas Wieland
</p>


<h3>References</h3>

<p>Huff, D. L. (1962): &ldquo;Determination of Intra-Urban Retail Trade Areas&rdquo;. Los Angeles : University of California.
</p>
<p>Huff, D. L. (1963): &ldquo;A Probabilistic Analysis of Shopping Center Trade Areas&rdquo;. In: <em>Land Economics</em>, <b>39</b>, 1, p. 81-90.
</p>
<p>Huff, D. L. (1964): &ldquo;Defining and Estimating a Trading Area&rdquo;. In: <em>Journal of Marketing</em>, <b>28</b>, 4, p. 34-38.
</p>
<p>Isard, W. (1960): &ldquo;Methods of Regional Analysis: an Introduction to Regional Science&rdquo;. Cambridge.
</p>
<p>Kanhaeusser, C. (2007): &ldquo;Modellierung und Prognose von Marktgebieten am Beispiel des Moebeleinzelhandels&rdquo;. In: Klein, R./Rauh, J. (eds.): <em>Analysemethodik und Modellierung in der geographischen Handelsforschung</em>. <em>Geographische Handelsforschung</em>, <b>13</b>. Passau. p. 75-110.
</p>
<p>Loeffler, G. (1998): &ldquo;Market areas - a methodological reflection on their boundaries&rdquo;. In: <em>GeoJournal</em>, <b>45</b>, 4, p. 265-272.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+huff.shares">huff.shares</a></code>, <code><a href="#topic+huff.attrac">huff.attrac</a></code>, <code><a href="#topic+huff.fit">huff.fit</a></code>, <code><a href="#topic+mci.fit">mci.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Market area analysis based on the POS survey in shopping1 #

data(shopping1)
# The survey dataset
data(shopping2)
# Dataset with distances and travel times

shopping1_adj &lt;- shopping1[(shopping1$weekday != 3) &amp; (shopping1$holiday != 1) 
&amp; (shopping1$survey != "pretest"),]
# Removing every case from tuesday, holidays and the ones belonging to the pretest

ijmatrix_POS &lt;- ijmatrix.create(shopping1_adj, "resid_code", "POS", "POS_expen")
# Creates an interaction matrix based on the observed frequencies (automatically)
# and the POS expenditures (Variable "POS_expen" separately stated)

ijmatrix_POS_data &lt;- merge(ijmatrix_POS, shopping2, by.x="interaction", by.y="route", 
all.x = TRUE)
# Adding the distances and travel times

ijmatrix_POS_data$freq_ij_abs_cor &lt;- var.correct(ijmatrix_POS_data$freq_ij_abs, 
corr.mode = "inc", incby = 0.1)
# Correcting the absolute values (frequencies) by increasing by 0.1

data(shopping3)
ijmatrix_POS_data_residdata &lt;- merge(ijmatrix_POS_data, shopping3)
# Adding the information about the origins (places of residence) stored in shopping3

ijmatrix_POS_data_residdata$visitper1000 &lt;- (ijmatrix_POS_data_residdata$
freq_ij_abs_cor/ijmatrix_POS_data_residdata$resid_pop2015)*1000
# Calculating the dependent variable
# visitper1000: surveyed customers per 1.000 inhabitants of the origin

ijmatrix_POS_data_residdata &lt;- 
ijmatrix_POS_data_residdata[(!is.na(ijmatrix_POS_data_residdata$
visitper1000)) &amp; (!is.na(ijmatrix_POS_data_residdata$d_time)),]
# Removing NAs (data for some outlier origins and routes not available)

ijmatrix_POS_data_residdata_POS1 &lt;- 
ijmatrix_POS_data_residdata[ijmatrix_POS_data_residdata$POS=="POS1",]
# Dataset for POS1 (town centre)

ijmatrix_POS_data_residdata_POS2 &lt;- 
ijmatrix_POS_data_residdata[ijmatrix_POS_data_residdata$POS=="POS2",]
# Dataset for POS2 (out-of-town shopping centre)

huff.decay(ijmatrix_POS_data_residdata_POS1, "d_km", "visitper1000")
huff.decay(ijmatrix_POS_data_residdata_POS1, "d_time", "visitper1000")
huff.decay(ijmatrix_POS_data_residdata_POS2, "d_km", "visitper1000")
huff.decay(ijmatrix_POS_data_residdata_POS2, "d_time", "visitper1000")
</code></pre>

<hr>
<h2 id='huff.fit'>
Fitting the Huff model using local optimization of attractivity 
</h2><span id='topic+huff.fit'></span>

<h3>Description</h3>

<p>This function fits the Huff model with a given interaction matrix by optimizing the attractivity values of suppliers/locations iteratively and calculates the market shares/market areas
</p>


<h3>Usage</h3>

<pre><code class='language-R'>huff.fit(huffdataset, origins, locations, attrac, dist, lambda = -2, dtype = "pow", 
lambda2 = NULL, localmarket_dataset, origin_id, localmarket, location_dataset, 
location_id, location_total, tolerance = 5, iterations = 3, output = "total", 
show_proc = FALSE, check_df = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="huff.fit_+3A_huffdataset">huffdataset</code></td>
<td>

<p>an interaction matrix which is a <code>data.frame</code> containing the origins, locations and the explanatory variables (attraction, transport costs)
</p>
</td></tr>
<tr><td><code id="huff.fit_+3A_origins">origins</code></td>
<td>

<p>the column in the interaction matrix <code>huffdataset</code> containing the origins (e.g. ZIP codes)
</p>
</td></tr>
<tr><td><code id="huff.fit_+3A_locations">locations</code></td>
<td>

<p>the column in the interaction matrix <code>huffdataset</code> containing the locations (e.g. store codes)
</p>
</td></tr>
<tr><td><code id="huff.fit_+3A_attrac">attrac</code></td>
<td>

<p>the column in the interaction matrix <code>huffdataset</code> containing the attraction variable (e.g. sales area)
</p>
</td></tr>
<tr><td><code id="huff.fit_+3A_dist">dist</code></td>
<td>

<p>the column in the interaction matrix <code>huffdataset</code> containing the transport costs (e.g. travelling time or street distance)
</p>
</td></tr>
<tr><td><code id="huff.fit_+3A_lambda">lambda</code></td>
<td>

<p>a single numeric value of <code class="reqn">\lambda</code> for the (exponential) weighting of distance (transport costs, default: -2)
</p>
</td></tr>
<tr><td><code id="huff.fit_+3A_dtype">dtype</code></td>
<td>

<p>Type of distance weighting function: <code>"pow"</code> (power function), <code>"exp"</code> (exponential function) or <code>"logistic"</code> (logistic function) (default: <code>dtype = "pow"</code>)
</p>
</td></tr>
<tr><td><code id="huff.fit_+3A_lambda2">lambda2</code></td>
<td>

<p>if <code>dtype = "logistic"</code> a second <code class="reqn">\lambda</code> parameter is needed
</p>
</td></tr>
<tr><td><code id="huff.fit_+3A_localmarket_dataset">localmarket_dataset</code></td>
<td>

<p>A <code>data.frame</code> containing the origins saved in a column which has the same name as in <code>huffdataset</code> and another column containing the local market potential 
</p>
</td></tr>
<tr><td><code id="huff.fit_+3A_origin_id">origin_id</code></td>
<td>

<p>the column in the dataset <code>localmarket_dataset</code> containing the origins (e.g. statistical districts, ZIP codes)
</p>
</td></tr>
<tr><td><code id="huff.fit_+3A_localmarket">localmarket</code></td>
<td>

<p>the column in the dataset <code>localmarket_dataset</code> containing the local market potential (e.g. purchasing power, number of customers)
</p>
</td></tr>
<tr><td><code id="huff.fit_+3A_location_dataset">location_dataset</code></td>
<td>

<p>A <code>data.frame</code> containing the suppliers/locations and their observed total values 
</p>
</td></tr>
<tr><td><code id="huff.fit_+3A_location_id">location_id</code></td>
<td>

<p>the column in the dataset <code>location_dataset</code> containing the locations (e.g. store codes), <code class="reqn">j</code>, according to the codes in <code>huffdataset</code>
</p>
</td></tr>
<tr><td><code id="huff.fit_+3A_location_total">location_total</code></td>
<td>

<p>the column in the dataset <code>location_dataset</code> containing the observed total values of suppliers/locations, <code class="reqn">T_{j,obs}</code> (e.g. annual sales, total number of customers)
</p>
</td></tr>
<tr><td><code id="huff.fit_+3A_tolerance">tolerance</code></td>
<td>

<p>accepted value of absolute percentage error between observed (<code class="reqn">T_{j,obs}</code>) and modeled total values (<code class="reqn">T_{j,exp}</code>) to skip a local optimization of location/supplier <code class="reqn">j</code>
</p>
</td></tr>
<tr><td><code id="huff.fit_+3A_iterations">iterations</code></td>
<td>

<p>a single numeric value for the desired number of iterations
</p>
</td></tr>
<tr><td><code id="huff.fit_+3A_output">output</code></td>
<td>

<p>Type of function output: <code>output = "matrix"</code> returns a Huff interaction matrix with the optimized attractivity values and the expected market shares/market areas. If <code>output = "total"</code>, the old (observed) and the new (expected) total values are returned. If <code>output = "diag"</code>, the function returns the diagnosis results (fitting measures) 
</p>
</td></tr>
<tr><td><code id="huff.fit_+3A_show_proc">show_proc</code></td>
<td>

<p>logical argument that indicates if the function prints messages about the state of process during the work (e.g. &ldquo;Processing variable xyz ...&rdquo; or &ldquo;Variable xyz is regarded as dummy variable&rdquo;). Default: <code>show_proc = FALSE</code> (messages off)
</p>
</td></tr>
<tr><td><code id="huff.fit_+3A_check_df">check_df</code></td>
<td>

<p>logical argument that indicates if the given dataset is checked for correct input, only for internal use, should not be deselected (default: <code>TRUE</code>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In many cases, only total empirical values of the suppliers/locations can be used for market area estimation. This function fits the <em>Huff model</em> not by estimating the parameters but by optimizing the attraction variable (transport cost weighting by <code class="reqn">\lambda</code> is given) using an optimization algorithm based on the idea of the <em>local optimization of attraction</em> algorithm developed by Guessefeldt (2002) and other model fit approaches. The fitting process in the <code>huff.fit</code> includes of given number of (<code class="reqn">m</code>) iterations, while the fit gets better with every iteration. The algorithm results can be evaluated by several diagnosis criteria which have been frequently used to evaluate <em>Huff model</em> results: Besides the sum of squared residuals, the function also calculates a <em>Pseudo-R-squared</em> measure and the <em>MAPE (mean average percentage error)</em>, both used by De Beule et al. (2014), and the <em>global error</em> used by Klein (1988).      
</p>


<h3>Value</h3>

<p>The function output can be controlled by the function argument <code>output</code>. If <code>output = "matrix"</code> the function returns a Huff interaction matrix with the optimized attractivity values and the expected market shares/market areas. If <code>output = "total"</code>, the old (observed) and the new (expected) total values are returned. If <code>output = "diag"</code>, the diagnosis results (fitting measures) are returned. All results are <code>data.frame</code>. 
</p>


<h3>Note</h3>

<p>Note that the iterations can be time-consuming and depend on the number of suppliers/locations. Use <code>show_proc = TRUE</code> for monitoring the iteration process.
</p>


<h3>Author(s)</h3>

<p>Thomas Wieland
</p>


<h3>References</h3>

<p>De Beule, M./Van den Poel, D./Van de Weghe, N. (2014): &ldquo;An extended Huff-model for robustly benchmarking and predicting retail network performance&rdquo;. In: <em>Applied Geography</em>, <b>46</b>, 1, p. 80-89.
</p>
<p>Guessefeldt, J. (2002): &ldquo;Zur Modellierung von raeumlichen Kaufkraftstroemen in unvollkommenen Maerkten&rdquo;. In: <em>Erdkunde</em>, <b>56</b>, 4, p. 351-370.
</p>
<p>Klein, R. (1988): &ldquo;Der Lebensmittel-Einzelhandel im Raum Verden. Raeumliches Einkaufsverhalten unter sich wandelnden Bedingungen&rdquo;. <em>Flensburger Arbeitspapiere zur Landeskunde und Raumordnung</em>, <b>6</b>. Flensburg.
</p>
<p>Wieland, T. (2015): &ldquo;Nahversorgung im Kontext raumoekonomischer Entwicklungen im Lebensmitteleinzelhandel - Konzeption und Durchfuehrung einer GIS-gestuetzten Analyse der Strukturen des Lebensmitteleinzelhandels und der Nahversorgung in Freiburg im Breisgau&rdquo;. Projektbericht. Goettingen : GOEDOC, Dokumenten- und Publikationsserver der Georg-August-Universitaet Goettingen. <a href="http://webdoc.sub.gwdg.de/pub/mon/2015/5-wieland.pdf">http://webdoc.sub.gwdg.de/pub/mon/2015/5-wieland.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+huff.attrac">huff.attrac</a></code>, <code><a href="#topic+huff.shares">huff.shares</a></code>, <code><a href="#topic+huff.decay">huff.decay</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Freiburg1)
data(Freiburg2)
data(Freiburg3)
# Loading the three Freiburg datasets

# NOTE: This may take a while!
# huff_total_opt2 &lt;- huff.fit(Freiburg1, "district", "store", "salesarea", "distance", 
# lambda = -2, dtype= "pow", lambda2 = NULL, Freiburg2, "district", "ppower", 
# Freiburg3, "store", "annualsales", tolerance = 1, iterations = 2, output = "total", 
# show_proc = TRUE)
# 2 iterations of the optimization algorithm with an accepted difference of +/- 1 %
# Output of total sales/shares, stored in dataset huff_total_opt10

# model.fit(huff_total_opt2$total_obs, huff_total_opt2$sum_E_j, plotVal = TRUE)
# total_obs = observed total values, originally from dataset Freiburg3
# sum_E_j = expected total values
</code></pre>

<hr>
<h2 id='huff.lambda'>
Fitting the distance parameter lambda in the Huff model
</h2><span id='topic+huff.lambda'></span>

<h3>Description</h3>

<p>This function estimates a distance decay parameter from observed total store/location data (e.g. complete annual turnovers) using bisection or &quot;trial and error&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>huff.lambda(huffdataset, origins, locations, attrac, dist, gamma = 1, atype = "pow", 
gamma2 = NULL, lambda_startv = -1, lambda_endv = -3, dtype = "pow", 
localmarket_dataset, origin_id, localmarket, 
location_dataset, location_id, location_total, 
method = "bisection", iterations = 10, output = "matrix", 
plotVal = FALSE, show_proc = FALSE, check_df = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="huff.lambda_+3A_huffdataset">huffdataset</code></td>
<td>

<p>an interaction matrix which is a <code>data.frame</code> containing the origins, locations and the explanatory variables (attraction, transport costs)
</p>
</td></tr>
<tr><td><code id="huff.lambda_+3A_origins">origins</code></td>
<td>

<p>the column in the interaction matrix <code>huffdataset</code> containing the origins (e.g. ZIP codes)
</p>
</td></tr>
<tr><td><code id="huff.lambda_+3A_locations">locations</code></td>
<td>

<p>the column in the interaction matrix <code>huffdataset</code> containing the locations (e.g. store codes)
</p>
</td></tr>
<tr><td><code id="huff.lambda_+3A_attrac">attrac</code></td>
<td>

<p>the column in the interaction matrix <code>huffdataset</code> containing the attraction variable (e.g. sales area)
</p>
</td></tr>
<tr><td><code id="huff.lambda_+3A_dist">dist</code></td>
<td>

<p>the column in the interaction matrix <code>huffdataset</code> containing the transport costs (e.g. travelling time or street distance)
</p>
</td></tr>
<tr><td><code id="huff.lambda_+3A_gamma">gamma</code></td>
<td>

<p>a single numeric value of <code class="reqn">\gamma</code> for the exponential weighting of the attraction variable (default: 1)
</p>
</td></tr>
<tr><td><code id="huff.lambda_+3A_atype">atype</code></td>
<td>

<p>Type of attraction weighting function: <code>atype = "pow"</code> (power function), <code>atype = "exp"</code> (exponential function) or <code>atype = "logistic"</code> (default: <code>atype = "pow"</code>)
</p>
</td></tr>
<tr><td><code id="huff.lambda_+3A_gamma2">gamma2</code></td>
<td>

<p>if <code>atype = "logistic"</code> a second <code class="reqn">\gamma</code> parameter is needed
</p>
</td></tr>
<tr><td><code id="huff.lambda_+3A_lambda_startv">lambda_startv</code></td>
<td>

<p>Start value for <code class="reqn">\lambda</code> search
</p>
</td></tr>
<tr><td><code id="huff.lambda_+3A_lambda_endv">lambda_endv</code></td>
<td>

<p>End value for <code class="reqn">\lambda</code> search
</p>
</td></tr>
<tr><td><code id="huff.lambda_+3A_dtype">dtype</code></td>
<td>

<p>Type of distance weighting function: <code>dtype = "pow"</code> (power function), <code>dtype = "exp"</code> (exponential function) or <code>dtype = "logistic"</code> (default: <code>dtype = "pow"</code>)
</p>
</td></tr>
<tr><td><code id="huff.lambda_+3A_localmarket_dataset">localmarket_dataset</code></td>
<td>

<p>A <code>data.frame</code> containing the origins saved in a column which has the same name as in <code>huffdataset</code> and another column containing the local market potential 
</p>
</td></tr>
<tr><td><code id="huff.lambda_+3A_origin_id">origin_id</code></td>
<td>

<p>the column in the dataset <code>localmarket_dataset</code> containing the origins (e.g. statistical districts, ZIP codes)
</p>
</td></tr>
<tr><td><code id="huff.lambda_+3A_localmarket">localmarket</code></td>
<td>

<p>the column in the dataset <code>localmarket_dataset</code> containing the local market potential (e.g. purchasing power, number of customers)
</p>
</td></tr>
<tr><td><code id="huff.lambda_+3A_location_dataset">location_dataset</code></td>
<td>

<p>A <code>data.frame</code> containing the suppliers/locations and their observed total values 
</p>
</td></tr>
<tr><td><code id="huff.lambda_+3A_location_id">location_id</code></td>
<td>

<p>the column in the dataset <code>location_dataset</code> containing the locations (e.g. store codes), <code class="reqn">j</code>, according to the codes in <code>huffdataset</code>
</p>
</td></tr>
<tr><td><code id="huff.lambda_+3A_location_total">location_total</code></td>
<td>

<p>the column in the dataset <code>location_dataset</code> containing the observed total values of suppliers/locations, <code class="reqn">T_{j,obs}</code> (e.g. annual sales, total number of customers)
</p>
</td></tr>
<tr><td><code id="huff.lambda_+3A_method">method</code></td>
<td>

<p>If <code>method = "bisection"</code> (default value), the optimal <code class="reqn">\lambda</code> is found by bisection. If <code>method = "compare"</code>, several values are tried and the best one is found (&quot;trial and error&quot;)
</p>
</td></tr>
<tr><td><code id="huff.lambda_+3A_iterations">iterations</code></td>
<td>

<p>a single numeric value for the desired number of iterations
</p>
</td></tr>
<tr><td><code id="huff.lambda_+3A_output">output</code></td>
<td>

<p>If <code>output = "iterations"</code>, the results for every single iteration is shown. If <code>output = "total"</code>, total sales and market shares (or total market area) of the suppliers are shown. 
</p>
</td></tr>
<tr><td><code id="huff.lambda_+3A_plotval">plotVal</code></td>
<td>

<p>If <code>plotVal = TRUE</code>, the function shows a simple plot of <code class="reqn">\lambda</code> values against residuals
</p>
</td></tr>
<tr><td><code id="huff.lambda_+3A_show_proc">show_proc</code></td>
<td>

<p>logical argument that indicates if the function prints messages about the state of process during the work (e.g. &ldquo;Processing variable xyz ...&rdquo;). Default: <code>show_proc = FALSE</code> (messages off)
</p>
</td></tr>
<tr><td><code id="huff.lambda_+3A_check_df">check_df</code></td>
<td>

<p>logical argument that indicates if the given dataset is checked for correct input, only for internal use, should not be deselected (default: <code>TRUE</code>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In many cases, only total empirical values of the suppliers/locations (e.g. annual turnover) can be used for market area estimation. This function fits the <em>Huff model</em> by estimating the <code class="reqn">\lambda</code> parameter iteratively using an optimization algorithm based on the idea of Klein (1988). The fitting process in the <code>huff.lambda</code> includes of given number of iterations, while the fit gets better with every iteration, measured using the sum of squared residuals of observed vs. expected total values. The iterative optimization can be done via bisection (see Kaw et al. 2011, ch. 03.03) or &quot;trial and error&quot; (see Fuelop et al. 2011).
</p>


<h3>Value</h3>

<p>The function output can be controlled by the function argument <code>output</code>. If <code>output = "iterations"</code>, the results for every single iteration is shown (<code>data.frame</code>). If <code>output = "total"</code>, total sales and market shares (or total market area) of the suppliers are shown (<code>data.frame</code>). The default output is a <code>list</code> with <code class="reqn">\gamma</code> and <code class="reqn">\lambda</code>. 
</p>


<h3>Note</h3>

<p>Note that the iterations can be time-consuming and depend on the number of suppliers/locations. Use <code>show_proc = TRUE</code> for monitoring the iteration process.
</p>


<h3>Author(s)</h3>

<p>Thomas Wieland
</p>


<h3>References</h3>

<p>Fuelop, G./Kopetsch, T./Schoepe, P. (2011): &ldquo;Catchment areas of medical practices and the role played by geographical distance in the patient's choice of doctor&rdquo;. In: <em>The Annals of Regional Science</em>, <b>46</b>, 3, p. 691-706.
</p>
<p>Kaw, A. K./Kalu, E. E./Nguyen, D. (2011): &ldquo;Numerical Methods with Applications&rdquo;. <a href="http://nm.mathforcollege.com/topics/textbook_index.html">http://nm.mathforcollege.com/topics/textbook_index.html</a>
</p>
<p>Klein, R. (1988): &ldquo;Der Lebensmittel-Einzelhandel im Raum Verden. Raeumliches Einkaufsverhalten unter sich wandelnden Bedingungen&rdquo;. <em>Flensburger Arbeitspapiere zur Landeskunde und Raumordnung</em>, <b>6</b>. Flensburg.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+huff.attrac">huff.attrac</a></code>, <code><a href="#topic+huff.shares">huff.shares</a></code>, <code><a href="#topic+huff.decay">huff.decay</a></code>, <code><a href="#topic+huff.fit">huff.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DIY1)
data(DIY2)
data(DIY3)
# Loading the three DIY store datasets

DIY_alldata &lt;- merge (DIY1, DIY2, by.x = "j_destination", by.y = "j_destination")
# Add store data to distance matrix

huff_DIY &lt;- huff.shares (DIY_alldata, "i_origin", "j_destination", "A_j_salesarea_sqm", 
"t_ij_min", gamma = 1, lambda = -2)
# Calculating Huff local market shares
# Gamma = 1, Lambda = -2

huff_DIY &lt;- merge (huff_DIY, DIY3, by.x = "i_origin", by.y = "district")
# Add data for origins

huff_DIY_total &lt;- shares.total (huff_DIY, "i_origin", "j_destination", "p_ij", 
"population")
# Calculating total market areas (=sums of customers)

colnames(DIY3) &lt;- c("district", "pop")
# Change column name to "pop" (must be other name)

huff.lambda (huff_DIY, "i_origin", "j_destination", "A_j_salesarea_sqm", 
"t_ij_min", gamma = 1, atype = "pow", gamma2 = NULL,
lambda_startv = -1, lambda_endv = -2.5, dtype= "pow",
DIY3, "district", "pop", huff_DIY_total, "suppliers_single", "sum_E_j", 
method = "bisection", iterations = 10)
# Iterative search for the best lambda value using bisection
# Output: gamma and lambda

huff.lambda (huff_DIY, "i_origin", "j_destination", "A_j_salesarea_sqm", 
"t_ij_min", gamma = 1, atype = "pow", gamma2 = NULL,
lambda_startv = -1, lambda_endv = -2.5, dtype= "pow",
DIY3, "district", "pop", huff_DIY_total, "suppliers_single", "sum_E_j", 
method = "bisection", iterations = 10, output = "iterations", show_proc = TRUE)
# Same procedure, output: single iterations  

huff.lambda (huff_DIY, "i_origin", "j_destination", "A_j_salesarea_sqm", 
"t_ij_min", gamma = 1, atype = "pow", gamma2 = NULL,
lambda_startv = -1, lambda_endv = -2.5, dtype= "pow",
DIY3, "district", "pop", huff_DIY_total, "suppliers_single", "sum_E_j", 
method = "compare", iterations = 10, output = "iterations", show_proc = TRUE, plotVal = TRUE)
# Using compare method, output: single iterations and plot 
</code></pre>

<hr>
<h2 id='huff.shares'>
Huff model market share/market area simulations
</h2><span id='topic+huff.shares'></span>

<h3>Description</h3>

<p>Calculating market areas/local market shares using the probabilistic market area model by Huff
</p>


<h3>Usage</h3>

<pre><code class='language-R'>huff.shares(huffdataset, origins, locations, attrac, dist, gamma = 1, lambda = -2, 
atype = "pow", dtype = "pow", gamma2 = NULL, lambda2 = NULL, check_df = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="huff.shares_+3A_huffdataset">huffdataset</code></td>
<td>

<p>an interaction matrix which is a <code>data.frame</code> containing the origins, locations and the explanatory variables (attraction, transport costs)
</p>
</td></tr>
<tr><td><code id="huff.shares_+3A_origins">origins</code></td>
<td>

<p>the column in the interaction matrix <code>huffdataset</code> containing the origins (e.g. ZIP codes)
</p>
</td></tr>
<tr><td><code id="huff.shares_+3A_locations">locations</code></td>
<td>

<p>the column in the interaction matrix <code>huffdataset</code> containing the locations (e.g. store codes)
</p>
</td></tr>
<tr><td><code id="huff.shares_+3A_attrac">attrac</code></td>
<td>

<p>the column in the interaction matrix <code>huffdataset</code> containing the attraction variable (e.g. sales area)
</p>
</td></tr>
<tr><td><code id="huff.shares_+3A_dist">dist</code></td>
<td>

<p>the column in the interaction matrix <code>huffdataset</code> containing the transport costs (e.g. travelling time or street distance)
</p>
</td></tr>
<tr><td><code id="huff.shares_+3A_gamma">gamma</code></td>
<td>

<p>a single numeric value of <code class="reqn">\gamma</code> for the exponential weighting of the attraction variable (default: 1)
</p>
</td></tr>
<tr><td><code id="huff.shares_+3A_lambda">lambda</code></td>
<td>

<p>a single numeric value of <code class="reqn">\lambda</code> for the (exponential) weighting of distance (transport costs, default: -2)
</p>
</td></tr>
<tr><td><code id="huff.shares_+3A_atype">atype</code></td>
<td>

<p>Type of attraction weighting function: <code>atype = "pow"</code> (power function), <code>atype = "exp"</code> (exponential function) or <code>atype = "logistic"</code> (default: <code>atype = "pow"</code>)
</p>
</td></tr>
<tr><td><code id="huff.shares_+3A_dtype">dtype</code></td>
<td>

<p>Type of distance weighting function: <code>dtype = "pow"</code> (power function), <code>dtype = "exp"</code> (exponential function) or <code>dtype = "logistic"</code> (default: <code>dtype = "pow"</code>)
</p>
</td></tr>
<tr><td><code id="huff.shares_+3A_gamma2">gamma2</code></td>
<td>

<p>if <code>atype = "logistic"</code> a second <code class="reqn">\gamma</code> parameter is needed
</p>
</td></tr>
<tr><td><code id="huff.shares_+3A_lambda2">lambda2</code></td>
<td>

<p>if <code>dtype = "logistic"</code> a second <code class="reqn">\lambda</code> parameter is needed
</p>
</td></tr>
<tr><td><code id="huff.shares_+3A_check_df">check_df</code></td>
<td>

<p>logical argument that indicates if the given dataset is checked for correct input, only for internal use, should not be deselected (default: <code>TRUE</code>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the market shares from a given interaction matrix and given weighting parameters. The result matrix can be processed by the function <code>shares.total()</code> to calculate the total values (e.g. annual sales) and shares.
</p>


<h3>Value</h3>

<p>Returns the input interaction matrix including the calculated shares (<code>p_ij</code>) as <code>data.frame</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Wieland
</p>


<h3>References</h3>

<p>Huff, D. L. (1962): &ldquo;Determination of Intra-Urban Retail Trade Areas&rdquo;. Los Angeles : University of California.
</p>
<p>Huff, D. L. (1963): &ldquo;A Probabilistic Analysis of Shopping Center Trade Areas&rdquo;. In: <em>Land Economics</em>, <b>39</b>, 1, p. 81-90.
</p>
<p>Huff, D. L. (1964): &ldquo;Defining and Estimating a Trading Area&rdquo;. In: <em>Journal of Marketing</em>, <b>28</b>, 4, p. 34-38.
</p>
<p>Loeffler, G. (1998): &ldquo;Market areas - a methodological reflection on their boundaries&rdquo;. In: <em>GeoJournal</em>, <b>45</b>, 4, p. 265-272.
</p>
<p>Wieland, T. (2015): &ldquo;Nahversorgung im Kontext raumoekonomischer Entwicklungen im Lebensmitteleinzelhandel - Konzeption und Durchfuehrung einer GIS-gestuetzten Analyse der Strukturen des Lebensmitteleinzelhandels und der Nahversorgung in Freiburg im Breisgau&rdquo;. Projektbericht. Goettingen : GOEDOC, Dokumenten- und Publikationsserver der Georg-August-Universitaet Goettingen. <a href="http://webdoc.sub.gwdg.de/pub/mon/2015/5-wieland.pdf">http://webdoc.sub.gwdg.de/pub/mon/2015/5-wieland.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+huff.attrac">huff.attrac</a></code>, <code><a href="#topic+huff.fit">huff.fit</a></code>, <code><a href="#topic+huff.decay">huff.decay</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Freiburg1)
data(Freiburg2)
# Loads the data

huff.shares (Freiburg1, "district", "store", "salesarea", "distance")
# Standard weighting (power function with gamma=1 and lambda=-2)
</code></pre>

<hr>
<h2 id='ijmatrix.create'>
Interaction matrix with market shares
</h2><span id='topic+ijmatrix.create'></span>

<h3>Description</h3>

<p>Creation of an interaction matrix with market shares (<code class="reqn">p_{ij}</code>) of every supplier (<code class="reqn">j</code>) in every submarket (<code class="reqn">i</code>) based on the frequencies in the raw data (e.g. household or POS survey). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ijmatrix.create(rawdataset, submarkets, suppliers, ..., remNA = TRUE, 
remSing = FALSE, remSing.val = 1, remSingSupp.val = 1, 
correctVar = FALSE, correctVar.val = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ijmatrix.create_+3A_rawdataset">rawdataset</code></td>
<td>

<p>a <code>data.frame</code> containing the raw data
</p>
</td></tr>
<tr><td><code id="ijmatrix.create_+3A_submarkets">submarkets</code></td>
<td>

<p>the column in the dataset containing the submarkets (e.g. ZIP codes)
</p>
</td></tr>
<tr><td><code id="ijmatrix.create_+3A_suppliers">suppliers</code></td>
<td>

<p>the column in the dataset containing the suppliers (e.g. store codes) 
</p>
</td></tr>
<tr><td><code id="ijmatrix.create_+3A_...">...</code></td>
<td>

<p>other numeric variables in the raw data which were observed and shall be used to calculate market shares (e.g. expenditures)
</p>
</td></tr>
<tr><td><code id="ijmatrix.create_+3A_remna">remNA</code></td>
<td>

<p>logical argument that indicates if <code>NA</code> values of the submarkets and suppliers are removed or not (default: <code>remNA = TRUE</code>, otherwise: <code>remNA = FALSE</code>, which means that <code>NA</code> are considered in the interaction matrix, recoded as factor <code>99999</code>)
</p>
</td></tr>
<tr><td><code id="ijmatrix.create_+3A_remsing">remSing</code></td>
<td>

<p>logical argument that indicates if singular instances of the submarkets and suppliers are removed or not (default: <code>remSing = FALSE</code>)
</p>
</td></tr>
<tr><td><code id="ijmatrix.create_+3A_remsing.val">remSing.val</code></td>
<td>

<p>if <code>remSing = TRUE</code>: numeric value that indicates the limit value of singular instances in the submarket set to be removed from the data
</p>
</td></tr>
<tr><td><code id="ijmatrix.create_+3A_remsingsupp.val">remSingSupp.val</code></td>
<td>

<p>if <code>remSing = TRUE</code>: numeric value that indicates the limit value of singular instances in the supplier set to be removed from the data
</p>
</td></tr>
<tr><td><code id="ijmatrix.create_+3A_correctvar">correctVar</code></td>
<td>

<p>logical argument that indicates if the calculated market shares shall be corrected when they do not match the MCI standards (<code class="reqn">p_{ij} = 0</code>) (default: <code>correctVar = FALSE</code>)
</p>
</td></tr>
<tr><td><code id="ijmatrix.create_+3A_correctvar.val">correctVar.val</code></td>
<td>

<p>if <code>correctVar = TRUE</code>: numeric value which is added to the absolute values before calculating market shares (default: 1)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates an interaction matrix for all <code class="reqn">i</code> submarkets (e.g. geographical regions) and all <code class="reqn">j</code> suppliers (e.g. store locations). The function calculates <code class="reqn">p_{ij}</code> based on the frequencies and, optionally, further market shares calculated from other observed variables in the given raw dataset (e.g. expenditures from submarket <code class="reqn">i</code> at supplier <code class="reqn">j</code>). 
</p>
<p>Single observations with missing submarket or supplier (<code>NA</code>) are removed from the data automatically (unless <code>remNA = FALSE</code>). Optionally, singular instances (e.g. some submarkets or suppliers are only represented once or twice in the whole dataset) can also be removed (<code>remSing = TRUE</code>), where the limit values for extraction can be set by <code>remSing.val</code> and <code>remSingSupp.val</code> (e.g. <code>remSing.val = 2</code> and <code>remSingSupp.val = 1</code> removes every submarket from the interaction matrix which was observed <code class="reqn">\le 2</code> and every supplier observed <code class="reqn">\le 1</code>).
</p>


<h3>Value</h3>

<p>An interaction matrix which is a <code>data.frame</code> containing the <code class="reqn">i</code> x <code class="reqn">j</code> combinations (<code>'interaction'</code>), the submarkets (column is named as in raw data), the suppliers (column is named as in raw data), the observed absolute frequencies of every <code class="reqn">j</code> in every <code class="reqn">i</code> (<code>'freq_ij_abs'</code>), the observed absolute frequencies in every <code class="reqn">i</code> (<code>'freq_i_total'</code>) and the observed market shares of every <code class="reqn">j</code> in every <code class="reqn">i</code> (<code>'p_ij_obs'</code>). If additional variables are stated (e.g. expenditures) which shall be turned into (local) market shares, the output interaction matrix contains absolute values for every interaction, total values for every <code class="reqn">i</code> submarket and market shares (<code class="reqn">p_{ij}</code>) for these variables, too, which are automatically named based on the given variable name (e.g. the market shares based on a raw data variable called <code>expen</code> is named <code>p_ij_obs_expen</code>). The first three variables of the output matrix are factors, the calculated values are numeric.
</p>


<h3>Author(s)</h3>

<p>Thomas Wieland
</p>


<h3>References</h3>

<p>Cooper, L. G./Nakanishi, M. (2010): &ldquo;Market-Share Analysis: Evaluating competitive marketing effectiveness&rdquo;. Boston, Dordrecht, London : Kluwer (first published 1988). E-book version from 2010: <a href="http://www.anderson.ucla.edu/faculty/lee.cooper/MCI_Book/BOOKI2010.pdf">http://www.anderson.ucla.edu/faculty/lee.cooper/MCI_Book/BOOKI2010.pdf</a>
</p>
<p>Huff, D. L./McCallum, D. (2008): &ldquo;Calibrating the Huff Model Using ArcGIS Business Analyst&rdquo;. <em>ESRI White Paper</em>, September 2008. <a href="https://www.esri.com/library/whitepapers/pdfs/calibrating-huff-model.pdf">https://www.esri.com/library/whitepapers/pdfs/calibrating-huff-model.pdf</a>
</p>
<p>Wieland, T. (2015): &ldquo;Raeumliches Einkaufsverhalten und Standortpolitik im Einzelhandel unter Beruecksichtigung von Agglomerationseffekten. Theoretische Erklaerungsansaetze, modellanalytische Zugaenge und eine empirisch-oekonometrische Marktgebietsanalyse anhand eines Fallbeispiels aus dem laendlichen Raum Ostwestfalens/Suedniedersachsens&rdquo;. <em>Geographische Handelsforschung</em>, <b>23</b>. 289 pages. Mannheim : MetaGIS.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ijmatrix.shares">ijmatrix.shares</a></code>, <code><a href="#topic+ijmatrix.crosstab">ijmatrix.crosstab</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating an interaction matrix based on the POS survey in grocery1 #

data(grocery1)
# Loads the data
ijmatrix.create (grocery1, "plz_submarket", "store_code")
# Creates an interaction matrix with local market shares based on frequencies

mynewmcidata &lt;- ijmatrix.create (grocery1, "plz_submarket", "store_code")
# Save results directly in a new dataset

ijmatrix.create (grocery1, "plz_submarket", "store_code", "trip_expen")
# Creates an interaction matrix with local market shares based on frequencies
# and expenditures (Variable "trip_expen")



# MCI analysis for the grocery store market areas based on the POS survey in shopping1 #

data(shopping1)
# Loading the survey dataset
data(shopping2)
# Loading the distance/travel time dataset
data(shopping3)
# Loading the dataset containing information about the city districts
data(shopping4)
# Loading the grocery store data

shopping1_KAeast &lt;- shopping1[shopping1$resid_code %in% 
shopping3$resid_code[shopping3$KA_east == 1],]
# Extracting only inhabitants of the eastern districts of Karlsruhe

ijmatrix_gro_adj &lt;- ijmatrix.create(shopping1_KAeast, "resid_code",
"gro_purchase_code", "gro_purchase_expen", remSing = TRUE, remSing.val = 1,
remSingSupp.val = 2, correctVar = TRUE, correctVar.val = 0.1)
# Removing singular instances/outliers (remSing = TRUE) incorporating
# only suppliers which are at least obtained three times (remSingSupp.val = 2)
# Correcting the values (correctVar = TRUE)
# by adding 0.1 to the absolute values (correctVar.val = 0.1)

ijmatrix_gro_adj &lt;- ijmatrix_gro_adj[(ijmatrix_gro_adj$gro_purchase_code !=
"REFORMHAUSBOESER") &amp; (ijmatrix_gro_adj$gro_purchase_code != "WMARKT_DURLACH")
&amp; (ijmatrix_gro_adj$gro_purchase_code != "X_INCOMPLETE_STORE"),]
# Remove non-regarded observations

ijmatrix_gro_adj_dist &lt;- merge (ijmatrix_gro_adj, shopping2, by.x="interaction",
by.y="route")
# Include the distances and travel times (shopping2)
ijmatrix_gro_adj_dist_stores &lt;- merge (ijmatrix_gro_adj_dist, shopping4,
by.x = "gro_purchase_code", by.y = "location_code")
# Adding the store information (shopping4)

mci.transvar(ijmatrix_gro_adj_dist_stores, "resid_code", "gro_purchase_code", 
"p_ij_obs")
# Log-centering transformation of one variable (p_ij_obs)

ijmatrix_gro_transf &lt;- mci.transmat(ijmatrix_gro_adj_dist_stores, "resid_code",
"gro_purchase_code", "p_ij_obs", "d_time", "salesarea_qm")
# Log-centering transformation of the interaction matrix

mcimodel_gro_trips &lt;- mci.fit(ijmatrix_gro_adj_dist_stores, "resid_code",
"gro_purchase_code", "p_ij_obs", "d_time", "salesarea_qm")
# MCI model for the grocery store market areas
# shares: "p_ij_obs", explanatory variables: "d_time", "salesarea_qm"

summary(mcimodel_gro_trips)
# Use like lm
</code></pre>

<hr>
<h2 id='ijmatrix.crosstab'>
Converting interaction matrix with market shares to crosstable
</h2><span id='topic+ijmatrix.crosstab'></span>

<h3>Description</h3>

<p>This function converts a given interaction matrix with (local) market shares to a crosstable where the rows are the submarkets and the columns contain the market shares 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ijmatrix.crosstab(mcidataset, submarkets, suppliers, shares)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ijmatrix.crosstab_+3A_mcidataset">mcidataset</code></td>
<td>

<p>The interaction matrix containing the submarkets/origins, suppliers/locations and local market shares
</p>
</td></tr>
<tr><td><code id="ijmatrix.crosstab_+3A_submarkets">submarkets</code></td>
<td>

<p>the column in the dataset containing the submarkets (e.g. ZIP codes)
</p>
</td></tr>
<tr><td><code id="ijmatrix.crosstab_+3A_suppliers">suppliers</code></td>
<td>

<p>the column in the dataset containing the suppliers (e.g. store codes)
</p>
</td></tr>
<tr><td><code id="ijmatrix.crosstab_+3A_shares">shares</code></td>
<td>

<p>the column in the dataset containing the local market shares
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In many cases the results of a market area analysis shall be visualized in a map, e.g. by pie charts or contour lines which belongs to the standard map types in Geographical Information Systems (GIS). An interaction matrix can not be processed directly in a GIS due to its linear character. This function converts an interaction matrix into a special kind of crosstable where the rows contain the origins <code class="reqn">i</code> and the local market shares <code class="reqn">p_{ij}</code> are represented by the columns. The submarkets/origins ID (rows) can be joined directly to the geodata (e.g. point shapefile) while the columns can be used for visualization.    
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> containing <code class="reqn">i</code> rows and <code class="reqn">j+1</code> columns (suppliers/locations and one column containing the submarkets/origins).
</p>


<h3>Author(s)</h3>

<p>Thomas Wieland
</p>


<h3>References</h3>

<p>Cooper, L. G./Nakanishi, M. (2010): &ldquo;Market-Share Analysis: Evaluating competitive marketing effectiveness&rdquo;. Boston, Dordrecht, London : Kluwer (first published 1988). E-book version from 2010: <a href="http://www.anderson.ucla.edu/faculty/lee.cooper/MCI_Book/BOOKI2010.pdf">http://www.anderson.ucla.edu/faculty/lee.cooper/MCI_Book/BOOKI2010.pdf</a>
</p>
<p>Huff, D. L./McCallum, D. (2008): &ldquo;Calibrating the Huff Model Using ArcGIS Business Analyst&rdquo;. <em>ESRI White Paper</em>, September 2008. <a href="https://www.esri.com/library/whitepapers/pdfs/calibrating-huff-model.pdf">https://www.esri.com/library/whitepapers/pdfs/calibrating-huff-model.pdf</a>
</p>
<p>Wieland, T. (2015): &ldquo;Raeumliches Einkaufsverhalten und Standortpolitik im Einzelhandel unter Beruecksichtigung von Agglomerationseffekten. Theoretische Erklaerungsansaetze, modellanalytische Zugaenge und eine empirisch-oekonometrische Marktgebietsanalyse anhand eines Fallbeispiels aus dem laendlichen Raum Ostwestfalens/Suedniedersachsens&rdquo;. <em>Geographische Handelsforschung</em>, <b>23</b>. 289 pages. Mannheim : MetaGIS.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ijmatrix.create">ijmatrix.create</a></code>, <code><a href="#topic+ijmatrix.shares">ijmatrix.shares</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grocery2)
# Loads the data

grocery2_cross &lt;- ijmatrix.crosstab(grocery2, "plz_submarket", "store_code", "p_ij_obs")
# Converts the market shares in the grocery2 dataset to a crosstable
</code></pre>

<hr>
<h2 id='ijmatrix.shares'>
Market shares in interaction matrix
</h2><span id='topic+ijmatrix.shares'></span>

<h3>Description</h3>

<p>Calculating market shares in an interaction matrix based on the observations of the regarded variable. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ijmatrix.shares(rawmatrix, submarkets, suppliers, observations, 
varname_total = "freq_i_total", varname_shares = "p_ij_obs")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ijmatrix.shares_+3A_rawmatrix">rawmatrix</code></td>
<td>

<p>a <code>data.frame</code> containing the submarkets, suppliers and the observed data
</p>
</td></tr>
<tr><td><code id="ijmatrix.shares_+3A_submarkets">submarkets</code></td>
<td>

<p>the column in the dataset containing the submarkets (e.g. ZIP codes)
</p>
</td></tr>
<tr><td><code id="ijmatrix.shares_+3A_suppliers">suppliers</code></td>
<td>

<p>the column in the dataset containing the suppliers (e.g. store codes)
</p>
</td></tr>
<tr><td><code id="ijmatrix.shares_+3A_observations">observations</code></td>
<td>

<p>the column with the regarded variable (e.g. frequencies, expenditures, turnovers)
</p>
</td></tr>
<tr><td><code id="ijmatrix.shares_+3A_varname_total">varname_total</code></td>
<td>

<p>character value, name of the variable for the total absolute values of the <code class="reqn">i</code> submarkets in the output (default: <code>varname_total = "freq_i_total"</code>)
</p>
</td></tr>
<tr><td><code id="ijmatrix.shares_+3A_varname_shares">varname_shares</code></td>
<td>

<p>character value, name of the variable for the market shares <code class="reqn">p_{ij}</code> in the output (default: <code>varname_shares = "p_ij_obs"</code>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the market shares of every <code class="reqn">j</code> in every <code class="reqn">i</code> (<code class="reqn">p_{ij}</code>) based on an existing interaction matrix.
</p>


<h3>Value</h3>

<p>The input interaction matrix which is a <code>data.frame</code> with a new column <code>'p_ij_obs'</code> (or another stated name in the argument <code>varname_shares</code>) or, if used after <code><a href="#topic+ijmatrix.create">ijmatrix.create</a></code>, an update of the columns <code>'freq_i_total'</code> and <code>'p_ij_obs'</code> (or different stated names in the arguments <code>varname_total</code> and/or <code>varname_shares</code>).
</p>


<h3>Author(s)</h3>

<p>Thomas Wieland
</p>


<h3>References</h3>

<p>Cooper, L. G./Nakanishi, M. (2010): &ldquo;Market-Share Analysis: Evaluating competitive marketing effectiveness&rdquo;. Boston, Dordrecht, London : Kluwer (first published 1988). E-book version from 2010: <a href="http://www.anderson.ucla.edu/faculty/lee.cooper/MCI_Book/BOOKI2010.pdf">http://www.anderson.ucla.edu/faculty/lee.cooper/MCI_Book/BOOKI2010.pdf</a>
</p>
<p>Huff, D. L./McCallum, D. (2008): &ldquo;Calibrating the Huff Model Using ArcGIS Business Analyst&rdquo;. <em>ESRI White Paper</em>, September 2008. <a href="https://www.esri.com/library/whitepapers/pdfs/calibrating-huff-model.pdf">https://www.esri.com/library/whitepapers/pdfs/calibrating-huff-model.pdf</a>
</p>
<p>Wieland, T. (2015): &ldquo;Raeumliches Einkaufsverhalten und Standortpolitik im Einzelhandel unter Beruecksichtigung von Agglomerationseffekten. Theoretische Erklaerungsansaetze, modellanalytische Zugaenge und eine empirisch-oekonometrische Marktgebietsanalyse anhand eines Fallbeispiels aus dem laendlichen Raum Ostwestfalens/Suedniedersachsens&rdquo;. <em>Geographische Handelsforschung</em>, <b>23</b>. 289 pages. Mannheim : MetaGIS.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ijmatrix.create">ijmatrix.create</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(grocery1)
# Loads the data

mymcidata &lt;- ijmatrix.create (grocery1, "plz_submarket", "store_code")
# Creates an interaction matrix with market shares based on the frequencies 
# of visited grocery stores and saves results directly in a new dataset
mymcidata$freq_ij_corr &lt;- var.correct(mymcidata$freq_ij_abs, 1)
# Corrects the frequency variable (no zero or negative values allowed)
mymcidata_shares &lt;- ijmatrix.shares(mymcidata, "plz_submarket", "store_code", "freq_ij_corr")
# Calculates market shares based on the corrected frequencies
# and saves the results as a new dataset
</code></pre>

<hr>
<h2 id='lm.beta'>
Beta regression coefficients
</h2><span id='topic+lm.beta'></span>

<h3>Description</h3>

<p>Calculating the standardized (beta) regression coefficients of linear models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm.beta(linmod, dummy.na = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm.beta_+3A_linmod">linmod</code></td>
<td>

<p>A <code>lm</code> object (linear regression model) with more than one independent variable
</p>
</td></tr>
<tr><td><code id="lm.beta_+3A_dummy.na">dummy.na</code></td>
<td>

<p>logical argument that indicates if dummy variables should be ignored when calculating the beta weights (default: <code>TRUE</code>). Note that beta weights of dummy variables do not make any sense
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standardized coefficients (beta coefficients) show how many standard deviations a dependent variable will change when the regarded independent variable is increased by a standard deviation. The <code class="reqn">\beta</code> values are used in multiple linear regression models to compare the real effect (power) of the independent variables when they are measured in different units. Note that <code class="reqn">\beta</code> values do not make any sense for dummy variables since they cannot change by a standard deviation.     
</p>


<h3>Value</h3>

<p>A <code>list</code> containing all independent variables and the corresponding standardized coefficients. 
</p>


<h3>Author(s)</h3>

<p>Thomas Wieland
</p>


<h3>References</h3>

<p>Backhaus, K./Erichson, B./Plinke, W./Weiber, R. (2016): &ldquo;Multivariate Analysemethoden: Eine anwendungsorientierte Einfuehrung&rdquo;. Berlin: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- runif(100)
x2 &lt;- runif(100)
# random values for two independent variables (x1, x2)
y &lt;- runif(100)
# random values for the dependent variable (y)
testmodel &lt;- lm(y~x1+x2)
# OLS regression
summary(testmodel)
# summary
lm.beta(testmodel)
# beta coefficients
</code></pre>

<hr>
<h2 id='mci.fit'>
Fitting the MCI model
</h2><span id='topic+mci.fit'></span>

<h3>Description</h3>

<p>This function fits the MCI model based on a given MCI interaction matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mci.fit(mcidataset, submarkets, suppliers, shares, ..., origin = TRUE, show_proc = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mci.fit_+3A_mcidataset">mcidataset</code></td>
<td>

<p>an interaction matrix which is a <code>data.frame</code> containing the submarkets, suppliers, the observed market shares (<code class="reqn">p_{ij}</code>) and the explanatory variables
</p>
</td></tr>
<tr><td><code id="mci.fit_+3A_submarkets">submarkets</code></td>
<td>

<p>the column in the interaction matrix <code>mcidataset</code> containing the submarkets
</p>
</td></tr>
<tr><td><code id="mci.fit_+3A_suppliers">suppliers</code></td>
<td>

<p>the column in the interaction matrix <code>mcidataset</code> containing the suppliers
</p>
</td></tr>
<tr><td><code id="mci.fit_+3A_shares">shares</code></td>
<td>

<p>the column in the interaction matrix <code>mcidataset</code> containing the observed market shares (<code class="reqn">p_{ij}</code>), numeric
</p>
</td></tr>
<tr><td><code id="mci.fit_+3A_...">...</code></td>
<td>

<p>the column(s) of the explanatory variable(s) (at least one), numeric and positive (or dummy [1,0])
</p>
</td></tr>
<tr><td><code id="mci.fit_+3A_origin">origin</code></td>
<td>

<p>logical argument that indicates if an intercept is included in the model or it is a regression through the origin (default <code>origin = TRUE</code>)
</p>
</td></tr>
<tr><td><code id="mci.fit_+3A_show_proc">show_proc</code></td>
<td>

<p>logical argument that indicates if the function prints messages about the state of process during the work (e.g. &ldquo;Processing variable xyz ...&rdquo; or &ldquo;Variable xyz is regarded as dummy variable&rdquo;). Default: <code>show_proc = FALSE</code> (messages off)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function transforms the input dataset (MCI interaction matrix) to regression-ready-data with the <em>log-centering transformation</em> by Nakanishi/Cooper (1974) and, therefore, the data is fitted by a linear regression model. The return of the function <code>mci.fit()</code> can be treated exactly like the output of the <code>lm()</code> function. The column in the interaction matrix <code>mcidataset</code> containing the shares is the 4th parameter of the function (<code>shares</code>). The further arguments (<code>...</code>) are the columns with the explanatory variables (attractivity/utility values of the <code class="reqn">j</code> alternatives, characteristics of the <code class="reqn">i</code> submarkets). The function identifies dummy variables which are not transformed (because they do not have to be). Normally, in MCI analyzes no intercept is included into the transformed linear model due to the requirement of logically consistent market shares as model results (see above), so the default is a regression through the origin (<code>origin = TRUE</code>). Note: If an intercept is included (<code>origin = FALSE</code>) (and also if dummy variables are used as explanatories), the <em>inverse log-centering transformation</em> by Nakanishi/Cooper (1982) has to be used for simulations.
</p>


<h3>Value</h3>

<p>The function <code>mci.fit()</code> returns an object of class <code>lm</code>. The full information (estimates, significance, R-squared etc.) can be adressed by the function <code>summary()</code>. The explanatory variables are marked with a &quot;_t&quot; to indicate that they were transformed by log-centering transformation.
</p>


<h3>Author(s)</h3>

<p>Thomas Wieland
</p>


<h3>References</h3>

<p>Colome Perales, R. (2002): &ldquo;Consumer Choice in Competitive Location Models&rdquo;. Barcelona.
</p>
<p>Gonzalez-Benito, O./Greatorex, M./Munos-Gallego, P. A. (2000): &ldquo;Assessment of potential retail segmentation variables - An approach based on a subjective MCI resource allocation model&rdquo;. In: <em>Journal of Retailing and Consumer Services</em>, <b>7</b>, 3, p. 171-179.
</p>
<p>Hartmann, M. (2005): &ldquo;Gravitationsmodelle als Verfahren der Standortanalyse im Einzelhandel&rdquo;. <em>Statistik Regional Electronic Papers</em>, <b>02/2005</b>. Halle.
</p>
<p>Huff, D. L./Batsell, R. R. (1975): &ldquo;Conceptual and Operational Problems with Market Share Models of Consumer Spatial Behavior&rdquo;. In: <em>Advances in Consumer Research</em>, <b>2</b>, p. 165-172.
</p>
<p>Huff, D. L./McCallum, D. (2008): &ldquo;Calibrating the Huff Model Using ArcGIS Business Analyst&rdquo;. <em>ESRI White Paper</em>, September 2008. <a href="https://www.esri.com/library/whitepapers/pdfs/calibrating-huff-model.pdf">https://www.esri.com/library/whitepapers/pdfs/calibrating-huff-model.pdf</a>
</p>
<p>Nakanishi, M./Cooper, L. G. (1974): &ldquo;Parameter Estimation for a Multiplicative Competitive Interaction Model - Least Squares Approach&rdquo;. In: <em>Journal of Marketing Research</em>, <b>11</b>, 3, p. 303-311.
</p>
<p>Nakanishi, M./Cooper, L. G. (1982): &ldquo;Simplified Estimation Procedures for MCI Models&rdquo;. In: <em>Marketing Science</em>, <b>1</b>, 3, p. 314-322. 
</p>
<p>Suarez-Vega, R./Gutierrez-Acuna, J. L./Rodriguez-Diaz, M. (2015): &ldquo;Locating a supermarket using a locally calibrated Huff model&rdquo;. In: <em>International Journal of Geographical Information Science</em>, <b>29</b>, 2, p. 217-233.
</p>
<p>Tihi, B./Oruc, N. (2012): &ldquo;Competitive Location Assessment - the MCI Approach&rdquo;. In: <em>South East European Journal of Economics and Business</em>, <b>7</b>, 2, p. 35-49. 
</p>
<p>Wieland, T. (2013): &ldquo;Einkaufsstaettenwahl, Einzelhandelscluster und raeumliche Versorgungsdisparitaeten - Modellierung von Marktgebieten im Einzelhandel unter Beruecksichtigung von Agglomerationseffekten&rdquo;. In: Schrenk, M./Popovich, V./Zeile, P./Elisei, P. (eds.): REAL CORP 2013. Planning Times. Proceedings of 18th International Conference on Urban Planning, Regional Development and Information Society. Schwechat. p. 275-284. <a href="http://www.corp.at/archive/CORP2013_98.pdf">http://www.corp.at/archive/CORP2013_98.pdf</a>
</p>
<p>Wieland, T. (2015): &ldquo;Raeumliches Einkaufsverhalten und Standortpolitik im Einzelhandel unter Beruecksichtigung von Agglomerationseffekten. Theoretische Erklaerungsansaetze, modellanalytische Zugaenge und eine empirisch-oekonometrische Marktgebietsanalyse anhand eines Fallbeispiels aus dem laendlichen Raum Ostwestfalens/Suedniedersachsens&rdquo;. <em>Geographische Handelsforschung</em>, <b>23</b>. 289 pages. Mannheim : MetaGIS.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mci.transmat">mci.transmat</a></code>, <code><a href="#topic+mci.transvar">mci.transvar</a></code>, <code><a href="#topic+mci.shares">mci.shares</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># MCI analysis for the grocery store market areas based on the POS survey in shopping1 #

data(shopping1)
# Loading the survey dataset
data(shopping2)
# Loading the distance/travel time dataset
data(shopping3)
# Loading the dataset containing information about the city districts
data(shopping4)
# Loading the grocery store data

shopping1_KAeast &lt;- shopping1[shopping1$resid_code %in% 
shopping3$resid_code[shopping3$KA_east == 1],]
# Extracting only inhabitants of the eastern districts of Karlsruhe

ijmatrix_gro_adj &lt;- ijmatrix.create(shopping1_KAeast, "resid_code",
"gro_purchase_code", "gro_purchase_expen", remSing = TRUE, remSing.val = 1,
remSingSupp.val = 2, correctVar = TRUE, correctVar.val = 0.1)
# Removing singular instances/outliers (remSing = TRUE) incorporating
# only suppliers which are at least obtained three times (remSingSupp.val = 2)
# Correcting the values (correctVar = TRUE)
# by adding 0.1 to the absolute values (correctVar.val = 0.1)

ijmatrix_gro_adj &lt;- ijmatrix_gro_adj[(ijmatrix_gro_adj$gro_purchase_code !=
"REFORMHAUSBOESER") &amp; (ijmatrix_gro_adj$gro_purchase_code != "WMARKT_DURLACH")
&amp; (ijmatrix_gro_adj$gro_purchase_code != "X_INCOMPLETE_STORE"),]
# Remove non-regarded observations

ijmatrix_gro_adj_dist &lt;- merge (ijmatrix_gro_adj, shopping2, by.x="interaction",
by.y="route")
# Include the distances and travel times (shopping2)
ijmatrix_gro_adj_dist_stores &lt;- merge (ijmatrix_gro_adj_dist, shopping4,
by.x = "gro_purchase_code", by.y = "location_code")
# Adding the store information (shopping4)

mci.transvar(ijmatrix_gro_adj_dist_stores, "resid_code", "gro_purchase_code", 
"p_ij_obs")
# Log-centering transformation of one variable (p_ij_obs)

ijmatrix_gro_transf &lt;- mci.transmat(ijmatrix_gro_adj_dist_stores, "resid_code",
"gro_purchase_code", "p_ij_obs", "d_time", "salesarea_qm")
# Log-centering transformation of the interaction matrix

mcimodel_gro_trips &lt;- mci.fit(ijmatrix_gro_adj_dist_stores, "resid_code",
"gro_purchase_code", "p_ij_obs", "d_time", "salesarea_qm")
# MCI model for the grocery store market areas
# shares: "p_ij_obs", explanatory variables: "d_time", "salesarea_qm"

summary(mcimodel_gro_trips)
# Use like lm
</code></pre>

<hr>
<h2 id='mci.shares'>
MCI market share/market area simulations
</h2><span id='topic+mci.shares'></span>

<h3>Description</h3>

<p>This function calculates (local) market shares based on specified explanatory variables and their weighting parameters in a given MCI interaction matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mci.shares(mcidataset, submarkets, suppliers, ..., mcitrans = "lc", interc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mci.shares_+3A_mcidataset">mcidataset</code></td>
<td>

<p>an interaction matrix which is a <code>data.frame</code> containing the submarkets, suppliers and the explanatory variables
</p>
</td></tr>
<tr><td><code id="mci.shares_+3A_submarkets">submarkets</code></td>
<td>

<p>the column in the interaction matrix <code>mcidataset</code> containing the submarkets
</p>
</td></tr>
<tr><td><code id="mci.shares_+3A_suppliers">suppliers</code></td>
<td>

<p>the column in the interaction matrix <code>mcidataset</code> containing the suppliers
</p>
</td></tr>
<tr><td><code id="mci.shares_+3A_...">...</code></td>
<td>

<p>the column(s) of the explanatory variable(s) (at least one), numeric and positive (or dummy [1,0]), and their weighting parameter(s). The parameter(s) must follow the particular variable(s): <code>mcivariable1, parameter1, ...</code>
</p>
</td></tr>
<tr><td><code id="mci.shares_+3A_mcitrans">mcitrans</code></td>
<td>

<p>defines if the regular multiplicative formula is used or the <em>inverse log-centering transformation</em> where the explanatory variables are MCI-transformed and linked by addition in an exponential function instead of multiplication. This transformation is necessary if an intercept is included in the model and/or if dummy variables are used as explanatories (default: <code>mcitrans = "lc"</code>, which indicates the regular log-centering transformation)
</p>
</td></tr>
<tr><td><code id="mci.shares_+3A_interc">interc</code></td>
<td>

<p>if <code>mcitrans = "ilc"</code>: logical argument that indicates if an intercept is included in the model (default <code>interc = NULL</code>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this function, the input dataset (MCI interaction matrix) is used for a calculation of (local) market shares (<code class="reqn">p_{ij}</code>), based on (at least one) given explanatory variable(s) and (a) given weighting parameter(s). If an intercept is included in the model and/or if dummy variables are used as explanatories, the <em>inverse log-centering transformation</em> by Nakanishi/Cooper (1982) has to be used for simulations (<code>mcitrans = "ilc"</code>).
</p>


<h3>Value</h3>

<p>The function <code>mci.shares()</code> returns the input interaction matrix (<code>data.frame</code>) with new variables/columns, where the last one (<code>p_ij</code>) is the one of interest, containing the (local) market shares of the <code class="reqn">j</code> suppliers in the <code class="reqn">i</code> submarkets (<code class="reqn">p_{ij}</code>).
</p>


<h3>Author(s)</h3>

<p>Thomas Wieland
</p>


<h3>References</h3>

<p>Huff, D. L./Batsell, R. R. (1975): &ldquo;Conceptual and Operational Problems with Market Share Models of Consumer Spatial Behavior&rdquo;. In: <em>Advances in Consumer Research</em>, <b>2</b>, p. 165-172.
</p>
<p>Huff, D. L./McCallum, D. (2008): &ldquo;Calibrating the Huff Model Using ArcGIS Business Analyst&rdquo;. <em>ESRI White Paper</em>, September 2008. <a href="https://www.esri.com/library/whitepapers/pdfs/calibrating-huff-model.pdf">https://www.esri.com/library/whitepapers/pdfs/calibrating-huff-model.pdf</a>
</p>
<p>Nakanishi, M./Cooper, L. G. (1974): &ldquo;Parameter Estimation for a Multiplicative Competitive Interaction Model - Least Squares Approach&rdquo;. In: <em>Journal of Marketing Research</em>, <b>11</b>, 3, p. 303-311.
</p>
<p>Nakanishi, M./Cooper, L. G. (1982): &ldquo;Simplified Estimation Procedures for MCI Models&rdquo;. In: <em>Marketing Science</em>, <b>1</b>, 3, p. 314-322.
</p>
<p>Wieland, T. (2013): &ldquo;Einkaufsstaettenwahl, Einzelhandelscluster und raeumliche Versorgungsdisparitaeten - Modellierung von Marktgebieten im Einzelhandel unter Beruecksichtigung von Agglomerationseffekten&rdquo;. In: Schrenk, M./Popovich, V./Zeile, P./Elisei, P. (eds.): REAL CORP 2013. Planning Times. Proceedings of 18th International Conference on Urban Planning, Regional Development and Information Society. Schwechat. p. 275-284. <a href="http://www.corp.at/archive/CORP2013_98.pdf">http://www.corp.at/archive/CORP2013_98.pdf</a>
</p>
<p>Wieland, T. (2015): &ldquo;Raeumliches Einkaufsverhalten und Standortpolitik im Einzelhandel unter Beruecksichtigung von Agglomerationseffekten. Theoretische Erklaerungsansaetze, modellanalytische Zugaenge und eine empirisch-oekonometrische Marktgebietsanalyse anhand eines Fallbeispiels aus dem laendlichen Raum Ostwestfalens/Suedniedersachsens&rdquo;. <em>Geographische Handelsforschung</em>, <b>23</b>. 289 pages. Mannheim : MetaGIS.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mci.fit">mci.fit</a></code>, <code><a href="#topic+mci.transmat">mci.transmat</a></code>, <code><a href="#topic+mci.transvar">mci.transvar</a></code>, <code><a href="#topic+shares.total">shares.total</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Freiburg1)
data(Freiburg2)
# Loads the data

mynewmatrix &lt;- mci.shares(Freiburg1, "district", "store", "salesarea", 1, "distance", -2)
# Calculating shares based on two attractivity/utility variables

mynewmatrix_alldata &lt;- merge(mynewmatrix, Freiburg2)
# Merge interaction matrix with district data (purchasing power)

shares.total (mynewmatrix_alldata, "district", "store", "p_ij", "ppower")
# Calculation of total sales 
</code></pre>

<hr>
<h2 id='mci.shares.elast'>
Market share elasticities
</h2><span id='topic+mci.shares.elast'></span>

<h3>Description</h3>

<p>This function calculates the market share elasticities (point elasticity) with respect to an attraction/utility variable and its given weighting parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mci.shares.elast (mcidataset, submarkets, suppliers, shares, mcivar, mciparam, 
check_df = TRUE)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mci.shares.elast_+3A_mcidataset">mcidataset</code></td>
<td>

<p>an interaction matrix which is a <code>data.frame</code> containing the submarkets, suppliers, the market shares and a variable for the local market potential (e.g. purchasing power, number of customers, population)
</p>
</td></tr>
<tr><td><code id="mci.shares.elast_+3A_submarkets">submarkets</code></td>
<td>

<p>the column in the interaction matrix <code>mcidataset</code> containing the submarkets
</p>
</td></tr>
<tr><td><code id="mci.shares.elast_+3A_suppliers">suppliers</code></td>
<td>

<p>the column in the interaction matrix <code>mcidataset</code> containing the suppliers
</p>
</td></tr>
<tr><td><code id="mci.shares.elast_+3A_shares">shares</code></td>
<td>

<p>the column in the interaction matrix <code>mcidataset</code> containing the (local) market shares
</p>
</td></tr>
<tr><td><code id="mci.shares.elast_+3A_mcivar">mcivar</code></td>
<td>

<p>the column in the interaction matrix <code>mcidataset</code> containing the attraction/utility variable
</p>
</td></tr>
<tr><td><code id="mci.shares.elast_+3A_mciparam">mciparam</code></td>
<td>

<p>single value of the (empirically estimated) weighting parameter corresponding to the attraction/utility variable
</p>
</td></tr>
<tr><td><code id="mci.shares.elast_+3A_check_df">check_df</code></td>
<td>

<p>logical argument that indicates if the input (dataset, column names) is checked (default: <code>check_df = TRUE</code> (should not be changed, only for internal use))
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Market-share elasticity is defined as the ratio of the relative change in the market share corresponding to a relative change in an explanatory (attraction/utility) variable, such as price or, in the context of retailing, driving time, sales area or price level. The elasticities calculated here are point elasticities (not arc elasticities): <code class="reqn">e_{s_{i}} = (d p_{i} / d X_{ki}) * (X_{ki} / {p_i})</code>, which are calculated for the MCI model via: <code class="reqn">e_{s_{i}}=\beta _{k}*(1-p_i)</code>, where <code class="reqn">\beta _k</code> is the corresponding weighting parameter. If the (absolute) elasticity value is greater than one, the suppliers' market share is called elastic, if it is smaller than one, the share is unelastic. E.g. if the share elasticity of a products' price is -2, a relative price reduction of 5% results in a share increase of 10% (Cooper/Nakanishi 2010). Note that the elasticity depends on the empirical shares: The greater the actual share, the smaller is the elasticity.  
</p>


<h3>Value</h3>

<p>The function <code>mci.shares.elast()</code> returns the input interaction matrix (<code>data.frame</code>) with a new column containing the calculated share elasticities for every combination of <code class="reqn">i</code> and <code class="reqn">j</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Wieland
</p>


<h3>References</h3>

<p>Cooper, L. G./Nakanishi, M. (2010): &ldquo;Market-Share Analysis: Evaluating competitive marketing effectiveness&rdquo;. Boston, Dordrecht, London : Kluwer (first published 1988). E-book version from 2010: <a href="http://www.anderson.ucla.edu/faculty/lee.cooper/MCI_Book/BOOKI2010.pdf">http://www.anderson.ucla.edu/faculty/lee.cooper/MCI_Book/BOOKI2010.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mci.fit">mci.fit</a></code>, <code><a href="#topic+mci.shares">mci.shares</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># MCI analysis for the grocery store market areas based on the POS survey in shopping1 #

data(shopping1)
# Loading the survey dataset
data(shopping2)
# Loading the distance/travel time dataset
data(shopping3)
# Loading the dataset containing information about the city districts
data(shopping4)
# Loading the grocery store data

shopping1_KAeast &lt;- shopping1[shopping1$resid_code %in% 
shopping3$resid_code[shopping3$KA_east == 1],]
# Extracting only inhabitants of the eastern districts of Karlsruhe

ijmatrix_gro_adj &lt;- ijmatrix.create(shopping1_KAeast, "resid_code",
"gro_purchase_code", "gro_purchase_expen", remSing = TRUE, remSing.val = 1,
remSingSupp.val = 2, correctVar = TRUE, correctVar.val = 0.1)
# Removing singular instances/outliers (remSing = TRUE) incorporating
# only suppliers which are at least obtained three times (remSingSupp.val = 2)
# Correcting the values (correctVar = TRUE)
# by adding 0.1 to the absolute values (correctVar.val = 0.1)

ijmatrix_gro_adj &lt;- ijmatrix_gro_adj[(ijmatrix_gro_adj$gro_purchase_code !=
"REFORMHAUSBOESER") &amp; (ijmatrix_gro_adj$gro_purchase_code != "WMARKT_DURLACH")
&amp; (ijmatrix_gro_adj$gro_purchase_code != "X_INCOMPLETE_STORE"),]
# Remove non-regarded observations

ijmatrix_gro_adj_dist &lt;- merge (ijmatrix_gro_adj, shopping2, by.x="interaction",
by.y="route")
# Include the distances and travel times (shopping2)
ijmatrix_gro_adj_dist_stores &lt;- merge (ijmatrix_gro_adj_dist, shopping4,
by.x = "gro_purchase_code", by.y = "location_code")
# Adding the store information (shopping4)

mci.transvar(ijmatrix_gro_adj_dist_stores, "resid_code", "gro_purchase_code", 
"p_ij_obs")
# Log-centering transformation of one variable (p_ij_obs)

ijmatrix_gro_transf &lt;- mci.transmat(ijmatrix_gro_adj_dist_stores, "resid_code",
"gro_purchase_code", "p_ij_obs", "d_time", "salesarea_qm")
# Log-centering transformation of the interaction matrix

mcimodel_gro_trips &lt;- mci.fit(ijmatrix_gro_adj_dist_stores, "resid_code",
"gro_purchase_code", "p_ij_obs", "d_time", "salesarea_qm")
# MCI model for the grocery store market areas
# shares: "p_ij_obs", explanatory variables: "d_time", "salesarea_qm"

summary(mcimodel_gro_trips)
# Use like lm

# Calculating market share elasticity:
ijmatrix_gro_adj_dist_stores_elas1 &lt;- mci.shares.elast (ijmatrix_gro_adj_dist_stores, 
"resid_code", "gro_purchase_code", "p_ij_obs", "d_time", -1.2443)
# Share elasticities of driving time

ijmatrix_gro_adj_dist_stores_elas2 &lt;- mci.shares.elast (ijmatrix_gro_adj_dist_stores, 
"resid_code", "gro_purchase_code", "p_ij_obs", "salesarea_qm", 0.9413)
# Share elasticities of sales area of the stores
</code></pre>

<hr>
<h2 id='mci.transmat'>
Log-centering transformation of an MCI interaction matrix
</h2><span id='topic+mci.transmat'></span>

<h3>Description</h3>

<p>This function applies the <em>log-centering transformation</em> to the variables in a given MCI interaction matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mci.transmat(mcidataset, submarkets, suppliers, mcivariable1, ..., show_proc = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mci.transmat_+3A_mcidataset">mcidataset</code></td>
<td>

<p>an interaction matrix which is a <code>data.frame</code> containing the submarkets, suppliers and the regarded variables (e.g. the observed market shares, <code class="reqn">p_{ij}</code>, and the explanatory variables)
</p>
</td></tr>
<tr><td><code id="mci.transmat_+3A_submarkets">submarkets</code></td>
<td>

<p>the column in the interaction matrix <code>mcidataset</code> containing the submarkets
</p>
</td></tr>
<tr><td><code id="mci.transmat_+3A_suppliers">suppliers</code></td>
<td>

<p>the column in the interaction matrix <code>mcidataset</code> containing the suppliers
</p>
</td></tr>
<tr><td><code id="mci.transmat_+3A_mcivariable1">mcivariable1</code></td>
<td>

<p>the column of the first variable to be transformed, numeric and positive (or dummy [1,0])
</p>
</td></tr>
<tr><td><code id="mci.transmat_+3A_...">...</code></td>
<td>

<p>the columns of other variables to be transformed, numeric and positive (or dummy [1,0])
</p>
</td></tr>
<tr><td><code id="mci.transmat_+3A_show_proc">show_proc</code></td>
<td>

<p>logical argument that indicates if the function prints messages about the state of process during the work (e.g. &ldquo;Processing variable xyz ...&rdquo; or &ldquo;Variable xyz is regarded as dummy variable&rdquo;). Default: <code>show_proc = FALSE</code> (messages off)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function transformes the input dataset (MCI interaction matrix) to regression-ready data with the <em>log-centering transformation</em> by Nakanishi/Cooper (1974). The resulting <code>data.frame</code> can be fitted with the <code>lm()</code> function (to combine these two steps in one, use <code>mci.fit()</code>). The <em>log-centering transformation</em> can be regarded as the key concept of the MCI model because it enables the model to be estimated by OLS (ordinary least squares) regression. The function identifies dummy variables which are not transformed (because they do not have to be). 
</p>


<h3>Value</h3>

<p>Returns a new <code>data.frame</code> with regression-ready data where the input variables are transformed by the the <em>log-centering transformation</em>. The names of the input variables are passed to the new <code>data.frame</code> marked with a &quot;_t&quot; to indicate that they were transformed (e.g. &quot;shares_t&quot; is the transformation of &quot;shares&quot;).
</p>


<h3>Author(s)</h3>

<p>Thomas Wieland
</p>


<h3>References</h3>

<p>Huff, D. L./Batsell, R. R. (1975): &ldquo;Conceptual and Operational Problems with Market Share Models of Consumer Spatial Behavior&rdquo;. In: <em>Advances in Consumer Research</em>, <b>2</b>, p. 165-172.
</p>
<p>Huff, D. L./McCallum, D. (2008): &ldquo;Calibrating the Huff Model Using ArcGIS Business Analyst&rdquo;. <em>ESRI White Paper</em>, September 2008. <a href="https://www.esri.com/library/whitepapers/pdfs/calibrating-huff-model.pdf">https://www.esri.com/library/whitepapers/pdfs/calibrating-huff-model.pdf</a>
</p>
<p>Nakanishi, M./Cooper, L. G. (1974): &ldquo;Parameter Estimation for a Multiplicative Competitive Interaction Model - Least Squares Approach&rdquo;. In: <em>Journal of Marketing Research</em>, <b>11</b>, 3, p. 303-311.
</p>
<p>Wieland, T. (2013): &ldquo;Einkaufsstaettenwahl, Einzelhandelscluster und raeumliche Versorgungsdisparitaeten - Modellierung von Marktgebieten im Einzelhandel unter Beruecksichtigung von Agglomerationseffekten&rdquo;. In: Schrenk, M./Popovich, V./Zeile, P./Elisei, P. (eds.): REAL CORP 2013. Planning Times. Proceedings of 18th International Conference on Urban Planning, Regional Development and Information Society. Schwechat. p. 275-284. <a href="http://www.corp.at/archive/CORP2013_98.pdf">http://www.corp.at/archive/CORP2013_98.pdf</a>
</p>
<p>Wieland, T. (2015): &ldquo;Raeumliches Einkaufsverhalten und Standortpolitik im Einzelhandel unter Beruecksichtigung von Agglomerationseffekten. Theoretische Erklaerungsansaetze, modellanalytische Zugaenge und eine empirisch-oekonometrische Marktgebietsanalyse anhand eines Fallbeispiels aus dem laendlichen Raum Ostwestfalens/Suedniedersachsens&rdquo;. <em>Geographische Handelsforschung</em>, <b>23</b>. 289 pages. Mannheim : MetaGIS.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mci.fit">mci.fit</a></code>, <code><a href="#topic+mci.transvar">mci.transvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># MCI analysis for the grocery store market areas in grocery2 #
data(grocery2)
# Loads the data
mci.transmat (grocery2, "plz_submarket", "store_code", "p_ij_obs", "dist_km", "salesarea_qm")
# Applies the log-centering transformation to the dataset using the function mci.transmat



# MCI analysis for the grocery store market areas based on the POS survey in shopping1 #

data(shopping1)
# Loading the survey dataset
data(shopping2)
# Loading the distance/travel time dataset
data(shopping3)
# Loading the dataset containing information about the city districts
data(shopping4)
# Loading the grocery store data

shopping1_KAeast &lt;- shopping1[shopping1$resid_code %in% 
shopping3$resid_code[shopping3$KA_east == 1],]
# Extracting only inhabitants of the eastern districts of Karlsruhe

ijmatrix_gro_adj &lt;- ijmatrix.create(shopping1_KAeast, "resid_code",
"gro_purchase_code", "gro_purchase_expen", remSing = TRUE, remSing.val = 1,
remSingSupp.val = 2, correctVar = TRUE, correctVar.val = 0.1)
# Removing singular instances/outliers (remSing = TRUE) incorporating
# only suppliers which are at least obtained three times (remSingSupp.val = 2)
# Correcting the values (correctVar = TRUE)
# by adding 0.1 to the absolute values (correctVar.val = 0.1)

ijmatrix_gro_adj &lt;- ijmatrix_gro_adj[(ijmatrix_gro_adj$gro_purchase_code !=
"REFORMHAUSBOESER") &amp; (ijmatrix_gro_adj$gro_purchase_code != "WMARKT_DURLACH")
&amp; (ijmatrix_gro_adj$gro_purchase_code != "X_INCOMPLETE_STORE"),]
# Remove non-regarded observations

ijmatrix_gro_adj_dist &lt;- merge (ijmatrix_gro_adj, shopping2, by.x="interaction",
by.y="route")
# Include the distances and travel times (shopping2)
ijmatrix_gro_adj_dist_stores &lt;- merge (ijmatrix_gro_adj_dist, shopping4,
by.x = "gro_purchase_code", by.y = "location_code")
# Adding the store information (shopping4)

mci.transvar(ijmatrix_gro_adj_dist_stores, "resid_code", "gro_purchase_code", 
"p_ij_obs")
# Log-centering transformation of one variable (p_ij_obs)

ijmatrix_gro_transf &lt;- mci.transmat(ijmatrix_gro_adj_dist_stores, "resid_code",
"gro_purchase_code", "p_ij_obs", "d_time", "salesarea_qm")
# Log-centering transformation of the interaction matrix

mcimodel_gro_trips &lt;- mci.fit(ijmatrix_gro_adj_dist_stores, "resid_code",
"gro_purchase_code", "p_ij_obs", "d_time", "salesarea_qm")
# MCI model for the grocery store market areas
# shares: "p_ij_obs", explanatory variables: "d_time", "salesarea_qm"

summary(mcimodel_gro_trips)
# Use like lm
</code></pre>

<hr>
<h2 id='mci.transvar'>
Log-centering transformation of one variable in an MCI interaction matrix
</h2><span id='topic+mci.transvar'></span>

<h3>Description</h3>

<p>This function applies the <em>log-centering transformation</em> to a variable in a given MCI interaction matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mci.transvar(mcidataset, submarkets, suppliers, mcivariable, 
output_ij = FALSE, output_var = "numeric", show_proc = FALSE, check_df = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mci.transvar_+3A_mcidataset">mcidataset</code></td>
<td>

<p>an interaction matrix which is a <code>data.frame</code> containing the submarkets, suppliers and the regarded variables (e.g. the observed market shares, <code class="reqn">p_{ij}</code>, and the explanatory variables)
</p>
</td></tr>
<tr><td><code id="mci.transvar_+3A_submarkets">submarkets</code></td>
<td>

<p>the column in the interaction matrix <code>mcidataset</code> containing the submarkets
</p>
</td></tr>
<tr><td><code id="mci.transvar_+3A_suppliers">suppliers</code></td>
<td>

<p>the column in the interaction matrix <code>mcidataset</code> containing the suppliers
</p>
</td></tr>
<tr><td><code id="mci.transvar_+3A_mcivariable">mcivariable</code></td>
<td>

<p>the column of the variable to be transformed, numeric and positive (or dummy [1,0])
</p>
</td></tr>
<tr><td><code id="mci.transvar_+3A_output_ij">output_ij</code></td>
<td>

<p>logical argument that indicates if the function output has to be a <code>data.frame</code> with three columns (submarkets, suppliers, transformed variable) or a vector only with the transformed values (default is <code>output_ij = FALSE</code>)
</p>
</td></tr>
<tr><td><code id="mci.transvar_+3A_output_var">output_var</code></td>
<td>

<p>defines the mode of the function output if <code>output_ij = FALSE</code> (default is <code>output_var = "numeric"</code>, otherwise <code>"list"</code>)
</p>
</td></tr>
<tr><td><code id="mci.transvar_+3A_show_proc">show_proc</code></td>
<td>

<p>logical argument that indicates if the function prints messages about the state of process during the work (e.g. &ldquo;Processing variable xyz ...&rdquo; or &ldquo;Variable xyz is regarded as dummy variable&rdquo;). Default: <code>show_proc = FALSE</code> (messages off)
</p>
</td></tr>
<tr><td><code id="mci.transvar_+3A_check_df">check_df</code></td>
<td>

<p>logical argument that indicates if the input (dataset, column names) is checked (default: <code>check_df = TRUE</code> (should not be changed, only for internal use))
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function transforms one variable from the input dataset (MCI interaction matrix) to regression-ready data with the <em>log-centering transformation</em> by Nakanishi/Cooper (1974) (to transform a complete interaction matrix, use <code>mci.transmat()</code>, for transformation and fitting use <code>mci.fit()</code>). The <em>log-centering transformation</em> can be regarded as the key concept of the MCI model because it enables the model to be estimated by OLS (ordinary least squares) regression. The function identifies dummy variables which are not transformed (because they do not have to be).
</p>


<h3>Value</h3>

<p>The format of the output can be controlled by the last two arguments of the function (see above). Either a new <code>data.frame</code> with the transformed input variable and the submarkets/suppliers or a vector with the transformed values only. The name of the input variable is passed to the new <code>data.frame</code> marked with a &quot;_t&quot; to indicate that it was transformed (e.g. &quot;shares_t&quot; is the transformation of &quot;shares&quot;).
</p>


<h3>Author(s)</h3>

<p>Thomas Wieland
</p>


<h3>References</h3>

<p>Huff, D. L./Batsell, R. R. (1975): &ldquo;Conceptual and Operational Problems with Market Share Models of Consumer Spatial Behavior&rdquo;. In: <em>Advances in Consumer Research</em>, <b>2</b>, p. 165-172.
</p>
<p>Huff, D. L./McCallum, D. (2008): &ldquo;Calibrating the Huff Model Using ArcGIS Business Analyst&rdquo;. <em>ESRI White Paper</em>, September 2008. <a href="https://www.esri.com/library/whitepapers/pdfs/calibrating-huff-model.pdf">https://www.esri.com/library/whitepapers/pdfs/calibrating-huff-model.pdf</a>
</p>
<p>Nakanishi, M./Cooper, L. G. (1974): &ldquo;Parameter Estimation for a Multiplicative Competitive Interaction Model - Least Squares Approach&rdquo;. In: <em>Journal of Marketing Research</em>, <b>11</b>, 3, p. 303-311.
</p>
<p>Wieland, T. (2013): &ldquo;Einkaufsstaettenwahl, Einzelhandelscluster und raeumliche Versorgungsdisparitaeten - Modellierung von Marktgebieten im Einzelhandel unter Beruecksichtigung von Agglomerationseffekten&rdquo;. In: Schrenk, M./Popovich, V./Zeile, P./Elisei, P. (eds.): REAL CORP 2013. Planning Times. Proceedings of 18th International Conference on Urban Planning, Regional Development and Information Society. Schwechat. p. 275-284. <a href="http://www.corp.at/archive/CORP2013_98.pdf">http://www.corp.at/archive/CORP2013_98.pdf</a>
</p>
<p>Wieland, T. (2015): &ldquo;Raeumliches Einkaufsverhalten und Standortpolitik im Einzelhandel unter Beruecksichtigung von Agglomerationseffekten. Theoretische Erklaerungsansaetze, modellanalytische Zugaenge und eine empirisch-oekonometrische Marktgebietsanalyse anhand eines Fallbeispiels aus dem laendlichen Raum Ostwestfalens/Suedniedersachsens&rdquo;. <em>Geographische Handelsforschung</em>, <b>23</b>. 289 pages. Mannheim : MetaGIS.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mci.fit">mci.fit</a></code>, <code><a href="#topic+mci.transmat">mci.transmat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># MCI analysis for the grocery store market areas based on the POS survey in shopping1 #

data(shopping1)
# Loading the survey dataset
data(shopping2)
# Loading the distance/travel time dataset
data(shopping3)
# Loading the dataset containing information about the city districts
data(shopping4)
# Loading the grocery store data

shopping1_KAeast &lt;- shopping1[shopping1$resid_code %in% 
shopping3$resid_code[shopping3$KA_east == 1],]
# Extracting only inhabitants of the eastern districts of Karlsruhe

ijmatrix_gro_adj &lt;- ijmatrix.create(shopping1_KAeast, "resid_code",
"gro_purchase_code", "gro_purchase_expen", remSing = TRUE, remSing.val = 1,
remSingSupp.val = 2, correctVar = TRUE, correctVar.val = 0.1)
# Removing singular instances/outliers (remSing = TRUE) incorporating
# only suppliers which are at least obtained three times (remSingSupp.val = 2)
# Correcting the values (correctVar = TRUE)
# by adding 0.1 to the absolute values (correctVar.val = 0.1)

ijmatrix_gro_adj &lt;- ijmatrix_gro_adj[(ijmatrix_gro_adj$gro_purchase_code !=
"REFORMHAUSBOESER") &amp; (ijmatrix_gro_adj$gro_purchase_code != "WMARKT_DURLACH")
&amp; (ijmatrix_gro_adj$gro_purchase_code != "X_INCOMPLETE_STORE"),]
# Remove non-regarded observations

ijmatrix_gro_adj_dist &lt;- merge (ijmatrix_gro_adj, shopping2, by.x="interaction",
by.y="route")
# Include the distances and travel times (shopping2)
ijmatrix_gro_adj_dist_stores &lt;- merge (ijmatrix_gro_adj_dist, shopping4,
by.x = "gro_purchase_code", by.y = "location_code")
# Adding the store information (shopping4)

mci.transvar(ijmatrix_gro_adj_dist_stores, "resid_code", "gro_purchase_code", 
"p_ij_obs")
# Log-centering transformation of one variable (p_ij_obs)

ijmatrix_gro_transf &lt;- mci.transmat(ijmatrix_gro_adj_dist_stores, "resid_code",
"gro_purchase_code", "p_ij_obs", "d_time", "salesarea_qm")
# Log-centering transformation of the interaction matrix

mcimodel_gro_trips &lt;- mci.fit(ijmatrix_gro_adj_dist_stores, "resid_code",
"gro_purchase_code", "p_ij_obs", "d_time", "salesarea_qm")
# MCI model for the grocery store market areas
# shares: "p_ij_obs", explanatory variables: "d_time", "salesarea_qm"

summary(mcimodel_gro_trips)
# Use like lm
</code></pre>

<hr>
<h2 id='model.fit'>
Goodness of fit statistics for the Huff model
</h2><span id='topic+model.fit'></span>

<h3>Description</h3>

<p>This function calculates several goodness of fit values to evaluate how good the observed values fit the empirical observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.fit(y_obs, y_exp, plotVal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.fit_+3A_y_obs">y_obs</code></td>
<td>

<p>Observed values of the dependent variable <code class="reqn">y</code>
</p>
</td></tr>
<tr><td><code id="model.fit_+3A_y_exp">y_exp</code></td>
<td>

<p>Expected values of the dependent variable <code class="reqn">y</code> (model results)
</p>
</td></tr>
<tr><td><code id="model.fit_+3A_plotval">plotVal</code></td>
<td>

<p>Logical argument that indicates if the function plots a graph comparing observed and expected values
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes several goodness of fit statistics to evaluate the results of non-linear fitting procedures for the Huff model (see the functions <code>huff.attrac</code> and <code>huff.fit</code>). Besides the sum of squared residuals, the function also calculates a <em>Pseudo-R-squared</em> measure and the <em>MAPE (mean average percentage error)</em>, both used by De Beule et al. (2014), and the <em>global error</em> used by Klein (1988).
</p>


<h3>Value</h3>

<p>list:
</p>
<table>
<tr><td><code>resids_sq_sum</code></td>
<td>
<p>Sum of squared residuals</p>
</td></tr>
<tr><td><code>pseudorsq</code></td>
<td>
<p>Pseudo-R-squared</p>
</td></tr>
<tr><td><code>globerr</code></td>
<td>
<p>Global error</p>
</td></tr>
<tr><td><code>mape</code></td>
<td>
<p>Mean average percentage error</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Wieland
</p>


<h3>References</h3>

<p>De Beule, M./Van den Poel, D./Van de Weghe, N. (2014): &ldquo;An extended Huff-model for robustly benchmarking and predicting retail network performance&rdquo;. In: <em>Applied Geography</em>, <b>46</b>, 1, p. 80-89.
</p>
<p>Klein, R. (1988): &ldquo;Der Lebensmittel-Einzelhandel im Raum Verden. Raeumliches Einkaufsverhalten unter sich wandelnden Bedingungen&rdquo;. <em>Flensburger Arbeitspapiere zur Landeskunde und Raumordnung</em>, <b>6</b>. Flensburg.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+huff.fit">huff.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Controlling the fit of a Huff Model market area estimation #

data(Freiburg1)
data(Freiburg2)
data(Freiburg3)
# Loads the data

huff_mat &lt;- huff.shares (Freiburg1, "district", "store", "salesarea", "distance")
# Market area estimation using the Huff Model with standard parameters
# (gamma = 1, lambda = -2)

huff_mat_pp &lt;- merge (huff_mat, Freiburg2)
# Adding the purchasing power data for the city districts

huff_total &lt;- shares.total (huff_mat_pp, "district", "store", "p_ij", "ppower")
# Total expected sales and shares

huff_total_control &lt;- merge (huff_total, Freiburg3, by.x = "suppliers_single",
by.y = "store")

model.fit(huff_total_control$annualsales, huff_total_control$sum_E_j, plotVal = TRUE)
# Observed vs. expected

# Results can be adressed directly:
huff_fit &lt;- model.fit(huff_total_control$annualsales, huff_total_control$sum_E_j, plotVal = TRUE)
huff_fit$mape
</code></pre>

<hr>
<h2 id='shares.segm'>
Segmentation of market areas by a criterion
</h2><span id='topic+shares.segm'></span>

<h3>Description</h3>

<p>This function segments the contents of an interaction matrix based on a criterion, such as distance or market penetration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shares.segm(mcidataset, submarkets, suppliers, segmentation, observations, 
..., check_df = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shares.segm_+3A_mcidataset">mcidataset</code></td>
<td>

<p>an interaction matrix which is a <code>data.frame</code> containing the submarkets, suppliers, the total values (e.g. shopping trips, expenditures) and a variable containing the criterion for the segmentation (e.g. distance, travel time, market penetration)
</p>
</td></tr>
<tr><td><code id="shares.segm_+3A_submarkets">submarkets</code></td>
<td>

<p>the column in the interaction matrix <code>mcidataset</code> containing the submarkets
</p>
</td></tr>
<tr><td><code id="shares.segm_+3A_suppliers">suppliers</code></td>
<td>

<p>the column in the interaction matrix <code>mcidataset</code> containing the suppliers
</p>
</td></tr>
<tr><td><code id="shares.segm_+3A_segmentation">segmentation</code></td>
<td>

<p>The column in the interaction matrix <code>mcidataset</code> containing the variable which is to be used for segmentation
</p>
</td></tr>
<tr><td><code id="shares.segm_+3A_observations">observations</code></td>
<td>

<p>The column in the interaction matrix <code>mcidataset</code> containing the total values which have to segmented
</p>
</td></tr>
<tr><td><code id="shares.segm_+3A_...">...</code></td>
<td>

<p>The stated limits of class segments (e.g. 0, 10, 20, 30)
</p>
</td></tr>
<tr><td><code id="shares.segm_+3A_check_df">check_df</code></td>
<td>

<p>logical argument that indicates if the input (dataset, column names) is checked (default: <code>check_df = TRUE</code> (should not be changed, only for internal use))
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For practical reasons, a market/market area can be zoned into segments based on a criterion (such as distance or travel time zones, zones of market penetration). Based on an existing interaction matrix, this function returns zones of a market/market area.
</p>


<h3>Value</h3>

<p>Returns a new <code>data.frame</code> with the classification segments, the sum of the total observed values with respect to each class and the corresponding percentage.
</p>


<h3>Author(s)</h3>

<p>Thomas Wieland
</p>


<h3>References</h3>

<p>Berman, B. R./Evans, J. R. (2013): &ldquo;Retail Management: A Strategic Approach&rdquo;. Pearson, 12 edition, 2013.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shares.total">shares.total</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Market area segmentation based on the POS survey in shopping1 #

data(shopping1)
# The survey dataset
data(shopping2)
# Dataset with distances and travel times

shopping1_adj &lt;- shopping1[(shopping1$weekday != 3) &amp; (shopping1$holiday != 1) 
&amp; (shopping1$survey != "pretest"),]
# Removing every case from tuesday, holidays and the ones belonging to the pretest

ijmatrix_POS &lt;- ijmatrix.create(shopping1_adj, "resid_code", "POS", "POS_expen")
# Creates an interaction matrix based on the observed frequencies (automatically)
# and the POS expenditures (Variable "POS_expen" separately stated)

ijmatrix_POS_data &lt;- merge(ijmatrix_POS, shopping2, by.x="interaction", by.y="route", 
all.x = TRUE)
# Adding the distances and travel times

ijmatrix_POS_data_segm_visit &lt;- shares.segm(ijmatrix_POS_data, "resid_code", "POS",
"d_time", "freq_ij_abs", 0,10,20,30)
# Segmentation by travel time using the number of customers/visitors
# Parameters: interaction matrix (data frame), columns with origins and destinations,
# variable to divide in classes, absolute frequencies/expenditures, class segments

ijmatrix_POS_data_segm_exp &lt;- shares.segm(ijmatrix_POS_data, "resid_code", "POS",
"d_time", "freq_ij_abs_POS_expen", 0,10,20,30)
# Segmentation by travel time using the POS expenditures
</code></pre>

<hr>
<h2 id='shares.total'>
Total market shares/market areas
</h2><span id='topic+shares.total'></span>

<h3>Description</h3>

<p>This function calculates the total sales and market shares (or total market area) of the suppliers based on a given interaction matrix which already contains (local) market shares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shares.total(mcidataset, submarkets, suppliers, shares, localmarket, 
plotChart = FALSE, plotChart.title = "Total sales", plotChart.unit = "sales", 
check_df = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shares.total_+3A_mcidataset">mcidataset</code></td>
<td>

<p>an interaction matrix which is a <code>data.frame</code> containing the submarkets, suppliers, the market shares and a variable for the local market potential (e.g. purchasing power, number of customers, population)
</p>
</td></tr>
<tr><td><code id="shares.total_+3A_submarkets">submarkets</code></td>
<td>

<p>the column in the interaction matrix <code>mcidataset</code> containing the submarkets
</p>
</td></tr>
<tr><td><code id="shares.total_+3A_suppliers">suppliers</code></td>
<td>

<p>the column in the interaction matrix <code>mcidataset</code> containing the suppliers
</p>
</td></tr>
<tr><td><code id="shares.total_+3A_shares">shares</code></td>
<td>

<p>the column in the interaction matrix <code>mcidataset</code> containing the the (local) market shares
</p>
</td></tr>
<tr><td><code id="shares.total_+3A_localmarket">localmarket</code></td>
<td>

<p>the column in the interaction matrix <code>mcidataset</code> containing the local market potential
</p>
</td></tr>
<tr><td><code id="shares.total_+3A_plotchart">plotChart</code></td>
<td>

<p>logical argument that indicates if the total values shall be visualized in a bar plot (default: <code>plotChart = FALSE</code>)
</p>
</td></tr>
<tr><td><code id="shares.total_+3A_plotchart.title">plotChart.title</code></td>
<td>

<p>If <code>plotChart = TRUE</code>: Title of the plot
</p>
</td></tr>
<tr><td><code id="shares.total_+3A_plotchart.unit">plotChart.unit</code></td>
<td>

<p>If <code>plotChart = TRUE</code>: Unit of the plotted total values (e.g. a currency), used as plot subtitle
</p>
</td></tr>
<tr><td><code id="shares.total_+3A_check_df">check_df</code></td>
<td>

<p>logical argument that indicates if the input (dataset, column names) is checked (default: <code>check_df = TRUE</code> (should not be changed, only for internal use))
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If (local) market shares are observed and estimated, respectively, it is possible to link them to a (local) market potential to estimate the total sales and shares of the given suppliers. In this function, the input dataset (interaction matrix with local market shares) is used for the calculation of total sales (or total number of customers) and total market shares of all <code class="reqn">j</code> regarded suppliers. Optionally, the function also returns a simple bar plot of the total values. 
</p>


<h3>Value</h3>

<p>Returns a new <code>data.frame</code> with the total sales (<code>sum_E_j</code>) and the over-all market shares of the <code class="reqn">j</code> suppliers (<code>share_j</code>).
</p>


<h3>Author(s)</h3>

<p>Thomas Wieland
</p>


<h3>References</h3>

<p>Huff, D. L./McCallum, D. (2008): &ldquo;Calibrating the Huff Model Using ArcGIS Business Analyst&rdquo;. <em>ESRI White Paper</em>, September 2008. <a href="https://www.esri.com/library/whitepapers/pdfs/calibrating-huff-model.pdf">https://www.esri.com/library/whitepapers/pdfs/calibrating-huff-model.pdf</a>
</p>
<p>Nakanishi, M./Cooper, L. G. (1974): &ldquo;Parameter Estimation for a Multiplicative Competitive Interaction Model - Least Squares Approach&rdquo;. In: <em>Journal of Marketing Research</em>, <b>11</b>, 3, p. 303-311.
</p>
<p>Nakanishi, M./Cooper, L. G. (1982): &ldquo;Simplified Estimation Procedures for MCI Models&rdquo;. In: <em>Marketing Science</em>, <b>1</b>, 3, p. 314-322. 
</p>
<p>Wieland, T. (2015): &ldquo;Raeumliches Einkaufsverhalten und Standortpolitik im Einzelhandel unter Beruecksichtigung von Agglomerationseffekten. Theoretische Erklaerungsansaetze, modellanalytische Zugaenge und eine empirisch-oekonometrische Marktgebietsanalyse anhand eines Fallbeispiels aus dem laendlichen Raum Ostwestfalens/Suedniedersachsens&rdquo;. <em>Geographische Handelsforschung</em>, <b>23</b>. 289 pages. Mannheim : MetaGIS.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mci.fit">mci.fit</a></code>, <code><a href="#topic+mci.transmat">mci.transmat</a></code>, <code><a href="#topic+mci.transvar">mci.transvar</a></code>, <code><a href="#topic+mci.shares">mci.shares</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Freiburg1)
data(Freiburg2)
# Loads the data

mynewmatrix &lt;- mci.shares(Freiburg1, "district", "store", "salesarea", 1, "distance", -2)
# Calculating shares based on two attractivity/utility variables

mynewmatrix_alldata &lt;- merge(mynewmatrix, Freiburg2)
# Merge interaction matrix with district data (purchasing power)

shares.total (mynewmatrix_alldata, "district", "store", "p_ij", "ppower")
# Calculation of total sales 
</code></pre>

<hr>
<h2 id='shopping1'>Point-of-sale survey in Karlsruhe</h2><span id='topic+shopping1'></span>

<h3>Description</h3>

<p>The dataset contains a point-of-sale (POS) survey conducted at two retail supply locations (town centre and planned shopping centre) in the east of Karlsruhe (Germany) from May 2016 (raw data). Amongst other things, the participants were asked about their last shopping trip with respect to groceries, clothing als consumer electronics (store choice and expenditures) and their place of residence (ZIP code and city district, respectively). The survey dataset contains 434 cases/interviewed individuals. The survey is <em>not</em> representative and should be regarded as an example. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("shopping1")</code></pre>


<h3>Format</h3>

<p>A data frame with 434 observations on the following 29 variables.
</p>

<dl>
<dt><code>POS</code></dt><dd><p>a factor indicating the survey location: <code>POS1</code> (town centre) or <code>POS2</code> (shopping centre)</p>
</dd>
<dt><code>time</code></dt><dd><p>a numeric vector containing the code for the time period the interview was conducted</p>
</dd>
<dt><code>date</code></dt><dd><p>a POSIXct containing the date the interview was conducted</p>
</dd>
<dt><code>POS_traffic</code></dt><dd><p>a numeric vector containing the code for the traffic mode the respondet used to come to the supply location</p>
</dd>
<dt><code>POS_stay</code></dt><dd><p>a numeric vector containing the respondents' duration of stay at the supply location</p>
</dd>
<dt><code>POS_expen</code></dt><dd><p>a numeric vector containing the respondents' expenditures at the supply location</p>
</dd>
<dt><code>POS1_freq</code></dt><dd><p>a numeric vector containing the frequency of visiting the supply location POS1</p>
</dd>
<dt><code>POS2_freq</code></dt><dd><p>a numeric vector containing the frequency of visiting the supply location POS2</p>
</dd>
<dt><code>gro_purchase_code</code></dt><dd><p>a factor containing the destination of the last grocery shopping trip</p>
</dd>
<dt><code>gro_purchase_brand</code></dt><dd><p>a factor containing the brand (store chain) of the destination of the last grocery shopping trip</p>
</dd>
<dt><code>gro_purchase_channel</code></dt><dd><p>a factor containing the shopping channel of the destination of the last grocery shopping trip: <code>ambulant</code>, <code>online</code> and <code>store</code></p>
</dd>
<dt><code>gro_purchase_expen</code></dt><dd><p>a numeric vector containing the expenditures corresponding to the last grocery shopping trip</p>
</dd>
<dt><code>cloth_purchase_code</code></dt><dd><p>a factor containing the destination of the last clothing shopping trip</p>
</dd>
<dt><code>cloth_purchase_brand</code></dt><dd><p>a factor containing the brand (store chain) of the destination of the last clothing shopping trip</p>
</dd>
<dt><code>cloth_purchase_channel</code></dt><dd><p>a factor containing the shopping channel of the destination of the last clothing shopping trip: <code>mail order</code>, <code>online</code> or <code>store</code></p>
</dd>
<dt><code>cloth_purchase_expen</code></dt><dd><p>a numeric vector containing the expenditures corresponding to the last clothing shopping trip</p>
</dd>
<dt><code>ce_purchase_code</code></dt><dd><p>a factor containing the destination of the last shopping trip with respect to consumer electronics (CE)</p>
</dd>
<dt><code>ce_purchase_brand</code></dt><dd><p>a factor containing the brand (store chain) of the destination of the last CE shopping trip</p>
</dd>
<dt><code>ce_purchase_channel</code></dt><dd><p>a factor containing the shopping channel of the destination of the last CE shopping trip: <code>online</code> or <code>store</code></p>
</dd>
<dt><code>ce_purchase_expen</code></dt><dd><p>a numeric vector containing the expenditures corresponding to the last CE shopping trip</p>
</dd>
<dt><code>resid_PLZ</code></dt><dd><p>a factor containing the customer origin (place of residence) as ZIP code</p>
</dd>
<dt><code>resid_name</code></dt><dd><p>a factor containing the customer origin (place of residence) as name of the corresponding city or city district</p>
</dd>
<dt><code>resid_name_official</code></dt><dd><p>a factor containing the customer origin (place of residence) as official names of the corresponding city or city district</p>
</dd>
<dt><code>resid_code</code></dt><dd><p>a factor containing the customer origin (place of residence) as internal code</p>
</dd>
<dt><code>age_cat</code></dt><dd><p>a numeric vector containing the age category of the respondent</p>
</dd>
<dt><code>sex</code></dt><dd><p>a numeric vector containing the sex of the respondent</p>
</dd>
<dt><code>weekday</code></dt><dd><p>a numeric vector containing the weekday where the interview took place</p>
</dd>
<dt><code>holiday</code></dt><dd><p>a numeric vector containing a dummy variable which indicates whether the interview was conducted on a holiday or not</p>
</dd>
<dt><code>survey</code></dt><dd><p>a factor reflecting the mode of survey: <code>main</code> is the main survey while <code>pretest</code> marks the cases from the pretest</p>
</dd>
</dl>



<h3>Source</h3>

<p>Primary empirical sources:
POS (point of sale) survey in the authors' course (&ldquo;Praktikum Empirische Sozialforschung: Stadtteilzentren als Einzelhandelsstandorte - Das Fallbeispiel Karlsruhe-Durlach&rdquo;, Karlsruhe Institute of Technology, Institute for Geography and Geoecology, May 2016), own calculations
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shopping2">shopping2</a></code>, <code><a href="#topic+shopping3">shopping3</a></code>, <code><a href="#topic+shopping4">shopping4</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Market area segmentation based on the POS survey in shopping1 #

data(shopping1)
# The survey dataset
data(shopping2)
# Dataset with distances and travel times

shopping1_adj &lt;- shopping1[(shopping1$weekday != 3) &amp; (shopping1$holiday != 1) 
&amp; (shopping1$survey != "pretest"),]
# Removing every case from tuesday, holidays and the ones belonging to the pretest

ijmatrix_POS &lt;- ijmatrix.create(shopping1_adj, "resid_code", "POS", "POS_expen")
# Creates an interaction matrix based on the observed frequencies (automatically)
# and the POS expenditures (Variable "POS_expen" separately stated)

ijmatrix_POS_data &lt;- merge(ijmatrix_POS, shopping2, by.x="interaction", by.y="route", 
all.x = TRUE)
# Adding the distances and travel times

ijmatrix_POS_data_segm_visit &lt;- shares.segm(ijmatrix_POS_data, "resid_code", "POS",
"d_time", "freq_ij_abs", 0,10,20,30)
# Segmentation by travel time using the number of customers/visitors
# Parameters: interaction matrix (data frame), columns with origins and destinations,
# variable to divide in classes, absolute frequencies/expenditures, class segments

ijmatrix_POS_data_segm_exp &lt;- shares.segm(ijmatrix_POS_data, "resid_code", "POS",
"d_time", "freq_ij_abs_POS_expen", 0,10,20,30)
# Segmentation by travel time using the POS expenditures
</code></pre>

<hr>
<h2 id='shopping2'>
Distance matrix for the point-of-sale survey in Karlsruhe
</h2><span id='topic+shopping2'></span>

<h3>Description</h3>

<p>The dataset contains a distance matrix (OD matrix: Origins-Destinations matrix) including the street distance and the travel time from the customer origins to the shopping destinations, both stored in the dataset <code>shopping1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("shopping2")</code></pre>


<h3>Format</h3>

<p>A data frame with 3723 observations on the following 5 variables.
</p>

<dl>
<dt><code>from</code></dt><dd><p>a factor containing the customer origin (place of residence) as internal code</p>
</dd>
<dt><code>to</code></dt><dd><p>a factor containing the shopping destination</p>
</dd>
<dt><code>d_km</code></dt><dd><p>a numeric vector containing the street distance from the origins to the destinations in km</p>
</dd>
<dt><code>d_time</code></dt><dd><p>a numeric vector containing the driving time from the origins to the destinations in km</p>
</dd>
<dt><code>route</code></dt><dd><p>a factor containing the interaction/route code between origins and destinations (from-to)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Primary empirical sources:
POS (point of sale) survey in the authors' course (&ldquo;Praktikum Empirische Sozialforschung: Stadtteilzentren als Einzelhandelsstandorte - Das Fallbeispiel Karlsruhe-Durlach&rdquo;, Karlsruhe Institute of Technology, Institute for Geography and Geoecology, May 2016), own calculations
</p>
<p>The street distance and travel time was calculated using the package <span class="pkg">ggmap</span>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shopping1">shopping1</a></code>, <code><a href="#topic+shopping3">shopping3</a></code>, <code><a href="#topic+shopping4">shopping4</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Market area segmentation based on the POS survey in shopping1 #

data(shopping1)
# The survey dataset
data(shopping2)
# Dataset with distances and travel times

shopping1_adj &lt;- shopping1[(shopping1$weekday != 3) &amp; (shopping1$holiday != 1) 
&amp; (shopping1$survey != "pretest"),]
# Removing every case from tuesday, holidays and the ones belonging to the pretest

ijmatrix_POS &lt;- ijmatrix.create(shopping1_adj, "resid_code", "POS", "POS_expen")
# Creates an interaction matrix based on the observed frequencies (automatically)
# and the POS expenditures (Variable "POS_expen" separately stated)

ijmatrix_POS_data &lt;- merge(ijmatrix_POS, shopping2, by.x="interaction", by.y="route", 
all.x = TRUE)
# Adding the distances and travel times

ijmatrix_POS_data_segm_visit &lt;- shares.segm(ijmatrix_POS_data, "resid_code", "POS",
"d_time", "freq_ij_abs", 0,10,20,30)
# Segmentation by travel time using the number of customers/visitors
# Parameters: interaction matrix (data frame), columns with origins and destinations,
# variable to divide in classes, absolute frequencies/expenditures, class segments

ijmatrix_POS_data_segm_exp &lt;- shares.segm(ijmatrix_POS_data, "resid_code", "POS",
"d_time", "freq_ij_abs_POS_expen", 0,10,20,30)
# Segmentation by travel time using the POS expenditures
</code></pre>

<hr>
<h2 id='shopping3'>
Market area data for the point-of-sale survey in Karlsruhe
</h2><span id='topic+shopping3'></span>

<h3>Description</h3>

<p>The dataset contains information about
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("shopping3")</code></pre>


<h3>Format</h3>

<p>A data frame with 70 observations on the following 5 variables.
</p>

<dl>
<dt><code>resid_name</code></dt><dd><p>a factor containing the customer origin (place of residence) as name of the corresponding city or city district</p>
</dd>
<dt><code>resid_name_offical</code></dt><dd><p>a factor containing the customer origin (place of residence) as official names of the corresponding city or city district</p>
</dd>
<dt><code>resid_pop2015</code></dt><dd><p>a numeric vector containing the population size of the area</p>
</dd>
<dt><code>KA_east</code></dt><dd><p>a numeric vector containing a dummy variable indicating whether the area belongs to the east of Karlsruhe or not</p>
</dd>
<dt><code>resid_code</code></dt><dd><p>a factor containing the customer origin (place of residence) as internal code</p>
</dd>
</dl>



<h3>Source</h3>

<p>Primary empirical sources:
POS (point of sale) survey in the authors' course (&ldquo;Praktikum Empirische Sozialforschung: Stadtteilzentren als Einzelhandelsstandorte - Das Fallbeispiel Karlsruhe-Durlach&rdquo;, Karlsruhe Institute of Technology, Institute for Geography and Geoecology, May 2016), own calculations
</p>
<p>Stadt Karlsruhe, Amt fuer Stadtentwicklung (2016): &ldquo;Die Karlsruher Bevoelkerung im Dezember 2015&rdquo;. Stadt Karlsruhe.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shopping1">shopping1</a></code>, <code><a href="#topic+shopping2">shopping2</a></code>, <code><a href="#topic+shopping4">shopping4</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Market area analysis based on the POS survey in shopping1 #

data(shopping1)
# The survey dataset
data(shopping2)
# Dataset with distances and travel times

shopping1_adj &lt;- shopping1[(shopping1$weekday != 3) &amp; (shopping1$holiday != 1) 
&amp; (shopping1$survey != "pretest"),]
# Removing every case from tuesday, holidays and the ones belonging to the pretest

ijmatrix_POS &lt;- ijmatrix.create(shopping1_adj, "resid_code", "POS", "POS_expen")
# Creates an interaction matrix based on the observed frequencies (automatically)
# and the POS expenditures (Variable "POS_expen" separately stated)

ijmatrix_POS_data &lt;- merge(ijmatrix_POS, shopping2, by.x="interaction", by.y="route", 
all.x = TRUE)
# Adding the distances and travel times

ijmatrix_POS_data$freq_ij_abs_cor &lt;- var.correct(ijmatrix_POS_data$freq_ij_abs, 
corr.mode = "inc", incby = 0.1)
# Correcting the absolute values (frequencies) by increasing by 0.1

data(shopping3)
ijmatrix_POS_data_residdata &lt;- merge(ijmatrix_POS_data, shopping3)
# Adding the information about the origins (places of residence) stored in shopping3

ijmatrix_POS_data_residdata$visitper1000 &lt;- (ijmatrix_POS_data_residdata$
freq_ij_abs_cor/ijmatrix_POS_data_residdata$resid_pop2015)*1000
# Calculating the dependent variable
# visitper1000: surveyed customers per 1.000 inhabitants of the origin

ijmatrix_POS_data_residdata &lt;- 
ijmatrix_POS_data_residdata[(!is.na(ijmatrix_POS_data_residdata$
visitper1000)) &amp; (!is.na(ijmatrix_POS_data_residdata$d_time)),]
# Removing NAs (data for some outlier origins and routes not available)

ijmatrix_POS_data_residdata_POS1 &lt;- 
ijmatrix_POS_data_residdata[ijmatrix_POS_data_residdata$POS=="POS1",]
# Dataset for POS1 (town centre)

ijmatrix_POS_data_residdata_POS2 &lt;- 
ijmatrix_POS_data_residdata[ijmatrix_POS_data_residdata$POS=="POS2",]
# Dataset for POS2 (out-of-town shopping centre)

huff.decay(ijmatrix_POS_data_residdata_POS1, "d_km", "visitper1000")
huff.decay(ijmatrix_POS_data_residdata_POS1, "d_time", "visitper1000")
huff.decay(ijmatrix_POS_data_residdata_POS2, "d_km", "visitper1000")
huff.decay(ijmatrix_POS_data_residdata_POS2, "d_time", "visitper1000")
</code></pre>

<hr>
<h2 id='shopping4'>
Grocery store data for the point-of-sale survey in Karlsruhe
</h2><span id='topic+shopping4'></span>

<h3>Description</h3>

<p>This dataset contains information about the regarded grocery stores in the east of Karlsruhe, based on the POS survey stored in the dataset <code>shopping1</code> and the related information in <code>shopping2</code>..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("shopping4")</code></pre>


<h3>Format</h3>

<p>A data frame with 11 observations on the following 4 variables.
</p>

<dl>
<dt><code>location_code</code></dt><dd><p>a factor containing the grocery store codes</p>
</dd>
<dt><code>salesarea_qm</code></dt><dd><p>a numeric vector containing the sales area of the stores in sqm</p>
</dd>
<dt><code>storetype_dc</code></dt><dd><p>a numeric vector containing a dummy variable that indicates if the store is a discounter or not</p>
</dd>
<dt><code>store_chain</code></dt><dd><p>a factor containing the store chain</p>
</dd>
</dl>



<h3>Source</h3>

<p>Primary empirical sources:
POS (point of sale) survey in the authors' course (&ldquo;Praktikum Empirische Sozialforschung: Stadtteilzentren als Einzelhandelsstandorte - Das Fallbeispiel Karlsruhe-Durlach&rdquo;, Karlsruhe Institute of Technology, Institute for Geography and Geoecology, May 2016), own calculations
</p>
<p>Mapping of grocery stores in the east of Karlsruhe in June 2016 with additional research
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shopping1">shopping1</a></code>, <code><a href="#topic+shopping2">shopping2</a></code>, <code><a href="#topic+shopping3">shopping3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># MCI analysis for the grocery store market areas based on the POS survey in shopping1 #

data(shopping1)
# Loading the survey dataset
data(shopping2)
# Loading the distance/travel time dataset
data(shopping3)
# Loading the dataset containing information about the city districts
data(shopping4)
# Loading the grocery store data

shopping1_KAeast &lt;- shopping1[shopping1$resid_code %in% 
shopping3$resid_code[shopping3$KA_east == 1],]
# Extracting only inhabitants of the eastern districts of Karlsruhe

ijmatrix_gro_adj &lt;- ijmatrix.create(shopping1_KAeast, "resid_code",
"gro_purchase_code", "gro_purchase_expen", remSing = TRUE, remSing.val = 1,
remSingSupp.val = 2, correctVar = TRUE, correctVar.val = 0.1)
# Removing singular instances/outliers (remSing = TRUE) incorporating
# only suppliers which are at least obtained three times (remSingSupp.val = 2)
# Correcting the values (correctVar = TRUE)
# by adding 0.1 to the absolute values (correctVar.val = 0.1)

ijmatrix_gro_adj &lt;- ijmatrix_gro_adj[(ijmatrix_gro_adj$gro_purchase_code !=
"REFORMHAUSBOESER") &amp; (ijmatrix_gro_adj$gro_purchase_code != "WMARKT_DURLACH")
&amp; (ijmatrix_gro_adj$gro_purchase_code != "X_INCOMPLETE_STORE"),]
# Remove non-regarded observations

ijmatrix_gro_adj_dist &lt;- merge (ijmatrix_gro_adj, shopping2, by.x="interaction",
by.y="route")
# Include the distances and travel times (shopping2)
ijmatrix_gro_adj_dist_stores &lt;- merge (ijmatrix_gro_adj_dist, shopping4,
by.x = "gro_purchase_code", by.y = "location_code")
# Adding the store information (shopping4)

mci.transvar(ijmatrix_gro_adj_dist_stores, "resid_code", "gro_purchase_code", 
"p_ij_obs")
# Log-centering transformation of one variable (p_ij_obs)

ijmatrix_gro_transf &lt;- mci.transmat(ijmatrix_gro_adj_dist_stores, "resid_code",
"gro_purchase_code", "p_ij_obs", "d_time", "salesarea_qm")
# Log-centering transformation of the interaction matrix

mcimodel_gro_trips &lt;- mci.fit(ijmatrix_gro_adj_dist_stores, "resid_code",
"gro_purchase_code", "p_ij_obs", "d_time", "salesarea_qm")
# MCI model for the grocery store market areas
# shares: "p_ij_obs", explanatory variables: "d_time", "salesarea_qm"

summary(mcimodel_gro_trips)
# Use like lm
</code></pre>

<hr>
<h2 id='var.asdummy'>
Creating dummy variables
</h2><span id='topic+var.asdummy'></span>

<h3>Description</h3>

<p>This function creates a dataset of dummy variables based on an input character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.asdummy(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var.asdummy_+3A_x">x</code></td>
<td>

<p>A character vector
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In MCI analyzes (as in OLS regression models generally) only <em>quantitative</em> information (that means: numeric) is allowed. <em>Qualitative</em> information (e.g. brands, companies, retail chains) can be added using dummy variables [1,0]. This function transforms a character vector <code>x</code> with <code class="reqn">c</code> characteristics to a set of <code class="reqn">c</code> dummy variables whose column names correspond to these characteristics marked with &ldquo;_DUMMY&rdquo;.    
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with dummy variables corresponding to the levels of the input variable.
</p>


<h3>Author(s)</h3>

<p>Thomas Wieland
</p>


<h3>References</h3>

<p>Nakanishi, M./Cooper, L. G. (1982): &ldquo;Simplified Estimation Procedures for MCI Models&rdquo;. In: <em>Marketing Science</em>, <b>1</b>, 3, p. 314-322. 
</p>
<p>Tihi, B./Oruc, N. (2012): &ldquo;Competitive Location Assessment - the MCI Approach&rdquo;. In: <em>South East European Journal of Economics and Business</em>, <b>7</b>, 2, p. 35-49. 
</p>
<p>Wieland, T. (2015): &ldquo;Raeumliches Einkaufsverhalten und Standortpolitik im Einzelhandel unter Beruecksichtigung von Agglomerationseffekten. Theoretische Erklaerungsansaetze, modellanalytische Zugaenge und eine empirisch-oekonometrische Marktgebietsanalyse anhand eines Fallbeispiels aus dem laendlichen Raum Ostwestfalens/Suedniedersachsens&rdquo;. <em>Geographische Handelsforschung</em>, <b>23</b>. 289 pages. Mannheim : MetaGIS.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>charvec &lt;- c("Peter", "Paul", "Peter", "Mary", "Peter", "Paul")
# Creates a vector with three names (Peter, Paul, Mary)
var.asdummy(charvec)
# Returns a data frame with 3 dummy variables
# (Mary_DUMMY, Paul_DUMMY, Peter_DUMMY)

data(grocery2)
# Loads the data
dummyvars &lt;- var.asdummy(grocery2$store_chain)
# Save the dummy variable set into a new dataset
mynewmcidata &lt;- data.frame(grocery2, dummyvars)
# Add the dummy dataset to the input dataset
</code></pre>

<hr>
<h2 id='var.correct'>
Correcting MCI input variables
</h2><span id='topic+var.correct'></span>

<h3>Description</h3>

<p>This function corrects a numeric variable to match the MCI standards.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.correct(x, corr.mode = "inc", incby = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var.correct_+3A_x">x</code></td>
<td>

<p>a numeric vector
</p>
</td></tr>
<tr><td><code id="var.correct_+3A_corr.mode">corr.mode</code></td>
<td>

<p>character value for the mode of variable correction: <code>corr.mode = "inc"</code> increases the values by the value of <code>incby</code> (default: <code>incby = 1</code>). If <code>corr.mode = "incabs"</code> the values are increased by the absolute value of their minimum + <code>incby</code>. If <code>corr.mode = "zetas"</code> a zeta squared transformation is applied to the numeric vector
</p>
</td></tr>
<tr><td><code id="var.correct_+3A_incby">incby</code></td>
<td>

<p>value to increase the values with (default <code> = 1</code>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the MCI model, only numeric variables with values greater than zero are accepted (From the theoretical perspective, a zero or negative attractivity/utility is just as impossible as negative market shares. In the log-centering transformation, those values cannot be processed.). This function corrects a numeric variable with zero and/or negative values to match the MCI standards. The most frequent case is that some absolute values which shall be used to calculate market shares (e.g. observed frequencies or expenditures) are equal to zero and must be increased by 1. Alternatively, they can be increased automatically by the absolute value of their minimum + <code>incby</code>. Another option which is especially designed to transform interval scale data (such as scoring in consumer surveys) is to apply a zeta-squared transformation (Cooper/Nakanishi 1983) to the numeric vector (<code>corr.mode = "zetas"</code>).
</p>


<h3>Value</h3>

<p>Returns a numeric vector with the corrected values.
</p>


<h3>Author(s)</h3>

<p>Thomas Wieland
</p>


<h3>References</h3>

<p>Colome Perales, R. (2002): &ldquo;Consumer Choice in Competitive Location Models&rdquo;. Barcelona.
</p>
<p>Cooper, L.G./Nakanishi, M. (1983): &ldquo;Standardizing Variables in Multiplicative Choice Models&rdquo;. In: <em>Journal of Consumer Research</em>, <b>10</b>, 1, p. 96-108.
</p>
<p>Cooper, L. G./Nakanishi, M. (2010): &ldquo;Market-Share Analysis: Evaluating competitive marketing effectiveness&rdquo;. Boston, Dordrecht, London : Kluwer (first published 1988). E-book version from 2010: <a href="http://www.anderson.ucla.edu/faculty/lee.cooper/MCI_Book/BOOKI2010.pdf">http://www.anderson.ucla.edu/faculty/lee.cooper/MCI_Book/BOOKI2010.pdf</a>
</p>
<p>Hartmann, M. (2005): &ldquo;Gravitationsmodelle als Verfahren der Standortanalyse im Einzelhandel&rdquo;. <em>Statistik Regional Electronic Papers</em>, <b>02/2005</b>. Halle.
</p>
<p>Tihi, B./Oruc, N. (2012): &ldquo;Competitive Location Assessment - the MCI Approach&rdquo;. In: <em>South East European Journal of Economics and Business</em>, <b>7</b>, 2, p. 35-49. 
</p>
<p>Wieland, T. (2015): &ldquo;Raeumliches Einkaufsverhalten und Standortpolitik im Einzelhandel unter Beruecksichtigung von Agglomerationseffekten. Theoretische Erklaerungsansaetze, modellanalytische Zugaenge und eine empirisch-oekonometrische Marktgebietsanalyse anhand eines Fallbeispiels aus dem laendlichen Raum Ostwestfalens/Suedniedersachsens&rdquo;. <em>Geographische Handelsforschung</em>, <b>23</b>. 289 pages. Mannheim : MetaGIS.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>var1 &lt;- c(11, 17.5, 24.1, 0.9, 21.2, 0)
# a vector containing one zero value
var.correct(var1)
# returns a vector with input values increased by 1

var2 &lt;- -5:5
# a vector containing zero and negative values
var.correct(var2, corr.mode = "incabs", incby = 1)
# returns a vector with minimum value equal to 1

var.correct(var2, corr.mode = "zetas")
# returns a vector only with positive values 
# (zeta-squared transformation)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
