<!DOCTYPE html><html lang="en-US"><head><title>Help for package adept</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {adept}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#scaleTemplate'><p>Templates Scaling</p></a></li>
<li><a href='#segmentPattern'><p>Pattern Segmentation From a Time-series via ADEPT</p></a></li>
<li><a href='#segmentWalking'><p>Walking Stride Pattern Segmentation from Raw Accelerometry Data via ADEPT</p></a></li>
<li><a href='#similarityMatrix'><p>ADEPT Similarity Matrix Computation</p></a></li>
<li><a href='#windowSmooth'><p>Fast Computation of Moving Window Average</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Adaptive Empirical Pattern Transformation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Designed for optimal use in performing fast, 
    accurate walking strides segmentation from high-density 
    data collected from a wearable accelerometer worn 
    during continuous walking activity.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/martakarass/adept">https://github.com/martakarass/adept</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/martakarass/adept/issues">https://github.com/martakarass/adept/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, ggplot2, lubridate, reshape2,
gridExtra, spelling, cluster, adeptdata, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, magrittr, dvmisc, parallel, pracma</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-31 23:38:16 UTC; martakaras</td>
</tr>
<tr>
<td>Author:</td>
<td>Marta Karas <a href="https://orcid.org/0000-0001-5889-3970"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Jacek Urbanek <a href="https://orcid.org/0000-0002-1890-8899"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Ciprian Crainiceanu [aut],
  John Muschelli <a href="https://orcid.org/0000-0001-6469-1750"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Adi Gherman [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marta Karas &lt;marta.karass@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-01 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='scaleTemplate'>Templates Scaling</h2><span id='topic+scaleTemplate'></span>

<h3>Description</h3>

<p>Compute a list of scaled templates via linear interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleTemplate(template, template.vl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scaleTemplate_+3A_template">template</code></td>
<td>
<p>A list of numeric vectors. Each vector represents
a distinct template.</p>
</td></tr>
<tr><td><code id="scaleTemplate_+3A_template.vl">template.vl</code></td>
<td>
<p>A numeric vector. A grid of vector lengths that each
element of <code>template</code> is to be linearly interpolated into.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lists of numeric vectors.
Each element of the
returned list is a list of templates scaled according
to a particular vector length. The number of elements in the returned
list equals the length of <code>template.vl</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Construct a list of two templates
template &lt;- list(sin(seq(0, 2 * pi, length.out = 100)),
                 cos(seq(0, 2 * pi, length.out = 100)))
## A grid of vector lengths to which each of templates is scaled into
template.vl &lt;- c(50, 100, 200)
## Compute list of rescaled templates
out &lt;- scaleTemplate(template, template.vl)

## Plot 1st template after rescaling to three values of vector length
par(mfrow = c(2, 1), cex = 0.7)
plot(out[[3]][[1]], type = "l",
     main = "Pattern: sin([0, 2 * pi]) rescaled according to different scales",
     ylab = "Pattern", xlab = "Index")
lines(out[[2]][[1]], col = "red")
lines(out[[1]][[1]], col = "blue")

## Plot 2nd template after rescaling to three values of vector length
plot(out[[3]][[2]], type = "l",
     main = "Pattern: cos([0, 2 * pi]) rescaled according to different scales",
     ylab = "Pattern", xlab = "Index")
lines(out[[2]][[2]], col = "red")
lines(out[[1]][[2]], col = "blue")

</code></pre>

<hr>
<h2 id='segmentPattern'>Pattern Segmentation From a Time-series via ADEPT</h2><span id='topic+segmentPattern'></span>

<h3>Description</h3>

<p>Segment pattern from a time-series <code>x</code> via Adaptive Empirical Pattern
Transformation (ADEPT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segmentPattern(
  x,
  x.fs,
  template,
  pattern.dur.seq,
  similarity.measure = "cov",
  similarity.measure.thresh = 0,
  x.adept.ma.W = NULL,
  finetune = NULL,
  finetune.maxima.ma.W = NULL,
  finetune.maxima.nbh.W = NULL,
  run.parallel = FALSE,
  run.parallel.cores = 1L,
  x.cut = TRUE,
  x.cut.vl = 6000,
  compute.template.idx = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segmentPattern_+3A_x">x</code></td>
<td>
<p>A numeric vector. A time-series to segment pattern from.</p>
</td></tr>
<tr><td><code id="segmentPattern_+3A_x.fs">x.fs</code></td>
<td>
<p>A numeric scalar. Frequency at which a time-series <code>x</code> is collected,
expressed in a number of observations per second.</p>
</td></tr>
<tr><td><code id="segmentPattern_+3A_template">template</code></td>
<td>
<p>A list of numeric vectors, or a numeric vector.
Each vector represents a distinct pattern template used in segmentation.</p>
</td></tr>
<tr><td><code id="segmentPattern_+3A_pattern.dur.seq">pattern.dur.seq</code></td>
<td>
<p>A numeric vector. A grid of potential pattern durations
used in segmentation. Expressed in seconds. See: Details.</p>
</td></tr>
<tr><td><code id="segmentPattern_+3A_similarity.measure">similarity.measure</code></td>
<td>
<p>A character scalar. Statistic used to compute similarity
between a time-series <code>x</code>  and pattern templates. Currently supported values:
</p>

<ul>
<li> <p><code>"cov"</code> - covariance,
</p>
</li>
<li> <p><code>"cor"</code> - correlation,
</p>
</li></ul>

<p>Default is <code>"cov"</code>.</p>
</td></tr>
<tr><td><code id="segmentPattern_+3A_similarity.measure.thresh">similarity.measure.thresh</code></td>
<td>
<p>A numeric scalar. Threshold of minimal similarity
value between a time-series <code>x</code> and a template
below which the algorithm does not identify a pattern occurrence from <code>x</code>.
Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="segmentPattern_+3A_x.adept.ma.w">x.adept.ma.W</code></td>
<td>
<p>A numeric scalar.
A length of a window used in moving average smoothing of a time-series <code>x</code> for
similarity matrix computation. Expressed in seconds.
Default is <code>NULL</code> (no smoothing applied).</p>
</td></tr>
<tr><td><code id="segmentPattern_+3A_finetune">finetune</code></td>
<td>
<p>A character scalar. A type of fine-tuning procedure employed in
segmentation. Defaults to <code>NULL</code> (no fine-tuning procedure employed). Currently supported values:
</p>

<ul>
<li> <p><code>"maxima"</code> - tunes preliminarily identified
beginning and end of a pattern so
as they correspond to local maxima of time-series <code>x</code> (or smoothed version of <code>x</code>)
found within neighbourhoods of preliminary locations.
</p>
</li></ul>
</td></tr>
<tr><td><code id="segmentPattern_+3A_finetune.maxima.ma.w">finetune.maxima.ma.W</code></td>
<td>
<p>A numeric scalar.
A length of a window used in moving average smoothing of a time-series <code>x</code> in
<code>"maxima"</code> fine-tuning procedure. Expressed in seconds.
Default is <code>NULL</code> (no smoothing applied).</p>
</td></tr>
<tr><td><code id="segmentPattern_+3A_finetune.maxima.nbh.w">finetune.maxima.nbh.W</code></td>
<td>
<p>A numeric scalar.
A length of the two neighborhoods centered at preliminarily identified
beginning and end of a pattern
within which we search for local maxima of <code>x</code> (or smoothed version of <code>x</code>) in <code>"maxima"</code>
fine-tuning procedure. Expressed in seconds. Default is <code>NULL</code>.
Note: if the length provided corresponds to an even number of <code>x</code> vector indices,
it will be rounded down so as the corresponding number of vector indices is its closest odd number.</p>
</td></tr>
<tr><td><code id="segmentPattern_+3A_run.parallel">run.parallel</code></td>
<td>
<p>A logical scalar. Whether or not to use parallel execution in the algorithm
with <code>parallel</code> package. Default is <code>FALSE</code>. DOES NOT WORK ON WINDOWS.</p>
</td></tr>
<tr><td><code id="segmentPattern_+3A_run.parallel.cores">run.parallel.cores</code></td>
<td>
<p>An integer scalar.
The number of cores to use for parallel execution. Defaults to 1L (no parallel).
DOES NOT WORK ON WINDOWS.</p>
</td></tr>
<tr><td><code id="segmentPattern_+3A_x.cut">x.cut</code></td>
<td>
<p>A logical scalar. Whether or not to use time optimization procedure in
which a time-series <code>x</code> is cut into parts and segmentation is performed for
each part of <code>x</code> separately. Recommended for a time-series <code>x</code> of vector length
above 30,000. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="segmentPattern_+3A_x.cut.vl">x.cut.vl</code></td>
<td>
<p>An integer scalar.
Defines a vector length of parts that <code>x</code> vector is cut into during the execution time optimization procedure.
Default is <code>6000</code> (recommended).</p>
</td></tr>
<tr><td><code id="segmentPattern_+3A_compute.template.idx">compute.template.idx</code></td>
<td>
<p>A logical scalar. Whether or not to compute and return information about
which of the provided pattern templates yielded a similarity matrix value
that corresponds to an identified pattern occurrence.
Setting to <code>TRUE</code> may increase computation time. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function implements Adaptive Empirical Pattern Transformation (ADEPT) method for pattern segmentation
from a time-series <code>x</code>.
ADEPT is optimized to perform fast, accurate walking strides segmentation from
high-density data collected with a wearable accelerometer during walking.
</p>
<p>ADEPT identifies patterns in a time-series <code>x</code> via maximization of chosen
similarity statistic (correlation, covariance, etc.) between a time-series <code>x</code>
and a pattern template(s). It accounts for variability in both
(1) pattern duration and (2) pattern shape.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with segmentation results. Each row
describes one identified pattern occurrence:
</p>

<ul>
<li> <p><code>tau_i</code> - index of  <code>x</code> where pattern starts,
</p>
</li>
<li> <p><code>T_i</code> - pattern duration, expressed in <code>x</code> vector length,
</p>
</li>
<li> <p><code>sim_i</code> -  similarity between a pattern and <code>x</code>;
note: if <code>"maxima"</code> fine-tune and/or <code>x</code> smoothing is employed,
the similarity value between the final segmented pattern and a template
may differ from the value in this table,
</p>
</li>
<li> <p><code>template_i</code> - if <code>compute.template.idx</code> equals <code>TRUE</code>:
index of a template best matched to <code>x</code>;
if <code>compute.template.idx</code> equals <code>FALSE</code>: <code>NA</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Karas, M., Straczkiewicz, M., Fadel, W., Harezlak, J., Crainiceanu, C.M.,
Urbanek, J.K. (2019). Adaptive empirical pattern
transformation (ADEPT) with application to walking stride segmentation.
Biostatistics. https://doi.org/10.1093/biostatistics/kxz033
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1: Simulate a time-series `x`. Assume that
## - `x` is collected at a frequency of 100 Hz,
## - there is one shape of pattern present within `x`,
## - each pattern lasts 1 second,
## - there is no noise in the collected data.
true.pattern &lt;- cos(seq(0, 2 * pi, length.out = 100))
x &lt;- c(true.pattern[1], replicate(10, true.pattern[-1]))
## Segment pattern from x.
out &lt;- segmentPattern(
  x = x,
  x.fs = 100,
  template = true.pattern,
  pattern.dur.seq = c(0.9, 0.95, 1.03, 1.1),
  similarity.measure = "cor",
  compute.template.idx = TRUE)
out
## Segment pattern from x. Now assume a grid of potential pattern duratios
## contains true pattern duration
out &lt;- segmentPattern(
  x = x,
  x.fs = 100,
  template = true.pattern,
  pattern.dur.seq = c(0.9, 0.95, 1, 1.03, 1.1),
  similarity.measure = "cor",
  compute.template.idx = TRUE)
out

## Example 2: Simulate a time-series `x`. Assume that
## - `x` is collected at a frequency of 100 Hz,
## - there are two shapes of pattern present within `x`,
## - patterns have various duration,
## - there is no noise in the collected data.
true.pattern.1 &lt;- cos(seq(0, 2 * pi, length.out = 200))
true.pattern.2 &lt;- true.pattern.1
true.pattern.2[70:130] &lt;- 2 * true.pattern.2[min(70:130)] + abs(true.pattern.2[70:130])
x &lt;- numeric()
for (vl in seq(70, 130, by = 10)){
  true.pattern.1.s &lt;- approx(
    seq(0, 1, length.out = 200),
    true.pattern.1, xout = seq(0, 1, length.out = vl))$y
  true.pattern.2.s &lt;- approx(
    seq(0, 1, length.out = 200),
    true.pattern.2, xout = seq(0, 1, length.out = vl))$y
  x &lt;- c(x, true.pattern.1.s[-1], true.pattern.2.s[-1])
  if (vl == 70) x &lt;- c(true.pattern.1.s[1], x)
}
## Segment pattern from x. Use a `template` object consisting of both
## true patterns used in `x` simulation.
out &lt;- segmentPattern(
  x = x,
  x.fs = 100,
  template = list(true.pattern.1, true.pattern.2),
  pattern.dur.seq = 60:130 * 0.01,
  similarity.measure = "cor",
  compute.template.idx = TRUE)
out

## Example 3: Simulate a time-series `x`. Assume that
## - `x` is collected at a frequency of 100 Hz,
## - there are two shapes of a pattern present within `x`,
## - patterns have various duration,
## - there is noise in the collected data.
set.seed(1)
x &lt;- x + rnorm(length(x), sd = 0.5)
## Segment pattern from x.
out &lt;- segmentPattern(
  x = x,
  x.fs = 100,
  template = list(true.pattern.1, true.pattern.2),
  pattern.dur.seq =  60:130 * 0.01,
  similarity.measure = "cor",
  compute.template.idx = TRUE)
out
## Segment pattern from x. Use `x.adept.ma.W` to define a length of a smoothing
## window to smooth `x` for similarity matrix computation.
out &lt;- segmentPattern(
  x = x,
  x.fs = 100,
  template = list(true.pattern.1, true.pattern.2),
  pattern.dur.seq =  60:130 * 0.01,
  similarity.measure = "cor",
  x.adept.ma.W = 0.1,
  compute.template.idx = TRUE)
out
## Segment pattern from x. Use `x.adept.ma.W` to define a length of a smoothing
## window to smooth `x` for similarity matrix computation. Employ a fine-tuning
## procedure for stride identification.
out &lt;- segmentPattern(
  x = x,
  x.fs = 100,
  template = list(true.pattern.1, true.pattern.2),
  pattern.dur.seq =  60:130 * 0.01,
  similarity.measure = "cor",
  x.adept.ma.W = 0.1,
  finetune = "maxima",
  finetune.maxima.nbh.W = 0.3,
  compute.template.idx = TRUE)
out
## Segment pattern from x. Employ a fine-tuning procedure for stride
## identification. Smooth `x` for both similarity matrix computation
## (set `x.adept.ma.W = 0.1`) and for  fine-tune peak detection procedure
## (set `finetune.maxima.nbh.W = 0.3`).
out &lt;- segmentPattern(
  x = x,
  x.fs = 100,
  template = list(true.pattern.1, true.pattern.2),
  pattern.dur.seq =  60:130 * 0.01,
  similarity.measure = "cor",
  x.adept.ma.W = 0.1,
  finetune = "maxima",
  finetune.maxima.nbh.W = 0.3,
  compute.template.idx = TRUE)
out

</code></pre>

<hr>
<h2 id='segmentWalking'>Walking Stride Pattern Segmentation from Raw Accelerometry Data via ADEPT</h2><span id='topic+segmentWalking'></span>

<h3>Description</h3>

<p>Segment walking stride pattern from a raw accelerometry data time-series
<code>(x,y,z)</code> via Adaptive Empirical Pattern Transformation (ADEPT).
Default algorithm parameters are optimized for a wrist-worn sensor and
were evaluated with data collected in the free-living environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segmentWalking(
  xyz,
  xyz.fs,
  template,
  sim_MIN = 0.85,
  dur_MIN = 0.8,
  dur_MAX = 1.4,
  ptp_r_MIN = 0.2,
  ptp_r_MAX = 2,
  vmc_r_MIN = 0.05,
  vmc_r_MAX = 0.5,
  mean_abs_diff_med_p_MAX = 0.5,
  mean_abs_diff_med_t_MAX = 0.2,
  mean_abs_diff_dur_MAX = 0.2,
  compute.template.idx = FALSE,
  run.parallel = FALSE,
  run.parallel.cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segmentWalking_+3A_xyz">xyz</code></td>
<td>
<p>A numeric matrix (or data frame) of n × 3 dimension.
Three-dimensional
raw accelerometry data time-series; acceleration measurements <code>(x,y,z)</code>
collected
along three orthogonal axes by the sensor's accelerometer.</p>
</td></tr>
<tr><td><code id="segmentWalking_+3A_xyz.fs">xyz.fs</code></td>
<td>
<p>A numeric scalar. Frequency at which a time-series
<code>(x,y,z)</code> is
collected, expressed in a number of observations per second.</p>
</td></tr>
<tr><td><code id="segmentWalking_+3A_template">template</code></td>
<td>
<p>A list of numeric vectors, or a numeric vector. Distinct
pattern template(s) of walking stride.</p>
</td></tr>
<tr><td><code id="segmentWalking_+3A_sim_min">sim_MIN</code></td>
<td>
<p>numeric scalar. Minimum value of correlation between pattern
template(s) and (r_t)_t vector magnitude of accelerometry data.
Default used is 0.85.</p>
</td></tr>
<tr><td><code id="segmentWalking_+3A_dur_min">dur_MIN</code></td>
<td>
<p>A numeric scalar. Minimum value of a stride duration allowed
to be identified. Expressed in seconds. Default used is 0.8.</p>
</td></tr>
<tr><td><code id="segmentWalking_+3A_dur_max">dur_MAX</code></td>
<td>
<p>A numeric scalar. Maximum value of a stride duration allowed
to be identified. Expressed in seconds. Default used is 1.4.</p>
</td></tr>
<tr><td><code id="segmentWalking_+3A_ptp_r_min">ptp_r_MIN</code></td>
<td>
<p>A numeric scalar. Minimum value of &quot;peak to peak&quot;
difference in (r_t)_t vector magnitude data of a stride.
Default used is 0.2.</p>
</td></tr>
<tr><td><code id="segmentWalking_+3A_ptp_r_max">ptp_r_MAX</code></td>
<td>
<p>A numeric scalar. Maximum value of &quot;peak to peak&quot;
difference in (r_t)_t vector magnitude data of a stride.
Default used is 2.0</p>
</td></tr>
<tr><td><code id="segmentWalking_+3A_vmc_r_min">vmc_r_MIN</code></td>
<td>
<p>A numeric scalar. Minimum value of VMC in
(r_t)_t vector magnitude data
of a stride. Default used is 0.05.</p>
</td></tr>
<tr><td><code id="segmentWalking_+3A_vmc_r_max">vmc_r_MAX</code></td>
<td>
<p>A numeric scalar. Maximum value of VMC in
(r_t)_t vector magnitude data
of a stride. Default used is 0.5.</p>
</td></tr>
<tr><td><code id="segmentWalking_+3A_mean_abs_diff_med_p_max">mean_abs_diff_med_p_MAX</code></td>
<td>
<p>A numeric scalar. Maximum value of MAD* of
Azimuth (az_)_t median for 3 subsequent valid strides.
Here, MAD* stands for mean
of 2 absolute differences between 3 subsequent values. Default used is 0.5.</p>
</td></tr>
<tr><td><code id="segmentWalking_+3A_mean_abs_diff_med_t_max">mean_abs_diff_med_t_MAX</code></td>
<td>
<p>A numeric scalar. Maximum value of MAD* of
Elevation (el_)_t median for 3 subsequent valid strides.
Here, MAD* stands for mean
of 2 absolute differences between 3 subsequent values. Default used is 0.2.</p>
</td></tr>
<tr><td><code id="segmentWalking_+3A_mean_abs_diff_dur_max">mean_abs_diff_dur_MAX</code></td>
<td>
<p>A numeric scalar. Maximum value of MAD* of
duration time for 3 subsequent valid strides. Here, MAD* stands for mean
of 2 absolute differences between 3 subsequent values. Default used is 0.2.</p>
</td></tr>
<tr><td><code id="segmentWalking_+3A_compute.template.idx">compute.template.idx</code></td>
<td>
<p>A logical scalar. Whether or not to compute
and return information about
which of the provided pattern templates yielded a similarity matrix value
that corresponds to an identified pattern occurrence.
Setting to <code>TRUE</code> may increase computation time.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="segmentWalking_+3A_run.parallel">run.parallel</code></td>
<td>
<p>A logical scalar. Whether or not to use parallel
execution in the algorithm
with <code>parallel</code> package. Default is <code>FALSE</code>.
DOES NOT WORK ON WINDOWS.</p>
</td></tr>
<tr><td><code id="segmentWalking_+3A_run.parallel.cores">run.parallel.cores</code></td>
<td>
<p>An integer scalar.
The number of cores to use for parallel execution. Defaults to 1L
(no parallel). DOES NOT WORK ON WINDOWS.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with segmentation results. Each row
describes one identified pattern occurrence:
</p>

<ul>
<li> <p><code>tau_i</code> - row index of <code>xyz</code> where pattern starts,
</p>
</li>
<li> <p><code>T_i</code> - pattern duration, expressed in <code>xyz</code> vector length,
</p>
</li>
<li> <p><code>sim_i</code> -  similarity between a pattern and
best-fit template; see <code>segmentPattern</code> for details,
</p>
</li>
<li> <p><code>template_i</code> - if <code>compute.template.idx</code> equals <code>TRUE</code>:
index of a template best matched to <code>x</code>;
if <code>compute.template.idx</code> equals <code>FALSE</code>: <code>NA</code>,
</p>
</li>
<li> <p><code>is_walking_i</code> &ndash; <code>1</code> if a pattern is identified as walking
stride; <code>0</code> otherwise.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(adeptdata)
library(dplyr)
library(adept)
xyz &lt;-
  adeptdata::acc_walking_IU %&gt;%
  filter(loc_id == "left_wrist", subj_id == "id86237981") %&gt;%
  arrange(time_s) %&gt;%
  select(v1 = x, v2 = y, v3 = z) %&gt;%
  as.matrix()
# define raw accelerometry data sample frequency
xyz.fs &lt;- 100

# define template list based on predefined templates
template_mat &lt;- adeptdata::stride_template$left_wrist[[3]]
template &lt;- list(
  template_mat[1, ],
  template_mat[2, ],
  template_mat[3, ]
)

# run walking segmentation
# (parallel supported, except for Windows; see run.parallel, run.parallel.cores args)
segmentWalking(xyz, xyz.fs, template)

</code></pre>

<hr>
<h2 id='similarityMatrix'>ADEPT Similarity Matrix Computation</h2><span id='topic+similarityMatrix'></span>

<h3>Description</h3>

<p>Compute ADEPT similarity matrix between a time-series <code>x</code> and a collection
of scaled templates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>similarityMatrix(x, template.scaled, similarity.measure)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="similarityMatrix_+3A_x">x</code></td>
<td>
<p>A numeric vector. A time-series <code>x</code>.</p>
</td></tr>
<tr><td><code id="similarityMatrix_+3A_template.scaled">template.scaled</code></td>
<td>
<p>A list of lists of numeric vectors, as returned by
<code>scaleTemplate</code>.  Each element of
<code>template.scaled</code>
is a list of templates interpolated to a particular vector length.
Number of elements in the <code>template.scaled</code>  corresponds to the
number of unique template length values used in segmentation.</p>
</td></tr>
<tr><td><code id="similarityMatrix_+3A_similarity.measure">similarity.measure</code></td>
<td>
<p>A character scalar. Statistic
used in similarity matrix computation; one of the following:
</p>

<ul>
<li><p> &quot;cov&quot; - for covariance,
</p>
</li>
<li><p> &quot;cor&quot; - for correlation.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix. Contains values of similarity between a time-series <code>x</code>
and scaled templates.
</p>

<ul>
<li><p> Number of rows equals <code>template.scaled</code> length,
number of columns equals <code>x</code>  length.
</p>
</li>
<li><p> A particular matrix row consists of similarity statistic
between <code>x</code> and a template rescaled to a particular vector length.
Precisely, each row's element is a maximum out of similarity values
computed for each distinct template used in segmentation.
</p>
</li></ul>



<h3>See Also</h3>

<p><code>scaleTemplate {adept}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data
par(mfrow = c(1,1))
x0 &lt;- sin(seq(0, 2 * pi * 100, length.out = 10000))
x  &lt;- x0 + rnorm(1000, sd = 0.1)
template &lt;- list(x0[1:500])
template.vl &lt;- seq(300, 700, by = 50)

## Rescale pattern
template.scaled &lt;- scaleTemplate(template, template.vl)

## Compute ADEPT similarity matrix
out &lt;- similarityMatrix(x, template.scaled, "cov")

## Visualize
par(mfrow = c(1,1))
image(t(out),
      main = "ADEPT similarity matrix\nfor time-series x and scaled versions of pattern templates",
      xlab = "Time index",
      ylab = "Pattern vector length",
      xaxt = "n", yaxt = "n")
xaxis &lt;- c(1, seq(1000, length(x0), by = 1000))
yaxis &lt;- template.vl
axis(1, at = xaxis/max(xaxis), labels = xaxis)
axis(2, at = (yaxis - min(yaxis))/(max(yaxis) - min(yaxis)), labels = yaxis)

</code></pre>

<hr>
<h2 id='windowSmooth'>Fast Computation of Moving Window Average</h2><span id='topic+windowSmooth'></span>

<h3>Description</h3>

<p>Compute moving window average of a time-series <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>windowSmooth(x, W, x.fs = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="windowSmooth_+3A_x">x</code></td>
<td>
<p>A numeric vector. A time-series for which a moving window average is computed.</p>
</td></tr>
<tr><td><code id="windowSmooth_+3A_w">W</code></td>
<td>
<p>A numeric scalar. A length of a moving window, expressed in time (seconds).</p>
</td></tr>
<tr><td><code id="windowSmooth_+3A_x.fs">x.fs</code></td>
<td>
<p>Frequency of a time-series <code>x</code>, expressed in a number of observations
per second. Defaults to <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Time-series frequency <code>x.fs</code> and a length  of a moving window (expressed in time) <code>W</code>
together determine
<code>W.vl = round(W * x.fs)</code>, a length of a moving window expressed in a length of
<code>x</code> vector object.
Note: <code>W.vl</code> must be equal or greater than <code>3</code>.
</p>

<ul>
<li><p> If <code>W.vl &lt; 3</code> then an error is thrown.
</p>
</li>
<li><p> If <code>W.vl</code> is an even number then <code>(W.vl-1)</code> value is silently
used instead as a length of a moving window expressed in <code>x</code> vector length.
</p>
</li></ul>



<h3>Value</h3>

<p>A numeric vector. Moving window average of a time-series <code>x</code>. Note:
head and tail of the
output vector where the moving window is undefined are filled with <code>NA</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Time-series defined as a function f(x) = x
N &lt;- 100
W  &lt;- 20
x &lt;- 1:N
x.smoothed &lt;- windowSmooth(x, W)
plot(x, type = "l")
points(x.smoothed, col = "red")

## Time-series defined as a function f(x) = sin(x) + noise
N &lt;-  1000
W  &lt;- 100
x &lt;- sin(seq(0, 4 * pi, length.out = N)) + rnorm(N, sd = 0.1)
x.smoothed &lt;- windowSmooth(x, W)
plot(x, type = "l")
points(x.smoothed, col = "red")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
