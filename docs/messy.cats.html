<!DOCTYPE html><html lang="en"><head><title>Help for package messy.cats</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {messy.cats}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#messy.cats-package'><p>messy.cats: Employs String Distance Tools to Help Clean Categorical Data</p></a></li>
<li><a href='#cat_join'><p>cat_join</p></a></li>
<li><a href='#cat_match'><p>cat_match</p></a></li>
<li><a href='#cat_replace'><p>cat_replace</p></a></li>
<li><a href='#clean_caterpillars'><p>clean_caterpillars</p></a></li>
<li><a href='#clean_names.df'><p>clean_names.df</p></a></li>
<li><a href='#country_match'><p>country_match</p></a></li>
<li><a href='#country_replace'><p>country_replace</p></a></li>
<li><a href='#country.names'><p>country.names</p></a></li>
<li><a href='#fix_typos'><p>fix_typos</p></a></li>
<li><a href='#fuzzy_rbind'><p>fuzzy_rbind</p></a></li>
<li><a href='#messy_caterpillars'><p>messy_caterpillars</p></a></li>
<li><a href='#messy_names.df'><p>messy_names.df</p></a></li>
<li><a href='#messy_states1'><p>messy_states1</p></a></li>
<li><a href='#messy_states2'><p>messy_states2</p></a></li>
<li><a href='#picked_list'><p>picked_list</p></a></li>
<li><a href='#select_metric'><p>select_metric</p></a></li>
<li><a href='#state_match'><p>state_match</p></a></li>
<li><a href='#state_replace'><p>state_replace</p></a></li>
<li><a href='#state.name'><p>state.name</p></a></li>
<li><a href='#typos'><p>typos</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Employs String Distance Tools to Help Clean Categorical Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hkarp1/messy.cats/issues">https://github.com/hkarp1/messy.cats/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Matching with string distance has never been easier! 'messy.cats' contains various functions that employ string distance tools in order to make data management easier for users working with categorical data. Categorical data, especially user inputted categorical data that often tends to be plagued by typos, can be difficult to work with. 'messy.cats' aims to provide functions that make cleaning categorical data simple and easy.  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, stringdist, varhandle, rapportools, stringr, gt</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-29 23:21:24 UTC; andrewhennessy</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrew Hennessy [aut],
  Duncan Kreutter [aut],
  Harrison Karp [cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Harrison Karp &lt;hkarp@wesleyan.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-30 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='messy.cats-package'>messy.cats: Employs String Distance Tools to Help Clean Categorical Data</h2><span id='topic+messy.cats'></span><span id='topic+messy.cats-package'></span>

<h3>Description</h3>

<p>Matching with string distance has never been easier! 'messy.cats' contains various functions that employ string distance tools in order to make data management easier for users working with categorical data. Categorical data, especially user inputted categorical data that often tends to be plagued by typos, can be difficult to work with. 'messy.cats' aims to provide functions that make cleaning categorical data simple and easy.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Harrison Karp <a href="mailto:hkarp@wesleyan.edu">hkarp@wesleyan.edu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Andrew Hennessy <a href="mailto:ahennessy@wesleyan.edu">ahennessy@wesleyan.edu</a>
</p>
</li>
<li><p> Duncan Kreutter <a href="mailto:dkreutter@wesleyan.edu">dkreutter@wesleyan.edu</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/hkarp1/messy.cats/issues">https://github.com/hkarp1/messy.cats/issues</a>
</p>
</li></ul>


<hr>
<h2 id='cat_join'>cat_join</h2><span id='topic+cat_join'></span>

<h3>Description</h3>

<p>cat_join() joins two dataframes using the closest match
between two specified columns with misspellings or slight format differences.
The closest match can be found using a variety of different string distance measurement options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_join(
  messy_df,
  clean_df,
  by,
  threshold = NA,
  method = "jw",
  q = 1,
  p = 0,
  bt = 0,
  useBytes = FALSE,
  weight = c(d = 1, i = 1, t = 1),
  join = "left"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cat_join_+3A_messy_df">messy_df</code></td>
<td>
<p>The dataframe to be joined using a messy categorical variable.</p>
</td></tr>
<tr><td><code id="cat_join_+3A_clean_df">clean_df</code></td>
<td>
<p>The dataframe to be joined with a clean categorical variable to be used
as a reference for the messy column.</p>
</td></tr>
<tr><td><code id="cat_join_+3A_by">by</code></td>
<td>
<p>A vector that specifies the columns to match and join by. If the column
names are the same input: &quot;column_name&quot;. If the columns have different names
input: c(&quot;messy_column&quot; = &quot;clean_column&quot;)</p>
</td></tr>
<tr><td><code id="cat_join_+3A_threshold">threshold</code></td>
<td>
<p>The maximum distance that will form a match. If this argument
is specified, any element in the messy vector that has no match closer than
the threshold distance will be replaced with NA. Default: NA</p>
</td></tr>
<tr><td><code id="cat_join_+3A_method">method</code></td>
<td>
<p>The type of string distance calculation to use. Possible methods
are : osa, lv, dl, hamming, lcs, qgram, cosine, jaccard, jw, and soundex.
See package stringdist for more information. Default: 'jw'</p>
</td></tr>
<tr><td><code id="cat_join_+3A_q">q</code></td>
<td>
<p>Size of the q-gram used in string distance calculation. Default: 1</p>
</td></tr>
<tr><td><code id="cat_join_+3A_p">p</code></td>
<td>
<p>Only used with method &quot;jw&quot;, the Jaro-Winkler penatly size. Default: 0</p>
</td></tr>
<tr><td><code id="cat_join_+3A_bt">bt</code></td>
<td>
<p>Only used with method &quot;jw&quot; with p &gt; 0, Winkler's boost threshold. Default: 0</p>
</td></tr>
<tr><td><code id="cat_join_+3A_usebytes">useBytes</code></td>
<td>
<p>Whether or not to perform byte-wise comparison. Default: FALSE</p>
</td></tr>
<tr><td><code id="cat_join_+3A_weight">weight</code></td>
<td>
<p>Only used with methods &quot;osa&quot; or &quot;dl&quot;, a vector representing the
penalty for deletion, insertion, substitution, and transposition,
in that order. Default: c(d = 1, i = 1, t = 1)</p>
</td></tr>
<tr><td><code id="cat_join_+3A_join">join</code></td>
<td>
<p>Choose a join function from the dplyr package to use in joining the datasets. Default: 'left'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When dealing with messy categorical string data, string distance
matching can be an easy and efficient cleaning tool. A variety of string
distance calculation algorithms have been developed for different types of data,
and these algorithms can be used to detect and remedy problems with categorical
string data.
</p>
<p>By providing a correctly spelled and specified vector of categories to be compared
against a vector of messy strings, a cleaned vector of categories can be generated
by finding the correctly specificed string most similar to a messy string. This
method works particularly well for messy user-inputted data that often suffers
from transposition or misspelling errors.
</p>
<p><code>cat_join()</code> joins the messy and clean datasets using the closest matching elements from
designated columns. The columns from the datasets are inputted into <code>cat_replace()</code> as the
messy and clean vectors, and the datasets are joined using a user inputted dplyr join verb.
</p>


<h3>Value</h3>

<p>Returns a dataframe consisting of the two inputted dataframes joined by their designated columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
 #EXAMPLE1
 messy_trees = data.frame()
 messy_trees[1:9,1] = c("red oak", "williw", "hemluck", "white elm",
  "fir tree", "birch tree", "pone", "dagwood", "mople")
 messy_trees[1:9,2] = c(34,12,43,32,65,23,12,45,35)
 clean_trees=data.frame()
 clean_trees[1:9,1] = c("oak", "willow", "hemlock", "elm", "fir",
 "birch", "pine", "dogwood", "maple")
 clean_trees[1:9,2] = "y"
 cat_join(messy_trees,clean_trees,by="V1",method="jaccard")
 }
</code></pre>

<hr>
<h2 id='cat_match'>cat_match</h2><span id='topic+cat_match'></span>

<h3>Description</h3>

<p><code>cat_match()</code> matches the contents of a messy vector with
the closest match in a clean vector. The closest match can be found
using a variety of different string distance measurement options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_match(
  messy_v,
  clean_v,
  return_dists = TRUE,
  return_lists = NA,
  pick_lists = FALSE,
  threshold = NA,
  method = "jw",
  q = 1,
  p = 0,
  bt = 0,
  useBytes = FALSE,
  weight = c(d = 1, i = 1, t = 1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cat_match_+3A_messy_v">messy_v</code></td>
<td>
<p>The messy string vector that will be restructured. This can come in the form
of a column of a dataframe or a lone vector.</p>
</td></tr>
<tr><td><code id="cat_match_+3A_clean_v">clean_v</code></td>
<td>
<p>The clean string vector that will be referenced to perform the restructing.
Again, this argument can be a dataframe column or vector.</p>
</td></tr>
<tr><td><code id="cat_match_+3A_return_dists">return_dists</code></td>
<td>
<p>If set to TRUE the distance between the matched strings will
be returned as a third column in the output dataframe, Default: TRUE</p>
</td></tr>
<tr><td><code id="cat_match_+3A_return_lists">return_lists</code></td>
<td>
<p>Return list of top X matches, Default: NA</p>
</td></tr>
<tr><td><code id="cat_match_+3A_pick_lists">pick_lists</code></td>
<td>
<p>Set to TRUE to manually choose matches, Default: F</p>
</td></tr>
<tr><td><code id="cat_match_+3A_threshold">threshold</code></td>
<td>
<p>The maximum distance that will form a match. If this argument
is specified, any element in the messy vector that has no match closer than
the threshold distance will be replaced with NA. Default: NA</p>
</td></tr>
<tr><td><code id="cat_match_+3A_method">method</code></td>
<td>
<p>The type of string distance calculation to use. Possible methods
are : osa, lv, dl, hamming, lcs, qgram, cosine, jaccard, jw, and soundex.
See package stringdist for more information. Default: 'jw'</p>
</td></tr>
<tr><td><code id="cat_match_+3A_q">q</code></td>
<td>
<p>Size of the q-gram used in string distance calculation. Default: 1</p>
</td></tr>
<tr><td><code id="cat_match_+3A_p">p</code></td>
<td>
<p>Only used with method &quot;jw&quot;, the Jaro-Winkler penatly size. Default: 0</p>
</td></tr>
<tr><td><code id="cat_match_+3A_bt">bt</code></td>
<td>
<p>Only used with method &quot;jw&quot; with p &gt; 0, Winkler's boost threshold. Default: 0</p>
</td></tr>
<tr><td><code id="cat_match_+3A_usebytes">useBytes</code></td>
<td>
<p>Whether or not to perform byte-wise comparison. Default: FALSE</p>
</td></tr>
<tr><td><code id="cat_match_+3A_weight">weight</code></td>
<td>
<p>Only used with methods &quot;osa&quot; or &quot;dl&quot;, a vector representing the
penalty for deletion, insertion, substitution, and transposition,
in that order. Default: c(d = 1, i = 1, t = 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When dealing with messy categorical string data, string distance
matching can be an easy and efficient cleaning tool. A variety of string
distance calculation algorithms have been developed for different types of data,
and these algorithms can be used to detect and remedy problems with categorical
string data.
</p>
<p>By providing a correctly spelled and specified vector of categories to be compared
against a vector of messy strings, a cleaned vector of categories can be generated
by finding the correctly specificed string most similar to a messy string. This
method works particularly well for messy user-inputted data that often suffers
from transposition or misspelling errors.
</p>
<p><code>cat_match()</code> is meant as an exploratory tool to discover how the elements
of two vectors will match using string distance measures, and has added functionality
to solve issues by hand and create a dataframe that can be used to create custom
matches between the clean and messy vectors.
</p>


<h3>Value</h3>

<p>Returns a dataframe with each unique value in the bad vector and it's
closest match in the good vector. If return_dists is TRUE the distances between
the matches are added as a column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
 messy_trees = c("red oak", "williw", "hemluck", "white elm",
 "fir tree", "birch tree", "pone", "dagwood", "mople")
 clean_trees = c("oak", "willow", "hemlock", "elm", "fir", "birch", "pine", "dogwood", "maple")
 matched_trees = cat_match(messy_trees, clean_trees)
 }
</code></pre>

<hr>
<h2 id='cat_replace'>cat_replace</h2><span id='topic+cat_replace'></span>

<h3>Description</h3>

<p><code>cat_replace()</code> replaces the contents of a messy vector with
the closest match in a clean vector. The closest match can be found
using a variety of different string distance measurement options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_replace(
  messy_v,
  clean_v,
  threshold = NA,
  method = "jw",
  q = 1,
  p = 0,
  bt = 0,
  useBytes = FALSE,
  weight = c(d = 1, i = 1, t = 1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cat_replace_+3A_messy_v">messy_v</code></td>
<td>
<p>The messy string vector that will be restructured. This can come in the form
of a column of a dataframe or a lone vector.</p>
</td></tr>
<tr><td><code id="cat_replace_+3A_clean_v">clean_v</code></td>
<td>
<p>The clean string vector that will be referenced to perform the restructing.
Again, this argument can be a dataframe column or vector.</p>
</td></tr>
<tr><td><code id="cat_replace_+3A_threshold">threshold</code></td>
<td>
<p>The maximum distance that will form a match. If this argument
is specified, any element in the messy vector that has no match closer than
the threshold distance will be replaced with NA. Default: NA</p>
</td></tr>
<tr><td><code id="cat_replace_+3A_method">method</code></td>
<td>
<p>The type of string distance calculation to use. Possible methods
are : osa, lv, dl, hamming, lcs, qgram, cosine, jaccard, jw, and soundex.
See package stringdist for more information. Default: 'jw'</p>
</td></tr>
<tr><td><code id="cat_replace_+3A_q">q</code></td>
<td>
<p>Size of the q-gram used in string distance calculation. Default: 1</p>
</td></tr>
<tr><td><code id="cat_replace_+3A_p">p</code></td>
<td>
<p>Only used with method &quot;jw&quot;, the Jaro-Winkler penatly size. Default: 0</p>
</td></tr>
<tr><td><code id="cat_replace_+3A_bt">bt</code></td>
<td>
<p>Only used with method &quot;jw&quot; with p &gt; 0, Winkler's boost threshold. Default: 0</p>
</td></tr>
<tr><td><code id="cat_replace_+3A_usebytes">useBytes</code></td>
<td>
<p>Whether or not to perform byte-wise comparison. Default: FALSE</p>
</td></tr>
<tr><td><code id="cat_replace_+3A_weight">weight</code></td>
<td>
<p>Only used with methods &quot;osa&quot; or &quot;dl&quot;, a vector representing the
penalty for deletion, insertion, substitution, and transposition,
in that order. Default: c(d = 1, i = 1, t = 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When dealing with messy categorical string data, string distance
matching can be an easy and efficient cleaning tool. A variety of string
distance calculation algorithms have been developed for different types of data,
and these algorithms can be used to detect and remedy problems with categorical
string data.
</p>
<p>By providing a correctly spelled and specified vector of categories to be compared
against a vector of messy strings, a cleaned vector of categories can be generated
by finding the correctly specificed string most similar to a messy string. This
method works particularly well for messy user-inputted data that often suffers
from transposition or misspelling errors.
</p>
<p><code>cat_replace()</code> replaces the elements of the messy vector with the closest matching
element from the clean vector.
</p>


<h3>Value</h3>

<p>cat_replace() returns a cleaned version of the bad vector, with each
element replaced by the most similar element of the good vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
 messy_trees = c("red oak", "williw", "hemluck", "white elm", "fir tree",
  "birch tree", "pone", "dagwood", "mople")
 clean_trees = c("oak", "willow", "hemlock", "elm", "fir", "birch", "pine", "dogwood", "maple")
 cleaned_trees = cat_replace(messy_trees, clean_trees)

 }
</code></pre>

<hr>
<h2 id='clean_caterpillars'>clean_caterpillars</h2><span id='topic+clean_caterpillars'></span>

<h3>Description</h3>

<p>Dataframe with caterpillar counts from three summers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_caterpillars
</code></pre>


<h3>Format</h3>

<p>A data frame with 74 rows and 3 variables:
</p>

<dl>
<dt><code>species</code></dt><dd><p>character Full latin names of 29 caterpillar species.</p>
</dd>
<dt><code>count</code></dt><dd><p>integer Randomly generated fake counts of the caterpillars.</p>
</dd>
<dt><code>year</code></dt><dd><p>double Year of caterpillar observations.</p>
</dd>
</dl>



<h3>Details</h3>

<p>An example dataset with clean caterpillar species names.
</p>

<hr>
<h2 id='clean_names.df'>clean_names.df</h2><span id='topic+clean_names.df'></span>

<h3>Description</h3>

<p>Data set of clean names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_names.df
</code></pre>


<h3>Format</h3>

<p>A data frame with 20 rows and 2 variables:
</p>

<dl>
<dt><code>first</code></dt><dd><p>character Clean first names</p>
</dd>
<dt><code>last</code></dt><dd><p>character Clean last names</p>
</dd>
</dl>



<h3>Details</h3>

<p>An example data that can be used in testing messy.cats functions
</p>

<hr>
<h2 id='country_match'>country_match</h2><span id='topic+country_match'></span>

<h3>Description</h3>

<p>A wrapper function for <code>cat_match()</code> that only requires an inputted
vector of messy country names. <code>country_match()</code> uses a built in clean list of
country names <code>country.names</code> as the reference clean vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>country_match(messy_countries, threshold = NA, p = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="country_match_+3A_messy_countries">messy_countries</code></td>
<td>
<p>Vector containing the messy country names that will be replaced
by the closest match from <code>country.names</code></p>
</td></tr>
<tr><td><code id="country_match_+3A_threshold">threshold</code></td>
<td>
<p>The maximum distance that will form a match. If this argument
is specified, any element in the messy vector that has no match closer than
the threshold distance will be replaced with NA. Default: NA</p>
</td></tr>
<tr><td><code id="country_match_+3A_p">p</code></td>
<td>
<p>Only used with method &quot;jw&quot;, the Jaro-Winkler penatly size. Default: 0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Country names are often misspelled or abbreviated in datasets, especially datasets that have been
manually digitized or created. <code>country_match()</code> is a warpper function of <code>cat_match()</code> that quickly solves
this common issue of mispellings or different formats of country names across datasets. This wrapper
function uses a built in clean list of country names <code>country.names</code> as the reference clean vector and
matches your inputted messy vector of names to their nearest country in <code>country.names</code>.
</p>


<h3>Value</h3>

<p><code>country_match()</code> returns a cleaned version of the bad vector, with each
element replaced by the most similar element of the good vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
 #EXAMPLE1
 lst &lt;- c("Conagoa", "Blearaus", "Venzesual", "Uruagsya", "England")
 matched &lt;- country_match(lst)
 }
</code></pre>

<hr>
<h2 id='country_replace'>country_replace</h2><span id='topic+country_replace'></span>

<h3>Description</h3>

<p>A wrapper function for <code>cat_replace()</code> that only requires an inputted
vector of messy countries. <code>country_replace()</code> uses a built in clean list of
country names <code>country.names</code> as the reference clean vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>country_replace(messy_countries, threshold = NA, p = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="country_replace_+3A_messy_countries">messy_countries</code></td>
<td>
<p>Vector containing the messy country names that will be replaced
by the closest match from <code>country.names</code></p>
</td></tr>
<tr><td><code id="country_replace_+3A_threshold">threshold</code></td>
<td>
<p>The maximum distance that will form a match. If this argument
is specified, any element in the messy vector that has no match closer than
the threshold distance will be replaced with NA. Default: NA</p>
</td></tr>
<tr><td><code id="country_replace_+3A_p">p</code></td>
<td>
<p>Only used with method &quot;jw&quot;, the Jaro-Winkler penatly size. Default: 0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Country names are often misspelled or abbreviated in datasets, especially datasets that have been
manually digitized or created. <code>country_replace()</code> is a warpper function of <code>cat_replace()</code> that quickly solves
this common issue of mispellings or different formats of country names across datasets. This wrapper
function uses a built in clean list of country names <code>country.names</code> as the reference clean vector and
replaces your inputted messy vector of names to their nearest match in <code>country.names</code>.
</p>


<h3>Value</h3>

<p><code>country_replace()</code> returns a cleaned version of the bad vector, with each
element replaced by the most similar element of the good vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
 #EXAMPLE1
 lst &lt;- c("Conagoa", "Blearaus", "Venzesual", "Uruagsya", "England")
 fixed &lt;- country_replace(lst)
 }
</code></pre>

<hr>
<h2 id='country.names'>country.names</h2><span id='topic+country.names'></span>

<h3>Description</h3>

<p>Dataframe with country names as only variable, contains many popular and official names for countries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>country.names
</code></pre>


<h3>Format</h3>

<p>A data frame with 203 rows and 1 variables:
</p>

<dl>
<dt><code>name</code></dt><dd><p>character Names of countries</p>
</dd>
</dl>



<h3>Details</h3>

<p>This dataframe contains a list of clean country names with many popular and official names for countries.
</p>

<hr>
<h2 id='fix_typos'>fix_typos</h2><span id='topic+fix_typos'></span>

<h3>Description</h3>

<p>This function is meant to allow users to fix typos in strings
that are not normally found in dictionaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_typos(typo_v, thr, occ_ratio)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fix_typos_+3A_typo_v">typo_v</code></td>
<td>
<p>vector of strings that will have its typos cleaned</p>
</td></tr>
<tr><td><code id="fix_typos_+3A_thr">thr</code></td>
<td>
<p>the string distance maximum used to determine typos. This argument
is specified as the percentage of a typo that should at most be expected to be
insertions, additons, deletions, and transpositions.</p>
</td></tr>
<tr><td><code id="fix_typos_+3A_occ_ratio">occ_ratio</code></td>
<td>
<p>the minimum ratio of correctly spelled words to their typo.
This argument helps to weed out words that are similar but valid. For example
commonly occurring valid names such as Adam and Amy will not be recognized as typos
even though they are similar because they both appear often. Typos are recognized by
their similarity in addition to their infrequent occurrence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are great tools like the
hunspell package that allow users to fix typos for words found in dictionaries,
but these functions struggle to work for strings like proper nouns and other
specific terminology not usually found in common dictionaries. This function
uses the text being cleaned as a dictionary. It finds probable correctly spelled
words based on their high occurrence and finds typos based on their low occurence.
This is based on the theory that typos will appear as infrequently used words due
no one using them on purpose, and they will be a short string distance from commonly
occurring correctly spelled words.
</p>


<h3>Value</h3>

<p>reformatted vector with typos replaced with correctly spelled words
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
 #EXAMPLE1
 }
</code></pre>

<hr>
<h2 id='fuzzy_rbind'>fuzzy_rbind</h2><span id='topic+fuzzy_rbind'></span>

<h3>Description</h3>

<p>fuzzy_rbind() binds dataframes based on columns with slightly different names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuzzy_rbind(
  df1,
  df2,
  threshold,
  method = "jw",
  q = 1,
  p = 0,
  bt = 0,
  useBytes = FALSE,
  weight = c(d = 1, i = 1, t = 1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fuzzy_rbind_+3A_df1">df1</code></td>
<td>
<p>The first dataframe to be bound.</p>
</td></tr>
<tr><td><code id="fuzzy_rbind_+3A_df2">df2</code></td>
<td>
<p>The second dataframe to be bound.</p>
</td></tr>
<tr><td><code id="fuzzy_rbind_+3A_threshold">threshold</code></td>
<td>
<p>The maximum string distance between column names, if the distance
between columns is greater than this threshold the columns will not be bound.</p>
</td></tr>
<tr><td><code id="fuzzy_rbind_+3A_method">method</code></td>
<td>
<p>The type of string distance calculation to use. Possible methods
are : osa, lv, dl, hamming, lcs, qgram, cosine, jaccard, jw, and soundex.
See package stringdist for more information. Default: 'jw', Default: 'jw'</p>
</td></tr>
<tr><td><code id="fuzzy_rbind_+3A_q">q</code></td>
<td>
<p>Size of the q-gram used in string distance calculation. Default: 1</p>
</td></tr>
<tr><td><code id="fuzzy_rbind_+3A_p">p</code></td>
<td>
<p>Only used with method &quot;jw&quot;, the Jaro-Winkler penatly size. Default: 0</p>
</td></tr>
<tr><td><code id="fuzzy_rbind_+3A_bt">bt</code></td>
<td>
<p>Only used with method &quot;jw&quot; with p &gt; 0, Winkler's boost threshold. Default: 0</p>
</td></tr>
<tr><td><code id="fuzzy_rbind_+3A_usebytes">useBytes</code></td>
<td>
<p>Whether or not to perform byte-wise comparison. Default: FALSE</p>
</td></tr>
<tr><td><code id="fuzzy_rbind_+3A_weight">weight</code></td>
<td>
<p>Only used with methods &quot;osa&quot; or &quot;dl&quot;, a vector representing the
penalty for deletion, insertion, substitution, and transposition,
in that order. Default: c(d = 1, i = 1, t = 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using datasets often times column names are slightly different, and <code>fuzzy_rbind()</code> helps
to bind dataframes using fuzzy matching of the column names.
</p>


<h3>Value</h3>

<p>fuzzy_rbind() returns a dataframe that has bound the two inputted dataframes based on
the closest matching columns, column names from dataframe 1 are preserved.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
 mtcars_colnames_messy = mtcars
 colnames(mtcars_colnames_messy)[1:5] = paste0(colnames(mtcars)[1:5], "_17")
 colnames(mtcars_colnames_messy)[6:11] = paste0(colnames(mtcars)[6:11], "_2017")
 x = fuzzy_rbind(mtcars, mtcars_colnames_messy, .5)
 x = fuzzy_rbind(mtcars, mtcars_colnames_messy, .2)
 }
</code></pre>

<hr>
<h2 id='messy_caterpillars'>messy_caterpillars</h2><span id='topic+messy_caterpillars'></span>

<h3>Description</h3>

<p>DATASET_DESCRIPTION
</p>


<h3>Usage</h3>

<pre><code class='language-R'>messy_caterpillars
</code></pre>


<h3>Format</h3>

<p>A data frame with 39 rows and 3 variables:
</p>

<dl>
<dt><code>CaterpillarSpecies</code></dt><dd><p>character Full latin names of 39 caterpillar
species with spelling and formatting errors.</p>
</dd>
<dt><code>Avg Weight (mg)</code></dt><dd><p>double Randomly generated fake weight data for each caterpillar species.</p>
</dd>
<dt><code>Avg Length (cm)</code></dt><dd><p>double Randomly generated fake length data for each caterpillar species.</p>
</dd>
</dl>



<h3>Details</h3>

<p>An example dataset with messy caterpillar species names.
</p>

<hr>
<h2 id='messy_names.df'>messy_names.df</h2><span id='topic+messy_names.df'></span>

<h3>Description</h3>

<p>Data set of messy names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>messy_names.df
</code></pre>


<h3>Format</h3>

<p>A data frame with 80 rows and 2 variables:
</p>

<dl>
<dt><code>first</code></dt><dd><p>character Messy first names</p>
</dd>
<dt><code>last</code></dt><dd><p>character MEssy last names</p>
</dd>
</dl>



<h3>Details</h3>

<p>An example data set of messy names that can be used in testing messy.cats functions.
</p>

<hr>
<h2 id='messy_states1'>messy_states1</h2><span id='topic+messy_states1'></span>

<h3>Description</h3>

<p>US State names with 1 character randomly changed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>messy_states1
</code></pre>


<h3>Format</h3>

<p>A data frame with 50 rows and 1 variables:
</p>

<dl>
<dt><code>messy_states1</code></dt><dd><p>character All 50 US states with 1 randomly changed character.</p>
</dd>
</dl>



<h3>Details</h3>

<p>An example dataset with mispelled US state names. The names have had 1 character randomly changed.
</p>

<hr>
<h2 id='messy_states2'>messy_states2</h2><span id='topic+messy_states2'></span>

<h3>Description</h3>

<p>US State names with 2 characters randomly changed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>messy_states2
</code></pre>


<h3>Format</h3>

<p>A data frame with 50 rows and 1 variables:
</p>

<dl>
<dt><code>messy_states2</code></dt><dd><p>character All 50 US states with 2 randomly changed characters.</p>
</dd>
</dl>



<h3>Details</h3>

<p>An example dataset with mispelled US state names. The names have had 2 characters randomly changed.
</p>

<hr>
<h2 id='picked_list'>picked_list</h2><span id='topic+picked_list'></span>

<h3>Description</h3>

<p>Handpicked matches from the datasets in intro.rmd.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>picked_list
</code></pre>


<h3>Format</h3>

<p>A data frame with 15 rows and 3 variables:
</p>

<dl>
<dt><code>bad</code></dt><dd><p>character column of bad car names</p>
</dd>
<dt><code>match</code></dt><dd><p>character column of good car names</p>
</dd>
<dt><code>dists</code></dt><dd><p>double string distance between the good and bad car names</p>
</dd>
</dl>



<h3>Details</h3>

<p>An example dataset of matched car names.
</p>

<hr>
<h2 id='select_metric'>select_metric</h2><span id='topic+select_metric'></span>

<h3>Description</h3>

<p>Uses heuristic algorithm to suggest a stringdist metric from among hamming, lv, osa, dl, lcs, jw
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_metric(messy_v, clean_v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_metric_+3A_messy_v">messy_v</code></td>
<td>
<p>a messy vector of strings</p>
</td></tr>
<tr><td><code id="select_metric_+3A_clean_v">clean_v</code></td>
<td>
<p>a vector of strings for messy_v to be matched against</p>
</td></tr>
</table>


<h3>Details</h3>

<p>for each metric, measures certainty via the difference between the best matches for each word and the average of all matches for each word
</p>


<h3>Value</h3>

<p>a string representing the suggested stringdist metric
</p>


<h3>See Also</h3>

<p><code><a href="stringdist.html#topic+stringdist">stringdist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>select_metric(c("aapple", "bamana", "clemtidne"), c("apple", "banana", "clementine"))
</code></pre>

<hr>
<h2 id='state_match'>state_match</h2><span id='topic+state_match'></span>

<h3>Description</h3>

<p>A wrapper function for <code>cat_match()</code>hat only requires an inputted
vector of messy states. <code>state_match()</code> uses a built in clean list of
state names <code>state.name</code> as the reference clean vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>state_match(messy_states, threshold = NA, p = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="state_match_+3A_messy_states">messy_states</code></td>
<td>
<p>Vector containing the messy state names that will be replaced
by the closest match from <code>state.name</code></p>
</td></tr>
<tr><td><code id="state_match_+3A_threshold">threshold</code></td>
<td>
<p>The maximum distance that will form a match. If this argument
is specified, any element in the messy vector that has no match closer than
the threshold distance will be replaced with NA. Default: NA</p>
</td></tr>
<tr><td><code id="state_match_+3A_p">p</code></td>
<td>
<p>Only used with method &quot;jw&quot;, the Jaro-Winkler penatly size. Default: 0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>State names are often misspelled or abbreviated in datasets, especially datasets that have been
manually digitized or created. <code>state_match()</code> is a warpper function of <code>cat_match()</code> that quickly solves
this common issue of mispellings or different formats of country names across datasets. This wrapper
function uses a built in clean list of country names <code>state.name</code> as the reference clean vector and
matches your inputted messy vector of names to their nearest state in <code>state.name</code>.
</p>


<h3>Value</h3>

<p><code>state_match()</code> returns a cleaned version of the bad vector, with each
element replaced by the most similar element of the good vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
 #EXAMPLE1
 lst &lt;- c("Indianaa", "Wisvconsin", "aLaska", "NewJersey", "Claifoarni")
 matched &lt;- state_match(lst)
 }
</code></pre>

<hr>
<h2 id='state_replace'>state_replace</h2><span id='topic+state_replace'></span>

<h3>Description</h3>

<p>A wrapper function for <code>cat_replace()</code> that only requires an inputted
vector of messy US state names. <code>state_replace()</code> uses the built-in character
vector <code>state.name</code> as the reference clean vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>state_replace(messy_states, threshold = NA, p = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="state_replace_+3A_messy_states">messy_states</code></td>
<td>
<p>Vector containing the messy state names that will be replaced
by the closest match from <code>state.name</code></p>
</td></tr>
<tr><td><code id="state_replace_+3A_threshold">threshold</code></td>
<td>
<p>The maximum distance that will form a match. If this argument
is specified, any element in the messy vector that has no match closer than
the threshold distance will be replaced with NA. Default: NA</p>
</td></tr>
<tr><td><code id="state_replace_+3A_p">p</code></td>
<td>
<p>Only used with method &quot;jw&quot;, the Jaro-Winkler penatly size. Default: 0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>State names are often misspelled or abbreviated in datasets, especially datasets that have been
manually digitized or created. <code>state_replace()</code> is a warpper function of <code>cat_replace()</code> that quickly solves
this common issue of mispellings or different formats of state names across datasets. This wrapper
function uses a built in clean list of country names <code>state.name</code> as the reference clean vector and
replaces your inputted messy vector of names to their nearest match in <code>state.name</code>.
</p>


<h3>Value</h3>

<p><code>state_replace()</code> returns a cleaned version of the bad vector, with each
element replaced by the most similar element of the good vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
 #EXAMPLE1
 lst &lt;- c("Indianaa", "Wisvconsin", "aLaska", "NewJersey", "Claifoarni")
 fixed &lt;- state_replace(lst)
 }
</code></pre>

<hr>
<h2 id='state.name'>state.name</h2><span id='topic+state.name'></span>

<h3>Description</h3>

<p>Testing data set of state names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>state.name
</code></pre>


<h3>Format</h3>

<p>A data frame with 50 rows and 1 variables:
</p>

<dl>
<dt><code>states</code></dt><dd><p>character State names</p>
</dd>
</dl>



<h3>Details</h3>

<p>Testing data set of state names
</p>

<hr>
<h2 id='typos'>typos</h2><span id='topic+typos'></span>

<h3>Description</h3>

<p>Data set of words, some correctly spelled, some typos, with their occurrence in text
</p>


<h3>Usage</h3>

<pre><code class='language-R'>typos
</code></pre>


<h3>Format</h3>

<p>A data frame with 27 rows and 2 variables:
</p>

<dl>
<dt><code>occurrence</code></dt><dd><p>double number of times word appears in text</p>
</dd>
<dt><code>species</code></dt><dd><p>character words in text</p>
</dd>
</dl>



<h3>Details</h3>

<p>An example data set that can be used in testing fix_typos().
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
