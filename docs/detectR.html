<!DOCTYPE html><html><head><title>Help for package detectR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {detectR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bandpass'><p>Optional bandpass filtering using the Butterworth filter.</p></a></li>
<li><a href='#blocklength.andrew'><p>Block length formula by Andrews</p></a></li>
<li><a href='#changesim'><p>Changepoint Example Data</p></a></li>
<li><a href='#detectBinary'><p>Change point detection using PCA and binary segmentation</p></a></li>
<li><a href='#detectGlasso'><p>Change point detection using Graphical lasso as in Cribben et al. (2012)</p></a></li>
<li><a href='#detectMaxChange'><p>Change point detection using max-type statistic as in Jeong et. al (2016)</p></a></li>
<li><a href='#detectSliding'><p>Change point detection using PCA and sliding method</p></a></li>
<li><a href='#global'><p>Global Variables and functions</p></a></li>
<li><a href='#LRV.bartlett'><p>(multivariate) Bartlett long-run variance calculation</p></a></li>
<li><a href='#networkpca'><p>If model is indicated, reduce data to components.</p></a></li>
<li><a href='#preproc'><p>Optional preprocessing step for regressing out noise variables.</p></a></li>
<li><a href='#preprocess'><p>Data preparation for changepoint detection using functions in this package..</p></a></li>
<li><a href='#testGlasso'><p>Test for for the equality of connectivity based on the Graphical lasso estimation.</p></a></li>
<li><a href='#testMax'><p>Max-type test for for the equality of connectivity</p></a></li>
<li><a href='#testPCA'><p>PCA-based test for the equality of connectivity</p></a></li>
<li><a href='#testsim'><p>Test Example Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Change Point Detection</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Changryong Baek &lt;crbaek@skku.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Time series analysis of network connectivity. Detects and visualizes change points between networks.
    Methods included in the package are discussed in depth in Baek, C., Gates, K. M., Leinwand, B., Pipiras, V. (2021)
    "Two sample tests for high-dimensional auto-covariances" &lt;<a href="https://doi.org/10.1016%2Fj.csda.2020.107067">doi:10.1016/j.csda.2020.107067</a>&gt;
    and Baek, C., Gampe, M., Leinwand B., Lindquist K., Hopfinger J. and Gates K. (2023)
    “Detecting functional connectivity changes in fMRI data” &lt;<a href="https://doi.org/10.1007%2Fs11336-023-09908-7">doi:10.1007/s11336-023-09908-7</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td>Unlimited</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>signal, lavaan, doParallel, glasso, LogConcDEAD, foreach,
parallel</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/crbaek/detectR">https://github.com/crbaek/detectR</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-07 06:19:59 UTC; crbaek</td>
</tr>
<tr>
<td>Author:</td>
<td>Changryong Baek [aut, cre],
  Mattew Gampe [aut],
  Kathleen M. Gates [aut],
  Seok-Oh Jeong [aut],
  Vladas Pipiras [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-08 20:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bandpass'>Optional bandpass filtering using the Butterworth filter.</h2><span id='topic+bandpass'></span>

<h3>Description</h3>

<p>Id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bandpass(data, butterfreq)
</code></pre>

<hr>
<h2 id='blocklength.andrew'>Block length formula by Andrews</h2><span id='topic+blocklength.andrew'></span>

<h3>Description</h3>

<p>Block length formula by Andrews
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blocklength.andrew(data)
</code></pre>

<hr>
<h2 id='changesim'>Changepoint Example Data</h2><span id='topic+changesim'></span>

<h3>Description</h3>

<p>This dataset contains a simulated multivariate time series with two
changepoints at time point 150 and 300. The dimension of the data is T=450 and p=20.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>changesim
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 450 rows and 20 columns.
</p>

<hr>
<h2 id='detectBinary'>Change point detection using PCA and binary segmentation</h2><span id='topic+detectBinary'></span>

<h3>Description</h3>

<p>This function uses PCA-based method to find breaks. Simultaneous breaks are found from binary segmentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detectBinary(
  Y,
  Del,
  L,
  q = "fixed",
  alpha = 0.05,
  nboot = 199,
  n.cl,
  bsize = "log",
  bootTF = TRUE,
  scaleTF = TRUE,
  diagTF = TRUE,
  plotTF = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detectBinary_+3A_y">Y</code></td>
<td>
<p>data: Y = length*dim</p>
</td></tr>
<tr><td><code id="detectBinary_+3A_del">Del</code></td>
<td>
<p>Delta away from the boundary restriction</p>
</td></tr>
<tr><td><code id="detectBinary_+3A_l">L</code></td>
<td>
<p>the number of factors</p>
</td></tr>
<tr><td><code id="detectBinary_+3A_q">q</code></td>
<td>
<p>methods in calculating long-run variance of the test statistic. Default is &quot;fixed&quot; = length^(1/3). Adaptive selection method is also available via &quot;andrews&quot;, or user specify the length</p>
</td></tr>
<tr><td><code id="detectBinary_+3A_alpha">alpha</code></td>
<td>
<p>significance level of the test</p>
</td></tr>
<tr><td><code id="detectBinary_+3A_nboot">nboot</code></td>
<td>
<p>the number of bootstrap sample for p-value. Default is 199.</p>
</td></tr>
<tr><td><code id="detectBinary_+3A_n.cl">n.cl</code></td>
<td>
<p>number of cores in parallel computing. The default is (machine cores - 1)</p>
</td></tr>
<tr><td><code id="detectBinary_+3A_bsize">bsize</code></td>
<td>
<p>block size for the Block Wild Bootstrapping. Default is log(length),  &quot;sqrt&quot; uses sqrt(length), &quot;adaptive&quot; determines block size using data dependent selection of Andrews</p>
</td></tr>
<tr><td><code id="detectBinary_+3A_boottf">bootTF</code></td>
<td>
<p>determine whether the threshold is calculated from bootstrap or asymptotic</p>
</td></tr>
<tr><td><code id="detectBinary_+3A_scaletf">scaleTF</code></td>
<td>
<p>scale the variance into 1</p>
</td></tr>
<tr><td><code id="detectBinary_+3A_diagtf">diagTF</code></td>
<td>
<p>include diagonal term of covariance matrix or not</p>
</td></tr>
<tr><td><code id="detectBinary_+3A_plottf">plotTF</code></td>
<td>
<p>Draw plot to see test statistic and threshold</p>
</td></tr>
</table>


<h3>Value</h3>

<p><strong>tstathist</strong> The complete history of test statistics.
</p>
<p><strong>Brhist</strong> The sequence of breakpoints found from binary splitting
</p>
<p><strong>L</strong> The number of factors used in the procedure
</p>
<p><strong>q</strong> The estimated vectorized autocovariance on each regime.
</p>
<p><strong>crit</strong> The critical value to identify change point
</p>
<p><strong>bsize</strong> The block size of the bootstrap
</p>
<p><strong>diagTF</strong> If TRUE, the diagonal entry of covariance matrix is used in detecting connectivity changes.
</p>
<p><strong>bootTF</strong> If TRUE, bootstrap is used to find critical value
</p>
<p><strong>scaleTF</strong> If TRUE, the multivariate signal is studentized to have zero mean and unit variance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out3= detectBinary(changesim, L=2, n.cl=1)
</code></pre>

<hr>
<h2 id='detectGlasso'>Change point detection using Graphical lasso as in Cribben et al. (2012)</h2><span id='topic+detectGlasso'></span>

<h3>Description</h3>

<p>This function implements the Dynamic Connectivity Regression (DCR) algorithm proposed by Cribben el al. (2012) to locate changepoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detectGlasso(
  Y,
  Del,
  p,
  lambda = "bic",
  nboot = 100,
  n.cl,
  bound = c(0.001, 1),
  gridTF = FALSE,
  plotTF = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detectGlasso_+3A_y">Y</code></td>
<td>
<p>Input data of dimension length*dim (T times d)</p>
</td></tr>
<tr><td><code id="detectGlasso_+3A_del">Del</code></td>
<td>
<p>Delta away from the boundary restriction</p>
</td></tr>
<tr><td><code id="detectGlasso_+3A_p">p</code></td>
<td>
<p>Gep(p) distribution controls the size of stationary bootstrap. The mean block length is 1/p</p>
</td></tr>
<tr><td><code id="detectGlasso_+3A_lambda">lambda</code></td>
<td>
<p>two selections possible for optimal parameter of lambda. &quot;bic&quot; finds lambda from bic criteria, or user can directly input the penalty value</p>
</td></tr>
<tr><td><code id="detectGlasso_+3A_nboot">nboot</code></td>
<td>
<p>the number of bootstrap sample for p-value. Default is 100.</p>
</td></tr>
<tr><td><code id="detectGlasso_+3A_n.cl">n.cl</code></td>
<td>
<p>number of cores in parallel computing. The default is (machine cores - 1)</p>
</td></tr>
<tr><td><code id="detectGlasso_+3A_bound">bound</code></td>
<td>
<p>bound of bic search in &quot;bic&quot; rule. Default is (.001, 1)</p>
</td></tr>
<tr><td><code id="detectGlasso_+3A_gridtf">gridTF</code></td>
<td>
<p>minimum bic is found by grid search. Default is FALSE</p>
</td></tr>
<tr><td><code id="detectGlasso_+3A_plottf">plotTF</code></td>
<td>
<p>Draw plot to see test statistic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with component
</p>
<p><strong>br</strong> The estimated breakpoints including boundary (0, T)
</p>
<p><strong>brhist</strong> The sequence of breakpoints found from binary splitting
</p>
<p><strong>diffhist</strong> The history of BIC reduction on each step
</p>
<p><strong>W</strong> The estimated vectorized autocovariance on each regime.
</p>
<p><strong>WI</strong> The estimated vectorized precision matrix on each regime.
</p>
<p><strong>lambda</strong> The penalty parameter estimated on each regime.
</p>
<p><strong>pvalhist</strong> The empirical p-values on each binary splitting.
</p>
<p><strong>fitzero</strong> Detailed output at first stage. Useful in producing plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out1= detectGlasso(changesim, p=.2, n.cl=1)
</code></pre>

<hr>
<h2 id='detectMaxChange'>Change point detection using max-type statistic as in Jeong et. al (2016)</h2><span id='topic+detectMaxChange'></span>

<h3>Description</h3>

<p>Change point detection using max-type statistic as in Jeong et. al (2016)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detectMaxChange(
  Y,
  m = c(30, 40, 50),
  margin = 30,
  thre.localfdr = 0.2,
  design.mat = NULL,
  plotTF = TRUE,
  n.cl
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detectMaxChange_+3A_y">Y</code></td>
<td>
<p>Input data matrix</p>
</td></tr>
<tr><td><code id="detectMaxChange_+3A_m">m</code></td>
<td>
<p>window sizes</p>
</td></tr>
<tr><td><code id="detectMaxChange_+3A_margin">margin</code></td>
<td>
<p>margin</p>
</td></tr>
<tr><td><code id="detectMaxChange_+3A_thre.localfdr">thre.localfdr</code></td>
<td>
<p>threshold for local fdr</p>
</td></tr>
<tr><td><code id="detectMaxChange_+3A_design.mat">design.mat</code></td>
<td>
<p>design matrix for analyzing task data</p>
</td></tr>
<tr><td><code id="detectMaxChange_+3A_plottf">plotTF</code></td>
<td>
<p>Draw plot to see test statistic and threshold</p>
</td></tr>
<tr><td><code id="detectMaxChange_+3A_n.cl">n.cl</code></td>
<td>
<p>number of clusters for parallel computing</p>
</td></tr>
</table>


<h3>Value</h3>

<p><strong>CLX</strong> Test statistic corresponding to window size arranged in column
</p>
<p><strong>CLXLocalFDR</strong> The Local FDR calculated for each time point
</p>
<p><strong>br</strong> The final estimated break points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out2= detectMaxChange(changesim, m=c(30, 35, 40, 45, 50), n.cl=1)
</code></pre>

<hr>
<h2 id='detectSliding'>Change point detection using PCA and sliding method</h2><span id='topic+detectSliding'></span>

<h3>Description</h3>

<p>Change point detection using PCA and sliding method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detectSliding(
  Y,
  wd = 40,
  L,
  Del,
  q = "fixed",
  alpha = 0.05,
  nboot = 199,
  n.cl,
  bsize = "log",
  bootTF = TRUE,
  scaleTF = TRUE,
  diagTF = TRUE,
  plotTF = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detectSliding_+3A_y">Y</code></td>
<td>
<p>data: Y = length*dim</p>
</td></tr>
<tr><td><code id="detectSliding_+3A_wd">wd</code></td>
<td>
<p>window size for sliding averages</p>
</td></tr>
<tr><td><code id="detectSliding_+3A_l">L</code></td>
<td>
<p>the number of factors</p>
</td></tr>
<tr><td><code id="detectSliding_+3A_del">Del</code></td>
<td>
<p>Delta away from the boundary restriction</p>
</td></tr>
<tr><td><code id="detectSliding_+3A_q">q</code></td>
<td>
<p>methods in calculating long-run variance of the test statistic. Default is &quot;fixed&quot; = length^(1/3) or &quot;andrews&quot; implements data adaptive selection, or user specify the length</p>
</td></tr>
<tr><td><code id="detectSliding_+3A_alpha">alpha</code></td>
<td>
<p>significance level of the test</p>
</td></tr>
<tr><td><code id="detectSliding_+3A_nboot">nboot</code></td>
<td>
<p>the number of bootstrap sample for p-value. Default is 199.</p>
</td></tr>
<tr><td><code id="detectSliding_+3A_n.cl">n.cl</code></td>
<td>
<p>number of cores in parallel computing. The default is (machine cores - 1)</p>
</td></tr>
<tr><td><code id="detectSliding_+3A_bsize">bsize</code></td>
<td>
<p>block size for the Block Wild Bootstrapping. Default is log(length),  &quot;sqrt&quot; uses sqrt(length), &quot;adaptive&quot; determines block size using data dependent selection of Andrews</p>
</td></tr>
<tr><td><code id="detectSliding_+3A_boottf">bootTF</code></td>
<td>
<p>determine whether the threshold is calculated from bootstrap or asymptotic</p>
</td></tr>
<tr><td><code id="detectSliding_+3A_scaletf">scaleTF</code></td>
<td>
<p>scale the variance into 1</p>
</td></tr>
<tr><td><code id="detectSliding_+3A_diagtf">diagTF</code></td>
<td>
<p>include diagonal term of covariance matrix or not</p>
</td></tr>
<tr><td><code id="detectSliding_+3A_plottf">plotTF</code></td>
<td>
<p>Draw plot to see test statistic and threshold</p>
</td></tr>
</table>


<h3>Value</h3>

<p><strong>sW</strong> The test statistic
</p>
<p><strong>L</strong> The number of factors used in the procedure
</p>
<p><strong>q</strong> The estimated vectorized autocovariance on each regime.
</p>
<p><strong>crit</strong> The critical value to identify change point
</p>
<p><strong>bsize</strong> The block size of the bootstrap
</p>
<p><strong>diagTF</strong> If TRUE, the diagonal entry of covariance matrix is used in detecting connectivity changes.
</p>
<p><strong>bootTF</strong> If TRUE, bootstrap is used to find critical value
</p>
<p><strong>scaleTF</strong> If TRUE, the multivariate signal is studentized to have zero mean and unit variance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out4 = detectSliding(changesim, wd=40, L=2, n.cl=1)
</code></pre>

<hr>
<h2 id='global'>Global Variables and functions</h2><span id='topic+global'></span>

<h3>Description</h3>

<p>Defining variables and functions used in the internal functions
</p>

<hr>
<h2 id='LRV.bartlett'>(multivariate) Bartlett long-run variance calculation</h2><span id='topic+LRV.bartlett'></span>

<h3>Description</h3>

<p>(multivariate) Bartlett long-run variance calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LRV.bartlett(cL, q)
</code></pre>

<hr>
<h2 id='networkpca'>If model is indicated, reduce data to components.</h2><span id='topic+networkpca'></span>

<h3>Description</h3>

<p>If model is indicated, reduce data to components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>networkpca(model, Y)
</code></pre>

<hr>
<h2 id='preproc'>Optional preprocessing step for regressing out noise variables.</h2><span id='topic+preproc'></span>

<h3>Description</h3>

<p>This function saves the residuals after regressing the user-defined
noise variables from the user-defined &quot;signal&quot; variables. Noise variables can
be nuisance regressors (such as cebral spinal fluid in fMRI), time vectors,
or any other vector that the user wishes to regress out.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preproc(Y, noise, signal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preproc_+3A_y">Y</code></td>
<td>
<p>data: Y = length*dim</p>
</td></tr>
<tr><td><code id="preproc_+3A_noise">noise</code></td>
<td>
<p>string vector indicating which variables (columns) are regressors</p>
</td></tr>
<tr><td><code id="preproc_+3A_signal">signal</code></td>
<td>
<p>string vector indicating which variables to regress out the noise variables from</p>
</td></tr>
</table>


<h3>Value</h3>

<p><strong>signalmatrix</strong>
</p>

<hr>
<h2 id='preprocess'>Data preparation for changepoint detection using functions in this package..</h2><span id='topic+preprocess'></span>

<h3>Description</h3>

<p>Id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preprocess(file = NULL,
header = NULL,
sep    = NULL,
signal = NULL,
noise = NULL,
butterfreq = NULL,
model = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preprocess_+3A_file">file</code></td>
<td>
<p>a data matrix or file name with columns as variables and rows as observations across time.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_header">header</code></td>
<td>
<p>logical for whether or not there is a header in the data file.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_sep">sep</code></td>
<td>
<p>The spacing of the data files.
&quot;&quot; indicates space-delimited,
&quot;/t&quot; indicates tab-delimited, &quot;,&quot; indicates comma delimited. Only necessary
to specify if reading data in from physical directory.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_signal">signal</code></td>
<td>
<p>(optional) a character vector containing the names of variables that contain signal i.e., which variables to use to detect change point. The default
(NULL) indicates all variables except those in 'noise' argument are considered signal. Example: signal = c(&quot;dDMN4&quot;, &quot;vDMN5&quot;, &quot;vDMN1&quot;,</p>
</td></tr>
<tr><td><code id="preprocess_+3A_noise">noise</code></td>
<td>
<p>(optional) a character vector containing the names of variables that contain noise. The signal variables will be regressed on these variables and residuals
used in change point detection. The default (NULL) indicates there are no noise variables. Example: noise = c(&quot;White.Matter1&quot;, &quot;CSF1&quot;)</p>
</td></tr>
<tr><td><code id="preprocess_+3A_butterfreq">butterfreq</code></td>
<td>
<p>(optional) bandpass filter frequency ranges. Example: c(.04,.4)</p>
</td></tr>
<tr><td><code id="preprocess_+3A_model">model</code></td>
<td>
<p>(optional) syntax indicating which variables belong to which networks for first pass of data reduction that is user-specified. If no header naming convention follows &quot;V#&quot;. Notation should follow lavaan syntax style.</p>
</td></tr>
</table>

<hr>
<h2 id='testGlasso'>Test for for the equality of connectivity based on the Graphical lasso estimation.</h2><span id='topic+testGlasso'></span>

<h3>Description</h3>

<p>This function utilizes Dynamic Connectivity Regression (DCR) algorithm proposed by Cribben el al. (2012) to test the equality of connectivity in two fMRI signals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testGlasso(
  subY1,
  subY2,
  p,
  lambda = "bic",
  nboot = 100,
  n.cl,
  bound = c(0.001, 1),
  gridTF = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testGlasso_+3A_suby1">subY1</code></td>
<td>
<p>a sample of size length*dim</p>
</td></tr>
<tr><td><code id="testGlasso_+3A_suby2">subY2</code></td>
<td>
<p>a sample of size length*dim</p>
</td></tr>
<tr><td><code id="testGlasso_+3A_p">p</code></td>
<td>
<p>Gep(p) distribution controls the size of stationary bootstrap. The mean block length is 1/p</p>
</td></tr>
<tr><td><code id="testGlasso_+3A_lambda">lambda</code></td>
<td>
<p>two selections possible for optimal parameter of lambda. &quot;bic&quot; finds lambda from bic criteria, or user can directly input the penalty value.</p>
</td></tr>
<tr><td><code id="testGlasso_+3A_nboot">nboot</code></td>
<td>
<p>the number of bootstrap sample for p-value. Default is 100.</p>
</td></tr>
<tr><td><code id="testGlasso_+3A_n.cl">n.cl</code></td>
<td>
<p>number of cores in parallel computing. The default is (machine cores - 1)</p>
</td></tr>
<tr><td><code id="testGlasso_+3A_bound">bound</code></td>
<td>
<p>bound of bic search in &quot;bic&quot; rule. Default is (.001, 1)</p>
</td></tr>
<tr><td><code id="testGlasso_+3A_gridtf">gridTF</code></td>
<td>
<p>Utilize a grid search to optimize hyperparameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p><strong>pval</strong> The empirical p-value for testing the equality of connectivity structure
</p>
<p><strong>rho</strong> The sequence of penalty parameter based on the combined sample, subY1 and subY2.
</p>
<p><strong>fit0</strong> Output of glasso for combined sample
</p>
<p><strong>fit1</strong> Output of glasso for subY1
</p>
<p><strong>fit2</strong> Output of glasso for subY2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test1= testGlasso(testsim$X, testsim$Y, n.cl=1)
</code></pre>

<hr>
<h2 id='testMax'>Max-type test for for the equality of connectivity</h2><span id='topic+testMax'></span>

<h3>Description</h3>

<p>This function produces three test results based on max-type block bootstrap (BMB), long-run variance block bootstrapping with lagged-window estimator (LVBWR) and sum-type block bootstrap (BSUM). See Baek el al. (2019) for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testMax(subY1, subY2, diagTF = TRUE, nboot, q = "fixed", n.cl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testMax_+3A_suby1">subY1</code></td>
<td>
<p>a sample of size length*dim</p>
</td></tr>
<tr><td><code id="testMax_+3A_suby2">subY2</code></td>
<td>
<p>a sample of size length*dim</p>
</td></tr>
<tr><td><code id="testMax_+3A_diagtf">diagTF</code></td>
<td>
<p>include diagonal term of covariance matrix or not</p>
</td></tr>
<tr><td><code id="testMax_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstrap sample, default is 2000</p>
</td></tr>
<tr><td><code id="testMax_+3A_q">q</code></td>
<td>
<p>methods in calculating long-run variance of the test statistic. Default is &quot;fixed&quot; = length^(1/3) or &quot;andrews&quot; implements data adaptive selection, or user specify the length</p>
</td></tr>
<tr><td><code id="testMax_+3A_n.cl">n.cl</code></td>
<td>
<p>number of cores in parallel computing. The default is (machine cores - 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><strong>tstat</strong> Test statistic for testing the equality of connectivity structure
</p>
<p><strong>pval</strong> The p-value for testing the equality of connectivity structure
</p>
<p><strong>q</strong> The tuning parameter used in calculating long-run variance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test2 = testMax(testsim$X, testsim$Y, n.cl=1)
</code></pre>

<hr>
<h2 id='testPCA'>PCA-based test for the equality of connectivity</h2><span id='topic+testPCA'></span>

<h3>Description</h3>

<p>This function performs PCA-test for testing the equality of connectivity in two fMRI signals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testPCA(subY1, subY2, L = 2, nlag, diagTF = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testPCA_+3A_suby1">subY1</code></td>
<td>
<p>a sample of size length*dim</p>
</td></tr>
<tr><td><code id="testPCA_+3A_suby2">subY2</code></td>
<td>
<p>a sample of size length*dim</p>
</td></tr>
<tr><td><code id="testPCA_+3A_l">L</code></td>
<td>
<p>the number of factors</p>
</td></tr>
<tr><td><code id="testPCA_+3A_nlag">nlag</code></td>
<td>
<p>is the number of ACF lag to be used in the test, default is 2, Default is nlag = floor(N^(1/3))</p>
</td></tr>
<tr><td><code id="testPCA_+3A_diagtf">diagTF</code></td>
<td>
<p>include diagonal term of covariance matrix or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p><strong>tstat</strong> Test statistic
</p>
<p><strong>pval</strong> Returns the p-value
</p>
<p><strong>df</strong> The degree of freedom in PCA-best test
</p>
<p><strong>L</strong> The number of factors used in the test
</p>
<p><strong>diagTF</strong> If true, the diagonal entry of covariance matrix is used in testing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test3 = testPCA(testsim$X, testsim$Y, L=2)
</code></pre>

<hr>
<h2 id='testsim'>Test Example Data</h2><span id='topic+testsim'></span>

<h3>Description</h3>

<p>This dataset contains a simulated multivariate time series with two different autocovariances.
It is a list data with two variables X and Y. Each multivariate time series had dimension of
T=150 and p=20
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testsim
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
