<!DOCTYPE html><html><head><title>Help for package rmapzen</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rmapzen}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_sf'><p>Coerce a Mapzen response to a simple features object</p></a></li>
<li><a href='#ca_tiles'><p>Vector tiles the contain California</p></a></li>
<li><a href='#costing_models'><p>Costing model constructors and helpers</p></a></li>
<li><a href='#mapzen_references'><p>Reference lists</p></a></li>
<li><a href='#marina_walks'><p>Pedestrian isochrones from the Berkeley Marina for 10 and 15 minutes</p></a></li>
<li><a href='#marina_walks_polygons'><p>Pedestrian isochrones from the Berkeley Marina for 10 and 15 minutes, as polygons</p></a></li>
<li><a href='#mz_autocomplete'><p>Mapzen search API</p></a></li>
<li><a href='#mz_bbox'><p>Get the bounding box</p></a></li>
<li><a href='#mz_check_usage'><p>Check usage statistics</p></a></li>
<li><a href='#mz_contours'><p>Create an mz_contours object</p></a></li>
<li><a href='#mz_coordinates'><p>Extract a data frame of coordinates from a <code>mapzen_geo_list</code></p></a></li>
<li><a href='#mz_date_time'><p>Create mz_date_time objects</p></a></li>
<li><a href='#mz_geocode'><p>Geocode an address or other location</p></a></li>
<li><a href='#mz_geocode_structured'><p>Geocode a structured address</p></a></li>
<li><a href='#mz_isochrone'><p>Retrieve isochrones</p></a></li>
<li><a href='#mz_location'><p>Create/extract lat/lon location information</p></a></li>
<li><a href='#mz_place'><p>Get details on a place</p></a></li>
<li><a href='#mz_provider'><p>Configure provider information</p></a></li>
<li><a href='#mz_set_host'><p>Set up a host provider for a PELIAS service</p></a></li>
<li><a href='#mz_structured_search'><p>Structured search</p></a></li>
<li><a href='#mz_tile_coordinates'><p>Specify tile coordinates</p></a></li>
<li><a href='#mz_vector_tiles'><p>Request vector tile data</p></a></li>
<li><a href='#oakland_public'><p>25 search results for &quot;Oakland Public library branch&quot;</p></a></li>
<li><a href='#rmapzen-package'><p>rmapzen: A client application for the 'Mapzen' API.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Client for 'Mapzen' and Related Map APIs</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tarak Shah &lt;tarak.shah@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an interface to 'Mapzen'-based APIs (including 
    geocode.earth, Nextzen, and NYC GeoSearch) for geographic search 
    and geocoding, isochrone calculation, and vector data to draw map tiles. 
    See <a href="https://www.mapzen.com/documentation/">https://www.mapzen.com/documentation/</a> for more information. The original 
    Mapzen has gone out of business, but 'rmapzen' can be set up to work with 
    any provider who implements the Mapzen API. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>tibble, httr, jsonlite, ISOcodes, dplyr, assertthat,
geojsonio, tidyr, purrr, digest, sf (&ge; 1.0.0), utils</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr, knitr, rmarkdown, rlang</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://tarakc02.github.io/rmapzen/">https://tarakc02.github.io/rmapzen/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tarakc02/rmapzen/issues">https://github.com/tarakc02/rmapzen/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-17 16:45:39 UTC; tshah</td>
</tr>
<tr>
<td>Author:</td>
<td>Tarak Shah [aut, cre],
  Daniel Possenriede [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-17 17:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_sf'>Coerce a Mapzen response to a simple features object</h2><span id='topic+as_sf'></span><span id='topic+as_sf.geo_list'></span><span id='topic+as_sf.mapzen_vector_layer'></span>

<h3>Description</h3>

<p>Coerces responses to class sf. See <code>vignette("sf1", package = "sf")</code> for
more information about Simple Features for R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_sf(geo, ...)

## S3 method for class 'geo_list'
as_sf(geo, ...)

## S3 method for class 'mapzen_vector_layer'
as_sf(geo, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_sf_+3A_geo">geo</code></td>
<td>
<p>The object to be converted</p>
</td></tr>
<tr><td><code id="as_sf_+3A_...">...</code></td>
<td>
<p>not currently used</p>
</td></tr>
</table>

<hr>
<h2 id='ca_tiles'>Vector tiles the contain California</h2><span id='topic+ca_tiles'></span>

<h3>Description</h3>

<p>Vector tiles the contain California
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ca_tiles
</code></pre>


<h3>Format</h3>

<p>An object of class <code>mapzen_vector_tiles</code> (inherits from <code>list</code>) of length 9.
</p>


<h3>Source</h3>

<p>Mapzen, OpenStreetMap contributors, Who's On First, Natural Earth,
and openstreetmapdata.com
</p>

<hr>
<h2 id='costing_models'>Costing model constructors and helpers</h2><span id='topic+costing_models'></span><span id='topic+mz_costing'></span><span id='topic+mz_costing_options'></span>

<h3>Description</h3>

<p>Mapzen's Isochrone service (<code><a href="#topic+mz_isochrone">mz_isochrone</a></code>) as well as other
mobility services (currently not implemented in this package, read more at
<a href="https://valhalla.readthedocs.io/en/latest/">https://valhalla.readthedocs.io/en/latest/</a>) require users to specify a
&quot;costing model.&quot; See <a href="https://valhalla.readthedocs.io/en/latest/">https://valhalla.readthedocs.io/en/latest/</a>
for details. These can be difficult to construct correctly, so the objects
<code>mz_costing</code> and <code>mz_costing_options</code> exist to make that process
less error-prone and more convenient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mz_costing

mz_costing_options
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 4.
</p>
<p>An object of class <code>list</code> of length 4.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mz_isochrone">mz_isochrone</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## creates a pedestrian costing model with walking speed of 2 km/hr
## that also avoids alleys.
## non-multimodal costing models will accept 0 or more options from the
## appropriate list.
mz_costing$pedestrian(
    mz_costing_options$pedestrian$walking_speed(2.0),
    mz_costing_options$pedestrian$alley_factor(0)
)

## creates a multimodal costing model that favors buses over rails, and
## has a slower than default walking speed
## (note multimodal has named arguments requiring list inputs)
mz_costing$multimodal(
    transit = list(
        mz_costing_options$transit$use_bus(1.0),
        mz_costing_options$transit$use_rail(5)
    ),
    pedestrian = list(
        mz_costing_options$pedestrian$walking_speed(4.1)
    )
)
</code></pre>

<hr>
<h2 id='mapzen_references'>Reference lists</h2><span id='topic+mapzen_references'></span><span id='topic+mz_sources'></span><span id='topic+mz_layers'></span><span id='topic+mz_countries'></span>

<h3>Description</h3>

<p>Lists of sources, layers, and countries, as they are expected to appear in
the <code><a href="#topic+mz_search">mz_search</a></code> functions. These data objects are provided as a
convenience, to be able to quickly and easily look up acceptable values for
the optional arguments of search functions. Object names match the argument
names for which they are appropriate. So <code>mz_sources</code> provide acceptable
arguments for the <code>source</code> argument in <code><a href="#topic+mz_search">mz_search</a></code>,
<code>mz_layers</code> for the <code>layer</code> argument, and <code><a href="#topic+mz_countries">mz_countries</a></code>
for the <code>boundary.country</code> argument. Mapzen's documentation
(<a href="https://github.com/pelias/documentation/">https://github.com/pelias/documentation/</a>) explains more about
each of these arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mz_sources

mz_layers

mz_countries
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 8.
</p>
<p>An object of class <code>list</code> of length 13.
</p>
<p>An object of class <code>list</code> of length 747.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# look for YMCAs in Jamaica:
# Note that boundary.country is supplied via ISO3166 code,
# but mz_countries will look up the code
mz_search("YMCA",
          boundary.country = mz_countries$Jamaica,
          layers = c(mz_layers$venue, mz_layers$address))

## End(Not run)

</code></pre>

<hr>
<h2 id='marina_walks'>Pedestrian isochrones from the Berkeley Marina for 10 and 15 minutes</h2><span id='topic+marina_walks'></span>

<h3>Description</h3>

<p>Isochrone results from Mapzen as of January 8, 2017. The location for the
isochrones is the Berkeley Marina, lat 37.86613, lon -122.3151
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marina_walks
</code></pre>


<h3>Format</h3>

<p>An object of class <code>mapzen_isochrone_list</code> (inherits from <code>geo_list</code>) of length 3.
</p>


<h3>Source</h3>

<p>Mapzen, OpenStreetMap, British Oceanographic Data Centre,
NASA, USGS, and Transitland.
</p>

<hr>
<h2 id='marina_walks_polygons'>Pedestrian isochrones from the Berkeley Marina for 10 and 15 minutes, as polygons</h2><span id='topic+marina_walks_polygons'></span>

<h3>Description</h3>

<p>Polygon Isochrone results (using <code>polygons = TRUE</code>) from Mapzen as of
January 10, 2017. The location for the isochrones is the Berkeley Marina,
lat 37.86613, lon -122.3151, and the contours are 10 and 15 minutes for a
pedestrian costing model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marina_walks_polygons
</code></pre>


<h3>Format</h3>

<p>An object of class <code>mapzen_isochrone_list</code> (inherits from <code>geo_list</code>) of length 3.
</p>


<h3>Source</h3>

<p>Mapzen, OpenStreetMap, British Oceanographic Data Centre,
NASA, USGS, and Transitland.
</p>

<hr>
<h2 id='mz_autocomplete'>Mapzen search API</h2><span id='topic+mz_autocomplete'></span><span id='topic+mz_reverse_geocode'></span><span id='topic+search'></span><span id='topic+mz_search'></span>

<h3>Description</h3>

<p>Functions to access the various endpoints from the Mapzen Search API.
For more details, see <a href="https://github.com/pelias/documentation/">https://github.com/pelias/documentation/</a>. If your
data is already split up by street, city, state, zip, etc., then you might
find <code><a href="#topic+mz_structured_search">mz_structured_search</a></code> to be more precise. All arguments
besides <code>text</code> (<code>point</code> in the case of <code>mz_reverse_geocode</code>) are
optional. If you have parsed addresses (e.g. for geocoding), use <code><a href="#topic+mz_structured_search">mz_structured_search</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mz_autocomplete(
  text,
  boundary.country = NULL,
  boundary.rect = NULL,
  focus.point = NULL,
  sources = NULL,
  layers = NULL,
  api_key = NULL
)

mz_reverse_geocode(
  point,
  size = NULL,
  layers = NULL,
  sources = NULL,
  boundary.country = NULL,
  api_key = NULL
)

mz_search(
  text,
  size = 10,
  boundary.country = NULL,
  boundary.rect = NULL,
  boundary.circle = NULL,
  focus.point = NULL,
  sources = NULL,
  layers = NULL,
  api_key = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mz_autocomplete_+3A_text">text</code></td>
<td>
<p>Search string</p>
</td></tr>
<tr><td><code id="mz_autocomplete_+3A_boundary.country">boundary.country</code></td>
<td>
<p>ISO-3166 country code to narrow the search.
See <code><a href="#topic+mz_countries">mz_countries</a></code></p>
</td></tr>
<tr><td><code id="mz_autocomplete_+3A_boundary.rect">boundary.rect</code></td>
<td>
<p>4 corners that define a box to narrow the search. Can
be the result of <code><a href="#topic+mz_bbox">mz_bbox</a></code>. Should have named elements with names
&quot;min_lon&quot;, &quot;min_lat&quot;, &quot;max_lon&quot;, &quot;max_lat&quot; &ndash; can be created using <code><a href="#topic+mz_rect">mz_rect</a></code>.</p>
</td></tr>
<tr><td><code id="mz_autocomplete_+3A_focus.point">focus.point</code></td>
<td>
<p>A point to &quot;focus&quot; the search. Can be created with
<code><a href="#topic+mz_location">mz_location</a></code> or <code><a href="#topic+mz_geocode">mz_geocode</a></code>, otherwise should have
names &quot;lat&quot; and &quot;lon&quot;</p>
</td></tr>
<tr><td><code id="mz_autocomplete_+3A_sources">sources</code></td>
<td>
<p>The originating source of the data (to filter/narrow search
results). See <code><a href="#topic+mz_sources">mz_sources</a></code></p>
</td></tr>
<tr><td><code id="mz_autocomplete_+3A_layers">layers</code></td>
<td>
<p>Which layers (types of places) to search. See
<a href="https://github.com/pelias/documentation/">https://github.com/pelias/documentation/</a>
for definitions, and use <code><a href="#topic+mz_layers">mz_layers</a></code> for convenience</p>
</td></tr>
<tr><td><code id="mz_autocomplete_+3A_api_key">api_key</code></td>
<td>
<p>Your Mapzen API key. The default is to look for the key within
the provider information that was set up with 'mz_set_host'.</p>
</td></tr>
<tr><td><code id="mz_autocomplete_+3A_point">point</code></td>
<td>
<p>For reverse geocoding, the location to reverse geocode. Can be
created with <code><a href="#topic+mz_location">mz_location</a></code> or <code><a href="#topic+mz_geocode">mz_geocode</a></code>,
otherwise should have names &quot;lat&quot; and &quot;lon&quot;</p>
</td></tr>
<tr><td><code id="mz_autocomplete_+3A_size">size</code></td>
<td>
<p>Number of search results requested</p>
</td></tr>
<tr><td><code id="mz_autocomplete_+3A_boundary.circle">boundary.circle</code></td>
<td>
<p>A circle to narrow the search. Should have named elements
with names &quot;lon&quot;, &quot;lat&quot;, and &quot;radius&quot;</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mz_place">mz_place</a></code>, <code><a href="#topic+mz_structured_search">mz_structured_search</a></code>,
<code><a href="#topic+mz_countries">mz_countries</a></code>, <code><a href="#topic+mz_sources">mz_sources</a></code>, <code><a href="#topic+mz_layers">mz_layers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# hard rock cafes in sweden:
mz_search("Hard Rock Cafe", boundary.country = "SE")

# autocompletions when the user types in "Union Square"
# prioritizing San Francisco results first:
mz_autocomplete("Union Square",
                focus.point = mz_geocode("San Francisco, CA"))

## End(Not run)

</code></pre>

<hr>
<h2 id='mz_bbox'>Get the bounding box</h2><span id='topic+mz_bbox'></span><span id='topic+mz_bbox.mapzen_geo_list'></span><span id='topic+mz_bbox.mapzen_isochrone_list'></span><span id='topic+mz_rect'></span>

<h3>Description</h3>

<p>Returns the bottom left and top right corners of the box that contains a
mapzen object (<code>mz_geo_list</code>, <code>mz_isochrone_list</code>,
or <code>mapzen_vector_tiles</code>).
In the case of <code>mz_rect</code>, creates such a box from the specified
coordinates. The returned value can be used directly as the
<code>boundary.rect</code> parameter for <code><a href="#topic+search">search</a></code> functions, as well as
converted to x, y, zoom coordinates to use with <code><a href="#topic+mz_vector_tiles">mz_vector_tiles</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mz_bbox(geo)

## S3 method for class 'mapzen_geo_list'
mz_bbox(geo)

## S3 method for class 'mapzen_isochrone_list'
mz_bbox(geo)

mz_rect(min_lon, min_lat, max_lon, max_lat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mz_bbox_+3A_geo">geo</code></td>
<td>
<p>A mapzen geo list or isochrone list</p>
</td></tr>
<tr><td><code id="mz_bbox_+3A_min_lon">min_lon</code>, <code id="mz_bbox_+3A_min_lat">min_lat</code>, <code id="mz_bbox_+3A_max_lon">max_lon</code>, <code id="mz_bbox_+3A_max_lat">max_lat</code></td>
<td>
<p>The bottom left and top right corners,
expressed as latitude and longitude, of a rectangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single-row tibble with columns <code>min_lon</code>, <code>min_lat</code>,
<code>max_lon</code>, <code>max_lat</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mz_rect(min_lon = -122.2856, min_lat = 37.73742, max_lon = -122.1749, max_lat = 37.84632)
mz_bbox(oakland_public)

</code></pre>

<hr>
<h2 id='mz_check_usage'>Check usage statistics</h2><span id='topic+mz_check_usage'></span>

<h3>Description</h3>

<p>Prints out remaining queries for various time periods. <code>rmapzen</code> manages
rate limiting for the per-second limits, but does not keep track of the daily
limits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mz_check_usage()
</code></pre>


<h3>Details</h3>

<p>This function is populated from the headers of responses to various API requests.
If no queries have been made, or if the only queries so far have hit cache servers,
then no information will be available.
</p>

<hr>
<h2 id='mz_contours'>Create an mz_contours object</h2><span id='topic+mz_contours'></span>

<h3>Description</h3>

<p>Contours are given as inputs to <code><a href="#topic+mz_isochrone">mz_isochrone</a></code>. This function
makes it convenient to construct them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mz_contours(times, colors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mz_contours_+3A_times">times</code></td>
<td>
<p>Times in minutes for the contour. Up to a maximum of 4 numbers.</p>
</td></tr>
<tr><td><code id="mz_contours_+3A_colors">colors</code></td>
<td>
<p>Colors for the contours. By default, a palette will be constructed
from the Colorbrewer 4-class oranges palette.</p>
</td></tr>
</table>

<hr>
<h2 id='mz_coordinates'>Extract a data frame of coordinates from a <code>mapzen_geo_list</code></h2><span id='topic+mz_coordinates'></span><span id='topic+mz_coordinates.mapzen_geo_list'></span>

<h3>Description</h3>

<p>Extract a data frame of coordinates from a <code>mapzen_geo_list</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mz_coordinates(geo)

## S3 method for class 'mapzen_geo_list'
mz_coordinates(geo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mz_coordinates_+3A_geo">geo</code></td>
<td>
<p>A mapzen geo list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble, with columns <code>lon</code> and <code>lat</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mz_coordinates(oakland_public)

</code></pre>

<hr>
<h2 id='mz_date_time'>Create mz_date_time objects</h2><span id='topic+mz_date_time'></span>

<h3>Description</h3>

<p>Mobility services (such as <code>mz_isochrone</code>) take, optionally, a date_time
argument that specifies the date and time along with type (departure/arrival).
This function constructs the appropriate objects to use as date_time arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mz_date_time(date_time, type = "departure")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mz_date_time_+3A_date_time">date_time</code></td>
<td>
<p>A POSIXt date-time object</p>
</td></tr>
<tr><td><code id="mz_date_time_+3A_type">type</code></td>
<td>
<p>&quot;departure&quot; or &quot;arrival&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='mz_geocode'>Geocode an address or other location</h2><span id='topic+mz_geocode'></span>

<h3>Description</h3>

<p>This is a convenience function that calls <code><a href="#topic+mz_search">mz_search</a></code> to retrieve
latitude and longitude.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mz_geocode(location, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mz_geocode_+3A_location">location</code></td>
<td>
<p>An address or other suitably specific search string</p>
</td></tr>
<tr><td><code id="mz_geocode_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code><a href="#topic+mz_search">mz_search</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble, with the parsed address used to retrieve the geocode, lat/lon,
and the confidence (between 0 and 1)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mz_search">mz_search</a></code>, <code><a href="#topic+mz_reverse_geocode">mz_reverse_geocode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mz_geocode("1600 Pennsylvania Ave., Washington DC")

# can also be a landmark
mz_geocode("Statue of Liberty, New York")

## End(Not run)

</code></pre>

<hr>
<h2 id='mz_geocode_structured'>Geocode a structured address</h2><span id='topic+mz_geocode_structured'></span>

<h3>Description</h3>

<p><code><a href="#topic+mz_geocode">mz_geocode</a></code> allows you to search using an unstructured string of
text, but if your address data has more structure (eg separate columns for
address, city, state, zip), then using the structured search service may
provide more precision. For more information, see
<a href="https://github.com/pelias/documentation/">https://github.com/pelias/documentation/</a>. Note that
all of the arguments are optional, but at least one of them must be non-NULL.
Furthermore, <code>postalcode</code> can not be used by itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mz_geocode_structured(
  address = NULL,
  neighbourhood = NULL,
  borough = NULL,
  locality = NULL,
  county = NULL,
  region = NULL,
  postalcode = NULL,
  country = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mz_geocode_structured_+3A_address">address</code></td>
<td>
<p>Can be a numbered street address or just the name of the street</p>
</td></tr>
<tr><td><code id="mz_geocode_structured_+3A_neighbourhood">neighbourhood</code></td>
<td>
<p>Neighborhood name (eg &quot;Notting Hill&quot; in London)</p>
</td></tr>
<tr><td><code id="mz_geocode_structured_+3A_borough">borough</code></td>
<td>
<p>eg &quot;Manhattan&quot;</p>
</td></tr>
<tr><td><code id="mz_geocode_structured_+3A_locality">locality</code></td>
<td>
<p>The city (eg &quot;Oakland&quot;)</p>
</td></tr>
<tr><td><code id="mz_geocode_structured_+3A_county">county</code></td>
<td>
<p>The county</p>
</td></tr>
<tr><td><code id="mz_geocode_structured_+3A_region">region</code></td>
<td>
<p>States in the case of US/Canada, or state-like
administrative division in other countries</p>
</td></tr>
<tr><td><code id="mz_geocode_structured_+3A_postalcode">postalcode</code></td>
<td>
<p>AKA the zip code. Can not be used alone, must have at least
one other argument</p>
</td></tr>
<tr><td><code id="mz_geocode_structured_+3A_country">country</code></td>
<td>
<p>The country - Can be the full name or the abbreviation from
<code><a href="#topic+mz_countries">mz_countries</a></code></p>
</td></tr>
<tr><td><code id="mz_geocode_structured_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="#topic+mz_structured_search">mz_structured_search</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble, with the parsed address used to retrieve the geocode, lat/lon,
and the confidence (between 0 and 1)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mz_geocode">mz_geocode</a></code>, <code><a href="#topic+mz_structured_search">mz_structured_search</a></code>
</p>

<hr>
<h2 id='mz_isochrone'>Retrieve isochrones</h2><span id='topic+mz_isochrone'></span>

<h3>Description</h3>

<p>From <a href="https://valhalla.readthedocs.io/en/latest/">https://valhalla.readthedocs.io/en/latest/</a>:
&quot;An isochrone is a line that connects points of equal travel time about a
given location, from the Greek roots of 'iso' for equal and 'chrone' for time.
The Mapzen Isochrone service computes areas that are reachable within
specified time intervals from a location, and returns the reachable regions
as contours of polygons or lines that you can display on a map.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mz_isochrone(
  locations,
  costing_model,
  contours,
  date_time = NULL,
  polygons = NULL,
  denoise = NULL,
  generalize = NULL,
  id = "my-iso",
  api_key = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mz_isochrone_+3A_locations">locations</code></td>
<td>
<p>An <code>mz_location</code>, or something that can be coerced to an
<code><a href="#topic+mz_location">mz_location</a></code>, as the departure point for the isochrone. This can be the
result of <code><a href="#topic+mz_geocode">mz_geocode</a></code>. Despite the argument name, the isochrone
service currently can only accept a single location</p>
</td></tr>
<tr><td><code id="mz_isochrone_+3A_costing_model">costing_model</code></td>
<td>
<p>The costing model, see <code><a href="#topic+mz_costing">mz_costing</a></code></p>
</td></tr>
<tr><td><code id="mz_isochrone_+3A_contours">contours</code></td>
<td>
<p>Up to 4 contours, see <code><a href="#topic+mz_contours">mz_contours</a></code></p>
</td></tr>
<tr><td><code id="mz_isochrone_+3A_date_time">date_time</code></td>
<td>
<p>The local date and time at the location, and whether it is
the departure or arrival time. See <code><a href="#topic+mz_date_time">mz_date_time</a></code></p>
</td></tr>
<tr><td><code id="mz_isochrone_+3A_polygons">polygons</code></td>
<td>
<p>Whether to return polygons (TRUE) or linestrings (FALSE, default)</p>
</td></tr>
<tr><td><code id="mz_isochrone_+3A_denoise">denoise</code></td>
<td>
<p>A value between 0 and 1 (default 1) to remove smaller contours.
A value of 1 will only return the largest contour for a given time value. A
value of 0.5 drops any contours that are less than half the area of the
largest contour.</p>
</td></tr>
<tr><td><code id="mz_isochrone_+3A_generalize">generalize</code></td>
<td>
<p>Tolerance in meters for the Douglas-Peucker generalization.</p>
</td></tr>
<tr><td><code id="mz_isochrone_+3A_id">id</code></td>
<td>
<p>A descriptive identifier, the response will contain the id as an element.</p>
</td></tr>
<tr><td><code id="mz_isochrone_+3A_api_key">api_key</code></td>
<td>
<p>Your Mapzen API key. The default is to look for the key within
the provider information that was set up with 'mz_set_host'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mapzen_isochrone_list</code>, which can be converted to <code>sf</code>
using <code><a href="#topic+as_sf">as_sf</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mz_costing">mz_costing</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mz_isochrone(
    mz_location(lat = 37.87416, lon = -122.2544),
    costing_model = mz_costing$auto(),
    contours = mz_contours(c(10, 20, 30))
)

# departure point can be specified as a geocode result
mz_isochrone(
    mz_geocode("UC Berkeley"),
    costing_model = mz_costing$pedestrian(),
    contours = mz_contours(c(10, 20, 30))
)

## End(Not run)

</code></pre>

<hr>
<h2 id='mz_location'>Create/extract lat/lon location information</h2><span id='topic+mz_location'></span><span id='topic+as.mz_location'></span><span id='topic+as.mz_location.default'></span><span id='topic+as.mz_location.mz_geocode_result'></span>

<h3>Description</h3>

<p><code>mz_location</code> constructs a new <code>mz_location</code> object, which can be
used with functions such as <code><a href="#topic+mz_isochrone">mz_isochrone</a></code> or
<code><a href="#topic+mz_reverse_geocode">mz_reverse_geocode</a></code>. <code>as.mz_location</code> coerces eligible
objects to <code>mz_location</code>s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mz_location(lat, lon)

as.mz_location(x, ...)

## Default S3 method:
as.mz_location(x, ...)

## S3 method for class 'mz_geocode_result'
as.mz_location(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mz_location_+3A_lat">lat</code></td>
<td>
<p>Latitude</p>
</td></tr>
<tr><td><code id="mz_location_+3A_lon">lon</code></td>
<td>
<p>Longitude</p>
</td></tr>
<tr><td><code id="mz_location_+3A_x">x</code></td>
<td>
<p>An object that has location information</p>
</td></tr>
<tr><td><code id="mz_location_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mz_isochrone">mz_isochrone</a></code> For using the Mapzen isochrone service
<code><a href="#topic+mz_contours">mz_contours</a></code>, <code><a href="#topic+mz_costing">mz_costing</a></code>, and
<code><a href="#topic+mz_costing_options">mz_costing_options</a></code> for other argument constructors
</p>

<hr>
<h2 id='mz_place'>Get details on a place</h2><span id='topic+mz_place'></span><span id='topic+mz_place.character'></span><span id='topic+mz_place.mapzen_geo_list'></span>

<h3>Description</h3>

<p>Search functions (e.g. <code><a href="#topic+mz_search">mz_search</a></code>) return identification numbers,
or <code>gid</code>s. Use <code>mz_place</code> to retrieve more details about the place.
See <a href="https://github.com/pelias/documentation/">https://github.com/pelias/documentation/</a> for details. This
function is generic, and can take a character vector of IDs, or a
<code>mapzen_geo_list</code> as returned by <code><a href="#topic+mz_search">mz_search</a></code> and friends.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mz_place(ids, ..., api_key = NULL)

## S3 method for class 'character'
mz_place(ids, ..., api_key = NULL)

## S3 method for class 'mapzen_geo_list'
mz_place(ids, ..., gid = "gid", api_key = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mz_place_+3A_ids">ids</code></td>
<td>
<p>A character vector of gids (see details), or a <code>mapzen_geo_list</code></p>
</td></tr>
<tr><td><code id="mz_place_+3A_...">...</code></td>
<td>
<p>Arguments passed on to methods</p>
</td></tr>
<tr><td><code id="mz_place_+3A_api_key">api_key</code></td>
<td>
<p>Your Mapzen API key. The default is to look for the key within
the provider information that was set up with 'mz_set_host'.</p>
</td></tr>
<tr><td><code id="mz_place_+3A_gid">gid</code></td>
<td>
<p>The name of the <code>gid</code> field to use. Search results may include,
in addition to the <code>gid</code> for the search result itself (the default), the
<code>gid</code>s for the country, region, county, locality and neighborhood.</p>
</td></tr>
</table>

<hr>
<h2 id='mz_provider'>Configure provider information</h2><span id='topic+mz_provider'></span>

<h3>Description</h3>

<p>rmapzen works with most implementations of PELIAS. This function defines the
base URL for a particular API provider, and can be used to provider the
<code>provider</code> argument to <code><a href="#topic+mz_set_host">mz_set_host</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mz_provider(hostname, path = NULL, key = NULL, scheme = "https")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mz_provider_+3A_hostname">hostname</code></td>
<td>
<p>The hostname in the API URL, for instance <code>www.example.com</code></p>
</td></tr>
<tr><td><code id="mz_provider_+3A_path">path</code></td>
<td>
<p>Specific path that all API requests must include, e.g. &quot;v1&quot;</p>
</td></tr>
<tr><td><code id="mz_provider_+3A_key">key</code></td>
<td>
<p>API key for this provider, if required</p>
</td></tr>
<tr><td><code id="mz_provider_+3A_scheme">scheme</code></td>
<td>
<p>The scheme for the URL, should always be &quot;https&quot;</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mz_set_host">mz_set_host</a></code>
</p>

<hr>
<h2 id='mz_set_host'>Set up a host provider for a PELIAS service</h2><span id='topic+mz_set_host'></span><span id='topic+mz_get_host'></span><span id='topic+mz_set_search_host_geocode.earth'></span><span id='topic+mz_set_search_host_nyc_geosearch'></span><span id='topic+mz_set_tile_host_nextzen'></span>

<h3>Description</h3>

<p>rmapzen works with most implementations of PELIAS. Use this function to set
up the basic information required to connect to a particular provider.
Provider-specific setup functions include information to set up known
providers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mz_set_host(which, provider)

mz_get_host(which)

mz_set_search_host_geocode.earth(key = Sys.getenv("GEOCODE.EARTH_KEY"))

mz_set_search_host_nyc_geosearch()

mz_set_tile_host_nextzen(key = Sys.getenv("NEXTZEN_KEY"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mz_set_host_+3A_which">which</code></td>
<td>
<p>One of &quot;search&quot;, &quot;matrix&quot;, or &quot;tile&quot;</p>
</td></tr>
<tr><td><code id="mz_set_host_+3A_provider">provider</code></td>
<td>
<p>A provider, created using <code><a href="#topic+mz_provider">mz_provider</a></code></p>
</td></tr>
<tr><td><code id="mz_set_host_+3A_key">key</code></td>
<td>
<p>API key</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mz_provider">mz_provider</a></code>
</p>

<hr>
<h2 id='mz_structured_search'>Structured search</h2><span id='topic+mz_structured_search'></span>

<h3>Description</h3>

<p><code><a href="#topic+mz_search">mz_search</a></code> allows you to search using an unstructured string of
text, but if your address data has more structure (eg separate columns for
address, city, state, zip), then using the structured search service may
provide more precision. For more information, see
<a href="https://github.com/pelias/documentation">https://github.com/pelias/documentation</a>. Note that
all of the arguments are optional, but at least one of them must be non-NULL.
Furthermore, <code>postalcode</code> can not be used by itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mz_structured_search(
  address = NULL,
  neighbourhood = NULL,
  borough = NULL,
  locality = NULL,
  county = NULL,
  region = NULL,
  postalcode = NULL,
  country = NULL,
  api_key = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mz_structured_search_+3A_address">address</code></td>
<td>
<p>Can be a numbered street address or just the name of the street</p>
</td></tr>
<tr><td><code id="mz_structured_search_+3A_neighbourhood">neighbourhood</code></td>
<td>
<p>Neighborhood name (eg &quot;Notting Hill&quot; in London)</p>
</td></tr>
<tr><td><code id="mz_structured_search_+3A_borough">borough</code></td>
<td>
<p>eg &quot;Manhattan&quot;</p>
</td></tr>
<tr><td><code id="mz_structured_search_+3A_locality">locality</code></td>
<td>
<p>The city (eg &quot;Oakland&quot;)</p>
</td></tr>
<tr><td><code id="mz_structured_search_+3A_county">county</code></td>
<td>
<p>The county</p>
</td></tr>
<tr><td><code id="mz_structured_search_+3A_region">region</code></td>
<td>
<p>States in the case of US/Canada, or state-like
administrative division in other countries</p>
</td></tr>
<tr><td><code id="mz_structured_search_+3A_postalcode">postalcode</code></td>
<td>
<p>AKA the zip code. Can not be used alone, must have at least
one other argument</p>
</td></tr>
<tr><td><code id="mz_structured_search_+3A_country">country</code></td>
<td>
<p>The country - Can be the full name or the abbreviation from
<code><a href="#topic+mz_countries">mz_countries</a></code></p>
</td></tr>
<tr><td><code id="mz_structured_search_+3A_api_key">api_key</code></td>
<td>
<p>Your Mapzen API key. The default is to look for the key within
the provider information that was set up with 'mz_set_host'.</p>
</td></tr>
<tr><td><code id="mz_structured_search_+3A_...">...</code></td>
<td>
<p>Any of the parameters, other than &quot;text&quot;, that appear in
<code><a href="#topic+mz_search">mz_search</a></code>, can appear here, for example <code>size</code>,
<code>boundary.country</code>, etc.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mz_search">mz_search</a></code>
</p>

<hr>
<h2 id='mz_tile_coordinates'>Specify tile coordinates</h2><span id='topic+mz_tile_coordinates'></span><span id='topic+as.mz_tile_coordinates'></span><span id='topic+as.mz_tile_coordinates.mz_tile_coordinates'></span><span id='topic+as.mz_tile_coordinates.mz_bbox'></span><span id='topic+as.mz_tile_coordinates.mz_location'></span><span id='topic+as.mz_tile_coordinates.mz_geocode_result'></span>

<h3>Description</h3>

<p><code><a href="#topic+mz_vector_tiles">mz_vector_tiles</a></code> requires tile coordinates or some other
specification of the region that is to be drawn. <code><a href="#topic+mz_vector_tiles">mz_vector_tiles</a></code>
will automatically convert its inputs to vector tiles, so you generally won't
need to use this function directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mz_tile_coordinates(x, y, z)

as.mz_tile_coordinates(obj, ...)

## S3 method for class 'mz_tile_coordinates'
as.mz_tile_coordinates(obj, ...)

## S3 method for class 'mz_bbox'
as.mz_tile_coordinates(obj, ..., z = NULL, height = NULL, width = NULL)

## S3 method for class 'mz_location'
as.mz_tile_coordinates(obj, ..., z = 15L)

## S3 method for class 'mz_geocode_result'
as.mz_tile_coordinates(obj, ..., z = 15L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mz_tile_coordinates_+3A_x">x</code></td>
<td>
<p>integer vector of x-coordinates</p>
</td></tr>
<tr><td><code id="mz_tile_coordinates_+3A_y">y</code></td>
<td>
<p>integer vector of y-coordinates</p>
</td></tr>
<tr><td><code id="mz_tile_coordinates_+3A_z">z</code></td>
<td>
<p>integer between 0 and 19 specifying the zoom level</p>
</td></tr>
<tr><td><code id="mz_tile_coordinates_+3A_obj">obj</code></td>
<td>
<p>An object that can be converted to tile coordinates</p>
</td></tr>
<tr><td><code id="mz_tile_coordinates_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods</p>
</td></tr>
<tr><td><code id="mz_tile_coordinates_+3A_height">height</code></td>
<td>
<p>Height in pixels</p>
</td></tr>
<tr><td><code id="mz_tile_coordinates_+3A_width">width</code></td>
<td>
<p>Width in pixels</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mz_vector_tiles">mz_vector_tiles</a></code>, <code><a href="#topic+mz_bbox">mz_bbox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mz_tile_coordinates(19293, 24641, 16)

## can specify multiple contiguous tiles:
mz_tile_coordinates(19293:19294, 24641:24642, 16)

## a rectangular bounding box can be converted to tile coordinates:
as.mz_tile_coordinates(mz_rect(min_lon = -122.2856,
                               min_lat = 37.73742,
                               max_lon = -122.1749,
                               max_lat = 37.84632))

## zoom level is calculated based on desired pixel dimensions of the map:
as.mz_tile_coordinates(mz_rect(min_lon = -122.2856,
                               min_lat = 37.73742,
                               max_lon = -122.1749,
                               max_lat = 37.84632), height = 750, width = 1000)

## a bounding box can also be calculated:
as.mz_tile_coordinates(mz_bbox(oakland_public))

</code></pre>

<hr>
<h2 id='mz_vector_tiles'>Request vector tile data</h2><span id='topic+mz_vector_tiles'></span>

<h3>Description</h3>

<p>From <a href="https://tilezen.readthedocs.io/en/latest/">https://tilezen.readthedocs.io/en/latest/</a>: &quot;Vector tiles are
square-shaped collections of geographic data that contain the map feature
geometry, such as lines and points.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mz_vector_tiles(tile_coordinates, ..., Origin = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mz_vector_tiles_+3A_tile_coordinates">tile_coordinates</code></td>
<td>
<p>an <code><a href="#topic+mz_tile_coordinates">mz_tile_coordinates</a></code> object, or something
that can be coerced to one (including the output of <code><a href="#topic+mz_bbox">mz_bbox</a></code>)</p>
</td></tr>
<tr><td><code id="mz_vector_tiles_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="#topic+as.mz_tile_coordinates">as.mz_tile_coordinates</a></code>.</p>
</td></tr>
<tr><td><code id="mz_vector_tiles_+3A_origin">Origin</code></td>
<td>
<p>optional, specify Origin URL in request header</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiple tiles are stitched together and returned as one object. Individual
layers can be converted to <code>sf</code> or <code>sp</code>, making it possible to
draw each layer with custom styles.
</p>


<h3>Value</h3>

<p>A list of tile layers (such as &quot;water&quot;, &quot;buildings&quot;, &quot;roads&quot;, etc.).
Each layer is an object of class <code>mapzen_vector_layer</code>, which can be converted
to <code>sf</code> using <code><a href="#topic+as_sf">as_sf</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mz_tile_coordinates">mz_tile_coordinates</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# vector tile at x = 19293, y = 24641, and zoom level 16
mz_vector_tiles(mz_tile_coordinates(19293, 24641, 16))

# multiple contiguous tiles will be stitched together
# this returns the result of stitching together 4 tiles
mz_vector_tiles(mz_tile_coordinates(19293:19294, 24641:24642, 16))

# can also use a bounding box:
mz_vector_tiles(mz_rect(min_lon = -122.2856,
                        min_lat = 37.73742,
                        max_lon = -122.1749,
                        max_lat = 37.84632))

# mz_bbox returns a bounding box for any Mapzen object
mz_vector_tiles(mz_bbox(oakland_public))

# bounding boxes are automatically converted to tile coordinates,
# with the zoom level based on the desired size in pixels of the final map
mz_vector_tiles(mz_bbox(oakland_public), height = 750, width = 1000)

## End(Not run)

</code></pre>

<hr>
<h2 id='oakland_public'>25 search results for &quot;Oakland Public library branch&quot;</h2><span id='topic+oakland_public'></span>

<h3>Description</h3>

<p>Contains the search results from Mapzen's search service for the query
&quot;Oakland public library branch&quot; as of January 8, 2017.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oakland_public
</code></pre>


<h3>Format</h3>

<p>A <code>mapzen_geo_list</code> with 25 locations
</p>


<h3>Source</h3>

<p>Mapzen, OpenStreetMap, OpenAddresses, GeoNames, WhosOnFirst,
see <a href="https://www.mapzen.com/rights/">https://www.mapzen.com/rights/</a>
</p>

<hr>
<h2 id='rmapzen-package'>rmapzen: A client application for the 'Mapzen' API.</h2><span id='topic+rmapzen'></span><span id='topic+rmapzen-package'></span>

<h3>Description</h3>

<p>The rmapzen package provides interfaces to the Search
&lt;https://github.com/pelias/documentation/&gt;, Isochrone
&lt;https://valhalla.readthedocs.io/en/latest/&gt;,
and Vector Tile &lt;https://tilezen.readthedocs.io/en/latest/&gt;
services from 'Mapzen', via the following functions:
</p>


<h3>Search</h3>

<p>All functionality described in &lt;https://github.com/pelias/documentation/&gt;
are supported:
</p>

<ul>
<li> <p><code><a href="#topic+mz_search">mz_search</a></code>
</p>
</li>
<li> <p><code><a href="#topic+mz_reverse_geocode">mz_reverse_geocode</a></code>
</p>
</li>
<li> <p><code><a href="#topic+mz_autocomplete">mz_autocomplete</a></code>
</p>
</li>
<li> <p><code><a href="#topic+mz_place">mz_place</a></code>
</p>
</li>
<li> <p><code><a href="#topic+mz_structured_search">mz_structured_search</a></code>
</p>
</li></ul>

<p>Additionally, <code><a href="#topic+mz_geocode">mz_geocode</a></code> is useful for a common application of
search, that of just obtaining latitude and longitude for a given address or place.
</p>


<h3>Isochrone</h3>

<p>Isochrones are the areas reachable from a given location within a specified
period of time. Mapzen's Isochrone service can calculate isochrones for driving,
walking, cycling, or multimodal forms of transport:
</p>

<ul>
<li> <p><code><a href="#topic+mz_isochrone">mz_isochrone</a></code>
</p>
</li>
<li> <p><code><a href="#topic+mz_costing">mz_costing</a></code>: for constructing &quot;costing models&quot; that describe
method of transport along with speed and other options relevant to the
calculation of the isochrone
</p>
</li>
<li> <p><code><a href="#topic+mz_costing_options">mz_costing_options</a></code>: for selecting specific options when
constructing a costing model
</p>
</li></ul>



<h3>Vector Tiles</h3>


<ul>
<li> <p><code><a href="#topic+mz_vector_tiles">mz_vector_tiles</a></code>: Request one or more adjacent tiles.
Multiple map tiles will be stitched together before being returned as a single
object.
</p>
</li>
<li> <p><code><a href="#topic+mz_tile_coordinates">mz_tile_coordinates</a></code>: When using <code><a href="#topic+mz_vector_tiles">mz_vector_tiles</a></code>,
you must specify the geographic area for which you want tile data. One way to do so
is using the x, y, z tile naming system (see &lt;https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames&gt;).
</p>
</li>
<li> <p><code><a href="#topic+mz_rect">mz_rect</a></code>: Alternatively, you can specify the lower left
and top-right points of a bounding box, which will automatically be converted
to tile-coordinates when you use <code><a href="#topic+mz_vector_tiles">mz_vector_tiles</a></code>
</p>
</li>
<li> <p><code><a href="#topic+mz_bbox">mz_bbox</a></code>: This is a generic function which will return
the bounding box of any Mapzen object. In this way, you can request vector
tiles for a region defined as the bounding box of an existing object.
</p>
</li></ul>



<h3>Data types and conversion</h3>

<p>Objects returned by rmapzen can be converted to
simple features (sf) via the generic function
<code><a href="#topic+as_sf">as_sf</a></code>. Search
and Isochrone objects can additionally be converted to ordinary data.frames
via <code>as.data.frame</code>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Tarak Shah <a href="mailto:tarak.shah@gmail.com">tarak.shah@gmail.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Daniel Possenriede [contributor]
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li><p> &lt;https://tarakc02.github.io/rmapzen/&gt; contains detailed examples
</p>
</li>
<li><p> &lt;https://www.mapzen.com/documentation/&gt; 'Mapzen' documentation
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
