<!DOCTYPE html><html><head><title>Help for package unitquantreg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {unitquantreg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#unitquantreg-package'><p>Overview of the <span class="pkg">unitquantreg</span> package</p></a></li>
<li><a href='#ashw'><p>The arcsecant hyperbolic Weibull distribution</p></a></li>
<li><a href='#bodyfat'><p>Percentage of body fat data set</p></a></li>
<li><a href='#hnp'><p>(Half-)Normal probability plots with simulated envelopes for</p>
<code>unitquantreg</code> objects</a></li>
<li><a href='#johnsonsb'><p>The Johnson SB distribution</p></a></li>
<li><a href='#kum'><p>The Kumaraswamy distribution</p></a></li>
<li><a href='#leeg'><p>The Log-extended exponential-geometric distribution</p></a></li>
<li><a href='#likelihood_stats'><p>Likelihood-based statistics of fit for <code>unitquantreg</code> objects.</p></a></li>
<li><a href='#loglike_unitquantreg'><p>Log-likelihood, score vector and hessian matrix.</p></a></li>
<li><a href='#methods-unitquantreg'><p>Methods for <code>unitquantreg</code> and <code>unitquantregs</code> objects</p></a></li>
<li><a href='#pairwise.vuong.test'><p>Pairwise vuong test</p></a></li>
<li><a href='#plot.unitquantreg'><p>Plot method for <code>unitquantreg</code> objects</p></a></li>
<li><a href='#plot.unitquantregs'><p>Plot method for <code>unitquantregs</code> objects</p></a></li>
<li><a href='#predict.unitquantreg'><p>Prediction method for <code>unitquantreg</code> class</p></a></li>
<li><a href='#residuals.unitquantreg'><p>Residuals method for <code>unitquantreg</code> objects</p></a></li>
<li><a href='#sim_bounded'><p>Simulated data set</p></a></li>
<li><a href='#ubs'><p>The unit-Birnbaum-Saunders distribution</p></a></li>
<li><a href='#uburrxii'><p>The unit-Burr-XII distribution</p></a></li>
<li><a href='#uchen'><p>The unit-Chen distribution</p></a></li>
<li><a href='#ughne'><p>The unit-Half-Normal-E distribution</p></a></li>
<li><a href='#ughnx'><p>The unit-Half-Normal-X distribution</p></a></li>
<li><a href='#ugompertz'><p>The unit-Gompertz distribution</p></a></li>
<li><a href='#ugumbel'><p>The unit-Gumbel distribution</p></a></li>
<li><a href='#ulogistic'><p>The unit-Logistic distribution</p></a></li>
<li><a href='#unitquantreg'><p>Parametric unit quantile regression models</p></a></li>
<li><a href='#unitquantreg.control'><p>Control parameters for unit quantile regression</p></a></li>
<li><a href='#uweibull'><p>The unit-Weibull distribution</p></a></li>
<li><a href='#vuong.test'><p>Vuong test</p></a></li>
<li><a href='#water'><p>Access to piped water supply data set</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Parametric Quantile Regression Models for Bounded Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.6</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>André F. B. Menezes &lt;andrefelipemaringa@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of parametric quantile regression models for bounded data. At present, the package provides 13 parametric quantile regression models. It can specify regression structure for any quantile and shape parameters. It also provides several S3 methods to extract information from fitted model, such as residual analysis, prediction, plotting, and model comparison. For more computation efficient the [dpqr]'s, likelihood, score and hessian functions are written in C++. For further details see Mazucheli et. al (2022) &lt;<a href="https://doi.org/10.1016%2Fj.cmpb.2022.106816">doi:10.1016/j.cmpb.2022.106816</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, optimx, stats, quantreg, Formula, MASS, numDeriv</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), rmarkdown, knitr, lmtest, ggplot2, covr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://andrmenezes.github.io/unitquantreg/">https://andrmenezes.github.io/unitquantreg/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/AndrMenezes/unitquantreg/issues">https://github.com/AndrMenezes/unitquantreg/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-05 09:00:00 UTC; amenezes</td>
</tr>
<tr>
<td>Author:</td>
<td>André F. B. Menezes
    <a href="https://orcid.org/0000-0002-3320-9834"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Josmar Mazucheli <a href="https://orcid.org/0000-0001-6740-0445"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-06 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='unitquantreg-package'>Overview of the <span class="pkg">unitquantreg</span> package</h2><span id='topic+unitquantreg-package'></span>

<h3>Description</h3>

<p>The <span class="pkg">unitquantreg</span> R package provides a collection of
parametric quantile regression models for bounded data. At present, the
package provides 13 parametric quantile regression models. It also enables
several S3 methods to extract information from fitted model, such as
residual analysis, prediction, plotting, and model comparison.
</p>


<h3>Author(s)</h3>

<p>André F. B. Menezes <a href="mailto:andrefelipemaringa@gmail.com">andrefelipemaringa@gmail.com</a>
</p>
<p>Josmar Mazucheli <a href="mailto:jmazucheli@gmail.com">jmazucheli@gmail.com</a>
</p>

<hr>
<h2 id='ashw'>The arcsecant hyperbolic Weibull distribution</h2><span id='topic+ashw'></span><span id='topic+dashw'></span><span id='topic+pashw'></span><span id='topic+qashw'></span><span id='topic+rashw'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and random number generation function
for the arcsecant hyperbolic Weibull distribution reparametrized in terms of the <code class="reqn">\tau</code>-th quantile, <code class="reqn">\tau \in (0, 1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dashw(x, mu, theta, tau = 0.5, log = FALSE)

pashw(q, mu, theta, tau = 0.5, lower.tail = TRUE, log.p = FALSE)

qashw(p, mu, theta, tau = 0.5, lower.tail = TRUE, log.p = FALSE)

rashw(n, mu, theta, tau = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ashw_+3A_x">x</code>, <code id="ashw_+3A_q">q</code></td>
<td>
<p>vector of positive quantiles.</p>
</td></tr>
<tr><td><code id="ashw_+3A_mu">mu</code></td>
<td>
<p>location parameter indicating the <code class="reqn">\tau</code>-th quantile, <code class="reqn">\tau \in (0, 1)</code>.</p>
</td></tr>
<tr><td><code id="ashw_+3A_theta">theta</code></td>
<td>
<p>shape parameter.</p>
</td></tr>
<tr><td><code id="ashw_+3A_tau">tau</code></td>
<td>
<p>the parameter to specify which quantile use in the parametrization.</p>
</td></tr>
<tr><td><code id="ashw_+3A_log">log</code>, <code id="ashw_+3A_log.p">log.p</code></td>
<td>
<p>logical; If TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="ashw_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; If TRUE, (default), <code class="reqn">P(X \leq x)</code> are returned, otherwise <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="ashw_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="ashw_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">f(y;\alpha, \theta)=\frac{\alpha \theta}{y\sqrt{1-y^2}} \mathrm{arcsech}(y)^{\theta-1}\exp\left [ -\alpha \mathrm{arcsech}(y)^\theta \right ]</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">F(y;\alpha, \theta)=\exp\left [ -\alpha \mathrm{arcsech}(y)^\theta \right ]</code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn">Q(\tau;\alpha, \theta)= \mathrm{sech}\left \{ \left [ -\alpha^{-1} \log(\tau)\right ]^{\frac{1}{\theta}} \right \}</code>
</p>

<p>Reparameterization
</p>
<p style="text-align: center;"><code class="reqn">\alpha = g^{-1}(\mu) = -\frac{\log(\tau)}{\mathrm{arcsech}(\mu)^\theta}</code>
</p>

<p>where <code class="reqn">\theta &gt;0</code> is the shape parameter and <code class="reqn">\mathrm{arcsech}(y)= \log\left[\left( 1+\sqrt{1-y^2} \right)/y \right]</code>.
</p>


<h3>Value</h3>

<p><code>dashw</code> gives the density, <code>pashw</code> gives the distribution function,
<code>qashw</code> gives the quantile function and <code>rashw</code> generates random deviates.
</p>
<p>Invalid arguments will return an error message.
</p>


<h3>Author(s)</h3>

<p>Josmar Mazucheli
</p>
<p>André F. B. Menezes
</p>


<h3>References</h3>

<p>Korkmaz, M. C., Chesneau, C. and Korkmaz, Z. S., (2021). A new alternative quantile regression model for the bounded response with educational measurements applications of OECD countries. <em>Journal of Applied Statistics</em>, 1&ndash;25.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(6969)
x &lt;- rashw(n = 1000, mu = 0.5, theta = 2.5, tau = 0.5)
R &lt;- range(x)
S &lt;- seq(from = R[1L], to = R[2L], by = 0.01)
hist(x, prob = TRUE, main = 'arcsecant hyperbolic Weibull')
lines(S, dashw(x = S, mu = 0.5, theta = 2.5, tau = 0.5), col = 2)
plot(ecdf(x))
lines(S, pashw(q = S, mu = 0.5, theta = 2.5, tau = 0.5), col = 2)
plot(quantile(x, probs = S), type = "l")
lines(qashw(p = S, mu = 0.5, theta = 2.5, tau = 0.5), col = 2)
</code></pre>

<hr>
<h2 id='bodyfat'>Percentage of body fat data set</h2><span id='topic+bodyfat'></span>

<h3>Description</h3>

<p>The body fat percentage of individuals assisted in a public
hospital in Curitiba, Paraná, Brasil.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bodyfat, package = "unitquantreg")
</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with 298 observations and 9 columns:
</p>

<ul>
<li> <p><code>arms</code>: Arms fat percentage.
</p>
</li>
<li> <p><code>legs</code>: Legs fat percentage.
</p>
</li>
<li> <p><code>body</code>: Body fat percentage.
</p>
</li>
<li> <p><code>android</code>: Android fat percentage.
</p>
</li>
<li> <p><code>gynecoid</code>: Ginecoid fat percentage.
</p>
</li>
<li> <p><code>bmi</code>: Body mass index - 24.71577.
</p>
</li>
<li> <p><code>age</code>: Age - 46.00.
</p>
</li>
<li> <p><code>sex</code>: Sex of individual. Female or male.
</p>
</li>
<li> <p><code>ipaq</code>: Factor variable indicating the sedentary, insufficiently
active or active.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>André F. B. Menezes
</p>
<p>Josmar Mazucheli
</p>


<h3>Source</h3>

<p><a href="http://www.leg.ufpr.br/doku.php/publications:papercompanions:multquasibeta">http://www.leg.ufpr.br/doku.php/publications:papercompanions:multquasibeta</a>
</p>


<h3>References</h3>

<p>Petterle, R. R., Bonat, W. H., Scarpin, C. T., Jonasson, T., and Borba, V. Z. C., (2020). Multivariate quasi-beta regression models for continuous bounded data. <em>The International Journal of Biostatistics</em>, 1&ndash;15, (preprint).
</p>
<p>Mazucheli, J., Leiva, V., Alves, B., and Menezes A. F. B., (2021). A new quantile regression for modeling bounded data under a unit Birnbaum-Saunders distribution with applications in medicine and politics. <em>Symmetry</em>, <b>13</b>(4) 1&ndash;21.
</p>

<hr>
<h2 id='hnp'>(Half-)Normal probability plots with simulated envelopes for
<code><a href="#topic+unitquantreg">unitquantreg</a></code> objects</h2><span id='topic+hnp'></span><span id='topic+hnp.unitquantreg'></span>

<h3>Description</h3>

<p>Produces a (half-)normal probability plot from a fitted model
object of class <code><a href="#topic+unitquantreg">unitquantreg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hnp(object, ...)

## S3 method for class 'unitquantreg'
hnp(
  object,
  nsim = 99,
  halfnormal = TRUE,
  plot = TRUE,
  output = TRUE,
  level = 0.95,
  resid.type = c("quantile", "cox-snell"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hnp_+3A_object">object</code></td>
<td>
<p>fitted model object of class <code><a href="#topic+unitquantreg">unitquantreg</a></code>.</p>
</td></tr>
<tr><td><code id="hnp_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
<tr><td><code id="hnp_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations used to compute envelope. Default is 99.</p>
</td></tr>
<tr><td><code id="hnp_+3A_halfnormal">halfnormal</code></td>
<td>
<p>logical. If <code>TRUE</code>, a half-normal plot is produced.
If <code>FALSE</code>, a normal plot is produced.</p>
</td></tr>
<tr><td><code id="hnp_+3A_plot">plot</code></td>
<td>
<p>Should the (half-)normal plot be plotted? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="hnp_+3A_output">output</code></td>
<td>
<p>Should the output be returned? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="hnp_+3A_level">level</code></td>
<td>
<p>confidence level of the simulated envelope. Default is 0.95.</p>
</td></tr>
<tr><td><code id="hnp_+3A_resid.type">resid.type</code></td>
<td>
<p>type of residuals to be used. The default is <code>quantile</code>.
See <code><a href="#topic+residuals.unitquantreg">residuals.unitquantreg</a></code> for further details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Residuals plots with simulated envelope were proposed by Atkinson (1981)
and can be construct as follows:
</p>

<ol>
<li><p>generate sample set of <code class="reqn">n</code> independent observations from the estimated
parameters of the fitted model;
</p>
</li>
<li><p>fit the model using the generated sample, if <code>halfnormal</code> is
<code>TRUE</code> compute the absolute values of the residuals and arrange them in order;
</p>
</li>
<li><p>repeat steps (1) and (2) <code>nsim</code> number of times;
</p>
</li>
<li><p>consider the <code class="reqn">n</code> sets of the <code>nsim</code> ordered statistics
of the residuals, then for each set compute the quantile <code>level</code>/2,
the median and the quantile 1 - <code>level</code>/2;
</p>
</li>
<li><p>plot these values and the ordered residuals of the original sample set
versus the expected order statistics of a (half)-normal distribution,
which is approximated as
</p>
<p style="text-align: center;"><code class="reqn">G^{-1} \left(\frac{i + n - 0.125}{2n + 0.5} \right)</code>
</p>

<p>for half-normal plots, i.e., <code>halfnormal=TRUE</code> or
</p>
<p style="text-align: center;"><code class="reqn">G^{-1} \left(\frac{i - 0.375}{n + 0.25}\right)</code>
</p>

<p>for normal plots, i.e., <code>halfnormal=FALSE</code>, where <code class="reqn">G(\cdot)</code> is the the
cumulative distribution function of standard Normal distribution for
<code>quantile</code> residuals or the standard exponential distribution for the
<code>cox-snell</code> residuals.
</p>
</li></ol>

<p>According to Atkinson (1981), if the model was correctly specified then no
more than <code>level</code>100% of the observations are expected to appear
outside the envelope bands. Additionally, if a large proportion of the
observations lies outside the envelope, thus one has evidence against
the adequacy of the fitted model.
</p>


<h3>Value</h3>

<p>A list with the following components in ordered
(and absolute if <code>halfnormal</code> is <code>TRUE</code>) values:
</p>
<table>
<tr><td><code>obs</code></td>
<td>
<p>the observed residuals.</p>
</td></tr>
<tr><td><code>teo</code></td>
<td>
<p>the theoretical residuals.</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower envelope band.</p>
</td></tr>
<tr><td><code>median</code></td>
<td>
<p>median envelope band.</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper envelope band.</p>
</td></tr>
<tr><td><code>time_elapsed</code></td>
<td>
<p>time elapsed to fit the <code>nsim</code> models.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>André F. B. Menezes
</p>


<h3>References</h3>

<p>Atkinson, A. C., (1981). Two graphical displays for outlying and influential observations in regression. <em>Biometrika</em> <b>68</b>(1), 13&ndash;20.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+residuals.unitquantreg">residuals.unitquantreg</a></code>
</p>

<hr>
<h2 id='johnsonsb'>The Johnson SB distribution</h2><span id='topic+johnsonsb'></span><span id='topic+djohnsonsb'></span><span id='topic+pjohnsonsb'></span><span id='topic+qjohnsonsb'></span><span id='topic+rjohnsonsb'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and random number generation function
for the Johnson SB distribution reparametrized in terms of the <code class="reqn">\tau</code>-th quantile, <code class="reqn">\tau \in (0, 1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>djohnsonsb(x, mu, theta, tau = 0.5, log = FALSE)

pjohnsonsb(q, mu, theta, tau = 0.5, lower.tail = TRUE, log.p = FALSE)

qjohnsonsb(p, mu, theta, tau = 0.5, lower.tail = TRUE, log.p = FALSE)

rjohnsonsb(n, mu, theta, tau = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="johnsonsb_+3A_x">x</code>, <code id="johnsonsb_+3A_q">q</code></td>
<td>
<p>vector of positive quantiles.</p>
</td></tr>
<tr><td><code id="johnsonsb_+3A_mu">mu</code></td>
<td>
<p>location parameter indicating the <code class="reqn">\tau</code>-th quantile, <code class="reqn">\tau \in (0, 1)</code>.</p>
</td></tr>
<tr><td><code id="johnsonsb_+3A_theta">theta</code></td>
<td>
<p>nonnegative shape parameter.</p>
</td></tr>
<tr><td><code id="johnsonsb_+3A_tau">tau</code></td>
<td>
<p>the parameter to specify which quantile is to used.</p>
</td></tr>
<tr><td><code id="johnsonsb_+3A_log">log</code>, <code id="johnsonsb_+3A_log.p">log.p</code></td>
<td>
<p>logical; If TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="johnsonsb_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; If TRUE, (default), <code class="reqn">P(X \leq{x})</code> are returned, otherwise <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="johnsonsb_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="johnsonsb_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">f(y\mid \alpha ,\theta )=\frac{\theta }{\sqrt{2\pi }}\frac{1}{y(1-y)}\exp\left\{ -\frac{1}{2}\left[\alpha +\theta \log\left(\frac{y}{1-y}\right)\right] ^{2}\right\}</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">F(y\mid \alpha ,\theta )=\Phi \left[ \alpha +\theta \log \left( \frac{y}{1-y}\right) \right]</code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn">Q(\tau \mid \alpha ,\theta )=\frac{\exp \left[ \frac{\Phi ^{-1}(\tau)-\alpha }{\theta }\right] }{1+\exp \left[ \frac{\Phi ^{-1}(\tau )-\alpha }{\theta }\right] }</code>
</p>

<p>Reparameterization
</p>
<p style="text-align: center;"><code class="reqn">\alpha =g^{-1}(\mu )=\Phi ^{-1}(\tau )-\theta \log \left( \frac{\mu }{1-\mu }\right)</code>
</p>



<h3>Value</h3>

<p><code>djohnsonsb</code> gives the density, <code>pjohnsonsb</code> gives the distribution function,
<code>qjohnsonsb</code> gives the quantile function and <code>rjohnsonsb</code> generates random deviates.
</p>
<p>Invalid arguments will return an error message.
</p>


<h3>Author(s)</h3>

<p>Josmar Mazucheli
</p>
<p>André F. B. Menezes
</p>


<h3>References</h3>

<p>Lemonte, A. J. and Bazán, J. L., (2015). New class of Johnson SB distributions and its associated regression model for rates and proportions. <em>Biometrical Journal</em>, <b>58</b>(4), 727&ndash;746.
</p>
<p>Johnson, N. L., (1949). Systems of frequency curves generated by methods of translation. <em>Biometrika</em>, <b>36</b>(1), 149&ndash;176.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
x &lt;- rjohnsonsb(n = 1000, mu = 0.5, theta = 1.5, tau = 0.5)
R &lt;- range(x)
S &lt;- seq(from = R[1], to = R[2], by =  0.01)
hist(x, prob = TRUE, main = 'Johnson SB')
lines(S, djohnsonsb(x = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)
plot(ecdf(x))
lines(S, pjohnsonsb(q = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)
plot(quantile(x, probs = S), type = "l")
lines(qjohnsonsb(p = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)

</code></pre>

<hr>
<h2 id='kum'>The Kumaraswamy distribution</h2><span id='topic+kum'></span><span id='topic+dkum'></span><span id='topic+pkum'></span><span id='topic+qkum'></span><span id='topic+rkum'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and random number generation for the Kumaraswamy distribution  reparametrized in terms of the <code class="reqn">\tau</code>-th quantile, <code class="reqn">\tau \in (0, 1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dkum(x, mu, theta, tau = 0.5, log = FALSE)

pkum(q, mu, theta, tau = 0.5, lower.tail = TRUE, log.p = FALSE)

qkum(p, mu, theta, tau = 0.5, lower.tail = TRUE, log.p = FALSE)

rkum(n, mu, theta, tau = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kum_+3A_x">x</code>, <code id="kum_+3A_q">q</code></td>
<td>
<p>vector of positive quantiles.</p>
</td></tr>
<tr><td><code id="kum_+3A_mu">mu</code></td>
<td>
<p>location parameter indicating the <code class="reqn">\tau</code>-th quantile, <code class="reqn">\tau \in (0, 1)</code>.</p>
</td></tr>
<tr><td><code id="kum_+3A_theta">theta</code></td>
<td>
<p>nonnegative shape parameter.</p>
</td></tr>
<tr><td><code id="kum_+3A_tau">tau</code></td>
<td>
<p>the parameter to specify which quantile is to used.</p>
</td></tr>
<tr><td><code id="kum_+3A_log">log</code>, <code id="kum_+3A_log.p">log.p</code></td>
<td>
<p>logical; If TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="kum_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; If TRUE, (default), <code class="reqn">P(X \leq{x})</code> are returned, otherwise <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="kum_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="kum_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">f(y\mid \alpha ,\theta )=\alpha \theta y^{\theta -1}(1-y^{\theta })^{\alpha-1}</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">F(y\mid \alpha ,\theta )=1-\left( 1-y^{\theta }\right) ^{\alpha }</code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn">Q(\tau \mid \alpha ,\theta )=\left[ 1-\left( 1-\tau \right) ^{\frac{1}{\alpha }}\right] ^{\frac{1}{\theta }}</code>
</p>

<p>Reparameterization
</p>
<p style="text-align: center;"><code class="reqn">\alpha=g^{-1}(\mu )=\frac{\log (1-\tau )}{\log (1-\mu ^{\theta })}</code>
</p>



<h3>Value</h3>

<p><code>dkum</code> gives the density, <code>pkum</code> gives the distribution function,
<code>qkum</code> gives the quantile function and <code>rkum</code> generates random deviates.
</p>
<p>Invalid arguments will return an error message.
</p>


<h3>Author(s)</h3>

<p>Josmar Mazucheli
</p>
<p>André F. B. Menezes
</p>


<h3>References</h3>

<p>Kumaraswamy, P., (1980). A generalized probability density function for double-bounded random processes. <em>Journal of Hydrology</em>, <b>46</b>(1), 79&ndash;88.
</p>
<p>Jones, M. C., (2009). Kumaraswamy's distribution: A beta-type distribution with some tractability advantages. <em>Statistical Methodology</em>, <b>6</b>(1), 70-81.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- rkum(n = 1000, mu = 0.5, theta = 1.5, tau = 0.5)
R &lt;- range(x)
S &lt;- seq(from = R[1], to = R[2], by =  0.01)
hist(x, prob = TRUE, main = 'Kumaraswamy')
lines(S, dkum(x = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)
plot(ecdf(x))
lines(S, pkum(q = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)
plot(quantile(x, probs = S), type = "l")
lines(qkum(p = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)
</code></pre>

<hr>
<h2 id='leeg'>The Log-extended exponential-geometric distribution</h2><span id='topic+leeg'></span><span id='topic+dleeg'></span><span id='topic+pleeg'></span><span id='topic+qleeg'></span><span id='topic+rleeg'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and random number generation function
for the Log-extended exponential-geometric distribution reparametrized in terms of the <code class="reqn">\tau</code>-th quantile, <code class="reqn">\tau \in (0, 1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dleeg(x, mu, theta, tau = 0.5, log = FALSE)

pleeg(q, mu, theta, tau = 0.5, lower.tail = TRUE, log.p = FALSE)

qleeg(p, mu, theta, tau = 0.5, lower.tail = TRUE, log.p = FALSE)

rleeg(n, mu, theta, tau = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leeg_+3A_x">x</code>, <code id="leeg_+3A_q">q</code></td>
<td>
<p>vector of positive quantiles.</p>
</td></tr>
<tr><td><code id="leeg_+3A_mu">mu</code></td>
<td>
<p>location parameter indicating the <code class="reqn">\tau</code>-th quantile, <code class="reqn">\tau \in (0, 1)</code>.</p>
</td></tr>
<tr><td><code id="leeg_+3A_theta">theta</code></td>
<td>
<p>nonnegative shape parameter.</p>
</td></tr>
<tr><td><code id="leeg_+3A_tau">tau</code></td>
<td>
<p>the parameter to specify which quantile is to be used.</p>
</td></tr>
<tr><td><code id="leeg_+3A_log">log</code>, <code id="leeg_+3A_log.p">log.p</code></td>
<td>
<p>logical; If TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="leeg_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; If TRUE, (default), <code class="reqn">P(X \leq{x})</code> are returned, otherwise <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="leeg_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="leeg_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">f(y\mid \alpha ,\theta )=\frac{\theta \left( 1+\alpha \right) y^{\theta -1}}{\left( 1+\alpha y^{\theta }\right) ^{2}}</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">F(y\mid \alpha ,\theta )=\frac{\left( 1+\alpha \right) y^{\theta }}{1+\alpha y^{\theta }}</code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn">Q(\tau \mid \alpha ,\theta )=\left[ \frac{\tau }{1+\alpha \left( 1-\tau\right) }\right] ^{\frac{1}{\theta }}</code>
</p>

<p>Reparameterization
</p>
<p style="text-align: center;"><code class="reqn">\alpha=g^{-1}(\mu )=-\frac{1-\tau \mu ^{\theta }}{\left( 1-\tau \right) }</code>
</p>



<h3>Value</h3>

<p><code>dleeg</code> gives the density, <code>pleeg</code> gives the distribution function,
<code>qleeg</code> gives the quantile function and <code>rleeg</code> generates random deviates.
</p>
<p>Invalid arguments will return an error message.
</p>


<h3>Author(s)</h3>

<p>Josmar Mazucheli <a href="mailto:jmazucheli@gmail.com">jmazucheli@gmail.com</a>
</p>
<p>André F. B. Menezes <a href="mailto:andrefelipemaringa@gmail.com">andrefelipemaringa@gmail.com</a>
</p>


<h3>References</h3>

<p>Jodrá, P. and Jiménez-Gamero, M. D., (2020). A quantile regression model for bounded responses based on the exponential-geometric distribution. <em>Revstat - Statistical Journal</em>, <b>18</b>(4), 415&ndash;436.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- rleeg(n = 1000, mu = 0.5, theta = 1.5, tau = 0.5)
R &lt;- range(x)
S &lt;- seq(from = R[1], to = R[2], by =  0.01)
hist(x, prob = TRUE, main = 'Log-extended exponential-geometric')
lines(S, dleeg(x = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)
plot(ecdf(x))
lines(S, pleeg(q = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)
plot(quantile(x, probs = S), type = "l")
lines(qleeg(p = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)
</code></pre>

<hr>
<h2 id='likelihood_stats'>Likelihood-based statistics of fit for <code>unitquantreg</code> objects.</h2><span id='topic+likelihood_stats'></span><span id='topic+print.likelihood_stats'></span>

<h3>Description</h3>

<p>Computes the likelihood-based statistics (Neg2LogLike, AIC, BIC and HQIC)
from <code>unitquantreg</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likelihood_stats(..., lt = NULL)

## S3 method for class 'likelihood_stats'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="likelihood_stats_+3A_...">...</code></td>
<td>
<p><code><a href="#topic+unitquantreg">unitquantreg</a></code> objects separated by commas.
Not use in <code>print</code> method.</p>
</td></tr>
<tr><td><code id="likelihood_stats_+3A_lt">lt</code></td>
<td>
<p>a list with one or more <code><a href="#topic+unitquantreg">unitquantreg</a></code> objects.</p>
</td></tr>
<tr><td><code id="likelihood_stats_+3A_x">x</code></td>
<td>
<p>object of class <code>likelihood_stats</code> obtained from <code>likelihood_stats</code>
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Neg2LogLike: The log-likelihood is reported as </p>
<p style="text-align: center;"><code class="reqn">Neg2LogLike= -2\log(L)</code>
</p>

<p>AIC: The Akaike's information criterion (AIC) is defined as </p>
<p style="text-align: center;"><code class="reqn">AIC = -2\log(L)+2p</code>
</p>

<p>BIC: The Schwarz Bayesian information criterion (BIC) is defined as </p>
<p style="text-align: center;"><code class="reqn">BIC =  -2\log(L) + p\log(n)</code>
</p>

<p>HQIC: The Hannan and Quinn information criterion (HQIC)  is defined as </p>
<p style="text-align: center;"><code class="reqn">HQIC =  -2\log(L) + 2p\log[\log(n)]</code>
</p>

<p>where <code class="reqn">L</code> is the likelihood function.
</p>


<h3>Value</h3>

<p>A list with class <code>"likelihood_stats"</code> containing the following
components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>
<p>ordered matrix according AIC value containg the likelihood
based statistics.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>André F. B. Menezes
</p>
<p>Josmar Mazucheli
</p>


<h3>References</h3>

<p>Akaike, H. (1974). A new look at the statistical model identification. <em>IEEE Transaction on Automatic Control</em>, <b>19</b>(6), 716&ndash;723.
</p>
<p>Hannan, E. J. and Quinn, B. G. (1979). The determination of the order of an autoregression. <em>Journal of the Royal Statistical Society, Series B</em>, <b>41</b>(2), 190&ndash;195.
</p>
<p>Schwarz, G. (1978). Estimating the dimension of a model. <em>Annals of Statistics</em>, <b>6</b>(2), 461&ndash;464.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim_bounded, package = "unitquantreg")
sim_bounded_curr &lt;- sim_bounded[sim_bounded$family == "uweibull", ]

models &lt;- c("uweibull", "kum", "ulogistic")
lt_fits &lt;- lapply(models, function(fam) {
  unitquantreg(formula = y1 ~ x, tau = 0.5, data = sim_bounded_curr,
               family = fam)
})

ans &lt;- likelihood_stats(lt = lt_fits)
ans

</code></pre>

<hr>
<h2 id='loglike_unitquantreg'>Log-likelihood, score vector and hessian matrix.</h2><span id='topic+loglike_unitquantreg'></span>

<h3>Description</h3>

<p>Internal functions using in <code><a href="#topic+unitquantreg.fit">unitquantreg.fit</a></code>
to compute the negative log-likelihood function, the score vector and the hessian
matrix using analytic expressions written in <code>C++</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglike_unitquantreg(par, tau, family, linkobj, linkobj.theta, X, Z, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglike_unitquantreg_+3A_par">par</code></td>
<td>
<p>vector of regression model coefficients for <code class="reqn">\mu</code> and/or
<code class="reqn">\theta</code>.</p>
</td></tr>
<tr><td><code id="loglike_unitquantreg_+3A_tau">tau</code></td>
<td>
<p>quantile level, value between 0 and 1.</p>
</td></tr>
<tr><td><code id="loglike_unitquantreg_+3A_family">family</code></td>
<td>
<p>specify the distribution family name.</p>
</td></tr>
<tr><td><code id="loglike_unitquantreg_+3A_linkobj">linkobj</code>, <code id="loglike_unitquantreg_+3A_linkobj.theta">linkobj.theta</code></td>
<td>
<p>a function, usually obtained from
<code><a href="stats.html#topic+make.link">make.link</a></code> for link function of <code class="reqn">\mu</code> and <code class="reqn">\theta</code>,
respectively.</p>
</td></tr>
<tr><td><code id="loglike_unitquantreg_+3A_x">X</code></td>
<td>
<p>design matrix related to the <code class="reqn">\mu</code> parameter.</p>
</td></tr>
<tr><td><code id="loglike_unitquantreg_+3A_z">Z</code></td>
<td>
<p>design matrix related to the <code class="reqn">\theta</code> parameter.</p>
</td></tr>
<tr><td><code id="loglike_unitquantreg_+3A_y">y</code></td>
<td>
<p>vector of response variable.</p>
</td></tr>
</table>

<hr>
<h2 id='methods-unitquantreg'>Methods for <code>unitquantreg</code> and <code>unitquantregs</code> objects</h2><span id='topic+methods-unitquantreg'></span><span id='topic+print.unitquantreg'></span><span id='topic+summary.unitquantreg'></span><span id='topic+coef.unitquantreg'></span><span id='topic+vcov.unitquantreg'></span><span id='topic+logLik.unitquantreg'></span><span id='topic+confint.unitquantreg'></span><span id='topic+fitted.unitquantreg'></span><span id='topic+terms.unitquantreg'></span><span id='topic+model.frame.unitquantreg'></span><span id='topic+model.matrix.unitquantreg'></span><span id='topic+update.unitquantreg'></span><span id='topic+print.unitquantregs'></span><span id='topic+summary.unitquantregs'></span>

<h3>Description</h3>

<p>Methods for extracting information from fitted regression models
objects of class <code>unitquantreg</code> and <code>unitquantregs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'unitquantreg'
print(x, digits = max(4, getOption("digits") - 3), ...)

## S3 method for class 'unitquantreg'
summary(object, correlation = FALSE, ...)

## S3 method for class 'unitquantreg'
coef(object, type = c("full", "quantile", "shape"), ...)

## S3 method for class 'unitquantreg'
vcov(object, ...)

## S3 method for class 'unitquantreg'
logLik(object, ...)

## S3 method for class 'unitquantreg'
confint(object, parm, level = 0.95, ...)

## S3 method for class 'unitquantreg'
fitted(object, type = c("quantile", "shape", "full"), ...)

## S3 method for class 'unitquantreg'
terms(x, type = c("quantile", "shape"), ...)

## S3 method for class 'unitquantreg'
model.frame(formula, ...)

## S3 method for class 'unitquantreg'
model.matrix(object, type = c("quantile", "shape"), ...)

## S3 method for class 'unitquantreg'
update(object, formula., ..., evaluate = TRUE)

## S3 method for class 'unitquantregs'
print(x, digits = max(3, getOption("digits") - 3), ...)

## S3 method for class 'unitquantregs'
summary(object, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods-unitquantreg_+3A_digits">digits</code></td>
<td>
<p>minimal number of <em>significant</em> digits.</p>
</td></tr>
<tr><td><code id="methods-unitquantreg_+3A_...">...</code></td>
<td>
<p>additional argument(s) for methods. Currently not used.</p>
</td></tr>
<tr><td><code id="methods-unitquantreg_+3A_object">object</code>, <code id="methods-unitquantreg_+3A_x">x</code></td>
<td>
<p>fitted model object of class <code><a href="#topic+unitquantreg">unitquantreg</a></code>.</p>
</td></tr>
<tr><td><code id="methods-unitquantreg_+3A_correlation">correlation</code></td>
<td>
<p>logical; if <code>TRUE</code>, the correlation matrix of the estimated parameters is returned and printed. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="methods-unitquantreg_+3A_type">type</code></td>
<td>
<p>character indicating type of fitted values to return.</p>
</td></tr>
<tr><td><code id="methods-unitquantreg_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters are to be given confidence intervals, either a vector of numbers or a vector of names. If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="methods-unitquantreg_+3A_level">level</code></td>
<td>
<p>the confidence level required.</p>
</td></tr>
<tr><td><code id="methods-unitquantreg_+3A_formula">formula</code></td>
<td>
<p>an R formula.</p>
</td></tr>
<tr><td><code id="methods-unitquantreg_+3A_formula.">formula.</code></td>
<td>
<p>Changes to the formula see <code><a href="stats.html#topic+update.formula">update.formula</a></code> for details.</p>
</td></tr>
<tr><td><code id="methods-unitquantreg_+3A_evaluate">evaluate</code></td>
<td>
<p>If true evaluate the new call else return the call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>summary</code> method gives Wald tests for the regressions coefficients
based on the observed Fisher information matrix. As usual the <code>summary</code>
method returns a list with relevant model statistics and estimates, which
can be printed using the <code>print</code> method.
</p>
<p>The <code>coef</code>, <code>vcov</code>, <code>confint</code> and <code>fitted</code> methods can
be use to extract, respectively, the estimated coefficients, the
estimated covariance matrix, the Wald confidence intervals, and fitted
values.
</p>
<p>A <code><a href="stats.html#topic+logLik">logLik</a></code> method is also provide, then the <code><a href="stats.html#topic+AIC">AIC</a></code>
function can be use to calculated the Akaike Information Criterion.
</p>
<p>The generic methods <code><a href="stats.html#topic+terms">terms</a></code>, <code><a href="stats.html#topic+model.frame">model.frame</a></code>,
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>, <code><a href="stats.html#topic+update">update</a></code> and are also provided.
</p>


<h3>Author(s)</h3>

<p>André F. B. Menezes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim_bounded, package = "unitquantreg")
sim_bounded_curr &lt;- sim_bounded[sim_bounded$family == "uweibull", ]
fit_1 &lt;- unitquantreg(formula = y1 ~ x + z + I(x^2) | z + x,
                      data = sim_bounded_curr,
                      family = "uweibull",
                      tau = 0.5, link.theta = "log")
fit_1
summary(fit_1)
vcov(fit_1)
coef(fit_1)
confint(fit_1)
terms(fit_1)
model.frame(fit_1)[1:5, ]
model.matrix(fit_1)[1:5, ]
update(fit_1, . ~ . -x)
update(fit_1, . ~ . -z)
update(fit_1, . ~ . -I(x^2))
update(fit_1, . ~ . | . -z)
update(fit_1, . ~ . | . -x)

</code></pre>

<hr>
<h2 id='pairwise.vuong.test'>Pairwise vuong test</h2><span id='topic+pairwise.vuong.test'></span>

<h3>Description</h3>

<p>Calculate pairwise comparisons between fitted models performing
vuong test for objects of class <code><a href="#topic+unitquantreg">unitquantreg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise.vuong.test(
  ...,
  lt,
  p.adjust.method = p.adjust.methods,
  alternative = c("two.sided", "less", "greater")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise.vuong.test_+3A_...">...</code></td>
<td>
<p><code><a href="#topic+unitquantreg">unitquantreg</a></code> objects separated by commas.</p>
</td></tr>
<tr><td><code id="pairwise.vuong.test_+3A_lt">lt</code></td>
<td>
<p>a list with one or more <code><a href="#topic+unitquantreg">unitquantreg</a></code> objects.</p>
</td></tr>
<tr><td><code id="pairwise.vuong.test_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>a character string specifying the method for multiple
testing adjustment; almost always one of
<code>p.adjust.methods</code>. Can be abbreviated.</p>
</td></tr>
<tr><td><code id="pairwise.vuong.test_+3A_alternative">alternative</code></td>
<td>
<p>indicates the alternative hypothesis and must be one
of <code>"two.sided"</code> (default), <code>"less"</code>, or <code>"greater"</code>.
Can be abbreviated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"pairwise.htest"</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vuong.test">vuong.test</a></code>, <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim_bounded, package = "unitquantreg")
sim_bounded_curr &lt;- sim_bounded[sim_bounded$family == "uweibull", ]

models &lt;- c("uweibull", "kum", "ulogistic")
lt_fits &lt;- lapply(models, function(fam) {
  unitquantreg(formula = y1 ~ x, tau = 0.5, data = sim_bounded_curr,
               family = fam)
})

ans &lt;- pairwise.vuong.test(lt = lt_fits)
ans

</code></pre>

<hr>
<h2 id='plot.unitquantreg'>Plot method for <code>unitquantreg</code> objects</h2><span id='topic+plot.unitquantreg'></span>

<h3>Description</h3>

<p>Provide diagnostic plots to check model assumptions for fitted model
of class <code>unitquantreg</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'unitquantreg'
plot(
  x,
  which = 1L:4L,
  caption = c("Residuals vs. indices of obs.", "Residuals vs. linear predictor",
    "Working response vs. linear predictor", "Half-normal plot of residuals"),
  sub.caption = paste(deparse(x$call), collapse = "\n"),
  main = "",
  ask = prod(par("mfcol")) &lt; length(which) &amp;&amp; dev.interactive(),
  ...,
  add.smooth = getOption("add.smooth"),
  type = "quantile",
  nsim = 99L,
  level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.unitquantreg_+3A_x">x</code></td>
<td>
<p>fitted model object of class <code>unitquantreg</code>.</p>
</td></tr>
<tr><td><code id="plot.unitquantreg_+3A_which">which</code></td>
<td>
<p>integer. if a subset of the plots is required, specify a subset
of the numbers 1 to 4, see below for further details.</p>
</td></tr>
<tr><td><code id="plot.unitquantreg_+3A_caption">caption</code></td>
<td>
<p>character. Captions to appear above the plots.</p>
</td></tr>
<tr><td><code id="plot.unitquantreg_+3A_sub.caption">sub.caption</code></td>
<td>
<p>character. Common title-above figures if there are multiple.</p>
</td></tr>
<tr><td><code id="plot.unitquantreg_+3A_main">main</code></td>
<td>
<p>character. Title to each plot in addition to the above caption.</p>
</td></tr>
<tr><td><code id="plot.unitquantreg_+3A_ask">ask</code></td>
<td>
<p>logical. If <code>TRUE</code>, the user is asked before each plot.</p>
</td></tr>
<tr><td><code id="plot.unitquantreg_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through to plotting functions.</p>
</td></tr>
<tr><td><code id="plot.unitquantreg_+3A_add.smooth">add.smooth</code></td>
<td>
<p>logical. Indicates if a smoother should be added to most plots</p>
</td></tr>
<tr><td><code id="plot.unitquantreg_+3A_type">type</code></td>
<td>
<p>character. Indicates type of residual to be used, see
<code><a href="#topic+residuals.unitquantreg">residuals.unitquantreg</a></code>.</p>
</td></tr>
<tr><td><code id="plot.unitquantreg_+3A_nsim">nsim</code></td>
<td>
<p>integer. Number of simulations in half-normal plots, see
<code><a href="#topic+hnp.unitquantreg">hnp.unitquantreg</a></code>.</p>
</td></tr>
<tr><td><code id="plot.unitquantreg_+3A_level">level</code></td>
<td>
<p>numeric. Confidence level of the simulated envelope, see
<code><a href="#topic+hnp.unitquantreg">hnp.unitquantreg</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot</code> method for <code>unitquantreg</code> objects produces four types
of diagnostic plot.
</p>
<p>The <code>which</code> argument can be used to select a subset of currently four
supported plot, which are: Residuals versus indices of observations
(<code>which = 1</code>); Residuals versus linear predictor (<code>which = 2</code>);
Working response versus linear predictor (<code>which = 3</code>) to
check possible misspecification of link function; Half-normal plot of
residuals (<code>which = 4</code>) to check distribution assumption.
</p>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Author(s)</h3>

<p>André F. B. Menezes
</p>


<h3>References</h3>

<p>Dunn, P. K. and Smyth, G. K. (2018) Generalized Linear Models With Examples in R, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+residuals.unitquantreg">residuals.unitquantreg</a></code>,
<code><a href="#topic+hnp.unitquantreg">hnp.unitquantreg</a></code>,
<code><a href="#topic+unitquantreg">unitquantreg</a></code>.
</p>

<hr>
<h2 id='plot.unitquantregs'>Plot method for <code>unitquantregs</code> objects</h2><span id='topic+plot.unitquantregs'></span>

<h3>Description</h3>

<p>Provide two type of plots for <code>unitquantregs</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'unitquantregs'
plot(
  x,
  which = c("coef", "conddist"),
  output_df = FALSE,
  parm = NULL,
  level = 0.95,
  mean_effect = FALSE,
  mfrow = NULL,
  mar = NULL,
  ylim = NULL,
  main = NULL,
  col = gray(c(0, 0.75)),
  border = NULL,
  cex = 1,
  pch = 20,
  type = "b",
  xlab = bquote("Quantile level (" * tau * ")"),
  ylab = "Estimate effect",
  dist_type = c("density", "cdf"),
  at_avg = TRUE,
  at_obs = NULL,
  legend_position = "topleft",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.unitquantregs_+3A_x">x</code></td>
<td>
<p>fitted model object of class <code>unitquantregs</code>.</p>
</td></tr>
<tr><td><code id="plot.unitquantregs_+3A_which">which</code></td>
<td>
<p>character. Indicate the type of plot. Currently supported are <code>"coef"</code> which
provide the estimated coefficients for several quantiles and <code>"conddist"</code> which provide
the conditional distribution (cdf or pdf) at specific values of covariates.</p>
</td></tr>
<tr><td><code id="plot.unitquantregs_+3A_output_df">output_df</code></td>
<td>
<p>logical. Should <code>data.frame</code> used to plot be returned?</p>
</td></tr>
<tr><td><code id="plot.unitquantregs_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters are to be plotted, either a vector
of numbers or a vector of names. By default, all parameters are considered.</p>
</td></tr>
<tr><td><code id="plot.unitquantregs_+3A_level">level</code></td>
<td>
<p>level of significance for the confidence interval of parameters.</p>
</td></tr>
<tr><td><code id="plot.unitquantregs_+3A_mean_effect">mean_effect</code></td>
<td>
<p>logical. Should a line for the mean effect coefficients be added?</p>
</td></tr>
<tr><td><code id="plot.unitquantregs_+3A_mfrow">mfrow</code>, <code id="plot.unitquantregs_+3A_mar">mar</code>, <code id="plot.unitquantregs_+3A_ylim">ylim</code>, <code id="plot.unitquantregs_+3A_main">main</code>, <code id="plot.unitquantregs_+3A_col">col</code>, <code id="plot.unitquantregs_+3A_border">border</code>, <code id="plot.unitquantregs_+3A_cex">cex</code>, <code id="plot.unitquantregs_+3A_pch">pch</code>, <code id="plot.unitquantregs_+3A_type">type</code>, <code id="plot.unitquantregs_+3A_xlab">xlab</code>, <code id="plot.unitquantregs_+3A_ylab">ylab</code></td>
<td>
<p>graphical parameters.</p>
</td></tr>
<tr><td><code id="plot.unitquantregs_+3A_dist_type">dist_type</code></td>
<td>
<p>character. Which conditional distribution should be plotted?
The options are <code>"density"</code> or <code>"cdf"</code>.</p>
</td></tr>
<tr><td><code id="plot.unitquantregs_+3A_at_avg">at_avg</code></td>
<td>
<p>logical. Should consider the conditional distribution at average values of covariates?</p>
</td></tr>
<tr><td><code id="plot.unitquantregs_+3A_at_obs">at_obs</code></td>
<td>
<p>list. List with name and values for each covariate.</p>
</td></tr>
<tr><td><code id="plot.unitquantregs_+3A_legend_position">legend_position</code></td>
<td>
<p>character. The legend position argument used in <code>legend</code> function.</p>
</td></tr>
<tr><td><code id="plot.unitquantregs_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through to plotting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot method for <code>unitquantregs</code> objects is inspired in PROC QUANTREG of SAS/STAT.
This plot method provide two type of visualizations.
</p>
<p>If <code>which = "coef"</code> plot the estimated coefficients for several quantiles.
</p>
<p>If <code>which = "conddist"</code> plot the conditional distribution at specific values of
covariates. The conditional distribution could be the cumulative distribution function
if <code>dist_type = "cdf"</code> or the probability density function if <code>dist_type = "pdf"</code>.
</p>


<h3>Value</h3>

<p>If <code>output_df = TRUE</code> then returns a data.frame used to plot.
Otherwise, no return value, called for side effects.
</p>


<h3>Author(s)</h3>

<p>André F. B. Menezes
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.unitquantreg">plot.unitquantreg</a></code>.
</p>

<hr>
<h2 id='predict.unitquantreg'>Prediction method for <code>unitquantreg</code> class</h2><span id='topic+predict.unitquantreg'></span>

<h3>Description</h3>

<p>Extract various types of predictions from unit quantile regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'unitquantreg'
predict(
  object,
  newdata,
  type = c("link", "quantile", "shape", "terms"),
  interval = c("none", "confidence"),
  level = 0.95,
  se.fit = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.unitquantreg_+3A_object">object</code></td>
<td>
<p>fitted model object of class <code><a href="#topic+unitquantreg">unitquantreg</a></code>.</p>
</td></tr>
<tr><td><code id="predict.unitquantreg_+3A_newdata">newdata</code></td>
<td>
<p>optionally, a data frame in which to look for variables with
which to predict. If omitted, the original observations are used.</p>
</td></tr>
<tr><td><code id="predict.unitquantreg_+3A_type">type</code></td>
<td>
<p>character indicating type of predictions. The options are
<code>link</code>, <code>quantile</code>, <code>shape</code> and <code>terms</code>.</p>
</td></tr>
<tr><td><code id="predict.unitquantreg_+3A_interval">interval</code></td>
<td>
<p>type of interval desired. The options are <code>none</code> and
<code>confidence</code>. The &quot;<code>terms</code>&quot; option returns a matrix giving
the fitted values of each term in the model formula on the linear predictor
scale.</p>
</td></tr>
<tr><td><code id="predict.unitquantreg_+3A_level">level</code></td>
<td>
<p>coverage probability for the confidence intervals. Default is
<code>0.95</code>.</p>
</td></tr>
<tr><td><code id="predict.unitquantreg_+3A_se.fit">se.fit</code></td>
<td>
<p>logical. If <code>TRUE</code> return the asymptotic standard errors.</p>
</td></tr>
<tr><td><code id="predict.unitquantreg_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>se.fit = FALSE</code> then returns a <code>data.frame</code> with
predict values and confidence interval if <code>interval = TRUE</code>.
</p>
<p>If <code>se.fit = TRUE</code> returns a list with components:
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p>Predictions, as for <code>se.fit = FALSE</code>.</p>
</td></tr>
<tr><td><code>se.fit</code></td>
<td>
<p>Estimated standard errors.</p>
</td></tr>
</table>
<p>For <code>type = "terms"</code> the output is a <code>data.frame</code> with a columns
per term.
</p>


<h3>Author(s)</h3>

<p>André F. B. Menezes
</p>

<hr>
<h2 id='residuals.unitquantreg'>Residuals method for <code>unitquantreg</code> objects</h2><span id='topic+residuals.unitquantreg'></span>

<h3>Description</h3>

<p>Extract various types of residuals from unit quantile regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'unitquantreg'
residuals(object, type = c("quantile", "cox-snell", "working", "partial"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.unitquantreg_+3A_object">object</code></td>
<td>
<p>fitted model object of class <code><a href="#topic+unitquantreg">unitquantreg</a></code>.</p>
</td></tr>
<tr><td><code id="residuals.unitquantreg_+3A_type">type</code></td>
<td>
<p>character indicating type of residuals. The options are
<code>"quantile"</code>, <code>"cox-snell"</code>, <code>"working"</code> and <code>"partial"</code>.</p>
</td></tr>
<tr><td><code id="residuals.unitquantreg_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="stats.html#topic+residuals">residuals</a></code> method can compute quantile
and Cox-Snell residuals. These residuals are defined, respectively, by
</p>
<p style="text-align: center;"><code class="reqn">r_{Q} = \Phi^{-1}\left[ F(y_i \mid \widehat{\mu}_i, \widehat{\theta}_i)\right]</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">r_{CS} = -\log\left[1- F(y_i \mid \widehat{\mu}_i, \widehat{\theta}_i)\right]</code>
</p>

<p>where <code class="reqn">\widehat{\mu}_i</code> and <code class="reqn">\widehat{\theta}_i</code> are the fitted values
of parameters <code class="reqn">\mu</code> and <code class="reqn">\theta</code>, <code class="reqn">F(\cdot \mid \cdot, \cdot)</code> is
the cumulative distribution function (c.d.f.) and <code class="reqn">\Phi(\cdot)</code> is the
c.d.f. of standard Normal distribution.
</p>
<p>Apart from the variability due the estimates of parameters,if the fitted
regression model is correctly specified then the quantile
residuals, <code class="reqn">r_Q</code>, follow a standard Normal distribution and
the Cox-Snell residuals, <code class="reqn">r_{CS}</code>, follow a standard exponential
distribution.
</p>


<h3>Value</h3>

<p>Numeric vector of residuals extract from an object of class
<code><a href="#topic+unitquantreg">unitquantreg</a></code>.
</p>


<h3>Author(s)</h3>

<p>André F. B. Menezes
</p>


<h3>References</h3>

<p>Cox, D. R. and Snell E. J., (1968). A general definition of residuals. <em>Journal of the Royal Statistical Society - Series B</em>, <b>30</b>(2), 248&ndash;265.
</p>
<p>Dunn, P. K. and Smyth, G. K., (1996). Randomized quantile residuals. <em>Journal of Computational and Graphical Statistics</em>, <b>5</b>(3), 236&ndash;244.
</p>

<hr>
<h2 id='sim_bounded'>Simulated data set</h2><span id='topic+sim_bounded'></span>

<h3>Description</h3>

<p>This data set was simulated from all families of distributions
available in <code><a href="#topic+unitquantreg">unitquantreg</a></code> package considering
the median, i.e., <code class="reqn">\tau=0.5</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sim_bounded, package = "unitquantreg")
</code></pre>


<h3>Format</h3>

<p><code><a href="base.html#topic+data.frame">data.frame</a></code> with 1300 observations and 5 columns:
</p>

<ul>
<li> <p><code>y1</code>: simulated response variable with constant shape parameter,
<code class="reqn">\theta = 2</code>.
</p>
</li>
<li> <p><code>y2</code>: simulated response variable with regression structure in
the shape parameter, <code class="reqn">\theta_i = \exp(\zeta_i</code>), where
<code class="reqn">\zeta_i = \mathbf{z}_i^\top\,\boldsymbol{\gamma}</code>.
</p>
</li>
<li> <p><code>x</code>: covariate related to <code class="reqn">\mu_i</code>, i.e., the median.
</p>
</li>
<li> <p><code>z</code>: covariate related to <code class="reqn">\theta_i</code>, i.e., the shape parameter.
</p>
</li>
<li> <p><code>family</code>: string indicating the family of distribution.
</p>
</li></ul>



<h3>Details</h3>

<p>There are two response variable, namely <code>y1</code> and <code>y2</code>.
The former was simulated considering a regression structure for
<code class="reqn">\mu</code> and one covariate simulated from a standard uniform distribution,
where the true vector of coefficients for <code class="reqn">\mu</code> is
<code class="reqn">\boldsymbol{\beta} = (1, 2)</code> and <code class="reqn">\theta = 2</code>.
The latter was simulated assuming a regression structure for both <code class="reqn">\mu</code>
and <code class="reqn">\theta</code> (shape parameter) and only one independent covariates
simulated from two standard uniform distributions. The true vectors of
coefficients for <code class="reqn">\mu</code> and <code class="reqn">\theta</code> are
<code class="reqn">\boldsymbol{\beta} = (1, 2)</code> and <code class="reqn">\boldsymbol{\gamma} = (-1, 1)</code>,
respectively.
</p>


<h3>Author(s)</h3>

<p>André F. B. Menezes
</p>

<hr>
<h2 id='ubs'>The unit-Birnbaum-Saunders distribution</h2><span id='topic+ubs'></span><span id='topic+dubs'></span><span id='topic+pubs'></span><span id='topic+qubs'></span><span id='topic+rubs'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and random number generation function
for the unit-Birnbaum-Saunders distribution reparametrized in terms of the <code class="reqn">\tau</code>-th quantile, <code class="reqn">\tau \in (0, 1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dubs(x, mu, theta, tau = 0.5, log = FALSE)

pubs(q, mu, theta, tau = 0.5, lower.tail = TRUE, log.p = FALSE)

qubs(p, mu, theta, tau = 0.5, lower.tail = TRUE, log.p = FALSE)

rubs(n, mu, theta, tau = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ubs_+3A_x">x</code>, <code id="ubs_+3A_q">q</code></td>
<td>
<p>vector of positive quantiles.</p>
</td></tr>
<tr><td><code id="ubs_+3A_mu">mu</code></td>
<td>
<p>location parameter indicating the <code class="reqn">\tau</code>-th quantile, <code class="reqn">\tau \in (0, 1)</code>.</p>
</td></tr>
<tr><td><code id="ubs_+3A_theta">theta</code></td>
<td>
<p>nonnegative shape parameter.</p>
</td></tr>
<tr><td><code id="ubs_+3A_tau">tau</code></td>
<td>
<p>the parameter to specify which quantile is to be used.</p>
</td></tr>
<tr><td><code id="ubs_+3A_log">log</code>, <code id="ubs_+3A_log.p">log.p</code></td>
<td>
<p>logical; If TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="ubs_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; If TRUE, (default), <code class="reqn">P(X \leq{x})</code> are returned, otherwise <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="ubs_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="ubs_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">f(y\mid \alpha ,\theta )=\frac{1}{2y\alpha \theta \sqrt{2\pi }}\left[\left( -\frac{\alpha }{\log (y)}\right) ^{\frac{1}{2}}+\left( -\frac{\alpha}{\log (y)}\right) ^{\frac{3}{2}}\right] \exp \left[ \frac{1}{2\theta ^{2}}\left( 2+\frac{\log (y)}{\alpha }+\frac{\alpha }{\log (y)}\right) \right]</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">F(y\mid \alpha ,\theta )=1-\Phi \left\{ \frac{1}{\theta }\left[ \left( -\frac{\log (y)}{\alpha }\right) ^{\frac{1}{2}}-\left( -\frac{\alpha }{\log(y)}\right) ^{\frac{1}{2}}\right] \right\}</code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn">Q\left( \tau \mid \alpha ,\theta \right) ={\exp }\left\{ -{\frac{2\alpha}{2+\left[ {\theta }\Phi ^{-1}\left( 1-\tau \right) \right] ^{2}-{\theta } \Phi ^{-1}\left( 1-\tau \right) \sqrt{4+\left[ {\theta }\Phi ^{-1}\left(1-\tau \right) \right] ^{2}}}}\right\}</code>
</p>

<p>Reparameterization
</p>
<p style="text-align: center;"><code class="reqn">\alpha=g^{-1}(\mu )=\log \left( \mu \right) g\left( \theta ,\tau \right)</code>
</p>

<p>where <code class="reqn">g\left( \theta ,\tau \right) =-\frac{1}{2}\left\{ 2+\left[ {\theta }\Phi^{-1}\left( 1-\tau \right) \right] ^{2}-{\theta }\Phi ^{-1}\left( 1-\tau\right) \sqrt{4+{\theta }\Phi ^{-1}\left( 1-\tau \right) }\right\} .</code>
</p>


<h3>Value</h3>

<p><code>dubs</code> gives the density, <code>pubs</code> gives the distribution function,
<code>qubs</code> gives the quantile function and <code>rubs</code> generates random deviates.
</p>
<p>Invalid arguments will return an error message.
</p>


<h3>Author(s)</h3>

<p>Josmar Mazucheli <a href="mailto:jmazucheli@gmail.com">jmazucheli@gmail.com</a>
</p>
<p>André F. B. Menezes <a href="mailto:andrefelipemaringa@gmail.com">andrefelipemaringa@gmail.com</a>
</p>


<h3>References</h3>

<p>Birnbaum, Z. W. and Saunders, S. C., (1969). A new family of life distributions. <em>Journal of Applied Probability</em>, <b>6</b>(2), 637&ndash;652.
Mazucheli, J., Menezes, A. F. B. and Dey, S., (2018). The unit-Birnbaum-Saunders distribution with applications. <em>Chilean Journal of Statistics</em>, <b>9</b>(1), 47&ndash;57.
</p>
<p>Mazucheli, J., Alves, B. and Menezes, A. F. B., (2021). A new quantile regression for modeling bounded data under a unit Birnbaum-Saunders distribution with applications. <em>Simmetry</em>, (), 1&ndash;28.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- rubs(n = 1000, mu = 0.5, theta = 1.5, tau = 0.5)
R &lt;- range(x)
S &lt;- seq(from = R[1], to = R[2], by =  0.01)
hist(x, prob = TRUE, main = 'unit-Birnbaum-Saunders')
lines(S, dubs(x = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)
plot(ecdf(x))
lines(S, pubs(q = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)
plot(quantile(x, probs = S), type = "l")
lines(qubs(p = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)

</code></pre>

<hr>
<h2 id='uburrxii'>The unit-Burr-XII distribution</h2><span id='topic+uburrxii'></span><span id='topic+duburrxii'></span><span id='topic+puburrxii'></span><span id='topic+quburrxii'></span><span id='topic+ruburrxii'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and random number generation function
for the unit-Burr-XII distribution reparametrized in terms of the <code class="reqn">\tau</code>-th quantile, <code class="reqn">\tau \in (0, 1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duburrxii(x, mu, theta, tau = 0.5, log = FALSE)

puburrxii(q, mu, theta, tau = 0.5, lower.tail = TRUE, log.p = FALSE)

quburrxii(p, mu, theta, tau = 0.5, lower.tail = TRUE, log.p = FALSE)

ruburrxii(n, mu, theta, tau = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uburrxii_+3A_x">x</code>, <code id="uburrxii_+3A_q">q</code></td>
<td>
<p>vector of positive quantiles.</p>
</td></tr>
<tr><td><code id="uburrxii_+3A_mu">mu</code></td>
<td>
<p>location parameter indicating the <code class="reqn">\tau</code>-th quantile, <code class="reqn">\tau \in (0, 1)</code>.</p>
</td></tr>
<tr><td><code id="uburrxii_+3A_theta">theta</code></td>
<td>
<p>nonnegative shape parameter.</p>
</td></tr>
<tr><td><code id="uburrxii_+3A_tau">tau</code></td>
<td>
<p>the parameter to specify which quantile is to used.</p>
</td></tr>
<tr><td><code id="uburrxii_+3A_log">log</code>, <code id="uburrxii_+3A_log.p">log.p</code></td>
<td>
<p>logical; If TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="uburrxii_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; If TRUE, (default), <code class="reqn">P(X \leq{x})</code> are returned, otherwise <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="uburrxii_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="uburrxii_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">f(y\mid \alpha, \theta )=\frac{\alpha \theta }{y}\left[ -\log (y)\right]^{\theta -1}\left\{ 1+\left[ -\log (y)\right] ^{\theta }\right\} ^{-\alpha -1}</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">F(y\mid \alpha, \theta )=\left\{ 1+\left[ -\log (y)\right] ^{\theta}\right\} ^{-\alpha }</code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn">Q(\tau \mid \alpha, \theta )=\exp \left[ -\left( \tau ^{-\frac{1}{\alpha }}-1\right)^{\frac{1}{\theta }} \right]</code>
</p>

<p>Reparameterization
</p>
<p style="text-align: center;"><code class="reqn">\alpha=g^{-1}(\mu)=\frac{\log\left ( \tau^{-1} \right )}{\log\left [ 1+\log\left ( \frac{1}{\mu} \right )^\theta \right ]}</code>
</p>



<h3>Value</h3>

<p><code>duburrxii</code> gives the density, <code>puburrxii</code> gives the distribution function,
<code>quburrxii</code> gives the quantile function and <code>ruburrxii</code> generates random deviates.
</p>
<p>Invalid arguments will return an error message.
</p>


<h3>Author(s)</h3>

<p>Josmar Mazucheli <a href="mailto:jmazucheli@gmail.com">jmazucheli@gmail.com</a>
</p>
<p>André F. B. Menezes <a href="mailto:andrefelipemaringa@gmail.com">andrefelipemaringa@gmail.com</a>
</p>


<h3>References</h3>

<p>Korkmaz M. C. and Chesneau, C., (2021). On the unit Burr-XII distribution with the quantile regression modeling and applications. <em>Computational and Applied Mathematics</em>, <b>40</b>(29), 1&ndash;26.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- ruburrxii(n = 1000, mu = 0.5, theta = 1.5, tau = 0.5)
R &lt;- range(x)
S &lt;- seq(from = R[1], to = R[2], by =  0.01)
hist(x, prob = TRUE, main = 'unit-Burr-XII')
lines(S, duburrxii(x = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)
plot(ecdf(x))
lines(S, puburrxii(q = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)
plot(quantile(x, probs = S), type = "l")
lines(quburrxii(p = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)

</code></pre>

<hr>
<h2 id='uchen'>The unit-Chen distribution</h2><span id='topic+uchen'></span><span id='topic+duchen'></span><span id='topic+puchen'></span><span id='topic+quchen'></span><span id='topic+ruchen'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and random number generation function
for the unit-Chen distribution reparametrized in terms of the <code class="reqn">\tau</code>-th quantile, <code class="reqn">\tau \in (0, 1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duchen(x, mu, theta, tau = 0.5, log = FALSE)

puchen(q, mu, theta, tau = 0.5, lower.tail = TRUE, log.p = FALSE)

quchen(p, mu, theta, tau = 0.5, lower.tail = TRUE, log.p = FALSE)

ruchen(n, mu, theta, tau = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uchen_+3A_x">x</code>, <code id="uchen_+3A_q">q</code></td>
<td>
<p>vector of positive quantiles.</p>
</td></tr>
<tr><td><code id="uchen_+3A_mu">mu</code></td>
<td>
<p>location parameter indicating the <code class="reqn">\tau</code>-th quantile, <code class="reqn">\tau \in (0, 1)</code>.</p>
</td></tr>
<tr><td><code id="uchen_+3A_theta">theta</code></td>
<td>
<p>nonnegative shape parameter.</p>
</td></tr>
<tr><td><code id="uchen_+3A_tau">tau</code></td>
<td>
<p>the parameter to specify which quantile is to be used.</p>
</td></tr>
<tr><td><code id="uchen_+3A_log">log</code>, <code id="uchen_+3A_log.p">log.p</code></td>
<td>
<p>logical; If TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="uchen_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; If TRUE, (default), <code class="reqn">P(X \leq{x})</code> are returned, otherwise <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="uchen_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="uchen_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">f(y\mid \alpha ,\theta )=\frac{\alpha \theta }{y}\left[ -\log (y)\right]^{\theta -1}\exp \left\{ \left[ -\log \left( y\right) \right]^{\theta}\right\} \exp \left\{ \alpha \left\{ 1-\exp \left[ \left( -\log (y)\right)^{\theta }\right] \right\} \right\}</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">F(y\mid \alpha ,\theta )=\exp \left\{ \alpha \left\{ 1-\exp \left[ \left(-\log (y)\right)^{\theta }\right] \right\} \right\}</code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn">Q\left( \tau \mid \alpha ,\theta \right) =\exp \left\{ -\left[ \log \left( 1-{\frac{\log \left( \tau \right) }{\alpha }}\right) \right]^{\frac{1}{\theta}}\right\}</code>
</p>

<p>Reparameterization
</p>
<p style="text-align: center;"><code class="reqn">\alpha=g^{-1}(\mu )={\frac{\log \left( \tau \right) }{1-\exp \left[ \left( -\log (\mu )\right)^{\theta }\right]}}</code>
</p>



<h3>Value</h3>

<p><code>duchen</code> gives the density, <code>puchen</code> gives the distribution function,
<code>quchen</code> gives the quantile function and <code>ruchen</code> generates random deviates.
</p>
<p>Invalid arguments will return an error message.
</p>


<h3>Author(s)</h3>

<p>Josmar Mazucheli <a href="mailto:jmazucheli@gmail.com">jmazucheli@gmail.com</a>
</p>
<p>André F. B. Menezes <a href="mailto:andrefelipemaringa@gmail.com">andrefelipemaringa@gmail.com</a>
</p>


<h3>References</h3>

<p>Korkmaz, M. C., Emrah, A., Chesneau, C. and Yousof, H. M., (2020). On the unit-Chen distribution with associated quantile regression and applications. <em>Journal of Applied Statistics</em>, <b>44</b>(1) 1&ndash;22.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- ruchen(n = 1000, mu = 0.5, theta = 1.5, tau = 0.5)
R &lt;- range(x)
S &lt;- seq(from = R[1], to = R[2], by =  0.01)
hist(x, prob = TRUE, main = 'unit-Chen')
lines(S, duchen(x = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)
plot(ecdf(x))
lines(S, puchen(q = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)
plot(quantile(x, probs = S), type = "l")
lines(quchen(p = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)
</code></pre>

<hr>
<h2 id='ughne'>The unit-Half-Normal-E distribution</h2><span id='topic+ughne'></span><span id='topic+dughne'></span><span id='topic+pughne'></span><span id='topic+qughne'></span><span id='topic+rughne'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and random number generation function
for the unit-Half-Normal-E distribution reparametrized in terms of the <code class="reqn">\tau</code>-th quantile, <code class="reqn">\tau \in (0, 1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dughne(x, mu, theta, tau = 0.5, log = FALSE)

pughne(q, mu, theta, tau = 0.5, lower.tail = TRUE, log.p = FALSE)

qughne(p, mu, theta, tau = 0.5, lower.tail = TRUE, log.p = FALSE)

rughne(n, mu, theta, tau = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ughne_+3A_x">x</code>, <code id="ughne_+3A_q">q</code></td>
<td>
<p>vector of positive quantiles.</p>
</td></tr>
<tr><td><code id="ughne_+3A_mu">mu</code></td>
<td>
<p>location parameter indicating the <code class="reqn">\tau</code>-th quantile, <code class="reqn">\tau \in (0, 1)</code>.</p>
</td></tr>
<tr><td><code id="ughne_+3A_theta">theta</code></td>
<td>
<p>nonnegative shape parameter.</p>
</td></tr>
<tr><td><code id="ughne_+3A_tau">tau</code></td>
<td>
<p>the parameter to specify which quantile is to be used.</p>
</td></tr>
<tr><td><code id="ughne_+3A_log">log</code>, <code id="ughne_+3A_log.p">log.p</code></td>
<td>
<p>logical; If TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="ughne_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; If TRUE, (default), <code class="reqn">P(X \leq{x})</code> are returned, otherwise <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="ughne_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="ughne_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">f(y\mid \alpha ,\theta )=\sqrt{\frac{2}{\pi }}\frac{\theta }{y\left[ -\log\left( y\right) \right] }\left( -{\frac{\log \left( y\right) }{\alpha }} \right)^{\theta }\mathrm{\exp }\left\{ -\frac{1}{2}\left[ -{\frac{\log \left( y\right) }{\alpha }}\right]^{2\theta }\right\}</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">F(y\mid \alpha ,\theta )=2\Phi \left[ -\left( -{\frac{\log \left( y\right) }{\alpha }}\right)^{\theta }\right]</code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn">Q(\tau \mid \alpha ,\theta )=\exp \left\{ -\alpha \left[ -\Phi^{-1}\left(\frac{\tau }{2}\right) \right]^{\frac{1}{\theta }}\right\}</code>
</p>

<p>Reparameterization
</p>
<p style="text-align: center;"><code class="reqn">\alpha=g^{-1}(\mu )=-\log \left( \mu \right) \left[ -\Phi^{-1}\left( \frac{\tau }{2}\right) \right]^{-\frac{1}{\theta }}</code>
</p>



<h3>Value</h3>

<p><code>dughne</code> gives the density, <code>pughne</code> gives the distribution function,
<code>qughne</code> gives the quantile function and <code>rughne</code> generates random deviates.
</p>
<p>Invalid arguments will return an error message.
</p>


<h3>Author(s)</h3>

<p>Josmar Mazucheli <a href="mailto:jmazucheli@gmail.com">jmazucheli@gmail.com</a>
</p>
<p>André F. B. Menezes <a href="mailto:andrefelipemaringa@gmail.com">andrefelipemaringa@gmail.com</a>
</p>


<h3>References</h3>

<p>Korkmaz, M. C., (2020). The unit generalized half normal distribution: A new bounded distribution with inference and application. <em>University Politehnica of Bucharest Scientific</em>, <b>82</b>(2), 133&ndash;140.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- rughne(n = 1000, mu = 0.5, theta = 2, tau = 0.5)
R &lt;- range(x)
S &lt;- seq(from = R[1], to = R[2], by =  0.01)
hist(x, prob = TRUE, main = 'unit-Half-Normal-E')
lines(S, dughne(x = S, mu = 0.5, theta = 2, tau = 0.5), col = 2)
plot(ecdf(x))
lines(S, pughne(q = S, mu = 0.5, theta = 2, tau = 0.5), col = 2)
plot(quantile(x, probs = S), type = "l")
lines(qughne(p = S, mu = 0.5, theta = 2, tau = 0.5), col = 2)

</code></pre>

<hr>
<h2 id='ughnx'>The unit-Half-Normal-X distribution</h2><span id='topic+ughnx'></span><span id='topic+dughnx'></span><span id='topic+pughnx'></span><span id='topic+qughnx'></span><span id='topic+rughnx'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and random number generation function
for the unit-Half-Normal-X distribution reparametrized in terms of the <code class="reqn">\tau</code>-th quantile, <code class="reqn">\tau \in (0, 1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dughnx(x, mu, theta, tau = 0.5, log = FALSE)

pughnx(q, mu, theta, tau = 0.5, lower.tail = TRUE, log.p = FALSE)

qughnx(p, mu, theta, tau = 0.5, lower.tail = TRUE, log.p = FALSE)

rughnx(n, mu, theta, tau = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ughnx_+3A_x">x</code>, <code id="ughnx_+3A_q">q</code></td>
<td>
<p>vector of positive quantiles.</p>
</td></tr>
<tr><td><code id="ughnx_+3A_mu">mu</code></td>
<td>
<p>location parameter indicating the <code class="reqn">\tau</code>-th quantile, <code class="reqn">\tau \in (0, 1)</code>.</p>
</td></tr>
<tr><td><code id="ughnx_+3A_theta">theta</code></td>
<td>
<p>nonnegative shape parameter.</p>
</td></tr>
<tr><td><code id="ughnx_+3A_tau">tau</code></td>
<td>
<p>the parameter to specify which quantile is to be used.</p>
</td></tr>
<tr><td><code id="ughnx_+3A_log">log</code>, <code id="ughnx_+3A_log.p">log.p</code></td>
<td>
<p>logical; If TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="ughnx_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; If TRUE, (default), <code class="reqn">P(X \leq{x})</code> are returned, otherwise <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="ughnx_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="ughnx_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">f(y\mid \alpha ,\theta )=\sqrt{\frac{2}{\pi }}\frac{\theta }{y\left(1-y\right) }\left( {\frac{y}{\alpha \left( 1-y\right) }}\right) ^{\theta }\mathrm{\exp }\left\{ -\frac{1}{2}\left[ {\frac{y}{\alpha \left( 1-y\right) }}\right] ^{2\theta }\right\}</code>
</p>

<p>Cumulative density function
</p>
<p style="text-align: center;"><code class="reqn">F(y\mid \alpha ,\theta )=2\Phi \left[ \left( \frac{y}{\alpha \left(1-y\right) }\right) ^{\theta }\right] -1</code>
</p>

<p>Quantile Function
</p>
<p style="text-align: center;"><code class="reqn">Q(\tau \mid \alpha )=\frac{\alpha \left[ \Phi ^{-1}\left( \frac{\tau +1}{2}\right) \right] ^{\frac{1}{\theta }}}{1+\alpha \left[ \Phi ^{-1}\left( \frac{ \tau +1}{2}\right) \right] ^{\frac{1}{\theta }}}</code>
</p>

<p>Reparametrization
</p>
<p style="text-align: center;"><code class="reqn">\alpha=g^{-1}(\mu )=\frac{\mu }{\left( 1-\mu \right) \left[ \Phi ^{-1}\left( \frac{\tau +1}{2}\right) \right] ^{\frac{1}{\theta }}}</code>
</p>



<h3>Value</h3>

<p><code>dughnx</code> gives the density, <code>pughnx</code> gives the distribution function,
<code>qughnx</code> gives the quantile function and <code>rughnx</code> generates random deviates.
</p>
<p>Invalid arguments will return an error message.
</p>


<h3>Author(s)</h3>

<p>Josmar Mazucheli <a href="mailto:jmazucheli@gmail.com">jmazucheli@gmail.com</a>
</p>
<p>André F. B. Menezes <a href="mailto:andrefelipemaringa@gmail.com">andrefelipemaringa@gmail.com</a>
</p>


<h3>References</h3>

<p>Bakouch, H. S., Nik, A. S., Asgharzadeh, A. and Salinas, H. S., (2021). A flexible probability model for  proportion  data: Unit-Half-Normal  distribution. <em>Communications  in  Statistics: CaseStudies, Data Analysis and Applications</em>, <b>0</b>(0), 1&ndash;18.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- rughnx(n = 1000, mu = 0.5, theta = 2, tau = 0.5)
R &lt;- range(x)
S &lt;- seq(from = R[1], to = R[2], by =  0.01)
hist(x, prob = TRUE, main = 'unit-Half-Normal-X')
lines(S, dughnx(x = S, mu = 0.5, theta = 2, tau = 0.5), col = 2)
plot(ecdf(x))
lines(S, pughnx(q = S, mu = 0.5, theta = 2, tau = 0.5), col = 2)
plot(quantile(x, probs = S), type = "l")
lines(qughnx(p = S, mu = 0.5, theta = 2, tau = 0.5), col = 2)

</code></pre>

<hr>
<h2 id='ugompertz'>The unit-Gompertz distribution</h2><span id='topic+ugompertz'></span><span id='topic+dugompertz'></span><span id='topic+pugompertz'></span><span id='topic+qugompertz'></span><span id='topic+rugompertz'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and random number deviates
for the unit-Gompertz distribution reparametrized in terms of the <code class="reqn">\tau</code>-th quantile, <code class="reqn">\tau \in (0, 1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dugompertz(x, mu, theta, tau = 0.5, log = FALSE)

pugompertz(q, mu, theta, tau = 0.5, lower.tail = TRUE, log.p = FALSE)

qugompertz(p, mu, theta, tau = 0.5, lower.tail = TRUE, log.p = FALSE)

rugompertz(n, mu, theta, tau = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ugompertz_+3A_x">x</code>, <code id="ugompertz_+3A_q">q</code></td>
<td>
<p>vector of positive quantiles.</p>
</td></tr>
<tr><td><code id="ugompertz_+3A_mu">mu</code></td>
<td>
<p>location parameter indicating the <code class="reqn">\tau</code>-th quantile, <code class="reqn">\tau \in (0, 1)</code>.</p>
</td></tr>
<tr><td><code id="ugompertz_+3A_theta">theta</code></td>
<td>
<p>nonnegative shape parameter.</p>
</td></tr>
<tr><td><code id="ugompertz_+3A_tau">tau</code></td>
<td>
<p>the parameter to specify which quantile is to be used.</p>
</td></tr>
<tr><td><code id="ugompertz_+3A_log">log</code>, <code id="ugompertz_+3A_log.p">log.p</code></td>
<td>
<p>logical; If TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="ugompertz_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; If TRUE, (default), <code class="reqn">P(X \leq{x})</code> are returned, otherwise <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="ugompertz_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="ugompertz_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">f(y\mid \alpha ,\theta )=\frac{\alpha \theta }{x}\exp \left\{ \alpha -\theta \log \left( y\right) -\alpha \exp \left[ -\theta \log \left( y\right) \right] \right\} </code>
</p>

<p>Cumulative density function
</p>
<p style="text-align: center;"><code class="reqn">F(y\mid \alpha ,\theta )=\exp \left[ \alpha \left( 1-y^{\theta }\right) \right] </code>
</p>

<p>Quantile Function
</p>
<p style="text-align: center;"><code class="reqn">Q(\tau \mid \alpha ,\theta )=\left[ \frac{\alpha -\log \left( \tau \right) }{\alpha }\right] ^{-\frac{1}{\theta }} </code>
</p>

<p>Reparameterization
</p>
<p style="text-align: center;"><code class="reqn">\alpha =g^{-1}(\mu )=\frac{\log \left( \tau \right) }{1-\mu ^{\theta }}</code>
</p>



<h3>Value</h3>

<p><code>dugompertz</code> gives the density, <code>pugompertz</code> gives the distribution function,
<code>qugompertz</code> gives the quantile function and <code>rugompertz</code> generates random deviates.
</p>
<p>Invalid arguments will return an error message.
</p>


<h3>Author(s)</h3>

<p>Josmar Mazucheli <a href="mailto:jmazucheli@gmail.com">jmazucheli@gmail.com</a>
</p>
<p>André F. B. Menezes <a href="mailto:andrefelipemaringa@gmail.com">andrefelipemaringa@gmail.com</a>
</p>


<h3>References</h3>

<p>Mazucheli, J., Menezes, A. F. and Dey, S., (2019). Unit-Gompertz Distribution with Applications. <em>Statistica</em>, <b>79</b>(1), 25-43.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- rugompertz(n = 1000, mu = 0.5, theta = 2, tau = 0.5)
R &lt;- range(x)
S &lt;- seq(from = R[1], to = R[2], by =  0.01)
hist(x, prob = TRUE, main = 'unit-Gompertz')
lines(S, dugompertz(x = S, mu = 0.5, theta = 2, tau = 0.5), col = 2)
plot(ecdf(x))
lines(S, pugompertz(q = S, mu = 0.5, theta = 2, tau = 0.5), col = 2)
plot(quantile(x, probs = S), type = "l")
lines(qugompertz(p = S, mu = 0.5, theta = 2, tau = 0.5), col = 2)
</code></pre>

<hr>
<h2 id='ugumbel'>The unit-Gumbel distribution</h2><span id='topic+ugumbel'></span><span id='topic+dugumbel'></span><span id='topic+pugumbel'></span><span id='topic+qugumbel'></span><span id='topic+rugumbel'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and random number generation function
for the unit-Gumbel distribution reparametrized in terms of the <code class="reqn">\tau</code>-th quantile, <code class="reqn">\tau \in (0, 1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dugumbel(x, mu, theta, tau = 0.5, log = FALSE)

pugumbel(q, mu, theta, tau = 0.5, lower.tail = TRUE, log.p = FALSE)

qugumbel(p, mu, theta, tau = 0.5, lower.tail = TRUE, log.p = FALSE)

rugumbel(n, mu, theta, tau = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ugumbel_+3A_x">x</code>, <code id="ugumbel_+3A_q">q</code></td>
<td>
<p>vector of positive quantiles.</p>
</td></tr>
<tr><td><code id="ugumbel_+3A_mu">mu</code></td>
<td>
<p>location parameter indicating the <code class="reqn">\tau</code>-th quantile, <code class="reqn">\tau \in (0, 1)</code>.</p>
</td></tr>
<tr><td><code id="ugumbel_+3A_theta">theta</code></td>
<td>
<p>nonnegative shape parameter.</p>
</td></tr>
<tr><td><code id="ugumbel_+3A_tau">tau</code></td>
<td>
<p>the parameter to specify which quantile use in the parametrization.</p>
</td></tr>
<tr><td><code id="ugumbel_+3A_log">log</code>, <code id="ugumbel_+3A_log.p">log.p</code></td>
<td>
<p>logical; If TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="ugumbel_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; If TRUE, (default), <code class="reqn">P(X \leq x)</code> are returned, otherwise <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="ugumbel_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="ugumbel_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">f(y\mid \alpha ,\theta )=\frac{\theta }{y(1-y)}\exp \left\{ -\alpha -\theta \log \left( \frac{y}{1-y}\right) -\exp \left[ -\alpha -\theta \log \left( \frac{y}{1-y}\right) \right] \right\}</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">F(y\mid\alpha,\theta)={\exp }\left[ -{{\exp }}\left( -\alpha \right)\left( \frac{1-y}{y}\right) ^{\theta } \right] </code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn">Q(\tau \mid \alpha, \theta)= \frac{\left [-\frac{1}{\log(\tau)  }\right ]^{\frac{1}{\theta}}}{\exp\left ( \frac{\alpha}{\theta} \right )+\left [-\frac{1}{\log(\tau)  }\right ]^{\frac{1}{\theta}}}</code>
</p>

<p>Reparameterization
</p>
<p style="text-align: center;"><code class="reqn">\alpha =  g^{-1}(\mu ) =\theta \log \left( {\frac{1-\mu }{\mu }}\right) +\log \left( -\frac{1}{\log \left( \tau \right) }\right)</code>
</p>

<p>where <code class="reqn">0&lt;y&lt;1</code> and <code class="reqn">\theta &gt;0</code> is the shape parameter.
</p>


<h3>Value</h3>

<p><code>dugumbel</code> gives the density, <code>pugumbel</code> gives the distribution function,
<code>qugumbel</code> gives the quantile function and <code>rugumbel</code> generates random deviates.
</p>
<p>Invalid arguments will return an error message.
</p>


<h3>Author(s)</h3>

<p>Josmar Mazucheli
</p>
<p>Andre F. B. Menezes
</p>


<h3>References</h3>

<p>Mazucheli, J. and Alves, B., (2021). The unit-Gumbel Quantile Regression Model for Proportion Data. <em>Under Review</em>.
</p>
<p>Gumbel, E. J., (1941). The return period of flood flows. <em>The Annals of Mathematical Statistics</em>, <b>12</b>(2), 163&ndash;190.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(6969)
x &lt;- rugumbel(n = 1000, mu = 0.5, theta = 1.5, tau = 0.5)
R &lt;- range(x)
S &lt;- seq(from = R[1], to = R[2], by = 0.01)
hist(x, prob = TRUE, main = 'unit-Gumbel')
lines(S, dugumbel(x = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)
plot(ecdf(x))
lines(S, pugumbel(q = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)
plot(quantile(x, probs = S), type = "l")
lines(qugumbel(p = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)
</code></pre>

<hr>
<h2 id='ulogistic'>The unit-Logistic distribution</h2><span id='topic+ulogistic'></span><span id='topic+dulogistic'></span><span id='topic+pulogistic'></span><span id='topic+qulogistic'></span><span id='topic+rulogistic'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and random number generation for the unit-Logistic distribution reparametrized in terms of the <code class="reqn">\tau</code>-th quantile, <code class="reqn">\tau \in (0, 1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dulogistic(x, mu, theta, tau = 0.5, log = FALSE)

pulogistic(q, mu, theta, tau = 0.5, lower.tail = TRUE, log.p = FALSE)

qulogistic(p, mu, theta, tau = 0.5, lower.tail = TRUE, log.p = FALSE)

rulogistic(n, mu, theta, tau = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ulogistic_+3A_x">x</code>, <code id="ulogistic_+3A_q">q</code></td>
<td>
<p>vector of positive quantiles.</p>
</td></tr>
<tr><td><code id="ulogistic_+3A_mu">mu</code></td>
<td>
<p>location parameter indicating the <code class="reqn">\tau</code>-th quantile, <code class="reqn">\tau \in (0, 1)</code>.</p>
</td></tr>
<tr><td><code id="ulogistic_+3A_theta">theta</code></td>
<td>
<p>nonnegative shape parameter.</p>
</td></tr>
<tr><td><code id="ulogistic_+3A_tau">tau</code></td>
<td>
<p>the parameter to specify which quantile is to used.</p>
</td></tr>
<tr><td><code id="ulogistic_+3A_log">log</code>, <code id="ulogistic_+3A_log.p">log.p</code></td>
<td>
<p>logical; If TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="ulogistic_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; If TRUE, (default), <code class="reqn">P(X \leq{x})</code> are returned, otherwise <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="ulogistic_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="ulogistic_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">f(y\mid \alpha ,\theta )=\frac{\theta \exp \left( \alpha \right) \left(\frac{y}{1-y}\right) ^{\theta -1}}{\left[ 1+\exp \left( \alpha \right)\left( \frac{y}{1-y}\right) ^{\theta }\right] ^{2}}</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">F(y\mid \alpha ,\theta )=\frac{\exp \left( \alpha \right) \left( \frac{y}{1-y}\right) ^{\theta }}{1+\exp \left( \alpha \right) \left( \frac{y}{1-y}\right) ^{\theta }}</code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn">Q(\tau \mid \alpha ,\theta )=\frac{\exp \left( -\frac{\alpha }{\theta }\right) \left( \frac{\tau }{1-\tau }\right) ^{\frac{1}{\theta }}}{1+\exp\left( -\frac{\alpha }{\theta }\right) \left( \frac{\tau }{1-\tau }\right) ^{ \frac{1}{\theta }}} </code>
</p>

<p>Reparameterization
</p>
<p style="text-align: center;"><code class="reqn">\alpha=g^{-1}(\mu )=\log \left( \frac{\tau }{1-\tau }\right) -\theta \log \left(   \frac{\mu }{1-\mu }\right) </code>
</p>



<h3>Value</h3>

<p><code>dulogistic</code> gives the density, <code>pulogistic</code> gives the distribution function,
<code>qulogistic</code> gives the quantile function and <code>rulogistic</code> generates random deviates.
</p>
<p>Invalid arguments will return an error message.
</p>


<h3>Author(s)</h3>

<p>Josmar Mazucheli <a href="mailto:jmazucheli@gmail.com">jmazucheli@gmail.com</a>
</p>
<p>André F. B. Menezes <a href="mailto:andrefelipemaringa@gmail.com">andrefelipemaringa@gmail.com</a>
</p>


<h3>References</h3>

<p>Paz, R. F., Balakrishnan, N. and Bazán, J. L., 2019. L-Logistic regression models: Prior sensitivity analysis, robustness to outliers and applications. <em>Brazilian Journal of Probability and Statistics</em>, <b>33</b>(3), 455&ndash;479.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- rulogistic(n = 1000, mu = 0.5, theta = 1.5, tau = 0.5)
R &lt;- range(x)
S &lt;- seq(from = R[1], to = R[2], by =  0.01)
hist(x, prob = TRUE, main = 'unit-Logistic')
lines(S, dulogistic(x = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)
plot(ecdf(x))
lines(S, pulogistic(q = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)
plot(quantile(x, probs = S), type = "l")
lines(qulogistic(p = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)
</code></pre>

<hr>
<h2 id='unitquantreg'>Parametric unit quantile regression models</h2><span id='topic+unitquantreg'></span><span id='topic+unitquantreg.fit'></span>

<h3>Description</h3>

<p>Fit a collection of parametric unit quantile regression model
by maximum likelihood using the log-likelihood function, the score vector
and the hessian matrix implemented in <code>C++</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitquantreg(
  formula,
  data,
  subset,
  na.action,
  tau,
  family,
  link = c("logit", "probit", "cloglog", "cauchit"),
  link.theta = c("identity", "log", "sqrt"),
  start = NULL,
  control = unitquantreg.control(),
  model = TRUE,
  x = FALSE,
  y = TRUE
)

unitquantreg.fit(
  y,
  X,
  Z = NULL,
  tau,
  family,
  link,
  link.theta,
  start = NULL,
  control = unitquantreg.control()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unitquantreg_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the quantile model like <code>y ~ x</code>
or <code>y ~ x | z</code>. See below for details.</p>
</td></tr>
<tr><td><code id="unitquantreg_+3A_data">data</code></td>
<td>
<p>data.frame contain the variables in the model.</p>
</td></tr>
<tr><td><code id="unitquantreg_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to
be used in the fitting process.</p>
</td></tr>
<tr><td><code id="unitquantreg_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the
data contain <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="unitquantreg_+3A_tau">tau</code></td>
<td>
<p>numeric vector. The quantile(s) to be estimated, i.e.,
number between 0 and 1. If just one quantile is specified an object of class
<code>unitquantreg</code> is returned. If a numeric vector of values between 0 and 1
is specified an object of class <code>unitquantregs</code> is returned. See below for
details.</p>
</td></tr>
<tr><td><code id="unitquantreg_+3A_family">family</code></td>
<td>
<p>character. Specify the distribution family.</p>
</td></tr>
<tr><td><code id="unitquantreg_+3A_link">link</code></td>
<td>
<p>character. Specify the link function in the quantile model.
Currently supported are <code>logit</code>, <code>probit</code>, <code>cloglog</code> and
<code>cauchit</code>. Default is <code>logit</code>.</p>
</td></tr>
<tr><td><code id="unitquantreg_+3A_link.theta">link.theta</code></td>
<td>
<p>character. Specify the link function in the shape model.
Currently supported are <code>identity</code>, <code>log</code> and <code>sqrt</code>.
Default is <code>log</code>.</p>
</td></tr>
<tr><td><code id="unitquantreg_+3A_start">start</code></td>
<td>
<p>numeric vector. An optional vector with starting values for all parameters.</p>
</td></tr>
<tr><td><code id="unitquantreg_+3A_control">control</code></td>
<td>
<p>list. Control arguments specified via <code><a href="#topic+unitquantreg.control">unitquantreg.control</a></code>.</p>
</td></tr>
<tr><td><code id="unitquantreg_+3A_model">model</code></td>
<td>
<p>logical. Indicates whether model frame should be included as a
component of the returned value.</p>
</td></tr>
<tr><td><code id="unitquantreg_+3A_x">x</code>, <code id="unitquantreg_+3A_y">y</code></td>
<td>
<p>logical. If <code>TRUE</code> the corresponding components of the fit
(model frame, response, model matrix) are returned. For <code><a href="#topic+unitquantreg.fit">unitquantreg.fit</a></code>
<code>y</code> should be the numeric response vector with values in (0,1).</p>
</td></tr>
<tr><td><code id="unitquantreg_+3A_x">X</code>, <code id="unitquantreg_+3A_z">Z</code></td>
<td>
<p>numeric matrix. Regressor matrix for the quantile and shape model,
respectively. Default is constant shape model, i.e., <code>Z</code> is matrix with
column of ones.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter estimation and inference are performed under the frequentist paradigm.
The <code><a href="optimx.html#topic+optimx">optimx</a></code> R package is use, since allows different optimization
technique to maximize the log-likelihood function.  The analytical score function are
use in the maximization and the standard errors are computed using the
analytical hessian matrix, both are implemented in efficient away using <code>C++</code>.
</p>


<h3>Value</h3>

<p><code><a href="#topic+unitquantreg">unitquantreg</a></code> can return an object of
class <code>unitquantreg</code> if <code>tau</code> is a scalar, i.e., a list with
the following components.
</p>
<table>
<tr><td><code>family</code></td>
<td>
<p>the distribution family name.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a list with elements <code>"quantile"</code> and <code>"shape"</code>
containing the coefficients from the respective models.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>a list with elements <code>"quantile"</code> and <code>"shape"</code>
containing the fitted parameters from the respective models.</p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>
<p>a list with elements <code>"quantile"</code> and <code>"shape"</code>
containing the fitted linear predictors from the respective models.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>a list with elements <code>"quantile"</code> and <code>"shape"</code>
containing the link objects from the respective models.</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>the quantile specify.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>log-likelihood of the fitted model.</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>gradient evaluate at maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>covariance matrix of all parameters in the model.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code>npar</code></td>
<td>
<p>number of parameters.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>residual degrees of freedom in the fitted model.</p>
</td></tr>
<tr><td><code>theta_const</code></td>
<td>
<p>logical indicating if the <code class="reqn">\theta</code> parameter was treated as nuisance parameter.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>the control parameters used to fit the model.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>number of iterations of optimization method.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>logical, if <code>TRUE</code> indicates successful convergence.</p>
</td></tr>
<tr><td><code>kkt</code></td>
<td>
<p>a list of logical  <code>kkt1</code> and <code>kkt2</code> provide check on
Kuhn-Karush-Tucker conditions, first-order KKT test (<code>kkt1</code>) checks
whether the gradient at the final parameters estimates is &quot;small&quot; and the
second-order KKT test (<code>kkte</code>) checks whether the Hessian at the final
parameters estimates is positive definite.</p>
</td></tr>
<tr><td><code>elapsed_time</code></td>
<td>
<p>time elapsed to fit the model.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the original function call.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the original model formula.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>a list with elements <code>"quantile"</code>, <code>"shape"</code> and
<code>"full"</code> containing the <code>terms</code> objects for the respective models.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>the full model frame, if <code>model = TRUE</code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response vector, if <code>y = TRUE</code>.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>a list with elements <code>"quantile"</code> and <code>"shape"</code>
containing the model matrices from the respective models, if <code>x = TRUE</code>.</p>
</td></tr>
</table>
<p>While <code><a href="#topic+unitquantreg.fit">unitquantreg.fit</a></code> returns an unclassed list with
components up to <code>elapsed_time</code>.
</p>
<p>If <code>tau</code> is a numeric vector with length greater than one an object of
class <code>unitquantregs</code> is returned, which consist of list of objects of
class <code>unitquantreg</code> for each specified quantiles.
</p>


<h3>Author(s)</h3>

<p>André F. B. Menezes
</p>

<hr>
<h2 id='unitquantreg.control'>Control parameters for unit quantile regression</h2><span id='topic+unitquantreg.control'></span>

<h3>Description</h3>

<p>Auxiliary function that control fitting of unit quantile
regression models using <code><a href="#topic+unitquantreg">unitquantreg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitquantreg.control(
  method = "BFGS",
  hessian = FALSE,
  gradient = TRUE,
  maxit = 5000,
  factr = 1e+07,
  reltol = sqrt(.Machine$double.eps),
  trace = 0L,
  starttests = FALSE,
  dowarn = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unitquantreg.control_+3A_method">method</code></td>
<td>
<p>string. Specify the method argument passed to <code><a href="optimx.html#topic+optimx">optimx</a></code>.</p>
</td></tr>
<tr><td><code id="unitquantreg.control_+3A_hessian">hessian</code></td>
<td>
<p>logical. Should use the numerically Hessian matrix to compute
variance-covariance? Default is <code>FALSE</code>, i.e., use the analytic
Hessian.</p>
</td></tr>
<tr><td><code id="unitquantreg.control_+3A_gradient">gradient</code></td>
<td>
<p>logical. Should use the analytic gradient? Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="unitquantreg.control_+3A_maxit">maxit</code></td>
<td>
<p>integer. Specify the maximal number of iterations passed to
<code>optimx</code>.</p>
</td></tr>
<tr><td><code id="unitquantreg.control_+3A_factr">factr</code></td>
<td>
<p>numeric.Controls the convergence of the <code>"L-BFGS-B"</code> method.</p>
</td></tr>
<tr><td><code id="unitquantreg.control_+3A_reltol">reltol</code></td>
<td>
<p>numeric. Relative convergence tolerance passed to <code><a href="optimx.html#topic+optimx">optimx</a></code>.</p>
</td></tr>
<tr><td><code id="unitquantreg.control_+3A_trace">trace</code></td>
<td>
<p>non-negative integer. If positive, tracing information on the
progress of the optimization is produced.</p>
</td></tr>
<tr><td><code id="unitquantreg.control_+3A_starttests">starttests</code></td>
<td>
<p>logical. Should <code><a href="optimx.html#topic+optimx">optimx</a></code> run tests of the functions
and parameters? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="unitquantreg.control_+3A_dowarn">dowarn</code></td>
<td>
<p>logical. Show warnings generated by <code><a href="optimx.html#topic+optimx">optimx</a></code>? Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="unitquantreg.control_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="optimx.html#topic+optimx">optimx</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>control</code> argument of
<code><a href="#topic+unitquantreg">unitquantreg</a></code> uses the arguments of
<code><a href="#topic+unitquantreg.control">unitquantreg.control</a></code>. In particular, the
parameters in <code><a href="#topic+unitquantreg">unitquantreg</a></code> are estimated by
maximum likelihood using the <code><a href="optimx.html#topic+optimx">optimx</a></code>, which is a
general-purpose optimization wrapper function that calls other R tools for
optimization, including the existing <code><a href="stats.html#topic+optim">optim</a></code> function.
The main advantage of <code><a href="optimx.html#topic+optimx">optimx</a></code> is to unify the tools
allowing a number of different optimization methods and provide sanity checks.
</p>


<h3>Value</h3>

<p>A list with components named as the arguments.
</p>


<h3>Author(s)</h3>

<p>André F. B. Menezes
</p>


<h3>References</h3>

<p>Nash, J. C. and Varadhan, R. (2011). Unifying Optimization Algorithms to Aid Software System Users: optimx for R., <em>Journal of Statistical Software</em>, <b>43</b>(9), 1&ndash;14.
</p>


<h3>See Also</h3>

<p><code><a href="optimx.html#topic+optimx">optimx</a></code> for more details about control
parameters and <code><a href="#topic+unitquantreg.fit">unitquantreg.fit</a></code> the fitting
procedure used by <code><a href="#topic+unitquantreg">unitquantreg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim_bounded, package = "unitquantreg")
sim_bounded_curr &lt;- sim_bounded[sim_bounded$family == "uweibull", ]

# Fitting using the analytical gradient
fit_gradient &lt;- unitquantreg(formula = y1 ~ x,
                             data = sim_bounded_curr, tau = 0.5,
                             family = "uweibull",
                             control = unitquantreg.control(gradient = TRUE,
                                                            trace = 1))

# Fitting without using the analytical gradient
fit_nogradient &lt;- unitquantreg(formula = y1 ~ x,
                             data = sim_bounded_curr, tau = 0.5,
                             family = "uweibull",
                             control = unitquantreg.control(gradient = FALSE,
                                                            trace = 1))
# Compare estimated coefficients
cbind(gradient = coef(fit_gradient), no_gradient = coef(fit_nogradient))

</code></pre>

<hr>
<h2 id='uweibull'>The unit-Weibull distribution</h2><span id='topic+uweibull'></span><span id='topic+duweibull'></span><span id='topic+puweibull'></span><span id='topic+quweibull'></span><span id='topic+ruweibull'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and random number generation function
for the unit-Weibull distribution reparametrized in terms of the <code class="reqn">\tau</code>-th quantile, <code class="reqn">\tau \in (0, 1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duweibull(x, mu, theta, tau = 0.5, log = FALSE)

puweibull(q, mu, theta, tau = 0.5, lower.tail = TRUE, log.p = FALSE)

quweibull(p, mu, theta, tau = 0.5, lower.tail = TRUE, log.p = FALSE)

ruweibull(n, mu, theta, tau = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uweibull_+3A_x">x</code>, <code id="uweibull_+3A_q">q</code></td>
<td>
<p>vector of positive quantiles.</p>
</td></tr>
<tr><td><code id="uweibull_+3A_mu">mu</code></td>
<td>
<p>location parameter indicating the <code class="reqn">\tau</code>-th quantile, <code class="reqn">\tau \in (0, 1)</code>.</p>
</td></tr>
<tr><td><code id="uweibull_+3A_theta">theta</code></td>
<td>
<p>nonnegative shape parameter.</p>
</td></tr>
<tr><td><code id="uweibull_+3A_tau">tau</code></td>
<td>
<p>the parameter to specify which quantile use in the parametrization.</p>
</td></tr>
<tr><td><code id="uweibull_+3A_log">log</code>, <code id="uweibull_+3A_log.p">log.p</code></td>
<td>
<p>logical; If TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="uweibull_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; If TRUE, (default), <code class="reqn">P(X \leq x)</code> are returned, otherwise <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="uweibull_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="uweibull_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">f(y\mid \alpha ,\theta )=\frac{\alpha \theta }{y}\left[ -\log (y)\right]^{\theta -1}\exp \left\{ -\alpha \left[ -\log (y)\right]^{\theta }\right\} </code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">F(y\mid \alpha ,\theta )=\exp \left\{ -\alpha \left[ -\log (y)\right]^{\theta }\right\}</code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn">Q\left( \tau \mid \alpha ,\theta \right) =\exp \left\{ -\left[ -\frac{\log (\tau )}{\alpha }\right]^{\frac{1}{\theta }}\right\}</code>
</p>

<p>Reparameterization
</p>
<p style="text-align: center;"><code class="reqn">\alpha =g^{-1}(\mu )=-\frac{\log (\tau )}{[-\log (\mu )]^{\theta}}</code>
</p>



<h3>Value</h3>

<p><code>duweibull</code> gives the density, <code>puweibull</code> gives the distribution function,
<code>quweibull</code> gives the quantile function and <code>ruweibull</code> generates random deviates.
</p>
<p>Invalid arguments will return an error message.
</p>


<h3>Author(s)</h3>

<p>Josmar Mazucheli
</p>
<p>André F. B. Menezes
</p>


<h3>References</h3>

<p>Mazucheli, J., Menezes, A. F. B and Ghitany, M. E., (2018). The unit-Weibull distribution and associated inference. <em>Journal of Applied Probability and Statistics</em>, <b>13</b>(2), 1&ndash;22.
</p>
<p>Mazucheli, J., Menezes, A. F. B., Fernandes, L. B., Oliveira, R. P. and Ghitany, M. E., (2020). The unit-Weibull distribution as an alternative to the Kumaraswamy distribution for the modeling of quantiles conditional on covariates. <em>Journal of Applied Statistics</em>, <b>47</b>(6), 954&ndash;974.
</p>
<p>Mazucheli, J., Menezes, A. F. B., Alqallaf, F. and Ghitany, M. E., (2021). Bias-Corrected Maximum Likelihood Estimators of the Parameters of the Unit-Weibull Distribution. <em>Austrian Journal of Statistics</em>, <b>50</b>(3), 41&ndash;53.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(6969)
x &lt;- ruweibull(n = 1000, mu = 0.5, theta = 1.5, tau = 0.5)
R &lt;- range(x)
S &lt;- seq(from = R[1], to = R[2], by = 0.01)
hist(x, prob = TRUE, main = 'unit-Weibull')
lines(S, duweibull(x = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)
plot(ecdf(x))
lines(S, puweibull(q = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)
plot(quantile(x, probs = S), type = "l")
lines(quweibull(p = S, mu = 0.5, theta = 1.5, tau = 0.5), col = 2)
</code></pre>

<hr>
<h2 id='vuong.test'>Vuong test</h2><span id='topic+vuong.test'></span>

<h3>Description</h3>

<p>Performs Vuong test between two fitted objects of class
<code><a href="#topic+unitquantreg">unitquantreg</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vuong.test(object1, object2, alternative = c("two.sided", "less", "greater"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vuong.test_+3A_object1">object1</code>, <code id="vuong.test_+3A_object2">object2</code></td>
<td>
<p>objects of class <code><a href="#topic+unitquantreg">unitquantreg</a></code>
containing the fitted models.</p>
</td></tr>
<tr><td><code id="vuong.test_+3A_alternative">alternative</code></td>
<td>
<p>indicates the alternative hypothesis and must be one
of <code>"two.sided"</code> (default), <code>"less"</code>, or <code>"greater"</code>. You can
specify just the initial letter of the value, but the argument name must be
given in full. See ‘Details’ for the meanings of the possible values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The statistic of Vuong likelihood ratio test for compare two
non-nested regression models is defined by
</p>
<p style="text-align: center;"><code class="reqn">T = \frac{1}{\widehat{\omega}^2\,\sqrt{n}}\,\sum_{i=1}^{n}\,
\log\frac{f(y_i \mid \boldsymbol{x}_i, \widehat{\boldsymbol{\theta}})}{
g(y_i \mid \boldsymbol{x}_i,\widehat{\boldsymbol{\gamma}})}</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\widehat{\omega}^2 = \frac{1}{n}\,\sum_{i=1}^{n}\,\left(\log \frac{f(y_i \mid \boldsymbol{x}_i, \widehat{\boldsymbol{\theta}})}{g(y_i \mid \boldsymbol{x}_i, \widehat{\boldsymbol{\gamma}})}\right)^2 - \left[\frac{1}{n}\,\sum_{i=1}^{n}\,\left(\log \frac{f(y_i \mid \boldsymbol{x}_i, \widehat{\boldsymbol{\theta}})}{ g(y_i \mid \boldsymbol{x}_i, \widehat{\boldsymbol{\gamma}})}\right)\right]^2</code>
</p>

<p>is an estimator for the variance of
<code class="reqn">\frac{1}{\sqrt{n}}\,\displaystyle\sum_{i=1}^{n}\,\log\frac{f(y_i \mid \boldsymbol{x}_i, \widehat{\boldsymbol{\theta}})}{g(y_i \mid \boldsymbol{x}_i, \widehat{\boldsymbol{\gamma}})}</code>,
<code class="reqn">f(y_i \mid \boldsymbol{x}_i, \widehat{\boldsymbol{\theta}})</code> and
<code class="reqn">g(y_i \mid \boldsymbol{x}_i, \widehat{\boldsymbol{\gamma}})</code>
are the corresponding rival densities evaluated at the maximum likelihood estimates.
</p>
<p>When <code class="reqn">n \rightarrow \infty</code> we have that <code class="reqn">T \rightarrow N(0, 1)</code> in distribution.
Therefore, at <code class="reqn">\alpha\%</code> level of significance  the null hypothesis of
the equivalence of the competing models is rejected if <code class="reqn">|T| &gt; z_{\alpha/2}</code>,
where <code class="reqn">z_{\alpha/2}</code> is the <code class="reqn">\alpha/2</code> quantile of standard normal distribution.
</p>
<p>In practical terms, <code class="reqn">f(y_i \mid \boldsymbol{x}_i, \widehat{\boldsymbol{\theta}})</code>
is better (worse) than <code class="reqn">g(y_i \mid \boldsymbol{x}_i, \widehat{\boldsymbol{\gamma}})</code>
if <code class="reqn">T&gt;z_{\alpha/2}</code> (or <code class="reqn">T&lt; -z_{\alpha/2}</code>).
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following
components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string with the method used.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string ginven the name of families models under comparison.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>André F. B. Menezes
</p>
<p>Josmar Mazucheli
</p>


<h3>References</h3>

<p>Vuong, Q. (1989). Likelihood ratio tests for model selection and
non-nested hypotheses. <em>Econometrica</em>, <b>57</b>(2), 307&ndash;333.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim_bounded, package = "unitquantreg")
sim_bounded_curr &lt;- sim_bounded[sim_bounded$family == "uweibull", ]

fit_uweibull &lt;- unitquantreg(formula = y1 ~ x, tau = 0.5,
                             data = sim_bounded_curr,
                             family = "uweibull")
fit_kum &lt;- unitquantreg(formula = y1 ~ x, tau = 0.5,
                             data = sim_bounded_curr,
                             family = "kum")

ans &lt;- vuong.test(object1 = fit_uweibull, object2 = fit_kum)
ans
str(ans)


</code></pre>

<hr>
<h2 id='water'>Access to piped water supply data set</h2><span id='topic+water'></span>

<h3>Description</h3>

<p>The access of people in households with piped water supply in the cities of Brazil from
the Southeast and Northeast regions. Information obtained during the census of 2010.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(water, package = "unitquantreg")
</code></pre>


<h3>Format</h3>

<p><code><a href="base.html#topic+data.frame">data.frame</a></code> with 3457 observations and 5 columns:
</p>

<ul>
<li> <p><code>phpws</code>: the proportion of households with piped water supply.
</p>
</li>
<li> <p><code>mhdi</code>: municipal human development index.
</p>
</li>
<li> <p><code>incpc</code>: per capita income.
</p>
</li>
<li> <p><code>region</code>: 0 for Southeast, 1 for Northeast.
</p>
</li>
<li> <p><code>pop</code>: total population.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>André F. B. Menezes
</p>


<h3>References</h3>

<p>Mazucheli, J., Menezes, A. F. B., Fernandes, L. B., Oliveira, R. P. and Ghitany, M. E., (2020).
The unit-Weibull distribution as an alternative to the Kumaraswamy distribution for the
modeling of quantiles conditional on covariates. <em>Jounal of Applied Statistics</em>, <b>47</b>(6), 954&ndash;974.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
