<!DOCTYPE html><html><head><title>Help for package cylcop</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cylcop}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cylcop-package'><p>cylcop: Circular-Linear Copulas with Angular Symmetry for Movement Data</p></a></li>
<li><a href='#angstep2xy'><p>Calculate the Next Position in a Trajectory from a Turn Angle and a Step Length</p></a></li>
<li><a href='#bearing'><p>Compass Bearing of a Line Between 2 Points</p></a></li>
<li><a href='#ccylcop'><p>Conditional Distributions of Circular-Linear Copulas</p></a></li>
<li><a href='#cor_cyl'><p>Estimate a Rank-Based Circular-Linear Correlation Coefficient</p></a></li>
<li><a href='#cramer_vonmises'><p>Cramér-von-Mises criterion</p></a></li>
<li><a href='#cyl_copula-class'><p>An S4 Class of Bivariate Copulas on the Cylinder</p></a></li>
<li><a href='#cyl_cubsec'><p>Construction of '<code>cyl_cubsec</code>' Objects</p></a></li>
<li><a href='#cyl_cubsec-class'><p>An S4 Class of Bivariate Copulas with Cubic Sections</p></a></li>
<li><a href='#cyl_quadsec'><p>Construction of '<code>cyl_quadsec</code>' Objects</p></a></li>
<li><a href='#cyl_quadsec-class'><p>An S4 Class of Bivariate Copulas with Quadratic Sections</p></a></li>
<li><a href='#cyl_rect_combine'><p>Construction of '<code>cyl_rect_combine</code>' Objects</p></a></li>
<li><a href='#cyl_rect_combine-class'><p>An S4 Class of Circular-Linear Copulas Generated from a Rectangular Patchwork</p></a></li>
<li><a href='#cyl_rot_combine'><p>Construction of '<code>cyl_rot_combine</code>' Objects</p></a></li>
<li><a href='#cyl_rot_combine-class'><p>An S4 Class of Circular-Linear Copulas generated from Linear Combinations</p>
of Copulas</a></li>
<li><a href='#cyl_vonmises'><p>Construction of '<code>cyl_vonmises</code>' Objects</p></a></li>
<li><a href='#cyl_vonmises-class'><p>An S4 Class of Bivariate von Mises Copulas</p></a></li>
<li><a href='#Cylcop'><p>Distribution, Density, and Random Number Generation for Circular-Linear Copulas'</p></a></li>
<li><a href='#cylcop_get_option'><p>Get Package Options</p></a></li>
<li><a href='#cylcop_set_option'><p>Set Package Options</p></a></li>
<li><a href='#cylcop-deprecated'><p>Deprecated functions</p></a></li>
<li><a href='#dens'><p>Density, Distribution, Random Number Generation and Quantiles of Kernel Density Estimates</p></a></li>
<li><a href='#fit_angle'><p>Fit a Circular Univariate Distribution</p></a></li>
<li><a href='#fit_cylcop_cor'><p>Estimate Copula Parameters from Correlation Measures</p></a></li>
<li><a href='#fit_cylcop_ml'><p>Estimate Parameters of a Circular-Linear Copula According to Maximum Likelihood</p></a></li>
<li><a href='#fit_steplength'><p>Fit a Linear Univariate Distribution</p></a></li>
<li><a href='#full2half_circ'><p>Convert Angle from Full Circle to Half Circle</p></a></li>
<li><a href='#gammamix'><p>Density, Distribution, Quantiles and Random Number Generation for the mixed gamma</p>
distribution</a></li>
<li><a href='#half2full_circ'><p>Convert Angle from Half Circle to Full Circle</p></a></li>
<li><a href='#joint'><p>Density, Distribution, Quantiles and Random Number Generation for joint</p>
distributions</a></li>
<li><a href='#lnormmix'><p>Density, Distribution, Quantiles and Random Number Generation for the mixed log-normal</p>
distribution</a></li>
<li><a href='#mi_cyl'><p>Estimate the Mutual Information Between a Circular and a Linear Random</p>
Variable</a></li>
<li><a href='#mle.vonmisesmix'><p>Mixed von Mises Maximum Likelihood Estimates</p></a></li>
<li><a href='#normmix'><p>Density, Distribution, Quantiles and Random Number Generation for the mixed normal</p>
distribution</a></li>
<li><a href='#numerical_conditional_cop'><p>Numerically Calculate the Conditional Copula</p></a></li>
<li><a href='#numerical_inv_conditional_cop'><p>Numerically calculate the inverse of the conditional copula</p></a></li>
<li><a href='#opt_auto'><p>Automatically Find the Best Fitting Copula</p></a></li>
<li><a href='#opt_circ_bw'><p>Find the Optimal Bandwidth for a Circular Kernel Density Estimate</p></a></li>
<li><a href='#opt_lin_bw'><p>Find the Optimal Bandwidth for a Linear Kernel Density Estimate</p></a></li>
<li><a href='#plot_circ_hist'><p>Circular Histogram of Turn Angles</p></a></li>
<li><a href='#plot_cop_scat'><p>Scatterplot of Copula Values</p></a></li>
<li><a href='#plot_cop_surf'><p>Surface Plot or Heat Map of the Distribution or the Density of a Copula</p></a></li>
<li><a href='#plot_joint_box'><p>Circular Boxplot of Turn Angles and Step Lengths</p></a></li>
<li><a href='#plot_joint_circ'><p>Circular Scatterplot of Turn Angles and Step Lengths</p></a></li>
<li><a href='#plot_joint_scat'><p>Scatterplot of Turn Angles and Step Lengths</p></a></li>
<li><a href='#plot_track'><p>Plot a Trajectory in Euclidean Space</p></a></li>
<li><a href='#plot,cyl_copula,missing-method'><p>Plot '<code>cyl_copula</code>' Objects</p></a></li>
<li><a href='#prob,cyl_copula-method'><p>Calculate the C-Volume of a '<code>cyl_copula</code>' Copula</p></a></li>
<li><a href='#set_cop_param'><p>Change Attributes of '<code>cyl_copula</code>' Objects</p></a></li>
<li><a href='#show,cyl_copula-method'><p>Print Information of '<code>cyl_copula</code>' Objects</p></a></li>
<li><a href='#traj_get'><p>Get a Trajectory from Coordinates</p></a></li>
<li><a href='#traj_sim'><p>Generate a Trajectory with Correlated Step Lengths and Turn Angles</p></a></li>
<li><a href='#vonmisesmix'><p>Density, Distribution, Quantiles and Random Number Generation for the mixed von</p>
Mises Distribution</a></li>
<li><a href='#wasserstein'><p>Calculate the Wasserstein Distance</p></a></li>
<li><a href='#weibullmix'><p>Density, Distribution, Quantiles and Random Number Generation for the mixed Weibull</p>
distribution</a></li>
<li><a href='#wrappedcauchy'><p>Density, Distribution, Quantiles and Random Number Generation for the Wrapped</p>
Cauchy Distribution</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Circular-Linear Copulas with Angular Symmetry for Movement Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/r-lib/devtools">https://github.com/r-lib/devtools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-lib/devtools/issues">https://github.com/r-lib/devtools/issues</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Florian Hodel &lt;florian.hodel@yahoo.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Classes (S4) of circular-linear, symmetric copulas with corresponding
    methods, extending the 'copula' package. These copulas are especially useful
    for modeling correlation in discrete-time movement data. Methods for density, 
    (conditional) distribution, random number generation, bivariate dependence
    measures and fitting parameters using maximum likelihood and other 
    approaches. The package also contains methods for visualizing movement data
    and copulas.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5),</td>
</tr>
<tr>
<td>Imports:</td>
<td>circular, stats, purrr, dplyr (&ge; 0.7.0), copula, stringr,
rlang, methods, GoFKernel, MASS, data.table, infotheo, ggplot2,
utils, rgl, viridis, plotly, cowplot, movMF, Rdpack, mixR,
transport</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'cyl_cop_class.R' 'Ccond.R' 'aaaglobal.R' 'correlation.R'
'cyl_cubsec.R' 'cyl_quadsec.R' 'cyl_rect_combine.R'
'cyl_rot_combine.R' 'cyl_vonmises.R' 'cylcop-package.R'
'density.R' 'deprecated.R' 'fit_cop_corr.R' 'fit_cop_mle.R'
'fit_margin.R' 'gof.R' 'joint_distr.R' 'mixed_linear.R'
'mixedvonmises.R' 'opt_auto.R' 'plotting_functions.R'
'simulate_trajectory.R' 'utils.R' 'wrappedcauchy.R' 'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-29 19:49:57 UTC; Flo</td>
</tr>
<tr>
<td>Author:</td>
<td>Florian Hodel <a href="https://orcid.org/0000-0002-0099-1006"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-29 22:00:21 UTC</td>
</tr>
</table>
<hr>
<h2 id='cylcop-package'>cylcop: Circular-Linear Copulas with Angular Symmetry for Movement Data</h2><span id='topic+cylcop'></span><span id='topic+cylcop-package'></span>

<h3>Description</h3>

<p>Classes (S4) of circular-linear, symmetric copulas with corresponding methods, extending the 'copula' package. These copulas are especially useful for modeling correlation in discrete-time movement data. Methods for density, (conditional) distribution, random number generation, bivariate dependence measures and fitting parameters using maximum likelihood and other approaches. The package also contains methods for visualizing movement data and copulas.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Florian Hodel <a href="mailto:florian.hodel@yahoo.com">florian.hodel@yahoo.com</a> (<a href="https://orcid.org/0000-0002-0099-1006">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/r-lib/devtools">https://github.com/r-lib/devtools</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-lib/devtools/issues">https://github.com/r-lib/devtools/issues</a>
</p>
</li></ul>


<hr>
<h2 id='angstep2xy'>Calculate the Next Position in a Trajectory from a Turn Angle and a Step Length</h2><span id='topic+angstep2xy'></span>

<h3>Description</h3>

<p>The x-y-coordinates of a position in 2-D space is calculated from the angle
between that position and the 2 previous ones in the trajectory and the
distance between that position and the previous one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angstep2xy(angle, steplength, prevp1, prevp2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angstep2xy_+3A_angle">angle</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> value of the turn angle or a
<code><a href="circular.html#topic+circular">circular</a></code> object, either in <code class="reqn">[0, 2\pi)</code> or in <code class="reqn">[-\pi, \pi)</code></p>
</td></tr>
<tr><td><code id="angstep2xy_+3A_steplength">steplength</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> value giving the distance between the
position and the previous one.</p>
</td></tr>
<tr><td><code id="angstep2xy_+3A_prevp1">prevp1</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the x and y
coordinates of the previous position.</p>
</td></tr>
<tr><td><code id="angstep2xy_+3A_prevp2">prevp2</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the x and y
coordinates of the position before the previous one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a <a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a>
holding the x and y coordinates of the position
</p>


<h3>Examples</h3>

<pre><code class='language-R'> angstep2xy(1.5*pi, 2, prevp1 = c(1, 4), prevp2 = c(2, 7.5))
 angstep2xy(-0.5*pi, 2, c(1, 4), c(2, 7.5))
</code></pre>

<hr>
<h2 id='bearing'>Compass Bearing of a Line Between 2 Points</h2><span id='topic+bearing'></span>

<h3>Description</h3>

<p>The angle between a line between 2 points in Euclidean 2-D space and the line from
(0,0) to (0,1) is calculated. In other words, the compass bearing of a line
between 2 points where north is 0. Angles increase in clockwise direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bearing(point1, point2, fullcirc = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bearing_+3A_point1">point1</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the
x and y coordinates of the first point.</p>
</td></tr>
<tr><td><code id="bearing_+3A_point2">point2</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the
x and y coordinates of the second point.</p>
</td></tr>
<tr><td><code id="bearing_+3A_fullcirc">fullcirc</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> value indicating whether the output
should be an angle on <code class="reqn">[0, 2\pi)</code> or <code class="reqn">[-\pi, \pi)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>fullcirc = FALSE</code>, the function returns a <a href="base.html#topic+numeric">numeric</a>
value (angle) from the interval <code class="reqn">[-\pi, \pi)</code>. <br />
If <code>fullcirc = TRUE</code>, the function returns a numeric value <a href="base.html#topic+numeric">numeric</a> from the interval
<code class="reqn">[0, 2\pi)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bearing(c(3,5), c(1,4))
bearing(c(3,5), c(1,4), fullcirc = TRUE)
</code></pre>

<hr>
<h2 id='ccylcop'>Conditional Distributions of Circular-Linear Copulas</h2><span id='topic+ccylcop'></span><span id='topic+ccylcop+2CCopula-method'></span><span id='topic+ccylcop+2Ccyl_cubsec-method'></span><span id='topic+ccylcop+2Ccyl_quadsec-method'></span><span id='topic+ccylcop+2Ccyl_rect_combine-method'></span><span id='topic+ccylcop+2Ccyl_rot_combine-method'></span><span id='topic+ccylcop+2Ccyl_vonmises-method'></span>

<h3>Description</h3>

<p>Calculates the conditional distributions and their inverses of circular-linear
copulas and 2-dimensional linear-linear copulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccylcop(u, copula, cond_on = 2, inverse = FALSE, ...)

## S4 method for signature 'Copula'
ccylcop(u, copula, cond_on, inverse)

## S4 method for signature 'cyl_cubsec'
ccylcop(u, copula, cond_on = 2, inverse = FALSE)

## S4 method for signature 'cyl_quadsec'
ccylcop(u, copula, cond_on = 2, inverse = FALSE)

## S4 method for signature 'cyl_rect_combine'
ccylcop(u, copula, cond_on = 2, inverse = FALSE)

## S4 method for signature 'cyl_rot_combine'
ccylcop(u, copula, cond_on = 2, inverse = FALSE)

## S4 method for signature 'cyl_vonmises'
ccylcop(u, copula, cond_on = 2, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ccylcop_+3A_u">u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> (or <a href="base.html#topic+vector">vector</a>) of <a href="base.html#topic+numeric">numeric</a>
values in <code class="reqn">[0,1]^2</code>, containing as first column
the circular (periodic) and as second the linear dimension.</p>
</td></tr>
<tr><td><code id="ccylcop_+3A_copula">copula</code></td>
<td>
<p><span class="rlang"><b>R</b></span> object of class '<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>'.
or '<code><a href="copula.html#topic+Copula-class">Copula</a></code>' (package '<span class="pkg">copula</span>', only 2-dimensional).</p>
</td></tr>
<tr><td><code id="ccylcop_+3A_cond_on">cond_on</code></td>
<td>
<p>column number of <code>u</code> on which the copula is conditioned. E.g if
<code>cond_on = 2</code>, the function calculates for each element in the first
column of <code>u</code> the copula conditional on the corresponding element in the
second column.</p>
</td></tr>
<tr><td><code id="ccylcop_+3A_inverse">inverse</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> indicating whether the inverse of the conditional copula is
calculated.</p>
</td></tr>
<tr><td><code id="ccylcop_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic that calls the function <code>copula::<a href="copula.html#topic+cCopula">cCopula</a>()</code>
for 2-dimensional '<code><a href="copula.html#topic+Copula-class">Copula</a></code>' objects from the '<span class="pkg">copula</span>'
package for which <code>copula::<a href="copula.html#topic+cCopula">cCopula</a>()</code> is available. If
<code>copula::<a href="copula.html#topic+cCopula">cCopula</a>()</code> is not available, the conditional copula is
calculated numerically. For '<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>' objects,
the conditional copula is calculated analytically or numerically
(depending on the copula and  the values of <code>u</code>).
Note that the input arguments and the
output of <code>cylcop::ccylcop()</code> differ from those of
<code>copula::<a href="copula.html#topic+cCopula">cCopula</a>()</code>.
</p>


<h3>Value</h3>

<p>A vector containing the values of the distribution of the copula at
<code>u[,-cond_on]</code> conditional on the values of <code>u[,cond_on]</code>.
</p>


<h3>References</h3>

<p>Nelsen RB (2006).
<em>An Introduction to Copulas</em>, volume 139 of <em>Lecture Notes in Statistics</em>.
Springer New York, New York, NY.
ISBN 978-0-387-98623-4, <a href="https://doi.org/10.1007/978-1-4757-3076-0">doi:10.1007/978-1-4757-3076-0</a>, <a href="https://link.springer.com/book/10.1007/978-1-4757-3076-0">https://link.springer.com/book/10.1007/978-1-4757-3076-0</a>.
</p>
<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>


<h3>See Also</h3>

<p><code>copula::<a href="copula.html#topic+cCopula">cCopula</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cop &lt;- cyl_quadsec(0.1)
#calculate C_u(v) with u = 0.1 and v = 0.5
cylcop::ccylcop(u = c(0.1, 0.5), copula = cop, cond_on = 1, inverse = FALSE)
#calculate C^-1_v(u) with u = 0.1 and v = 0.5 and with u = 0.4 and v = 0.2
cylcop::ccylcop(u = rbind(c(0.1, 0.5), c(0.4, 0.2)), copula = cop, cond_on = 2, inverse = TRUE)

</code></pre>

<hr>
<h2 id='cor_cyl'>Estimate a Rank-Based Circular-Linear Correlation Coefficient</h2><span id='topic+cor_cyl'></span>

<h3>Description</h3>

<p>The code is based on Mardia (1976),
Solow et al. (1988) and Tu (2015).
The function returns a numeric value between 0 and 1, not -1 and 1, positive
and negative correlation cannot be discerned. Note also that the correlation
coefficient is independent of the marginal distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_cyl(theta, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_cyl_+3A_theta">theta</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of angles
(measurements of a circular variable).</p>
</td></tr>
<tr><td><code id="cor_cyl_+3A_x">x</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of step lengths
(measurements of a linear variable).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="base.html#topic+numeric">numeric</a> value between 0 and 1, the circular-linear
correlation coefficient.
</p>


<h3>References</h3>

<p>Mardia KV (1976).
&ldquo;Linear-Circular Correlation Coefficients and Rhythmometry.&rdquo;
<em>Biometrika</em>, <b>63</b>(2), 403&ndash;405.
ISSN 00063444, <a href="https://doi.org/10.2307/2335637">doi:10.2307/2335637</a>.
</p>
<p>Solow AR, Bullister JL, Nevison C (1988).
&ldquo;An application of circular-linear correlation analysis to the relationship between Freon concentration and wind direction in Woods Hole, Massachusetts.&rdquo;
<em>Environmental Monitoring and Assessment</em>, <b>10</b>(3), 219&ndash;228.
ISSN 1573-2959, <a href="https://doi.org/10.1007/BF00395081">doi:10.1007/BF00395081</a>, <a href="https://doi.org/10.1007/BF00395081">https://doi.org/10.1007/BF00395081</a>.
</p>
<p>Tu R (2015).
&ldquo;A Study of the Parametric and Nonparametric Linear-Circular Correlation Coefficient.&rdquo;
<em>California Polytechnic State University, San Luis Obispo</em>, 1&ndash;24.
<a href="https://digitalcommons.calpoly.edu/statsp/51/">https://digitalcommons.calpoly.edu/statsp/51/</a>.
</p>
<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mi_cyl">mi_cyl</a>()</code>, <code><a href="#topic+fit_cylcop_cor">fit_cylcop_cor</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

cop &lt;- cyl_quadsec(0.1)

#draw samples and calculate the correlation coefficient
sample &lt;- rcylcop(100, cop)
cor_cyl(theta = sample[,1], x = sample[,2])

#the correlation coefficient is independent of the marginal distribution.
sample &lt;- traj_sim(100,
  cop,
  marginal_circ = list(name = "vonmises", coef  = list(0, 1)),
  marginal_lin = list(name = "weibull", coef = list(shape = 2))
)
cor_cyl(theta = sample$angle, x = sample$steplength)
cor_cyl(theta = sample$cop_u, x = sample$cop_v)

# Estimate correlation of samples drawn from circular-linear copulas with
# perfect correlation
cop &lt;- cyl_rect_combine(copula::normalCopula(1))
sample &lt;- rcylcop(100, cop)
cor_cyl(theta = sample[,1], x = sample[,2])

</code></pre>

<hr>
<h2 id='cramer_vonmises'>Cramér-von-Mises criterion</h2><span id='topic+cramer_vonmises'></span>

<h3>Description</h3>

<p>Calculate the Cramér-von-Mises criterion
with a p-value (via parametric bootstrapping) to assess the goodness of fit
of a parametric copula compared to the empirical copula of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cramer_vonmises(
  copula,
  theta,
  x,
  n_bootstrap = 1000,
  parameters = NULL,
  optim.method = "L-BFGS-B",
  optim.control = list(maxit = 100)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cramer_vonmises_+3A_copula">copula</code></td>
<td>
<p><span class="rlang"><b>R</b></span> object of class '<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>' or
'<code><a href="copula.html#topic+Copula-class">Copula</a></code>' (package '<span class="pkg">copula</span>'.</p>
</td></tr>
<tr><td><code id="cramer_vonmises_+3A_theta">theta</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of angles
(measurements of a circular variable) or &quot;circular&quot; component of pseudo-observations.</p>
</td></tr>
<tr><td><code id="cramer_vonmises_+3A_x">x</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of step lengths
(measurements of a linear variable) or &quot;linear&quot; component of pseudo-observations.</p>
</td></tr>
<tr><td><code id="cramer_vonmises_+3A_n_bootstrap">n_bootstrap</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> number of bootstrap replicates. If
<code>n_bootstrap</code> is smaller than 1, no p-value is calculated.</p>
</td></tr>
<tr><td><code id="cramer_vonmises_+3A_parameters">parameters</code></td>
<td>
<p><a href="base.html#topic+vector">vector</a> of <a href="base.html#topic+character">character</a> strings
holding the names of the parameters to be optimized when using the bootstrap
procedure.
These can be any parameters in <code>copula@parameters</code>. Default is to
optimize the first 2 parameters. <code>parameters</code> has no effect if <code>copula</code>
is of class '<code><a href="copula.html#topic+Copula-class">Copula</a></code>' (package '<span class="pkg">copula</span>'</p>
</td></tr>
<tr><td><code id="cramer_vonmises_+3A_optim.method">optim.method</code></td>
<td>
<p><a href="base.html#topic+character">character</a> string, optimizer used in
<code><a href="stats.html#topic+optim">optim</a>()</code>, can be
<code>"Nelder-Mead"</code>, <code>"BFGS"</code>, <code>"CG"</code>, <code>"L-BFGS-B"</code>,
<code>"SANN"</code>, or <code>"Brent"</code>.</p>
</td></tr>
<tr><td><code id="cramer_vonmises_+3A_optim.control">optim.control</code></td>
<td>
<p><a href="base.html#topic+list">list</a> of additional controls passed to
<code><a href="stats.html#topic+optim">optim</a>()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Cramér-von Misses criterion is calculated as the sum of the squared
differences between the empirical copula and the parametric copula, <code>copula</code>,
evaluated at the pseudo-observations obtained from <code>theta</code> and <code>x</code>.
If the bootstrap procedure is used, a random sample is drawn from <code>copula</code>
and converted to pseudo-observations. A new (set of) copula parameter(s) is then
fit to those pseudo-observations using maximum likelihood (function
<code>cylcop::<a href="#topic+fit_cylcop_ml">fit_cylcop_ml</a>()</code>).
</p>


<h3>Value</h3>

<p>A list of length 2 containing the Cramér-von Mises criterion and the p-value.
</p>


<h3>References</h3>

<p>Genest C, Rémillard B (2008).
&ldquo;Validity of the parametric bootstrap for goodness-of-fit testing in semiparametric models.&rdquo;
<em>Annales de l'Institut Henri Poincaré, Probabilités et Statistiques</em>, <b>44</b>(6), 1096 &ndash; 1127.
<a href="https://doi.org/10.1214/07-AIHP148">doi:10.1214/07-AIHP148</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
sample &lt;- rcylcop(100,cyl_cubsec(0.1, 0.1))

opt_cop &lt;- fit_cylcop_ml(copula = cyl_quadsec(),
  theta = sample[,1],
  x = sample[,2],
  parameters = "a",
  start = 0
)$copula
cramer_vonmises(opt_cop,
  theta = sample[,1],
  x = sample[,2],
  n_bootstrap=5)

</code></pre>

<hr>
<h2 id='cyl_copula-class'>An S4 Class of Bivariate Copulas on the Cylinder</h2><span id='topic+cyl_copula-class'></span>

<h3>Description</h3>

<p>The class '<code>cyl_copula</code>' follows somewhat the structure of the class
'<code><a href="copula.html#topic+Copula-class">Copula</a></code>' of the package '<span class="pkg">copula</span>'. It contains
circular-linear copulas.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p><a href="base.html#topic+character">character</a> string holding the name of the copula.</p>
</dd>
<dt><code>parameters</code></dt><dd><p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the parameter values.</p>
</dd>
<dt><code>param.names</code></dt><dd><p><a href="base.html#topic+character">character</a> <a href="base.html#topic+vector">vector</a> holding the parameter names.</p>
</dd>
<dt><code>param.lowbnd</code></dt><dd><p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the lower bounds of the parameters.</p>
</dd>
<dt><code>param.upbnd</code></dt><dd><p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the upper bounds of the parameters.</p>
</dd>
</dl>


<h3>Extended by</h3>

<p>'<code>cyl_copula</code>' is extended by the following classes:
</p>

<ul>
<li><p> '<code><a href="#topic+cyl_vonmises-class">cyl_vonmises</a></code>': von Mises copulas.
</p>
</li>
<li><p> '<code><a href="#topic+cyl_quadsec-class">cyl_quadsec</a></code>': Copulas with quadratic sections.
</p>
</li>
<li><p> '<code><a href="#topic+cyl_cubsec-class">cyl_cubsec</a></code>': Copulas with cubic sections.
</p>
</li>
<li><p> '<code><a href="#topic+cyl_rot_combine-class">cyl_rot_combine</a></code>': Linear combinations of copulas and their
180 degree rotations.
</p>
</li>
<li><p> '<code><a href="#topic+cyl_rect_combine-class">cyl_rect_combine</a></code>': Rectangular patchwork copulas.
</p>
</li></ul>



<h3>Objects from the Class</h3>

<p>Objects are created by the functions <code><a href="#topic+cyl_vonmises">cyl_vonmises</a>()</code>,
<code><a href="#topic+cyl_quadsec">cyl_quadsec</a>()</code>, <code><a href="#topic+cyl_cubsec">cyl_cubsec</a>()</code>, <code><a href="#topic+cyl_rot_combine">cyl_rot_combine</a>()</code>,
and <code><a href="#topic+cyl_rect_combine">cyl_rect_combine</a>()</code>.
</p>


<h3>References</h3>

<p>Hodel FH, Fieberg JR (2022).
&ldquo;Circular-Linear Copulae for Animal Movement Data.&rdquo;
<em>Methods in Ecology and Evolution</em>.
<a href="https://doi.org/10.1111/2041-210X.13821">doi:10.1111/2041-210X.13821</a>.
</p>
<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cop &lt;- cyl_quadsec(0.1)
is(cop)

</code></pre>

<hr>
<h2 id='cyl_cubsec'>Construction of '<code>cyl_cubsec</code>' Objects</h2><span id='topic+cyl_cubsec'></span>

<h3>Description</h3>

<p>Constructs a circular-linear copula with cubic sections of class
'<code><a href="#topic+cyl_cubsec-class">cyl_cubsec</a></code>'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cyl_cubsec(a = 1/(2 * pi), b = 1/(2 * pi))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cyl_cubsec_+3A_a">a</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> value of the first parameter of the copula.
It must be in <code class="reqn">[- 1 / (2 \pi)), 1 / (2 \pi))]</code>.</p>
</td></tr>
<tr><td><code id="cyl_cubsec_+3A_b">b</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> value of the second parameter of the copula.
It must be in <code class="reqn">[- 1 / (2 \pi)), 1 / (2 \pi))]</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <span class="rlang"><b>R</b></span> object of class '<code><a href="#topic+cyl_cubsec-class">cyl_cubsec</a></code>'.
</p>


<h3>References</h3>

<p>Nelsen RB, Quesada-Molina JJ, Rodr\'iguez-Lallena JA (1997).
&ldquo;Bivariate copulas with cubic sections.&rdquo;
<em>Journal of Nonparametric Statistics</em>, <b>7</b>(3), 205&ndash;220.
ISSN 10485252, <a href="https://doi.org/10.1080/10485259708832700">doi:10.1080/10485259708832700</a>.
</p>
<p>Hodel FH, Fieberg JR (2022).
&ldquo;Circular-Linear Copulae for Animal Movement Data.&rdquo;
<em>Methods in Ecology and Evolution</em>.
<a href="https://doi.org/10.1111/2041-210X.13821">doi:10.1111/2041-210X.13821</a>.
</p>
<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cop &lt;- cyl_cubsec(a = 0.1, b = -0.1)
if(interactive()){
 plot_cop_surf(copula = cop, type = "pdf", plot_type = "ggplot")
}

</code></pre>

<hr>
<h2 id='cyl_cubsec-class'>An S4 Class of Bivariate Copulas with Cubic Sections</h2><span id='topic+cyl_cubsec-class'></span>

<h3>Description</h3>

<p>This class contains bivariate circular-linear copulas with cubic sections in the linear dimension.
They are periodic in the circular dimension, <code class="reqn">u</code>, and symmetric with respect
to <code class="reqn">u=0.5</code>. Therefore,
they can capture correlation in data where there is symmetry between positive and negative angles.
These copulas are described by two parameters, <code>a</code> and <code>b</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p><a href="base.html#topic+character">character</a> string holding the name of the copula.</p>
</dd>
<dt><code>parameters</code></dt><dd><p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the parameter values.</p>
</dd>
<dt><code>param.names</code></dt><dd><p><a href="base.html#topic+character">character</a> <a href="base.html#topic+vector">vector</a> holding the
parameter names.</p>
</dd>
<dt><code>param.lowbnd</code></dt><dd><p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the lower
bounds of the parameters.</p>
</dd>
<dt><code>param.upbnd</code></dt><dd><p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the upper
bounds of the parameters.</p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>Objects are created by <code><a href="#topic+cyl_cubsec">cyl_cubsec</a>()</code>.
</p>


<h3>Extends</h3>

<p>Class '<code>cyl_cubsec</code>' extends class '<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>'.
</p>


<h3>References</h3>

<p>Nelsen RB, Quesada-Molina JJ, Rodr\'iguez-Lallena JA (1997).
&ldquo;Bivariate copulas with cubic sections.&rdquo;
<em>Journal of Nonparametric Statistics</em>, <b>7</b>(3), 205&ndash;220.
ISSN 10485252, <a href="https://doi.org/10.1080/10485259708832700">doi:10.1080/10485259708832700</a>.
</p>
<p>Hodel FH, Fieberg JR (2022).
&ldquo;Circular-Linear Copulae for Animal Movement Data.&rdquo;
<em>Methods in Ecology and Evolution</em>.
<a href="https://doi.org/10.1111/2041-210X.13821">doi:10.1111/2041-210X.13821</a>.
</p>
<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>

<hr>
<h2 id='cyl_quadsec'>Construction of '<code>cyl_quadsec</code>' Objects</h2><span id='topic+cyl_quadsec'></span>

<h3>Description</h3>

<p>Constructs a circular-linear copula with cubic sections of class
'<code><a href="#topic+cyl_quadsec-class">cyl_quadsec</a></code>'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cyl_quadsec(a = 1/(2 * pi))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cyl_quadsec_+3A_a">a</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> value of the parameter of the copula. It must be in
<code class="reqn">[- 1 / (2 \pi)), 1 / (2 \pi))]</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <span class="rlang"><b>R</b></span> object of class '<code><a href="#topic+cyl_quadsec-class">cyl_quadsec</a></code>'.
</p>


<h3>References</h3>

<p>Quesada-Molina JJ, Rodr\'iguez-Lallena JA (1995).
&ldquo;Bivariate copulas with quadratic sections.&rdquo;
<em>Journal of Nonparametric Statistics</em>, <b>5</b>(4), 323&ndash;337.
ISSN 10290311, <a href="https://doi.org/10.1080/10485259508832652">doi:10.1080/10485259508832652</a>.
</p>
<p>Hodel FH, Fieberg JR (2022).
&ldquo;Circular-Linear Copulae for Animal Movement Data.&rdquo;
<em>Methods in Ecology and Evolution</em>.
<a href="https://doi.org/10.1111/2041-210X.13821">doi:10.1111/2041-210X.13821</a>.
</p>
<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cop &lt;- cyl_quadsec(a = 0.1)
if(interactive()){
 plot_cop_surf(copula = cop, type = "pdf", plot_type = "ggplot")
}

</code></pre>

<hr>
<h2 id='cyl_quadsec-class'>An S4 Class of Bivariate Copulas with Quadratic Sections</h2><span id='topic+cyl_quadsec-class'></span>

<h3>Description</h3>

<p>This class contains bivariate circular-linear copulas with quadratic sections
in the linear dimension. They are periodic in the circular dimension, <code class="reqn">u</code>,
and symmetric with respect to <code class="reqn">u=0.5</code>. Therefore,
they can capture correlation in data where there is symmetry between positive
and negative angles. These copulas are described by one parameter, <code>a</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p><a href="base.html#topic+character">character</a> string holding the name of the copula.</p>
</dd>
<dt><code>parameters</code></dt><dd><p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the
parameter value.</p>
</dd>
<dt><code>param.names</code></dt><dd><p><a href="base.html#topic+character">character</a> <a href="base.html#topic+vector">vector</a> holding the
parameter name.</p>
</dd>
<dt><code>param.lowbnd</code></dt><dd><p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the lower
bound of the parameter.</p>
</dd>
<dt><code>param.upbnd</code></dt><dd><p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the upper
bound of the parameter.</p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>Objects are created by <code><a href="#topic+cyl_quadsec">cyl_quadsec</a>()</code>.
</p>


<h3>Extends</h3>

<p>Class '<code>cyl_quadsec</code>' extends class '<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>'.
</p>


<h3>References</h3>

<p>Quesada-Molina JJ, Rodr\'iguez-Lallena JA (1995).
&ldquo;Bivariate copulas with quadratic sections.&rdquo;
<em>Journal of Nonparametric Statistics</em>, <b>5</b>(4), 323&ndash;337.
ISSN 10290311, <a href="https://doi.org/10.1080/10485259508832652">doi:10.1080/10485259508832652</a>.
</p>
<p>Hodel FH, Fieberg JR (2022).
&ldquo;Circular-Linear Copulae for Animal Movement Data.&rdquo;
<em>Methods in Ecology and Evolution</em>.
<a href="https://doi.org/10.1111/2041-210X.13821">doi:10.1111/2041-210X.13821</a>.
</p>
<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>

<hr>
<h2 id='cyl_rect_combine'>Construction of '<code>cyl_rect_combine</code>' Objects</h2><span id='topic+cyl_rect_combine'></span>

<h3>Description</h3>

<p>Constructs a circular-linear copula of class
'<code><a href="#topic+cyl_rect_combine-class">cyl_rect_combine</a></code>' from a rectangular patchwork of copulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cyl_rect_combine(
  copula,
  background = indepCopula(),
  low_rect = c(0, 0.5),
  up_rect = "symmetric",
  flip_up = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cyl_rect_combine_+3A_copula">copula</code></td>
<td>
<p>'<code><a href="copula.html#topic+Copula-class">Copula</a></code>' object of the package
'<span class="pkg">copula</span>' or '<code><a href="#topic+cyl_vonmises-class">cyl_vonmises</a></code>' object, the copula in
the rectangles.</p>
</td></tr>
<tr><td><code id="cyl_rect_combine_+3A_background">background</code></td>
<td>
<p>'<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>' or
'<code><a href="copula.html#topic+Copula-class">Copula</a></code>' object of the package '<span class="pkg">copula</span>',
the copula where no rectangles overlay the unit square. If this copula is not
symmetric, the overall <code>cyl_rect_combine</code>-copula will also not be symmetric.</p>
</td></tr>
<tr><td><code id="cyl_rect_combine_+3A_low_rect">low_rect</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of length 2 containing the
lower and upper edge (u-value) of the lower rectangle.</p>
</td></tr>
<tr><td><code id="cyl_rect_combine_+3A_up_rect">up_rect</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of length 2 containing the lower
and upper edge (u-value) of the upper rectangle, or the character string
&quot;symmetric&quot; if it should be the mirror image (with respect to u=0.5) of the lower rectangle.</p>
</td></tr>
<tr><td><code id="cyl_rect_combine_+3A_flip_up">flip_up</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> value indicating whether the copula (<code>copula</code>)
is rotated 90 degrees in the upper (<code>flip_up = TRUE</code>) or lower rectangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <span class="rlang"><b>R</b></span> object of class '<code><a href="#topic+cyl_rect_combine-class">cyl_rect_combine</a></code>'.
</p>


<h3>References</h3>

<p>Durante F, Saminger-Platz S, Sarkoci P (2009).
&ldquo;Rectangular patchwork for bivariate copulas and tail dependence.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>38</b>(15), 2515&ndash;2527.
ISSN 03610926, <a href="https://doi.org/10.1080/03610920802571203">doi:10.1080/03610920802571203</a>.
</p>
<p>Hodel FH, Fieberg JR (2022).
&ldquo;Circular-Linear Copulae for Animal Movement Data.&rdquo;
<em>Methods in Ecology and Evolution</em>.
<a href="https://doi.org/10.1111/2041-210X.13821">doi:10.1111/2041-210X.13821</a>.
</p>
<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#symmetric rectangles spanning entire unit square
cop &lt;- cyl_rect_combine(copula::frankCopula(2))
if(interactive()){
 plot_cop_surf(copula = cop, type = "pdf", plot_type = "ggplot", resolution = 20)
}

#symmetric rectangles, independence copula as background
cop &lt;- cyl_rect_combine(copula::frankCopula(2),
  low_rect = c(0, 0.3),
  up_rect = "symmetric",
  flip_up = FALSE
)
if(interactive()){
 plot_cop_surf(copula = cop, type = "pdf", plot_type = "ggplot", resolution = 20)
}

#symmetric rectangles, cy_quadsec-copula as background
cop &lt;- cyl_rect_combine(copula::normalCopula(0.3),
  low_rect = c(0.1, 0.4),
  up_rect = "symmetric",
  background = cyl_quadsec(-0.1)
)
if(interactive()){
 plot_cop_surf(copula = cop, type = "pdf", plot_type = "ggplot", resolution = 20)
}

#asymmetric rectangles, von Mises copula as background.
#!!Not a symmetric circular linear copula!!
cop &lt;- cyl_rect_combine(copula::normalCopula(0.3),
  low_rect = c(0.1, 0.4),
  up_rect = c(0.5, 0.7),
  background = cyl_vonmises(mu = pi, kappa = 0.3)
)
if(interactive()){
 plot_cop_surf(copula = cop, type = "pdf", plot_type = "ggplot", resolution = 20)
}

</code></pre>

<hr>
<h2 id='cyl_rect_combine-class'>An S4 Class of Circular-Linear Copulas Generated from a Rectangular Patchwork</h2><span id='topic+cyl_rect_combine-class'></span>

<h3>Description</h3>

<p>This class contains bivariate circular-linear copulas generated from
linear-linear bivariate '<code><a href="copula.html#topic+Copula-class">Copula</a></code>' objects of the package
'<span class="pkg">copula</span>' or circular-linear copulas of class '<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>'.
2 non-overlapping rectangles are laid over the unit square, both have width
1 in v-direction. In the area covered by the first rectangle, the copula is
derived from a linear-linear bivariate '<code><a href="copula.html#topic+Copula-class">Copula</a></code>' object.
Rectangle 2 contains the same copula as rectangle 1, but 90 degrees rotated.
In the area not covered by the rectangles, the &quot;background&quot;, the copula is
derived from a circular-linear '<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>' object.
The copula regions are combined in a way that the overall result on the entire
unit square is also a copula.
</p>


<h3>Details</h3>

<p>With appropriate choices of the rectangles this results in copulas
that are periodic in u-direction (and not in v-direction) and therefore are
circular-linear. When the 2 rectangles are mirror images with
respect to <code class="reqn">u=0.5</code>, the resulting overall copula is symmetric with respect
to <code class="reqn">u=0.5</code>, i.e. there is symmetry between positive and negative angles.
</p>
<p>Note that as &quot;background copula&quot;, we can also chose a linear-linear copula,
the overall result will then, however, not be a symmetric circular linear copula.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p><a href="base.html#topic+character">character</a> string holding the name of the copula.</p>
</dd>
<dt><code>parameters</code></dt><dd><p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the parameter values.</p>
</dd>
<dt><code>param.names</code></dt><dd><p><a href="base.html#topic+character">character</a> <a href="base.html#topic+vector">vector</a> the parameter names.</p>
</dd>
<dt><code>param.lowbnd</code></dt><dd><p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the lower bounds of the
parameters.</p>
</dd>
<dt><code>param.upbnd</code></dt><dd><p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the upper bounds of the
parameters.</p>
</dd>
<dt><code>sym.cop</code></dt><dd><p>'<code><a href="copula.html#topic+Copula-class">Copula</a></code>' object of the package
'<span class="pkg">copula</span>' or '<code><a href="#topic+cyl_vonmises-class">cyl_vonmises</a></code>' object. The copula in
the rectangles.</p>
</dd>
<dt><code>background.cop</code></dt><dd><p>'<code><a href="#topic+cyl_vonmises-class">cyl_vonmises</a></code>' or
'<code><a href="copula.html#topic+Copula-class">Copula</a></code>' object of the package '<span class="pkg">copula</span>',
the copula where no rectangles overlay the unit square. If this copula is not
symmetric, the overall <code>cyl_rect_combine</code>-copula will also not be symmetric.</p>
</dd>
<dt><code>flip_up</code></dt><dd><p><a href="base.html#topic+logical">logical</a> value indicating whether the copula (<code>sym.cop</code>) is
rotated 90 degrees in the upper or lower rectangle.</p>
</dd>
<dt><code>sym_rect</code></dt><dd><p><a href="base.html#topic+logical">logical</a> value indicating whether the upper rectangle was
forced to be a mirror image of the lower one with respect to u=0.5 at the
construction of the object.</p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>Objects are created by
<code><a href="#topic+cyl_rect_combine">cyl_rect_combine</a>()</code>.
</p>


<h3>Extends</h3>

<p>Class '<code>cyl_rect_combine</code>' extends class '<code><a href="copula.html#topic+Copula-class">Copula</a></code>'.
</p>


<h3>References</h3>

<p>Durante F, Saminger-Platz S, Sarkoci P (2009).
&ldquo;Rectangular patchwork for bivariate copulas and tail dependence.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>38</b>(15), 2515&ndash;2527.
ISSN 03610926, <a href="https://doi.org/10.1080/03610920802571203">doi:10.1080/03610920802571203</a>.
</p>
<p>Hodel FH, Fieberg JR (2022).
&ldquo;Circular-Linear Copulae for Animal Movement Data.&rdquo;
<em>Methods in Ecology and Evolution</em>.
<a href="https://doi.org/10.1111/2041-210X.13821">doi:10.1111/2041-210X.13821</a>.
</p>
<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>

<hr>
<h2 id='cyl_rot_combine'>Construction of '<code>cyl_rot_combine</code>' Objects</h2><span id='topic+cyl_rot_combine'></span>

<h3>Description</h3>

<p>Constructs a circular-linear copula of class
'<code><a href="#topic+cyl_rot_combine-class">cyl_rot_combine</a></code>' from linear combinations
of copulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cyl_rot_combine(copula, shift = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cyl_rot_combine_+3A_copula">copula</code></td>
<td>
<p>linear-linear 2-dimensional '<code><a href="copula.html#topic+Copula-class">Copula</a></code>'
object of the package '<span class="pkg">copula</span>'.</p>
</td></tr>
<tr><td><code id="cyl_rot_combine_+3A_shift">shift</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> value indicating whether the (u-periodic)
copula should be shifted by 0.5 in u direction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <span class="rlang"><b>R</b></span> object of class '<code><a href="#topic+cyl_rot_combine-class">cyl_rot_combine</a></code>'.
</p>


<h3>References</h3>

<p>Nelsen RB (2006).
<em>An Introduction to Copulas</em>, volume 139 of <em>Lecture Notes in Statistics</em>.
Springer New York, New York, NY.
ISBN 978-0-387-98623-4, <a href="https://doi.org/10.1007/978-1-4757-3076-0">doi:10.1007/978-1-4757-3076-0</a>, <a href="https://link.springer.com/book/10.1007/978-1-4757-3076-0">https://link.springer.com/book/10.1007/978-1-4757-3076-0</a>.
</p>
<p>Hodel FH, Fieberg JR (2022).
&ldquo;Circular-Linear Copulae for Animal Movement Data.&rdquo;
<em>Methods in Ecology and Evolution</em>.
<a href="https://doi.org/10.1111/2041-210X.13821">doi:10.1111/2041-210X.13821</a>.
</p>
<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cop &lt;- cyl_rot_combine(copula = copula::frankCopula(param = 3), shift = TRUE)
if(interactive()){
 plot_cop_surf(copula = cop, type = "pdf", plot_type = "ggplot", resolution = 20)
}

cop &lt;- cyl_rot_combine(copula = copula::claytonCopula(param = 10), shift = FALSE)
if(interactive()){
 plot_cop_surf(copula = cop, type = "pdf", plot_type = "ggplot", resolution = 20)
}

</code></pre>

<hr>
<h2 id='cyl_rot_combine-class'>An S4 Class of Circular-Linear Copulas generated from Linear Combinations
of Copulas</h2><span id='topic+cyl_rot_combine-class'></span>

<h3>Description</h3>

<p>This class contains bivariate circular-linear copulas, generated from
linear-linear bivariate '<code><a href="copula.html#topic+Copula-class">Copula</a></code>' objects of the package
'<span class="pkg">copula</span>', by taking the arithmetic mean of the original copula and
the 90 deg rotated copula. This results in copulas that are periodic in the
circular dimension, u, and symmetric with respect to <code class="reqn">u=0.5</code>, i.e. positive
and negative angles.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p><a href="base.html#topic+character">character</a> string holding the name of the copula.</p>
</dd>
<dt><code>parameters</code></dt><dd><p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the parameter values.</p>
</dd>
<dt><code>param.names</code></dt><dd><p><a href="base.html#topic+character">character</a> <a href="base.html#topic+vector">vector</a> the parameter names.</p>
</dd>
<dt><code>param.lowbnd</code></dt><dd><p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the lower bounds of the
parameters.</p>
</dd>
<dt><code>param.upbnd</code></dt><dd><p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the upper bounds of the
parameters.</p>
</dd>
<dt><code>orig.cop</code></dt><dd><p>linear-linear 2-dimensional '<code><a href="copula.html#topic+Copula-class">Copula</a></code>'
object of the package '<span class="pkg">copula</span>'.</p>
</dd>
<dt><code>shift</code></dt><dd><p><a href="base.html#topic+logical">logical</a> value indicating whether the (u-periodic)
copula should be shifted by 0.5 in u direction.</p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>Objects are created by    <code><a href="#topic+cyl_rot_combine">cyl_rot_combine</a>()</code>.
</p>


<h3>Extends</h3>

<p>Class '<code>cyl_rot_combine</code>' extends class '<code><a href="copula.html#topic+Copula-class">Copula</a></code>'.
</p>


<h3>References</h3>

<p>Nelsen RB (2006).
<em>An Introduction to Copulas</em>, volume 139 of <em>Lecture Notes in Statistics</em>.
Springer New York, New York, NY.
ISBN 978-0-387-98623-4, <a href="https://doi.org/10.1007/978-1-4757-3076-0">doi:10.1007/978-1-4757-3076-0</a>, <a href="https://link.springer.com/book/10.1007/978-1-4757-3076-0">https://link.springer.com/book/10.1007/978-1-4757-3076-0</a>.
</p>
<p>Hodel FH, Fieberg JR (2022).
&ldquo;Circular-Linear Copulae for Animal Movement Data.&rdquo;
<em>Methods in Ecology and Evolution</em>.
<a href="https://doi.org/10.1111/2041-210X.13821">doi:10.1111/2041-210X.13821</a>.
</p>
<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>

<hr>
<h2 id='cyl_vonmises'>Construction of '<code>cyl_vonmises</code>' Objects</h2><span id='topic+cyl_vonmises'></span>

<h3>Description</h3>

<p>Constructs a circular-linear von Mises copula according to
Johnson and Wehrly (1978) of class
'<code><a href="#topic+cyl_vonmises-class">cyl_vonmises</a></code>'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cyl_vonmises(mu = 0, kappa = 1, flip = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cyl_vonmises_+3A_mu">mu</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> value giving the mean of the von Mises
function used to construct the copula.</p>
</td></tr>
<tr><td><code id="cyl_vonmises_+3A_kappa">kappa</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> value giving the concentration of the
von Mises function used to construct the copula.</p>
</td></tr>
<tr><td><code id="cyl_vonmises_+3A_flip">flip</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> value indicating whether the copula
should be rotated 90 degrees to capture negative correlation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <span class="rlang"><b>R</b></span> object of class '<code><a href="#topic+cyl_vonmises-class">cyl_vonmises</a></code>'.
</p>


<h3>References</h3>

<p>Johnson RA, Wehrly TE (1978).
&ldquo;Some Angular-Linear Distributions and Related Regression Models.&rdquo;
<em>Journal of the American Statistical Association ISSN:</em>, <b>73</b>(363), 602&ndash;606.
ISSN 00401706, <a href="https://doi.org/10.2307/1270921">doi:10.2307/1270921</a>.
</p>
<p>Hodel FH, Fieberg JR (2022).
&ldquo;Circular-Linear Copulae for Animal Movement Data.&rdquo;
<em>Methods in Ecology and Evolution</em>.
<a href="https://doi.org/10.1111/2041-210X.13821">doi:10.1111/2041-210X.13821</a>.
</p>
<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cop &lt;- cyl_vonmises(mu=pi, kappa=10, flip = TRUE)
if(interactive()){
 plot_cop_surf(copula = cop, type = "pdf", plot_type = "ggplot", resolution = 20)
}

cop &lt;- cyl_vonmises(mu=0, kappa=8, flip = FALSE)
if(interactive()){
 plot_cop_surf(copula = cop, type = "pdf", plot_type = "ggplot", resolution = 20)
}

</code></pre>

<hr>
<h2 id='cyl_vonmises-class'>An S4 Class of Bivariate von Mises Copulas</h2><span id='topic+cyl_vonmises-class'></span>

<h3>Description</h3>

<p>This class contains circular-linear copulas that are based on the approach by
Johnson and Wehrly (1978) with a von Mises periodic function.
They are periodic in the circular dimension, u, but not symmetric with
respect to <code class="reqn">u=0.5</code> i.e. there is no symmetry between positive and negative angles.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p><a href="base.html#topic+character">character</a> string holding the name of the copula.</p>
</dd>
<dt><code>parameters</code></dt><dd><p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the parameter values.</p>
</dd>
<dt><code>param.names</code></dt><dd><p><a href="base.html#topic+character">character</a> <a href="base.html#topic+vector">vector</a> holding the
parameter names.</p>
</dd>
<dt><code>param.lowbnd</code></dt><dd><p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the lower
bounds of the parameters.</p>
</dd>
<dt><code>param.upbnd</code></dt><dd><p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the upper
bounds of the parameters.</p>
</dd>
<dt><code>flip</code></dt><dd><p><a href="base.html#topic+logical">logical</a> value indicating whether the copula should
be rotated 90 degrees to capture negative correlation.</p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>Objects are created by <code><a href="#topic+cyl_vonmises">cyl_vonmises</a>()</code>.
</p>


<h3>Extends</h3>

<p>Class '<code>cyl_vonmises</code>' extends class '<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>'.
</p>


<h3>References</h3>

<p>Johnson RA, Wehrly TE (1978).
&ldquo;Some Angular-Linear Distributions and Related Regression Models.&rdquo;
<em>Journal of the American Statistical Association ISSN:</em>, <b>73</b>(363), 602&ndash;606.
ISSN 00401706, <a href="https://doi.org/10.2307/1270921">doi:10.2307/1270921</a>.
</p>
<p>Hodel FH, Fieberg JR (2022).
&ldquo;Circular-Linear Copulae for Animal Movement Data.&rdquo;
<em>Methods in Ecology and Evolution</em>.
<a href="https://doi.org/10.1111/2041-210X.13821">doi:10.1111/2041-210X.13821</a>.
</p>
<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>

<hr>
<h2 id='Cylcop'>Distribution, Density, and Random Number Generation for Circular-Linear Copulas'</h2><span id='topic+Cylcop'></span><span id='topic+rcylcop'></span><span id='topic+pcylcop'></span><span id='topic+dcylcop'></span><span id='topic+dcylcop+2Cmatrix+2CCopula-method'></span><span id='topic+rcylcop+2Cnumeric+2CCopula-method'></span><span id='topic+pcylcop+2Cmatrix+2CCopula-method'></span><span id='topic+rcylcop+2Cnumeric+2Ccyl_cubsec-method'></span><span id='topic+dcylcop+2Cmatrix+2Ccyl_cubsec-method'></span><span id='topic+pcylcop+2Cmatrix+2Ccyl_cubsec-method'></span><span id='topic+rcylcop+2Cnumeric+2Ccyl_quadsec-method'></span><span id='topic+dcylcop+2Cmatrix+2Ccyl_quadsec-method'></span><span id='topic+pcylcop+2Cmatrix+2Ccyl_quadsec-method'></span><span id='topic+rcylcop+2Cnumeric+2Ccyl_rect_combine-method'></span><span id='topic+dcylcop+2Cmatrix+2Ccyl_rect_combine-method'></span><span id='topic+pcylcop+2Cmatrix+2Ccyl_rect_combine-method'></span><span id='topic+rcylcop+2Cnumeric+2Ccyl_rot_combine-method'></span><span id='topic+dcylcop+2Cmatrix+2Ccyl_rot_combine-method'></span><span id='topic+pcylcop+2Cmatrix+2Ccyl_rot_combine-method'></span><span id='topic+rcylcop+2Cnumeric+2Ccyl_vonmises-method'></span><span id='topic+dcylcop+2Cmatrix+2Ccyl_vonmises-method'></span><span id='topic+pcylcop+2Cmatrix+2Ccyl_vonmises-method'></span>

<h3>Description</h3>

<p>Calculate the distribution (<code>pcylcop()</code>), the density (<code>dcylcop()</code>),
and generate random
samples (<code>rcylcop()</code>) of a '<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>' object or a
'<code><a href="copula.html#topic+Copula-class">Copula</a></code>' object (package '<span class="pkg">copula</span>', only 2-dimensional).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcylcop(u, copula)

rcylcop(n, copula)

dcylcop(u, copula, log = FALSE)

## S4 method for signature 'matrix,Copula'
dcylcop(u, copula)

## S4 method for signature 'numeric,Copula'
rcylcop(n, copula)

## S4 method for signature 'matrix,Copula'
pcylcop(u, copula)

## S4 method for signature 'numeric,cyl_cubsec'
rcylcop(n, copula)

## S4 method for signature 'matrix,cyl_cubsec'
dcylcop(u, copula)

## S4 method for signature 'matrix,cyl_cubsec'
pcylcop(u, copula)

## S4 method for signature 'numeric,cyl_quadsec'
rcylcop(n, copula)

## S4 method for signature 'matrix,cyl_quadsec'
dcylcop(u, copula)

## S4 method for signature 'matrix,cyl_quadsec'
pcylcop(u, copula)

## S4 method for signature 'numeric,cyl_rect_combine'
rcylcop(n, copula)

## S4 method for signature 'matrix,cyl_rect_combine'
dcylcop(u, copula)

## S4 method for signature 'matrix,cyl_rect_combine'
pcylcop(u, copula)

## S4 method for signature 'numeric,cyl_rot_combine'
rcylcop(n, copula)

## S4 method for signature 'matrix,cyl_rot_combine'
dcylcop(u, copula)

## S4 method for signature 'matrix,cyl_rot_combine'
pcylcop(u, copula)

## S4 method for signature 'numeric,cyl_vonmises'
rcylcop(n, copula)

## S4 method for signature 'matrix,cyl_vonmises'
dcylcop(u, copula)

## S4 method for signature 'matrix,cyl_vonmises'
pcylcop(u, copula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cylcop_+3A_u">u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> (or <a href="base.html#topic+vector">vector</a>)  of <a href="base.html#topic+numeric">numeric</a>
values in <code class="reqn">[0,1]^2</code>, containing as first column the circular (periodic) and
as second the linear dimension</p>
</td></tr>
<tr><td><code id="Cylcop_+3A_copula">copula</code></td>
<td>
<p><span class="rlang"><b>R</b></span> object of class '<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>'.
or '<code><a href="copula.html#topic+Copula-class">Copula</a></code>' (package '<span class="pkg">copula</span>', only 2-dimensional).</p>
</td></tr>
<tr><td><code id="Cylcop_+3A_n">n</code></td>
<td>
<p>number of random samples to be generated with <code>rcylcop()</code>.</p>
</td></tr>
<tr><td><code id="Cylcop_+3A_log">log</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> indicating if the logarithm of the density
should be returned (<code>dcylcop()</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For '<code><a href="copula.html#topic+Copula-class">Copula</a></code>' objects, <code>pcylcop()</code> and <code>rcylcop()</code>
just call the functions of the '<span class="pkg">copula</span>' package
<code><a href="copula.html#topic+pCopula">pCopula</a>()</code> and <code><a href="copula.html#topic+rCopula">rCopula</a>()</code>, respectively.
The density is, however, calculated differently in <code>dcylcop()</code> and
<code><a href="copula.html#topic+dCopula">dCopula</a>()</code>. The difference is
that <code>copula::<a href="copula.html#topic+dCopula">dCopula</a>()</code>
will return a density of 0 for points on the boundary of the unit square,
whereas <code>dcylcop()</code> will return the correct density on the boundaries
for both '<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>' and '<code><a href="copula.html#topic+Copula-class">Copula</a></code>' objects.
</p>


<h3>Value</h3>

<p>The functions <code>pcylcop()</code> and <code>dcylcop()</code> give a <a href="base.html#topic+vector">vector</a> of
length <code>nrow(u)</code> containing the distribution and the density, respectively,
at the corresponding values of <code>u</code>. The function <code>rcylcop()</code> generates a
<a href="base.html#topic+matrix">matrix</a> with 2 columns and <code>n</code> rows containing
the random samples.
</p>


<h3>References</h3>

<p>Nelsen RB (2006).
<em>An Introduction to Copulas</em>, volume 139 of <em>Lecture Notes in Statistics</em>.
Springer New York, New York, NY.
ISBN 978-0-387-98623-4, <a href="https://doi.org/10.1007/978-1-4757-3076-0">doi:10.1007/978-1-4757-3076-0</a>, <a href="https://link.springer.com/book/10.1007/978-1-4757-3076-0">https://link.springer.com/book/10.1007/978-1-4757-3076-0</a>.
</p>
<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>


<h3>See Also</h3>

<p><code>copula::<a href="copula.html#topic+dCopula">dCopula</a>()</code>,
<code>copula::<a href="copula.html#topic+pCopula">pCopula</a>()</code>,
<code>copula::<a href="copula.html#topic+rCopula">rCopula</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

cop &lt;- cyl_quadsec(0.1)
rcylcop(5, cop)
pcylcop(c(0.3, 0.1), cop)
pcylcop(rbind(c(0.3, 0.1), c(0.2, 1)), cop)

cop &lt;- cyl_rot_combine(copula::frankCopula(2), shift = TRUE)
dcylcop(u = rbind(c(0.1, 0.4), c(1.0, 0.2)), copula = cop)
dcylcop(c(0.1, 0.3), cyl_quadsec(0.1), log = TRUE)

cop &lt;- copula::normalCopula(0.3)
copula::dCopula(c(.Machine$double.eps,0.2),cop)
copula::dCopula(c(0,0.2),cop)
dcylcop(c(.Machine$double.eps,0.2),cop)
dcylcop(c(0,0.2),cop)

</code></pre>

<hr>
<h2 id='cylcop_get_option'>Get Package Options</h2><span id='topic+cylcop_get_option'></span>

<h3>Description</h3>

<p>Currently the only option (<code>"silent"</code>) is to toggle verbosity on or off.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cylcop_get_option(option = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cylcop_get_option_+3A_option">option</code></td>
<td>
<p><a href="base.html#topic+character">character</a> string, the name of the option.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <a href="base.html#topic+numeric">numeric</a> value of option. If no argument is provided, a list
of all options is printed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cylcop_set_option">cylcop_set_option</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cylcop_get_option("silent")
cylcop_get_option()
</code></pre>

<hr>
<h2 id='cylcop_set_option'>Set Package Options</h2><span id='topic+cylcop_set_option'></span><span id='topic+verbose+2C'></span><span id='topic+silent'></span>

<h3>Description</h3>

<p>Currently the only option is to toggle verbosity on or off.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cylcop_set_option(silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cylcop_set_option_+3A_silent">silent</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a>, suppress all sounds and messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No output, only side effects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cylcop_get_option">cylcop_get_option</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cylcop_set_option(silent = FALSE)
</code></pre>

<hr>
<h2 id='cylcop-deprecated'>Deprecated functions</h2><span id='topic+cylcop-deprecated'></span><span id='topic+scat_plot'></span><span id='topic+traj_plot'></span><span id='topic+circ_plot'></span><span id='topic+cop_scat_plot'></span><span id='topic+cop_plot'></span><span id='topic+make_traj'></span><span id='topic+qmixedvonmises'></span><span id='topic+mle.mixedvonmises'></span>

<h3>Description</h3>

<p>These functions are provided for compatibility with older version of
the cylcop package. They may eventually be completely
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scat_plot(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cylcop-deprecated_+3A_...">...</code></td>
<td>
<p>Parameters to be passed to the new versions of the functions</p>
</td></tr>
</table>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: right;">
  <code>scat_plot()</code> </td><td style="text-align: left;"> is replaced by <code><a href="#topic+plot_joint_scat">plot_joint_scat</a>()</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>traj_plot()</code> </td><td style="text-align: left;"> is replaced by <code><a href="#topic+plot_track">plot_track</a>()</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>circ_plot()</code> </td><td style="text-align: left;"> is replaced by <code><a href="#topic+plot_joint_circ">plot_joint_circ</a>()</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>cop_scat_plot()</code> </td><td style="text-align: left;"> is replaced by <code><a href="#topic+plot_cop_scat">plot_cop_scat</a>()</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>cop_plot()</code> </td><td style="text-align: left;"> is replaced by <code><a href="#topic+plot_cop_surf">plot_cop_surf</a>()</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>make_traj()</code> </td><td style="text-align: left;"> is replaced by <code><a href="#topic+traj_sim">traj_sim</a>()</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>qmixedvonmises()</code> </td><td style="text-align: left;"> is replaced by <code><a href="#topic+qvonmisesmix">qvonmisesmix</a>()</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>mle.mixedvonmises()</code> </td><td style="text-align: left;"> is replaced by <code><a href="#topic+mle.vonmisesmix">mle.vonmisesmix</a>()</code></td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>


<hr>
<h2 id='dens'>Density, Distribution, Random Number Generation and Quantiles of Kernel Density Estimates</h2><span id='topic+dens'></span><span id='topic+ddens'></span><span id='topic+pdens'></span><span id='topic+qdens'></span><span id='topic+rdens'></span>

<h3>Description</h3>

<p>Calculate the density (<code>ddens()</code>), the distribution (<code>pdens()</code>),
the quantiles (<code>qdens()</code>) and generate random
samples (<code>rdens()</code>) of a kernel density estimate as returned by
<code><a href="#topic+fit_angle">fit_angle</a>()</code> or <code><a href="#topic+fit_steplength">fit_steplength</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdens(n, density)

ddens(x, density)

pdens(x, density)

qdens(p, density)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dens_+3A_n">n</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> value, the number of random samples to be
generated with <code>rdens()</code>.</p>
</td></tr>
<tr><td><code id="dens_+3A_density">density</code></td>
<td>
<p>a '<code><a href="stats.html#topic+density">density</a></code>' object (for linear kernel density estimates)
or a '<code><a href="circular.html#topic+density.circular">density.circular</a></code>' object
(for circular kernel density estimates) containing information about the kernel density
estimate. These objects can be obtained using
<code><a href="#topic+fit_angle">fit_angle</a>(..., parametric = FALSE)</code> or
<code><a href="#topic+fit_steplength">fit_steplength</a>(..., parametric = FALSE)</code>.</p>
</td></tr>
<tr><td><code id="dens_+3A_x">x</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> giving the points where
the density or distribution function is evaluated.</p>
</td></tr>
<tr><td><code id="dens_+3A_p">p</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> giving the probabilities where
the quantile function is evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ddens()</code> and <code>pdens()</code> give a <a href="base.html#topic+vector">vector</a> of length <code>length(x)</code> containing
the density or distribution function at the corresponding values of <code>x</code>.
<code>qdens()</code> gives a <a href="base.html#topic+vector">vector</a> of length <code>length(p)</code> containing
the quantiles at the corresponding values of <code>p</code>. The function <code>rdens()</code>
generates a <a href="base.html#topic+vector">vector</a> of length <code>n</code> containing the random samples.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_angle">fit_angle</a>()</code>, <code><a href="#topic+fit_steplength">fit_steplength</a>()</code>,
<code><a href="#topic+fit_steplength">fit_steplength</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

steps &lt;- rweibull(10, shape=3)
dens &lt;- fit_steplength(x = steps, parametric = FALSE)
ddens(c(0.1,0.3), dens)
pdens(c(0.1,0.3), dens)
qdens(c(0.1,0.3), dens)
rdens(4, dens)

angles &lt;- full2half_circ(
  circular::rvonmises(10, mu = circular::circular(0), kappa = 2)
)
dens &lt;- fit_angle(theta = angles, parametric = FALSE)
ddens(c(0.1,0.3), dens)
pdens(c(0.1,0.3), dens)
qdens(c(0.1,0.3), dens)
rdens(4, dens)

</code></pre>

<hr>
<h2 id='fit_angle'>Fit a Circular Univariate Distribution</h2><span id='topic+fit_angle'></span>

<h3>Description</h3>

<p>This function finds parameter estimates of the marginal circular
distribution (with potentially fixed mean), or gives a kernel density estimate using
a von Mises smoothing kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_angle(
  theta,
  parametric = c("vonmises", "wrappedcauchy", "vonmisesmix", FALSE),
  bandwidth = NULL,
  mu = NULL,
  ncomp = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_angle_+3A_theta">theta</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of angles in <code class="reqn">[-\pi, \pi)</code>.</p>
</td></tr>
<tr><td><code id="fit_angle_+3A_parametric">parametric</code></td>
<td>
<p>either a <a href="base.html#topic+character">character</a> string describing what distribution
should be fitted (<code>"vonmises"</code>, <code>"wrappedcauchy"</code>, or
<code>"vonmisesmix"</code>), or the <a href="base.html#topic+logical">logical</a> <code>FALSE</code> if a non-parametric
estimation (kernel density) should be made.</p>
</td></tr>
<tr><td><code id="fit_angle_+3A_bandwidth">bandwidth</code></td>
<td>
<p>If <code>parametric = FALSE</code>, the numeric value of the kernel density bandwidth.
Default is <code>cylcop::<a href="#topic+opt_circ_bw">opt_circ_bw</a>(theta, "nrd")</code>.</p>
</td></tr>
<tr><td><code id="fit_angle_+3A_mu">mu</code></td>
<td>
<p>(optional) <a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a>, fixed mean direction(s) of the
parametric distribution.</p>
</td></tr>
<tr><td><code id="fit_angle_+3A_ncomp">ncomp</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a>, number of components of the mixed von Mises distribution.
Only has an effect if <code>parametric="vonmisesmix"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If a parametric estimate is made, a <a href="base.html#topic+list">list</a> is returned
containing the estimated parameters, their
standard errors (if available), the log-likelihood,
the AIC and the name of the distribution.
If a non-parametric estimate is made, the output is a '<code><a href="circular.html#topic+density.circular">density.circular</a></code>' object
obtained with the function <code>circular::<a href="circular.html#topic+density.circular">density.circular</a>()</code> of the '<span class="pkg">circular</span>'
package.
</p>


<h3>See Also</h3>

<p><code>circular::<a href="circular.html#topic+density.circular">density.circular</a>()</code>,
<code><a href="#topic+fit_angle">fit_angle</a>()</code>, <code><a href="#topic+opt_circ_bw">opt_circ_bw</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

silent_curr &lt;- cylcop_get_option("silent")
cylcop_set_option(silent = TRUE)

n &lt;- 10 #n (number of samples) is set small for performance.

angles &lt;- rvonmisesmix(n,
  mu = c(0, pi),
  kappa = c(2,1),
  prop = c(0.5, 0.5)
)

bw &lt;- opt_circ_bw(theta = angles,
  method="nrd",
  kappa.est = "trigmoments"
)
dens_non_param &lt;- fit_angle(theta = angles,
  parametric = FALSE,
  bandwidth = bw
)

param_estimate &lt;- fit_angle(theta = angles,
  parametric = "vonmisesmix"
)
param_estimate_fixed_mean &lt;- fit_angle(theta = angles,
  parametric = "vonmisesmix",
  mu = c(0, pi),
  ncomp =2
)

cylcop_set_option(silent = silent_curr)

</code></pre>

<hr>
<h2 id='fit_cylcop_cor'>Estimate Copula Parameters from Correlation Measures</h2><span id='topic+fit_cylcop_cor'></span><span id='topic+fit_cylcop_cor+2Ccyl_vonmises-method'></span><span id='topic+fit_cylcop_cor+2Ccyl_quadsec-method'></span><span id='topic+fit_cylcop_cor+2Ccyl_cubsec-method'></span><span id='topic+fit_cylcop_cor+2Ccyl_rot_combine-method'></span><span id='topic+fit_cylcop_cor+2Ccyl_rect_combine-method'></span><span id='topic+optCor'></span>

<h3>Description</h3>

<p>This function implements a simple search of the parameter space of a
'<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>' object to find the
parameter values that lead to a correlation that is closest to the correlation
in the data (<code>theta</code> and <code>x</code>). In some special cases of
'<code><a href="#topic+cyl_rect_combine-class">cyl_rect_combine</a></code>' copulas, the parameter can be
obtained analytically from Kendall's tau of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_cylcop_cor(copula, theta, x, acc = NULL, n = 10000, method, ...)

## S4 method for signature 'cyl_vonmises'
fit_cylcop_cor(copula, theta, x, acc, n, method = "cor_cyl")

## S4 method for signature 'cyl_quadsec'
fit_cylcop_cor(copula, theta, x, acc, n, method = "cor_cyl")

## S4 method for signature 'cyl_cubsec'
fit_cylcop_cor(
  copula,
  theta,
  x,
  acc,
  n,
  method = "cor_cyl",
  parameter = "both"
)

## S4 method for signature 'cyl_rot_combine'
fit_cylcop_cor(copula, theta, x, acc, n, method = "mi_cyl")

## S4 method for signature 'cyl_rect_combine'
fit_cylcop_cor(copula, theta, x, acc, n, method = "tau", background = FALSE)

optCor(copula, theta, x, acc = NULL, n = 10000, method, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_cylcop_cor_+3A_copula">copula</code></td>
<td>
<p><span class="rlang"><b>R</b></span> object of class '<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>'.</p>
</td></tr>
<tr><td><code id="fit_cylcop_cor_+3A_theta">theta</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of angles
(measurements of a circular variable).</p>
</td></tr>
<tr><td><code id="fit_cylcop_cor_+3A_x">x</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of step lengths
(measurements of a linear variable).</p>
</td></tr>
<tr><td><code id="fit_cylcop_cor_+3A_acc">acc</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> value, the interval of the copula parameter
at which to evaluate the correlation.</p>
</td></tr>
<tr><td><code id="fit_cylcop_cor_+3A_n">n</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> value, the number of sample points at each
optimization step.</p>
</td></tr>
<tr><td><code id="fit_cylcop_cor_+3A_method">method</code></td>
<td>
<p><a href="base.html#topic+character">character</a> string describing what correlation metric
to use. Either a rank-based circular-linear correlation coefficient (<code>"cor_cyl"</code>),
mutual information (<code>"mi_cyl"</code>), or Kendall's tau (<code>"tau"</code>).</p>
</td></tr>
<tr><td><code id="fit_cylcop_cor_+3A_...">...</code></td>
<td>
<p>Additional parameters (see individual methods).</p>
</td></tr>
<tr><td><code id="fit_cylcop_cor_+3A_parameter">parameter</code></td>
<td>
<p>For '<code><a href="#topic+cyl_cubsec-class">cyl_cubsec</a></code>' copulas: A character
string specifying which parameter of the copula to optimize,
<code>"a"</code>, <code>"b"</code>, or <code>"both"</code></p>
</td></tr>
<tr><td><code id="fit_cylcop_cor_+3A_background">background</code></td>
<td>
<p>For '<code><a href="#topic+cyl_rect_combine-class">cyl_rect_combine</a></code>' copulas :
A <a href="base.html#topic+logical">logical</a> value describing whether to optimize
the parameter of the background copula, (<code>background = TRUE</code>) or
the one of the copula in the rectangles (<code>background = FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code assumes that the correlation captured by the copula increases
monotonously with the copula parameter values. It starts with a parameter value close
to the minimum for that copula and calculates the correlation for a sample of size <code>n</code>
from that copula. Next, the parameter is doubled and again the correlation for a sample
of size <code>n</code> calculated. After this exponential search pattern, a binary search
is implemented similarly between the bounds found with the exponential search. For this
binary search, the interval between those bounds is split into small intervals of length
<code>acc</code>. Thus, smaller values of <code>acc</code> lead to higher accuracy.
</p>
<p>If a '<code><a href="#topic+cyl_rect_combine-class">cyl_rect_combine</a></code>' copula has rectangles spanning
the entire unit square and as background the independence copula, Kendall's tau can be used
to analytically calculate the parameter value leading to the correlation of the data.
No search is necessary in this case. This makes it the recommended method to use
for those '<code><a href="#topic+cyl_rect_combine-class">cyl_rect_combine</a></code>' copulas.
<code>optCor()</code> is an alias for <code>fit_cylcop_cor</code>.
</p>
<p>See also individual methods (below) for more detailed explanations.
</p>


<h3>Value</h3>

<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> containing the estimated
parameter value(s).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fit_cylcop_cor(cyl_vonmises)</code>: only parameter <code>"kappa"</code> can be optimized, since parameter
<code>"mu"</code> does not influence the correlation.
</p>
</li>
<li> <p><code>fit_cylcop_cor(cyl_quadsec)</code>: the absolute value of the parameter is optimized, positive
and negative values give the same correlation.
</p>
</li>
<li> <p><code>fit_cylcop_cor(cyl_cubsec)</code>: optimization of parameters, <code>"a"</code> and <code>"b"</code>,
can be done separately or simultaneously.
</p>
</li>
<li> <p><code>fit_cylcop_cor(cyl_rot_combine)</code>: the circular-linear correlation coefficient will give a
value close to 0 for any parameter value. It therefore only makes sense to
use <code>method = "mi_cyl"</code> for the optimization.
</p>
</li>
<li> <p><code>fit_cylcop_cor(cyl_rect_combine)</code>: if the rectangles span the entire unit square and the background
is the independence copula, it is recommended to use <code>method = "tau"</code>, since this
calculates the copula parameter analytically. If there is a background copula,
other than the independence copula, its parameter can be optimized by setting
<code>background=TRUE</code>.
</p>
</li></ul>


<h3>References</h3>

<p>Hodel FH, Fieberg JR (2022).
&ldquo;Circular-Linear Copulae for Animal Movement Data.&rdquo;
<em>Methods in Ecology and Evolution</em>.
<a href="https://doi.org/10.1111/2041-210X.13821">doi:10.1111/2041-210X.13821</a>.
</p>
<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mi_cyl">mi_cyl</a>()</code>, <code><a href="#topic+cor_cyl">cor_cyl</a>()</code>, <code><a href="#topic+fit_cylcop_ml">fit_cylcop_ml</a>()</code>,
<code><a href="#topic+opt_auto">opt_auto</a>()</code>, <code>copula::<a href="copula.html#topic+fitCopula">fitCopula</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

sample &lt;- rcylcop(100, cyl_rect_combine(copula::frankCopula(2)))
fit_cylcop_cor(cyl_rect_combine(copula::frankCopula()),
  theta = sample[,1],
  x = sample[,2],
  method = "tau"
)

fit_cylcop_cor(cyl_rect_combine(copula::frankCopula()),
  theta = sample[,1],
  x = sample[,2],
  method = "mi_cyl",
  n = 100
)

fit_cylcop_cor(cyl_rect_combine(copula::claytonCopula()),
  theta = sample[,1],
  x = sample[,2],
  method = "tau"
)

fit_cylcop_cor(cyl_quadsec(), theta = sample[,1], x = sample[,2], method = "mi_cyl")
fit_cylcop_cor(cyl_quadsec(), theta = sample[,1], x = sample[,2], method = "cor_cyl")
fit_cylcop_cor(cyl_quadsec(),
  theta = sample[,1],
  x = sample[,2],
  method = "cor_cyl",
  n = 100,
  acc = 0.001
)

optCor(cyl_quadsec(),
 theta = sample[,1],
 x = sample[,2],
 method = "mi_cyl")

</code></pre>

<hr>
<h2 id='fit_cylcop_ml'>Estimate Parameters of a Circular-Linear Copula According to Maximum Likelihood</h2><span id='topic+fit_cylcop_ml'></span><span id='topic+optML'></span>

<h3>Description</h3>

<p>The code of this function is based on <code>copula::<a href="copula.html#topic+fitCopula">fitCopula</a>()</code>.
A circular-linear copula is fit to a set of bivariate observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_cylcop_ml(
  copula,
  theta,
  x,
  parameters = NULL,
  start = NULL,
  lower = NULL,
  upper = NULL,
  optim.method = "L-BFGS-B",
  optim.control = list(maxit = 100),
  estimate.variance = FALSE,
  traceOpt = FALSE
)

optML(
  copula,
  theta,
  x,
  parameters = NULL,
  start = NULL,
  lower = NULL,
  upper = NULL,
  optim.method = "L-BFGS-B",
  optim.control = list(maxit = 100),
  estimate.variance = FALSE,
  traceOpt = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_cylcop_ml_+3A_copula">copula</code></td>
<td>
<p><span class="rlang"><b>R</b></span> object of class '<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>'.</p>
</td></tr>
<tr><td><code id="fit_cylcop_ml_+3A_theta">theta</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of angles
(measurements of a circular variable) or &quot;circular&quot; component of pseudo-observations.</p>
</td></tr>
<tr><td><code id="fit_cylcop_ml_+3A_x">x</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of step lengths
(measurements of a linear variable) or &quot;linear&quot; component of pseudo-observations.</p>
</td></tr>
<tr><td><code id="fit_cylcop_ml_+3A_parameters">parameters</code></td>
<td>
<p><a href="base.html#topic+vector">vector</a> of <a href="base.html#topic+character">character</a> strings
holding the names of the parameters to be optimized.
These can be any parameters in <code>copula@parameters</code>. Default is to
optimize the first 2 parameters or the single parameter if <code>copula</code> only
has 1.</p>
</td></tr>
<tr><td><code id="fit_cylcop_ml_+3A_start">start</code></td>
<td>
<p><a href="base.html#topic+vector">vector</a> of starting values of the parameters. Default is
to take the starting values from <code>copula</code>.</p>
</td></tr>
<tr><td><code id="fit_cylcop_ml_+3A_lower">lower</code></td>
<td>
<p>(optional) <a href="base.html#topic+vector">vector</a> of lower bounds of the parameters.</p>
</td></tr>
<tr><td><code id="fit_cylcop_ml_+3A_upper">upper</code></td>
<td>
<p>(optional) <a href="base.html#topic+vector">vector</a> of upper bounds of the parameters.</p>
</td></tr>
<tr><td><code id="fit_cylcop_ml_+3A_optim.method">optim.method</code></td>
<td>
<p><a href="base.html#topic+character">character</a> string, optimizer used in
<code><a href="stats.html#topic+optim">optim</a>()</code>, can be
<code>"Nelder-Mead"</code>, <code>"BFGS"</code>, <code>"CG"</code>, <code>"L-BFGS-B"</code>,
<code>"SANN"</code>, or <code>"Brent"</code>. Default is &quot;L-BFGS-B&quot;.</p>
</td></tr>
<tr><td><code id="fit_cylcop_ml_+3A_optim.control">optim.control</code></td>
<td>
<p><a href="base.html#topic+list">list</a> of additional controls passed to
<code><a href="stats.html#topic+optim">optim</a>()</code>.</p>
</td></tr>
<tr><td><code id="fit_cylcop_ml_+3A_estimate.variance">estimate.variance</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> value, denoting whether to include an
estimate of the variance (NOT YET IMPLEMENTED).</p>
</td></tr>
<tr><td><code id="fit_cylcop_ml_+3A_traceopt">traceOpt</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> value, whether to print information regarding
convergence, current values, etc. during the optimization process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data is first converted to pseudo observations to which
the copula is then fit. Therefore, the result of the optimization will be
exactly the same whether measurements (<code>theta=theta</code> and <code>x=x</code>)
or pseudo observations (<code>theta=copula::<a href="copula.html#topic+pobs">pobs</a>(theta,x)[,1]</code>
and <code>x=copula::<a href="copula.html#topic+pobs">pobs</a>(theta,x)[,2]</code>) are provided.
If you wish to fit parameters of a '<code><a href="copula.html#topic+Copula-class">Copula</a></code>' object
(package '<span class="pkg">copula</span>'), use the function <code>copula::<a href="copula.html#topic+fitCopula">fitCopula</a>()</code>.
<code>optML()</code> is an alias for <code>fit_cylcop_ml</code>.
</p>


<h3>Value</h3>

<p>A list of length 3 containing the same type of '<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>'
object as <code>copula</code>, but with optimized parameters, the log-likelihood
and the AIC.
</p>


<h3>References</h3>

<p>Hodel FH, Fieberg JR (2022).
&ldquo;Circular-Linear Copulae for Animal Movement Data.&rdquo;
<em>Methods in Ecology and Evolution</em>.
<a href="https://doi.org/10.1111/2041-210X.13821">doi:10.1111/2041-210X.13821</a>.
</p>
<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>


<h3>See Also</h3>

<p><code>copula::<a href="copula.html#topic+fitCopula">fitCopula</a>()</code>, <code><a href="#topic+fit_cylcop_cor">fit_cylcop_cor</a>()</code>,
<code><a href="#topic+opt_auto">opt_auto</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

sample &lt;- rcylcop(100,cyl_quadsec(0.1))
fit_cylcop_ml(copula = cyl_quadsec(),
  theta = sample[,1],
  x = sample[,2],
  parameters = "a",
  start = 0
)
fit_cylcop_ml(copula = cyl_rect_combine(copula::frankCopula()),
  theta = sample[,1],
  x = sample[,2],
  parameters = "alpha",
  start = 1
)


sample &lt;- rjoint(
  n = 100,
  copula = cyl_cubsec(0.1, -0.08),
  marginal_1 = list(name = "vonmisesmix", coef = list(
     mu = c(pi, 0),
     kappa = c(2, 5),
     prop = c(0.3, 0.7)
    )),
  marginal_2 = list(name = "exp", coef = list(0.3))
  )
  fit_cylcop_ml(copula = cyl_cubsec(),
  theta = sample[,1],
  x = sample[,2],
  parameters = c("a","b"),
  start = c(0,0),
  upper= c(0.1, 1/(2*pi))
)

optML(copula = cyl_quadsec(),
  theta = sample[,1],
  x = sample[,2],
  parameters = "a",
  start = 0
)
</code></pre>

<hr>
<h2 id='fit_steplength'>Fit a Linear Univariate Distribution</h2><span id='topic+fit_steplength'></span>

<h3>Description</h3>

<p>This function finds parameter estimates of the marginal linear
distribution, or gives a kernel density estimate using
a Gaussian smoothing kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_steplength(
  x,
  parametric = c("beta", "cauchy", "chi-squared", "chisq", "exponential", "exp", "gamma",
    "lognormal", "lnorm", "lognorm", "logistic", "normal", "t", "weibull", "normalmix",
    "weibullmix", "gammamix", "lnormmix", FALSE),
  start = NULL,
  bandwidth = NULL,
  ncomp = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_steplength_+3A_x">x</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of measurements of a linear
random variable in <code class="reqn">[0,\infty)</code>.</p>
</td></tr>
<tr><td><code id="fit_steplength_+3A_parametric">parametric</code></td>
<td>
<p>either a <a href="base.html#topic+character">character</a> string describing what distribution
should be fitted (<code>"beta"</code>, <code>"cauchy"</code>, <code>"chi-squared"</code>,
<code>"exponential"</code>, <code>"gamma"</code>, <code>"lognormal"</code>, <code>"logistic"</code>,
<code>"normal"</code>, <code>"t"</code>, <code>"weibull"</code>,<code>"normalmix"</code>,
<code>"weibullmix"</code>, <code>"gammamix"</code>, or <code>"lnormmix"</code>),
or the <a href="base.html#topic+logical">logical</a>
<code>FALSE</code> if a non-parametric estimation (kernel density) should be made.</p>
</td></tr>
<tr><td><code id="fit_steplength_+3A_start">start</code></td>
<td>
<p>(optional, except when <code>parametric = "chi-squared"</code>)
named <a href="base.html#topic+list">list</a> containing the parameters to be optimized with initial
values.</p>
</td></tr>
<tr><td><code id="fit_steplength_+3A_bandwidth">bandwidth</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> value for the kernel density bandwidth.
Default is  <code>cylcop::<a href="#topic+opt_lin_bw">opt_lin_bw</a>(x, "nrd")</code>.</p>
</td></tr>
<tr><td><code id="fit_steplength_+3A_ncomp">ncomp</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a>, number of components of the mixed distribution.
Only has an effect if <code>parametric %in% c("normalmix", "weibullmix", "gammamix",
"lnormmix")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If a parametric estimate is made, a <a href="base.html#topic+list">list</a> is returned
containing the estimated parameters, their standard errors,
the log-likelihood, the AIC and the name of the distribution.
If a non-parametric estimate is made, the output is a a '<code><a href="stats.html#topic+density">density</a></code>' object,
which is obtained with the function
<code>GoFKernel::<a href="GoFKernel.html#topic+density.reflected">density.reflected</a>()</code> of the '<span class="pkg">GoFKernel</span>'
package.
</p>


<h3>See Also</h3>

<p><code>GoFKernel::<a href="GoFKernel.html#topic+density.reflected">density.reflected</a>()</code>,
<code><a href="#topic+fit_angle">fit_angle</a>()</code>, <code><a href="#topic+opt_lin_bw">opt_lin_bw</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(graphics)
set.seed(123)

silent_curr &lt;- cylcop_get_option("silent")
cylcop_set_option(silent = TRUE)

n &lt;- 100 #n (number of samples) is set small for performance.

x &lt;- rweibull(n, shape = 10)

dens_non_param &lt;- fit_steplength(x = x, parametric = FALSE)
weibull &lt;- fit_steplength(x = x, parametric = "weibull")
gamma &lt;- fit_steplength(x = x, parametric = "gamma")
chisq &lt;- fit_steplength(x = x, parametric = "chi-squared", start = list(df = 1))

true_dens &lt;- dweibull(seq(0, max(x), length.out = 200),
  shape = 10
)
dens_weibull &lt;- dweibull(seq(0, max(x),length.out = 200),
  shape = weibull$coef$shape,
  scale = weibull$coef$scale
)
dens_gamma &lt;- dgamma(seq(0, max(x),length.out = 200),
  shape = gamma$coef$shape,
  rate = gamma$coef$rate
)
dens_chisq &lt;- dchisq(seq(0, max(x),length.out = 200),
  df = chisq$coef$df
)

plot(seq(0,max(x),length.out = 200), true_dens, type = "l")
lines(dens_non_param$x, dens_non_param$y, col = "red")
lines(seq(0,max(x),length.out = 200), dens_weibull, col = "green")
lines(seq(0,max(x),length.out = 200), dens_gamma, col = "blue")
lines(seq(0,max(x),length.out = 200), dens_chisq, col = "cyan")

cylcop_set_option(silent = silent_curr)

</code></pre>

<hr>
<h2 id='full2half_circ'>Convert Angle from Full Circle to Half Circle</h2><span id='topic+full2half_circ'></span>

<h3>Description</h3>

<p>Converts an angle from the full circle (i.e. in the interval <code class="reqn">[0, 2\pi)</code>)
to an angle on the half circle  (i.e. in the interval <code class="reqn">[-\pi, \pi)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>full2half_circ(angle)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="full2half_circ_+3A_angle">angle</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> value of an angle or a
<code><a href="circular.html#topic+circular">circular</a></code>-object in <code class="reqn">[0, 2\pi)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <a href="base.html#topic+numeric">numeric</a> value of the angle in <code class="reqn">[-\pi, \pi)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>full2half_circ(0 * pi) / pi
full2half_circ(0.5 * pi) / pi
full2half_circ(1 * pi) / pi
full2half_circ(1.5 * pi) / pi
full2half_circ(2 * pi) / pi


</code></pre>

<hr>
<h2 id='gammamix'>Density, Distribution, Quantiles and Random Number Generation for the mixed gamma
distribution</h2><span id='topic+gammamix'></span><span id='topic+rgammamix'></span><span id='topic+pgammamix'></span><span id='topic+dgammamix'></span><span id='topic+qgammamix'></span>

<h3>Description</h3>

<p>The number of components in the mixed gamma distribution is specified by the length
of the parameter vectors. The quantiles are numerically obtained from the distribution function using
monotone cubic splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgammamix(n, shape, rate = 1, scale = 1/rate, prop)

dgammamix(x, shape, rate = 1, scale = 1/rate, prop)

pgammamix(q, shape, rate = 1, scale = 1/rate, prop)

qgammamix(p, shape, rate = 1, scale = 1/rate, prop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gammamix_+3A_n">n</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> value, the number of random samples to be
generated with <code>rgammamix()</code>.</p>
</td></tr>
<tr><td><code id="gammamix_+3A_shape">shape</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the shape parameter
of the components.</p>
</td></tr>
<tr><td><code id="gammamix_+3A_rate">rate</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> an alternative way to specify the scale
(<code>scale = 1 / rate</code>).</p>
</td></tr>
<tr><td><code id="gammamix_+3A_scale">scale</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the scale parameter
of the components.</p>
</td></tr>
<tr><td><code id="gammamix_+3A_prop">prop</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a>, holding the mixing proportions
of the components.</p>
</td></tr>
<tr><td><code id="gammamix_+3A_x">x</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> giving the points where
the density function is evaluated.</p>
</td></tr>
<tr><td><code id="gammamix_+3A_q">q</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> giving the quantiles where
the distribution function is evaluated.</p>
</td></tr>
<tr><td><code id="gammamix_+3A_p">p</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> giving the probabilities where
the quantile function is evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p><code>dgammamix()</code> gives a <a href="base.html#topic+vector">vector</a> of length <code>length(x)</code>
containing the density at <code>x</code>.
</p>
</li>
<li><p><code>pgammamix()</code> gives a
<a href="base.html#topic+vector">vector</a> of length <code>length(q)</code> containing
the distribution function at the corresponding values of <code>q</code>.
</p>
</li>
<li><p><code>qgammamix()</code> gives a <a href="base.html#topic+vector">vector</a> of length <code>length(p)</code>
containing the quantiles at the corresponding values of <code>p</code>.
</p>
</li>
<li><p><code>rgammamix()</code> generates a <a href="base.html#topic+vector">vector</a> of length <code>n</code>
containing the random samples.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
rgammamix(10, shape = c(1, 3, 7), scale = c(2, 2, 4), prop = c(0.6, 0.3, 0.1))

dgammamix(c(0, 2, 1), shape = c(1, 3), rate = c(2, 2), prop = c(0.6, 0.4))

prob &lt;- pgammamix(c(0.1, 7), shape = c(1, 3, 7), scale = c(2, 2, 4), prop = c(0.6, 0.3, 0.1))
prob
qgammamix(prob, shape = c(1, 3, 7), scale = c(2, 2, 4), prop = c(0.6, 0.3, 0.1))

</code></pre>

<hr>
<h2 id='half2full_circ'>Convert Angle from Half Circle to Full Circle</h2><span id='topic+half2full_circ'></span>

<h3>Description</h3>

<p>Converts an angle from the half circle (i.e. in the interval <code class="reqn">[-\pi, \pi)</code>)
to an angle on the full circle  (i.e. in the interval <code class="reqn">[0, 2\pi)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>half2full_circ(angle)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="half2full_circ_+3A_angle">angle</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> value of an angle or a
<code><a href="circular.html#topic+circular">circular</a></code>-object in <code class="reqn">[-\pi, \pi)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <a href="base.html#topic+numeric">numeric</a> value of the angle in <code class="reqn">[0, 2\pi)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>half2full_circ(-1 * pi) / pi
half2full_circ(-0.5 * pi) / pi
half2full_circ(-0 * pi) / pi
half2full_circ(0.5 * pi) / pi

</code></pre>

<hr>
<h2 id='joint'>Density, Distribution, Quantiles and Random Number Generation for joint
distributions</h2><span id='topic+joint'></span><span id='topic+rjoint'></span><span id='topic+pjoint'></span><span id='topic+djoint'></span>

<h3>Description</h3>

<p>The bivariate joint distributions are described in terms of two marginal
distributions and a copula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rjoint(n, copula, marginal_1, marginal_2)

djoint(x, copula, marginal_1, marginal_2)

pjoint(q, copula, marginal_1, marginal_2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="joint_+3A_n">n</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> value, the number of random samples to be
generated with <code>rjoint()</code>.</p>
</td></tr>
<tr><td><code id="joint_+3A_copula">copula</code></td>
<td>
<p><span class="rlang"><b>R</b></span> object of class '<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>'.
or '<code><a href="copula.html#topic+Copula-class">Copula</a></code>' (package '<span class="pkg">copula</span>', only 2-dimensional).</p>
</td></tr>
<tr><td><code id="joint_+3A_marginal_1">marginal_1</code></td>
<td>
<p>named <a href="base.html#topic+list">list</a> (for parametric estimates) or
a '<code><a href="stats.html#topic+density">density</a></code>' object (for linear kernel density estimates)
or a '<code><a href="circular.html#topic+density.circular">density.circular</a></code>' object (for circular kernel density estimates).
The output of functions <code><a href="#topic+fit_angle">fit_angle</a>()</code> and <code><a href="#topic+fit_steplength">fit_steplength</a>()</code>
can be used here directly.</p>
</td></tr>
<tr><td><code id="joint_+3A_marginal_2">marginal_2</code></td>
<td>
<p>This input is similar to <code>marginal_1</code>.</p>
</td></tr>
<tr><td><code id="joint_+3A_x">x</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> (or <a href="base.html#topic+vector">vector</a>) of <a href="base.html#topic+numeric">numeric</a>
values giving the points (in 2 dimensions) where the density function is evaluated.</p>
</td></tr>
<tr><td><code id="joint_+3A_q">q</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> (or <a href="base.html#topic+vector">vector</a>) of <a href="base.html#topic+numeric">numeric</a>
values giving the points (in 2 dimensions) where
the distribution function is evaluated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If entered &quot;by hand&quot;, the named lists describing the parametric distributions
(<code>marginal_1</code> and <code>marginal_2</code>) must contain 2 entries:
</p>

<ol>
<li><p><code>name</code>:
a <a href="base.html#topic+character">character</a> string denoting the name of the distribution.
For a circular distribution, it can be <code>"vonmises"</code>, <code>"vonmisesmix"</code>, or
<code>"wrappedcauchy"</code>. For a linear distribution, it must be a
string denoting the name of a linear distribution in the environment, i.e. the name of its
distribution function without the &quot;p&quot;,
e.g. &quot;norm&quot; for normal distribution
</p>
</li>
<li><p><code>coef</code>: For a circular distribution <code>coef</code> is a (named) <a href="base.html#topic+list">list</a> of
parameters of the circular
marginal distribution as taken by the functions
<code><a href="circular.html#topic+qvonmises">qvonmises</a>()</code>, <code><a href="#topic+qvonmisesmix">qvonmisesmix</a>()</code>,
or <code><a href="#topic+qwrappedcauchy">qwrappedcauchy</a>()</code>. For a linear distribution, <code>coef</code> is
a named list containing the parameters of the distribution given in <code>"name"</code>.
</p>
</li></ol>



<h3>Value</h3>


<ul>
<li><p><code>djoint()</code> gives a <a href="base.html#topic+vector">vector</a> of length <code>length(x)</code>
containing the density at <code>x</code>.
</p>
</li>
<li><p><code>pjoint()</code> gives a
<a href="base.html#topic+vector">vector</a> of length <code>length(q)</code> containing
the distribution function at the corresponding values of <code>q</code>.
</p>
</li>
<li><p><code>rjoint()</code> generates a <a href="base.html#topic+vector">vector</a> of length <code>n</code>
containing the random samples.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>cop &lt;- copula::normalCopula(0.6)
marginal_1 &lt;- list(name="exp",coef=list(rate=2))
marginal_2 &lt;- list(name="lnorm", coef=list(0,0.1))

sample &lt;- rjoint(10,cop,marginal_1,marginal_2)
pjoint(sample,cop,marginal_1,marginal_2)
djoint(sample,cop,marginal_1,marginal_2)

cop &lt;- cyl_quadsec()
marginal_1 &lt;- list(name="wrappedcauchy", coef=list(location=0,scale=0.3))
marginal_2 &lt;- list(name="weibull",coef=list(shape=3))

sample &lt;- rjoint(10,cop,marginal_1,marginal_2)
marginal_1 &lt;- fit_angle(theta=sample[,1], parametric=FALSE)
marginal_2 &lt;- fit_steplength(x=sample[,2],parametric="lnorm")
pjoint(c(0.3*pi,4),cop,marginal_1,marginal_2)
djoint(c(0,2),cop,marginal_1,marginal_2)

</code></pre>

<hr>
<h2 id='lnormmix'>Density, Distribution, Quantiles and Random Number Generation for the mixed log-normal
distribution</h2><span id='topic+lnormmix'></span><span id='topic+rlnormmix'></span><span id='topic+plnormmix'></span><span id='topic+dlnormmix'></span><span id='topic+qlnormmix'></span>

<h3>Description</h3>

<p>The number of components in the mixed log-normal distribution is specified by the length
of the parameter vectors. The quantiles are numerically obtained from the distribution function using
monotone cubic splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlnormmix(n, meanlog, sdlog, prop)

dlnormmix(x, meanlog, sdlog, prop)

plnormmix(q, meanlog, sdlog, prop)

qlnormmix(p, meanlog, sdlog, prop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lnormmix_+3A_n">n</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> value, the number of random samples to be
generated with <code>rlnormmix()</code>.</p>
</td></tr>
<tr><td><code id="lnormmix_+3A_meanlog">meanlog</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the means
of the components on the log scale.</p>
</td></tr>
<tr><td><code id="lnormmix_+3A_sdlog">sdlog</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the standard
deviations of the components on the log scale.</p>
</td></tr>
<tr><td><code id="lnormmix_+3A_prop">prop</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a>, holding the mixing proportions
of the components.</p>
</td></tr>
<tr><td><code id="lnormmix_+3A_x">x</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> giving the points where
the density function is evaluated.</p>
</td></tr>
<tr><td><code id="lnormmix_+3A_q">q</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> giving the quantiles where
the distribution function is evaluated.</p>
</td></tr>
<tr><td><code id="lnormmix_+3A_p">p</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> giving the probabilities where
the quantile function is evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p><code>dlnormmix()</code> gives a <a href="base.html#topic+vector">vector</a> of length <code>length(x)</code>
containing the density at <code>x</code>.
</p>
</li>
<li><p><code>plnormmix()</code> gives a
<a href="base.html#topic+vector">vector</a> of length <code>length(q)</code> containing
the distribution function at the corresponding values of <code>q</code>.
</p>
</li>
<li><p><code>qlnormmix()</code> gives a <a href="base.html#topic+vector">vector</a> of length <code>length(p)</code>
containing the quantiles at the corresponding values of <code>p</code>.
</p>
</li>
<li><p><code>rlnormmix()</code> generates a <a href="base.html#topic+vector">vector</a> of length <code>n</code>
containing the random samples.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
rlnormmix(10, meanlog = c(1, 3, 7), sdlog = c(2, 2, 4), prop = c(0.6, 0.3, 0.1))

dlnormmix(c(0, 2, 1), meanlog = c(1, 3), sdlog = c(2, 2), prop = c(0.6, 0.4))

prob &lt;- plnormmix(c(0.1, 7), meanlog = c(1, 3, 7), sdlog = c(2, 2, 4), prop = c(0.6, 0.3, 0.1))
prob
qlnormmix(prob, meanlog = c(1, 3, 7), sdlog = c(2, 2, 4), prop = c(0.6, 0.3, 0.1))

</code></pre>

<hr>
<h2 id='mi_cyl'>Estimate the Mutual Information Between a Circular and a Linear Random
Variable</h2><span id='topic+mi_cyl'></span>

<h3>Description</h3>

<p>The empirical copula is obtained from the data (<code>theta</code> and <code>x</code>),
and the mutual information of the 2 components is calculated. This gives a
non-negative number that can be normalized to lie between 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mi_cyl(theta, x, normalize = TRUE, symmetrize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mi_cyl_+3A_theta">theta</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of angles (measurements of a circular
variable).</p>
</td></tr>
<tr><td><code id="mi_cyl_+3A_x">x</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of step lengths (measurements of a linear
variable).</p>
</td></tr>
<tr><td><code id="mi_cyl_+3A_normalize">normalize</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> value whether the mutual information should be
normalized to lie within <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="mi_cyl_+3A_symmetrize">symmetrize</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> value whether it should be assumed that right and left
turns are equivalent. If <code>theta</code> can take values in <code class="reqn">[-\pi, \pi)</code>,
this means that positive and negative angles are equivalent.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, the two components of the empirical copula, <code class="reqn">u</code> and <code class="reqn">v</code>
are obtained. Then the mutual information is calculated via discretizing <code class="reqn">u</code> and <code class="reqn">v</code>
into <code>length(theta)^(1/3)</code> bins. The mutual information can be
normalized to lie between 0 and 1 by dividing by the product of the entropies
of <code>u</code> and <code>v</code>. This is done using functions from the '<span class="pkg">infotheo</span>'
package.
</p>
<p>Even if <code>u</code> and <code>v</code> are perfectly correlated
(i.e. <code><a href="#topic+cor_cyl">cor_cyl</a></code> goes to 1 with large sample sizes),
the normalized mutual information will not be 1 if the underlying copula is periodic and
symmetric. E.g. while <code>normalCopula(1)</code> has a correlation of 1 and a density
that looks like a line going from <code class="reqn">(0,0)</code> to <code class="reqn">(1,1)</code>,
<code>cyl_rect_combine(normalCopula(1))</code>
has a density that looks like &quot;&lt;&quot;. The mutual information will be 1 in the first case,
but not in the second. Therefore, we can set <code>symmetrize = TRUE</code> to first
convert (if necessary) theta to lie in <code class="reqn">[-\pi, \pi)</code> and then multiply all angles
larger than 0 with -1. The empirical copula is then calculated and the mutual information
is obtained from those values. It is exactly 1 in the case of
perfect correlation as captured by e.g.
<code>cyl_rect_combine(normalCopula(1))</code>.
</p>
<p>Note also that the mutual information is independent of the marginal distributions.
However, <code>symmetrize=TRUE</code> only works with angles, not with pseudo-observations.
When <code>x</code> and <code>theta</code> are pseudo-observations, information is lost
due to the ranking, and symmetrization will fail.
</p>


<h3>Value</h3>

<p>A <a href="base.html#topic+numeric">numeric</a> value, the mutual information between <code>theta</code> and <code>x</code>
in nats.
</p>


<h3>References</h3>

<p>Ma J, Sun Z (2011).
&ldquo;Mutual Information Is Copula Entropy.&rdquo;
<em>Tsinghua Science and Technology</em>, <b>16</b>(1), 51-54.
ISSN 1007-0214, <a href="https://doi.org/10.1016/S1007-0214%2811%2970008-6">doi:10.1016/S1007-0214(11)70008-6</a>, <a href="https://www.sciencedirect.com/science/article/pii/S1007021411700086/">https://www.sciencedirect.com/science/article/pii/S1007021411700086/</a>.
</p>
<p>Calsaverini RS, Vicente R, Systems C, Artes ED (2009).
&ldquo;An information-theoretic approach to statistical dependence: Copula information.&rdquo;
<em>Europhysics Letters</em>, <b>88</b>(6), 1&ndash;6.
<a href="https://doi.org/10.1209/0295-5075/88/68003">doi:10.1209/0295-5075/88/68003</a>, <a href="https://iopscience.iop.org/article/10.1209/0295-5075/88/68003/">https://iopscience.iop.org/article/10.1209/0295-5075/88/68003/</a>.
</p>
<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cor_cyl">cor_cyl</a>()</code>, <code><a href="#topic+fit_cylcop_cor">fit_cylcop_cor</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

cop &lt;- cyl_quadsec(0.1)
marg1 &lt;- list(name="vonmises",coef=list(0,4))
marg2 &lt;- list(name="lnorm",coef=list(2,3))

#draw samples and calculate the mutual information.
sample &lt;- rjoint(100,cop,marg1,marg2)
mi_cyl(theta = sample[,1],
  x = sample[,2],
  normalize = TRUE,
  symmetrize = FALSE
)

#the correlation coefficient is independent of the marginal distribution.
 sample &lt;- traj_sim(100,
  cop,
  marginal_circ = list(name = "vonmises", coef  = list(0, 1)),
  marginal_lin = list(name = "weibull", coef = list(shape = 2))
)

mi_cyl(theta = sample$angle,
  x = sample$steplength,
  normalize = TRUE,
  symmetrize = FALSE)
mi_cyl(theta = sample$cop_u,
  x = sample$cop_v,
  normalize = TRUE,
  symmetrize = FALSE)

# Estimate correlation of samples drawn from circular-linear copulas
# with perfect correlation.
cop &lt;- cyl_rect_combine(copula::normalCopula(1))
sample &lt;- rjoint(100,cop,marg1,marg2)
# without normalization
mi_cyl(theta = sample[,1],
  x = sample[,2],
  normalize = FALSE,
  symmetrize = FALSE
)
#with normalization
mi_cyl(theta = sample[,1],
  x = sample[,2],
  normalize = TRUE,
  symmetrize = FALSE
)
#only with normalization and symmetrization do we get a value of 1
mi_cyl(theta = sample[,1],
  x = sample[,2],
  normalize = TRUE,
  symmetrize = TRUE
)

</code></pre>

<hr>
<h2 id='mle.vonmisesmix'>Mixed von Mises Maximum Likelihood Estimates</h2><span id='topic+mle.vonmisesmix'></span>

<h3>Description</h3>

<p>Computes the maximum likelihood estimates for the parameters of a mixed
von Mises distribution: the mean directions, the concentration parameters,
and the proportions of the distributions. The code is a simplified version of
<code>movMF::<a href="movMF.html#topic+movMF">movMF</a>()</code> with the added
feature of optionally fixed mean directions (Hornik and Grün 2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mle.vonmisesmix(theta, mu = NULL, ncomp = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mle.vonmisesmix_+3A_theta">theta</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of angles.</p>
</td></tr>
<tr><td><code id="mle.vonmisesmix_+3A_mu">mu</code></td>
<td>
<p>(optional) <a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of length <code>ncomp</code>
holding the mean directions (angles). If not specified
the mean directions are estimated.</p>
</td></tr>
<tr><td><code id="mle.vonmisesmix_+3A_ncomp">ncomp</code></td>
<td>
<p>positive <a href="base.html#topic+integer">integer</a> specifying the number of components
of the mixture model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function complements the '<span class="pkg">circular</span>' package, which
provides functions to make maximum likelihood estimates of e.g. von Mises
(<code>circular::<a href="circular.html#topic+mle.vonmises">mle.vonmises</a>()</code>), or wrapped Cauchy distributions
(<code>circular::<a href="circular.html#topic+mle.wrappedcauchy">mle.wrappedcauchy</a>()</code>)
</p>


<h3>Value</h3>

<p>A list containing the optimized parameters <code>mu</code>, <code>kappa</code>,
and <code>prop</code>.
</p>


<h3>References</h3>

<p>Hornik K, Grün B (2014).
&ldquo;movMF : An R Package for Fitting Mixtures of von Mises-Fisher Distributions.&rdquo;
<em>Journal of Statistical Software</em>, <b>58</b>.
<a href="https://doi.org/10.18637/jss.v058.i10">doi:10.18637/jss.v058.i10</a>..
</p>


<h3>See Also</h3>

<p><code>movMF::<a href="movMF.html#topic+movMF">movMF</a>()</code>,
<code>circular::<a href="circular.html#topic+mle.vonmises">mle.vonmises</a>()</code>,
<code><a href="#topic+dvonmisesmix">dvonmisesmix</a>()</code>,
<code><a href="#topic+qvonmisesmix">qvonmisesmix</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

n &lt;- 10
angles &lt;- rvonmisesmix(n,
  mu = c(0, pi),
  kappa = c(2, 1),
  prop = c(0.4,0.6)
)
mle.vonmisesmix(theta = angles)
mle.vonmisesmix(theta = angles, mu = c(0, pi))

</code></pre>

<hr>
<h2 id='normmix'>Density, Distribution, Quantiles and Random Number Generation for the mixed normal
distribution</h2><span id='topic+normmix'></span><span id='topic+rnormmix'></span><span id='topic+pnormmix'></span><span id='topic+dnormmix'></span><span id='topic+qnormmix'></span>

<h3>Description</h3>

<p>The number of components in the mixed normal distribution is specified by the length
of the parameter vectors. The quantiles are numerically obtained from the distribution function using
monotone cubic splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnormmix(n, mu, sigma, prop)

dnormmix(x, mu, sigma, prop)

pnormmix(q, mu, sigma, prop)

qnormmix(p, mu, sigma, prop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normmix_+3A_n">n</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> value, the number of random samples to be
generated with <code>rnormmix()</code>.</p>
</td></tr>
<tr><td><code id="normmix_+3A_mu">mu</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the means of the components.</p>
</td></tr>
<tr><td><code id="normmix_+3A_sigma">sigma</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the standard
deviations of the components.</p>
</td></tr>
<tr><td><code id="normmix_+3A_prop">prop</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a>, holding the mixing proportions
of the components.</p>
</td></tr>
<tr><td><code id="normmix_+3A_x">x</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> giving the points where
the density function is evaluated.</p>
</td></tr>
<tr><td><code id="normmix_+3A_q">q</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> giving the quantiles where
the distribution function is evaluated.</p>
</td></tr>
<tr><td><code id="normmix_+3A_p">p</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> giving the probabilities where
the quantile function is evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p><code>dnormmix()</code> gives a <a href="base.html#topic+vector">vector</a> of length <code>length(x)</code>
containing the density at <code>x</code>.
</p>
</li>
<li><p><code>pnormmix()</code> gives a
<a href="base.html#topic+vector">vector</a> of length <code>length(q)</code> containing
the distribution function at the corresponding values of <code>q</code>.
</p>
</li>
<li><p><code>qnormmix()</code> gives a <a href="base.html#topic+vector">vector</a> of length <code>length(p)</code>
containing the quantiles at the corresponding values of <code>p</code>.
</p>
</li>
<li><p><code>rnormmix()</code> generates a <a href="base.html#topic+vector">vector</a> of length <code>n</code>
containing the random samples.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
rnormmix(10, mu = c(0, 3, 7), sigma = c(2, 2, 4), prop = c(0.6, 0.3, 0.1))

dnormmix(c(0, 2, 1), mu = c(0, 3), sigma = c(2, 2), prop = c(0.6, 0.4))

prob &lt;- pnormmix(c(0.1, 7), mu = c(0, 3, 7), sigma = c(2, 2, 4), prop = c(0.6, 0.3, 0.1))
prob
qnormmix(prob, mu = c(0, 3, 7), sigma = c(2, 2, 4), prop = c(0.6, 0.3, 0.1))

</code></pre>

<hr>
<h2 id='numerical_conditional_cop'>Numerically Calculate the Conditional Copula</h2><span id='topic+numerical_conditional_cop'></span>

<h3>Description</h3>

<p>Numerically Calculate the Conditional Copula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numerical_conditional_cop(u, copula, cond_on)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numerical_conditional_cop_+3A_u">u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> or <a href="base.html#topic+vector">vector</a> of <a href="base.html#topic+numeric">numeric</a>
values in <code class="reqn">I^2</code>, containing as first column
the circular (periodic) and as second the linear dimension.</p>
</td></tr>
<tr><td><code id="numerical_conditional_cop_+3A_copula">copula</code></td>
<td>
<p><span class="rlang"><b>R</b></span> object of class '<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>'
or '<code><a href="copula.html#topic+Copula-class">Copula</a></code>' (package '<span class="pkg">copula</span>', only 2-dimensional).</p>
</td></tr>
<tr><td><code id="numerical_conditional_cop_+3A_cond_on">cond_on</code></td>
<td>
<p>column number of <code>u</code> on which the copula is conditioned. E.g. if
<code>cond_on = 2</code>, the function calculates for each element in the first column of u
the copula conditional on the element in the second column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the values of the distribution of the copula at
<code>u[,-cond_on]</code> conditional on the values of <code>u[,cond_on]</code>.
</p>


<h3>References</h3>

<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>
<p>Hodel FH, Fieberg JR (2022).
&ldquo;Circular-Linear Copulae for Animal Movement Data.&rdquo;
<em>Methods in Ecology and Evolution</em>.
<a href="https://doi.org/10.1111/2041-210X.13821">doi:10.1111/2041-210X.13821</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ccylcop">ccylcop</a>()</code>, <code><a href="#topic+numerical_inv_conditional_cop">numerical_inv_conditional_cop</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cop &lt;- cyl_quadsec(0.1)
u &lt;- cbind(c(0.3, 0.1), c(0.7, 0.3))
numerical_conditional_cop(u = u, cop = cop, cond_on = 1)

</code></pre>

<hr>
<h2 id='numerical_inv_conditional_cop'>Numerically calculate the inverse of the conditional copula</h2><span id='topic+numerical_inv_conditional_cop'></span>

<h3>Description</h3>

<p>Numerically calculate the inverse of the conditional copula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numerical_inv_conditional_cop(u, copula, cond_on)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numerical_inv_conditional_cop_+3A_u">u</code></td>
<td>
<p><a href="base.html#topic+matrix">matrix</a> or <a href="base.html#topic+vector">vector</a> of <a href="base.html#topic+numeric">numeric</a>
values in <code class="reqn">I^2</code>, containing as first column
the circular (periodic) and as second the linear dimension.</p>
</td></tr>
<tr><td><code id="numerical_inv_conditional_cop_+3A_copula">copula</code></td>
<td>
<p><span class="rlang"><b>R</b></span> object of class '<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>'
or '<code><a href="copula.html#topic+Copula-class">Copula</a></code>' (package '<span class="pkg">copula</span>', only 2-dimensional).</p>
</td></tr>
<tr><td><code id="numerical_inv_conditional_cop_+3A_cond_on">cond_on</code></td>
<td>
<p>column number of <code>u</code> on which the copula is conditioned. E.g if
<code>cond_on = 2</code>, the function calculates for each element in the first column
of u the inverse of the Copula conditional on the element in the second column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the values of the inverse distribution of the copula at
<code>[u,-cond_on]</code> conditional on the values of <code>[u,cond_on]</code>.
</p>


<h3>References</h3>

<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>
<p>Hodel FH, Fieberg JR (2022).
&ldquo;Circular-Linear Copulae for Animal Movement Data.&rdquo;
<em>Methods in Ecology and Evolution</em>.
<a href="https://doi.org/10.1111/2041-210X.13821">doi:10.1111/2041-210X.13821</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ccylcop">ccylcop</a>()</code>, <code><a href="#topic+numerical_conditional_cop">numerical_conditional_cop</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cop &lt;- cyl_quadsec(0.1)
u &lt;- cbind(c(0.3, 0.1), c(0.7, 0.3))
numerical_inv_conditional_cop(u = u, cop = cop, cond_on = 1)

</code></pre>

<hr>
<h2 id='opt_auto'>Automatically Find the Best Fitting Copula</h2><span id='topic+opt_auto'></span>

<h3>Description</h3>

<p>The parameters of 15 different circular-linear copulas are fitted to data
and sorted
according to AIC. For each copula, first, a starting value for the maximum
likelihood estimation (MLE) is found using <code><a href="#topic+fit_cylcop_cor">fit_cylcop_cor</a>()</code>.
Then, MLE is carried out with a &quot;reasonable&quot; setup using <code><a href="#topic+fit_cylcop_ml">fit_cylcop_ml</a>()</code>.
If MLE fails, parameters obtained with <code><a href="#topic+fit_cylcop_cor">fit_cylcop_cor</a>()</code> are reported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt_auto(theta, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt_auto_+3A_theta">theta</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of angles
(measurements of a circular variable).</p>
</td></tr>
<tr><td><code id="opt_auto_+3A_x">x</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of step lengths
(measurements of a linear variable).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing 3 lists: Descriptions of the copulas, the
'<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>' objects with fitted parameters, and the AIC.
The lists are sorted by ascending AIC.
If <code><a href="#topic+fit_cylcop_ml">fit_cylcop_ml</a>()</code> has failed, the reported parameters are the ones obtained
with <code><a href="#topic+fit_cylcop_cor">fit_cylcop_cor</a>()</code> and the AIC is set to <code>NA</code>.
</p>


<h3>References</h3>

<p>Hodel FH, Fieberg JR (2022).
&ldquo;Circular-Linear Copulae for Animal Movement Data.&rdquo;
<em>Methods in Ecology and Evolution</em>.
<a href="https://doi.org/10.1111/2041-210X.13821">doi:10.1111/2041-210X.13821</a>.
</p>
<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_cylcop_cor">fit_cylcop_cor</a>()</code>, <code><a href="#topic+fit_cylcop_ml">fit_cylcop_ml</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

#Optimal copula is independent of marginals.
data &lt;- rcylcop(100,cyl_quadsec(0.1))

#This takes a few seconds to run.
copula_lst &lt;- opt_auto(theta = data[,1], x = data[,2])

</code></pre>

<hr>
<h2 id='opt_circ_bw'>Find the Optimal Bandwidth for a Circular Kernel Density Estimate</h2><span id='topic+opt_circ_bw'></span>

<h3>Description</h3>

<p>This function basically wraps <code>circular::<a href="circular.html#topic+bw.cv.ml.circular">bw.cv.ml.circular</a>()</code>
and <code>circular::<a href="circular.html#topic+bw.nrd.circular">bw.nrd.circular</a>()</code> of the '<span class="pkg">circular</span>'
package, simplifying their inputs. For more control,
these '<span class="pkg">circular</span>' functions could be used directly.
The normal reference distribution (<code>"nrd"</code>) method of finding the bandwidth
parameter might give very bad results,
especially for multi-modal population distributions.
In these cases it can help to set <code>kappa.est = "trigmoments"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt_circ_bw(theta, method = c("cv", "nrd"), kappa.est = "trigmoments")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt_circ_bw_+3A_theta">theta</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of angles in <code class="reqn">[-\pi, \pi)</code>.</p>
</td></tr>
<tr><td><code id="opt_circ_bw_+3A_method">method</code></td>
<td>
<p><a href="base.html#topic+character">character</a> string describing the method,
either <code>"cv"</code> (cross-validation), or <code>"nrd"</code>
leading to a rule-of-thumb estimate.</p>
</td></tr>
<tr><td><code id="opt_circ_bw_+3A_kappa.est">kappa.est</code></td>
<td>
<p><a href="base.html#topic+character">character</a> string describing how the spread is estimated.
Either maximum likelihood <code>"ML"</code>, or trigonometric moment <code>"trigmoments"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>method="nrd"</code> is somewhat similar to the linear case (see
<code><a href="#topic+fit_steplength">fit_steplength</a>()</code>). Instead of matching a normal distribution to
the data and then calculating its optimal bandwidth, a von Mises distribution is used.
To match that von Mises distribution to the data we can either find its concentration
parameter kappa using maximum likelihood (<code>kappa.est="ML"</code>) or by trigonometric moment
matching (<code>kappa.est="trigmoments"</code>). When the data is multimodal, fitting a
(unimodal) von Mises distribution using maximum likelihood will probably give bad
results. Using <code>kappa.est="trigmoments"</code> potentially works better in those cases.
</p>
<p>As an alternative, the bandwidth can be found by maximizing the cross-validation likelihood
(<code>method="cv"</code>). However, with this leave-one-out cross-validation scheme, at every
likelihood optimization step, <code class="reqn">n(n-1)</code> von Mises densities need to be calculated, where
<code class="reqn">n=</code><code>length(theta)</code>. Therefore, this method can become quite slow with
large sample sizes.
</p>


<h3>Value</h3>

<p>A <a href="base.html#topic+numeric">numeric</a> value, the optimized bandwidth.
</p>


<h3>See Also</h3>

<p><code>circular::<a href="circular.html#topic+bw.cv.ml.circular">bw.cv.ml.circular</a>()</code>,
<code>circular::<a href="circular.html#topic+bw.nrd.circular">bw.nrd.circular</a>()</code>,
<code><a href="#topic+opt_circ_bw">opt_circ_bw</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(circular)
require(graphics)
set.seed(123)
n &lt;- 10  #n (number of samples) is set small for performance. Increase n to
         # a value larger than 1000 to see the effects of multimodality

angles &lt;- rvonmisesmix(n,
  mu = c(0,pi),
  kappa = c(2,1),
  prop = c(0.5,0.5)
)
bw1 &lt;- opt_circ_bw(theta = angles, method="nrd", kappa.est = "ML")
bw2 &lt;- opt_circ_bw(theta = angles, method="nrd", kappa.est = "trigmoments")
bw3 &lt;- opt_circ_bw(theta = angles, method="cv")

dens1 &lt;- fit_angle(theta = angles, parametric = FALSE, bandwidth = bw1)
dens2 &lt;- fit_angle(theta = angles, parametric = FALSE, bandwidth = bw2)
dens3 &lt;- fit_angle(theta = angles, parametric = FALSE, bandwidth = bw3)
true_dens &lt;- dvonmisesmix(
  seq(-pi,pi,0.001),
  mu = c(0,pi),
  kappa = c(2,1),
  prop = c(0.5,0.5)
)
if(interactive()){
 plot(seq(-pi, pi, 0.001), true_dens, type = "l")
 lines(as.double(dens1$x), as.double(dens1$y), col = "red")
 lines(as.double(dens2$x), as.double(dens2$y), col = "green")
 lines(as.double(dens3$x), as.double(dens3$y), col = "blue")
}

</code></pre>

<hr>
<h2 id='opt_lin_bw'>Find the Optimal Bandwidth for a Linear Kernel Density Estimate</h2><span id='topic+opt_lin_bw'></span>

<h3>Description</h3>

<p>This function wraps <code>stats::<a href="stats.html#topic+bw.ucv">bw.ucv</a>()</code>
and <code>stats::<a href="stats.html#topic+bw.nrd">bw.nrd</a>()</code> of the '<span class="pkg">stats</span>'
package, simplifying their inputs. For more control,
these '<span class="pkg">stats</span>' functions could be used directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt_lin_bw(x, method = c("cv", "nrd"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt_lin_bw_+3A_x">x</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of linear measurements.</p>
</td></tr>
<tr><td><code id="opt_lin_bw_+3A_method">method</code></td>
<td>
<p><a href="base.html#topic+character">character</a> string describing the method used to find
the optimal bandwidth. Either <code>"cv"</code> (cross-validation),
or <code>"nrd"</code> (rule-of-thumb estimate).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The normal reference distribution (<code>nrd</code>) method involves
matching a normal distribution to the data using an empirical measure of spread.
The optimal bandwidth for that normal distribution can then be exactly calculated
by minimizing the mean integrated square error.
<code>method="cv"</code> finds the optimal bandwidth using unbiased cross-validation.
</p>


<h3>Value</h3>

<p>A <a href="base.html#topic+numeric">numeric</a> value, the optimized bandwidth.
</p>


<h3>See Also</h3>

<p><code>stats::<a href="stats.html#topic+bw.ucv">bw.ucv</a>()</code>,
<code>stats::<a href="stats.html#topic+bw.nrd">bw.nrd</a>()</code>
<code><a href="#topic+opt_lin_bw">opt_lin_bw</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(graphics)
set.seed(123)
n &lt;- 1000

x &lt;- rweibull(n, shape = 10)
bw1 &lt;- opt_lin_bw(x = x, method="nrd")
bw2 &lt;- opt_lin_bw(x = x, method="cv")

dens1 &lt;- fit_steplength(x = x, parametric = FALSE, bandwidth = bw1)
dens2 &lt;- fit_steplength(x = x, parametric = FALSE, bandwidth = bw2)
true_dens &lt;- dweibull(seq(0,max(x),length.out = 200), shape = 10)

plot(seq(0,max(x),length.out = 200), true_dens, type = "l")
lines(dens1$x, dens1$y, col = "red")
lines(dens2$x, dens2$y, col = "green")

</code></pre>

<hr>
<h2 id='plot_circ_hist'>Circular Histogram of Turn Angles</h2><span id='topic+plot_circ_hist'></span>

<h3>Description</h3>

<p>This function produces a circular histogram of turn angles, i.e. angles
on the the half-circle between -pi and pi.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_circ_hist(theta, nbars = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_circ_hist_+3A_theta">theta</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of angles
(measurements of a circular variable) or &quot;circular&quot; component of pseudo-observations.
They must be on the half-circle, i.e. theta must be in <code class="reqn">[-\pi, \pi)</code>.</p>
</td></tr>
<tr><td><code id="plot_circ_hist_+3A_nbars">nbars</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+integer">integer</a>, the number of bins (bars)
in the histogram.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A '<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>' object.
</p>


<h3>References</h3>

<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_joint_scat">plot_joint_scat</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

theta &lt;- cylcop::rvonmisesmix(n = 100,
  mu = c(0, pi),
  kappa = c(5, 2),
  prop = c(4, 2)
)
plot1 &lt;- plot_circ_hist(theta)

</code></pre>

<hr>
<h2 id='plot_cop_scat'>Scatterplot of Copula Values</h2><span id='topic+plot_cop_scat'></span>

<h3>Description</h3>

<p>This function produces a scatterplot ('<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>' object) of
a sample from a copula. Either a sample is provided as input, or a sample
is drawn from a copula to quickly visualize it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_cop_scat(traj = NULL, u = NULL, v = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_cop_scat_+3A_traj">traj</code></td>
<td>
<p>a <a href="base.html#topic+data.frame">data.frame</a> containing the trajectory produced by e.g.
<code><a href="#topic+traj_sim">traj_sim</a>()</code>, which must contain the columns
<code>traj$cop_u</code> and <code>traj$cop_v</code>.</p>
</td></tr>
<tr><td><code id="plot_cop_scat_+3A_u">u</code></td>
<td>
<p>(alternatively) <a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of first
components of pseudo-observations or draws from a copula.</p>
</td></tr>
<tr><td><code id="plot_cop_scat_+3A_v">v</code></td>
<td>
<p>(alternatively) <a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of second
components of pseudo-observations or draws from a copula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Alternatively, instead of plotting a sample from a copula <code>cop</code>
using <code>scatterplot(copula=cop)</code>, you can also use <code><a href="base.html#topic+plot">plot</a>(cop)</code>.
If a trajectory is provided and <code>n</code> is smaller than <code>nrow(traj)</code>,
<code>n</code> steps are randomly selected from the trajectory and plotted.
</p>


<h3>Value</h3>

<p>A '<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>' object, the scatterplot.
</p>


<h3>References</h3>

<p>Hodel FH, Fieberg JR (2022).
&ldquo;Circular-Linear Copulae for Animal Movement Data.&rdquo;
<em>Methods in Ecology and Evolution</em>.
<a href="https://doi.org/10.1111/2041-210X.13821">doi:10.1111/2041-210X.13821</a>.
</p>
<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_track">plot_track</a>()</code>,
<code><a href="#topic+plot_joint_circ">plot_joint_circ</a>()</code>, <code><a href="#topic+plot_cop_surf">plot_cop_surf</a>()</code>, <code><a href="#topic+plot_joint_scat">plot_joint_scat</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
traj &lt;- traj_sim(100,
  copula = cyl_quadsec(0.1),
  marginal_circ = list(name = "vonmises", coef  = list(0, 1)),
  marginal_lin = list(name = "weibull", coef = list(shape = 3))
)
plot_cop_scat(traj = traj)

sample &lt;- rcylcop(100,cyl_quadsec(0.1))
plot_cop_scat(u = sample[,1], v = sample[,2])

</code></pre>

<hr>
<h2 id='plot_cop_surf'>Surface Plot or Heat Map of the Distribution or the Density of a Copula</h2><span id='topic+plot_cop_surf'></span>

<h3>Description</h3>

<p>This function plots the distribution or the density of a copula. It can produce
a surface plot using either functions from the '<span class="pkg">rgl</span>' or from the
'<span class="pkg">plotly</span>' package, or it can produce a heat map using functions from
'<span class="pkg">ggplot2</span>'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_cop_surf(
  copula,
  type = "pdf",
  plot_type = "rgl",
  resolution = 50,
  n_gridlines = 11
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_cop_surf_+3A_copula">copula</code></td>
<td>
<p>'<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>' or a '<code><a href="copula.html#topic+Copula-class">Copula</a></code>' object
from the package '<span class="pkg">copula</span>'.</p>
</td></tr>
<tr><td><code id="plot_cop_surf_+3A_type">type</code></td>
<td>
<p><a href="base.html#topic+character">character</a> string describing what is plotted,
either <code>"pdf"</code> or <code>"cdf"</code>.</p>
</td></tr>
<tr><td><code id="plot_cop_surf_+3A_plot_type">plot_type</code></td>
<td>
<p><a href="base.html#topic+character">character</a> string describing what type of plot
is produced. Available plot types are:
<code>"rgl"</code>: surface plot,
<code>"plotly"</code>: interactive surface plot, or
<code>"ggplot"</code>: heatmap</p>
</td></tr>
<tr><td><code id="plot_cop_surf_+3A_resolution">resolution</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> value. The density or distribution
will be calculated at <code>resolution^2</code> points.</p>
</td></tr>
<tr><td><code id="plot_cop_surf_+3A_n_gridlines">n_gridlines</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> value giving the number of grid
lines drawn in u and v direction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on <code>plot_type</code>, a '<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>' object
is returned, or a '<span class="pkg">plotly</span>' visualization or '<span class="pkg">rgl</span>' plot is produced.
</p>


<h3>References</h3>

<p>Hodel FH, Fieberg JR (2022).
&ldquo;Circular-Linear Copulae for Animal Movement Data.&rdquo;
<em>Methods in Ecology and Evolution</em>.
<a href="https://doi.org/10.1111/2041-210X.13821">doi:10.1111/2041-210X.13821</a>.
</p>
<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_cop_scat">plot_cop_scat</a>()</code>, <code><a href="#topic+plot_track">plot_track</a>()</code>,
<code><a href="#topic+plot_joint_circ">plot_joint_circ</a>()</code>, <code><a href="#topic+plot_joint_scat">plot_joint_scat</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
 plot_cop_surf(copula::frankCopula(2),
   type="pdf",
   plot_type="ggplot",
   resolution = 5
 )
 plot_cop_surf(copula::frankCopula(2),
   type="cdf",
   plot_type="ggplot",
   resolution = 5
 )

#opens a new window
  plot_cop_surf(cyl_quadsec(0.1),
    type="pdf",
    plot_type="rgl"
  )
  plot_cop_surf(cyl_quadsec(0.1),
    type="pdf",
    plot_type="rgl",
    n_gridlines = 60
  )

  plot_cop_surf(cyl_quadsec(0.1),
    type="pdf",
    plot_type="plotly",
    n_gridlines = 10,
    resolution = 10
  )
}

</code></pre>

<hr>
<h2 id='plot_joint_box'>Circular Boxplot of Turn Angles and Step Lengths</h2><span id='topic+plot_joint_box'></span>

<h3>Description</h3>

<p>This function produces circular boxplots (a '<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>' object)
of the turn angles corresponding to specific quantiles of the step lengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_joint_box(
  traj = NULL,
  theta = NULL,
  x = NULL,
  levels = 5,
  marginal_lin = NULL,
  spacing = 0.3,
  legend_pos = "right"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_joint_box_+3A_traj">traj</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a> containing the trajectory produced by e.g.
<code><a href="#topic+traj_sim">traj_sim</a>()</code>. It must contain
the columns <code>traj$angle</code> and <code>traj$steplength</code>.</p>
</td></tr>
<tr><td><code id="plot_joint_box_+3A_theta">theta</code></td>
<td>
<p>(alternatively) <a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of angles
(measurements of a circular variable) or &quot;circular&quot; component of pseudo-observations.</p>
</td></tr>
<tr><td><code id="plot_joint_box_+3A_x">x</code></td>
<td>
<p>(alternatively) <a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of step lengths
(measurements of a linear variable) or &quot;linear&quot; component of pseudo-observations.</p>
</td></tr>
<tr><td><code id="plot_joint_box_+3A_levels">levels</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> value between 1 and 15, the number of
quantiles into which the step lengths are split.</p>
</td></tr>
<tr><td><code id="plot_joint_box_+3A_marginal_lin">marginal_lin</code></td>
<td>
<p>named <a href="base.html#topic+list">list</a> (for parametric estimates) or
a '<code><a href="stats.html#topic+density">density</a></code>' object (for kernel density estimates).
The output of function <code><a href="#topic+fit_steplength">fit_steplength</a>()</code> can be used here directly for
both cases. If <code>marginal_lin</code> is specified, the limits of the quantiles of the step lengths
are determined from that distribution instead of from the data specified with
<code>traj$steplength</code> or <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot_joint_box_+3A_spacing">spacing</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> value between 0 and 10 determining the
spacing between the boxplots.</p>
</td></tr>
<tr><td><code id="plot_joint_box_+3A_legend_pos">legend_pos</code></td>
<td>
<p><a href="base.html#topic+character">character</a> string denoting the position of the legend (limits
of the step length quantiles). Either <code>"left"</code>, <code>"right"</code>, <code>"top"</code>, or
<code>"bottom"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The step lengths are split into quantiles. For each quantile a boxplot of the
corresponding turn angles is produced and wrapped around the circle.
The turn angle values are plotted
as scatter plot overlaying the boxplot. Outliers are plotted in red.
The median of the turn angles is defined as the center of the shortest arc
that connects all points. The length of the whiskers is 1.5 times the interquartile range.
</p>
<p>You can either specify <code>traj</code> or the angels (<code>theta</code>)
and step lengths (codex).
If entered &quot;by hand&quot;, the named list describing the marginal linear distribution
(for <code>marginal_lin</code>) must contain 2 entries:
</p>

<ol>
<li><p><code>name</code>:
a <a href="base.html#topic+character">character</a> string denoting the name of the linear distribution,
i.e. the name of its
distribution function without the &quot;p&quot;,
e.g. &quot;norm&quot; for normal distribution.
</p>
</li>
<li><p><code>coef</code>: a named list containing the parameters of the distribution
given in <code>"name"</code>.
</p>
</li></ol>



<h3>Value</h3>

<p>A '<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>' object, the circular boxplot.
</p>


<h3>References</h3>

<p>Hodel FH, Fieberg JR (2022).
&ldquo;Circular-Linear Copulae for Animal Movement Data.&rdquo;
<em>Methods in Ecology and Evolution</em>.
<a href="https://doi.org/10.1111/2041-210X.13821">doi:10.1111/2041-210X.13821</a>.
</p>
<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_cop_scat">plot_cop_scat</a>()</code>, <code><a href="#topic+plot_track">plot_track</a>()</code>,
<code><a href="#topic+plot_joint_circ">plot_joint_circ</a>()</code>, <code><a href="#topic+plot_cop_surf">plot_cop_surf</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)

traj &lt;- traj_sim(100,
  copula = cyl_rect_combine(copula::frankCopula(6)),
  marginal_circ = list(name= "vonmises", coef=list(0, 2)),
  marginal_lin = list(name = "weibull", coef=list(shape=3))
)

plot1 &lt;- plot_joint_box(traj)
plot2 &lt;- plot_joint_box(traj,
  marginal_lin=list(name = "weibull", coef=list(shape=3))
)

</code></pre>

<hr>
<h2 id='plot_joint_circ'>Circular Scatterplot of Turn Angles and Step Lengths</h2><span id='topic+plot_joint_circ'></span>

<h3>Description</h3>

<p>This function produces a circular scatterplot with the step lengths plotted
as distance from the center of a circle and the turn angles as angles
(polar coordinates).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_joint_circ(traj = NULL, theta = NULL, x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_joint_circ_+3A_traj">traj</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a> containing the trajectory produced by e.g.
<code><a href="#topic+traj_sim">traj_sim</a>()</code>. It must contain
the columns <code>traj$angle</code> and <code>traj$steplength</code>.</p>
</td></tr>
<tr><td><code id="plot_joint_circ_+3A_theta">theta</code></td>
<td>
<p>(alternatively) <a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of angles
(measurements of a circular variable) or &quot;circular&quot; component of pseudo-observations.</p>
</td></tr>
<tr><td><code id="plot_joint_circ_+3A_x">x</code></td>
<td>
<p>(alternatively) <a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of step lengths
(measurements of a linear variable) or &quot;linear&quot; component of pseudo-observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can either specify <code>traj</code> or the angels and step lengths
<code>theta</code> and <code>x</code>.
</p>


<h3>Value</h3>

<p>A '<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>' object.
</p>


<h3>References</h3>

<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_cop_scat">plot_cop_scat</a>()</code>, <code><a href="#topic+plot_track">plot_track</a>()</code>,
<code><a href="#topic+plot_cop_surf">plot_cop_surf</a>()</code>, <code><a href="#topic+plot_joint_scat">plot_joint_scat</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

traj &lt;- traj_sim(100,
  copula = cyl_quadsec(0.1),
  marginal_circ = list(name="vonmises",coef=list(0, 1)),
  marginal_lin = list(name="weibull", coef=list(shape=3))
)
plot1 &lt;- plot_joint_circ(traj)

</code></pre>

<hr>
<h2 id='plot_joint_scat'>Scatterplot of Turn Angles and Step Lengths</h2><span id='topic+plot_joint_scat'></span>

<h3>Description</h3>

<p>This function produces a scatterplot ('<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>' object) of
the turn angles and step lengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_joint_scat(
  traj = NULL,
  theta = NULL,
  x = NULL,
  periodic = FALSE,
  plot_margins = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_joint_scat_+3A_traj">traj</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a> containing the trajectory produced by e.g.
<code><a href="#topic+traj_sim">traj_sim</a>()</code>. It must contain
the columns <code>traj$angle</code> and <code>traj$steplength</code>.</p>
</td></tr>
<tr><td><code id="plot_joint_scat_+3A_theta">theta</code></td>
<td>
<p>(alternatively) <a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of angles
(measurements of a circular variable).</p>
</td></tr>
<tr><td><code id="plot_joint_scat_+3A_x">x</code></td>
<td>
<p>(alternatively) <a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of step lengths
(measurements of a linear variable).</p>
</td></tr>
<tr><td><code id="plot_joint_scat_+3A_periodic">periodic</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> value denoting whether the plot should
be periodically extended past -pi and pi.</p>
</td></tr>
<tr><td><code id="plot_joint_scat_+3A_plot_margins">plot_margins</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> determining whether the marginal kernel
density estimates are computed and plotted. Alternatively, <code>plot_margins</code> can
be a list of length 2 containing first a kernel density estimate for <code>theta</code> and
second a kernel density estimate for <code>x</code>. The first entry must be of type
<code>'density.circular'</code> (as returned e.g. by <code><a href="#topic+fit_angle">fit_angle</a>(theta, parametric=FALSE))</code>,
and the second entry must be of type <code>"density"</code>
(as returned e.g. by <code><a href="#topic+fit_steplength">fit_steplength</a>(x, parametric=FALSE))</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can either specify <code>traj</code> or the angels and step lengths
(<code>theta</code> and <code>x</code>).
If <code>plot_margins=T</code>, the code will attempt to find appropriate bandwidths for
the kernel density estimate autonomously, also taking into account computational time.
For more control over the actual method and parameters used to obtain the kernel
density estimates, you can calculate them &quot;by hand&quot; using e.g.
<code><a href="#topic+fit_angle">fit_angle</a>(theta, parametric=FALSE)</code>
and <code><a href="#topic+fit_steplength">fit_steplength</a>(x, parametric=FALSE))</code>.
</p>


<h3>Value</h3>

<p>A '<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>' object, the scatterplot.
</p>


<h3>References</h3>

<p>Hodel FH, Fieberg JR (2022).
&ldquo;Circular-Linear Copulae for Animal Movement Data.&rdquo;
<em>Methods in Ecology and Evolution</em>.
<a href="https://doi.org/10.1111/2041-210X.13821">doi:10.1111/2041-210X.13821</a>.
</p>
<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_cop_scat">plot_cop_scat</a>()</code>, <code><a href="#topic+plot_track">plot_track</a>()</code>,
<code><a href="#topic+plot_joint_circ">plot_joint_circ</a>()</code>, <code><a href="#topic+plot_cop_surf">plot_cop_surf</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
traj &lt;- traj_sim(100,
  copula = cyl_quadsec(0.1),
  marginal_circ = list(name = "vonmises", coef  = list(0, 1)),
  marginal_lin = list(name = "weibull", coef = list(shape = 3))
)

plot1 &lt;- plot_joint_scat(traj)
plot2 &lt;- plot_joint_scat(traj, periodic = TRUE)
plot3 &lt;- plot_joint_scat(theta=traj$angle, x=traj$steplength, periodic = TRUE, plot_margins=TRUE)

bw &lt;- opt_circ_bw(theta = traj$angle, method = "nrd",kappa.est = "trigmoments")
ang_dens &lt;- fit_angle(theta=traj$angle, parametric=FALSE, bandwidth=bw)
step_dens &lt;- fit_steplength(x=traj$steplength, parametric=FALSE)
plot4 &lt;- plot_joint_scat(traj, periodic = TRUE, plot_margins=list(ang_dens, step_dens))

</code></pre>

<hr>
<h2 id='plot_track'>Plot a Trajectory in Euclidean Space</h2><span id='topic+plot_track'></span>

<h3>Description</h3>

<p>This function plots the locations of a trajectory or multiple trajectories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_track(traj = NULL, x_coord = NULL, y_coord = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_track_+3A_traj">traj</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a> containing the trajectory produced by e.g.
<code><a href="#topic+traj_sim">traj_sim</a>()</code>. It must contain
the columns <code>traj$pos_x</code> and <code>traj$pos_y</code>. It is also possible to specify a
<a href="base.html#topic+list">list</a> of such data.frames containing multiple trajectories.</p>
</td></tr>
<tr><td><code id="plot_track_+3A_x_coord">x_coord</code></td>
<td>
<p>(alternatively) <a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of x-coordinates or
a <a href="base.html#topic+list">list</a> of x-coordinate vectors of multiple trajectories.</p>
</td></tr>
<tr><td><code id="plot_track_+3A_y_coord">y_coord</code></td>
<td>
<p>(alternatively) <a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of y-coordinates or
a <a href="base.html#topic+list">list</a> of y-coordinate vectors of multiple trajectories.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A '<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>' object.
</p>


<h3>References</h3>

<p>Hodel FH, Fieberg JR (2022).
&ldquo;Circular-Linear Copulae for Animal Movement Data.&rdquo;
<em>Methods in Ecology and Evolution</em>.
<a href="https://doi.org/10.1111/2041-210X.13821">doi:10.1111/2041-210X.13821</a>.
</p>
<p>Hodel FH, Fieberg JR (2021).
&ldquo;Cylcop: An R Package for Circular-Linear Copulae with Angular Symmetry.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2021.07.14.452253">doi:10.1101/2021.07.14.452253</a>, <a href="https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/">https://www.biorxiv.org/content/10.1101/2021.07.14.452253v3/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_cop_scat">plot_cop_scat</a>()</code>,
<code><a href="#topic+plot_joint_circ">plot_joint_circ</a>()</code>, <code><a href="#topic+plot_cop_surf">plot_cop_surf</a>()</code>, <code><a href="#topic+plot_joint_scat">plot_joint_scat</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
traj &lt;- traj_sim(50,
  copula = cyl_quadsec(0.1),
  marginal_circ = list(name = "vonmises", coef  = list(0, 1)),
  marginal_lin = list(name = "weibull", coef = list(shape = 3))
)
plot1 &lt;- plot_track(traj=traj)

x_coord &lt;- list(runif(10),runif(20),runif(3))
y_coord &lt;- list(runif(10),runif(20),runif(3))

plot2 &lt;- plot_track(x_coord=x_coord, y_coord=y_coord)

</code></pre>

<hr>
<h2 id='plot+2Ccyl_copula+2Cmissing-method'>Plot '<code>cyl_copula</code>' Objects</h2><span id='topic+plot+2Ccyl_copula+2Cmissing-method'></span>

<h3>Description</h3>

<p>Method for <code><a href="base.html#topic+plot">plot</a>()</code> to draw a scatter plot of a
random sample from a circular-linear copula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'cyl_copula,missing'
plot(x, n = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2Ccyl_copula+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p><span class="rlang"><b>R</b></span> object of class '<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>'.</p>
</td></tr>
<tr><td><code id="plot+2B2Ccyl_copula+2B2Cmissing-method_+3A_n">n</code></td>
<td>
<p>sample size of the random sample drawn from <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2Ccyl_copula+2B2Cmissing-method_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="base.html#topic+plot">plot</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible <code>NULL</code>. As side effect, a plot is produced.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

plot(cyl_quadsec(0.1))
plot(cyl_vonmises(0,2), n = 100)
plot(cyl_quadsec(0.1),
   xlab = "something",
   ylab = "something else",
   main = "clever title",
   col = "red",
   fg = "blue",
   asp= 1)

</code></pre>

<hr>
<h2 id='prob+2Ccyl_copula-method'>Calculate the C-Volume of a '<code>cyl_copula</code>' Copula</h2><span id='topic+prob+2Ccyl_copula-method'></span><span id='topic+prob'></span>

<h3>Description</h3>

<p>This is a method corresponding to the generic <code><a href="copula.html#topic+prob">prob</a>()</code> in the
'<span class="pkg">copula</span>' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'cyl_copula'
prob(x, l, u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob+2B2Ccyl_copula-method_+3A_x">x</code></td>
<td>
<p><span class="rlang"><b>R</b></span> object of class '<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>'.</p>
</td></tr>
<tr><td><code id="prob+2B2Ccyl_copula-method_+3A_l">l</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of length 2 holding the coordinates of the
lower left corner in <code class="reqn">[0,1]^2</code>.</p>
</td></tr>
<tr><td><code id="prob+2B2Ccyl_copula-method_+3A_u">u</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of length 2 holding the coordinates of the
upper right corner in <code class="reqn">[0,1]^2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="base.html#topic+numeric">numeric</a> in <code class="reqn">[0,1]</code>, the probability that a draw from the
2-dimensional copula <code>x</code> falls in the rectangle defined by <code>l</code> and
<code>u</code>.
</p>


<h3>See Also</h3>

<p><code>copula::<a href="copula.html#topic+prob">prob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cop &lt;- cyl_quadsec(0.1)
prob(cop, l = c(0.1, 0.3), u = c(0.3, 0.9))

</code></pre>

<hr>
<h2 id='set_cop_param'>Change Attributes of '<code>cyl_copula</code>' Objects</h2><span id='topic+set_cop_param'></span><span id='topic+set_cop_param+2Ccyl_cubsec-method'></span><span id='topic+set_cop_param+2Ccyl_quadsec-method'></span><span id='topic+set_cop_param+2Ccyl_rect_combine-method'></span><span id='topic+set_cop_param+2Ccyl_rot_combine-method'></span><span id='topic+set_cop_param+2Ccyl_vonmises-method'></span>

<h3>Description</h3>

<p>These methods can be used, e.g. in other functions, to give users limited access
to the parameters of a copula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_cop_param(copula, param_val, param_name, ...)

## S4 method for signature 'cyl_cubsec'
set_cop_param(copula, param_val, param_name)

## S4 method for signature 'cyl_quadsec'
set_cop_param(copula, param_val, param_name)

## S4 method for signature 'cyl_rect_combine'
set_cop_param(copula, param_val, param_name)

## S4 method for signature 'cyl_rot_combine'
set_cop_param(copula, param_val, param_name)

## S4 method for signature 'cyl_vonmises'
set_cop_param(copula, param_val, param_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_cop_param_+3A_copula">copula</code></td>
<td>
<p><span class="rlang"><b>R</b></span> object of class '<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>'.</p>
</td></tr>
<tr><td><code id="set_cop_param_+3A_param_val">param_val</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the values to which the
parameters given in <code>copula@parameters</code> should be changed.</p>
</td></tr>
<tr><td><code id="set_cop_param_+3A_param_name">param_name</code></td>
<td>
<p><a href="base.html#topic+vector">vector</a> of <a href="base.html#topic+character">character</a> strings holding the
names of the parameters to be changed.</p>
</td></tr>
<tr><td><code id="set_cop_param_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that for a rectangular patchwork copula
('<code><a href="#topic+cyl_rect_combine-class">cyl_rect_combine</a></code>')
the attribute <code>rectangles_symmetric</code> cannot be changed by <code>set_cop_param()</code>,
since rectangular patchwork copulas with symmetric rectangles are treated as
distinct from rectangular patchwork copulas with potentially asymmetric rectangles.
Therefore, when changing one of the bounds of the lower rectangle of such a copula,
the corresponding bound of the upper rectangle is automatically changed as well
(see examples).
</p>


<h3>Value</h3>

<p>A '<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>' object with the changed parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cop &lt;- cyl_rect_combine(copula::normalCopula(0.2),low_rect = c(0.1,0.4), up_rect="symmetric")
cop
cop &lt;- set_cop_param(cop, param_val = c(0.1, 0.3), param_name = c("rho.1", "low_rect2"))
cop &lt;- cyl_rect_combine(copula::normalCopula(0.2),low_rect = c(0.1,0.4), up_rect=c(0.6,0.9))
cop
cop &lt;- set_cop_param(cop, param_val = 0.3, param_name = "low_rect2")
cop
</code></pre>

<hr>
<h2 id='show+2Ccyl_copula-method'>Print Information of '<code>cyl_copula</code>' Objects</h2><span id='topic+show+2Ccyl_copula-method'></span><span id='topic+show+2Ccyl_rect_combine-method'></span><span id='topic+show+2Ccyl_rot_combine-method'></span>

<h3>Description</h3>

<p>Methods for function <code><a href="methods.html#topic+show">show</a>()</code> in package <span class="pkg">cylcop</span>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'cyl_copula'
show(object)

## S4 method for signature 'cyl_rect_combine'
show(object)

## S4 method for signature 'cyl_rot_combine'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2Ccyl_copula-method_+3A_object">object</code></td>
<td>
<p><span class="rlang"><b>R</b></span> object of class '<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible <code>NULL</code>. As side effect, information on <code>object</code> is
printed.
</p>

<hr>
<h2 id='traj_get'>Get a Trajectory from Coordinates</h2><span id='topic+traj_get'></span>

<h3>Description</h3>

<p>The function calculates step lengths and turn angles from x- and y-coordinates
and calculates pseudo-observations from those step lengths and turn angles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traj_get(x_coords, y_coords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traj_get_+3A_x_coords">x_coords</code></td>
<td>
<p><a href="base.html#topic+vector">vector</a> of <a href="base.html#topic+numeric">numeric</a> values
containing the x-coordinates of a trajectory.</p>
</td></tr>
<tr><td><code id="traj_get_+3A_y_coords">y_coords</code></td>
<td>
<p><a href="base.html#topic+vector">vector</a> of <a href="base.html#topic+numeric">numeric</a> values
containing the y-coordinates of a trajectory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="base.html#topic+data.frame">data.frame</a> containing the trajectory. It has 6 columns
containing the x and y coordinates, the turn angles, the step lengths, and
the pseudo-observations.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+traj_sim">traj_sim</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

traj &lt;- traj_sim(n = 5,
copula = cyl_quadsec(0.1),
marginal_circ = list(name="vonmises",coef=list(0, 1)),
marginal_lin = list(name="weibull",coef=list(shape=3))
)

traj_from_coords &lt;- traj_get(traj[,1], traj[,2])


</code></pre>

<hr>
<h2 id='traj_sim'>Generate a Trajectory with Correlated Step Lengths and Turn Angles</h2><span id='topic+traj_sim'></span>

<h3>Description</h3>

<p>The function draws values from a circular-linear bivariate distribution of
turn angles and step lengths specified by the marginal distributions and a
circular-linear copula. From the start
point (0,0) and the second (potentially user specified)
point, a trajectory is then built with these turn angles and step lengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traj_sim(
  n,
  copula,
  marginal_circ,
  marginal_lin,
  ignore_first = TRUE,
  pos_2 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traj_sim_+3A_n">n</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a>, number of trajectory steps to generate.</p>
</td></tr>
<tr><td><code id="traj_sim_+3A_copula">copula</code></td>
<td>
<p>'<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>' object.</p>
</td></tr>
<tr><td><code id="traj_sim_+3A_marginal_circ">marginal_circ</code></td>
<td>
<p>named <a href="base.html#topic+list">list</a> (for parametric estimates) or
a '<code><a href="circular.html#topic+density.circular">density.circular</a></code>' object (for kernel density estimates).
The output of function <code><a href="#topic+fit_angle">fit_angle</a>()</code> can be used here directly for
both cases.</p>
</td></tr>
<tr><td><code id="traj_sim_+3A_marginal_lin">marginal_lin</code></td>
<td>
<p>named <a href="base.html#topic+list">list</a> (for parametric estimates) or
a '<code><a href="stats.html#topic+density">density</a></code>' object (for kernel density estimates).
The output of function <code><a href="#topic+fit_steplength">fit_steplength</a>()</code> can be used here directly for
both cases.</p>
</td></tr>
<tr><td><code id="traj_sim_+3A_ignore_first">ignore_first</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> value. If <code>ignore_first = TRUE</code> (default),
a trajectory of length <code>n+2</code> is generated and the first two steps of that
trajectory are removed.</p>
</td></tr>
<tr><td><code id="traj_sim_+3A_pos_2">pos_2</code></td>
<td>
<p>(optional) <a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of length 2
containing the coordinates of the second point in the trajectory.
The first point is always at (0,0). If
no value is specified, the second point is obtained by going in a random direction
from the first point for a distance drawn from the marginal step length distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Samples are drawn from the circular-linear copula and then transformed
using the quantile functions of the marginal circular and the marginal linear
distribution. To generate draws from any bivariate joint distribution (not
necessarily a circular-linear one) without also producing a trajectory,
the function <code><a href="#topic+rjoint">rjoint</a>()</code> can be used.
</p>
<p>If entered &quot;by hand&quot;, the named lists describing the parametric distributions
(<code>marginal_circ</code> and <code>marginal_lin</code>) must contain 2 entries:
</p>

<ol>
<li><p><code>name</code>:
a <a href="base.html#topic+character">character</a> string denoting the name of the distribution.
For the circular distribution, it can be <code>"vonmises"</code>, <code>"vonmisesmix"</code>, or
<code>"wrappedcauchy"</code>. For the linear distribution, it must be a
string denoting the name of a linear distribution in the environment, i.e. the name of its
distribution function without the &quot;p&quot;,
e.g. &quot;norm&quot; for normal distribution
</p>
</li>
<li><p><code>coef</code>: For the circular distribution <code>coef</code> is a (named) <a href="base.html#topic+list">list</a> of
parameters of the circular
marginal distribution as taken by the functions
<code><a href="circular.html#topic+qvonmises">qvonmises</a>()</code>, <code><a href="#topic+qvonmisesmix">qvonmisesmix</a>()</code>,
or <code><a href="#topic+qwrappedcauchy">qwrappedcauchy</a>()</code>. For the linear distribution, <code>coef</code> is
a named list containing the parameters of the distribution given in <code>"name"</code>.
</p>
</li></ol>



<h3>Value</h3>

<p>A <a href="base.html#topic+data.frame">data.frame</a> containing the trajectory. It has 6 columns
containing the x and y coordinates, the turn angles, the step lengths, and
the values sampled from the copula.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+traj_get">traj_get</a>()</code>,
<code><a href="#topic+fit_steplength">fit_steplength</a>()</code>, <code><a href="#topic+fit_angle">fit_angle</a>()</code>,
<code><a href="#topic+plot_track">plot_track</a>()</code>, <code><a href="#topic+plot_cop_scat">plot_cop_scat</a>()</code>,
<code><a href="#topic+plot_joint_scat">plot_joint_scat</a>()</code>, <code><a href="#topic+plot_joint_circ">plot_joint_circ</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(circular)
set.seed(123)

traj &lt;- traj_sim(n = 5,
copula = cyl_quadsec(0.1),
marginal_circ = list(name="vonmises",coef=list(0, 1)),
marginal_lin = list(name="weibull",coef=list(shape=3))
)

traj

angles &lt;- rvonmisesmix(100,
  mu = c(0, pi),
  kappa = c(2, 3),
  prop = c(0.4, 0.6)
)
angles &lt;- full2half_circ(angles)
bw &lt;- opt_circ_bw(theta = angles, method = "nrd", kappa.est = "trigmoments")
marg_ang &lt;- fit_angle(theta = angles, parametric = FALSE, bandwidth = bw)

steplengths &lt;- rlnorm(100, 0, 0.3)
marg_stepl &lt;- fit_steplength(x = steplengths, parametric = "lnorm")

traj_sim(n = 5,
copula = cyl_quadsec(0.1),
marginal_circ = marg_ang,
marginal_lin = marg_stepl,
ignore_first = FALSE,
pos_2 = c(5,5)
)

</code></pre>

<hr>
<h2 id='vonmisesmix'>Density, Distribution, Quantiles and Random Number Generation for the mixed von
Mises Distribution</h2><span id='topic+vonmisesmix'></span><span id='topic+rvonmisesmix'></span><span id='topic+pvonmisesmix'></span><span id='topic+dvonmisesmix'></span><span id='topic+qvonmisesmix'></span>

<h3>Description</h3>

<p>The number of components in the mixed von Mises distribution is specified by the length
of the parameter vectors. The quantiles are numerically obtained from the distribution function using
monotone cubic splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvonmisesmix(n, mu, kappa, prop)

dvonmisesmix(theta, mu, kappa, prop)

pvonmisesmix(theta, mu, kappa, prop)

qvonmisesmix(p, mu, kappa, prop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vonmisesmix_+3A_n">n</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> value, the number of random samples to be
generated with <code>rvonmisesmix()</code>.</p>
</td></tr>
<tr><td><code id="vonmisesmix_+3A_mu">mu</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the mean directions.</p>
</td></tr>
<tr><td><code id="vonmisesmix_+3A_kappa">kappa</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the concentration
parameters.</p>
</td></tr>
<tr><td><code id="vonmisesmix_+3A_prop">prop</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a>, holding the mixing proportions
of the components.</p>
</td></tr>
<tr><td><code id="vonmisesmix_+3A_theta">theta</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> giving the angles where
the density or distribution function is evaluated.</p>
</td></tr>
<tr><td><code id="vonmisesmix_+3A_p">p</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> giving the probabilities where
the quantile function is evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p><code>dvonmisesmix()</code> gives a <a href="base.html#topic+vector">vector</a> of length <code>length(theta)</code>
containing the density at <code>theta</code>.
</p>
</li>
<li><p><code>pvonmisesmix()</code> gives a
<a href="base.html#topic+vector">vector</a> of length <code>length(theta)</code> containing
the distribution function at the corresponding values of <code>theta</code>.
</p>
</li>
<li><p><code>qvonmisesmix()</code> gives a <a href="base.html#topic+vector">vector</a> of length <code>length(p)</code>
containing the quantiles at the corresponding values of <code>p</code>.
</p>
</li>
<li><p><code>rvonmisesmix()</code> generates a <a href="base.html#topic+vector">vector</a> of length <code>n</code>
containing the random samples, i.e. angles in <code class="reqn">[-\pi, \pi)</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
rvonmisesmix(10, mu = c(0, pi, pi/2), kappa = c(2, 2, 4), prop = c(0.6, 0.3, 0.1))

dvonmisesmix(c(0, 2, pi, 1), mu = c(0, pi), kappa = c(2, 2), prop = c(0.6, 0.4))

prob &lt;- pvonmisesmix(c(0.1, pi), mu = c(0, pi, pi/2), kappa = c(2, 2, 4), prop = c(0.6, 0.3, 0.1))
prob
qvonmisesmix(prob, mu = c(0, pi, pi/2), kappa = c(2, 2, 4), prop = c(0.6, 0.3, 0.1))

</code></pre>

<hr>
<h2 id='wasserstein'>Calculate the Wasserstein Distance</h2><span id='topic+wasserstein'></span>

<h3>Description</h3>

<p>The Wasserstein distance is calculated based on the Euclidean distance
between two copula PDFs on a grid, or between a copula PDF and
pseudo-observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wasserstein(
  copula,
  copula2 = NULL,
  theta = NULL,
  x = NULL,
  n_grid = 2500,
  p = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wasserstein_+3A_copula">copula</code></td>
<td>
<p><span class="rlang"><b>R</b></span> object of class '<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>'.
or '<code><a href="copula.html#topic+Copula-class">Copula</a></code>' (package '<span class="pkg">copula</span>', only 2-dimensional).</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_copula2">copula2</code></td>
<td>
<p><span class="rlang"><b>R</b></span> object of class '<code><a href="#topic+cyl_copula-class">cyl_copula</a></code>'.
or '<code><a href="copula.html#topic+Copula-class">Copula</a></code>' (package '<span class="pkg">copula</span>', only 2-dimensional).</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_theta">theta</code></td>
<td>
<p>(alternatively) <a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of angles
(measurements of a circular variable) or &quot;circular&quot; component of pseudo-observations.</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_x">x</code></td>
<td>
<p>(alternatively) <a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of step lengths
(measurements of a linear variable) or &quot;linear&quot; component of pseudo-observations.</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_n_grid">n_grid</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> number of grid cells at which the PDF of the copula(s) is calculated
Default is 2500</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_p">p</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> power (1 or 2) to which the Euclidean distance
between points is taken in order to compute transportation costs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that when comparing 2 copula PDFs (i.e. <code>theta = NULL</code> and <code>x = NULL</code>),
the calculated Wasserstein distance will depend on the number of grid cells
(<code>n_grid</code>) used to approximate the PDFs. The distance will converge to a certain
value with a higher number of grid cells, but the computational time will also increase.
The default of 2500 seems to be a good (empirically determined) compromise.
The same is true when calculating the Wasserstein distance between a copula
PDF and pseudo-observations. There, it is also important to only compare distances
that use the same number of observations.
</p>
<p>The code is based on the functions <code>transport::<a href="transport.html#topic+wasserstein">wasserstein</a>()</code>
and <code>transport::<a href="transport.html#topic+semidiscrete">semidiscrete</a>()</code>.
</p>


<h3>Value</h3>

<p><a href="base.html#topic+numeric">numeric</a>, the pth Wasserstein distance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
copula1 &lt;- cyl_quadsec(0.1)
copula2 &lt;- cyl_rect_combine(copula::frankCopula(2))
wasserstein(copula=copula1,copula2 = copula2,p=2,n_grid=20)
wasserstein(copula=copula1,copula2 = copula1,p=2,n_grid=20)
wasserstein(copula=copula1,copula2 = copula::frankCopula(2),p=2,n_grid=20)

 sample &lt;- rjoint(10,
  copula1,
  marginal_1 = list(name = "vonmises", coef  = list(0, 1)),
  marginal_2 = list(name = "weibull", coef = list(3,4))
)

wasserstein(copula=copula1, theta=sample[,1], x=sample[,2], n_grid=20)
</code></pre>

<hr>
<h2 id='weibullmix'>Density, Distribution, Quantiles and Random Number Generation for the mixed Weibull
distribution</h2><span id='topic+weibullmix'></span><span id='topic+rweibullmix'></span><span id='topic+pweibullmix'></span><span id='topic+dweibullmix'></span><span id='topic+qweibullmix'></span>

<h3>Description</h3>

<p>The number of components in the mixed Weibull distribution is specified by the length
of the parameter vectors. The quantiles are numerically obtained from the distribution function using
monotone cubic splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rweibullmix(n, shape, scale, prop)

dweibullmix(x, shape, scale, prop)

pweibullmix(q, shape, scale, prop)

qweibullmix(p, shape, scale, prop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weibullmix_+3A_n">n</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> value, the number of random samples to be
generated with <code>rweibullmix()</code>.</p>
</td></tr>
<tr><td><code id="weibullmix_+3A_shape">shape</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the shape parameter
of the components.</p>
</td></tr>
<tr><td><code id="weibullmix_+3A_scale">scale</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> holding the scale parameter
of the components.</p>
</td></tr>
<tr><td><code id="weibullmix_+3A_prop">prop</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a>, holding the mixing proportions
of the components.</p>
</td></tr>
<tr><td><code id="weibullmix_+3A_x">x</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> giving the points where
the density function is evaluated.</p>
</td></tr>
<tr><td><code id="weibullmix_+3A_q">q</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> giving the quantiles where
the distribution function is evaluated.</p>
</td></tr>
<tr><td><code id="weibullmix_+3A_p">p</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> giving the probabilities where
the quantile function is evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p><code>dweibullmix()</code> gives a <a href="base.html#topic+vector">vector</a> of length <code>length(x)</code>
containing the density at <code>x</code>.
</p>
</li>
<li><p><code>pweibullmix()</code> gives a
<a href="base.html#topic+vector">vector</a> of length <code>length(q)</code> containing
the distribution function at the corresponding values of <code>q</code>.
</p>
</li>
<li><p><code>qweibullmix()</code> gives a <a href="base.html#topic+vector">vector</a> of length <code>length(p)</code>
containing the quantiles at the corresponding values of <code>p</code>.
</p>
</li>
<li><p><code>rweibullmix()</code> generates a <a href="base.html#topic+vector">vector</a> of length <code>n</code>
containing the random samples.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
rweibullmix(10, shape = c(1, 3, 7), scale = c(2, 2, 4), prop = c(0.6, 0.3, 0.1))

dweibullmix(c(0, 2, 1), shape = c(1, 3), scale = c(2, 2), prop = c(0.6, 0.4))

prob &lt;- pweibullmix(c(0.1, 7), shape = c(1, 3, 7), scale = c(2, 2, 4), prop = c(0.6, 0.3, 0.1))
prob
qweibullmix(prob, shape = c(1, 3, 7), scale = c(2, 2, 4), prop = c(0.6, 0.3, 0.1))

</code></pre>

<hr>
<h2 id='wrappedcauchy'>Density, Distribution, Quantiles and Random Number Generation for the Wrapped
Cauchy Distribution</h2><span id='topic+wrappedcauchy'></span><span id='topic+rwrappedcauchy'></span><span id='topic+pwrappedcauchy'></span><span id='topic+dwrappedcauchy'></span><span id='topic+qwrappedcauchy'></span>

<h3>Description</h3>

<p>The distribution function (<code>pwrappedcauchy()</code>) and quantiles
(<code>qwrappedcauchy()</code>) of the wrapped Cauchy distribution cannot
be obtained analytically. They are therefore missing in the
'<span class="pkg">circular</span>' package and are obtained here numerically.
Random number generation (<code>rwrappedcauchy()</code>) and density
(<code>dwrappedcauchy()</code>) don't need a numerical
approximation and are provided here for consistency in parametrization
with the other wrapped Cauchy functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwrappedcauchy(n, location = 0, scale = 1)

dwrappedcauchy(theta, location = 0, scale = 1)

pwrappedcauchy(theta, location = 0, scale = 1, K = 100, check_prec = FALSE)

qwrappedcauchy(p, location = 0, scale = 1, K = 100, check_prec = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrappedcauchy_+3A_n">n</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> value, the number of random samples to be
generated with <code>rwrappedcauchy()</code>.</p>
</td></tr>
<tr><td><code id="wrappedcauchy_+3A_location">location</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> value, the mean of the distribution.</p>
</td></tr>
<tr><td><code id="wrappedcauchy_+3A_scale">scale</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> value, the parameter tuning the spread of the
density. It must be non-negative.</p>
</td></tr>
<tr><td><code id="wrappedcauchy_+3A_theta">theta</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> giving the angles where
the density or distribution function is evaluated.</p>
</td></tr>
<tr><td><code id="wrappedcauchy_+3A_k">K</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> value, the number of &quot;wraps&quot; used in each direction
to approximate the distribution.</p>
</td></tr>
<tr><td><code id="wrappedcauchy_+3A_check_prec">check_prec</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a>, whether to check if the precision of
the numerical approximation with the current parameters is higher than 99%.</p>
</td></tr>
<tr><td><code id="wrappedcauchy_+3A_p">p</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> giving the probabilities where
the quantile function is evaluated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One could alternatively  convert <code>scale</code> to <code>rho</code> via
<code>rho = exp(-scale)</code> and use
<code>circular::<a href="circular.html#topic+rwrappedcauchy">rwrappedcauchy</a>(theta, mu=location rho=rho)</code> or
<code>circular::<a href="circular.html#topic+dwrappedcauchy">dwrappedcauchy</a>(theta, mu=location rho=rho)</code>.
</p>
<p>The wrapped Cauchy cdf, for which there is no analytical expression,
is calculated by wrapping the Cauchy distribution <code class="reqn">K</code> times
around the circle in each direction and summing the Cauchy cdfs at each point of
the circle. Let <code class="reqn">\Omega</code> follow a Cauchy distribution and
<code class="reqn">\Theta</code> a wrapped Cauchy distribution, where <code class="reqn">\Theta</code> can take values
<code class="reqn">\theta \in [-\pi,\pi)</code>.
<code class="reqn">Pr(\Theta \le \theta)</code> is approximated as
</p>
<p style="text-align: center;"><code class="reqn">\sum^K_{k=-K}Pr(\Omega \le \theta+2\pi k)-Pr(\Omega \le -\pi+2\pi k).</code>
</p>

<p>The quantiles are calculated by numerical inversion.
</p>


<h3>Value</h3>


<ul>
<li><p><code>dwrappedcauchy()</code> gives a <a href="base.html#topic+vector">vector</a> of length <code>length(theta)</code>
containing the density at <code>theta</code>.
</p>
</li>
<li><p><code>pwrappedcauchy()</code> gives a
<a href="base.html#topic+vector">vector</a> of length <code>length(theta)</code> containing
the distribution function at the corresponding values of <code>theta</code>.
</p>
</li>
<li><p><code>qwrappedcauchy()</code> gives a <a href="base.html#topic+vector">vector</a> of length <code>length(p)</code>
containing the quantiles at the corresponding values of <code>p</code>.
</p>
</li>
<li><p><code>rwrappedcauchy()</code> generates a <a href="base.html#topic+vector">vector</a> of length <code>n</code>
containing the random samples, i.e. angles in <code class="reqn">[-\pi, \pi)</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code>circular::<a href="circular.html#topic+dwrappedcauchy">dwrappedcauchy</a>()</code>,
<code>circular::<a href="circular.html#topic+rwrappedcauchy">rwrappedcauchy</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

rwrappedcauchy(10, location = 0, scale =3)

dwrappedcauchy(c(0.1, pi), location = pi, scale =2)
circular::dwrappedcauchy(circular::circular(c(0.1,pi)), mu = circular::circular(pi), rho =exp(-2))

prob &lt;- pwrappedcauchy(c(0.1, pi), location = pi, scale =2)
prob
qwrappedcauchy(prob, location = pi, scale =2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
