<!DOCTYPE html><html lang="en"><head><title>Help for package Bioi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Bioi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.euclidean_linker_cpp'><p>Return the group number for each localization.</p></a></li>
<li><a href='#.find_min_dists_cpp'><p>For all points in matrix 1, return the distance to and index of the</p>
nearest point in matrix 2.</a></li>
<li><a href='#.perform_grouping'><p>Return the group number for each localization.</p></a></li>
<li><a href='#.perform_partitioning'><p>Return the group number for each localization.</p></a></li>
<li><a href='#Bioi'><p><code>Bioi</code> package</p></a></li>
<li><a href='#euclidean_linker'><p>Return the group number for each localization.</p></a></li>
<li><a href='#find_blobs'><p>Assign all neighboring pixels the same group number.</p></a></li>
<li><a href='#find_min_dists'><p>For all points in matrix 1, return the distance to and index of the</p>
nearest point in matrix 2.</a></li>
<li><a href='#identify_thresholded_objects'><p>Assign all neighboring pixels the same group number.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Biological Image Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.10</td>
</tr>
<tr>
<td>Author:</td>
<td>Zachary Colburn</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zachary Colburn &lt;zcolburn@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Single linkage clustering and connected component analyses are often performed on biological images. 'Bioi' provides a set of functions for performing these tasks. This functionality is implemented in several key functions that can extend to from 1 to many dimensions. The single linkage clustering method implemented here can be used on n-dimensional data sets, while connected component analyses are limited to 3 or fewer dimensions.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp(&ge; 0.12.13), assertthat(&ge; 0.2.0), dplyr(&ge; 0.7.4),
igraph</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, ggplot2, testthat(&ge; 2.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-12-08 00:45:28 UTC; ZacharyColburn</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-12-08 01:30:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='.euclidean_linker_cpp'>Return the group number for each localization.</h2><span id='topic+.euclidean_linker_cpp'></span>

<h3>Description</h3>

<p>Group PALM/iPALM localizations based on their physical separation distance
</p>
<p>PALM/iPALM data results in a list of spatial coordinates for fluorophore
localizations. This function groups nearby localizations if they are within
the provided critical distance from each other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.euclidean_linker_cpp(input, critDist, use_prog_bar = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".euclidean_linker_cpp_+3A_input">input</code></td>
<td>
<p>A numeric matrix where each row is a localization and each
column is a spatial axis.</p>
</td></tr>
<tr><td><code id=".euclidean_linker_cpp_+3A_critdist">critDist</code></td>
<td>
<p>The critical distance for which localizations nearer than
this distance are deemed part of the same group.</p>
</td></tr>
<tr><td><code id=".euclidean_linker_cpp_+3A_use_prog_bar">use_prog_bar</code></td>
<td>
<p>A logical indicating whether a progress bar should be
used. This must be set to false when running in parallel.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zach Colburn
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Function call
## Not run: .euclidean_linker_cpp(inputMatrix, critDist)

</code></pre>

<hr>
<h2 id='.find_min_dists_cpp'>For all points in matrix 1, return the distance to and index of the
nearest point in matrix 2.</h2><span id='topic+.find_min_dists_cpp'></span>

<h3>Description</h3>

<p>Find the shortest distance between each point in one data set and the points
in a second set.
</p>
<p>This function determines the distance between every point in data set 1 and
the points in data set 2. Unlike this function's naive counterpart,
find_min_dists, this function divides the PALM/iPALM localization data
into blocks, operates on the data in each block, and then performs linking
operations on neighboring blocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.find_min_dists_cpp(mOne, mTwo)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".find_min_dists_cpp_+3A_mone">mOne</code></td>
<td>
<p>A numeric matrix where each row is a localization and each
column is a spatial axis.</p>
</td></tr>
<tr><td><code id=".find_min_dists_cpp_+3A_mtwo">mTwo</code></td>
<td>
<p>A numeric matrix with the same number of columns as mOne.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zach Colburn
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(10)

mOne &lt;- as.matrix(data.frame(
x = rnorm(10),
y = rbinom(10, 100, 0.5),
z = runif(10)
))

mTwo &lt;- as.matrix(data.frame(
x = rnorm(20),
y = rbinom(20, 100, 0.5),
z = runif(20)
))

.find_min_dists_cpp(mOne, mTwo)

## End(Not run)

</code></pre>

<hr>
<h2 id='.perform_grouping'>Return the group number for each localization.</h2><span id='topic+.perform_grouping'></span>

<h3>Description</h3>

<p>Group PALM/iPALM localizations based on their physical separation distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.perform_grouping(input, critDist, use_prog_bar = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".perform_grouping_+3A_input">input</code></td>
<td>
<p>A numeric matrix where each row is a localization and each
column is a spatial axis.</p>
</td></tr>
<tr><td><code id=".perform_grouping_+3A_critdist">critDist</code></td>
<td>
<p>The critical distance for which localizations nearer than
this distance are deemed part of the same group.</p>
</td></tr>
<tr><td><code id=".perform_grouping_+3A_use_prog_bar">use_prog_bar</code></td>
<td>
<p>TRUE/FALSE indicating whether a progress bar should be
used. This is only available when run_parallel is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>PALM/iPALM data results in a list of spatial coordinates for fluorophore
localizations. This function groups nearby localizations if they are within
the provided critical distance from each other.
</p>


<h3>Author(s)</h3>

<p>Zach Colburn
</p>

<hr>
<h2 id='.perform_partitioning'>Return the group number for each localization.</h2><span id='topic+.perform_partitioning'></span>

<h3>Description</h3>

<p>Group PALM/iPALM localizations based on their physical separation distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.perform_partitioning(
  input,
  critDist,
  use_prog_bar = TRUE,
  run_parallel = FALSE,
  num_cores = NULL,
  partition_req = 5000,
  parallel_call_depth = 3,
  min_gap = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".perform_partitioning_+3A_input">input</code></td>
<td>
<p>A numeric matrix where each row is a localization and each
column is a spatial axis.</p>
</td></tr>
<tr><td><code id=".perform_partitioning_+3A_critdist">critDist</code></td>
<td>
<p>The critical distance for which localizations nearer than
this distance are deemed part of the same group.</p>
</td></tr>
<tr><td><code id=".perform_partitioning_+3A_use_prog_bar">use_prog_bar</code></td>
<td>
<p>TRUE/FALSE indicating whether a progress bar should be
used. This is only available when run_parallel is FALSE.</p>
</td></tr>
<tr><td><code id=".perform_partitioning_+3A_run_parallel">run_parallel</code></td>
<td>
<p>TRUE/FALSE indicating whether operations should be
performed in parallel. This is only valid if partitioning is performed.</p>
</td></tr>
<tr><td><code id=".perform_partitioning_+3A_num_cores">num_cores</code></td>
<td>
<p>The number of cores to use if running in parallel.</p>
</td></tr>
<tr><td><code id=".perform_partitioning_+3A_partition_req">partition_req</code></td>
<td>
<p>The minimum number of points required to create a new
partition.</p>
</td></tr>
<tr><td><code id=".perform_partitioning_+3A_parallel_call_depth">parallel_call_depth</code></td>
<td>
<p>The number of levels of partitioning that should
be performed before terminating calls to run operations in parallel. The
number of threads opened when running in parallel is equal to
2^(parallel_call_depth)*num_cores.</p>
</td></tr>
<tr><td><code id=".perform_partitioning_+3A_min_gap">min_gap</code></td>
<td>
<p>The minimum width of any dimension created during
partitioning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>PALM/iPALM data results in a list of spatial coordinates for fluorophore
localizations. This function groups nearby localizations if they are within
the provided critical distance from each other.
</p>


<h3>Author(s)</h3>

<p>Zach Colburn
</p>

<hr>
<h2 id='Bioi'><code>Bioi</code> package</h2><span id='topic+Bioi'></span>

<h3>Description</h3>

<p>PALM/iPALM localization and biological image analysis functions.
</p>

<hr>
<h2 id='euclidean_linker'>Return the group number for each localization.</h2><span id='topic+euclidean_linker'></span>

<h3>Description</h3>

<p>Group PALM/iPALM localizations based on their physical separation distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euclidean_linker(
  input,
  critDist,
  use_prog_bar = TRUE,
  run_parallel = FALSE,
  num_cores = NULL,
  partition_req = 5000,
  parallel_call_depth = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="euclidean_linker_+3A_input">input</code></td>
<td>
<p>A numeric matrix where each row is a localization and each
column is a spatial axis.</p>
</td></tr>
<tr><td><code id="euclidean_linker_+3A_critdist">critDist</code></td>
<td>
<p>The critical distance for which localizations nearer than
this distance are deemed part of the same group.</p>
</td></tr>
<tr><td><code id="euclidean_linker_+3A_use_prog_bar">use_prog_bar</code></td>
<td>
<p>TRUE/FALSE indicating whether a progress bar should be
used. This is only available when run_parallel is FALSE.</p>
</td></tr>
<tr><td><code id="euclidean_linker_+3A_run_parallel">run_parallel</code></td>
<td>
<p>TRUE/FALSE indicating whether operations should be
performed in parallel. This is only valid if partitioning is performed.</p>
</td></tr>
<tr><td><code id="euclidean_linker_+3A_num_cores">num_cores</code></td>
<td>
<p>The number of cores to use if running in parallel.</p>
</td></tr>
<tr><td><code id="euclidean_linker_+3A_partition_req">partition_req</code></td>
<td>
<p>The minimum number of points required to create a new
partition.</p>
</td></tr>
<tr><td><code id="euclidean_linker_+3A_parallel_call_depth">parallel_call_depth</code></td>
<td>
<p>The number of levels of partitioning that should
be performed before terminating calls to run operations in parallel. The
number of threads opened when running in parallel is equal to
2^(parallel_call_depth)*num_cores.</p>
</td></tr>
<tr><td><code id="euclidean_linker_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to euclidean_linker (i.e.
finding_blobs).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>PALM/iPALM data results in a list of spatial coordinates for fluorophore
localizations. This function groups nearby localizations if they are within
the provided critical distance from each other.
</p>


<h3>Author(s)</h3>

<p>Zach Colburn
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate random data.
#set.seed(10)
#input &lt;- as.matrix(data.frame(x=rnorm(10),y=rnorm(10)))

# Perform linking.
#euclidean_linker(input, 0.4)

</code></pre>

<hr>
<h2 id='find_blobs'>Assign all neighboring pixels the same group number.</h2><span id='topic+find_blobs'></span>

<h3>Description</h3>

<p>Perform connected-component labeling to group continuous, thresholded
objects in 3-dimensional arrays.
</p>
<p>This function takes a vector, matrix, or 3-dimensional array where each
element is TRUE if it corresponds to an object-positive index or FALSE if it
corresponds to a background index. An object of the same dimension as the
input is returned. All connected object indices take the value of their
group number and all background indices take the value NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_blobs(
  arr,
  use_prog_bar = TRUE,
  run_parallel = FALSE,
  num_cores = NULL,
  partition_req = NULL,
  parallel_call_depth = 3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_blobs_+3A_arr">arr</code></td>
<td>
<p>A vector, matrix, or 3-dimensional array where object-positive
elements are denoted by the value TRUE and background elements are denoted
by the value FALSE.</p>
</td></tr>
<tr><td><code id="find_blobs_+3A_use_prog_bar">use_prog_bar</code></td>
<td>
<p>TRUE/FALSE indicating whether a progress bar should be
used. This is only available when run_parallel is FALSE.</p>
</td></tr>
<tr><td><code id="find_blobs_+3A_run_parallel">run_parallel</code></td>
<td>
<p>TRUE/FALSE indicating whether operations should be
performed in parallel. This is only valid if partitioning is performed.</p>
</td></tr>
<tr><td><code id="find_blobs_+3A_num_cores">num_cores</code></td>
<td>
<p>The number of cores to use if running in parallel.</p>
</td></tr>
<tr><td><code id="find_blobs_+3A_partition_req">partition_req</code></td>
<td>
<p>The minimum number of points required to create a new
partition.</p>
</td></tr>
<tr><td><code id="find_blobs_+3A_parallel_call_depth">parallel_call_depth</code></td>
<td>
<p>The number of levels of partitioning that should
be performed before terminating calls to run operations in parallel. The
number of threads opened when running in parallel is equal to
2^(parallel_call_depth)*num_cores.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zach Colburn
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a random matrix.
set.seed(10)
mat &lt;- matrix(runif(70), nrow = 7)

# Arbitrarily say that everything below 0.8 is background.
logical_mat &lt;- mat &gt; 0.8

# Find blobs.
find_blobs(logical_mat)

</code></pre>

<hr>
<h2 id='find_min_dists'>For all points in matrix 1, return the distance to and index of the
nearest point in matrix 2.</h2><span id='topic+find_min_dists'></span>

<h3>Description</h3>

<p>Find the shortest distance between each point in one data set and the points
in a second set.
</p>
<p>This function determines the distance between every point in mOne and the
nearest point in mTwo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_min_dists(mOne, mTwo)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_min_dists_+3A_mone">mOne</code></td>
<td>
<p>A numeric matrix where each row is a localization and each
column is a spatial axis.</p>
</td></tr>
<tr><td><code id="find_min_dists_+3A_mtwo">mTwo</code></td>
<td>
<p>A numeric matrix with the same number of columns as mOne.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zach Colburn
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate random data.
set.seed(10)

mOne &lt;- as.matrix(data.frame(
x = rnorm(10),
y = rbinom(10, 100, 0.5),
z = runif(10)
))

mTwo &lt;- as.matrix(data.frame(
x = rnorm(20),
y = rbinom(20, 100, 0.5),
z = runif(20)
))

# Find the minimum distance between each point in mOne and the points in
# mTwo.
find_min_dists(mOne, mTwo)

</code></pre>

<hr>
<h2 id='identify_thresholded_objects'>Assign all neighboring pixels the same group number.</h2><span id='topic+identify_thresholded_objects'></span>

<h3>Description</h3>

<p>This function is deprecated. It now calls the more efficient find_blobs
method.
</p>
<p>This function takes a matrix corresponding to a thresholded image and
returns a matrix of the same size, where all adjacent, thresholded pixels
are the same integer corresponding to that object's cluster number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identify_thresholded_objects(img, pixRange = 50)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="identify_thresholded_objects_+3A_img">img</code></td>
<td>
<p>A thresholded matrix (where non-object pixels are assigned a
value of 0).</p>
</td></tr>
<tr><td><code id="identify_thresholded_objects_+3A_pixrange">pixRange</code></td>
<td>
<p>This parameter is now obsolete. Previously, the parameter
denoted an integer number of pixels to specify a search region. Execution
was faster when this value was small. However, the value needed to be larger
than the diameter of the largest continuous object in the image.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zach Colburn
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a random matrix.
set.seed(10)
mat &lt;- matrix(runif(70), nrow = 7)

# Arbitrarily say that everything below 0.8 is background.
mat[mat &lt; 0.8] &lt;- 0

# Find blobs.
identify_thresholded_objects(mat)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
