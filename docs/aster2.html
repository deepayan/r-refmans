<!DOCTYPE html><html><head><title>Help for package aster2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {aster2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aster2-package'>
<p>Aster Models</p></a></li>
<li><a href='#asterdata'><p>Object Describing Saturated Aster Model</p></a></li>
<li><a href='#constancy'><p>Constancy Spaces for Aster Models</p></a></li>
<li><a href='#cumulant'><p>Cumulant Functions for Aster Models</p></a></li>
<li><a href='#echinacea'><p>Life History Data on Echinacea angustifolia</p></a></li>
<li><a href='#families'><p>Families for Aster Models</p></a></li>
<li><a href='#hornworm'><p>Life History Data on Manduca sexta</p></a></li>
<li><a href='#link'><p>Link Functions for Aster Models</p></a></li>
<li><a href='#subset.asterdata'><p>Subset Object Describing Saturated Aster Model</p></a></li>
<li><a href='#test1'><p>Test Data</p></a></li>
<li><a href='#Transform'><p>Change-of-Parameter Functions for Aster Models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-03-26</td>
</tr>
<tr>
<td>Title:</td>
<td>Aster Models</td>
</tr>
<tr>
<td>Author:</td>
<td>Charles J. Geyer &lt;charlie@stat.umn.edu&gt;.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Charles J. Geyer &lt;charlie@stat.umn.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0), Matrix</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>aster</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Description:</td>
<td>Aster models are exponential family regression models for life
    history analysis.  They are like generalized linear models except that
    elements of the response vector can have different families (e. g.,
    some Bernoulli, some Poisson, some zero-truncated Poisson, some normal)
    and can be dependent, the dependence indicated by a graphical structure.
    Discrete time survival analysis, zero-inflated Poisson regression, and
    generalized linear models that are exponential family (e. g., logistic
    regression and Poisson regression with log link) are special cases.
    Main use is for data in which there is survival over discrete time periods
    and there is additional data about what happens conditional on survival
    (e. g., number of offspring).  Uses the exponential family canonical
    parameterization (aster transform of usual parameterization).
    Unlike the aster package, this package does dependence groups (nodes of
    the graph need not be conditionally independent given their predecessor
    node), including multinomial and two-parameter normal as families.  Thus
    this package also generalizes mark-capture-recapture analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.stat.umn.edu/geyer/aster/">http://www.stat.umn.edu/geyer/aster/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-03-26 20:47:12 UTC; geyer</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-03-26 21:30:45 UTC</td>
</tr>
</table>
<hr>
<h2 id='aster2-package'>
Aster Models
</h2><span id='topic+aster2-package'></span><span id='topic+aster2'></span>

<h3>Description</h3>

<p>Aster models are exponential family graphical models that
combine aspects of generalized linear models and survival analysis.
</p>
<p>This package is still under development, only about half finished.
However, it does do maximum likelihood for unconditional aster models
with dependence groups, which the old package <code>aster</code> does not.
</p>
<p>The main differences between this package and the old package are as follows.
</p>

<ol>
<li><p> The old package had triple indices for model matrices.  The first index
ran over individuals, the second index over nodes of the graph for
an individual, and the third index over regression coefficients.  Consequently
the model matrix was represented (sometimes, but not consistently) as a
three-dimensional array rather than a matrix, which was very confusing, even
to the package author.  This package ignores individuals, one index runs
over all nodes of the combined graph for all individuals.  Thus model matrices
are always matrices.
</p>
</li>
<li><p> The old package did not implement dependence groups, although they were
described in Geyer, Wagenius and Shaw (2007).  This package does.
Consequently, this package requires a data frame, a vector <code>pred</code> that
indicates predecessors, a vector <code>group</code> that indicates individuals in
the same dependence group, and a vector <code>fam</code> that indicates families
to specify a saturated aster model (the old package required only
the data frame, <code>pred</code>, and <code>fam</code>).
To facilitate the old style model specification, there is a new function
<code><a href="#topic+asterdata">asterdata</a></code> that constructs objects of class <code>"asterdata"</code>
given an old style data frame, <code>pred</code>, and <code>fam</code>.  All other
functions of the package take objects of class <code>"asterdata"</code> as model
specifications.
</p>
</li>
<li><p> The function <code><a href="aster.html#topic+predict.aster">predict.aster</a></code> in the old package
did some parameter transformations, but not all, and the returned value,
when a list, had a component <code>gradient</code>, that was undocumented but useful
in applying the delta method.  The functions
<code><a href="#topic+transformSaturated">transformSaturated</a></code>,
<code><a href="#topic+transformConditional">transformConditional</a></code>, and
<code><a href="#topic+transformUnconditional">transformUnconditional</a></code> in this package transform
between any of the following parameter vectors:
the conditional canonical parameter <code class="reqn">\theta</code>,
the unconditional canonical parameter <code class="reqn">\varphi</code>,
the conditional mean value parameter <code class="reqn">\xi</code>,
the unconditional mean value parameter <code class="reqn">\mu</code>,
the canonical affine submodel canonical parameter <code class="reqn">\beta</code>,
and (unconditional aster models only)
the canonical affine submodel mean value parameter <code class="reqn">\tau</code>
(this last parameter is new, not discussed in the cited papers below, it is
<code class="reqn">\tau = M^T \mu</code>, where <code class="reqn">M</code> is the model matrix).
The change of parameter from <code class="reqn">\tau</code> to <code class="reqn">\beta</code>
is equivalent to maximum likelihood estimation for an unconditional
aster model when the value <code class="reqn">\tau = M^T y</code> is used,
where <code class="reqn">y</code> is the response vector.  All of these transformation functions
also compute derivatives, if requested.  See examples.
</p>
</li></ol>



<h3>Bugs</h3>

<p>Functions analogous to <code>aster</code>, <code>anova</code>, and <code>predict</code>
in the old package are missing, thus model fitting, hypothesis tests,
and confidence intervals are more cumbersome.  In fact, since there is
no function to calculate log likelihoods (like <code>mlogl</code> in the old
package), there is no way to do likelihood ratio tests (but Rao or Wald
tests could be done, for unconditional aster models, since the derivative
of the log likelihood is observed minus expected
<code class="reqn">M^T (y - \mu)</code>.
</p>


<h3>References</h3>

<p>Geyer, C. J., Wagenius, S., and Shaw, R. G. (2007)
Aster Models for Life History Analysis.
<em>Biometrika</em> <b>94</b> 415&ndash;426.
</p>
<p>Shaw, R. G., Geyer, C. J., Wagenius, S., Hangelbroek, H. H.
and Etterson, J. R. (2008)
Unifying Life History Analyses for Inference of Fitness
and Population Growth.
<em>American Naturalist</em>, <b>172</b>, E35&ndash;E47. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asterdata">asterdata</a></code>, <code><a href="#topic+transformSaturated">transformSaturated</a></code>,
<code><a href="#topic+families">families</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: # perfectly good example but takes longer to run than CRAN allows
data(echinacea)
#### estimate MLE (simpler model than in Biometrika paper cited, not as good)
hdct &lt;- as.numeric(grepl("hdct", as.character(echinacea$redata$varb)))
modmat &lt;- model.matrix(resp ~ varb + nsloc + ewloc + pop * hdct - pop,
    data = echinacea$redata)
tau.hat &lt;- as.numeric(t(modmat) %*% echinacea$redata$resp)
beta.hat &lt;- transformUnconditional(tau.hat, modmat, echinacea,
    from = "tau", to = "beta")
inverse.fisher &lt;- jacobian(tau.hat, echinacea, transform = "unconditional",
    from = "tau", to = "beta", modmat = modmat)
#### now have MLE (beta.hat) and pseudo-inverse of Fisher information
#### (inverse.fisher), pseudo-inverse because modmat is not full rank
foo &lt;- cbind(beta.hat, sqrt(diag(inverse.fisher)))
foo &lt;- cbind(foo, foo[ , 1]/foo[ , 2])
foo &lt;- cbind(foo, 2 * pnorm(- abs(foo[ , 3])))
dimnames(foo) &lt;- list(colnames(modmat),
    c("Estimate", "Std. Error", "z value", "Pr(&gt;|z|)"))
printCoefmat(foo)
#### coefficients constrained to be zero because parameterization is not
#### identifiable have estimate zero and std. error zero (and rest NA)

#### estimate fitness in populations
#### generate new data with one individual in each pop at location (0, 0)
pop.names &lt;- levels(echinacea$redata$pop)
pop.idx &lt;- match(pop.names, as.character(echinacea$redata$pop))
pop.id &lt;- echinacea$redata$id[pop.idx]
newdata &lt;- subset(echinacea, echinacea$redata$id %in% pop.id)
newdata$redata[ , "nsloc"] &lt;- 0
newdata$redata[ , "ewloc"] &lt;- 0
hdct &lt;- as.integer(grepl("hdct", as.character(newdata$redata$varb)))
#### modmat for new data
newmodmat &lt;- model.matrix(resp ~ varb + nsloc + ewloc + pop * hdct - pop,
    data = newdata$redata)
#### matrix that when multiplied mean value parameter vector gives fitness
#### in each pop
amat &lt;- matrix(NA, nrow = length(pop.id), ncol = nrow(newmodmat))
for (i in 1:nrow(amat))
    amat[i, ] &lt;- as.numeric(grepl(paste("^", pop.id[i], ".hdct", sep = ""),
        rownames(newmodmat)))
#### transform to expected fitness parameters
efit &lt;- transformUnconditional(beta.hat, newmodmat, newdata,
    from = "beta", to = "mu")
efit &lt;- as.numeric(amat %*% efit)
#### jacobian matrix of this transformation
jack &lt;- jacobian(beta.hat, newdata, transform = "unconditional",
    from = "beta", to = "mu", modmat = newmodmat)
#### delta method standard errors
sefit &lt;- sqrt(diag(amat %*% jack %*% inverse.fisher %*% t(jack) %*% t(amat)))
foo &lt;- cbind(efit, sefit)
dimnames(foo) &lt;- list(pop.names, c("Est. fitness", "Std. Error"))
print(foo)

## End(Not run)
</code></pre>

<hr>
<h2 id='asterdata'>Object Describing Saturated Aster Model</h2><span id='topic+asterdata'></span><span id='topic+validasterdata'></span><span id='topic+is.validasterdata'></span>

<h3>Description</h3>

<p>Functions to construct and test conformance to the contract for objects
of class <code>"asterdata"</code>.  All other functions in this package take
model descriptions of this form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asterdata(data, vars, pred, group, code, families, delta,
  response.name = "resp", varb.name = "varb",
  tolerance = 8 * .Machine$double.eps)
validasterdata(object, tolerance = 8 * .Machine$double.eps)
is.validasterdata(object, tolerance = 8 * .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asterdata_+3A_data">data</code></td>
<td>
<p>a data frame containing response and predictor variables for
the aster model.</p>
</td></tr>
<tr><td><code id="asterdata_+3A_vars">vars</code></td>
<td>
<p>a character vector containing names of variables in the data
frame <code>data</code> that are components of the response vector of the
aster model.</p>
</td></tr>
<tr><td><code id="asterdata_+3A_pred">pred</code></td>
<td>
<p>an integer vector satisfying <code>length(pred) == length(vars)</code>
specifying the arrows of the subgraph of the aster model corresponding
to a single individual.  Must be nonnegative and satisfy
<code>all(pred &lt; seq(along = pred))</code>.
A zero value of <code>pred[j]</code> indicates the predecessor of node <code>j</code>
is an initial node (formerly called root node) of the subgraph.
A nonzero value of <code>pred[j]</code> indicates the predecessor of node
<code>j</code> is node <code>pred[j]</code>.  In either case there is an arrow in
the subgraph from predecessor node to successor node.</p>
</td></tr>
<tr><td><code id="asterdata_+3A_group">group</code></td>
<td>
<p>an integer vector satisfying <code>length(group) == length(vars)</code>
specifying the lines of the subgraph of the aster model corresponding to
a single individual, which in turn specify the dependence groups.
Must be nonnegative and satisfy <code>all(group &lt; seq(along = group))</code>.
Nonzero elements of <code>group</code> indicate nodes of the subgraph that
are connected by a line and hence are in the same dependence group:
nodes <code>j</code> and <code>group[j]</code> are connected by a line.  Since
nodes in the same dependence group must have the same predecessor,
this requires <code>pred[group[j]] == pred[j]</code>.  Since
nodes in the same dependence group must be in the same family,
this requires <code>code[group[j]] == code[j]</code>.
It also requires that the dimension of the family specified by
<code>code[j]</code> be the same as the number of nodes in the dependence
group.  Zero elements of <code>group</code> indicate nothing about dependence
groups.
</p>
<p>The lines indicate a transitive relation.  If there is a line from
node <code>j1</code> to node <code>j2</code> and a line from
node <code>j2</code> to node <code>j3</code> then there is also a line from
node <code>j1</code> to node <code>j3</code>, but this line need not be specified
by the <code>group</code> vector, and indeed cannot.  If there is a dependence
group with <code>d</code> nodes, then there are <code>choose(d, 2)</code> lines
connecting these nodes, but the <code>group</code> vector can only specify
<code>d - 1</code> lines which imply the rest.
</p>
<p>For example, if nodes <code>j1</code>, <code>j2</code>, <code>j3</code>, and <code>j4</code>
are to make up a four-dimensional dependence group and <code>j1 &lt; j2</code>,
<code>j2 &lt; j3</code>, and <code>j3 &lt; j4</code>, we must have <code>group[j1] == 0</code>,
<code>group[j2] == j1</code>, <code>group[j3] == j2</code>, and
<code>group[j4] == j3</code>.
This is forced by the requirement <code>all(group &lt; seq(along = group))</code>.</p>
</td></tr>
<tr><td><code id="asterdata_+3A_code">code</code></td>
<td>
<p>an integer vector satisfying <code>length(code) == length(vars)</code>
specifying the families corresponding to the dependence groups.
This requires </p>
<pre>all(code %in% seq(along = families)</pre>
<p>Node <code>j</code> is in a dependence group
with family described by <code>families[code[j]]</code>.
</p>
<p>Note that <code>group[j] == k</code>
requires <code>families[j] == families[k]</code> when <code>k != 0</code>.</p>
</td></tr>
<tr><td><code id="asterdata_+3A_families">families</code></td>
<td>
<p>a list of family specifications
(see <code><a href="#topic+families">families</a></code>).  Specifications of families not having
hyperparameters may be abbreviated as character strings, for example,
<code>"binomial"</code> rather than <code>fam.binomial()</code>.</p>
</td></tr>
<tr><td><code id="asterdata_+3A_delta">delta</code></td>
<td>
<p>a numeric vector satisfying <code>length(delta) == length(vars)</code>
specifying the degeneracies of the aster model for a single individual.
The model specified is the limit as <code class="reqn">s \to \infty</code> of
nondegenerate models having conditional canonical parameter vector
<code class="reqn">\theta + s \delta</code> (note that the conditional
canonical parameter vector is always used here, regardless of whether
conditional or unconditional canonical affine submodels are to be used).
May be missing (and usually is) in which case <code class="reqn">\delta = 0</code>
is implied, meaning the limit is trivial (same as not taking a limit).</p>
</td></tr>
<tr><td><code id="asterdata_+3A_response.name">response.name</code></td>
<td>
<p>a character string giving the name of the response
vector.</p>
</td></tr>
<tr><td><code id="asterdata_+3A_varb.name">varb.name</code></td>
<td>
<p>a character string giving the name of the factor covariate
that says which of the variables in the data frame <code>data</code> correspond
to which components of the response vector.</p>
</td></tr>
<tr><td><code id="asterdata_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric &gt;= 0.  Relative errors smaller
than <code>tolerance</code> are not considered in checking validity
of normal location-scale data.</p>
</td></tr>
<tr><td><code id="asterdata_+3A_object">object</code></td>
<td>
<p>an object of class <code>"asterdata"</code>.  The function
<code>validasterdata</code> always returns <code>TRUE</code> or throws an error with
an informative message.  The function <code>is.validasterdata</code> never throws
an error unless <code>object</code> has the wrong class, returning <code>TRUE</code>
or <code>FALSE</code> according to whether <code>object</code> does or does not
conform to the contract for class <code>"asterdata"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Response variables in dependence groups are taken to be in the order they
appear in the response vector.  The first to appear in the response vector
is the first canonical statistic for the dependence group distribution,
the second to appear the second canonical statistic, and so forth.
The number of response variables in the dependence group must match the
dimension of the dependence group distribution.
</p>
<p>This function only handles the usual case where the subgraph for every
individual is isomorphic to subgraph for every other individual
and all initial nodes (formerly
called root nodes) correspond to the constant one.  Each row of <code>data</code>
is the data for one individual.  The vectors <code>vars</code>, <code>pred</code>,
<code>group</code>, <code>code</code>, and <code>delta</code> (if not missing) describe
the subgraph for one individual (which is the same for all individuals).
</p>
<p>In other cases for which this function does not have the flexibility to
construct the appropriate object of class <code>"asterdata"</code>, such an
object will have to be constructed &ldquo;by hand&rdquo; using R statements
not involving this function or modifying an object produced by this
function.  See the following section for description of such objects.
The functions <code>validasterdata</code> and <code>is.validasterdata</code> can be
used to check whether objects constructed &ldquo;by hand&rdquo; have been
constructed correctly.
</p>


<h3>Value</h3>

<p>an object of class <code>"asterdata"</code> is a list containing the
following components
</p>
<table>
<tr><td><code>redata</code></td>
<td>
<p>a data frame having <code>nrow(data) * length(vars)</code> rows
and containing variables having names
in <code>setdiff(names(data), vars)</code> and also the names
<code>"id"</code>, <code>response.name</code>, and <code>varb.name</code>.
Produced from <code>data</code> using the <code><a href="stats.html#topic+reshape">reshape</a></code>
function.  Each variable in <code>setdiff(names(data), vars)</code> is repeated
<code>length(vars)</code> times.  The variable named <code>response.name</code>
is the concatenation of the variables in <code>data</code> with names
in <code>vars</code>.  The variable named <code>varb.name</code> is a factor
having levels <code>vars</code> that says which of the variables in the data
frame <code>data</code> correspond to which components of the response vector.
The variable named <code>"id"</code> is an integer vector that says which of
the individuals (which rows of <code>data</code>) correspond to which rows
of <code>redata</code>.  Not all objects of class <code>"asterdata"</code> need
have an <code>id</code> variable, although all those constructed by this
function do.</p>
</td></tr>
<tr><td><code>repred</code></td>
<td>
<p>an integer vector satisfying
<code>length(repred) == nrow(redata)</code> specifying the arrows of the
graph of the aster model for all individuals.
Must be nonnegative and satisfy <code>all(repred &lt; seq(along = repred))</code>.
A zero value of <code>repred[j]</code> indicates the predecessor of node
<code>j</code> is an initial node (formerly called root node) of the graph.
A nonzero value of <code>repred[j]</code> indicates the predecessor of node
<code>j</code> is node <code>repred[j]</code>.  In either case there is an arrow in
the graph from predecessor node to successor node.
</p>
<p>Note that
<code>repred</code> is determined by <code>pred</code> but is quite different from
it.  Firstly, the lengths differ.  Secondly, <code>repred</code> is not just
a repetition of <code>pred</code>.  The numbers in <code>pred</code>, if nonzero,
are indices for the vector <code>vars</code> whereas the numbers
in <code>repred</code>, if nonzero,
are row indices for the data frame <code>redata</code>.</p>
</td></tr>
<tr><td><code>initial</code></td>
<td>
<p>a numeric vector specifying constants associated with
initial nodes (formerly called root nodes) of the graphical model
for all individuals.  If <code>repred[j] == 0</code> then the predecessor
of node <code>j</code> is an initial node associated with the constant
<code>initial[j]</code>, which must be a positive integer unless the
family associated with the arrow from this initial node to node <code>j</code>
is infinitely divisible (the only such family currently implemented
being Poisson), in which case <code>initial[j]</code> must
be a strictly positive and finite real number.  If <code>repred[j] != 0</code>,
then <code>initial[j]</code> is ignored and may be any numeric value, including
<code>NA</code> or <code>NaN</code>.  This function always makes <code>initial</code>
equal to <code>rep(1, nrow(redata))</code> but the more general description
above is valid for objects of class <code>"asterdata"</code> constructed
&ldquo;by hand&rdquo;.</p>
</td></tr>
<tr><td><code>regroup</code></td>
<td>
<p>an integer vector satisfying
<code>length(regroup) == nrow(redata)</code>
specifying the lines of the graph of the aster model for all individuals,
which in turn specify the dependence groups.
Must be nonnegative
and satisfy <code>all(regroup &lt; seq(along = regroup))</code>.
Nonzero elements of <code>regroup</code> indicate nodes of the graph that
are connected by a line and hence are in the same dependence group:
nodes <code>j</code> and <code>regroup[j]</code> are connected by a line.  Since
nodes in the same dependence group must have the same predecessor,
this requires <code>repred[regroup[j]] == repred[j]</code>.  Since
nodes in the same dependence group must be in the same family,
this requires <code>recode[regroup[j]] == recode[j]</code>.
</p>
<p>It also requires that the dimension of the family specified by
<code>recode[j]</code> be the same as the number of nodes in the dependence
group.  Zero elements of <code>regroup</code> indicate nothing about dependence
groups.
</p>
<p>The lines indicate a transitive relation.  If there is a line from
node <code>j1</code> to node <code>j2</code> and a line from
node <code>j2</code> to node <code>j3</code> then there is also a line from
node <code>j1</code> to node <code>j3</code>, but this line need not be specified
by the <code>group</code> vector, and indeed cannot.  If there is a dependence
group with <code>d</code> nodes, then there are <code>choose(d, 2)</code> lines
connecting these nodes, but the <code>group</code> vector can only specify
<code>d - 1</code> lines which imply the rest.
</p>
<p>For example, if nodes <code>j1</code>, <code>j2</code>, <code>j3</code>, and <code>j4</code>
are to make up a four-dimensional dependence group and <code>j1 &lt; j2</code>,
<code>j2 &lt; j3</code>, and <code>j3 &lt; j4</code>, we must have <code>regroup[j1] == 0</code>,
<code>regroup[j2] == j1</code>, <code>regroup[j3] == j2</code>, and
<code>regroup[j4] == j3</code>.
This is forced by the requirement
<code>all(regroup &lt; seq(along = regroup))</code>.
</p>
<p>Note that
<code>regroup</code> is determined by <code>group</code> but is quite different from
it.  Firstly, the lengths differ.  Secondly, <code>regroup</code> is not just
a repetition of <code>group</code>.  The numbers in <code>group</code>, if nonzero,
are indices for the vector <code>vars</code> whereas the numbers
in <code>regroup</code>, if nonzero,
are row indices for the data frame <code>redata</code>.</p>
</td></tr>
<tr><td><code>recode</code></td>
<td>
<p>an integer vector satisfying
<code>length(recode) == nrow(redata)</code>
specifying the families corresponding to the dependence groups.
This requires </p>
<pre>all(recode %in% seq(along = families)</pre>
<p>Node <code>j</code> is in a dependence group
with family described by <code>families[recode[j]]</code>.
</p>
<p>Note that <code>regroup[j] == k</code>
requires <code>recode[j] == recode[k]</code> when <code>regroup[j] != 0</code>.
Also note that
<code>recode</code> is determined by <code>code</code> but is different from
it.  Firstly, the lengths differ.  Secondly, <code>recode</code> need not be
just a repetition of <code>code</code>.
This function always makes <code>recode</code>
equal to <code>rep(code, each = nrow(redata))</code> but the more general
description
above is valid for objects of class <code>"asterdata"</code> constructed
&ldquo;by hand&rdquo;.</p>
</td></tr>
<tr><td><code>families</code></td>
<td>
<p>a copy of the argument of the same name of this function
except that any character string abbreviations are converted to objects
of class <code>"astfam"</code>.</p>
</td></tr>
<tr><td><code>redelta</code></td>
<td>
<p>a numeric vector satisfying
<code>length(redelta) == nrow(redata)</code>
specifying the degeneracies of the aster model for all individuals.
If not the zero vector, the degenerate model
specified is the limit as <code class="reqn">s \to \infty</code> of
nondegenerate models having conditional canonical parameter vector
<code class="reqn">\theta + s \delta</code> (note that the conditional
canonical parameter vector is always used here, regardless of whether
conditional or unconditional canonical affine submodels are to be used).
</p>
<p>Note that
<code>redelta</code> is determined by <code>delta</code> but is different from
it.  Firstly, the lengths differ.  Secondly, <code>redelta</code> need not be
just a repetition of <code>delta</code>.
This function always makes <code>redelta</code>
equal to <code>rep(delta, each = nrow(redata))</code> but the more general
description
above is valid for objects of class <code>"asterdata"</code> constructed
&ldquo;by hand&rdquo;.</p>
</td></tr>
<tr><td><code>response.name</code></td>
<td>
<p>a character string giving the name of the response
variable in <code>redata</code>.  For this function, a copy of the argument
<code>response.name</code>.</p>
</td></tr>
<tr><td><code>varb.name</code></td>
<td>
<p>a character string giving the name of the &ldquo;varb&rdquo;
variable in <code>redata</code>.  For this function, a copy of the argument
<code>varb.name</code>.</p>
</td></tr>
</table>
<p>In addition an object of class <code>"asterdata"</code> may contain (and those
constructed by this function do contain) components
<code>pred</code>, <code>group</code>, and <code>code</code>,
which are copies of the arguments of the same names of this function.
Objects of class <code>"asterdata"</code> not constructed by this function need
not contain these additional components, since they may make no sense if
the graph for all individuals is not the repetition of isomorphic subgraphs,
one for each individual.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+families">families</a></code> and <code><a href="#topic+subset.asterdata">subset.asterdata</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(test1)
fred &lt;- asterdata(test1, vars = c("m1", "n1", "n2"), pred = c(0, 1, 1),
    group = c(0, 0, 2), code = c(1, 2, 2),
    families = list("bernoulli", "normal.location.scale"))
is.validasterdata(fred)
</code></pre>

<hr>
<h2 id='constancy'>Constancy Spaces for Aster Models</h2><span id='topic+constancy'></span><span id='topic+is.same'></span>

<h3>Description</h3>

<p>Produce basis for constancy space of an aster model.
Test whether the difference of two canonical parameter vectors is
in the constancy space (so the two parameter vectors correspond
to the same probability model).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constancy(data, parm.type = c("theta", "phi"))
is.same(parm1, parm2, data, parm.type = c("theta", "phi"),
    tolerance = sqrt(.Machine$double.eps))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constancy_+3A_data">data</code></td>
<td>
<p>an object of class <code>"asterdata"</code> produced by
<code><a href="#topic+asterdata">asterdata</a></code> or &ldquo;by hand&rdquo; such that
<code>is.validasterdata(data)</code> returns <code>TRUE</code>.  The specification
of the aster model.</p>
</td></tr>
<tr><td><code id="constancy_+3A_parm.type">parm.type</code></td>
<td>
<p>the parametrization for which the constancy space is wanted.</p>
</td></tr>
<tr><td><code id="constancy_+3A_parm1">parm1</code></td>
<td>
<p>a parameter vector of the type specified by <code>parm.type</code>
for the saturated aster model specified by <code>data</code>.</p>
</td></tr>
<tr><td><code id="constancy_+3A_parm2">parm2</code></td>
<td>
<p>another parameter vector of the type specified
by <code>parm.type</code> for the saturated aster model specified
by <code>data</code>.</p>
</td></tr>
<tr><td><code id="constancy_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric &gt;= 0.  Relative errors smaller
than <code>tolerance</code> are not considered in the comparison.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is no need for functions to test whether different mean value parameters
(<code class="reqn">\xi</code> or <code class="reqn">\mu</code>) correspond to the same probability
distribution because these parametrizations are identifiable (different valid
parameter vectors correspond to different probability distributions).
</p>


<h3>Value</h3>

<p>for <code>is.same</code> a logical value;
for <code>constancy</code>
a matrix whose rows constitute a basis for the constancy space.
This means that if <code class="reqn">\delta</code> is a linear combination of rows
of this matrix then for all real <code class="reqn">s</code> the distributions having parameter
vectors <code class="reqn">\psi</code> and <code class="reqn">\psi + s \delta</code> are the
same, where <code class="reqn">\psi = \theta</code>
or <code class="reqn">\psi = \varphi</code> depending on whether
<code>parm.type = "theta"</code> or <code>parm.type = "phi"</code>.
Conversely, if <code class="reqn">\psi_1</code> and <code class="reqn">\psi_2</code> are valid parameter
vectors of the same type, then they correspond to the same probability
distribution only if <code class="reqn">\psi_1 - \psi_2</code> is a linear
combination of rows of this matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asterdata">asterdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(test1)
fred &lt;- asterdata(test1,
    vars = c("m1", "m2", "m3", "n1", "n2", "b1", "p1", "z1"),
    pred = c(0, 0, 0, 1, 1, 2, 3, 6), group = c(0, 1, 2, 0, 4, 0, 0, 0),
    code = c(1, 1, 1, 2, 2, 3, 4, 5),
    families = list(fam.multinomial(3), "normal.location.scale",
    "bernoulli", "poisson", "zero.truncated.poisson"))
cmat &lt;- constancy(fred, parm.type = "phi")
</code></pre>

<hr>
<h2 id='cumulant'>Cumulant Functions for Aster Models</h2><span id='topic+cumulant'></span>

<h3>Description</h3>

<p>Calculate cumulant function and up to three derivatives for
families known to the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumulant(theta, fam, deriv = 0, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumulant_+3A_theta">theta</code></td>
<td>
<p>canonical parameter value.</p>
</td></tr>
<tr><td><code id="cumulant_+3A_fam">fam</code></td>
<td>
<p>an object of class <code>"astfam"</code> produced by one of
the family functions (see <code><a href="#topic+families">families</a></code>) specifying the
exponential family.</p>
</td></tr>
<tr><td><code id="cumulant_+3A_deriv">deriv</code></td>
<td>
<p>the number of derivatives wanted.  Must be nonnegative
integer less than or equal to three.</p>
</td></tr>
<tr><td><code id="cumulant_+3A_delta">delta</code></td>
<td>
<p>direction in which limit is taken.  Cumulant
function is for family that is limit of family specified, limit
being for distributions with parameter
<code class="reqn">\theta + s \delta</code>,
the limit being as <code class="reqn">s \to \infty</code>.  May be missing,
in which case <code class="reqn">\delta = 0</code> is assumed, which is the same
as no limit being taken.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing some of the following components:
</p>
<table>
<tr><td><code>zeroth</code></td>
<td>
<p>the value of the cumulant function at <code class="reqn">\theta</code>.</p>
</td></tr>
<tr><td><code>first</code></td>
<td>
<p>the value of the first derivative at <code class="reqn">\theta</code>, a
vector having the same dimension as <code class="reqn">\theta</code>.</p>
</td></tr>
<tr><td><code>second</code></td>
<td>
<p>the value of the second derivative at <code class="reqn">\theta</code>, a
<code class="reqn">d \times d</code> matrix if <code class="reqn">d</code> is the dimension
of <code class="reqn">\theta</code> or a scalar if <code class="reqn">\theta</code> is scalar.</p>
</td></tr>
<tr><td><code>third</code></td>
<td>
<p>the value of the third derivative at <code class="reqn">\theta</code>, a
<code class="reqn">d \times d \times d</code> array if <code class="reqn">d</code> is the dimension
of <code class="reqn">\theta</code> or a scalar if <code class="reqn">\theta</code> is scalar.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Not intended for use by ordinary users.  Provides R interface for testing
to C code called by many other functions in the package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+families">families</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cumulant(-0.5, fam.bernoulli(), deriv = 3)
cumulant(-0.5, fam.bernoulli(), deriv = 3, delta = 1)
</code></pre>

<hr>
<h2 id='echinacea'>Life History Data on Echinacea angustifolia</h2><span id='topic+echinacea'></span>

<h3>Description</h3>

<p>Data on life history traits for the purple coneflower
<em>Echinacea angustifolia</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(echinacea)</code></pre>


<h3>Format</h3>

<p>An object of class <code>"asterdata"</code> (see <code><a href="#topic+asterdata">asterdata</a></code>)
comprising  records for 570 plants observed over three years.
Nodes of the graph for one individual are associated with the variables
(levels of the factor <code>echinacea$redata$varb</code>)
</p>

<dl>
<dt>ld02</dt><dd><p>Indicator of being alive in 2002.  Bernoulli,
predecessor the constant one.</p>
</dd>
<dt>ld03</dt><dd><p>Ditto for 2003.  Bernoulli, predecessor <code>ld02</code>.</p>
</dd>
<dt>ld04</dt><dd><p>Ditto for 2004.  Bernoulli, predecessor <code>ld03</code>.</p>
</dd>
<dt>fl02</dt><dd><p>Indicator of flowering 2002.  Bernoulli,
predecessor <code>ld02</code>.</p>
</dd>
<dt>fl03</dt><dd><p>Ditto for 2003.  Bernoulli, predecessor <code>ld03</code>.</p>
</dd>
<dt>fl04</dt><dd><p>Ditto for 2004.  Bernoulli, predecessor <code>ld04</code>.</p>
</dd>
<dt>hdct02</dt><dd><p>Count of number of flower heads in 2002.
Zero-truncated Poisson, predecessor <code>fl02</code>.</p>
</dd>
<dt>hdct03</dt><dd><p>Ditto for 2003.
Zero-truncated Poisson, predecessor <code>fl03</code>.</p>
</dd>
<dt>hdct04</dt><dd><p>Ditto for 2004.
Zero-truncated Poisson, predecessor <code>fl04</code>.</p>
</dd>
</dl>

<p>Covariates are
</p>

<dl>
<dt>pop</dt><dd><p>the remnant population of origin of the plant
(all plants were grown together, <code>pop</code> encodes ancestry).</p>
</dd>
<dt>ewloc</dt><dd><p>east-west location in plot.</p>
</dd>
<dt>nsloc</dt><dd><p>north-south location in plot.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This is the data for the example in Geyer, Wagenius, and Shaw (2007).
These data were included in the R package <code>aster</code> which was the
predecessor of this package as the dataset <code>echinacea</code>.
</p>


<h3>Source</h3>

<p>Stuart Wagenius,
<a href="http://www.chicagobotanic.org/research/staff/wagenius">http://www.chicagobotanic.org/research/staff/wagenius</a>
</p>


<h3>References</h3>

<p>Geyer, C. J., Wagenius, S., and Shaw, R. G. (2007)
Aster Models for Life History Analysis.
<em>Biometrika</em> <b>94</b> 415&ndash;426.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(echinacea)
names(echinacea)
names(echinacea$redata)
levels(echinacea$redata$varb)
</code></pre>

<hr>
<h2 id='families'>Families for Aster Models</h2><span id='topic+families'></span><span id='topic+fam.bernoulli'></span><span id='topic+fam.poisson'></span><span id='topic+fam.zero.truncated.poisson'></span><span id='topic+fam.normal.location.scale'></span><span id='topic+fam.multinomial'></span>

<h3>Description</h3>

<p>Families known to the package.
These functions construct simple family specifications used
in specifying aster models.  Statistical properties of these families
are described.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fam.bernoulli()
fam.poisson()
fam.zero.truncated.poisson()
fam.normal.location.scale()
fam.multinomial(dimension)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="families_+3A_dimension">dimension</code></td>
<td>
<p>the dimension (number of categories) for the multinomial
distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently implemented families are
</p>

<dl>
<dt><code>"bernoulli"</code></dt><dd><p>Bernoulli (binomial with sample size one).
The distribution of any
zero-or-one-valued random variable <code class="reqn">Y</code>, which is the canonical
statistic.  The mean value parameter is
</p>
<p style="text-align: center;"><code class="reqn">\mu = E(Y) = \Pr(Y = 1).</code>
</p>

<p>The canonical parameter is
<code class="reqn">\theta = \log(\mu) - \log(1 - \mu)</code>,
also called logit of <code class="reqn">\mu</code>.  The cumulant function is
</p>
<p style="text-align: center;"><code class="reqn">c(\theta) = \log(1 + e^\theta).</code>
</p>

<p>This distribution has degenerate limiting distributions.  The lower
limit as <code class="reqn">\theta \to - \infty</code> is the
distribution concentrated at zero, having cumulant function which
is the constant function everywhere equal to zero.  The upper
limit as <code class="reqn">\theta \to + \infty</code> is the
distribution concentrated at one, having cumulant function which
is the identity function satisfying
<code class="reqn">c(\theta) = \theta</code> for all <code class="reqn">\theta</code>.
</p>
<p>For predecessor (sample size) <code class="reqn">n</code>, the successor is the sum of
<code class="reqn">n</code> independent and identically distributed (IID) Bernoulli
random variables, that is,
binomial with sample size <code class="reqn">n</code>.  The mean value parameter is <code class="reqn">n</code>
times the mean value parameter for sample size one; the cumulant function
is <code class="reqn">n</code> times the cumulant function for sample size one; the canonical
parameter is the same for all sample sizes.</p>
</dd>
<dt><code>"poisson"</code></dt><dd><p>Poisson.  The mean value parameter
<code class="reqn">\mu</code> is the mean of the Poisson distribution.
The canonical parameter is <code class="reqn">\theta = \log(\mu)</code>.
The cumulant function is
</p>
<p style="text-align: center;"><code class="reqn">c(\theta) = e^\theta.</code>
</p>

<p>This distribution has a degenerate limiting distribution.  The lower
limit as <code class="reqn">\theta \to - \infty</code> is the
distribution concentrated at zero, having cumulant function which
is the constant function everywhere equal to zero.  There is no upper
limit because the canonical statistic is unbounded above.
</p>
<p>For predecessor (sample size) <code class="reqn">n</code>, the successor is the sum of
<code class="reqn">n</code> IID Poisson random variables, that is,
Poisson with mean <code class="reqn">n \mu</code>.  The mean value parameter is <code class="reqn">n</code>
times the mean value parameter for sample size one; the cumulant function
is <code class="reqn">n</code> times the cumulant function for sample size one; the canonical
parameter is the same for all sample sizes.</p>
</dd>
<dt><code>"zero.truncated.poisson"</code></dt><dd><p>Poisson conditioned on being
greater than zero.  Let <code class="reqn">m</code> be the mean of the corresponding
untruncated Poisson distribution.  Then the canonical parameters for both
truncated and untruncated distributions are the same
<code class="reqn">\theta = \log(m)</code>.
The mean value parameter for the zero-truncated Poisson distribution is
</p>
<p style="text-align: center;"><code class="reqn">\mu = \frac{m}{1 - e^{- m}}</code>
</p>

<p>and the cumulant function is
</p>
<p style="text-align: center;"><code class="reqn">c(\theta) = m + \log(1 - e^{- m}),</code>
</p>

<p>where <code class="reqn">m</code> is as defined above,
so <code class="reqn">m = e^\theta</code>.
</p>
<p>This distribution has a degenerate limiting distribution.  The lower
limit as <code class="reqn">\theta \to - \infty</code> is the
distribution concentrated at one, having cumulant function which
is the identity function satisfying
<code class="reqn">c(\theta) = \theta</code> for all <code class="reqn">\theta</code>.
There is no upper
limit because the canonical statistic is unbounded above.
</p>
<p>For predecessor (sample size) <code class="reqn">n</code>, the successor is the sum of
<code class="reqn">n</code> IID zero-truncated Poisson random variables, which is not
a brand-name distribution.  The mean value parameter is <code class="reqn">n</code>
times the mean value parameter for sample size one; the cumulant function
is <code class="reqn">n</code> times the cumulant function for sample size one; the canonical
parameter is the same for all sample sizes.</p>
</dd>
<dt><code>"normal.location.scale"</code></dt><dd><p>The distribution of a normal
random variable <code class="reqn">X</code> with unknown mean <code class="reqn">m</code> and unknown variance
<code class="reqn">v</code>.  Thought of as an exponential family, this is
a two-parameter family, hence must have a two-dimensional canonical
statistic <code class="reqn">Y = (X, X^2)</code>.  The canonical parameter
vector <code class="reqn">\theta</code> has components
</p>
<p style="text-align: center;"><code class="reqn">\theta_1 = \frac{m}{v}</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\theta_2 = - \frac{1}{2 v}.</code>
</p>

<p>The value of <code class="reqn">\theta_1</code> is unrestricted, but
<code class="reqn">\theta_2</code> must be strictly negative.
The mean value parameter vector <code class="reqn">\mu</code> has components
</p>
<p style="text-align: center;"><code class="reqn">\mu_1 = m = - \frac{\theta_1}{2 \theta_2}</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\mu_2 = v + m^2 = - \frac{1}{2 \theta_2} + \frac{\theta_1^2}{4 \theta_2^2}.</code>
</p>

<p>The cumulant function is
</p>
<p style="text-align: center;"><code class="reqn">c(\theta) = - \frac{\theta_1^2}{4 \theta_2} + \frac{1}{2} \log\left(- \frac{1}{2 \theta_2}\right).</code>
</p>

<p>This distribution has no degenerate limiting distributions, because
the canonical statistic is a continuous random vector so the boundary
of its support has probability zero.
</p>
<p>For predecessor (sample size) <code class="reqn">n</code>, the successor is the sum of
<code class="reqn">n</code> IID random vectors <code class="reqn">(X_i, X_i^2)</code>,
where each <code class="reqn">X_i</code> is normal
with mean <code class="reqn">m</code> and variance <code class="reqn">v</code>, and this is not
a brand-name multivariate distribution (the first component of the sum
is normal, the second component noncentral chi-square, and the
components are not independent).
The mean value parameter vector is <code class="reqn">n</code>
times the mean value parameter vector for sample size one;
the cumulant function
is <code class="reqn">n</code> times the cumulant function for sample size one; the canonical
parameter vector is the same for all sample sizes.</p>
</dd>
<dt><code>"multinomial"</code></dt><dd><p>Multinomial with sample size one.
The distribution of any random vector <code class="reqn">Y</code> having all components zero
except for one component which is one (<code class="reqn">Y</code> is the
canonical statistic vector).
The mean value parameter is the vector <code class="reqn">\mu = E(Y)</code> having
components
</p>
<p style="text-align: center;"><code class="reqn">\mu_i = E(Y_i) = \Pr(Y_i = 1).</code>
</p>

<p>The mean value parameter vector <code class="reqn">\mu</code> is given as a function
of the canonical parameter vector <code class="reqn">\theta</code> by
</p>
<p style="text-align: center;"><code class="reqn">\mu_i = \frac{e^{\theta_i}}{\sum_{j = 1}^d e^{\theta_j}},</code>
</p>

<p>where <code class="reqn">d</code> is the dimension of <code class="reqn">Y</code> and <code class="reqn">\theta</code>
and <code class="reqn">\mu</code>.  This transformation is not one-to-one;
adding the same number
to each component of <code class="reqn">\theta</code> does not change the value
of <code class="reqn">\mu</code>.
The cumulant function is
</p>
<p style="text-align: center;"><code class="reqn">c(\theta) = \log\left(\sum_{j = 1}^d e^{\theta_j}\right).</code>
</p>

<p>This distribution is degenerate.  The sum of the components of the
canonical statistic is equal to one with probability
one, which implies the nonidentifiability of the <code class="reqn">d</code>-dimensional
canonical parameter vector mentioned above.  Hence one parameter
(at least) is always constrained to to be zero in
fitting an aster model with a multinomial family.
</p>
<p>This distribution has many degenerate distributions.  For any vector
<code class="reqn">\delta</code> the limit of distributions having canonical
parameter vectors <code class="reqn">\theta + s \delta</code> as
<code class="reqn">s \to \infty</code> exists and is another
multinomial distribution (the limit distribution in the direction
<code class="reqn">\delta</code>).
Let <code class="reqn">A</code> be the set of <code class="reqn">i</code> such that 
<code class="reqn">\delta_i = \max(\delta)</code>,
where <code class="reqn">\max(\delta)</code> denotes the maximum over the
components of <code class="reqn">\delta</code>.
Then the limit distribution in the direction <code class="reqn">\delta</code>
has components <code class="reqn">Y_i</code> of the canonical statistic
for <code class="reqn">i \notin A</code> concentrated at zero.
The cumulant function of this degenerate distribution is
</p>
<p style="text-align: center;"><code class="reqn">c(\theta) = \log\left(\sum_{j \in A} e^{\theta_j}\right).</code>
</p>

<p>The canonical parameters <code class="reqn">\theta_j</code> for <code class="reqn">j \notin A</code> are not identifiable, and one other canonical parameter is not
identifiable because of the constraint that the sum of the components
of the canonical statistic is equal to one with probability one.
</p>
<p>For predecessor (sample size) <code class="reqn">n</code>, the successor is the sum of
<code class="reqn">n</code> IID multinomial-sample-size-one random vectors, that is,
multinomial with sample size <code class="reqn">n</code>.  The mean value parameter is <code class="reqn">n</code>
times the mean value parameter for sample size one; the cumulant function
is <code class="reqn">n</code> times the cumulant function for sample size one; the canonical
parameter is the same for all sample sizes.</p>
</dd>
</dl>



<h3>Value</h3>

<p>a list of class <code>"astfam"</code> giving name and values of any
hyperparameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fam.bernoulli()
fam.multinomial(4)
</code></pre>

<hr>
<h2 id='hornworm'>Life History Data on Manduca sexta</h2><span id='topic+hornworm'></span>

<h3>Description</h3>

<p>Data on life history traits for the tobacco hornworm
<em>Manduca sexta</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hornworm)</code></pre>


<h3>Format</h3>

<p>An object of class <code>"asterdata"</code> (see <code><a href="#topic+asterdata">asterdata</a></code>)
comprising records for 162 insects (54 female, 68 male, and 40 for which
there was no opportunity to determine sex) observed over 40 days.
Nodes of the graph for one individual are associated with the variables
(levels of the factor <code>hornworm$redata$varb</code>) in dependence groups
</p>

<dl>
<dt>P</dt><dd><p>Bernoulli.  Predecessor 1 (initial node).  Indicator of pupation.</p>
</dd>
<dt>T330, T331, T332</dt><dd><p>Three-dimensional multinomial dependence group.
Predecessor <code>P</code>.</p>
</dd>
</dl>

<dl>
<dt>T330</dt><dd><p>Indicator of death after pupation.  In these data,
all deaths after pupation are considered to have happened on
day 33 regardless of when they occurred (because the actual
day of death was not recorded in the original data).</p>
</dd>
<dt>T331</dt><dd><p>Indicator of survival to day 33 but still pre-eclosion.</p>
</dd>
<dt>T332</dt><dd><p>Indicator of eclosion (emergence from pupa as adult moth
on day 33.</p>
</dd>
</dl>

<dl>
<dt>B33</dt><dd><p>Zero-truncated Poisson.  Predecessor <code>T332</code>.
Count of ovarioles on day 33.  Only females have this node in their
graphs.</p>
</dd>
<dt>Tx1, Tx2</dt><dd><p>For <code>x</code> = 34, ..., 40. Two-dimensional multinomial
dependence group.  Predecessor <code>Tw1</code>, where <code>w = x - 1</code>.</p>
</dd>
</dl>

<dl>
<dt>Tx1</dt><dd><p>Indicator of survival to day <code>x</code> but still
pre-eclosion.</p>
</dd>
<dt>Tx2</dt><dd><p>Indicator of eclosion (emergence from pupa as adult moth
on day <code>x</code>.</p>
</dd>
</dl>

<dl>
<dt>Bx</dt><dd><p>Zero-truncated Poisson.  Predecessor <code>Tx2</code>.
Count of ovarioles on day <code>x</code>.  Only females have these nodes in
their graph.</p>
</dd>
</dl>

<p>Covariates are
</p>

<dl>
<dt>Sex</dt><dd><p>a factor.  <code>F</code> is known female, <code>M</code> is known male,
<code>U</code> is unknown (no opportunity to observe).</p>
</dd>
<dt>Time_2nd</dt><dd><p>time (in weeks) to reach the 2nd instar stage.  Larval
instars are stages between molts (shedding of exoskeleton) of the larval
form (caterpillar).</p>
</dd>
<dt>Mass_2nd</dt><dd><p>mass (in grams) at the 2nd instar stage.</p>
</dd>
<dt>Mass_Repro</dt><dd><p>mass (in grams) at eclosion.</p>
</dd>
<dt>LarvaID</dt><dd><p>name of an individual in the original data.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This is the data described by and analyzed by non-aster methods by
Kingsolver et al. (2012) and re-analyzed using this package by Eck et al.
(submitted).
</p>
<p>For an illustration of the graph, see Figure 1 in Eck et al. (submitted).
</p>
<p>In the description above, a concrete example of the <code>x</code> and <code>w</code>
notation is that T351 and T352 form a two-dimensional multinomial dependence
group, the predecessor of which is T341, and B35 is a dependence group all
by itself, its predecessor being T352.
</p>
<p>Every multinomial dependence group acts like a switch.  If the predecessor
is one, the dependence group is multinomial with sample size one (exactly
one variable is one and the rest are zero).  So this indicates which way
the life history goes.  If the predecessor is zero, then all successors are
zero.  This goes for all variables in any aster model.  If <code>Tx2</code> is zero,
then so is <code>Bx</code>.  The ovariole count is zero except for the day on
which the individual eclosed.
</p>


<h3>Source</h3>

<p>Joel Kingsolver
<a href="http://bio.unc.edu/people/faculty/kingsolver/">http://bio.unc.edu/people/faculty/kingsolver/</a>
</p>


<h3>References</h3>

<p>Kingsolver, J. G., Diamond, S. E., Seiter, S. A., and Higgins, J. K. (2012)
Direct and indirect phenotypic selection on developmental trajectories
in <em>Manduca sexta</em>.
<em>Functional Ecology</em> <b>26</b> 598&ndash;607.
</p>
<p>Eck, D., Shaw, R. G., Geyer, C. J., and Kingsolver, J. (submitted)
An integrated analysis of phenotypic selection on insect body size
and development time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hornworm)
names(hornworm)
names(hornworm$redata)
levels(hornworm$redata$varb)
</code></pre>

<hr>
<h2 id='link'>Link Functions for Aster Models</h2><span id='topic+link'></span>

<h3>Description</h3>

<p>Calculate link function and up to one derivative for
families known to the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>link(xi, fam, deriv = 0, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="link_+3A_xi">xi</code></td>
<td>
<p>mean value parameter value, a numeric vector.</p>
</td></tr>
<tr><td><code id="link_+3A_fam">fam</code></td>
<td>
<p>an object of class <code>"astfam"</code> produced by one of
the family functions (see <code><a href="#topic+families">families</a></code>) specifying the
exponential family.</p>
</td></tr>
<tr><td><code id="link_+3A_deriv">deriv</code></td>
<td>
<p>the number of derivatives wanted.  Must be either
zero or one.</p>
</td></tr>
<tr><td><code id="link_+3A_delta">delta</code></td>
<td>
<p>direction in which limit is taken.  Link
function is for family that is limit of family specified, limit
being for distributions with canonical parameter
<code class="reqn">\theta + s \delta</code>,
the limit being as <code class="reqn">s \to \infty</code>.  May be missing,
in which case <code class="reqn">\delta = 0</code> is assumed, which is the same
as no limit being taken.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing some of the following components:
</p>
<table>
<tr><td><code>zeroth</code></td>
<td>
<p>the value of the link function at <code class="reqn">\xi</code>, a vector
of dimension <code class="reqn">d</code>, where <code class="reqn">d</code></p>
</td></tr></table>
<p> is the dimension of <code class="reqn">\xi</code>.
</p>
<table>
<tr><td><code>first</code></td>
<td>
<p>the value of the first derivative at <code class="reqn">\xi</code>, a
<code class="reqn">d \times d</code> matrix, where <code class="reqn">d</code> is the dimension
of <code class="reqn">\xi</code> or a scalar if <code class="reqn">\xi</code> is scalar.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Not intended for use by ordinary users.  Provides R interface for testing
to C code called by many other functions in the package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+families">families</a></code> and <code><a href="#topic+cumulant">cumulant</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>link(0.3, fam.bernoulli(), deriv = 1)
link(0.3, fam.bernoulli(), deriv = 1, delta = 1)
</code></pre>

<hr>
<h2 id='subset.asterdata'>Subset Object Describing Saturated Aster Model</h2><span id='topic+subset.asterdata'></span>

<h3>Description</h3>

<p>Subset an object of class <code>"asterdata"</code>,
for which see <code><a href="#topic+asterdata">asterdata</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asterdata'
subset(x, subset, successors = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.asterdata_+3A_x">x</code></td>
<td>
<p>an object of class <code>"asterdata"</code>, for which see
<code><a href="#topic+asterdata">asterdata</a></code>.</p>
</td></tr>
<tr><td><code id="subset.asterdata_+3A_subset">subset</code></td>
<td>
<p>a logical vector indicating nodes of the graph to keep:
missing values are taken as false.</p>
</td></tr>
<tr><td><code id="subset.asterdata_+3A_successors">successors</code></td>
<td>
<p>a logical scalar indicating whether the subgraph must be
a union of connected components of the original graph, that is, if all
successors of nodes in the subset must also be in the subset.</p>
</td></tr>
<tr><td><code id="subset.asterdata_+3A_...">...</code></td>
<td>
<p>further arguments, which are ignored (this argument is required
for methods of the generic function <code><a href="base.html#topic+subset">subset</a></code> but is not used
for this method.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>subset</code> is a logical vector of the same length as the number
of nodes in the graph specified by argument <code>x</code>.  It indicates the
subset of nodes in the subgraph wanted.  The subgraph must be closed with
respect to predecessors (all predecessors of nodes in the subset are also
in the subset) and if <code>successors = TRUE</code> with respect
to successors (all successors of nodes in the subset are also in the subset).
And similarly for dependence groups: each dependence
group in the original graph must have all or none of its elements
in the subgraph.
</p>


<h3>Value</h3>

<p>an object of class <code>"asterdata"</code> that represents the aster model having
subgraph with nodes specified by <code>subset</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asterdata">asterdata</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(echinacea)
#### select one individual from each level of pop
foo &lt;- echinacea$redata$pop
bar &lt;- match(levels(foo), as.character(foo))
baz &lt;- is.element(echinacea$redata$id, echinacea$redata$id[bar])
out &lt;- subset(echinacea, baz)
</code></pre>

<hr>
<h2 id='test1'>Test Data</h2><span id='topic+test1'></span>

<h3>Description</h3>

<p>Test data of no biological interest.  Does have all families
implemented at the time the test data was created.  No predictor variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(test1)</code></pre>


<h3>Format</h3>

<p>A data frame with 100 observations on the following 8 variables.
</p>

<dl>
<dt><code>m1</code></dt><dd><p>a numeric vector, part of a multinomial dependence group
(with <code>m2</code> and <code>m3</code>).  Predecessor of this group is the
constant 1.</p>
</dd>
<dt><code>m2</code></dt><dd><p>a numeric vector.</p>
</dd>
<dt><code>m3</code></dt><dd><p>a numeric vector.</p>
</dd>
<dt><code>n1</code></dt><dd><p>a numeric vector, part of a normal location-scale
dependence group (with <code>n2</code>).  Predecessor of this group
is <code>m1</code>.</p>
</dd>
<dt><code>n2</code></dt><dd><p>a numeric vector (actually <code>n1^2</code>).</p>
</dd>
<dt><code>b1</code></dt><dd><p>a numeric vector, Bernoulli.  Predecessor is <code>m2</code>.</p>
</dd>
<dt><code>p1</code></dt><dd><p>a numeric vector, Poisson.  Predecessor is <code>m3</code>.</p>
</dd>
<dt><code>z1</code></dt><dd><p>a numeric vector, zero-truncated Poisson.  Predecessor
is <code>b1</code>.</p>
</dd>
</dl>



<h3>Source</h3>

<p>created by R script <code>test1.R</code> in directory <code>makedata</code> of the
installation directory for this package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(test1)
fred &lt;- asterdata(test1,
    vars = c("m1", "m2", "m3", "n1", "n2", "b1", "p1", "z1"),
    pred = c(0, 0, 0, 1, 1, 2, 3, 6), group = c(0, 1, 2, 0, 4, 0, 0, 0),
    code = c(1, 1, 1, 2, 2, 3, 4, 5),
    families = list(fam.multinomial(3), "normal.location.scale",
    "bernoulli", "poisson", "zero.truncated.poisson"))
</code></pre>

<hr>
<h2 id='Transform'>Change-of-Parameter Functions for Aster Models</h2><span id='topic+Transform'></span><span id='topic+transformSaturated'></span><span id='topic+transformConditional'></span><span id='topic+transformUnconditional'></span><span id='topic+jacobian'></span><span id='topic+validtheta'></span><span id='topic+is.validtheta'></span><span id='topic+validxi'></span><span id='topic+is.validxi'></span>

<h3>Description</h3>

<p>Calculate a change-of-parameter for a saturated aster model or the
derivative of such a change-of-parameter.  Validate certain parameter vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformSaturated(parm, data, from = c("theta", "phi", "xi", "mu"),
  to = c("theta", "phi", "xi", "mu"), differential,
  model.type = c("unconditional", "conditional"),
  tolerance = 8 * .Machine$double.eps)
transformConditional(parm, modmat, data, from = "beta",
  to = c("theta", "phi", "xi", "mu"), differential,
  offset, tolerance = 8 * .Machine$double.eps)
transformUnconditional(parm, modmat, data, from = c("beta", "tau"),
  to = c("beta", "theta", "phi", "xi", "mu", "tau"),
  differential, offset, tolerance = 8 * .Machine$double.eps)
jacobian(parm, data,
    transform = c("saturated", "conditional", "unconditional"),
    from = c("beta", "theta", "phi", "xi", "mu", "tau"),
    to = c("beta", "theta", "phi", "xi", "mu", "tau"),
    modmat, offset, tolerance = 8 * .Machine$double.eps)
validtheta(data, theta, model.type = c("unconditional", "conditional"),
    tolerance = 8 * .Machine$double.eps)
is.validtheta(data, theta, model.type = c("unconditional", "conditional"),
    tolerance = 8 * .Machine$double.eps)
validxi(data, xi, model.type = c("unconditional", "conditional"),
    tolerance = 8 * .Machine$double.eps)
is.validxi(data, xi, model.type = c("unconditional", "conditional"),
    tolerance = 8 * .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Transform_+3A_parm">parm</code></td>
<td>
<p>parameter vector to transform,
a numerical vector of length <code>nrow(data$redata)</code>
for <code>transformSaturated</code> or of length <code>ncol(modmat)</code>
for <code>transformConditional</code> and <code>transformUnconditional</code>.</p>
</td></tr>
<tr><td><code id="Transform_+3A_data">data</code></td>
<td>
<p>an object of class <code>"asterdata"</code> produced by
<code><a href="#topic+asterdata">asterdata</a></code> or &ldquo;by hand&rdquo; such that
<code>is.validasterdata(data)</code> returns <code>TRUE</code>.  The specification
of the aster model.</p>
</td></tr>
<tr><td><code id="Transform_+3A_from">from</code></td>
<td>
<p>the kind of parameter which <code>parm</code> is.  May be abbreviated.</p>
</td></tr>
<tr><td><code id="Transform_+3A_to">to</code></td>
<td>
<p>the kind of parameter to which <code>parm</code> is to be converted.
May be abbreviated.</p>
</td></tr>
<tr><td><code id="Transform_+3A_differential">differential</code></td>
<td>
<p>if not missing a numeric vector of the same length
as <code>parm</code>.  If missing the change-of-parameter is calculated.
If not missing the directional derivative of the change-of-parameter
is calculated (see Details section).</p>
</td></tr>
<tr><td><code id="Transform_+3A_modmat">modmat</code></td>
<td>
<p>the model matrix for a canonical affine submodel, a
numerical matrix having <code>nrow(data$redata)</code> rows
and <code>length(beta)</code> columns for <code>transformConditional</code>
or <code>length(parm)</code> columns for <code>transformUnconditional</code>.</p>
</td></tr>
<tr><td><code id="Transform_+3A_offset">offset</code></td>
<td>
<p>the offset vector for a canonical affine submodel, a
a numerical vector of length <code>nrow(data$redata)</code>.  May be missing,
in which case offset vector equal to zero is used.</p>
</td></tr>
<tr><td><code id="Transform_+3A_theta">theta</code></td>
<td>
<p>conditional canonical parameter vector to validate,
a numerical vector of length <code>nrow(data$redata)</code>.</p>
</td></tr>
<tr><td><code id="Transform_+3A_xi">xi</code></td>
<td>
<p>conditional canonical parameter vector to validate,
a numerical vector of length <code>nrow(data$redata)</code>.</p>
</td></tr>
<tr><td><code id="Transform_+3A_model.type">model.type</code></td>
<td>
<p>which kind of model (see Details section).
May be abbreviated.</p>
</td></tr>
<tr><td><code id="Transform_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric &gt;= 0.  Relative errors smaller
than <code>tolerance</code> are not considered in checking validity
of <code>xi</code> for multinomial data.</p>
</td></tr>
<tr><td><code id="Transform_+3A_transform">transform</code></td>
<td>
<p>the &ldquo;transform&rdquo; function that will be called to
calculate derivatives, e. g., <code>transform == "saturated"</code> means the
function <code>transformSaturated</code> will be called.  May be abbreviated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>differential</code> is missing, the returned value is a new parameter
vector of the specified type.  If <code>differential</code> is not missing,
the returned value is the derivative evaluated at <code>parm</code>
and <code>differential</code>, that is, if <code class="reqn">f</code> is the change-of variable
function and <code class="reqn">\psi</code> is the <code>from</code> parameter, then
<code class="reqn">f(\psi)</code> is calculated when the differential is missing and
<code class="reqn">f'(\psi)(\delta)</code> is calculated when the
differential <code class="reqn">\delta</code> is not missing, where the latter is defined by
</p>
<p style="text-align: center;"><code class="reqn">f(\psi + \delta) \approx f(\psi) + f'(\psi)(\delta)</code>
</p>
<p> for small <code class="reqn">\delta</code>.
</p>
<p>The kinds of parameters are <code>"theta"</code> the conditional canonical parameter
for the saturated model, <code>"phi"</code> the unconditional canonical parameter
for the saturated model, <code>"xi"</code> the conditional mean value parameter
for the saturated model, <code>"mu"</code> the unconditional mean value parameter
for the saturated model,
<code>"beta"</code> the regression coefficient parameter for a canonical affine
submodel (<code class="reqn">\theta = a + M \beta</code> for a conditional
canonical affine submodel or
<code class="reqn">\varphi = a + M \beta</code> for an unconditional
canonical affine submodel, where <code class="reqn">a</code> is the offset vector
and <code class="reqn">M</code> is the model matrix),
<code>"tau"</code> the mean value parameter for an unconditional canonical affine
submodel (<code class="reqn">\tau = M^T \mu</code>,
where <code class="reqn">M</code> is the model matrix).
</p>
<p>Only the conditional canonical parameter vector <code class="reqn">\theta</code> and
the conditional mean value parameter vector <code class="reqn">\xi</code> can be checked
directly.  (To check the validity of another parameter, transform to one
of these and check that.)  This means that in conversions to these parameters
the output vector is checked rather than the input vector, and conversions
(apparently) not involving these parameters (which do go through these
parameters inside the transformation function) a conversion to one of
these parameters is what is checked rather than the input vector.
</p>
<p>There is a difference between conditional and unconditional aster models
in the way they treat zero predecessors.  For a conditional aster model,
if the observed value of the predecessor is zero, then the successor is
zero almost surely and can have any parameter value for <code class="reqn">\theta</code>
or <code class="reqn">\xi</code>.  For an unconditional aster model,
if the expected value of the predecessor is zero, then the successor is
zero almost surely and can have any parameter value for <code class="reqn">\theta</code>
or <code class="reqn">\xi</code>.
</p>
<p>Since zero values are not allowed at initial nodes (not
considered valid by the function <code><a href="#topic+validasterdata">validasterdata</a></code>), the only
way predecessor data can be zero almost surely in an unconditional aster model
is if the delta vector (<code>data$redelta</code>) is not zero so we have a limiting
model.
</p>
<p>The function <code>jacobian</code> turns the derivative considered as
a linear transformation calculated by the &ldquo;transform&rdquo; functions
into the matrix that represents the linear transformation (sometimes
called the Jacobian matrix of the transformation).  The arguments
<code>modmat</code> and <code>offset</code> are only used if
<code>transform == "conditional"</code> or <code>transform == "unconditional"</code>,
and (as with the &ldquo;transform&rdquo; functions) the argument <code>offset</code>
may be missing, in which case the zero vector is used.  Not all of the
candidate values for <code>from</code> and <code>to</code> arguments
for the <code>jacobian</code> function are valid: the value must be valid for
the &ldquo;transform&rdquo; function that will be called.
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as <code>parm</code>.  The new parameter if
<code>deriv == FALSE</code> or the transform of the differential
if <code>deriv = TRUE</code>.  See details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asterdata">asterdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(echinacea)
theta &lt;- rnorm(nrow(echinacea$redata), 0, 0.1)
phi &lt;- transformSaturated(theta, echinacea, from = "theta", to = "phi")
## rarely (if ever) want jacobian for unsaturated model transform
## result here is 5130 by 5130 matrix
## Not run: jack &lt;- jacobian(theta, echinacea, from = "theta", to = "phi")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
