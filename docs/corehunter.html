<!DOCTYPE html><html><head><title>Help for package corehunter</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {corehunter}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#corehunter-package'><p>Core Hunter 3</p></a></li>
<li><a href='#coreHunterData'><p>Initialize Core Hunter data.</p></a></li>
<li><a href='#distances'><p>Create Core Hunter distance data from matrix or file.</p></a></li>
<li><a href='#evaluateCore'><p>Evaluate a core collection using the specified objective.</p></a></li>
<li><a href='#exampleData'><p>Small example dataset with 218 individuals.</p></a></li>
<li><a href='#genotypes'><p>Create Core Hunter genotype data from data frame, matrix or file.</p></a></li>
<li><a href='#getAlleleFrequencies'><p>Get Allele frequency matrix.</p></a></li>
<li><a href='#getNormalizationRanges'><p>Determine normalization ranges of all objectives in a multi-objective configuration.</p></a></li>
<li><a href='#objective'><p>Create Core Hunter objective.</p></a></li>
<li><a href='#phenotypes'><p>Create Core Hunter phenotype data from data frame or file.</p></a></li>
<li><a href='#read.autodelim'><p>Read delimited file.</p></a></li>
<li><a href='#sampleCore'><p>Sample a core collection.</p></a></li>
<li><a href='#setRange'><p>Set the normalization range of the given objective.</p></a></li>
<li><a href='#wrapData'><p>Wrap distances, genotypes or phenotypes in Core Hunter data.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Multi-Purpose Core Subset Selection</td>
</tr>
<tr>
<td>Version:</td>
<td>3.2.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-31</td>
</tr>
<tr>
<td>Description:</td>
<td>Core Hunter is a tool to sample diverse, representative subsets from large germplasm
    collections, with minimum redundancy. Such so-called core collections have applications in plant
    breeding and genetic resource management in general. Core Hunter can construct cores based on
    genetic marker data, phenotypic traits or precomputed distance matrices, optimizing one of many
    provided evaluation measures depending on the precise purpose of the core (e.g. high diversity,
    representativeness, or allelic richness). In addition, multiple measures can be simultaneously
    optimized as part of a weighted index to bring the different perspectives closer together.
    The Core Hunter library is implemented in Java 8 as an open source project (see
    <a href="http://www.corehunter.org">http://www.corehunter.org</a>).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.3), rJava (&ge; 0.9-8)</td>
</tr>
<tr>
<td>Imports:</td>
<td>naturalsort (&ge; 0.1.2), methods</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Java (&gt;= 8)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, mockr, StatMatch</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-01 14:10:30 UTC; herman.de.beukelaer</td>
</tr>
<tr>
<td>Author:</td>
<td>Herman De Beukelaer [aut, cre],
  Guy Davenport [aut],
  Veerle Fack [ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Herman De Beukelaer &lt;herman.debeukelaer@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-01 14:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='corehunter-package'>Core Hunter 3</h2><span id='topic+corehunter'></span><span id='topic+corehunter-package'></span>

<h3>Description</h3>

<p>Core Hunter is a tool to sample diverse, representative subsets from large germplasm
collections, with minimum redundancy. Such so-called core collections have applications in plant
breeding and genetic resource management in general. Core Hunter can construct cores based on
genetic marker data, phenotypic traits or precomputed distance matrices, optimizing one of many
provided evaluation measures depending on the precise purpose of the core (e.g. maximum diversity,
representativeness, or allelic richness). In addition, multiple measures can be simultaneously
optimized as part of a weighted index to bring the different perspectives closer together.
The Core Hunter library is implemented in Java 8 as an open source project
(see <a href="http://www.corehunter.org">http://www.corehunter.org</a>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Herman De Beukelaer <a href="mailto:herman.debeukelaer@gmail.com">herman.debeukelaer@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Guy Davenport <a href="mailto:daveneti@gmail.com">daveneti@gmail.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Veerle Fack <a href="mailto:veerle.fack@ugent.be">veerle.fack@ugent.be</a> [thesis advisor]
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+coreHunterData">coreHunterData</a></code>, <code><a href="#topic+genotypes">genotypes</a></code>,
<code><a href="#topic+phenotypes">phenotypes</a></code>, <code><a href="#topic+distances">distances</a></code>,
<code><a href="#topic+sampleCore">sampleCore</a></code>, <code><a href="#topic+evaluateCore">evaluateCore</a></code>,
<code><a href="#topic+objective">objective</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# sample core based on genetic marker data (default format)
geno.file &lt;- system.file("extdata", "genotypes.csv", package = "corehunter")
geno &lt;- genotypes(file = geno.file, format = "default")
core &lt;- sampleCore(geno)

# sample core based on genetic marker data (biparental format)
geno.file &lt;- system.file("extdata", "genotypes-biparental.csv", package = "corehunter")
geno &lt;- genotypes(file = geno.file, format = "biparental")
core &lt;- sampleCore(geno)

# sample core based on genetic marker data (frequency format)
geno.file &lt;- system.file("extdata", "genotypes-frequency.csv", package = "corehunter")
geno &lt;- genotypes(file = geno.file, format = "frequency")
core &lt;- sampleCore(geno)

# sample core based on phenotypic traits
pheno.file &lt;- system.file("extdata", "phenotypes.csv", package = "corehunter")
pheno &lt;- phenotypes(file = pheno.file)
core &lt;- sampleCore(pheno)

# sample core based on precomputed distance matrix
dist.file &lt;- system.file("extdata", "distances.csv", package = "corehunter")
dist &lt;- distances(file = dist.file)
core &lt;- sampleCore(dist)

# sample core from genotypes with custom objective (allelic richness)
core &lt;- sampleCore(geno, obj = objective("HE"))

# sample core from genotypes with custom size and objective (representativeness)
core &lt;- sampleCore(geno, obj = objective("AN", "MR"), size = 0.1)

# sample core from genotypes with custom size and stop condition
core &lt;- sampleCore(geno, size = 0.1, impr.time = 2)

# sample core based on both genotypes and phenotypes
geno.pheno &lt;- coreHunterData(geno, pheno)
core &lt;- sampleCore(geno.pheno)

## End(Not run)

</code></pre>

<hr>
<h2 id='coreHunterData'>Initialize Core Hunter data.</h2><span id='topic+coreHunterData'></span>

<h3>Description</h3>

<p>The data may contain genotypes, phenotypes and/or a precomputed distance matrix.
All provided data should describe the same individuals which is verified by comparing
the item ids and names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coreHunterData(genotypes, phenotypes, distances)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coreHunterData_+3A_genotypes">genotypes</code></td>
<td>
<p>Genetic marker data (<code>chgeno</code>).</p>
</td></tr>
<tr><td><code id="coreHunterData_+3A_phenotypes">phenotypes</code></td>
<td>
<p>Phenotypic trait data (<code>chpheno</code>).</p>
</td></tr>
<tr><td><code id="coreHunterData_+3A_distances">distances</code></td>
<td>
<p>Precomputed distance matrix (<code>chdist</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Core Hunter data (<code>chdata</code>) with elements
</p>

<dl>
<dt><code>geno</code></dt><dd><p>Genotype data of class <code>chgeno</code> if included.</p>
</dd>
<dt><code>pheno</code></dt><dd><p>Phenotype data of class <code>chpheno</code> if included.</p>
</dd>
<dt><code>dist</code></dt><dd><p>Distance data of class <code>chdist</code> if included.</p>
</dd>
<dt><code>size</code></dt><dd><p>Number of individuals in the dataset.</p>
</dd>
<dt><code>ids</code></dt><dd><p>Unique item identifiers.</p>
</dd>
<dt><code>names</code></dt><dd><p>Item names. Names of individuals to which no explicit name
has been assigned are equal to the unique <code>ids</code>.</p>
</dd>
<dt><code>java</code></dt><dd><p>Java version of the data object.</p>
</dd>
</dl>

<p>Core Hunter data of class <code>chdata</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genotypes">genotypes</a></code>, <code><a href="#topic+phenotypes">phenotypes</a></code>, <code><a href="#topic+distances">distances</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
geno.file &lt;- system.file("extdata", "genotypes.csv", package = "corehunter")
pheno.file &lt;- system.file("extdata", "phenotypes.csv", package = "corehunter")
dist.file &lt;- system.file("extdata", "distances.csv", package = "corehunter")

my.data &lt;- coreHunterData(
  genotypes(file = geno.file, format = "default"),
  phenotypes(file = pheno.file),
  distances(file = dist.file)
)

## End(Not run)

</code></pre>

<hr>
<h2 id='distances'>Create Core Hunter distance data from matrix or file.</h2><span id='topic+distances'></span>

<h3>Description</h3>

<p>Specify either a symmetric distance matrix or the file from which to read the matrix.
See <a href="https://www.corehunter.org">https://www.corehunter.org</a> for documentation and examples of the distance matrix
file format used by Core Hunter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distances(data, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distances_+3A_data">data</code></td>
<td>
<p>Symmetric distance matrix. Unique row and column headers are required,
should be the same and are used as item ids. Can be a <code>numeric</code> matrix or a data frame.
The data frame may optionally include a first column <code>NAME</code> used to assign names to some
or all individuals. The remaining columns should be <code>numeric</code>.</p>
</td></tr>
<tr><td><code id="distances_+3A_file">file</code></td>
<td>
<p>File from which to read the distance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Distance matrix data of class <code>chdist</code> with elements
</p>

<dl>
<dt><code>data</code></dt><dd><p>Distance matrix (<code>numeric</code> matrix).</p>
</dd>
<dt><code>size</code></dt><dd><p>Number of individuals in the dataset.</p>
</dd>
<dt><code>ids</code></dt><dd><p>Unique item identifiers.</p>
</dd>
<dt><code>names</code></dt><dd><p>Item names. Names of individuals to which no explicit name
has been assigned are equal to the unique <code>ids</code>.</p>
</dd>
<dt><code>java</code></dt><dd><p>Java version of the data object.</p>
</dd>
<dt><code>file</code></dt><dd><p>Normalized path of file from which data was read (if applicable).</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># create from distance matrix
m &lt;- matrix(runif(100), nrow = 10, ncol = 10)
diag(m) &lt;- 0
# make symmetric
m[lower.tri(m)] &lt;- t(m)[lower.tri(m)]
# set headers
rownames(m) &lt;- colnames(m) &lt;- paste("i", 1:10, sep = "-")

dist &lt;- distances(m)

# read from file
dist.file &lt;- system.file("extdata", "distances.csv", package = "corehunter")
dist &lt;- distances(file = dist.file)

</code></pre>

<hr>
<h2 id='evaluateCore'>Evaluate a core collection using the specified objective.</h2><span id='topic+evaluateCore'></span>

<h3>Description</h3>

<p>Evaluate a core collection using the specified objective.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluateCore(core, data, objective)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluateCore_+3A_core">core</code></td>
<td>
<p>A core collection of class <code>chcore</code>, or a
numeric or character vector indicating the indices or ids,
respectively, of the individuals in the evaluated core.</p>
</td></tr>
<tr><td><code id="evaluateCore_+3A_data">data</code></td>
<td>
<p>Core Hunter data (<code>chdata</code>) containing genotypes,
phenotypes and/or a precomputed distance matrix. Can also be an
object of class <code>chdist</code>, <code>chgeno</code> or <code>chpheno</code>
if only one type of data is provided.</p>
</td></tr>
<tr><td><code id="evaluateCore_+3A_objective">objective</code></td>
<td>
<p>Objective function (<code>chobj</code>) used to evaluate the core.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of the core when evaluated with the chosen objective (numeric).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coreHunterData">coreHunterData</a></code>, <code><a href="#topic+objective">objective</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- exampleData()
core &lt;- sampleCore(data, objective("EN", "PD"))
evaluateCore(core, data, objective("EN", "PD"))
evaluateCore(core, data, objective("AN", "MR"))
evaluateCore(core, data, objective("EE", "GD"))
evaluateCore(core, data, objective("CV"))
evaluateCore(core, data, objective("HE"))


</code></pre>

<hr>
<h2 id='exampleData'>Small example dataset with 218 individuals.</h2><span id='topic+exampleData'></span>

<h3>Description</h3>

<p>Data was genotyped using 190 SNP markers and 4 quantitative traits were recorded.
Includes a precomputed distance matrix read from <code>"extdata/distances.csv"</code>,
genotypes read from <code>"extdata/genotypes-biparental.csv"</code> and phenotypes read
from <code>"extdata/phenotypes.csv"</code>.
The distance matrix is computed from the genotypes (Modified Rogers' distance).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exampleData()
</code></pre>


<h3>Details</h3>

<p>Data was taken from the CIMMYT Research Data Repository (Study Global ID
hdl:11529/10199; real data set 5, cycle 0).
</p>


<h3>Value</h3>

<p>Core Hunter data of class <code>chdata</code>
</p>


<h3>Source</h3>

<p>Cerón-Rojas, J. Jesús ; Crossa, José; Arief, Vivi N.; Kaye Basford;
Rutkoski, Jessica; Jarquín, Diego ; Alvarado, Gregorio; Beyene, Yoseph;
Semagn, Kassa ; DeLacy, Ian, 2015-06-04, &quot;Application of a Genomics
Selection Index to Real and Simulated Data&quot;,
<a href="http://hdl.handle.net/11529/10199">http://hdl.handle.net/11529/10199</a> V10
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exampleData()

</code></pre>

<hr>
<h2 id='genotypes'>Create Core Hunter genotype data from data frame, matrix or file.</h2><span id='topic+genotypes'></span>

<h3>Description</h3>

<p>Specify either a data frame or matrix, or a file from which to read the genotypes.
See <a href="https://www.corehunter.org">https://www.corehunter.org</a> for documentation and examples of the genotype data
file format used by Core Hunter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genotypes(data, alleles, file, format)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genotypes_+3A_data">data</code></td>
<td>
<p>Data frame or matrix containing the genotypes (individuals x markers)
depending on the chosen format:
</p>

<dl>
<dt><code>default</code></dt><dd>
<p>Data frame. One row per individual and one or more columns per marker.
Columns contain the names, numbers, references, ... of observed alleles.
Unique row names (item ids) are required and columns should be named
after the marker to which they belong, optionally extended with an
arbitrary suffix starting with a dot (<code>.</code>), dash (<code>-</code>) or
underscore (<code>_</code>) character.
</p>
</dd>
<dt><code>biparental</code></dt><dd>
<p>Numeric matrix or data frame. One row per individual and one column per marker.
Data consists of 0, 1 and 2 coding for homozygous (AA), heterozygous (AB) and
homozygous (BB), respectively. Unique row names (item ids) are required and
optionally column (marker) names may be included as well.
</p>
</dd>
<dt><code>frequency</code></dt><dd>
<p>Numeric matrix or data frame. One row per individual (or bulk sample) and multiple
columns per marker. Data consists of allele frequencies, grouped per marker in
consecutive columns named after the corresponding marker, optionally extended
with an arbitrary suffix starting with a dot (<code>.</code>), dash (<code>-</code>) or
underscore (<code>_</code>) character.. The allele frequencies of each marker should
sum to one in each sample. Unique row names (item ids) are required.
</p>
</dd>
</dl>
<p>In case a data frame is provided, an optional first column <code>NAME</code>
may be included to specify item names. The remaining columns should follow
the format as described above.
See <a href="https://www.corehunter.org">https://www.corehunter.org</a> for more details about the supported genotype formats.
Note that both the <code>frequency</code> and <code>biparental</code> format syntactically also
comply with the <code>default</code> format but with different semantics, meaning that it
is very important to specify the correct format. Some checks have been built in that
raise warnings in case it seems that the wrong format might have been specified based
on an inspection of the data. If you are sure that you have selected the correct format
these warnings, if any, can be safely ignored.
</p>
</td></tr>
<tr><td><code id="genotypes_+3A_alleles">alleles</code></td>
<td>
<p>Allele names per marker (<code>character</code> vector).
Ignored except when creating <code>frequency</code> data from a matrix or data frame.
Allele names should be ordered in correspondence with the data columns.</p>
</td></tr>
<tr><td><code id="genotypes_+3A_file">file</code></td>
<td>
<p>File containing the genotype data.</p>
</td></tr>
<tr><td><code id="genotypes_+3A_format">format</code></td>
<td>
<p>Genotype data format, one of <code>default</code>, <code>biparental</code> or <code>frequency</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Genotype data of class <code>chgeno</code> with elements
</p>

<dl>
<dt><code>data</code></dt><dd><p>Genotypes. Data frame for default format, <code>numeric</code> matrix for other formats.</p>
</dd>
<dt><code>size</code></dt><dd><p>Number of individuals in the dataset.</p>
</dd>
<dt><code>ids</code></dt><dd><p>Unique item identifiers (<code>character</code>).</p>
</dd>
<dt><code>names</code></dt><dd><p>Item names (<code>character</code>). Names of individuals to which no explicit name
has been assigned are equal to the unique <code>ids</code>.</p>
</dd>
<dt><code>markers</code></dt><dd><p>Marker names (<code>character</code>).
May contain <code>NA</code> values in case only some or no marker names were specified.
Marker names are always included for the <code>default</code> and <code>frequency</code> format
but are optional for the <code>biparental</code> format.</p>
</dd>
<dt><code>alleles</code></dt><dd><p>List of character vectors with allele names per marker.
Vectors may contain <code>NA</code> values in case only some or no allele names were
specified. For <code>biparental</code> data the two alleles are name <code>"0"</code> and
<code>"1"</code>, respectively, for all markers. For the <code>default</code> format allele
names are inferred from the provided data. Finally, for <code>frequency</code> data
allele names are optional and may be specified either in the file or through
the <code>alleles</code> argument when creating this type of data from a matrix or
data frame.</p>
</dd>
<dt><code>java</code></dt><dd><p>Java version of the data object.</p>
</dd>
<dt><code>format</code></dt><dd><p>Genotype data format used.</p>
</dd>
<dt><code>file</code></dt><dd><p>Normalized path of file from which data was read (if applicable).</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# create from data frame or matrix

# default format
geno.data &lt;- data.frame(
 NAME = c("Alice", "Bob", "Carol", "Dave", "Eve"),
 M1.1 = c(1,2,1,2,1),
 M1.2 = c(3,2,2,3,1),
 M2.1 = c("B","C","D","B",NA),
 M2.2 = c("B","A","D","B",NA),
 M3.1 = c("a1","a1","a2","a2","a1"),
 M3.2 = c("a1","a2","a2","a1","a1"),
 M4.1 = c(NA,"+","+","+","-"),
 M4.2 = c(NA,"-","+","-","-"),
 row.names = paste("g", 1:5, sep = "-")
)
geno &lt;- genotypes(geno.data, format = "default")

# biparental (e.g. SNP)
geno.data &lt;- matrix(
 sample(c(0,1,2), replace = TRUE, size = 1000),
 nrow = 10, ncol = 100
)
rownames(geno.data) &lt;- paste("g", 1:10, sep = "-")
colnames(geno.data) &lt;- paste("m", 1:100, sep = "-")
geno &lt;- genotypes(geno.data, format = "biparental")

# frequencies
geno.data &lt;- matrix(
 c(0.0, 0.3, 0.7, 0.5, 0.5, 0.0, 1.0,
   0.4, 0.0, 0.6, 0.1, 0.9, 0.0, 1.0,
   0.3, 0.3, 0.4, 1.0, 0.0, 0.6, 0.4),
 byrow = TRUE, nrow = 3, ncol = 7
)
rownames(geno.data) &lt;- paste("g", 1:3, sep = "-")
colnames(geno.data) &lt;- c("M1", "M1", "M1", "M2", "M2", "M3", "M3")
alleles &lt;- c("M1-a", "M1-b", "M1-c", "M2-a", "M2-b", "M3-a", "M3-b")
geno &lt;- genotypes(geno.data, alleles, format = "frequency")

# read from file

# default format
geno.file &lt;- system.file("extdata", "genotypes.csv", package = "corehunter")
geno &lt;- genotypes(file = geno.file, format = "default")

# biparental (e.g. SNP)
geno.file &lt;- system.file("extdata", "genotypes-biparental.csv", package = "corehunter")
geno &lt;- genotypes(file = geno.file, format = "biparental")

# frequencies
geno.file &lt;- system.file("extdata", "genotypes-frequency.csv", package = "corehunter")
geno &lt;- genotypes(file = geno.file, format = "frequency")

## End(Not run)

</code></pre>

<hr>
<h2 id='getAlleleFrequencies'>Get Allele frequency matrix.</h2><span id='topic+getAlleleFrequencies'></span>

<h3>Description</h3>

<p>Get Allele frequency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAlleleFrequencies(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAlleleFrequencies_+3A_data">data</code></td>
<td>
<p>Core Hunter data containing genotypes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>allele frequency matrix
</p>

<hr>
<h2 id='getNormalizationRanges'>Determine normalization ranges of all objectives in a multi-objective configuration.</h2><span id='topic+getNormalizationRanges'></span>

<h3>Description</h3>

<p>Executes an independent stochastic hill-climbing search (random descent) per objective
to approximate the optimal solution for each objective, from which a suitable normalization
range is inferred based on the Pareto minima/maxima. These normalization searches are
executed in parallel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNormalizationRanges(
  data,
  obj,
  size = 0.2,
  always.selected = integer(0),
  never.selected = integer(0),
  mode = c("default", "fast"),
  time = NA,
  impr.time = NA,
  steps = NA,
  impr.steps = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNormalizationRanges_+3A_data">data</code></td>
<td>
<p>Core Hunter data (<code>chdata</code>) containing genotypes,
phenotypes and/or a precomputed distance matrix. Can also be an
object of class <code>chdist</code>, <code>chgeno</code> or <code>chpheno</code>
if only one type of data is provided.</p>
</td></tr>
<tr><td><code id="getNormalizationRanges_+3A_obj">obj</code></td>
<td>
<p>List of objectives (<code>chobj</code>).
If no objectives are specified Core Hunter maximizes a weighted
index including the default entry-to-nearest-entry distance
(<code>EN</code>) for each available data type.
For genotypes, the Modified Roger's distance (<code>MR</code>) is
used. For phenotypes, Gower's distance (<code>GD</code>) is applied.</p>
</td></tr>
<tr><td><code id="getNormalizationRanges_+3A_size">size</code></td>
<td>
<p>Desired core subset size (numeric). If larger than one the value
is used as the absolute core size after rounding. Else it is used as the
sampling rate and multiplied with the dataset size to determine the size of
the core. The default sampling rate is 0.2.</p>
</td></tr>
<tr><td><code id="getNormalizationRanges_+3A_always.selected">always.selected</code></td>
<td>
<p>vector with indices (integer) or ids (character) of
items that should always be selected in the core collection</p>
</td></tr>
<tr><td><code id="getNormalizationRanges_+3A_never.selected">never.selected</code></td>
<td>
<p>vector with indices (integer) or ids (character) of
items that should never be selected in the core collection</p>
</td></tr>
<tr><td><code id="getNormalizationRanges_+3A_mode">mode</code></td>
<td>
<p>Execution mode (<code>default</code> or <code>fast</code>). In default mode,
the normalization searches terminate when no improvement is found for ten
seconds. In fast mode, searches terminate as soon as no improvement is
made for two seconds. These stop conditions can be overridden using arguments
<code>time</code>, <code>impr.time</code>, <code>steps</code> and/or <code>impr.steps</code>. In
<code>default</code> mode, the value of the latter two, step-based conditions is
multiplied with 500, in line with the behaviour of <code><a href="#topic+sampleCore">sampleCore</a></code>
when executed in <code>default</code> mode.</p>
</td></tr>
<tr><td><code id="getNormalizationRanges_+3A_time">time</code></td>
<td>
<p>Absolute runtime limit in seconds. Not used by default (<code>NA</code>).
If used, it should be a strictly positive value, which is rounded to the
nearest integer.</p>
</td></tr>
<tr><td><code id="getNormalizationRanges_+3A_impr.time">impr.time</code></td>
<td>
<p>Maximum time without improvement in seconds. If no explicit
stop conditions are specified, the maximum time without improvement defaults
to ten or two seconds, when executing Core Hunter in <code>default</code> or
<code>fast</code> mode, respectively. If a custom improvement time is specified,
it should be strictly positive and is rounded to the nearest integer.</p>
</td></tr>
<tr><td><code id="getNormalizationRanges_+3A_steps">steps</code></td>
<td>
<p>Maximum number of search steps. Not used by default (<code>NA</code>).
If used, it should be a strictly positive value, which is rounded
to the nearest integer. In <code>default</code> mode, the value is
multiplied with 500, in line with the behaviour of
<code><a href="#topic+sampleCore">sampleCore</a></code> when executed in <code>default</code> mode.</p>
</td></tr>
<tr><td><code id="getNormalizationRanges_+3A_impr.steps">impr.steps</code></td>
<td>
<p>Maximum number of steps without improvement. Not used by
default (<code>NA</code>). If used, it should be a strictly
positive value, which is rounded to the nearest integer.
In <code>default</code> mode, the value is multiplied with 500,
in line with the behaviour of <code><a href="#topic+sampleCore">sampleCore</a></code>
when executed in <code>default</code> mode.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an objective that is being maximized, the upper bound is set to the value of the best
solution for that objective, while the lower bound is set to the Pareto minimum, i.e. the
minimum value obtained when evaluating all optimal solutions (for each single objective)
with the considered objective. For an objective that is being minimized, the roles of
upper and lower bound are interchanged, and the Pareto maximum is used instead.
</p>
<p>Because Core Hunter uses stochastic algorithms, repeated runs may produce different
results. To eliminate randomness, you may set a random number generation seed using
<code><a href="base.html#topic+set.seed">set.seed</a></code> prior to executing Core Hunter. In addition, when reproducible
results are desired, it is advised to use step-based stop conditions instead of the
(default) time-based criteria, because runtimes may be affected by external factors,
and, therefore, a different number of steps may have been performed in repeated runs
when using time-based stop conditions.
</p>


<h3>Value</h3>

<p>Numeric matrix with one row per objective and two columns:
</p>

<dl>
<dt><code>lower</code></dt><dd><p>Lower bound of normalization range.</p>
</dd>
<dt><code>upper</code></dt><dd><p>Upper bound of normalization range.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+coreHunterData">coreHunterData</a></code>, <code><a href="#topic+objective">objective</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- exampleData()

# maximize entry-to-nearest-entry distance between genotypes and phenotypes (equal weight)
objectives &lt;- list(objective("EN", "MR"), objective("EN", "GD"))
# get normalization ranges for default size (20%)
ranges &lt;- getNormalizationRanges(data, obj = objectives, mode = "fast")

# set normalization ranges and sample core
objectives &lt;- lapply(1:2, function(o){setRange(objectives[[o]], ranges[o,])})
core &lt;- sampleCore(data, obj = objectives)


</code></pre>

<hr>
<h2 id='objective'>Create Core Hunter objective.</h2><span id='topic+objective'></span>

<h3>Description</h3>

<p>The following optimization objectives are supported by Core Hunter:
</p>

<dl>
<dt><code>EN</code></dt><dd>
<p>Average entry-to-nearest-entry distance (default). Maximizes the average distance
between each selected individual and the closest other selected item
in the core. Favors diverse cores in which each individual is sufficiently
different from the most similar other selected item (low redundancy).
Multiple distance measures are provided to be used with this objective (see below).
</p>
</dd>
<dt><code>AN</code></dt><dd>
<p>Average accession-to-nearest-entry distance. Minimizes the average distance
between each individual (from the full dataset) and the closest selected item
in the core (which can be the individual itself). Favors representative cores
in which all items from the original dataset are represented by similar individuals
in the selected subset. Multiple distance measures are provided to be used with this
objective (see below).
</p>
</dd>
<dt><code>EE</code></dt><dd>
<p>Average entry-to-entry distance. Maximizes the average distance between
each pair of selected individuals in the core. This objective is related to
the entry-to-nearest-entry (EN) distance but less effectively avoids redundant,
similar individuals in the core. In general, use of <code>EN</code> is preferred.
Multiple distance measures are provided to be used with this objective (see below).
</p>
</dd>
<dt><code>SH</code></dt><dd>
<p>Shannon's allelic diversity index. Maximizes the entropy, as used in information
theory, of the selected core. Independently takes into account all allele frequencies,
regardless of the locus (marker) where to which the allele belongs. Requires genotypes.
</p>
</dd>
<dt><code>HE</code></dt><dd>
<p>Expected proportion of heterozygous loci. Maximizes the expected proportion of heterozygous
loci in offspring produced from random crossings within the selected core. In contrast to
Shannon's index (<code>SH</code>) this objective treats each marker (locus) with equal importance,
regardless of the number of possible alleles for that marker. Requires genotypes.
</p>
</dd>
<dt><code>CV</code></dt><dd>
<p>Allele coverage. Maximizes the proportion of alleles observed in the full dataset that are
retained in the selected core. Requires genotypes.
</p>
</dd>
</dl>

<p>The first three objective types (<code>EN</code>, <code>AN</code> and <code>EE</code>) aggregate pairwise distances
between individuals. These distances can be computed using various measures:
</p>

<dl>
<dt><code>MR</code></dt><dd>
<p>Modified Rogers distance (default). Requires genotypes.
</p>
</dd>
<dt><code>CE</code></dt><dd>
<p>Cavalli-Sforza and Edwards distance. Requires genotypes.
</p>
</dd>
<dt><code>GD</code></dt><dd>
<p>Gower distance. Requires phenotypes.
</p>
</dd>
<dt><code>PD</code></dt><dd>
<p>Precomputed distances. Uses the precomputed distance matrix of the dataset.
</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>objective(
  type = c("EN", "AN", "EE", "SH", "HE", "CV"),
  measure = c("MR", "CE", "GD", "PD"),
  weight = 1,
  range = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objective_+3A_type">type</code></td>
<td>
<p>Objective type, one of <code>EN</code> (default), <code>AN</code>, <code>EE</code>,
<code>SH</code>, <code>HE</code> or <code>CV</code> (see description). The former three
objectives are distance based and require to choose a distance
<code>measure</code>. By default, Modified Roger's distance is used,
computed from the genotypes.</p>
</td></tr>
<tr><td><code id="objective_+3A_measure">measure</code></td>
<td>
<p>Distance measure used to compute the distance between two
individuals, one of <code>MR</code> (default), <code>CE</code>, <code>GD</code> or <code>PD</code>
(see description). Ignored when <code>type</code> is <code>SH</code>, <code>HE</code> or
<code>CV</code>.</p>
</td></tr>
<tr><td><code id="objective_+3A_weight">weight</code></td>
<td>
<p>Weight assigned to the objective when maximizing a weighted
index. Defaults to 1.0.</p>
</td></tr>
<tr><td><code id="objective_+3A_range">range</code></td>
<td>
<p>Normalization range [l,u] of the objective when maximizing a weighted
index. By default the range is not set (<code>NULL</code>) and will be determined
automatically prior to execution, if normalization is enabled (default).
Values are rescaled to [0,1] with the linear formula
<code class="reqn">
 v' = (v - l)/(u - l)
</code>.
When an explicit normalization range is set, it overrides the automatically inferred
range. Also, setting the range for all included objectives reduces the computation time
when sampling a multi-objective core collection. In case of repeated sampling from the
same dataset with the same objectives and size, it is therefore advised to determine the
normalization ranges only once using <code><a href="#topic+getNormalizationRanges">getNormalizationRanges</a></code> so that
they can be reused for all executions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Core Hunter objective of class <code>chobj</code> with elements
</p>

<dl>
<dt><code>type</code></dt><dd><p>Objective type.</p>
</dd>
<dt><code>meas</code></dt><dd><p>Distance measure (if applicable).</p>
</dd>
<dt><code>weight</code></dt><dd><p>Assigned weight.</p>
</dd>
<dt><code>range</code></dt><dd><p>Normalization range (if specified).</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+getNormalizationRanges">getNormalizationRanges</a></code>, <code><a href="#topic+setRange">setRange</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>objective()
objective(meas = "PD")
objective("EE", "GD")
objective("HE")
objective("EN", "MR", range = c(0.150, 0.300))
objective("AN", "MR", weight = 0.5, range = c(0.150, 0.300))

</code></pre>

<hr>
<h2 id='phenotypes'>Create Core Hunter phenotype data from data frame or file.</h2><span id='topic+phenotypes'></span>

<h3>Description</h3>

<p>Specify either a data frame containing the phenotypic trait observations
or a file from which to read the data. See <a href="https://www.corehunter.org">https://www.corehunter.org</a> for
documentation and examples of the phenotype data format used by Core Hunter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phenotypes(data, types, min, max, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phenotypes_+3A_data">data</code></td>
<td>
<p>Data frame containing one row per individual and one column per trait.
Unique row and column names are required and used as item and trait ids, respectively.
The data frame may optionally include a first column <code>NAME</code> used to assign names
to some or all individuals.</p>
</td></tr>
<tr><td><code id="phenotypes_+3A_types">types</code></td>
<td>
<p>Variable types (optional).
Vector of characters, each of length one or two.
Ignored when reading from file.
</p>
<p>The first letter indicates the scale type and should be one of <code>N</code> (nominal),
<code>O</code> (ordinal), <code>I</code> (interval) or <code>R</code> (ratio).
</p>
<p>The second letter optionally indicates the variable encoding (in Java) and should
be one of <code>B</code> (boolean), <code>T</code> (short), <code>I</code> (integer), <code>L</code> (long),
<code>R</code> (big integer), <code>F</code> (float), <code>D</code> (double), <code>M</code> (big decimal),
<code>A</code> (date) or <code>S</code> (string). The default encoding is <code>S</code> (string)
for nominal variables, <code>I</code> (integer) for ordinal and interval variables
and <code>D</code> (double) for ratio variables. Interval and ratio variables are
limited to numeric encodings.
</p>
<p>If no explicit variable types are specified these are automatically inferred from
the data frame column types and classes, whenever possible. Columns of type
<code>character</code> are treated as nominal string encoded variables (<code>N</code>).
Unordered <code>factor</code> columns are converted to <code>character</code> and also
treated as string encoded nominals. Ordered factors are converted to
integer encoded interval variables (<code>I</code>) as described below.
Columns of type <code>logical</code> are taken to be asymmetric binary variables (<code>NB</code>).
Finally, <code>integer</code> and more broadly <code>numeric</code> columns are treated as integer
encoded interval variables (<code>I</code>) and double encoded ratio variables (<code>R</code>),
respectively.
</p>
<p>Boolean encoded nominals (<code>NB</code>) are treated as asymmetric binary variables.
For symmetric binary variables just use the default string encoding (<code>N</code>
or <code>NS</code>). Other nominal variables are converted to factors.
</p>
<p>Ordinal variables of class <code>ordered</code> are converted to integers respecting
the order and range of the factor levels and subsequently treated as integer
encoded interval variables (<code>I</code>). This conversion allows to model the
full range of factor levels also when some might not occur in the data. For other
ordinal variables it is assumed that each value occurs at least once and that
values follow the natural ordering of the chosen data type (in Java).
</p>
<p>If explicit types are given for some variables others can still be automatically inferred
by setting their type to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="phenotypes_+3A_min">min</code></td>
<td>
<p>Minimum values of interval or ratio variables (optional).
Numeric vector. Ignored when reading from file.
If undefined for some variables the respective minimum is inferred from the data.
If the data exceeds the minimum it is also updated accordingly.
For nominal and ordinal variables just put <code>NA</code>.</p>
</td></tr>
<tr><td><code id="phenotypes_+3A_max">max</code></td>
<td>
<p>Maximum values of interval or ratio variables (optional).
Numeric vector. Ignored when reading from file.
If undefined for some variables the respective maximum is inferred from the data.
If the data exceeds the maximum it is also updated accordingly.
For nominal and ordinal variables just put <code>NA</code>.</p>
</td></tr>
<tr><td><code id="phenotypes_+3A_file">file</code></td>
<td>
<p>File containing the phenotype data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Phenotype data of class <code>chpheno</code> with elements
</p>

<dl>
<dt><code>data</code></dt><dd><p>Phenotypes (data frame).</p>
</dd>
<dt><code>size</code></dt><dd><p>Number of individuals in the dataset.</p>
</dd>
<dt><code>ids</code></dt><dd><p>Unique item identifiers.</p>
</dd>
<dt><code>names</code></dt><dd><p>Item names. Names of individuals to which no explicit name
has been assigned are equal to the unique <code>ids</code>.</p>
</dd>
<dt><code>types</code></dt><dd><p>Variable types and encodings.</p>
</dd>
<dt><code>ranges</code></dt><dd><p>Variable ranges, when applicable (<code>NA</code> elsewhere).</p>
</dd>
<dt><code>java</code></dt><dd><p>Java version of the data object.</p>
</dd>
<dt><code>file</code></dt><dd><p>Normalized path of file from which the data was read (if applicable).</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># create from data frame
pheno.data &lt;- data.frame(
 season = c("winter", "summer", "summer", "winter", "summer"),
 yield = c(34.5, 32.6, 22.1, 54.12, 43.33),
 size = ordered(c("l", "s", "s", "m", "l"), levels = c("s", "m", "l")),
 resistant = c(FALSE, TRUE, TRUE, FALSE, TRUE)
)
pheno &lt;- phenotypes(pheno.data)

# explicit types
pheno &lt;- phenotypes(pheno.data, types = c("N", "R", "O", "NB"))
# treat last column as symmetric binary, auto infer others
pheno &lt;- phenotypes(pheno.data, types = c(NA, NA, NA, "NS"))

# explicit ranges
pheno &lt;- phenotypes(pheno.data, min = c(NA, 20.0, NA, NA), max = c(NA, 60.0, NA, NA))

# read from file
pheno.file &lt;- system.file("extdata", "phenotypes.csv", package = "corehunter")
pheno &lt;- phenotypes(file = pheno.file)

</code></pre>

<hr>
<h2 id='read.autodelim'>Read delimited file.</h2><span id='topic+read.autodelim'></span>

<h3>Description</h3>

<p>Delegates to <code><a href="utils.html#topic+read.delim">read.delim</a></code> where the separator is inferred from the file extension (CSV or TXT).
For CSV files the delimiter is set to <code>","</code> while for TXT file <code>"\t"</code> is used. Also sets
some default argument values as used by Core Hunter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.autodelim(
  file,
  quote = "'\"",
  row.names = 1,
  na.strings = "",
  check.names = FALSE,
  strip.white = TRUE,
  stringsAsFactors = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.autodelim_+3A_file">file</code></td>
<td>
<p>File path.</p>
</td></tr>
<tr><td><code id="read.autodelim_+3A_quote">quote</code></td>
<td>
<p>the set of quoting characters. To disable quoting
altogether, use <code>quote = ""</code>.  See <code><a href="base.html#topic+scan">scan</a></code> for the
behaviour on quotes embedded in quotes.  Quoting is only considered
for columns read as character, which is all of them unless
<code>colClasses</code> is specified.</p>
</td></tr>
<tr><td><code id="read.autodelim_+3A_row.names">row.names</code></td>
<td>
<p>a vector of row names.  This can be a vector giving
the actual row names, or a single number giving the column of the
table which contains the row names, or character string giving the
name of the table column containing the row names.
</p>
<p>If there is a header and the first row contains one fewer field than
the number of columns, the first column in the input is used for the
row names.  Otherwise if <code>row.names</code> is missing, the rows are
numbered.
</p>
<p>Using <code>row.names = NULL</code> forces row numbering. Missing or
<code>NULL</code> <code>row.names</code> generate row names that are considered
to be &lsquo;automatic&rsquo; (and not preserved by <code><a href="base.html#topic+as.matrix">as.matrix</a></code>).
</p>
</td></tr>
<tr><td><code id="read.autodelim_+3A_na.strings">na.strings</code></td>
<td>
<p>a character vector of strings which are to be
interpreted as <code><a href="base.html#topic+NA">NA</a></code> values.  Blank fields are also
considered to be missing values in logical, integer, numeric and
complex fields.  Note that the test happens <em>after</em>
white space is stripped from the input, so <code>na.strings</code>
values may need their own white space stripped in advance.</p>
</td></tr>
<tr><td><code id="read.autodelim_+3A_check.names">check.names</code></td>
<td>
<p>logical.  If <code>TRUE</code> then the names of the
variables in the data frame are checked to ensure that they are
syntactically valid variable names.  If necessary they are adjusted
(by <code><a href="base.html#topic+make.names">make.names</a></code>) so that they are, and also to ensure
that there are no duplicates.</p>
</td></tr>
<tr><td><code id="read.autodelim_+3A_strip.white">strip.white</code></td>
<td>
<p>logical. Used only when <code>sep</code> has
been specified, and allows the stripping of leading and trailing
white space from unquoted <code>character</code> fields (<code>numeric</code> fields
are always stripped).  See <code><a href="base.html#topic+scan">scan</a></code> for further details
(including the exact meaning of &lsquo;white space&rsquo;),
remembering that the columns may include the row names.</p>
</td></tr>
<tr><td><code id="read.autodelim_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>logical: should character vectors be converted
to factors?  Note that this is overridden by <code>as.is</code> and
<code>colClasses</code>, both of which allow finer control.</p>
</td></tr>
<tr><td><code id="read.autodelim_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to  <code><a href="utils.html#topic+read.delim">read.delim</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame.
</p>

<hr>
<h2 id='sampleCore'>Sample a core collection.</h2><span id='topic+sampleCore'></span>

<h3>Description</h3>

<p>Sample a core collection from the given data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleCore(
  data,
  obj,
  size = 0.2,
  always.selected = integer(0),
  never.selected = integer(0),
  mode = c("default", "fast"),
  normalize = TRUE,
  time = NA,
  impr.time = NA,
  steps = NA,
  impr.steps = NA,
  indices = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleCore_+3A_data">data</code></td>
<td>
<p>Core Hunter data (<code>chdata</code>) containing genotypes,
phenotypes and/or a precomputed distance matrix. Typically the
data is obtained with <code><a href="#topic+coreHunterData">coreHunterData</a></code>. Can also be
an object of class <code>chdist</code>, <code>chgeno</code> or <code>chpheno</code>
if only one type of data is provided.</p>
</td></tr>
<tr><td><code id="sampleCore_+3A_obj">obj</code></td>
<td>
<p>Objective or list of objectives (<code>chobj</code>).
If no objectives are specified Core Hunter maximizes a weighted
index including the default entry-to-nearest-entry distance
(<code>EN</code>) for each available data type, with equal weight.
For genotypes, the Modified Roger's distance (<code>MR</code>) is
used. For phenotypes, Gower's distance (<code>GD</code>) is applied.</p>
</td></tr>
<tr><td><code id="sampleCore_+3A_size">size</code></td>
<td>
<p>Desired core subset size (numeric). If larger than one the value
is used as the absolute core size after rounding. Else it is used as the
sampling rate and multiplied with the dataset size to determine the size of
the core. The default sampling rate is 0.2.</p>
</td></tr>
<tr><td><code id="sampleCore_+3A_always.selected">always.selected</code></td>
<td>
<p>vector with indices (integer) or ids (character) of
items that should always be selected in the core collection</p>
</td></tr>
<tr><td><code id="sampleCore_+3A_never.selected">never.selected</code></td>
<td>
<p>vector with indices (integer) or ids (character) of
items that should never be selected in the core collection</p>
</td></tr>
<tr><td><code id="sampleCore_+3A_mode">mode</code></td>
<td>
<p>Execution mode (<code>default</code> or <code>fast</code>). In default mode,
Core Hunter uses an advanced parallel tempering search algorithm and terminates
when no improvement is found for ten seconds. In fast mode, a simple stochastic
hill-climbing algorithm is applied and Core Hunter terminates as soon as no
improvement is made for two seconds. Stop conditions can be overridden with
arguments <code>time</code> and <code>impr.time</code>.</p>
</td></tr>
<tr><td><code id="sampleCore_+3A_normalize">normalize</code></td>
<td>
<p>If <code>TRUE</code> (default), the applied objectives in a multi-objective
configuration (two or more objectives) are automatically normalized prior to execution.
For single-objective configurations, this argument is ignored.
</p>
<p>Normalization requires an independent preliminary search per objective (fast stochastic
hill-climber, executed in parallel for all objectives). The same stop conditions, as
specified for the main search, are also applied to each normalization search. In
<code>default</code> execution mode, however, any step-based stop conditions are multiplied
by 500 for the normalization searches, because in that case the main search (parallel
tempering) executes 500 stochastic hill-climbing steps per replica, in a single step
of the main search.
</p>
<p>Normalization ranges can also be precomputed (see <code><a href="#topic+getNormalizationRanges">getNormalizationRanges</a></code>)
or manually specified in the objectives to save computation time when sampling core
collections. This is especially useful when multiple cores are sampled for the same
objectives, with possibly varying weights.</p>
</td></tr>
<tr><td><code id="sampleCore_+3A_time">time</code></td>
<td>
<p>Absolute runtime limit in seconds. Not used by default (<code>NA</code>).
If used, it should be a strictly positive value, which is rounded to the
nearest integer.</p>
</td></tr>
<tr><td><code id="sampleCore_+3A_impr.time">impr.time</code></td>
<td>
<p>Maximum time without improvement in seconds. If no explicit
stop conditions are specified, the maximum time without improvement defaults
to ten or two seconds, when executing Core Hunter in <code>default</code> or
<code>fast</code> mode, respectively. If a custom improvement time is specified,
it should be strictly positive and is rounded to the nearest integer.</p>
</td></tr>
<tr><td><code id="sampleCore_+3A_steps">steps</code></td>
<td>
<p>Maximum number of search steps. Not used by default (<code>NA</code>).
If used, it should be a strictly positive value, which is rounded
to the nearest integer. The number of steps applies to the main
search. Details of how this stop condition is transferred to
normalization searches, in a multi-objective configuration, are
provided in the description of the argument <code>normalize</code>.</p>
</td></tr>
<tr><td><code id="sampleCore_+3A_impr.steps">impr.steps</code></td>
<td>
<p>Maximum number of steps without improvement. Not used by
default (<code>NA</code>). If used, it should be a strictly
positive value, which is rounded to the nearest integer.
The maximum number of steps without improvement applies
to the main search. Details of how this stop condition is
transferred to normalization searches, in a multi-objective
configuration, are provided in the description of the argument
<code>normalize</code>.</p>
</td></tr>
<tr><td><code id="sampleCore_+3A_indices">indices</code></td>
<td>
<p>If <code>TRUE</code>, the result contains the indices instead of ids
(default) of the selected individuals.</p>
</td></tr>
<tr><td><code id="sampleCore_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, search progress messages are printed to the console.
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because Core Hunter uses stochastic algorithms, repeated runs may produce different
results. To eliminate randomness, you may set a random number generation seed using
<code><a href="base.html#topic+set.seed">set.seed</a></code> prior to executing Core Hunter. In addition, when reproducible
results are desired, it is advised to use step-based stop conditions instead of the
(default) time-based criteria, because runtimes may be affected by external factors,
and, therefore, a different number of steps may have been performed in repeated runs
when using time-based stop conditions.
</p>


<h3>Value</h3>

<p>Core subset (<code>chcore</code>). It has an element <code>sel</code>
which is a character or numeric vector containing the sorted ids or indices,
respectively, of the selected individuals (see argument <code>indices</code>).
In addition the result has one or more elements that indicate the value
of each objective function that was included in the optimization.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coreHunterData">coreHunterData</a></code>, <code><a href="#topic+objective">objective</a></code>, <code><a href="#topic+getNormalizationRanges">getNormalizationRanges</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- exampleData()

# default size, maximize entry-to-nearest-entry Modified Rogers distance
obj &lt;- objective("EN", "MR")
core &lt;- sampleCore(data, obj)

# fast mode
core &lt;- sampleCore(data, obj, mode = "f")
# absolute size
core &lt;- sampleCore(data, obj, size = 25)
# relative size
core &lt;- sampleCore(data, obj, size = 0.1)

# other objective: minimize accession-to-nearest-entry precomputed distance
core &lt;- sampleCore(data, obj = objective(type = "AN", measure = "PD"))
# multiple objectives (equal weight)
core &lt;- sampleCore(data, obj = list(
 objective("EN", "PD"),
 objective("AN", "GD")
))
# multiple objectives (custom weight)
core &lt;- sampleCore(data, obj = list(
 objective("EN", "PD", weight = 0.3),
 objective("AN", "GD", weight = 0.7)
))

# custom stop conditions
core &lt;- sampleCore(data, obj, time = 5, impr.time = 2)
core &lt;- sampleCore(data, obj, steps = 300)

# print progress messages
core &lt;- sampleCore(data, obj, verbose = TRUE)


</code></pre>

<hr>
<h2 id='setRange'>Set the normalization range of the given objective.</h2><span id='topic+setRange'></span>

<h3>Description</h3>

<p>See argument <code>range</code> of <code><a href="#topic+objective">objective</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setRange(obj, range)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setRange_+3A_obj">obj</code></td>
<td>
<p>Core Hunter objective of class <code>chobj</code>.</p>
</td></tr>
<tr><td><code id="setRange_+3A_range">range</code></td>
<td>
<p>Normalization range [l,u].
See argument <code>range</code> of <code><a href="#topic+objective">objective</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Objective including normalization range.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+objective">objective</a></code>
</p>

<hr>
<h2 id='wrapData'>Wrap distances, genotypes or phenotypes in Core Hunter data.</h2><span id='topic+wrapData'></span>

<h3>Description</h3>

<p>If the given data does not match any of these three classes
it is returned unchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrapData(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrapData_+3A_data">data</code></td>
<td>
<p>of class <code>chgeno</code>, <code>chpheno</code> or <code>chdist</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Core Hunter data of class <code>chdata</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
