<!DOCTYPE html><html><head><title>Help for package servosphereR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {servosphereR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#servosphereR'><p>servosphereR: A package to facilitate cleaning and analyzing data produced by a servosphere.</p></a></li>
<li><a href='#aggregateData'><p>Aggregate data frames</p></a></li>
<li><a href='#atan3'><p>Calculate angle between a vector and y-axis</p></a></li>
<li><a href='#calcBearing'><p>Calculate bearing</p></a></li>
<li><a href='#calcDistance'><p>Calculate distance</p></a></li>
<li><a href='#calcTurnAngle'><p>Calculate turn angle</p></a></li>
<li><a href='#calcTurnVelocity'><p>Calculate turn velocity</p></a></li>
<li><a href='#calcVelocity'><p>Calculate velocity</p></a></li>
<li><a href='#calcXY'><p>Calculate (x, y) coordinates</p></a></li>
<li><a href='#cleanNames'><p>Set column names for list of data frames</p></a></li>
<li><a href='#getFiles'><p>Return a list of data frames generated from the servosphere</p></a></li>
<li><a href='#mergeTrialInfo'><p>Merge trial id information</p></a></li>
<li><a href='#servosphere'><p>Example servosphere data</p></a></li>
<li><a href='#summaryAvgBearing'><p>Calculate average bearing</p></a></li>
<li><a href='#summaryAvgVelocity'><p>Calculate average velocity</p></a></li>
<li><a href='#summaryNetDisplacement'><p>Calculate net displacement</p></a></li>
<li><a href='#summaryStops'><p>Summarize the number and length of stops</p></a></li>
<li><a href='#summaryTortuosity'><p>Calculate tortuosity</p></a></li>
<li><a href='#summaryTotalDistance'><p>Calculate total path distance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analyze Data Generated from Syntech Servosphere Trials</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions that facilitate and speed up the analysis of data
    produced by a Syntech servosphere <a href="http://www.ockenfels-syntech.com/products/locomotion-compensation/">http://www.ockenfels-syntech.com/products/locomotion-compensation/</a>,
    which is equipment for studying the movement behavior of arthropods.
    This package is designed to make working with data produced from a 
    servosphere easy for someone new to or unfamiliar with R. The functions
    provided in this package fall into three broad-use categories: functions for
    cleaning raw data produced by the servosphere software, functions for
    deriving movement variables based on position data, and functions for 
    summarizing movement variables for easier analysis. These functions are
    built with functions from the tidyverse package to work efficiently, as a
    single servosphere file may consist of hundreds of thousands of rows of data
    and a user may wish to analyze hundreds of files at a time. Many of the 
    movement variables derivable through this package are described in the 
    following papers:
    Ot√°lora-Luna, Fernando; Dickens, Joseph C. (2011) &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0020990">doi:10.1371/journal.pone.0020990</a>&gt;
    Party, Virginie; Hanot, Christophe; Busser, Daniela Schmidt; Rochat, Didier; Renou, Michel (2013) &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0052897">doi:10.1371/journal.pone.0052897</a>&gt;
    Bell, William J.; Kramer, Ernest (1980) &lt;<a href="https://doi.org/10.1007%2FBF01402908">doi:10.1007/BF01402908</a>&gt;
    Becher, Paul G; Guerin, Patrick M. (2009) &lt;<a href="https://doi.org/10.1016%2Fj.jinsphys.2009.01.006">doi:10.1016/j.jinsphys.2009.01.006</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://github.com/wittja01/servosphereR">http://github.com/wittja01/servosphereR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="http://github.com/wittja01/servosphereR/issues">http://github.com/wittja01/servosphereR/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>purrr (&ge; 0.2), data.table (&ge; 1.10), dplyr (&ge; 0.7), magrittr
(&ge; 1.5), rlang (&ge; 0.3), stats (&ge; 3.4)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-05-14 18:53:37 UTC; wittm094</td>
</tr>
<tr>
<td>Author:</td>
<td>Jacob T. Wittman [aut, cre],
  Brian H. Aukema [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jacob T. Wittman &lt;wittja01@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-05-14 19:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='servosphereR'>servosphereR: A package to facilitate cleaning and analyzing data produced by a servosphere.</h2><span id='topic+servosphereR'></span><span id='topic+servosphereR-package'></span>

<h3>Description</h3>

<p>A servosphere, or locomotory compensator, is a device that can be used to
study the movement of insects or other small critters. A servosphere consists
of a ball that rests on top of motors. A camera pointed at the top of the
sphere watches the insect as it moves and reports position changes to the
motors. As the insect moves, the motors rotate to keep the insect positioned
at the top of the sphere.
</p>

<hr>
<h2 id='aggregateData'>Aggregate data frames</h2><span id='topic+aggregateData'></span>

<h3>Description</h3>

<p>Aggregate the data frames in a list to reduce noise in movement recordings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregateData(list, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregateData_+3A_list">list</code></td>
<td>
<p>A list of data frame objects.</p>
</td></tr>
<tr><td><code id="aggregateData_+3A_n">n</code></td>
<td>
<p>The number of consecutive rows to aggregate over.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires that the change in time and change in position column
names are &quot;dT&quot;, &quot;dx&quot;, and &quot;dy&quot;, respectively.
</p>
<p>Movement recording data generated by the servosphere software is quite noisy
due to extraneous movements by the insect or side-to-side motion. Aggregating
the data by aggregating rows reduces this noise. Aggregating also reduces the
size of the data files, making future computing tasks faster.
</p>
<p>To aggregate the data properly, we recommend watching recordings of the
target organism moving on the servosphere and determine the length of time it
takes the insect to move at least 50 percent of its body length. Use the time
it takes the insect to move at least 50 percent of its body length as the
minimum aggregation time. Longer periods may be necessary depending on the
size and movement of the insect.
</p>
<p>The resulting data frames will have an additional column named &quot;length&quot;. The
values in length should be approximately equal to the sum of dT from the n
rows aggregated over, i.e. if each observation from the un-aggregated data is 10
ms and the user aggregates these observations to 1 second, the value of
length should be approximately 1. Note that in aggregating the data frame, the
stimulus column will also be aggregated The stimulus status value at the first
row to be aggregated will become the value of the stimulus for the aggregated
row.
</p>


<h3>Value</h3>

<p>A list of aggregated data frames with an additional column,
<code>length</code>, to check that the function worked.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Aggregates every 5 rows in each data frame. Must be used after
# cleanNames()
 servosphere &lt;- list(data.frame(id = rep(1, 200),
                                stimulus = rep(c(0, 1), each = 100),
                                dT = sample(8:12, 200, replace = TRUE),
                                dx = runif(200, 0, 5),
                                dy = runif(200, 0, 5),
                                treatment = rep("a", 200),
                                date = rep("2032018", 200)),
                     data.frame(id = rep(2, 200),
                                stimulus = rep(c(0, 1), each = 100),
                                dT = sample(8:12, 200, replace = TRUE),
                                dx = runif(200, 0, 5),
                                dy = runif(200, 0, 5),
                                treatment = rep("b", 200),
                                date = rep("2032018", 200)))
 servosphere &lt;- aggregateData(servosphere, n = 5)
</code></pre>

<hr>
<h2 id='atan3'>Calculate angle between a vector and y-axis</h2><span id='topic+atan3'></span>

<h3>Description</h3>

<p>Calculate the angle between a vector and y-axis, not the x-axis as in atan2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atan3(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="atan3_+3A_x">x</code></td>
<td>
<p>The x coordinate from the (x, y) locations.</p>
</td></tr>
<tr><td><code id="atan3_+3A_y">y</code></td>
<td>
<p>The y coordinate from the (x, y) location for an organism.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function. It is called in another function but is otherwise
not &quot;outward facing&quot;.
</p>
<p>This function calculates the angle between a vector and the y-axis. The
base function atan2 calculates the angle between a vector and the x-axis,
which is not desirable in this case.
</p>
<p>If the data will be aggregated, it is recommended to aggregate the data before
running this function.
</p>

<hr>
<h2 id='calcBearing'>Calculate bearing</h2><span id='topic+calcBearing'></span>

<h3>Description</h3>

<p>Calculates the bearing (direction of movement) for each time step
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcBearing(list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcBearing_+3A_list">list</code></td>
<td>
<p>A list of data frames with separate columns for x and y
coordinate values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires that the data has been previously processed with the
<code>calcXY()</code> function, providing (x, y) coordinates. Calculate the
direction moved by the organism relative to the y axis between each time step
in your data frames.
</p>
<p>If the data will be aggregated, it is recommended to aggregate the data before
running this function.
</p>


<h3>Value</h3>

<p>A list of data frames with a column for the bearing of the organism
at each time step.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Provide a list of data frames with two columns for the (x, y) coordinates

 servosphere &lt;- list(data.frame(id = rep(1, 200),
                                stimulus = rep(c(0, 1), each = 100),
                                dT = sample(8:12, 200, replace = TRUE),
                                dx = runif(200, 0, 5),
                                dy = runif(200, 0, 5),
                                treatment = rep("a", 200),
                                date = rep("2032018", 200)),
                     data.frame(id = rep(2, 200),
                                stimulus = rep(c(0, 1), each = 100),
                                dT = sample(8:12, 200, replace = TRUE),
                                dx = runif(200, 0, 5),
                                dy = runif(200, 0, 5),
                                treatment = rep("b", 200),
                                date = rep("2032018", 200)))
servosphere &lt;- calcXY(servosphere)

servosphere &lt;- calcBearing(servosphere)
</code></pre>

<hr>
<h2 id='calcDistance'>Calculate distance</h2><span id='topic+calcDistance'></span>

<h3>Description</h3>

<p>Calculate distance moved between time steps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcDistance(list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcDistance_+3A_list">list</code></td>
<td>
<p>A list of data frames, each of which has a column for dx and dy.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use the dx and dy columns in the servosphere data frames to calculate the
distance moved between each time recording. If the data will be aggregated, it
is recommended to aggregate the data before running this function.
</p>


<h3>Value</h3>

<p>A list of data frames, each of which has a variable for the distance
moved between each data recording.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> servosphere &lt;- list(data.frame(id = rep(1, 200),
                                stimulus = rep(c(0, 1), each = 100),
                                dT = sample(8:12, 200, replace = TRUE),
                                dx = runif(200, 0, 5),
                                dy = runif(200, 0, 5),
                                treatment = rep("a", 200),
                                date = rep("2032018", 200)),
                     data.frame(id = rep(2, 200),
                                stimulus = rep(c(0, 1), each = 100),
                                dT = sample(8:12, 200, replace = TRUE),
                                dx = runif(200, 0, 5),
                                dy = runif(200, 0, 5),
                                treatment = rep("b", 200),
                                date = rep("2032018", 200)))
servosphere &lt;- calcDistance(servosphere)
</code></pre>

<hr>
<h2 id='calcTurnAngle'>Calculate turn angle</h2><span id='topic+calcTurnAngle'></span>

<h3>Description</h3>

<p>Calculate the turn angle between two successive moves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcTurnAngle(list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcTurnAngle_+3A_list">list</code></td>
<td>
<p>A list of data frames, where each data frame has a column for
bearing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For this function to work, the data must have previously been processed with
the <code>calcBearing</code> function.
</p>
<p>This function calculates the turn angle between two successive movement
vectors. If the organism has not moved for a period of time but begins moving
again, the function calculates the turn angle between the last movement the
organism made and its current move.
</p>
<p>If the data will be aggregated, it is recommended to aggregate the data before
running this function.
</p>


<h3>Value</h3>

<p>A list of data frames that each contain a column for turn angle.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Provide a data frame that includes a column with bearing data

 servosphere &lt;- list(data.frame(id = rep(1, 200),
                                stimulus = rep(c(0, 1), each = 100),
                                dT = sample(8:12, 200, replace = TRUE),
                                dx = runif(200, 0, 5),
                                dy = runif(200, 0, 5),
                                treatment = rep("a", 200),
                                date = rep("2032018", 200)),
                     data.frame(id = rep(2, 200),
                                stimulus = rep(c(0, 1), each = 100),
                                dT = sample(8:12, 200, replace = TRUE),
                                dx = runif(200, 0, 5),
                                dy = runif(200, 0, 5),
                                treatment = rep("b", 200),
                                date = rep("2032018", 200)))
servosphere &lt;- calcXY(servosphere)
servosphere &lt;- calcBearing(servosphere)
servosphere &lt;- calcTurnAngle(servosphere)
</code></pre>

<hr>
<h2 id='calcTurnVelocity'>Calculate turn velocity</h2><span id='topic+calcTurnVelocity'></span>

<h3>Description</h3>

<p>Calculate the turning velocity in degrees per second between two moves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcTurnVelocity(list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcTurnVelocity_+3A_list">list</code></td>
<td>
<p>A list of data frames, where each data frame has a column for
turn angle.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For this function to work, the data must have previously been processed with
the <code>calcTurnAngle</code> function.
</p>
<p>This function calculates the turning velocity between two consecutive moves.
The units for turn velocity will be degrees per second.
</p>
<p>If the data will be aggregated, it is recommended to aggregate the data before
running this function.
</p>


<h3>Value</h3>

<p>A list of data frames that each contain a column for turn velocity.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Provide data previously processed by the calcTurnAngle function

 servosphere &lt;- list(data.frame(id = rep(1, 200),
                                stimulus = rep(c(0, 1), each = 100),
                                dT = sample(8:12, 200, replace = TRUE),
                                dx = runif(200, 0, 5),
                                dy = runif(200, 0, 5),
                                treatment = rep("a", 200),
                                date = rep("2032018", 200)),
                     data.frame(id = rep(2, 200),
                                stimulus = rep(c(0, 1), each = 100),
                                dT = sample(8:12, 200, replace = TRUE),
                                dx = runif(200, 0, 5),
                                dy = runif(200, 0, 5),
                                treatment = rep("b", 200),
                                date = rep("2032018", 200)))
servosphere &lt;- calcXY(servosphere)
servosphere &lt;- calcBearing(servosphere)
servosphere &lt;- calcTurnAngle(servosphere)
servosphere &lt;- calcTurnVelocity(servosphere)
</code></pre>

<hr>
<h2 id='calcVelocity'>Calculate velocity</h2><span id='topic+calcVelocity'></span>

<h3>Description</h3>

<p>Calculate the average velocity between two location recordings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcVelocity(list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcVelocity_+3A_list">list</code></td>
<td>
<p>A list of data frames, where each data frame has a column for dT,
dx, and dy.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the velocity of the organism on the servosphere
between two location recordings. The units for velocity will be distance per
second, where distance is the units of distance used by the software in
recording the movement of the organism. For example, if the software recorded
distance in centimeters, the units for velocity will be centimeters per
second.
</p>
<p>If the data will be aggregated, it is recommended to aggregate the data before
running this function.
</p>


<h3>Value</h3>

<p>A list of data frames that each contain a column for velocity.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> servosphere &lt;- list(data.frame(id = rep(1, 200),
                                stimulus = rep(c(0, 1), each = 100),
                                dT = sample(8:12, 200, replace = TRUE),
                                dx = runif(200, 0, 5),
                                dy = runif(200, 0, 5),
                                treatment = rep("a", 200),
                                date = rep("2032018", 200)),
                     data.frame(id = rep(2, 200),
                                stimulus = rep(c(0, 1), each = 100),
                                dT = sample(8:12, 200, replace = TRUE),
                                dx = runif(200, 0, 5),
                                dy = runif(200, 0, 5),
                                treatment = rep("b", 200),
                                date = rep("2032018", 200)))

servosphere &lt;- calcVelocity(servosphere)
</code></pre>

<hr>
<h2 id='calcXY'>Calculate (x, y) coordinates</h2><span id='topic+calcXY'></span>

<h3>Description</h3>

<p>Calculates (x,y) coordinates from dx and dy values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcXY(list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcXY_+3A_list">list</code></td>
<td>
<p>A list of data frame objects with columns dx and dy.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use the dx and dy columns in the servosphere data frames to calculate the (x,
y) coordinate for each position recording. If the data will be aggregated, it is
recommended to aggregate the data before running this function.
</p>


<h3>Value</h3>

<p>Converts dx and dy values to (x, y) coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> servosphere &lt;- list(data.frame(id = rep(1, 200),
                                stimulus = rep(c(0, 1), each = 100),
                                dT = sample(8:12, 200, replace = TRUE),
                                dx = runif(200, 0, 5),
                                dy = runif(200, 0, 5),
                                treatment = rep("a", 200),
                                date = rep("2032018", 200)),
                     data.frame(id = rep(2, 200),
                                stimulus = rep(c(0, 1), each = 100),
                                dT = sample(8:12, 200, replace = TRUE),
                                dx = runif(200, 0, 5),
                                dy = runif(200, 0, 5),
                                treatment = rep("b", 200),
                                date = rep("2032018", 200)))
servosphere &lt;- calcXY(servosphere)
</code></pre>

<hr>
<h2 id='cleanNames'>Set column names for list of data frames</h2><span id='topic+cleanNames'></span>

<h3>Description</h3>

<p>Take a list of data frames and change the column names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleanNames(list, colnames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cleanNames_+3A_list">list</code></td>
<td>
<p>A list of data frame objects.</p>
</td></tr>
<tr><td><code id="cleanNames_+3A_colnames">colnames</code></td>
<td>
<p>A vector of strings holding the names for the columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Once a list of data frames is generated with the getFiles function, use this
function to set up the column names for all the data frames in the list.
</p>
<p>Other functions in this package require that the change in time and position
columns are named &quot;dT&quot;, &quot;dx&quot;, and &quot;dy&quot;, respectively.
</p>


<h3>Value</h3>

<p>Returns the list of data frames provided with the column names
modified based on the provided vector <code>colnames</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>colnames &lt;- c("stimulus", "dT", "dx", "dy")
servosphere &lt;- cleanNames(servosphere, colnames)
</code></pre>

<hr>
<h2 id='getFiles'>Return a list of data frames generated from the servosphere</h2><span id='topic+getFiles'></span>

<h3>Description</h3>

<p>Import all the .csv files in a single directory and convert
them to a list of data frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFiles(path, pattern, full.names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFiles_+3A_path">path</code></td>
<td>
<p>A string for the file path.</p>
</td></tr>
<tr><td><code id="getFiles_+3A_pattern">pattern</code></td>
<td>
<p>A string with a unique pattern to look for in file names.</p>
</td></tr>
<tr><td><code id="getFiles_+3A_full.names">full.names</code></td>
<td>
<p>Return the full file path when TRUE or the file name when
FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using the servosphere, each trial produces a .csv file that contains the
data from that trial. This data should include a column for time (dT),
position (dX, dY), and the stimulus. All the data files the user wishes to
analyze should be in the same directory. They should also have a common
naming convention to facilitate the identification of these files (i.e.
&quot;x_servosphere.csv&quot;, where x might be the date the trial was run or the
unique trial ID).
</p>
<p>Other functions in this package require that all the .csv files from the
servosphere that the user wishes to analyze are contained in a list, where
each item in the list is a data.table created from each .csv file.
</p>
<p>This function makes use of the data.table package to read in the .csv files,
as it is currently the fastest way to bring in such files. This function is
noticeably slower when alternative csv reading functions are used and when
the number of .csv files is large.
</p>


<h3>Value</h3>

<p>A list where each item is a data.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>servosphere &lt;- getFiles("./extdata/", pattern = "_servosphere.csv")
</code></pre>

<hr>
<h2 id='mergeTrialInfo'>Merge trial id information</h2><span id='topic+mergeTrialInfo'></span>

<h3>Description</h3>

<p>This function merges trial id information with the servosphere data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeTrialInfo(list, trial.data, col.names, stimulus.keep,
  stimulus.split = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeTrialInfo_+3A_list">list</code></td>
<td>
<p>The list of servosphere output data.</p>
</td></tr>
<tr><td><code id="mergeTrialInfo_+3A_trial.data">trial.data</code></td>
<td>
<p>The data frame containing your trial id information. This
must contain an identifier column titled 'id' and if the data are to be
split by stimuli, an additional identifier column 'id_stim'. See the
description for more details.</p>
</td></tr>
<tr><td><code id="mergeTrialInfo_+3A_col.names">col.names</code></td>
<td>
<p>A string vector containing the names of the columns you want
to transfer to your servosphere output data. The trial.data data frame may
have columns not needed for the analysis, so the function asks the user to
be explicit about which columns to retain.</p>
</td></tr>
<tr><td><code id="mergeTrialInfo_+3A_stimulus.keep">stimulus.keep</code></td>
<td>
<p>An integer vector containing the stimuli numbers to
retained in the data and split the data frames by. Omitted stimuli values
will be discarded.</p>
</td></tr>
<tr><td><code id="mergeTrialInfo_+3A_stimulus.split">stimulus.split</code></td>
<td>
<p>A logical value indicating whether the data frames
should be split by stimulus. Defaults to 'FALSE'. If 'TRUE', be sure to
include a 'id_stim' column to give each trial/stimulus combination a unique
ID.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users of the servosphere will need a separate data frame with trial id
information in a column titled <code>id</code>. This should contain a unique
identifier and any other relevant experimental information, such as
treatments applied, date, time of day, etc. Make sure the rows in your trial
id data frame are ordered in the same order as the list of data frames of
your servosphere output.
</p>
<p>Researchers may wish to compare data before and after some stimulus has been
applied and this function allows the user to split their data into separate
data frames based on different values of the stimulus variable to facilitate
these comparison. If the data frames should be split by stimulus, the trial
record data frame should contain a column <code>id_stim</code> that lists the id
number of the trial, followed by an underscore, followed by each value of the
stimulus variable retained. If the data should be split by stimulus, the rows
of the trial id data frame should be ordered first by <code>id</code> in the same
order as their data is stored within the list. Once ordered by <code>id</code> the
trial data data frame should be further ordered within an <code>id</code> by
<code>stimulus</code> (i.e. id_stim 1_1 should come before id_stim 1_2).
</p>
<p>Data recorded during a particular stimuli may also be discarded if it is not
required for analysis. For example, recordings may begin with a five minute
adjustment period and the data associated with that period may not be used
for analysis. The stimulus recorded by the software during that five minute
adjustment period can be discarded by omitting that stimulus number from the
<code>stimulus.keep</code> argument.
</p>
<p>This function will also append an item to your list of data frames that
contains the relevant column names to be retained in future manipulations of
the data.
</p>


<h3>Value</h3>

<p>Returns the list of data frames provided which have been merged with
additional relevant trial information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> servosphere &lt;- list(data.frame(id = rep(1, 200),
                                stimulus = rep(c(0, 1), each = 100),
                                dT = sample(8:12, 200, replace = TRUE),
                                dx = runif(200, 0, 5),
                                dy = runif(200, 0, 5),
                                treatment = rep("a", 200),
                                date = rep("2032018", 200)),
                     data.frame(id = rep(2, 200),
                                stimulus = rep(c(0, 1), each = 100),
                                dT = sample(8:12, 200, replace = TRUE),
                                dx = runif(200, 0, 5),
                                dy = runif(200, 0, 5),
                                treatment = rep("b", 200),
                                date = rep("2032018", 200)))
 trial_record &lt;- data.frame(id = c(1, 2),
                            treatment = c("a", "b"),
                            date = c("2032018", "2042018"),
                            time = c("13:30", "07:30"))
 trial_id_split &lt;- data.frame(id = c(1, 2, 1, 2),
                              stimulus = c(1, 1, 2, 2),
                              treatment = c("a", "b", "a", "b"),
                              date = rep(c("2032018", "2042018"), times = 2),
                              time = rep(c("13:30", "07:30"), times = 2),
                              id_stim = c("1_1", "2_1", "1_2", "2_2"))
# Merge the columns id, treatment, and date from the trial_record data frame
# with all the data frames in our list servosphere.

 merged_servosphere &lt;- mergeTrialInfo(servosphere,
   trial_record,
   col.names = c("id", "treatment"),
   stimulus.keep = c(0, 1))

# Repeat of the merger above without retaining the id column while
# also splitting the data provided into separate data frames based on the
# different stimuli recorded, keeping only data associated with stimuli 1 and
# 2. Splitting based on stimulus requires a column in the trial.data data
# frame titled id_stim.

 merged_servosphere &lt;- mergeTrialInfo(servosphere,
     trial_id_split,
     col.names = c("id", "treatment"),
     stimulus.split = TRUE,
     stimulus.keep = c(0, 1))
</code></pre>

<hr>
<h2 id='servosphere'>Example servosphere data</h2><span id='topic+servosphere'></span>

<h3>Description</h3>

<p>A list containing two data frames of example data output from the software
used with a servosphere.This data has not been cleaned in anyway.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>servosphere
</code></pre>


<h3>Format</h3>

<p>A list of two data frames:
</p>

<dl>
<dt>X.cState</dt><dd><p>stimulus designator</p>
</dd>
<dt>dT..ms.</dt><dd><p>Change in time, in miliseconds</p>
</dd>
<dt>dx..cm.</dt><dd><p>Distance moved in X direction during dT, in centimeters</p>
</dd>
<dt>dY..cm.</dt><dd><p>Distance moved in Y direction during dT, in centimeters</p>
</dd>
</dl>

<hr>
<h2 id='summaryAvgBearing'>Calculate average bearing</h2><span id='topic+summaryAvgBearing'></span>

<h3>Description</h3>

<p>Calculate the average bearing, or direction of movement, for a movement path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryAvgBearing(list, summary.df = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryAvgBearing_+3A_list">list</code></td>
<td>
<p>A list of data frames, each of which has a column for bearing.</p>
</td></tr>
<tr><td><code id="summaryAvgBearing_+3A_summary.df">summary.df</code></td>
<td>
<p>The summary data frame containing a column recording
the bearing of each recorded movement.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bearing is the direction of movement and and falls between 0 and 360.
Outdoors degree measures of 0/360 will typically correspond to due north. For
servosphere data, 0/360 will correspond to the  movement in the direction of
the positive y-axis.
</p>


<h3>Value</h3>

<p>A list of two named vectors. The first named vector contains the
average bearing calculated for each movement path. The second named vector
contains the rho, a measure of concentration for the average bearing.
</p>

<hr>
<h2 id='summaryAvgVelocity'>Calculate average velocity</h2><span id='topic+summaryAvgVelocity'></span>

<h3>Description</h3>

<p>Calculate the average velocity for a movement path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryAvgVelocity(list, summary.df = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryAvgVelocity_+3A_list">list</code></td>
<td>
<p>A list of data frames, each of which has a column for velocity.</p>
</td></tr>
<tr><td><code id="summaryAvgVelocity_+3A_summary.df">summary.df</code></td>
<td>
<p>The data frame object within which you are storing path
summary variables. The default is NA if you do not currently have a summary
data frame object started. When set to <code>NA</code> the function will create a new
summary data frame. When an object is provided, the function will merge the
summary data frame with the new data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the average velocity for a movement path. The units on velocity are
equal to the distance units used to record the data per second.
</p>


<h3>Value</h3>

<p>The inputed summary data frame or a new data frame if summary.df is
<code>NA</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># If a summary data frame has not been started

 servosphere &lt;- list(data.frame(id = rep(1, 200),
                                stimulus = rep(c(0, 1), each = 100),
                                dT = sample(8:12, 200, replace = TRUE),
                                dx = runif(200, 0, 5),
                                dy = runif(200, 0, 5),
                                treatment = rep("a", 200),
                                date = rep("2032018", 200)),
                     data.frame(id = rep(2, 200),
                                stimulus = rep(c(0, 1), each = 100),
                                dT = sample(8:12, 200, replace = TRUE),
                                dx = runif(200, 0, 5),
                                dy = runif(200, 0, 5),
                                treatment = rep("b", 200),
                                date = rep("2032018", 200)))
servosphere &lt;- calcVelocity(servosphere)

summary_df &lt;- summaryAvgVelocity(servosphere, summary.df = NA)
# If a summary data frame has been started

summary_df &lt;- data.frame(id = c(1, 2),
                         treatment = c("a", "b"),
                         date = c("2032018", "2042018"),
                         stimulus = c(0, 0))

summary_df &lt;- summaryAvgVelocity(servosphere, summary.df = summary_df)

</code></pre>

<hr>
<h2 id='summaryNetDisplacement'>Calculate net displacement</h2><span id='topic+summaryNetDisplacement'></span>

<h3>Description</h3>

<p>Calculate the net displacement for a path taken by an organism
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryNetDisplacement(list, summary.df = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryNetDisplacement_+3A_list">list</code></td>
<td>
<p>A list of data frames, each of which has a column representing dx
and dy.</p>
</td></tr>
<tr><td><code id="summaryNetDisplacement_+3A_summary.df">summary.df</code></td>
<td>
<p>The data frame object within which you are storing path
summary variables. The default is NA if you do not currently have a summary
data frame object started. When set to NA the function will create a new
summary data frame. When an object is provided, the function will merge the
summary data frame with the new data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Net displacement is the distance between the start of a path and the end of a
path. This function calculates the net displacement for a path recorded from
the servosphere.
</p>


<h3>Value</h3>

<p>A named vector of numbers where each number corresponds to the net
displacement of a movement path. The numbers are ordered and named as they
are in the data frames list.
</p>

<hr>
<h2 id='summaryStops'>Summarize the number and length of stops</h2><span id='topic+summaryStops'></span>

<h3>Description</h3>

<p>Caulculate how many times an insect stopped walking during its recorded
movement and the average length of those stops.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryStops(list, summary.df = NA, stop.threshold = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryStops_+3A_list">list</code></td>
<td>
<p>A list of data frames, each of which must have a column recording
the velocity variable.</p>
</td></tr>
<tr><td><code id="summaryStops_+3A_summary.df">summary.df</code></td>
<td>
<p>The data frame object within which you are storing path
summary variables. The default is NA if you do not currently have a summary
data frame object started. When set to <code>NA</code> the function will create a
new summary data frame. When an object is provided, the function will merge
the summary data frame with the new data.</p>
</td></tr>
<tr><td><code id="summaryStops_+3A_stop.threshold">stop.threshold</code></td>
<td>
<p>The velocity below which the insect is considered to be
stopped. The default is 0, but should be adjusted based on observations of
the insect and the recording equipment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates a path for the total number of stops made during the
recording, as well as the average length of those stops. The function
requires the user to provide a movement threshold, below which the insect is
considered to be stopped. The servosphere may record small movements of
insect appendages or side to side motion as movement but typically this will
be much slower than actual movement. Estimates of this threshold speed can be
obtained by comparing recordings of the data to videos of the actual movement
or in person observation.
</p>

<hr>
<h2 id='summaryTortuosity'>Calculate tortuosity</h2><span id='topic+summaryTortuosity'></span>

<h3>Description</h3>

<p>Calculate the tortuosity, or straightness, of a movement path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryTortuosity(summary.df, total.distance, net.displacement,
  inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryTortuosity_+3A_summary.df">summary.df</code></td>
<td>
<p>The summary data frame containing total distance and net
displacement for all movement paths</p>
</td></tr>
<tr><td><code id="summaryTortuosity_+3A_total.distance">total.distance</code></td>
<td>
<p>The unquoted variable name in a data frame containing
the total distance for all movement paths</p>
</td></tr>
<tr><td><code id="summaryTortuosity_+3A_net.displacement">net.displacement</code></td>
<td>
<p>The unquoted variable name in a data frame containing
the net displacement for all movement paths.</p>
</td></tr>
<tr><td><code id="summaryTortuosity_+3A_inverse">inverse</code></td>
<td>
<p>Defaults to <code>FALSE</code>. When set to <code>FALSE</code>, this
function calculates tortuosity as net displacement divided by total
distance. Setting inverse to <code>TRUE</code> causes the function to calculate
tortuosity as total distance divided by net displacement.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To use this function, a summary data frame must already exist containing a
column for total distance and net displacement (in other words, your data
should have been processed by <code>summaryTotalDistance</code> and
<code>summaryNetDisplacement</code>.
</p>
<p>Tortuosity is a measure of how straight a path is. There are different
methods for calculating path straightness. This function calculates
tortuosity as the quotient of net displacement and total distance by default.
The quotient can be reversed by setting inverse to <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>The inputed data frame of numbers where each number corresponds to
the tortuosity of a movement path. The numbers are ordered and named as
they are in the data frames list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate tortuosity as the ratio of net displacement to total distance

summary_df &lt;- data.frame(id = c(1, 2),
                         treatment = c("a", "b"),
                         date = c("2032018", "2042018"),
                         stimulus = c(0, 0),
                         total_distance = runif(2, 11, 20),
                         net_displacement = runif(2, 5, 10))

summary_df &lt;- summaryTortuosity(summary.df = summary_df,
  total.distance = total_distance,
  net.displacement = net_displacement)

# Calculate tortuosity as the ratio of total distance to net displacement
# (the opposite of the previous example)

summary_df &lt;- summaryTortuosity(summary.df = summary_df,
  total.distance = total_distance,
  net.displacement = net_displacement,
  inverse = TRUE)
</code></pre>

<hr>
<h2 id='summaryTotalDistance'>Calculate total path distance</h2><span id='topic+summaryTotalDistance'></span>

<h3>Description</h3>

<p>Calculate the total distance moved by an organism on the servosphere
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryTotalDistance(list, summary.df = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryTotalDistance_+3A_list">list</code></td>
<td>
<p>A list of data frames, each of which has a column recording the
distance moved during each recording period.</p>
</td></tr>
<tr><td><code id="summaryTotalDistance_+3A_summary.df">summary.df</code></td>
<td>
<p>The data frame object within which you are storing path
summary variables. The default is NA if you do not currently have a summary
data frame object started. When set to NA the function will create a new
summary data frame. When an object is provided, the function will merge the
summary data frame with the new data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Determine the total distance of a path taken by an organism on a servosphere.
</p>


<h3>Value</h3>

<p>A named vector of numbers where each number corresponds to the total
distance moved by an organism represented in the list of data frames. The
numbers are ordered and named as they are in the data frames list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># If a summary data frame has not been started

 servosphere &lt;- list(data.frame(id = rep(1, 200),
                                stimulus = rep(c(0, 1), each = 100),
                                dT = sample(8:12, 200, replace = TRUE),
                                dx = runif(200, 0, 5),
                                dy = runif(200, 0, 5),
                                treatment = rep("a", 200),
                                date = rep("2032018", 200)),
                     data.frame(id = rep(2, 200),
                                stimulus = rep(c(0, 1), each = 100),
                                dT = sample(8:12, 200, replace = TRUE),
                                dx = runif(200, 0, 5),
                                dy = runif(200, 0, 5),
                                treatment = rep("b", 200),
                                date = rep("2032018", 200)))

servosphere &lt;- calcDistance(servosphere)

summary_df &lt;- summaryTotalDistance(servosphere, summary.df = NA)

# If a summary data frame has been started

summary_df &lt;- data.frame(id = c(1, 2),
                         treatment = c("a", "b"),
                         date = c("2032018", "2042018"),
                         stimulus = c(0, 0))

summary_df &lt;- summaryTotalDistance(servosphere, summary.df = summary_df)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
