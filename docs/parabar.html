<!DOCTYPE html><html lang="en"><head><title>Help for package parabar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {parabar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#parabar-package'><p>Progress Bar for Parallel Tasks</p></a></li>
<li><a href='#AsyncBackend'><p>AsyncBackend</p></a></li>
<li><a href='#Backend'><p>Backend</p></a></li>
<li><a href='#BackendFactory'><p>BackendFactory</p></a></li>
<li><a href='#BackendService'><p>BackendService</p></a></li>
<li><a href='#Bar'><p>Bar</p></a></li>
<li><a href='#BarFactory'><p>BackendFactory</p></a></li>
<li><a href='#BasicBar'><p>BasicBar</p></a></li>
<li><a href='#clear'><p>Clear a Backend</p></a></li>
<li><a href='#configure_bar'><p>Configure The Progress Bar</p></a></li>
<li><a href='#Context'><p>Context</p></a></li>
<li><a href='#ContextFactory'><p>ContextFactory</p></a></li>
<li><a href='#evaluate'><p>Evaluate An Expression On The Backend</p></a></li>
<li><a href='#Exception'><p>Package Exceptions</p></a></li>
<li><a href='#export'><p>Export Objects To a Backend</p></a></li>
<li><a href='#get_option'><p>Get or Set Package Option</p></a></li>
<li><a href='#Helper'><p>Package Helpers</p></a></li>
<li><a href='#LOGO'><p>The Package Logo</p></a></li>
<li><a href='#make_logo'><p>Generate Package Logo</p></a></li>
<li><a href='#ModernBar'><p>ModernBar</p></a></li>
<li><a href='#Options'><p>Class for Package Options</p></a></li>
<li><a href='#par_apply'><p>Run a Task in Parallel</p></a></li>
<li><a href='#par_lapply'><p>Run a Task in Parallel</p></a></li>
<li><a href='#par_sapply'><p>Run a Task in Parallel</p></a></li>
<li><a href='#peek'><p>Inspect a Backend</p></a></li>
<li><a href='#ProgressTrackingContext'><p>ProgressTrackingContext</p></a></li>
<li><a href='#SessionState'><p>SessionState</p></a></li>
<li><a href='#Specification'><p>Specification</p></a></li>
<li><a href='#start_backend'><p>Start a Backend</p></a></li>
<li><a href='#stop_backend'><p>Stop a Backend</p></a></li>
<li><a href='#SyncBackend'><p>SyncBackend</p></a></li>
<li><a href='#TaskState'><p>TaskState</p></a></li>
<li><a href='#UserApiConsumer'><p>UserApiConsumer</p></a></li>
<li><a href='#Warning'><p>Package Warnings</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Progress Bar for Parallel Tasks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.2</td>
</tr>
<tr>
<td>Description:</td>
<td>A simple interface in the form of R6 classes for executing tasks in
    parallel, tracking their progress, and displaying accurate progress bars.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://parabar.mihaiconstantin.com">https://parabar.mihaiconstantin.com</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mihaiconstantin/parabar/issues">https://github.com/mihaiconstantin/parabar/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, progress, parallel, callr, filelock, utils</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'TaskState.R' 'Options.R' 'Helper.R' 'Exception.R'
'Specification.R' 'BackendService.R' 'Backend.R'
'AsyncBackend.R' 'SyncBackend.R' 'BackendFactory.R' 'Bar.R'
'ModernBar.R' 'BasicBar.R' 'BarFactory.R' 'Context.R'
'ProgressTrackingContext.R' 'ContextFactory.R' 'SessionState.R'
'Warning.R' 'UserApiConsumer.R' 'exports.R' 'logo.R'
'parabar-package.R'</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-16 23:10:06 UTC; mihai</td>
</tr>
<tr>
<td>Author:</td>
<td>Mihai Constantin <a href="https://orcid.org/0000-0002-6460-0107"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mihai Constantin &lt;mihai@mihaiconstantin.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-17 08:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='parabar-package'>Progress Bar for Parallel Tasks</h2><span id='topic+parabar'></span><span id='topic+parabar-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A simple interface in the form of R6 classes for executing tasks in parallel, tracking their progress, and displaying accurate progress bars.
</p>


<h3>Details</h3>

<p>The package is aimed at two audiences: (1) end-users who want to execute a
task in parallel in an interactive <code>R</code> session and track the execution
progress, and (2) <code>R</code> package developers who want to use <code><a href="#topic+parabar">parabar</a></code>
as a solution for parallel processing in their packages.
</p>


<h3>Users</h3>

<p>For the first category of users, <code><a href="#topic+parabar">parabar</a></code> provides several main
functions of interest:
</p>

<ul>
<li> <p><code><a href="#topic+start_backend">start_backend()</a></code>: creates a parallel backend for executing tasks
according to the specifications provided.
</p>
</li>
<li> <p><code><a href="#topic+stop_backend">stop_backend()</a></code>: stops an active backend and makes the <code><a href="R6.html#topic+R6Class">R6::R6</a></code>
eligible for garbage collection.
</p>
</li>
<li> <p><code><a href="#topic+par_sapply">par_sapply()</a></code>: is a drop-in replacement for the built-in
<code><a href="base.html#topic+lapply">base::sapply()</a></code> function when no backend is provided. However, when a
backend is provided, the function will execute a task in parallel on the
backend, similar to the built-in function <code><a href="parallel.html#topic+clusterApply">parallel::parSapply()</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+par_lapply">par_lapply()</a></code>: is a drop-in replacement for the built-in
<code><a href="base.html#topic+lapply">base::lapply()</a></code> function when no backend is provided. However, when a
backend is provided, the function will execute a task in parallel on the
backend, similar to the built-in function <code><a href="parallel.html#topic+clusterApply">parallel::parLapply()</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+par_apply">par_apply()</a></code>: is a drop-in replacement for the built-in
<code><a href="base.html#topic+apply">base::apply()</a></code> function when no backend is provided. However, when a
backend is provided, the function will execute a task in parallel on the
backend, similar to the built-in function <code><a href="parallel.html#topic+clusterApply">parallel::parApply()</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+clear">clear()</a></code>: removes all variables available on a backend.
</p>
</li>
<li> <p><code><a href="#topic+peek">peek()</a></code>: returns the names of all variables available on a
backend.
</p>
</li>
<li> <p><code><a href="#topic+export">export()</a></code>: exports objects from a specified environment to a
backend.
</p>
</li>
<li> <p><code><a href="#topic+evaluate">evaluate()</a></code>: evaluates arbitrary and unquoted expression on a
backend.
</p>
</li></ul>

<p><code><a href="#topic+parabar">parabar</a></code> also provides a function <code><a href="#topic+configure_bar">configure_bar()</a></code> for
configuring the progress bar, and three functions can be used to get and set
the package options:
</p>

<ul>
<li> <p><code><a href="#topic+get_option">get_option()</a></code>: gets the value of a package option.
</p>
</li>
<li> <p><code><a href="#topic+set_option">set_option()</a></code>: sets the value of a package option.
</p>
</li>
<li> <p><code><a href="#topic+set_default_options">set_default_options()</a></code>: sets default values for all package
options. This function is automatically called on package load.
</p>
</li></ul>



<h3>Developers</h3>

<p>For the second category of users, <code><a href="#topic+parabar">parabar</a></code> provides a set of
classes (i.e., <code><a href="R6.html#topic+R6Class">R6::R6Class()</a></code>) that can be used to create backends (i.e.,
synchronous and asynchronous) and interact with them via a simple interface.
From a high-level perspective, the package consists of <strong><code>backends</code></strong> and
<strong><code>contexts</code></strong> in which these backends are employed for executing the tasks
in parallel.
</p>


<h4>Backends</h4>

<p>A <strong><code>backend</code></strong> represents a set of operations, defined by the
<code><a href="#topic+BackendService">BackendService</a></code> interface, that can be deployed on a cluster
returned by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>. Backends can be synchronous (i.e.,
<code><a href="#topic+SyncBackend">SyncBackend</a></code>) or asynchronous (i.e., <code><a href="#topic+AsyncBackend">AsyncBackend</a></code>).
The former will block the execution of the current <code>R</code> session until the
parallel task is completed, while the latter will return immediately and the
task will be executed in a background <code>R</code> session.
</p>
<p>The <code><a href="#topic+BackendService">BackendService</a></code> interface defines the following operations:
<code><a href="#topic+BackendService">start()</a></code>, <code><a href="#topic+BackendService">stop()</a></code>,
<code><a href="#topic+BackendService">clear()</a></code>, <code><a href="#topic+BackendService">peek()</a></code>,
<code><a href="#topic+BackendService">export()</a></code>,
<code><a href="#topic+BackendService">evaluate()</a></code>,
<code><a href="#topic+BackendService">sapply()</a></code>, <code><a href="#topic+BackendService">lapply()</a></code>,
<code><a href="#topic+BackendService">apply()</a></code>, and
<code><a href="#topic+BackendService">get_output()</a></code>.
</p>
<p>Check out the documentation for <code><a href="#topic+BackendService">BackendService</a></code> for more
information on each method.
</p>



<h4>Contexts</h4>

<p>A <strong><code>context</code></strong> represents the specific conditions in which the backend
operates. The default, regular <code><a href="#topic+Context">Context</a></code> class simply forwards the
call to the corresponding backend method. However, a more complex context can
augment the operation before forwarding the call to the backend. One example
of a complex context is the <code><a href="#topic+ProgressTrackingContext">ProgressTrackingContext</a></code> class. This
class extends the regular <code><a href="#topic+Context">Context</a></code> class and decorates, for
example, the backend <code><a href="#topic+BackendService">sapply()</a></code> operation to log
the progress after each task execution and display a progress bar.
</p>
<p>The following are the main classes provided by <code>parabar</code>:
</p>

<ul>
<li> <p><code><a href="#topic+BackendService">BackendService</a></code>: interface for backend operations.
</p>
</li>
<li> <p><code><a href="#topic+Backend">Backend</a></code>: abstract class that serves as a base class for all
concrete implementations.
</p>
</li>
<li> <p><code><a href="#topic+SyncBackend">SyncBackend</a></code>: synchronous backend extending the abstract
<code><a href="#topic+Backend">Backend</a></code> class.
</p>
</li>
<li> <p><code><a href="#topic+AsyncBackend">AsyncBackend</a></code>: asynchronous backend extending the abstract
<code><a href="#topic+Backend">Backend</a></code> class.
</p>
</li>
<li> <p><code><a href="#topic+Specification">Specification</a></code>: backend specification used when starting a
backend.
</p>
</li>
<li> <p><code><a href="#topic+TaskState">TaskState</a></code>: determine the state of a task deployed to an
asynchronous backend.
</p>
</li>
<li> <p><code><a href="#topic+BackendFactory">BackendFactory</a></code>: factory for creating backend objects.
</p>
</li>
<li> <p><code><a href="#topic+Context">Context</a></code>: default context for executing backend operations.
</p>
</li>
<li> <p><code><a href="#topic+ProgressTrackingContext">ProgressTrackingContext</a></code>: context for decorating the
<code><a href="#topic+BackendService">sapply()</a></code>,
<code><a href="#topic+BackendService">lapply()</a></code>, and
<code><a href="#topic+BackendService">apply()</a></code> operations to track and display the
execution progress.
</p>
</li>
<li> <p><code><a href="#topic+ContextFactory">ContextFactory</a></code>: factory for creating context objects.
</p>
</li>
<li> <p><code><a href="#topic+UserApiConsumer">UserApiConsumer</a></code>: opinionated wrapper around the other
<code><a href="R6.html#topic+R6Class">R6::R6</a></code> classes used in by the exported functions for the users.
</p>
</li></ul>




<h3>Progress Bars</h3>

<p><code><a href="#topic+parabar">parabar</a></code> also exposes several classes for creating and updating
different progress bars, namely:
</p>

<ul>
<li> <p><code><a href="#topic+Bar">Bar</a></code>: abstract class defining the pure virtual methods to be
implemented by concrete bar classes.
</p>
</li>
<li> <p><code><a href="#topic+BasicBar">BasicBar</a></code>: a simple, but robust, bar created via
<code><a href="utils.html#topic+txtProgressBar">utils::txtProgressBar()</a></code> extending the <code><a href="#topic+Bar">Bar</a></code> abstract class.
</p>
</li>
<li> <p><code><a href="#topic+ModernBar">ModernBar</a></code>: a modern bar created via <code><a href="progress.html#topic+progress_bar">progress::progress_bar</a></code>
extending the <code><a href="#topic+Bar">Bar</a></code> abstract class.
</p>
</li>
<li> <p><code><a href="#topic+BarFactory">BarFactory</a></code>: factory for creating bar objects.
</p>
</li></ul>

<p>Finally, <code><a href="#topic+parabar">parabar</a></code> uses several <code><a href="base.html#topic+options">base::options()</a></code> to configure the
behavior of the functionality it provides. For more information on the
options used and their see default values, see the <code><a href="#topic+Options">Options</a></code>
class.
</p>
<p>For more information about the design of <code><a href="#topic+parabar">parabar</a></code>, check out the
documentation and the <code>UML</code> diagram at
<a href="https://parabar.mihaiconstantin.com">parabar.mihaiconstantin.com</a>.
</p>

<div style="display: block; text-align: center">
<div style="display: block; margin-top: 1rem; margin-bottom: 0.5rem">
<p><strong>Software Design</strong>
</p>
</div>
<p><img src="../help/figures/parabar-design.png" style="max-width: 95%;" alt="parabar Software Design" />
</p>
</div>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Mihai Constantin <a href="mailto:mihai@mihaiconstantin.com">mihai@mihaiconstantin.com</a> (<a href="https://orcid.org/0000-0002-6460-0107">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://parabar.mihaiconstantin.com">https://parabar.mihaiconstantin.com</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mihaiconstantin/parabar/issues">https://github.com/mihaiconstantin/parabar/issues</a>
</p>
</li></ul>


<hr>
<h2 id='AsyncBackend'>AsyncBackend</h2><span id='topic+AsyncBackend'></span>

<h3>Description</h3>

<p>This is a concrete implementation of the abstract class <code><a href="#topic+Backend">Backend</a></code>
that implements the <code><a href="#topic+BackendService">BackendService</a></code> interface. This backend
executes tasks in parallel asynchronously (i.e., without blocking the main
<code>R</code> session) on a <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code> cluster created in a background
<code>R</code> <code><a href="callr.html#topic+r_session">session</a></code>.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+BackendService">parabar::BackendService</a></code> -&gt; <code><a href="#topic+Backend">parabar::Backend</a></code> -&gt; <code>AsyncBackend</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>task_state</code></dt><dd><p>A list of logical values indicating the state of
the task execution. See the <code><a href="#topic+TaskState">TaskState</a></code> class for more
information on how the statues are determined. The following statuses
are available:
</p>

<ul>
<li> <p><code>task_not_started</code>: Indicates whether the backend is free. <code>TRUE</code>
signifies that no task has been started and the backend is free to
deploy.
</p>
</li>
<li> <p><code>task_is_running</code>: Indicates whether a task is currently running on
the backend.
</p>
</li>
<li> <p><code>task_is_completed</code>: Indicates whether a task has finished
executing. <code>TRUE</code> signifies that the output of the task has not been
fetched. Calling the method <code>get_option()</code> will move the output from
the background <code>R</code> session to the main <code>R</code> session. Once the output
has been fetched, the backend is free to deploy another task.
</p>
</li></ul>
</dd>
<dt><code>session_state</code></dt><dd><p>A list of logical values indicating the state of
the background session managing the cluster. See the
<code><a href="#topic+SessionState">SessionState</a></code> class for more information on the available
statuses. The following statuses are available:
</p>

<ul>
<li> <p><code>session_is_starting</code>: Indicates whether the session is starting.
</p>
</li>
<li> <p><code>session_is_idle</code>: Indicates whether the session is idle.
</p>
</li>
<li> <p><code>session_is_busy</code>: Indicates whether the session is busy. A session
is busy when a task is running or when the output of a task has not
been fetched into the main <code>R</code> session. See the <code>task_state</code> field.
</p>
</li>
<li> <p><code>session_is_finished</code>: Indicates whether the session was closed.
</p>
</li></ul>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AsyncBackend-new"><code>AsyncBackend$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncBackend-start"><code>AsyncBackend$start()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncBackend-stop"><code>AsyncBackend$stop()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncBackend-clear"><code>AsyncBackend$clear()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncBackend-peek"><code>AsyncBackend$peek()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncBackend-export"><code>AsyncBackend$export()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncBackend-evaluate"><code>AsyncBackend$evaluate()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncBackend-sapply"><code>AsyncBackend$sapply()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncBackend-lapply"><code>AsyncBackend$lapply()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncBackend-apply"><code>AsyncBackend$apply()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncBackend-get_output"><code>AsyncBackend$get_output()</code></a>
</p>
</li>
<li> <p><a href="#method-AsyncBackend-clone"><code>AsyncBackend$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-AsyncBackend-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code><a href="#topic+AsyncBackend">AsyncBackend</a></code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncBackend$new()</pre></div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+AsyncBackend">AsyncBackend</a></code>.
</p>


<hr>
<a id="method-AsyncBackend-start"></a>



<h4>Method <code>start()</code></h4>

<p>Start the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncBackend$start(specification)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>specification</code></dt><dd><p>An object of class <code><a href="#topic+Specification">Specification</a></code>
that contains the backend configuration.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns void. The resulting backend must be stored in the
<code>.cluster</code> private field on the <code><a href="#topic+Backend">Backend</a></code> abstract class,
and accessible to any concrete backend implementations via the active
binding <code>cluster</code>.
</p>


<hr>
<a id="method-AsyncBackend-stop"></a>



<h4>Method <code>stop()</code></h4>

<p>Stop the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncBackend$stop()</pre></div>



<h5>Returns</h5>

<p>This method returns void.
</p>


<hr>
<a id="method-AsyncBackend-clear"></a>



<h4>Method <code>clear()</code></h4>

<p>Remove all objects from the backend. This function is equivalent to
calling <code>rm(list = ls(all.names = TRUE))</code> on each node in the
backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncBackend$clear()</pre></div>



<h5>Returns</h5>

<p>This method returns void.
</p>


<hr>
<a id="method-AsyncBackend-peek"></a>



<h4>Method <code>peek()</code></h4>

<p>Inspect the backend for variables available in the <code>.GlobalEnv</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncBackend$peek()</pre></div>



<h5>Returns</h5>

<p>This method returns a list of character vectors, where each element
corresponds to a node in the backend. The character vectors contain
the names of the variables available in the <code>.GlobalEnv</code> on each
node.
</p>


<hr>
<a id="method-AsyncBackend-export"></a>



<h4>Method <code>export()</code></h4>

<p>Export variables from a given environment to the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncBackend$export(variables, environment)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>variables</code></dt><dd><p>A character vector of variable names to export.</p>
</dd>
<dt><code>environment</code></dt><dd><p>An environment object from which to export the
variables.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns void.
</p>


<hr>
<a id="method-AsyncBackend-evaluate"></a>



<h4>Method <code>evaluate()</code></h4>

<p>Evaluate an arbitrary expression on the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncBackend$evaluate(expression)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expression</code></dt><dd><p>An unquoted expression to evaluate on the backend.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns the result of the expression evaluation.
</p>


<hr>
<a id="method-AsyncBackend-sapply"></a>



<h4>Method <code>sapply()</code></h4>

<p>Run a task on the backend akin to <code><a href="parallel.html#topic+clusterApply">parallel::parSapply()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncBackend$sapply(x, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>An atomic vector or list to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>fun</code></dt><dd><p>A function to apply to each element of <code>x</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code><a href="#topic+Backend">Backend</a></code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-AsyncBackend-lapply"></a>



<h4>Method <code>lapply()</code></h4>

<p>Run a task on the backend akin to <code><a href="parallel.html#topic+clusterApply">parallel::parLapply()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncBackend$lapply(x, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>An atomic vector or list to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>fun</code></dt><dd><p>A function to apply to each element of <code>x</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code><a href="#topic+Backend">Backend</a></code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-AsyncBackend-apply"></a>



<h4>Method <code>apply()</code></h4>

<p>Run a task on the backend akin to <code><a href="parallel.html#topic+clusterApply">parallel::parApply()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncBackend$apply(x, margin, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>An array to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>margin</code></dt><dd><p>A numeric vector indicating the dimensions of <code>x</code> the
<code>fun</code> function should be applied over. For example, for a matrix,
<code>margin = 1</code> indicates applying <code>fun</code> rows-wise, <code>margin = 2</code>
indicates applying <code>fun</code> columns-wise, and <code>margin = c(1, 2)</code>
indicates applying <code>fun</code> element-wise. Named dimensions are also
possible depending on <code>x</code>. See <code><a href="parallel.html#topic+clusterApply">parallel::parApply()</a></code> and
<code><a href="base.html#topic+apply">base::apply()</a></code> for more details.</p>
</dd>
<dt><code>fun</code></dt><dd><p>A function to apply to <code>x</code> according to the <code>margin</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code><a href="#topic+Backend">Backend</a></code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-AsyncBackend-get_output"></a>



<h4>Method <code>get_output()</code></h4>

<p>Get the output of the task execution.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncBackend$get_output(wait = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>wait</code></dt><dd><p>A logical value indicating whether to wait for the task
to finish executing before fetching the results. Defaults to <code>FALSE</code>.
See the <strong>Details</strong> section for more information.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This method fetches the output of the task execution after calling
the <code>sapply()</code> method. It returns the output and immediately removes
it from the backend. Subsequent calls to this method will throw an
error if no additional tasks have been executed in the meantime. This
method should be called after the execution of a task.
</p>
<p>If <code>wait = TRUE</code>, the method will block the main process until the
backend finishes executing the task and the results are available. If
<code>wait = FALSE</code>, the method will immediately attempt to fetch the
results from the background <code>R</code> session, and throw an error if the
task is still running.
</p>



<h5>Returns</h5>

<p>A vector, matrix, or list of the same length as <code>x</code>, containing the
results of the <code>fun</code>. The output format differs based on the specific
operation employed. Check out the documentation for the <code>apply</code>
operations of <code><a href="parallel.html#topic+parallel-package">parallel::parallel</a></code> for more information.
</p>


<hr>
<a id="method-AsyncBackend-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AsyncBackend$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+BackendService">BackendService</a></code>, <code><a href="#topic+Backend">Backend</a></code>, <code><a href="#topic+SyncBackend">SyncBackend</a></code>,
<code><a href="#topic+ProgressTrackingContext">ProgressTrackingContext</a></code>, and <code><a href="#topic+TaskState">TaskState</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a specification object.
specification &lt;- Specification$new()

# Set the number of cores.
specification$set_cores(cores = 2)

# Set the cluster type.
specification$set_type(type = "psock")

# Create an asynchronous backend object.
backend &lt;- AsyncBackend$new()

# Start the cluster on the backend.
backend$start(specification)

# Check if there is anything on the backend.
backend$peek()

# Create a dummy variable.
name &lt;- "parabar"

# Export the variable to the backend.
backend$export("name")

# Remove variable from current environment.
rm(name)

# Run an expression on the backend, using the exported variable `name`.
backend$evaluate({
    # Print the name.
    print(paste0("Hello, ", name, "!"))
})

# Run a task in parallel (i.e., approx. 2.5 seconds).
backend$sapply(
    x = 1:10,
    fun = function(x) {
        # Sleep a bit.
        Sys.sleep(0.5)

        # Compute something.
        output &lt;- x + 1

        # Return the result.
        return(output)
    }
)

# Right know the main process is free and the task is executing on a `psock`
# cluster started in a background `R` session.

# Trying to get the output immediately will throw an error, indicating that the
# task is still running.
try(backend$get_output())

# However, we can block the main process and wait for the task to complete
# before fetching the results.
backend$get_output(wait = TRUE)

# Clear the backend.
backend$clear()

# Check that there is nothing on the cluster.
backend$peek()

# Stop the backend.
backend$stop()

# Check that the backend is not active.
backend$active

</code></pre>

<hr>
<h2 id='Backend'>Backend</h2><span id='topic+Backend'></span>

<h3>Description</h3>

<p>This is an abstract class that serves as a base class for all concrete
backend implementations. It defines the common properties that all concrete
backends require.
</p>


<h3>Details</h3>

<p>This class cannot be instantiated. It needs to be extended by concrete
subclasses that implement the pure virtual methods. Instances of concrete
backend implementations can be conveniently obtained using the
<code><a href="#topic+BackendFactory">BackendFactory</a></code> class.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+BackendService">parabar::BackendService</a></code> -&gt; <code>Backend</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>cluster</code></dt><dd><p>The cluster object used by the backend. For
<code><a href="#topic+SyncBackend">SyncBackend</a></code> objects, this is a cluster object created by
<code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>. For <code><a href="#topic+AsyncBackend">AsyncBackend</a></code> objects,
this is a permanent <code>R</code> session created by <code><a href="callr.html#topic+r_session">callr::r_session</a></code> that
contains the <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code> cluster object.</p>
</dd>
<dt><code>supports_progress</code></dt><dd><p>A boolean value indicating whether the
backend implementation supports progress tracking.</p>
</dd>
<dt><code>active</code></dt><dd><p>A boolean value indicating whether the backend
implementation has an active cluster.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Backend-new"><code>Backend$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Backend-clone"><code>Backend$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="parabar" data-topic="BackendService" data-id="apply"><a href='../../parabar/html/BackendService.html#method-BackendService-apply'><code>parabar::BackendService$apply()</code></a></span></li>
<li><span class="pkg-link" data-pkg="parabar" data-topic="BackendService" data-id="clear"><a href='../../parabar/html/BackendService.html#method-BackendService-clear'><code>parabar::BackendService$clear()</code></a></span></li>
<li><span class="pkg-link" data-pkg="parabar" data-topic="BackendService" data-id="evaluate"><a href='../../parabar/html/BackendService.html#method-BackendService-evaluate'><code>parabar::BackendService$evaluate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="parabar" data-topic="BackendService" data-id="export"><a href='../../parabar/html/BackendService.html#method-BackendService-export'><code>parabar::BackendService$export()</code></a></span></li>
<li><span class="pkg-link" data-pkg="parabar" data-topic="BackendService" data-id="get_output"><a href='../../parabar/html/BackendService.html#method-BackendService-get_output'><code>parabar::BackendService$get_output()</code></a></span></li>
<li><span class="pkg-link" data-pkg="parabar" data-topic="BackendService" data-id="lapply"><a href='../../parabar/html/BackendService.html#method-BackendService-lapply'><code>parabar::BackendService$lapply()</code></a></span></li>
<li><span class="pkg-link" data-pkg="parabar" data-topic="BackendService" data-id="peek"><a href='../../parabar/html/BackendService.html#method-BackendService-peek'><code>parabar::BackendService$peek()</code></a></span></li>
<li><span class="pkg-link" data-pkg="parabar" data-topic="BackendService" data-id="sapply"><a href='../../parabar/html/BackendService.html#method-BackendService-sapply'><code>parabar::BackendService$sapply()</code></a></span></li>
<li><span class="pkg-link" data-pkg="parabar" data-topic="BackendService" data-id="start"><a href='../../parabar/html/BackendService.html#method-BackendService-start'><code>parabar::BackendService$start()</code></a></span></li>
<li><span class="pkg-link" data-pkg="parabar" data-topic="BackendService" data-id="stop"><a href='../../parabar/html/BackendService.html#method-BackendService-stop'><code>parabar::BackendService$stop()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-Backend-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code><a href="#topic+Backend">Backend</a></code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Backend$new()</pre></div>



<h5>Returns</h5>

<p>Instantiating this class will throw an error.
</p>


<hr>
<a id="method-Backend-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Backend$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+BackendService">BackendService</a></code>, <code><a href="#topic+SyncBackend">SyncBackend</a></code>,
<code><a href="#topic+AsyncBackend">AsyncBackend</a></code>, <code><a href="#topic+BackendFactory">BackendFactory</a></code>, and
<code><a href="#topic+Context">Context</a></code>.
</p>

<hr>
<h2 id='BackendFactory'>BackendFactory</h2><span id='topic+BackendFactory'></span>

<h3>Description</h3>

<p>This class is a factory that provides concrete implementations of the
<code><a href="#topic+Backend">Backend</a></code> abstract class.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-BackendFactory-get"><code>BackendFactory$get()</code></a>
</p>
</li>
<li> <p><a href="#method-BackendFactory-clone"><code>BackendFactory$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-BackendFactory-get"></a>



<h4>Method <code>get()</code></h4>

<p>Obtain a concrete implementation of the abstract <code><a href="#topic+Backend">Backend</a></code>
class of the specified type.
</p>


<h5>Usage</h5>

<div class="r"><pre>BackendFactory$get(type)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>A character string specifying the type of the
<code><a href="#topic+Backend">Backend</a></code> to instantiate. Possible values are <code>"sync"</code> and
<code>"async"</code>. See the <strong>Details</strong> section for more information.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>When <code>type = "sync"</code> a <code><a href="#topic+SyncBackend">SyncBackend</a></code> instance is created
and returned. When <code>type = "async"</code> an <code><a href="#topic+AsyncBackend">AsyncBackend</a></code>
instance is provided instead.
</p>



<h5>Returns</h5>

<p>A concrete implementation of the class <code><a href="#topic+Backend">Backend</a></code>. It
throws an error if the requested backend <code>type</code> is not supported.
</p>


<hr>
<a id="method-BackendFactory-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>BackendFactory$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+BackendService">BackendService</a></code>, <code><a href="#topic+Backend">Backend</a></code>, <code><a href="#topic+SyncBackend">SyncBackend</a></code>,
<code><a href="#topic+AsyncBackend">AsyncBackend</a></code>, and <code><a href="#topic+ContextFactory">ContextFactory</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a backend factory.
backend_factory &lt;- BackendFactory$new()

# Get a synchronous backend instance.
backend &lt;- backend_factory$get("sync")

# Check the class of the backend instance.
class(backend)

# Get an asynchronous backend instance.
backend &lt;- backend_factory$get("async")

# Check the class of the backend instance.
class(backend)

</code></pre>

<hr>
<h2 id='BackendService'>BackendService</h2><span id='topic+BackendService'></span>

<h3>Description</h3>

<p>This is an interface that defines the operations available on a
<code><a href="#topic+Backend">Backend</a></code> implementation. Backend implementations and the
<code><a href="#topic+Context">Context</a></code> class must implement this interface.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-BackendService-new"><code>BackendService$new()</code></a>
</p>
</li>
<li> <p><a href="#method-BackendService-start"><code>BackendService$start()</code></a>
</p>
</li>
<li> <p><a href="#method-BackendService-stop"><code>BackendService$stop()</code></a>
</p>
</li>
<li> <p><a href="#method-BackendService-clear"><code>BackendService$clear()</code></a>
</p>
</li>
<li> <p><a href="#method-BackendService-peek"><code>BackendService$peek()</code></a>
</p>
</li>
<li> <p><a href="#method-BackendService-export"><code>BackendService$export()</code></a>
</p>
</li>
<li> <p><a href="#method-BackendService-evaluate"><code>BackendService$evaluate()</code></a>
</p>
</li>
<li> <p><a href="#method-BackendService-sapply"><code>BackendService$sapply()</code></a>
</p>
</li>
<li> <p><a href="#method-BackendService-lapply"><code>BackendService$lapply()</code></a>
</p>
</li>
<li> <p><a href="#method-BackendService-apply"><code>BackendService$apply()</code></a>
</p>
</li>
<li> <p><a href="#method-BackendService-get_output"><code>BackendService$get_output()</code></a>
</p>
</li>
<li> <p><a href="#method-BackendService-clone"><code>BackendService$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-BackendService-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code><a href="#topic+BackendService">BackendService</a></code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>BackendService$new()</pre></div>



<h5>Returns</h5>

<p>Instantiating this class will throw an error.
</p>


<hr>
<a id="method-BackendService-start"></a>



<h4>Method <code>start()</code></h4>

<p>Start the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>BackendService$start(specification)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>specification</code></dt><dd><p>An object of class <code><a href="#topic+Specification">Specification</a></code>
that contains the backend configuration.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns void. The resulting backend must be stored in the
<code>.cluster</code> private field on the <code><a href="#topic+Backend">Backend</a></code> abstract class,
and accessible to any concrete backend implementations via the active
binding <code>cluster</code>.
</p>


<hr>
<a id="method-BackendService-stop"></a>



<h4>Method <code>stop()</code></h4>

<p>Stop the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>BackendService$stop()</pre></div>



<h5>Returns</h5>

<p>This method returns void.
</p>


<hr>
<a id="method-BackendService-clear"></a>



<h4>Method <code>clear()</code></h4>

<p>Remove all objects from the backend. This function is equivalent to
calling <code>rm(list = ls(all.names = TRUE))</code> on each node in the
backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>BackendService$clear()</pre></div>



<h5>Details</h5>

<p>This method is ran by default when the backend is started.
</p>



<h5>Returns</h5>

<p>This method returns void.
</p>


<hr>
<a id="method-BackendService-peek"></a>



<h4>Method <code>peek()</code></h4>

<p>Inspect the backend for variables available in the <code>.GlobalEnv</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>BackendService$peek()</pre></div>



<h5>Returns</h5>

<p>This method returns a list of character vectors, where each element
corresponds to a node in the backend. The character vectors contain
the names of the variables available in the <code>.GlobalEnv</code> on each
node.
</p>


<hr>
<a id="method-BackendService-export"></a>



<h4>Method <code>export()</code></h4>

<p>Export variables from a given environment to the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>BackendService$export(variables, environment)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>variables</code></dt><dd><p>A character vector of variable names to export.</p>
</dd>
<dt><code>environment</code></dt><dd><p>An environment object from which to export the
variables.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns void.
</p>


<hr>
<a id="method-BackendService-evaluate"></a>



<h4>Method <code>evaluate()</code></h4>

<p>Evaluate an arbitrary expression on the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>BackendService$evaluate(expression)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expression</code></dt><dd><p>An unquoted expression to evaluate on the backend.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns the result of the expression evaluation.
</p>


<hr>
<a id="method-BackendService-sapply"></a>



<h4>Method <code>sapply()</code></h4>

<p>Run a task on the backend akin to <code><a href="parallel.html#topic+clusterApply">parallel::parSapply()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>BackendService$sapply(x, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>An atomic vector or list to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>fun</code></dt><dd><p>A function to apply to each element of <code>x</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code><a href="#topic+Backend">Backend</a></code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-BackendService-lapply"></a>



<h4>Method <code>lapply()</code></h4>

<p>Run a task on the backend akin to <code><a href="parallel.html#topic+clusterApply">parallel::parLapply()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>BackendService$lapply(x, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>An atomic vector or list to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>fun</code></dt><dd><p>A function to apply to each element of <code>x</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code><a href="#topic+Backend">Backend</a></code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-BackendService-apply"></a>



<h4>Method <code>apply()</code></h4>

<p>Run a task on the backend akin to <code><a href="parallel.html#topic+clusterApply">parallel::parApply()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>BackendService$apply(x, margin, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>An array to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>margin</code></dt><dd><p>A numeric vector indicating the dimensions of <code>x</code> the
<code>fun</code> function should be applied over. For example, for a matrix,
<code>margin = 1</code> indicates applying <code>fun</code> rows-wise, <code>margin = 2</code>
indicates applying <code>fun</code> columns-wise, and <code>margin = c(1, 2)</code>
indicates applying <code>fun</code> element-wise. Named dimensions are also
possible depending on <code>x</code>. See <code><a href="parallel.html#topic+clusterApply">parallel::parApply()</a></code> and
<code><a href="base.html#topic+apply">base::apply()</a></code> for more details.</p>
</dd>
<dt><code>fun</code></dt><dd><p>A function to apply to <code>x</code> according to the <code>margin</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code><a href="#topic+Backend">Backend</a></code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-BackendService-get_output"></a>



<h4>Method <code>get_output()</code></h4>

<p>Get the output of the task execution.
</p>


<h5>Usage</h5>

<div class="r"><pre>BackendService$get_output(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Additional optional arguments that may be used by concrete
implementations.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This method fetches the output of the task execution after calling
the <code>sapply()</code> method. It returns the output and immediately removes
it from the backend. Therefore, subsequent calls to this method are
not advised. This method should be called after the execution of a
task.
</p>



<h5>Returns</h5>

<p>A vector, matrix, or list of the same length as <code>x</code>, containing the
results of the <code>fun</code>. The output format differs based on the specific
operation employed. Check out the documentation for the <code>apply</code>
operations of <code><a href="parallel.html#topic+parallel-package">parallel::parallel</a></code> for more information.
</p>


<hr>
<a id="method-BackendService-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>BackendService$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Backend">Backend</a></code>, <code><a href="#topic+SyncBackend">SyncBackend</a></code>, <code><a href="#topic+AsyncBackend">AsyncBackend</a></code>,
and <code><a href="#topic+Context">Context</a></code>.
</p>

<hr>
<h2 id='Bar'>Bar</h2><span id='topic+Bar'></span>

<h3>Description</h3>

<p>This is an abstract class that defines the pure virtual methods a concrete
bar must implement.
</p>


<h3>Details</h3>

<p>This class cannot be instantiated. It needs to be extended by concrete
subclasses that implement the pure virtual methods. Instances of concrete
backend implementations can be conveniently obtained using the
<code><a href="#topic+BarFactory">BarFactory</a></code> class.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>engine</code></dt><dd><p>The bar engine.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Bar-new"><code>Bar$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Bar-create"><code>Bar$create()</code></a>
</p>
</li>
<li> <p><a href="#method-Bar-update"><code>Bar$update()</code></a>
</p>
</li>
<li> <p><a href="#method-Bar-terminate"><code>Bar$terminate()</code></a>
</p>
</li>
<li> <p><a href="#method-Bar-clone"><code>Bar$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Bar-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code><a href="#topic+Bar">Bar</a></code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Bar$new()</pre></div>



<h5>Returns</h5>

<p>Instantiating this class will throw an error.
</p>


<hr>
<a id="method-Bar-create"></a>



<h4>Method <code>create()</code></h4>

<p>Create a progress bar.
</p>


<h5>Usage</h5>

<div class="r"><pre>Bar$create(total, initial, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>total</code></dt><dd><p>The total number of times the progress bar should tick.</p>
</dd>
<dt><code>initial</code></dt><dd><p>The starting point of the progress bar.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments for the bar creation. See the
<strong>Details</strong> section for more information.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The optional <code>...</code> named arguments depend on the specific concrete
implementation (i.e., <code><a href="#topic+BasicBar">BasicBar</a></code> or
<code><a href="#topic+ModernBar">ModernBar</a></code>).
</p>



<h5>Returns</h5>

<p>This method returns void. The resulting bar is stored in the private
field <code>.bar</code>, accessible via the active binding <code>engine</code>.
</p>


<hr>
<a id="method-Bar-update"></a>



<h4>Method <code>update()</code></h4>

<p>Update the progress bar.
</p>


<h5>Usage</h5>

<div class="r"><pre>Bar$update(current)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>current</code></dt><dd><p>The position the progress bar should be at (e.g., 30
out of 100), usually the index in a loop.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Bar-terminate"></a>



<h4>Method <code>terminate()</code></h4>

<p>Terminate the progress bar.
</p>


<h5>Usage</h5>

<div class="r"><pre>Bar$terminate()</pre></div>


<hr>
<a id="method-Bar-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Bar$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+BasicBar">BasicBar</a></code>, <code><a href="#topic+ModernBar">ModernBar</a></code>, and <code><a href="#topic+BarFactory">BarFactory</a></code>.
</p>

<hr>
<h2 id='BarFactory'>BackendFactory</h2><span id='topic+BarFactory'></span>

<h3>Description</h3>

<p>This class is a factory that provides concrete implementations of the
<code><a href="#topic+Bar">Bar</a></code> abstract class.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-BarFactory-get"><code>BarFactory$get()</code></a>
</p>
</li>
<li> <p><a href="#method-BarFactory-clone"><code>BarFactory$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-BarFactory-get"></a>



<h4>Method <code>get()</code></h4>

<p>Obtain a concrete implementation of the abstract <code><a href="#topic+Bar">Bar</a></code>
class of the specified type.
</p>


<h5>Usage</h5>

<div class="r"><pre>BarFactory$get(type)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>A character string specifying the type of the
<code><a href="#topic+Bar">Bar</a></code> to instantiate. Possible values are <code>"modern"</code> and
<code>"basic"</code>. See the <strong>Details</strong> section for more information.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>When <code>type = "modern"</code> a <code><a href="#topic+ModernBar">ModernBar</a></code> instance is created
and returned. When <code>type = "basic"</code> a <code><a href="#topic+BasicBar">BasicBar</a></code> instance
is provided instead.
</p>



<h5>Returns</h5>

<p>A concrete implementation of the class <code><a href="#topic+Bar">Bar</a></code>. It throws an
error if the requested bar <code>type</code> is not supported.
</p>


<hr>
<a id="method-BarFactory-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>BarFactory$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Bar">Bar</a></code>, <code><a href="#topic+BasicBar">BasicBar</a></code>, and <code><a href="#topic+ModernBar">ModernBar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a bar factory.
bar_factory &lt;- BarFactory$new()

# Get a modern bar instance.
bar &lt;- bar_factory$get("modern")

# Check the class of the bar instance.
class(bar)

# Get a basic bar instance.
bar &lt;- bar_factory$get("basic")

# Check the class of the bar instance.
class(bar)

</code></pre>

<hr>
<h2 id='BasicBar'>BasicBar</h2><span id='topic+BasicBar'></span>

<h3>Description</h3>

<p>This is a concrete implementation of the abstract class <code><a href="#topic+Bar">Bar</a></code>
using the <code><a href="utils.html#topic+txtProgressBar">utils::txtProgressBar()</a></code> as engine for the progress bar.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Bar">parabar::Bar</a></code> -&gt; <code>BasicBar</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-BasicBar-new"><code>BasicBar$new()</code></a>
</p>
</li>
<li> <p><a href="#method-BasicBar-create"><code>BasicBar$create()</code></a>
</p>
</li>
<li> <p><a href="#method-BasicBar-update"><code>BasicBar$update()</code></a>
</p>
</li>
<li> <p><a href="#method-BasicBar-terminate"><code>BasicBar$terminate()</code></a>
</p>
</li>
<li> <p><a href="#method-BasicBar-clone"><code>BasicBar$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-BasicBar-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code><a href="#topic+BasicBar">BasicBar</a></code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>BasicBar$new()</pre></div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+BasicBar">BasicBar</a></code>.
</p>


<hr>
<a id="method-BasicBar-create"></a>



<h4>Method <code>create()</code></h4>

<p>Create a progress bar.
</p>


<h5>Usage</h5>

<div class="r"><pre>BasicBar$create(total, initial, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>total</code></dt><dd><p>The total number of times the progress bar should tick.</p>
</dd>
<dt><code>initial</code></dt><dd><p>The starting point of the progress bar.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments for the bar creation passed to
<code><a href="utils.html#topic+txtProgressBar">utils::txtProgressBar()</a></code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns void. The resulting bar is stored in the private
field <code>.bar</code>, accessible via the active binding <code>engine</code>. Both the
private field and the active binding are defined in the super class
<code><a href="#topic+Bar">Bar</a></code>.
</p>


<hr>
<a id="method-BasicBar-update"></a>



<h4>Method <code>update()</code></h4>

<p>Update the progress bar by calling <code><a href="utils.html#topic+txtProgressBar">utils::setTxtProgressBar()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>BasicBar$update(current)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>current</code></dt><dd><p>The position the progress bar should be at (e.g., 30
out of 100), usually the index in a loop.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-BasicBar-terminate"></a>



<h4>Method <code>terminate()</code></h4>

<p>Terminate the progress bar by calling <code><a href="base.html#topic+connections">base::close()</a></code> on the
private field <code>.bar</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>BasicBar$terminate()</pre></div>


<hr>
<a id="method-BasicBar-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>BasicBar$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Bar">Bar</a></code>, <code><a href="#topic+ModernBar">ModernBar</a></code>, and <code><a href="#topic+BarFactory">BarFactory</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a basic bar instance.
bar &lt;- BasicBar$new()

# Specify the number of ticks to be performed.
total &lt;- 100

# Create the progress bar.
bar$create(total = total, initial = 0)

# Use the progress bar.
for (i in 1:total) {
    # Sleep a bit.
    Sys.sleep(0.02)

    # Update the progress bar.
    bar$update(i)
}

# Terminate the progress bar.
bar$terminate()

</code></pre>

<hr>
<h2 id='clear'>Clear a Backend</h2><span id='topic+clear'></span>

<h3>Description</h3>

<p>This function can be used to clear a <code><a href="#topic+Backend">backend</a></code> created
by <code><a href="#topic+start_backend">start_backend()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clear(backend)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clear_+3A_backend">backend</code></td>
<td>
<p>An object of class <code><a href="#topic+Backend">Backend</a></code> as returned by the
<code><a href="#topic+start_backend">start_backend()</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a convenience wrapper around the lower-lever API of
<code><a href="#topic+parabar">parabar</a></code> aimed at developers. More specifically, this function
calls the <code><a href="#topic+BackendService">clear</a></code> method on the provided
<code><a href="#topic+Backend">backend</a></code> instance.
</p>


<h3>Value</h3>

<p>The function returns void. It throws an error if the value provided for the
<code>backend</code> argument is not an instance of class <code><a href="#topic+Backend">Backend</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+start_backend">start_backend()</a></code>, <code><a href="#topic+peek">peek()</a></code>, <code><a href="#topic+export">export()</a></code>,
<code><a href="#topic+evaluate">evaluate()</a></code>, <code><a href="#topic+configure_bar">configure_bar()</a></code>, <code><a href="#topic+par_sapply">par_sapply()</a></code>,
<code><a href="#topic+par_lapply">par_lapply()</a></code>, <code><a href="#topic+par_apply">par_apply()</a></code>, <code><a href="#topic+stop_backend">stop_backend()</a></code>,
and <code><a href="#topic+BackendService">BackendService</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an asynchronous backend.
backend &lt;- start_backend(cores = 2, cluster_type = "psock", backend_type = "async")

# Check that the backend is active.
backend$active

# Check if there is anything on the backend.
peek(backend)

# Create a dummy variable.
name &lt;- "parabar"

# Export the `name` variable in the current environment to the backend.
export(backend, "name", environment())

# Remove the dummy variable from the current environment.
rm(name)

# Check the backend to see that the variable has been exported.
peek(backend)

# Run an expression on the backend.
# Note that the symbols in the expression are resolved on the backend.
evaluate(backend, {
    # Print the name.
    print(paste0("Hello, ", name, "!"))
})

# Clear the backend.
clear(backend)

# Check that there is nothing on the backend.
peek(backend)

# Use a basic progress bar (i.e., see `parabar::Bar`).
configure_bar(type = "basic", style = 3)

# Run a task in parallel (i.e., approx. 1.25 seconds).
output &lt;- par_sapply(backend, x = 1:10, fun = function(x) {
    # Sleep a bit.
    Sys.sleep(0.25)

    # Compute and return.
    return(x + 1)
})

# Print the output.
print(output)

# Stop the backend.
stop_backend(backend)

# Check that the backend is not active.
backend$active

</code></pre>

<hr>
<h2 id='configure_bar'>Configure The Progress Bar</h2><span id='topic+configure_bar'></span>

<h3>Description</h3>

<p>This function can be used to conveniently configure the progress bar by
adjusting the <code>progress_bar_config</code> field of the
<code><a href="#topic+Options">Options</a></code> instance in the <code><a href="base.html#topic+options">base::.Options</a></code> list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>configure_bar(type = "modern", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="configure_bar_+3A_type">type</code></td>
<td>
<p>A character string specifying the type of progress bar to be used
with compatible <code><a href="#topic+Backend">backends</a></code>. Possible values are
<code>"modern"</code> and <code>"basic"</code>. The default value is <code>"modern"</code>.</p>
</td></tr>
<tr><td><code id="configure_bar_+3A_...">...</code></td>
<td>
<p>A list of named arguments used to configure the progress bar. See
the <strong>Details</strong> section for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The optional <code>...</code> named arguments depend on the <code>type</code> of progress bar being
configured. When <code>type = "modern"</code>, the <code>...</code> take the named arguments of the
<code><a href="progress.html#topic+progress_bar">progress::progress_bar</a></code> class. When <code>type = "basic"</code>, the <code>...</code> take the
named arguments of the <code><a href="utils.html#topic+txtProgressBar">utils::txtProgressBar()</a></code> built-in function. See the
<strong>Examples</strong> section for a demonstration.
</p>


<h3>Value</h3>

<p>The function returns void. It throws an error if the requested bar <code>type</code> is
not supported.
</p>


<h3>See Also</h3>

<p><code><a href="progress.html#topic+progress_bar">progress::progress_bar</a></code>, <code><a href="utils.html#topic+txtProgressBar">utils::txtProgressBar()</a></code>,
<code><a href="#topic+set_default_options">set_default_options()</a></code>, <code><a href="#topic+get_option">get_option()</a></code>,
<code><a href="#topic+set_option">set_option()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set the default package options.
set_default_options()

# Get the progress bar type from options.
get_option("progress_bar_type")

# Get the progress bar configuration from options.
get_option("progress_bar_config")

# Adjust the format of the `modern` progress bar.
configure_bar(type = "modern", format = "[:bar] :percent")

# Check that the configuration has been updated in the options.
get_option("progress_bar_config")

# Change to and adjust the style of the `basic` progress bar.
configure_bar(type = "basic", style = 3)

# Check that the configuration has been updated in the options.
get_option("progress_bar_type")
get_option("progress_bar_config")

</code></pre>

<hr>
<h2 id='Context'>Context</h2><span id='topic+Context'></span>

<h3>Description</h3>

<p>This class represents the base context for interacting with
<code><a href="#topic+Backend">Backend</a></code> implementations via the <code><a href="#topic+BackendService">BackendService</a></code>
interface.
</p>


<h3>Details</h3>

<p>This class is a vanilla wrapper around a <code><a href="#topic+Backend">Backend</a></code> implementation.
It registers a backend instance and forwards all <code><a href="#topic+BackendService">BackendService</a></code>
methods calls to the backend instance. Subclasses can override any of the
<code><a href="#topic+BackendService">BackendService</a></code> methods to decorate the backend instance with
additional functionality (e.g., see the <code><a href="#topic+ProgressTrackingContext">ProgressTrackingContext</a></code>
class for an example).
</p>


<h3>Super class</h3>

<p><code><a href="#topic+BackendService">parabar::BackendService</a></code> -&gt; <code>Context</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>backend</code></dt><dd><p>The <code><a href="#topic+Backend">Backend</a></code> object registered with the
context.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Context-new"><code>Context$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Context-set_backend"><code>Context$set_backend()</code></a>
</p>
</li>
<li> <p><a href="#method-Context-start"><code>Context$start()</code></a>
</p>
</li>
<li> <p><a href="#method-Context-stop"><code>Context$stop()</code></a>
</p>
</li>
<li> <p><a href="#method-Context-clear"><code>Context$clear()</code></a>
</p>
</li>
<li> <p><a href="#method-Context-peek"><code>Context$peek()</code></a>
</p>
</li>
<li> <p><a href="#method-Context-export"><code>Context$export()</code></a>
</p>
</li>
<li> <p><a href="#method-Context-evaluate"><code>Context$evaluate()</code></a>
</p>
</li>
<li> <p><a href="#method-Context-sapply"><code>Context$sapply()</code></a>
</p>
</li>
<li> <p><a href="#method-Context-lapply"><code>Context$lapply()</code></a>
</p>
</li>
<li> <p><a href="#method-Context-apply"><code>Context$apply()</code></a>
</p>
</li>
<li> <p><a href="#method-Context-get_output"><code>Context$get_output()</code></a>
</p>
</li>
<li> <p><a href="#method-Context-clone"><code>Context$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Context-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code><a href="#topic+Context">Context</a></code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Context$new()</pre></div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+Context">Context</a></code>.
</p>


<hr>
<a id="method-Context-set_backend"></a>



<h4>Method <code>set_backend()</code></h4>

<p>Set the backend instance to be used by the context.
</p>


<h5>Usage</h5>

<div class="r"><pre>Context$set_backend(backend)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>backend</code></dt><dd><p>An object of class <code><a href="#topic+Backend">Backend</a></code> that
implements the <code><a href="#topic+BackendService">BackendService</a></code> interface.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Context-start"></a>



<h4>Method <code>start()</code></h4>

<p>Start the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>Context$start(specification)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>specification</code></dt><dd><p>An object of class <code><a href="#topic+Specification">Specification</a></code>
that contains the backend configuration.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns void. The resulting backend must be stored in the
<code>.cluster</code> private field on the <code><a href="#topic+Backend">Backend</a></code> abstract class,
and accessible to any concrete backend implementations via the active
binding <code>cluster</code>.
</p>


<hr>
<a id="method-Context-stop"></a>



<h4>Method <code>stop()</code></h4>

<p>Stop the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>Context$stop()</pre></div>



<h5>Returns</h5>

<p>This method returns void.
</p>


<hr>
<a id="method-Context-clear"></a>



<h4>Method <code>clear()</code></h4>

<p>Remove all objects from the backend. This function is equivalent to
calling <code>rm(list = ls(all.names = TRUE))</code> on each node in the
backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>Context$clear()</pre></div>



<h5>Returns</h5>

<p>This method returns void.
</p>


<hr>
<a id="method-Context-peek"></a>



<h4>Method <code>peek()</code></h4>

<p>Inspect the backend for variables available in the <code>.GlobalEnv</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Context$peek()</pre></div>



<h5>Returns</h5>

<p>This method returns a list of character vectors, where each element
corresponds to a node in the backend. The character vectors contain
the names of the variables available in the <code>.GlobalEnv</code> on each
node.
</p>


<hr>
<a id="method-Context-export"></a>



<h4>Method <code>export()</code></h4>

<p>Export variables from a given environment to the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>Context$export(variables, environment)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>variables</code></dt><dd><p>A character vector of variable names to export.</p>
</dd>
<dt><code>environment</code></dt><dd><p>An environment object from which to export the
variables. Defaults to the parent frame.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns void.
</p>


<hr>
<a id="method-Context-evaluate"></a>



<h4>Method <code>evaluate()</code></h4>

<p>Evaluate an arbitrary expression on the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>Context$evaluate(expression)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expression</code></dt><dd><p>An unquoted expression to evaluate on the backend.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns the result of the expression evaluation.
</p>


<hr>
<a id="method-Context-sapply"></a>



<h4>Method <code>sapply()</code></h4>

<p>Run a task on the backend akin to <code><a href="parallel.html#topic+clusterApply">parallel::parSapply()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Context$sapply(x, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>An atomic vector or list to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>fun</code></dt><dd><p>A function to apply to each element of <code>x</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code><a href="#topic+Backend">Backend</a></code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-Context-lapply"></a>



<h4>Method <code>lapply()</code></h4>

<p>Run a task on the backend akin to <code><a href="parallel.html#topic+clusterApply">parallel::parLapply()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Context$lapply(x, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>An atomic vector or list to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>fun</code></dt><dd><p>A function to apply to each element of <code>x</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code><a href="#topic+Backend">Backend</a></code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-Context-apply"></a>



<h4>Method <code>apply()</code></h4>

<p>Run a task on the backend akin to <code><a href="parallel.html#topic+clusterApply">parallel::parApply()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Context$apply(x, margin, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>An array to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>margin</code></dt><dd><p>A numeric vector indicating the dimensions of <code>x</code> the
<code>fun</code> function should be applied over. For example, for a matrix,
<code>margin = 1</code> indicates applying <code>fun</code> rows-wise, <code>margin = 2</code>
indicates applying <code>fun</code> columns-wise, and <code>margin = c(1, 2)</code>
indicates applying <code>fun</code> element-wise. Named dimensions are also
possible depending on <code>x</code>. See <code><a href="parallel.html#topic+clusterApply">parallel::parApply()</a></code> and
<code><a href="base.html#topic+apply">base::apply()</a></code> for more details.</p>
</dd>
<dt><code>fun</code></dt><dd><p>A function to apply to <code>x</code> according to the <code>margin</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code><a href="#topic+Backend">Backend</a></code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-Context-get_output"></a>



<h4>Method <code>get_output()</code></h4>

<p>Get the output of the task execution.
</p>


<h5>Usage</h5>

<div class="r"><pre>Context$get_output(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Additional arguments to pass to the backend registered
with the context. This is useful for backends that require additional
arguments to fetch the output (e.g., <code><a href="#topic+AsyncBackend">AsyncBackend$get_output(wait = TRUE)</a></code>).</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This method fetches the output of the task execution after calling
the <code>sapply()</code> method. It returns the output and immediately removes
it from the backend. Therefore, subsequent calls to this method are
not advised. This method should be called after the execution of a
task.
</p>



<h5>Returns</h5>

<p>A vector, matrix, or list of the same length as <code>x</code>, containing the
results of the <code>fun</code>. The output format differs based on the specific
operation employed. Check out the documentation for the <code>apply</code>
operations of <code><a href="parallel.html#topic+parallel-package">parallel::parallel</a></code> for more information.
</p>


<hr>
<a id="method-Context-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Context$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+ProgressTrackingContext">ProgressTrackingContext</a></code>, <code><a href="#topic+BackendService">BackendService</a></code>,
<code><a href="#topic+Backend">Backend</a></code>, and <code><a href="#topic+SyncBackend">SyncBackend</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a task to run in parallel.
task &lt;- function(x, y) {
    # Sleep a bit.
    Sys.sleep(0.25)

    # Return the result of a computation.
    return(x + y)
}

# Create a specification object.
specification &lt;- Specification$new()

# Set the number of cores.
specification$set_cores(cores = 2)

# Set the cluster type.
specification$set_type(type = "psock")

# Create a backend factory.
backend_factory &lt;- BackendFactory$new()

# Get a synchronous backend instance.
backend &lt;- backend_factory$get("sync")

# Create a base context object.
context &lt;- Context$new()

# Register the backend with the context.
context$set_backend(backend)

# From now all, all backend operations are intercepted by the context.

# Start the backend.
context$start(specification)

# Run a task in parallel (i.e., approx. 1.25 seconds).
context$sapply(x = 1:10, fun = task, y = 10)

# Get the task output.
context$get_output()

# Close the backend.
context$stop()

# Get an asynchronous backend instance.
backend &lt;- backend_factory$get("async")

# Register the backend with the same context object.
context$set_backend(backend)

# Start the backend reusing the specification object.
context$start(specification)

# Run a task in parallel (i.e., approx. 1.25 seconds).
context$sapply(x = 1:10, fun = task, y = 10)

# Get the task output.
backend$get_output(wait = TRUE)

# Close the backend.
context$stop()

</code></pre>

<hr>
<h2 id='ContextFactory'>ContextFactory</h2><span id='topic+ContextFactory'></span>

<h3>Description</h3>

<p>This class is a factory that provides instances of the <code><a href="#topic+Context">Context</a></code>
class.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ContextFactory-get"><code>ContextFactory$get()</code></a>
</p>
</li>
<li> <p><a href="#method-ContextFactory-clone"><code>ContextFactory$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ContextFactory-get"></a>



<h4>Method <code>get()</code></h4>

<p>Obtain instances of the <code><a href="#topic+Context">Context</a></code> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>ContextFactory$get(type)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>A character string specifying the type of the
<code><a href="#topic+Context">Context</a></code> to instantiate. Possible values are <code>"regular"</code>
and <code>"progress"</code>. See the <strong>Details</strong> section for more information.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>When <code>type = "regular"</code> a <code><a href="#topic+Context">Context</a></code> instance is created
and returned. When <code>type = "progress"</code> a
<code><a href="#topic+ProgressTrackingContext">ProgressTrackingContext</a></code> instance is provided instead.
</p>



<h5>Returns</h5>

<p>An object of type <code><a href="#topic+Context">Context</a></code>. It throws an error if the
requested context <code>type</code> is not supported.
</p>


<hr>
<a id="method-ContextFactory-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ContextFactory$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Context">Context</a></code>, <code><a href="#topic+ProgressTrackingContext">ProgressTrackingContext</a></code>,
<code><a href="#topic+BackendService">BackendService</a></code>, and <code><a href="#topic+Backend">Backend</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a context factory.
context_factory &lt;- ContextFactory$new()

# Get a regular context instance.
context &lt;- context_factory$get("regular")

# Check the class of the context instance.
class(context)

# Get a progress context instance.
context &lt;- context_factory$get("progress")
class(context)

</code></pre>

<hr>
<h2 id='evaluate'>Evaluate An Expression On The Backend</h2><span id='topic+evaluate'></span>

<h3>Description</h3>

<p>This function can be used to evaluate an arbitrary <code><a href="base.html#topic+expression">base::expression()</a></code> a
<code><a href="#topic+Backend">backend</a></code> created by <code><a href="#topic+start_backend">start_backend()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate(backend, expression)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluate_+3A_backend">backend</code></td>
<td>
<p>An object of class <code><a href="#topic+Backend">Backend</a></code> as returned by the
<code><a href="#topic+start_backend">start_backend()</a></code> function.</p>
</td></tr>
<tr><td><code id="evaluate_+3A_expression">expression</code></td>
<td>
<p>An unquoted expression to evaluate on the backend.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a convenience wrapper around the lower-lever API of
<code><a href="#topic+parabar">parabar</a></code> aimed at developers. More specifically, this function
calls the <code><a href="#topic+BackendService">evaluate</a></code> method on the provided
<code><a href="#topic+Backend">backend</a></code> instance.
</p>


<h3>Value</h3>

<p>This method returns the result of the expression evaluation. It throws an
error if the value provided for the <code>backend</code> argument is not an instance of
class <code><a href="#topic+Backend">Backend</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+start_backend">start_backend()</a></code>, <code><a href="#topic+peek">peek()</a></code>, <code><a href="#topic+export">export()</a></code>,
<code><a href="#topic+clear">clear()</a></code>, <code><a href="#topic+configure_bar">configure_bar()</a></code>, <code><a href="#topic+par_sapply">par_sapply()</a></code>,
<code><a href="#topic+par_lapply">par_lapply()</a></code>, <code><a href="#topic+par_apply">par_apply()</a></code>, <code><a href="#topic+stop_backend">stop_backend()</a></code>,
and <code><a href="#topic+BackendService">BackendService</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an asynchronous backend.
backend &lt;- start_backend(cores = 2, cluster_type = "psock", backend_type = "async")

# Check that the backend is active.
backend$active

# Check if there is anything on the backend.
peek(backend)

# Create a dummy variable.
name &lt;- "parabar"

# Export the `name` variable in the current environment to the backend.
export(backend, "name", environment())

# Remove the dummy variable from the current environment.
rm(name)

# Check the backend to see that the variable has been exported.
peek(backend)

# Run an expression on the backend.
# Note that the symbols in the expression are resolved on the backend.
evaluate(backend, {
    # Print the name.
    print(paste0("Hello, ", name, "!"))
})

# Clear the backend.
clear(backend)

# Check that there is nothing on the backend.
peek(backend)

# Use a basic progress bar (i.e., see `parabar::Bar`).
configure_bar(type = "basic", style = 3)

# Run a task in parallel (i.e., approx. 1.25 seconds).
output &lt;- par_sapply(backend, x = 1:10, fun = function(x) {
    # Sleep a bit.
    Sys.sleep(0.25)

    # Compute and return.
    return(x + 1)
})

# Print the output.
print(output)

# Stop the backend.
stop_backend(backend)

# Check that the backend is not active.
backend$active

</code></pre>

<hr>
<h2 id='Exception'>Package Exceptions</h2><span id='topic+Exception'></span>

<h3>Description</h3>

<p>This class contains static methods for throwing exceptions with informative
messages.
</p>


<h3>Format</h3>


<dl>
<dt><code>Exception$abstract_class_not_instantiable(object)</code></dt><dd><p>Exception for instantiating abstract classes or interfaces.</p>
</dd>
<dt><code>Exception$method_not_implemented()</code></dt><dd><p>Exception for calling methods without an implementation.</p>
</dd>
<dt><code>Exception$feature_not_developed()</code></dt><dd><p>Exception for running into things not yet developed.</p>
</dd>
<dt><code>Exception$not_enough_cores()</code></dt><dd><p>Exception for requesting more cores than available on the machine.</p>
</dd>
<dt><code>Exception$cluster_active()</code></dt><dd><p>Exception for attempting to start a cluster while another one is active.</p>
</dd>
<dt><code>Exception$cluster_not_active()</code></dt><dd><p>Exception for attempting to stop a cluster while not active.</p>
</dd>
<dt><code>Exception$async_task_not_started()</code></dt><dd><p>Exception for reading results while an asynchronous task has not yet started.</p>
</dd>
<dt><code>Exception$async_task_running()</code></dt><dd><p>Exception for reading results while an asynchronous task is running.</p>
</dd>
<dt><code>Exception$async_task_completed()</code></dt><dd><p>Exception for reading results while a completed asynchronous task has unread results.</p>
</dd>
<dt><code>Exception$async_task_error(error)</code></dt><dd><p>Exception for errors while running an asynchronous task.</p>
</dd>
<dt><code>Exception$stop_busy_backend_not_allowed()</code></dt><dd><p>Exception for stopping a busy backend without intent.</p>
</dd>
<dt><code>Exception$temporary_file_creation_failed()</code></dt><dd><p>Exception for reading results while an asynchronous task is running.</p>
</dd>
<dt><code>Exception$type_not_assignable(actual, expected)</code></dt><dd><p>Exception for when providing incorrect object types.</p>
</dd>
<dt><code>Exception$unknown_package_option(option)</code></dt><dd><p>Exception for when requesting unknown package options.</p>
</dd>
<dt><code>Exception$primitive_as_task_not_allowed()</code></dt><dd><p>Exception for when decorating primitive functions with progress tracking.</p>
</dd>
<dt><code>Exception$array_margins_not_compatible(actual, allowed)</code></dt><dd><p>Exception for using improper margins in the <code>BackendService$apply</code> operation.</p>
</dd>
</dl>


<hr>
<h2 id='export'>Export Objects To a Backend</h2><span id='topic+export'></span>

<h3>Description</h3>

<p>This function can be used to export objects to a
<code><a href="#topic+Backend">backend</a></code> created by <code><a href="#topic+start_backend">start_backend()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export(backend, variables, environment)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_+3A_backend">backend</code></td>
<td>
<p>An object of class <code><a href="#topic+Backend">Backend</a></code> as returned by the
<code><a href="#topic+start_backend">start_backend()</a></code> function.</p>
</td></tr>
<tr><td><code id="export_+3A_variables">variables</code></td>
<td>
<p>A character vector of variable names to export to the
backend.</p>
</td></tr>
<tr><td><code id="export_+3A_environment">environment</code></td>
<td>
<p>An environment from which to export the variables. If no
environment is provided, the <code>.GlobalEnv</code> environment is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a convenience wrapper around the lower-lever API of
<code><a href="#topic+parabar">parabar</a></code> aimed at developers. More specifically, this function
calls the <code><a href="#topic+BackendService">export</a></code> method on the provided
<code><a href="#topic+Backend">backend</a></code> instance.
</p>


<h3>Value</h3>

<p>The function returns void. It throws an error if the value provided for the
<code>backend</code> argument is not an instance of class <code><a href="#topic+Backend">Backend</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+start_backend">start_backend()</a></code>, <code><a href="#topic+peek">peek()</a></code>, <code><a href="#topic+evaluate">evaluate()</a></code>,
<code><a href="#topic+clear">clear()</a></code>, <code><a href="#topic+configure_bar">configure_bar()</a></code>, <code><a href="#topic+par_sapply">par_sapply()</a></code>,
<code><a href="#topic+par_lapply">par_lapply()</a></code>, <code><a href="#topic+par_apply">par_apply()</a></code>, <code><a href="#topic+stop_backend">stop_backend()</a></code>,
and <code><a href="#topic+BackendService">BackendService</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an asynchronous backend.
backend &lt;- start_backend(cores = 2, cluster_type = "psock", backend_type = "async")

# Check that the backend is active.
backend$active

# Check if there is anything on the backend.
peek(backend)

# Create a dummy variable.
name &lt;- "parabar"

# Export the `name` variable in the current environment to the backend.
export(backend, "name", environment())

# Remove the dummy variable from the current environment.
rm(name)

# Check the backend to see that the variable has been exported.
peek(backend)

# Run an expression on the backend.
# Note that the symbols in the expression are resolved on the backend.
evaluate(backend, {
    # Print the name.
    print(paste0("Hello, ", name, "!"))
})

# Clear the backend.
clear(backend)

# Check that there is nothing on the backend.
peek(backend)

# Use a basic progress bar (i.e., see `parabar::Bar`).
configure_bar(type = "basic", style = 3)

# Run a task in parallel (i.e., approx. 1.25 seconds).
output &lt;- par_sapply(backend, x = 1:10, fun = function(x) {
    # Sleep a bit.
    Sys.sleep(0.25)

    # Compute and return.
    return(x + 1)
})

# Print the output.
print(output)

# Stop the backend.
stop_backend(backend)

# Check that the backend is not active.
backend$active

</code></pre>

<hr>
<h2 id='get_option'>Get or Set Package Option</h2><span id='topic+get_option'></span><span id='topic+set_option'></span><span id='topic+set_default_options'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+get_option">get_option()</a></code> function is a helper for retrieving the value of
<code><a href="#topic+parabar">parabar</a></code> <code><a href="base.html#topic+options">options</a></code>. If the
<code><a href="#topic+Options">option</a></code> requested is not available in the session
<code><a href="base.html#topic+options">base::.Options</a></code> list, the corresponding default value set by the
<code><a href="#topic+Options">Options</a></code> <code><a href="R6.html#topic+R6Class">R6::R6</a></code> class is returned instead.
</p>
<p>The <code><a href="#topic+set_option">set_option()</a></code> function is a helper for setting
<code><a href="#topic+parabar">parabar</a></code> <code><a href="base.html#topic+options">options</a></code>. The function adjusts the
fields of the <code><a href="#topic+Options">Options</a></code> instance stored in the <code><a href="base.html#topic+options">base::.Options</a></code>
list. If no <code><a href="#topic+Options">Options</a></code> instance is present in the
<code><a href="base.html#topic+options">base::.Options</a></code> list, a new one is created.
</p>
<p>The <code><a href="#topic+set_default_options">set_default_options()</a></code> function is used to set the default
<code><a href="base.html#topic+options">options</a></code> values for the <code><a href="#topic+parabar">parabar</a></code> package. The
function is automatically called at package load and the entry created can be
retrieved via <code><a href="base.html#topic+options">getOption(&quot;parabar&quot;)</a></code>. Specific package
<code><a href="base.html#topic+options">options</a></code> can be retrieved using the helper function
<code><a href="#topic+get_option">get_option()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_option(option)

set_option(option, value)

set_default_options()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_option_+3A_option">option</code></td>
<td>
<p>A character string representing the name of the option to
retrieve or adjust. See the public fields of <code><a href="R6.html#topic+R6Class">R6::R6</a></code> class
<code><a href="#topic+Options">Options</a></code> for the list of available <code><a href="#topic+parabar">parabar</a></code>
<code><a href="base.html#topic+options">options</a></code>.</p>
</td></tr>
<tr><td><code id="get_option_+3A_value">value</code></td>
<td>
<p>The value to set the <code><a href="#topic+Options">option</a></code> to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code><a href="#topic+get_option">get_option()</a></code> function returns the value of the requested
<code><a href="#topic+Options">option</a></code> present in the <code><a href="base.html#topic+options">base::.Options</a></code> list, or its
corresponding default value (i.e., see <code><a href="#topic+Options">Options</a></code>). If the
requested <code><a href="#topic+Options">option</a></code> is not known, an error is thrown.
</p>
<p>The <code><a href="#topic+set_option">set_option()</a></code> function returns void. It throws an error if the
requested <code><a href="#topic+Options">option</a></code> to be adjusted is not known.
</p>
<p>The <code><a href="#topic+set_default_options">set_default_options()</a></code> function returns void. The
<code><a href="base.html#topic+options">options</a></code> set can be consulted via the <code><a href="base.html#topic+options">base::.Options</a></code>
list. See the <code><a href="#topic+Options">Options</a></code> <code><a href="R6.html#topic+R6Class">R6::R6</a></code> class for more information on
the default values set by this function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Options">Options</a></code>, <code><a href="#topic+set_default_options">set_default_options()</a></code>, <code><a href="base.html#topic+options">base::options()</a></code>,
and <code><a href="base.html#topic+options">base::getOption()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get the status of progress tracking.
get_option("progress_track")

# Set the status of progress tracking to `FALSE`.
set_option("progress_track", FALSE)

# Get the status of progress tracking again.
get_option("progress_track")

# Restore default options.
set_default_options()

# Get the status of progress tracking yet again.
get_option("progress_track")

</code></pre>

<hr>
<h2 id='Helper'>Package Helpers</h2><span id='topic+Helper'></span>

<h3>Description</h3>

<p>This class contains static helper methods.
</p>


<h3>Format</h3>


<dl>
<dt><code>Helper$get_class_name(object)</code></dt><dd><p>Helper for getting the class of a given object.</p>
</dd>
<dt><code>Helper$is_of_class(object, class)</code></dt><dd><p>Check if an object is of a certain class.</p>
</dd>
<dt><code>Helper$get_option(option)</code></dt><dd><p>Get package option, or corresponding default value.</p>
</dd>
<dt><code>Helper$set_option(option, value)</code></dt><dd><p>Set package option.</p>
</dd>
<dt><code>Helper$check_object_type(object, expected_type)</code></dt><dd><p>Check the type of a given object.</p>
</dd>
<dt><code>Helper$check_array_margins(margins, dimensions)</code></dt><dd><p>Helper to check array margins for the <code>BackendService$apply</code> operation.</p>
</dd>
</dl>


<hr>
<h2 id='LOGO'>The Package Logo</h2><span id='topic+LOGO'></span>

<h3>Description</h3>

<p>The logo is generated by <code><a href="#topic+make_logo">make_logo()</a></code> and displayed on package
attach for interactive <code>R</code> sessions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LOGO
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> containing the <code>ASCII</code> logo.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_logo">make_logo()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(LOGO)

</code></pre>

<hr>
<h2 id='make_logo'>Generate Package Logo</h2><span id='topic+make_logo'></span>

<h3>Description</h3>

<p>This function is meant for generating or updating the logo. After running
this procedure we end up with what is stored in the <code><a href="#topic+LOGO">LOGO</a></code>
constant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_logo(
  template = "./inst/assets/logo/parabar-logo.txt",
  version = c(1, 0, 0)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_logo_+3A_template">template</code></td>
<td>
<p>A character string representing the path to the logo
template.</p>
</td></tr>
<tr><td><code id="make_logo_+3A_version">version</code></td>
<td>
<p>A numerical vector of three positive integers representing the
version of the package to append to the logo.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ASCII logo.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LOGO">LOGO</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Generate the logo.
logo &lt;- make_logo()

# Print the logo.
cat(logo)

## End(Not run)

</code></pre>

<hr>
<h2 id='ModernBar'>ModernBar</h2><span id='topic+ModernBar'></span>

<h3>Description</h3>

<p>This is a concrete implementation of the abstract class <code><a href="#topic+Bar">Bar</a></code>
using the <code><a href="progress.html#topic+progress_bar">progress::progress_bar</a></code> as engine for the progress bar.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Bar">parabar::Bar</a></code> -&gt; <code>ModernBar</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ModernBar-new"><code>ModernBar$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ModernBar-create"><code>ModernBar$create()</code></a>
</p>
</li>
<li> <p><a href="#method-ModernBar-update"><code>ModernBar$update()</code></a>
</p>
</li>
<li> <p><a href="#method-ModernBar-terminate"><code>ModernBar$terminate()</code></a>
</p>
</li>
<li> <p><a href="#method-ModernBar-clone"><code>ModernBar$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ModernBar-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code><a href="#topic+ModernBar">ModernBar</a></code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ModernBar$new()</pre></div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+ModernBar">ModernBar</a></code>.
</p>


<hr>
<a id="method-ModernBar-create"></a>



<h4>Method <code>create()</code></h4>

<p>Create a progress bar.
</p>


<h5>Usage</h5>

<div class="r"><pre>ModernBar$create(total, initial, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>total</code></dt><dd><p>The total number of times the progress bar should tick.</p>
</dd>
<dt><code>initial</code></dt><dd><p>The starting point of the progress bar.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments for the bar creation passed to
<code><a href="progress.html#topic+progress_bar">progress::progress_bar$new()</a></code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns void. The resulting bar is stored in the private
field <code>.bar</code>, accessible via the active binding <code>engine</code>. Both the
private field and the active binding are defined in the super class
<code><a href="#topic+Bar">Bar</a></code>.
</p>


<hr>
<a id="method-ModernBar-update"></a>



<h4>Method <code>update()</code></h4>

<p>Update the progress bar by calling
<code><a href="progress.html#topic+progress_bar">progress::progress_bar$update()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ModernBar$update(current)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>current</code></dt><dd><p>The position the progress bar should be at (e.g., 30
out of 100), usually the index in a loop.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ModernBar-terminate"></a>



<h4>Method <code>terminate()</code></h4>

<p>Terminate the progress bar by calling
<code><a href="progress.html#topic+progress_bar">progress::progress_bar$terminate()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ModernBar$terminate()</pre></div>


<hr>
<a id="method-ModernBar-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ModernBar$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Bar">Bar</a></code>, <code><a href="#topic+BasicBar">BasicBar</a></code>, and <code><a href="#topic+BarFactory">BarFactory</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a modern bar instance.
bar &lt;- ModernBar$new()

# Specify the number of ticks to be performed.
total &lt;- 100

# Create the progress bar.
bar$create(total = total, initial = 0)

# Use the progress bar.
for (i in 1:total) {
    # Sleep a bit.
    Sys.sleep(0.02)

    # Update the progress bar.
    bar$update(i)
}

# Terminate the progress bar.
bar$terminate()

</code></pre>

<hr>
<h2 id='Options'>Class for Package Options</h2><span id='topic+Options'></span>

<h3>Description</h3>

<p>This class holds public fields that represent the package
<code><a href="base.html#topic+options">options</a></code> used to configure the default behavior of the
functionality <code><a href="#topic+parabar">parabar</a></code> provides.
</p>


<h3>Details</h3>

<p>An instance of this class is automatically created and stored in the session
<code><a href="base.html#topic+options">base::.Options</a></code> at load time. This instance can be accessed and changed
via <code><a href="base.html#topic+options">getOption(&quot;parabar&quot;)</a></code>. Specific package
<code><a href="base.html#topic+options">options</a></code> can be retrieved using the helper function
<code><a href="#topic+get_option">get_option()</a></code>.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>progress_track</code></dt><dd><p>A logical value indicating whether progress
tracking should be enabled (i.e., <code>TRUE</code>) or disabled  (i.e.,
<code>FALSE</code>) globally for compatible backends. The default value is
<code>TRUE</code>.</p>
</dd>
<dt><code>progress_timeout</code></dt><dd><p>A numeric value indicating the timeout (i.e.,
in seconds) between subsequent checks of the log file for new
progress records. The default value is <code>0.001</code>.</p>
</dd>
<dt><code>progress_wait</code></dt><dd><p>A numeric value indicating the approximate
duration (i.e., in seconds) to wait between progress bar updates
before checking if the task has finished (i.e., possibly with an
error). The default value is <code>0.1</code>.</p>
</dd>
<dt><code>progress_bar_type</code></dt><dd><p>A character string indicating the default
bar type to use with compatible backends. Possible values are
<code>"modern"</code> (the default) or <code>"basic"</code>.</p>
</dd>
<dt><code>progress_bar_config</code></dt><dd><p>A list of lists containing the default bar
configuration for each supported bar engine. Elements of these lists
represent arguments for the corresponding bar engines. Currently, the
supported bar engines are:
</p>

<ul>
<li> <p><code>modern</code>: The <code><a href="progress.html#topic+progress_bar">progress::progress_bar</a></code> engine, with the following
default configuration:
</p>

<ul>
<li> <p><code>show_after = 0</code>
</p>
</li>
<li> <p><code>format = "&gt; completed :current out of :total tasks [:percent] [:elapsed]"</code>
</p>
</li></ul>

</li>
<li> <p><code>basic</code>: The <code><a href="utils.html#topic+txtProgressBar">utils::txtProgressBar</a></code> engine, with no default
configuration.
</p>
</li></ul>
</dd>
<dt><code>stop_forceful</code></dt><dd><p>A logical value indicating whether to allow
stopping an asynchronous backend forcefully (i.e., <code>TRUE</code>), or not
(i.e., <code>FALSE</code>). When stopping forcefully, the backend is terminated
without waiting for a running tasks to finish or for the results to
be read into the main <code>R</code> session. The default value is <code>FALSE</code>.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>progress_log_path</code></dt><dd><p>A character string indicating the path to
the log file where to track the execution progress of a running task.
The default value is a temporary file generated by
<code><a href="base.html#topic+tempfile">base::tempfile()</a></code>. Calling this active binding repeatedly will
yield different temporary file paths. Fixing the path to a specific
value is possible by setting this active binding to a character
string representing the desired path. Setting this active binding to
<code>NULL</code> will reset it to the default value (i.e., yielding different
temporary file paths).</p>
</dd>
</dl>

</div>


<h3>See Also</h3>

<p><code><a href="#topic+get_option">get_option()</a></code>, <code><a href="#topic+set_option">set_option()</a></code>, and
<code><a href="#topic+set_default_options">set_default_options()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set the default package options (i.e., automatically set at load time).
set_default_options()

# First, get the options instance from the session options.
parabar &lt;- getOption("parabar")

# Then, disable progress tracking.
parabar$progress_track &lt;- FALSE

# Check that the change was applied (i.e., `progress_track: FALSE`).
getOption("parabar")

# To restore defaults, set the default options again.
set_default_options()

# Check that the change was applied (i.e., `progress_track: TRUE`).
getOption("parabar")

# We can also use the built-in helpers to get and set options more conveniently.

# Get the progress tracking option.
get_option("progress_track")

# Set the progress tracking option to `FALSE`.
set_option("progress_track", FALSE)

# Check that the change was applied (i.e., `progress_track: FALSE`).
get_option("progress_track")

# Get a temporary file for logging the progress.
get_option("progress_log_path")

# Fix the logging file path.
set_option("progress_log_path", "./progress.log")

# Check that the logging path change was applied.
get_option("progress_log_path")

# Restore the logging path to the default behavior.
set_option("progress_log_path", NULL)

# Check that the logging path change was applied.
get_option("progress_log_path")

# Restore the defaults.
set_default_options()

</code></pre>

<hr>
<h2 id='par_apply'>Run a Task in Parallel</h2><span id='topic+par_apply'></span>

<h3>Description</h3>

<p>This function can be used to run a task in parallel. The task is executed in
parallel on the specified backend, similar to <code><a href="parallel.html#topic+clusterApply">parallel::parApply()</a></code>. If
<code>backend = NULL</code>, the task is executed sequentially using <code><a href="base.html#topic+apply">base::apply()</a></code>.
See the <strong>Details</strong> section for more information on how this function works.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par_apply(backend = NULL, x, margin, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="par_apply_+3A_backend">backend</code></td>
<td>
<p>An object of class <code><a href="#topic+Backend">Backend</a></code> as returned by the
<code><a href="#topic+start_backend">start_backend()</a></code> function. It can also be <code>NULL</code> to run the task
sequentially via <code><a href="base.html#topic+apply">base::apply()</a></code>. The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="par_apply_+3A_x">x</code></td>
<td>
<p>An array to pass to the <code>fun</code> function.</p>
</td></tr>
<tr><td><code id="par_apply_+3A_margin">margin</code></td>
<td>
<p>A numeric vector indicating the dimensions of <code>x</code> the
<code>fun</code> function should be applied over. For example, for a matrix,
<code>margin = 1</code> indicates applying <code>fun</code> rows-wise, <code>margin = 2</code>
indicates applying <code>fun</code> columns-wise, and <code>margin = c(1, 2)</code>
indicates applying <code>fun</code> element-wise. Named dimensions are also
possible depending on <code>x</code>. See <code><a href="parallel.html#topic+clusterApply">parallel::parApply()</a></code> and
<code><a href="base.html#topic+apply">base::apply()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="par_apply_+3A_fun">fun</code></td>
<td>
<p>A function to apply to <code>x</code> according to the <code>margin</code>.</p>
</td></tr>
<tr><td><code id="par_apply_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the <code>fun</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the <code><a href="#topic+UserApiConsumer">UserApiConsumer</a></code> class that acts like an
interface for the developer API of the <code><a href="#topic+parabar">parabar</a></code> package.
</p>


<h3>Value</h3>

<p>The dimensions of the output vary according to the <code>margin</code> argument. Consult
the documentation of <code><a href="base.html#topic+apply">base::apply()</a></code> for a detailed explanation on how the
output is structured.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+start_backend">start_backend()</a></code>, <code><a href="#topic+peek">peek()</a></code>, <code><a href="#topic+export">export()</a></code>,
<code><a href="#topic+evaluate">evaluate()</a></code>, <code><a href="#topic+clear">clear()</a></code>, <code><a href="#topic+configure_bar">configure_bar()</a></code>,
<code><a href="#topic+par_sapply">par_sapply()</a></code>, <code><a href="#topic+par_lapply">par_lapply()</a></code>, <code><a href="#topic+stop_backend">stop_backend()</a></code>,
<code><a href="#topic+set_option">set_option()</a></code>, <code><a href="#topic+get_option">get_option()</a></code>, <code><a href="#topic+Options">Options</a></code>,
<code><a href="#topic+UserApiConsumer">UserApiConsumer</a></code>, and <code><a href="#topic+BackendService">BackendService</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Define a simple task.
task &lt;- function(x) {
    # Perform computations.
    Sys.sleep(0.01)

    # Return the result.
    mean(x)
}

# Define a matrix for the task.
x &lt;- matrix(rnorm(100^2, mean = 10, sd = 0.5), nrow = 100, ncol = 100)

# Start an asynchronous backend.
backend &lt;- start_backend(cores = 2, cluster_type = "psock", backend_type = "async")

# Run a task in parallel over the rows of `x`.
results &lt;- par_apply(backend, x = x, margin = 1, fun = task)

# Run a task in parallel over the columns of `x`.
results &lt;- par_apply(backend, x = x, margin = 2, fun = task)

# The task can also be run over all elements of `x` using `margin = c(1, 2)`.
# Improper dimensions will throw an error.
try(par_apply(backend, x = x, margin = c(1, 2, 3), fun = task))

# Disable progress tracking.
set_option("progress_track", FALSE)

# Run a task in parallel.
results &lt;- par_apply(backend, x = x, margin = 1, fun = task)

# Enable progress tracking.
set_option("progress_track", TRUE)

# Change the progress bar options.
configure_bar(type = "modern", format = "[:bar] :percent")

# Run a task in parallel.
results &lt;- par_apply(backend, x = x, margin = 1, fun = task)

# Stop the backend.
stop_backend(backend)

# Start a synchronous backend.
backend &lt;- start_backend(cores = 2, cluster_type = "psock", backend_type = "sync")

# Run a task in parallel.
results &lt;- par_apply(backend, x = x, margin = 1, fun = task)

# Disable progress tracking to remove the warning that progress is not supported.
set_option("progress_track", FALSE)

# Run a task in parallel.
results &lt;- par_apply(backend, x = x, margin = 1, fun = task)

# Stop the backend.
stop_backend(backend)

# Run the task using the `base::lapply` (i.e., non-parallel).
results &lt;- par_apply(NULL, x = x, margin = 1, fun = task)



</code></pre>

<hr>
<h2 id='par_lapply'>Run a Task in Parallel</h2><span id='topic+par_lapply'></span>

<h3>Description</h3>

<p>This function can be used to run a task in parallel. The task is executed in
parallel on the specified backend, similar to <code><a href="parallel.html#topic+clusterApply">parallel::parLapply()</a></code>. If
<code>backend = NULL</code>, the task is executed sequentially using <code><a href="base.html#topic+lapply">base::lapply()</a></code>.
See the <strong>Details</strong> section for more information on how this function works.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par_lapply(backend = NULL, x, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="par_lapply_+3A_backend">backend</code></td>
<td>
<p>An object of class <code><a href="#topic+Backend">Backend</a></code> as returned by the
<code><a href="#topic+start_backend">start_backend()</a></code> function. It can also be <code>NULL</code> to run the task
sequentially via <code><a href="base.html#topic+lapply">base::lapply()</a></code>. The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="par_lapply_+3A_x">x</code></td>
<td>
<p>An atomic vector or list to pass to the <code>fun</code> function.</p>
</td></tr>
<tr><td><code id="par_lapply_+3A_fun">fun</code></td>
<td>
<p>A function to apply to each element of <code>x</code>.</p>
</td></tr>
<tr><td><code id="par_lapply_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the <code>fun</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the <code><a href="#topic+UserApiConsumer">UserApiConsumer</a></code> class that acts like an
interface for the developer API of the <code><a href="#topic+parabar">parabar</a></code> package.
</p>


<h3>Value</h3>

<p>A list of the same length as <code>x</code> containing the results of the <code>fun</code>. The
output format resembles that of <code><a href="base.html#topic+lapply">base::lapply()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+start_backend">start_backend()</a></code>, <code><a href="#topic+peek">peek()</a></code>, <code><a href="#topic+export">export()</a></code>,
<code><a href="#topic+evaluate">evaluate()</a></code>, <code><a href="#topic+clear">clear()</a></code>, <code><a href="#topic+configure_bar">configure_bar()</a></code>,
<code><a href="#topic+par_sapply">par_sapply()</a></code>, <code><a href="#topic+par_apply">par_apply()</a></code>, <code><a href="#topic+stop_backend">stop_backend()</a></code>,
<code><a href="#topic+set_option">set_option()</a></code>, <code><a href="#topic+get_option">get_option()</a></code>, <code><a href="#topic+Options">Options</a></code>,
<code><a href="#topic+UserApiConsumer">UserApiConsumer</a></code>, and <code><a href="#topic+BackendService">BackendService</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Define a simple task.
task &lt;- function(x) {
    # Perform computations.
    Sys.sleep(0.01)

    # Return the result.
    return(x + 1)
}

# Start an asynchronous backend.
backend &lt;- start_backend(cores = 2, cluster_type = "psock", backend_type = "async")

# Run a task in parallel.
results &lt;- par_lapply(backend, x = 1:300, fun = task)

# Disable progress tracking.
set_option("progress_track", FALSE)

# Run a task in parallel.
results &lt;- par_lapply(backend, x = 1:300, fun = task)

# Enable progress tracking.
set_option("progress_track", TRUE)

# Change the progress bar options.
configure_bar(type = "modern", format = "[:bar] :percent")

# Run a task in parallel.
results &lt;- par_lapply(backend, x = 1:300, fun = task)

# Stop the backend.
stop_backend(backend)

# Start a synchronous backend.
backend &lt;- start_backend(cores = 2, cluster_type = "psock", backend_type = "sync")

# Run a task in parallel.
results &lt;- par_lapply(backend, x = 1:300, fun = task)

# Disable progress tracking to remove the warning that progress is not supported.
set_option("progress_track", FALSE)

# Run a task in parallel.
results &lt;- par_lapply(backend, x = 1:300, fun = task)

# Stop the backend.
stop_backend(backend)

# Run the task using the `base::lapply` (i.e., non-parallel).
results &lt;- par_lapply(NULL, x = 1:300, fun = task)



</code></pre>

<hr>
<h2 id='par_sapply'>Run a Task in Parallel</h2><span id='topic+par_sapply'></span>

<h3>Description</h3>

<p>This function can be used to run a task in parallel. The task is executed in
parallel on the specified backend, similar to <code><a href="parallel.html#topic+clusterApply">parallel::parSapply()</a></code>. If
<code>backend = NULL</code>, the task is executed sequentially using <code><a href="base.html#topic+lapply">base::sapply()</a></code>.
See the <strong>Details</strong> section for more information on how this function works.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par_sapply(backend = NULL, x, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="par_sapply_+3A_backend">backend</code></td>
<td>
<p>An object of class <code><a href="#topic+Backend">Backend</a></code> as returned by the
<code><a href="#topic+start_backend">start_backend()</a></code> function. It can also be <code>NULL</code> to run the task
sequentially via <code><a href="base.html#topic+lapply">base::sapply()</a></code>. The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="par_sapply_+3A_x">x</code></td>
<td>
<p>An atomic vector or list to pass to the <code>fun</code> function.</p>
</td></tr>
<tr><td><code id="par_sapply_+3A_fun">fun</code></td>
<td>
<p>A function to apply to each element of <code>x</code>.</p>
</td></tr>
<tr><td><code id="par_sapply_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the <code>fun</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the <code><a href="#topic+UserApiConsumer">UserApiConsumer</a></code> class that acts like an
interface for the developer API of the <code><a href="#topic+parabar">parabar</a></code> package.
</p>


<h3>Value</h3>

<p>A vector of the same length as <code>x</code> containing the results of the <code>fun</code>. The
output format resembles that of <code><a href="base.html#topic+lapply">base::sapply()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+start_backend">start_backend()</a></code>, <code><a href="#topic+peek">peek()</a></code>, <code><a href="#topic+export">export()</a></code>,
<code><a href="#topic+evaluate">evaluate()</a></code>, <code><a href="#topic+clear">clear()</a></code>, <code><a href="#topic+configure_bar">configure_bar()</a></code>,
<code><a href="#topic+par_lapply">par_lapply()</a></code>, <code><a href="#topic+par_apply">par_apply()</a></code>, <code><a href="#topic+stop_backend">stop_backend()</a></code>,
<code><a href="#topic+set_option">set_option()</a></code>, <code><a href="#topic+get_option">get_option()</a></code>, <code><a href="#topic+Options">Options</a></code>,
<code><a href="#topic+UserApiConsumer">UserApiConsumer</a></code>, and <code><a href="#topic+BackendService">BackendService</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Define a simple task.
task &lt;- function(x) {
    # Perform computations.
    Sys.sleep(0.01)

    # Return the result.
    return(x + 1)
}

# Start an asynchronous backend.
backend &lt;- start_backend(cores = 2, cluster_type = "psock", backend_type = "async")

# Run a task in parallel.
results &lt;- par_sapply(backend, x = 1:300, fun = task)

# Disable progress tracking.
set_option("progress_track", FALSE)

# Run a task in parallel.
results &lt;- par_sapply(backend, x = 1:300, fun = task)

# Enable progress tracking.
set_option("progress_track", TRUE)

# Change the progress bar options.
configure_bar(type = "modern", format = "[:bar] :percent")

# Run a task in parallel.
results &lt;- par_sapply(backend, x = 1:300, fun = task)

# Stop the backend.
stop_backend(backend)

# Start a synchronous backend.
backend &lt;- start_backend(cores = 2, cluster_type = "psock", backend_type = "sync")

# Run a task in parallel.
results &lt;- par_sapply(backend, x = 1:300, fun = task)

# Disable progress tracking to remove the warning that progress is not supported.
set_option("progress_track", FALSE)

# Run a task in parallel.
results &lt;- par_sapply(backend, x = 1:300, fun = task)

# Stop the backend.
stop_backend(backend)

# Run the task using the `base::sapply` (i.e., non-parallel).
results &lt;- par_sapply(NULL, x = 1:300, fun = task)



</code></pre>

<hr>
<h2 id='peek'>Inspect a Backend</h2><span id='topic+peek'></span>

<h3>Description</h3>

<p>This function can be used to check the names of the variables present on a
<code><a href="#topic+Backend">backend</a></code> created by <code><a href="#topic+start_backend">start_backend()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peek(backend)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="peek_+3A_backend">backend</code></td>
<td>
<p>An object of class <code><a href="#topic+Backend">Backend</a></code> as returned by the
<code><a href="#topic+start_backend">start_backend()</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a convenience wrapper around the lower-lever API of
<code><a href="#topic+parabar">parabar</a></code> aimed at developers. More specifically, this function
calls the <code><a href="#topic+BackendService">peek</a></code> method on the provided
<code><a href="#topic+Backend">backend</a></code> instance.
</p>


<h3>Value</h3>

<p>The function returns a list of character vectors, where each list element
corresponds to a node, and each element of the character vector is the name
of a variable present on that node. It throws an error if the value provided
for the <code>backend</code> argument is not an instance of class <code><a href="#topic+Backend">Backend</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+start_backend">start_backend()</a></code>, <code><a href="#topic+export">export()</a></code>, <code><a href="#topic+evaluate">evaluate()</a></code>,
<code><a href="#topic+clear">clear()</a></code>, <code><a href="#topic+configure_bar">configure_bar()</a></code>, <code><a href="#topic+par_sapply">par_sapply()</a></code>,
<code><a href="#topic+par_lapply">par_lapply()</a></code>, <code><a href="#topic+par_apply">par_apply()</a></code>, <code><a href="#topic+stop_backend">stop_backend()</a></code>,
and <code><a href="#topic+BackendService">BackendService</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an asynchronous backend.
backend &lt;- start_backend(cores = 2, cluster_type = "psock", backend_type = "async")

# Check that the backend is active.
backend$active

# Check if there is anything on the backend.
peek(backend)

# Create a dummy variable.
name &lt;- "parabar"

# Export the `name` variable in the current environment to the backend.
export(backend, "name", environment())

# Remove the dummy variable from the current environment.
rm(name)

# Check the backend to see that the variable has been exported.
peek(backend)

# Run an expression on the backend.
# Note that the symbols in the expression are resolved on the backend.
evaluate(backend, {
    # Print the name.
    print(paste0("Hello, ", name, "!"))
})

# Clear the backend.
clear(backend)

# Check that there is nothing on the backend.
peek(backend)

# Use a basic progress bar (i.e., see `parabar::Bar`).
configure_bar(type = "basic", style = 3)

# Run a task in parallel (i.e., approx. 1.25 seconds).
output &lt;- par_sapply(backend, x = 1:10, fun = function(x) {
    # Sleep a bit.
    Sys.sleep(0.25)

    # Compute and return.
    return(x + 1)
})

# Print the output.
print(output)

# Stop the backend.
stop_backend(backend)

# Check that the backend is not active.
backend$active

</code></pre>

<hr>
<h2 id='ProgressTrackingContext'>ProgressTrackingContext</h2><span id='topic+ProgressTrackingContext'></span>

<h3>Description</h3>

<p>This class represents a progress tracking context for interacting with
<code><a href="#topic+Backend">Backend</a></code> implementations via the <code><a href="#topic+BackendService">BackendService</a></code>
interface.
</p>


<h3>Details</h3>

<p>This class extends the base <code><a href="#topic+Context">Context</a></code> class and overrides the
<code><a href="#topic+Context">sapply</a></code> parent method to decorate the backend instance
with additional functionality. Specifically, this class creates a temporary
file to log the progress of backend tasks, and then creates a progress bar to
display the progress of the backend tasks.
</p>
<p>The progress bar is updated after each backend task execution. The timeout
between subsequent checks of the temporary log file is controlled by the
<code><a href="#topic+Options">Options</a></code> class and defaults to <code>0.001</code>. This value can be
adjusted via the <code><a href="#topic+Options">Options</a></code> instance present in the session
<code><a href="base.html#topic+options">base::.Options</a></code> list (i.e., see <code><a href="#topic+set_option">set_option()</a></code>). For example, to
set the timeout to <code>0.1</code> we can run <code>set_option("progress_timeout", 0.1)</code>.
</p>
<p>This class is a good example of how to extend the base <code><a href="#topic+Context">Context</a></code>
class to decorate the backend instance with additional functionality.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+BackendService">parabar::BackendService</a></code> -&gt; <code><a href="#topic+Context">parabar::Context</a></code> -&gt; <code>ProgressTrackingContext</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>bar</code></dt><dd><p>The <code><a href="#topic+Bar">Bar</a></code> instance registered with the context.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ProgressTrackingContext-set_backend"><code>ProgressTrackingContext$set_backend()</code></a>
</p>
</li>
<li> <p><a href="#method-ProgressTrackingContext-set_bar"><code>ProgressTrackingContext$set_bar()</code></a>
</p>
</li>
<li> <p><a href="#method-ProgressTrackingContext-configure_bar"><code>ProgressTrackingContext$configure_bar()</code></a>
</p>
</li>
<li> <p><a href="#method-ProgressTrackingContext-sapply"><code>ProgressTrackingContext$sapply()</code></a>
</p>
</li>
<li> <p><a href="#method-ProgressTrackingContext-lapply"><code>ProgressTrackingContext$lapply()</code></a>
</p>
</li>
<li> <p><a href="#method-ProgressTrackingContext-apply"><code>ProgressTrackingContext$apply()</code></a>
</p>
</li>
<li> <p><a href="#method-ProgressTrackingContext-clone"><code>ProgressTrackingContext$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="parabar" data-topic="Context" data-id="clear"><a href='../../parabar/html/Context.html#method-Context-clear'><code>parabar::Context$clear()</code></a></span></li>
<li><span class="pkg-link" data-pkg="parabar" data-topic="Context" data-id="evaluate"><a href='../../parabar/html/Context.html#method-Context-evaluate'><code>parabar::Context$evaluate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="parabar" data-topic="Context" data-id="export"><a href='../../parabar/html/Context.html#method-Context-export'><code>parabar::Context$export()</code></a></span></li>
<li><span class="pkg-link" data-pkg="parabar" data-topic="Context" data-id="get_output"><a href='../../parabar/html/Context.html#method-Context-get_output'><code>parabar::Context$get_output()</code></a></span></li>
<li><span class="pkg-link" data-pkg="parabar" data-topic="Context" data-id="initialize"><a href='../../parabar/html/Context.html#method-Context-initialize'><code>parabar::Context$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="parabar" data-topic="Context" data-id="peek"><a href='../../parabar/html/Context.html#method-Context-peek'><code>parabar::Context$peek()</code></a></span></li>
<li><span class="pkg-link" data-pkg="parabar" data-topic="Context" data-id="start"><a href='../../parabar/html/Context.html#method-Context-start'><code>parabar::Context$start()</code></a></span></li>
<li><span class="pkg-link" data-pkg="parabar" data-topic="Context" data-id="stop"><a href='../../parabar/html/Context.html#method-Context-stop'><code>parabar::Context$stop()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ProgressTrackingContext-set_backend"></a>



<h4>Method <code>set_backend()</code></h4>

<p>Set the backend instance to be used by the context.
</p>


<h5>Usage</h5>

<div class="r"><pre>ProgressTrackingContext$set_backend(backend)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>backend</code></dt><dd><p>An object of class <code><a href="#topic+Backend">Backend</a></code> that supports
progress tracking implements the <code><a href="#topic+BackendService">BackendService</a></code>
interface.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This method overrides the parent method to validate the backend
provided and guarantee it is an instance of the
<code><a href="#topic+AsyncBackend">AsyncBackend</a></code> class.
</p>


<hr>
<a id="method-ProgressTrackingContext-set_bar"></a>



<h4>Method <code>set_bar()</code></h4>

<p>Set the <code><a href="#topic+Bar">Bar</a></code> instance to be used by the context.
</p>


<h5>Usage</h5>

<div class="r"><pre>ProgressTrackingContext$set_bar(bar)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>bar</code></dt><dd><p>An object of class <code><a href="#topic+Bar">Bar</a></code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ProgressTrackingContext-configure_bar"></a>



<h4>Method <code>configure_bar()</code></h4>

<p>Configure the <code><a href="#topic+Bar">Bar</a></code> instance registered with the context.
</p>


<h5>Usage</h5>

<div class="r"><pre>ProgressTrackingContext$configure_bar(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>A list of named arguments passed to the <code>create()</code> method
of the <code><a href="#topic+Bar">Bar</a></code> instance. See the documentation of the
specific concrete bar for details (e.g., <code><a href="#topic+ModernBar">ModernBar</a></code>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ProgressTrackingContext-sapply"></a>



<h4>Method <code>sapply()</code></h4>

<p>Run a task on the backend akin to <code><a href="parallel.html#topic+clusterApply">parallel::parSapply()</a></code>, but with
a progress bar.
</p>


<h5>Usage</h5>

<div class="r"><pre>ProgressTrackingContext$sapply(x, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>An atomic vector or list to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>fun</code></dt><dd><p>A function to apply to each element of <code>x</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code><a href="#topic+Backend">Backend</a></code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-ProgressTrackingContext-lapply"></a>



<h4>Method <code>lapply()</code></h4>

<p>Run a task on the backend akin to <code><a href="parallel.html#topic+clusterApply">parallel::parLapply()</a></code>, but with
a progress bar.
</p>


<h5>Usage</h5>

<div class="r"><pre>ProgressTrackingContext$lapply(x, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>An atomic vector or list to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>fun</code></dt><dd><p>A function to apply to each element of <code>x</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code><a href="#topic+Backend">Backend</a></code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-ProgressTrackingContext-apply"></a>



<h4>Method <code>apply()</code></h4>

<p>Run a task on the backend akin to <code><a href="parallel.html#topic+clusterApply">parallel::parApply()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ProgressTrackingContext$apply(x, margin, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>An array to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>margin</code></dt><dd><p>A numeric vector indicating the dimensions of <code>x</code> the
<code>fun</code> function should be applied over. For example, for a matrix,
<code>margin = 1</code> indicates applying <code>fun</code> rows-wise, <code>margin = 2</code>
indicates applying <code>fun</code> columns-wise, and <code>margin = c(1, 2)</code>
indicates applying <code>fun</code> element-wise. Named dimensions are also
possible depending on <code>x</code>. See <code><a href="parallel.html#topic+clusterApply">parallel::parApply()</a></code> and
<code><a href="base.html#topic+apply">base::apply()</a></code> for more details.</p>
</dd>
<dt><code>fun</code></dt><dd><p>A function to apply to <code>x</code> according to the <code>margin</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code><a href="#topic+Backend">Backend</a></code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-ProgressTrackingContext-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ProgressTrackingContext$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Context">Context</a></code>, <code><a href="#topic+BackendService">BackendService</a></code>, <code><a href="#topic+Backend">Backend</a></code>, and
<code><a href="#topic+AsyncBackend">AsyncBackend</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a task to run in parallel.
task &lt;- function(x, y) {
    # Sleep a bit.
    Sys.sleep(0.15)

    # Return the result of a computation.
    return(x + y)
}

# Create a specification object.
specification &lt;- Specification$new()

# Set the number of cores.
specification$set_cores(cores = 2)

# Set the cluster type.
specification$set_type(type = "psock")

# Create a backend factory.
backend_factory &lt;- BackendFactory$new()

# Get a backend instance that does not support progress tracking.
backend &lt;- backend_factory$get("sync")

# Create a progress tracking context object.
context &lt;- ProgressTrackingContext$new()

# Attempt to set the incompatible backend instance.
try(context$set_backend(backend))

# Get a backend instance that does support progress tracking.
backend &lt;- backend_factory$get("async")

# Register the backend with the context.
context$set_backend(backend)

# From now all, all backend operations are intercepted by the context.

# Start the backend.
context$start(specification)

# Create a bar factory.
bar_factory &lt;- BarFactory$new()

# Get a modern bar instance.
bar &lt;- bar_factory$get("modern")

# Register the bar with the context.
context$set_bar(bar)

# Configure the bar.
context$configure_bar(
    show_after = 0,
    format = " &gt; completed :current out of :total tasks [:percent] [:elapsed]"
)

# Run a task in parallel (i.e., approx. 1.9 seconds).
context$sapply(x = 1:25, fun = task, y = 10)

# Get the task output.
backend$get_output(wait = TRUE)

# Change the bar type.
bar &lt;- bar_factory$get("basic")

# Register the bar with the context.
context$set_bar(bar)

# Remove the previous bar configuration.
context$configure_bar()

# Run a task in parallel (i.e., approx. 1.9 seconds).
context$sapply(x = 1:25, fun = task, y = 10)

# Get the task output.
backend$get_output(wait = TRUE)

# Close the backend.
context$stop()

</code></pre>

<hr>
<h2 id='SessionState'>SessionState</h2><span id='topic+SessionState'></span>

<h3>Description</h3>

<p>This class holds the state of a background <code><a href="callr.html#topic+r_session">session</a></code>
used by an asynchronous backend (i.e., <code><a href="#topic+AsyncBackend">AsyncBackend</a></code>). See the
<strong>Details</strong> section for more information.
</p>


<h3>Details</h3>

<p>The session state is useful to check if an asynchronous backend is ready for
certain operations. A session can only be in one of the following four states
at a time:
</p>

<ul>
<li> <p><code>session_is_starting</code>: When <code>TRUE</code>, it indicates that the session is
starting.
</p>
</li>
<li> <p><code>session_is_idle</code>: When <code>TRUE</code>, it indicates that the session is idle and
ready to execute operations.
</p>
</li>
<li> <p><code>session_is_busy</code>: When <code>TRUE</code>, it indicates that the session is busy
(i.e., see the <code><a href="#topic+TaskState">TaskState</a></code> class for more information about a
task's state).
</p>
</li>
<li> <p><code>session_is_finished</code>: When <code>TRUE</code>, it indicates that the session is closed
and no longer available for operations.
</p>
</li></ul>



<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>session_is_starting</code></dt><dd><p>A logical value indicating whether the
session is starting.</p>
</dd>
<dt><code>session_is_idle</code></dt><dd><p>A logical value indicating whether the session
is idle and ready to execute operations.</p>
</dd>
<dt><code>session_is_busy</code></dt><dd><p>A logical value indicating whether the session
is busy.</p>
</dd>
<dt><code>session_is_finished</code></dt><dd><p>A logical value indicating whether the
session is closed and no longer available for operations.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SessionState-new"><code>SessionState$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SessionState-clone"><code>SessionState$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-SessionState-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code><a href="#topic+SessionState">SessionState</a></code> object and determine the state
of a given background <code><a href="callr.html#topic+r_session">session</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>SessionState$new(session)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>session</code></dt><dd><p>A <code><a href="callr.html#topic+r_session">callr::r_session</a></code> object.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+SessionState">SessionState</a></code>.
</p>


<hr>
<a id="method-SessionState-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SessionState$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+TaskState">TaskState</a></code>, <code><a href="#topic+AsyncBackend">AsyncBackend</a></code> and
<code><a href="#topic+ProgressTrackingContext">ProgressTrackingContext</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Handy function to print the session states all at once.
check_state &lt;- function(session) {
    # Create a session object and determine its state.
    session_state &lt;- SessionState$new(session)

    # Print the state.
    cat(
        "Session is starting: ", session_state$session_is_starting, "\n",
        "Session is idle: ", session_state$session_is_idle, "\n",
        "Session is busy: ", session_state$session_is_busy, "\n",
        "Session is finished: ", session_state$session_is_finished, "\n",
        sep = ""
    )
}

# Create a specification object.
specification &lt;- Specification$new()

# Set the number of cores.
specification$set_cores(cores = 2)

# Set the cluster type.
specification$set_type(type = "psock")

# Create an asynchronous backend object.
backend &lt;- AsyncBackend$new()

# Start the cluster on the backend.
backend$start(specification)

# Check that the session is idle.
check_state(backend$cluster)

{
    # Run a task in parallel (i.e., approx. 0.25 seconds).
    backend$sapply(
        x = 1:10,
        fun = function(x) {
            # Sleep a bit.
            Sys.sleep(0.05)

            # Compute something.
            output &lt;- x + 1

            # Return the result.
            return(output)
        }
    )

    # And immediately check that the session is busy.
    check_state(backend$cluster)
}

# Get the output and wait for the task to complete.
output &lt;- backend$get_output(wait = TRUE)

# Check that the session is idle again.
check_state(backend$cluster)

# Manually close the session.
backend$cluster$close()

# Check that the session is finished.
check_state(backend$cluster)

# Stop the backend.
backend$stop()

</code></pre>

<hr>
<h2 id='Specification'>Specification</h2><span id='topic+Specification'></span>

<h3>Description</h3>

<p>This class contains the information required to start a backend. An instance
of this class is used by the <code>start</code> method of the
<code><a href="#topic+BackendService">BackendService</a></code> interface.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>cores</code></dt><dd><p>The number of nodes to use in the cluster creation.</p>
</dd>
<dt><code>type</code></dt><dd><p>The type of cluster to create.</p>
</dd>
<dt><code>types</code></dt><dd><p>The supported cluster types.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Specification-set_cores"><code>Specification$set_cores()</code></a>
</p>
</li>
<li> <p><a href="#method-Specification-set_type"><code>Specification$set_type()</code></a>
</p>
</li>
<li> <p><a href="#method-Specification-clone"><code>Specification$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Specification-set_cores"></a>



<h4>Method <code>set_cores()</code></h4>

<p>Set the number of nodes to use in the cluster.
</p>


<h5>Usage</h5>

<div class="r"><pre>Specification$set_cores(cores)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cores</code></dt><dd><p>The number of nodes to use in the cluster.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This method also performs a validation of the requested number of
cores, ensuring that the the value lies between <code>1</code> and
<code>parallel::detectCores() - 1</code>.
</p>


<hr>
<a id="method-Specification-set_type"></a>



<h4>Method <code>set_type()</code></h4>

<p>Set the type of cluster to create.
</p>


<h5>Usage</h5>

<div class="r"><pre>Specification$set_type(type)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>The type of cluster to create. Possible values are
<code>"fork"</code> and <code>"psock"</code>. Defaults to <code>"psock"</code>.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>If no type is explicitly requested (i.e., <code>type = NULL</code>), the type is
determined based on the operating system. On Unix-like systems, the
type is set to <code>"fork"</code>, while on Windows systems, the type is set to
<code>"psock"</code>. If an unknown type is requested, a warning is issued and
the type is set to <code>"psock"</code>.
</p>


<hr>
<a id="method-Specification-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Specification$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+BackendService">BackendService</a></code>, <code><a href="#topic+Backend">Backend</a></code>, <code><a href="#topic+SyncBackend">SyncBackend</a></code>,
and <code><a href="#topic+AsyncBackend">AsyncBackend</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a specification object.
specification &lt;- Specification$new()

# Set the number of cores.
specification$set_cores(cores = 4)

# Set the cluster type.
specification$set_type(type = "psock")

# Get the number of cores.
specification$cores

# Get the cluster type.
specification$type

# Attempt to set too many cores.
specification$set_cores(cores = 100)

# Check that the cores were reasonably set.
specification$cores

# Allow the object to determine the adequate cluster type.
specification$set_type(type = NULL)

# Check the type determined.
specification$type

# Attempt to set an invalid cluster type.
specification$set_type(type = "invalid")

# Check that the type was set to `psock`.
specification$type

</code></pre>

<hr>
<h2 id='start_backend'>Start a Backend</h2><span id='topic+start_backend'></span>

<h3>Description</h3>

<p>This function can be used to start a backend. Check out the <strong>Details</strong>
section for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>start_backend(cores, cluster_type = "psock", backend_type = "async")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="start_backend_+3A_cores">cores</code></td>
<td>
<p>A positive integer representing the number of cores to use
(i.e., the number of processes to start). This value must be between <code>2</code> and
<code>parallel::detectCores() - 1</code>.</p>
</td></tr>
<tr><td><code id="start_backend_+3A_cluster_type">cluster_type</code></td>
<td>
<p>A character string representing the type of cluster to
create. Possible values are <code>"fork"</code> and <code>"psock"</code>. Defaults to <code>"psock"</code>.
See the section <strong>Cluster Type</strong> for more information.</p>
</td></tr>
<tr><td><code id="start_backend_+3A_backend_type">backend_type</code></td>
<td>
<p>A character string representing the type of backend to
create. Possible values are <code>"sync"</code> and <code>"async"</code>. Defaults to <code>"async"</code>.
See the section <strong>Backend Type</strong> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a convenience wrapper around the lower-lever API of
<code><a href="#topic+parabar">parabar</a></code> aimed at developers. More specifically, this function
uses the <code><a href="#topic+Specification">Specification</a></code> class to create a specification object,
and the <code><a href="#topic+BackendFactory">BackendFactory</a></code> class to create a <code><a href="#topic+Backend">Backend</a></code>
instance based on the specification object.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+Backend">Backend</a></code> instance that can be used to parallelize computations.
The methods available on the <code><a href="#topic+Backend">Backend</a></code> instance are defined by the
<code><a href="#topic+BackendService">BackendService</a></code> interface.
</p>


<h3>Cluster Type</h3>

<p>The cluster type determines the type of cluster to create. The requested
value is validated and passed to the <code>type</code> argument of the
<code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code> function. The following table lists the possible
values and their corresponding description.</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Cluster</strong> </td><td style="text-align: left;"> <strong>Description</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"fork"</code> </td><td style="text-align: left;"> For Unix-based systems. </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"psock"</code> </td><td style="text-align: left;"> For Windows-based systems. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Backend Type</h3>

<p>The backend type determines the type of backend to create. The requested
value is passed to the <code><a href="#topic+BackendFactory">BackendFactory</a></code> class, which returns a
<code><a href="#topic+Backend">Backend</a></code> instance of the desired type. The following table lists
the possible backend types and their corresponding description.</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Backend</strong> </td><td style="text-align: left;"> <strong>Description</strong> </td><td style="text-align: left;"> <strong>Implementation</strong> </td><td style="text-align: center;"> <strong>Progress</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"sync"</code> </td><td style="text-align: left;"> A synchronous backend. </td><td style="text-align: left;"> <code><a href="#topic+SyncBackend">SyncBackend</a></code> </td><td style="text-align: center;"> no </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"async"</code> </td><td style="text-align: left;"> An asynchronous backend. </td><td style="text-align: left;"> <code><a href="#topic+AsyncBackend">AsyncBackend</a></code> </td><td style="text-align: center;"> yes </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>In a nutshell, the difference between the two backend types is that for the
synchronous backend the cluster is created in the main process, while for the
asynchronous backend the cluster is created in a backend <code>R</code> process using
<code><a href="callr.html#topic+r_session">callr::r_session</a></code>. Therefore, the synchronous backend is blocking the main
process during task execution, while the asynchronous backend is
non-blocking. Check out the implementations listed in the table above for
more information. All concrete implementations extend the
<code><a href="#topic+Backend">Backend</a></code> abstract class and implement the
<code><a href="#topic+BackendService">BackendService</a></code> interface.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+peek">peek()</a></code>, <code><a href="#topic+export">export()</a></code>, <code><a href="#topic+evaluate">evaluate()</a></code>,
<code><a href="#topic+clear">clear()</a></code>, <code><a href="#topic+configure_bar">configure_bar()</a></code>, <code><a href="#topic+par_sapply">par_sapply()</a></code>,
<code><a href="#topic+par_lapply">par_lapply()</a></code>, <code><a href="#topic+par_apply">par_apply()</a></code>, <code><a href="#topic+stop_backend">stop_backend()</a></code>,
and <code><a href="#topic+BackendService">BackendService</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an asynchronous backend.
backend &lt;- start_backend(cores = 2, cluster_type = "psock", backend_type = "async")

# Check that the backend is active.
backend$active

# Check if there is anything on the backend.
peek(backend)

# Create a dummy variable.
name &lt;- "parabar"

# Export the `name` variable in the current environment to the backend.
export(backend, "name", environment())

# Remove the dummy variable from the current environment.
rm(name)

# Check the backend to see that the variable has been exported.
peek(backend)

# Run an expression on the backend.
# Note that the symbols in the expression are resolved on the backend.
evaluate(backend, {
    # Print the name.
    print(paste0("Hello, ", name, "!"))
})

# Clear the backend.
clear(backend)

# Check that there is nothing on the backend.
peek(backend)

# Use a basic progress bar (i.e., see `parabar::Bar`).
configure_bar(type = "basic", style = 3)

# Run a task in parallel (i.e., approx. 1.25 seconds).
output &lt;- par_sapply(backend, x = 1:10, fun = function(x) {
    # Sleep a bit.
    Sys.sleep(0.25)

    # Compute and return.
    return(x + 1)
})

# Print the output.
print(output)

# Stop the backend.
stop_backend(backend)

# Check that the backend is not active.
backend$active

</code></pre>

<hr>
<h2 id='stop_backend'>Stop a Backend</h2><span id='topic+stop_backend'></span>

<h3>Description</h3>

<p>This function can be used to stop a <code><a href="#topic+Backend">backend</a></code> created
by <code><a href="#topic+start_backend">start_backend()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_backend(backend)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stop_backend_+3A_backend">backend</code></td>
<td>
<p>An object of class <code><a href="#topic+Backend">Backend</a></code> as returned by the
<code><a href="#topic+start_backend">start_backend()</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a convenience wrapper around the lower-lever API of
<code><a href="#topic+parabar">parabar</a></code> aimed at developers. More specifically, this function
calls the <code><a href="#topic+BackendService">stop</a></code> method on the provided
<code><a href="#topic+Backend">backend</a></code> instance.
</p>


<h3>Value</h3>

<p>The function returns void. It throws an error if:
</p>

<ul>
<li><p> the value provided for the <code>backend</code> argument is not an instance of class
<code><a href="#topic+Backend">Backend</a></code>.
</p>
</li>
<li><p> the <code><a href="#topic+Backend">backend</a></code> object provided is already stopped
(i.e., is not active).
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+start_backend">start_backend()</a></code>, <code><a href="#topic+peek">peek()</a></code>, <code><a href="#topic+export">export()</a></code>,
<code><a href="#topic+evaluate">evaluate()</a></code>, <code><a href="#topic+clear">clear()</a></code>, <code><a href="#topic+configure_bar">configure_bar()</a></code>,
<code><a href="#topic+par_sapply">par_sapply()</a></code>, <code><a href="#topic+par_apply">par_apply()</a></code>, <code><a href="#topic+par_lapply">par_lapply()</a></code>, and
<code><a href="#topic+BackendService">BackendService</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an asynchronous backend.
backend &lt;- start_backend(cores = 2, cluster_type = "psock", backend_type = "async")

# Check that the backend is active.
backend$active

# Check if there is anything on the backend.
peek(backend)

# Create a dummy variable.
name &lt;- "parabar"

# Export the `name` variable in the current environment to the backend.
export(backend, "name", environment())

# Remove the dummy variable from the current environment.
rm(name)

# Check the backend to see that the variable has been exported.
peek(backend)

# Run an expression on the backend.
# Note that the symbols in the expression are resolved on the backend.
evaluate(backend, {
    # Print the name.
    print(paste0("Hello, ", name, "!"))
})

# Clear the backend.
clear(backend)

# Check that there is nothing on the backend.
peek(backend)

# Use a basic progress bar (i.e., see `parabar::Bar`).
configure_bar(type = "basic", style = 3)

# Run a task in parallel (i.e., approx. 1.25 seconds).
output &lt;- par_sapply(backend, x = 1:10, fun = function(x) {
    # Sleep a bit.
    Sys.sleep(0.25)

    # Compute and return.
    return(x + 1)
})

# Print the output.
print(output)

# Stop the backend.
stop_backend(backend)

# Check that the backend is not active.
backend$active

</code></pre>

<hr>
<h2 id='SyncBackend'>SyncBackend</h2><span id='topic+SyncBackend'></span>

<h3>Description</h3>

<p>This is a concrete implementation of the abstract class <code><a href="#topic+Backend">Backend</a></code>
that implements the <code><a href="#topic+BackendService">BackendService</a></code> interface. This backend
executes tasks in parallel on a <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code> cluster
synchronously (i.e., blocking the main <code>R</code> session).
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+BackendService">parabar::BackendService</a></code> -&gt; <code><a href="#topic+Backend">parabar::Backend</a></code> -&gt; <code>SyncBackend</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SyncBackend-new"><code>SyncBackend$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SyncBackend-start"><code>SyncBackend$start()</code></a>
</p>
</li>
<li> <p><a href="#method-SyncBackend-stop"><code>SyncBackend$stop()</code></a>
</p>
</li>
<li> <p><a href="#method-SyncBackend-clear"><code>SyncBackend$clear()</code></a>
</p>
</li>
<li> <p><a href="#method-SyncBackend-peek"><code>SyncBackend$peek()</code></a>
</p>
</li>
<li> <p><a href="#method-SyncBackend-export"><code>SyncBackend$export()</code></a>
</p>
</li>
<li> <p><a href="#method-SyncBackend-evaluate"><code>SyncBackend$evaluate()</code></a>
</p>
</li>
<li> <p><a href="#method-SyncBackend-sapply"><code>SyncBackend$sapply()</code></a>
</p>
</li>
<li> <p><a href="#method-SyncBackend-lapply"><code>SyncBackend$lapply()</code></a>
</p>
</li>
<li> <p><a href="#method-SyncBackend-apply"><code>SyncBackend$apply()</code></a>
</p>
</li>
<li> <p><a href="#method-SyncBackend-get_output"><code>SyncBackend$get_output()</code></a>
</p>
</li>
<li> <p><a href="#method-SyncBackend-clone"><code>SyncBackend$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-SyncBackend-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code><a href="#topic+SyncBackend">SyncBackend</a></code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>SyncBackend$new()</pre></div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+SyncBackend">SyncBackend</a></code>.
</p>


<hr>
<a id="method-SyncBackend-start"></a>



<h4>Method <code>start()</code></h4>

<p>Start the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>SyncBackend$start(specification)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>specification</code></dt><dd><p>An object of class <code><a href="#topic+Specification">Specification</a></code>
that contains the backend configuration.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns void. The resulting backend must be stored in the
<code>.cluster</code> private field on the <code><a href="#topic+Backend">Backend</a></code> abstract class,
and accessible to any concrete backend implementations via the active
binding <code>cluster</code>.
</p>


<hr>
<a id="method-SyncBackend-stop"></a>



<h4>Method <code>stop()</code></h4>

<p>Stop the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>SyncBackend$stop()</pre></div>



<h5>Returns</h5>

<p>This method returns void.
</p>


<hr>
<a id="method-SyncBackend-clear"></a>



<h4>Method <code>clear()</code></h4>

<p>Remove all objects from the backend. This function is equivalent to
calling <code>rm(list = ls(all.names = TRUE))</code> on each node in the
backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>SyncBackend$clear()</pre></div>



<h5>Returns</h5>

<p>This method returns void.
</p>


<hr>
<a id="method-SyncBackend-peek"></a>



<h4>Method <code>peek()</code></h4>

<p>Inspect the backend for variables available in the <code>.GlobalEnv</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>SyncBackend$peek()</pre></div>



<h5>Returns</h5>

<p>This method returns a list of character vectors, where each element
corresponds to a node in the backend. The character vectors contain
the names of the variables available in the <code>.GlobalEnv</code> on each
node.
</p>


<hr>
<a id="method-SyncBackend-export"></a>



<h4>Method <code>export()</code></h4>

<p>Export variables from a given environment to the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>SyncBackend$export(variables, environment)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>variables</code></dt><dd><p>A character vector of variable names to export.</p>
</dd>
<dt><code>environment</code></dt><dd><p>An environment object from which to export the
variables. Defaults to the parent frame.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns void.
</p>


<hr>
<a id="method-SyncBackend-evaluate"></a>



<h4>Method <code>evaluate()</code></h4>

<p>Evaluate an arbitrary expression on the backend.
</p>


<h5>Usage</h5>

<div class="r"><pre>SyncBackend$evaluate(expression)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expression</code></dt><dd><p>An unquoted expression to evaluate on the backend.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns the result of the expression evaluation.
</p>


<hr>
<a id="method-SyncBackend-sapply"></a>



<h4>Method <code>sapply()</code></h4>

<p>Run a task on the backend akin to <code><a href="parallel.html#topic+clusterApply">parallel::parSapply()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>SyncBackend$sapply(x, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>An atomic vector or list to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>fun</code></dt><dd><p>A function to apply to each element of <code>x</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code><a href="#topic+Backend">Backend</a></code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-SyncBackend-lapply"></a>



<h4>Method <code>lapply()</code></h4>

<p>Run a task on the backend akin to <code><a href="parallel.html#topic+clusterApply">parallel::parLapply()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>SyncBackend$lapply(x, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>An atomic vector or list to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>fun</code></dt><dd><p>A function to apply to each element of <code>x</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code><a href="#topic+Backend">Backend</a></code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-SyncBackend-apply"></a>



<h4>Method <code>apply()</code></h4>

<p>Run a task on the backend akin to <code><a href="parallel.html#topic+clusterApply">parallel::parApply()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>SyncBackend$apply(x, margin, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>An array to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>margin</code></dt><dd><p>A numeric vector indicating the dimensions of <code>x</code> the
<code>fun</code> function should be applied over. For example, for a matrix,
<code>margin = 1</code> indicates applying <code>fun</code> rows-wise, <code>margin = 2</code>
indicates applying <code>fun</code> columns-wise, and <code>margin = c(1, 2)</code>
indicates applying <code>fun</code> element-wise. Named dimensions are also
possible depending on <code>x</code>. See <code><a href="parallel.html#topic+clusterApply">parallel::parApply()</a></code> and
<code><a href="base.html#topic+apply">base::apply()</a></code> for more details.</p>
</dd>
<dt><code>fun</code></dt><dd><p>A function to apply to <code>x</code> according to the <code>margin</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>This method returns void. The output of the task execution must be
stored in the private field <code>.output</code> on the <code><a href="#topic+Backend">Backend</a></code>
abstract class, and is accessible via the <code>get_output()</code> method.
</p>


<hr>
<a id="method-SyncBackend-get_output"></a>



<h4>Method <code>get_output()</code></h4>

<p>Get the output of the task execution.
</p>


<h5>Usage</h5>

<div class="r"><pre>SyncBackend$get_output(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Additional arguments currently not in use.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This method fetches the output of the task execution after calling
the <code>sapply()</code> method. It returns the output and immediately removes
it from the backend. Therefore, subsequent calls to this method will
return <code>NULL</code>. This method should be called after the execution of a
task.
</p>



<h5>Returns</h5>

<p>A vector, matrix, or list of the same length as <code>x</code>, containing the
results of the <code>fun</code>. The output format differs based on the specific
operation employed. Check out the documentation for the <code>apply</code>
operations of <code><a href="parallel.html#topic+parallel-package">parallel::parallel</a></code> for more information.
</p>


<hr>
<a id="method-SyncBackend-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SyncBackend$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+BackendService">BackendService</a></code>, <code><a href="#topic+Backend">Backend</a></code>, <code><a href="#topic+AsyncBackend">AsyncBackend</a></code>,
and <code><a href="#topic+Context">Context</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a specification object.
specification &lt;- Specification$new()

# Set the number of cores.
specification$set_cores(cores = 2)

# Set the cluster type.
specification$set_type(type = "psock")

# Create a synchronous backend object.
backend &lt;- SyncBackend$new()

# Start the cluster on the backend.
backend$start(specification)

# Check if there is anything on the backend.
backend$peek()

# Create a dummy variable.
name &lt;- "parabar"

# Export the variable from the current environment to the backend.
backend$export("name", environment())

# Remove variable from current environment.
rm(name)

# Run an expression on the backend, using the exported variable `name`.
backend$evaluate({
    # Print the name.
    print(paste0("Hello, ", name, "!"))
})

# Run a task in parallel (i.e., approx. 1.25 seconds).
backend$sapply(
    x = 1:10,
    fun = function(x) {
        # Sleep a bit.
        Sys.sleep(0.25)

        # Compute something.
        output &lt;- x + 1

        # Return the result.
        return(output)
    }
)

# Get the task output.
backend$get_output()

# Clear the backend.
backend$clear()

# Check that there is nothing on the cluster.
backend$peek()

# Stop the backend.
backend$stop()

# Check that the backend is not active.
backend$active

</code></pre>

<hr>
<h2 id='TaskState'>TaskState</h2><span id='topic+TaskState'></span>

<h3>Description</h3>

<p>This class holds the state of a task deployed to an asynchronous backend
(i.e., <code><a href="#topic+AsyncBackend">AsyncBackend</a></code>). See the <strong>Details</strong> section for more
information.
</p>


<h3>Details</h3>

<p>The task state is useful to check if an asynchronous backend is free to
execute other operations. A task can only be in one of the following three
states at a time:
</p>

<ul>
<li> <p><code>task_not_started</code>: When <code>TRUE</code>, it indicates whether the backend is free
to execute another operation.
</p>
</li>
<li> <p><code>task_is_running</code>: When <code>TRUE</code>, it indicates that there is a task running
on the backend.
</p>
</li>
<li> <p><code>task_is_completed</code>: When <code>TRUE</code>, it indicates that the task has been
completed, but the backend is still busy because the task output has not
been retrieved.
</p>
</li></ul>

<p>The task state is determined based on the state of the background
<code><a href="callr.html#topic+r_session">session</a></code> (i.e., see the <code>get_state</code> method for
<code><a href="callr.html#topic+r_session">callr::r_session</a></code>) and the state of the task execution inferred from
polling the process (i.e., see the <code>poll_process</code> method for
<code><a href="callr.html#topic+r_session">callr::r_session</a></code>) as follows:</p>

<table>
<tr>
 <td style="text-align: center;">
   Session State </td><td style="text-align: center;"> Execution State </td><td style="text-align: center;"> Not Started </td><td style="text-align: center;"> Is Running </td><td style="text-align: center;"> Is Completed </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>idle</code> </td><td style="text-align: center;"> <code>timeout</code> </td><td style="text-align: center;"> <code>TRUE</code> </td><td style="text-align: center;"> <code>FALSE</code> </td><td style="text-align: center;"> <code>FALSE</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>busy</code> </td><td style="text-align: center;"> <code>timeout</code> </td><td style="text-align: center;"> <code>FALSE</code> </td><td style="text-align: center;"> <code>TRUE</code> </td><td style="text-align: center;"> <code>FALSE</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
   <code>busy</code> </td><td style="text-align: center;"> <code>ready</code> </td><td style="text-align: center;"> <code>FALSE</code> </td><td style="text-align: center;"> <code>FALSE</code> </td><td style="text-align: center;"> <code>TRUE</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>



<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>task_not_started</code></dt><dd><p>A logical value indicating whether the task
has been started. It is used to determine if the backend is free to
execute another operation.</p>
</dd>
<dt><code>task_is_running</code></dt><dd><p>A logical value indicating whether the task is
running.</p>
</dd>
<dt><code>task_is_completed</code></dt><dd><p>A logical value indicating whether the task
has been completed and the output needs to be retrieved.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TaskState-new"><code>TaskState$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TaskState-clone"><code>TaskState$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-TaskState-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code><a href="#topic+TaskState">TaskState</a></code> object and determine the state of
a task on a given background <code><a href="callr.html#topic+r_session">session</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>TaskState$new(session)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>session</code></dt><dd><p>A <code><a href="callr.html#topic+r_session">callr::r_session</a></code> object.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An object of class <code><a href="#topic+TaskState">TaskState</a></code>.
</p>


<hr>
<a id="method-TaskState-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TaskState$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+SessionState">SessionState</a></code>, <code><a href="#topic+AsyncBackend">AsyncBackend</a></code> and
<code><a href="#topic+ProgressTrackingContext">ProgressTrackingContext</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Handy function to print the task states all at once.
check_state &lt;- function(session) {
    # Create a task state object and determine the state.
    task_state &lt;- TaskState$new(session)

    # Print the state.
    cat(
        "Task not started: ", task_state$task_not_started, "\n",
        "Task is running: ", task_state$task_is_running, "\n",
        "Task is completed: ", task_state$task_is_completed, "\n",
        sep = ""
    )
}

# Create a specification object.
specification &lt;- Specification$new()

# Set the number of cores.
specification$set_cores(cores = 2)

# Set the cluster type.
specification$set_type(type = "psock")

# Create an asynchronous backend object.
backend &lt;- AsyncBackend$new()

# Start the cluster on the backend.
backend$start(specification)

# Check that the task has not been started (i.e., the backend is free).
check_state(backend$cluster)

{
    # Run a task in parallel (i.e., approx. 0.25 seconds).
    backend$sapply(
        x = 1:10,
        fun = function(x) {
            # Sleep a bit.
            Sys.sleep(0.05)

            # Compute something.
            output &lt;- x + 1

            # Return the result.
            return(output)
        }
    )

    # And immediately check the state to see that the task is running.
    check_state(backend$cluster)
}

# Sleep for a bit to wait for the task to complete.
Sys.sleep(1)

# Check that the task is completed (i.e., the output needs to be retrieved).
check_state(backend$cluster)

# Get the output.
output &lt;- backend$get_output(wait = TRUE)

# Check that the task has not been started (i.e., the backend is free again).
check_state(backend$cluster)

# Stop the backend.
backend$stop()

</code></pre>

<hr>
<h2 id='UserApiConsumer'>UserApiConsumer</h2><span id='topic+UserApiConsumer'></span>

<h3>Description</h3>

<p>This class is an opinionated interface around the developer API of the
<code><a href="#topic+parabar">parabar</a></code> package. See the <strong>Details</strong> section for more
information on how this class works.
</p>


<h3>Details</h3>

<p>This class acts as a wrapper around the <code><a href="R6.html#topic+R6Class">R6::R6</a></code> developer API of the
<code><a href="#topic+parabar">parabar</a></code> package. In a nutshell, it provides an opinionated
interface by wrapping the developer API in simple functional calls. More
specifically, for executing a task in parallel, this class performs the
following steps:
</p>

<ul>
<li><p> Validates the backend provided.
</p>
</li>
<li><p> Instantiates an appropriate <code><a href="#topic+parabar">parabar</a></code> context based on the
backend. If the backend supports progress tracking (i.e., the backend is an
instance of <code><a href="#topic+AsyncBackend">AsyncBackend</a></code>), a progress tracking context (i.e.,
<code><a href="#topic+ProgressTrackingContext">ProgressTrackingContext</a></code>) is instantiated and used. Otherwise,
a regular context (i.e., <code><a href="#topic+Context">Context</a></code>) is instantiated. A regular
context is also used if the progress tracking is disabled via the
<code><a href="#topic+Options">Options</a></code> instance.
</p>
</li>
<li><p> Registers the <code><a href="#topic+Backend">backend</a></code> with the context.
</p>
</li>
<li><p> Instantiates and configures the progress bar based on the
<code><a href="#topic+Options">Options</a></code> instance in the session <code><a href="base.html#topic+options">base::.Options</a></code> list.
</p>
</li>
<li><p> Executes the task in parallel, and displays a progress bar if appropriate.
</p>
</li>
<li><p> Fetches the results from the backend and returns them.
</p>
</li></ul>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-UserApiConsumer-sapply"><code>UserApiConsumer$sapply()</code></a>
</p>
</li>
<li> <p><a href="#method-UserApiConsumer-lapply"><code>UserApiConsumer$lapply()</code></a>
</p>
</li>
<li> <p><a href="#method-UserApiConsumer-apply"><code>UserApiConsumer$apply()</code></a>
</p>
</li>
<li> <p><a href="#method-UserApiConsumer-clone"><code>UserApiConsumer$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-UserApiConsumer-sapply"></a>



<h4>Method <code>sapply()</code></h4>

<p>Execute a task in parallel akin to <code><a href="parallel.html#topic+clusterApply">parallel::parSapply()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>UserApiConsumer$sapply(backend, x, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>backend</code></dt><dd><p>An object of class <code><a href="#topic+Backend">Backend</a></code> as returned by
the <code><a href="#topic+start_backend">start_backend()</a></code> function. It can also be <code>NULL</code> to run
the task sequentially via <code><a href="base.html#topic+lapply">base::sapply()</a></code>.</p>
</dd>
<dt><code>x</code></dt><dd><p>An atomic vector or list to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>fun</code></dt><dd><p>A function to apply to each element of <code>x</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector of the same length as <code>x</code> containing the results of the
<code>fun</code>. The output format resembles that of <code><a href="base.html#topic+lapply">base::sapply()</a></code>.
</p>


<hr>
<a id="method-UserApiConsumer-lapply"></a>



<h4>Method <code>lapply()</code></h4>

<p>Execute a task in parallel akin to <code><a href="parallel.html#topic+clusterApply">parallel::parLapply()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>UserApiConsumer$lapply(backend, x, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>backend</code></dt><dd><p>An object of class <code><a href="#topic+Backend">Backend</a></code> as returned by
the <code><a href="#topic+start_backend">start_backend()</a></code> function. It can also be <code>NULL</code> to run
the task sequentially via <code><a href="base.html#topic+lapply">base::lapply()</a></code>.</p>
</dd>
<dt><code>x</code></dt><dd><p>An atomic vector or list to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>fun</code></dt><dd><p>A function to apply to each element of <code>x</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of the same length as <code>x</code> containing the results of the <code>fun</code>.
The output format resembles that of <code><a href="base.html#topic+lapply">base::lapply()</a></code>.
</p>


<hr>
<a id="method-UserApiConsumer-apply"></a>



<h4>Method <code>apply()</code></h4>

<p>Execute a task in parallel akin to <code><a href="parallel.html#topic+clusterApply">parallel::parApply()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>UserApiConsumer$apply(backend, x, margin, fun, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>backend</code></dt><dd><p>An object of class <code><a href="#topic+Backend">Backend</a></code> as returned by
the <code><a href="#topic+start_backend">start_backend()</a></code> function. It can also be <code>NULL</code> to run
the task sequentially via <code><a href="base.html#topic+apply">base::apply()</a></code>.</p>
</dd>
<dt><code>x</code></dt><dd><p>An array to pass to the <code>fun</code> function.</p>
</dd>
<dt><code>margin</code></dt><dd><p>A numeric vector indicating the dimensions of <code>x</code> the
<code>fun</code> function should be applied over. For example, for a matrix,
<code>margin = 1</code> indicates applying <code>fun</code> rows-wise, <code>margin = 2</code>
indicates applying <code>fun</code> columns-wise, and <code>margin = c(1, 2)</code>
indicates applying <code>fun</code> element-wise. Named dimensions are also
possible depending on <code>x</code>. See <code><a href="parallel.html#topic+clusterApply">parallel::parApply()</a></code> and
<code><a href="base.html#topic+apply">base::apply()</a></code> for more details.</p>
</dd>
<dt><code>fun</code></dt><dd><p>A function to apply to <code>x</code> according to the <code>margin</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments to pass to the <code>fun</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The dimensions of the output vary according to the <code>margin</code> argument.
Consult the documentation of <code><a href="base.html#topic+apply">base::apply()</a></code> for a detailed
explanation on how the output is structured.
</p>


<hr>
<a id="method-UserApiConsumer-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>UserApiConsumer$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+start_backend">start_backend()</a></code>, <code><a href="#topic+stop_backend">stop_backend()</a></code>,
<code><a href="#topic+configure_bar">configure_bar()</a></code>, <code><a href="#topic+par_sapply">par_sapply()</a></code>, and
<code><a href="#topic+par_lapply">par_lapply()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define a simple task.
task &lt;- function(x) {
    # Perform computations.
    Sys.sleep(0.01)

    # Return the result.
    return(x + 1)
}

# Start an asynchronous backend.
backend &lt;- start_backend(cores = 2, cluster_type = "psock", backend_type = "async")

# Change the progress bar options.
configure_bar(type = "modern", format = "[:bar] :percent")

# Create an user API consumer.
consumer &lt;- UserApiConsumer$new()

# Execute the task using the `sapply` parallel operation.
output_sapply &lt;- consumer$sapply(backend = backend, x = 1:200, fun = task)

# Print the head of the `sapply` operation output.
head(output_sapply)

# Execute the task using the `sapply` parallel operation.
output_lapply &lt;- consumer$lapply(backend = backend, x = 1:200, fun = task)

# Print the head of the `lapply` operation output.
head(output_lapply)

# Stop the backend.
stop_backend(backend)

</code></pre>

<hr>
<h2 id='Warning'>Package Warnings</h2><span id='topic+Warning'></span>

<h3>Description</h3>

<p>This class contains static methods for throwing warnings with informative
messages.
</p>


<h3>Format</h3>


<dl>
<dt><code>Warning$requested_cluster_cores_too_low()</code></dt><dd><p>Warning for not requesting enough cluster cores.</p>
</dd>
<dt><code>Warning$requested_cluster_cores_too_high()</code></dt><dd><p>Warning for requesting too many cluster cores.</p>
</dd>
<dt><code>Warning$requested_cluster_type_not_supported()</code></dt><dd><p>Warning for requesting an unsupported cluster type.</p>
</dd>
<dt><code>Warning$progress_not_supported_for_backend()</code></dt><dd><p>Warning for using a backend incompatible with progress tracking.</p>
</dd>
<dt><code>Warning$error_in_backend_finalizer()</code></dt><dd><p>Warning for errors in the backend finalizer during garbage collection.</p>
</dd>
</dl>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
