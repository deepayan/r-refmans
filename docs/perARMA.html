<!DOCTYPE html><html><head><title>Help for package perARMA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {perARMA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#perARMA-package'><p>Periodic Time Series Analysis and Modeling</p></a></li>
<li><a href='#ab2phth'>
<p>Fourier representation of real matrix</p></a></li>
<li><a href='#acfpacf'>
<p>Plotting usual ACF and PACF</p></a></li>
<li><a href='#arosa'>
<p>Monthly stratospheric ozone, Arosa</p></a></li>
<li><a href='#Bcoeff, Bcoeffa'>
<p>Fourier representation of covariance function</p></a></li>
<li><a href='#loglikec'>
<p>Calculation of the logarithm of likelihood function</p></a></li>
<li><a href='#loglikef'>
<p>Calculation of the logarithm of likelihood function (using Fourier representation)</p></a></li>
<li><a href='#makeparma'>
<p>Simulation of PARMA sequence</p></a></li>
<li><a href='#parma_ident'>
<p>Identification of PC-T structure</p></a></li>
<li><a href='#parmaf'>
<p>PARMA coefficients estimation</p></a></li>
<li><a href='#parmafil'>
<p>PARMA filtration</p></a></li>
<li><a href='#parmaresid'>
<p>Computing residuals of PARMA series</p></a></li>
<li><a href='#peracf'><p> Periodic ACF function</p></a></li>
<li><a href='#permest'><p> Periodic Mean Estimation</p></a></li>
<li><a href='#perpacf'>
<p>Periodic PACF function</p></a></li>
<li><a href='#persigest'><p>Periodic standard deviations</p></a></li>
<li><a href='#perYW'>
<p>Yule-Walker estimators of PAR model</p></a></li>
<li><a href='#pgram'>
<p>Plotting the periodogram of time series</p></a></li>
<li><a href='#predictperYW'>
<p>Prediction for PAR model</p></a></li>
<li><a href='#R_w_ma'>
<p>Covariance matrix for PARMA model (conditional)</p></a></li>
<li><a href='#scoh'>
<p>Plotting the squared coherence statistic of time series</p></a></li>
<li><a href='#volumes'>
<p>Volumes of energy, Nord Pool Spot Exchange</p></a></li>
<li><a href='#volumes.sep'>
<p>Volumes of energy, Nord Pool Spot Exchange, from 1st and 2nd September 2010.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Periodic Time Series Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Karolina Marek &lt;karolina.marek10@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Identification, model fitting and estimation for time series with periodic structure.
    Additionally, procedures for simulation of periodic processes
    and real data sets are included.
    Hurd, H. L., Miamee, A. G. (2007) &lt;<a href="https://doi.org/10.1002%2F9780470182833">doi:10.1002/9780470182833</a>&gt;
    Box, G. E. P., Jenkins, G. M., Reinsel, G. (1994)  &lt;<a href="https://doi.org/10.1111%2Fjtsa.12194">doi:10.1111/jtsa.12194</a>&gt;
    Brockwell, P. J., Davis, R. A. (1991, ISBN:978-1-4419-0319-8) 
    Bretz, F., Hothorn, T., Westfall, P. (2010, ISBN: 9780429139543) 
    Westfall, P. H., Young, S. S. (1993, ISBN:978-0-471-55761-6)
    Bloomfield, P., Hurd, H. L.,Lund, R. (1994) 
    &lt;<a href="https://doi.org/10.1111%2Fj.1467-9892.1994.tb00181.x">doi:10.1111/j.1467-9892.1994.tb00181.x</a>&gt;
    Dehay, D., Hurd, H. L. (1994, ISBN:0-7803-1023-3)
    Vecchia, A. (1985) &lt;<a href="https://doi.org/10.1080%2F00401706.1985.10488076">doi:10.1080/00401706.1985.10488076</a>&gt;
    Vecchia, A. (1985) &lt;<a href="https://doi.org/10.1111%2Fj.1752-1688.1985.tb00167.x">doi:10.1111/j.1752-1688.1985.tb00167.x</a>&gt;
    Jones, R., Brelsford, W. (1967) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2F54.3-4.403">doi:10.1093/biomet/54.3-4.403</a>&gt;
    Makagon, A. (1999)
    <a href="https://www.math.uni.wroc.pl/~pms/files/19.2/Article/19.2.5.pdf">https://www.math.uni.wroc.pl/~pms/files/19.2/Article/19.2.5.pdf</a>
    Sakai, H. (1989) &lt;<a href="https://doi.org/10.1111%2Fj.1467-9892.1991.tb00069.x">doi:10.1111/j.1467-9892.1991.tb00069.x</a>&gt;
    Gladyshev, E. G. (1961) 
    <a href="https://www.mathnet.ru/php/archive.phtml?wshow=paper&amp;amp;jrnid=dan&amp;amp;paperid=24851">https://www.mathnet.ru/php/archive.phtml?wshow=paper&amp;jrnid=dan&amp;paperid=24851</a>
    Ansley (1979) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2F66.1.59">doi:10.1093/biomet/66.1.59</a>&gt;
    Hurd, H. L., Gerr, N. L. (1991) &lt;<a href="https://doi.org/10.1111%2Fj.1467-9892.1991.tb00088.x">doi:10.1111/j.1467-9892.1991.tb00088.x</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2.0)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>corpcor, gnm, matlab, Matrix, signal, stats</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-16 21:43:34 UTC; karolina</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-17 08:20:02 UTC</td>
</tr>
<tr>
<td>Author:</td>
<td>Anna Dudek [aut],
  Harry Hurd [aut],
  Wioletta Wojtowicz [aut],
  Karolina Marek [cre]</td>
</tr>
</table>
<hr>
<h2 id='perARMA-package'>Periodic Time Series Analysis and Modeling</h2><span id='topic+perARMA-package'></span><span id='topic+perARMA'></span>

<h3>Description</h3>

<p>This package provides procedures for periodic
time series analysis. The package includes procedures for nonparametric
spectral analysis and parametric (PARMA) identification,
estimation/fitting and prediction. The package is
equipped with three examples of periodic time series: <code>volumes</code> and <code>volumes.sep</code>,
which record hourly volumes of traded energy, and <code>arosa</code> containing monthly ozone
levels.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> perARMA</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.6</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2016-02-25</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL(&gt;=2.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The main routines are: <br />
Nonparametric spectral analysis: <code>pgram</code>, <code>scoh</code> <br />
Preliminary identification and conditioning: <code>permest</code>, <code>persigest</code> <br />
Identification: <code>peracf</code>, <code>Bcoeff</code>, <code>perpacf</code>,  <code>acfpacf</code> <br />
Parameter estimation/fitting: <code>perYW</code>, <code>loglikec</code>, <code>parmaf</code>, <code>loglikef</code> <br />
Prediction: <code>predictperYW</code>, <code>predseries</code><br />
Simulation and testing: <code>makeparma</code>, <code>parma_ident</code><br />
<br />
For a complete list of procedures use <code>library(help="perARMA")</code>. <br />
</p>


<h3>Author(s)</h3>

<p>Anna Dudek, Harry Hurd and Wioletta Wojtowicz <br />
Maintainer: Karolina Marek &lt;karolina.marek10@gmail.com&gt;
</p>


<h3>References</h3>

<p>Hurd, H. L., Miamee, A. G., (2007), Periodically Correlated Random Sequences:
Spectral Theory and Practice, Wiley InterScience.
</p>


<h3>See Also</h3>

<p>Packages for Periodic Autoregression Analysis <code>link{pear}</code>,
Dynamic Systems Estimation <code>link{dse}</code> and
Bayesian and Likelihood Analysis of Dynamic Linear Models <code>link{dlm}</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Do not run
## It could take more than one minute
#demo(perARMA)
</code></pre>

<hr>
<h2 id='ab2phth'>
Fourier representation of real matrix 
</h2><span id='topic+ab2phth'></span><span id='topic+phth2ab'></span>

<h3>Description</h3>

<p>The function <code>ab2phth</code> transforms an input matrix 
<code>a</code> of size <code class="reqn">T \times p</code> containing the sine and cosine 
coefficients in the real Fourier series representation, 
to the <code class="reqn">T \times p</code> output matrix <code>phi</code> according to 
<code class="reqn"> \phi_{n,j} = a_{1,j} + \sum_{k=1}^{\left\lfloor T/2 \right\rfloor }(a_{2k,j} \cos(2\pi kn/T) + a_{2k+1,j} \sin(2\pi kn/T))</code>
for <code class="reqn"> n = 1, \ldots, T </code> and <code class="reqn"> j = 1, \ldots, p</code>.
The inverse transformation is implemented in <code>phth2ab</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ab2phth(a)
phth2ab(phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ab2phth_+3A_a">a</code></td>
<td>
<p>matrix of <code class="reqn">a_{n,j}</code> coefficients (size of <code class="reqn">T \times p</code>).</p>
</td></tr>
<tr><td><code id="ab2phth_+3A_phi">phi</code></td>
<td>
<p>matrix of <code class="reqn">\phi_{n,j}</code> coefficients (size of <code class="reqn">T \times p</code>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>martix <code>phi</code> or <code>a</code> for <code>ab2phth</code> or <code>phth2ab</code>, respectively.
</p>


<h3>Author(s)</h3>

<p>Harry Hurd
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makepar">makepar</a></code>, <code><a href="#topic+makeparma">makeparma</a></code>,  <code><a href="#topic+parma_ident">parma_ident</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> m=matrix(seq(0,11),3,4)
 ab&lt;-ab2phth(m)
 phi=ab$phi
 phth2ab(phi) 
</code></pre>

<hr>
<h2 id='acfpacf'>
Plotting usual ACF and PACF
</h2><span id='topic+acfpacf'></span><span id='topic+acfpacf.acf'></span><span id='topic+acfpacf.pacf'></span>

<h3>Description</h3>

<p>Plots values of usual ACF and PACF functions with confidence
intervals. Function <code>acfpacf</code> uses procedures <code>acfpacf.acf</code> and
<code>acfpacf.pacf</code>, which computes values of ACF and PACF function, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acfpacf(x, nac, npac, datastr,...)
acfpacf.acf(x, normflg)
acfpacf.pacf(x, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acfpacf_+3A_x">x</code></td>
<td>

<p>input time series, missing values are not permitted.
</p>
</td></tr>
<tr><td><code id="acfpacf_+3A_nac">nac</code></td>
<td>

<p>number of ACF values to return (typically much less than length of <code>x</code>).
</p>
</td></tr>
<tr><td><code id="acfpacf_+3A_npac">npac</code></td>
<td>

<p>number of PACF values to return (typically much less than length of <code>x</code>).
</p>
</td></tr>
<tr><td><code id="acfpacf_+3A_datastr">datastr</code></td>
<td>

<p>string name of data to be printed on the plot.
</p>
</td></tr>
<tr><td><code id="acfpacf_+3A_normflg">normflg</code></td>
<td>

<p>computing parameter for ACF values. These values are returned as a series <code>acf(k)</code> for <code>k = 0, ..., nr</code>, where <code>nr</code>
is length of <code>x</code>. Parameter <code>normflg</code> can be equal to: <br />
0 - <code>acf(k)</code> values will be normalized by <code>nr</code>,<br />
1 - <code>acf(k)</code> values will be normalized by <code>nr</code> multiplied by sample variance (to obtain correlations), <br />
2 - <code>acf(k)</code> values will be divided by <code>nr-k</code>, thus normalized by number of samples at each lag,<br />
3 - <code>acf(k)</code> values will be divided by <code>nr-k</code> multiplied by sample variance.<br />
In <code>acfpacf</code> procedure <code>normflg=3</code> is used.
</p>
</td></tr>
<tr><td><code id="acfpacf_+3A_m">m</code></td>
<td>

<p>maximum lag to compute PACF values. Value for the first lag (<code>pacf(1)</code>) is equal to <code>acf(2)</code>, which is the lag 1 acf
value, and then for computing values for <code>k = 2, ..., m</code> the Toeplitz structure
of the projection equations is used (see Brockwell, P. J., Davis, R. A., 1991, Time Series: Theory and Methods, example 4.4.2).
</p>
</td></tr>
<tr><td><code id="acfpacf_+3A_...">...</code></td>
<td>
<p>other arguments:<br />
<code>plfg</code>, <code>acalpha</code>, <code>pacacalpha</code>, <code>valcol</code>, <code>thrcol</code>, <code>thrmhcol</code>, where <br />
<code>plfg</code> is plotting flag, this parameter should be positive number to plot computed <code>acfpacf</code> values,<br />
<code>acalpha</code> and <code>pacalpha</code> are p-values (or <code>alpha</code> is I type error) thresholds for ACF and PACF plots based on independent normal values,<br />
<code>valcol,thrcol,thrmhcol</code> are colors of function values, confidence interval markers on the ACF/PACF and confidence interval markers on the ACF/PACF
for multiple hypothesis alpha correction on the plot.<br />
By default parameters are fixed to <code>plfg=1</code>, <code>acalpha=.05</code>, <code>pacacalpha=.05</code>, <code>valcol="red"</code>, <code>thrcol="green"</code>, <code>thrmhcol="blue"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>acfpacf</code> returns plot of ACF and PACF values with two types of
thresholds for input <code>acalpha</code> and <code>pacalpha</code>, respectively. The first one
denoted by <code>thr</code> is given for ACF values by <code class="reqn"> Pr[acf(j)&gt;thr] = \alpha/2</code> and <code class="reqn">Pr[acf(j)&lt;-thr] = \alpha/2</code>
where <code>acf(k)</code> is the ACF value at lag <code>k</code>. This threshold corresponds to type I
error for null hypothesis that <code>acf(k) = 0</code>. The plot allows to check if any of
the ACF values are significantly non-zero. Actual
threshold calculations are based on the following asymptotic result:
if <code class="reqn">X_t</code> is <code class="reqn">IID (0,\sigma^2)</code>, then for large <code class="reqn">n</code>, <code class="reqn">\hat{\rho}(k)</code> for
<code class="reqn">k &lt;&lt; n</code> are <code class="reqn">IID N(0,1/n)</code> (see Brockwell, P. J., Davis, R. A., 1991, Time Series: Theory and Methods, example 7.2.1, p. 222).
Thus, under the null hypothesis, the plots for <code>thr = qnorm(1-acalpha/2,0,1/sqrt(nr))</code>
should exhibit a proportion of roughly <code>acalpha</code> points that lie outside
the interval <code>[-thr, thr]</code>. Threshold for PACF is based on the same results. <br />
On the other hand we can also interpret the plots as a multiple hypothesis testing problem to compute second
threshold <code>thrm</code>. Suppose, we decided to plot some number of nonzero lags (equal to <code>nac</code>)
of the ACF function. If the estimated <code>acf</code> values estimates
are IID then we have <code>nac</code> independent tests of <code>acf(k) = 0</code>. The probability that at least one of values
lies outside the interval <code>[-thr, thr]</code> is equal to <code>1-Pr[all lie inside]</code>, which is <code>[1-(1-acalpha)]^nac</code>.
Finally, the last expression is approximately
equal to <code>nac*acalpha</code>. To get a threshold <code>thrmh</code> such that <code>1-Pr[all lie inside] = acalpha</code>  we
take the threshold as <br />
<code>thrmh = qnorm (1-(acalpha/2)/nac, 0, 1/sqrt(nr))</code> (for more details check the Bonferroni correction).<br />
For the PACF, the threshold <code>thrm</code> calculation is based on Theorem 8.1.2
of Time Series: Theory and Methods, p. 241, which states that the PACF values for an AR sequence are
asymptotically normal.
</p>


<h3>Value</h3>

<p>No return value, called for side effects</p>


<h3>Note</h3>

<p>Procedure <code>acfpacf</code> is an implementation of the usual (meaning not periodic) ACF and PACF functions.
It happens that for PC time series the usual ACF and PACF are still useful in the identification of model orders and in some cases can be more sensitive than
the perodic versions. The ACF and PACF values inform about the correlations of the random part. It is possible to run <code>acfpacf</code> on original data which include the peridic mean as a deterministic component. But typically the periodic mean can distort our understanding
(or view) of the random fluctuations, thus running <code>acfpacf</code> additionally on the data after removing periodic mean is suggested.
It is possible to use also <code>acfpacf.acf</code>, <code>acfpacf.pacf</code> procedures to obtain values of
ACF and PACF functions, respectively. When subjected to a truly PC sequence, the usual
ACF and PACF produce an average of the instantaneous (time indexed)
values produced by periodic ACF and periodic PACF. Depending therefore on correlations
between these averaged quantities, the usual ACF and PACF may be more or
less sensitive that the instantaneous ones.
</p>


<h3>Author(s)</h3>

<p>Harry Hurd
</p>


<h3>References</h3>

<p>Box, G. E. P., Jenkins, G. M., Reinsel, G. (1994), Time Series Analysis, 3rd Ed., Prentice-Hall,
Englewood Cliffs, NJ.
<br />
<br />
Brockwell, P. J., Davis, R. A. (1991), Time Series: Theory and Methods, 2nd Ed., Springer: New York.
<br />
<br />
Bretz, F., Hothorn, T., Westfall, P. (2010), Multiple Comparisons Using R, CRC Press.
<br />
<br />
Westfall, P. H., Young, S. S. (1993), Resampling-Based Multiple Testing: Examples and Methods
for p-Value Adjustment, Wiley Series in Probability and Statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+peracf">peracf</a></code>, <code><a href="#topic+perpacf">perpacf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(volumes)
# for original data
dev.set(which=1)
acfpacf(volumes,24,24,'volumes')

# for data after removing periodic mean
pmean_out&lt;-permest(t(volumes),24, 0.05, NaN,'volumes',pp=0)
xd=pmean_out$xd
dev.set(which=1)
acfpacf(xd,24,24,'volumes')
</code></pre>

<hr>
<h2 id='arosa'>
Monthly stratospheric ozone, Arosa
</h2><span id='topic+arosa'></span>

<h3>Description</h3>

<p>A fifty-year time series of monthly stratospheric ozone readings from Arosa, Switzerland. The dataset length is equal to 684, but some of the observations are missing (denoted by NaNs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(arosa)</code></pre>


<h3>Format</h3>

<p>The format is:
Time-Series [1:684] from 1 to 684: NaN NaN NaN NaN NaN NaN 312 300 281 267 ...
</p>


<h3>References</h3>

<p>Bloomfield, P., Hurd, H. L.,Lund, R., (1994), Periodic correlation
in stratospheric ozone data. Journal of Time Series Analysis 15, 127-150.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(arosa)
str(arosa) 
</code></pre>

<hr>
<h2 id='Bcoeff+2C+20Bcoeffa'>
Fourier representation of covariance function
</h2><span id='topic+Bcoeff'></span><span id='topic+Bcoeffa'></span>

<h3>Description</h3>

<p>The procedure <code>Bcoeff</code> computes the complex estimators
<code class="reqn"> B_{k}(\tau) = \frac{1}{T} \sum_{t=0}^{T-1}R(t+\tau,t)\exp(-i 2 \pi t /T)</code>
as Fourier coefficients in covariance function representation.
The procedure first computes the periodic mean
(with missing values ignored) and subtracts it from the series.
For each specified lag <code class="reqn">\tau</code>, the values of
<code class="reqn">\hat{B}_{k}(\tau)</code> are computed only for
<code class="reqn"> k= 0, 1, \ldots,\left\lfloor T/2 \right\rfloor</code>,
because for real series
<code class="reqn"> \hat{B}_{k}(\tau)= \overline{\hat{B}_{T-k}(\tau)}</code>.
Also the p-values for the test <code class="reqn"> B_{k}(\tau)=0</code> are returned. <br />
The function <code>Bcoeffa</code> calculates the estimator of the real
coefficients <code class="reqn"> a_{k}(\tau)</code> which satisfy
<code class="reqn"> R(t+\tau,t) = B(t,\tau) = a_1(\tau) + \sum (a_{2k}(\tau) \cos(2 \pi k t/ T)+a_{2k+1}(\tau) \sin(2 \pi k t/ T)) </code>,
for all required lags <code class="reqn"> \tau</code> and  <code class="reqn">k</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bcoeff(x, T_t, tau, missval, datastr,...)
Bcoeffa(x, T_t, tau, missval, datastr,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bcoeff+2B2C+2B20Bcoeffa_+3A_x">x</code></td>
<td>

<p>input time series.
</p>
</td></tr>
<tr><td><code id="Bcoeff+2B2C+2B20Bcoeffa_+3A_t_t">T_t</code></td>
<td>

<p>period length of PC-T structure.
</p>
</td></tr>
<tr><td><code id="Bcoeff+2B2C+2B20Bcoeffa_+3A_tau">tau</code></td>
<td>

<p>vector of lag values on which estimation of <code class="reqn">B_k(\tau)</code> is performed.
</p>
</td></tr>
<tr><td><code id="Bcoeff+2B2C+2B20Bcoeffa_+3A_missval">missval</code></td>
<td>

<p>notation for missing values.
</p>
</td></tr>
<tr><td><code id="Bcoeff+2B2C+2B20Bcoeffa_+3A_datastr">datastr</code></td>
<td>

<p>string name of data for printing.
</p>
</td></tr>
<tr><td><code id="Bcoeff+2B2C+2B20Bcoeffa_+3A_...">...</code></td>
<td>
<p>other arguments:<br />
<code>printflg</code> should be a positive parameter to print,<br />
<code>meth</code> is a parameter connected to the amount of frequencies used in estimation, if <code>meth=0</code> all possible frequencies are used in estimation else
if <code> meth &gt; 0</code> then <code class="reqn"> \left\lfloor n/2\right\rfloor</code> frequencies on either side of the Fourier frequencies <code class="reqn"> 2\pi k/T</code> are used.<br />
By default parameters are fixed to <code>printflg=1, meth=0</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This procedure can be applied to the original series to obtain estimators of <code class="reqn"> B_{k}(\tau)</code> in covariance function representation
or to the normalized series (series after  periodic mean removal and division by standard deviations) to obtain correlation coefficients.
The p-values for test of <code class="reqn">|B_k(\tau)|^2=0</code> are based on
the ratio of magnitude squares of amplitudes of a high
resolution Fourier decompositions. Magnitudes for the
frequency corresponding to index <code class="reqn">k</code> are compared to
the magnitudes of neighboring frequencies
(via the F distribution) (see Hurd, H. L., Miamee, A. G., 2007, Periodically Correlated Random Sequences, pp. 272-282, 288-292).
</p>


<h3>Value</h3>

<p>procedures (for positive <code>printflg</code> parameter) print a table containing the following columns:
</p>
<table>
<tr><td><code>k</code></td>
<td>
<p>index number of the coefficient <code class="reqn">B_k(\tau)</code>.</p>
</td></tr>
<tr><td><code>reB_k</code>, <code>imB_k/ahat_k</code></td>
<td>
<p>real and imaginary parts of estimated coefficient <code class="reqn">B_k(\tau)</code> (<code>Bcoeff</code> procedure) / real coefficients in representation of coefficient
<code class="reqn">B_k(\tau)</code> (<code>Bcoeffa</code> procedure).</p>
</td></tr>
<tr><td><code>n1</code></td>
<td>
<p>degrees of freedom associated to the estimator
<code class="reqn">SS1/n1</code> of the variance at frequency <code class="reqn">2\pi k /T</code>.</p>
</td></tr>
<tr><td><code>n2</code></td>
<td>
<p>degrees of freedom associated to the
&quot;background&quot; variance estimation <code class="reqn">SS2/n2</code> based on
frequencies in the neighborhood of the frequency <code class="reqn">2\pi k /T</code>.</p>
</td></tr>
<tr><td><code>Fratio</code></td>
<td>
<p> the statistic <code class="reqn">(SS1/n1)/(SS2/n2)</code>, which under
the null hypothesis has <code class="reqn">F(n1,n2)</code> distribution.</p>
</td></tr>
<tr><td><code>pv</code></td>
<td>
<p>p-values for test of <code class="reqn">\left|B_k(\tau)\right|^2=0</code>, based on F distribution.</p>
</td></tr>
</table>
<p>If <code>printflg</code> is set to be equal to 0, above values are returned just as matrices.
</p>


<h3>Author(s)</h3>

<p>Harry Hurd
</p>


<h3>References</h3>

<p>Dehay, D., Hurd, H. L., (1994), Representation and Estimation for Periodically and Almost Periodically
Correlated Random Processes in W. A. Gardner (ed.), Cyclostationarity in Communications and Signal Processing, IEEE Press.
<br />
<br />
Hurd, H. L., Miamee, A. G., (2007), Periodically Correlated Random Sequences:
Spectral Theory and Practice, Wiley InterScience.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(volumes)
Bcoeff(volumes,24,seq(0,12),NaN,'volumes')
Bcoeffa(volumes,24,seq(0,12),NaN,'volumes')
</code></pre>

<hr>
<h2 id='loglikec'>
Calculation of the logarithm of likelihood function
</h2><span id='topic+loglikec'></span>

<h3>Description</h3>

<p>Function <code>loglikec</code>, given <code>phi</code>, <code>del</code>, <code>theta</code>
encoded in  <code>ptvec</code>, evaluates the logarithm of likelihood function from the
PARMA series. Procedure returns also values of the AIC, FPE, BIC information criteria and MSE of residuals,
what enables to examine residuals and  evaluate godness of model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglikec(ptvec, x, conpars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglikec_+3A_ptvec">ptvec</code></td>
<td>

<p>vector of parameters for PARMA(p,q) model, containing matrix parameters
<code>phi</code> (of size <code class="reqn">T \times p</code>), <code>del</code> (of size <code class="reqn">T \times 1</code>),
<code>theta</code> (of size <code class="reqn">T \times q</code>) as following <br />
<code>ptvec = [phi[,1],...,phi[,p],del,theta[,1], ...,theta[,q]]</code>.
</p>
</td></tr>
<tr><td><code id="loglikec_+3A_x">x</code></td>
<td>

<p>input time series.
</p>
</td></tr>
<tr><td><code id="loglikec_+3A_conpars">conpars</code></td>
<td>
<p>vector of parameters <code>[T, p, q, stype]</code>,<br />
<code>T_t</code> period of PC-T structure,<br />
<code>p, q</code> maximum PAR and PMA order, respectively,<br />
<code>stype</code>  numeric parameter connected with covariance matrix computation, so far should be equal to 0 to use procedure
<code>R_w_ma</code> (see <code>R_w_ma</code> description). In the future also other values of <code>stype</code> will be available for
full covariance matrix computation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this procedure first series <code>x</code> is filtered by matrix coefficients <code>phi</code>, <code>del</code>, <code>theta</code>.
The code to compute logarithm of likelihood function must includes
the computation of covariance matrix from the parameters <code>phi</code>, <code>del</code>, <code>theta</code>.
Since the inverse of the computed covariance is needed for computing the likelihood,
and it is sometimes ill conditioned (or even singular),
the condition is improved by removing rows and columns corresponding to very small eigenvalues.
This corresponds to removing input data that is highly linearly dependent on the remaining
input data. The procedure contains a threshold ZTHRS (which current value is <code>10*eps</code>) that governs the discarding of rows and column corresponding to small eigenvalues (these are determined by a Cholesky decomposition). Any eigenvalue smaller than the threshold has its row and column deleted from the matrix. Then the
inverse and the likelihood are computed from the reduced rank covariance matrix.
</p>


<h3>Value</h3>

<p>list of values:
</p>
<table>
<tr><td><code>loglik</code></td>
<td>
<p>logarithm of likehood function (nagative value).</p>
</td></tr>
<tr><td><code>aicval</code></td>
<td>
<p>value of AIC criterion.</p>
</td></tr>
<tr><td><code>fpeval</code></td>
<td>
<p>value of FPE criterion.</p>
</td></tr>
<tr><td><code>bicval</code></td>
<td>
<p>value of BIC criterion.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the <code>loglikec</code> procedure, motivated by the possibility of deficient rank sequences, we made a variant of the Cholesky decomposition. In proposed approach upper traingular
matrix eliminates data points that are lineary dependant on previous ones and removes their consideration in the likelihood value calculation. As a consequence data vector
is reduced so that covariance matrix is positive definite and problem of non-invertible covariance matrix is avoided.
</p>


<h3>Author(s)</h3>

<p>Harry Hurd
</p>


<h3>References</h3>

<p>Box, G. E. P., Jenkins, G. M., Reinsel, G. (1994), Time Series Analysis, 3rd Ed., Prentice-Hall,
Englewood Cliffs, NJ.
<br />
<br />
Brockwell, P. J., Davis, R. A. (1991), Time Series: Theory and Methods, 2nd Ed., Springer: New York.
<br />
<br />
Vecchia, A., (1985), Maximum Likelihood Estimation for Periodic Autoregressive Moving Average Models, Technometrics, v. 27, pp.375-384.
<br />
<br />
Vecchia, A., (1985), Periodic autoregressive-moving average (PARMA) modeling with applications to water resources, Water Resources
Bulletin, v. 21, no. 5.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+R_w_ma">R_w_ma</a></code>,  <code><a href="#topic+parmafil">parmafil</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Do not run
## It could take a few seconds

data(volumes)
pmean&lt;-permest(t(volumes),24, 0.05, NaN,'volumes', pp=0)
xd=pmean$xd
estimators&lt;-perYW(volumes,24,2,NaN)
estvec=c(estimators$phi[,1],estimators$phi[,2],estimators$del)
loglikec(estvec,xd,c(24,2,0,0))

</code></pre>

<hr>
<h2 id='loglikef'>
Calculation of the logarithm of likelihood function (using Fourier representation)
</h2><span id='topic+loglikef'></span>

<h3>Description</h3>

<p>Procedure <code>loglikef</code> computes the logarithm of likelihood function from the PARMA
sequence <code>x</code> for matrices
<code>phi</code> (of size <code class="reqn">T \times p</code>) and <code>theta</code> (of size <code class="reqn">T \times (q+1)</code>)
inputed in their Fourier representation as <code>a</code> and <code>b</code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglikef(ab, x, conpars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglikef_+3A_ab">ab</code></td>
<td>

<p>matrix <code>[a,b]</code> taken as a vector, where<br />
<code>a</code> is Fourier representation of <code>phi</code>
(use <code>phi=ab2phth(a)</code> to recover <code>phi</code>),<br />
<code>b</code> is Fourier representation of <code>theta</code>
(use <code>del=ab2phth(b[,1])</code> to recover <code>del</code> and 
<code>theta=ab2phth(b[,2:q+1])</code> to recover <code>theta</code>).<br />
Vector <code>ab</code> contains only non-zero coefficients form <code>a</code> and <code>b</code>.
</p>
</td></tr>
<tr><td><code id="loglikef_+3A_x">x</code></td>
<td>

<p>input time series.
</p>
</td></tr>
<tr><td><code id="loglikef_+3A_conpars">conpars</code></td>
<td>

<p>vector of parameters <code>[T,p,q,naf,nbf,del_mask,iaf,ibf,stype]</code>:<br />
<code>T_t</code> period of PC-T structure,<br />
<code>p, q</code> maximum PAR and PMA order, respectively,<br />
<code>naf, nbf</code> total active coefficients in <code>a</code> and <code>b</code>, respectively,<br />
<code>del_mask</code> vector of length <code>T</code> (it will be used in the future, so far the user should set <code>del_mask=matrix(1,T,1)</code>),<br />
<code>iaf, ibf</code> linear indexes of active coefficients in <code>a</code> and <code>b</code>, respectively,<br />
<code>stype</code>  numeric parameter connected with covariance matrix computation, so far should be equal to 0 to use procedure 
<code>R_w_ma</code> (see <code>R_w_ma</code> description). In the future also other values of <code>stype</code> will be available for 
full covariance matrix computation. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method of computation of logarithm of likelihood function makes use of the representation of the periodically varying parameters by Fourier series. 
This alternative parametrization of PARMA system, introduced by 
Jones and Breslford, can sometimes substantially reduce the number of parameters required to represent PARMA system. Mapping between  <code>phi</code> and <code>theta</code> coefficients
and <code>a</code> and <code>b</code> coefficients is one-to-one, so first
logarithm of likelihood is computed for transformed coefficients and then these coefficients are transformed to <code>phi</code> and <code>theta</code>. 
Fourier series parametrization permits us 
to reduce the total number of parameters by constraining some frequencies to have zero amplitude. Then the code  includes
the computation of covariance matrix from the parameters <code>phi</code>, <code>del</code>, <code>theta</code>.
Since the inverse of the computed covariance is needed for computing the likelihood, and it is sometimes ill conditioned (or even singular), the condition is improved by removing rows and columns corresponding to very small eigenvalues. This corresponds to removing input data that is highly linearly dependent on the remaining input data. The procedure contains a threshold ZTHRS (which current value is <code>10*eps</code>) that governs the discarding of rows and column corresponding to small eigenvalues (these are determined by a Cholesky decomposition). Any eigenvalue smaller than the threshold has its row and column deleted from the matrix. Then the 
inverse and the likelihood are computed from the reduced rank covariance matrix.
</p>


<h3>Value</h3>

<p>negative value of the logarithm of likelihood function: <code>y</code>.
</p>


<h3>Note</h3>

<p>In the <code>loglikef</code> procedure, motivated by the possibility of deficient rank sequences, we made a variant of the Cholesky decomposition. In proposed approach upper traingular
matrix eliminates data points that are lineary dependant on previous ones and removes their consideration in the likelihood value calculation. As a consequence data vector
is reduced so that covariance matrix is positive definite and problem of non-invertible covariance matrix is avoided.<br />
This function is used in <code>parmaf</code> procedure, thus for more details please look also at <code>parmaf</code> code.
</p>


<h3>Author(s)</h3>

<p>Harry Hurd 
</p>


<h3>References</h3>

<p>Box, G. E. P., Jenkins, G. M., Reinsel, G. (1994), Time Series Analysis, 3rd Ed., Prentice-Hall, Englewood Cliffs, NJ.
<br />
<br />
Brockwell, P. J., Davis, R. A., (1991), Time Series: Theory and Methods, 2nd Ed., Springer: New York.
<br /> 
<br />
Jones, R., Brelsford, W., (1967), Time series with periodic structure, Biometrika 54, 403-408.
<br />
<br />
Makagon, A., (1999), Theoretical prediction of periodically correlated sequences, Probability and Mathematical Statistics 19 (2), 287-322.
<br />
<br />
Sakai, H., (1989), On the spectral density matrix of a periodic ARMA process, J. Time Series Analysis, v. 12, no. 2, pp. 73-82.
<br />
<br />
Vecchia, A., (1985), Maximum Likelihood Estimation for Periodic Autoregressive Moving Average Models, Technometrics, v. 27, pp.375-384.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+R_w_ma">R_w_ma</a></code>,  <code><a href="#topic+parmaresid">parmaresid</a></code>, <code><a href="#topic+parmaf">parmaf</a></code>
</p>

<hr>
<h2 id='makeparma'>
Simulation of PARMA sequence
</h2><span id='topic+makeparma'></span><span id='topic+makepar'></span>

<h3>Description</h3>

<p>Procedures <code>makeparma</code> and <code>makepar</code>  enable to construct PARMA and PAR type sequence of length <code>n</code> 
according to inputed matrices <code>phi</code>, <code>theta</code>, <code>del</code>. 
The optional parameter <code>nprep</code> defines the number of 
periods of simulated output <code>y</code> that will be discarded to let 
the start-up transients settle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeparma(n, phi, theta, del, nprep)
makepar(n, phi, del, nprep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeparma_+3A_n">n</code></td>
<td>

<p>length of simulated series.
</p>
</td></tr>
<tr><td><code id="makeparma_+3A_phi">phi</code></td>
<td>

<p>matrix of size <code class="reqn">T \times p</code> containing periodic AR parameters.
</p>
</td></tr>
<tr><td><code id="makeparma_+3A_theta">theta</code></td>
<td>

<p>matrix of size <code class="reqn">T \times q</code> containing periodic MA parameters.
</p>
</td></tr>
<tr><td><code id="makeparma_+3A_del">del</code></td>
<td>

<p>vector of length <code class="reqn">T</code> containing the periodic sigmas (shock weights), which are
sometimes denoted also as <code class="reqn">\sigma(t)</code> or as <code class="reqn"> \theta_{0}(t)</code>.
</p>
</td></tr>
<tr><td><code id="makeparma_+3A_nprep">nprep</code></td>
<td>

<p>number of periods of simulated output; for <code>p&gt;0</code> the computation of new 
<code>y</code> values depends on old ones through the autoregressive part. Starting 
a PARMA with the assumption that old values of <code>y</code> are equal to zero causes
a transient in the output. This transient dies out as time goes on. So to avoid this transient problem, 
we compute <code>nprep</code> periods of simulated output to allow the transient to die out.<br />
This parameter is optional, because by default  <code>nprep=50</code> (for <code>makeparma</code> procedure) or <code>nprep=10</code>
(for <code>makepar</code> procedure). Later we will provide a function to compute an
appropriate value of <code>nprep</code> that 
depends on the PARMA parameters.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A vector <code class="reqn"> \xi(t)</code> of independent <code class="reqn">N(0,1)</code> variates is generated by 
the standard 
random number generator <code>rnorm</code>. This vector series is filtered 
by <code>parmafil</code>, which parameters are set by <code>phi</code>, <code>theta</code>
and <code>del</code>, 
to generate the filtered series (pre-iterates and the <code>n</code> desired data). 
The last <code>n</code> data of the filtered series are output in the vector <code>y</code>.
</p>


<h3>Value</h3>

<p>PARMA or PAR sequence returned as <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>Harry Hurd 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parmafil">parmafil</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################### simulation of PARMA(2,1)
T=12
nlen=480
p=2
 a=matrix(0,T,p)
q=1
 b=matrix(0,T,q)

a[1,1]=.8                 
a[2,1]=.3                                     
phia&lt;-ab2phth(a) 
phi0=phia$phi         
phi0=as.matrix(phi0)       
      
b[1,1]=-.7	          
b[2,1]=-.6                  
thetab&lt;-ab2phth(b)         
theta0=thetab$phi  
theta0=as.matrix(theta0) 

del0=matrix(1,T,1)       

PARMA21&lt;-makeparma(nlen,phi0,theta0,del0)
parma&lt;-PARMA21$y
plot(ts(parma))

##################### simulation of PAR(2)
T=24
nlen=1000
p=2
a=matrix(0,T,p)
a[1,1]=.5
a[2,2]=.4

phia&lt;-ab2phth(a)
phi0=phia$phi
phi0=as.matrix(phi0)

del0=matrix(1,T,1)

PAR1&lt;-makepar(nlen,phi0,del0)
par&lt;-PAR1$y
plot(ts(par))
</code></pre>

<hr>
<h2 id='parma_ident'>
Identification of PC-T structure
</h2><span id='topic+parma_ident'></span>

<h3>Description</h3>

<p>Procedure <code>parma_ident</code> utilizes a collection of procedures 
(functions) that together provide
identification of PC structure in the series and saves results in the  <code>'ident.txt'</code> file, which is
located in the working directory.
This procedure could be applied to the original time series <code>x</code>  or to the residuals of fitted PARMA models
to characterize the goodness of fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parma_ident(x, T_t, missval, datastr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parma_ident_+3A_x">x</code></td>
<td>

<p>input time series.
</p>
</td></tr>
<tr><td><code id="parma_ident_+3A_t_t">T_t</code></td>
<td>

<p>period of PC-T structure.
</p>
</td></tr>
<tr><td><code id="parma_ident_+3A_missval">missval</code></td>
<td>

<p>notation for missing values.
</p>
</td></tr>
<tr><td><code id="parma_ident_+3A_datastr">datastr</code></td>
<td>

<p>string name of data for printing.
</p>
</td></tr>
<tr><td><code id="parma_ident_+3A_...">...</code></td>
<td>
<p>other arguments: <br />
<code>outdir</code> is string name of the directory in which file <code>'ident.txt'</code> 
with results returned by <code>parma_ident</code> procedure will be saved,<br />
<code>details</code> should be equal to 1 to print all details.<br />
By default these parameters are fixed to
<code>outdir='IDENT_OUT'</code>, <code>details=1</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Procedure <code>parma_ident</code> provides a universal method for analyzing series
or residuals. It calls following procedures:
<code>permest</code>, <code>persigest</code>, <code>peracf</code>, <code>Bcoeff</code>, <code>Bcoeffa</code>, <code>perpacf</code>, 
<code>ppfcoeffab</code>, <code>ppfplot</code>, <code>acfpacf</code>. 
</p>


<h3>Value</h3>

<p>procedure returns list of values:
</p>
<table>
<tr><td><code>pmean</code></td>
<td>
<p>periodic mean values,</p>
</td></tr>
<tr><td><code>xd</code></td>
<td>
<p>series after removing periodic mean,</p>
</td></tr>
<tr><td><code>pstd</code></td>
<td>
<p>periodic standard deviations values,</p>
</td></tr>
<tr><td><code>xn</code></td>
<td>
<p>series obtained after removing periodic mean and divided by periodic standard deviations,</p>
</td></tr>
</table>
<p>as well as a text file <code>'ident.txt'</code> containing all the textual output generated 
in the running of <code>parma_ident</code>. 
</p>


<h3>Author(s)</h3>

<p>Harry Hurd 
</p>


<h3>References</h3>

<p>Hurd, H. L., Miamee, A. G., (2007), Periodically Correlated Random Sequences: Spectral Theory and Practice, Wiley InterScience.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
############### PC-T series simulation
T=12
nlen=480
descriptor='PARMA(2,1) periodic phis all del =1'
p=2
 a=matrix(0,T,p)
q=1
 b=matrix(0,T,q)
a[1,1]=.8                 
a[2,1]=.3                                                                
a[1,2]=-.9  
             
phia&lt;-ab2phth(a) 
phi0=phia$phi            
phi0=as.matrix(phi0)       
      
b[1,1]=-.7	          
b[2,1]=-.6                  
thetab&lt;-ab2phth(b)       
theta0=thetab$phi  
theta0=as.matrix(theta0) 
del0=matrix(1,T,1)        

makeparma_out&lt;-makeparma(nlen,phi0,theta0,del0)                        
y=makeparma_out$y

############### parma_ident use

parma_ident(t(y),T,NaN,descriptor,outdir=tempdir())
</code></pre>

<hr>
<h2 id='parmaf'>
PARMA coefficients estimation
</h2><span id='topic+parmaf'></span>

<h3>Description</h3>

<p>Procedure <code>parmaf</code> enables the estimation of parameters of the chosen representation of PARMA(p,q) model. For general PARMA we use non-linear 
optimization methods to obtain minimum of negative logarithm of likelihood function using <code>loglikef</code> procedure. Intitial values of parameters are computed using Yule-Walker equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parmaf(x, T_t, p, q, af, bf, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parmaf_+3A_x">x</code></td>
<td>

<p>input time series.
</p>
</td></tr>
<tr><td><code id="parmaf_+3A_t_t">T_t</code></td>
<td>

<p>period length of PC-T structure.
</p>
</td></tr>
<tr><td><code id="parmaf_+3A_p">p</code></td>
<td>

<p>maximum PAR order, which is a number of columns in <code>af</code>.
</p>
</td></tr>
<tr><td><code id="parmaf_+3A_q">q</code></td>
<td>

<p>maximum PMA order, which is a number of columns in <code>bf</code> diminished by 1.
</p>
</td></tr>
<tr><td><code id="parmaf_+3A_af">af</code></td>
<td>

<p><code class="reqn">T \times p</code> logical values matrix pointing to active frequency 
components for <code>phi</code>.
</p>
</td></tr>
<tr><td><code id="parmaf_+3A_bf">bf</code></td>
<td>

<p><code class="reqn">T \times (q+1)</code> logical matrix pointing to active frequency 
components for <code>theta</code>.
</p>
</td></tr>
<tr><td><code id="parmaf_+3A_...">...</code></td>
<td>

<p>Other arguments:<br />
<code>a0</code> starting value for <code>a</code>, where <code>a</code> is Fourier representation of
<code>phi</code> (use <code>phi=ab2phth(a)</code> to recover <code>phi</code>);
if <code>a0</code> is not defined Yule Walker method is used to estimate it;<br />
<code>b0</code> starting values for <code>b</code>, where <code>b</code> is Fourier representation of
<code>theta</code> (use <code>del=ab2phth(b[,1])</code> 
to recover <code>del</code> and use <code>theta = ab2phth(b[,2:q+1])</code> to recover 
<code>theta</code>);
if <code>b0</code> is not defined Yule Walker method is used to estimate it;<br />
<code>stype</code>  numeric parameter connected with covariance matrix computation, so far should be equal to 0 to use procedure 
<code>R_w_ma</code> (see <code>R_w_ma</code> description). In the future also other values of <code>stype</code> will be available for 
full covariance matrix computation. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to obtain maximum likelihood estimates of model parameters <code>a</code> and <code>b</code>
we use a numerical optimization method to minimalize value of <code>y</code> (as negative value of logarithm of loglikelihood function returned by <code>loglikef</code>) 
over parameter values. Internally, parameters <code>a</code> and <code>b</code> are
converted to <code>phi</code>  and <code>theta</code> as needed via function 
<code>ab2phth</code>. For the present we use <code>optim</code> function with defined <code>method="BFGS"</code> (see code for more details). 
</p>


<h3>Value</h3>

<p>list of values:
</p>
<table>
<tr><td><code>a</code></td>
<td>
<p>is matrix of Fourier coefficients determining <code>phi</code>.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>is matrix of Fourier corfficients determining <code>theta</code>.</p>
</td></tr>
<tr><td><code>negloglik</code></td>
<td>
<p>minimum value of negative logarithm of likehood function.</p>
</td></tr>
<tr><td><code>aicval</code></td>
<td>
<p>value of AIC criterion.</p>
</td></tr>
<tr><td><code>fpeval</code></td>
<td>
<p>value of FPE criterion.</p>
</td></tr>
<tr><td><code>bicval</code></td>
<td>
<p>value of BIC criterion.</p>
</td></tr>
<tr><td><code>resids</code></td>
<td>
<p>series of residuals.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Harry Hurd 
</p>


<h3>References</h3>

<p>Box, G. E. P., Jenkins, G. M., Reinsel, G. (1994), Time Series Analysis, 3rd Ed., Prentice-Hall, Englewood Cliffs, NJ.
<br />
<br />
Brockwell, P. J., Davis, R. A., (1991), Time Series: Theory and Methods, 2nd Ed., Springer: New York.
<br /> 
<br />
Jones, R., Brelsford, W., (1967), Time series with periodic structure, Biometrika 54, 403-408.
<br />
<br />
Vecchia, A., (1985), Maximum Likelihood Estimation for Periodic Autoregressive Moving Average Models, Technometrics, v. 27, pp.375-384.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loglikef">loglikef</a></code>, <code><a href="#topic+perYW">perYW</a></code>,  <code><a href="#topic+R_w_ma">R_w_ma</a></code>,   
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
######## simulation of periodic series
T=12
nlen=480
p=2
 a=matrix(0,T,p)
q=1
 b=matrix(0,T,q)
a[1,1]=.8                 
a[2,1]=.3                
                                                 
a[1,2]=-.9               
phia&lt;-ab2phth(a) 
phi0=phia$phi            
phi0=as.matrix(phi0)       
      
b[1,1]=-.7	          
b[2,1]=-.6                  
thetab&lt;-ab2phth(b)       
theta0=thetab$phi  
theta0=as.matrix(theta0) 
del0=matrix(1,T,1)        
makeparma_out&lt;-makeparma(nlen,phi0,theta0,del0)                      
y=makeparma_out$y

## Do not run 
## It could take more than one minute


############ fitting of PARMA(0,1) model
p=0
q=1
af=matrix(0,T,p)
bf=matrix(0,T,q+1)
bf[1,1]=1
bf[1:3,2]=1

parmaf(y,T,p,q,af,bf)

########### fitting of PARMA(2,0) model
p=2
q=0
af=matrix(0,T,p)
bf=matrix(0,T,q+1)
af[1:3,1]=1       
af[1:3,2]=1
bf[1,1]=1
parmaf(y,T,p,q,af,bf)
############ fitting of PARMA(2,1) model
p=2
q=1
af=matrix(0,T,p)
bf=matrix(0,T,q+1)
af[1:3,1]=1       
af[1:3,2]=1
bf[1,1]=1
bf[1:3,2]=1
parmaf(y,T,p,q,af,bf)

</code></pre>

<hr>
<h2 id='parmafil'>
PARMA filtration
</h2><span id='topic+parmafil'></span>

<h3>Description</h3>

<p>Procedure <code>parmafil</code> filters the vector <code>x</code> according to matrices <code>a, b</code> containing PARMA model parameters. 
The function returns series <code>y</code> such that 
<code class="reqn">a(n,1)*y(n) = b(n,1)*x(n) + b(n,2)*x(n-1) + \ldots + b(n,nb+1)*x(n-nb)- a(n,2)*y(n-1) - \ldots - a(n,na+1)*y(n-na)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parmafil(b, a, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parmafil_+3A_b">b</code></td>
<td>
<p>matrix of size <code class="reqn">T \times (nb+1)</code>, which elements satisfy <code class="reqn">b(n,j)=b(n+T,j)</code>, usually in the literature <code>b</code> is called the periodic MA parameters and <code class="reqn">nb</code>
is denoted by <code class="reqn">q</code>.
</p>
</td></tr>
<tr><td><code id="parmafil_+3A_a">a</code></td>
<td>
<p>matrix of size <code class="reqn">T \times na</code>, which elements satisfy <code class="reqn">a(n,j)=a(n+T,j)</code>,  usually in the literature <code>a</code> is called the periodic AR parameters
and <code class="reqn">na</code> is denoted <code class="reqn">p</code>. If <code class="reqn">a(n,1)</code> is not equal to 1 for all <code class="reqn">n</code>, the values of <code class="reqn">a(n,j)</code> are normalized by <code class="reqn">a(n,j)=a(n,j)/a(n,1)</code>.
</p>
</td></tr>
<tr><td><code id="parmafil_+3A_x">x</code></td>
<td>

<p>input time series.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Filtered signal <code>y</code>.
</p>


<h3>Note</h3>

<p>To filter using the convention <code class="reqn">\phi(t,B)x(t) = \theta(t,B) \xi(t)</code>
with <code class="reqn">\phi(t,B)=1 - \phi(t,1)B - ... - \phi(t,p)B^p</code>, 
<code class="reqn">\theta(t,B)=del(t,1) + \theta(t,1)B + ... + \theta(t,q)B^q</code>
set <code>a=[ones(T,1),-phi]</code>, <code>b=[theta]</code>, then <code>x=parmafil(b,a,xi)</code>.
</p>


<h3>Author(s)</h3>

<p>Harry Hurd 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loglikec">loglikec</a></code>, <code><a href="#topic+loglikef">loglikef</a></code>, <code><a href="#topic+makeparma">makeparma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b=matrix(c(1,1,0,0,.5,.5),2,3)
a=matrix(c(1,1,.5,.5),2,2)
s=sample(1:100,50, replace=TRUE)
x=matrix(s,50,1)

parmafil_out&lt;-parmafil(a,b,x)
y=parmafil_out$y
plot(y,type="l")
</code></pre>

<hr>
<h2 id='parmaresid'>
Computing residuals of PARMA series
</h2><span id='topic+parmaresid'></span>

<h3>Description</h3>

<p>Procedure <code>parmaresid</code>, given <code>phi</code> (of size <code class="reqn">T \times p</code>), <code>del</code> 
(of size <code class="reqn">T \times 1</code>), 
<code>theta</code> (of size <code class="reqn">T \times q</code>), computes the residuals of PARMA series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parmaresid(x, stype, del, phi,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parmaresid_+3A_x">x</code></td>
<td>

<p>input time series.
</p>
</td></tr>
<tr><td><code id="parmaresid_+3A_stype">stype</code></td>
<td>
<p> numeric parameter connected with covariance matrix computation, so far should be equal to 0 to use procedure 
<code>R_w_ma</code> (see <code>R_w_ma</code> description). In the future also other values of <code>stype</code> will be available for 
full covariance matrix computation.
</p>
</td></tr>
<tr><td><code id="parmaresid_+3A_del">del</code></td>
<td>

<p>vector of coefficients of length <code class="reqn">T</code>.
</p>
</td></tr>
<tr><td><code id="parmaresid_+3A_phi">phi</code></td>
<td>

<p>matrix of coefficients of  size <code class="reqn">T \times p</code>.
</p>
</td></tr>
<tr><td><code id="parmaresid_+3A_...">...</code></td>
<td>

<p>matrix of coefficients <code>theta</code> of size <code class="reqn">T \times q</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program uses <code>parmafil</code> to filter the series and computes the  covariance matrix. 
This code does the Cholesky factorization and 
determines the residuals from the inverse of <code>L</code> (see the code: 
<code>e=Linv*w0_r1</code>). This allows the treatment of a deficient rank 
covariance and a reduction of rank. 
Procedure <code>parmaresid</code> is used in <code>parmaf</code> function.
</p>


<h3>Value</h3>

<p>Series of residuals <code>resids</code>.
</p>


<h3>Author(s)</h3>

<p>Harry Hurd 
</p>


<h3>References</h3>

<p>Box, G. E. P., Jenkins, G. M., Reinsel, G. (1994), Time Series Analysis, 3rd Ed., Prentice-Hall,
Englewood Cliffs, NJ.
<br />
<br />
Brockwell, P. J., Davis, R. A. (1991), Time Series: Theory and Methods, 2nd Ed., Springer: New York.
<br />
<br />
Vecchia, A., (1985), Maximum Likelihood Estimation for Periodic Autoregressive Moving Average Models, Technometrics, v. 27, pp.375-384.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+R_w_ma">R_w_ma</a></code>,  <code><a href="#topic+loglikec">loglikec</a></code>, <code><a href="#topic+loglikef">loglikef</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Do not run 
## It could take a few seconds

data(volumes)
pmean&lt;-permest(t(volumes),24, 0.05, NaN,'volumes', pp=0)
xd=pmean$xd
estimators&lt;-perYW(volumes,24,2,NaN)

parmaresid(xd, 0, estimators$del, estimators$phi)

</code></pre>

<hr>
<h2 id='peracf'> Periodic ACF function
</h2><span id='topic+peracf'></span>

<h3>Description</h3>

<p>Function <code>peracf</code>, given an input time series and a specified period <code>T</code>, computes the periodic correlation coefficients for which
<code class="reqn"> \rho(t+\tau,t)=\rho(t,\tau)</code>, where <code class="reqn">t = 1,\ldots, T</code>
are seasons and <code class="reqn">\tau</code> is lag. For each
possible pair of <code class="reqn"> t</code> and <code class="reqn">\tau </code> confidence limits for
<code class="reqn">\rho(t,\tau)</code> are also computed using Fisher
transformation. Procedure <code>peracf</code>
provides also two important tests: <code class="reqn"> \rho(t+\tau,t) \equiv \rho(\tau)</code> and <code class="reqn">\rho(t+\tau,t) \equiv 0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peracf(x, T_t, tau, missval, datastr,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peracf_+3A_x">x</code></td>
<td>

<p>input time series, at the begining missing values
in <code>x</code> will be treat as zeros and periodic mean will be computed,
then missing values will be replaced by periodic mean.
</p>
</td></tr>
<tr><td><code id="peracf_+3A_t_t">T_t</code></td>
<td>

<p>period of PC-T structure.
</p>
</td></tr>
<tr><td><code id="peracf_+3A_tau">tau</code></td>
<td>

<p>vector of lag values for which estimation is made.
</p>
</td></tr>
<tr><td><code id="peracf_+3A_missval">missval</code></td>
<td>

<p>notation for missing values (denoted as NaN).
</p>
</td></tr>
<tr><td><code id="peracf_+3A_datastr">datastr</code></td>
<td>

<p>string name of data for printing.
</p>
</td></tr>
<tr><td><code id="peracf_+3A_...">...</code></td>
<td>
<p>other arguments, that are connected with the plots:<br />
<code>prttaus, plottaus, cialpha, typeci, typerho, pchci, pchrho, colci, colrho</code>, where<br />
<code>prttaus</code> is a set of lags for which correlation coefficients are printed; it is a subset of <code>tau</code>, <br />
<code>plottaus</code> is a set of lags for plotting the correlation coefficients
(one plot per lag); it is a subset of <code>tau</code>,<br />
<code>cialpha</code> threshold for confidence interval, <br />
<code>typeci</code>/ <code>typerho</code>, <code>pchci</code>/ <code>pchrho</code>, <code>colci</code>/<code>colrho</code>
define the type, plot character and colors of confidence intervals/periodic correlation values.<br />
By default these parameters are fixed to <code>prttaus = seq(1,T/2)</code>, <code>plottaus = seq(1,T/2)</code>, <code>cialpha = 0.05</code>, <code>typeci = "b"</code>, <code>typerho = "b"</code>, <code>pchci = 10</code>, <code>pchrho = 15</code>, <code>colci = "blue"</code>, <code>colrho = "red"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>peracf</code> uses three separate procedures:<br />
<code>rhoci()</code> returns the upper and lower bands defining a <code class="reqn">1 - \alpha</code> confidence interval for the true values of
<code class="reqn"> \rho(t, \tau)</code>,<br />
<code>rho.zero.test()</code>  tests whether the estimated correlation coefficients are equal to zeros, <code class="reqn"> \rho(t+\tau,t) \equiv 0</code>.<br />
<code>rho.equal.test()</code>  tests whether the estimated correlation coefficients are equal to each other for all seasons in the period,
<code class="reqn"> \rho(t+\tau,t) \equiv \rho(\tau)</code>.<br />
</p>
<p>In the test <code class="reqn"> \rho(t+\tau,t) \equiv \rho(\tau)</code>, rejection for some <code class="reqn">\tau
&gt; 0</code> indicates
that series is properly PC and is not just an amplitude modulated stationary
sequence. In other words, there exists a nonzero
lag <code class="reqn">\tau</code> for which <code class="reqn"> \rho(t+\tau,t)</code> is
properly periodic in <code class="reqn">t</code>.<br />
In the test <code class="reqn">\rho(t+\tau,t) \equiv 0</code>, the
rejection for some <code class="reqn"> \tau \neq 0</code> indicates the sequence is not PC white noise.
</p>


<h3>Value</h3>

<p>tables of values for each specified lag <code class="reqn">\tau</code>:
</p>
<table>
<tr><td><code>rho(t</code>, <code>tau)</code></td>
<td>
<p>estimated correlation coefficients.</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower bands of confidence intervals.</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper bands of confidence intervals.</p>
</td></tr>
<tr><td><code>nsamp</code></td>
<td>
<p>number of samples used in each estimation.</p>
</td></tr>
</table>
<p>Above values are also returned as matrices.
</p>


<h3>Author(s)</h3>

<p>Harry Hurd
</p>


<h3>References</h3>

<p>Hurd, H. L., Miamee, A. G., (2007), Periodically Correlated Random Sequences: Spectral Theory and Practice, Wiley InterScience.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Bcoeff">Bcoeff</a></code>, <code><a href="#topic+perpacf">perpacf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(volumes)
dev.set(which=1)
peracf(t(volumes),24,seq(1,12),NaN,'volumes')
</code></pre>

<hr>
<h2 id='permest'> Periodic Mean Estimation</h2><span id='topic+permest'></span>

<h3>Description</h3>

<p>Assuming that the period <code>T</code> is known, procedure <code>permest</code> plots and returns the estimated periodic
mean as a function of season. Missing data are permitted.
The confidence intervals for these values, based on the t-distribution, are also computed
and plotted. The de-meaned <code>x</code> is also returned with missing values
replaced by periodic mean values.
If at time <code>t</code> there is a missing value,
it is replaced with the periodic mean at <code>(t mod T)</code>, provided the periodic mean exists (meaning there is at least one non-missing data for the
season <code>(t mod T)</code>). Otherwise the periodic mean at <code>(t mod T)</code> will be set to <code>"Missing"</code> and in the output vectors
<code>xr</code> and <code>xd</code> all the values whose times are congruent with <code>(t mod T)</code> will be set to <code>"Missing"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permest(x, T_t, alpha, missval, datastr,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permest_+3A_x">x</code></td>
<td>

<p>input time series.
</p>
</td></tr>
<tr><td><code id="permest_+3A_t_t">T_t</code></td>
<td>

<p>period of the computed mean.
</p>
</td></tr>
<tr><td><code id="permest_+3A_alpha">alpha</code></td>
<td>

<p><code>1-alpha</code> is confidence interval containment probability using the t-distribution.
</p>
</td></tr>
<tr><td><code id="permest_+3A_missval">missval</code></td>
<td>

<p>notation for missing values.
</p>
</td></tr>
<tr><td><code id="permest_+3A_datastr">datastr</code></td>
<td>

<p>string name of data for printing.
</p>
</td></tr>
<tr><td><code id="permest_+3A_...">...</code></td>
<td>
<p>other arguments used in the plot: <code>typeci</code>, <code>typepmean</code>, <code>pchci</code>, <code>pchpmean</code>, <code>colci</code>, <code>colpmean</code>, <code>pp</code>;<br />
<code>typeci</code> / <code>typepmean</code>, <code>pchci</code> / <code>pchpmean</code>, <code>colci</code> / <code>colpmean</code> set the type, plot character and colors of confidence
intervals / periodic mean values on the plot, <br />
<code>pp</code> should be positive to print and plot <code>permest</code> values.<br />
By default these parameters are fixed to <code>typeci = "o"</code>, <code>typepmean = "b"</code>, <code>pchci = 10</code>, <code>pchpmean = 15</code>, <code>colci = "red"</code>, <code>colpmean = "blue"</code>, <code>pp = 1</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The series may contain missing values (we suggest using <code>NaN</code>)
and the length of the series need not be
an integer multiple of the period. The program returns
and plots the periodic mean with <code>1-alpha</code> confidence
intervals based on all non-missing values present for each
particular season. The p-value for a one-way
ANOVA test for equality of seasonal means is also computed.
</p>


<h3>Value</h3>

<p>procedure returns:
</p>
<table>
<tr><td><code>pmean</code></td>
<td>
<p>periodic mean values.</p>
</td></tr>
<tr><td><code>lower</code>, <code>upper</code></td>
<td>
<p>bounds of the confidence intervals.</p>
</td></tr>
<tr><td><code>xr</code></td>
<td>
<p>series with missing values replaced by periodic mean values.</p>
</td></tr>
<tr><td><code>xd</code></td>
<td>
<p>series after removing periodic mean.</p>
</td></tr>
<tr><td><code>pmpv</code></td>
<td>
<p>p-value for a one-way ANOVA test for equality of means.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Harry Hurd
</p>


<h3>References</h3>

<p>Hurd, H. L., Miamee, A. G., (2007), Periodically Correlated Random Sequences:
Spectral Theory and Practice, Wiley InterScience.
<br />
<br />
Westfall, P. H., Young, S. S. (1993), Resampling-Based Multiple Testing: Examples and Methods
for p-Value Adjustment, Wiley Series in Probability and Statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+persigest">persigest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(arosa)
dev.set(which=1)
permest(t(arosa),12, 0.05, NaN,'arosa')
</code></pre>

<hr>
<h2 id='perpacf'>
Periodic PACF function
</h2><span id='topic+perpacf'></span><span id='topic+ppfcoeffab'></span><span id='topic+ppfplot'></span>

<h3>Description</h3>

<p>The function <code>perpacf</code>, given an input time series, a specified period <code>T</code> and a lag <code>p</code>, computes
the periodic sample correlation coefficients <code class="reqn">\pi(t,n)</code> and returns their values as a matrix <code>ppa</code>  of size <code class="reqn"> T \times (p+1)</code>.<br />
</p>
<p>The <code>ppfcoeffab</code> procedure transforms the output of <code>perpacf</code> into Fourier form, i.e. into Fourier coeficients,
so we can represent <code class="reqn">\pi(t,n)</code> by its Fourier coefficients.<br />
</p>
<p>Function <code>ppfplot</code> plots perpacf coefficients returned by <code>perpacf</code> as function of <code>n</code> for each specified lag <code class="reqn">t=1, 2,\ldots, T</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perpacf(x, T_t, p, missval)
ppfcoeffab(ppf, nsamp, printflg, datastr)
ppfplot(ppf, nsamp, alpha, datastr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perpacf_+3A_x">x</code></td>
<td>

<p>input time series.
</p>
</td></tr>
<tr><td><code id="perpacf_+3A_t_t">T_t</code></td>
<td>

<p>period of PC-T structure.
</p>
</td></tr>
<tr><td><code id="perpacf_+3A_p">p</code></td>
<td>

<p>maximum lag used in computation.
</p>
</td></tr>
<tr><td><code id="perpacf_+3A_missval">missval</code></td>
<td>

<p>notation for missing values.
</p>
</td></tr>
<tr><td><code id="perpacf_+3A_ppf">ppf</code></td>
<td>

<p>matrix of periodic PACF values (of size <code class="reqn">T \times (p+1)</code>) returned by <code>perpacf</code> function.
</p>
</td></tr>
<tr><td><code id="perpacf_+3A_nsamp">nsamp</code></td>
<td>

<p>number of samples (periods) used to compute <code>ppf</code>.
</p>
</td></tr>
<tr><td><code id="perpacf_+3A_printflg">printflg</code></td>
<td>

<p>parameter should be positive to return messages.
</p>
</td></tr>
<tr><td><code id="perpacf_+3A_alpha">alpha</code></td>
<td>

<p>parameter for thresolds are displayed along with the Bonferroni corrected thresholds.
</p>
</td></tr>
<tr><td><code id="perpacf_+3A_datastr">datastr</code></td>
<td>

<p>string name of data for printing.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Procedure <code>perpacf</code> returns <code>ppa</code> matrix, where for
each separation <code>n=0,1,...,p</code>, <code>ppa[,n]</code> is the value
of <code class="reqn">\hat{\pi}(t,n)</code> for <code>t=1,2,...,T</code>. Further, since <code>T</code> is assumed to be the period of the underlying PC process,
<code class="reqn">\pi(t,n)</code> is periodic in <code>t</code> with period <code>T</code>. So we can represent <code class="reqn">\pi(t,n)</code> by its Fourier coefficients.
Further, if the variation in time of <code class="reqn">\pi(t,n)</code> is really smooth over the period, then looking at
these Fourier coefficients (the output of <code>ppfcoeffab</code>) may be a more sensitive detector of linear dependence
of  <code class="reqn">x_{t+1}</code> on the preceding <code>n</code> samples
(think of <code>n</code> as fixed here) than looking at <code class="reqn">\pi(t,n)</code> for individual times.
The <code>ppfcoeffab</code> procedure  also needs the sample size <code>nsamp</code> used by <code>perpacf</code> in computing the <code class="reqn">\pi(t,n)</code>
in order to compute p-values for the <code>pkab</code> coefficients. The
p-values are computed assuming that for each <code>t</code>, <code class="reqn">\pi(t,n)</code> is <code>N(0,1/sqrt(nsamp))</code> under the null.
The procedure <code>ppfcoeffab</code> is called in  <code>parma_ident</code>.
<br />
Function <code>ppfplot</code> plots values of <code class="reqn">\pi(t,n+1)</code> and computes p-values for testing
if <code class="reqn"> \pi(n_0+1,t)=0</code> for all <code> t = 1, ..., T</code> and fix <code class="reqn">n_0</code> (p-values in column labelled <code class="reqn">n_0=n</code>) and
if <code class="reqn"> \pi(n+1,t)=0</code> for all <code> t = 1, ..., T</code> and <code class="reqn"> n_0 \leq n \leq nmax</code> (p-values in column labelled <code class="reqn"> n_0 \leq n \leq nmax</code>).
perpacf is plotted as function of n for each specified lag <code class="reqn">t=1, 2,\ldots, T</code>.
</p>


<h3>Value</h3>

<p>The function <code>perpacf</code> returns two matrixes:
</p>
<table>
<tr><td><code>ppa</code></td>
<td>
<p>matrix of size <code class="reqn"> T \times (p+1)</code> with perpacf coefficients.</p>
</td></tr>
<tr><td><code>nsamp</code></td>
<td>
<p>matrix of size <code class="reqn"> T \times (p+1)</code> with numbers of samples used in estimation of sample correlation.</p>
</td></tr>
</table>
<p>The function <code>ppfcoeffab</code> returns table of values:
</p>
<table>
<tr><td><code>pihat_k</code></td>
<td>
<p>Fourier coefficients <code>pkab</code> of <code>ppf</code> values.</p>
</td></tr>
<tr><td><code>pv</code></td>
<td>
<p>Bonferroni corrected p-values.</p>
</td></tr>
</table>
<p>The function <code>ppfplot</code> returns plot of <code class="reqn">\pi(t,n+1)</code> coefficients and table of p-vaules for provided
tests. Note that there are two plots; the first plot presents values of <code class="reqn">\pi(t,n+1)</code> for all considered <code class="reqn">t</code> and <code class="reqn">n</code>, whereas
the second plot presents separate charts for particular <code class="reqn">t</code> values.
</p>


<h3>Author(s)</h3>

<p>Harry Hurd
</p>


<h3>References</h3>

<p>Hurd, H. L., Miamee, A. G., (2007), Periodically Correlated Random Sequences: Spectral Theory and Practice, Wiley InterScience.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+peracf">peracf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(volumes)
 perpacf_out&lt;-perpacf(t(volumes),24,12,NaN)
 ppa=perpacf_out$ppa
 nsamp=perpacf_out$nsamp
 ppfcoeffab(ppa,nsamp,1,'volumes')
 ppfplot(ppa,41,.05,'volumes')
</code></pre>

<hr>
<h2 id='persigest'>Periodic standard deviations
</h2><span id='topic+persigest'></span>

<h3>Description</h3>

<p>Assuming that the period <code>T</code> is known, procedure <code>persigest</code> plots and returns the estimated periodic
standard deviation as a function of season. Missing data are permitted. The
confidence intervals for these values, based on the chi-square distribution, are also
computed and plotted. The de-meaned and normalized series
<code>xn</code> is returned. <br />
First, the periodic mean is computed using the method of <code>permest</code>. If at time <code>t</code> there is a missing value in the data, it is ignored
in the computation of periodic standard deviation. For any season <code>(t mod T)</code> where all the data are missing, the periodic standard
deviation is set to <code>"Missing"</code> and in the output vector <code>xn</code> all the values whose times are congruent with <code>(t mod T)</code> will be set to <code>"Missing"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>persigest(x, T_t, alpha, missval, datastr,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="persigest_+3A_x">x</code></td>
<td>

<p>input time series.
</p>
</td></tr>
<tr><td><code id="persigest_+3A_t_t">T_t</code></td>
<td>

<p>period of the computed standard deviation.
</p>
</td></tr>
<tr><td><code id="persigest_+3A_alpha">alpha</code></td>
<td>

<p><code>1-alpha</code> is confidence interval containment probability
using the chi-square distribution.
</p>
</td></tr>
<tr><td><code id="persigest_+3A_missval">missval</code></td>
<td>

<p>notation for missing values.
</p>
</td></tr>
<tr><td><code id="persigest_+3A_datastr">datastr</code></td>
<td>

<p>string name of data for printing.
</p>
</td></tr>
<tr><td><code id="persigest_+3A_...">...</code></td>
<td>
<p>other arguments used in the plot: <code>typeci</code>, <code>typepstd</code>, <code>pchci</code>, <code>pchpstd</code>, <code>colci</code>, <code>colpstd</code>, <code>pp</code>;<br />
<code>typeci</code> / <code>typepstd</code>, <code>pchci</code> / <code>pchpstd</code>, <code>colci</code> / <code>colpstd</code> set the type, plot character and colors of confidence
intervals / periodic mean values on the plot, <br />
<code>pp</code> should be positive to print and plot <code>permest</code> values.<br />
By default parameters are fixed to <code>typeci = "o"</code>, <code>typepstd = "b"</code>, <code>pchci = 10</code>, <code>pchpstd = 15</code>, <code>colci = "red"</code>, <code>colpstd = "blue"</code>, <code>pp = 1</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The series may contain missing values (we suggest using <code>NaN</code>)
and the length of the series may not be
an integer multiple of the period. The program returns and plots the
periodic standard deviations with <code>1-alpha</code> confidence
intervals based on all non-missing values present for each particular
season.
The p-value for Barttlet's test for homogenity of variance <code class="reqn"> \sigma(t)
 \equiv \sigma</code> is also computed.
Rejection of homogeneity
(based on the <code>pspv</code> value) indicates a properly periodic variance,
but leaves open whether or
not series is simply the result of a stationary process subjected
to amplitude-scale modulation. To
resolve this<code class="reqn"> R (t + \tau, t) </code> for  some <code class="reqn"> \tau \neq 0 </code>
need to be estimated.
</p>


<h3>Value</h3>

<p>procedure returns:
</p>
<table>
<tr><td><code>pstd</code></td>
<td>
<p>periodic standard deviations values.</p>
</td></tr>
<tr><td><code>lower</code>, <code>upper</code></td>
<td>
<p>bounds of the confidence intervals.</p>
</td></tr>
<tr><td><code>xn</code></td>
<td>
<p>series after removing periodic mean and divided by standard deviations</p>
</td></tr>
<tr><td><code>pspv</code></td>
<td>
<p>p-value for Bartlett's test for the homogeneity of variance.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Harry Hurd
</p>


<h3>References</h3>

<p>Hurd, H. L., Miamee, A. G., (2007), Periodically Correlated Random Sequences:
Spectral Theory and Practice, Wiley InterScience.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+permest">permest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(arosa)
dev.set(which=1)
persigest(t(arosa),12, 0.05, NaN,'arosa')
</code></pre>

<hr>
<h2 id='perYW'>
Yule-Walker estimators of PAR model
</h2><span id='topic+perYW'></span>

<h3>Description</h3>

<p>Assuming known <code>T</code>, procedure <code>perYW</code> implements Yule-Walker 
estimation method for a periodic autoregressive PAR(p) model. 
Order of autoregression <code>p</code>, which could be specified using sample 
periodic PACF, is constant
for all seasons. For input time series <code>x</code>, matrix of parameters 
<code>phi</code> and vector of parameters
<code>del</code> are computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perYW(x, T_t, p, missval)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perYW_+3A_x">x</code></td>
<td>

<p>input time series.
</p>
</td></tr>
<tr><td><code id="perYW_+3A_t_t">T_t</code></td>
<td>

<p>period of PC-T structure (assumed constant over time).
</p>
</td></tr>
<tr><td><code id="perYW_+3A_p">p</code></td>
<td>

<p>order of the autoregression.
</p>
</td></tr>
<tr><td><code id="perYW_+3A_missval">missval</code></td>
<td>

<p>notation for missing values.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For fixed <code>T</code>, this procedure implements a periodic version of the
Yule-Walker algorithm. 
The algorithm is based on solving for the best coefficients of
LS prediction of <code class="reqn">X(t)</code> in terms of <code class="reqn">X(t-1),...,X(t-p+1)</code>. 
Sample autocorrelations are used in place 
of population autocorrelations in the expressions of the best coefficients.
</p>


<h3>Value</h3>

<p>estimated parameters of PAR(p) model:
</p>
<table>
<tr><td><code>phi</code></td>
<td>
<p>matrix of coefficients for autoregressive part.</p>
</td></tr>
<tr><td><code>del</code></td>
<td>
<p>vector of noise weights (consider them variances of the shocks).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Harry Hurd 
</p>


<h3>References</h3>

<p>Brockwell, P. J., Davis, R. A. (1991), Time Series: Theory and Methods, 2nd Ed., Springer: New York.
<br />
<br />
Vecchia, A., (1985), Maximum Likelihood Estimation for Periodic Autoregressive Moving Average Models, Technometrics, v. 27, pp.375-384.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predictperYW">predictperYW</a></code>, <code><a href="#topic+loglikef">loglikef</a></code>, <code><a href="#topic+parmaf">parmaf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(volumes)
perYW(volumes,24,2,NaN)
</code></pre>

<hr>
<h2 id='pgram'>
Plotting the periodogram of time series
</h2><span id='topic+pgram'></span>

<h3>Description</h3>

<p>The periodogram is a classical tool 
based on the sample Fourier transform 
for finding periodic components in a time series. 
The procedure <code>pgram</code> computes and plots an average 
of <code class="reqn">np</code> periodograms where <code>np=floor(length(x)/fftlen)</code> where the 
input parameter <code>fftlen</code> is the length of the FFT; to get just 
1 FFT of length <code>fftlen</code>, use <code>x(1:fftlen)</code> in place of <code>x</code>. To get a 
significance of high periodogram peaks, the procedure tests, 
at each frequency, the value of the averaged periodogram against 
the average of <code>2*halflen</code> neighboring cells (<code>halflen</code> on each side), 
and averaged over the <code class="reqn">np</code> periodograms; the neighboring cell average 
is called the background. Significance of the ratio of center 
frequency average to the background average is computed from the 
F distribution. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgram(x, fftlen,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgram_+3A_x">x</code></td>
<td>
<p>input time series, missing values denoted by NaNs will be
replaced in <code>pgram</code> by zeros.
</p>
</td></tr>
<tr><td><code id="pgram_+3A_fftlen">fftlen</code></td>
<td>
<p>length of FFT which will be used. In <code>pgram</code> we can specify the desired length of the FFT, then <code>x</code> is divided into pieces of 
this length. FFT is done on each of these pieces and the resulting magnitude squares values are added,
so average of the periodograms for each frequency is obtained. 
</p>
</td></tr>
<tr><td><code id="pgram_+3A_...">...</code></td>
<td>
<p>other arguments that are connected with periodogram plot: <code>np1</code>, <code>np2</code>, <code>halflen</code>, <code>alpha</code>, <code>rejalpha</code>, <code>logsw</code>, 
<code>datastr</code>, <code>typeci</code>, <code>typepgram</code>, <code>colci</code>, <code>colpgram</code>, where <br />
<code>np1</code> and <code>np2</code> are frequency indexes of the first and the last frequency in the periodogram plot; it is required that
<code class="reqn">np1 &gt; halflen</code> and usually <code class="reqn">np2=\left \lfloor length(x)/2 \right \rfloor</code>, because periodogram is symmetric;<br />
<code>halflen</code> is a value on each side of the center for background estimation, <br />
<code>alpha</code> is significance level for testing for periodic components, <br />
<code>rejalpha</code> is significance level for rejecting outliers in the background estimation, <br />
<code>logsw</code> if is equal to 1 plot of the periodogram is in <code class="reqn">\log</code> scale, else linear, <br /> 
<code>datastr</code> string name of data for printing, <br />
Parameters <code>typeci</code> / <code>typepgram</code>, <code>colci</code> / <code>colpgram</code> define the type and colors of confidence intervals / periodogram values on the plot.<br />
By default they are fixed to <code>np1 = 5</code>, <code>np2 = fftlen/2</code>, <code>halflen = 4</code>, <code>alpha = .05</code>, <code>rejalpha = .01</code>, <code>logsw = 1</code>, 
<code>datastr = 'data'</code>, <code>typeci = "b"</code>, <code>typepgram = "b"</code>, <code>colci = "red"</code>, <code>colpgram = "blue"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When we assume that period <code>T_t</code> of PC-T structure is unknown, 
function <code>pgram</code> enables us to find
candidate for the period length assuming the period of 
the second order structure is the same as the period of 
the first order structure (IE, in the series itself).
</p>


<h3>Value</h3>

<p>For any FFT index <code class="reqn">j</code> (say where a strong peak occurs)
<code class="reqn">j</code> corresponds to the number of cycles in the FFT window, 
so the period can be easily computed as <code>T_t = fftlen/j</code>.
</p>


<h3>Author(s)</h3>

<p>Harry Hurd 
</p>


<h3>References</h3>

<p>Box, G. E. P., Jenkins, G. M., Reinsel, G. (1994), Time Series Analysis, 3rd Ed., Prentice-Hall,
Englewood Cliffs, NJ.
<br />
<br />
Hurd, H. L., Miamee, A. G., (2007), Periodically Correlated Random Sequences: 
Spectral Theory and Practice, Wiley InterScience.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scoh">scoh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(volumes)
dev.set(which=1)
pgram(t(volumes),length(volumes),datastr='volumes')
</code></pre>

<hr>
<h2 id='predictperYW'>
Prediction for PAR model
</h2><span id='topic+predictperYW'></span><span id='topic+predseries'></span>

<h3>Description</h3>

<p>Procedure <code>predictperYW</code> provideds the LMS  forecast
of a PAR(p) series. The Yule-Walker method is first use to 
estimate the LMS prediction coefficients using all the 
observed data in <code>x</code>.<br />
Additionally, procedure <code>predseries</code>
plots the predicted values of the series with real future
values of the series (provided that such real data is 
available).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictperYW(x, T_t, p, missval, start,...)
predseries(real, x, T_t, p, start,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictperYW_+3A_x">x</code></td>
<td>

<p>input time series.
</p>
</td></tr>
<tr><td><code id="predictperYW_+3A_t_t">T_t</code></td>
<td>

<p>period of PC-T structure.
</p>
</td></tr>
<tr><td><code id="predictperYW_+3A_p">p</code></td>
<td>

<p>order of autoregression, it is assumed constant over time.
</p>
</td></tr>
<tr><td><code id="predictperYW_+3A_missval">missval</code></td>
<td>

<p>notation for missing values.
</p>
</td></tr>
<tr><td><code id="predictperYW_+3A_start">start</code></td>
<td>

<p>index of forecast value of the series; there are two possible scenarios:<br />
<code>start&lt;length(x)</code> - procedure <code>predictperYW</code> enables to predict values of some piece of existing series (using Yule-Walker coefficients). 
In this case it is also 
necessary to define <code>end</code> value, as we want to predict values <code>x[start:end]</code> and compare them with known observations.<br />
<code>start&gt;length(x)</code> - procedure <code>predictperYW</code> enables to predict future values of the series. In this scenario forecast of length <code>start-length(x)</code> 
is performed to 
find values <code>xp[length(x)+1:start]</code>.
In this case one can use also <code>predseries</code> procedure to compare predicted future of the series with real data (if such  data is 
available, see examples section).
</p>
</td></tr>
<tr><td><code id="predictperYW_+3A_real">real</code></td>
<td>

<p>the real future values of <code>x</code> series (historical data).
</p>
</td></tr>
<tr><td><code id="predictperYW_+3A_...">...</code></td>
<td>
<p>other arguments that will be connected with plot: <code>realcol</code> is a color of konwn values and <code>predcol</code>
is a color of predicted values on the plot.
By default parameters are fixed to <code>realcol="blue"</code>, <code>predcol="red"</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>procedure <code>predictperYW</code> for <code>start&lt;length(x)</code> plots values of <code>x[start:end]</code> and <code>xp[start:end]</code>, where <code>xp</code> are predicted values; for 
<code>start&gt;length(x)</code> function returns and plots two series:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>input series together with predicted values added.</p>
</td></tr>
<tr><td><code>new</code></td>
<td>
<p>predicted part of the series only.</p>
</td></tr>
</table>
<p>Procedure <code>predseries</code> plots predicted and real values of the series on the same plot.
</p>


<h3>Author(s)</h3>

<p>Wioletta Wojtowicz
</p>


<h3>References</h3>

<p>Box, G. E. P., Jenkins, G. M., Reinsel, G. (1994), Time Series Analysis, 3rd Ed., Prentice-Hall,
Englewood Cliffs, NJ.
<br />
<br />
Brockwell, P. J., Davis, R. A. (1991), Time Series: Theory and Methods, 2nd Ed., Springer: New York.
<br />
<br />
Gladyshev, E. G., (1961), Periodically Correlated Random Sequences, Sov. Math., 2, 385-388.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(volumes)
permest_out&lt;-permest(t(volumes),24, 0.05, NaN,'volumes', pp=0)
xd=permest_out$xd
dev.set(which=1)
predictperYW(xd,24,2,NaN,956,end=980)

dev.set(which=1)
predictperYW(xd[1:980],24,2,NaN,1004)

data(volumes.sep)
dev.set(which=1)
realdata=c(volumes,volumes.sep)
predseries(realdata,t(volumes[1:980]),24,2,1004)
</code></pre>

<hr>
<h2 id='R_w_ma'>
Covariance matrix for PARMA model (conditional)
</h2><span id='topic+R_w_ma'></span>

<h3>Description</h3>

<p>Procedure <code>R_w_ma</code> computes the covariance matrix of the moving average 
part of a PARMA sequence. 
This is used in maximum likelihood estimation in conjunction with 
the Ansley transformation method of computing the likelihood 
of the sample conditioned on the firt <code>m = max(p; q)</code>
samples being ignored (or set to null); see Ansley or Brockwell and Davis for 
background on the procedure. The method avoids the cumbersome calculation of
full covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R_w_ma(theta, nstart, nlen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R_w_ma_+3A_theta">theta</code></td>
<td>

<p>matrix of size <code class="reqn"> T \times (q+1)</code> contains vectorial 
parameters <code class="reqn"> [\theta_0,\theta_1,...,\theta_q]</code>, where
<code class="reqn">\theta(0,t)=\sigma(t)=del(t)</code>, thus
<code>theta = [del,theta_1,...,theta_q]</code>.
</p>
</td></tr>
<tr><td><code id="R_w_ma_+3A_nstart">nstart</code></td>
<td>

<p>starting time, for conditional likelihood in PARMA  set to <code>p+1</code>.
</p>
</td></tr>
<tr><td><code id="R_w_ma_+3A_nlen">nlen</code></td>
<td>

<p>size of the covariance matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Procedure <code>R_w_ma</code>  implements calculation of covariance matrix of size <code>nlen-p</code> from the parameters <code>theta</code> and <code>phi</code> of PARMA sequence.
The result is returned  as two vectors, first containing non-zero 
elements of covariance matrix and the second containing indexes of this parameters.
Using these vectors covariance matrix can be easily reconstructed.
</p>


<h3>Value</h3>

<p>procedure returns covariance matrix in sparse format as following: 
</p>
<table>
<tr><td><code>R</code></td>
<td>
<p>vector of non-zero elements of covariance matrix.</p>
</td></tr>
<tr><td><code>rindex</code></td>
<td>
<p>vector of indexes of non-zero elements.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Harry Hurd 
</p>


<h3>References</h3>

<p>Ansley, (1979), An algorithm for the exact likelihood of a mixed autregressive moving average process, Biometrika, v.66, pp.59-65.
<br />
<br />
Brockwell, P. J., Davis, R. A. (1991), Time Series: Theory and Methods, 2nd Ed., Springer: New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loglikec">loglikec</a></code>,  <code><a href="#topic+loglikef">loglikef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T=12
nlen=480
p=2
 a=matrix(0,T,p)
q=1
 b=matrix(0,T,q)
a[1,1]=.8                  
a[2,1]=.3                 
                          
phia&lt;-ab2phth(a) 
phi0=phia$phi          
phi0=as.matrix(phi0)        
      
b[1,1]=-.7	          
b[2,1]=-.6                  
thetab&lt;-ab2phth(b)         
theta0=thetab$phi  
theta0=as.matrix(theta0) 
del0=matrix(1,T,1)    


R_w_ma(cbind(del0,theta0),p+1,T)    

</code></pre>

<hr>
<h2 id='scoh'>
Plotting the squared coherence statistic of time series
</h2><span id='topic+scoh'></span>

<h3>Description</h3>

<p>The magnitude of squared coherence is computed in a specified square set of <code class="reqn">( \lambda_p, \lambda_q) \in [0, 2\pi) </code>
and using a specified smoothing window. The perception of this empirical spectral coherence is aided
by plotting the coherence values only at points where thereshold is exceeded. For identification/discovery of 
PC structure, the sample periodic mean should be first subtracted from the series because a periodic mean itself has 
PC structure that can dominate and confound the perception of the second order PC structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoh(x, m, win,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scoh_+3A_x">x</code></td>
<td>

<p>input time series.
</p>
</td></tr>
<tr><td><code id="scoh_+3A_m">m</code></td>
<td>

<p>length of the smoothing window.
</p>
</td></tr>
<tr><td><code id="scoh_+3A_win">win</code></td>
<td>

<p>vector of smoothing weights, they should be non-negative.
</p>
</td></tr>
<tr><td><code id="scoh_+3A_...">...</code></td>
<td>
<p>other arguments that will be connected with squared coherence statistic plot: <code>pfa</code>, <code>plflg</code>, <code>bfflg</code>, <code>ix</code>, <code>iy</code>, <code>nx</code>, <code>ny</code>, <code>datastr</code>,
where <br />
<code>plflg</code> should be positive to plot values of statistic,<br />
<code>pfa</code>  should be positive to plot threshold,<br />
<code>bfflg</code> is a Bonferroni correction parameter; it sholud be positive to correct <code>pfa</code> before thresholding,<br />
<code>ix</code> and <code>iy</code> are initial values at x and y axes (the lower left corner of plot),<br />
<code>nx, ny</code> are the incremental frequency indices above the starting point <code>(ix,iy)</code> (the ending values of frequency index are <code>ix+nx,iy+ny</code>),<br />
<code>datastr</code> string name of data for printing.<br />  
By default they are fixed to <code>pfa = 1</code>, <code>plflg = 1</code>, <code>bfflg = 1</code>, <code>ix = 0</code>, <code>iy = 0</code>, <code>nx = length(x)/2</code>, <code>ny = length(x)/2</code>, <code>datastr = "data")</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To ensure that periodic structure seen in the spectral coherence image is not a consequence 
of an additive periodic mean, it is recommended that the <code>permest</code> function is first used to remove the periodic mean.
</p>


<h3>Value</h3>

<p>The program returns plot of squared coherence statistic values, that
exceed threshold.
</p>


<h3>Author(s)</h3>

<p>Harry Hurd 
</p>


<h3>References</h3>

<p>Hurd, H. L., Gerr, N. L., (1991), Graphical Methods for Determining
the Presence of Periodic Correlation in Time Series, J.
Time Series Anal.,  (12),   pp. 337-350(1991).
<br />
<br />
Hurd, H. L., Miamee, A. G., (2007), Periodically Correlated Random Sequences: 
Spectral Theory and Practice, Wiley InterScience.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pgram">pgram</a></code>, <code><a href="#topic+permest">permest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Do not run 
## It could take a few seconds

data(volumes)
m=16
win=matrix(1/m,1,m)
dev.set(which=1)
scoh(t(volumes),m,win,datastr='volumes')
</code></pre>

<hr>
<h2 id='volumes'>
Volumes of energy, Nord Pool Spot Exchange
</h2><span id='topic+volumes'></span>

<h3>Description</h3>

<p>One-dimensional discrete time series, which contains 984 real-valued 
observations of volumes of energy traded on the Nord Pool Spot Exchange from
July 6th to August 31st 2010. Analysed series contains the hourly records only from weekdays from the considered period. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(volumes)</code></pre>


<h3>Format</h3>

<p>The format is:
Time-Series [1:984] from 1 to 984: 24888 24316 23755 23354 23290 ...
</p>


<h3>Source</h3>

<p>Data were found on <a href="http://www.npspot.com">http://www.npspot.com</a> ( Downloads -&gt; Historical market data )
selecting <code>Elspot volumes</code> and <code>hourly</code> resolution to download file <code>Elspot\_volumes\_2010\_hourly.xls.</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(volumes)
message(volumes)
</code></pre>

<hr>
<h2 id='volumes.sep'>
Volumes of energy, Nord Pool Spot Exchange, from 1st and 2nd September 2010.
</h2><span id='topic+volumes.sep'></span>

<h3>Description</h3>

<p>One-dimenssional discrete time series, which conatins 48 real-valued 
observations of volumes of energy traded on the Nord Pool Spot Exchange.
These are omitted before the last two days of 
<code>volumes</code> data and are used to compare the predicted values 
of the series <code>volumes</code> with real values in <code>volumes.sep</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(volumes.sep)</code></pre>


<h3>Format</h3>

<p>The format is:
Time-Series [1:48] from 1 to 48: 25281 24576 24306 24266 24515 ...
</p>


<h3>Source</h3>

<p>Data were found on <a href="http://www.npspot.com">http://www.npspot.com</a> ( Downloads -&gt; Historical market data )
selecting <code>Elspot volumes</code> and <code>hourly</code> resolution to download file <code>Elspot\_volumes\_2010\_hourly.xls.</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(volumes.sep)
message(volumes.sep)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
