<!DOCTYPE html><html lang="en"><head><title>Help for package ElliptCopulas</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ElliptCopulas}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compute_etahat'><p>Compute <code class="reqn">\hat{\eta}_k</code></p></a></li>
<li><a href='#compute_matrix_alpha'><p>Compute the matrix of coefficients alpha</p></a></li>
<li><a href='#conv_funct'><p>Conversion Functions for Elliptical Distributions</p></a></li>
<li><a href='#DensityGenerator.normalize'><p>Normalization of an elliptical copula generator</p></a></li>
<li><a href='#derivative.psi'><p>Computing <code class="reqn">\psi</code>, its inverse <code class="reqn">\Psi</code> and the <code class="reqn">k</code>-th derivative of <code class="reqn">\Psi</code></p></a></li>
<li><a href='#derivative.rho'><p>Computing <code class="reqn">\rho</code> and its <code class="reqn">k</code>-th derivative</p></a></li>
<li><a href='#derivative.tau'><p>Computing <code class="reqn">\tau</code> and its <code class="reqn">k</code>-th derivative</p></a></li>
<li><a href='#EllCopEst'><p>Estimate the density generator of a (meta-)elliptical copula</p></a></li>
<li><a href='#EllCopLikelihood'><p>Computation of the likelihood of an elliptical copula</p></a></li>
<li><a href='#EllCopSim'><p>Simulation from an elliptical copula model</p></a></li>
<li><a href='#EllDistrDerivEst'><p>Estimate the derivatives of a generator</p></a></li>
<li><a href='#EllDistrEst'><p>Nonparametric estimation of the density generator of an elliptical distribution</p></a></li>
<li><a href='#EllDistrEst.adapt'><p>Estimation of the generator of the elliptical distribution by kernel smoothing</p>
with adaptive choice of the bandwidth</a></li>
<li><a href='#EllDistrSim'><p>Simulation of elliptically symmetric random vectors</p></a></li>
<li><a href='#EllDistrSimCond'><p>Simulation of elliptically symmetric random vectors</p>
conditionally to some observed part.</a></li>
<li><a href='#estim_tilde_AMSE'><p>Estimate the part of the AMSE of the elliptical density generator that only depends</p>
on the parameter &quot;a&quot; assuming <code class="reqn">h</code> has been optimally chosen</a></li>
<li><a href='#KTMatrixEst'><p>Fast estimation of Kendall's tau matrix</p></a></li>
<li><a href='#TEllDistrEst'><p>Estimation of trans-elliptical distributions</p></a></li>
<li><a href='#vectorized_Faa_di_Bruno'><p>Vectorized version of Faa di Bruno formula</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Inference of Elliptical Distributions and Copulas</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for the simulation and
  the nonparametric estimation of elliptical distributions,
  meta-elliptical copulas and trans-elliptical distributions,
  following the article Derumigny and Fermanian (2022) &lt;<a href="https://doi.org/10.1016%2Fj.jmva.2022.104962">doi:10.1016/j.jmva.2022.104962</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Runuran, wdm, Matrix, kStatistics, pbapply</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mvtnorm, Rmpfr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/AlexisDerumigny/ElliptCopulas/issues">https://github.com/AlexisDerumigny/ElliptCopulas/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/AlexisDerumigny/ElliptCopulas">https://github.com/AlexisDerumigny/ElliptCopulas</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-09 13:29:07 UTC; aderumigny</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexis Derumigny <a href="https://orcid.org/0000-0002-6163-8097"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jean-David Fermanian
    <a href="https://orcid.org/0000-0001-5960-5555"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Victor Ryan [aut],
  Rutger van der Spek [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexis Derumigny &lt;a.f.f.derumigny@tudelft.nl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-09 15:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='compute_etahat'>Compute <code class="reqn">\hat{\eta}_k</code></h2><span id='topic+compute_etahat'></span>

<h3>Description</h3>

<p><code class="reqn">\hat{\eta}_k</code> is a quantity that is useful
for estimating the <code class="reqn">k</code>-th derivative of the generator
of an elliptical distribution.
It is defined in Section 3 of (Ryan and Derumigny, 2024).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_etahat(
  X,
  mu = 0,
  Sigma_m1 = diag(d),
  grid,
  h,
  Kernel = "gaussian",
  a = 1,
  k,
  mpfr = FALSE,
  precBits = 100,
  dopb = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_etahat_+3A_x">X</code></td>
<td>
<p>a matrix of size <code class="reqn">n \times d</code>, assumed to be <code class="reqn">n</code> i.i.d. observations
(rows) of a <code class="reqn">d</code>-dimensional elliptical distribution.</p>
</td></tr>
<tr><td><code id="compute_etahat_+3A_mu">mu</code></td>
<td>
<p>mean of X. This can be the true value or an estimate. It must be
a vector of dimension <code class="reqn">d</code>.</p>
</td></tr>
<tr><td><code id="compute_etahat_+3A_sigma_m1">Sigma_m1</code></td>
<td>
<p>inverse of the covariance matrix of X.
This can be the true value or an estimate. It must be
a matrix of dimension <code class="reqn">d \times d</code>.</p>
</td></tr>
<tr><td><code id="compute_etahat_+3A_grid">grid</code></td>
<td>
<p>grid of values on which to estimate the density generator.</p>
</td></tr>
<tr><td><code id="compute_etahat_+3A_h">h</code></td>
<td>
<p>bandwidth of the kernel. Can be either a number or a vector of the
size <code>length(grid)</code>.</p>
</td></tr>
<tr><td><code id="compute_etahat_+3A_kernel">Kernel</code></td>
<td>
<p>name of the kernel. Possible choices are
<code>"gaussian"</code>, <code>"epanechnikov"</code>, <code>"triangular"</code>.</p>
</td></tr>
<tr><td><code id="compute_etahat_+3A_a">a</code></td>
<td>
<p>tuning parameter to improve the performance at 0.</p>
</td></tr>
<tr><td><code id="compute_etahat_+3A_k">k</code></td>
<td>
<p>order of the derivative</p>
</td></tr>
<tr><td><code id="compute_etahat_+3A_mpfr">mpfr</code></td>
<td>
<p>if <code>mpfr = TRUE</code>, multiple precision floating point is used
via the package <a href="Rmpfr.html#topic+Rmpfr">Rmpfr</a>.
This allows for a higher (numerical) accuracy, at the expense of computing time.
It is recommended to use this option for higher dimensions.</p>
</td></tr>
<tr><td><code id="compute_etahat_+3A_precbits">precBits</code></td>
<td>
<p>number of precBits used for floating point precision
(only used if <code>mpfr = TRUE</code>).</p>
</td></tr>
<tr><td><code id="compute_etahat_+3A_dopb">dopb</code></td>
<td>
<p>a Boolean value.
If <code>dopb = TRUE</code>, a progress bar is displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of size <code>n1 = length(grid)</code>.
Each component of this vector is <code class="reqn">\hat{\eta}_k(x[i])</code>
where <code>x[i]</code> is the <code class="reqn">i</code>-th element of the grid.
</p>


<h3>Author(s)</h3>

<p>Victor Ryan, Alexis Derumigny
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (FALSE){
# Comparison between the estimated and true generator of the Gaussian distribution
n = 500000
d = 3
X = matrix(rnorm(n * d), ncol = d)
grid = seq(0, 5, by = 0.1)
a = 0.7

etahat = compute_etahat(X = X, grid = grid, a = a, h = 0.04, k = 1)
plot(grid, etahat, type = "l", ylim = c(-0.02, 0.02))

# Computation of true values
g = exp(-grid/2)/(2*pi)^{3/2}
gprime = (-1/2) *exp(-grid/2)/(2*pi)^{3/2}
A = a^(d/2)
psia = -a + (A + grid^(d/2))^(2/d)
psiaprime = grid^(d/2 - 1) * (A + grid^(d/2))^(2/d - 1)
psiasecond = psiaprime * ( (d-2)/2 ) * grid^{-1} * A *
  ( grid^(d/2) + A )^(-1)

rhoprimexi = ((d-2) * grid^((d-4)/2) * psiaprime
- 2 * grid^((d-2)/2) * psiasecond) / (2 * psiaprime^3) * g +
grid^((d-2)/2) / (psiaprime^2) * gprime

lines(grid, rhoprimexi, col = "red")
}

</code></pre>

<hr>
<h2 id='compute_matrix_alpha'>Compute the matrix of coefficients alpha</h2><span id='topic+compute_matrix_alpha'></span>

<h3>Description</h3>

<p>This matrix of coefficient is useful for the estimation of higher-order
derivatives of an elliiptical distribution density generator. It is introduced
in Section 3 of (Ryan and Derumigny, 2024).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_matrix_alpha(kmax, grid, a, d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_matrix_alpha_+3A_kmax">kmax</code></td>
<td>
<p>order the derivative that we want to compute</p>
</td></tr>
<tr><td><code id="compute_matrix_alpha_+3A_grid">grid</code></td>
<td>
<p>the grid of the values at which we want to compute the derivative</p>
</td></tr>
<tr><td><code id="compute_matrix_alpha_+3A_a">a</code></td>
<td>
<p>the tuning parameter controlling the bias of the estimator
at zero.</p>
</td></tr>
<tr><td><code id="compute_matrix_alpha_+3A_d">d</code></td>
<td>
<p>the dimension of the problem</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>(kmax+1) * (kmax+1) * length(grid)</code> array
</p>


<h3>Author(s)</h3>

<p>Victor Ryan, Alexis Derumigny
</p>


<h3>References</h3>

<p>Ryan, V., &amp; Derumigny, A. (2024).
On the choice of the two tuning parameters for nonparametric estimation of an
elliptical distribution generator
<a href="https://arxiv.org/abs/2408.17087">arxiv:2408.17087</a>.
</p>


<h3>See Also</h3>

<p>This function uses the internal functions <code><a href="#topic+derivative.tau">derivative.tau</a></code>
and <code><a href="#topic+derivative.psi">derivative.psi</a></code>.
See also <code><a href="#topic+vectorized_Faa_di_Bruno">vectorized_Faa_di_Bruno</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kmax = 1
d = 3
grid = 0.2
a = 0.8
compute_matrix_alpha(kmax = kmax, grid = grid, a = a, d = d)

</code></pre>

<hr>
<h2 id='conv_funct'>Conversion Functions for Elliptical Distributions</h2><span id='topic+conv_funct'></span><span id='topic+Convert_gd_To_g1'></span><span id='topic+Convert_g1_To_Fg1'></span><span id='topic+Convert_g1_To_Qg1'></span><span id='topic+Convert_g1_To_f1'></span><span id='topic+Convert_gd_To_fR2'></span>

<h3>Description</h3>

<p>An elliptical random vector X of density <code class="reqn">|det(\Sigma)|^{-1/2} g_d(x' \Sigma^{-1} x)</code>
can always be written as <code class="reqn">X = \mu + R * A * U</code> for some positive random variable <code class="reqn">R</code>
and a random vector <code class="reqn">U</code> on the <code class="reqn">d</code>-dimensional sphere.
Furthermore, there is a one-to-one mapping between g_d
and its one-dimensional marginal g_1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Convert_gd_To_g1(grid, g_d, d)

Convert_g1_To_Fg1(grid, g_1)

Convert_g1_To_Qg1(grid, g_1)

Convert_g1_To_f1(grid, g_1)

Convert_gd_To_fR2(grid, g_d, d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conv_funct_+3A_grid">grid</code></td>
<td>
<p>the grid on which the values of the functions in parameter are given.</p>
</td></tr>
<tr><td><code id="conv_funct_+3A_g_d">g_d</code></td>
<td>
<p>the <code class="reqn">d</code>-dimensional density generator.</p>
</td></tr>
<tr><td><code id="conv_funct_+3A_d">d</code></td>
<td>
<p>the dimension of the random vector.</p>
</td></tr>
<tr><td><code id="conv_funct_+3A_g_1">g_1</code></td>
<td>
<p>the <code class="reqn">1</code>-dimensional density generator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>One of the following </p>

<ul>
<li> <p><code>g_1</code> the <code class="reqn">1</code>-dimensional density generator.
</p>
</li>
<li> <p><code>Fg1</code> the <code class="reqn">1</code>-dimensional marginal cumulative distribution function.
</p>
</li>
<li> <p><code>Qg1</code> the <code class="reqn">1</code>-dimensional marginal quantile function
(approximately equal to the inverse function of Fg1).
</p>
</li>
<li> <p><code>f1</code> the density of a <code class="reqn">1</code>-dimensional margin if <code class="reqn">\mu = 0</code>
and <code class="reqn">A</code> is the identity matrix.
</p>
</li>
<li> <p><code>fR2</code> the density function of <code class="reqn">R^2</code>.
</p>
</li></ul>

<p>The function <code>Convert_gd_To_g1</code> returns a numerical vector of (approximated) values
of <code>g_1</code> on the same grid as <code>gd</code>.
In all other cases, a function is returned (see the examples section).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DensityGenerator.normalize">DensityGenerator.normalize</a></code>
to compute the normalized version of a given <code class="reqn">d</code>-dimensional generator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid = seq(0,100,by = 0.01)
g_d = DensityGenerator.normalize(grid = grid, grid_g = 1/(1+grid^3), d = 3)
g_1 = Convert_gd_To_g1(grid = grid, g_d = g_d, d = 3)
Fg_1 = Convert_g1_To_Fg1(grid = grid, g_1 = g_1)
Qg_1 = Convert_g1_To_Qg1(grid = grid, g_1 = g_1)
f1 = Convert_g1_To_f1(grid = grid, g_1 = g_1)
fR2 = Convert_gd_To_fR2(grid = grid, g_d = g_d, d = 3)
plot(grid, g_d, type = "l", xlim = c(0,10))
plot(grid, g_1, type = "l", xlim = c(0,10))
plot(Fg_1, xlim = c(-3,3))
plot(Qg_1, xlim = c(0.01,0.99))
plot(f1, xlim = c(-3,3))
plot(fR2, xlim = c(0,3))

</code></pre>

<hr>
<h2 id='DensityGenerator.normalize'>Normalization of an elliptical copula generator</h2><span id='topic+DensityGenerator.normalize'></span><span id='topic+DensityGenerator.check'></span>

<h3>Description</h3>

<p>The function <code>DensityGenerator.normalize</code> transforms an elliptical copula generator
into an elliptical copula generator,generating the same distribution
and which is normalized to follow the normalization constraint
</p>
<p style="text-align: center;"><code class="reqn">\frac{\pi^{d/2}}{\Gamma(d/2)}
\int_0^{+\infty} g_k(t) t^{(d-2)/2} dt = 1.</code>
</p>

<p>as well as the identification constraint
</p>
<p style="text-align: center;"><code class="reqn">\frac{\pi^{(d-1)/2}}{\Gamma((d-1)/2)}
\int_0^{+\infty} g_k(t) t^{(d-3)/2} dt = b.</code>
</p>

<p>The function <code>DensityGenerator.check</code> checks, for a given generator,
whether these two constraints are satisfied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DensityGenerator.normalize(grid, grid_g, d, verbose = 0, b = 1)

DensityGenerator.check(grid, grid_g, d, b = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DensityGenerator.normalize_+3A_grid">grid</code></td>
<td>
<p>the regularly spaced grid on which the values of the generator are given.</p>
</td></tr>
<tr><td><code id="DensityGenerator.normalize_+3A_grid_g">grid_g</code></td>
<td>
<p>the values of the <code class="reqn">d</code>-dimensional generator at points of the grid.</p>
</td></tr>
<tr><td><code id="DensityGenerator.normalize_+3A_d">d</code></td>
<td>
<p>the dimension of the space.</p>
</td></tr>
<tr><td><code id="DensityGenerator.normalize_+3A_verbose">verbose</code></td>
<td>
<p>if 1, prints the estimated (alpha, beta) such that
<code>new_g(t) = alpha * old_g(beta*t)</code>.</p>
</td></tr>
<tr><td><code id="DensityGenerator.normalize_+3A_b">b</code></td>
<td>
<p>the target value for the identification constraint.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>DensityGenerator.normalize</code> returns
the normalized generator, as a list of values on the same <code>grid</code>.
</p>
<p><code>DensityGenerator.check</code> returns (invisibly) a vector of two booleans
where the first element is <code>TRUE</code> if the normalization constraint is satisfied
and the second element is <code>TRUE</code> if the identification constraint is satisfied.
</p>


<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2022).
Identifiability and estimation of meta-elliptical copula generators.
Journal of Multivariate Analysis, article 104962.
<a href="https://doi.org/10.1016/j.jmva.2022.104962">doi:10.1016/j.jmva.2022.104962</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EllCopSim">EllCopSim()</a></code> for the simulation of elliptical copula samples,
<code><a href="#topic+EllCopEst">EllCopEst()</a></code> for the estimation of elliptical copula,
<a href="#topic+conv_funct">conversion functions</a> for the conversion between different representation
of the generator of an elliptical copula.
</p>

<hr>
<h2 id='derivative.psi'>Computing <code class="reqn">\psi</code>, its inverse <code class="reqn">\Psi</code> and the <code class="reqn">k</code>-th derivative of <code class="reqn">\Psi</code></h2><span id='topic+derivative.psi'></span><span id='topic+f1'></span><span id='topic+f2'></span>

<h3>Description</h3>

<p>The function <code class="reqn">\psi</code> is used to estimate the generator of elliptical distribution.
It depends on the parameter <code class="reqn">a</code>, which reduces the bias of the estimator around zero.
The functions <code>f1</code> and <code>f2</code> are already implemented in <code>derivative.psi</code>.
They are required to compute higher derivatives of <code class="reqn">\Psi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derivative.psi(x, a, d, k, inverse)

f1(x, d, k = 0)

f2(x, a, d, k = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="derivative.psi_+3A_x">x</code></td>
<td>
<p>a numeric value</p>
</td></tr>
<tr><td><code id="derivative.psi_+3A_a">a</code></td>
<td>
<p>a parameter <code class="reqn">a &gt; 0</code> that reduces the bias of the estimator around zero</p>
</td></tr>
<tr><td><code id="derivative.psi_+3A_d">d</code></td>
<td>
<p>the dimension of the data</p>
</td></tr>
<tr><td><code id="derivative.psi_+3A_k">k</code></td>
<td>
<p>the order of derivative.
If <code>k = 0</code>, then the original function value is returned.
If <code>k &gt; 0</code>, the value of its derivative is returned.</p>
</td></tr>
<tr><td><code id="derivative.psi_+3A_inverse">inverse</code></td>
<td>
<p>if <code>inverse = TRUE</code>, then the inverse of <code class="reqn">\Psi</code> is
of interest. Otherwise, the function <code class="reqn">\psi</code> is used for the computation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value <code class="reqn">\psi(x)^{(k)}</code> if <code>inverse = TRUE</code>,
otherwise <code class="reqn">\Psi(x)^{(k)}</code>.
</p>
<p>The functions <code>f1</code> and <code>f2</code> also return a numeric value
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>f1()</code>: <code class="reqn">f_1(x) = x^{2/d}</code>
</p>
</li>
<li> <p><code>f2()</code>: <code class="reqn">f_2(x) = (x + a)^{d/2} - a^{d/2}</code>
</p>
</li></ul>


<h3>Note</h3>

<p>The derivatives of <code class="reqn">\psi</code> is not yet implemented. The function <code class="reqn">\psi</code>
is defined as <code class="reqn">\psi(x) = -a + (a^{d/2} + x^{d/2})^{2/d}</code>.
For any <code class="reqn">a &gt; 0</code> and <code class="reqn">x &gt; 0</code>, it has an inverse.
Let <code class="reqn">\Psi</code> be the inverse function of <code class="reqn">\psi</code>, then
</p>
<p style="text-align: center;"><code class="reqn">\Psi(x) = ((x+a)^{d/2} - a^{d/2})^{2/d} = (f_1 \circ f_2)(x).</code>
</p>



<h3>Author(s)</h3>

<p>Victor Ryan, Alexis Derumigny
</p>


<h3>References</h3>

<p>Ryan, V., &amp; Derumigny, A. (2024).
On the choice of the two tuning parameters for nonparametric estimation of an
elliptical distribution generator
<a href="https://arxiv.org/abs/2408.17087">arxiv:2408.17087</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derivative.tau">derivative.tau</a></code> and <code><a href="#topic+derivative.rho">derivative.rho</a></code>.
<code><a href="#topic+vectorized_Faa_di_Bruno">vectorized_Faa_di_Bruno</a></code> which is used for the computation
of the derivatives.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Return the 5-th derivative of the inverse of psi
derivative.psi(x = 1, a = 1, d = 3, k = 5, inverse = TRUE)

# Return psi
derivative.psi(x = 1, a = 1, d = 3, k = 0, inverse = FALSE)

</code></pre>

<hr>
<h2 id='derivative.rho'>Computing <code class="reqn">\rho</code> and its <code class="reqn">k</code>-th derivative</h2><span id='topic+derivative.rho'></span>

<h3>Description</h3>

<p>The function <code class="reqn">\rho</code> is used to compute <code class="reqn">\widetilde{AMSE}</code>.
The quantity <code class="reqn">\widetilde{AMSE}</code> is of interest
because we can use it to find the optimal <code class="reqn">a</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derivative.rho(grid, a, d, k, derivatives.g)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="derivative.rho_+3A_grid">grid</code></td>
<td>
<p>a grid of numeric values</p>
</td></tr>
<tr><td><code id="derivative.rho_+3A_a">a</code></td>
<td>
<p>a parameter <code class="reqn">a &gt; 0</code> that reduces the bias of the estimator around zero</p>
</td></tr>
<tr><td><code id="derivative.rho_+3A_d">d</code></td>
<td>
<p>the dimension of the data</p>
</td></tr>
<tr><td><code id="derivative.rho_+3A_k">k</code></td>
<td>
<p>the order of derivative of <code class="reqn">\rho</code>.
If <code>k = 0</code>, then the original function value is returned.
If <code>k &gt; 0</code>, the value of its derivative is returned</p>
</td></tr>
<tr><td><code id="derivative.rho_+3A_derivatives.g">derivatives.g</code></td>
<td>
<p>a matrix of size <code>length(x) * (k + 1)</code>
whose entry of position <code>[i,j]</code> is <code class="reqn">g^{(j - 1)} (x[i])</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector <code class="reqn">\rho(grid[1])^{(k)}, \dots, \rho(grid[N])^{(k)}</code>,
where <code class="reqn">N</code> is the length of the grid
</p>


<h3>Author(s)</h3>

<p>Victor Ryan, Alexis Derumigny
</p>


<h3>References</h3>

<p>Ryan, V., &amp; Derumigny, A. (2024).
On the choice of the two tuning parameters for nonparametric estimation of an
elliptical distribution generator
<a href="https://arxiv.org/abs/2408.17087">arxiv:2408.17087</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derivative.tau">derivative.tau</a></code> and <code><a href="#topic+derivative.psi">derivative.psi</a></code>.
<code>EllDistrDerivEst</code> for the nonparametric estimation of the derivatives
of <code>g</code>, the elliptical distribution density generator.
<code><a href="#topic+compute_matrix_alpha">compute_matrix_alpha</a></code> which is used for the computation
of the derivatives.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Return the 5-th derivative of tau at x = 1

grid = c(1)
a = 1; d = 3; k = 3
der.g = matrix(seq(1, 3, length.out = 4), nrow = 1)
derivative.rho(grid = grid, a = a, d = d, k = k, derivatives.g = der.g)

</code></pre>

<hr>
<h2 id='derivative.tau'>Computing <code class="reqn">\tau</code> and its <code class="reqn">k</code>-th derivative</h2><span id='topic+derivative.tau'></span><span id='topic+f3'></span><span id='topic+f4'></span>

<h3>Description</h3>

<p>The function <code class="reqn">\tau</code> is used to compute <code class="reqn">\alpha_{i,k}</code>,
which is required to compute the derivatives
of the generator of elliptical distribution.
The functions <code>f3</code> and <code>f4</code> are already implemented in <code>derivative.tau</code>.
These functions are needed for computing higher derivatives of <code class="reqn">\tau</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derivative.tau(x, a, d, k)

f3(x, d, k = 0)

f4(x, a, d, k = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="derivative.tau_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="derivative.tau_+3A_a">a</code></td>
<td>
<p>a parameter <code class="reqn">a &gt; 0</code> that reduces the bias of the estimator around zero</p>
</td></tr>
<tr><td><code id="derivative.tau_+3A_d">d</code></td>
<td>
<p>the dimension of the data</p>
</td></tr>
<tr><td><code id="derivative.tau_+3A_k">k</code></td>
<td>
<p>the order of derivatives for <code>f3</code> and <code>f4</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector <code class="reqn">\tau^{(k)}(x_1), ..., \tau^{(k)}(x_N)</code>
where <code>N = length(x)</code>.
</p>
<p>The functions <code>f3</code> and <code>f4</code> also return a numeric value
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>f3()</code>: <code class="reqn">f_3(x) = x^{(d-2)/d}</code>
</p>
</li>
<li> <p><code>f4()</code>: <code class="reqn">f_4(x) = a^{d/2} + x^{d/2}</code>
</p>
</li></ul>


<h3>Note</h3>

<p>The function <code class="reqn">\tau</code> is defined as follows:
<code class="reqn">\tau(x) = x^{(d-2)/2}/\psi^{\prime}(x)</code>, where
<code class="reqn">\psi^{\prime}(x) = x^{d/2 - 1}(a^{d/2} + x^{d/2})^{2/d - 1}</code>.
The definition of <code class="reqn">\psi</code> is already described in <code>derivative.tau</code>.
Therefore, by the definition of <code class="reqn">f_3</code> and <code class="reqn">f_4</code>,
the function <code class="reqn">\tau</code> is actually <code class="reqn">\tau(x) = (f_3 \circ f_4)(x)</code>.
</p>


<h3>Author(s)</h3>

<p>Victor Ryan, Alexis Derumigny
</p>


<h3>References</h3>

<p>Ryan, V., &amp; Derumigny, A. (2024).
On the choice of the two tuning parameters for nonparametric estimation of an
elliptical distribution generator
<a href="https://arxiv.org/abs/2408.17087">arxiv:2408.17087</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derivative.psi">derivative.psi</a></code> and <code><a href="#topic+derivative.rho">derivative.rho</a></code>.
<code><a href="#topic+vectorized_Faa_di_Bruno">vectorized_Faa_di_Bruno</a></code> which is used for the computation
of the derivatives.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Return the 5-th derivative of tau at x = 1
derivative.tau(x = 1, a = 1, d = 3, k = 5)

# Return the value of tau at x = 1.
derivative.tau(x = 1, a = 1, d = 3, k = 0)

# Vectorized version
derivative.tau(x = c(1,3), a = 1, d = 3, k = 5)

</code></pre>

<hr>
<h2 id='EllCopEst'>Estimate the density generator of a (meta-)elliptical copula</h2><span id='topic+EllCopEst'></span>

<h3>Description</h3>

<p>This function estimates the density generator of a (meta-)elliptical copula
using the iterative procedure described in (Derumigny and Fermanian, 2022).
This iterative procedure consists in alternating a step of estimating the data
via Liebscher's procedure <code><a href="#topic+EllDistrEst">EllDistrEst()</a></code> and estimating the quantile function
of the underlying elliptical distribution to transform the data back to the unit cube.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EllCopEst(
  dataU,
  Sigma_m1,
  h,
  grid = seq(0, 10, by = 0.01),
  niter = 10,
  a = 1,
  Kernel = "epanechnikov",
  verbose = 1,
  startPoint = "identity",
  prenormalization = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EllCopEst_+3A_datau">dataU</code></td>
<td>
<p>the data matrix on the <code class="reqn">[0,1]</code> scale.</p>
</td></tr>
<tr><td><code id="EllCopEst_+3A_sigma_m1">Sigma_m1</code></td>
<td>
<p>the inverse of the correlation matrix of the components of data</p>
</td></tr>
<tr><td><code id="EllCopEst_+3A_h">h</code></td>
<td>
<p>bandwidth of the kernel for Liebscher's procedure</p>
</td></tr>
<tr><td><code id="EllCopEst_+3A_grid">grid</code></td>
<td>
<p>the grid at which the density generator is estimated.</p>
</td></tr>
<tr><td><code id="EllCopEst_+3A_niter">niter</code></td>
<td>
<p>the number of iterations</p>
</td></tr>
<tr><td><code id="EllCopEst_+3A_a">a</code></td>
<td>
<p>tuning parameter to improve the performance at 0.
See Liebscher (2005), Example p.210</p>
</td></tr>
<tr><td><code id="EllCopEst_+3A_kernel">Kernel</code></td>
<td>
<p>kernel used for the smoothing.
Possible choices are <code>gaussian</code>, <code>epanechnikov</code> and <code>triangular</code>.</p>
</td></tr>
<tr><td><code id="EllCopEst_+3A_verbose">verbose</code></td>
<td>
<p>if 1, prints the progress of the iterations.
If 2, prints the normalization constants used at each iteration,
as computed by <code><a href="#topic+DensityGenerator.normalize">DensityGenerator.normalize</a></code>.</p>
</td></tr>
<tr><td><code id="EllCopEst_+3A_startpoint">startPoint</code></td>
<td>
<p>is the given starting point of the procedure </p>

<ul>
<li> <p><code>startPoint = "gaussian"</code> for using the gaussian generator as starting point ;
</p>
</li>
<li> <p><code>startPoint = "identity"</code> for a data-driven starting point ;
</p>
</li>
<li> <p><code>startPoint = "A~Phi^{-1}"</code> for another data-driven starting point using
the Gaussian quantile function.
</p>
</li></ul>
</td></tr>
<tr><td><code id="EllCopEst_+3A_prenormalization">prenormalization</code></td>
<td>
<p>if <code>TRUE</code>, the procedure will normalize the variables
at each iteration so that the variance is <code class="reqn">1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of two elements:
</p>

<ul>
<li> <p><code>g_d_norm</code>: the estimated elliptical copula generator at each point of the grid;
</p>
</li>
<li> <p><code>list_path_gdh</code>: the list of estimated elliptical copula generator at each iteration.
</p>
</li></ul>



<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2022).
Identifiability and estimation of meta-elliptical copula generators.
Journal of Multivariate Analysis, article 104962.
<a href="https://doi.org/10.1016/j.jmva.2022.104962">doi:10.1016/j.jmva.2022.104962</a>.
</p>
<p>Liebscher, E. (2005).
A semiparametric density estimator based on elliptical distributions.
Journal of Multivariate Analysis, 92(1), 205.
<a href="https://doi.org/10.1016/j.jmva.2003.09.007">doi:10.1016/j.jmva.2003.09.007</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EllDistrEst">EllDistrEst</a></code> for the estimation of elliptical distributions,
<code><a href="#topic+EllCopSim">EllCopSim</a></code> for the simulation of elliptical copula samples,
<code><a href="#topic+EllCopLikelihood">EllCopLikelihood</a></code> for the computation of the likelihood of a given generator,
<code><a href="#topic+DensityGenerator.normalize">DensityGenerator.normalize</a></code> to compute the normalized version of a given generator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulation from a Gaussian copula
grid = seq(0,10,by = 0.01)
g_d = DensityGenerator.normalize(grid, grid_g = exp(-grid), d = 3)
n = 10
# To have a nice estimation, we suggest to use rather n=200
# (around 20s of computation time)
U = EllCopSim(n = n, d = 3, grid = grid, g_d = g_d)
result = EllCopEst(dataU = U, grid, Sigma_m1 = diag(3),
                   h = 0.1, a = 0.5)
plot(grid, g_d, type = "l", xlim = c(0,2))
lines(grid, result$g_d_norm, col = "red", xlim = c(0,2))

# Adding missing observations
n_NA = 2
U_NA = U
for (i in 1:n_NA){
  U_NA[sample.int(n,1), sample.int(3,1)] = NA
}
resultNA = EllCopEst(dataU = U_NA, grid, Sigma_m1 = diag(3),
                     h = 0.1, a = 0.5)
lines(grid, resultNA$g_d_norm, col = "blue", xlim = c(0,2))


</code></pre>

<hr>
<h2 id='EllCopLikelihood'>Computation of the likelihood of an elliptical copula</h2><span id='topic+EllCopLikelihood'></span>

<h3>Description</h3>

<p>Computes the likelihood
</p>
<p style="text-align: center;"><code class="reqn">\frac{g(Q_g(U) \Sigma^{-1} Q_g(U))}{f_g(Q_g(U_1)) \cdots f_g(Q_g(U_d))}
</code>
</p>

<p>for a vector <code class="reqn">(U_1, \dots, U_d)</code> on the unit cube
and for a <code class="reqn">d</code>-dimensional generator <code class="reqn">g</code> whose univariate density and quantile functions
are respectively <code class="reqn">f_g</code> and <code class="reqn">Q_g</code>.
This is to the likelihood of the copula associated with the elliptical distribution
having density <code class="reqn">|det(\Sigma)|^{-1/2} g(x \Sigma^{-1} x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EllCopLikelihood(grid, g_d, pointsToCompute, Sigma_m1, log = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EllCopLikelihood_+3A_grid">grid</code></td>
<td>
<p>the discretization grid on which the generator is given.</p>
</td></tr>
<tr><td><code id="EllCopLikelihood_+3A_g_d">g_d</code></td>
<td>
<p>the values of the <code class="reqn">d</code>-dimensional density generator on the grid.</p>
</td></tr>
<tr><td><code id="EllCopLikelihood_+3A_pointstocompute">pointsToCompute</code></td>
<td>
<p>the points <code class="reqn">U</code> at which the likelihood should be computed.
If <code>pointsToCompute</code> is a vector, then its length is used as the dimension <code class="reqn">d</code> of the space.
If it is a matrix, then the dimension of the space is the number of columns.</p>
</td></tr>
<tr><td><code id="EllCopLikelihood_+3A_sigma_m1">Sigma_m1</code></td>
<td>
<p>the inverse correlation matrix of the elliptical distribution.</p>
</td></tr>
<tr><td><code id="EllCopLikelihood_+3A_log">log</code></td>
<td>
<p>if <code>TRUE</code>, this returns the log-likelihood instead of the likelihood.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector (of length 1 if <code>pointsToCompute</code> is a vector) of likelihoods
associated with each observation.
</p>


<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2022).
Identifiability and estimation of meta-elliptical copula generators.
Journal of Multivariate Analysis, article 104962.
<a href="https://doi.org/10.1016/j.jmva.2022.104962">doi:10.1016/j.jmva.2022.104962</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EllCopEst">EllCopEst</a></code> for the estimation of elliptical copula,
<code><a href="#topic+EllCopEst">EllCopEst</a></code> for the estimation of elliptical copula.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid = seq(0,50,by = 0.01)
gdnorm = DensityGenerator.normalize(grid = grid, grid_g = exp(-grid/2), d = 3)
gdnorm2 = DensityGenerator.normalize(grid = grid, grid_g = 1/(1+grid^2), d = 3)
X = EllCopSim(n = 30, d = 3, grid = grid, g_d = gdnorm)
logLik = EllCopLikelihood(grid , g_d = gdnorm , X,
                          Sigma_m1 = diag(3), log = TRUE)
logLik2 = EllCopLikelihood(grid , g_d = gdnorm2 , X,
                           Sigma_m1 = diag(3), log = TRUE)
print(c(sum(logLik), sum(logLik2)))

</code></pre>

<hr>
<h2 id='EllCopSim'>Simulation from an elliptical copula model</h2><span id='topic+EllCopSim'></span>

<h3>Description</h3>

<p>Simulation from an elliptical copula model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EllCopSim(n, d, grid, g_d, A = diag(d), genR = list(method = "pinv"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EllCopSim_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="EllCopSim_+3A_d">d</code></td>
<td>
<p>dimension of X.</p>
</td></tr>
<tr><td><code id="EllCopSim_+3A_grid">grid</code></td>
<td>
<p>grid on which values of density generator are known.</p>
</td></tr>
<tr><td><code id="EllCopSim_+3A_g_d">g_d</code></td>
<td>
<p>vector of values of the density generator on the <code>grid</code>.</p>
</td></tr>
<tr><td><code id="EllCopSim_+3A_a">A</code></td>
<td>
<p>square-root of the correlation matrix of X.</p>
</td></tr>
<tr><td><code id="EllCopSim_+3A_genr">genR</code></td>
<td>
<p>additional arguments for the generation of the squared radius.
It must be a list with a component method: </p>

<ul>
<li><p> If <code>genR$method == "pinv"</code>, the radius is generated
using the function <code><a href="Runuran.html#topic+pinv.new">Runuran::pinv.new()</a></code>.
</p>
</li>
<li><p> If <code>genR$method == "MH"</code>,
the generation is done using the Metropolis-Hasting algorithm,
with a N(0,1) move at each step.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of size <code style="white-space: pre;">&#8288;(n,d)&#8288;</code> with <code>n</code> observations
of the <code>d</code>-dimensional elliptical copula.
</p>


<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2022).
Identifiability and estimation of meta-elliptical copula generators.
Journal of Multivariate Analysis, article 104962.
<a href="https://doi.org/10.1016/j.jmva.2022.104962">doi:10.1016/j.jmva.2022.104962</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EllDistrSim">EllDistrSim</a></code> for the simulation of elliptical distributions samples,
<code><a href="#topic+EllCopEst">EllCopEst</a></code> for the estimation of elliptical copula,
<code><a href="#topic+EllCopLikelihood">EllCopLikelihood</a></code> for the computation of the likelihood of a given generator,
<code><a href="#topic+DensityGenerator.normalize">DensityGenerator.normalize</a></code> to compute the normalized version of a given generator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation from a Gaussian copula
grid = seq(0,5,by = 0.01)
X = EllCopSim(n = 20, d = 2, grid = grid, g_d = exp(-grid/2))
X = EllCopSim(n = 20, d = 2, grid = grid, g_d = exp(-grid/2),
              genR = list(method = "MH", niter = 500) )
plot(X)

</code></pre>

<hr>
<h2 id='EllDistrDerivEst'>Estimate the derivatives of a generator</h2><span id='topic+EllDistrDerivEst'></span>

<h3>Description</h3>

<p>A continuous elliptical distribution has a density of the form
</p>
<p style="text-align: center;"><code class="reqn">f_X(x) = {|\Sigma|}^{-1/2}
g\left( (x-\mu)^\top \, \Sigma^{-1} \, (x-\mu) \right),
</code>
</p>

<p>where <code class="reqn">x \in \mathbb{R}^d</code>,
<code class="reqn">\mu \in \mathbb{R}^d</code> is the mean,
<code class="reqn">\Sigma</code> is a <code class="reqn">d \times d</code> positive-definite matrix
and a function <code class="reqn">g: \mathbb{R}_+ \rightarrow \mathbb{R}_+</code>, called the
density generator of <code class="reqn">X</code>.
The goal is to estimate the derivatives of <code class="reqn">g</code> at some point <code class="reqn">\xi</code>,
by kernel smoothing, following Section 3 of (Ryan and Derumigny, 2024).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EllDistrDerivEst(
  X,
  mu = 0,
  Sigma_m1 = diag(NCOL(X)),
  grid,
  h,
  Kernel = "gaussian",
  a = 1,
  k,
  mpfr = FALSE,
  precBits = 100,
  dopb = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EllDistrDerivEst_+3A_x">X</code></td>
<td>
<p>a matrix of size <code class="reqn">n \times d</code>, assumed to be <code class="reqn">n</code> i.i.d. observations
(rows) of a <code class="reqn">d</code>-dimensional elliptical distribution.</p>
</td></tr>
<tr><td><code id="EllDistrDerivEst_+3A_mu">mu</code></td>
<td>
<p>mean of X. This can be the true value or an estimate. It must be
a vector of dimension <code class="reqn">d</code>.</p>
</td></tr>
<tr><td><code id="EllDistrDerivEst_+3A_sigma_m1">Sigma_m1</code></td>
<td>
<p>inverse of the covariance matrix of X.
This can be the true value or an estimate. It must be
a matrix of dimension <code class="reqn">d \times d</code>.</p>
</td></tr>
<tr><td><code id="EllDistrDerivEst_+3A_grid">grid</code></td>
<td>
<p>grid of values on which to estimate the density generator.</p>
</td></tr>
<tr><td><code id="EllDistrDerivEst_+3A_h">h</code></td>
<td>
<p>bandwidth of the kernel. Can be either a number or a vector of the
size <code>length(grid)</code>.</p>
</td></tr>
<tr><td><code id="EllDistrDerivEst_+3A_kernel">Kernel</code></td>
<td>
<p>name of the kernel. Possible choices are
<code>"gaussian"</code>, <code>"epanechnikov"</code>, <code>"triangular"</code>.</p>
</td></tr>
<tr><td><code id="EllDistrDerivEst_+3A_a">a</code></td>
<td>
<p>tuning parameter to improve the performance at 0.</p>
</td></tr>
<tr><td><code id="EllDistrDerivEst_+3A_k">k</code></td>
<td>
<p>highest order of the derivative of the generator that is to be
estimated. For example, <code>k = 1</code> corresponds to the estimation of the
generator and of its derivative. <code>k = 2</code> corresponds to the estimation
of the generator as well as its first and second derivatives.</p>
</td></tr>
<tr><td><code id="EllDistrDerivEst_+3A_mpfr">mpfr</code></td>
<td>
<p>if <code>mpfr = TRUE</code>, multiple precision floating point is used
via the package <a href="Rmpfr.html#topic+Rmpfr">Rmpfr</a>.
This allows for a higher (numerical) accuracy, at the expense of computing time.
It is recommended to use this option for higher dimensions.</p>
</td></tr>
<tr><td><code id="EllDistrDerivEst_+3A_precbits">precBits</code></td>
<td>
<p>number of precBits used for floating point precision
(only used if <code>mpfr = TRUE</code>).</p>
</td></tr>
<tr><td><code id="EllDistrDerivEst_+3A_dopb">dopb</code></td>
<td>
<p>a Boolean value.
If <code>dopb = TRUE</code>, a progress bar is displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function may be rather slow for higher-order derivatives.
Furthermore, it is likely that the number of observations needs to be quite
high for the higher-order derivatives to be estimated well enough.
</p>


<h3>Value</h3>

<p>a matrix of size <code>length(grid) * (kmax + 1)</code>
with the estimated value of the generator and all its derivatives
at all orders until and including <code>kmax</code>, at all points of the grid.
</p>


<h3>Author(s)</h3>

<p>Alexis Derumigny, Victor Ryan
</p>
<p>Victor Ryan, Alexis Derumigny
</p>


<h3>References</h3>

<p>Ryan, V., &amp; Derumigny, A. (2024).
On the choice of the two tuning parameters for nonparametric estimation of an
elliptical distribution generator
<a href="https://arxiv.org/abs/2408.17087">arxiv:2408.17087</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EllDistrEst">EllDistrEst</a></code> for the nonparametric estimation of the
elliptical distribution density generator itself,
<code><a href="#topic+EllDistrSim">EllDistrSim</a></code> for the simulation of elliptical distribution samples.
</p>
<p>This function uses the internal functions <code><a href="#topic+compute_etahat">compute_etahat</a></code>
and <code><a href="#topic+compute_matrix_alpha">compute_matrix_alpha</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Comparison between the estimated and true generator of the Gaussian distribution
n = 50000
d = 3
X = matrix(rnorm(n * d), ncol = d)
grid = seq(0, 5, by = 0.1)
a = 1.5

gprimeEst = EllDistrDerivEst(X = X, grid = grid, a = a, h = 0.09, k = 1)[,2]
plot(grid, gprimeEst, type = "l")

# Computation of true values
g = exp(-grid/2)/(2*pi)^{3/2}
gprime = (-1/2) * exp(-grid/2)/(2*pi)^{3/2}

lines(grid, gprime, col = "red")

</code></pre>

<hr>
<h2 id='EllDistrEst'>Nonparametric estimation of the density generator of an elliptical distribution</h2><span id='topic+EllDistrEst'></span>

<h3>Description</h3>

<p>This function uses Liebscher's algorithm to estimate the density generator
of an elliptical distribution by kernel smoothing.
A continuous elliptical distribution has a density of the form
</p>
<p style="text-align: center;"><code class="reqn">f_X(x) = {|\Sigma|}^{-1/2}
g\left( (x-\mu)^\top \, \Sigma^{-1} \, (x-\mu) \right),
</code>
</p>

<p>where <code class="reqn">x \in \mathbb{R}^d</code>,
<code class="reqn">\mu \in \mathbb{R}^d</code> is the mean,
<code class="reqn">\Sigma</code> is a <code class="reqn">d \times d</code> positive-definite matrix
and a function <code class="reqn">g: \mathbb{R}_+ \rightarrow \mathbb{R}_+</code>, called the
density generator of <code class="reqn">X</code>.
The goal is to estimate <code class="reqn">g</code> at some point <code class="reqn">\xi</code>, by
</p>
<p style="text-align: center;"><code class="reqn">
\widehat{g}_{n,h,a}(\xi)
:= \dfrac{\xi^{\frac{-d+2}{2}} \psi_a'(\xi)}{n h s_d}
\sum_{i=1}^n
  K\left( \dfrac{ \psi_a(\xi) - \psi_a(\xi_i) }{h} \right)
+ K\left( \dfrac{ \psi_a(\xi) + \psi_a(\xi_i) }{h} \right),
</code>
</p>

<p>where
<code class="reqn">s_d := \pi^{d/2} / \Gamma(d/2)</code>,
<code class="reqn">\Gamma</code> is the Gamma function,
<code class="reqn">h</code> and <code class="reqn">a</code> are tuning parameters (respectively the bandwidth and a
parameter controlling the bias at <code class="reqn">\xi = 0</code>),
<code class="reqn">\psi_a(\xi) := -a + (a^{d/2} + \xi^{d/2})^{2/d},</code>
<code class="reqn">\xi \in \mathbb{R}</code>, <code class="reqn">K</code> is a kernel function and
<code class="reqn">\xi_i := (X_i - \mu)^\top \, \Sigma^{-1} \, (X_i - \mu),
</code>
for a sample <code class="reqn">X_1, \dots, X_n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EllDistrEst(
  X,
  mu = 0,
  Sigma_m1 = diag(d),
  grid,
  h,
  Kernel = "epanechnikov",
  a = 1,
  mpfr = FALSE,
  precBits = 100,
  dopb = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EllDistrEst_+3A_x">X</code></td>
<td>
<p>a matrix of size <code class="reqn">n \times d</code>, assumed to be <code class="reqn">n</code> i.i.d. observations
(rows) of a <code class="reqn">d</code>-dimensional elliptical distribution.</p>
</td></tr>
<tr><td><code id="EllDistrEst_+3A_mu">mu</code></td>
<td>
<p>mean of X. This can be the true value or an estimate. It must be
a vector of dimension <code class="reqn">d</code>.</p>
</td></tr>
<tr><td><code id="EllDistrEst_+3A_sigma_m1">Sigma_m1</code></td>
<td>
<p>inverse of the covariance matrix of X.
This can be the true value or an estimate. It must be
a matrix of dimension <code class="reqn">d \times d</code>.</p>
</td></tr>
<tr><td><code id="EllDistrEst_+3A_grid">grid</code></td>
<td>
<p>grid of values of <code class="reqn">\xi</code> at which we want to estimate the
density generator.</p>
</td></tr>
<tr><td><code id="EllDistrEst_+3A_h">h</code></td>
<td>
<p>bandwidth of the kernel. Can be either a number or a vector of the
size <code>length(grid)</code>.</p>
</td></tr>
<tr><td><code id="EllDistrEst_+3A_kernel">Kernel</code></td>
<td>
<p>name of the kernel. Possible choices are
<code>"gaussian"</code>, <code>"epanechnikov"</code>, <code>"triangular"</code>.</p>
</td></tr>
<tr><td><code id="EllDistrEst_+3A_a">a</code></td>
<td>
<p>tuning parameter to improve the performance at 0.
Can be either a number or a vector of the
size <code>length(grid)</code>. If this is a vector, the code will need to allocate
a matrix of size <code>nrow(X) * length(grid)</code> which can be prohibitive in
some cases.</p>
</td></tr>
<tr><td><code id="EllDistrEst_+3A_mpfr">mpfr</code></td>
<td>
<p>if <code>mpfr = TRUE</code>, multiple precision floating point is used
via the package <a href="Rmpfr.html#topic+Rmpfr">Rmpfr</a>.
This allows for a higher (numerical) accuracy, at the expense of computing time.
It is recommended to use this option for higher dimensions.</p>
</td></tr>
<tr><td><code id="EllDistrEst_+3A_precbits">precBits</code></td>
<td>
<p>number of precBits used for floating point precision
(only used if <code>mpfr = TRUE</code>).</p>
</td></tr>
<tr><td><code id="EllDistrEst_+3A_dopb">dopb</code></td>
<td>
<p>a Boolean value.
If <code>dopb = TRUE</code>, a progress bar is displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the values of the density generator of the elliptical copula,
estimated at each point of the <code>grid</code>.
</p>


<h3>Author(s)</h3>

<p>Alexis Derumigny, Rutger van der Spek
</p>


<h3>References</h3>

<p>Liebscher, E. (2005).
A semiparametric density estimator based on elliptical distributions.
Journal of Multivariate Analysis, 92(1), 205.
<a href="https://doi.org/10.1016/j.jmva.2003.09.007">doi:10.1016/j.jmva.2003.09.007</a>
</p>
<p>The function <code class="reqn">\psi_a</code> is introduced in Liebscher (2005), Example p.210.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+EllDistrSim">EllDistrSim</a></code> for the simulation of elliptical distribution samples.
</p>
</li>
<li> <p><code><a href="#topic+estim_tilde_AMSE">estim_tilde_AMSE</a></code> for the estimation of a component of
the asymptotic mean-square error (AMSE) of this estimator
<code class="reqn">\widehat{g}_{n,h,a}(\xi)</code>, assuming <code class="reqn">h</code> has been optimally chosen.
</p>
</li>
<li> <p><code><a href="#topic+EllDistrEst.adapt">EllDistrEst.adapt</a></code> for the adaptive nonparametric estimation
of the generator of an elliptical distribution.
</p>
</li>
<li> <p><code><a href="#topic+EllDistrDerivEst">EllDistrDerivEst</a></code> for the nonparametric estimation of the
derivatives of the generator.
</p>
</li>
<li> <p><code><a href="#topic+EllCopEst">EllCopEst</a></code> for the estimation of elliptical copulas
density generators.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Comparison between the estimated and true generator of the Gaussian distribution
X = matrix(rnorm(500*3), ncol = 3)
grid = seq(0,5,by=0.1)
g_3 = EllDistrEst(X = X, grid = grid, a = 0.7, h=0.05)
g_3mpfr = EllDistrEst(X = X, grid = grid, a = 0.7, h=0.05,
                      mpfr = TRUE, precBits = 20)
plot(grid, g_3, type = "l")
lines(grid, exp(-grid/2)/(2*pi)^{3/2}, col = "red")

# In higher dimensions

d = 250
X = matrix(rnorm(500*d), ncol = d)
grid = seq(0, 400, by = 25)
true_g = exp(-grid/2) / (2*pi)^{d/2}

g_d = EllDistrEst(X = X, grid = grid, a = 100, h=40)

g_dmpfr = EllDistrEst(X = X, grid = grid, a = 100, h=40,
                      mpfr = TRUE, precBits = 10000)
ylim = c(min(c(true_g, as.numeric(g_dmpfr[which(g_dmpfr&gt;0)]))),
         max(c(true_g, as.numeric(g_dmpfr)), na.rm=TRUE) )
plot(grid, g_dmpfr, type = "l", col = "red", ylim = ylim, log = "y")
lines(grid, g_d, type = "l")
lines(grid, true_g, col = "blue")


</code></pre>

<hr>
<h2 id='EllDistrEst.adapt'>Estimation of the generator of the elliptical distribution by kernel smoothing
with adaptive choice of the bandwidth</h2><span id='topic+EllDistrEst.adapt'></span>

<h3>Description</h3>

<p>A continuous elliptical distribution has a density of the form
</p>
<p style="text-align: center;"><code class="reqn">f_X(x) = {|\Sigma|}^{-1/2}
g\left( (x-\mu)^\top \, \Sigma^{-1} \, (x-\mu) \right),
</code>
</p>

<p>where <code class="reqn">x \in \mathbb{R}^d</code>,
<code class="reqn">\mu \in \mathbb{R}^d</code> is the mean,
<code class="reqn">\Sigma</code> is a <code class="reqn">d \times d</code> positive-definite matrix
and a function <code class="reqn">g: \mathbb{R}_+ \rightarrow \mathbb{R}_+</code>, called the
density generator of <code class="reqn">X</code>.
The goal is to estimate <code class="reqn">g</code> at some point <code class="reqn">\xi</code>, by
</p>
<p style="text-align: center;"><code class="reqn">
\widehat{g}_{n,h,a}(\xi)
:= \dfrac{\xi^{\frac{-d+2}{2}} \psi_a'(\xi)}{n h s_d}
\sum_{i=1}^n
  K\left( \dfrac{ \psi_a(\xi) - \psi_a(\xi_i) }{h} \right)
+ K\left( \dfrac{ \psi_a(\xi) + \psi_a(\xi_i) }{h} \right),
</code>
</p>

<p>where
<code class="reqn">s_d := \pi^{d/2} / \Gamma(d/2)</code>,
<code class="reqn">\Gamma</code> is the Gamma function,
<code class="reqn">h</code> and <code class="reqn">a</code> are tuning parameters (respectively the bandwidth and a
parameter controlling the bias at <code class="reqn">\xi = 0</code>),
<code class="reqn">\psi_a(\xi) := -a + (a^{d/2} + \xi^{d/2})^{2/d},</code>
<code class="reqn">\xi \in \mathbb{R}</code>, <code class="reqn">K</code> is a kernel function and
<code class="reqn">\xi_i := (X_i - \mu)^\top \, \Sigma^{-1} \, (X_i - \mu),
</code>
for a sample <code class="reqn">X_1, \dots, X_n</code>.
This function computes &quot;optimal asymptotic&quot; values for the bandwidth <code class="reqn">h</code>
and the tuning parameter <code class="reqn">a</code> from a first step bandwidth that the user
needs to provide.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EllDistrEst.adapt(
  X,
  mu = 0,
  Sigma_m1 = diag(NCOL(X)),
  grid,
  h_firstStep,
  grid_a = NULL,
  Kernel = "gaussian",
  mpfr = FALSE,
  precBits = 100,
  dopb = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EllDistrEst.adapt_+3A_x">X</code></td>
<td>
<p>a matrix of size <code class="reqn">n \times d</code>, assumed to be <code class="reqn">n</code> i.i.d. observations
(rows) of a <code class="reqn">d</code>-dimensional elliptical distribution.</p>
</td></tr>
<tr><td><code id="EllDistrEst.adapt_+3A_mu">mu</code></td>
<td>
<p>mean of X. This can be the true value or an estimate. It must be
a vector of dimension <code class="reqn">d</code>.</p>
</td></tr>
<tr><td><code id="EllDistrEst.adapt_+3A_sigma_m1">Sigma_m1</code></td>
<td>
<p>inverse of the covariance matrix of X.
This can be the true value or an estimate. It must be
a matrix of dimension <code class="reqn">d \times d</code>.</p>
</td></tr>
<tr><td><code id="EllDistrEst.adapt_+3A_grid">grid</code></td>
<td>
<p>vector containing the values at which we want the generator to be
estimated.</p>
</td></tr>
<tr><td><code id="EllDistrEst.adapt_+3A_h_firststep">h_firstStep</code></td>
<td>
<p>a vector of size <code>2</code> containing first-step bandwidths
to be used. The first one is used for the estimation of the asymptotic mean-squared
error. The second one is used for the first step estimation of <code class="reqn">g</code>.
From these two estimators, a final value of the bandwidth <code class="reqn">h</code> is determined,
which is used for the final estimator of <code class="reqn">g</code>.
</p>
<p>If <code>h_firstStep</code> is of length <code>1</code>, its value is reused for both purposes
(estimation of the AMSE and first-step estimation of <code class="reqn">g</code>).</p>
</td></tr>
<tr><td><code id="EllDistrEst.adapt_+3A_grid_a">grid_a</code></td>
<td>
<p>the grid of possible values of <code>a</code> to be used.
If missing, a default sequence is used.</p>
</td></tr>
<tr><td><code id="EllDistrEst.adapt_+3A_kernel">Kernel</code></td>
<td>
<p>name of the kernel. Possible choices are
<code>"gaussian"</code>, <code>"epanechnikov"</code>, <code>"triangular"</code>.</p>
</td></tr>
<tr><td><code id="EllDistrEst.adapt_+3A_mpfr">mpfr</code></td>
<td>
<p>if <code>mpfr = TRUE</code>, multiple precision floating point is used
via the package <a href="Rmpfr.html#topic+Rmpfr">Rmpfr</a>.
This allows for a higher (numerical) accuracy, at the expense of computing time.
It is recommended to use this option for higher dimensions.</p>
</td></tr>
<tr><td><code id="EllDistrEst.adapt_+3A_precbits">precBits</code></td>
<td>
<p>number of precBits used for floating point precision
(only used if <code>mpfr = TRUE</code>).</p>
</td></tr>
<tr><td><code id="EllDistrEst.adapt_+3A_dopb">dopb</code></td>
<td>
<p>a Boolean value.
If <code>dopb = TRUE</code>, a progress bar is displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following elements: </p>

<ul>
<li> <p><code>g</code> a vector of size <code>n1 = length(grid)</code>.
Each component of this vector is an estimator of <code class="reqn">g(x[i])</code>
where <code>x[i]</code> is the <code class="reqn">i</code>-th element of the grid.
</p>
</li>
<li> <p><code>best_a</code> a vector of the same size as <code>grid</code> indicating
for each value of the grid what is the optimal choice of <code class="reqn">a</code> found by
our algorithm (which is used to estimate <code class="reqn">g</code>).
</p>
</li>
<li> <p><code>best_h</code> a vector of the same size as <code>grid</code> indicating
for each value of the grid what is the optimal choice of <code class="reqn">h</code> found by
our algorithm (which is used to estimate <code class="reqn">g</code>).
</p>
</li>
<li> <p><code>first_step_g</code> first step estimator of <code>g</code>, computed using
the tuning parameters <code>best_a</code> and <code>h_firstStep[2]</code>.
</p>
</li>
<li> <p><code>AMSE_estimated</code> an estimator of the part of the asymptotic MSE
that only depends on <code class="reqn">a</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Alexis Derumigny, Victor Ryan
</p>


<h3>References</h3>

<p>Ryan, V., &amp; Derumigny, A. (2024).
On the choice of the two tuning parameters for nonparametric estimation of an
elliptical distribution generator
<a href="https://arxiv.org/abs/2408.17087">arxiv:2408.17087</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EllDistrEst">EllDistrEst</a></code> for the nonparametric estimation of the
elliptical distribution density generator,
<code><a href="#topic+EllDistrSim">EllDistrSim</a></code> for the simulation of elliptical distribution samples.
</p>
<p><code><a href="#topic+estim_tilde_AMSE">estim_tilde_AMSE</a></code> which is used in this function. It estimates
a component of the asymptotic mean-square error (AMSE) of the nonparametric
estimator of the elliptical density generator assuming <code class="reqn">h</code> has been optimally
chosen.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 500
d = 3
X = matrix(rnorm(n * d), ncol = d)
grid = seq(0, 5, by = 0.1)

result = EllDistrEst.adapt(X = X, grid = grid, h = 0.05)
plot(grid, result$g, type = "l")
lines(grid, result$first_step_g, col = "blue")

# Computation of true values
g = exp(-grid/2)/(2*pi)^{3/2}
lines(grid, g, type = "l", col = "red")

plot(grid, result$best_a, type = "l", col = "red")
plot(grid, result$best_h, type = "l", col = "red")

sum((g - result$g)^2, na.rm = TRUE) &lt; sum((g - result$first_step_g)^2, na.rm = TRUE)

</code></pre>

<hr>
<h2 id='EllDistrSim'>Simulation of elliptically symmetric random vectors</h2><span id='topic+EllDistrSim'></span>

<h3>Description</h3>

<p>This function uses the decomposition <code class="reqn">X = \mu + R * A * U</code>
where <code class="reqn">\mu</code> is the mean of <code class="reqn">X</code>, <code class="reqn">R</code> is the random radius,
<code class="reqn">A</code> is the square-root of the covariance matrix of <code class="reqn">X</code>,
and <code class="reqn">U</code> is a uniform random variable of the d-dimensional unit sphere.
Note that <code class="reqn">R</code> is generated using the Metropolis-Hasting algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EllDistrSim(
  n,
  d,
  A = diag(d),
  mu = 0,
  density_R2,
  genR = list(method = "pinv")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EllDistrSim_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="EllDistrSim_+3A_d">d</code></td>
<td>
<p>dimension of <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="EllDistrSim_+3A_a">A</code></td>
<td>
<p>square-root of the covariance matrix of <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="EllDistrSim_+3A_mu">mu</code></td>
<td>
<p>mean of <code class="reqn">X</code>. It should be a vector of size <code>d</code>.</p>
</td></tr>
<tr><td><code id="EllDistrSim_+3A_density_r2">density_R2</code></td>
<td>
<p>density of the random variable <code class="reqn">R^2</code>,
i.e. the density of the <code class="reqn">||X||_2^2</code> if <code class="reqn">\mu=0</code>
and <code class="reqn">A</code> is the identity matrix.
</p>
<p>Note that this function <strong>must</strong> return <code class="reqn">0</code> for negative inputs,
otherwise negative values of <code class="reqn">R^2</code> may be generated.
The simplest way to do this is to add <code style="white-space: pre;">&#8288; * (x &gt; 0)&#8288;</code> at the end of the
return value of the provided <code>density_R2</code> function (see example below).</p>
</td></tr>
<tr><td><code id="EllDistrSim_+3A_genr">genR</code></td>
<td>
<p>additional arguments for the generation of the squared radius.
It must be a list with a component method: </p>

<ul>
<li><p> If <code>genR$method == "pinv"</code>, the radius is generated
using the function <code><a href="Runuran.html#topic+pinv.new">Runuran::pinv.new()</a></code>.
</p>
</li>
<li><p> If <code>genR$method == "MH"</code>,
the generation is done using the Metropolis-Hasting algorithm,
with a <code class="reqn">N(0,1)</code> move at each step.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of dimensions <code>(n,d)</code> of simulated observations.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EllCopSim">EllCopSim</a></code> for the simulation of elliptical copula samples,
<code><a href="#topic+EllCopEst">EllCopEst</a></code> for the estimation of elliptical distributions,
<code><a href="#topic+EllDistrSimCond">EllDistrSimCond</a></code> for the conditional simulation of
elliptically distributed random vectors given some observe components.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample from a 3-dimensional normal distribution
X = EllDistrSim(n = 200, d = 3, density_R2 = function(x){stats::dchisq(x=x,df=3)})
plot(X[,1], X[,2])
X = EllDistrSim(n = 200, d = 3, density_R2 = function(x){stats::dchisq(x=x,df=3)},
                genR = list(method = "MH", niter = 500))
plot(X[,1], X[,2])

# Sample from an Elliptical distribution for which the squared radius
# follows an exponential distribution
cov1 = rbind(c(1,0.5), c(0.5,1))
X = EllDistrSim(n = 1000, d = 2,
                A = chol(cov1), mu = c(2,6),
                density_R2 = function(x){return(exp(-x) * (x &gt; 0))} )

</code></pre>

<hr>
<h2 id='EllDistrSimCond'>Simulation of elliptically symmetric random vectors
conditionally to some observed part.</h2><span id='topic+EllDistrSimCond'></span>

<h3>Description</h3>

<p>Simulation of elliptically symmetric random vectors
conditionally to some observed part.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EllDistrSimCond(
  n,
  xobs,
  d,
  Sigma = diag(d),
  mu = 0,
  density_R2_,
  genR = list(method = "pinv")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EllDistrSimCond_+3A_n">n</code></td>
<td>
<p>number of observations to be simulated
from the conditional distribution.</p>
</td></tr>
<tr><td><code id="EllDistrSimCond_+3A_xobs">xobs</code></td>
<td>
<p>observed value of X that we condition on.
<code>NA</code> represent unknown components of the vectors to be simulated.</p>
</td></tr>
<tr><td><code id="EllDistrSimCond_+3A_d">d</code></td>
<td>
<p>dimension of the random vector</p>
</td></tr>
<tr><td><code id="EllDistrSimCond_+3A_sigma">Sigma</code></td>
<td>
<p>(unconditional) covariance matrix</p>
</td></tr>
<tr><td><code id="EllDistrSimCond_+3A_mu">mu</code></td>
<td>
<p>(unconditional) mean</p>
</td></tr>
<tr><td><code id="EllDistrSimCond_+3A_density_r2_">density_R2_</code></td>
<td>
<p>(unconditional) density of the squared radius.</p>
</td></tr>
<tr><td><code id="EllDistrSimCond_+3A_genr">genR</code></td>
<td>
<p>additional arguments for the generation of the squared radius.
It must be a list with a component method: </p>

<ul>
<li><p> If <code>genR$method == "pinv"</code>, the radius is generated
using the function <code><a href="Runuran.html#topic+pinv.new">Runuran::pinv.new()</a></code>.
</p>
</li>
<li><p> If <code>genR$method == "MH"</code>,
the generation is done using the Metropolis-Hasting algorithm,
with a N(0,1) move at each step.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of size (n,d) of simulated observations.
</p>


<h3>References</h3>

<p>Cambanis, S., Huang, S., &amp; Simons, G. (1981).
On the Theory of Elliptically Contoured Distributions,
Journal of Multivariate Analysis.
(Corollary 5, p.376)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EllDistrSim">EllDistrSim</a></code> for the (unconditional) simulation of
elliptically distributed random vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d = 3
Sigma = rbind(c(1, 0.8, 0.9),
              c(0.8, 1, 0.7),
              c(0.9, 0.7, 1))
mu = c(0, 0, 0)
result = EllDistrSimCond(n = 100, xobs = c(NA, 2, NA), d = d,
  Sigma = Sigma, mu = mu, density_R2_ = function(x){stats::dchisq(x=x,df=3)})
plot(result)

result2 = EllDistrSimCond(n = 1000, xobs = c(1.3, 2, NA), d = d,
  Sigma = Sigma, mu = mu, density_R2_ = function(x){stats::dchisq(x=x,df=3)})
hist(result2)


</code></pre>

<hr>
<h2 id='estim_tilde_AMSE'>Estimate the part of the AMSE of the elliptical density generator that only depends
on the parameter &quot;a&quot; assuming <code class="reqn">h</code> has been optimally chosen</h2><span id='topic+estim_tilde_AMSE'></span>

<h3>Description</h3>

<p>A continuous elliptical distribution has a density of the form
</p>
<p style="text-align: center;"><code class="reqn">f_X(x) = {|\Sigma|}^{-1/2}
g\left( (x-\mu)^\top \, \Sigma^{-1} \, (x-\mu) \right),
</code>
</p>

<p>where <code class="reqn">x \in \mathbb{R}^d</code>,
<code class="reqn">\mu \in \mathbb{R}^d</code> is the mean,
<code class="reqn">\Sigma</code> is a <code class="reqn">d \times d</code> positive-definite matrix
and a function <code class="reqn">g: \mathbb{R}_+ \rightarrow \mathbb{R}_+</code>, called the
density generator of <code class="reqn">X</code>.
The goal is to estimate <code class="reqn">g</code> at some point <code class="reqn">\xi</code>, by
</p>
<p style="text-align: center;"><code class="reqn">
\widehat{g}_{n,h,a}(\xi)
:= \dfrac{\xi^{\frac{-d+2}{2}} \psi_a'(\xi)}{n h s_d}
\sum_{i=1}^n
  K\left( \dfrac{ \psi_a(\xi) - \psi_a(\xi_i) }{h} \right)
+ K\left( \dfrac{ \psi_a(\xi) + \psi_a(\xi_i) }{h} \right),
</code>
</p>

<p>where
<code class="reqn">s_d := \pi^{d/2} / \Gamma(d/2)</code>,
<code class="reqn">\Gamma</code> is the Gamma function,
<code class="reqn">h</code> and <code class="reqn">a</code> are tuning parameters (respectively the bandwidth and a
parameter controlling the bias at <code class="reqn">\xi = 0</code>),
<code class="reqn">\psi_a(\xi) := -a + (a^{d/2} + \xi^{d/2})^{2/d},</code>
<code class="reqn">\xi \in \mathbb{R}</code>, <code class="reqn">K</code> is a kernel function and
<code class="reqn">\xi_i := (X_i - \mu)^\top \, \Sigma^{-1} \, (X_i - \mu),
</code>
for a sample <code class="reqn">X_1, \dots, X_n</code>.
Thanks to Proposition 2.2 in (Ryan and Derumigny, 2024), the asymptotic
mean square error of <code class="reqn">\widehat{g}_{n,h,a}(\xi)</code> can be decomposed into
a product of a constant (that depends on the true <code class="reqn">g</code>) and a term that
depends on <code class="reqn">g</code> and <code class="reqn">a</code>. This function computes this term. It can be
useful to find out the best value of the parameter <code class="reqn">a</code> to be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estim_tilde_AMSE(
  X,
  mu = 0,
  Sigma_m1 = diag(NCOL(X)),
  grid,
  h,
  Kernel = "gaussian",
  a = 1,
  mpfr = FALSE,
  precBits = 100,
  dopb = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estim_tilde_AMSE_+3A_x">X</code></td>
<td>
<p>a matrix of size <code class="reqn">n \times d</code>, assumed to be <code class="reqn">n</code> i.i.d. observations
(rows) of a <code class="reqn">d</code>-dimensional elliptical distribution.</p>
</td></tr>
<tr><td><code id="estim_tilde_AMSE_+3A_mu">mu</code></td>
<td>
<p>mean of X. This can be the true value or an estimate. It must be
a vector of dimension <code class="reqn">d</code>.</p>
</td></tr>
<tr><td><code id="estim_tilde_AMSE_+3A_sigma_m1">Sigma_m1</code></td>
<td>
<p>inverse of the covariance matrix of X.
This can be the true value or an estimate. It must be
a matrix of dimension <code class="reqn">d \times d</code>.</p>
</td></tr>
<tr><td><code id="estim_tilde_AMSE_+3A_grid">grid</code></td>
<td>
<p>grid of values of <code class="reqn">\xi</code> at which we want to estimate the
density generator.</p>
</td></tr>
<tr><td><code id="estim_tilde_AMSE_+3A_h">h</code></td>
<td>
<p>bandwidth of the kernel. Can be either a number or a vector of the
size <code>length(grid)</code>.</p>
</td></tr>
<tr><td><code id="estim_tilde_AMSE_+3A_kernel">Kernel</code></td>
<td>
<p>name of the kernel. Possible choices are
<code>"gaussian"</code>, <code>"epanechnikov"</code>, <code>"triangular"</code>.</p>
</td></tr>
<tr><td><code id="estim_tilde_AMSE_+3A_a">a</code></td>
<td>
<p>tuning parameter to improve the performance at 0.
Can be either a number or a vector of the
size <code>length(grid)</code>. If this is a vector, the code will need to allocate
a matrix of size <code>nrow(X) * length(grid)</code> which can be prohibitive in
some cases.</p>
</td></tr>
<tr><td><code id="estim_tilde_AMSE_+3A_mpfr">mpfr</code></td>
<td>
<p>if <code>mpfr = TRUE</code>, multiple precision floating point is used
via the package <a href="Rmpfr.html#topic+Rmpfr">Rmpfr</a>.
This allows for a higher (numerical) accuracy, at the expense of computing time.
It is recommended to use this option for higher dimensions.</p>
</td></tr>
<tr><td><code id="estim_tilde_AMSE_+3A_precbits">precBits</code></td>
<td>
<p>number of precBits used for floating point precision
(only used if <code>mpfr = TRUE</code>).</p>
</td></tr>
<tr><td><code id="estim_tilde_AMSE_+3A_dopb">dopb</code></td>
<td>
<p>a Boolean value.
If <code>dopb = TRUE</code>, a progress bar is displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the same size as the grid, with the corresponding value
for the <code class="reqn">\widetilde{AMSE}</code>.
</p>


<h3>Author(s)</h3>

<p>Alexis Derumigny, Victor Ryan
</p>


<h3>References</h3>

<p>Ryan, V., &amp; Derumigny, A. (2024).
On the choice of the two tuning parameters for nonparametric estimation of an
elliptical distribution generator
<a href="https://arxiv.org/abs/2408.17087">arxiv:2408.17087</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Comparison between the estimated and true generator of the Gaussian distribution
n = 50000
d = 3
X = matrix(rnorm(n * d), ncol = d)
grid = seq(0, 5, by = 0.1)
a = 1.5

AMSE_est = estim_tilde_AMSE(X = X, grid = grid, a = a, h = 0.09)
plot(grid, abs(AMSE_est), type = "l")

# Computation of true values
g = exp(-grid/2)/(2*pi)^{3/2}
gprime = (-1/2) *exp(-grid/2)/(2*pi)^{3/2}
A = a^(d/2)
psia = -a + (A + grid^(d/2))^(2/d)
psiaprime = grid^(d/2 - 1) * (A + grid^(d/2))^(2/d - 1)
psiasecond = psiaprime * ( (d-2)/2 ) * grid^{-1} * A *
  ( grid^(d/2) + A )^(-1)

rhoprimexi = ((d-2) * grid^((d-4)/2) * psiaprime
  - 2 * grid^((d-2)/2) * psiasecond) / (2 * psiaprime^3) * g +
  grid^((d-2)/2) / (psiaprime^2) * gprime

AMSE = rhoprimexi / psiaprime

lines(grid, abs(AMSE), col = "red")


# Comparison as a function of $a$
n = 50000
d = 3
X = matrix(rnorm(n * d), ncol = d)
grid = 0.1
vec_a = c(0.001, 0.002, 0.005,
0.01, 0.02, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.8, 1, 1.5, 2)

AMSE_est = rep(NA, length = length(vec_a))
for (i in 1:length(vec_a)){
  AMSE_est[i] = estim_tilde_AMSE(X = X, grid = grid, a = vec_a[i], h = 0.09,
                          dopb = FALSE)
}

plot(vec_a, abs(AMSE_est), type = "l", log = "x")

# Computation of true values
a = vec_a

g = exp(-grid/2)/(2*pi)^{3/2}
gprime = (-1/2) *exp(-grid/2)/(2*pi)^{3/2}
A = a^(d/2)
psia = -a + (A + grid^(d/2))^(2/d)
psiaprime = grid^(d/2 - 1) * (A + grid^(d/2))^(2/d - 1)
psiasecond = psiaprime * ( (d-2)/2 ) * grid^{-1} * A *
  ( grid^(d/2) + A )^(-1)

rhoprimexi = ((d-2) * grid^((d-4)/2) * psiaprime
  - 2 * grid^((d-2)/2) * psiasecond) / (2 * psiaprime^3) * g +
  grid^((d-2)/2) / (psiaprime^2) * gprime

AMSE = rhoprimexi / psiaprime

yliminf = min(c(abs(AMSE_est), abs(AMSE)))
ylimsup = max(c(abs(AMSE_est), abs(AMSE)))

plot(vec_a, abs(AMSE_est), type = "l", log = "xy",
     ylim = c(yliminf, ylimsup))
lines(vec_a, abs(AMSE), col = "red")

</code></pre>

<hr>
<h2 id='KTMatrixEst'>Fast estimation of Kendall's tau matrix</h2><span id='topic+KTMatrixEst'></span>

<h3>Description</h3>

<p>Estimate Kendall's tau matrix using averaging estimators. Under
the structural assumption that Kendall's tau matrix is block-structured
with constant values in each off-diagonal block, this function estimates
Kendall's tau matrix &ldquo;fast&rdquo;, in the sense that each interblock
coefficient is estimated in time <code class="reqn">N \cdot n \cdot log(n)</code>,
where <code>N</code> is the amount of pairs that are averaged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KTMatrixEst(dataMatrix, blockStructure = NULL, averaging = "no", N = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KTMatrixEst_+3A_datamatrix">dataMatrix</code></td>
<td>
<p>matrix of size <code>(n,d)</code> containing <code>n</code> observations
of a <code>d</code>-dimensional random vector.</p>
</td></tr>
<tr><td><code id="KTMatrixEst_+3A_blockstructure">blockStructure</code></td>
<td>
<p>list of vectors.
Each vector corresponds to one group of variables
and contains the indexes of the variables that belongs to this group.
<code>blockStructure</code> must be a partition of <code>1:d</code>,
where <code>d</code> is the number of columns in <code>dataMatrix</code>.</p>
</td></tr>
<tr><td><code id="KTMatrixEst_+3A_averaging">averaging</code></td>
<td>
<p>type of averaging used for fast estimation.
Possible choices are </p>

<ul>
<li> <p><code>no</code>: no averaging;
</p>
</li>
<li> <p><code>all</code>: averaging all Kendall's taus in each block.
<code>N</code> is then the number of entries in the block, i.e. the
products of both dimensions.
</p>
</li>
<li> <p><code>diag</code>: averaging along diagonal blocks elements.
<code>N</code> is then the minimum of the block's dimensions.
</p>
</li>
<li> <p><code>row</code>: averaging Kendall's tau along the smallest block side.
<code>N</code> is then the minimum of the block's dimensions.
</p>
</li>
<li> <p><code>random</code>: averaging Kendall's taus along a random sample of <code>N</code> entries
of the given block. These entries are chosen uniformly without replacement.
</p>
</li></ul>
</td></tr>
<tr><td><code id="KTMatrixEst_+3A_n">N</code></td>
<td>
<p>number of entries to average (n the random case.
By default, <code>N</code> is then the minimum of the block's dimensions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with dimensions depending on <code>averaging</code>.
</p>

<ul>
<li><p> If <code>averaging = no</code>,
the function returns a matrix of dimension <code>(n,n)</code>
which estimates the Kendall's tau matrix.
</p>
</li>
<li><p> Else, the function returns a matrix of dimension
<code>(length(blockStructure) , length(blockStructure))</code>
giving the estimates of the Kendall's tau for each block with ones on the diagonal.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Rutger van der Spek, Alexis Derumigny
</p>


<h3>References</h3>

<p>van der Spek, R., &amp; Derumigny, A. (2022).
Fast estimation of Kendall's Tau and conditional Kendall's Tau matrices under structural assumptions.
<a href="https://arxiv.org/abs/2204.03285">arxiv:2204.03285</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Estimating off-diagonal block Kendall's taus
matrixCor = matrix(c(1  , 0.5, 0.3 ,0.3, 0.3,
                     0.5,   1, 0.3, 0.3, 0.3,
                     0.3, 0.3,   1, 0.5, 0.5,
                     0.3, 0.3, 0.5,   1, 0.5,
                     0.3, 0.3, 0.5, 0.5,   1), ncol = 5 , nrow = 5)
dataMatrix = mvtnorm::rmvnorm(n = 100, mean = rep(0, times = 5), sigma = matrixCor)
blockStructure = list(1:2, 3:5)
estKTMatrix = list()
estKTMatrix$all = KTMatrixEst(dataMatrix = dataMatrix,
                              blockStructure = blockStructure,
                              averaging = "all")
estKTMatrix$row = KTMatrixEst(dataMatrix = dataMatrix,
                              blockStructure = blockStructure,
                              averaging = "row")
estKTMatrix$diag = KTMatrixEst(dataMatrix = dataMatrix,
                               blockStructure = blockStructure,
                               averaging = "diag")
estKTMatrix$random = KTMatrixEst(dataMatrix = dataMatrix,
                                 blockStructure = blockStructure,
                                 averaging = "random", N = 2)
InterBlockCor = lapply(estKTMatrix, FUN = function(x) {sin(x[1,2] * pi / 2)})

# Estimation of the correlation between variables of the first group
# and of the second group
print(unlist(InterBlockCor))
# to be compared with the true value: 0.3.

</code></pre>

<hr>
<h2 id='TEllDistrEst'>Estimation of trans-elliptical distributions</h2><span id='topic+TEllDistrEst'></span>

<h3>Description</h3>

<p>This function estimates the parameters of a trans-elliptical
distribution which is a distribution whose copula is
(meta-)elliptical, with arbitrary margins, using the procedure
proposed in (Derumigny &amp; Fermanian, 2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TEllDistrEst(
  X, estimatorCDF = function(x){
    force(x)
    return( function(y){(stats::ecdf(x)(y) - 1/(2*length(x))) }) },
  h, verbose = 1, grid, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TEllDistrEst_+3A_x">X</code></td>
<td>
<p>the matrix of observations of the variables</p>
</td></tr>
<tr><td><code id="TEllDistrEst_+3A_estimatorcdf">estimatorCDF</code></td>
<td>
<p>the way of estimating the marginal cumulative distribution functions.
It should be either a function that takes in parameter a vector of observations
and returns an estimated cdf (i.e. a function) or a list of such functions
to be applied on the data.
In this case, it is required that the length of the list should be the same
as the number of columns of <code>X</code>.
It is required that the functions returned by <code>estimatorCDF</code>
should have values in the <em>open</em> interval <code class="reqn">(0,1)</code>.</p>
</td></tr>
<tr><td><code id="TEllDistrEst_+3A_h">h</code></td>
<td>
<p>bandwidth for the non-parametric estimation of the density generator.</p>
</td></tr>
<tr><td><code id="TEllDistrEst_+3A_verbose">verbose</code></td>
<td>
<p>if 1, prints the progress of the iterations.
If 2, prints the normalizations constants used at each iteration,
as computed by <code><a href="#topic+DensityGenerator.normalize">DensityGenerator.normalize</a></code>.</p>
</td></tr>
<tr><td><code id="TEllDistrEst_+3A_grid">grid</code></td>
<td>
<p>grid of values on which to estimate the density generator</p>
</td></tr>
<tr><td><code id="TEllDistrEst_+3A_...">...</code></td>
<td>
<p>other parameters to be passed to <code><a href="#topic+EllCopEst">EllCopEst</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with three components:
</p>

<ul>
<li> <p><code>listEstCDF</code>: a list of estimated marginal CDF given by <code>estimatorCDF</code>;
</p>
</li>
<li> <p><code>corMatrix</code>: the estimated correlation matrix:
</p>
</li>
<li> <p><code>estEllCopGen</code>: the estimated generator of the meta-elliptical copula.
</p>
</li></ul>



<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2022).
Identifiability and estimation of meta-elliptical copula generators.
Journal of Multivariate Analysis, article 104962.
<a href="https://doi.org/10.1016/j.jmva.2022.104962">doi:10.1016/j.jmva.2022.104962</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cor = matrix(c(1, 0.5, 0.2,
               0.5, 1, 0.8,
               0.2, 0.8, 1), byrow = TRUE, nrow = 3)

grid = seq(0,10,by = 0.01)
g_d = DensityGenerator.normalize(grid, grid_g = exp(-grid), d = 3)
n = 10
# To have a nice estimation, we suggest to use rather n=200
# (around 20s of computation time)
U = EllCopSim(n = n, d = 3, grid = grid, g_d = g_d, A = chol(cor))
X = matrix(nrow = n, ncol = 3)
X[,1] = stats::qnorm(U[,1], mean = 2)
X[,2] = stats::qt(U[,2], df = 5)
X[,3] = stats::qt(U[,3], df = 8)

result = TEllDistrEst(X, h = 0.1, grid = grid)
plot(grid, g_d, type = "l", xlim = c(0,2))
lines(grid, result$estiEllCop$g_d_norm, col = "red")
print(result$corMatrix)

# Adding missing observations
n_NA = 2
X_NA = X
for (i in 1:n_NA){
  X_NA[sample.int(n,1), sample.int(3,1)] = NA
}
resultNA = TEllDistrEst(X_NA, h = 0.1, grid = grid, verbose = 1)
lines(grid, resultNA$estiEllCopGen, col = "blue")


</code></pre>

<hr>
<h2 id='vectorized_Faa_di_Bruno'>Vectorized version of Faa di Bruno formula</h2><span id='topic+vectorized_Faa_di_Bruno'></span>

<h3>Description</h3>

<p>This code implements a vectorized version of the Faa di Bruno formula, relying
internally on the Bell polynomials from the package kStatistics, via the
function <a href="kStatistics.html#topic+eBellPol">kStatistics::eBellPol</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vectorized_Faa_di_Bruno(f, g, x, k, args_f, args_g)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vectorized_Faa_di_Bruno_+3A_f">f</code>, <code id="vectorized_Faa_di_Bruno_+3A_g">g</code></td>
<td>
<p>two functions that take in argument</p>

<ul>
<li><p> a vector <code>x</code> of numeric values
</p>
</li>
<li><p> an integer <code>k</code> which is as to be understood
as the order of the derivative of f
</p>
</li>
<li><p> potentially other parameters (not vectorized)
</p>
</li></ul>
</td></tr>
<tr><td><code id="vectorized_Faa_di_Bruno_+3A_x">x</code></td>
<td>
<p>vector of (one-dimensional) values
at which the <code>k</code>-th order derivatives is to be evaluated.</p>
</td></tr>
<tr><td><code id="vectorized_Faa_di_Bruno_+3A_k">k</code></td>
<td>
<p>the order of the derivative</p>
</td></tr>
<tr><td><code id="vectorized_Faa_di_Bruno_+3A_args_f">args_f</code>, <code id="vectorized_Faa_di_Bruno_+3A_args_g">args_g</code></td>
<td>
<p>the list of additional parameters to be passed on
to <code>f</code> and <code>g</code>. This must be the same for all values of <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of size <code>length(x)</code> for which
the <code>i</code>-th component is
<code class="reqn">(f \circ g)^{(k)} (x[i])</code>
</p>


<h3>Author(s)</h3>

<p>Alexis Derumigny, Victor Ryan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_matrix_alpha">compute_matrix_alpha</a></code> which also uses the Bell polynomials
in a similar way.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- function(x, k, a){
  if (k == 0){ return ( exp(x) + a)
  } else {
    return (exp(x))
  }
}
args_g = list(a = 2)

f &lt;- function(x, k, a){
  if (k == 0){ return ( x^2 + a)
  } else if (k == 1) {
    return ( 2 * x)
  } else if (k == 2) {
    return ( 2 )
  } else {
    return ( 0 )
  }
}
args_f = list(a = 5)

x = 1:5
vectorized_Faa_di_Bruno(f = f, g = g, x = x, k = 1,
  args_f = args_f, args_g = args_g)
# Derivative of ( exp(x) + 2 )^2 + 5
# which explicit expression is:
2 * exp(x) * ( exp(x) + 2 )

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
