<!DOCTYPE html><html lang="en"><head><title>Help for package future</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {future}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.length'><p>Gets the length of an object without dispatching</p></a></li>
<li><a href='#+25conditions+25'><p>Control whether standard output should be captured or not</p></a></li>
<li><a href='#+25globals+25'><p>Specify globals and packages for a future assignment</p></a></li>
<li><a href='#+25label+25'><p>Specify label for a future assignment</p></a></li>
<li><a href='#+25lazy+25'><p>Control lazy / eager evaluation for a future assignment</p></a></li>
<li><a href='#+25plan+25'><p>Use a specific plan for a future assignment</p></a></li>
<li><a href='#+25seed+25'><p>Set random seed for future assignment</p></a></li>
<li><a href='#+25stdout+25'><p>Control whether standard output should be captured or not</p></a></li>
<li><a href='#+25tweak+25'><p>Temporarily tweaks the arguments of the current strategy</p></a></li>
<li><a href='#backtrace'><p>Back trace the expressions evaluated when an error was caught</p></a></li>
<li><a href='#cluster'><p>Create a cluster future whose value will be resolved asynchronously in a parallel process</p></a></li>
<li><a href='#clusterExportSticky'><p>Export globals to the sticky-globals environment of the cluster nodes</p></a></li>
<li><a href='#ClusterFuture-class'><p>A cluster future is a future whose value will be resolved asynchronously in a parallel process</p></a></li>
<li><a href='#ConstantFuture-class'><p>A future with a constant value</p></a></li>
<li><a href='#find_references'><p>Get the first or all references of an <span class="rlang"><b>R</b></span> object</p></a></li>
<li><a href='#future'><p>Create a future</p></a></li>
<li><a href='#Future-class'><p>A future represents a value that will be available at some point in the future</p></a></li>
<li><a href='#future.options'><p>Options used for futures</p></a></li>
<li><a href='#FutureCondition'><p>A condition (message, warning, or error) that occurred while orchestrating a future</p></a></li>
<li><a href='#FutureGlobals'><p>A representation of a set of globals used with futures</p></a></li>
<li><a href='#futureOf'><p>Get the future of a future variable</p></a></li>
<li><a href='#FutureResult'><p>Results from resolving a future</p></a></li>
<li><a href='#futures'><p>Get all futures in a container</p></a></li>
<li><a href='#futureSessionInfo'><p>Get future-specific session information and validate current backend</p></a></li>
<li><a href='#getExpression'><p>Inject code for the next type of future to use for nested futures</p></a></li>
<li><a href='#getGlobalsAndPackages'><p>Retrieves global variables of an expression and their associated packages</p></a></li>
<li><a href='#mandelbrot'><p>Mandelbrot convergence counts</p></a></li>
<li><a href='#multicore'><p>Create a multicore future whose value will be resolved asynchronously in a forked parallel process</p></a></li>
<li><a href='#MulticoreFuture-class'><p>A multicore future is a future whose value will be resolved asynchronously in a parallel process</p></a></li>
<li><a href='#MultiprocessFuture-class'><p>A multiprocess future is a future whose value will be resolved asynchronously in a parallel process</p></a></li>
<li><a href='#multisession'><p>Create a multisession future whose value will be resolved asynchronously in a parallel <span class="rlang"><b>R</b></span> session</p></a></li>
<li><a href='#nbrOfWorkers'><p>Get the number of workers available</p></a></li>
<li><a href='#nullcon'><p>Creates a connection to the system null device</p></a></li>
<li><a href='#plan'><p>Plan how to resolve a future</p></a></li>
<li><a href='#re-exports'><p>Functions Moved to 'parallelly'</p></a></li>
<li><a href='#readImmediateConditions'><p>Writes and Reads 'immediateCondition' RDS Files</p></a></li>
<li><a href='#requestCore'><p>Request a core for multicore processing</p></a></li>
<li><a href='#resetWorkers'><p>Free up active background workers</p></a></li>
<li><a href='#resolve'><p>Resolve one or more futures synchronously</p></a></li>
<li><a href='#resolved'><p>Check whether a future is resolved or not</p></a></li>
<li><a href='#result.Future'><p>Get the results of a resolved future</p></a></li>
<li><a href='#run.Future'><p>Run a future</p></a></li>
<li><a href='#save_rds'><p>Robustly Saves an Object to RDS File Atomically</p></a></li>
<li><a href='#sequential'><p>Create a sequential future whose value will be in the current <span class="rlang"><b>R</b></span> session</p></a></li>
<li><a href='#sessionDetails'><p>Outputs details on the current <span class="rlang"><b>R</b></span> session</p></a></li>
<li><a href='#signalConditions'><p>Signals Captured Conditions</p></a></li>
<li><a href='#sticky_globals'><p>Place a sticky-globals environment immediately after the global environment</p></a></li>
<li><a href='#tweak'><p>Tweak a future function by adjusting its default arguments</p></a></li>
<li><a href='#UniprocessFuture-class'><p>An uniprocess future is a future whose value will be resolved synchronously in the current process</p></a></li>
<li><a href='#usedCores'><p>Get number of cores currently used</p></a></li>
<li><a href='#value'><p>The value of a future or the values of all elements in a container</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.34.0</td>
</tr>
<tr>
<td>Title:</td>
<td>Unified Parallel and Distributed Processing in R for Everyone</td>
</tr>
<tr>
<td>Imports:</td>
<td>digest, globals (&ge; 0.16.1), listenv (&ge; 0.8.0), parallel,
parallelly (&ge; 1.38.0), utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>methods, RhpcBLASctl, R.rsp, markdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Description:</td>
<td>The purpose of this package is to provide a lightweight and
    unified Future API for sequential and parallel processing of R
    expression via futures.  The simplest way to evaluate an expression
    in parallel is to use 'x %&lt;-% { expression }' with 'plan(multisession)'.
    This package implements sequential, multicore, multisession, and
    cluster futures.  With these, R expressions can be evaluated on the
    local machine, in parallel a set of local machines, or distributed
    on a mix of local and remote machines.
    Extensions to this package implement additional backends for
    processing futures via compute cluster schedulers, etc.
    Because of its unified API, there is no need to modify any code in order
    switch from sequential on the local machine to, say, distributed
    processing on a remote compute cluster.
    Another strength of this package is that global variables and functions
    are automatically identified and exported as needed, making it
    straightforward to tweak existing code to make use of futures.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL (&ge; 2.1)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>TRUE</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://future.futureverse.org">https://future.futureverse.org</a>,
<a href="https://github.com/HenrikBengtsson/future">https://github.com/HenrikBengtsson/future</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/HenrikBengtsson/future/issues">https://github.com/HenrikBengtsson/future/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-29 15:02:12 UTC; henrik</td>
</tr>
<tr>
<td>Author:</td>
<td>Henrik Bengtsson <a href="https://orcid.org/0000-0002-7579-5165"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Henrik Bengtsson &lt;henrikb@braju.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-29 16:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='.length'>Gets the length of an object without dispatching</h2><span id='topic+.length'></span>

<h3>Description</h3>

<p>Gets the length of an object without dispatching
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.length(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".length_+3A_x">x</code></td>
<td>
<p>Any <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns <code>length(unclass(x))</code>, but tries to avoid
calling <code>unclass(x)</code> unless necessary.
</p>


<h3>Value</h3>

<p>A non-negative integer.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+.subset">.subset</a>()</code> and <code><a href="base.html#topic+.subset2">.subset2</a>()</code>.
</p>

<hr>
<h2 id='+25conditions+25'>Control whether standard output should be captured or not</h2><span id='topic++25conditions+25'></span>

<h3>Description</h3>

<p>Control whether standard output should be captured or not
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fassignment %conditions% capture
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25conditions+2B25_+3A_fassignment">fassignment</code></td>
<td>
<p>The future assignment, e.g.
<code>x %&lt;-% { expr }</code>.</p>
</td></tr>
<tr><td><code id="+2B25conditions+2B25_+3A_capture">capture</code></td>
<td>
<p>If TRUE, the standard output will be captured, otherwise not.</p>
</td></tr>
</table>

<hr>
<h2 id='+25globals+25'>Specify globals and packages for a future assignment</h2><span id='topic++25globals+25'></span><span id='topic++25packages+25'></span>

<h3>Description</h3>

<p>Specify globals and packages for a future assignment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fassignment %globals% globals
fassignment %packages% packages
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25globals+2B25_+3A_fassignment">fassignment</code></td>
<td>
<p>The future assignment, e.g.
<code>x %&lt;-% { expr }</code>.</p>
</td></tr>
<tr><td><code id="+2B25globals+2B25_+3A_globals">globals</code></td>
<td>
<p>(optional) a logical, a character vector, or a named list
to control how globals are handled.
For details, see section 'Globals used by future expressions'
in the help for <code><a href="#topic+future">future()</a></code>.</p>
</td></tr>
<tr><td><code id="+2B25globals+2B25_+3A_packages">packages</code></td>
<td>
<p>(optional) a character vector specifying packages
to be attached in the <span class="rlang"><b>R</b></span> environment evaluating the future.</p>
</td></tr>
</table>

<hr>
<h2 id='+25label+25'>Specify label for a future assignment</h2><span id='topic++25label+25'></span>

<h3>Description</h3>

<p>Specify label for a future assignment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fassignment %label% label
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25label+2B25_+3A_fassignment">fassignment</code></td>
<td>
<p>The future assignment, e.g.
<code>x %&lt;-% { expr }</code>.</p>
</td></tr>
<tr><td><code id="+2B25label+2B25_+3A_label">label</code></td>
<td>
<p>An optional character string label attached to the future.</p>
</td></tr>
</table>

<hr>
<h2 id='+25lazy+25'>Control lazy / eager evaluation for a future assignment</h2><span id='topic++25lazy+25'></span>

<h3>Description</h3>

<p>Control lazy / eager evaluation for a future assignment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fassignment %lazy% lazy
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25lazy+2B25_+3A_fassignment">fassignment</code></td>
<td>
<p>The future assignment, e.g.
<code>x %&lt;-% { expr }</code>.</p>
</td></tr>
<tr><td><code id="+2B25lazy+2B25_+3A_lazy">lazy</code></td>
<td>
<p>If FALSE (default), the future is resolved
eagerly (starting immediately), otherwise not.</p>
</td></tr>
</table>

<hr>
<h2 id='+25plan+25'>Use a specific plan for a future assignment</h2><span id='topic++25plan+25'></span>

<h3>Description</h3>

<p>Use a specific plan for a future assignment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fassignment %plan% strategy
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25plan+2B25_+3A_fassignment">fassignment</code></td>
<td>
<p>The future assignment, e.g.
<code>x %&lt;-% { expr }</code>.</p>
</td></tr>
<tr><td><code id="+2B25plan+2B25_+3A_strategy">strategy</code></td>
<td>
<p>The mechanism for how the future should be
resolved. See <code><a href="#topic+plan">plan()</a></code> for further details.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The <code><a href="#topic+plan">plan()</a></code> function sets the default plan for all futures.
</p>

<hr>
<h2 id='+25seed+25'>Set random seed for future assignment</h2><span id='topic++25seed+25'></span>

<h3>Description</h3>

<p>Set random seed for future assignment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fassignment %seed% seed
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25seed+2B25_+3A_fassignment">fassignment</code></td>
<td>
<p>The future assignment, e.g.
<code>x %&lt;-% { expr }</code>.</p>
</td></tr>
<tr><td><code id="+2B25seed+2B25_+3A_seed">seed</code></td>
<td>
<p>(optional) If TRUE, the random seed, that is, the state of the
random number generator (RNG) will be set such that statistically sound
random numbers are produced (also during parallelization).
If FALSE (default), it is assumed that the future expression does neither
need nor use random numbers generation.
To use a fixed random seed, specify a L'Ecuyer-CMRG seed (seven integer)
or a regular RNG seed (a single integer).  If the latter, then a
L'Ecuyer-CMRG seed will be automatically created based on the given seed.
Furthermore, if FALSE, then the future will be monitored to make sure it
does not use random numbers.  If it does and depending on the value of
option <code><a href="#topic+future.options">future.rng.onMisuse</a></code>, the check is
ignored, an informative warning, or error will be produced.
If <code>seed</code> is NULL, then the effect is as with <code>seed = FALSE</code>
but without the RNG check being performed.</p>
</td></tr>
</table>

<hr>
<h2 id='+25stdout+25'>Control whether standard output should be captured or not</h2><span id='topic++25stdout+25'></span>

<h3>Description</h3>

<p>Control whether standard output should be captured or not
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fassignment %stdout% capture
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25stdout+2B25_+3A_fassignment">fassignment</code></td>
<td>
<p>The future assignment, e.g.
<code>x %&lt;-% { expr }</code>.</p>
</td></tr>
<tr><td><code id="+2B25stdout+2B25_+3A_capture">capture</code></td>
<td>
<p>If TRUE, the standard output will be captured, otherwise not.</p>
</td></tr>
</table>

<hr>
<h2 id='+25tweak+25'>Temporarily tweaks the arguments of the current strategy</h2><span id='topic++25tweak+25'></span>

<h3>Description</h3>

<p>Temporarily tweaks the arguments of the current strategy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fassignment %tweak% tweaks
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25tweak+2B25_+3A_fassignment">fassignment</code></td>
<td>
<p>The future assignment, e.g.
<code>x %&lt;-% { expr }</code>.</p>
</td></tr>
<tr><td><code id="+2B25tweak+2B25_+3A_tweaks">tweaks</code></td>
<td>
<p>A named list (or vector) with arguments that
should be changed relative to the current strategy.</p>
</td></tr>
</table>

<hr>
<h2 id='backtrace'>Back trace the expressions evaluated when an error was caught</h2><span id='topic+backtrace'></span>

<h3>Description</h3>

<p>Back trace the expressions evaluated when an error was caught
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backtrace(future, envir = parent.frame(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="backtrace_+3A_future">future</code></td>
<td>
<p>A future with a caught error.</p>
</td></tr>
<tr><td><code id="backtrace_+3A_envir">envir</code></td>
<td>
<p>the environment where to locate the future.</p>
</td></tr>
<tr><td><code id="backtrace_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the future's call stack that led up to the error.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_log &lt;- function(x) log(x)
foo &lt;- function(...) my_log(...)

f &lt;- future({ foo("a") })
res &lt;- tryCatch({
  v &lt;- value(f)
}, error = function(ex) {
  t &lt;- backtrace(f)
  print(t)
})


</code></pre>

<hr>
<h2 id='cluster'>Create a cluster future whose value will be resolved asynchronously in a parallel process</h2><span id='topic+cluster'></span>

<h3>Description</h3>

<p>A cluster future is a future that uses cluster evaluation,
which means that its <em>value is computed and resolved in
parallel in another process</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster(
  ...,
  persistent = FALSE,
  workers = availableWorkers(),
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster_+3A_...">...</code></td>
<td>
<p>Additional named elements passed to <code><a href="#topic+ClusterFuture">ClusterFuture()</a></code>.</p>
</td></tr>
<tr><td><code id="cluster_+3A_persistent">persistent</code></td>
<td>
<p>If FALSE, the evaluation environment is cleared
from objects prior to the evaluation of the future.</p>
</td></tr>
<tr><td><code id="cluster_+3A_workers">workers</code></td>
<td>
<p>A <code><a href="parallel.html#topic+makeCluster">cluster</a></code> object,
a character vector of host names, a positive numeric scalar,
or a function.
If a character vector or a numeric scalar, a <code>cluster</code> object
is created using <code><a href="parallelly.html#topic+makeClusterPSOCK">makeClusterPSOCK</a>(workers)</code>.
If a function, it is called without arguments <em>when the future
is created</em> and its value is used to configure the workers.
The function should return any of the above types.</p>
</td></tr>
<tr><td><code id="cluster_+3A_envir">envir</code></td>
<td>
<p>The <a href="base.html#topic+environment">environment</a> from where global objects should be
identified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is <em>not</em> meant to be called directly.  Instead, the
typical usages are:
</p>
<div class="sourceCode r"><pre># Evaluate futures via a single background R process on the local machine
plan(cluster, workers = 1)

# Evaluate futures via two background R processes on the local machine
plan(cluster, workers = 2)

# Evaluate futures via a single R process on another machine on on the
# local area network (LAN)
plan(cluster, workers = "raspberry-pi")

# Evaluate futures via a single R process running on a remote machine
plan(cluster, workers = "pi.example.org")

# Evaluate futures via four R processes, one running on the local machine,
# two running on LAN machine 'n1' and one on a remote machine
plan(cluster, workers = c("localhost", "n1", "n1", "pi.example.org")
</pre></div>


<h3>Value</h3>

<p>A <a href="#topic+ClusterFuture">ClusterFuture</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Use cluster futures
cl &lt;- parallel::makeCluster(2, timeout = 60)
plan(cluster, workers = cl)

## A global variable
a &lt;- 0

## Create future (explicitly)
f &lt;- future({
  b &lt;- 3
  c &lt;- 2
  a * b * c
})

## A cluster future is evaluated in a separate process.
## Regardless, changing the value of a global variable will
## not affect the result of the future.
a &lt;- 7
print(a)

v &lt;- value(f)
print(v)
stopifnot(v == 0)

## CLEANUP
parallel::stopCluster(cl)


</code></pre>

<hr>
<h2 id='clusterExportSticky'>Export globals to the sticky-globals environment of the cluster nodes</h2><span id='topic+clusterExportSticky'></span>

<h3>Description</h3>

<p>Export globals to the sticky-globals environment of the cluster nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterExportSticky(cl, globals)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clusterExportSticky_+3A_cl">cl</code></td>
<td>
<p>(cluster) A cluster object as returned by
<code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
<tr><td><code id="clusterExportSticky_+3A_globals">globals</code></td>
<td>
<p>(list) A named list of sticky globals to be exported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This requires that the <span class="pkg">future</span> package is installed on the cluster
nodes.
</p>


<h3>Value</h3>

<p>(invisible; cluster) The cluster object.
</p>

<hr>
<h2 id='ClusterFuture-class'>A cluster future is a future whose value will be resolved asynchronously in a parallel process</h2><span id='topic+ClusterFuture-class'></span><span id='topic+ClusterFuture'></span><span id='topic+MultisessionFuture'></span><span id='topic+MultisessionFuture-class'></span>

<h3>Description</h3>

<p>A cluster future is a future whose value will be resolved asynchronously in a parallel process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClusterFuture(
  expr = NULL,
  substitute = TRUE,
  envir = parent.frame(),
  persistent = FALSE,
  workers = NULL,
  ...
)

MultisessionFuture(
  expr = NULL,
  substitute = TRUE,
  envir = parent.frame(),
  persistent = FALSE,
  workers = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ClusterFuture-class_+3A_expr">expr</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> <a href="base.html#topic+expression">expression</a>.</p>
</td></tr>
<tr><td><code id="ClusterFuture-class_+3A_substitute">substitute</code></td>
<td>
<p>If TRUE, argument <code>expr</code> is
<code><a href="base.html#topic+substitute">substitute</a>()</code>:ed, otherwise not.</p>
</td></tr>
<tr><td><code id="ClusterFuture-class_+3A_envir">envir</code></td>
<td>
<p>The <a href="base.html#topic+environment">environment</a> from where global objects should be
identified.</p>
</td></tr>
<tr><td><code id="ClusterFuture-class_+3A_persistent">persistent</code></td>
<td>
<p>If FALSE, the evaluation environment is cleared
from objects prior to the evaluation of the future.</p>
</td></tr>
<tr><td><code id="ClusterFuture-class_+3A_workers">workers</code></td>
<td>
<p>A <code><a href="parallel.html#topic+makeCluster">cluster</a></code> object,
a character vector of host names, a positive numeric scalar,
or a function.
If a character vector or a numeric scalar, a <code>cluster</code> object
is created using <code><a href="parallelly.html#topic+makeClusterPSOCK">makeClusterPSOCK</a>(workers)</code>.
If a function, it is called without arguments <em>when the future
is created</em> and its value is used to configure the workers.
The function should return any of the above types.</p>
</td></tr>
<tr><td><code id="ClusterFuture-class_+3A_...">...</code></td>
<td>
<p>Additional named elements passed to <code><a href="#topic+Future">Future()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ClusterFuture()</code> returns an object of class <code>ClusterFuture</code>.
</p>
<p><code>MultisessionFuture()</code> returns an object of class <code>MultisessionFuture</code>,
which inherits from <code>ClusterFuture</code>.
</p>


<h3>Usage</h3>

<p>To use 'cluster' futures, use <code>plan(cluster, ...)</code>, cf. <a href="#topic+cluster">cluster</a>.
</p>
<p>To use 'multisession' futures, use <code>plan(multisession, ...)</code>, cf. <a href="#topic+multisession">multisession</a>.
</p>

<hr>
<h2 id='ConstantFuture-class'>A future with a constant value</h2><span id='topic+ConstantFuture-class'></span><span id='topic+ConstantFuture'></span>

<h3>Description</h3>

<p>A constant future is a future whose expression is a constant
and therefore by definition is already resolved upon creation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConstantFuture(..., globals = TRUE, envir = emptyenv())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ConstantFuture-class_+3A_...">...</code></td>
<td>
<p>Additional named elements of the future.</p>
</td></tr>
<tr><td><code id="ConstantFuture-class_+3A_globals">globals</code></td>
<td>
<p>(optional) a logical, a character vector, or a named list
to control how globals are handled.
For details, see section 'Globals used by future expressions'
in the help for <code><a href="#topic+future">future()</a></code>.</p>
</td></tr>
<tr><td><code id="ConstantFuture-class_+3A_envir">envir</code></td>
<td>
<p>The <a href="base.html#topic+environment">environment</a> from where global objects should be
identified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ConstantFuture()</code> returns an object of class <code>ConstantFuture</code>.
</p>

<hr>
<h2 id='find_references'>Get the first or all references of an <span class="rlang"><b>R</b></span> object</h2><span id='topic+find_references'></span><span id='topic+assert_no_references'></span>

<h3>Description</h3>

<p>Get the first or all references of an <span class="rlang"><b>R</b></span> object
</p>
<p>Assert that there are no references among the identified globals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_references(x, first_only = FALSE)

assert_no_references(
  x,
  action = c("error", "warning", "message", "string"),
  source = c("globals", "value")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_references_+3A_x">x</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> object to be checked.</p>
</td></tr>
<tr><td><code id="find_references_+3A_first_only">first_only</code></td>
<td>
<p>If <code>TRUE</code>, only the first reference is returned,
otherwise all references.</p>
</td></tr>
<tr><td><code id="find_references_+3A_action">action</code></td>
<td>
<p>Type of action to take if a reference is found.</p>
</td></tr>
<tr><td><code id="find_references_+3A_source">source</code></td>
<td>
<p>Is the source of <code>x</code> the globals or the value of the future?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>find_references()</code> returns a list of zero or more references
identified.
</p>
<p>If a reference is detected, an informative error, warning, message,
or a character string is produced, otherwise <code>NULL</code> is returned
invisibly.
</p>

<hr>
<h2 id='future'>Create a future</h2><span id='topic+future'></span><span id='topic+futureCall'></span><span id='topic+futureAssign'></span><span id='topic++25+3C-+25'></span><span id='topic++25-+3E+25'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right;' alt='logo' width='120' />
Creates a future that evaluates an <span class="rlang"><b>R</b></span> expression or
a future that calls an <span class="rlang"><b>R</b></span> function with a set of arguments.
How, when, and where these futures are evaluated can be configured
using <code><a href="#topic+plan">plan()</a></code> such that it is evaluated in parallel on,
for instance, the current machine, on a remote machine, or via a
job queue on a compute cluster.
Importantly, any <span class="rlang"><b>R</b></span> code using futures remains the same regardless
on these settings and there is no need to modify the code when
switching from, say, sequential to parallel processing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>future(
  expr,
  envir = parent.frame(),
  substitute = TRUE,
  lazy = FALSE,
  seed = FALSE,
  globals = TRUE,
  packages = NULL,
  stdout = TRUE,
  conditions = "condition",
  earlySignal = FALSE,
  label = NULL,
  gc = FALSE,
  ...
)

futureAssign(
  x,
  value,
  envir = parent.frame(),
  substitute = TRUE,
  lazy = FALSE,
  seed = FALSE,
  globals = TRUE,
  packages = NULL,
  stdout = TRUE,
  conditions = "condition",
  earlySignal = FALSE,
  label = NULL,
  gc = FALSE,
  ...,
  assign.env = envir
)

x %&lt;-% value

futureCall(
  FUN,
  args = list(),
  envir = parent.frame(),
  lazy = FALSE,
  seed = FALSE,
  globals = TRUE,
  packages = NULL,
  stdout = TRUE,
  conditions = "condition",
  earlySignal = FALSE,
  label = NULL,
  gc = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="future_+3A_expr">expr</code>, <code id="future_+3A_value">value</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> <a href="base.html#topic+expression">expression</a>.</p>
</td></tr>
<tr><td><code id="future_+3A_envir">envir</code></td>
<td>
<p>The <a href="base.html#topic+environment">environment</a> from where global objects should be
identified.</p>
</td></tr>
<tr><td><code id="future_+3A_substitute">substitute</code></td>
<td>
<p>If TRUE, argument <code>expr</code> is
<code><a href="base.html#topic+substitute">substitute</a>()</code>:ed, otherwise not.</p>
</td></tr>
<tr><td><code id="future_+3A_lazy">lazy</code></td>
<td>
<p>If FALSE (default), the future is resolved
eagerly (starting immediately), otherwise not.</p>
</td></tr>
<tr><td><code id="future_+3A_seed">seed</code></td>
<td>
<p>(optional) If TRUE, the random seed, that is, the state of the
random number generator (RNG) will be set such that statistically sound
random numbers are produced (also during parallelization).
If FALSE (default), it is assumed that the future expression does neither
need nor use random numbers generation.
To use a fixed random seed, specify a L'Ecuyer-CMRG seed (seven integer)
or a regular RNG seed (a single integer).  If the latter, then a
L'Ecuyer-CMRG seed will be automatically created based on the given seed.
Furthermore, if FALSE, then the future will be monitored to make sure it
does not use random numbers.  If it does and depending on the value of
option <code><a href="#topic+future.options">future.rng.onMisuse</a></code>, the check is
ignored, an informative warning, or error will be produced.
If <code>seed</code> is NULL, then the effect is as with <code>seed = FALSE</code>
but without the RNG check being performed.</p>
</td></tr>
<tr><td><code id="future_+3A_globals">globals</code></td>
<td>
<p>(optional) a logical, a character vector, or a named list
to control how globals are handled.
For details, see section 'Globals used by future expressions'
in the help for <code><a href="#topic+future">future()</a></code>.</p>
</td></tr>
<tr><td><code id="future_+3A_packages">packages</code></td>
<td>
<p>(optional) a character vector specifying packages
to be attached in the <span class="rlang"><b>R</b></span> environment evaluating the future.</p>
</td></tr>
<tr><td><code id="future_+3A_stdout">stdout</code></td>
<td>
<p>If TRUE (default), then the standard output is captured,
and re-outputted when <code>value()</code> is called.
If FALSE, any output is silenced (by sinking it to the null device as
it is outputted).
Using <code>stdout = structure(TRUE, drop = TRUE)</code> causes the captured
standard output to be dropped from the future object as soon as it has
been relayed. This can help decrease the overall memory consumed by
captured output across futures.
Using <code>stdout = NA</code> (not recommended) avoids intercepting the standard
output; behavior of such unhandled standard output depends on the future</p>
</td></tr>
<tr><td><code id="future_+3A_conditions">conditions</code></td>
<td>
<p>A character string of conditions classes to be captured
and relayed.  The default is to relay all conditions, including messages
and warnings.  To drop all conditions, use <code>conditions = character(0)</code>.
Errors are always relayed.
Attribute <code>exclude</code> can be used to ignore specific classes, e.g.
<code>conditions = structure("condition", exclude = "message")</code> will capture
all <code>condition</code> classes except those that inherits from the <code>message</code> class.
Using <code>conditions = structure(..., drop = TRUE)</code> causes any captured
conditions to be dropped from the future object as soon as it has
been relayed, e.g. by <code>value(f)</code>. This can help decrease the overall
memory consumed by captured conditions across futures.
Using <code>conditions = NULL</code> (not recommended) avoids intercepting conditions,
except from errors; behavior of such unhandled conditions depends on the
future backend and the environment from which R runs.</p>
</td></tr>
<tr><td><code id="future_+3A_earlysignal">earlySignal</code></td>
<td>
<p>Specified whether conditions should be signaled as soon
as possible or not.</p>
</td></tr>
<tr><td><code id="future_+3A_label">label</code></td>
<td>
<p>An optional character string label attached to the future.</p>
</td></tr>
<tr><td><code id="future_+3A_gc">gc</code></td>
<td>
<p>If TRUE, the garbage collector run (in the process that
evaluated the future) only after the value of the future is collected.
Exactly when the values are collected may depend on various factors such
as number of free workers and whether <code>earlySignal</code> is TRUE (more
frequently) or FALSE (less frequently).
<em>Some types of futures ignore this argument.</em></p>
</td></tr>
<tr><td><code id="future_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+Future">Future()</a></code>.</p>
</td></tr>
<tr><td><code id="future_+3A_x">x</code></td>
<td>
<p>the name of a future variable, which will hold the value
of the future expression (as a promise).</p>
</td></tr>
<tr><td><code id="future_+3A_assign.env">assign.env</code></td>
<td>
<p>The <a href="base.html#topic+environment">environment</a> to which the variable
should be assigned.</p>
</td></tr>
<tr><td><code id="future_+3A_fun">FUN</code></td>
<td>
<p>A <a href="base.html#topic+function">function</a> to be evaluated.</p>
</td></tr>
<tr><td><code id="future_+3A_args">args</code></td>
<td>
<p>A <a href="base.html#topic+list">list</a> of arguments passed to function <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The state of a future is either unresolved or resolved.
The value of a future can be retrieved using <code>v &lt;- <a href="#topic+value">value</a>(f)</code>.
Querying the value of a non-resolved future will <em>block</em> the call
until the future is resolved.
It is possible to check whether a future is resolved or not
without blocking by using <code><a href="#topic+resolved">resolved</a>(f)</code>.
</p>
<p>For a future created via a future assignment
(<code>x %&lt;-% value</code> or <code>futureAssign("x", value)</code>), the value
is bound to a promise, which when queried will internally call
<code><a href="#topic+value">value()</a></code>  on the future and which will then be resolved
into a regular variable bound to that value.  For example, with future
assignment <code>x %&lt;-% value</code>, the first time variable <code>x</code> is
queried the call blocks if (and only if) the future is not yet resolved.
As soon as it is resolved, and any succeeding queries, querying <code>x</code>
will immediately give the value.
</p>
<p>The future assignment construct <code>x %&lt;-% value</code> is not a formal
assignment per se, but a binary infix operator on objects <code>x</code>
and expression <code>value</code>.  However, by using non-standard evaluation,
this constructs can emulate an assignment operator similar to
<code>x &lt;- value</code>. Due to <span class="rlang"><b>R</b></span>'s precedence rules of operators,
future expressions often need to be explicitly bracketed, e.g.
<code>x %&lt;-% { a + b }</code>.
</p>
<p>The <code>futureCall()</code> function works analogously to
<code><a href="base.html#topic+do.call">do.call</a>()</code>, which calls a function with a set of
arguments.  The difference is that <code>do.call()</code> returns the value of
the call whereas <code>futureCall()</code> returns a future.
</p>


<h3>Value</h3>

<p><code>f &lt;- future(expr)</code> creates a <a href="#topic+Future">Future</a> <code>f</code> that evaluates expression <code>expr</code>, the value of the future is retrieved using <code>v &lt;- value(f)</code>.
</p>
<p><code>x %&lt;-% value</code> (a future assignment) and
<code>futureAssign("x", value)</code> create a <a href="#topic+Future">Future</a> that evaluates
expression <code>expr</code> and binds its value (as a
<a href="base.html#topic+delayedAssign">promise</a>) to
a variable <code>x</code>.  The value of the future is automatically retrieved
when the assigned variable (promise) is queried.
The future itself is returned invisibly, e.g.
<code>f &lt;- futureAssign("x", expr)</code> and <code>f &lt;- (x %&lt;-% expr)</code>.
Alternatively, the future of a future variable <code>x</code> can be retrieved
without blocking using <code>f &lt;- <a href="#topic+futureOf">futureOf</a>(x)</code>.
Both the future and the variable (promise) are assigned to environment
<code>assign.env</code> where the name of the future is <code style="white-space: pre;">&#8288;.future_&lt;name&gt;&#8288;</code>.
</p>
<p><code>f &lt;- futureCall(FUN, args)</code> creates a <a href="#topic+Future">Future</a> <code>f</code> that calls function <code>FUN</code> with arguments <code>args</code>, where the value of the future is retrieved using <code>x &lt;- value(f)</code>.
</p>


<h3>Eager or lazy evaluation</h3>

<p>By default, a future is resolved using <em>eager</em> evaluation
(<code>lazy = FALSE</code>).  This means that the expression starts to
be evaluated as soon as the future is created.
</p>
<p>As an alternative, the future can be resolved using <em>lazy</em>
evaluation (<code>lazy = TRUE</code>).  This means that the expression
will only be evaluated when the value of the future is requested.
<em>Note that this means that the expression may not be evaluated
at all - it is guaranteed to be evaluated if the value is requested</em>.
</p>
<p>For future assignments, lazy evaluation can be controlled via the
<code style="white-space: pre;">&#8288;%lazy%&#8288;</code> operator, e.g. <code>x %&lt;-% { expr } %lazy% TRUE</code>.
</p>


<h3>Globals used by future expressions</h3>

<p>Global objects (short <em>globals</em>) are objects (e.g. variables and
functions) that are needed in order for the future expression to be
evaluated while not being local objects that are defined by the future
expression. For example, in
</p>
<pre>
  a &lt;- 42
  f &lt;- future({ b &lt;- 2; a * b })
</pre>
<p>variable <code>a</code> is a global of future assignment <code>f</code> whereas
<code>b</code> is a local variable.
In order for the future to be resolved successfully (and correctly),
all globals need to be gathered when the future is created such that
they are available whenever and wherever the future is resolved.
</p>
<p>The default behavior (<code>globals = TRUE</code>),
is that globals are automatically identified and gathered.
More precisely, globals are identified via code inspection of the
future expression <code>expr</code> and their values are retrieved with
environment <code>envir</code> as the starting point (basically via
<code>get(global, envir = envir, inherits = TRUE)</code>).
<em>In most cases, such automatic collection of globals is sufficient
and less tedious and error prone than if they are manually specified</em>.
</p>
<p>However, for full control, it is also possible to explicitly specify
exactly which the globals are by providing their names as a character
vector.
In the above example, we could use
</p>
<pre>
  a &lt;- 42
  f &lt;- future({ b &lt;- 2; a * b }, globals = "a")
</pre>
<p>Yet another alternative is to explicitly specify also their values
using a named list as in
</p>
<pre>
  a &lt;- 42
  f &lt;- future({ b &lt;- 2; a * b }, globals = list(a = a))
</pre>
<p>or
</p>
<pre>
  f &lt;- future({ b &lt;- 2; a * b }, globals = list(a = 42))
</pre>
<p>Specifying globals explicitly avoids the overhead added from
automatically identifying the globals and gathering their values.
Furthermore, if we know that the future expression does not make use
of any global variables, we can disable the automatic search for
globals by using
</p>
<pre>
  f &lt;- future({ a &lt;- 42; b &lt;- 2; a * b }, globals = FALSE)
</pre>
<p>Future expressions often make use of functions from one or more packages.
As long as these functions are part of the set of globals, the future
package will make sure that those packages are attached when the future
is resolved.  Because there is no need for such globals to be frozen
or exported, the future package will not export them, which reduces
the amount of transferred objects.
For example, in
</p>
<pre>
  x &lt;- rnorm(1000)
  f &lt;- future({ median(x) })
</pre>
<p>variable <code>x</code> and <code>median()</code> are globals, but only <code>x</code>
is exported whereas <code>median()</code>, which is part of the <span class="pkg">stats</span>
package, is not exported.  Instead it is made sure that the <span class="pkg">stats</span>
package is on the search path when the future expression is evaluated.
Effectively, the above becomes
</p>
<pre>
  x &lt;- rnorm(1000)
  f &lt;- future({
    library("stats")
    median(x)
  })
</pre>
<p>To manually specify this, one can either do
</p>
<pre>
  x &lt;- rnorm(1000)
  f &lt;- future({
    median(x)
  }, globals = list(x = x, median = stats::median)
</pre>
<p>or
</p>
<pre>
  x &lt;- rnorm(1000)
  f &lt;- future({
    library("stats")
    median(x)
  }, globals = list(x = x))
</pre>
<p>Both are effectively the same.
</p>
<p>Although rarely needed, a combination of automatic identification and manual
specification of globals is supported via attributes <code>add</code> (to add
false negatives) and <code>ignore</code> (to ignore false positives) on value
<code>TRUE</code>.  For example, with
<code>globals = structure(TRUE, ignore = "b", add = "a")</code> any globals
automatically identified except <code>b</code> will be used in addition to
global <code>a</code>.
</p>
<p>When using future assignments, globals can be specified analogously
using the <code><a href="#topic++25globals+25">%globals%</a></code> operator, e.g.
</p>
<pre>
  x &lt;- rnorm(1000)
  y %&lt;-% { median(x) } %globals% list(x = x, median = stats::median)
</pre>


<h3>Author(s)</h3>

<p>The future logo was designed by Dan LaBar and tweaked by Henrik Bengtsson.
</p>


<h3>See Also</h3>

<p>How, when and where futures are resolved is given by the
<em>future strategy</em>, which can be set by the end user using the
<code><a href="#topic+plan">plan()</a></code> function.  The future strategy must not be
set by the developer, e.g. it must not be called within a package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Evaluate futures in parallel
plan(multisession)

## Data
x &lt;- rnorm(100)
y &lt;- 2 * x + 0.2 + rnorm(100)
w &lt;- 1 + x ^ 2


## EXAMPLE: Regular assignments (evaluated sequentially)
fitA &lt;- lm(y ~ x, weights = w)      ## with offset
fitB &lt;- lm(y ~ x - 1, weights = w)  ## without offset
fitC &lt;- {
  w &lt;- 1 + abs(x)  ## Different weights
  lm(y ~ x, weights = w)
}
print(fitA)
print(fitB)
print(fitC)


## EXAMPLE: Future assignments (evaluated in parallel)
fitA %&lt;-% lm(y ~ x, weights = w)      ## with offset
fitB %&lt;-% lm(y ~ x - 1, weights = w)  ## without offset
fitC %&lt;-% {
  w &lt;- 1 + abs(x)
  lm(y ~ x, weights = w)
}
print(fitA)
print(fitB)
print(fitC)


## EXAMPLE: Explicitly create futures (evaluated in parallel)
## and retrieve their values
fA &lt;- future( lm(y ~ x, weights = w) )
fB &lt;- future( lm(y ~ x - 1, weights = w) )
fC &lt;- future({
  w &lt;- 1 + abs(x)
  lm(y ~ x, weights = w)
})
fitA &lt;- value(fA)
fitB &lt;- value(fB)
fitC &lt;- value(fC)
print(fitA)
print(fitB)
print(fitC)


## EXAMPLE: futureCall() and do.call()
x &lt;- 1:100
y0 &lt;- do.call(sum, args = list(x))
print(y0)

f1 &lt;- futureCall(sum, args = list(x))
y1 &lt;- value(f1)
print(y1)
</code></pre>

<hr>
<h2 id='Future-class'>A future represents a value that will be available at some point in the future</h2><span id='topic+Future-class'></span><span id='topic+Future'></span>

<h3>Description</h3>

<p>A <em>future</em> is an abstraction for a <em>value</em> that may
available at some point in the future.  A future can either be
<code>unresolved</code> or <code>resolved</code>, a state which can be checked
with <code><a href="#topic+resolved">resolved()</a></code>.  As long as it is <em>unresolved</em>, the
value is not available.  As soon as it is <em>resolved</em>, the value
is available via <code><a href="#topic+value">value</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Future(
  expr = NULL,
  envir = parent.frame(),
  substitute = TRUE,
  stdout = TRUE,
  conditions = "condition",
  globals = list(),
  packages = NULL,
  seed = FALSE,
  lazy = FALSE,
  gc = FALSE,
  earlySignal = FALSE,
  label = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Future-class_+3A_expr">expr</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> <a href="base.html#topic+expression">expression</a>.</p>
</td></tr>
<tr><td><code id="Future-class_+3A_envir">envir</code></td>
<td>
<p>The <a href="base.html#topic+environment">environment</a> from where global objects should be
identified.</p>
</td></tr>
<tr><td><code id="Future-class_+3A_substitute">substitute</code></td>
<td>
<p>If TRUE, argument <code>expr</code> is
<code><a href="base.html#topic+substitute">substitute</a>()</code>:ed, otherwise not.</p>
</td></tr>
<tr><td><code id="Future-class_+3A_stdout">stdout</code></td>
<td>
<p>If TRUE (default), then the standard output is captured,
and re-outputted when <code>value()</code> is called.
If FALSE, any output is silenced (by sinking it to the null device as
it is outputted).
Using <code>stdout = structure(TRUE, drop = TRUE)</code> causes the captured
standard output to be dropped from the future object as soon as it has
been relayed. This can help decrease the overall memory consumed by
captured output across futures.
Using <code>stdout = NA</code> (not recommended) avoids intercepting the standard
output; behavior of such unhandled standard output depends on the future</p>
</td></tr>
<tr><td><code id="Future-class_+3A_conditions">conditions</code></td>
<td>
<p>A character string of conditions classes to be captured
and relayed.  The default is to relay all conditions, including messages
and warnings.  To drop all conditions, use <code>conditions = character(0)</code>.
Errors are always relayed.
Attribute <code>exclude</code> can be used to ignore specific classes, e.g.
<code>conditions = structure("condition", exclude = "message")</code> will capture
all <code>condition</code> classes except those that inherits from the <code>message</code> class.
Using <code>conditions = structure(..., drop = TRUE)</code> causes any captured
conditions to be dropped from the future object as soon as it has
been relayed, e.g. by <code>value(f)</code>. This can help decrease the overall
memory consumed by captured conditions across futures.
Using <code>conditions = NULL</code> (not recommended) avoids intercepting conditions,
except from errors; behavior of such unhandled conditions depends on the
future backend and the environment from which R runs.</p>
</td></tr>
<tr><td><code id="Future-class_+3A_globals">globals</code></td>
<td>
<p>(optional) a logical, a character vector, or a named list
to control how globals are handled.
For details, see section 'Globals used by future expressions'
in the help for <code><a href="#topic+future">future()</a></code>.</p>
</td></tr>
<tr><td><code id="Future-class_+3A_packages">packages</code></td>
<td>
<p>(optional) a character vector specifying packages
to be attached in the <span class="rlang"><b>R</b></span> environment evaluating the future.</p>
</td></tr>
<tr><td><code id="Future-class_+3A_seed">seed</code></td>
<td>
<p>(optional) If TRUE, the random seed, that is, the state of the
random number generator (RNG) will be set such that statistically sound
random numbers are produced (also during parallelization).
If FALSE (default), it is assumed that the future expression does neither
need nor use random numbers generation.
To use a fixed random seed, specify a L'Ecuyer-CMRG seed (seven integer)
or a regular RNG seed (a single integer).  If the latter, then a
L'Ecuyer-CMRG seed will be automatically created based on the given seed.
Furthermore, if FALSE, then the future will be monitored to make sure it
does not use random numbers.  If it does and depending on the value of
option <code><a href="#topic+future.options">future.rng.onMisuse</a></code>, the check is
ignored, an informative warning, or error will be produced.
If <code>seed</code> is NULL, then the effect is as with <code>seed = FALSE</code>
but without the RNG check being performed.</p>
</td></tr>
<tr><td><code id="Future-class_+3A_lazy">lazy</code></td>
<td>
<p>If FALSE (default), the future is resolved
eagerly (starting immediately), otherwise not.</p>
</td></tr>
<tr><td><code id="Future-class_+3A_gc">gc</code></td>
<td>
<p>If TRUE, the garbage collector run (in the process that
evaluated the future) only after the value of the future is collected.
Exactly when the values are collected may depend on various factors such
as number of free workers and whether <code>earlySignal</code> is TRUE (more
frequently) or FALSE (less frequently).
<em>Some types of futures ignore this argument.</em></p>
</td></tr>
<tr><td><code id="Future-class_+3A_earlysignal">earlySignal</code></td>
<td>
<p>Specified whether conditions should be signaled as soon
as possible or not.</p>
</td></tr>
<tr><td><code id="Future-class_+3A_label">label</code></td>
<td>
<p>An optional character string label attached to the future.</p>
</td></tr>
<tr><td><code id="Future-class_+3A_...">...</code></td>
<td>
<p>Additional named elements of the future.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Future object is itself an <a href="base.html#topic+environment">environment</a>.
</p>


<h3>Value</h3>

<p><code>Future()</code> returns an object of class <code>Future</code>.
</p>


<h3>See Also</h3>

<p>One function that creates a Future is <code><a href="#topic+future">future()</a></code>.
It returns a Future that evaluates an <span class="rlang"><b>R</b></span> expression in the future.
An alternative approach is to use the <code><a href="#topic++25+3C-+25">%&lt;-%</a></code> infix
assignment operator, which creates a future from the
right-hand-side (RHS) <span class="rlang"><b>R</b></span> expression and assigns its future value
to a variable as a <em><a href="base.html#topic+delayedAssign">promise</a></em>.
</p>

<hr>
<h2 id='future.options'>Options used for futures</h2><span id='topic+future.options'></span><span id='topic+future.cmdargs'></span><span id='topic+.future.R'></span><span id='topic+future.startup.script'></span><span id='topic+R_FUTURE_STARTUP_SCRIPT'></span><span id='topic+future.debug'></span><span id='topic+R_FUTURE_DEBUG'></span><span id='topic+future.demo.mandelbrot.region'></span><span id='topic+R_FUTURE_DEMO_MANDELBROT_REGION'></span><span id='topic+future.demo.mandelbrot.nrow'></span><span id='topic+R_FUTURE_DEMO_MANDELBROT_NROW'></span><span id='topic+future.fork.multithreading.enable'></span><span id='topic+R_FUTURE_FORK_MULTITHREADING_ENABLE'></span><span id='topic+future.globals.maxSize'></span><span id='topic+R_FUTURE_GLOBALS_MAXSIZE'></span><span id='topic+future.globals.method'></span><span id='topic+R_FUTURE_GLOBALS_METHOD'></span><span id='topic+future.globals.onMissing'></span><span id='topic+R_FUTURE_GLOBALS_ONMISSING'></span><span id='topic+future.globals.resolve'></span><span id='topic+R_FUTURE_GLOBALS_RESOLVE'></span><span id='topic+future.globals.onReference'></span><span id='topic+R_FUTURE_GLOBALS_ONREFERENCE'></span><span id='topic+future.plan'></span><span id='topic+R_FUTURE_PLAN'></span><span id='topic+future.onFutureCondition.keepFuture'></span><span id='topic+R_FUTURE_ONFUTURECONDITION_KEEPFUTURE'></span><span id='topic+future.resolve.recursive'></span><span id='topic+R_FUTURE_RESOLVE_RECURSIVE'></span><span id='topic+future.globalenv.onMisuse'></span><span id='topic+R_FUTURE_GLOBALENV_ONMISUSE'></span><span id='topic+future.rng.onMisuse'></span><span id='topic+R_FUTURE_RNG_ONMISUSE'></span><span id='topic+future.wait.alpha'></span><span id='topic+R_FUTURE_WAIT_ALPHA'></span><span id='topic+future.wait.interval'></span><span id='topic+R_FUTURE_WAIT_INTERVAL'></span><span id='topic+future.wait.timeout'></span><span id='topic+R_FUTURE_WAIT_TIMEOUT'></span><span id='topic+R_FUTURE_RESOLVED_TIMEOUT'></span><span id='topic+future.output.windows.reencode'></span><span id='topic+R_FUTURE_OUTPUT_WINDOWS_REENCODE'></span><span id='topic+future.journal'></span><span id='topic+R_FUTURE_JOURNAL'></span><span id='topic+R_FUTURE_GLOBALS_OBJECTSIZE_METHOD'></span><span id='topic+future.globals.objectSize.method'></span>

<h3>Description</h3>

<p>Below are the <span class="rlang"><b>R</b></span> options and environment variables that are used by the
<span class="pkg">future</span> package and packages enhancing it.<br />
<br />
<em>WARNING: Note that the names and the default values of these options may
change in future versions of the package.  Please use with care until
further notice.</em>
</p>


<h3>Packages must not change future options</h3>

<p>Just like for other R options, as a package developer you must <em>not</em> change
any of the below <code style="white-space: pre;">&#8288;future.*&#8288;</code> options.  Only the end-user should set these.
If you find yourself having to tweak one of the options, make sure to
undo your changes immediately afterward.  For example, if you want to
bump up the <code>future.globals.maxSize</code> limit when creating a future,
use something like the following inside your function:
</p>
<div class="sourceCode r"><pre>oopts &lt;- options(future.globals.maxSize = 1.0 * 1e9)  ## 1.0 GB
on.exit(options(oopts))
f &lt;- future({ expr })  ## Launch a future with large objects
</pre></div>


<h3>Settings moved to the 'parallelly' package</h3>

<p>Several functions have been moved to the <span class="pkg">parallelly</span> package:
</p>

<ul>
<li> <p><code><a href="parallelly.html#topic+availableCores">parallelly::availableCores()</a></code>
</p>
</li>
<li> <p><code><a href="parallelly.html#topic+availableWorkers">parallelly::availableWorkers()</a></code>
</p>
</li>
<li> <p><code><a href="parallelly.html#topic+makeClusterMPI">parallelly::makeClusterMPI()</a></code>
</p>
</li>
<li> <p><code><a href="parallelly.html#topic+makeClusterPSOCK">parallelly::makeClusterPSOCK()</a></code>
</p>
</li>
<li> <p><code><a href="parallelly.html#topic+makeClusterPSOCK">parallelly::makeNodePSOCK()</a></code>
</p>
</li>
<li> <p><code><a href="parallelly.html#topic+supportsMulticore">parallelly::supportsMulticore()</a></code>
</p>
</li></ul>

<p>The options and environment variables controlling those have been adjusted
accordingly to have different prefixes.
For example, option <span class="option">future.fork.enable</span> has been renamed to
<span class="option">parallelly.fork.enable</span> and the corresponding environment variable
<span class="env">R_FUTURE_FORK_ENABLE</span> has been renamed to
<span class="env">R_PARALLELLY_FORK_ENABLE</span>.
For backward compatibility reasons, the <span class="pkg">parallelly</span> package will
support both versions for a long foreseeable time.
See the <a href="parallelly.html#topic+parallelly.options">parallelly::parallelly.options</a> page for the settings.
</p>


<h3>Options for controlling futures</h3>


<dl>
<dt><span class="option">future.plan</span>:</dt><dd><p>(character string or future function) Default future strategy plan used unless otherwise specified via <code><a href="#topic+plan">plan()</a></code>. This will also be the future plan set when calling <code>plan("default")</code>.  If not specified, this option may be set when the <span class="pkg">future</span> package is <em>loaded</em> if command-line option <code>--parallel=ncores</code> (short <code style="white-space: pre;">&#8288;-p ncores&#8288;</code>) is specified; if <code>ncores &gt; 1</code>, then option <span class="option">future.plan</span> is set to <code>multisession</code> otherwise <code>sequential</code> (in addition to option <span class="option">mc.cores</span> being set to <code>ncores</code>, if <code>ncores &gt;= 1</code>). (Default: <code>sequential</code>)</p>
</dd>
<dt><span class="option">future.globals.maxSize</span>:</dt><dd><p>(numeric) Maximum allowed total size (in bytes) of global variables identified. Used to prevent too large exports. If set of <code>+Inf</code>, then the check for large globals is skipped. (Default: <code>500 * 1024 ^ 2</code> = 500 MiB)</p>
</dd>
<dt><span class="option">future.globals.onReference</span>: (<em>beta feature - may change</em>)</dt><dd><p>(character string) Controls whether the identified globals should be scanned for so called <em>references</em> (e.g. external pointers and connections) or not.  It is unlikely that another <span class="rlang"><b>R</b></span> process (&quot;worker&quot;) can use a global that uses a internal reference of the master <span class="rlang"><b>R</b></span> process&mdash;we call such objects <em>non-exportable globals</em>.
If this option is <code>"error"</code>, an informative error message is produced if a non-exportable global is detected.
If <code>"warning"</code>, a warning is produced, but the processing will continue; it is likely that the future will be resolved with a run-time error unless processed in the master <span class="rlang"><b>R</b></span> process (e.g. <code>plan(sequential)</code> and <code>plan(multicore)</code>).
If <code>"ignore"</code>, no scan is performed.
(Default: <code>"ignore"</code> but may change)
</p>
</dd>
<dt><span class="option">future.resolve.recursive</span>:</dt><dd><p>(integer) An integer specifying the maximum recursive depth to which futures should be resolved. If negative, nothing is resolved.  If <code>0</code>, only the future itself is resolved.  If <code>1</code>, the future and any of its elements that are futures are resolved, and so on. If <code>+Inf</code>, infinite search depth is used. (Default: <code>0</code>)</p>
</dd>
<dt><span class="option">future.rng.onMisuse</span>: (<em>beta feature - may change</em>)</dt><dd><p>(character string) If random numbers are used in futures, then parallel (L'Ecuyer-CMRG) RNG should be used in order to get statistical sound RNGs. The defaults in the future framework assume that <em>no</em> random number generation (RNG) is taken place in the future expression because L'Ecuyer-CMRG RNGs come with an unnecessary overhead if not needed.  To protect against mistakes, the future framework attempts to detect when random numbers are used despite L'Ecuyer-CMRG RNGs are not in place.  If this is detected, and <code>future.rng.onMisuse = "error"</code>, then an informative error message is produced.  If <code>"warning"</code>, then a warning message is produced.  If <code>"ignore"</code>, no check is performed. (Default: <code>"warning"</code>)</p>
</dd>
<dt><span class="option">future.globalenv.onMisuse</span>: (<em>beta feature - may change</em>)</dt><dd><p>(character string) Assigning variables to the global environment for the purpose of using the variable at a later time makes no sense with futures, because the next future may be evaluated in different R process.  To protect against mistakes, the future framework attempts to detect when variables are added to the global environment.  If this is detected, and <code>future.globalenv.onMisuse = "error"</code>, then an informative error message is produced.  If <code>"warning"</code>, then a warning message is produced.  If <code>"ignore"</code>, no check is performed. (Default: <code>"ignore"</code>)</p>
</dd>
<dt><span class="option">future.onFutureCondition.keepFuture</span>:</dt><dd><p>(logical) If <code>TRUE</code>, a <code>FutureCondition</code> keeps a copy of the <code>Future</code> object that triggered the condition. If <code>FALSE</code>, it is dropped. (Default: <code>TRUE</code>)</p>
</dd>
<dt><span class="option">future.wait.timeout</span>:</dt><dd><p>(numeric) Maximum waiting time (in seconds) for a free worker before a timeout error is generated. (Default: <code>30 * 24 * 60 * 60</code> (= 30 days))</p>
</dd>
<dt><span class="option">future.wait.interval</span>:</dt><dd><p>(numeric) Initial interval (in
seconds) between polls. This controls the polling frequency for finding
an available worker when all workers are currently busy. It also controls
the polling frequency of <code>resolve()</code>. (Default: <code>0.01</code> = 0.01 seconds)</p>
</dd>
<dt><span class="option">future.wait.alpha</span>:</dt><dd><p>(numeric) Positive scale factor used to increase the interval after each poll. (Default: <code>1.01</code>)</p>
</dd>
</dl>



<h3>Options for debugging futures</h3>


<dl>
<dt><span class="option">future.debug</span>:</dt><dd><p>(logical) If <code>TRUE</code>, extensive debug messages are generated. (Default: <code>FALSE</code>)</p>
</dd>
</dl>



<h3>Options for controlling package startup</h3>


<dl>
<dt><span class="option">future.startup.script</span>:</dt><dd><p>(character vector or a logical) Specifies zero of more future startup scripts to be sourced when the <span class="pkg">future</span> package is <em>attached</em>. It is only the first existing script that is sourced. If none of the specified files exist, nothing is sourced&mdash;there will be neither a warning nor an error.
If this option is not specified, environment variable <span class="env">R_FUTURE_STARTUP_SCRIPT</span> is considered, where multiple scripts may be separated by either a colon (<code>:</code>) or a semicolon (<code style="white-space: pre;">&#8288;;&#8288;</code>). If neither is set, or either is set to <code>TRUE</code>, the default is to look for a &lsquo;<span class="file">.future.R</span>&rsquo; script in the current directory and then in the user's home directory.  To disable future startup scripts, set the option or the environment variable to <code>FALSE</code>.  <em>Importantly</em>, this option is <em>always</em> set to <code>FALSE</code> if the <span class="pkg">future</span> package is loaded as part of a future expression being evaluated, e.g. in a background process. In order words, they are sourced in the main <span class="rlang"><b>R</b></span> process but not in future processes. (Default: <code>TRUE</code> in main <span class="rlang"><b>R</b></span> process and <code>FALSE</code> in future processes / during future evaluation)</p>
</dd>
<dt><span class="option">future.cmdargs</span>:</dt><dd><p>(character vector) Overrides <code><a href="base.html#topic+commandArgs">commandArgs</a>()</code> when the <span class="pkg">future</span> package is <em>loaded</em>.</p>
</dd>
</dl>



<h3>Options for configuring low-level system behaviors</h3>


<dl>
<dt><span class="option">future.fork.multithreading.enable</span> (<em>beta feature - may change</em>):</dt><dd><p>(logical) Enable or disable <em>multi-threading</em> while using <em>forked</em> parallel processing.  If <code>FALSE</code>, different multi-thread library settings are overridden such that they run in single-thread mode. Specifically, multi-threading will be disabled for OpenMP (which requires the <span class="pkg">RhpcBLASctl</span> package) and for <strong>RcppParallel</strong>. If <code>TRUE</code>, or not set (the default), multi-threading is allowed.  Parallelization via multi-threaded processing (done in native code by some packages and external libraries) while at the same time using forked (aka &quot;multicore&quot;) parallel processing is known to unstable.  Note that this is not only true when using <code>plan(multicore)</code> but also when using, for instance, <code><a href="parallel.html#topic+mclapply">mclapply</a>()</code> of the <span class="pkg">parallel</span> package. (Default: not set)</p>
</dd>
<dt><span class="option">future.output.windows.reencode</span>:</dt><dd><p>(logical) Enable or disable re-encoding of UTF-8 symbols that were incorrectly encoded while captured.  In R (&lt; 4.2.0) and on older versions of MS Windows, R cannot capture UTF-8 symbols as-is when they are captured from the standard output.  For examples, a UTF-8 check mark symbol (<code>"\u2713"</code>) would be relayed as <code>"&lt;U+2713&gt;"</code> (a string with eight ASCII characters).  Setting this option to <code>TRUE</code> will cause <code>value()</code> to attempt to recover the intended UTF-8 symbols from <code style="white-space: pre;">&#8288;&lt;U+nnnn&gt;&#8288;</code> string components, if, and only if, the string was captured by a future resolved on MS Windows. (Default: <code>TRUE</code>)</p>
</dd>
</dl>

<p>See also <a href="parallelly.html#topic+parallelly.options">parallelly::parallelly.options</a>.
</p>


<h3>Options for demos</h3>


<dl>
<dt><span class="option">future.demo.mandelbrot.region</span>:</dt><dd><p>(integer) Either a named list of <code><a href="#topic+mandelbrot">mandelbrot()</a></code> arguments or an integer in {1, 2, 3} specifying a predefined Mandelbrot region. (Default: <code>1L</code>)</p>
</dd>
<dt><span class="option">future.demo.mandelbrot.nrow</span>:</dt><dd><p>(integer) Number of rows and columns of tiles. (Default: <code>3L</code>)</p>
</dd>
</dl>



<h3>Deprecated or for internal prototyping</h3>

<p>The following options exists only for troubleshooting purposes and must not
be used in production.  If used, there is a risk that the results are
non-reproducible if processed elsewhere.  To lower the risk of them being
used by mistake, they are marked as deprecated and will produce warnings
if set.
</p>

<dl>
<dt><span class="option">future.globals.onMissing</span>:</dt><dd><p>(character string) Action to take when non-existing global variables (&quot;globals&quot; or &quot;unknowns&quot;) are identified when the future is created.  If <code>"error"</code>, an error is generated immediately.  If <code>"ignore"</code>, no action is taken and an attempt to evaluate the future expression will be made.  The latter is useful when there is a risk for false-positive globals being identified, e.g. when future expression contains non-standard evaluation (NSE).  (Default: <code>"ignore"</code>)</p>
</dd>
<dt><span class="option">future.globals.method</span>:</dt><dd><p>(character string) Method used to identify globals. For details, see <code><a href="globals.html#topic+globalsOf">globalsOf</a>()</code>. (Default: <code>"ordered"</code>)</p>
</dd>
<dt><span class="option">future.globals.resolve</span>:</dt><dd><p>(logical) If <code>TRUE</code>, globals that are <code><a href="#topic+Future">Future</a></code> objects (typically created as <em>explicit</em> futures) will be resolved and have their values (using <code>value()</code>) collected.  Because searching for unresolved futures among globals (including their content) can be expensive, the default is not to do it and instead leave it to the run-time checks that assert proper ownership when resolving futures and collecting their values. (Default: <code>FALSE</code>)</p>
</dd>
</dl>



<h3>Environment variables that set R options</h3>

<p>All of the above <span class="rlang"><b>R</b></span> <span class="option">future.*</span> options can be set by corresponding
environment variable <span class="env">R_FUTURE_*</span> <em>when the <span class="pkg">future</span> package is
loaded</em>. This means that those environment variables must be set before
the <span class="pkg">future</span> package is loaded in order to have an effect.
For example, if <code>R_FUTURE_RNG_ONMISUSE="ignore"</code>, then option
<span class="option">future.rng.onMisuse</span> is set to <code>"ignore"</code> (character string).
Similarly, if <code>R_FUTURE_GLOBALS_MAXSIZE="50000000"</code>, then option
<span class="option">future.globals.maxSize</span> is set to <code>50000000</code> (numeric).
</p>


<h3>See Also</h3>

<p>To set <span class="rlang"><b>R</b></span> options or environment variables when <span class="rlang"><b>R</b></span> starts (even before the <span class="pkg">future</span> package is loaded), see the <a href="base.html#topic+Startup">Startup</a> help page.  The <a href="https://cran.r-project.org/package=startup"><span class="pkg">startup</span></a> package provides a friendly mechanism for configurating <span class="rlang"><b>R</b></span>'s startup process.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Allow at most 5 MB globals per futures
options(future.globals.maxSize = 5e6)

# Be strict; catch all RNG mistakes
options(future.rng.onMisuse = "error")


</code></pre>

<hr>
<h2 id='FutureCondition'>A condition (message, warning, or error) that occurred while orchestrating a future</h2><span id='topic+FutureCondition'></span><span id='topic+FutureMessage'></span><span id='topic+FutureWarning'></span><span id='topic+FutureError'></span><span id='topic+RngFutureCondition'></span><span id='topic+RngFutureWarning'></span><span id='topic+RngFutureError'></span><span id='topic+UnexpectedFutureResultError'></span><span id='topic+GlobalEnvFutureCondition'></span><span id='topic+GlobalEnvFutureWarning'></span><span id='topic+GlobalEnvFutureError'></span><span id='topic+FutureJournalCondition'></span>

<h3>Description</h3>

<p>While <em>orchestrating</em> (creating, launching, querying, collection)
futures, unexpected run-time errors (and other types of conditions) may
occur.  Such conditions are coerced to a corresponding FutureCondition
class to help distinguish them from conditions that occur due to the
<em>evaluation</em> of the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FutureCondition(message, call = NULL, uuid = future$uuid, future = NULL)

FutureMessage(message, call = NULL, uuid = future$uuid, future = NULL)

FutureWarning(message, call = NULL, uuid = future$uuid, future = NULL)

FutureError(message, call = NULL, uuid = future$uuid, future = NULL)

RngFutureCondition(
  message = NULL,
  call = NULL,
  uuid = future$uuid,
  future = NULL
)

RngFutureWarning(...)

RngFutureError(...)

UnexpectedFutureResultError(future, hint = NULL)

GlobalEnvFutureCondition(
  message = NULL,
  call = NULL,
  globalenv = globalenv,
  uuid = future$uuid,
  future = NULL
)

GlobalEnvFutureWarning(...)

GlobalEnvFutureError(...)

FutureJournalCondition(
  message,
  journal,
  call = NULL,
  uuid = future$uuid,
  future = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FutureCondition_+3A_message">message</code></td>
<td>
<p>A message condition.</p>
</td></tr>
<tr><td><code id="FutureCondition_+3A_call">call</code></td>
<td>
<p>The call stack that led up to the condition.</p>
</td></tr>
<tr><td><code id="FutureCondition_+3A_uuid">uuid</code></td>
<td>
<p>A universally unique identifier for the future associated with
this FutureCondition.</p>
</td></tr>
<tr><td><code id="FutureCondition_+3A_future">future</code></td>
<td>
<p>The <a href="#topic+Future">Future</a> involved.</p>
</td></tr>
<tr><td><code id="FutureCondition_+3A_hint">hint</code></td>
<td>
<p>(optional) A string with a suggestion on what might be wrong.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class FutureCondition which inherits from class
<a href="base.html#topic+conditions">condition</a> and FutureMessage, FutureWarning,
and FutureError all inherits from FutureCondition.
Moreover, a FutureError inherits from <a href="base.html#topic+conditions">error</a>,
a FutureWarning from <a href="base.html#topic+conditions">warning</a>, and
a FutureMessage from <a href="base.html#topic+conditions">message</a>.
</p>

<hr>
<h2 id='FutureGlobals'>A representation of a set of globals used with futures</h2><span id='topic+FutureGlobals'></span><span id='topic+as.FutureGlobals'></span><span id='topic+as.FutureGlobals.FutureGlobals'></span><span id='topic+as.FutureGlobals.Globals'></span><span id='topic+as.FutureGlobals.list'></span><span id='topic++5B.FutureGlobals'></span><span id='topic+c.FutureGlobals'></span><span id='topic+unique.FutureGlobals'></span>

<h3>Description</h3>

<p>A representation of a set of globals used with futures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FutureGlobals(object = list(), resolved = FALSE, total_size = NA_real_, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FutureGlobals_+3A_object">object</code></td>
<td>
<p>A named list.</p>
</td></tr>
<tr><td><code id="FutureGlobals_+3A_resolved">resolved</code></td>
<td>
<p>A logical indicating whether these globals
have been scanned for and resolved futures or not.</p>
</td></tr>
<tr><td><code id="FutureGlobals_+3A_total_size">total_size</code></td>
<td>
<p>The total size of all globals, if known.</p>
</td></tr>
<tr><td><code id="FutureGlobals_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This class extends the <a href="globals.html#topic+Globals">Globals</a> class by adding
attributes <code>resolved</code> and <code>total_size</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>FutureGlobals</code>.
</p>

<hr>
<h2 id='futureOf'>Get the future of a future variable</h2><span id='topic+futureOf'></span>

<h3>Description</h3>

<p>Get the future of a future variable that has been created directly
or indirectly via <code><a href="#topic+future">future()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>futureOf(
  var = NULL,
  envir = parent.frame(),
  mustExist = TRUE,
  default = NA,
  drop = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="futureOf_+3A_var">var</code></td>
<td>
<p>the variable.  If NULL, all futures in the
environment are returned.</p>
</td></tr>
<tr><td><code id="futureOf_+3A_envir">envir</code></td>
<td>
<p>the environment where to search from.</p>
</td></tr>
<tr><td><code id="futureOf_+3A_mustexist">mustExist</code></td>
<td>
<p>If TRUE and the variable does not exists, then
an informative error is thrown, otherwise NA is returned.</p>
</td></tr>
<tr><td><code id="futureOf_+3A_default">default</code></td>
<td>
<p>the default value if future was not found.</p>
</td></tr>
<tr><td><code id="futureOf_+3A_drop">drop</code></td>
<td>
<p>if TRUE and <code>var</code> is NULL, then returned list
only contains futures, otherwise also <code>default</code> values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+Future">Future</a> (or <code>default</code>).
If <code>var</code> is NULL, then a named list of Future:s are returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a %&lt;-% { 1 }

f &lt;- futureOf(a)
print(f)

b %&lt;-% { 2 }

f &lt;- futureOf(b)
print(f)

## All futures
fs &lt;- futureOf()
print(fs)


## Futures part of environment
env &lt;- new.env()
env$c %&lt;-% { 3 }

f &lt;- futureOf(env$c)
print(f)

f2 &lt;- futureOf(c, envir = env)
print(f2)

f3 &lt;- futureOf("c", envir = env)
print(f3)

fs &lt;- futureOf(envir = env)
print(fs)
</code></pre>

<hr>
<h2 id='FutureResult'>Results from resolving a future</h2><span id='topic+FutureResult'></span><span id='topic+as.character.FutureResult'></span><span id='topic+print.FutureResult'></span>

<h3>Description</h3>

<p>Results from resolving a future
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FutureResult(
  value = NULL,
  visible = TRUE,
  stdout = NULL,
  conditions = NULL,
  rng = FALSE,
  ...,
  started = .POSIXct(NA_real_),
  finished = Sys.time(),
  version = "1.8"
)

## S3 method for class 'FutureResult'
as.character(x, ...)

## S3 method for class 'FutureResult'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FutureResult_+3A_value">value</code></td>
<td>
<p>The value of the future expression.
If the expression was not fully resolved (e.g. an error) occurred,
the the value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="FutureResult_+3A_visible">visible</code></td>
<td>
<p>If TRUE, the value was visible, otherwise invisible.</p>
</td></tr>
<tr><td><code id="FutureResult_+3A_conditions">conditions</code></td>
<td>
<p>A list of zero or more list elements each containing
a captured <a href="base.html#topic+conditions">condition</a> and possibly more meta data such as the
call stack and a timestamp.</p>
</td></tr>
<tr><td><code id="FutureResult_+3A_rng">rng</code></td>
<td>
<p>If TRUE, the <code>.Random.seed</code> was updated from resolving the
future, otherwise not.</p>
</td></tr>
<tr><td><code id="FutureResult_+3A_...">...</code></td>
<td>
<p>(optional) Additional named results to be returned.</p>
</td></tr>
<tr><td><code id="FutureResult_+3A_started">started</code>, <code id="FutureResult_+3A_finished">finished</code></td>
<td>
<p><a href="base.html#topic+DateTimeClasses">POSIXct</a> timestamps
when the evaluation of the future expression was started and finished.</p>
</td></tr>
<tr><td><code id="FutureResult_+3A_version">version</code></td>
<td>
<p>The version format of the results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only part of the <em>backend</em> Future API.
This function is <em>not</em> part of the frontend Future API.
</p>


<h3>Value</h3>

<p>An object of class FutureResult.
</p>


<h3>Note to developers</h3>

<p>The FutureResult structure is <em>under development</em> and may change at anytime,
e.g. elements may be renamed or removed.  Because of this, please avoid
accessing the elements directly in code.  Feel free to reach out if you need
to do so in your code.
</p>

<hr>
<h2 id='futures'>Get all futures in a container</h2><span id='topic+futures'></span>

<h3>Description</h3>

<p>Gets all futures in an environment, a list, or a list environment
and returns an object of the same class (and dimensions).
Non-future elements are returned as is.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>futures(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="futures_+3A_x">x</code></td>
<td>
<p>An environment, a list, or a list environment.</p>
</td></tr>
<tr><td><code id="futures_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful for retrieve futures that were created via
future assignments (<code style="white-space: pre;">&#8288;%&lt;-%&#8288;</code>) and therefore stored as promises.
This function turns such promises into standard <code>Future</code>
objects.
</p>


<h3>Value</h3>

<p>An object of same type as <code>x</code> and with the same names
and/or dimensions, if set.
</p>

<hr>
<h2 id='futureSessionInfo'>Get future-specific session information and validate current backend</h2><span id='topic+futureSessionInfo'></span>

<h3>Description</h3>

<p>Get future-specific session information and validate current backend
</p>


<h3>Usage</h3>

<pre><code class='language-R'>futureSessionInfo(test = TRUE, anonymize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="futureSessionInfo_+3A_test">test</code></td>
<td>
<p>If TRUE, one or more futures are created to query workers
and validate their information.</p>
</td></tr>
<tr><td><code id="futureSessionInfo_+3A_anonymize">anonymize</code></td>
<td>
<p>If TRUE, user names and host names are anonymized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plan(multisession, workers = 2)
futureSessionInfo()
plan(sequential)
</code></pre>

<hr>
<h2 id='getExpression'>Inject code for the next type of future to use for nested futures</h2><span id='topic+getExpression'></span><span id='topic+getExpression.Future'></span>

<h3>Description</h3>

<p>Inject code for the next type of future to use for nested futures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getExpression(future, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getExpression_+3A_future">future</code></td>
<td>
<p>Current future.</p>
</td></tr>
<tr><td><code id="getExpression_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no next future strategy is specified, the default is to
use <a href="#topic+sequential">sequential</a> futures.  This conservative approach protects
against spawning off recursive futures by mistake, especially
<a href="#topic+multicore">multicore</a> and <a href="#topic+multisession">multisession</a> ones.
The default will also set <code>options(mc.cores = 1L)</code> (*) so that
no parallel <span class="rlang"><b>R</b></span> processes are spawned off by functions such as
<code>parallel::mclapply()</code> and friends.
</p>
<p>Currently it is not possible to specify what type of nested
futures to be used, meaning the above default will always be
used.
See <a href="https://github.com/HenrikBengtsson/future/issues/37">Issue #37</a>
for plans on adding support for custom nested future types.
</p>
<p>(*) Ideally we would set <code>mc.cores = 0</code> but that will unfortunately
cause <code>mclapply()</code> and friends to generate an error saying
&quot;'mc.cores' must be &gt;= 1&quot;.  Ideally those functions should
fall back to using the non-multicore alternative in this
case, e.g. <code>mclapply(...)</code> =&gt; <code>lapply(...)</code>.
See <a href="https://github.com/HenrikBengtsson/Wishlist-for-R/issues/7">https://github.com/HenrikBengtsson/Wishlist-for-R/issues/7</a>
for a discussion on this.
</p>


<h3>Value</h3>

<p>A future expression with code injected to set what
type of future to use for nested futures, iff any.
</p>

<hr>
<h2 id='getGlobalsAndPackages'>Retrieves global variables of an expression and their associated packages</h2><span id='topic+getGlobalsAndPackages'></span>

<h3>Description</h3>

<p>Retrieves global variables of an expression and their associated packages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGlobalsAndPackages(
  expr,
  envir = parent.frame(),
  tweak = tweakExpression,
  globals = TRUE,
  locals = getOption("future.globals.globalsOf.locals", TRUE),
  resolve = getOption("future.globals.resolve", NULL),
  persistent = FALSE,
  maxSize = getOption("future.globals.maxSize", 500 * 1024^2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getGlobalsAndPackages_+3A_expr">expr</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> expression whose globals should be found.</p>
</td></tr>
<tr><td><code id="getGlobalsAndPackages_+3A_envir">envir</code></td>
<td>
<p>The environment from which globals should be searched.</p>
</td></tr>
<tr><td><code id="getGlobalsAndPackages_+3A_tweak">tweak</code></td>
<td>
<p>(optional) A function that takes an expression and returned a modified one.</p>
</td></tr>
<tr><td><code id="getGlobalsAndPackages_+3A_globals">globals</code></td>
<td>
<p>(optional) a logical, a character vector, a named list, or a <a href="globals.html#topic+Globals">Globals</a> object.  If TRUE, globals are identified by code inspection based on <code>expr</code> and <code>tweak</code> searching from environment <code>envir</code>.  If FALSE, no globals are used.  If a character vector, then globals are identified by lookup based their names <code>globals</code> searching from environment <code>envir</code>.  If a named list or a Globals object, the globals are used as is.</p>
</td></tr>
<tr><td><code id="getGlobalsAndPackages_+3A_locals">locals</code></td>
<td>
<p>Should globals part of any &quot;local&quot; environment of
a function be included or not?</p>
</td></tr>
<tr><td><code id="getGlobalsAndPackages_+3A_resolve">resolve</code></td>
<td>
<p>If TRUE, any future that is a global variables (or part of one) is resolved and replaced by a &quot;constant&quot; future.</p>
</td></tr>
<tr><td><code id="getGlobalsAndPackages_+3A_persistent">persistent</code></td>
<td>
<p>If TRUE, non-existing globals (= identified in expression but not found in memory) are always silently ignored and assumed to be existing in the evaluation environment.  If FALSE, non-existing globals are by default ignore, but may also trigger an informative error if option <span class="option">future.globals.onMissing</span> in <code>"error"</code> (should only be used for troubleshooting).</p>
</td></tr>
<tr><td><code id="getGlobalsAndPackages_+3A_maxsize">maxSize</code></td>
<td>
<p>The maximum allowed total size (in bytes) of globals&mdash;for
the purpose of preventing too large exports / transfers happening by
mistake.  If the total size of the global objects are greater than this
limit, an informative error message is produced. If
<code>maxSize = +Inf</code>, then this assertion is skipped. (Default: 500 MiB).</p>
</td></tr>
<tr><td><code id="getGlobalsAndPackages_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with elements <code>expr</code> (the tweaked expression), <code>globals</code> (a named list of class <a href="#topic+FutureGlobals">FutureGlobals</a>) and <code>packages</code> (a character string).
</p>


<h3>See Also</h3>

<p>Internally, <code><a href="globals.html#topic+globalsOf">globalsOf</a>()</code> is used to identify globals and associated packages from the expression.
</p>

<hr>
<h2 id='mandelbrot'>Mandelbrot convergence counts</h2><span id='topic+mandelbrot'></span><span id='topic+as.raster.Mandelbrot'></span><span id='topic+plot.Mandelbrot'></span><span id='topic+mandelbrot_tiles'></span><span id='topic+mandelbrot.matrix'></span><span id='topic+mandelbrot.numeric'></span>

<h3>Description</h3>

<p>Mandelbrot convergence counts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mandelbrot(...)

## S3 method for class 'matrix'
mandelbrot(Z, maxIter = 200L, tau = 2, ...)

## S3 method for class 'numeric'
mandelbrot(
  xmid = -0.75,
  ymid = 0,
  side = 3,
  resolution = 400L,
  maxIter = 200L,
  tau = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mandelbrot_+3A_z">Z</code></td>
<td>
<p>A complex matrix for which convergence
counts should be calculated.</p>
</td></tr>
<tr><td><code id="mandelbrot_+3A_maxiter">maxIter</code></td>
<td>
<p>Maximum number of iterations per bin.</p>
</td></tr>
<tr><td><code id="mandelbrot_+3A_tau">tau</code></td>
<td>
<p>A threshold; the radius when calling
divergence (Mod(z) &gt; tau).</p>
</td></tr>
<tr><td><code id="mandelbrot_+3A_xmid">xmid</code>, <code id="mandelbrot_+3A_ymid">ymid</code>, <code id="mandelbrot_+3A_side">side</code>, <code id="mandelbrot_+3A_resolution">resolution</code></td>
<td>
<p>Alternative specification of
the complex plane <code>Z</code>, where
<code>mean(Re(Z)) == xmid</code>,
<code>mean(Im(Z)) == ymid</code>,
<code>diff(range(Re(Z))) == side</code>,
<code>diff(range(Im(Z))) == side</code>, and
<code>dim(Z) == c(resolution, resolution)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an integer matrix (of class Mandelbrot) with
non-negative counts.
</p>


<h3>Author(s)</h3>

<p>The internal Mandelbrot algorithm was inspired by and
adopted from similar GPL code of Martin Maechler available
from ftp://stat.ethz.ch/U/maechler/R/ on 2005-02-18 (sic!).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>counts &lt;- mandelbrot(xmid = -0.75, ymid = 0, side = 3)
str(counts)
## Not run: 
plot(counts)

## End(Not run)

## Not run: 
demo("mandelbrot", package = "future", ask = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='multicore'>Create a multicore future whose value will be resolved asynchronously in a forked parallel process</h2><span id='topic+multicore'></span>

<h3>Description</h3>

<p>A multicore future is a future that uses multicore evaluation,
which means that its <em>value is computed and resolved in
parallel in another process</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multicore(
  ...,
  workers = availableCores(constraints = "multicore"),
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multicore_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+Future">Future()</a></code>.</p>
</td></tr>
<tr><td><code id="multicore_+3A_workers">workers</code></td>
<td>
<p>The number of parallel processes to use.
If a function, it is called without arguments <em>when the future
is created</em> and its value is used to configure the workers.</p>
</td></tr>
<tr><td><code id="multicore_+3A_envir">envir</code></td>
<td>
<p>The <a href="base.html#topic+environment">environment</a> from where global objects should be
identified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is <em>not</em> meant to be called directly.  Instead, the
typical usages are:
</p>
<div class="sourceCode r"><pre># Evaluate futures in parallel on the local machine via as many forked
# processes as available to the current R process
plan(multicore)

# Evaluate futures in parallel on the local machine via two forked processes
plan(multicore, workers = 2)
</pre></div>


<h3>Value</h3>

<p>A <a href="#topic+MulticoreFuture">MulticoreFuture</a>.
If <code>workers == 1</code>, then all processing using done in the
current/main <span class="rlang"><b>R</b></span> session and we therefore fall back to using a
sequential future. To override this fallback, use <code>workers = I(1)</code>.
This is also the case whenever multicore processing is not supported,
e.g. on Windows.
</p>


<h3>Support for forked (&quot;multicore&quot;) processing</h3>

<p>Not all operating systems support process forking and thereby not multicore
futures.  For instance, forking is not supported on Microsoft Windows.
Moreover, process forking may break some R environments such as RStudio.
Because of this, the future package disables process forking also in
such cases.  See <code><a href="parallelly.html#topic+supportsMulticore">parallelly::supportsMulticore()</a></code> for details.
Trying to create multicore futures on non-supported systems or when
forking is disabled will result in multicore futures falling back to
becoming <a href="#topic+sequential">sequential</a> futures.  If used in RStudio, there will be an
informative warning:
</p>
<div class="sourceCode r"><pre>&gt; plan(multicore)
Warning message:
In supportsMulticoreAndRStudio(...) :
  [ONE-TIME WARNING] Forked processing ('multicore') is not supported when
running R from RStudio because it is considered unstable. For more details,
how to control forked processing or not, and how to silence this warning in
future R sessions, see ?parallelly::supportsMulticore
</pre></div>


<h3>See Also</h3>

<p>For processing in multiple background <span class="rlang"><b>R</b></span> sessions, see
<a href="#topic+multisession">multisession</a> futures.
</p>
<p>Use <code><a href="parallelly.html#topic+availableCores">parallelly::availableCores()</a></code> to see the total number of
cores that are available for the current <span class="rlang"><b>R</b></span> session.
Use <code><a href="parallelly.html#topic+availableCores">availableCores</a>("multicore") &gt; 1L</code> to check
whether multicore futures are supported or not on the current
system.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use multicore futures
plan(multicore)

## A global variable
a &lt;- 0

## Create future (explicitly)
f &lt;- future({
  b &lt;- 3
  c &lt;- 2
  a * b * c
})

## A multicore future is evaluated in a separate forked
## process.  Changing the value of a global variable
## will not affect the result of the future.
a &lt;- 7
print(a)

v &lt;- value(f)
print(v)
stopifnot(v == 0)
</code></pre>

<hr>
<h2 id='MulticoreFuture-class'>A multicore future is a future whose value will be resolved asynchronously in a parallel process</h2><span id='topic+MulticoreFuture-class'></span><span id='topic+MulticoreFuture'></span>

<h3>Description</h3>

<p>A multicore future is a future whose value will be resolved asynchronously in a parallel process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MulticoreFuture(expr = NULL, substitute = TRUE, envir = parent.frame(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MulticoreFuture-class_+3A_expr">expr</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> <a href="base.html#topic+expression">expression</a>.</p>
</td></tr>
<tr><td><code id="MulticoreFuture-class_+3A_substitute">substitute</code></td>
<td>
<p>If TRUE, argument <code>expr</code> is
<code><a href="base.html#topic+substitute">substitute</a>()</code>:ed, otherwise not.</p>
</td></tr>
<tr><td><code id="MulticoreFuture-class_+3A_envir">envir</code></td>
<td>
<p>The <a href="base.html#topic+environment">environment</a> from where global objects should be
identified.</p>
</td></tr>
<tr><td><code id="MulticoreFuture-class_+3A_...">...</code></td>
<td>
<p>Additional named elements passed to <code><a href="#topic+Future">Future()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>MulticoreFuture()</code> returns an object of class <code>MulticoreFuture</code>.
</p>


<h3>Usage</h3>

<p>To use 'multicore' futures, use <code>plan(multicore, ...)</code>, cf. <a href="#topic+multicore">multicore</a>.
</p>

<hr>
<h2 id='MultiprocessFuture-class'>A multiprocess future is a future whose value will be resolved asynchronously in a parallel process</h2><span id='topic+MultiprocessFuture-class'></span><span id='topic+MultiprocessFuture'></span>

<h3>Description</h3>

<p>A multiprocess future is a future whose value will be resolved asynchronously in a parallel process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MultiprocessFuture(expr = NULL, substitute = TRUE, envir = parent.frame(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MultiprocessFuture-class_+3A_expr">expr</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> <a href="base.html#topic+expression">expression</a>.</p>
</td></tr>
<tr><td><code id="MultiprocessFuture-class_+3A_substitute">substitute</code></td>
<td>
<p>If TRUE, argument <code>expr</code> is
<code><a href="base.html#topic+substitute">substitute</a>()</code>:ed, otherwise not.</p>
</td></tr>
<tr><td><code id="MultiprocessFuture-class_+3A_envir">envir</code></td>
<td>
<p>The <a href="base.html#topic+environment">environment</a> from where global objects should be
identified.</p>
</td></tr>
<tr><td><code id="MultiprocessFuture-class_+3A_...">...</code></td>
<td>
<p>Additional named elements passed to <code><a href="#topic+Future">Future()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>MultiprocessFuture()</code> returns an object of class <code>MultiprocessFuture</code>.
</p>

<hr>
<h2 id='multisession'>Create a multisession future whose value will be resolved asynchronously in a parallel <span class="rlang"><b>R</b></span> session</h2><span id='topic+multisession'></span>

<h3>Description</h3>

<p>A multisession future is a future that uses multisession evaluation,
which means that its <em>value is computed and resolved in
parallel in another <span class="rlang"><b>R</b></span> session</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multisession(
  ...,
  workers = availableCores(),
  lazy = FALSE,
  rscript_libs = .libPaths(),
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multisession_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+Future">Future()</a></code>.</p>
</td></tr>
<tr><td><code id="multisession_+3A_workers">workers</code></td>
<td>
<p>The number of parallel processes to use.
If a function, it is called without arguments <em>when the future
is created</em> and its value is used to configure the workers.</p>
</td></tr>
<tr><td><code id="multisession_+3A_lazy">lazy</code></td>
<td>
<p>If FALSE (default), the future is resolved
eagerly (starting immediately), otherwise not.</p>
</td></tr>
<tr><td><code id="multisession_+3A_rscript_libs">rscript_libs</code></td>
<td>
<p>A character vector of <span class="rlang"><b>R</b></span> package library folders that
the workers should use.  The default is <code>.libPaths()</code> so that multisession
workers inherits the same library path as the main <span class="rlang"><b>R</b></span> session.
To avoid this, use <code>plan(multisession, ..., rscript_libs = NULL)</code>.
<em>Important: Note that the library path is set on the workers when they are
created, i.e. when <code>plan(multisession)</code> is called.  Any changes to
<code>.libPaths()</code> in the main R session after the workers have been created
will have no effect.</em>
This is passed down as-is to <code><a href="parallelly.html#topic+makeClusterPSOCK">parallelly::makeClusterPSOCK()</a></code>.</p>
</td></tr>
<tr><td><code id="multisession_+3A_envir">envir</code></td>
<td>
<p>The <a href="base.html#topic+environment">environment</a> from where global objects should be
identified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is <em>not</em> meant to be called directly.  Instead, the
typical usages are:
</p>
<div class="sourceCode r"><pre># Evaluate futures in parallel on the local machine via as many background
# processes as available to the current R process
plan(multisession)

# Evaluate futures in parallel on the local machine via two background
# processes
plan(multisession, workers = 2)
</pre></div>
<p>The background <span class="rlang"><b>R</b></span> sessions (the &quot;workers&quot;) are created using
<code><a href="#topic+makeClusterPSOCK">makeClusterPSOCK()</a></code>.
</p>
<p>For the total number of
<span class="rlang"><b>R</b></span> sessions available including the current/main <span class="rlang"><b>R</b></span> process, see
<code><a href="parallelly.html#topic+availableCores">parallelly::availableCores()</a></code>.
</p>
<p>A multisession future is a special type of cluster future.
</p>


<h3>Value</h3>

<p>A <a href="#topic+MultisessionFuture">MultisessionFuture</a>.
If <code>workers == 1</code>, then all processing is done in the
current/main <span class="rlang"><b>R</b></span> session and we therefore fall back to using a
lazy future.  To override this fallback, use <code>workers = I(1)</code>.
</p>


<h3>See Also</h3>

<p>For processing in multiple forked <span class="rlang"><b>R</b></span> sessions, see
<a href="#topic+multicore">multicore</a> futures.
</p>
<p>Use <code><a href="parallelly.html#topic+availableCores">parallelly::availableCores()</a></code> to see the total number of
cores that are available for the current <span class="rlang"><b>R</b></span> session.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Use multisession futures
plan(multisession)

## A global variable
a &lt;- 0

## Create future (explicitly)
f &lt;- future({
  b &lt;- 3
  c &lt;- 2
  a * b * c
})

## A multisession future is evaluated in a separate R session.
## Changing the value of a global variable will not affect
## the result of the future.
a &lt;- 7
print(a)

v &lt;- value(f)
print(v)
stopifnot(v == 0)

## Explicitly close multisession workers by switching plan
plan(sequential)

</code></pre>

<hr>
<h2 id='nbrOfWorkers'>Get the number of workers available</h2><span id='topic+nbrOfWorkers'></span><span id='topic+nbrOfFreeWorkers'></span>

<h3>Description</h3>

<p>Get the number of workers available
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbrOfWorkers(evaluator = NULL)

nbrOfFreeWorkers(evaluator = NULL, background = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nbrOfWorkers_+3A_evaluator">evaluator</code></td>
<td>
<p>A future evaluator function.
If NULL (default), the current evaluator as returned
by <code><a href="#topic+plan">plan()</a></code> is used.</p>
</td></tr>
<tr><td><code id="nbrOfWorkers_+3A_background">background</code></td>
<td>
<p>If TRUE, only workers that can process a future in the
background are considered.  If FALSE, also workers running in the main <span class="rlang"><b>R</b></span>
process are considered, e.g. when using the 'sequential' backend.</p>
</td></tr>
<tr><td><code id="nbrOfWorkers_+3A_...">...</code></td>
<td>
<p>Not used; reserved for future use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nbrOfWorkers()</code> returns a positive number in <code class="reqn">{1, 2, 3, ...}</code>, which
for some future backends may also be <code>+Inf</code>.
</p>
<p><code>nbrOfFreeWorkers()</code> returns a non-negative number in
<code class="reqn">{0, 1, 2, 3, ...}</code> which is less than or equal to <code>nbrOfWorkers()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plan(multisession)
nbrOfWorkers()  ## == availableCores()

plan(sequential)
nbrOfWorkers()  ## == 1
</code></pre>

<hr>
<h2 id='nullcon'>Creates a connection to the system null device</h2><span id='topic+nullcon'></span>

<h3>Description</h3>

<p>Creates a connection to the system null device
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nullcon()
</code></pre>


<h3>Value</h3>

<p>Returns a open, binary <code><a href="base.html#topic+connections">base::connection()</a></code>.
</p>

<hr>
<h2 id='plan'>Plan how to resolve a future</h2><span id='topic+plan'></span>

<h3>Description</h3>

<p>This function allows <em>the user</em> to plan the future, more specifically,
it specifies how <code><a href="#topic+future">future()</a></code>:s are resolved,
e.g. sequentially or in parallel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plan(
  strategy = NULL,
  ...,
  substitute = TRUE,
  .skip = FALSE,
  .call = TRUE,
  .cleanup = TRUE,
  .init = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plan_+3A_strategy">strategy</code></td>
<td>
<p>The evaluation function (or name of it) to use
for resolving a future. If <code>NULL</code>, then the current strategy is returned.</p>
</td></tr>
<tr><td><code id="plan_+3A_...">...</code></td>
<td>
<p>Additional arguments overriding the default arguments
of the evaluation function.  Which additional arguments are supported
depends on what evaluation function is used, e.g. several support
argument <code>workers</code> but not all. For details, see the individual
functions of which some are linked to below.</p>
</td></tr>
<tr><td><code id="plan_+3A_substitute">substitute</code></td>
<td>
<p>If <code>TRUE</code>, the <code>strategy</code> expression is
<code>substitute()</code>:d, otherwise not.</p>
</td></tr>
<tr><td><code id="plan_+3A_.skip">.skip</code></td>
<td>
<p>(internal) If <code>TRUE</code>, then attempts to set a strategy
that is the same as what is currently in use, will be skipped.</p>
</td></tr>
<tr><td><code id="plan_+3A_.call">.call</code></td>
<td>
<p>(internal) Used for recording the call to this function.</p>
</td></tr>
<tr><td><code id="plan_+3A_.cleanup">.cleanup</code></td>
<td>
<p>(internal) Used to stop implicitly started clusters.</p>
</td></tr>
<tr><td><code id="plan_+3A_.init">.init</code></td>
<td>
<p>(internal) Used to initiate workers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default strategy is <code><a href="#topic+sequential">sequential</a></code>, but the default can be
configured by option <span class="option">future.plan</span> and, if that is not set,
system environment variable <span class="env">R_FUTURE_PLAN</span>.
To reset the strategy back to the default, use <code>plan("default")</code>.
</p>


<h3>Value</h3>

<p>If a new strategy is chosen, then the previous one is returned
(invisible), otherwise the current one is returned (visibly).
</p>


<h3>Built-in evaluation strategies</h3>

<p>The <span class="pkg">future</span> package provides the following built-in backends:
</p>

<dl>
<dt><code><a href="#topic+sequential">sequential</a></code>:</dt><dd>
<p>Resolves futures sequentially in the current <span class="rlang"><b>R</b></span> process, e.g.
<code>plan(sequential)</code>.
</p>
</dd>
<dt><code><a href="#topic+multisession">multisession</a></code>:</dt><dd>
<p>Resolves futures asynchronously (in parallel) in separate
<span class="rlang"><b>R</b></span> sessions running in the background on the same machine, e.g.
<code>plan(multisession)</code> and <code>plan(multisession, workers = 2)</code>.
</p>
</dd>
<dt><code><a href="#topic+multicore">multicore</a></code>:</dt><dd>
<p>Resolves futures asynchronously (in parallel) in separate
<em>forked</em> <span class="rlang"><b>R</b></span> processes running in the background on
the same machine, e.g.
<code>plan(multicore)</code> and <code>plan(multicore, workers = 2)</code>.
This backend is not supported on Windows.
</p>
</dd>
<dt><code><a href="#topic+cluster">cluster</a></code>:</dt><dd>
<p>Resolves futures asynchronously (in parallel) in separate
<span class="rlang"><b>R</b></span> sessions running typically on one or more machines, e.g.
<code>plan(cluster)</code>, <code>plan(cluster, workers = 2)</code>, and
<code>plan(cluster, workers = c("n1", "n1", "n2", "server.remote.org"))</code>.
</p>
</dd>
</dl>

<p>Other package provide additional evaluation strategies.
For example, the <span class="pkg">future.callr</span> package implements an alternative
to the <code>multisession</code> backend on top of the <span class="pkg">callr</span> package, e.g.
<code>plan(future.callr::callr, workers = 2)</code>.
Another example is the <span class="pkg">future.batchtools</span> package, which implements,
on top of the <span class="pkg">batchtools</span> package, e.g.
<code>plan(future.batchtools::batchtools_slurm)</code>.
These types of futures are resolved via job schedulers, which typically
are available on high-performance compute (HPC) clusters, e.g. LSF,
Slurm, TORQUE/PBS, Sun Grid Engine, and OpenLava.
</p>
<p>To &quot;close&quot; any background workers (e.g. <code>multisession</code>), change
the plan to something different; <code>plan(sequential)</code> is recommended
for this.
</p>


<h3>For package developers</h3>

<p>Please refrain from modifying the future strategy inside your packages /
functions, i.e. do not call <code>plan()</code> in your code. Instead, leave
the control on what backend to use to the end user. This idea is part of
the core philosophy of the future framework&mdash;as a developer you can never
know what future backends the user have access to. Moreover, by not making
any assumptions about what backends are available, your code will also work
automatically with any new backends developed after you wrote your code.
</p>
<p>If you think it is necessary to modify the future strategy within a
function, then make sure to undo the changes when exiting the function.
This can be done using:
</p>
<pre>
  oplan &lt;- plan(new_set_of_strategies)
  on.exit(plan(oplan), add = TRUE)
  [...]
</pre>
<p>This is important because the end-user might have already set the future
strategy elsewhere for other purposes and will most likely not known that
calling your function will break their setup.
<em>Remember, your package and its functions might be used in a greater
context where multiple packages and functions are involved and those might
also rely on the future framework, so it is important to avoid stepping on
others' toes.</em>
</p>


<h3>Using plan() in scripts and vignettes</h3>

<p>When writing scripts or vignettes that use futures, try to place any
call to <code>plan()</code> as far up (i.e. as early on) in the code as possible.
This will help users to quickly identify where the future plan is set up
and allow them to modify it to their computational resources.
Even better is to leave it to the user to set the <code>plan()</code> prior to
<code>source()</code>:ing the script or running the vignette.
If a &lsquo;<span class="file"><a href="#topic+.future.R">.future.R</a></span>&rsquo; exists in the current directory and / or in
the user's home directory, it is sourced when the <span class="pkg">future</span> package is
<em>loaded</em>. Because of this, the &lsquo;<span class="file">.future.R</span>&rsquo; file provides a
convenient place for users to set the <code>plan()</code>.
This behavior can be controlled via an <span class="rlang"><b>R</b></span> option&mdash;see
<a href="#topic+future.options">future options</a> for more details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- b &lt;- c &lt;- NA_real_

# An sequential future
plan(sequential)
f &lt;- future({
  a &lt;- 7
  b &lt;- 3
  c &lt;- 2
  a * b * c
})
y &lt;- value(f)
print(y)
str(list(a = a, b = b, c = c)) ## All NAs


# A sequential future with lazy evaluation
plan(sequential)
f &lt;- future({
  a &lt;- 7
  b &lt;- 3
  c &lt;- 2
  a * b * c
}, lazy = TRUE)
y &lt;- value(f)
print(y)
str(list(a = a, b = b, c = c)) ## All NAs


# A multicore future (specified as a string)
plan("multicore")
f &lt;- future({
  a &lt;- 7
  b &lt;- 3
  c &lt;- 2
  a * b * c
})
y &lt;- value(f)
print(y)
str(list(a = a, b = b, c = c)) ## All NAs

## Multisession futures gives an error on R CMD check on
## Windows (but not Linux or macOS) for unknown reasons.
## The same code works in package tests.


# A multisession future (specified via a string variable)
plan("future::multisession")
f &lt;- future({
  a &lt;- 7
  b &lt;- 3
  c &lt;- 2
  a * b * c
})
y &lt;- value(f)
print(y)
str(list(a = a, b = b, c = c)) ## All NAs




## Explicitly specifying number of workers
## (default is parallelly::availableCores())
plan(multicore, workers = 2)
message("Number of parallel workers: ", nbrOfWorkers())


## Explicitly close multisession workers by switching plan
plan(sequential)
</code></pre>

<hr>
<h2 id='re-exports'>Functions Moved to 'parallelly'</h2><span id='topic+re-exports'></span><span id='topic+as.cluster'></span><span id='topic+autoStopCluster'></span><span id='topic+availableCores'></span><span id='topic+availableWorkers'></span><span id='topic+makeClusterMPI'></span><span id='topic+makeClusterPSOCK'></span><span id='topic+makeNodePSOCK'></span><span id='topic+supportsMulticore'></span>

<h3>Description</h3>

<p>The following function used to be part of <span class="pkg">future</span> but has since
been migrated to <span class="pkg">parallelly</span>.  The migration started with
<span class="pkg">future</span> 1.20.0 (November 2020).  They were moved because they
are also useful outside of the <span class="pkg">future</span> framework.
</p>


<h3>Details</h3>


<ul>
<li> <p><code><a href="parallelly.html#topic+as.cluster">parallelly::as.cluster()</a></code>
</p>
</li>
<li> <p><code><a href="parallelly.html#topic+autoStopCluster">parallelly::autoStopCluster()</a></code>
</p>
</li>
<li> <p><code><a href="parallelly.html#topic+availableCores">parallelly::availableCores()</a></code>
</p>
</li>
<li> <p><code><a href="parallelly.html#topic+availableWorkers">parallelly::availableWorkers()</a></code>
</p>
</li>
<li> <p><code><a href="parallelly.html#topic+makeClusterMPI">parallelly::makeClusterMPI()</a></code>
</p>
</li>
<li> <p><code><a href="parallelly.html#topic+makeClusterPSOCK">parallelly::makeClusterPSOCK()</a></code>
</p>
</li>
<li> <p><code><a href="parallelly.html#topic+makeClusterPSOCK">parallelly::makeNodePSOCK()</a></code>
</p>
</li>
<li> <p><code><a href="parallelly.html#topic+supportsMulticore">parallelly::supportsMulticore()</a></code>
</p>
</li></ul>

<p>For backward-compatible reasons, these functions remain available as
exact copies also from this package (as re-exports).  For example,
</p>
<div class="sourceCode r"><pre>cl &lt;- parallelly::makeClusterPSOCK(2)
</pre></div>
<p>can still be accessed as:
</p>
<div class="sourceCode r"><pre>cl &lt;- future::makeClusterPSOCK(2)
</pre></div>

<hr>
<h2 id='readImmediateConditions'>Writes and Reads 'immediateCondition' RDS Files</h2><span id='topic+readImmediateConditions'></span><span id='topic+saveImmediateCondition'></span>

<h3>Description</h3>

<p>Writes and Reads 'immediateCondition' RDS Files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readImmediateConditions(
  path = immediateConditionsPath(rootPath = rootPath),
  rootPath = tempdir(),
  pattern = "[.]rds$",
  include = getOption("future.relay.immediate", "immediateCondition"),
  signal = FALSE,
  remove = TRUE
)

saveImmediateCondition(
  cond,
  path = immediateConditionsPath(rootPath = rootPath),
  rootPath = tempdir()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readImmediateConditions_+3A_path">path</code></td>
<td>
<p>(character string) The folder where the RDS files are.</p>
</td></tr>
<tr><td><code id="readImmediateConditions_+3A_pattern">pattern</code></td>
<td>
<p>(character string) A regular expression selecting
the RDS files to be read.</p>
</td></tr>
<tr><td><code id="readImmediateConditions_+3A_include">include</code></td>
<td>
<p>(character vector) The class or classes of the objects
to be kept.</p>
</td></tr>
<tr><td><code id="readImmediateConditions_+3A_signal">signal</code></td>
<td>
<p>(logical) If TRUE, the condition read are signaled.</p>
</td></tr>
<tr><td><code id="readImmediateConditions_+3A_remove">remove</code></td>
<td>
<p>(logical) If TRUE, the RDS files used are removed on exit.</p>
</td></tr>
<tr><td><code id="readImmediateConditions_+3A_cond">cond</code></td>
<td>
<p>A condition of class <code>immediateCondition</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>readImmediateConditions()</code> returns a <a href="base.html#topic+list">base::list</a> of
<code>immediateCondition</code> objects.
</p>
<p><code>saveImmediateCondition()</code> returns, invisibly, the pathname of
the RDS written.
</p>

<hr>
<h2 id='requestCore'>Request a core for multicore processing</h2><span id='topic+requestCore'></span>

<h3>Description</h3>

<p>If no cores are available, the current process
blocks until a core is available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>requestCore(
  await,
  workers = availableCores(),
  timeout = getOption("future.wait.timeout", 30 * 24 * 60 * 60),
  delta = getOption("future.wait.interval", 0.01),
  alpha = getOption("future.wait.alpha", 1.01)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="requestCore_+3A_await">await</code></td>
<td>
<p>A function used to try to &quot;collect&quot;
finished multicore subprocesses.</p>
</td></tr>
<tr><td><code id="requestCore_+3A_workers">workers</code></td>
<td>
<p>Total number of workers available.</p>
</td></tr>
<tr><td><code id="requestCore_+3A_timeout">timeout</code></td>
<td>
<p>Maximum waiting time (in seconds) allowed
before a timeout error is generated.</p>
</td></tr>
<tr><td><code id="requestCore_+3A_delta">delta</code></td>
<td>
<p>Then base interval (in seconds) to wait
between each try.</p>
</td></tr>
<tr><td><code id="requestCore_+3A_alpha">alpha</code></td>
<td>
<p>A multiplicative factor used to increase
the wait interval after each try.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible TRUE. If no cores are available after
extensive waiting, then a timeout error is thrown.
</p>

<hr>
<h2 id='resetWorkers'>Free up active background workers</h2><span id='topic+resetWorkers'></span>

<h3>Description</h3>

<p>Free up active background workers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resetWorkers(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resetWorkers_+3A_x">x</code></td>
<td>
<p>A FutureStrategy.</p>
</td></tr>
<tr><td><code id="resetWorkers_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will resolve any active futures that is currently
being evaluated on background workers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>resetWorkers(plan())

</code></pre>

<hr>
<h2 id='resolve'>Resolve one or more futures synchronously</h2><span id='topic+resolve'></span>

<h3>Description</h3>

<p>This function provides an efficient mechanism for waiting for multiple
futures in a container (e.g. list or environment) to be resolved while in
the meanwhile retrieving values of already resolved futures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolve(
  x,
  idxs = NULL,
  recursive = 0,
  result = FALSE,
  stdout = FALSE,
  signal = FALSE,
  force = FALSE,
  sleep = getOption("future.wait.interval", 0.01),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resolve_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+Future">Future</a> to be resolved, or a list, an environment, or a
list environment of futures to be resolved.</p>
</td></tr>
<tr><td><code id="resolve_+3A_idxs">idxs</code></td>
<td>
<p>(optional) integer or logical index specifying the subset of
elements to check.</p>
</td></tr>
<tr><td><code id="resolve_+3A_recursive">recursive</code></td>
<td>
<p>A non-negative number specifying how deep of a recursion
should be done.  If TRUE, an infinite recursion is used.  If FALSE or zero,
no recursion is performed.</p>
</td></tr>
<tr><td><code id="resolve_+3A_result">result</code></td>
<td>
<p>(internal) If TRUE, the results are <em>retrieved</em>, otherwise not.
Note that this only collects the results from the parallel worker, which
can help lower the overall latency if there are multiple concurrent futures.
This does <em>not</em> return the collected results.</p>
</td></tr>
<tr><td><code id="resolve_+3A_stdout">stdout</code></td>
<td>
<p>(internal) If TRUE, captured standard output is relayed, otherwise not.</p>
</td></tr>
<tr><td><code id="resolve_+3A_signal">signal</code></td>
<td>
<p>(internal) If TRUE, captured <a href="base.html#topic+conditions">conditions</a> are relayed,
otherwise not.</p>
</td></tr>
<tr><td><code id="resolve_+3A_force">force</code></td>
<td>
<p>(internal) If TRUE, captured standard output and captured
<a href="base.html#topic+conditions">conditions</a> already relayed is relayed again, otherwise not.</p>
</td></tr>
<tr><td><code id="resolve_+3A_sleep">sleep</code></td>
<td>
<p>Number of seconds to wait before checking if futures have been
resolved since last time.</p>
</td></tr>
<tr><td><code id="resolve_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is resolves synchronously, i.e. it blocks until <code>x</code> and
any containing futures are resolved.
</p>


<h3>Value</h3>

<p>Returns <code>x</code> (regardless of subsetting or not).
If <code>signal</code> is TRUE and one of the futures produces an error, then
that error is produced.
</p>


<h3>See Also</h3>

<p>To resolve a future <em>variable</em>, first retrieve its
<a href="#topic+Future">Future</a> object using <code><a href="#topic+futureOf">futureOf()</a></code>, e.g.
<code>resolve(futureOf(x))</code>.
</p>

<hr>
<h2 id='resolved'>Check whether a future is resolved or not</h2><span id='topic+resolved'></span>

<h3>Description</h3>

<p>Check whether a future is resolved or not
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolved(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resolved_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+Future">Future</a>, a list, or an environment (which also
includes <a href="listenv.html#topic+listenv">list environment</a>).</p>
</td></tr>
<tr><td><code id="resolved_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method needs to be implemented by the class that implement
the Future API.  The implementation should return either TRUE or FALSE
and must never throw an error (except for <a href="#topic+FutureError">FutureError</a>:s which indicate
significant, often unrecoverable infrastructure problems).
It should also be possible to use the method for polling the
future until it is resolved (without having to wait infinitely long),
e.g. <code>while (!resolved(future)) Sys.sleep(5)</code>.
</p>


<h3>Value</h3>

<p>A logical of the same length and dimensions as <code>x</code>.
Each element is TRUE unless the corresponding element is a
non-resolved future in case it is FALSE.
</p>

<hr>
<h2 id='result.Future'>Get the results of a resolved future</h2><span id='topic+result.Future'></span><span id='topic+result'></span>

<h3>Description</h3>

<p>Get the results of a resolved future
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Future'
result(future, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="result.Future_+3A_future">future</code></td>
<td>
<p>A <a href="#topic+Future">Future</a>.</p>
</td></tr>
<tr><td><code id="result.Future_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only part of the <em>backend</em> Future API.
This function is <em>not</em> part of the frontend Future API.
</p>


<h3>Value</h3>

<p>The <a href="#topic+FutureResult">FutureResult</a> object.
</p>

<hr>
<h2 id='run.Future'>Run a future</h2><span id='topic+run.Future'></span><span id='topic+run'></span>

<h3>Description</h3>

<p>Run a future
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Future'
run(future, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run.Future_+3A_future">future</code></td>
<td>
<p>A <a href="#topic+Future">Future</a>.</p>
</td></tr>
<tr><td><code id="run.Future_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can only be called once per future.
Further calls will result in an informative error.
If a future is not run when its value is queried,
then it is run at that point.
</p>


<h3>Value</h3>

<p>The <a href="#topic+Future">Future</a> object.
</p>

<hr>
<h2 id='save_rds'>Robustly Saves an Object to RDS File Atomically</h2><span id='topic+save_rds'></span>

<h3>Description</h3>

<p>Robustly Saves an Object to RDS File Atomically
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_rds(object, pathname, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="save_rds_+3A_object">object</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> object to be save.</p>
</td></tr>
<tr><td><code id="save_rds_+3A_pathname">pathname</code></td>
<td>
<p>RDS file to written.</p>
</td></tr>
<tr><td><code id="save_rds_+3A_...">...</code></td>
<td>
<p>(optional) Additional arguments passed to <code><a href="base.html#topic+readRDS">base::saveRDS()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <a href="base.html#topic+readRDS">base::saveRDS</a> internally but writes the object atomically by first
writing to a temporary file which is then renamed.
</p>


<h3>Value</h3>

<p>(invisible) The pathname of the RDS written.
</p>

<hr>
<h2 id='sequential'>Create a sequential future whose value will be in the current <span class="rlang"><b>R</b></span> session</h2><span id='topic+sequential'></span><span id='topic+uniprocess'></span>

<h3>Description</h3>

<p>A sequential future is a future that is evaluated sequentially in the
current <span class="rlang"><b>R</b></span> session similarly to how <span class="rlang"><b>R</b></span> expressions are evaluated in <span class="rlang"><b>R</b></span>.
The only difference to <span class="rlang"><b>R</b></span> itself is that globals are validated
by default just as for all other types of futures in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sequential(..., envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sequential_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+Future">Future()</a></code>.</p>
</td></tr>
<tr><td><code id="sequential_+3A_envir">envir</code></td>
<td>
<p>The <a href="base.html#topic+environment">environment</a> from where global objects should be
identified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is <em>not</em> meant to be called directly.  Instead, the
typical usages are:
</p>
<div class="sourceCode r"><pre># Evaluate futures sequentially in the current R process
plan(sequential)
</pre></div>


<h3>Value</h3>

<p>A <a href="#topic+SequentialFuture">SequentialFuture</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use sequential futures
plan(sequential)

## A global variable
a &lt;- 0

## Create a sequential future
f &lt;- future({
  b &lt;- 3
  c &lt;- 2
  a * b * c
})

## Since 'a' is a global variable in future 'f' which
## is eagerly resolved (default), this global has already
## been resolved / incorporated, and any changes to 'a'
## at this point will _not_ affect the value of 'f'.
a &lt;- 7
print(a)

v &lt;- value(f)
print(v)
stopifnot(v == 0)
</code></pre>

<hr>
<h2 id='sessionDetails'>Outputs details on the current <span class="rlang"><b>R</b></span> session</h2><span id='topic+sessionDetails'></span>

<h3>Description</h3>

<p>Outputs details on the current <span class="rlang"><b>R</b></span> session
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sessionDetails(env = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sessionDetails_+3A_env">env</code></td>
<td>
<p>If TRUE, <code>Sys.getenv()</code> information is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly a list of all details.
</p>

<hr>
<h2 id='signalConditions'>Signals Captured Conditions</h2><span id='topic+signalConditions'></span>

<h3>Description</h3>

<p>Captured conditions that meet the <code>include</code> and <code>exclude</code>
requirements are signaled <em>in the order as they were captured</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signalConditions(
  future,
  include = "condition",
  exclude = NULL,
  resignal = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="signalConditions_+3A_future">future</code></td>
<td>
<p>A resolved <a href="#topic+Future">Future</a>.</p>
</td></tr>
<tr><td><code id="signalConditions_+3A_include">include</code></td>
<td>
<p>A character string of <a href="base.html#topic+conditions">condition</a>
classes to signal.</p>
</td></tr>
<tr><td><code id="signalConditions_+3A_exclude">exclude</code></td>
<td>
<p>A character string of <a href="base.html#topic+conditions">condition</a>
classes <em>not</em> to signal.</p>
</td></tr>
<tr><td><code id="signalConditions_+3A_resignal">resignal</code></td>
<td>
<p>If TRUE, then already signaled conditions are signaled
again, otherwise not.</p>
</td></tr>
<tr><td><code id="signalConditions_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <a href="#topic+Future">Future</a> where conditioned that were signaled
have been flagged to have been signaled.
</p>


<h3>See Also</h3>

<p>Conditions are signaled by
<code><a href="base.html#topic+conditions">signalCondition</a>()</code>.
</p>

<hr>
<h2 id='sticky_globals'>Place a sticky-globals environment immediately after the global environment</h2><span id='topic+sticky_globals'></span>

<h3>Description</h3>

<p>Place a sticky-globals environment immediately after the global environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sticky_globals(erase = FALSE, name = "future:sticky_globals", pos = 2L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sticky_globals_+3A_erase">erase</code></td>
<td>
<p>(logical) If TRUE, the environment is erased, otherwise not.</p>
</td></tr>
<tr><td><code id="sticky_globals_+3A_name">name</code></td>
<td>
<p>(character) The name of the environment on the <a href="base.html#topic+search">base::search</a>
path.</p>
</td></tr>
<tr><td><code id="sticky_globals_+3A_pos">pos</code></td>
<td>
<p>(integer) The position on the search path where the
environment should be positioned.  If <code>pos == 0L</code>, then the environment
is detached, if it exists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(invisible; environment) The environment.
</p>

<hr>
<h2 id='tweak'>Tweak a future function by adjusting its default arguments</h2><span id='topic+tweak'></span>

<h3>Description</h3>

<p>Tweak a future function by adjusting its default arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tweak(strategy, ..., penvir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tweak_+3A_strategy">strategy</code></td>
<td>
<p>An existing future function or the name of one.</p>
</td></tr>
<tr><td><code id="tweak_+3A_...">...</code></td>
<td>
<p>Named arguments to replace the defaults of existing
arguments.</p>
</td></tr>
<tr><td><code id="tweak_+3A_penvir">penvir</code></td>
<td>
<p>The environment used when searching for a future
function by its name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a future function.
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+plan">plan()</a></code> to set a future to become the
new default strategy.
</p>

<hr>
<h2 id='UniprocessFuture-class'>An uniprocess future is a future whose value will be resolved synchronously in the current process</h2><span id='topic+UniprocessFuture-class'></span><span id='topic+UniprocessFuture'></span><span id='topic+SequentialFuture'></span>

<h3>Description</h3>

<p>An uniprocess future is a future whose value will be resolved synchronously in the current process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UniprocessFuture(expr = NULL, substitute = TRUE, envir = parent.frame(), ...)

SequentialFuture(
  expr = NULL,
  envir = parent.frame(),
  substitute = TRUE,
  lazy = FALSE,
  globals = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UniprocessFuture-class_+3A_expr">expr</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> <a href="base.html#topic+expression">expression</a>.</p>
</td></tr>
<tr><td><code id="UniprocessFuture-class_+3A_substitute">substitute</code></td>
<td>
<p>If TRUE, argument <code>expr</code> is
<code><a href="base.html#topic+substitute">substitute</a>()</code>:ed, otherwise not.</p>
</td></tr>
<tr><td><code id="UniprocessFuture-class_+3A_envir">envir</code></td>
<td>
<p>The <a href="base.html#topic+environment">environment</a> from where global objects should be
identified.</p>
</td></tr>
<tr><td><code id="UniprocessFuture-class_+3A_...">...</code></td>
<td>
<p>Additional named elements passed to <code><a href="#topic+Future">Future()</a></code>.</p>
</td></tr>
<tr><td><code id="UniprocessFuture-class_+3A_lazy">lazy</code></td>
<td>
<p>If FALSE (default), the future is resolved
eagerly (starting immediately), otherwise not.</p>
</td></tr>
<tr><td><code id="UniprocessFuture-class_+3A_globals">globals</code></td>
<td>
<p>(optional) a logical, a character vector, or a named list
to control how globals are handled.
For details, see section 'Globals used by future expressions'
in the help for <code><a href="#topic+future">future()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>UniprocessFuture()</code> returns an object of class <code>UniprocessFuture</code>.
</p>
<p><code>SequentialFuture()</code> returns an object of class <code>SequentialProcess</code>,
which inherits from <code>UniprocessFuture</code>.
</p>


<h3>Usage</h3>

<p>To use 'sequential' futures, use <code>plan(sequential)</code>, cf. <a href="#topic+sequential">sequential</a>.
</p>

<hr>
<h2 id='usedCores'>Get number of cores currently used</h2><span id='topic+usedCores'></span>

<h3>Description</h3>

<p>Get number of children (and don't count the current process)
used by the current <span class="rlang"><b>R</b></span> session.  The number of children
is the total number of subprocesses launched by this
process that are still running and whose values have yet
not been collected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>usedCores()
</code></pre>


<h3>Value</h3>

<p>A non-negative integer.
</p>

<hr>
<h2 id='value'>The value of a future or the values of all elements in a container</h2><span id='topic+value'></span><span id='topic+value.Future'></span><span id='topic+value.list'></span><span id='topic+value.listenv'></span><span id='topic+value.environment'></span>

<h3>Description</h3>

<p>Gets the value of a future or the values of all elements (including futures)
in a container such as a list, an environment, or a list environment.
If one or more futures is unresolved, then this function blocks until all
queried futures are resolved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>value(...)

## S3 method for class 'Future'
value(future, stdout = TRUE, signal = TRUE, ...)

## S3 method for class 'list'
value(x, stdout = TRUE, signal = TRUE, ...)

## S3 method for class 'listenv'
value(x, stdout = TRUE, signal = TRUE, ...)

## S3 method for class 'environment'
value(x, stdout = TRUE, signal = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="value_+3A_...">...</code></td>
<td>
<p>All arguments used by the S3 methods.</p>
</td></tr>
<tr><td><code id="value_+3A_future">future</code>, <code id="value_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+Future">Future</a>, an environment, a list, or a list environment.</p>
</td></tr>
<tr><td><code id="value_+3A_stdout">stdout</code></td>
<td>
<p>If TRUE, standard output captured while resolving futures
is relayed, otherwise not.</p>
</td></tr>
<tr><td><code id="value_+3A_signal">signal</code></td>
<td>
<p>If TRUE, <a href="base.html#topic+conditions">conditions</a> captured while resolving
futures are relayed, otherwise not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>value()</code> of a Future object returns the value of the future, which can
be any type of <span class="rlang"><b>R</b></span> object.
</p>
<p><code>value()</code> of a list, an environment, or a list environment returns an
object with the same number of elements and of the same class.
Names and dimension attributes are preserved, if available.
All future elements are replaced by their corresponding <code>value()</code> values.
For all other elements, the existing object is kept as-is.
</p>
<p>If <code>signal</code> is TRUE and one of the futures produces an error, then
that error is produced.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
