<!DOCTYPE html><html><head><title>Help for package mdpeer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mdpeer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Adj2Lap'><p>Compute graph Laplacian matrix from graph adjacency matrix</p></a></li>
<li><a href='#L2L.normalized'><p>Compute normalized version of graph Laplacian matrix</p></a></li>
<li><a href='#mdpeer'><p>mdpeer: Methods for graph-constrained regression with enhanced regularization parameters selection</p></a></li>
<li><a href='#riPEER'><p>Graph-constrained regression with penalty term being a linear combination of graph-based and ridge penalty terms</p></a></li>
<li><a href='#riPEERc'><p>Graph-constrained regression with addition of a small ridge term to handle the non-invertibility of a graph Laplacian matrix</p></a></li>
<li><a href='#vizu.mat'><p>Visualize matrix data in a form of a heatmap, with continuous values legend</p></a></li>
<li><a href='#vizu.mat.factor'><p>Visualize matrix data in a form of a heatmap, with categorical values legend</p></a></li>
<li><a href='#vrPEER'><p>Graph-constrained regression with variable-reduction procedure to handle the non-invertibility of</p>
a graph-originated penalty matrix</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Graph-Constrained Regression with Enhanced Regularization
Parameters Selection</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Marta Karas [aut, cre],
  Damian Brzyski [ctb],
  Jaroslaw Harezlak [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marta Karas &lt;marta.karass@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides graph-constrained regression methods in which
    regularization parameters are selected automatically via estimation of
    equivalent Linear Mixed Model formulation. 'riPEER' (ridgified Partially
    Empirical Eigenvectors for Regression) method employs a penalty term being
    a linear combination of graph-originated and ridge-originated penalty terms,
    whose two regularization parameters are ML estimators from corresponding
    Linear Mixed Model solution; a graph-originated penalty term allows imposing
    similarity between coefficients based on graph information given whereas
    additional ridge-originated penalty term facilitates parameters estimation:
    it reduces computational issues arising from singularity in a graph-originated
    penalty matrix and yields plausible results in situations when graph information
    is not informative. 'riPEERc' (ridgified Partially Empirical Eigenvectors
    for Regression with constant) method utilizes addition of a diagonal matrix
    multiplied by a predefined (small) scalar to handle the non-invertibility of
    a graph Laplacian matrix. 'vrPEER' (variable reducted PEER) method performs
    variable-reduction procedure to handle the non-invertibility of a graph
    Laplacian matrix.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>reshape2, ggplot2, nlme, boot, nloptr, rootSolve, psych,
magic, glmnet</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-05-30 02:48:05 UTC; mkaras</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-05-30 04:44:40 UTC</td>
</tr>
</table>
<hr>
<h2 id='Adj2Lap'>Compute graph Laplacian matrix from graph adjacency matrix</h2><span id='topic+Adj2Lap'></span>

<h3>Description</h3>

<p>Compute graph Laplacian matrix from graph adjacency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Adj2Lap(adj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Adj2Lap_+3A_adj">adj</code></td>
<td>
<p>graph adjacency matrix (squared symmetric matrix)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>graph Laplacian matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define exemplary adjacency matrix
p1 &lt;- 10
p2 &lt;- 40
p &lt;- p1 + p2
A &lt;- matrix(rep(0, p * p), p, p)
A[1:p1, 1:p1] &lt;- 1
A[(p1 + 1):p, (p1 + 1):p] &lt;- 1
vizu.mat(A, "adjacency matrix")

# Compute corresponding Laplacian matrix
L &lt;- Adj2Lap(A)
vizu.mat(L, "Laplacian matrix")
</code></pre>

<hr>
<h2 id='L2L.normalized'>Compute normalized version of graph Laplacian matrix</h2><span id='topic+L2L.normalized'></span>

<h3>Description</h3>

<p>Compute normalized version of graph Laplacian matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L2L.normalized(L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="L2L.normalized_+3A_l">L</code></td>
<td>
<p>graph Laplcian matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>normalized graph Laplacian matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define exemplary adjacency matrix
p1 &lt;- 10
p2 &lt;- 40
p &lt;- p1 + p2
A &lt;- matrix(rep(0, p * p), p, p)
A[1:p1, 1:p1] &lt;- 1
A[(p1 + 1):p, (p1 + 1):p] &lt;- 1
vizu.mat(A, "adjacency matrix")

# Compute corresponding Laplacian matrix
L &lt;- Adj2Lap(A)
vizu.mat(L, "Laplacian matrix")

# Compute corresponding Laplacian matrix - normalized
L.norm &lt;- L2L.normalized(L)
vizu.mat(L.norm, "L Laplacian matrix (normalized)")

</code></pre>

<hr>
<h2 id='mdpeer'>mdpeer: Methods for graph-constrained regression with enhanced regularization parameters selection</h2><span id='topic+mdpeer'></span><span id='topic+mdpeer-package'></span>

<h3>Description</h3>

<p>Provides graph-constrained
regression methods in which regularization parameters 
are selected automatically via estimation of equivalent Linear
Mixed Model formulation.  
'riPEER' (ridgified Partially Empirical Eigenvectors for
Regression) method employs a penalty term being
a linear combination of graph-originated and ridge-originated penalty terms,
whose two regularization parameters are ML estimators from corresponding Linear
Mixed Model solution; a graph-originated penalty
term allows imposing similarity between coefficients based on graph information
given whereas additional ridge-originated penalty term facilitates parameters
estimation: it reduces computational issues arising from singularity in a graph-originated 
penalty matrix and yields plausible results in situations when graph
information is not informative. 'riPEERc' (ridgified Partially Empirical Eigenvectors for
Regression with constant) method utilizes addition of a diagonal matrix multiplied by a predefined (small) 
scalar to handle the non-invertibility of a graph Laplacian matrix. 'vrPEER' 
(variable reducted PEER) method performs variable-reduction procedure to handle 
the non-invertibility of a graph Laplacian matrix.
</p>

<hr>
<h2 id='riPEER'>Graph-constrained regression with penalty term being a linear combination of graph-based and ridge penalty terms</h2><span id='topic+riPEER'></span>

<h3>Description</h3>

<p>Graph-constrained regression with penalty term being a linear combination of graph-based and ridge penalty terms.
</p>
<p>See <em>Details</em> for model description and optimization problem formulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riPEER(Q, y, Z, X = NULL, optim.metod = "rootSolve",
  rootSolve.x0 = c(1e-05, 1e-05), rootSolve.Q0.x0 = 1e-05, sbplx.x0 = c(1,
  1), sbplx.lambda.lo = c(10^(-5), 10^(-5)), sbplx.lambda.up = c(1e+06,
  1e+06), compute.boot.CI = FALSE, boot.R = 1000, boot.conf = 0.95,
  boot.set.seed = TRUE, boot.parallel = "multicore", boot.ncpus = 4,
  verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="riPEER_+3A_q">Q</code></td>
<td>
<p>graph-originated penalty matrix <code class="reqn">(p \times p)</code>; typically: a graph Laplacian matrix</p>
</td></tr>
<tr><td><code id="riPEER_+3A_y">y</code></td>
<td>
<p>response values matrix <code class="reqn">(n \times 1)</code></p>
</td></tr>
<tr><td><code id="riPEER_+3A_z">Z</code></td>
<td>
<p>design matrix <code class="reqn">(n \times p)</code> modeled as random effects variables (to be penalized in regression modeling);
<strong>assumed to be already standarized</strong></p>
</td></tr>
<tr><td><code id="riPEER_+3A_x">X</code></td>
<td>
<p>design matrix <code class="reqn">(n \times k)</code> modeled as fixed effects variables (not to be penalized in regression modeling);
if does not contain columns of 1s, such column will be added to be treated as intercept in a model</p>
</td></tr>
<tr><td><code id="riPEER_+3A_optim.metod">optim.metod</code></td>
<td>
<p>optimization method used to optimize <code class="reqn">\lambda = (\lambda_Q, \lambda_R)</code>
</p>

<ul>
<li><p> &quot;rootSolve&quot; (default) - optimizes by finding roots of non-linear equations by the Newton-Raphson method; from <code>rootSolve</code> package
</p>
</li>
<li><p> &quot;sbplx&quot; -  optimizes with the use of Subplex Algorithm: 'Subplex is a variant of Nelder-Mead that uses Nelder-Mead on a sequence of subspaces'; from <code>nloptr</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="riPEER_+3A_rootsolve.x0">rootSolve.x0</code></td>
<td>
<p>vector containing initial guesses for <code class="reqn">\lambda = (\lambda_Q, \lambda_R)</code> used in &quot;rootSolve&quot; algorithm</p>
</td></tr>
<tr><td><code id="riPEER_+3A_rootsolve.q0.x0">rootSolve.Q0.x0</code></td>
<td>
<p>vector containing initial guess for <code class="reqn">\lambda_R</code> used in &quot;rootSolve&quot; algorithm</p>
</td></tr>
<tr><td><code id="riPEER_+3A_sbplx.x0">sbplx.x0</code></td>
<td>
<p>vector containing initial guesses for <code class="reqn">\lambda = (\lambda_Q, \lambda_R)</code> used in &quot;sbplx&quot; algorithm</p>
</td></tr>
<tr><td><code id="riPEER_+3A_sbplx.lambda.lo">sbplx.lambda.lo</code></td>
<td>
<p>vector containing minimum values of <code class="reqn">\lambda = (\lambda_Q, \lambda_R)</code> grid search in &quot;sbplx&quot; algorithm</p>
</td></tr>
<tr><td><code id="riPEER_+3A_sbplx.lambda.up">sbplx.lambda.up</code></td>
<td>
<p>vector containing mximum values of <code class="reqn">\lambda = (\lambda_Q, \lambda_R)</code> grid search in &quot;sbplx&quot; algorithm</p>
</td></tr>
<tr><td><code id="riPEER_+3A_compute.boot.ci">compute.boot.CI</code></td>
<td>
<p>logical whether or not compute bootstrap confidence intervals for <code class="reqn">b</code> regression coefficient estimates</p>
</td></tr>
<tr><td><code id="riPEER_+3A_boot.r">boot.R</code></td>
<td>
<p>number of bootstrap replications used in bootstrap confidence intervals computation</p>
</td></tr>
<tr><td><code id="riPEER_+3A_boot.conf">boot.conf</code></td>
<td>
<p>confidence level assumed in bootstrap confidence intervals computation</p>
</td></tr>
<tr><td><code id="riPEER_+3A_boot.set.seed">boot.set.seed</code></td>
<td>
<p>logical whether or not set seed in bootstrap confidence intervals computation</p>
</td></tr>
<tr><td><code id="riPEER_+3A_boot.parallel">boot.parallel</code></td>
<td>
<p>value of <code>parallel</code> argument in <code>boot</code> function in bootstrap confidence intervals computation</p>
</td></tr>
<tr><td><code id="riPEER_+3A_boot.ncpus">boot.ncpus</code></td>
<td>
<p>value of <code>ncpus</code> argument in <code>boot</code> function in bootstrap confidence intervals computation</p>
</td></tr>
<tr><td><code id="riPEER_+3A_verbose">verbose</code></td>
<td>
<p>logical whether or not set verbose mode (print out function execution messages)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates coefficients of linear model of the formula:
</p>
<p style="text-align: center;"><code class="reqn">y =  X\beta + Zb + \varepsilon</code>
</p>

<p>where:
</p>

<ul>
<li> <p><code class="reqn">y</code> - response,
</p>
</li>
<li> <p><code class="reqn">X</code> - data matrix,
</p>
</li>
<li> <p><code class="reqn">Z</code> - data matrix,
</p>
</li>
<li> <p><code class="reqn">\beta</code> - regression coefficients, <em>not penalized</em> in estimation process,
</p>
</li>
<li> <p><code class="reqn">b</code> - regression coefficients, <em>penalized</em> in estimation process and for whom there is, possibly a prior graph of similarity / graph of connections available.
</p>
</li></ul>

<p>The method uses a penalty being a linear combination of a graph-based and ridge penalty terms:
</p>
<p style="text-align: center;"><code class="reqn">\beta_{est}, b_{est}= arg \; min_{\beta,b} \{ (y - X\beta - Zb)^T(y - X\beta - Zb) + \lambda_Qb^TQb +  \lambda_Rb^Tb \}</code>
</p>

<p>where:
</p>

<ul>
<li> <p><code class="reqn">Q</code> - a graph-originated penalty matrix; typically: a graph Laplacian matrix,
</p>
</li>
<li> <p><code class="reqn">\lambda_Q</code> - regularization parameter for a graph-based penalty term
</p>
</li>
<li> <p><code class="reqn">\lambda_R</code> - regularization parameter for ridge penalty term
</p>
</li></ul>

<p>The two regularization parameters, <code class="reqn">\lambda_Q</code> and <code class="reqn">\lambda_R</code>, are estimated as ML estimators from equivalent
Linear Mixed Model optimizaton problem formulation (see: References).
</p>

<ul>
<li><p> Graph-originated penalty term allows imposing similarity between coefficients based on graph information given.
</p>
</li>
<li><p> Ridge-originated penalty term facilitates parameters estimation: it reduces computational issues
arising from singularity in a graph-originated
penalty matrix and yields plausible results in situations when graph information
is not informative.
</p>
</li></ul>

<p>Bootstrap confidence intervals computation is available (not set as a default option).
</p>


<h3>Value</h3>

<table>
<tr><td><code>b.est</code></td>
<td>
<p>vector of <code class="reqn">b</code> coefficient estimates</p>
</td></tr>
<tr><td><code>beta.est</code></td>
<td>
<p>vector of <code class="reqn">\beta</code> coefficient estimates</p>
</td></tr>
<tr><td><code>lambda.Q</code></td>
<td>
<p><code class="reqn">\lambda_Q</code> regularization parameter value</p>
</td></tr>
<tr><td><code>lambda.R</code></td>
<td>
<p><code class="reqn">\lambda_R</code> regularization parameter value</p>
</td></tr>
<tr><td><code>lambda.2</code></td>
<td>
<p><code>lambda.R</code>/<code>lambda.Q</code> value</p>
</td></tr>
<tr><td><code>boot.CI</code></td>
<td>
<p>data frame with two columns, <code>lower</code> and <code>upper</code>, containing, respectively, values of lower and upper bootstrap confidence intervals for <code class="reqn">b</code> regression coefficient estimates</p>
</td></tr>
<tr><td><code>obj.fn.val</code></td>
<td>
<p>optimization problem objective function value</p>
</td></tr>
</table>


<h3>References</h3>

<p>Karas, M., Brzyski, D., Dzemidzic, M., J., Kareken, D.A., Randolph, T.W., Harezlak, J. (2017).
Brain connectivity-informed regularization methods for regression. doi: https://doi.org/10.1101/117945
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
n &lt;- 200
p1 &lt;- 10
p2 &lt;- 90
p &lt;- p1 + p2
# Define graph adjacency matrix
A &lt;- matrix(rep(0, p*p), nrow = p, ncol = p)
A[1:p1, 1:p1] &lt;- 1
A[(p1+1):p, (p1+1):p] &lt;- 1
L &lt;- Adj2Lap(A)
# Define Q penalty matrix as graph Laplacian matrix normalized)
Q &lt;- L2L.normalized(L)
# Define Z,X design matrices and aoutcome y
Z &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)
b.true &lt;- c(rep(1, p1), rep(0, p2))
X &lt;- matrix(rnorm(n*3), nrow = n, ncol = 3)
beta.true &lt;- runif(3)
intercept &lt;- 0
eta &lt;- intercept + Z %*% b.true + X %*% beta.true
R2 &lt;- 0.5
sd.eps &lt;- sqrt(var(eta) * (1 - R2) / R2)
error &lt;- rnorm(n, sd = sd.eps)
y &lt;- eta + error

## Not run: 
riPEER.out &lt;- riPEER(Q, y, Z, X)
plt.df &lt;- data.frame(x = 1:p, y = riPEER.out$b.est)
ggplot(plt.df, aes(x = x, y = y, group = 1)) + geom_line() + labs("b estimates")

## End(Not run)

## Not run: 
# riPEER with 0.95 bootstrap confidence intervals computation
riPEER.out &lt;- riPEER(Q, y, Z, X, compute.boot.CI = TRUE, boot.R = 500)
plt.df &lt;- data.frame(x = 1:p, 
                     y = riPEER.out$b.est, 
                     lo = riPEER.out$boot.CI[,1], 
                     up =  riPEER.out$boot.CI[,2])
ggplot(plt.df, aes(x = x, y = y, group = 1)) + geom_line() +  
  geom_ribbon(aes(ymin=lo, ymax=up), alpha = 0.3)

## End(Not run)

</code></pre>

<hr>
<h2 id='riPEERc'>Graph-constrained regression with addition of a small ridge term to handle the non-invertibility of a graph Laplacian matrix</h2><span id='topic+riPEERc'></span>

<h3>Description</h3>

<p>Graph-constrained regression with addition of a diagonal matrix multiplied by a predefined (small)
scalar to handle the non-invertibility of a graph Laplacian matrix (see: References).
</p>
<p>Bootstrap confidence intervals computation is available (not set as a default option).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riPEERc(Q, y, Z, X = NULL, lambda.2 = 0.001, compute.boot.CI = FALSE,
  boot.R = 1000, boot.conf = 0.95, boot.set.seed = TRUE,
  boot.parallel = "multicore", boot.ncpus = 4, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="riPEERc_+3A_q">Q</code></td>
<td>
<p>graph-originated penalty matrix <code class="reqn">(p \times p)</code>; typically: a graph Laplacian matrix</p>
</td></tr>
<tr><td><code id="riPEERc_+3A_y">y</code></td>
<td>
<p>response values matrix <code class="reqn">(n \times 1)</code></p>
</td></tr>
<tr><td><code id="riPEERc_+3A_z">Z</code></td>
<td>
<p>design matrix <code class="reqn">(n \times p)</code> modeled as random effects variables (to be penalized in regression modeling);
<strong>assumed to be already standarized</strong></p>
</td></tr>
<tr><td><code id="riPEERc_+3A_x">X</code></td>
<td>
<p>design matrix <code class="reqn">(n \times k)</code> modeled as fixed effects variables (not to be penalized in regression modeling);
<strong>should contain colum of 1s if intercept is to be considered in a model</strong></p>
</td></tr>
<tr><td><code id="riPEERc_+3A_lambda.2">lambda.2</code></td>
<td>
<p>(small) scalar value of regularization parameter for diagonal matrix by adding which the <code>Q</code> matrix is corrected
(note: correction is done <em>before</em> <code class="reqn">\lambda_Q</code> regularization parameter value estimation;
in other words: <code class="reqn">\lambda_Q</code> estimation is done for the corrected <code>Q</code> matrix)</p>
</td></tr>
<tr><td><code id="riPEERc_+3A_compute.boot.ci">compute.boot.CI</code></td>
<td>
<p>logical whether or not compute bootstrap confidence intervals for <code class="reqn">b</code> regression coefficient estimates</p>
</td></tr>
<tr><td><code id="riPEERc_+3A_boot.r">boot.R</code></td>
<td>
<p>number of bootstrap replications used in bootstrap confidence intervals computation</p>
</td></tr>
<tr><td><code id="riPEERc_+3A_boot.conf">boot.conf</code></td>
<td>
<p>confidence level assumed in bootstrap confidence intervals computation</p>
</td></tr>
<tr><td><code id="riPEERc_+3A_boot.set.seed">boot.set.seed</code></td>
<td>
<p>logical whether or not set seed in bootstrap confidence intervals computation</p>
</td></tr>
<tr><td><code id="riPEERc_+3A_boot.parallel">boot.parallel</code></td>
<td>
<p>value of <code>parallel</code> argument in <code>boot</code> function in bootstrap confidence intervals computation</p>
</td></tr>
<tr><td><code id="riPEERc_+3A_boot.ncpus">boot.ncpus</code></td>
<td>
<p>value of <code>ncpus</code> argument in <code>boot</code> function in bootstrap confidence intervals computation</p>
</td></tr>
<tr><td><code id="riPEERc_+3A_verbose">verbose</code></td>
<td>
<p>logical whether or not set verbose mode (print out function execution messages)</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>b.est</code></td>
<td>
<p>vector of <code class="reqn">b</code> coefficient estimates</p>
</td></tr>
<tr><td><code>beta.est</code></td>
<td>
<p>vector of <code class="reqn">\beta</code> coefficient estimates</p>
</td></tr>
<tr><td><code>lambda.Q</code></td>
<td>
<p><code class="reqn">\lambda_Q</code> regularization parameter value</p>
</td></tr>
<tr><td><code>lambda.R</code></td>
<td>
<p><code>lambda.Q</code> * <code>lambda.2</code> value</p>
</td></tr>
<tr><td><code>lambda.2</code></td>
<td>
<p><code>lambda.2</code> supplied argument value</p>
</td></tr>
<tr><td><code>boot.CI</code></td>
<td>
<p>data frame with two columns, <code>lower</code> and <code>upper</code>, containing, respectively, values of lower and upper bootstrap confidence intervals for <code class="reqn">b</code> regression coefficient estimates</p>
</td></tr>
</table>


<h3>References</h3>

<p>Karas, M., Brzyski, D., Dzemidzic, M., J., Kareken, D.A., Randolph, T.W., Harezlak, J. (2017).
Brain connectivity-informed regularization methods for regression. doi: https://doi.org/10.1101/117945
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
n &lt;- 200
p1 &lt;- 10
p2 &lt;- 90
p &lt;- p1 + p2
# Define graph adjacency matrix
A &lt;- matrix(rep(0, p*p), nrow = p, ncol = p)
A[1:p1, 1:p1] &lt;- 1
A[(p1+1):p, (p1+1):p] &lt;- 1
L &lt;- Adj2Lap(A)
# Define Q penalty matrix as graph Laplacian matrix normalized)
Q &lt;- L2L.normalized(L)
# Define Z,X design matrices and aoutcome y
Z &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)
b.true &lt;- c(rep(1, p1), rep(0, p2))
X &lt;- matrix(rnorm(n*3), nrow = n, ncol = 3)
beta.true &lt;- runif(3)
intercept &lt;- 0
eta &lt;- intercept + Z %*% b.true + X %*% beta.true
R2 &lt;- 0.5
sd.eps &lt;- sqrt(var(eta) * (1 - R2) / R2)
error &lt;- rnorm(n, sd = sd.eps)
y &lt;- eta + error

## Not run: 
riPEERc.out &lt;- riPEERc(Q, y, Z, X)
plt.df &lt;- data.frame(x = 1:p, y = riPEERc.out$b.est)
ggplot(plt.df, aes(x = x, y = y, group = 1)) + geom_line() + labs("b estimates")

## End(Not run)

## Not run: 
# riPEERc with 0.95 bootstrap confidence intervals computation
riPEERc.out &lt;- riPEERc(Q, y, Z, X, compute.boot.CI = TRUE, boot.R = 500)
plt.df &lt;- data.frame(x = 1:p, y = riPEERc.out$b.est, 
                     lo = riPEERc.out$boot.CI[,1], 
                     up =  riPEERc.out$boot.CI[,2])
ggplot(plt.df, aes(x = x, y = y, group = 1)) + geom_line() +  
  geom_ribbon(aes(ymin=lo, ymax=up), alpha = 0.3)

## End(Not run)

</code></pre>

<hr>
<h2 id='vizu.mat'>Visualize matrix data in a form of a heatmap, with continuous values legend</h2><span id='topic+vizu.mat'></span>

<h3>Description</h3>

<p>Matrix data visualization in a form of a heatmap, with
the use of <code>ggplot2</code> library. Minimum user input (a matrix object) is needed to produce decent visualization output.
Automatic plot adjustments are implemented and used as defaults, including
selecting legend color palette and legend scale limits.  Further
plot adjustments are available, including
adding a title, font size change, axis label clearing and others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vizu.mat(matrix.object, title = "", base_size = 12, adjust.limits = TRUE,
  adjust.colors = TRUE, fill.scale.limits = NULL, colors.palette = NULL,
  geom_tile.colour = "grey90", clear.labels = TRUE, clear.x.label = FALSE,
  clear.y.label = FALSE, uniform.labes = FALSE, rotate.x.labels = FALSE,
  x.lab = "", y.lab = "", axis.text.x.size = base_size - 2,
  axis.text.y.size = base_size - 2, axis.title.x.size = base_size - 2,
  axis.title.y.size = base_size - 2, legend.text.size = base_size - 2,
  legend.title.size = base_size - 2, legend.title = "value",
  text.font.family = "Helvetica", remove.legend = FALSE,
  axis.text.x.breaks.idx = NULL, axis.text.y.breaks.idx = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vizu.mat_+3A_matrix.object">matrix.object</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="vizu.mat_+3A_title">title</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="vizu.mat_+3A_base_size">base_size</code></td>
<td>
<p>base font size</p>
</td></tr>
<tr><td><code id="vizu.mat_+3A_adjust.limits">adjust.limits</code></td>
<td>
<p>logical whether or not adjust legend scale limits automatically:
</p>

<ul>
<li><p> legend scale starts / ends with 0 for matrix with non-negative / non-positive values only,
</p>
</li>
<li><p> legend scale is symmetric for matrix with both negative and positive values
</p>
</li></ul>
</td></tr>
<tr><td><code id="vizu.mat_+3A_adjust.colors">adjust.colors</code></td>
<td>
<p>logical whether or not adjust legend color automatically:
</p>

<ul>
<li><p> legend color palette white-red for a data matrix with non-negative values only,
</p>
</li>
<li><p> legend color palette blue-white for a data matrix with non-positive values only,
</p>
</li>
<li><p> legend color palette blue-white-red for a data matrix with both positive and negative values
</p>
</li></ul>
</td></tr>
<tr><td><code id="vizu.mat_+3A_fill.scale.limits">fill.scale.limits</code></td>
<td>
<p>2-element vector defining legend scale limits</p>
</td></tr>
<tr><td><code id="vizu.mat_+3A_colors.palette">colors.palette</code></td>
<td>
<p>legend color color palette</p>
</td></tr>
<tr><td><code id="vizu.mat_+3A_geom_tile.colour">geom_tile.colour</code></td>
<td>
<p>tiles color value</p>
</td></tr>
<tr><td><code id="vizu.mat_+3A_clear.labels">clear.labels</code></td>
<td>
<p>logical whether or not clear both x- and y-axis labels</p>
</td></tr>
<tr><td><code id="vizu.mat_+3A_clear.x.label">clear.x.label</code></td>
<td>
<p>logical whether or not clear x-axis labels</p>
</td></tr>
<tr><td><code id="vizu.mat_+3A_clear.y.label">clear.y.label</code></td>
<td>
<p>logical whether or not clear y-axis labels</p>
</td></tr>
<tr><td><code id="vizu.mat_+3A_uniform.labes">uniform.labes</code></td>
<td>
<p>logical whether or not define generic short column and rows labeling:
</p>

<ul>
<li><p> 'c1','c2',...,'cp' for columns,
</p>
</li>
<li><p> 'r1','r2',...,'rp' for rows;
might be especially useful if the matrix some long colnames and rownames already assigned
</p>
</li></ul>
</td></tr>
<tr><td><code id="vizu.mat_+3A_rotate.x.labels">rotate.x.labels</code></td>
<td>
<p>logical whether or not rotate x-axis labels by 90 degrees</p>
</td></tr>
<tr><td><code id="vizu.mat_+3A_x.lab">x.lab</code></td>
<td>
<p>x-axis label</p>
</td></tr>
<tr><td><code id="vizu.mat_+3A_y.lab">y.lab</code></td>
<td>
<p>y-axis label</p>
</td></tr>
<tr><td><code id="vizu.mat_+3A_axis.text.x.size">axis.text.x.size</code></td>
<td>
<p>font size of x-axis text</p>
</td></tr>
<tr><td><code id="vizu.mat_+3A_axis.text.y.size">axis.text.y.size</code></td>
<td>
<p>font size of y-axis text</p>
</td></tr>
<tr><td><code id="vizu.mat_+3A_axis.title.x.size">axis.title.x.size</code></td>
<td>
<p>font size of x-axis label</p>
</td></tr>
<tr><td><code id="vizu.mat_+3A_axis.title.y.size">axis.title.y.size</code></td>
<td>
<p>font size of y-axis label</p>
</td></tr>
<tr><td><code id="vizu.mat_+3A_legend.text.size">legend.text.size</code></td>
<td>
<p>font size of legend text</p>
</td></tr>
<tr><td><code id="vizu.mat_+3A_legend.title.size">legend.title.size</code></td>
<td>
<p>font size of legend title</p>
</td></tr>
<tr><td><code id="vizu.mat_+3A_legend.title">legend.title</code></td>
<td>
<p>legend title</p>
</td></tr>
<tr><td><code id="vizu.mat_+3A_text.font.family">text.font.family</code></td>
<td>
<p>font family</p>
</td></tr>
<tr><td><code id="vizu.mat_+3A_remove.legend">remove.legend</code></td>
<td>
<p>logical whether or not remove legend</p>
</td></tr>
<tr><td><code id="vizu.mat_+3A_axis.text.x.breaks.idx">axis.text.x.breaks.idx</code></td>
<td>
<p>indices of x-axis elements whose thicks are kept
and whose numerical labels are kept</p>
</td></tr>
<tr><td><code id="vizu.mat_+3A_axis.text.y.breaks.idx">axis.text.y.breaks.idx</code></td>
<td>
<p>indices of y-axis elements whose thicks are kept
and whose numerical labels are kept</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ggplot2</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(rnorm(30*30), nrow = 30, ncol = 30)
vizu.mat(mat)
vizu.mat(mat, fill.scale.limits = c(-3,3))
vizu.mat(mat, fill.scale.limits = c(-10,10))
vizu.mat(mat, fill.scale.limits = c(-10,10), 
         uniform.labes = TRUE, clear.labels = FALSE)
colnames(mat) &lt;- paste0("col", 1:30, sample(LETTERS, 30, replace = TRUE))
rownames(mat) &lt;- paste0("row", 1:30, sample(LETTERS, 30, replace = TRUE))
vizu.mat(mat, fill.scale.limits = c(-10,10), 
         clear.labels = FALSE, 
         rotate.x.labels = TRUE)
mat.positive &lt;- abs(mat)
vizu.mat(mat.positive, 
         title = "positive values only -&gt; legend limits and colors automatically adjusted",
         clear.labels = FALSE, 
         rotate.x.labels = TRUE)

</code></pre>

<hr>
<h2 id='vizu.mat.factor'>Visualize matrix data in a form of a heatmap, with categorical values legend</h2><span id='topic+vizu.mat.factor'></span>

<h3>Description</h3>

<p>Matrix data visualization in a form of a heatmap, with
the use of <code>ggplot2</code> library. Numerical values are represented as
categorical. Minimum user input (a matrix object) is needed to produce decent visualization output. Further
plot adjustments are available, including tile color change,
adding a title, font size change, axis label clearing and others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vizu.mat.factor(matrix.object, title = "", base_size = 12,
  scale_fill_manual.values = NULL, geom_tile.colour = "grey90",
  clear.labels = TRUE, clear.x.label = FALSE, clear.y.label = FALSE,
  uniform.labes = FALSE, rotate.x.labels = FALSE, x.lab = "",
  y.lab = "", axis.text.x.size = base_size - 2,
  axis.text.y.size = base_size - 2, axis.title.x.size = base_size - 2,
  axis.title.y.size = base_size - 2, legend.text.size = base_size - 2,
  legend.title.size = base_size - 2, legend.title = "value",
  text.font.family = "Helvetica", remove.legend = FALSE,
  factor.levels = NULL, axis.text.x.breaks.idx = NULL,
  axis.text.y.breaks.idx = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vizu.mat.factor_+3A_matrix.object">matrix.object</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="vizu.mat.factor_+3A_title">title</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="vizu.mat.factor_+3A_base_size">base_size</code></td>
<td>
<p>base font size</p>
</td></tr>
<tr><td><code id="vizu.mat.factor_+3A_scale_fill_manual.values">scale_fill_manual.values</code></td>
<td>
<p>vector of legend colors for categorical values</p>
</td></tr>
<tr><td><code id="vizu.mat.factor_+3A_geom_tile.colour">geom_tile.colour</code></td>
<td>
<p>tiles color value</p>
</td></tr>
<tr><td><code id="vizu.mat.factor_+3A_clear.labels">clear.labels</code></td>
<td>
<p>logical whether or not clear both x- and y-axis labels</p>
</td></tr>
<tr><td><code id="vizu.mat.factor_+3A_clear.x.label">clear.x.label</code></td>
<td>
<p>logical whether or not clear x-axis labels</p>
</td></tr>
<tr><td><code id="vizu.mat.factor_+3A_clear.y.label">clear.y.label</code></td>
<td>
<p>logical whether or not clear y-axis labels</p>
</td></tr>
<tr><td><code id="vizu.mat.factor_+3A_uniform.labes">uniform.labes</code></td>
<td>
<p>logical whether or not define generic short column and rows labeling:
</p>

<ul>
<li><p> 'c1','c2',...,'cp' for columns,
</p>
</li>
<li><p> 'r1','r2',...,'rp' for rows;
might be especially useful if the matrix some long colnames and rownames already assigned
</p>
</li></ul>
</td></tr>
<tr><td><code id="vizu.mat.factor_+3A_rotate.x.labels">rotate.x.labels</code></td>
<td>
<p>logical whether or not rotate x-axis labels by 90 degrees</p>
</td></tr>
<tr><td><code id="vizu.mat.factor_+3A_x.lab">x.lab</code></td>
<td>
<p>x-axis label</p>
</td></tr>
<tr><td><code id="vizu.mat.factor_+3A_y.lab">y.lab</code></td>
<td>
<p>y-axis label</p>
</td></tr>
<tr><td><code id="vizu.mat.factor_+3A_axis.text.x.size">axis.text.x.size</code></td>
<td>
<p>font size of x-axis text</p>
</td></tr>
<tr><td><code id="vizu.mat.factor_+3A_axis.text.y.size">axis.text.y.size</code></td>
<td>
<p>font size of y-axis text</p>
</td></tr>
<tr><td><code id="vizu.mat.factor_+3A_axis.title.x.size">axis.title.x.size</code></td>
<td>
<p>font size of x-axis label</p>
</td></tr>
<tr><td><code id="vizu.mat.factor_+3A_axis.title.y.size">axis.title.y.size</code></td>
<td>
<p>font size of y-axis label</p>
</td></tr>
<tr><td><code id="vizu.mat.factor_+3A_legend.text.size">legend.text.size</code></td>
<td>
<p>font size of legend text</p>
</td></tr>
<tr><td><code id="vizu.mat.factor_+3A_legend.title.size">legend.title.size</code></td>
<td>
<p>font size of legend title</p>
</td></tr>
<tr><td><code id="vizu.mat.factor_+3A_legend.title">legend.title</code></td>
<td>
<p>legend title</p>
</td></tr>
<tr><td><code id="vizu.mat.factor_+3A_text.font.family">text.font.family</code></td>
<td>
<p>font family</p>
</td></tr>
<tr><td><code id="vizu.mat.factor_+3A_remove.legend">remove.legend</code></td>
<td>
<p>logical whether or not remove legend</p>
</td></tr>
<tr><td><code id="vizu.mat.factor_+3A_factor.levels">factor.levels</code></td>
<td>
<p>vector of values defining levels of factors
(might be used to redefine order of variables in the legend)</p>
</td></tr>
<tr><td><code id="vizu.mat.factor_+3A_axis.text.x.breaks.idx">axis.text.x.breaks.idx</code></td>
<td>
<p>indices of x-axis elements whose thicks are kept
and whose numerical labels are kept</p>
</td></tr>
<tr><td><code id="vizu.mat.factor_+3A_axis.text.y.breaks.idx">axis.text.y.breaks.idx</code></td>
<td>
<p>indices of y-axis elements whose thicks are kept
and whose numerical labels are kept</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ggplot2</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- diag(30)
vizu.mat.factor(mat)
vizu.mat.factor(mat, 
                title = "some title",
                scale_fill_manual.values = c("white","red"),
                axis.text.x.breaks.idx = seq(1,30,5),
                axis.text.y.breaks.idx = seq(1,30,5))
vizu.mat.factor(mat, 
                title = "some title: large font, legend: small font",
                base_size = 20, 
                legend.text.size  = 10, 
                legend.title.size = 10)
vizu.mat.factor(mat, 
                scale_fill_manual.values = c("white","red"),
                clear.labels = FALSE) 
colnames(mat) &lt;- paste0("col", 1:30, sample(LETTERS, 30, replace = TRUE))
rownames(mat) &lt;- paste0("row", 1:30, sample(LETTERS, 30, replace = TRUE))
vizu.mat.factor(mat, 
                clear.labels = FALSE,
                rotate.x.labels = TRUE) 

</code></pre>

<hr>
<h2 id='vrPEER'>Graph-constrained regression with variable-reduction procedure to handle the non-invertibility of
a graph-originated penalty matrix</h2><span id='topic+vrPEER'></span>

<h3>Description</h3>

<p>Graph-constrained regression with variable-reduction procedure to handle the non-invertibility of
a graph-originated penalty matrix (see: References).
</p>
<p>Bootstrap confidence intervals computation is available (not set as a default option).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vrPEER(Q, y, Z, X = NULL, sv.thr = 1e-05, compute.boot.CI = FALSE,
  boot.R = 1000, boot.conf = 0.95, boot.set.seed = TRUE,
  boot.parallel = "multicore", boot.ncpus = 4, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vrPEER_+3A_q">Q</code></td>
<td>
<p>graph-originated penalty matrix <code class="reqn">(p \times p)</code>; typically: a graph Laplacian matrix</p>
</td></tr>
<tr><td><code id="vrPEER_+3A_y">y</code></td>
<td>
<p>response values matrix <code class="reqn">(n \times 1)</code></p>
</td></tr>
<tr><td><code id="vrPEER_+3A_z">Z</code></td>
<td>
<p>design matrix <code class="reqn">(n \times p)</code> modeled as random effects variables (to be penalized in regression modeling);
<strong>assumed to be already standarized</strong></p>
</td></tr>
<tr><td><code id="vrPEER_+3A_x">X</code></td>
<td>
<p>design matrix <code class="reqn">(n \times k)</code> modeled as fixed effects variables (not to be penalized in regression modeling);
<strong>should contain colum of 1s if intercept is to be considered in a model</strong></p>
</td></tr>
<tr><td><code id="vrPEER_+3A_sv.thr">sv.thr</code></td>
<td>
<p>threshold value above which singular values of <code>Q</code> are considered &quot;zeros&quot;</p>
</td></tr>
<tr><td><code id="vrPEER_+3A_compute.boot.ci">compute.boot.CI</code></td>
<td>
<p>logical whether or not compute bootstrap confidence intervals for <code class="reqn">b</code> regression coefficient estimates</p>
</td></tr>
<tr><td><code id="vrPEER_+3A_boot.r">boot.R</code></td>
<td>
<p>number of bootstrap replications used in bootstrap confidence intervals computation</p>
</td></tr>
<tr><td><code id="vrPEER_+3A_boot.conf">boot.conf</code></td>
<td>
<p>confidence level assumed in bootstrap confidence intervals computation</p>
</td></tr>
<tr><td><code id="vrPEER_+3A_boot.set.seed">boot.set.seed</code></td>
<td>
<p>logical whether or not set seed in bootstrap confidence intervals computation</p>
</td></tr>
<tr><td><code id="vrPEER_+3A_boot.parallel">boot.parallel</code></td>
<td>
<p>value of <code>parallel</code> argument in <code>boot</code> function in bootstrap confidence intervals computation</p>
</td></tr>
<tr><td><code id="vrPEER_+3A_boot.ncpus">boot.ncpus</code></td>
<td>
<p>value of <code>ncpus</code> argument in <code>boot</code> function in bootstrap confidence intervals computation</p>
</td></tr>
<tr><td><code id="vrPEER_+3A_verbose">verbose</code></td>
<td>
<p>logical whether or not set verbose mode (print out function execution messages)</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>b.est</code></td>
<td>
<p>vector of <code class="reqn">b</code> coefficient estimates</p>
</td></tr>
<tr><td><code>beta.est</code></td>
<td>
<p>vector of <code class="reqn">\beta</code> coefficient estimates</p>
</td></tr>
<tr><td><code>lambda.Q</code></td>
<td>
<p><code class="reqn">\lambda_Q</code> regularization parameter value</p>
</td></tr>
<tr><td><code>boot.CI</code></td>
<td>
<p>data frame with two columns, <code>lower</code> and <code>upper</code>, containing, respectively, values of lower and upper bootstrap confidence intervals for <code class="reqn">b</code> regression coefficient estimates</p>
</td></tr>
</table>


<h3>References</h3>

<p>Karas, M., Brzyski, D., Dzemidzic, M., J., Kareken, D.A., Randolph, T.W., Harezlak, J. (2017).
Brain connectivity-informed regularization methods for regression. doi: https://doi.org/10.1101/117945
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
n &lt;- 200
p1 &lt;- 10
p2 &lt;- 90
p &lt;- p1 + p2
# Define graph adjacency matrix
A &lt;- matrix(rep(0, p*p), nrow = p, ncol = p)
A[1:p1, 1:p1] &lt;- 1
A[(p1+1):p, (p1+1):p] &lt;- 1
L &lt;- Adj2Lap(A)
# Define Q penalty matrix as graph Laplacian matrix normalized)
Q &lt;- L2L.normalized(L)
# Define Z,X design matrices and aoutcome y
Z &lt;- matrix(rnorm(n*p), nrow = n, ncol = p)
b.true &lt;- c(rep(1, p1), rep(0, p2))
X &lt;- matrix(rnorm(n*3), nrow = n, ncol = 3)
beta.true &lt;- runif(3)
intercept &lt;- 0
eta &lt;- intercept + Z %*% b.true + X %*% beta.true
R2 &lt;- 0.5
sd.eps &lt;- sqrt(var(eta) * (1 - R2) / R2)
error &lt;- rnorm(n, sd = sd.eps)
y &lt;- eta + error

## Not run: 
# run vrPEER 
vrPEER.out &lt;- vrPEER(Q, y, Z, X)
plt.df &lt;- data.frame(x = 1:p, 
                     y = vrPEER.out$b.est)
ggplot(plt.df, aes(x = x, y = y, group = 1)) + geom_line()

## End(Not run)

## Not run: 
# run vrPEER with 0.95 confidence intrvals 
vrPEER.out &lt;- vrPEER(Q, y, Z, X, compute.boot.CI = TRUE, boot.R = 500)
plt.df &lt;- data.frame(x = 1:p, 
                     y = vrPEER.out$b.est, 
                     lo = vrPEER.out$boot.CI[,1], 
                     up =  vrPEER.out$boot.CI[,2])
ggplot(plt.df, aes(x = x, y = y, group = 1)) + geom_line() +  
  geom_ribbon(aes(ymin=lo, ymax=up), alpha = 0.3)

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
