<!DOCTYPE html><html><head><title>Help for package cubature</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cubature}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cubature-package'><p>Cubature is a package for adaptive and monte-carlo multidimensional</p>
integration over hypercubes</a></li>
<li><a href='#cubintegrate'><p>Unified Cubature Integration Interface</p></a></li>
<li><a href='#cuhre'><p>Integration by a Deterministic Iterative Adaptive Algorithm</p></a></li>
<li><a href='#default_args'><p>Default arguments for each integration method</p></a></li>
<li><a href='#divonne'><p>Integration by Stratified Sampling for Variance Reduction</p></a></li>
<li><a href='#hcubature'><p>Adaptive multivariate integration over hypercubes (hcubature and pcubature)</p></a></li>
<li><a href='#suave'><p>Integration with SUbregion-Adaptive Vegas Algorithm</p></a></li>
<li><a href='#vegas'><p>Integration by a Monte Carlo Algorithm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Adaptive Multivariate Integration over Hypercubes</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.0</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make and USE_C17</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bnaras.github.io/cubature/">https://bnaras.github.io/cubature/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bnaras/cubature/issues">https://github.com/bnaras/cubature/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>R wrappers around the cubature C library of Steven
    G. Johnson for adaptive multivariate integration over hypercubes
    and the Cuba C library of Thomas Hahn for deterministic and
    Monte Carlo integration. Scalar and vector interfaces for 
    cubature and Cuba routines are provided; the vector interfaces
    are highly recommended as demonstrated in the package
    vignette.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, mvtnorm, benchr, rmarkdown</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-11 18:33:55 UTC; naras</td>
</tr>
<tr>
<td>Author:</td>
<td>Balasubramanian Narasimhan [aut, cre],
  Manuel Koller [ctb],
  Steven G. Johnson [aut],
  Thomas Hahn [aut],
  Annie Bouvier [aut],
  Kiên Kiêu [aut],
  Simen Gaure [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Balasubramanian Narasimhan &lt;naras@stat.stanford.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-11 20:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cubature-package'>Cubature is a package for adaptive and monte-carlo multidimensional
integration over hypercubes</h2><span id='topic+cubature-package'></span><span id='topic+cubature'></span>

<h3>Description</h3>

<p>Cubature is a package for adaptive and monte-carlo multidimensional
integration over hypercubes. It is a wrapper around the pure C,
GPLed implementations by Steven G. Johnson (cubature) and Thomas
Hahn (Cuba) libraries.
</p>


<h3>Author(s)</h3>

<p>C code by Steven G. Johnson and Thomas Hahn, R by Balasubramanian Narasimhan, Manuel Koller, Simen Gaure, Kiên Kiêu, and Annie Bouvier
</p>
<p>Maintainer: Balasubramanian Narasimhan<a href="mailto:naras@stat.stanford.edu">naras@stat.stanford.edu</a>
</p>

<hr>
<h2 id='cubintegrate'>Unified Cubature Integration Interface</h2><span id='topic+cubintegrate'></span>

<h3>Description</h3>

<p>Integrate a function within specified limits using method
specified. Further arguments specific to method as well as other
arguments to f may be passed. For defaults used in each method, see
help on the method or <code><a href="#topic+default_args">default_args()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cubintegrate(
  f,
  lower,
  upper,
  fDim = 1,
  method = c("hcubature", "pcubature", "cuhre", "divonne", "suave", "vegas"),
  relTol = 1e-05,
  absTol = 1e-12,
  maxEval = 10^6,
  nVec = 1L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubintegrate_+3A_f">f</code></td>
<td>
<p>The function (integrand) to be integrated. Can be
vectorized version, but the additional arguments <code>...</code>
must indicate via either <code>vectorInterface = TRUE</code> for
<code>hcubature</code> and <code>pcubature</code>, or a value for <code>nVec</code>. See
details on each method.</p>
</td></tr>
<tr><td><code id="cubintegrate_+3A_lower">lower</code></td>
<td>
<p>The lower limit of integration, a vector for
hypercubes.</p>
</td></tr>
<tr><td><code id="cubintegrate_+3A_upper">upper</code></td>
<td>
<p>The upper limit of integration, a vector for
hypercubes.</p>
</td></tr>
<tr><td><code id="cubintegrate_+3A_fdim">fDim</code></td>
<td>
<p>The number of components of f, default 1, bears no
relation to the dimension of the hypercube over which
integration is performed.</p>
</td></tr>
<tr><td><code id="cubintegrate_+3A_method">method</code></td>
<td>
<p>the method to use should be one of &quot;hcubature&quot;,
&quot;pcubature&quot;, &quot;cuhre&quot;, &quot;divonne&quot;, &quot;suave&quot; or &quot;vegas&quot;.</p>
</td></tr>
<tr><td><code id="cubintegrate_+3A_reltol">relTol</code></td>
<td>
<p>The maximum tolerance, default 1e-5.</p>
</td></tr>
<tr><td><code id="cubintegrate_+3A_abstol">absTol</code></td>
<td>
<p>the absolute tolerance, default 1e-12.</p>
</td></tr>
<tr><td><code id="cubintegrate_+3A_maxeval">maxEval</code></td>
<td>
<p>The maximum number of function evaluations needed,
default 10^6.  Note that the actual number of function
evaluations performed is only approximately guaranteed not to
exceed this number.</p>
</td></tr>
<tr><td><code id="cubintegrate_+3A_nvec">nVec</code></td>
<td>
<p>the number of vectorization points for Cuba C library,
default 1, but can be set to an integer &gt; 1 for vectorization,
for example, 1024. The function f above needs to handle the
vector of points appropriately; see vignette examples. Unlike
Cuba, the cubature C library manages the number of points on
its own and can vary between calls. Therefore, any value for
nVec greater than one implies vectorization for a cubature
method.</p>
</td></tr>
<tr><td><code id="cubintegrate_+3A_...">...</code></td>
<td>
<p>All other arguments which may include integration
method specific parameters and those for f. Unrecognized
parameters for integration method are presumed to be intended
for f and so processed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned value is a list of items: -</p>
<table>
<tr><td><code>integral</code></td>
<td>
<p>the
value of the integral</p>
</td></tr></table>
<p> - </p>
<table>
<tr><td><code>error</code></td>
<td>
<p>the estimated absolute
error</p>
</td></tr> <tr><td><code>neval</code></td>
<td>
<p>the number of times the function was
evaluated</p>
</td></tr></table>
<p> - returnCodethe actual integer return code
of the C routine; a non-zero value usually indicates problems;
further interpretation depends on method - </p>
<table>
<tr><td><code>nregions</code></td>
<td>
<p>for
Cuba routines, the actual number of subregions needed</p>
</td></tr>
<tr><td><code>prob</code></td>
<td>
<p>the <code class="reqn">\chi^2</code>-probability (not the
<code class="reqn">\chi^2</code>-value itself!) that <code>error</code> is not a
reliable estimate of the true integration error.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+default_args">default_args()</a></code>, <code><a href="#topic+hcubature">hcubature()</a></code>,
<code><a href="#topic+pcubature">pcubature()</a></code>, <code><a href="#topic+cuhre">cuhre()</a></code>,
<code><a href="#topic+vegas">vegas()</a></code>, <code><a href="#topic+suave">suave()</a></code>, <code><a href="#topic+divonne">divonne()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>I.1d &lt;- function(x) {
  sin(4*x) *
    x * ((x * ( x * (x*x-4) + 1) - 1))
}
I.1d_v &lt;- function(x) {
   matrix(apply(x, 2, function(z)
       sin(4 * z) *
       z * ((z * ( z * (z * z - 4) + 1) - 1))),
       ncol = ncol(x))
}
cubintegrate(f = I.1d, lower = -2, upper = 2, method = "pcubature")
cubintegrate(f = I.1d, lower = -2, upper = 2, method = "cuhre", flags=list(verbose = 2))
cubintegrate(f = I.1d_v, lower = -2, upper = 2, method = "hcubature", nVec = 2L)
cubintegrate(f = I.1d_v, lower = -2, upper = 2, method = "cuhre", nVec = 128L)

</code></pre>

<hr>
<h2 id='cuhre'>Integration by a Deterministic Iterative Adaptive Algorithm</h2><span id='topic+cuhre'></span>

<h3>Description</h3>

<p>Implement a deterministic algorithm for multidimensional numerical
integration. Its algorithm uses one of several cubature rules in a globally
adaptive subdivision scheme.  The subdivision algorithm is similar to
<code><a href="#topic+suave">suave()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cuhre(
  f,
  nComp = 1L,
  lowerLimit,
  upperLimit,
  ...,
  relTol = 1e-05,
  absTol = 1e-12,
  minEval = 0L,
  maxEval = 10^6,
  flags = list(verbose = 0L, final = 1L, keep_state = 0L, level = 0L),
  key = 0L,
  nVec = 1L,
  stateFile = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cuhre_+3A_f">f</code></td>
<td>
<p>The function (integrand) to be integrated. For cuhre, it
can be something as simple as a function of a single argument,
say x.</p>
</td></tr>
<tr><td><code id="cuhre_+3A_ncomp">nComp</code></td>
<td>
<p>The number of components of f, default 1, bears no
relation to the dimension of the hypercube over which
integration is performed.</p>
</td></tr>
<tr><td><code id="cuhre_+3A_lowerlimit">lowerLimit</code></td>
<td>
<p>The lower limit of integration, a vector for
hypercubes.</p>
</td></tr>
<tr><td><code id="cuhre_+3A_upperlimit">upperLimit</code></td>
<td>
<p>The upper limit of integration, a vector for
hypercubes.</p>
</td></tr>
<tr><td><code id="cuhre_+3A_...">...</code></td>
<td>
<p>All other arguments passed to the function f.</p>
</td></tr>
<tr><td><code id="cuhre_+3A_reltol">relTol</code></td>
<td>
<p>The maximum tolerance, default 1e-5.</p>
</td></tr>
<tr><td><code id="cuhre_+3A_abstol">absTol</code></td>
<td>
<p>the absolute tolerance, default 1e-12.</p>
</td></tr>
<tr><td><code id="cuhre_+3A_mineval">minEval</code></td>
<td>
<p>the minimum number of function evaluations required</p>
</td></tr>
<tr><td><code id="cuhre_+3A_maxeval">maxEval</code></td>
<td>
<p>The maximum number of function evaluations needed,
default 10^6.  Note that the actual number of function
evaluations performed is only approximately guaranteed not to
exceed this number.</p>
</td></tr>
<tr><td><code id="cuhre_+3A_flags">flags</code></td>
<td>
<p>flags governing the integration. The list here is
exhaustive to keep the documentation and invocation uniform,
but not all flags may be used for a particular method as noted
below.  List components:
</p>

<dl>
<dt>verbose</dt><dd><p>encodes the verbosity level, from 0 (default) to 3.  Level 0 does not print any output, level 1 prints reasonable information on the progress of the integration, level 2 also echoes the input parameters, and level 3 further prints the subregion results.</p>
</dd>
<dt>final</dt><dd><p>when 0, all sets of samples collected on a subregion during the various iterations or phases contribute to the final result.  When 1, only the last (largest) set of samples is used in the final result.</p>
</dd>
<dt>smooth</dt><dd><p>Applies to Suave and Vegas only. When 0, apply additional smoothing to the importance function, this moderately improves convergence for many integrands.  When 1, use the importance function without smoothing, this should be chosen if the integrand has sharp edges.</p>
</dd>
<dt>keep_state</dt><dd><p>when nonzero, retain state file if argument <code>stateFile</code> is non-null, else delete <code>stateFile</code> if specified.</p>
</dd>
<dt>load_state</dt><dd><p>Applies to Vegas only. Reset the integrator state even if a state file is present, i.e. keep only the grid. Together with <code>keep_state</code> this allows a grid adapted by one integration to be used for another integrand.</p>
</dd>
<dt>level</dt><dd><p>applies only to Divonne, Suave and Vegas. When <code>0</code>, Mersenne Twister random numbers are used. When nonzero Ranlux random numbers are used, except when <code>rngSeed</code> is zero which forces use of Sobol quasi-random numbers. Ranlux implements Marsaglia and Zaman's 24-bit RCARRY algorithm with generation period <code class="reqn">p</code>, i.e. for every 24 generated numbers used, another <code class="reqn">p-24</code> are skipped. The luxury level for the Ranlux generator may be encoded in <code>level</code> as follows:
</p>

<dl>
<dt>Level 1 (p = 48)</dt><dd><p>gives very long period, passes the gap test but fails spectral test</p>
</dd>
<dt>Level 2 (p = 97)</dt><dd><p>passes all known tests, but theoretically still defective</p>
</dd>
<dt>Level 3 (p = 223)</dt><dd><p>any theoretically possible correlations have very small chance of being observed</p>
</dd>
<dt>Level 4 (p = 389)</dt><dd><p>highest possible luxury, all 24 bits chaotic</p>
</dd>
<dt>Levels 5-23</dt><dd><p>default to 3, values above 24 directly specify the period p. Note that Ranlux's original level 0, (mis)used for selecting Mersenne Twister in Cuba, is equivalent to <code>level = 24</code></p>
</dd></dl>
</dd></dl>
</td></tr>
<tr><td><code id="cuhre_+3A_key">key</code></td>
<td>
<p>the quadrature rule key: <code style="white-space: pre;">&#8288;key = 7, 9, 11, 13&#8288;</code>
selects the cubature rule of degree key. Note that the
degree-11 rule is available only in 3 dimensions, the degree-13
rule only in 2 dimensions.  For other values, including the
default 0, the rule is the degree-13 rule in 2 dimensions, the
degree-11 rule in 3 dimensions, and the degree-9 rule
otherwise.</p>
</td></tr>
<tr><td><code id="cuhre_+3A_nvec">nVec</code></td>
<td>
<p>the number of vectorization points, default 1, but can
be set to an integer &gt; 1 for vectorization, for example, 1024
and the function f above needs to handle the vector of points
appropriately. See vignette examples.</p>
</td></tr>
<tr><td><code id="cuhre_+3A_statefile">stateFile</code></td>
<td>
<p>the name of an external file. Vegas can store its
entire internal state (i.e. all the information to resume an
interrupted integration) in an external file.  The state file
is updated after every iteration. If, on a subsequent
invocation, Vegas finds a file of the specified name, it loads
the internal state and continues from the point it left
off. Needless to say, using an existing state file with a
different integrand generally leads to wrong results. Once the
integration finishes successfully, i.e. the prescribed accuracy
is attained, the state file is removed. This feature is useful
mainly to define &lsquo;check-points&rsquo; in long-running
integrations from which the calculation can be restarted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See details in the documentation.
</p>


<h3>Value</h3>

<p>A list with components: </p>
<dl>
<dt>nregions</dt><dd><p>the
actual number of subregions needed</p>
</dd> <dt>neval</dt><dd><p>the actual
number of integrand evaluations needed</p>
</dd> <dt>returnCode</dt><dd><p>if
zero, the desired accuracy was reached, if -1, dimension out of
range, if 1, the accuracy goal was not met within the allowed
maximum number of integrand evaluations.</p>
</dd>
<dt>integral</dt><dd><p>vector of length <code>nComp</code>; the integral of
<code>integrand</code> over the hypercube</p>
</dd> <dt>error</dt><dd><p>vector of
length <code>nComp</code>; the presumed absolute error of
<code>integral</code></p>
</dd> <dt>prob</dt><dd><p>vector of length <code>nComp</code>; the
<code class="reqn">\chi^2</code>-probability (not the
<code class="reqn">\chi^2</code>-value itself!) that <code>error</code> is not a
reliable estimate of the true integration error.</p>
</dd></dl>



<h3>References</h3>

<p>J. Berntsen, T. O. Espelid (1991) An adaptive algorithm for the
approximate calculation of multiple integrals. <em>ACM Transactions on
Mathematical Software</em>, <b>17</b>(4), 437-451.
</p>
<p>T. Hahn (2005) CUBA-a library for multidimensional numerical integration.
<em>Computer Physics Communications</em>, <b>168</b>, 78-95. See <a href="https://feynarts.de/cuba/">https://feynarts.de/cuba/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vegas">vegas()</a></code>, <code><a href="#topic+suave">suave()</a></code>, <code><a href="#topic+divonne">divonne()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>integrand &lt;- function(arg) {
  x &lt;- arg[1]
  y &lt;- arg[2]
  z &lt;- arg[3]
  ff &lt;- sin(x)*cos(y)*exp(z);
return(ff)
} # End integrand

NDIM &lt;- 3
NCOMP &lt;- 1
cuhre(f = integrand,
      lowerLimit = rep(0, NDIM),
      upperLimit = rep(1, NDIM),
      relTol = 1e-3, absTol= 1e-12,
      flags = list(verbose = 2, final = 0))

</code></pre>

<hr>
<h2 id='default_args'>Default arguments for each integration method</h2><span id='topic+default_args'></span>

<h3>Description</h3>

<p>Since each method has a different set of parameters, this function
returns the default values of all parameters that can be modified
and passed to integration routines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_args()
</code></pre>


<h3>Value</h3>

<p>a named list of parameters for each method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>default_args()
</code></pre>

<hr>
<h2 id='divonne'>Integration by Stratified Sampling for Variance Reduction</h2><span id='topic+divonne'></span>

<h3>Description</h3>

<p>Divonne works by stratified sampling, where the partioning of the
integration region is aided by methods from numerical optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>divonne(
  f,
  nComp = 1L,
  lowerLimit,
  upperLimit,
  ...,
  relTol = 1e-05,
  absTol = 1e-12,
  minEval = 0L,
  maxEval = 10^6,
  flags = list(verbose = 0L, final = 1L, keep_state = 0L, level = 0L),
  rngSeed = 0L,
  nVec = 1L,
  key1 = 47L,
  key2 = 1L,
  key3 = 1L,
  maxPass = 5L,
  border = 0,
  maxChisq = 10,
  minDeviation = 0.25,
  xGiven = NULL,
  nExtra = 0L,
  peakFinder = NULL,
  stateFile = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="divonne_+3A_f">f</code></td>
<td>
<p>The function (integrand) to be integrated as in
<code><a href="#topic+cuhre">cuhre()</a></code>. Optionally, the function can take an
additional argument in addition to the variable being
integrated: - <code>cuba_phase</code> - indicating the integration phase:
</p>

<dl>
<dt>0</dt><dd><p>sampling of the points in <code>xgiven</code></p>
</dd>
<dt>1</dt><dd><p>partitioning phase</p>
</dd>
<dt>2</dt><dd><p>final integration phase</p>
</dd>
<dt>3</dt><dd><p>refinement phase</p>
</dd>
</dl>

<p>This information might be useful if
the integrand takes long to compute and a sufficiently accurate
approximation of the integrand is available. The actual value
of the integral is only of minor importance in the partitioning
phase, which is instead much more dependent on the peak
structure of the integrand to find an appropriate
tessellation. An approximation which reproduces the peak
structure while leaving out the fine details might hence be a
perfectly viable and much faster substitute when
<code>cuba_phase &lt; 2</code>. In all other instances, phase can be
ignored and it is entirely admissible to define the integrand
without it.</p>
</td></tr>
<tr><td><code id="divonne_+3A_ncomp">nComp</code></td>
<td>
<p>The number of components of f, default 1, bears no
relation to the dimension of the hypercube over which
integration is performed.</p>
</td></tr>
<tr><td><code id="divonne_+3A_lowerlimit">lowerLimit</code></td>
<td>
<p>The lower limit of integration, a vector for
hypercubes.</p>
</td></tr>
<tr><td><code id="divonne_+3A_upperlimit">upperLimit</code></td>
<td>
<p>The upper limit of integration, a vector for
hypercubes.</p>
</td></tr>
<tr><td><code id="divonne_+3A_...">...</code></td>
<td>
<p>All other arguments passed to the function f.</p>
</td></tr>
<tr><td><code id="divonne_+3A_reltol">relTol</code></td>
<td>
<p>The maximum tolerance, default 1e-5.</p>
</td></tr>
<tr><td><code id="divonne_+3A_abstol">absTol</code></td>
<td>
<p>the absolute tolerance, default 1e-12.</p>
</td></tr>
<tr><td><code id="divonne_+3A_mineval">minEval</code></td>
<td>
<p>the minimum number of function evaluations required</p>
</td></tr>
<tr><td><code id="divonne_+3A_maxeval">maxEval</code></td>
<td>
<p>The maximum number of function evaluations needed,
default 10^6.  Note that the actual number of function
evaluations performed is only approximately guaranteed not to
exceed this number.</p>
</td></tr>
<tr><td><code id="divonne_+3A_flags">flags</code></td>
<td>
<p>flags governing the integration. The list here is
exhaustive to keep the documentation and invocation uniform,
but not all flags may be used for a particular method as noted
below.  List components:
</p>

<dl>
<dt>verbose</dt><dd><p>encodes the verbosity level, from 0 (default) to 3.  Level 0 does not print any output, level 1 prints reasonable information on the progress of the integration, level 2 also echoes the input parameters, and level 3 further prints the subregion results.</p>
</dd>
<dt>final</dt><dd><p>when 0, all sets of samples collected on a subregion during the various iterations or phases contribute to the final result.  When 1, only the last (largest) set of samples is used in the final result.</p>
</dd>
<dt>smooth</dt><dd><p>Applies to Suave and Vegas only. When 0, apply additional smoothing to the importance function, this moderately improves convergence for many integrands.  When 1, use the importance function without smoothing, this should be chosen if the integrand has sharp edges.</p>
</dd>
<dt>keep_state</dt><dd><p>when nonzero, retain state file if argument <code>stateFile</code> is non-null, else delete <code>stateFile</code> if specified.</p>
</dd>
<dt>load_state</dt><dd><p>Applies to Vegas only. Reset the integrator state even if a state file is present, i.e. keep only the grid. Together with <code>keep_state</code> this allows a grid adapted by one integration to be used for another integrand.</p>
</dd>
<dt>level</dt><dd><p>applies only to Divonne, Suave and Vegas. When <code>0</code>, Mersenne Twister random numbers are used. When nonzero Ranlux random numbers are used, except when <code>rngSeed</code> is zero which forces use of Sobol quasi-random numbers. Ranlux implements Marsaglia and Zaman's 24-bit RCARRY algorithm with generation period <code class="reqn">p</code>, i.e. for every 24 generated numbers used, another <code class="reqn">p-24</code> are skipped. The luxury level for the Ranlux generator may be encoded in <code>level</code> as follows:
</p>

<dl>
<dt>Level 1 (p = 48)</dt><dd><p>gives very long period, passes the gap test but fails spectral test</p>
</dd>
<dt>Level 2 (p = 97)</dt><dd><p>passes all known tests, but theoretically still defective</p>
</dd>
<dt>Level 3 (p = 223)</dt><dd><p>any theoretically possible correlations have very small chance of being observed</p>
</dd>
<dt>Level 4 (p = 389)</dt><dd><p>highest possible luxury, all 24 bits chaotic</p>
</dd>
<dt>Levels 5-23</dt><dd><p>default to 3, values above 24 directly specify the period p. Note that Ranlux's original level 0, (mis)used for selecting Mersenne Twister in Cuba, is equivalent to <code>level = 24</code></p>
</dd></dl>
</dd></dl>
</td></tr>
<tr><td><code id="divonne_+3A_rngseed">rngSeed</code></td>
<td>
<p>seed, default 0, for the random number
generator. Note the articulation with <code>level</code> settings for
<code>flag</code></p>
</td></tr>
<tr><td><code id="divonne_+3A_nvec">nVec</code></td>
<td>
<p>the number of vectorization points, default 1, but can
be set to an integer &gt; 1 for vectorization, for example, 1024
and the function f above needs to handle the vector of points
appropriately. See vignette examples.</p>
</td></tr>
<tr><td><code id="divonne_+3A_key1">key1</code></td>
<td>
<p>integer that determines sampling in the partitioning
phase: <code style="white-space: pre;">&#8288;key1 = 7, 9, 11, 13&#8288;</code> selects the cubature rule of
degree <code>key1</code>.  Note that the degree-11 rule is available
only in 3 dimensions, the degree-13 rule only in 2
dimensions. For other values of <code>key1</code>, a quasi-random
sample of <code class="reqn">n=|key1|</code> points is used, where
the sign of <code>key1</code> determines the type of sample,
<code>key1 = 0</code>, use the default rule. <code>key1 &gt; 0</code>, use a
Korobov quasi-random sample, <code>key1 &lt; 0</code>, use a Sobol
quasi-random sample if <code>flags$seed</code> is zero, otherwise a
&ldquo;standard&rdquo; sample (Mersenne Twister) pseudo-random
sample</p>
</td></tr>
<tr><td><code id="divonne_+3A_key2">key2</code></td>
<td>
<p>integer that determines sampling in the final
integration phase: same as <code>key1</code>, but here
<code class="reqn">n=|key2|</code> determines the number of
points, <code class="reqn">n &gt; 39</code>, sample <code class="reqn">n</code> points,
<code class="reqn">n &lt; 40</code>, sample <code class="reqn">n</code>
<code>nneed</code> points, where <code>nneed</code> is the number of points
needed to reach the prescribed accuracy, as estimated by
Divonne from the results of the partitioning phase.</p>
</td></tr>
<tr><td><code id="divonne_+3A_key3">key3</code></td>
<td>
<p>integer that sets the strategy for the refinement
phase: <code>key3 = 0</code>, do not treat the subregion any further.
<code>key3 = 1</code>, split the subregion up once more.  Otherwise,
the subregion is sampled a third time with <code>key3</code>
specifying the sampling parameters exactly as <code>key2</code>
above.</p>
</td></tr>
<tr><td><code id="divonne_+3A_maxpass">maxPass</code></td>
<td>
<p>integer that controls the thoroughness of the
partitioning phase: The partitioning phase terminates when the
estimated total number of integrand evaluations (partitioning
plus final integration) does not decrease for <code>maxPass</code>
successive iterations. A decrease in points generally indicates
that Divonne discovered new structures of the integrand and was
able to find a more effective partitioning. <code>maxPass</code> can
be understood as the number of &ldquo;safety&rdquo; iterations that
are performed before the partition is accepted as final and
counting consequently restarts at zero whenever new structures
are found.</p>
</td></tr>
<tr><td><code id="divonne_+3A_border">border</code></td>
<td>
<p>the relative width of the border of the integration
region.  Points falling into the border region will not be
sampled directly, but will be extrapolated from two samples
from the interior. Use a non-zero <code>border</code> if the
integrand subroutine cannot produce values directly on the
integration boundary. The relative width of the border is
identical in all the dimensions. For example, set
<code>border=0.1</code> for a border of width equal to 10\
width of the integration region.</p>
</td></tr>
<tr><td><code id="divonne_+3A_maxchisq">maxChisq</code></td>
<td>
<p>the maximum <code class="reqn">\chi^2</code> value a single
subregion is allowed to have in the final integration
phase. Regions which fail this <code class="reqn">\chi^2</code> test and
whose sample averages differ by more than <code>min.deviation</code>
move on to the refinement phase.</p>
</td></tr>
<tr><td><code id="divonne_+3A_mindeviation">minDeviation</code></td>
<td>
<p>a bound, given as the fraction of the requested
error of the entire integral, which determines whether it is
worthwhile further examining a region that failed the
<code class="reqn">\chi^2</code> test.  Only if the two sampling averages
obtained for the region differ by more than this bound is the
region further treated.</p>
</td></tr>
<tr><td><code id="divonne_+3A_xgiven">xGiven</code></td>
<td>
<p>a matrix (<code>nDim</code>, <code>nGiven</code>).  A list of
<code>nGiven</code> points where the integrand might have peaks.
Divonne will consider these points when partitioning the
integration region.  The idea here is to help the integrator
find the extrema of the integrand in the presence of very
narrow peaks. Even if only the approximate location of such
peaks is known, this can considerably speed up convergence.</p>
</td></tr>
<tr><td><code id="divonne_+3A_nextra">nExtra</code></td>
<td>
<p>the maximum number of extra points the peak-finder
subroutine will return. If <code>nextra</code> is zero,
<code>peakfinder</code> is not called and an arbitrary object may be
passed in its place, e.g. just 0.</p>
</td></tr>
<tr><td><code id="divonne_+3A_peakfinder">peakFinder</code></td>
<td>
<p>the peak-finder subroutine. This R function is
called whenever a region is up for subdivision and is supposed
to point out possible peaks lying in the region, thus acting as
the dynamic counterpart of the static list of points supplied
in <code>xgiven</code>. It is expected to be declared as
<code style="white-space: pre;">&#8288;peakFinder &lt;- function(bounds, nMax)&#8288;</code> where <code>bounds</code>
is a matrix of dimension <code style="white-space: pre;">&#8288;(2, nDim)&#8288;</code> which contains the
lower (row 1) and upper (row 2) bounds of the subregion.  The
returned value should be a matrix <code style="white-space: pre;">&#8288;(nX, nDim)&#8288;</code> where
<code>nX</code> is the actual number of points (should be less or
equal to <code>nMax</code>).</p>
</td></tr>
<tr><td><code id="divonne_+3A_statefile">stateFile</code></td>
<td>
<p>the name of an external file. Vegas can store its
entire internal state (i.e. all the information to resume an
interrupted integration) in an external file.  The state file
is updated after every iteration. If, on a subsequent
invocation, Vegas finds a file of the specified name, it loads
the internal state and continues from the point it left
off. Needless to say, using an existing state file with a
different integrand generally leads to wrong results. Once the
integration finishes successfully, i.e. the prescribed accuracy
is attained, the state file is removed. This feature is useful
mainly to define &lsquo;check-points&rsquo; in long-running
integrations from which the calculation can be restarted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Divonne uses stratified sampling for variance reduction, that is, it
partitions the integration region such that all subregions have an
approximately equal value of a quantity called the spread (volume times
half-range).
</p>
<p>See details in the documentation.
</p>


<h3>Value</h3>

<p>A list with components: </p>
<dl>
<dt>nregions</dt><dd><p>the actual
number of subregions needed</p>
</dd> <dt>neval</dt><dd><p>the actual number
of integrand evaluations needed</p>
</dd> <dt>returnCode</dt><dd><p>if zero,
the desired accuracy was reached, if -1,
dimension out of range, if 1, the accuracy goal was not met
within the allowed maximum number of integrand evaluations.</p>
</dd>
<dt>integral</dt><dd><p>vector of length <code>nComp</code>; the integral of
<code>integrand</code> over the hypercube</p>
</dd> <dt>error</dt><dd><p>vector of
length <code>nComp</code>; the presumed absolute error of
<code>integral</code></p>
</dd> <dt>prob</dt><dd><p>vector of length <code>nComp</code>;
the <code class="reqn">\chi^2</code>-probability (not the
<code class="reqn">\chi^2</code>-value itself!) that <code>error</code> is not a
reliable estimate of the true integration error.</p>
</dd></dl>



<h3>References</h3>

<p>J. H. Friedman, M. H. Wright (1981) A nested partitioning
procedure for numerical multiple integration. <em>ACM Trans. Math.
Software</em>, <b>7</b>(1), 76-92.
</p>
<p>J. H. Friedman, M. H. Wright (1981) User's guide for DIVONNE. SLAC Report
CGTM-193-REV, CGTM-193, Stanford University.
</p>
<p>T. Hahn (2005) CUBA-a library for multidimensional numerical integration.
<em>Computer Physics Communications</em>, <b>168</b>, 78-95.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cuhre">cuhre()</a></code>, <code><a href="#topic+suave">suave()</a></code>, <code><a href="#topic+vegas">vegas()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>integrand &lt;- function(arg, phase) {
  x &lt;- arg[1]
  y &lt;- arg[2]
  z &lt;- arg[3]
  ff &lt;- sin(x)*cos(y)*exp(z);
return(ff)
}
divonne(integrand, relTol=1e-3,  absTol=1e-12, lowerLimit = rep(0, 3), upperLimit = rep(1, 3),
        flags=list(verbose = 2),  key1= 47)

# Example with a peak-finder function
nDim &lt;- 3L
peakf &lt;- function(bounds, nMax) {
#  print(bounds) # matrix (ndim,2)
  x &lt;- matrix(0, ncol = nMax, nrow = nDim)
   pas &lt;- 1 / (nMax - 1)
   # 1ier point
   x[, 1] &lt;- rep(0, nDim)
   # Les autres points
   for (i in 2L:nMax) {
      x[, i] &lt;- x[, (i - 1)] + pas
    }
  x
} #end peakf

divonne(integrand, relTol=1e-3,  absTol=1e-12,
        lowerLimit = rep(0, 3), upperLimit = rep(1, 3),
        flags=list(verbose = 2),  peakFinder = peakf, nExtra = 4L)
</code></pre>

<hr>
<h2 id='hcubature'>Adaptive multivariate integration over hypercubes (hcubature and pcubature)</h2><span id='topic+hcubature'></span><span id='topic+adaptIntegrate'></span><span id='topic+pcubature'></span>

<h3>Description</h3>

<p>The function performs adaptive multidimensional integration (cubature) of
(possibly) vector-valued integrands over hypercubes. The function includes
a vector interface where the integrand may be evaluated at several hundred
points in a single call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hcubature(
  f,
  lowerLimit,
  upperLimit,
  ...,
  tol = 1e-05,
  fDim = 1,
  maxEval = 0,
  absError = 0,
  doChecking = FALSE,
  vectorInterface = FALSE,
  norm = c("INDIVIDUAL", "PAIRED", "L2", "L1", "LINF")
)

pcubature(
  f,
  lowerLimit,
  upperLimit,
  ...,
  tol = 1e-05,
  fDim = 1,
  maxEval = 0,
  absError = 0,
  doChecking = FALSE,
  vectorInterface = FALSE,
  norm = c("INDIVIDUAL", "PAIRED", "L2", "L1", "LINF")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hcubature_+3A_f">f</code></td>
<td>
<p>The function (integrand) to be integrated</p>
</td></tr>
<tr><td><code id="hcubature_+3A_lowerlimit">lowerLimit</code></td>
<td>
<p>The lower limit of integration, a vector for
hypercubes</p>
</td></tr>
<tr><td><code id="hcubature_+3A_upperlimit">upperLimit</code></td>
<td>
<p>The upper limit of integration, a vector for
hypercubes</p>
</td></tr>
<tr><td><code id="hcubature_+3A_...">...</code></td>
<td>
<p>All other arguments passed to the function f</p>
</td></tr>
<tr><td><code id="hcubature_+3A_tol">tol</code></td>
<td>
<p>The maximum tolerance, default 1e-5.</p>
</td></tr>
<tr><td><code id="hcubature_+3A_fdim">fDim</code></td>
<td>
<p>The dimension of the integrand, default 1, bears no
relation to the dimension of the hypercube</p>
</td></tr>
<tr><td><code id="hcubature_+3A_maxeval">maxEval</code></td>
<td>
<p>The maximum number of function evaluations needed,
default 0 implying no limit. Note that the actual number of
function evaluations performed is only approximately guaranteed
not to exceed this number.</p>
</td></tr>
<tr><td><code id="hcubature_+3A_abserror">absError</code></td>
<td>
<p>The maximum absolute error tolerated</p>
</td></tr>
<tr><td><code id="hcubature_+3A_dochecking">doChecking</code></td>
<td>
<p>As of version 2.0, this flag is ignored and will
be dropped in forthcoming versions</p>
</td></tr>
<tr><td><code id="hcubature_+3A_vectorinterface">vectorInterface</code></td>
<td>
<p>A flag that indicates whether to use the
vector interface and is by default FALSE. See details below</p>
</td></tr>
<tr><td><code id="hcubature_+3A_norm">norm</code></td>
<td>
<p>For vector-valued integrands, <code>norm</code> specifies the
norm that is used to measure the error and determine
convergence properties. See below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function merely calls Johnson's C code and returns the results.
</p>
<p>One can specify a maximum number of function evaluations (default is 0 for
no limit).  Otherwise, the integration stops when the estimated error is
less than the absolute error requested, or when the estimated error is less
than tol times the integral, in absolute value, or the maximum number of
iterations is reached (see parameter info below), whichever is earlier.
</p>
<p>For compatibility with earlier versions, the <code>adaptIntegrate</code> function
is an alias for the underlying <code>hcubature</code> function which uses h-adaptive
integration. Otherwise, the calling conventions are the same.
</p>
<p>We highly recommend referring to the vignette to achieve the best results!
</p>
<p>The <code>hcubature</code> function is the h-adaptive version that recursively partitions
the integration domain into smaller subdomains, applying the same integration
rule to each, until convergence is achieved.
</p>
<p>The p-adaptive version, <code>pcubature</code>, repeatedly doubles the degree
of the quadrature rules until convergence is achieved, and is based on a tensor
product of Clenshaw-Curtis quadrature rules. This algorithm is often superior
to h-adaptive integration for smooth integrands in a few (&lt;=3) dimensions,
but is a poor choice in higher dimensions or for non-smooth integrands.
Compare with <code>hcubature</code> which also takes the same arguments.
</p>
<p>The vector interface requires the integrand to take a matrix as its argument.
The return value should also be a matrix. The number of points at which the
integrand may be evaluated is not under user control: the integration routine
takes care of that and this number may run to several hundreds. We strongly
advise vectorization; see vignette.
</p>
<p>The <code>norm</code> argument is irrelevant for scalar integrands and is ignored.
Given vectors <code class="reqn">v</code> and <code class="reqn">e</code> of estimated integrals and errors therein,
respectively, the <code>norm</code> argument takes on one of the following values:
</p>

<dl>
<dt><code>INDIVIDUAL</code></dt><dd><p>Convergence is achieved only when each integrand
(each component of <code class="reqn">v</code> and <code class="reqn">e</code>) individually satisfies the requested
error tolerances</p>
</dd>
<dt><code>L1</code>, <code>L2</code>, <code>LINF</code></dt><dd><p>The absolute error is measured as
<code class="reqn">|e|</code> and the relative error as <code class="reqn">|e|/|v|</code>, where <code class="reqn">|...|</code> is the
<code class="reqn">L_1</code>, <code class="reqn">L_2</code>, or <code class="reqn">L_{\infty}</code> norm, respectively</p>
</dd>
<dt><code>PAIRED</code></dt><dd><p>Like <code>INDIVIDUAL</code>, except that the integrands are
grouped into consecutive pairs, with the error tolerance applied in an
<code class="reqn">L_2</code> sense to each pair. This option is mainly useful for integrating
vectors of complex numbers, where each consecutive pair of real integrands
is the real and imaginary parts of a single complex integrand, and the concern
is only the error in the complex plane rather than the error in the real and
imaginary parts separately</p>
</dd>
</dl>



<h3>Value</h3>

<p>The returned value is a list of four items:
</p>
<table>
<tr><td><code>integral</code></td>
<td>
<p>the value of the integral</p>
</td></tr> <tr><td><code>error</code></td>
<td>
<p>the
estimated absolute error</p>
</td></tr> <tr><td><code>functionEvaluations</code></td>
<td>
<p>the number
of times the function was evaluated</p>
</td></tr> <tr><td><code>returnCode</code></td>
<td>
<p>the
actual integer return code of the C routine</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Balasubramanian Narasimhan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## Test function 0
## Compare with original cubature result of
## ./cubature_test 2 1e-4 0 0
## 2-dim integral, tolerance = 0.0001
## integrand 0: integral = 0.708073, est err = 1.70943e-05, true err = 7.69005e-09
## #evals = 17

testFn0 &lt;- function(x) {
  prod(cos(x))
}

hcubature(testFn0, rep(0,2), rep(1,2), tol=1e-4)

pcubature(testFn0, rep(0,2), rep(1,2), tol=1e-4)

M_2_SQRTPI &lt;- 2/sqrt(pi)

## Test function 1
## Compare with original cubature result of
## ./cubature_test 3 1e-4 1 0
## 3-dim integral, tolerance = 0.0001
## integrand 1: integral = 1.00001, est err = 9.67798e-05, true err = 9.76919e-06
## #evals = 5115

testFn1 &lt;- function(x) {
  val &lt;- sum (((1-x) / x)^2)
  scale &lt;- prod(M_2_SQRTPI/x^2)
  exp(-val) * scale
}

hcubature(testFn1, rep(0, 3), rep(1, 3), tol=1e-4)
pcubature(testFn1, rep(0, 3), rep(1, 3), tol=1e-4)

##
## Test function 2
## Compare with original cubature result of
## ./cubature_test 2 1e-4 2 0
## 2-dim integral, tolerance = 0.0001
## integrand 2: integral = 0.19728, est err = 1.97261e-05, true err = 4.58316e-05
## #evals = 166141

testFn2 &lt;- function(x) {
  ## discontinuous objective: volume of hypersphere
  radius &lt;- as.double(0.50124145262344534123412)
  ifelse(sum(x*x) &lt; radius*radius, 1, 0)
}

hcubature(testFn2, rep(0, 2), rep(1, 2), tol=1e-4)
pcubature(testFn2, rep(0, 2), rep(1, 2), tol=1e-4)

##
## Test function 3
## Compare with original cubature result of
## ./cubature_test 3 1e-4 3 0
## 3-dim integral, tolerance = 0.0001
## integrand 3: integral = 1, est err = 0, true err = 2.22045e-16
## #evals = 33

testFn3 &lt;- function(x) {
  prod(2*x)
}

hcubature(testFn3, rep(0,3), rep(1,3), tol=1e-4)
pcubature(testFn3, rep(0,3), rep(1,3), tol=1e-4)

##
## Test function 4 (Gaussian centered at 1/2)
## Compare with original cubature result of
## ./cubature_test 2 1e-4 4 0
## 2-dim integral, tolerance = 0.0001
## integrand 4: integral = 1, est err = 9.84399e-05, true err = 2.78894e-06
## #evals = 1853

testFn4 &lt;- function(x) {
  a &lt;- 0.1
  s &lt;- sum((x - 0.5)^2)
  (M_2_SQRTPI / (2. * a))^length(x) * exp (-s / (a * a))
}

hcubature(testFn4, rep(0,2), rep(1,2), tol=1e-4)
pcubature(testFn4, rep(0,2), rep(1,2), tol=1e-4)

##
## Test function 5 (double Gaussian)
## Compare with original cubature result of
## ./cubature_test 3 1e-4 5 0
## 3-dim integral, tolerance = 0.0001
## integrand 5: integral = 0.999994, est err = 9.98015e-05, true err = 6.33407e-06
## #evals = 59631

testFn5 &lt;- function(x) {
  a &lt;- 0.1
  s1 &lt;- sum((x - 1/3)^2)
  s2 &lt;- sum((x - 2/3)^2)
  0.5 * (M_2_SQRTPI / (2. * a))^length(x) * (exp(-s1 / (a * a)) + exp(-s2 / (a * a)))
}

hcubature(testFn5, rep(0,3), rep(1,3), tol=1e-4)
pcubature(testFn5, rep(0,3), rep(1,3), tol=1e-4)

##
## Test function 6 (Tsuda's example)
## Compare with original cubature result of
## ./cubature_test 4 1e-4 6 0
## 4-dim integral, tolerance = 0.0001
## integrand 6: integral = 0.999998, est err = 9.99685e-05, true err = 1.5717e-06
## #evals = 18753

testFn6 &lt;- function(x) {
  a &lt;- (1 + sqrt(10.0)) / 9.0
  prod(a / (a + 1) * ((a + 1) / (a + x))^2)
}

hcubature(testFn6, rep(0,4), rep(1,4), tol=1e-4)
pcubature(testFn6, rep(0,4), rep(1,4), tol=1e-4)


##
## Test function 7
##   test integrand from W. J. Morokoff and R. E. Caflisch, "Quasi=
##   Monte Carlo integration," J. Comput. Phys 122, 218-230 (1995).
##   Designed for integration on [0,1]^dim, integral = 1. */
## Compare with original cubature result of
## ./cubature_test 3 1e-4 7 0
## 3-dim integral, tolerance = 0.0001
## integrand 7: integral = 1.00001, est err = 9.96657e-05, true err = 1.15994e-05
## #evals = 7887

testFn7 &lt;- function(x) {
  n &lt;- length(x)
  p &lt;- 1/n
  (1 + p)^n * prod(x^p)
}

hcubature(testFn7, rep(0,3), rep(1,3), tol=1e-4)
pcubature(testFn7, rep(0,3), rep(1,3), tol=1e-4)


## Example from web page
## http://ab-initio.mit.edu/wiki/index.php/Cubature
##
## f(x) = exp(-0.5(euclidean_norm(x)^2)) over the three-dimensional
## hyperbcube [-2, 2]^3
## Compare with original cubature result
testFnWeb &lt;-  function(x) {
  exp(-0.5 * sum(x^2))
}

hcubature(testFnWeb, rep(-2,3), rep(2,3), tol=1e-4)
pcubature(testFnWeb, rep(-2,3), rep(2,3), tol=1e-4)

## Test function I.1d from
## Numerical integration using Wang-Landau sampling
## Y. W. Li, T. Wust, D. P. Landau, H. Q. Lin
## Computer Physics Communications, 2007, 524-529
## Compare with exact answer: 1.63564436296
##
I.1d &lt;- function(x) {
  sin(4*x) *
    x * ((x * ( x * (x*x-4) + 1) - 1))
}

hcubature(I.1d, -2, 2, tol=1e-7)
pcubature(I.1d, -2, 2, tol=1e-7)

## Test function I.2d from
## Numerical integration using Wang-Landau sampling
## Y. W. Li, T. Wust, D. P. Landau, H. Q. Lin
## Computer Physics Communications, 2007, 524-529
## Compare with exact answer: -0.01797992646
##
##
I.2d &lt;- function(x) {
  x1 = x[1]
  x2 = x[2]
  sin(4*x1+1) * cos(4*x2) * x1 * (x1*(x1*x1)^2 - x2*(x2*x2 - x1) +2)
}

hcubature(I.2d, rep(-1, 2), rep(1, 2), maxEval=10000)
pcubature(I.2d, rep(-1, 2), rep(1, 2), maxEval=10000)

##
## Example of multivariate normal integration borrowed from
## package mvtnorm (on CRAN) to check ... argument
## Compare with output of
## pmvnorm(lower=rep(-0.5, m), upper=c(1,4,2), mean=rep(0, m), corr=sigma, alg=Miwa())
##     0.3341125.  Blazing quick as well!  Ours is, not unexpectedly, much slower.
##
dmvnorm &lt;- function (x, mean, sigma, log = FALSE) {
    if (is.vector(x)) {
        x &lt;- matrix(x, ncol = length(x))
    }
    if (missing(mean)) {
        mean &lt;- rep(0, length = ncol(x))
    }
    if (missing(sigma)) {
        sigma &lt;- diag(ncol(x))
    }
    if (NCOL(x) != NCOL(sigma)) {
        stop("x and sigma have non-conforming size")
    }
    if (!isSymmetric(sigma, tol = sqrt(.Machine$double.eps),
        check.attributes = FALSE)) {
        stop("sigma must be a symmetric matrix")
    }
    if (length(mean) != NROW(sigma)) {
        stop("mean and sigma have non-conforming size")
    }
    distval &lt;- mahalanobis(x, center = mean, cov = sigma)
    logdet &lt;- sum(log(eigen(sigma, symmetric = TRUE, only.values = TRUE)$values))
    logretval &lt;- -(ncol(x) * log(2 * pi) + logdet + distval)/2
    if (log)
        return(logretval)
    exp(logretval)
}

m &lt;- 3
sigma &lt;- diag(3)
sigma[2,1] &lt;- sigma[1, 2] &lt;- 3/5 ; sigma[3,1] &lt;- sigma[1, 3] &lt;- 1/3
sigma[3,2] &lt;- sigma[2, 3] &lt;- 11/15
hcubature(dmvnorm, lower=rep(-0.5, m), upper=c(1,4,2),
                        mean=rep(0, m), sigma=sigma, log=FALSE,
               maxEval=10000)
pcubature(dmvnorm, lower=rep(-0.5, m), upper=c(1,4,2),
                        mean=rep(0, m), sigma=sigma, log=FALSE,
               maxEval=10000)

## End(Not run)

</code></pre>

<hr>
<h2 id='suave'>Integration with SUbregion-Adaptive Vegas Algorithm</h2><span id='topic+suave'></span>

<h3>Description</h3>

<p>Suave uses <code><a href="#topic+vegas">vegas()</a></code>-like importance sampling combined with a
globally adaptive subdivision strategy: Until the requested accuracy is
reached, the region with the largest error at the time is bisected in the
dimension in which the fluctuations of the integrand are reduced most. The
number of new samples in each half is prorated for the fluctuation in that
half.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>suave(
  f,
  nComp = 1L,
  lowerLimit,
  upperLimit,
  ...,
  relTol = 1e-05,
  absTol = 1e-12,
  minEval = 0L,
  maxEval = 10^6,
  flags = list(verbose = 0L, final = 1L, smooth = 0L, keep_state = 0L, level = 0L),
  rngSeed = 0L,
  nVec = 1L,
  nNew = 1000L,
  nMin = 50L,
  flatness = 50,
  stateFile = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="suave_+3A_f">f</code></td>
<td>
<p>The function (integrand) to be integrated as in
<code><a href="#topic+cuhre">cuhre()</a></code>. Optionally, the function can take two
additional arguments in addition to the variable being
integrated: - <code>cuba_weight</code> which is the weight of the
point being sampled, - <code>cuba_iter</code> the current iteration
number. The function author may choose to use these in any
appropriate way or ignore them altogether.</p>
</td></tr>
<tr><td><code id="suave_+3A_ncomp">nComp</code></td>
<td>
<p>The number of components of f, default 1, bears no
relation to the dimension of the hypercube over which
integration is performed.</p>
</td></tr>
<tr><td><code id="suave_+3A_lowerlimit">lowerLimit</code></td>
<td>
<p>The lower limit of integration, a vector for
hypercubes.</p>
</td></tr>
<tr><td><code id="suave_+3A_upperlimit">upperLimit</code></td>
<td>
<p>The upper limit of integration, a vector for
hypercubes.</p>
</td></tr>
<tr><td><code id="suave_+3A_...">...</code></td>
<td>
<p>All other arguments passed to the function f.</p>
</td></tr>
<tr><td><code id="suave_+3A_reltol">relTol</code></td>
<td>
<p>The maximum tolerance, default 1e-5.</p>
</td></tr>
<tr><td><code id="suave_+3A_abstol">absTol</code></td>
<td>
<p>the absolute tolerance, default 1e-12.</p>
</td></tr>
<tr><td><code id="suave_+3A_mineval">minEval</code></td>
<td>
<p>the minimum number of function evaluations required</p>
</td></tr>
<tr><td><code id="suave_+3A_maxeval">maxEval</code></td>
<td>
<p>The maximum number of function evaluations needed,
default 10^6.  Note that the actual number of function
evaluations performed is only approximately guaranteed not to
exceed this number.</p>
</td></tr>
<tr><td><code id="suave_+3A_flags">flags</code></td>
<td>
<p>flags governing the integration. The list here is
exhaustive to keep the documentation and invocation uniform,
but not all flags may be used for a particular method as noted
below.  List components:
</p>

<dl>
<dt>verbose</dt><dd><p>encodes the verbosity level, from 0 (default) to 3.  Level 0 does not print any output, level 1 prints reasonable information on the progress of the integration, level 2 also echoes the input parameters, and level 3 further prints the subregion results.</p>
</dd>
<dt>final</dt><dd><p>when 0, all sets of samples collected on a subregion during the various iterations or phases contribute to the final result.  When 1, only the last (largest) set of samples is used in the final result.</p>
</dd>
<dt>smooth</dt><dd><p>Applies to Suave and Vegas only. When 0, apply additional smoothing to the importance function, this moderately improves convergence for many integrands.  When 1, use the importance function without smoothing, this should be chosen if the integrand has sharp edges.</p>
</dd>
<dt>keep_state</dt><dd><p>when nonzero, retain state file if argument <code>stateFile</code> is non-null, else delete <code>stateFile</code> if specified.</p>
</dd>
<dt>load_state</dt><dd><p>Applies to Vegas only. Reset the integrator state even if a state file is present, i.e. keep only the grid. Together with <code>keep_state</code> this allows a grid adapted by one integration to be used for another integrand.</p>
</dd>
<dt>level</dt><dd><p>applies only to Divonne, Suave and Vegas. When <code>0</code>, Mersenne Twister random numbers are used. When nonzero Ranlux random numbers are used, except when <code>rngSeed</code> is zero which forces use of Sobol quasi-random numbers. Ranlux implements Marsaglia and Zaman's 24-bit RCARRY algorithm with generation period <code class="reqn">p</code>, i.e. for every 24 generated numbers used, another <code class="reqn">p-24</code> are skipped. The luxury level for the Ranlux generator may be encoded in <code>level</code> as follows:
</p>

<dl>
<dt>Level 1 (p = 48)</dt><dd><p>gives very long period, passes the gap test but fails spectral test</p>
</dd>
<dt>Level 2 (p = 97)</dt><dd><p>passes all known tests, but theoretically still defective</p>
</dd>
<dt>Level 3 (p = 223)</dt><dd><p>any theoretically possible correlations have very small chance of being observed</p>
</dd>
<dt>Level 4 (p = 389)</dt><dd><p>highest possible luxury, all 24 bits chaotic</p>
</dd>
<dt>Levels 5-23</dt><dd><p>default to 3, values above 24 directly specify the period p. Note that Ranlux's original level 0, (mis)used for selecting Mersenne Twister in Cuba, is equivalent to <code>level = 24</code></p>
</dd></dl>
</dd></dl>
</td></tr>
<tr><td><code id="suave_+3A_rngseed">rngSeed</code></td>
<td>
<p>seed, default 0, for the random number
generator. Note the articulation with <code>level</code> settings for
<code>flag</code></p>
</td></tr>
<tr><td><code id="suave_+3A_nvec">nVec</code></td>
<td>
<p>the number of vectorization points, default 1, but can
be set to an integer &gt; 1 for vectorization, for example, 1024
and the function f above needs to handle the vector of points
appropriately. See vignette examples.</p>
</td></tr>
<tr><td><code id="suave_+3A_nnew">nNew</code></td>
<td>
<p>the number of new integrand evaluations in each
subdivision.</p>
</td></tr>
<tr><td><code id="suave_+3A_nmin">nMin</code></td>
<td>
<p>the minimum number of samples a former pass must
contribute to a subregion to be considered in that region's
compound integral value. Increasing nmin may reduce jumps in
the <code class="reqn">\chi^2</code> value.</p>
</td></tr>
<tr><td><code id="suave_+3A_flatness">flatness</code></td>
<td>
<p>the parameter p, or the type of norm used to
compute the fluctuation of a sample. This determines how
prominently &quot;outliers,&quot; i.e. individual samples with a large
fluctuation, figure in the total fluctuation, which in turn
determines how a region is split up. As suggested by its name,
flatness should be chosen large for &quot;flat&quot; integrands and small
for &quot;volatile&quot; integrands with high peaks. Note that since
flatness appears in the exponent, one should not use too large
values (say, no more than a few hundred) lest terms be
truncated internally to prevent overflow.</p>
</td></tr>
<tr><td><code id="suave_+3A_statefile">stateFile</code></td>
<td>
<p>the name of an external file. Vegas can store its
entire internal state (i.e. all the information to resume an
interrupted integration) in an external file.  The state file
is updated after every iteration. If, on a subsequent
invocation, Vegas finds a file of the specified name, it loads
the internal state and continues from the point it left
off. Needless to say, using an existing state file with a
different integrand generally leads to wrong results. Once the
integration finishes successfully, i.e. the prescribed accuracy
is attained, the state file is removed. This feature is useful
mainly to define &lsquo;check-points&rsquo; in long-running
integrations from which the calculation can be restarted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See details in the documentation.
</p>


<h3>Value</h3>

<p>A list with components: </p>
<dl>
<dt>nregions</dt><dd><p>the actual
number of subregions needed</p>
</dd> <dt>neval</dt><dd><p>the actual number
of integrand evaluations needed</p>
</dd> <dt>returnCode</dt><dd><p>if zero,
the desired accuracy was reached, if -1,
dimension out of range, if 1, the accuracy goal was not met
within the allowed maximum number of integrand evaluations.</p>
</dd>
<dt>integral</dt><dd><p>vector of length <code>nComp</code>; the integral of
<code>integrand</code> over the hypercube</p>
</dd> <dt>error</dt><dd><p>vector of
length <code>nComp</code>; the presumed absolute error of
<code>integral</code></p>
</dd> <dt>prob</dt><dd><p>vector of length <code>nComp</code>;
the <code class="reqn">\chi^2</code>-probability (not the
<code class="reqn">\chi^2</code>-value itself!) that <code>error</code> is not a
reliable estimate of the true integration error.</p>
</dd></dl>



<h3>References</h3>

<p>T. Hahn (2005) CUBA-a library for multidimensional numerical
integration. <em>Computer Physics Communications</em>, <b>168</b>, 78-95.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cuhre">cuhre()</a></code>, <code><a href="#topic+divonne">divonne()</a></code>, <code><a href="#topic+vegas">vegas()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
integrand &lt;- function(arg) {
  x &lt;- arg[1]
  y &lt;- arg[2]
  z &lt;- arg[3]
  ff &lt;- sin(x)*cos(y)*exp(z);
return(ff)
} # end integrand
suave(integrand, lowerLimit = rep(0, 3), upperLimit = rep(1, 3),
             relTol=1e-3,  absTol=1e-12,
             flags=list(verbose=2, final=0))

</code></pre>

<hr>
<h2 id='vegas'>Integration by a Monte Carlo Algorithm</h2><span id='topic+vegas'></span>

<h3>Description</h3>

<p>Implement a Monte Carlo algorithm for multidimensional numerical
integration.  This algorithm uses importance sampling as a
variance-reduction technique. Vegas iteratively builds up a
piecewise constant weight function, represented on a rectangular
grid. Each iteration consists of a sampling step followed by a
refinement of the grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vegas(
  f,
  nComp = 1L,
  lowerLimit,
  upperLimit,
  ...,
  relTol = 1e-05,
  absTol = 1e-12,
  minEval = 0L,
  maxEval = 10^6,
  flags = list(verbose = 0L, final = 1L, smooth = 0L, keep_state = 0L, load_state = 0L,
    level = 0L),
  rngSeed = 12345L,
  nVec = 1L,
  nStart = 1000L,
  nIncrease = 500L,
  nBatch = 1000L,
  gridNo = 0L,
  stateFile = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vegas_+3A_f">f</code></td>
<td>
<p>The function (integrand) to be integrated as in
<code><a href="#topic+cuhre">cuhre()</a></code>. Optionally, the function can take two
additional arguments in addition to the variable being
integrated: - <code>cuba_weight</code> which is the weight of the
point being sampled, - <code>cuba_iter</code> the current iteration
number. The function author may choose to use these in any
appropriate way or ignore them altogether.</p>
</td></tr>
<tr><td><code id="vegas_+3A_ncomp">nComp</code></td>
<td>
<p>The number of components of f, default 1, bears no
relation to the dimension of the hypercube over which
integration is performed.</p>
</td></tr>
<tr><td><code id="vegas_+3A_lowerlimit">lowerLimit</code></td>
<td>
<p>The lower limit of integration, a vector for
hypercubes.</p>
</td></tr>
<tr><td><code id="vegas_+3A_upperlimit">upperLimit</code></td>
<td>
<p>The upper limit of integration, a vector for
hypercubes.</p>
</td></tr>
<tr><td><code id="vegas_+3A_...">...</code></td>
<td>
<p>All other arguments passed to the function f.</p>
</td></tr>
<tr><td><code id="vegas_+3A_reltol">relTol</code></td>
<td>
<p>The maximum tolerance, default 1e-5.</p>
</td></tr>
<tr><td><code id="vegas_+3A_abstol">absTol</code></td>
<td>
<p>the absolute tolerance, default 1e-12.</p>
</td></tr>
<tr><td><code id="vegas_+3A_mineval">minEval</code></td>
<td>
<p>the minimum number of function evaluations required</p>
</td></tr>
<tr><td><code id="vegas_+3A_maxeval">maxEval</code></td>
<td>
<p>The maximum number of function evaluations needed,
default 10^6.  Note that the actual number of function
evaluations performed is only approximately guaranteed not to
exceed this number.</p>
</td></tr>
<tr><td><code id="vegas_+3A_flags">flags</code></td>
<td>
<p>flags governing the integration. The list here is
exhaustive to keep the documentation and invocation uniform,
but not all flags may be used for a particular method as noted
below.  List components:
</p>

<dl>
<dt>verbose</dt><dd><p>encodes the verbosity level, from 0 (default) to 3.  Level 0 does not print any output, level 1 prints reasonable information on the progress of the integration, level 2 also echoes the input parameters, and level 3 further prints the subregion results.</p>
</dd>
<dt>final</dt><dd><p>when 0, all sets of samples collected on a subregion during the various iterations or phases contribute to the final result.  When 1, only the last (largest) set of samples is used in the final result.</p>
</dd>
<dt>smooth</dt><dd><p>Applies to Suave and Vegas only. When 0, apply additional smoothing to the importance function, this moderately improves convergence for many integrands.  When 1, use the importance function without smoothing, this should be chosen if the integrand has sharp edges.</p>
</dd>
<dt>keep_state</dt><dd><p>when nonzero, retain state file if argument <code>stateFile</code> is non-null, else delete <code>stateFile</code> if specified.</p>
</dd>
<dt>load_state</dt><dd><p>Applies to Vegas only. Reset the integrator state even if a state file is present, i.e. keep only the grid. Together with <code>keep_state</code> this allows a grid adapted by one integration to be used for another integrand.</p>
</dd>
<dt>level</dt><dd><p>applies only to Divonne, Suave and Vegas. When <code>0</code>, Mersenne Twister random numbers are used. When nonzero Ranlux random numbers are used, except when <code>rngSeed</code> is zero which forces use of Sobol quasi-random numbers. Ranlux implements Marsaglia and Zaman's 24-bit RCARRY algorithm with generation period <code class="reqn">p</code>, i.e. for every 24 generated numbers used, another <code class="reqn">p-24</code> are skipped. The luxury level for the Ranlux generator may be encoded in <code>level</code> as follows:
</p>

<dl>
<dt>Level 1 (p = 48)</dt><dd><p>gives very long period, passes the gap test but fails spectral test</p>
</dd>
<dt>Level 2 (p = 97)</dt><dd><p>passes all known tests, but theoretically still defective</p>
</dd>
<dt>Level 3 (p = 223)</dt><dd><p>any theoretically possible correlations have very small chance of being observed</p>
</dd>
<dt>Level 4 (p = 389)</dt><dd><p>highest possible luxury, all 24 bits chaotic</p>
</dd>
<dt>Levels 5-23</dt><dd><p>default to 3, values above 24 directly specify the period p. Note that Ranlux's original level 0, (mis)used for selecting Mersenne Twister in Cuba, is equivalent to <code>level = 24</code></p>
</dd></dl>
</dd></dl>
</td></tr>
<tr><td><code id="vegas_+3A_rngseed">rngSeed</code></td>
<td>
<p>seed, default 0, for the random number
generator. Note the articulation with <code>level</code> settings for
<code>flag</code></p>
</td></tr>
<tr><td><code id="vegas_+3A_nvec">nVec</code></td>
<td>
<p>the number of vectorization points, default 1, but can
be set to an integer &gt; 1 for vectorization, for example, 1024
and the function f above needs to handle the vector of points
appropriately. See vignette examples.</p>
</td></tr>
<tr><td><code id="vegas_+3A_nstart">nStart</code></td>
<td>
<p>the number of integrand evaluations per iteration to
start with.</p>
</td></tr>
<tr><td><code id="vegas_+3A_nincrease">nIncrease</code></td>
<td>
<p>the increase in the number of integrand
evaluations per iteration. The j-th iteration evaluates the
integrand at nStart+(j-1)*nincrease points.</p>
</td></tr>
<tr><td><code id="vegas_+3A_nbatch">nBatch</code></td>
<td>
<p>Vegas samples points not all at once, but in batches
of a predetermined size, to avoid excessive memory
consumption. <code>nbatch</code> is the number of points sampled in
each batch. Tuning this number should usually not be necessary
as performance is affected significantly only as far as the
batch of samples fits into the CPU cache.</p>
</td></tr>
<tr><td><code id="vegas_+3A_gridno">gridNo</code></td>
<td>
<p>an integer.  Vegas may accelerate convergence to keep
the grid accumulated during one integration for the next one,
if the integrands are reasonably similar to each other. Vegas
maintains an internal table with space for ten grids for this
purpose.  If <code>gridno</code> is a number between 1 and 10, the
grid is not discarded at the end of the integration, but stored
in the respective slot of the table for a future
invocation. The grid is only re-used if the dimension of the
subsequent integration is the same as the one it originates
from. In repeated invocations it may become necessary to flush
a slot in memory. In this case the negative of the grid number
should be set. Vegas will then start with a new grid and also
restore the grid number to its positive value, such that at the
end of the integration the grid is again stored in the
indicated slot.</p>
</td></tr>
<tr><td><code id="vegas_+3A_statefile">stateFile</code></td>
<td>
<p>the name of an external file. Vegas can store its
entire internal state (i.e. all the information to resume an
interrupted integration) in an external file.  The state file
is updated after every iteration. If, on a subsequent
invocation, Vegas finds a file of the specified name, it loads
the internal state and continues from the point it left
off. Needless to say, using an existing state file with a
different integrand generally leads to wrong results. Once the
integration finishes successfully, i.e. the prescribed accuracy
is attained, the state file is removed. This feature is useful
mainly to define &lsquo;check-points&rsquo; in long-running
integrations from which the calculation can be restarted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See details in the documentation.
</p>


<h3>Value</h3>

<p>A list with components: </p>
<dl>
<dt>nregions</dt><dd><p>the actual
number of subregions needed</p>
</dd> <dt>neval</dt><dd><p>the actual number
of integrand evaluations needed</p>
</dd> <dt>returnCode</dt><dd><p>if zero,
the desired accuracy was reached, if -1,
dimension out of range, if 1, the accuracy goal was not met
within the allowed maximum number of integrand evaluations.</p>
</dd>
<dt>integral</dt><dd><p>vector of length <code>nComp</code>; the integral of
<code>integrand</code> over the hypercube</p>
</dd> <dt>error</dt><dd><p>vector of
length <code>nComp</code>; the presumed absolute error of
<code>integral</code></p>
</dd> <dt>prob</dt><dd><p>vector of length <code>nComp</code>;
the <code class="reqn">\chi^2</code>-probability (not the
<code class="reqn">\chi^2</code>-value itself!) that <code>error</code> is not a
reliable estimate of the true integration error.</p>
</dd></dl>



<h3>References</h3>

<p>G. P. Lepage (1978) A new algorithm for adaptive
multidimensional integration. <em>J. Comput. Phys.</em>, <b>27</b>, 192-210.
</p>
<p>G. P. Lepage (1980) VEGAS - An adaptive multi-dimensional integration
program. Research Report CLNS-80/447. Cornell University, Ithaca, N.-Y.
</p>
<p>T. Hahn (2005) CUBA-a library for multidimensional numerical integration.
<em>Computer Physics Communications</em>, <b>168</b>, 78-95.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cuhre">cuhre()</a></code>, <code><a href="#topic+suave">suave()</a></code>, <code><a href="#topic+divonne">divonne()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
integrand &lt;- function(arg, weight) {
  x &lt;- arg[1]
  y &lt;- arg[2]
  z &lt;- arg[3]
  ff &lt;- sin(x)*cos(y)*exp(z);
return(ff)
} # end integrand
vegas(integrand, lowerLimit = rep(0, 3), upperLimit = rep(1, 3),
             relTol=1e-3,  absTol=1e-12,
             flags=list(verbose=2, final=0))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
