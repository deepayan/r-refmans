<!DOCTYPE html><html lang="en"><head><title>Help for package adw</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {adw}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adw'><p>Angular Distance Weighting Interpolation.</p></a></li>
<li><a href='#adw_sf'><p>Angular Distance Weighting Interpolation for the extent of 'simple feature'.</p></a></li>
<li><a href='#adw_sv'><p>Angular Distance Weighting Interpolation for the extent of 'SpatVector'.</p></a></li>
<li><a href='#adw_vector'><p>Angular Distance Weighting Interpolation for the extent of vector.</p></a></li>
<li><a href='#awa'><p>Area weighted average.</p></a></li>
<li><a href='#points2grid'><p>Points were to converted grids using a local gridding method.</p></a></li>
<li><a href='#points2grid_sf'><p>Points were to converted grids using a local gridding method.</p></a></li>
<li><a href='#points2grid_sv'><p>Points were to converted grids using a local gridding method.</p></a></li>
<li><a href='#points2grid_vector'><p>Points were to converted grids using a local gridding method.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Angular Distance Weighting Interpolation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Panfeng Zhang &lt;zhangpanfeng@jlnu.edu.cn&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The irregularly-spaced data are interpolated onto regular latitude-longitude grids by weighting each station according to its distance and angle from the center of a search radius. In addition to this, we also provide a simple way (Jones and Hulme, 1996) to grid the irregularly-spaced data points onto regular latitude-longitude grids by averaging all stations in grid-boxes.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/PanfengZhang/adw">https://github.com/PanfengZhang/adw</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/PanfengZhang/adw/issues">https://github.com/PanfengZhang/adw/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, sf, terra, cnmap</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, ggplot2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-15 16:34:07 UTC; zhang</td>
</tr>
<tr>
<td>Author:</td>
<td>Panfeng Zhang <a href="https://orcid.org/0000-0001-6084-9231"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Guoyu Ren [ctb],
  Yun Qin [ctb],
  Chenchen Ren [ctb],
  Xiang Zheng [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-15 19:10:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='adw'>Angular Distance Weighting Interpolation.</h2><span id='topic+adw'></span>

<h3>Description</h3>

<p>The irregularly-spaced data are interpolated onto regular latitude-longitude
grids by weighting each station according to its distance and angle from the
center of a search radius.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adw(ds, extent, gridsize = 5, cdd = 1000, m = 4, nmin = 3, nmax = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adw_+3A_ds">ds</code></td>
<td>
<p>a input dataframe which contains the column names of lon, lat, value.</p>
</td></tr>
<tr><td><code id="adw_+3A_extent">extent</code></td>
<td>
<p>a extent numeric vector (latitude and longitude) of length 4 in
the order c(xmin, xmax, ymin, ymax), or a polygon object with class 'sf'
(package 'sf'),  or a polygon object with class 'SpatVector' (package 'terra').
Assume that the coordinate reference system is WGS1984 (EPSG: 4326).</p>
</td></tr>
<tr><td><code id="adw_+3A_gridsize">gridsize</code></td>
<td>
<p>the grid size, i.e. the grid resolution. units: degree.</p>
</td></tr>
<tr><td><code id="adw_+3A_cdd">cdd</code></td>
<td>
<p>correlation decay distance, i.e. the maximum search radius.
unit: kilometer. default value: 1000km.</p>
</td></tr>
<tr><td><code id="adw_+3A_m">m</code></td>
<td>
<p>is used to adjust the weighting function further, higher values of m
increase the rate at which the weight decays with distance. default value 4.</p>
</td></tr>
<tr><td><code id="adw_+3A_nmin">nmin</code></td>
<td>
<p>the minimum number of observation points required to interpolate
a grid within the search radius (i.e. cdd); if the number of stations within
the search ridius (cdd) is less than nmin, a missing value will be generated
to fill this grid. default value 3.</p>
</td></tr>
<tr><td><code id="adw_+3A_nmax">nmax</code></td>
<td>
<p>The number of nearest points within the search radius to use for
interpolation. default value 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a regular latitude-longitude dataframe grid (interpoled values).
</p>


<h3>References</h3>

<p>Caesar, J., L. Alexander, and R. Vose, 2006: Large-scale changes in observed daily maximum and minimum temperatures: Creation and analysis of a new gridded data set. Journal of Geophysical Research, 111, https://doi.org/10.1029/2005JD006280.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2)
dd &lt;- data.frame(lon = runif(100, min = 110, max = 117),
                 lat = runif(100, min = 31, max = 37),
                 value = runif(100, min = -10, max = 10))
head(dd)

# example 1
grd &lt;- adw(dd, extent = c(110, 117, 31, 37), gridsize = 0.5, cdd = 500)
head(grd)

# example 2
hmap &lt;- cnmap::getMap(code = "410000") |&gt; sf::st_make_valid() # return a 'sf' object.
grd &lt;- adw(dd, extent = hmap, gridsize = 0.5, cdd = 500)
head(grd)

# example 3
hmap &lt;- cnmap::getMap(code = "410000", returnClass = "sv") # return a 'SpatVector' object.
grd &lt;- adw(dd, extent = hmap, gridsize = 0.5, cdd = 500)
head(grd)
</code></pre>

<hr>
<h2 id='adw_sf'>Angular Distance Weighting Interpolation for the extent of 'simple feature'.</h2><span id='topic+adw_sf'></span>

<h3>Description</h3>

<p>The irregularly-spaced data are interpolated onto regular latitude-longitude
grids by weighting each station according to its distance and angle from the
center of a search radius.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adw_sf(ds, extent, gridsize = 5, cdd = 1000, m = 4, nmin = 3, nmax = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adw_sf_+3A_ds">ds</code></td>
<td>
<p>a input dataframe which contains the column names of lon, lat, value.</p>
</td></tr>
<tr><td><code id="adw_sf_+3A_extent">extent</code></td>
<td>
<p>a polygon object with class 'sf' (package 'sf'). Assume that
the coordinate reference system is WGS1984 (EPSG: 4326).</p>
</td></tr>
<tr><td><code id="adw_sf_+3A_gridsize">gridsize</code></td>
<td>
<p>the grid size, i.e. the grid resolution. units: degree.</p>
</td></tr>
<tr><td><code id="adw_sf_+3A_cdd">cdd</code></td>
<td>
<p>correlation decay distance, i.e. the maximum search radius.
unit: kilometer. default value: 1000km.</p>
</td></tr>
<tr><td><code id="adw_sf_+3A_m">m</code></td>
<td>
<p>is used to adjust the weighting function further, higher values of m
increase the rate at which the weight decays with distance. default value 4.</p>
</td></tr>
<tr><td><code id="adw_sf_+3A_nmin">nmin</code></td>
<td>
<p>the minimum number of observation points required to interpolate
a grid within the search radius (i.e. cdd); if the number of stations within
the search ridius (cdd) is less than nmin, a missing value will be generated
to fill this grid. default value 3.</p>
</td></tr>
<tr><td><code id="adw_sf_+3A_nmax">nmax</code></td>
<td>
<p>The number of nearest points within the search radius to use for
interpolation. default value 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a regular latitude-longitude dataframe grid (interpoled values).
</p>


<h3>References</h3>

<p>Caesar, J., L. Alexander, and R. Vose, 2006: Large-scale changes in observed daily maximum and minimum temperatures: Creation and analysis of a new gridded data set. Journal of Geophysical Research, 111, https://doi.org/10.1029/2005JD006280.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2)
dd &lt;- data.frame(lon = runif(100, min = 110, max = 117),
                 lat = runif(100, min = 31, max = 37),
                 value = runif(100, min = -10, max = 10))
head(dd)
hmap &lt;- cnmap::getMap(code = "410000") |&gt; sf::st_make_valid() # return a 'sf' object.
grd &lt;- adw_sf(dd, extent = hmap, gridsize = 0.5, cdd = 500)
head(grd)
</code></pre>

<hr>
<h2 id='adw_sv'>Angular Distance Weighting Interpolation for the extent of 'SpatVector'.</h2><span id='topic+adw_sv'></span>

<h3>Description</h3>

<p>The irregularly-spaced data are interpolated onto regular latitude-longitude
grids by weighting each station according to its distance and angle from the
center of a search radius.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adw_sv(ds, extent, gridsize = 5, cdd = 1000, m = 4, nmin = 3, nmax = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adw_sv_+3A_ds">ds</code></td>
<td>
<p>a input dataframe which contains the column names of lon, lat, value.</p>
</td></tr>
<tr><td><code id="adw_sv_+3A_extent">extent</code></td>
<td>
<p>a polygon object with class 'SpatVector' (package 'terra').
Assume that the coordinate reference system is WGS1984 (EPSG: 4326).</p>
</td></tr>
<tr><td><code id="adw_sv_+3A_gridsize">gridsize</code></td>
<td>
<p>the grid size, i.e. the grid resolution. units: degree.</p>
</td></tr>
<tr><td><code id="adw_sv_+3A_cdd">cdd</code></td>
<td>
<p>correlation decay distance, i.e. the maximum search radius.
unit: kilometer. default value: 1000km.</p>
</td></tr>
<tr><td><code id="adw_sv_+3A_m">m</code></td>
<td>
<p>is used to adjust the weighting function further, higher values of m
increase the rate at which the weight decays with distance. default value 4.</p>
</td></tr>
<tr><td><code id="adw_sv_+3A_nmin">nmin</code></td>
<td>
<p>the minimum number of observation points required to interpolate
a grid within the search radius (i.e. cdd); if the number of stations within
the search ridius (cdd) is less than nmin, a missing value will be generated
to fill this grid. default value 3.</p>
</td></tr>
<tr><td><code id="adw_sv_+3A_nmax">nmax</code></td>
<td>
<p>The number of nearest points within the search radius to use for
interpolation. default value 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a regular latitude-longitude dataframe grid (interpoled values).
</p>


<h3>References</h3>

<p>Caesar, J., L. Alexander, and R. Vose, 2006: Large-scale changes in observed daily maximum and minimum temperatures: Creation and analysis of a new gridded data set. Journal of Geophysical Research, 111, https://doi.org/10.1029/2005JD006280.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2)
dd &lt;- data.frame(lon = runif(100, min = 110, max = 117),
                 lat = runif(100, min = 31, max = 37),
                 value = runif(100, min = -10, max = 10))
head(dd)
# example
hmap &lt;- cnmap::getMap(code = "410000", returnClass = "sv") # return a 'SpatVector' object.
grd &lt;- adw_sv(dd, extent = hmap, gridsize = 0.5, cdd = 500)
head(grd)
</code></pre>

<hr>
<h2 id='adw_vector'>Angular Distance Weighting Interpolation for the extent of vector.</h2><span id='topic+adw_vector'></span>

<h3>Description</h3>

<p>The irregularly-spaced data are interpolated onto regular latitude-longitude
grids by weighting each station according to its distance and angle from the
center of a search radius.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adw_vector(ds, extent, gridsize = 5, cdd = 1000, m = 4, nmin = 3, nmax = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adw_vector_+3A_ds">ds</code></td>
<td>
<p>a input dataframe which contains the column names of lon, lat, value.</p>
</td></tr>
<tr><td><code id="adw_vector_+3A_extent">extent</code></td>
<td>
<p>a extent numeric vector (latitude and longitude) of length 4 in
the order c(xmin, xmax, ymin, ymax).</p>
</td></tr>
<tr><td><code id="adw_vector_+3A_gridsize">gridsize</code></td>
<td>
<p>the grid size, i.e. the grid resolution. units: degree.</p>
</td></tr>
<tr><td><code id="adw_vector_+3A_cdd">cdd</code></td>
<td>
<p>correlation decay distance, i.e. the maximum search radius.
unit: kilometer. default value: 1000km.</p>
</td></tr>
<tr><td><code id="adw_vector_+3A_m">m</code></td>
<td>
<p>is used to adjust the weighting function further, higher values of m
increase the rate at which the weight decays with distance. default value 4.</p>
</td></tr>
<tr><td><code id="adw_vector_+3A_nmin">nmin</code></td>
<td>
<p>the minimum number of observation points required to interpolate
a grid within the search radius (i.e. cdd); if the number of stations within
the search ridius (cdd) is less than nmin, a missing value will be generated
to fill this grid. default value 3.</p>
</td></tr>
<tr><td><code id="adw_vector_+3A_nmax">nmax</code></td>
<td>
<p>The number of nearest points within the search radius to use for
interpolation. default value 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a regular latitude-longitude dataframe grid (interpoled values).
</p>


<h3>References</h3>

<p>Caesar, J., L. Alexander, and R. Vose, 2006: Large-scale changes in observed daily maximum and minimum temperatures: Creation and analysis of a new gridded data set. Journal of Geophysical Research, 111, https://doi.org/10.1029/2005JD006280.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2)
dd &lt;- data.frame(lon = runif(100, min = 110, max = 117),
                 lat = runif(100, min = 31, max = 37),
                 value = runif(100, min = -10, max = 10))
head(dd)
# example
grd &lt;- adw_vector(dd, extent = c(110, 117, 31, 37), gridsize = 0.5, cdd = 500)
head(grd)
</code></pre>

<hr>
<h2 id='awa'>Area weighted average.</h2><span id='topic+awa'></span>

<h3>Description</h3>

<p>The large area, or hemispheric, or global averages can be calculated
dependent on the area represented by the grid-point or grid-box. The weight of
latitude-longitude grid-points-boxes should be the cosine of the latitude of
the ith grid-point-box.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>awa(dat, lat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="awa_+3A_dat">dat</code></td>
<td>
<p>a numeric vector of grid data. The missing values are not allowed.</p>
</td></tr>
<tr><td><code id="awa_+3A_lat">lat</code></td>
<td>
<p>a latitude numeric vector of grid data. The cosine of latitude is
used as the weight coefficient.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar value, i.e the value of area weighted average.
</p>


<h3>References</h3>

<p>Jones, P. D., and M. Hulme, 1996: Calculating regional climatic time series for temperature and precipitation: Methods and illustrations. Int. J. Climatol., 16, 361–377, https://doi.org/10.1002/(SICI)1097-0088(199604)16:4&lt;361::AID-JOC53&gt;3.0.CO;2-F.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set.seed(2)
# dd &lt;- data.frame(lon = runif(100, min = 110, max = 117),
#                  lat = runif(100, min = 31, max = 37),
#                  value = runif(100, min = -10, max = 10))
# grd &lt;- points2grid(dd, extent = c(110, 117, 31, 37), gridsize = 0.5)
# grd &lt;- na.omit(grd)
# awa(grd$value, grd$lat) # area weighted average
</code></pre>

<hr>
<h2 id='points2grid'>Points were to converted grids using a local gridding method.</h2><span id='topic+points2grid'></span>

<h3>Description</h3>

<p>the irregularly-spaced data of points are converted onto regular
latitude-longitude grids by averaging all stations in grid-boxes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>points2grid(dd, extent, gridsize = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="points2grid_+3A_dd">dd</code></td>
<td>
<p>a input dataframe which contains the column names of lon, lat, value.</p>
</td></tr>
<tr><td><code id="points2grid_+3A_extent">extent</code></td>
<td>
<p>a extent numeric vector (latitude and longitude) of length 4 in
the order c(xmin, xmax, ymin, ymax), or a polygon object with class 'sf'
(package 'sf'),  or a polygon object with class 'SpatVector' (package 'terra').
Assume that the coordinate reference system is WGS1984 (EPSG: 4326).</p>
</td></tr>
<tr><td><code id="points2grid_+3A_gridsize">gridsize</code></td>
<td>
<p>the grid size, i.e. the grid resolution. units: degree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a regular latitude-longitude dataframe grid (grid values).
</p>


<h3>References</h3>

<p>Jones, P. D., and M. Hulme, 1996: Calculating regional climatic time series for temperature and precipitation: Methods and illustrations. Int. J. Climatol., 16, 361–377, https://doi.org/10.1002/(SICI)1097-0088(199604)16:4&lt;361::AID-JOC53&gt;3.0.CO;2-F.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set.seed(2)
# dd &lt;- data.frame(lon = runif(100, min = 110, max = 117),
#                  lat = runif(100, min = 31, max = 37),
#                  value = runif(100, min = -10, max = 10))
# head(dd)
# 
# # example 1
# grd &lt;- points2grid(dd, extent = c(110, 117, 31, 37), gridsize = 0.5)
# head(grd)
# 
# # example 2
# hmap &lt;- cnmap::getMap(code = "410000", return = "sf") |&gt; sf::st_make_valid()
# grd &lt;- points2grid(dd, extent = hmap, gridsize = 0.5)
# head(grd)
# 
# # example 3
# hmap &lt;- cnmap::getMap(code = "410000", return = "sv")
# grd &lt;- points2grid(dd, extent = hmap, gridsize = 0.5)
# head(grd)
</code></pre>

<hr>
<h2 id='points2grid_sf'>Points were to converted grids using a local gridding method.</h2><span id='topic+points2grid_sf'></span>

<h3>Description</h3>

<p>the irregularly-spaced data of points are converted onto regular
latitude-longitude grids by averaging all stations in grid-boxes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>points2grid_sf(dd, extent, gridsize = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="points2grid_sf_+3A_dd">dd</code></td>
<td>
<p>a input dataframe which contains the column names of lon, lat, value.</p>
</td></tr>
<tr><td><code id="points2grid_sf_+3A_extent">extent</code></td>
<td>
<p>a polygon object of simple feature (come from package 'sf').
Assume that the coordinate reference system is WGS1984 (EPSG: 4326).</p>
</td></tr>
<tr><td><code id="points2grid_sf_+3A_gridsize">gridsize</code></td>
<td>
<p>the grid size, i.e. the grid resolution. units: degree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a regular latitude-longitude dataframe grid (grid values).
</p>


<h3>References</h3>

<p>Jones, P. D., and M. Hulme, 1996: Calculating regional climatic time series for temperature and precipitation: Methods and illustrations. Int. J. Climatol., 16, 361–377, https://doi.org/10.1002/(SICI)1097-0088(199604)16:4&lt;361::AID-JOC53&gt;3.0.CO;2-F.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set.seed(2)
# dd &lt;- data.frame(lon = runif(100, min = 110, max = 117),
#                  lat = runif(100, min = 31, max = 37),
#                  value = runif(100, min = -10, max = 10))
# head(dd)
# # example
# hmap &lt;- cnmap::getMap(code = 410000) |&gt; sf::st_make_valid()
# grd &lt;- points2grid_sf(dd, extent = hmap, gridsize = 0.5)
# head(grd)
</code></pre>

<hr>
<h2 id='points2grid_sv'>Points were to converted grids using a local gridding method.</h2><span id='topic+points2grid_sv'></span>

<h3>Description</h3>

<p>the irregularly-spaced data of points are converted onto regular
latitude-longitude grids by averaging all stations in grid-boxes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>points2grid_sv(dd, extent, gridsize = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="points2grid_sv_+3A_dd">dd</code></td>
<td>
<p>a input dataframe which contains the column names of lon, lat, value.</p>
</td></tr>
<tr><td><code id="points2grid_sv_+3A_extent">extent</code></td>
<td>
<p>a polygon object of SpatVector (from package 'terra').
Assume that the coordinate reference system is WGS1984 (EPSG: 4326).</p>
</td></tr>
<tr><td><code id="points2grid_sv_+3A_gridsize">gridsize</code></td>
<td>
<p>the grid size, i.e. the grid resolution. units: degree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a regular latitude-longitude dataframe grid (grid values).
</p>


<h3>References</h3>

<p>Jones, P. D., and M. Hulme, 1996: Calculating regional climatic time series for temperature and precipitation: Methods and illustrations. Int. J. Climatol., 16, 361–377, https://doi.org/10.1002/(SICI)1097-0088(199604)16:4&lt;361::AID-JOC53&gt;3.0.CO;2-F.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set.seed(2)
# dd &lt;- data.frame(lon = runif(100, min = 110, max = 117),
#                  lat = runif(100, min = 31, max = 37),
#                  value = runif(100, min = -10, max = 10))
# head(dd)
# # example
# hmap &lt;- cnmap::getMap(code = 410000, returnClass = "sv")
# grd &lt;- points2grid_sv(dd, extent = hmap, gridsize = 0.5)
# head(grd)
</code></pre>

<hr>
<h2 id='points2grid_vector'>Points were to converted grids using a local gridding method.</h2><span id='topic+points2grid_vector'></span>

<h3>Description</h3>

<p>The irregularly-spaced data of points are converted onto regular
latitude-longitude grids by averaging all stations in grid-boxes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>points2grid_vector(dd, extent, gridsize = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="points2grid_vector_+3A_dd">dd</code></td>
<td>
<p>a input dataframe which contains the column names of lon, lat, value.</p>
</td></tr>
<tr><td><code id="points2grid_vector_+3A_extent">extent</code></td>
<td>
<p>a extent numeric vector (latitude and longitude) of length 4 in
the order c(xmin, xmax, ymin, ymax).</p>
</td></tr>
<tr><td><code id="points2grid_vector_+3A_gridsize">gridsize</code></td>
<td>
<p>the grid size, i.e. the grid resolution. units: degree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a regular latitude-longitude dataframe grid (grid values).
</p>


<h3>References</h3>

<p>Jones, P. D., and M. Hulme, 1996: Calculating regional climatic time series for temperature and precipitation: Methods and illustrations. Int. J. Climatol., 16, 361–377, https://doi.org/10.1002/(SICI)1097-0088(199604)16:4&lt;361::AID-JOC53&gt;3.0.CO;2-F.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set.seed(2)
# dd &lt;- data.frame(lon = runif(100, min = 110, max = 117),
#                  lat = runif(100, min = 31, max = 37),
#                  value = runif(100, min = -10, max = 10))
# head(dd)
# # example
# grd &lt;- points2grid(dd, extent = c(110, 117, 31, 37), gridsize = 0.5)
# head(grd)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
