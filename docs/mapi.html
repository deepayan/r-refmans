<!DOCTYPE html><html lang="en-US"><head><title>Help for package mapi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mapi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mapi'><p>MAPI, general presentation</p></a></li>
<li><a href='#MAPI_CheckData'><p>Function MAPI_CheckData</p></a></li>
<li><a href='#MAPI_EstimateHalfwidth'><p>Function MAPI_EstimateHalfwidth</p></a></li>
<li><a href='#MAPI_GridAuto'><p>Function MAPI_GridAuto</p></a></li>
<li><a href='#MAPI_GridHexagonal'><p>Function MAPI_GridHexagonal</p></a></li>
<li><a href='#MAPI_Plot'><p>Function MAPI_Plot</p></a></li>
<li><a href='#MAPI_Plot2'><p>Function MAPI_Plot2</p></a></li>
<li><a href='#MAPI_RunAuto'><p>Function MAPI_RunAuto</p></a></li>
<li><a href='#MAPI_RunOnGrid'><p>Function MAPI_RunOnGrid</p></a></li>
<li><a href='#MAPI_Tails'><p>Function MAPI_Tails</p></a></li>
<li><a href='#metric'><p>'metric' test dataset</p></a></li>
<li><a href='#samples'><p>'samples' test dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Mapping Averaged Pairwise Information</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Mapping Averaged Pairwise Information (MAPI) is an
    exploratory method providing graphical representations summarizing the
    spatial variation of pairwise metrics (eg. distance, similarity
    coefficient, ...) computed between georeferenced samples.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www1.montpellier.inra.fr/CBGP/software/MAPI/">https://www1.montpellier.inra.fr/CBGP/software/MAPI/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>sf (&ge; 0.5), data.table (&ge; 1.10), Rcpp (&ge; 0.10.0), parallel
(&ge; 3.3), pbapply (&ge; 1.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>grDevices, ggplot2 (&ge; 2.3), latticeExtra, sp (&ge; 1.3),
progress</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-19 09:20:40 UTC; piry</td>
</tr>
<tr>
<td>Author:</td>
<td>Sylvain Piry <a href="https://orcid.org/0000-0002-7717-7555"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Thomas Campolunghi [aut],
  Florent Cestier [aut],
  Karine Berthier <a href="https://orcid.org/0000-0002-2260-7968"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sylvain Piry &lt;sylvain.piry@inrae.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-19 11:32:42 UTC</td>
</tr>
</table>
<hr>
<h2 id='mapi'>MAPI, general presentation</h2><span id='topic+mapi'></span><span id='topic+mapi-package'></span>

<h3>Description</h3>

<p>MAPI is an exploratory method providing graphical representations of the spatial variation of
pairwise metrics (eg. distance, similarity coefficient, ...) computed between georeferenced samples.
</p>


<h4>Principle</h4>

<p>As schematically illustrated Figure 1, MAPI relies on spatial joins between a hexagonal grid and a network
of georeferenced samples connected by ellipses, i.e. polygons with 32 segments approaching an elliptical shape.
</p>
<p>The shape of the ellipses can be controlled through the eccentricity value and the sample locations can be
&quot;blurred&quot; by applying an error circle of a given radius on the geographic coordinates.
Each elliptical polygon is associated to 1) the value of the pairwise metric computed between the samples
it connects and 2) a weight corresponding to the inverse of its area (i.e. larger ellipses have lower weights).
</p>
<p>Each cell of the grid receives the weighted mean of the pairwise metric values associated to the ellipses intersecting the cell.
</p>

<p><img src="../help/figures/fig3D.png" alt="fig3D.png" /><br />
<em>Figure 1: Schematic principle of the MAPI method from Piry et al. 2016.</em>
</p>


<h4>Input data</h4>

<p>The analysis requires two tables (data.frame or data.table):
</p>

<ol>
<li><p> Information on samples: table with three mandatory columns and column names: 'ind' (sample name), 'x' and 'y' (projected coordinates).
An optional column 'errRad' (radius of error circle on sample coordinates) can be provided.
</p>
</li></ol>

<p>MAPI requires cartesian coordinates (ie. projected, such as UTM or Lambert) NOT (yet?) angular coordinates (eg. latitude/longitude).
The package <span class="pkg">sf</span> provides the <code>st_transform</code> function for coordinates transformation and projection.
GIS software such as QGis can also help with datum transformation.
</p>
<p>Example of 'samples' data:
</p>

<table>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> ind   </td><td style="text-align: right;"> x      </td><td style="text-align: right;"> y      </td><td style="text-align: right;"> errRad </td>
</tr>
<tr>
 <td style="text-align: left;">
1  </td><td style="text-align: left;"> 2_42  </td><td style="text-align: right;"> 12000  </td><td style="text-align: right;"> 5000   </td><td style="text-align: right;">     10 </td>
</tr>
<tr>
 <td style="text-align: left;">
2  </td><td style="text-align: left;"> 2_47  </td><td style="text-align: right;"> 17000  </td><td style="text-align: right;"> 5000   </td><td style="text-align: right;">     10 </td>
</tr>
<tr>
 <td style="text-align: left;">
3  </td><td style="text-align: left;"> 1_82  </td><td style="text-align: right;">  2000  </td><td style="text-align: right;"> 9000   </td><td style="text-align: right;">     10 </td>
</tr>
<tr>
 <td style="text-align: left;">
4  </td><td style="text-align: left;"> 2_100 </td><td style="text-align: right;"> 20000  </td><td style="text-align: right;"> 10000  </td><td style="text-align: right;">     10 </td>
</tr>
<tr>
 <td style="text-align: left;">
5  </td><td style="text-align: left;"> 2_87  </td><td style="text-align: right;"> 17000  </td><td style="text-align: right;"> 9000   </td><td style="text-align: right;">     10 </td>
</tr>
<tr>
 <td style="text-align: left;">
6  </td><td style="text-align: left;"> 1_11  </td><td style="text-align: right;"> 1000   </td><td style="text-align: right;"> 2000   </td><td style="text-align: right;">     10 </td>
</tr>
<tr>
 <td style="text-align: left;">
...  </td><td style="text-align: left;"> ...  </td><td style="text-align: right;"> ...   </td><td style="text-align: right;"> ...    </td><td style="text-align: right;">   ...  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<ol>
<li><p> Values of the pairwise metric computed between samples provided, either, as a complete matrix with the same number of columns and rows
(column and row names must match the sample names provided in the 'samples' data) or as a table with three mandatory columns and
column names: 'ind1', 'ind2' (sample names) and 'value' (pairwise metric values).
</p>
</li></ol>

<p>Example of 'metric' data:
</p>

<table>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> ind1  </td><td style="text-align: left;"> ind2 </td><td style="text-align: right;">   value </td>
</tr>
<tr>
 <td style="text-align: left;">
1   </td><td style="text-align: left;">  1_1  </td><td style="text-align: left;"> 1_2 </td><td style="text-align: right;"> 0.055556 </td>
</tr>
<tr>
 <td style="text-align: left;">
2   </td><td style="text-align: left;">  1_1  </td><td style="text-align: left;"> 1_3 </td><td style="text-align: right;"> 0.020833 </td>
</tr>
<tr>
 <td style="text-align: left;">
3   </td><td style="text-align: left;">  1_1  </td><td style="text-align: left;"> 1_4 </td><td style="text-align: right;"> 0.125000 </td>
</tr>
<tr>
 <td style="text-align: left;">
4   </td><td style="text-align: left;">  1_1  </td><td style="text-align: left;"> 1_5 </td><td style="text-align: right;"> 0.125000 </td>
</tr>
<tr>
 <td style="text-align: left;">
5   </td><td style="text-align: left;">  1_1  </td><td style="text-align: left;"> 1_6 </td><td style="text-align: right;"> 0.020833 </td>
</tr>
<tr>
 <td style="text-align: left;">
6   </td><td style="text-align: left;">  1_1  </td><td style="text-align: left;"> 1_7 </td><td style="text-align: right;"> 0.090278 </td>
</tr>
<tr>
 <td style="text-align: left;">
... </td><td style="text-align: left;"> ...   </td><td style="text-align: left;"> ... </td><td style="text-align: right;"> ...      </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>




<h4>Try it</h4>

<p>Using the test dataset ('samples' and 'metric') included in the package, let's run an (almost) automatic MAPI analysis
</p>
<p>Test data result from population genetic simulations in which two panmictic populations are
separated by a barrier to dispersal. As we use dummy coordinates, there is no appropriate crs, so we just use 'crs=3857'
(a pseudo-mercator projection). Of course, in this case, sample position on earth is meaningless.
For a real dataset, 'crs' must be the EPSG code of the projection of your cartesian coordinates.
</p>
<pre>
 # Load the package
 library(mapi)
 
 # Load 'samples' data
 data("samples")
 
 # Load 'metric' data. For our simulated data set the parwise metric 
 # computed between samples is the individual genetic distance â of Rousset (2000).
 data("metric")
 
 # Run MAPI the lazy way (automatic) with 1000 permutations 
 # for detection of significant (dis)continuous areas.
 # As crs must be set, we go with crs=3857 even if we use dummy coordinates.
 # Of course, this have no geographical meaning.
 # As we have a regular sampling, we use beta=0.5
 my.results &lt;- MAPI_RunAuto(samples, metric, crs=3857, beta=0.5, nbPermuts=1000)
 
 # Get significant areas with a FDR control at alpha=0.05 (5%, by default)
 my.tails &lt;- MAPI_Tails(my.results, alpha=0.05)
 
 # Look at the result Figure 2.
 MAPI_Plot2(my.results, tails=my.tails)
 </pre>
<p>Spatial variation of the genetic distance is represented with a color scale from dark brown (lowest values) to dark blue (higher value). The central blue area identified as a significant area of discontinuity corresponds
to the position of the simulated barrier. Note that due to the permutation procedure, delineation of the significant areas may vary slightly among runs.
</p>

<p><img src="../help/figures/mapiPlotOutput.png" alt="mapiPlotOutput.png" /><br />
<em>Figure 2: MAPI graphical Output produced using the MAPI_Plot2 function.</em>
</p>


<h4>To go deeper</h4>

<p><code><a href="#topic+MAPI_RunAuto">MAPI_RunAuto</a></code> is a wrapper which calls three other functions: <code><a href="#topic+MAPI_CheckData">MAPI_CheckData</a></code>, <code><a href="#topic+MAPI_GridAuto">MAPI_GridAuto</a></code> and <code><a href="#topic+MAPI_RunOnGrid">MAPI_RunOnGrid</a></code>.
</p>
<p><code><a href="#topic+MAPI_GridAuto">MAPI_GridAuto</a></code> is itself another wrapper around <code><a href="#topic+MAPI_EstimateHalfwidth">MAPI_EstimateHalfwidth</a></code> and <code><a href="#topic+MAPI_GridHexagonal">MAPI_GridHexagonal</a></code>.
</p>
<p>Typically, a &quot;manual&quot; MAPI analysis will involve the following ordered steps:
</p>

<ol>
<li> <p><code><a href="#topic+MAPI_CheckData">MAPI_CheckData</a></code> 
</p>
</li>
<li> <p><code><a href="#topic+MAPI_EstimateHalfwidth">MAPI_EstimateHalfwidth</a></code> 
</p>
</li>
<li> <p><code><a href="#topic+MAPI_GridHexagonal">MAPI_GridHexagonal</a></code> 
</p>
</li>
<li> <p><code><a href="#topic+MAPI_RunOnGrid">MAPI_RunOnGrid</a></code> 
</p>
</li>
<li> <p><code><a href="#topic+MAPI_Tails">MAPI_Tails</a></code> 
</p>
</li>
<li> <p><code><a href="#topic+MAPI_Plot2">MAPI_Plot2</a></code> 
</p>
</li></ol>

<p>Within this general framework, you may, for example:
</p>

<ul>
<li><p>set your own value for 'halfwidth' (ignore step 2)
</p>
</li>
<li><p>use your own grid, or reuse one from another run (ignore steps 2 &amp; 3)
</p>
</li>
<li><p>tweak some MAPI parameters (such as dMin or dMax for filtering on geographic distances between samples)
</p>
</li>
<li><p>discard poorly supported cells prior detecting significant areas of (dis)continuity  (parameter <code>minQ</code>) and/or change significance level (parameter <code>alpha</code> in <code><a href="#topic+MAPI_Tails">MAPI_Tails</a></code>)
</p>
</li>
<li><p>build your MAPI maps with a GIS software (ignore step 6). See 'Export results' section below
</p>
</li></ul>




<h4>Export results</h4>

<p>Output tables (weighted mean of the pairwise metric within cell and polygons delineating significant areas of (dis)continuity) are spatial objects built using the package <span class="pkg">sf</span>.
Refer to <span class="pkg">sf</span> documentation to export MAPI results in various format.
Below is an example of how MAPI results can be exported as ESRI Shapefiles:
</p>
<pre>
library(sf)
# Export results for our test dataset
st_write(my.results, dsn=".", layer="myFirstMapiResult", 
   driver="ESRI Shapefile", append=FALSE, delete_layer=TRUE)
st_write(my.tails, dsn=".", layer="myFirstMapiResultTails", 
   driver="ESRI Shapefile", append=FALSE, delete_layer=TRUE)
</pre>
<p>Alternatively, exporting layers in a geopackage is more convenient (only one file):
</p>
<pre>
library(sf)
# Export results for our test dataset
st_write(my.results, dsn="myFirstMapi.gpkg", layer="Result", 
   driver="GPKG", append=FALSE, delete_layer=TRUE)
st_write(my.tails, dsn="myFirstMapi.gpkg", layer="Tails", 
   driver="GPKG", append=FALSE, delete_layer=TRUE)
</pre>
<p>You may now open these files &lsquo;<span class="file">myFirstMapiResult.shp</span>&rsquo; and &lsquo;<span class="file">myFirstMapiResultTails.shp</span>&rsquo; or &lsquo;<span class="file">myFirstMapi.gpkg</span>&rsquo; in a GIS software such as QGis and customize the layout.<br />
</p>
<p>NOTE: recent versions of sf/gdal packages does not allow to export the 'permuts' column. As it was never used, MAPI &gt;=1.0.4 releases does not returns anymore this column.
If you still use older MAPI versions, you can remove this column before exporting using the following command:
</p>
<pre>
my.results$permuts &lt;- NULL
</pre>
<p>NOTE: If the area of significant zones is very large, the measure may not fit in Shapefiles fields. It is then possible to convert the area measure in km² by dividing the value by 1,000,000:
</p>
<pre>
my.tails$area &lt;- as.numeric(my.tails$area) / 1e6
</pre>
<p>Overlaying MAPI results with landscape layouts can help in analyzing the relationship between environmental features and spatial genetic patterns (eg. Piry &amp; al., 2016; Piry &amp; al., 2018).
</p>



<h3>References</h3>



<h4>Description of the MAPI method</h4>

<p><br />
Piry S., Chapuis M.-P., Gauffre B., Papaïx J., Cruaud A. and Berthier K. <b>(2016)</b>.
Mapping Averaged Pairwise Information (MAPI): a new exploratory tool to uncover spatial structure.
<em>Methods in Ecology and Evolution</em> <b>7</b>:(12), 1463–1475.
doi: <a href="https://doi.org/10.1111/2041-210X.12616">10.1111/2041-210X.12616</a>
</p>



<h4>Applications of MAPI in Landscape Genetics</h4>


<ul>
<li><p>Larson S., Gagne RB et al. <b>2021</b>
Translocations maintain genetic diversity and increase connectivity in sea otters, <em>Enhydra lutris</em>
<em>Marine Mammal Science</em>
doi: <a href="https://doi.org/10.1111/mms.12841">10.1111/mms.12841</a>
</p>
</li>
<li><p>Stragier C., Piry S., et al. <b>2020</b>.
Interplay between historical and current features of the cityscape in shaping the genetic structure of the house mouse (<em>Mus musculus domesticus</em>) in Dakar (Senegal, West Africa)
<em>bioRxiv ; Version 4 of this preprint has been peer-reviewed and is recommended by Peer Community In Ecology (DOI:10.24072/pci.ecology.100044)</em>
doi: <a href="https://doi.org/10.1101/557066">10.1101/557066</a>
</p>
</li>
<li><p>Piry S., Berthier K., Streiff R., Cros-Arteil S., Tatin L., Foucart A., Bröder L., Hochkirch A., and Chapuis M.-P. <b>(2018)</b>.
Fine-scale interactions between habitat quality and genetic variation suggest an impact of grazing on the critically endangered Crau Plain grasshopper (Pamphagidae: <em>Prionotropis rhodanica</em>).
<em>Journal of Orthoptera Research</em> <b>27</b>, 61–73.
doi: <a href="https://doi.org/10.3897/jor.27.15036">10.3897/jor.27.15036</a>
</p>
</li>
<li><p>Dellicour S, Prunier JG, Piry S, et al. <b>(2019)</b>
Landscape genetic analyses of <em>Cervus elaphus</em> and <em>Sus scrofa</em>: comparative study and analytical developments.
<em>Heredity</em>.
doi: <a href="https://doi.org/10.1038/s41437-019-0183-5">10.1038/s41437-019-0183-5</a>
</p>
</li></ul>


<hr>
<h2 id='MAPI_CheckData'>Function MAPI_CheckData</h2><span id='topic+MAPI_CheckData'></span>

<h3>Description</h3>

<p>Check the validity of the 'samples' and 'metric' data loaded.<br />
Missing data are removed from 'metric', samples with missing coordinates are removed and samples that are not present in both dataset ('samples' and 'metric') are discarded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAPI_CheckData(
  samples,
  metric,
  isMatrix = all((class(metric) == "matrix"), (nrow(metric) == ncol(metric)))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MAPI_CheckData_+3A_samples">samples</code></td>
<td>
<p>a data.frame with names and geographical coordinates of samples. Column names must be: 'ind', 'x', 'y'.
Optional column 'errRad' with an error radius for sample locations (eg. GPS uncertainty). Coordinates must be projected (not latitude/longitude).</p>
</td></tr>
<tr><td><code id="MAPI_CheckData_+3A_metric">metric</code></td>
<td>
<p>a data.frame or a square matrix with the pairwise metric computed for all pairs of samples.
If data.frame, column names must be: 'ind1', 'ind2', 'value'.  If matrix, sample names must be the row- and column names.</p>
</td></tr>
<tr><td><code id="MAPI_CheckData_+3A_ismatrix">isMatrix</code></td>
<td>
<p>Boolean. Depends on the 'metric' data:<br />
TRUE if 'metric' is a square matrix with column names = row names and standing for sample names.<br />
FALSE if 'metric is a three columns data.frame ('ind1', 'ind2', 'value'). <br />
The default value is determined using a &quot;matrix&quot; class detection for 'metric' as well as identity between row and column number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of two data.table objects corresponding to 'samples' and 'metric' after cleaning.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("samples")
data("metric")
# remove first sample in order to force warning
samples &lt;- samples[-c(1) , ]
clean.list &lt;- MAPI_CheckData(samples, metric)
checked.samples &lt;- clean.list[['samples']]
checked.metric &lt;- clean.list[['metric']]

## End(Not run)

</code></pre>

<hr>
<h2 id='MAPI_EstimateHalfwidth'>Function MAPI_EstimateHalfwidth</h2><span id='topic+MAPI_EstimateHalfwidth'></span>

<h3>Description</h3>

<p>This function computes the side length (= halfwidth) of the hexagonal cells. Halfwidth value can be further used to build a MAPI grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAPI_EstimateHalfwidth(samples, crs, beta = 0.25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MAPI_EstimateHalfwidth_+3A_samples">samples</code></td>
<td>
<p>a data.frame with names and geographical coordinates of samples. Column names must be: 'ind', 'x', 'y'.
Optional column 'errRad' with an error radius for sample locations (eg. GPS uncertainty).
Coordinates must be projected (not latitude/longitude).</p>
</td></tr>
<tr><td><code id="MAPI_EstimateHalfwidth_+3A_crs">crs</code></td>
<td>
<p>coordinate reference system: integer with the EPSG code, or character with proj4string.
The coordinates system must be a projection, not latitude/longitude.</p>
</td></tr>
<tr><td><code id="MAPI_EstimateHalfwidth_+3A_beta">beta</code></td>
<td>
<p>A value depending on spatial regularity of sampling: 0.5 for regular sampling, 0.25 for random sampling (Hengl, 2006).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">h_w = \frac{\beta \sqrt{A/N}}{\sqrt{2.5980}}</code>, where A is the study area (convex hull of sampling points) and N the number of samples.
Parameter beta allows to respect the Nyquist-Shannon sampling theorem depending on sampling regularity.
</p>


<h3>Value</h3>

<p>halfwidth cell value (side length of hexagonal cells).
</p>


<h3>References</h3>

<p>Hengl, T. (2006) Finding the right pixel size. Computers &amp; Geosciences, 32, 1283&ndash;1298.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(samples)
# Computes hexagonal cell halfwidth for the 'samples' dataset using beta=0.5
hw &lt;- MAPI_EstimateHalfwidth(samples, beta=0.5)

</code></pre>

<hr>
<h2 id='MAPI_GridAuto'>Function MAPI_GridAuto</h2><span id='topic+MAPI_GridAuto'></span>

<h3>Description</h3>

<p>Wrapper that computes cell halfwidth for a given beta value, and then
builds a grid of hexagonal cells (call to <code><a href="#topic+MAPI_GridHexagonal">MAPI_GridHexagonal</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAPI_GridAuto(samples, crs, beta = 0.25, buf = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MAPI_GridAuto_+3A_samples">samples</code></td>
<td>
<p>a data.frame with names and geographical coordinates of samples. Column names must be: 'ind', 'x', 'y'.
Optional column 'errRad' with an error radius for sample locations (eg. GPS uncertainty).
Coordinates must be projected (not latitude/longitude).</p>
</td></tr>
<tr><td><code id="MAPI_GridAuto_+3A_crs">crs</code></td>
<td>
<p>coordinate reference system: integer with the EPSG code, or character with proj4string.
When using dummy coordinates (eg. simulation output) you may use EPSG:3857 (pseudo-Mercator) for example.
This allows computation but, of course, has no geographical meaning.</p>
</td></tr>
<tr><td><code id="MAPI_GridAuto_+3A_beta">beta</code></td>
<td>
<p>A value depending on sampling regularity: 0.5 for regular sampling, 0.25 for random sampling (Hengl, 2006).</p>
</td></tr>
<tr><td><code id="MAPI_GridAuto_+3A_buf">buf</code></td>
<td>
<p>optional. This parameter allows to expand or shrink the grid by a number of units in the
same reference system as the sample geographical coordinates (0 by default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The halfwidth cell value used to build the grid is computed as
<code class="reqn">h_w = \frac{\beta \sqrt{A/N}}{\sqrt{2.5980}}</code>,
where A is the study area (convex hull of sampling points) and N the number of samples.
Parameter beta allows to respect the Nyquist-Shannon sampling theorem depending on sampling regularity
(call to <code><a href="#topic+MAPI_EstimateHalfwidth">MAPI_EstimateHalfwidth</a></code>).
</p>


<h3>Value</h3>

<p>a spatial object of class 'sf' including the x and y coordinates of cell centers, cell geometry (polygons) and cell id (gid).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("samples")
grid &lt;- MAPI_GridAuto(samples, crs=3857, beta=0.5)

</code></pre>

<hr>
<h2 id='MAPI_GridHexagonal'>Function MAPI_GridHexagonal</h2><span id='topic+MAPI_GridHexagonal'></span>

<h3>Description</h3>

<p>Build a grid of hexagonal cells according to samples coordinates and a given halfwidth
cell value provided by users (can be computed using <code><a href="#topic+MAPI_EstimateHalfwidth">MAPI_EstimateHalfwidth</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAPI_GridHexagonal(samples, crs, hw, buf = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MAPI_GridHexagonal_+3A_samples">samples</code></td>
<td>
<p>a data.frame with names and geographical coordinates of samples. Column names must be: 'ind', 'x', 'y'.
Optional column 'errRad' with an error radius for sample locations (eg. GPS uncertainty).
Coordinates must be projected (not latitude/longitude).</p>
</td></tr>
<tr><td><code id="MAPI_GridHexagonal_+3A_crs">crs</code></td>
<td>
<p>coordinate reference system: integer with the EPSG code, or character with proj4string.
When using dummy coordinates (eg. simulation output) you may use EPSG:3857 for example.
This allows computation but, of course, has no geographical meaning.</p>
</td></tr>
<tr><td><code id="MAPI_GridHexagonal_+3A_hw">hw</code></td>
<td>
<p>Halfwidth : side length of hexagonal cells.</p>
</td></tr>
<tr><td><code id="MAPI_GridHexagonal_+3A_buf">buf</code></td>
<td>
<p>optional. This parameter allows to expand or shrink the grid by a number of units in
the same reference system as the sample geographical coordinates (0 by default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a spatial object of class 'sf' including the x and y coordinates of cell centers, cell geometry (polygons) and cell id (gid).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("samples")
# Builds a grid of hexagonal cells according to samples coordinates (columns x and y) 
# using the EPSG:3857 projection and an halfwidth cell value of hw=250m.
grid &lt;- MAPI_GridHexagonal(samples, crs=3857, hw=250)

</code></pre>

<hr>
<h2 id='MAPI_Plot'>Function MAPI_Plot</h2><span id='topic+MAPI_Plot'></span>

<h3>Description</h3>

<p>Plot a MAPI analysis result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAPI_Plot(
  resu,
  tails = NULL,
  samples = NULL,
  pal = c("#994000", "#CC5800", "#FF8F33", "#FFAD66", "#FFCA99", "#FFE6CC", "#FBFBFB",
    "#CCFDFF", "#99F8FF", "#66F0FF", "#33E4FF", "#00AACC", "#007A99"),
  shades = 20,
  main = NA,
  upper = TRUE,
  lower = TRUE,
  upper.border = "black",
  lower.border = "gray"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MAPI_Plot_+3A_resu">resu</code></td>
<td>
<p>A spatial object of class 'sf' resulting from a MAPI analysis done using
<code><a href="#topic+MAPI_RunAuto">MAPI_RunAuto</a></code> or <code><a href="#topic+MAPI_RunOnGrid">MAPI_RunOnGrid</a></code>.</p>
</td></tr>
<tr><td><code id="MAPI_Plot_+3A_tails">tails</code></td>
<td>
<p>An optional spatial object of class 'sf' resulting from the post-process with
<code><a href="#topic+MAPI_Tails">MAPI_Tails</a></code> of a MAPI analysis result. Default = NULL (no tails shown).</p>
</td></tr>
<tr><td><code id="MAPI_Plot_+3A_samples">samples</code></td>
<td>
<p>A data.frame with names and geographical coordinates of samples.
Column names must be: 'ind', 'x', 'y'.
Optional column 'errRad' with an error radius for sample locations (eg. GPS uncertainty).
Coordinates must be projected (not latitude/longitude).</p>
</td></tr>
<tr><td><code id="MAPI_Plot_+3A_pal">pal</code></td>
<td>
<p>A color ramp, eg. from <span class="pkg">RColorBrewer</span> (default: orange &gt; light gray &gt; blue)</p>
</td></tr>
<tr><td><code id="MAPI_Plot_+3A_shades">shades</code></td>
<td>
<p>Number of breaks for the color ramp (default 20)</p>
</td></tr>
<tr><td><code id="MAPI_Plot_+3A_main">main</code></td>
<td>
<p>Plot title (none by default)</p>
</td></tr>
<tr><td><code id="MAPI_Plot_+3A_upper">upper</code></td>
<td>
<p>If TRUE and tails is not NULL, upper-tail significant areas are plotted. TRUE by default.</p>
</td></tr>
<tr><td><code id="MAPI_Plot_+3A_lower">lower</code></td>
<td>
<p>If TRUE and tails is not NULL, lower-tail significant areas are plotted. TRUE by default.</p>
</td></tr>
<tr><td><code id="MAPI_Plot_+3A_upper.border">upper.border</code></td>
<td>
<p>Border color of the upper-tail significant area. &quot;black&quot; by default.</p>
</td></tr>
<tr><td><code id="MAPI_Plot_+3A_lower.border">lower.border</code></td>
<td>
<p>Border color of the lower-tail significant area. &quot;gray&quot; by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the &quot;trellis&quot; object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("metric")
data("samples")
resu &lt;- MAPI_RunAuto(samples, metric, crs=3857, nbPermuts = 1000)
tails &lt;- MAPI_Tails(resu)
pl &lt;- MAPI_Plot(resu, tails=tails, samples=samples)
# Open png driver
png("mapiPlotOutput.png", width=1000, type="cairo-png")
print(pl) # Do plot in file
dev.off() # Close driver

## End(Not run)
</code></pre>

<hr>
<h2 id='MAPI_Plot2'>Function MAPI_Plot2</h2><span id='topic+MAPI_Plot2'></span>

<h3>Description</h3>

<p>Plot a MAPI analysis result with ggplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAPI_Plot2(
  resu,
  tails = NULL,
  samples = NULL,
  pal = c("#994000", "#CC5800", "#FF8F33", "#FFAD66", "#FFCA99", "#FFE6CC", "#FBFBFB",
    "#CCFDFF", "#99F8FF", "#66F0FF", "#33E4FF", "#00AACC", "#007A99"),
  shades = 20,
  main = "",
  upper = TRUE,
  lower = TRUE,
  upper.border = "black",
  lower.border = "gray"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MAPI_Plot2_+3A_resu">resu</code></td>
<td>
<p>A spatial object of class 'sf' resulting from a MAPI analysis done using
<code><a href="#topic+MAPI_RunAuto">MAPI_RunAuto</a></code> or <code><a href="#topic+MAPI_RunOnGrid">MAPI_RunOnGrid</a></code>.</p>
</td></tr>
<tr><td><code id="MAPI_Plot2_+3A_tails">tails</code></td>
<td>
<p>An optional spatial object of class 'sf' resulting from the post-process with
<code><a href="#topic+MAPI_Tails">MAPI_Tails</a></code> of a MAPI analysis result. Default = NULL (no tails shown).</p>
</td></tr>
<tr><td><code id="MAPI_Plot2_+3A_samples">samples</code></td>
<td>
<p>A data.frame with names and geographical coordinates of samples.
Column names must be: 'ind', 'x', 'y'.
Optional column 'errRad' with an error radius for sample locations (eg. GPS uncertainty).
Coordinates must be projected (not latitude/longitude).</p>
</td></tr>
<tr><td><code id="MAPI_Plot2_+3A_pal">pal</code></td>
<td>
<p>A color ramp, eg. from <span class="pkg">RColorBrewer</span> (default: orange &gt; light gray &gt; blue)</p>
</td></tr>
<tr><td><code id="MAPI_Plot2_+3A_shades">shades</code></td>
<td>
<p>Number of breaks for the color ramp (default 20)</p>
</td></tr>
<tr><td><code id="MAPI_Plot2_+3A_main">main</code></td>
<td>
<p>Plot title (none by default)</p>
</td></tr>
<tr><td><code id="MAPI_Plot2_+3A_upper">upper</code></td>
<td>
<p>If TRUE and tails is not NULL, upper-tail significant areas are plotted. TRUE by default.</p>
</td></tr>
<tr><td><code id="MAPI_Plot2_+3A_lower">lower</code></td>
<td>
<p>If TRUE and tails is not NULL, lower-tail significant areas are plotted. TRUE by default.</p>
</td></tr>
<tr><td><code id="MAPI_Plot2_+3A_upper.border">upper.border</code></td>
<td>
<p>Border color of the upper-tail significant area. &quot;black&quot; by default.</p>
</td></tr>
<tr><td><code id="MAPI_Plot2_+3A_lower.border">lower.border</code></td>
<td>
<p>Border color of the lower-tail significant area. &quot;gray&quot; by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(ggplot2)
data("metric")
data("samples")
resu &lt;- MAPI_RunAuto(samples, metric, crs=3857, nbPermuts = 1000)
tails &lt;- MAPI_Tails(resu)
pl &lt;- MAPI_Plot2(resu, tails=tails, samples=samples)
# Save to image
ggsave("mapiPlotOutput.png", plot=pl)

## End(Not run)
</code></pre>

<hr>
<h2 id='MAPI_RunAuto'>Function MAPI_RunAuto</h2><span id='topic+MAPI_RunAuto'></span>

<h3>Description</h3>

<p>This function is a wrapper allowing to run a complete MAPI analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAPI_RunAuto(
  samples,
  metric,
  crs,
  isMatrix = all(class(metric) == "matrix", nrow(metric) == ncol(metric)),
  beta = 0.25,
  ecc = 0.975,
  buf = 0,
  errRad = 10,
  nbPermuts = 0,
  dMin = 0,
  dMax = Inf,
  nbCores = ifelse(requireNamespace("parallel", quietly = TRUE),
    parallel::detectCores() - 1, 1),
  N = 8
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MAPI_RunAuto_+3A_samples">samples</code></td>
<td>
<p>a data.frame with names and geographical coordinates of samples.
Column names must be: 'ind', 'x', 'y'.  Optional column 'errRad' with an error radius for sample locations (eg. GPS uncertainty).
Coordinates must be projected (not latitude/longitude).</p>
</td></tr>
<tr><td><code id="MAPI_RunAuto_+3A_metric">metric</code></td>
<td>
<p>a data.frame or a square matrix with the pairwise metric computed for all pairs of samples.
If data.frame, column names must be: 'ind1', 'ind2', 'value'.
If matrix, sample names must be the row- and column names.</p>
</td></tr>
<tr><td><code id="MAPI_RunAuto_+3A_crs">crs</code></td>
<td>
<p>coordinate reference system: integer with the EPSG code, or character with proj4string.
When using dummy coordinates (eg. simulation output) you may use EPSG:3857 for example.
This allows computation but, of course, has no geographical meaning.</p>
</td></tr>
<tr><td><code id="MAPI_RunAuto_+3A_ismatrix">isMatrix</code></td>
<td>
<p>Boolean. Depends on the 'metric' data:<br />
TRUE if 'metric' is a square matrix with column names = row names and standing for sample names.<br />
FALSE if 'metric is a three columns data.frame ('ind1', 'ind2', 'value'). <br />
The default value is determined using a &quot;matrix&quot; class detection for 'metric' as well as identity between row and column number.</p>
</td></tr>
<tr><td><code id="MAPI_RunAuto_+3A_beta">beta</code></td>
<td>
<p>A value depending on spatial regularity of sampling: 0.5 for regular sampling, 0.25 for random sampling (Hengl, 2006).</p>
</td></tr>
<tr><td><code id="MAPI_RunAuto_+3A_ecc">ecc</code></td>
<td>
<p>ellipse eccentricity value (0.975 by default).</p>
</td></tr>
<tr><td><code id="MAPI_RunAuto_+3A_buf">buf</code></td>
<td>
<p>optional. This parameter allows to expand or shrink the grid by a number of units in
the same reference system as the sample geographical coordinates (0 by default).</p>
</td></tr>
<tr><td><code id="MAPI_RunAuto_+3A_errrad">errRad</code></td>
<td>
<p>global error radius for sample locations (same radius for all samples, 10 by default).
Units are in the same reference system as the sample geographical coordinates.
To use different error radius values for sample locations, add a column 'errRad' in the 'sample' data (see <code><a href="#topic+mapi">mapi</a></code>).</p>
</td></tr>
<tr><td><code id="MAPI_RunAuto_+3A_nbpermuts">nbPermuts</code></td>
<td>
<p>number of permutations of sample locations (0 by default).</p>
</td></tr>
<tr><td><code id="MAPI_RunAuto_+3A_dmin">dMin</code></td>
<td>
<p>minimum distance between individuals. 0 by default.</p>
</td></tr>
<tr><td><code id="MAPI_RunAuto_+3A_dmax">dMax</code></td>
<td>
<p>maximal distance between individuals. +Inf by default.</p>
</td></tr>
<tr><td><code id="MAPI_RunAuto_+3A_nbcores">nbCores</code></td>
<td>
<p>number of CPU cores you want to use during parallel computation.
The default value is estimated as the number of available cores minus 1, suitable for a personal computer.
On a cluster you might have to set it to a reasonable value (eg. 8) in order to keep resources for other tasks.</p>
</td></tr>
<tr><td><code id="MAPI_RunAuto_+3A_n">N</code></td>
<td>
<p>number of points used per quarter of ellipse, 8 by default.
Don't change it unless you really know what you are doing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Following functions are called by <code>MAPI_RunAuto</code> in following order:
</p>

<ul>
<li> <p><code><a href="#topic+MAPI_CheckData">MAPI_CheckData</a></code> cleans the dataset;
</p>
</li>
<li> <p><code><a href="#topic+MAPI_GridAuto">MAPI_GridAuto</a></code> generates a grid of hexagons by calling <code><a href="#topic+MAPI_EstimateHalfwidth">MAPI_EstimateHalfwidth</a></code> then <code><a href="#topic+MAPI_GridHexagonal">MAPI_GridHexagonal</a></code>;
</p>
</li>
<li> <p><code><a href="#topic+MAPI_RunOnGrid">MAPI_RunOnGrid</a></code> performs the MAPI analysis.
</p>
</li></ul>

<p>NOTE: The call to <code><a href="#topic+MAPI_Tails">MAPI_Tails</a></code> is not included.
It should be done afterwards on the object returned by <code>MAPI_RunAuto</code>.
</p>


<h3>Value</h3>

<p>a spatial object of class 'sf' providing for each cell: <br />
</p>

<ul>
<li><p> gid: Cell ID <br />
</p>
</li>
<li><p> x and y coordinates of cell center <br />
</p>
</li>
<li><p> nb_ell: number of ellipses used to compute the weighted mean <br />
</p>
</li>
<li><p> avg_value: weighted mean of the pairwise metric <br />
</p>
</li>
<li><p> sum_wgts: sum of weights of ellipses used to compute the weighted mean <br />
</p>
</li>
<li><p> w_stdev: weighted standard deviation of the pairwise metric <br />
</p>
</li>
<li><p> swQ: percentile of the sum of weights <br />
</p>
</li>
<li><p> geometry <br />
When permutations are performed: <br />
</p>
</li>
<li><p> proba: proportion of the permuted weighted means below the observed weighted mean <br />
</p>
</li>
<li><p> ltP: lower-tail p-value adjusted using the FDR procedure of Benjamini and Yekutieli <br />
</p>
</li>
<li><p> utP: upper-tail p-value adjusted using the FDR procedure of Benjamini and Yekutieli <br />
</p>
</li></ul>



<h3>References</h3>

<p>Benjamini, Y. &amp; Yekutieli, D. (2001) The control of the false discovery rate in multiple testing under dependency. Annals of Statistics, 29, 1165–1188.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("metric")
data("samples")
# Run a MAPI analysis without permutation
my.results &lt;- MAPI_RunAuto(samples, metric, crs=3857, beta=0.5, nbPermuts=0)

# eg. Export results to shapefile "myFirstMapiResult" in current directory
# to further visualize and customize the MAPI plot in SIG software.
library(sf)
st_write(my.results, dsn=".", layer="myFirstMapiResult", driver="ESRI Shapefile")

## End(Not run)

</code></pre>

<hr>
<h2 id='MAPI_RunOnGrid'>Function MAPI_RunOnGrid</h2><span id='topic+MAPI_RunOnGrid'></span>

<h3>Description</h3>

<p>Launch a MAPI analysis for a given grid computed with <code><a href="#topic+MAPI_GridAuto">MAPI_GridAuto</a></code>
or <code><a href="#topic+MAPI_GridHexagonal">MAPI_GridHexagonal</a></code> or provided by users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAPI_RunOnGrid(
  samples,
  metric,
  grid,
  isMatrix = FALSE,
  ecc = 0.975,
  errRad = 10,
  nbPermuts = 0,
  dMin = 0,
  dMax = Inf,
  nbCores = ifelse(base::requireNamespace("parallel", quietly = TRUE),
    parallel::detectCores() - 1, 1),
  N = 8
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MAPI_RunOnGrid_+3A_samples">samples</code></td>
<td>
<p>a data.frame with names and geographical coordinates of samples.
Column names must be: 'ind', 'x', 'y'.  Optional column 'errRad' with an error radius for sample locations (eg. GPS uncertainty).
Coordinates must be projected (not latitude/longitude).</p>
</td></tr>
<tr><td><code id="MAPI_RunOnGrid_+3A_metric">metric</code></td>
<td>
<p>a data.frame or a square matrix with the pairwise metric computed for all pairs of samples.
If data.frame, column names must be: 'ind1', 'ind2', 'value'.
If matrix, sample names must be the row- and column names.</p>
</td></tr>
<tr><td><code id="MAPI_RunOnGrid_+3A_grid">grid</code></td>
<td>
<p>a spatial object of class 'sf' with the geometry of each cell.
When using your own grid, please check that the object structure is the same as returned by
<code><a href="#topic+MAPI_GridAuto">MAPI_GridAuto</a></code> or <code><a href="#topic+MAPI_GridHexagonal">MAPI_GridHexagonal</a></code>.</p>
</td></tr>
<tr><td><code id="MAPI_RunOnGrid_+3A_ismatrix">isMatrix</code></td>
<td>
<p>Boolean. Depends on the 'metric' data:<br />
TRUE if 'metric' is a square matrix with column names = row names and standing for sample names.<br />
FALSE if 'metric is a three columns data.frame ('ind1', 'ind2', 'value'). <br />
The default value is determined using a &quot;matrix&quot; class detection for metric as well as identity between row and column number.</p>
</td></tr>
<tr><td><code id="MAPI_RunOnGrid_+3A_ecc">ecc</code></td>
<td>
<p>ellipse eccentricity value (0.975 by default).</p>
</td></tr>
<tr><td><code id="MAPI_RunOnGrid_+3A_errrad">errRad</code></td>
<td>
<p>global error radius for sample locations (same radius for all samples, 10 by default).
Units are in the same reference system as the sample geographical coordinates.
To use different error radius values for sample locations, add a column 'errRad' in the 'sample' data (see <code><a href="#topic+mapi">mapi</a></code>).</p>
</td></tr>
<tr><td><code id="MAPI_RunOnGrid_+3A_nbpermuts">nbPermuts</code></td>
<td>
<p>number of permutations of sample locations (0 by default).</p>
</td></tr>
<tr><td><code id="MAPI_RunOnGrid_+3A_dmin">dMin</code></td>
<td>
<p>minimum distance between individuals. 0 by default.</p>
</td></tr>
<tr><td><code id="MAPI_RunOnGrid_+3A_dmax">dMax</code></td>
<td>
<p>maximal distance between individuals. +Inf by default.</p>
</td></tr>
<tr><td><code id="MAPI_RunOnGrid_+3A_nbcores">nbCores</code></td>
<td>
<p>number of CPU cores you want to use during parallel computation.
The default value is estimated as the number of available cores minus 1, suitable for a personal computer.
On a cluster you might have to set it to a reasonable value (eg. 8) in order to keep resources for other tasks.</p>
</td></tr>
<tr><td><code id="MAPI_RunOnGrid_+3A_n">N</code></td>
<td>
<p>number of points used per quarter of ellipse, 8 by default.
Don't change it unless you really know what you are doing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To test whether the pairwise metric values associated with the ellipses are independent of the sample locations, those are permuted 'nbPermuts' times.
At each permutation, new cell values are computed and stored to build a cumulative null distribution for each cell of the grid.
Each cell value from the observed data set is then ranked against its null distribution.
For each cell, the proportion of permuted values that are smaller or greater
than the observed value provides a lower-tailed (ltP) and upper-tailed (utP) test p-value.
</p>
<p>A false discovery rate (FDR) procedure (Benjamini and Yekutieli, 2001) is applied to account for multiple
testing (number of cells) under positive dependency conditions (spatial autocorrelation).  An adjusted
p-value is computed for each cell using the function <code>p.adjust</code> from the 'stats' package with the method 'BY'.
</p>


<h3>Value</h3>

<p>a spatial object of class 'sf' providing for each cell: <br />
</p>

<ul>
<li><p> gid: Cell ID <br />
</p>
</li>
<li><p> x and y coordinates of cell center <br />
</p>
</li>
<li><p> nb_ell: number of ellipses used to compute the weighted mean <br />
</p>
</li>
<li><p> avg_value: weighted mean of the pairwise metric <br />
</p>
</li>
<li><p> sum_wgts: sum of weights of ellipses used to compute the weighted mean <br />
</p>
</li>
<li><p> w_stdev: weighted standard deviation of the pairwise metric <br />
</p>
</li>
<li><p> swQ: percentile of the sum of weights <br />
</p>
</li>
<li><p> geometry <br />
When permutations are performed: <br />
</p>
</li>
<li><p> proba: proportion of the permuted weighted means below the observed weighted mean <br />
</p>
</li>
<li><p> ltP: lower-tail p-value adjusted using the FDR procedure of Benjamini and Yekutieli <br />
</p>
</li>
<li><p> utP: upper-tail p-value adjusted using the FDR procedure of Benjamini and Yekutieli <br />
</p>
</li></ul>



<h3>References</h3>

<p>Benjamini, Y. and Yekutieli, D. (2001). The control of the false discovery rate in multiple testing under dependency. Annals of Statistics 29, 1165–1188.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(metric)
data(samples)
my.grid &lt;- MAPI_GridHexagonal(samples, crs=3857, 500) # 500m halfwidth

# Note: 10 permutations is only for test purpose, increase to &gt;=1000 in real life!
my.results &lt;- MAPI_RunOnGrid(samples, metric, grid=my.grid, nbPermuts=10, nbCores=1)

# eg. Export results to shapefile "myFirstMapiResult" in current directory
library(sf)
st_write(my.results, dsn=".", layer="myFirstMapiResult", driver="ESRI Shapefile")

## End(Not run)

</code></pre>

<hr>
<h2 id='MAPI_Tails'>Function MAPI_Tails</h2><span id='topic+MAPI_Tails'></span>

<h3>Description</h3>

<p>Determine significant continuous and discontinuous areas from the result
of a MAPI analysis when run with permutations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAPI_Tails(resu, minQ = 0, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MAPI_Tails_+3A_resu">resu</code></td>
<td>
<p>A spatial object of class 'sf' resulting from a MAPI analysis done using either
<code><a href="#topic+MAPI_RunAuto">MAPI_RunAuto</a></code> or <code><a href="#topic+MAPI_RunOnGrid">MAPI_RunOnGrid</a></code>.</p>
</td></tr>
<tr><td><code id="MAPI_Tails_+3A_minq">minQ</code></td>
<td>
<p>Threshold under which cells with the smallest sum-of-weights percentile (range 1 .. 100) are discarded (default value = 0).
This parameter allows to discard cells for which the average value of the pairwise metric is computed
using either a small number and/or only long-distance ellipses.</p>
</td></tr>
<tr><td><code id="MAPI_Tails_+3A_alpha">alpha</code></td>
<td>
<p>Significance level (default=0.05)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When permutations are performed, in <code><a href="#topic+MAPI_RunOnGrid">MAPI_RunOnGrid</a></code> for each cell, the proportion of permuted values that are smaller or greater
than the observed value provides a lower-tailed (ltP) and upper-tailed (utP) test p-value.
A false discovery rate (FDR) procedure (Benjamini and Yekutieli, 2001) is applied to account for multiple
testing (number of cells) under positive dependency conditions (spatial autocorrelation). An adjusted
p-value is computed for each cell using the function <code>p.adjust</code> from the 'stats' package with the method 'BY'.
The significance level at which FDR is controlled is set through the parameter alpha. For example, when alpha is
set to 0.05, this means that 5\
</p>
<p>Significant cells belonging to the lower (or upper) tail that are spatially connected are aggregated
together to form the significant areas with the lowest (or greater) average values of the pairwise metric analyzed.
</p>


<h3>Value</h3>

<p>a spatial object of class 'sf' with the area and geometry of the polygons delineating the significant areas.
A column provides the tail for each polygon (upper or lower).
</p>


<h3>References</h3>

<p>Benjamini, Y. and Yekutieli, D. (2001). The control of the false discovery rate in multiple testing under dependency. Annals of Statistics 29, 1165–1188.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("metric")
data("samples")
# Run MAPI computation
resu &lt;- MAPI_RunAuto(samples, metric, crs=3857, nbPermuts=1000)
# Discards the 10% cells with the smallest sum-of-weights 
#    and aggregates adjacent cells belonging to the same tail 
#    at a 5% significance level
tails &lt;- MAPI_Tails(resu, minQ=10, alpha=0.05)

## End(Not run)

</code></pre>

<hr>
<h2 id='metric'>'metric' test dataset</h2><span id='topic+metric'></span>

<h3>Description</h3>

<p>The individuals were simulated as described in the <code><a href="#topic+samples">samples</a></code> section.
The value is a genetic distance (â estimator in Rousset, 2000) computed between the 
200 simulated samples using SPAGeDi v1.4 (Hardy &amp; Vekemans, 2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("metric")
</code></pre>


<h3>Value</h3>

<p>A data.table object with 19900 rows (one per sample pair, non symmetrical) and 3 columns (&quot;ind1&quot;, &quot;ind2&quot;, &quot;value&quot;) 
containing respectively the first sample name, the second sample name and the value of their relation.
</p>


<h3>References</h3>

<p>Rousset, F. (2000). Genetic differentiation between individuals. Journal of Evolutionary Biology, 13:58&ndash;62.
</p>
<p>Hardy OJ, Vekemans X (2002) SPAGeDi: a versatile computer program to analyse spatial genetic structure 
at the individual or population levels. Molecular Ecology Notes 2: 618-620.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("metric")
</code></pre>

<hr>
<h2 id='samples'>'samples' test dataset</h2><span id='topic+samples'></span>

<h3>Description</h3>

<p>Test dataset provided with the MAPI package. We used generation-by-generation coalescent algorithms 
(Hudson et al., 1990) to simulate 10 microsatellite genotypes at migration-mutation-drift equilibrium 
for 200 diploid individuals, distributed on the nodes of a 20x10 lattice.
</p>
<p>Mutations for each locus followed a symmetric generalized stepwise model with a variance equal to 0.36
(Estoup et al., 2001) and a maximum range of allelic states of 40. The mutation rate was fixed so that
heterozygosity ranged from 0.6 to 0.8 as frequently observed at microsatellite
markers (Chapuis et al., 2012).
</p>
<p>Two panmictic populations are separated by a barrier. We used
Simcoal2 (Laval and Excoffier, 2004) to generate two panmictic populations of equal effective size
<code class="reqn">N_e = 100</code> and exchanging <code class="reqn">N_{e}m = 0.1</code> migrants at each generation. The barrier to gene
flow bisected the lattice from north to south in its center.
</p>
<p>The differentiation values computed between these samples is described in the <code><a href="#topic+metric">metric</a></code> section.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("samples")
</code></pre>


<h3>Value</h3>

<p>A data.table object with 200 simulated individuals (one per row) and 4 columns (&quot;ind&quot;, &quot;x&quot;, &quot;y&quot;, &quot;errRad&quot;) 
including the sample names, coordinates x and y and an error circle radius on coordinates.
</p>


<h3>References</h3>

<p>Chapuis, M.-P., Streiff, R., and Sword, G. (2012). Long microsatellites and unusually high levels 
of genetic diversity in the orthoptera. Insect Molecular Biology, 21(2):181&ndash;186.
</p>
<p>Estoup, A., Wilson, I. J., Sullivan, C., Cornuet, J.-M., and Moritz, C. (2001). Inferring 
population history from microsatellite and enzyme data in serially introduced cane toads, 
Bufo marinus. Genetics, 159(4):1671&ndash;1687.
</p>
<p>Hudson, R. R. et al. (1990). Gene genealogies and the coalescent process. 
Oxford Surveys in Evolutionary Biology, 7(1):44.
</p>
<p>Laval, G. and Excoffier, L. (2004). SIMCOAL 2.0: a program to simulate genomic diversity 
over large recombining regions in a subdivided population with a complex history. 
Bioinformatics, 20(15):2485&ndash;2487.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("samples")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
