<!DOCTYPE html><html><head><title>Help for package gasfluxes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gasfluxes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gasfluxes-package'><p>Calculate greenhouse gas flux calculation from chamber measurements.</p></a></li>
<li><a href='#agg.fluxes'><p>Accumulation of fluxes</p></a></li>
<li><a href='#erfc'><p>erfc</p></a></li>
<li><a href='#fluxMeas'><p>Data from chamber N2O flux measurements.</p></a></li>
<li><a href='#gasfluxes'><p>Flux calculation</p></a></li>
<li><a href='#HMR.fit'><p>HMR fit</p></a></li>
<li><a href='#lin.fit'><p>Linear concentration - time model</p></a></li>
<li><a href='#NDFE.fit'><p>NDFE fit</p></a></li>
<li><a href='#rlin.fit'><p>Robust linear concentration - time model</p></a></li>
<li><a href='#selectfluxes'><p>Select a flux estimate</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Greenhouse Gas Flux Calculation from Chamber Measurements</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-05</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Roland Fuss &lt;roland.fuss@thuenen.de&gt;</td>
</tr>
<tr>
<td>Contact:</td>
<td>Roland Fuss &lt;roland.fuss@thuenen.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for greenhouse gas flux calculation from chamber
    measurements.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://git-dmz.thuenen.de/fuss/gasfluxes">https://git-dmz.thuenen.de/fuss/gasfluxes</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>sfsmisc, data.table (&ge; 1.14.8), MASS, stats, graphics,
grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-05 09:03:12 UTC; fuss</td>
</tr>
<tr>
<td>Author:</td>
<td>Roland Fuss [aut, cre],
  Roman Hueppi [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-08 10:40:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='gasfluxes-package'>Calculate greenhouse gas flux calculation from chamber measurements.</h2><span id='topic+gasfluxes-package'></span>

<h3>Description</h3>

<p>Gasfluxes provides functions for fitting non-linear concentration - time models as well as convenience functions
for checking data and combining different calculation methods.
</p>


<h3>Details</h3>

<p>The wrapper function for convenient flux calculation is
<code><a href="#topic+gasfluxes">gasfluxes</a></code>. Several concentration - time models are implemented
</p>

<ul>
<li> <p><code><a href="#topic+HMR.fit">HMR.fit</a></code>: An implementation of HMR using partially linear least-squares.
</p>
</li>
<li> <p><code><a href="#topic+NDFE.fit">NDFE.fit</a></code>: An implementation of the NDFE model using partially linear least-squares.
</p>
</li>
<li> <p><code><a href="#topic+lin.fit">lin.fit</a></code>: A simple linear model.
</p>
</li>
<li> <p><code><a href="#topic+rlin.fit">rlin.fit</a></code>: A simple linear model fit using robust regression.
</p>
</li></ul>


<hr>
<h2 id='agg.fluxes'>Accumulation of fluxes</h2><span id='topic+agg.fluxes'></span>

<h3>Description</h3>

<p>Aggregate a time series of fluxes to a cummulative flux value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agg.fluxes(fluxes, datetimes, timeunit = "hours")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="agg.fluxes_+3A_fluxes">fluxes</code></td>
<td>
<p>flux values</p>
</td></tr>
<tr><td><code id="agg.fluxes_+3A_datetimes">datetimes</code></td>
<td>
<p>datetime values (POSIXct or POSIXlt)</p>
</td></tr>
<tr><td><code id="agg.fluxes_+3A_timeunit">timeunit</code></td>
<td>
<p>the unit of time (denominator of the flux unit), supported are the explicit units supported by <code>difftime</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses linear interpolation. The unit of the cumulative flux is [fluxes] * timeunit. 
NA values are removed and values sorted according to time order. If less then two non-NA value pairs are provided, 
NA is returned for the cumlative flux.
</p>


<h3>Value</h3>

<p>A one-row data.frame with columns
</p>
<table>
<tr><td><code>flux</code></td>
<td>
<p>the cumulative flux</p>
</td></tr>
<tr><td><code>from</code></td>
<td>
<p>the start of the cumulation period</p>
</td></tr>
<tr><td><code>to</code></td>
<td>
<p>the end of the cumulation period</p>
</td></tr>
</table>
<p>The return value being a data.frame is useful, when the function is used for &quot;split-apply-combine&quot; type operations to calculate groupwise cumulated values, 
e.g., using package data.table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Some random example data
datetimes &lt;- Sys.time() + (1:20)/2*24*3600
set.seed(42)
fluxes &lt;- rlnorm(20, 5)
agg.fluxes(fluxes, datetimes)

</code></pre>

<hr>
<h2 id='erfc'>erfc</h2><span id='topic+erfc'></span>

<h3>Description</h3>

<p>This is the complementary error function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>erfc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="erfc_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector, i.e., the erfc values.
</p>

<hr>
<h2 id='fluxMeas'>Data from chamber N2O flux measurements.</h2><span id='topic+fluxMeas'></span>

<h3>Description</h3>

<p>A dataset containing data from 1329 chamber N2O flux measurements.
</p>


<h3>Format</h3>

<p>A data.table with 5300 rows and 5 variables:
</p>

<ul>
<li><p> serie: ID of flux measurement
</p>
</li>
<li><p> V: Volume (normalized by area, i.e., the height in m)
</p>
</li>
<li><p> A: Area (always 1)
</p>
</li>
<li><p> time: closing time in h
</p>
</li>
<li><p> C: N2O concentration in mg N / m^3
</p>
</li></ul>



<h3>Source</h3>

<p>own data (anonymized by not including site and treatment information)
</p>

<hr>
<h2 id='gasfluxes'>Flux calculation</h2><span id='topic+gasfluxes'></span>

<h3>Description</h3>

<p>A wrapper function for convenient flux calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gasfluxes(
  dat,
  .id = "ID",
  .V = "V",
  .A = "A",
  .times = "time",
  .C = "C",
  methods = c("linear", "robust linear", "HMR", "NDFE"),
  k_HMR = log(1.5),
  k_NDFE = log(0.01),
  verbose = TRUE,
  plot = TRUE,
  select,
  maxiter = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gasfluxes_+3A_dat">dat</code></td>
<td>
<p>a data.frame or data.table with data from flux measurements.</p>
</td></tr>
<tr><td><code id="gasfluxes_+3A_.id">.id</code></td>
<td>
<p>character vector specifying the columns to be used as ID, multiple ID columns are possible.</p>
</td></tr>
<tr><td><code id="gasfluxes_+3A_.v">.V</code></td>
<td>
<p>character specifying the column containing chamber volume values.</p>
</td></tr>
<tr><td><code id="gasfluxes_+3A_.a">.A</code></td>
<td>
<p>character specifying the column containing chamber area values.</p>
</td></tr>
<tr><td><code id="gasfluxes_+3A_.times">.times</code></td>
<td>
<p>character specifying the column containing chamber closing time values.</p>
</td></tr>
<tr><td><code id="gasfluxes_+3A_.c">.C</code></td>
<td>
<p>character specifying the column containing concentration values.</p>
</td></tr>
<tr><td><code id="gasfluxes_+3A_methods">methods</code></td>
<td>
<p>character; which methods to use for flux estimation. See details for available methods.</p>
</td></tr>
<tr><td><code id="gasfluxes_+3A_k_hmr">k_HMR</code></td>
<td>
<p>starting value for <code><a href="#topic+HMR.fit">HMR.fit</a></code>.</p>
</td></tr>
<tr><td><code id="gasfluxes_+3A_k_ndfe">k_NDFE</code></td>
<td>
<p>starting value for <code><a href="#topic+NDFE.fit">NDFE.fit</a></code>.</p>
</td></tr>
<tr><td><code id="gasfluxes_+3A_verbose">verbose</code></td>
<td>
<p>logical; print progress messages?</p>
</td></tr>
<tr><td><code id="gasfluxes_+3A_plot">plot</code></td>
<td>
<p>create a PDF with plots in the working directory if <code>TRUE</code> (the default). The IDs are used as plot names. The plots are only intended to facilitate quick checking, not for publication quality graphs.</p>
</td></tr>
<tr><td><code id="gasfluxes_+3A_select">select</code></td>
<td>
<p>deprecated; please use function <code><a href="#topic+selectfluxes">selectfluxes</a></code>.</p>
</td></tr>
<tr><td><code id="gasfluxes_+3A_maxiter">maxiter</code></td>
<td>
<p>see <code><a href="stats.html#topic+nls.control">nls.control</a></code></p>
</td></tr>
<tr><td><code id="gasfluxes_+3A_...">...</code></td>
<td>
<p>further parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available methods are
</p>

<table>
<tr>
 <td style="text-align: left;">
"linear":</td><td style="text-align: left;"> <code><a href="#topic+lin.fit">lin.fit</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
"robust linear":</td><td style="text-align: left;"> <code><a href="#topic+rlin.fit">rlin.fit</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
"HMR":</td><td style="text-align: left;"> <code><a href="#topic+HMR.fit">HMR.fit</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
"NDFE":</td><td style="text-align: left;"> <code><a href="#topic+NDFE.fit">NDFE.fit</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Specifying other methods results in an error. 
</p>
<p>The default starting values for &quot;HMR&quot; and &quot;NDFE&quot;, <code class="reqn">k = log(\kappa)</code> and <code class="reqn">k = log(\tau)</code>, resp., assume that time is in hours. If you use a different time unit, you should adjust them accordingly.
Note that <code>nls</code> is used internally by these functions and thus they should not be used with artificial &quot;zero-residual&quot; data.
</p>
<p>The input data.frame or data.table should be in the following format:
</p>
<pre>
   serie        V A      time         C
1:    ID1 0.522625 1 0.0000000 0.3317823
2:    ID1 0.522625 1 0.3333333 0.3304053
3:    ID1 0.522625 1 0.6666667 0.3394311
4:    ID1 0.522625 1 1.0000000 0.4469102
5:    ID2 0.523625 1 0.0000000 0.4572708
</pre>
<p>However, more than one ID column are possible. E.g., the first ID column could be the plot and a second ID column could be the date. Keep in mind that the combination of IDs must be a unique identifier for each flux measurement.
</p>
<p>Units of the output depend on input units. 
It's recommended to use [V] = m^3, [A] = m^2, [time] = h, [C] = [mass or mol]/m^3, which results in [f0] = [mass or mol]/m^2/h.
Since all algorithms use V/A, A can be input as 1 and V as the chamber height.
</p>


<h3>Value</h3>

<p>A data.table with the results of the flux calculation. See the documentation of the fitting functions for details. 
If a selection algorithm has been specified, the last columns are the selected flux estimate, the corresponding standard error and p-value and the method with which the selected flux was estimated.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selectfluxes">selectfluxes</a></code> for flux selection
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#compare result of original HMR with plinear HMR
data(fluxMeas)
res &lt;- gasfluxes(fluxMeas[1:400,], 
                 .id = "serie", .V = "V", .A = "A",
                 .times = "time", .C = "C",
                 methods = c("HMR"), verbose = TRUE)
                 
#number of successful fits
res[, sum(!is.na(HMR.kappa))]



res &lt;- gasfluxes(fluxMeas, 
                 .id = "serie", .V = "V", .A = "A",
                 .times = "time", .C = "C",
                 methods = "HMR", verbose = TRUE)
# Error: time not sorted in flux ID ID556. 
# Investigate the problem:
fluxMeas[serie %in% c("ID555", "ID556", "ID557")]
#    serie        V A      time         C
# 1: ID555 0.551625 1 0.0000000 0.3884388
# 2: ID555 0.551625 1 0.3333333 0.4125270
# 3: ID555 0.551625 1 0.6666667 0.3714207
# 4: ID555 0.551625 1 1.0000000 0.3735092
# 5: ID556 0.524250 1 0.0000000 0.3638239
# 6: ID556 0.524250 1 0.3333333 0.3520481
# 7: ID556 0.524250 1 0.6666667 0.3551644
# 8: ID557 0.528375 1 0.0500000 0.3954601
# 9: ID556 0.524250 1 0.0000000 0.3839834
#10: ID557 0.528375 1 0.3333333 0.3967269
#11: ID557 0.528375 1 0.6666667 0.3764967
#12: ID557 0.528375 1 1.0000000 0.3973055

# some mixup of IDs and times
# usually an input or Excel error during data preparation
# investigate and fix

## End(Not run) 

</code></pre>

<hr>
<h2 id='HMR.fit'>HMR fit</h2><span id='topic+HMR.fit'></span>

<h3>Description</h3>

<p>Fit the HMR model using the Golub-Pereyra algorithm for partially linear least-squares models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HMR.fit(
  t,
  C,
  A = 1,
  V,
  serie = "",
  k = log(1.5),
  verbose = TRUE,
  plot = FALSE,
  maxiter = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HMR.fit_+3A_t">t</code></td>
<td>
<p>time values (usually in hours)</p>
</td></tr>
<tr><td><code id="HMR.fit_+3A_c">C</code></td>
<td>
<p>concentration values</p>
</td></tr>
<tr><td><code id="HMR.fit_+3A_a">A</code></td>
<td>
<p>area covered by the chamber</p>
</td></tr>
<tr><td><code id="HMR.fit_+3A_v">V</code></td>
<td>
<p>effective volume of the chamber</p>
</td></tr>
<tr><td><code id="HMR.fit_+3A_serie">serie</code></td>
<td>
<p>id of the flux measurement</p>
</td></tr>
<tr><td><code id="HMR.fit_+3A_k">k</code></td>
<td>
<p>starting value for nls function</p>
</td></tr>
<tr><td><code id="HMR.fit_+3A_verbose">verbose</code></td>
<td>
<p>logical, TRUE prints message after each flux calculation</p>
</td></tr>
<tr><td><code id="HMR.fit_+3A_plot">plot</code></td>
<td>
<p>logical, mainly intended for use in <code><a href="#topic+gasfluxes">gasfluxes</a></code></p>
</td></tr>
<tr><td><code id="HMR.fit_+3A_maxiter">maxiter</code></td>
<td>
<p>see <code><a href="stats.html#topic+nls.control">nls.control</a></code></p>
</td></tr>
<tr><td><code id="HMR.fit_+3A_...">...</code></td>
<td>
<p>further parameters, currently none</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The HMR model (Pedersen et al., 2010) is <code class="reqn">C(t)=\phi+f_0 \frac{e^{-\kappa t}}{-\kappa \frac{V}{A}}</code>.
To ensure the lower bound <code class="reqn">\kappa &gt; 0</code>, the substitution <code class="reqn">\kappa = e^k</code> is used. The resulting reparameterized model is then 
fit using <code><a href="stats.html#topic+nls">nls</a></code> with <code>algorithm = "plinear"</code>. This is computationally more efficient than the manual implementation in the HMR package and results 
in almost identical flux values. Flux standard errors and p-values differ strongly from those reported by the HMR package &lt;= version 0.3.1, 
but are equal to those reported by later versions.
</p>
<p>The default starting value <code class="reqn">k = log(\kappa)</code> assumes that time is in hours. If you use a different time unit, you should adjust it accordingly.
</p>
<p>There have been demands to return the initial concentration as predicted by the model as this is useful for checking plausibility. However, 
this can be easily calculated from the parameters and the equation of the model by setting t = 0, i.e., <code class="reqn">C_0=\phi-\frac{f_0}{\kappa \frac{V}{A}}</code>.
</p>
<p>Note that <code>nls</code> is used internally and thus this function should not be used with artificial &quot;zero-residual&quot; data.
</p>


<h3>Value</h3>

<p>A list of
</p>
<table>
<tr><td><code>f0</code></td>
<td>
<p>flux estimate</p>
</td></tr>
<tr><td><code>f0.se</code></td>
<td>
<p>standard error of flux estimate</p>
</td></tr>
<tr><td><code>f0.p</code></td>
<td>
<p>p-value of flux estimate</p>
</td></tr>
<tr><td><code>kappa</code>, <code>phi</code></td>
<td>
<p>other parameters of the HMR model</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike information criterion</p>
</td></tr>
<tr><td><code>AICc</code></td>
<td>
<p>Akaike information criterion with small sample correction</p>
</td></tr>
<tr><td><code>RSE</code></td>
<td>
<p>residual standard error (sigma from summary.nls)</p>
</td></tr>
<tr><td><code>diagnostics</code></td>
<td>
<p>error or warning messages</p>
</td></tr>
</table>


<h3>References</h3>

<p>Pedersen, A.R., Petersen, S.O., Schelde, K., 2010. A comprehensive approach to soil-atmosphere trace-gas flux estimation with static chambers. European Journal of Soil Science 61(6), 888-902.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#a single fit
t &lt;- c(0, 1/3, 2/3, 1)
C &lt;- c(320, 341, 352, 359)
print(fit &lt;- HMR.fit(t, C, 1, 0.3, "a"))
plot(C ~ t)
curve({fit$phi + fit$f0 * exp(-fit$kappa * x)/(-fit$kappa*0.3)}, 
      from = 0, to = 1, add = TRUE)

## Not run: 
#a dataset of 1329 chamber N2O flux measurements
data(fluxMeas)
fluxMeas[, n := length(time), by=serie]
print(fluxMeas)
fluxes &lt;- fluxMeas[n &gt; 3, HMR.fit(time, C, A, V, serie), by=serie]
print(fluxes)
plot(f0.se ~ f0, data = fluxes)
#one very large f0.se value (and several infinite ones not shown in the plot)
fluxes[is.finite(f0.se),][which.max(f0.se),]
plot(C~time, data=fluxMeas[serie=="ID940",])
print(tmp &lt;- fluxes[is.finite(f0.se),][which.max(f0.se),])
curve({tmp[, phi] + tmp[, f0] * exp(-tmp[, kappa] * x)/
      (-tmp[, kappa]*fluxMeas[serie=="ID940", V[1]]/
      fluxMeas[serie=="ID940",A[1]])}, 
      from = 0, to = 1, add = TRUE)
plot(f0.se ~ f0, data = fluxes[f0.se &lt; 1e4,], pch = 16)
boxplot(fluxes[f0.se &lt; 1e4, sqrt(f0.se)])

## End(Not run)

</code></pre>

<hr>
<h2 id='lin.fit'>Linear concentration - time model</h2><span id='topic+lin.fit'></span>

<h3>Description</h3>

<p>Fit a linear model to concentration - time data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lin.fit(t, C, A = 1, V, serie = "", verbose = TRUE, plot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lin.fit_+3A_t">t</code></td>
<td>
<p>time values (usually in hours)</p>
</td></tr>
<tr><td><code id="lin.fit_+3A_c">C</code></td>
<td>
<p>concentration values</p>
</td></tr>
<tr><td><code id="lin.fit_+3A_a">A</code></td>
<td>
<p>area covered by the chamber</p>
</td></tr>
<tr><td><code id="lin.fit_+3A_v">V</code></td>
<td>
<p>effective volume of the chamber</p>
</td></tr>
<tr><td><code id="lin.fit_+3A_serie">serie</code></td>
<td>
<p>id of the flux measurement</p>
</td></tr>
<tr><td><code id="lin.fit_+3A_verbose">verbose</code></td>
<td>
<p>logical, TRUE prints message after each flux calculation</p>
</td></tr>
<tr><td><code id="lin.fit_+3A_plot">plot</code></td>
<td>
<p>logical, mainly intended for use in <code><a href="#topic+gasfluxes">gasfluxes</a></code></p>
</td></tr>
<tr><td><code id="lin.fit_+3A_...">...</code></td>
<td>
<p>further parameters, currently none</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is basically a wrapper of R's OLS fitting facilities. For now <code><a href="stats.html#topic+lm">lm</a></code> (and methods for objects of class &quot;lm&quot;) is used, 
but this may change to more efficient alternatives in later versions.
</p>


<h3>Value</h3>

<p>A list of
</p>
<table>
<tr><td><code>f0</code></td>
<td>
<p>flux estimate</p>
</td></tr>
<tr><td><code>f0.se</code></td>
<td>
<p>standard error of flux estimate</p>
</td></tr>
<tr><td><code>f0.p</code></td>
<td>
<p>p-value of flux estimate</p>
</td></tr>
<tr><td><code>C0</code></td>
<td>
<p>estimated concentration at t = 0 (intercept)</p>
</td></tr>  
<tr><td><code>AIC</code></td>
<td>
<p>Akaike information criterion</p>
</td></tr> 
<tr><td><code>AICc</code></td>
<td>
<p>Akaike information criterion with small sample correction</p>
</td></tr>
<tr><td><code>RSE</code></td>
<td>
<p>residual standard error (sigma from summary.nls)</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>Pearson's correlation coefficient</p>
</td></tr>
<tr><td><code>diagnostics</code></td>
<td>
<p>error or warning messages</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#a single fit
t &lt;- c(0, 1/3, 2/3, 1)
C &lt;- c(320, 341, 352, 359)
print(fit &lt;- lin.fit(t, C, 1, 0.3, "a"))
plot(C ~ t)
curve({fit$f0/0.3 * x + fit$C0}, from = 0, to = 1, add = TRUE)

</code></pre>

<hr>
<h2 id='NDFE.fit'>NDFE fit</h2><span id='topic+NDFE.fit'></span>

<h3>Description</h3>

<p>Fit the the non-steady-state diffusive flux extimator model using the Golub-Pereyra algorithm for partially linear least-squares models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NDFE.fit(
  t,
  C,
  A = 1,
  V,
  serie = "",
  k = log(0.01),
  verbose = TRUE,
  plot = FALSE,
  maxiter = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NDFE.fit_+3A_t">t</code></td>
<td>
<p>time values (usually in hours)</p>
</td></tr>
<tr><td><code id="NDFE.fit_+3A_c">C</code></td>
<td>
<p>concentration values</p>
</td></tr>
<tr><td><code id="NDFE.fit_+3A_a">A</code></td>
<td>
<p>area covered by the chamber</p>
</td></tr>
<tr><td><code id="NDFE.fit_+3A_v">V</code></td>
<td>
<p>effective volume of the chamber</p>
</td></tr>
<tr><td><code id="NDFE.fit_+3A_serie">serie</code></td>
<td>
<p>id of the flux measurement</p>
</td></tr>
<tr><td><code id="NDFE.fit_+3A_k">k</code></td>
<td>
<p>starting value for nls function</p>
</td></tr>
<tr><td><code id="NDFE.fit_+3A_verbose">verbose</code></td>
<td>
<p>logical, TRUE prints message after each flux calculation</p>
</td></tr>
<tr><td><code id="NDFE.fit_+3A_plot">plot</code></td>
<td>
<p>logical, mainly intended for use in <code><a href="#topic+gasfluxes">gasfluxes</a></code></p>
</td></tr>
<tr><td><code id="NDFE.fit_+3A_maxiter">maxiter</code></td>
<td>
<p>see <code><a href="stats.html#topic+nls.control">nls.control</a></code></p>
</td></tr>
<tr><td><code id="NDFE.fit_+3A_...">...</code></td>
<td>
<p>further parameters, currently none</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NDFE model (Livingston et al., 2006) is <code class="reqn">C(t)=C_0+f_0\tau \frac{A}{V}\left [\frac{2}{\sqrt{\textup{pi}}}\sqrt{t/\tau}+e^{t/\tau}\textup{erfc}(\sqrt{t/\tau})-1\right ]</code>.
To ensure the lower bound <code class="reqn">\tau &gt; 0</code>, the substituion <code class="reqn">\tau = e^k</code> is used. The resulting reparameterized model is then 
fit using <code><a href="stats.html#topic+nls">nls</a></code> with <code>algorithm = "plinear"</code>. 
</p>
<p>Note that according to the reference the model is not valid for negative fluxes. Warning: This function does not check if fluxes are positive. It's left to the user to handle negative fluxes.
</p>
<p>The default starting value <code class="reqn">k = log(\tau)</code> assumes that time is in hours. If you use a different time unit, you should adjust it accordingly.
</p>
<p>Note that <code>nls</code> is used internally and thus this function should not be used with artificial &quot;zero-residual&quot; data.
</p>


<h3>Value</h3>

<p>A list of
</p>
<table>
<tr><td><code>f0</code></td>
<td>
<p>flux estimate</p>
</td></tr>
<tr><td><code>f0.se</code></td>
<td>
<p>standard error of flux estimate</p>
</td></tr>
<tr><td><code>f0.p</code></td>
<td>
<p>p-value of flux estimate</p>
</td></tr>
<tr><td><code>C0</code>, <code>tau</code></td>
<td>
<p>other parameters of the NDFE model</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike information criterion</p>
</td></tr>
<tr><td><code>AICc</code></td>
<td>
<p>Akaike information criterion with small sample correction</p>
</td></tr>
<tr><td><code>RSE</code></td>
<td>
<p>residual standard error (sigma from summary.nls)</p>
</td></tr>
<tr><td><code>diagnostics</code></td>
<td>
<p>error or warning messages</p>
</td></tr>
</table>


<h3>References</h3>

<p>Livingston, G.P., Hutchinson, G.L., Spartalian, K., 2006. Trace gas emission in chambers: A non-steady-state diffusion model. Soil Sci. Soc. Am. J. 70(5), 1459-1469.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#a single fit
t &lt;- c(0, 1/3, 2/3, 1)
C &lt;- c(320, 340, 355, 362)
print(fit &lt;- NDFE.fit(t, C, 1, 0.3, "a"))
plot(C ~ t)
curve({fit$C0+fit$f0*fit$tau*1/0.3*(2/sqrt(pi)*sqrt(x/fit$tau)+
      exp(x/fit$tau)*erfc(sqrt(x/fit$tau))-1)}, 
      from = 0, to = 1, add = TRUE)
#note that the flux estimate is very uncertain because 
#there are no data points in the region of high curvature

</code></pre>

<hr>
<h2 id='rlin.fit'>Robust linear concentration - time model</h2><span id='topic+rlin.fit'></span>

<h3>Description</h3>

<p>Fit a linear model to concentration - time data using robust methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlin.fit(t, C, A = 1, V, serie = "", verbose = TRUE, plot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlin.fit_+3A_t">t</code></td>
<td>
<p>time values (usually in hours)</p>
</td></tr>
<tr><td><code id="rlin.fit_+3A_c">C</code></td>
<td>
<p>concentration values</p>
</td></tr>
<tr><td><code id="rlin.fit_+3A_a">A</code></td>
<td>
<p>area covered by the chamber</p>
</td></tr>
<tr><td><code id="rlin.fit_+3A_v">V</code></td>
<td>
<p>effective volume of the chamber</p>
</td></tr>
<tr><td><code id="rlin.fit_+3A_serie">serie</code></td>
<td>
<p>id of the flux measurement</p>
</td></tr>
<tr><td><code id="rlin.fit_+3A_verbose">verbose</code></td>
<td>
<p>logical, TRUE prints message after each flux calculation</p>
</td></tr>
<tr><td><code id="rlin.fit_+3A_plot">plot</code></td>
<td>
<p>logical, mainly intended for use in <code><a href="#topic+gasfluxes">gasfluxes</a></code></p>
</td></tr>
<tr><td><code id="rlin.fit_+3A_...">...</code></td>
<td>
<p>further parameters, currently none</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is basically a wrapper of <code><a href="MASS.html#topic+rlm">rlm</a></code> using the Huber M estimator. This function never weights the first or last time point with zero with very few data points. However, there might exist &quot;better&quot; robust regression methods for flux estimation.
</p>


<h3>Value</h3>

<p>A list of
</p>
<table>
<tr><td><code>f0</code></td>
<td>
<p>flux estimate</p>
</td></tr>
<tr><td><code>f0.se</code></td>
<td>
<p>standard error of flux estimate</p>
</td></tr>
<tr><td><code>f0.p</code></td>
<td>
<p>p-value of flux estimate</p>
</td></tr>
<tr><td><code>C0</code></td>
<td>
<p>estimated concentration at t = 0 (intercept)</p>
</td></tr>  
<tr><td><code>weights</code></td>
<td>
<p>robustness weights</p>
</td></tr>
<tr><td><code>diagnostics</code></td>
<td>
<p>error or warning messages</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#a single fit
t &lt;- c(0, 1/3, 2/3, 1)
C &lt;- c(320, 330, 315, 351)
print(fit &lt;- rlin.fit(t, C, 1, 0.3, "a"))
plot(C ~ t)
curve({fit$f0/0.3 * x + fit$C0}, from = 0, to = 1, add = TRUE)

</code></pre>

<hr>
<h2 id='selectfluxes'>Select a flux estimate</h2><span id='topic+selectfluxes'></span>

<h3>Description</h3>

<p>Selects the appropriate flux estimate from linear, robust linear and non-linear calculated fluxes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectfluxes(dat, select, f.detect = NULL, t.meas = NULL, tol = 5e-05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectfluxes_+3A_dat">dat</code></td>
<td>
<p>a data.table as returned by <code><a href="#topic+gasfluxes">gasfluxes</a></code>. The function modifies it by reference.</p>
</td></tr>
<tr><td><code id="selectfluxes_+3A_select">select</code></td>
<td>
<p>character; specify a ruleset for selection of the final flux value, see details.</p>
</td></tr>
<tr><td><code id="selectfluxes_+3A_f.detect">f.detect</code></td>
<td>
<p>detection limit for HMR method. This can be determined by a simple simulation (see examples) or for four data points the approximation in Parkin et al. (2012) can be used.</p>
</td></tr>
<tr><td><code id="selectfluxes_+3A_t.meas">t.meas</code></td>
<td>
<p>a vector or single value giving the measurement time factor that relates to kappa.max. It is suggested to use the time difference between the first and last sample taken from the closed chamber. The unit should be consistent with the units of <code>f.detect</code> and kappa (e.g., h if kappa is in 1/h).</p>
</td></tr>
<tr><td><code id="selectfluxes_+3A_tol">tol</code></td>
<td>
<p>the relative tolerance <code>abs((linear.f0 - HMR.f0)/HMR.f0)</code> below which the linear flux estimate and the HMR flux estimate are considered equal in the &quot;kappa.max&quot; algorithm. This is to protect against HMR fits that equal the linear fit and have extremely high standard errors. Defaults to <code>tol = 5e-5</code>.</p>
</td></tr>
<tr><td><code id="selectfluxes_+3A_...">...</code></td>
<td>
<p>further parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available selection algorithms currently are
</p>

<dl>
<dt>&quot;kappa.max&quot;</dt><dd><p>The selection algorithm restricts the use of HMR by imposing a maximal value for kappa &quot;kappa.max&quot;, 
depending on the quotient of the linear flux estimate and the minimal detectable flux (f.detect), as well as 
the chamber closure time (t.meas). kappa.max = f.lin/f.detect/t.meas. This is currently the recommended algorithm. 
Note that the algorithm was developed for predominantly positive fluxes (such as N2O fluxes). If data with considerable gas uptake is analyzed, the algorithm needs to be modified, which currently means the user needs to implement it themselves.</p>
</dd>
</dl>

<p>Other selection algorithms could be implemented, but selection can always be done as a postprocessing step. E.g., if many data points are available for each flux measurement it is probably most sensible to use AICc.
</p>


<h3>Value</h3>

<p>A data.table with the with following columns added to the function input: selected flux estimate, the corresponding standard error and p-value and the method with which the selected flux was estimated. 
For the  &quot;kappa.max&quot; method the &quot;kappa.max&quot; values are included. These columns are also added to the input data.table by reference.
</p>


<h3>References</h3>

<p>Parkin, T.B., Venterea, R.T., Hargreaves, S.K., 2012. Calculating the Detection Limits of Chamber-based Soil Greenhouse Gas Flux Measurements. Journal of Environmental Quality 41, 705-715.
</p>
<p>Hueppi, R., Felber, R., Krauss, M., Six, J., Leifeld, J., Fuss, R., 2018. Restricting the nonlinearity parameter in soil greenhouse gas flux calculation for more reliable flux estimates. PLOS ONE 13(7): e0200876. https://doi.org/10.1371/journal.pone.0200876
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
res &lt;- gasfluxes(fluxMeas[1:499], 
                 .id = "serie", .V = "V", .A = "A",
                 .times = "time", .C = "C",
                 methods = c("linear", "robust linear", "HMR"), verbose = FALSE, plot = FALSE)

### estimate f.detect by simulation ###
#ambient concentration:
C0 &lt;- 320/1000 * 28 * 273.15 / 22.4 / (273.15 + 15) #mg N / m^3
#uncertainty of GC measurement:
sdGC &lt;- 5/1000 * 28 * 273.15 / 22.4 / (273.15 + 15) #mg N / m^3 
#create simulated concentrations corresponding to 1 hour flux measurements with zero fluxes:
set.seed(42)
sim &lt;- data.frame(t = seq(0, 1, length.out = 4), C = rnorm(4e3, mean = C0, sd = sdGC), 
                  id = rep(1:1e3, each = 4), A = 1, V = 0.52)
#fit HMR model:                  
simflux &lt;- gasfluxes(sim, .id = "id", .times = "t", methods = c("HMR", "linear"), plot = FALSE) 
simflux[, f0 := HMR.f0]
simflux[is.na(f0), f0 := linear.f0]
#dection limit as 97.5 % quantile (95 % confidence):
f.detect &lt;- simflux[, quantile(f0, 0.975)] #0.03 mg N / m^2 / h

# example using the kappa.max (ref. Hueppi et al., 2018) with a single t.meas value
t.meas &lt;- max(fluxMeas$time[1:499]) #1
selectfluxes(res, "kappa.max", f.detect = f.detect, t.meas = t.meas)
res[method == "HMR", .N] # 11        

# example using the kappa.max with a vector for t.meas
t.meas &lt;- fluxMeas[1:499][, max(time), by = serie][["V1"]]
selectfluxes(res, "kappa.max", f.detect = f.detect, t.meas = t.meas)
res[method == "HMR", .N] # 10                  

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
