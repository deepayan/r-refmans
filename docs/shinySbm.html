<!DOCTYPE html><html><head><title>Help for package shinySbm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {shinySbm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#FungusTreeNetwork'><p>FungusTreeNetwork</p></a></li>
<li><a href='#get_adjacency'><p>get_adjacency</p></a></li>
<li><a href='#get_adjacency.default'><p>get_adjacency.default</p></a></li>
<li><a href='#get_block'><p>get_block generic</p></a></li>
<li><a href='#get_block.BipartiteSBM_fit'><p>get_block.BipartiteSBM_fit method</p></a></li>
<li><a href='#get_block.SimpleSBM_fit'><p>get_block.SimpleSBM_fit method</p></a></li>
<li><a href='#get_flextable'><p>get_flextable</p></a></li>
<li><a href='#plotSbm'><p>plotSbm</p></a></li>
<li><a href='#plotSbm.BipartiteSBM_fit'><p>plotSbm.BipartiteSBM_fit Method</p></a></li>
<li><a href='#plotSbm.default'><p>plotSbm.default Method</p></a></li>
<li><a href='#plotSbm.matrix'><p>plotSbm.matrix Method</p></a></li>
<li><a href='#plotSbm.SimpleSBM_fit'><p>plotSbm.SimpleSBM_fit Method</p></a></li>
<li><a href='#shinySbmApp'><p>Run the Shiny Application</p></a></li>
<li><a href='#visSbm'><p>visSbm</p></a></li>
<li><a href='#visSbm.BipartiteSBM_fit'><p>visSbm</p></a></li>
<li><a href='#visSbm.default'><p>visSbm</p></a></li>
<li><a href='#visSbm.SimpleSBM_fit'><p>visSbm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>'shiny' Application to Use the Stochastic Block Model</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Description:</td>
<td>A 'shiny' interface for a simpler use of the 'sbm' R package. 
    It also contains useful functions to easily explore the 'sbm' package results. 
    With this package you should be able to use the stochastic block model 
    without any knowledge in R, get automatic reports and nice visuals, as 
    well as learning the basic functions of 'sbm'.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Jo-Theo/shinySbm/issues">https://github.com/Jo-Theo/shinySbm/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.50), sbm</td>
</tr>
<tr>
<td>Imports:</td>
<td>colourpicker, config (&ge; 0.3.1), data.table, dplyr, DT,
flextable, fresh, ggplot2, golem (&ge; 0.3.5), magrittr,
parallel, patchwork, purrr, rmarkdown, shiny (&ge; 1.7.2),
shinyalert, shinydashboard, stringr, visNetwork</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, spelling, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-07 16:37:53 UTC; theodore</td>
</tr>
<tr>
<td>Author:</td>
<td>Theodore Vanrenterghem [cre, aut],
  Julie Aubert <a href="https://orcid.org/0000-0001-5203-5748"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Saint-Clair Chabert-Liddell
    <a href="https://orcid.org/0000-0001-5604-7308"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  groÃŸBM team [ctb],
  Golem User [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Theodore Vanrenterghem &lt;shiny.sbm.dev@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-07 21:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling 'rhs(lhs)'.
</p>

<hr>
<h2 id='FungusTreeNetwork'>FungusTreeNetwork</h2><span id='topic+FungusTreeNetwork'></span>

<h3>Description</h3>

<p>fungus-tree interaction network
</p>
<p>This data set provides information about $154$ fungi sampled on $51$ tree species.
Composed of nodes and edges lists build based on 'sbm' data package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FungusTreeNetwork
</code></pre>


<h3>Format</h3>

<p>A list of the following entries:
</p>

<dl>
<dt>networks</dt><dd>

<ul>
<li><p>tree_names: (character) tree names
</p>
</li>
<li><p>fungus_names: (character) fungus names
</p>
</li>
<li><p>tree_tree
</p>

<ol>
<li><p>nodes: data.frame describing nodes of tree_tree network
</p>
</li>
<li><p>edges: data.frame describing edges of tree_tree network
</p>
</li>
<li><p>type: this network is &quot;unipartite&quot;
</p>
</li></ol>


</li>
<li><p>fungus_tree
</p>

<ol>
<li><p>nodes: data.frame describing nodes of fungus_tree network
</p>
</li>
<li><p>edges: data.frame describing edges of fungus_tree network
</p>
</li>
<li><p>type: this network is &quot;bipartite&quot;
</p>
</li></ol>


</li></ul>

</dd>
<dt>sbmResults</dt><dd>

<ul>
<li><p>tree_treeResults of <code>estimateSimpleSBM</code> for sbm
applied on tree_tree data with a Poisson model.
</p>
</li>
<li><p>fungus_treeResults of <code>estimateBipartiteSBM</code> for sbm
applied on fungus_tree data with a Bernoulli model.
</p>
</li></ul>

</dd>
</dl>



<h3>Source</h3>

<p>Vacher, Corinne, Dominique Piou, and Marie-Laure Desprez-Loustau. &quot;Architecture of an antagonistic tree/fungus network: the asymmetric influence of past evolutionary history.&quot; PloS one 3.3 (2008): e1740.
</p>

<hr>
<h2 id='get_adjacency'>get_adjacency</h2><span id='topic+get_adjacency'></span>

<h3>Description</h3>

<p>A fct that build an adjacency matrix from a list of edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_adjacency(edges, type = c("unipartite", "bipartite"), directed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_adjacency_+3A_edges">edges</code></td>
<td>
<p>Can be a table which is a list pair of nodes (nodes ids are one the two first columns) a numerical third column can be associated will be the connections values.</p>
</td></tr>
<tr><td><code id="get_adjacency_+3A_type">type</code></td>
<td>
<p>network type can be ''bipartite'&lsquo; or '&rsquo;unipartite''</p>
</td></tr>
<tr><td><code id="get_adjacency_+3A_directed">directed</code></td>
<td>
<p>whether or not connections are directed ('TRUE') or symmetrical ('FALSE') (default is set to 'TRUE')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an adjacency/incidence matrix (data.frame) representing the network
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For unipartite network
data_uni &lt;- FungusTreeNetwork$networks$tree_tree

# If the network is symmetric:
my_mat &lt;- get_adjacency(data_uni$edges,
  type = data_uni$type,
  directed = FALSE
)
# If the network is directed:
my_mat &lt;- get_adjacency(data_uni$edges,
  type = data_uni$type,
  directed = TRUE
)

# For bipartite network
data_bi &lt;- FungusTreeNetwork$networks$fungus_tree

my_mat &lt;- get_adjacency(data_bi$edges, type = data_bi$type)

# In any case with a 2 columns data.frames the network is considered binary and each line is a 1.
binary_net &lt;- FungusTreeNetwork$fungus_tree$edges[, -3]

my_mat &lt;- get_adjacency(binary_net, type = data_bi$type)

</code></pre>

<hr>
<h2 id='get_adjacency.default'>get_adjacency.default</h2><span id='topic+get_adjacency.default'></span>

<h3>Description</h3>

<p>A fct that build an adjacency matrix from a list of edges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
get_adjacency(edges, type = c("unipartite", "bipartite"), directed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_adjacency.default_+3A_edges">edges</code></td>
<td>
<p>Can be a table which is a list pair of nodes (nodes ids are one the two first columns) a numerical third column can be associated will be the connections values.</p>
</td></tr>
<tr><td><code id="get_adjacency.default_+3A_type">type</code></td>
<td>
<p>network type can be ''bipartite'&lsquo; or '&rsquo;unipartite''</p>
</td></tr>
<tr><td><code id="get_adjacency.default_+3A_directed">directed</code></td>
<td>
<p>whether or not connections are directed ('TRUE') or symmetrical ('FALSE') (default is set to 'TRUE')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an adjacency/incidence matrix (data.frame) representing the network
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For unipartite network
data_uni &lt;- FungusTreeNetwork$networks$tree_tree

# If the network is symmetric:
my_mat &lt;- get_adjacency(data_uni$edges,
  type = data_uni$type,
  directed = FALSE
)
# If the network is directed:
my_mat &lt;- get_adjacency(data_uni$edges,
  type = data_uni$type,
  directed = TRUE
)

# For bipartite network
data_bi &lt;- FungusTreeNetwork$networks$fungus_tree

my_mat &lt;- get_adjacency(data_bi$edges, type = data_bi$type)

# In any case with a 2 columns data.frames the network is considered binary and each line is a 1.
binary_net &lt;- FungusTreeNetwork$fungus_tree$edges[, -3]

my_mat &lt;- get_adjacency(binary_net, type = data_bi$type)

</code></pre>

<hr>
<h2 id='get_block'>get_block generic</h2><span id='topic+get_block'></span>

<h3>Description</h3>

<p>A fct that return blocks attribution or probabilities for each nodes in a Sbm fit from the sbm package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_block(
  x,
  labels = "default",
  node_names = NULL,
  attribution = TRUE,
  proportion = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_block_+3A_x">x</code></td>
<td>
<p>Sbm model of class 'BipartiteSBM_fit', 'SimpleSBM_fit'.</p>
</td></tr>
<tr><td><code id="get_block_+3A_labels">labels</code></td>
<td>
<p>labels for nodes. If it's simple sbm it should be a single character (&quot;default&quot; -&gt; c(&quot;nodes&quot;)). If sbm is bipartite a named character (names are row and col) (&quot;default&quot; -&gt; c(row = 'row', col = 'col')).</p>
</td></tr>
<tr><td><code id="get_block_+3A_node_names">node_names</code></td>
<td>

<ul>
<li><p>&quot;bipartite case&quot;: named list (&quot;row&quot;,&quot;col&quot;), row is a character vector containing names of nodes in rows, and respectively for columns
</p>
</li>
<li><p>&quot;unipartite case&quot;: character: node names
</p>
</li></ul>
</td></tr>
<tr><td><code id="get_block_+3A_attribution">attribution</code></td>
<td>
<p>Boolean indicating whether or not the produced tables should contain a block attribution column. This column shows the block in which each nodes is the most likely to be.</p>
</td></tr>
<tr><td><code id="get_block_+3A_proportion">proportion</code></td>
<td>
<p>Boolean indicating whether or not the produced tables should contain the probabilities to belong in each blocks. These columns shows for every nodes and every blocks the probabilities that the node belong to the block.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p>&quot;bipartite case&quot;: A list containing two data.frames with block attributions and/or proportions one for the row blocks and one for the column blocks
</p>
</li>
<li><p>&quot;unipartite case&quot;: A data.frame with block attributions and/or proportions
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# my_sbm_bi &lt;- sbm::estimateBipartiteSBM(sbm::fungusTreeNetwork$fungus_tree,
#                                        model = 'bernoulli')
my_sbm_bi &lt;- FungusTreeNetwork$sbmResults$fungus_tree

node_names_bi &lt;- list(
  row = FungusTreeNetwork$networks$fungus_names,
  col = FungusTreeNetwork$networks$tree_names
)

my_blocks_bi &lt;- get_block(my_sbm_bi,
  labels = c(row = "Fungus", col = "Tree"),
  node_names = node_names_bi
)
my_blocks_bi$row
my_blocks_bi$col

# my_sbm_uni &lt;- sbm::estimateSimpleSBM(sbm::fungusTreeNetwork$tree_tree,
#                                      model = "poisson")
my_sbm_uni &lt;- FungusTreeNetwork$sbmResults$tree_tree

node_names_uni &lt;- list(FungusTreeNetwork$networks$tree_names)

my_blocks_uni &lt;- get_block(my_sbm_uni,
  labels = c("Tree"),
  node_names = node_names_uni
)
my_blocks_uni
</code></pre>

<hr>
<h2 id='get_block.BipartiteSBM_fit'>get_block.BipartiteSBM_fit method</h2><span id='topic+get_block.BipartiteSBM_fit'></span>

<h3>Description</h3>

<p>A fct that return blocks attribution or probabilities for each nodes in a Sbm fit from the sbm package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BipartiteSBM_fit'
get_block(
  x,
  labels = "default",
  node_names = NULL,
  attribution = TRUE,
  proportion = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_block.BipartiteSBM_fit_+3A_x">x</code></td>
<td>
<p>Sbm model of class 'BipartiteSBM_fit'.</p>
</td></tr>
<tr><td><code id="get_block.BipartiteSBM_fit_+3A_labels">labels</code></td>
<td>
<p>labels for nodes. If it's simple sbm it should be a single character (&quot;default&quot; -&gt; c(&quot;nodes&quot;)). If sbm is bipartite a named character (names are row and col) (&quot;default&quot; -&gt; c(row = 'row', col = 'col')).</p>
</td></tr>
<tr><td><code id="get_block.BipartiteSBM_fit_+3A_node_names">node_names</code></td>
<td>
<p>named list (&quot;row&quot;,&quot;col&quot;), row is a character vector containing names of nodes in rows, and respectively for columns</p>
</td></tr>
<tr><td><code id="get_block.BipartiteSBM_fit_+3A_attribution">attribution</code></td>
<td>
<p>Boolean indicating whether or not the produced tables should contain a block attribution column. This column shows the block in which each nodes is the most likely to be.</p>
</td></tr>
<tr><td><code id="get_block.BipartiteSBM_fit_+3A_proportion">proportion</code></td>
<td>
<p>Boolean indicating whether or not the produced tables should contain the probabilities to belong in each blocks. These columns shows for every nodes and every blocks the probabilities that the node belong to the block.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two data.frames with block attributions and/or proportions one for the row blocks and one for the column blocks
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# my_sbm_bi &lt;- sbm::estimateBipartiteSBM(sbm::fungusTreeNetwork$fungus_tree,
#                                        model = 'bernoulli')
my_sbm_bi &lt;- FungusTreeNetwork$sbmResults$fungus_tree

node_names_bi &lt;- list(
  row = FungusTreeNetwork$networks$fungus_names,
  col = FungusTreeNetwork$networks$tree_names
)

my_blocks_bi &lt;- get_block(my_sbm_bi,
  labels = c(row = "Fungus", col = "Tree"),
  node_names = node_names_bi
)
my_blocks_bi$row
my_blocks_bi$col

</code></pre>

<hr>
<h2 id='get_block.SimpleSBM_fit'>get_block.SimpleSBM_fit method</h2><span id='topic+get_block.SimpleSBM_fit'></span>

<h3>Description</h3>

<p>A fct that return blocks attribution or probabilities for each nodes in a Sbm fit from the sbm package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SimpleSBM_fit'
get_block(
  x,
  labels = "default",
  node_names = NULL,
  attribution = TRUE,
  proportion = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_block.SimpleSBM_fit_+3A_x">x</code></td>
<td>
<p>Sbm model of class 'SimpleSBM_fit'.</p>
</td></tr>
<tr><td><code id="get_block.SimpleSBM_fit_+3A_labels">labels</code></td>
<td>
<p>labels for nodes. If it's simple sbm it should be a single character (&quot;default&quot; -&gt; c(&quot;nodes&quot;)). If sbm is bipartite a named character (names are row and col) (&quot;default&quot; -&gt; c(row = 'row', col = 'col')).</p>
</td></tr>
<tr><td><code id="get_block.SimpleSBM_fit_+3A_node_names">node_names</code></td>
<td>
<p>character: node names</p>
</td></tr>
<tr><td><code id="get_block.SimpleSBM_fit_+3A_attribution">attribution</code></td>
<td>
<p>Boolean indicating whether or not the produced tables should contain a block attribution column. This column shows the block in which each nodes is the most likely to be.</p>
</td></tr>
<tr><td><code id="get_block.SimpleSBM_fit_+3A_proportion">proportion</code></td>
<td>
<p>Boolean indicating whether or not the produced tables should contain the probabilities to belong in each blocks. These columns shows for every nodes and every blocks the probabilities that the node belong to the block.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with block attributions and/or proportions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# my_sbm_uni &lt;- sbm::estimateSimpleSBM(sbm::fungusTreeNetwork$tree_tree,
#                                      model = "poisson")
my_sbm_uni &lt;- FungusTreeNetwork$sbmResults$tree_tree

node_names_uni &lt;- list(FungusTreeNetwork$networks$tree_names)

my_blocks_uni &lt;- get_block(my_sbm_uni,
  labels = c("Tree"),
  node_names = node_names_uni
)
my_blocks_uni
</code></pre>

<hr>
<h2 id='get_flextable'>get_flextable</h2><span id='topic+get_flextable'></span>

<h3>Description</h3>

<p>A fct that build a flextable from an sbm object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_flextable(
  sbm,
  labels = "default",
  type = c("blockProp", "connectParam", "storedModels"),
  settings = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_flextable_+3A_sbm">sbm</code></td>
<td>
<p>an sbm model product of sbm estimation (simple or bipartite)</p>
</td></tr>
<tr><td><code id="get_flextable_+3A_labels">labels</code></td>
<td>
<p>labels for nodes.
If it's simple sbm it should be a single character (&quot;default&quot; -&gt; c(&quot;nodes&quot;)).
If sbm is bipartite a named character (names are row and col) (&quot;default&quot; -&gt; c(row = 'row', col = 'col')).</p>
</td></tr>
<tr><td><code id="get_flextable_+3A_type">type</code></td>
<td>
<p>the type of table wanted.</p>
</td></tr>
<tr><td><code id="get_flextable_+3A_settings">settings</code></td>
<td>
<p>a list of settings</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Values of <code>type</code>
</p>

<ul>
<li><p>'blockProp': gives the block proportions.
</p>
</li>
<li><p>'connectParam': gives the block connectivity.
</p>
</li>
<li><p>'storedModels': gives the stored modems summary.
</p>
</li></ul>

<p>The list of parameters <code>settings</code> for the flextable
</p>

<ul>
<li><p>&quot;caption&quot;: Caption is the flextable title (character)
</p>
</li>
<li><p>&quot;digits&quot;: nb of digits wanted to be shown in the table
</p>
</li>
<li><p>&quot;selected_col&quot;: Color highlighting the selected model
</p>
</li>
<li><p>&quot;best_col&quot;: Color of text for the best model
</p>
</li></ul>



<h3>Value</h3>

<p>Return the selected flextable
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# my_sbm &lt;- sbm::estimateBipartiteSBM(sbm::fungusTreeNetwork$fungus_tree,
#                                     model = 'bernoulli')
my_sbm &lt;- FungusTreeNetwork$sbmResults$fungus_tree

get_flextable(my_sbm,
  labels = c(row = "Fungus", col = "Trees"),
  type = "blockProp"
)

get_flextable(my_sbm,
  labels = c(row = "Fungus", col = "Trees"),
  type = "connectParam", settings = list(digits = 5)
)

get_flextable(my_sbm,
  labels = "default",
  type = "storedModels", settings = list(caption = "New Title")
)

</code></pre>

<hr>
<h2 id='plotSbm'>plotSbm</h2><span id='topic+plotSbm'></span>

<h3>Description</h3>

<p>A fct that plot a beautiful matrix from an sbm object or a network matrix it does
have suitable parameters to get the wanted plots. This is the generic function:
it does have one method Bipartite and one for Simple Sbm. The 'x' object need
to be construct by one of the 'estimate***SBM' function from the 'sbm' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSbm(
  x,
  ordered = FALSE,
  transpose = FALSE,
  labels = NULL,
  plotOptions = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSbm_+3A_x">x</code></td>
<td>
<p>Sbm model of class 'BipartiteSBM_fit', 'SimpleSBM_fit' or simple numeric 'matrix'.</p>
</td></tr>
<tr><td><code id="plotSbm_+3A_ordered">ordered</code></td>
<td>
<p>Boolean. Set <code>TRUE</code> if the matrix should be reordered (Default is <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="plotSbm_+3A_transpose">transpose</code></td>
<td>
<p>Boolean. Set <code>TRUE</code> to invert columns and rows to flatten a long matrix (Default is <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="plotSbm_+3A_labels">labels</code></td>
<td>
<p>a named list (names should be: '&quot;col&quot;' and '&quot;row&quot;') of characters describing columns and rows component (Default is <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="plotSbm_+3A_plotoptions">plotOptions</code></td>
<td>
<p>a list providing options. See details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of parameters <code>plotOptions</code> for the matrix plot is
</p>

<ul>
<li><p>&quot;showValues&quot;: Boolean. Set TRUE to see the real values. Default value is TRUE
</p>
</li>
<li><p>&quot;showPredictions&quot;: Boolean. Set TRUE to see the predicted values. Default value is TRUE
</p>
</li>
<li><p>&quot;title&quot;: Title in characters. Will be printed at the bottom of the matrix. Default value is NULL
</p>
</li>
<li><p>&quot;colPred&quot;: Color of the predicted values, the small values will be more transparent. Default value is &quot;red&quot;
</p>
</li>
<li><p>&quot;colValue&quot;: Color of the real values, the small values will close to white. Default value is &quot;black&quot;
</p>
</li>
<li><p>&quot;showLegend&quot;: Should a legend be printed ? TRUE or FALSE, default:  FALSE
</p>
</li>
<li><p>&quot;interactionName&quot;: Name of connection in legend default: &quot;Connection&quot;
</p>
</li></ul>



<h3>Value</h3>

<p>a ggplot object corresponding to the matrix plot inside the app.
Groups the network matrix is organized by blocks, the small tiles are for
individuals connections. The big tiles between red lines are for block connectivity
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# my_sbm_bi &lt;- sbm::estimateBipartiteSBM(sbm::fungusTreeNetwork$fungus_tree,
#                                        model = 'bernoulli')
my_sbm_bi &lt;- FungusTreeNetwork$sbmResults$fungus_tree

plotSbm(my_sbm_bi,
  ordered = TRUE, transpose = TRUE,
  plotOptions = list(title = "An example Matrix")
)


# my_sbm_uni &lt;- sbm::estimateSimpleSBM(sbm::fungusTreeNetwork$tree_tree,
#                                      model = "poisson")
my_sbm_uni &lt;- FungusTreeNetwork$sbmResults$tree_tree

plotSbm(my_sbm_uni,
  ordered = TRUE,
  plotOptions = list(title = "An example Matrix")
)

n_col &lt;- 100
n_row &lt;- 90
mat &lt;- matrix(sample(0:10, n_col * n_row, replace = TRUE), n_col, n_row)
plotSbm(mat,
  transpose = TRUE,
  labels = list(col = "Columns", row = "Rows"),
  plotOptions = list(colValue = "blue")
)

</code></pre>

<hr>
<h2 id='plotSbm.BipartiteSBM_fit'>plotSbm.BipartiteSBM_fit Method</h2><span id='topic+plotSbm.BipartiteSBM_fit'></span>

<h3>Description</h3>

<p>plotSbm method for BipartiteSBM_fit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BipartiteSBM_fit'
plotSbm(
  x,
  ordered = FALSE,
  transpose = FALSE,
  labels = NULL,
  plotOptions = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSbm.BipartiteSBM_fit_+3A_x">x</code></td>
<td>
<p>an Sbm model of class '&quot;BipartiteSBM_fit&quot;'</p>
</td></tr>
<tr><td><code id="plotSbm.BipartiteSBM_fit_+3A_ordered">ordered</code></td>
<td>
<p>Boolean. Set <code>TRUE</code> if the matrix should be reordered (Default is <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="plotSbm.BipartiteSBM_fit_+3A_transpose">transpose</code></td>
<td>
<p>Boolean. Set <code>TRUE</code> to invert columns and rows to flatten a long matrix (Default is <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="plotSbm.BipartiteSBM_fit_+3A_labels">labels</code></td>
<td>
<p>named list (names should be: '&quot;col&quot;' and '&quot;row&quot;') of characters describing columns and rows component (Default is <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="plotSbm.BipartiteSBM_fit_+3A_plotoptions">plotOptions</code></td>
<td>
<p>list providing options. See details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of parameters <code>plotOptions</code> for the matrix plot is
</p>

<ul>
<li><p>&quot;showValues&quot;: Boolean. Set TRUE to see the real values. Default value is TRUE
</p>
</li>
<li><p>&quot;showPredictions&quot;: Boolean. Set TRUE to see the predicted values. Default value is TRUE
</p>
</li>
<li><p>&quot;title&quot;: Title in characters. Will be printed at the bottom of the matrix. Default value is NULL
</p>
</li>
<li><p>&quot;colPred&quot;: Color of the predicted values, the small values will be more transparent. Default value is &quot;red&quot;
</p>
</li>
<li><p>&quot;colValue&quot;: Color of the real values, the small values will close to white. Default value is &quot;black&quot;
</p>
</li>
<li><p>&quot;showLegend&quot;: Should a legend be printed ? TRUE or FALSE, default:  FALSE
</p>
</li>
<li><p>&quot;interactionName&quot;: Name of connection in legend default: &quot;Connection&quot;
</p>
</li></ul>



<h3>Value</h3>

<p>a ggplot object corresponding to the matrix plot inside the app.
Groups the network matrix is organized by blocks, the small tiles are for
individuals connections. The big tiles between red lines are for block connectivity
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# my_sbm_bi &lt;- sbm::estimateBipartiteSBM(sbm::fungusTreeNetwork$fungus_tree,
#                                        model = 'bernoulli')
my_sbm_bi &lt;- FungusTreeNetwork$sbmResults$fungus_tree

plotSbm(my_sbm_bi,
  ordered = TRUE, transpose = TRUE,
  plotOptions = list(title = "An example Matrix")
)

</code></pre>

<hr>
<h2 id='plotSbm.default'>plotSbm.default Method</h2><span id='topic+plotSbm.default'></span>

<h3>Description</h3>

<p>plotSbm method for unknown object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
plotSbm(
  x,
  ordered = FALSE,
  transpose = FALSE,
  labels = NULL,
  plotOptions = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSbm.default_+3A_x">x</code></td>
<td>
<p>any object</p>
</td></tr>
<tr><td><code id="plotSbm.default_+3A_ordered">ordered</code></td>
<td>
<p>isn't used in default method</p>
</td></tr>
<tr><td><code id="plotSbm.default_+3A_transpose">transpose</code></td>
<td>
<p>isn't used in default method</p>
</td></tr>
<tr><td><code id="plotSbm.default_+3A_labels">labels</code></td>
<td>
<p>isn't used in default method</p>
</td></tr>
<tr><td><code id="plotSbm.default_+3A_plotoptions">plotOptions</code></td>
<td>
<p>isn't used in default method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>default plot for x
</p>

<hr>
<h2 id='plotSbm.matrix'>plotSbm.matrix Method</h2><span id='topic+plotSbm.matrix'></span>

<h3>Description</h3>

<p>plotSbm method for matrix object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
plotSbm(
  x,
  ordered = FALSE,
  transpose = FALSE,
  labels = NULL,
  plotOptions = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSbm.matrix_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
<tr><td><code id="plotSbm.matrix_+3A_ordered">ordered</code></td>
<td>
<p>Boolean. Set <code>TRUE</code> if the matrix should be reordered (Default is <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="plotSbm.matrix_+3A_transpose">transpose</code></td>
<td>
<p>Boolean. Set <code>TRUE</code> to invert columns and rows to flatten a long matrix (Default is <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="plotSbm.matrix_+3A_labels">labels</code></td>
<td>
<p>named list (names should be: '&quot;col&quot;' and '&quot;row&quot;') of characters describing columns and rows component (Default is <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="plotSbm.matrix_+3A_plotoptions">plotOptions</code></td>
<td>
<p>list providing options. See details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of parameters <code>plotOptions</code> for the matrix plot is
</p>

<ul>
<li><p>&quot;showValues&quot;: Boolean. Set TRUE to see the real values. Default value is TRUE
</p>
</li>
<li><p>&quot;showPredictions&quot;: Boolean. Set TRUE to see the predicted values. Default value is TRUE
</p>
</li>
<li><p>&quot;title&quot;: Title in characters. Will be printed at the bottom of the matrix. Default value is NULL
</p>
</li>
<li><p>&quot;colPred&quot;: Color of the predicted values, the small values will be more transparent. Default value is &quot;red&quot;
</p>
</li>
<li><p>&quot;colValue&quot;: Color of the real values, the small values will close to white. Default value is &quot;black&quot;
</p>
</li>
<li><p>&quot;showLegend&quot;: Should a legend be printed ? TRUE or FALSE, default:  FALSE
</p>
</li>
<li><p>&quot;interactionName&quot;: Name of connection in legend default: &quot;Connection&quot;
</p>
</li></ul>



<h3>Value</h3>

<p>a ggplot object corresponding to the matrix plot inside the app.
Here because there no 'sbm' information and only a matrix describing a network,
The matrix isn't organized and the tiles are only showing individuals connections.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_col &lt;- 100
n_row &lt;- 90
mat &lt;- matrix(sample(0:10, n_col * n_row, replace = TRUE), n_col, n_row)
plotSbm(mat,
  transpose = TRUE,
  labels = list(col = "Columns", row = "Rows"),
  plotOptions = list(colValue = "blue")
)

</code></pre>

<hr>
<h2 id='plotSbm.SimpleSBM_fit'>plotSbm.SimpleSBM_fit Method</h2><span id='topic+plotSbm.SimpleSBM_fit'></span>

<h3>Description</h3>

<p>plotSbm method for SimpleSBM_fit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SimpleSBM_fit'
plotSbm(
  x,
  ordered = FALSE,
  transpose = FALSE,
  labels = NULL,
  plotOptions = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSbm.SimpleSBM_fit_+3A_x">x</code></td>
<td>
<p>Sbm model of class '&quot;SimpleSBM_fit&quot;'</p>
</td></tr>
<tr><td><code id="plotSbm.SimpleSBM_fit_+3A_ordered">ordered</code></td>
<td>
<p>Boolean. Set <code>TRUE</code> if the matrix should be reordered (Default is <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="plotSbm.SimpleSBM_fit_+3A_transpose">transpose</code></td>
<td>
<p>isn't used in this method</p>
</td></tr>
<tr><td><code id="plotSbm.SimpleSBM_fit_+3A_labels">labels</code></td>
<td>
<p>named list (names should be: '&quot;col&quot;' and '&quot;row&quot;') of characters describing columns and rows component (Default is <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="plotSbm.SimpleSBM_fit_+3A_plotoptions">plotOptions</code></td>
<td>
<p>list providing options. See details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of parameters <code>plotOptions</code> for the matrix plot is
</p>

<ul>
<li><p>&quot;showValues&quot;: Boolean. Set TRUE to see the real values. Default value is TRUE
</p>
</li>
<li><p>&quot;showPredictions&quot;: Boolean. Set TRUE to see the predicted values. Default value is TRUE
</p>
</li>
<li><p>&quot;title&quot;: Title in characters. Will be printed at the bottom of the matrix. Default value is NULL
</p>
</li>
<li><p>&quot;colPred&quot;: Color of the predicted values, the small values will be more transparent. Default value is &quot;red&quot;
</p>
</li>
<li><p>&quot;colValue&quot;: Color of the real values, the small values will close to white. Default value is &quot;black&quot;
</p>
</li>
<li><p>&quot;showLegend&quot;: Should a legend be printed ? TRUE or FALSE, default:  FALSE
</p>
</li>
<li><p>&quot;interactionName&quot;: Name of connection in legend default: &quot;Connection&quot;
</p>
</li></ul>



<h3>Value</h3>

<p>a ggplot object corresponding to the matrix plot inside the app.
Groups the network matrix is organized by blocks, the small tiles are for
individuals connections. The big tiles between red lines are for block connectivity
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# my_sbm_uni &lt;- sbm::estimateSimpleSBM(sbm::fungusTreeNetwork$tree_tree,
#                                      model = "poisson")
my_sbm_uni &lt;- FungusTreeNetwork$sbmResults$tree_tree

plotSbm(my_sbm_uni,
  ordered = TRUE,
  plotOptions = list(title = "An example Matrix")
)

</code></pre>

<hr>
<h2 id='shinySbmApp'>Run the Shiny Application</h2><span id='topic+shinySbmApp'></span>

<h3>Description</h3>

<p>Run the Shiny Application
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shinySbmApp(
  nbCore_control = TRUE,
  console_verbosity = TRUE,
  onStart = NULL,
  options = list(launch.browser = TRUE),
  enableBookmarking = NULL,
  uiPattern = "/",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shinySbmApp_+3A_nbcore_control">nbCore_control</code></td>
<td>
<p>Allow to control the number of Cores when running an 'sbm'</p>
</td></tr>
<tr><td><code id="shinySbmApp_+3A_console_verbosity">console_verbosity</code></td>
<td>
<p>boolean boolean should the console be printing 'sbm' outputs</p>
</td></tr>
<tr><td><code id="shinySbmApp_+3A_onstart">onStart</code></td>
<td>
<p>A function that will be called before the app is actually run.
This is only needed for <code>shinyAppObj</code>, since in the <code>shinyAppDir</code>
case, a <code>global.R</code> file can be used for this purpose.</p>
</td></tr>
<tr><td><code id="shinySbmApp_+3A_options">options</code></td>
<td>
<p>Named options that should be passed to the <code>runApp</code> call
(these can be any of the following: &quot;port&quot;, &quot;launch.browser&quot;, &quot;host&quot;, &quot;quiet&quot;,
&quot;display.mode&quot; and &quot;test.mode&quot;). You can also specify <code>width</code> and
<code>height</code> parameters which provide a hint to the embedding environment
about the ideal height/width for the app.</p>
</td></tr>
<tr><td><code id="shinySbmApp_+3A_enablebookmarking">enableBookmarking</code></td>
<td>
<p>Can be one of <code>"url"</code>, <code>"server"</code>, or
<code>"disable"</code>. The default value, <code>NULL</code>, will respect the setting from
any previous calls to  <code><a href="shiny.html#topic+enableBookmarking">enableBookmarking()</a></code>. See <code><a href="shiny.html#topic+enableBookmarking">enableBookmarking()</a></code>
for more information on bookmarking your app.</p>
</td></tr>
<tr><td><code id="shinySbmApp_+3A_uipattern">uiPattern</code></td>
<td>
<p>A regular expression that will be applied to each <code>GET</code>
request to determine whether the <code>ui</code> should be used to handle the
request. Note that the entire request path must match the regular
expression in order for the match to be considered successful.</p>
</td></tr>
<tr><td><code id="shinySbmApp_+3A_...">...</code></td>
<td>
<p>arguments to pass to golem_opts.
See '?golem::get_golem_options' for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to launch the 'shiny' application
</p>

<hr>
<h2 id='visSbm'>visSbm</h2><span id='topic+visSbm'></span>

<h3>Description</h3>

<p>A fct that plot a visNetwork plot of a adjacency matrix or an Sbm fit from the sbm package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visSbm(
  x,
  labels = "default",
  node_names = NULL,
  directed = "default",
  settings = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visSbm_+3A_x">x</code></td>
<td>
<p>Sbm model of class 'BipartiteSBM_fit', 'SimpleSBM_fit' or simple numeric 'matrix'.</p>
</td></tr>
<tr><td><code id="visSbm_+3A_labels">labels</code></td>
<td>
<p>labels for nodes. If it's simple sbm it should be a single character (&quot;default&quot; -&gt; c(&quot;nodes&quot;)).
If sbm is bipartite a named character (names are row and col) (&quot;default&quot; -&gt; c(row = 'row', col = 'col')).</p>
</td></tr>
<tr><td><code id="visSbm_+3A_node_names">node_names</code></td>
<td>
<p>if NULL do nothing specific, but list of nodes are given
the graph get interactive and nodes names are showed by clicking on a block.
In bipartite case a named list:
</p>

<ul>
<li><p>&quot;row&quot;: character: node names in rows
</p>
</li>
<li><p>&quot;col&quot;: character: node names in columns
</p>
</li></ul>

<p>In unipartite case a single character vector containing the nodes names (Default = NULL).</p>
</td></tr>
<tr><td><code id="visSbm_+3A_directed">directed</code></td>
<td>
<p>Boolean indicating whether or not the network is directed by default, a asymmetrical matrix will be seen as directed.</p>
</td></tr>
<tr><td><code id="visSbm_+3A_settings">settings</code></td>
<td>
<p>list of settings</p>
</td></tr>
</table>


<h3>Details</h3>

<p>List of parameters
</p>

<ul>
<li><p>&quot;edge_threshold&quot;: &quot;default&quot; erases as many small edges as it can without isolating any nodes (no connection).
It can also be a numeric value between 0 and 1, relative (between min and max) filter for small edges value
</p>
</li>
<li><p>&quot;edge_color&quot;: character: color of edges (default: &quot;lightblue&quot;)
</p>
</li>
<li><p>&quot;arrows&quot;: boolean: should edges be arrows
</p>
</li>
<li><p>&quot;arrow_thickness&quot;: numeric: arrows size
</p>
</li>
<li><p>&quot;arrow_start&quot;: character: &quot;row&quot; or &quot;col&quot; or labels value according to row or columns. The arrow will start from selected to the the other value
</p>
</li>
<li><p>&quot;node_color&quot;: named character: Bipartite case c(row = &quot;row_color&quot;, col = &quot;col_color&quot;). Unipartite case c(&quot;node_color&quot;)
</p>
</li>
<li><p>&quot;node_shape&quot;: named character: Bipartite case c(row = &quot;row_shape&quot;, col = &quot;col_shape&quot;). Unipartite case c(&quot;node_shape&quot;). Value from visNetwork shape argument of visEdges function (&quot;triangle&quot;,&quot;dot&quot;,&quot;square&quot;,etc...)
</p>
</li>
<li><p>&quot;digits&quot;: integer: number of digits to show when numbers are shown (default: 2)
</p>
</li></ul>



<h3>Value</h3>

<p>a visNetwork visual of the x object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# my_sbm_bi &lt;- sbm::estimateBipartiteSBM(sbm::fungusTreeNetwork$fungus_tree,
#                                        model = 'bernoulli')
my_sbm_bi &lt;- FungusTreeNetwork$sbmResults$fungus_tree

node_names_bi &lt;- list(
  row = FungusTreeNetwork$networks$fungus_names,
  col = FungusTreeNetwork$networks$tree_names
)

visSbm(my_sbm_bi,
  labels = c(row = "Fungus", col = "Tree"),
  node_names = node_names_bi,
  settings = list(
    arrows = TRUE,
    arrow_start = "Fungus",
    node_color = c(row = "pink", col = "green"),
    node_shape = c(row = "dot", col = "square")
  )
)


# my_sbm_uni &lt;- sbm::estimateSimpleSBM(sbm::fungusTreeNetwork$tree_tree,
#                                      model = "poisson")
my_sbm_uni &lt;- FungusTreeNetwork$sbmResults$tree_tree

node_names_uni &lt;- list(FungusTreeNetwork$networks$tree_names)

visSbm(my_sbm_uni,
  labels = c("Tree"),
  node_names = node_names_uni,
  settings = list(
    edge_threshold = 0.01,
    edge_color = "grey",
    node_color = c("violet")
  )
)

</code></pre>

<hr>
<h2 id='visSbm.BipartiteSBM_fit'>visSbm</h2><span id='topic+visSbm.BipartiteSBM_fit'></span>

<h3>Description</h3>

<p>A fct that plot a visNetwork plot of a adjacency matrix or an Sbm fit from the sbm package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BipartiteSBM_fit'
visSbm(
  x,
  labels = "default",
  node_names = NULL,
  directed = "default",
  settings = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visSbm.BipartiteSBM_fit_+3A_x">x</code></td>
<td>
<p>Sbm model of class 'BipartiteSBM_fit', 'SimpleSBM_fit' or simple numeric 'matrix'.</p>
</td></tr>
<tr><td><code id="visSbm.BipartiteSBM_fit_+3A_labels">labels</code></td>
<td>
<p>labels for nodes. If it's simple sbm it should be a single character (&quot;default&quot; -&gt; c(&quot;nodes&quot;)).
If sbm is bipartite a named character (names are row and col) (&quot;default&quot; -&gt; c(row = 'row', col = 'col')).</p>
</td></tr>
<tr><td><code id="visSbm.BipartiteSBM_fit_+3A_node_names">node_names</code></td>
<td>
<p>if NULL do nothing specific, but list of nodes are given
the graph get interactive and nodes names are showed by clicking on a block.
In bipartite case a named list:
</p>

<ul>
<li><p>&quot;row&quot;: character: node names in rows
</p>
</li>
<li><p>&quot;col&quot;: character: node names in columns
</p>
</li></ul>

<p>In unipartite case a single character vector containing the nodes names (Default = NULL).</p>
</td></tr>
<tr><td><code id="visSbm.BipartiteSBM_fit_+3A_directed">directed</code></td>
<td>
<p>Boolean indicating whether or not the network is directed by default, a asymmetrical matrix will be seen as directed.</p>
</td></tr>
<tr><td><code id="visSbm.BipartiteSBM_fit_+3A_settings">settings</code></td>
<td>
<p>list of settings</p>
</td></tr>
</table>


<h3>Details</h3>

<p>List of parameters
</p>

<ul>
<li><p>&quot;edge_threshold&quot;: &quot;default&quot; erases as many small edges as it can without isolating any nodes (no connection).
It can also be a numeric value between 0 and 1, relative (between min and max) filter for small edges value
</p>
</li>
<li><p>&quot;edge_color&quot;: character: color of edges (default: &quot;lightblue&quot;)
</p>
</li>
<li><p>&quot;arrows&quot;: boolean: should edges be arrows
</p>
</li>
<li><p>&quot;arrow_thickness&quot;: numeric: arrows size
</p>
</li>
<li><p>&quot;arrow_start&quot;: character: &quot;row&quot; or &quot;col&quot; or labels value according to row or columns. The arrow will start from selected to the the other value
</p>
</li>
<li><p>&quot;node_color&quot;: named character: Bipartite case c(row = &quot;row_color&quot;, col = &quot;col_color&quot;). Unipartite case c(&quot;node_color&quot;)
</p>
</li>
<li><p>&quot;node_shape&quot;: named character: Bipartite case c(row = &quot;row_shape&quot;, col = &quot;col_shape&quot;). Unipartite case c(&quot;node_shape&quot;). Value from visNetwork shape argument of visEdges function (&quot;triangle&quot;,&quot;dot&quot;,&quot;square&quot;,etc...)
</p>
</li>
<li><p>&quot;digits&quot;: integer: number of digits to show when numbers are shown (default: 2)
</p>
</li></ul>



<h3>Value</h3>

<p>a visNetwork visual of the x object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# my_sbm_bi &lt;- sbm::estimateBipartiteSBM(sbm::fungusTreeNetwork$fungus_tree,
#                                        model = 'bernoulli')
my_sbm_bi &lt;- FungusTreeNetwork$sbmResults$fungus_tree

node_names_bi &lt;- list(
  row = FungusTreeNetwork$networks$fungus_names,
  col = FungusTreeNetwork$networks$tree_names
)

visSbm(my_sbm_bi,
  labels = c(row = "Fungus", col = "Tree"),
  node_names = node_names_bi,
  settings = list(
    arrows = TRUE,
    arrow_start = "Fungus",
    node_color = c(row = "pink", col = "green"),
    node_shape = c(row = "dot", col = "square")
  )
)

</code></pre>

<hr>
<h2 id='visSbm.default'>visSbm</h2><span id='topic+visSbm.default'></span>

<h3>Description</h3>

<p>A fct that plot a visNetwork plot of a adjacency matrix or an Sbm fit from the sbm package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
visSbm(
  x,
  labels = "default",
  node_names = NULL,
  directed = "default",
  settings = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visSbm.default_+3A_x">x</code></td>
<td>
<p>Sbm model of class 'BipartiteSBM_fit', 'SimpleSBM_fit' or simple numeric 'matrix'.</p>
</td></tr>
<tr><td><code id="visSbm.default_+3A_labels">labels</code></td>
<td>
<p>labels for nodes. If it's simple sbm it should be a single character (&quot;default&quot; -&gt; c(&quot;nodes&quot;)).
If sbm is bipartite a named character (names are row and col) (&quot;default&quot; -&gt; c(row = 'row', col = 'col')).</p>
</td></tr>
<tr><td><code id="visSbm.default_+3A_node_names">node_names</code></td>
<td>
<p>if NULL do nothing specific, but list of nodes are given
the graph get interactive and nodes names are showed by clicking on a block.
In bipartite case a named list:
</p>

<ul>
<li><p>&quot;row&quot;: character: node names in rows
</p>
</li>
<li><p>&quot;col&quot;: character: node names in columns
</p>
</li></ul>

<p>In unipartite case a single character vector containing the nodes names (Default = NULL).</p>
</td></tr>
<tr><td><code id="visSbm.default_+3A_directed">directed</code></td>
<td>
<p>Boolean indicating whether or not the network is directed by default, a asymmetrical matrix will be seen as directed.</p>
</td></tr>
<tr><td><code id="visSbm.default_+3A_settings">settings</code></td>
<td>
<p>list of settings</p>
</td></tr>
</table>


<h3>Details</h3>

<p>List of parameters
</p>

<ul>
<li><p>&quot;edge_threshold&quot;: &quot;default&quot; erases as many small edges as it can without isolating any nodes (no connection).
It can also be a numeric value between 0 and 1, relative (between min and max) filter for small edges value
</p>
</li>
<li><p>&quot;edge_color&quot;: character: color of edges (default: &quot;lightblue&quot;)
</p>
</li>
<li><p>&quot;arrows&quot;: boolean: should edges be arrows
</p>
</li>
<li><p>&quot;arrow_thickness&quot;: numeric: arrows size
</p>
</li>
<li><p>&quot;arrow_start&quot;: character: &quot;row&quot; or &quot;col&quot; or labels value according to row or columns. The arrow will start from selected to the the other value
</p>
</li>
<li><p>&quot;node_color&quot;: named character: Bipartite case c(row = &quot;row_color&quot;, col = &quot;col_color&quot;). Unipartite case c(&quot;node_color&quot;)
</p>
</li>
<li><p>&quot;node_shape&quot;: named character: Bipartite case c(row = &quot;row_shape&quot;, col = &quot;col_shape&quot;). Unipartite case c(&quot;node_shape&quot;). Value from visNetwork shape argument of visEdges function (&quot;triangle&quot;,&quot;dot&quot;,&quot;square&quot;,etc...)
</p>
</li>
<li><p>&quot;digits&quot;: integer: number of digits to show when numbers are shown (default: 2)
</p>
</li></ul>



<h3>Value</h3>

<p>a visNetwork visual of the x object
</p>

<hr>
<h2 id='visSbm.SimpleSBM_fit'>visSbm</h2><span id='topic+visSbm.SimpleSBM_fit'></span>

<h3>Description</h3>

<p>A fct that plot a visNetwork plot of a adjacency matrix or an Sbm fit from the sbm package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SimpleSBM_fit'
visSbm(
  x,
  labels = "default",
  node_names = NULL,
  directed = "default",
  settings = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visSbm.SimpleSBM_fit_+3A_x">x</code></td>
<td>
<p>Sbm model of class 'BipartiteSBM_fit', 'SimpleSBM_fit' or simple numeric 'matrix'.</p>
</td></tr>
<tr><td><code id="visSbm.SimpleSBM_fit_+3A_labels">labels</code></td>
<td>
<p>labels for nodes. If it's simple sbm it should be a single character (&quot;default&quot; -&gt; c(&quot;nodes&quot;)).
If sbm is bipartite a named character (names are row and col) (&quot;default&quot; -&gt; c(row = 'row', col = 'col')).</p>
</td></tr>
<tr><td><code id="visSbm.SimpleSBM_fit_+3A_node_names">node_names</code></td>
<td>
<p>if NULL do nothing specific, but list of nodes are given
the graph get interactive and nodes names are showed by clicking on a block.
In bipartite case a named list:
</p>

<ul>
<li><p>&quot;row&quot;: character: node names in rows
</p>
</li>
<li><p>&quot;col&quot;: character: node names in columns
</p>
</li></ul>

<p>In unipartite case a single character vector containing the nodes names (Default = NULL).</p>
</td></tr>
<tr><td><code id="visSbm.SimpleSBM_fit_+3A_directed">directed</code></td>
<td>
<p>Boolean indicating whether or not the network is directed by default, a asymmetrical matrix will be seen as directed.</p>
</td></tr>
<tr><td><code id="visSbm.SimpleSBM_fit_+3A_settings">settings</code></td>
<td>
<p>list of settings</p>
</td></tr>
</table>


<h3>Details</h3>

<p>List of parameters
</p>

<ul>
<li><p>&quot;edge_threshold&quot;: &quot;default&quot; erases as many small edges as it can without isolating any nodes (no connection).
It can also be a numeric value between 0 and 1, relative (between min and max) filter for small edges value
</p>
</li>
<li><p>&quot;edge_color&quot;: character: color of edges (default: &quot;lightblue&quot;)
</p>
</li>
<li><p>&quot;arrows&quot;: boolean: should edges be arrows
</p>
</li>
<li><p>&quot;arrow_thickness&quot;: numeric: arrows size
</p>
</li>
<li><p>&quot;arrow_start&quot;: character: &quot;row&quot; or &quot;col&quot; or labels value according to row or columns. The arrow will start from selected to the the other value
</p>
</li>
<li><p>&quot;node_color&quot;: named character: Bipartite case c(row = &quot;row_color&quot;, col = &quot;col_color&quot;). Unipartite case c(&quot;node_color&quot;)
</p>
</li>
<li><p>&quot;node_shape&quot;: named character: Bipartite case c(row = &quot;row_shape&quot;, col = &quot;col_shape&quot;). Unipartite case c(&quot;node_shape&quot;). Value from visNetwork shape argument of visEdges function (&quot;triangle&quot;,&quot;dot&quot;,&quot;square&quot;,etc...)
</p>
</li>
<li><p>&quot;digits&quot;: integer: number of digits to show when numbers are shown (default: 2)
</p>
</li></ul>



<h3>Value</h3>

<p>a visNetwork visual of the x object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# my_sbm_uni &lt;- sbm::estimateSimpleSBM(sbm::fungusTreeNetwork$tree_tree,
#                                      model = "poisson")
my_sbm_uni &lt;- FungusTreeNetwork$sbmResults$tree_tree

node_names_uni &lt;- list(FungusTreeNetwork$networks$tree_names)

visSbm(my_sbm_uni,
  labels = c("Tree"),
  node_names = node_names_uni,
  settings = list(
    edge_threshold = 0.01,
    edge_color = "grey",
    node_color = c("violet")
  )
)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
