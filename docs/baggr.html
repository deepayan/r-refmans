<!DOCTYPE html><html lang="en-GB"><head><title>Help for package baggr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {baggr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#baggr-package'><p>baggr - a package for Bayesian meta-analysis</p></a></li>
<li><a href='#add_color_to_plot'><p>Add colors to baggr plots</p></a></li>
<li><a href='#baggr'><p>Bayesian aggregate treatment effects model</p></a></li>
<li><a href='#baggr_compare'><p>(Run and) compare multiple baggr models</p></a></li>
<li><a href='#baggr_plot'><p>Plotting method in baggr package</p></a></li>
<li><a href='#baggr_theme_set'><p>Set, get, and replace themes for baggr plots</p></a></li>
<li><a href='#binary_to_individual'><p>Generate individual-level binary outcome data from an aggregate statistics</p></a></li>
<li><a href='#bubble'><p>Bubble plots for meta-regression models</p></a></li>
<li><a href='#chicks'><p>Chickens: impact of electromagnetic field on calcium ion efflux in chicken brains</p></a></li>
<li><a href='#convert_inputs'><p>Convert inputs for baggr models</p></a></li>
<li><a href='#data_spike'><p>Spike &amp; slab example dataset</p></a></li>
<li><a href='#effect_draw'><p>Make predictive draws from baggr model</p></a></li>
<li><a href='#effect_plot'><p>Plot predictive draws from baggr model</p></a></li>
<li><a href='#fixed_effects'><p>Effects of covariates on outcome in baggr models</p></a></li>
<li><a href='#forest_plot'><p>Draw a forest plot for a baggr model</p></a></li>
<li><a href='#get_order'><p>Separate out ordering so we can test directly</p></a></li>
<li><a href='#group_effects'><p>Extract baggr study/group effects</p></a></li>
<li><a href='#is.baggr_cv'><p>Check if something is a baggr_cv object</p></a></li>
<li><a href='#labbe'><p>L'Abbe plot for binary data</p></a></li>
<li><a href='#loo_compare'><p>Compare LOO CV models</p></a></li>
<li><a href='#loocv'><p>Leave one group out cross-validation for <code>baggr</code> models</p></a></li>
<li><a href='#microcredit'><p>7 studies on effect of microcredit supply</p></a></li>
<li><a href='#microcredit_simplified'><p>Simplified version of the microcredit dataset.</p></a></li>
<li><a href='#mint'><p>&quot;Mean and interval&quot; function, including other summaries, calculated for matrix (by column) or vector</p></a></li>
<li><a href='#mutau_cor'><p>Correlation between mu and tau in a baggr model</p></a></li>
<li><a href='#plot_quantiles'><p>plot quantiles</p></a></li>
<li><a href='#plot.baggr'><p>Plotting method for baggr outputs</p></a></li>
<li><a href='#plot.baggr_compare'><p>Plot method for baggr_compare models</p></a></li>
<li><a href='#plot.baggr_cv'><p>Plotting method for results of baggr LOO analyses</p></a></li>
<li><a href='#pooling'><p>Pooling metrics and related statistics for baggr</p></a></li>
<li><a href='#prepare_ma'><p>Convert from individual to summary data in meta-analyses</p></a></li>
<li><a href='#prepare_prior'><p>Prepare prior values for Stan models in baggr</p></a></li>
<li><a href='#print_dist'><p>Output a distribution as a string</p></a></li>
<li><a href='#print.baggr'><p>S3 print method for objects of class <code>baggr</code> (model fits)</p></a></li>
<li><a href='#print.baggr_compare'><p>Print method for baggr_compare models</p></a></li>
<li><a href='#print.baggr_cv'><p>Print baggr cv objects nicely</p></a></li>
<li><a href='#print.compare_baggr_cv'><p>Print baggr_cv comparisons</p></a></li>
<li><a href='#priors'><p>Prior distributions in baggr</p></a></li>
<li><a href='#random_effects'><p>Extract only random effects from a baggr model</p></a></li>
<li><a href='#schools'><p>8 schools example</p></a></li>
<li><a href='#set_prior_val'><p>Add prior values to Stan input for baggr</p></a></li>
<li><a href='#single_comp_plot'><p>Plot single comparison ggplot in <code>baggr_compare</code> style</p></a></li>
<li><a href='#treatment_effect'><p>Average treatment effects in a baggr model</p></a></li>
<li><a href='#yusuf'><p>Yusuf et al: beta-blockers and heart attacks</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Aggregate Treatment Effects</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.8</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Witold Wiecek &lt;witold.wiecek@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Running and comparing meta-analyses of data with hierarchical 
    Bayesian models in Stan, including convenience functions for formatting
    data, plotting and pooling measures specific to meta-analysis. This implements many models
    from Meager (2019) &lt;<a href="https://doi.org/10.1257%2Fapp.20170299">doi:10.1257/app.20170299</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), Rcpp (&ge; 0.12.17)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rstan (&ge; 2.26.0), rstantools (&ge; 2.1.1), bayesplot, crayon,
forestplot, ggplot2, ggplotify, ggrepel, gridExtra, utils,
stats, testthat, methods</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>StanHeaders (&ge; 2.26.0), rstan (&ge; 2.26.0), BH (&ge;
1.66.0-1), Rcpp (&ge; 0.12.17), RcppParallel (&ge; 5.0.1),
RcppEigen (&ge; 0.3.3.4.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, covr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/wwiecek/baggr">https://github.com/wwiecek/baggr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/wwiecek/baggr/issues">https://github.com/wwiecek/baggr/issues</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-12 16:59:36 UTC; waw</td>
</tr>
<tr>
<td>Author:</td>
<td>Witold Wiecek [cre, aut],
  Rachael Meager [aut],
  Brice Green [ctb] (loo_compare, many visuals),
  Danny Toomey [ctb] (many bug fixes),
  Trustees of Columbia University [cph] (package skeleton)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-12 18:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='baggr-package'>baggr - a package for Bayesian meta-analysis</h2><span id='topic+baggr-package'></span>

<h3>Description</h3>

<p>This is <em>baggr</em> (pronounced as <em>bagger</em> or <em>badger</em>), a Bayesian meta-analysis
package for R that uses <a href="https://mc-stan.org/">Stan</a> to fit the models.
<em>Baggr</em> is intended to be user-friendly and transparent so that
it's easier to understand the models you are building and criticise them.
</p>


<h3>Details</h3>

<p><em>Baggr</em> package provides a suite of models that work with both summary data and full data sets,
to synthesise evidence collected from different groups, contexts or time periods.
The <a href="#topic+baggr">baggr</a> command automatically detects the data type and, by default, fits a partial
pooling model (which you may know as
<a href="https://stats.stackexchange.com/questions/4700/what-is-the-difference-between-fixed-effect-random-effect-and-mixed-effect-mode">random effects models</a>)
with weakly informative priors by calling <a href="https://mc-stan.org/">Stan</a> to carry
out Bayesian inference. Modelling of variances or quantiles, standardisation and
transformation of data are also possible.
</p>


<h3>Getting help</h3>

<p>This is only a simple package help file.
For documentation of the main function for conducting analyses see <a href="#topic+baggr">baggr</a>.
For description of models, data types and priors available in the package,
try the built-in vignette (<code>vignette("baggr")</code>).
</p>


<h3>References</h3>

<p>Stan Development Team (2020). RStan: the R interface to Stan. R package version 2.21.2. https://mc-stan.org
</p>

<hr>
<h2 id='add_color_to_plot'>Add colors to baggr plots</h2><span id='topic+add_color_to_plot'></span>

<h3>Description</h3>

<p>Add colors to baggr plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_color_to_plot(p, what)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_color_to_plot_+3A_p">p</code></td>
<td>
<p>A ggplot object to add colors to</p>
</td></tr>
<tr><td><code id="add_color_to_plot_+3A_what">what</code></td>
<td>
<p>A named vector, e.g. <code>c(Hypermean = "red", "Group A" = "green")</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='baggr'>Bayesian aggregate treatment effects model</h2><span id='topic+baggr'></span>

<h3>Description</h3>

<p>Bayesian inference on parameters of an average treatment effects model
that's appropriate to the supplied
individual- or group-level data, using Hamiltonian Monte Carlo in Stan.
(For overall package help file see <a href="#topic+baggr-package">baggr-package</a>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baggr(
  data,
  model = NULL,
  pooling = c("partial", "none", "full"),
  effect_label = NULL,
  covariates = c(),
  prior_hypermean = NULL,
  prior_hypersd = NULL,
  prior_hypercor = NULL,
  prior_beta = NULL,
  prior_control = NULL,
  prior_control_sd = NULL,
  prior_sigma = NULL,
  prior = NULL,
  ppd = FALSE,
  pooling_control = c("none", "partial", "remove"),
  test_data = NULL,
  quantiles = seq(0.05, 0.95, 0.1),
  outcome = "outcome",
  group = "group",
  treatment = "treatment",
  silent = FALSE,
  warn = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="baggr_+3A_data">data</code></td>
<td>
<p>data frame with summary or individual level data to meta-analyse;
see Details section for how to format your data</p>
</td></tr>
<tr><td><code id="baggr_+3A_model">model</code></td>
<td>
<p>if <code>NULL</code>, detected automatically from input data
otherwise choose from
<code>"rubin"</code>, <code>"mutau"</code>, <code>"rubin_full"</code>, <code>"quantiles"</code>
(see Details).</p>
</td></tr>
<tr><td><code id="baggr_+3A_pooling">pooling</code></td>
<td>
<p>Type of pooling;
choose from <code>"none"</code>, <code>"partial"</code> (default) and <code>"full"</code>.
If you are not familiar with the terms, consult the vignette;
&quot;partial&quot; can be understood as random effects and &quot;full&quot; as fixed effects</p>
</td></tr>
<tr><td><code id="baggr_+3A_effect_label">effect_label</code></td>
<td>
<p>How to label the effect(s). These labels are used in various print and plot outputs.
Will default to <code>"mean"</code> in most models, <code>"log OR"</code> in logistic model etc.
If you plan on comparing models (see <a href="#topic+baggr_compare">baggr_compare</a>), use the same labels.</p>
</td></tr>
<tr><td><code id="baggr_+3A_covariates">covariates</code></td>
<td>
<p>Character vector with column names in <code>data</code>. The corresponding columns are used as
covariates (fixed effects) in the meta-regression model (in case of aggregate data).
In the case of individual level data the model does not differentiate between group-level
variables (same values of the covariate for all rows related to a given group) and
individual-level covariates.</p>
</td></tr>
<tr><td><code id="baggr_+3A_prior_hypermean">prior_hypermean</code></td>
<td>
<p>prior distribution for hypermean; you can use &quot;plain text&quot; notation like
<code>prior_hypermean=normal(0,100)</code> or <code>uniform(-10, 10)</code>.
See <em>Details:Priors</em> section below for more possible specifications.
If unspecified, the priors will be derived automatically based on data
(and printed out in the console).</p>
</td></tr>
<tr><td><code id="baggr_+3A_prior_hypersd">prior_hypersd</code></td>
<td>
<p>prior for hyper-standard deviation, used
by Rubin and <code>"mutau"</code> models;
same rules apply as for <code style="white-space: pre;">&#8288;_hypermean&#8288;</code>;</p>
</td></tr>
<tr><td><code id="baggr_+3A_prior_hypercor">prior_hypercor</code></td>
<td>
<p>prior for hypercorrelation matrix, used by the <code>"mutau"</code> model</p>
</td></tr>
<tr><td><code id="baggr_+3A_prior_beta">prior_beta</code></td>
<td>
<p>prior for regression coefficients if <code>covariates</code> are specified; will default to
experimental normal(0, 10^2) distribution</p>
</td></tr>
<tr><td><code id="baggr_+3A_prior_control">prior_control</code></td>
<td>
<p>prior for the mean in the control arm (baseline), currently
used in <code>"logit"</code> model only;
if <code>pooling_control = "partial"</code>, the prior is hyperprior
for all baselines, if <code>"none"</code>,
then it is an independent prior for all baselines</p>
</td></tr>
<tr><td><code id="baggr_+3A_prior_control_sd">prior_control_sd</code></td>
<td>
<p>prior for the SD in the control arm (baseline), currently
used in <code>"logit"</code> model only;
this can only be used if <code>pooling_control = "partial"</code></p>
</td></tr>
<tr><td><code id="baggr_+3A_prior_sigma">prior_sigma</code></td>
<td>
<p>prior for error terms in linear regression models (<code>"rubin_full"</code> or <code>"mutau_full"</code>)</p>
</td></tr>
<tr><td><code id="baggr_+3A_prior">prior</code></td>
<td>
<p>alternative way to specify all priors as a named list with <code>hypermean</code>,
<code>hypersd</code>, <code>hypercor</code>, <code>beta</code>, analogous to <code>prior_</code> arguments above,
e.g. <code>prior = list(hypermean = normal(0,10), beta = uniform(-50, 50))</code></p>
</td></tr>
<tr><td><code id="baggr_+3A_ppd">ppd</code></td>
<td>
<p>logical; use prior predictive distribution? (<em>p.p.d.</em>)
If <code>ppd=TRUE</code>, Stan model will sample from the prior distribution(s)
and ignore <code>data</code> in inference. However, <code>data</code> argument might still
be used to infer the correct model (if <code>model=NULL</code>) and to set the
default priors, therefore you must specify it.</p>
</td></tr>
<tr><td><code id="baggr_+3A_pooling_control">pooling_control</code></td>
<td>
<p>Pooling for group-specific control mean terms in models using
individual-level data. Typically we use either <code>"none"</code> or <code>"partial"</code>,
but if you want to remove the group-specific intercept altogether,
set this to <code>"remove"</code>.</p>
</td></tr>
<tr><td><code id="baggr_+3A_test_data">test_data</code></td>
<td>
<p>data for cross-validation; NULL for no validation, otherwise a data frame
with the same columns as <code>data</code> argument. See &quot;Cross-validation&quot; section below.</p>
</td></tr>
<tr><td><code id="baggr_+3A_quantiles">quantiles</code></td>
<td>
<p>if <code>model = "quantiles"</code>, a vector indicating which quantiles of data to use
(with values between 0 and 1)</p>
</td></tr>
<tr><td><code id="baggr_+3A_outcome">outcome</code></td>
<td>
<p>character; column name in (individual-level)
<code>data</code> with outcome variable values</p>
</td></tr>
<tr><td><code id="baggr_+3A_group">group</code></td>
<td>
<p>character; column name in <code>data</code> with grouping factor;
it's necessary for individual-level data, for summarised data
it will be used as labels for groups when displaying results</p>
</td></tr>
<tr><td><code id="baggr_+3A_treatment">treatment</code></td>
<td>
<p>character; column name in (individual-level) <code>data</code> with treatment factor;</p>
</td></tr>
<tr><td><code id="baggr_+3A_silent">silent</code></td>
<td>
<p>Whether to silence messages about prior settings and about other automatic behaviour.</p>
</td></tr>
<tr><td><code id="baggr_+3A_warn">warn</code></td>
<td>
<p>print an additional warning if Rhat exceeds 1.05</p>
</td></tr>
<tr><td><code id="baggr_+3A_...">...</code></td>
<td>
<p>extra options passed to Stan function, e.g. <code>control = list(adapt_delta = 0.99)</code>,
number of iterations etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Below we briefly discuss 1/ data preparation, 2/ choice of model, 3/ choice of priors.
All three are discussed in more depth in the package vignette, <code>vignette("baggr")</code>.
</p>
<p><strong>Data.</strong> For aggregate data models you need a data frame with columns
<code>tau</code> and <code>se</code> (Rubin model) or <code>tau</code>, <code>mu</code>, <code>se.tau</code>, <code>se.mu</code> (&quot;mu &amp; tau&quot; model).
An additional column can be used to provide labels for each group
(by default column <code>group</code> is used if available, but this can be
customised &ndash; see the example below).
For individual level data three columns are needed: outcome, treatment, group. These
are identified by using the <code>outcome</code>, <code>treatment</code> and <code>group</code> arguments.
</p>
<p>Many data preparation steps can be done through a helper function <a href="#topic+prepare_ma">prepare_ma</a>.
It can convert individual to summary-level data, calculate
odds/risk ratios (with/without corrections) in binary data, standardise variables and more.
Using it will automatically format data inputs to work with <code>baggr()</code>.
</p>
<p><strong>Models.</strong> Available models are:
</p>

<ul>
<li><p> for the <strong>continuous variable</strong> means:
<code>"rubin"</code> model for average treatment effect (using summary data), <code>"mutau"</code>
version which takes into account means of control groups (also using summary data),
<code>"rubin_full"</code>,  which is the same model as <code>"rubin"</code> but works with individual-level data
</p>
</li>
<li><p> for <strong>continuous variable quantiles</strong>: '&quot;quantiles&quot;&ldquo; model
(see Meager, 2019 in references)
</p>
</li>
<li><p> for <em>mixture data</em>: <code>"sslab"</code> (experimental)
</p>
</li>
<li><p> for <strong>binary data</strong>: <code>"logit"</code> model can be used on individual-level data;
you can also analyse continuous statistics such as
log odds ratios and logs risk ratios using the models listed above;
see <code>vignette("baggr_binary")</code> for tutorial with examples
</p>
</li></ul>

<p>If no model is specified, the function tries to infer the appropriate
model automatically.
Additionally, the user must specify type of pooling.
The default is always partial pooling.
</p>
<p><strong>Covariates.</strong>
Both aggregate and individual-level data can include extra columns, given by <code>covariates</code> argument
(specified as a character vector of column names) to be used in regression models.
We also refer to impact of these covariates as <em>fixed effects</em>.
</p>
<p>Two types of covariates may be present in your data:
</p>

<ul>
<li><p> In <code>"rubin"</code> and <code>"mutau"</code> models, covariates that <strong>change according to group unit</strong>.
In that case, the model accounting
for the group covariates is a
<a href="https://handbook-5-1.cochrane.org/chapter_9/9_6_4_meta_regression.htm">meta-regression</a>
model. It can be modelled on summary-level data.
</p>
</li>
<li><p> In <code>"logit"</code> and <code>"rubin_full"</code> models, covariates that <strong>change according to individual unit</strong>.
Then, such a model is commonly referred to as a
<a href="https://stats.stackexchange.com/questions/4700/what-is-the-difference-between-fixed-effect-random-effect-and-mixed-effect-mode/252888">mixed model</a>
. It has to be fitted to individual-level data. Note that meta-regression is a special
case of a mixed model for individual-level data.
</p>
</li></ul>

<p><strong>Priors.</strong> It is optional to specify priors yourself,
as the package will try propose an appropriate
prior for the input data if you do not pass a <code>prior</code> argument.
To set the priors yourself, use <code>prior_</code> arguments. For specifying many priors at once
(or re-using between models), a single <code>prior = list(...)</code> argument can be used instead.
Meaning of the prior parameters may slightly change from model to model.
Details and examples are given in <code>vignette("baggr")</code>.
Setting <code>ppd=TRUE</code> can be used to obtain prior predictive distributions,
which is useful for understanding the prior assumptions,
especially useful in conjunction with <a href="#topic+effect_plot">effect_plot</a>. You can also <a href="#topic+baggr_compare">baggr_compare</a>
different priors by setting <code>baggr_compare(..., compare="prior")</code>.
</p>
<p><strong>Cross-validation.</strong> When <code>test_data</code> are specified, an extra parameter, the
log predictive density, will be returned by the model.
(The fitted model itself is the same regardless of whether there are <code>test_data</code>.)
To understand this parameter, see documentation of <a href="#topic+loocv">loocv</a>, a function that
can be used to assess out of sample prediction of the model using all available data.
If using individual-level data model, <code>test_data</code> should only include treatment arms
of the groups of interest. (This is because in cross-validation we are not typically
interested in the model's ability to fit heterogeneity in control arms, but
only heterogeneity in treatment arms.)
For using aggregate level data, there is no such restriction.
</p>
<p><strong>Outputs.</strong> By default, some outputs are printed. There is also a
plot method for <em>baggr</em> objects which you can access via <a href="#topic+baggr_plot">baggr_plot</a> (or simply <code>plot()</code>).
Other standard functions for working with <code>baggr</code> object are
</p>

<ul>
<li> <p><a href="#topic+treatment_effect">treatment_effect</a> for distribution of hyperparameters
</p>
</li>
<li> <p><a href="#topic+group_effects">group_effects</a> for distributions of group-specific parameters (alias: <a href="#topic+study_effects">study_effects</a>, we use the two interchangeably)
</p>
</li>
<li> <p><a href="#topic+fixed_effects">fixed_effects</a> for coefficients in (meta-)regression
</p>
</li>
<li> <p><a href="#topic+effect_draw">effect_draw</a> and <a href="#topic+effect_plot">effect_plot</a> for posterior predictive distributions
</p>
</li>
<li> <p><a href="#topic+baggr_compare">baggr_compare</a> for comparing multiple <code>baggr</code> models
</p>
</li>
<li> <p><a href="#topic+loocv">loocv</a> for cross-validation
</p>
</li></ul>



<h3>Value</h3>

<p><code>baggr</code> class structure: a list including Stan model fit
alongside input data, pooling metrics, various model properties.
If test data is used, mean value of -2*lpd is reported as <code>mean_lpd</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df_pooled &lt;- data.frame("tau" = c(1, -1, .5, -.5, .7, -.7, 1.3, -1.3),
                        "se" = rep(1, 8),
                        "state" = datasets::state.name[1:8])
baggr(df_pooled) #baggr automatically detects the input data
# same model, but with correct labels,
# different pooling &amp; passing some options to Stan
baggr(df_pooled, group = "state", pooling = "full", iter = 500)
# model with non-default (and very informative) priors

baggr(df_pooled, prior_hypersd = normal(0, 2))


# "mu &amp; tau" model, using a built-in dataset
# prepare_ma() can summarise individual-level data
ms &lt;- microcredit_simplified
microcredit_summary_data &lt;- prepare_ma(ms, outcome = "consumption")
baggr(microcredit_summary_data, model = "mutau",
      iter = 500, #this is just for illustration -- don't set it this low normally!
      pooling = "partial", prior_hypercor = lkj(1),
      prior_hypersd = normal(0,10),
      prior_hypermean = multinormal(c(0,0),matrix(c(10,3,3,10),2,2)))



</code></pre>

<hr>
<h2 id='baggr_compare'>(Run and) compare multiple baggr models</h2><span id='topic+baggr_compare'></span>

<h3>Description</h3>

<p>Compare multiple <a href="#topic+baggr">baggr</a> models by either
providing multiple already existing models as (named) arguments or
passing parameters necessary to run a <a href="#topic+baggr">baggr</a> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baggr_compare(
  ...,
  what = "pooling",
  compare = c("groups", "hyperpars", "effects"),
  transform = NULL,
  prob = 0.95,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="baggr_compare_+3A_...">...</code></td>
<td>
<p>Either some (at least 1) objects of class <code>baggr</code>
(you should name your objects, see the example below)
or the same arguments you'd pass to <a href="#topic+baggr">baggr</a>.
In the latter case you must specify <code>what</code> to compare.</p>
</td></tr>
<tr><td><code id="baggr_compare_+3A_what">what</code></td>
<td>
<p>One of <code>"pooling"</code> (comparison between no, partial and
full pooling) or <code>"prior"</code> (comparison between prior and
posterior predictive). If pre-existing baggr models are
passed to <code>...</code>, this argument is ignored.</p>
</td></tr>
<tr><td><code id="baggr_compare_+3A_compare">compare</code></td>
<td>
<p>When plotting, choose between comparison of <code>"groups"</code>
(default), <code>"hyperpars"</code> (to omit group-specific estimates)
or (predicted) <code>"effects"</code>.
The <code>"groups"</code> option is not available when <code>what = "prior"</code>.</p>
</td></tr>
<tr><td><code id="baggr_compare_+3A_transform">transform</code></td>
<td>
<p>a function (e.g. exp(), log()) to apply to
the the sample of group (and hyper, if <code>hyper=TRUE</code>)
effects before plotting; when working with
effects that are on log scale,
exponent transform is used automatically,
you can plot on log scale by setting
transform = identity</p>
</td></tr>
<tr><td><code id="baggr_compare_+3A_prob">prob</code></td>
<td>
<p>Width of uncertainty interval (defaults to 95%)</p>
</td></tr>
<tr><td><code id="baggr_compare_+3A_plot">plot</code></td>
<td>
<p>logical; calls <a href="#topic+plot.baggr_compare">plot.baggr_compare</a> when running <code>baggr_compare</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you pass parameters to the function you must specify
what kind of comparison you want, either <code>"pooling"</code>, which
will run fully/partially/un-pooled models and then compare them,
or <code>"prior"</code> which will generate estimates without the data
and compare them to the model with the full data. For more
details see <a href="#topic+baggr">baggr</a>, specifically the <code>ppd</code> argument.
</p>


<h3>Value</h3>

<p>an object of class <code>baggr_compare</code>
</p>


<h3>Author(s)</h3>

<p>Witold Wiecek, Brice Green
</p>


<h3>See Also</h3>

<p><a href="#topic+plot.baggr_compare">plot.baggr_compare</a> and <a href="#topic+print.baggr_compare">print.baggr_compare</a>
for working with results of this function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Most basic comparison between no, partial and full pooling
# (This will run the models)
# run model with just prior and then full data for comparison
# with the same arguments that are passed to baggr
prior_comparison &lt;-
  baggr_compare(schools,
                model = 'rubin',
                #this is just for illustration -- don't set it this low normally!
                iter = 500,
                prior_hypermean = normal(0, 3),
                prior_hypersd = normal(0,2),
                prior_hypercor = lkj(2),
                what = "prior")
# print the aggregated treatment effects
prior_comparison
# plot the comparison of the two distributions
plot(prior_comparison)
# Now compare different types of pooling for the same model
pooling_comparison &lt;-
  baggr_compare(schools,
                model = 'rubin',
                #this is just for illustration -- don't set it this low normally!
                iter = 500,
                prior_hypermean = normal(0, 3),
                prior_hypersd = normal(0,2),
                prior_hypercor = lkj(2),
                what = "pooling",
                # You can automatically plot:
                plot = TRUE)
# Compare existing models (you don't have to, but best to name them):
bg1 &lt;- baggr(schools, pooling = "partial")
bg2 &lt;- baggr(schools, pooling = "full")
baggr_compare("Partial pooling model" = bg1, "Full pooling" = bg2)

#' ...or simply draw from prior predictive dist (note ppd=T)
bg1 &lt;- baggr(schools, ppd=TRUE)
bg2 &lt;- baggr(schools, prior_hypermean = normal(0, 5), ppd=TRUE)
baggr_compare("Prior A, p.p.d."=bg1,
              "Prior B p.p.d."=bg2,
              compare = "effects")

# Compare how posterior predictive effect varies with e.g. choice of prior
bg1 &lt;- baggr(schools, prior_hypersd = uniform(0, 20))
bg2 &lt;- baggr(schools, prior_hypersd = normal(0, 5))
baggr_compare("Uniform prior on SD"=bg1,
                   "Normal prior on SD"=bg2,
                   compare = "effects", plot = TRUE)

# Models don't have to be identical. Compare different subsets of input data:
bg1_small &lt;- baggr(schools[1:6,], pooling = "partial")
baggr_compare("8 schools model" = bg1, "First 6 schools" = bg1_small,
              plot = TRUE)

</code></pre>

<hr>
<h2 id='baggr_plot'>Plotting method in baggr package</h2><span id='topic+baggr_plot'></span>

<h3>Description</h3>

<p>Extracts study effects from the  <code>baggr</code> model and plots them,
possibly next to the hypereffect estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baggr_plot(
  bg,
  hyper = FALSE,
  style = c("intervals", "areas", "forest_plot"),
  transform = NULL,
  prob = 0.5,
  prob_outer = 0.95,
  vline = TRUE,
  order = TRUE,
  values_outer = TRUE,
  values_size = 4,
  values_digits = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="baggr_plot_+3A_bg">bg</code></td>
<td>
<p>object of class <code>baggr</code></p>
</td></tr>
<tr><td><code id="baggr_plot_+3A_hyper">hyper</code></td>
<td>
<p>logical; show hypereffect as the last row of the plot?
alternatively you can pass colour for the hypermean row,
e.g. <code>hyper = "red"</code></p>
</td></tr>
<tr><td><code id="baggr_plot_+3A_style">style</code></td>
<td>
<p><code>"forest_plot"</code> imitates the visual style of forest plots
and also prints means and intervals next to each row;
<code>"intervals"</code> (default) or <code>"areas"</code> use package <code>bayesplot</code> styles</p>
</td></tr>
<tr><td><code id="baggr_plot_+3A_transform">transform</code></td>
<td>
<p>a function (e.g. <code>exp()</code>, <code>log()</code>) to apply to the
values of group (and hyper, if <code>hyper=TRUE</code>) effects
before plotting; when working with effects that are on
log scale, exponent transform is used automatically, you can
plot on log scale by setting <code>transform = identity</code></p>
</td></tr>
<tr><td><code id="baggr_plot_+3A_prob">prob</code></td>
<td>
<p>Probability mass for the inner interval in visualisation</p>
</td></tr>
<tr><td><code id="baggr_plot_+3A_prob_outer">prob_outer</code></td>
<td>
<p>Probability mass for the outer interval in visualisation</p>
</td></tr>
<tr><td><code id="baggr_plot_+3A_vline">vline</code></td>
<td>
<p>logical; show vertical line through 0 in the plot?</p>
</td></tr>
<tr><td><code id="baggr_plot_+3A_order">order</code></td>
<td>
<p>logical; sort groups by magnitude of treatment effect?</p>
</td></tr>
<tr><td><code id="baggr_plot_+3A_values_outer">values_outer</code></td>
<td>
<p>logical; use the interval corresponding to <code>prob_outer</code> when <code>style = "forest_plot"</code>?
if not, the &quot;inner&quot; interval (<code>prob</code>) is used</p>
</td></tr>
<tr><td><code id="baggr_plot_+3A_values_size">values_size</code></td>
<td>
<p>size of the text values in the plot when <code>style = "forest_plot"</code></p>
</td></tr>
<tr><td><code id="baggr_plot_+3A_values_digits">values_digits</code></td>
<td>
<p>number of significant digits to use when <code>style = "forest_plot"</code></p>
</td></tr>
<tr><td><code id="baggr_plot_+3A_...">...</code></td>
<td>
<p>extra arguments to pass to the <code>bayesplot</code> functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object
</p>


<h3>Author(s)</h3>

<p>Witold Wiecek; the visual style is based on <em>bayesplot</em> package
</p>


<h3>See Also</h3>

<p><a href="bayesplot.html#topic+MCMC-intervals">bayesplot::MCMC-intervals</a> for more information about <em>bayesplot</em> functionality;
<a href="#topic+forest_plot">forest_plot</a> for a typical meta-analysis alternative (which you can imitate using <code>style = "forest_plot"</code>);
<a href="#topic+effect_plot">effect_plot</a> for plotting treatment effects for a new group
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- baggr(schools, pooling = "none")
plot(fit, hyper = "red")
plot(fit, style = "areas", order = FALSE)
plot(fit, style = "forest_plot", order = FALSE)

</code></pre>

<hr>
<h2 id='baggr_theme_set'>Set, get, and replace themes for baggr plots</h2><span id='topic+baggr_theme_set'></span><span id='topic+baggr_theme_get'></span><span id='topic+baggr_theme_update'></span><span id='topic+baggr_theme_replace'></span>

<h3>Description</h3>

<p>These functions get, set, and modify the ggplot2 themes
of the baggr plots. <code>baggr_theme_get()</code> returns a ggplot2 theme function for
adding themes to a plot. <code>baggr_theme_set()</code> assigns a new theme
for all plots of baggr objects. <code>baggr_theme_update()</code> edits a specific
theme element for the current theme while holding the theme's
other aspects constant. <code>baggr_theme_replace()</code> is used for
wholesale replacing aspects of a plot's theme (see <code><a href="ggplot2.html#topic+theme_get">ggplot2::theme_get()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baggr_theme_set(new = bayesplot::theme_default())

baggr_theme_get()

baggr_theme_update(...)

baggr_theme_replace(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="baggr_theme_set_+3A_new">new</code></td>
<td>
<p>New theme to use for all baggr plots</p>
</td></tr>
<tr><td><code id="baggr_theme_set_+3A_...">...</code></td>
<td>
<p>A named list of theme settings</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the hood, many of the visualizations rely on the
bayesplot package, and thus these leverage the <code><a href="bayesplot.html#topic+bayesplot_theme_get">bayesplot::bayesplot_theme_get()</a></code>
functions. By default, these match the bayesplot's package
theme to make it easier to form cohesive graphs across this package
and others. The trickiest of these to use is <code>baggr_theme_replace</code>;
9 times out of 10 you want baggr_theme_update.
</p>


<h3>Value</h3>

<p>The get method returns the current theme, but all of the
others invisibly return the old theme.
</p>


<h3>See Also</h3>

<p><a href="bayesplot.html#topic+bayesplot_theme_get">bayesplot::bayesplot_theme_get</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# make plot look like default ggplots

library(ggplot2)

fit &lt;- baggr(schools)
baggr_theme_set(theme_grey())
baggr_plot(fit)

# use baggr_theme_get to return theme elements for current theme
qplot(mtcars$mpg) + baggr_theme_get()

# update specific aspect of theme you are interested in
baggr_theme_update(text = element_text(family = "mono"))

# undo that silliness
baggr_theme_update(text = element_text(family = "serif"))

# update and replace are similar, but replace overwrites the
# whole element, update just edits the aspect of the element
# that you give it
# this will error:
# baggr_theme_replace(text = element_text(family = "Times"))
# baggr_plot(fit)
# because it deleted everything else to do with text elements

</code></pre>

<hr>
<h2 id='binary_to_individual'>Generate individual-level binary outcome data from an aggregate statistics</h2><span id='topic+binary_to_individual'></span>

<h3>Description</h3>

<p>This is a helper function that is typically used automatically by some of <em>baggr</em> functions,
such as when running <code>model="logit"</code> in <a href="#topic+baggr">baggr</a>, when summary-level data are supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binary_to_individual(
  data,
  group = "group",
  covariates = c(),
  rename_group = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binary_to_individual_+3A_data">data</code></td>
<td>
<p>A data frame with columns <code>a</code>, <code>c</code> and <code>b</code>/<code>n1</code>, <code>d</code>/<code>n2</code>.
(You can also use <code>ai</code>, <code>ci</code>, <code>n1i</code>, <code>n2i</code> instead.)</p>
</td></tr>
<tr><td><code id="binary_to_individual_+3A_group">group</code></td>
<td>
<p>Column name storing group</p>
</td></tr>
<tr><td><code id="binary_to_individual_+3A_covariates">covariates</code></td>
<td>
<p>Column names in <code>data</code> that contain group-level variables
to retain when expanding into individual-level <code>data.frame</code></p>
</td></tr>
<tr><td><code id="binary_to_individual_+3A_rename_group">rename_group</code></td>
<td>
<p>If <code>TRUE</code> (default), this will rename the grouping variable
to <code>"group"</code>, making it easier to work with <a href="#topic+baggr">baggr</a>
</p>
<p>See <code>vignette("baggr_binary")</code> for an example of use and notation details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns <code>group</code>, <code>outcome</code> and <code>treatment</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+prepare_ma">prepare_ma</a> uses this function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df_yusuf &lt;- read.table(text="
  trial        a n1i  c n2i
  Balcon      14  56 15  58
  Clausen     18  66 19  64
  Multicentre 15 100 12  95
  Barber      10  52 12  47
  Norris      21 226 24 228
  Kahler       3  38  6  31
  Ledwich      2  20  3  20
  ", header=TRUE)
bti &lt;- binary_to_individual(df_yusuf, group = "trial")
head(bti)
# to go back to summary-level data
prepare_ma(bti, effect = "logOR")
# the last operation is equivalent to simply doing
prepare_ma(df_yusuf, group="trial", effect="logOR")

</code></pre>

<hr>
<h2 id='bubble'>Bubble plots for meta-regression models</h2><span id='topic+bubble'></span>

<h3>Description</h3>

<p>Bubble plots for meta-regression models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bubble(bg, covariate, fit = TRUE, label = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bubble_+3A_bg">bg</code></td>
<td>
<p>a <code><a href="#topic+baggr">baggr()</a></code> model using summary-level data, with covariates</p>
</td></tr>
<tr><td><code id="bubble_+3A_covariate">covariate</code></td>
<td>
<p>one of the covariates present in the model</p>
</td></tr>
<tr><td><code id="bubble_+3A_fit">fit</code></td>
<td>
<p>logical: show mean model prediction? (slope is mean estimate of <code><a href="#topic+fixed_effects">fixed_effects()</a></code>, intercept is <code><a href="#topic+hypermean">hypermean()</a></code>);
if you have more than two groups and the covariate is a factor, this will be ignored</p>
</td></tr>
<tr><td><code id="bubble_+3A_label">label</code></td>
<td>
<p>logical: label study/group names?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A simple bubble plot in <code>ggplot</code> style.
Dot sizes are proportional to inverse of variance of each study (more precise studies are larger).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+labbe">labbe()</a></code> for an exploratory plot of binary data in similar style
</p>

<hr>
<h2 id='chicks'>Chickens: impact of electromagnetic field on calcium ion efflux in chicken brains</h2><span id='topic+chicks'></span>

<h3>Description</h3>

<p>An experiment conducted by Blackman et al. (1988) and documented in the following
<a href="https://github.com/VMatthijs/Slamming-the-sham">GitHub repository</a> by Vakar
and Gelman. The dataset consists of a large number of experiments (<code>tau</code>, <code>se.tau</code>)
repeated at varying wave frequencies. Sham experiments (<code>mu</code>, <code>se.mu</code>) are also
included, allowing us to compare performance of models with and without
control measurements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chicks
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 38 rows and 7 columns.
</p>


<h3>References</h3>

<p>Blackman, C. F., S. G. Benane, D. J. Elliott, D. E. House, and
M. M. Pollock.
“Influence of Electromagnetic Fields on the Efflux of Calcium Ions from Brain
Tissue in Vitro: A Three-Model Analysis Consistent with the Frequency
Response up to 510 Hz.” Bioelectromagnetics 9, no. 3 (1988): 215–27.
</p>

<hr>
<h2 id='convert_inputs'>Convert inputs for baggr models</h2><span id='topic+convert_inputs'></span>

<h3>Description</h3>

<p>Converts data to a list of inputs suitable for Stan models,
checks integrity of data and suggests the appropriate default model
if needed. Typically all of this is
done automatically by <a href="#topic+baggr">baggr</a>, so <strong>this function is included only for debugging</strong>
or running (custom) models &quot;by hand&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_inputs(
  data,
  model,
  quantiles,
  effect = NULL,
  group = "group",
  outcome = "outcome",
  treatment = "treatment",
  covariates = c(),
  test_data = NULL,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_inputs_+3A_data">data</code></td>
<td>
<p>'data.frame&ldquo; with desired modelling input</p>
</td></tr>
<tr><td><code id="convert_inputs_+3A_model">model</code></td>
<td>
<p>valid model name used by baggr;
see <a href="#topic+baggr">baggr</a> for allowed models
if <code>model = NULL</code>, this function will try to find appropriate model
automatically</p>
</td></tr>
<tr><td><code id="convert_inputs_+3A_quantiles">quantiles</code></td>
<td>
<p>vector of quantiles to use (only applicable if <code>model = "quantiles"</code>)</p>
</td></tr>
<tr><td><code id="convert_inputs_+3A_effect">effect</code></td>
<td>
<p>Only matters for binary data, use <code>logOR</code>, <code>logRR</code>, or <code>RD</code>. Otherwise ignore.
See <a href="#topic+prepare_ma">prepare_ma</a> for details.</p>
</td></tr>
<tr><td><code id="convert_inputs_+3A_group">group</code></td>
<td>
<p>name of the column with grouping variable</p>
</td></tr>
<tr><td><code id="convert_inputs_+3A_outcome">outcome</code></td>
<td>
<p>name of column with outcome variable (designated as string)</p>
</td></tr>
<tr><td><code id="convert_inputs_+3A_treatment">treatment</code></td>
<td>
<p>name of column with treatment variable</p>
</td></tr>
<tr><td><code id="convert_inputs_+3A_covariates">covariates</code></td>
<td>
<p>Character vector with column names in <code>data</code>.
The corresponding columns are used as
covariates (fixed effects) in the meta-regression model.</p>
</td></tr>
<tr><td><code id="convert_inputs_+3A_test_data">test_data</code></td>
<td>
<p>same format as <code>data</code> argument, gets left aside for
testing purposes (see <a href="#topic+baggr">baggr</a>)</p>
</td></tr>
<tr><td><code id="convert_inputs_+3A_silent">silent</code></td>
<td>
<p>Whether to print messages when evaluated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typically this function is only called within <a href="#topic+baggr">baggr</a> and you do
not need to use it yourself. It can be useful to understand inputs
or to run models which you modified yourself.
</p>


<h3>Value</h3>

<p>R structure that's appropriate for use by <a href="#topic+baggr">baggr</a> Stan models;
<code>group_label</code>, <code>model</code>, <code>effect</code> and <code>n_groups</code> are included as attributes
and are necessary for <a href="#topic+baggr">baggr</a> to work correctly
</p>


<h3>Author(s)</h3>

<p>Witold Wiecek
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple meta-analysis example,
# this is the formatted input for Stan models in baggr():
convert_inputs(schools, "rubin")
</code></pre>

<hr>
<h2 id='data_spike'>Spike &amp; slab example dataset</h2><span id='topic+data_spike'></span>

<h3>Description</h3>

<p>Spike &amp; slab example dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_spike
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 1500 rows and 4 columns.
</p>

<hr>
<h2 id='effect_draw'>Make predictive draws from baggr model</h2><span id='topic+effect_draw'></span>

<h3>Description</h3>

<p>The function <code>effect_draw</code> and its alias, <code>posterior_predict</code>, take the sample
of hyperparameters from a <a href="#topic+baggr">baggr</a> model
(typically hypermean and hyper-SD, which you can see using <a href="#topic+treatment_effect">treatment_effect</a>)
and draws values of new realisations of treatment effect, i.e. an additional draw from the &quot;population of studies&quot;.
This can be used for both prior and posterior draws, depending on <a href="#topic+baggr">baggr</a> model.
By default this is done for a single new effect, but for meta-regression models
you can specify values of covariates with the <code>newdata</code> argument, same as in <a href="stats.html#topic+predict">predict</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effect_draw(
  object,
  draws = NULL,
  newdata = NULL,
  transform = NULL,
  summary = FALSE,
  message = TRUE,
  interval = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="effect_draw_+3A_object">object</code></td>
<td>
<p>A <code>baggr</code> class object.</p>
</td></tr>
<tr><td><code id="effect_draw_+3A_draws">draws</code></td>
<td>
<p>How many values to draw? The default is as long as the number of samples
in the <code>baggr</code> object (see <em>Details</em>).</p>
</td></tr>
<tr><td><code id="effect_draw_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame containing new values of covariates
that were used when fitting the <code>baggr</code> model</p>
</td></tr>
<tr><td><code id="effect_draw_+3A_transform">transform</code></td>
<td>
<p>a transformation (an R function) to apply to the result of a draw.</p>
</td></tr>
<tr><td><code id="effect_draw_+3A_summary">summary</code></td>
<td>
<p>logical; if TRUE returns summary statistics rather than samples from the distribution;</p>
</td></tr>
<tr><td><code id="effect_draw_+3A_message">message</code></td>
<td>
<p>logical; use to disable messages prompted by using this function with
no pooling models</p>
</td></tr>
<tr><td><code id="effect_draw_+3A_interval">interval</code></td>
<td>
<p>uncertainty interval width (numeric between 0 and 1), if <code>summary=TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The predictive distribution can be used to &quot;combine&quot; heterogeneity between treatment effects and
uncertainty in the mean treatment effect. This is useful both in understanding impact of
heterogeneity (see Riley et al, 2011, for a simple introduction) and for study design e.g.
as priors in analysis of future data (since the draws can be seen as an expected treatment effect
in a hypothetical study).
</p>
<p>The default number of samples is the same as what is returned by Stan model implemented in <a href="#topic+baggr">baggr</a>,
(depending on such options as <code>iter</code>, <code>chains</code>, <code>thin</code>). If <code>n</code> is larger than what is available
in Stan model, we draw values with replacement. This is not recommended and warning is printed in
these cases.
</p>
<p>Under default settings in <a href="#topic+baggr">baggr</a>, a <em>posterior</em> predictive distribution is obtained. But
<code>effect_draw</code> can also be used for <em>prior</em> predictive distributions when
setting <code>ppd=T</code> in <a href="#topic+baggr">baggr</a>. The two outputs work exactly the same way.
</p>
<p>If the <code>baggr</code> model used by the function is a meta-regression
(i.e. a <code>baggr</code> model with <code>covariates</code>), by specifying
the predicted values can be adjusted for known levels of fixed covariates by
passing <code>newdata</code> (same as in <a href="stats.html#topic+predict">predict</a>). If no adjustment is made, the
returned value should be interpreted as the effect when all covariates are 0.
</p>


<h3>Value</h3>

<p>A vector (with <code>draws</code> values) for models with one treatment effect parameter,
a matrix (<code>draws</code> rows and same number of columns as number of parameters) otherwise.
If <code>newdata</code> are specified, an array is returned instead, where the first dimension
corresponds to rows of <code>newdata</code>.
</p>


<h3>References</h3>

<p>Riley, Richard D., Julian P. T. Higgins, and Jonathan J. Deeks.
&quot;Interpretation of Random Effects Meta-Analyses&quot;.
<em>BMJ 342 (10 February 2011).</em>.
</p>


<h3>See Also</h3>

<p><a href="#topic+treatment_effect">treatment_effect</a> returns samples from hypermean(s) and hyper-SD(s)
which are used by this function
</p>

<hr>
<h2 id='effect_plot'>Plot predictive draws from baggr model</h2><span id='topic+effect_plot'></span>

<h3>Description</h3>

<p>This function plots values from <a href="#topic+effect_draw">effect_draw</a>, the predictive distribution
(under default settings, <em>posterior</em> predictive),
for one or more <code>baggr</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effect_plot(..., transform = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="effect_plot_+3A_...">...</code></td>
<td>
<p>Object(s) of class <a href="#topic+baggr">baggr</a>. If there is more than one,
a comparison will be plotted and  names of objects
will be used as a plot legend (see examples).</p>
</td></tr>
<tr><td><code id="effect_plot_+3A_transform">transform</code></td>
<td>
<p>a transformation to apply to the result, should be an R function;
(this is commonly used when calling <a href="#topic+group_effects">group_effects</a> from other
plotting or printing functions)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under default settings in <a href="#topic+baggr">baggr</a> posterior predictive is obtained. But
<code>effect_plot</code> can also be used for <em>prior</em> predictive distributions when
setting <code>ppd=T</code> in <a href="#topic+baggr">baggr</a>. The two outputs work exactly the same, but
labels will change to indicate this difference.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p><a href="#topic+effect_draw">effect_draw</a> documents the process of drawing values;
<a href="#topic+baggr_compare">baggr_compare</a> can be used as a shortcut for <code>effect_plot</code> with argument
<code>compare = "effects"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# A single effects plot
bg1 &lt;- baggr(schools, prior_hypersd = uniform(0, 20))
effect_plot(bg1)

# Compare how posterior depends on the prior choice
bg2 &lt;- baggr(schools, prior_hypersd = normal(0, 5))
effect_plot("Uniform prior on SD"=bg1,
            "Normal prior on SD"=bg2)

# Compare the priors themselves (ppd=T)
bg1_ppd &lt;- baggr(schools, prior_hypersd = uniform(0, 20), ppd=TRUE)
bg2_ppd &lt;- baggr(schools, prior_hypersd = normal(0, 5), ppd=TRUE)
effect_plot("Uniform prior on SD"=bg1_ppd,
            "Normal prior on SD"=bg2_ppd)

</code></pre>

<hr>
<h2 id='fixed_effects'>Effects of covariates on outcome in baggr models</h2><span id='topic+fixed_effects'></span>

<h3>Description</h3>

<p>Effects of covariates on outcome in baggr models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixed_effects(bg, summary = FALSE, transform = NULL, interval = 0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fixed_effects_+3A_bg">bg</code></td>
<td>
<p>a <a href="#topic+baggr">baggr</a> model</p>
</td></tr>
<tr><td><code id="fixed_effects_+3A_summary">summary</code></td>
<td>
<p>logical; if <code>TRUE</code> returns summary statistic instead of all MCMC samples</p>
</td></tr>
<tr><td><code id="fixed_effects_+3A_transform">transform</code></td>
<td>
<p>a transformation (R function) to apply to the result;
(this is commonly used when calling from other
plotting or printing functions)</p>
</td></tr>
<tr><td><code id="fixed_effects_+3A_interval">interval</code></td>
<td>
<p>uncertainty interval width (numeric between 0 and 1), if <code>summary=TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 2 vectors (corresponding to MCMC samples)
<code>tau</code> (mean effect) and <code>sigma_tau</code> (SD). If <code>summary=TRUE</code>,
both vectors are summarised as mean and lower/upper bounds according to
<code>interval</code>
</p>


<h3>See Also</h3>

<p><a href="#topic+treatment_effect">treatment_effect</a> for overall treatment effect across groups,
<a href="#topic+group_effects">group_effects</a> for effects within each group,
<a href="#topic+effect_draw">effect_draw</a> and <a href="#topic+effect_plot">effect_plot</a> for predicted treatment effect in new group
</p>

<hr>
<h2 id='forest_plot'>Draw a forest plot for a baggr model</h2><span id='topic+forest_plot'></span>

<h3>Description</h3>

<p>The forest plot functionality in <em>baggr</em> is a simple interface for
calling the forestplot function. By default the forest plot
displays raw (unpooled) estimates for groups and the treatment effect
estimate underneath. This behaviour can be modified to display pooled
group estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forest_plot(
  bg,
  show = c("inputs", "posterior", "both", "covariates"),
  print = show,
  prob = 0.95,
  digits = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forest_plot_+3A_bg">bg</code></td>
<td>
<p>a <a href="#topic+baggr">baggr</a> class object</p>
</td></tr>
<tr><td><code id="forest_plot_+3A_show">show</code></td>
<td>
<p>if <code>"inputs"</code>, then plotted points and lines
correspond to raw inputs for each group;
if <code>"posterior"</code> &ndash; to posterior distribution;
you can also plot <code>"both"</code> inputs and posteriors;
if <code>"covariates"</code>, then fixed effect coefficients are plotted</p>
</td></tr>
<tr><td><code id="forest_plot_+3A_print">print</code></td>
<td>
<p>which values to print next to the plot: values of <code>"inputs"</code>
or <code>"posterior"</code> means?
(if <code>show="covariates"</code>, it must be <code>"posterior"</code>)</p>
</td></tr>
<tr><td><code id="forest_plot_+3A_prob">prob</code></td>
<td>
<p>width of the intervals (lines) for the plot</p>
</td></tr>
<tr><td><code id="forest_plot_+3A_digits">digits</code></td>
<td>
<p>number of digits to display when printing out mean and SD
in the plot</p>
</td></tr>
<tr><td><code id="forest_plot_+3A_...">...</code></td>
<td>
<p>other arguments passed to forestplot</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>forestplot function and its vignette for examples;
<a href="#topic+effect_plot">effect_plot</a> and <a href="#topic+baggr_plot">baggr_plot</a> for non-forest plots of baggr results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bg &lt;- baggr(schools, iter = 500)
forest_plot(bg)
forest_plot(bg, show = "posterior", print = "inputs", digits = 2)

</code></pre>

<hr>
<h2 id='get_order'>Separate out ordering so we can test directly</h2><span id='topic+get_order'></span>

<h3>Description</h3>

<p>Separate out ordering so we can test directly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_order(df_groups, hyper)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_order_+3A_df_groups">df_groups</code></td>
<td>
<p>data.frame of group effects used in <a href="#topic+plot.baggr_compare">plot.baggr_compare</a></p>
</td></tr>
<tr><td><code id="get_order_+3A_hyper">hyper</code></td>
<td>
<p>show parameter estimate? same as in <a href="#topic+plot.baggr_compare">plot.baggr_compare</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a set of effects measured by models, identifies the
model which has the biggest range of estimates and ranks groups
by those estimates, returning the order
</p>

<hr>
<h2 id='group_effects'>Extract baggr study/group effects</h2><span id='topic+group_effects'></span><span id='topic+study_effects'></span>

<h3>Description</h3>

<p>Given a baggr object, returns the raw MCMC draws of the posterior for
each group's effect or a summary of these draws. (We use &quot;group&quot; and &quot;study&quot; interchangeably.)
If there are no covariates in the model, this effect is a single random variable.
If there are covariates, the group effect is a sum of effect of covariates (fixed effects)
and the study-specific random variable (random effects).
This is an internal function currently used as a helper for plotting and
printing of results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_effects(
  bg,
  summary = FALSE,
  transform = NULL,
  interval = 0.95,
  random_only = FALSE,
  rename_int = FALSE
)

study_effects(
  bg,
  summary = FALSE,
  transform = NULL,
  interval = 0.95,
  random_only = FALSE,
  rename_int = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_effects_+3A_bg">bg</code></td>
<td>
<p>baggr object</p>
</td></tr>
<tr><td><code id="group_effects_+3A_summary">summary</code></td>
<td>
<p>logical; if <code>TRUE</code> returns summary statistics as explained below.</p>
</td></tr>
<tr><td><code id="group_effects_+3A_transform">transform</code></td>
<td>
<p>a transformation to apply to the result, should be an R function;
(this is commonly used when calling <code>group_effects</code> from other
plotting or printing functions)</p>
</td></tr>
<tr><td><code id="group_effects_+3A_interval">interval</code></td>
<td>
<p>uncertainty interval width (numeric between 0 and 1), if summarising</p>
</td></tr>
<tr><td><code id="group_effects_+3A_random_only">random_only</code></td>
<td>
<p>logical; for meta-regression models, should <a href="#topic+fixed_effects">fixed_effects</a> be included in the
returned group effect?</p>
</td></tr>
<tr><td><code id="group_effects_+3A_rename_int">rename_int</code></td>
<td>
<p>logical; if <code>TRUE</code> then rather than returning <code>median</code>, <code>lci</code> and <code>uci</code>
columns they are renamed to e.g. <code style="white-space: pre;">&#8288;50%&#8288;</code>, <code style="white-space: pre;">&#8288;2.5%&#8288;</code>, <code style="white-space: pre;">&#8288;97.5%&#8288;</code>; this only
works if <code>summary=TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>summary = TRUE</code>, the returned object contains, for each study
or group, the following 5 values:
the posterior medians, the lower and upper bounds of the
uncertainty intervals using the central posterior credible interval
of width specified in the argument <code>interval</code>, the posterior mean, and
the posterior standard deviation.
</p>


<h3>Value</h3>

<p>Either an array with MCMC samples (if <code>summary = FALSE</code>)
or a summary of these samples (if <code>summary = TRUE</code>).
For arrays the three dimensions are: N samples, N groups and N effects
(equal to 1 for the basic models).
</p>


<h3>See Also</h3>

<p><a href="#topic+fixed_effects">fixed_effects</a> for effects of covariates on outcome. To extract random effects
when covariates are present, you can use either <a href="#topic+random_effects">random_effects</a> or, equivalently,
<code>group_effects(random_only=TRUE)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit1 &lt;- baggr(schools)
group_effects(fit1, summary = TRUE, interval = 0.5)
</code></pre>

<hr>
<h2 id='is.baggr_cv'>Check if something is a baggr_cv object</h2><span id='topic+is.baggr_cv'></span>

<h3>Description</h3>

<p>Check if something is a baggr_cv object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.baggr_cv(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.baggr_cv_+3A_x">x</code></td>
<td>
<p>object to check</p>
</td></tr>
</table>

<hr>
<h2 id='labbe'>L'Abbe plot for binary data</h2><span id='topic+labbe'></span>

<h3>Description</h3>

<p>This plot shows relationship between proportions of events in control and treatment groups in binary data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labbe(
  data,
  group = "group",
  plot_model = FALSE,
  labels = TRUE,
  shade_se = c("rr", "or", "none")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="labbe_+3A_data">data</code></td>
<td>
<p>a data frame with binary data
(must have columns <code>a</code>, <code>c</code>, <code>b</code>/<code>n1</code>, <code>d</code>/<code>n2</code>)</p>
</td></tr>
<tr><td><code id="labbe_+3A_group">group</code></td>
<td>
<p>a character string specifying group names (e.g. study names), used for labels;</p>
</td></tr>
<tr><td><code id="labbe_+3A_plot_model">plot_model</code></td>
<td>
<p>if <code>TRUE</code>, then odds ratios and risk ratios <a href="#topic+baggr">baggr</a> models are estimated (using default
settings) and their mean estimates of effects are plotted as lines</p>
</td></tr>
<tr><td><code id="labbe_+3A_labels">labels</code></td>
<td>
<p>if <code>TRUE</code>, names from the <code>group</code> column are displayed</p>
</td></tr>
<tr><td><code id="labbe_+3A_shade_se">shade_se</code></td>
<td>
<p>if <code>"none"</code>, nothing is plotted, if <code>"or"</code> or <code>"rr"</code>, a shaded area corresponding to
inverse of effect's (OR or RR) SE is added to each data point; the default is <code>"rr"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object
</p>


<h3>See Also</h3>

<p><code>vignette("baggr_binary")</code> for an illustrative example
</p>

<hr>
<h2 id='loo_compare'>Compare LOO CV models</h2><span id='topic+loo_compare'></span>

<h3>Description</h3>

<p>Given multiple <a href="#topic+loocv">loocv</a> outputs, calculate differences in their expected log
predictive density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loo_compare(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loo_compare_+3A_...">...</code></td>
<td>
<p>A series of <code>baggr_cv</code> objects passed as arguments, with a minimum of 2
arguments required for comparison. <code>baggr_cv</code> objects can be created via the
<a href="#topic+loocv">loocv</a> function. In instances where more than 2 arguments are passed, the
first model will be compared sequentially to all other provided models.
Arguments can be passed with names (see example below).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a series of comparisons in order of the arguments provided as Model 1 - Model N for
N loocv objects provided. Model 1 corresponds to the first object passed and
Model N corresponds to the Nth object passed.
</p>


<h3>See Also</h3>

<p><a href="#topic+loocv">loocv</a> for fitting LOO CV objects and explanation of the procedure;
loo package by Vehtari et al (available on CRAN) for a more comprehensive approach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# 2 models with more/less informative priors -- this will take a while to run
cv_1 &lt;- loocv(schools, model = "rubin", pooling = "partial")
cv_2 &lt;- loocv(schools, model = "rubin", pooling = "partial",
              prior_hypermean = normal(0, 5), prior_hypersd = cauchy(0,2.5))
loo_compare("Default prior"=cv_1,"Alternative prior"=cv_2)

## End(Not run)
</code></pre>

<hr>
<h2 id='loocv'>Leave one group out cross-validation for <code>baggr</code> models</h2><span id='topic+loocv'></span>

<h3>Description</h3>

<p>Performs exact leave-one-group-out cross-validation on a baggr model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loocv(data, return_models = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loocv_+3A_data">data</code></td>
<td>
<p>Input data frame - same as for <a href="#topic+baggr">baggr</a> function.</p>
</td></tr>
<tr><td><code id="loocv_+3A_return_models">return_models</code></td>
<td>
<p>logical; if FALSE, summary statistics will be returned and the
models discarded;
if TRUE, a list of models will be returned alongside summaries</p>
</td></tr>
<tr><td><code id="loocv_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <a href="#topic+baggr">baggr</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values returned by <code>loocv()</code> can be used to understand how excluding
any one group affects the overall result, as well as how well the model
predicts the omitted group. LOO-CV approaches are a good general practice
for comparing Bayesian models, not only in meta-analysis.
</p>
<p>This function automatically runs <em>K</em> baggr models, where <em>K</em> is number of groups (e.g. studies),
leaving out one group at a time. For each run, it calculates
<em>expected log predictive density</em> (ELPD) for that group (see Gelman et al 2013).
(In the logistic model, where the proportion in control group is unknown, each of
the groups is divided into data for controls, which is kept for estimation, and data for
treated units, which is not used for estimation but only for calculating predictive density.
This is akin to fixing the baseline risk and only trying to infer the odds ratio.)
</p>
<p>The main output is the cross-validation
information criterion, or -2 times the ELPD summed over <em>K</em> models.
(We sum the terms as we are working with logarithms.)
This is related to, and often approximated by, the Watanabe-Akaike
Information Criterion. When comparing models, smaller values mean
a better fit. For more information on cross-validation see
<a href="http://www.stat.columbia.edu/~gelman/research/published/waic_understand3.pdf">this overview article</a>
</p>
<p>For running more computation-intensive models, consider setting the
<code>mc.cores</code> option before running loocv, e.g. <code>options(mc.cores = 4)</code>
(by default baggr runs 4 MCMC chains in parallel).
As a default, rstan runs &quot;silently&quot; (<code>refresh=0</code>).
To see sampling progress, please set e.g. <code>loocv(data, refresh = 500)</code>.
</p>


<h3>Value</h3>

<p>log predictive density value, an object of class <code>baggr_cv</code>;
full model, prior values and <em>lpd</em> of each model are also returned.
These can be examined by using <code>attributes()</code> function.
</p>


<h3>Author(s)</h3>

<p>Witold Wiecek
</p>


<h3>References</h3>

<p>Gelman, Andrew, Jessica Hwang, and Aki Vehtari.
'Understanding Predictive Information Criteria for Bayesian Models.'
Statistics and Computing 24, no. 6 (November 2014): 997–1016.
</p>


<h3>See Also</h3>

<p><a href="#topic+loo_compare">loo_compare</a> for comparison of many LOO CV results; you can print and plot
output via <a href="#topic+plot.baggr_cv">plot.baggr_cv</a> and <a href="#topic+print.baggr_cv">print.baggr_cv</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# even simple examples may take a while
cv &lt;- loocv(schools, pooling = "partial")
print(cv)      # returns the lpd value
attributes(cv) # more information is included in the object

## End(Not run)

</code></pre>

<hr>
<h2 id='microcredit'>7 studies on effect of microcredit supply</h2><span id='topic+microcredit'></span>

<h3>Description</h3>

<p>This dataframe contains the data used in Meager (2019) to estimate hierarchical
models on the data from 7 randomized controlled trials of expanding access to microcredit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>microcredit
</code></pre>


<h3>Format</h3>

<p>A data frame with 40267 rows, 7 study identifiers and 7 outcomes
</p>


<h3>Details</h3>

<p>The columns include the group indicator which gives the name of the lead author
on each of the respective studies, the value of the 6 outcome variables of most
interest (consumer durables spending, business expenditures, business profit,
business revenues, temptation goods spending and consumption spending) all of
which are standardised to USD PPP in 2009 dollars per two weeks (these are flow variables),
and finally a treatment assignment status indicator.
</p>
<p>The dataset has not otherwise been cleaned and therefore includes NAs and other
issues common to real-world datasets.
</p>
<p>For more information on how and why these variables were chosen and standardised,
see Meager (2019) or consult the associated code repository which includes the
standardisation scripts:
<a href="https://bitbucket.org/rmeager/aggregate-average-impacts-microcredit/src/master/">link</a>
</p>


<h3>References</h3>

<p>Meager, Rachael (2019) Understanding the average impact of microcredit expansions:
A Bayesian hierarchical analysis of seven randomized experiments.
American Economic Journal: Applied Economics, 11(1), 57-91.
</p>

<hr>
<h2 id='microcredit_simplified'>Simplified version of the microcredit dataset.</h2><span id='topic+microcredit_simplified'></span>

<h3>Description</h3>

<p>This dataframe contains the data used in Meager (2019) to estimate hierarchical
models on the data from 7 randomized controlled trials of expanding access to microcredit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>microcredit_simplified
</code></pre>


<h3>Format</h3>

<p>A data frame with 14224 rows, 7 study identifiers and 1 outcome
</p>


<h3>Details</h3>

<p>The columns include the group indicator which gives the name of the lead author on
each of the respective studies, the value of the household consumption
spending standardised to USD PPP in 2009 dollars per two weeks (these are flow variables),
and finally a treatment assignment status indicator.
</p>
<p>The dataset has not otherwise been cleaned and therefore includes NAs and other
issues common to real data.
</p>
<p>For more information on how and why these variables were chosen and standardised,
see Meager (2019) or consult the associated code repository:
<a href="https://bitbucket.org/rmeager/aggregate-average-impacts-microcredit/src/master/">link</a>
</p>
<p>This dataset includes only complete cases and only the consumption outcome variable.
</p>


<h3>References</h3>

<p>Meager, Rachael (2019) Understanding the average impact of microcredit expansions:
A Bayesian hierarchical analysis of seven randomized experiments. American Economic Journal:
Applied Economics, 11(1), 57-91.
</p>

<hr>
<h2 id='mint'>&quot;Mean and interval&quot; function, including other summaries, calculated for matrix (by column) or vector</h2><span id='topic+mint'></span>

<h3>Description</h3>

<p>This function is just a convenient shorthand for getting typical summary statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mint(y, int = 0.95, digits = NULL, median = FALSE, sd = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mint_+3A_y">y</code></td>
<td>
<p>matrix or a vector; for matrices, <code>mint</code> is done by-column</p>
</td></tr>
<tr><td><code id="mint_+3A_int">int</code></td>
<td>
<p>probability interval (default is 95 percent) to calculate</p>
</td></tr>
<tr><td><code id="mint_+3A_digits">digits</code></td>
<td>
<p>number of significant digits to <a href="base.html#topic+round">round</a> values by.</p>
</td></tr>
<tr><td><code id="mint_+3A_median">median</code></td>
<td>
<p>return median value?</p>
</td></tr>
<tr><td><code id="mint_+3A_sd">sd</code></td>
<td>
<p>return SD?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mint(rnorm(100, 12, 5))

</code></pre>

<hr>
<h2 id='mutau_cor'>Correlation between mu and tau in a baggr model</h2><span id='topic+mutau_cor'></span>

<h3>Description</h3>

<p>Correlation between mu and tau in a baggr model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutau_cor(bg, summary = FALSE, interval = 0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutau_cor_+3A_bg">bg</code></td>
<td>
<p>a <a href="#topic+baggr">baggr</a> model where <code>model = "mutau"</code></p>
</td></tr>
<tr><td><code id="mutau_cor_+3A_summary">summary</code></td>
<td>
<p>logical; if TRUE returns summary statistics as explained below.</p>
</td></tr>
<tr><td><code id="mutau_cor_+3A_interval">interval</code></td>
<td>
<p>uncertainty interval width (numeric between 0 and 1), if summarising</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of values
</p>

<hr>
<h2 id='plot_quantiles'>plot quantiles</h2><span id='topic+plot_quantiles'></span>

<h3>Description</h3>

<p>Plot results for baggr quantile models. Displays results facetted per group.
Results are <code>ggplot2</code> plots and can be modified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_quantiles(fit, ncol, hline = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_quantiles_+3A_fit">fit</code></td>
<td>
<p>an object of class <code>baggr</code></p>
</td></tr>
<tr><td><code id="plot_quantiles_+3A_ncol">ncol</code></td>
<td>
<p>number of columns for the plot; defaults to half of number of groups</p>
</td></tr>
<tr><td><code id="plot_quantiles_+3A_hline">hline</code></td>
<td>
<p>logical; plots a line through 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bg &lt;- baggr(microcredit_simplified, model = "quantiles",
            quantiles = c(0.25, 0.50, 0.75),
            iter = 1000, refresh = 0,
            outcome = "consumption")
#vanilla plot
plot_quantiles(bg)[[1]]
plot_quantiles(bg, hline = TRUE)[[2]] +
  ggplot2::coord_cartesian(ylim = c(-2, 5)) +
  ggplot2::ggtitle("Works like a ggplot2 plot!")

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.baggr'>Plotting method for baggr outputs</h2><span id='topic+plot.baggr'></span>

<h3>Description</h3>

<p>Using generic <code>plot()</code> on <code>baggr</code> output invokes <code><a href="#topic+baggr_plot">baggr_plot</a></code> visual.
See therein for customisation options. Note that plot output is <code>ggplot2</code> object.'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'baggr'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.baggr_+3A_x">x</code></td>
<td>
<p>object of class <code>baggr</code></p>
</td></tr>
<tr><td><code id="plot.baggr_+3A_...">...</code></td>
<td>
<p>optional arguments, see <code>baggr_plot</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object from <code>baggr_plot</code>
</p>


<h3>Author(s)</h3>

<p>Witold Wiecek
</p>

<hr>
<h2 id='plot.baggr_compare'>Plot method for baggr_compare models</h2><span id='topic+plot.baggr_compare'></span>

<h3>Description</h3>

<p>Allows plots that compare multiple baggr models
that were passed for comparison purposes to baggr compare or
run automatically by baggr_compare
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'baggr_compare'
plot(
  x,
  compare = x$compare,
  style = "areas",
  grid_models = FALSE,
  grid_parameters = TRUE,
  prob = x$prob,
  hyper = TRUE,
  transform = NULL,
  order = F,
  vline = FALSE,
  add_values = FALSE,
  values_digits = 2,
  values_size = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.baggr_compare_+3A_x">x</code></td>
<td>
<p>baggr_compare model to plot</p>
</td></tr>
<tr><td><code id="plot.baggr_compare_+3A_compare">compare</code></td>
<td>
<p>When plotting, choose between comparison of <code>"groups"</code>
(default), <code>"hyperpars"</code> (to omit group-specific estimates)
or (predicted) <code>"effects"</code>.
The <code>"groups"</code> option is not available when <code>what = "prior"</code>.</p>
</td></tr>
<tr><td><code id="plot.baggr_compare_+3A_style">style</code></td>
<td>
<p>What kind of plot to display (if <code>grid_models = TRUE</code>),
passed to the <code>style</code> argument in <a href="#topic+baggr_plot">baggr_plot</a>.</p>
</td></tr>
<tr><td><code id="plot.baggr_compare_+3A_grid_models">grid_models</code></td>
<td>
<p>If <code>FALSE</code> (default), generate a single comparison plot;
if <code>TRUE</code>, display each model (using individual <a href="#topic+baggr_plot">baggr_plot</a>'s)
side-by-side.</p>
</td></tr>
<tr><td><code id="plot.baggr_compare_+3A_grid_parameters">grid_parameters</code></td>
<td>
<p>if <code>TRUE</code>, uses <code>ggplot</code>-style facetting when plotting models
with many parameters (especially <code>"quantiles"</code>, <code>"sslab"</code>);
if <code>FALSE</code>, returns separate plot for each parameter</p>
</td></tr>
<tr><td><code id="plot.baggr_compare_+3A_prob">prob</code></td>
<td>
<p>Width of uncertainty interval (defaults to 95%)</p>
</td></tr>
<tr><td><code id="plot.baggr_compare_+3A_hyper">hyper</code></td>
<td>
<p>Whether to plot pooled treatment effect
in addition to group treatment effects when <code>compare = "groups"</code></p>
</td></tr>
<tr><td><code id="plot.baggr_compare_+3A_transform">transform</code></td>
<td>
<p>a function (e.g. exp(), log())
to apply to the values of group (and hyper, if hyper=TRUE)
effects before plotting</p>
</td></tr>
<tr><td><code id="plot.baggr_compare_+3A_order">order</code></td>
<td>
<p>Whether to sort by median treatment effect by group.
If yes, medians from the model with largest range of estimates
are used for sorting.
If not, groups are shown alphabetically.</p>
</td></tr>
<tr><td><code id="plot.baggr_compare_+3A_vline">vline</code></td>
<td>
<p>logical; show vertical line through 0 in the plot?</p>
</td></tr>
<tr><td><code id="plot.baggr_compare_+3A_add_values">add_values</code></td>
<td>
<p>logical; if TRUE, values will be printed next to the plot,
in a style that's similar to what is done for forest plots</p>
</td></tr>
<tr><td><code id="plot.baggr_compare_+3A_values_digits">values_digits</code></td>
<td>
<p>number of significant digits to use when printing values,</p>
</td></tr>
<tr><td><code id="plot.baggr_compare_+3A_values_size">values_size</code></td>
<td>
<p>size of font for the values, if <code>add_values == TRUE</code></p>
</td></tr>
<tr><td><code id="plot.baggr_compare_+3A_...">...</code></td>
<td>
<p>ignored for now, may be used in the future</p>
</td></tr>
</table>

<hr>
<h2 id='plot.baggr_cv'>Plotting method for results of baggr LOO analyses</h2><span id='topic+plot.baggr_cv'></span>

<h3>Description</h3>

<p>Plotting method for results of baggr LOO analyses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'baggr_cv'
plot(x, y, ..., add_values = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.baggr_cv_+3A_x">x</code></td>
<td>
<p>output from <a href="#topic+loocv">loocv</a> that has <code>return_models = TRUE</code></p>
</td></tr>
<tr><td><code id="plot.baggr_cv_+3A_y">y</code></td>
<td>
<p>Unused, ignore</p>
</td></tr>
<tr><td><code id="plot.baggr_cv_+3A_...">...</code></td>
<td>
<p>Unused, ignore</p>
</td></tr>
<tr><td><code id="plot.baggr_cv_+3A_add_values">add_values</code></td>
<td>
<p>logical; if <code>TRUE</code>, values of <em>elpd</em> are printed next to each
study</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ggplot2</code> plot in similar style to <a href="#topic+baggr_compare">baggr_compare</a> default plots
</p>

<hr>
<h2 id='pooling'>Pooling metrics and related statistics for baggr</h2><span id='topic+pooling'></span><span id='topic+heterogeneity'></span><span id='topic+weights.baggr'></span>

<h3>Description</h3>

<p>Compute statistics relating to
<code>pooling</code> in a given <a href="#topic+baggr">baggr</a> meta-analysis model returns statistics, for
either the entire model or individual groups, such as
pooling statistic by Gelman &amp; Pardoe (2006), <em>I-squared</em>, <em>H-squared</em>, or study weights;
<code>heterogeneity</code> is a shorthand for <code>pooling(type = "total")</code>
<code>weights</code> is shorthand for <code>pooling(metric = "weights")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pooling(
  bg,
  metric = c("pooling", "isq", "hsq", "weights"),
  type = c("groups", "total"),
  summary = TRUE
)

heterogeneity(
  bg,
  metric = c("pooling", "isq", "hsq", "weights"),
  summary = TRUE
)

## S3 method for class 'baggr'
weights(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pooling_+3A_bg">bg</code></td>
<td>
<p>a <a href="#topic+baggr">baggr</a> model</p>
</td></tr>
<tr><td><code id="pooling_+3A_metric">metric</code></td>
<td>
<p><code>"pooling"</code> for Gelman &amp; Pardoe statistic <em>P</em>,
<code>"isq"</code> for I-squared statistic (<em>1-P</em>, Higgins &amp; Thompson, 2002)
<code>"hsq"</code> for H squared statistic (<em>1/P</em>, ibid.);
<code>"weights"</code> for study weights;
also see <em>Details</em></p>
</td></tr>
<tr><td><code id="pooling_+3A_type">type</code></td>
<td>
<p>In <code>pooling</code> calculation is done for each of the <code>"groups"</code>
(default) or for <code>"total"</code> hypereffect(s).</p>
</td></tr>
<tr><td><code id="pooling_+3A_summary">summary</code></td>
<td>
<p>logical; if <code>FALSE</code> a whole vector of pooling values is returned,
otherwise only the means and intervals</p>
</td></tr>
<tr><td><code id="pooling_+3A_object">object</code></td>
<td>
<p><a href="#topic+baggr">baggr</a> model for which to calculate group (study) weights</p>
</td></tr>
<tr><td><code id="pooling_+3A_...">...</code></td>
<td>
<p>Unused, please ignore.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pooling statistic (Gelman &amp; Pardoe, 2006) describes the extent to which
group-level estimates of treatment
effect are &quot;pooled&quot; toward average treatment effect in the meta-analysis model.
If <code>pooling = "none"</code> or <code>"full"</code> (which you specify when calling <a href="#topic+baggr">baggr</a>),
then the values are always 0 or 1, respectively.
If <code>pooling = "partial"</code>, the value is somewhere between 0 and 1.
We can distinguish between pooling of individual groups and overall pooling in
the model.
</p>
<p>In many contexts, i.e. medical statistics, it is typical to report <em>1-P</em>, called <code class="reqn">I^2</code>
(see Higgins and Thompson, 2002; sometimes another statistic, <code class="reqn">H^2 = 1 / P</code>,
is used).
Higher values of <em>I-squared</em> indicate higher heterogeneity;
Von Hippel (2015) provides useful details for <em>I-squared</em> calculations (and some
issues related to it, especially in frequentist models).
See Gelman &amp; Pardoe (2006) Section 1.1 for a short explanation of how <code class="reqn">R^2</code>
statistic relates to the pooling metric.
</p>


<h3>Group pooling</h3>

<p>This is the calculation done by <code>pooling()</code> if <code>type = "groups"</code> (default).
In a partial pooling model (see <a href="#topic+baggr">baggr</a> and above), group <em>k</em> (e.g. study) has
standard error of treatment effect estimate, <code class="reqn">se_k</code>.
The treatment effect (across <em>k</em> groups) is variable across groups, with
hyper-SD parameter <code class="reqn">\sigma_(\tau)</code>.
</p>
<p>The quantity of interest is ratio of variation in treatment effects to the
total variation.
By convention, we subtract it from 1, to obtain a <em>pooling metric</em> <em>P</em>.
</p>
<p style="text-align: center;"><code class="reqn">p = 1 - (\sigma_(\tau)^2 / (\sigma_(\tau)^2 + se_k^2))</code>
</p>


<ul>
<li><p> If <code class="reqn">p &lt; 0.5</code>, the variation across studies is higher than variation within studies.
</p>
</li>
<li><p> Values close to 1 indicate nearly full pooling. Variation across studies dominates.
</p>
</li>
<li><p> Values close to 0 indicate no pooling. Variation within studies dominates.
</p>
</li></ul>

<p>Note that, since <code class="reqn">\sigma_{\tau}^2</code> is a Bayesian parameter (rather than a
single fixed value),
<em>P</em> is also a parameter. It is typical for <em>P</em> to have very high dispersion,
as in many cases we
cannot precisely estimate <code class="reqn">\sigma_{\tau}</code>. To obtain samples from the distribution
of <em>P</em> (rather than summarised values), set <code>summary=FALSE</code>.
</p>


<h3>Study weights</h3>

<p>Contributions of each group (e.g. each study) to the mean meta-analysis estimate
can be calculated by calculating for each study <em>w_k</em> the inverse of sum of group-specific
SE squared and between-study variation.
To obtain weights, this vector (across all studies) has to be normalised to 1, i.e.
<em>w_k/sum(w_k)</em> for each <em>k</em>.
</p>
<p>SE is typically treated as a fixed quantity
(and usually reported on the reported point estimate),
but between-study variance is a model parameter,
hence the weights themselves are also random variables.
</p>


<h3>Overall pooling in the model</h3>

<p>Typically researchers want to report a single measure from the model,
relating to heterogeneity across groups.
This is calculated by either <code>pooling(mymodel, type = "total")</code> or simply
<code>heterogeneity(mymodel)</code>
</p>
<p>Formulae for the calculations below are provided in main package vignette and
almost analogous to the group calculation above, but using mean variance across
all studies. In other words, pooling <em>P</em> is simply ratio of the expected within-study
variance term to total variance.
</p>
<p>The typical study variance is calculated following Eqn. (1) and (9)
in Higgins and Thompson (see References). We use this formulation
to make our pooling and I^2 comparable with other meta-analysis implementations,
but users should be aware that this is only one possibility for calculating
that &quot;typical&quot; within-study variance.
</p>
<p>Same as for group-specific estimates, <em>P</em> is a Bayesian parameter and its
dispersion can be high.
</p>


<h3>Value</h3>

<p>Matrix with mean and intervals for chosen pooling metric,
each row corresponding to one meta-analysis group.
</p>


<h3>References</h3>

<p>Gelman, Andrew, and Iain Pardoe.
&quot;Bayesian Measures of Explained Variance and Pooling in Multilevel (Hierarchical) Models.&quot;
<em>Technometrics 48, no. 2 (May 2006): 241-51</em>.
</p>
<p>Higgins, Julian P. T., and Simon G. Thompson.
&quot;Quantifying Heterogeneity in a Meta-Analysis.&quot;
<em>Statistics in Medicine, vol. 21, no. 11, June 2002, pp. 1539-58</em>.
</p>
<p>Hippel, Paul T von. &quot;The Heterogeneity Statistic I2 Can Be Biased in Small Meta-Analyses.&quot;
<em>BMC Medical Research Methodology 15 (April 14, 2015).</em>
</p>

<hr>
<h2 id='prepare_ma'>Convert from individual to summary data in meta-analyses</h2><span id='topic+prepare_ma'></span>

<h3>Description</h3>

<p>Allows for one-way conversion from full to summary data
or for calculation of effects for binary data.
Usually used before calling <a href="#topic+baggr">baggr</a>.
Input must be pre-formatted appropriately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_ma(
  data,
  effect = c("mean", "logOR", "logRR", "RD"),
  rare_event_correction = 0.25,
  correction_type = c("single", "all"),
  log = FALSE,
  cfb = FALSE,
  summarise = TRUE,
  treatment = "treatment",
  baseline = NULL,
  group = "group",
  outcome = "outcome",
  pooling = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepare_ma_+3A_data">data</code></td>
<td>
<p><strong>either</strong> a data.frame of individual-level observations
with columns for outcome (numeric), treatment (values 0 and 1) and
group (numeric, character or factor); <strong>or</strong>, a data frame with binary data
(must have columns <code>a</code>, <code>c</code>, <code>b</code>/<code>n1</code>, <code>d</code>/<code>n2</code>).</p>
</td></tr>
<tr><td><code id="prepare_ma_+3A_effect">effect</code></td>
<td>
<p>what effect to calculate? a <code>mean</code> (and SE) of outcome in groups or
(for binary data) <code>logOR</code> (odds ratio), <code>logRR</code> (risk ratio),
<code>RD</code> (risk difference);</p>
</td></tr>
<tr><td><code id="prepare_ma_+3A_rare_event_correction">rare_event_correction</code></td>
<td>
<p>This correction is used when working with
binary data (effect <code>logOR</code> or <code>logRR</code>)
The value of correction is added to all cells in
either some or all rows (groups), depending on <code>correction_type</code>.
Using corrections may bias results but is the only alternative to
avoid infinite values.</p>
</td></tr>
<tr><td><code id="prepare_ma_+3A_correction_type">correction_type</code></td>
<td>
<p>If <code>"single"</code> then rare event correction is only applied to the
particular rows that have 0 cells, if <code>"all"</code>, then to all studies</p>
</td></tr>
<tr><td><code id="prepare_ma_+3A_log">log</code></td>
<td>
<p>logical; log-transform the outcome variable?</p>
</td></tr>
<tr><td><code id="prepare_ma_+3A_cfb">cfb</code></td>
<td>
<p>logical; calculate change from baseline? If yes, the outcome
variable is taken as a difference between values in <code>outcome</code> and
<code>baseline</code> columns</p>
</td></tr>
<tr><td><code id="prepare_ma_+3A_summarise">summarise</code></td>
<td>
<p>logical; <code>TRUE</code> by default, but you can disable it to obtain
converted (e.g. logged) data with columns renamed</p>
</td></tr>
<tr><td><code id="prepare_ma_+3A_treatment">treatment</code></td>
<td>
<p>name of column with treatment variable</p>
</td></tr>
<tr><td><code id="prepare_ma_+3A_baseline">baseline</code></td>
<td>
<p>name of column with baseline variable</p>
</td></tr>
<tr><td><code id="prepare_ma_+3A_group">group</code></td>
<td>
<p>name of the column with grouping variable</p>
</td></tr>
<tr><td><code id="prepare_ma_+3A_outcome">outcome</code></td>
<td>
<p>name of column with outcome variable</p>
</td></tr>
<tr><td><code id="prepare_ma_+3A_pooling">pooling</code></td>
<td>
<p>Internal use only, please ignore</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conversions done by this function are not typically needed and may happen automatically
when <code>data</code> is given to <a href="#topic+baggr">baggr</a>. However, this function can be used to explicitly
convert from full to reduced (summarised) data without analysing it in any model.
It can be useful for examining your data and generating summary tables.
</p>
<p>If multiple operations are performed, they are taken in this order:
</p>

<ol>
<li><p> conversion to log scale,
</p>
</li>
<li><p> calculating change from baseline,
</p>
</li>
<li><p> summarising data (using appropriate <code>effect</code>)
</p>
</li></ol>



<h3>Value</h3>


<ul>
<li><p> If you <code>summarise</code>: a data.frame with columns for <code>group</code>, <code>tau</code> and <code>se.tau</code>
(for <code>effect = "mean"</code>, also baseline means; for <code>"logRR"</code> or <code>"logOR"</code> also
<code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, which correspond to typical contingency table notation, that is:
<code>a</code> = events in exposed; <code>b</code> = no events in exposed, <code>c</code> = events in unexposed,
<code>d</code> = no events in unexposed).
</p>
</li>
<li><p> If you do not summarise data, individual level data will be returned, but
some columns may be renamed or transformed (see the arguments above).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Witold Wiecek
</p>


<h3>See Also</h3>

<p><a href="#topic+convert_inputs">convert_inputs</a> for how any type of data is (internally) converted into
a list of Stan inputs; vignette <code>baggr_binary</code> for more details about
rare event corrections
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example of working with binary outcomes data
# Make up some individual-level data first:
df_rare &lt;- data.frame(group = paste("Study", LETTERS[1:5]),
                      a = c(0, 2, 1, 3, 1), c = c(2, 2, 3, 3, 5),
                      n1i = c(120, 300, 110, 250, 95),
                      n2i = c(120, 300, 110, 250, 95))
df_rare_ind &lt;- binary_to_individual(df_rare)
# Calculate ORs; default rare event correction will be applied
prepare_ma(df_rare_ind, effect = "logOR")
# Add 0.5 to all rows
prepare_ma(df_rare_ind, effect = "logOR",
           correction_type = "all",
           rare_event_correction = 0.5)
</code></pre>

<hr>
<h2 id='prepare_prior'>Prepare prior values for Stan models in baggr</h2><span id='topic+prepare_prior'></span>

<h3>Description</h3>

<p>This is an internal function called by <a href="#topic+baggr">baggr</a>. You can use it for debugging
or to run modified models.
It extracts and prepares priors passed by the user.
Then, if any necessary priors are missing, it sets them automatically
and notifies user about these automatic choices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_prior(
  prior,
  data,
  stan_data,
  model,
  pooling,
  covariates,
  quantiles = c(),
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepare_prior_+3A_prior">prior</code></td>
<td>
<p><code>prior</code> argument passed from <a href="#topic+baggr">baggr</a> call</p>
</td></tr>
<tr><td><code id="prepare_prior_+3A_data">data</code></td>
<td>
<p><code>data</code> another argument in <a href="#topic+baggr">baggr</a></p>
</td></tr>
<tr><td><code id="prepare_prior_+3A_stan_data">stan_data</code></td>
<td>
<p>list of inputs that will be used by sampler
this is already pre-obtained through <a href="#topic+convert_inputs">convert_inputs</a></p>
</td></tr>
<tr><td><code id="prepare_prior_+3A_model">model</code></td>
<td>
<p>same as in <a href="#topic+baggr">baggr</a></p>
</td></tr>
<tr><td><code id="prepare_prior_+3A_pooling">pooling</code></td>
<td>
<p>same as in <a href="#topic+baggr">baggr</a></p>
</td></tr>
<tr><td><code id="prepare_prior_+3A_covariates">covariates</code></td>
<td>
<p>same as in <a href="#topic+baggr">baggr</a></p>
</td></tr>
<tr><td><code id="prepare_prior_+3A_quantiles">quantiles</code></td>
<td>
<p>same as in <a href="#topic+baggr">baggr</a></p>
</td></tr>
<tr><td><code id="prepare_prior_+3A_silent">silent</code></td>
<td>
<p>same as in <a href="#topic+baggr">baggr</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with prior values that can be appended to <code>stan_data</code>
and passed to a Stan model.
</p>

<hr>
<h2 id='print_dist'>Output a distribution as a string</h2><span id='topic+print_dist'></span>

<h3>Description</h3>

<p>Used for printing nicely formatted outputs when reporting results etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_dist(dist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_dist_+3A_dist">dist</code></td>
<td>
<p>distribution name, one of <a href="#topic+priors">priors</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string like <code>normal(0, 10^2)</code>.
</p>

<hr>
<h2 id='print.baggr'>S3 print method for objects of class <code>baggr</code> (model fits)</h2><span id='topic+print.baggr'></span>

<h3>Description</h3>

<p>This prints a concise summary of the main <a href="#topic+baggr">baggr</a> model features.
More info is included in the summary of the model and its attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'baggr'
print(x, exponent = FALSE, digits = 2, prob = 0.95, group, fixed = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.baggr_+3A_x">x</code></td>
<td>
<p>object of class <code>baggr</code></p>
</td></tr>
<tr><td><code id="print.baggr_+3A_exponent">exponent</code></td>
<td>
<p>if <code>TRUE</code>, results (for means) are converted to exp scale</p>
</td></tr>
<tr><td><code id="print.baggr_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits to print.</p>
</td></tr>
<tr><td><code id="print.baggr_+3A_prob">prob</code></td>
<td>
<p>Width of uncertainty interval (defaults to 95%)</p>
</td></tr>
<tr><td><code id="print.baggr_+3A_group">group</code></td>
<td>
<p>logical; print group effects? If unspecified,
they are printed only if
less than 20 groups are present</p>
</td></tr>
<tr><td><code id="print.baggr_+3A_fixed">fixed</code></td>
<td>
<p>logical: print fixed effects?</p>
</td></tr>
<tr><td><code id="print.baggr_+3A_...">...</code></td>
<td>
<p>currently unused by this package: further arguments passed
to or from other methods (<code>print</code>  requirement)</p>
</td></tr>
</table>

<hr>
<h2 id='print.baggr_compare'>Print method for baggr_compare models</h2><span id='topic+print.baggr_compare'></span>

<h3>Description</h3>

<p>Print method for baggr_compare models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'baggr_compare'
print(x, digits, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.baggr_compare_+3A_x">x</code></td>
<td>
<p>baggr_compare model</p>
</td></tr>
<tr><td><code id="print.baggr_compare_+3A_digits">digits</code></td>
<td>
<p>number of significant digits for effect estimates</p>
</td></tr>
<tr><td><code id="print.baggr_compare_+3A_...">...</code></td>
<td>
<p>other parameters passed to print</p>
</td></tr>
</table>

<hr>
<h2 id='print.baggr_cv'>Print baggr cv objects nicely</h2><span id='topic+print.baggr_cv'></span>

<h3>Description</h3>

<p>Print baggr cv objects nicely
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'baggr_cv'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.baggr_cv_+3A_x">x</code></td>
<td>
<p><code>baggr_cv</code> object obtained from <a href="#topic+loocv">loocv</a> to print</p>
</td></tr>
<tr><td><code id="print.baggr_cv_+3A_digits">digits</code></td>
<td>
<p>number of digits to print</p>
</td></tr>
<tr><td><code id="print.baggr_cv_+3A_...">...</code></td>
<td>
<p>Unused, ignore</p>
</td></tr>
</table>

<hr>
<h2 id='print.compare_baggr_cv'>Print baggr_cv comparisons</h2><span id='topic+print.compare_baggr_cv'></span>

<h3>Description</h3>

<p>Print baggr_cv comparisons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'compare_baggr_cv'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.compare_baggr_cv_+3A_x">x</code></td>
<td>
<p>baggr_cv comparison to print</p>
</td></tr>
<tr><td><code id="print.compare_baggr_cv_+3A_digits">digits</code></td>
<td>
<p>number of digits to print</p>
</td></tr>
<tr><td><code id="print.compare_baggr_cv_+3A_...">...</code></td>
<td>
<p>additional arguments for s3 consistency</p>
</td></tr>
</table>

<hr>
<h2 id='priors'>Prior distributions in baggr</h2><span id='topic+priors'></span><span id='topic+multinormal'></span><span id='topic+lkj'></span><span id='topic+normal'></span><span id='topic+lognormal'></span><span id='topic+student_t'></span><span id='topic+cauchy'></span><span id='topic+uniform'></span>

<h3>Description</h3>

<p>This page provides a list of all available distributions
that can be used to specify priors in <code><a href="#topic+baggr">baggr()</a></code>. These convenience functions
are designed to allow the user to write the priors in the most &quot;natural&quot; way when
implementing them in baggr. Apart from
passing on the arguments, their only other role is to perform a rudimentary check
if the distribution is specified correctly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multinormal(location, Sigma)

lkj(shape, order = NULL)

normal(location, scale)

lognormal(mu, sigma)

student_t(nu, mu, sigma)

cauchy(location, scale)

uniform(lower, upper)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="priors_+3A_location">location</code></td>
<td>
<p>Mean for normal and multivariate normal (in which case <code>location</code> is a vector),
and median for Cauchy distributions</p>
</td></tr>
<tr><td><code id="priors_+3A_sigma">Sigma</code></td>
<td>
<p>Variance-covariance matrix for multivariate normal.</p>
</td></tr>
<tr><td><code id="priors_+3A_shape">shape</code></td>
<td>
<p>Shape parameter for LKJ</p>
</td></tr>
<tr><td><code id="priors_+3A_order">order</code></td>
<td>
<p>Order of LKJ matrix (typically it does not need to be specified,
as it is inferred directly in the model)</p>
</td></tr>
<tr><td><code id="priors_+3A_scale">scale</code></td>
<td>
<p>SD for Normal, scale for Cauchy</p>
</td></tr>
<tr><td><code id="priors_+3A_mu">mu</code></td>
<td>
<p>mean of ln(X) for lognormal or location for Student's generalised T</p>
</td></tr>
<tr><td><code id="priors_+3A_sigma">sigma</code></td>
<td>
<p>SD of ln(X) for lognormal or scale for Student's generalised T</p>
</td></tr>
<tr><td><code id="priors_+3A_nu">nu</code></td>
<td>
<p>degrees of freedom for Student's generalised T</p>
</td></tr>
<tr><td><code id="priors_+3A_lower">lower</code></td>
<td>
<p>Lower bound for Uniform</p>
</td></tr>
<tr><td><code id="priors_+3A_upper">upper</code></td>
<td>
<p>Upper bound for Uniform</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The prior choice in <a href="#topic+baggr">baggr</a> is done via distinct arguments for each type of prior,
e.g. <code>prior_hypermean</code>, or a named list of several passed to <code>prior</code>.
See the examples below.
</p>
<p>Notation for priors is &quot;plain-text&quot;, in that you can write the distributions as
<code>normal(5,10)</code>, <code>uniform(0,100)</code> etc.
</p>
<p>Different parameters admit different priors (see <a href="#topic+baggr">baggr</a> for explanations of
what the different <code>prior_</code> arguments do):
</p>

<ul>
<li> <p><code>prior_hypermean</code>, <code>prior_control</code>, and <code>prior_beta</code>
will take <code>"normal"</code>, <code>"uniform"</code>, <code>"lognormal"</code>, and
<code>"cauchy"</code> input for scalars.
For a vector hypermean (see <code>"mutau"</code> model), it will take any of these
arguments and apply them independently to
each component of the vector, or it can also take a <code>"multinormal"</code> argument
(see the example below).
</p>
</li>
<li> <p><code>prior_hypersd</code>, <code>prior_control_sd</code>, and <code>prior_sigma</code> will take <code>"normal"</code>, <code>"uniform"</code>, and <code>"lognormal"</code>
but negative parts of the distribution are truncated
</p>
</li>
<li> <p><code>prior_hypercor</code> allows <code>"lkj"</code> input (see Lewandowski <em>et al.</em>)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Witold Wiecek, Rachael Meager
</p>


<h3>References</h3>

<p>Lewandowski, Daniel, Dorota Kurowicka, and Harry Joe.
&quot;Generating Random Correlation Matrices Based on Vines and Extended Onion Method.&quot;
<em>Journal of Multivariate Analysis</em> 100, no. 9 (October 1, 2009): 1989-2001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># (these are not the recommended priors -- for syntax illustration only)

# change the priors for 8 schools:
baggr(schools, model = "rubin", pooling = "partial",
      prior_hypermean = normal(5,5),
      prior_hypersd = normal(0,20))


# passing priors as a list
custom_priors &lt;- list(hypercor = lkj(1), hypersd = normal(0,10),
                      hypermean = multinormal(c(0,0),matrix(c(10,3,3,10),2,2)))
microcredit_summary_data &lt;- prepare_ma(microcredit, outcome = "consumption")
baggr(microcredit_summary_data, model = "mutau",
      pooling = "partial", prior = custom_priors)

</code></pre>

<hr>
<h2 id='random_effects'>Extract only random effects from a baggr model</h2><span id='topic+random_effects'></span>

<h3>Description</h3>

<p>This function is a shortcut for <code>group_effects(random_only=TRUE, ...)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_effects(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_effects_+3A_...">...</code></td>
<td>
<p>arguments passed to <a href="#topic+group_effects">group_effects</a></p>
</td></tr>
</table>

<hr>
<h2 id='schools'>8 schools example</h2><span id='topic+schools'></span>

<h3>Description</h3>

<p>A classic example of aggregate level continuous data in Bayesian hierarchical modelling.
This dataframe contains a column of estimated treatment effects of an SAT prep
program implemented in 8 different schools in the US, and a column of estimated standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>schools
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 8 rows and 3 columns.
</p>


<h3>Details</h3>

<p>See Gelman et al (1995), Chapter 5, for context and applied example.
</p>


<h3>References</h3>

<p>Gelman, Andrew, John B. Carlin, Hal S. Stern, and Donald B. Rubin.
Bayesian Data Analysis. Taylor &amp; Francis, 1995.
</p>

<hr>
<h2 id='set_prior_val'>Add prior values to Stan input for baggr</h2><span id='topic+set_prior_val'></span>

<h3>Description</h3>

<p>Add prior values to Stan input for baggr
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_prior_val(target, name, prior, p = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_prior_val_+3A_target">target</code></td>
<td>
<p>list object (Stan input) to which prior will be added</p>
</td></tr>
<tr><td><code id="set_prior_val_+3A_name">name</code></td>
<td>
<p>prior name, like <code>hypermean</code>, <code>hypersd</code>, <code>hypercor</code></p>
</td></tr>
<tr><td><code id="set_prior_val_+3A_prior">prior</code></td>
<td>
<p>one of prior distributions allowed by baggr like <a href="#topic+normal">normal</a></p>
</td></tr>
<tr><td><code id="set_prior_val_+3A_p">p</code></td>
<td>
<p>number of repeats of the prior, i.e. when P i.i.d. priors are set for
P dimensional parameter as in &quot;mu &amp; tau&quot; type of model</p>
</td></tr>
</table>

<hr>
<h2 id='single_comp_plot'>Plot single comparison ggplot in <code>baggr_compare</code> style</h2><span id='topic+single_comp_plot'></span>

<h3>Description</h3>

<p>Plot single comparison ggplot in <code>baggr_compare</code> style
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_comp_plot(
  df,
  title = "",
  legend = "top",
  ylab = "",
  grid = F,
  points = FALSE,
  add_values = FALSE,
  values_digits = 1,
  values_size = 4
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="single_comp_plot_+3A_df">df</code></td>
<td>
<p>data.frame with columns <code>group</code>, <code>median</code>, <code>lci</code>, <code>uci</code>,
<code>model</code> (character or factor listing compared models) and,
optionally, <code>parameter</code> (character or factor with name of parameter)</p>
</td></tr>
<tr><td><code id="single_comp_plot_+3A_title">title</code></td>
<td>
<p><code>ggtitle</code> argument passed to ggplot</p>
</td></tr>
<tr><td><code id="single_comp_plot_+3A_legend">legend</code></td>
<td>
<p><code>legend.position</code>  argument passed to ggplot</p>
</td></tr>
<tr><td><code id="single_comp_plot_+3A_ylab">ylab</code></td>
<td>
<p>Y axis label</p>
</td></tr>
<tr><td><code id="single_comp_plot_+3A_grid">grid</code></td>
<td>
<p>logical; if <code>TRUE</code>, facets the plot by values in the <code>parameter</code> column</p>
</td></tr>
<tr><td><code id="single_comp_plot_+3A_points">points</code></td>
<td>
<p>you can optionally specify a (<code>numeric</code>) column that has values of points
to be plotted next to intervals</p>
</td></tr>
<tr><td><code id="single_comp_plot_+3A_add_values">add_values</code></td>
<td>
<p>logical; if <code>TRUE</code>, values will be printed next to the plot,
in a style that's similar to what is done for forest plots</p>
</td></tr>
<tr><td><code id="single_comp_plot_+3A_values_digits">values_digits</code></td>
<td>
<p>number of significant digits to use when printing values,</p>
</td></tr>
<tr><td><code id="single_comp_plot_+3A_values_size">values_size</code></td>
<td>
<p>size of font for the values, if <code>add_values == TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot2</code> object
</p>

<hr>
<h2 id='treatment_effect'>Average treatment effects in a baggr model</h2><span id='topic+treatment_effect'></span><span id='topic+hypermean'></span><span id='topic+hypersd'></span>

<h3>Description</h3>

<p>The most general <code>treatment_effect</code> displays
both hypermean and hyperSD (as a list of length 2),
whereas <code>hypermean</code> and <code>hypersd</code> can be used as shorthands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treatment_effect(
  bg,
  summary = FALSE,
  transform = NULL,
  interval = 0.95,
  message = TRUE
)

hypermean(
  bg,
  transform = NULL,
  interval = 0.95,
  message = FALSE,
  summary = TRUE
)

hypersd(bg, transform = NULL, interval = 0.95, message = FALSE, summary = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treatment_effect_+3A_bg">bg</code></td>
<td>
<p>a <a href="#topic+baggr">baggr</a> model</p>
</td></tr>
<tr><td><code id="treatment_effect_+3A_summary">summary</code></td>
<td>
<p>logical; if TRUE returns summary statistics as explained below.</p>
</td></tr>
<tr><td><code id="treatment_effect_+3A_transform">transform</code></td>
<td>
<p>a transformation to apply to the result, should be an R function;
(this is commonly used when calling <code>treatment_effect</code> from other
plotting or printing functions)</p>
</td></tr>
<tr><td><code id="treatment_effect_+3A_interval">interval</code></td>
<td>
<p>uncertainty interval width (numeric between 0 and 1), if summarising</p>
</td></tr>
<tr><td><code id="treatment_effect_+3A_message">message</code></td>
<td>
<p>logical; use to disable messages prompted by using with
no pooling models</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>treatment_effect()</code>: A list with 2 vectors (corresponding to MCMC samples)
<code>tau</code> (mean effect) and <code>sigma_tau</code> (SD). If <code>summary=TRUE</code>,
both vectors are summarised as mean and lower/upper bounds according to
<code>interval</code>
</p>
</li>
<li> <p><code>hypermean()</code>: The hypermean of a <code>baggr</code> model, shorthand for <code>treatment_effect(x, s=T)[[1]]</code>
</p>
</li>
<li> <p><code>hypersd()</code>: The hyper-SD of a <code>baggr</code> model, shorthand for <code>treatment_effect(x, s=T)[[2]]</code>
</p>
</li></ul>

<hr>
<h2 id='yusuf'>Yusuf et al: beta-blockers and heart attacks</h2><span id='topic+yusuf'></span>

<h3>Description</h3>

<p>This replicates Table 6 from the famous Yusuf et al. (1985), removing one trial (Snow)
that had NA observations only. The paper is notable for application of rare-event
corrections, which we discuss more in package vignette <code>baggr_binary</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yusuf
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 21 rows and 5 columns.
</p>


<h3>References</h3>

<p>Yusuf, S., Peto, R., Lewis, J., Collins, R., &amp; Sleight, P. (1985).
Beta blockade during and after myocardial infarction:
An overview of the randomized trials.
Progress in Cardiovascular Disease, 27(5), 335–371.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
