<!DOCTYPE html><html lang="en"><head><title>Help for package giniCI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {giniCI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#giniCI-package'><p>giniCI: Gini-based Composite Indicators</p></a></li>
<li><a href='#bli'><p>OECD Better Life Index Indicators</p></a></li>
<li><a href='#giniCI'><p>Computing Gini-based Composite Indicators</p></a></li>
<li><a href='#normalize'><p>Indicator Normalization</p></a></li>
<li><a href='#rankComp'><p>Ranking Comparison</p></a></li>
<li><a href='#rankRankPlot'><p>Rank-rank Plot</p></a></li>
<li><a href='#rankScatterPlot'><p>Rank Scatter Plot</p></a></li>
<li><a href='#rankShiftPlot'><p>Rank Shift Plot</p></a></li>
<li><a href='#summary.rankComp'><p>Summarizing Ranking Comparison</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Gini-Based Composite Indicators</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Viet Duong Nguyen &lt;viet-duong.nguyen@outlook.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of Gini-based weighting approaches in constructing composite indicators, providing functionalities for normalization, aggregation, and ranking comparison.  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>DescTools (&ge; 0.99.57), ggplot2 (&ge; 3.5.1), ggrepel (&ge;
0.9.6), ggpubr (&ge; 0.6.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-12 15:48:08 UTC; Duong Nguyen</td>
</tr>
<tr>
<td>Author:</td>
<td>Viet Duong Nguyen <a href="https://orcid.org/0009-0001-0227-3112"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Chiara Gigliarano <a href="https://orcid.org/0000-0003-2861-1316"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Mariateresa Ciommi
    <a href="https://orcid.org/0000-0003-4131-4543"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-13 10:30:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='giniCI-package'>giniCI: Gini-based Composite Indicators</h2><span id='topic+giniCI-package'></span>

<h3>Description</h3>

<p>An implementation of Gini-based weighting approaches in constructing
composite indicators, providing functionalities for normalization,
aggregation, and ranking comparison.
</p>


<h3>Author(s)</h3>

<p>Viet Duong Nguyen (maintainer) &lt;<a href="mailto:viet-duong.nguyen@outlook.it">viet-duong.nguyen@outlook.it</a>&gt; <br />
Chiara Gigliarano <br />
Mariateresa Ciommi
</p>


<h3>References</h3>

<p>Ciommi, M., Gigliarano, C., Emili, A., Taralli, S., and Chelli, F. M. (2017).
A new class of composite indicators for measuring well-being at the local
level: An application to the Equitable and Sustainable Well-being (BES) of
the Italian Provinces. <em>Ecological Indicators</em>, <b>76</b>, 281&ndash;296.
</p>

<hr>
<h2 id='bli'>OECD Better Life Index Indicators</h2><span id='topic+bli'></span>

<h3>Description</h3>

<p>This dataset includes 11 well-being indicators for 36 countries spanning the
years 2014 to 2017. The indicators are derived from the OECD Better Life
Index, which measures 11 topics deemed essential by the OECD for assessing
material living conditions and quality of life.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bli
</code></pre>


<h3>Format</h3>

<p>A data frame with 144 rows and 13 variables:
</p>

<dl>
<dt>COUNTRY</dt><dd><p>Country.</p>
</dd>
<dt>YEAR</dt><dd><p>Year.</p>
</dd>
<dt>HO_HISH</dt><dd><p>Housing expenditure: percentage of housing costs in households gross adjusted disposable income.</p>
</dd>
<dt>IW_HADI</dt><dd><p>Household income: average amount of money that a household earns per year, after taxes.</p>
</dd>
<dt>JE_EMPL</dt><dd><p>Employment rate: percentage of people, aged 15 to 64, currently in a paid job.</p>
</dd>
<dt>SC_SNTWS</dt><dd><p>Quality of support network: percentage of people who believe they can rely on their friends in case of need.</p>
</dd>
<dt>ES_EDUA</dt><dd><p>Educational attainment: percentage of people, aged 25 to 64, having at least an upper-secondary (high school) degree.</p>
</dd>
<dt>CG_VOTO</dt><dd><p>Voter turnout: percentage of registered voters who voted during recent elections.</p>
</dd>
<dt>EQ_AIRP</dt><dd><p>Air pollution: average concentration of particulate matter (PM2.5) in the air.</p>
</dd>
<dt>HS_LEB</dt><dd><p>Life expectancy: average number of years a person can expect to live.</p>
</dd>
<dt>SW_LIFS</dt><dd><p>Life satisfaction: average self-evaluation of life satisfaction, on a scale from 0 to 10.</p>
</dd>
<dt>PS_REPH</dt><dd><p>Homicide rate: average number of reported homicides per 100,000 people.</p>
</dd>
<dt>WL_TNOW</dt><dd><p>Leisure and personal care: average number of hours per day spent on leisure and personal care, including sleeping and eating.</p>
</dd>
</dl>



<h3>Source</h3>

<p>OECD (2024). Better Life Index (Editions 2014, 2015, 2016, and 2017),
<em>OECD Social and Welfare Statistics (database)</em>. Accessed on December 06, 2024.
</p>

<hr>
<h2 id='giniCI'>Computing Gini-based Composite Indicators</h2><span id='topic+giniCI'></span>

<h3>Description</h3>

<p>Compute a composite index with weighting schemes based on the Gini
coefficient of constituent indicators, with options for aggregation methods
and  horizontal variability adjustment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>giniCI(inds, method = c("equal", "gini", "reci"),
       agg = c("ari", "geo"), hv = TRUE, ci.pol = c("pos", "neg"),
       time = NULL, ref.time = NULL, only.ci = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="giniCI_+3A_inds">inds</code></td>
<td>
<p>a matrix or data frame of indicators to be aggregated.</p>
</td></tr>
<tr><td><code id="giniCI_+3A_method">method</code></td>
<td>
<p>weighting method to be used. See <code>'Details'</code>.</p>
</td></tr>
<tr><td><code id="giniCI_+3A_agg">agg</code></td>
<td>
<p>aggregation function to be used, with <code>"ari"</code> denoting the
weighted arithmetic mean and <code>"geo"</code> denoting the weighted geometric mean.</p>
</td></tr>
<tr><td><code id="giniCI_+3A_hv">hv</code></td>
<td>
<p>a logical value indicating whether horizontal variability adjustment
should be applied.</p>
</td></tr>
<tr><td><code id="giniCI_+3A_ci.pol">ci.pol</code></td>
<td>
<p>a character value indicating the polarity of composite index.
Use <code>"pos"</code> if increasing values of the composite index correspond to
positive variations of the phenomenon (e.g., socio-economic developments).
Otherwise, use <code>"neg"</code> if increasing values of the composite index
correspond to to negative variations of the phenomenon (e.g., vulnerability
and poverty).</p>
</td></tr>
<tr><td><code id="giniCI_+3A_time">time</code></td>
<td>
<p>a vector of temporal factors for indicators. The length of <code>time</code>
must equal the number of rows in <code>inds</code>. If <code>NULL</code>, the input indicators
are treated as cross-sectional data.</p>
</td></tr>
<tr><td><code id="giniCI_+3A_ref.time">ref.time</code></td>
<td>
<p>a value denoting the reference time for weighting. If
provided, weights will be derived using only observations at the reference
time.</p>
</td></tr>
<tr><td><code id="giniCI_+3A_only.ci">only.ci</code></td>
<td>
<p>a logical value indicating whether only the composite index
should be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The defaut method is <code>"equal"</code> that produces equal weights <code class="reqn">1/n</code> where
<code class="reqn">n</code> is the number of indicators. For methods <code>"gini"</code> (Gini-based
weighting) and <code>"reci"</code> (reciprocal Gini-based weighting), weights are
defined based on the Gini coefficient of indicators. Let <code class="reqn">G_i</code> be the
Gini coefficient of the <code class="reqn">i</code>-th indicator, the weights by methods
<code>"gini"</code> and <code>"reci"</code> are respectively computed as
<code class="reqn">w^\mathrm{gini}_i = \frac{G_i}{\sum^n_{i = 1} G_i}</code> and
<code class="reqn">w^\mathrm{reci}_i = \frac{1 / G_i}{\sum^n_{i = 1} 1 / G_i}</code>.
</p>
<p>Temporal factors can be applied to methods <code>"gini"</code> and <code>"reci"</code>. If either
<code>time</code> or <code>ref.time</code> is <code>NULL</code>, the weighting process is run on all
observations. If both <code>time</code> and <code>ref.time</code> are not <code>NULL</code>, only observations
at the reference time are used for weight computation.
</p>
<p>When aggregating the indicators, the aggregate score for the <code class="reqn">j</code>-th unit
is computed by applying the chosen aggregation function with the obtained
weights to values in the <code class="reqn">j</code>-th row. If <code>hv = TRUE</code>, horizontal
variability adjustment is executed by introducing a penalty for units with
unbalanced values among dimensions. The penalty for the <code class="reqn">j</code>-th unit is
defined as the the index of dispersion (variance-to-mean ratio) of values in
the <code class="reqn">j</code>-th row. If <code>ci.pol = "pos"</code>, the penalties is subtracted from the
aggregate scores to form the composite index. If <code>ci.pol = "neg"</code> the
penalties is added to the aggregate scores to form the composite index.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>ci</code></td>
<td>
<p>the composite index.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>the weights assigned.</p>
</td></tr>
<tr><td><code>pen</code></td>
<td>
<p>the horizontal variability penalties (if <code>hv = TRUE</code>).</p>
</td></tr>
</table>
<p>If <code>only.ci = TRUE</code>, the function will return only the composite index.
</p>


<h3>Note</h3>

<p>Methods <code>"gini"</code> and <code>"reci"</code> require non-negative indicators for the
calculation of Gini coefficients. In addition, option <code>hv = TRUE</code> cannot be
used if any row contains negative values. Therefore, it may be necessary to
use <code><a href="#topic+normalize">normalize</a></code> to scale the indicators to non-negative ranges before
computing the composite index.
</p>
<p>A Gini coefficient of zero occurs when the indicators are constant or do not
change over the reference time. If a zero Gini coefficient is obtained for
for one or more indicators, method <code>"gini"</code> returns the corresponding weights
as zero while method <code>"reci"</code> cannot be applied.
</p>


<h3>Author(s)</h3>

<p>Viet Duong Nguyen, Chiara Gigliarano, Mariateresa Ciommi
</p>


<h3>References</h3>

<p>Mazziotta, M. and Pareto, A. (2016). On a Generalized Non-compensatory
Composite Index for Measuring Socio-economic Phenomena. <em>Social
Indicators Research</em>, <b>127</b>, 983&ndash;1003.
</p>
<p>Ciommi, M., Gigliarano, C., Emili, A., Taralli, S., and Chelli, F. M. (2017).
A new class of composite indicators for measuring well-being at the local
level: An application to the Equitable and Sustainable Well-being (BES) of
the Italian Provinces. <em>Ecological Indicators</em>, <b>76</b>, 281&ndash;296.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normalize">normalize</a></code>, <code><a href="#topic+rankComp">rankComp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bli)

# Indicator polarity
bli.pol = c("neg", "pos", "pos", "pos", "pos", "neg",
            "pos", "pos", "pos", "neg", "pos")

# Goalpost normalization without using time factors
bli.norm &lt;- normalize(inds = bli[, 3:13], method = "goalpost",
                      ind.pol = bli.pol)

# Goalpost normalization using time factors and a reference time
bli.norm.2014 &lt;- normalize(inds = bli[, 3:13], method = "goalpost",
                           ind.pol = bli.pol, time = bli$YEAR,
                           ref.time = 2014)

# Adjusted Mazziotta-Pareto index
bli.ampi &lt;- giniCI(bli.norm, ci.pol = "pos")
bli.ampi$ci

# Gini-based weighted arithmetic mean with reference time
bli.gini &lt;- giniCI(bli.norm.2014, method = "gini", ci.pol = "pos",
                   time = bli$YEAR, ref.time = 2014)
bli.gini$ci
bli.gini$w

# Reciprocal Gini-based weighted geometric mean with reference time
bli.reci &lt;- giniCI(bli.norm.2014, method = "reci", agg = "geo",
                   ci.pol = "pos", time = bli$YEAR, ref.time = 2014)
bli.reci$ci
bli.reci$w

</code></pre>

<hr>
<h2 id='normalize'>Indicator Normalization</h2><span id='topic+normalize'></span>

<h3>Description</h3>

<p>Perform normalization based on indicators' polarity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize(inds, method = c("min-max", "goalpost"), ind.pol,
          gp.range = c(70, 130), time = NULL, ref.time = NULL,
          ref.value = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalize_+3A_inds">inds</code></td>
<td>
<p>a numeric vector, matrix, or data frame which provides indicators
to be normalized.</p>
</td></tr>
<tr><td><code id="normalize_+3A_method">method</code></td>
<td>
<p>normalization method to be used. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="normalize_+3A_ind.pol">ind.pol</code></td>
<td>
<p>a character vector whose elements can be <code>"pos"</code> (positive) or
<code>"neg"</code> (negative), indicating the polarity of indicators. An indicator's
polarity is the sign of the relation between the indicator and the
phenomenon to be measured.</p>
</td></tr>
<tr><td><code id="normalize_+3A_gp.range">gp.range</code></td>
<td>
<p>a vector of the form <code>c(a,b)</code> giving the normalization range
for method <code>"goalpost"</code>. The default value is <code>c(70,130)</code>.</p>
</td></tr>
<tr><td><code id="normalize_+3A_time">time</code></td>
<td>
<p>a vector of temporal factors for input indicators. The length of
<code>time</code> must equal the number of rows in <code>inds</code>. If <code>NULL</code>, the input data
will be treated as cross-sectional.</p>
</td></tr>
<tr><td><code id="normalize_+3A_ref.time">ref.time</code></td>
<td>
<p>a value denoting the reference time for normalization. See
&lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="normalize_+3A_ref.value">ref.value</code></td>
<td>
<p>a vector containing reference values for indicators to
facilitate the interpretation of results, required by method <code>"goalpost"</code>.
When normalizing each indicator, their reference values will be mapped to
the midpoint of <code>gp.range</code>. See &lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, each indicator <code class="reqn">x</code> is normalized by method <code>"min-max"</code> with
the formulas
</p>
<p style="text-align: center;"><code class="reqn">\displaystyle\tilde{x}^{+}_i = \frac{x_i -
\mathrm{inf}_x}{\mathrm{sup}_x - \mathrm{inf}_x},</code>
</p>

<p>or
</p>
<p style="text-align: center;"><code class="reqn">\displaystyle \tilde{x}^{-}_i = 1 - \tilde{x}^{+}_i,</code>
</p>

<p>where <code class="reqn">\mathrm{sup}_x</code> and <code class="reqn">\mathrm{inf}_x</code> are respectively the
superior and inferior values of the indicator. The former formula is applied
to indicators with positive polarity while the latter one is used for those
with negative polarity.
</p>
<p>If either <code>time</code> or <code>ref.time</code> is <code>NULL</code>, the superior and inferior values
are respectively the maximum and minimum values of <code class="reqn">x</code>. If both <code>time</code>
and <code>ref.time</code> are not <code>NULL</code>, the superior and inferior values are
respectively the maximum and minimum values of <code class="reqn">x</code> observed at the
reference time. In other words, if <code>time</code> is not provided or provided without
specifying a value for <code>ref.time</code>, the input data will be treated as
cross-sectional.
</p>
<p>For method <code>"goalpost"</code>, a vector of reference values for indicators is
required. If not specified by users (<code>ref.value = NULL</code>), these values are
automatically set #' to the indicator means for cross-sectional data or to
the indicator means at the reference time for longitudinal data.
</p>
<p>Method <code>"goalpost"</code> computes two goalposts for normalization as
<code class="reqn">\mathrm{gp\_min}_x = \mathrm{ref}_x - \Delta</code> and
<code class="reqn">\mathrm{gp\_max}_x = \mathrm{ref}_x + \Delta</code>, where
<code class="reqn">\mathrm{ref}_x</code> is the reference value of <code class="reqn">x</code> and
<code class="reqn">\Delta = (\mathrm{sup}_x - \mathrm{inf}_x)/2</code>. Indicators with
positive polarity are rescaled using the formula
</p>
<p style="text-align: center;"><code class="reqn">\displaystyle \tilde{x}^{+}_i =
\frac{x_i - \mathrm{gp\_min}_x}{\mathrm{gp\_max}_x -
\mathrm{gp\_min}_x} (b - a) + a,</code>
</p>

<p>while indicators with negative polarity are rescaled using the formula
</p>
<p style="text-align: center;"><code class="reqn">\displaystyle \tilde{x}^{-}_i = a + b - \tilde{x}^{+}_i.</code>
</p>

<p>If an indicator follows a symmetric probability distribution and its
reference value is set to the mean, the normalized values will theoretically
remain in the range <code class="reqn">[a,b]</code>. In other cases, the normalized values may
extend beyond <code>gp.range</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"data.frame"</code> containing normalized indicators.
</p>


<h3>Author(s)</h3>

<p>Viet Duong Nguyen, Chiara Gigliarano, Mariateresa Ciommi
</p>


<h3>References</h3>

<p>Mazziotta, M. and Pareto, A. (2016). On a Generalized Non-compensatory
Composite Index for Measuring Socio-economic Phenomena. <em>Social
Indicators Research</em>, <b>127</b>, 983&ndash;1003.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+giniCI">giniCI</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data samples
set.seed(1)
df1 &lt;- data.frame(X1 = rnorm(100, 0, 5),
                  X2 = runif(100, 1, 10),
                  X3 = rpois(100, 10))
set.seed(1)
df2 &lt;- data.frame(X1 = rnorm(300, 0, 5),
                  X2 = runif(300, 1, 10),
                  X3 = rpois(300, 10),
                  time = rep(c(2020:2022), rep(100,3)))

# Min-max normalization
df1.mm &lt;- normalize(inds = df1,
                    ind.pol = c("pos", "neg", "pos"))
summary(df1.mm)
df2.mm &lt;- normalize(inds = df2[, 1:3],
                    ind.pol = c("pos", "neg", "pos"),
                    time = df2[, 4], ref.time = 2020)
summary(df2.mm)

# Goalpost normalization
df1.gp &lt;- normalize(inds = df1, method = "goalpost",
                    ind.pol = c("pos", "neg", "pos"))
summary(df1.gp)
df2.gp &lt;- normalize(inds = df2[, 1:3], method = "goalpost",
                    ind.pol = c("pos", "neg", "pos"),
                    time = df2[, 4], ref.time = 2020)
summary(df2.gp)
</code></pre>

<hr>
<h2 id='rankComp'>Ranking Comparison</h2><span id='topic+rankComp'></span>

<h3>Description</h3>

<p>Perform a ranking comparison between two indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rankComp(ref, alt, highest.first = TRUE, id = NULL, time = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rankComp_+3A_ref">ref</code></td>
<td>
<p>a numeric vector of reference index values.</p>
</td></tr>
<tr><td><code id="rankComp_+3A_alt">alt</code></td>
<td>
<p>a numeric vector of alternative index values.</p>
</td></tr>
<tr><td><code id="rankComp_+3A_highest.first">highest.first</code></td>
<td>
<p>a logical value indicating whether the highest value
gets ranking #1. If <code>FALSE</code>, the lowest value gets ranking #1.</p>
</td></tr>
<tr><td><code id="rankComp_+3A_id">id</code></td>
<td>
<p>a vector of unit identifiers.</p>
</td></tr>
<tr><td><code id="rankComp_+3A_time">time</code></td>
<td>
<p>a vector of temporal factors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of classes <code>"rankComp"</code> and <code>"data.frame"</code> containing the following
columns:
</p>
<table role = "presentation">
<tr><td><code>id</code></td>
<td>
<p>the unit identifiers (if provided).</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>the temporal factors (if provided).</p>
</td></tr>
<tr><td><code>ref.rank</code></td>
<td>
<p>the ranking based on the reference index.</p>
</td></tr>
<tr><td><code>alt.rank</code></td>
<td>
<p>the ranking based on the alternative index.</p>
</td></tr>
<tr><td><code>shift</code></td>
<td>
<p>the ranking shifts between two indices.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Viet Duong Nguyen, Chiara Gigliarano, Mariateresa Ciommi
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.rankComp">summary.rankComp</a></code>, <code><a href="#topic+rankScatterPlot">rankScatterPlot</a></code>, <code><a href="#topic+rankShiftPlot">rankShiftPlot</a></code>,
<code><a href="#topic+rankRankPlot">rankRankPlot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bli)

# Goalpost normalization
bli.pol = c("neg", "pos", "pos", "pos", "pos", "neg",
            "pos", "pos", "pos", "neg", "pos")
bli.norm.2014 &lt;- normalize(inds = bli[, 3:13], method = "goalpost",
                           ind.pol = bli.pol, time = bli$YEAR,
                           ref.time = 2014)

# Composite indices
ci.gini &lt;- giniCI(bli.norm.2014, method = "gini",
                  ci.pol = "pos", time = bli$YEAR, ref.time = 2014,
                  only.ci = TRUE)
ci.reci &lt;- giniCI(bli.norm.2014, method = "reci", agg = "geo",
                  ci.pol = "pos", time = bli$YEAR, ref.time = 2014,
                  only.ci = TRUE)

# Ranking comparison
ci.comp &lt;- rankComp(ci.gini, ci.reci, id = bli$COUNTRY, time = bli$YEAR)
print(ci.comp)
summary(ci.comp)
</code></pre>

<hr>
<h2 id='rankRankPlot'>Rank-rank Plot</h2><span id='topic+rankRankPlot'></span>

<h3>Description</h3>

<p>Generate rank-rank plots for ranking comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rankRankPlot(object, id.col = FALSE, p.size = 1.5, p.nudge = 0.05,
             s.width = 0.5,  lab.size = 3.88,
             max.overlaps = 10, max.tick = 50,
             ref.lab = "Reference ranking", alt.lab = "Alternative ranking",
             y.lab = NULL, combine = FALSE, nr = NULL, nc = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rankRankPlot_+3A_object">object</code></td>
<td>
<p>an object of class <code>"rankComp"</code>, usually, an output of a call
to <code><a href="#topic+rankComp">rankComp</a></code>.</p>
</td></tr>
<tr><td><code id="rankRankPlot_+3A_id.col">id.col</code></td>
<td>
<p>a logical value indicating whether the rank-rank segment should
be colored by unit identifiers. It is not recommended if having more than
20 units.</p>
</td></tr>
<tr><td><code id="rankRankPlot_+3A_p.size">p.size</code></td>
<td>
<p>size of segment endpoints.</p>
</td></tr>
<tr><td><code id="rankRankPlot_+3A_p.nudge">p.nudge</code></td>
<td>
<p>horizontal adjustment value to nudge the starting position of
labels.</p>
</td></tr>
<tr><td><code id="rankRankPlot_+3A_s.width">s.width</code></td>
<td>
<p>line width for rank-rank segments.</p>
</td></tr>
<tr><td><code id="rankRankPlot_+3A_lab.size">lab.size</code></td>
<td>
<p>label size value.</p>
</td></tr>
<tr><td><code id="rankRankPlot_+3A_max.overlaps">max.overlaps</code></td>
<td>
<p>a value to exclude the label if it has too many overlaps.
The default value is <code>10</code>. Set <code>max.overlaps = Inf</code> to always show all
labels.</p>
</td></tr>
<tr><td><code id="rankRankPlot_+3A_max.tick">max.tick</code></td>
<td>
<p>a positive integer to control the maximum number of axis
ticks. The default value is <code>50</code>. Set <code>max.tick</code> equal to or greater than
the number of rankings to display all rankings on the axis.</p>
</td></tr>
<tr><td><code id="rankRankPlot_+3A_ref.lab">ref.lab</code></td>
<td>
<p>name of the reference index.</p>
</td></tr>
<tr><td><code id="rankRankPlot_+3A_alt.lab">alt.lab</code></td>
<td>
<p>name of the alternative index.</p>
</td></tr>
<tr><td><code id="rankRankPlot_+3A_y.lab">y.lab</code></td>
<td>
<p>label of the y-axis.</p>
</td></tr>
<tr><td><code id="rankRankPlot_+3A_combine">combine</code></td>
<td>
<p>a logical value indicating whether to generate a grid that
combines plots from different time factors (If <code>object$time</code> is not <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="rankRankPlot_+3A_nr">nr</code></td>
<td>
<p>(optional) number of rows in the plot grid.</p>
</td></tr>
<tr><td><code id="rankRankPlot_+3A_nc">nc</code></td>
<td>
<p>(optional) number of columns in the plot grid.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot comparing two rankings connected by segments. In case <code>object$time</code>
is not <code>NULL</code>, a list of plots for different time factors and the combined
grid (if <code>combine = TRUE</code>) will be returned. The function does not print the
return if it is assigned to an object. Use <code><a href="base.html#topic+print">print</a></code> with the storing object
to generate the plot.
</p>


<h3>Author(s)</h3>

<p>Viet Duong Nguyen, Chiara Gigliarano, Mariateresa Ciommi
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rankComp">rankComp</a></code>, <code><a href="#topic+rankScatterPlot">rankScatterPlot</a></code>, <code><a href="#topic+rankShiftPlot">rankShiftPlot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bli)

# Goalpost normalization
bli.pol = c("neg", "pos", "pos", "pos", "pos", "neg",
            "pos", "pos", "pos", "neg", "pos")
bli.norm.2014 &lt;- normalize(inds = bli[, 3:13], method = "goalpost",
                           ind.pol = bli.pol, time = bli$YEAR,
                           ref.time = 2014)

# Composite indices
ci.gini &lt;- giniCI(bli.norm.2014, method = "gini",
                  ci.pol = "pos", time = bli$YEAR, ref.time = 2014,
                  only.ci = TRUE)
ci.reci &lt;- giniCI(bli.norm.2014, method = "reci", agg = "geo",
                  ci.pol = "pos", time = bli$YEAR, ref.time = 2014,
                  only.ci = TRUE)

# Ranking comparison plots
ci.comp &lt;- rankComp(ci.gini, ci.reci, id = bli$COUNTRY, time = bli$YEAR)
rankScatterPlot(ci.comp)$'2014'
rankShiftPlot(ci.comp)$'2015'
rankRankPlot(ci.comp)$'2016'

# Storing and printing
p.scatter &lt;- rankScatterPlot(ci.comp, combine = TRUE, max.overlaps = 20)
print(p.scatter$'2017') # or: print(p.scatter[[4]])
print(p.scatter$'comb') # or: print(p.scatter[[5]])
</code></pre>

<hr>
<h2 id='rankScatterPlot'>Rank Scatter Plot</h2><span id='topic+rankScatterPlot'></span>

<h3>Description</h3>

<p>Generate rank scatter plots for ranking comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rankScatterPlot(object, p.col = "black", p.size = 1.5, p.shape = 19,
                lab = TRUE, lab.col = "red", lab.size = 3.88,
                ref.line = TRUE, max.overlaps = 10, max.tick = 50,
                ref.lab = "Reference ranking", alt.lab = "Alternative ranking",
                combine = FALSE, nr = NULL, nc = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rankScatterPlot_+3A_object">object</code></td>
<td>
<p>an object of class <code>"rankComp"</code>, usually, an output of a call
to <code><a href="#topic+rankComp">rankComp</a></code>.</p>
</td></tr>
<tr><td><code id="rankScatterPlot_+3A_p.col">p.col</code></td>
<td>
<p>point color code. See &lsquo;Color Specification&rsquo;
in <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="rankScatterPlot_+3A_p.size">p.size</code></td>
<td>
<p>point size value.</p>
</td></tr>
<tr><td><code id="rankScatterPlot_+3A_p.shape">p.shape</code></td>
<td>
<p>point shape value. See &lsquo;pch values&rsquo; in <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="rankScatterPlot_+3A_lab">lab</code></td>
<td>
<p>a logical value indicating whether identifier labels should be
assigned to scatter points. If <code>object$id</code> is <code>NULL</code>, the points
will be labeled by the row index.</p>
</td></tr>
<tr><td><code id="rankScatterPlot_+3A_lab.col">lab.col</code></td>
<td>
<p>color code for labels. See &lsquo;Color Specification&rsquo; in
<code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="rankScatterPlot_+3A_lab.size">lab.size</code></td>
<td>
<p>label size value.</p>
</td></tr>
<tr><td><code id="rankScatterPlot_+3A_ref.line">ref.line</code></td>
<td>
<p>a logical value indicating whether a 45-degree reference line
should be added to the plot.</p>
</td></tr>
<tr><td><code id="rankScatterPlot_+3A_max.overlaps">max.overlaps</code></td>
<td>
<p>a value to exclude the label if it has too many overlaps.
The default value is <code>10</code>. Set <code>max.overlaps = Inf</code> to always show all
labels.</p>
</td></tr>
<tr><td><code id="rankScatterPlot_+3A_max.tick">max.tick</code></td>
<td>
<p>a positive integer to control the maximum number of axis
ticks. The default value is <code>50</code>. Set <code>max.tick</code> equal to or greater than
the number of rankings to display all rankings on the axis.</p>
</td></tr>
<tr><td><code id="rankScatterPlot_+3A_ref.lab">ref.lab</code></td>
<td>
<p>name of the reference index.</p>
</td></tr>
<tr><td><code id="rankScatterPlot_+3A_alt.lab">alt.lab</code></td>
<td>
<p>name of the alternative index.</p>
</td></tr>
<tr><td><code id="rankScatterPlot_+3A_combine">combine</code></td>
<td>
<p>a logical value indicating whether to generate a grid that
combines plots from different time factors (If <code>object$time</code> is not <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="rankScatterPlot_+3A_nr">nr</code></td>
<td>
<p>(optional) number of rows in the plot grid.</p>
</td></tr>
<tr><td><code id="rankScatterPlot_+3A_nc">nc</code></td>
<td>
<p>(optional) number of columns in the plot grid.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scatter plot displaying unit rankings for two indices. In case <code>object$time</code>
is not <code>NULL</code>, a list of plots for different time factors and the combined
grid (if <code>combine = TRUE</code>) will be returned. The function does not print the
return if it is assigned to an object. Use <code><a href="base.html#topic+print">print</a></code> with the storing object
to generate the plot.
</p>


<h3>Author(s)</h3>

<p>Viet Duong Nguyen, Chiara Gigliarano, Mariateresa Ciommi
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rankComp">rankComp</a></code>, <code><a href="#topic+rankShiftPlot">rankShiftPlot</a></code>, <code><a href="#topic+rankRankPlot">rankRankPlot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bli)

# Goalpost normalization
bli.pol = c("neg", "pos", "pos", "pos", "pos", "neg",
            "pos", "pos", "pos", "neg", "pos")
bli.norm.2014 &lt;- normalize(inds = bli[, 3:13], method = "goalpost",
                           ind.pol = bli.pol, time = bli$YEAR,
                           ref.time = 2014)

# Composite indices
ci.gini &lt;- giniCI(bli.norm.2014, method = "gini",
                  ci.pol = "pos", time = bli$YEAR, ref.time = 2014,
                  only.ci = TRUE)
ci.reci &lt;- giniCI(bli.norm.2014, method = "reci", agg = "geo",
                  ci.pol = "pos", time = bli$YEAR, ref.time = 2014,
                  only.ci = TRUE)

# Ranking comparison plots
ci.comp &lt;- rankComp(ci.gini, ci.reci, id = bli$COUNTRY, time = bli$YEAR)
rankScatterPlot(ci.comp)$'2014'
rankShiftPlot(ci.comp)$'2015'
rankRankPlot(ci.comp)$'2016'

# Storing and printing
p.scatter &lt;- rankScatterPlot(ci.comp, combine = TRUE, max.overlaps = 20)
print(p.scatter$'2017') # or: print(p.scatter[[4]])
print(p.scatter$'comb') # or: print(p.scatter[[5]])
</code></pre>

<hr>
<h2 id='rankShiftPlot'>Rank Shift Plot</h2><span id='topic+rankShiftPlot'></span>

<h3>Description</h3>

<p>Generate rank shift plots for ranking comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rankShiftPlot(object, p.cols = c("black", "red"), p.shapes = c(1, 8),
              p.sizes = c(1.5, 1.5), s.col = "black",
              s.type = 1, s.width = 0.5, max.tick = 50,
              ref.lab = "Reference ranking", alt.lab = "Alternative ranking",
              y.lab = "Ranking", combine = FALSE, nr = NULL, nc = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rankShiftPlot_+3A_object">object</code></td>
<td>
<p>an object of class <code>"rankComp"</code>, usually, an output of a call
to <code><a href="#topic+rankComp">rankComp</a></code>.</p>
</td></tr>
<tr><td><code id="rankShiftPlot_+3A_p.cols">p.cols</code></td>
<td>
<p>a vector with two elements denoting the color codes for
reference and alternative positions. See &lsquo;Color Specification&rsquo; in
<code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="rankShiftPlot_+3A_p.shapes">p.shapes</code></td>
<td>
<p>a vector with two elements denoting the shapes for reference
and alternative positions. See &lsquo;pch values&rsquo; in <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="rankShiftPlot_+3A_p.sizes">p.sizes</code></td>
<td>
<p>a vector with two elements denoting the sizes for reference
and alternative positions.</p>
</td></tr>
<tr><td><code id="rankShiftPlot_+3A_s.col">s.col</code></td>
<td>
<p>color code for rank shift segments. See &lsquo;Color
Specification&rsquo; in <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="rankShiftPlot_+3A_s.type">s.type</code></td>
<td>
<p>line type for rank shift segments. See &lsquo;Line Type
Specification&rsquo; in <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="rankShiftPlot_+3A_s.width">s.width</code></td>
<td>
<p>line width for rank shift segments.</p>
</td></tr>
<tr><td><code id="rankShiftPlot_+3A_max.tick">max.tick</code></td>
<td>
<p>a positive integer to control the maximum number of axis
ticks. The default value is <code>50</code>. Set <code>max.tick</code> equal to or greater than
the number of rankings to display all rankings on the axis.</p>
</td></tr>
<tr><td><code id="rankShiftPlot_+3A_ref.lab">ref.lab</code></td>
<td>
<p>name of the reference index.</p>
</td></tr>
<tr><td><code id="rankShiftPlot_+3A_alt.lab">alt.lab</code></td>
<td>
<p>name of the alternative index.</p>
</td></tr>
<tr><td><code id="rankShiftPlot_+3A_y.lab">y.lab</code></td>
<td>
<p>label of the y-axis.</p>
</td></tr>
<tr><td><code id="rankShiftPlot_+3A_combine">combine</code></td>
<td>
<p>a logical value indicating whether to generate a grid that
combines plots from different time factors (If <code>object$time</code> is not <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="rankShiftPlot_+3A_nr">nr</code></td>
<td>
<p>(optional) number of rows in the plot grid.</p>
</td></tr>
<tr><td><code id="rankShiftPlot_+3A_nc">nc</code></td>
<td>
<p>(optional) number of columns in the plot grid.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot displaying shifts in ranking between two indices. In case <code>object$time</code>
is not <code>NULL</code>, a list of plots for different time factors and the combined
grid (if <code>combine = TRUE</code>) will be returned. The function does not print the
return value if it is assigned to an object. Use <code><a href="base.html#topic+print">print</a></code> with the storing
object to produce the plot.
</p>


<h3>Author(s)</h3>

<p>Viet Duong Nguyen, Chiara Gigliarano, Mariateresa Ciommi
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rankComp">rankComp</a></code>, <code><a href="#topic+rankScatterPlot">rankScatterPlot</a></code>, <code><a href="#topic+rankRankPlot">rankRankPlot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bli)

# Goalpost normalization
bli.pol = c("neg", "pos", "pos", "pos", "pos", "neg",
            "pos", "pos", "pos", "neg", "pos")
bli.norm.2014 &lt;- normalize(inds = bli[, 3:13], method = "goalpost",
                           ind.pol = bli.pol, time = bli$YEAR,
                           ref.time = 2014)

# Composite indices
ci.gini &lt;- giniCI(bli.norm.2014, method = "gini",
                  ci.pol = "pos", time = bli$YEAR, ref.time = 2014,
                  only.ci = TRUE)
ci.reci &lt;- giniCI(bli.norm.2014, method = "reci", agg = "geo",
                  ci.pol = "pos", time = bli$YEAR, ref.time = 2014,
                  only.ci = TRUE)

# Ranking comparison plots
ci.comp &lt;- rankComp(ci.gini, ci.reci, id = bli$COUNTRY, time = bli$YEAR)
rankScatterPlot(ci.comp)$'2014'
rankShiftPlot(ci.comp)$'2015'
rankRankPlot(ci.comp)$'2016'

# Storing and printing
p.scatter &lt;- rankScatterPlot(ci.comp, combine = TRUE, max.overlaps = 20)
print(p.scatter$'2017') # or: print(p.scatter[[4]])
print(p.scatter$'comb') # or: print(p.scatter[[5]])
</code></pre>

<hr>
<h2 id='summary.rankComp'>Summarizing Ranking Comparison</h2><span id='topic+summary.rankComp'></span><span id='topic+print.summary.rankComp'></span>

<h3>Description</h3>

<p>Summary method for class <code>"rankComp"</code> and print method for class
<code>"summary.rankComp"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rankComp'
summary(object, n.pick = 10L, n.q = 10L, ...)

## S3 method for class 'summary.rankComp'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.rankComp_+3A_object">object</code></td>
<td>
<p>an object of class <code>"rankComp"</code>, usually, an output of a call
to <code><a href="#topic+rankComp">rankComp</a></code>.</p>
</td></tr>
<tr><td><code id="summary.rankComp_+3A_n.pick">n.pick</code></td>
<td>
<p>a positive integer specifying the number of units considered to
form the top/bottom based on the alternative index. The default value is <code>10</code>.</p>
</td></tr>
<tr><td><code id="summary.rankComp_+3A_n.q">n.q</code></td>
<td>
<p>a positive integer specifying the n-quantiles considered
to compute quantile rankings. The default value is <code>10</code> (deciles).</p>
</td></tr>
<tr><td><code id="summary.rankComp_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.rankComp_+3A_x">x</code></td>
<td>
<p>an object of class <code>"summary.rankComp"</code>, usually, a output of a call
to <code><a href="#topic+summary.rankComp">summary.rankComp</a></code>.</p>
</td></tr>
<tr><td><code id="summary.rankComp_+3A_digits">digits</code></td>
<td>
<p>number of significant digits to use when printing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.rankComp</code> provides details on the ranking comparison between the
reference and the alternative indices stored in the object of class
<code>"rankComp"</code>. <code>print.summary.rankComp</code> prints summary information using a
smart digit format for the components.
</p>


<h3>Value</h3>

<p>An object of class <code>"summary.rankComp"</code> which is a list of components:
</p>
<table role = "presentation">
<tr><td><code>par</code></td>
<td>
<p>a vector storing the values of <code>n.pick</code> and <code>n.q</code>.</p>
</td></tr>
<tr><td><code>n.unit</code></td>
<td>
<p>the number of ranked units (by temporal factors if available).</p>
</td></tr>
<tr><td><code>shift.stats</code></td>
<td>
<p>a data frame with rows presenting the summary statistics
of ranking shifts: minimum, first quartile, median, mean, third quartile,
and maximum.</p>
</td></tr>
<tr><td><code>asr</code></td>
<td>
<p>a data frame giving the average shift in ranking (ASR)
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{ASR} = \frac{1}{m} \sum^m_{i = 1}
  | \mathrm{rank}^{\mathrm{alt}}_i - \mathrm{rank}^{\mathrm{ref}}_i |,</code>
</p>

<p>where <code class="reqn">m</code> is the number of units considered. The rows present the ASR
for all units, and for the top and the bottom units based on the
alternative index ranking.</p>
</td></tr>
<tr><td><code>per</code></td>
<td>
<p>a data frame giving the percentage of equal rankings (PER)
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{PER} = 100 \times \frac{1}{m} \sum^m_{i = 1}
  \{ \mathrm{rank}^{\mathrm{alt}}_i = \mathrm{rank}^{\mathrm{ref}}_i \},</code>
</p>

<p>where <code class="reqn">m</code> is the number of units considered. The rows present the PER
for all units, and for the top and the bottom units based on the
alternative index ranking.</p>
</td></tr>
<tr><td><code>asq</code></td>
<td>
<p>the average shift in quantile ranking (by temporal factors if
available). This value is similar to the ASR for all units, but using the
quantile ranking of two indices.</p>
</td></tr>
</table>
<p>For <code>shift.stats</code>, <code>asr</code>, and <code>per</code>, multiple columns will be generated
according to temporal factors if <code>object$time</code> is not <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Viet Duong Nguyen, Chiara Gigliarano, Mariateresa Ciommi
</p>


<h3>References</h3>

<p>Mariani, F., Ciommi, M., and Recchioni, M. C. (2024). Two in One: A New Tool
to Combine Two Rankings Based on the Voronoi Diagram. <em>Social Indicators
Research</em>, <b>175</b>, 989&ndash;1005.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rankComp">rankComp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bli)

# Goalpost normalization
bli.pol = c("neg", "pos", "pos", "pos", "pos", "neg",
            "pos", "pos", "pos", "neg", "pos")
bli.norm.2014 &lt;- normalize(inds = bli[, 3:13], method = "goalpost",
                           ind.pol = bli.pol, time = bli$YEAR,
                           ref.time = 2014)

# Composite indices
ci.gini &lt;- giniCI(bli.norm.2014, method = "gini",
                  ci.pol = "pos", time = bli$YEAR, ref.time = 2014,
                  only.ci = TRUE)
ci.reci &lt;- giniCI(bli.norm.2014, method = "reci", agg = "geo",
                  ci.pol = "pos", time = bli$YEAR, ref.time = 2014,
                  only.ci = TRUE)

# Ranking comparison
ci.comp &lt;- rankComp(ci.gini, ci.reci, id = bli$COUNTRY, time = bli$YEAR)
print(ci.comp)
summary(ci.comp)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
