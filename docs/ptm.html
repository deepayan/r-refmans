<!DOCTYPE html><html><head><title>Help for package ptm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ptm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.get.exepath'><p>Find Full Paths to Executables</p></a></li>
<li><a href='#.get.url'><p>Get Web Resource</p></a></li>
<li><a href='#aa.at'><p>Residue Found at the Requested Position</p></a></li>
<li><a href='#aa.comp'><p>Amino Acid Composition</p></a></li>
<li><a href='#abundance'><p>Protein Abundance Data</p></a></li>
<li><a href='#ac.scan'><p>Scan a Protein in Search of Acetylation Sites</p></a></li>
<li><a href='#acc.dssp'><p>Compute Residue Accessibility and SASA</p></a></li>
<li><a href='#atom.dpx'><p>Atom Depth Analysis</p></a></li>
<li><a href='#bg.go'><p>Search GO Terms for Background Set</p></a></li>
<li><a href='#ddG.profile'><p>Contribution of a given position to changes in stability</p></a></li>
<li><a href='#ddG.ptm'><p>PDB Model and Change in Stability of a Modified Protein</p></a></li>
<li><a href='#dis.scan'><p>Scan a Protein in Search of Disease-Related PTM Sites</p></a></li>
<li><a href='#dpx'><p>Atom Depth Analysis</p></a></li>
<li><a href='#env.extract'><p>Sequence Environment Around a Given Position</p></a></li>
<li><a href='#env.matrices'><p>Environment Matrices</p></a></li>
<li><a href='#env.plot'><p>Differential Sequence Environment Plot</p></a></li>
<li><a href='#env.Ztest'><p>Preferred/Avoided Amino Acids Within an Environment</p></a></li>
<li><a href='#find.aaindex'><p>Find the Amino Acid Indexes</p></a></li>
<li><a href='#foldx.assembly'><p>Compute Assembly Free Energy</p></a></li>
<li><a href='#foldx.mut'><p>Compute Changes in Stability (DDG)</p></a></li>
<li><a href='#foldx.stab'><p>Compute Folding Free Energy (DG)</p></a></li>
<li><a href='#get.area'><p>Atomic Solvation Energies.</p></a></li>
<li><a href='#get.go'><p>Get Gene Ontology Annotation</p></a></li>
<li><a href='#get.seq'><p>Import a Protein Sequence from a Database</p></a></li>
<li><a href='#gl.scan'><p>Scan a Protein in Search of OGlcNAc Sites</p></a></li>
<li><a href='#gracefully_fail'><p>Check that Internet Resource Work Properly and Fail Gracefully When Not</p></a></li>
<li><a href='#hdfisher.go'><p>Hypothesis-Driven Fisher Test</p></a></li>
<li><a href='#hmeto'><p>Human MetO sites oxidized by hydrogen peroxide treatment.</p></a></li>
<li><a href='#id.features'><p>Features Related to the Protein Entry</p></a></li>
<li><a href='#id.mapping'><p>Identifier Mapping</p></a></li>
<li><a href='#imutant'><p>Compute Changes in Stability (DDG)</p></a></li>
<li><a href='#is.at'><p>Check Residue a Fixed Position</p></a></li>
<li><a href='#kegg.uniprot'><p>Identifier Mapping From KEGG to UniProt</p></a></li>
<li><a href='#me.scan'><p>Scan a Protein in Search of Methylation Sites</p></a></li>
<li><a href='#meto.list'><p>List Proteins Found in MetOSite Matching a Keyword</p></a></li>
<li><a href='#meto.scan'><p>Scans a Protein in Search of  MetO Sites</p></a></li>
<li><a href='#meto.search'><p>Search for Specific MetO Sites</p></a></li>
<li><a href='#mkdssp'><p>Compute DSSP File Using an In-House Version of the DSSP Software</p></a></li>
<li><a href='#msa'><p>Multiple Sequence Alignment</p></a></li>
<li><a href='#net.go'><p>Gene Ontology Network</p></a></li>
<li><a href='#ni.scan'><p>Scan a Protein in Search of Nitration Sites</p></a></li>
<li><a href='#p.scan'><p>Scan a Protein in Search of  Phosphosites</p></a></li>
<li><a href='#pairwise.dist'><p>Compute Euclidean Distances</p></a></li>
<li><a href='#parse.dssp'><p>Parse a DSSP File to Return a Dataframe</p></a></li>
<li><a href='#pdb.chain'><p>Download and/or Split PDB Files.</p></a></li>
<li><a href='#pdb.quaternary'><p>Protein Subunit Composition</p></a></li>
<li><a href='#pdb.select'><p>Select the PDB with the Optimal Coverage to the UniProt Sequence</p></a></li>
<li><a href='#pdb.seq'><p>Get Chain Sequences</p></a></li>
<li><a href='#pdb.uniprot'><p>Identifier Mapping From PDB to UniProt</p></a></li>
<li><a href='#pdb2uniprot'><p>Return the UniProt ID Given the PDB and Chain IDs</p></a></li>
<li><a href='#prot2codon'><p>Find the Coding Triplets for a Given Protein</p></a></li>
<li><a href='#ptm.plot'><p>Plot Values of a Property and PTM Sites Along the Protein Sequence</p></a></li>
<li><a href='#ptm.scan'><p>Scan a Protein in Search of PTM Sites</p></a></li>
<li><a href='#reg.scan'><p>Scan a Protein in Search of Regulatory PTM Sites</p></a></li>
<li><a href='#renum'><p>Renumerate Residue Position</p></a></li>
<li><a href='#renum.meto'><p>Renumerate Residue Position</p></a></li>
<li><a href='#renum.pdb'><p>Renumerate Residue Position</p></a></li>
<li><a href='#res.dpx'><p>Residue Depth Analysis</p></a></li>
<li><a href='#saro.dist'><p>Compute Distances to the Closest Aromatic Residues</p></a></li>
<li><a href='#saro.geometry'><p>Compute Geometric Parameters of S-Aromatic Motifs</p></a></li>
<li><a href='#saro.motif'><p>Search for S-Aromatic Motifs</p></a></li>
<li><a href='#search.go'><p>Search a Simple User Query</p></a></li>
<li><a href='#sni.scan'><p>Scan a Protein in Search of S-nitrosylation Sites</p></a></li>
<li><a href='#species.kegg'><p>Convert Between Species Name and KEGG 3-Letter Code Format</p></a></li>
<li><a href='#species.mapping'><p>Map Protein ID to Species</p></a></li>
<li><a href='#stru.part'><p>Partition of Structural Regions</p></a></li>
<li><a href='#su.scan'><p>Scan a Protein in Search of Sumoylation Sites</p></a></li>
<li><a href='#term.go'><p>Get Core Information About the GO Term</p></a></li>
<li><a href='#ub.scan'><p>Scan a Protein in Search of Ubiquitination Sites</p></a></li>
<li><a href='#uniprot.kegg'><p>Identifier Mapping From UniProt to KEGG</p></a></li>
<li><a href='#uniprot.pdb'><p>Identifier Mapping From UniProt to PDB</p></a></li>
<li><a href='#uniprot2pdb'><p>Return the PDB and Chain IDs of the Provided UniProt Protein</p></a></li>
<li><a href='#xprod'><p>Compute Cross Product</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analyses of Protein Post-Translational Modifications</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.6</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Juan Carlos Aledo &lt;caledo@uma.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains utilities for the analysis of post-translational modifications (PTMs) in proteins, 
    with particular emphasis on the sulfoxidation of methionine residues. Features include the ability to download, 
    filter and analyze data from the sulfoxidation database 'MetOSite', and integrate data from other main PTMs 
    (other databases). Utilities to search and characterize S-aromatic motifs in proteins are also provided. 
    In addition, functions to analyze sequence environments around modifiable residues in proteins can be found. 
    For instance, 'ptm' allows to search for amino acids either overrepresented or avoided around the modifiable 
    residues from the proteins of interest. Functions tailored to test statistical hypothesis related to
    these differential sequence environments are also implemented. A number of utilities to assess the effect
    of the modification/mutation of a given residue on the protein stability, have also been included in this package.
    Further and detailed information regarding the methods in this package can be found in (Aledo (2020) <a href="https://metositeptm.com">https://metositeptm.com</a>).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bitbucket.org/jcaledo/ptm">https://bitbucket.org/jcaledo/ptm</a>, <a href="https://metositeptm.com">https://metositeptm.com</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>bio3d (&ge; 2.3-4), Biostrings, curl, graphics, httr (&ge; 1.3.1),
igraph, jsonlite, muscle, RCurl, seqinr, stats, utils, xml2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>KEGGREST, knitr, markdown, testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-07 14:50:26 UTC; juancarlosaledo</td>
</tr>
<tr>
<td>Author:</td>
<td>Juan Carlos Aledo [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-07 15:20:17 UTC</td>
</tr>
</table>
<hr>
<h2 id='.get.exepath'>Find Full Paths to Executables</h2><span id='topic+.get.exepath'></span>

<h3>Description</h3>

<p>Finds the path to an executable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get.exepath(prg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".get.exepath_+3A_prg">prg</code></td>
<td>
<p>name of the executable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the absolute path.
</p>

<hr>
<h2 id='.get.url'>Get Web Resource</h2><span id='topic+.get.url'></span>

<h3>Description</h3>

<p>Gets a web resource.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get.url(url, n_tries = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".get.url_+3A_url">url</code></td>
<td>
<p>url to be reached.</p>
</td></tr>
<tr><td><code id=".get.url_+3A_n_tries">n_tries</code></td>
<td>
<p>number of tries.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the response or an error message.
</p>

<hr>
<h2 id='aa.at'>Residue Found at the Requested Position</h2><span id='topic+aa.at'></span>

<h3>Description</h3>

<p>Returns the residue found at the requested position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aa.at(at, target, uniprot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aa.at_+3A_at">at</code></td>
<td>
<p>the position in the primary structure of the protein.</p>
</td></tr>
<tr><td><code id="aa.at_+3A_target">target</code></td>
<td>
<p>a character string specifying the UniProt ID of the protein of interest or, alternatively, the sequence of that protein.</p>
</td></tr>
<tr><td><code id="aa.at_+3A_uniprot">uniprot</code></td>
<td>
<p>logical, if TRUE the argument 'target' should be an ID.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please, note that when uniprot is set to FALSE, target can be the string returned by a suitable function, such as get.seq or other.
</p>


<h3>Value</h3>

<p>Returns a single character representing the residue found at the indicated position in the indicated protein.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>See Also</h3>

<p>is.at(), renum.pdb(), renum.meto(), renum(), aa.comp()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: aa.at(28, 'P01009')
</code></pre>

<hr>
<h2 id='aa.comp'>Amino Acid Composition</h2><span id='topic+aa.comp'></span>

<h3>Description</h3>

<p>Returns a table with the amino acid composition of the target protein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aa.comp(target, uniprot = TRUE, reference = 'human', init = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aa.comp_+3A_target">target</code></td>
<td>
<p>a character string specifying the UniProt ID of the protein of interest or, alternatively, the sequence of that protein.</p>
</td></tr>
<tr><td><code id="aa.comp_+3A_uniprot">uniprot</code></td>
<td>
<p>logical, if TRUE the argument 'target' should be an ID.</p>
</td></tr>
<tr><td><code id="aa.comp_+3A_reference">reference</code></td>
<td>
<p>amino acid frequencies (in percent) of the proteinogenic amino acids to be used as reference. It should be either 'human', 'up' (composition of proteins in UniProt in 2019). Alternatively, the user can pass as argument any vector with 20 values to be used as reference.</p>
</td></tr>
<tr><td><code id="aa.comp_+3A_init">init</code></td>
<td>
<p>logical, whether remove or not the first residue (initiation methionine) from the sequence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list where the first element is a dataframe with the observed and expected frequencies for each amino acid, the second element is the result of the Chi-squared test. In addition, a plot to reflect potential deviations from the reference standard composition is shown.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>See Also</h3>

<p>is.at(), renum.pdb(), renum.meto(), renum(), aa.at()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aa.comp('MPSSVSWGILLLAGLCCLVPVSLAEDPQGDAAQK', uniprot = FALSE)
</code></pre>

<hr>
<h2 id='abundance'>Protein Abundance Data</h2><span id='topic+abundance'></span>

<h3>Description</h3>

<p>Returns data regarding the abundance of a given protein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abundance(id, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abundance_+3A_id">id</code></td>
<td>
<p>the UniProt identifier of the protein of interest.</p>
</td></tr>
<tr><td><code id="abundance_+3A_...">...</code></td>
<td>
<p>either 'jarkat' or 'hela' if required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For human proteins, in addition to the abundance in the whole organism (by default), the abundance found in Jurkat or HeLa cells can be requested. The data are obtained from the PaxDb.
</p>


<h3>Value</h3>

<p>A numeric value for the abundance, expressed a parts per million (ppm), of the requested protein.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Wang et al. Proteomics 2015, 10.1002/pmic.201400441. (PMID: 25656970)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>abundance(id = 'A0AVT1')
## Not run: abundance(id = 'A0AVT1', 'jurkat')
## Not run: abundance(id = 'A0AVT1', 'hela')
</code></pre>

<hr>
<h2 id='ac.scan'>Scan a Protein in Search of Acetylation Sites</h2><span id='topic+ac.scan'></span>

<h3>Description</h3>

<p>Scans the indicated protein in search of acetylation sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ac.scan(up_id, db = 'all')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ac.scan_+3A_up_id">up_id</code></td>
<td>
<p>a character string corresponding to the UniProt ID.</p>
</td></tr>
<tr><td><code id="ac.scan_+3A_db">db</code></td>
<td>
<p>the database where to search. It should be one among 'PSP', 'dbPTM', 'all'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If db = 'all' has been selected, it may happen that the same residue appears in several rows if it is present in different databases.
</p>


<h3>Value</h3>

<p>Returns a dataframe where each row corresponds to an acetylable residue.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Hornbeck et al. Nucleic Acids Res. 2019 47:D433-D441, (PMID: 30445427).
</p>
<p>Huang et al. Nucleic Acids Res. 2019 47:D298-D308, (PMID: 30418626).
</p>


<h3>See Also</h3>

<p>meto.scan(), p.scan(), me.scan(), ub.scan(), su.scan(), gl.scan(), sni.scan(), ni.scan(), ptm.scan(), reg.scan(), dis.scan()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ac.scan('P01009', db = 'PSP')
</code></pre>

<hr>
<h2 id='acc.dssp'>Compute Residue Accessibility and SASA</h2><span id='topic+acc.dssp'></span>

<h3>Description</h3>

<p>Computes the accessibility as well as the SASA for each reside from the indicated protein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acc.dssp(pdb, aa = 'all')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acc.dssp_+3A_pdb">pdb</code></td>
<td>
<p>is either a PDB id, or the path to a pdb file.</p>
</td></tr>
<tr><td><code id="acc.dssp_+3A_aa">aa</code></td>
<td>
<p>one letter code for the amino acid of interest, or 'all' for all the protein residues.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You must have installed DSSP on your system and in the search path for executables.
</p>


<h3>Value</h3>

<p>A dataframe where each row is an individual residue of the selected protein. The variables computed, among others, are:
(i) the secondary structure (ss) element to which the residue belongs,
(ii) the solvent accessible surface area (sasa) of each residue in square angstrom (Å²), and
(iii) the accessibility (acc) computed as the percent of the sasa that the residue X would have in the tripeptide GXG with the polypeptide skeleton in an extended conformation and the side chain in the conformation most frequently observed in proteins.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Miller et al (1987) J. Mol. Biol. 196: 641-656 (PMID: 3681970).
</p>
<p>Touw et al (2015) Nucl. Ac. Res. 43(Database issue): D364-D368 (PMID: 25352545).
</p>


<h3>See Also</h3>

<p>atom.dpx(), res.dpx(), str.part()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: acc.dssp('3cwm')
</code></pre>

<hr>
<h2 id='atom.dpx'>Atom Depth Analysis</h2><span id='topic+atom.dpx'></span>

<h3>Description</h3>

<p>Computes the depth from the surface for each protein's atom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atom.dpx(pdb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="atom.dpx_+3A_pdb">pdb</code></td>
<td>
<p>is either a PDB id, or the path to a pdb file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the depth, defined as the distance in angstroms between the target atom and the closest atom on the protein surface. When the protein is composed of several subunits, the calculations are made for both, the atom being part of the complex, and the atom being only part of the polypeptide chain to which it belongs.
</p>


<h3>Value</h3>

<p>A dataframe with the computed depths.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Pintar et al. 2003. Bioinformatics 19:313-314 (PMID: 12538266)
</p>


<h3>See Also</h3>

<p>res.dpx(), acc.dssp(), str.part()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: atom.dpx('1cll')
</code></pre>

<hr>
<h2 id='bg.go'>Search GO Terms for Background Set</h2><span id='topic+bg.go'></span>

<h3>Description</h3>

<p>Searches the GO terms of the protein contained in a given set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bg.go(ids)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bg.go_+3A_ids">ids</code></td>
<td>
<p>either a vector containing the UniProt IDs of the background set or the path to the txt file containing the list of IDs acting as background.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe with two columns (Uniprot ID, GO terms) and as many rows as different proteins there are in the input set.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Rhee et al. (2008) Nature Reviews Genetics 9:509–515.
</p>


<h3>See Also</h3>

<p>search.go(), term.go(), get.go(), go.enrich(), gorilla(), net.go()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: bg.go(c('P01009', 'P01374', 'Q86UP4'))
</code></pre>

<hr>
<h2 id='ddG.profile'>Contribution of a given position to changes in stability</h2><span id='topic+ddG.profile'></span>

<h3>Description</h3>

<p>Represents the sensitivity of a given position to changes in stability of a protein (DDG).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddG.profile(prot, ch, pos, pH = 7, Te = 25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddG.profile_+3A_prot">prot</code></td>
<td>
<p>either the 4-letter identifier of a PDB structure, or the amino acid sequence (one letter amino acid code) of a protein.</p>
</td></tr>
<tr><td><code id="ddG.profile_+3A_ch">ch</code></td>
<td>
<p>a letter identifying the chain of interest.</p>
</td></tr>
<tr><td><code id="ddG.profile_+3A_pos">pos</code></td>
<td>
<p>the position, in the primary structure, of the residue to be mutated.</p>
</td></tr>
<tr><td><code id="ddG.profile_+3A_ph">pH</code></td>
<td>
<p>a numeric value between 0 and 14.</p>
</td></tr>
<tr><td><code id="ddG.profile_+3A_te">Te</code></td>
<td>
<p>a numeric value indicating the temperature in degrees Celsius.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It must be remembered that DDG &gt; 0 implies destabilizing change and DDG &gt; 0 implies a stabilizing change.
</p>


<h3>Value</h3>

<p>The function returns a dataframe with the DDG values (kcal/mol) for each alternative amino acid, and a barplot grouping the amino acids according to their physicochemical nature.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>See Also</h3>

<p>foldx.mut(), imutant()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ddG.profile(prot = '1pga', ch = 'A', pos = 27)
</code></pre>

<hr>
<h2 id='ddG.ptm'>PDB Model and Change in Stability of a Modified Protein</h2><span id='topic+ddG.ptm'></span>

<h3>Description</h3>

<p>Builds a PDB model of the modified protein and computes the corresponding change in stability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddG.ptm(pdb, ch, pos, ptm, dir = 'f', pH = 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddG.ptm_+3A_pdb">pdb</code></td>
<td>
<p>the 4-letter identifier of a PDB structure or the path to a PDB file.</p>
</td></tr>
<tr><td><code id="ddG.ptm_+3A_ch">ch</code></td>
<td>
<p>a letter identifying the chain of interest.</p>
</td></tr>
<tr><td><code id="ddG.ptm_+3A_pos">pos</code></td>
<td>
<p>the position, in the primary structure, of the residue to be modified.</p>
</td></tr>
<tr><td><code id="ddG.ptm_+3A_ptm">ptm</code></td>
<td>
<p>the post-translational modification to be considered. It should be one among: 'pSer', 'pThr', 'pTyr', 'MetO-Q', 'MetO-T'.</p>
</td></tr>
<tr><td><code id="ddG.ptm_+3A_dir">dir</code></td>
<td>
<p>indicates the direction of the PTM reaction: either forward ('f'), or backward ('b').</p>
</td></tr>
<tr><td><code id="ddG.ptm_+3A_ph">pH</code></td>
<td>
<p>a numeric value between 0 and 14.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The current function uses FoldX to build the model of the modified protein. Currently, FoldX does not allow to change Met by MetO, so we use glutamine (Q) or threonine (T) to mimic MetO.
</p>


<h3>Value</h3>

<p>The function computes and returns the DDG (kcal/mol) for the requested modification, defined as DDG = DGmodified - DGunmodified, where DG is the Gibbs free energy for the folding of the protein from its unfolded state. Thus, a positive value means a destabilizing effect, and vice versa. A PDB model containing the modified target is saved in the current directory.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Schymkowitz et al (2005) Nucl. Ac. Res. 33:W382-W388.
</p>


<h3>See Also</h3>

<p>imutant(), foldx.mut(), ddG.profile()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ddG.ptm('./1u8f_Repair.pdb', 'O', pos = 246, ptm = 'pThr')
</code></pre>

<hr>
<h2 id='dis.scan'>Scan a Protein in Search of Disease-Related PTM Sites</h2><span id='topic+dis.scan'></span>

<h3>Description</h3>

<p>Scans the indicated protein in search of disease-related PTM sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dis.scan(up_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dis.scan_+3A_up_id">up_id</code></td>
<td>
<p>a character string corresponding to the UniProt ID.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe where each row corresponds to a residue, and the columns inform about the disease-related modifications.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Hornbeck et al. Nucleic Acids Res. 2019 47:D433-D441, (PMID: 30445427).
</p>


<h3>See Also</h3>

<p>meto.scan(), ac.scan(), me.scan(), ub.scan(), su.scan(), gl.scan(), sni.scan(), ni.scan(), ptm.scan(), reg.scan(), p.scan()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: dis.scan('P31749')
</code></pre>

<hr>
<h2 id='dpx'>Atom Depth Analysis</h2><span id='topic+dpx'></span>

<h3>Description</h3>

<p>Computes the depth from the surface for each protein's atom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpx(pdb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dpx_+3A_pdb">pdb</code></td>
<td>
<p>is either a PDB id, or the path to a pdb file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the depth, defined as the distance in angstroms between the target atom and the closest atom on the protein surface.
</p>


<h3>Value</h3>

<p>A dataframe with the computed depths.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Pintar et al. 2003. Bioinformatics 19:313-314 (PMID: 12538266)
</p>


<h3>See Also</h3>

<p>compute.dssp(), atom.dpx(), res.dpx(), acc.dssp(), str.part()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: dpx('3cwm')
</code></pre>

<hr>
<h2 id='env.extract'>Sequence Environment Around a Given Position</h2><span id='topic+env.extract'></span>

<h3>Description</h3>

<p>Extracts the sequence environment around a given position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env.extract(prot, db = 'none', c, r, ctr = 'none', exclude = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env.extract_+3A_prot">prot</code></td>
<td>
<p>either a uniprot id or a string sequence.</p>
</td></tr>
<tr><td><code id="env.extract_+3A_db">db</code></td>
<td>
<p>a character string specifying the desired database; it must be one of 'uniprot', 'metosite', 'none'.</p>
</td></tr>
<tr><td><code id="env.extract_+3A_c">c</code></td>
<td>
<p>center of the environment.</p>
</td></tr>
<tr><td><code id="env.extract_+3A_r">r</code></td>
<td>
<p>radius of the environment.</p>
</td></tr>
<tr><td><code id="env.extract_+3A_ctr">ctr</code></td>
<td>
<p>the type of control environment; it must be one of 'random', 'closest', or 'none'.</p>
</td></tr>
<tr><td><code id="env.extract_+3A_exclude">exclude</code></td>
<td>
<p>a vector containing the positions to be excluded as control.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The random control returns an environment center at a random position containing the same type or amino acid than the positive environment. The closest control searches for the closest position where such a type of amino acid is found and returns its environment.
</p>


<h3>Value</h3>

<p>Returns a  list of two strings (environments).
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Aledo et al. Sci Rep. 2015; 5: 16955. (PMID: 26597773)
</p>


<h3>See Also</h3>

<p>env.matrices(), env.Ztest() and env.plot()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>env.extract('P01009', db = 'uniprot', 271, 10, ctr = 'random')
</code></pre>

<hr>
<h2 id='env.matrices'>Environment Matrices</h2><span id='topic+env.matrices'></span>

<h3>Description</h3>

<p>Provides the frequencies of each amino acid within the environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env.matrices(env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env.matrices_+3A_env">env</code></td>
<td>
<p>a character string vector containing the environments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of two dataframes. The first, shown the environment in matrix form. The second provides the frequencies of each amino acid within the environments.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Aledo et al. Sci Rep. 2015; 5: 16955. (PMID: 26597773)
</p>


<h3>See Also</h3>

<p>env.extract(), env.Ztest() and env.plot()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>env.matrices(c('ANQRmCTPQ', 'LYPPmQTPC', 'XXGSmSGXX'))
</code></pre>

<hr>
<h2 id='env.plot'>Differential Sequence Environment Plot</h2><span id='topic+env.plot'></span>

<h3>Description</h3>

<p>Plots the Z statistics at each position within the environment for the requested amino acid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env.plot(Z, aa, pValue = 0.001, ylim = c(-8,6), ty = 'p',title = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env.plot_+3A_z">Z</code></td>
<td>
<p>a matrix containing the standardized difference in frequencies (positive - control).</p>
</td></tr>
<tr><td><code id="env.plot_+3A_aa">aa</code></td>
<td>
<p>the amino acid of interest.</p>
</td></tr>
<tr><td><code id="env.plot_+3A_pvalue">pValue</code></td>
<td>
<p>the p-Value chosen to confer statistical significance.</p>
</td></tr>
<tr><td><code id="env.plot_+3A_ylim">ylim</code></td>
<td>
<p>range of the dependent variable. If we pass the argument 'automatic', the function will choose a suitable range for you.</p>
</td></tr>
<tr><td><code id="env.plot_+3A_ty">ty</code></td>
<td>
<p>what type of plot should be drawn (&quot;p&quot;: points, &quot;l&quot;: lines, &quot;b&quot;: both).</p>
</td></tr>
<tr><td><code id="env.plot_+3A_title">title</code></td>
<td>
<p>character string giving a title for the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The p-Value is used to draw two horizontal lines delimiting the region supporting the null hypothesis: no significant differences. Points laying above or below of these lines cannot be explained by randomness.
</p>


<h3>Value</h3>

<p>This function returns a plot for the requested amino acid.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Aledo et al. Sci Rep. 2015; 5: 16955. (PMID: 26597773)
</p>


<h3>See Also</h3>

<p>env.extract(), env.matrices() and env.Ztest()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Get the matrices
pos = env.matrices(hmeto$positive)[[2]][,-11]
ctr = env.matrices(hmeto$control)[[2]][,-11]
## Run the test
Z = env.Ztest(pos, ctr, alpha = 0.0001)[[1]]
## Plot the results
env.plot(Z, aa = 'E', pValue = 0.05)
## End(Not run)
</code></pre>

<hr>
<h2 id='env.Ztest'>Preferred/Avoided Amino Acids Within an Environment</h2><span id='topic+env.Ztest'></span>

<h3>Description</h3>

<p>Searches for amino acids either overrepresented or avoided at given positions within a sequence environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env.Ztest(pos, ctr, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env.Ztest_+3A_pos">pos</code></td>
<td>
<p>a 21 x m matrix containing the absolute frequencies of 21 amino acids at the m positions, in the positive environments.</p>
</td></tr>
<tr><td><code id="env.Ztest_+3A_ctr">ctr</code></td>
<td>
<p>a 21 x m matrix containing the absolute frequencies of 21 amino acids at the m positions, in the control environments.</p>
</td></tr>
<tr><td><code id="env.Ztest_+3A_alpha">alpha</code></td>
<td>
<p>significance level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please, note that in addition to the 20 proteinogenetic amino acid we are using the symbol X when the target (central) residue is closer to the N-terminal or C-terminal of the protein than the radius used.
</p>


<h3>Value</h3>

<p>Returns a list with three elements: (1) a matrix with the values of the Z statistical. (2) A dataframe with information regarding amino acid overrepresented in the positive environments, and (3) a dataframe similar to the previous one, but for amino acids avoided from the positive environments.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Aledo et al. Sci Rep. 2015; 5: 16955. (PMID: 26597773)
</p>


<h3>See Also</h3>

<p>env.extract(), env.matrices() and env.plot()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pos = env.matrices(hmeto$positive)[[2]][,-11]; ctr = env.matrices(hmeto$control)[[2]][,-11]
env.Ztest(pos, ctr, alpha = 0.0001)
</code></pre>

<hr>
<h2 id='find.aaindex'>Find the Amino Acid Indexes</h2><span id='topic+find.aaindex'></span>

<h3>Description</h3>

<p>Finds amino acid indexes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.aaindex(word)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.aaindex_+3A_word">word</code></td>
<td>
<p>a character string for the key-word of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number and ID of the indexes matching the requested word
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>https://www.genome.jp/aaindex/AAindex/list_of_indices
</p>


<h3>See Also</h3>

<p>ptm.plot()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>find.aaindex('mutability')
find.aaindex('Kyte-Doolittle')
</code></pre>

<hr>
<h2 id='foldx.assembly'>Compute Assembly Free Energy</h2><span id='topic+foldx.assembly'></span>

<h3>Description</h3>

<p>Computes changes in the Gibbs free energy of the assembly process of a protein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foldx.assembly(pdb, mol1, mol2, pH = 7, I = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="foldx.assembly_+3A_pdb">pdb</code></td>
<td>
<p>the 4-letter identifier of a PDB structure or the path to a PDB file.</p>
</td></tr>
<tr><td><code id="foldx.assembly_+3A_mol1">mol1</code></td>
<td>
<p>molecule or group of molecules interacting with mol2 (see details)</p>
</td></tr>
<tr><td><code id="foldx.assembly_+3A_mol2">mol2</code></td>
<td>
<p>molecule or group of molecules interacting with mol1 (see details)</p>
</td></tr>
<tr><td><code id="foldx.assembly_+3A_ph">pH</code></td>
<td>
<p>a numeric value between 0 and 14.</p>
</td></tr>
<tr><td><code id="foldx.assembly_+3A_i">I</code></td>
<td>
<p>a value indicating the molar ionic strength.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the FoldX's command 'AnalyseComplex', which allows to determine the interaction energy between two molecules or two groups of molecules. For instance, if in a dimeric protein, formed by chain A and B, we may set: mol1 = 'A', mol2 = 'B'. If we are dealing with a trimer, we may set: mol1 = 'A', mol2: 'AB'.
</p>


<h3>Value</h3>

<p>The function returns a dataframe with the residues that make up the interface between mol1 and mol2, as well as the change in Gibbs free energy, DG, of the assembly process for the requested subunits.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Schymkowitz et al (2005) Nucl. Ac. Res. 33:W382-W388.
</p>


<h3>See Also</h3>

<p>foldx.stab()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: foldx.assembly(pdb = '1sev', mol1 = 'A', mol2 = 'B')
</code></pre>

<hr>
<h2 id='foldx.mut'>Compute Changes in Stability (DDG)</h2><span id='topic+foldx.mut'></span>

<h3>Description</h3>

<p>Computes changes in the stability of a protein after a residue mutation using a force-field approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foldx.mut(pdb, ch, pos, newres = "", pH =7, method = "buildmodel", keepfiles = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="foldx.mut_+3A_pdb">pdb</code></td>
<td>
<p>the 4-letter identifier of a PDB structure or the path to a PDB file.</p>
</td></tr>
<tr><td><code id="foldx.mut_+3A_ch">ch</code></td>
<td>
<p>a letter identifying the chain of interest.</p>
</td></tr>
<tr><td><code id="foldx.mut_+3A_pos">pos</code></td>
<td>
<p>the position, in the primary structure, of the residue to be mutated.</p>
</td></tr>
<tr><td><code id="foldx.mut_+3A_newres">newres</code></td>
<td>
<p>the one letter code of the residue to be incorporated. When a value is not entered for this parameter, then the function will compute DDG for the mutation to any possible amino acid (including phosphoserine, phosphothreonine, phosphotyrosine and hydroxiproline in the case of the 'positionscan' method).</p>
</td></tr>
<tr><td><code id="foldx.mut_+3A_ph">pH</code></td>
<td>
<p>a numeric value between 0 and 14.</p>
</td></tr>
<tr><td><code id="foldx.mut_+3A_method">method</code></td>
<td>
<p>a character string specifying the approach to be used; it must be one of 'buildmodel', 'positionscan'.</p>
</td></tr>
<tr><td><code id="foldx.mut_+3A_keepfiles">keepfiles</code></td>
<td>
<p>logical, when TRUE the repaired PDB file is saved in the working directory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two computational approaches for prediction of the effect of amino acid changes on protein stability are implemented. FoldX (buildmodel and positionscan methods) uses a force field approach and although it has been proved to be satisfactorily accurate, it is also a time-consuming method. An alternative much faster is I-Mutant, a method base on machine-learning
</p>


<h3>Value</h3>

<p>The function computes and returns the DDG (kcal/mol) for the requested residue change, defined as DDG = DGmt - DGwt, where DG is the Gibbs free energy for the folding of the protein from its unfolded state. Thus, a positive value means a destabilizing effect, and vice versa.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Schymkowitz et al (2005) Nucl. Ac. Res. 33:W382-W388.
</p>


<h3>See Also</h3>

<p>imutant(), ddG.profile()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: foldx.mut('1aaq', 'A', 45, 'R')
</code></pre>

<hr>
<h2 id='foldx.stab'>Compute Folding Free Energy (DG)</h2><span id='topic+foldx.stab'></span>

<h3>Description</h3>

<p>Computes changes in the Gibbs free energy of the folding process of a protein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foldx.stab(pdb, pH = 7, I = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="foldx.stab_+3A_pdb">pdb</code></td>
<td>
<p>the 4-letter identifier of a PDB structure or the path to a PDB file.</p>
</td></tr>
<tr><td><code id="foldx.stab_+3A_ph">pH</code></td>
<td>
<p>a numeric value between 0 and 14.</p>
</td></tr>
<tr><td><code id="foldx.stab_+3A_i">I</code></td>
<td>
<p>a value indicating the molar ionic strength.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the FoldX's command 'Stability'
</p>


<h3>Value</h3>

<p>The function computes and returns the DG (kcal/mol) of the folding process of the requested protein.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Schymkowitz et al (2005) Nucl. Ac. Res. 33:W382-W388.
</p>


<h3>See Also</h3>

<p>foldx.assembly()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: foldx.stab('5zok')
</code></pre>

<hr>
<h2 id='get.area'>Atomic Solvation Energies.</h2><span id='topic+get.area'></span>

<h3>Description</h3>

<p>Computes online surface energies using the Getarea server.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.area(pdb, keepfiles = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.area_+3A_pdb">pdb</code></td>
<td>
<p>is either a PDB id, or the path to a pdb file.</p>
</td></tr>
<tr><td><code id="get.area_+3A_keepfiles">keepfiles</code></td>
<td>
<p>logical, if TRUE the dataframe will be saved in the working directory and we will keep the getarea txt file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the option keepfiles is set as TRUE, then txt and Rda files are saved in the working directory.
</p>


<h3>Value</h3>

<p>This function returns a dataframe containing the requested information.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Fraczkiewicz, R. and Braun, W. (1998) J. Comp. Chem., 19, 319-333.
</p>


<h3>See Also</h3>

<p>compute.dssp(), atom.dpx(), res.dpx(), acc.dssp(), str.part()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: get.area('3cwm')
</code></pre>

<hr>
<h2 id='get.go'>Get Gene Ontology Annotation</h2><span id='topic+get.go'></span>

<h3>Description</h3>

<p>Gets the gene ontology annotations for a given protein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.go(id, format = 'dataframe', silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.go_+3A_id">id</code></td>
<td>
<p>the UniProt identifier of the protein of interest.</p>
</td></tr>
<tr><td><code id="get.go_+3A_format">format</code></td>
<td>
<p>string indicating the output's format. It should be either 'dataframe' or 'string'. The 'string' format may be convenient when subsequent GO terms enrichment analysis is intended.</p>
</td></tr>
<tr><td><code id="get.go_+3A_silent">silent</code></td>
<td>
<p>logical, if FALSE print details of the reading process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe (by default) with GO IDs linked to the protein of interest, as well as additional information related to these GO ids. A string with the GO ids can be obtained as output if indicated by means of the argument 'format'.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Rhee et al. (2008) Nature Reviews Genetics 9:509–515.
</p>


<h3>See Also</h3>

<p>search.go, term.go(), bg.go(), hdfisher.go(), gorilla(), net.go()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: get.go('P01009')
</code></pre>

<hr>
<h2 id='get.seq'>Import a Protein Sequence from a Database</h2><span id='topic+get.seq'></span>

<h3>Description</h3>

<p>Imports a protein sequence from a selected database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.seq(id, db = 'uniprot', as.string = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.seq_+3A_id">id</code></td>
<td>
<p>the identifier of the protein of interest.</p>
</td></tr>
<tr><td><code id="get.seq_+3A_db">db</code></td>
<td>
<p>a character string specifying the desired database; it must be one of 'uniprot', 'metosite', 'pdb', 'kegg-aa', 'kegg-nt'.</p>
</td></tr>
<tr><td><code id="get.seq_+3A_as.string">as.string</code></td>
<td>
<p>logical, if TRUE the imported sequence will be returned as a character string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MetOSite uses the same type of protein ID than UniProt. However, if the chosen database is PDB, the identifier should be the 4-character unique identifier characteristic of PDB, followed by colon and the chain of interest. For instance, '2OCC:B' means we are interested in the sequence of chain B from the structure 2OCC. KEGG used its own IDs (see examples).
</p>


<h3>Value</h3>

<p>Returns a protein (or nucleotide) sequence either as a character vector or a as a character string.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get.seq('P01009')
</code></pre>

<hr>
<h2 id='gl.scan'>Scan a Protein in Search of OGlcNAc Sites</h2><span id='topic+gl.scan'></span>

<h3>Description</h3>

<p>Scans the indicated protein in search of glycosylation sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gl.scan(up_id, db = 'all')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gl.scan_+3A_up_id">up_id</code></td>
<td>
<p>a character string corresponding to the UniProt ID.</p>
</td></tr>
<tr><td><code id="gl.scan_+3A_db">db</code></td>
<td>
<p>the database where to search. It should be one among 'PSP', 'dbPTM', 'all'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If db = 'all' has been selected, it may happen that the same residue appears in several rows if it is present in different databases.
</p>


<h3>Value</h3>

<p>Returns a dataframe where each row corresponds to a modifiable residue.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Hornbeck et al. Nucleic Acids Res. 2019 47:D433-D441, (PMID: 30445427).
</p>
<p>Huang et al. Nucleic Acids Res. 2019 47:D298-D308, (PMID: 30418626).
</p>


<h3>See Also</h3>

<p>meto.scan(), ac.scan(), me.scan(), ub.scan(), su.scan(), p.scan(), sni.scan(), ni.scan(), ptm.scan(), reg.scan(), dis.scan()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: gl.scan('P08670', db = 'PSP')
</code></pre>

<hr>
<h2 id='gracefully_fail'>Check that Internet Resource Work Properly and Fail Gracefully When Not</h2><span id='topic+gracefully_fail'></span>

<h3>Description</h3>

<p>Checks that internet resource works properly and fail gracefully when not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gracefully_fail(call, timeout = 10,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gracefully_fail_+3A_call">call</code></td>
<td>
<p>url of the resource.</p>
</td></tr>
<tr><td><code id="gracefully_fail_+3A_timeout">timeout</code></td>
<td>
<p>set maximum request time in seconds.</p>
</td></tr>
<tr><td><code id="gracefully_fail_+3A_...">...</code></td>
<td>
<p>further named parameters, such as query, headers, etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To be used as an ancillary function.
</p>


<h3>Value</h3>

<p>The response object or NULL when the server does not respond properly.
</p>


<h3>Author(s)</h3>

<p>thefactmachine
</p>


<h3>References</h3>

<p>https://gist.github.com/thefactmachine/18279b7796c0836d9188
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gracefully_fail("http://httpbin.org/delay/2")
</code></pre>

<hr>
<h2 id='hdfisher.go'>Hypothesis-Driven Fisher Test</h2><span id='topic+hdfisher.go'></span>

<h3>Description</h3>

<p>Carries out an enrichment Fisher's test using a hypothesis driven approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdfisher.go(target, background, query, analysis = 'enrichment')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hdfisher.go_+3A_target">target</code></td>
<td>
<p>either a vector containing the UniProt IDs of the target set or the path to the txt file containing the list of IDs.</p>
</td></tr>
<tr><td><code id="hdfisher.go_+3A_background">background</code></td>
<td>
<p>a dataframe with two columns (Uniprot ID and GO terms) and as many rows as different proteins there are in the background set.</p>
</td></tr>
<tr><td><code id="hdfisher.go_+3A_query">query</code></td>
<td>
<p>character string defining the query.</p>
</td></tr>
<tr><td><code id="hdfisher.go_+3A_analysis">analysis</code></td>
<td>
<p>a character string indicating whether the desired analysis is the enrichment ('enrichment') or depletion ('depletion').</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list that contains the contingency table and the p-Value.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Rhee et al. (2008) Nature Reviews Genetics 9:509–515.
</p>


<h3>See Also</h3>

<p>search.go(), term.go(), get.go(), bg.go(), go.enrich(), gorilla(), net.go()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: hdfisher.go(c('Q14667', 'Q5JSZ5'), bg.go(c('Q14667', 'Q5JSZ5', 'P13196')), 'ion')
</code></pre>

<hr>
<h2 id='hmeto'>Human MetO sites oxidized by hydrogen peroxide treatment.</h2><span id='topic+hmeto'></span>

<h3>Description</h3>

<p>A dataset containing data regarding human MetO sites oxidized by H2O2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmeto
</code></pre>


<h3>Format</h3>

<p>A data frame with 4472 rows and 15 variables:
</p>

<dl>
<dt>prot_id</dt><dd><p>UniProt ID of the oxidized protein</p>
</dd>
<dt>prot_name</dt><dd><p>the protein's name</p>
</dd>
<dt>met_pos</dt><dd><p>the position of the MetO site in the primary structure</p>
</dd>
<dt>met_vivo_vitro</dt><dd><p>conditions under which the oxidation experiment was carried out</p>
</dd>
<dt>MetOsites</dt><dd><p>array with all the sites oxidized in that protein</p>
</dd>
<dt>site_id</dt><dd><p>primary key identifying the site</p>
</dd>
<dt>positive</dt><dd><p>sequence environment of the MetO site</p>
</dd>
<dt>control</dt><dd><p>sequence environment of a non oxidized Met from the same protein</p>
</dd>
<dt>IDP</dt><dd><p>Intrinsically Disordered Proteins, 0: the protein is not found in DisProt; 1: the protein contains disordered regions; 2: the protein may contain disordered regions but the experimental evidences are ambiguous</p>
</dd>
<dt>IDR</dt><dd><p>Intrinsically Disordered Region, TRUE: the MetO site belong to the IDR, FALSE: the MetO site doesn't belong to the IDR</p>
</dd>
<dt>abundance</dt><dd><p>protein abundance, in ppm</p>
</dd>
<dt>N</dt><dd><p>protein length, in number of residues</p>
</dd>
<dt>met</dt><dd><p>number of methionine residues</p>
</dd>
<dt>fmet</dt><dd><p>relative frequency of Met in that protein</p>
</dd>
<dt>prot_vivo_vitro</dt><dd><p>whether the protein has been described to be oxidized in vivo, in vitro or under both conditions</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://metosite.uma.es/">https://metosite.uma.es/</a>
</p>

<hr>
<h2 id='id.features'>Features Related to the Protein Entry</h2><span id='topic+id.features'></span>

<h3>Description</h3>

<p>Obtains features related to the provided id.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id.features(id, features = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="id.features_+3A_id">id</code></td>
<td>
<p>the UniProt identifier of the protein of interest.</p>
</td></tr>
<tr><td><code id="id.features_+3A_features">features</code></td>
<td>
<p>a string identifying the features (comma separated) to be recovered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default the the function provides info regarding the following features: id, reviewed, entry name and organism. If wished, this list of features can be expanded using the argument 'features'. There is a large list of features that can be retrieved. You can look up your relevant feature's name in the full list of UniProtKB found at https://www.uniprot.org/help/return_fields.
</p>


<h3>Value</h3>

<p>Returns a named list with the requested features.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>See Also</h3>

<p>species.mapping()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: id.features('P04406', features = 'ec,keyword,xref_pdb')
</code></pre>

<hr>
<h2 id='id.mapping'>Identifier Mapping</h2><span id='topic+id.mapping'></span>

<h3>Description</h3>

<p>Mapping between protein identifiers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id.mapping(id, from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="id.mapping_+3A_id">id</code></td>
<td>
<p>the identifier to be converted.</p>
</td></tr>
<tr><td><code id="id.mapping_+3A_from">from</code></td>
<td>
<p>the type for the identifier of origin; it must be one of 'uniprot', 'pdb', or 'kegg'.</p>
</td></tr>
<tr><td><code id="id.mapping_+3A_to">to</code></td>
<td>
<p>the type for the identifier of destination; it must be one of 'uniprot', 'pdb', or 'kegg'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character string corresponding to the requested identifier.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>See Also</h3>

<p>pdb2uniprot(), uniprot2pdb()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: id.mapping('P01009', from = 'uniprot', to = 'pdb')
</code></pre>

<hr>
<h2 id='imutant'>Compute Changes in Stability (DDG)</h2><span id='topic+imutant'></span>

<h3>Description</h3>

<p>Computes changes in the stability of a protein after a residue mutation using a machine-learning approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imutant(protein, ch = "_", pos, newres = "", pH = 7, Te = 25, timeout = 60)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imutant_+3A_protein">protein</code></td>
<td>
<p>either the 4-letter identifier of a PDB structure, or the amino acid sequence (one letter amino acid code) of a protein.</p>
</td></tr>
<tr><td><code id="imutant_+3A_ch">ch</code></td>
<td>
<p>a letter identifying the chain of interest.</p>
</td></tr>
<tr><td><code id="imutant_+3A_pos">pos</code></td>
<td>
<p>the position, in the primary structure, of the residue to be mutated.</p>
</td></tr>
<tr><td><code id="imutant_+3A_newres">newres</code></td>
<td>
<p>the one letter code of the residue to be incorporated. When a value is not entered for this parameter, then the function will compute DDG for the mutation to any possible amino acid.</p>
</td></tr>
<tr><td><code id="imutant_+3A_ph">pH</code></td>
<td>
<p>a numeric value between 0 and 14.</p>
</td></tr>
<tr><td><code id="imutant_+3A_te">Te</code></td>
<td>
<p>a numeric value indicating the temperature in degrees Celsius.</p>
</td></tr>
<tr><td><code id="imutant_+3A_timeout">timeout</code></td>
<td>
<p>maximum time to wait, in seconds, for a response from the I-Mutant server.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the I-Mutant v2.0 tool, which is a fast method based on a support vector machine approach to predict protein stability changes upon single point mutations.
</p>


<h3>Value</h3>

<p>The function computes and returns a dataframe containing the following variables:
</p>

<ul>
<li><p>Position:  Position in the primary structure of the mutated residue.
</p>
</li>
<li><p>WT:  Amino acid found at that position in the wild-type protein.
</p>
</li>
<li><p>NW:  New amino acid found in the mutated protein.
</p>
</li>
<li><p>DDG: Change in Gibbs free energy (kcal/mol), defined as DDG = DGmt - DGwt, where DG is the change in Gibbs free energy for the folding of the protein from its unfolded state. Thus, a positive value means a stabilizing effect, and vice versa.
</p>
</li>
<li><p>pH:  -log H+]
</p>
</li>
<li><p>T:   Temperature in Celsius degrees.
</p>
</li>
<li><p>RSA:  Relative Solvent Accessible Area (Only if a PDB file has been provided).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Capriotti et al (2005) Nucl. Ac. Res. 33:W306-W310.
</p>


<h3>See Also</h3>

<p>foldx.mut(), ddG.profile()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: imutant(protein = '1u8f', ch = 'O', pos = 46, newres = 'K')
</code></pre>

<hr>
<h2 id='is.at'>Check Residue a Fixed Position</h2><span id='topic+is.at'></span>

<h3>Description</h3>

<p>Checks if a given amino acid is at a given position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.at(at, target, aa = 'M', uniprot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.at_+3A_at">at</code></td>
<td>
<p>the position in the primary structure of the protein.</p>
</td></tr>
<tr><td><code id="is.at_+3A_target">target</code></td>
<td>
<p>a character string specifying the UniProt ID of the protein of interest or, alternatively, the sequence of that protein.</p>
</td></tr>
<tr><td><code id="is.at_+3A_aa">aa</code></td>
<td>
<p>the amino acid of interest.</p>
</td></tr>
<tr><td><code id="is.at_+3A_uniprot">uniprot</code></td>
<td>
<p>logical, if TRUE the argument 'target' should be an ID.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please, note that when uniprot is set to FALSE, target can be the string returned by a suitable function, such as get.seq or other.
</p>


<h3>Value</h3>

<p>Returns a boolean. Either the residue is present at that position or not.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>See Also</h3>

<p>aa.at(), renum.pdb(), renum.meto(), renum(), aa.comp()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: is.at(28, 'P01009', 'Q')
</code></pre>

<hr>
<h2 id='kegg.uniprot'>Identifier Mapping From KEGG to UniProt</h2><span id='topic+kegg.uniprot'></span>

<h3>Description</h3>

<p>Mapping between KEGG and UniProt protein identifiers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kegg.uniprot(id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kegg.uniprot_+3A_id">id</code></td>
<td>
<p>the identifier to be converted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character string corresponding to the requested identifier.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>See Also</h3>

<p>id.mapping()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: kegg.uniprot('hsa:5265')
</code></pre>

<hr>
<h2 id='me.scan'>Scan a Protein in Search of Methylation Sites</h2><span id='topic+me.scan'></span>

<h3>Description</h3>

<p>Scans the indicated protein in search of methylation sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>me.scan(up_id, db = 'all')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="me.scan_+3A_up_id">up_id</code></td>
<td>
<p>a character string corresponding to the UniProt ID.</p>
</td></tr>
<tr><td><code id="me.scan_+3A_db">db</code></td>
<td>
<p>the database where to search. It should be one among 'PSP', 'dbPTM', 'all'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If db = 'all' has been selected, it may happen that the same residue appears in several rows if it is present in different databases.
</p>


<h3>Value</h3>

<p>Returns a dataframe where each row corresponds to a modifiable residue.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Hornbeck et al. Nucleic Acids Res. 2019 47:D433-D441, (PMID: 30445427).
</p>
<p>Huang et al. Nucleic Acids Res. 2019 47:D298-D308, (PMID: 30418626).
</p>


<h3>See Also</h3>

<p>meto.scan(), ac.scan(), p.scan(), ub.scan(), su.scan(), gl.scan(), sni.scan(), ni.scan(), ptm.scan(), reg.scan(), dis.scan()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: me.scan('Q16695', db = 'PSP')
</code></pre>

<hr>
<h2 id='meto.list'>List Proteins Found in MetOSite Matching a Keyword</h2><span id='topic+meto.list'></span>

<h3>Description</h3>

<p>Lists proteins found in MetOSite with names matching the keyword.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meto.list(keyword)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meto.list_+3A_keyword">keyword</code></td>
<td>
<p>a character string corresponding to the keyword</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a dataframe with the uniprot id, the protein name and the species, for those proteins present into MetOSite whose name contains the keyword.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Valverde et al. 2019. Bioinformatics 35:4849-4850 (PMID: 31197322)
</p>


<h3>See Also</h3>

<p>meto.search(), meto.scan()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>meto.list('inhibitor')
</code></pre>

<hr>
<h2 id='meto.scan'>Scans a Protein in Search of  MetO Sites</h2><span id='topic+meto.scan'></span>

<h3>Description</h3>

<p>Scans a given protein in search of MetO sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meto.scan(up_id, report = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meto.scan_+3A_up_id">up_id</code></td>
<td>
<p>a character string corresponding to the UniProt ID.</p>
</td></tr>
<tr><td><code id="meto.scan_+3A_report">report</code></td>
<td>
<p>it should be a natural number between 1 and 3.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the 'report' parameter has been set to 1, this function returns a brief report providing the position,  the function category and literature references concerning the residues detected as MetO, if any. If we wish to obtain a more detailed report, the option should be: report = 2. Finally, If we want a detailed and printable report (saved in the current directory), we should set report = 3
</p>


<h3>Value</h3>

<p>This function returns a report regarding the MetO sites found, if any, in the protein of interest.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Valverde et al. 2019. Bioinformatics 35:4849-4850 (PMID: 31197322)
</p>


<h3>See Also</h3>

<p>meto.search(), meto.list()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>meto.scan('P01009')
</code></pre>

<hr>
<h2 id='meto.search'>Search for Specific MetO Sites</h2><span id='topic+meto.search'></span>

<h3>Description</h3>

<p>Searches for specific MetO sites filtering MetOSite according to the selected criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meto.search(highthroughput.group = TRUE,
                   bodyguard.group = TRUE,
                   regulatory.group = TRUE,
                   gain.activity = 2, loss.activity = 2, gain.ppi = 2,
                   loss.ppi = 2, change.stability = 2, change.location = 2,
                   organism = -1, oxidant = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meto.search_+3A_highthroughput.group">highthroughput.group</code></td>
<td>
<p>logical, when FALSE the sites described in a high-throughput study (unknown effect) are filtered out.</p>
</td></tr>
<tr><td><code id="meto.search_+3A_bodyguard.group">bodyguard.group</code></td>
<td>
<p>logical, when FALSE the sites postulated to function as ROS sink (because when oxidized no apparent effect can be detected) are filtered out.</p>
</td></tr>
<tr><td><code id="meto.search_+3A_regulatory.group">regulatory.group</code></td>
<td>
<p>logical, when FALSE the sites whose oxidation affect the properties of the protein (and therefore may be involved in regulation) are filtered out.</p>
</td></tr>
<tr><td><code id="meto.search_+3A_gain.activity">gain.activity</code></td>
<td>
<p>introduce 1 or 0 to indicate whether the oxidation of the selected sites implies a gain of activity or not, respectively. If we do not wish to use this property to filter, introduce 2.</p>
</td></tr>
<tr><td><code id="meto.search_+3A_loss.activity">loss.activity</code></td>
<td>
<p>introduce 1 or 0 to indicate whether or not the oxidation of the selected sites implies a loss of activity or not, respectively. If we do not wish to use this property to filter, introduce 2.</p>
</td></tr>
<tr><td><code id="meto.search_+3A_gain.ppi">gain.ppi</code></td>
<td>
<p>introduce 1 or 0 to indicate whether the oxidation of the selected sites implies a gain of protein-protein interaction or not, respectively. If we do not wish to use this property to filter, introduce 2.</p>
</td></tr>
<tr><td><code id="meto.search_+3A_loss.ppi">loss.ppi</code></td>
<td>
<p>introduce 1 or 0 to indicate whether or not the oxidation of the selected sites implies a loss of protein-protein interaction or not, respectively. If we do not wish to use this property to filter, introduce 2.</p>
</td></tr>
<tr><td><code id="meto.search_+3A_change.stability">change.stability</code></td>
<td>
<p>introduce 1 or 0 to indicate whether the oxidation of the selected sites leads to a change in the protein stability or not, respectively. If we do not wish to use this property to filter, introduce 2.</p>
</td></tr>
<tr><td><code id="meto.search_+3A_change.location">change.location</code></td>
<td>
<p>introduce 1 or 0 to indicate whether or not the oxidation of the selected sites implies a change of localization or not, respectively. If we do not wish to use this property to filter, introduce 2.</p>
</td></tr>
<tr><td><code id="meto.search_+3A_organism">organism</code></td>
<td>
<p>a character string indicating the scientific name of the species of interest, or -1 if we do not wish to filter by species.</p>
</td></tr>
<tr><td><code id="meto.search_+3A_oxidant">oxidant</code></td>
<td>
<p>a character string indicating the oxidant, or -1 if we do not wish to filter by oxidants.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that all the arguments of this function are optional. We only pass an argument to the function when we want to use that parameter to filter. Thus, meto.search() will return all the MetO sites found in the database MetOSite.
</p>


<h3>Value</h3>

<p>This function returns a dataframe with a line per MetO site.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Valverde et al. 2019. Bioinformatics 35:4849-4850 (PMID: 31197322)
</p>


<h3>See Also</h3>

<p>meto.scan(), meto.list()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>meto.search(organism = 'Homo sapiens', oxidant = 'HClO')
</code></pre>

<hr>
<h2 id='mkdssp'>Compute DSSP File Using an In-House Version of the DSSP Software</h2><span id='topic+mkdssp'></span>

<h3>Description</h3>

<p>Computes the DSSP file using an in-house version of the DSSP software.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkdssp(pdb, method = 'ptm', exefile = "dssp")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkdssp_+3A_pdb">pdb</code></td>
<td>
<p>is either a 4-character identifier of the PDB structure, or the path to a pdb file.</p>
</td></tr>
<tr><td><code id="mkdssp_+3A_method">method</code></td>
<td>
<p>a character string specifying the desired method to get the dssp dataframe; it should be one of 'ptm' or 'bio3d'.</p>
</td></tr>
<tr><td><code id="mkdssp_+3A_exefile">exefile</code></td>
<td>
<p>file path to the DSSP executable on your system (i.e. how is DSSP invoked).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The structure of the output data depends on the method chosen, but it will always contain the DSSP-related data.
</p>


<h3>Value</h3>

<p>Returns either a dataframe containing the information extracted from the dssp file (method ptm), or a list with that information (method bio3d).
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Touw et al (2015) Nucl. Ac. Res. 43(Database issue): D364-D368 (PMID: 25352545).
</p>


<h3>See Also</h3>

<p>download.dssp(), parse.dssp(), compute.dssp() and acc.dssp()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: mkdssp('3cwm', method = 'ptm')
</code></pre>

<hr>
<h2 id='msa'>Multiple Sequence Alignment</h2><span id='topic+msa'></span>

<h3>Description</h3>

<p>Aligns multiple protein sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msa(sequences, ids = names(sequences), sfile = FALSE, inhouse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msa_+3A_sequences">sequences</code></td>
<td>
<p>vector containing the sequences.</p>
</td></tr>
<tr><td><code id="msa_+3A_ids">ids</code></td>
<td>
<p>vector containing the sequences' ids.</p>
</td></tr>
<tr><td><code id="msa_+3A_sfile">sfile</code></td>
<td>
<p>if different to FALSE, then it should be a string indicating the path to save  a fasta alignment file.</p>
</td></tr>
<tr><td><code id="msa_+3A_inhouse">inhouse</code></td>
<td>
<p>logical, if TRUE the in-house MUSCLE software is used. It must be installed on your system and in the search path for executables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of four elements. The first one ($seq) provides the sequences analyzed, the second element ($ids) returns the identifiers, the third element ($aln) provides the alignment in fasta format and the fourth element ($ali) gives the alignment in matrix format.
</p>


<h3>References</h3>

<p>Edgar RC. Nucl. Ac. Res. 2004 32:1792-1797.
</p>
<p>Edgar RC. BMC Bioinformatics 5(1):113.
</p>


<h3>See Also</h3>

<p>custom.aln(), list.hom(), parse.hssp(), get.hssp(), shannon()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: msa(sequences = sapply(c("P19446", "P40925", "P40926"), ptm::get.seq),
 ids = c("wmelon", "cyt", "mit"))
## End(Not run)
</code></pre>

<hr>
<h2 id='net.go'>Gene Ontology Network</h2><span id='topic+net.go'></span>

<h3>Description</h3>

<p>Explores the relationship among proteins from a given set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net.go(data, threshold = 0.2, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net.go_+3A_data">data</code></td>
<td>
<p>either a vector containing the UniProt IDs (vertices) or the path to the txt or rda file containing them.</p>
</td></tr>
<tr><td><code id="net.go_+3A_threshold">threshold</code></td>
<td>
<p>threshold value of the Jaccard index above which two proteins are considered to be linked.</p>
</td></tr>
<tr><td><code id="net.go_+3A_silent">silent</code></td>
<td>
<p>logical, if FALSE print details of the running process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function first searches the GO terms for each vertex and then computes the Jaccard index for each protein pair, based on their GO terms. Afterwards, an adjacency matrix is computed, where two proteins are linked if their Jaccard index is greater than the selected threshold.
</p>


<h3>Value</h3>

<p>Returns a list containing (i) the dataframe corresponding to the computed Jaccard matrix, (ii) the adjacency matrix, (iii) a vector containing the vertices, and (iv) a matrix describing the edges of the network.
</p>


<h3>Author(s)</h3>

<p>Pablo Aledo &amp; Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Aledo &amp; Aledo (2020) Antioxidants 9(10), 987.
</p>
<p>Rhee et al. (2008) Nature Reviews Genetics 9:509–515.
</p>


<h3>See Also</h3>

<p>search.go(), term.go(), get.go(), bg.go(), gorilla()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: net.go(path2data = "./GOvivo.txt")
</code></pre>

<hr>
<h2 id='ni.scan'>Scan a Protein in Search of Nitration Sites</h2><span id='topic+ni.scan'></span>

<h3>Description</h3>

<p>Scans the indicated protein in search of nitration sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ni.scan(up_id, db = 'all')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ni.scan_+3A_up_id">up_id</code></td>
<td>
<p>a character string corresponding to the UniProt ID.</p>
</td></tr>
<tr><td><code id="ni.scan_+3A_db">db</code></td>
<td>
<p>the database where to search. It should be one among 'PSP', 'dbPTM', 'all'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe where each row corresponds to a modified residue.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Huang et al. Nucleic Acids Res. 2019 47:D298-D308, (PMID: 30418626).
</p>


<h3>See Also</h3>

<p>meto.scan(), ac.scan(), me.scan(), ub.scan(), su.scan(), gl.scan(), sni.scan(), p.scan(), ptm.scan(), reg.scan(), dis.scan()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ni.scan('P05202')
</code></pre>

<hr>
<h2 id='p.scan'>Scan a Protein in Search of  Phosphosites</h2><span id='topic+p.scan'></span>

<h3>Description</h3>

<p>Scans the indicated protein in search of phosphosites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p.scan(up_id, db = 'all')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p.scan_+3A_up_id">up_id</code></td>
<td>
<p>a character string corresponding to the UniProt ID.</p>
</td></tr>
<tr><td><code id="p.scan_+3A_db">db</code></td>
<td>
<p>the database where to search. It should be one among 'PSP', 'dbPTM','dbPAF', 'PhosPhAt', 'Phospho.ELM', 'all'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If db = 'all' has been selected, it may happen that the same residue appears in several rows if it is present in different databases.
</p>


<h3>Value</h3>

<p>Returns a dataframe where each row corresponds to a phosphorylatable residue.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Hornbeck et al. Nucleic Acids Res. 2019 47:D433-D441, (PMID: 30445427).
</p>
<p>Huang et al. Nucleic Acids Res. 2019 47:D298-D308, (PMID: 30418626).
</p>
<p>Ullah et al. Sci. Rep. 2016 6:23534, (PMID: 27010073).
</p>
<p>Durek et al. Nucleic Acids Res.2010 38:D828-D834, (PMID: 19880383).
</p>
<p>Dinkel et al. Nucleic Acids Res. 2011 39:D261-D567 (PMID: 21062810).
</p>


<h3>See Also</h3>

<p>meto.scan(), ac.scan(), me.scan(), ub.scan(), su.scan(), gl.scan(), sni.scan(), ni.scan(), ptm.scan(), reg.scan(), dis.scan()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: p.scan('P01009', db = 'PSP')
</code></pre>

<hr>
<h2 id='pairwise.dist'>Compute Euclidean Distances</h2><span id='topic+pairwise.dist'></span>

<h3>Description</h3>

<p>Computes the pairwise distance matrix between two sets of points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise.dist(a, b, squared = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise.dist_+3A_a">a</code>, <code id="pairwise.dist_+3A_b">b</code></td>
<td>
<p>matrices (NxD) and (MxD), respectively, where each row represents a D-dimensional point.</p>
</td></tr>
<tr><td><code id="pairwise.dist_+3A_squared">squared</code></td>
<td>
<p>return containing squared Euclidean distance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Euclidean distance matrix (NxM). An attribute &quot;squared&quot; set to the
value of param <code>squared</code> is provided.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pairwise.dist(matrix(1:9, ncol = 3), matrix(9:1, ncol = 3))
</code></pre>

<hr>
<h2 id='parse.dssp'>Parse a DSSP File to Return a Dataframe</h2><span id='topic+parse.dssp'></span>

<h3>Description</h3>

<p>Parses a DSSP file to return a dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse.dssp(file, keepfiles = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse.dssp_+3A_file">file</code></td>
<td>
<p>input dssp file.</p>
</td></tr>
<tr><td><code id="parse.dssp_+3A_keepfiles">keepfiles</code></td>
<td>
<p>logical, if TRUE the dataframe will be saved in the working directory and we will keep the dssp file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the argument 'keepfiles' is not set to TRUE, the dssp file used to get the parsed dataframe will be removed.
</p>


<h3>Value</h3>

<p>Returns a dataframe providing data for 'acc', 'ss', 'phi' and 'psi' for each residues from the structure.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Touw et al (2015) Nucl. Ac. Res. 43(Database issue): D364-D368 (PMID: 25352545).
</p>


<h3>See Also</h3>

<p>download.dssp(), compute.dssp(), mkdssp() and acc.dssp()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: compute.dssp('3cwm'); parse.dssp('3cwm.dssp')
</code></pre>

<hr>
<h2 id='pdb.chain'>Download and/or Split PDB Files.</h2><span id='topic+pdb.chain'></span>

<h3>Description</h3>

<p>Downloads a PDB file (if required) and splits it to provide a file by chain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdb.chain(pdb, keepfiles = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdb.chain_+3A_pdb">pdb</code></td>
<td>
<p>the path to the PDB of interest or a 4-letter identifier.</p>
</td></tr>
<tr><td><code id="pdb.chain_+3A_keepfiles">keepfiles</code></td>
<td>
<p>logical, if TRUE the function makes a 'temp' directory within the current directory and save in it a pdb file for each chain present in the given structure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a chr vector where each coordinate is a chain from the structure.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: pdb.chain('1bpl')
</code></pre>

<hr>
<h2 id='pdb.quaternary'>Protein Subunit Composition</h2><span id='topic+pdb.quaternary'></span>

<h3>Description</h3>

<p>Determines the subunit composition of a given protein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdb.quaternary(pdb, keepfiles = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdb.quaternary_+3A_pdb">pdb</code></td>
<td>
<p>the path to the PDB of interest or a 4-letter identifier.</p>
</td></tr>
<tr><td><code id="pdb.quaternary_+3A_keepfiles">keepfiles</code></td>
<td>
<p>logical, if TRUE the fasta file containing the alignment of the subunits is saved in the current directory, as well as the split pdb files.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A fasta file containing the alignment among the subunit sequences can be saved in the current directory if required.
</p>


<h3>Value</h3>

<p>This function returns a list with four elements: (i) a distances matrix, (ii) the sequences, (iii) chains id, (iv) the PDB ID used.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: pdb.quaternary('1bpl')
</code></pre>

<hr>
<h2 id='pdb.select'>Select the PDB with the Optimal Coverage to the UniProt Sequence</h2><span id='topic+pdb.select'></span>

<h3>Description</h3>

<p>Select the PDB and chain with the optimal coverage to a given UniProt sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdb.select(up_id, threshold = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdb.select_+3A_up_id">up_id</code></td>
<td>
<p>the UniProt ID.</p>
</td></tr>
<tr><td><code id="pdb.select_+3A_threshold">threshold</code></td>
<td>
<p>coverage value that when reached the search is halted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two elements: (i) the PDB ID and (ii) the chain. The coverage with the UniProt sequence is given as an attribute.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>See Also</h3>

<p>pdb.quaternary(), pdb.chain(), pdb.res(), pdb.pep(), uniprot2pdb(), pdb2uniprot()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: pdb.select('P01009', threshold = 0.8)
</code></pre>

<hr>
<h2 id='pdb.seq'>Get Chain Sequences</h2><span id='topic+pdb.seq'></span>

<h3>Description</h3>

<p>Gets the sequences of the chain find in a given PDB.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdb.seq(pdb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdb.seq_+3A_pdb">pdb</code></td>
<td>
<p>the 4-letter PDB identifier.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe with as many rows as different chains are present in the PDB. For each row six variables are returned: (i) the entry id, (ii) the entity id, (iii) the chain, (iv) the protein name, (v) the species and (vi) the sequence.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: pdb.seq('1bpl')
</code></pre>

<hr>
<h2 id='pdb.uniprot'>Identifier Mapping From PDB to UniProt</h2><span id='topic+pdb.uniprot'></span>

<h3>Description</h3>

<p>Mapping between PDB and UniProt protein identifiers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdb.uniprot(id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdb.uniprot_+3A_id">id</code></td>
<td>
<p>the identifier to be converted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character string corresponding to the requested identifier.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>See Also</h3>

<p>id.mapping()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: pdb.uniprot('3cwm')
</code></pre>

<hr>
<h2 id='pdb2uniprot'>Return the UniProt ID Given the PDB and Chain IDs</h2><span id='topic+pdb2uniprot'></span>

<h3>Description</h3>

<p>Returns the uniprot id of a given chain within a PDB structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdb2uniprot(pdb, chain)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdb2uniprot_+3A_pdb">pdb</code></td>
<td>
<p>the 4-letter PDB identifier.</p>
</td></tr>
<tr><td><code id="pdb2uniprot_+3A_chain">chain</code></td>
<td>
<p>letter identifying the chain.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the UniProt ID for the chain of interest.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>See Also</h3>

<p>uniprot2pdb(), id.mapping()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: pdb2uniprot('1u8f', 'O')
</code></pre>

<hr>
<h2 id='prot2codon'>Find the Coding Triplets for a Given Protein</h2><span id='topic+prot2codon'></span>

<h3>Description</h3>

<p>Finds the codons corresponding to a given protein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prot2codon(prot, chain = "", laxity = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prot2codon_+3A_prot">prot</code></td>
<td>
<p>is either a UniProt or PDB id, or the path to a pdb file.</p>
</td></tr>
<tr><td><code id="prot2codon_+3A_chain">chain</code></td>
<td>
<p>when prot corresponds to a pdb, the chain of interest must be provided.</p>
</td></tr>
<tr><td><code id="prot2codon_+3A_laxity">laxity</code></td>
<td>
<p>logical, if FALSE the program stop when a mismatch between the protein and the gene sequences is detected. Otherwise the program doesn't stop and at the end points out the mismatches.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe with as many rows as residues has the protein.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: prot2codon('P01009')
</code></pre>

<hr>
<h2 id='ptm.plot'>Plot Values of a Property and PTM Sites Along the Protein Sequence</h2><span id='topic+ptm.plot'></span>

<h3>Description</h3>

<p>Represents the values of a property and show the PTM sites along a protein sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptm.plot(up_id, pdb = "", property, ptm, window = 1, sdata = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ptm.plot_+3A_up_id">up_id</code></td>
<td>
<p>a character string for the UniProt ID of the protein of interest.</p>
</td></tr>
<tr><td><code id="ptm.plot_+3A_pdb">pdb</code></td>
<td>
<p>Optional argument to indicate the PDB and chain to be used (i.e. '1u8f.O'). If we leave this argument empty, the function will make the election for us whenever possible.</p>
</td></tr>
<tr><td><code id="ptm.plot_+3A_property">property</code></td>
<td>
<p>a character string indicating the property of interest. It should be one of 'sasa', 'acc', 'dpx', 'eiip', 'volume', 'polarizability', 'avg.hyd', 'pi.hel', 'a.hel', 'b.sheet', 'B.factor', or 'own'.</p>
</td></tr>
<tr><td><code id="ptm.plot_+3A_ptm">ptm</code></td>
<td>
<p>a character vector indicating the PTMs of interest. It should be among: 'ac' (acetylation), 'me' (methylation), 'meto' (sulfoxidation), 'p' (phosphorylation), 'ni' (nitration), 'su' (sumoylation) or 'ub' (ubiquitination), 'gl' (glycosylation), 'sni' (S-nitrosylation),'reg' (regulatory), 'dis' (disease).</p>
</td></tr>
<tr><td><code id="ptm.plot_+3A_window">window</code></td>
<td>
<p>positive integer indicating the window size for smoothing with a sliding window average (default: 1, i.e. no smoothing).</p>
</td></tr>
<tr><td><code id="ptm.plot_+3A_sdata">sdata</code></td>
<td>
<p>logical, if TRUE save a Rda file with the relevant data in the current directory.</p>
</td></tr>
<tr><td><code id="ptm.plot_+3A_...">...</code></td>
<td>
<p>when the user want to use his/her own amino acid index, it can be passed as a named vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the property 'own' is selected, a named vector with the own index for the 20 amino acids should be passed as argument.
Currently the supported properties are:
</p>

<ul>
<li><p>sasa:  Solvent-accessible surface area (3D)
</p>
</li>
<li><p>acc: Accessibility (3D)
</p>
</li>
<li><p>dpx: Depth (3D)
</p>
</li>
<li><p>volume: Normalized van der Waals volume (1D)
</p>
</li>
<li><p>mutability: Relative mutability, Jones 1992, (1D)
</p>
</li>
<li><p>helix: Average relative probability of helix, Kanehisa-Tsong 1980,(1D)
</p>
</li>
<li><p>beta-sheet: Average relative probability of beta-sheet, Kanehisa-Tsong 1980, (1D)
</p>
</li>
<li><p>pi-helix: Propensity of amino acids within pi-helices, Fodje-Al-Karadaghi 2002, (1D)
</p>
</li>
<li><p>hydropathy: Hydropathy index, Kyte-Doolittle 1982, (1D)
</p>
</li>
<li><p>avg.hyd: Normalized average hydrophobicity scales, Cid et al 1992, (1D)
</p>
</li>
<li><p>hplc: Retention coefficient in HPLC at pH7.4, Meek 1980, (1D)
</p>
</li>
<li><p>argos: Hydrophobicity index, Argos et al 1982, (1D)
</p>
</li>
<li><p>eiip: Electron-ion interaction potential, Veljkovic et al 1985, (1D)
</p>
</li>
<li><p>polarizability: Polarizability parameter, Charton-Charton 1982, (1D)
</p>
</li></ul>

<p>For 3D properties such as sasa, acc or dpx, for which different values can be obtained depending on the quaternary structure, we first compute the property values for each residue in the whole protein and plotted them against the residue position. Then, the value for this property is computed in the isolated chain (a single polypeptide chain) and in a second plot, the differences between the values in the whole protein and the chain are plotted against the residue position.
</p>


<h3>Value</h3>

<p>This function returns either one or two plots related to the chosen property along the primary structure, as well as the computed data if sdata has been set to TRUE.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>See Also</h3>

<p>find.aaindex()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ptm.plot('P04406', property = 'sasa', window = 10, ptm = 'meto')
## Not run: ptm.ptm('P04406', property = 'dpx', ptm = c('meto', 'p'))
</code></pre>

<hr>
<h2 id='ptm.scan'>Scan a Protein in Search of PTM Sites</h2><span id='topic+ptm.scan'></span>

<h3>Description</h3>

<p>Scans the indicated protein in search of PTM sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptm.scan(up_id, renumerate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ptm.scan_+3A_up_id">up_id</code></td>
<td>
<p>a character string corresponding to the UniProt ID.</p>
</td></tr>
<tr><td><code id="ptm.scan_+3A_renumerate">renumerate</code></td>
<td>
<p>logical, when TRUE the  sequence numeration of MetO sites is that given by Uniprot, which may not coincide with that from MetOSite.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The numerations of the sequences given by UniProt and MetOSite may or may not match. Sometimes one of the sequences corresponds to the precursor protein and the other to the processed mature protein.
</p>


<h3>Value</h3>

<p>Returns a dataframe where each row corresponds to a residue, and the columns inform about the modifications.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Hornbeck et al. Nucleic Acids Res. 2019 47:D433-D441, (PMID: 30445427).
</p>
<p>Huang et al. Nucleic Acids Res. 2019 47:D298-D308, (PMID: 30418626).
</p>
<p>Ullah et al. Sci. Rep. 2016 6:23534, (PMID: 27010073).
</p>
<p>Durek et al. Nucleic Acids Res.2010 38:D828-D834, (PMID: 19880383).
</p>
<p>Dinkel et al. Nucleic Acids Res. 2011 39:D261-D567 (PMID: 21062810).
</p>


<h3>See Also</h3>

<p>meto.scan(), ac.scan(), me.scan(), ub.scan(), su.scan(), gl.scan(), sni.scan(), ni.scan(), p.scan(), reg.scan(), dis.scan()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ptm.scan('P01009', renumerate = TRUE)
</code></pre>

<hr>
<h2 id='reg.scan'>Scan a Protein in Search of Regulatory PTM Sites</h2><span id='topic+reg.scan'></span>

<h3>Description</h3>

<p>Scans the indicated protein in search of regulatory PTM sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reg.scan(up_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reg.scan_+3A_up_id">up_id</code></td>
<td>
<p>a character string corresponding to the UniProt ID.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe where each row corresponds to a residue, and the columns inform about the regulatory modifications.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Hornbeck et al. Nucleic Acids Res. 2019 47:D433-D441, (PMID: 30445427).
</p>


<h3>See Also</h3>

<p>meto.scan(), ac.scan(), me.scan(), ub.scan(), su.scan(), gl.scan(), sni.scan(), ni.scan(), ptm.scan(), p.scan(), dis.scan()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: reg.scan('P01009')
</code></pre>

<hr>
<h2 id='renum'>Renumerate Residue Position</h2><span id='topic+renum'></span>

<h3>Description</h3>

<p>Renumerates residue position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renum(up_id, pos, from, to, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renum_+3A_up_id">up_id</code></td>
<td>
<p>the UniProt ID.</p>
</td></tr>
<tr><td><code id="renum_+3A_pos">pos</code></td>
<td>
<p>position in the initial sequence.</p>
</td></tr>
<tr><td><code id="renum_+3A_from">from</code></td>
<td>
<p>origin of the initial sequence, it should be one among 'uniprot', 'metosite' and 'pdb'.</p>
</td></tr>
<tr><td><code id="renum_+3A_to">to</code></td>
<td>
<p>target sequence, it should be one among 'uniprot', 'metosite' and 'pdb'.</p>
</td></tr>
<tr><td><code id="renum_+3A_...">...</code></td>
<td>
<p>additional arguments (PDB ID and chain) when 'pdb' is either origin or destination.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either the origin sequence or the target sequence should be uniprot. Nevertheless, the conversion pdb -&gt; metosite, for instance, can be achieved through the path: pdb -&gt; uniprot -&gt; metosite. If 'pdb' is selected, then the PDB ID and the involved chain must be provided, in that order.
</p>


<h3>Value</h3>

<p>Returns the final position.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>See Also</h3>

<p>is.at(), aa.at(), renum.pdb(), renum.meto(), aa.comp()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: renum(up_id = 'P01009', pos = 60, from = 'uniprot',
                         to = 'pdb', pdb = '1ATU', chain = 'A')
## End(Not run)
</code></pre>

<hr>
<h2 id='renum.meto'>Renumerate Residue Position</h2><span id='topic+renum.meto'></span>

<h3>Description</h3>

<p>Renumerates residue position of a MetOSite sequence to match the corresponding UniProt sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renum.meto(uniprot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renum.meto_+3A_uniprot">uniprot</code></td>
<td>
<p>the UniProt ID.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe containing the re-numerated sequence.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>See Also</h3>

<p>is.at(), aa.at(), renum.pdb(), renum(), aa.comp()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: renum.meto('P01009')
</code></pre>

<hr>
<h2 id='renum.pdb'>Renumerate Residue Position</h2><span id='topic+renum.pdb'></span>

<h3>Description</h3>

<p>Renumerates residue position of a PDB sequence to match the corresponding UniProt sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renum.pdb(pdb, chain, uniprot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renum.pdb_+3A_pdb">pdb</code></td>
<td>
<p>the PDB ID or the path to a pdb file.</p>
</td></tr>
<tr><td><code id="renum.pdb_+3A_chain">chain</code></td>
<td>
<p>the chain of interest.</p>
</td></tr>
<tr><td><code id="renum.pdb_+3A_uniprot">uniprot</code></td>
<td>
<p>the UniProt ID.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe containing the re-numerated sequence.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>See Also</h3>

<p>is.at(), aa.at(), renum.meto(), renum(), aa.compo()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: renum.pdb(pdb = '121P', chain = 'A', uniprot = 'P01112')
</code></pre>

<hr>
<h2 id='res.dpx'>Residue Depth Analysis</h2><span id='topic+res.dpx'></span>

<h3>Description</h3>

<p>Computes the depth from the surface for each protein's residue.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>res.dpx(pdb, aa = 'all')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="res.dpx_+3A_pdb">pdb</code></td>
<td>
<p>is either a PDB id, or the path to a pdb file.</p>
</td></tr>
<tr><td><code id="res.dpx_+3A_aa">aa</code></td>
<td>
<p>one letter code for the amino acid of interest, or 'all' for all the protein residues.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the depth, defined as the distance in angstroms between the residue and the closest atom on the protein surface.
</p>


<h3>Value</h3>

<p>A dataframe with the computed depths.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Pintar et al. 2003. Bioinformatics 19:313-314 (PMID: 12538266)
</p>


<h3>See Also</h3>

<p>atom.dpx(), acc.dssp(), str.part()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: res.dpx('1cll')
</code></pre>

<hr>
<h2 id='saro.dist'>Compute Distances to the Closest Aromatic Residues</h2><span id='topic+saro.dist'></span>

<h3>Description</h3>

<p>Computes distances to the closest aromatic residues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saro.dist(pdb, threshold = 7, rawdata = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saro.dist_+3A_pdb">pdb</code></td>
<td>
<p>either the path to the PDB file of interest or the 4-letters identifier.</p>
</td></tr>
<tr><td><code id="saro.dist_+3A_threshold">threshold</code></td>
<td>
<p>distance in ångströms, between the S atom and the aromatic ring centroid, used as threshold.</p>
</td></tr>
<tr><td><code id="saro.dist_+3A_rawdata">rawdata</code></td>
<td>
<p>logical to indicate whether we also want the raw distance matrix between delta S and aromatic ring centroids.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each methionyl residue this function computes the distances to the closest aromatic ring from Y, F and W. When that distance is equal or lower to the threshold, it will be computed as a S-aromatic motif.
</p>


<h3>Value</h3>

<p>The function returns a dataframe with as many rows as methionyl residues are found in the protein. The distances in ångströms to the closest tyrosine, phenylalanine and triptophan are given in the columns, as well as the number of S-aromatic motifs detected with each of these amino acids. Also a raw distance matrix can be provided.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Reid, Lindley &amp; Thornton, FEBS Lett. 1985, 190:209-213.
</p>


<h3>See Also</h3>

<p>saro.motif(), saro.geometry()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: saro.dist('1CLL')
</code></pre>

<hr>
<h2 id='saro.geometry'>Compute Geometric Parameters of S-Aromatic Motifs</h2><span id='topic+saro.geometry'></span>

<h3>Description</h3>

<p>Computes distances and angles of S-aromatic motifs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saro.geometry(pdb, rA, chainA = 'A', rB, chainB = 'A')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saro.geometry_+3A_pdb">pdb</code></td>
<td>
<p>either the path to the PDB file of interest or the 4-letters identifier.</p>
</td></tr>
<tr><td><code id="saro.geometry_+3A_ra">rA</code></td>
<td>
<p>numeric position of one of the two residues involved in the motif.</p>
</td></tr>
<tr><td><code id="saro.geometry_+3A_chaina">chainA</code></td>
<td>
<p>a character indicating the chain to which belong the first residue.</p>
</td></tr>
<tr><td><code id="saro.geometry_+3A_rb">rB</code></td>
<td>
<p>numeric position of the second residue involved in the motif.</p>
</td></tr>
<tr><td><code id="saro.geometry_+3A_chainb">chainB</code></td>
<td>
<p>a character indicating the chain to which belong the second residue.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distance between the delta sulfur atom and the centroid of the aromatic ring is computed, as well as the angle between this vector and the one perpendicular to the plane containing the aromatic ring. Based on the distance (d) and the angle (theta) the user decide whether the two residues are considered to be S-bonded or not (usually when d &lt; 7 and theta &lt; 60º).
</p>


<h3>Value</h3>

<p>The function returns a dataframe providing the coordinates of the sulfur atom and the centroid (centroids when the aromatic residue is tryptophan), as well as the distance (ångströms) and the angle (degrees) mentioned above.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Reid, Lindley &amp; Thornton, FEBS Lett. 1985, 190, 209-213.
</p>


<h3>See Also</h3>

<p>saro.motif(), saro.dist()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: saro.geometry('1CLL', rA = 141, rB = 145)
</code></pre>

<hr>
<h2 id='saro.motif'>Search for S-Aromatic Motifs</h2><span id='topic+saro.motif'></span>

<h3>Description</h3>

<p>Searches for S-aromatic motifs in proteins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saro.motif(pdb, threshold = 7, onlySaro = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saro.motif_+3A_pdb">pdb</code></td>
<td>
<p>either the path to the PDB file of interest or the 4-letters identifier.</p>
</td></tr>
<tr><td><code id="saro.motif_+3A_threshold">threshold</code></td>
<td>
<p>distance in ångströms, between the S atom and the aromatic ring centroid, used as threshold.</p>
</td></tr>
<tr><td><code id="saro.motif_+3A_onlysaro">onlySaro</code></td>
<td>
<p>logical, if FALSE the output includes information about Met residues that are not involved in S-aromatic motifs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each methionyl residue taking place in a S-aromatic motif, this function computes the aromatic residues involved, the distance between the delta sulfur and the aromatic ring's centroid, as well as the angle between the sulfur-aromatic vector and the normal vector of the plane containing the aromatic ring.
</p>


<h3>Value</h3>

<p>The function returns a dataframe reporting the S-aromatic motifs found for the protein of interest.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Reid, Lindley &amp; Thornton, FEBS Lett. 1985, 190, 209-213.
</p>


<h3>See Also</h3>

<p>saro.dist(), saro.geometry()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: saro.motif('1CLL')
</code></pre>

<hr>
<h2 id='search.go'>Search a Simple User Query</h2><span id='topic+search.go'></span>

<h3>Description</h3>

<p>Searches a simple user query.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search.go(query)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search.go_+3A_query">query</code></td>
<td>
<p>character string defining the query.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe containing the GO IDs found associated to the query, as well as other information related to these terms.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Rhee et al. (2008) Nature Reviews Genetics 9:509–515.
</p>


<h3>See Also</h3>

<p>term.go(), get.go(), bg.go(), hdfisher.go(), gorilla(), net.go()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: search.go('oxidative stress')
</code></pre>

<hr>
<h2 id='sni.scan'>Scan a Protein in Search of S-nitrosylation Sites</h2><span id='topic+sni.scan'></span>

<h3>Description</h3>

<p>Scans the indicated protein in search of S-nitrosylation sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sni.scan(up_id, db = 'all')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sni.scan_+3A_up_id">up_id</code></td>
<td>
<p>a character string corresponding to the UniProt ID.</p>
</td></tr>
<tr><td><code id="sni.scan_+3A_db">db</code></td>
<td>
<p>the database where to search. It should be one among 'PSP', 'dbPTM', 'all'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe where each row corresponds to a modifiable residue.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Huang et al. Nucleic Acids Res. 2019 47:D298-D308, (PMID: 30418626).
</p>


<h3>See Also</h3>

<p>meto.scan(), ac.scan(), me.scan(), ub.scan(), su.scan(), gl.scan(), p.scan(), ni.scan(), ptm.scan(), reg.scan(), dis.scan()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: sni.scan('P01009')
</code></pre>

<hr>
<h2 id='species.kegg'>Convert Between Species Name and KEGG 3-Letter Code Format</h2><span id='topic+species.kegg'></span>

<h3>Description</h3>

<p>Converts between species name and KEGG 3-letter code format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>species.kegg(organism, from = 'scientific')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="species.kegg_+3A_organism">organism</code></td>
<td>
<p>character string defining the organisms.</p>
</td></tr>
<tr><td><code id="species.kegg_+3A_from">from</code></td>
<td>
<p>string indicating the character of the provided name. It should be one of 'vulgar', 'scientific', '3-letter'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe with the entries matching the request.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>See Also</h3>

<p>id.features(), species.mapping()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: species.kegg('chempanzee', from = 'vulgar')
## Not run: species.kegg('Pan paniscus')
## Not run: species.kegg('ppo', from = '3-letter')
</code></pre>

<hr>
<h2 id='species.mapping'>Map Protein ID to Species</h2><span id='topic+species.mapping'></span>

<h3>Description</h3>

<p>Maps a protein ID to its corresponding organism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>species.mapping(id, db = 'uniprot')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="species.mapping_+3A_id">id</code></td>
<td>
<p>the identifier of the protein of interest.</p>
</td></tr>
<tr><td><code id="species.mapping_+3A_db">db</code></td>
<td>
<p>a character string specifying the corresponding database. Currently, only 'uniprot' or 'pdb' are valid options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character string identifying the organism to which the given protein belong.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>See Also</h3>

<p>id.features()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: species.mapping('P01009')
</code></pre>

<hr>
<h2 id='stru.part'>Partition of Structural Regions</h2><span id='topic+stru.part'></span>

<h3>Description</h3>

<p>Carries out a partition of the structural regions of a given protein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stru.part(pdb, cutoff = 0.25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stru.part_+3A_pdb">pdb</code></td>
<td>
<p>is either a PDB id, or the path to a pdb file</p>
</td></tr>
<tr><td><code id="stru.part_+3A_cutoff">cutoff</code></td>
<td>
<p>accessibility below which a residue is considered to be buried.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The accessibilities of a residue computed in the complex (ACCc) and in the monomer (ACCm) allow to distinguish four structural regions as follows.
</p>
<p>Interior: ACCc &lt; cutoff &amp; (ACCm - ACCc) = 0.
</p>
<p>Surface: ACCc &gt; cutoff &amp;  (ACCm - ACCc) = 0.
</p>
<p>Support: ACCm &lt; cutoff &amp; (ACCm - ACCc) &gt; 0.
</p>
<p>Rim: ACCc &gt; cutoff &amp; (ACCm - ACCc) &gt; 0.
</p>
<p>Core: ACCm &gt; cutoff &amp; ACCc &lt; cutoff.
</p>


<h3>Value</h3>

<p>A dataframe where each residue is assigned to one of the four structural groups considered.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Levy (2010) J. Mol. Biol. 403: 660-670 (PMID: 20868694).
</p>


<h3>See Also</h3>

<p>atom.dpx(), res.dpx(), acc.dssp()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: stru.part('1u8f')
</code></pre>

<hr>
<h2 id='su.scan'>Scan a Protein in Search of Sumoylation Sites</h2><span id='topic+su.scan'></span>

<h3>Description</h3>

<p>Scans the indicated protein in search of sumoylation sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>su.scan(up_id, db = 'all')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="su.scan_+3A_up_id">up_id</code></td>
<td>
<p>a character string corresponding to the UniProt ID.</p>
</td></tr>
<tr><td><code id="su.scan_+3A_db">db</code></td>
<td>
<p>the database where to search. It should be one among 'PSP', 'dbPTM', 'all'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If db = 'all' has been selected, it may happen that the same residue appears in several rows if it is present in different databases.
</p>


<h3>Value</h3>

<p>Returns a dataframe where each row corresponds to a modifiable residue.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Hornbeck et al. Nucleic Acids Res. 2019 47:D433-D441, (PMID: 30445427).
</p>
<p>Huang et al. Nucleic Acids Res. 2019 47:D298-D308, (PMID: 30418626).
</p>


<h3>See Also</h3>

<p>meto.scan(), ac.scan(), me.scan(), ub.scan(), p.scan(), gl.scan(), sni.scan(), ni.scan(), ptm.scan(), reg.scan(), dis.scan()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: su.scan('Q16695', db = 'PSP')
</code></pre>

<hr>
<h2 id='term.go'>Get Core Information About the GO Term</h2><span id='topic+term.go'></span>

<h3>Description</h3>

<p>Gets core information about the GO term of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>term.go(go, children = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="term.go_+3A_go">go</code></td>
<td>
<p>GO id.</p>
</td></tr>
<tr><td><code id="term.go_+3A_children">children</code></td>
<td>
<p>logical, when true GO children terms are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the argument children is set to TRUE, the output of this function is a list with two elements: the first one is a dataframe with the core information, and the second one is a dataframe containing the children terms.
</p>


<h3>Value</h3>

<p>Returns a dataframe containing core information such as term name and definition, reference, aspect, and whether or not the term is obsolete. If children is set to TRUE, the function returns a list.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Rhee et al. (2008) Nature Reviews Genetics 9:509–515.
</p>


<h3>See Also</h3>

<p>search.go(), get.go(), bg.go(), hdfisher.go(), gorilla(), net.go()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: term.go('GO:0034599')
</code></pre>

<hr>
<h2 id='ub.scan'>Scan a Protein in Search of Ubiquitination Sites</h2><span id='topic+ub.scan'></span>

<h3>Description</h3>

<p>Scans the indicated protein in search of ubiquitination sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ub.scan(up_id, db = 'all')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ub.scan_+3A_up_id">up_id</code></td>
<td>
<p>a character string corresponding to the UniProt ID.</p>
</td></tr>
<tr><td><code id="ub.scan_+3A_db">db</code></td>
<td>
<p>the database where to search. It should be one among 'PSP', 'dbPTM', 'all'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If db = 'all' has been selected, it may happen that the same residue appears in several rows if it is present in different databases.
</p>


<h3>Value</h3>

<p>Returns a dataframe where each row corresponds to a modifiable residue.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>References</h3>

<p>Hornbeck et al. Nucleic Acids Res. 2019 47:D433-D441, (PMID: 30445427).
</p>
<p>Huang et al. Nucleic Acids Res. 2019 47:D298-D308, (PMID: 30418626).
</p>


<h3>See Also</h3>

<p>meto.scan(), ac.scan(), me.scan(), p.scan(), su.scan(), gl.scan(), sni.scan(), ni.scan(), ptm.scan(), reg.scan(), dis.scan()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ub.scan('Q16695', db = 'PSP')
</code></pre>

<hr>
<h2 id='uniprot.kegg'>Identifier Mapping From UniProt to KEGG</h2><span id='topic+uniprot.kegg'></span>

<h3>Description</h3>

<p>Mapping between UniProt and KEGG protein identifiers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniprot.kegg(id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniprot.kegg_+3A_id">id</code></td>
<td>
<p>the identifier to be converted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character string corresponding to the requested identifier.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>See Also</h3>

<p>id.mapping()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: uniprot.kegg('P01009')
</code></pre>

<hr>
<h2 id='uniprot.pdb'>Identifier Mapping From UniProt to PDB</h2><span id='topic+uniprot.pdb'></span>

<h3>Description</h3>

<p>Mapping between UniProt and PDB protein identifiers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniprot.pdb(id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniprot.pdb_+3A_id">id</code></td>
<td>
<p>the identifier to be converted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character string corresponding to the requested identifier.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>See Also</h3>

<p>id.mapping()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: uniprot.pdb('P01009')
</code></pre>

<hr>
<h2 id='uniprot2pdb'>Return the PDB and Chain IDs of the Provided UniProt Protein</h2><span id='topic+uniprot2pdb'></span>

<h3>Description</h3>

<p>Returns the PDB and chain IDs of the provided protein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniprot2pdb(up_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniprot2pdb_+3A_up_id">up_id</code></td>
<td>
<p>the UniProt ID.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a dataframe with info about the PDB related to the protein of interest.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>See Also</h3>

<p>pdb2uniprot(), id.mapping()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: uniprot2pdb("P04406")
</code></pre>

<hr>
<h2 id='xprod'>Compute Cross Product</h2><span id='topic+xprod'></span>

<h3>Description</h3>

<p>Computes the  cross product of two vectors in three-dimensional euclidean space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xprod(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xprod_+3A_...">...</code></td>
<td>
<p>vectors involved in the cross product.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each methionyl residue taking place in a S-aromatic motif, this function computes the aromatic residue involved, the distance between the delta sulfur and the aromatic ring's centroid, as well as the angle between the sulfur-aromatic vector and the normal vector of the plane containing the aromatic ring.
</p>


<h3>Value</h3>

<p>This function returns a vector that is orthogonal to the plane containing the two vector used as arguments.
</p>


<h3>Author(s)</h3>

<p>Juan Carlos Aledo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xprod(c(1,1,1), c(1,2,1))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
