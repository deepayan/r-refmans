<!DOCTYPE html><html><head><title>Help for package quarks</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {quarks}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cvgtest'><p>Unconditional and Conditional Coverage Tests, Independence Test</p></a></li>
<li><a href='#DAX'><p>German Stock Market Index (DAX) Financial Time Series Data</p></a></li>
<li><a href='#DJI'><p>Dow Jones Industrial Average (DJI) Financial Time Series Data</p></a></li>
<li><a href='#ewma'><p>Exponentially weighted moving average</p></a></li>
<li><a href='#fhs'><p>Filtered historical simulation</p></a></li>
<li><a href='#FTSE100'><p>Financial Times Stock Exchange Index (FTSE) Financial Time Series Data</p></a></li>
<li><a href='#hs'><p>Nonparametric calculation of univariate Value at Risk and Expected Shortfall</p></a></li>
<li><a href='#HSI'><p>Hang Seng Index (HSI) Financial Time Series Data</p></a></li>
<li><a href='#lossfun'><p>Loss Functions</p></a></li>
<li><a href='#NIK225'><p>Nikkei Heikin Kabuka Index (NIK) Financial Time Series Data</p></a></li>
<li><a href='#plop'><p>Profit &amp; Loss operator function</p></a></li>
<li><a href='#plot.quarks'><p>Plot Method for the Package 'quarks'</p></a></li>
<li><a href='#print.quarks'><p>Print Method for the Package 'quarks'</p></a></li>
<li><a href='#rollcast'><p>Rolling one-step ahead forecasts of Value at Risk and Expected Shortfall</p></a></li>
<li><a href='#runFTSdata'><p>Application for downloading data from Yahoo Finance</p></a></li>
<li><a href='#SP500'><p>Standard and Poor's (SP500) Financial Time Series Data</p></a></li>
<li><a href='#trftest'><p>Backtesting of Value-at-Risk via Traffic Light Test</p></a></li>
<li><a href='#vwhs'><p>Volatility weighted historical simulation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simple Methods for Calculating and Backtesting Value at Risk and
Expected Shortfall</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Enables the user to calculate Value at Risk (VaR)
    and Expected Shortfall (ES) by means of various types of historical
    simulation. Currently plain-, age-, volatility-weighted- and filtered
    historical simulation are implemented in this package. Volatility weighting
    can be carried out via an exponentially weighted moving average model
    (EWMA) or other GARCH-type models. The performance can be assessed via
    Traffic Light Test, Coverage Tests and Loss Functions. The methods of the
    package are described in Gurrola-Perez, P. and Murphy, D. (2015)
    <a href="https://EconPapers.repec.org/RePEc:boe:boeewp:0525">https://EconPapers.repec.org/RePEc:boe:boeewp:0525</a> as well as McNeil, J.,
    Frey, R., and Embrechts, P. (2015) <a href="https://ideas.repec.org/b/pup/pbooks/10496.html">https://ideas.repec.org/b/pup/pbooks/10496.html</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dygraphs, ggplot2, graphics, progress, rugarch, shiny,
shinyjs, smoots, stats, yfR, xts</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-08 08:54:09 UTC; Letmode</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastian Letmathe [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastian Letmathe &lt;sebastian.let@t-online.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-08 21:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cvgtest'>Unconditional and Conditional Coverage Tests, Independence Test</h2><span id='topic+cvgtest'></span>

<h3>Description</h3>

<p>The conditional (Kupiec, 1995), the unconditional coverage
test (Christoffersen, 1998) and the independence test (Christoffersen, 1998)
of the Value-at-Risk (VaR) are applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvgtest(obj = list(loss = NULL, VaR = NULL, p = NULL), conflvl = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cvgtest_+3A_obj">obj</code></td>
<td>
<p>a list that contains the following elements:
</p>

<dl>
<dt><code>loss</code></dt><dd><p>a numeric vector that contains the values of a loss series
ordered from past to present; is set to <code>NULL</code> by default.</p>
</dd>
<dt><code>VaR</code></dt><dd><p>a numeric vector that contains the estimated values of the
VaR for the same time points of the loss series <code>loss</code>;
is set to <code>NULL</code> by default.</p>
</dd>
<dt><code>p</code></dt><dd><p>a numeric vector with one element; defines the probability p
stated in the null hypotheses of the coverage tests (see the section
<code>Details</code> for more information); is set to <code>NULL</code> by default.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="cvgtest_+3A_conflvl">conflvl</code></td>
<td>
<p>a numeric vector with one element; the significance
level at which the null hypotheses are evaluated; is set to <code>0.95</code> by
default.
Please note that a list returned by the <code>rollcast</code> function can be directly
passed to <code>cvgtest</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With this function, the conditional and the unconditional coverage
tests introduced by Kupiec (1995) and Christoffersen (1998) can be applied.
Given a return series <code class="reqn">r_t</code> with <code class="reqn">n</code> observations, divide the
series into <code class="reqn">n-K</code> in-sample and <code class="reqn">K</code> out-of-sample observations,
fit a model to the in-sample data and obtain rolling one-step forecasts of
the VaR for the out-of-sample time points.
</p>
<p>Define
</p>
<p style="text-align: center;"><code class="reqn">I_t = 1,</code>
</p>

<p>if <code class="reqn">-r_t &gt; \widehat{VaR}_t (\alpha)</code> or
</p>
<p style="text-align: center;"><code class="reqn">I_t = 0,</code>
</p>
<p> otherwise,
</p>
<p>for <code class="reqn">t = n + 1, n + 2, ..., n + K</code> as the hit sequence, where <code class="reqn">\alpha</code> is
the confidence level for the VaR (often <code class="reqn">\alpha = 0.95</code> or <code class="reqn">\alpha = 0.99</code>).
Furthermore, denote <code class="reqn">p = \alpha</code> and let <code class="reqn">w</code> be the actual covered
proportion of losses in the data.
</p>
<p>1. Unconditional coverage test:
</p>
<p style="text-align: center;"><code class="reqn">H_{0, uc}: p = w</code>
</p>

<p>Let <code class="reqn">K_1</code> be the number of ones in <code class="reqn">I_t</code> and analogously <code class="reqn">K_0</code> the number of
zeros (all conditional on the first observation).
Also calculate <code class="reqn">\hat{w} = K_0 / (K - 1)</code>. Obtain
</p>
<p style="text-align: center;"><code class="reqn">L(I_t, p) = p^{K_0}(1 - p)^{K_1}</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">L(I_t, \hat{w}) = \hat{w}^{K_0}(1 - \hat{w})^{K_1}</code>
</p>

<p>and subsequently the test statistic
</p>
<p style="text-align: center;"><code class="reqn">LR_{uc} = -2  * \ln \{L(I_t, p) / L(I_t, \hat{w})\}.</code>
</p>

<p><code class="reqn">LR_{uc}</code> now asymptotically follows a chi-square-distribution with one degree
of freedom.
</p>
<p>2. Conditional coverage test:
</p>
<p>The conditional coverage test combines the unconditional coverage test
with a test on independence. Denote by <code class="reqn">w_{ij}</code> the probability of an <code class="reqn">i</code> on day
<code class="reqn">t-1</code> being followed by a <code class="reqn">j</code> on day <code class="reqn">t</code>, where <code class="reqn">i</code> and <code class="reqn">j</code> correspond to the value of
<code class="reqn">I_t</code> on the respective day.
</p>
<p style="text-align: center;"><code class="reqn">H_{0, cc}: w_{00} = w{10} = p</code>
</p>

<p>with <code class="reqn">i = 0, 1</code> and <code class="reqn">j = 0, 1</code>.
</p>
<p>Let <code class="reqn">K_{ij}</code> be the number of observations, where the values on two following days
follow the pattern <code class="reqn">ij</code>. Calculate
</p>
<p style="text-align: center;"><code class="reqn">L(I_t, \hat{w}_{00}, \hat{w}_{10})
= \hat{w}_{00}^{K_{00}}(1 - \hat{w}_{00})^{K_{01}} * \hat{w}_{10})^{K_{10}}(1 - \hat{w}_{10})^{K_{11}},</code>
</p>

<p>where <code class="reqn">\hat{w}_{00} = K_{00} / K_0</code> and <code class="reqn">\hat{w}_{10} = K_{10} / K_1</code>. The test
statistic is then given by
</p>
<p style="text-align: center;"><code class="reqn">LR_{cc} = -2  * \ln \{ L(I_t, p) / L(I_t, \hat{w}_{00}, \hat{w}_{10}) \},</code>
</p>

<p>which asymptotically follows a chi-square-distribution with two degrees of
freedom.
</p>
<p>3. Independence test:
</p>
<p style="text-align: center;"><code class="reqn">H_{0,ind}: w_{00} = w_{10}</code>
</p>

<p>The asymptotically chi-square-distributed test statistic (one degree of
freedom) is given by
</p>
<p style="text-align: center;"><code class="reqn">LR_{ind} = -2  * \ln \{L(I_t, \hat{w}_{00}, \hat{w}_{10}) / L(I_t, \hat{w})\}.</code>
</p>

<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
</p>
<p>The function needs four inputs: the out-of-sample loss series <code>obj$loss</code>, the
corresponding estimated VaR series <code>obj$VaR</code>, the coverage level <code>obj$p</code>,
for which the VaR has been calculated and the significance level <code>conflvl</code>,
at which the null hypotheses are evaluated. If an object returned by this
function is entered into the R console, a detailed overview of the test results
is printed.
</p>


<h3>Value</h3>

<p>A list of class <code>quarks</code> with the following four elements:
</p>

<dl>
<dt>p</dt><dd><p>probability p stated in the null hypotheses of the coverage tests</p>
</dd>
<dt>p.uc</dt><dd><p>the p-value of the unconditional coverage test</p>
</dd>
<dt>p.cc</dt><dd><p>the p-value of the conditional coverage test</p>
</dd>
<dt>p.ind</dt><dd><p>the p-value of the independence test</p>
</dd>
<dt>conflvl</dt><dd><p>the significance level at which the null hypotheses are
evaluated</p>
</dd>
<dt>model</dt><dd><p>selected model for estimation; only available if a list
returned by the <code>rollcast</code> function is passed to <code>cvgtest</code></p>
</dd>
<dt>method</dt><dd><p>selected method for estimation; only available if a list
returned by the <code>rollcast</code>) function is passed to <code>cvgtest</code></p>
</dd>
</dl>



<h3>References</h3>

<p>Christoffersen, P. F. (1998). Evaluating interval forecasts. International
economic review, pp. 841-862.
</p>
<p>Kupiec, P. (1995). Techniques for verifying the accuracy of risk measurement
models. The J. of Derivatives, 3(2).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
prices &lt;- DAX$price_close
returns &lt;- diff(log(prices))
n &lt;- length(returns)
nout &lt;- 250 # number of obs. for out-of-sample forecasting
nwin &lt;- 500 # window size for rolling forecasts
results &lt;- rollcast(x = returns, p = 0.975, method = 'age', nout = nout,
                     nwin = nwin)
cvgtest(results)

</code></pre>

<hr>
<h2 id='DAX'>German Stock Market Index (DAX) Financial Time Series Data</h2><span id='topic+DAX'></span>

<h3>Description</h3>

<p>A dataset that contains the daily financial data of the DAX from
2000 to December 2023 (currency in EUR).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DAX
</code></pre>


<h3>Format</h3>

<p>A data frame with 6094 rows and 11 variables:
</p>

<dl>
<dt>ticker</dt><dd><p>id of the stock</p>
</dd>
<dt>ref_date</dt><dd><p>date in format YY-MM-DD</p>
</dd>
<dt>price_open</dt><dd><p>opening price (daily)</p>
</dd>
<dt>price_high</dt><dd><p>highest price (daily)</p>
</dd>
<dt>price_low</dt><dd><p>lowest price (daily)</p>
</dd>
<dt>price_close</dt><dd><p>closing price (daily)</p>
</dd>
<dt>volume</dt><dd><p>trading volume</p>
</dd>
<dt>price_adjusted</dt><dd><p>adjusted closing price (daily)</p>
</dd>
<dt>ret_adjusted_prices</dt><dd><p>returns obtained from the adj. closing prices</p>
</dd>
<dt>ret_closing_prices</dt><dd><p>returns obtained from the closing prices</p>
</dd>
<dt>cumret_adjusted_prices</dt><dd><p>accumulated arithmetic/log return for the period</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data was obtained from Yahoo Finance.
</p>

<hr>
<h2 id='DJI'>Dow Jones Industrial Average (DJI) Financial Time Series Data</h2><span id='topic+DJI'></span>

<h3>Description</h3>

<p>A dataset that contains the daily financial data of the DJI from
2000 to December 2023 (currency in USD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DJI
</code></pre>


<h3>Format</h3>

<p>A data frame with 6037 rows and 11 variables:
</p>

<dl>
<dt>ticker</dt><dd><p>id of the stock</p>
</dd>
<dt>ref_date</dt><dd><p>date in format YY-MM-DD</p>
</dd>
<dt>price_open</dt><dd><p>opening price (daily)</p>
</dd>
<dt>price_high</dt><dd><p>highest price (daily)</p>
</dd>
<dt>price_low</dt><dd><p>lowest price (daily)</p>
</dd>
<dt>price_close</dt><dd><p>closing price (daily)</p>
</dd>
<dt>volume</dt><dd><p>trading volume</p>
</dd>
<dt>price_adjusted</dt><dd><p>adjusted closing price (daily)</p>
</dd>
<dt>ret_adjusted_prices</dt><dd><p>returns obtained from the adj. closing prices</p>
</dd>
<dt>ret_closing_prices</dt><dd><p>returns obtained from the closing prices</p>
</dd>
<dt>cumret_adjusted_prices</dt><dd><p>accumulated arithmetic/log return for the period</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data was obtained from Yahoo Finance.
</p>

<hr>
<h2 id='ewma'>Exponentially weighted moving average</h2><span id='topic+ewma'></span>

<h3>Description</h3>

<p>Estimates volatility of a return series by means of an exponentially
weighted moving average.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ewma(x, lambda = 0.94)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ewma_+3A_x">x</code></td>
<td>
<p>a numeric vector of asset returns</p>
</td></tr>
<tr><td><code id="ewma_+3A_lambda">lambda</code></td>
<td>
<p>decay factor for the calculation of weights; default is <code>0.94</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numerical vector <code>vol</code> that contains the computed
volatility.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prices &lt;- DAX$price_close
returns &lt;- diff(log(prices))
date &lt;- DAX$ref_date[-1]
cvar &lt;- ewma(x = returns, lambda = 0.94)
csig &lt;- sqrt(cvar)
plot(date, csig, type = 'l',
     main = 'conditional standard deviations for the DAX30 return series')
</code></pre>

<hr>
<h2 id='fhs'>Filtered historical simulation</h2><span id='topic+fhs'></span>

<h3>Description</h3>

<p>Calculates univariate Value at Risk and Expected Shortfall (Conditional
Value at Risk) by means of filtered historical simulation.
Volatility can be estimated with an exponentially weighted moving
average or a GARCH-type model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fhs(x, p = 0.975, model = c("EWMA", "GARCH"), lambda = 0.94, nboot = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fhs_+3A_x">x</code></td>
<td>
<p>a numeric vector of asset returns</p>
</td></tr>
<tr><td><code id="fhs_+3A_p">p</code></td>
<td>
<p>confidence level for VaR calculation; default is <code>0.975</code></p>
</td></tr>
<tr><td><code id="fhs_+3A_model">model</code></td>
<td>
<p>model for estimating conditional volatility; options are <code>'EWMA'</code>
and <code>'GARCH'</code>; if <code>model = 'GARCH'</code>, additional arguments can be adjusted
via <code>...</code>; default is <code>'EWMA'</code></p>
</td></tr>
<tr><td><code id="fhs_+3A_lambda">lambda</code></td>
<td>
<p>decay factor for the calculation of weights; default is <code>0.94</code></p>
</td></tr>
<tr><td><code id="fhs_+3A_nboot">nboot</code></td>
<td>
<p>size of bootstrap sample; must be a single non-NA integer value
with <code>nboot &gt; 0</code>; default is <code>NULL</code></p>
</td></tr>
<tr><td><code id="fhs_+3A_...">...</code></td>
<td>
<p>additional arguments of the <code>ugarchspec</code> function from the
<code>rugarch</code>-package; only applied if <code>model = 'GARCH'</code>; default
settings for the arguments <code>variance.model</code> and <code>mean.model</code> are:
</p>

<dl>
<dt><code>variance.model</code> = <code>list(model = 'sGARCH', garchOrder = c(1, 1))</code></dt><dd></dd>
<dt><code>mean.model</code> = <code>list(armaOrder = c(0, 0))</code></dt><dd></dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following elements:
</p>

<dl>
<dt>VaR</dt><dd><p>Calculated Value at Risk</p>
</dd>
<dt>ES</dt><dd><p>Calculated Expected Shortfall (Conditional Value at Risk)</p>
</dd>
<dt>p</dt><dd><p>Confidence level for VaR calculation</p>
</dd>
<dt>garchmod</dt><dd><p>The model fit. Is the respective GARCH fit for
<code>model = "GARCH"</code> (see <code>rugarch</code> documentation) and  <code>'EWMA'</code> for
<code>model = "EWMA"</code></p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>prices &lt;- DAX$price_close
returns &lt;- diff(log(prices))
# volatility weighting via EWMA
ewma &lt;- fhs(x = returns, p = 0.975, model = "EWMA", lambda = 0.94,
            nboot = 10000)
ewma
# volatility weighting via GARCH
garch &lt;- fhs(x = returns, p = 0.975, model = "GARCH", variance.model =
list(model = "sGARCH"), nboot = 10000)
garch
</code></pre>

<hr>
<h2 id='FTSE100'>Financial Times Stock Exchange Index (FTSE) Financial Time Series Data</h2><span id='topic+FTSE100'></span>

<h3>Description</h3>

<p>A dataset that contains the daily financial data of the FTSE from
2000 to December 2023 (currency in EUR).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FTSE100
</code></pre>


<h3>Format</h3>

<p>A data frame with 6060 rows and 11 variables:
</p>

<dl>
<dt>ticker</dt><dd><p>id of the stock</p>
</dd>
<dt>ref_date</dt><dd><p>date in format YY-MM-DD</p>
</dd>
<dt>price_open</dt><dd><p>opening price (daily)</p>
</dd>
<dt>price_high</dt><dd><p>highest price (daily)</p>
</dd>
<dt>price_low</dt><dd><p>lowest price (daily)</p>
</dd>
<dt>price_close</dt><dd><p>closing price (daily)</p>
</dd>
<dt>volume</dt><dd><p>trading volume</p>
</dd>
<dt>price_adjusted</dt><dd><p>adjusted closing price (daily)</p>
</dd>
<dt>ret_adjusted_prices</dt><dd><p>returns obtained from the adj. closing prices</p>
</dd>
<dt>ret_closing_prices</dt><dd><p>returns obtained from the closing prices</p>
</dd>
<dt>cumret_adjusted_prices</dt><dd><p>accumulated arithmetic/log return for the period</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data was obtained from Yahoo Finance.
</p>

<hr>
<h2 id='hs'>Nonparametric calculation of univariate Value at Risk and Expected Shortfall</h2><span id='topic+hs'></span>

<h3>Description</h3>

<p>Computes Value at Risk and Expected Shortfall (Conditional Value
at Risk) by means of plain and age-weighted historical simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hs(x, p = 0.975, method = c("age", "plain"), lambda = 0.98)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hs_+3A_x">x</code></td>
<td>
<p>a numeric vector of asset returns</p>
</td></tr>
<tr><td><code id="hs_+3A_p">p</code></td>
<td>
<p>confidence level for VaR calculation; default is <code>0.975</code></p>
</td></tr>
<tr><td><code id="hs_+3A_method">method</code></td>
<td>
<p>method to be used for calculation; default is <code>'plain'</code></p>
</td></tr>
<tr><td><code id="hs_+3A_lambda">lambda</code></td>
<td>
<p>decay factor for the calculation of weights; default is <code>0.98</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following elements:
</p>

<dl>
<dt>VaR</dt><dd><p>Calculated Value at Risk</p>
</dd>
<dt>ES</dt><dd><p>Calculated Expected Shortfall (Conditional Value at Risk)</p>
</dd>
<dt>p</dt><dd><p>Confidence level for VaR calculation</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>prices &lt;- DAX$price_close
returns &lt;- diff(log(prices))
hs(x = returns, p = 0.975, method = 'plain')
hs(x = returns, p = 0.975, method = 'age', lambda = 0.98)
</code></pre>

<hr>
<h2 id='HSI'>Hang Seng Index (HSI) Financial Time Series Data</h2><span id='topic+HSI'></span>

<h3>Description</h3>

<p>A dataset that contains the daily financial data of the HSI from
2000 to December 2023.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HSI
</code></pre>


<h3>Format</h3>

<p>A data frame with 5914 rows and 11 variables:
</p>

<dl>
<dt>ticker</dt><dd><p>id of the stock</p>
</dd>
<dt>ref_date</dt><dd><p>date in format YY-MM-DD</p>
</dd>
<dt>price_open</dt><dd><p>opening price (daily)</p>
</dd>
<dt>price_high</dt><dd><p>highest price (daily)</p>
</dd>
<dt>price_low</dt><dd><p>lowest price (daily)</p>
</dd>
<dt>price_close</dt><dd><p>closing price (daily)</p>
</dd>
<dt>volume</dt><dd><p>trading volume</p>
</dd>
<dt>price_adjusted</dt><dd><p>adjusted closing price (daily)</p>
</dd>
<dt>ret_adjusted_prices</dt><dd><p>returns obtained from the adj. closing prices</p>
</dd>
<dt>ret_closing_prices</dt><dd><p>returns obtained from the closing prices</p>
</dd>
<dt>cumret_adjusted_prices</dt><dd><p>accumulated arithmetic/log return for the period</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data was obtained from Yahoo Finance.
</p>

<hr>
<h2 id='lossfun'>Loss Functions</h2><span id='topic+lossfun'></span>

<h3>Description</h3>

<p>This functions allows for the calculation of loss functions in order to assess
the performance of models in regard to forecasting ES.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lossfun(obj = list(loss = NULL, ES = NULL), beta = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lossfun_+3A_obj">obj</code></td>
<td>
<p>a list that contains the following elements:
</p>

<dl>
<dt><code>loss</code></dt><dd><p>a numeric vector that contains the values of a loss series
ordered from past to present; is set to <code>NULL</code> by default</p>
</dd>
<dt><code>ES</code></dt><dd><p>a numeric vector that contains the estimated values of the
ES for the same time points of the loss series <code>loss</code>; is set to
<code>NULL</code> by default</p>
</dd>
</dl>

<p>Please note that a list returned by the <code>rollcast</code> function can be directly
passed to <code>lossfun</code>.</p>
</td></tr>
<tr><td><code id="lossfun_+3A_beta">beta</code></td>
<td>
<p>a single numeric value; a measure for the opportunity cost of
capital; default is <code>1e-04</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a negative return series <code>obj$loss</code>, the corresponding Expected
Shortfall (ES) estimates <code>obj$ES</code> and a parameter <code>beta</code> that
defines the opportunity cost of capital, four different definitions of loss
functions are considered.
</p>


<h3>Value</h3>

<p>an S3 class object, which is a list of
</p>

<dl>
<dt>loss.fun1</dt><dd><p>regulatory loss function</p>
</dd>
<dt>loss.fun2</dt><dd><p>firm's loss function following Sarma et al. (2003)</p>
</dd>
<dt>loss.fun3</dt><dd><p>loss function following Abad et al. (2015)</p>
</dd>
<dt>loss.fun4</dt><dd><p>Feng's loss function; a compromise of regulatory and
firm's loss function</p>
</dd>
</dl>



<h3>References</h3>

<p>Abad, P., Muela, S. B., &amp; Mart√≠n, C. L. (2015). The role of the loss function
in value-at-risk comparisons. The Journal of Risk Model Validation, 9(1), 1-19.
</p>
<p>Sarma, M., Thomas, S., &amp; Shah, A. (2003). Selection of Value-at-Risk models.
Journal of Forecasting, 22(4), 337-358.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
prices &lt;- DAX$price_close
returns &lt;- diff(log(prices))
n &lt;- length(returns)
nout &lt;- 250 # number of obs. for out-of-sample forecasting
nwin &lt;- 500 # window size for rolling forecasts
results &lt;- rollcast(x = returns, p = 0.975, method = 'age', nout = nout,
                     nwin = nwin)
loss &lt;- -results$xout
ES &lt;- results$ES
loss.data &lt;- list(loss = loss, ES = ES)
lossfun(loss.data)

# directly passing the output object of 'rollcast()' to 'lossfun()'
lossfun(results)

</code></pre>

<hr>
<h2 id='NIK225'>Nikkei Heikin Kabuka Index (NIK) Financial Time Series Data</h2><span id='topic+NIK225'></span>

<h3>Description</h3>

<p>A dataset that contains the daily financial data of the NIK from
2000 to December 2023.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NIK225
</code></pre>


<h3>Format</h3>

<p>A data frame with 5881 rows and 11 variables:
</p>

<dl>
<dt>ticker</dt><dd><p>id of the stock</p>
</dd>
<dt>ref_date</dt><dd><p>date in format YY-MM-DD</p>
</dd>
<dt>price_open</dt><dd><p>opening price (daily)</p>
</dd>
<dt>price_high</dt><dd><p>highest price (daily)</p>
</dd>
<dt>price_low</dt><dd><p>lowest price (daily)</p>
</dd>
<dt>price_close</dt><dd><p>closing price (daily)</p>
</dd>
<dt>volume</dt><dd><p>trading volume</p>
</dd>
<dt>price_adjusted</dt><dd><p>adjusted closing price (daily)</p>
</dd>
<dt>ret_adjusted_prices</dt><dd><p>returns obtained from the adj. closing prices</p>
</dd>
<dt>ret_closing_prices</dt><dd><p>returns obtained from the closing prices</p>
</dd>
<dt>cumret_adjusted_prices</dt><dd><p>accumulated arithmetic/log return for the period</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data was obtained from Yahoo Finance.
</p>

<hr>
<h2 id='plop'>Profit &amp; Loss operator function</h2><span id='topic+plop'></span>

<h3>Description</h3>

<p>Calculates portfolio returns or losses by assigning weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plop(x, wts = NULL, approxim = c(0, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plop_+3A_x">x</code></td>
<td>
<p>a numeric matrix of asset returns or losses</p>
</td></tr>
<tr><td><code id="plop_+3A_wts">wts</code></td>
<td>
<p>a numeric vector or matrix containing the portfolio
weights; portfolio value is standardized to 1 on any observation unit;
sum of weights should not exceed 1 (row-wise for matrices); by default
the portfolio is equally weighted over time and across all assets; if a
vector is passed to <code>wts</code> the portfolio is equally weighted over time</p>
</td></tr>
<tr><td><code id="plop_+3A_approxim">approxim</code></td>
<td>
<p>controls if a first-order approximation for the calculation
of returns or losses is used; default is <code>1</code> (first-order
approximation is employed)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following elements:
</p>

<dl>
<dt>pl</dt><dd><p>Weighted portfolio returns or losses</p>
</dd>
<dt>wts</dt><dd><p>Portfolio weights</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># creating portfolio
portfol &lt;- cbind(SP500$price_close, DJI$price_close)
returns &lt;- apply(portfol, 2, function(x) diff(log(x)))
# defining weights and applying the P&amp;L operator function
wts &lt;- c(0.4, 0.6)
portret &lt;- plop(returns, wts = wts, approxim = 1)
portloss &lt;- plop(-returns, wts = wts, approxim = 1)
plot.ts(cbind(portret$pl, portloss$pl))

</code></pre>

<hr>
<h2 id='plot.quarks'>Plot Method for the Package 'quarks'</h2><span id='topic+plot.quarks'></span>

<h3>Description</h3>

<p>This function regulates how objects created by the package quarks are
plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'quarks'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.quarks_+3A_x">x</code></td>
<td>
<p>an input object of class <code>quarks</code>.</p>
</td></tr>
<tr><td><code id="plot.quarks_+3A_...">...</code></td>
<td>
<p>additional arguments of the standard plot method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='print.quarks'>Print Method for the Package 'quarks'</h2><span id='topic+print.quarks'></span>

<h3>Description</h3>

<p>This function regulates how objects created by the package <code>quarks</code> are
printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'quarks'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.quarks_+3A_x">x</code></td>
<td>
<p>an input object of class <code>quarks</code>.</p>
</td></tr>
<tr><td><code id="print.quarks_+3A_...">...</code></td>
<td>
<p>included for compatibility; additional arguments will however
not affect the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='rollcast'>Rolling one-step ahead forecasts of Value at Risk and Expected Shortfall</h2><span id='topic+rollcast'></span>

<h3>Description</h3>

<p>Computes rolling one-step ahead forecasts of Value at Risk and Expected
Shortfall (Conditional Value at Risk) by means of plain historical
simulation age- and volatility-weighted historical simulation as well as
filtered historical simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rollcast(
  x,
  p = 0.975,
  model = c("EWMA", "GARCH"),
  method = c("plain", "age", "vwhs", "fhs"),
  lambda = c(0.94, 0.98),
  nout = NULL,
  nwin = NULL,
  nboot = NULL,
  smoothscale = c("none", "lpr", "auto"),
  smoothopts = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rollcast_+3A_x">x</code></td>
<td>
<p>a numeric vector of asset returns</p>
</td></tr>
<tr><td><code id="rollcast_+3A_p">p</code></td>
<td>
<p>confidence level for VaR calculation; default is <code>0.975</code></p>
</td></tr>
<tr><td><code id="rollcast_+3A_model">model</code></td>
<td>
<p>model for estimating conditional volatility; options are <code>'EWMA'</code>
and <code>'GARCH'</code>; if <code>model = 'GARCH'</code>, additional arguments can be adjusted
via <code>...</code>; default is <code>'EWMA'</code></p>
</td></tr>
<tr><td><code id="rollcast_+3A_method">method</code></td>
<td>
<p>method to be used for calculation; default is <code>'plain'</code></p>
</td></tr>
<tr><td><code id="rollcast_+3A_lambda">lambda</code></td>
<td>
<p>decay factor for the calculation of weights; default is <code>0.98</code>
for <code>method = 'age'</code> and <code>0.94</code> for <code>method = 'vwhs'</code> or
<code>method = 'fhs'</code></p>
</td></tr>
<tr><td><code id="rollcast_+3A_nout">nout</code></td>
<td>
<p>number of out-of-sample observations; most recent observations are used;
default is <code>NULL</code></p>
</td></tr>
<tr><td><code id="rollcast_+3A_nwin">nwin</code></td>
<td>
<p>window size for rolling one-step forecasting; most recent observations
before out-of-sample are used; default is <code>NULL</code></p>
</td></tr>
<tr><td><code id="rollcast_+3A_nboot">nboot</code></td>
<td>
<p>size of bootstrap sample; must be a single non-NA integer value
with <code>nboot &gt; 0</code>; default is <code>NULL</code></p>
</td></tr>
<tr><td><code id="rollcast_+3A_smoothscale">smoothscale</code></td>
<td>
<p>a character object; defines the smoothing approach
for the unconditional variance from the logarithm of the squared centralized
returns; for <code>smoothscale = 'lpr'</code>, the unconditional
variance is smoothed via the <code>smoots::gsmooth()</code> function from the
<code>smoots</code> package; the bandwidth has to be chosen manually; otherwise the
default is used; if <code>smoothscale = 'auto'</code>, the function <code>smoots::msmooth()</code>
is employed and the bandwidth is chosen automatically (data-driven); see the
documentation of the <code>smoots</code> package for more information; is set to
<code>smoothscale = 'none'</code> by default</p>
</td></tr>
<tr><td><code id="rollcast_+3A_smoothopts">smoothopts</code></td>
<td>
<p>additional arguments of <code>smoots::gsmooth()</code> and
<code>smoots::msmooth()</code>; see the documentation of the <code>smoots</code>
package for more information; is set to customized default settings</p>
</td></tr>
<tr><td><code id="rollcast_+3A_...">...</code></td>
<td>
<p>additional arguments of the <code>ugarchspec</code> function from the
<code>rugarch</code>-package; only applied if <code>model = 'GARCH'</code>; default
settings for the arguments <code>variance.model</code> and <code>mean.model</code> are:
</p>

<dl>
<dt><code>variance.model</code> = <code>list(model = 'sGARCH', garchOrder = c(1, 1))</code></dt><dd></dd>
<dt><code>mean.model</code> = <code>list(armaOrder = c(0, 0))</code></dt><dd></dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following elements:
</p>

<dl>
<dt>VaR</dt><dd><p>Numerical vector containing out-of-sample forecasts of Value at
Risk</p>
</dd>
<dt>ES</dt><dd><p>Numerical vector containing out-of-sample forecasts of Expected
Shortfall (Conditional Value at Risk)</p>
</dd>
<dt>xout</dt><dd><p>Numerical vector containing out-of-sample returns</p>
</dd>
<dt>p</dt><dd><p>Confidence level for VaR calculation</p>
</dd>
<dt>model</dt><dd><p>Model for estimating conditional volatility</p>
</dd>
<dt>method</dt><dd><p>Method to be used for calculation</p>
</dd>
<dt>nout</dt><dd><p>Number of out-of-sample observations</p>
</dd>
<dt>nwin</dt><dd><p>Window size for rolling one-step forecasting</p>
</dd>
<dt>nboot</dt><dd><p>Size of bootstrap sample</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
prices &lt;- DAX$price_close
returns &lt;- diff(log(prices))
n &lt;- length(returns)
nout &lt;- 250 # number of obs. for out-of-sample forecasting
nwin &lt;- 1000 # window size for rolling forecasts


### Example 1 - plain historical simulation
results1 &lt;- rollcast(x = returns, p = 0.975, method = 'plain', nout = nout,
                     nwin = nwin)
matplot(1:nout, cbind(-results1$xout, results1$VaR, results1$ES),
  type = 'hll',
  xlab = 'number of out-of-sample obs.', ylab = 'losses, VaR and ES',
  main = 'Plain HS - 97.5% VaR and ES for the DAX30 return series')

### Example 2 - age weighted historical simulation
results2 &lt;- rollcast(x = returns, p = 0.975, method = 'age', nout = nout,
                     nwin = nwin)
matplot(1:nout, cbind(-results2$xout, results2$VaR, results2$ES),
  type = 'hll',
  xlab = 'number of out-of-sample obs.', ylab = 'losses, VaR and ES',
  main = 'Age weighted HS - 97.5% VaR and ES for the DAX30 return series')

### Example 3 - volatility weighted historical simulation - EWMA
results3 &lt;- rollcast(x = returns, p = 0.975, model = 'EWMA',
                     method = 'vwhs', nout = nout, nwin = nwin)
matplot(1:nout, cbind(-results3$xout, results3$VaR, results3$ES),
  type = 'hll',
  xlab = 'number of out-of-sample obs.', ylab = 'losses, VaR and ES',
  main = 'Vol. weighted HS (EWMA) - 97.5% VaR and ES for the DAX30 return
  series')

### Example 4 - volatility weighted historical simulation - GARCH
results4 &lt;- rollcast(x = returns, p = 0.975, model = 'GARCH',
                     method = 'vwhs', nout = nout, nwin = nwin)
matplot(1:nout, cbind(-results4$xout, results4$VaR, results4$ES),
  type = 'hll',
  xlab = 'number of out-of-sample obs.', ylab = 'losses, VaR and ES',
  main = 'Vol. weighted HS (GARCH) - 97.5% VaR and ES for the DAX30 return
  series')

### Example 5 - filtered historical simulation - EWMA
results5 &lt;- rollcast(x = returns, p = 0.975, model = 'EWMA',
                     method = 'fhs', nout = nout, nwin = nwin, nboot = 10000)
matplot(1:nout, cbind(-results5$xout, results5$VaR, results5$ES),
  type = 'hll',
  xlab = 'number of out-of-sample obs.', ylab = 'losses, VaR and ES',
  main = 'Filtered HS (EWMA) - 97.5% VaR and ES for the DAX30 return
  series')

### Example 6 - filtered historical simulation - GARCH
results6 &lt;- rollcast(x = returns, p = 0.975, model = 'GARCH',
                     method = 'fhs', nout = nout, nwin = nwin, nboot = 10000)
matplot(1:nout, cbind(-results6$xout, results6$VaR, results6$ES),
  type = 'hll',
  xlab = 'number of out-of-sample obs.', ylab = 'losses, VaR and ES',
  main = 'Filtered HS (GARCH) - 97.5% VaR and ES for the DAX30 return
  series')

</code></pre>

<hr>
<h2 id='runFTSdata'>Application for downloading data from Yahoo Finance</h2><span id='topic+runFTSdata'></span>

<h3>Description</h3>

<p>Application for downloading data from Yahoo Finance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runFTSdata()
</code></pre>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='SP500'>Standard and Poor's (SP500) Financial Time Series Data</h2><span id='topic+SP500'></span>

<h3>Description</h3>

<p>A dataset that contains the daily financial data of the SP500 from
2000 to December 2023 (currency in USD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SP500
</code></pre>


<h3>Format</h3>

<p>A data frame with 6037 rows and 11 variables:
</p>

<dl>
<dt>ticker</dt><dd><p>id of the stock</p>
</dd>
<dt>ref_date</dt><dd><p>date in format YY-MM-DD</p>
</dd>
<dt>price_open</dt><dd><p>opening price (daily)</p>
</dd>
<dt>price_high</dt><dd><p>highest price (daily)</p>
</dd>
<dt>price_low</dt><dd><p>lowest price (daily)</p>
</dd>
<dt>price_close</dt><dd><p>closing price (daily)</p>
</dd>
<dt>volume</dt><dd><p>trading volume</p>
</dd>
<dt>price_adjusted</dt><dd><p>adjusted closing price (daily)</p>
</dd>
<dt>ret_adjusted_prices</dt><dd><p>returns obtained from the adj. closing prices</p>
</dd>
<dt>ret_closing_prices</dt><dd><p>returns obtained from the closing prices</p>
</dd>
<dt>cumret_adjusted_prices</dt><dd><p>accumulated arithmetic/log return for the period</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data was obtained from Yahoo Finance.
</p>

<hr>
<h2 id='trftest'>Backtesting of Value-at-Risk via Traffic Light Test</h2><span id='topic+trftest'></span>

<h3>Description</h3>

<p>The Traffic Light Test, is applied to
previously calculated Value-at-Risk series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trftest(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trftest_+3A_obj">obj</code></td>
<td>
<p>A list returned by the <code>rollcast</code> function, that contains
a Value-at-Risk series; any other list that follows the name conventions
of the <code>rollcast</code> function can be used as well.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses an object returned by the <code>rollcast</code> function
of the <code>quarks</code> package as an input for the
function argument <code>obj</code>. A list with different elements, such as
the cumulative probabilities for the VaR series within <code>obj</code>,
is returned. Instead of the list, only the traffic light backtesting results
are printed to the R console.
</p>


<h3>Value</h3>

<p>A list of class <code>quarks</code> is returned with the following elements.
</p>

<dl>
<dt>model</dt><dd><p>selected model for estimation</p>
</dd>
<dt>method</dt><dd><p>selected method for estimation</p>
</dd>
<dt>p_VaR</dt><dd><p>cumulative probability of observing the number of
breaches or fewer for (1 - <code>p</code>)100%-VaR</p>
</dd>
<dt>pot_VaR</dt><dd><p>number of exceedances for (1 - <code>p</code>)100%-VaR</p>
</dd>
<dt>p</dt><dd><p>coverage level for (1-<code>p</code>)100% VaR</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
prices &lt;- DAX$price_close
returns &lt;- diff(log(prices))
n &lt;- length(returns)
nout &lt;- 250 # number of obs. for out-of-sample forecasting
nwin &lt;- 500 # window size for rolling forecasts
results &lt;- rollcast(x = returns, p = 0.975, method = 'age', nout = nout,
                     nwin = nwin)
trftest(results)


</code></pre>

<hr>
<h2 id='vwhs'>Volatility weighted historical simulation</h2><span id='topic+vwhs'></span>

<h3>Description</h3>

<p>Calculates univariate Value at Risk and Expected Shortfall (Conditional
Value at Risk) by means of volatility weighted historical simulation.
Volatility can be estimated with an exponentially weighted moving average
or a GARCH-type model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vwhs(x, p = 0.975, model = c("EWMA", "GARCH"), lambda = 0.94, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vwhs_+3A_x">x</code></td>
<td>
<p>a numeric vector of asset returns</p>
</td></tr>
<tr><td><code id="vwhs_+3A_p">p</code></td>
<td>
<p>confidence level for VaR calculation; default is <code>0.975</code></p>
</td></tr>
<tr><td><code id="vwhs_+3A_model">model</code></td>
<td>
<p>model for estimating conditional volatility; default is <code>'EWMA'</code></p>
</td></tr>
<tr><td><code id="vwhs_+3A_lambda">lambda</code></td>
<td>
<p>decay factor for the calculation of weights; default is <code>0.94</code></p>
</td></tr>
<tr><td><code id="vwhs_+3A_...">...</code></td>
<td>
<p>additional arguments of the <code>ugarchspec</code> function from the
<code>rugarch</code>-package; the default settings for the arguments
<code>variance.model</code> and <code>mean.model</code> are <code>list(model = 'sGARCH',
garchOrder = c(1, 1))</code> and <code>list(armaOrder = c(0, 0))</code>, respectively</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following elements:
</p>

<dl>
<dt>VaR</dt><dd><p>Calculated Value at Risk</p>
</dd>
<dt>ES</dt><dd><p>Calculated Expected Shortfall (Conditional Value at Risk)</p>
</dd>
<dt>p</dt><dd><p>Confidence level for VaR calculation</p>
</dd>
<dt>garchmod</dt><dd><p>The model fit. Is the respective GARCH fit for
<code>model = 'GARCH'</code> (see <code>rugarch</code> documentation) and  <code>'EWMA'</code> for
<code>model = 'EWMA'</code></p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>prices &lt;- DAX$price_close
returns &lt;- diff(log(prices))
# volatility weighting via EWMA
ewma &lt;- vwhs(x = returns, p = 0.975, model = "EWMA", lambda = 0.94)
ewma
# volatility weighting via GARCH
garch &lt;- vwhs(x = returns, p = 0.975, model = "GARCH", variance.model =
list(model = "sGARCH"))
garch
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
