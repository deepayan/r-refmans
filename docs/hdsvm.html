<!DOCTYPE html><html lang="en"><head><title>Help for package hdsvm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hdsvm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef.cv.hdsvm'><p>Extract Coefficients from a 'cv.hdsvm' Object</p></a></li>
<li><a href='#coef.cv.nc.hdsvm'><p>Extract Coefficients from a 'cv.nc.hdsvm' Object</p></a></li>
<li><a href='#coef.hdsvm'><p>Extract Model Coefficients from a 'hdsvm' Object</p></a></li>
<li><a href='#coef.nc.hdsvm'><p>Extract Model Coefficients from a 'nc.hdsvm' Object</p></a></li>
<li><a href='#cv.hdsvm'><p>Cross-validation for Selecting the Tuning Parameter in the Penalized SVM</p></a></li>
<li><a href='#cv.nc.hdsvm'><p>Cross-validation for Selecting the Tuning Parameter of Nonconvex Penalized SVM</p></a></li>
<li><a href='#hdsvm'><p>Solve Penalized SVM</p></a></li>
<li><a href='#nc.hdsvm'><p>Solve the Penalized SVM with Nonconvex Penalties</p></a></li>
<li><a href='#predict.cv.hdsvm'><p>Make Predictions from a 'cv.hdsvm' Object</p></a></li>
<li><a href='#predict.cv.nc.hdsvm'><p>Make Predictions from a 'cv.nc.hdsvm' Object</p></a></li>
<li><a href='#predict.hdsvm'><p>Make Predictions from a 'hdsvm' Object</p></a></li>
<li><a href='#predict.nc.hdsvm'><p>Make Predictions from a 'nc.hdsvm' Object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Algorithm for Support Vector Machine</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-05</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yikai Zhang &lt;yikai-zhang@uiowa.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements an efficient algorithm to fit and tune penalized Support Vector Machine models using the generalized coordinate descent algorithm. Designed to handle high-dimensional datasets effectively, with emphasis on precision and computational efficiency. This package implements the algorithms proposed in Tang, Q., Zhang, Y., &amp; Wang, B. (2022) <a href="https://openreview.net/pdf?id=RvwMTDYTOb">https://openreview.net/pdf?id=RvwMTDYTOb</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, Matrix, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-05 20:41:31 UTC; qtang7</td>
</tr>
<tr>
<td>Author:</td>
<td>Yikai Zhang [aut, cre],
  Qian Tang [aut],
  Boxiang Wang [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-11 13:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='coef.cv.hdsvm'>Extract Coefficients from a 'cv.hdsvm' Object</h2><span id='topic+coef.cv.hdsvm'></span>

<h3>Description</h3>

<p>Retrieves coefficients from a cross-validated 'hdsvm()' model, using the
stored '&quot;hdsvm.fit&quot;' object and the optimal 'lambda' value determined during
cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.hdsvm'
coef(object, s = c("lambda.1se", "lambda.min"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.cv.hdsvm_+3A_object">object</code></td>
<td>
<p>A fitted 'cv.hdsvm()' object from which coefficients are to be extracted.</p>
</td></tr>
<tr><td><code id="coef.cv.hdsvm_+3A_s">s</code></td>
<td>
<p>Specifies the value(s) of the penalty parameter 'lambda' for which coefficients are desired.
The default is 's = &quot;lambda.1se&quot;', which corresponds to the largest value of 'lambda' such that the
cross-validation error estimate is within one standard error of the minimum. Alternatively,
's = &quot;lambda.min&quot;' can be used, corresponding to the minimum of the cross-validation error estimate.
If 's' is numeric, these are taken as the actual values of 'lambda' to use.</p>
</td></tr>
<tr><td><code id="coef.cv.hdsvm_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the coefficients at the specified 'lambda' values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.hdsvm">cv.hdsvm</a></code>, <code><a href="#topic+predict.cv.hdsvm">predict.cv.hdsvm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(315)
n &lt;- 100
p &lt;- 400
x1 &lt;- matrix(rnorm(n / 2 * p, -0.25, 0.1), n / 2)
x2 &lt;- matrix(rnorm(n / 2 * p, 0.25, 0.1), n / 2)
x &lt;- rbind(x1, x2)
beta &lt;- 0.1 * rnorm(p)
prob &lt;- plogis(c(x %*% beta))
y &lt;- 2 * rbinom(n, 1, prob) - 1
cv.fit &lt;- cv.hdsvm(x, y, lam2 = 0.01)
coef(cv.fit, s = c(0.02, 0.03))
</code></pre>

<hr>
<h2 id='coef.cv.nc.hdsvm'>Extract Coefficients from a 'cv.nc.hdsvm' Object</h2><span id='topic+coef.cv.nc.hdsvm'></span>

<h3>Description</h3>

<p>Retrieves coefficients at specified values of 'lambda' from a fitted 'cv.nc.hdsvm()' model.
Utilizes the stored '&quot;nchdsvm.fit&quot;' object and the optimal 'lambda' values determined during
the cross-validation process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.nc.hdsvm'
coef(object, s = c("lambda.1se", "lambda.min"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.cv.nc.hdsvm_+3A_object">object</code></td>
<td>
<p>A fitted 'cv.nc.hdsvm()' object from which coefficients are to be extracted.</p>
</td></tr>
<tr><td><code id="coef.cv.nc.hdsvm_+3A_s">s</code></td>
<td>
<p>Specifies the 'lambda' values at which coefficients are requested.
The default is 's = &quot;lambda.1se&quot;', representing the largest 'lambda' such that the cross-validation
error estimate is within one standard error of the minimum. Alternatively, 's = &quot;lambda.min&quot;'
corresponds to the 'lambda' yielding the minimum cross-validation error. If 's' is numeric, these
values are directly used as the 'lambda' values for coefficient extraction.</p>
</td></tr>
<tr><td><code id="coef.cv.nc.hdsvm_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector or matrix of coefficients corresponding to the specified 'lambda' values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.nc.hdsvm">cv.nc.hdsvm</a></code>, <code><a href="#topic+predict.cv.nc.hdsvm">predict.cv.nc.hdsvm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(315)
n &lt;- 100
p &lt;- 400
x1 &lt;- matrix(rnorm(n / 2 * p, -0.25, 0.1), n / 2)
x2 &lt;- matrix(rnorm(n / 2 * p, 0.25, 0.1), n / 2)
x &lt;- rbind(x1, x2)
beta &lt;- 0.1 * rnorm(p)
prob &lt;- plogis(c(x %*% beta))
y &lt;- 2 * rbinom(n, 1, prob) - 1
lam2 &lt;- 0.01
lambda &lt;- 10^(seq(1,-4, length.out = 30))
cv.nc.fit &lt;- cv.nc.hdsvm(x = x, y = y, lambda = lambda, lam2 = lam2, pen = "scad")
coef(cv.nc.fit, s = c(0.02, 0.03))
</code></pre>

<hr>
<h2 id='coef.hdsvm'>Extract Model Coefficients from a 'hdsvm' Object</h2><span id='topic+coef.hdsvm'></span>

<h3>Description</h3>

<p>Retrieves the coefficients at specified values of 'lambda' from a fitted 'hdsvm()' model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdsvm'
coef(object, s = NULL, type = c("coefficients", "nonzero"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.hdsvm_+3A_object">object</code></td>
<td>
<p>Fitted 'hdsvm()' object.</p>
</td></tr>
<tr><td><code id="coef.hdsvm_+3A_s">s</code></td>
<td>
<p>Values of the penalty parameter 'lambda' for which coefficients are requested.
Defaults to the entire sequence used during the model fit.</p>
</td></tr>
<tr><td><code id="coef.hdsvm_+3A_type">type</code></td>
<td>
<p>Type of prediction required. Type '&quot;coefficients&quot;' computes the coefficients at the requested 
values for 's'. Type '&quot;nonzero&quot;' returns a list of the indices of the nonzero coefficients for each 
value of <code>s</code>.</p>
</td></tr>
<tr><td><code id="coef.hdsvm_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts coefficients for specified 'lambda' values from a 'hdsvm()' object.
If 's', the vector of 'lambda' values, contains values not originally used in the model fitting,
the 'coef' function employs linear interpolation between the closest 'lambda' values from the 
original sequence to estimate coefficients at the new 'lambda' values.
</p>


<h3>Value</h3>

<p>Returns a matrix or vector of coefficients corresponding to the specified 'lambda' values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hdsvm">hdsvm</a></code>, <code><a href="#topic+predict.hdsvm">predict.hdsvm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(315)
n &lt;- 100
p &lt;- 400
x1 &lt;- matrix(rnorm(n / 2 * p, -0.25, 0.1), n / 2)
x2 &lt;- matrix(rnorm(n / 2 * p, 0.25, 0.1), n / 2)
x &lt;- rbind(x1, x2)
beta &lt;- 0.1 * rnorm(p)
prob &lt;- plogis(c(x %*% beta))
y &lt;- 2 * rbinom(n, 1, prob) - 1
lam2 &lt;- 0.01
fit &lt;- hdsvm(x, y, lam2=lam2)
coefs &lt;- coef(fit, s = fit$lambda[3:5])
</code></pre>

<hr>
<h2 id='coef.nc.hdsvm'>Extract Model Coefficients from a 'nc.hdsvm' Object</h2><span id='topic+coef.nc.hdsvm'></span>

<h3>Description</h3>

<p>Retrieves the coefficients at specified values of 'lambda' from a fitted 'nc.hdsvm()' model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nc.hdsvm'
coef(object, s = NULL, type = c("coefficients", "nonzero"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.nc.hdsvm_+3A_object">object</code></td>
<td>
<p>Fitted 'nc.hdsvm()' object.</p>
</td></tr>
<tr><td><code id="coef.nc.hdsvm_+3A_s">s</code></td>
<td>
<p>Values of the penalty parameter 'lambda' for which coefficients are requested.
Defaults to the entire sequence used during the model fit.</p>
</td></tr>
<tr><td><code id="coef.nc.hdsvm_+3A_type">type</code></td>
<td>
<p>Type of prediction required. Type '&quot;coefficients&quot;' computes the coefficients at the requested 
values for 's'. Type '&quot;nonzero&quot;' returns a list of the indices of the nonzero coefficients for each 
value of <code>s</code>.</p>
</td></tr>
<tr><td><code id="coef.nc.hdsvm_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts coefficients for specified 'lambda' values from a 'nc.hdsvm()' object.
If 's', the vector of 'lambda' values, contains values not originally used in the model fitting,
the 'coef' function employs linear interpolation between the closest 'lambda' values from the 
original sequence to estimate coefficients at the new 'lambda' values.
</p>


<h3>Value</h3>

<p>Returns a matrix or vector of coefficients corresponding to the specified 'lambda' values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nc.hdsvm">nc.hdsvm</a></code>, <code><a href="#topic+predict.nc.hdsvm">predict.nc.hdsvm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(315)
n &lt;- 100
p &lt;- 400
x1 &lt;- matrix(rnorm(n / 2 * p, -0.25, 0.1), n / 2)
x2 &lt;- matrix(rnorm(n / 2 * p, 0.25, 0.1), n / 2)
x &lt;- rbind(x1, x2)
beta &lt;- 0.1 * rnorm(p)
prob &lt;- plogis(c(x %*% beta))
y &lt;- 2 * rbinom(n, 1, prob) - 1
lam2 &lt;- 0.01
lambda &lt;- 10^(seq(1,-4, length.out = 30)) 
nc.fit &lt;- nc.hdsvm(x = x, y = y, lambda = lambda, lam2 = lam2, pen = "scad")
nc.coefs &lt;- coef(nc.fit, s = nc.fit$lambda[3:5])
</code></pre>

<hr>
<h2 id='cv.hdsvm'>Cross-validation for Selecting the Tuning Parameter in the Penalized SVM</h2><span id='topic+cv.hdsvm'></span>

<h3>Description</h3>

<p>Performs k-fold cross-validation for <code><a href="#topic+hdsvm">hdsvm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.hdsvm(x, y, lambda = NULL, nfolds = 5L, foldid, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.hdsvm_+3A_x">x</code></td>
<td>
<p>A numerical matrix with <code class="reqn">n</code> rows (observations) and <code class="reqn">p</code> columns (variables).</p>
</td></tr>
<tr><td><code id="cv.hdsvm_+3A_y">y</code></td>
<td>
<p>Response variable.</p>
</td></tr>
<tr><td><code id="cv.hdsvm_+3A_lambda">lambda</code></td>
<td>
<p>Optional; a user-supplied sequence of <code>lambda</code> values. If <code>NULL</code>, 
<code><a href="#topic+hdsvm">hdsvm</a></code> selects its own sequence.</p>
</td></tr>
<tr><td><code id="cv.hdsvm_+3A_nfolds">nfolds</code></td>
<td>
<p>Number of folds for cross-validation. Defaults to 5.</p>
</td></tr>
<tr><td><code id="cv.hdsvm_+3A_foldid">foldid</code></td>
<td>
<p>Optional vector specifying the indices of observations in each fold.
If provided, it overrides <code>nfolds</code>.</p>
</td></tr>
<tr><td><code id="cv.hdsvm_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+hdsvm">hdsvm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the average cross-validation error and provides the standard error.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>cv.hdsvm</code> consisting of
</p>
<table role = "presentation">
<tr><td><code>lambda</code></td>
<td>
<p>Candidate <code>lambda</code> values.</p>
</td></tr>
<tr><td><code>cvm</code></td>
<td>
<p>Mean cross-validation error.</p>
</td></tr>
<tr><td><code>cvsd</code></td>
<td>
<p>Standard error of the mean cross-validation error.</p>
</td></tr>
<tr><td><code>cvup</code></td>
<td>
<p>Upper confidence curve: <code>cvm</code> + <code>cvsd</code>.</p>
</td></tr>
<tr><td><code>cvlo</code></td>
<td>
<p>Lower confidence curve: <code>cvm</code> - <code>cvsd</code>.</p>
</td></tr>
<tr><td><code>lambda.min</code></td>
<td>
<p><code>lambda</code> achieving the minimum cross-validation error.</p>
</td></tr>
<tr><td><code>lambda.1se</code></td>
<td>
<p>Largest <code>lambda</code> within one standard error of the minimum error.</p>
</td></tr>
<tr><td><code>cv.min</code></td>
<td>
<p>Cross-validation error at <code>lambda.min</code>.</p>
</td></tr>
<tr><td><code>cv.1se</code></td>
<td>
<p>Cross-validation error at <code>lambda.1se</code>.</p>
</td></tr>
<tr><td><code>hdsvm.fit</code></td>
<td>
<p>a fitted <code><a href="#topic+hdsvm">hdsvm</a></code> object for the full data.</p>
</td></tr>
<tr><td><code>nzero</code></td>
<td>
<p>Number of non-zero coefficients at each <code>lambda</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(315)
n &lt;- 100
p &lt;- 400
x1 &lt;- matrix(rnorm(n / 2 * p, -0.25, 0.1), n / 2)
x2 &lt;- matrix(rnorm(n / 2 * p, 0.25, 0.1), n / 2)
x &lt;- rbind(x1, x2)
beta &lt;- 0.1 * rnorm(p)
prob &lt;- plogis(c(x %*% beta))
y &lt;- 2 * rbinom(n, 1, prob) - 1
lam2 &lt;- 0.01
fit &lt;- cv.hdsvm(x, y, lam2=lam2)
</code></pre>

<hr>
<h2 id='cv.nc.hdsvm'>Cross-validation for Selecting the Tuning Parameter of Nonconvex Penalized SVM</h2><span id='topic+cv.nc.hdsvm'></span>

<h3>Description</h3>

<p>Conducts k-fold cross-validation for the 'nc.hdsvm()' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.nc.hdsvm(x, y, lambda = NULL, nfolds = 5L, foldid, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.nc.hdsvm_+3A_x">x</code></td>
<td>
<p>A numerical matrix with dimensions (<code class="reqn">n</code> rows and <code class="reqn">p</code> columns), where each row represents an observation.</p>
</td></tr>
<tr><td><code id="cv.nc.hdsvm_+3A_y">y</code></td>
<td>
<p>Response variable.</p>
</td></tr>
<tr><td><code id="cv.nc.hdsvm_+3A_lambda">lambda</code></td>
<td>
<p>Optional user-supplied sequence of <code>lambda</code> values.</p>
</td></tr>
<tr><td><code id="cv.nc.hdsvm_+3A_nfolds">nfolds</code></td>
<td>
<p>Number of folds in the cross-validation, default is 5.</p>
</td></tr>
<tr><td><code id="cv.nc.hdsvm_+3A_foldid">foldid</code></td>
<td>
<p>An optional vector that assigns each observation to a specific fold. 
If provided, this parameter overrides <code>nfolds</code>.</p>
</td></tr>
<tr><td><code id="cv.nc.hdsvm_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+nc.hdsvm">nc.hdsvm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates the average cross-validation error and its standard error across folds. It is primarily used to 
identify the optimal <code>lambda</code> value for fitting nonconvex penalized SVM models.
</p>


<h3>Value</h3>

<p>An object of class <code>cv.nc.hdsvm</code> is returned,
which is a list with the ingredients of the cross-validated fit.
</p>
<table role = "presentation">
<tr><td><code>lambda</code></td>
<td>
<p>the values of <code>lambda</code> used in the fits.</p>
</td></tr>
<tr><td><code>cvm</code></td>
<td>
<p>the mean cross-validated error - a vector of length <code>length(lambda)</code>.</p>
</td></tr>
<tr><td><code>cvsd</code></td>
<td>
<p>estimate of standard error of <code>cvm</code>.</p>
</td></tr>
<tr><td><code>cvupper</code></td>
<td>
<p>upper curve = <code>cvm+cvsd</code>.</p>
</td></tr>
<tr><td><code>cvlower</code></td>
<td>
<p>lower curve = <code>cvm-cvsd</code>.</p>
</td></tr>
<tr><td><code>nzero</code></td>
<td>
<p>number of non-zero coefficients at each <code>lambda</code>.</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>a text string indicating type of measure (for plotting purposes).</p>
</td></tr>
<tr><td><code>nchdsvm.fit</code></td>
<td>
<p>a fitted <code><a href="#topic+nc.hdsvm">nc.hdsvm</a></code> object for the full data.</p>
</td></tr>
<tr><td><code>lambda.min</code></td>
<td>
<p>The optimal value of <code>lambda</code> that gives minimum cross validation error <code>cvm</code>.</p>
</td></tr>
<tr><td><code>lambda.1se</code></td>
<td>
<p>The largest value of <code>lambda</code> such that error is within 1 standard error of the minimum.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(315)
n &lt;- 100
p &lt;- 400
x1 &lt;- matrix(rnorm(n / 2 * p, -0.25, 0.1), n / 2)
x2 &lt;- matrix(rnorm(n / 2 * p, 0.25, 0.1), n / 2)
x &lt;- rbind(x1, x2)
beta &lt;- 0.1 * rnorm(p)
prob &lt;- plogis(c(x %*% beta))
y &lt;- 2 * rbinom(n, 1, prob) - 1
lam2 &lt;- 0.01
lambda &lt;- 10^(seq(1,-4, length.out=30))
cv.nc.fit &lt;- cv.nc.hdsvm(x=x, y=y, lambda=lambda, lam2=lam2, pen="scad")
</code></pre>

<hr>
<h2 id='hdsvm'>Solve Penalized SVM</h2><span id='topic+hdsvm'></span>

<h3>Description</h3>

<p>Fits a penalized support vector machine (SVM) model using a range of <code>lambda</code> values,
allowing for detailed control over regularization parameters and model complexity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdsvm(
  x,
  y,
  nlambda = 100,
  lambda.factor = ifelse(nobs &lt; nvars, 0.01, 1e-04),
  lambda = NULL,
  lam2 = 0,
  hval = 1,
  pf = rep(1, nvars),
  pf2 = rep(1, nvars),
  exclude,
  dfmax = nvars + 1,
  pmax = min(dfmax * 1.2, nvars),
  standardize = TRUE,
  eps = 1e-08,
  maxit = 1e+06,
  sigma = 0.9,
  is_exact = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hdsvm_+3A_x">x</code></td>
<td>
<p>Matrix of predictors, with dimensions (<code class="reqn">n</code> observations by <code class="reqn">p</code> variables).</p>
</td></tr>
<tr><td><code id="hdsvm_+3A_y">y</code></td>
<td>
<p>Response variable vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="hdsvm_+3A_nlambda">nlambda</code></td>
<td>
<p>Number of <code>lambda</code> values to consider (default is 100).</p>
</td></tr>
<tr><td><code id="hdsvm_+3A_lambda.factor">lambda.factor</code></td>
<td>
<p>The factor for getting the minimal value
in the <code>lambda</code> sequence, where
<code>min(lambda)</code> = <code>lambda.factor</code> * <code>max(lambda)</code>
and <code>max(lambda)</code> is the smallest value of <code>lambda</code>
for which all coefficients (except the intercept when it is present)
are penalized to zero. The default depends on the relationship
between <code class="reqn">n</code> (the number of rows in the design matrix) and
<code class="reqn">p</code> (the number of predictors). If <code class="reqn">n &lt; p</code>, it defaults to
<code>0.05</code>. If <code class="reqn">n &gt; p</code>, the default is <code>0.001</code>,
closer to zero.  A very small value of <code>lambda.factor</code> will
lead to a saturated fit. The argument takes no effect if there is a
user-supplied <code>lambda</code> sequence.</p>
</td></tr>
<tr><td><code id="hdsvm_+3A_lambda">lambda</code></td>
<td>
<p>A user-supplied <code>lambda</code> sequence. Typically,
by leaving this option unspecified, users can have the program
compute its own <code>lambda</code> sequence based on <code>nlambda</code>
and <code>lambda.factor</code>. It is better to supply, if necessary,
a decreasing sequence of <code>lambda</code> values than a single
(small) value. The program will ensure that the user-supplied
<code>lambda</code> sequence is sorted in decreasing order before</p>
</td></tr>
<tr><td><code id="hdsvm_+3A_lam2">lam2</code></td>
<td>
<p>Regularization parameter <code>lambda2</code> for the
quadratic penalty of the coefficients. Unlike <code>lambda</code>,
only one value of <code>lambda2</code> is used for each fitting process.</p>
</td></tr>
<tr><td><code id="hdsvm_+3A_hval">hval</code></td>
<td>
<p>Smoothing parameter for the smoothed hinge loss, default is 1.</p>
</td></tr>
<tr><td><code id="hdsvm_+3A_pf">pf</code></td>
<td>
<p>L1 penalty factor of length <code class="reqn">p</code> used for the adaptive
LASSO or adaptive elastic net. Separate L1 penalty weights can be
applied to each coefficient to allow different L1 shrinkage.
Can be 0 for some variables (but not all), which imposes no
shrinkage, and results in that variable always being included
in the model. Default is 1 for all variables (and implicitly
infinity for variables in the <code>exclude</code> list).</p>
</td></tr>
<tr><td><code id="hdsvm_+3A_pf2">pf2</code></td>
<td>
<p>L2 penalty factor of length <code class="reqn">p</code> used for adaptive
elastic net. Separate L2 penalty weights can be applied to
each coefficient to allow different L2 shrinkage.
Can be 0 for some variables, which imposes no shrinkage.
Default is 1 for all variables.</p>
</td></tr>
<tr><td><code id="hdsvm_+3A_exclude">exclude</code></td>
<td>
<p>Indices of variables to be excluded from the model.
Default is none. Equivalent to an infinite penalty factor.</p>
</td></tr>
<tr><td><code id="hdsvm_+3A_dfmax">dfmax</code></td>
<td>
<p>The maximum number of variables allowed in the model.
Useful for very large <code class="reqn">p</code> when a partial path is desired.
Default is <code class="reqn">p+1</code>.</p>
</td></tr>
<tr><td><code id="hdsvm_+3A_pmax">pmax</code></td>
<td>
<p>Maximum count of non-zero coefficients across the solution path.</p>
</td></tr>
<tr><td><code id="hdsvm_+3A_standardize">standardize</code></td>
<td>
<p>Logical flag for variable standardization,
prior to fitting the model sequence. The coefficients are
always returned to the original scale. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="hdsvm_+3A_eps">eps</code></td>
<td>
<p>Convergence criterion for stopping the algorithm.</p>
</td></tr>
<tr><td><code id="hdsvm_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations permitted.</p>
</td></tr>
<tr><td><code id="hdsvm_+3A_sigma">sigma</code></td>
<td>
<p>Penalty parameter in the quadratic term of the augmented Lagrangian.</p>
</td></tr>
<tr><td><code id="hdsvm_+3A_is_exact">is_exact</code></td>
<td>
<p>If <code>TRUE</code>, solutions are computed exactly; otherwise, approximations are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function utilizes the hinge loss function combined with elastic net penalization:
</p>
<p style="text-align: center;"><code class="reqn">1'[\max\{1 - y_i (\beta_0 + X_i^\top \beta), 0\}]/N + \lambda_1 \cdot |pf_1 \circ \beta|_1 +
0.5 \cdot \lambda_2 \cdot (\sqrt{pf_2} \circ \beta)^2,</code>
</p>

<p>where <code class="reqn">\circ</code> denotes the Hadamard product. 
</p>
<p>For faster computation, if the algorithm is not converging or
running slow, consider increasing <code>eps</code>, increasing
<code>sigma</code>, decreasing <code>nlambda</code>, or increasing
<code>lambda.factor</code> before increasing <code>maxit</code>.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>hdsvm</code> consisting of
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the call that produced this object</p>
</td></tr>
<tr><td><code>b0</code></td>
<td>
<p>intercept sequence of length <code>length(lambda)</code></p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>a <code>p*length(lambda)</code> matrix of coefficients,
stored as a sparse matrix (<code>dgCMatrix</code> class,
the standard class for sparse numeric matrices in
the <code>Matrix</code> package.). To convert it into
normal type matrix, use <code>as.matrix()</code>.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the actual sequence of <code>lambda</code> values used</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the number of nonzero coefficients for each value
of <code>lambda</code>.</p>
</td></tr>
<tr><td><code>npasses</code></td>
<td>
<p>the number of iterations for every lambda value</p>
</td></tr>
<tr><td><code>jerr</code></td>
<td>
<p>error flag, for warnings and errors, 0 if no error.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(315)
n &lt;- 100
p &lt;- 400
x1 &lt;- matrix(rnorm(n / 2 * p, -0.25, 0.1), n / 2)
x2 &lt;- matrix(rnorm(n / 2 * p, 0.25, 0.1), n / 2)
x &lt;- rbind(x1, x2)
beta &lt;- 0.1 * rnorm(p)
prob &lt;- plogis(c(x %*% beta))
y &lt;- 2 * rbinom(n, 1, prob) - 1
lam2 &lt;- 0.01
fit &lt;- hdsvm(x, y, lam2=lam2)
</code></pre>

<hr>
<h2 id='nc.hdsvm'>Solve the Penalized SVM with Nonconvex Penalties</h2><span id='topic+nc.hdsvm'></span>

<h3>Description</h3>

<p>This function fits the penalized SVM using nonconvex penalties 
such as SCAD or MCP. It allows for flexible control over the regularization parameters and 
offers advanced options for initializing and optimizing the fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nc.hdsvm(
  x,
  y,
  lambda,
  pen = "scad",
  aval = NULL,
  lam2 = 1,
  ini_beta = NULL,
  lla_step = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nc.hdsvm_+3A_x">x</code></td>
<td>
<p>Matrix of predictors, with dimensions (nobs * nvars); each row represents an observation.</p>
</td></tr>
<tr><td><code id="nc.hdsvm_+3A_y">y</code></td>
<td>
<p>Response variable, with length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="nc.hdsvm_+3A_lambda">lambda</code></td>
<td>
<p>Optional user-supplied sequence of <code>lambda</code> values. If unspecified, the program 
calculates its own sequence based on <code>nlambda</code> and <code>lambda.factor</code>. Supplying a decreasing 
sequence of <code>lambda</code> values is advisable to leverage the warm-start optimization.</p>
</td></tr>
<tr><td><code id="nc.hdsvm_+3A_pen">pen</code></td>
<td>
<p>Specifies the type of nonconvex penalty: &quot;SCAD&quot; or &quot;MCP&quot;.</p>
</td></tr>
<tr><td><code id="nc.hdsvm_+3A_aval">aval</code></td>
<td>
<p>The parameter value for the SCAD or MCP penalty. Default is 3.7 for SCAD and 2 for MCP.</p>
</td></tr>
<tr><td><code id="nc.hdsvm_+3A_lam2">lam2</code></td>
<td>
<p>Regularization parameter <code>lambda2</code> for the quadratic penalty on the coefficients. 
Only one value of <code>lambda2</code> is used per fit.</p>
</td></tr>
<tr><td><code id="nc.hdsvm_+3A_ini_beta">ini_beta</code></td>
<td>
<p>Optional initial coefficients to start the fitting process.</p>
</td></tr>
<tr><td><code id="nc.hdsvm_+3A_lla_step">lla_step</code></td>
<td>
<p>Number of Local Linear Approximation (LLA) steps. Default is 3.</p>
</td></tr>
<tr><td><code id="nc.hdsvm_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+hdsvm">hdsvm</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with S3 class <code>nc.hdsvm</code> consisting of
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the call that produced this object</p>
</td></tr>
<tr><td><code>b0</code></td>
<td>
<p>intercept sequence of length <code>length(lambda)</code></p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>a <code>p*length(lambda)</code> matrix of coefficients,
stored as a sparse matrix (<code>dgCMatrix</code> class,
the standard class for sparse numeric matrices in
the <code>Matrix</code> package.). To convert it into
normal type matrix, use <code>as.matrix()</code>.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the actual sequence of <code>lambda</code> values used</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the number of nonzero coefficients for each value
of <code>lambda</code>.</p>
</td></tr>
<tr><td><code>npasses</code></td>
<td>
<p>the number of iterations for every lambda value</p>
</td></tr>
<tr><td><code>jerr</code></td>
<td>
<p>error flag, for warnings and errors, 0 if no error.</p>
</td></tr></table>
<p>#'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(315)
n &lt;- 100
p &lt;- 400
x1 &lt;- matrix(rnorm(n / 2 * p, -0.25, 0.1), n / 2)
x2 &lt;- matrix(rnorm(n / 2 * p, 0.25, 0.1), n / 2)
x &lt;- rbind(x1, x2)
beta &lt;- 0.1 * rnorm(p)
prob &lt;- plogis(c(x %*% beta))
y &lt;- 2 * rbinom(n, 1, prob) - 1
lam2 &lt;- 0.01
lambda &lt;- 10^(seq(1,-4, length.out = 30)) 
nc.fit &lt;- nc.hdsvm(x = x, y = y, lambda = lambda, lam2 = lam2, pen = "scad")
</code></pre>

<hr>
<h2 id='predict.cv.hdsvm'>Make Predictions from a 'cv.hdsvm' Object</h2><span id='topic+predict.cv.hdsvm'></span>

<h3>Description</h3>

<p>Generates predictions using a fitted 'cv.hdsvm()' object. This function utilizes the
stored 'hdsvm.fit' object and an optimal value of 'lambda' determined during the
cross-validation process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.hdsvm'
predict(
  object,
  newx,
  s = c("lambda.1se", "lambda.min"),
  type = c("class", "loss"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.cv.hdsvm_+3A_object">object</code></td>
<td>
<p>A fitted 'cv.hdsvm()' object from which predictions are to be made.</p>
</td></tr>
<tr><td><code id="predict.cv.hdsvm_+3A_newx">newx</code></td>
<td>
<p>Matrix of new predictor values for which predictions are desired.
This must be a matrix and is a required argument.</p>
</td></tr>
<tr><td><code id="predict.cv.hdsvm_+3A_s">s</code></td>
<td>
<p>Specifies the value(s) of the penalty parameter 'lambda' at which predictions
are desired. The default is 's = &quot;lambda.1se&quot;', representing the largest value of 'lambda'
such that the cross-validation error estimate is within one standard error of the minimum.
Alternatively, 's = &quot;lambda.min&quot;' can be used, corresponding to the minimum of the
cross-validation error estimate. If 's' is numeric, these are taken as the actual values
of 'lambda' to use for predictions.</p>
</td></tr>
<tr><td><code id="predict.cv.hdsvm_+3A_type">type</code></td>
<td>
<p>Type of prediction required. Type '&quot;class&quot;' produces the predicted binary class labels and
type '&quot;loss&quot;' returns the fitted values. Default is <code>"class"</code>.</p>
</td></tr>
<tr><td><code id="predict.cv.hdsvm_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix or vector of predicted values corresponding to the specified
'lambda' values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.hdsvm">cv.hdsvm</a></code>, <code><a href="#topic+coef.cv.hdsvm">coef.cv.hdsvm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(315)
n &lt;- 100
p &lt;- 400
x1 &lt;- matrix(rnorm(n / 2 * p, -0.25, 0.1), n / 2)
x2 &lt;- matrix(rnorm(n / 2 * p, 0.25, 0.1), n / 2)
x &lt;- rbind(x1, x2)
beta &lt;- 0.1 * rnorm(p)
prob &lt;- plogis(c(x %*% beta))
y &lt;- 2 * rbinom(n, 1, prob) - 1
cv.fit &lt;- cv.hdsvm(x, y, lam2 = 0.01)
predict(cv.fit, newx = x[50:60, ], s = "lambda.min")
</code></pre>

<hr>
<h2 id='predict.cv.nc.hdsvm'>Make Predictions from a 'cv.nc.hdsvm' Object</h2><span id='topic+predict.cv.nc.hdsvm'></span>

<h3>Description</h3>

<p>Generates predictions using a fitted 'cv.nc.hdsvm()' object. This function utilizes the
stored 'nchdsvm.fit' object and an optimal value of 'lambda' determined during the
cross-validation process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.nc.hdsvm'
predict(
  object,
  newx,
  s = c("lambda.1se", "lambda.min"),
  type = c("class", "loss"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.cv.nc.hdsvm_+3A_object">object</code></td>
<td>
<p>A fitted 'cv.nc.hdsvm()' object from which predictions are to be made.</p>
</td></tr>
<tr><td><code id="predict.cv.nc.hdsvm_+3A_newx">newx</code></td>
<td>
<p>Matrix of new predictor values for which predictions are desired.
This must be a matrix and is a required argument.</p>
</td></tr>
<tr><td><code id="predict.cv.nc.hdsvm_+3A_s">s</code></td>
<td>
<p>Specifies the value(s) of the penalty parameter 'lambda' at which predictions
are desired. The default is 's = &quot;lambda.1se&quot;', representing the largest value of 'lambda'
such that the cross-validation error estimate is within one standard error of the minimum.
Alternatively, 's = &quot;lambda.min&quot;' can be used, corresponding to the minimum of the
cross-validation error estimate. If 's' is numeric, these are taken as the actual values
of 'lambda' to use for predictions.</p>
</td></tr>
<tr><td><code id="predict.cv.nc.hdsvm_+3A_type">type</code></td>
<td>
<p>Type of prediction required. Type '&quot;class&quot;' produces the predicted binary class labels and
type '&quot;loss&quot;' returns the fitted values. Default is <code>"class"</code>.</p>
</td></tr>
<tr><td><code id="predict.cv.nc.hdsvm_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix or vector of predicted values corresponding to the specified
'lambda' values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.nc.hdsvm">cv.nc.hdsvm</a></code>, <code><a href="#topic+predict.cv.nc.hdsvm">predict.cv.nc.hdsvm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(315)
n &lt;- 100
p &lt;- 400
x1 &lt;- matrix(rnorm(n / 2 * p, -0.25, 0.1), n / 2)
x2 &lt;- matrix(rnorm(n / 2 * p, 0.25, 0.1), n / 2)
x &lt;- rbind(x1, x2)
beta &lt;- 0.1 * rnorm(p)
prob &lt;- plogis(c(x %*% beta))
y &lt;- 2 * rbinom(n, 1, prob) - 1
lam2 &lt;- 0.01
lambda &lt;- 10^(seq(1,-4, length.out = 30))
cv.nc.fit &lt;- cv.nc.hdsvm(x = x, y = y, lambda = lambda, lam2 = lam2, pen = "scad")
predict(cv.nc.fit, newx = x[50:60, ], s = "lambda.min")
</code></pre>

<hr>
<h2 id='predict.hdsvm'>Make Predictions from a 'hdsvm' Object</h2><span id='topic+predict.hdsvm'></span>

<h3>Description</h3>

<p>Produces fitted values for new predictor data using a fitted 'hdsvm()' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdsvm'
predict(object, newx, s = NULL, type = c("class", "loss"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.hdsvm_+3A_object">object</code></td>
<td>
<p>Fitted 'hdsvm()' object from which predictions are to be derived.</p>
</td></tr>
<tr><td><code id="predict.hdsvm_+3A_newx">newx</code></td>
<td>
<p>Matrix of new predictor values for which predictions are desired.
This must be a matrix and is a required argument.</p>
</td></tr>
<tr><td><code id="predict.hdsvm_+3A_s">s</code></td>
<td>
<p>Values of the penalty parameter 'lambda' for which predictions are requested.
Defaults to the entire sequence used during the model fit.</p>
</td></tr>
<tr><td><code id="predict.hdsvm_+3A_type">type</code></td>
<td>
<p>Type of prediction required. Type '&quot;class&quot;' produces the predicted binary class labels and
type '&quot;loss&quot;' returns the fitted values. Default is <code>"class"</code>.</p>
</td></tr>
<tr><td><code id="predict.hdsvm_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates predictions at specified 'lambda' values from a fitted 'hdsvm()' object.
It is essential to provide a new matrix of predictor values ('newx') at which these predictions are to be made.
</p>


<h3>Value</h3>

<p>Returns a vector or matrix of predicted values corresponding to the specified 'lambda' values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hdsvm">hdsvm</a></code>, <code><a href="#topic+coef.hdsvm">coef.hdsvm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(315)
n &lt;- 100
p &lt;- 400
x1 &lt;- matrix(rnorm(n / 2 * p, -0.25, 0.1), n / 2)
x2 &lt;- matrix(rnorm(n / 2 * p, 0.25, 0.1), n / 2)
x &lt;- rbind(x1, x2)
beta &lt;- 0.1 * rnorm(p)
prob &lt;- plogis(c(x %*% beta))
y &lt;- 2 * rbinom(n, 1, prob) - 1
lam2 &lt;- 0.01
fit &lt;- hdsvm(x, y, lam2=lam2)
preds &lt;- predict(fit, newx = tail(x), s = fit$lambda[3:5])
</code></pre>

<hr>
<h2 id='predict.nc.hdsvm'>Make Predictions from a 'nc.hdsvm' Object</h2><span id='topic+predict.nc.hdsvm'></span>

<h3>Description</h3>

<p>Produces fitted values for new predictor data using a fitted 'nc.hdsvm()' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nc.hdsvm'
predict(object, newx, s = NULL, type = c("class", "loss"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.nc.hdsvm_+3A_object">object</code></td>
<td>
<p>Fitted 'nc.hdsvm()' object from which predictions are to be derived.</p>
</td></tr>
<tr><td><code id="predict.nc.hdsvm_+3A_newx">newx</code></td>
<td>
<p>Matrix of new predictor values for which predictions are desired.
This must be a matrix and is a required argument.</p>
</td></tr>
<tr><td><code id="predict.nc.hdsvm_+3A_s">s</code></td>
<td>
<p>Values of the penalty parameter 'lambda' for which predictions are requested.
Defaults to the entire sequence used during the model fit.</p>
</td></tr>
<tr><td><code id="predict.nc.hdsvm_+3A_type">type</code></td>
<td>
<p>Type of prediction required. Type '&quot;class&quot;' produces the predicted binary class labels and
type '&quot;loss&quot;' returns the fitted values. Default is <code>"class"</code>.</p>
</td></tr>
<tr><td><code id="predict.nc.hdsvm_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates predictions at specified 'lambda' values from a fitted 'nc.hdsvm()' object.
It is essential to provide a new matrix of predictor values ('newx') at which these predictions are to be made.
</p>


<h3>Value</h3>

<p>Returns a vector or matrix of predicted values corresponding to the specified 'lambda' values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nc.hdsvm">nc.hdsvm</a></code>, <code><a href="#topic+coef.nc.hdsvm">coef.nc.hdsvm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(315)
n &lt;- 100
p &lt;- 400
x1 &lt;- matrix(rnorm(n / 2 * p, -0.25, 0.1), n / 2)
x2 &lt;- matrix(rnorm(n / 2 * p, 0.25, 0.1), n / 2)
x &lt;- rbind(x1, x2)
beta &lt;- 0.1 * rnorm(p)
prob &lt;- plogis(c(x %*% beta))
y &lt;- 2 * rbinom(n, 1, prob) - 1
lam2 &lt;- 0.01
lambda &lt;- 10^(seq(1,-4, length.out = 30)) 
nc.fit &lt;- nc.hdsvm(x = x, y = y, lambda = lambda, lam2 = lam2, pen = "scad")
nc.preds &lt;- predict(nc.fit, newx = tail(x), s = nc.fit$lambda[3:5])
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
