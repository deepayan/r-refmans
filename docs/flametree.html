<!DOCTYPE html><html><head><title>Help for package flametree</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {flametree}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#flametree_grow'><p>Generate the data specifying a flametree</p></a></li>
<li><a href='#flametree_plot'><p>Create a plot from a flametree data frame</p></a></li>
<li><a href='#flametree_save'><p>Save the plot</p></a></li>
<li><a href='#sparks'><p>Spark functions to control tree growth</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Generate Random Tree-Like Images</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Description:</td>
<td>A generative art system for producing tree-like
    images using an L-system to create the structures. The package 
    includes tools for generating the data structures and visualise
    them in a variety of styles.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/djnavarro/flametree">https://github.com/djnavarro/flametree</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/djnavarro/flametree/issues">https://github.com/djnavarro/flametree/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>tibble, dplyr, purrr, tidyr, ggplot2, ggforce, magrittr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>deldir, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-29 06:07:39 UTC; danielle</td>
</tr>
<tr>
<td>Author:</td>
<td>Danielle Navarro <a href="https://orcid.org/0000-0001-7648-6578"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Danielle Navarro &lt;djnavarro@protonmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-29 08:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling 'rhs(lhs)'.
</p>

<hr>
<h2 id='flametree_grow'>Generate the data specifying a flametree</h2><span id='topic+flametree_grow'></span>

<h3>Description</h3>

<p>Generate the data specifying a flametree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flametree_grow(
  seed = 286,
  time = 6,
  scale = c(0.6, 0.8, 0.9),
  angle = c(-10, 10, 20),
  split = 2,
  trees = 1,
  seg_col = spark_linear(tree = 2, time = 1),
  seg_wid = spark_decay(time = 0.3, multiplier = 5, constant = 0.1),
  shift_x = spark_random(multiplier = 3),
  shift_y = spark_nothing()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flametree_grow_+3A_seed">seed</code></td>
<td>
<p>Integer seed for the random number generator</p>
</td></tr>
<tr><td><code id="flametree_grow_+3A_time">time</code></td>
<td>
<p>Number of generations to run the iterative process</p>
</td></tr>
<tr><td><code id="flametree_grow_+3A_scale">scale</code></td>
<td>
<p>Vector of possible values for the &quot;size rescaling&quot; at each iteration</p>
</td></tr>
<tr><td><code id="flametree_grow_+3A_angle">angle</code></td>
<td>
<p>Vector of possible angle changes (in degrees) at each iteration</p>
</td></tr>
<tr><td><code id="flametree_grow_+3A_split">split</code></td>
<td>
<p>Number of splits at each time point</p>
</td></tr>
<tr><td><code id="flametree_grow_+3A_trees">trees</code></td>
<td>
<p>Number of trees to generate</p>
</td></tr>
<tr><td><code id="flametree_grow_+3A_seg_col">seg_col</code></td>
<td>
<p>Spark function to control the segment colour</p>
</td></tr>
<tr><td><code id="flametree_grow_+3A_seg_wid">seg_wid</code></td>
<td>
<p>Spark function to control the segment width</p>
</td></tr>
<tr><td><code id="flametree_grow_+3A_shift_x">shift_x</code></td>
<td>
<p>Spark function to control horizontal jitter</p>
</td></tr>
<tr><td><code id="flametree_grow_+3A_shift_y">shift_y</code></td>
<td>
<p>Spark function to control vertical jitter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generative art created with flametree is a visualisation of a data
structure created by calling <code>flametree_grow()</code>. The underlying
algorithm is an iterative branching process: each tree starts out as a single
vertical segment, to which multiple new segments are added at the end of the
first iteration. Over multiple iterations this creates a tree-like structure.
</p>
<p>The user can control how this iterative process unfolds. By setting the
<code>seed</code> argument the random number generator is reset using
<code>set.seed()</code>. The <code>trees</code> argument specifies the number of trees
to create using this process, the <code>time</code> argument specifies how many
iterations of the branching process will be run (at least two), and the
<code>split</code> argument specifies how many new segments (at least two) will be
created each time abranching occurs.
</p>
<p>When a new segment is created, its size and orientation are controlled by the
<code>scale</code> and <code>angle</code> arguments. The <code>scale</code> argument takes a
vector of at least two positive numbers. One of these numbers is selected at
random whenever a new segment is created, and the length of the new segment
is equal to the length of the &quot;parent&quot; segment from which it was created,
multiplied by this scaling factor. The orientation of the new segment is
controlled by the angle argument in an analogous way. Every time a new
segment is generated, one of these angles (interpreted in degrees, not
radians) is selected at random. The orientation of the new segment is equal
to the orientation of the parent segment plus the sampled angle. Like the
<code>scale</code> argument, <code>angle</code> must contain at least two values.
</p>
<p>The remaining arguments (<code>seg_col</code>, <code>seg_wid</code>, <code>shift_x</code>,
and <code>shift_y</code>) all take functions as their input, and are used to
control how the colours (<code>seg_col</code>) and width (<code>seg_wid</code>) of the
segments are created, as well as the horizontal (<code>shift_x</code>) and
vertical (<code>shift_y</code>) displacement of the trees are generated. Functions
passed to these arguments take four inputs: <code>coord_x</code>, <code>coord_y</code>,
<code>id_tree</code>, and <code>id_time</code>. Any function that takes
these variables as input can be used for this purpose. However, as a
convenience, four &quot;spark&quot; functions are provided that can be used to create
functions that are suitable for this purpose: <code>spark_linear()</code>,
<code>spark_decay()</code>, <code>spark_random()</code>, and <code>spark_nothing()</code>.
</p>
<p>These functions are documented in their own help files. To give an example,
the default behaviour of <code>flametree_grow()</code> adds a random horizontal
displacement to each tree to give the impression of multiple trees growing
side by side. To suppress this horizontal displacement, set
<code>shift_x = spark_nothing()</code>.
</p>


<h3>Value</h3>

<p>The output of <code>flametree_grow()</code>' is a tibble with the following
columns: <code>coord_x</code>, <code>coord_y</code>, <code>id_tree</code>, <code>id_time</code>,
<code>id_path</code>, <code>id_leaf</code>, <code>id_pathtree</code>, <code>id_step</code>,
<code>seg_deg</code>, <code>seg_len</code>, <code>seg_col</code>, and <code>seg_wid</code>. Each
row in the tibble specifies a single point: every curved segment is defined
by three such rows.
</p>
<p>The two &quot;coord&quot; columns are numeric variables that specify the location of
the point itself. The &quot;id&quot; columns are used as indicators of various kinds.
The <code>id_tree</code> column contains numbers specifying which tree each point
belongs to, and similarly the <code>id_time</code> column is a numeric identifier
that specifies the time point at which the point was generated (i.e., the
iteration of the generative process). The <code>id_step</code> column contains
a number (0, 1, or 2) indicating whether the point is the first point, the
midpoint, or the end point of the relevant curved segment in a tree. In
addition, there are two identifier columns used to denote the segments
themselves. The <code>id_path</code> column is numeric, and assigns value 1 to
the &quot;first&quot; segment (i.e., the lowest part of the tree trunk) for every
tree, with values increasing numerically for each subsequent segment. Values
for <code>id_path</code> will uniquely identify a segment within a tree, but when
multiple trees are generated there will be multiple segments that have the
same <code>id_path</code> value. If a unique identifier across trees is needed,
use the <code>id_pathtree</code> column, which is a character vector constructed
by pasting the <code>id_path</code> and <code>id_tree</code> values into a string, with
an underscore as the separator character.
</p>
<p>In addition to the two coordinate columns and the six identifier columns,
the data generated by <code>flametree_grow()</code> contains four &quot;seg&quot; columns
that are intended to map onto different visual characteristics of a plot.
The <code>seg_deg</code> column specifies the orientation of the segment, whereas
<code>seg_len</code> denotes the length of the segment, <code>seg_col</code> specifies
the colour (as a numeric value that could be interpreted by a palette), and
<code>seg_wid</code> specifies the width of the segment. Note that this information
use used differently by the <code>flametree_plot()</code> function, depending on
what style of plot is generated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># flametree data structure with default parameters
flametree_grow()

# setting time = 10 runs the generative process
# longer resulting in a table with more rows
flametree_grow(time = 10)

# default behaviour is to randomly displace trees
# by random horizontal perturbation: to switch this
# off use the spark_nothing() function
flametree_grow(shift_x = spark_nothing())

</code></pre>

<hr>
<h2 id='flametree_plot'>Create a plot from a flametree data frame</h2><span id='topic+flametree_plot'></span>

<h3>Description</h3>

<p>Create a plot from a flametree data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flametree_plot(
  data,
  background = "black",
  palette = c("#1E2640", "#F3EAC0", "#DC9750", "#922C40"),
  style = "plain"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flametree_plot_+3A_data">data</code></td>
<td>
<p>The data frame specifying the flametree</p>
</td></tr>
<tr><td><code id="flametree_plot_+3A_background">background</code></td>
<td>
<p>The background colour of the image</p>
</td></tr>
<tr><td><code id="flametree_plot_+3A_palette">palette</code></td>
<td>
<p>A vector of colours</p>
</td></tr>
<tr><td><code id="flametree_plot_+3A_style">style</code></td>
<td>
<p>Style of tree to draw</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>flametree_plot()</code> function provides several ways to
visualise the data created by the generative system implemented by
<code>flametree_grow()</code>. The <code>background</code> argument sets the background
colour of the image, and should either be a string specifying an RGB hex
colour (e.g., &quot;#000000&quot;) or the of a colour recognised by R (see the
<code>colours()</code> function for details). Analogously, the <code>palette</code>
argument should be a vector of colours. However, the <code>palette</code> argument
is  interpreted slightly differently depending on which style of plot is
created, discussed below. To set the <code>style</code> of the resulting plot,
pass one of the following style names: &quot;plain&quot; (the default), &quot;voronoi&quot;,
&quot;wisp&quot;, &quot;nativeflora&quot;, &quot;minimal&quot;, or &quot;themegray&quot;.
</p>
<p>Plots in the &quot;plain&quot; style have the following properties. Branches of
the trees vary in width using the <code>seg_wid</code> data column. Each branch
is shown as a curved segment created using <code>geom_bezier2()</code>, and the
colour of the segments is mapped to the <code>seg_col</code> column in the data.
No leaves are drawn. In this style, the elements of the <code>palette</code> are
used to create a continuous n-colour gradient using
<code>scale_colour_gradientn()</code>.
</p>
<p>Plots in the &quot;voronoi&quot; style draw the shape of the tree the same way as
the plain style, except that the segments do not vary in colour and are
rendered using <code>geom_bezier()</code> instead of <code>geom_bezier2()</code>. Unlike
the plain style, stylised &quot;leaves&quot; are drawn by constructing a Voronoi
tesselation of the terminal nodes in the tree. Note that computing the
tesselation is computationally expensive and this will likely produce
errors if there are too many nodes (typically when the <code>time</code> parameter
to <code>flametree_grow()</code> is large). The interpretation of the
<code>palette</code> argument is slightly different: the first element of the
palette is used to set the colour of the trees, and the rest of the palette
colours are used to create the gradient palette used to colour the tiles
depicted in the Voronoi tesselation.
</p>
<p>The <code>style = "nativeflora"</code> style creates a plot in which tree branches
are rendered as thin segments, with a proportion of those segments removed,
and small points are drawn at the end of each terminal segment. The width of
the branches does not vary (i.e., <code>seg_wid</code> is ignored) and the colour
of the branches is constant within tree, but does vary across trees, ignoring
the continuous valued <code>seg_col</code> variable and using only the
<code>id_tree</code> variable to do so. As with the plain style, the
<code>palette</code> colours are used to define an n-colour gradient.
</p>
<p>The &quot;wisp&quot; style is similar to nativeflora, but no segments are removed, and
the wdith of the branches is mapped to <code>seg_wid</code>. It only uses the first
two elements of <code>palette</code>: the first element specifies the colour of the
branches, and the second element specifies the colour of the leaf dots.
</p>
<p>The final two styles are simplifications of other styles. The &quot;minimal&quot;
style is similar to the plain style but does not use curved segments, relying
on <code>geom_path()</code> to draw the branches. The &quot;themegray&quot; style does this
too, but it ignores the <code>palette</code> argument entirely, rendering the trees
in black, set against the default gray background specified by the ggplot2
<code>theme_gray()</code> function.
</p>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the default tree in the plain style
flametree_grow() %&gt;% flametree_plot()

# 10 trees drawn in the nativeflora style
flametree_grow(trees = 10, shift_x = spark_nothing()) %&gt;%
  flametree_plot(style = "nativeflora")

# changing the palette
shades &lt;- c("#A06AB4", "#FFD743", "#07BB9C", "#D773A2")
flametree_grow() %&gt;% flametree_plot(palette = shades)

</code></pre>

<hr>
<h2 id='flametree_save'>Save the plot</h2><span id='topic+flametree_save'></span>

<h3>Description</h3>

<p>Save the plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flametree_save(plot, filename, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flametree_save_+3A_plot">plot</code></td>
<td>
<p>The ggplot object</p>
</td></tr>
<tr><td><code id="flametree_save_+3A_filename">filename</code></td>
<td>
<p>The path to the file</p>
</td></tr>
<tr><td><code id="flametree_save_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to ggsave</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>flametree_save()</code> function provides a very thin wrapper
around the <code>ggsave()</code> function from ggplot2. It reverses the order of
the first two arguments: the plot argument comes before filename, in order
to be more pipe-friendly. The second thing it does is inspect the plot
object to determine the background colour, and ensures that colour is also
used to specify the background colour for the graphics device (e.g., the
bg argument to <code>png()</code>). The reason for doing this is that plots
created using <code>flametree_plot()</code> typically force the coordinates to be
on the same scale using <code>coord_equal()</code>. As a consequence, if the
aspect ratio of the image differs from the aspect ratio of the ggplot there
will be sections of the image that show the background colour of the graphics
device rather than the background colour specified by the ggplot object. By
overriding the default behaviour of <code>ggsave()</code>, the
<code>flametree_save()</code> function ensures that the image has the same
background colour everywhere.
</p>


<h3>Value</h3>

<p>Invisibly returns NULL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# typical usage
flametree_grow(trees = 5, time = 8) %&gt;%
  flametree_plot(style = "voronoi") %&gt;%
  flametree_save(filename = "~/Desktop/myfile.png")

# passing additional arguments to ggsave()
flametree_grow(trees = 5, time = 8) %&gt;%
  flametree_plot(style = "voronoi") %&gt;%
  flametree_save(
    filename = "~/Desktop/myfile.png",
    height = 8,
    width = 8
  )

## End(Not run)

</code></pre>

<hr>
<h2 id='sparks'>Spark functions to control tree growth</h2><span id='topic+sparks'></span><span id='topic+spark_linear'></span><span id='topic+spark_decay'></span><span id='topic+spark_random'></span><span id='topic+spark_nothing'></span>

<h3>Description</h3>

<p>Spark functions to control tree growth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spark_linear(x = 0, y = 0, tree = 0, time = 0, constant = 0)

spark_decay(x = 0, y = 0, tree = 0, time = 0, multiplier = 2, constant = 0)

spark_random(multiplier = 3, constant = 0)

spark_nothing()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparks_+3A_x">x</code></td>
<td>
<p>Weight given to the horizontal co-ordinate</p>
</td></tr>
<tr><td><code id="sparks_+3A_y">y</code></td>
<td>
<p>Weight given to the horizontal co-ordinate</p>
</td></tr>
<tr><td><code id="sparks_+3A_tree">tree</code></td>
<td>
<p>Weight given to the tree number</p>
</td></tr>
<tr><td><code id="sparks_+3A_time">time</code></td>
<td>
<p>Weight given to the time point</p>
</td></tr>
<tr><td><code id="sparks_+3A_constant">constant</code></td>
<td>
<p>Constant value to be added to the output</p>
</td></tr>
<tr><td><code id="sparks_+3A_multiplier">multiplier</code></td>
<td>
<p>Scaling parameter that multiplies the output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some arguments to <code>flametree_grow()</code> take numeric input, but
<code>seg_col</code>, <code>seg_wid</code>, <code>shift_x</code>, and <code>shift_y</code> all
take functions as their input, and are used to
control how the colours (<code>seg_col</code>) and width (<code>seg_wid</code>) of the
segments are created, as well as the horizontal (<code>shift_x</code>) and
vertical (<code>shift_y</code>) displacement of the trees are generated. Functions
passed to these arguments take four inputs: <code>coord_x</code>, <code>coord_y</code>,
<code>id_tree</code>, and <code>id_time</code> as input. Any function that takes
these variables as input and produces a numeric vector of the same length
as the input can be used for this purpose. However, as a
convenience, four &quot;spark&quot; functions are provided that can be used to create
functions that are suitable for this purpose: <code>spark_linear()</code>,
<code>spark_decay()</code>, <code>spark_random()</code>, and <code>spark_nothing()</code>.
Arguments passed to one of the spark functions determine the specific
function is generated. For example, <code>spark_linear()</code> can be used to
construct any linear combination of the inputs:
<code>spark_linear(x = 3, y = 2)</code> would return a function that computes
the sum <code>(3 * coord_x) + (2 * coord_y)</code>. Different values provided as
input produce different linear functions. Analogously, <code>spark_decay()</code>
returns functions that are exponentially decaying functions of a linear
combination of inputs. The <code>spark_random()</code> generator can be used to
generate functions that return random values, and <code>spark_nothing()</code>
produces a function that always returns zero regardless of input.
</p>


<h3>Value</h3>

<p>A function that takes <code>coord_x</code>, <code>coord_y</code>, <code>id_tree</code>,
and <code>id_time</code> as input, and returns a numeric vector as output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># returns a linear function of x and y
spark_linear(x = 3,  y = 2)

# returns a function of time that decays
# exponentially to an asymptote
spark_decay(time = .1, constant = .1)

# returns a numeric vector containing
# copies of the same uniform random number
# constrained to lie between -2.5 and 2.5
spark_random(multiplier = 5)

# returns a function that always produces
# a vector of zeros
spark_nothing()

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
