<!DOCTYPE html><html lang="en"><head><title>Help for package hgwrr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hgwrr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hgwrr-package'><p>HGWR: Hierarchical and Geographically Weighted Regression</p></a></li>
<li><a href='#coef.hgwrm'><p>Get estimated coefficients.</p></a></li>
<li><a href='#fitted.hgwrm'><p>Get fitted response.</p></a></li>
<li><a href='#logLik.hgwrm'><p>Log likelihood function</p></a></li>
<li><a href='#make_dummy'><p>Make Dummy Variables</p></a></li>
<li><a href='#mulsam.test'><p>Simulated Spatial Multisampling Data For Test (DataFrame)</p></a></li>
<li><a href='#multisampling'><p>Large Scale Simulated Spatial Multisampling Data (DataFrame)</p></a></li>
<li><a href='#print_table_md'><p>Print a character matrix as a table.</p></a></li>
<li><a href='#print.hgwrm'><p>Print description of a <code>hgwrm</code> object.</p></a></li>
<li><a href='#print.spahetbootres'><p>Print the result of spatial heterogeneity test</p></a></li>
<li><a href='#print.summary.hgwrm'><p>Print summary of an <code>hgwrm</code> object.</p></a></li>
<li><a href='#residuals.hgwrm'><p>Get residuals.</p></a></li>
<li><a href='#spatial_hetero_test'><p>Generic method to test spatial heterogeneity</p></a></li>
<li><a href='#spatial_hetero_test_data'><p>Test the spatial heterogeneity in data based on permutation.</p></a></li>
<li><a href='#spatial_hetero_test.hgwrm'><p>Hierarchical and Geographically Weighted Regression</p></a></li>
<li><a href='#summary.hgwrm'><p>Summary an <code>hgwrm</code> object.</p></a></li>
<li><a href='#wuhan.hp'><p>Wuhan Second-hand House Price and POI Data (DataFrame)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Hierarchical and Geographically Weighted Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-15</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yigong Hu &lt;yigong.hu@bristol.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>This model divides coefficients into three types,
        i.e., local fixed effects, global fixed effects, and random effects (Hu et al., 2022)&lt;<a href="https://doi.org/10.1177%2F23998083211063885">doi:10.1177/23998083211063885</a>&gt;.
        If data have spatial hierarchical structures (especially are overlapping on some locations),
        it is worth trying this model to reach better fitness.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/HPDell/hgwrr/">https://github.com/HPDell/hgwrr/</a>, <a href="https://hpdell.github.io/hgwrr/">https://hpdell.github.io/hgwrr/</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.8)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), sf, stats, utils, MASS</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), furrr, progressr,</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse, ggplot2, tmap, lme4, spdep, GWmodel</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-15 16:39:59 UTC; yigong</td>
</tr>
<tr>
<td>Author:</td>
<td>Yigong Hu [aut, cre],
  Richard Harris [aut],
  Richard Timmerman [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-16 11:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='hgwrr-package'>HGWR: Hierarchical and Geographically Weighted Regression</h2><span id='topic+hgwrr-package'></span>

<h3>Description</h3>

<p>An R and C++ implementation of Hierarchical and Geographically Weighted
Regression (HGWR) model is provided in this package. This model divides
coefficients into three types: local fixed effects, global fixed effects,
and random effects. If data have spatial hierarchical structures
(especially are overlapping on some locations),
it is worth trying this model to reach better fitness.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> hgwrr</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Hierarchical and Geographically Weighted Regression</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.6-1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-11-15</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person(given = "Yigong",
                    family = "Hu",
                    role = c("aut", "cre"),
                    email = "yigong.hu@bristol.ac.uk"),
             person(given = "Richard",
                    family = "Harris",
                    role = "aut"),
             person(given = "Richard",
                    family = "Timmerman",
                    role = "aut"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Yigong Hu &lt;yigong.hu@bristol.ac.uk&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> This model divides coefficients into three types,
        i.e., local fixed effects, global fixed effects, and random effects (Hu et al., 2022)&lt;doi:10.1177/23998083211063885&gt;.
        If data have spatial hierarchical structures (especially are overlapping on some locations),
        it is worth trying this model to reach better fitness.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/HPDell/hgwrr/, https://hpdell.github.io/hgwrr/</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> Rcpp (&gt;= 1.0.8)</td>
</tr>
<tr>
 <td style="text-align: left;">
LinkingTo: </td><td style="text-align: left;"> Rcpp, RcppArmadillo</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.5.0), sf, stats, utils, MASS</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> knitr,
rmarkdown,
testthat (&gt;= 3.0.0),
furrr,
progressr,</td>
</tr>
<tr>
 <td style="text-align: left;">
SystemRequirements: </td><td style="text-align: left;"> GNU make</td>
</tr>
<tr>
 <td style="text-align: left;">
Roxygen: </td><td style="text-align: left;"> list(markdown = TRUE)</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 7.2.3</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
Config/Needs/website: </td><td style="text-align: left;"> tidyverse,
ggplot2,
tmap,
lme4,
spdep,
GWmodel</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Yigong Hu [aut, cre],
  Richard Harris [aut],
  Richard Timmerman [aut]</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Note</h3>

<p>Acknowledgement:
We gratefully acknowledge support from China Scholarship Council.
</p>


<h3>Author(s)</h3>

<p>Yigong Hu, Richard Harris, Richard Timmerman
</p>


<h3>References</h3>

<p>Hu, Y., Lu, B., Ge, Y., Dong, G., 2022.
Uncovering spatial heterogeneity in real estate prices via
combined hierarchical linear model and geographically weighted regression.
Environment and Planning B: Urban Analytics and City Science.
<a href="https://doi.org/10.1177/23998083211063885">doi:10.1177/23998083211063885</a>
</p>

<hr>
<h2 id='coef.hgwrm'>Get estimated coefficients.</h2><span id='topic+coef.hgwrm'></span>

<h3>Description</h3>

<p>Get estimated coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hgwrm'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.hgwrm_+3A_object">object</code></td>
<td>
<p>An <code>hgwrm</code> object returned by <code><a href="#topic+hgwr">hgwr()</a></code>.</p>
</td></tr>
<tr><td><code id="coef.hgwrm_+3A_...">...</code></td>
<td>
<p>Parameter received from other functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>DataFrame</code> object consists of all estimated coefficients.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hgwr">hgwr()</a></code>, <code><a href="#topic+summary.hgwrm">summary.hgwrm()</a></code>, <code><a href="#topic+fitted.hgwrm">fitted.hgwrm()</a></code> and <code><a href="#topic+residuals.hgwrm">residuals.hgwrm()</a></code>.
</p>

<hr>
<h2 id='fitted.hgwrm'>Get fitted response.</h2><span id='topic+fitted.hgwrm'></span>

<h3>Description</h3>

<p>Get fitted response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hgwrm'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.hgwrm_+3A_object">object</code></td>
<td>
<p>An <code>hgwrm</code> object returned by <code><a href="#topic+hgwr">hgwr()</a></code>.</p>
</td></tr>
<tr><td><code id="fitted.hgwrm_+3A_...">...</code></td>
<td>
<p>Parameter received from other functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector consists of fitted response values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hgwr">hgwr()</a></code>, <code><a href="#topic+summary.hgwrm">summary.hgwrm()</a></code>, <code><a href="#topic+coef.hgwrm">coef.hgwrm()</a></code> and <code><a href="#topic+residuals.hgwrm">residuals.hgwrm()</a></code>.
</p>

<hr>
<h2 id='logLik.hgwrm'>Log likelihood function</h2><span id='topic+logLik.hgwrm'></span>

<h3>Description</h3>

<p>Log likelihood function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hgwrm'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.hgwrm_+3A_object">object</code></td>
<td>
<p>An <code>hgwrm</code> object.</p>
</td></tr>
<tr><td><code id="logLik.hgwrm_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>logLik</code> instance used for S3 method <code>logLik()</code>.
</p>

<hr>
<h2 id='make_dummy'>Make Dummy Variables</h2><span id='topic+make_dummy'></span><span id='topic+make_dummy_extract'></span><span id='topic+make_dummy_extract.character'></span><span id='topic+make_dummy_extract.factor'></span><span id='topic+make_dummy_extract.logical'></span><span id='topic+make_dummy_extract.default'></span>

<h3>Description</h3>

<p>Function <code>make_dummy</code>
converts categorical variables in a data frame to dummy variables.
</p>
<p>Function <code>make_dummy_extract</code>
converts a column to dummy variables if necessary
and assign appropriate names.
See the &quot;detail&quot; section for further information.
Users can define their own functions to allow the model
deal with some types of variables properly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_dummy(data)

make_dummy_extract(col, name)

## S3 method for class 'character'
make_dummy_extract(col, name)

## S3 method for class 'factor'
make_dummy_extract(col, name)

## S3 method for class 'logical'
make_dummy_extract(col, name)

## Default S3 method:
make_dummy_extract(col, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_dummy_+3A_data">data</code></td>
<td>
<p>The data frame from which dummy variables need to be extracted.</p>
</td></tr>
<tr><td><code id="make_dummy_+3A_col">col</code></td>
<td>
<p>A vector to extract dummy variables.</p>
</td></tr>
<tr><td><code id="make_dummy_+3A_name">name</code></td>
<td>
<p>The vector's name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>col</code> is a character vector,
the function will get unique values of its elements
and leave out the last one.
Then, all the unique values are combined with the <code>name</code> argument
as names of new columns.
</p>
<p>If <code>col</code> is a factor vector,
the function will get its levels and leave out the last one.
Then, all level labels are combined with the <code>name</code> argument
as names of new columns.
</p>
<p>If <code>col</code> is a logical vector,
the function will convert it to a numeric vector
with value <code>TRUE</code> mapped to <code>1</code> and <code>FALSE</code> to <code>0</code>.
</p>
<p>If <code>col</code> is of other types,
the default behaviour for extracting dummy variables is
just to copy the original value and try to convert it to numeric values.
</p>


<h3>Value</h3>

<p>The data frame with extracted dummy variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_dummy(iris["Species"])

make_dummy_extract(iris$Species, "Species")

make_dummy_extract(c("top", "mid", "low", "mid", "top"), "level")

make_dummy_extract(factor(c("far", "near", "near")), "distance")

make_dummy_extract(c(TRUE, TRUE, FALSE), "sold")

</code></pre>

<hr>
<h2 id='mulsam.test'>Simulated Spatial Multisampling Data For Test (DataFrame)</h2><span id='topic+mulsam.test'></span>

<h3>Description</h3>

<p>A simulation data set for testing use of spatial hierarchical structure and
samples overlapping on certain locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mulsam.test)</code></pre>


<h3>Format</h3>

<p>A list of three items called &quot;data&quot;, &quot;coords&quot; and &quot;beta&quot;.
Item &quot;data&quot; is a data frame with 873 observations at 25 locations
and the following 6 variables.
</p>

<dl>
<dt><code>y</code></dt><dd><p>a numeric vector, dependent variable <code class="reqn">y</code></p>
</dd>
<dt><code>g1</code></dt><dd><p>a numeric vector, group level independent variable <code class="reqn">g_1</code></p>
</dd>
<dt><code>g2</code></dt><dd><p>a numeric vector, group level independent variable <code class="reqn">g_2</code></p>
</dd>
<dt><code>z1</code></dt><dd><p>a numeric vector, sample level independent variable <code class="reqn">z_1</code></p>
</dd>
<dt><code>x1</code></dt><dd><p>a numeric vector, sample level independent variable <code class="reqn">x_1</code></p>
</dd>
<dt><code>group</code></dt><dd><p>a numeric vector, group id of each sample</p>
</dd>
</dl>

<p>where <code>g1</code> and <code>g2</code> are used to estimate local fixed effects;
<code>x1</code> is used to estimate global fixed effects
and <code>z1</code> is used to estimate random effects.
</p>


<h3>Author(s)</h3>

<p>Yigong Hu <a href="mailto:yigong.hu@bristol.ac.uk">yigong.hu@bristol.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mulsam.test)
hgwr(formula = y ~ L(g1 + g2) + x1 + (z1 | group),
     data = mulsam.test$data,
     coords = mulsam.test$coords,
     bw = 10, kernel = "bisquared")
</code></pre>

<hr>
<h2 id='multisampling'>Large Scale Simulated Spatial Multisampling Data (DataFrame)</h2><span id='topic+multisampling'></span>

<h3>Description</h3>

<p>A simulation data of spatial hierarchical structure and
samples overlapping on certain locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(multisampling)</code></pre>


<h3>Format</h3>

<p>A list of three items called &quot;data&quot;, &quot;coords&quot; and &quot;beta&quot;.
Item &quot;data&quot; is a data frame with 21434 observations at 625 locations
and the following 6 variables.
</p>

<dl>
<dt><code>y</code></dt><dd><p>a numeric vector, dependent variable <code class="reqn">y</code></p>
</dd>
<dt><code>g1</code></dt><dd><p>a numeric vector, group level independent variable <code class="reqn">g_1</code></p>
</dd>
<dt><code>g2</code></dt><dd><p>a numeric vector, group level independent variable <code class="reqn">g_2</code></p>
</dd>
<dt><code>z1</code></dt><dd><p>a numeric vector, sample level independent variable <code class="reqn">z_1</code></p>
</dd>
<dt><code>x1</code></dt><dd><p>a numeric vector, sample level independent variable <code class="reqn">x_1</code></p>
</dd>
<dt><code>group</code></dt><dd><p>a numeric vector, group id of each sample</p>
</dd>
</dl>

<p>where <code>g1</code> and <code>g2</code> are used to estimate local fixed effects;
<code>x1</code> is used to estimate global fixed effects
and <code>z1</code> is used to estimate random effects.
</p>


<h3>Author(s)</h3>

<p>Yigong Hu <a href="mailto:yigong.hu@bristol.ac.uk">yigong.hu@bristol.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(multisampling)
hgwr(formula = y ~ L(g1 + g2) + x1 + (z1 | group),
     data = multisampling$data,
     coords = multisampling$coords,
     bw = 32)

## End(Not run)
</code></pre>

<hr>
<h2 id='print_table_md'>Print a character matrix as a table.</h2><span id='topic+print_table_md'></span>

<h3>Description</h3>

<p>Print a character matrix as a table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_table_md(
  x,
  col_sep = "",
  header_sep = "",
  row_begin = "",
  row_end = "",
  table_before = NA_character_,
  table_after = NA_character_,
  table_style = c("plain", "md", "latex", "booktabs"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_table_md_+3A_x">x</code></td>
<td>
<p>A character matrix.</p>
</td></tr>
<tr><td><code id="print_table_md_+3A_col_sep">col_sep</code></td>
<td>
<p>Column separator. Default to <code>""</code>.</p>
</td></tr>
<tr><td><code id="print_table_md_+3A_header_sep">header_sep</code></td>
<td>
<p>Header separator. Default to <code>"-"</code>.
If <code>header_sep</code> only contains one character,
it will be repeated for each column.
If it contains more than one character,
it will be printed below the first row.</p>
</td></tr>
<tr><td><code id="print_table_md_+3A_row_begin">row_begin</code></td>
<td>
<p>Character at the beginning of each row.
Default to <code>col_sep</code>.</p>
</td></tr>
<tr><td><code id="print_table_md_+3A_row_end">row_end</code></td>
<td>
<p>Character at the ending of each row.
Default to <code>col_sep</code>.</p>
</td></tr>
<tr><td><code id="print_table_md_+3A_table_before">table_before</code></td>
<td>
<p>Characters to be printed before the table.</p>
</td></tr>
<tr><td><code id="print_table_md_+3A_table_after">table_after</code></td>
<td>
<p>Characters to be printed after the table.</p>
</td></tr>
<tr><td><code id="print_table_md_+3A_table_style">table_style</code></td>
<td>
<p>Name of pre-defined style.
Possible values are <code>"plain"</code>, <code>"md"</code>, <code>"latex"</code>, or <code>"booktabs"</code>.
Default to <code>"plain"</code>.</p>
</td></tr>
<tr><td><code id="print_table_md_+3A_...">...</code></td>
<td>
<p>Additional style control arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>table_style</code> is specified, <code>col_sep</code>, <code>header_sep</code>, <code>row_begin</code>
and <code>row_end</code> would not take effects.
Because this function will automatically set their values.
For each possible value of <code>table_style</code>, its corresponding style settings
are shown in the following table.
</p>

<table>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <strong><code>plain</code></strong> </td><td style="text-align: left;"> <strong><code>md</code></strong> </td><td style="text-align: left;"> <strong><code>latex</code></strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>col_sep</code>    </td><td style="text-align: left;"> <code>""</code>             </td><td style="text-align: left;"> <code>"|"</code>         </td><td style="text-align: left;"> <code>"&amp;"</code>            </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>header_sep</code> </td><td style="text-align: left;"> <code>""</code>             </td><td style="text-align: left;"> <code>"-"</code>         </td><td style="text-align: left;"> <code>""</code>             </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>row_begin</code>  </td><td style="text-align: left;"> <code>""</code>             </td><td style="text-align: left;"> <code>"|"</code>         </td><td style="text-align: left;"> <code>""</code>             </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>row_end</code>    </td><td style="text-align: left;"> <code>""</code>             </td><td style="text-align: left;"> <code>"|"</code>         </td><td style="text-align: left;"> <code>"\\"</code>
</td>
</tr>

</table>

<p>In this function, characters are right padded by spaces.
</p>


<h3>Value</h3>

<p>No return.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.hgwrm">print.hgwrm()</a></code>, <code><a href="#topic+summary.hgwrm">summary.hgwrm()</a></code>.
</p>

<hr>
<h2 id='print.hgwrm'>Print description of a <code>hgwrm</code> object.</h2><span id='topic+print.hgwrm'></span>

<h3>Description</h3>

<p>Print description of a <code>hgwrm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hgwrm'
print(x, decimal.fmt = "%.6f", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.hgwrm_+3A_x">x</code></td>
<td>
<p>An <code>hgwrm</code> object returned by <code><a href="#topic+hgwr">hgwr()</a></code>.</p>
</td></tr>
<tr><td><code id="print.hgwrm_+3A_decimal.fmt">decimal.fmt</code></td>
<td>
<p>The format string passing to <code><a href="base.html#topic+sprintf">base::sprintf()</a></code>.</p>
</td></tr>
<tr><td><code id="print.hgwrm_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+print_table_md">print_table_md</a></code>
</p>

<dl>
<dt><code>col_sep</code></dt><dd><p>Column separator. Default to <code>""</code>.</p>
</dd>
<dt><code>header_sep</code></dt><dd><p>Header separator. Default to <code>"-"</code>.
If <code>header_sep</code> only contains one character,
it will be repeated for each column.
If it contains more than one character,
it will be printed below the first row.</p>
</dd>
<dt><code>row_begin</code></dt><dd><p>Character at the beginning of each row.
Default to <code>col_sep</code>.</p>
</dd>
<dt><code>row_end</code></dt><dd><p>Character at the ending of each row.
Default to <code>col_sep</code>.</p>
</dd>
<dt><code>table_before</code></dt><dd><p>Characters to be printed before the table.</p>
</dd>
<dt><code>table_after</code></dt><dd><p>Characters to be printed after the table.</p>
</dd>
<dt><code>table_style</code></dt><dd><p>Name of pre-defined style.
Possible values are <code>"plain"</code>, <code>"md"</code>, <code>"latex"</code>, or <code>"booktabs"</code>.
Default to <code>"plain"</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>No return.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.hgwrm">summary.hgwrm()</a></code>, <code><a href="#topic+print_table_md">print_table_md()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mulsam.test)
model &lt;- hgwr(
  formula = y ~ L(g1 + g2) + x1 + (z1 | group),
  data = mulsam.test$data,
  coords = mulsam.test$coords,
  bw = 10
)
print(model)
print(model, table.style = "md")

</code></pre>

<hr>
<h2 id='print.spahetbootres'>Print the result of spatial heterogeneity test</h2><span id='topic+print.spahetbootres'></span>

<h3>Description</h3>

<p>Print the result of spatial heterogeneity test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spahetbootres'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.spahetbootres_+3A_x">x</code></td>
<td>
<p>A <code>spahetbootres</code> object.</p>
</td></tr>
<tr><td><code id="print.spahetbootres_+3A_...">...</code></td>
<td>
<p>Other unused arguments.</p>
</td></tr>
</table>

<hr>
<h2 id='print.summary.hgwrm'>Print summary of an <code>hgwrm</code> object.</h2><span id='topic+print.summary.hgwrm'></span>

<h3>Description</h3>

<p>Print summary of an <code>hgwrm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.hgwrm'
print(x, decimal.fmt = "%.6f", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.hgwrm_+3A_x">x</code></td>
<td>
<p>An object returned from <code><a href="#topic+summary.hgwrm">summary.hgwrm()</a></code>.</p>
</td></tr>
<tr><td><code id="print.summary.hgwrm_+3A_decimal.fmt">decimal.fmt</code></td>
<td>
<p>The format string passing to <code><a href="base.html#topic+sprintf">base::sprintf()</a></code>.</p>
</td></tr>
<tr><td><code id="print.summary.hgwrm_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+print_table_md">print_table_md</a></code>
</p>

<dl>
<dt><code>col_sep</code></dt><dd><p>Column separator. Default to <code>""</code>.</p>
</dd>
<dt><code>header_sep</code></dt><dd><p>Header separator. Default to <code>"-"</code>.
If <code>header_sep</code> only contains one character,
it will be repeated for each column.
If it contains more than one character,
it will be printed below the first row.</p>
</dd>
<dt><code>row_begin</code></dt><dd><p>Character at the beginning of each row.
Default to <code>col_sep</code>.</p>
</dd>
<dt><code>row_end</code></dt><dd><p>Character at the ending of each row.
Default to <code>col_sep</code>.</p>
</dd>
<dt><code>table_before</code></dt><dd><p>Characters to be printed before the table.</p>
</dd>
<dt><code>table_after</code></dt><dd><p>Characters to be printed after the table.</p>
</dd>
<dt><code>table_style</code></dt><dd><p>Name of pre-defined style.
Possible values are <code>"plain"</code>, <code>"md"</code>, <code>"latex"</code>, or <code>"booktabs"</code>.
Default to <code>"plain"</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>No return.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.hgwrm">summary.hgwrm()</a></code>, <code><a href="#topic+print_table_md">print_table_md()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mulsam.test)
model &lt;- hgwr(
  formula = y ~ L(g1 + g2) + x1 + (z1 | group),
  data = mulsam.test$data,
  coords = mulsam.test$coords,
  bw = 10
)
summary(model)

</code></pre>

<hr>
<h2 id='residuals.hgwrm'>Get residuals.</h2><span id='topic+residuals.hgwrm'></span>

<h3>Description</h3>

<p>Get residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hgwrm'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.hgwrm_+3A_object">object</code></td>
<td>
<p>An <code>hgwrm</code> object returned by <code><a href="#topic+hgwr">hgwr()</a></code>.</p>
</td></tr>
<tr><td><code id="residuals.hgwrm_+3A_...">...</code></td>
<td>
<p>Parameter received from other functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector consists of residuals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hgwr">hgwr()</a></code>, <code><a href="#topic+summary.hgwrm">summary.hgwrm()</a></code>, <code><a href="#topic+coef.hgwrm">coef.hgwrm()</a></code> and <code><a href="#topic+fitted.hgwrm">fitted.hgwrm()</a></code>.
</p>

<hr>
<h2 id='spatial_hetero_test'>Generic method to test spatial heterogeneity</h2><span id='topic+spatial_hetero_test'></span><span id='topic+spatial_hetero_test.default'></span><span id='topic+spatial_hetero_test.matrix'></span><span id='topic+spatial_hetero_test.numeric'></span><span id='topic+spatial_hetero_test.vector'></span><span id='topic+spatial_hetero_test.data.frame'></span><span id='topic+spatial_hetero_test.sf'></span>

<h3>Description</h3>

<p>Generic method to test spatial heterogeneity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial_hetero_test(x, ...)

## Default S3 method:
spatial_hetero_test(x, ...)

## S3 method for class 'matrix'
spatial_hetero_test(x, coords, ...)

## S3 method for class 'numeric'
spatial_hetero_test(x, coords, ...)

## S3 method for class 'vector'
spatial_hetero_test(x, coords, ...)

## S3 method for class 'data.frame'
spatial_hetero_test(x, coords, ...)

## S3 method for class 'sf'
spatial_hetero_test(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatial_hetero_test_+3A_x">x</code></td>
<td>
<p>The data to be tested.</p>
</td></tr>
<tr><td><code id="spatial_hetero_test_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+spatial_hetero_test_data">spatial_hetero_test_data</a></code>, <code><a href="#topic+spatial_hetero_test_data">spatial_hetero_test_data</a></code>
</p>

<dl>
<dt><code>resample</code></dt><dd><p>The total times of resampling with replacement.
Default to 5000.</p>
</dd>
<dt><code>poly</code></dt><dd><p>The number of polynomial terms used by the polynomial estimator.
Default to 2.</p>
</dd>
<dt><code>bw</code></dt><dd><p>The adaptive bandwidth used by the polynomial estimator.
Default to 10.</p>
</dd>
<dt><code>kernel</code></dt><dd><p>The kernel function used by the polynomial estimator.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>The verbosity level. Default to 0.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="spatial_hetero_test_+3A_coords">coords</code></td>
<td>
<p>The coordinates used for testing.
Accepts a matrix or vector.
For matrix, it needs to have the same number of rows as <code>x</code>.
For vector, it indicates the columns in <code>x</code>
and the actual coordinates will be taken from <code>x</code>.</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>spatial_hetero_test(default)</code>: Default behavior.
</p>
</li>
<li> <p><code>spatial_hetero_test(matrix)</code>: For the matrix, <code>coords</code> is necessary.
</p>
</li>
<li> <p><code>spatial_hetero_test(numeric)</code>: Takes <code>x</code> as values of a series variables stored by column,
and <code>coords</code> as coordinates for each row in <code>x</code>.
</p>
</li>
<li> <p><code>spatial_hetero_test(vector)</code>: Takes <code>x</code> as values of the variable,
and <code>coords</code> as coordinates for each element in <code>x</code>.
</p>
</li>
<li> <p><code>spatial_hetero_test(data.frame)</code>: Takes <code>x</code> as variable values (each column is a variable),
and <code>coords</code> as coordinates for each row in <code>x</code>.
</p>
</li>
<li> <p><code>spatial_hetero_test(sf)</code>: For the <code>sf</code> object, coordinates of centroids are used.
Only the numerical columns are tested.
</p>
</li></ul>

<hr>
<h2 id='spatial_hetero_test_data'>Test the spatial heterogeneity in data based on permutation.</h2><span id='topic+spatial_hetero_test_data'></span>

<h3>Description</h3>

<p>Test the spatial heterogeneity in data based on permutation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial_hetero_test_data(
  x,
  coords,
  ...,
  resample = 5000,
  poly = 2,
  bw = 10,
  kernel = c("bisquared", "gaussian"),
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatial_hetero_test_data_+3A_x">x</code></td>
<td>
<p>A matrix of data to be tested. Each column is a variable.</p>
</td></tr>
<tr><td><code id="spatial_hetero_test_data_+3A_coords">coords</code></td>
<td>
<p>A matrix of coordinates.</p>
</td></tr>
<tr><td><code id="spatial_hetero_test_data_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="spatial_hetero_test_data_+3A_resample">resample</code></td>
<td>
<p>The total times of resampling with replacement.
Default to 5000.</p>
</td></tr>
<tr><td><code id="spatial_hetero_test_data_+3A_poly">poly</code></td>
<td>
<p>The number of polynomial terms used by the polynomial estimator.
Default to 2.</p>
</td></tr>
<tr><td><code id="spatial_hetero_test_data_+3A_bw">bw</code></td>
<td>
<p>The adaptive bandwidth used by the polynomial estimator.
Default to 10.</p>
</td></tr>
<tr><td><code id="spatial_hetero_test_data_+3A_kernel">kernel</code></td>
<td>
<p>The kernel function used by the polynomial estimator.</p>
</td></tr>
<tr><td><code id="spatial_hetero_test_data_+3A_verbose">verbose</code></td>
<td>
<p>The verbosity level. Default to 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>spahetbootres</code> object of permutation-test results with the following items:
</p>

<dl>
<dt><code>vars</code></dt><dd><p>The names of variables.</p>
</dd>
<dt><code>t0</code></dt><dd><p>The value of the statistics on original values.</p>
</dd>
<dt><code>t</code></dt><dd><p>The value of the same statistics on permuted values.</p>
</dd>
<dt><code>p</code></dt><dd><p>The p-value for each variable.</p>
</dd>
</dl>

<p>Currently, variance is used as the statistics.
</p>

<hr>
<h2 id='spatial_hetero_test.hgwrm'>Hierarchical and Geographically Weighted Regression</h2><span id='topic+spatial_hetero_test.hgwrm'></span><span id='topic+hgwr'></span><span id='topic+hgwr.sf'></span><span id='topic+hgwr.data.frame'></span><span id='topic+hgwr_fit'></span>

<h3>Description</h3>

<p>A Hierarchical Linear Model (HLM) with group-level geographically weighted effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hgwrm'
spatial_hetero_test(
  x,
  round = 99,
  statistic = stat_glsw,
  parallel = FALSE,
  verbose = 0,
  ...
)

hgwr(
  formula,
  data,
  ...,
  bw = "CV",
  kernel = c("gaussian", "bisquared"),
  alpha = 0.01,
  eps_iter = 1e-06,
  eps_gradient = 1e-06,
  max_iters = 1e+06,
  max_retries = 1e+06,
  ml_type = c("D_Only", "D_Beta"),
  f_test = FALSE,
  verbose = 0
)

## S3 method for class 'sf'
hgwr(
  formula,
  data,
  ...,
  bw = "CV",
  kernel = c("gaussian", "bisquared"),
  alpha = 0.01,
  eps_iter = 1e-06,
  eps_gradient = 1e-06,
  max_iters = 1e+06,
  max_retries = 1e+06,
  ml_type = c("D_Only", "D_Beta"),
  f_test = FALSE,
  verbose = 0
)

## S3 method for class 'data.frame'
hgwr(
  formula,
  data,
  ...,
  coords,
  bw = "CV",
  kernel = c("gaussian", "bisquared"),
  alpha = 0.01,
  eps_iter = 1e-06,
  eps_gradient = 1e-06,
  max_iters = 1e+06,
  max_retries = 1e+06,
  ml_type = c("D_Only", "D_Beta"),
  f_test = FALSE,
  verbose = 0
)

hgwr_fit(
  formula,
  data,
  coords,
  bw = c("CV", "AIC"),
  kernel = c("gaussian", "bisquared"),
  alpha = 0.01,
  eps_iter = 1e-06,
  eps_gradient = 1e-06,
  max_iters = 1e+06,
  max_retries = 1e+06,
  ml_type = c("D_Only", "D_Beta"),
  f_test = FALSE,
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatial_hetero_test.hgwrm_+3A_x">x</code></td>
<td>
<p>An <code>hgwrm</code> object</p>
</td></tr>
<tr><td><code id="spatial_hetero_test.hgwrm_+3A_round">round</code></td>
<td>
<p>The number of times to sampling from model.</p>
</td></tr>
<tr><td><code id="spatial_hetero_test.hgwrm_+3A_statistic">statistic</code></td>
<td>
<p>A function used to calculate the statistics
on the original data and bootstrapped data.
Default to the variance of standardlised GLSW estimates.</p>
</td></tr>
<tr><td><code id="spatial_hetero_test.hgwrm_+3A_parallel">parallel</code></td>
<td>
<p>If TRUE, use <code>furrr</code> package to parallel.</p>
</td></tr>
<tr><td><code id="spatial_hetero_test.hgwrm_+3A_verbose">verbose</code></td>
<td>
<p>An integer value. Determine the log level.
Possible values are:
</p>

<dl>
<dt>0</dt><dd><p>no log is printed.</p>
</dd>
<dt>1</dt><dd><p>only logs in back-fitting are printed.</p>
</dd>
<dt>2</dt><dd><p>all logs are printed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="spatial_hetero_test.hgwrm_+3A_...">...</code></td>
<td>
<p>Further arguments for the specified type of <code>data</code>.</p>
</td></tr>
<tr><td><code id="spatial_hetero_test.hgwrm_+3A_formula">formula</code></td>
<td>
<p>A formula.
Its structure is similar to <code><a href="lme4.html#topic+lmer">lmer</a></code> function
in <strong>lme4</strong> package.
Models can be specified with the following form:
</p>
<div class="sourceCode r"><pre>response ~ L(glsw) + fixed + (random | group)
</pre></div>
<p>For more information, please see the <code>formula</code> subsection in details.</p>
</td></tr>
<tr><td><code id="spatial_hetero_test.hgwrm_+3A_data">data</code></td>
<td>
<p>The data.</p>
</td></tr>
<tr><td><code id="spatial_hetero_test.hgwrm_+3A_bw">bw</code></td>
<td>
<p>A numeric value. It is the value of bandwidth or <code>"CV"</code>.
In this stage this function only support adaptive bandwidth.
And its unit must be the number of nearest neighbours.
If <code>"CV"</code> is specified, the algorithm will automatically select an
optimized bandwidth value.</p>
</td></tr>
<tr><td><code id="spatial_hetero_test.hgwrm_+3A_kernel">kernel</code></td>
<td>
<p>A character value. It specify which kernel function is used
in GWR part. Possible values are
</p>

<dl>
<dt><code>gaussian</code></dt><dd><p>Gaussian kernel function <code class="reqn">k(d)=\exp\left(-\frac{d^2}{b^2}\right)</code></p>
</dd>
<dt><code>bisquared</code></dt><dd><p>Bi-squared kernel function. If <code class="reqn">d&lt;b</code> then <code class="reqn">k(d)=\left(1-\frac{d^2}{b^2}\right)^2</code> else <code class="reqn">k(d)=0</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="spatial_hetero_test.hgwrm_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value. It is the size of the first trial step in
maximum likelihood algorithm.</p>
</td></tr>
<tr><td><code id="spatial_hetero_test.hgwrm_+3A_eps_iter">eps_iter</code></td>
<td>
<p>A numeric value. Terminate threshold of back-fitting.</p>
</td></tr>
<tr><td><code id="spatial_hetero_test.hgwrm_+3A_eps_gradient">eps_gradient</code></td>
<td>
<p>A numeric value. Terminate threshold of
maximum likelihood algorithm.</p>
</td></tr>
<tr><td><code id="spatial_hetero_test.hgwrm_+3A_max_iters">max_iters</code></td>
<td>
<p>An integer value. The maximum of iteration.</p>
</td></tr>
<tr><td><code id="spatial_hetero_test.hgwrm_+3A_max_retries">max_retries</code></td>
<td>
<p>An integer value. If the algorithm tends to be diverge,
it stops automatically after trying <em>max_retires</em> times.</p>
</td></tr>
<tr><td><code id="spatial_hetero_test.hgwrm_+3A_ml_type">ml_type</code></td>
<td>
<p>An integer value. Represent which maximum likelihood
algorithm is used. Possible values are:
</p>

<dl>
<dt><code>D_Only</code></dt><dd><p>Only <code class="reqn">D</code> is specified by maximum likelihood.</p>
</dd>
<dt><code>D_Beta</code></dt><dd><p>Both <code class="reqn">D</code> and <code class="reqn">beta</code> is specified by maximum likelihood.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="spatial_hetero_test.hgwrm_+3A_f_test">f_test</code></td>
<td>
<p>A logical value. Determine whether to do F test on GLSW effects.
If <code>f_test=TURE</code>, there will be a <code>f_test</code> item in the returned object
showing the F test for each GLSW effect.</p>
</td></tr>
<tr><td><code id="spatial_hetero_test.hgwrm_+3A_coords">coords</code></td>
<td>
<p>A 2-column matrix.
It consists of coordinates for each group.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Effect Specification in Formula</h4>

<p>In the HGWR model, there are three types of effects specified by the
<code>formula</code> argument:
</p>

<dl>
<dt>Group-level spatially weighted (GLSW, aka. local fixed) effects</dt><dd><p>Effects wrapped by functional symbol <code>L</code>.</p>
</dd>
<dt>Sample-level random (SLR) effects</dt><dd><p>Effects specified outside the functional symbol <code>L</code> but to the left of symbol <code>|</code>.</p>
</dd>
<dt>Fixed effects</dt><dd><p>Other effects</p>
</dd>
</dl>

<p>For example, the following formula in the example of this function below is written as
</p>
<div class="sourceCode r"><pre>y ~ L(g1 + g2) + x1 + (z1 | group)
</pre></div>
<p>where <code>g1</code> and <code>g2</code> are GLSW effects,
<code>x1</code> is the fixed effects,
and <code>z1</code> is the SLR effects grouped by the group indicator <code>group</code>.
Note that SLR effects can only be specified once!
</p>



<h3>Value</h3>

<p>A list describing the model with following fields.
</p>

<dl>
<dt><code>gamma</code></dt><dd><p>Coefficients of group-level spatially weighted effects.</p>
</dd>
<dt><code>beta</code></dt><dd><p>Coefficients of fixed effects.</p>
</dd>
<dt><code>mu</code></dt><dd><p>Coefficients of sample-level random effects.</p>
</dd>
<dt><code>D</code></dt><dd><p>Variance-covariance matrix of sample-level random effects.</p>
</dd>
<dt><code>sigma</code></dt><dd><p>Variance of errors.</p>
</dd>
<dt><code>effects</code></dt><dd><p>A list including names of all effects.</p>
</dd>
<dt><code>call</code></dt><dd><p>Calling of this function.</p>
</dd>
<dt><code>frame</code></dt><dd><p>The DataFrame object sent to this call.</p>
</dd>
<dt><code>frame.parsed</code></dt><dd><p>Variables extracted from the data.</p>
</dd>
<dt><code>groups</code></dt><dd><p>Unique group labels extracted from the data.</p>
</dd>
<dt><code>f_test</code></dt><dd><p>A list of F test for GLSW effects. Only exists when <code>f_test=TRUE</code>. Each item contains the F value, degrees of freedom in the numerator, degrees of freedom in the denominator, and <code class="reqn">p</code> value of <code class="reqn">F&gt;F_\alpha</code>.</p>
</dd>
</dl>



<h3>Functions</h3>


<ul>
<li> <p><code>spatial_hetero_test(hgwrm)</code>: Test the spatial heterogeneity with bootstrapping.
</p>
</li>
<li> <p><code>hgwr_fit()</code>: Fit a HGWR model
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>data(mulsam.test)
hgwr(
  formula = y ~ L(g1 + g2) + x1 + (z1 | group),
  data = mulsam.test$data,
  coords = mulsam.test$coords,
  bw = 10
)

mod_Ftest &lt;- hgwr(
  formula = y ~ L(g1 + g2) + x1 + (z1 | group),
  data = mulsam.test$data,
  coords = mulsam.test$coords,
  bw = 10
)
summary(mod_Ftest)

</code></pre>

<hr>
<h2 id='summary.hgwrm'>Summary an <code>hgwrm</code> object.</h2><span id='topic+summary.hgwrm'></span>

<h3>Description</h3>

<p>Summary an <code>hgwrm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hgwrm'
summary(object, ..., test_hetero = FALSE, verbose = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.hgwrm_+3A_object">object</code></td>
<td>
<p>An <code>hgwrm</code> object returned from <code><a href="#topic+hgwr">hgwr()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.hgwrm_+3A_...">...</code></td>
<td>
<p>Other arguments passed from other functions.</p>
</td></tr>
<tr><td><code id="summary.hgwrm_+3A_test_hetero">test_hetero</code></td>
<td>
<p>Logical/list value.
Whether to test the spatial heterogeneity of GLSW effects.
If it is set to <code>FALSE</code>, the test will not be executed.
If it is set to <code>TRUE</code>, the test will be executed with default parameters
(see details below).
It accepts a list to enable the test with specified parameters.</p>
</td></tr>
<tr><td><code id="summary.hgwrm_+3A_verbose">verbose</code></td>
<td>
<p>An Integer value to control whether additional messages
during testing spatial heterogeneity should be reported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters used to perform test of spatial heterogeneity are
</p>

<dl>
<dt><code>bw</code></dt><dd><p>Bandwidth (unit: number of nearest neighbours) used to make spatial kernel density estimation. Default: <code>10</code>.</p>
</dd>
<dt><code>poly</code></dt><dd><p>The number of polynomial terms used in the local polynomial estimation. Default: <code>2</code>.</p>
</dd>
<dt><code>resample</code></dt><dd><p>Total resampling times. Default: <code>5000</code>.</p>
</dd>
<dt><code>kernel</code></dt><dd><p>The kernel function used in the local polynomial estimation. Options are <code>"gaussian"</code> and <code>"bisquared"</code>. Default: <code>"bisquared"</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list containing summary informations of this <code>hgwrm</code> object
with the following fields.
</p>

<dl>
<dt><code>diagnostic</code></dt><dd><p>A list of diagnostic information.</p>
</dd>
<dt><code>random.stddev</code></dt><dd><p>The standard deviation of random effects.</p>
</dd>
<dt><code>random.corr</code></dt><dd><p>The correlation matrix of random effects.</p>
</dd>
<dt><code>residuals</code></dt><dd><p>The residual vector.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+hgwr">hgwr()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mulsam.test)
m &lt;- hgwr(
  formula = y ~ L(g1 + g2) + x1 + (z1 | group),
  data = mulsam.test$data,
  coords = mulsam.test$coords,
  bw = 10
)
summary(m)
summary(m, test_hetero = TRUE)
summary(m, test_hetero = list(kernel = "gaussian"))

</code></pre>

<hr>
<h2 id='wuhan.hp'>Wuhan Second-hand House Price and POI Data (DataFrame)</h2><span id='topic+wuhan.hp'></span>

<h3>Description</h3>

<p>A data set of second-hand house price in Wuhan, China collected in 2018.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(multisampling)</code></pre>


<h3>Format</h3>

<p>A list of two items called &quot;data&quot; and &quot;coords&quot;.
Item &quot;data&quot; is a data frame with 13862 second-hand properties at 779 neighbourhoods
and the following 22 variables.
</p>

<dl>
<dt><code>Price</code></dt><dd><p>House price per square metre.</p>
</dd>
<dt><code>Floor.High</code></dt><dd><p>1 if a property is on a high floor, otherwise 0.</p>
</dd>
<dt><code>Floor.Low</code></dt><dd><p>1 if a property is on a low floor, otherwise 0.</p>
</dd>
<dt><code>Decoration.Fine</code></dt><dd><p>1 if a property is well decorated, otherwise 0.</p>
</dd>
<dt><code>PlateTower</code></dt><dd><p>1 if a property is of the plate-tower type, otherwise 0.</p>
</dd>
<dt><code>Steel</code></dt><dd><p>1 if a property is of 'steel' structure, otherwise 0.</p>
</dd>
<dt><code>BuildingArea</code></dt><dd><p>Building area in square metres.</p>
</dd>
<dt><code>Fee</code></dt><dd><p>Management fee per square meter per month.</p>
</dd>
<dt><code>d.Commercial</code></dt><dd><p>Distance to the nearest commercial area.</p>
</dd>
<dt><code>d.Greenland</code></dt><dd><p>Distance to the nearest green land.</p>
</dd>
<dt><code>d.Water</code></dt><dd><p>Distance to the nearest river or lake.</p>
</dd>
<dt><code>d.University</code></dt><dd><p>Distance to the nearest university.</p>
</dd>
<dt><code>d.HighSchool</code></dt><dd><p>Distance to the nearest high school.</p>
</dd>
<dt><code>d.MiddleSchool</code></dt><dd><p>Distance to the nearest middle school.</p>
</dd>
<dt><code>d.PrimarySchool</code></dt><dd><p>Distance to the nearest primary school.</p>
</dd>
<dt><code>d.Kindergarten</code></dt><dd><p>Distance to the nearest kindergarten.</p>
</dd>
<dt><code>d.SubwayStation</code></dt><dd><p>Distance to the nearest subway station.</p>
</dd>
<dt><code>d.Supermarket</code></dt><dd><p>Distance to the nearest supermarket.</p>
</dd>
<dt><code>d.ShoppingMall</code></dt><dd><p>Distance to the nearest shopping mall.</p>
</dd>
<dt><code>lon</code></dt><dd><p>Longitude coordinates (Projected CRS: EPSG 3857).</p>
</dd>
<dt><code>lat</code></dt><dd><p>Latitude coordinates (Projected CRS: EPSE 3857).</p>
</dd>
<dt><code>group</code></dt><dd><p>Group id of each sample.</p>
</dd>
</dl>

<p>The following variables are group level:
</p>
<p>- <code>Fee</code>
- <code>d.Commercial</code>
- <code>d.Greenland</code>
- <code>d.Water</code>
- <code>d.University</code>
- <code>d.HighSchool</code>
- <code>d.MiddleSchool</code>
- <code>d.PrimarySchool</code>
- <code>d.Kindergarten</code>
- <code>d.SubwayStation</code>
- <code>d.Supermarket</code>
- <code>d.ShoppingMall</code>
</p>
<p>The following variables are sample level:
</p>
<p>- <code>Price</code>
- <code>Floor.High</code>
- <code>Floor.Low</code>
- <code>Decoration.Fine</code>
- <code>PlateTower</code>
- <code>Steel</code>
- <code>BuildingArea</code>
</p>
<p>Item &quot;coords&quot; is a 779-by-2 matrix of coordinates of all neighbourhoods.
</p>


<h3>Author(s)</h3>

<p>Yigong Hu <a href="mailto:yigong.hu@bristol.ac.uk">yigong.hu@bristol.ac.uk</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(wuhan.hp)
hgwr(
  formula = Price ~ L(d.Water + d.Commercial + d.PrimarySchool +
            d.Kindergarten + Fee) + BuildingArea + (Floor.High | group),
  data = wuhan.hp$data,
  coords = wuhan.hp$coords, bw = 50, kernel = "bisquared")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
