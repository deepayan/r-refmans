<!DOCTYPE html><html lang="en"><head><title>Help for package diagL1</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {diagL1}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bile'><p>Bile Data</p></a></li>
<li><a href='#boot_het.regL1'><p>Bootstrapping Linear L1 Models</p></a></li>
<li><a href='#boot.regL1'><p>Bootstrapping Linear L1 Models</p></a></li>
<li><a href='#class_to_regL1'><p>Change object class from &quot;rq&quot; to &quot;regL1&quot;</p></a></li>
<li><a href='#class_to_rq'><p>Change object class from &quot;regL1&quot; to &quot;rq&quot;</p></a></li>
<li><a href='#CookDistance'><p>Calculate Cook Distance</p></a></li>
<li><a href='#dlaplace'><p>Probability density function (PDF) of the Laplace distribution</p></a></li>
<li><a href='#FD'><p>F Distance</p></a></li>
<li><a href='#Fire'><p>Fire Data</p></a></li>
<li><a href='#forwardSearch_regL1'><p>Forward Search in Linear L1 Models</p></a></li>
<li><a href='#HV_test'><p>Homogeneity of Variance Tests for Linear L1 Models</p></a></li>
<li><a href='#lambda_mle'><p>Function to estimate lambda via MLE</p></a></li>
<li><a href='#lambda_ros'><p>Function to calculate robust lambda estimator</p></a></li>
<li><a href='#laplace.dist.test'><p>Wrapper for the 'laplace.test' function from the 'lawstat' package</p></a></li>
<li><a href='#LF_test'><p>Lack of Fit Tests for Linear L1 Models</p></a></li>
<li><a href='#likelihoodCD'><p>Calculate Conditional Likelihood Displacement</p></a></li>
<li><a href='#likelihoodD'><p>Calculate Likelihood Displacement</p></a></li>
<li><a href='#PIF'><p>Predictive Influence Function</p></a></li>
<li><a href='#plaplace'><p>Cumulative distribution function (CDF) of the Laplace distribution</p></a></li>
<li><a href='#plot.forwardSearch_regL1'><p>Forward Search in Linear L1 Models</p></a></li>
<li><a href='#print.forwardSearch_regL1'><p>Print an forwardSearch_regL1 object</p></a></li>
<li><a href='#print.regL1'><p>Print an regL1 object</p></a></li>
<li><a href='#print.summary.forwardSearch_regL1'><p>Print Forward Search in Linear L1 Model Summary Object</p></a></li>
<li><a href='#print.summary.regL1'><p>Print Linear L1 Regression Summary Object</p></a></li>
<li><a href='#qlaplace'><p>Quantile function (inverse of the CDF) of the Laplace distribution</p></a></li>
<li><a href='#regL1'><p>Fitting Linear L1 Models</p></a></li>
<li><a href='#regL1_het'><p>Fitting Heteroscedastic Linear L1 Models</p></a></li>
<li><a href='#rlaplace'><p>Function to generate random values from the Laplace distribution</p></a></li>
<li><a href='#SAE'><p>Function to calculate SAE</p></a></li>
<li><a href='#summary.forwardSearch_regL1'><p>Summarizing Fit of Forward Search in Linear L1 Regression</p></a></li>
<li><a href='#summary.regL1'><p>Summary methods for L1 Regression</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Routines for Fit, Inference and Diagnostics in Linear L1 and LAD
Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Kevin Allan Sales Rodrigues
    <a href="https://orcid.org/0000-0003-4925-5883"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Silvia Nagib Elian [ctb, ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kevin Allan Sales Rodrigues &lt;kevin.asr@outlook.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Diagnostics for linear L1 regression (also known as LAD - Least Absolute Deviations), including: estimation, confidence intervals, tests of hypotheses, measures of leverage, methods of diagnostics for L1 regression, special diagnostics graphs and measures of leverage. The algorithms are based in Dielman (2005)  &lt;<a href="https://doi.org/10.1080%2F0094965042000223680">doi:10.1080/0094965042000223680</a>&gt;, Elian et al. (2000) &lt;<a href="https://doi.org/10.1080%2F03610920008832518">doi:10.1080/03610920008832518</a>&gt; and Dodge (1997) &lt;<a href="https://doi.org/10.1006%2Fjmva.1997.1666">doi:10.1006/jmva.1997.1666</a>&gt;. This package builds on the 'quantreg' package, which is a well-established package for tuning quantile regression models. There are also tests to verify if the errors have a Laplace distribution based on the work of Puig and Stephens (2000) &lt;<a href="https://doi.org/10.2307%2F1270952">doi:10.2307/1270952</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), quantreg (&ge; 5.97), greekLetters (&ge; 1.0.2)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, methods, conquer, lawstat, MatrixModels, Matrix, MASS,
cubature, doParallel, foreach</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-28 03:04:55 UTC; kevin</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-30 00:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bile'>Bile Data</h2><span id='topic+bile'></span>

<h3>Description</h3>

<p>A dataset containing lithogenic bile concentrations in 29 Pima Indians. For 29 females, the data give age and percent saturation of bile cholesterol.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bile)
</code></pre>


<h3>Format</h3>

<p>A data frame with 29 rows and 2 variables.
</p>


<h3>Details</h3>


<ul>
<li><p> Age: age in years of each female indian
</p>
</li>
<li><p> Concentration: percent saturation of bile cholesterol
</p>
</li></ul>



<h3>References</h3>

<p>Goodall, C. (1983). Examining Residuals. In Hoaglin, D. C., Mosteller, F. and Tukey, J. W. (1983). Understanding Robust and Exploratory Data Analysis. <em>Wiley series in probability and mathematical statistics</em>.
</p>

<hr>
<h2 id='boot_het.regL1'>Bootstrapping Linear L1 Models</h2><span id='topic+boot_het.regL1'></span>

<h3>Description</h3>

<p>This function can be used to construct standard errors,
confidence intervals and tests of hypotheses regarding linear L1
regression models. The bootstrap method used compute xypairs bootstrap
for linear L1 regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_het.regL1(x, y, groups, R = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boot_het.regL1_+3A_x">x</code></td>
<td>
<p>the regression design matrix.</p>
</td></tr>
<tr><td><code id="boot_het.regL1_+3A_y">y</code></td>
<td>
<p>the regression response vector.</p>
</td></tr>
<tr><td><code id="boot_het.regL1_+3A_groups">groups</code></td>
<td>
<p>vector with the group index associated with the observation, observations with the same index belong to the same group.</p>
</td></tr>
<tr><td><code id="boot_het.regL1_+3A_r">R</code></td>
<td>
<p>the number of bootstrap replications.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of four elements: a vector of lambda mle estimate for each bootstrap sample and another vector with empirical quantiles. A matrix B of dimension R by p is returned with the R resampled estimates of the vector of L1 linear regression parameters. A matrix U of sampled indices.
</p>


<h3>See Also</h3>

<p><code><a href="quantreg.html#topic+boot.rq">boot.rq</a></code> Bootstrapping Quantile Regression from package <code>quantreg</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
x1 = matrix(rnorm(20), ncol = 2)
y1 = x1[, 1] + x1[, 2] + rlaplace(10, 0, 5)
x2 = matrix(rnorm(20), ncol = 2)
y2 = x2[, 1] + x2[, 2] + rlaplace(10, 0, 10)
x3 = matrix(rnorm(20), ncol = 2)
y3 = x3[, 1] + x3[, 2] + rlaplace(10, 0, 15)
x4 = matrix(rnorm(20), ncol = 2)
y4 = x4[, 1] + x4[, 2] + rlaplace(10, 0, 20)
x5 = matrix(rnorm(20), ncol = 2)
y5 = x5[, 1] + x5[, 2] + rlaplace(10, 0, 30)

y = c(y1, y2, y3, y4, y5)
x = rbind(x1, x2, x3, x4, x5)
group_index = c(rep(1,10),rep(2,10),rep(3,10),rep(4,10),rep(5,10))

bt1 = boot_het.regL1(x, y, group_index, 1000)
bt1$lambda_mle_het



</code></pre>

<hr>
<h2 id='boot.regL1'>Bootstrapping Linear L1 Models</h2><span id='topic+boot.regL1'></span>

<h3>Description</h3>

<p>This function can be used to construct standard errors,
confidence intervals and tests of hypotheses regarding linear L1
regression models. The bootstrap method used compute xypairs bootstrap
for linear L1 regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.regL1(x, y, R = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boot.regL1_+3A_x">x</code></td>
<td>
<p>the regression design matrix.</p>
</td></tr>
<tr><td><code id="boot.regL1_+3A_y">y</code></td>
<td>
<p>the regression response vector.</p>
</td></tr>
<tr><td><code id="boot.regL1_+3A_r">R</code></td>
<td>
<p>the number of bootstrap replications.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of four elements: a vector of lambda mle estimate for each bootstrap sample and another vector with empirical quantiles. A matrix B of dimension R by p is returned with the R resampled estimates of the vector of L1 linear regression parameters. A matrix U of sampled indices.
</p>


<h3>See Also</h3>

<p><code><a href="quantreg.html#topic+boot.rq">boot.rq</a></code> Bootstrapping Quantile Regression from package <code>quantreg</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(stackloss)
bt1 = boot.regL1(stack.x, stack.loss, 1000)
plot(bt1$lambda_mle)



</code></pre>

<hr>
<h2 id='class_to_regL1'>Change object class from &quot;rq&quot; to &quot;regL1&quot;</h2><span id='topic+class_to_regL1'></span>

<h3>Description</h3>

<p>Changing the object's class from &quot;rq&quot; to &quot;regL1&quot; allows you to use functions from the 'diagL1' package normally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>class_to_regL1(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="class_to_regL1_+3A_object">object</code></td>
<td>
<p>Object from &quot;rq&quot; class.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object with class &quot;regL1&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regL1">regL1</a></code> for fitting linear L1 models.
<code>rq</code> for fitting linear L1 models.
</p>

<hr>
<h2 id='class_to_rq'>Change object class from &quot;regL1&quot; to &quot;rq&quot;</h2><span id='topic+class_to_rq'></span>

<h3>Description</h3>

<p>Changing the object's class from &quot;regL1&quot; to &quot;rq&quot; allows you to use functions from the 'quantreg' package normally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>class_to_rq(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="class_to_rq_+3A_object">object</code></td>
<td>
<p>Object from &quot;regL1&quot; class.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object with class &quot;rq&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regL1">regL1</a></code> for fitting linear L1 models.
<code>rq</code> for fitting linear L1 models.
</p>

<hr>
<h2 id='CookDistance'>Calculate Cook Distance</h2><span id='topic+CookDistance'></span>

<h3>Description</h3>

<p>Calculate Cook Distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CookDistance(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CookDistance_+3A_model">model</code></td>
<td>
<p>Object returned from regL1 representing the fit of the L1 model.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Cook Distance</code></td>
<td>
<p>          A vector with Cook Distance for each observation.</p>
</td></tr></table>
<p>.
</p>


<h3>References</h3>

<p>Sun, R.-B. and Wei, B.-C. (2004). On influence assessment for lad regression.
<em>Statistics &amp; Probability Letters</em>, <strong>67</strong>, 97-110. <a href="https://doi.org/10.1016/j.spl.2003.08.018">doi:10.1016/j.spl.2003.08.018</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x = matrix(rnorm(100), ncol = 2)
y = x[, 1] + x[, 2] + rlaplace(50, 0, 5)

# Fits a linear regression L1 model
mod1 = regL1(y ~ x)
CookDistance(mod1)
</code></pre>

<hr>
<h2 id='dlaplace'>Probability density function (PDF) of the Laplace distribution</h2><span id='topic+dlaplace'></span>

<h3>Description</h3>

<p>Probability density function (PDF) of the Laplace distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlaplace(x, location = 0, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlaplace_+3A_x">x</code></td>
<td>
<p>Values for which to calculate the probability density.</p>
</td></tr>
<tr><td><code id="dlaplace_+3A_location">location</code></td>
<td>
<p>Location parameter of the Laplace distribution (default = 0).</p>
</td></tr>
<tr><td><code id="dlaplace_+3A_scale">scale</code></td>
<td>
<p>Scale parameter of the Laplace distribution (default = 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of calculated probability densities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dlaplace(0, 0, 1)
</code></pre>

<hr>
<h2 id='FD'>F Distance</h2><span id='topic+FD'></span>

<h3>Description</h3>

<p>F Distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FD(model, norm = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FD_+3A_model">model</code></td>
<td>
<p>Object returned from regL1 representing the fit of the L1 model.</p>
</td></tr>
<tr><td><code id="FD_+3A_norm">norm</code></td>
<td>
<p>Type of norm, there are two types, 1 (norm L1) and 2 (norm L2). The default is norm L2.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>F Distance</code></td>
<td>
<p>          A vector with F Distance for each observation.</p>
</td></tr></table>
<p>.
</p>


<h3>References</h3>

<p>Sun, R.-B. and Wei, B.-C. (2004). On influence assessment for lad regression.
<em>Statistics &amp; Probability Letters</em>, <strong>67</strong>, 97-110. <a href="https://doi.org/10.1016/j.spl.2003.08.018">doi:10.1016/j.spl.2003.08.018</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x = matrix(rnorm(100), ncol = 2)
y = x[, 1] + x[, 2] + rlaplace(50, 0, 5)

# Fits a linear regression L1 model
mod1 = regL1(y ~ x)
FD(mod1)
</code></pre>

<hr>
<h2 id='Fire'>Fire Data</h2><span id='topic+Fire'></span>

<h3>Description</h3>

<p>A dataset containing incidence of fire data for 47 residential areas in Chicago for the year 1975.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Fire)
</code></pre>


<h3>Format</h3>

<p>A data frame with 47 rows and 6 variables.
</p>


<h3>Details</h3>


<ul>
<li><p> Fire: fires per 1000 housing units
</p>
</li>
<li><p> log_Fire: log of variable Fire
</p>
</li>
<li><p> Theft: thefts per 1000 residents
</p>
</li>
<li><p> Age: percent of housing units built in or before 1940
</p>
</li>
<li><p> Income: median family income as a multiple of $1000
</p>
</li></ul>



<h3>References</h3>

<p>Birkes, D.and Dodge, Y. (1993). Alternative Methods of Regression. <em>Jonh Wiley &amp; Sons</em>.
</p>

<hr>
<h2 id='forwardSearch_regL1'>Forward Search in Linear L1 Models</h2><span id='topic+forwardSearch_regL1'></span>

<h3>Description</h3>

<p>This function applies the forward search approach to robust analysis in linear L1 models. This function is based on function <code>fwdlm</code> of package 'forward'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forwardSearch_regL1(
  formula,
  data,
  nsamp = "best",
  intercept = TRUE,
  trace = TRUE,
  subset,
  weights,
  na.action,
  method = "br",
  model = TRUE,
  contrasts = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forwardSearch_regL1_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of a ~ operator, and the terms, separated by + operators, on the right.</p>
</td></tr>
<tr><td><code id="forwardSearch_regL1_+3A_data">data</code></td>
<td>
<p>a data.frame in which to interpret the variables named in the formula, or in the subset and the weights argument. If this is missing, then the variables in the formula should be on the search list. This may also be a single number to handle some special cases – see below for details.</p>
</td></tr>
<tr><td><code id="forwardSearch_regL1_+3A_nsamp">nsamp</code></td>
<td>
<p>the initial subset for the forward search in linear regression is found by fitting the regression model with the R function <code><a href="MASS.html#topic+lmsreg">lmsreg</a></code>. This argument allows to control how many subsets are used in the Least Median of Squares regression. The choices are: the number of samples or &quot;best&quot; (the default) or &quot;exact&quot; or &quot;sample&quot;. For details see <code><a href="MASS.html#topic+lmsreg">lmsreg</a></code>.</p>
</td></tr>
<tr><td><code id="forwardSearch_regL1_+3A_intercept">intercept</code></td>
<td>
<p>logical for the inclusion of the intercept (if no formula is provided).</p>
</td></tr>
<tr><td><code id="forwardSearch_regL1_+3A_trace">trace</code></td>
<td>
<p>logical, if TRUE a message is printed for every ten iterations completed during the forward search.</p>
</td></tr>
<tr><td><code id="forwardSearch_regL1_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="forwardSearch_regL1_+3A_weights">weights</code></td>
<td>
<p>vector of observation weights; if supplied, the algorithm fits to minimize the sum of the weights multiplied into the absolute residuals. The length of weights must be the same as the number of observations. The weights must be nonnegative and it is strongly recommended that they be strictly positive, since zero weights are ambiguous.</p>
</td></tr>
<tr><td><code id="forwardSearch_regL1_+3A_na.action">na.action</code></td>
<td>
<p>a function to filter missing data. This is applied to the model.frame after any subset argument has been used. The default (with na.fail) is to create an error if any missing values are found. A possible alternative is na.omit, which deletes observations that contain one or more missing values.</p>
</td></tr>
<tr><td><code id="forwardSearch_regL1_+3A_method">method</code></td>
<td>
<p>the algorithmic method used to compute the fit. There are several options: &quot;br&quot;, &quot;fn&quot;, &quot;pfn&quot;, &quot;sfn&quot;, &quot;fnc&quot;, &quot;conquer&quot;, &quot;pfnb&quot;, &quot;qfnb&quot;, &quot;ppro&quot; and &quot;lasso&quot;. See <code>rq</code> for more details.</p>
</td></tr>
<tr><td><code id="forwardSearch_regL1_+3A_model">model</code></td>
<td>
<p>if TRUE then the model frame is returned. This is essential if one wants to call summary subsequently.</p>
</td></tr>
<tr><td><code id="forwardSearch_regL1_+3A_contrasts">contrasts</code></td>
<td>
<p>a list giving contrasts for some or all of the factors default = NULL appearing in the model formula. The elements of the list should have the same name as the variable and should be either a contrast matrix (specifically, any full-rank matrix with as many rows as there are levels in the factor), or else a function to compute such a matrix given the number of levels.</p>
</td></tr>
<tr><td><code id="forwardSearch_regL1_+3A_...">...</code></td>
<td>
<p>additional arguments for the fitting routines (see <code>rq.fit.br</code> and <code>rq.fit.fnb</code>, etc. and the functions they call).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A fitted forward search in linear L1 regression model object.
</p>


<h3>References</h3>

<p>Atkinson, A.C. and Riani, M. (2000). <em>Robust Diagnostic Regression Analysis</em>. New York: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# applies the forward search approach to robust analysis in a linear L1 model
mod = forwardSearch_regL1(Concentration ~ Age, data = bile)

</code></pre>

<hr>
<h2 id='HV_test'>Homogeneity of Variance Tests for Linear L1 Models</h2><span id='topic+HV_test'></span>

<h3>Description</h3>

<p>Homogeneity of Variance Tests for Linear L1 Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HV_test(y, x, groups, alpha = 0.05, tolerance = 0.001, max_iteration = 2000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HV_test_+3A_y">y</code></td>
<td>
<p>A vector with response variables.</p>
</td></tr>
<tr><td><code id="HV_test_+3A_x">x</code></td>
<td>
<p>A matrix with a single explanatory variable.</p>
</td></tr>
<tr><td><code id="HV_test_+3A_groups">groups</code></td>
<td>
<p>Vector containing the group index to which the observation belongs.</p>
</td></tr>
<tr><td><code id="HV_test_+3A_alpha">alpha</code></td>
<td>
<p>Significance level of the test, must be between 0 and 1.</p>
</td></tr>
<tr><td><code id="HV_test_+3A_tolerance">tolerance</code></td>
<td>
<p>threshold that determines when the iterative algorithm should stop (for <code>regL1_het</code>).</p>
</td></tr>
<tr><td><code id="HV_test_+3A_max_iteration">max_iteration</code></td>
<td>
<p>maximum number of iterations (for <code>regL1_het</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 3 statistics to test homogeneity of variance are discussed in Rodrigues (2024), for more details see this reference. In practice, use the HV_LRT statistic results. If possible, use the HV_LRT statistic with a critical value obtained via bootstrap simulation.
</p>


<h3>Value</h3>

<p>A list with results from 3 homogeneity of variance tests
</p>
<table role = "presentation">
<tr><td><code>alpha</code></td>
<td>
<p>alpha argument.</p>
</td></tr>
<tr><td><code>asymptotic_critical_value</code></td>
<td>
<p>asymptotic alpha-based test critical value.</p>
</td></tr>
<tr><td><code>HV_LRT</code></td>
<td>
<p>LF1 statistic value using MLE (Maximum Likelihood Estimator).</p>
</td></tr>
<tr><td><code>HV_max_lambda_ratio</code></td>
<td>
<p>p-value of LF1 statistic using MLE.</p>
</td></tr>
<tr><td><code>HV_max_log_lambda_ratio</code></td>
<td>
<p>LF1 statistic value using ROS (Residuals Order Statistics).</p>
</td></tr>
<tr><td><code>number_of_groups</code></td>
<td>
<p>number of groups.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>overall sample size.</p>
</td></tr>
<tr><td><code>lambda_heteroscedastic</code></td>
<td>
<p>heteroscedastic estimation of the scaling parameters.</p>
</td></tr>
<tr><td><code>lambda_homocedastic</code></td>
<td>
<p>homoscedastic estimation of the scale parameter.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rodrigues, K. A. S. (2024). <strong>Analysis of the adjustment of the L1 regression model</strong>.
Phd dissertation, University of São Paulo, BR.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
x1 = matrix(rnorm(20), ncol = 1)
y1 = x1 + rlaplace(20, 0, 1)
x2 = matrix(rnorm(20), ncol = 1)
y2 = x2 + rlaplace(20, 0, 1.5)
x3 = matrix(rnorm(20), ncol = 1)
y3 = x3 + rlaplace(20, 0, 2)
x4 = matrix(rnorm(20), ncol = 1)
y4 = x4 + rlaplace(20, 0, 2.5)
x5 = matrix(rnorm(20), ncol = 1)
y5 = x5 + rlaplace(20, 0, 3)

y = c(y1, y2, y3, y4, y5)
x = rbind(x1, x2, x3, x4, x5)
group_index = c(rep(1,20),rep(2,20),rep(3,20),rep(4,20),rep(5,20))

# Application of the homogeneity of variance test
test_result = HV_test(y, x, group_index)
test_result


</code></pre>

<hr>
<h2 id='lambda_mle'>Function to estimate lambda via MLE</h2><span id='topic+lambda_mle'></span>

<h3>Description</h3>

<p>Function to estimate lambda via MLE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda_mle(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lambda_mle_+3A_model">model</code></td>
<td>
<p>A linear model L1 fitted with the <code>rq</code> function from the <code>quantreg</code> package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>lambda MLE (Maximum Likelihood Estimator) estimator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(stackloss)
model_L1 = regL1(stack.loss ~ stack.x)
lambda_mle(model_L1)

</code></pre>

<hr>
<h2 id='lambda_ros'>Function to calculate robust lambda estimator</h2><span id='topic+lambda_ros'></span>

<h3>Description</h3>

<p>Function to compute a robust lambda estimator, which is based on the residuals order statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda_ros(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lambda_ros_+3A_model">model</code></td>
<td>
<p>A linear model L1 fitted with the <code>rq</code> function from the <code>quantreg</code> package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Robust lambda estimator, which is based on the residuals order statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(stackloss)
model_L1 = regL1(stack.loss ~ stack.x)
lambda_ros(model_L1)

</code></pre>

<hr>
<h2 id='laplace.dist.test'>Wrapper for the 'laplace.test' function from the 'lawstat' package</h2><span id='topic+laplace.dist.test'></span>

<h3>Description</h3>

<p>This function is a wrapper for the 'laplace.test' function from the 'lawstat' package.
The advantage of using this function instead of the 'laplace.test' function of the
'lawstat' package is that this function shows the tables with the critical values
of the statistics provided by Puig and Stephens (2000). This makes interpretation of the results easier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>laplace.dist.test(y, print_tables = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="laplace.dist.test_+3A_y">y</code></td>
<td>
<p>A numeric vector containing the sample data.</p>
</td></tr>
<tr><td><code id="laplace.dist.test_+3A_print_tables">print_tables</code></td>
<td>
<p>A boolean variable that indicates whether tables with critical values will be printed or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of the laplace.test function.
</p>


<h3>References</h3>

<p>Puig, P. and Stephens, M. A. (2000). Tests of fit for the Laplace distribution, with applications.
<em>Technometrics</em>, <strong>42</strong>(4), 417-424. <a href="https://doi.org/10.2307/1270952">doi:10.2307/1270952</a>.
</p>


<h3>See Also</h3>

<p><code><a href="lawstat.html#topic+laplace.test">laplace.test</a></code> Goodness-of-fit Test Statistics for the Laplace Distribution from package <code>lawstat</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
normal_sample = rnorm(100, 0, 10)
laplace_sample = rlaplace(100, 0, 10)
laplace.dist.test(normal_sample)
laplace.dist.test(laplace_sample)


</code></pre>

<hr>
<h2 id='LF_test'>Lack of Fit Tests for Linear L1 Models</h2><span id='topic+LF_test'></span>

<h3>Description</h3>

<p>Lack of Fit Tests for Linear L1 Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LF_test(y, x, groups, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LF_test_+3A_y">y</code></td>
<td>
<p>A vector with response variables.</p>
</td></tr>
<tr><td><code id="LF_test_+3A_x">x</code></td>
<td>
<p>A matrix with a single explanatory variable.</p>
</td></tr>
<tr><td><code id="LF_test_+3A_groups">groups</code></td>
<td>
<p>Vector containing the group index to which the observation belongs.</p>
</td></tr>
<tr><td><code id="LF_test_+3A_alpha">alpha</code></td>
<td>
<p>Significance level of the test, must be between 0 and 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 3 statistics to test lack of fit are discussed in Rodrigues (2024), for more details see this reference. In practice, use the LF1_MLE statistic results. These tests were developed with just one explanatory variable in mind, which is why we include an error if there is more than one explanatory variable.
</p>


<h3>Value</h3>

<p>A list with results from 3 lack of fit tests
</p>
<table role = "presentation">
<tr><td><code>alpha</code></td>
<td>
<p>alpha argument.</p>
</td></tr>
<tr><td><code>critical_value</code></td>
<td>
<p>alpha-based test critical value.</p>
</td></tr>
<tr><td><code>LF1_MLE</code></td>
<td>
<p>LF1 statistic value using MLE (Maximum Likelihood Estimator).</p>
</td></tr>
<tr><td><code>LF1_MLE</code></td>
<td>
<p>p-value of LF1 statistic using MLE.</p>
</td></tr>
<tr><td><code>LF1_ROS</code></td>
<td>
<p>LF1 statistic value using ROS (Residuals Order Statistics).</p>
</td></tr>
<tr><td><code>LF2</code></td>
<td>
<p>LF2 statistic value.</p>
</td></tr>
<tr><td><code>modelo_H0</code></td>
<td>
<p>model fitted under H0.</p>
</td></tr>
<tr><td><code>modelo_Ha</code></td>
<td>
<p>model fitted under Ha.</p>
</td></tr>
<tr><td><code>MLE</code></td>
<td>
<p>estimation of the scale parameter of the estimator model via MLE.</p>
</td></tr>
<tr><td><code>ROS</code></td>
<td>
<p>estimation of the scale parameter of the estimator model via ROS.</p>
</td></tr>
<tr><td><code>SAE_H0</code></td>
<td>
<p>SAE (Sum of Absolute Errors) of the adjusted model under H0.</p>
</td></tr>
<tr><td><code>SAE_Ha</code></td>
<td>
<p>SAE (Sum of Absolute Errors) of the adjusted model under Ha.</p>
</td></tr>
<tr><td><code>matrix_mean_x</code></td>
<td>
<p>average of the explanatory variable per group of observations.</p>
</td></tr>
<tr><td><code>number_of_groups</code></td>
<td>
<p>number of groups.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rodrigues, K. A. S. (2024). <strong>Analysis of the adjustment of the L1 regression model</strong>.
Phd dissertation, University of São Paulo, BR.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
x1 = matrix(rnorm(20), ncol = 1)
y1 = x1 + rlaplace(20, 0, 5)
x2 = matrix(rnorm(20), ncol = 1)
y2 = x2 + rlaplace(20, 1, 5)
x3 = matrix(rnorm(20), ncol = 1)
y3 = x3 + rlaplace(20, 2, 5)
x4 = matrix(rnorm(20), ncol = 1)
y4 = x4 + rlaplace(20, 3, 5)
x5 = matrix(rnorm(20), ncol = 1)
y5 = x5 + rlaplace(20, 4, 5)

y = c(y1, y2, y3, y4, y5)
x = rbind(x1, x2, x3, x4, x5)
group_index = c(rep(1,20),rep(2,20),rep(3,20),rep(4,20),rep(5,20))

# Application of the lack of fit test
test_result = LF_test(y, x, group_index)
test_result


</code></pre>

<hr>
<h2 id='likelihoodCD'>Calculate Conditional Likelihood Displacement</h2><span id='topic+likelihoodCD'></span>

<h3>Description</h3>

<p>Calculate Conditional Likelihood Displacement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likelihoodCD(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="likelihoodCD_+3A_model">model</code></td>
<td>
<p>Object returned from regL1 representing the fit of the L1 model.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Likelihood Displacement</code></td>
<td>
<p>          A vector with Likelihood Displacement for each observation.</p>
</td></tr></table>
<p>.
</p>


<h3>References</h3>

<p>Elian, S. N., André, C. D. S. and Narula, S. C. (2000). Influence Measure for the
L<sub>1</sub> regression.
<em>Communications in Statistics - Theory and Methods</em>, <strong>29</strong>(4), 837-849. <a href="https://doi.org/10.1080/03610920008832518">doi:10.1080/03610920008832518</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x = matrix(rnorm(100), ncol = 2)
y = x[, 1] + x[, 2] + rlaplace(50, 0, 5)

# Fits a linear regression L1 model
mod1 = regL1(y ~ x)
likelihoodCD(mod1)
</code></pre>

<hr>
<h2 id='likelihoodD'>Calculate Likelihood Displacement</h2><span id='topic+likelihoodD'></span>

<h3>Description</h3>

<p>Calculate Likelihood Displacement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likelihoodD(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="likelihoodD_+3A_model">model</code></td>
<td>
<p>Object returned from regL1 representing the fit of the L1 model.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Likelihood Displacement</code></td>
<td>
<p>          A vector with Likelihood Displacement for each observation.</p>
</td></tr></table>
<p>.
</p>


<h3>References</h3>

<p>Elian, S. N., André, C. D. S. and Narula, S. C. (2000). Influence Measure for the
L<sub>1</sub> regression.
<em>Communications in Statistics - Theory and Methods</em>, <strong>29</strong>(4), 837-849. <a href="https://doi.org/10.1080/03610920008832518">doi:10.1080/03610920008832518</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x = matrix(rnorm(100), ncol = 2)
y = x[, 1] + x[, 2] + rlaplace(50, 0, 5)

# Fits a linear regression L1 model
mod1 = regL1(y ~ x)
likelihoodD(mod1)
</code></pre>

<hr>
<h2 id='PIF'>Predictive Influence Function</h2><span id='topic+PIF'></span>

<h3>Description</h3>

<p>Predictive Influence Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PIF(y, x, w, num_cores = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PIF_+3A_y">y</code></td>
<td>
<p>A vector with response variables.</p>
</td></tr>
<tr><td><code id="PIF_+3A_x">x</code></td>
<td>
<p>A matrix with a single explanatory variable.</p>
</td></tr>
<tr><td><code id="PIF_+3A_w">w</code></td>
<td>
<p>Explanatory variables vector for z, usually explanatory variables averages.</p>
</td></tr>
<tr><td><code id="PIF_+3A_num_cores">num_cores</code></td>
<td>
<p>Number of cores you want to use for parallel processing (default = 2).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please, install and load the &quot;foreach&quot; package to use this function. For more details see Rodrigues (2024).
</p>


<h3>Value</h3>

<p>A vector with predictive influence function value for each observation.
</p>


<h3>References</h3>

<p>Rodrigues, K. A. S. (2024). <strong>Analysis of the adjustment of the L1 regression model</strong>.
Phd dissertation, University of São Paulo, BR.
</p>

<hr>
<h2 id='plaplace'>Cumulative distribution function (CDF) of the Laplace distribution</h2><span id='topic+plaplace'></span>

<h3>Description</h3>

<p>Cumulative distribution function (CDF) of the Laplace distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plaplace(q, location = 0, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plaplace_+3A_q">q</code></td>
<td>
<p>Values for which to calculate the cumulative distribution.</p>
</td></tr>
<tr><td><code id="plaplace_+3A_location">location</code></td>
<td>
<p>Location parameter of the Laplace distribution (default = 0).</p>
</td></tr>
<tr><td><code id="plaplace_+3A_scale">scale</code></td>
<td>
<p>Scale parameter of the Laplace distribution (default = 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of calculated cumulative distributions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plaplace(0, 0, 1)
</code></pre>

<hr>
<h2 id='plot.forwardSearch_regL1'>Forward Search in Linear L1 Models</h2><span id='topic+plot.forwardSearch_regL1'></span>

<h3>Description</h3>

<p>This function plots the results of a forward search in linear L1 models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'forwardSearch_regL1'
plot(
  x,
  type.plot = 1:5,
  squared = FALSE,
  scaled = FALSE,
  ylim = NULL,
  xlim = NULL,
  th.Res = 2,
  th.Lev = 0.25,
  sig.Tst = 2.58,
  labels.in.plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.forwardSearch_regL1_+3A_x">x</code></td>
<td>
<p>a &quot;forwardSearch_regL1&quot; object.</p>
</td></tr>
<tr><td><code id="plot.forwardSearch_regL1_+3A_type.plot">type.plot</code></td>
<td>
<p>select which plots to draw, by default all. Each graph is addressed by an integer:
</p>

<ol>
<li><p> scaled residuals
</p>
</li>
<li><p> minimum deletion residuals
</p>
</li>
<li><p> coefficients
</p>
</li>
<li><p> statistics
</p>
</li>
<li><p> MAE (Mean Absolute Error) values
</p>
</li></ol>
</td></tr>
<tr><td><code id="plot.forwardSearch_regL1_+3A_squared">squared</code></td>
<td>
<p>logical, if TRUE plots squared residuals.</p>
</td></tr>
<tr><td><code id="plot.forwardSearch_regL1_+3A_scaled">scaled</code></td>
<td>
<p>logical, if TRUE plots scaled coefficient estimates.</p>
</td></tr>
<tr><td><code id="plot.forwardSearch_regL1_+3A_ylim">ylim</code></td>
<td>
<p>a two component vector for the min and max of the y axis.</p>
</td></tr>
<tr><td><code id="plot.forwardSearch_regL1_+3A_xlim">xlim</code></td>
<td>
<p>a two component vector for the min and max of the x axis.</p>
</td></tr>
<tr><td><code id="plot.forwardSearch_regL1_+3A_th.res">th.Res</code></td>
<td>
<p>numerical, a threshold for labelling the residuals.</p>
</td></tr>
<tr><td><code id="plot.forwardSearch_regL1_+3A_th.lev">th.Lev</code></td>
<td>
<p>numerical, a threshold for labelling the leverages.</p>
</td></tr>
<tr><td><code id="plot.forwardSearch_regL1_+3A_sig.tst">sig.Tst</code></td>
<td>
<p>numerical, a value (on the scale of the t statistics) used to draw the confidence interval on the plot of the t statistics.</p>
</td></tr>
<tr><td><code id="plot.forwardSearch_regL1_+3A_labels.in.plot">labels.in.plot</code></td>
<td>
<p>logical, if TRUE units are labelled in the plots when required.</p>
</td></tr>
<tr><td><code id="plot.forwardSearch_regL1_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, just plots the results of a forward search in linear L1 models.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forwardSearch_regL1">forwardSearch_regL1</a></code> for apply forward search in linear L1 regression model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# applies the forward search approach to robust analysis in a linear L1 model
mod = forwardSearch_regL1(Concentration ~ Age, data = bile)
plot(mod, 1)

</code></pre>

<hr>
<h2 id='print.forwardSearch_regL1'>Print an forwardSearch_regL1 object</h2><span id='topic+print.forwardSearch_regL1'></span>

<h3>Description</h3>

<p>Print an object generated by forwardSearch_regL1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'forwardSearch_regL1'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.forwardSearch_regL1_+3A_x">x</code></td>
<td>
<p>Object returned from forwardSearch_regL1.</p>
</td></tr>
<tr><td><code id="print.forwardSearch_regL1_+3A_...">...</code></td>
<td>
<p>Optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forwardSearch_regL1">forwardSearch_regL1</a></code> for apply forward search in linear L1 regression model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# applies the forward search approach to robust analysis in a linear L1 model
mod = forwardSearch_regL1(Concentration ~ Age, data = bile)
mod # or print(mod)


</code></pre>

<hr>
<h2 id='print.regL1'>Print an regL1 object</h2><span id='topic+print.regL1'></span>

<h3>Description</h3>

<p>Print an object generated by regL1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'regL1'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.regL1_+3A_x">x</code></td>
<td>
<p>Object returned from regL1 representing the fit of the L1 model.</p>
</td></tr>
<tr><td><code id="print.regL1_+3A_...">...</code></td>
<td>
<p>Optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regL1">regL1</a></code> for fitting linear L1 models.
</p>

<hr>
<h2 id='print.summary.forwardSearch_regL1'>Print Forward Search in Linear L1 Model Summary Object</h2><span id='topic+print.summary.forwardSearch_regL1'></span>

<h3>Description</h3>

<p>Print summary of forward search in linear L1 model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.forwardSearch_regL1'
print(x, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.forwardSearch_regL1_+3A_x">x</code></td>
<td>
<p>This is an object of class &quot;<code>summary</code>&quot; produced by a call to <code>summary.regL1()</code>.</p>
</td></tr>
<tr><td><code id="print.summary.forwardSearch_regL1_+3A_digits">digits</code></td>
<td>
<p>Significant digits reported in the printed table.</p>
</td></tr>
<tr><td><code id="print.summary.forwardSearch_regL1_+3A_...">...</code></td>
<td>
<p>Optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forwardSearch_regL1">forwardSearch_regL1</a></code> for apply forward search in linear L1 regression model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# applies the forward search approach to robust analysis in a linear L1 model
mod = forwardSearch_regL1(Concentration ~ Age, data = bile)
summary(mod)

</code></pre>

<hr>
<h2 id='print.summary.regL1'>Print Linear L1 Regression Summary Object</h2><span id='topic+print.summary.regL1'></span>

<h3>Description</h3>

<p>Print summary of linear L1 regression object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.regL1'
print(x, digits = max(5, .Options$digits - 2), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.regL1_+3A_x">x</code></td>
<td>
<p>This is an object of class &quot;<code>summary.regL1</code>&quot; produced by a call to <code>summary.regL1()</code>.</p>
</td></tr>
<tr><td><code id="print.summary.regL1_+3A_digits">digits</code></td>
<td>
<p>Significant digits reported in the printed table.</p>
</td></tr>
<tr><td><code id="print.summary.regL1_+3A_...">...</code></td>
<td>
<p>Optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>

<hr>
<h2 id='qlaplace'>Quantile function (inverse of the CDF) of the Laplace distribution</h2><span id='topic+qlaplace'></span>

<h3>Description</h3>

<p>Quantile function (inverse of the CDF) of the Laplace distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qlaplace(p, location = 0, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qlaplace_+3A_p">p</code></td>
<td>
<p>Values for which to calculate quantiles.</p>
</td></tr>
<tr><td><code id="qlaplace_+3A_location">location</code></td>
<td>
<p>Location parameter of the Laplace distribution (default = 0).</p>
</td></tr>
<tr><td><code id="qlaplace_+3A_scale">scale</code></td>
<td>
<p>Scale parameter of the Laplace distribution (default = 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of calculated quantiles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qlaplace(0.5, 0, 1)
</code></pre>

<hr>
<h2 id='regL1'>Fitting Linear L1 Models</h2><span id='topic+regL1'></span>

<h3>Description</h3>

<p>This function fits an L1 regression model using the <code>rq</code> function from the 'quantreg' package. L1 regression allows dealing with outliers and non-normal distributions in the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regL1(
  formula,
  data,
  subset,
  weights,
  na.action,
  method = "br",
  model = TRUE,
  contrasts = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regL1_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of a ~ operator, and the terms, separated by + operators, on the right.</p>
</td></tr>
<tr><td><code id="regL1_+3A_data">data</code></td>
<td>
<p>a data.frame in which to interpret the variables named in the formula, or in the subset and the weights argument. If this is missing, then the variables in the formula should be on the search list. This may also be a single number to handle some special cases – see below for details.</p>
</td></tr>
<tr><td><code id="regL1_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="regL1_+3A_weights">weights</code></td>
<td>
<p>vector of observation weights; if supplied, the algorithm fits to minimize the sum of the weights multiplied into the absolute residuals. The length of weights must be the same as the number of observations. The weights must be nonnegative and it is strongly recommended that they be strictly positive, since zero weights are ambiguous.</p>
</td></tr>
<tr><td><code id="regL1_+3A_na.action">na.action</code></td>
<td>
<p>a function to filter missing data. This is applied to the model.frame after any subset argument has been used. The default (with na.fail) is to create an error if any missing values are found. A possible alternative is na.omit, which deletes observations that contain one or more missing values.</p>
</td></tr>
<tr><td><code id="regL1_+3A_method">method</code></td>
<td>
<p>the algorithmic method used to compute the fit. There are several options: &quot;br&quot;, &quot;fn&quot;, &quot;pfn&quot;, &quot;sfn&quot;, &quot;fnc&quot;, &quot;conquer&quot;, &quot;pfnb&quot;, &quot;qfnb&quot;, &quot;ppro&quot; and &quot;lasso&quot;. See <code>rq</code> for more details.</p>
</td></tr>
<tr><td><code id="regL1_+3A_model">model</code></td>
<td>
<p>if TRUE then the model frame is returned. This is essential if one wants to call summary subsequently.</p>
</td></tr>
<tr><td><code id="regL1_+3A_contrasts">contrasts</code></td>
<td>
<p>a list giving contrasts for some or all of the factors default = NULL appearing in the model formula. The elements of the list should have the same name as the variable and should be either a contrast matrix (specifically, any full-rank matrix with as many rows as there are levels in the factor), or else a function to compute such a matrix given the number of levels.</p>
</td></tr>
<tr><td><code id="regL1_+3A_...">...</code></td>
<td>
<p>additional arguments for the fitting routines (see <code>rq.fit.br</code> and <code>rq.fit.fnb</code>, etc. and the functions they call).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>L1 regression is an important particular case of quantile regression, so this function inherits from the &quot;rq&quot; class of the <code>quantreg</code> package.
</p>


<h3>Value</h3>

<p>A fitted L1 linear regression model object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x = matrix(rnorm(100), ncol = 2)
y = x[, 1] + x[, 2] + rlaplace(50, 0, 5)

# Fits a linear regression L1 model
mod1 = regL1(y ~ x)

</code></pre>

<hr>
<h2 id='regL1_het'>Fitting Heteroscedastic Linear L1 Models</h2><span id='topic+regL1_het'></span>

<h3>Description</h3>

<p>This function fits an groupwise heteroscedastic L1 regression model using the <code>rq</code> function from the 'quantreg' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regL1_het(
  x,
  y,
  groups,
  na.action = stats::na.omit,
  method = "br",
  model = TRUE,
  tolerance = 0.001,
  max_iteration = 2000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regL1_het_+3A_x">x</code></td>
<td>
<p>the regression design matrix.</p>
</td></tr>
<tr><td><code id="regL1_het_+3A_y">y</code></td>
<td>
<p>the regression response vector.</p>
</td></tr>
<tr><td><code id="regL1_het_+3A_groups">groups</code></td>
<td>
<p>vector with the group index associated with the observation, observations with the same index belong to the same group.</p>
</td></tr>
<tr><td><code id="regL1_het_+3A_na.action">na.action</code></td>
<td>
<p>a function to filter missing data. This is applied to the model.frame after any subset argument has been used. The default (with na.fail) is to create an error if any missing values are found. A possible alternative is na.omit, which deletes observations that contain one or more missing values.</p>
</td></tr>
<tr><td><code id="regL1_het_+3A_method">method</code></td>
<td>
<p>the algorithmic method used to compute the fit. There are several options: &quot;br&quot;, &quot;fn&quot;, &quot;pfn&quot;, &quot;sfn&quot;, &quot;fnc&quot;, &quot;conquer&quot;, &quot;pfnb&quot;, &quot;qfnb&quot;, &quot;ppro&quot; and &quot;lasso&quot;. See <code>rq</code> for more details.</p>
</td></tr>
<tr><td><code id="regL1_het_+3A_model">model</code></td>
<td>
<p>if TRUE then the model frame is returned. This is essential if one wants to call summary subsequently.</p>
</td></tr>
<tr><td><code id="regL1_het_+3A_tolerance">tolerance</code></td>
<td>
<p>threshold that determines when the iterative algorithm should stop.</p>
</td></tr>
<tr><td><code id="regL1_het_+3A_max_iteration">max_iteration</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="regL1_het_+3A_...">...</code></td>
<td>
<p>additional arguments for the fitting routines (see <code>rq.fit.br</code> and <code>rq.fit.fnb</code>, etc. and the functions they call).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>L1 regression is an important particular case of quantile regression, so this function inherits from the &quot;rq&quot; class of the <code>quantreg</code> package.
</p>


<h3>Value</h3>

<p>A fitted heteroscedastic L1 linear regression model object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x1 = matrix(rnorm(20), ncol = 2)
y1 = x1[, 1] + x1[, 2] + rlaplace(10, 0, 5)
x2 = matrix(rnorm(20), ncol = 2)
y2 = x2[, 1] + x2[, 2] + rlaplace(10, 0, 10)
x3 = matrix(rnorm(20), ncol = 2)
y3 = x3[, 1] + x3[, 2] + rlaplace(10, 0, 15)
x4 = matrix(rnorm(20), ncol = 2)
y4 = x4[, 1] + x4[, 2] + rlaplace(10, 0, 20)
x5 = matrix(rnorm(20), ncol = 2)
y5 = x5[, 1] + x5[, 2] + rlaplace(10, 0, 30)

y = c(y1, y2, y3, y4, y5)
x = rbind(x1, x2, x3, x4, x5)
group_index = c(rep(1,10),rep(2,10),rep(3,10),rep(4,10),rep(5,10))
# Fits a heteroscedastic linear regression L1 model
mod1 = regL1_het(x, y, group_index)

</code></pre>

<hr>
<h2 id='rlaplace'>Function to generate random values from the Laplace distribution</h2><span id='topic+rlaplace'></span>

<h3>Description</h3>

<p>Function to generate random values from the Laplace distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlaplace(n, location = 0, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rlaplace_+3A_n">n</code></td>
<td>
<p>Number of values to generate.</p>
</td></tr>
<tr><td><code id="rlaplace_+3A_location">location</code></td>
<td>
<p>Location parameter of the Laplace distribution (default = 0).</p>
</td></tr>
<tr><td><code id="rlaplace_+3A_scale">scale</code></td>
<td>
<p>Scale parameter of the Laplace distribution (default = 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of generated random values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rlaplace(10, 0, 1)
</code></pre>

<hr>
<h2 id='SAE'>Function to calculate SAE</h2><span id='topic+SAE'></span>

<h3>Description</h3>

<p>Function to calculate SAE (Sum of Absolute Errors) of the adjusted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SAE(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SAE_+3A_model">model</code></td>
<td>
<p>A linear model L1 fitted with the <code>rq</code> function from the <code>quantreg</code> package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SAE (Sum of Absolute Errors).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(stackloss)
model_L1 = regL1(stack.loss ~ stack.x)
SAE(model_L1)

</code></pre>

<hr>
<h2 id='summary.forwardSearch_regL1'>Summarizing Fit of Forward Search in Linear L1 Regression</h2><span id='topic+summary.forwardSearch_regL1'></span>

<h3>Description</h3>

<p>Returns a summary list for a forward search in linear L1 regression fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'forwardSearch_regL1'
summary(object, steps = "auto", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.forwardSearch_regL1_+3A_object">object</code></td>
<td>
<p>Object returned from forwardSearch_regL1.</p>
</td></tr>
<tr><td><code id="summary.forwardSearch_regL1_+3A_steps">steps</code></td>
<td>
<p>the number of forward steps to show.</p>
</td></tr>
<tr><td><code id="summary.forwardSearch_regL1_+3A_...">...</code></td>
<td>
<p>Optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>References</h3>

<p>Atkinson, A.C. and Riani, M. (2000). <em>Robust Diagnostic Regression Analysis</em>. New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forwardSearch_regL1">forwardSearch_regL1</a></code> for apply forward search in linear L1 regression model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# applies the forward search approach to robust analysis in a linear L1 model
mod = forwardSearch_regL1(Concentration ~ Age, data = bile)
summary(mod)


</code></pre>

<hr>
<h2 id='summary.regL1'>Summary methods for L1 Regression</h2><span id='topic+summary.regL1'></span>

<h3>Description</h3>

<p>Returns a summary list for a L1 regression fit. A null value will be returned if printing is invoked.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'regL1'
summary(
  object,
  se = NULL,
  covariance = FALSE,
  hs = TRUE,
  U = NULL,
  gamma = 0.7,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.regL1_+3A_object">object</code></td>
<td>
<p>Object returned from regL1 representing the fit of the L1 model.</p>
</td></tr>
<tr><td><code id="summary.regL1_+3A_se">se</code></td>
<td>
<p>specifies the method used to compute standard standard errors. There are currently seven available methods: &quot;rank&quot;, &quot;iid&quot;, &quot;nid&quot;, &quot;ker&quot;, &quot;boot&quot;, &quot;BLB&quot;, &quot;conquer&quot; and &quot;extreme&quot;.</p>
</td></tr>
<tr><td><code id="summary.regL1_+3A_covariance">covariance</code></td>
<td>
<p>logical flag to indicate whether the full covariance matrix of the estimated parameters should be returned.</p>
</td></tr>
<tr><td><code id="summary.regL1_+3A_hs">hs</code></td>
<td>
<p>Use Hall Sheather bandwidth for sparsity estimation If false revert to Bofinger bandwidth.</p>
</td></tr>
<tr><td><code id="summary.regL1_+3A_u">U</code></td>
<td>
<p>Resampling indices or gradient evaluations used for bootstrap, see <code>summary.rq</code> and <code>boot.rq</code> for more details.</p>
</td></tr>
<tr><td><code id="summary.regL1_+3A_gamma">gamma</code></td>
<td>
<p>parameter controlling the effective sample size of the'bag of little bootstrap samples that will be b = n^gamma where n is the sample size of the original model.</p>
</td></tr>
<tr><td><code id="summary.regL1_+3A_...">...</code></td>
<td>
<p>Optional arguments. See <code>summary.rq</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regL1">regL1</a></code> for fitting linear L1 models.
<code>summary.rq</code> summary methods for Quantile Regression.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
