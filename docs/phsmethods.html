<!DOCTYPE html><html lang="en-GB"><head><title>Help for package phsmethods</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {phsmethods}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#age_calculate'><p>Calculate age between two dates</p></a></li>
<li><a href='#age_from_chi'><p>Extract age from the CHI number</p></a></li>
<li><a href='#area_lookup'><p>Codes and names of Scottish geographical and administrative areas.</p></a></li>
<li><a href='#chi_check'><p>Check the validity of a CHI number</p></a></li>
<li><a href='#chi_pad'><p>Add a leading zero to nine-digit CHI numbers</p></a></li>
<li><a href='#create_age_groups'><p>Create age groups</p></a></li>
<li><a href='#dob_from_chi'><p>Extract Date of Birth (DoB) from the CHI number</p></a></li>
<li><a href='#extract_fin_year'><p>Extract the formatted financial year from a date</p></a></li>
<li><a href='#file_size'><p>Calculate file size</p></a></li>
<li><a href='#format_postcode'><p>Format a postcode</p></a></li>
<li><a href='#make_inheritance_checks'><p>Check that a set of arguments inherits from a set of classes</p>
Throws an exception if one argument does not pass the checks.
Argument must have AT LEAST ONE of the specified classes to pass.</a></li>
<li><a href='#match_area'><p>Translate geography codes into area names</p></a></li>
<li><a href='#phsmethods'><p><code>phsmethods</code> package</p></a></li>
<li><a href='#qtr'><p>Assign a date to a quarter</p></a></li>
<li><a href='#rename'><p>Functions renamed in phsmethods 0.2.1 (Dec 2021)</p></a></li>
<li><a href='#sex_from_chi'><p>Extract sex from the CHI number</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Standard Methods for Use in Public Health Scotland</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of methods for commonly undertaken analytical
    tasks, primarily developed for Public Health Scotland (PHS) analysts,
    but the package is also generally useful to others working in the
    healthcare space, particularly since it has functions for working with
    Community Health Index (CHI) numbers. The package can help to make
    data manipulation and analysis more efficient and reproducible.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Public-Health-Scotland/phsmethods">https://github.com/Public-Health-Scotland/phsmethods</a>,
<a href="https://public-health-scotland.github.io/phsmethods/">https://public-health-scotland.github.io/phsmethods/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Public-Health-Scotland/phsmethods/issues">https://github.com/Public-Health-Scotland/phsmethods/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, dplyr, lifecycle, lubridate, magrittr, readr, rlang,
scales (&ge; 1.0.0), stringr, tibble, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, ggplot2, here, knitr, rmarkdown, spelling, testthat (&ge;
3.0.0)</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>lifecycle</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-08 14:30:34 UTC; yuyanf01</td>
</tr>
<tr>
<td>Author:</td>
<td>Public Health Scotland [cph],
  David Caldwell [aut],
  Lucinda Lawrie [rev],
  Jack Hannah [aut],
  Tina Fu [aut, cre],
  Ciara Gribben [aut],
  Chris Deans [aut],
  Jaime Villacampa [aut],
  Graeme Gowans [aut],
  Alice Byers [ctb],
  Alan Yeung [ctb],
  James McMahon <a href="https://orcid.org/0000-0002-5380-2029"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Nicolaos Christofidis [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tina Fu &lt;Yuyan.Fu2@phs.scot&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-08 23:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='age_calculate'>Calculate age between two dates</h2><span id='topic+age_calculate'></span>

<h3>Description</h3>

<p>This function calculates the age between two dates using
functions in <code>lubridate</code>. It calculates age in either years or months.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>age_calculate(
  start,
  end = if (lubridate::is.Date(start)) Sys.Date() else Sys.time(),
  units = c("years", "months"),
  round_down = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="age_calculate_+3A_start">start</code></td>
<td>
<p>A start date (e.g. date of birth) which must be supplied with
<code>Date</code> or <code>POSIXct</code> or <code>POSIXlt</code>
class. <code><a href="base.html#topic+as.Date">base::as.Date()</a></code>,
<code><a href="lubridate.html#topic+ymd">lubridate::dmy()</a></code> and
<code><a href="base.html#topic+as.POSIXlt">as.POSIXct()</a></code> are examples of functions which
can be used to store dates as an appropriate class.</p>
</td></tr>
<tr><td><code id="age_calculate_+3A_end">end</code></td>
<td>
<p>An end date which must be supplied with <code>Date</code> or <code>POSIXct</code> or
<code>POSIXlt</code> class. Default is <code>Sys.Date()</code> or <code>Sys.time()</code> depending on the
class of <code>start</code>.</p>
</td></tr>
<tr><td><code id="age_calculate_+3A_units">units</code></td>
<td>
<p>Type of units to be used. years and months are accepted.
Default is <code>years</code>.</p>
</td></tr>
<tr><td><code id="age_calculate_+3A_round_down">round_down</code></td>
<td>
<p>Should returned ages be rounded down to the nearest whole
number. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector representing the ages in the given units.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)
birth_date &lt;- lubridate::ymd("2020-02-29")
end_date &lt;- lubridate::ymd("2022-02-21")
age_calculate(birth_date, end_date)
age_calculate(birth_date, end_date, units = "months")

# If the start day is leap day (February 29th), age increases on 1st March
# every year.
leap1 &lt;- lubridate::ymd("2020-02-29")
leap2 &lt;- lubridate::ymd("2022-02-28")
leap3 &lt;- lubridate::ymd("2022-03-01")

age_calculate(leap1, leap2)
age_calculate(leap1, leap3)
</code></pre>

<hr>
<h2 id='age_from_chi'>Extract age from the CHI number</h2><span id='topic+age_from_chi'></span>

<h3>Description</h3>

<p><code>age_from_chi</code> takes a CHI number or a vector of CHI numbers
and returns the age as implied by the CHI number(s). If the Date of Birth
(DoB) is ambiguous it will return NA. It uses <code><a href="#topic+dob_from_chi">dob_from_chi()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>age_from_chi(
  chi_number,
  ref_date = NULL,
  min_age = 0,
  max_age = NULL,
  chi_check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="age_from_chi_+3A_chi_number">chi_number</code></td>
<td>
<p>a CHI number or a vector of CHI numbers with <code>character</code>
class.</p>
</td></tr>
<tr><td><code id="age_from_chi_+3A_ref_date">ref_date</code></td>
<td>
<p>calculate the age at this date, default is to use
<code>Sys.Date()</code> i.e. today.</p>
</td></tr>
<tr><td><code id="age_from_chi_+3A_min_age">min_age</code>, <code id="age_from_chi_+3A_max_age">max_age</code></td>
<td>
<p>optional min and/or max dates that the DoB could take
as the century needs to be guessed.
Must be either length 1 for a 'fixed' age or the same length as <code>chi_number</code>
for an age per CHI number.
<code>min_age</code> can be age based on common sense in the dataset, whilst <code>max_age</code>
can be age when an event happens such as the age at discharge.</p>
</td></tr>
<tr><td><code id="age_from_chi_+3A_chi_check">chi_check</code></td>
<td>
<p>logical, optionally skip checking the CHI for validity which
will be faster but should only be used if you have previously checked the
CHI(s), the default (TRUE) will to check the CHI numbers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector of ages in years truncated to the nearest year.
It will be the same length as <code>chi_number</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>age_from_chi("0101336489")

library(tibble)
library(dplyr)
data &lt;- tibble(chi = c(
  "0101336489",
  "0101405073",
  "0101625707"
), dis_date = as.Date(c(
  "1950-01-01",
  "2000-01-01",
  "2020-01-01"
)))

data %&gt;%
  mutate(chi_age = age_from_chi(chi))

data %&gt;%
  mutate(chi_age = age_from_chi(chi, min_age = 18, max_age = 65))

data %&gt;%
  mutate(chi_age = age_from_chi(chi,
    ref_date = dis_date
  ))
</code></pre>

<hr>
<h2 id='area_lookup'>Codes and names of Scottish geographical and administrative areas.</h2><span id='topic+area_lookup'></span>

<h3>Description</h3>

<p>A dataset containing Scotland's geography codes and associated area names.
It is used within <code><a href="#topic+match_area">match_area()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>area_lookup
</code></pre>


<h3>Format</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with 2 variables and over 17,000 rows:
</p>

<dl>
<dt>geo_code</dt><dd><p>Standard geography code - 9 characters</p>
</dd>
<dt>area_name</dt><dd><p>Name of the area the code represents</p>
</dd>
</dl>



<h3>Details</h3>

<p><code>geo_code</code> contains geography codes pertaining to Health
Boards, Council Areas, Health and Social Care Partnerships, Intermediate
Zones, Data Zones (2001 and 2011), Electoral Wards, Scottish Parliamentary
Constituencies, UK Parliamentary Constituencies, Travel to work areas,
National Parks, Community Health Partnerships, Localities (S19),
Settlements (S20) and Scotland.
</p>


<h3>Source</h3>

<p><a href="https://statistics.gov.scot/">https://statistics.gov.scot/</a>
</p>


<h3>See Also</h3>

<p>The script used to create the <code>area_lookup</code> dataset on
<a href="https://github.com/Public-Health-Scotland/phsmethods/blob/master/data-raw/area_lookup.R">GitHub</a>.
</p>

<hr>
<h2 id='chi_check'>Check the validity of a CHI number</h2><span id='topic+chi_check'></span>

<h3>Description</h3>

<p><code>chi_check</code> takes a CHI number or a vector of CHI numbers
with <code>character</code> class. It returns feedback on the validity of the
entered CHI number and, if found to be invalid, provides an explanation as
to why.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chi_check(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chi_check_+3A_x">x</code></td>
<td>
<p>a CHI number or a vector of CHI numbers with <code>character</code> class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Community Health Index (CHI) is a register of all patients in
NHS Scotland. A CHI number is a unique, ten-digit identifier assigned to
each patient on the index.
</p>
<p>The first six digits of a CHI number are a patient's date of birth in
DD/MM/YY format.
</p>
<p>The ninth digit of a CHI number identifies a patient's sex: odd for male,
even for female. The tenth digit is a check digit, denoted <code>checksum</code>.
</p>
<p>While a CHI number is made up exclusively of numeric digits, it cannot be
stored with <code>numeric</code> class in R. This is because leading zeros in
numeric values are silently dropped, a practice not exclusive to R. For this
reason, <code>chi_check</code> accepts input values of <code>character</code> class
only. A leading zero can be added to a nine-digit CHI number using
<code><a href="#topic+chi_pad">chi_pad()</a></code>.
</p>
<p><code>chi_check</code> assesses whether an entered CHI number is valid by checking
whether the answer to each of the following criteria is <code>Yes</code>:
</p>

<ul>
<li><p> Does it contain no non-numeric characters?
</p>
</li>
<li><p> Is it ten digits in length?
</p>
</li>
<li><p> Do the first six digits denote a valid date?
</p>
</li>
<li><p> Is the checksum digit correct?
</p>
</li></ul>



<h3>Value</h3>

<p><code>chi_check</code> returns a character string. Depending on the
validity of the entered CHI number, it will return one of the following:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;Valid CHI&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Invalid character(s) present&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Too many characters&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Too few characters&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Invalid date&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Invalid checksum&#8288;</code>
</p>
</li>
<li> <p><code>Missing (NA)</code>
</p>
</li>
<li> <p><code>Missing (Blank)</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>chi_check("0101011237")
chi_check(c("0101201234", "3201201234"))

library(dplyr)
df &lt;- tibble(chi = c(
  "3213201234",
  "123456789",
  "12345678900",
  "010120123?",
  NA
))
df %&gt;%
  mutate(validity = chi_check(chi))
</code></pre>

<hr>
<h2 id='chi_pad'>Add a leading zero to nine-digit CHI numbers</h2><span id='topic+chi_pad'></span>

<h3>Description</h3>

<p><code>chi_pad</code> takes a nine-digit CHI number with
<code>character</code> class and prefixes it with a zero. Any values provided
which are not a string comprised of nine numeric digits remain unchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chi_pad(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chi_pad_+3A_x">x</code></td>
<td>
<p>a CHI number or a vector of CHI numbers with <code>character</code> class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Community Health Index (CHI) is a register of all patients in
NHS Scotland. A CHI number is a unique, ten-digit identifier assigned to
each patient on the index.
</p>
<p>The first six digits of a CHI number are a patient's date of birth in
DD/MM/YY format. The first digit of a CHI number must, therefore, be 3 or
less. Depending on the source, CHI numbers are sometimes missing a leading
zero.
</p>
<p>While a CHI number is made up exclusively of numeric digits, it cannot be
stored with <code>numeric</code> class in R. This is because leading zeros in
numeric values are silently dropped, a practice not exclusive to R. For this
reason, <code>chi_pad</code> accepts input values of <code>character</code> class
only, and returns values of the same class. It does not assess the validity
of a CHI number - please see <code><a href="#topic+chi_check">chi_check()</a></code> for that.
</p>


<h3>Value</h3>

<p>The original character vector with CHI numbers padded if applicable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chi_pad(c("101011237", "101201234"))
</code></pre>

<hr>
<h2 id='create_age_groups'>Create age groups</h2><span id='topic+create_age_groups'></span>

<h3>Description</h3>

<p><code>create_age_groups()</code> takes a numeric vector and assigns each age to the
appropriate age group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_age_groups(x, from = 0, to = 90, by = 5, as_factor = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_age_groups_+3A_x">x</code></td>
<td>
<p>a vector of numeric values</p>
</td></tr>
<tr><td><code id="create_age_groups_+3A_from">from</code></td>
<td>
<p>the start of the smallest age group. The default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="create_age_groups_+3A_to">to</code></td>
<td>
<p>the end point of the age groups. The default is <code>90</code>.</p>
</td></tr>
<tr><td><code id="create_age_groups_+3A_by">by</code></td>
<td>
<p>the size of the age groups. The default is <code>5</code>.</p>
</td></tr>
<tr><td><code id="create_age_groups_+3A_as_factor">as_factor</code></td>
<td>
<p>The default behaviour is to return a character vector. Use
<code>TRUE</code> to return a factor vector instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>from</code>, <code>to</code> and <code>by</code> values are used to create distinct
age groups. <code>from</code> dictates the starting age of the lowest age group,
and <code>by</code> indicates how wide each group should be. <code>to</code> stipulates
the cut-off point at which all ages equal to or greater than this value
should be categorised together in a <code style="white-space: pre;">&#8288;to+&#8288;</code> group. If the specified value
of <code>to</code> is not a multiple of <code>by</code>, the value of <code>to</code> is
rounded down to the nearest multiple of <code>by</code>.
</p>
<p>The default values of <code>from</code>, <code>to</code> and <code>by</code> correspond to the
<a href="https://www.opendata.nhs.scot/dataset/standard-populations/resource/edee9731-daf7-4e0d-b525-e4c1469b8f69">European Standard Population</a>
age groups.
</p>


<h3>Value</h3>

<p>A character vector, where each element is the age group for the
corresponding element in <code>x</code>. If <code>as_factor = TRUE</code>, a factor
vector is returned instead.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>age &lt;- c(54, 7, 77, 1, 26, 101)

create_age_groups(age)
create_age_groups(age, from = 0, to = 80, by = 10)

# Final group may start below 'to'
create_age_groups(age, from = 0, to = 65, by = 10)

# To get the output as a factor:
create_age_groups(age, as_factor = TRUE)
</code></pre>

<hr>
<h2 id='dob_from_chi'>Extract Date of Birth (DoB) from the CHI number</h2><span id='topic+dob_from_chi'></span>

<h3>Description</h3>

<p><code>dob_from_chi</code> takes a CHI number or a vector of CHI numbers
and returns the Date of Birth (DoB) as implied by the CHI number(s). If the
DoB is ambiguous it will return NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dob_from_chi(chi_number, min_date = NULL, max_date = NULL, chi_check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dob_from_chi_+3A_chi_number">chi_number</code></td>
<td>
<p>a CHI number or a vector of CHI numbers with <code>character</code>
class.</p>
</td></tr>
<tr><td><code id="dob_from_chi_+3A_min_date">min_date</code>, <code id="dob_from_chi_+3A_max_date">max_date</code></td>
<td>
<p>optional min and/or max dates that the
DoB could take as the century needs to be guessed. Must be either length 1
for a 'fixed' date or the same length as <code>chi_number</code> for a date
per CHI number. <code>min_date</code> can be date based on common sense in the dataset,
whilst <code>max_date</code> can be date when an event happens such as discharge date.</p>
</td></tr>
<tr><td><code id="dob_from_chi_+3A_chi_check">chi_check</code></td>
<td>
<p>logical, optionally skip checking the CHI for validity which
will be faster but should only be used if you have previously checked the
CHI(s). The default (TRUE) will check the CHI numbers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a date vector of DoB. It will be the same length as <code>chi_number</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dob_from_chi("0101336489")

library(tibble)
library(dplyr)
data &lt;- tibble(chi = c(
  "0101336489",
  "0101405073",
  "0101625707"
), adm_date = as.Date(c(
  "1950-01-01",
  "2000-01-01",
  "2020-01-01"
)))

data %&gt;%
  mutate(chi_dob = dob_from_chi(chi))

data %&gt;%
  mutate(chi_dob = dob_from_chi(chi,
    min_date = as.Date("1930-01-01"),
    max_date = adm_date
  ))
</code></pre>

<hr>
<h2 id='extract_fin_year'>Extract the formatted financial year from a date</h2><span id='topic+extract_fin_year'></span>

<h3>Description</h3>

<p><code>extract_fin_year</code> takes a date and extracts the
correct financial year in the PHS specified format from it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_fin_year(date)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_fin_year_+3A_date">date</code></td>
<td>
<p>A date which must be supplied with <code>Date</code>, <code>POSIXct</code>, <code>POSIXlt</code> or
<code>POSIXt</code> class. <code><a href="base.html#topic+as.Date">base::as.Date()</a></code>,
<code><a href="lubridate.html#topic+ymd">lubridate::dmy()</a></code> and
<code><a href="base.html#topic+as.POSIXlt">as.POSIXct()</a></code> are examples of functions which
can be used to store dates as an appropriate class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PHS accepted format for financial year is YYYY/YY e.g. 2017/18.
</p>


<h3>Value</h3>

<p>A character vector of financial years in the form '2017/18'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- lubridate::dmy(c(21012017, 04042017, 17112017))
extract_fin_year(x)
</code></pre>

<hr>
<h2 id='file_size'>Calculate file size</h2><span id='topic+file_size'></span>

<h3>Description</h3>

<p><code>file_size</code> takes a filepath and an optional regular
expression pattern. It returns the size of all files within that directory
which match the given pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_size(filepath = getwd(), pattern = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="file_size_+3A_filepath">filepath</code></td>
<td>
<p>A character string denoting a filepath. Defaults to the
working directory, <code>getwd()</code>.</p>
</td></tr>
<tr><td><code id="file_size_+3A_pattern">pattern</code></td>
<td>
<p>An optional character string denoting a
<code><a href="base.html#topic+regex">regular expression()</a></code> pattern. Only file names which
match the regular expression will be returned. See the <strong>See Also</strong>
section for resources regarding how to write regular expressions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sizes of files with certain extensions are returned with the
type of file prefixed. For example, the size of a 12 KB <code>.xlsx</code> file is
returned as <code style="white-space: pre;">&#8288;Excel 12 KB&#8288;</code>. The complete list of explicitly catered-for file
extensions and their prefixes are as follows:
</p>

<ul>
<li> <p><code>.xls</code>, <code>.xlsb</code>, <code>.xlsm</code> and <code>.xlsx</code> files are
prefixed with <code>Excel</code>
</p>
</li>
<li> <p><code>.csv</code> files are prefixed with <code>CSV</code>
</p>
</li>
<li> <p><code>.sav</code> and <code>.zsav</code> files are prefixed with <code>SPSS</code>
</p>
</li>
<li> <p><code>.doc</code>, <code>.docm</code> and <code>.docx</code> files are prefixed with
<code>Word</code>
</p>
</li>
<li> <p><code>.rds</code> files are prefixed with <code>RDS</code>
</p>
</li>
<li> <p><code>.txt</code> files are prefixed with <code>Text</code>,
</p>
</li>
<li> <p><code>.fst</code> files are prefixed with <code>FST</code>,
</p>
</li>
<li> <p><code>.pdf</code> files are prefixed with <code>PDF</code>,
</p>
</li>
<li> <p><code>.tsv</code> files are prefixed with <code>TSV</code>,
</p>
</li>
<li> <p><code>.html</code> files are prefixed with <code>HTML</code>,
</p>
</li>
<li> <p><code>.ppt</code>, <code>.pptm</code> and <code>.pptx</code> files are prefixed with
<code>PowerPoint</code>,
</p>
</li>
<li> <p><code>.md</code> files are prefixed with <code>Markdown</code>
</p>
</li></ul>

<p>Files with extensions not contained within this list will have their size
returned with no prefix. To request that a certain extension be explicitly
catered for, please create an issue on
<a href="https://github.com/Public-Health-Scotland/phsmethods/issues">GitHub</a>.
</p>
<p>File sizes are returned as the appropriate multiple of the unit byte
(bytes (B), kilobytes (KB), megabytes (MB), etc.). Each multiple is taken to
be 1,024 units of the preceding denomination.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> listing the names of files within
<code>filepath</code> which match <code>pattern</code> and their respective sizes. The
column names of this tibble are <code>name</code> and <code>size</code>. If no <code>pattern</code> is
specified, <code>file_size</code> returns the names and sizes of all files within
<code>filepath</code>. File names and sizes are returned in alphabetical order of
file name. Sub-folders contained within <code>filepath</code> will return a file
size of <code style="white-space: pre;">&#8288;0 B&#8288;</code>.
</p>
<p>If <code>filepath</code> is an empty folder, or <code>pattern</code> matches no files
within <code>filepath</code>, <code>file_size</code> returns <code>NULL</code>.
</p>


<h3>See Also</h3>

<p>For more information on using regular expressions, see this
<a href="https://www.jumpingrivers.com/blog/regular-expressions-every-r-programmer-should-know/">Jumping Rivers blog post</a>
and this
<a href="https://stringr.tidyverse.org/articles/regular-expressions.html">vignette</a>
from the <code><a href="stringr.html#topic+stringr-package">stringr()</a></code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Name and size of all files in working directory
file_size()

# Name and size of .xlsx files only in working directory
file_size(pattern = "\\.xlsx$")

# Size only of alphabetically first file in working directory
library(magrittr)
file_size() %&gt;%
  dplyr::pull(size) %&gt;%
  extract(1)

</code></pre>

<hr>
<h2 id='format_postcode'>Format a postcode</h2><span id='topic+format_postcode'></span>

<h3>Description</h3>

<p><code>format_postcode</code> takes a character string or vector of
character strings. It extracts the input values which adhere to the standard
UK postcode format (with or without spaces), assigns the appropriate amount
of spacing to them (for both pc7 and pc8 formats) and ensures all letters
are capitalised.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_postcode(x, format = c("pc7", "pc8"), quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format_postcode_+3A_x">x</code></td>
<td>
<p>A character string or vector of character strings. Input values
which adhere to the standard UK postcode format may be upper or lower case
and will be formatted regardless of existing spacing. Any input values which
do not adhere to the standard UK postcode format will generate an NA and a
warning message - see <strong>Value</strong> section for more information.</p>
</td></tr>
<tr><td><code id="format_postcode_+3A_format">format</code></td>
<td>
<p>A character string denoting the desired output format. Valid
options are <code>pc7</code> and <code>pc8</code>. The default is <code>pc7</code>. See <strong>Value</strong>
section for more information on the string length of output values.</p>
</td></tr>
<tr><td><code id="format_postcode_+3A_quiet">quiet</code></td>
<td>
<p>(optional) If quiet is <code>TRUE</code> all messages and warnings will be
suppressed. This is useful in a production context and when you are sure of
the data or you are specifically using this function to remove invalid
postcodes. This will also make the function a bit quicker as fewer checks
are performed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard UK postcode format (without spaces) is:
</p>

<ul>
<li><p> 1 or 2 letters, followed by
</p>
</li>
<li><p> 1 number, followed by
</p>
</li>
<li><p> 1 optional letter or number, followed by
</p>
</li>
<li><p> 1 number, followed by
</p>
</li>
<li><p> 2 letters
</p>
</li></ul>

<p><a href="https://assets.publishing.service.gov.uk/government/uploads/system/uploads/attachment_data/file/283357/ILRSpecification2013_14Appendix_C_Dec2012_v1.pdf">UK government regulations</a>
mandate which letters and numbers can be used in specific sections of a
postcode. However, these regulations are liable to change over time. For
this reason, <code>format_postcode</code> does not validate whether a given
postcode actually exists, or whether specific numbers and letters are being
used in the appropriate places. It only assesses whether the given input is
consistent with the above format and, if so, assigns the appropriate amount
of spacing and capitalises any lower case letters.
</p>


<h3>Value</h3>

<p>When <code>format</code> is set equal to <code>pc7</code>, <code>format_postcode</code>
returns a character string of length 7. 5 character postcodes have two
spaces after the 2nd character; 6 character postcodes have 1 space after the
3rd character; and 7 character postcodes have no spaces.
</p>
<p>When <code>format</code> is set equal to <code>pc8</code>, <code>format_postcode</code> returns
a character string with maximum length 8. All postcodes, whether 5, 6 or 7
characters, have one space before the last 3 characters.
</p>
<p>Any input values which do not adhere to the standard UK postcode format will
generate an NA output value and a warning message. A warning is generated
rather than an error so as not to let one erroneously recorded postcode in a
large input vector prevent the remaining entries from being appropriately
formatted.
</p>
<p>Any input values which do adhere to the standard UK postcode format but
contain lower case letters will generate a warning message explaining that
these letters will be capitalised.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format_postcode("G26QE")
format_postcode(c("KA89NB", "PA152TY"), format = "pc8")

library(dplyr)
df &lt;- tibble(postcode = c("G429BA", "G207AL", "DD37JY", "DG98BS"))
df %&gt;%
  mutate(postcode = format_postcode(postcode))
</code></pre>

<hr>
<h2 id='make_inheritance_checks'>Check that a set of arguments inherits from a set of classes
Throws an exception if one argument does not pass the checks.
Argument must have AT LEAST ONE of the specified classes to pass.</h2><span id='topic+make_inheritance_checks'></span>

<h3>Description</h3>

<p>Check that a set of arguments inherits from a set of classes
Throws an exception if one argument does not pass the checks.
Argument must have AT LEAST ONE of the specified classes to pass.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_inheritance_checks(arguments, target_classes, ignore_null = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_inheritance_checks_+3A_arguments">arguments</code></td>
<td>
<p>a list object containing argument_name=argument pairs for
each argument. Argument names must be provided or else they will be ignored.</p>
</td></tr>
<tr><td><code id="make_inheritance_checks_+3A_target_classes">target_classes</code></td>
<td>
<p>character vector of the classes to check for.</p>
</td></tr>
<tr><td><code id="make_inheritance_checks_+3A_ignore_null">ignore_null</code></td>
<td>
<p>boolean. Indicates whether to ignore arguments with value
NULL (TRUE) or to throw an exception (FALSE). Default = TRUE.</p>
</td></tr>
</table>

<hr>
<h2 id='match_area'>Translate geography codes into area names</h2><span id='topic+match_area'></span>

<h3>Description</h3>

<p><code>match_area</code> takes a geography code or vector of geography
codes. It matches the input to the corresponding value in the
<code><a href="#topic+area_lookup">area_lookup()</a></code> dataset and returns the corresponding area name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_area(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match_area_+3A_x">x</code></td>
<td>
<p>A geography code or vector of geography codes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>match_area</code> relies predominantly on the standard 9 digit
geography codes. The only exceptions are:
</p>

<ul>
<li><p> RA2701: No Fixed Abode
</p>
</li>
<li><p> RA2702: Rest of UK (Outside Scotland)
</p>
</li>
<li><p> RA2703: Outside the UK
</p>
</li>
<li><p> RA2704: Unknown Residency
</p>
</li></ul>

<p><code>match_area</code> caters for both current and previous versions of geography
codes (e.g 2014 and 2019 Health Boards).
</p>
<p>It can account for geography codes pertaining to Health Boards, Council
Areas, Health and Social Care Partnerships, Intermediate Zones, Data Zones
(2001 and 2011), Electoral Wards, Scottish Parliamentary Constituencies,
UK Parliamentary Constituencies, Travel to work areas, National Parks,
Community Health Partnerships, Localities (S19), Settlements (S20) and
Scotland.
</p>
<p><code>match_area</code> returns a non-NA value only when an exact match is present
between the input value and the corresponding variable in the
<code><a href="#topic+area_lookup">area_lookup()</a></code> dataset. These exact matches are sensitive to both
case and spacing. It is advised to inspect <code><a href="#topic+area_lookup">area_lookup()</a></code> in the
case of unexpected results, as these may be explained by subtle differences
in transcription between the input value and the corresponding value in the
lookup dataset.
</p>


<h3>Value</h3>

<p>Each geography code within Scotland is unique, and consequently
<code>match_area</code> returns a single area name for each input value.
Any input value without a corresponding value in the
<code><a href="#topic+area_lookup">area_lookup()</a></code> dataset will return an NA output value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>match_area("S20000010")

library(dplyr)
df &lt;- tibble(code = c("S02000656", "S02001042", "S08000020", "S12000013"))
df %&gt;% mutate(name = match_area(code))

</code></pre>

<hr>
<h2 id='phsmethods'><code>phsmethods</code> package</h2><span id='topic+phsmethods'></span>

<h3>Description</h3>

<p>Standard Methods for use in PHS.
</p>


<h3>Details</h3>

<p>See the README on
<a href="https://github.com/Public-Health-Scotland/phsmethods#readme">GitHub</a>.
</p>

<hr>
<h2 id='qtr'>Assign a date to a quarter</h2><span id='topic+qtr'></span><span id='topic+qtr_end'></span><span id='topic+qtr_next'></span><span id='topic+qtr_prev'></span>

<h3>Description</h3>

<p>The qtr functions take a date input and calculate the relevant
quarter-related value from it. They all return the year as part of this
value.
</p>

<ul>
<li> <p><code>qtr</code> returns the current quarter
</p>
</li>
<li> <p><code>qtr_end</code> returns the last month in the quarter
</p>
</li>
<li> <p><code>qtr_next</code> returns the next quarter
</p>
</li>
<li> <p><code>qtr_prev</code> returns the previous quarter
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>qtr(date, format = c("long", "short"))

qtr_end(date, format = c("long", "short"))

qtr_next(date, format = c("long", "short"))

qtr_prev(date, format = c("long", "short"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qtr_+3A_date">date</code></td>
<td>
<p>A date which must be supplied with <code>Date</code> or <code>POSIXct</code></p>
</td></tr>
<tr><td><code id="qtr_+3A_format">format</code></td>
<td>
<p>A <code>character</code> string specifying the format the quarter
should be displayed in. Valid options are <code>long</code> (January to March 2018) and
<code>short</code> (Jan-Mar 2018). The default is <code>long</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Quarters are defined as:
</p>

<ul>
<li><p> January to March (Jan-Mar)
</p>
</li>
<li><p> April to June (Apr-Jun)
</p>
</li>
<li><p> July to September (Jul-Sep)
</p>
</li>
<li><p> October to December (Oct-Dec)
</p>
</li></ul>



<h3>Value</h3>

<p>A character vector of financial quarters in the specified format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- lubridate::dmy(c(26032012, 04052012, 23092012))
qtr(x)
qtr_end(x, format = "short")
qtr_next(x)
qtr_prev(x, format = "short")

</code></pre>

<hr>
<h2 id='rename'>Functions renamed in phsmethods 0.2.1 (Dec 2021)</h2><span id='topic+postcode'></span><span id='topic+age_group'></span><span id='topic+fin_year'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>phsmethods 0.2.1 renamed a number of functions
to improve code clarity. The old functions no longer
work and will error. At the next update they will be
removed completely.
</p>

<ul>
<li> <p><code>postcode()</code> → <code>format_postcode()</code>
</p>
</li>
<li> <p><code>age_group()</code> → <code>create_age_groups()</code>
</p>
</li>
<li> <p><code>fin_year()</code> → <code>extract_fin_year()</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>postcode(x, format = c("pc7", "pc8"))

age_group(x, from = 0, to = 90, by = 5, as_factor = FALSE)

fin_year(date)
</code></pre>


<h3>Value</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>

<hr>
<h2 id='sex_from_chi'>Extract sex from the CHI number</h2><span id='topic+sex_from_chi'></span>

<h3>Description</h3>

<p><code>sex_from_chi</code> takes a CHI number or a vector of CHI numbers
and returns the sex as implied by the CHI number(s). The default return type
is an integer but this can be modified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sex_from_chi(
  chi_number,
  male_value = 1L,
  female_value = 2L,
  as_factor = FALSE,
  chi_check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sex_from_chi_+3A_chi_number">chi_number</code></td>
<td>
<p>a CHI number or a vector of CHI numbers with <code>character</code>
class.</p>
</td></tr>
<tr><td><code id="sex_from_chi_+3A_male_value">male_value</code>, <code id="sex_from_chi_+3A_female_value">female_value</code></td>
<td>
<p>optionally supply custom values for Male and
Female. Note that that these must be of the same class.</p>
</td></tr>
<tr><td><code id="sex_from_chi_+3A_as_factor">as_factor</code></td>
<td>
<p>logical, optionally return as a factor with labels <code>'Male'</code>
and <code>'Female'</code>. Note that this will override any custom values supplied with
<code>male_value</code> or <code>female_value</code>.</p>
</td></tr>
<tr><td><code id="sex_from_chi_+3A_chi_check">chi_check</code></td>
<td>
<p>logical, optionally skip checking the CHI for validity which
will be faster but should only be used if you have previously checked the
CHI(s).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Community Health Index (CHI) is a register of all patients in
NHS Scotland. A CHI number is a unique, ten-digit identifier assigned to
each patient on the index.
</p>
<p>The ninth digit of a CHI number identifies a patient's sex: odd for men,
even for women.
</p>
<p>The default behaviour for <code>sex_from_chi</code> is to first check the CHI number is
valid using <code>check_chi</code> and then to return 1 for male and 2 for female.
</p>
<p>There are options to return custom values e.g. <code>'M'</code> and <code>'F'</code> or to return
a factor which will have labels <code>'Male'</code> and <code style="white-space: pre;">&#8288;'Female')&#8288;</code>
</p>


<h3>Value</h3>

<p>a vector with the same class as <code>male_value</code> and <code>female_value</code>,
(integer by default) unless <code>as_factor</code> is <code>TRUE</code> in which case a factor will
be returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sex_from_chi("0101011237")
sex_from_chi(c("0101011237", "0101336489", NA))
sex_from_chi(
  c("0101011237", "0101336489", NA),
  male_value = "M",
  female_value = "F"
)
sex_from_chi(c("0101011237", "0101336489", NA), as_factor = TRUE)

library(dplyr)
df &lt;- tibble(chi = c("0101011237", "0101336489", NA))
df %&gt;% mutate(chi_sex = sex_from_chi(chi))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
