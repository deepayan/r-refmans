<!DOCTYPE html><html><head><title>Help for package diffmatchpatch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {diffmatchpatch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#diff_make'><p>Compute diffs between text strings</p></a></li>
<li><a href='#dmp_options'><p>diffmatchpatch settings</p></a></li>
<li><a href='#match_find'><p>Fuzzy matching of a text string</p></a></li>
<li><a href='#patch_make'><p>Create and apply patches to a text string</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>String Diff, Match, and Patch Utilities</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-04-10</td>
</tr>
<tr>
<td>Copyright:</td>
<td>Google Inc., Neil Fraser, Mike Slemmer, Sergey Nozhenko,
Christian Leutloff, Colin Rundel</td>
</tr>
<tr>
<td>Description:</td>
<td>A wrapper for Google's 'diff-match-patch' library. It provides basic tools
    for computing diffs, finding fuzzy matches, and constructing / applying patches to strings.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rundel/diffmatchpatch">https://github.com/rundel/diffmatchpatch</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rundel/diffmatchpatch/issues">https://github.com/rundel/diffmatchpatch/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-04-15 11:43:59 UTC; rundel</td>
</tr>
<tr>
<td>Author:</td>
<td>Colin Rundel [aut, cre],
  Google Inc. [cph] (diff_match_patch.h),
  Neil Fraser [cph] (diff_match_patch.h),
  Mike Slemmer [cph] (diff_match_patch.h),
  Sergey Nozhenko [cph] (diff_match_patch.h),
  Christian Leutloff [cph] (diff_match_patch.h)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Colin Rundel &lt;rundel@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-04-16 07:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='diff_make'>Compute diffs between text strings</h2><span id='topic+diff_make'></span><span id='topic+diff_levenshtein'></span><span id='topic+diff_to_delta'></span><span id='topic+diff_from_delta'></span><span id='topic+diff_to_html'></span><span id='topic+diff_to_patch'></span><span id='topic+diff_text_source'></span><span id='topic+diff_text_dest'></span><span id='topic+diff'></span>

<h3>Description</h3>

<p>The following functions are used to construct or work with diff(s) between text strings.
Specifically, <code>diff_make()</code> computes the character level differences between
the source string (<code>x</code>) and destination string (<code>y</code>). These diffs can be made more human
friendly via a secondary cleaning process via the <code>cleanup</code> argument.
</p>
<p>Once computed, diffs are represented using <code>diff_df</code> data frames, which consist of just
two columns: <code>text</code> and <code>op</code>. Basic convenience functions for pretty printing of these are
provided by the package.
</p>
<p>The following helper functions are provided:
</p>

<ul>
<li> <p><code>print()</code> - prints a diff using ANSI colors if available.
</p>
</li>
<li> <p><code>as.character()</code> - converts a diff (using ANSI colors if available) to a character vector.
</p>
</li>
<li> <p><code>diff_levenshtein()</code> calculates the Levenshtein distance of a diff.
</p>
</li>
<li> <p><code>diff_to_delta()</code> converts a diff to a delta string.
</p>
</li>
<li> <p><code>diff_from_delta()</code> creates a diff from a source string (<code>x</code>) and a <code>delta</code> string.
</p>
</li>
<li> <p><code>diff_to_html()</code> converts a diff to pretty HTML string.
</p>
</li>
<li> <p><code>diff_to_patch()</code> converts a diff to a patch string.
</p>
</li>
<li> <p><code>diff_text_source()</code> recovers the source string from a diff.
</p>
</li>
<li> <p><code>diff_text_dest()</code> recovers the destination string from a diff.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>diff_make(x, y, cleanup = "semantic", checklines = TRUE)

diff_levenshtein(diff)

diff_to_delta(diff)

diff_from_delta(x, delta)

diff_to_html(diff)

diff_to_patch(diff)

diff_text_source(diff)

diff_text_dest(diff)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff_make_+3A_x">x</code></td>
<td>
<p>The source string</p>
</td></tr>
<tr><td><code id="diff_make_+3A_y">y</code></td>
<td>
<p>The destination string</p>
</td></tr>
<tr><td><code id="diff_make_+3A_cleanup">cleanup</code></td>
<td>
<p>Determines the cleanup method applied to the diffs. Allowed values include:
<code>semantic</code>, <code>lossless</code>, <code>efficiency</code>, <code>merge</code> and <code>none</code>. See Details for the behavior of
these methods.</p>
</td></tr>
<tr><td><code id="diff_make_+3A_checklines">checklines</code></td>
<td>
<p>Performance flag - if <code>FALSE</code>, then don't run a
line-level diff first to identify the changed areas.
If <code>TRUE</code>, run a faster slightly less optimal diff. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="diff_make_+3A_diff">diff</code></td>
<td>
<p>A <code>diff_df</code> data frame.</p>
</td></tr>
<tr><td><code id="diff_make_+3A_delta">delta</code></td>
<td>
<p>A delta string.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Cleanup methods</h4>


<ul>
<li> <p><code>semantic</code> - Reduce the number of edits by eliminating semantically trivial equalities.
</p>
</li>
<li><p> semantic <code>lossless</code> - Look for single edits surrounded on both sides by equalities
which can be shifted sideways to align the edit to a word boundary.
e.g: The c<strong>at c</strong>ame. -&gt; The **cat **came.
</p>
</li>
<li> <p><code>efficiency</code> - Reduce the number of edits by eliminating operationally trivial equalities.
</p>
</li>
<li> <p><code>merge</code> - Reorder and merge like edit sections.  Merge equalities.
Any edit section can move as long as it doesn't cross an equality.
</p>
</li>
<li> <p><code>none</code> - Do not apply any cleanup methods to the diffs.
</p>
</li></ul>




<h3>Value</h3>


<ul>
<li> <p><code>diff_make()</code> returns a <code>diff_df</code> data frame containing the diffs.
</p>
</li></ul>


<ul>
<li> <p><code>diff_make()</code> returns the Levenshtein distance as an integer.
</p>
</li></ul>


<ul>
<li> <p><code>diff_to_delta()</code> returns an character string.
</p>
</li></ul>


<ul>
<li> <p><code>diff_from_delta()</code> returns a <code>diff_df</code> data frame.
</p>
</li></ul>


<ul>
<li> <p><code>diff_to_html()</code> returns a character string.
</p>
</li></ul>


<ul>
<li> <p><code>diff_to_patch()</code> returns a character string.
</p>
</li></ul>


<ul>
<li> <p><code>diff_text_source()</code> returns a character string.
</p>
</li></ul>


<ul>
<li> <p><code>diff_text_dest()</code> returns a character string.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>(d = diff_make("abcdef", "abchij"))

diff_levenshtein(d)

diff_to_html(d)

diff_text_source(d) 

diff_text_dest(d) 

diff_to_patch(d)

(delta = diff_to_delta(d))

diff_from_delta("abcdef", delta)
</code></pre>

<hr>
<h2 id='dmp_options'>diffmatchpatch settings</h2><span id='topic+dmp_options'></span>

<h3>Description</h3>

<p>Allows for examining or setting options that affect the behavior of the
diff, match, and patch related functions in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmp_options(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmp_options_+3A_...">...</code></td>
<td>
<p>No arguments returns all current options and their values. Character values retrieve a subset
of options and the current values. Options can be set, using name = value. However, only the options named
below are used. Options can also be passed by giving a single unnamed argument which is a named list.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Available options</h4>


<ul>
<li> <p><code>diff_timeout</code> (float) - Number of seconds to map a diff before giving up (0 for infinity).
</p>
</li>
<li> <p><code>diff_edit_cost</code> (int) - Cost of an empty edit operation in terms of edit characters.
</p>
</li>
<li> <p><code>match_threshold</code> (float) - At what point is no match declared (0.0 = perfection, 1.0 = very loose).
</p>
</li>
<li> <p><code>match_distance</code> (int) - How far to search for a match (0 = exact location, 1000+ = broad match).
A match this many characters away from the expected location will add
1.0 to the score (0.0 is a perfect match).
</p>
</li>
<li> <p><code>patch_delete_threshold</code> (float) - When deleting a large block of text (over ~64 characters), how close does
the contents have to match the expected contents. (0.0 = perfection,
1.0 = very loose).  Note that Match_Threshold controls how closely the
end points of a delete need to match.
</p>
</li>
<li> <p><code>patch_margin</code> (int) - Chunk size for context length.
</p>
</li>
<li> <p><code>match_max_bits</code> (int) - The number of bits in an int.
</p>
</li></ul>




<h3>Value</h3>

<p>When getting options returns a named list of options and their current values,
when setting options returns a named list of the previous value(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dmp_options()

dmp_options("diff_timeout")

prev = dmp_options(diff_timeout = 5)
prev

</code></pre>

<hr>
<h2 id='match_find'>Fuzzy matching of a text string</h2><span id='topic+match_find'></span><span id='topic+match'></span>

<h3>Description</h3>

<p>Locate the best instance of <code>pattern</code> in the <code>text</code> near <code>loc</code> using the
Bitap algorithm.Returns <code>-1</code> if no match found. Assumes R's typical 1-based indexing for <code>loc</code>
and the returned value.
</p>
<p>This algorithm makes use of the <code>match_distance</code> and <code>match_threshold</code> options to determine
the match. If these values are not set explicitly via the <code>threshold</code> and <code>distance</code> arguments -
their value will use the currently set global option value.
</p>
<p>Candidate matches are scored based on:
a) the number of spelling differences between the pattern and the text and
b) the distance between the candidate match and the expected location.
</p>
<p>The <code>match_distance</code> option determines the relative importance of these two metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_find(text, pattern, loc = 1L, threshold = NULL, distance = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_find_+3A_text">text</code></td>
<td>
<p>The text to search.</p>
</td></tr>
<tr><td><code id="match_find_+3A_pattern">pattern</code></td>
<td>
<p>The pattern to search for.</p>
</td></tr>
<tr><td><code id="match_find_+3A_loc">loc</code></td>
<td>
<p>The expected location of the pattern.</p>
</td></tr>
<tr><td><code id="match_find_+3A_threshold">threshold</code></td>
<td>
<p>Threshold for determining a match (0 - perfect match, 1 - very loose).</p>
</td></tr>
<tr><td><code id="match_find_+3A_distance">distance</code></td>
<td>
<p>Distance from expected location scaling for score penalty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Index of best match or -1 for no match.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor 
incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud 
exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure 
dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. 
Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt 
mollit anim id est laborum."

match_find(x, "Loren Ibsen")
match_find(x, "Loren Ibsen", threshold = 0.1)

match_find(x, "minimum")
match_find(x, "minimum", threshold = 0.4)

</code></pre>

<hr>
<h2 id='patch_make'>Create and apply patches to a text string</h2><span id='topic+patch_make'></span><span id='topic+patch_apply'></span><span id='topic+patch'></span>

<h3>Description</h3>

<p>Patches are constructed via <code>patch_make()</code> and applied using <code>patch_apply()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patch_make(x, y)

patch_apply(x, patch)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patch_make_+3A_x">x</code></td>
<td>
<p>The source string</p>
</td></tr>
<tr><td><code id="patch_make_+3A_y">y</code></td>
<td>
<p>The destination string</p>
</td></tr>
<tr><td><code id="patch_make_+3A_patch">patch</code></td>
<td>
<p>A string representation of the patch(es).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>patch_make()</code> returns a string representation of the patch(es).
</p>

<ul>
<li> <p><code>patch_apply()</code> returns the patched version of the string <code>x</code>,
the <code>matches</code> attribute contains logical values indicating which patches
were successfully applied.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
(p = patch_make("abcdef", "abchij"))

patch_apply("abcdef", p)

patch_apply("abc", p)

patch_apply("def", p)

patch_apply("hij", p)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
