<!DOCTYPE html><html><head><title>Help for package RCurl</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RCurl}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AUTH_ANY'><p>Constants for identifying Authentication Schemes</p></a></li>
<li><a href='#base64'><p>Encode/Decode base64 content</p></a></li>
<li><a href='#basicHeaderGatherer'><p>Functions for processing the response header of a libcurl request</p></a></li>
<li><a href='#basicTextGatherer'><p>Cumulate text across callbacks (from an HTTP response)</p></a></li>
<li><a href='#binaryBuffer'><p>Create internal C-level data structure for collecting binary data</p></a></li>
<li><a href='#CFILE'><p>Create a C-level handle for a file</p></a></li>
<li><a href='#chunkToLineReader'><p>Utility that collects data from the HTTP reply into lines and</p>
calls user-provided function.</a></li>
<li><a href='#clone'><p>Clone/duplicate an object</p></a></li>
<li><a href='#complete'><p>Complete an asynchronous HTTP request</p></a></li>
<li><a href='#CURLEnums'><p>Classes and coercion methods for enumerations in libcurl</p></a></li>
<li><a href='#curlError'><p>Raise a warning or error about a CURL problem</p></a></li>
<li><a href='#curlEscape'><p>Handle characters in URL that need to be escaped</p></a></li>
<li><a href='#CurlFeatureBits'><p>Constants for libcurl</p></a></li>
<li><a href='#curlGlobalInit'><p>Start and stop the Curl library</p></a></li>
<li><a href='#CURLHandle-class'><p>Class &quot;CURLHandle&quot; for synchronous HTTP requests</p></a></li>
<li><a href='#curlOptions'><p>Constructor and accessors for CURLOptions objects</p></a></li>
<li><a href='#curlPerform'><p>Perform the HTTP query</p></a></li>
<li><a href='#curlSetOpt'><p>Set values for the CURL options</p></a></li>
<li><a href='#curlVersion'><p>Information describing the Curl library</p></a></li>
<li><a href='#dynCurlReader'><p>Dynamically determine content-type of body from HTTP header and</p>
set body reader</a></li>
<li><a href='#fileUpload'><p>Specify information about a file to upload in an HTTP request</p></a></li>
<li><a href='#findHTTPHeaderEncoding'><p>Find the encoding of the HTTP response from the HTTP header</p></a></li>
<li><a href='#ftpUpload'><p>Upload content via FTP</p></a></li>
<li><a href='#getBinaryURL'><p>Download binary content</p></a></li>
<li><a href='#getBitIndicators'><p>Operate on bit fields</p></a></li>
<li><a href='#getCurlErrorClassNames'><p>Retrieve names of all curl error classes</p></a></li>
<li><a href='#getCurlHandle'><p>Create libcurl handles</p></a></li>
<li><a href='#getCurlInfo'><p>Access information about a CURL request</p></a></li>
<li><a href='#getFormParams'><p>Extract parameters from a form query string</p></a></li>
<li><a href='#getURIAsynchronous'><p>Download multiple URIs concurrently, with inter-leaved downloads</p></a></li>
<li><a href='#getURL'><p>Download a URI</p></a></li>
<li><a href='#guessMIMEType'><p>Infer the MIME type from a file name</p></a></li>
<li><a href='#HTTP_VERSION_1_0'><p>Symbolic constants for specifying HTTP and SSL versions in libcurl</p></a></li>
<li><a href='#httpPUT'><p>Simple high-level functions for HTTP PUT and DELETE</p></a></li>
<li><a href='#merge.list'><p>Method for merging two lists by name</p></a></li>
<li><a href='#mimeTypeExtensions'><p>Mapping from extension to MIME type</p></a></li>
<li><a href='#MultiCURLHandle-class'><p>Class &quot;MultiCURLHandle&quot; for asynchronous, concurrent HTTP requests</p></a></li>
<li><a href='#postForm'><p>Submit an HTML form</p></a></li>
<li><a href='#RCurlInternal'><p>Internal functions</p></a></li>
<li><a href='#reset'><p>Generic function for resetting an object</p></a></li>
<li><a href='#scp'><p>Retrieve contents of a file from a remote host via SCP (Secure Copy)</p></a></li>
<li><a href='#url.exists'><p>Check if URL exists</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.98-1.14</td>
</tr>
<tr>
<td>Title:</td>
<td>General Network (HTTP/FTP/...) Client Interface for R</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make, libcurl</td>
</tr>
<tr>
<td>Description:</td>
<td>A wrapper for 'libcurl' <a href="https://curl.se/libcurl/">https://curl.se/libcurl/</a>
	Provides functions to allow one to compose general HTTP requests
        and provides convenient functions to fetch URIs, get &amp; post
        forms, etc. and process the results returned by the Web server.
        This provides a great deal of control over the HTTP/FTP/...
        connection and the form of the request while providing a
        higher-level interface than is available just using R socket
        connections.  Additionally, the underlying implementation is
        robust and extensive, supporting FTP/FTPS/TFTP (uploads and
        downloads), SSL/HTTPS, telnet, dict, ldap, and also supports
        cookies, redirects, authentication, etc.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>bitops</td>
</tr>
<tr>
<td>Suggests:</td>
<td>XML</td>
</tr>
<tr>
<td>Collate:</td>
<td>aclassesEnums.R bitClasses.R xbits.R base64.R binary.S
classes.S curl.S curlAuthConstants.R curlEnums.R curlError.R
curlInfo.S dynamic.R form.S getFormParams.R getURLContent.R
header.R http.R httpError.R httpErrors.R iconv.R info.S mime.R
multi.S options.S scp.R support.S upload.R urlExists.R zclone.R
zzz.R</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-08 16:11:59 UTC; ligges</td>
</tr>
<tr>
<td>Author:</td>
<td>CRAN Team [ctb, cre] (de facto maintainer since 2013),
  Duncan Temple Lang
    <a href="https://orcid.org/0000-0003-0159-1546"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>CRAN Team &lt;CRAN@r-project.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-09 08:20:41 UTC</td>
</tr>
</table>
<hr>
<h2 id='AUTH_ANY'>Constants for identifying Authentication Schemes</h2><span id='topic+AUTH_ANY'></span><span id='topic+AUTH_ANYSAFE'></span><span id='topic+AUTH_BASIC'></span><span id='topic+AUTH_DIGEST'></span><span id='topic+AUTH_DIGEST_IE'></span><span id='topic+AUTH_GSSNEGOTIATE'></span><span id='topic+AUTH_NONE'></span><span id='topic+AUTH_NTLM'></span><span id='topic+AUTH_NTLM_WB'></span><span id='topic+AUTH_ONLY'></span>

<h3>Description</h3>

<p>These variables  are symbolic constants that allow
use to specify different combinations of schemes
for HTTP authentication in a request to a Web server.
We can combine them via the <code>|</code> operator to
indicate that libcurl should try them in order until one works.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   AUTH_BASIC | AUTH_DIGEST
</code></pre>

<hr>
<h2 id='base64'>Encode/Decode base64 content</h2><span id='topic+base64'></span><span id='topic+base64Encode'></span><span id='topic+base64Decode'></span>

<h3>Description</h3>

<p>These functions encode and decode strings using base64 representations.
<code>base64</code> can be used as  a single entry point with an argument to 
encode or decode. The other two functions perform the specific action.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base64(txt, encode = !inherits(txt, "base64"), mode = "character")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base64_+3A_txt">txt</code></td>
<td>
<p>character string to encode or decode</p>
</td></tr>
<tr><td><code id="base64_+3A_encode">encode</code></td>
<td>
<p>logical value indicating whether the desired action is to encode or decode the object.
If <code>txt</code> has (S3) class <code>base64</code>, the default is to decode this.
</p>
</td></tr>
<tr><td><code id="base64_+3A_mode">mode</code></td>
<td>
<p>a character string which is either &quot;raw&quot; or &quot;character&quot;.
This controls the type of vector that is returned.
If this is &quot;raw&quot;, a raw vector is created.  Otherwise, a character
vector of length 1 is returned and its element is the text version
of the original data given in <code>txt</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This calls the routines in libcurl. These are not
declared in the curl header files. So the support
may need to be handled carefully on some platforms,
e.g. Microsoft Windows.
</p>


<h3>Value</h3>

<p>If encode is <code>TRUE</code>, a character vector
with a class named <code>base64</code>.
If decode is <code>TRUE</code>, a simple string.
</p>


<h3>Note</h3>

<p>This is currently not vectorized.
</p>
<p>We might extend this to work with raw objects.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>libcurl - <a href="https://curl.se/">https://curl.se/</a>
Wikipedia's explanation of base 64 encoding - <a href="https://en.wikipedia.org/wiki/Base64">https://en.wikipedia.org/wiki/Base64</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # encode and then decode a simple string.
  txt = "Some simple text for base 64 to handle"
  x = base64(txt)
  base64(x)

    # encode to a raw vector
  x = base64("Simple text", TRUE, "raw")

    # decode to a character string.
  ans = base64Decode(x)
  ans == txt
    # decoded to a raw format.
  ans = base64Decode(x, "raw")


   # Binary data
#  f = paste(R.home(), "doc", "html", "logo.jpg", sep = .Platform$file.sep)
  f = system.file("examples", "logo.jpg", package = "RCurl")
  img = readBin(f, "raw", file.info(f)[1, "size"])
  b64 = base64Encode(img, "raw")
  back = base64Decode(b64, "raw")
  identical(img, back)

   # alternatively, we can encode to a string and then decode back again
   # to raw and see that we preserve the date.
 
  enc = base64Encode(img, "character")
  dec = base64Decode(enc, "raw")
  identical(img, dec)


   # The following would be the sort of computation we could do if we
   # could have in-memory raw connections.
   # We would save() some objects to such an in-memory binary/raw connection
   # and then encode the resulting raw vector into a character vector.
   # Then we can insert that into a message, e.g. an email message or
   # an XML document and when we receive it in a different R session
   # we would get the string and reverse the encoding from the string to
   # a raw vector
   # In the absence of that in-memory connection  facility in save(),
   # we can use a file.
  
  x = 1:10

   # save two objects - a function and a vector
  f = paste(tempfile(), "rda", sep = ".")
  save(base64, x, file = f)

   # now read the results back from that file as a raw vector
  data = readBin(f, "raw", file.info(f)[1,"size"])

   # base64 encode it
  txt = base64Encode(data, "character")

  if(require(XML)) {
    tt = xmlTree("r:data", namespaces = c(r = "http://www.r-project.org"))
    tt$addNode(newXMLTextNode(txt))
    out = saveXML(tt)


    doc = xmlRoot(xmlTreeParse(out, asText = TRUE))
    rda = base64Decode(xmlValue(doc), "raw")
    f = tempfile()
    writeBin(rda, f)
    e = new.env()
    load(f, e)
    objects(e)
  }

   # we'd like to be able to do
   #  con = rawConnection(raw(), 'r+')
   #  save(base64, x, file = con)
   #  txt = base64Encode(rawConnectionValue(con), "character")
   # ... write and read xml stuff
   #  val = xmlValue(doc)
   #  rda = base64Decode(val, "raw")
   #  e = new.env()
   #  input = rawConnection(o, "r")
   #  load(input, e)
</code></pre>

<hr>
<h2 id='basicHeaderGatherer'>Functions for processing the response header of a libcurl request</h2><span id='topic+basicHeaderGatherer'></span><span id='topic+parseHTTPHeader'></span>

<h3>Description</h3>

<p>These two functions are used to collect the contents of the header of
an HTTP response via the <code>headerfunction</code> option of a curl handle
and then processing that text into both the name: value pairs
and also the initial line of the response that provides the
status of the request.
<code>basicHeaderGatherer</code> is a simple special case of
<code><a href="#topic+basicTextGatherer">basicTextGatherer</a></code> with the built-in post-processing
step done by <code>parseHTTPHeader</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basicHeaderGatherer(txt = character(), max = NA)
parseHTTPHeader(lines, multi = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basicHeaderGatherer_+3A_txt">txt</code></td>
<td>
<p>any initial text that we want included with the header.
This is passed to <code><a href="#topic+basicTextGatherer">basicTextGatherer</a></code>. Generally it
should not be specified unless there is a good reason.</p>
</td></tr>
<tr><td><code id="basicHeaderGatherer_+3A_max">max</code></td>
<td>
<p>This is passed directly to
<code><a href="#topic+basicTextGatherer">basicTextGatherer</a></code></p>
</td></tr>
<tr><td><code id="basicHeaderGatherer_+3A_lines">lines</code></td>
<td>
<p> the text as a character vector from the response header
that
<code>parseHTTPHeader</code> will convert to a status and name-value
pairs.</p>
</td></tr> 
<tr><td><code id="basicHeaderGatherer_+3A_multi">multi</code></td>
<td>
<p>a logical value controlling whether we check for
multiple HTTP headers in the lines of text. This is caused
by a Continue being concatenated with the actual response.
When this is <code>TRUE</code>, we look for the lines
that start an HTTP header, e.g. <code>HTTP 200 ...</code>,
and we use the content from the last of these.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return value is the same as <code><a href="#topic+basicTextGatherer">basicTextGatherer</a></code>,
i.e. a list with
<code>update</code>, <code>value</code> and <code>reset</code> function elements.
The <code>value</code> element will invoke <code>parseHTTPHeader</code>
on the contents read during the processing of the  libcurl request
and return that value.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>Curl homepage <a href="https://curl.se/">https://curl.se/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+basicTextGatherer">basicTextGatherer</a></code>
<code><a href="#topic+curlPerform">curlPerform</a></code>    
<code><a href="#topic+curlSetOpt">curlSetOpt</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if(url.exists("https://www.omegahat.net/RCurl/index.html")) withAutoprint({
     h = basicHeaderGatherer()
     getURI("https://www.omegahat.net/RCurl/index.html",
              headerfunction = h$update)
     names(h$value())
     h$value()
  })
</code></pre>

<hr>
<h2 id='basicTextGatherer'>Cumulate text across callbacks (from an HTTP response)</h2><span id='topic+basicTextGatherer'></span><span id='topic+multiTextGatherer'></span><span id='topic+debugGatherer'></span>

<h3>Description</h3>

<p>These functions create callback functions that can be used
to with the libcurl engine  when it passes information to us
when it is available as part of the HTTP response.
</p>
<p><code>basicTextGatherer</code> is a generator function that returns a closure which is
used to cumulate text provided in callbacks from the libcurl
engine when it reads the response from an HTTP request.
</p>
<p><code>debugGatherer</code> can be used with the <code>debugfunction</code>
libcurl option in a call and the associated <code>update</code>
function is called whenever libcurl has information
about the header, data and general messages about the
request.
</p>
<p>These functions return a list of functions.
Each time one calls <code>basicTextGatherer</code> or
<code>debugGatherer</code>, one gets a new, separate
collection of functions.  However, each
collection of functions (or instance) shares
the variables across the functions and across calls.
This allows them to store data persistently across
the calls without using a global variable.
In this way, we can have multiple instances of the collection
of functions, with each instance updating its own local state
and not interfering with those of the others.
</p>
<p>We use an S3 class named <code>RCurlCallbackFunction</code> to indicate
that the collection of funcions can be used as a callback.
The <code>update</code> function is the one that is actually used
as the callback function in the CURL option.
The <code>value</code> function can be invoked to get the current
state that has been accumulated by the
<code>update</code> function.  This is typically used
when the request is complete.
One can reuse the same collection of functions across
different requests. The information will be cumulated.
Sometimes it is convenient to reuse the object but
reset the state to its original empty value, as it had
been created afresh. The <code>reset</code> function in the collection
permits this.
</p>
<p><code>multiTextGatherer</code> is used when we are downloading multiple
URIs concurrently in a single libcurl operation.  This merely
uses the tools of <code>basicTextGatherer</code> applied to each of
several URIs. See <code><a href="#topic+getURIAsynchronous">getURIAsynchronous</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basicTextGatherer(txt = character(), max = NA, value = NULL,
                    .mapUnicode = TRUE)
multiTextGatherer(uris, binary = rep(NA, length(uris)))
debugGatherer()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basicTextGatherer_+3A_txt">txt</code></td>
<td>
<p>an initial character vector to start things.
We allow this to be specified so that one can initialize
the content. 
</p>
</td></tr>
<tr><td><code id="basicTextGatherer_+3A_max">max</code></td>
<td>
<p>if specified as an integer this controls  the total number
of characters that will be read.  If more are read, the function
tells libcurl to stop!</p>
</td></tr>
<tr><td><code id="basicTextGatherer_+3A_uris">uris</code></td>
<td>
<p>for <code>multiTextGatherer</code>, this is either the number
or the names of the uris being downloaded and for which we
need a separate writer function.
</p>
</td></tr>
<tr><td><code id="basicTextGatherer_+3A_value">value</code></td>
<td>
<p>if specified, a function that is called when retrieving
the text usually after the completion of the request and the
processing of the response. This function can be used to convert the
result into a different format, e.g. parse an XML document,
read values from table in the text.</p>
</td></tr>
<tr><td><code id="basicTextGatherer_+3A_.mapunicode">.mapUnicode</code></td>
<td>
<p>a logical value that controls whether the resulting
text is processed to map components of the form \uxxxx to their
appropriate Unicode representation.</p>
</td></tr>
<tr><td><code id="basicTextGatherer_+3A_binary">binary</code></td>
<td>
<p>a logical vector that indicates which URIs yield binary content</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is called when the libcurl engine finds sufficient
data on the stream from which it is reading the response.
It cumulates these bytes and hands them to a C routine in
this package which calls the actual gathering function (or a suitable
replacement) returned as the <code>update</code> component from this function.
</p>


<h3>Value</h3>

<p>Both the <code>basicTextGatherer</code> and <code>debugGatherer</code>
functions return an object of class
<code>RCurlCallbackFunction</code>.
<code>basicTextGatherer</code> extends this with the class
<code>RCurlTextHandler</code>
and 
<code>debugGatherer</code> extends this with the class
<code>RCurlDebugHandler</code>.
Each of these has the same basic structure,
being a list of 3 functions.
</p>
<table>
<tr><td><code>update</code></td>
<td>
<p>the function that is called with the text from the
callback routine and which processes this text by accumulating it
into a vector</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>a function that returns the text cumulated across the
callbacks. This takes an argument <code>collapse</code> (and additional ones)
that are handed to <code><a href="base.html#topic+paste">paste</a></code>.
If the value of  <code>collapse</code> is given as <code>NULL</code>,
the vector of elements containing the different text for each
callback is returned. This is convenient when debugging or if one
knows something about the nature of the callbacks, e.g. the regular
size that causes iit to identify records in a natural way.
</p>
</td></tr>
<tr><td><code>reset</code></td>
<td>
<p>a function that resets the internal state to its
original, empty value. This can be used to reuse the same object
across requests but to avoid cumulating new input with the material from previous requests.</p>
</td></tr>
</table>
<p><code>multiTextGatherer</code> returns a list with an element corresponding
to each URI. Each element is an object obtained by calling
<code>basicTextGatherer</code>, i.e. a collection of 3 functions with
shared state.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>Curl homepage <a href="https://curl.se/">https://curl.se/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getURL">getURL</a></code>
<code><a href="#topic+dynCurlReader">dynCurlReader</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(url.exists("https://www.omegahat.net/RCurl/index.html")) withAutoprint({
  txt = getURL("https://www.omegahat.net/RCurl/index.html", write = basicTextGatherer())

  h = basicTextGatherer()
  txt = getURL("https://www.omegahat.net/RCurl/index.html", write = h$update)
    ## Cumulate across pages.
  txt = getURL("https://www.omegahat.net/index.html", write = h$update)


  headers = basicTextGatherer()
  txt = getURL("https://www.omegahat.net/RCurl/index.html",
               header = TRUE, headerfunction = headers$update)

     ## Now read the headers.
  cat(headers$value())
  headers$reset()


    ## Debugging callback
  d = debugGatherer()
  x = getURL("https://www.omegahat.net/RCurl/index.html", debugfunction = d$update, verbose = TRUE)
  cat(names(d$value()))
  d$value()[["headerIn"]]


    ## This hung on Solaris
    ## 2022-02-08 philosophy.html is malformed UTF-8
  uris = c("https://www.omegahat.net/RCurl/index.html",
           "https://www.omegahat.net/RCurl/philosophy.html")
## Not run: 
  g = multiTextGatherer(uris)
  txt = getURIAsynchronous(uris,  write = g)
  names(txt) # no names this way
  nchar(txt)

   # Now don't use names for the gatherer elements.
  g = multiTextGatherer(length(uris))
  txt = getURIAsynchronous(uris,  write = g)
  names(txt)
  nchar(txt)

## End(Not run)
})


## Not run: 
 Sys.setlocale(,"en_US.latin1")
 Sys.setlocale(,"en_US.UTF-8")
 uris = c("https://www.omegahat.net/RCurl/index.html",
          "https://www.omegahat.net/RCurl/philosophy.html")
 g = multiTextGatherer(uris)
 txt = getURIAsynchronous(uris,  write = g)

## End(Not run)
</code></pre>

<hr>
<h2 id='binaryBuffer'>Create internal C-level data structure for collecting binary data</h2><span id='topic+binaryBuffer'></span><span id='topic+coerce+2CRCurlBinaryBuffer+2Craw-method'></span>

<h3>Description</h3>

<p>This is the constructor function for creating an internal data
structure
that is used when reading binary data from an HTTP request
via RCurl.  It is used with the native routine
<code>R_curl_write_binary_data</code> for collecting
the response from the HTTP query into a buffer that stores
the bytes. The contents can then be brought back into R
as a <code>raw</code> vector and then used in different ways,
e.g. uncompressed with the <code>Rcompression</code> package,
or written to a file via <code><a href="base.html#topic+writeBin">writeBin</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binaryBuffer(initialSize = 5000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binaryBuffer_+3A_initialsize">initialSize</code></td>
<td>
<p>a number giving the size (number of bytes) to
allocate for the buffer. In most cases, the size won't make an
enormous difference. If this is small, the
<code>R_curl_write_binary_data</code> routine will expand it as necessary
when more daat is received than would fit in it.  If it is very
large, i.e. larger than the resulting response, the consequence is
simply unused memory.   One can determine the appropriate size by
performing the HTTP request with <code>nobody = TRUE</code> and looking
at the resulting size indicated by the headers of the response,
i.e.
<code>getCurlInfo(handle)</code> and then using that size and repeating
the request and receiving the body. This is a trade-off between
network speed and memor consumption and processing speed when
collecting the .
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>RCurlBinaryBuffer</code> which is to be treated
as an opaque data for the most part. When passing this as the value of
the <code>file</code> option, one will have to pass the ref slot.
</p>
<p>After the contents have been read, one can convert this object to an R
raw vector using <code>as(buf, "raw")</code>.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>Curl homepage <a href="https://curl.se/">https://curl.se/</a></p>


<h3>See Also</h3>

<p><code>R_curl_write_binary_data</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(url.exists("https://www.omegahat.net/RCurl/xmlParse.html.gz")) {
  buf = binaryBuffer()

     # Now fetch the binary file.
  getURI("https://www.omegahat.net/RCurl/xmlParse.html.gz",
         write = getNativeSymbolInfo("R_curl_write_binary_data")$address,
         file = buf@ref)

   # Convert the internal data structure into an R raw vector
  b = as(buf, "raw")

  if (getRversion() &gt;= "4")
    txt = memDecompress(b, asChar = TRUE)
  ## or txt = Rcompression::gunzip(b)
 }
</code></pre>

<hr>
<h2 id='CFILE'>Create a C-level handle for a file</h2><span id='topic+CFILE'></span><span id='topic+CFILE-class'></span><span id='topic+close+2CCFILE-method'></span>

<h3>Description</h3>

<p>This function and class allow us to work with C-level
<code>FILE</code> handles.
The intent is to be able to pass these to <code>libcurl</code>
as options so that it can read or write from or to the file.
We can also do this with R connections and specify callback functions
that manipulate these connections. But using
the C-level FILE handle is likely to be significantly faster for large
files.
</p>
<p>The <code>close</code> method allows us to explicitly flush and close the file
from within R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CFILE(filename, mode = "r")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CFILE_+3A_filename">filename</code></td>
<td>
<p>the name of the file on disk</p>
</td></tr>
<tr><td><code id="CFILE_+3A_mode">mode</code></td>
<td>
<p>a string specifying how to open the file, read or write, text or binary.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a simple interface to the C routine <code>fopen</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>CFILE</code> which is 
has a single slot name <code>ref</code> which is an external pointer
holding the address of the FILE object in C.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>Man page for <code>fopen</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+curlPerform">curlPerform</a></code> and the <code>readdata</code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
filename = system.file("tests", "amazon3.R", package = "RCurl")
f = CFILE(filename)

if(url.exists('http://s3.amazonaws.com/'))
  curlPerform(url = "http://s3.amazonaws.com/RRupload/duncan2",
              upload = TRUE,
              readdata = f@ref,
              infilesize = file.info(filename)[1, "size"])

## End(Not run)
</code></pre>

<hr>
<h2 id='chunkToLineReader'>Utility that collects data from the HTTP reply into lines and
calls user-provided function.
</h2><span id='topic+chunkToLineReader'></span>

<h3>Description</h3>

<p>When one provides an R function to process the body of
the R rep
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chunkToLineReader(f, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chunkToLineReader_+3A_f">f</code></td>
<td>
<p>a function that is to be called each time
the <code>read</code> function is invoked and there are complete
lines in that input.</p>
</td></tr>
<tr><td><code id="chunkToLineReader_+3A_verbose">verbose</code></td>
<td>
<p>a logical value. If <code>TRUE</code>,
information is displayed when there is any text
that does not form a complete line and is held
for processing in the next chunk.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This constructs a closure and then processes each chunk as
they are passed to the read function.
It strips away any text that does not form a complete line
at the end of the chunk and holds this to be added to the next chunk
being processed.
</p>


<h3>Value</h3>

<p>A list with two components
</p>
<table>
<tr><td><code>read</code></td>
<td>
<p>the function that will do the actual reading from the
HTTP response stream and call the function <code>f</code> on each
step (assuming the chunk has a line marker.</p>
</td></tr>
<tr><td><code>comp2</code></td>
<td>
<p>Description of 'comp2'</p>
</td></tr>
</table>
<p>...
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>Curl homepage <a href="https://curl.se/">https://curl.se/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getURI">getURI</a></code> and the <code>write</code> argument.
<code><a href="#topic+getForm">getForm</a></code>, <code><a href="#topic+postForm">postForm</a></code>  
<code><a href="#topic+curlPerform">curlPerform</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read a rectangular table of data into R from the URL
# and add up the values and the number of values read.

summer =
function()
{
  total = 0.0
  numValues = 0

  list(read = function(txt) {
                 con = textConnection(txt)
                 on.exit(close(con))
                 els = scan(con)
                 numValues &lt;&lt;- numValues + length(els)
                 total &lt;&lt;- total + sum(els)

                 ""
              },
       result = function() c(total = total, numValues = numValues))
}

s = summer()

## Not run: 
## broken, 2022-07-29
if(url.exists("https://www.omegahat.net/RCurl/matrix.data"))
   getURL("https://www.omegahat.net/RCurl/matrix.data", write = chunkToLineReader(s$read)$read)

## End(Not run)</code></pre>

<hr>
<h2 id='clone'>Clone/duplicate an object</h2><span id='topic+clone'></span><span id='topic+clone+2CANY-method'></span><span id='topic+clone+2CCURLHandle-method'></span><span id='topic+clone+2Cenvironment-method'></span><span id='topic+clone+2CCFILE-method'></span>

<h3>Description</h3>

<p>This is a generic function and methods for making a copy of an
object such as a curl handle, C-level pointer to a file, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clone(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clone_+3A_x">x</code></td>
<td>
<p>the object to be cloned.</p>
</td></tr>
<tr><td><code id="clone_+3A_...">...</code></td>
<td>
<p>additional parameters for methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Typically, an object of the same class and &ldquo;value&rdquo;
as the input - <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dupCurlHandle">dupCurlHandle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> h = getCurlHandle(verbose = TRUE)
 other = dupCurlHandle(h)
 curlSetOpt(curl = h, verbose = FALSE)
</code></pre>

<hr>
<h2 id='complete'>Complete an asynchronous HTTP request</h2><span id='topic+complete'></span><span id='topic+complete+2CMultiCURLHandle-method'></span>

<h3>Description</h3>

<p>This is a generic function that is used within the
RCurl package to force the completion of an
HTTP request. If the request is asynchronous,
this essentially blocks until the request is completed
by repeatedly asking for more information to be
retrieved from the HTTP connection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete_+3A_obj">obj</code></td>
<td>
<p>the object which is to be completed. This is typically a
<code><a href="#topic+MultiCURLHandle-class">MultiCURLHandle-class</a></code> instance.</p>
</td></tr>
<tr><td><code id="complete_+3A_...">...</code></td>
<td>
<p>additional arguments intended to be used by specific methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value is typically not of interest, but rather the side effect
of processing the pending requests.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p><a href="https://curl.se/">https://curl.se/</a>, specifically the multi interface of libcurl.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MultiCURLHandle-class">MultiCURLHandle-class</a></code>
<code><a href="#topic+push">push</a></code>, <code><a href="#topic+pop">pop</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: # it does not exist
if(url.exists("http://eeyore.ucdavis.edu/cgi-bin/testForm1.pl")) {

  f = system.file("NAMESPACE", package = "RCurl")
   postForm("http://eeyore.ucdavis.edu/cgi-bin/testForm1.pl",
            "fileData" = fileUpload(f))


   postForm("http://eeyore.ucdavis.edu/cgi-bin/testForm1.pl",
            "fileData" = fileUpload("",
                                    paste(readLines(f), collapse = "\n"),
                                    "text/plain"))

   postForm("http://eeyore.ucdavis.edu/cgi-bin/testForm1.pl",
            "fileData" = fileUpload(f,
                                    paste(readLines(f), collapse = "\n")
                                    ),
            .opts = list(verbose = TRUE, header = TRUE))
}
## End(Not run)
</code></pre>

<hr>
<h2 id='CURLEnums'>Classes and coercion methods for enumerations in libcurl</h2><span id='topic++7C+2CBitwiseValue+2CBitwiseValue-method'></span><span id='topic+c+2CBitwiseValue-method'></span><span id='topic++26+2CBitwiseValue-method'></span><span id='topic++26+2CBitwiseValue+2CBitwiseValue-method'></span><span id='topic++5B+2CEnumDef-method'></span><span id='topic++5B+2CEnumDef+2CANY-method'></span><span id='topic+coerce+2CBitwiseValue+2Cnumeric-method'></span><span id='topic+curl_infotype-class'></span><span id='topic+CURLcode-class'></span><span id='topic+curl_proxytype-class'></span><span id='topic+curl_usessl-class'></span><span id='topic+curl_ftpccc-class'></span><span id='topic+curl_ftpauth-class'></span><span id='topic+curl_ftpcreatedir-class'></span><span id='topic+curl_ftpmethod-class'></span><span id='topic+CURL_NETRC_OPTION-class'></span><span id='topic+CURLFORMcode-class'></span><span id='topic+curl_TimeCond-class'></span><span id='topic+curl_closepolicy-class'></span><span id='topic+coerce+2Cinteger+2Ccurl_infotype-method'></span><span id='topic+coerce+2Cinteger+2CCURLcode-method'></span><span id='topic+coerce+2Cinteger+2Ccurl_proxytype-method'></span><span id='topic+coerce+2Cinteger+2Ccurl_usessl-method'></span><span id='topic+coerce+2Cinteger+2Ccurl_ftpccc-method'></span><span id='topic+coerce+2Cinteger+2Ccurl_ftpauth-method'></span><span id='topic+coerce+2Cinteger+2Ccurl_ftpcreatedir-method'></span><span id='topic+coerce+2Cinteger+2Ccurl_ftpmethod-method'></span><span id='topic+coerce+2Cinteger+2CCURL_NETRC_OPTION-method'></span><span id='topic+coerce+2Cinteger+2CCURLFORMcode-method'></span><span id='topic+coerce+2Cinteger+2Ccurl_TimeCond-method'></span><span id='topic+coerce+2Cinteger+2Ccurl_closepolicy-method'></span><span id='topic+coerce+2Cnumeric+2Ccurl_infotype-method'></span><span id='topic+coerce+2Cnumeric+2CCURLcode-method'></span><span id='topic+coerce+2Cnumeric+2Ccurl_proxytype-method'></span><span id='topic+coerce+2Cnumeric+2Ccurl_usessl-method'></span><span id='topic+coerce+2Cnumeric+2Ccurl_ftpccc-method'></span><span id='topic+coerce+2Cnumeric+2Ccurl_ftpauth-method'></span><span id='topic+coerce+2Cnumeric+2Ccurl_ftpcreatedir-method'></span><span id='topic+coerce+2Cnumeric+2Ccurl_ftpmethod-method'></span><span id='topic+coerce+2Cnumeric+2CCURL_NETRC_OPTION-method'></span><span id='topic+coerce+2Cnumeric+2CCURLFORMcode-method'></span><span id='topic+coerce+2Cnumeric+2Ccurl_TimeCond-method'></span><span id='topic+coerce+2Cnumeric+2Ccurl_closepolicy-method'></span><span id='topic+coerce+2Ccharacter+2Ccurl_infotype-method'></span><span id='topic+coerce+2Ccharacter+2CCURLcode-method'></span><span id='topic+coerce+2Ccharacter+2Ccurl_proxytype-method'></span><span id='topic+coerce+2Ccharacter+2Ccurl_usessl-method'></span><span id='topic+coerce+2Ccharacter+2Ccurl_ftpccc-method'></span><span id='topic+coerce+2Ccharacter+2Ccurl_ftpauth-method'></span><span id='topic+coerce+2Ccharacter+2Ccurl_ftpcreatedir-method'></span><span id='topic+coerce+2Ccharacter+2Ccurl_ftpmethod-method'></span><span id='topic+coerce+2Ccharacter+2CCURL_NETRC_OPTION-method'></span><span id='topic+coerce+2Ccharacter+2CCURLFORMcode-method'></span><span id='topic+coerce+2Ccharacter+2Ccurl_TimeCond-method'></span><span id='topic+coerce+2Ccharacter+2Ccurl_closepolicy-method'></span>

<h3>Description</h3>

<p>These are classes and coercion methods
for enumeration types in RCurl corresponding to symbolic
constants in libcurl.
The actual constants are not exported, but are defined within
the package. So we can use them with code such as 
<code>RCurl:::CURLINFO_DATA_IN</code>.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>

<hr>
<h2 id='curlError'>Raise a warning or error about a CURL problem</h2><span id='topic+curlError'></span>

<h3>Description</h3>

<p>This function is called to raise an error or warning
that arises from a curl operation when making a request.
This is called from C code that encounters the error
and this function is responsible for generating the error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curlError(type, msg, asError = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curlError_+3A_type">type</code></td>
<td>
<p>the type of the error or a status code identifying the
type of the error. Typically this is an integer value that
identifies the type of the Curl error. The value corresponds
to one of the enumerated value of type <code>CURLcode</code>.</p>
</td></tr>
<tr><td><code id="curlError_+3A_msg">msg</code></td>
<td>
<p>the error message, as a character vector of length 1</p>
</td></tr>
<tr><td><code id="curlError_+3A_aserror">asError</code></td>
<td>
<p>a logical value that indicates whether to raise an
error or a warning</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This calls <code>warning</code> or <code>stop</code> with the relevant condition
object.
The object is always of basic  (S3) class
<code>GenericCurlError, error, condition</code>
or
<code>GenericCurlError, warning, condition</code>.
When the <code>type</code> value corresponds to a
<code>CURLCode</code> value, the condition has the primary class given by that
<code>CURLCode</code>'s name, e.g. <code>COULDNT_RESOLVE_HOST</code>,
<code>TOO_MANY_REDIRECTS</code> (with the CURLE prefix removed).
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>References</h3>

<p>libcurl documentation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+curlPerform">curlPerform</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # This illustrates generating and catching an error.
  # We intentionally give a mis-spelled URL.
 tryCatch(curlPerform(url = "ftp.wcc.nrcs.usda.govx"),
          COULDNT_RESOLVE_HOST = function(x) cat("resolve problem\n"),
          error = function(x) cat(class(x), "got it\n"))
</code></pre>

<hr>
<h2 id='curlEscape'>Handle characters in URL that need to be escaped</h2><span id='topic+curlEscape'></span><span id='topic+curlUnescape'></span><span id='topic+curlPercentEncode'></span>

<h3>Description</h3>

<p>These functions convert between URLs that are
human-readable and those that have special characters
escaped.  For example, to send a URL with a space,
we need to represent the space as <code>%20</code>.
</p>
<p><code>curlPercentEncode</code> uses a different format than the
<code>curlEscape</code>
function and this is needed for x-www-form-encoded POST submissions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curlEscape(urls)
curlUnescape(urls)
curlPercentEncode(x, amp = TRUE, codes = PercentCodes, post.amp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curlEscape_+3A_urls">urls</code></td>
<td>
<p> a character vector giving the strings to be escaped or
unescaped.</p>
</td></tr>
<tr><td><code id="curlEscape_+3A_x">x</code></td>
<td>
<p>the strings to be encoded via the percent-encoding method</p>
</td></tr>
<tr><td><code id="curlEscape_+3A_amp">amp</code></td>
<td>
<p>a  logical value indicating whether to encode &amp;
characters.</p>
</td></tr>
<tr><td><code id="curlEscape_+3A_codes">codes</code></td>
<td>
<p>the named character vector giving the encoding map. The
names are the characters we encode, the values are what we encode them
as.</p>
</td></tr>
<tr><td><code id="curlEscape_+3A_post.amp">post.amp</code></td>
<td>
<p>a logical value controlling whether the resulting
string is further processed to escape the percent (%) prefixes with
the code for percent, i.e. %25.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This calls <code>curl_escape</code> or <code>curl_unescape</code> in the libcurl library.
</p>


<h3>Value</h3>

<p>A character vector that has corresponding elements
to the input with the characters escaped or not.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>Curl homepage <a href="https://curl.se/">https://curl.se/</a>
</p>
<p>Percent encoding explained in <a href="https://en.wikipedia.org/wiki/Percent-encoding">https://en.wikipedia.org/wiki/Percent-encoding</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  curlEscape("http://www.abc.com?x=a is a sentence&amp;a b=and another")

  # Reverse it should get back original
  curlUnescape(curlEscape("http://www.abc.com?x=a is a sentence&amp;a b=and another"))
</code></pre>

<hr>
<h2 id='CurlFeatureBits'>Constants for libcurl</h2><span id='topic+CurlFeatureBits'></span><span id='topic+CurlNetrc'></span><span id='topic+CurlGlobalBits'></span>

<h3>Description</h3>

<p>These are enums and bit fields defining
constants used in libcurl and used in
R to specify values symbolically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CurlFeatureBits</code></pre>


<h3>Format</h3>

<p>named integer vectors.
The names give the symbolic constants that can be used
in R and C code. These are mapped to their integer equivalents
and used in C-level computations.
</p>


<h3>Source</h3>

<p>libcurl (see <a href="https://curl.se/">https://curl.se/</a>)
</p>

<hr>
<h2 id='curlGlobalInit'>Start and stop the Curl library</h2><span id='topic+curlGlobalInit'></span><span id='topic+curlGlobalCleanup'></span>

<h3>Description</h3>

<p>These functions provide a way to both start/initialize
and stop/uninitialize the libcurl engine.
There is no need to call
<code>curlGlobalInit</code> as it is done implicitly the
first time one uses the libcurl facilities.
However, this function does permit one to explicitly
control how it is initialized.
Specifically, on Windows one might want to
avoid re-initializing the Win32 socket facilities
if the  host application (e.g. R) has already done this.
</p>
<p><code>curlGlobalInit</code> should only be called once per R session.
Subsequent calls will have no effect, or may confuse the libcurl engine.
</p>
<p>One can reclaim the resources the libcurl engine is
consuming via the <code>curlGlobalCleanup</code> function
when one no longer needs the libcurl facilities in
an R session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curlGlobalInit(flags = c("ssl", "win32"))
curlGlobalCleanup()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curlGlobalInit_+3A_flags">flags</code></td>
<td>
<p>flags indicating which features to activate.
These come from the <code><a href="#topic+CurlGlobalBits">CurlGlobalBits</a></code>
bit-field.  The default is to activate both SSL and Win32 sockets
(if on Windows).  One can specify either the names of the features
that are matched (via <code><a href="#topic+setBitIndicators">setBitIndicators</a></code>) or
the integer value.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>curlGobalInit</code> returns a status code which should be 0.
<code>curlGlobalCleanup</code> returns <code>NULL</code> in  all cases.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>Curl homepage <a href="https://curl.se/">https://curl.se/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getCurlHandle">getCurlHandle</a></code>  
<code><a href="#topic+curlPerform">curlPerform</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # Activate only the SSL.
 curlGlobalInit("ssl")

## Not run: 
# Don't run these automatically as we should only call this function
# once per R session

    # Everything, the default.
 curlGlobalInit()

   # Nothing.
 curlGlobalInit("none")
 curlGlobalInit(0)

## End(Not run)

</code></pre>

<hr>
<h2 id='CURLHandle-class'>Class &quot;CURLHandle&quot; for synchronous HTTP requests</h2><span id='topic+CURLHandle-class'></span>

<h3>Description</h3>

<p>This is the basic class used for  performing HTTP requests
in the RCurl package.
In R, this is a reference to a C-level data structure
so we treat it as an opaque data type. However,
essentially we can think of this as an with
a set of options that persists across calls, i.e. HTTP requests.
The numerous options that one can set can be see via
<code><a href="#topic+getCurlOptionsConstants">getCurlOptionsConstants</a></code>.
The object can keep a connection to a Web server open for a period of time
across calls.
</p>
<p>This class differs from <code><a href="#topic+MultiCURLHandle-class">MultiCURLHandle-class</a></code> as it
can handle only one request at a time and blocks until the request
is completed (normally or abnormally).
The other class can handle asynchronous, multiple connections.
</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Extends</h3>

<p>Class <code>"oldClass"</code>, directly.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p><a href="https://curl.se/">https://curl.se/</a>, the libcurl web site.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getURL">getURL</a></code>,   <code><a href="#topic+getForm">getForm</a></code>,   <code><a href="#topic+postForm">postForm</a></code>
<code><a href="#topic+dupCurlHandle">dupCurlHandle</a></code>,
<code><a href="#topic+getCurlHandle">getCurlHandle</a></code>,
<code><a href="#topic+MultiCURLHandle-class">MultiCURLHandle-class</a></code>
</p>

<hr>
<h2 id='curlOptions'>Constructor and accessors for CURLOptions objects</h2><span id='topic+curlOptions'></span><span id='topic+getCurlOptionsConstants'></span><span id='topic+getCurlOptionTypes'></span><span id='topic+listCurlOptions'></span><span id='topic+mapCurlOptNames'></span><span id='topic++5B+3C-.CURLOptions'></span><span id='topic++5B+5B+3C-.CURLOptions'></span>

<h3>Description</h3>

<p>These functions provide a constructor
and accessor methods 
for the (currently S3) class <code>CURLOptions</code>.
This class is a way to group and manage options settings
for CURL.
These functions manage a named list of options
where the names are elements of a fixed.
Not all elements need be set, but
these functions take care of expanding names
to match the fixed set, while allowing callers
to use abbreviated/partial names.
Names that do not match (via <code><a href="base.html#topic+pmatch">pmatch</a></code>)
will cause an error.
</p>
<p>The set of possible names is given by
<code>names(getCurlOptionsConstants())</code>
or more directly with <code>listCurlOptions()</code>.
</p>
<p><code>mapCurlOptNames</code> handles the partial matching and
expansion of the names of the options for all the functions
that handle CURL options.
Currently this uses <code><a href="base.html#topic+pmatch">pmatch</a></code> to
perform the matching and so rejects words
that are ambiguous, i.e. have multiple matches
within the set of permissible option names.
As a result, &quot;head&quot; will match both
&quot;header&quot; and &quot;headerfunction&quot;.
We may change this behavior in the future, but
we encourage using the full names for readability of code if nothing
else.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curlOptions(..., .opts = list())
getCurlOptionsConstants()
## S3 replacement method for class 'CURLOptions'
x[i] &lt;- value
## S3 replacement method for class 'CURLOptions'
x[[i]] &lt;- value
listCurlOptions()
getCurlOptionTypes(opts = getCurlOptionsConstants())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curlOptions_+3A_...">...</code></td>
<td>
<p>name-value pairs identifying the settings for the options
of interest.</p>
</td></tr>
<tr><td><code id="curlOptions_+3A_.opts">.opts</code></td>
<td>
<p>a named list of options, typically a previously created
<code>CURLOptions</code> object. These are merged with the options
specified in <code>...</code>.</p>
</td></tr>
<tr><td><code id="curlOptions_+3A_x">x</code></td>
<td>
<p>a <code>CURLOptions</code> object</p>
</td></tr>
<tr><td><code id="curlOptions_+3A_i">i</code></td>
<td>
<p>the name(s) of the option elements being accessed.
These can be partial names matching elements in the set
of known options. Other names will cause an error.</p>
</td></tr>
<tr><td><code id="curlOptions_+3A_value">value</code></td>
<td>
<p>the values to assign to the options identified via <code>i</code>.</p>
</td></tr>
<tr><td><code id="curlOptions_+3A_opts">opts</code></td>
<td>
<p>the options whose type description are of interest in the call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions use <code>mapCurlOptNames</code>
to match and hence expand the names the callers
provide.
</p>


<h3>Value</h3>

<p><code>curlOptions</code> returns an object
of class <code>CURLOptions</code> which is simply
a named list.
</p>
<p><code>getCurlConstants</code> returns a named vector identifying
the names of the possible options and their associated
values. These values are used in the C code and also each integer
encodes the type of the argument expected by the C code
for that option.
</p>
<p><code>getCurlOptionTypes</code> returns human-readable,
heuristic descriptions of the types expected for the different options.
These are integer/logical  corresponding to &quot;long&quot; in the RCurl documentation;
string/object pointer corresponding to &quot;char *&quot; or ;
function corresponding to a function/routine pointer;
large number corresponding to a <code>curl_off_t</code>.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>Curl homepage <a href="https://curl.se/">https://curl.se/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+curlPerform">curlPerform</a></code>
<code><a href="#topic+curlSetOpt">curlSetOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 tt = basicTextGatherer()
 myOpts = curlOptions(verbose = TRUE, header = TRUE, writefunc = tt[[1]])

  # note that the names are expanded, e.g. writefunc is now writefunction.
 names(myOpts)

 myOpts[["header"]]

 myOpts[["header"]] &lt;- FALSE

# Using the abbreviation "hea" is an error as it matches
# both 
#  myOpts[["hea"]] &lt;- FALSE

 # Remove the option from the list
 myOpts[["header"]] &lt;- NULL
</code></pre>

<hr>
<h2 id='curlPerform'>Perform the HTTP query</h2><span id='topic+curlPerform'></span><span id='topic+curlMultiPerform'></span>

<h3>Description</h3>

<p>These function causes the HTTP query, that has been specified
via the different options in this and other calls, to be sent and processed.
Unlike in curl itself,
for <code>curlPerform</code> one can specify all the options
in this call as an atomic invocation.
This avoids having to set the options and then perform
the action. Instead, this is all done in one call.
</p>
<p>For <code>curlMultiPerform</code>, one must add the relevant
<code><a href="#topic+CURLHandle-class">CURLHandle-class</a></code> objects to the
<code><a href="#topic+MultiCURLHandle-class">MultiCURLHandle-class</a></code> objects
before issuing the call to <code>curlMultiPerform</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curlPerform(..., .opts = list(), curl = getCurlHandle(), .encoding = integer())
curlMultiPerform(curl, multiple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curlPerform_+3A_curl">curl</code></td>
<td>
<p>for <code>curlPerform</code>, this is the <code>CURLHandle</code>
object giving the structure for the
options  and that will process the command.
For <code>curlMultiPerform</code>, this is an object of class
code <code><a href="#topic+MultiCURLHandle-class">MultiCURLHandle-class</a></code>.</p>
</td></tr>
<tr><td><code id="curlPerform_+3A_...">...</code></td>
<td>
<p>a named list of curl options to set after the handle has
been created.</p>
</td></tr>
<tr><td><code id="curlPerform_+3A_.opts">.opts</code></td>
<td>
<p>a named list or <code>CURLOptions</code> object identifying the
curl options for the handle. This is merged with the values of ...
to create the actual options for the curl handle in the request.</p>
</td></tr>
<tr><td><code id="curlPerform_+3A_multiple">multiple</code></td>
<td>
<p>a logical value. If <code>TRUE</code> and the internal call
to <code>curl_multi_perform</code> returns a value that indicates there is
still data available from one of the HTTP responses, we call
<code>curl_multi_perform</code> repeatedly until there is no more data
available  at that time. If this is <code>FALSE</code>, we call
<code>curl_multi_perform</code> once and return, regardless of whether
there is more data available. This is convenient if we want to limit
the time spent in the call to <code>curlMultiPerform</code>.
</p>
</td></tr>
<tr><td><code id="curlPerform_+3A_.encoding">.encoding</code></td>
<td>
<p>an integer or a string that explicitly identifies the
encoding of the content that is returned by the HTTP server in its
response to our query. The possible strings are
&lsquo;UTF-8&rsquo; or &lsquo;ISO-8859-1&rsquo;
and the integers should be specified symbolically
as  <code>CE_UTF8</code> and <code>CE_LATIN1</code>.
Note that, by default, the package attempts to process the header of
the HTTP response to determine the encoding. This argument is used
when such information is erroneous and the caller knows the correct
encoding.
</p>
<p>Note that the encoding argument is not a regular libcurl option and
is handled specially by RCurl. But as a result, it is not unset
in subsequent uses of the curl handle (<code>curl</code>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A integer value indicating the status of the request.
This should be 0 as other errors will generate
errors.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>Curl homepage <a href="https://curl.se/">https://curl.se/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getURL">getURL</a></code>
<code><a href="#topic+postForm">postForm</a></code>
<code><a href="#topic+getForm">getForm</a></code>
<code><a href="#topic+curlSetOpt">curlSetOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(url.exists("https://www.omegahat.net/RCurl")) withAutoprint({
  h = basicTextGatherer()
  curlPerform(url = "https://www.omegahat.net/RCurl", writefunction = h$update)
   # Now read the text that was cumulated during the query response.
  cat(h$value())
})


## this no longer exists
if(url.exists("http://services.soaplite.com/hibye.cgi")) withAutoprint({
     # SOAP request
  body = '&lt;?xml version="1.0" encoding="UTF-8"?&gt;\
&lt;SOAP-ENV:Envelope SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" \
                   xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" \
                   xmlns:xsd="http://www.w3.org/1999/XMLSchema" \
                   xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" \
                   xmlns:xsi="http://www.w3.org/1999/XMLSchema-instance"&gt;\
  &lt;SOAP-ENV:Body&gt;\
       &lt;namesp1:hi xmlns:namesp1="http://www.soaplite.com/Demo"/&gt;\
  &lt;/SOAP-ENV:Body&gt;\
&lt;/SOAP-ENV:Envelope&gt;\n'


  h$reset()
  curlPerform(url = "http://services.soaplite.com/hibye.cgi",
              httpheader=c(Accept="text/xml", Accept="multipart/*",
                           SOAPAction='"http://www.soaplite.com/Demo#hi"',
                           'Content-Type' = "text/xml; charset=utf-8"),
              postfields=body,
              writefunction = h$update,
              verbose = TRUE
             )

  body = h$value()

})


   # Using a C routine as the reader of the body of the response.
if(url.exists("https://www.omegahat.net/RCurl/index.html")) withAutoprint({
  routine = getNativeSymbolInfo("R_internalWriteTest", PACKAGE = "RCurl")$address
  curlPerform(URL = "https://www.omegahat.net/RCurl/index.html",
              writefunction = routine)
})
</code></pre>

<hr>
<h2 id='curlSetOpt'>Set values for the CURL options</h2><span id='topic+curlSetOpt'></span>

<h3>Description</h3>

<p>This function allows us to set values for the
possible options in the CURL data structure
that defines the HTTP request.
These options persist across calls in the
<code>CURLHandle</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curlSetOpt(..., .opts = list(), curl = getCurlHandle(),
            .encoding = integer(), .forceHeaderNames = FALSE,
             .isProtected = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curlSetOpt_+3A_...">...</code></td>
<td>
<p>a named list of curl options to set after the handle has
been created.</p>
</td></tr>
<tr><td><code id="curlSetOpt_+3A_.opts">.opts</code></td>
<td>
<p>a named list or <code>CURLOptions</code> object identifying the
curl options for the handle.</p>
</td></tr>  
<tr><td><code id="curlSetOpt_+3A_curl">curl</code></td>
<td>
<p>the <code>CURLHandle</code> object created earlier via
a call to <code><a href="#topic+getCurlHandle">getCurlHandle</a></code> or
<code><a href="#topic+dupCurlHandle">dupCurlHandle</a></code></p>
</td></tr>
<tr><td><code id="curlSetOpt_+3A_.encoding">.encoding</code></td>
<td>
<p>an integer or a string that explicitly identifies the
encoding of the content that is returned by the HTTP server in its
response to our query. The possible strings are
&lsquo;UTF-8&rsquo; or &lsquo;ISO-8859-1&rsquo;
and the integers should be specified symbolically
as  <code>CE_UTF8</code> and <code>CE_LATIN1</code>.
Note that, by default, the package attempts to process the header of
the HTTP response to determine the encoding. This argument is used
when such information is erroneous and the caller knows the correct
encoding.
</p>
</td></tr>
<tr><td><code id="curlSetOpt_+3A_.forceheadernames">.forceHeaderNames</code></td>
<td>
<p>a logical value which if <code>TRUE</code>
allows the caller to explicitly indicate that the HTTPHEADER
option needs to have the names prefixed to the strings.
This removes any ambiguity caused by the presence of ':' in the
values  appearing to be the separator between the name and the value
of the <code>name: value</code> pairs of the HTTP header.</p>
</td></tr>
<tr><td><code id="curlSetOpt_+3A_.isprotected">.isProtected</code></td>
<td>

<p>a logical vector (or value that is repeated) specifying which 
of the values in ... and <code>.opts</code> need to be explicitly
protected from garbage collection or not.
The basic idea is that we specify <code>FALSE</code> if
the value being set for the curl option may be garbage collected
before the <code>curl</code> handle is garbage collected.  This would leave 
the <code>curl</code> object in an inconsistent state, referring to an R
object (i.e. an R function), which may be used after the R object has been garbage collected. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer value giving the status of the return.
This should be 0 as if there was an error in the libcurl
mechiansim,   we will throw it there.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>Curl homepage <a href="https://curl.se/">https://curl.se/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getCurlHandle">getCurlHandle</a></code>
<code><a href="#topic+dupCurlHandle">dupCurlHandle</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(url.exists("https://www.omegahat.net")) {

  curl = getCurlHandle()
     # Note the header that extends across two lines with the second line
     # prefixed with white space.
   curlSetOpt( .opts = list(httpheader = c(Date = "Wed, 1/2/2000 10:01:01",
                            foo="abc\n    extra line"), verbose = TRUE),
               curl = curl)
   ans = getURL("https://www.omegahat.net", curl = curl)
}
</code></pre>

<hr>
<h2 id='curlVersion'>Information describing the Curl library</h2><span id='topic+curlVersion'></span>

<h3>Description</h3>

<p>This function queries the Curl library to provide information
about its characteristics when it was compiled.
This tells the user about its capabilities and can be used
to determine strategies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curlVersion(id = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curlVersion_+3A_id">id</code></td>
<td>
<p>an integer value between 0 and 3 inclusive.
The idea is that one specifies the identifier for the version of
interest.
In fact, all values seem to yield the same result.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list
</p>
<table>
<tr><td><code>age</code></td>
<td>
<p>integer giving the number of this libcurl, 0 is FIRST, 1 is
SECOND, 2 is THIRD</p>
</td></tr>
<tr><td><code>version</code></td>
<td>
<p>the version identifier as a string, e.g. <code>"7.12.0"</code></p>
</td></tr>
<tr><td><code>version_num</code></td>
<td>
<p>the value as an integer</p>
</td></tr>
<tr><td><code>host</code></td>
<td>
<p>the machine on which the libcurl was configured/built.</p>
</td></tr>
<tr><td><code>features</code></td>
<td>
<p>a named integer vector of bits indicating what
features of libcurl were configured and built into this version.
These are features such as
ipv6, ssl, libz, largefile, ntlm (Microsoft &quot;authorization&quot;).</p>
</td></tr>
<tr><td><code>ssl_version</code></td>
<td>
<p>the string identifying the SSL version.</p>
</td></tr>
<tr><td><code>ssl_version_num</code></td>
<td>
<p>the number identifying the SSL version</p>
</td></tr>
<tr><td><code>libz_version</code></td>
<td>
<p>the string identifying the version of libz.</p>
</td></tr>
<tr><td><code>protocols</code></td>
<td>
<p>a character vector of the supported HTTP protocols,
e.g. http, https, ftp, ldap, gopher, telnet</p>
</td></tr>
<tr><td><code>ares</code></td>
<td>
<p>name of the asynchronous DNS (domain name service) lookup
library. This is often simply the empty string indicating it is not there.
</p>
</td></tr>
<tr><td><code>ares_num</code></td>
<td>
<p>the number for the ares library</p>
</td></tr>
<tr><td><code>libidn</code></td>
<td>
<p>the name of the IDN (internationalized domain names)
library being used. This field only appears in version 3 of libcurl.
If you are using version 2 (e.g. curl-7.11.2), this will be
<code>NA</code>.
An empty string indicates that the field is present, but has no value.
</p>
</td></tr>
</table>
<p>See the man page for <code>curl_version_info</code>
for a description of these fields.
<code>features</code> in R is a named integer vector
detailing the different features.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>Curl homepage <a href="https://curl.se/">https://curl.se/</a></p>


<h3>See Also</h3>

<p><code>curl_version_info</code> in the libcurl documentation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  curlVersion()
</code></pre>

<hr>
<h2 id='dynCurlReader'>Dynamically determine content-type of body from HTTP header and
set body reader</h2><span id='topic+dynCurlReader'></span>

<h3>Description</h3>

<p>This function is used for the <code>writefunction</code>
option in a curl HTTP request.
The idea is that we read the header of the HTTP response
and when our code determines that the header is complete
(the presence of a blank line), it examines the contents
of the header and finds a Content-Type field.
It uses the value of this to determine the nature of the
body of the HTTP response and dynamically (re)sets the reader
for the curl handle appropriately. If the content is binary,
it collects the content into a <code>raw</code> vector;
if it is text, it sets the appropriate character encoding
and collects the content into a character vector.
</p>
<p>This function is like <code><a href="#topic+basicTextGatherer">basicTextGatherer</a></code>
but behaves dynamically by determining how to read the content
based on the header of the HTTP response.
This function returns a list of functions that are used
to update and query a shared state across calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynCurlReader(curl = getCurlHandle(), txt = character(), max = NA,
              value = NULL, verbose = FALSE, binary = NA, baseURL = NA,
              isHTTP = NA, encoding = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dynCurlReader_+3A_curl">curl</code></td>
<td>
<p>the curl handle to be used for the request. It is
essential that this handle be used in the low-level call to
<code><a href="#topic+curlPerform">curlPerform</a></code> so that the update
element sets the reader for the body on the appropriate
curl handle that is used in the request.
</p>
</td></tr>
<tr><td><code id="dynCurlReader_+3A_txt">txt</code></td>
<td>
<p>initial value of the text. This is almost always an empty
character vector.</p>
</td></tr>
<tr><td><code id="dynCurlReader_+3A_max">max</code></td>
<td>
<p>the maximum number of characters to read. This is almost
always <code>NA</code>.</p>
</td></tr>
<tr><td><code id="dynCurlReader_+3A_value">value</code></td>
<td>
<p>a function that can be specified which will be used to
convert the body of the response from text or raw in a customized
manner,
e.g. uncompress a gzip body. This can als be done explicitly
with a call <code>fun(reader$value())</code> after the body has been read.
The advantage of specifying the function in the constructor of the
reader  is that the end-user doesn't have to know which function to
use to do the conversion.
</p>
</td></tr>
<tr><td><code id="dynCurlReader_+3A_verbose">verbose</code></td>
<td>
<p>a logical value indicating whether messages about
progress and operations are written on the console as the
header and body are processed.
</p>
</td></tr>
<tr><td><code id="dynCurlReader_+3A_binary">binary</code></td>
<td>
<p>a logical value indicating whether the caller  knows
whether the resulting content is binary (<code>TRUE</code>) or not
(<code>FALSE</code>) or unknown (<code>NA</code>).
</p>
</td></tr>
<tr><td><code id="dynCurlReader_+3A_baseurl">baseURL</code></td>
<td>
<p>the URL of the request which can be used to follow
links to other URLs that are described relative to this.
</p>
</td></tr>
<tr><td><code id="dynCurlReader_+3A_ishttp">isHTTP</code></td>
<td>
<p>a logical value indicating whether the request/download uses
HTTP or not. If this is <code>NA</code>, we determine this when the header
is received.  If the caller knows this is an FTP or other request,
they can specify this when creating the reader.</p>
</td></tr>
<tr><td><code id="dynCurlReader_+3A_encoding">encoding</code></td>
<td>
<p>a string that allows the caller to specify and override
the encoding of the result. This is used to convert text returned
from the server.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 5 elements all of which are functions. These are
</p>
<table>
<tr><td><code>update</code></td>
<td>
<p>the function that does the actual reading/processing of
the content that libcurl passes to it from the header and the
body. This is the work-horse of the reader.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>a function to get the body of the response</p>
</td></tr>
<tr><td><code>header</code></td>
<td>
<p>a function to get the content of the HTPP header</p>
</td></tr>  
<tr><td><code>reset</code></td>
<td>
<p>a function to reset the internal contents which allows
the same reader to be re-used in subsequent HTTP requests</p>
</td></tr>
<tr><td><code>curl</code></td>
<td>
<p>accessor function for the curl handle specified in the
call to create this dynamic reader object.</p>
</td></tr>
</table>
<p>This list has the S3 class vector
<code>c("DynamicRCurlTextHandler", "RCurlTextHandler", "RCurlCallbackFunction")</code>
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>libcurl <a href="https://curl.se/">https://curl.se/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+basicTextGatherer">basicTextGatherer</a></code>
<code><a href="#topic+curlPerform">curlPerform</a></code>
<code><a href="#topic+getURLContent">getURLContent</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   # Each of these examples can be done with getURLContent().
   # These are here just to illustrate the dynamic reader.
if(url.exists("https://www.omegahat.net/Rcartogram/demo.jpg")) withAutoprint({
  header = dynCurlReader()
  curlPerform(url = "https://www.omegahat.net/Rcartogram/demo.jpg",
              headerfunction = header$update, curl = header$curl())
  class( header$value() )
  length( header$value() )
})

if(url.exists("https://www.omegahat.net/dd.gz")) withAutoprint({
     # gzip example.
  header = dynCurlReader()
  curlPerform(url = "https://www.omegahat.net/dd.gz",
              headerfunction = header$update, curl = header$curl())
  class( header$value() )
  length( header$value() )

  if (getRversion() &gt;= "4")
     cat(memDecompress(header$value(), asChar = TRUE))
   ## or   cat(Rcompression::gunzip(header$value()))
})


   # Character encoding example
## Not run: 
  header = dynCurlReader()
  curlPerform(url = "http://www.razorvine.net/test/utf8form/formaccepter.sn",
               postfields = c(text = "ABC", outputencoding =  "UTF-8"),
               verbose = TRUE,
               writefunction = header$update, curl = header$curl())
  class( header$value() )
  Encoding( header$value() )

## End(Not run)
</code></pre>

<hr>
<h2 id='fileUpload'>Specify information about a file to upload in an HTTP request</h2><span id='topic+fileUpload'></span>

<h3>Description</h3>

<p>This function creates an object that describes all of the details
needed to include the contents of a file in the submission of an
HTTP request, typically a multi-part form submitted via
<code><a href="#topic+postForm">postForm</a></code>.
The idea is that we want to transfer the contents of a file or a
buffer of data within R that is not actually stored on the file
system but is resident in the R session.  We want to be able to
specify either the name of the file and have RCurl read the contents
when they are needed, or alternatively specify the contents ourselves
if it makes sense that we already have the contents in R, e.g. that
they are dynamically generated. Additionally, we may need to specify
the type of data in the file/buffer via the Content-Type field for
this parameter in the request.
This function allows us to specify either the file name or contents
and optionally the content type.
</p>
<p>This is used as an element in of the <code>params</code> argument
<code><a href="#topic+postForm">postForm</a></code> and the native C code understands and processes
objects returned from this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fileUpload(filename = character(), contents = character(), contentType = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fileUpload_+3A_filename">filename</code></td>
<td>
<p>the name of the file that RCurl is to pass in the form
submission/HTTP request. If this is specified and no value for
<code>contents</code> is given, this has to identify a valid/existing
file.  If <code>contents</code> is specified, any value provided here
is used simply to provide information about the provenance of the
data in contents. The file need not exist.
The path is expanded by the function, so <code>~</code> can be used.
</p>
</td></tr>
<tr><td><code id="fileUpload_+3A_contents">contents</code></td>
<td>
<p> either a character vector or a <code>raw</code> vector
giving the contents or data to be submitted. If this is provided,
<code>filename</code> is not needed and not read.
</p>
</td></tr>
<tr><td><code id="fileUpload_+3A_contenttype">contentType</code></td>
<td>
<p>a character string (vector of length 1) giving the
type of the content, e.g. text/plain, text/html, which helps the
server receiving the data to interpret the contents.  If omitted,
this is omitted from the form submission and the recipient left to guess.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of (S3) class <code>FileUploadInfo</code> with fields
<code>filename</code>, <code>contents</code> and <code>contentType</code>.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p><a href="https://curl.se/">https://curl.se/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+postForm">postForm</a></code>
</p>

<hr>
<h2 id='findHTTPHeaderEncoding'>Find the encoding of the HTTP response from the HTTP header</h2><span id='topic+findHTTPHeaderEncoding'></span>

<h3>Description</h3>

<p>This function is currently made available so it can be called
from C code to find the charset from the HTTP header in the
response from an HTTP server. It maps this charset value
to one of the known R encodings (UTF-8 or LATIN1)
or returns the native encoding.
</p>
<p>This will most likely be removed in the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findHTTPHeaderEncoding(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findHTTPHeaderEncoding_+3A_str">str</code></td>
<td>
<p>one or more lines from the HTTP header</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NA</code> or an integer value indicating the encoding
to be used. This integer corresponds to the <code>cetype_t</code>  enumeration
in Rinternals.h.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>Writing R Extensions Manual and the section(s) on character encodings</p>


<h3>Examples</h3>

<pre><code class='language-R'>findHTTPHeaderEncoding("Content-Type: text/html;charset=ISO-8859-1\r\n")
findHTTPHeaderEncoding("Content-Type: text/html; charset=utf-8\r\n")
</code></pre>

<hr>
<h2 id='ftpUpload'>Upload content via FTP</h2><span id='topic+ftpUpload'></span>

<h3>Description</h3>

<p>This function is a relatively simple wrapper for <code><a href="#topic+curlPerform">curlPerform</a></code>
which allows the caller to upload a file to an FTP server.
One can upload the contents of a file from the local file system or 
the contents already in memory. 
One specifies the FTP server and the fully-qualified file name and path where the contents are 
to be stored.
One can specify the user login and password via the <code>userpwd</code> option
for  <code><a href="#topic+curlPerform">curlPerform</a></code> via the ... parameter, or
one can put this information directly in the target URL (i.e. <code>to</code>)
in the form <code>ftp://login:password@machine.name/path/to/file</code>.
</p>
<p>This function can handle binary or text content.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ftpUpload(what, to, asText = inherits(what, "AsIs") || is.raw(what),
          ..., curl = getCurlHandle())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ftpUpload_+3A_what">what</code></td>
<td>
<p>the name of a local file or the contents to be uploaded. This can 
can be text or binary content. This can also be an open connection.
If this value is <code>raw</code> or has class <code>AsIs</code> by being enclosed within <code>I()</code>,
it is treated as literal content.</p>
</td></tr>
<tr><td><code id="ftpUpload_+3A_to">to</code></td>
<td>
<p>the URL to which the content is to be uploaded. This should be the ftp server
with the prefix <code>ftp://</code> and optionally the
user login and password, and then the path to the file in which the 
content is to be stored.</p>
</td></tr>
<tr><td><code id="ftpUpload_+3A_astext">asText</code></td>
<td>
<p>a logical value indicating whether to treat the value of <code>what</code>
as content, be it text or raw/binary vector.  Otherwise, <code>what</code> is 
treated as the name of a file.</p>
</td></tr>
<tr><td><code id="ftpUpload_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code><a href="#topic+curlPerform">curlPerform</a></code>.</p>
</td></tr>
<tr><td><code id="ftpUpload_+3A_curl">curl</code></td>
<td>
<p>the curl handle to use for the <code><a href="#topic+curlPerform">curlPerform</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of the <code><a href="#topic+curlPerform">curlPerform</a></code> call.
</p>


<h3>Note</h3>

<p>One can also provide additional FTP commands that are executed
before and after the upload as part of the request.
Use the prequote, quote, and postquote options in <code><a href="#topic+curlPerform">curlPerform</a></code> for these.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>FTP, libcurl</p>


<h3>See Also</h3>

<p><code><a href="#topic+curlPerform">curlPerform</a></code>
<code><a href="#topic+getCurlHandle">getCurlHandle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 

  ftpUpload(I("Some text to be uploaded into a file\nwith several lines"),
            "ftp://login:password@laptop17/ftp/zoe",
            )

  ftpUpload(I("Some text to be uploaded into a file\nwith several lines"),
            "ftp://laptop17/ftp/zoe",
            userpwd = "login:password"
            )

  ftpUpload(system.file("examples", "system.png", package = "RCurl"), 
            "ftp://login:password@laptop17/ftp/Election.rda",
            postquote = c("CWD subdir", "RNFR Election.rda", "RNTO ElectionPolls.rda")
            )
 
## End(Not run)
</code></pre>

<hr>
<h2 id='getBinaryURL'>Download binary content</h2><span id='topic+getBinaryURL'></span>

<h3>Description</h3>

<p>This function allows one to download binary content.
This is a convenience function that is a call to
<code><a href="#topic+getURL">getURL</a></code> with suitable values
for the <code>write</code> and <code>file</code> options
for the Curl handle. These take care of processing
the body of the response to the Curl request into a
vector of &quot;raw&quot; elements.
</p>
<p>Binary content from POST forms or other requests that are not simple
URL requests can be implemented using the same approach as this
function, i.e., specifying the same values as in the body of this function for
<code>write</code> and <code>file</code> in the call to <code><a href="#topic+curlPerform">curlPerform</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBinaryURL(url, ..., .opts = list(), curl = getCurlHandle(),
             .buf = binaryBuffer(.len), .len = 5000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBinaryURL_+3A_url">url</code></td>
<td>
<p>the URL identifying the content to download.
This can be a regular URL or a
<code>application/x-www-form-urlencoded</code> URL,
i.e. with name=value parameters appended to the location via a ?,
and separated  from each other via a &amp;.</p>
</td></tr>
<tr><td><code id="getBinaryURL_+3A_...">...</code></td>
<td>
<p>additional arguments that are passed to <code><a href="#topic+getURL">getURL</a></code>.</p>
</td></tr>
<tr><td><code id="getBinaryURL_+3A_.opts">.opts</code></td>
<td>
<p>a list of named values that are passed to
<code><a href="#topic+getURL">getURL</a></code> as the <code>.opts</code> argument.</p>
</td></tr>
<tr><td><code id="getBinaryURL_+3A_curl">curl</code></td>
<td>
<p>an optional curl handle used in <code><a href="#topic+curlPerform">curlPerform</a></code>
that has been created previously and is to be reused for this
request.
This allows the R user to reuse a curl handle that already has a
connection to the server or has settings for options that have been
set previously.</p>
</td></tr> 
<tr><td><code id="getBinaryURL_+3A_.buf">.buf</code></td>
<td>
<p>a raw vector in which to insert the body of the response.
This is a parameter to allow the caller to reuse an existing buffer.</p>
</td></tr>
<tr><td><code id="getBinaryURL_+3A_.len">.len</code></td>
<td>
<p>an non-negative integer which is used as the length for
the buffer in which to store the binary data in the response.
The buffer is extended if it is not big enough but this allows the
caller to provide context specific knowledge about the length of the
response, e.g. the size of the file being downloaded, and
avoid expanding the buffer as the material is being processed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;raw&quot; vector.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+getURL">getURL</a></code>,
<code><a href="base.html#topic+raw">raw</a></code>,
<code><a href="base.html#topic+memDecompress">memDecompress</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  u = "https://www.omegahat.net/RCurl/data.gz"

if(url.exists(u)) withAutoprint({

  content = getBinaryURL(u)

  if (getRversion() &gt;= "4") withAutoprint({
    x &lt;- memDecompress(content, asChar = TRUE)
    read.csv(textConnection(x))
  }) else withAutoprint({
     tmp = tempfile()
     writeBin(content, con = tmp)
     read.csv(gzfile(tmp))
     unlink(tmp)
  })


   # Working from the Content-Type in the header of the HTTP response.
  h  = basicTextGatherer()
  content = getBinaryURL(u, .opts = list(headerfunction = h$update))
  header = parseHTTPHeader(h$value())
  type = strsplit(header["Content-Type"], "/")[[1]]

  if(type[2] %in% c("x-gzip", "gzip")) {
  if (getRversion() &gt;= "4") {
     cat(memDecompress(content, asChar = TRUE))
  } else {
    tmp = tempfile()
    writeBin(content, con = tmp)
    writeLines(readLines(gzfile(tmp)))
    unlink(tmp)
    }
  }

})
</code></pre>

<hr>
<h2 id='getBitIndicators'>Operate on bit fields</h2><span id='topic+getBitIndicators'></span><span id='topic+setBitIndicators'></span>

<h3>Description</h3>

<p>The <code>getBitIndicators</code> function decompose a value into its respective
bit components.
The <code>setBitIndicators</code> combines individual components into a
single number
to &quot;set&quot; a bit field value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBitIndicators(val, defs)
setBitIndicators(vals, defs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBitIndicators_+3A_val">val</code></td>
<td>
<p>the value to break up into the bit field components.</p>
</td></tr>
<tr><td><code id="getBitIndicators_+3A_defs">defs</code></td>
<td>
<p>the named integer vector that defines the bit field elements.</p>
</td></tr>
<tr><td><code id="getBitIndicators_+3A_vals">vals</code></td>
<td>
<p>the individual components that are to be combined into a
single integer value representing the collection of components.
These can be given as names or integer values that correspond to the
elements in the defs, either by name or value.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getBitIndicators</code> returns a named integer vector representing
the components of the bit field in the value.
The names of the vector give the symbolic elements that were set in
the value.
</p>
<p><code>setBitIndicators</code> returns a single integer value representing
the value from combining the different components (e.g. ORing the bits
of the different values).
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>Curl homepage <a href="https://curl.se/">https://curl.se/</a></p>


<h3>See Also</h3>

<p>The features field in <code><a href="#topic+curlVersion">curlVersion</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  getBitIndicators(7, c(A = 1, B = 2, C = 4))
  getBitIndicators(3, c(A = 1, B = 2, C = 4))
  getBitIndicators(5, c(A = 1, B = 2, C = 4))
</code></pre>

<hr>
<h2 id='getCurlErrorClassNames'>Retrieve names of all curl error classes</h2><span id='topic+getCurlErrorClassNames'></span>

<h3>Description</h3>

<p>This function returns the names of all of the
error classes that curl can raise as a result
of a request. You can use these names
in calls to <code>tryCatch</code>
to identify the class of the error for which you
want to provide an error handler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCurlErrorClassNames()
</code></pre>


<h3>Value</h3>

<p>A character vector
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>References</h3>

<p>libcurl documentation
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+tryCatch">tryCatch</a></code>
<code><a href="#topic+curlPerform">curlPerform</a></code>   and higher-level functions
for making requests.
</p>

<hr>
<h2 id='getCurlHandle'>Create libcurl handles</h2><span id='topic+getCurlHandle'></span><span id='topic+getCurlMultiHandle'></span><span id='topic+dupCurlHandle'></span>

<h3>Description</h3>

<p>These functions create and duplicate curl handles
for use in calls to the HTTP facilities provided by
that low-level language and this R-level interface.
A curl handle is an opaque data type that contains a
reference to the internal C-level data structure
of libcurl for performing HTTP requests.
</p>
<p>The <code>getCurlMutliHandle</code> returns an object
that can be used for concurrent, multiple requests.
It is quite different from the regular curl handle
and again, should be treated as an opaque data type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCurlHandle(..., .opts = NULL, .encoding = integer(),
              .defaults = getOption("RCurlOptions"))
dupCurlHandle(curl, ..., .opts = NULL, .encoding = integer())
getCurlMultiHandle(..., .handles = list(...))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCurlHandle_+3A_curl">curl</code></td>
<td>
<p>the existing curl handle that is to be duplicated</p>
</td></tr>
<tr><td><code id="getCurlHandle_+3A_...">...</code></td>
<td>
<p>a named list of curl options to set after the handle has
been created. For <code>getCurlMultiHandle</code>, these values are
invidivual curl handle objects, created via <code>getCurlHandle</code> or <code>dupCurlHandle</code>. </p>
</td></tr>
<tr><td><code id="getCurlHandle_+3A_.opts">.opts</code></td>
<td>
<p>a named list or <code>CURLOptions</code> object identifying the
curl options for the handle. These and the <code>...</code> arguments are
used after the handle has been created.</p>
</td></tr>
<tr><td><code id="getCurlHandle_+3A_.encoding">.encoding</code></td>
<td>
<p>an integer or a string that explicitly identifies the
encoding of the content that is returned by the HTTP server in its
response to our query. The possible strings are
&lsquo;UTF-8&rsquo; or &lsquo;ISO-8859-1&rsquo;
and the integers should be specified symbolically
as  <code>CE_UTF8</code> and <code>CE_LATIN1</code>.
Note that, by default, the package attempts to process the header of
the HTTP response to determine the encoding. This argument is used
when such information is erroneous and the caller knows the correct
encoding.
</p>
</td></tr>
<tr><td><code id="getCurlHandle_+3A_.defaults">.defaults</code></td>
<td>
<p>a collection of default values taken from R's
global/session options. This is a parameter so that one can override
it if necessary.</p>
</td></tr>
<tr><td><code id="getCurlHandle_+3A_.handles">.handles</code></td>
<td>
<p>a list of curl handle objects that are used as the
individual request handles within the multi-asynchronous requests</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions create C-level data structures.
</p>


<h3>Value</h3>

<p>An object of class <code>CURLHandle</code>
which is simply a pointer to the memory for the C
structure.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>Curl homepage <a href="https://curl.se/">https://curl.se/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getURL">getURL</a></code>
<code><a href="#topic+curlPerform">curlPerform</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  options(RCurlOptions = list(verbose = TRUE,
                              followlocation = TRUE,
                              autoreferer = TRUE,
                              nosignal = TRUE))
  if(url.exists("https://www.omegahat.net/RCurl")) {
     x = getURL("https://www.omegahat.net/RCurl")
        # here we override one of these.
     x = getURL("https://www.omegahat.net/RCurl", verbose = FALSE)
  }
</code></pre>

<hr>
<h2 id='getCurlInfo'>Access information about a CURL request</h2><span id='topic+getCurlInfo'></span><span id='topic+getCurlInfoConstants'></span>

<h3>Description</h3>

<p>This function provides access to data about a previously
executed CURL request that is accessible via a
<code>CURLHandle</code> object.
This means, of course, that one must have access to the <code>CURLHandle</code>
object.
The information one can get includes items such as the name of the
file (potentially containing redirects), download time,
</p>
<p>See <code><a href="#topic+getCurlInfoConstants">getCurlInfoConstants</a></code> for the names of the possible fields.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCurlInfo(curl, which = getCurlInfoConstants())
getCurlInfoConstants()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCurlInfo_+3A_curl">curl</code></td>
<td>
<p>the <code>CURLHandle</code> object used to perform the request.
This is a reference to an opaque internal C-level data structure that is
provided and used by libcurl to make a request.</p>
</td></tr>
<tr><td><code id="getCurlInfo_+3A_which">which</code></td>
<td>
<p>identifiers for the elements of interest.
These can be specified by integer value or by name.
The names are matched against those in the
<code><a href="#topic+getCurlInfoConstants">getCurlInfoConstants</a></code></p>
</td></tr></table>
<p>.
</p>


<h3>Details</h3>

<p>This is an interface to the <code>get_curl_info</code> routine in
the libcurl package. 
</p>


<h3>Value</h3>

<p>A named list whose elements correspond
to the requested fields.
The names are expanded to match the names of these
fields and the values are either strings or integer values.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>Curl homepage <a href="https://curl.se/">https://curl.se/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+curlPerform">curlPerform</a></code>
<code><a href="#topic+getURL">getURL</a></code>  
<code><a href="#topic+getCurlHandle">getCurlHandle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> if(url.exists("https://www.omegahat.net/RCurl/index.html")) withAutoprint({
    curl = getCurlHandle()
    txt = getURL("https://www.omegahat.net/RCurl/index.html", curl = curl)
    getCurlInfo(curl)
    rm(curl)  # release the curl!
 })
</code></pre>

<hr>
<h2 id='getFormParams'>Extract parameters from a form query string</h2><span id='topic+getFormParams'></span>

<h3>Description</h3>

<p>This function facilitates getting the parameter names and values
from a URL that is an parameterized HTML query.
</p>
<p>This is motivated by a function from Chris Davis and Delft University.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFormParams(query, isURL = grepl("^(http|\\?)", query))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFormParams_+3A_query">query</code></td>
<td>
<p>the query string or full URL containing the query</p>
</td></tr>
<tr><td><code id="getFormParams_+3A_isurl">isURL</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, <code>query</code> is 
the full URL and we need to extract the sub-string representing the
parameters. If <code>isURL</code> is <code>FALSE</code>, then <code>query</code>
is assumed to be just the string containing the parameters.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named character vector
giving the parameter values  The names are the parameter names.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(url.exists("https://www.omegahat.net/foo/bob.R")) withAutoPrint({

  getFormParams("https://www.omegahat.net/foo/bob.R?xyz=1&amp;abc=verylong")

  getFormParams("xyz=1&amp;abc=verylong")
  getFormParams("xyz=1&amp;abc=&amp;on=true")
  getFormParams("xyz=1&amp;abc=")
})
</code></pre>

<hr>
<h2 id='getURIAsynchronous'>Download multiple URIs concurrently, with inter-leaved downloads</h2><span id='topic+getURIAsynchronous'></span><span id='topic+getURLAsynchronous'></span>

<h3>Description</h3>

<p>This function allows the caller to specify multiple URIs to download
at the same time. All the requests are submitted and then the replies
are processed as data becomes available on each connection.
In this way, the responses are processed in an inter-leaved fashion,
with a chunk from one response from one request being processed and
then followed by a chunk from a different request.
</p>
<p>Downloading documents asynchronously involves some trade-offs.
The switching between different streams, detecting when input is
available on any of them involves a little more processing
and so increases the consumption of CPU cycles.
On the other hand, there is a potentially large saving of
time when one considers total time to download.
See <a href="https://www.omegahat.net/RCurl/concurrent.xml">https://www.omegahat.net/RCurl/concurrent.xml</a>
for more details.  This is a common trade-off that arises in
concurrent/parallel/asynchronous computing.
</p>
<p><code><a href="#topic+getURI">getURI</a></code> calls this function if more than one
URI is specified and <code>async</code> is <code>TRUE</code>, the default in this case.
One can also download the (contents of the) multiple URIs
serially, i.e. one after the other using <code><a href="#topic+getURI">getURI</a></code>
with a value of <code>FALSE</code> for <code>async</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getURIAsynchronous(url, ..., .opts = list(), write = NULL,
                   curl = getCurlHandle(),
                   multiHandle = getCurlMultiHandle(), perform = Inf,
                  .encoding = integer(), binary = rep(NA, length(url)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getURIAsynchronous_+3A_url">url</code></td>
<td>
<p>a character vector identifying the URIs to download.</p>
</td></tr>
<tr><td><code id="getURIAsynchronous_+3A_...">...</code></td>
<td>
<p>named arguments to be passed to <code><a href="#topic+curlSetOpt">curlSetOpt</a></code>
when creating each of the different <code>curlHandle</code> objects.</p>
</td></tr>
<tr><td><code id="getURIAsynchronous_+3A_.opts">.opts</code></td>
<td>
<p>a named list or <code>CURLOptions</code> object identifying the
curl options for the handle. This is merged with the values of ...
to create the actual options for the curl handle in the request.</p>
</td></tr>  
<tr><td><code id="getURIAsynchronous_+3A_write">write</code></td>
<td>
<p>an object giving the functions or routines that are to be
called when input is waiting  on the different HTTP response
streams.
By default, a separate callback function is associated with each
input stream. This is necessary for the results to be meaningful
as if we use a single reader, it will be called for all streams
in a haphazard order and the content interleaved.
One can do interesting things however using a single object.
</p>
</td></tr>
<tr><td><code id="getURIAsynchronous_+3A_curl">curl</code></td>
<td>
<p>the prototypical curlHandle that is duplicated and used in
in </p>
</td></tr>
<tr><td><code id="getURIAsynchronous_+3A_multihandle">multiHandle</code></td>
<td>

<p>this is a curl handle for performing asynchronous requests.
</p>
</td></tr>
<tr><td><code id="getURIAsynchronous_+3A_perform">perform</code></td>
<td>
<p>a number which specifies the maximum number of calls to
<code><a href="#topic+curlMultiPerform">curlMultiPerform</a></code> that are to be made in this
function call. This is typically either 0 for no calls
or <code>Inf</code> meaning process the requests until completion.
One may find alternative values useful, such as 1 to ensure that
the requests are dispatched.
</p>
</td></tr>
<tr><td><code id="getURIAsynchronous_+3A_.encoding">.encoding</code></td>
<td>
<p>an integer or a string that explicitly identifies the
encoding of the content that is returned by the HTTP server in its
response to our query. The possible strings are
&lsquo;UTF-8&rsquo; or &lsquo;ISO-8859-1&rsquo;
and the integers should be specified symbolically
as  <code>CE_UTF8</code> and <code>CE_LATIN1</code>.
Note that, by default, the package attempts to process the header of
the HTTP response to determine the encoding. This argument is used
when such information is erroneous and the caller knows the correct
encoding.
</p>
</td></tr>
<tr><td><code id="getURIAsynchronous_+3A_binary">binary</code></td>
<td>
<p>a logical vector identifying whether each URI has binary
content or simple text.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This uses <code><a href="#topic+curlMultiPerform">curlMultiPerform</a></code>
and the multi/asynchronous interface for libcurl.
</p>


<h3>Value</h3>

<p>The return value depends on the run-time characteristics
of the call.
If the call merely specifies the URIs to be downloaded, the result
is a named character vector. The names identify the URIs
and the elements of the vector are the contents of the corresponding
URI.
</p>
<p>If the requests are not performed or completed
(i.e. <code>perform</code> is zero  or too small a value to process all the chunks)
a list with 2 elements is returned.
These elements are:
</p>
<table>
<tr><td><code>multiHandle</code></td>
<td>
<p>the curl multi-handle, of class
<code><a href="#topic+MultiCURLHandle-class">MultiCURLHandle-class</a></code>. This can be used
in further calls to <code><a href="#topic+curlMultiPerform">curlMultiPerform</a></code></p>
</td></tr>
<tr><td><code>write</code></td>
<td>
<p>the <code>write</code> argument (after it was potentially
expanded to a list). This can then be used to fetch the results
of the requests when the requests are completed in the future.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Duncan Temple Lang &lt;duncan@r-project.org&gt;</p>


<h3>References</h3>

<p>Curl homepage <a href="https://curl.se/">https://curl.se/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getURL">getURL</a></code>
<code><a href="#topic+getCurlMultiHandle">getCurlMultiHandle</a></code>
<code><a href="#topic+curlMultiPerform">curlMultiPerform</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  uris = c("https://www.omegahat.net/RCurl/index.html",
           "https://www.omegahat.net/RCurl/philosophy.xml")
  txt = getURIAsynchronous(uris)
  names(txt)
  nchar(txt)
</code></pre>

<hr>
<h2 id='getURL'>Download a URI</h2><span id='topic+getURL'></span><span id='topic+getURI'></span><span id='topic+getURLContent'></span>

<h3>Description</h3>

<p>These functions download one or more URIs (a.k.a. URLs).
It uses libcurl under the hood to perform the request
and retrieve the response.
There are a myriad of options that can be specified using
the ... mechanism to control the creation and submission
of the request and the processing of the response.
</p>
<p><code>getURLContent</code> has been added as a high-level function
like <code>getURL</code> and <code>getBinaryURL</code> but which 
determines the type of the content being downloaded
by looking at the resulting HTTP header's Content-Type
field. It uses this to determine whether the bytes
are binary or &quot;text&quot;.
</p>
<p>The request supports any of the facilities within the
version of libcurl that was installed.
One can examine these via <code><a href="#topic+curlVersion">curlVersion</a></code>.
</p>
<p><code>getURLContent</code> doesn't perform asynchronous or multiple
concurrent requests at present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getURL(url, ..., .opts = list(),
        write = basicTextGatherer(.mapUnicode = .mapUnicode),
         curl = getCurlHandle(), async = length(url) &gt; 1,
           .encoding = integer(), .mapUnicode = TRUE)
getURI(url, ..., .opts = list(), 
        write = basicTextGatherer(.mapUnicode = .mapUnicode),
         curl = getCurlHandle(), async = length(url) &gt; 1,
          .encoding = integer(), .mapUnicode = TRUE)
getURLContent(url, ..., curl = getCurlHandle(.opts = .opts), .encoding = NA,
               binary = NA, .opts = list(...),
               header = dynCurlReader(curl, binary = binary,
                                        baseURL = url, isHTTP = isHTTP,
                                         encoding = .encoding),
               isHTTP = length(grep('^[[:space:]]*http', url)) &gt; 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getURL_+3A_url">url</code></td>
<td>
<p>a string giving the URI</p>
</td></tr>
<tr><td><code id="getURL_+3A_...">...</code></td>
<td>
<p>named values that are interpreted as CURL options
governing the HTTP request.</p>
</td></tr>
<tr><td><code id="getURL_+3A_.opts">.opts</code></td>
<td>
<p>a named list or <code>CURLOptions</code> object identifying the
curl options for the handle. This is merged with the values of ...
to create the actual options for the curl handle in the request.</p>
</td></tr>  
<tr><td><code id="getURL_+3A_write">write</code></td>
<td>
<p>if explicitly supplied, this is a function that is called
with a single argument each time the the HTTP response handler has
gathered sufficient text. The argument to the function is
a single string.  The default argument provides
both a  function for cumulating this text and is then used
to retrieve it as the return value for this function.
</p>
</td></tr>
<tr><td><code id="getURL_+3A_curl">curl</code></td>
<td>
<p>the previously initialized CURL context/handle which can
be used for multiple requests.</p>
</td></tr>
<tr><td><code id="getURL_+3A_async">async</code></td>
<td>
<p>a logical value that determines whether the download
request should be done via asynchronous, concurrent downloading or a serial
download. This really only arises when we are trying to download
multiple URIs in a single call. There are trade-offs between
concurrent and serial downloads, essentially trading CPU cycles
for shorter elapsed times. Concurrent downloads reduce the overall
time waiting for <code>getURI</code>/<code>getURL</code> to return.
</p>
</td></tr>
<tr><td><code id="getURL_+3A_.encoding">.encoding</code></td>
<td>
<p>an integer or a string that explicitly identifies the
encoding of the content that is returned by the HTTP server in its
response to our query. The possible strings are
&lsquo;UTF-8&rsquo; or &lsquo;ISO-8859-1&rsquo;
and the integers should be specified symbolically
as  <code>CE_UTF8</code> and <code>CE_LATIN1</code>.
Note that, by default, the package attempts to process the header of
the HTTP response to determine the encoding. This argument is used
when such information is erroneous and the caller knows the correct
encoding.
The default value leaves the decision  to this default mechanism.
This does however currently involve processing each line/chunk
of the header (with a call to an R function). As a result,
if one knows the encoding for the resulting response,
specifying this avoids this slight overhead which is probably
quite small relative to network latency and speed.
</p>
</td></tr>
<tr><td><code id="getURL_+3A_.mapunicode">.mapUnicode</code></td>
<td>
<p>a logical value that controls whether the resulting
text is processed to map components of the form \uxxxx to their
appropriate Unicode representation.</p>
</td></tr>
<tr><td><code id="getURL_+3A_binary">binary</code></td>
<td>
<p>a logical value indicating whether the caller  knows
whether the resulting content is binary (<code>TRUE</code>) or not
(<code>FALSE</code>) or unknown (<code>NA</code>).
</p>
</td></tr>
<tr><td><code id="getURL_+3A_header">header</code></td>
<td>
<p>this is made available as a parameter of the function
to allow callers to construct different readers for processing
the header and body of the (HTTP) response.
Callers specifying this will typically only adjust the
call to <code>dynCurlReader</code>, e.g. to specify a
function for its <code>value</code> parameter to
control how the body is post-processed.
</p>
<p>The caller can specify a value of <code>TRUE</code> or <code>FALSE</code>
for this parameter.  <code>TRUE</code> means that the header will be
returned along with the body; <code>FALSE</code> corresponds to the
default  and only the body will be returned.
When returning the header, it is first parsed via
<code><a href="#topic+parseHTTPHeader">parseHTTPHeader</a></code>,
unless the value of <code>header</code> is of class <code>AsIs</code>.
So to get the raw header, pass the argument as <code>header = I(TRUE)</code>.
</p>
</td></tr>
<tr><td><code id="getURL_+3A_ishttp">isHTTP</code></td>
<td>
<p>a logical value that indicates whether the request an
HTTP request. This is used when determining how to process the response.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If no value is supplied for <code>write</code>,
the result is the text that is the HTTP response.
(HTTP header information is included if the header option for CURL is
set to <code>TRUE</code> and no handler for headerfunction is supplied in
the CURL options.)
</p>
<p>Alternatively, if a value is supplied for the <code>write</code> parameter,
this is returned. This allows the caller to create a handler within
the call and get it back. This avoids having to explicitly create
and assign it and then call <code>getURL</code> and then access the result.
Instead, the 3 steps can be inlined in a single call.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>Curl homepage <a href="https://curl.se/">https://curl.se/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getBinaryURL">getBinaryURL</a></code>
<code><a href="#topic+curlPerform">curlPerform</a></code>
<code><a href="#topic+curlOptions">curlOptions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  omegahatExists = url.exists("https://www.omegahat.net")

   # Regular HTTP
  if(omegahatExists &amp;&amp; requireNamespace("XML", quietly = TRUE)) withAutoprint({
     txt = getURL("https://www.omegahat.net/RCurl/")
     ## Then we could parse the result.
     XML::htmlTreeParse(txt, asText = TRUE)
  })


        # HTTPS. First check to see that we have support compiled into
        # libcurl for ssl.
  if(interactive() &amp;&amp; ("ssl" %in% names(curlVersion()$features))
         &amp;&amp; url.exists("https://sourceforge.net/")) {
     txt = tryCatch(getURL("https://sourceforge.net/"),
                    error = function(e) {
                                  getURL("https://sourceforge.net/",
                                            ssl.verifypeer = FALSE)
                              })

  }


     # Create a CURL handle that we will reuse.
  if(interactive() &amp;&amp; omegahatExists) {
     curl = getCurlHandle()
     pages = list()
     for(u in c("https://www.omegahat.net/RCurl/index.html",
                "https://www.omegahat.net/RGtk/index.html")) {
         pages[[u]] = getURL(u, curl = curl)
     }
  }


    # Set additional fields in the header of the HTTP request.
    # verbose option allows us to see that they were included.
  if(omegahatExists)
     getURL("https://www.omegahat.net", httpheader = c(Accept = "text/html", 
                                                      MyField = "Duncan"), 
               verbose = TRUE)



    # Arrange to read the header of the response from the HTTP server as
    # a separate "stream". Then we can break it into name-value
    # pairs. (The first line is the HTTP/1.1 200 Ok or 301 Moved Permanently
    # status line)
  if(omegahatExists) withAutoprint({
     h = basicTextGatherer()
     txt = getURL("https://www.omegahat.net/RCurl/index.html",
                  header= TRUE, headerfunction = h$update, 
                  httpheader = c(Accept="text/html", Test=1), verbose = TRUE) 
     print(paste(h$value(NULL)[-1], collapse=""))
     con &lt;- textConnection(paste(h$value(NULL)[-1], collapse=""))
     read.dcf(con)
     close(con)
  })



   # Test the passwords.
  if(omegahatExists) withAutoprint({
     x = getURL("https://www.omegahat.net/RCurl/testPassword/index.html",  userpwd = "bob:duncantl")

       # Catch an error because no authorization
       # We catch the generic HTTPError, but we could catch the more specific "Unauthorized" error
       # type.
      x = tryCatch(getURLContent("https://www.omegahat.net/RCurl/testPassword/index.html"),
                    HTTPError = function(e) {
                                   cat("HTTP error: ", e$message, "\n")
                                })
  })

## Not run: 
  #  Needs specific information from the cookie file on a per user basis
  #  with a registration to the NY times.
  x = getURL("https://www.nytimes.com",
                 header = TRUE, verbose = TRUE,
                 cookiefile = "/home/duncan/Rcookies",
                 netrc = TRUE,
                 maxredirs = as.integer(20),
                 netrc.file = "/home2/duncan/.netrc1",
                 followlocation = TRUE)

## End(Not run)

   if(interactive() &amp;&amp; omegahatExists) {
       d = debugGatherer()
       x = getURL("https://www.omegahat.net", debugfunction = d$update, verbose = TRUE)
       d$value()
   }

    #############################################
    #  Using an option set in R

   if(interactive() &amp;&amp; omegahatExists) {
      opts = curlOptions(header = TRUE, userpwd = "bob:duncantl", netrc = TRUE)
      getURL("https://www.omegahat.net/RCurl/testPassword/index.html", verbose = TRUE, .opts = opts)

         # Using options in the CURL handle.
      h = getCurlHandle(header = TRUE, userpwd = "bob:duncantl", netrc = TRUE)
      getURL("https://www.omegahat.net/RCurl/testPassword/index.html", verbose = TRUE, curl = h)
   }



   # Use a C routine as the reader. Currently gives a warning.
  if(interactive() &amp;&amp; omegahatExists) {
     routine = getNativeSymbolInfo("R_internalWriteTest", PACKAGE = "RCurl")$address
     getURL("https://www.omegahat.net/RCurl/index.html", writefunction = routine)
  }



  # Example
  if(interactive() &amp;&amp; omegahatExists) {
     uris = c("https://www.omegahat.net/RCurl/index.html",
              "https://www.omegahat.net/RCurl/philosophy.xml")
     txt = getURI(uris)
     names(txt)
     nchar(txt)

     txt = getURI(uris, async = FALSE)
     names(txt)
     nchar(txt)


     routine = getNativeSymbolInfo("R_internalWriteTest", PACKAGE = "RCurl")$address
     txt = getURI(uris, write = routine, async = FALSE)
     names(txt)
     nchar(txt)


         # getURLContent() for text and binary
     x = getURLContent("https://www.omegahat.net/RCurl/index.html")
     class(x)

     x = getURLContent("https://www.omegahat.net/RCurl/data.gz")
     class(x)
     attr(x, "Content-Type")

     x = getURLContent("https://www.omegahat.net/Rcartogram/demo.jpg")
     class(x)
     attr(x, "Content-Type")


     curl = getCurlHandle()
     dd = getURLContent("https://www.omegahat.net/RJSONIO/RJSONIO.pdf",
                        curl = curl,
                        header = dynCurlReader(curl, binary = TRUE,
                                           value = function(x) {
                                                    print(attributes(x)) 
                                                    x}))
   }



  # FTP
  # Download the files within a directory.
if(interactive() &amp;&amp; url.exists('ftp://ftp.wcc.nrcs.usda.gov')) {

   url = 'ftp://ftp.wcc.nrcs.usda.gov/data/snow/snow_course/table/history/idaho/'
   filenames = getURL(url, ftp.use.epsv = FALSE, dirlistonly = TRUE)

      # Deal with newlines as \n or \r\n. (BDR)
      # Or alternatively, instruct libcurl to change \n's to \r\n's for us with crlf = TRUE
      # filenames = getURL(url, ftp.use.epsv = FALSE, ftplistonly = TRUE, crlf = TRUE)
   filenames = paste(url, strsplit(filenames, "\r*\n")[[1]], sep = "")
   con = getCurlHandle( ftp.use.epsv = FALSE)

      # there is a slight possibility that some of the files that are
      # returned in the directory listing and in filenames will disappear
      # when we go back to get them. So we use a try() in the call getURL.
   contents = sapply(filenames[1:5], function(x) try(getURL(x, curl = con)))
   names(contents) = filenames[1:length(contents)]
}
   
</code></pre>

<hr>
<h2 id='guessMIMEType'>Infer the MIME type from a file name</h2><span id='topic+guessMIMEType'></span>

<h3>Description</h3>

<p>This function returns the MIME type, i.e. part of the value
used in the Content-Type for an HTTP request/response
or in email to identify the nature of the content.
This is a string such as &quot;text/plain&quot; or &quot;text/xml&quot;
or &quot;image/png&quot;.
</p>
<p>The function consults an R object constructed
by reading a Web site of known MIME types (not necessarily all)
and matching the extension of the file name to the names of that table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guessMIMEType(name, default = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guessMIMEType_+3A_name">name</code></td>
<td>
<p>character vector of file names</p>
</td></tr>
<tr><td><code id="guessMIMEType_+3A_default">default</code></td>
<td>
<p>the value to use if no MIME type is found in the table
for the given file name/extension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector giving the MIME types for each element of <code>name</code>.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>References</h3>

<p>The table of MIME types and extensions was programmatically extracted
from &lsquo;<span class="samp">&#8288;http://www.webmaster-toolkit.com/mime-types.shtml&#8288;</span>&rsquo; with
<code>
  tbls = readHTMLTable("http://www.webmaster-toolkit.com/mime-types.shtml")
  tmp = tbls[[1]][-1,]
  mimeTypeExtensions = structure(as.character(tmp[[2]]), names = gsub("^\.", "", tmp[[1]]))
  save(mimeTypeExtensions, file = "data/mimeTypeExtensions.rda")
</code>
The IANA list is not as convenient to programmatically compile.
</p>


<h3>See Also</h3>

<p>Uploading file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> guessMIMEType(c("foo.txt", "foo.png", "foo.jpeg", "foo.Z", "foo.R"))

 guessMIMEType("foo.bob")
 guessMIMEType("foo.bob", "application/x-binary")
</code></pre>

<hr>
<h2 id='HTTP_VERSION_1_0'>Symbolic constants for specifying HTTP and SSL versions in libcurl</h2><span id='topic+HTTP_VERSION_1_0'></span><span id='topic+HTTP_VERSION_1_1'></span><span id='topic+HTTP_VERSION_LAST'></span><span id='topic+HTTP_VERSION_NONE'></span><span id='topic+SSLVERSION_DEFAULT'></span><span id='topic+SSLVERSION_LAST'></span><span id='topic+SSLVERSION_SSLv2'></span><span id='topic+SSLVERSION_SSLv3'></span><span id='topic+SSLVERSION_TLSv1'></span>

<h3>Description</h3>

<p>These are values that can be used to set the <code>http.version</code> and <code>sslversion</code>
options of <code><a href="#topic+curlPerform">curlPerform</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HTTP_VERSION_1_0</code></pre>


<h3>References</h3>

<p><a href="https://curl.se/libcurl/c/curl_easy_setopt.html">https://curl.se/libcurl/c/curl_easy_setopt.html</a>
</p>

<hr>
<h2 id='httpPUT'>Simple high-level functions for HTTP PUT and DELETE</h2><span id='topic+httpPUT'></span><span id='topic+httpPOST'></span><span id='topic+httpGET'></span><span id='topic+httpDELETE'></span><span id='topic+httpHEAD'></span><span id='topic+httpOPTIONS'></span>

<h3>Description</h3>

<p>These two functions are simple, high-level functions
that implement the HTTP request methods PUT and DELETE.
These can also be done by specifying the method
type using the curl option <code>customrequest</code>.
These functions merely provide a convenience
wrapper for <code><a href="#topic+getURLContent">getURLContent</a></code>
with the HTTP method specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>httpPUT(url, content,  ..., curl = getCurlHandle())
httpPOST(url, ..., curl = getCurlHandle())
httpDELETE(url, ..., curl = getCurlHandle())
httpGET(url, ..., curl = getCurlHandle())
httpHEAD(url, ..., curl = getCurlHandle())
httpOPTIONS(url, ..., curl = getCurlHandle())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="httpPUT_+3A_url">url</code></td>
<td>
<p>the URL of the server to which the HTTP request is to be
made</p>
</td></tr>
<tr><td><code id="httpPUT_+3A_content">content</code></td>
<td>
<p>the value that is to be used as the content of the
<code>PUT</code> request. This can be a character or a <code>raw</code> object.</p>
</td></tr>
<tr><td><code id="httpPUT_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+getURLContent">getURLContent</a></code></p>
</td></tr>
<tr><td><code id="httpPUT_+3A_curl">curl</code></td>
<td>
<p>the curl handle to be used to make the request</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The content returned by the server as a result of the request.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getURLContent">getURLContent</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   # create a database in a CouchDB server
 httpPUT("http://127.0.0.1:5984/temp_db")

   # Insert an entry into an ElasticSearch dabtabase.
 httpPUT("http://localhost:9200/a/b/axyz", '{"abc" : 123}')

   # Then delete the database
 httpDELETE("http://127.0.0.1:5984/temp_db")

## End(Not run)
</code></pre>

<hr>
<h2 id='merge.list'>Method for merging two lists by name</h2><span id='topic+merge.list'></span>

<h3>Description</h3>

<p>This is a method that merges the contents of one list
with another by adding the named elements in the second
that are not in the first.
In other words, the first list is the target template,
and the second one adds any extra elements that it has.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge.list(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge.list_+3A_x">x</code></td>
<td>
<p>the list to which elements will be added</p>
</td></tr>
<tr><td><code id="merge.list_+3A_y">y</code></td>
<td>
<p>the list which will supply additional elements to <code>x</code>
that are not already there by name. </p>
</td></tr>
<tr><td><code id="merge.list_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list whose name set is the union of the elements
in names of x and y and whose values are those taken
from y and then with those in x, overwriting if necessary.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>Curl homepage <a href="https://curl.se/">https://curl.se/</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+merge">merge</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Not exported.

 merge.list(list(a=1, b = "xyz", c = function(x, y) {x+y}),
             list(a = 2, z = "a string"))

  # No values in y
 merge.list(list(a=1, b = "xyz", c = function(x, y) {x+y}), list())

  # No values in x
 merge.list(list(), list(a=1, b = "xyz", c = function(x, y) {x+y}))

## End(Not run)
</code></pre>

<hr>
<h2 id='mimeTypeExtensions'>Mapping from extension to MIME type</h2><span id='topic+mimeTypeExtensions'></span>

<h3>Description</h3>

<p>This is a programmatically generated character vector
whose names identify the  MIME type typically associated with
the extension which are the values.
This is used in <code><a href="#topic+guessMIMEType">guessMIMEType</a></code>.
We can match an extension and then find the corresponding
MIME type.
There are duplicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mimeTypeExtensions)</code></pre>


<h3>Format</h3>

<p>The format is a named character vector
where the names are the MIME types
and the values are the file
extensions.
</p>


<h3>Source</h3>

<p>The table of MIME types and extensions was programmatically extracted
from &lsquo;<span class="samp">&#8288;http://www.webmaster-toolkit.com/mime-types.shtml&#8288;</span>&rsquo; with
<code>
  tbls = readHTMLTable("http://www.webmaster-toolkit.com/mime-types.shtml")
  tmp = tbls[[1]][-1,]
  mimeTypeExtensions = structure(as.character(tmp[[2]]), names = gsub("^\.", "", tmp[[1]]))
  save(mimeTypeExtensions, file = "data/mimeTypeExtensions.rda")
</code>
The IANA list is not as convenient to programmatically compile.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mimeTypeExtensions)
</code></pre>

<hr>
<h2 id='MultiCURLHandle-class'>Class &quot;MultiCURLHandle&quot; for asynchronous, concurrent HTTP requests</h2><span id='topic+MultiCURLHandle-class'></span><span id='topic+pop'></span><span id='topic+push'></span><span id='topic+pop+2CMultiCURLHandle+2CCURLHandle-method'></span><span id='topic+pop+2CMultiCURLHandle+2Ccharacter-method'></span><span id='topic+push+2CMultiCURLHandle+2CCURLHandle-method'></span>

<h3>Description</h3>

<p>This is a class that represents a handle to an internal
C-level data structure provided by libcurl to
perform multiple HTTP requests in a single operation
and process the responses in an inter-leaved fashion,
i.e. a chunk from one, followed by a chunk from another.
</p>
<p>Objects of this class contain not only a reference to the
internal C-level data structure, but also have a list
of the <code><a href="#topic+CURLHandle-class">CURLHandle-class</a></code> objects
that represent the individual HTTP requests that make up
the collection of concurrent requests.
These are maintained for garbage collection reasons.
</p>
<p>Essentially, the data in objects of this class are for internal use;
this is an opaque class in R.
</p>


<h3>Objects from the Class</h3>

<p>The constructor function  <code><a href="#topic+getCurlMultiHandle">getCurlMultiHandle</a></code>
is the only way to create meaningful instances of this class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ref</code>:</dt><dd><p>Object of class <code>"externalptr"</code>. This is
a reference to the instance of the libcurl data structure
<code>CURLM</code> pointer.
</p>
</dd>
<dt><code>subhandles</code>:</dt><dd><p>Object of class <code>"list"</code>.
This is a list of <code><a href="#topic+CURLHandle-class">CURLHandle-class</a></code>
instances that have been <code>push()</code>ed onto the
multi-handle stack.
</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>pop</dt><dd><p><code>signature(obj = "MultiCURLHandle", val = "CURLHandle")</code>: ... </p>
</dd>
<dt>pop</dt><dd><p><code>signature(obj = "MultiCURLHandle", val = "character")</code>: ... </p>
</dd>
<dt>push</dt><dd><p><code>signature(obj = "MultiCURLHandle", val = "CURLHandle")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>Curl homepage <a href="https://curl.se/">https://curl.se/</a>
<a href="https://www.omegahat.net/RCurl/">https://www.omegahat.net/RCurl/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getCurlMultiHandle">getCurlMultiHandle</a></code>
<code><a href="#topic+curlMultiPerform">curlMultiPerform</a></code>
<code><a href="#topic+multiTextGatherer">multiTextGatherer</a></code>    
</p>

<hr>
<h2 id='postForm'>Submit an HTML form</h2><span id='topic+postForm'></span><span id='topic+.postForm'></span><span id='topic+getForm'></span>

<h3>Description</h3>

<p>These functions provide facilities for submitting an HTML
form using either the simple GET mechanism (appending the name-value
pairs of parameters in the URL) or the POST method which puts
the name-value pairs as separate sections  in the body of the 
HTTP request. The choice of action is defined by the form,
not the caller.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postForm(uri, ..., .params = list(), .opts = curlOptions(url = uri),
         curl = getCurlHandle(), style = 'HTTPPOST',
          .encoding = integer(), binary = NA, .checkParams = TRUE,
          .contentEncodeFun = curlEscape)
.postForm(curl, .opts, .params, style = 'HTTPPOST')
getForm(uri, ..., .params = character(), .opts = list(), curl = getCurlHandle(),
         .encoding = integer(), binary = NA, .checkParams = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postForm_+3A_uri">uri</code></td>
<td>
<p>the full URI to which the form is to be posted. This
includes the host and the specific file or script which will process
the form.</p>
</td></tr>
<tr><td><code id="postForm_+3A_...">...</code></td>
<td>
<p>the name-value pairs of parameters.
Note that these are not the CURL options.</p>
</td></tr>
<tr><td><code id="postForm_+3A_.params">.params</code></td>
<td>
<p>instead of specifying the name-value parameters in
&quot;free&quot; form via the ... argument, one can specify them
as named list or character vector.
</p>
</td></tr>
<tr><td><code id="postForm_+3A_.opts">.opts</code></td>
<td>
<p>an object representing the CURL options for this call.</p>
</td></tr>
<tr><td><code id="postForm_+3A_curl">curl</code></td>
<td>
<p>the <code>CURLHandle</code> object created earlier if one is
reusing these objects. Otherwise, a new one is generated and
discarded.</p>
</td></tr>
<tr><td><code id="postForm_+3A_style">style</code></td>
<td>
<p>this is typically a string
and controls how the form data is posted, specifically
the value for the Content-Type header and the particular
representation.
Use 'httppost' to use a <code>multipart/form-data</code>
transmission
and use 'post' for <code>application/x-www-form-urlencoded</code>
content.
This string is compared to the names
of (the internal) <code>PostStyles</code> vector using partial
matching.  In the future, we will use
enum values within R.
The default is <code>multipart/form-data</code> for reasons of backward compatability.
</p>
</td></tr>
<tr><td><code id="postForm_+3A_.encoding">.encoding</code></td>
<td>
<p>the encoding of the result, if it is known a priori.
This can be an integer between 0 and 4 or more appropriately a
string identifying the encoding as one of  &quot;utf-8&quot;,
or &quot;ISO-859-1&quot;.</p>
</td></tr>
<tr><td><code id="postForm_+3A_binary">binary</code></td>
<td>
<p>a logical value indicating whether the caller  knows
whether the resulting content is binary (<code>TRUE</code>) or not
(<code>FALSE</code>) or unknown (<code>NA</code>).
</p>
</td></tr>  
<tr><td><code id="postForm_+3A_.checkparams">.checkParams</code></td>
<td>
<p>a logical value that indicates whether we should perform a check/test
to identify if any of the arguments passed to the form correspond to Curl options.
This is useful to identify potential errors in specifying the Curl options in the
wrong place (in the way we would for <code><a href="#topic+curlPerform">curlPerform</a></code>).
This check can lead to spurious warning messages if the form has parameters
with names that do conflict with Curl options. 
By specifying <code>FALSE</code> for this parameter, you can avoid this test
and hence any warnings. But make certain you know what you are doing.
</p>
</td></tr>
<tr><td><code id="postForm_+3A_.contentencodefun">.contentEncodeFun</code></td>
<td>
<p>a function which encodes strings in a
suitable manner.  For x-www-form-encoded submissions, this should 
most likely should be <code>curlPercentEncode</code> which maps spaces to
+, = to %3D, etc.
We are leaving the default as <code>curlEscape</code> for now until we test whether applications
continue to work with the correct encoding.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creating a new <code>CURLHandle</code> allows the C-level code
to more efficiently map the R-level values to their
C equivalents needed to make the call. However, reusing
the handle across calls can be more efficient in that
the connection to a server can be maintained and thus,
the sometimes expensive task of establishing it is
avoided in subsequent calls.
</p>


<h3>Value</h3>

<p>By default, the text from the HTTP response is
returned.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getURL">getURL</a></code>
<code><a href="#topic+curlOptions">curlOptions</a></code>
<code><a href="#topic+curlSetOpt">curlSetOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(url.exists("http://www.google.com")) withAutoprint({
   # Two ways to submit a query to google. Searching for RCurl
  getURL("http://www.google.com/search?hl=en&amp;lr=&amp;ie=ISO-8859-1&amp;q=RCurl&amp;btnG=Search")

   # Here we let getForm do the hard work of combining the names and values.
  getForm("http://www.google.com/search", hl="en", lr="",
          ie="ISO-8859-1", q="RCurl", btnG="Search")

   # And here if we already have the parameters as a list/vector.
  getForm("http://www.google.com/search", .params = c(hl="en", lr="",
          ie="ISO-8859-1",  q="RCurl", btnG="Search"))
})


   # Now looking at POST method for forms.
url &lt;- "http://wwwx.cs.unc.edu/~jbs/aw-wwwp/docs/resources/perl/perl-cgi/programs/cgi_stdin.cgi"
if(url.exists(url)) 
 postForm(url,
           name = "Bob", "checkedbox" = "spinich",
           submitButton = "Now!",
           textarea = "Some text to send",
           selectitem = "The item",
           radiobutton = "a", style = "POST")


  # Genetic database via the Web.
if(url.exists('http://www.wormbase.org/db/searches/advanced/dumper')) withAutoprint({
 x = postForm('http://www.wormbase.org/db/searches/advanced/dumper',
         species="briggsae",
         list="",
         flank3="0",
         flank5="0",
         feature="Gene Models",
         dump = "Plain TEXT",
         orientation = "Relative to feature",
         relative = "Chromsome",
         DNA ="flanking sequences only",
         .cgifields = paste(c("feature", "orientation", "DNA", "dump","relative"), collapse=", "))


 # Note that we don't have to paste multiple values together ourselves,
 # e.g. the .cgifields can be specified as a character vector rather
 # than a string.
 x = postForm('http://www.wormbase.org/db/searches/advanced/dumper',
         species="briggsae",
         list="",
         flank3="0",
         flank5="0",
         feature="Gene Models",
         dump = "Plain TEXT",
         orientation = "Relative to feature",
         relative = "Chromsome",
         DNA ="flanking sequences only",
         .cgifields =c("feature", "orientation", "DNA", "dump", "relative"))
})
	  
</code></pre>

<hr>
<h2 id='RCurlInternal'>Internal functions</h2><span id='topic+coerce+2Cnumeric+2CNetrcEnum-method'></span>

<h3>Description</h3>

<p>Not for human consumption</p>

<hr>
<h2 id='reset'>Generic function for resetting an object</h2><span id='topic+reset'></span><span id='topic+reset+2CCURLHandle-method'></span>

<h3>Description</h3>

<p>This generic and the associated method for a CURLHandle
allows one to reset the state of the Curl object
to its default state.  This is convenient if we want
to reuse the same connection, but want to ensure
that it is in a particular state.
</p>
<p>Unfortunately, we cannot query the state of different
fields in an existing Curl handle and so we need
to be able to reset the state and then update it with
any particular settings we would have liked to keep.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reset(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reset_+3A_x">x</code></td>
<td>
<p>the object to be reset. For our method, this is an object of
class  <code>CURLHandle</code>.</p>
</td></tr>
<tr><td><code id="reset_+3A_...">...</code></td>
<td>
<p>additional arguments for methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This calls the C routine <code>curl_easy_reset</code> in libcurl.
</p>


<h3>Value</h3>

<p>Methods typically return the updated version of the
object passed to it. This allows the caller to assign
the new result to the same variable rather than
relying on mutating the content of the object in place.
In other words, the object should not be treated as a reference
but a new object with the updated contents should be returned.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>Curl homepage <a href="https://curl.se/">https://curl.se/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getCurlHandle">getCurlHandle</a></code>
<code><a href="#topic+dupCurlHandle">dupCurlHandle</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'> h = getCurlHandle()
 curlSetOpt(customrequest = "DELETE")
 reset(h)
</code></pre>

<hr>
<h2 id='scp'>Retrieve contents of a file from a remote host via SCP (Secure Copy)</h2><span id='topic+scp'></span>

<h3>Description</h3>

<p>This function allows us to retrieve the contents of a file from a
remote host via SCP. This is done entirely within R, rather than
a command line application and the contents of the file are never
written to disc.  The function allows the 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scp(host, path, keypasswd = NA, user = getUserName(), rsa = TRUE,
     key = sprintf(c("~/.ssh/id_%s.pub", "~/.ssh/id_%s"),
                   if (rsa) "rsa" else "dsa"),
     binary = NA, size = 5000, curl = getCurlHandle(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scp_+3A_host">host</code></td>
<td>
<p>the name of the remote host or its IP address</p>
</td></tr>
<tr><td><code id="scp_+3A_path">path</code></td>
<td>
<p>the path of the file of interest on the remote host's file
systems</p>
</td></tr>
<tr><td><code id="scp_+3A_keypasswd">keypasswd</code></td>
<td>
<p>a password for accessing the local SSH key. This is
the passphrase for the key.</p>
</td></tr>
<tr><td><code id="scp_+3A_user">user</code></td>
<td>
<p>the name of the user on the remote machine</p>
</td></tr>
<tr><td><code id="scp_+3A_rsa">rsa</code></td>
<td>
<p>a logical value indicating whether to use the RSA or DSA key</p>
</td></tr>
<tr><td><code id="scp_+3A_key">key</code></td>
<td>
<p>the path giving the location of the SSH key. </p>
</td></tr>
<tr><td><code id="scp_+3A_binary">binary</code></td>
<td>
<p>a logical value giving </p>
</td></tr>
<tr><td><code id="scp_+3A_size">size</code></td>
<td>
<p>an estimate of the size of the buffer needed to store the
contents of the file. This is used to initialize the buffer and
potentially avoid resizing it as needed.</p>
</td></tr>
<tr><td><code id="scp_+3A_curl">curl</code></td>
<td>
<p>a curl handle (<code><a href="#topic+getCurlHandle">getCurlHandle</a></code>) that is to be
reused for this request and which potentially contains numerous
options settings or an existing connection to the host.</p>
</td></tr>
<tr><td><code id="scp_+3A_...">...</code></td>
<td>
<p>additional parameters handed to <code><a href="#topic+curlPerform">curlPerform</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This uses libcurl's facilities for scp.
Use <code>"scp" %in% curlVersion()$protocols</code> to
see if SCP is supported.
</p>


<h3>Value</h3>

<p>Either a raw or character vector giving the contents of the file.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>References</h3>

<p>libcurl <a href="https://curl.se/">https://curl.se/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+curlPerform">curlPerform</a></code>
<code><a href="#topic+getCurlOptionsConstants">getCurlOptionsConstants</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   x = scp("eeyore.ucdavis.edu", "/home/duncan/OmegaWeb/index.html",
           "My.SCP.Passphrase", binary = FALSE)
   x = scp("eeyore.ucdavis.edu", "/home/duncan/OmegaWeb/RCurl/xmlParse.bz2",
           "My.SCP.Passphrase")
   o = memDecompress(x, asChar = TRUE)

## End(Not run)</code></pre>

<hr>
<h2 id='url.exists'>Check if URL exists</h2><span id='topic+url.exists'></span>

<h3>Description</h3>

<p>This functions is analogous to <code><a href="base.html#topic+file.exists">file.exists</a></code>
and determines whether a request for a specific URL responds
without error. We make the request but ask the server
not to return the body. We just process the header.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>url.exists(url, ..., .opts = list(...),
            curl = getCurlHandle(.opts = .opts),
             .header = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="url.exists_+3A_url">url</code></td>
<td>
<p>a vector of one or more URLs whose existence we are to test</p>
</td></tr>
<tr><td><code id="url.exists_+3A_...">...</code></td>
<td>
<p>name = value pairs of Curl options.</p>
</td></tr>
<tr><td><code id="url.exists_+3A_.opts">.opts</code></td>
<td>
<p>a list of name = value pairs of Curl options.</p>
</td></tr>
<tr><td><code id="url.exists_+3A_curl">curl</code></td>
<td>
<p>a Curl handle that the caller can specify if she wants to
reuse an existing handle, e.g. with different options already
specified or that has previously established a connection to the Web
server</p>
</td></tr>
<tr><td><code id="url.exists_+3A_.header">.header</code></td>
<td>
<p>a logical value that if <code>TRUE</code> causes the header
information to be returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This makes an HTTP request but with the nobody option set to
<code>FALSE</code> so that we don't actually retrieve the contents of the URL.
</p>


<h3>Value</h3>

<p>If <code>.header</code> is <code>FALSE</code>, this returns
<code>TRUE</code> or <code>FALSE</code> for each URL indicating whether
the request was successful (had a status with a value
in the 200 range).
</p>
<p>If <code>.header</code> is <code>TRUE</code>, the header is returned for the
request for each URL.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>References</h3>

<p>HTTP specification
</p>


<h3>See Also</h3>

<p><code><a href="#topic+curlPerform">curlPerform</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> url.exists("https://www.omegahat.net/RCurl")
 try(url.exists("https://www.omegahat.net/RCurl-xxx"))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
