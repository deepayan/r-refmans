<!DOCTYPE html><html><head><title>Help for package mRMRe</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mRMRe}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjacencyMatrix'>
<p>Accessor function for the 'adjacencyMatrix' information in a mRMRe.Network object.</p>
</p></a></li>
<li><a href='#causality'>
<p>Accessor function for the 'causality' information in a mRMRe.Filter and mRMRe.Network object.</p></a></li>
<li><a href='#cgps'><p>Part of the large pharmacogenomic dataset published by Garnett et al. within the Cancer Genome Project (CGP)</p></a></li>
<li><a href='#correlate'>
<p>Function to compute various correlation measures between two variables</p></a></li>
<li><a href='#export_concordance_index'>
<p>Export concordance index</p></a></li>
<li><a href='#export_filters'>
<p>Export filters</p></a></li>
<li><a href='#export_filters_bootstrap'>
<p>Export filters bootstrap</p></a></li>
<li><a href='#export_mim'>
<p>Export mim</p></a></li>
<li><a href='#featureCount'>
<p>Accessor function for the 'featureCount' information in a mRMRe.Data, mRMRe.Filter and mRMRe.Network object.</p></a></li>
<li><a href='#featureData'>
<p>Accessor function for the 'featureData' information in a mRMRe.Data object</p></a></li>
<li><a href='#featureNames'>
<p>Accessor function for the 'featureNames' information in a mRMRe.Data, mRMRe.Filter and mRMRe.Network object</p></a></li>
<li><a href='#get_thread_count'>
<p>openMP Thread Count</p></a></li>
<li><a href='#get.thread.count'>
<p>openMP Thread Count</p></a></li>
<li><a href='#mim'>
<p>Accessor function for the 'mim' information in a mRMRe.Data, mRMRe.Filter and mRMRe.Network object</p></a></li>
<li><a href='#mRMRe.Data-class'><p>Class <code>"mRMRe.Data"</code></p></a></li>
<li><a href='#mRMRe.Filter-class'><p>Class <code>"mRMRe.Filter"</code></p></a></li>
<li><a href='#mRMRe.Network-class'><p>Class <code>"mRMRe.Network"</code></p></a></li>
<li><a href='#priors'>
<p>Accessor function for the 'priors' information in a mRMRe.Data object</p></a></li>
<li><a href='#sampleCount'>
<p>Accessor function for the 'sampleCount' information in a mRMRe.Data, mRMRe.Filter and mRMRe.Network object.</p></a></li>
<li><a href='#sampleNames'>
<p>Accessor function for the 'sampleNames' information in a mRMRe.Data, mRMRe.Filter and mRMRe.Network object.</p></a></li>
<li><a href='#sampleStrata'>
<p>Accessor function for the 'sampleStrata' information in a mRMRe.Data object</p></a></li>
<li><a href='#sampleWeights'>
<p>Accessor function for the 'sampleWeights' information in a mRMRe.Data object</p></a></li>
<li><a href='#scores'>
<p>mRMR Scores as per the MI gain for each feature</p></a></li>
<li><a href='#set_thread_count'>
<p>openMP Thread Count</p></a></li>
<li><a href='#set.thread.count'>
<p>openMP Thread Count</p></a></li>
<li><a href='#solutions'>
<p>Basic result of the mRMR procedure</p></a></li>
<li><a href='#subsetData'>
<p>Returns a mRMRe.Data object using a subset of the current mRMRe.Data object.</p></a></li>
<li><a href='#target'>
<p>mRMR Target(s)</p></a></li>
<li><a href='#visualize'>
<p>mRMRe Network display</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Parallelized Minimum Redundancy, Maximum Relevance (mRMR)</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-09-03</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes mutual information matrices from continuous, categorical 
  and survival variables, as well as feature selection with minimum redundancy, 
  maximum relevance (mRMR) and a new ensemble mRMR technique. Published in
  De Jay et al. (2013) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtt383">doi:10.1093/bioinformatics/btt383</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/Artistic-2.0">Artistic-2.0</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), survival, igraph, methods</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.pmgenomics.ca/bhklab/">https://www.pmgenomics.ca/bhklab/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-25 05:52:17 UTC; hornik</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicolas De Jay [aut],
  Simon Papillon-Cavanagh [aut],
  Catharina Olsen [aut],
  Gianluca Bontempi [aut],
  Bo Li [aut],
  Christopher Eeles [ctb],
  Benjamin Haibe-Kains [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Benjamin Haibe-Kains &lt;benjamin.haibe.kains@utoronto.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-25 05:57:25 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjacencyMatrix'>
Accessor function for the 'adjacencyMatrix' information in a mRMRe.Network object.
</h2><span id='topic+adjacencyMatrix'></span><span id='topic+adjacencyMatrixSum'></span><span id='topic+adjacencyMatrix+2CmRMRe.Network-method'></span><span id='topic+adjacencyMatrixSum+2CmRMRe.Network-method'></span>

<h3>Description</h3>

<p>The adjency matrix is a directed matrix of 0's and 1's indicating if there is a link between features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mRMRe.Network'
adjacencyMatrix(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjacencyMatrix_+3A_object">object</code></td>
<td>
<p>a <code>mRMRe.Network</code> object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.thread.count(2)
data(cgps)
feature_data &lt;- mRMR.data(data =  data.frame(cgps.ge))

# Build an mRMR-based network and display adjacency matrix (topology)
network &lt;- new("mRMRe.Network", data = feature_data, target_indices = c(1, 2),
			levels = c(2, 1), layers = 1)
adjacencyMatrix(network)
</code></pre>

<hr>
<h2 id='causality'>
Accessor function for the 'causality' information in a mRMRe.Filter and mRMRe.Network object.
</h2><span id='topic+causality'></span><span id='topic+causality+2CmRMRe.Filter-method'></span><span id='topic+causality+2CmRMRe.Network-method'></span>

<h3>Description</h3>

<p>The causality data is compute using the co-information lattice algorithm on each V-structure (feature, target, feature).  Given that this procedure
is computed for each pair of features, the minimum result is kept. A negative score indicates putative causality of the feature to the target.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mRMRe.Filter'
causality(object)
## S4 method for signature 'mRMRe.Network'
causality(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="causality_+3A_object">object</code></td>
<td>
<p>a <code>mRMRe.Filter or mRMRe.Network</code> object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.thread.count(2)
data(cgps)
feature_data &lt;- mRMR.data(data =  data.frame(cgps.ge))
filter &lt;- mRMR.classic("mRMRe.Filter", data = feature_data, target_indices = 3:5,
						feature_count = 2)
causality(filter)
</code></pre>

<hr>
<h2 id='cgps'>Part of the large pharmacogenomic dataset published by Garnett et al. within the Cancer Genome Project (CGP)</h2><span id='topic+cgps.annot'></span><span id='topic+cgps.ge'></span><span id='topic+cgps.ic50'></span>

<h3>Description</h3>

<p>This dataset contains gene expression of 200 cancer cell lines for which sensitivity (IC50) to Camptothecin was measured (release 2).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cgps)</code></pre>


<h3>Format</h3>

<p>The <code><a href="#topic+cgps">cgps</a></code> dataset is composed of three objects
</p>

<dl>
<dt>cgps.annot</dt><dd><p>Dataframe containing gene annotations</p>
</dd>
<dt>cgps.ge</dt><dd><p>Matrix containing expressions of 1000 genes; cell lines in rows, genes in columns</p>
</dd>
<dt>cgps.ic50</dt><dd><p>Drug sensitivity measurements (IC50) for Camptothecin</p>
</dd>
</dl>



<h3>Details</h3>

<p>Camptothecin is a drug mainly used in colorectal cancer.</p>


<h3>Source</h3>

<p>http://www.ebi.ac.uk/arrayexpress/experiments/E-MTAB-783
</p>
<p>http://www.nature.com/nature/journal/v483/n7391/extref/nature11005-s2.zip
</p>


<h3>References</h3>

<p>Garnett MJ et al. &quot;Systematic identification of genomic markers of drug sensitivity in cancer cells&quot;, <em>Nature</em>, <b>483</b>:570-575, 2012.</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.thread.count(2)
data(cgps)

message("Gene expression data:")
print(cgps.ge[1:3, 1:3])

message("Gene annotations:")
print(head(cgps.annot))

message("Drug sensitivity (IC50) values:")
print(head(cgps.ic50))
</code></pre>

<hr>
<h2 id='correlate'>
Function to compute various correlation measures between two variables
</h2><span id='topic+correlate'></span>

<h3>Description</h3>

<p>Correlate is a function that cestimates correlation between two variables, which can be either continuous, categorical (ordered factor) or censored (survival data).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlate(X, Y, method = c("pearson", "spearman", "kendall", "frequency", "cramersv",
		"cindex"),strata, weights, outX = TRUE, bootstrap_count = 0, alpha = 0.05,
 		alternative = c("two.sided", "less", "greater"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlate_+3A_x">X</code></td>
<td>
<p>Vector of type numeric, ordered factor, or Surv.</p>
</td></tr>
<tr><td><code id="correlate_+3A_y">Y</code></td>
<td>
<p>Vector of type numeric, ordered factor, or Surv of same length as <code>X</code>.</p>
</td></tr>
<tr><td><code id="correlate_+3A_method">method</code></td>
<td>
<p>One of the following values: pearson, spearman, kendall, frequency, cramersv, or cindex.</p>
</td></tr>
<tr><td><code id="correlate_+3A_strata">strata</code></td>
<td>
<p>Vector of type factor corresponding to the sample strata.</p>
</td></tr>
<tr><td><code id="correlate_+3A_weights">weights</code></td>
<td>
<p>Vector of type numeric corresponding to the sample weights.</p>
</td></tr>
<tr><td><code id="correlate_+3A_outx">outX</code></td>
<td>
<p>For cindex, if set to <code>TRUE</code>, ignore ties; otherwise, take them into account when computing the concordance index.</p>
</td></tr>
<tr><td><code id="correlate_+3A_bootstrap_count">bootstrap_count</code></td>
<td>
<p>If set to <code>0</code>, analytical standard error for the correlation estimate in each strata is used to compute the meta-estimate (inverse-variance weighting avarega); otherwise a number of bootstraps are used to computes standard errors.</p>
</td></tr>
<tr><td><code id="correlate_+3A_alpha">alpha</code></td>
<td>
<p>The probability of Type I error that is, rejecting a null hypothesis when it is in fact true</p>
</td></tr>
<tr><td><code id="correlate_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis,must be one of two.sided (default), greater or less.  You can specify just the initial letter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>correlate</code> function could be used to measure correlation between any types of variables:
</p>

<dl>
<dt>numeric vs. numeric</dt><dd><p>Pearson, Spearman, Kendall or concordance index</p>
</dd>
<dt>numeric vs. ordered factor</dt><dd><p>concordance index (Somers' Dxy)</p>
</dd>
<dt>numeric vs. survival data</dt><dd><p>concordance index (Somers' Dxy)</p>
</dd>
<dt>ordered factor vs. ordered factor</dt><dd><p>Carmer's V</p>
</dd>
<dt>ordered factor vs. survival data</dt><dd><p>concordance index (Somers' Dxy)</p>
</dd>
<dt>survival data vs. survival data</dt><dd><p>concordance index (Somers' Dxy)</p>
</dd>
</dl>

<p>Part of the code underlying <code>correlate</code> is also used in <code>mim</code> method of the <code>mRMRe.Data</code> object because correlations are used to build the mutual information matrix in order for feature selection to take place. This is why these two functions have many argiuments in common.
</p>


<h3>Value</h3>

<table>
<tr><td><code>estimate</code></td>
<td>
<p>point estimate</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>standard error</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower confidence bound</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper confidence bound</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>p-value</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>sample size</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mRMRe.Data-class">mRMRe.Data-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.thread.count(2)

## load data
data(cgps)
   
## spearman correlation coefficent between the first gene and Camptothecin IC50
correlate(X=cgps.ge[ ,1], Y=cgps.ic50, method="spearman")
   
## concordance index between the first gene and Camptothecin IC50
correlate(X=cgps.ge[ ,1], Y=cgps.ic50, method="cindex")
</code></pre>

<hr>
<h2 id='export_concordance_index'>
Export concordance index
</h2><span id='topic+export_concordance_index'></span>

<h3>Description</h3>

<p>Export the concordance index
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_concordance_index_+3A_samplesa">samplesA</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_concordance_index_+3A_samplesb">samplesB</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_concordance_index_+3A_samplesc">samplesC</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_concordance_index_+3A_samplesd">samplesD</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_concordance_index_+3A_samplestrata">sampleStrata</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_concordance_index_+3A_sampleweights">sampleWeights</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_concordance_index_+3A_samplestratumcount">sampleStratumCount</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_concordance_index_+3A_outx">outX</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_concordance_index_+3A_ratio">ratio</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_concordance_index_+3A_concordantweights">concordantWeights</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_concordance_index_+3A_discordantweights">discordantWeights</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_concordance_index_+3A_uninformativeweights">uninformativeWeights</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_concordance_index_+3A_relevantweights">relevantWeights</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return. Modifies the <code>ratio</code> argument by reference.
</p>


<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>

<hr>
<h2 id='export_filters'>
Export filters
</h2><span id='topic+export_filters'></span>

<h3>Description</h3>

<p>Export the filters
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_filters_+3A_childrencountperlevel">childrenCountPerLevel</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_+3A_datamatrix">dataMatrix</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_+3A_priorsmatrix">priorsMatrix</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_+3A_priorsweight">priorsWeight</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_+3A_samplestrata">sampleStrata</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_+3A_sampleweights">sampleWeights</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_+3A_featuretypes">featureTypes</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_+3A_samplecount">sampleCount</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_+3A_featurecount">featureCount</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_+3A_samplestratumcount">sampleStratumCount</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_+3A_targetfeatureindices">targetFeatureIndices</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_+3A_continuousestimator">continuousEstimator</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_+3A_outx">outX</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_+3A_bootstrapcount">bootstrapCount</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_+3A_mimatrix">miMatrix</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Exhaustively computes the minimum redudancy maximim relevance features from
the mutual information matrix, returing a list of solutions where each item
is a numeric index of selected features.
</p>


<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>

<hr>
<h2 id='export_filters_bootstrap'>
Export filters bootstrap
</h2><span id='topic+export_filters_bootstrap'></span>

<h3>Description</h3>

<p>Export the filters
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_filters_bootstrap_+3A_solutioncount">solutionCount</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_bootstrap_+3A_solutionlength">solutionLength</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_bootstrap_+3A_datamatrix">dataMatrix</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_bootstrap_+3A_priorsmatrix">priorsMatrix</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_bootstrap_+3A_priorsweight">priorsWeight</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_bootstrap_+3A_samplestrata">sampleStrata</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_bootstrap_+3A_sampleweights">sampleWeights</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_bootstrap_+3A_featuretypes">featureTypes</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_bootstrap_+3A_samplecount">sampleCount</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_bootstrap_+3A_featurecount">featureCount</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_bootstrap_+3A_samplestratumcount">sampleStratumCount</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_bootstrap_+3A_targetfeatureindices">targetFeatureIndices</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_bootstrap_+3A_continuousestimator">continuousEstimator</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_bootstrap_+3A_outx">outX</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_bootstrap_+3A_bootstrapcount">bootstrapCount</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_filters_bootstrap_+3A_mimatrix">miMatrix</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Bootstraps and estimate of the minimum redundancy maximim relevance features
from the mutual information, returning a list where each item is a numeric
vector of selected feature indices.
</p>


<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>

<hr>
<h2 id='export_mim'>
Export mim
</h2><span id='topic+export_mim'></span>

<h3>Description</h3>

<p>Export mim
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_mim_+3A_datamatrix">dataMatrix</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_mim_+3A_priorsmatrix">priorsMatrix</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_mim_+3A_priorsweight">priorsWeight</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_mim_+3A_samplestrata">sampleStrata</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_mim_+3A_sampleweights">sampleWeights</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_mim_+3A_featuretypes">featureTypes</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_mim_+3A_samplecount">sampleCount</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_mim_+3A_featurecount">featureCount</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_mim_+3A_samplestratumcount">sampleStratumCount</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_mim_+3A_continuousestimator">continuousEstimator</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_mim_+3A_outx">outX</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_mim_+3A_bootstrapcount">bootstrapCount</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="export_mim_+3A_mimatrix">miMatrix</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the mutual information matrix.
</p>


<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>

<hr>
<h2 id='featureCount'>
Accessor function for the 'featureCount' information in a mRMRe.Data, mRMRe.Filter and mRMRe.Network object.
</h2><span id='topic+featureCount'></span><span id='topic+featureCount+2CmRMRe.Data-method'></span><span id='topic+featureCount+2CmRMRe.Filter-method'></span><span id='topic+featureCount+2CmRMRe.Network-method'></span>

<h3>Description</h3>

<p>The feature count is simply the total number of feature considered in the mRMRe procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mRMRe.Data'
featureCount(object)
## S4 method for signature 'mRMRe.Filter'
featureCount(object)
## S4 method for signature 'mRMRe.Network'
featureCount(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="featureCount_+3A_object">object</code></td>
<td>
<p>a <code>mRMRe.Data, mRMRe.Filter or mRMRe.Network</code> object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.thread.count(2)
data(cgps)
feature_data &lt;- mRMR.data(data =  data.frame(cgps.ge))
featureCount(feature_data)
filter &lt;- mRMR.classic("mRMRe.Filter", data = feature_data, target_indices = 3:5,
						feature_count = 2)
featureCount(filter)
</code></pre>

<hr>
<h2 id='featureData'>
Accessor function for the 'featureData' information in a mRMRe.Data object
</h2><span id='topic+featureData'></span><span id='topic+featureData+2CmRMRe.Data-method'></span>

<h3>Description</h3>

<p>the featureData consists of the numerical value of each feature for each sample considered
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mRMRe.Data'
featureData(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="featureData_+3A_object">object</code></td>
<td>
<p>a <code>mRMRe.Data</code> object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.thread.count(2)
data(cgps)
feature_data &lt;- mRMR.data(data =  data.frame(cgps.ge))
featureData(feature_data)
</code></pre>

<hr>
<h2 id='featureNames'>
Accessor function for the 'featureNames' information in a mRMRe.Data, mRMRe.Filter and mRMRe.Network object
</h2><span id='topic+featureNames'></span><span id='topic+featureNames+2CmRMRe.Filter-method'></span><span id='topic+featureNames+2CmRMRe.Network-method'></span><span id='topic+featureNames+2CmRMRe.Data-method'></span>

<h3>Description</h3>

<p>featureNames are the names of the features given as input to the mRMRe procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mRMRe.Data'
featureNames(object)
## S4 method for signature 'mRMRe.Filter'
featureNames(object)
## S4 method for signature 'mRMRe.Network'
featureNames(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="featureNames_+3A_object">object</code></td>
<td>
<p>a <code>mRMRe.Data, mRMRe.Filter or mRMRe.Network</code> object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.thread.count(2)
data(cgps)
feature_data &lt;- mRMR.data(data = data.frame(cgps.ge))
featureNames(feature_data)
filter &lt;- mRMR.classic("mRMRe.Filter", data = feature_data, target_indices = 3:5,
						feature_count = 2)
featureNames(filter)
</code></pre>

<hr>
<h2 id='get_thread_count'>
openMP Thread Count
</h2><span id='topic+get_thread_count'></span>

<h3>Description</h3>

<p>This methods allows you to get the number of cores currently accessible to openMP
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_thread_count_+3A_thread_count">thread_count</code></td>
<td>
<p>number of OPENMP threads to be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return the current number of cores accessible to openMP for C level parallelization
</p>


<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>

<hr>
<h2 id='get.thread.count'>
openMP Thread Count
</h2><span id='topic+get.thread.count'></span>

<h3>Description</h3>

<p>This methods allows you to retrieve the number of cores currently accessible to openMP</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.thread.count()
</code></pre>


<h3>Value</h3>

<p>Return the number of cores accessible to openMP for C level parallelization.
</p>


<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get.thread.count() </code></pre>

<hr>
<h2 id='mim'>
Accessor function for the 'mim' information in a mRMRe.Data, mRMRe.Filter and mRMRe.Network object
</h2><span id='topic+mim'></span><span id='topic+mim+2CmRMRe.Data-method'></span><span id='topic+mim+2CmRMRe.Network-method'></span><span id='topic+mim+2CmRMRe.Filter-method'></span>

<h3>Description</h3>

<p>In both mRMRe.Filter and mRMRe.Network objects, a sparse mutual information matrix is computed for the mRMRe procedure and this lazy-evaluated matrix is returned.
In the context of a a mRMRe.Data 'mim', the full pairwise mutual information matrix is computed and returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mRMRe.Data'
mim(object, prior_weight, continuous_estimator, outX, bootstrap_count)
## S4 method for signature 'mRMRe.Filter'
mim(object, method)
## S4 method for signature 'mRMRe.Network'
mim(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mim_+3A_object">object</code></td>
<td>
<p>a <code>mRMRe.Data, mRMRe.Filter or mRMRe.Network</code> object.</p>
</td></tr>
<tr><td><code id="mim_+3A_prior_weight">prior_weight</code></td>
<td>
<p>a numeric value [0,1] of indicating the impact of priors (mRMRe.Data only).</p>
</td></tr>
<tr><td><code id="mim_+3A_continuous_estimator">continuous_estimator</code></td>
<td>
<p>an estimator of the mutual information between features: either &quot;pearson&quot;, &quot;spearman&quot;, &quot;kendall&quot;, &quot;frequency&quot; (mRMRe.Data only).</p>
</td></tr>
<tr><td><code id="mim_+3A_outx">outX</code></td>
<td>
<p>a boolean used in the concordance index estimator to keep or throw out ties (mRMRe.Data only).</p>
</td></tr>
<tr><td><code id="mim_+3A_bootstrap_count">bootstrap_count</code></td>
<td>
<p>an integer indicating the number of bootstrap resampling used in estimation (mRMRe.Data only). </p>
</td></tr>
<tr><td><code id="mim_+3A_method">method</code></td>
<td>
<p>either &quot;mi&quot; or &quot;cor&quot;; the latter will return the correlation coefficients (rho) while the former will return the mutual information (-0.5 * log(1 - (rho^2))). </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.thread.count(2)
data(cgps)
feature_data &lt;- mRMR.data(data =  data.frame(cgps.ge))

# Calculate the pairwise mutual information matrix
mim(feature_data)
filter &lt;- mRMR.classic("mRMRe.Filter", data = feature_data, target_indices = 3:5,
						feature_count = 2)

# Obtain the sparse (lazy-evaluated) mutual information matrix.
mim(filter)
</code></pre>

<hr>
<h2 id='mRMRe.Data-class'>Class <code>"mRMRe.Data"</code></h2><span id='topic+mRMRe.Data-class'></span><span id='topic+mRMR.data'></span>

<h3>Description</h3>

<p><code>mRMRe.Data</code> is the class containing datasets.  Most if not all of the routines in the mRMRe package use <code>mRMRe.Data</code> objects as primary input.
</p>
<p>Such an object is instantiated with a data frame containing the sample sets and optionally, stratum, weight vectors and a prior matrix.  In addition to basic accession functions, we describe several methods which serve to manipulate the contents of the dataset.
</p>
<p>Note that <code>mRMR.data</code> function is a wrapper to easily create <code>mRMRe.Data</code> objects.
</p>



<h3>Instantiation</h3>

<p>Objects are created via calls of the form <code>new("mRMRe.Data", data, strata, weights, priors)</code>.
</p>
<p><code>data</code>: is expected to be a data frame with samples and features respectively organized as rows and columns.  The columns
have to be of type :numeric, ordered factor, Surv and respectively interpreted as :continuous, discrete and survival variables.
</p>
<p><code>strata</code>: is expected to be a vector of type :ordered factor with the strata associated to the samples provided
in <code>data</code>.
</p>
<p><code>weights</code>: is expected to be a vector of type :numeric with the weights associated to the samples provided
in <code>data</code>.
</p>
<p><code>priors</code>: is expected to be a matrix of type :numeric where <code>priors[i, j]</code>: denotes an forced association between
features i and j in <code>data</code>.  The latter takes into consideration the directionality of the relationship and must be a value
between 0 and 1.
</p>


<h3>Mutual Information Matrix</h3>

<p>The <code>mim</code> method computes and returns a mutual information matrix.  A correlation between continuous features is estimated
using an estimator specified in <code>continuous_estimator</code>; currently, :pearson, spearman, kendall, frequency are supported.
The estimator for discrete features is Cramer's V and for all other combinations, concordance index.
</p>
<p>When <code>outX</code> is set to <code>TRUE</code>, ties are ignored when computing the concordance index and otherwise, these are considered.
The correlations are first computed per strata and these are then combined by the inverse variance weight mean of the estimates
using a <code>bootstrap_count</code> number of bootstraps if the former parameter is greater than 0, and by the relative weights of each
strata otherwise.  The resulting correlation is then summated with the corresponding value in the priors matrix with the
latter being weighed for a proportion <code>prior_weight</code> of a final, biased correlation.
</p>


<h3>Slots</h3>


<dl>
<dt><code>sample_names</code>:</dt><dd><p>Object of class <code>"character"</code> containing the sample names.</p>
</dd>
<dt><code>feature_names</code>:</dt><dd><p>Object of class <code>"character"</code> containing the feature names.</p>
</dd>
<dt><code>feature_types</code>:</dt><dd><p>Object of class <code>"numeric"</code> containing the internal representation of features/variables: <code>1</code> for numeric, <code>2</code> for ordered factor, and <code>3</code> for survival data</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"matrix"</code> containing the internal representation of the data set.</p>
</dd>
<dt><code>strata</code>:</dt><dd><p>Object of class <code>"numeric"</code> containing the feature strata.</p>
</dd>
<dt><code>weights</code>:</dt><dd><p>Object of class <code>"numeric"</code> containing sample weights.</p>
</dd>
<dt><code>priors</code>:</dt><dd><p>Object of class <code>"matrix"</code> containing the priors.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>featureCount</dt><dd><p><code>signature(object = "mRMRe.Data")</code>: Returns the number of features.</p>
</dd>
<dt>featureData</dt><dd><p><code>signature(object = "mRMRe.Data")</code>: Returns a data frame corresponding to the data set.</p>
</dd>
<dt>featureNames</dt><dd><p><code>signature(object = "mRMRe.Data")</code>: Returns a vector containing the feature names.</p>
</dd>
<dt>mim</dt><dd><p><code>signature(object = "mRMRe.Data", prior_weight = 0,
    continuous_estimator = c("pearson", "spearman", "kendall", "frequency"),
    outX = TRUE, bootstrap_count = 0)</code>: Computes and returns the mutual information matrix.</p>
</dd>
<dt>priors</dt><dd><p><code>signature(object = "mRMRe.Data")</code>: Returns a matrix containing the priors.</p>
</dd>
<dt>priors&lt;-</dt><dd><p><code>signature(object = "mRMRe.Data", value)</code>: Sets the prior matrix.</p>
</dd>
<dt>sampleCount</dt><dd><p><code>signature(object = "mRMRe.Data")</code>: Returns the number of samples.</p>
</dd>
<dt>sampleNames</dt><dd><p><code>signature(object = "mRMRe.Data")</code>: Returns a vector containing sample names.</p>
</dd>
<dt>sampleStrata</dt><dd><p><code>signature(object = "mRMRe.Data")</code>: Returns a vector containing sample strata.</p>
</dd>
<dt>sampleStrata&lt;-</dt><dd><p><code>signature(object = "mRMRe.Data", value)</code>: Sets the sample strata.</p>
</dd>
<dt>sampleWeights</dt><dd><p><code>signature(object = "mRMRe.Data")</code>: Returns a vector containing sample weights.</p>
</dd>
<dt>sampleWeights&lt;-</dt><dd><p><code>signature(object = "mRMRe.Data")</code>: Sets the sample weights.</p>
</dd>
<dt>subsetData</dt><dd><p><code>signature(object = "mRMRe.Data", row_indices, column_indices)</code>: Returns another data object containing only the specified samples and features (rows and columns, respectively.)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mRMRe.Filter-class">mRMRe.Filter-class</a></code>, <code><a href="#topic+mRMRe.Network-class">mRMRe.Network-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("mRMRe.Data")

set.thread.count(2)

## load data
data(cgps)

## equivalent ways of building an mRMRe.Data object
ge &lt;- mRMR.data(data = data.frame(cgps.ge[ , 1:10, drop=FALSE]))
ge &lt;- new("mRMRe.Data", data = data.frame(cgps.ge[ , 1:10, drop=FALSE]))

## print data
print(featureData(ge)[1:3, 1:3])

## print feature names
print(featureNames(ge))

## print the first sample names
print(head(sampleNames(ge)))

## print the first sample weights
print(head(sampleWeights(ge)))
</code></pre>

<hr>
<h2 id='mRMRe.Filter-class'>Class <code>"mRMRe.Filter"</code></h2><span id='topic+mRMRe.Filter-class'></span><span id='topic+mRMR.ensemble'></span><span id='topic+mRMR.classic'></span>

<h3>Description</h3>

<p>mRMRe.Filter is a wrapper for various variants of the maximum relevance minimum redundancy (mRMR) feature selection/filter.
</p>
<p>Note that <code>mRMR.classic</code> and <code>mRMR.ensemble</code> functions are wrappers to easily perform classical (single) and ensemble mRMR feature selection.
</p>


<h3>Instantiation</h3>

<p>Objects are created via calls of the form <code>new("mRMRe.Filter", data, prior_weight,
	target_indices,	levels,	method, continuous_estimator, outX, bootstrap_count)</code>.
</p>
<p><code>data</code>: is expected to be a <code>mRMRe.Data</code> object.
</p>
<p><code>target_indices</code>: is expected to be a vector of type <code>integer</code> containing the indices of the features
that will serve as targets for the feature selections.
</p>
<p><code>levels</code>: is expected to be a vector of type <code>integer</code> containing the number of children of each element
at each level of the resulting filter tree.
</p>
<p><code>method</code>: is expected to be either <code>exhaustive</code> or <code>bootstrap</code>.  The former uses the whole dataset to pick siblings in the tree according
to the mRMR metric, while the latter perform the classical mRMR feature selection on several bootrstap selections of the dataset.
</p>
<p><code>continuous_estimator</code>: it specifies the estimators for correlation between two continuous variables; value is either <code>pearson</code>, <code>spearman</code>, <code>kendall</code>, <code>frequency</code>, 
</p>
<p><code>outX</code>: set to <code>TRUE</code> (default value) to not count pairs of 
observations tied on <code>x</code> as a relevant pair. This results in a 
Goodman-Kruskal gamma type rank correlation.
</p>
<p><code>bootstrap_count</code>: Number of bootstraps to statistically compare
the mRMR scores of each solution.
</p>
<p>Since a mutual information matrix must be computed in order for feature selection to take place, the remaining arguments
are identical to those required by the <code>mim</code> method of the <code>mRMRe.Data</code> object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>filters</code>:</dt><dd><p>Object of class <code>"list"</code> containing for each target a solutions matrix.</p>
</dd>
<dt><code>mi_matrix</code>:</dt><dd><p>Object of class <code>"matrix"</code> containing the combined mutual information matrix of the relevant targets.</p>
</dd>
<dt><code>causality_list</code>:</dt><dd><p>Object of class <code>"list"</code> containing for each target a vector of causality coefficients between the target and its predictors.</p>
</dd>
<dt><code>sample_names</code>:</dt><dd><p>Object of class <code>"character"</code> containing the sample names.</p>
</dd>
<dt><code>feature_names</code>:</dt><dd><p>Object of class <code>"character"</code> containing the feature names.</p>
</dd>
<dt><code>target_indices</code>:</dt><dd><p>Object of class <code>"integer"</code> containing the target indices.</p>
</dd>
<dt><code>fixed_feature_count</code>:</dt><dd><p>Object of class <code>"integer"</code> containing the number of fixed features.</p>
</dd>
<dt><code>levels</code>:</dt><dd><p>Object of class <code>"integer"</code> containing the desired topology of the tree.</p>
</dd>
<dt><code>scores</code>:</dt><dd><p>Object of class <code>"list"</code> containing the mRMR score of selected features, respective to filters.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>causality</dt><dd><p><code>signature(object = "mRMRe.Filter")</code>: ... </p>
</dd>
<dt>featureCount</dt><dd><p><code>signature(object = "mRMRe.Filter")</code>: Returns the number of features.</p>
</dd>
<dt>featureNames</dt><dd><p><code>signature(object = "mRMRe.Filter")</code>: Returns a vector containing the feature names.</p>
</dd>
<dt>mim</dt><dd><p><code>signature(object = "mRMRe.Filter")</code>: Returns the potentially partial mutual information matrix used for feature selection.</p>
</dd>
<dt>sampleCount</dt><dd><p><code>signature(object = "mRMRe.Filter")</code>: Returns the number of samples.</p>
</dd>
<dt>sampleNames</dt><dd><p><code>signature(object = "mRMRe.Filter")</code>: Returns a vector containing sample names.</p>
</dd>
<dt>solutions</dt><dd><p><code>signature(object = "mRMRe.Filter", mi_threshold = -Inf,
    						causality_threshold = Inf)</code>:
Returns a matrix in which each column represents a different solution (path from root of the tree to a leaf.)
</p>
</dd>
<dt>target</dt><dd><p><code>signature(object = "mRMRe.Filter")</code>: Returns a vector containing the target indices.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>


<h3>References</h3>

<p>Ding, C. and Peng, H. (2005). &quot;Minimum redundancy feature selection from microarray gene expression data&quot;. <em>Journal of bioinformatics and computational biology</em>, <b>3</b>(2):185&ndash;205.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mRMRe.Data-class">mRMRe.Data-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("mRMRe.Filter")

set.thread.count(2)

## load data
data(cgps)

## build an mRMRe.Data object
ge &lt;- mRMR.data(data = data.frame(cgps.ge[ , 1:100, drop=FALSE]))

## perform a classic (single) mRMR to select the 10 genes the most correlated with 
## the first gene but the less correlated between each other
exect &lt;- system.time(fs &lt;- new("mRMRe.Filter", data = ge, target_indices = 1,
					levels = c(8, 1, 1, 1, 1)))
print(exect)

## print the index of the selected features for each distinct mRMR solutions
print(solutions(fs)[[1]])

## print the names of the selected features for each distinct mRMR solutions
print(apply(solutions(fs)[[1]], 2, function(x, y) { return(y[x]) }, y=featureNames(ge)))
</code></pre>

<hr>
<h2 id='mRMRe.Network-class'>Class <code>"mRMRe.Network"</code></h2><span id='topic+mRMRe.Network-class'></span><span id='topic+mRMR.network'></span>

<h3>Description</h3>

<p>mRMRe.Network is a wrapper for inferring a network of features based on mRMR feature selection.
</p>



<h3>Instantiation</h3>

<p>Objects are created via calls of the form <code>new("mRMRe.Network", data, prior_weight,
	target_indices, levels, layers, ..., mi_threshold, causality_threshold)</code>.
</p>
<p><code>layers</code>: is expected to be an <code>integer</code> specifying the number of layers of network inference desired.  When multiple
layers are desired, the elements of the solutions found in the last step of feature selection are used as the targets of the next
step.
</p>
<p>Since networking involves filter processing, the remaining arguments are identical to those required by <code>solutions</code> method of
the <code>mRMRe.Filter</code> object and <code>mim</code> method of the <code>mRMRe.Data</code> object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>topologies</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>mi_matrix</code>:</dt><dd><p>Object of class <code>"matrix"</code> containing the combined mutual information matrix of the network elements.</p>
</dd>
<dt><code>causality_list</code>:</dt><dd><p>Object of class <code>"list"</code> containing for each target a vector of causality coefficients between the target and its predictors.</p>
</dd>
<dt><code>sample_names</code>:</dt><dd><p>Object of class <code>"character"</code> containing the sample names.</p>
</dd>
<dt><code>feature_names</code>:</dt><dd><p>Object of class <code>"character"</code> containing the feature names.</p>
</dd>
<dt><code>target_indices</code>:</dt><dd><p>Object of class <code>"integer"</code> containing the target indices.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>adjacencyMatrix</dt><dd><p><code>signature(object = "mRMRe.Network")</code>: Returns a matrix describing the topology of the network.</p>
</dd>
<dt>adjacencyMatrixSum</dt><dd><p><code>signature(object = "mRMRe.Network")</code>: ... </p>
</dd>
<dt>causality</dt><dd><p><code>signature(object = "mRMRe.Network")</code>: Returns a list containing vectors containing causality coefficients between targets and predictors.</p>
</dd>
<dt>featureNames</dt><dd><p><code>signature(object = "mRMRe.Network")</code>: Returns a vector containing the feature names.</p>
</dd>
<dt>mim</dt><dd><p><code>signature(object = "mRMRe.Network")</code>: ... </p>
</dd>
<dt>sampleNames</dt><dd><p><code>signature(object = "mRMRe.Network")</code>: Returns a vector containing sample names.</p>
</dd>
<dt>solutions</dt><dd><p><code>signature(object = "mRMRe.Network")</code>: ... </p>
</dd>
<dt>visualize</dt><dd><p><code>signature(object = "mRMRe.Network")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mRMRe.Filter-class">mRMRe.Filter-class</a></code>, <code><a href="#topic+mRMRe.Data-class">mRMRe.Data-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("mRMRe.Network")

set.thread.count(2)

## load data
data(cgps)

## build an mRMRe.Data object
ge &lt;- mRMR.data(data = data.frame(cgps.ge[ , 1:100, drop=FALSE]))

## build a network object with the 10 first genes and their children,
## 8 distinct mRMR feature selections of 5 genes for each gene
exect &lt;- system.time(netw &lt;- new("mRMRe.Network", data = ge, target_indices = 1:10,
		levels = c(8, 1, 1, 1, 1), layers = 2))
print(exect)

## plot network using igraph
## Not run: visualize(netw)

</code></pre>

<hr>
<h2 id='priors'>
Accessor function for the 'priors' information in a mRMRe.Data object
</h2><span id='topic+priors'></span><span id='topic+priors+3C-'></span><span id='topic+priors+2CmRMRe.Data-method'></span><span id='topic+priors+3C-+2CmRMRe.Data-method'></span>

<h3>Description</h3>

<p>The priors matrix consists of a prior bias to be used in computation to mutual information between features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mRMRe.Data'
priors(object)
## S4 replacement method for signature 'mRMRe.Data'
priors(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="priors_+3A_object">object</code></td>
<td>
<p>a <code>mRMRe.Data</code> object.</p>
</td></tr>
<tr><td><code id="priors_+3A_value">value</code></td>
<td>
<p>a numeric matrix containing values from 0 to 1 (or NA), one per pairwise feature bias.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.thread.count(2)
data(cgps)
feature_data &lt;- mRMR.data(data = data.frame(cgps.ge))
priors(feature_data)
</code></pre>

<hr>
<h2 id='sampleCount'>
Accessor function for the 'sampleCount' information in a mRMRe.Data, mRMRe.Filter and mRMRe.Network object.
</h2><span id='topic+sampleCount'></span><span id='topic+sampleCount+2CmRMRe.Data-method'></span><span id='topic+sampleCount+2CmRMRe.Filter-method'></span><span id='topic+sampleCount+2CmRMRe.Network-method'></span>

<h3>Description</h3>

<p>The feature count is simply the total number of samples considered in the mRMRe procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mRMRe.Data'
sampleCount(object)
## S4 method for signature 'mRMRe.Filter'
sampleCount(object)
## S4 method for signature 'mRMRe.Network'
sampleCount(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleCount_+3A_object">object</code></td>
<td>
<p>a <code>mRMRe.Data, mRMRe.Filter or mRMRe.Network</code> object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.thread.count(2)
data(cgps)
feature_data &lt;- mRMR.data(data = data.frame(cgps.ge))
sampleCount(feature_data)
filter &lt;- mRMR.classic("mRMRe.Filter", data = feature_data, target_indices = 3:5,
						feature_count = 2)
sampleCount(filter)
</code></pre>

<hr>
<h2 id='sampleNames'>
Accessor function for the 'sampleNames' information in a mRMRe.Data, mRMRe.Filter and mRMRe.Network object.
</h2><span id='topic+sampleNames'></span><span id='topic+sampleNames+2CmRMRe.Filter-method'></span><span id='topic+sampleNames+2CmRMRe.Network-method'></span><span id='topic+sampleNames+2CmRMRe.Data-method'></span>

<h3>Description</h3>

<p>sampleNames are the names of the samples given as input to the mRMRe procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mRMRe.Data'
sampleNames(object)
## S4 method for signature 'mRMRe.Filter'
sampleNames(object)
## S4 method for signature 'mRMRe.Network'
sampleNames(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleNames_+3A_object">object</code></td>
<td>
<p>a <code>mRMRe.Data, mRMRe.Filter or mRMRe.Network</code> object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.thread.count(2)
data(cgps)
feature_data &lt;- mRMR.data(data = data.frame(cgps.ge))
sampleNames(feature_data)
filter &lt;- mRMR.classic("mRMRe.Filter", data = feature_data, target_indices = 3:5,
						feature_count = 2)
sampleNames(filter)
</code></pre>

<hr>
<h2 id='sampleStrata'>
Accessor function for the 'sampleStrata' information in a mRMRe.Data object
</h2><span id='topic+sampleStrata'></span><span id='topic+sampleStrata+3C-'></span><span id='topic+sampleStrata+2CmRMRe.Data-method'></span><span id='topic+sampleStrata+3C-+2CmRMRe.Data-method'></span>

<h3>Description</h3>

<p>The sampleStrata vector consists of a sampling stratification that will be used in computing mutual information
between features.  If known batch effects or sample stratification is present between samples, identify such subsets
using this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mRMRe.Data'
sampleStrata(object)
## S4 replacement method for signature 'mRMRe.Data'
sampleStrata(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleStrata_+3A_object">object</code></td>
<td>
<p>a <code>mRMRe.Data</code> object.</p>
</td></tr>
<tr><td><code id="sampleStrata_+3A_value">value</code></td>
<td>
<p>a factor vector identifying the stratification of samples.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.thread.count(2)
data(cgps)
feature_data &lt;- mRMR.data(data = data.frame(cgps.ge))

# No stratification (default)
sampleStrata(feature_data)

# Random stratification 
sampleStrata(feature_data) &lt;- as.factor(sample(c(0,1), 
  sampleCount(feature_data), replace=TRUE))
# Show result
sampleStrata(feature_data)
</code></pre>

<hr>
<h2 id='sampleWeights'>
Accessor function for the 'sampleWeights' information in a mRMRe.Data object
</h2><span id='topic+sampleWeights'></span><span id='topic+sampleWeights+3C-'></span><span id='topic+sampleWeights+2CmRMRe.Data-method'></span><span id='topic+sampleWeights+3C-+2CmRMRe.Data-method'></span>

<h3>Description</h3>

<p>TODO
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mRMRe.Data'
sampleWeights(object)
## S4 replacement method for signature 'mRMRe.Data'
sampleWeights(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleWeights_+3A_object">object</code></td>
<td>
<p>a <code>mRMRe.Data</code> object.</p>
</td></tr>
<tr><td><code id="sampleWeights_+3A_value">value</code></td>
<td>
<p>a numeric vector containing the biases of each sample in the mutual information computation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.thread.count(2)
data(cgps)
feature_data &lt;- mRMR.data(data = data.frame(cgps.ge))

# Uniform weight (default)
sampleWeights(feature_data)

# Random weighting  
sampleWeights(feature_data) &lt;- runif(sampleCount(feature_data))
# Show result
sampleWeights(feature_data)
</code></pre>

<hr>
<h2 id='scores'>
mRMR Scores as per the MI gain for each feature</h2><span id='topic+scores'></span><span id='topic+scores+2CmRMRe.Data-method'></span><span id='topic+scores+2CmRMRe.Filter-method'></span><span id='topic+scores+2CmRMRe.Network-method'></span>

<h3>Description</h3>

<p>The <code>scores</code> method returns the scores of individual features in respect to previously selected features as per standard
mRMR procedure.  For each target, the score of a feature is defined as the mutual information between the target and this feature
minus the average mutual information of previously selected features and this feature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mRMRe.Data'
scores(object, solutions)
## S4 method for signature 'mRMRe.Filter'
scores(object)
## S4 method for signature 'mRMRe.Network'
scores(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scores_+3A_object">object</code></td>
<td>
<p>a <code>mRMRe.Data, mRMRe.Filter or mRMRe.Network</code> object.</p>
</td></tr>
<tr><td><code id="scores_+3A_solutions">solutions</code></td>
<td>
<p>a set of solutions from mRMRe.Filter or mRMRe.Network to be used in computing the scores from a mRMRe.Data set.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.thread.count(2)
data(cgps)
feature_data &lt;- mRMR.data(data =  data.frame(cgps.ge))

# Create an mRMR filter and obtain the indices of selected features
filter &lt;- mRMR.classic("mRMRe.Filter", data = feature_data, target_indices = 3:5,
						feature_count = 2)
scores(filter)
</code></pre>

<hr>
<h2 id='set_thread_count'>
openMP Thread Count
</h2><span id='topic+set_thread_count'></span>

<h3>Description</h3>

<p>This methods allows you to set the number of cores currently accessible to openMP
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_thread_count_+3A_thread_count">thread_count</code></td>
<td>
<p>number of OPENMP threads to be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return, sets the number of cores available to openMP for C level parallelization.
</p>


<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>

<hr>
<h2 id='set.thread.count'>
openMP Thread Count</h2><span id='topic+set.thread.count'></span>

<h3>Description</h3>

<p>This methods allows you to set the number of cores currently accessible to openMP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.thread.count(thread_count)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.thread.count_+3A_thread_count">thread_count</code></td>
<td>
<p>number of OPENMP threads to be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return, sets the number of cores available to openMP for C level parallelization.
</p>


<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Access to number of available threads
threads &lt;- get.thread.count()
# Force a single threaded openMP job
set.thread.count(1)

# Revert back to all accessible threads
set.thread.count(threads)
</code></pre>

<hr>
<h2 id='solutions'>
Basic result of the mRMR procedure</h2><span id='topic+solutions'></span><span id='topic+solutions+2CmRMRe.Filter-method'></span><span id='topic+solutions+2CmRMRe.Network-method'></span>

<h3>Description</h3>

<p>The 'solutions' method allows one to access the set of selected features resulting of the mRMR algorithm.  More generally,
the set of feature are identified by their indices in the inputed feature set (1 being the first feature (column)).  At the
network level, 'solutions' consists of the topology of the network, identifying which features is connected to others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mRMRe.Filter'
solutions(object, mi_threshold, causality_threshold, with_fixed_features)
## S4 method for signature 'mRMRe.Network'
solutions(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solutions_+3A_object">object</code></td>
<td>
<p>a <code>mRMRe.Filter or mRMRe.Network</code> object.</p>
</td></tr>
<tr><td><code id="solutions_+3A_mi_threshold">mi_threshold</code></td>
<td>
<p>a numeric value used in filtering the features based on their mRMR scores,
features that do not pass the threshold will be set at NA.</p>
</td></tr>
<tr><td><code id="solutions_+3A_causality_threshold">causality_threshold</code></td>
<td>
<p>a numeric value used in filtering the features based on their causality scores,
features that do not pass the threshold will be set at NA</p>
</td></tr>
<tr><td><code id="solutions_+3A_with_fixed_features">with_fixed_features</code></td>
<td>
<p>a boolean indicating if fixed features are used in the computation, default TRUE</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.thread.count(2)
data(cgps)
feature_data &lt;- mRMR.data(data =  data.frame(cgps.ge))

# Create an mRMR filter and obtain the indices of selected features
filter &lt;- mRMR.classic("mRMRe.Filter", data = feature_data, target_indices = 3:5,
						feature_count = 2)
solutions(filter)

# Build an mRMR-based network and obtain feature connections (topology)
network &lt;- new("mRMRe.Network", data = feature_data, target_indices = c(1, 2),
			levels = c(2, 1), layers = 1)
solutions(network)
</code></pre>

<hr>
<h2 id='subsetData'>
Returns a mRMRe.Data object using a subset of the current mRMRe.Data object.
</h2><span id='topic+subsetData'></span><span id='topic+subsetData+2CmRMRe.Data-method'></span>

<h3>Description</h3>

<p>This method is used to extract a subset of the current mRMRe.Data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mRMRe.Data'
subsetData(object, row_indices, column_indices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsetData_+3A_object">object</code></td>
<td>
<p>a <code>mRMRe.Data</code> object.</p>
</td></tr>
<tr><td><code id="subsetData_+3A_row_indices">row_indices</code></td>
<td>
<p>An integer vector of the rows to be included in the subset.</p>
</td></tr>
<tr><td><code id="subsetData_+3A_column_indices">column_indices</code></td>
<td>
<p>An integer vector of the columns to be included in the subset.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.thread.count(2)
data(cgps)
feature_data &lt;- mRMR.data(data = data.frame(cgps.ge))
# Subset the same dimensions, equivalent to making a copy
feature_data_copy &lt;- subsetData(feature_data, 
    row_indices=sampleCount(feature_data),
		column_indices=featureCount(feature_data))

# Use only half of the samples
feature_data_samples &lt;- subsetData(feature_data, row_indices=sampleCount(feature_data)/2)

# Use only half of the features
feature_data_features &lt;- subsetData(feature_data,
    column_indices=featureCount(feature_data))
</code></pre>

<hr>
<h2 id='target'>
mRMR Target(s)
</h2><span id='topic+target'></span><span id='topic+target+2CmRMRe.Filter-method'></span><span id='topic+target+2CmRMRe.Network-method'></span>

<h3>Description</h3>

<p>The 'target' method allows you to access the target of a mRMR procedure.  In a mRMRe.Network setting, the target consists of the seed or
the starting set of features given in the network building.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mRMRe.Filter'
target(object)
## S4 method for signature 'mRMRe.Network'
target(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="target_+3A_object">object</code></td>
<td>
<p>a <code>mRMRe.Filter or mRMRe.Network</code> object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.thread.count(2)
data(cgps)
feature_data &lt;- mRMR.data(data =  data.frame(cgps.ge))

# Create an mRMR filter and obtain the targets of that filter
filter &lt;- mRMR.classic("mRMRe.Filter", data = feature_data, target_indices = 3:5,
						feature_count = 2)
target(filter)

# Build an mRMR-based network and obtain targets (seeds) of the network
network &lt;- new("mRMRe.Network", data = feature_data, target_indices = c(1, 2),
				levels = c(2, 1), layers = 1)
target(network)
</code></pre>

<hr>
<h2 id='visualize'>
mRMRe Network display</h2><span id='topic+visualize'></span><span id='topic+visualize+2CmRMRe.Network-method'></span>

<h3>Description</h3>

<p>The 'visualize' methods allows the visual display of an inferred mRMRe.Network topology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mRMRe.Network'
visualize(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visualize_+3A_object">object</code></td>
<td>
<p>a <code>mRMRe.Network</code> object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicolas De Jay, Simon Papillon-Cavanagh, Benjamin Haibe-Kains
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.thread.count(2)
data(cgps)
feature_data &lt;- mRMR.data(data =  data.frame(cgps.ge))

# Build an mRMR-based network and display it
network &lt;- new("mRMRe.Network", data = feature_data, target_indices = c(1),
				levels = c(3, 1), layers = 2)
visualize(network)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
