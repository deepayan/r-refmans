<!DOCTYPE html><html><head><title>Help for package shinyHugePlot</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {shinyHugePlot}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aggregator'><p>R6 base class for the aggregation</p></a></li>
<li><a href='#custom_func_aggregator'><p>Aggregation using a user-defined function.</p></a></li>
<li><a href='#custom_stat_aggregator'><p>Aggregation which returns arbitrary statistics</p></a></li>
<li><a href='#downsampler'><p>R6 class for down-sampling data</p></a></li>
<li><a href='#eLTTB_aggregator'><p>Aggregation using local minimum and maximum values,</p>
and Largest Triangle Three Buckets (LTTB) method.</a></li>
<li><a href='#list_aggregators'><p>Show the aggregation functions</p></a></li>
<li><a href='#LTTB_aggregator'><p>Aggregation using Largest Triangle Three Buckets (LTTB) method.</p></a></li>
<li><a href='#min_max_aggregator'><p>Aggregation using local minimum and maximum values.</p></a></li>
<li><a href='#min_max_ovlp_aggregator'><p>Aggregation using local minimum and maximum values</p>
of which small data ranges have 50% overlaps.</a></li>
<li><a href='#noise_fluct'><p>Time-series fluctuations in sound level</p></a></li>
<li><a href='#nth_pnt_aggregator'><p>Aggregation which returns every Nth point.</p></a></li>
<li><a href='#null_aggregator'><p>NULL aggregator.</p></a></li>
<li><a href='#plotly_build_light'><p>Build <code>plotly</code> data with low computation cost</p></a></li>
<li><a href='#plotly_datahandler'><p>R6 class for handling plotly data</p></a></li>
<li><a href='#range_stat_aggregator'><p>Aggregation which returns the ranges and nominal values</p>
within small data ranges</a></li>
<li><a href='#rng_aggregator'><p>Aggregation that returns ranges of the data.</p></a></li>
<li><a href='#shiny_hugeplot'><p>Wrapper for plotting large-sized data using <code>shinyHugePlot</code></p></a></li>
<li><a href='#shinyHugePlot'><p>shinyHugePlot</p></a></li>
<li><a href='#updatePlotlyH'><p>Function to call a method to update <code>plotly</code> traces</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Efficient Plotting of Large-Sized Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.6</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Junta Tagusari &lt;j.tagusari@eng.hokudai.ac.jp&gt;</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0), plotly (&ge; 4.10.0), shiny (&ge; 1.7.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6 (&ge; 2.5.1), dplyr (&ge; 1.0.9), tibble (&ge; 3.1.7), tidyr (&ge;
1.2.0), tidyselect (&ge; 1.1.2), data.table (&ge; 1.14.2), stringr
(&ge; 1.4.0), nanotime (&ge; 0.3.6), assertthat (&ge; 0.2.1), bit64
(&ge; 4.0.5), purrr (&ge; 0.3.4), jsonlite (&ge; 1.8.0), lazyeval (&ge;
0.2.2), shinyjs (&ge; 2.1.0), htmltools (&ge; 0.5.2), rlang (&ge;
1.0.5)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Description:</td>
<td>
    A tool to plot data with a large sample size using 'shiny' and 'plotly'.
    Relatively small samples are obtained from the original data using a specific algorithm.
    The samples are updated according to a user-defined x range.
    Jonas Van Der Donckt, Jeroen Van Der Donckt, Emiel Deprost (2022) <a href="https://github.com/predict-idlab/plotly-resampler">https://github.com/predict-idlab/plotly-resampler</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-18 05:41:05 UTC; jtagu</td>
</tr>
<tr>
<td>Author:</td>
<td>Junta Tagusari [aut, cre, cph],
  Jonas Van Der Donckt [cph],
  Jeroen Van Der Donckt [cph],
  Emiel Deprost [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-18 05:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aggregator'>R6 base class for the aggregation</h2><span id='topic+aggregator'></span>

<h3>Description</h3>

<p>A base class for the aggregation,
which defines the structure of the class and
is not available on a stand-alone basis.
</p>


<h3>Format</h3>

<p>An <code>R6::R6Class</code> object
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>parameters</code></dt><dd><p>Parameters for the aggregation, returned as a named list.
Generate a matrix using x and n_out
Apply function for nanotime</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-aggregator-new"><code>aggregator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-aggregator-aggregate"><code>aggregator$aggregate()</code></a>
</p>
</li>
<li> <p><a href="#method-aggregator-set_parameters"><code>aggregator$set_parameters()</code></a>
</p>
</li>
<li> <p><a href="#method-aggregator-clone"><code>aggregator$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-aggregator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor of <code>aggregator</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>aggregator$new(
  ...,
  interleave_gaps = FALSE,
  NA_position = "begin",
  coef_gap = 3,
  accepted_datatype = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Not used.</p>
</dd>
<dt><code>interleave_gaps, NA_position, coef_gap, accepted_datatype</code></dt><dd><p>Arguments passed to <code>self$set_parameters</code>, optional.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-aggregator-aggregate"></a>



<h4>Method <code>aggregate()</code></h4>

<p>Aggregates the given input and returns samples.
</p>


<h5>Usage</h5>

<div class="r"><pre>aggregator$aggregate(x, y, n_out)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x, y</code></dt><dd><p>Indexes and values that has to be aggregated.</p>
</dd>
<dt><code>n_out</code></dt><dd><p>Integer or numeric.
The number of samples that the aggregated data contains.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-aggregator-set_parameters"></a>



<h4>Method <code>set_parameters()</code></h4>

<p>Setting of the parameters for the aggregation
</p>


<h5>Usage</h5>

<div class="r"><pre>aggregator$set_parameters(
  ...,
  interleave_gaps,
  NA_position,
  coef_gap,
  accepted_datatype
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Not used.</p>
</dd>
<dt><code>interleave_gaps</code></dt><dd><p>Boolean, optional.
Whether <code>NA</code> values should be added
when there are gaps / irregularly sampled data.
Irregular gaps between samples are determined whether the gap is larger than
the median of the sample gaps times the coefficient for detecting irregular gaps.
By default, <code>FALSE</code>.</p>
</dd>
<dt><code>NA_position</code></dt><dd><p>Character, optional.
Indicates where <code>NA</code>s are placed when gaps are detected.
If <code>"end"</code>, the first point after a gap will be replaced.
If <code>"begin"</code>, the last point before a gap will be replaced.
If <code>"both"</code>, both the encompassing gap data points are replaced.
This parameter is only effective when <code>interleave_gaps == TRUE</code>.
By default, <code>"begin"</code>.</p>
</dd>
<dt><code>coef_gap</code></dt><dd><p>Numeric, optional.
The coefficient to detect irregular gaps.
By default, 3.0.</p>
</dd>
<dt><code>accepted_datatype</code></dt><dd><p>Character, optional.
This parameter indicates the supported data classes.
If all data classes are accepted, set it to <code>NULL</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-aggregator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>aggregator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='custom_func_aggregator'>Aggregation using a user-defined function.</h2><span id='topic+custom_func_aggregator'></span>

<h3>Description</h3>

<p>Arbitrary function can be applied using this aggregation class.
</p>


<h3>Format</h3>

<p>An <code>R6::R6Class</code> object
</p>


<h3>Super class</h3>

<p><code>shinyHugePlot::aggregator</code> -&gt; <code>custom_func_aggregator</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-custom_func_aggregator-new"><code>custom_func_aggregator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-custom_func_aggregator-set_aggregation_func"><code>custom_func_aggregator$set_aggregation_func()</code></a>
</p>
</li>
<li> <p><a href="#method-custom_func_aggregator-clone"><code>custom_func_aggregator$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="shinyHugePlot" data-topic="aggregator" data-id="aggregate"><a href='../../shinyHugePlot/html/aggregator.html#method-aggregator-aggregate'><code>shinyHugePlot::aggregator$aggregate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="shinyHugePlot" data-topic="aggregator" data-id="set_parameters"><a href='../../shinyHugePlot/html/aggregator.html#method-aggregator-set_parameters'><code>shinyHugePlot::aggregator$set_parameters()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-custom_func_aggregator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor of the Aggregator.
</p>


<h5>Usage</h5>

<div class="r"><pre>custom_func_aggregator$new(
  ...,
  aggregation_func,
  interleave_gaps,
  coef_gap,
  NA_position,
  accepted_datatype
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>aggregation_func</code></dt><dd><p>Function.
User-defined function to aggregate data,
of which arguments are <code>x</code>, <code>y</code> and <code>n_out</code>.</p>
</dd>
<dt><code>interleave_gaps, coef_gap, NA_position, accepted_datatype, ...</code></dt><dd><p>Arguments pass to the constructor of <code>aggregator</code> object.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-custom_func_aggregator-set_aggregation_func"></a>



<h4>Method <code>set_aggregation_func()</code></h4>

<p>Set a function to aggregate the data
</p>


<h5>Usage</h5>

<div class="r"><pre>custom_func_aggregator$set_aggregation_func(aggregation_func)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>aggregation_func</code></dt><dd><p>Function.
User-defined function to aggregate data,
of which arguments are <code>x</code>, <code>y</code> and <code>n_out</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-custom_func_aggregator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>custom_func_aggregator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>custom_agg_func &lt;- function(x, y, n_out) {
  bin_width &lt;- floor(length(x)/n_out)
  x_idx &lt;- seq(floor(bin_width / 2), bin_width * n_out, bin_width)
  y_mat &lt;- y[1:(bin_width * n_out)] %&gt;%
    matrix(nrow = bin_width)
  y_agg &lt;- apply(y_mat, 2, quantile, probs = 0.25)
  return(list(x = x[x_idx], y = y_agg))
}
data(noise_fluct)
agg &lt;- custom_func_aggregator$new(
  aggregation_func = custom_agg_func, interleave_gaps = TRUE
  )
d_agg &lt;- agg$aggregate(
  x = noise_fluct$time, y = noise_fluct$f500, n_out = 1000
  )
plotly::plot_ly(x = d_agg$x, y = d_agg$y, type = "scatter", mode = "lines")
</code></pre>

<hr>
<h2 id='custom_stat_aggregator'>Aggregation which returns arbitrary statistics</h2><span id='topic+custom_stat_aggregator'></span>

<h3>Description</h3>

<p>This aggregator divides the data into no-overlapping intervals
and calculate specific statistical values such as the mean.
</p>


<h3>Format</h3>

<p>An <code>R6::R6Class</code> object
</p>


<h3>Super class</h3>

<p><code>shinyHugePlot::aggregator</code> -&gt; <code>custom_stat_aggregator</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-custom_stat_aggregator-new"><code>custom_stat_aggregator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-custom_stat_aggregator-clone"><code>custom_stat_aggregator$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="shinyHugePlot" data-topic="aggregator" data-id="aggregate"><a href='../../shinyHugePlot/html/aggregator.html#method-aggregator-aggregate'><code>shinyHugePlot::aggregator$aggregate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="shinyHugePlot" data-topic="aggregator" data-id="set_parameters"><a href='../../shinyHugePlot/html/aggregator.html#method-aggregator-set_parameters'><code>shinyHugePlot::aggregator$set_parameters()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-custom_stat_aggregator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor of the Aggregator.
</p>
<p>Constructor of the Aggregator.
</p>


<h5>Usage</h5>

<div class="r"><pre>custom_stat_aggregator$new(
  ...,
  y_func = mean,
  x_mean = TRUE,
  interleave_gaps,
  coef_gap,
  NA_position,
  accepted_datatype
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>y_func</code></dt><dd><p>Function.
Statistical values are calculated using this function.
By default, <code>mean</code>.</p>
</dd>
<dt><code>x_mean</code></dt><dd><p>Boolean.
Whether using the mean values or not for the x values.
If not, the x values that give the specific y values are used.
E.g., if you use <code>max</code> as the <code>aggregation_func</code> and
set this argument to <code>FALSE</code>, x values that give the maximum
y values are used.
By default, <code>TRUE</code>.</p>
</dd>
<dt><code>interleave_gaps, coef_gap, NA_position, accepted_datatype, ...</code></dt><dd><p>Arguments pass to the constructor of <code>aggregator</code> object.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-custom_stat_aggregator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>custom_stat_aggregator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>data(noise_fluct)
agg &lt;- custom_stat_aggregator$new(y_func = mean, interleave_gaps = TRUE)
d_agg &lt;- agg$aggregate(noise_fluct$time, noise_fluct$f500, 1000)
plotly::plot_ly(x = d_agg$x, y = d_agg$y, type = "scatter", mode = "lines")

</code></pre>

<hr>
<h2 id='downsampler'>R6 class for down-sampling data</h2><span id='topic+downsampler'></span>

<h3>Description</h3>

<p>A class for down-sampling data with a large number of samples.
An instance contains (the reference of) original data, layout of the figure,
and options for aggregating the original data.
An interactive plot for displaying large-sized data can be obtained using
the figure, down-sampler and its options included in the instance,
while making the plot using <code>shiny_hugeplot</code> function is easier (see examples).
See the super class (<code>plotly_datahandler</code>) to find more members
to handle the data in <code>plotly</code>.
</p>


<h3>Format</h3>

<p>An <code>R6::R6Class</code> object
</p>


<h3>Super class</h3>

<p><code>shinyHugePlot::plotly_datahandler</code> -&gt; <code>downsampler</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>downsample_options</code></dt><dd><p>Options for aggregating (down-sampling) data
registered in this instance.</p>
</dd>
<dt><code>n_out_default</code></dt><dd><p>Default sample size.</p>
</dd>
<dt><code>aggregator_default</code></dt><dd><p>Default aggregator instance.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-downsampler-new"><code>downsampler$new()</code></a>
</p>
</li>
<li> <p><a href="#method-downsampler-add_trace"><code>downsampler$add_trace()</code></a>
</p>
</li>
<li> <p><a href="#method-downsampler-update_trace"><code>downsampler$update_trace()</code></a>
</p>
</li>
<li> <p><a href="#method-downsampler-set_downsample_options"><code>downsampler$set_downsample_options()</code></a>
</p>
</li>
<li> <p><a href="#method-downsampler-clone"><code>downsampler$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="shinyHugePlot" data-topic="plotly_datahandler" data-id="plotly_data_to_df"><a href='../../shinyHugePlot/html/plotly_datahandler.html#method-plotly_datahandler-plotly_data_to_df'><code>shinyHugePlot::plotly_datahandler$plotly_data_to_df()</code></a></span></li>
<li><span class="pkg-link" data-pkg="shinyHugePlot" data-topic="plotly_datahandler" data-id="set_trace_data"><a href='../../shinyHugePlot/html/plotly_datahandler.html#method-plotly_datahandler-set_trace_data'><code>shinyHugePlot::plotly_datahandler$set_trace_data()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-downsampler-new"></a>



<h4>Method <code>new()</code></h4>

<p>To construct an instance, original data, layout of the figure, and options
for aggregating the original data are necessary.
The original data and the layout of the figure can be given by providing
a <code>plotly</code> object (<code>figure</code> argument).
The options for aggregating the original data can be given by providing
an aggregator (<code>aggregator</code> argument) and the number of samples
(<code>n_out</code> argument).
See the constructor of the <code>plotly_datahandler</code> class for more
information on other arguments.
</p>


<h5>Usage</h5>

<div class="r"><pre>downsampler$new(
  figure = NULL,
  n_out = 1000L,
  aggregator = min_max_aggregator$new(),
  tz = Sys.timezone(),
  use_light_build = TRUE,
  legend_options = list(name_prefix = "&lt;b style=\"color:sandybrown\"&gt;[S]&lt;/b&gt; ",
    name_suffix = "", xdiff_prefix = "&lt;i style=\"color:#fc9944\"&gt; ~", xdiff_suffix =
    "&lt;/i&gt;"),
  verbose = F
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>figure, legend_options, tz, use_light_build</code></dt><dd><p>Arguments passed to <code>plotly_datahandler$new</code>.</p>
</dd>
<dt><code>n_out</code></dt><dd><p>Integer or numeric.
The number of samples shown after down-sampling. By default 1000.</p>
</dd>
<dt><code>aggregator</code></dt><dd><p>An instance of an R6 class for aggregation.
Select an aggregation function. The list of the functions are obtained
using <code>list_aggregators</code>.
By default, <code>min_max_aggregator$new()</code>.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Boolean.
Whether detailed messages to check the procedures are shown. By default, <code>FALSE</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-downsampler-add_trace"></a>



<h4>Method <code>add_trace()</code></h4>

<p>Add a new series to the data registered in the instance.
If a data frame (<code>traces_df</code> argument) compliant with
<code>self$orig_data</code> is given, it will be added to <code>self$orig_data</code>.
If attributes to construct a <code>plotly</code> object (<code>...</code> argument)
are given, a data frame is constructed and added.
Options for aggregating data can be set using
<code>aggregator</code> and <code>n_out</code> arguments.
It is a wrapper of <code>self$set_trace_data</code> and
<code>self$set_downsample_options</code>. See these methods for more information.
Note that the traces of the figure are not updated with this method and
<code>self$update_trace</code> is necessary.
</p>


<h5>Usage</h5>

<div class="r"><pre>downsampler$add_trace(..., traces_df = NULL, n_out = NULL, aggregator = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>..., traces_df</code></dt><dd><p>Arguments passed to <code>self$set_trace_data</code>
(see the super class of <code>plotly_datahandler</code>)</p>
</dd>
<dt><code>n_out, aggregator</code></dt><dd><p>Arguments passed to <code>self$set_downsample_options</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-downsampler-update_trace"></a>



<h4>Method <code>update_trace()</code></h4>

<p>Update traces of the figure registered in the instance
(<code>self$figure$x$data</code>) according to
re-layout order (<code>relayout_order</code> argument).
Using <code>reset</code> and <code>reload</code> arguments, traces are updated
without re-layout orders.
It just registers the new traces and returns nothing by default.
It returns the new traces if <code>send_trace</code> is <code>TRUE</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>downsampler$update_trace(
  relayout_order = list(NULL),
  reset = FALSE,
  reload = FALSE,
  send_trace = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>relayout_order</code></dt><dd><p>Named list.
A list generated by <code>plotlyjs_relayout</code>,
which is obtained using <code>plotly::event_data</code>.
e.g.,
If you would like set the range of the 2nd x axis to [10.0, 21.5],
<code>list(`xaxis2.range[0]` = 10.0, `xaxis2.range[1]` = 21.5)</code>.
If you would like reset the range of the 1st x axis,
<code>list(xaxis.autorange = TRUE, xaxis.showspike = TRUE)</code>.</p>
</dd>
<dt><code>reset</code></dt><dd><p>Boolean.
If it is <code>TRUE</code>, all other arguments are neglected and
the figure will be reset (all the ranges of x axes are initialized).
By default, <code>FALSE</code>.</p>
</dd>
<dt><code>reload</code></dt><dd><p>Boolean.
If it is <code>TRUE</code>, the ranges of the figure are preserved but
the aggregation will be conducted with the current settings.
By default, <code>FALSE</code>.</p>
</dd>
<dt><code>send_trace</code></dt><dd><p>Boolean.
If it is <code>TRUE</code>, a named list will be returned,
which contains the indexes of the traces that will be updated
(<code>trace_idx_update</code>) and the updated traces (<code>new_trace</code>).
By default, <code>FALSE</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-downsampler-set_downsample_options"></a>



<h4>Method <code>set_downsample_options()</code></h4>

<p>In the instance, options for aggregating data are registered as data frame.
(see <code>self$downsample_options</code>.)
Using this method, the options can be set.
</p>


<h5>Usage</h5>

<div class="r"><pre>downsampler$set_downsample_options(uid = NULL, n_out = NULL, aggregator = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>uid</code></dt><dd><p>Character, optional.
The unique id of the trace.
If <code>NULL</code>, all the options registered in this instance are updated.
By default, <code>NULL</code>.</p>
</dd>
<dt><code>n_out</code></dt><dd><p>Numeric or integer, optional.
The number of samples output by the aggregator.
If <code>NULL</code>, the default value registered in this instance is used.
By default, <code>NULL</code>.</p>
</dd>
<dt><code>aggregator</code></dt><dd><p><code>aggregator</code> object, optional.
An instance that aggregate the data.
If <code>NULL</code>, the default value registered in this instance is used.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-downsampler-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>downsampler$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
data(noise_fluct)

# example 1 : Easy method using shiny_hugeplot
shiny_hugeplot(noise_fluct$time, noise_fluct$f500)

# example 2 : Manual method using a downsampler object
fig &lt;- plot_ly(
  x = noise_fluct$time,
  y = noise_fluct$f500,
  type = "scatter",
  mode = "lines"
  ) %&gt;%
  layout(xaxis = list(type = "date")) %&gt;%
  shinyHugePlot::plotly_build_light()

ds &lt;- downsampler$new(
  figure = fig,
  aggregator = min_max_aggregator$new(interleave_gaps = TRUE)
)

ui &lt;- fluidPage(
  plotlyOutput(outputId = "hp", width = "800px", height = "600px")
)

server &lt;- function(input, output, session) {

  output$hp &lt;- renderPlotly(ds$figure)

  observeEvent(plotly::event_data("plotly_relayout"),{
    updatePlotlyH(session, "hp", plotly::event_data("plotly_relayout"), ds)
  })

}

shinyApp(ui = ui, server = server)


# example 3 : Add another series of which aggregator is different

noise_events &lt;- tibble(
  time = c("2022-11-09 12:25:50", "2022-11-09 12:26:14"),
  level = c(60, 60)
)

ds$add_trace(
  x = noise_events$time, y = noise_events$level, name = "event",
  type = "scatter", mode = "markers",
  aggregator = null_aggregator$new()
)
ds$update_trace(reset = TRUE)

server &lt;- function(input, output, session) {

  output$hp &lt;- renderPlotly(ds$figure)

  observeEvent(plotly::event_data("plotly_relayout"),{
    updatePlotlyH(session, "hp", plotly::event_data("plotly_relayout"), ds)
  })

}

shinyApp(ui = ui, server = server)



</code></pre>

<hr>
<h2 id='eLTTB_aggregator'>Aggregation using local minimum and maximum values,
and Largest Triangle Three Buckets (LTTB) method.</h2><span id='topic+eLTTB_aggregator'></span>

<h3>Description</h3>

<p>Efficient version off LTTB
by first reducing really large data with the <code>min_max_ovlp_aggregator</code>
and then further aggregating the reduced result with <code>LTTB_aggregator</code>.
</p>


<h3>Format</h3>

<p>An <code>R6::R6Class</code> object
</p>


<h3>Super class</h3>

<p><code>shinyHugePlot::aggregator</code> -&gt; <code>eLTTB_aggregator</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>LTTB</code></dt><dd><p>An R6 LTTB_aggregator instance</p>
</dd>
<dt><code>minmax</code></dt><dd><p>An R6 <code>min_max_ovlp_aggregator</code> instance</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-eLTTB_aggregator-new"><code>eLTTB_aggregator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-eLTTB_aggregator-clone"><code>eLTTB_aggregator$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="shinyHugePlot" data-topic="aggregator" data-id="aggregate"><a href='../../shinyHugePlot/html/aggregator.html#method-aggregator-aggregate'><code>shinyHugePlot::aggregator$aggregate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="shinyHugePlot" data-topic="aggregator" data-id="set_parameters"><a href='../../shinyHugePlot/html/aggregator.html#method-aggregator-set_parameters'><code>shinyHugePlot::aggregator$set_parameters()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-eLTTB_aggregator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor of the aggregator.
</p>


<h5>Usage</h5>

<div class="r"><pre>eLTTB_aggregator$new(
  ...,
  interleave_gaps,
  coef_gap,
  NA_position,
  accepted_datatype = c("numeric", "integer", "character", "factor", "logical")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Arguments pass to the constructor of <code>aggregator</code>,
<code>LTTB_aggregator</code> and <code>min_max_oblp_aggregator</code> objects.</p>
</dd>
<dt><code>interleave_gaps, coef_gap, NA_position, accepted_datatype</code></dt><dd><p>Arguments pass to the constructor of <code>aggregator</code> object.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-eLTTB_aggregator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>eLTTB_aggregator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>data(noise_fluct)
agg &lt;- eLTTB_aggregator$new(interleave_gaps = TRUE)
d_agg &lt;- agg$aggregate(noise_fluct$time, noise_fluct$f500, 1000)
plotly::plot_ly(x = d_agg$x, y = d_agg$y, type = "scatter", mode = "lines")

</code></pre>

<hr>
<h2 id='list_aggregators'>Show the aggregation functions</h2><span id='topic+list_aggregators'></span>

<h3>Description</h3>

<p>It displays all the aggregators registered in the package.
No arguments are necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_aggregators()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>list_aggregators()
</code></pre>

<hr>
<h2 id='LTTB_aggregator'>Aggregation using Largest Triangle Three Buckets (LTTB) method.</h2><span id='topic+LTTB_aggregator'></span>

<h3>Description</h3>

<p>The LTTB method aggregates the huge samples using the areas
of the triangles formed by the samples.
Numerical distances are employed in this class,
which requires the ratio between x and y values.
When the x is datetime, nanosecond is a unit.
When the x is factor or character, it will be encoded into numeric codes.
</p>


<h3>Format</h3>

<p>An <code>R6::R6Class</code> object
</p>


<h3>Super class</h3>

<p><code>shinyHugePlot::aggregator</code> -&gt; <code>LTTB_aggregator</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-LTTB_aggregator-new"><code>LTTB_aggregator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-LTTB_aggregator-clone"><code>LTTB_aggregator$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="shinyHugePlot" data-topic="aggregator" data-id="aggregate"><a href='../../shinyHugePlot/html/aggregator.html#method-aggregator-aggregate'><code>shinyHugePlot::aggregator$aggregate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="shinyHugePlot" data-topic="aggregator" data-id="set_parameters"><a href='../../shinyHugePlot/html/aggregator.html#method-aggregator-set_parameters'><code>shinyHugePlot::aggregator$set_parameters()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-LTTB_aggregator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor of the aggregator.
</p>


<h5>Usage</h5>

<div class="r"><pre>LTTB_aggregator$new(
  ...,
  nt_y_ratio = 1e+09,
  x_y_ratio = 1,
  interleave_gaps,
  coef_gap,
  NA_position,
  accepted_datatype = c("numeric", "integer", "character", "factor", "logical")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x_y_ratio, nt_y_ratio</code></dt><dd><p>Numeric.
These parameters set the unit length of the numeric <code>x</code>
and <code>nanotime</code> x.
For example, setting <code>x_y_ratio</code> to 2 is equivalent to
assuming 2 is the unit length of <code>x</code>
(and 1 is always the unit length of <code>y</code>).
The unit length is employed to calculate the area of the triangles.</p>
</dd>
<dt><code>interleave_gaps, coef_gap, NA_position, accepted_datatype, ...</code></dt><dd><p>Arguments pass to the constructor of <code>aggregator</code> object.
Note that <code>accepted_datatype</code> has default value.
Downsample with the Largest Triangle Three Buckets (LTTB) aggregation method</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LTTB_aggregator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>LTTB_aggregator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>data(noise_fluct)
agg &lt;- LTTB_aggregator$new(interleave_gaps = TRUE)
d_agg &lt;- agg$aggregate(
  x = noise_fluct$time, y = noise_fluct$f500, n_out = 1000
  )
plotly::plot_ly(x = d_agg$x, y = d_agg$y, type = "scatter", mode = "lines")
</code></pre>

<hr>
<h2 id='min_max_aggregator'>Aggregation using local minimum and maximum values.</h2><span id='topic+min_max_aggregator'></span>

<h3>Description</h3>

<p>Divide the data into small data ranges
and find the maximum and minimum values of each.
Note that many samples may be replaced with <code>NA</code>,
if <code>interleave_gaps = TRUE</code> and the original data is increased or decreased
monotonically. Use <code>min_max_ovlp_aggregator</code> instead in that case.
<code>n_out</code> must be even number.
</p>


<h3>Format</h3>

<p>An <code>R6::R6Class</code> object
</p>


<h3>Super class</h3>

<p><code>shinyHugePlot::aggregator</code> -&gt; <code>min_max_aggregator</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-min_max_aggregator-new"><code>min_max_aggregator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-min_max_aggregator-clone"><code>min_max_aggregator$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="shinyHugePlot" data-topic="aggregator" data-id="aggregate"><a href='../../shinyHugePlot/html/aggregator.html#method-aggregator-aggregate'><code>shinyHugePlot::aggregator$aggregate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="shinyHugePlot" data-topic="aggregator" data-id="set_parameters"><a href='../../shinyHugePlot/html/aggregator.html#method-aggregator-set_parameters'><code>shinyHugePlot::aggregator$set_parameters()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-min_max_aggregator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor of the Aggregator.
</p>


<h5>Usage</h5>

<div class="r"><pre>min_max_aggregator$new(
  ...,
  interleave_gaps,
  coef_gap,
  NA_position,
  accepted_datatype
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>interleave_gaps, coef_gap, NA_position, accepted_datatype, ...</code></dt><dd><p>Arguments pass to the constructor of <code>aggregator</code> object.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-min_max_aggregator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>min_max_aggregator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>data(noise_fluct)
agg &lt;- min_max_aggregator$new(interleave_gaps = TRUE)
d_agg &lt;- agg$aggregate(noise_fluct$time, noise_fluct$f500, 1000)
plotly::plot_ly(x = d_agg$x, y = d_agg$y, type = "scatter", mode = "lines")

</code></pre>

<hr>
<h2 id='min_max_ovlp_aggregator'>Aggregation using local minimum and maximum values
of which small data ranges have 50% overlaps.</h2><span id='topic+min_max_ovlp_aggregator'></span>

<h3>Description</h3>

<p>Divide the data into 50% overlapping intervals
and find the maximum and minimum values of each.
<code>n_out</code> must be even number.
</p>


<h3>Format</h3>

<p>An <code>R6::R6Class</code> object
</p>


<h3>Super class</h3>

<p><code>shinyHugePlot::aggregator</code> -&gt; <code>min_max_ovlp_aggregator</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-min_max_ovlp_aggregator-new"><code>min_max_ovlp_aggregator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-min_max_ovlp_aggregator-clone"><code>min_max_ovlp_aggregator$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="shinyHugePlot" data-topic="aggregator" data-id="aggregate"><a href='../../shinyHugePlot/html/aggregator.html#method-aggregator-aggregate'><code>shinyHugePlot::aggregator$aggregate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="shinyHugePlot" data-topic="aggregator" data-id="set_parameters"><a href='../../shinyHugePlot/html/aggregator.html#method-aggregator-set_parameters'><code>shinyHugePlot::aggregator$set_parameters()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-min_max_ovlp_aggregator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor of the Aggregator.
</p>


<h5>Usage</h5>

<div class="r"><pre>min_max_ovlp_aggregator$new(
  ...,
  interleave_gaps,
  coef_gap,
  NA_position,
  accepted_datatype
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>interleave_gaps, coef_gap, NA_position, accepted_datatype, ...</code></dt><dd><p>Arguments pass to the constructor of <code>aggregator</code> object.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-min_max_ovlp_aggregator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>min_max_ovlp_aggregator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>data(noise_fluct)
agg &lt;- min_max_ovlp_aggregator$new(interleave_gaps = TRUE)
d_agg &lt;- agg$aggregate(noise_fluct$time, noise_fluct$f500, 1000)
plotly::plot_ly(x = d_agg$x, y = d_agg$y, type = "scatter", mode = "lines")

</code></pre>

<hr>
<h2 id='noise_fluct'>Time-series fluctuations in sound level</h2><span id='topic+noise_fluct'></span>

<h3>Description</h3>

<p>Results of the measurement of the sound level,
where peaks due to road traffic are observed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noise_fluct
</code></pre>


<h3>Format</h3>

<p>A data frame with 32,001 rows and 4 columns:
</p>

<dl>
<dt>time</dt><dd><p>time</p>
</dd>
<dt>f500, f1000, f2000</dt><dd><p>Octave-band sound levels whose center frequencies are 500, 1000 and 2000 Hz.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Junta Tagusari <a href="mailto:j.tagusari@eng.hokudai.ac.jp">j.tagusari@eng.hokudai.ac.jp</a>
</p>

<hr>
<h2 id='nth_pnt_aggregator'>Aggregation which returns every Nth point.</h2><span id='topic+nth_pnt_aggregator'></span>

<h3>Description</h3>

<p>Aggregation by extracting every Nth data.
</p>


<h3>Format</h3>

<p>An <code>R6::R6Class</code> object
</p>


<h3>Super class</h3>

<p><code>shinyHugePlot::aggregator</code> -&gt; <code>nth_pnt_aggregator</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-nth_pnt_aggregator-new"><code>nth_pnt_aggregator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-nth_pnt_aggregator-clone"><code>nth_pnt_aggregator$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="shinyHugePlot" data-topic="aggregator" data-id="aggregate"><a href='../../shinyHugePlot/html/aggregator.html#method-aggregator-aggregate'><code>shinyHugePlot::aggregator$aggregate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="shinyHugePlot" data-topic="aggregator" data-id="set_parameters"><a href='../../shinyHugePlot/html/aggregator.html#method-aggregator-set_parameters'><code>shinyHugePlot::aggregator$set_parameters()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-nth_pnt_aggregator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor of the Aggregator.
</p>


<h5>Usage</h5>

<div class="r"><pre>nth_pnt_aggregator$new(
  ...,
  interleave_gaps,
  coef_gap,
  NA_position,
  accepted_datatype
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>interleave_gaps, coef_gap, NA_position, accepted_datatype, ...</code></dt><dd><p>Arguments pass to the constructor of <code>aggregator</code> object.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-nth_pnt_aggregator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>nth_pnt_aggregator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>data(noise_fluct)
agg &lt;- nth_pnt_aggregator$new(interleave_gaps = TRUE)
d_agg &lt;- agg$aggregate(noise_fluct$time, noise_fluct$f500, 1000)
plotly::plot_ly(x = d_agg$x, y = d_agg$y, type = "scatter", mode = "lines")
</code></pre>

<hr>
<h2 id='null_aggregator'>NULL aggregator.</h2><span id='topic+null_aggregator'></span>

<h3>Description</h3>

<p>It does not aggregate the data but returns the full samples within the range.
</p>


<h3>Format</h3>

<p>An <code>R6::R6Class</code> object
</p>


<h3>Super class</h3>

<p><code>shinyHugePlot::aggregator</code> -&gt; <code>null_aggregator</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-null_aggregator-new"><code>null_aggregator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-null_aggregator-aggregate"><code>null_aggregator$aggregate()</code></a>
</p>
</li>
<li> <p><a href="#method-null_aggregator-clone"><code>null_aggregator$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="shinyHugePlot" data-topic="aggregator" data-id="set_parameters"><a href='../../shinyHugePlot/html/aggregator.html#method-aggregator-set_parameters'><code>shinyHugePlot::aggregator$set_parameters()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-null_aggregator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor of the Aggregator.
</p>


<h5>Usage</h5>

<div class="r"><pre>null_aggregator$new(
  ...,
  interleave_gaps,
  coef_gap,
  NA_position,
  accepted_datatype
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>interleave_gaps, coef_gap, NA_position, accepted_datatype, ...</code></dt><dd><p>Arguments pass to the constructor of <code>aggregator</code> object.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-null_aggregator-aggregate"></a>



<h4>Method <code>aggregate()</code></h4>

<p>A function that does nothing other than inserting NAs.
</p>


<h5>Usage</h5>

<div class="r"><pre>null_aggregator$aggregate(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Arguments passed to <code>super$aggregate</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-null_aggregator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>null_aggregator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>data(noise_fluct)
agg &lt;- null_aggregator$new(interleave_gaps = TRUE)
d_agg &lt;- agg$aggregate(noise_fluct$time, noise_fluct$f500)
plotly::plot_ly(
  x = d_agg$x[1:100], y = d_agg$y[1:100], type = "scatter", mode = "lines"
)
</code></pre>

<hr>
<h2 id='plotly_build_light'>Build <code>plotly</code> data with low computation cost</h2><span id='topic+plotly_build_light'></span>

<h3>Description</h3>

<p>Before illustrating data using <code>plotly</code>, it must be built
(<code>figure$x$data</code> are need to be made using <code>figure$x$attrs</code>).
However, because a lot of procedures are necessary,
the computation cost is relatively high.
With this function, the data is built in quite short time by omitting
several procedures for high-frequency data.
Note that this function is not universally applicable to all <code>plotly</code>
objects but made for high-frequency scatter data.
<code>plotly::plotly_build</code> function may return better results in
specific cases although it takes more time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotly_build_light(fig, vars_hf = c("x", "y", "text", "hovertext"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotly_build_light_+3A_fig">fig</code></td>
<td>
<p><code>plotly</code> object.
Note that <code>fig$x$attrs</code> is not <code>NULL</code> and
each <code>fig$x$attrs</code> element has an element named <code>x</code>.
This function generates <code>fig$x$data</code> using <code>fig$x$attrs</code>.</p>
</td></tr>
<tr><td><code id="plotly_build_light_+3A_vars_hf">vars_hf</code></td>
<td>
<p>Character, optional.
Variable names where high frequency data is included.
It must include <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>built <code>plotly</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(noise_fluct)
plotly_build_light(
  plotly::plot_ly(
    x = noise_fluct$time,
    y = noise_fluct$f500,
    name = "level",
    type = "scatter"
  )
)

plotly_build_light(
  plotly::plot_ly(
    data = noise_fluct,
    x = ~time,
    y = ~f500,
    name = "level",
    type = "scatter"
  )
)

</code></pre>

<hr>
<h2 id='plotly_datahandler'>R6 class for handling plotly data</h2><span id='topic+plotly_datahandler'></span>

<h3>Description</h3>

<p>A class for handling <code>plotly</code> data,
which defines functions used in the <code>downsampler</code> class
</p>


<h3>Format</h3>

<p>An <code>R6::R6Class</code> object
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>figure</code></dt><dd><p><code>plotly</code> object.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>orig_data</code></dt><dd><p>Data frame representing <code>plotly</code> traces.</p>
</dd>
<dt><code>trace_df_default</code></dt><dd><p>Data frame representing default values
of <code>plotly</code> traces.
<code>name</code> column represents the names of the attributes.
<code>required</code> column represents whether the attributes are necessary
to construct a data frame of a trace.
<code>data</code> column represents whether the attributes are the data.
<code>default</code> attributes represents default values of the attributes.
When constructing a data frame of a trace, default values are used
if no values are assigned.
<code>class</code> column represents the acceptable classes of the attributes.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-plotly_datahandler-new"><code>plotly_datahandler$new()</code></a>
</p>
</li>
<li> <p><a href="#method-plotly_datahandler-set_trace_data"><code>plotly_datahandler$set_trace_data()</code></a>
</p>
</li>
<li> <p><a href="#method-plotly_datahandler-plotly_data_to_df"><code>plotly_datahandler$plotly_data_to_df()</code></a>
</p>
</li>
<li> <p><a href="#method-plotly_datahandler-clone"><code>plotly_datahandler$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-plotly_datahandler-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructing an instance.
The data contained in a <code>plotly</code> object (<code>figure</code> argument)
will be included in the instance (as a reference).
</p>


<h5>Usage</h5>

<div class="r"><pre>plotly_datahandler$new(
  figure = NULL,
  legend_options = list(name_prefix = "&lt;b style=\"color:sandybrown\"&gt;[S]&lt;/b&gt; ",
    name_suffix = "", xdiff_prefix = "&lt;i style=\"color:#fc9944\"&gt; ~", xdiff_suffix =
    "&lt;/i&gt;"),
  tz = Sys.timezone(),
  use_light_build = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>figure</code></dt><dd><p><code>plotly</code> object.
The traces of this object will be down-sampled.</p>
</dd>
<dt><code>legend_options</code></dt><dd><p>Named list, optional.
Names of the elements are <code>name_prefix</code>,
<code>name_suffix</code>, <code>xdiff_prefix</code>,
and <code>xdiff_suffix</code>.
<code>name_prefix</code> and <code>name_suffix</code>
will be added to the name of the trace when the down-sampling is applied.
By default, prefix is a bold orange <code>[S]</code> and suffix is none.
<code>xdiff_prefix</code> and <code>xdiff_suffix</code> are employed to show
the mean aggregation size of the down-sampling.</p>
</dd>
<dt><code>tz</code></dt><dd><p>Character, optional.
Time zone used to display time-series data.
By default <code>Sys.timezone()</code>.</p>
</dd>
<dt><code>use_light_build</code></dt><dd><p>Boolean, optional.
Whether <code>plotly_build_light</code> is used.
It quickly build scatter-type <code>plotly</code> data.
By default, <code>TRUE</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-plotly_datahandler-set_trace_data"></a>



<h4>Method <code>set_trace_data()</code></h4>

<p>In the instance, data is contained as a data frame
(see <code>self$orig_data</code> for detailed information).
Using this method, the data can be added or overwritten.
If a data frame (<code>traces_df</code> argument) is given, it will be
added to <code>self$orig_data</code> or reassigned as <code>self$orig_data</code>.
If attributes to construct a <code>plotly</code> object (<code>...</code> argument)
are given, a data frame is constructed and used.
</p>


<h5>Usage</h5>

<div class="r"><pre>plotly_datahandler$set_trace_data(..., traces_df = NULL, append = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Arguments to constitute a <code>plotly</code> attributes, optional.
For instance, <code>x</code>, <code>y</code>, <code>type</code>, and <code>mode</code>
are applicable. See <code>plotly::plot_ly</code>.</p>
</dd>
<dt><code>traces_df</code></dt><dd><p>Data frame, optional.
Data frame whose format is agreed with <code>self$orig_data</code>.
If <code>traces_df</code> is given, arguments in <code>...</code> are neglected.</p>
</dd>
<dt><code>append</code></dt><dd><p>Boolean, optional.
Whether the data is append or overwrite. By default, <code>FALSE</code>
(the traces are overwritten).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-plotly_datahandler-plotly_data_to_df"></a>



<h4>Method <code>plotly_data_to_df()</code></h4>

<p>Covert the data contained in <code>plotly</code> object to a data frame.
A unique id (<code>uid</code>) is granted to each data.
The data frame will be returned.
</p>


<h5>Usage</h5>

<div class="r"><pre>plotly_datahandler$plotly_data_to_df(plotly_data, use_datatable = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>plotly_data</code></dt><dd><p>List.
The list whose elements are named list representing <code>plotly</code> traces.
All elements must have elements named <code>type</code>.</p>
</dd>
<dt><code>use_datatable</code></dt><dd><p>Boolean.
If it is <code>TRUE</code>, data such as <code>x</code> and <code>y</code> are nested
in a <code>data.table</code>, of which key column is <code>x</code>.
By default, <code>TRUE</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-plotly_datahandler-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>plotly_datahandler$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='range_stat_aggregator'>Aggregation which returns the ranges and nominal values
within small data ranges</h2><span id='topic+range_stat_aggregator'></span>

<h3>Description</h3>

<p>This aggregator divides the data into no-overlapping intervals
and calculate specific statistics that represents the range and nominal
values of the data, such as the max, min and mean.
</p>


<h3>Format</h3>

<p>An <code>R6::R6Class</code> object
</p>


<h3>Super classes</h3>

<p><code>shinyHugePlot::aggregator</code> -&gt; <code>shinyHugePlot::rng_aggregator</code> -&gt; <code>range_stat_aggregator</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-range_stat_aggregator-new"><code>range_stat_aggregator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-range_stat_aggregator-clone"><code>range_stat_aggregator$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="shinyHugePlot" data-topic="aggregator" data-id="aggregate"><a href='../../shinyHugePlot/html/aggregator.html#method-aggregator-aggregate'><code>shinyHugePlot::aggregator$aggregate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="shinyHugePlot" data-topic="aggregator" data-id="set_parameters"><a href='../../shinyHugePlot/html/aggregator.html#method-aggregator-set_parameters'><code>shinyHugePlot::aggregator$set_parameters()</code></a></span></li>
<li><span class="pkg-link" data-pkg="shinyHugePlot" data-topic="rng_aggregator" data-id="as_plotly_range"><a href='../../shinyHugePlot/html/rng_aggregator.html#method-rng_aggregator-as_plotly_range'><code>shinyHugePlot::rng_aggregator$as_plotly_range()</code></a></span></li>
<li><span class="pkg-link" data-pkg="shinyHugePlot" data-topic="rng_aggregator" data-id="as_range"><a href='../../shinyHugePlot/html/rng_aggregator.html#method-rng_aggregator-as_range'><code>shinyHugePlot::rng_aggregator$as_range()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-range_stat_aggregator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor of the aggregator.
</p>


<h5>Usage</h5>

<div class="r"><pre>range_stat_aggregator$new(
  ...,
  ylwr = min,
  y = mean,
  yupr = max,
  interleave_gaps,
  coef_gap,
  NA_position,
  accepted_datatype
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>yupr, y, ylwr</code></dt><dd><p>Functions.
Statistical values are calculated using this function.
By default, <code>max, mean, min</code>, respectively.
Note that the NA values are omitted automatically.</p>
</dd>
<dt><code>interleave_gaps, coef_gap, NA_position, accepted_datatype, ...</code></dt><dd><p>Arguments pass to the constructor of <code>aggregator</code> object.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-range_stat_aggregator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>range_stat_aggregator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>data(noise_fluct)
agg &lt;- range_stat_aggregator$new(
  ylwr = min, y = mean, yupr = max, interleave_gaps = TRUE
)
d_agg &lt;- agg$aggregate(noise_fluct$time, noise_fluct$f500, 100)
plotly::plot_ly(x = d_agg$x, y = d_agg$y, type = "scatter", mode = "lines") %&gt;%
  plotly::add_trace(x = d_agg$x, y = d_agg$ylwr, type = "scatter", mode = "lines")%&gt;%
  plotly::add_trace(x = d_agg$x, y = d_agg$yupr, type = "scatter", mode = "lines")

</code></pre>

<hr>
<h2 id='rng_aggregator'>Aggregation that returns ranges of the data.</h2><span id='topic+rng_aggregator'></span>

<h3>Description</h3>

<p>A super class for describing <code>aggregator</code> that returns <code>x</code>, <code>y</code>,
<code>ylwr</code> and <code>yupr</code> values based on given <code>x</code> and <code>y</code> data.
</p>


<h3>Format</h3>

<p>An <code>R6::R6Class</code> object
</p>


<h3>Value</h3>

<p>List of which elements represent the ranges.
If there are no <code>NA</code>s, the length of the list is 1;
multiple lists are obtained if there are <code>NA</code>s.
Each element of list has <code>x</code> and <code>y</code> values that surround
the range of values.
</p>


<h3>Super class</h3>

<p><code>shinyHugePlot::aggregator</code> -&gt; <code>rng_aggregator</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-rng_aggregator-new"><code>rng_aggregator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-rng_aggregator-as_plotly_range"><code>rng_aggregator$as_plotly_range()</code></a>
</p>
</li>
<li> <p><a href="#method-rng_aggregator-as_range"><code>rng_aggregator$as_range()</code></a>
</p>
</li>
<li> <p><a href="#method-rng_aggregator-clone"><code>rng_aggregator$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="shinyHugePlot" data-topic="aggregator" data-id="aggregate"><a href='../../shinyHugePlot/html/aggregator.html#method-aggregator-aggregate'><code>shinyHugePlot::aggregator$aggregate()</code></a></span></li>
<li><span class="pkg-link" data-pkg="shinyHugePlot" data-topic="aggregator" data-id="set_parameters"><a href='../../shinyHugePlot/html/aggregator.html#method-aggregator-set_parameters'><code>shinyHugePlot::aggregator$set_parameters()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-rng_aggregator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor of the Aggregator.
</p>


<h5>Usage</h5>

<div class="r"><pre>rng_aggregator$new(
  interleave_gaps,
  coef_gap,
  NA_position,
  accepted_datatype,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>interleave_gaps, coef_gap, NA_position, accepted_datatype, ...</code></dt><dd><p>Arguments pass to the constructor of <code>aggregator</code> object.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-rng_aggregator-as_plotly_range"></a>



<h4>Method <code>as_plotly_range()</code></h4>

<p>Compute a <code>plotly</code> trace to illustrate the range of the data.
</p>


<h5>Usage</h5>

<div class="r"><pre>rng_aggregator$as_plotly_range(x, y, ylwr, yupr, opacity = 0.5)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x, y, ylwr, yupr</code></dt><dd><p>Outputs of the sub class of <code>rng_aggregator</code>.</p>
</dd>
<dt><code>opacity</code></dt><dd><p>Numeric, optional. Opacity of the range fill.
By default, 0.5.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-rng_aggregator-as_range"></a>



<h4>Method <code>as_range()</code></h4>

<p>Compute <code>x</code>, <code>ylwr</code> and <code>yupr</code> from a <code>plotly</code> trace
made by <code>self$as_plotly_range</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>rng_aggregator$as_range(prng)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>prng</code></dt><dd><p>List that represents range values, which
must contains <code>x</code>, <code>y</code>.
Note that the list may be an element of a list generated by
<code>self$as_plotly_range</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-rng_aggregator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>rng_aggregator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='shiny_hugeplot'>Wrapper for plotting large-sized data using <code>shinyHugePlot</code></h2><span id='topic+shiny_hugeplot'></span><span id='topic+shiny_hugeplot.default'></span><span id='topic+shiny_hugeplot.character'></span><span id='topic+shiny_hugeplot.matrix'></span><span id='topic+shiny_hugeplot.data.frame'></span><span id='topic+shiny_hugeplot.plotly'></span><span id='topic+shiny_hugeplot.downsampler'></span>

<h3>Description</h3>

<p>This is a S3 class function to easily plot large-sized data using
<code>downsampler</code> object including <code>plotly</code> and
<code>shiny</code> application.
Using data that is given as a first argument,
<code>shiny</code> application will be constructed and (by default,) executed.
As the first argument, many classes are applicable,
ranging from a numeric vector representing y values
to a <code>downsampler</code> object containing
original data, layout of the figure and
options for aggregating the original data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shiny_hugeplot(obj, ...)

## Default S3 method:
shiny_hugeplot(
  obj = NULL,
  y = NULL,
  tz = Sys.timezone(),
  use_light_build = TRUE,
  plotly_options = list(type = "scatter", mode = "lines"),
  plotly_layout_options = list(),
  aggregator = min_max_aggregator$new(),
  n_out = 1000L,
  run_shiny = TRUE,
  downsampler_options = list(),
  shiny_options = list(),
  width = "100%",
  height = "600px",
  verbose = FALSE,
  ...
)

## S3 method for class 'character'
shiny_hugeplot(
  obj = NULL,
  n_out = 1000L,
  aggregator = min_max_aggregator$new(),
  run_shiny = TRUE,
  use_light_build = TRUE,
  fread_options = list(),
  downsampler_options = list(),
  plotly_options = list(type = "scatter", mode = "lines"),
  plotly_layout_options = list(),
  shiny_options = list(),
  width = "100%",
  height = "600px",
  verbose = FALSE,
  ...
)

## S3 method for class 'matrix'
shiny_hugeplot(
  obj = NULL,
  n_out = 1000L,
  aggregator = min_max_aggregator$new(),
  run_shiny = TRUE,
  use_light_build = TRUE,
  downsampler_options = list(),
  plotly_options = list(type = "scatter", mode = "lines"),
  plotly_layout_options = list(),
  shiny_options = list(),
  width = "100%",
  height = "600px",
  verbose = FALSE,
  ...
)

## S3 method for class 'data.frame'
shiny_hugeplot(
  obj = NULL,
  tz = Sys.timezone(),
  n_out = 1000L,
  aggregator = min_max_aggregator$new(),
  run_shiny = TRUE,
  use_light_build = TRUE,
  downsampler_options = list(),
  plotly_options = list(type = "scatter", mode = "lines"),
  plotly_layout_options = list(),
  shiny_options = list(),
  width = "100%",
  height = "600px",
  verbose = FALSE,
  ...
)

## S3 method for class 'plotly'
shiny_hugeplot(
  obj,
  n_out = 1000L,
  aggregator = min_max_aggregator$new(),
  run_shiny = TRUE,
  use_light_build = TRUE,
  downsampler_options = list(),
  shiny_options = list(),
  width = "100%",
  height = "600px",
  verbose = FALSE,
  ...
)

## S3 method for class 'downsampler'
shiny_hugeplot(
  obj,
  run_shiny = TRUE,
  shiny_options = list(),
  width = "100%",
  height = "600px",
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shiny_hugeplot_+3A_obj">obj</code></td>
<td>
<p>Numeric/<code>nanotime</code>/<code>POSIXt</code> vector,
numeric matrix, data.frame, single character string,
<code>plotly</code> object, or <code>downsampler</code> object.
If a numeric vector is given, it will be used as y values of the figure
of the <code>shiny</code> application
(the x values are calculated by <code>seq_along(obj)</code>).
It will be interpreted as the x values if you use <code>y</code> argument together.
If a <code>nanotime</code> (see <code>nanotime</code> package) vector is given,
it will be used as the x values (<code>y</code> argument is mandatory).
If a numeric matrix is given, which must have more than 2 columns,
the first and second column values will be used as the x and y values.
If a data frame is given,
which must have columns named <code>x</code> and <code>y</code>,
these columns will be used as the x and y values.
If a single character string is given, it will be used as a file path
to obtain a data frame
(data frame will be loaded using <code>data.table::fread</code>).
If a <code>plotly</code> object is given, the data and layout of it will be used
for constructing the figure of the <code>shiny</code> application.
If a <code>downsampler</code> object is given, the data, layout, and
down-sampling options for aggregating original data of it will be used for
constructing <code>shiny</code> application.</p>
</td></tr>
<tr><td><code id="shiny_hugeplot_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="shiny_hugeplot_+3A_y">y</code></td>
<td>
<p>Numeric vector, optional.
y values of the figure of <code>shiny</code> application,
which is required if the <code>obj</code> argument is used as the x values.</p>
</td></tr>
<tr><td><code id="shiny_hugeplot_+3A_tz">tz</code></td>
<td>
<p>Timezone, optional.
It is used to convert the <code>nanotime</code> to the time displayed in the figure.
By default, <code>Sys.timezone()</code>.</p>
</td></tr>
<tr><td><code id="shiny_hugeplot_+3A_use_light_build">use_light_build</code></td>
<td>
<p>Boolean, optional.
Whether <code>shinyHugePlot::plotly_build_light</code> will be used.
(if <code>FALSE</code>, <code>plotly::plotly_build</code> will be used)
By default, <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="shiny_hugeplot_+3A_plotly_options">plotly_options</code></td>
<td>
<p>Named list, optional.
Arguments passed to <code>plotly::plot_ly</code>.</p>
</td></tr>
<tr><td><code id="shiny_hugeplot_+3A_plotly_layout_options">plotly_layout_options</code></td>
<td>
<p>Named list, optional.
Arguments passed to <code>plotly::layout</code>.</p>
</td></tr>
<tr><td><code id="shiny_hugeplot_+3A_aggregator">aggregator</code></td>
<td>
<p>Instance of R6 classes for aggregating data, optional.
The classes can be listed using <code>list_aggregators</code>.
By default, <code>min_max_aggregator$new()</code>.</p>
</td></tr>
<tr><td><code id="shiny_hugeplot_+3A_n_out">n_out</code></td>
<td>
<p>Integer, optional.
Number of samples get by the down-sampling. By default, 1000.</p>
</td></tr>
<tr><td><code id="shiny_hugeplot_+3A_run_shiny">run_shiny</code></td>
<td>
<p>Boolean, optional.
whether a generated <code>shiny</code> application will be launched.
By default, <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="shiny_hugeplot_+3A_downsampler_options">downsampler_options</code></td>
<td>
<p>Named list, optional.
Arguments passed to <code>downsampler$new</code>.
Note that use <code>aggregator</code> and <code>n_out</code> arguments
if you want to set these arguments.</p>
</td></tr>
<tr><td><code id="shiny_hugeplot_+3A_shiny_options">shiny_options</code></td>
<td>
<p>Named list, optional.
Arguments passed to <code>shinyApp</code> function.</p>
</td></tr>
<tr><td><code id="shiny_hugeplot_+3A_width">width</code>, <code id="shiny_hugeplot_+3A_height">height</code></td>
<td>
<p>Character, optional.
Arguments passed to <code>plotlyOutput</code>.
By default, <code>100%</code> and <code>600px</code>.</p>
</td></tr>
<tr><td><code id="shiny_hugeplot_+3A_verbose">verbose</code></td>
<td>
<p>Boolean.
Whether detailed messages to check the procedures are shown. By default, <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="shiny_hugeplot_+3A_fread_options">fread_options</code></td>
<td>
<p>Named list, optional.
Arguments passed to <code>data.table::fread</code>,
which is used if a single character string is given as the <code>obj</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(noise_fluct)

shiny_hugeplot(noise_fluct$f500)
shiny_hugeplot(noise_fluct$time, noise_fluct$f500)

</code></pre>

<hr>
<h2 id='shinyHugePlot'>shinyHugePlot</h2><span id='topic+shinyHugePlot'></span><span id='topic+shinyHugePlot-package'></span>

<h3>Description</h3>

<p>An interactive plot for data with a large sample size using <code>shiny</code>
and<code>plotly</code> can be obtained.
For an easy application, see <code>shiny_hugeplot</code> function.
For a manual application, see <code>downsampler</code> class.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Junta Tagusari <a href="mailto:j.tagusari@eng.hokudai.ac.jp">j.tagusari@eng.hokudai.ac.jp</a> [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Jonas Van Der Donckt [copyright holder]
</p>
</li>
<li><p> Jeroen Van Der Donckt [copyright holder]
</p>
</li>
<li><p> Emiel Deprost [copyright holder]
</p>
</li></ul>


<hr>
<h2 id='updatePlotlyH'>Function to call a method to update <code>plotly</code> traces</h2><span id='topic+updatePlotlyH'></span>

<h3>Description</h3>

<p>It is used by registering in a <code>shiny</code> application.
It receives events in <code>plotly</code> figure and update it using a method of
a <code>downsampler</code> instance.
See the examples in <code>downsampler</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updatePlotlyH(
  session,
  outputId,
  relayout_order,
  ds_obj,
  reset = FALSE,
  reload = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updatePlotlyH_+3A_session">session</code></td>
<td>
<p><code>session</code> object.
The object passed to function given to <code>shinyServer</code>.</p>
</td></tr>
<tr><td><code id="updatePlotlyH_+3A_outputid">outputId</code></td>
<td>
<p>Character.
The <code>outputId</code> of the figure, whose data will be down-sampled</p>
</td></tr>
<tr><td><code id="updatePlotlyH_+3A_relayout_order">relayout_order</code></td>
<td>
<p>Named list.
The list generated by <code>plotlyjs_relayout</code>,
which is obtained using <code>plotly::event_data</code>.</p>
</td></tr>
<tr><td><code id="updatePlotlyH_+3A_ds_obj">ds_obj</code></td>
<td>
<p><code>downsampler</code> instance.
The instance containing original data of the figure,
which is also used for updating the traces of <code>plotly</code>.</p>
</td></tr>
<tr><td><code id="updatePlotlyH_+3A_reset">reset</code></td>
<td>
<p>Boolean.
It it is <code>TRUE</code>, the figure will be updated even if
<code>relayout_order</code> is <code>NULL</code>.
The ranges of x axes are reset (initialized).</p>
</td></tr>
<tr><td><code id="updatePlotlyH_+3A_reload">reload</code></td>
<td>
<p>Boolean.
It it is <code>TRUE</code>, the figure will be updated even if
<code>relayout_order</code> is <code>NULL</code>.
The ranges of x axes are preserved.</p>
</td></tr>
<tr><td><code id="updatePlotlyH_+3A_verbose">verbose</code></td>
<td>
<p>Boolean.
Whether detailed messages to check the procedures are shown. By default, <code>FALSE</code>.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
