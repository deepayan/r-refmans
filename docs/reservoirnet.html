<!DOCTYPE html><html><head><title>Help for package reservoirnet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {reservoirnet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;&gt;%'><p>Takes two nodes and applies python operator <code>&gt;&gt;</code></p></a></li>
<li><a href='#createNode'><p>Function to create some node</p></a></li>
<li><a href='#dfCovid'><p>Datagouv covid-19 dataset</p></a></li>
<li><a href='#generate_data'><p>Load data from the <code>Japanese vowels</code> or the <code>Mackey-Glass</code></p></a></li>
<li><a href='#install_reservoirpy'><p>Install reservoirpy</p></a></li>
<li><a href='#link'><p>Link two :py:class:<code>~.Node</code> instances to form a :py:class:<code>~.Model</code></p>
instance. <code>node1</code> output will be used as input for <code>node2</code> in the
created model. This is similar to a function composition operation:</a></li>
<li><a href='#plot_2x2_perf'><p>plot_2x2_perf</p></a></li>
<li><a href='#plot_marginal_perf'><p>plot_marginal_perf</p></a></li>
<li><a href='#plot_perf_22'><p>plot_perf_22</p></a></li>
<li><a href='#plot.reservoir_predict_seq'><p>plot.reservoir_predict_seq</p></a></li>
<li><a href='#predict_seq'><p>Run the node-forward function on a sequence of data</p></a></li>
<li><a href='#print.summary.reservoirR_fit'><p>reservoirR_fit print summary</p></a></li>
<li><a href='#random_search_hyperparam'><p>random_search_hyperparam</p></a></li>
<li><a href='#reservoirR_fit'><p>Offline fitting method of a Node</p></a></li>
<li><a href='#rloguniform'><p>rloguniform</p></a></li>
<li><a href='#summary.reservoir_predict_seq'><p>summary.reservoir_predict_seq</p></a></li>
<li><a href='#summary.reservoirR_fit'><p>reservoirR_fit summary</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Reservoir Computing and Echo State Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-13</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Python (&gt;= 3.7)</td>
</tr>
<tr>
<td>Description:</td>
<td>A simple user-friendly library based on the 'python' module 'reservoirpy'.
             It provides a flexible interface to implement efficient Reservoir
             Computing (RC) architectures with a particular focus on Echo State Networks
             (ESN). Some of its features are: offline and online training, parallel implementation, 
             sparse matrix computation, fast spectral initialization, advanced learning 
             rules (e.g. Intrinsic Plasticity) etc. It also makes possible to easily create 
             complex architectures with multiple reservoirs (e.g. deep reservoirs), readouts, 
             and complex feedback loops. Moreover, graphical tools are included to easily 
             explore hyperparameters. Finally, it includes several tutorials exploring
             time series forecasting, classification and hyperparameter tuning. For more information
             about 'reservoirpy', please see Trouvain et al. (2020) &lt;<a href="https://doi.org/10.1007%2F978-3-030-61616-8_40">doi:10.1007/978-3-030-61616-8_40</a>&gt;.
             This package was developed in the framework of the University of Bordeaux’s IdEx
             "Investments for the Future" program / RRI PHDS.</td>
</tr>
<tr>
<td>Config/reticulate:</td>
<td>list( packages = list( list(package = "reservoirpy",
pip=TRUE) ) )</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/reservoirpy">https://github.com/reservoirpy</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>reticulate, testthat (&ge; 3.0.0), rlang, ggplot2, ggpubr,
janitor, dplyr, magrittr, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, covr, kableExtra, slider, tibble, tidyr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-03 13:57:07 UTC; tf1</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Ferte [aut, cre, trl],
  Kalidou Ba [aut, trl],
  Nathan Trouvain [aut],
  Rodolphe Thiebaut [aut],
  Xavier Hinaut [aut],
  Boris Hejblum [aut, trl]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Ferte &lt;thomas.ferte@u-bordeaux.fr&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-04 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+26gt+3B+25'>Takes two nodes and applies python operator <code>&gt;&gt;</code></h2><span id='topic++25+3E+3E+25'></span><span id='topic+chevron'></span>

<h3>Description</h3>

<p>A port of the <code>&gt;&gt;</code> &quot;chevron&quot; operator from reservoirpy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node1 %&gt;&gt;% node2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B26gt+2B3B+2B25_+3A_node1">node1</code></td>
<td>
<p>a <code>Node</code> or a list of <code>Nodes</code></p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B26gt+2B3B+2B25_+3A_node2">node2</code></td>
<td>
<p>a <code>Node</code> or a list of <code>Nodes</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A node or a list of nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
  source &lt;- reservoirnet::createNode("Input")
  reservoir &lt;- reservoirnet::createNode("Reservoir", units = 100, lr=0.1, sr=0.9)
  source %&gt;&gt;% reservoir

  readout &lt;- reservoirnet::createNode("Ridge")
  list(source %&gt;&gt;% reservoir, source) %&gt;&gt;% readout
}
</code></pre>

<hr>
<h2 id='createNode'>Function to create some node</h2><span id='topic+createNode'></span>

<h3>Description</h3>

<p>Function to create some node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createNode(
  nodeType = c("Ridge"),
  units = NULL,
  lr = 1,
  sr = NULL,
  otputDim = NULL,
  inputDim = NULL,
  name = NULL,
  ridge = 0,
  inputBias = TRUE,
  input_scaling = TRUE,
  input_connectivity = 0.1,
  rc_connectivity = 0.1,
  activation = "tanh",
  dtype = "float64",
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createNode_+3A_nodetype">nodeType</code></td>
<td>
<p>Type of node. Default is <code>"Ridge"</code>.</p>
</td></tr>
<tr><td><code id="createNode_+3A_units">units</code></td>
<td>
<p>(int) optional 
Number of reservoir units. If None, the number of units will be infered from
the <code>W</code> matrix shape.</p>
</td></tr>
<tr><td><code id="createNode_+3A_lr">lr</code></td>
<td>
<p>(float) default to 1.0
Neurons leak rate. Must be in :math:<code>[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="createNode_+3A_sr">sr</code></td>
<td>
<p>(float) optional
Spectral radius of recurrent weight matrix.</p>
</td></tr>
<tr><td><code id="createNode_+3A_otputdim">otputDim</code></td>
<td>
<p>Output dimension of the Node. Dimension of its state.</p>
</td></tr>
<tr><td><code id="createNode_+3A_inputdim">inputDim</code></td>
<td>
<p>Input dimension of the Node.</p>
</td></tr>
<tr><td><code id="createNode_+3A_name">name</code></td>
<td>
<p>Name of the Node. It must be a unique identifier.</p>
</td></tr>
<tr><td><code id="createNode_+3A_ridge">ridge</code></td>
<td>
<p>float, default to <code>0.0</code>. L2 regularization parameter.</p>
</td></tr>
<tr><td><code id="createNode_+3A_inputbias">inputBias</code></td>
<td>
<p>bool, default to <code>TRUE</code>. If <code>TRUE</code>, then a bias parameter 
will be learned along with output weights.</p>
</td></tr>
<tr><td><code id="createNode_+3A_input_scaling">input_scaling</code></td>
<td>
<p>float or array-like of shapes (features), default to <code>1.0</code>.
Input gain. An array of the same dimension as the inputs can be used to
set up different input scaling for each feature.</p>
</td></tr>
<tr><td><code id="createNode_+3A_input_connectivity">input_connectivity</code></td>
<td>
<p>float, default to 0.1. Connectivity of input neurons, i.e. ratio of input neurons connected to reservoir neurons. Must be between 0 and 1.</p>
</td></tr>
<tr><td><code id="createNode_+3A_rc_connectivity">rc_connectivity</code></td>
<td>
<p>float, default to 0.1. Connectivity of recurrent weight matrix, i.e. ratio of reservoir neurons connected to other reservoir neurons, including themselves. Must be between 0 and 1.</p>
</td></tr>
<tr><td><code id="createNode_+3A_activation">activation</code></td>
<td>
<p>str 'tanh'. Reservoir units activation function. Should be a activationsfunc function name ('tanh', 'identity', 'sigmoid', 'relu', 'softmax', 'softplus').</p>
</td></tr>
<tr><td><code id="createNode_+3A_dtype">dtype</code></td>
<td>
<p>Numerical type for node parameters</p>
</td></tr>
<tr><td><code id="createNode_+3A_seed">seed</code></td>
<td>
<p>set random seed</p>
</td></tr>
<tr><td><code id="createNode_+3A_...">...</code></td>
<td>
<p>Others params</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A node generated by reservoirpy python module.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
readout &lt;- reservoirnet::createNode("Ridge")
}

</code></pre>

<hr>
<h2 id='dfCovid'>Datagouv covid-19 dataset</h2><span id='topic+dfCovid'></span>

<h3>Description</h3>

<p>A dataset containing the data from datagouv.fr concerning covid-19 infections in Aquitaine. Data related to hospitalizations can be found at Santé publique France  - Data downloaded at https://www.data.gouv.fr/fr/datasets/r/08c18e08-6780-452d-9b8c-ae244ad529b3, update from 26/01/2023. Data related to RT-PCR can be found at Santé publique France  - Data downloaded at https://www.data.gouv.fr/fr/datasets/r/10639654-3864-48ac-b024-d772c218c4c1, update from 26/01/2023.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dfCovid)
</code></pre>


<h3>Format</h3>

<p>A data frame with 962 rows and 4 variables
</p>


<h3>Details</h3>


<ul>
<li><p> date. The date
</p>
</li>
<li><p> hosp. Number of person hospitalized with SARS-CoV-2 in Aquitaine.
</p>
</li>
<li><p> Positive. Number of person with a positive RT-PCR in Aquitaine.
</p>
</li>
<li><p> Tested. Number of person with a RT-PCR in Aquitaine.
</p>
</li></ul>


<hr>
<h2 id='generate_data'>Load data from the <code>Japanese vowels</code> or the <code>Mackey-Glass</code></h2><span id='topic+generate_data'></span>

<h3>Description</h3>

<p>Mackey-Glass time series <code>[8]_ [9]_</code>, computed from the Mackey-Glass
delayed differential equation:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_data(
  dataset = c("japanese_vowels", "mackey_glass", "both"),
  one_hot_encode = TRUE,
  repeat_targets = FALSE,
  reload = FALSE,
  n_timesteps,
  tau = 17,
  a = 0.2,
  b = 0.1,
  n = 10,
  x0 = 1.2,
  h = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_data_+3A_dataset">dataset</code></td>
<td>
<p>(String) take value in array <code>[japanese_vowels,mackey_glass]</code></p>
</td></tr>
<tr><td><code id="generate_data_+3A_one_hot_encode">one_hot_encode</code></td>
<td>
<p>(bool), default to True. If True, returns class label as a one-hot encoded vector.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_repeat_targets">repeat_targets</code></td>
<td>
<p>(bool), default to False. If True, repeat the target label or vector along the time axis of the corresponding sample.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_reload">reload</code></td>
<td>
<p>(bool), default to False
If True, re-download data from remote repository. Else, if a cached version
of the dataset exists, use the cached dataset.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_n_timesteps">n_timesteps</code></td>
<td>
<p>(int) Number of time steps to compute.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_tau">tau</code></td>
<td>
<p>(int), default to 17 
Time delay :math:'\tau' of Mackey-Glass equation.
By defaults, equals to 17. Other values can
change the choatic behaviour of the timeseries.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_a">a</code></td>
<td>
<p>(float) default to 0.2
:math:'a' parameter of the equation.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_b">b</code></td>
<td>
<p>(float) default to 0.1
:math:'b' parameter of the equation.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_n">n</code></td>
<td>
<p>(int) default to 10
:math:'n' parameter of the equation.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_x0">x0</code></td>
<td>
<p>(float), optional, default to 1.2
Initial condition of the timeseries.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_h">h</code></td>
<td>
<p>(float), default to 1.0
Time delta between two discrete timesteps.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array of shape (n_timesteps, 1) Mackey-Glass timeseries.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
japanese_vowels &lt;- generate_data(dataset="japanese_vowels")
timeSerie &lt;- generate_data(dataset = "mackey_glass",n_timesteps = 2500)
res =generate_data(dataset &lt;- "both",n_timesteps = 2500)
}
</code></pre>

<hr>
<h2 id='install_reservoirpy'>Install reservoirpy</h2><span id='topic+install_reservoirpy'></span>

<h3>Description</h3>

<p>Install reservoirpy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_reservoirpy(envname = "r-reticulate", method = "auto")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="install_reservoirpy_+3A_envname">envname</code></td>
<td>
<p><code>str</code> name of environment. Default is R-reticulate</p>
</td></tr>
<tr><td><code id="install_reservoirpy_+3A_method">method</code></td>
<td>
<p><code>str</code> type of environment type <code>(virtualenv, conda)</code>. 
Default is auto <code>(virtualenv is not available on Windows)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A NULL object after installing reservoirpy python module.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
reservoirnet::install_reservoirpy()

## End(Not run)

</code></pre>

<hr>
<h2 id='link'>Link two :py:class:<code>~.Node</code> instances to form a :py:class:<code>~.Model</code>
instance. <code>node1</code> output will be used as input for <code>node2</code> in the
created model. This is similar to a function composition operation:</h2><span id='topic+link'></span>

<h3>Description</h3>

<p>Link two :py:class:<code>~.Node</code> instances to form a :py:class:<code>~.Model</code>
instance. <code>node1</code> output will be used as input for <code>node2</code> in the
created model. This is similar to a function composition operation:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>link(node1, node2, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="link_+3A_node1">node1</code></td>
<td>
<p>(Node) or (list_of_Node)
Nodes or lists of nodes to link.</p>
</td></tr>
<tr><td><code id="link_+3A_node2">node2</code></td>
<td>
<p>(Node) or (list_of_Node)
Nodes or lists of nodes to link.</p>
</td></tr>
<tr><td><code id="link_+3A_name">name</code></td>
<td>
<p>(str) optional
Name for the chaining Model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can update the state of the node several times
</p>


<h3>Value</h3>

<p>A reservoir model linking node1 and node2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(reticulate::py_module_available("reservoirpy")){
reservoir &lt;- reservoirnet::createNode(nodeType = "Reservoir",
                                      seed = 1,
                                      units = 100,
                                      lr = 0.7,
                                      sr = 1,
                                      input_scaling = 1)
readout &lt;- reservoirnet::createNode(nodeType = "Ridge", ridge = 0.1)
model &lt;- reservoirnet::link(reservoir, readout)
}

</code></pre>

<hr>
<h2 id='plot_2x2_perf'>plot_2x2_perf</h2><span id='topic+plot_2x2_perf'></span>

<h3>Description</h3>

<p>Plot 2x2 combinations of the hyperparameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_2x2_perf(
  dfPerf,
  perf_lab = "Median relative error",
  legend_position = "bottom",
  trans = "log10"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_2x2_perf_+3A_dfperf">dfPerf</code></td>
<td>
<p>The performance dataframe which should have the columns : perf, ridge, input_scaling, leaking_rate, spectral_radius. Where perf is the performance metric</p>
</td></tr>
<tr><td><code id="plot_2x2_perf_+3A_perf_lab">perf_lab</code></td>
<td>
<p>The label of the performance metric.</p>
</td></tr>
<tr><td><code id="plot_2x2_perf_+3A_legend_position">legend_position</code></td>
<td>
<p>Position of legend passed to ggarrange</p>
</td></tr>
<tr><td><code id="plot_2x2_perf_+3A_trans">trans</code></td>
<td>
<p>The transformation (default is &quot;log10&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mutliple 2x2 plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dfPerf &lt;-
data.frame(
  perf = runif(n = 10),
  ridge = runif(n = 10),
  input_scaling = runif(n = 10),
  leaking_rate = runif(n = 10)
)
reservoirnet::plot_2x2_perf(dfPerf = dfPerf)


</code></pre>

<hr>
<h2 id='plot_marginal_perf'>plot_marginal_perf</h2><span id='topic+plot_marginal_perf'></span>

<h3>Description</h3>

<p>get marginal performance from dfPerf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_marginal_perf(dfPerf, color_cut = 10, perf_lab = "Median relative error")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_marginal_perf_+3A_dfperf">dfPerf</code></td>
<td>
<p>The performance dataframe which should have the columns : perf, ridge, input_scaling, leaking_rate, spectral_radius. Where perf is the performance metric</p>
</td></tr>
<tr><td><code id="plot_marginal_perf_+3A_color_cut">color_cut</code></td>
<td>
<p>The cutting point to highlight best values (default = 10)</p>
</td></tr>
<tr><td><code id="plot_marginal_perf_+3A_perf_lab">perf_lab</code></td>
<td>
<p>The label of the performance metric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with 4 facets
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dfPerf &lt;-
data.frame(
  perf = runif(n = 10),
  ridge = runif(n = 10),
  input_scaling = runif(n = 10),
  leaking_rate = runif(n = 10)
)
reservoirnet::plot_marginal_perf(dfPerf = dfPerf, color_cut = 2)

</code></pre>

<hr>
<h2 id='plot_perf_22'>plot_perf_22</h2><span id='topic+plot_perf_22'></span>

<h3>Description</h3>

<p>Unit plot for 2x2 function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_perf_22(x, y, dfPerf, perf_lab, trans = "log10")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_perf_22_+3A_x">x</code></td>
<td>
<p>The x feature</p>
</td></tr>
<tr><td><code id="plot_perf_22_+3A_y">y</code></td>
<td>
<p>The y feature</p>
</td></tr>
<tr><td><code id="plot_perf_22_+3A_dfperf">dfPerf</code></td>
<td>
<p>The performance dataframe which should have the columns : perf, ridge, input_scaling, leaking_rate, spectral_radius. Where perf is the performance metric</p>
</td></tr>
<tr><td><code id="plot_perf_22_+3A_perf_lab">perf_lab</code></td>
<td>
<p>The label of the performance metric.</p>
</td></tr>
<tr><td><code id="plot_perf_22_+3A_trans">trans</code></td>
<td>
<p>The transformation (default is &quot;log10&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2x2 plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dfPerf &lt;-
data.frame(
  perf = runif(n = 10),
  ridge = runif(n = 10),
  input_scaling = runif(n = 10),
  leaking_rate = runif(n = 10)
)
reservoirnet::plot_perf_22(
  dfPerf = dfPerf,
  x = "ridge",
  y = "input_scaling",
  perf_lab = "MSE"
)

</code></pre>

<hr>
<h2 id='plot.reservoir_predict_seq'>plot.reservoir_predict_seq</h2><span id='topic+plot.reservoir_predict_seq'></span>

<h3>Description</h3>

<p>plot.reservoir_predict_seq
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'reservoir_predict_seq'
plot(x, ..., vec_nodes = c(1:20), vec_time = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.reservoir_predict_seq_+3A_x">x</code></td>
<td>
<p>A reservoir_predict_seq object</p>
</td></tr>
<tr><td><code id="plot.reservoir_predict_seq_+3A_...">...</code></td>
<td>
<p>deprecated</p>
</td></tr>
<tr><td><code id="plot.reservoir_predict_seq_+3A_vec_nodes">vec_nodes</code></td>
<td>
<p>Number of nodes to plot</p>
</td></tr>
<tr><td><code id="plot.reservoir_predict_seq_+3A_vec_time">vec_time</code></td>
<td>
<p>Time to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(reticulate::py_module_available("reservoirpy")){
reservoir &lt;- reservoirnet::createNode(nodeType = "Reservoir",
                                      seed = 1,
                                      units = 100,
                                      lr = 0.7,
                                      sr = 1,
                                      input_scaling = 1)
X &lt;- matrix(data = rnorm(100), ncol = 4)
reservoir_state_stand &lt;- reservoirnet::predict_seq(node = reservoir, X = X)
plot(reservoir_state_stand)
summary(reservoir_state_stand)
}

</code></pre>

<hr>
<h2 id='predict_seq'>Run the node-forward function on a sequence of data</h2><span id='topic+predict_seq'></span>

<h3>Description</h3>

<p>Run the node-forward function on a sequence of data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_seq(node, X, formState = NULL, stateful = TRUE, reset = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_seq_+3A_node">node</code></td>
<td>
<p>node</p>
</td></tr>
<tr><td><code id="predict_seq_+3A_x">X</code></td>
<td>
<p>array-like of shape <code>([n_inputs], timesteps, input_dim)</code>
A sequence of data of shape (timesteps, features).</p>
</td></tr>
<tr><td><code id="predict_seq_+3A_formstate">formState</code></td>
<td>
<p>array of shape <code>(1, output_dim)</code>, optional 
Node state value to use at begining of computation.</p>
</td></tr>
<tr><td><code id="predict_seq_+3A_stateful">stateful</code></td>
<td>
<p><code>bool</code>, default to <code>TRUE</code> 
If True, Node state will be updated by this operation.</p>
</td></tr>
<tr><td><code id="predict_seq_+3A_reset">reset</code></td>
<td>
<p><code>bool</code>, default to <code>FALSE</code>
If True, Node state will be reset to zero before this operation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can update the state of the node several times
</p>


<h3>Value</h3>

<p>An object of class reservoir_predict_seq. This object is a numeric
vector containing the matrix of the prediction of the reservoir. It is either
the forecast of the ridge layer or the node state of the reservoir if no
ridge layer is given.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(reticulate::py_module_available("reservoirpy")){
reservoir &lt;- reservoirnet::createNode(nodeType = "Reservoir",
                                      seed = 1,
                                      units = 100,
                                      lr = 0.7,
                                      sr = 1,
                                      input_scaling = 1)
X &lt;- matrix(data = rnorm(100), ncol = 4)
reservoir_state_stand &lt;- reservoirnet::predict_seq(node = reservoir, X = X)
plot(reservoir_state_stand)
summary(reservoir_state_stand)
}


</code></pre>

<hr>
<h2 id='print.summary.reservoirR_fit'>reservoirR_fit print summary</h2><span id='topic+print.summary.reservoirR_fit'></span>

<h3>Description</h3>

<p>print S3 method for summary.reservoirR_fit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.reservoirR_fit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.reservoirR_fit_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.reservoirR_fit</code> to print.</p>
</td></tr>
<tr><td><code id="print.summary.reservoirR_fit_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A NULL object which shows the model setting to perform the reservoir
fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(reticulate::py_module_available("reservoirpy")){
}

</code></pre>

<hr>
<h2 id='random_search_hyperparam'>random_search_hyperparam</h2><span id='topic+random_search_hyperparam'></span>

<h3>Description</h3>

<p>Generate a hyperparameter simulation table using functions as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_search_hyperparam(
  n = 100,
  ls_fct = list(ridge = function(n) 1e-05, input_scaling = function(n) 1, spectral_radius
    = function(n) rloguniform(n = n, min = 0.01, max = 10), leaking_rate = function(n)
    rloguniform(n = n, min = 0.001, max = 1))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_search_hyperparam_+3A_n">n</code></td>
<td>
<p>Number of search</p>
</td></tr>
<tr><td><code id="random_search_hyperparam_+3A_ls_fct">ls_fct</code></td>
<td>
<p>A list of functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of size n x 4. Each row is a different set of hyperparameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>random_search_hyperparam(
  n = 100,
  ls_fct = list(
    ridge = function(n)
      1e-5,
    input_scaling = function(n)
      1,
    spectral_radius = function(n)
      rloguniform(n = n, min = 1e-2, max = 10),
    leaking_rate = function(n)
      rloguniform(n = n, min = 1e-3, max = 1)
  )
)

</code></pre>

<hr>
<h2 id='reservoirR_fit'>Offline fitting method of a Node</h2><span id='topic+reservoirR_fit'></span>

<h3>Description</h3>

<p>Offline fitting method of a Node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reservoirR_fit(node, X, Y, warmup = 0, stateful = FALSE, reset = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reservoirR_fit_+3A_node">node</code></td>
<td>
<p>node</p>
</td></tr>
<tr><td><code id="reservoirR_fit_+3A_x">X</code></td>
<td>
<p><code>array-like</code> of shape <code>[n_inputs], [series], timesteps, input_dim)</code>, optional
Input sequences dataset. If None, the method will try to fit
the parameters of the Node using the precomputed values returned
by previous call of :py:meth:<code>partial_fit</code>.</p>
</td></tr>
<tr><td><code id="reservoirR_fit_+3A_y">Y</code></td>
<td>
<p>array-like of shape <code>([series], timesteps, output_dim)</code>, optional
Teacher signals dataset. If None, the method will try to fit
the parameters of the Node using the precomputed values returned
by previous call of :py:meth: <code>partial_fit</code>, or to fit the Node in
an unsupervised way, if possible.</p>
</td></tr>
<tr><td><code id="reservoirR_fit_+3A_warmup">warmup</code></td>
<td>
<p>: <code>int</code>, default to 0 
Number of timesteps to consider as warmup and 
discard at the begining of each timeseries before training.</p>
</td></tr>
<tr><td><code id="reservoirR_fit_+3A_stateful">stateful</code></td>
<td>
<p>is boolen</p>
</td></tr>
<tr><td><code id="reservoirR_fit_+3A_reset">reset</code></td>
<td>
<p>is boolean. Should the node status be reset before fitting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A fitted reservoir of class reservoiR_fit containing the fitted
model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(reticulate::py_module_available("reservoirpy")){
}

</code></pre>

<hr>
<h2 id='rloguniform'>rloguniform</h2><span id='topic+rloguniform'></span>

<h3>Description</h3>

<p>Simulate a log-uniform distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rloguniform(n, min = 10^-1, max = 10^2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rloguniform_+3A_n">n</code></td>
<td>
<p>number of sample</p>
</td></tr>
<tr><td><code id="rloguniform_+3A_min">min</code></td>
<td>
<p>minimum of the distribution</p>
</td></tr>
<tr><td><code id="rloguniform_+3A_max">max</code></td>
<td>
<p>maximum of the distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of simulated values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rloguniform(n = 1)
</code></pre>

<hr>
<h2 id='summary.reservoir_predict_seq'>summary.reservoir_predict_seq</h2><span id='topic+summary.reservoir_predict_seq'></span>

<h3>Description</h3>

<p>summary.reservoir_predict_seq
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'reservoir_predict_seq'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.reservoir_predict_seq_+3A_object">object</code></td>
<td>
<p>A reservoir_predict_seq object</p>
</td></tr>
<tr><td><code id="summary.reservoir_predict_seq_+3A_...">...</code></td>
<td>
<p>Additional argument (unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with node activation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(reticulate::py_module_available("reservoirpy")){
reservoir &lt;- reservoirnet::createNode(nodeType = "Reservoir",
                                      seed = 1,
                                      units = 100,
                                      lr = 0.7,
                                      sr = 1,
                                      input_scaling = 1)
X &lt;- matrix(data = rnorm(100), ncol = 4)
reservoir_state_stand &lt;- reservoirnet::predict_seq(node = reservoir, X = X)
plot(reservoir_state_stand)
summary(reservoir_state_stand)
}

</code></pre>

<hr>
<h2 id='summary.reservoirR_fit'>reservoirR_fit summary</h2><span id='topic+summary.reservoirR_fit'></span>

<h3>Description</h3>

<p>summary S3 method for reservoirR_fit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'reservoirR_fit'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.reservoirR_fit_+3A_object">object</code></td>
<td>
<p>an object of class <code>reservoirR_fit</code> to summarized.</p>
</td></tr>
<tr><td><code id="summary.reservoirR_fit_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(reticulate::py_module_available("reservoirpy")){
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
