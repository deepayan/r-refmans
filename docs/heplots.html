<!DOCTYPE html><html lang="en-US"><head><title>Help for package heplots</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {heplots}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#heplots-package'><p>Visualizing Hypothesis Tests in Multivariate Linear Models</p></a></li>
<li><a href='#AddHealth'><p>Adolescent Mental Health Data</p></a></li>
<li><a href='#Adopted'><p>Adopted Children</p></a></li>
<li><a href='#arrow3d'><p>Draw a 3D Arrow in an RGL Scene</p></a></li>
<li><a href='#bartlettTests'><p>Bartlett Tests of Homogeneity of Variances</p></a></li>
<li><a href='#bbox3d'><p>Find the bounding box of a <code>rgl::mesh3d</code> or <code>rgl::qmesh3d</code> object</p></a></li>
<li><a href='#Bees'><p>Captive and maltreated bees</p></a></li>
<li><a href='#boxM'><p>Box's M-test</p></a></li>
<li><a href='#coefplot'><p>Coefficient plots for Multivariate Linear Models</p></a></li>
<li><a href='#colDevs'><p>Calculate column deviations from central values</p></a></li>
<li><a href='#covEllipses'><p>Draw classical and robust covariance ellipses for one or more groups</p></a></li>
<li><a href='#cqplot'><p>Chi Square Quantile-Quantile plots</p></a></li>
<li><a href='#cross3d'><p>Draw a 3D cross in an rgl scene</p></a></li>
<li><a href='#df.terms'><p>Find degrees of freedom for model terms</p></a></li>
<li><a href='#Diabetes'><p>Diabetes Dataset</p></a></li>
<li><a href='#dogfood'><p>Dogfood Preferences</p></a></li>
<li><a href='#ellipse.axes'><p>Draw Axes of a 2D Covariance Ellipse</p></a></li>
<li><a href='#ellipse.box'><p>Draw Conjugate Axes and Parallelogram Surrounding a Covariance Ellipse</p></a></li>
<li><a href='#ellipse3d.axes'><p>Draw axes of a 3D ellipsoid</p></a></li>
<li><a href='#Ellipsoid'><p>Draw an Ellipsoid in an rgl Scene</p></a></li>
<li><a href='#etasq'><p>Measures of Partial Association (Eta-squared) for Linear Models</p></a></li>
<li><a href='#FootHead'><p>Head measurements of football players</p></a></li>
<li><a href='#glance.mlm'><p>Glance at an mlm object</p></a></li>
<li><a href='#gsorth'><p>Orthogonalize successive columns of a data frame or matrix</p></a></li>
<li><a href='#Headache'><p>Treatment of Headache Sufferers for Sensitivity to Noise</p></a></li>
<li><a href='#heplot'><p>Two-Dimensional HE Plots</p></a></li>
<li><a href='#heplot1d'><p>One-Dimensional HE Plots</p></a></li>
<li><a href='#heplot3d'><p>Three-Dimensional HE Plots</p></a></li>
<li><a href='#heplots-internal'><p>Internal heplots functions</p></a></li>
<li><a href='#Hernior'><p>Recovery from Elective Herniorrhaphy</p></a></li>
<li><a href='#interpPlot'><p>Plot an Interpolation Between Two Related Data Sets</p></a></li>
<li><a href='#Iwasaki_Big_Five'><p>Personality Traits of Cultural Groups</p></a></li>
<li><a href='#label.ellipse'><p>Label an ellipse</p></a></li>
<li><a href='#leveneTests'><p>Levene Tests of Homogeneity of Variances</p></a></li>
<li><a href='#logdetCI'><p>Calculate confidence interval for log determinant of covariance matrices</p></a></li>
<li><a href='#Mahalanobis'><p>Classical and Robust Mahalanobis Distances</p></a></li>
<li><a href='#mark.H0'><p>Mark a point null hypothesis in an HE plot</p></a></li>
<li><a href='#mathscore'><p>Math scores for basic math and word problems</p></a></li>
<li><a href='#MockJury'><p>Effects Of Physical Attractiveness Upon Mock Jury Decisions</p></a></li>
<li><a href='#NeuroCog'><p>Neurocognitive Measures in Psychiatric Groups</p></a></li>
<li><a href='#NLSY'><p>National Longitudinal Survey of Youth Data</p></a></li>
<li><a href='#oral'><p>Effect of Delay in Oral Practice in Second Language Learning</p></a></li>
<li><a href='#Oslo'><p>Oslo Transect Subset Data</p></a></li>
<li><a href='#Overdose'><p>Overdose of Amitriptyline</p></a></li>
<li><a href='#pairs.mlm'><p>Pairwise HE Plots</p></a></li>
<li><a href='#Parenting'><p>Father Parenting Competence</p></a></li>
<li><a href='#peng'><p>Size measurements for penguins near Palmer Station, Antarctica</p></a></li>
<li><a href='#Plastic'><p>Plastic Film Data</p></a></li>
<li><a href='#plot.boxM'><p>Plot for Box's M test and generalizations</p></a></li>
<li><a href='#plot.robmlm'><p>Plot observation weights from a robust multivariate linear models</p></a></li>
<li><a href='#Pottery2'><p>Chemical Analysis of Romano-British Pottery</p></a></li>
<li><a href='#Probe'><p>Response Speed in a Probe Experiment</p></a></li>
<li><a href='#RatWeight'><p>Weight Gain in Rats Exposed to Thiouracil and Thyroxin</p></a></li>
<li><a href='#ReactTime'><p>Reaction Time Data</p></a></li>
<li><a href='#robmlm'><p>Robust Fitting of Multivariate Linear Models</p></a></li>
<li><a href='#Rohwer'><p>Rohwer Data Set</p></a></li>
<li><a href='#RootStock'><p>Growth of Apple Trees from Different Root Stocks</p></a></li>
<li><a href='#Sake'><p>Taste Ratings of Japanese Rice Wine (Sake)</p></a></li>
<li><a href='#schooldata'><p>School Data</p></a></li>
<li><a href='#Skulls'><p>Egyptian Skulls</p></a></li>
<li><a href='#SocGrades'><p>Grades in a Sociology Course</p></a></li>
<li><a href='#SocialCog'><p>Social Cognitive Measures in Psychiatric Groups</p></a></li>
<li><a href='#statList'><p>Calculate statistics for levels of factors</p></a></li>
<li><a href='#termMeans'><p>Calculate Means for a Term in a Multivariate Linear Model</p></a></li>
<li><a href='#TIPI'><p>Data on the Ten Item Personality Inventory</p></a></li>
<li><a href='#trans.colors'><p>Make Colors Transparent</p></a></li>
<li><a href='#uniStats'><p>Univariate Test Statistics for a Multivariate Linear Model</p></a></li>
<li><a href='#VocabGrowth'><p>Vocabulary growth data</p></a></li>
<li><a href='#WeightLoss'><p>Weight Loss Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Visualizing Hypothesis Tests in Multivariate Linear Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-12-07</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Friendly &lt;friendly@yorku.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides HE plot and other functions for visualizing hypothesis
    tests in multivariate linear models. HE plots represent sums-of-squares-and-products 
    matrices for linear hypotheses and for error using ellipses (in two
    dimensions) and ellipsoids (in three dimensions). The related 'candisc' package
    provides visualizations in a reduced-rank canonical discriminant space when
    there are more than a few response variables.</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), broom</td>
</tr>
<tr>
<td>Imports:</td>
<td>car, MASS, graphics, grDevices, stats, magrittr, purrr, rgl,
tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>candisc, carData, effects, reshape, gplots, nlme, lattice,
reshape2, corrgram, animation, mvinfluence, knitr, rmarkdown,
markdown, dplyr, tidyr, ggplot2, bookdown, patchwork,
tinytable, glue, here, Sleuth2, rrcov, archdata, qqtest,
vcdExtra, R.rsp</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/friendly/heplots/issues">https://github.com/friendly/heplots/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://friendly.github.io/heplots/">http://friendly.github.io/heplots/</a>,
<a href="http://friendly.github.io/heplots/">http://friendly.github.io/heplots/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-22 20:15:47 UTC; friendly</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Friendly <a href="https://orcid.org/0000-0002-3237-0941"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  John Fox <a href="https://orcid.org/0000-0002-1196-8012"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Georges Monette <a href="https://orcid.org/0000-0003-0076-5532"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Phil Chalmers <a href="https://orcid.org/0000-0001-5332-2810"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Duncan Murdoch [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-22 21:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='heplots-package'>Visualizing Hypothesis Tests in Multivariate Linear Models</h2><span id='topic+heplots-package'></span><span id='topic+heplots'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>The <code>heplots</code> package provides functions for visualizing hypothesis
tests in multivariate linear models (MANOVA, multivariate multiple
regression, MANCOVA, and repeated measures designs).  HE plots represent
sums-of-squares-and-products matrices for linear hypotheses and for error
using ellipses (in two dimensions), ellipsoids (in three dimensions), or by
line segments in one dimension.
</p>


<h3>Details</h3>

<p>The basic theory behind HE plots is described by Friendly (2007).
See Fox, Friendly and Monette (2007) for a
brief introduction; Friendly &amp; Sigal (2016) for a tutorial on these methods;
and Friendly, Monette and Fox (2013) for a general
discussion of the role of elliptical geometry in statistical understanding.
</p>
<p>Other topics now addressed here include robust MLMs, tests for equality of
covariance matrices in MLMs, and chi square Q-Q plots for MLMs.
</p>
<p>The package also provides a collection of data sets illustrating a variety
of multivariate linear models of the types listed above, together with
graphical displays.
</p>
<p>Several tutorial vignettes are also included.  See
<code>vignette(package="heplots")</code>.
</p>
<p>The graphical functions contained here all display multivariate model
effects in variable (data) space, for one or more response variables (or
contrasts among response variables in repeated measures designs).
</p>
 
<dl>
<dt>list(list(&quot;heplot&quot;))</dt><dd><p>constructs two-dimensional HE plots
for model terms and linear hypotheses for pairs of response variables in
multivariate linear models.</p>
</dd>
<dt>list(list(&quot;heplot3d&quot;))</dt><dd><p>constructs analogous 3D plots for triples of
response variables.</p>
</dd>
<dt>list(list(&quot;pairs.mlm&quot;))</dt><dd><p>constructs a &ldquo;matrix&rdquo; of pairwise HE
plots.</p>
</dd>
<dt>list(list(&quot;heplot1d&quot;))</dt><dd><p>constructs 1-dimensional analogs of HE plots
for model terms and linear hypotheses for single response variables.</p>
</dd> 
</dl>

<p>For repeated measure designs, between-subject effects and within-subject
effects must be plotted separately, because the error terms (E matrices)
differ.  For terms involving within-subject effects, these functions carry
out a linear transformation of the matrix <b>Y</b> of responses to a matrix
<b>Y M</b>, where <b>M</b> is the model matrix for a term in the
intra-subject design and produce plots of the H and E matrices in this
transformed space. The vignette <code>repeated</code> describes these graphical
methods for repeated measures designs.
</p>
<p>The related <span class="pkg">car</span> package calculates Type II and Type III tests of
multivariate linear hypotheses using the <code><a href="car.html#topic+Anova">Anova</a></code> and
<code><a href="car.html#topic+linearHypothesis">linearHypothesis</a></code> functions.
</p>
<p>The <code><a href="candisc.html#topic+candisc-package">candisc-package</a></code> package provides functions for
visualizing effects for MLM model terms in a low-dimensional canonical space
that shows the largest hypothesis relative to error variation. The
<span class="pkg">candisc</span> package now also includes related methods for canonical
correlation analysis.
</p>
<p>The <code>heplots</code> package also contains a large number of multivariate data
sets with examples of analyses and graphic displays.  Use
<code>data(package="heplots")</code> to see the current list.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly, John Fox, and Georges Monette
</p>
<p>Maintainer: Michael Friendly, <a href="mailto:friendly@yorku.ca">friendly@yorku.ca</a>, <a href="http://datavis.ca">http://datavis.ca</a>
</p>


<h3>References</h3>

<p>Friendly, M. (2006).  Data Ellipses, HE Plots and Reduced-Rank
Displays for Multivariate Linear Models: SAS Software and Examples.
<em>Journal of Statistical Software</em>, 17(6), 1-42. 
<a href="https://www.jstatsoft.org/v17/i06/">https://www.jstatsoft.org/v17/i06/</a>,
<a href="https://doi.org/10.18637/jss.v017.i06">doi:10.18637/jss.v017.i06</a>
</p>
<p>Friendly, M. (2007).  HE plots for Multivariate General Linear Models.
<em>Journal of Computational and Graphical Statistics</em>, 16(2) 421-444.
<a href="http://datavis.ca/papers/jcgs-heplots.pdf">http://datavis.ca/papers/jcgs-heplots.pdf</a>,
<a href="https://doi.org/10.1198/106186007X208407">doi:10.1198/106186007X208407</a>
</p>
<p>Fox, J., Friendly, M. &amp; Monette, G. (2007).  Visual hypothesis tests in
multivariate linear models: The heplots package for R.  <em>DSC 2007:
Directions in Statistical Computing</em>.
<a href="https://socialsciences.mcmaster.ca/jfox/heplots-dsc-paper.pdf">https://socialsciences.mcmaster.ca/jfox/heplots-dsc-paper.pdf</a>
</p>
<p>Friendly, M. (2010). HE Plots for Repeated Measures Designs. <em>Journal
of Statistical Software</em>, 37(4), 1-40. 
<a href="https://doi.org/10.18637/jss.v037.i04">doi:10.18637/jss.v037.i04</a>.
</p>
<p>Fox, J., Friendly, M. &amp; Weisberg, S. (2013).  Hypothesis Tests for
Multivariate Linear Models Using the car Package.  <em>The R Journal</em>,
<b>5</b>(1),
<a href="https://journal.r-project.org/archive/2013-1/fox-friendly-weisberg.pdf">https://journal.r-project.org/archive/2013-1/fox-friendly-weisberg.pdf</a>.
</p>
<p>Friendly, M., Monette, G. &amp; Fox, J. (2013).  Elliptical Insights:
Understanding Statistical Methods Through Elliptical Geometry.
<em>Statistical Science</em>, 2013, <b>28</b> (1), 1-39,
<a href="http://datavis.ca/papers/ellipses.pdf">http://datavis.ca/papers/ellipses.pdf</a>.
</p>
<p>Friendly, M. &amp; Sigal, M. (2014). Recent Advances in Visualizing Multivariate
Linear Models. <em>Revista Colombiana de Estadistica</em>, <b>37</b>, 261-283
</p>
<p>Friendly, M. &amp; Sigal, M. (2016). Graphical Methods for Multivariate Linear
Models in Psychological Research: An R Tutorial. Submitted for publication.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+Anova">Anova</a></code>, <code><a href="car.html#topic+linearHypothesis">linearHypothesis</a></code> for Anova.mlm computations and tests
</p>
<p><code><a href="candisc.html#topic+candisc-package">candisc-package</a></code> for reduced-rank views in canonical space
</p>
<p><code><a href="stats.html#topic+manova">manova</a></code> for a different approach to testing effects in MANOVA designs
</p>

<hr>
<h2 id='AddHealth'>Adolescent Mental Health Data</h2><span id='topic+AddHealth'></span>

<h3>Description</h3>

<p>This data was taken from the National Longitudinal Study of Adolescent
Health.  It is a cross-sectional sample of participants from grades 7&ndash;12,
described and analyzed by Warne (2014).
</p>


<h3>Format</h3>

<p>A data frame with 4344 observations on the following 3 variables.
</p>
 
<dl>
<dt><code>grade</code></dt><dd><p>an ordered factor with levels <code>7</code> &lt;
<code>8</code> &lt; <code>9</code> &lt; <code>10</code> &lt; <code>11</code> &lt; <code>12</code></p>
</dd>
<dt><code>depression</code></dt><dd><p>a numeric vector</p>
</dd> 
<dt><code>anxiety</code></dt><dd><p>a numeric vector</p>
</dd> 
</dl>



<h3>Details</h3>

<p><code>depression</code> is the response to the question &quot;In the last month, how
often did you feel depressed or blue?&quot;
</p>
<p><code>anxiety</code> is the response to the question &quot;In the last month, how often
did you have trouble relaxing?&quot;
</p>
<p>The responses for <code>depression</code> and <code>anxiety</code> were recorded on a
5-point Likert scale, with categories <code>0="Never", 1="Rarely",
2="Occasionally", 3="Often", 4="Every day"</code>
</p>


<h3>Source</h3>

<p>Warne, R. T. (2014). A primer on Multivariate Analysis of Variance
(MANOVA) for Behavioral Scientists.  
<em>Practical Assessment, Research &amp; Evaluation</em>, 19 (1).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(AddHealth)

if(require(dplyr) &amp; require(ggplot2)) {
# find means &amp; std.errors by grade
means &lt;- AddHealth |&gt;
group_by(grade) |&gt;
  summarise(
    n = n(),
    dep_se = sd(depression, na.rm = TRUE) / sqrt(n),
    anx_se = sd(anxiety, na.rm = TRUE) / sqrt(n),
    depression = mean(depression),
    anxiety = mean(anxiety) ) |&gt; 
  relocate(depression, anxiety, .after = grade) |&gt;
  print()
  
# plot means with std.error bars
ggplot(data = means, aes(x = anxiety, y = depression, 
color = grade)) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = anxiety - anx_se, 
                     xmax = anxiety + anx_se)) +
  geom_errorbar(aes(ymin = depression - dep_se, 
                    ymax = depression + dep_se)) +
  geom_line(aes(group = 1), linewidth = 1.5) +
  geom_label(aes(label = grade), 
             nudge_x = -0.015, nudge_y = 0.02) +
  scale_color_discrete(guide = "none") +
  theme_bw(base_size = 15)
}

# fit mlm
AH.mod &lt;- lm(cbind(anxiety, depression) ~ grade, data=AddHealth)

car::Anova(AH.mod)
summary(car::Anova(AH.mod))

heplot(AH.mod, hypotheses="grade.L", 
       fill=c(TRUE, FALSE),
       level = 0.4)

</code></pre>

<hr>
<h2 id='Adopted'>Adopted Children</h2><span id='topic+Adopted'></span>

<h3>Description</h3>

<p>Data are a subset from an observational, longitudinal, study on adopted
children.  Is child's intelligence related to intelligence of the biological
mother and the intelligence of the adoptive mother?
</p>


<h3>Format</h3>

<p>A data frame with 62 observations on the following 6 variables.
</p>
 
<dl>
<dt><code>AMED</code></dt><dd><p>adoptive mother's years of education (proxy
for her IQ)</p>
</dd> 
<dt><code>BMIQ</code></dt><dd><p>biological mother's score on IQ test</p>
</dd>
<dt><code>Age2IQ</code></dt><dd><p>IQ of child at age 2</p>
</dd> 
<dt><code>Age4IQ</code></dt><dd><p>IQ of child at age 4</p>
</dd> 
<dt><code>Age8IQ</code></dt><dd><p>IQ of child at age 8</p>
</dd>
<dt><code>Age13IQ</code></dt><dd><p>IQ of child at age 13</p>
</dd> 
</dl>



<h3>Details</h3>

<p>The child's intelligence was measured at age 2, 4, 8, and 13 for this
sample.  How does intelligence change over time, and how are these changes
related to intelligence of the birth and adoptive mother?
</p>


<h3>Source</h3>

<p>Ramsey, F.L. and Schafer, D.W. (2002). <em>The Statistical Sleuth:
A Course in Methods of Data Analysis (2nd ed)</em>, Duxbury.
</p>
<p>This data set is identical to <code><a href="Sleuth2.html#topic+ex1605">ex1605</a></code> in the
<code>Sleuth2</code> package.
</p>


<h3>References</h3>

<p>Friendly, M.  (2010). HE Plots for Repeated Measures Designs.
<em>Journal of Statistical Software</em>, 37(4), 1-40.
<a href="https://doi.org/10.18637/jss.v037.i04">doi:10.18637/jss.v037.i04</a>.
</p>
<p>Skodak, M. and Skeels, H.M. (1949). A Final Follow-up Study of One Hundred
Adopted Children, 
<em>Journal of Genetic Psychology</em> <b>75</b>: 85&ndash;125.
</p>


<h3>See Also</h3>

<p><code><a href="Sleuth2.html#topic+ex1605">ex1605</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Treat as multivariate regression problem
Adopted.mod &lt;- lm(cbind(Age2IQ, Age4IQ, Age8IQ, Age13IQ) ~ AMED + BMIQ, 
                  data=Adopted)
Adopted.mod


require(car)
# test overall multivariate regression
print(linearHypothesis(Adopted.mod, c("AMED","BMIQ")), SSP=FALSE)

# show separate linear regressions
op &lt;- par(mfcol=c(2,4), mar=c(4,4,1,1)+.1)
for (i in 3:6) {
	dataEllipse(as.matrix(Adopted[,c(1,i)]),
	            col="black", levels=0.68, ylim=c(70,140))
	abline(lm(Adopted[,i] ~ Adopted[,1]), col="red", lwd=2)

	dataEllipse(as.matrix(Adopted[,c(2,i)]),
	            col="black", levels=0.68, ylim=c(70,140))
	abline(lm(Adopted[,i] ~ Adopted[,2]), col="red", lwd=2)
	abline(a=0,b=1, lty=1, col="blue")
}
par(op)

# between-S (MMReg) plots
heplot(Adopted.mod, hypotheses=list("Reg"=c("AMED", "BMIQ")),
	main="IQ scores of adopted children: MMReg")

pairs(Adopted.mod, hypotheses=list("Reg"=c("AMED", "BMIQ")))

if(requireNamespace("rgl")){
heplot3d(Adopted.mod, hypotheses=list("Reg"=c("AMED", "BMIQ")),
	col = c("red", "blue", "black", "gray"), wire=FALSE)
}

# Treat IQ at different ages as a repeated measure factor
# within-S models &amp; plots
Age &lt;- data.frame(Age=ordered(c(2,4,8,13)))
car::Anova(Adopted.mod, idata=Age, idesign=~Age, test="Roy")

# within-S plots
heplot(Adopted.mod, idata=Age, idesign=~Age, iterm="Age",
	cex=1.25, cex.lab=1.4, fill=c(FALSE, TRUE),
	hypotheses=list("Reg"=c("AMED", "BMIQ"))
	)


</code></pre>

<hr>
<h2 id='arrow3d'>Draw a 3D Arrow in an RGL Scene</h2><span id='topic+arrow3d'></span>

<h3>Description</h3>

<p>Draws a 3D arrow in an rgl scene with barbs at the arrow head
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrow3d(
  p0 = c(0, 0, 0),
  p1 = c(1, 1, 1),
  barblen,
  s = 0.05,
  theta = pi/6,
  n = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arrow3d_+3A_p0">p0</code></td>
<td>
<p>Initial point (tail of arrow)</p>
</td></tr>
<tr><td><code id="arrow3d_+3A_p1">p1</code></td>
<td>
<p>Ending point (head of arrow)</p>
</td></tr>
<tr><td><code id="arrow3d_+3A_barblen">barblen</code></td>
<td>
<p>Length of each barb, in data units</p>
</td></tr>
<tr><td><code id="arrow3d_+3A_s">s</code></td>
<td>
<p>length of barb as fraction of line length (unless barblen is
specified)</p>
</td></tr>
<tr><td><code id="arrow3d_+3A_theta">theta</code></td>
<td>
<p>opening angle of barbs</p>
</td></tr>
<tr><td><code id="arrow3d_+3A_n">n</code></td>
<td>
<p>number of barbs</p>
</td></tr>
<tr><td><code id="arrow3d_+3A_...">...</code></td>
<td>
<p>args passed to lines3d for line styling, e.g., <code>color</code>,
<code>lwd</code>, etc. See <code><a href="rgl.html#topic+material3d">material3d</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns (invisibly): integer ID of the line added to the scene 
</p>


<h3>Author(s)</h3>

<p>Barry Rowlingson, posted to R-help, 1/10/2010
</p>


<h3>See Also</h3>

<p><code><a href="rgl.html#topic+lines3d">lines3d</a></code>, <code><a href="rgl.html#topic+segments3d">segments3d</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
arrow3d(c(0,0,0), c(2,2,2), barblen=.2, lwd=3, col="black")
arrow3d(c(0,0,0), c(-2,2,2), barblen=.2, lwd=3, col="red")

</code></pre>

<hr>
<h2 id='bartlettTests'>Bartlett Tests of Homogeneity of Variances</h2><span id='topic+bartlettTests'></span><span id='topic+bartlettTests.default'></span><span id='topic+bartlettTests.formula'></span><span id='topic+bartlettTests.lm'></span>

<h3>Description</h3>

<p>This function extends <code><a href="stats.html#topic+bartlett.test">bartlett.test</a></code> to a multivariate
response setting.  It performs the Bartlett test of homogeneity of variances
for each of a set of response variables, and prints a compact summary.
</p>
<p>Bartlett's test is the univariate version of Box's M test for equality of
covariance matrices.  This function provides a univariate follow-up test to
Box's M test to give one simple assessment of which response variables
contribute to significant differences in variances among groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bartlettTests(y, ...)

## Default S3 method:
bartlettTests(y, group, ...)

## S3 method for class 'formula'
bartlettTests(y, data, ...)

## S3 method for class 'lm'
bartlettTests(y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bartlettTests_+3A_y">y</code></td>
<td>
<p>A data frame or matrix of numeric response variables for the default method,
or a model formula for a multivariate linear model, or the multivariate linear model itself.
In the case of a formula or model, the  variables on the right-hand-side of the model must all 
be factors and must be completely crossed.</p>
</td></tr>
<tr><td><code id="bartlettTests_+3A_...">...</code></td>
<td>
<p>other arguments, passed to <code><a href="stats.html#topic+bartlett.test">bartlett.test</a></code></p>
</td></tr>
<tr><td><code id="bartlettTests_+3A_group">group</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of the rows of <code>y</code> for the default method</p>
</td></tr>
<tr><td><code id="bartlettTests_+3A_data">data</code></td>
<td>
<p>the data set, for the <code>formula</code> method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of classes &quot;anova&quot; and &quot;data.frame&quot;, with one observation
for each response variable in <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>References</h3>

<p>Bartlett, M. S. (1937). Properties of sufficiency and
statistical tests.  <em>Proceedings of the Royal Society of London Series
A</em>, <b>160</b>, 268-282.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boxM">boxM</a></code> for Box's M test for all responses together.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bartlettTests(iris[,1:4], iris$Species)

data(Skulls, package="heplots")
bartlettTests(Skulls[,-1], Skulls$epoch)

# formula method
bartlettTests(cbind(mb, bh, bl, nh) ~ epoch, data=Skulls)

</code></pre>

<hr>
<h2 id='bbox3d'>Find the bounding box of a <code>rgl::mesh3d</code> or <code>rgl::qmesh3d</code> object</h2><span id='topic+bbox3d'></span>

<h3>Description</h3>

<p>Ellipsoids are created by <span class="pkg">rgl</span> functions as meshes of points, segments, ... from coordinates
in various forms. This function calculates the bounding box, defined as the range of the
x, y, and z coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bbox3d(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bbox3d_+3A_x">x</code></td>
<td>
<p>A mesh3d object</p>
</td></tr>
<tr><td><code id="bbox3d_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2 x 3 matrix, giving the minimum and maximum values in the rows and x, y, z coordinates
in the columns.
</p>

<hr>
<h2 id='Bees'>Captive and maltreated bees</h2><span id='topic+Bees'></span>

<h3>Description</h3>

<p>Pabalan, Davey and Packe (2000) studied the effects of captivity and
maltreatment on reproductive capabilities of queen and worker bees in a
complex factorial design.
</p>


<h3>Format</h3>

<p>A data frame with 246 observations on the following 6 variables.
</p>
 
<dl>
<dt><code>caste</code></dt><dd><p>a factor with levels <code>Queen</code> <code>Worker</code></p>
</dd> 
<dt><code>treat</code></dt><dd><p>a factor with levels <code>""</code> <code>CAP</code> <code>MAL</code></p>
</dd> 
<dt><code>time</code></dt><dd><p>an ordered factor: time of treatment</p>
</dd> 
<dt><code>Iz</code></dt><dd><p>an index of ovarian development</p>
</dd>
<dt><code>Iy</code></dt><dd><p>an index of ovarian reabsorption</p>
</dd> 
<dt><code>trtime</code></dt><dd><p>a factor with levels <code>0</code> <code>CAP05</code> <code>CAP07</code> <code>CAP10</code>
<code>CAP12</code> <code>CAP15</code> <code>MAL05</code> <code>MAL07</code> <code>MAL10</code>
<code>MAL12</code> <code>MAL15</code></p>
</dd> 
</dl>



<h3>Details</h3>

<p>Bees were placed in a small tube and either held captive (CAP) or shaken
periodically (MAL) for one of 5, 7.5, 10, 12.5 or 15 minutes, after which
they were sacrificed and two measures: ovarian development (<code>Iz</code>) and
ovarian reabsorption (<code>Iy</code>), were taken. A single control group was
measured with no such treatment, i.e., at time 0; there are n=10 per group.
</p>
<p>The design is thus nearly a three-way factorial, with factors <code>caste</code>
(Queen, Worker), <code>treat</code> (CAP, MAL) and <code>time</code>, except that there
are only 11 combinations of Treatment and Time; we call these <code>trtime</code>
below.
</p>
<p>Models for the three-way factorial design, using the formula
<code>cbind(Iz,Iy) ~ caste*treat*time</code> ignore the control condition at
<code>time==0</code>, where <code>treat==NA</code>.
</p>
<p>To handle the additional control group at <code>time==0</code>, while separating
the effects of Treatment and Time, 10 contrasts can be defined for the
<code>trtime</code> factor in the model <code>cbind(Iz,Iy) ~ caste*trtime</code> See
<code>demo(bees.contrasts)</code> for details.
</p>
<p>In the <code>heplot</code> examples below, the default <code>size="evidence"</code>
displays are too crowded to interpret, because some effects are so highly
significant.  The alternative effect-size scaling, <code>size="effect"</code>,
makes the relations clearer.
</p>


<h3>Source</h3>

<p>Pabalan, N., Davey, K. G. &amp; Packe, L. (2000). Escalation of
Aggressive Interactions During Staged Encounters in Halictus ligatus Say
(Hymenoptera: Halictidae), with a Comparison of Circle Tube Behaviors with
Other Halictine Species <em>Journal of Insect Behavior</em>, <b>13</b>,
627-650.
</p>


<h3>References</h3>

<p>Friendly, M. (2006). Data Ellipses, HE Plots and Reduced-Rank
Displays for Multivariate Linear Models: SAS Software and Examples
<em>Journal of Statistical Software</em>, <b>17</b>, 1-42.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Bees)
require(car)

# 3-way factorial, ignoring 0 group
bees.mod &lt;- lm(cbind(Iz,Iy) ~ caste*treat*time, data=Bees)
car::Anova(bees.mod)

op&lt;-palette(c(palette()[1:4],"brown","magenta", "olivedrab","darkgray"))
heplot(bees.mod, 
    xlab="Iz: Ovarian development", 
    ylab="Iz: Ovarian reabsorption",
		main="Bees: ~caste*treat*time")

heplot(bees.mod, size="effect",
    xlab="Iz: Ovarian development", 
    ylab="Iz: Ovarian reabsorption",
    main="Bees: ~caste*treat*time", 
    )

# two-way design, using trtime
bees.mod1 &lt;- lm(cbind(Iz,Iy) ~ caste*trtime, data=Bees)
Anova(bees.mod1)

# HE plots for this model, with both significance and effect size scaling

heplot(bees.mod1, 
    xlab="Iz: Ovarian development", 
    ylab="Iz: Ovarian reabsorption",
		main="Bees: ~caste*trtime")
heplot(bees.mod1, 
    xlab="Iz: Ovarian development", 
    ylab="Iz: Ovarian reabsorption",
    main="Bees: ~caste*trtime",
    size="effect")
palette(op)

# effect plots for separate responses
if(require(effects)) {
	bees.lm1 &lt;-lm(Iy ~ treat*caste*time, data=Bees)
	bees.lm2 &lt;-lm(Iz ~ treat*caste*time, data=Bees)
	
	bees.eff1 &lt;- allEffects(bees.lm1)
	plot(bees.eff1,multiline=TRUE,ask=FALSE)
	
	bees.eff2 &lt;- allEffects(bees.lm2)
	plot(bees.eff2,multiline=TRUE,ask=FALSE)
}


</code></pre>

<hr>
<h2 id='boxM'>Box's M-test</h2><span id='topic+boxM'></span><span id='topic+boxM.formula'></span><span id='topic+boxM.lm'></span><span id='topic+boxM.default'></span><span id='topic+summary.boxM'></span>

<h3>Description</h3>

<p><code>boxM</code> performs the Box's (1949) M-test for homogeneity of covariance
matrices obtained from multivariate normal data according to one or more
classification factors. The test compares the product of the log
determinants of the separate covariance matrices to the log determinant of
the pooled covariance matrix, analogous to a likelihood ratio test. The test
statistic uses a chi-square approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxM(Y, ...)

## Default S3 method:
boxM(Y, group, ...)

## S3 method for class 'formula'
boxM(Y, data, ...)

## S3 method for class 'lm'
boxM(Y, ...)

## S3 method for class 'boxM'
summary(object, digits = getOption("digits"), cov = FALSE, quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boxM_+3A_y">Y</code></td>
<td>
<p>The response variable matrix for the default method, or a
<code>"mlm"</code> or <code>"formula"</code> object for a multivariate linear model.  If
<code>Y</code> is a linear-model object or a formula, the variables on the
right-hand-side of the model must all be factors and must be completely
crossed, e.g., <code>A:B</code></p>
</td></tr>
<tr><td><code id="boxM_+3A_...">...</code></td>
<td>
<p>Arguments passed down to methods.</p>
</td></tr>
<tr><td><code id="boxM_+3A_group">group</code></td>
<td>
<p>a factor defining groups, or a vector of length <em>n</em> doing
the same.</p>
</td></tr>
<tr><td><code id="boxM_+3A_data">data</code></td>
<td>
<p>a numeric data.frame or matrix containing <em>n</em> observations
of <em>p</em> variables; it is expected that <em>n &gt; p</em>.</p>
</td></tr>
<tr><td><code id="boxM_+3A_object">object</code></td>
<td>
<p>a <code>"boxM"</code> object for the <code>summary</code> method</p>
</td></tr>
<tr><td><code id="boxM_+3A_digits">digits</code></td>
<td>
<p>number of digits to print for the <code>summary</code> method</p>
</td></tr>
<tr><td><code id="boxM_+3A_cov">cov</code></td>
<td>
<p>logical; if <code>TRUE</code> the covariance matrices are printed.</p>
</td></tr>
<tr><td><code id="boxM_+3A_quiet">quiet</code></td>
<td>
<p>logical; if <code>TRUE</code> printing from the <code>summary</code> is
suppressed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As an object of class <code>"htest"</code>, the statistical test is printed
normally by default. As an object of class <code>"boxM"</code>, a few methods are
available.
</p>
<p>There is no general provision as yet for handling missing data.  Missing
data are simply removed, with a warning.
</p>
<p>As well, the computation assumes that the covariance matrix for each group
is non-singular, so that <code class="reqn">log det(S_i)</code> can be calculated for each
group. At the minimum, this requires that <code class="reqn">n &gt; p</code> for each group.
</p>
<p>Box's M test for a multivariate linear model highly sensitive to departures
from multivariate normality, just as the analogous univariate test.  It is
also affected adversely by unbalanced designs.  Some people recommend to
ignore the result unless it is very highly significant, e.g., p &lt; .0001 or
worse.
</p>
<p>The <code>summary</code> method prints a variety of additional statistics based on
the eigenvalues of the covariance matrices.  These are returned invisibly,
as a list containing the following components: 
</p>
 
<ul>
<li> <p><code>logDet</code> - log determinants 
</p>
</li>
<li> <p><code>eigs</code> - eigenvalues of the covariance matrices 
</p>
</li>
<li> <p><code>eigstats</code> - statistics computed on the eigenvalues for each covariance matrix:<br /> 
<code>product</code>: the product of eigenvalues, <code class="reqn">\prod{\lambda_i}</code>;<br /> 
<code>sum</code>: the sum of eigenvalues, <code class="reqn">\sum{\lambda_i}</code>;<br /> 
<code>precision</code>: the average precision of eigenvalues, <code class="reqn">1/\sum(1/\lambda_i)</code>;<br /> 
<code>max</code>: the maximum eigenvalue, <code class="reqn">\lambda_1</code> 
</p>
</li></ul>



<h3>Value</h3>

<p>A list with class <code>c("htest", "boxM")</code> containing the following
components: 
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>an approximated value of the chi-square
distribution.</p>
</td></tr> 
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom related of the test
statistic in this case that it follows a Chi-square distribution.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr> 
<tr><td><code>cov</code></td>
<td>
<p>a list containing the
within covariance matrix for each level of <code>grouping</code>.</p>
</td></tr> 
<tr><td><code>pooled</code></td>
<td>
<p>the pooled covariance matrix.</p>
</td></tr> 
<tr><td><code>logDet</code></td>
<td>
<p>a vector containing the natural logarithm of each matrix in <code>cov</code>, followed by the value for
the pooled covariance matrix</p>
</td></tr> 
<tr><td><code>means</code></td>
<td>
<p>a matrix of the means for all groups, followed by the grand means</p>
</td></tr> 
<tr><td><code>df</code></td>
<td>
<p>a vector of the degrees of freedom for all groups, followed by that for the pooled covariance matrix</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the names of the data.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the character string &quot;Box's M-test for Homogeneity of
Covariance Matrices&quot;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>The default method was taken from the <span class="pkg">biotools</span> package,
Anderson Rodrigo da Silva <a href="mailto:anderson.agro@hotmail.com">anderson.agro@hotmail.com</a>
</p>
<p>Generalized by Michael Friendly and John Fox
</p>


<h3>References</h3>

<p>Box, G. E. P. (1949). A general distribution theory for a class
of likelihood criteria. <em>Biometrika</em>, 36, 317-346.
</p>
<p>Morrison, D.F. (1976) <em>Multivariate Statistical Methods</em>.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+leveneTest">leveneTest</a></code> carries out homogeneity of variance
tests for univariate models with better statistical properties.
</p>
<p><code><a href="#topic+plot.boxM">plot.boxM</a></code>, a simple plot of the log determinants
</p>
<p><code><a href="#topic+covEllipses">covEllipses</a></code> plots covariance ellipses in variable space for
several groups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iris)

# default method
res &lt;- boxM(iris[, 1:4], iris[, "Species"])
res

# summary method gives details
summary(res)

# visualize (what is done in the plot method) 
dets &lt;- res$logDet
ng &lt;- length(res$logDet)-1
dotchart(dets, xlab = "log determinant")
points(dets , 1:4,  
	cex=c(rep(1.5, ng), 2.5), 
	pch=c(rep(16, ng), 15),
	col= c(rep("blue", ng), "red"))
	
	# plot method gives confidence intervals for logDet
plot(res, gplabel="Species")

# formula method
boxM( cbind(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width) ~ Species, data=iris)

### Skulls dat
data(Skulls)
# lm method
skulls.mod &lt;- lm(cbind(mb, bh, bl, nh) ~ epoch, data=Skulls)
boxM(skulls.mod)




</code></pre>

<hr>
<h2 id='coefplot'>Coefficient plots for Multivariate Linear Models</h2><span id='topic+coefplot'></span><span id='topic+coefplot.mlm'></span>

<h3>Description</h3>

<p>Displays confidence ellipses for all parameters in an multivariate linear
model, for a given pair of variables.  As such, it is a generalization of
<code><a href="car.html#topic+confidenceEllipse">confidenceEllipse</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefplot(object, ...)

## S3 method for class 'mlm'
coefplot(
  object,
  variables = 1:2,
  parm = NULL,
  df = NULL,
  level = 0.95,
  intercept = FALSE,
  Scheffe = FALSE,
  bars = TRUE,
  fill = FALSE,
  fill.alpha = 0.2,
  labels = !add,
  label.pos = NULL,
  xlab,
  ylab,
  xlim = NULL,
  ylim = NULL,
  axes = TRUE,
  main = "",
  add = FALSE,
  lwd = 1,
  lty = 1,
  pch = 19,
  col = palette(),
  cex = 2,
  cex.label = 1.5,
  lty.zero = 3,
  col.zero = 1,
  pch.zero = "+",
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coefplot_+3A_object">object</code></td>
<td>
<p>A multivariate linear model, such as fit by <code>lm(cbind(y1,
y2, ...) ~ ...)</code></p>
</td></tr>
<tr><td><code id="coefplot_+3A_...">...</code></td>
<td>
<p>Other parameters passed to methods</p>
</td></tr>
<tr><td><code id="coefplot_+3A_variables">variables</code></td>
<td>
<p>Response variables to plot, given as their indices or names</p>
</td></tr>
<tr><td><code id="coefplot_+3A_parm">parm</code></td>
<td>
<p>Parameters to plot, given as their indices or names</p>
</td></tr>
<tr><td><code id="coefplot_+3A_df">df</code></td>
<td>
<p>Degrees of freedom for hypothesis tests</p>
</td></tr>
<tr><td><code id="coefplot_+3A_level">level</code></td>
<td>
<p>Confidence level for the confidence ellipses</p>
</td></tr>
<tr><td><code id="coefplot_+3A_intercept">intercept</code></td>
<td>
<p>logical. Include the intercept?</p>
</td></tr>
<tr><td><code id="coefplot_+3A_scheffe">Scheffe</code></td>
<td>
<p>If <code>TRUE</code>, confidence intervals for all parameters have
Scheffe coverage, otherwise, individual coverage.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_bars">bars</code></td>
<td>
<p>Draw univariate confidence intervals for each of the variables?</p>
</td></tr>
<tr><td><code id="coefplot_+3A_fill">fill</code></td>
<td>
<p>a logical value or vector. <code>TRUE</code> means the confidence
ellipses will be filled.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_fill.alpha">fill.alpha</code></td>
<td>
<p>Opacity of the confidence ellipses</p>
</td></tr>
<tr><td><code id="coefplot_+3A_labels">labels</code></td>
<td>
<p>Labels for the confidence ellipses</p>
</td></tr>
<tr><td><code id="coefplot_+3A_label.pos">label.pos</code></td>
<td>
<p>Positions of the labels for each ellipse.  See
<code><a href="#topic+label.ellipse">label.ellipse</a></code></p>
</td></tr>
<tr><td><code id="coefplot_+3A_xlab">xlab</code>, <code id="coefplot_+3A_ylab">ylab</code></td>
<td>
<p>x, y axis labels</p>
</td></tr>
<tr><td><code id="coefplot_+3A_xlim">xlim</code>, <code id="coefplot_+3A_ylim">ylim</code></td>
<td>
<p>Axis limits</p>
</td></tr>
<tr><td><code id="coefplot_+3A_axes">axes</code></td>
<td>
<p>Draw axes?</p>
</td></tr>
<tr><td><code id="coefplot_+3A_main">main</code></td>
<td>
<p>Plot title</p>
</td></tr>
<tr><td><code id="coefplot_+3A_add">add</code></td>
<td>
<p>logical. Add to an existing plot?</p>
</td></tr>
<tr><td><code id="coefplot_+3A_lwd">lwd</code></td>
<td>
<p>Line widths</p>
</td></tr>
<tr><td><code id="coefplot_+3A_lty">lty</code></td>
<td>
<p>Line types</p>
</td></tr>
<tr><td><code id="coefplot_+3A_pch">pch</code></td>
<td>
<p>Point symbols for the parameter estimates</p>
</td></tr>
<tr><td><code id="coefplot_+3A_col">col</code></td>
<td>
<p>Colors for the confidence ellipses, points, lines</p>
</td></tr>
<tr><td><code id="coefplot_+3A_cex">cex</code></td>
<td>
<p>Character size for points showing parameter estimates</p>
</td></tr>
<tr><td><code id="coefplot_+3A_cex.label">cex.label</code></td>
<td>
<p>Character size for ellipse labels</p>
</td></tr>
<tr><td><code id="coefplot_+3A_lty.zero">lty.zero</code>, <code id="coefplot_+3A_col.zero">col.zero</code>, <code id="coefplot_+3A_pch.zero">pch.zero</code></td>
<td>
<p>Line type, color and point symbol for
horizontal and vertical lines at 0, 0.</p>
</td></tr>
<tr><td><code id="coefplot_+3A_verbose">verbose</code></td>
<td>
<p>logical.  Print parameter estimates and variance-covariance
for each parameter?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns invisibly a list of the coordinates of the ellipses drawn
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+confidenceEllipse">confidenceEllipse</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rohwer.mlm &lt;- lm(cbind(SAT,PPVT,Raven)~n+s+ns, data=Rohwer)

coefplot(rohwer.mlm, lwd=2, 
         main="Bivariate coefficient plot for SAT and PPVT", fill=TRUE)
coefplot(rohwer.mlm, add=TRUE, Scheffe=TRUE, fill=TRUE)

coefplot(rohwer.mlm, var=c(1,3))

mod1 &lt;- lm(cbind(SAT,PPVT,Raven)~n+s+ns+na+ss, data=Rohwer)
coefplot(mod1, lwd=2, fill=TRUE, parm=(1:5),
	main="Bivariate 68% coefficient plot for SAT and PPVT", level=0.68)


</code></pre>

<hr>
<h2 id='colDevs'>Calculate column deviations from central values</h2><span id='topic+colDevs'></span>

<h3>Description</h3>

<p><code>colDevs</code> calculates the column deviations of data values from a
central value (mean, median, etc.), possibly stratified by a grouping
variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colDevs(x, group, center = mean, group.var = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colDevs_+3A_x">x</code></td>
<td>
<p>A numeric data frame or matrix.</p>
</td></tr>
<tr><td><code id="colDevs_+3A_group">group</code></td>
<td>
<p>A factor (or variable that can be coerced to a factor)
indicating the membership of each observation in <code>x</code> in one or more
groups. If missing, all the data is treated as a single group.
You can also specify the <code><a href="base.html#topic+interaction">interaction</a></code> of two or more
factors.</p>
</td></tr>
<tr><td><code id="colDevs_+3A_center">center</code></td>
<td>
<p>A function used to center the values (for each group if
<code>group</code> is specified. The function must take a vector argument and
return a scalar result.</p>
</td></tr>
<tr><td><code id="colDevs_+3A_group.var">group.var</code></td>
<td>
<p>logical. If <code>TRUE</code>, the <code>group</code> variable containing factor levels is prepended to the
matrix of deviations.</p>
</td></tr>
<tr><td><code id="colDevs_+3A_...">...</code></td>
<td>
<p>Arguments passed down</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conceptually, the function is similar to a column-wise
<code><a href="base.html#topic+sweep">sweep</a></code>, by group, allowing an arbitrary <code>center</code>
function.
</p>
<p>Non-numeric columns of <code>x</code> are removed, with a warning.
</p>


<h3>Value</h3>

<p>By default, it returns a numeric matrix containing the deviations from the centering
function. If <code>levels==TRUE</code>, it returns a data.frame containing the group factor prepended to the
matrix of deviations.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+colMeans">colMeans</a></code> for column means,
</p>
<p><code><a href="base.html#topic+sweep">sweep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iris)

Species &lt;- iris$Species
irisdev &lt;- colDevs(iris[,1:4], Species, mean)

irisdev &lt;- colDevs(iris[,1:4], Species, median)
# trimmed mean, using an anonymous function
irisdev &lt;- colDevs(iris[,1:4], Species, function(x) mean(x, trim=0.25))

# include the group factor in output
irisdev &lt;- colDevs(iris[,1:4], Species, group.var = "Species")
head(irisdev)

# no grouping variable: deviations from column grand means
# include all variables (but suppress warning for this doc)
irisdev &lt;- suppressWarnings( colDevs(iris) )

# two-way design
colDevs(Plastic[,1:3], Plastic[,"rate"])
colDevs(Plastic[,1:3], Plastic[,"additive"])
# cell deviations
#' colDevs(Plastic[,1:3], interaction(Plastic[,c("rate", "additive")]))
</code></pre>

<hr>
<h2 id='covEllipses'>Draw classical and robust covariance ellipses for one or more groups</h2><span id='topic+covEllipses'></span><span id='topic+covEllipses.boxM'></span><span id='topic+covEllipses.data.frame'></span><span id='topic+covEllipses.matrix'></span><span id='topic+covEllipses.default'></span><span id='topic+covEllipses.formula'></span>

<h3>Description</h3>

<p>The function draws covariance ellipses for one or more groups and optionally
for the pooled total sample.  It uses either the classical product-moment
covariance estimate, or a robust alternative, as provided by
<code><a href="MASS.html#topic+cov.rob">cov.rob</a></code>. Provisions are provided to do this for more
than two variables, in a scatterplot matrix format.
</p>
<p>These plot methods provide one way to visualize possible heterogeneity of
within-group covariance matrices in a one-way MANOVA design. When covariance
matrices are nearly equal, their covariance ellipses should all have the
same shape.  When centered at a common mean, they should also all overlap.
</p>
<p>They can also be used to visualize the difference between classical and
robust covariance matrices by overlaying the two in a single plot (via <code>add=TRUE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covEllipses(x, ...)

## S3 method for class 'data.frame'
covEllipses(
  x,
  group,
  pooled = TRUE,
  method = c("classical", "mve", "mcd"),
  ...
)

## S3 method for class 'matrix'
covEllipses(
  x,
  group,
  pooled = TRUE,
  method = c("classical", "mve", "mcd"),
  ...
)

## S3 method for class 'formula'
covEllipses(x, data, ...)

## S3 method for class 'boxM'
covEllipses(x, ...)

## Default S3 method:
covEllipses(
  x,
  means,
  df,
  labels = NULL,
  variables = 1:2,
  level = 0.68,
  segments = 60,
  center = FALSE,
  center.pch = "+",
  center.cex = 2,
  col = getOption("heplot.colors", c("red", "blue", "black", "darkgreen", "darkcyan",
    "brown", "magenta", "darkgray")),
  lty = 1,
  lwd = 2,
  fill = FALSE,
  fill.alpha = 0.3,
  label.pos = 0,
  xlab,
  ylab,
  vlabels,
  var.cex = 2,
  main = "",
  xlim,
  ylim,
  axes = TRUE,
  offset.axes,
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covEllipses_+3A_x">x</code></td>
<td>
<p>The generic argument. For the default method, this is a list of
covariance matrices. For the <code>data.frame</code> and <code>matrix</code> methods,
this is a numeric matrix of two or more columns supplying the variables to
be analyzed.</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the default method for <code>plot</code>,
<code>text</code>, and <code>points</code></p>
</td></tr>
<tr><td><code id="covEllipses_+3A_group">group</code></td>
<td>
<p>a factor defining groups, or a vector of length
<code>n=nrow(x)</code> doing the same. If missing, a single covariance ellipse is
drawn.</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_pooled">pooled</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the pooled covariance matrix for the
total sample is also computed and plotted</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_method">method</code></td>
<td>
<p>the covariance method to be used: classical product-moment
(<code>"classical"</code>), or minimum volume ellipsoid (<code>"mve"</code>), or minimum
covariance determinant (<code>"mcd"</code>).</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_data">data</code></td>
<td>
<p>For the <code>formula</code> method, a data.frame in which to evaluate.</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_means">means</code></td>
<td>
<p>For the default method, a matrix of the means for all groups
(followed by the grand means, if <code>pooled=TRUE</code>). Rows are the groups,
and columns are the variables. It is assumed that the means have column
names corresponding to the variables in the covariance matrices.</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_df">df</code></td>
<td>
<p>For the default method, a vector of the degrees of freedom for the
covariance matrices</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_labels">labels</code></td>
<td>
<p>Either a character vector of labels for the groups, or
<code>TRUE</code>, indicating that group labels are taken as the names of the
covariance matrices. Use <code>labels=""</code> to suppress group labels, e.g.,
when <code>add=TRUE</code></p>
</td></tr>
<tr><td><code id="covEllipses_+3A_variables">variables</code></td>
<td>
<p>indices or names of the response variables to be plotted;
defaults to <code>1:2</code>.  If more than two variables are supplied, the
function plots all pairwise covariance ellipses in a scatterplot matrix
format.</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_level">level</code></td>
<td>
<p>equivalent coverage of a data ellipse for normally-distributed
errors, defaults to <code>0.68</code>.</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_segments">segments</code></td>
<td>
<p>number of line segments composing each ellipse; defaults to
<code>40</code>.</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_center">center</code></td>
<td>
<p>If <code>TRUE</code>, the covariance ellipses are centered at the
centroid.</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_center.pch">center.pch</code></td>
<td>
<p>character to use in plotting the centroid of the data;
defaults to <code>"+"</code>.</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_center.cex">center.cex</code></td>
<td>
<p>size of character to use in plotting the centroid (means) of the
data; defaults to <code>2</code>.</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_col">col</code></td>
<td>
<p>a color or vector of colors to use in plotting ellipses&mdash;
recycled as necessary&mdash; see Details. A single color can be given, in which case it is used
for all ellipses.  For convenience, the default colors for all plots
produced in a given session can be changed by assigning a color vector via
<code>options(heplot.colors =c(...)</code>.  Otherwise, the default colors are
<code>c("red", "blue", "black", "darkgreen", "darkcyan", "magenta", "brown",
"darkgray")</code>.</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_lty">lty</code></td>
<td>
<p>vector of line types to use for plotting the ellipses&mdash;
recycled as necessary&mdash; see Details.  Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_lwd">lwd</code></td>
<td>
<p>vector of line widths to use for plotting the ellipses&mdash;
recycled as necessary&mdash; see Details.  Defaults to
<code>2</code>.</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_fill">fill</code></td>
<td>
<p>A logical vector indicating whether each ellipse should be
filled or not&mdash; recycled as necessary&mdash; see Details.   Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_fill.alpha">fill.alpha</code></td>
<td>
<p>Alpha transparency for filled ellipses, a numeric scalar
or vector of values within <code>[0,1]</code>, where 0 means fully transparent and
1 means fully opaque. Defaults to 0.3.</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_label.pos">label.pos</code></td>
<td>
<p>Label position, a vector of integers (in <code>0:4</code>) or
character strings (in <code>c("center", "bottom", "left", "top", "right")</code>)
use in labeling ellipses, recycled as necessary.  Values of 1, 2, 3 and 4,
respectively indicate positions below, to the left of, above and to the
right of the max/min coordinates of the ellipse; the value 0 specifies the
centroid of the <code>ellipse</code> object.  The default, <code>label.pos=NULL</code>
uses the correlation of the <code>ellipse</code> to determine &quot;top&quot; (r&gt;=0) or
&quot;bottom&quot; (r&lt;0).</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label; defaults to name of the x variable.</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label; defaults to name of the y variable.</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_vlabels">vlabels</code></td>
<td>
<p>Labels for the variables can also be supplied through this
argument, which is more convenient when <code>length(variables) &gt; 2</code>.</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_var.cex">var.cex</code></td>
<td>
<p>character size for variable labels in the pairs plot, when <code>length(variables) &gt; 2</code>.</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_main">main</code></td>
<td>
<p>main plot label; defaults to <code>""</code>, and presently has no
effect.</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_xlim">xlim</code></td>
<td>
<p>x-axis limits; if absent, will be computed from the data.</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_ylim">ylim</code></td>
<td>
<p>y-axis limits; if absent, will be computed from the data.</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_axes">axes</code></td>
<td>
<p>Whether to draw the x, y axes; defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="covEllipses_+3A_offset.axes">offset.axes</code></td>
<td>
<p>proportion to extend the axes in each direction if
computed from the data; optional.</p>
</td></tr>
<tr><td><code id="covEllipses_+3A_add">add</code></td>
<td>
<p>if <code>TRUE</code>, add to the current plot; the default is
<code>FALSE</code>. This argument is has no effect when more than two variables
are plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>labels</code>,
<code>col</code>, <code>lty</code>, <code>lwd</code>, <code>fill</code>, <code>fill.alpha</code> and <code>label.pos</code> are used to
draw the ellipses for the groups and also for the pooled, within-group covariance, which is the <b>last</b> in a list
when these are computed by the functions. 
These arguments are each taken in the order specified, and recycled as necessary.
</p>


<h3>Value</h3>

<p>Nothing is returned.  The function is used for its side-effect of
producing a plot. 
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="#topic+heplot">heplot</a></code>, <code><a href="#topic+boxM">boxM</a></code>,
</p>
<p><code><a href="MASS.html#topic+cov.rob">cov.rob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(iris)

# compare classical and robust covariance estimates
covEllipses(iris[,1:4], iris$Species)
covEllipses(iris[,1:4], iris$Species, fill=TRUE, method="mve", add=TRUE, labels="")

# method for a boxM object	
x &lt;- boxM(iris[, 1:4], iris[, "Species"])
x
covEllipses(x, fill=c(rep(FALSE,3), TRUE) )
covEllipses(x, fill=c(rep(FALSE,3), TRUE), center=TRUE, label.pos=1:4 )

# method for a list of covariance matrices
cov &lt;- c(x$cov, pooled=list(x$pooled))
df &lt;- c(table(iris$Species)-1, nrow(iris)-3)
covEllipses(cov, x$means, df, label.pos=3, fill=c(rep(FALSE,3), TRUE))
 
covEllipses(cov, x$means, df, label.pos=3, fill=c(rep(FALSE,3), TRUE), center=TRUE)

# scatterplot matrix version
covEllipses(iris[,1:4], iris$Species, 
	fill=c(rep(FALSE,3), TRUE), variables=1:4, 
	fill.alpha=.1)


</code></pre>

<hr>
<h2 id='cqplot'>Chi Square Quantile-Quantile plots</h2><span id='topic+cqplot'></span><span id='topic+cqplot.default'></span><span id='topic+cqplot.mlm'></span>

<h3>Description</h3>

<p>A chi square quantile-quantile plots show the relationship between
data-based values which should be distributed as <code class="reqn">\chi^2</code> and
corresponding quantiles from the <code class="reqn">\chi^2</code> distribution.  In multivariate
analyses, this is often used both to assess multivariate normality and check
for outliers, using the Mahalanobis squared distances (<code class="reqn">D^2</code>) of
observations from the centroid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cqplot(x, ...)

## S3 method for class 'mlm'
cqplot(x, ...)

## Default S3 method:
cqplot(
  x,
  method = c("classical", "mcd", "mve"),
  detrend = FALSE,
  pch = 19,
  col = palette()[1],
  cex = par("cex"),
  ref.col = "red",
  ref.lwd = 2,
  conf = 0.95,
  env.col = "gray",
  env.lwd = 2,
  env.lty = 1,
  env.fill = TRUE,
  fill.alpha = 0.2,
  fill.color = trans.colors(ref.col, fill.alpha),
  labels = if (!is.null(rownames(x))) rownames(x) else 1:nrow(x),
  id.n,
  id.method = "y",
  id.cex = 1,
  id.col = palette()[1],
  xlab,
  ylab,
  main,
  what = deparse(substitute(x)),
  ylim,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cqplot_+3A_x">x</code></td>
<td>
<p>either a numeric data frame or matrix for the default method, or an
object of class <code>"mlm"</code> representing a multivariate linear model.  In
the latter case, residuals from the model are plotted.</p>
</td></tr>
<tr><td><code id="cqplot_+3A_...">...</code></td>
<td>
<p>Other arguments passed to methods</p>
</td></tr>
<tr><td><code id="cqplot_+3A_method">method</code></td>
<td>
<p>estimation method used for center and covariance, one of:
<code>"classical"</code> (product-moment), <code>"mcd"</code> (minimum covariance
determinant), or <code>"mve"</code> (minimum volume ellipsoid).</p>
</td></tr>
<tr><td><code id="cqplot_+3A_detrend">detrend</code></td>
<td>
<p>logical; if <code>FALSE</code>, the plot shows values of <code class="reqn">D^2</code>
vs. <code class="reqn">\chi^2</code>. if <code>TRUE</code>, the ordinate shows values of <code class="reqn">D^2 -
\chi^2</code></p>
</td></tr>
<tr><td><code id="cqplot_+3A_pch">pch</code></td>
<td>
<p>plot symbol for points. Can be a vector of length equal to the
number of rows in <code>x</code>.</p>
</td></tr>
<tr><td><code id="cqplot_+3A_col">col</code></td>
<td>
<p>color for points. Can be a vector of length equal to the
number of rows in <code>x</code>.
The default is the <em>first</em> entry in the
current color palette (see <code><a href="grDevices.html#topic+palette">palette</a></code> and
<code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="cqplot_+3A_cex">cex</code></td>
<td>
<p>character symbol size for points.  Can be a vector of length
equal to the number of rows in <code>x</code>.</p>
</td></tr>
<tr><td><code id="cqplot_+3A_ref.col">ref.col</code></td>
<td>
<p>Color for the reference line</p>
</td></tr>
<tr><td><code id="cqplot_+3A_ref.lwd">ref.lwd</code></td>
<td>
<p>Line width for the reference line</p>
</td></tr>
<tr><td><code id="cqplot_+3A_conf">conf</code></td>
<td>
<p>confidence coverage for the approximate confidence envelope</p>
</td></tr>
<tr><td><code id="cqplot_+3A_env.col">env.col</code></td>
<td>
<p>line color for the boundary of the confidence envelope</p>
</td></tr>
<tr><td><code id="cqplot_+3A_env.lwd">env.lwd</code></td>
<td>
<p>line width for the confidence envelope</p>
</td></tr>
<tr><td><code id="cqplot_+3A_env.lty">env.lty</code></td>
<td>
<p>line type for the confidence envelope</p>
</td></tr>
<tr><td><code id="cqplot_+3A_env.fill">env.fill</code></td>
<td>
<p>logical; should the confidence envelope be filled?</p>
</td></tr>
<tr><td><code id="cqplot_+3A_fill.alpha">fill.alpha</code></td>
<td>
<p>transparency value for <code>fill.color</code></p>
</td></tr>
<tr><td><code id="cqplot_+3A_fill.color">fill.color</code></td>
<td>
<p>color used to fill the confidence envelope</p>
</td></tr>
<tr><td><code id="cqplot_+3A_labels">labels</code></td>
<td>
<p>vector of text strings to be used to identify points, defaults
to <code>rownames(x)</code> or observation numbers if <code>rownames(x)</code> is
<code>NULL</code></p>
</td></tr>
<tr><td><code id="cqplot_+3A_id.n">id.n</code></td>
<td>
<p>number of points labeled. If <code>id.n=0</code>, the default, no
point identification occurs.</p>
</td></tr>
<tr><td><code id="cqplot_+3A_id.method">id.method</code></td>
<td>
<p>point identification method. The default
<code>id.method="y"</code> will identify the <code>id.n</code> points with the largest
value of abs(y-mean(y)). See <code><a href="car.html#topic+showLabels">showLabels</a></code> for other
options.</p>
</td></tr>
<tr><td><code id="cqplot_+3A_id.cex">id.cex</code></td>
<td>
<p>size of text for point labels</p>
</td></tr>
<tr><td><code id="cqplot_+3A_id.col">id.col</code></td>
<td>
<p>color for point labels</p>
</td></tr>
<tr><td><code id="cqplot_+3A_xlab">xlab</code></td>
<td>
<p>label for horizontal (theoretical quantiles) axis</p>
</td></tr>
<tr><td><code id="cqplot_+3A_ylab">ylab</code></td>
<td>
<p>label for vertical (empirical quantiles) axis</p>
</td></tr>
<tr><td><code id="cqplot_+3A_main">main</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="cqplot_+3A_what">what</code></td>
<td>
<p>the name of the object plotted; used in the construction of
<code>main</code> when that is not specified.</p>
</td></tr>
<tr><td><code id="cqplot_+3A_ylim">ylim</code></td>
<td>
<p>limits for vertical axis.  If not specified, the range of the
confidence envelope is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cqplot</code> is a more general version of similar functions in other
packages that produce chi square QQ plots. It allows for classical
Mahalanobis squared distances as well as robust estimates based on the MVE
and MCD; it provides an approximate confidence (concentration) envelope
around the line of unit slope, a detrended version, where the reference line
is horizontal, the ability to identify or label unusual points, and other
graphical features.
</p>
<p>The method for <code>"mlm"</code> objects applies this to the residuals from the
model.
</p>
<p>The calculation of the confidence envelope follows that used in the SAS
program, <a href="http://www.datavis.ca/sasmac/cqplot.html">http://www.datavis.ca/sasmac/cqplot.html</a> which comes from
Chambers et al. (1983), Section 6.8.
</p>
<p>The essential formula is 
</p>
<p style="text-align: center;"><code class="reqn"> SE ( z_{(i)} ) = \hat{\delta} /g ( q_i)) \times \sqrt{  p_i (1-p_i) / n } </code>
</p>

<p>where <code class="reqn">z_{(i)}</code> is the i-th
order value of <code class="reqn">D^2</code>, <code class="reqn">\hat{\delta}</code> is an estimate of the slope of
the reference line obtained from the corresponding quartiles and
<code class="reqn">g(q_i)</code> is the density of the chi square distribution at the quantile
<code class="reqn">q_i</code>.
</p>
<p>Note that this confidence envelope applies only to the <code class="reqn">D^2</code> computed
using the classical estimates of location and scatter. The
<code>car::qqPlot()</code> function provides for simulated envelopes, but only for
a univariate measure. Oldford (2016) provides a general theory and methods
for QQ plots.
</p>


<h3>Value</h3>

<p>Returns invisibly the vector of squared Mahalanobis distances
corresponding to the rows of <code>x</code> or the residuals of the model for the identified points, else <code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>References</h3>

<p>J. Chambers, W. S. Cleveland, B. Kleiner, P. A. Tukey (1983).
<em>Graphical methods for data analysis</em>, Wadsworth.
</p>
<p>R. W. Oldford (2016), &quot;Self calibrating quantile-quantile plots&quot;, 
<em>The American Statistician</em>, 70, 74-90.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Mahalanobis">Mahalanobis</a></code> for calculation of Mahalanobis squared distance;
</p>
<p><code><a href="stats.html#topic+qqplot">qqplot</a></code>; <code><a href="car.html#topic+qqPlot">qqPlot</a></code> can give a similar
result for Mahalanobis squared distances of data or residuals;
<code><a href="qqtest.html#topic+qqtest">qqtest</a></code> has many features for all types of QQ plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

cqplot(iris[, 1:4])

iris.mod &lt;- lm(as.matrix(iris[,1:4]) ~ Species, data=iris)
cqplot(iris.mod, id.n=3)

# compare with car::qqPlot
car::qqPlot(Mahalanobis(iris[, 1:4]), dist="chisq", df=4)


# Adopted data
Adopted.mod &lt;- lm(cbind(Age2IQ, Age4IQ, Age8IQ, Age13IQ) ~ AMED + BMIQ, 
                  data=Adopted)
cqplot(Adopted.mod, id.n=3)
cqplot(Adopted.mod, id.n=3, method="mve")


# Sake data
Sake.mod &lt;- lm(cbind(taste, smell) ~ ., data=Sake)
cqplot(Sake.mod)
cqplot(Sake.mod, method="mve", id.n=2)

# SocialCog data -- one extreme outlier
data(SocialCog)
SC.mlm &lt;-  lm(cbind(MgeEmotions,ToM, ExtBias, PersBias) ~ Dx,
               data=SocialCog)
cqplot(SC.mlm, id.n=1)

# data frame example: stackloss data
data(stackloss)
cqplot(stackloss[, 1:3], id.n=4)                # very strange
cqplot(stackloss[, 1:3], id.n=4, detrend=TRUE)
cqplot(stackloss[, 1:3], id.n=4, method="mve")
cqplot(stackloss[, 1:3], id.n=4, method="mcd")



</code></pre>

<hr>
<h2 id='cross3d'>Draw a 3D cross in an rgl scene</h2><span id='topic+cross3d'></span>

<h3>Description</h3>

<p>Draws a 3D cross or axis vectors in an rgl scene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross3d(centre = rep(0, 3), scale = rep(1, 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cross3d_+3A_centre">centre</code></td>
<td>
<p>A scalar or vector of length 3, giving the centre of the 3D cross</p>
</td></tr>
<tr><td><code id="cross3d_+3A_scale">scale</code></td>
<td>
<p>A scalar or vector of length 3, giving the lengths of the arms of the 3D cross</p>
</td></tr>
<tr><td><code id="cross3d_+3A_...">...</code></td>
<td>
<p>Other arguments, passed on to <code><a href="rgl.html#topic+segments3d">segments3d</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Used for its side-effect, but returns (invisibly) a 6 by 3 matrix
containing the end-points of three axes, in pairs.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="rgl.html#topic+points3d">segments3d</a></code>
</p>

<hr>
<h2 id='df.terms'>Find degrees of freedom for model terms</h2><span id='topic+df.terms'></span><span id='topic+df.terms.default'></span>

<h3>Description</h3>

<p>Find degrees of freedom for model terms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df.terms(model, term, ...)

## Default S3 method:
df.terms(model, term, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="df.terms_+3A_model">model</code></td>
<td>
<p>A model object, such as fit using <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
<tr><td><code id="df.terms_+3A_term">term</code></td>
<td>
<p>One or more terms from the model</p>
</td></tr>
<tr><td><code id="df.terms_+3A_...">...</code></td>
<td>
<p>Other arguments, ignored</p>
</td></tr>
</table>

<hr>
<h2 id='Diabetes'>Diabetes Dataset</h2><span id='topic+Diabetes'></span>

<h3>Description</h3>

<p>Reaven and Miller (1979) examined the relationship among blood chemistry
measures of glucose tolerance and insulin in 145 nonobese adults. They used
the PRIM9 system at the Stanford Linear Accelerator Center to visualize the
data in 3D, and discovered a peculiar pattern that looked like a large blob
with two wings in different directions.
</p>


<h3>Format</h3>

<p>A data frame with 145 observations on the following 6 variables.
</p>
 
<dl>
<dt><code>relwt</code></dt><dd><p>relative weight, expressed as the ratio of actual weight to expected weight, given the person's height, a numeric vector</p>
</dd> 
<dt><code>glufast</code></dt><dd><p>fasting plasma glucose level, a numeric vector</p>
</dd> 
<dt><code>glutest</code></dt><dd><p>test plasma glucose level, a measure of glucose intolerance, a numeric vector</p>
</dd> 
<dt><code>instest</code></dt><dd><p>plasma insulin during test, a measure of insulin response to oral glucose, a numeric vector</p>
</dd> 
<dt><code>sspg</code></dt><dd><p>steady state plasma glucose, a measure of insulin resistance, a numeric vector</p>
</dd> 
<dt><code>group</code></dt><dd><p>diagnostic group, a factor with levels <code>Normal</code> <code>Chemical_Diabetic</code>
<code>Overt_Diabetic</code></p>
</dd> 
</dl>



<h3>Details</h3>

<p>After further analysis, the subjects were classified as subclinical
(chemical) diabetics, overt diabetics and normals.  This study was
influential in defining the stages of development of Type 2 diabetes. Overt
diabetes is the most advanced stage, characterized by elevated fasting blood
glucose concentration and classical symptoms. Preceding overt diabetes is
the latent or chemical diabetic stage, with no symptoms of diabetes but
demonstrable abnormality of oral or intravenous glucose tolerance.
</p>
<p><code>glutest</code> was defined as the &quot;area under the plasma glucose curve for
the three hour oral glucose tolerance test.&quot;  Reaven &amp; Miller refer to this
variable as &quot;Glucose area&quot;.
</p>
<p><code>instest</code> was defined as the &quot;area under the plasma insulin curve&quot;, and
is referred to in the paper as &quot;Insulin area&quot;.
</p>
<p>This study was influential in defining the stages of development of Type 2
diabetes. Overt diabetes is the most advanced stage, characterized by
elevated fasting blood glucose concentration and classical symptoms.
Preceding overt diabetes is the latent or chemical diabetic stage, with no
symptoms of diabetes but demonstrable abnormality of oral or intravenous
glucose tolerance.
</p>


<h3>Source</h3>

<p>Andrews, D. F. &amp; Herzberg, A. M. (1985).  
<em>Data: A Collection
of Problems from Many Fields for the Student and Research Worker</em>,
Springer-Verlag, Ch. 36.
</p>
<p>Friendly, M. (1991). <em>SAS System for Statistical Graphics</em>, Cary, NC:
SAS Institute.
</p>


<h3>References</h3>

<p>Reaven, G. M. and Miller, R. G. (1979).  An attempt to define
the nature of chemical diabetes using a multidimensional analysis.
<em>Diabetologia</em>, 16, 17-24.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Diabetes)
col &lt;- c("blue", "red", "darkgreen")[Diabetes$group]
pch &lt;- c(16,15,17)[Diabetes$group]

# a perplexing plot, similar to Fig 2, but with a loess smooth 
plot(instest ~ glutest, data=Diabetes, pch=16,
	cex.lab=1.25,
	xlab="Glucose area (glutest)",
	ylab="Insulin area (instest)")
lines( loess.smooth(Diabetes$glutest, Diabetes$instest), col="blue", lwd=2) 

# scatterplot matrix, colored by group
plot(Diabetes[,1:5], col=col, pch=pch)

# covariance ellipses
covEllipses(Diabetes[,2:5], Diabetes$group, fill=TRUE, pooled=FALSE, 
	col=col)

covEllipses(Diabetes[,2:5], Diabetes$group, fill=TRUE, pooled=FALSE, 
	col=col, variables=1:4)

# Box's M test
diab.boxm &lt;- boxM(Diabetes[,2:5], Diabetes$group)
diab.boxm
plot(diab.boxm)

# heplots
diab.mlm &lt;- lm(cbind(glufast, glutest, instest, sspg) ~ group, data=Diabetes)

heplot(diab.mlm)
pairs(diab.mlm, fill=TRUE, fill.alpha=0.1)



</code></pre>

<hr>
<h2 id='dogfood'>Dogfood Preferences</h2><span id='topic+dogfood'></span>

<h3>Description</h3>

<p>A tiny hypothetical dataset to illustrate one-way MANOVA.
</p>
<p>A dogfood manufacturer wanted to study preference for different dogfood formulas, two of their own
(&quot;Old&quot;, &quot;New&quot;) and two from other manufacturers (&quot;Major&quot;, &quot;Alps&quot;). In a between-dog design, 4 dogs
were presented with a bowl of one <code>formula</code> and the time to <code>start</code> eating and <code>amount</code> eaten were recorded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dogfood")
</code></pre>


<h3>Format</h3>

<p>A data frame with 16 observations on the following 3 variables.
</p>

<dl>
<dt><code>formula</code></dt><dd><p>factor, a factor with levels <code>Old</code>, <code>New</code>, <code>Major</code>, <code>Alps</code></p>
</dd>
<dt><code>start</code></dt><dd><p>numeric, time to start eating</p>
</dd>
<dt><code>amount</code></dt><dd><p>numeric, amount eaten</p>
</dd>
</dl>



<h3>Details</h3>

<p>In addition to testing the overall effects of <code>formula</code>,
three useful (and orthogonal) contrasts can specified for this 3-df factor:
</p>

<ul>
<li> <p><code>Ours</code> vs. <code>Theirs</code>, with weights <code>c(1, 1, -1, -1)</code>
</p>
</li>
<li> <p><code>Major</code> vs. <code>Alps</code>, with weights <code>c(0, 0,  1, -1)</code>
</p>
</li>
<li> <p><code>Old</code> vs. <code>New</code>, with weights <code>c(1, -1, 0, 0)</code>
</p>
</li></ul>

<p>Because these are orthogonal contrasts, they fully decompose the main effect of <code>formula</code>,
in that their sum of squares add to the overall sum of squares.
</p>


<h3>Source</h3>

<p>Used in my Psych 6140 lecture notes, <a href="http://friendly.apps01.yorku.ca/psy6140/">http://friendly.apps01.yorku.ca/psy6140/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dogfood)
library(car)
library(candisc)

# make some boxplots
op &lt;- par(mfrow = c(1,2))
boxplot(start ~ formula, data = dogfood)
points(start ~ formula, data = dogfood, pch=16, cex = 1.2)

boxplot(amount ~ formula, data = dogfood)
points(amount ~ formula, data = dogfood, pch=16, cex = 1.2)
par(op)

# setup contrasts to test interesting comparisons
C &lt;- matrix(
       c( 1,  1, -1, -1,         #Ours vs. Theirs
          0,  0,  1, -1,           #Major vs. Alps
          1, -1,  0,  0),             #New vs. Old
       nrow=4, ncol=3)
# assign these to the formula factor
contrasts(dogfood$formula) &lt;- C
# re-fit the model
dogfood.mod &lt;- lm(cbind(start, amount) ~ formula, data=dogfood)

dogfood.mod &lt;- lm(cbind(start, amount) ~ formula, data=dogfood)
Anova(dogfood.mod)

# data ellipses
covEllipses(cbind(start, amount) ~ formula, data=dogfood,
  fill = TRUE, fill.alpha = 0.1)

# test these contrasts with multivariate tests 
linearHypothesis(dogfood.mod, "formula1", title="Ours vs. Theirs")
linearHypothesis(dogfood.mod, "formula2", title="Old vs. New")
linearHypothesis(dogfood.mod, "formula3", title="Alps vs. Major")

heplot(dogfood.mod, fill = TRUE, fill.alpha = 0.1)

# display contrasts in the heplot 
hyp &lt;- list("Ours/Theirs" = "formula1",
            "Old/New" = "formula2")
heplot(dogfood.mod, hypotheses = hyp,
       fill = TRUE, fill.alpha = 0.1)

dogfood.can &lt;- candisc(dogfood.mod, data=dogfood)
heplot(dogfood.can, 
       fill = TRUE, fill.alpha = 0.1, 
       lwd = 2, var.lwd = 2, var.cex = 2)
</code></pre>

<hr>
<h2 id='ellipse.axes'>Draw Axes of a 2D Covariance Ellipse</h2><span id='topic+ellipse.axes'></span>

<h3>Description</h3>

<p>A function to draw the principal axes of a 2D ellipse from a correlation,
covariance or sums of squares and cross products matrix in an existing plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipse.axes(
  x,
  centre = c(0, 0),
  center = centre,
  scale,
  which = 1:2,
  level = 0.95,
  radius = sqrt(qchisq(level, 2)),
  extend = 0,
  labels = TRUE,
  label.ends = c(2, 4),
  label.pos = c(2, 4, 1, 3),
  type = c("lines", "arrows"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ellipse.axes_+3A_x">x</code></td>
<td>
<p>A square positive definite matrix at least <code class="reqn">2 \times 2</code> in size.  It will be
treated as the correlation or covariance of a multivariate normal
distribution.</p>
</td></tr>
<tr><td><code id="ellipse.axes_+3A_centre">centre</code>, <code id="ellipse.axes_+3A_center">center</code></td>
<td>
<p>The center of the ellipse</p>
</td></tr>
<tr><td><code id="ellipse.axes_+3A_scale">scale</code></td>
<td>
<p>If x is a correlation matrix, then the standard deviations of
each parameter can be given in the scale parameter.  This defaults to
<code>c(1, 1)</code>, so no rescaling will be done.</p>
</td></tr>
<tr><td><code id="ellipse.axes_+3A_which">which</code></td>
<td>
<p>An integer vector to select which variables from the object <code>x</code> will be
plotted.  The default is the first 2.</p>
</td></tr>
<tr><td><code id="ellipse.axes_+3A_level">level</code></td>
<td>
<p>The coverage level of a simultaneous region of the ellipse.  The
default is 0.95, for a 95% region.  This is used to control the size of the
ellipse.</p>
</td></tr>
<tr><td><code id="ellipse.axes_+3A_radius">radius</code></td>
<td>
<p>The size of the ellipsoid may also be controlled by specifying the
value of a t-statistic on its boundary. This defaults to the square root of a chi-square statistic
for a given <code>level</code> on 2 degrees of freedom, however in a small sample of <code>n</code> observations,
a more accurate value is <code>sqrt(2 * qf(level, 2, n - 1 ))</code>.</p>
</td></tr>
<tr><td><code id="ellipse.axes_+3A_extend">extend</code></td>
<td>
<p>Fraction to extend the <code>radius</code> (default: 0). For example, use <code>extend = 0.1</code> to extend
the ellipse axes by 10%.</p>
</td></tr>
<tr><td><code id="ellipse.axes_+3A_labels">labels</code></td>
<td>
<p>Either a logical value, a character string, or a character
vector of length 2.  If <code>TRUE</code>, the default, the axes are labeled &quot;PC1&quot;,
&quot;PC2&quot;.  If a single character string, the digits 1, and 2 are pasted on
the end.</p>
</td></tr>
<tr><td><code id="ellipse.axes_+3A_label.ends">label.ends</code></td>
<td>
<p>A vector of indices in the range <code>1:4</code> indicating which ends of the axes
should be labeled, corresponding to a selection of rows of the 4 x 2 matrix
of axes end points. Values <code>1:2</code> represent the minimum and maximum of the first dimension respectively.
Values <code>3:4</code> represent the minimum and maximum of the second dimension.
Default: <code>c(2, 4)</code>.</p>
</td></tr>
<tr><td><code id="ellipse.axes_+3A_label.pos">label.pos</code></td>
<td>
<p>Positions of text labels relative to the ends of the axes used in <code><a href="graphics.html#topic+text">text</a></code> for
the four possible <code>label.ends</code>. 1, 2, 3, 4 represent below, to the left, above and to the right.
The default, <code>c(2, 4, 1, 3)</code>, positions the labels outside the axes.</p>
</td></tr>
<tr><td><code id="ellipse.axes_+3A_type">type</code></td>
<td>
<p>Character. Draw <code>"lines"</code> or <code>"arrows"</code>.</p>
</td></tr>
<tr><td><code id="ellipse.axes_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="graphics.html#topic+lines">lines</a></code> and <code><a href="graphics.html#topic+text">text</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a 4 x 2 matrix containing the end points of the axes in pairs (min, max) by rows.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+lines">lines</a></code>, <code><a href="graphics.html#topic+text">text</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
cov &lt;- cov(iris[,1:2])
mu &lt;- colMeans(iris[,1:2])

radius &lt;- sqrt(qchisq(0.68, 2))
plot(iris[,1:2], asp=1)
car::ellipse(mu, cov, radius = radius)
res &lt;- ellipse.axes(cov, center=mu, level = 0.68,
                    labels = TRUE)
res

# try some options 
plot(iris[,1:2], asp=1)
car::ellipse(mu, cov, radius = radius)
abline(h=mu[2], v=mu[1], col = "grey")
ellipse.axes(cov, centre=mu, level = 0.68,
             labels = "Dim", label.ends = 1:4,
             lwd = 2, lty = 2, col = "red",
             cex = 1.5)
             
# draw arrows rather than lines            
plot(iris[,1:2], asp=1)
car::ellipse(mu, cov, radius = radius)
ellipse.axes(cov, center=mu, level = 0.68,
             type = "arrows", extend = 0.2)
</code></pre>

<hr>
<h2 id='ellipse.box'>Draw Conjugate Axes and Parallelogram Surrounding a Covariance Ellipse</h2><span id='topic+ellipse.box'></span>

<h3>Description</h3>

<p>Draw Conjugate Axes and Parallelogram Surrounding a Covariance Ellipse
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipse.box(
  x,
  center = c(0, 0),
  which = 1:2,
  level = 0.95,
  radius = sqrt(qchisq(level, 2)),
  factor = c("cholesky", "pca"),
  draw = c("box", "diameters", "both"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ellipse.box_+3A_x">x</code></td>
<td>
<p>A square positive definite matrix at least 2x2 in size.  It will be
treated as the correlation or covariance of a multivariate normal
distribution.</p>
</td></tr>
<tr><td><code id="ellipse.box_+3A_center">center</code></td>
<td>
<p>The center of the ellipse</p>
</td></tr>
<tr><td><code id="ellipse.box_+3A_which">which</code></td>
<td>
<p>An integer vector to select which variables from the object <code>x</code> will be
plotted.  The default is the first 2.</p>
</td></tr>
<tr><td><code id="ellipse.box_+3A_level">level</code></td>
<td>
<p>The coverage level of a simultaneous region of the ellipse.  The
default is 0.95, for a 95% region.  This is used to control the size of the
ellipse.</p>
</td></tr>
<tr><td><code id="ellipse.box_+3A_radius">radius</code></td>
<td>
<p>The size of the ellipsoid may also be controlled by specifying the
value of a t-statistic on its boundary. This defaults to the square root of a chi-square statistic
for a given <code>level</code> on 2 degrees of freedom, however in a small sample of <code>n</code> observations,
a more accurate value is <code>sqrt(2 * qf(level, 2, n - 1 ))</code>.</p>
</td></tr>
<tr><td><code id="ellipse.box_+3A_factor">factor</code></td>
<td>
<p>A function defining the conjugate axes used to transform the unit
circle into an ellipse.  <code><a href="base.html#topic+chol">chol</a></code>, uses the right Cholesky
factor of <code>x</code>.</p>
</td></tr>
<tr><td><code id="ellipse.box_+3A_draw">draw</code></td>
<td>
<p>What to draw? <code>"box"</code>, <code>"diameters"</code> or <code>"both"</code></p>
</td></tr>
<tr><td><code id="ellipse.box_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a 2 column matrix containing the end points of lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
cov &lt;- cov(iris[,3:4])
mu &lt;- colMeans(iris[,3:4])

radius &lt;- sqrt(qchisq(0.68, 2))
plot(iris[,3:4], asp=1)
car::ellipse(mu, cov, radius = radius)
ellipse.axes(cov, center=mu, level = 0.68,
            labels = TRUE)
ellipse.box(cov, center=mu, level = 0.68, 
            factor = "pca", 
            col = "red", lwd = 2 )

res &lt;- ellipse.box(cov, center=mu, level = 0.68, factor = "chol", col = "green", lwd = 2 )
res
</code></pre>

<hr>
<h2 id='ellipse3d.axes'>Draw axes of a 3D ellipsoid</h2><span id='topic+ellipse3d.axes'></span>

<h3>Description</h3>

<p>A function to draw the major axes of a 3D ellipsoid from a correlation,
covariance or sums of squares and cross products matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipse3d.axes(
  x,
  centre = c(0, 0, 0),
  center = centre,
  scale = c(1, 1, 1),
  level = 0.95,
  t = sqrt(qchisq(level, 3)),
  which = 1:3,
  labels = TRUE,
  label.ends = c(2, 4, 6),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ellipse3d.axes_+3A_x">x</code></td>
<td>
<p>A square positive definite matrix at least 3x3 in size.  It will be
treated as the correlation or covariance of a multivariate normal
distribution.</p>
</td></tr>
<tr><td><code id="ellipse3d.axes_+3A_centre">centre</code>, <code id="ellipse3d.axes_+3A_center">center</code></td>
<td>
<p>The center of the ellipse</p>
</td></tr>
<tr><td><code id="ellipse3d.axes_+3A_scale">scale</code></td>
<td>
<p>If x is a correlation matrix, then the standard deviations of
each parameter can be given in the scale parameter.  This defaults to
<code>c(1, 1, 1)</code>, so no rescaling will be done.</p>
</td></tr>
<tr><td><code id="ellipse3d.axes_+3A_level">level</code></td>
<td>
<p>The coverage level of a simultaneous region.  The
default is 0.95, for a 95% region.  This is used to control the size of the
ellipsoid.</p>
</td></tr>
<tr><td><code id="ellipse3d.axes_+3A_t">t</code></td>
<td>
<p>The size of the ellipsoid may also be controlled by specifying the
value of a t-statistic on its boundary, which defaults to the square root of a chi-square statistic
for a given <code>level</code> on 3 degrees of freedom.</p>
</td></tr>
<tr><td><code id="ellipse3d.axes_+3A_which">which</code></td>
<td>
<p>An integer vector to select which variables from the object will be
plotted.  The default is the first 3.</p>
</td></tr>
<tr><td><code id="ellipse3d.axes_+3A_labels">labels</code></td>
<td>
<p>Either a logical value, a character string, or a character
vector of length 3.  If <code>TRUE</code>, the default, the axes are labeled PC1,
PC2, PC3.  If a single character string, the digits 1, 2, 3 are pasted on
the end.</p>
</td></tr>
<tr><td><code id="ellipse3d.axes_+3A_label.ends">label.ends</code></td>
<td>
<p>A vector of length 3 indicating which ends of the axes
should be labeled, corresponding to a selection of rows of the 6 x 3 matrix
of axes end points.  Default: <code>c(2,4,6)</code>.</p>
</td></tr>
<tr><td><code id="ellipse3d.axes_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>segments3d</code> and <code>text3d</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 6 x 3 matrix containing the end points of the three axis
lines in pairs by rows.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="rgl.html#topic+points3d">segments3d</a></code>,
<code><a href="rgl.html#topic+texts">text3d</a></code>, <code><a href="rgl.html#topic+ellipse3d">ellipse3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iris)
iris3 &lt;- iris[,1:3]
cov &lt;- cov(iris3)
mu &lt;- colMeans(iris3)
col &lt;-c("blue", "green", "red")[iris$Species]

library(rgl)
plot3d(iris3, type="s", size=0.4, col=col, cex=2, box=FALSE, aspect="iso")
plot3d( ellipse3d(cov, centre=mu, level=0.68), col="gray", alpha=0.2,  add = TRUE)

axes &lt;- ellipse3d.axes(cov, centre=mu, level=0.68, color="gray", lwd=2)

</code></pre>

<hr>
<h2 id='Ellipsoid'>Draw an Ellipsoid in an rgl Scene</h2><span id='topic+Ellipsoid'></span><span id='topic+Ellipsoid.data.frame'></span><span id='topic+Ellipsoid.default'></span>

<h3>Description</h3>

<p>This is an experimental function designed to separate internal code in <code>link{heplot3d}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ellipsoid(x, ...)

## S3 method for class 'data.frame'
Ellipsoid(x, which = 1:3, method = c("classical", "mve", "mcd"), ...)

## Default S3 method:
Ellipsoid(
  x,
  center = c(0, 0, 0),
  which = 1:3,
  radius = 1,
  df = Inf,
  label = "",
  cex.label = 1.5,
  col = "pink",
  lwd = 1,
  segments = 40,
  shade = TRUE,
  alpha = 0.1,
  wire = TRUE,
  verbose = FALSE,
  warn.rank = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Ellipsoid_+3A_x">x</code></td>
<td>
<p>An object. In the default method the parameter x should be a square positive definite matrix at               least 3x3 in size. It will be treated as the correlation or covariance of a multivariate normal
distribution. For the <code>data.frame</code> method, it should be a numeric data frame with at
least 3 columns.</p>
</td></tr>
<tr><td><code id="Ellipsoid_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
<tr><td><code id="Ellipsoid_+3A_which">which</code></td>
<td>
<p>This parameter selects which variables from the object will be plotted. The default is the first 3.</p>
</td></tr>
<tr><td><code id="Ellipsoid_+3A_method">method</code></td>
<td>
<p>the covariance method to be used: classical product-moment (<code>"classical"</code>), 
or minimum volume ellipsoid (<code>"mve"</code>), or 
minimum covariance determinant (<code>"mcd"</code></p>
</td></tr>
<tr><td><code id="Ellipsoid_+3A_center">center</code></td>
<td>
<p>center of the ellipsoid, a vector of length 3, typically the mean vector of data</p>
</td></tr>
<tr><td><code id="Ellipsoid_+3A_radius">radius</code></td>
<td>
<p>size of the ellipsoid</p>
</td></tr>
<tr><td><code id="Ellipsoid_+3A_df">df</code></td>
<td>
<p>degrees of freedom associated with the covariance matrix, used to calculate the appropriate F statistic</p>
</td></tr>
<tr><td><code id="Ellipsoid_+3A_label">label</code></td>
<td>
<p>label for the ellipsoid</p>
</td></tr>
<tr><td><code id="Ellipsoid_+3A_cex.label">cex.label</code></td>
<td>
<p>text size of label</p>
</td></tr>
<tr><td><code id="Ellipsoid_+3A_col">col</code></td>
<td>
<p>color of the ellipsoid</p>
</td></tr>
<tr><td><code id="Ellipsoid_+3A_lwd">lwd</code></td>
<td>
<p>line with for the wire-frame version</p>
</td></tr>
<tr><td><code id="Ellipsoid_+3A_segments">segments</code></td>
<td>
<p>number of segments composing each ellipsoid; defaults to <code>40</code>.</p>
</td></tr>
<tr><td><code id="Ellipsoid_+3A_shade">shade</code></td>
<td>
<p>logical; should the ellipsoid be smoothly shaded?</p>
</td></tr>
<tr><td><code id="Ellipsoid_+3A_alpha">alpha</code></td>
<td>
<p>transparency of the shaded ellipsoid</p>
</td></tr>
<tr><td><code id="Ellipsoid_+3A_wire">wire</code></td>
<td>
<p>logical; should the ellipsoid be drawn as a wire frame?</p>
</td></tr>
<tr><td><code id="Ellipsoid_+3A_verbose">verbose</code></td>
<td>
<p>logical; for debugging</p>
</td></tr>
<tr><td><code id="Ellipsoid_+3A_warn.rank">warn.rank</code></td>
<td>
<p>logical; warn if the ellipsoid is less than rank 3?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the bounding box of the ellipsoid invisibly; otherwise used for it's side effect of
drawing the ellipsoid
</p>


<h3>Examples</h3>

<pre><code class='language-R'># none yet
</code></pre>

<hr>
<h2 id='etasq'>Measures of Partial Association (Eta-squared) for Linear Models</h2><span id='topic+etasq'></span><span id='topic+etasq.lm'></span><span id='topic+etasq.mlm'></span><span id='topic+etasq.Anova.mlm'></span>

<h3>Description</h3>

<p>Calculates partial eta-squared for linear models or multivariate analogs of
eta-squared (or R^2), indicating the partial association for each term in a
multivariate linear model. There is a different analog for each of the four
standard multivariate test statistics: Pillai's trace, Hotelling-Lawley
trace, Wilks' Lambda and Roy's maximum root test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>etasq(x, ...)

## S3 method for class 'mlm'
etasq(x, ...)

## S3 method for class 'Anova.mlm'
etasq(x, anova = FALSE, ...)

## S3 method for class 'lm'
etasq(x, anova = FALSE, partial = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="etasq_+3A_x">x</code></td>
<td>
<p>A <code>lm</code>, <code>mlm</code> or <code>Anova.mlm</code> object</p>
</td></tr>
<tr><td><code id="etasq_+3A_...">...</code></td>
<td>
<p>Other arguments passed down to <code><a href="car.html#topic+Anova">Anova</a></code>.</p>
</td></tr>
<tr><td><code id="etasq_+3A_anova">anova</code></td>
<td>
<p>A logical, indicating whether the result should also contain
the test statistics produced by <code>Anova()</code>.</p>
</td></tr>
<tr><td><code id="etasq_+3A_partial">partial</code></td>
<td>
<p>A logical, indicating whether to calculate partial or
classical eta^2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For univariate linear models, classical 
<code class="reqn">\eta^2</code> = SSH / SST and partial
<code class="reqn">\eta^2</code> = SSH / (SSH + SSE).  These are identical in one-way designs.
</p>
<p>Partial eta-squared describes the proportion of total variation attributable
to a given factor, partialling out (excluding) other factors from the total
nonerror variation. These are commonly used as measures of effect size or
measures of (non-linear) strength of association in ANOVA models.
</p>
<p>All multivariate tests are based on the <code class="reqn">s=min(p, df_h)</code> latent roots of
<code class="reqn">H E^{-1}</code>. The analogous multivariate partial <code class="reqn">\eta^2</code> measures are
calculated as:
</p>
 
<dl>
<dt>Pillai's trace (V)</dt><dd><p><code class="reqn">\eta^2 = V/s</code></p>
</dd>
<dt>Hotelling-Lawley trace (T)</dt><dd><p><code class="reqn">\eta^2 = T/(T+s)</code></p>
</dd> 
<dt>Wilks' Lambda (L)</dt><dd><p><code class="reqn">\eta^2 = L^{1/s}</code></p>
</dd> 
<dt>Roy's maximum root (R)</dt><dd><p><code class="reqn">\eta^2 = R/(R+1)</code></p>
</dd> 
</dl>



<h3>Value</h3>

<p>When <code>anova=FALSE</code>, a one-column data frame containing the
eta-squared values for each term in the model.
</p>
<p>When <code>anova=TRUE</code>, a 5-column (lm) or 7-column (mlm) data frame
containing the eta-squared values and the test statistics produced by
<code>print.Anova()</code> for each term in the model.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>References</h3>

<p>Muller, K. E. and Peterson, B. L. (1984). Practical methods for
computing power in testing the Multivariate General Linear Hypothesis
<em>Computational Statistics and Data Analysis</em>, <b>2</b>, 143-158.
</p>
<p>Muller, K. E. and LaVange, L. M. and Ramey, S. L. and Ramey, C. T. (1992).
Power Calculations for General Linear Multivariate Models Including Repeated
Measures Applications. <em>Journal of the American Statistical
Association</em>, <b>87</b>, 1209-1226.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+Anova">Anova</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(car)
data(Soils, package="carData")
soils.mod &lt;- lm(cbind(pH,N,Dens,P,Ca,Mg,K,Na,Conduc) ~ Block + Contour*Depth, data=Soils)
#Anova(soils.mod)
etasq(Anova(soils.mod))
etasq(soils.mod) # same
etasq(Anova(soils.mod), anova=TRUE)

etasq(soils.mod, test="Wilks")
etasq(soils.mod, test="Hotelling")

</code></pre>

<hr>
<h2 id='FootHead'>Head measurements of football players</h2><span id='topic+FootHead'></span>

<h3>Description</h3>

<p>Data collected as part of a preliminary study examining the relation between
football helmet design and neck injuries. There are 30 subjects in each of
three groups: High school football players, college players and non-football
players.
</p>


<h3>Format</h3>

<p>A data frame with 90 observations on the following 7 variables.
</p>
 
<dl>
<dt><code>group</code></dt><dd><p>a factor with levels <code>High school</code> <code>College</code> <code>Non-football</code></p>
</dd> 
<dt><code>width</code></dt><dd><p>a numeric vector: head width at widest dimension</p>
</dd> 
<dt><code>circum</code></dt><dd><p>a numeric vector: head circumference</p>
</dd> 
<dt><code>front.back</code></dt><dd><p>a numeric vector: front to back distance at eye level</p>
</dd> 
<dt><code>eye.top</code></dt><dd><p>a numeric vector: eye to top of head</p>
</dd> 
<dt><code>ear.top</code></dt><dd><p>a numeric vector:ear to top of head</p>
</dd>
<dt><code>jaw</code></dt><dd><p>a numeric vector: jaw width</p>
</dd> 
</dl>



<h3>Source</h3>

<p>Rencher, A. C. (1995), <em>Methods of Multivariate Analysis</em>, New
York: Wiley, Table 8.3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(FootHead)
str(FootHead)
require(car)

# use Helmert contrasts for group
contrasts(FootHead$group) &lt;- contr.helmert
contrasts(FootHead$group)

foot.mod &lt;- lm(cbind(width, circum,front.back,eye.top,ear.top,jaw) ~ group, 
               data=FootHead)
Manova(foot.mod)

# show the HE plot for the first two variables
heplot(foot.mod, main="HE plot for width and circumference", fill=TRUE,
	col=c("red", "blue"))

# show it with tests of Helmert contrasts
heplot(foot.mod, hypotheses=list("group.1"="group1","group.2"="group2"),
	col=c("red", "blue", "green3", "green3" ),
	main="HE plot with orthogonal Helmert contrasts")

# show all pairwise HE plots
pairs(foot.mod)

# ... with tests of Helmert contrasts
pairs(foot.mod, hypotheses=list("group.1"="group1","group.2"="group2"),
	col=c("red", "blue", "green3", "green3"), hyp.labels=FALSE)

# see that the hypothesis for groups really is 2D
if(requireNamespace("rgl")){
heplot3d(foot.mod, variables=c(1,2,6),
	hypotheses=list("group.1"="group1","group.2"="group2"),
	col=c("red", "blue", "green3", "green3" ), wire=FALSE)
}

</code></pre>

<hr>
<h2 id='glance.mlm'>Glance at an mlm object</h2><span id='topic+glance.mlm'></span>

<h3>Description</h3>

<p>This function takes an &quot;mlm&quot; object, fit by <code><a href="stats.html#topic+lm">lm</a></code> with a multivariate response.
The goal is to return something analogous to <code><a href="broom.html#topic+glance.lm">glance.lm</a></code> for a univariate response linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mlm'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glance.mlm_+3A_x">x</code></td>
<td>
<p>An <code>"mlm"</code> object created by <code><a href="stats.html#topic+lm">lm</a></code>, i.e., with a multivariate response.</p>
</td></tr>
<tr><td><code id="glance.mlm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the multivariate case, it returns a <code><a href="tibble.html#topic+tibble">tibble</a></code> with one row for each
response variable, containing goodness of fit measures, F-tests and p-values.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code> with one row for each response variable and the columns:
</p>

<dl>
<dt><code>r.squared</code></dt><dd><p>R squared statistic, or the percent of variation explained by the model.</p>
</dd>
<dt><code>sigma</code></dt><dd><p>Estimated standard error of the residuals</p>
</dd>
<dt><code>fstatitic</code></dt><dd><p>Overall F statistic for the model</p>
</dd>
<dt><code>numdf</code></dt><dd><p>Numerator degrees of freedom for the overall test</p>
</dd>
<dt><code>dendf</code></dt><dd><p>Denominator degrees of freedom for the overall test</p>
</dd>
<dt><code>p.value</code></dt><dd><p>P-value corresponding to the F statistic</p>
</dd>
<dt><code>nobs</code></dt><dd><p>Number of observations used</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>iris.mod &lt;- lm(cbind(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width) ~ Species, data=iris)
glance(iris.mod)
</code></pre>

<hr>
<h2 id='gsorth'>Orthogonalize successive columns of a data frame or matrix</h2><span id='topic+gsorth'></span>

<h3>Description</h3>

<p><code>gsorth</code> uses sequential, orthogonal projections, as in the
Gram-Schmidt method, to transform a matrix or numeric columns of a data
frame into an uncorrelated set, possibly retaining the same column means and
standard deviations as the original.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsorth(y, order, recenter = TRUE, rescale = TRUE, adjnames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gsorth_+3A_y">y</code></td>
<td>
<p>A numeric data frame or matrix</p>
</td></tr>
<tr><td><code id="gsorth_+3A_order">order</code></td>
<td>
<p>An integer vector specifying the order of and/or a subset of
the columns of <code>y</code> to be orthogonalized. If missing, <code>order=1:p</code>
where <code>p=ncol(y)</code>.</p>
</td></tr>
<tr><td><code id="gsorth_+3A_recenter">recenter</code></td>
<td>
<p>If <code>TRUE</code>, the result has same column means as
original; else means = 0 for cols <code>2:p</code>.</p>
</td></tr>
<tr><td><code id="gsorth_+3A_rescale">rescale</code></td>
<td>
<p>If <code>TRUE</code>, the result has same column standard
deviations as original; else sd = residual variance for cols <code>2:p</code></p>
</td></tr>
<tr><td><code id="gsorth_+3A_adjnames">adjnames</code></td>
<td>
<p>If <code>TRUE</code>, the column names of the result are adjusted
to the form Y1, Y2.1, Y3.12, by adding the suffixes '.1', '.12', etc. to the
original column names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In statistical applications, interpretation depends on the <code>order</code> of
the variables orthogonalized. In multivariate linear models, orthogonalizing
the response, Y variables provides the equivalent of step-down tests, where
Y1 is tested alone, and then Y2.1, Y3.12, etc. can be tested to determine
their additional contributions over the previous response variables.
</p>
<p>Similarly, orthogonalizing the model X variables provides the equivalent of
Type I tests, such as provided by <code><a href="stats.html#topic+anova">anova</a></code>.
</p>
<p>The method is equivalent to setting each of columns <code>2:p</code> to the
residuals from a linear regression of that column on all prior columns,
i.e.,
</p>
<p><code>z[,j] &lt;- resid( lm( z[,j] ~ as.matrix(z[,1:(j-1)]), data=z) )</code>
</p>
<p>However, for accuracy and speed the transformation is carried out using the
QR decomposition.
</p>


<h3>Value</h3>

<p>Returns a matrix or data frame with uncorrelated columns.  Row and
column names are copied to the result.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+qr">qr</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
GSiris &lt;- gsorth(iris[,1:4])
GSiris &lt;- gsorth(iris, order=1:4)   # same, using order
str(GSiris)
zapsmall(cor(GSiris))
colMeans(GSiris)
# sd(GSiris) -- sd(&lt;matrix&gt;) now deprecated
apply(GSiris, 2, sd)

# orthogonalize Y side
GSiris &lt;- data.frame(gsorth(iris[,1:4]), Species=iris$Species)
iris.mod1 &lt;- lm(as.matrix(GSiris[,1:4]) ~ Species, data=GSiris)
car::Anova(iris.mod1)

# orthogonalize X side
rohwer.mod &lt;- lm(cbind(SAT, PPVT, Raven) ~ n + s + ns + na + ss, data=Rohwer)
car::Anova(rohwer.mod)

# type I tests for Rohwer data
Rohwer.orth &lt;- cbind(Rohwer[,1:5], gsorth(Rohwer[, c("n", "s", "ns", "na", "ss")], adjnames=FALSE))

rohwer.mod1 &lt;- lm(cbind(SAT, PPVT, Raven) ~ n + s + ns + na + ss, data=Rohwer.orth)
car::Anova(rohwer.mod1)
# compare with anova()
anova(rohwer.mod1)

# compare heplots for original Xs and orthogonalized, Type I
heplot(rohwer.mod)
heplot(rohwer.mod1)


</code></pre>

<hr>
<h2 id='Headache'>Treatment of Headache Sufferers for Sensitivity to Noise</h2><span id='topic+Headache'></span>

<h3>Description</h3>

<p>A study was conducted investigating the effectiveness of different kinds of
psychological treatment on the sensitivity of headache sufferers to noise,
described in Hand and Taylor (1987), Study E.
</p>


<h3>Format</h3>

<p>A data frame with 98 observations on the following 6 variables.
</p>
 
<dl>
<dt><code>type</code></dt><dd><p>Type of headache, a factor with levels <code>Migrane</code> <code>Tension</code></p>
</dd> 
<dt><code>treatment</code></dt><dd><p>Treatment group, a factor with levels <code>T1</code> <code>T2</code> <code>T3</code> 
<code>Control</code>.  See Details</p>
</dd> 
<dt><code>u1</code></dt><dd><p>Noise level rated as Uncomfortable, initial measure</p>
</dd> 
<dt><code>du1</code></dt><dd><p>Noise level rated as Definitely Uncomfortable, initial measure</p>
</dd> 
<dt><code>u2</code></dt><dd><p>Noise level rated as Uncomfortable, final measure</p>
</dd> 
<dt><code>du2</code></dt><dd><p>Noise level rated as Definitely Uncomfortable, final measure</p>
</dd> 
</dl>



<h3>Details</h3>

<p>In a pre-post design, 98 patients were first assessed for the volume of
noise which they found uncomfortable (U) and definitely uncomfortable (DU).
They were then given relaxation training, where they listened to the noise
at the DU level and given instruction breathing techniques and the use of
visual imagery to distract them from discomfort.  One of four treatments was
then applied, and all patients were reassessed for the noise volume they
considered uncomfortable (U) and definitely uncomfortable (DU).
</p>
<p>The treatments are described as follows: 
</p>

<dl>
<dt><code>T1</code></dt><dd><p>Listened again to the tone at their initial DU level, for
the same amount of time they were able to tolerate it before.</p>
</dd>
<dt><code>T2</code></dt><dd><p>Same as T1, with one additional minute exposure</p>
</dd>
<dt><code>T3</code></dt><dd><p>Same as T2, but were explicitly instructed to use the
relaxation techniques</p>
</dd> 
<dt><code>Control</code></dt><dd><p>These subject experienced no
further exposure to the noise tone until the final sensitivity measures were taken</p>
</dd> 
</dl>

<p>Hand and Taylor described several substantive hypotheses related to the
differences among treatments. In the <code>Headache</code> data frame, these have
been included as <code>contrasts(Headache$treatment)</code>
</p>


<h3>Source</h3>

<p>D. J. Hand and C. C. Taylor (1987). <em>Multivariate analysis of
variance and repeated measures: a practical approach for behavioural
scientists</em> London: Chapman and Hall. ISBN: 0412258005. Table E.1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(car)
data(Headache)
str(Headache)

# basic MLM, specifying between-S effects
headache.mod &lt;- lm(cbind(u1, du1, u2, du2) ~ type * treatment, data=Headache)

##############################
## between-S tests
##############################
Anova(headache.mod, test="Roy")

# test each contrast separately
print(linearHypothesis(headache.mod, hypothesis="treatment1", test="Roy"), SSP=FALSE)
print(linearHypothesis(headache.mod, hypothesis="treatment2", test="Roy"), SSP=FALSE)
print(linearHypothesis(headache.mod, hypothesis="treatment3", test="Roy"), SSP=FALSE)


heplot(headache.mod, variables=c(1,3),
	hypotheses=paste("treatment", 1:3, sep=""),
	hyp.labels=c("extra.exp", "no.inst", "explicit.inst"),
	xlab="u1: Initial sensitivity", ylab="u2: Final sensitivity",
	main="Headache data: Unpleasant levels")
abline(0, 1, lty=5, col="gray")

heplot(headache.mod, variables=c(2,4),
	hypotheses=paste("treatment", 1:3, sep=""),
	xlab="du1: Initial sensitivity", ylab="du2: Final sensitivity",
	main="Headache data: Definitely Unpleasant levels")
abline(0, 1, lty=5, col="gray")

pairs(headache.mod)

##############################
# between-S and within-S tests
##############################
idata = expand.grid(level=factor(c("U", "DU")), phase=factor(1:2))
Anova(headache.mod, idata=idata, idesign=~level*phase)


</code></pre>

<hr>
<h2 id='heplot'>Two-Dimensional HE Plots</h2><span id='topic+heplot'></span><span id='topic+heplot.mlm'></span>

<h3>Description</h3>

<p>This function plots ellipses representing the hypothesis and error
sums-of-squares-and-products matrices for terms and linear hypotheses in a
multivariate linear model.  These include MANOVA models (all explanatory
variables are factors), multivariate regression (all quantitative
predictors), MANCOVA models, homogeneity of regression, as well as repeated
measures designs treated from a multivariate perspective.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heplot(mod, ...)

## S3 method for class 'mlm'
heplot(
  mod,
  terms,
  hypotheses,
  term.labels = TRUE,
  hyp.labels = TRUE,
  err.label = "Error",
  label.pos = NULL,
  variables = 1:2,
  error.ellipse = !add,
  factor.means = !add,
  grand.mean = !add,
  remove.intercept = TRUE,
  type = c("II", "III", "2", "3"),
  idata = NULL,
  idesign = NULL,
  icontrasts = c("contr.sum", "contr.poly"),
  imatrix = NULL,
  iterm = NULL,
  markH0 = !is.null(iterm),
  manova,
  size = c("evidence", "effect.size", "significance"),
  level = 0.68,
  alpha = 0.05,
  segments = 60,
  center.pch = "+",
  center.cex = 2,
  col = getOption("heplot.colors", c("red", "blue", "black", "darkgreen", "darkcyan",
    "magenta", "brown", "darkgray")),
  lty = 2:1,
  lwd = 1:2,
  fill = FALSE,
  fill.alpha = 0.3,
  xlab,
  ylab,
  main = "",
  xlim,
  ylim,
  axes = TRUE,
  offset.axes,
  add = FALSE,
  verbose = FALSE,
  warn.rank = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heplot_+3A_mod">mod</code></td>
<td>
<p>a model object of class <code>"mlm"</code>.</p>
</td></tr>
<tr><td><code id="heplot_+3A_...">...</code></td>
<td>
<p>arguments to pass down to <code>plot</code>, <code>text</code>, and <code>points</code>.</p>
</td></tr>
<tr><td><code id="heplot_+3A_terms">terms</code></td>
<td>
<p>a logical value or character vector of terms in the model for
which to plot hypothesis matrices; if missing or <code>TRUE</code>, defaults to
all terms; if <code>FALSE</code>, no terms are plotted.</p>
</td></tr>
<tr><td><code id="heplot_+3A_hypotheses">hypotheses</code></td>
<td>
<p>optional list of linear hypotheses for which to plot
hypothesis matrices; hypotheses are specified as for the
<code><a href="car.html#topic+linearHypothesis">linearHypothesis</a></code> function in the <code>car</code> package; the
list elements can be named, in which case the names are used.</p>
</td></tr>
<tr><td><code id="heplot_+3A_term.labels">term.labels</code></td>
<td>
<p>logical value or character vector of names for the terms
to be plotted. If <code>TRUE</code> (the default) the names of the terms are used;
if <code>FALSE</code>, term labels are not plotted.</p>
</td></tr>
<tr><td><code id="heplot_+3A_hyp.labels">hyp.labels</code></td>
<td>
<p>logical value or character vector of names for the
hypotheses to be plotted. If <code>TRUE</code> (the default) the names of
components of the list of hypotheses are used; if <code>FALSE</code>, hypothesis
labels are not plotted.</p>
</td></tr>
<tr><td><code id="heplot_+3A_err.label">err.label</code></td>
<td>
<p>Label for the error ellipse</p>
</td></tr>
<tr><td><code id="heplot_+3A_label.pos">label.pos</code></td>
<td>
<p>Label position, a vector of integers (in <code>0:4</code>) or
character strings (in <code>c("center", "bottom", "left", "top", "right")</code>,
or in <code>c("C", "S", "W", "N", "E")</code> use in labeling ellipses, recycled
as necessary.  Values of 1, 2, 3 and 4, respectively indicate positions
below, to the left of, above and to the right of the max/min coordinates of
the ellipse; the value 0 specifies the centroid of the <code>ellipse</code>
object.  The default, <code>label.pos=NULL</code> uses the correlation of the
<code>ellipse</code> to determine &quot;top&quot; (r&gt;=0) or &quot;bottom&quot; (r&lt;0).  Even more
flexible options are described in <code><a href="#topic+label.ellipse">label.ellipse</a></code></p>
</td></tr>
<tr><td><code id="heplot_+3A_variables">variables</code></td>
<td>
<p>indices or names of the two response variables to be
plotted; defaults to <code>1:2</code>.</p>
</td></tr>
<tr><td><code id="heplot_+3A_error.ellipse">error.ellipse</code></td>
<td>
<p>if <code>TRUE</code>, plot the error ellipse; defaults to
<code>TRUE</code>, if the argument <code>add</code> is <code>FALSE</code> (see below).</p>
</td></tr>
<tr><td><code id="heplot_+3A_factor.means">factor.means</code></td>
<td>
<p>logical value or character vector of names of factors
for which the means are to be plotted, or <code>TRUE</code> or <code>FALSE</code>;
defaults to <code>TRUE</code>, if the argument <code>add</code> is <code>FALSE</code> (see
below).</p>
</td></tr>
<tr><td><code id="heplot_+3A_grand.mean">grand.mean</code></td>
<td>
<p>if <code>TRUE</code>, plot the centroid for all of the data;
defaults to <code>TRUE</code>, if the argument <code>add</code> is <code>FALSE</code> (see
below).</p>
</td></tr>
<tr><td><code id="heplot_+3A_remove.intercept">remove.intercept</code></td>
<td>
<p>if <code>TRUE</code> (the default), do not plot the
ellipse for the intercept even if it is in the MANOVA table.</p>
</td></tr>
<tr><td><code id="heplot_+3A_type">type</code></td>
<td>
<p>&ldquo;type&rdquo; of sum-of-squares-and-products matrices to compute; one
of <code>"II"</code>, <code>"III"</code>, <code>"2"</code>, or <code>"3"</code>, where <code>"II"</code>
is the default (and <code>"2"</code> is a synonym).</p>
</td></tr>
<tr><td><code id="heplot_+3A_idata">idata</code></td>
<td>
<p>an optional data frame giving a factor or factors defining the
intra-subject model for multivariate repeated-measures data.  See Friendly
(2010) and Details of <code><a href="car.html#topic+Anova">Anova</a></code> for an explanation of the
intra-subject design and for further explanation of the other arguments
relating to intra-subject factors.</p>
</td></tr>
<tr><td><code id="heplot_+3A_idesign">idesign</code></td>
<td>
<p>a one-sided model formula using the &ldquo;data&rdquo; in idata and
specifying the intra-subject design for repeated measure models.</p>
</td></tr>
<tr><td><code id="heplot_+3A_icontrasts">icontrasts</code></td>
<td>
<p>names of contrast-generating functions to be applied by
default to factors and ordered factors, respectively, in the within-subject
&ldquo;data&rdquo;; the contrasts must produce an intra-subject model matrix in which
different terms are orthogonal. The default is c(&quot;contr.sum&quot;, &quot;contr.poly&quot;).</p>
</td></tr>
<tr><td><code id="heplot_+3A_imatrix">imatrix</code></td>
<td>
<p>In lieu of <code>idata</code> and <code>idesign</code>, you can specify
the intra-subject design matrix directly via <code>imatrix</code>, in the form of
list of named elements.  Each element gives the columns of the
within-subject model matrix for an intra-subject term to be tested, and must
have as many rows as there are responses; the columns of the within-subject
model matrix for <em>different</em> terms must be mutually orthogonal.</p>
</td></tr>
<tr><td><code id="heplot_+3A_iterm">iterm</code></td>
<td>
<p>For repeated measures designs, you must specify one
intra-subject term (a character string) to select the SSPE (E) matrix used
in the HE plot.  Hypothesis terms plotted include the <code>iterm</code> effect as
well as all interactions of <code>iterm</code> with <code>terms</code>.</p>
</td></tr>
<tr><td><code id="heplot_+3A_markh0">markH0</code></td>
<td>
<p>A logical value (or else a list of arguments to
<code><a href="#topic+mark.H0">mark.H0</a></code>) used to draw cross-hairs and a point indicating the
value of a point null hypothesis.  The default is TRUE if <code>iterm</code> is
non-NULL.</p>
</td></tr>
<tr><td><code id="heplot_+3A_manova">manova</code></td>
<td>
<p>optional <code>Anova.mlm</code> object for the model; if absent a
MANOVA is computed. Specifying the argument can therefore save computation
in repeated calls.</p>
</td></tr>
<tr><td><code id="heplot_+3A_size">size</code></td>
<td>
<p>how to scale the hypothesis ellipse relative to the error
ellipse; if <code>"evidence"</code>, the default, the scaling is done so that a
&ldquo;significant&rdquo; hypothesis ellipse at level <code>alpha</code> extends outside of
the error ellipse. <code>size = "significance"</code> is a synonym and does the same thing.
If <code>"effect.size"</code>, the hypothesis ellipse is on the
same scale as the error ellipse.</p>
</td></tr>
<tr><td><code id="heplot_+3A_level">level</code></td>
<td>
<p>equivalent coverage of ellipse  (assuming normally-distributed errors).
This defaults to <code>0.68</code>, giving a standard 1 SD bivariate ellipse.</p>
</td></tr>
<tr><td><code id="heplot_+3A_alpha">alpha</code></td>
<td>
<p>significance level for Roy's greatest-root test statistic; if
<code>size="evidence"</code> or <code>size="significance"</code>, then the hypothesis ellipse is scaled so that it
just touches the error ellipse at the specified alpha level. A larger
hypothesis ellipse <em>somewhere</em> in the space of the response variables
therefore indicates statistical significance; defaults to <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="heplot_+3A_segments">segments</code></td>
<td>
<p>number of line segments composing each ellipse; defaults to <code>60</code>.</p>
</td></tr>
<tr><td><code id="heplot_+3A_center.pch">center.pch</code></td>
<td>
<p>character to use in plotting the centroid of the data;
defaults to <code>"+"</code>.</p>
</td></tr>
<tr><td><code id="heplot_+3A_center.cex">center.cex</code></td>
<td>
<p>size of character to use in plotting the centroid of the data; defaults to <code>2</code>.</p>
</td></tr>
<tr><td><code id="heplot_+3A_col">col</code></td>
<td>
<p>a color or vector of colors to use in plotting ellipses; the
first color is used for the error ellipse; the remaining colors &mdash; recycled
as necessary &mdash; are used for the hypothesis ellipses.  A single color can
be given, in which case it is used for all ellipses.  For convenience, the
default colors for all heplots produced in a given session can be changed by
assigning a color vector via <code>options(heplot.colors =c(...)</code>.
Otherwise, the default colors are <code>c("red", "blue", "black",
"darkgreen", "darkcyan", "magenta", "brown", "darkgray")</code>.</p>
</td></tr>
<tr><td><code id="heplot_+3A_lty">lty</code></td>
<td>
<p>vector of line types to use for plotting the ellipses; the first
is used for the error ellipse, the rest &mdash; possibly recycled &mdash; for the
hypothesis ellipses; a single line type can be given. Defaults to <code>2:1</code>.</p>
</td></tr>
<tr><td><code id="heplot_+3A_lwd">lwd</code></td>
<td>
<p>vector of line widths to use for plotting the ellipses; the first
is used for the error ellipse, the rest &mdash; possibly recycled &mdash; for the
hypothesis ellipses; a single line width can be given. Defaults to
<code>1:2</code>.</p>
</td></tr>
<tr><td><code id="heplot_+3A_fill">fill</code></td>
<td>
<p>A logical vector indicating whether each ellipse should be
filled or not.  The first value is used for the error ellipse, the rest &mdash;
possibly recycled &mdash; for the hypothesis ellipses; a single fill value can
be given.  Defaults to FALSE for backward compatibility. See Details below.</p>
</td></tr>
<tr><td><code id="heplot_+3A_fill.alpha">fill.alpha</code></td>
<td>
<p>Alpha transparency for filled ellipses, a numeric scalar
or vector of values within <code>[0,1]</code>, where 0 means fully transparent and 1 means fully opaque.</p>
</td></tr>
<tr><td><code id="heplot_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label; defaults to name of the x variable.</p>
</td></tr>
<tr><td><code id="heplot_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label; defaults to name of the y variable.</p>
</td></tr>
<tr><td><code id="heplot_+3A_main">main</code></td>
<td>
<p>main plot label; defaults to <code>""</code>.</p>
</td></tr>
<tr><td><code id="heplot_+3A_xlim">xlim</code></td>
<td>
<p>x-axis limits; if absent, will be computed from the data.</p>
</td></tr>
<tr><td><code id="heplot_+3A_ylim">ylim</code></td>
<td>
<p>y-axis limits; if absent, will be computed from the data.</p>
</td></tr>
<tr><td><code id="heplot_+3A_axes">axes</code></td>
<td>
<p>Whether to draw the x, y axes; defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="heplot_+3A_offset.axes">offset.axes</code></td>
<td>
<p>proportion to extend the axes in each direction if
computed from the data; optional.</p>
</td></tr>
<tr><td><code id="heplot_+3A_add">add</code></td>
<td>
<p>if <code>TRUE</code>, add to the current plot; the default is
<code>FALSE</code>.  If <code>TRUE</code>, the error ellipse is not plotted.</p>
</td></tr>
<tr><td><code id="heplot_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, print the MANOVA table and details of
hypothesis tests; the default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="heplot_+3A_warn.rank">warn.rank</code></td>
<td>
<p>if <code>TRUE</code>, do not suppress warnings about the rank of
the hypothesis matrix when the ellipse collapses to a line; the default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>heplot</code> function plots a representation of the covariance ellipses
for hypothesized model terms and linear hypotheses (H) and the corresponding
error (E) matrices for two response variables in a multivariate linear model
(mlm).
</p>
<p>The plot helps to visualize the nature and dimensionality response variation
on the two variables jointly in relation to error variation that is
summarized in the various multivariate test statistics (Wilks' Lambda,
Pillai trace, Hotelling-Lawley trace, Roy maximum root). Roy's maximum root
test has a particularly simple visual interpretation, exploited in the
<code>size="evidence"</code> version of the plot. See the description of argument
<code>alpha</code>.
</p>
<p>For a 1 df hypothesis term (a quantitative regressor, a single contrast or
parameter test), the H matrix has rank 1 (one non-zero latent root of <code class="reqn">H
E^{-1}</code>) and the H &quot;ellipse&quot; collapses to a degenerate line.
</p>
<p>Typically, you fit a mlm with <code>mymlm &lt;- lm(cbind(y1, y2, y3, ...) ~
modelterms)</code>, and plot some or all of the <code>modelterms</code> with
<code>heplot(mymlm, ...)</code>.  Arbitrary linear hypotheses related to the terms
in the model (e.g., contrasts of an effect) can be included in the plot
using the <code>hypotheses</code> argument.  See
<code><a href="car.html#topic+linearHypothesis">linearHypothesis</a></code> for details.
</p>
<p>For repeated measure designs, where the response variables correspond to one
or more variates observed under a within-subject design, between-subject
effects and within-subject effects must be plotted separately, because the
error terms (E matrices) differ.  When you specify an intra-subject term
(<code>iterm</code>), the analysis and HE plots amount to analysis of the matrix
<b>Y</b> of responses post-multiplied by a matrix <b>M</b> determined by the
intra-subject design for that term.  See Friendly (2010) or the
<code>vignette("repeated")</code> in this package for an extended discussion and
examples.
</p>
<p>The related <code><a href="candisc.html#topic+candisc">candisc</a></code> package provides functions for
visualizing a multivariate linear model in a low-dimensional view via a
generalized canonical discriminant analyses.
<code><a href="candisc.html#topic+heplot.candisc">heplot.candisc</a></code> and
<code><a href="candisc.html#topic+heplot3d.candisc">heplot3d.candisc</a></code> provide a low-rank 2D (or 3D) view
of the effects for a given term in the space of maximum discrimination.
</p>
<p>When an element of <code>fill</code> is <code>TRUE</code>, the ellipse outline is drawn
using the corresponding color in <code>col</code>, and the interior is filled with
a transparent version of this color specified in <code>fill.alpha</code>.  To
produce filled (non-degenerate) ellipses without the bounding outline, use a
value of <code>lty=0</code> in the corresponding position.
</p>


<h3>Value</h3>

<p>The function invisibly returns an object of class <code>"heplot"</code>,
with coordinates for the various hypothesis ellipses and the error ellipse,
and the limits of the horizontal and vertical axes.  These may be useful for
adding additional annotations to the plot, using standard plotting
functions.  (No methods for manipulating these objects are currently
available.)
</p>
<p>The components are:
</p>

<dl>
<dt>H</dt><dd><p>a list containing the coordinates of each ellipse for the hypothesis terms</p>
</dd> 
<dt>E</dt><dd><p>a matrix containing the coordinates for the error ellipse</p>
</dd> 
<dt>center</dt><dd><p>x,y coordinates of the centroid</p>
</dd> 
<dt>xlim</dt><dd><p>x-axis limits</p>
</dd> 
<dt>ylim</dt><dd><p>y-axis limits</p>
</dd>
<dt>radius</dt><dd><p>the radius for the unit circles used to generate the ellipses</p>
</dd>
</dl>



<h3>References</h3>

<p>Friendly, M. (2006).  Data Ellipses, HE Plots and Reduced-Rank
Displays for Multivariate Linear Models: SAS Software and Examples
<em>Journal of Statistical Software</em>, <b>17</b>(6), 1&ndash;42. 
<a href="https://www.jstatsoft.org/v17/i06/">https://www.jstatsoft.org/v17/i06/</a>,
DOI: 10.18637/jss.v017.i06
</p>
<p>Friendly, M. (2007).  HE plots for Multivariate General Linear Models.
<em>Journal of Computational and Graphical Statistics</em>, <b>16</b>(2)
421&ndash;444.  <a href="http://datavis.ca/papers/jcgs-heplots.pdf">http://datavis.ca/papers/jcgs-heplots.pdf</a>
</p>
<p>Friendly, Michael (2010). HE Plots for Repeated Measures Designs.
<em>Journal of Statistical Software</em>, 37(4), 1-40.  
DOI: 10.18637/jss.v037.i04.
</p>
<p>Fox, J., Friendly, M. &amp; Weisberg, S. (2013). Hypothesis Tests for
Multivariate Linear Models Using the car Package. <em>The R Journal</em>,
<b>5</b>(1),
<a href="https://journal.r-project.org/archive/2013-1/fox-friendly-weisberg.pdf">https://journal.r-project.org/archive/2013-1/fox-friendly-weisberg.pdf</a>.
</p>
<p>Friendly, M. &amp; Sigal, M. (2014) Recent Advances in Visualizing Multivariate
Linear Models. <em>Revista Colombiana de Estadistica</em>, <b>37</b>, 261-283.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+Anova">Anova</a></code>, <code><a href="car.html#topic+linearHypothesis">linearHypothesis</a></code> for
details on testing MLMs.
</p>
<p><code><a href="#topic+heplot1d">heplot1d</a></code>, <code><a href="#topic+heplot3d">heplot3d</a></code>, <code><a href="#topic+pairs.mlm">pairs.mlm</a></code>,
<code><a href="#topic+mark.H0">mark.H0</a></code> for other HE plot functions.
<code><a href="#topic+coefplot.mlm">coefplot.mlm</a></code> for plotting confidence ellipses for parameters
in MLMs.
</p>
<p><code><a href="#topic+trans.colors">trans.colors</a></code> for calculation of transparent colors.
<code><a href="#topic+label.ellipse">label.ellipse</a></code> for labeling positions in plotting H and E
ellipses.
</p>
<p><code><a href="candisc.html#topic+candisc">candisc</a></code>, <code><a href="candisc.html#topic+heplot.candisc">heplot.candisc</a></code> for
reduced-rank views of <code>mlm</code>s in canonical space.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## iris data
contrasts(iris$Species) &lt;- matrix(c(0,-1,1, 2, -1, -1), 3,2)
contrasts(iris$Species)

iris.mod &lt;- lm(cbind(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width) ~
Species, data=iris)

hyp &lt;- list("V:V"="Species1","S:VV"="Species2")
heplot(iris.mod, hypotheses=hyp)
# compare with effect-size scaling
heplot(iris.mod, hypotheses=hyp, size="effect", add=TRUE)

# try filled ellipses; include contrasts
heplot(iris.mod, hypotheses=hyp, fill=TRUE, 
       fill.alpha=0.2, col=c("red", "blue"))
heplot(iris.mod, hypotheses=hyp, fill=TRUE, 
       col=c("red", "blue"), lty=c(0,0,1,1))

# vary label position and fill.alpha
heplot(iris.mod, hypotheses=hyp, fill=TRUE, fill.alpha=c(0.3,0.1), col=c("red", "blue"), 
       lty=c(0,0,1,1), label.pos=0:3)

# what is returned?
hep &lt;-heplot(iris.mod, variables=c(1,3),  hypotheses=hyp)
str(hep)

# all pairs
pairs(iris.mod, hypotheses=hyp, hyp.labels=FALSE)


## Pottery data, from car package
data(Pottery, package = "carData")
pottery.mod &lt;- lm(cbind(Al, Fe, Mg, Ca, Na) ~ Site, data=Pottery)
heplot(pottery.mod)
heplot(pottery.mod, terms=FALSE, add=TRUE, col="blue", 
  hypotheses=list(c("SiteCaldicot = 0", "SiteIsleThorns=0")),
  hyp.labels="Sites Caldicot and Isle Thorns")

## Rohwer data, multivariate multiple regression/ANCOVA
#-- ANCOVA, assuming equal slopes
rohwer.mod &lt;- lm(cbind(SAT, PPVT, Raven) ~ SES + n + s + ns + na + ss, data=Rohwer)
car::Anova(rohwer.mod)
col &lt;- c("red", "black", "blue", "cyan", "magenta", "brown", "gray")
heplot(rohwer.mod, col=col)

# Add ellipse to test all 5 regressors
heplot(rohwer.mod, hypotheses=list("Regr" = c("n", "s", "ns", "na", "ss")), 
       col=col, fill=TRUE)
# View all pairs
pairs(rohwer.mod, hypotheses=list("Regr" = c("n", "s", "ns", "na", "ss")))
# or 3D plot

if(requireNamespace("rgl")){
col &lt;- c("pink", "black", "blue", "cyan", "magenta", "brown", "gray")
heplot3d(rohwer.mod, hypotheses=list("Regr" = c("n", "s", "ns", "na", "ss")), col=col)
}

</code></pre>

<hr>
<h2 id='heplot1d'>One-Dimensional HE Plots</h2><span id='topic+heplot1d'></span><span id='topic+heplot1d.mlm'></span>

<h3>Description</h3>

<p>This function plots a 1-dimensional representation of the hypothesis (H) and
error (E) sums-of-squares-and-products matrices for terms and linear
hypotheses in a multivariate linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heplot1d(mod, ...)

## S3 method for class 'mlm'
heplot1d(
  mod,
  terms,
  hypotheses,
  term.labels = TRUE,
  hyp.labels = TRUE,
  variables = 1,
  error.ellipse = !add,
  factor.means = !add,
  grand.mean = !add,
  remove.intercept = TRUE,
  type = c("II", "III", "2", "3"),
  idata = NULL,
  idesign = NULL,
  icontrasts = c("contr.sum", "contr.poly"),
  imatrix = NULL,
  iterm = NULL,
  manova,
  size = c("evidence", "effect.size", "significance"),
  level = 0.68,
  alpha = 0.05,
  center.pch = "|",
  col = getOption("heplot.colors", c("red", "blue", "black", "darkgreen", "darkcyan",
    "magenta", "brown", "darkgray")),
  lty = 2:1,
  lwd = 1:2,
  xlab,
  main = "",
  xlim,
  axes = TRUE,
  offset.axes = 0.1,
  add = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heplot1d_+3A_mod">mod</code></td>
<td>
<p>a model object of class <code>"mlm"</code>.</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_...">...</code></td>
<td>
<p>arguments to pass down to <code>plot</code>, <code>text</code>, and <code>points</code>.</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_terms">terms</code></td>
<td>
<p>a logical value or character vector of terms in the model for
which to plot hypothesis matrices; if missing or <code>TRUE</code>, defaults to
all terms; if <code>FALSE</code>, no terms are plotted.</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_hypotheses">hypotheses</code></td>
<td>
<p>optional list of linear hypotheses for which to plot
hypothesis matrices; hypotheses are specified as for the
<code><a href="car.html#topic+linearHypothesis">linearHypothesis</a></code> function in the <code>car</code> package; the
list elements can be named, in which case the names are used.</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_term.labels">term.labels</code></td>
<td>
<p>logical value or character vector of names for the terms
to be plotted. If <code>TRUE</code> (the default) the names of the terms are used;
if <code>FALSE</code>, term labels are not plotted.</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_hyp.labels">hyp.labels</code></td>
<td>
<p>logical value or character vector of names for the
hypotheses to be plotted. If <code>TRUE</code> (the default) the names of
components of the list of hypotheses are used; if <code>FALSE</code>, hypothesis
labels are not plotted.</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_variables">variables</code></td>
<td>
<p>indices or names of the two response variables to be
plotted; defaults to <code>1:2</code>.</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_error.ellipse">error.ellipse</code></td>
<td>
<p>if <code>TRUE</code>, plot the error ellipse; defaults to
<code>TRUE</code>, if the argument <code>add</code> is <code>FALSE</code> (see below).</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_factor.means">factor.means</code></td>
<td>
<p>logical value or character vector of names of factors
for which the means are to be plotted, or <code>TRUE</code> or <code>FALSE</code>;
defaults to <code>TRUE</code>, if the argument <code>add</code> is <code>FALSE</code> (see
below).</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_grand.mean">grand.mean</code></td>
<td>
<p>if <code>TRUE</code>, plot the centroid for all of the data;
defaults to <code>TRUE</code>, if the argument <code>add</code> is <code>FALSE</code> (see
below).</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_remove.intercept">remove.intercept</code></td>
<td>
<p>if <code>TRUE</code> (the default), do not plot the
ellipse for the intercept even if it is in the MANOVA table.</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_type">type</code></td>
<td>
<p>&ldquo;type&rdquo; of sum-of-squares-and-products matrices to compute; one
of <code>"II"</code>, <code>"III"</code>, <code>"2"</code>, or <code>"3"</code>, where <code>"II"</code>
is the default (and <code>"2"</code> is a synonym).</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_idata">idata</code></td>
<td>
<p>an optional data frame giving a factor or factors defining the
intra-subject model for multivariate repeated-measures data.  See Details of
<code><a href="car.html#topic+Anova">Anova</a></code> for an explanation of the intra-subject design and
for further explanation of the other arguments relating to intra-subject
factors.</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_idesign">idesign</code></td>
<td>
<p>a one-sided model formula using the &ldquo;data&rdquo; in idata and
specifying the intra-subject design for repeated measure models.</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_icontrasts">icontrasts</code></td>
<td>
<p>names of contrast-generating functions to be applied by
default to factors and ordered factors, respectively, in the within-subject
&ldquo;data&rdquo;; the contrasts must produce an intra-subject model matrix in which
different terms are orthogonal. The default is c(&quot;contr.sum&quot;, &quot;contr.poly&quot;).</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_imatrix">imatrix</code></td>
<td>
<p>In lieu of <code>idata</code> and <code>idesign</code>, you can specify
the intra-subject design matrix directly via <code>imatrix</code>, in the form of
list of named elements.  Each element gives the columns of the
within-subject model matrix for an intra-subject term to be tested, and must
have as many rows as there are responses; the columns of the within-subject
model matrix for <em>different</em> terms must be mutually orthogonal.</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_iterm">iterm</code></td>
<td>
<p>For repeated measures designs, you must specify one
intra-subject term (a character string) to select the SSPE (E) matrix used
in the HE plot.  Hypothesis terms plotted include the <code>iterm</code> effect as
well as all interactions of <code>iterm</code> with <code>terms</code>.</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_manova">manova</code></td>
<td>
<p>optional <code>Anova.mlm</code> object for the model; if absent a
MANOVA is computed. Specifying the argument can therefore save computation
in repeated calls.</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_size">size</code></td>
<td>
<p>how to scale the hypothesis ellipse relative to the error
ellipse; if <code>"evidence"</code>, the default, the scaling is done so that a
&ldquo;significant&rdquo; hypothesis ellipse at level <code>alpha</code> extends outside of
the error ellipse. <code>size = "significance"</code> is a synonym and does the same thing.
If <code>"effect.size"</code>, the hypothesis ellipse is on the
same scale as the error ellipse.</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_level">level</code></td>
<td>
<p>equivalent coverage of ellipse  (assuming normally-distributed errors).
This defaults to <code>0.68</code>, giving a standard 1 SD bivariate ellipse.</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_alpha">alpha</code></td>
<td>
<p>significance level for Roy's greatest-root test statistic; if
<code>size="evidence"</code> or <code>size="significance"</code>, then the hypothesis ellipse is scaled so that it
just touches the error ellipse at the specified alpha level. A larger
hypothesis ellipse <em>somewhere</em> in the space of the response variables
therefore indicates statistical significance; defaults to <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_center.pch">center.pch</code></td>
<td>
<p>character to use in plotting the centroid of the data;
defaults to <code>"|"</code>.</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_col">col</code></td>
<td>
<p>a color or vector of colors to use in plotting ellipses; the
first color is used for the error ellipse; the remaining colors &mdash; recycled
as necessary &mdash; are used for the hypothesis ellipses.  A single color can
be given, in which case it is used for all ellipses.  For convenience, the
default colors for all heplots produced in a given session can be changed by
assigning a color vector via <code>options(heplot.colors =c(...)</code>.
Otherwise, the default colors are <code>c("red", "blue", "black",
"darkgreen", "darkcyan", "magenta", "brown", "darkgray")</code>.</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_lty">lty</code></td>
<td>
<p>vector of line types to use for plotting the ellipses; the first
is used for the error ellipse, the rest &mdash; possibly recycled &mdash; for the
hypothesis ellipses; a single line type can be given. Defaults to <code>2:1</code>.</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_lwd">lwd</code></td>
<td>
<p>vector of line widths to use for plotting the ellipses; the first
is used for the error ellipse, the rest &mdash; possibly recycled &mdash; for the
hypothesis ellipses; a single line width can be given. Defaults to <code>1:2</code>.</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label; defaults to name of the x variable.</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_main">main</code></td>
<td>
<p>main plot label; defaults to <code>""</code>.</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_xlim">xlim</code></td>
<td>
<p>x-axis limits; if absent, will be computed from the data.</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_axes">axes</code></td>
<td>
<p>Whether to draw the x, y axes; defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="heplot1d_+3A_offset.axes">offset.axes</code></td>
<td>
<p>proportion to extend the axes in each direction if
computed from the data; optional.</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_add">add</code></td>
<td>
<p>if <code>TRUE</code>, add to the current plot; the default is
<code>FALSE</code>.  If <code>TRUE</code>, the error ellipse is not plotted.</p>
</td></tr>
<tr><td><code id="heplot1d_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, print the MANOVA table and details of
hypothesis tests; the default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In particular, for a given response, the 1-D representations of H and E
matrices correspond to line segments.  The E &ldquo;ellipse&rdquo; is shown as a
filled rectangle whose width equals the mean squared error for that
response.  The H &ldquo;ellipse&rdquo; for each model term is shown as a line segment
whose length represents either the size of the effect or the evidence for
that effect.
</p>
<p><b>This version is an initial sketch.  Details of the implementation are
subject to change.</b>
</p>


<h3>Value</h3>

<p>The function invisibly returns an object of class <code>"heplot1d"</code>,
with coordinates for the various hypothesis ellipses and the error ellipse,
and the limits of the horizontal and vertical axes.  (No methods for
manipulating these objects are currently available.)
</p>
<p>The components are: 
</p>
<table role = "presentation">
<tr><td><code>H</code></td>
<td>
<p>ranges for the hypothesis terms</p>
</td></tr> 
<tr><td><code>E</code></td>
<td>
<p>range for E</p>
</td></tr> 
<tr><td><code>xlim</code></td>
<td>
<p>x-axis limits</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+Anova">Anova</a></code>, <code><a href="car.html#topic+linearHypothesis">linearHypothesis</a></code> for
hypothesis tests in <code>mlm</code>s
</p>
<p><code><a href="#topic+heplot">heplot</a></code>, <code><a href="#topic+heplot3d">heplot3d</a></code>, <code><a href="#topic+pairs.mlm">pairs.mlm</a></code> for
other HE plot methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Plastics data
plastic.mod &lt;- lm(cbind(tear, gloss, opacity) ~ rate*additive, data=Plastic)
heplot1d(plastic.mod, col=c("pink","blue"))
heplot1d(plastic.mod, col=c("pink","blue"),variables=2)
heplot1d(plastic.mod, col=c("pink","blue"),variables=3)

## Bees data
bees.mod &lt;- lm(cbind(Iz,Iy) ~ caste*treat*time, data=Bees)
heplot1d(bees.mod)
heplot1d(bees.mod, variables=2)


</code></pre>

<hr>
<h2 id='heplot3d'>Three-Dimensional HE Plots</h2><span id='topic+heplot3d'></span><span id='topic+heplot3d.mlm'></span>

<h3>Description</h3>

<p>This function plots ellipsoids in 3D representing the hypothesis and error
sums-of-squares-and-products matrices for terms and linear hypotheses in a
multivariate linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heplot3d(mod, ...)

## S3 method for class 'mlm'
heplot3d(
  mod,
  terms,
  hypotheses,
  term.labels = TRUE,
  hyp.labels = TRUE,
  err.label = "Error",
  variables = 1:3,
  error.ellipsoid = !add,
  factor.means = !add,
  grand.mean = !add,
  remove.intercept = TRUE,
  type = c("II", "III", "2", "3"),
  idata = NULL,
  idesign = NULL,
  icontrasts = c("contr.sum", "contr.poly"),
  imatrix = NULL,
  iterm = NULL,
  manova,
  size = c("evidence", "effect.size", "significance"),
  level = 0.68,
  alpha = 0.05,
  segments = 40,
  col = getOption("heplot3d.colors", c("red", "blue", "black", "darkgreen", "darkcyan",
    "magenta", "brown", "darkgray")),
  lwd = c(1, 4),
  shade = TRUE,
  shade.alpha = 0.2,
  wire = c(TRUE, FALSE),
  bg.col = c("white", "black"),
  fogtype = c("none", "exp2", "linear", "exp"),
  fov = 30,
  offset = 0.01,
  xlab,
  ylab,
  zlab,
  xlim,
  ylim,
  zlim,
  cex.label = 1.5,
  add = FALSE,
  verbose = FALSE,
  warn.rank = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heplot3d_+3A_mod">mod</code></td>
<td>
<p>a model object of class <code>"mlm"</code>.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_...">...</code></td>
<td>
<p>arguments passed from generic.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_terms">terms</code></td>
<td>
<p>a logical value or character vector of terms in the model for
which to plot hypothesis matrices; if missing or <code>TRUE</code>, defaults to
all terms; if <code>FALSE</code>, no terms are plotted.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_hypotheses">hypotheses</code></td>
<td>
<p>optional list of linear hypotheses for which to plot
hypothesis matrices; hypotheses are specified as for the
<code><a href="car.html#topic+linearHypothesis">linearHypothesis</a></code> function in the <code>car</code> package; the
list elements can be named, in which case the names are used.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_term.labels">term.labels</code></td>
<td>
<p>logical value or character vector of names for the terms
to be plotted. If <code>TRUE</code> (the default) the names of the terms are used;
if <code>FALSE</code>, term labels are not plotted.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_hyp.labels">hyp.labels</code></td>
<td>
<p>logical value or character vector of names for the
hypotheses to be plotted. If <code>TRUE</code> (the default) the names of
components of the list of hypotheses are used; if <code>FALSE</code>, hypothesis
labels are not plotted.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_err.label">err.label</code></td>
<td>
<p>Label for the error ellipse</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_variables">variables</code></td>
<td>
<p>indices or names of the three response variables to be
plotted; defaults to <code>1:3</code>.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_error.ellipsoid">error.ellipsoid</code></td>
<td>
<p>if <code>TRUE</code>, plot the error ellipsoid; defaults to
<code>TRUE</code>, if the argument <code>add</code> is <code>FALSE</code> (see below).</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_factor.means">factor.means</code></td>
<td>
<p>logical value or character vector of names of factors
for which the means are to be plotted, or <code>TRUE</code> or <code>FALSE</code>;
defaults to <code>TRUE</code>, if the argument <code>add</code> is <code>FALSE</code> (see
below).</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_grand.mean">grand.mean</code></td>
<td>
<p>if <code>TRUE</code>, plot the centroid for all of the data;
defaults to <code>TRUE</code>, if the argument <code>add</code> is <code>FALSE</code> (see
below).</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_remove.intercept">remove.intercept</code></td>
<td>
<p>if <code>TRUE</code> (the default), do not plot the
ellipsoid for the intercept even if it is in the MANOVA table.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_type">type</code></td>
<td>
<p>&ldquo;type&rdquo; of sum-of-squares-and-products matrices to compute; one
of <code>"II"</code>, <code>"III"</code>, <code>"2"</code>, or <code>"3"</code>, where <code>"II"</code>
is the default (and <code>"2"</code> is a synonym).</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_idata">idata</code></td>
<td>
<p>an optional data frame giving a factor or factors defining the
intra-subject model for multivariate repeated-measures data.  See Details of
<code><a href="car.html#topic+Anova">Anova</a></code> for an explanation of the intra-subject design and
for further explanation of the other arguments relating to intra-subject
factors.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_idesign">idesign</code></td>
<td>
<p>a one-sided model formula using the &ldquo;data&rdquo; in idata and
specifying the intra-subject design for repeated measure models.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_icontrasts">icontrasts</code></td>
<td>
<p>names of contrast-generating functions to be applied by
default to factors and ordered factors, respectively, in the within-subject
&ldquo;data&rdquo;; the contrasts must produce an intra-subject model matrix in which
different terms are orthogonal. The default is c(&quot;contr.sum&quot;, &quot;contr.poly&quot;).</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_imatrix">imatrix</code></td>
<td>
<p>In lieu of <code>idata</code> and <code>idesign</code>, you can specify
the intra-subject design matrix directly via <code>imatrix</code>, in the form of
list of named elements.  Each element gives the columns of the
within-subject model matrix for an intra-subject term to be tested, and must
have as many rows as there are responses; the columns of the within-subject
model matrix for <em>different</em> terms must be mutually orthogonal.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_iterm">iterm</code></td>
<td>
<p>For repeated measures designs, you must specify one
intra-subject term (a character string) to select the SSPE (E) matrix used
in the HE plot.  Hypothesis terms plotted include the <code>iterm</code> effect as
well as all interactions of <code>iterm</code> with <code>terms</code>.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_manova">manova</code></td>
<td>
<p>optional <code>Anova.mlm</code> object for the model; if absent a
MANOVA is computed. Specifying the argument can therefore save computation
in repeated calls.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_size">size</code></td>
<td>
<p>how to scale the hypothesis ellipse relative to the error
ellipse; if <code>"evidence"</code>, the default, the scaling is done so that a
&ldquo;significant&rdquo; hypothesis ellipse at level <code>alpha</code> extends outside of
the error ellipse. <code>size = "significance"</code> is a synonym and does the same thing.
If <code>"effect.size"</code>, the hypothesis ellipse is on the
same scale as the error ellipse.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_level">level</code></td>
<td>
<p>equivalent coverage of ellipse  (assuming normally-distributed errors).
This defaults to <code>0.68</code>, giving a standard 1 SD bivariate ellipse.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_alpha">alpha</code></td>
<td>
<p>significance level for Roy's greatest-root test statistic; if
<code>size="evidence"</code> or <code>size="significance"</code>, then the hypothesis ellipse is scaled so that it
just touches the error ellipse at the specified alpha level. A larger
hypothesis ellipse <em>somewhere</em> in the space of the response variables
therefore indicates statistical significance; defaults to <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_segments">segments</code></td>
<td>
<p>number of segments composing each ellipsoid; defaults to <code>40</code>.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_col">col</code></td>
<td>
<p>a color or vector of colors to use in plotting ellipsoids; the
first color is used for the error ellipsoid; the remaining colors &mdash;
recycled as necessary &mdash; are used for the hypothesis ellipsoid.  A single
color can be given, in which case it is used for all ellipsoid.  For
convenience, the default colors for all heplots produced in a given session
can be changed by assigning a color vector via <code>options(heplot3d.colors=c(...)</code>.  
Otherwise, the default colors are <code>c("pink", "blue",
"black", "darkgreen", "darkcyan", "magenta", "brown", "darkgray")</code>.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_lwd">lwd</code></td>
<td>
<p>a two-element vector giving the line width for drawing ellipsoids
(including those that degenerate to an ellipse) and for drawing ellipsoids
that degenerate to a line segment. The default is <code>c(1, 4)</code>.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_shade">shade</code></td>
<td>
<p>a logical scalar or vector, indicating whether the ellipsoids
should be rendered with <code><a href="rgl.html#topic+shade3d">shade3d</a></code>. Works like <code>col</code>,
except that <code>FALSE</code> is used for any 1 df degenerate ellipsoid.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_shade.alpha">shade.alpha</code></td>
<td>
<p>a numeric value in the range [0,1], or a vector of such
values, giving the alpha transparency for ellipsoids rendered with
<code>shade=TRUE</code>.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_wire">wire</code></td>
<td>
<p>a logical scalar or vector, indicating whether the ellipsoids
should be rendered with <code><a href="rgl.html#topic+wire3d">wire3d</a></code>. Works like <code>col</code>,
except that <code>TRUE</code> is used for any 1 df degenerate ellipsoid.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_bg.col">bg.col</code></td>
<td>
<p>background colour, <code>"white"</code> or <code>"black"</code>,
defaulting to <code>"white"</code>.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_fogtype">fogtype</code></td>
<td>
<p>type of &ldquo;fog&rdquo; to use for depth-cueing; the default is
<code>"none"</code>. See <code><a href="rgl.html#topic+bg">bg</a></code>.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_fov">fov</code></td>
<td>
<p>field of view angle; controls perspective.  See
<code><a href="rgl.html#topic+viewpoint">viewpoint</a></code>.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_offset">offset</code></td>
<td>
<p>proportion of axes to off set labels; defaults to <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label; defaults to name of the x variable.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label; defaults to name of the y variable.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_zlab">zlab</code></td>
<td>
<p>z-axis label; defaults to name of the z variable.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_xlim">xlim</code></td>
<td>
<p>x-axis limits; if absent, will be computed from the data.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_ylim">ylim</code></td>
<td>
<p>y-axis limits; if absent, will be computed from the data.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_zlim">zlim</code></td>
<td>
<p>z-axis limits; if absent, will be computed from the data.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_cex.label">cex.label</code></td>
<td>
<p>text size for ellipse labels</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_add">add</code></td>
<td>
<p>if <code>TRUE</code>, add to the current plot; the default is
<code>FALSE</code>.  If <code>TRUE</code>, the error ellipsoid is neither plotted nor
returned in the output object.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, print the MANOVA table and details of
hypothesis tests; the default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="heplot3d_+3A_warn.rank">warn.rank</code></td>
<td>
<p>if <code>TRUE</code>, do not suppress warnings about the rank of
the hypothesis matrix when the ellipsoid collapses to an ellipse or line;
the default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the H matrix for a term has rank &lt; 3, the ellipsoid collapses to an
ellipse (rank(H)=2) or a line (rank(H)=1).
</p>
<p>Rotating the plot can be particularly revealing, showing views in which H
variation is particularly large or small in relation to E variation.  See
<code><a href="rgl.html#topic+play3d">play3d</a></code> and <code><a href="rgl.html#topic+movie3d">movie3d</a></code> for details on
creating animations.
</p>
<p>The arguments <code>xlim</code>, <code>ylim</code>, and <code>zlim</code> can be used to
expand the bounding box of the axes, but cannot decrease it.
</p>


<h3>Value</h3>

<p><code>heplot3d</code> invisibly returns a list containing the bounding
boxes of the error (E) ellipsoid and for each term or linear hypothesis
specified in the call.  Each of these is a 2 x 3 matrix with rownames &quot;min&quot;
and &quot;max&quot; and colnames corresponding to the variables plotted. An additional
component, <code>center</code>, contains the coordinates of the centroid in the
plot.
</p>
<p>The function also leaves an object named <code>.frame</code> in the global
environment, containing the rgl object IDs for the axes, axis labels, and
bounding box; these are deleted and the axes, etc.  redrawn if the plot is
added to.
</p>


<h3>References</h3>

<p>Friendly, M. (2006).  Data Ellipses, HE Plots and Reduced-Rank
Displays for Multivariate Linear Models: SAS Software and Examples
<em>Journal of Statistical Software</em>, 17(6), 1-42.
<a href="https://www.jstatsoft.org/v17/i06/">https://www.jstatsoft.org/v17/i06/</a>
</p>
<p>Friendly, M. (2007).  HE plots for Multivariate General Linear Models.
<em>Journal of Computational and Graphical Statistics</em>, 16(2) 421-444.
<a href="http://datavis.ca/papers/jcgs-heplots.pdf">http://datavis.ca/papers/jcgs-heplots.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+Anova">Anova</a></code>, <code><a href="car.html#topic+linearHypothesis">linearHypothesis</a></code>, for
details on MANOVA tests and linear hypotheses
</p>
<p><code><a href="#topic+heplot">heplot</a></code>, <code><a href="#topic+pairs.mlm">pairs.mlm</a></code>, for other plotting methods
for <code>mlm</code> objects
</p>
<p><code><a href="rgl.html#topic+rgl-package">rgl-package</a></code>, for details about 3D plots with <code>rgl</code>
</p>
<p><code><a href="candisc.html#topic+heplot3d.candisc">heplot3d.candisc</a></code> for 3D HE plots in canonical space.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Soils data, from carData package
data(Soils, package = "carData")
soils.mod &lt;- lm(cbind(pH,N,Dens,P,Ca,Mg,K,Na,Conduc) ~ Block + Contour*Depth, data=Soils)
car::Anova(soils.mod)

heplot(soils.mod, variables=c("Ca", "Mg"))
pairs(soils.mod, terms="Depth", variables=c("pH", "N", "P", "Ca", "Mg"))

heplot3d(soils.mod, variables=c("Mg", "Ca", "Na"), wire=FALSE)

# Plastic data
plastic.mod &lt;- lm(cbind(tear, gloss, opacity) ~ rate*additive, data=Plastic)
## Not run: 
heplot3d(plastic.mod, col=c("red", "blue", "brown", "green3"), wire=FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='heplots-internal'>Internal heplots functions</h2><span id='topic+heplots-internal'></span><span id='topic+lambda.crit'></span><span id='topic+HLT.crit'></span><span id='topic+Roy.crit'></span><span id='topic+he.rep'></span><span id='topic+termInfo'></span><span id='topic+last'></span><span id='topic+Pillai'></span><span id='topic+Wilks'></span><span id='topic+HL'></span><span id='topic+Roy'></span>

<h3>Description</h3>

<p>Internal functions for the heplots package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda.crit(
  alpha,
  p,
  dfh,
  dfe,
  test.statistic = c("Roy", "HLT", "Hotelling-Lawley")
)

Roy.crit(alpha, p, dfh, dfe)

HLT.crit(alpha, p, dfh, dfe)

he.rep(x, n)

Pillai(eig, q, df.res)

Wilks(eig, q, df.res)

HL(eig, q, df.res)

Roy(eig, q, df.res)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heplots-internal_+3A_alpha">alpha</code></td>
<td>
<p>significance level for critical values of multivariate
statistics</p>
</td></tr>
<tr><td><code id="heplots-internal_+3A_p">p</code></td>
<td>
<p>Number of variables</p>
</td></tr>
<tr><td><code id="heplots-internal_+3A_dfh">dfh</code></td>
<td>
<p>degrees of freedom for hypothesis</p>
</td></tr>
<tr><td><code id="heplots-internal_+3A_dfe">dfe</code></td>
<td>
<p>degrees of freedom for error</p>
</td></tr>
<tr><td><code id="heplots-internal_+3A_test.statistic">test.statistic</code></td>
<td>
<p>Test statistic used for the multivariate test</p>
</td></tr>
<tr><td><code id="heplots-internal_+3A_x">x</code></td>
<td>
<p>An argument to <code><a href="#topic+heplot">heplot</a></code> or <code><a href="#topic+heplot3d">heplot3d</a></code> that
is to be repeated for Error and all hypothesis terms</p>
</td></tr>
<tr><td><code id="heplots-internal_+3A_n">n</code></td>
<td>
<p>Number of hypothesis terms</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions calculate critical values of multivariate test statistics (Wilks' Lambda, Hotelling-Lawley
trace, Roy's maximum root test) used in setting the size of H ellipses relative to E.
They are not intended to be called by the user.
</p>


<h3>Value</h3>

<p>The critical value of the test statistic
</p>


<h3>Author(s)</h3>

<p>Michael Friendly <a href="mailto:friendly@yorku.ca">friendly@yorku.ca</a>
</p>

<hr>
<h2 id='Hernior'>Recovery from Elective Herniorrhaphy</h2><span id='topic+Hernior'></span>

<h3>Description</h3>

<p>A data set on measures of post-operative recovery of 32 patients undergoing
an elective herniorrhaphy operation, in relation to pre-operative measures.
</p>


<h3>Format</h3>

<p>A data frame with 32 observations on the following 9 variables.
</p>
 
<dl>
<dt><code>age</code></dt><dd><p>patient age</p>
</dd> 
<dt><code>sex</code></dt><dd><p>patient sex, a factor with levels <code>f</code> <code>m</code></p>
</dd> 
<dt><code>pstat</code></dt><dd><p>physical status (ignoring that associated with the operation). 
A 1-5 scale, with 1=perfect health, 5=very poor health.</p>
</dd> 
<dt><code>build</code></dt><dd><p>body build, a 1-5 scale, with 1=emaciated, 2=thin, 3=average, 4=fat, 5=obese.</p>
</dd>
<dt><code>cardiac</code></dt><dd><p>preoperative complications with heart, 1-4 scale, with 1=none, 2=mild, 3=moderate, 4=severe.</p>
</dd> 
<dt><code>resp</code></dt><dd><p>preoperative complications with respiration, 1-4 scale, with 1=none, 2=mild, 
3=moderate, 4=severe.</p>
</dd> 
<dt><code>leave</code></dt><dd><p>condition upon leaving the recovery room, a 1-4 scale, with 1=routine recovery, 2=intensive care for observation
overnight, 3=intensive care, with moderate care required, 4=intensive care,
with moderate care required.  </p>
</dd> 
<dt><code>los</code></dt><dd><p>length of stay in hospital after operation (days)</p>
</dd>
<dt><code>nurse</code></dt><dd><p>level of nursing required one week after operation, a
1-5 scale, with 1=intense, 2=heavy, 3=moderate, 4=light, 5=none (?); see Details</p>
</dd>
</dl>



<h3>Details</h3>

<p><code>leave</code>, <code>nurse</code> and <code>los</code> are outcome measures; the
remaining variables are potential predictors of recovery status.
</p>
<p>The variable <code>nurse</code> is recorded as 1-4, with remaining (20) entries
entered as &quot;-&quot; in both sources.  It is not clear whether this means &quot;none&quot;
or NA.  The former interpretation was used in constructing the R data frame,
so <code>nurse==5</code> for these observations. Using
<code>Hernior$nurse[Hernior$nurse==5] &lt;- NA</code> would change to the other
interpretation, but render <code>nurse</code> useless in a multivariate analysis.
</p>
<p>The ordinal predictors could instead be treated as factors, and there are
also potential interactions to be explored.
</p>


<h3>Source</h3>

<p>Mosteller, F. and Tukey, J. W. (1977), <em>Data analysis and
regression</em>, Reading, MA: Addison-Wesley. Data Exhibit 8, 567-568. Their
source: A study by B. McPeek and J. P. Gilbert of the Harvard Anesthesia
Center.
</p>


<h3>References</h3>

<p>Hand, D. J., Daly, F., Lunn, A. D., McConway, K. J. and
Ostrowski, E. (1994), <em>A Handbook of Small Data Sets</em>, Number 484,
390-391.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(car)
data(Hernior)
str(Hernior)
Hern.mod &lt;- lm(cbind(leave, nurse, los) ~ 
               age + sex +  pstat +  build + cardiac + resp, data=Hernior)
car::Anova(Hern.mod, test="Roy") # actually, all tests are identical

# test overall regression
print(linearHypothesis(Hern.mod, c("age", "sexm", "pstat", "build", "cardiac", "resp")), SSP=FALSE)

# joint test of age, sex &amp; caridac
print(linearHypothesis(Hern.mod, c("age", "sexm", "cardiac")), SSP=FALSE)

# HE plots
clr &lt;- c("red", "darkgray", "blue", "darkgreen", "magenta", "brown", "black")
heplot(Hern.mod, col=clr)
pairs(Hern.mod, col=clr)

## Enhancing the pairs plot ...
# create better variable labels
vlab &lt;- c("LeaveCondition\n(leave)", 
          "NursingCare\n(nurse)", 
          "LengthOfStay\n(los)")
# Add ellipse to test all 5 regressors simultaneously
hyp &lt;- list("Regr" = c("age", "sexm", "pstat", "build", "cardiac", "resp"))
pairs(Hern.mod, hypotheses=hyp, col=clr, var.labels=vlab)

## Views in canonical space for the various predictors
if (require(candisc)) {
	Hern.canL &lt;- candiscList(Hern.mod)
	plot(Hern.canL, term="age")
	plot(Hern.canL, term="sex")
	plot(Hern.canL, term="pstat")  # physical status
}


</code></pre>

<hr>
<h2 id='interpPlot'>Plot an Interpolation Between Two Related Data Sets</h2><span id='topic+interpPlot'></span>

<h3>Description</h3>

<p>Plot an interpolation between two related data sets, typically
transformations of each other. This function is designed to be used in
animations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpPlot(
  xy1,
  xy2,
  alpha,
  xlim,
  ylim,
  points = TRUE,
  add = FALSE,
  col = palette()[1],
  ellipse = FALSE,
  ellipse.args = NULL,
  abline = FALSE,
  col.lines = palette()[2],
  lwd = 2,
  id.method = "mahal",
  labels = rownames(xy1),
  id.n = 0,
  id.cex = 1,
  id.col = palette()[1],
  segments = FALSE,
  segment.col = "darkgray",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpPlot_+3A_xy1">xy1</code></td>
<td>
<p>First data set, a 2-column matrix or data.frame</p>
</td></tr>
<tr><td><code id="interpPlot_+3A_xy2">xy2</code></td>
<td>
<p>Second data set, a 2-column matrix or data.frame</p>
</td></tr>
<tr><td><code id="interpPlot_+3A_alpha">alpha</code></td>
<td>
<p>The value of the interpolation fraction, typically (but not
necessarily) <code>0 &lt;= alpha &lt;= 1)</code>.</p>
</td></tr>
<tr><td><code id="interpPlot_+3A_xlim">xlim</code>, <code id="interpPlot_+3A_ylim">ylim</code></td>
<td>
<p>x, y limits for the plot.  If not specified, the function
uses the ranges of <code>rbind(xy1, xy2)</code>.</p>
</td></tr>
<tr><td><code id="interpPlot_+3A_points">points</code></td>
<td>
<p>Logical. Whether to plot the points in the current interpolation?</p>
</td></tr>
<tr><td><code id="interpPlot_+3A_add">add</code></td>
<td>
<p>Logical. Whether to add to an existing plot?</p>
</td></tr>
<tr><td><code id="interpPlot_+3A_col">col</code></td>
<td>
<p>Color for plotted points.</p>
</td></tr>
<tr><td><code id="interpPlot_+3A_ellipse">ellipse</code></td>
<td>
<p>logical. <code>TRUE</code> to plot a <code>dataEllipse</code></p>
</td></tr>
<tr><td><code id="interpPlot_+3A_ellipse.args">ellipse.args</code></td>
<td>
<p>other arguments passed to <code>dataEllipse</code></p>
</td></tr>
<tr><td><code id="interpPlot_+3A_abline">abline</code></td>
<td>
<p>logical. <code>TRUE</code> to plot the linear regression line for <code>XY</code></p>
</td></tr>
<tr><td><code id="interpPlot_+3A_col.lines">col.lines</code></td>
<td>
<p>line color</p>
</td></tr>
<tr><td><code id="interpPlot_+3A_lwd">lwd</code></td>
<td>
<p>line width</p>
</td></tr>
<tr><td><code id="interpPlot_+3A_id.method">id.method</code></td>
<td>
<p>How points are to be identified. See <code><a href="car.html#topic+showLabels">showLabels</a></code>.</p>
</td></tr>
<tr><td><code id="interpPlot_+3A_labels">labels</code></td>
<td>
<p>observation labels</p>
</td></tr>
<tr><td><code id="interpPlot_+3A_id.n">id.n</code></td>
<td>
<p>Number of points to be identified. If set to zero, no points are identified.</p>
</td></tr>
<tr><td><code id="interpPlot_+3A_id.cex">id.cex</code></td>
<td>
<p>Controls the size of the plotted labels. The default is 1</p>
</td></tr>
<tr><td><code id="interpPlot_+3A_id.col">id.col</code></td>
<td>
<p>Controls the color of the plotted labels.</p>
</td></tr>
<tr><td><code id="interpPlot_+3A_segments">segments</code></td>
<td>
<p>logical. <code>TRUE</code> to draw lines segments from <code>xy1</code> to <code>xy</code></p>
</td></tr>
<tr><td><code id="interpPlot_+3A_segment.col">segment.col</code></td>
<td>
<p>line color for segments</p>
</td></tr>
<tr><td><code id="interpPlot_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>plot()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Points are plotted via the linear interpolation, </p>
<p style="text-align: center;"><code class="reqn"> XY = XY1 + \alpha
(XY2 - XY1)</code>
</p>

<p>The function allows plotting of the data ellipse, the linear regression
line, and line segments showing the movement of points.
</p>
<p>Interpolations other than linear can be obtained by using a non-linear
series of <code>alpha</code> values.  For example
<code>alpha=sin(seq(0,1,.1)/sin(1)</code> will give a sinusoid interpolation.
</p>


<h3>Value</h3>

<p>Returns invisibly the interpolated XY points.
</p>


<h3>Note</h3>

<p>The examples here just use on-screen animations to the console
graphics window. The <code><a href="animation.html#topic+animation">animation</a></code> package provides
facilities to save these in various formats.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+dataEllipse">dataEllipse</a></code>, <code><a href="car.html#topic+showLabels">showLabels</a></code>,
<code><a href="animation.html#topic+animation">animation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#################################################
# animate an AV plot from marginal to conditional
#################################################
data(Duncan, package="carData")
duncmod &lt;- lm(prestige ~ income + education, data=Duncan)
mod.mat &lt;- model.matrix(duncmod)

# function to do an animation for one variable
dunc.anim &lt;- function(variable, other, alpha=seq(0, 1, .1)) {
  var &lt;- which(variable==colnames(mod.mat))
  duncdev &lt;- scale(Duncan[,c(variable, "prestige")], scale=FALSE)
  duncav &lt;- lsfit(mod.mat[, -var], cbind(mod.mat[, var], Duncan$prestige), 
          intercept = FALSE)$residuals
  colnames(duncav) &lt;- c(variable, "prestige")
  
  lims &lt;- apply(rbind(duncdev, duncav),2,range)
  
  for (alp in alpha) {
    main &lt;- if(alp==0) paste("Marginal plot:", variable)
      else paste(round(100*alp), "% Added-variable plot:", variable)
    interpPlot(duncdev, duncav, alp, xlim=lims[,1], ylim=lims[,2], pch=16,
      main = main,
      xlab = paste(variable, "| ", alp, other),
      ylab = paste("prestige | ", alp, other),
      ellipse=TRUE, ellipse.args=(list(levels=0.68, fill=TRUE, fill.alpha=alp/2)), 
      abline=TRUE, id.n=3, id.cex=1.2, cex.lab=1.25)
    Sys.sleep(1)
  }
}

# show these in the R console
if(interactive()) {
dunc.anim("income", "education")

dunc.anim("education", "income")
}

############################################
# correlated bivariate data with 2 outliers
# show rotation from data space to PCA space
############################################

set.seed(123345)
x &lt;- c(rnorm(100), 2, -2)
y &lt;- c(x[1:100] + rnorm(100), -2, 2)
XY &lt;- cbind(x=x, y=y)
rownames(XY) &lt;- seq_along(x)
XY &lt;- scale(XY, center=TRUE, scale=FALSE)

# start, end plots

car::dataEllipse(XY, pch=16, levels=0.68, id.n=2)
mod &lt;- lm(y~x, data=as.data.frame(XY))
abline(mod, col="red", lwd=2)

pca &lt;- princomp(XY, cor=TRUE)
scores &lt;- pca$scores
car::dataEllipse(scores, pch=16, levels=0.68, id.n=2)
abline(lm(Comp.2 ~ Comp.1, data=as.data.frame(scores)), lwd=2, col="red")

# show interpolation

# functions for labels, as a function of alpha
main &lt;- function(alpha) {if(alpha==0) "Original data" 
  else if(alpha==1) "PCA scores"
  else paste(round(100*alpha,1), "% interpolation")}
xlab &lt;- function(alpha) {if(alpha==0) "X"
  else if(alpha==1) "PCA.1"
  else paste("X +", alpha, "(X - PCA.1)")}
ylab &lt;- function(alpha) {if(alpha==0) "Y"
  else if(alpha==1) "PCA.2"
  else paste("Y +", alpha, "(Y - PCA.2)")}

interpPCA &lt;- function(XY, alpha = seq(0,1,.1)) {
  XY &lt;- scale(XY, center=TRUE, scale=FALSE)
  if (is.null(rownames(XY))) rownames(XY) &lt;- 1:nrow(XY)
  pca &lt;- princomp(XY, cor=TRUE)
  scores &lt;- pca$scores

  for (alp in alpha) {
    interpPlot(XY, scores, alp, 
      pch=16,
      main = main(alp),
      xlab = xlab(alp),
      ylab = ylab(alp),
      ellipse=TRUE, ellipse.args=(list(levels=0.68, fill=TRUE, fill.alpha=(1-alp)/2)), 
      abline=TRUE, id.n=2, id.cex=1.2, cex.lab=1.25, segments=TRUE)
    Sys.sleep(1)
  }
}

# show in R console
if(interactive()) {
interpPCA(XY)
}

## Not run: 
library(animation)
saveGIF({
  interpPCA(XY, alpha &lt;- seq(0,1,.1))},
  movie.name="outlier-demo.gif", ani.width=480, ani.height=480, interval=1.5)


## End(Not run)


</code></pre>

<hr>
<h2 id='Iwasaki_Big_Five'>Personality Traits of Cultural Groups</h2><span id='topic+Iwasaki_Big_Five'></span>

<h3>Description</h3>

<p>This dataset, from Grice &amp; Iwasaki (2007), gives scores on the five
personality scales of the NEO PI-r (Costa &amp; McCrae, 1992), called the &quot;Big
Five&quot; personality traits: Neuroticism, Extraversion, Openness-to-Experience,
Agreeableness, and Conscientiousness.
</p>


<h3>Format</h3>

<p>A data frame with 203 observations on the following 7 variables.
</p>
 
<dl>
<dt><code>ID</code></dt><dd><p>ID number</p>
</dd> 
<dt><code>Group</code></dt><dd><p>a factor with
levels <code>Eur</code> <code>Asian_Amer</code> <code>Asian_Intl</code></p>
</dd>
<dt><code>N</code></dt><dd><p>Neuroticism score</p>
</dd> 
<dt><code>E</code></dt><dd><p>Extraversion score</p>
</dd>
<dt><code>O</code></dt><dd><p>Openness score</p>
</dd> 
<dt><code>A</code></dt><dd><p>Agreeableness score</p>
</dd>
<dt><code>C</code></dt><dd><p>Conscientiousness score</p>
</dd> 
</dl>



<h3>Details</h3>

<p>The groups are: 
</p>
 
<dl>
<dt>Eur</dt><dd><p>European Americans (Caucasians living in the United States their entire lives)</p>
</dd> 
<dt>Asian_Amer</dt><dd><p>Asian Americans (Asians living in the United States since before the age of 6 years)</p>
</dd>
<dt>Asian_Intl</dt><dd><p>Asian Internationals (Asians who moved to the United States after their 6th birthday)</p>
</dd> 
</dl>

<p>The factor <code>Group</code> is set up to compare E vs. Asian and the two Asian
groups
</p>


<h3>Source</h3>

<p>Grice, J., &amp; Iwasaki, M. (2007). A truly multivariate approach to
MANOVA.  <em>Applied Multivariate Research</em>, <b>12</b>, 199-226.
https://doi.org/10.22329/amr.v12i3.660.
</p>


<h3>References</h3>

<p>Costa Jr, P. T., &amp; McCrae, R. R. (1992).  <em>Revised NEO
Personality Inventory (NEO PI-R) and NEO Five-Factor Inventory (NEOFFI)
professional manual</em>.  Psychological Assessment Resources.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Iwasaki_Big_Five)
# use Helmert contrasts for groups
contrasts(Iwasaki_Big_Five$Group) &lt;- 
   matrix(c(2, -1, -1,
            0, -1,  1), ncol=2)

str(Iwasaki_Big_Five)

Big5.mod &lt;- lm(cbind(N, E, O, A, C) ~ Group, data=Iwasaki_Big_Five)
coef(Big5.mod)

car::Anova(Big5.mod)

# test contrasts
car::linearHypothesis(Big5.mod, "Group1", title = "Eur vs Asian")
car::linearHypothesis(Big5.mod, "Group2", title = "Asian: Amer vs Inter")

# heplots
labs &lt;- c("Neuroticism", "Extraversion", "Openness", "Agreeableness", "Conscientiousness" )

heplot(Big5.mod,
       fill = TRUE, fill.alpha = 0.2, 
       cex.lab = 1.5,
       xlab = labs[1], ylab = labs[2])

heplot(Big5.mod, variables = c(2,5),
       fill = TRUE, fill.alpha = 0.2,
       cex.lab = 1.5,
       xlab = labs[2], ylab = labs[5])

pairs(Big5.mod, 
      fill = TRUE, fill.alpha = 0.2, var.labels = labs)


# canonical discriminant analysis
if (require(candisc)) { 
library(candisc)
Big5.can &lt;- candisc(Big5.mod)
Big5.can
heplot(Big5.can, fill = TRUE, fill.alpha = 0.1)
}
</code></pre>

<hr>
<h2 id='label.ellipse'>Label an ellipse</h2><span id='topic+label.ellipse'></span>

<h3>Description</h3>

<p><code>label.ellipse</code> is used to a draw text label on an ellipse at its center or
somewhere around the periphery in a very flexible way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label.ellipse(
  ellipse,
  label,
  col = "black",
  label.pos = NULL,
  xpd = TRUE,
  tweak = 0.5 * c(strwidth("M"), strheight("M")),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="label.ellipse_+3A_ellipse">ellipse</code></td>
<td>
<p>A two-column matrix of coordinates for the ellipse boundary</p>
</td></tr>
<tr><td><code id="label.ellipse_+3A_label">label</code></td>
<td>
<p>Character string to be used as the ellipse label</p>
</td></tr>
<tr><td><code id="label.ellipse_+3A_col">col</code></td>
<td>
<p>Label color</p>
</td></tr>
<tr><td><code id="label.ellipse_+3A_label.pos">label.pos</code></td>
<td>
<p>Label position relative to the ellipse.  See details</p>
</td></tr>
<tr><td><code id="label.ellipse_+3A_xpd">xpd</code></td>
<td>
<p>Should the label be allowed to extend beyond the plot limits?</p>
</td></tr>
<tr><td><code id="label.ellipse_+3A_tweak">tweak</code></td>
<td>
<p>A vector of two lengths used to tweak label positions</p>
</td></tr>
<tr><td><code id="label.ellipse_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code>text</code>, e.g., <code>cex</code>, ...</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>label.pos=NULL</code>, the function uses the sign of the correlation
represented by the ellipse to determine a position
at the top (<code class="reqn">r&gt;=0</code>) or bottom (<code class="reqn">r&lt;0</code>) of the ellipse.
Integer values of 0, 1, 2, 3 and 4, respectively indicate positions 
at the center, below, to the left of, above 
and to the right of the max/min coordinates of the ellipse.
Label positions can also be specified as the corresponding character strings
<code>c("center", "bottom", "left", "top", "right")</code>, or compass directions, 
<code>c("C", "S", "W", "N", "E")</code>, or  
Other integer <code>label.pos</code> values, <code>5:nrow(ellipse)</code> are taken as indices of the row coordinates
to be used for the ellipse label. 
Equivalently, <code>label.pos</code> can also be a <em>fraction</em> in (0,1), interpreted
as the fraction of the way around the unit circle, counterclockwise from the point (1,0).
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="#topic+heplot">heplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>circle &lt;- function(center=c(0,0), radius=1, segments=60) {
   angles &lt;- (0:segments)*2*pi/segments
   circle &lt;- radius * cbind( cos(angles), sin(angles))
   t( c(center) + t( circle ))
}

label_demo &lt;- function(ell) {
  plot(-2:2, -2:2, type="n", asp=1, main="label.pos values and points (0:60)")
  lines(ell, col="gray")
  points(0, 0, pch="+", cex=2)
  
  labs &lt;- c("center", "bot", "left", "top", "right")
  for (i in 0:4) {
    label.ellipse(ell, label=paste(i, ":", labs[i+1]), label.pos = i)
  }
  for( i in 5*c(1,2, 4,5, 7,8, 10,11)) {
    points(ell[i,1], ell[i,2], pch=16)
    label.ellipse(ell, label=i, label.pos=i)
  }
}

circ &lt;- circle(radius=1.8)
label_demo(circ)

ell &lt;-circ %*% chol(matrix( c(1, .5, .5, 1), 2, 2)) 
label_demo(ell)
</code></pre>

<hr>
<h2 id='leveneTests'>Levene Tests of Homogeneity of Variances</h2><span id='topic+leveneTests'></span><span id='topic+leveneTests.default'></span><span id='topic+leveneTests.formula'></span><span id='topic+leveneTests.lm'></span>

<h3>Description</h3>

<p>This function extends <code><a href="car.html#topic+leveneTest">leveneTest</a></code> to a multivariate
response setting.  It performs the Levene test of homogeneity of variances
for each of a set of response variables, and prints a compact summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leveneTests(y, ...)

## Default S3 method:
leveneTests(y, group, center = median, ...)

## S3 method for class 'formula'
leveneTests(y, data, ...)

## S3 method for class 'lm'
leveneTests(y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="leveneTests_+3A_y">y</code></td>
<td>
<p>A data frame or matrix of numeric response variables for the default method,
or a model formula for a multivariate linear model, or the multivariate linear model itself.
In the case of a formula or model, the  variables on the right-hand-side of the model must all 
be factors and must be completely crossed.</p>
</td></tr>
<tr><td><code id="leveneTests_+3A_...">...</code></td>
<td>
<p>arguments to be passed down to <code><a href="car.html#topic+leveneTest">leveneTest</a></code>, e.g., <code>data</code> for the 
<code>formula</code> and <code>lm</code> methods; can also 
be used to pass arguments to the function given by center (e.g., center=mean and trim=0.1 specify 
the 10% trimmed mean) other arguments.</p>
</td></tr>
<tr><td><code id="leveneTests_+3A_group">group</code></td>
<td>
<p>a vector or factor object giving the group for the
corresponding elements of the rows of <code>y</code> for the default method</p>
</td></tr>
<tr><td><code id="leveneTests_+3A_center">center</code></td>
<td>
<p>The name of a function to compute the center of each group;
<code>mean</code> gives the original Levene's (1960) test; the default,
<code>median</code>, provides a more robust test suggested by Brown and Forsythe (1974).</p>
</td></tr>
<tr><td><code id="leveneTests_+3A_data">data</code></td>
<td>
<p>the data set, for the <code>formula</code> method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of classes &quot;anova&quot; and &quot;data.frame&quot;, with one observation
for each response variable in <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>References</h3>

<p>Levene, H. (1960). Robust Tests for Equality of Variances. In
Olkin, I. <em>et al.</em> (Eds.), <em>Contributions to Probability and
Statistics: Essays in Honor of Harold Hotelling</em>, Stanford University Press,
278-292.
</p>
<p>Brown, M. B. &amp; Forsythe, A. B. (1974). Robust Tests For Equality Of
Variances <em>Journal of the American Statistical Association</em>, <b>69</b>,
364-367.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+leveneTest">leveneTest</a></code>, <code><a href="#topic+bartlettTests">bartlettTests</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
leveneTests(iris[,1:4], iris$Species)

# handle a 1-column response?
leveneTests(iris[,1, drop=FALSE], iris$Species)

data(Skulls, package="heplots")
leveneTests(Skulls[,-1], Skulls$epoch)

# formula method
leveneTests(cbind(mb, bh, bl, nh) ~ epoch, data=Skulls)

# use 10% trimmed means
leveneTests(cbind(mb, bh, bl, nh) ~ epoch, data=Skulls, trim = 0.1)


# mlm method
skulls.mod &lt;- lm(cbind(mb, bh, bl, nh) ~ epoch, data=Skulls)
leveneTests(skulls.mod)

</code></pre>

<hr>
<h2 id='logdetCI'>Calculate confidence interval for log determinant of covariance matrices</h2><span id='topic+logdetCI'></span>

<h3>Description</h3>

<p>This function uses asymptotic results described by Cai et. al (2016),
Theorem 1, to calculate approximate, normal theory confidence intervals
(CIs) for the log determinant of one or more sample covariance matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logdetCI(cov, n, conf = 0.95, method = 1, bias.adj = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logdetCI_+3A_cov">cov</code></td>
<td>
<p>a covariance matrix or a (named) list of covariance matrices, all the same size</p>
</td></tr>
<tr><td><code id="logdetCI_+3A_n">n</code></td>
<td>
<p>sample size, or vector of sample sizes, one for each covariance matrix</p>
</td></tr>
<tr><td><code id="logdetCI_+3A_conf">conf</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="logdetCI_+3A_method">method</code></td>
<td>
<p>Three methods are provided, based on Cai et. al Theorem 1
(<code>method=1</code>), Corollary 1 (<code>method=2</code>) and Corollary 2
(<code>method=3</code>), each with different bias and SE values.</p>
</td></tr>
<tr><td><code id="logdetCI_+3A_bias.adj">bias.adj</code></td>
<td>
<p>logical; set <code>FALSE</code> to exclude the bias correction term.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Their results are translated into a CI via the approximation 
</p>
<p style="text-align: center;"><code class="reqn"> \log det( \widehat{\Sigma} ) - bias \pm z_{1 - \alpha/2} \times SE </code>
</p>
 
<p>where <code class="reqn">\widehat{\Sigma}</code> 
is the sample estimate of a population covariance matrix,
<code class="reqn">bias</code> is a bias correction constant and <code class="reqn">SE</code> is a width factor for
the confidence interval.  Both <code class="reqn">bias</code> and <code class="reqn">SE</code> are functions of the
sample size, <code class="reqn">n</code> and number of variables, <code class="reqn">p</code>.
</p>
<p>This function is included here only to provide an approximation to
<em>graphical accuracy</em> for use with Box's M test for equality of
covariance matrices, <code><a href="#topic+boxM">boxM</a></code> and its associated
<code><a href="#topic+plot.boxM">plot.boxM</a></code> method.
</p>
<p>Cai et. al (2015) claim that their Theorem 1 holds with either <code class="reqn">p</code> fixed
or <code class="reqn">p(n)</code> growing with <code class="reqn">n</code>, as long as <code class="reqn">p(n) \le n</code>. Their
Corollary 1 (<code>method=2</code>) is the special case when <code class="reqn">p</code> is fixed.
Their Corollary 2 (<code>method=3</code>) is the special case when <code class="reqn">0 \le p/n
&lt; 1</code> is fixed.
</p>
<p>The properties of this CI estimator are unknown in small to moderate sample
sizes, but it seems to be the only one available.  It is therefore
experimental in this version of the package and is subject to change in the
future.
</p>
<p>The <code class="reqn">bias</code> term offsets the confidence interval from the sample estimate
of <code class="reqn"> \log det( \widehat{\Sigma} ) </code>. When <code class="reqn">p</code> is large relative to
<code class="reqn">n</code>, the confidence interval may not overlap the sample estimate.
</p>
<p>Strictly speaking, this estimator applies to the MLE of the covariance
matrix <code class="reqn"> \widehat{\Sigma}</code>, i.e., using <code class="reqn">n</code> rather than <code class="reqn">n-1</code> in
as the divisor.  The factor <code class="reqn">(n-1 / n)</code> has not yet been taken into
account here.
</p>


<h3>Value</h3>

<p>A data frame with one row for each covariance matrix. <code>lower</code>
and <code>upper</code> are the boundaries of the confidence intervals. Other
columns are <code>logdet, bias, se</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>References</h3>

<p>Cai, T. T.; Liang, T. &amp; Zhou, H. H. (2015) Law of log determinant of sample
covariance matrix and optimal estimation of differential entropy for
high-dimensional Gaussian distributions. <em>Journal of Multivariate
Analysis</em>, 137, 161-172.
<a href="https://doi.org/10.1016/j.jmva.2015.02.003">doi:10.1016/j.jmva.2015.02.003</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boxM">boxM</a></code>, <code><a href="#topic+plot.boxM">plot.boxM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iris)
iris.mod &lt;- lm(as.matrix(iris[,1:4]) ~ iris$Species)
iris.boxm &lt;- boxM(iris.mod)
cov &lt;- c(iris.boxm$cov, list(pooled=iris.boxm$pooled))
n &lt;- c(rep(50, 3), 150)

CI &lt;- logdetCI( cov, n=n, conf=.95, method=1)
CI
plot(iris.boxm, xlim=c(-14, -8), main="Iris data, Box's M test", gplabel="Species")
arrows(CI$lower, 1:4, CI$upper, 1:4, lwd=3, angle=90, len=.1, code=3)

CI &lt;- logdetCI( cov, n=n, conf=.95, method=1, bias.adj=FALSE)
CI
plot(iris.boxm, xlim=c(-14, -8), main="Iris data, Box's M test", gplabel="Species")
arrows(CI$lower, 1:4, CI$upper, 1:4, lwd=3, angle=90, len=.1, code=3)


</code></pre>

<hr>
<h2 id='Mahalanobis'>Classical and Robust Mahalanobis Distances</h2><span id='topic+Mahalanobis'></span>

<h3>Description</h3>

<p>This function is a convenience wrapper to <code><a href="stats.html#topic+mahalanobis">mahalanobis</a></code>
offering also the possibility to calculate robust Mahalanobis squared
distances using MCD and MVE estimators of center and covariance (from
<code><a href="MASS.html#topic+cov.rob">cov.rob</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mahalanobis(
  x,
  center,
  cov,
  method = c("classical", "mcd", "mve"),
  nsamp = "best",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Mahalanobis_+3A_x">x</code></td>
<td>
<p>a numeric matrix or data frame with, say, <code class="reqn">p</code> columns</p>
</td></tr>
<tr><td><code id="Mahalanobis_+3A_center">center</code></td>
<td>
<p>mean vector of the data; if this and <code>cov</code> are both supplied,
the function simply calls <code><a href="stats.html#topic+mahalanobis">mahalanobis</a></code> to 
calculate the result</p>
</td></tr>
<tr><td><code id="Mahalanobis_+3A_cov">cov</code></td>
<td>
<p>covariance matrix (p x p) of the data</p>
</td></tr>
<tr><td><code id="Mahalanobis_+3A_method">method</code></td>
<td>
<p>estimation method used for center and covariance, one of:
<code>"classical"</code> (product-moment), 
<code>"mcd"</code> (minimum covariance determinant), or           
<code>"mve"</code> (minimum volume ellipsoid).</p>
</td></tr>
<tr><td><code id="Mahalanobis_+3A_nsamp">nsamp</code></td>
<td>
<p>passed to <code><a href="MASS.html#topic+cov.rob">cov.rob</a></code></p>
</td></tr>
<tr><td><code id="Mahalanobis_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="MASS.html#topic+cov.rob">cov.rob</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any missing data in a row of <code>x</code> causes <code>NA</code> to be returned for
that row.
</p>


<h3>Value</h3>

<p>a vector of length <code>nrow(x)</code> containing the squared distances.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+mahalanobis">mahalanobis</a></code>, <code><a href="MASS.html#topic+cov.rob">cov.rob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
summary(Mahalanobis(iris[, 1:4]))
summary(Mahalanobis(iris[, 1:4], method="mve"))
summary(Mahalanobis(iris[, 1:4], method="mcd"))


</code></pre>

<hr>
<h2 id='mark.H0'>Mark a point null hypothesis in an HE plot</h2><span id='topic+mark.H0'></span>

<h3>Description</h3>

<p>A utility function to draw and label a point in a 2D (or 3D) HE plot
corresponding to a point null hypothesis being tested. This is most useful
for repeated measure designs where null hypotheses for within-S effects
often correspond to (0,0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mark.H0(
  x = 0,
  y = 0,
  z = NULL,
  label,
  cex = 2,
  pch = 19,
  col = "green3",
  lty = 2,
  pos = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mark.H0_+3A_x">x</code></td>
<td>
<p>Horizontal coordinate for H0</p>
</td></tr>
<tr><td><code id="mark.H0_+3A_y">y</code></td>
<td>
<p>Vertical coordinate for H0</p>
</td></tr>
<tr><td><code id="mark.H0_+3A_z">z</code></td>
<td>
<p>z coordinate for H0.  If not NULL, the function assumes that a
<code>heplot3d</code> plot has been drawn.</p>
</td></tr>
<tr><td><code id="mark.H0_+3A_label">label</code></td>
<td>
<p>Text used to label the point. Defaults to
<code>expression(H[0])</code> in 2D plots.</p>
</td></tr>
<tr><td><code id="mark.H0_+3A_cex">cex</code></td>
<td>
<p>Point and text size.  For 3D plots, the function uses
<code>size=5*cex</code> in a call to <code><a href="rgl.html#topic+points3d">points3d</a></code>.</p>
</td></tr>
<tr><td><code id="mark.H0_+3A_pch">pch</code></td>
<td>
<p>Plot character.  Ignored for 3D plots.</p>
</td></tr>
<tr><td><code id="mark.H0_+3A_col">col</code></td>
<td>
<p>Color for text, character and lines</p>
</td></tr>
<tr><td><code id="mark.H0_+3A_lty">lty</code></td>
<td>
<p>Line type for vertical and horizontal reference lines. Not drawn if <code>lty</code>=0.</p>
</td></tr>
<tr><td><code id="mark.H0_+3A_pos">pos</code></td>
<td>
<p>Position of text.  Ignored for 3D plots</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Used for side effect of drawing on the current plot.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cross3d">cross3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Vocab.mod &lt;- lm(cbind(grade8,grade9,grade10,grade11) ~ 1, data=VocabGrowth)
idata &lt;-data.frame(grade=ordered(8:11))

heplot(Vocab.mod, type="III", idata=idata, idesign=~grade, iterm="grade",
	main="HE plot for Grade effect")
mark.H0()

</code></pre>

<hr>
<h2 id='mathscore'>Math scores for basic math and word problems</h2><span id='topic+mathscore'></span>

<h3>Description</h3>

<p>Scores for two groups of school children taught by different math teachers
and tested for both basic math (BM) problems and solving word problems (WP).
</p>


<h3>Format</h3>

<p>A data frame with 12 observations on the following 3 variables.
</p>
 
<dl>
<dt><code>group</code></dt><dd><p>a factor with levels <code>1</code> <code>2</code></p>
</dd>
<dt><code>BM</code></dt><dd><p>Basic Math score, a numeric vector</p>
</dd> 
<dt><code>WP</code></dt><dd><p>Word Problems score, a numeric vector</p>
</dd> 
</dl>



<h3>Source</h3>

<p>Fictitious data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mathscore)
str(mathscore)

math.mod &lt;- lm(cbind(BM, WP) ~ group, data=mathscore)
car::Anova(math.mod)

# scatterplot with data ellipses
car::scatterplot(WP ~ BM | group, data=mathscore, 
	ellipse=list(levels=0.68), smooth=FALSE, pch=c(15,16), 
	legend=list(coords = "topright"))

# HE plot
heplot(math.mod, fill=TRUE, 
  cex=2, cex.lab=1.8,
	xlab="Basic math", ylab="Word problems")




</code></pre>

<hr>
<h2 id='MockJury'>Effects Of Physical Attractiveness Upon Mock Jury Decisions</h2><span id='topic+MockJury'></span>

<h3>Description</h3>

<p>Male participants were shown a picture of one of three young women.  Pilot
work had indicated that the one woman was beautiful, another of average
physical attractiveness, and the third unattractive.  Participants rated the
woman they saw on each of twelve attributes.  These measures were used to
check on the manipulation by the photo.
</p>


<h3>Format</h3>

<p>A data frame with 114 observations on the following 17 variables.
</p>
 
<dl>
<dt><code>Attr</code></dt><dd><p>Attractiveness of the photo, a factor with levels <code>Beautiful</code> <code>Average</code> <code>Unattractive</code></p>
</dd>
<dt><code>Crime</code></dt><dd><p>Type of crime, a factor with levels <code>Burglary</code> (theft of items from victim's room) <code>Swindle</code> (conned a male victim)</p>
</dd>
<dt><code>Years</code></dt><dd><p>length of sentence given the defendant by the mock juror subject</p>
</dd> 
<dt><code>Serious</code></dt><dd><p>a rating of how serious the subject thought the defendant's crime was</p>
</dd> 
<dt><code>exciting</code></dt><dd><p>rating of the photo for 'exciting'</p>
</dd> 
<dt><code>calm</code></dt><dd><p>rating of the photo for 'calm'</p>
</dd>
<dt><code>independent</code></dt><dd><p>rating of the photo for 'independent'</p>
</dd>
<dt><code>sincere</code></dt><dd><p>rating of the photo for 'sincere'</p>
</dd>
<dt><code>warm</code></dt><dd><p>rating of the photo for 'warm'</p>
</dd>
<dt><code>phyattr</code></dt><dd><p>rating of the photo for 'physical attractiveness'</p>
</dd>
<dt><code>sociable</code></dt><dd><p>rating of the photo for 'exciting'</p>
</dd>
<dt><code>kind</code></dt><dd><p>rating of the photo for 'kind'</p>
</dd>
<dt><code>intelligent</code></dt><dd><p>rating of the photo for 'intelligent'</p>
</dd>
<dt><code>strong</code></dt><dd><p>rating of the photo for 'strong'</p>
</dd>
<dt><code>sophisticated</code></dt><dd><p>rating of the photo for 'sophisticated'</p>
</dd>
<dt><code>happy</code></dt><dd><p>rating of the photo for 'happy'</p>
</dd>
<dt><code>ownPA</code></dt><dd><p>self-rating of the subject for 'physical attractiveness'</p>
</dd> 
</dl>



<h3>Details</h3>

<p>Then the participants were told that the person in the photo had committed a
Crime, and asked to rate the seriousness of the crime and recommend a prison
sentence, in Years.
</p>
<p>Does attractiveness of the &quot;defendant&quot; influence the sentence or perceived
seriousness of the crime?  Does attractiveness interact with the nature of
the crime?
</p>


<h3>Source</h3>

<p>Originally obtained from Dr. Wuensch's StatData page at East Carolina University. No longer exists.
</p>


<h3>References</h3>

<p>Data from the thesis by Plaster, M. E. (1989). <em>Inmates as
mock jurors: The effects of physical attractiveness upon juridic decisions.</em>
M.A. thesis, Greenville, NC: East Carolina University.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# manipulation check:  test ratings of the photos classified by Attractiveness
jury.mod1 &lt;- lm( cbind(phyattr, happy, independent, sophisticated) ~ Attr, data=MockJury)
car::Anova(jury.mod1, test="Roy")

heplot(jury.mod1, main="HE plot for manipulation check")
pairs(jury.mod1)

if (require(candisc)) {
	jury.can &lt;- candisc(jury.mod1)
	jury.can
	heplot(jury.can, main="Canonical HE plot")
}

# influence of Attr of photo and nature of crime on Serious and Years
jury.mod2 &lt;- lm( cbind(Serious, Years) ~ Attr * Crime, data=MockJury)
car::Anova(jury.mod2, test="Roy")
heplot(jury.mod2)

# stepdown test (ANCOVA), controlling for Serious
jury.mod3 &lt;- lm( Years ~ Serious + Attr * Crime, data=MockJury)
car::Anova(jury.mod3)

# need to consider heterogeneous slopes?
jury.mod4 &lt;- lm( Years ~ Serious * Attr * Crime, data=MockJury)
car::Anova(jury.mod3, jury.mod4)


</code></pre>

<hr>
<h2 id='NeuroCog'>Neurocognitive Measures in Psychiatric Groups</h2><span id='topic+NeuroCog'></span>

<h3>Description</h3>

<p>The primary purpose of the study (Hartman, 2016, Heinrichs et al. (2015))
was to evaluate patterns and levels of performance on neurocognitive
measures among individuals with schizophrenia and schizoaffective disorder
using a well-validated, comprehensive neurocognitive battery specifically
designed for individuals with psychosis (Heinrichs et al. (2008))
</p>


<h3>Format</h3>

<p>A data frame with 242 observations on the following 10 variables.
</p>
 
<dl>
<dt><code>Dx</code></dt><dd><p>Diagnostic group, a factor with levels <code>Schizophrenia</code> <code>Schizoaffective</code> <code>Control</code></p>
</dd>
<dt><code>Speed</code></dt><dd><p>Speed of processing domain T score, a numeric vector</p>
</dd>
<dt><code>Attention</code></dt><dd><p>Attention/Vigilance Domain T score, a numeric vector</p>
</dd> 
<dt><code>Memory</code></dt><dd><p>Working memory a numeric vector</p>
</dd>
<dt><code>Verbal</code></dt><dd><p>Verbal Learning Domain T score, a numeric vector</p>
</dd>
<dt><code>Visual</code></dt><dd><p>Visual Learning Domain T score, a numeric vector</p>
</dd>
<dt><code>ProbSolv</code></dt><dd><p>Reasoning/Problem Solving Domain T score, a numeric vector</p>
</dd> 
<dt><code>SocialCog</code></dt><dd><p>Social Cognition Domain T score, a numeric vector</p>
</dd> 
<dt><code>Age</code></dt><dd><p>Subject age, a numeric vector</p>
</dd>
<dt><code>Sex</code></dt><dd><p>Subject gender, a factor with levels <code>Female</code> <code>Male</code></p>
</dd> 
</dl>



<h3>Details</h3>

<p>The main interest was in determining how well these measures distinguished
among all groups and whether there were variables that distinguished between
the schizophrenia and schizoaffective groups.
</p>
<p>Neurocognitive function was assessed using the MATRICS Consensus Cognitive
Battery (MCCB; Nuechterlein et al., 2008). The MCCB consists of 10
individually administered tests that measure cognitive performance in seven
domains: speed of processing, attention/vigilance, working memory, verbal
learning, visual learning, reasoning and problem solving, and social
cognition.
</p>
<p>The clinical sample comprised 116 male and female patients who met the
following criteria: 1) a diagnosis of schizophrenia (n = 70) or
schizoaffective disorder (n = 46) confirmed by the Structured Clinical
Interview for DSM-IV-TR Axis I Disorders; 2) outpatient status; 3) a history
free of developmental or learning disability; 4) age 18-65; 5) a history
free of neurological or endocrine disorder; and 6) no concurrent DSM-IV-TR
diagnosis of substance use disorder.
</p>
<p>Non-psychiatric control participants (n = 146) were screened for medical and
psychiatric illness and history of substance abuse. Patients were recruited
from three outpatient clinics in Hamilton, Ontario, Canada. Control
participants were recruited through local newspaper and online classified
advertisements for paid research participation.
</p>


<h3>Source</h3>

<p>Hartman, L. I. (2016). Schizophrenia and Schizoaffective Disorder:
One Condition or Two? Unpublished PhD dissertation, York University.
</p>
<p>Heinrichs, R.W., Pinnock, F., Muharib, E., Hartman, L.I., Goldberg, J.O., &amp;
McDermid Vaz, S. (2015).  Neurocognitive normality in schizophrenia
revisited.  
<em>Schizophrenia Research: Cognition</em>, <b>2</b> (4), 227-232.
<code>doi: 10.1016/j.scog.2015.09.001</code>
</p>


<h3>References</h3>

<p>Heinrichs, R. W., Ammari, N., McDermid Vaz, S. &amp; Miles, A.
(2008). Are schizophrenia and schizoaffective disorder neuropsychologically
distinguishable?  <em>Schizophrenia Research</em>, <b>99</b>, 149-154.
</p>
<p>Nuechterlein K.H., Green M.F., Kern R.S., Baade L.E., Barch D., Cohen J.,
Essock S., Fenton W.S., Frese F.J., Gold J.M., Goldberg T., Heaton R., Keefe
R.S.E., Kraemer H., Mesholam-Gately R., Seidman L.J., Stover E., Weinberger
D.R., Young A.S., Zalcman S., Marder S.R. (2008) The MATRICS Consensus
Cognitive Battery, Part 1: Test selection, reliability, and validity.
<em>American Journal of Psychiatry</em>, <b>165</b> (2), 203-213.
<a href="https://pubmed.ncbi.nlm.nih.gov/18172019/">https://pubmed.ncbi.nlm.nih.gov/18172019/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(car)
data(NeuroCog)
NC.mlm &lt;- lm(cbind( Speed, Attention, Memory, Verbal, Visual, ProbSolv) ~ Dx,
               data=NeuroCog)
Anova(NC.mlm)

# test contrasts
contrasts(NeuroCog$Dx)
print(linearHypothesis(NC.mlm, "Dx1"), SSP=FALSE)
print(linearHypothesis(NC.mlm, "Dx2"), SSP=FALSE)

# pairwise HE plots
pairs(NC.mlm, var.cex=1.5)

# canonical discriminant analysis
if (require(candisc)) {
  NC.can &lt;- candisc(NC.mlm)
  NC.can
  
  plot(NC.can, ellipse=TRUE, rev.axes=c(TRUE,FALSE), pch=c(7,9,10))
}


</code></pre>

<hr>
<h2 id='NLSY'>National Longitudinal Survey of Youth Data</h2><span id='topic+NLSY'></span>

<h3>Description</h3>

<p>The dataset come from a small random sample of the U.S. National
Longitudinal Survey of Youth.
</p>


<h3>Format</h3>

<p>A data frame with 243 observations on the following 6 variables.
</p>
 
<dl>
<dt><code>math</code></dt><dd><p>Math achievement test score</p>
</dd>
<dt><code>read</code></dt><dd><p>Reading achievement test score</p>
</dd>
<dt><code>antisoc</code></dt><dd><p>score on a measure of child's antisocial behavior, <code>0:6</code></p>
</dd> 
<dt><code>hyperact</code></dt><dd><p>score on a measure of child's
hyperactive behavior, <code>0:5</code></p>
</dd> <dt><code>income</code></dt><dd><p>yearly income of child's father</p>
</dd> 
<dt><code>educ</code></dt><dd><p>years of education of child's father</p>
</dd> 
</dl>



<h3>Details</h3>

<p>In this dataset, <code>math</code> and <code>read</code> scores are taken at the outcome
variables. Among the remaining predictors, <code>income</code> and <code>educ</code>
might be considered as background variables necessary to control for.
Interest might then be focused on whether the behavioural variables
<code>antisoc</code> and <code>hyperact</code> contribute beyond that.
</p>


<h3>Source</h3>

<p>This dataset was derived from a larger one used by Patrick Curran at
the 1997 meeting of the Society for Research on Child Development (SRCD). A
description now only exists on the WayBack Machine,
<a href="http://web.archive.org/web/20050404145001/http://www.unc.edu/~curran/example.html">http://web.archive.org/web/20050404145001/http://www.unc.edu/~curran/example.html</a>.
</p>
<p>More details are available at
<a href="http://web.archive.org/web/20060830061414/http://www.unc.edu/~curran/srcd-docs/srcdmeth.pdf">http://web.archive.org/web/20060830061414/http://www.unc.edu/~curran/srcd-docs/srcdmeth.pdf</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(car)
data(NLSY)

#examine the data
scatterplotMatrix(NLSY, smooth=FALSE)

# test control variables by themselves
# -------------------------------------
mod1 &lt;- lm(cbind(read,math) ~ income+educ, data=NLSY)
Anova(mod1)
heplot(mod1, fill=TRUE)

# test of overall regression
coefs &lt;- rownames(coef(mod1))[-1]
linearHypothesis(mod1, coefs)
heplot(mod1, fill=TRUE, hypotheses=list("Overall"=coefs))

 
# additional contribution of antisoc + hyperact over income + educ
# ----------------------------------------------------------------
mod2 &lt;- lm(cbind(read,math) ~ antisoc + hyperact + income + educ, data=NLSY)
Anova(mod2)

coefs &lt;- rownames(coef(mod2))[-1]
heplot(mod2, fill=TRUE, hypotheses=list("Overall"=coefs, "mod2|mod1"=coefs[1:2]))
linearHypothesis(mod2, coefs[1:2])

heplot(mod2, fill=TRUE, hypotheses=list("mod2|mod1"=coefs[1:2]))


</code></pre>

<hr>
<h2 id='oral'>Effect of Delay in Oral Practice in Second Language Learning</h2><span id='topic+oral'></span>

<h3>Description</h3>

<p>Postovsky (1970) investigated the effect of delay in oral practice at the beginning of second language learning.
A control condition began oral practice with no delay, while an experimental group had a four-week delay before
starting oral practice. The data consists of scores on language skills at the end of six weeks of study.
</p>
<p>Students in this study were matched on age, education, former language training, intelligence and language aptitude.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("oral")
</code></pre>


<h3>Format</h3>

<p>A data frame with 56 observations on the following 5 variables.
</p>

<dl>
<dt><code>group</code></dt><dd><p>Group, a factor with levels <code>Control</code> <code>Exptl</code></p>
</dd>
<dt><code>listen</code></dt><dd><p>Listening test, a numeric vector</p>
</dd>
<dt><code>speak</code></dt><dd><p>Speaking test, a numeric vector</p>
</dd>
<dt><code>read</code></dt><dd><p>Reading test, a numeric vector</p>
</dd>
<dt><code>write</code></dt><dd><p>Writing test, a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Timm, N. H. (1975). <em>Multivariate Analysis with Applications in Education and Psychology</em>. Wadsworth (Brooks/Cole),
Exercise 3.12, p. 279.
</p>


<h3>References</h3>

<p>Postovsky, V. A. (1970). Effects of delay in oral practice at the start of second language training. Unpublished doctoral dissertation, 
University of California, Berkeley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(car)
library(candisc)
data(oral)

# make some boxplots
op &lt;- par(mfrow=c(1,4), cex.lab=1.5)
clr &lt;- c("pink", "lightblue")
Boxplot(listen ~ group, data=oral, col = clr, cex.lab = 1.5)
Boxplot(speak ~  group, data=oral, col = clr, cex.lab = 1.5)
Boxplot(read ~   group, data=oral, col = clr, cex.lab = 1.5)
Boxplot(write ~  group, data=oral, col = clr, cex.lab = 1.5)
par(op)

# view the data ellipses
covEllipses(cbind(listen, speak, read, write) ~ group, data=oral,
    variables = 1:4,
    level = 0.40,
    pooled = FALSE,
    fill = TRUE, fill.alpha = 0.05)

oral.mod &lt;- lm(cbind(listen, speak, read, write) ~ group, data=oral)
Anova(oral.mod)

# canonical view
oral.can &lt;- candisc(oral.mod) |&gt; print()
summary(oral.can)

# reflect the structure &amp; scores to make them positive
oral.can$structure[, "Can1"] &lt;- -1 * oral.can$structure[, "Can1"]
oral.can$scores[, "Can1"]    &lt;- -1 * oral.can$scores[, "Can1"]

plot(oral.can, var.lwd=2)


</code></pre>

<hr>
<h2 id='Oslo'>Oslo Transect Subset Data</h2><span id='topic+Oslo'></span>

<h3>Description</h3>

<p>The Oslo data set contains chemical concentrations of 332 samples of
different plant species collected along a 120 km transect running through
the city of Oslo, Norway. It is a subset of the
<code><a href="rrcov.html#topic+OsloTransect">OsloTransect</a></code> data provided by the <code>rrcov</code> package.
</p>


<h3>Format</h3>

<p>A data frame with 332 observations on the following 14 variables.
</p>
 
<dl>
<dt><code>site</code></dt><dd><p>transect site ID, a factor with levels
<code>102</code> <code>103</code> <code>104</code> <code>105</code> <code>106</code> <code>107</code> <code>108</code>
<code>109</code> <code>111</code> <code>112</code> <code>113</code> <code>114</code> <code>115</code> <code>116</code>
<code>117</code> <code>118</code> <code>119</code> <code>121</code> <code>122</code> <code>123</code> <code>124</code>
<code>125</code> <code>126</code> <code>127</code> <code>128</code> <code>129</code> <code>131</code> <code>132</code>
<code>133</code> <code>134</code> <code>135</code> <code>136</code> <code>138</code> <code>139</code> <code>141</code>
<code>142</code> <code>143</code> <code>144</code></p>
</dd> 
<dt><code>XC</code></dt><dd><p>X coordinate, a numeric vector</p>
</dd> 
<dt><code>YC</code></dt><dd><p>Y coordinate, a numeric vector</p>
</dd>
<dt><code>forest</code></dt><dd><p>forest type, a factor with levels <code>birspr</code>
<code>mixdec</code> <code>pine</code> <code>sprbir</code> <code>sprpin</code> <code>spruce</code></p>
</dd>
<dt><code>weather</code></dt><dd><p>weather type, a factor with levels <code>cloud</code>
<code>moist</code> <code>nice</code> <code>rain</code></p>
</dd> <dt><code>litho</code></dt><dd><p>lithological
type, a factor with levels <code>camsed</code> (Cambro-Silurian sedimentary),
<code>gneis_o</code> (Precambrian gneisses - Oslo), <code>gneis_r</code> (- Randsfjord),
<code>magm</code> (Magmatic rocks)</p>
</dd> 
<dt><code>altitude</code></dt><dd><p>altitude, a numeric vector</p>
</dd> 
<dt><code>Cu</code></dt><dd><p>Copper, a numeric vector</p>
</dd> 
<dt><code>Fe</code></dt><dd><p>Iron, a numeric vector</p>
</dd> 
<dt><code>K</code></dt><dd><p>Potassium, a numeric vector</p>
</dd>
<dt><code>Mg</code></dt><dd><p>Magnesium, a numeric vector</p>
</dd> 
<dt><code>Mn</code></dt><dd><p>Manganese, a numeric vector</p>
</dd> 
<dt><code>P</code></dt><dd><p>Lead, a numeric vector</p>
</dd>
<dt><code>Zn</code></dt><dd><p>Zinc, a numeric vector</p>
</dd> 
</dl>



<h3>Details</h3>

<p>The <code><a href="rrcov.html#topic+OsloTransect">OsloTransect</a></code> contains 360 observations, with 9
observations per site. Only 7 chemical elements were retained from the 25
contained in the <code><a href="rrcov.html#topic+OsloTransect">OsloTransect</a></code> data, and these were all
log-transformed, following Todorov and Filzmoser (2009).
</p>
<p>Only complete cases on these variables were retained, and two lithological
types of low frequency were removed, leaving 332 observations.
</p>


<h3>Source</h3>

<p>Reimann, C., Arnoldussen, A., Boyd, R., Finne, T.E., Koller, F.,
Nordgulen, Oe., And Englmaier, P. (2007) Element contents in leaves of four
plant species (birch, mountain ash, fern and spruce) along anthropogenic and
geogenic concentration gradients, <em>The Science of the Total
Environment</em>, 377, 416-433.
</p>


<h3>References</h3>

<p>Todorov V. and Filzmoser P. (2009) Robust statistic for the
one-way MANOVA, submitted to the <em>Journal of Environmetrics</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Oslo)
table(Oslo$litho)

Oslo.mod &lt;- lm(cbind(Cu, K, Mg, Mn, P, Zn) ~ litho, data=Oslo)
car::Anova(Oslo.mod)

heplot(Oslo.mod, var=c("Cu", "Mn"))
pairs(Oslo.mod)

## Not run: 
if(require(candisc)) {
  Oslo.can &lt;- candisc(Oslo.mod)
  Oslo.can
  heplot(Oslo.can)
  if(requireNamespace("rgl")){
    heplot3d(Oslo.can, shade=TRUE, wire=FALSE, alpha=0.5, var.col="red")
  }
}

## End(Not run)


</code></pre>

<hr>
<h2 id='Overdose'>Overdose of Amitriptyline</h2><span id='topic+Overdose'></span>

<h3>Description</h3>

<p>Data on overdoses of the drug amitriptyline.
Amitriptyline is a drug prescribed by physicians as an antidepressant. However, there are also 
conjectured side effects that seem to be related to the use of the drug: irregular heart beat,
abnormal blood pressure and irregular waves on the electrocardiogram (ECG).
This dataset (originally from Rudorfer, 1982) gives data on 17 patients admitted to hospital after an overdose 
of amitriptyline.
The two response variables are: <code>TCAD</code> and <code>AMI</code>. The other variables are predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Overdose")
</code></pre>


<h3>Format</h3>

<p>A data frame with 17 observations on the following 7 variables.
</p>

<dl>
<dt><code>TCAD</code></dt><dd><p>total TCAD plasma level, a numeric vector</p>
</dd>
<dt><code>AMI</code></dt><dd><p>amount of amitriptyline present in the TCAD plasma level, a numeric vector</p>
</dd>
<dt><code>Gender</code></dt><dd><p>a factor with levels <code>Male</code> <code>Female</code></p>
</dd>
<dt><code>amount</code></dt><dd><p>amount of drug taken at time of overdose, a numeric vector</p>
</dd>
<dt><code>BP</code></dt><dd><p>diastolic blood pressure, a numeric vector</p>
</dd>
<dt><code>ECG_PR</code></dt><dd><p>ECG PR wave measurement, a numeric vector</p>
</dd>
<dt><code>ECG_QRS</code></dt><dd><p>ECG QRS wave measurement, a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Johnson &amp; Wichern (2005), <em>Applied Multivariate Statistical Analysis</em>,
Exercise 7.25, p. 426.
</p>


<h3>References</h3>

<p>Rudorfer,  M. V. Cardiovascular changes and plasma drug levels after amitriptyline overdose. (1982).
<em>J. Toxicology - Clinical Toxicology</em>. <b>19</b>(1),67-78. 
<a href="https://doi.org/10.3109/15563658208990367">doi:10.3109/15563658208990367</a>, PMID: 7154142.
</p>
<p>Clay Ford, &quot;Getting started with Multivariate Multiple Regression&quot;,
<a href="https://library.virginia.edu/data/articles/getting-started-with-multivariate-multiple-regression">https://library.virginia.edu/data/articles/getting-started-with-multivariate-multiple-regression</a>.
</p>
<p>ECG measurements:
</p>

<dl>
<dt>PR</dt><dd><p><a href="https://en.wikipedia.org/wiki/PR_interval">https://en.wikipedia.org/wiki/PR_interval</a></p>
</dd>
<dt>QRS</dt><dd><p><a href="https://en.wikipedia.org/wiki/QRS_complex">https://en.wikipedia.org/wiki/QRS_complex</a></p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(Overdose)
str(Overdose)
pairs(Overdose) 

over.mlm &lt;- lm(cbind(TCAD, AMI) ~ Gender + amount + BP + ECG_PR + ECG_QRS, data = Overdose)
coef(over.mlm)

# check for outliers
cqplot(over.mlm)

# HE plot shows that relations of responses to predictors are essentially one-dimensional
heplot(over.mlm)

# canonical correlation analysis 
if(require(candisc)) {
cancor(cbind(TCAD, AMI) ~ as.numeric(Gender) + amount + BP + ECG_PR + ECG_QRS, data = Overdose)
}

</code></pre>

<hr>
<h2 id='pairs.mlm'>Pairwise HE Plots</h2><span id='topic+pairs.mlm'></span>

<h3>Description</h3>

<p>The function (in the form of an <code>mlm</code> method for the generic
<code><a href="graphics.html#topic+pairs">pairs</a></code> function) constructs a &ldquo;matrix&rdquo; of pairwise
HE plots (see <a href="#topic+heplot">heplot</a>) for a multivariate linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mlm'
pairs(
  x,
  variables,
  var.labels,
  var.cex = 2,
  type = c("II", "III", "2", "3"),
  idata = NULL,
  idesign = NULL,
  icontrasts = NULL,
  imatrix = NULL,
  iterm = NULL,
  manova,
  offset.axes = 0.05,
  digits = getOption("digits") - 1,
  fill = FALSE,
  fill.alpha = 0.3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairs.mlm_+3A_x">x</code></td>
<td>
<p>an object of class <code>mlm</code>.</p>
</td></tr>
<tr><td><code id="pairs.mlm_+3A_variables">variables</code></td>
<td>
<p>indices or names of the three of more response variables to
be plotted; defaults to all of the responses.</p>
</td></tr>
<tr><td><code id="pairs.mlm_+3A_var.labels">var.labels</code></td>
<td>
<p>labels for the variables plotted in the diagonal panels;
defaults to names of the response variables.</p>
</td></tr>
<tr><td><code id="pairs.mlm_+3A_var.cex">var.cex</code></td>
<td>
<p>character expansion for the variable labels.</p>
</td></tr>
<tr><td><code id="pairs.mlm_+3A_type">type</code></td>
<td>
<p>type of sum-of-squares-and-products matrices to compute; one
of <code>"II"</code>, <code>"III"</code>, <code>"2"</code>, or <code>"3"</code>, where <code>"II"</code>
is the default (and <code>"2"</code> is a synonym).</p>
</td></tr>
<tr><td><code id="pairs.mlm_+3A_idata">idata</code></td>
<td>
<p>an optional data frame giving a factor or factors defining the
intra-subject model for multivariate repeated-measures data.  See Details of
<code><a href="car.html#topic+Anova">Anova</a></code> for an explanation of the intra-subject design and
for further explanation of the other arguments relating to intra-subject factors.</p>
</td></tr>
<tr><td><code id="pairs.mlm_+3A_idesign">idesign</code></td>
<td>
<p>a one-sided model formula using the &ldquo;data&rdquo; in idata and
specifying the intra-subject design for repeated measure models.</p>
</td></tr>
<tr><td><code id="pairs.mlm_+3A_icontrasts">icontrasts</code></td>
<td>
<p>names of contrast-generating functions to be applied by
default to factors and ordered factors, respectively, in the within-subject
&ldquo;data&rdquo;; the contrasts must produce an intra-subject model matrix in which
different terms are orthogonal. The default is c(&quot;contr.sum&quot;, &quot;contr.poly&quot;).</p>
</td></tr>
<tr><td><code id="pairs.mlm_+3A_imatrix">imatrix</code></td>
<td>
<p>In lieu of <code>idata</code> and <code>idesign</code>, you can specify
the intra-subject design matrix directly via <code>imatrix</code>, in the form of
list of named elements.  Each element gives the columns of the
within-subject model matrix for an intra-subject term to be tested, and must
have as many rows as there are responses; the columns of the within-subject
model matrix for <em>different</em> terms must be mutually orthogonal.</p>
</td></tr>
<tr><td><code id="pairs.mlm_+3A_iterm">iterm</code></td>
<td>
<p>For repeated measures designs, you must specify one
intra-subject term (a character string) to select the SSPE (E) matrix used
in the HE plot.  Hypothesis terms plotted include the <code>iterm</code> effect as
well as all interactions of <code>iterm</code> with <code>terms</code>.</p>
</td></tr>
<tr><td><code id="pairs.mlm_+3A_manova">manova</code></td>
<td>
<p>optional <code>Anova.mlm</code> object for the model; if absent a
MANOVA is computed. Specifying the argument can therefore save computation
in repeated calls.</p>
</td></tr>
<tr><td><code id="pairs.mlm_+3A_offset.axes">offset.axes</code></td>
<td>
<p>proportion to extend the axes in each direction; defaults to 0.05.</p>
</td></tr>
<tr><td><code id="pairs.mlm_+3A_digits">digits</code></td>
<td>
<p>number of significant digits in axis end-labels; taken from
the <code>"digits"</code> option.</p>
</td></tr>
<tr><td><code id="pairs.mlm_+3A_fill">fill</code></td>
<td>
<p>A logical vector indicating whether each ellipse should be
filled or not.  The first value is used for the error ellipse, the rest &mdash;
possibly recycled &mdash; for the hypothesis ellipses; a single fill value can
be given.  Defaults to FALSE for backward compatibility. See Details of
<code><a href="#topic+heplot">heplot</a></code></p>
</td></tr>
<tr><td><code id="pairs.mlm_+3A_fill.alpha">fill.alpha</code></td>
<td>
<p>Alpha transparency for filled ellipses, a numeric scalar
or vector of values within <code>[0,1]</code>, where 0 means fully transparent and
1 means fully opaque. Defaults to 0.3.</p>
</td></tr>
<tr><td><code id="pairs.mlm_+3A_...">...</code></td>
<td>
<p>arguments to pass down to <code>heplot</code>, which is used to draw
each panel of the display.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>References</h3>

<p>Friendly, M. (2006).  Data Ellipses, HE Plots and Reduced-Rank
Displays for Multivariate Linear Models: SAS Software and Examples
<em>Journal of Statistical Software</em>, 17(6), 1-42.
<a href="https://www.jstatsoft.org/v17/i06/">https://www.jstatsoft.org/v17/i06/</a>
</p>
<p>Friendly, M. (2007).  HE plots for Multivariate General Linear Models.
<em>Journal of Computational and Graphical Statistics</em>, 16(2) 421-444.
<a href="http://datavis.ca/papers/jcgs-heplots.pdf">http://datavis.ca/papers/jcgs-heplots.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+heplot">heplot</a></code>, <code><a href="#topic+heplot3d">heplot3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ANCOVA, assuming equal slopes
rohwer.mod &lt;- lm(cbind(SAT, PPVT, Raven) ~ SES + n + s + ns + na + ss, data=Rohwer)

# View all pairs, with ellipse for all 5 regressors
pairs(rohwer.mod, hypotheses=list("Regr" = c("n", "s", "ns", "na", "ss")))


</code></pre>

<hr>
<h2 id='Parenting'>Father Parenting Competence</h2><span id='topic+Parenting'></span>

<h3>Description</h3>

<p>The data, from an exercise given by Meyers et al. (2006) relates to 60
fathers assessed on three subscales of a Perceived Parenting Competence
Scale. The fathers were selected from three groups: (a) fathers of a child
with no disabilities; (b) fathers with a physically disabled child; (c)
fathers with a mentally disabled child.
</p>


<h3>Format</h3>

<p>A data frame with 60 observations on the following 4 variables.
</p>
 
<dl>
<dt><code>group</code></dt><dd><p>a factor with levels <code>Normal</code>
<code>Physical Disability</code> <code>Mental Disability</code></p>
</dd>
<dt><code>caring</code></dt><dd><p>caretaking responsibilities, a numeric vector</p>
</dd>
<dt><code>emotion</code></dt><dd><p>emotional support provided to the child, a numeric vector</p>
</dd> 
<dt><code>play</code></dt><dd><p>recreational time spent with the child, a numeric vector</p>
</dd> 
</dl>



<h3>Details</h3>

<p>The scores on the response variables are discrete.
</p>


<h3>Source</h3>

<p>Meyers, L. S., Gamst, G, &amp; Guarino, A. J. (2006). <em>Applied
Multivariate Research: Design and Interpretation</em>, Thousand Oaks, CA: Sage
Publications, <a href="https://study.sagepub.com/meyers3e">https://study.sagepub.com/meyers3e</a>, Exercises 10B.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Parenting)
require(car)

# fit the MLM
parenting.mod &lt;- lm(cbind(caring, emotion, play) ~ group, data=Parenting)
car::Anova(parenting.mod)

# Box's M test
boxM(parenting.mod)
plot(boxM(parenting.mod))

parenting.mod &lt;- lm(cbind(caring, emotion, play) ~ group, data=Parenting)
car::Anova(parenting.mod)
# test contrasts
print(linearHypothesis(parenting.mod, "group1"), SSP=FALSE)
print(linearHypothesis(parenting.mod, "group2"), SSP=FALSE)


heplot(parenting.mod)
# display tests of contrasts
hyp &lt;- list("N:MP" = "group1", "M:P" = "group2")
heplot(parenting.mod, hypotheses=hyp)

# make a prettier plot
heplot(parenting.mod, hypotheses=hyp, asp=1,
       fill=TRUE, fill.alpha=c(0.3,0.1), 
       col=c("red", "blue"), 
       lty=c(0,0,1,1), label.pos=c(1,1,3,2),
       cex=1.4, cex.lab=1.4, lwd=3)

pairs(parenting.mod, fill=TRUE, fill.alpha=c(0.3, 0.1))

## Not run: 
heplot3d(parenting.mod, wire=FALSE)

## End(Not run)



</code></pre>

<hr>
<h2 id='peng'>Size measurements for penguins near Palmer Station, Antarctica</h2><span id='topic+peng'></span>

<h3>Description</h3>

<p>Data originally from <a href="https://allisonhorst.github.io/palmerpenguins/"><code>palmerpenguins</code></a>. Includes
measurements for penguin species, island in Palmer Archipelago,
size (flipper length, body mass, bill dimensions), and sex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peng
</code></pre>


<h3>Format</h3>

<p>A tibble with 333 rows and 8 variables:
</p>

<dl>
<dt>species</dt><dd><p>a factor denoting penguin species (<code>"Adlie", "Chinstrap" or "Gentoo"</code>)</p>
</dd>
<dt>island</dt><dd><p>a factor denoting island in Palmer Archipelago, Antarctica (<code>"Biscoe", "Dream" or "Torgersen"</code>)</p>
</dd>
<dt>bill_length</dt><dd><p>a number denoting bill length (millimeters)</p>
</dd>
<dt>bill_depth</dt><dd><p>a number denoting bill depth (millimeters)</p>
</dd>
<dt>flipper_length</dt><dd><p>an integer denoting flipper length (millimeters)</p>
</dd>
<dt>body_mass</dt><dd><p>an integer denoting body mass (grams)</p>
</dd>
<dt>sex</dt><dd><p>a factor denoting penguin sex (<code>"f", "m"</code>)</p>
</dd>
<dt>year</dt><dd><p>an integer denoting the study year (2007, 2008, or 2009)</p>
</dd>
</dl>



<h3>Details</h3>

<p>In this version, variable names have been shortened (removing units) and observations with
missing data have been removed.
</p>


<h3>Source</h3>

<p>Adlie penguins: Palmer Station Antarctica LTER and K. Gorman. 2020. 
Structural size measurements and isotopic signatures of foraging among 
adult male and female Adlie penguins (Pygoscelis adeliae) nesting along 
the Palmer Archipelago near Palmer Station, 2007-2009 ver 5. Environmental 
Data Initiative <a href="https://doi.org/10.6073/pasta/98b16d7d563f265cb52372c8ca99e60f">doi:10.6073/pasta/98b16d7d563f265cb52372c8ca99e60f</a>
</p>
<p>Gentoo penguins: Palmer Station Antarctica LTER and K. Gorman. 2020. 
Structural size measurements and isotopic signatures of foraging among 
adult male and female Gentoo penguin (Pygoscelis papua) nesting along the 
Palmer Archipelago near Palmer Station, 2007-2009 ver 5. Environmental 
Data Initiative <a href="https://doi.org/10.6073/pasta/7fca67fb28d56ee2ffa3d9370ebda689">doi:10.6073/pasta/7fca67fb28d56ee2ffa3d9370ebda689</a>
</p>
<p>Chinstrap penguins: Palmer Station Antarctica LTER and K. Gorman. 
2020. Structural size measurements and isotopic signatures of foraging 
among adult male and female Chinstrap penguin (Pygoscelis antarcticus) 
nesting along the Palmer Archipelago near Palmer Station, 2007-2009 ver 6. 
Environmental Data Initiative <a href="https://doi.org/10.6073/pasta/c14dfcfada8ea13a17536e73eb6fbe9e">doi:10.6073/pasta/c14dfcfada8ea13a17536e73eb6fbe9e</a>
</p>
<p>Originally published in: Gorman K.B., Williams T.D., Fraser W.R. (2014) 
Ecological Sexual Dimorphism and Environmental Variability within a 
Community of Antarctic Penguins (Genus Pygoscelis). PLoS ONE 9(3): e90081. 
<a href="https://doi.org/10.1371/journal.pone.0090081">doi:10.1371/journal.pone.0090081</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(peng)
# Covariance ellipses, centered, first two variables
covEllipses(cbind(bill_length, bill_depth) ~ species, data=peng,
     center=TRUE, 
     fill=c(rep(FALSE,3), TRUE), 
     fill.alpha=.1, label.pos=c(1:3,0))

# All pairs when more than two variables are specified. They look pretty similar
covEllipses(peng[,3:6], peng$species, 
            variables=1:4, 
            fill=c(rep(FALSE,3), TRUE), 
            fill.alpha=.1)
            
# Box's M test 	
peng.boxm &lt;- boxM(cbind(bill_length, bill_depth, flipper_length, body_mass) ~ species, data=peng)
peng.boxm
plot(peng.boxm, gplabel="Species")

# Fit MANOVA model, predicting species 
peng.mod0 &lt;-lm(cbind(bill_length, bill_depth, flipper_length, body_mass) ~
               species, data=peng)
car::Anova(peng.mod0)

# HE plot
heplot(peng.mod0, fill=TRUE, fill.alpha=0.1, 
       size="effect",
       xlim=c(35,52), ylim=c(14,20))

</code></pre>

<hr>
<h2 id='Plastic'>Plastic Film Data</h2><span id='topic+Plastic'></span>

<h3>Description</h3>

<p>An experiment was conducted to determine the optimum conditions for
extruding plastic film.  Three responses were measured in relation to two
factors, rate of extrusion and amount of an additive.
</p>


<h3>Format</h3>

<p>A data frame with 20 observations on the following 5 variables.
</p>
 
<dl>
<dt><code>tear</code></dt><dd><p>a numeric vector: tear resistance</p>
</dd>
<dt><code>gloss</code></dt><dd><p>a numeric vector: film gloss</p>
</dd> 
<dt><code>opacity</code></dt><dd><p>a numeric vector: film opacity</p>
</dd> 
<dt><code>rate</code></dt><dd><p>a factor representing change in the rate of extrusion with levels <code>Low</code> (-10%), <code>High</code> (10%)</p>
</dd> 
<dt><code>additive</code></dt><dd><p>a factor with levels <code>Low</code> (1.0%), <code>High</code> (1.5%)</p>
</dd> 
</dl>



<h3>Source</h3>

<p>Johnson, R.A. &amp; Wichern, D.W. (1992). <em>Applied Multivariate
Statistical Analysis</em>, 3rd ed., Prentice-Hall. Example 6.12 (p. 266).
</p>


<h3>References</h3>

<p>Krzanowski, W. J. (1988). <em>Principles of Multivariate
Analysis. A User's Perspective</em>. Oxford.  (p. 381)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
str(Plastic)
plastic.mod &lt;- lm(cbind(tear, gloss, opacity) ~ rate*additive, data=Plastic)
car::Anova(plastic.mod)

pairs(plastic.mod)

</code></pre>

<hr>
<h2 id='plot.boxM'>Plot for Box's M test and generalizations</h2><span id='topic+plot.boxM'></span>

<h3>Description</h3>

<p>This function creates a simple dot chart showing the contributions (log
determinants) of the various groups to Box's M test for equality of
covariance matrices. An important virtue of these plots is that they can show
<em>how</em> the groups differ from each other, and from the pooled
covariance matrix using a scalar like <code class="reqn">ln | S |</code>. In this way, they
can suggest more specific questions or hypotheses regarding the
equality of covariance matrices, analogous to the use of contrasts
and linear hypotheses for testing differences among group mean vectors.
</p>
<p>Because Box's M test is based on a specific function (log determinant) of
the covariance matrices in the groups compared to the pooled covariance
matrix, this function also also allow plots of other measures based on the
eigenvalues of these covariance matrices.
</p>
<p>Confidence intervals are only available for the default Box M test, using
<code>which="logDet"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boxM'
plot(
  x,
  gplabel = NULL,
  which = c("logDet", "product", "sum", "precision", "max"),
  log = which == "product",
  pch = c(16, 15),
  cex = c(2, 2.5),
  col = c("blue", "red"),
  rev = FALSE,
  xlim,
  conf = 0.95,
  method = 1,
  bias.adj = TRUE,
  lwd = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.boxM_+3A_x">x</code></td>
<td>
<p>A <code>"boxM"</code> object resulting from <code><a href="#topic+boxM">boxM</a></code></p>
</td></tr>
<tr><td><code id="plot.boxM_+3A_gplabel">gplabel</code></td>
<td>
<p>character string used to label the group factor.</p>
</td></tr>
<tr><td><code id="plot.boxM_+3A_which">which</code></td>
<td>
<p>Measure to be plotted. The default, <code>"logDet"</code>, is the
standard plot.  Other values are: <code>"product"</code>, <code>"sum"</code>,
<code>"precision"</code> and <code>"max"</code></p>
</td></tr>
<tr><td><code id="plot.boxM_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, the log of the measure is plotted. The
default, <code>which=="product"</code>, produces a plot equivalent to the plot of
<code>"logDet"</code>.</p>
</td></tr>
<tr><td><code id="plot.boxM_+3A_pch">pch</code></td>
<td>
<p>a vector of two point symbols to use for the individual groups
and the pooled data, respectively</p>
</td></tr>
<tr><td><code id="plot.boxM_+3A_cex">cex</code></td>
<td>
<p>character size of point symbols, a vector of length two for
groups and pooled data, respectively</p>
</td></tr>
<tr><td><code id="plot.boxM_+3A_col">col</code></td>
<td>
<p>colors for point symbols, a vector of length two for the groups
and the pooled data</p>
</td></tr>
<tr><td><code id="plot.boxM_+3A_rev">rev</code></td>
<td>
<p>logical; if <code>TRUE</code>, the order of the groups is reversed on
the vertical axis.</p>
</td></tr>
<tr><td><code id="plot.boxM_+3A_xlim">xlim</code></td>
<td>
<p>x limits for the plot</p>
</td></tr>
<tr><td><code id="plot.boxM_+3A_conf">conf</code></td>
<td>
<p>coverage for approximate confidence intervals, <code>0 &lt;= conf &lt;
1</code> ; use <code>conf=0</code> to suppress these</p>
</td></tr>
<tr><td><code id="plot.boxM_+3A_method">method</code></td>
<td>
<p>confidence interval method; see <code><a href="#topic+logdetCI">logdetCI</a></code></p>
</td></tr>
<tr><td><code id="plot.boxM_+3A_bias.adj">bias.adj</code></td>
<td>
<p>confidence interval bias adjustment; see
<code><a href="#topic+logdetCI">logdetCI</a></code></p>
</td></tr>
<tr><td><code id="plot.boxM_+3A_lwd">lwd</code></td>
<td>
<p>line width for confidence interval</p>
</td></tr>
<tr><td><code id="plot.boxM_+3A_...">...</code></td>
<td>
<p>Arguments passed down to <code><a href="graphics.html#topic+dotchart">dotchart</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>References</h3>

<p>Friendly, M., &amp; Sigal, M. (2018). Visualizing Tests for Equality of Covariance Matrices. 
<em>The American Statistician</em>, <b>72</b>(4);
<a href="https://doi.org/10.1080/00031305.2018.1497537">doi:10.1080/00031305.2018.1497537</a>.
Online: <a href="https://www.datavis.ca/papers/EqCov-TAS.pdf">https://www.datavis.ca/papers/EqCov-TAS.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boxM">boxM</a></code>, <code><a href="#topic+logdetCI">logdetCI</a></code>
</p>
<p><code><a href="graphics.html#topic+dotchart">dotchart</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Iris data
res &lt;- boxM(iris[, 1:4], iris[, "Species"])
plot(res, gplabel="Species")

# Skulls data
skulls.mod &lt;- lm(cbind(mb, bh, bl, nh) ~ epoch, data=Skulls)
skulls.boxm &lt;- boxM(skulls.mod)
plot(skulls.boxm, gplabel="Epoch")
plot(skulls.boxm, gplabel="Epoch", bias.adj=FALSE)

# other measures
 plot(skulls.boxm, which="product", gplabel="Epoch", xlim=c(10,14))
 plot(skulls.boxm, which="sum", gplabel="Epoch")
 plot(skulls.boxm, which="precision", gplabel="Epoch")
 plot(skulls.boxm, which="max", gplabel="Epoch")



</code></pre>

<hr>
<h2 id='plot.robmlm'>Plot observation weights from a robust multivariate linear models</h2><span id='topic+plot.robmlm'></span>

<h3>Description</h3>

<p>Creates an index plot of the observation weights assigned in the last
iteration of <code><a href="#topic+robmlm">robmlm</a></code>.  Observations with low weights have large
residual squared distances and are potential multivariate outliers with
respect to the fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'robmlm'
plot(
  x,
  labels,
  id.weight = 0.7,
  id.pos = 4,
  pch = 19,
  col = palette()[1],
  cex = par("cex"),
  segments = FALSE,
  xlab = "Case index",
  ylab = "Weight in robust MANOVA",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.robmlm_+3A_x">x</code></td>
<td>
<p>A <code>"robmlm"</code> object</p>
</td></tr>
<tr><td><code id="plot.robmlm_+3A_labels">labels</code></td>
<td>
<p>Observation labels; if not specified, uses rownames from the
original data</p>
</td></tr>
<tr><td><code id="plot.robmlm_+3A_id.weight">id.weight</code></td>
<td>
<p>Threshold for identifying observations with small weights</p>
</td></tr>
<tr><td><code id="plot.robmlm_+3A_id.pos">id.pos</code></td>
<td>
<p>Position of observation label relative to the point</p>
</td></tr>
<tr><td><code id="plot.robmlm_+3A_pch">pch</code></td>
<td>
<p>Point symbol(s); can be a vector of length equal to the number of
observations in the data frame</p>
</td></tr>
<tr><td><code id="plot.robmlm_+3A_col">col</code></td>
<td>
<p>Point color(s)</p>
</td></tr>
<tr><td><code id="plot.robmlm_+3A_cex">cex</code></td>
<td>
<p>Point character size(s)</p>
</td></tr>
<tr><td><code id="plot.robmlm_+3A_segments">segments</code></td>
<td>
<p>logical; if <code>TRUE</code>, draw line segments from 1.o down to
the point</p>
</td></tr>
<tr><td><code id="plot.robmlm_+3A_xlab">xlab</code></td>
<td>
<p>x axis label</p>
</td></tr>
<tr><td><code id="plot.robmlm_+3A_ylab">ylab</code></td>
<td>
<p>y axis label</p>
</td></tr>
<tr><td><code id="plot.robmlm_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns invisibly the weights for the observations labeled in the
plot
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robmlm">robmlm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Skulls)
sk.rmod &lt;- robmlm(cbind(mb, bh, bl, nh) ~ epoch, data=Skulls)
plot(sk.rmod, col=Skulls$epoch)
axis(side=3, at=15+seq(0,120,30), labels=levels(Skulls$epoch), cex.axis=1)

# Pottery data

data(Pottery, package = "carData")
pottery.rmod &lt;- robmlm(cbind(Al,Fe,Mg,Ca,Na)~Site, data=Pottery)
plot(pottery.rmod, col=Pottery$Site, segments=TRUE)

# SocialCog data

data(SocialCog)
SC.rmod &lt;- robmlm(cbind( MgeEmotions, ToM, ExtBias, PersBias) ~ Dx,
               data=SocialCog)
plot(SC.rmod, col=SocialCog$Dx, segments=TRUE)



</code></pre>

<hr>
<h2 id='Pottery2'>Chemical Analysis of Romano-British Pottery</h2><span id='topic+Pottery2'></span>

<h3>Description</h3>

<p>Results of chemical analyses of 48 specimens of Romano-British pottery
published by Tubb et al. (1980).  The numbers are the percentage of various
metal oxides found in each sample for elements of concentrations greater
than 0.01%. This is the original data set from Tubb et al. (1980), in
contrast to <code><a href="carData.html#topic+Pottery">Pottery</a></code>.
</p>


<h3>Format</h3>

<p>A data frame with 48 observations on the following 12 variables.
</p>
 
<dl>
<dt><code>Region</code></dt><dd><p>a factor with levels <code>Gl</code> <code>NF</code>
<code>Wales</code></p>
</dd> 
<dt><code>Site</code></dt><dd><p>a factor with levels <code>AshleyRails</code>
<code>Caldicot</code> <code>Gloucester</code> <code>IsleThorns</code> <code>Llanedryn</code></p>
</dd>
<dt><code>Kiln</code></dt><dd><p>a factor with levels <code>1</code> <code>2</code> <code>3</code> <code>4</code>
<code>5</code></p>
</dd> 
<dt><code>Al</code></dt><dd><p>amount of aluminum oxide, <code class="reqn">Al_2O_3</code></p>
</dd>
<dt><code>Fe</code></dt><dd><p>amount of iron oxide, <code class="reqn">Fe_2O_3</code></p>
</dd>
<dt><code>Mg</code></dt><dd><p>amount of magnesium oxide, MgO</p>
</dd> 
<dt><code>Ca</code></dt><dd><p>amount of calcium oxide, CaO</p>
</dd> 
<dt><code>Na</code></dt><dd><p>amount of sodium oxide, <code class="reqn">Na_2O</code></p>
</dd> 
<dt><code>K</code></dt><dd><p>amount of potassium oxide, <code class="reqn">K_2O</code></p>
</dd>
<dt><code>Ti</code></dt><dd><p>amount of titanium oxide, <code class="reqn">TiO_2</code> </p>
</dd>
<dt><code>Mn</code></dt><dd><p>amount of manganese oxide, MnO</p>
</dd> 
<dt><code>Ba</code></dt><dd><p>amount of BaO</p>
</dd> 
</dl>



<h3>Details</h3>

<p>The specimens are identified by their <code>rownames</code> in the data frame.
<code>Kiln</code> indicates at which kiln site the pottery was found; <code>Site</code>
gives the location names of those sites. The kiln sites come from three
<code>Region</code>s, <code>("Gl"=1, "Wales"=(2, 3), "NF"=(4, 5))</code>, where the full
names are &quot;Gloucester&quot;, &quot;Wales&quot;, and &quot;New Forrest&quot;.
</p>
<p>The variable <code>Kiln</code> comes pre-supplied with contrasts to test
interesting hypotheses related to <code>Site</code> and <code>Region</code>.
</p>


<h3>Source</h3>

<p>Originally slightly modified from files by David Carlson, now at
<code><a href="archdata.html#topic+RBPottery">RBPottery</a></code>. 
</p>


<h3>References</h3>

<p>Baxter, M. J. 2003. <em>Statistics in Archaeology</em>. Arnold,
London.
</p>
<p>Carlson, David L. 2017. <em>Quantitative Methods in Archaeology Using R</em>.
Cambridge University Press, pp 247-255, 335-342.
</p>
<p>Tubb, A., A. J. Parker, and G. Nickless. 1980.  The Analysis of
Romano-British Pottery by Atomic Absorption Spectrophotometry.
<em>Archaeometry</em>, <b>22</b>, 153-171.
</p>


<h3>See Also</h3>

<p><code><a href="carData.html#topic+Pottery">Pottery</a></code> for the related (subset) data set;
<code><a href="archdata.html#topic+RBPottery">RBPottery</a></code> for a newer version with more variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(car)
data(Pottery2)
# contrasts for Kiln correspond to between Region [,1:2] and within Region [,3:4]
contrasts(Pottery2$Kiln)

pmod &lt;-lm(cbind(Al,Fe,Mg,Ca,Na,K,Ti,Mn,Ba)~Kiln, data=Pottery2)
car::Anova(pmod)

# extract coefficient names for linearHypotheses
coefs &lt;- rownames(coef(pmod))[-1]

# test differences among regions
linearHypothesis(pmod, coefs[1:2])
# test differences within regions B, C
linearHypothesis(pmod, coefs[3:4])

heplot(pmod, fill=c(TRUE,FALSE), hypotheses=list("Region" =coefs[1:2], "WithinBC"=coefs[3:4]))

# all pairwise views;  note that Ba shows no effect
pairs(pmod, fill=c(TRUE,FALSE))

# canonical view, via candisc::heplot

if (require(candisc)) {

# canonical analysis: how many dimensions?
(pcan &lt;- candisc(pmod))

heplot(pcan, scale=18, fill=c(TRUE,FALSE), var.col="darkgreen", var.lwd=2, var.cex=1.5)

## Not run: 
heplot3d(pcan, scale=8)

## End(Not run)
}


</code></pre>

<hr>
<h2 id='Probe'>Response Speed in a Probe Experiment</h2><span id='topic+Probe'></span><span id='topic+Probe1'></span><span id='topic+Probe2'></span>

<h3>Description</h3>

<p>Data from a probe experiment testing whether immediate memory for sentences
is influenced by the phrase structure of the sentence.  The data sets come
from Timm (1975), Ex. 3.14 and Ex. 3.16 (p.244)
</p>


<h3>Format</h3>

<p><code>Probe1</code>: A data frame with 11 observations on the following 5 variables.  
</p>
 
<dl>
<dt><code>p1</code></dt><dd><p>speed at position 1</p>
</dd>
<dt><code>p2</code></dt><dd><p>speed at position 2</p>
</dd> 
<dt><code>p3</code></dt><dd><p>speed at position 3</p>
</dd> 
<dt><code>p4</code></dt><dd><p>speed at position 4</p>
</dd> 
<dt><code>p5</code></dt><dd><p>speed at position 5</p>
</dd> 
</dl>

<p><code>Probe2</code>: A data frame with 20 observations on the following 6 variables.  
</p>
 
<dl>
<dt><code>stm</code></dt><dd><p>Short term memory capacity: a factor with levels <code>High</code> <code>Low</code></p>
</dd> 
<dt><code>p1</code></dt><dd><p>speed at position 1</p>
</dd> 
<dt><code>p2</code></dt><dd><p>speed at position 2</p>
</dd> 
<dt><code>p3</code></dt><dd><p>speed at position 3</p>
</dd> 
<dt><code>p4</code></dt><dd><p>speed at position 4</p>
</dd>
<dt><code>p5</code></dt><dd><p>speed at position 5</p>
</dd> 
</dl>



<h3>Details</h3>

<p>Procedure: Subjects listened to tape-recorded sentences.  Each sentence was
followed by a &quot;probe word&quot; from one of 5 positions within the sentence.  The
subject had to respond with the word which immediately followed the probe
word in the sentence.  The dependent measure is response speed =
k(1/reaction time).
</p>
<p>Sample sentence: 
</p>
<pre>
*       The tall man met the young girl who got the new hat.
Pos'ns:      1    2            3    4    5
Function:   ADJ1 SUBJ        ADJ2  OBJ  REL.PN
</pre>
<p>In <code>Probe2</code>, there are two groups of subjects, pre-selected on a test
of short term memory.
</p>
<p>These data sets (fictitious) are used as examples of single-sample and
two-sample profile analysis or simple repeated measure designs with
structured contrasts.
</p>


<h3>Source</h3>

<p>Timm, N. (1975) <em>Multivariate analysis, with applications in
education and psychology</em> Brooks/Cole.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Probe1)
boxplot(Probe1)

pmod1 &lt;- lm(cbind(p1,p2,p3,p4,p5) ~ 1, data=Probe1)
idata &lt;- data.frame(position=factor(1:5))

library(car)
(pmod1.aov &lt;- car::Anova(pmod1, idata=idata, idesign=~position))

# using default contrasts (p5 as reference level)
heplot(pmod1, manova=pmod1.aov, 
       iterm="position", 
       type="III", 
       idata=idata, idesign=~position)
pairs(pmod1, manova=pmod1.aov, 
       iterm="position", 
       type="III", 
       idata=idata, idesign=~position)

# contrasts for substantative hypotheses regarding
# sentence position effects
C &lt;- matrix(c(
	1, 1, -1, -1, 0,
	1, -1, 1, -1, 0,
	1, -1, -1, 1, 0,
	1, 1, 1, 1, -4), 5, 4)
rownames(C) &lt;- paste("p", 1:5, sep="")
colnames(C) &lt;- c("SubPred", "AdjNoun", "SPxAN", "RelPN")

contrasts(idata$position)&lt;- C
(pmod1.aov &lt;- car::Anova(pmod1, idata=idata, idesign=~position))

heplot(pmod1, manova=pmod1.aov, 
       iterm="position", type="III", idata=idata, idesign=~position)
pairs(pmod1, manova=pmod1.aov, 
       iterm="position", type="III", idata=idata, idesign=~position)


</code></pre>

<hr>
<h2 id='RatWeight'>Weight Gain in Rats Exposed to Thiouracil and Thyroxin</h2><span id='topic+RatWeight'></span>

<h3>Description</h3>

<p>The data are from a study of weight gain, where investigators randomly
assigned 30 rats to three treatment groups: treatment 1 was a control (no
additive); treatments 2 and 3 consisted of two different additives
(thiouracil and thyroxin respectively) to the rats drinking water. Weight
was measured at baseline (week 0) and at weeks 1, 2, 3, and 4. Due to an
accident at the beginning of the study, data on 3 rats from the thyroxin
group are unavailable.
</p>


<h3>Format</h3>

<p>A data frame with 27 observations on the following 6 variables.
</p>
 
<dl>
<dt><code>trt</code></dt><dd><p>a factor with levels <code>Control</code> <code>Thiouracil</code> <code>Thyroxin</code></p>
</dd> 
<dt><code>wt0</code></dt><dd><p>Weight at Week 0 (baseline weight)</p>
</dd> 
<dt><code>wt1</code></dt><dd><p>Weight at Week 1</p>
</dd>
<dt><code>wt2</code></dt><dd><p>Weight at Week 2</p>
</dd> 
<dt><code>wt3</code></dt><dd><p>Weight at Week 3</p>
</dd>
<dt><code>wt4</code></dt><dd><p>Weight at Week 4</p>
</dd> 
</dl>



<h3>Details</h3>

<p>The <code>trt</code> factor comes supplied with contrasts comparing <code>Control</code>
to each of <code>Thiouracil</code> and <code>Thyroxin</code>.
</p>


<h3>Source</h3>

<p>Originally from Box (1950), Table D (page 389), where the values for
weeks 1-4 were recorded as the gain in weight for that week.
</p>
<p>Fitzmaurice, G. M. and Laird, N. M. and Ware, J. H (2004). <em>Applied
Longitudinal Analysis</em>, New York, NY: Wiley-Interscience.
<a href="https://rdrr.io/rforge/ALA/">https://rdrr.io/rforge/ALA/</a>.
</p>


<h3>References</h3>

<p>Box, G.E.P. (1950). Problems in the analysis of growth and wear
curves.  <em>Biometrics</em>, 6, 362-389.
</p>
<p>Friendly, Michael (2010). HE Plots for Repeated Measures Designs.
<em>Journal of Statistical Software</em>, 37(4), 1-40. 
<a href="https://doi.org/10.18637/jss.v037.i04">doi:10.18637/jss.v037.i04</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(RatWeight)
contrasts(RatWeight$trt)

rat.mod &lt;- lm(cbind(wt0, wt1, wt2, wt3, wt4) ~ trt, data=RatWeight)
rat.mod

idata &lt;- data.frame(week = ordered(0:4))
car::Anova(rat.mod, idata=idata, idesign=~week, test="Roy")

# quick look at between group effects
pairs(rat.mod)

# between-S, baseline &amp; week 4
heplot(rat.mod, col=c("red", "blue", "green3", "green3"),
	variables=c(1,5),
	hypotheses=c("trt1", "trt2"),
	main="Rat weight data, Between-S effects") 

# within-S
heplot(rat.mod, idata=idata, idesign=~week, iterm="week",
	col=c("red", "blue", "green3"),
#	hypotheses=c("trt1", "trt2"),
	main="Rat weight data, Within-S effects")


</code></pre>

<hr>
<h2 id='ReactTime'>Reaction Time Data</h2><span id='topic+ReactTime'></span>

<h3>Description</h3>

<p>Data from Maxwell and Delaney (1990, p. 497) representing the reaction times
of 10 subjects in some task where visual stimuli are tilted at 0, 4, and 8
degrees; with noise absent or present.  Each subject responded to 3 tilt x 2
noise = 6 conditions.  The data thus comprise a repeated measure design with
two within-S factors.
</p>


<h3>Format</h3>

<p>A data frame with 10 observations giving the reaction time for the 6
conditions.  
</p>
 
<dl>
<dt><code>deg0NA</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>deg4NA</code></dt><dd><p>a numeric vector</p>
</dd> 
<dt><code>deg8NA</code></dt><dd><p>a numeric vector</p>
</dd> 
<dt><code>deg0NP</code></dt><dd><p>a numeric vector</p>
</dd> 
<dt><code>deg4NP</code></dt><dd><p>a numeric vector</p>
</dd> 
<dt><code>deg8NP</code></dt><dd><p>a numeric vector</p>
</dd> 
</dl>



<h3>Source</h3>

<p>Baron, J. and Li, Y. (2003).  <em>Notes on the use of R for
psychology experiments and questionnaires</em>,
<a href="https://cran.r-project.org/doc/contrib/Baron-rpsych.pdf">https://cran.r-project.org/doc/contrib/Baron-rpsych.pdf</a>
</p>


<h3>References</h3>

<p>Michael Friendly (2010). HE Plots for Repeated Measures Designs.
<em>Journal of Statistical Software</em>, 37(4), 1-40. 
<a href="https://doi.org/10.18637/jss.v037.i04">doi:10.18637/jss.v037.i04</a>.
</p>
<p>Maxwell, S. E. &amp; Delaney, H. D. (1990).  <em>Designing Experiments and
Analyzing Data: A model comparison perspective</em>. Pacific Grove, CA:
Brooks/Cole.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ReactTime)
(RT.mod &lt;- lm(as.matrix(ReactTime)~1))

# within-S factors
within &lt;- expand.grid(tilt=ordered(c(0,4,8)), noise=c("NA", "NP"))
car::Anova(RT.mod, idata=within, idesign=~tilt * noise)

heplot(RT.mod, idata=within, idesign=~tilt * noise, iterm="tilt")

# plotting means and std errors directly

levels &lt;- expand.grid(Tilt=c(0,4,8), noise=c("NA", "NP"))
(means.df &lt;- data.frame(levels, mean=colMeans(ReactTime), se=sqrt(diag(var(ReactTime)))/9))

with(means.df, {
	plot(Tilt, mean, type="n", main="Reaction Time data", xlab="Tilt", ylab="Reaction time")
	colors &lt;- rep(c("red", "blue"), each=3)
	pts &lt;- rep(c(15, 16), each=3)

	lines(Tilt[1:3], mean[1:3], col="red", lwd=2)
	lines(Tilt[4:6], mean[4:6], col="blue", lwd=2)
	points(Tilt, mean, pch=pts, col=colors, cex=1.2)
	arrows(Tilt, mean-se, Tilt, mean+se, angle=90, code=3, 
			col=colors, len=.05, lwd=2)
	# labels at last point, in lieu of legend
	text(Tilt[3], mean[3]-10, labels="NA", col="red", pos=1)
	text(Tilt[6], mean[6]-10, labels="NP", col="blue", pos=1)
	}
	)

</code></pre>

<hr>
<h2 id='robmlm'>Robust Fitting of Multivariate Linear Models</h2><span id='topic+robmlm'></span><span id='topic+print.robmlm'></span><span id='topic+print.summary.robmlm'></span><span id='topic+robmlm.default'></span><span id='topic+robmlm.formula'></span><span id='topic+summary.robmlm'></span>

<h3>Description</h3>

<p>Fit a multivariate linear model by robust regression using a simple M
estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robmlm(X, ...)

## Default S3 method:
robmlm(
  X,
  Y,
  w,
  P = 2 * pnorm(4.685, lower.tail = FALSE),
  tune,
  max.iter = 100,
  psi = psi.bisquare,
  tol = 1e-06,
  initialize,
  verbose = FALSE,
  ...
)

## S3 method for class 'formula'
robmlm(
  formula,
  data,
  subset,
  weights,
  na.action,
  model = TRUE,
  contrasts = NULL,
  ...
)

## S3 method for class 'robmlm'
print(x, ...)

## S3 method for class 'robmlm'
summary(object, ...)

## S3 method for class 'summary.robmlm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robmlm_+3A_x">X</code></td>
<td>
<p>for the default method, a model matrix, including the constant (if
present)</p>
</td></tr>
<tr><td><code id="robmlm_+3A_...">...</code></td>
<td>
<p>other arguments, passed down. In particular relevant control
arguments can be passed to the to the <code>robmlm.default</code> method.</p>
</td></tr>
<tr><td><code id="robmlm_+3A_y">Y</code></td>
<td>
<p>for the default method, a response matrix</p>
</td></tr>
<tr><td><code id="robmlm_+3A_w">w</code></td>
<td>
<p>prior weights</p>
</td></tr>
<tr><td><code id="robmlm_+3A_p">P</code></td>
<td>
<p>two-tail probability, to find cutoff quantile for chisq (tuning
constant); default is set for bisquare weight function</p>
</td></tr>
<tr><td><code id="robmlm_+3A_tune">tune</code></td>
<td>
<p>tuning constant (if given directly)</p>
</td></tr>
<tr><td><code id="robmlm_+3A_max.iter">max.iter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="robmlm_+3A_psi">psi</code></td>
<td>
<p>robustness weight function; <code><a href="MASS.html#topic+psi.bisquare">psi.bisquare</a></code> is
the default</p>
</td></tr>
<tr><td><code id="robmlm_+3A_tol">tol</code></td>
<td>
<p>convergence tolerance, maximum relative change in coefficients</p>
</td></tr>
<tr><td><code id="robmlm_+3A_initialize">initialize</code></td>
<td>
<p>modeling function to find start values for coefficients,
equation-by-equation; if absent WLS (<code>lm.wfit</code>) is used</p>
</td></tr>
<tr><td><code id="robmlm_+3A_verbose">verbose</code></td>
<td>
<p>show iteration history? (<code>TRUE</code> or <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="robmlm_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>cbind(y1, y2, ...) ~ x1 + x2 + ...</code>.</p>
</td></tr>
<tr><td><code id="robmlm_+3A_data">data</code></td>
<td>
<p>a data frame from which variables specified in <code>formula</code>
are preferentially to be taken.</p>
</td></tr>
<tr><td><code id="robmlm_+3A_subset">subset</code></td>
<td>
<p>An index vector specifying the cases to be used in fitting.</p>
</td></tr>
<tr><td><code id="robmlm_+3A_weights">weights</code></td>
<td>
<p>a vector of prior weights for each case.</p>
</td></tr>
<tr><td><code id="robmlm_+3A_na.action">na.action</code></td>
<td>
<p>A function to specify the action to be taken if <code>NA</code>s
are found.  The 'factory-fresh' default action in R is
<code><a href="stats.html#topic+na.omit">na.omit</a></code>, and can be changed by
<code><a href="base.html#topic+options">options</a></code><code>(na.action=)</code>.</p>
</td></tr>
<tr><td><code id="robmlm_+3A_model">model</code></td>
<td>
<p>should the model frame be returned in the object?</p>
</td></tr>
<tr><td><code id="robmlm_+3A_contrasts">contrasts</code></td>
<td>
<p>optional contrast specifications; see
<code><a href="stats.html#topic+lm">lm</a></code> for details.</p>
</td></tr>
<tr><td><code id="robmlm_+3A_x">x</code></td>
<td>
<p>a <code>robmlm</code> object</p>
</td></tr>
<tr><td><code id="robmlm_+3A_object">object</code></td>
<td>
<p>a <code>robmlm</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These S3 methods are designed to provide a specification of a class of
robust methods which extend <code>mlm</code>s, and are therefore compatible with
other <code>mlm</code> extensions, including <code><a href="car.html#topic+Anova">Anova</a></code> and
<code><a href="#topic+heplot">heplot</a></code>.
</p>
<p>Fitting is done by iterated re-weighted least squares (IWLS), using weights
based on the Mahalanobis squared distances of the current residuals from the
origin, and a scaling (covariance) matrix calculated by
<code><a href="MASS.html#topic+cov.trob">cov.trob</a></code>. The design of these methods were loosely
modeled on <code><a href="MASS.html#topic+rlm">rlm</a></code>.
</p>
<p>An internal <code>vcov.mlm</code> function is an extension of the standard
<code><a href="stats.html#topic+vcov">vcov</a></code> method providing for observation weights.
</p>


<h3>Value</h3>

<p>An object of class <code>"robmlm"</code> inheriting from <code>c("mlm",
"lm")</code>.
</p>
<p>This means that the returned <code>"robmlm"</code> contains all the components of
<code>"mlm"</code> objects described for <code><a href="stats.html#topic+lm">lm</a></code>, plus the
following: 
</p>

<dl>
<dt>weights </dt><dd><p>final observation weights</p>
</dd> 
<dt>iterations </dt><dd><p>number of iterations</p>
</dd> 
<dt>converged </dt><dd><p>logical: did the IWLS process converge?</p>
</dd>
</dl>

<p>The generic accessor functions <code><a href="stats.html#topic+coefficients">coefficients</a></code>,
<code><a href="stats.html#topic+effects">effects</a></code>, <code><a href="stats.html#topic+fitted.values">fitted.values</a></code> and
<code><a href="stats.html#topic+residuals">residuals</a></code> extract various useful features of the value
returned by <code>robmlm</code>.
</p>


<h3>Author(s)</h3>

<p>John Fox; packaged by Michael Friendly
</p>


<h3>References</h3>

<p>A. Marazzi (1993) <em>Algorithms, Routines and S Functions for
Robust Statistics</em>.  Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+rlm">rlm</a></code>, <code><a href="MASS.html#topic+cov.trob">cov.trob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##############
# Skulls data

# make shorter labels for epochs and nicer variable labels in heplots
Skulls$epoch &lt;- factor(Skulls$epoch, labels=sub("c","",levels(Skulls$epoch)))
# variable labels
vlab &lt;- c("maxBreadth", "basibHeight", "basialLength", "nasalHeight")

# fit manova model, classically and robustly
sk.mod &lt;- lm(cbind(mb, bh, bl, nh) ~ epoch, data=Skulls)
sk.rmod &lt;- robmlm(cbind(mb, bh, bl, nh) ~ epoch, data=Skulls)

# standard mlm methods apply here
coefficients(sk.rmod)

# index plot of weights
plot(sk.rmod$weights, type="h", xlab="Case Index", ylab="Robust mlm weight", col="gray")
points(sk.rmod$weights, pch=16, col=Skulls$epoch)
axis(side=1, at=15+seq(0,120,30), labels=levels(Skulls$epoch), tick=FALSE, cex.axis=1)

# heplots to see effect of robmlm vs. mlm
heplot(sk.mod, hypotheses=list(Lin="epoch.L", Quad="epoch.Q"), 
    xlab=vlab[1], ylab=vlab[2], cex=1.25, lty=1)
heplot(sk.rmod, hypotheses=list(Lin="epoch.L", Quad="epoch.Q"), 
    add=TRUE, error.ellipse=TRUE, lwd=c(2,2), lty=c(2,2), 
    term.labels=FALSE, hyp.labels=FALSE, err.label="")

##############
# Pottery data

data(Pottery, package = "carData")
pottery.mod &lt;- lm(cbind(Al,Fe,Mg,Ca,Na)~Site, data=Pottery)
pottery.rmod &lt;- robmlm(cbind(Al,Fe,Mg,Ca,Na)~Site, data=Pottery)
car::Anova(pottery.mod)
car::Anova(pottery.rmod)

# index plot of weights
plot(pottery.rmod$weights, type="h")
points(pottery.rmod$weights, pch=16, col=Pottery$Site)

# heplots to see effect of robmlm vs. mlm
heplot(pottery.mod, cex=1.3, lty=1)
heplot(pottery.rmod, add=TRUE, error.ellipse=TRUE, lwd=c(2,2), lty=c(2,2), 
    term.labels=FALSE, err.label="")

###############
# Prestige data
data(Prestige, package = "carData")

# treat women and prestige as response variables for this example
prestige.mod &lt;- lm(cbind(women, prestige) ~ income + education + type, data=Prestige)
prestige.rmod &lt;- robmlm(cbind(women, prestige) ~ income + education + type, data=Prestige)

coef(prestige.mod)
coef(prestige.rmod)
# how much do coefficients change?
round(coef(prestige.mod) - coef(prestige.rmod),3)

# pretty plot of case weights
plot(prestige.rmod$weights, type="h", xlab="Case Index", ylab="Robust mlm weight", col="gray")
points(prestige.rmod$weights, pch=16, col=Prestige$type)
legend(0, 0.7, levels(Prestige$type), pch=16, col=palette()[1:3], bg="white")

heplot(prestige.mod, cex=1.4, lty=1)
heplot(prestige.rmod, add=TRUE, error.ellipse=TRUE, lwd=c(2,2), lty=c(2,2), 
    term.labels=FALSE, err.label="")



</code></pre>

<hr>
<h2 id='Rohwer'>Rohwer Data Set</h2><span id='topic+Rohwer'></span>

<h3>Description</h3>

<p>Data from an experiment by William D. Rohwer on kindergarten children
designed to examine how well performance on a set of paired-associate (PA)
tasks can predict performance on some measures of aptitude and achievement.
</p>


<h3>Format</h3>

<p>A data frame with 69 observations on the following 10 variables.
</p>
 
<dl>
<dt><code>group</code></dt><dd><p>a numeric vector, corresponding to SES</p>
</dd>
<dt><code>SES</code></dt><dd><p>Socioeconomic status, a factor with levels <code>Hi</code> <code>Lo</code></p>
</dd> 
<dt><code>SAT</code></dt><dd><p>a numeric vector: score on a Student Achievement Test</p>
</dd> 
<dt><code>PPVT</code></dt><dd><p>a numeric vector: score on the Peabody Picture Vocabulary Test</p>
</dd> 
<dt><code>Raven</code></dt><dd><p>a numeric vector: score on the Raven Progressive Matrices Test</p>
</dd> 
<dt><code>n</code></dt><dd><p>a numeric vector: performance on a 'named' PA task</p>
</dd> 
<dt><code>s</code></dt><dd><p>a numeric vector: performance on a 'still' PA task</p>
</dd> 
<dt><code>ns</code></dt><dd><p>a numeric vector: performance on a 'named still' PA task</p>
</dd> 
<dt><code>na</code></dt><dd><p>a numeric vector: performance on a 'named action' PA task</p>
</dd> 
<dt><code>ss</code></dt><dd><p>a numeric vector: performance on a 'sentence still' PA task</p>
</dd> 
</dl>



<h3>Details</h3>

<p>The variables <code>SAT</code>, <code>PPVT</code> and <code>Raven</code> are responses to be
potentially explained by performance on the paired-associate (PA) learning
task<code>n</code>, <code>s</code>, <code>ns</code>, <code>na</code>, and <code>ss</code>.
</p>


<h3>Source</h3>

<p>Timm, N.H. 1975).  <em>Multivariate Analysis with Applications in
Education and Psychology</em>.  Wadsworth (Brooks/Cole), Examples 4.3 (p. 281),
4.7 (p. 313), 4.13 (p. 344).
</p>


<h3>References</h3>

<p>Friendly, M. (2007).  HE plots for Multivariate General Linear
Models.  <em>Journal of Computational and Graphical Statistics</em>,
<b>16</b>(2) 421&ndash;444.  <a href="http://datavis.ca/papers/jcgs-heplots.pdf">http://datavis.ca/papers/jcgs-heplots.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
str(Rohwer)

## ANCOVA, assuming equal slopes
rohwer.mod &lt;- lm(cbind(SAT, PPVT, Raven) ~ SES + n + s + ns + na + ss, data=Rohwer)
car::Anova(rohwer.mod)

# Visualize the ANCOVA model
heplot(rohwer.mod)
# Add ellipse to test all 5 regressors
heplot(rohwer.mod, hypotheses=list("Regr" = c("n", "s", "ns", "na", "ss")))
# View all pairs
pairs(rohwer.mod, hypotheses=list("Regr" = c("n", "s", "ns", "na", "ss")))

# or 3D plot
## Not run: 
col &lt;- c("red", "green3", "blue", "cyan", "magenta", "brown", "gray")
heplot3d(rohwer.mod, hypotheses=list("Regr" = c("n", "s", "ns", "na", "ss")), 
                     col=col, wire=FALSE)

## End(Not run)

## fit separate, independent models for Lo/Hi SES
rohwer.ses1 &lt;- lm(cbind(SAT, PPVT, Raven) ~ n + s + ns + na + ss, data=Rohwer, subset=SES=="Hi")
rohwer.ses2 &lt;- lm(cbind(SAT, PPVT, Raven) ~ n + s + ns + na + ss, data=Rohwer, subset=SES=="Lo")

# overlay the separate HE plots
heplot(rohwer.ses1, ylim=c(40,110),col=c("red", "black"))
heplot(rohwer.ses2, add=TRUE, col=c("blue", "black"), grand.mean=TRUE, error.ellipse=TRUE)


</code></pre>

<hr>
<h2 id='RootStock'>Growth of Apple Trees from Different Root Stocks</h2><span id='topic+RootStock'></span>

<h3>Description</h3>

<p>In a classic experiment carried out from 1918 to 1934, growth of apple trees
of six different rootstocks were compared on four measures of size.
How do the measures of size vary with the type of rootstock?
</p>


<h3>Format</h3>

<p>A data frame with 48 observations on the following 5 variables.
</p>
 
<dl>
<dt><code>rootstock</code></dt><dd><p>a factor with levels <code>1</code> <code>2</code> <code>3</code> <code>4</code> <code>5</code> <code>6</code></p>
</dd> 
<dt><code>girth4</code></dt><dd><p>a numeric vector: trunk girth at 4 years (mm x 100)</p>
</dd> 
<dt><code>ext4</code></dt><dd><p>a numeric vector: extension growth at 4 years (m)</p>
</dd> 
<dt><code>girth15</code></dt><dd><p>a numeric vector: trunk girth at 15 years (mm x 100)</p>
</dd> 
<dt><code>weight15</code></dt><dd><p>a numeric vector: weight of tree above ground at 15 years (lb x 1000)</p>
</dd> 
</dl>



<h3>Details</h3>

<p>This is a balanced, one-way MANOVA design, with n=8 trees for each
rootstock.
</p>


<h3>Source</h3>

<p>Andrews, D. and Herzberg, A. (1985). <em>Data: A Collection of
Problems from Many Fields for the Student and Research Worker</em>
Springer-Verlag, pp. 357&ndash;360.
</p>


<h3>References</h3>

<p>Rencher, A. C. (1995). <em>Methods of Multivariate Analysis</em>.
New York: Wiley, Table 6.2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(car)
data(RootStock)
str(RootStock)

root.mod &lt;- lm(cbind(girth4, ext4, girth15, weight15) ~ rootstock, data=RootStock)
car::Anova(root.mod)

pairs(root.mod)

# test two orthogonal contrasts among the rootstocks
hyp &lt;- matrix(c(2,-1,-1,-1,-1,2,  
                1, 0,0,0,0,-1), 2, 6, byrow=TRUE)
car::linearHypothesis(root.mod, hyp)
heplot(root.mod, hypotheses=list(Contrasts=hyp, C1=hyp[1,], C2=hyp[2,]))

heplot1d(root.mod, hypotheses=list(Contrasts=hyp, C1=hyp[1,], C2=hyp[2,]))


</code></pre>

<hr>
<h2 id='Sake'>Taste Ratings of Japanese Rice Wine (Sake)</h2><span id='topic+Sake'></span>

<h3>Description</h3>

<p>Siotani et al. (1985) describe a study of Japanese rice wine (sake) used to
investigate the relationship between two subjective ratings (<code>taste</code>
and <code>smell</code>) and a number of physical measurements on 30 brands of
sake.
</p>


<h3>Format</h3>

<p>A data frame with 30 observations on the following 10 variables.
</p>
 
<dl>
<dt><code>taste</code></dt><dd><p>mean taste rating</p>
</dd> 
<dt><code>smell</code></dt><dd><p>mean smell rating</p>
</dd> 
<dt><code>pH</code></dt><dd><p>pH measurement</p>
</dd> 
<dt><code>acidity1</code></dt><dd><p>one measure of acidity</p>
</dd> 
<dt><code>acidity2</code></dt><dd><p>another measure of acidity</p>
</dd>
<dt><code>sake</code></dt><dd><p>Sake-meter score</p>
</dd> 
<dt><code>rsugar</code></dt><dd><p>direct reducing sugar content</p>
</dd> 
<dt><code>tsugar</code></dt><dd><p>total sugar content</p>
</dd>
<dt><code>alcohol</code></dt><dd><p>alcohol content</p>
</dd>
<dt><code>nitrogen</code></dt><dd><p>formol-nitrogen content</p>
</dd> 
</dl>



<h3>Details</h3>

<p>These data provide one example of a case where a multivariate regression
doesn't benefit from having multiple outcome measures, using the standard
tests.  Barrett (2003) uses this data to illustrate influence measures for
multivariate regression models.
</p>
<p>The <code>taste</code> and <code>smell</code> values are the mean ratings of 10 experts
on some unknown scale.
</p>


<h3>Source</h3>

<p>Siotani, M. Hayakawa, T. &amp; Fujikoshi, Y. (1985). <em>Modern
Multivariate Statistical Analysis: A Graduate Course and Handbook</em>. American
Sciences Press, p. 217.
</p>


<h3>References</h3>

<p>Barrett, B. E. (2003). Understanding Influence in Multivariate
Regression. <em>Communications in Statistics - Theory and Methods</em> 32 (3),
667-680.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Sake)
# quick look at the data
boxplot(scale(Sake))

Sake.mod &lt;- lm(cbind(taste,smell) ~ ., data=Sake)

library(car)
car::Anova(Sake.mod)

predictors &lt;- colnames(Sake)[-(1:2)]                 
# overall multivariate regression test
linearHypothesis(Sake.mod, predictors)

heplot(Sake.mod, hypotheses=list("Regr" = predictors))

</code></pre>

<hr>
<h2 id='schooldata'>School Data</h2><span id='topic+schooldata'></span>

<h3>Description</h3>

<p>School Data, from Charnes et al. (1981). The aim is to explain scores on 3
different tests, <code>reading</code>, <code>mathematics</code> and <code>selfesteem</code>
from 70 school sites by means of 5 explanatory variables related to parents
and teachers.
</p>


<h3>Format</h3>

<p>A data frame with 70 observations on the following 8 variables.
</p>
 
<dl>
<dt><code>education</code></dt><dd><p>Education level of mother as measured in
terms of percentage of high school graduates among female parents</p>
</dd>
<dt><code>occupation</code></dt><dd><p> Highest occupation of a family member according
to a pre-arranged rating scale</p>
</dd> 
<dt><code>visit</code></dt><dd><p> Parental visits index
representing the number of visits to the school site</p>
</dd>
<dt><code>counseling</code></dt><dd><p> Parent counseling index calculated from data on
time spent with child on school-related topics such as reading together, etc.</p>
</dd> 
<dt><code>teacher</code></dt><dd><p> Number of teachers at a given site</p>
</dd>
<dt><code>reading</code></dt><dd><p> Reading score as measured by the Metropolitan Achievement Test</p>
</dd> 
<dt><code>mathematics</code></dt><dd><p>Mathematics score as measured by the Metropolitan Achievement Test</p>
</dd> 
<dt><code>selfesteem</code></dt><dd><p>Coopersmith Self-Esteem Inventory, intended as a measure of self-esteem</p>
</dd> 
</dl>



<h3>Details</h3>

<p>This dataset was shamelessly borrowed from the <code>FRB</code> package.
</p>
<p>The relationships among these variables are unusual, a fact only revealed by
plotting.
</p>


<h3>Source</h3>

<p>A. Charnes, W.W. Cooper and E. Rhodes (1981). Evaluating Program and
Managerial Efficiency: An Application of Data Envelopment Analysis to
Program Follow Through. <em>Management Science</em>, <b>27</b>, 668-697.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(schooldata)
# initial screening
plot(schooldata)

# better plot
library(corrgram)
corrgram(schooldata, 
         lower.panel=panel.ellipse, 
         upper.panel=panel.pts)

#fit the MMreg model
school.mod &lt;- lm(cbind(reading, mathematics, selfesteem) ~ 
		             education + occupation + visit + counseling + teacher, data=schooldata)

# shorthand: fit all others
school.mod &lt;- lm(cbind(reading, mathematics, selfesteem) ~ ., data=schooldata)
car::Anova(school.mod)

# HE plots
heplot(school.mod, fill=TRUE, fill.alpha=0.1)
pairs(school.mod, fill=TRUE, fill.alpha=0.1)

# robust model, using robmlm()
school.rmod &lt;- robmlm(cbind(reading, mathematics, selfesteem) ~ ., data=schooldata)
# note that counseling is now significant
car::Anova(school.rmod)

# Index plot of the weights
wts &lt;- school.rmod$weights
notable &lt;- which(wts &lt; 0.8)
plot(wts, type = "h", col="gray", ylab = "Observation weight")
points(1:length(wts), wts, 
       pch=16,
       col = ifelse(wts &lt; 0.8, "red", "black"))

text(notable, wts[notable],
     labels = notable,
     pos = 3,
     col = "red")



# compare classical HE plot with that based on the robust model
heplot(school.mod, cex=1.4, lty=1, fill=TRUE, fill.alpha=0.1)
heplot(school.rmod, 
       add=TRUE, 
       error.ellipse=TRUE, 
       lwd=c(2,2), lty=c(2,2), 
	     term.labels=FALSE, err.label="", 
	     fill=TRUE)


</code></pre>

<hr>
<h2 id='Skulls'>Egyptian Skulls</h2><span id='topic+Skulls'></span>

<h3>Description</h3>

<p>Measurements made on Egyptian skulls from five epochs.
</p>


<h3>Format</h3>

<p>A data frame with 150 observations on the following 5 variables.
</p>
 
<dl>
<dt><code>epoch</code></dt><dd><p>the epoch the skull as assigned to, an
ordered factor with levels <code>c4000BC</code> <code>c3300BC</code>, <code>c1850BC</code>,
<code>c200BC</code>, and <code>cAD150</code>, where the years are only given approximately, of course.</p>
</dd> 
<dt><code>mb</code></dt><dd><p>maximal breadth of the skull.</p>
</dd>
<dt><code>bh</code></dt><dd><p>basibregmatic height of the skull.</p>
</dd>
<dt><code>bl</code></dt><dd><p>basialiveolar length of the skull.</p>
</dd>
<dt><code>nh</code></dt><dd><p>nasal height of the skull.</p>
</dd> 
</dl>



<h3>Details</h3>

<p>The epochs correspond to the following periods of Egyptian history:
</p>
 
<ol>
<li><p> the early predynastic period (circa 4000 BC); 
</p>
</li>
<li><p> the late predynastic period (circa 3300 BC); 
</p>
</li>
<li><p> the 12th and 13th dynasties (circa 1850 BC); 
</p>
</li>
<li><p> the Ptolemiac period (circa 200 BC); 
</p>
</li>
<li><p> the Roman period (circa 150 AD). 
</p>
</li></ol>

<p>The question is whether the measurements change over time.  Non-constant
measurements of the skulls over time would indicate interbreeding with
immigrant populations.
</p>
<p>Note that using polynomial contrasts for <code>epoch</code> essentially treats the
time points as equally spaced.
</p>


<h3>Source</h3>

<p>D. J. Hand, F. Daly, A. D. Lunn, K. J. McConway and E. Ostrowski (1994).
<em>A Handbook of Small Datasets</em>, Chapman and Hall/CRC, London.
</p>


<h3>References</h3>

<p>Thomson, A. and Randall-Maciver, R. (1905) <em>Ancient Races
of the Thebaid</em>, Oxford: Oxford University Press.
</p>
<p>Hand, D. J., F. Daly, A. D. Lunn, K. J. McConway and E. Ostrowski (1994).
<em>A Handbook of Small Datasets</em>, Chapman and Hall/CRC, London.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Skulls)
library(car)    # for Anova

# make shorter labels for epochs
Skulls$epoch &lt;- factor(Skulls$epoch, labels=sub("c","",levels(Skulls$epoch)))

# longer variable labels
vlab &lt;- c("maxBreadth", "basibHeight", "basialLength", "nasalHeight")

# fit manova model
sk.mod &lt;- lm(cbind(mb, bh, bl, nh) ~ epoch, data=Skulls)

Anova(sk.mod)
summary(Anova(sk.mod))

# test trends over epochs
print(linearHypothesis(sk.mod, "epoch.L"), SSP=FALSE) # linear component
print(linearHypothesis(sk.mod, "epoch.Q"), SSP=FALSE) # quadratic component

# typical scatterplots are not very informative
scatterplot(mb ~ bh|epoch, data=Skulls, 
            ellipse = list(levels=0.68), 
            smooth=FALSE, 
            legend = list(coords="topright"),
            xlab=vlab[2], ylab=vlab[1])

scatterplot(mb ~ bl|epoch, data=Skulls, 
            ellipse = list(levels=0.68), 
            smooth=FALSE, 
            legend = list(coords="topright"),
            xlab=vlab[3], ylab=vlab[1])

# HE plots

heplot(sk.mod, 
       hypotheses=list(Lin="epoch.L", Quad="epoch.Q"), 
       xlab=vlab[1], ylab=vlab[2])

pairs(sk.mod, 
      hypotheses=list(Lin="epoch.L", Quad="epoch.Q"), 
      var.labels=vlab)

# 3D plot shows that nearly all of hypothesis variation is linear!
## Not run: 
heplot3d(sk.mod, hypotheses=list(Lin="epoch.L", Quad="epoch.Q"), col=c("pink", "blue"))

# view in canonical space
if (require(candisc)) {
	sk.can &lt;- candisc(sk.mod)
	sk.can
	heplot(sk.can)
	heplot3d(sk.can)
}

## End(Not run)


</code></pre>

<hr>
<h2 id='SocGrades'>Grades in a Sociology Course</h2><span id='topic+SocGrades'></span>

<h3>Description</h3>

<p>The data set <code>SocGrades</code> contains four outcome measures on student
performance in an introductory sociology course together with six potential
predictors. These data were used by Marascuilo and Levin (1983) for an
example of canonical correlation analysis, but are also suitable as examples
of multivariate multiple regression, MANOVA, MANCOVA and step-down analysis
in multivariate linear models.
</p>


<h3>Format</h3>

<p>A data frame with 40 observations on the following 10 variables.
</p>
 
<dl>
<dt><code>class</code></dt><dd><p>Social class, an ordered factor with levels
<code>1</code> &gt; <code>2</code> &gt; <code>3</code></p>
</dd> 
<dt><code>sex</code></dt><dd><p>sex, a factor with levels <code>F</code> <code>M</code></p>
</dd> 
<dt><code>gpa</code></dt><dd><p>grade point average</p>
</dd>
<dt><code>boards</code></dt><dd><p>College Board test scores</p>
</dd>
<dt><code>hssoc</code></dt><dd><p>previous high school unit in sociology, a factor with 2 <code>no</code>, <code>yes</code></p>
</dd> 
<dt><code>pretest</code></dt><dd><p>score on course pretest</p>
</dd>
<dt><code>midterm1</code></dt><dd><p>score on first midterm exam</p>
</dd>
<dt><code>midterm2</code></dt><dd><p>score on second midterm exam</p>
</dd>
<dt><code>final</code></dt><dd><p>score on final exam</p>
</dd> 
<dt><code>eval</code></dt><dd><p>course evaluation</p>
</dd> </dl>



<h3>Details</h3>

<p><code>midterm1</code>, <code>midterm2</code>, <code>final</code>, and possibly <code>eval</code> are
the response variables. All other variables are potential predictors.
</p>
<p>The factors <code>class</code>, <code>sex</code>, and <code>hssoc</code> can be used with
<code>as.numeric</code> in correlational analyses.
</p>


<h3>Source</h3>

<p>Marascuilo, L. A. and Levin, J. R. (1983). <em>Multivariate
Statistics in the Social Sciences</em> Monterey, CA: Brooks/Cole, Table 5-1, p.
192.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(SocGrades)
# basic MLM
grades.mod &lt;- lm(cbind(midterm1, midterm2, final, eval) ~ 
	class + sex + gpa + boards + hssoc + pretest, data=SocGrades)
	
car::Anova(grades.mod, test="Roy")

clr &lt;- c("red", "blue", "darkgreen", "magenta", "brown", "black", "darkgray")
heplot(grades.mod, col=clr)
pairs(grades.mod, col=clr)

## Not run: 
heplot3d(grades.mod, col=clr, wire=FALSE)

## End(Not run)

if (require(candisc)) {
	# calculate canonical results for all terms
	grades.can &lt;- candiscList(grades.mod)
	# extract canonical R^2s
	unlist(lapply(grades.can, function(x) x$canrsq))
	# plot class effect in canonical space
	heplot(grades.can, term="class", scale=4)	

	# 1 df terms: show canonical scores and weights for responses
	plot(grades.can, term="sex")
	plot(grades.can, term="gpa")
	plot(grades.can, term="boards")
	}


</code></pre>

<hr>
<h2 id='SocialCog'>Social Cognitive Measures in Psychiatric Groups</h2><span id='topic+SocialCog'></span>

<h3>Description</h3>

<p>The general purpose of the study (Hartman, 2016, Heinrichs et al. (2015))
was to evaluate patterns and levels of performance on neurocognitive
measures among individuals with schizophrenia and schizoaffective disorder
using a well-validated, comprehensive neurocognitive battery specifically
designed for individuals with psychosis (Heinrichs et al. (2008))
</p>


<h3>Format</h3>

<p>A data frame with 139 observations on the following 5 variables.
</p>
 
<dl>
<dt><code>Dx</code></dt><dd><p>Diagnostic group, a factor with levels
<code>Schizophrenia</code>, <code>Schizoaffective</code>, <code>Control</code></p>
</dd>
<dt><code>MgeEmotions</code></dt><dd><p>Score on the Managing emotions test, a numeric vector</p>
</dd> 
<dt><code>ToM</code></dt><dd><p>Score on the The Reading the Mind in the Eyes test (theory of mind), a numeric vector</p>
</dd>
<dt><code>ExtBias</code></dt><dd><p>Externalizing Bias score, a numeric vector</p>
</dd>
<dt><code>PersBias</code></dt><dd><p>Personal Bias score, a numeric vector</p>
</dd> 
</dl>



<h3>Details</h3>

<p>The data here are for a subset of the observations in <code><a href="#topic+NeuroCog">NeuroCog</a></code>
for which measures on various scales of social cognition were also
available. Interest here is on whether the schizophrenia group can be
distinguished from the schizoaffective group on these measures.
</p>
<p>The Social Cognitive measures were designed to tap various aspects of the
perception and cognitive procession of emotions of others.  Emotion
perception was assessed using a Managing Emotions (<code>MgeEmotions</code>) score
from the MCCB.  A &quot;theory of mind&quot; (<code>ToM</code>) score assessed ability to
read the emotions of others from photographs of the eye region of male and
female faces. Two other measures, externalizing bias (<code>ExtBias</code>) and
personalizing bias (<code>PersBias</code>) were calculated from a scale measuring
the degree to which individuals attribute internal, personal or situational
causal attributions to positive and negative social events.
</p>
<p>See <code><a href="#topic+NeuroCog">NeuroCog</a></code> for a description of the sample. Only those with
complete data on all the social cognitive measures are included in this data
set.
</p>
<p>There is one extreme outlier in the schizophrenia group and other possible
outliers in the control group, left in here for tutorial purposes.
</p>


<h3>Source</h3>

<p>Hartman, L. I. (2016). Schizophrenia and Schizoaffective Disorder:
One Condition or Two? Unpublished PhD dissertation, York University.
</p>
<p>Heinrichs, R.W., Pinnock, F., Muharib, E., Hartman, L.I., Goldberg, J.O., &amp;
McDermid Vaz, S. (2015).  Neurocognitive normality in schizophrenia
revisited.  <em>Schizophrenia Research: Cognition</em>, <b>2</b> (4), 227-232.
doi: 10.1016/j.scog.2015.09.001
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(car)
data(SocialCog)
SC.mod &lt;- lm(cbind(MgeEmotions, ToM, ExtBias, PersBias) ~ Dx, data=SocialCog)
SC.mod
car::Anova(SC.mod)

# test hypotheses of interest in terms of contrasts
print(linearHypothesis(SC.mod, "Dx1"), SSP=FALSE)
print(linearHypothesis(SC.mod, "Dx2"), SSP=FALSE)

#' ## HE plots

heplot(SC.mod, hypotheses=list("Dx1"="Dx1", "Dx2"="Dx2"),
	fill=TRUE, fill.alpha=.1)
	
pairs(SC.mod, fill=c(TRUE,FALSE), fill.alpha=.1) 


</code></pre>

<hr>
<h2 id='statList'>Calculate statistics for levels of factors</h2><span id='topic+statList'></span><span id='topic+covList'></span><span id='topic+colMeansList'></span>

<h3>Description</h3>

<p><code>statList</code> provides a general method for calculating univariate or
multivariate statistics for a matrix or data.frame stratified by one or more
factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statList(X, factors, FUN, drop = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="statList_+3A_x">X</code></td>
<td>
<p>A matrix or data frame containing the variables to be summarized</p>
</td></tr>
<tr><td><code id="statList_+3A_factors">factors</code></td>
<td>
<p>A vector, matrix or data frame containing the factors for
which <code>X</code> is to be summarized.  If <code>factors</code> is not specified,  
the result is calculated for all of the data in <code>X</code>.</p>
</td></tr>
<tr><td><code id="statList_+3A_fun">FUN</code></td>
<td>
<p>A function to be applied to the pieces of <code>X</code>, as split by <code>factors</code>.</p>
</td></tr>
<tr><td><code id="statList_+3A_drop">drop</code></td>
<td>
<p>Logical, indicating whether empty levels of <code>factors</code> are
to be dropped from the result.</p>
</td></tr>
<tr><td><code id="statList_+3A_...">...</code></td>
<td>
<p>Other arguments, passed to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>statList</code> is the general function. <code>X</code> is first <code>split</code> by
<code>factors</code>, and <code>FUN</code> is applied to the result.
</p>
<p><code>colMeansList</code> and <code>covList</code> are just calls to <code>statList</code>
with the appropriate <code>FUN</code>.
</p>


<h3>Value</h3>

<p>Returns a list of items corresponding to the unique elements in
<code>factors</code>, or the interaction of <code>factors</code>. Each item is the
result of applying <code>FUN</code> to that collection of rows of <code>X</code>. The
items are named according to the levels in <code>factors</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+colMeans">colMeans</a></code>, <code><a href="#topic+termMeans">termMeans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# grand means
statList(iris[,1:4], FUN=colMeans)
# species means
statList(iris[,1:4], iris$Species, FUN=colMeans)
# same
colMeansList(iris[,1:4], iris$Species)

# var-cov matrices, by species
covList(iris[,1:4], iris$Species)

# multiple factors
iris$Dummy &lt;- sample(c("Hi","Lo"),150, replace=TRUE)
colMeansList(iris[,1:4], iris[,5:6])



</code></pre>

<hr>
<h2 id='termMeans'>Calculate Means for a Term in a Multivariate Linear Model</h2><span id='topic+termMeans'></span>

<h3>Description</h3>

<p><code>termMeans</code> is a utility function designed to calculate means for the
levels of factor(s) for any term in a multivariate linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>termMeans(mod, term, label.factors = FALSE, abbrev.levels = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="termMeans_+3A_mod">mod</code></td>
<td>
<p>An mlm model object</p>
</td></tr>
<tr><td><code id="termMeans_+3A_term">term</code></td>
<td>
<p>A character string indicating a given term in the model. All
factors in the term must be included in the model, even if they are in the
model data frame.</p>
</td></tr>
<tr><td><code id="termMeans_+3A_label.factors">label.factors</code></td>
<td>
<p>If true, the rownames for each row in the result
include the name(s) of the factor(s) involved, followed by the 
level values. Otherwise, the rownames include only the levels of 
the factor(s), with multiple factors separated by ':'</p>
</td></tr>
<tr><td><code id="termMeans_+3A_abbrev.levels">abbrev.levels</code></td>
<td>
<p>Either a logical or an integer, specifying whether the
levels values of the factors in the <code>term</code> are to be abbreviated in
constructing the rownames.  An integer specifies the minimum length of the
abbreviation for each factor in the term.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix whose columns correspond to the response variables
in the model and whose rows correspond to the levels of the factor(s) in the
<code>term</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+aggregate">aggregate</a></code>, <code><a href="base.html#topic+colMeans">colMeans</a></code>
</p>
<p><code><a href="#topic+statList">statList</a></code>, <code><a href="#topic+colMeansList">colMeansList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
factors &lt;- expand.grid(A=factor(1:3),B=factor(1:2),C=factor(1:2))
n &lt;- nrow(factors)
responses &lt;-data.frame(Y1=10+round(10*rnorm(n)),Y2=10+round(10*rnorm(n)))
test &lt;- data.frame(factors, responses)
mod &lt;- lm(cbind(Y1,Y2) ~ A*B, data=test)

termMeans(mod, "A")
termMeans(mod, "A:B")
termMeans(mod, "A:B", label.factors=TRUE)
## Not run: 
termMeans(mod, "A:B:C")    # generates an error

## End(Not run)

plastic.mod &lt;- lm(cbind(tear, gloss, opacity) ~ rate*additive, data=Plastic)
colors = c("red", "darkblue", "darkgreen", "brown")
heplot(plastic.mod, col=colors, cex=1.25)
# add means for interaction term
intMeans &lt;- termMeans(plastic.mod, 'rate:additive', abbrev=2)
points(intMeans[,1], intMeans[,2], pch=18, cex=1.2, col="brown")
text(intMeans[,1], intMeans[,2], rownames(intMeans), adj=c(0.5,1), col="brown")



</code></pre>

<hr>
<h2 id='TIPI'>Data on the Ten Item Personality Inventory</h2><span id='topic+TIPI'></span>

<h3>Description</h3>

<p>The Ten Item Personality Inventory (Gosling et al. 2003) is a brief
inventory of the Big Five personality domains (Extraversion, Neuroticism,
Conscientiousness, Agreeableness, and Openness to experience). This dataset,
originally from the Open Source Psychometrics Project
(https://openpsychometrics.org/), was used by Jones et al. (2020), from
which we obtained this version.
</p>


<h3>Format</h3>

<p>A data frame with 1799 observations on the following 16 variables.
</p>
 
<dl>
<dt><code>Extraversion</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Neuroticism</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Conscientiousness</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Agreeableness</code></dt><dd><p>a numeric vector</p>
</dd> 
<dt><code>Openness</code></dt><dd><p>a numeric vector</p>
</dd> 
<dt><code>education</code></dt><dd><p>an ordered factor with levels
<code>&lt;HS</code> &lt; <code>HS</code> &lt; <code>Univ</code> &lt; <code>Grad</code></p>
</dd> 
<dt><code>urban</code></dt><dd><p>an ordered factor with levels <code>Rural</code> &lt; <code>Suburban</code> &lt; <code>Urban</code></p>
</dd>
<dt><code>gender</code></dt><dd><p>a factor with levels <code>M</code> <code>F</code></p>
</dd>
<dt><code>engnat</code></dt><dd><p>a factor with levels <code>Native</code> <code>Non-native</code></p>
</dd>
<dt><code>age</code></dt><dd><p>a numeric vector</p>
</dd> 
<dt><code>religion</code></dt><dd><p>a factor with levels <code>Agnostic</code> <code>Atheist</code> <code>Buddhist</code> <code>Christian
      (Catholic)</code> <code>Christian (Mormon)</code> <code>Christian (Protestant)</code>
<code>Christian (Other)</code> <code>Hindu</code> <code>Jewish</code> <code>Muslim</code>
<code>Sikh</code> <code>Other</code></p>
</dd> 
<dt><code>orientation</code></dt><dd><p>a factor with levels <code>Heterosexual</code> <code>Bisexual</code> <code>Homosexual</code> 
<code>Asexual</code> <code>Other</code></p>
</dd> 
<dt><code>race</code></dt><dd><p>a factor with levels <code>Asian</code>
<code>Arab</code> <code>Black</code> <code>Indig-White</code> <code>Other</code></p>
</dd>
<dt><code>voted</code></dt><dd><p>a factor with levels <code>Yes</code> <code>No</code></p>
</dd>
<dt><code>married</code></dt><dd><p>a factor with levels <code>Never married</code>
<code>Currently married</code> <code>Previously married</code></p>
</dd>
<dt><code>familysize</code></dt><dd><p>a numeric vector</p>
</dd> 
</dl>



<h3>Details</h3>

<p>In addition to scores on the Big Five scales, the dataset contains 11
demographic variables on the participants, potentially useful in
multivariate analyses.
</p>
<p>Scores on each personality domain were calculated by averaging items
assigned to each domain (after reverse scoring specific items). In this
version, total scores for each scale were calculated by averaging the
positively and negatively coded items, for example, <code>TIPI$Extraversion
&lt;- (TIPI$E + (8-TIPI$E_r))/2</code>.
</p>
<p>Then, for the present purposes, some tidying was done: </p>
 <ul>
<li><p> 100
cases with 'gender==&quot;Other&quot; were deleted; </p>
</li>
<li><p> codes for levels of
'education', 'engnat' and 'race' were abbreviated for ease of use in
graphics. </p>
</li></ul>



<h3>Source</h3>

<p>Jones, P.J., Mair, P., Simon, T. et al. (2020). Network Trees: A
Method for Recursively Partitioning Covariance Structures.
<em>Psychometrika</em>, <b>85</b>, 926?945.
https://doi.org/10.1007/s11336-020-09731-4
</p>


<h3>References</h3>

<p>Gosling, S. D., Rentfrow, P. J., &amp; Swann, W. B, Jr. (2003). A
very brief measure of the Big-Five personality domains. <em>Journal of
Research in Personality</em>, <b>37</b>, 504?528.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(TIPI)
# fit an mlm
tipi.mlm &lt;- lm(cbind(Extraversion, Neuroticism, Conscientiousness, Agreeableness, Openness) 
               ~ engnat + gender + education, data = TIPI )
car::Anova(tipi.mlm)

heplot(tipi.mlm, fill=TRUE, fill.alpha=0.1)

pairs(tipi.mlm, fill=TRUE, fill.alpha=0.1)

# candisc works best for factors with &gt;2 levels
library(candisc)
tipi.can &lt;- candisc(tipi.mlm, term="education")
tipi.can

heplot(tipi.can, fill=TRUE, fill.alpha=0.1, 
       var.col = "darkred", var.cex = 1.5, var.lwd = 3)

</code></pre>

<hr>
<h2 id='trans.colors'>Make Colors Transparent</h2><span id='topic+trans.colors'></span>

<h3>Description</h3>

<p>Takes a vector of colors (as color names or rgb hex values) and adds a
specified alpha transparency to each.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trans.colors(col, alpha = 0.5, names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trans.colors_+3A_col">col</code></td>
<td>
<p>A character vector of colors, either as color names or rgb hex
values</p>
</td></tr>
<tr><td><code id="trans.colors_+3A_alpha">alpha</code></td>
<td>
<p>alpha transparency value(s) to apply to each color (0 means
fully transparent and 1 means opaque)</p>
</td></tr>
<tr><td><code id="trans.colors_+3A_names">names</code></td>
<td>
<p>optional character vector of names for the colors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Colors (<code>col</code>) and <code>alpha</code> need not be of the same length. The
shorter one is replicated to make them of the same length.
</p>


<h3>Value</h3>

<p>A vector of color values of the form <code>"#rrggbbaa"</code>
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code>, <code><a href="grDevices.html#topic+rgb">rgb</a></code>,
<code><a href="grDevices.html#topic+adjustcolor">adjustcolor</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
trans.colors(palette(), alpha=0.5)

# alpha can be vectorized
trans.colors(palette(), alpha=seq(0, 1, length=length(palette())))

# lengths need not match: shorter one is repeated as necessary
trans.colors(palette(), alpha=c(.1, .2))

trans.colors(colors()[1:20])

# single color, with various alphas
trans.colors("red", alpha=seq(0,1, length=5))
# assign names
trans.colors("red", alpha=seq(0,1, length=5), names=paste("red", 1:5, sep=""))


</code></pre>

<hr>
<h2 id='uniStats'>Univariate Test Statistics for a Multivariate Linear Model</h2><span id='topic+uniStats'></span>

<h3>Description</h3>

<p>Univariate Test Statistics for a Multivariate Linear Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniStats(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uniStats_+3A_x">x</code></td>
<td>
<p>A <code>"mlm"</code> object fitted by <code>link[stats]{lm}</code> with two or more response variable3s</p>
</td></tr>
<tr><td><code id="uniStats_+3A_...">...</code></td>
<td>
<p>Other arguments, ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c("anova", "data.frame")</code> containing, for each response variable
the overall <code class="reqn">R^2</code> for all terms in the model and the overall <code class="reqn">F</code> statistic
together with its degrees of freedom and p-value.
</p>


<h3>See Also</h3>

<p>[glance.mlm()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris.mod &lt;- lm(cbind(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width) ~ Species, data=iris)
car::Anova(iris.mod)
uniStats(iris.mod)

data(Plastic, package = "heplots")
plastic.mod &lt;- lm(cbind(tear, gloss, opacity) ~ rate*additive, data=Plastic)
# multivariate tests
car::Anova(plastic.mod)
</code></pre>

<hr>
<h2 id='VocabGrowth'>Vocabulary growth data</h2><span id='topic+VocabGrowth'></span>

<h3>Description</h3>

<p>Data from the Laboratory School of the University of Chicago.  They consist
of scores from a cohort of pupils in grades 8-11 on the vocabulary section
of the Cooperative Reading Test.  The scores are scaled to a common, but
arbitrary origin and unit of measurement, so as to be comparable over the
four grades.
</p>


<h3>Format</h3>

<p>A data frame with 64 observations on the following 4 variables.
</p>
 
<dl>
<dt><code>grade8</code></dt><dd><p>Grade 8 vocabulary score</p>
</dd>
<dt><code>grade9</code></dt><dd><p>Grade 9 vocabulary score</p>
</dd> 
<dt><code>grade10</code></dt><dd><p>Grade 10 vocabulary score</p>
</dd> 
<dt><code>grade11</code></dt><dd><p>Grade 11 vocabulary score</p>
</dd> 
</dl>



<h3>Details</h3>

<p>Since these data cover an age range in which physical growth is beginning to
decelerate, it is of interest whether a similar effect occurs in the
acquisition of new vocabulary.
</p>


<h3>Source</h3>

<p>R.D.  
Bock, <em>Multivariate statistical methods in behavioral research</em>, McGraw-Hill, New York, 1975, pp453.
</p>


<h3>References</h3>

<p>Friendly, Michael (2010). HE Plots for Repeated Measures
Designs. <em>Journal of Statistical Software</em>, 37(4), 1-40.
<a href="https://doi.org/10.18637/jss.v037.i04">doi:10.18637/jss.v037.i04</a>.
</p>
<p>Keesling, J.W., Bock, R.D. et al, &quot;The Laboratory School study of vocabulary
growth&quot;, University of Chicago, 1975.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(car)
data(VocabGrowth)

# Standard Multivariate &amp; Univariate repeated measures analysis
Vocab.mod &lt;- lm(cbind(grade8,grade9,grade10,grade11) ~ 1, data=VocabGrowth)
idata &lt;-data.frame(grade=ordered(8:11))
car::Anova(Vocab.mod, idata=idata, idesign=~grade, type="III")

##Type III Repeated Measures MANOVA Tests: Pillai test statistic
##            Df test stat approx F num Df den Df    Pr(&gt;F)    
##(Intercept)  1     0.653  118.498      1     63 4.115e-16 ***
##grade        1     0.826   96.376      3     61 &lt; 2.2e-16 ***


heplot(Vocab.mod, type="III", idata=idata, idesign=~grade, iterm="grade",
	main="HE plot for Grade effect")

### doing this 'manually' by explicitly transforming Y -&gt; Y M
# calculate Y M, using polynomial contrasts
trends &lt;- as.matrix(VocabGrowth) %*% poly(8:11, degree=3)
colnames(trends)&lt;- c("Linear", "Quad", "Cubic")

# test all trend means = 0 == Grade effect
within.mod &lt;- lm(trends ~ 1)

Manova(within.mod)
heplot(within.mod, terms="(Intercept)", col=c("red", "blue"), type="3",
  term.labels="Grade",
  main="HE plot for Grade effect")
mark.H0()

</code></pre>

<hr>
<h2 id='WeightLoss'>Weight Loss Data</h2><span id='topic+WeightLoss'></span>

<h3>Description</h3>

<p>Contrived data on weight loss and self esteem over three months, for three
groups of individuals: Control, Diet and Diet + Exercise. The data
constitute a double-multivariate design.
</p>


<h3>Format</h3>

<p>A data frame with 34 observations on the following 7 variables.
</p>
 
<dl>
<dt><code>group</code></dt><dd><p>a factor with levels <code>Control</code>
<code>Diet</code> <code>DietEx</code>.</p>
</dd> <dt><code>wl1</code></dt><dd><p>Weight loss at 1 month</p>
</dd>
<dt><code>wl2</code></dt><dd><p>Weight loss at 2 months</p>
</dd> 
<dt><code>wl3</code></dt><dd><p>Weight loss at 3 months</p>
</dd> 
<dt><code>se1</code></dt><dd><p>Self esteem at 1 month</p>
</dd>
<dt><code>se2</code></dt><dd><p>Self esteem at 2 months</p>
</dd> 
<dt><code>se3</code></dt><dd><p>Self esteem at 3 months</p>
</dd> 
</dl>



<h3>Details</h3>

<p>Helmert contrasts are assigned to <code>group</code>, comparing <code>Control</code> vs.
(<code>Diet</code> <code>DietEx</code>) and <code>Diet</code> vs. <code>DietEx</code>.
</p>


<h3>Source</h3>

<p>Originally taken from
<a href="http://www.csun.edu/~ata20315/psy524/main.htm">http://www.csun.edu/~ata20315/psy524/main.htm</a>, but modified slightly
</p>


<h3>References</h3>

<p>Friendly, Michael (2010). HE Plots for Repeated Measures
Designs. <em>Journal of Statistical Software</em>, 37(4), 1-40.
<a href="https://doi.org/10.18637/jss.v037.i04">doi:10.18637/jss.v037.i04</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(WeightLoss)
str(WeightLoss)
table(WeightLoss$group)

contrasts(WeightLoss$group) &lt;- matrix(c(-2,1,1, 0, -1, 1),ncol=2)
(wl.mod&lt;-lm(cbind(wl1,wl2,wl3,se1,se2,se3)~group, data=WeightLoss))

heplot(wl.mod, hypotheses=c("group1", "group2"))
pairs(wl.mod, variables=1:3)
pairs(wl.mod, variables=4:6)

# within-S variables
within &lt;- data.frame(measure=rep(c("Weight loss", "Self esteem"),each=3), month=rep(ordered(1:3),2))

# doubly-multivariate analysis: requires car 2.0+
## Not run: 
imatrix &lt;- matrix(c(
	1,0,-1, 1, 0, 0,
	1,0, 0,-2, 0, 0,
	1,0, 1, 1, 0, 0,
	0,1, 0, 0,-1, 1,
	0,1, 0, 0, 0,-2,
	0,1, 0, 0, 1, 1), 6, 6, byrow=TRUE)

# NB: for heplots the columns of imatrix should have names
colnames(imatrix) &lt;- c("WL", "SE", "WL.L", "WL.Q", "SE.L", "SE.Q")
rownames(imatrix) &lt;- colnames(WeightLoss)[-1]
(imatrix &lt;- list(measure=imatrix[,1:2], month=imatrix[,3:6]))
contrasts(WeightLoss$group) &lt;- matrix(c(-2,1,1, 
                                        0,-1,1), ncol=2) 

(wl.mod&lt;-lm(cbind(wl1, wl2, wl3, se1, se2, se3)~group, data=WeightLoss))
(wl.aov &lt;- car::Anova(wl.mod, imatrix=imatrix, test="Roy"))

heplot(wl.mod, imatrix=imatrix, iterm="group:measure")

## End(Not run)

# do the correct analysis 'manually'
unit &lt;- function(n, prefix="") {
	J &lt;-matrix(rep(1, n), ncol=1)
	rownames(J) &lt;- paste(prefix, 1:n, sep="")
	J
}                

measure &lt;- kronecker(diag(2), unit(3, 'M')/3, make.dimnames=TRUE)
colnames(measure)&lt;- c('WL', 'SE')

between &lt;- as.matrix(WeightLoss[,-1]) %*% measure

between.mod &lt;- lm(between ~ group, data=WeightLoss)
car::Anova(between.mod)

heplot(between.mod, hypotheses=c("group1", "group2"), 
	xlab="Weight Loss", ylab="Self Esteem",
	col=c("red", "blue", "brown"),
	main="Weight Loss &amp; Self Esteem: Group Effect")

month &lt;- kronecker(diag(2), poly(1:3), make.dimnames=TRUE)
colnames(month)&lt;- c('WL', 'SE')
trends &lt;- as.matrix(WeightLoss[,-1]) %*% month
within.mod &lt;- lm(trends ~ group, data=WeightLoss)
car::Anova(within.mod)

heplot(within.mod)
heplot(within.mod, hypotheses=c("group1", "group2"), 
	xlab="Weight Loss", ylab="Self Esteem",
	type="III", remove.intercept=FALSE,
	term.labels=c("month", "group:month"),
	main="Weight Loss &amp; Self Esteem: Within-S Effects")
mark.H0()

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
