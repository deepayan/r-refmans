<!DOCTYPE html><html lang="en"><head><title>Help for package leidenAlg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {leidenAlg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.dendrogram.fakeCommunities'><p>Returns pre-calculated dendrogram</p></a></li>
<li><a href='#exampleGraph'><p>Conos graph</p></a></li>
<li><a href='#find_partition'><p>Finds the optimal partition using the Leiden algorithm</p></a></li>
<li><a href='#find_partition_rcpp'><p>Refer to the R function find_partition()</p>
For notes of the graph object, refer to https://igraph.org/c/doc/igraph-Basic.html</a></li>
<li><a href='#find_partition_with_rep'><p>Finds the optimal partition using the Leiden algorithm with replicate starts</p></a></li>
<li><a href='#find_partition_with_rep_rcpp'><p>Finds the optimal partition using the Leiden algorithm</p></a></li>
<li><a href='#leiden.community'><p>Leiden algorithm community detection</p>
Detects communities using Leiden algorithm (implementation copied from https://github.com/vtraag/leidenalg)</a></li>
<li><a href='#membership.fakeCommunities'><p>Returns pre-calculated membership factor</p></a></li>
<li><a href='#rleiden.community'><p>Recursive leiden communities</p>
Constructs an n-step recursive clustering, using leiden.community</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Implements the Leiden Algorithm via an R Interface</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.4</td>
</tr>
<tr>
<td>Description:</td>
<td>An R interface to the Leiden algorithm, an iterative community detection algorithm on networks. The algorithm is designed to converge to a partition in which all subsets of all communities are locally optimally assigned, yielding communities guaranteed to be connected. The implementation proves to be fast, scales well, and can be run on graphs of millions of nodes (as long as they can fit in memory). The original implementation was constructed as a python interface "leidenalg" found here: <a href="https://github.com/vtraag/leidenalg">https://github.com/vtraag/leidenalg</a>. The algorithm was originally described in Traag, V.A., Waltman, L. &amp; van Eck, N.J. "From Louvain to Leiden: guaranteeing well-connected communities". Sci Rep 9, 5233 (2019) &lt;<a href="https://doi.org/10.1038%2Fs41598-019-41695-z">doi:10.1038/s41598-019-41695-z</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>See the file COPYRIGHTS for various leidenAlg copyright
details</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), Matrix</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, igraph, methods, parallel, Rcpp (&ge;
1.0.5), sccore, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>pbapply, testthat (&ge; 3.1.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppEigen</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make (optional), libxml2 (optional), glpk (&gt;=
4.57, optional)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kharchenkolab/leidenAlg">https://github.com/kharchenkolab/leidenAlg</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kharchenkolab/leidenAlg/issues">https://github.com/kharchenkolab/leidenAlg/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Kharchenko [aut],
  Viktor Petukhov [aut],
  Yichen Wang [aut],
  V.A. Traag [ctb],
  Gábor Csárdi [ctb],
  Tamás Nepusz [ctb],
  Minh Van Nguyen [ctb],
  Evan Biederstedt [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Evan Biederstedt &lt;evan.biederstedt@gmail.com&gt;</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-17 20:29:51 UTC; evanbiederstedt</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-17 21:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.dendrogram.fakeCommunities'>Returns pre-calculated dendrogram</h2><span id='topic+as.dendrogram.fakeCommunities'></span>

<h3>Description</h3>

<p>Returns pre-calculated dendrogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fakeCommunities'
as.dendrogram(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.dendrogram.fakeCommunities_+3A_object">object</code></td>
<td>
<p>fakeCommunities object</p>
</td></tr>
<tr><td><code id="as.dendrogram.fakeCommunities_+3A_...">...</code></td>
<td>
<p>further parameters for generic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dendrogram
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rLeidenComm = suppressWarnings(rleiden.community(exampleGraph, n.cores=1))
as.dendrogram.fakeCommunities(rLeidenComm)

</code></pre>

<hr>
<h2 id='exampleGraph'>Conos graph</h2><span id='topic+exampleGraph'></span>

<h3>Description</h3>

<p>Conos graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exampleGraph
</code></pre>


<h3>Format</h3>

<p>An object of class <code>igraph</code> of length 100.
</p>

<hr>
<h2 id='find_partition'>Finds the optimal partition using the Leiden algorithm</h2><span id='topic+find_partition'></span>

<h3>Description</h3>

<p>Finds the optimal partition using the Leiden algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_partition(graph, edge_weights, resolution = 1, niter = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_partition_+3A_graph">graph</code></td>
<td>
<p>The igraph graph to define the partition on</p>
</td></tr>
<tr><td><code id="find_partition_+3A_edge_weights">edge_weights</code></td>
<td>
<p>Vector of edge weights. In weighted graphs, a real number is assigned to each (directed or undirected) edge. For an unweighted graph, this is set to 1. Refer to igraph, weighted graphs.</p>
</td></tr>
<tr><td><code id="find_partition_+3A_resolution">resolution</code></td>
<td>
<p>Numeric scalar, resolution parameter controlling communities detected (default=1.0) Higher resolutions lead to more communities, while lower resolutions lead to fewer communities.</p>
</td></tr>
<tr><td><code id="find_partition_+3A_niter">niter</code></td>
<td>
<p>Number of iterations that the algorithm should be run for (default=2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of membership values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
library(leidenAlg)

g &lt;- make_star(10)
E(g)$weight &lt;- seq(ecount(g))
find_partition(g, E(g)$weight)

</code></pre>

<hr>
<h2 id='find_partition_rcpp'>Refer to the R function find_partition()
For notes of the graph object, refer to https://igraph.org/c/doc/igraph-Basic.html</h2><span id='topic+find_partition_rcpp'></span>

<h3>Description</h3>

<p>Refer to the R function find_partition()
For notes of the graph object, refer to https://igraph.org/c/doc/igraph-Basic.html
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_partition_rcpp(
  edgelist,
  edgelist_length,
  num_vertices,
  direction,
  edge_weights,
  resolution = 1,
  niter = 2L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_partition_rcpp_+3A_edgelist">edgelist</code></td>
<td>
<p>The graph edge list</p>
</td></tr>
<tr><td><code id="find_partition_rcpp_+3A_edgelist_length">edgelist_length</code></td>
<td>
<p>integer The length of the graph edge list</p>
</td></tr>
<tr><td><code id="find_partition_rcpp_+3A_num_vertices">num_vertices</code></td>
<td>
<p>integer The number of vertices in the graph</p>
</td></tr>
<tr><td><code id="find_partition_rcpp_+3A_direction">direction</code></td>
<td>
<p>boolean Whether the graph is directed or undirected</p>
</td></tr>
<tr><td><code id="find_partition_rcpp_+3A_edge_weights">edge_weights</code></td>
<td>
<p>Vector of edge weights. In weighted graphs, a real number is assigned to each (directed or undirected) edge. For an unweighted graph, this is set to 1. Refer to igraph, weighted graphs.</p>
</td></tr>
<tr><td><code id="find_partition_rcpp_+3A_resolution">resolution</code></td>
<td>
<p>Numeric scalar, resoluiton parameter controlling communities detected (default=1.0) Higher resolutions lead to more communities, while lower resolutions lead to fewer communities.</p>
</td></tr>
<tr><td><code id="find_partition_rcpp_+3A_niter">niter</code></td>
<td>
<p>Number of iterations that the algorithm should be run for (default=2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of membership values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
edgelist &lt;- as.vector(t(igraph::as_edgelist(exampleGraph, names=FALSE))) - 1
edgelist_length &lt;- length(edgelist)
num_vertices &lt;- length(igraph::V(exampleGraph)) - 1
direction &lt;- igraph::is_weighted(exampleGraph)
find_partition_rcpp(edgelist, edgelist_length, num_vertices, direction, E(exampleGraph)$weight)
</code></pre>

<hr>
<h2 id='find_partition_with_rep'>Finds the optimal partition using the Leiden algorithm with replicate starts</h2><span id='topic+find_partition_with_rep'></span>

<h3>Description</h3>

<p>This function performs Leiden algorithm <code>nrep</code> times and returns the
result from the run with the maximum quality.
</p>
<p>Since Leiden algorithm has stochastic process, repeating stochastically may
improve the result. However, users should be aware of whether there is indeed
a community structure with exploration, rather than blindly trusting the
returned result that comes with the highest quality value.
</p>
<p>The random number generator (RNG) is not re-seeded at each new start of
community detection, in order to keep the independence of each replicate. To
get reproducible result, users can run <code>set.seed()</code> before calling these
functions.
</p>
<p><code><a href="#topic+find_partition">find_partition</a></code> only performs the community detection once and
the reproducibility can also be ensured with <code>set.seed()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_partition_with_rep(
  graph,
  edge_weights,
  resolution = 1,
  niter = 2,
  nrep = 10
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_partition_with_rep_+3A_graph">graph</code></td>
<td>
<p>The igraph graph to define the partition on</p>
</td></tr>
<tr><td><code id="find_partition_with_rep_+3A_edge_weights">edge_weights</code></td>
<td>
<p>Vector of edge weights. In weighted graphs, a real number is assigned to each (directed or undirected) edge. For an unweighted graph, this is set to 1. Refer to igraph, weighted graphs.</p>
</td></tr>
<tr><td><code id="find_partition_with_rep_+3A_resolution">resolution</code></td>
<td>
<p>Numeric scalar, resolution parameter controlling communities detected (default=1.0) Higher resolutions lead to more communities, while lower resolutions lead to fewer communities.</p>
</td></tr>
<tr><td><code id="find_partition_with_rep_+3A_niter">niter</code></td>
<td>
<p>Number of iterations that the algorithm should be run for (default=2)</p>
</td></tr>
<tr><td><code id="find_partition_with_rep_+3A_nrep">nrep</code></td>
<td>
<p>Number of replicate starts with random number being updated. (default=10) The result with the best quality will be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of membership values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)

# To run 10 replicates and get the partitioning with the highest quality
membership &lt;- find_partition_with_rep(exampleGraph, E(exampleGraph)$weight, nrep = 10)

# To get reprodicible result for every function call, do `set.seed()` right before calling
set.seed(233)
res1 &lt;- find_partition_with_rep(exampleGraph, E(exampleGraph)$weight, resolution = 2)
# Here, no seed was set...
res2 &lt;- find_partition_with_rep(exampleGraph, E(exampleGraph)$weight, resolution = 2)
set.seed(233)
res3 &lt;- find_partition_with_rep(exampleGraph, E(exampleGraph)$weight, resolution = 2)
identical(res1, res2) # FALSE (usually), as no seed as set
identical(res1, res3) # TRUE (always), as set.seed() was used directly before the function call

</code></pre>

<hr>
<h2 id='find_partition_with_rep_rcpp'>Finds the optimal partition using the Leiden algorithm</h2><span id='topic+find_partition_with_rep_rcpp'></span>

<h3>Description</h3>

<p>Finds the optimal partition using the Leiden algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_partition_with_rep_rcpp(
  edgelist,
  edgelist_length,
  num_vertices,
  direction,
  edge_weights,
  resolution = 1,
  niter = 2L,
  nrep = 1L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_partition_with_rep_rcpp_+3A_edgelist">edgelist</code></td>
<td>
<p>The graph edge list</p>
</td></tr>
<tr><td><code id="find_partition_with_rep_rcpp_+3A_edgelist_length">edgelist_length</code></td>
<td>
<p>integer The length of the graph edge list</p>
</td></tr>
<tr><td><code id="find_partition_with_rep_rcpp_+3A_num_vertices">num_vertices</code></td>
<td>
<p>integer The number of vertices in the graph</p>
</td></tr>
<tr><td><code id="find_partition_with_rep_rcpp_+3A_direction">direction</code></td>
<td>
<p>boolean Whether the graph is directed or undirected</p>
</td></tr>
<tr><td><code id="find_partition_with_rep_rcpp_+3A_edge_weights">edge_weights</code></td>
<td>
<p>Vector of edge weights. In weighted graphs, a real number is assigned to each (directed or undirected) edge. For an unweighted graph, this is set to 1. Refer to igraph, weighted graphs.</p>
</td></tr>
<tr><td><code id="find_partition_with_rep_rcpp_+3A_resolution">resolution</code></td>
<td>
<p>Numeric scalar, resoluiton parameter controlling communities detected (default=1.0) Higher resolutions lead to more communities, while lower resolutions lead to fewer communities.</p>
</td></tr>
<tr><td><code id="find_partition_with_rep_rcpp_+3A_niter">niter</code></td>
<td>
<p>Number of iterations that the algorithm should be run for (default=2)</p>
</td></tr>
<tr><td><code id="find_partition_with_rep_rcpp_+3A_nrep">nrep</code></td>
<td>
<p>Number of replicate starts with random number being updated. (default=10) The result with the best quality will be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For notes of the graph object, refer to https://igraph.org/c/doc/igraph-Basic.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(igraph)

edgelist &lt;- as.vector(t(igraph::as_edgelist(exampleGraph, names=FALSE))) - 1
edgelist_len &lt;- length(edgelist)  ## The length of the graph edge list
n_vertices &lt;- length(igraph::V(exampleGraph)) - 1  ## The number of vertices in the graph
direct &lt;- igraph::is_weighted(exampleGraph)  ## Whether the graph is directed or undirected
edge_weights &lt;- E(exampleGraph)$weight
find_partition_with_rep_rcpp(edgelist, edgelist_len, n_vertices, direct, edge_weights, nrep = 10)

</code></pre>

<hr>
<h2 id='leiden.community'>Leiden algorithm community detection
Detects communities using Leiden algorithm (implementation copied from https://github.com/vtraag/leidenalg)</h2><span id='topic+leiden.community'></span>

<h3>Description</h3>

<p>Leiden algorithm community detection
Detects communities using Leiden algorithm (implementation copied from https://github.com/vtraag/leidenalg)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leiden.community(graph, resolution = 1, n.iterations = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="leiden.community_+3A_graph">graph</code></td>
<td>
<p>graph on which communities should be detected</p>
</td></tr>
<tr><td><code id="leiden.community_+3A_resolution">resolution</code></td>
<td>
<p>resolution parameter (default=1.0) - higher numbers lead to more communities</p>
</td></tr>
<tr><td><code id="leiden.community_+3A_n.iterations">n.iterations</code></td>
<td>
<p>number of iterations that the algorithm should be run for (default=2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a fakeCommunities object that returns membership and dendrogram
</p>


<h3>Examples</h3>

<pre><code class='language-R'>leiden.community(exampleGraph)

</code></pre>

<hr>
<h2 id='membership.fakeCommunities'>Returns pre-calculated membership factor</h2><span id='topic+membership.fakeCommunities'></span>

<h3>Description</h3>

<p>Returns pre-calculated membership factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fakeCommunities'
membership(communities, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="membership.fakeCommunities_+3A_communities">communities</code></td>
<td>
<p>fakeCommunities object</p>
</td></tr>
<tr><td><code id="membership.fakeCommunities_+3A_...">...</code></td>
<td>
<p>further parameters for generic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>membership factor
</p>


<h3>Examples</h3>

<pre><code class='language-R'>leidenComm = leiden.community(exampleGraph)
membership.fakeCommunities(leidenComm)

</code></pre>

<hr>
<h2 id='rleiden.community'>Recursive leiden communities
Constructs an n-step recursive clustering, using leiden.community</h2><span id='topic+rleiden.community'></span>

<h3>Description</h3>

<p>Recursive leiden communities
Constructs an n-step recursive clustering, using leiden.community
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rleiden.community(
  graph,
  max.depth = 2,
  n.cores = parallel::detectCores(logical = FALSE),
  min.community.size = 10,
  verbose = FALSE,
  resolution = 1,
  cur.depth = 1,
  hierarchical = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rleiden.community_+3A_graph">graph</code></td>
<td>
<p>graph</p>
</td></tr>
<tr><td><code id="rleiden.community_+3A_max.depth">max.depth</code></td>
<td>
<p>Recursive depth (default=2)</p>
</td></tr>
<tr><td><code id="rleiden.community_+3A_n.cores">n.cores</code></td>
<td>
<p>integer Number of cores to use (default = parallel::detectCores(logical=FALSE)). If logical=FALSE, uses the number of physical CPUs/cores. If logical=TRUE, uses the logical number of CPUS/cores. See parallel::detectCores()</p>
</td></tr>
<tr><td><code id="rleiden.community_+3A_min.community.size">min.community.size</code></td>
<td>
<p>integer Minimal community size parameter for the walktrap communities&mdash;Communities smaller than that will be merged (default=10)</p>
</td></tr>
<tr><td><code id="rleiden.community_+3A_verbose">verbose</code></td>
<td>
<p>boolean Whether to output progress messages (default=FALSE)</p>
</td></tr>
<tr><td><code id="rleiden.community_+3A_resolution">resolution</code></td>
<td>
<p>resolution parameter passed to leiden.community (either a single value, or a value equivalent to max.depth) (default=1)</p>
</td></tr>
<tr><td><code id="rleiden.community_+3A_cur.depth">cur.depth</code></td>
<td>
<p>integer Current depth of clustering (default=1)</p>
</td></tr>
<tr><td><code id="rleiden.community_+3A_hierarchical">hierarchical</code></td>
<td>
<p>boolean If TRUE, calculate hierarchy on the multilevel clusters (default=TRUE)</p>
</td></tr>
<tr><td><code id="rleiden.community_+3A_...">...</code></td>
<td>
<p>passed to leiden.community</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a fakeCommunities object that returns membership and dendrogram
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rleiden.community(exampleGraph, n.cores=1)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
