<!DOCTYPE html><html><head><title>Help for package RCEIM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RCEIM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RCEIM-package'>
<p>An R Cross Entropy Inspired Method for Optimization</p>
RCEIM</a></li>
<li><a href='#ceimOpt'>
<p>A Cross Entropy Inspired Method for Optimization</p></a></li>
<li><a href='#enforceDomainOnParameters'>
<p>Enforce domain boundaries</p></a></li>
<li><a href='#overPlotErrorPolygon'>
<p>Overplot an error polygon</p></a></li>
<li><a href='#plotEliteDistrib'>
<p>Plot the distribution of elite members</p></a></li>
<li><a href='#sortDataFrame'>
<p>Sorting a data frame by a key</p></a></li>
<li><a href='#testFunOptimization'>
<p>1D test problem for RCEIM</p></a></li>
<li><a href='#testFunOptimization2d'>
<p>2D test problem for RCEIM</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>R Cross Entropy Inspired Method for Optimization</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-04-03</td>
</tr>
<tr>
<td>Author:</td>
<td>Alberto Krone-Martins</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alberto Krone-Martins &lt;algol@sim.ul.pt&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of a stochastic heuristic method for performing multidimensional function optimization. The method is inspired in the Cross-Entropy Method. It does not relies on derivatives, neither imposes particularly strong requirements into the function to be optimized. Additionally, it takes profit from multi-core processing to enable optimization of time-consuming functions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Suggests:</td>
<td>parallel</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-04-03 19:00:59 UTC; algol</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-04-03 20:19:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='RCEIM-package'>
An R Cross Entropy Inspired Method for Optimization
RCEIM
</h2><span id='topic+RCEIM-package'></span><span id='topic+RCEIM'></span>

<h3>Description</h3>

<p>RCEIM is a package implementing a stochastic heuristic method for performing multidimensional function optimization. The method is inspired in the Cross-Entropy Method.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> RCEIM</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2015-02-19</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>RCEIM implements a simple stochastic heuristic method for optimization in the function <code><a href="#topic+ceimOpt">ceimOpt</a></code>. This method starts from a random population of solutions, computes the values of the function and selects a fraction of these solutions - the elite members. Afterwards, based on the elite members it creates a gaussian distribution, samples new random solutions from it, and iterates until convergence is reached (this is controlled by an epsilon parameter) or other stopping criteria is fulfilled (such as the maximum number of iterations).
</p>
<p>One advantage of this method is that it does not impose strong conditions on the function to be optimized. The function must written as an R function, but it does not need to be continuous, differentiable, neither analytic. Moreover, the method is ready for multicore processing, enabling the optimization of time-consuming functions.
</p>
<p><img src="../help/figures/RCEIM-Problems.jpg" alt="RCEIM-Problems" />

</p>
<p>Two examples of 1D and 2D functions that can be used as test problems for RCEIM (defined in <code><a href="#topic+testFunOptimization">testFunOptimization</a></code> and <code><a href="#topic+testFunOptimization2d">testFunOptimization2d</a></code>) are represented in the above figures.
</p>


<h3>Author(s)</h3>

<p>Alberto Krone-Martins, Laurent Gallucio
</p>
<p>Maintainer: Alberto Krone-Martins &lt;algol@sim.ul.pt&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ceimOpt">ceimOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Solve a simple optimization problem and shows the results
po &lt;- ceimOpt(OptimFunction=function(x){(x[1]+1)^2+(x[2]+2)^2}, maxIter=100, epsilon=0.3, 
      nParams=2)
plotEliteDistrib(po$EliteMembers)
rm(po)

# A harder problem in 1D
po &lt;- ceimOpt(OptimFunction="testFunOptimization", maxIter=10, epsilon=0.3, 
      nParams=1, verbose=TRUE)
dev.new()
xx &lt;- seq(-10,10,by=0.01)
plot(xx, testFunOptimization(xx), type="l", xlab="x", ylab="Value")
points(po$BestMember[1], po$BestMember[2], col="red")
rm(list=c('xx','po'))

# A harder problem in 2D
po &lt;- ceimOpt(OptimFunction="testFunOptimization2d", maxIter=20, epsilon=0.3, 
      nParams=2, verbose=TRUE)
dev.new()
xx &lt;- seq(-10,10,by=0.1)
yy &lt;- seq(-10,10,by=0.1)
zz &lt;- matrix(nrow=length(yy), ncol=length(xx))
for(i in 1:length(xx)){
    for(j in 1:length(yy)){
        zz[i,j] &lt;- testFunOptimization2d( c(xx[i],yy[j]) )
    }
}
image(xx,yy,zz, col=gray((50:100)/100), xlab="x", ylab="y")
contour(xx,yy,zz, add=TRUE)
points(po$BestMember[1], po$BestMember[2], col="red", pch=19, cex=0.5)
rm(list=c('xx','yy','zz'))

# Example of multicore processing
slowFunction &lt;- function(x) { 
  p&lt;-runif(50000)
  return((x+3)^2)
} 
system.time(po &lt;- ceimOpt(OptimFunction="slowFunction", maxIter=10,
    Ntot=100, epsilon=0.3, nParams=1, verbose=FALSE, parallel=FALSE))
print(po$BestMember)
system.time(po &lt;- ceimOpt(OptimFunction="slowFunction", maxIter=10,
    Ntot=100, epsilon=0.3, nParams=1, verbose=FALSE, parallel=TRUE))
print(po$BestMember)
rm(po)
</code></pre>

<hr>
<h2 id='ceimOpt'>
A Cross Entropy Inspired Method for Optimization
</h2><span id='topic+ceimOpt'></span>

<h3>Description</h3>

<p>This is a Cross-Entropy Inspired Method for optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ceimOpt(OptimFunction = "testFunOptimization", nParams = 1, minimize = TRUE, 
    Ntot = 1000, N_elite = floor(Ntot/4), N_super = 1, alpha = 1, epsilon = 0.1, 
    q = 2, maxIter = 50, waitGen = maxIter, boundaries = t(matrix(rep(c(-10, 10), 
    nParams), ncol = nParams)),plotConvergence = FALSE, chaosGen = maxIter, 
    handIterative = FALSE, verbose = FALSE, plotResultDistribution = FALSE, 
    parallelVersion = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ceimOpt_+3A_optimfunction">OptimFunction</code></td>
<td>

<p>A string with the name of the function that will be optimized.
</p>
</td></tr>
<tr><td><code id="ceimOpt_+3A_nparams">nParams</code></td>
<td>

<p>An integer with the number of parameters of the function that will be optimized.
</p>
</td></tr>
<tr><td><code id="ceimOpt_+3A_minimize">minimize</code></td>
<td>

<p>A boolean indicating if the OptimFunction should be minimized or maximized.
</p>
</td></tr>
<tr><td><code id="ceimOpt_+3A_ntot">Ntot</code></td>
<td>

<p>An integer with the number of individuals per iteration.
</p>
</td></tr>
<tr><td><code id="ceimOpt_+3A_n_elite">N_elite</code></td>
<td>

<p>An integer with the number of elite individuals, or in other words, the individuals used to define the individuals of the new iteration.
</p>
</td></tr>
<tr><td><code id="ceimOpt_+3A_n_super">N_super</code></td>
<td>

<p>An integer with the number of super-individuals, or those individuals with the best fitness values, that are directly replicated to the next iteration.
</p>
</td></tr>
<tr><td><code id="ceimOpt_+3A_alpha">alpha</code></td>
<td>

<p>A parameter of the CE method used to control the convergence rate, and to prevent early convergence.
</p>
</td></tr>
<tr><td><code id="ceimOpt_+3A_epsilon">epsilon</code></td>
<td>

<p>A convergence control parameter: if the maximum st.dev. of the parameters of the elite individuals divided by its average value is smaller than this number, the method considers that it converged.
</p>
</td></tr>
<tr><td><code id="ceimOpt_+3A_q">q</code></td>
<td>

<p>A parameter of the CE method used to control the convergence rate, and to prevent early convergence.  
</p>
</td></tr>
<tr><td><code id="ceimOpt_+3A_maxiter">maxIter</code></td>
<td>

<p>The maximum number of iterations that the method will run before stop.
</p>
</td></tr>
<tr><td><code id="ceimOpt_+3A_waitgen">waitGen</code></td>
<td>

<p>The number of iterations that the method will wait: after &quot;waitGen&quot; without any improvement in the best individual, the method gives up and return the best individual as an answer.
</p>
</td></tr>
<tr><td><code id="ceimOpt_+3A_boundaries">boundaries</code></td>
<td>

<p>A matrix with as many rows as there are parameters and two columns the first column stores the minimum value, while the second, the maximum.
</p>
</td></tr>
<tr><td><code id="ceimOpt_+3A_plotconvergence">plotConvergence</code></td>
<td>

<p>A flag to indicate if the user wants to visually check the convergence of the method.
</p>
</td></tr>
<tr><td><code id="ceimOpt_+3A_chaosgen">chaosGen</code></td>
<td>

<p>The number of iterations before the method replaces all the solutions, but the super-individuals, by a new random trial.
</p>
</td></tr>
<tr><td><code id="ceimOpt_+3A_handiterative">handIterative</code></td>
<td>

<p>A flag to indicate if the user wants to press enter between the each generation.
</p>
</td></tr>
<tr><td><code id="ceimOpt_+3A_verbose">verbose</code></td>
<td>

<p>A flag to indicate if the user wants to receive some convergence and distribution information printed on the screen.
</p>
</td></tr>
<tr><td><code id="ceimOpt_+3A_plotresultdistribution">plotResultDistribution</code></td>
<td>

<p>A flag to indicate if the user wants to see the resulting distribution of elite members (black curve), the value of the fittest member (red line) and of the average member (blue line), for each parameter.
</p>
</td></tr>
<tr><td><code id="ceimOpt_+3A_parallelversion">parallelVersion</code></td>
<td>

<p>A flag to indicate if the user wants to use all the cores in his/her computer to compute the fitness functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a simple stochastic heuristic method for optimization. It starts from a random population of points, computes the values of the function and selects a fraction of the points - the elite members. Then, based on these fittest points, it constructs a gaussian distribution, samples new random points from it, and iterates until convergence is reached (this is controlled by the epsilon parameter) or other stopping criteria is fulfilled (such as the maximum number of iterations).
</p>
<p>The method does not impose strong conditions on the function to be optimized. The function must written as an R function, but it does not need to be neither continuous, differentiable or analytic. Moreover, the method is ready for multicore processing, enabling the optimization of time-consuming functions.
</p>


<h3>Value</h3>

<p>A list that contains:
</p>
<table>
<tr><td><code>BestMember</code></td>
<td>
<p>The parameters and the fitness value of the best member.</p>
</td></tr>
<tr><td><code>Convergence</code></td>
<td>
<p>A boolean indicating if the method reached convergence.</p>
</td></tr>
<tr><td><code>Criteria</code></td>
<td>
<p>Stopping criterion.</p>
</td></tr>
<tr><td><code>Iterations</code></td>
<td>
<p>The amount of iterations.</p>
</td></tr>
<tr><td><code>EliteMembers</code></td>
<td>
<p>The parameters and fitness values of the elite members at the last iteration.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alberto Krone-Martins
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Solve a simple optimization problem and shows the results
po &lt;- ceimOpt(OptimFunction=function(x){(x[1]+1)^2+(x[2]+2)^2}, maxIter=100, epsilon=0.3, 
      nParams=2)
plotEliteDistrib(po$EliteMembers)
rm(po)

# A harder problem in 1D
po &lt;- ceimOpt(OptimFunction="testFunOptimization", maxIter=10, epsilon=0.3, 
      nParams=1, verbose=TRUE)
dev.new()
xx &lt;- seq(-10,10,by=0.01)
plot(xx, testFunOptimization(xx), type="l", xlab="x", ylab="Value")
points(po$BestMember[1], po$BestMember[2], col="red")
rm(list=c('xx','po'))

# A harder problem in 2D
po &lt;- ceimOpt(OptimFunction="testFunOptimization2d", maxIter=20, epsilon=0.3, 
      nParams=2, verbose=TRUE)
dev.new()
xx &lt;- seq(-10,10,by=0.1)
yy &lt;- seq(-10,10,by=0.1)
zz &lt;- matrix(nrow=length(yy), ncol=length(xx))
for(i in 1:length(xx)){
    for(j in 1:length(yy)){
        zz[i,j] &lt;- testFunOptimization2d( c(xx[i],yy[j]) )
    }
}
image(xx,yy,zz, col=gray((50:100)/100), xlab="x", ylab="y")
contour(xx,yy,zz, add=TRUE)
points(po$BestMember[1], po$BestMember[2], col="red", pch=19, cex=0.5)
rm(list=c('xx','yy','zz'))

# Example of multicore processing
slowFunction &lt;- function(x) { 
  p&lt;-runif(50000)
  return((x+3)^2)
} 
system.time(po &lt;- ceimOpt(OptimFunction="slowFunction", maxIter=10,
    Ntot=100, epsilon=0.3, nParams=1, verbose=FALSE, parallel=FALSE))
print(po$BestMember)
system.time(po &lt;- ceimOpt(OptimFunction="slowFunction", maxIter=10,
    Ntot=100, epsilon=0.3, nParams=1, verbose=FALSE, parallel=TRUE))
print(po$BestMember)
rm(po)
</code></pre>

<hr>
<h2 id='enforceDomainOnParameters'>
Enforce domain boundaries
</h2><span id='topic+enforceDomainOnParameters'></span>

<h3>Description</h3>

<p>A small function to assure that the domains are respected during the optimization process. If any of them not respected, the ofending parameters are replaced by the value of the nearest border.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enforceDomainOnParameters(paramsArray, domain)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enforceDomainOnParameters_+3A_paramsarray">paramsArray</code></td>
<td>

<p>The array with the parameters to check.
</p>
</td></tr>
<tr><td><code id="enforceDomainOnParameters_+3A_domain">domain</code></td>
<td>

<p>The domain boudaries.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The parameter array, with ofending values replaced if necessary.
</p>


<h3>Author(s)</h3>

<p>Alberto Krone-Martins
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creates a random set of parameters in an interval larger than a certain domain
# and apply the enforceDomainOnParameters function and represent graphically
# the parameters before and after the function.
dev.new()
paramArr &lt;- matrix((runif(100)-0.5)/0.5*13, nrow=50)
domain &lt;- matrix(c(-10, -10, 10, 10), ncol=2)
newParamArr &lt;- enforceDomainOnParameters(paramArr, domain)
plot(paramArr[,1], paramArr[,2], xlab="x", ylab="y", main="black: input\n red: output")
points(newParamArr[,1], newParamArr[,2], col="red", pch=19, cex=0.7)
</code></pre>

<hr>
<h2 id='overPlotErrorPolygon'>
Overplot an error polygon
</h2><span id='topic+overPlotErrorPolygon'></span>

<h3>Description</h3>

<p>A simple function to overplot an error polygon around a curve. Note that the error is considered as symmetric, and exclusively on y. The polygon will be created from the coordinate tuples <code class="reqn">(x, (y - err_y))</code> and <code class="reqn">(x, (y + err_y))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overPlotErrorPolygon(x, y, err_y, col = "grey", logPlot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overPlotErrorPolygon_+3A_x">x</code></td>
<td>

<p>A vector containing the x coordinate of the data.
</p>
</td></tr>
<tr><td><code id="overPlotErrorPolygon_+3A_y">y</code></td>
<td>

<p>A vector containing the y coordinate of the data.
</p>
</td></tr>
<tr><td><code id="overPlotErrorPolygon_+3A_err_y">err_y</code></td>
<td>

<p>A vector containing the error in y.
</p>
</td></tr>
<tr><td><code id="overPlotErrorPolygon_+3A_col">col</code></td>
<td>

<p>The color that will be used for filling the polygon.
</p>
</td></tr>
<tr><td><code id="overPlotErrorPolygon_+3A_logplot">logPlot</code></td>
<td>

<p>A boolean indicating if the plot is in logscale.
</p>
</td></tr>
<tr><td><code id="overPlotErrorPolygon_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed to polygon().
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A polygon is overplotted in the active graphics device.
</p>


<h3>Author(s)</h3>

<p>Alberto Krone-Martins
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Shows a simple random curve and overplots a randomly created error bar.
dev.new()
xx &lt;- 1:10
yy &lt;- (1:10)/5 + 4 + (runif(10)-0.5)/0.5*2
plot(xx, yy, type="l", xlab="x", ylab="y", ylim=c(0,10))
err_yy &lt;- 1.5 + (runif(10)-0.5)/0.5
overPlotErrorPolygon(xx,yy,err_yy, col=rgb(0,0,1,0.3), border=NA)
</code></pre>

<hr>
<h2 id='plotEliteDistrib'>
Plot the distribution of elite members
</h2><span id='topic+plotEliteDistrib'></span>

<h3>Description</h3>

<p>A simple function to create distribution plots of the elite members after the optimization procedure. The distribution is graphically represented using a kernel density estimation. Aditionally, this function also indicates the best and average members.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotEliteDistrib(elite)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotEliteDistrib_+3A_elite">elite</code></td>
<td>

<p>A matrix containing parameters of the elite members.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graphic representation of the elite members and also of the best and average members. 
</p>


<h3>Author(s)</h3>

<p>Alberto Krone-Martins
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ceimOpt">ceimOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Solve a simple 2D problem and show the distribution of the parameters
po &lt;- ceimOpt(OptimFunction=function(x){(x[1]+1)^2+(x[2]+2)^2}, maxIter=100, 
      epsilon=0.1, nParams=2)
plotEliteDistrib(po$EliteMembers)
rm(po)
</code></pre>

<hr>
<h2 id='sortDataFrame'>
Sorting a data frame by a key
</h2><span id='topic+sortDataFrame'></span>

<h3>Description</h3>

<p>A simple function to sort a data frame based on a certain keyword. This function was posted by r-fanatic at a dzone forum (the webpage is not available anymore).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortDataFrame(x, key, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortDataFrame_+3A_x">x</code></td>
<td>

<p>The data frame to be sorted.
</p>
</td></tr>
<tr><td><code id="sortDataFrame_+3A_key">key</code></td>
<td>

<p>The key by which the data frame will be sorted.
</p>
</td></tr>
<tr><td><code id="sortDataFrame_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed to the order function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sorted data frame.
</p>


<h3>Author(s)</h3>

<p>r-fanatic
</p>


<h3>References</h3>

<p>The original webpage where r-fanatic posted the code is not available as of 3rd April 2017.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a simple data frame and order using the "B" key
ppp &lt;- data.frame(A=1:10,B=10:1)
ppp
sortDataFrame(ppp,"B")
ppp
</code></pre>

<hr>
<h2 id='testFunOptimization'>
1D test problem for RCEIM
</h2><span id='topic+testFunOptimization'></span>

<h3>Description</h3>

<p>An one-dimension problem for testing optimization methods. 
</p>
<p>This function was created for demonstrating the RCEIM package. It has the form:
</p>

<p>f(x) = exp(-((x - 2)^2)) + 0.9 * exp(-((x + 2)^2)) + 0.5 * sin(8*x) + 0.25 * cos(2*x)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testFunOptimization(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testFunOptimization_+3A_x">x</code></td>
<td>
<p>The point where the function is computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the function at x. 
</p>


<h3>Author(s)</h3>

<p>Alberto Krone-Martins
</p>


<h3>See Also</h3>

<p><code><a href="#topic+testFunOptimization2d">testFunOptimization2d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a graphical representation of the problem with a line plot
dev.new()
xx &lt;- seq(-10,10,by=0.01) 
plot(xx, testFunOptimization(xx), type="l", xlab="x", ylab="Value")
rm(list=c('xx'))
</code></pre>

<hr>
<h2 id='testFunOptimization2d'>
2D test problem for RCEIM
</h2><span id='topic+testFunOptimization2d'></span>

<h3>Description</h3>

<p>A two-dimensional problem for testing optimization methods. 
</p>
<p>This function was created for demonstrating the RCEIM package. It has the form:
</p>




<p>f(x_1,x_2) = ((x_1-4)^2 + (x_2+2)^2)/50 - ((x_1+2)^2 + (x_2+4)^2)/90 
-exp(-(x_1-2)^2) - 0.9*exp(-(x_2+2)^2) - 0.5*sin(8*x_1) - 0.25*cos(2*x_2)
+0.25*sin(x_1*x_2/2) + 0.5*cos(x_2*x_1/2.5)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testFunOptimization2d(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testFunOptimization2d_+3A_x">x</code></td>
<td>
<p>a vector with the point where the function is computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the function at the requested point (x_1, x_2).
</p>


<h3>Author(s)</h3>

<p>Alberto Krone-Martins
</p>


<h3>See Also</h3>

<p><code><a href="#topic+testFunOptimization">testFunOptimization</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a graphical representation of the problem with a contour plot
dev.new()
xx &lt;- seq(-10,10,by=0.1)
yy &lt;- seq(-10,10,by=0.1)
zz &lt;- matrix(nrow=length(yy), ncol=length(xx))
for(i in 1:length(xx)){
	for(j in 1:length(yy)){
		zz[i,j] &lt;- testFunOptimization2d( c(xx[i],yy[j]) )
	}
}
image(xx,yy,zz, col=gray((50:100)/100), xlab="x", ylab="y")
contour(xx,yy,zz, add=TRUE)
rm(list=c('xx','yy','zz'))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
