<!DOCTYPE html><html><head><title>Help for package mazealls</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mazealls}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#decagon_maze'><p>decagon_maze .</p></a></li>
<li><a href='#dodecagon_maze'><p>dodecagon_maze .</p></a></li>
<li><a href='#eq_triangle_maze'><p>eq_triangle_maze .</p></a></li>
<li><a href='#hexaflake_maze'><p>hexaflake_maze .</p></a></li>
<li><a href='#hexagon_maze'><p>hexagon_maze .</p></a></li>
<li><a href='#holey_line'><p>holey_line .</p></a></li>
<li><a href='#holey_path'><p>holey_path .</p></a></li>
<li><a href='#iso_trapezoid_maze'><p>iso_trapezoid_maze .</p></a></li>
<li><a href='#koch_maze'><p>koch_maze .</p></a></li>
<li><a href='#mazealls'><p>generate recursive mazes</p></a></li>
<li><a href='#mazealls-NEWS'><p>News for package 'mazealls':</p></a></li>
<li><a href='#octagon_maze'><p>octagon_maze .</p></a></li>
<li><a href='#parallelogram_maze'><p>parallelogram_maze .</p></a></li>
<li><a href='#sierpinski_carpet_maze'><p>sierpinski_carpet_maze .</p></a></li>
<li><a href='#sierpinski_maze'><p>sierpinski_maze .</p></a></li>
<li><a href='#sierpinski_trapezoid_maze'><p>sierpinski_trapezoid_maze .</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Maintainer:</td>
<td>Steven E. Pav &lt;shabbychef@gmail.com&gt;</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-12-11</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Generate Recursive Mazes</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/shabbychef/mazealls/issues">https://github.com/shabbychef/mazealls/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Supports the generation of parallelogram, equilateral
    triangle, regular hexagon, isosceles trapezoid, Koch snowflake,
    'hexaflake', Sierpinski triangle, Sierpinski carpet and Sierpinski
    trapezoid mazes via 'TurtleGraphics'. Mazes are generated by the recursive method:
    the domain is divided into sub-domains in which mazes are generated,
    then dividing lines with holes are drawn between them, see
    J. Buck, Recursive Division, <a href="http://weblog.jamisbuck.org/2011/1/12/maze-generation-recursive-division-algorithm">http://weblog.jamisbuck.org/2011/1/12/maze-generation-recursive-division-algorithm</a>.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>TurtleGraphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/shabbychef/mazealls">https://github.com/shabbychef/mazealls</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'decagon_maze.r' 'dodecagon_maze.r' 'eq_triangle_maze.r'
'hexaflake_maze.r' 'hexagon_maze.r' 'holey_line.r'
'holey_path.r' 'iso_trapezoid_maze.r' 'koch_maze.r'
'mazealls.r' 'octagon_maze.r' 'parallelogram_maze.r'
'sierpinski_carpet_maze.r' 'sierpinski_maze.r'
'sierpinski_trapezoid_maze.r' 'utils.r'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-12-12 06:34:19 UTC; root</td>
</tr>
<tr>
<td>Author:</td>
<td>Steven E. Pav <a href="https://orcid.org/0000-0002-4197-6195"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-12-12 06:49:44 UTC</td>
</tr>
</table>
<hr>
<h2 id='decagon_maze'>decagon_maze .</h2><span id='topic+decagon_maze'></span>

<h3>Description</h3>

<p>Draw a regular decagon maze, with each side consisting of
of <code class="reqn">2^{depth}</code> pieces of length <code>unit_len</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decagon_maze(depth, unit_len = 4L, clockwise = TRUE,
  start_from = c("midpoint", "corner"), method = c("five_flower"),
  draw_boundary = FALSE, num_boundary_holes = 2, boundary_lines = TRUE,
  boundary_holes = NULL, boundary_hole_color = NULL,
  boundary_hole_locations = NULL, boundary_hole_arrows = FALSE,
  end_side = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decagon_maze_+3A_depth">depth</code></td>
<td>
<p>the depth of recursion. This controls the side length.</p>
</td></tr>
<tr><td><code id="decagon_maze_+3A_unit_len">unit_len</code></td>
<td>
<p>the unit length in graph coordinates. This controls
the width of the &lsquo;holes&rsquo; in the boundary lines and
generally controls the spacing of mazes.</p>
</td></tr>
<tr><td><code id="decagon_maze_+3A_clockwise">clockwise</code></td>
<td>
<p>whether to draw clockwise.</p>
</td></tr>
<tr><td><code id="decagon_maze_+3A_start_from">start_from</code></td>
<td>
<p>whether to start from the midpoint of the first side
of a maze, or from the corner facing the first side.</p>
</td></tr>
<tr><td><code id="decagon_maze_+3A_method">method</code></td>
<td>
<p>there are a few ways to recursively draw an decagon. 
The following values are acceptable:
</p>

<dl>
<dt>five_flower</dt><dd><p>Dissects the decagon as &lsquo;flower&rsquo; of five rhombuses in the center, and
another five surrounding them.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="decagon_maze_+3A_draw_boundary">draw_boundary</code></td>
<td>
<p>a boolean indicating whether a final boundary shall be
drawn around the maze.</p>
</td></tr>
<tr><td><code id="decagon_maze_+3A_num_boundary_holes">num_boundary_holes</code></td>
<td>
<p>the number of boundary sides which should be
randomly selected to have holes. Note that the <code>boundary_holes</code>
parameter takes precedence.</p>
</td></tr>
<tr><td><code id="decagon_maze_+3A_boundary_lines">boundary_lines</code></td>
<td>
<p>indicates which of the sides of the maze
shall have drawn boundary lines. Can be a logical array indicating
which sides shall have lines, or a numeric array, giving the
index of sides that shall have lines.</p>
</td></tr>
<tr><td><code id="decagon_maze_+3A_boundary_holes">boundary_holes</code></td>
<td>
<p>an array indicating which of the boundary lines
have holes. If <code>NULL</code>, then boundary holes are randomly selected
by the <code>num_boundary_holes</code> parameter. If numeric, indicates
which sides of the maze shall have holes. If a boolean array, indicates
which of the sides shall have holes. These forms are recycled
if needed. See <code><a href="#topic+holey_path">holey_path</a></code>. Note that if no line
is drawn, no hole can be drawn either.</p>
</td></tr>
<tr><td><code id="decagon_maze_+3A_boundary_hole_color">boundary_hole_color</code></td>
<td>
<p>the color of boundary holes. A value of
<code>NULL</code> indicates no colored holes. See <code><a href="#topic+holey_path">holey_path</a></code>
for more details. Can be an array of colors, or colors and the 
value <code>'clear'</code>, which stands in for <code>NULL</code> to
indicate no filled hole to be drawn.</p>
</td></tr>
<tr><td><code id="decagon_maze_+3A_boundary_hole_locations">boundary_hole_locations</code></td>
<td>
<p>the &lsquo;locations&rsquo; of the boundary holes
within each boundary segment.
A value of <code>NULL</code> indicates the code may randomly choose, as is
the default.
May be a numeric array. A positive value up to the side length is
interpreted as the location to place the boundary hole.
A negative value is interpreted as counting down from the side
length plus 1. A value of zero corresponds to allowing the 
code to pick the location within a segment.
A value of <code>NA</code> may cause an error.</p>
</td></tr>
<tr><td><code id="decagon_maze_+3A_boundary_hole_arrows">boundary_hole_arrows</code></td>
<td>
<p>a boolean or boolean array indicating whether to draw
perpendicular double arrows at the boundary holes, as a visual guide. These
can be useful for locating the entry and exit points of a maze.</p>
</td></tr>
<tr><td><code id="decagon_maze_+3A_end_side">end_side</code></td>
<td>
<p>the number of the side to end on. A value of
1 corresponds to the starting side, while higher numbers
correspond to the drawn side of the figure in the canonical order
(that is, the order induced by the <code>clockwise</code> parameter).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draws a maze in a regular decagon. Dissects the decagon
into rhombuses.
</p>

<p><img src="../help/figures/simple-decagon-1.png" width="100%" alt="Figure: five flower decagon" />


</p>


<h3>Value</h3>

<p>nothing; the function is called for side effects only, though in
the future this might return information about the drawn boundary of
the shape.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
turtle_init(2200,2200,mode='clip')
turtle_hide()
turtle_up()
turtle_do({
  turtle_setpos(25,1100)
  turtle_setangle(0)
	decagon_maze(5,21,draw_boundary=TRUE,boundary_holes=c(1,6))
})

## End(Not run)
</code></pre>

<hr>
<h2 id='dodecagon_maze'>dodecagon_maze .</h2><span id='topic+dodecagon_maze'></span>

<h3>Description</h3>

<p>Draw a regular dodecagon maze, with each side consisting of
of <code class="reqn">2^{depth}</code> pieces of length <code>unit_len</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dodecagon_maze(depth, unit_len = 4L, clockwise = TRUE,
  start_from = c("midpoint", "corner"), method = c("hex_ring"),
  draw_boundary = FALSE, num_boundary_holes = 2, boundary_lines = TRUE,
  boundary_holes = NULL, boundary_hole_color = NULL,
  boundary_hole_locations = NULL, boundary_hole_arrows = FALSE,
  end_side = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dodecagon_maze_+3A_depth">depth</code></td>
<td>
<p>the depth of recursion. This controls the side length.</p>
</td></tr>
<tr><td><code id="dodecagon_maze_+3A_unit_len">unit_len</code></td>
<td>
<p>the unit length in graph coordinates. This controls
the width of the &lsquo;holes&rsquo; in the boundary lines and
generally controls the spacing of mazes.</p>
</td></tr>
<tr><td><code id="dodecagon_maze_+3A_clockwise">clockwise</code></td>
<td>
<p>whether to draw clockwise.</p>
</td></tr>
<tr><td><code id="dodecagon_maze_+3A_start_from">start_from</code></td>
<td>
<p>whether to start from the midpoint of the first side
of a maze, or from the corner facing the first side.</p>
</td></tr>
<tr><td><code id="dodecagon_maze_+3A_method">method</code></td>
<td>
<p>there are a few ways to recursively draw an decagon. 
The following values are acceptable:
</p>

<dl>
<dt>hex_ring</dt><dd><p>A regular hexagon maze in the center is drawn, with a 
ring of alternating squares and equilateral triangle mazes around it.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="dodecagon_maze_+3A_draw_boundary">draw_boundary</code></td>
<td>
<p>a boolean indicating whether a final boundary shall be
drawn around the maze.</p>
</td></tr>
<tr><td><code id="dodecagon_maze_+3A_num_boundary_holes">num_boundary_holes</code></td>
<td>
<p>the number of boundary sides which should be
randomly selected to have holes. Note that the <code>boundary_holes</code>
parameter takes precedence.</p>
</td></tr>
<tr><td><code id="dodecagon_maze_+3A_boundary_lines">boundary_lines</code></td>
<td>
<p>indicates which of the sides of the maze
shall have drawn boundary lines. Can be a logical array indicating
which sides shall have lines, or a numeric array, giving the
index of sides that shall have lines.</p>
</td></tr>
<tr><td><code id="dodecagon_maze_+3A_boundary_holes">boundary_holes</code></td>
<td>
<p>an array indicating which of the boundary lines
have holes. If <code>NULL</code>, then boundary holes are randomly selected
by the <code>num_boundary_holes</code> parameter. If numeric, indicates
which sides of the maze shall have holes. If a boolean array, indicates
which of the sides shall have holes. These forms are recycled
if needed. See <code><a href="#topic+holey_path">holey_path</a></code>. Note that if no line
is drawn, no hole can be drawn either.</p>
</td></tr>
<tr><td><code id="dodecagon_maze_+3A_boundary_hole_color">boundary_hole_color</code></td>
<td>
<p>the color of boundary holes. A value of
<code>NULL</code> indicates no colored holes. See <code><a href="#topic+holey_path">holey_path</a></code>
for more details. Can be an array of colors, or colors and the 
value <code>'clear'</code>, which stands in for <code>NULL</code> to
indicate no filled hole to be drawn.</p>
</td></tr>
<tr><td><code id="dodecagon_maze_+3A_boundary_hole_locations">boundary_hole_locations</code></td>
<td>
<p>the &lsquo;locations&rsquo; of the boundary holes
within each boundary segment.
A value of <code>NULL</code> indicates the code may randomly choose, as is
the default.
May be a numeric array. A positive value up to the side length is
interpreted as the location to place the boundary hole.
A negative value is interpreted as counting down from the side
length plus 1. A value of zero corresponds to allowing the 
code to pick the location within a segment.
A value of <code>NA</code> may cause an error.</p>
</td></tr>
<tr><td><code id="dodecagon_maze_+3A_boundary_hole_arrows">boundary_hole_arrows</code></td>
<td>
<p>a boolean or boolean array indicating whether to draw
perpendicular double arrows at the boundary holes, as a visual guide. These
can be useful for locating the entry and exit points of a maze.</p>
</td></tr>
<tr><td><code id="dodecagon_maze_+3A_end_side">end_side</code></td>
<td>
<p>the number of the side to end on. A value of
1 corresponds to the starting side, while higher numbers
correspond to the drawn side of the figure in the canonical order
(that is, the order induced by the <code>clockwise</code> parameter).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draws a maze in a regular dodecagon. Currently dissects the maze
into a hexagon and a ring of squares and equilateral triangles.
</p>

<p><img src="../help/figures/simple-dodecagon-1.png" width="100%" alt="Figure: hex ring dodecagon" />


</p>


<h3>Value</h3>

<p>nothing; the function is called for side effects only, though in
the future this might return information about the drawn boundary of
the shape.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
turtle_init(2200,2200,mode='clip')
turtle_hide()
turtle_up()
turtle_do({
  turtle_setpos(25,1100)
  turtle_setangle(0)
	 dodecagon_maze(5,21,draw_boundary=TRUE,boundary_holes=c(1,6))
})

## End(Not run)
</code></pre>

<hr>
<h2 id='eq_triangle_maze'>eq_triangle_maze .</h2><span id='topic+eq_triangle_maze'></span>

<h3>Description</h3>

<p>Recursively draw an equilateral triangle maze, with sides consisting
of <code class="reqn">2^{depth}</code> pieces of length <code>unit_len</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eq_triangle_maze(depth, unit_len, clockwise = TRUE,
  method = c("stack_trapezoids", "triangles", "uniform", "two_ears", "random",
  "hex_and_three", "shave_all", "shave"), start_from = c("midpoint",
  "corner"), boustro = c(1, 1), draw_boundary = FALSE,
  num_boundary_holes = 2, boundary_lines = TRUE, boundary_holes = NULL,
  boundary_hole_color = NULL, boundary_hole_locations = NULL,
  boundary_hole_arrows = FALSE, end_side = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eq_triangle_maze_+3A_depth">depth</code></td>
<td>
<p>the depth of recursion. This controls the side length.</p>
</td></tr>
<tr><td><code id="eq_triangle_maze_+3A_unit_len">unit_len</code></td>
<td>
<p>the unit length in graph coordinates. This controls
the width of the &lsquo;holes&rsquo; in the boundary lines and
generally controls the spacing of mazes.</p>
</td></tr>
<tr><td><code id="eq_triangle_maze_+3A_clockwise">clockwise</code></td>
<td>
<p>whether to draw clockwise.</p>
</td></tr>
<tr><td><code id="eq_triangle_maze_+3A_method">method</code></td>
<td>
<p>there are many ways to recursive draw a triangle. The
following values are acceptable:
</p>

<dl>
<dt>stack_trapezoids</dt><dd><p>Isosceles trapezoids are stacked on top of each
other, with the long sides aligned to the first side.</p>
</dd>
<dt>triangles</dt><dd><p>The triangle maze is recursively drawn as four
equilateral triangle mazes of half size, each connected to their neighbors.</p>
</dd>
<dt>uniform</dt><dd><p>The triangle maze is recursively drawn as four
equilateral triangle uniform mazes of half size, each connected to their
neighbors.</p>
</dd>
<dt>two_ears</dt><dd><p>The triangle maze is recursively drawn as a large
parallelogram maze connected to two two half size equilateral triangle
mazes, which are &lsquo;ears&rsquo;.</p>
</dd>
<dt>random</dt><dd><p>A method is randomly selected from the available methods.</p>
</dd>
<dt>hex_and_three</dt><dd><p>When <code class="reqn">2^{depth}</code> is a power of three, the triangle
is drawn as a hexagonal maze of one third size connected to three
equilateral triangular mazes, each one third size, at the corners.</p>
</dd>
<dt>shave</dt><dd><p>Here <code class="reqn">2^{depth}</code> can be arbitrary. A single line is
&lsquo;shaved&rsquo; off the triangle, connected to another equilateral triangle of
length one less is drawn next to it. This sub triangle will either be
drawn using a &lsquo;hex_and_three&rsquo;, &lsquo;random&rsquo;, or &lsquo;shave&rsquo;
methods, in decreasing order of preference, depending on the side length.</p>
</dd>
<dt>shave_all</dt><dd><p>Here <code class="reqn">2^{depth}</code> can be arbitrary. A single line is
&lsquo;shaved&rsquo; off the triangle, connected to another equilateral triangle of
length one less is drawn next to it. This sub triangle will also be drawn
using the &lsquo;shave_all&rsquo; method. These mazes tend to look boring, and
are not recommended.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="eq_triangle_maze_+3A_start_from">start_from</code></td>
<td>
<p>whether to start from the midpoint of the first side
of a maze, or from the corner facing the first side.</p>
</td></tr>
<tr><td><code id="eq_triangle_maze_+3A_boustro">boustro</code></td>
<td>
<p>an array of two values, which help determine
the location of holes in internal lines of length
<code>height</code>. The default value, <code>c(1,1)</code> results in 
uniform selection. Otherwise the location of holes are chosen
with probability proportional to a beta density with the
ordered elements of <code>boustro</code> set as 
<code>shape1</code> and <code>shape2</code>.
In sub mazes, this parameter is reversed, which
can lead to &lsquo;boustrophedonic&rsquo; mazes. It is suggested
that the sum of values not exceed 40, as otherwise the location 
of internal holes may be not widely dispersed from the mean
value.</p>
</td></tr>
<tr><td><code id="eq_triangle_maze_+3A_draw_boundary">draw_boundary</code></td>
<td>
<p>a boolean indicating whether a final boundary shall be
drawn around the maze.</p>
</td></tr>
<tr><td><code id="eq_triangle_maze_+3A_num_boundary_holes">num_boundary_holes</code></td>
<td>
<p>the number of boundary sides which should be
randomly selected to have holes. Note that the <code>boundary_holes</code>
parameter takes precedence.</p>
</td></tr>
<tr><td><code id="eq_triangle_maze_+3A_boundary_lines">boundary_lines</code></td>
<td>
<p>indicates which of the sides of the maze
shall have drawn boundary lines. Can be a logical array indicating
which sides shall have lines, or a numeric array, giving the
index of sides that shall have lines.</p>
</td></tr>
<tr><td><code id="eq_triangle_maze_+3A_boundary_holes">boundary_holes</code></td>
<td>
<p>an array indicating which of the boundary lines
have holes. If <code>NULL</code>, then boundary holes are randomly selected
by the <code>num_boundary_holes</code> parameter. If numeric, indicates
which sides of the maze shall have holes. If a boolean array, indicates
which of the sides shall have holes. These forms are recycled
if needed. See <code><a href="#topic+holey_path">holey_path</a></code>. Note that if no line
is drawn, no hole can be drawn either.</p>
</td></tr>
<tr><td><code id="eq_triangle_maze_+3A_boundary_hole_color">boundary_hole_color</code></td>
<td>
<p>the color of boundary holes. A value of
<code>NULL</code> indicates no colored holes. See <code><a href="#topic+holey_path">holey_path</a></code>
for more details. Can be an array of colors, or colors and the 
value <code>'clear'</code>, which stands in for <code>NULL</code> to
indicate no filled hole to be drawn.</p>
</td></tr>
<tr><td><code id="eq_triangle_maze_+3A_boundary_hole_locations">boundary_hole_locations</code></td>
<td>
<p>the &lsquo;locations&rsquo; of the boundary holes
within each boundary segment.
A value of <code>NULL</code> indicates the code may randomly choose, as is
the default.
May be a numeric array. A positive value up to the side length is
interpreted as the location to place the boundary hole.
A negative value is interpreted as counting down from the side
length plus 1. A value of zero corresponds to allowing the 
code to pick the location within a segment.
A value of <code>NA</code> may cause an error.</p>
</td></tr>
<tr><td><code id="eq_triangle_maze_+3A_boundary_hole_arrows">boundary_hole_arrows</code></td>
<td>
<p>a boolean or boolean array indicating whether to draw
perpendicular double arrows at the boundary holes, as a visual guide. These
can be useful for locating the entry and exit points of a maze.</p>
</td></tr>
<tr><td><code id="eq_triangle_maze_+3A_end_side">end_side</code></td>
<td>
<p>the number of the side to end on. A value of
1 corresponds to the starting side, while higher numbers
correspond to the drawn side of the figure in the canonical order
(that is, the order induced by the <code>clockwise</code> parameter).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draws a maze in an equilateral triangle, starting from the midpoint
of the first side (or the corner before the first side via the
<code>start_from</code> option). A number of different recursive methods
are supported, dividing the triangle into sub-triangles, or hexagons,
parallelogram and triangles, and so on.  Optionally draws boundaries
around the triangle, with control over which sides have lines and
holes. Side length of triangles consists of <code class="reqn">2^{depth}</code> segments
of length <code>unit_len</code>, though <code>depth</code> may be non-integral.
A number of different methods are supported.
</p>
<p>For <code>method='uniform'</code>:
</p>

<p><img src="../help/figures/eq-tri-uniform-1.png" width="100%" alt="Figure: uniform" />


</p>
<p>For <code>method='triangles'</code>:
</p>

<p><img src="../help/figures/eq-tri-four-tri-1.png" width="100%" alt="Figure: triangles" />


</p>
<p>For <code>method='two_ears'</code>:
</p>

<p><img src="../help/figures/eq-tri-two-ears-1.png" width="100%" alt="Figure: two ears" />


</p>
<p>For <code>method='hex_and_three'</code>:
</p>

<p><img src="../help/figures/eq-tri-hex-and-three-1.png" width="100%" alt="Figure: hex and three triangles" />


</p>
<p>For <code>method='shave'</code>:
</p>

<p><img src="../help/figures/eq-tri-shave-1.png" width="100%" alt="Figure: shave" />


</p>
<p>For <code>method='shave_all'</code>:
</p>

<p><img src="../help/figures/eq-tri-shave-all-1.png" width="100%" alt="Figure: shave all" />


</p>


<h3>Value</h3>

<p>nothing; the function is called for side effects only, though in
the future this might return information about the drawn boundary of
the shape.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TurtleGraphics)
turtle_init(2500,2500)
turtle_hide() 
turtle_up()
turtle_do({
  turtle_left(90)
  turtle_forward(40)
  turtle_right(90)
  eq_triangle_maze(depth=3,12,clockwise=FALSE,method='two_ears',draw_boundary=TRUE)
})

turtle_init(2500,2500)
turtle_hide() 
turtle_up()
turtle_do({
  turtle_left(90)
  turtle_forward(40)
  turtle_right(90)
  eq_triangle_maze(depth=3,12,clockwise=FALSE,method='random',draw_boundary=TRUE)
})

# join two together, with green holes on opposite sides
turtle_init(2500,2500)
turtle_hide() 
turtle_up()
turtle_do({
  turtle_left(90)
  turtle_forward(40)
  turtle_right(90)
  eq_triangle_maze(depth=3,12,clockwise=TRUE,method='two_ears',draw_boundary=TRUE,
    boundary_holes=c(1,3),boundary_hole_color=c('clear','clear','green'))
  eq_triangle_maze(depth=3,12,clockwise=FALSE,method='uniform',draw_boundary=TRUE,
    boundary_lines=c(2,3),boundary_holes=c(2),boundary_hole_color='green')
})

# non integral depths also possible:
turtle_init(2500,2500)
turtle_hide() 
turtle_up()
turtle_do({
  turtle_left(90)
  turtle_forward(40)
  turtle_right(90)
  eq_triangle_maze(depth=log2(27),12,clockwise=TRUE,method='hex_and_three',draw_boundary=TRUE,
    boundary_holes=c(1,3),boundary_hole_color=c('clear','clear','green'))
  eq_triangle_maze(depth=log2(27),12,clockwise=FALSE,method='shave',draw_boundary=TRUE,
    boundary_lines=c(2,3),boundary_holes=c(2),boundary_hole_color='green')
})
</code></pre>

<hr>
<h2 id='hexaflake_maze'>hexaflake_maze .</h2><span id='topic+hexaflake_maze'></span>

<h3>Description</h3>

<p>Recursively draw a hexaflake maze, a cross between a Koch snowflake
and a Sierpinski triangle. The outer part of the flake consists of 
a hexagon of side length <code class="reqn">3^{depth}</code> pieces of length
<code>unit_len</code>. The &lsquo;inner&rsquo; and &lsquo;outer&rsquo; pieces of
the flake are mazes drawn in different colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hexaflake_maze(depth, unit_len, clockwise = TRUE, start_from = c("midpoint",
  "corner"), color1 = "black", color2 = "gray40", draw_boundary = FALSE,
  num_boundary_holes = 2, boundary_lines = TRUE, boundary_holes = NULL,
  boundary_hole_color = NULL, boundary_hole_locations = NULL,
  boundary_hole_arrows = FALSE, end_side = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hexaflake_maze_+3A_depth">depth</code></td>
<td>
<p>the depth of recursion. This controls the side length.
Should be an integer.</p>
</td></tr>
<tr><td><code id="hexaflake_maze_+3A_unit_len">unit_len</code></td>
<td>
<p>the unit length in graph coordinates. This controls
the width of the &lsquo;holes&rsquo; in the boundary lines and
generally controls the spacing of mazes.</p>
</td></tr>
<tr><td><code id="hexaflake_maze_+3A_clockwise">clockwise</code></td>
<td>
<p>whether to draw clockwise.</p>
</td></tr>
<tr><td><code id="hexaflake_maze_+3A_start_from">start_from</code></td>
<td>
<p>whether to start from the midpoint of the first side
of a maze, or from the corner facing the first side.</p>
</td></tr>
<tr><td><code id="hexaflake_maze_+3A_color1">color1</code></td>
<td>
<p>The dominant color of the maze.</p>
</td></tr>
<tr><td><code id="hexaflake_maze_+3A_color2">color2</code></td>
<td>
<p>The negative color of the maze.</p>
</td></tr>
<tr><td><code id="hexaflake_maze_+3A_draw_boundary">draw_boundary</code></td>
<td>
<p>a boolean indicating whether a final boundary shall be
drawn around the maze.</p>
</td></tr>
<tr><td><code id="hexaflake_maze_+3A_num_boundary_holes">num_boundary_holes</code></td>
<td>
<p>the number of boundary sides which should be
randomly selected to have holes. Note that the <code>boundary_holes</code>
parameter takes precedence.</p>
</td></tr>
<tr><td><code id="hexaflake_maze_+3A_boundary_lines">boundary_lines</code></td>
<td>
<p>indicates which of the sides of the maze
shall have drawn boundary lines. Can be a logical array indicating
which sides shall have lines, or a numeric array, giving the
index of sides that shall have lines.</p>
</td></tr>
<tr><td><code id="hexaflake_maze_+3A_boundary_holes">boundary_holes</code></td>
<td>
<p>an array indicating which of the boundary lines
have holes. If <code>NULL</code>, then boundary holes are randomly selected
by the <code>num_boundary_holes</code> parameter. If numeric, indicates
which sides of the maze shall have holes. If a boolean array, indicates
which of the sides shall have holes. These forms are recycled
if needed. See <code><a href="#topic+holey_path">holey_path</a></code>. Note that if no line
is drawn, no hole can be drawn either.</p>
</td></tr>
<tr><td><code id="hexaflake_maze_+3A_boundary_hole_color">boundary_hole_color</code></td>
<td>
<p>the color of boundary holes. A value of
<code>NULL</code> indicates no colored holes. See <code><a href="#topic+holey_path">holey_path</a></code>
for more details. Can be an array of colors, or colors and the 
value <code>'clear'</code>, which stands in for <code>NULL</code> to
indicate no filled hole to be drawn.</p>
</td></tr>
<tr><td><code id="hexaflake_maze_+3A_boundary_hole_locations">boundary_hole_locations</code></td>
<td>
<p>the &lsquo;locations&rsquo; of the boundary holes
within each boundary segment.
A value of <code>NULL</code> indicates the code may randomly choose, as is
the default.
May be a numeric array. A positive value up to the side length is
interpreted as the location to place the boundary hole.
A negative value is interpreted as counting down from the side
length plus 1. A value of zero corresponds to allowing the 
code to pick the location within a segment.
A value of <code>NA</code> may cause an error.</p>
</td></tr>
<tr><td><code id="hexaflake_maze_+3A_boundary_hole_arrows">boundary_hole_arrows</code></td>
<td>
<p>a boolean or boolean array indicating whether to draw
perpendicular double arrows at the boundary holes, as a visual guide. These
can be useful for locating the entry and exit points of a maze.</p>
</td></tr>
<tr><td><code id="hexaflake_maze_+3A_end_side">end_side</code></td>
<td>
<p>the number of the side to end on. A value of
1 corresponds to the starting side, while higher numbers
correspond to the drawn side of the figure in the canonical order
(that is, the order induced by the <code>clockwise</code> parameter).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draws a maze in an Hexflake. Relies on generation of hexagonal and
triangular mazes for the internals. An internal hexagon and
six surrounding hexagons are recursively drawn as hexaflakes,
connected by 12 equilateral triangles, drawn in the secondary color:
</p>

<p><img src="../help/figures/hexaflake-1.png" width="100%" alt="Figure: Hexaflake maze" />


</p>


<h3>Value</h3>

<p>nothing; the function is called for side effects only, though in
the future this might return information about the drawn boundary of
the shape.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sierpinski_trapezoid_maze">sierpinski_trapezoid_maze</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TurtleGraphics)
turtle_init(1000,1000,mode='clip')
turtle_hide()
turtle_do({
  turtle_setpos(50,500)
  turtle_setangle(0)
  hexaflake_maze(depth=3,unit_len=10,draw_boundary=TRUE,color2='green')
})

</code></pre>

<hr>
<h2 id='hexagon_maze'>hexagon_maze .</h2><span id='topic+hexagon_maze'></span>

<h3>Description</h3>

<p>Recursively draw a regular hexagon, with sides consisting
of <code class="reqn">2^{depth}</code> pieces of length <code>unit_len</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hexagon_maze(depth, unit_len, clockwise = TRUE, method = c("two_trapezoids",
  "six_triangles", "three_parallelograms", "random"),
  start_from = c("midpoint", "corner"), boustro = c(1, 1),
  draw_boundary = FALSE, num_boundary_holes = 2, boundary_lines = TRUE,
  boundary_holes = NULL, boundary_hole_color = NULL,
  boundary_hole_locations = NULL, boundary_hole_arrows = FALSE,
  end_side = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hexagon_maze_+3A_depth">depth</code></td>
<td>
<p>the depth of recursion. This controls the
side length. If an integer then nice recursive mazes
are possible, but non-integral values corresponding to
log base 2 of integers are also acceptable.</p>
</td></tr>
<tr><td><code id="hexagon_maze_+3A_unit_len">unit_len</code></td>
<td>
<p>the unit length in graph coordinates. This controls
the width of the &lsquo;holes&rsquo; in the boundary lines and
generally controls the spacing of mazes.</p>
</td></tr>
<tr><td><code id="hexagon_maze_+3A_clockwise">clockwise</code></td>
<td>
<p>whether to draw clockwise.</p>
</td></tr>
<tr><td><code id="hexagon_maze_+3A_method">method</code></td>
<td>
<p>there are many ways to recursive draw an isosceles
trapezoid.  The following values are acceptable:
</p>

<dl>
<dt>two_trapezoids</dt><dd><p>Two isosceles trapezoids are placed next to each
other, with a holey line between them.</p>
</dd>
<dt>size_triangles</dt><dd><p>Six equilateral triangles are packed together, with
five holey lines and one solid line.</p>
</dd>
<dt>three_parallelograms</dt><dd><p>Three parallelograms are packed together,
with two holey lines and one solid line between them.</p>
</dd>
<dt>random</dt><dd><p>A method is chosen uniformly at random.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="hexagon_maze_+3A_start_from">start_from</code></td>
<td>
<p>whether to start from the midpoint of the first side
of a maze, or from the corner facing the first side.</p>
</td></tr>
<tr><td><code id="hexagon_maze_+3A_boustro">boustro</code></td>
<td>
<p>an array of two values, which help determine
the location of holes in internal lines of length
<code>height</code>. The default value, <code>c(1,1)</code> results in 
uniform selection. Otherwise the location of holes are chosen
with probability proportional to a beta density with the
ordered elements of <code>boustro</code> set as 
<code>shape1</code> and <code>shape2</code>.
In sub mazes, this parameter is reversed, which
can lead to &lsquo;boustrophedonic&rsquo; mazes. It is suggested
that the sum of values not exceed 40, as otherwise the location 
of internal holes may be not widely dispersed from the mean
value.</p>
</td></tr>
<tr><td><code id="hexagon_maze_+3A_draw_boundary">draw_boundary</code></td>
<td>
<p>a boolean indicating whether a final boundary shall be
drawn around the maze.</p>
</td></tr>
<tr><td><code id="hexagon_maze_+3A_num_boundary_holes">num_boundary_holes</code></td>
<td>
<p>the number of boundary sides which should be
randomly selected to have holes. Note that the <code>boundary_holes</code>
parameter takes precedence.</p>
</td></tr>
<tr><td><code id="hexagon_maze_+3A_boundary_lines">boundary_lines</code></td>
<td>
<p>indicates which of the sides of the maze
shall have drawn boundary lines. Can be a logical array indicating
which sides shall have lines, or a numeric array, giving the
index of sides that shall have lines.</p>
</td></tr>
<tr><td><code id="hexagon_maze_+3A_boundary_holes">boundary_holes</code></td>
<td>
<p>an array indicating which of the boundary lines
have holes. If <code>NULL</code>, then boundary holes are randomly selected
by the <code>num_boundary_holes</code> parameter. If numeric, indicates
which sides of the maze shall have holes. If a boolean array, indicates
which of the sides shall have holes. These forms are recycled
if needed. See <code><a href="#topic+holey_path">holey_path</a></code>. Note that if no line
is drawn, no hole can be drawn either.</p>
</td></tr>
<tr><td><code id="hexagon_maze_+3A_boundary_hole_color">boundary_hole_color</code></td>
<td>
<p>the color of boundary holes. A value of
<code>NULL</code> indicates no colored holes. See <code><a href="#topic+holey_path">holey_path</a></code>
for more details. Can be an array of colors, or colors and the 
value <code>'clear'</code>, which stands in for <code>NULL</code> to
indicate no filled hole to be drawn.</p>
</td></tr>
<tr><td><code id="hexagon_maze_+3A_boundary_hole_locations">boundary_hole_locations</code></td>
<td>
<p>the &lsquo;locations&rsquo; of the boundary holes
within each boundary segment.
A value of <code>NULL</code> indicates the code may randomly choose, as is
the default.
May be a numeric array. A positive value up to the side length is
interpreted as the location to place the boundary hole.
A negative value is interpreted as counting down from the side
length plus 1. A value of zero corresponds to allowing the 
code to pick the location within a segment.
A value of <code>NA</code> may cause an error.</p>
</td></tr>
<tr><td><code id="hexagon_maze_+3A_boundary_hole_arrows">boundary_hole_arrows</code></td>
<td>
<p>a boolean or boolean array indicating whether to draw
perpendicular double arrows at the boundary holes, as a visual guide. These
can be useful for locating the entry and exit points of a maze.</p>
</td></tr>
<tr><td><code id="hexagon_maze_+3A_end_side">end_side</code></td>
<td>
<p>the number of the side to end on. A value of
1 corresponds to the starting side, while higher numbers
correspond to the drawn side of the figure in the canonical order
(that is, the order induced by the <code>clockwise</code> parameter).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draws a maze in a regular hexagon, starting from the midpoint
of the first side (or the corner before the first side via the
<code>start_from</code> option). A number of different recursive methods
are supported, dividing the triangle into trapezoids, triangles
or parallelograms. Optionally draws boundaries
around the hexagon, with control over which sides have lines and
holes. Sides of the hexagon consist of <code class="reqn">2^{depth}</code> segments
of length <code>unit_len</code>, though <code>depth</code> may be non-integral.
A number of different methods are supported.
</p>
<p>For <code>method='two_trapezoids'</code>:
</p>

<p><img src="../help/figures/hex-trapezoids-1.png" width="100%" alt="Figure: two trapezoids" />


</p>
<p>For <code>method='six_trapezoids'</code>:
</p>

<p><img src="../help/figures/hex-triangles-1.png" width="100%" alt="Figure: six triangles" />


</p>
<p>For <code>method='three_trapezoids'</code>:
</p>

<p><img src="../help/figures/hex-parallelo-1.png" width="100%" alt="Figure: three parallelograms" />


</p>


<h3>Value</h3>

<p>nothing; the function is called for side effects only, though in
the future this might return information about the drawn boundary of
the shape.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TurtleGraphics)
turtle_init(2000,2000)
turtle_hide()
turtle_do({
	turtle_up()
	turtle_backward(250)
	turtle_right(90)
	turtle_forward(150)
	turtle_left(90)

	turtle_right(60)
	hexagon_maze(depth=3,12,clockwise=FALSE,method='six_triangles',
	  draw_boundary=TRUE,boundary_holes=c(1,4),boundary_hole_color='green')
})


turtle_init(2000,2000)
turtle_hide()
turtle_do({
	turtle_up()
	turtle_backward(250)
	turtle_right(90)
	turtle_forward(150)
	turtle_left(90)

	turtle_right(60)
	hexagon_maze(depth=log2(20),12,clockwise=FALSE,method='six_triangles',
	  draw_boundary=TRUE,boundary_holes=c(1,4),boundary_hole_color='green')
})


turtle_init(1000,1000)
turtle_hide()
turtle_do({
	turtle_up()
	turtle_backward(250)
	turtle_right(90)
	turtle_forward(150)
	turtle_left(90)

	turtle_right(60)
	hexagon_maze(depth=3,12,clockwise=FALSE,method='three_parallelograms',
	  draw_boundary=TRUE,boundary_holes=c(1,4),boundary_hole_color='green')
})

turtle_init(1000,1000)
turtle_hide()
turtle_do({
	hexagon_maze(depth=3,15,clockwise=TRUE,method='two_trapezoids',
	  draw_boundary=TRUE,boundary_holes=c(1,4))
	hexagon_maze(depth=3,15,clockwise=FALSE,method='two_trapezoids',
	  draw_boundary=TRUE,boundary_lines=c(2,3,4,5,6),boundary_holes=c(1,4))
})

turtle_init(1000,1000)
turtle_hide()
turtle_do({
	depth &lt;- 3
	num_segs &lt;- 2^depth
	unit_len &lt;- 8
	multiplier &lt;- -1
	hexagon_maze(depth=depth,unit_len,clockwise=FALSE,method='two_trapezoids',
	  draw_boundary=FALSE)
	for (iii in c(1:6)) {
		if (iii %in% c(1,4)) {
			holes &lt;- c(1,4) 
		} else {
			holes &lt;- c(1)
		}
		hexagon_maze(depth=depth,unit_len,clockwise=TRUE,method='two_trapezoids',
		  draw_boundary=TRUE,boundary_holes=holes)
		turtle_forward(distance=unit_len * num_segs/2)
		turtle_right((multiplier * 60) %% 360)
		turtle_forward(distance=unit_len * num_segs/2)
	}
})
</code></pre>

<hr>
<h2 id='holey_line'>holey_line .</h2><span id='topic+holey_line'></span>

<h3>Description</h3>

<p>Draws a line with a randomly selected &lsquo;hole&rsquo; in it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>holey_line(unit_len, num_segs, which_seg = NULL, go_back = FALSE,
  hole_color = NULL, hole_arrow = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="holey_line_+3A_unit_len">unit_len</code></td>
<td>
<p>the unit length in graph coordinates. This controls
the width of the &lsquo;holes&rsquo; in the boundary lines and
generally controls the spacing of mazes.</p>
</td></tr>
<tr><td><code id="holey_line_+3A_num_segs">num_segs</code></td>
<td>
<p>the total number of segments. All but one of these,
of length <code>unit_len</code> will be drawn. The other, randomly
chosen, will be a hole. If <code>num_segs</code> is one, only a hole is made,
and no line drawn.  If zero or less, no action taken.</p>
</td></tr>
<tr><td><code id="holey_line_+3A_which_seg">which_seg</code></td>
<td>
<p>optional numeric indicating which segment should
have the hole. If <code>NULL</code>, the hole segment is chosen uniformly
at random.</p>
</td></tr>
<tr><td><code id="holey_line_+3A_go_back">go_back</code></td>
<td>
<p>whether to return the turtle to starting position
when the line has been drawn.</p>
</td></tr>
<tr><td><code id="holey_line_+3A_hole_color">hole_color</code></td>
<td>
<p>the color to plot the &lsquo;hole&rsquo;. A 
<code>NULL</code> value corresponds to no drawn hole. 
See the <code><a href="grDevices.html#topic+colors">colors</a></code> function for
acceptable values.</p>
</td></tr>
<tr><td><code id="holey_line_+3A_hole_arrow">hole_arrow</code></td>
<td>
<p>a boolean or indicating whether
to draw a perpendicular arrow at a hole.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the workhorse of drawing mazes, as it
creates a maze wall with a single hole in it.
</p>


<h3>Value</h3>

<p>Returns the <code>which_seg</code> variable, the location of the hole, though typically
the function is called for side effects only.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(TurtleGraphics)
turtle_init(1000,1000,mode='clip')
turtle_hide()
y &lt;- holey_line(unit_len=20, num_segs=15)

turtle_right(90)
y &lt;- holey_line(unit_len=20, num_segs=10,hole_arrow=TRUE)

</code></pre>

<hr>
<h2 id='holey_path'>holey_path .</h2><span id='topic+holey_path'></span>

<h3>Description</h3>

<p>Make the turtle move multiple units, making turns, and possibly drawing
line segments possibly with holes in them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>holey_path(unit_len, lengths, angles, draw_line = TRUE, has_hole = FALSE,
  hole_color = NULL, hole_locations = NULL, hole_arrows = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="holey_path_+3A_unit_len">unit_len</code></td>
<td>
<p>the unit length in graph coordinates. This controls
the width of the &lsquo;holes&rsquo; in the boundary lines and
generally controls the spacing of mazes.</p>
</td></tr>
<tr><td><code id="holey_path_+3A_lengths">lengths</code></td>
<td>
<p>an array of the number of units
each part of the path. An array of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="holey_path_+3A_angles">angles</code></td>
<td>
<p>after each part of the path is
drawn, the turtle turns right by the given angle.</p>
</td></tr>
<tr><td><code id="holey_path_+3A_draw_line">draw_line</code></td>
<td>
<p>a boolean array telling whether
each part of the path is drawn at all, or whether
the turtle simply moves through that path.</p>
</td></tr>
<tr><td><code id="holey_path_+3A_has_hole">has_hole</code></td>
<td>
<p>a boolean array telling whether,
conditional on the path being drawn, it has a one unit
hole.</p>
</td></tr>
<tr><td><code id="holey_path_+3A_hole_color">hole_color</code></td>
<td>
<p>the color to plot the &lsquo;hole&rsquo;. 
A value <code>NULL</code> or <code>'clear'</code> corresponds to no 
drawn hole, the latter being useful for mixing drawn colored
holes with no hole drawn at all (for which <code>'white'</code>
would be an acceptable choice if the background were white).
Filled holes are often useful for indicating the entry and
exit points of a maze.
See the <code><a href="grDevices.html#topic+colors">colors</a></code> function for
acceptable values.</p>
</td></tr>
<tr><td><code id="holey_path_+3A_hole_locations">hole_locations</code></td>
<td>
<p>an optional array of &lsquo;locations&rsquo;
of the holes. These affect the <code>which_seg</code> of any holey
lines which are drawn. If an array of numeric values,
a value of zero corresponds to allowing the code to randomly
choose the location of a hole; 
negative values are &lsquo;inverted&rsquo; by adding <code>length + 1</code>, 
so that if the same segment is drawn twice, in different 
directions, only the sign of the hole location needs to be 
flipped to have aligned holes.
<code>NA</code> values will throw an error for now, though
this may change in the future.</p>
</td></tr>
<tr><td><code id="holey_path_+3A_hole_arrows">hole_arrows</code></td>
<td>
<p>a boolean or boolean array telling whether
to draw a perpendicular arrow at a hole.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Causes the turtle to move through a path of connected line segments,
possibly drawing lines, possibly drawing holes in those lines.
All arguments are recycled to the length of the longest
argument via <code>mapply</code>, which simplifies
the path description.
</p>


<h3>Value</h3>

<p>nothing; the function is called for side effects only, though in
the future this might return information about the drawn boundary of
the shape.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+holey_line">holey_line</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(TurtleGraphics)
# draw a triangle with holes on the boundaries
turtle_init(1000,1000)
holey_path(unit_len=20, lengths=rep(10,3), angles=c(120), draw_line=TRUE, has_hole=TRUE)

# draw a square with holes on the boundaries
turtle_init(1000,1000)
turtle_hide()
holey_path(unit_len=20, lengths=rep(10,4), angles=c(90), draw_line=TRUE, has_hole=TRUE, 
  hole_color=c('red','green'))

# draw a square spiral
turtle_init(1000,1000)
turtle_hide()
holey_path(unit_len=20, lengths=sort(rep(1:10,2),decreasing=TRUE), angles=c(90), 
  draw_line=TRUE, has_hole=FALSE)
</code></pre>

<hr>
<h2 id='iso_trapezoid_maze'>iso_trapezoid_maze .</h2><span id='topic+iso_trapezoid_maze'></span>

<h3>Description</h3>

<p>Recursively draw a isosceles trapezoid maze, with three sides consisting
of <code class="reqn">2^{depth}</code> pieces of length <code>unit_len</code>, and one long
side of length <code class="reqn">2^{depth+1}</code> pieces, starting from the
long side.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iso_trapezoid_maze(depth, unit_len = 4L, clockwise = TRUE,
  start_from = c("midpoint", "corner"), method = c("four_trapezoids",
  "one_ear", "random"), boustro = c(1, 1), draw_boundary = FALSE,
  num_boundary_holes = 2, boundary_lines = TRUE, boundary_holes = NULL,
  boundary_hole_color = NULL, boundary_hole_locations = NULL,
  boundary_hole_arrows = FALSE, end_side = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iso_trapezoid_maze_+3A_depth">depth</code></td>
<td>
<p>the depth of recursion. This controls the
side length: three sides have <code>round(2^depth)</code> segments
of length <code>unit_len</code>, while the long side is twice as long.
<code>depth</code> need not be integral.</p>
</td></tr>
<tr><td><code id="iso_trapezoid_maze_+3A_unit_len">unit_len</code></td>
<td>
<p>the unit length in graph coordinates. This controls
the width of the &lsquo;holes&rsquo; in the boundary lines and
generally controls the spacing of mazes.</p>
</td></tr>
<tr><td><code id="iso_trapezoid_maze_+3A_clockwise">clockwise</code></td>
<td>
<p>whether to draw clockwise.</p>
</td></tr>
<tr><td><code id="iso_trapezoid_maze_+3A_start_from">start_from</code></td>
<td>
<p>whether to start from the midpoint of the first side
of a maze, or from the corner facing the first side.</p>
</td></tr>
<tr><td><code id="iso_trapezoid_maze_+3A_method">method</code></td>
<td>
<p>there are many ways to recursive draw an isosceles
trapezoid.  The following values are acceptable:
</p>

<dl>
<dt>four_trapezoids</dt><dd><p>Four isosceles trapezoids are packed around each
other with a &lsquo;bone&rsquo; between them.</p>
</dd>
<dt>one_ear</dt><dd><p>A parallelogram is placed next to an equilateral triangle
(an &lsquo;ear&rsquo;). Note this method is acceptable when depth is
not an integer.</p>
</dd>
<dt>random</dt><dd><p>A method is chosen uniformly at random.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="iso_trapezoid_maze_+3A_boustro">boustro</code></td>
<td>
<p>an array of two values, which help determine
the location of holes in internal lines of length
<code>height</code>. The default value, <code>c(1,1)</code> results in 
uniform selection. Otherwise the location of holes are chosen
with probability proportional to a beta density with the
ordered elements of <code>boustro</code> set as 
<code>shape1</code> and <code>shape2</code>.
In sub mazes, this parameter is reversed, which
can lead to &lsquo;boustrophedonic&rsquo; mazes. It is suggested
that the sum of values not exceed 40, as otherwise the location 
of internal holes may be not widely dispersed from the mean
value.</p>
</td></tr>
<tr><td><code id="iso_trapezoid_maze_+3A_draw_boundary">draw_boundary</code></td>
<td>
<p>a boolean indicating whether a final boundary shall be
drawn around the maze.</p>
</td></tr>
<tr><td><code id="iso_trapezoid_maze_+3A_num_boundary_holes">num_boundary_holes</code></td>
<td>
<p>the number of boundary sides which should be
randomly selected to have holes. Note that the <code>boundary_holes</code>
parameter takes precedence.</p>
</td></tr>
<tr><td><code id="iso_trapezoid_maze_+3A_boundary_lines">boundary_lines</code></td>
<td>
<p>indicates which of the sides of the maze
shall have drawn boundary lines. Can be a logical array indicating
which sides shall have lines, or a numeric array, giving the
index of sides that shall have lines.</p>
</td></tr>
<tr><td><code id="iso_trapezoid_maze_+3A_boundary_holes">boundary_holes</code></td>
<td>
<p>an array indicating which of the boundary lines
have holes. If <code>NULL</code>, then boundary holes are randomly selected
by the <code>num_boundary_holes</code> parameter. If numeric, indicates
which sides of the maze shall have holes. If a boolean array, indicates
which of the sides shall have holes. These forms are recycled
if needed. See <code><a href="#topic+holey_path">holey_path</a></code>. Note that if no line
is drawn, no hole can be drawn either.</p>
</td></tr>
<tr><td><code id="iso_trapezoid_maze_+3A_boundary_hole_color">boundary_hole_color</code></td>
<td>
<p>the color of boundary holes. A value of
<code>NULL</code> indicates no colored holes. See <code><a href="#topic+holey_path">holey_path</a></code>
for more details. Can be an array of colors, or colors and the 
value <code>'clear'</code>, which stands in for <code>NULL</code> to
indicate no filled hole to be drawn.</p>
</td></tr>
<tr><td><code id="iso_trapezoid_maze_+3A_boundary_hole_locations">boundary_hole_locations</code></td>
<td>
<p>the &lsquo;locations&rsquo; of the boundary holes
within each boundary segment.
A value of <code>NULL</code> indicates the code may randomly choose, as is
the default.
May be a numeric array. A positive value up to the side length is
interpreted as the location to place the boundary hole.
A negative value is interpreted as counting down from the side
length plus 1. A value of zero corresponds to allowing the 
code to pick the location within a segment.
A value of <code>NA</code> may cause an error.</p>
</td></tr>
<tr><td><code id="iso_trapezoid_maze_+3A_boundary_hole_arrows">boundary_hole_arrows</code></td>
<td>
<p>a boolean or boolean array indicating whether to draw
perpendicular double arrows at the boundary holes, as a visual guide. These
can be useful for locating the entry and exit points of a maze.</p>
</td></tr>
<tr><td><code id="iso_trapezoid_maze_+3A_end_side">end_side</code></td>
<td>
<p>the number of the side to end on. A value of
1 corresponds to the starting side, while higher numbers
correspond to the drawn side of the figure in the canonical order
(that is, the order induced by the <code>clockwise</code> parameter).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draws a maze in an isoscelese trapezoid with three sides of equal length
and one long side of twice that length, starting from the midpoint
of the long side (or the corner before the first side via the
<code>start_from</code> option). A number of different recursive methods
are supported.
Optionally draws boundaries around the trapezoid, 
with control over which sides have lines and
holes. Three sides of the trapezoid consist of <code class="reqn">2^{depth}</code> segments
of length <code>unit_len</code>, while the longer has <code class="reqn">2^{depth}</code>. 
A number of different methods are supported.
For <code>method='four_trapezoids'</code>:
</p>

<p><img src="../help/figures/trap-four-1.png" width="100%" alt="Figure: four trapezoids" />


</p>
<p>For <code>method='one_ear'</code>:
</p>

<p><img src="../help/figures/trap-ear-1.png" width="100%" alt="Figure: one ear" />


</p>


<h3>Value</h3>

<p>nothing; the function is called for side effects only, though in
the future this might return information about the drawn boundary of
the shape.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(TurtleGraphics)
turtle_init(1000,1000)
turtle_hide() 
iso_trapezoid_maze(depth=4,20,clockwise=FALSE,draw_boundary=TRUE)

turtle_init(1000,1000)
turtle_hide() 
turtle_do({
iso_trapezoid_maze(depth=3,20,clockwise=TRUE,draw_boundary=TRUE,boundary_holes=3)
})

turtle_init(2000,2000)
turtle_hide() 
turtle_up()
turtle_do({
	len &lt;- 22
	iso_trapezoid_maze(depth=log2(len),15,clockwise=TRUE,draw_boundary=TRUE,
	  boundary_holes=c(1,3),method='one_ear',
	  boundary_hole_color=c('clear','clear','green','clear'))
	iso_trapezoid_maze(depth=log2(len),15,clockwise=FALSE,draw_boundary=TRUE,
	  boundary_lines=c(2,3,4),boundary_holes=c(2),method='one_ear',
	  boundary_hole_color=c('red'))
})
</code></pre>

<hr>
<h2 id='koch_maze'>koch_maze .</h2><span id='topic+koch_maze'></span>

<h3>Description</h3>

<p>Recursively draw an Koch snowflake maze. The inner part of the snowflake
maze consists of an equilateral triangle of side length <code class="reqn">3^{depth}</code>
pieces of length <code>unit_len</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>koch_maze(depth, unit_len, clockwise = TRUE, draw_boundary = TRUE,
  num_boundary_holes = 2, boundary_lines = TRUE, boundary_holes = NULL,
  boundary_hole_color = NULL, boundary_hole_locations = NULL,
  boundary_hole_arrows = FALSE, end_side = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="koch_maze_+3A_depth">depth</code></td>
<td>
<p>the depth of recursion. This controls the side length.
Should be an integer.</p>
</td></tr>
<tr><td><code id="koch_maze_+3A_unit_len">unit_len</code></td>
<td>
<p>the unit length in graph coordinates. This controls
the width of the &lsquo;holes&rsquo; in the boundary lines and
generally controls the spacing of mazes.</p>
</td></tr>
<tr><td><code id="koch_maze_+3A_clockwise">clockwise</code></td>
<td>
<p>whether to draw clockwise.</p>
</td></tr>
<tr><td><code id="koch_maze_+3A_draw_boundary">draw_boundary</code></td>
<td>
<p>a boolean indicating whether a final boundary shall be
drawn around the maze.</p>
</td></tr>
<tr><td><code id="koch_maze_+3A_num_boundary_holes">num_boundary_holes</code></td>
<td>
<p>the number of boundary sides which should be
randomly selected to have holes. Note that the <code>boundary_holes</code>
parameter takes precedence.</p>
</td></tr>
<tr><td><code id="koch_maze_+3A_boundary_lines">boundary_lines</code></td>
<td>
<p>indicates which of the sides of the maze
shall have drawn boundary lines. Can be a logical array indicating
which sides shall have lines, or a numeric array, giving the
index of sides that shall have lines.</p>
</td></tr>
<tr><td><code id="koch_maze_+3A_boundary_holes">boundary_holes</code></td>
<td>
<p>an array indicating which of the boundary lines
have holes. If <code>NULL</code>, then boundary holes are randomly selected
by the <code>num_boundary_holes</code> parameter. If numeric, indicates
which sides of the maze shall have holes. If a boolean array, indicates
which of the sides shall have holes. These forms are recycled
if needed. See <code><a href="#topic+holey_path">holey_path</a></code>. Note that if no line
is drawn, no hole can be drawn either.</p>
</td></tr>
<tr><td><code id="koch_maze_+3A_boundary_hole_color">boundary_hole_color</code></td>
<td>
<p>the color of boundary holes. A value of
<code>NULL</code> indicates no colored holes. See <code><a href="#topic+holey_path">holey_path</a></code>
for more details. Can be an array of colors, or colors and the 
value <code>'clear'</code>, which stands in for <code>NULL</code> to
indicate no filled hole to be drawn.</p>
</td></tr>
<tr><td><code id="koch_maze_+3A_boundary_hole_locations">boundary_hole_locations</code></td>
<td>
<p>the &lsquo;locations&rsquo; of the boundary holes
within each boundary segment.
A value of <code>NULL</code> indicates the code may randomly choose, as is
the default.
May be a numeric array. A positive value up to the side length is
interpreted as the location to place the boundary hole.
A negative value is interpreted as counting down from the side
length plus 1. A value of zero corresponds to allowing the 
code to pick the location within a segment.
A value of <code>NA</code> may cause an error.</p>
</td></tr>
<tr><td><code id="koch_maze_+3A_boundary_hole_arrows">boundary_hole_arrows</code></td>
<td>
<p>a boolean or boolean array indicating whether to draw
perpendicular double arrows at the boundary holes, as a visual guide. These
can be useful for locating the entry and exit points of a maze.</p>
</td></tr>
<tr><td><code id="koch_maze_+3A_end_side">end_side</code></td>
<td>
<p>the number of the side to end on. A value of
1 corresponds to the starting side, while higher numbers
correspond to the drawn side of the figure in the canonical order
(that is, the order induced by the <code>clockwise</code> parameter).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draws a maze in an Koch snowflake, starting from the corner of the
first side. Relies on generation of triangular mazes for the internals.
The triangular part has sides consisting of <code>3^depth</code> segments
of length <code>unit_len</code>.
</p>

<p><img src="../help/figures/koch-flake-1.png" width="100%" alt="Figure: Koch snowflake" />


</p>


<h3>Value</h3>

<p>nothing; the function is called for side effects only, though in
the future this might return information about the drawn boundary of
the shape.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(TurtleGraphics)
turtle_init(2000,2000)
turtle_hide() 
turtle_up()
set.seed(1234)
turtle_do({
	turtle_backward(distance=400)
	turtle_left(90)
	turtle_forward(650)
	turtle_right(90)
	turtle_right(30)
	koch_maze(depth=3,unit_len=14)
})
</code></pre>

<hr>
<h2 id='mazealls'>generate recursive mazes</h2><span id='topic+mazealls'></span><span id='topic+mazealls-package'></span>

<h3>Description</h3>

<p>Generate recursive mazes.
</p>


<h3>Details</h3>

<p>Recursive generation of mazes proceeds roughly as follows: subdivide
the domain logicall into two or more parts, creating mazes in the 
sub-parts, then drawing dividing lines between them with some holes.
The holes in the dividing lines should be constructed so that the
sub-parts form a tree, with exactly one way to get from one of the
sub-parts to any one of the others. Then an optional outer boundary
with optional holes is drawn to finish the maze.
</p>


<h3>unit length</h3>

<p>The <code>unit_len</code> parameter controls the graphical length of one &lsquo;unit&rsquo;, 
which is the length of holes between sections of the mazes, and is roughly the width
of the &lsquo;hallways&rsquo; of a maze. Here is an example of using different
unit lengths in a stack of trapezoids
</p>

<p><img src="../help/figures/unit-len-stack-trap-1.png" width="100%" alt="Figure: Stacked trapezoids" />


</p>


<h3>boundaries</h3>

<p>The parameters <code>draw_boundary</code>, <code>boundary_lines</code>, <code>boundary_holes</code>, 
<code>num_boundary_holes</code> and <code>boundary_hole_color</code> control
the drawing of the final outer boundary of polynomial mazes. Without a boundary
the maze can be used in recursive construction. Adding a boundary provides the
typical entry and exit points of a maze. The parameter <code>draw_boundary</code> is a
single Boolean that controls whether the boundary is drawn or not.
The parameter <code>boundary_lines</code> may be a scalar Boolean, or a numeric
array giving the indices of which sides should have drawn boundary lines.
The sides are numbered in the order in which they appear, and are
controlled by the <code>clockwise</code> parameter. The parameter <code>boundary_holes</code>
is a numeric array giving the indices of the boundary lines that should
have holes. If <code>NULL</code>, then we uniformly choose <code>num_boundary_holes</code> holes 
at random. Holes can be drawn as colored segments with the
<code>boundary_hole_color</code>, which is a character array giving the color of each
hole. The value 'clear' stands in for clear holes.
Arrows can optionally be drawn at the boundary holes via the
<code>boundary_hole_arrows</code> parameter, which is either a logical array or a 
numerical array indicating which sides should have boundary hole arrows.
</p>

<p><img src="../help/figures/boundary-stuff-1.png" width="100%" alt="Figure: Boundary Examples" />


</p>


<h3>end side</h3>

<p>The <code>end_side</code> parameter controls which side of the maze the turtle ends on.
The default value of 1 essentially causes the turtle to end where it 
started. The sides are numbered in the order in which the boundary would be
drawn. Along with the boundary controls, the ending side can be useful to join together 
polygons into more complex mazes.
</p>


<h3>Legal Mumbo Jumbo</h3>

<p>mazealls is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.
</p>


<h3>Note</h3>

<p>This package is dedicated to my friend, Abie Flaxman, who gave me the idea,
and other ideas.
</p>
<p>If you like this package, please endorse the author for &lsquo;mazes&rsquo; on
LinkedIn.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>

<hr>
<h2 id='mazealls-NEWS'>News for package 'mazealls':</h2><span id='topic+mazealls-NEWS'></span>

<h3>Description</h3>

<p>News for package &lsquo;mazealls&rsquo;
</p>




<h3><a href="https://cran.r-project.org/package=mazealls"><span class="pkg">mazealls</span></a> Version 0.2.0 (2017-12-12) </h3>


<ul>
<li><p> adding octagon, decagon and dodecagon mazes.
</p>
</li>
<li><p> adding Sierpinski triangle, carpet and trapezoid mazes.
</p>
</li>
<li><p> adding hexaflake maze.
</p>
</li>
<li><p> adding option to draw arrows at boundary holes.
</p>
</li>
<li><p> adding boustrophedon factor to parallelogram, triangle, trapezoid,
hexagon mazes.
</p>
</li></ul>



<h3><a href="https://cran.r-project.org/package=mazealls"><span class="pkg">mazealls</span></a> Initial Version 0.1.0 (2017-11-12) </h3>


<ul>
<li><p> first CRAN release.
</p>
</li></ul>


<hr>
<h2 id='octagon_maze'>octagon_maze .</h2><span id='topic+octagon_maze'></span>

<h3>Description</h3>

<p>Draw a regular octagon maze, with each side consisting of
of <code class="reqn">2^{depth}</code> pieces of length <code>unit_len</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>octagon_maze(depth, unit_len = 4L, clockwise = TRUE,
  start_from = c("midpoint", "corner"), method = c("ammann_beenker"),
  draw_boundary = FALSE, num_boundary_holes = 2, boundary_lines = TRUE,
  boundary_holes = NULL, boundary_hole_color = NULL,
  boundary_hole_locations = NULL, boundary_hole_arrows = FALSE,
  end_side = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="octagon_maze_+3A_depth">depth</code></td>
<td>
<p>the depth of recursion. This controls the side length.</p>
</td></tr>
<tr><td><code id="octagon_maze_+3A_unit_len">unit_len</code></td>
<td>
<p>the unit length in graph coordinates. This controls
the width of the &lsquo;holes&rsquo; in the boundary lines and
generally controls the spacing of mazes.</p>
</td></tr>
<tr><td><code id="octagon_maze_+3A_clockwise">clockwise</code></td>
<td>
<p>whether to draw clockwise.</p>
</td></tr>
<tr><td><code id="octagon_maze_+3A_start_from">start_from</code></td>
<td>
<p>whether to start from the midpoint of the first side
of a maze, or from the corner facing the first side.</p>
</td></tr>
<tr><td><code id="octagon_maze_+3A_method">method</code></td>
<td>
<p>there are a few ways to recursively draw an octagon. 
The following values are acceptable:
</p>

<dl>
<dt>ammann_beenker</dt><dd><p>Decompose into 4 45-degree rhombuses and two squares.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="octagon_maze_+3A_draw_boundary">draw_boundary</code></td>
<td>
<p>a boolean indicating whether a final boundary shall be
drawn around the maze.</p>
</td></tr>
<tr><td><code id="octagon_maze_+3A_num_boundary_holes">num_boundary_holes</code></td>
<td>
<p>the number of boundary sides which should be
randomly selected to have holes. Note that the <code>boundary_holes</code>
parameter takes precedence.</p>
</td></tr>
<tr><td><code id="octagon_maze_+3A_boundary_lines">boundary_lines</code></td>
<td>
<p>indicates which of the sides of the maze
shall have drawn boundary lines. Can be a logical array indicating
which sides shall have lines, or a numeric array, giving the
index of sides that shall have lines.</p>
</td></tr>
<tr><td><code id="octagon_maze_+3A_boundary_holes">boundary_holes</code></td>
<td>
<p>an array indicating which of the boundary lines
have holes. If <code>NULL</code>, then boundary holes are randomly selected
by the <code>num_boundary_holes</code> parameter. If numeric, indicates
which sides of the maze shall have holes. If a boolean array, indicates
which of the sides shall have holes. These forms are recycled
if needed. See <code><a href="#topic+holey_path">holey_path</a></code>. Note that if no line
is drawn, no hole can be drawn either.</p>
</td></tr>
<tr><td><code id="octagon_maze_+3A_boundary_hole_color">boundary_hole_color</code></td>
<td>
<p>the color of boundary holes. A value of
<code>NULL</code> indicates no colored holes. See <code><a href="#topic+holey_path">holey_path</a></code>
for more details. Can be an array of colors, or colors and the 
value <code>'clear'</code>, which stands in for <code>NULL</code> to
indicate no filled hole to be drawn.</p>
</td></tr>
<tr><td><code id="octagon_maze_+3A_boundary_hole_locations">boundary_hole_locations</code></td>
<td>
<p>the &lsquo;locations&rsquo; of the boundary holes
within each boundary segment.
A value of <code>NULL</code> indicates the code may randomly choose, as is
the default.
May be a numeric array. A positive value up to the side length is
interpreted as the location to place the boundary hole.
A negative value is interpreted as counting down from the side
length plus 1. A value of zero corresponds to allowing the 
code to pick the location within a segment.
A value of <code>NA</code> may cause an error.</p>
</td></tr>
<tr><td><code id="octagon_maze_+3A_boundary_hole_arrows">boundary_hole_arrows</code></td>
<td>
<p>a boolean or boolean array indicating whether to draw
perpendicular double arrows at the boundary holes, as a visual guide. These
can be useful for locating the entry and exit points of a maze.</p>
</td></tr>
<tr><td><code id="octagon_maze_+3A_end_side">end_side</code></td>
<td>
<p>the number of the side to end on. A value of
1 corresponds to the starting side, while higher numbers
correspond to the drawn side of the figure in the canonical order
(that is, the order induced by the <code>clockwise</code> parameter).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draws a maze in a regular octagon via dissection into rhombuses.
</p>

<p><img src="../help/figures/simple-octagon-1.png" width="100%" alt="Figure: Amman Beenker octagon" />


</p>


<h3>Value</h3>

<p>nothing; the function is called for side effects only, though in
the future this might return information about the drawn boundary of
the shape.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
turtle_init(2000,2000,mode='clip')
turtle_hide()
turtle_up()
turtle_do({
  turtle_setpos(75,1000)
  turtle_setangle(0)
	octagon_maze(6,12,draw_boundary=TRUE)
})

## End(Not run)
</code></pre>

<hr>
<h2 id='parallelogram_maze'>parallelogram_maze .</h2><span id='topic+parallelogram_maze'></span>

<h3>Description</h3>

<p>Recursively draw a parallelogram maze, with the first side consisting of
<code>height</code> segments of length <code>unit_len</code>, and the second side 
<code>width</code> segments of length <code>unit_len</code>. The angle between
the first and second side may be set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parallelogram_maze(unit_len, height, width = height, angle = 90,
  clockwise = TRUE, method = c("two_parallelograms", "four_parallelograms",
  "uniform", "random"), start_from = c("midpoint", "corner"), balance = 0,
  height_boustro = c(1, 1), width_boustro = c(1, 1),
  draw_boundary = FALSE, num_boundary_holes = 2, boundary_lines = TRUE,
  boundary_holes = NULL, boundary_hole_color = NULL,
  boundary_hole_locations = NULL, boundary_hole_arrows = FALSE,
  end_side = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parallelogram_maze_+3A_unit_len">unit_len</code></td>
<td>
<p>the unit length in graph coordinates. This controls
the width of the &lsquo;holes&rsquo; in the boundary lines and
generally controls the spacing of mazes.</p>
</td></tr>
<tr><td><code id="parallelogram_maze_+3A_height">height</code></td>
<td>
<p>the length of the first side in numbers of <code>unit_len</code>
segments.</p>
</td></tr>
<tr><td><code id="parallelogram_maze_+3A_width">width</code></td>
<td>
<p>the length of the second side in numbers of <code>unit_len</code>
segments.</p>
</td></tr>
<tr><td><code id="parallelogram_maze_+3A_angle">angle</code></td>
<td>
<p>the angle (in degrees) between the first and second sides.
Note that this is the angle that the Turtle turns when rounding
the first corner, so it is the internal angle at the starting
point (if starting from a corner), and the external angle at
the second corner.</p>
</td></tr>
<tr><td><code id="parallelogram_maze_+3A_clockwise">clockwise</code></td>
<td>
<p>whether to draw clockwise.</p>
</td></tr>
<tr><td><code id="parallelogram_maze_+3A_method">method</code></td>
<td>
<p>there are many ways to recursive draw an isosceles
trapezoid.  The following values are acceptable:
</p>

<dl>
<dt>two_parallelograms</dt><dd><p>The parallelogram maze is built as two
parallelogram mazes with a holey line between them.</p>
</dd>
<dt>four_parallelograms</dt><dd><p>The parallelogram maze is built as four
parallelogram mazes with three holey lines and one solid line between them.</p>
</dd>
<dt>uniform</dt><dd><p>The parallelogram maze is built as four
parallelogram mazes with three holey lines and one solid line between them.
Sub-mazes are chosen to be nearly equal in size.</p>
</dd>
<dt>random</dt><dd><p>A method is chosen uniformly at random.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="parallelogram_maze_+3A_start_from">start_from</code></td>
<td>
<p>whether to start from the midpoint of the first side
of a maze, or from the corner facing the first side.</p>
</td></tr>
<tr><td><code id="parallelogram_maze_+3A_balance">balance</code></td>
<td>
<p>for the <code>two_parallelograms</code> method, we choose whether
to split on height or width based on a balance condition. The log odds
of choosing height over width is the factor <code>balance</code> times the 
sign of the difference <code>height - width</code>. When balance takes the default
value of 0, you have equal odds of selecting to split on height or width.
Note that balance is positive and large, you tend to generate nearly
uniform splits. When balance is negative and large, you tend to have
imbalanced mazes, and the imbalance propagates.</p>
</td></tr>
<tr><td><code id="parallelogram_maze_+3A_height_boustro">height_boustro</code></td>
<td>
<p>an array of two values, which help determine
the location of holes in internal lines of length
<code>height</code>. The default value, <code>c(1,1)</code> results in 
uniform selection. Otherwise the location of holes are chosen
with probability proportional to a beta density with 
<code>shape1</code> and <code>shape2</code> the two elements of <code>height_boustro</code>
in order. In sub mazes, this parameter is reversed, which
can lead to &lsquo;boustrophedonic&rsquo; mazes. The sum of values
should probably not exceed 30, as otherwise the location of internal
holes is forced.</p>
</td></tr>
<tr><td><code id="parallelogram_maze_+3A_width_boustro">width_boustro</code></td>
<td>
<p>an array of two values, which help determine
the location of any split along lines which are length <code>width</code>.</p>
</td></tr>
<tr><td><code id="parallelogram_maze_+3A_draw_boundary">draw_boundary</code></td>
<td>
<p>a boolean indicating whether a final boundary shall be
drawn around the maze.</p>
</td></tr>
<tr><td><code id="parallelogram_maze_+3A_num_boundary_holes">num_boundary_holes</code></td>
<td>
<p>the number of boundary sides which should be
randomly selected to have holes. Note that the <code>boundary_holes</code>
parameter takes precedence.</p>
</td></tr>
<tr><td><code id="parallelogram_maze_+3A_boundary_lines">boundary_lines</code></td>
<td>
<p>indicates which of the sides of the maze
shall have drawn boundary lines. Can be a logical array indicating
which sides shall have lines, or a numeric array, giving the
index of sides that shall have lines.</p>
</td></tr>
<tr><td><code id="parallelogram_maze_+3A_boundary_holes">boundary_holes</code></td>
<td>
<p>an array indicating which of the boundary lines
have holes. If <code>NULL</code>, then boundary holes are randomly selected
by the <code>num_boundary_holes</code> parameter. If numeric, indicates
which sides of the maze shall have holes. If a boolean array, indicates
which of the sides shall have holes. These forms are recycled
if needed. See <code><a href="#topic+holey_path">holey_path</a></code>. Note that if no line
is drawn, no hole can be drawn either.</p>
</td></tr>
<tr><td><code id="parallelogram_maze_+3A_boundary_hole_color">boundary_hole_color</code></td>
<td>
<p>the color of boundary holes. A value of
<code>NULL</code> indicates no colored holes. See <code><a href="#topic+holey_path">holey_path</a></code>
for more details. Can be an array of colors, or colors and the 
value <code>'clear'</code>, which stands in for <code>NULL</code> to
indicate no filled hole to be drawn.</p>
</td></tr>
<tr><td><code id="parallelogram_maze_+3A_boundary_hole_locations">boundary_hole_locations</code></td>
<td>
<p>the &lsquo;locations&rsquo; of the boundary holes
within each boundary segment.
A value of <code>NULL</code> indicates the code may randomly choose, as is
the default.
May be a numeric array. A positive value up to the side length is
interpreted as the location to place the boundary hole.
A negative value is interpreted as counting down from the side
length plus 1. A value of zero corresponds to allowing the 
code to pick the location within a segment.
A value of <code>NA</code> may cause an error.</p>
</td></tr>
<tr><td><code id="parallelogram_maze_+3A_boundary_hole_arrows">boundary_hole_arrows</code></td>
<td>
<p>a boolean or boolean array indicating whether to draw
perpendicular double arrows at the boundary holes, as a visual guide. These
can be useful for locating the entry and exit points of a maze.</p>
</td></tr>
<tr><td><code id="parallelogram_maze_+3A_end_side">end_side</code></td>
<td>
<p>the number of the side to end on. A value of
1 corresponds to the starting side, while higher numbers
correspond to the drawn side of the figure in the canonical order
(that is, the order induced by the <code>clockwise</code> parameter).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draws a maze in an parallelogram, starting from the midpoint
of the first side (or the corner before the first side via the
<code>start_from</code> option). Can recursively subdivide into two or
four parallelograms.  The first (and third) side shall consist of <code>height</code>
segments of length <code>unit_len</code>. The second and fourth side consist of
<code>width</code> segments of length <code>unit_len</code>. The angle between them is
<code>angle</code>. Here is an example maze:
</p>

<p><img src="../help/figures/para-maze-1.png" width="100%" alt="Figure: parallelogram maze" />


</p>
<p>This function admits a <code>balance</code> parameter which controls
how the maze should be recursively subdivided. A negative value creates
imbalanced mazes, while positive values create more uniform mazes. Here are
create seven mazes created side by side with an increasing balance
parameter:
</p>

<p><img src="../help/figures/para-imbalance-fade-1.png" width="100%" alt="Figure: parallelogram maze" />


</p>


<h3>Value</h3>

<p>nothing; the function is called for side effects only, though in
the future this might return information about the drawn boundary of
the shape.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(TurtleGraphics)

turtle_init(500,300,mode='clip')
turtle_hide()
turtle_up()
turtle_do({
 turtle_setpos(15,15)
 turtle_setangle(0)
 parallelogram_maze(angle=90,unit_len=10,width=45,height=25,method='uniform',
 	start_from='corner',draw_boundary=TRUE)
})

# testing imbalance condition
turtle_init(400,500,mode='clip')
turtle_hide()
turtle_up()
turtle_do({
 turtle_setpos(15,250)
 turtle_setangle(0)
 parallelogram_maze(angle=90,unit_len=10,width=30,height=40,
   method='two_parallelograms',draw_boundary=TRUE,balance=-1.0)
})

# a bunch of imbalanced mazes, fading into each other
turtle_init(850,400,mode='clip')
turtle_hide()
turtle_up()
turtle_do({
  turtle_setpos(15,200)
  turtle_setangle(0)
  valseq &lt;- seq(from=-1.5,to=1.5,length.out=4)
  blines &lt;- c(1,2,3,4)
  bholes &lt;- c(1,3)
  set.seed(12354)
  for (iii in seq_along(valseq)) {
     parallelogram_maze(angle=90,unit_len=10,width=20,height=25,
      method='two_parallelograms',draw_boundary=TRUE,balance=valseq[iii],
       end_side=3,boundary_lines=blines,boundary_holes=bholes)
     turtle_right(180)
     blines &lt;- c(2,3,4)
     bholes &lt;- c(3)
  }
})

# a somewhat 'boustrophedonic' maze
turtle_init(500,300,mode='clip')
turtle_hide()
turtle_up()
turtle_do({
 turtle_setpos(15,15)
 turtle_setangle(0)
 parallelogram_maze(angle=90,unit_len=10,width=47,height=27,
    method='two_parallelograms', height_boustro=c(21,3),width_boustro=c(21,3),balance=-0.25,
		 start_from='corner',draw_boundary=TRUE)
})
</code></pre>

<hr>
<h2 id='sierpinski_carpet_maze'>sierpinski_carpet_maze .</h2><span id='topic+sierpinski_carpet_maze'></span>

<h3>Description</h3>

<p>Recursively draw a Sierpinski carpet maze in a parallelogram,
with the first side consisting of
<code>height</code> segments of length <code>unit_len</code>, and the second side 
<code>width</code> segments of length <code>unit_len</code>. The angle between
the first and second side may be set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sierpinski_carpet_maze(unit_len, height, width = height, angle = 90,
  clockwise = TRUE, method = "random", color1 = "black",
  color2 = "gray40", start_from = c("midpoint", "corner"), balance = 0,
  draw_boundary = FALSE, num_boundary_holes = 2, boundary_lines = TRUE,
  boundary_holes = NULL, boundary_hole_color = NULL,
  boundary_hole_locations = NULL, boundary_hole_arrows = FALSE,
  end_side = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sierpinski_carpet_maze_+3A_unit_len">unit_len</code></td>
<td>
<p>the unit length in graph coordinates. This controls
the width of the &lsquo;holes&rsquo; in the boundary lines and
generally controls the spacing of mazes.</p>
</td></tr>
<tr><td><code id="sierpinski_carpet_maze_+3A_height">height</code></td>
<td>
<p>the length of the first side in numbers of <code>unit_len</code>
segments.</p>
</td></tr>
<tr><td><code id="sierpinski_carpet_maze_+3A_width">width</code></td>
<td>
<p>the length of the second side in numbers of <code>unit_len</code>
segments.</p>
</td></tr>
<tr><td><code id="sierpinski_carpet_maze_+3A_angle">angle</code></td>
<td>
<p>the angle (in degrees) between the first and second sides.</p>
</td></tr>
<tr><td><code id="sierpinski_carpet_maze_+3A_clockwise">clockwise</code></td>
<td>
<p>whether to draw clockwise.</p>
</td></tr>
<tr><td><code id="sierpinski_carpet_maze_+3A_method">method</code></td>
<td>
<p>passed to <code><a href="#topic+parallelogram_maze">parallelogram_maze</a></code> to control the method
of drawing the sub mazes.</p>
</td></tr>
<tr><td><code id="sierpinski_carpet_maze_+3A_color1">color1</code></td>
<td>
<p>The dominant color of the maze.</p>
</td></tr>
<tr><td><code id="sierpinski_carpet_maze_+3A_color2">color2</code></td>
<td>
<p>The negative color of the maze.</p>
</td></tr>
<tr><td><code id="sierpinski_carpet_maze_+3A_start_from">start_from</code></td>
<td>
<p>whether to start from the midpoint of the first side
of a maze, or from the corner facing the first side.</p>
</td></tr>
<tr><td><code id="sierpinski_carpet_maze_+3A_balance">balance</code></td>
<td>
<p>passed to <code><a href="#topic+parallelogram_maze">parallelogram_maze</a></code> to
control imbalance of sub mazes.</p>
</td></tr>
<tr><td><code id="sierpinski_carpet_maze_+3A_draw_boundary">draw_boundary</code></td>
<td>
<p>a boolean indicating whether a final boundary shall be
drawn around the maze.</p>
</td></tr>
<tr><td><code id="sierpinski_carpet_maze_+3A_num_boundary_holes">num_boundary_holes</code></td>
<td>
<p>the number of boundary sides which should be
randomly selected to have holes. Note that the <code>boundary_holes</code>
parameter takes precedence.</p>
</td></tr>
<tr><td><code id="sierpinski_carpet_maze_+3A_boundary_lines">boundary_lines</code></td>
<td>
<p>indicates which of the sides of the maze
shall have drawn boundary lines. Can be a logical array indicating
which sides shall have lines, or a numeric array, giving the
index of sides that shall have lines.</p>
</td></tr>
<tr><td><code id="sierpinski_carpet_maze_+3A_boundary_holes">boundary_holes</code></td>
<td>
<p>an array indicating which of the boundary lines
have holes. If <code>NULL</code>, then boundary holes are randomly selected
by the <code>num_boundary_holes</code> parameter. If numeric, indicates
which sides of the maze shall have holes. If a boolean array, indicates
which of the sides shall have holes. These forms are recycled
if needed. See <code><a href="#topic+holey_path">holey_path</a></code>. Note that if no line
is drawn, no hole can be drawn either.</p>
</td></tr>
<tr><td><code id="sierpinski_carpet_maze_+3A_boundary_hole_color">boundary_hole_color</code></td>
<td>
<p>the color of boundary holes. A value of
<code>NULL</code> indicates no colored holes. See <code><a href="#topic+holey_path">holey_path</a></code>
for more details. Can be an array of colors, or colors and the 
value <code>'clear'</code>, which stands in for <code>NULL</code> to
indicate no filled hole to be drawn.</p>
</td></tr>
<tr><td><code id="sierpinski_carpet_maze_+3A_boundary_hole_locations">boundary_hole_locations</code></td>
<td>
<p>the &lsquo;locations&rsquo; of the boundary holes
within each boundary segment.
A value of <code>NULL</code> indicates the code may randomly choose, as is
the default.
May be a numeric array. A positive value up to the side length is
interpreted as the location to place the boundary hole.
A negative value is interpreted as counting down from the side
length plus 1. A value of zero corresponds to allowing the 
code to pick the location within a segment.
A value of <code>NA</code> may cause an error.</p>
</td></tr>
<tr><td><code id="sierpinski_carpet_maze_+3A_boundary_hole_arrows">boundary_hole_arrows</code></td>
<td>
<p>a boolean or boolean array indicating whether to draw
perpendicular double arrows at the boundary holes, as a visual guide. These
can be useful for locating the entry and exit points of a maze.</p>
</td></tr>
<tr><td><code id="sierpinski_carpet_maze_+3A_end_side">end_side</code></td>
<td>
<p>the number of the side to end on. A value of
1 corresponds to the starting side, while higher numbers
correspond to the drawn side of the figure in the canonical order
(that is, the order induced by the <code>clockwise</code> parameter).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draws a Sierpinski carpet as two-color maze in a parallelogram.
</p>


<h3>Value</h3>

<p>nothing; the function is called for side effects only, though in
the future this might return information about the drawn boundary of
the shape.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parallelogram_maze">parallelogram_maze</a></code>,
<code><a href="#topic+sierpinski_maze">sierpinski_maze</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TurtleGraphics)
turtle_init(800,900,mode='clip')
turtle_hide()
turtle_up()
turtle_do({
 turtle_setpos(35,400)
 turtle_setangle(0)
 sierpinski_carpet_maze(angle=80,unit_len=8,width=30,height=30,
   method='two_parallelograms',draw_boundary=TRUE,balance=-1.0,color2='green')
})

## Not run: 
library(TurtleGraphics)
turtle_init(2000,2000,mode='clip')
turtle_hide()
turtle_up()
bholes &lt;- list(c(1,2), c(1), c(2))
turtle_do({
 turtle_setpos(1000,1100)
 turtle_setangle(180)
 for (iii in c(1:3)) {
	 mybhol &lt;- bholes[[iii]]
	 sierpinski_carpet_maze(angle=120,unit_len=12,width=81,height=81,
		 draw_boundary=TRUE,boundary_lines=c(1,2,3),num_boundary_holes=0,
		 boundary_holes=mybhol,balance=1.0,color2='green',
		 start_from='corner')
	 turtle_left(120)
 }
})

## End(Not run)
</code></pre>

<hr>
<h2 id='sierpinski_maze'>sierpinski_maze .</h2><span id='topic+sierpinski_maze'></span>

<h3>Description</h3>

<p>Recursively draw a Sierpinski triangle maze. The sides of the
triangle consist of <code class="reqn">2^{depth}</code> pieces of length
<code>unit_len</code>.
The &lsquo;inner&rsquo; and &lsquo;outer&rsquo; pieces of
the flake are mazes drawn in different colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sierpinski_maze(depth, unit_len, clockwise = TRUE,
  start_from = c("midpoint", "corner"), method = "random",
  style = c("four_triangles", "hexaflake", "dragon_left", "dragon_right"),
  color1 = "black", color2 = "gray40", draw_boundary = FALSE,
  num_boundary_holes = 2, boundary_lines = TRUE, boundary_holes = NULL,
  boundary_hole_color = NULL, boundary_hole_locations = NULL,
  boundary_hole_arrows = FALSE, end_side = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sierpinski_maze_+3A_depth">depth</code></td>
<td>
<p>the depth of recursion. This controls the side length.
Should be an integer.</p>
</td></tr>
<tr><td><code id="sierpinski_maze_+3A_unit_len">unit_len</code></td>
<td>
<p>the unit length in graph coordinates. This controls
the width of the &lsquo;holes&rsquo; in the boundary lines and
generally controls the spacing of mazes.</p>
</td></tr>
<tr><td><code id="sierpinski_maze_+3A_clockwise">clockwise</code></td>
<td>
<p>whether to draw clockwise.</p>
</td></tr>
<tr><td><code id="sierpinski_maze_+3A_start_from">start_from</code></td>
<td>
<p>whether to start from the midpoint of the first side
of a maze, or from the corner facing the first side.</p>
</td></tr>
<tr><td><code id="sierpinski_maze_+3A_method">method</code></td>
<td>
<p>controls the method to draw the underlying
equilateral triangles. See <code><a href="#topic+eq_triangle_maze">eq_triangle_maze</a></code>.</p>
</td></tr>
<tr><td><code id="sierpinski_maze_+3A_style">style</code></td>
<td>
<p>controls the style of Sierpinski triangle. The
following are recognized:
</p>

<dl>
<dt>four_triangles</dt><dd><p>The traditional Sierpinski Triangle of four triangles
with the center in the minor color, <code>color2</code>.</p>
</dd>
<dt>hexaflake</dt><dd><p>Looks more like a hexaflake in a triangle.</p>
</dd>
<dt>dragon_left</dt><dd><p>Looks like a dragon fractal.</p>
</dd>
<dt>dragon_right</dt><dd><p>Looks like a dragon fractal.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="sierpinski_maze_+3A_color1">color1</code></td>
<td>
<p>The dominant color of the maze.</p>
</td></tr>
<tr><td><code id="sierpinski_maze_+3A_color2">color2</code></td>
<td>
<p>The negative color of the maze.</p>
</td></tr>
<tr><td><code id="sierpinski_maze_+3A_draw_boundary">draw_boundary</code></td>
<td>
<p>a boolean indicating whether a final boundary shall be
drawn around the maze.</p>
</td></tr>
<tr><td><code id="sierpinski_maze_+3A_num_boundary_holes">num_boundary_holes</code></td>
<td>
<p>the number of boundary sides which should be
randomly selected to have holes. Note that the <code>boundary_holes</code>
parameter takes precedence.</p>
</td></tr>
<tr><td><code id="sierpinski_maze_+3A_boundary_lines">boundary_lines</code></td>
<td>
<p>indicates which of the sides of the maze
shall have drawn boundary lines. Can be a logical array indicating
which sides shall have lines, or a numeric array, giving the
index of sides that shall have lines.</p>
</td></tr>
<tr><td><code id="sierpinski_maze_+3A_boundary_holes">boundary_holes</code></td>
<td>
<p>an array indicating which of the boundary lines
have holes. If <code>NULL</code>, then boundary holes are randomly selected
by the <code>num_boundary_holes</code> parameter. If numeric, indicates
which sides of the maze shall have holes. If a boolean array, indicates
which of the sides shall have holes. These forms are recycled
if needed. See <code><a href="#topic+holey_path">holey_path</a></code>. Note that if no line
is drawn, no hole can be drawn either.</p>
</td></tr>
<tr><td><code id="sierpinski_maze_+3A_boundary_hole_color">boundary_hole_color</code></td>
<td>
<p>the color of boundary holes. A value of
<code>NULL</code> indicates no colored holes. See <code><a href="#topic+holey_path">holey_path</a></code>
for more details. Can be an array of colors, or colors and the 
value <code>'clear'</code>, which stands in for <code>NULL</code> to
indicate no filled hole to be drawn.</p>
</td></tr>
<tr><td><code id="sierpinski_maze_+3A_boundary_hole_locations">boundary_hole_locations</code></td>
<td>
<p>the &lsquo;locations&rsquo; of the boundary holes
within each boundary segment.
A value of <code>NULL</code> indicates the code may randomly choose, as is
the default.
May be a numeric array. A positive value up to the side length is
interpreted as the location to place the boundary hole.
A negative value is interpreted as counting down from the side
length plus 1. A value of zero corresponds to allowing the 
code to pick the location within a segment.
A value of <code>NA</code> may cause an error.</p>
</td></tr>
<tr><td><code id="sierpinski_maze_+3A_boundary_hole_arrows">boundary_hole_arrows</code></td>
<td>
<p>a boolean or boolean array indicating whether to draw
perpendicular double arrows at the boundary holes, as a visual guide. These
can be useful for locating the entry and exit points of a maze.</p>
</td></tr>
<tr><td><code id="sierpinski_maze_+3A_end_side">end_side</code></td>
<td>
<p>the number of the side to end on. A value of
1 corresponds to the starting side, while higher numbers
correspond to the drawn side of the figure in the canonical order
(that is, the order induced by the <code>clockwise</code> parameter).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draws a maze in an Sierpinski equilateral Triangle. The inner quarter is
drawn in the secondary color, while the outer three quarters are drawn
recursively. This is the traditional Sierpinski Triangle, generated when
<code>style=='four_triangles'</code>:
</p>

<p><img src="../help/figures/sierpinski-1.png" width="100%" alt="Figure: Sierpinski triangle" />


</p>


<h3>Value</h3>

<p>nothing; the function is called for side effects only, though in
the future this might return information about the drawn boundary of
the shape.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eq_triangle_maze">eq_triangle_maze</a></code>,
<code><a href="#topic+hexaflake_maze">hexaflake_maze</a></code>,
<code><a href="#topic+sierpinski_carpet_maze">sierpinski_carpet_maze</a></code>,
<code><a href="#topic+sierpinski_trapezoid_maze">sierpinski_trapezoid_maze</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(TurtleGraphics)
turtle_init(1000,1000,mode='clip')
turtle_up()
turtle_hide()
turtle_do({
	turtle_setpos(10,500)
	turtle_setangle(0)
	sierpinski_maze(depth=5,unit_len=19,boundary_lines=TRUE,
	  boundary_holes=c(1,3),color1='black',color2='gray60')
})

</code></pre>

<hr>
<h2 id='sierpinski_trapezoid_maze'>sierpinski_trapezoid_maze .</h2><span id='topic+sierpinski_trapezoid_maze'></span>

<h3>Description</h3>

<p>Recursively draw a Sierpinski isosceles trapezoid maze, 
with three sides consisting
of <code class="reqn">2^{depth}</code> pieces of length <code>unit_len</code>, and one long
side of length <code class="reqn">2^{depth+1}</code> pieces, starting from the
long side.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sierpinski_trapezoid_maze(depth, unit_len = 4L, clockwise = TRUE,
  start_from = c("midpoint", "corner"), color1 = "black",
  color2 = "gray40", flip_color_parts = 1, draw_boundary = FALSE,
  num_boundary_holes = 2, boundary_lines = TRUE, boundary_holes = NULL,
  boundary_hole_color = NULL, boundary_hole_locations = NULL,
  boundary_hole_arrows = FALSE, end_side = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sierpinski_trapezoid_maze_+3A_depth">depth</code></td>
<td>
<p>the depth of recursion. This controls the
side length: three sides have <code>round(2^depth)</code> segments
of length <code>unit_len</code>, while the long side is twice as long.
<code>depth</code> need not be integral.</p>
</td></tr>
<tr><td><code id="sierpinski_trapezoid_maze_+3A_unit_len">unit_len</code></td>
<td>
<p>the unit length in graph coordinates. This controls
the width of the &lsquo;holes&rsquo; in the boundary lines and
generally controls the spacing of mazes.</p>
</td></tr>
<tr><td><code id="sierpinski_trapezoid_maze_+3A_clockwise">clockwise</code></td>
<td>
<p>whether to draw clockwise.</p>
</td></tr>
<tr><td><code id="sierpinski_trapezoid_maze_+3A_start_from">start_from</code></td>
<td>
<p>whether to start from the midpoint of the first side
of a maze, or from the corner facing the first side.</p>
</td></tr>
<tr><td><code id="sierpinski_trapezoid_maze_+3A_color1">color1</code></td>
<td>
<p>The dominant color of the maze.</p>
</td></tr>
<tr><td><code id="sierpinski_trapezoid_maze_+3A_color2">color2</code></td>
<td>
<p>The negative color of the maze.</p>
</td></tr>
<tr><td><code id="sierpinski_trapezoid_maze_+3A_flip_color_parts">flip_color_parts</code></td>
<td>
<p>a numerical array which can contain values 1
through 4. Those parts of the maze, when drawn recursively, have 
their colors flipped. A value of <code>3</code> corresponds to a traditional
Sierpinski triangle, while <code>1</code> corresponds to a Hexaflake.
Values of <code>2</code> or <code>4</code> look more like dragon mazes.</p>
</td></tr>
<tr><td><code id="sierpinski_trapezoid_maze_+3A_draw_boundary">draw_boundary</code></td>
<td>
<p>a boolean indicating whether a final boundary shall be
drawn around the maze.</p>
</td></tr>
<tr><td><code id="sierpinski_trapezoid_maze_+3A_num_boundary_holes">num_boundary_holes</code></td>
<td>
<p>the number of boundary sides which should be
randomly selected to have holes. Note that the <code>boundary_holes</code>
parameter takes precedence.</p>
</td></tr>
<tr><td><code id="sierpinski_trapezoid_maze_+3A_boundary_lines">boundary_lines</code></td>
<td>
<p>indicates which of the sides of the maze
shall have drawn boundary lines. Can be a logical array indicating
which sides shall have lines, or a numeric array, giving the
index of sides that shall have lines.</p>
</td></tr>
<tr><td><code id="sierpinski_trapezoid_maze_+3A_boundary_holes">boundary_holes</code></td>
<td>
<p>an array indicating which of the boundary lines
have holes. If <code>NULL</code>, then boundary holes are randomly selected
by the <code>num_boundary_holes</code> parameter. If numeric, indicates
which sides of the maze shall have holes. If a boolean array, indicates
which of the sides shall have holes. These forms are recycled
if needed. See <code><a href="#topic+holey_path">holey_path</a></code>. Note that if no line
is drawn, no hole can be drawn either.</p>
</td></tr>
<tr><td><code id="sierpinski_trapezoid_maze_+3A_boundary_hole_color">boundary_hole_color</code></td>
<td>
<p>the color of boundary holes. A value of
<code>NULL</code> indicates no colored holes. See <code><a href="#topic+holey_path">holey_path</a></code>
for more details. Can be an array of colors, or colors and the 
value <code>'clear'</code>, which stands in for <code>NULL</code> to
indicate no filled hole to be drawn.</p>
</td></tr>
<tr><td><code id="sierpinski_trapezoid_maze_+3A_boundary_hole_locations">boundary_hole_locations</code></td>
<td>
<p>the &lsquo;locations&rsquo; of the boundary holes
within each boundary segment.
A value of <code>NULL</code> indicates the code may randomly choose, as is
the default.
May be a numeric array. A positive value up to the side length is
interpreted as the location to place the boundary hole.
A negative value is interpreted as counting down from the side
length plus 1. A value of zero corresponds to allowing the 
code to pick the location within a segment.
A value of <code>NA</code> may cause an error.</p>
</td></tr>
<tr><td><code id="sierpinski_trapezoid_maze_+3A_boundary_hole_arrows">boundary_hole_arrows</code></td>
<td>
<p>a boolean or boolean array indicating whether to draw
perpendicular double arrows at the boundary holes, as a visual guide. These
can be useful for locating the entry and exit points of a maze.</p>
</td></tr>
<tr><td><code id="sierpinski_trapezoid_maze_+3A_end_side">end_side</code></td>
<td>
<p>the number of the side to end on. A value of
1 corresponds to the starting side, while higher numbers
correspond to the drawn side of the figure in the canonical order
(that is, the order induced by the <code>clockwise</code> parameter).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draws a maze in an isoscelese trapezoid with three sides of equal length
and one long side of twice that length, starting from the midpoint
of the long side (or the corner before the first side via the
<code>start_from</code> option). Differently colors the parts of the
maze for a Sierpinski effect.
</p>
<p>Here are mazes for different values of <code>flip_color_parts</code> ranging
from 1 to 4:
</p>

<p><img src="../help/figures/sierpinski-trapezoids-1.png" width="100%" alt="Figure: four kinds of Sierpinski trapezoids" />


</p>


<h3>Value</h3>

<p>nothing; the function is called for side effects only, though in
the future this might return information about the drawn boundary of
the shape.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iso_trapezoid_maze">iso_trapezoid_maze</a></code>,
<code><a href="#topic+hexaflake_maze">hexaflake_maze</a></code>,
<code><a href="#topic+sierpinski_carpet_maze">sierpinski_carpet_maze</a></code>,
<code><a href="#topic+sierpinski_maze">sierpinski_maze</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(TurtleGraphics)
turtle_init(1000,1000,mode='clip')
turtle_hide()
turtle_up()
turtle_do({
  turtle_setpos(500,500)
  turtle_setangle(0)
  sierpinski_trapezoid_maze(unit_len=15,depth=4,color1='black',color2='green',
    clockwise=TRUE,draw_boundary=TRUE,boundary_holes=c(1,3))
  sierpinski_trapezoid_maze(unit_len=15,depth=4,color1='black',color2='green',
    clockwise=FALSE,draw_boundary=TRUE,
    boundary_lines=c(2,3,4),boundary_holes=3)
})

# stack some trapezoids!
require(TurtleGraphics)
turtle_init(750,900,mode='clip')
turtle_hide()
turtle_up()
turtle_do({
  turtle_setpos(25,450)
  turtle_setangle(0)
  blines &lt;- c(1,2,4)
  for (dep in seq(from=4,to=0)) {
    sierpinski_trapezoid_maze(unit_len=13,depth=dep,color1='black',color2='green',
      flip_color_parts=2,
      clockwise=TRUE,boundary_lines=blines,draw_boundary=TRUE,boundary_holes=c(1,3),
      end_side=3)
    turtle_right(180)
    blines &lt;- c(1,2,4)
  }
})
## Not run: 
require(TurtleGraphics)
turtle_init(750,900,mode='clip')
turtle_hide()
turtle_up()
turtle_do({
  turtle_setpos(25,450)
  turtle_setangle(0)
  blines &lt;- c(1,2,4)
  for (dep in seq(from=5,to=0)) {
    sierpinski_trapezoid_maze(unit_len=13,depth=dep,color1='black',color2='green',
      flip_color_parts=3,
      clockwise=TRUE,boundary_lines=blines,draw_boundary=TRUE,boundary_holes=c(1,3),
      end_side=3)
    turtle_right(180)
    blines &lt;- c(1,2,4)
  }
})

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
