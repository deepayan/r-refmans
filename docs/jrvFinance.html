<!DOCTYPE html><html><head><title>Help for package jrvFinance</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {jrvFinance}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#annuity'><p>Present Value of Annuity and Related Functions</p></a></li>
<li><a href='#bisection.root'><p>Find zero of a function by bracketing the zero and then using</p>
bisection.</a></li>
<li><a href='#bonds'><p>Bond pricing using yield to maturity.</p></a></li>
<li><a href='#coupons'><p>Bond pricing using yield to maturity.</p></a></li>
<li><a href='#daycount'><p>Day count and year fraction for bond pricing</p></a></li>
<li><a href='#duration'><p>Duration and Modified Duration</p></a></li>
<li><a href='#edate'><p>Shift date by a number of months</p></a></li>
<li><a href='#equiv.rate'><p>Equivalent Rates under different Compounding Conventions</p></a></li>
<li><a href='#GenBS'><p>Generalized Black Scholes model for pricing vanilla European options</p></a></li>
<li><a href='#GenBSImplied'><p>Generalized Black Scholes model implied volatility</p></a></li>
<li><a href='#irr'><p>Internal Rate of Return</p></a></li>
<li><a href='#irr.solve'><p>Solve for IRR (internal rate of return) or YTM (yield to maturity)</p></a></li>
<li><a href='#jrvFinance-package'><p>Basic Finance: NPV/IRR/annuities, bond pricing, Black Scholes</p></a></li>
<li><a href='#newton.raphson.root'><p>A Newton Raphson root finder: finds x such that f(x) = 0</p></a></li>
<li><a href='#npv'><p>Net Present Value</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Basic Finance; NPV/IRR/Annuities/Bond-Pricing; Black Scholes</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the basic financial analysis
    functions similar to (but not identical to) what
    is available in most spreadsheet software. This
    includes finding the IRR and NPV of regularly
    spaced cash flows and annuities. Bond pricing and
    YTM calculations are included. In addition, Black
    Scholes option pricing and Greeks are also
    provided.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, markdown, rmarkdown</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jrvarma/jrvFinance">https://github.com/jrvarma/jrvFinance</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jrvarma/jrvFinance/issues">https://github.com/jrvarma/jrvFinance/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-05 13:24:34 UTC; jrvarma</td>
</tr>
<tr>
<td>Author:</td>
<td>Jayanth Varma [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jayanth Varma &lt;jrvarma@iima.ac.in&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-05 13:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='annuity'>Present Value of Annuity and Related Functions</h2><span id='topic+annuity'></span><span id='topic+annuity.pv'></span><span id='topic+annuity.fv'></span><span id='topic+annuity.instalment'></span><span id='topic+annuity.periods'></span><span id='topic+annuity.rate'></span><span id='topic+annuity.instalment.breakup'></span>

<h3>Description</h3>

<p>Functions to compute present value and future value of annuities, to find
instalment given the present value or future value. Can also find the rate
or the number of periods given other parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annuity.pv(
  rate,
  n.periods = Inf,
  instalment = 1,
  terminal.payment = 0,
  immediate.start = FALSE,
  cf.freq = 1,
  comp.freq = 1
)

annuity.fv(
  rate,
  n.periods = Inf,
  instalment = 1,
  terminal.payment = 0,
  immediate.start = FALSE,
  cf.freq = 1,
  comp.freq = 1
)

annuity.instalment(
  rate,
  n.periods = Inf,
  pv = if (missing(fv)) 1 else 0,
  fv = 0,
  terminal.payment = 0,
  immediate.start = FALSE,
  cf.freq = 1,
  comp.freq = 1
)

annuity.periods(
  rate,
  instalment = 1,
  pv = if (missing(fv)) 1 else 0,
  fv = 0,
  terminal.payment = 0,
  immediate.start = FALSE,
  cf.freq = 1,
  comp.freq = 1,
  round2int.digits = 3
)

annuity.rate(
  n.periods = Inf,
  instalment = 1,
  pv = if (missing(fv)) 1 else 0,
  fv = 0,
  terminal.payment = 0,
  immediate.start = FALSE,
  cf.freq = 1,
  comp.freq = 1
)

annuity.instalment.breakup(
  rate,
  n.periods = Inf,
  pv = 1,
  immediate.start = FALSE,
  cf.freq = 1,
  comp.freq = 1,
  period.no = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annuity_+3A_rate">rate</code></td>
<td>
<p>The interest rate in decimal (0.10 or 10e-2 for 10%)</p>
</td></tr>
<tr><td><code id="annuity_+3A_n.periods">n.periods</code></td>
<td>
<p>The number of periods in the annuity.</p>
</td></tr>
<tr><td><code id="annuity_+3A_instalment">instalment</code></td>
<td>
<p>The instalment (cash flow) per period.</p>
</td></tr>
<tr><td><code id="annuity_+3A_terminal.payment">terminal.payment</code></td>
<td>
<p>Any cash flow at the end of the annuity. For
example, a bullet repayment at maturity of the unamortized principal.</p>
</td></tr>
<tr><td><code id="annuity_+3A_immediate.start">immediate.start</code></td>
<td>
<p>Logical variable which is <code>TRUE</code> for immediate
annuities (the first instalment is due immediately) and <code>FALSE</code> for deferred
annuities (the first instalment is due at the end of the first period).</p>
</td></tr>
<tr><td><code id="annuity_+3A_cf.freq">cf.freq</code></td>
<td>
<p>Frequency of annuity payments: 1 for annual, 2 for
semi-annual, 12 for monthly.</p>
</td></tr>
<tr><td><code id="annuity_+3A_comp.freq">comp.freq</code></td>
<td>
<p>Frequency of compounding of interest rates: 1 for annual,
2 for semi-annual, 12 for monthly, Inf for continuous compounding.</p>
</td></tr>
<tr><td><code id="annuity_+3A_pv">pv</code></td>
<td>
<p>The present value of all the cash flows including the terminal
payment.</p>
</td></tr>
<tr><td><code id="annuity_+3A_fv">fv</code></td>
<td>
<p>The future value (at the end of the annuity) of all the cash
flows including the terminal payment.</p>
</td></tr>
<tr><td><code id="annuity_+3A_round2int.digits">round2int.digits</code></td>
<td>
<p>Used only in <code>annuity.periods</code>. If the computed
number of periods is an integer when rounded to round2int.digits, then the
rounded integer value is returned. With the default value of 3, 9.9996 is
returned as 10, but 9.9994 and 9.39999999 are returned without any
rounding.</p>
</td></tr>
<tr><td><code id="annuity_+3A_period.no">period.no</code></td>
<td>
<p>Used only in <code>annuity.instalment.breakup</code>. This is the
period for which the instalment needs to be broken up into principal and
interest parts.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are based on the Present Value relationship:
</p>
<p style="text-align: center;"><code class="reqn">pv = fv \cdot df = 
terminal.payment \cdot df + \frac{instalment (1 - df)}{r}</code>
</p>

<p>where
<code class="reqn">df = (1 + r)^{-n.periods}</code> is the <code class="reqn">n.periods</code> discount factor and
<code class="reqn">r</code> is the per period interest rate computed using
rate, cf.freq and comp.freq.
</p>
<p>It is intended that only one of <code class="reqn">pv</code> or <code class="reqn">fv</code> is used in any function call, but
internally the functions use <code class="reqn">pv + fv \cdot df</code> as the
LHS of the present value relationship under the assumption that only of the
two is non zero. 
</p>
<p>The function <code>annuity.instalment.breakup</code> regards the annuity as a repayment
of a loan equal to <code>pv</code> plus the present value of terminal.payment. The
instalment paid in period period.no is broken up into the principal
repayment (amortization) and interest components.
</p>


<h3>Value</h3>

<p>For most functions, the return value is one of the arguments
described above. For example <code>annuity.pv</code> returns <code>pv</code>. The only exception is
<code>annuity.instalment.breakup</code>. This returns a list with the following
components:
</p>
<table>
<tr><td><code>opening.principal</code></td>
<td>
<p>The principal balance at the beginning
of the period</p>
</td></tr>
<tr><td><code>closing.principal</code></td>
<td>
<p>The principal balance at the end of
the period</p>
</td></tr>
<tr><td><code>interest.part</code></td>
<td>
<p>The portion of the instalment which
represents interest</p>
</td></tr>
<tr><td><code>principal.part</code></td>
<td>
<p>The portion of the instalment
which represents principal repayment</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Prof. Jayanth R. Varma <a href="mailto:jrvarma@iima.ac.in">jrvarma@iima.ac.in</a>
</p>

<hr>
<h2 id='bisection.root'>Find zero of a function by bracketing the zero and then using
bisection.</h2><span id='topic+bisection.root'></span>

<h3>Description</h3>

<p>Tries to find the zero of a function by using the bisection method
(<code><a href="stats.html#topic+uniroot">uniroot</a></code>). To call
<code><a href="stats.html#topic+uniroot">uniroot</a></code>, the zero must be bracketed by
finding two points at which the function value has opposite
signs. The main code in this function is a grid search to find
such a pair of points. A geometric grid of points between
<code>lower</code> and <code>guess</code> and also between <code>guess</code> and
<code>upper</code>. This grid is searched for two neighbouring points
across which the function changes sign. This brackets the root,
and then we try to locate the root by calling
<code><a href="stats.html#topic+uniroot">uniroot</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bisection.root(f, guess, lower, upper, nstep = 100, toler = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bisection.root_+3A_f">f</code></td>
<td>
<p>The function whose zero is to be found. An R function
object that takes one numeric argument and returns a numeric
value. In an IRR application, this will be the NPV
function. In an implied volatility application, the value will
be the option price.</p>
</td></tr>
<tr><td><code id="bisection.root_+3A_guess">guess</code></td>
<td>
<p>The starting value (guess) from which the solver
starts searching for the root. Must be positive.</p>
</td></tr>
<tr><td><code id="bisection.root_+3A_lower">lower</code></td>
<td>
<p>The lower end of the interval within which to search
for the root. Must be positive.</p>
</td></tr>
<tr><td><code id="bisection.root_+3A_upper">upper</code></td>
<td>
<p>The upper end of the interval within which to search
for the root. Must be positive.</p>
</td></tr>
<tr><td><code id="bisection.root_+3A_nstep">nstep</code></td>
<td>
<p>The number of steps in the grid search to bracket the
zero. See details.</p>
</td></tr>
<tr><td><code id="bisection.root_+3A_toler">toler</code></td>
<td>
<p>The criterion to determine whether a zero has been
found. This is passed on to <code><a href="stats.html#topic+uniroot">uniroot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The root (or NA if the method fails)
</p>


<h3>Author(s)</h3>

<p>Prof. Jayanth R. Varma
</p>

<hr>
<h2 id='bonds'>Bond pricing using yield to maturity.</h2><span id='topic+bonds'></span><span id='topic+bond.price'></span><span id='topic+bond.TCF'></span><span id='topic+bond.yield'></span><span id='topic+bond.duration'></span><span id='topic+bond.prices'></span><span id='topic+bond.durations'></span><span id='topic+bond.yields'></span>

<h3>Description</h3>

<p>bond.price computes the price given the yield to maturity
bond.duration computes the duration given the yield to maturity
bond.yield computes the yield to maturity given the price
bond.prices, bond.durations and bond.yields are wrapper functions
that use <code>mapply</code> to vectorize bond.price, bond.duration and bond.yield
All arguments to bond.prices, bond.durations and bond.yields
can be vectors.
On the other hand, bond.price, bond.duration and bond.yield do not allow vectors 
Standard compounding and day count conventions are supported for all functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bond.price(
  settle,
  mature,
  coupon,
  freq = 2,
  yield,
  convention = c("30/360", "ACT/ACT", "ACT/360", "30/360E"),
  comp.freq = freq,
  redemption_value = 100
)

bond.yield(
  settle,
  mature,
  coupon,
  freq = 2,
  price,
  convention = c("30/360", "ACT/ACT", "ACT/360", "30/360E"),
  comp.freq = freq,
  redemption_value = 100
)

bond.duration(
  settle,
  mature,
  coupon,
  freq = 2,
  yield,
  convention = c("30/360", "ACT/ACT", "ACT/360", "30/360E"),
  modified = FALSE,
  comp.freq = freq,
  redemption_value = 100
)

bond.TCF(
  settle,
  mature,
  coupon,
  freq = 2,
  convention = c("30/360", "ACT/ACT", "ACT/360", "30/360E"),
  redemption_value = 100
)

bond.prices(
  settle,
  mature,
  coupon,
  freq = 2,
  yield,
  convention = c("30/360", "ACT/ACT", "ACT/360", "30/360E"),
  comp.freq = freq,
  redemption_value = 100
)

bond.yields(
  settle,
  mature,
  coupon,
  freq = 2,
  price,
  convention = c("30/360", "ACT/ACT", "ACT/360", "30/360E"),
  comp.freq = freq,
  redemption_value = 100
)

bond.durations(
  settle,
  mature,
  coupon,
  freq = 2,
  yield,
  convention = c("30/360", "ACT/ACT", "ACT/360", "30/360E"),
  modified = FALSE,
  comp.freq = freq,
  redemption_value = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bonds_+3A_settle">settle</code></td>
<td>
<p>The settlement date for which the bond is traded. Can be a
character string or any object that can be converted into date using
<code><a href="base.html#topic+as.Date">as.Date</a></code>.</p>
</td></tr>
<tr><td><code id="bonds_+3A_mature">mature</code></td>
<td>
<p>The maturity date of the bond. Can be a character string or
any object that can be converted into date using <code><a href="base.html#topic+as.Date">as.Date</a></code></p>
</td></tr>
<tr><td><code id="bonds_+3A_coupon">coupon</code></td>
<td>
<p>The coupon rate in decimal (0.10 or 10e-2 for 10%)</p>
</td></tr>
<tr><td><code id="bonds_+3A_freq">freq</code></td>
<td>
<p>The frequency of coupon payments: 1 for annual, 2 for
semi-annual, 12 for monthly.</p>
</td></tr>
<tr><td><code id="bonds_+3A_yield">yield</code></td>
<td>
<p>The yield to maturity of the bond</p>
</td></tr>
<tr><td><code id="bonds_+3A_convention">convention</code></td>
<td>
<p>The daycount convention</p>
</td></tr>
<tr><td><code id="bonds_+3A_comp.freq">comp.freq</code></td>
<td>
<p>The frequency of compounding of the bond yield: 1 for
annual, 2 for semi-annual, 12 for monthly. Usually same as freq.</p>
</td></tr>
<tr><td><code id="bonds_+3A_redemption_value">redemption_value</code></td>
<td>
<p>The principal amount that the bond will pay on maturity or call.
Typically necessary when the bond is expected to be called at premium to par.</p>
</td></tr>
<tr><td><code id="bonds_+3A_price">price</code></td>
<td>
<p>The clean price of the bond.</p>
</td></tr>
<tr><td><code id="bonds_+3A_modified">modified</code></td>
<td>
<p>A logical value used in duration. <code>TRUE</code> to return Modified
Duration, <code>FALSE</code> otherwise</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>bond.TCF</code> returns a list of three components
</p>
<table>
<tr><td><code>t</code></td>
<td>
<p>A vector of cash flow dates in number of years</p>
</td></tr>
<tr><td><code>cf</code></td>
<td>
<p>A vector of cash flows</p>
</td></tr>
<tr><td><code>accrued</code></td>
<td>
<p>The accrued interest</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Prof. Jayanth R. Varma <a href="mailto:jrvarma@iima.ac.in">jrvarma@iima.ac.in</a>
</p>

<hr>
<h2 id='coupons'>Bond pricing using yield to maturity.</h2><span id='topic+coupons'></span><span id='topic+coupons.n'></span><span id='topic+coupons.dates'></span><span id='topic+coupons.next'></span><span id='topic+coupons.prev'></span>

<h3>Description</h3>

<p>Convenience functions for finding coupon dates and number of coupons of a bond.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coupons.dates(settle, mature, freq = 2)

coupons.n(settle, mature, freq = 2)

coupons.next(settle, mature, freq = 2)

coupons.prev(settle, mature, freq = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coupons_+3A_settle">settle</code></td>
<td>
<p>The settlement date for which the bond is traded. Can be a
character string or any object that can be converted into date using
<code><a href="base.html#topic+as.Date">as.Date</a></code>.</p>
</td></tr>
<tr><td><code id="coupons_+3A_mature">mature</code></td>
<td>
<p>The maturity date of the bond. Can be a character string or
any object that can be converted into date using <code><a href="base.html#topic+as.Date">as.Date</a></code></p>
</td></tr>
<tr><td><code id="coupons_+3A_freq">freq</code></td>
<td>
<p>The frequency of coupon payments: 1 for annual, 2 for
semi-annual, 12 for monthly.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Prof. Jayanth R. Varma <a href="mailto:jrvarma@iima.ac.in">jrvarma@iima.ac.in</a>
</p>

<hr>
<h2 id='daycount'>Day count and year fraction for bond pricing</h2><span id='topic+daycount'></span><span id='topic+daycount.30.360'></span><span id='topic+daycount.actual'></span><span id='topic+yearFraction'></span>

<h3>Description</h3>

<p>Implements 30/360, ACT/360, ACT/360 and 30/360E day count conventions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yearFraction(
  d1,
  d2,
  r1,
  r2,
  freq = 2,
  convention = c("30/360", "ACT/ACT", "ACT/360", "30/360E")
)

daycount.actual(d1, d2, variant = c("bond"))

daycount.30.360(d1, d2, variant = c("US", "EU", "IT"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="daycount_+3A_d1">d1</code></td>
<td>
<p>The starting date of period for day counts</p>
</td></tr>
<tr><td><code id="daycount_+3A_d2">d2</code></td>
<td>
<p>The ending date of period for day counts</p>
</td></tr>
<tr><td><code id="daycount_+3A_r1">r1</code></td>
<td>
<p>The starting date of reference period for ACT/ACT day counts</p>
</td></tr>
<tr><td><code id="daycount_+3A_r2">r2</code></td>
<td>
<p>The ending date of reference period for ACT/ACT day counts</p>
</td></tr>
<tr><td><code id="daycount_+3A_freq">freq</code></td>
<td>
<p>The frequency of coupon payments: 1 for annual, 2 for
semi-annual, 12 for monthly.</p>
</td></tr>
<tr><td><code id="daycount_+3A_convention">convention</code></td>
<td>
<p>The daycount convention</p>
</td></tr>
<tr><td><code id="daycount_+3A_variant">variant</code></td>
<td>
<p>Three variants of the 30/360 convention are implemented, but
only one variant of ACT/ACT is currently implemented</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Prof. Jayanth R. Varma <a href="mailto:jrvarma@iima.ac.in">jrvarma@iima.ac.in</a>
</p>


<h3>References</h3>

<p>The 30/360 day count was converted from C++ code in the
QuantLib library
</p>

<hr>
<h2 id='duration'>Duration and Modified Duration</h2><span id='topic+duration'></span>

<h3>Description</h3>

<p>Computes Duration and Modified Duration for cash flows with
different cash flow and compounding conventions. Cash flows need
not be evenly spaced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duration(
  cf,
  rate,
  cf.freq = 1,
  comp.freq = 1,
  cf.t = seq(from = ifelse(immediate.start, 0, 1/cf.freq), by = 1/cf.freq, along.with =
    cf),
  immediate.start = FALSE,
  modified = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duration_+3A_cf">cf</code></td>
<td>
<p>Vector of cash flows</p>
</td></tr>
<tr><td><code id="duration_+3A_rate">rate</code></td>
<td>
<p>The interest rate in decimal (0.10 or 10e-2 for 10%)</p>
</td></tr>
<tr><td><code id="duration_+3A_cf.freq">cf.freq</code></td>
<td>
<p>Frequency of annuity payments: 1 for annual, 2 for
semi-annual, 12 for monthly.</p>
</td></tr>
<tr><td><code id="duration_+3A_comp.freq">comp.freq</code></td>
<td>
<p>Frequency of compounding of interest rates: 1 for annual,
2 for semi-annual, 12 for monthly, Inf for continuous compounding.</p>
</td></tr>
<tr><td><code id="duration_+3A_cf.t">cf.t</code></td>
<td>
<p>Optional vector of timing (in years) of cash flows. If omitted
regular sequence of years is assumed.</p>
</td></tr>
<tr><td><code id="duration_+3A_immediate.start">immediate.start</code></td>
<td>
<p>Logical variable which is <code>TRUE</code> when the first cash
flows is at the beginning of the first period (for example, immediate
annuities) and <code>FALSE</code> when the first cash flows is at the end of the first
period (for example, deferred annuities)</p>
</td></tr>
<tr><td><code id="duration_+3A_modified">modified</code></td>
<td>
<p>in function duration, <code>TRUE</code> if modified
duration is desired. <code>FALSE</code> otherwise.</p>
</td></tr>
</table>

<hr>
<h2 id='edate'>Shift date by a number of months</h2><span id='topic+edate'></span>

<h3>Description</h3>

<p>Convenience function for finding the same date in different months. Used for example
to find coupon dates of bonds given the maturity date. See <code><a href="#topic+coupons">coupons</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edate(from, months = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edate_+3A_from">from</code></td>
<td>
<p>starting date - a character string or any object that can be
converted into date using <code><a href="base.html#topic+as.Date">as.Date</a></code>.</p>
</td></tr>
<tr><td><code id="edate_+3A_months">months</code></td>
<td>
<p>Number of months (can be negative)</p>
</td></tr>
</table>

<hr>
<h2 id='equiv.rate'>Equivalent Rates under different Compounding Conventions</h2><span id='topic+equiv.rate'></span>

<h3>Description</h3>

<p>Converts an interest rate from one compounding convention to
another (for example from semi-annual to monthly compounding or
from annual to continuous compounding)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equiv.rate(rate, from.freq = 1, to.freq = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equiv.rate_+3A_rate">rate</code></td>
<td>
<p>The interest rate in decimal (0.10 or 10e-2 for 10%)</p>
</td></tr>
<tr><td><code id="equiv.rate_+3A_from.freq">from.freq</code></td>
<td>
<p>Frequency of compounding of the given interest
rate: 1 for annual, 2 for semi-annual, 12 for monthly, Inf for
continuous compounding.</p>
</td></tr>
<tr><td><code id="equiv.rate_+3A_to.freq">to.freq</code></td>
<td>
<p>Frequency of compounding to which the given
interest rate is to be converted: 1 for annual, 2 for
semi-annual, 12 for monthly, <code>Inf</code> for continuous
compounding.</p>
</td></tr>
</table>

<hr>
<h2 id='GenBS'>Generalized Black Scholes model for pricing vanilla European options</h2><span id='topic+GenBS'></span>

<h3>Description</h3>

<p>Compute values of call and put options as well as the Greeks -
the sensitivities of the option price to various input arguments using the
Generalized Black Scholes model. &quot;Generalized&quot; means that the asset can
have a continuous dividend yield.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenBS(s, X, r, Sigma, t, div_yield = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenBS_+3A_s">s</code></td>
<td>
<p>the spot price of the asset (the stock price for options on stocks)</p>
</td></tr>
<tr><td><code id="GenBS_+3A_x">X</code></td>
<td>
<p>the exercise or strike price of the option</p>
</td></tr>
<tr><td><code id="GenBS_+3A_r">r</code></td>
<td>
<p>the continuously compounded rate of interest in decimal (0.10 or 10e-2 for 10%)
(use <code><a href="#topic+equiv.rate">equiv.rate</a></code> to convert to a continuously compounded rate)</p>
</td></tr>
<tr><td><code id="GenBS_+3A_sigma">Sigma</code></td>
<td>
<p>the volatility of the asset price in decimal  (0.20 or 20e-2 for 20%)</p>
</td></tr>
<tr><td><code id="GenBS_+3A_t">t</code></td>
<td>
<p>the maturity of the option in years</p>
</td></tr>
<tr><td><code id="GenBS_+3A_div_yield">div_yield</code></td>
<td>
<p>the continuously compounded dividend yield (0.05 or 5e-2 for 5%)
(use <code><a href="#topic+equiv.rate">equiv.rate</a></code> to convert to a continuously compounded rate)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Generalized Black Scholes formula for call options is <br />
<code class="reqn">e^{-r t} (s \;  e^{g t} \; Nd1 - X \; Nd2)</code> <br />
where <br />
<code class="reqn">g = r - div\_yield</code> <br />
<code class="reqn">Nd1 = N(d1)</code> and <code class="reqn">Nd2 = N(d2)</code> <br />
<code class="reqn">d1 = \frac{log(s / X) + (g + Sigma^2/ 2)  t}{Sigma \sqrt{t}}</code> <br />
<code class="reqn">d2 = d1 - Sigma \sqrt{t}</code> <br />
N denotes the normal CDF (<code><a href="stats.html#topic+pnorm">pnorm</a></code>)<br />
For put options, the formula is <br />
<code class="reqn">e^{-r t}  (-s \; e^{g  t} \; Nminusd1 + X \;  Nminusd2)</code><br />
where <br />
<code class="reqn">Nminusd1 = N(-d1)</code> and <code class="reqn">Nminusd2 = N(-d2)</code> <br />
</p>


<h3>Value</h3>

<p>A list of the following elements
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the value of a call option</p>
</td></tr>
<tr><td><code>put</code></td>
<td>
<p>the value of a put option</p>
</td></tr>
<tr><td><code>Greeks</code></td>
<td>
<p>a list of the following elements</p>
</td></tr>
<tr><td><code>Greeks$callDelta</code></td>
<td>
<p>the delta of a call option - the sensitivity to the spot price of the asset</p>
</td></tr>
<tr><td><code>Greeks$putDelta</code></td>
<td>
<p>the delta of a put option - the sensitivity to the spot price of the asset</p>
</td></tr>
<tr><td><code>Greeks$callTheta</code></td>
<td>
<p>the theta of a call option - the time decay of the option value
with passage of time. Note that time is measured in years. To find a daily theta divided by 365.</p>
</td></tr>
<tr><td><code>Greeks$putTheta</code></td>
<td>
<p>the theta of a put option</p>
</td></tr>
<tr><td><code>Greeks$Gamma</code></td>
<td>
<p>the gamma of a call or put option - the second derivative with respect to the spot price
or the sensitivity of delta to the spot price</p>
</td></tr>
<tr><td><code>Greeks$Vega</code></td>
<td>
<p>the vega of a call or put option - the sensitivity to the volatility</p>
</td></tr>
<tr><td><code>Greeks$callRho</code></td>
<td>
<p>the rho of a call option - the sensitivity to the interest rate</p>
</td></tr>
<tr><td><code>Greeks$putRho</code></td>
<td>
<p>the rho of a put option - the sensitivity to the interest rate</p>
</td></tr>
<tr><td><code>extra</code></td>
<td>
<p>a list of the following elements</p>
</td></tr>
<tr><td><code>extra$d1</code></td>
<td>
<p>the d1 of the Generalized Black Scholes formula</p>
</td></tr>
<tr><td><code>extra$d2</code></td>
<td>
<p>the d2 of the Generalized Black Scholes formula</p>
</td></tr>
<tr><td><code>extra$Nd1</code></td>
<td>
<p>is <code><a href="stats.html#topic+pnorm">pnorm</a></code>(d1)</p>
</td></tr>
<tr><td><code>extra$Nd2</code></td>
<td>
<p>is <code><a href="stats.html#topic+pnorm">pnorm</a></code>(d2)</p>
</td></tr>
<tr><td><code>extra$Nminusd1</code></td>
<td>
<p>is <code><a href="stats.html#topic+pnorm">pnorm</a></code>(-d1)</p>
</td></tr>
<tr><td><code>extra$Nminusd2</code></td>
<td>
<p>is <code><a href="stats.html#topic+pnorm">pnorm</a></code>(-d2)</p>
</td></tr>
<tr><td><code>extra$callProb</code></td>
<td>
<p>the (risk neutral) probability that the call will be exercised = <code>Nd2</code></p>
</td></tr>
<tr><td><code>extra$putProb</code></td>
<td>
<p>the (risk neutral) probability that the put will be exercised = <code>Nminusd2</code></p>
</td></tr>
</table>

<hr>
<h2 id='GenBSImplied'>Generalized Black Scholes model implied volatility</h2><span id='topic+GenBSImplied'></span>

<h3>Description</h3>

<p>Find implied volatility given the option price using the generalized Black Scholes model.
&quot;Generalized&quot; means that the asset can have a continuous dividend yield.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenBSImplied(
  s,
  X,
  r,
  price,
  t,
  div_yield,
  PutOpt = FALSE,
  toler = 1e-06,
  max.iter = 100,
  convergence = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenBSImplied_+3A_s">s</code></td>
<td>
<p>the spot price of the asset (the stock price for options on stocks)</p>
</td></tr>
<tr><td><code id="GenBSImplied_+3A_x">X</code></td>
<td>
<p>the exercise or strike price of the option</p>
</td></tr>
<tr><td><code id="GenBSImplied_+3A_r">r</code></td>
<td>
<p>the continuously compounded rate of interest in decimal (0.10 or 10e-2 for 10%)
(use <code><a href="#topic+equiv.rate">equiv.rate</a></code> to convert to a continuously compounded rate)</p>
</td></tr>
<tr><td><code id="GenBSImplied_+3A_price">price</code></td>
<td>
<p>the price of the option</p>
</td></tr>
<tr><td><code id="GenBSImplied_+3A_t">t</code></td>
<td>
<p>the maturity of the option in years</p>
</td></tr>
<tr><td><code id="GenBSImplied_+3A_div_yield">div_yield</code></td>
<td>
<p>the continuously compounded dividend yield (0.05 or 5e-2 for 5%)
(use <code><a href="#topic+equiv.rate">equiv.rate</a></code> to convert to a continuously compounded rate)</p>
</td></tr>
<tr><td><code id="GenBSImplied_+3A_putopt">PutOpt</code></td>
<td>
<p><code>TRUE</code> for put options, <code>FALSE</code> for call options</p>
</td></tr>
<tr><td><code id="GenBSImplied_+3A_toler">toler</code></td>
<td>
<p>passed on to <code><a href="#topic+newton.raphson.root">newton.raphson.root</a></code>
The implied volatility is regarded as correct if the solver is able to
match the option price to within less than <code>toler</code>. Otherwise the function returns <code>NA</code></p>
</td></tr>
<tr><td><code id="GenBSImplied_+3A_max.iter">max.iter</code></td>
<td>
<p>passed on to <code><a href="#topic+newton.raphson.root">newton.raphson.root</a></code></p>
</td></tr>
<tr><td><code id="GenBSImplied_+3A_convergence">convergence</code></td>
<td>
<p>passed on to <code><a href="#topic+newton.raphson.root">newton.raphson.root</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>GenBSImplied</code> calls <code><a href="#topic+newton.raphson.root">newton.raphson.root</a></code> and
if that fails <code><a href="stats.html#topic+uniroot">uniroot</a></code>
</p>

<hr>
<h2 id='irr'>Internal Rate of Return</h2><span id='topic+irr'></span>

<h3>Description</h3>

<p>Computes IRR (Internal Rate of Return) for cash flows with different cash flow and
compounding conventions. Cash flows need not be evenly spaced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irr(
  cf,
  interval = NULL,
  cf.freq = 1,
  comp.freq = 1,
  cf.t = seq(from = 0, by = 1/cf.freq, along.with = cf),
  r.guess = NULL,
  toler = 1e-06,
  convergence = 1e-08,
  max.iter = 100,
  method = c("default", "newton", "bisection")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irr_+3A_cf">cf</code></td>
<td>
<p>Vector of cash flows</p>
</td></tr>
<tr><td><code id="irr_+3A_interval">interval</code></td>
<td>
<p>the interval c(lower, upper) within which to
search for the IRR</p>
</td></tr>
<tr><td><code id="irr_+3A_cf.freq">cf.freq</code></td>
<td>
<p>Frequency of annuity payments: 1 for annual, 2 for
semi-annual, 12 for monthly.</p>
</td></tr>
<tr><td><code id="irr_+3A_comp.freq">comp.freq</code></td>
<td>
<p>Frequency of compounding of interest rates: 1 for annual,
2 for semi-annual, 12 for monthly, Inf for continuous compounding.</p>
</td></tr>
<tr><td><code id="irr_+3A_cf.t">cf.t</code></td>
<td>
<p>Optional vector of timing (in years) of cash flows. If omitted
regular sequence of years is assumed.</p>
</td></tr>
<tr><td><code id="irr_+3A_r.guess">r.guess</code></td>
<td>
<p>the starting value (guess) from which the solver
starts searching for the IRR</p>
</td></tr>
<tr><td><code id="irr_+3A_toler">toler</code></td>
<td>
<p>the argument <code>toler</code> for
<code><a href="#topic+irr.solve">irr.solve</a></code>.  The IRR is regarded as correct if
abs(NPV) is less than <code>toler</code>.  Otherwise the <code>irr</code>
function returns <code>NA</code></p>
</td></tr>
<tr><td><code id="irr_+3A_convergence">convergence</code></td>
<td>
<p>the argument <code>convergence</code> for
<code><a href="#topic+irr.solve">irr.solve</a></code></p>
</td></tr>
<tr><td><code id="irr_+3A_max.iter">max.iter</code></td>
<td>
<p>the argument <code>max.iter</code> for
<code><a href="#topic+irr.solve">irr.solve</a></code></p>
</td></tr>
<tr><td><code id="irr_+3A_method">method</code></td>
<td>
<p>The root finding method to be used. The
<code>default</code> is to try Newton-Raphson method
(<code><a href="#topic+newton.raphson.root">newton.raphson.root</a></code>) and if that fails to try
bisection (<code><a href="#topic+bisection.root">bisection.root</a></code>). The other two
choices (<code>newton</code> and <code>bisection</code> force only one of
the methods to be tried.</p>
</td></tr>
</table>

<hr>
<h2 id='irr.solve'>Solve for IRR (internal rate of return) or YTM (yield to maturity)</h2><span id='topic+irr.solve'></span>

<h3>Description</h3>

<p>This function computes the internal rate of return at which the
net present value equals zero. It requires as input a function
that computes the net present value of a series of cash flows for
a given interest rate as well as the derivative of the NPV with
respect to the interest rate (10,000 times this derivative is the
PVBP or DV01).  In this package, <code>irr.solve</code> is primarily
intended to be called by the <code><a href="#topic+irr">irr</a></code> and
<code><a href="#topic+bond.yield">bond.yield</a></code> functions. It is made available for those
who want to find IRR of more complex instruments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irr.solve(
  f,
  interval = NULL,
  r.guess = NULL,
  toler = 1e-06,
  convergence = 1e-08,
  max.iter = 100,
  method = c("default", "newton", "bisection")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irr.solve_+3A_f">f</code></td>
<td>
<p>The function whose zero is to be found. An R function
object that takes one numeric argument and returns a list of
two components (value and gradient). In the IRR applications,
these two components will be the NPV and its derivative</p>
</td></tr>
<tr><td><code id="irr.solve_+3A_interval">interval</code></td>
<td>
<p>The interval c(lower, upper) within which to
search for the IRR</p>
</td></tr>
<tr><td><code id="irr.solve_+3A_r.guess">r.guess</code></td>
<td>
<p>The starting value (guess) from which the solver
starts searching for the IRR</p>
</td></tr>
<tr><td><code id="irr.solve_+3A_toler">toler</code></td>
<td>
<p>The argument <code>toler</code> to
<code><a href="#topic+newton.raphson.root">newton.raphson.root</a></code>.  The IRR is regarded as
correct if abs(NPV) is less than <code>toler</code>.  Otherwise the
<code>irr.solve</code> returns <code>NA</code></p>
</td></tr>
<tr><td><code id="irr.solve_+3A_convergence">convergence</code></td>
<td>
<p>The argument <code>convergence</code> to
<code><a href="#topic+newton.raphson.root">newton.raphson.root</a></code>.</p>
</td></tr>
<tr><td><code id="irr.solve_+3A_max.iter">max.iter</code></td>
<td>
<p>The maximum number of iterations of the
Newton-Raphson procedure</p>
</td></tr>
<tr><td><code id="irr.solve_+3A_method">method</code></td>
<td>
<p>The root finding method to be used. The
<code>default</code> is to try Newton-Raphson method
(<code><a href="#topic+newton.raphson.root">newton.raphson.root</a></code>) and if that fails to try
bisection (<code><a href="#topic+bisection.root">bisection.root</a></code>). The other two
choices (<code>newton</code> and <code>bisection</code> force only one of
the methods to be tried.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>irr.solve</code> is basically an interface to the
general root finder <code><a href="#topic+newton.raphson.root">newton.raphson.root</a></code>. However, if
<code><a href="#topic+newton.raphson.root">newton.raphson.root</a></code> fails, <code>irr.solve</code> makes an
attempt to find the root using <code><a href="stats.html#topic+uniroot">uniroot</a></code> from the R
stats package. <code>Uniroot</code> uses bisection and it requires the root to
be bracketed (the function must be of opposite sign at the two end
points - lower and upper).
</p>


<h3>Value</h3>

<p>The function <code>irr.solve</code> returns <code>NA</code> if the IRR/YTM
could not be found. Otherwise it returns the IRR/YTM. When
<code>NA</code> is returned, a warning message is printed
</p>


<h3>Author(s)</h3>

<p>Prof. Jayanth R. Varma <a href="mailto:jrvarma@iima.ac.in">jrvarma@iima.ac.in</a>
</p>

<hr>
<h2 id='jrvFinance-package'>Basic Finance: NPV/IRR/annuities, bond pricing, Black Scholes</h2><span id='topic+jrvFinance-package'></span><span id='topic+jrvFinance'></span>

<h3>Description</h3>

<p>This package implements the basic financial analysis functions
similar to (but not identical to) what is available in most
spreadsheet software.  This includes finding the IRR, NPV and
duration of possibly irregularly spaced cash flows and
annuities. Bond pricing, YTM and duration calculations are
included. Black Scholes option pricing, Greeks and implied
volatility are also provided.
</p>


<h3>Details</h3>

<p>Important functions include:
</p>
<p><code><a href="#topic+npv">npv</a></code>, <code><a href="#topic+irr">irr</a></code>, <code><a href="#topic+duration">duration</a></code>, 
<code><a href="#topic+annuity.pv">annuity.pv</a></code>, <code><a href="#topic+bond.price">bond.price</a></code>, <code><a href="#topic+bond.yield">bond.yield</a></code>,
<code><a href="#topic+GenBS">GenBS</a></code>, <code><a href="#topic+GenBSImplied">GenBSImplied</a></code>
</p>
<p>For more details, see the vignette
</p>


<h3>Author(s)</h3>

<p>Prof. Jayanth R. Varma <a href="mailto:jrvarma@iima.ac.in">jrvarma@iima.ac.in</a>
</p>


<h3>References</h3>

<p>The 30/360 day count was converted from C++ code in the QuantLib library.
The Newton Raphson solver was converted from C++ code in the Boost library
</p>

<hr>
<h2 id='newton.raphson.root'>A Newton Raphson root finder: finds x such that f(x) = 0</h2><span id='topic+newton.raphson.root'></span>

<h3>Description</h3>

<p>The function <code>newton.raphson.root</code> is a general root finder which
can find the zero of any function whose derivative is available.
In this package, it is called by <code><a href="#topic+irr.solve">irr.solve</a></code> and by
<code><a href="#topic+GenBSImplied">GenBSImplied</a></code>. It can be used in other situations as
well - see the examples below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newton.raphson.root(
  f,
  guess = 0,
  lower = -Inf,
  upper = Inf,
  max.iter = 100,
  toler = 1e-06,
  convergence = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newton.raphson.root_+3A_f">f</code></td>
<td>
<p>The function whose zero is to be found. An R function
object that takes one numeric argument and returns a list of
two components (value and gradient). In an IRR application,
these two components will be the NPV and the DV01/10000. In an
implied volatility application, the components will be the
option price and the vega. See also the examples below</p>
</td></tr>
<tr><td><code id="newton.raphson.root_+3A_guess">guess</code></td>
<td>
<p>The starting value (guess) from which the solver
starts searching for the IRR</p>
</td></tr>
<tr><td><code id="newton.raphson.root_+3A_lower">lower</code></td>
<td>
<p>The lower end of the interval within which to search
for the root</p>
</td></tr>
<tr><td><code id="newton.raphson.root_+3A_upper">upper</code></td>
<td>
<p>The upper end of the interval within which to search
for the root</p>
</td></tr>
<tr><td><code id="newton.raphson.root_+3A_max.iter">max.iter</code></td>
<td>
<p>The maximum number of iterations of the
Newton-Raphson procedure</p>
</td></tr>
<tr><td><code id="newton.raphson.root_+3A_toler">toler</code></td>
<td>
<p>The criterion to determine whether a zero has been
found. If the value of the function exceeds <code>toler</code> in
absolute value, then <code>NA</code> is returned with a warning</p>
</td></tr>
<tr><td><code id="newton.raphson.root_+3A_convergence">convergence</code></td>
<td>
<p>The relative tolerance threshold used to
determine whether the Newton-Raphson procedure has
converged. The procedure terminates when the last step is less
than <code>convergence</code> times the current estimate of the
root. Convergence can take place to a non zero local
minimum. This is checked using the <code>toler</code> criterion
below</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns <code>NA</code> under either of two conditions: (a)
the procedure did not converge after <code>max.iter</code> iterations,
or (b) the procedure converged but the function value is not zero
within the limits of <code>toler</code> at this point. The second
condition usually implies that the procedure has converged to a
non zero local minimum from which there is no downhill gradient.
</p>
<p>If the iterations converge to a genuine root (within the limits of
<code>toler</code>), then it returns the root that was found.
</p>


<h3>References</h3>

<p>The Newton Raphson solver was converted from C++ code
in the <a href="https://www.boost.org/">Boost library</a>
</p>

<hr>
<h2 id='npv'>Net Present Value</h2><span id='topic+npv'></span>

<h3>Description</h3>

<p>Computes NPV (Net Present Value) for cash flows with different cash flow and
compounding conventions. Cash flows need not be evenly spaced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npv(
  cf,
  rate,
  cf.freq = 1,
  comp.freq = 1,
  cf.t = seq(from = if (immediate.start) 0 else 1/cf.freq, by = 1/cf.freq, along.with =
    cf),
  immediate.start = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="npv_+3A_cf">cf</code></td>
<td>
<p>Vector of cash flows</p>
</td></tr>
<tr><td><code id="npv_+3A_rate">rate</code></td>
<td>
<p>The interest rate in decimal (0.10 or 10e-2 for 10%)</p>
</td></tr>
<tr><td><code id="npv_+3A_cf.freq">cf.freq</code></td>
<td>
<p>Frequency of annuity payments: 1 for annual, 2 for
semi-annual, 12 for monthly.</p>
</td></tr>
<tr><td><code id="npv_+3A_comp.freq">comp.freq</code></td>
<td>
<p>Frequency of compounding of interest rates: 1 for annual,
2 for semi-annual, 12 for monthly, Inf for continuous compounding.</p>
</td></tr>
<tr><td><code id="npv_+3A_cf.t">cf.t</code></td>
<td>
<p>Optional vector of timing (in years) of cash flows. If omitted
regular sequence of years is assumed.</p>
</td></tr>
<tr><td><code id="npv_+3A_immediate.start">immediate.start</code></td>
<td>
<p>Logical variable which is <code>TRUE</code> when the first cash
flows is at the beginning of the first period (for example, immediate
annuities) and <code>FALSE</code> when the first cash flows is at the end of the first
period (for example, deferred annuities)</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
