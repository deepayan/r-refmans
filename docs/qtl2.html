<!DOCTYPE html><html><head><title>Help for package qtl2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qtl2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#qtl2-package'><p>qtl2: Quantitative Trait Locus Mapping in Experimental Crosses</p></a></li>
<li><a href='#add_threshold'><p>Add thresholds to genome scan plot</p></a></li>
<li><a href='#align_scan1_map'><p>Internal functions</p></a></li>
<li><a href='#basic_summaries'><p>Basic summaries of a cross2 object</p></a></li>
<li><a href='#batch_cols'><p>Batch columns by pattern of missing values</p></a></li>
<li><a href='#batch_vec'><p>Split vector into batches</p></a></li>
<li><a href='#bayes_int'><p>Calculate Bayes credible intervals</p></a></li>
<li><a href='#calc_entropy'><p>Calculate entropy of genotype probability distribution</p></a></li>
<li><a href='#calc_errorlod'><p>Calculate genotyping error LOD scores</p></a></li>
<li><a href='#calc_geno_freq'><p>Calculate genotype frequencies</p></a></li>
<li><a href='#calc_genoprob'><p>Calculate conditional genotype probabilities</p></a></li>
<li><a href='#calc_grid'><p>Calculate indicators of which marker/pseudomarker positions are along a fixed grid</p></a></li>
<li><a href='#calc_het'><p>Calculate heterozygosities</p></a></li>
<li><a href='#calc_kinship'><p>Calculate kinship matrix</p></a></li>
<li><a href='#calc_raw_founder_maf'><p>Calculate founder minor allele frequencies from raw SNP genotypes</p></a></li>
<li><a href='#calc_raw_geno_freq'><p>Calculate genotype frequencies from raw SNP genotypes</p></a></li>
<li><a href='#calc_raw_het'><p>Calculate estimated heterozygosity from raw SNP genotypes</p></a></li>
<li><a href='#calc_raw_maf'><p>Calculate minor allele frequency from raw SNP genotypes</p></a></li>
<li><a href='#calc_sdp'><p>Calculate strain distribution pattern from SNP genotypes</p></a></li>
<li><a href='#cbind_expand'><p>Combine matrices by columns, expanding and aligning rows</p></a></li>
<li><a href='#cbind.calc_genoprob'><p>Join genotype probabilities for different chromosomes</p></a></li>
<li><a href='#cbind.scan1'><p>Join genome scan results for different phenotypes.</p></a></li>
<li><a href='#cbind.scan1perm'><p>Combine columns from multiple scan1 permutation results</p></a></li>
<li><a href='#cbind.sim_geno'><p>Join genotype imputations for different chromosomes</p></a></li>
<li><a href='#cbind.viterbi'><p>Join viterbi results for different chromosomes</p></a></li>
<li><a href='#CCcolors'><p>Collaborative Cross colors</p></a></li>
<li><a href='#check_cross2'><p>Check a cross2 object</p></a></li>
<li><a href='#chisq_colpairs'><p>Chi-square test on all pairs of columns</p></a></li>
<li><a href='#chr_lengths'><p>Calculate chromosome lengths</p></a></li>
<li><a href='#clean'><p>Clean an object</p></a></li>
<li><a href='#clean_genoprob'><p>Clean genotype probabilities</p></a></li>
<li><a href='#clean_scan1'><p>Clean scan1 output</p></a></li>
<li><a href='#compare_geno'><p>Compare individuals' genotype data</p></a></li>
<li><a href='#compare_genoprob'><p>Compare two sets of genotype probabilities</p></a></li>
<li><a href='#compare_maps'><p>Compare two marker maps</p></a></li>
<li><a href='#convert2cross2'><p>Convert R/qtl cross object to new format</p></a></li>
<li><a href='#count_xo'><p>Count numbers of crossovers</p></a></li>
<li><a href='#create_gene_query_func'><p>Create a function to query genes</p></a></li>
<li><a href='#create_snpinfo'><p>Create snp information table for a cross</p></a></li>
<li><a href='#create_variant_query_func'><p>Create a function to query variants</p></a></li>
<li><a href='#decomp_kinship'><p>Calculate eigen decomposition of kinship matrix</p></a></li>
<li><a href='#drop_markers'><p>Drop markers from a cross2 object</p></a></li>
<li><a href='#drop_nullmarkers'><p>Drop markers with no genotype data</p></a></li>
<li><a href='#est_herit'><p>Estimate heritability with a linear mixed model</p></a></li>
<li><a href='#est_map'><p>Estimate genetic maps</p></a></li>
<li><a href='#find_dup_markers'><p>Find markers with identical genotype data</p></a></li>
<li><a href='#find_ibd_segments'><p>Find IBD segments for a set of strains</p></a></li>
<li><a href='#find_index_snp'><p>Find name of indexed snp</p></a></li>
<li><a href='#find_map_gaps'><p>Find gaps in a genetic map</p></a></li>
<li><a href='#find_marker'><p>Find markers by chromosome position</p></a></li>
<li><a href='#find_markerpos'><p>Find positions of markers</p></a></li>
<li><a href='#find_peaks'><p>Find peaks in a set of LOD curves</p></a></li>
<li><a href='#fit1'><p>Fit single-QTL model at a single position</p></a></li>
<li><a href='#fread_csv'><p>Read a csv file</p></a></li>
<li><a href='#fread_csv_numer'><p>Read a csv file that has numeric columns</p></a></li>
<li><a href='#genoprob_to_alleleprob'><p>Convert genotype probabilities to allele probabilities</p></a></li>
<li><a href='#genoprob_to_snpprob'><p>Convert genotype probabilities to SNP probabilities</p></a></li>
<li><a href='#get_common_ids'><p>Get common set of IDs from objects</p></a></li>
<li><a href='#get_x_covar'><p>Get X chromosome covariates</p></a></li>
<li><a href='#guess_phase'><p>Guess phase of imputed genotypes</p></a></li>
<li><a href='#index_snps'><p>Create index of equivalent SNPs</p></a></li>
<li><a href='#insert_pseudomarkers'><p>Insert pseudomarkers into a marker map</p></a></li>
<li><a href='#interp_genoprob'><p>Interpolate genotype probabilities</p></a></li>
<li><a href='#interp_map'><p>Interpolate between maps</p></a></li>
<li><a href='#invert_sdp'><p>Calculate SNP genotype matrix from strain distribution patterns</p></a></li>
<li><a href='#locate_xo'><p>Locate crossovers</p></a></li>
<li><a href='#lod_int'><p>Calculate LOD support intervals</p></a></li>
<li><a href='#map_to_grid'><p>Subset a map to positions on a grid</p></a></li>
<li><a href='#mat2strata'><p>Define strata based on rows of a matrix</p></a></li>
<li><a href='#max_compare_geno'><p>Find pair with most similar genotypes</p></a></li>
<li><a href='#max_scan1'><p>Find position with maximum LOD score</p></a></li>
<li><a href='#maxlod'><p>Overall maximum LOD score</p></a></li>
<li><a href='#maxmarg'><p>Find genotypes with maximum marginal probabilities</p></a></li>
<li><a href='#n_missing'><p>Count missing genotypes</p></a></li>
<li><a href='#plot_coef'><p>Plot QTL effects along chromosome</p></a></li>
<li><a href='#plot_compare_geno'><p>Plot of compare_geno object.</p></a></li>
<li><a href='#plot_genes'><p>Plot gene locations for a genomic interval</p></a></li>
<li><a href='#plot_genoprob'><p>Plot genotype probabilities for one individual on one chromosome.</p></a></li>
<li><a href='#plot_genoprobcomp'><p>Plot comparison of two sets of genotype probabilities</p></a></li>
<li><a href='#plot_lodpeaks'><p>Plot LOD scores vs QTL peak locations</p></a></li>
<li><a href='#plot_onegeno'><p>Plot one individual's genome-wide genotypes</p></a></li>
<li><a href='#plot_peaks'><p>Plot QTL peak locations</p></a></li>
<li><a href='#plot_pxg'><p>Plot phenotype vs genotype</p></a></li>
<li><a href='#plot_scan1'><p>Plot a genome scan</p></a></li>
<li><a href='#plot_sdp'><p>plot strain distribution patterns for SNPs</p></a></li>
<li><a href='#plot_snpasso'><p>Plot SNP associations</p></a></li>
<li><a href='#predict_snpgeno'><p>Predict SNP genotypes</p></a></li>
<li><a href='#print.cross2'><p>Print a cross2 object</p></a></li>
<li><a href='#print.summary.scan1perm'><p>Print summary of scan1perm permutations</p></a></li>
<li><a href='#probs_to_grid'><p>Subset genotype probability array to pseudomarkers on a grid</p></a></li>
<li><a href='#pull_genoprobint'><p>Pull genotype probabilities for an interval</p></a></li>
<li><a href='#pull_genoprobpos'><p>Pull genotype probabilities for a particular position</p></a></li>
<li><a href='#pull_markers'><p>Drop all but a specified set of markers</p></a></li>
<li><a href='#qtl2version'><p>Installed version of R/qtl2</p></a></li>
<li><a href='#rbind.calc_genoprob'><p>Join genotype probabilities for different individuals</p></a></li>
<li><a href='#rbind.scan1'><p>Join genome scan results for different chromosomes.</p></a></li>
<li><a href='#rbind.scan1perm'><p>Combine data from scan1perm objects</p></a></li>
<li><a href='#rbind.sim_geno'><p>Join genotype imputations for different individuals</p></a></li>
<li><a href='#rbind.viterbi'><p>Join Viterbi results for different individuals</p></a></li>
<li><a href='#read_cross2'><p>Read QTL data from files</p></a></li>
<li><a href='#read_pheno'><p>Read phenotype data</p></a></li>
<li><a href='#recode_snps'><p>Recode SNPs by major allele</p></a></li>
<li><a href='#reduce_map_gaps'><p>Reduce the lengths of gaps in a map</p></a></li>
<li><a href='#reduce_markers'><p>Reduce markers to a subset of more-evenly-spaced ones</p></a></li>
<li><a href='#replace_ids'><p>Replace individual IDs</p></a></li>
<li><a href='#scale_kinship'><p>Scale kinship matrix</p></a></li>
<li><a href='#scan1'><p>Genome scan with a single-QTL model</p></a></li>
<li><a href='#scan1blup'><p>Calculate BLUPs of QTL effects in scan along one chromosome</p></a></li>
<li><a href='#scan1coef'><p>Calculate QTL effects in scan along one chromosome</p></a></li>
<li><a href='#scan1max'><p>Maximum LOD score from genome scan with a single-QTL model</p></a></li>
<li><a href='#scan1perm'><p>Permutation test for genome scan with a single-QTL model</p></a></li>
<li><a href='#scan1snps'><p>Single-QTL genome scan at imputed SNPs</p></a></li>
<li><a href='#sdp2char'><p>Convert strain distribution patterns to character strings</p></a></li>
<li><a href='#sim_geno'><p>Simulate genotypes given observed marker data</p></a></li>
<li><a href='#smooth_gmap'><p>Smooth genetic map</p></a></li>
<li><a href='#subset_scan1'><p>Subset scan1 output</p></a></li>
<li><a href='#subset.calc_genoprob'><p>Subsetting genotype probabilities</p></a></li>
<li><a href='#subset.cross2'><p>Subsetting data for a QTL experiment</p></a></li>
<li><a href='#subset.sim_geno'><p>Subsetting imputed genotypes</p></a></li>
<li><a href='#subset.viterbi'><p>Subsetting Viterbi results</p></a></li>
<li><a href='#summary_compare_geno'><p>Basic summary of compare_geno object</p></a></li>
<li><a href='#summary_scan1perm'><p>Summarize scan1perm results</p></a></li>
<li><a href='#summary.cross2'><p>Summary of cross2 object</p></a></li>
<li><a href='#top_snps'><p>Create table of top snp associations</p></a></li>
<li><a href='#unsmooth_gmap'><p>Unsmooth genetic map</p></a></li>
<li><a href='#viterbi'><p>Calculate most probable sequence of genotypes</p></a></li>
<li><a href='#write_control_file'><p>Write a control file for QTL data</p></a></li>
<li><a href='#xpos_scan1'><p>Get x-axis position for genomic location</p></a></li>
<li><a href='#zip_datafiles'><p>Zip a set of data files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.36</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-13</td>
</tr>
<tr>
<td>Title:</td>
<td>Quantitative Trait Locus Mapping in Experimental Crosses</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a set of tools to perform quantitative
    trait locus (QTL) analysis in experimental crosses. It is a
    reimplementation of the 'R/qtl' package to better handle
    high-dimensional data and complex cross designs.
    Broman et al. (2019) &lt;<a href="https://doi.org/10.1534%2Fgenetics.118.301595">doi:10.1534/genetics.118.301595</a>&gt;.</td>
</tr>
<tr>
<td>Author:</td>
<td>Karl W Broman <a href="https://orcid.org/0000-0002-4914-6671"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  R Core Team [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Karl W Broman &lt;broman@wisc.edu&gt;</td>
</tr>
<tr>
<td>Copyright:</td>
<td>Code for Brent's method for univariate function optimization
was taken from R 3.2.2 (Copyright 1995, 1996 Robert Gentleman
and Ross Ihaka, Copyright 2003-2004 The R Foundation, Copyright
1998-2014 The R Core Team).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.7), yaml (&ge; 2.1.13), jsonlite (&ge; 0.9.17),
data.table (&ge; 1.10.4-3), parallel, stats, utils, graphics,
grDevices, RSQLite</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, devtools, roxygen2, vdiffr, qtl</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://kbroman.org/qtl2/">https://kbroman.org/qtl2/</a>, <a href="https://github.com/rqtl/qtl2">https://github.com/rqtl/qtl2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rqtl/qtl2/issues">https://github.com/rqtl/qtl2/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-13 13:02:58 UTC; kbroman</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-13 14:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='qtl2-package'>qtl2: Quantitative Trait Locus Mapping in Experimental Crosses</h2><span id='topic+qtl2'></span><span id='topic+qtl2-package'></span>

<h3>Description</h3>

<p>Provides a set of tools to perform quantitative trait locus (QTL) analysis in experimental crosses. It is a reimplementation of the 'R/qtl' package to better handle high-dimensional data and complex cross designs. Broman et al. (2019) <a href="https://doi.org/10.1534/genetics.118.301595">doi:10.1534/genetics.118.301595</a>.
</p>


<h3>Vignettes</h3>


<ul>
<li> <p><a href="https://kbroman.org/qtl2/assets/vignettes/user_guide.html">user guide</a>
</p>
</li>
<li> <p><a href="https://kbroman.org/qtl2/pages/rqtl2_functions.html">categorized list of functions in R/qtl2</a>
</p>
</li>
<li> <p><a href="https://kbroman.org/qtl2/assets/vignettes/input_files.html">input file formats</a>
</p>
</li>
<li> <p><a href="https://kbroman.org/qtl2/assets/vignettes/qtl2fst.html">using qtl2fst for on-disk genotype probabilities</a>
</p>
</li>
<li> <p><a href="https://kbroman.org/qtl2/pages/prep_do_data.html">preparing DO mouse data for R/qtl2</a>
</p>
</li>
<li> <p><a href="https://kbroman.org/qtl2/assets/vignettes/do_diagnostics.html">genotype diagnostics for diversity outbred mice</a>
</p>
</li>
<li> <p><a href="https://kbroman.org/qtl2/assets/vignettes/do_mixups.html">identifying sample mix-ups in diversity outbred mice</a>
</p>
</li>
<li> <p><a href="https://kbroman.org/qtl2/assets/vignettes/rqtl_diff.html">differences between R/qtl and R/qtl2</a>
</p>
</li>
<li> <p><a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">developer guide</a>
</p>
</li>
<li> <p><a href="https://smcclatchy.github.io/mapping/">Tutorial on R/qtl2</a> by
<a href="https://github.com/smcclatchy">Susan McClatchy</a> and <a href="https://github.com/dmgatti">Dan Gatti</a>
</p>
</li></ul>



<h3>Related packages</h3>


<ul>
<li> <p><a href="https://github.com/rqtl/qtl2convert">qtl2convert</a>, for converting
data among the R/qtl2, DOQTL, and R/qtl formats
</p>
</li>
<li> <p><a href="https://github.com/rqtl/qtl2fst">qtl2fst</a>, for storing genotype
probabilities on disk
</p>
</li>
<li> <p><a href="https://github.com/byandell/qtl2ggplot">qtl2ggplot</a>,
for <a href="https://ggplot2.tidyverse.org/">ggplot2</a>-based data visualizations
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Karl W Broman <a href="mailto:broman@wisc.edu">broman@wisc.edu</a> (<a href="https://orcid.org/0000-0002-4914-6671">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> R Core Team [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://kbroman.org/qtl2/">https://kbroman.org/qtl2/</a>
</p>
</li>
<li> <p><a href="https://github.com/rqtl/qtl2">https://github.com/rqtl/qtl2</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/rqtl/qtl2/issues">https://github.com/rqtl/qtl2/issues</a>
</p>
</li></ul>


<hr>
<h2 id='add_threshold'>Add thresholds to genome scan plot</h2><span id='topic+add_threshold'></span>

<h3>Description</h3>

<p>Draw line segments at significance thresholds for a genome scan plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_threshold(map, thresholdA, thresholdX = NULL, chr = NULL, gap = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_threshold_+3A_map">map</code></td>
<td>
<p>Marker map used in the genome scan plot</p>
</td></tr>
<tr><td><code id="add_threshold_+3A_thresholda">thresholdA</code></td>
<td>
<p>Autosomal threshold. Numeric or a list. (If a
list, the <code>"A"</code> component is taken to be <code>thresholdA</code> and the
<code>"X"</code> component is taken to be <code>thresholdX</code>.)</p>
</td></tr>
<tr><td><code id="add_threshold_+3A_thresholdx">thresholdX</code></td>
<td>
<p>X chromosome threshold (if missing, assumed to be the same as <code>thresholdA</code>)</p>
</td></tr>
<tr><td><code id="add_threshold_+3A_chr">chr</code></td>
<td>
<p>Chromosomes that were included in the plot</p>
</td></tr>
<tr><td><code id="add_threshold_+3A_gap">gap</code></td>
<td>
<p>Gap between chromosomes in the plot. Default is 1% of the total genome length.</p>
</td></tr>
<tr><td><code id="add_threshold_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="graphics.html#topic+segments">graphics::segments()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))

map &lt;- insert_pseudomarkers(iron$gmap, step=5)
probs &lt;- calc_genoprob(iron, map, error_prob=0.002)
Xcovar &lt;- get_x_covar(iron)
out &lt;- scan1(probs, iron$pheno[,1], Xcovar=Xcovar)
# run just 3 permutations, as a fast illustration
operm &lt;- scan1perm(probs, iron$pheno[,1], addcovar=Xcovar,
                   n_perm=3, perm_Xsp=TRUE, chr_lengths=chr_lengths(map))

plot(out, map)
add_threshold(map, summary(operm), col="violetred", lty=2)
</code></pre>

<hr>
<h2 id='align_scan1_map'>Internal functions</h2><span id='topic+align_scan1_map'></span><span id='topic+qtl2-internal'></span>

<h3>Description</h3>

<p>Functions that are exported and so available to users but not really intended to be used by a typical user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>align_scan1_map(scan1_output, map)
</code></pre>


<h3>Functions</h3>


<ul>
<li> <p><code>align_scan1_map()</code>: Align <code>scan1()</code> output with a map
</p>
</li></ul>

<hr>
<h2 id='basic_summaries'>Basic summaries of a cross2 object</h2><span id='topic+basic_summaries'></span><span id='topic+n_ind'></span><span id='topic+n_ind_geno'></span><span id='topic+n_ind_pheno'></span><span id='topic+n_ind_covar'></span><span id='topic+n_ind_gnp'></span><span id='topic+ind_ids'></span><span id='topic+ind_ids_geno'></span><span id='topic+ind_ids_pheno'></span><span id='topic+ind_ids_covar'></span><span id='topic+ind_ids_gnp'></span><span id='topic+n_chr'></span><span id='topic+n_founders'></span><span id='topic+founders'></span><span id='topic+chr_names'></span><span id='topic+tot_mar'></span><span id='topic+n_mar'></span><span id='topic+marker_names'></span><span id='topic+n_pheno'></span><span id='topic+pheno_names'></span><span id='topic+n_covar'></span><span id='topic+covar_names'></span><span id='topic+n_phenocovar'></span><span id='topic+phenocovar_names'></span>

<h3>Description</h3>

<p>Basic summaries of a cross2 object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_ind(cross2)

n_ind_geno(cross2)

n_ind_pheno(cross2)

n_ind_covar(cross2)

n_ind_gnp(cross2)

ind_ids(cross2)

ind_ids_geno(cross2)

ind_ids_pheno(cross2)

ind_ids_covar(cross2)

ind_ids_gnp(cross2)

n_chr(cross2)

n_founders(cross2)

founders(cross2)

chr_names(cross2)

tot_mar(cross2)

n_mar(cross2)

marker_names(cross2)

n_pheno(cross2)

pheno_names(cross2)

n_covar(cross2)

covar_names(cross2)

n_phenocovar(cross2)

phenocovar_names(cross2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basic_summaries_+3A_cross2">cross2</code></td>
<td>
<p>An object of class <code>"cross2"</code>, as output by <code><a href="#topic+read_cross2">read_cross2()</a></code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Variously a number, vector of numbers, or vector of character strings.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>n_ind()</code>: Number of individuals (either genotyped or phenotyped)
</p>
</li>
<li> <p><code>n_ind_geno()</code>: Number of genotyped individuals
</p>
</li>
<li> <p><code>n_ind_pheno()</code>: Number of phenotyped individuals
</p>
</li>
<li> <p><code>n_ind_covar()</code>: Number of individuals with covariate data
</p>
</li>
<li> <p><code>n_ind_gnp()</code>: Number of individuals with both genotype and phenotype data
</p>
</li>
<li> <p><code>ind_ids()</code>: IDs of individuals (either genotyped or phenotyped)
</p>
</li>
<li> <p><code>ind_ids_geno()</code>: IDs of genotyped individuals
</p>
</li>
<li> <p><code>ind_ids_pheno()</code>: IDs of phenotyped individuals
</p>
</li>
<li> <p><code>ind_ids_covar()</code>: IDs of individuals with covariate data
</p>
</li>
<li> <p><code>ind_ids_gnp()</code>: IDs of individuals with both genotype and phenotype data
</p>
</li>
<li> <p><code>n_chr()</code>: Number of chromosomes
</p>
</li>
<li> <p><code>n_founders()</code>: Number of founder strains
</p>
</li>
<li> <p><code>founders()</code>: Names of founder strains
</p>
</li>
<li> <p><code>chr_names()</code>: Chromosome names
</p>
</li>
<li> <p><code>tot_mar()</code>: Total number of markers
</p>
</li>
<li> <p><code>n_mar()</code>: Number of markers on each chromosome
</p>
</li>
<li> <p><code>marker_names()</code>: Marker names
</p>
</li>
<li> <p><code>n_pheno()</code>: Number of phenotypes
</p>
</li>
<li> <p><code>pheno_names()</code>: Phenotype names
</p>
</li>
<li> <p><code>n_covar()</code>: Number of covariates
</p>
</li>
<li> <p><code>covar_names()</code>: Covariate names
</p>
</li>
<li> <p><code>n_phenocovar()</code>: Number of phenotype covariates
</p>
</li>
<li> <p><code>phenocovar_names()</code>: Phenotype covariate names
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+summary.cross2">summary.cross2()</a></code>
</p>

<hr>
<h2 id='batch_cols'>Batch columns by pattern of missing values</h2><span id='topic+batch_cols'></span>

<h3>Description</h3>

<p>Identify batches of columns of a matrix that have the same pattern
of missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batch_cols(mat, max_batch = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="batch_cols_+3A_mat">mat</code></td>
<td>
<p>A numeric matrix</p>
</td></tr>
<tr><td><code id="batch_cols_+3A_max_batch">max_batch</code></td>
<td>
<p>Maximum batch size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the batches, each with two components:
<code>cols</code> containing numeric indices of the columns in the
corresponding batch, and <code>omit</code> containing a vector of row indices
that have missing values in this batch.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+batch_vec">batch_vec()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rbind(c( 1,  2,  3, 13, 16),
           c( 4,  5,  6, 14, 17),
           c( 7, NA,  8, NA, 18),
           c(NA, NA, NA, NA, 19),
           c(10, 11, 12, 15, 20))
batch_cols(x)
</code></pre>

<hr>
<h2 id='batch_vec'>Split vector into batches</h2><span id='topic+batch_vec'></span>

<h3>Description</h3>

<p>Split a vector into batches, each no longer than <code>batch_size</code> and
creating at least <code>n_cores</code> batches, for use in parallel
calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batch_vec(vec, batch_size = NULL, n_cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="batch_vec_+3A_vec">vec</code></td>
<td>
<p>A vector to be split into batches</p>
</td></tr>
<tr><td><code id="batch_vec_+3A_batch_size">batch_size</code></td>
<td>
<p>Maximum size for each batch</p>
</td></tr>
<tr><td><code id="batch_vec_+3A_n_cores">n_cores</code></td>
<td>
<p>Number of compute cores, to be used as a minimum number of batches.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors, each no longer than <code>batch_size</code>, and with at least <code>n_cores</code> componenets.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+batch_cols">batch_cols()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vec_split &lt;- batch_vec(1:304, 50, 8)
vec_split2 &lt;- batch_vec(1:304, 50)
</code></pre>

<hr>
<h2 id='bayes_int'>Calculate Bayes credible intervals</h2><span id='topic+bayes_int'></span>

<h3>Description</h3>

<p>Calculate Bayes credible intervals for a single LOD curve on a single
chromosome, with the ability to identify intervals for multiple LOD
peaks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayes_int(
  scan1_output,
  map,
  chr = NULL,
  lodcolumn = 1,
  threshold = 0,
  peakdrop = Inf,
  prob = 0.95,
  expand2markers = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayes_int_+3A_scan1_output">scan1_output</code></td>
<td>
<p>An object of class <code>"scan1"</code> as returned by
<code><a href="#topic+scan1">scan1()</a></code>.</p>
</td></tr>
<tr><td><code id="bayes_int_+3A_map">map</code></td>
<td>
<p>A list of vectors of marker positions, as produced by
<code><a href="#topic+insert_pseudomarkers">insert_pseudomarkers()</a></code>.</p>
</td></tr>
<tr><td><code id="bayes_int_+3A_chr">chr</code></td>
<td>
<p>Chromosome ID to consider (must be a single value).</p>
</td></tr>
<tr><td><code id="bayes_int_+3A_lodcolumn">lodcolumn</code></td>
<td>
<p>LOD score column to consider (must be a single value).</p>
</td></tr>
<tr><td><code id="bayes_int_+3A_threshold">threshold</code></td>
<td>
<p>Minimum LOD score for a peak.</p>
</td></tr>
<tr><td><code id="bayes_int_+3A_peakdrop">peakdrop</code></td>
<td>
<p>Amount that the LOD score must drop between peaks,
if multiple peaks are to be defined on a chromosome.</p>
</td></tr>
<tr><td><code id="bayes_int_+3A_prob">prob</code></td>
<td>
<p>Nominal coverage for the interval.</p>
</td></tr>
<tr><td><code id="bayes_int_+3A_expand2markers">expand2markers</code></td>
<td>
<p>If TRUE, QTL intervals are expanded so
that their endpoints are at genetic markers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We identify a set of peaks defined as local maxima that
exceed the specified <code>threshold</code>, with the requirement that
the LOD score must have dropped by at least <code>peakdrop</code> below
the lowest of any two adjacent peaks.
</p>
<p>At a given peak, if there are ties, with multiple positions jointly
achieving the maximum LOD score, we take the average of these
positions as the location of the peak.
</p>
<p>The default is to use <code>threshold=0</code>, <code>peakdrop=Inf</code>, and
<code>prob=0.95</code>. We then return results a single peak, no matter the
maximum LOD score, and give a 95% Bayes credible interval.
</p>


<h3>Value</h3>

<p>A matrix with three columns:
</p>

<ul>
<li> <p><code>ci_lo</code> - lower bound of interval
</p>
</li>
<li> <p><code>pos</code> - peak position
</p>
</li>
<li> <p><code>ci_hi</code> - upper bound of interval
</p>
</li></ul>

<p>Each row corresponds to a different peak.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lod_int">lod_int()</a></code>, <code><a href="#topic+find_peaks">find_peaks()</a></code>, <code><a href="#topic+scan1">scan1()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))


# insert pseudomarkers into map
map &lt;- insert_pseudomarkers(iron$gmap, step=1)

# calculate genotype probabilities
probs &lt;- calc_genoprob(iron, map, error_prob=0.002)

# grab phenotypes and covariates; ensure that covariates have names attribute
pheno &lt;- iron$pheno
covar &lt;- match(iron$covar$sex, c("f", "m")) # make numeric
names(covar) &lt;- rownames(iron$covar)
Xcovar &lt;- get_x_covar(iron)

# perform genome scan
out &lt;- scan1(probs, pheno, addcovar=covar, Xcovar=Xcovar)

# 95% Bayes credible interval for QTL on chr 7, first phenotype
bayes_int(out, map, chr=7, lodcolum=1)
</code></pre>

<hr>
<h2 id='calc_entropy'>Calculate entropy of genotype probability distribution</h2><span id='topic+calc_entropy'></span>

<h3>Description</h3>

<p>For each individual at each genomic position, calculate the entropy
of the genotype probability distribution, as a quantitative summary
of the amount of missing information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_entropy(probs, quiet = TRUE, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_entropy_+3A_probs">probs</code></td>
<td>
<p>Genotype probabilities, as calculated from
<code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.</p>
</td></tr>
<tr><td><code id="calc_entropy_+3A_quiet">quiet</code></td>
<td>
<p>IF <code>FALSE</code>, print progress messages.</p>
</td></tr>
<tr><td><code id="calc_entropy_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We calculate -sum(p log_2 p), where we take 0 log 0 = 0.
</p>


<h3>Value</h3>

<p>A list of matrices (each matrix is a chromosome and is arranged as individuals x markers).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))

probs &lt;- calc_genoprob(grav2, error_prob=0.002)
e &lt;- calc_entropy(probs)
e &lt;- do.call("cbind", e) # combine chromosomes into one big matrix

# summarize by individual
mean_ind &lt;- rowMeans(e)

# summarize by marker
mean_marker &lt;- colMeans(e)
</code></pre>

<hr>
<h2 id='calc_errorlod'>Calculate genotyping error LOD scores</h2><span id='topic+calc_errorlod'></span>

<h3>Description</h3>

<p>Use the genotype probabilities calculated with
<code><a href="#topic+calc_genoprob">calc_genoprob()</a></code> to calculate genotyping error LOD
scores, to help identify potential genotyping errors (and problem
markers and/or individuals).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_errorlod(cross, probs, quiet = TRUE, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_errorlod_+3A_cross">cross</code></td>
<td>
<p>Object of class <code>"cross2"</code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.</p>
</td></tr>
<tr><td><code id="calc_errorlod_+3A_probs">probs</code></td>
<td>
<p>Genotype probabilities as calculated from <code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.</p>
</td></tr>
<tr><td><code id="calc_errorlod_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code>, print progress messages.</p>
</td></tr>
<tr><td><code id="calc_errorlod_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">O_k</code> denote the observed marker genotype at position
<code class="reqn">k</code>, and <code class="reqn">g_k</code> denote the corresponding true underlying
genotype.
</p>
<p>Following Lincoln and Lander (1992), we calculate
LOD = <code class="reqn">log_{10} [ Pr(O_k | g_k = O_k) / Pr(O_k | g_k \ne O_K) ]</code>
</p>


<h3>Value</h3>

<p>A list of matrices of genotyping error LOD scores. Each
matrix corresponds to a chromosome and is arranged as
individuals x markers.
</p>


<h3>References</h3>

<p>Lincoln SE, Lander ES (1992) Systematic detection of errors in genetic linkage data. Genomics 14:604&ndash;610.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))
probs &lt;- calc_genoprob(iron, error_prob=0.002, map_function="c-f")
errorlod &lt;- calc_errorlod(iron, probs)

# combine into one matrix
errorlod &lt;- do.call("cbind", errorlod)
</code></pre>

<hr>
<h2 id='calc_geno_freq'>Calculate genotype frequencies</h2><span id='topic+calc_geno_freq'></span>

<h3>Description</h3>

<p>Calculate genotype frequencies, by individual or by marker
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_geno_freq(probs, by = c("individual", "marker"), omit_x = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_geno_freq_+3A_probs">probs</code></td>
<td>
<p>List of arrays of genotype probabilities, as
calculated by <code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.</p>
</td></tr>
<tr><td><code id="calc_geno_freq_+3A_by">by</code></td>
<td>
<p>Whether to summarize by individual or marker</p>
</td></tr>
<tr><td><code id="calc_geno_freq_+3A_omit_x">omit_x</code></td>
<td>
<p>If TRUE, results are just for the autosomes. If
FALSE, results are a list of length two, containing the results
for the autosomes and those for the X chromosome.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>omit_x=TRUE</code>, the result is a matrix of genotype
frequencies; columns are genotypes and rows are either individuals
or markers.
</p>
<p>If necessary (that is, if <code>omit_x=FALSE</code>, the data include the
X chromosome, and the set of genotypes on the X chromosome are
different than on the autosomes), the result is a list with two
components (for the autosomes and for the X chromosome), each being
a matrix of genotype frequencies.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_raw_geno_freq">calc_raw_geno_freq()</a></code>, <code><a href="#topic+calc_het">calc_het()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))
p &lt;- calc_genoprob(iron, err=0.002)

# genotype frequencies by marker
tab_g &lt;- calc_geno_freq(p, "marker")

# allele frequencies by marker
ap &lt;- genoprob_to_alleleprob(p)
tab_a &lt;- calc_geno_freq(ap, "marker")

</code></pre>

<hr>
<h2 id='calc_genoprob'>Calculate conditional genotype probabilities</h2><span id='topic+calc_genoprob'></span>

<h3>Description</h3>

<p>Uses a hidden Markov model to calculate the probabilities of the
true underlying genotypes given the observed multipoint marker
data, with possible allowance for genotyping errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_genoprob(
  cross,
  map = NULL,
  error_prob = 0.0001,
  map_function = c("haldane", "kosambi", "c-f", "morgan"),
  lowmem = FALSE,
  quiet = TRUE,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_genoprob_+3A_cross">cross</code></td>
<td>
<p>Object of class <code>"cross2"</code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.</p>
</td></tr>
<tr><td><code id="calc_genoprob_+3A_map">map</code></td>
<td>
<p>Genetic map of markers. May include pseudomarker
locations (that is, locations that are not within the marker
genotype data). If NULL, the genetic map in <code>cross</code> is used.</p>
</td></tr>
<tr><td><code id="calc_genoprob_+3A_error_prob">error_prob</code></td>
<td>
<p>Assumed genotyping error probability</p>
</td></tr>
<tr><td><code id="calc_genoprob_+3A_map_function">map_function</code></td>
<td>
<p>Character string indicating the map function to
use to convert genetic distances to recombination fractions.</p>
</td></tr>
<tr><td><code id="calc_genoprob_+3A_lowmem">lowmem</code></td>
<td>
<p>If <code>FALSE</code>, split individuals into groups with
common sex and crossinfo and then precalculate the transition
matrices for a chromosome; potentially a lot faster but using more
memory.</p>
</td></tr>
<tr><td><code id="calc_genoprob_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code>, print progress messages.</p>
</td></tr>
<tr><td><code id="calc_genoprob_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">O_k</code> denote the observed marker genotype at position
<code class="reqn">k</code>, and <code class="reqn">g_k</code> denote the corresponding true underlying
genotype.
</p>
<p>We use the forward-backward equations to calculate
<code class="reqn">\alpha_{kv} = \log Pr(O_1, \ldots, O_k, g_k = v)</code>
and
<code class="reqn">\beta_{kv} = \log Pr(O_{k+1}, \ldots, O_n | g_k = v)</code>
</p>
<p>We then obtain
<code class="reqn">Pr(g_k | O_1, \ldots, O_n) = \exp(\alpha_{kv} + \beta_{kv}) / s</code>
where
<code class="reqn">s = \sum_v \exp(\alpha_{kv} + \beta_{kv})</code>
</p>


<h3>Value</h3>

<p>An object of class <code>"calc_genoprob"</code>: a list of three-dimensional arrays of probabilities,
individuals x genotypes x positions. (Note that the arrangement is
different from R/qtl.) Also contains four attributes:
</p>

<ul>
<li> <p><code>crosstype</code> - The cross type of the input <code>cross</code>.
</p>
</li>
<li> <p><code>is_x_chr</code> - Logical vector indicating whether chromosomes
are to be treated as the X chromosome or not, from input <code>cross</code>.
</p>
</li>
<li> <p><code>alleles</code> - Vector of allele codes, from input
<code>cross</code>.
</p>
</li>
<li> <p><code>alleleprobs</code> - Logical value (<code>FALSE</code>) that
indicates whether the probabilities are compressed to allele
probabilities, as from <code><a href="#topic+genoprob_to_alleleprob">genoprob_to_alleleprob()</a></code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+insert_pseudomarkers">insert_pseudomarkers()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
gmap_w_pmar &lt;- insert_pseudomarkers(grav2$gmap, step=1)
probs &lt;- calc_genoprob(grav2, gmap_w_pmar, error_prob=0.002)
</code></pre>

<hr>
<h2 id='calc_grid'>Calculate indicators of which marker/pseudomarker positions are along a fixed grid</h2><span id='topic+calc_grid'></span>

<h3>Description</h3>

<p>Construct vectors of logical indicators that indicate which
positions correspond to locations along a grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_grid(map, step = 0, off_end = 0, tol = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_grid_+3A_map">map</code></td>
<td>
<p>A list of numeric vectors; each vector gives marker
positions for a single chromosome.</p>
</td></tr>
<tr><td><code id="calc_grid_+3A_step">step</code></td>
<td>
<p>Distance between pseudomarkers and markers; if
<code>step=0</code> no pseudomarkers are inserted.</p>
</td></tr>
<tr><td><code id="calc_grid_+3A_off_end">off_end</code></td>
<td>
<p>Distance beyond terminal markers in which to insert
pseudomarkers.</p>
</td></tr>
<tr><td><code id="calc_grid_+3A_tol">tol</code></td>
<td>
<p>Tolerance for determining whether a pseudomarker would
duplicate a marker position.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+insert_pseudomarkers">insert_pseudomarkers()</a></code>, with
<code>stepwidth="fixed"</code>, will insert a grid of pseudomarkers,
to a marker map. The present function gives a series of
TRUE/FALSE vectors that indicate which positions fall on the
grid. This is for use with <code><a href="#topic+probs_to_grid">probs_to_grid()</a></code>, for
reducing genotype probabilities, calculated with
<code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>, to just the positions on the grid.
The main value of this is to speed up genome scan computations
in the case of very dense markers, by focusing on just a grid
of positions rather than on all marker locations.
</p>


<h3>Value</h3>

<p>A list of logical (TRUE/FALSE) vectors that indicate, for a
marker/pseudomarker map created by
<code><a href="#topic+insert_pseudomarkers">insert_pseudomarkers()</a></code> with <code>step</code>&gt;0 and
<code>stepwidth="fixed"</code>, which positions correspond to he
locations along the fixed grid.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+insert_pseudomarkers">insert_pseudomarkers()</a></code>, <code><a href="#topic+probs_to_grid">probs_to_grid()</a></code>,
<code><a href="#topic+map_to_grid">map_to_grid()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))
gmap_w_pmar &lt;- insert_pseudomarkers(iron$gmap, step=1)
grid &lt;- calc_grid(iron$gmap, step=1)
</code></pre>

<hr>
<h2 id='calc_het'>Calculate heterozygosities</h2><span id='topic+calc_het'></span>

<h3>Description</h3>

<p>Calculate heterozygosites, by individual or by marker
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_het(probs, by = c("individual", "marker"), omit_x = TRUE, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_het_+3A_probs">probs</code></td>
<td>
<p>List of arrays of genotype probabilities, as
calculated by <code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.</p>
</td></tr>
<tr><td><code id="calc_het_+3A_by">by</code></td>
<td>
<p>Whether to summarize by individual or marker</p>
</td></tr>
<tr><td><code id="calc_het_+3A_omit_x">omit_x</code></td>
<td>
<p>If TRUE, omit the X chromosome.</p>
</td></tr>
<tr><td><code id="calc_het_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>calc_het()</code> looks at the genotype names (the 2nd
dimension of the dimnames of the input <code>probs</code>), which must be
two-letter names, and assumes that when the two letters are
different it's a heterozygous genotype while if they're the
same it's a homozygous genotype
</p>


<h3>Value</h3>

<p>The result is a vector of estimated heterozygosities
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_raw_het">calc_raw_het()</a></code>, <code><a href="#topic+calc_geno_freq">calc_geno_freq()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))
p &lt;- calc_genoprob(iron, err=0.002)

# heterozygosities by individual
het_ind &lt;- calc_het(p)

# heterozygosities by marker
het_mar &lt;- calc_het(p, "marker")

</code></pre>

<hr>
<h2 id='calc_kinship'>Calculate kinship matrix</h2><span id='topic+calc_kinship'></span>

<h3>Description</h3>

<p>Calculate genetic similarity among individuals (kinship matrix)
from conditional genotype probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_kinship(
  probs,
  type = c("overall", "loco", "chr"),
  omit_x = FALSE,
  use_allele_probs = TRUE,
  quiet = TRUE,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_kinship_+3A_probs">probs</code></td>
<td>
<p>Genotype probabilities, as calculated from
<code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.</p>
</td></tr>
<tr><td><code id="calc_kinship_+3A_type">type</code></td>
<td>
<p>Indicates whether to calculate the overall kinship
(<code>"overall"</code>, using all chromosomes), the kinship matrix
leaving out one chromosome at a time (<code>"loco"</code>), or the
kinship matrix for each chromosome (<code>"chr"</code>).</p>
</td></tr>
<tr><td><code id="calc_kinship_+3A_omit_x">omit_x</code></td>
<td>
<p>If <code>TRUE</code>, only use the autosomes; ignored when
<code>type="chr"</code>.</p>
</td></tr>
<tr><td><code id="calc_kinship_+3A_use_allele_probs">use_allele_probs</code></td>
<td>
<p>If <code>TRUE</code>, assess similarity with
allele probabilities (that is, first run
<code><a href="#topic+genoprob_to_alleleprob">genoprob_to_alleleprob()</a></code>); otherwise use the genotype
probabilities.</p>
</td></tr>
<tr><td><code id="calc_kinship_+3A_quiet">quiet</code></td>
<td>
<p>IF <code>FALSE</code>, print progress messages.</p>
</td></tr>
<tr><td><code id="calc_kinship_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>use_allele_probs=TRUE</code> (the default), we first
convert the genotype probabilities to allele
probabilities (using <code><a href="#topic+genoprob_to_alleleprob">genoprob_to_alleleprob()</a></code>).
</p>
<p>We then calculate
<code class="reqn">\sum_{kl}(p_{ikl} p_{jkl})</code>
where <code class="reqn">k</code> = position, <code class="reqn">l</code> = allele, and <code class="reqn">i,j</code>
are two individuals.
</p>
<p>For crosses with just two possible genotypes (e.g., backcross), we
don't convert to allele probabilities but just use the original
genotype probabilities.
</p>


<h3>Value</h3>

<p>If <code>type="overall"</code> (the default), a matrix of
proportion of matching alleles. Otherwise a list with one matrix
per chromosome.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
map &lt;- insert_pseudomarkers(grav2$gmap, step=1)
probs &lt;- calc_genoprob(grav2, map, error_prob=0.002)
K &lt;- calc_kinship(probs)

# using only markers/pseudomarkers on the grid
grid &lt;- calc_grid(grav2$gmap, step=1)
probs_sub &lt;- probs_to_grid(probs, grid)
K_grid &lt;- calc_kinship(probs_sub)
</code></pre>

<hr>
<h2 id='calc_raw_founder_maf'>Calculate founder minor allele frequencies from raw SNP genotypes</h2><span id='topic+calc_raw_founder_maf'></span>

<h3>Description</h3>

<p>Calculate minor allele frequency from raw SNP genotypes in founders, by founder strain or by marker
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_raw_founder_maf(cross, by = c("individual", "marker"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_raw_founder_maf_+3A_cross">cross</code></td>
<td>
<p>Object of class <code>"cross2"</code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.</p>
</td></tr>
<tr><td><code id="calc_raw_founder_maf_+3A_by">by</code></td>
<td>
<p>Indicates whether to summarize by founder strain (<code>"individual"</code>) or by marker.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of minor allele frequencies, one for each founder strain or marker.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+recode_snps">recode_snps()</a></code>, <code><a href="#topic+calc_raw_maf">calc_raw_maf()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data and calculate genotype probabilities
file &lt;- paste0("https://raw.githubusercontent.com/rqtl/",
               "qtl2data/main/DOex/DOex.zip")
DOex &lt;- read_cross2(file)
DOex_maf &lt;- calc_raw_founder_maf(DOex)

## End(Not run)
</code></pre>

<hr>
<h2 id='calc_raw_geno_freq'>Calculate genotype frequencies from raw SNP genotypes</h2><span id='topic+calc_raw_geno_freq'></span>

<h3>Description</h3>

<p>Calculate genotype frequencies from raw SNP genotypes, by individual or by marker
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_raw_geno_freq(cross, by = c("individual", "marker"), cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_raw_geno_freq_+3A_cross">cross</code></td>
<td>
<p>Object of class <code>"cross2"</code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.</p>
</td></tr>
<tr><td><code id="calc_raw_geno_freq_+3A_by">by</code></td>
<td>
<p>Indicates whether to summarize by individual or by marker.</p>
</td></tr>
<tr><td><code id="calc_raw_geno_freq_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of genotypes frequencies with 3 columns (AA, AB,
and BB) and with rows being either individuals or markers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_raw_maf">calc_raw_maf()</a></code>, <code><a href="#topic+calc_raw_het">calc_raw_het()</a></code>, <code><a href="#topic+recode_snps">recode_snps()</a></code>, <code><a href="#topic+calc_geno_freq">calc_geno_freq()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data and calculate genotype probabilities
file &lt;- paste0("https://raw.githubusercontent.com/rqtl/",
               "qtl2data/main/DOex/DOex.zip")
DOex &lt;- read_cross2(file)
gfreq &lt;- calc_raw_geno_freq(DOex)

## End(Not run)
</code></pre>

<hr>
<h2 id='calc_raw_het'>Calculate estimated heterozygosity from raw SNP genotypes</h2><span id='topic+calc_raw_het'></span>

<h3>Description</h3>

<p>Calculate estimated heterozygosity for each individual from raw SNP genotypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_raw_het(cross, by = c("individual", "marker"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_raw_het_+3A_cross">cross</code></td>
<td>
<p>Object of class <code>"cross2"</code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.</p>
</td></tr>
<tr><td><code id="calc_raw_het_+3A_by">by</code></td>
<td>
<p>Indicates whether to summarize by founder strain (<code>"individual"</code>) or by marker.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of heterozygosities, one for each individual or marker.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+recode_snps">recode_snps()</a></code>, <code><a href="#topic+calc_raw_maf">calc_raw_maf()</a></code>, <code><a href="#topic+calc_raw_founder_maf">calc_raw_founder_maf()</a></code>, <code><a href="#topic+calc_raw_geno_freq">calc_raw_geno_freq()</a></code>, <code><a href="#topic+calc_het">calc_het()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data and calculate genotype probabilities
file &lt;- paste0("https://raw.githubusercontent.com/rqtl/",
               "qtl2data/main/DOex/DOex.zip")
DOex &lt;- read_cross2(file)
DOex_het &lt;- calc_raw_het(DOex)

## End(Not run)
</code></pre>

<hr>
<h2 id='calc_raw_maf'>Calculate minor allele frequency from raw SNP genotypes</h2><span id='topic+calc_raw_maf'></span>

<h3>Description</h3>

<p>Calculate minor allele frequency from raw SNP genotypes, by individual or by marker
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_raw_maf(cross, by = c("individual", "marker"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_raw_maf_+3A_cross">cross</code></td>
<td>
<p>Object of class <code>"cross2"</code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.</p>
</td></tr>
<tr><td><code id="calc_raw_maf_+3A_by">by</code></td>
<td>
<p>Indicates whether to summarize by founder strain (<code>"individual"</code>) or by marker.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of minor allele frequencies, one for each individual or marker.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+recode_snps">recode_snps()</a></code>, <code><a href="#topic+calc_raw_founder_maf">calc_raw_founder_maf()</a></code>, <code><a href="#topic+calc_raw_het">calc_raw_het()</a></code>, <code><a href="#topic+calc_raw_geno_freq">calc_raw_geno_freq()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data and calculate genotype probabilities
file &lt;- paste0("https://raw.githubusercontent.com/rqtl/",
               "qtl2data/main/DOex/DOex.zip")
DOex &lt;- read_cross2(file)
DOex_maf &lt;- calc_raw_maf(DOex)

## End(Not run)
</code></pre>

<hr>
<h2 id='calc_sdp'>Calculate strain distribution pattern from SNP genotypes</h2><span id='topic+calc_sdp'></span>

<h3>Description</h3>

<p>Calculate the strain distribution patterns (SDPs) from the strain
genotypes at a set of SNPs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_sdp(geno)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_sdp_+3A_geno">geno</code></td>
<td>
<p>Matrix of SNP genotypes, markers x strains, coded as 1
(AA) and 3 (BB). Markers with values other than 1 or 3 are omitted,
and monomorphic markers, are omitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of strain distribution patterns: integers between
1 and <code class="reqn">2^n - 2</code> where <code class="reqn">n</code> is the number of strains, whose
binary representation indicates the strain genotypes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+invert_sdp">invert_sdp()</a></code>, <code><a href="#topic+sdp2char">sdp2char()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rbind(m1=c(3, 1, 1, 1, 1, 1, 1, 1),
           m2=c(1, 3, 3, 1, 1, 1, 1, 1),
           m3=c(1, 1, 1, 1, 3, 3, 3, 3))
calc_sdp(x)
</code></pre>

<hr>
<h2 id='cbind_expand'>Combine matrices by columns, expanding and aligning rows</h2><span id='topic+cbind_expand'></span>

<h3>Description</h3>

<p>This is like <code><a href="base.html#topic+cbind">base::cbind()</a></code> but using row names to align the rows and expanding
with missing values if there are rows in some matrices but not others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbind_expand(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cbind_expand_+3A_...">...</code></td>
<td>
<p>A set of matrices or data frames</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrices combined by columns, using row names to align the rows, and expanding with missing values if there are rows in some matrices but not others.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- data.frame(x=c(1,2,3,NA,4), y=c(5,8,9,10,11), row.names=c("A", "B", "C", "D", "E"))
df2 &lt;- data.frame(w=c(7,8,0,9,10), z=c(6,NA,NA,9,10), row.names=c("A", "B", "F", "C", "D"))
cbind_expand(df1, df2)
</code></pre>

<hr>
<h2 id='cbind.calc_genoprob'>Join genotype probabilities for different chromosomes</h2><span id='topic+cbind.calc_genoprob'></span>

<h3>Description</h3>

<p>Join multiple genotype probability objects, as produced by
<code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>, for the same set of individuals but different
chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calc_genoprob'
cbind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cbind.calc_genoprob_+3A_...">...</code></td>
<td>
<p>Genotype probability objects as produced by
<code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>. Must have the same set of individuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"calc_genoprob"</code>, like the input; see <code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rbind.calc_genoprob">rbind.calc_genoprob()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
map &lt;- insert_pseudomarkers(grav2$gmap, step=1)
probsA &lt;- calc_genoprob(grav2[1:5,1:2], map, error_prob=0.002)
probsB &lt;- calc_genoprob(grav2[1:5,3:4], map, error_prob=0.002)
probs &lt;- cbind(probsA, probsB)

</code></pre>

<hr>
<h2 id='cbind.scan1'>Join genome scan results for different phenotypes.</h2><span id='topic+cbind.scan1'></span>

<h3>Description</h3>

<p>Join multiple <code><a href="#topic+scan1">scan1()</a></code> results for different phenotypes;
must have the same map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scan1'
cbind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cbind.scan1_+3A_...">...</code></td>
<td>
<p>Genome scan objects of class <code>"scan1"</code>, as produced by <code><a href="#topic+scan1">scan1()</a></code>.
Must have the same map.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If components <code>addcovar()</code>, <code>Xcovar</code>,
<code>intcovar</code>, <code>weights</code> do not match between objects, we
omit this information.
</p>
<p>If <code>hsq</code> present but has differing numbers of rows, we omit this information.
</p>


<h3>Value</h3>

<p>An object of class '&quot;scan1&quot;, like the inputs, but with the lod score columns
from the inputs combined as multiple columns in a single object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rbind.scan1">rbind.scan1()</a></code>, <code><a href="#topic+scan1">scan1()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
map &lt;- insert_pseudomarkers(grav2$gmap, step=1)
probs &lt;- calc_genoprob(grav2, map, error_prob=0.002)
phe1 &lt;- grav2$pheno[,1,drop=FALSE]
phe2 &lt;- grav2$pheno[,2,drop=FALSE]

out1 &lt;- scan1(probs, phe1) # phenotype 1
out2 &lt;- scan1(probs, phe2) # phenotype 2
out &lt;- cbind(out1, out2)

</code></pre>

<hr>
<h2 id='cbind.scan1perm'>Combine columns from multiple scan1 permutation results</h2><span id='topic+cbind.scan1perm'></span>

<h3>Description</h3>

<p>Column-bind multiple scan1perm objects with the same numbers of rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scan1perm'
cbind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cbind.scan1perm_+3A_...">...</code></td>
<td>
<p>A set of permutation results from
<code><a href="#topic+scan1perm">scan1perm()</a></code> (objects of class <code>"scan1perm"</code>. If
different numbers of permutation replicates were used, those
columns with fewer replicates are padded with missing values
<code>NA</code>. However, if any include autosome/X
chromosome-specific permutations, they must all be such.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aim of this function is to concatenate the results
from multiple runs of a permutation test with
<code><a href="#topic+scan1perm">scan1perm()</a></code>, generally with different phenotypes
and/or methods, to be used in parallel with
<code><a href="#topic+rbind.scan1perm">rbind.scan1perm()</a></code>.
</p>


<h3>Value</h3>

<p>The combined column-binded input, as an object of class <code>"scan1perm"</code>; see <code><a href="#topic+scan1perm">scan1perm()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rbind.scan1perm">rbind.scan1perm()</a></code>, <code><a href="#topic+scan1perm">scan1perm()</a></code>, <code><a href="#topic+scan1">scan1()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))


# insert pseudomarkers into map
map &lt;- insert_pseudomarkers(iron$gmap, step=1)

# calculate genotype probabilities
probs &lt;- calc_genoprob(iron, map, error_prob=0.002)

# grab phenotypes and covariates; ensure that covariates have names attribute
pheno &lt;- iron$pheno
covar &lt;- match(iron$covar$sex, c("f", "m")) # make numeric
names(covar) &lt;- rownames(iron$covar)
Xcovar &lt;- get_x_covar(iron)

# permutations with genome scan (just 3 replicates, for illustration)
operm1 &lt;- scan1perm(probs, pheno[,1,drop=FALSE], addcovar=covar, Xcovar=Xcovar, n_perm=3)
operm2 &lt;- scan1perm(probs, pheno[,2,drop=FALSE], addcovar=covar, Xcovar=Xcovar, n_perm=3)

operm &lt;- cbind(operm1, operm2)

</code></pre>

<hr>
<h2 id='cbind.sim_geno'>Join genotype imputations for different chromosomes</h2><span id='topic+cbind.sim_geno'></span>

<h3>Description</h3>

<p>Join multiple genotype imputation objects, as produced by
<code><a href="#topic+sim_geno">sim_geno()</a></code>, for the same individuals but different
chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sim_geno'
cbind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cbind.sim_geno_+3A_...">...</code></td>
<td>
<p>Genotype imputation objects as produced by
<code><a href="#topic+sim_geno">sim_geno()</a></code>. Must have the same set of individuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"sim_geno"</code>, like the input; see <code><a href="#topic+sim_geno">sim_geno()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rbind.sim_geno">rbind.sim_geno()</a></code>, <code><a href="#topic+sim_geno">sim_geno()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
map &lt;- insert_pseudomarkers(grav2$gmap, step=1)
drawsA &lt;- sim_geno(grav2[1:5,1:2], map, error_prob=0.002, n_draws=4)
drawsB &lt;- sim_geno(grav2[1:5,3:4], map, error_prob=0.002, n_draws=4)
draws &lt;- cbind(drawsA, drawsB)

</code></pre>

<hr>
<h2 id='cbind.viterbi'>Join viterbi results for different chromosomes</h2><span id='topic+cbind.viterbi'></span>

<h3>Description</h3>

<p>Join multiple viterbi objects, as produced by <code><a href="#topic+viterbi">viterbi()</a></code>, for the
same set of individuals but different chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'viterbi'
cbind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cbind.viterbi_+3A_...">...</code></td>
<td>
<p>Imputed genotype objects as produced by
<code><a href="#topic+viterbi">viterbi()</a></code>. Must have the same set of individuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"viterbi"</code>, like the input; see <code><a href="#topic+viterbi">viterbi()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rbind.viterbi">rbind.viterbi()</a></code>, <code><a href="#topic+viterbi">viterbi()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
map &lt;- insert_pseudomarkers(grav2$gmap, step=1)
gA &lt;- viterbi(grav2[1:5,1:2], map, error_prob=0.002)
gB &lt;- viterbi(grav2[1:5,3:4], map, error_prob=0.002)
g &lt;- cbind(gA, gB)

</code></pre>

<hr>
<h2 id='CCcolors'>Collaborative Cross colors</h2><span id='topic+CCcolors'></span><span id='topic+CCorigcolors'></span><span id='topic+CCaltcolors'></span>

<h3>Description</h3>

<p>A vector of 8 colors for use with the mouse
Collaborative Cross and Diversity Outbreds.
</p>


<h3>Details</h3>

<p><code>CCorigcolors</code> are the original eight colors for the Collaborative Cross founder strains.
<code>CCaltcolors</code> are a slightly modified version, but still not color-blind friendly.
<code>CCcolors</code> are derived from the the Okabe-Ito color blind friendly palette in
Wong (2011) Nature Methods <a href="https://doi.org/10.1038/nmeth.1618">doi:10.1038/nmeth.1618</a>.
</p>


<h3>Source</h3>

<p><a href="https://csbio.unc.edu/CCstatus/index.py?run=AvailableLines.information">https://csbio.unc.edu/CCstatus/index.py?run=AvailableLines.information</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CCcolors)
data(CCaltcolors)
data(CCorigcolors)
</code></pre>

<hr>
<h2 id='check_cross2'>Check a cross2 object</h2><span id='topic+check_cross2'></span>

<h3>Description</h3>

<p>Check the integrity of the data within a cross2 object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_cross2(cross2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_cross2_+3A_cross2">cross2</code></td>
<td>
<p>An object of class <code>"cross2"</code>, as output by <code><a href="#topic+read_cross2">read_cross2()</a></code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Checks whether a cross2 object meets the
specifications. Problems are issued as warnings.
</p>


<h3>Value</h3>

<p>If everything is correct, returns <code>TRUE</code>; otherwise <code>FALSE</code>,
with attributes that give the problems.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
check_cross2(grav2)
</code></pre>

<hr>
<h2 id='chisq_colpairs'>Chi-square test on all pairs of columns</h2><span id='topic+chisq_colpairs'></span>

<h3>Description</h3>

<p>Perform a chi-square test for independence for all pairs of columns of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chisq_colpairs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chisq_colpairs_+3A_x">x</code></td>
<td>
<p>A matrix of positive integers. <code>NA</code>s and values &lt;= 0 are treated as missing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size p x p, where p is the number of columns in
the input matrix <code>x</code>, containing the chi-square test
statistics for independence, applied to pairs of columns of
<code>x</code>. The diagonal of the result will be all <code>NA</code>s.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- matrix(sample(1:2, 500, replace=TRUE), ncol=5)
chisq_colpairs(z)
</code></pre>

<hr>
<h2 id='chr_lengths'>Calculate chromosome lengths</h2><span id='topic+chr_lengths'></span>

<h3>Description</h3>

<p>Calculate chromosome lengths for a map object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chr_lengths(map, collapse_to_AX = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chr_lengths_+3A_map">map</code></td>
<td>
<p>A list of vectors, each specifying locations of the markers.</p>
</td></tr>
<tr><td><code id="chr_lengths_+3A_collapse_to_ax">collapse_to_AX</code></td>
<td>
<p>If TRUE, collapse to the total lengths of the
autosomes and X chromosome.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We take <code>diff(range(v))</code> for each vector, <code>v</code>.
</p>


<h3>Value</h3>

<p>A vector of chromosome lengths. If
<code>collapse_to_AX=TRUE</code>, the result is a vector of length 2
(autosomal and X chromosome lengths).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scan1perm">scan1perm()</a></code>
</p>

<hr>
<h2 id='clean'>Clean an object</h2><span id='topic+clean'></span>

<h3>Description</h3>

<p>Clean an object by removing messy values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_+3A_object">object</code></td>
<td>
<p>Object to be cleaned</p>
</td></tr>
<tr><td><code id="clean_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Input object with messy values cleaned up
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clean.scan1">clean.scan1()</a></code>, <code><a href="#topic+clean.calc_genoprob">clean.calc_genoprob()</a></code>
</p>

<hr>
<h2 id='clean_genoprob'>Clean genotype probabilities</h2><span id='topic+clean_genoprob'></span><span id='topic+clean.calc_genoprob'></span>

<h3>Description</h3>

<p>Clean up genotype probabilities by setting small values to 0 and
for a genotype column where the maximum value is rather small, set
all values in that column to 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_genoprob(
  object,
  value_threshold = 0.000001,
  column_threshold = 0.01,
  ind = NULL,
  cores = 1,
  ...
)

## S3 method for class 'calc_genoprob'
clean(
  object,
  value_threshold = 0.000001,
  column_threshold = 0.01,
  ind = NULL,
  cores = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_genoprob_+3A_object">object</code></td>
<td>
<p>Genotype probabilities as calculated by
<code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.</p>
</td></tr>
<tr><td><code id="clean_genoprob_+3A_value_threshold">value_threshold</code></td>
<td>
<p>Probabilities below this value will be set
to 0.</p>
</td></tr>
<tr><td><code id="clean_genoprob_+3A_column_threshold">column_threshold</code></td>
<td>
<p>For genotype columns where the maximum
value is below this threshold, all values will be set to 0.
This must be less than <code class="reqn">1/k</code> where <code class="reqn">k</code> is the number of
genotypes.</p>
</td></tr>
<tr><td><code id="clean_genoprob_+3A_ind">ind</code></td>
<td>
<p>Optional vector of individuals (logical, numeric, or
character). If provided, only the genotype probabilities for
these individuals will be cleaned, though the full set will be
returned.</p>
</td></tr>
<tr><td><code id="clean_genoprob_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
<tr><td><code id="clean_genoprob_+3A_...">...</code></td>
<td>
<p>Ignored at this point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In cases where a particular genotype is largely absent,
<code>scan1coef()</code> and <code>fit1()</code> can give unstable estimates of the
genotype effects. Cleaning up the genotype probabilities by setting
small values to 0 helps to ensure that such effects get set to
<code>NA</code>.
</p>
<p>At each position and for each genotype column, we find the maximum
probability across individuals. If that maximum is &lt;
<code>column_threshold</code>, all values in that genotype column at that
position are set to 0.
</p>
<p>In addition, any genotype probabilties that are &lt; <code>value_threshold</code>
(generally &lt; <code>column_threshold</code>) are set to 0.
</p>
<p>The probabilities are then re-scaled so that the probabilities for
each individual at each position sum to 1.
</p>
<p>If <code>ind</code> is provided, the function is applied only to the
designated subset of individuals. This may be useful when only a
subset of individuals have been phenotyped, as you may want to zero
out genotype columns where that subset of individuals has only
negligible probability values.
</p>


<h3>Value</h3>

<p>A cleaned version of the input genotype probabilities
object, <code>object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))


# calculate genotype probabilities
probs &lt;- calc_genoprob(iron, error_prob=0.002)

# clean the genotype probabilities
# (doesn't really do anything in this case, because there are no small but non-zero values)
probs_clean &lt;- clean(probs)

# clean only the females' genotype probabilities
probs_cleanf &lt;- clean(probs, ind=names(iron$is_female)[iron$is_female])
</code></pre>

<hr>
<h2 id='clean_scan1'>Clean scan1 output</h2><span id='topic+clean_scan1'></span><span id='topic+clean.scan1'></span>

<h3>Description</h3>

<p>Clean scan1 output by replacing negative values with NA and remove
rows where all values are NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_scan1(object, ...)

## S3 method for class 'scan1'
clean(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_scan1_+3A_object">object</code></td>
<td>
<p>Output of <code><a href="#topic+scan1">scan1()</a></code>.</p>
</td></tr>
<tr><td><code id="clean_scan1_+3A_...">...</code></td>
<td>
<p>Ignored at present</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input object with negative values replaced with NAs and then rows with all NAs removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))

pr &lt;- calc_genoprob(iron)
out &lt;- scan1(pr, iron$pheno)

out &lt;- clean(out)
</code></pre>

<hr>
<h2 id='compare_geno'>Compare individuals' genotype data</h2><span id='topic+compare_geno'></span>

<h3>Description</h3>

<p>Count the number of matching genotypes between all pairs of
individuals, to look for unusually closely related individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_geno(cross, omit_x = FALSE, proportion = TRUE, quiet = TRUE, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_geno_+3A_cross">cross</code></td>
<td>
<p>Object of class <code>"cross2"</code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.</p>
</td></tr>
<tr><td><code id="compare_geno_+3A_omit_x">omit_x</code></td>
<td>
<p>If TRUE, only use autosomal genotypes</p>
</td></tr>
<tr><td><code id="compare_geno_+3A_proportion">proportion</code></td>
<td>
<p>If TRUE (the default), the upper triangle of the
result contains the proportions of matching genotypes. If
FALSE, the upper triangle contains counts of matching
genotypes.</p>
</td></tr>
<tr><td><code id="compare_geno_+3A_quiet">quiet</code></td>
<td>
<p>IF <code>FALSE</code>, print progress messages.</p>
</td></tr>
<tr><td><code id="compare_geno_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A square matrix; diagonal is number of observed genotypes
for each individual. The values in the lower triangle are the
numbers of markers where both of a pair were genotyped. The
values in the upper triangle are either proportions or counts
of matching genotypes for each pair (depending on whether
<code>proportion=TRUE</code> or <code style="white-space: pre;">&#8288;=FALSE&#8288;</code>). The object is given
class <code>"compare_geno"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
cg &lt;- compare_geno(grav2)
summary(cg)
</code></pre>

<hr>
<h2 id='compare_genoprob'>Compare two sets of genotype probabilities</h2><span id='topic+compare_genoprob'></span>

<h3>Description</h3>

<p>Compare two sets of genotype probabilities for one individual on a single chromosome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_genoprob(
  probs1,
  probs2,
  cross,
  ind = 1,
  chr = NULL,
  minprob = 0.95,
  minmarkers = 10,
  minwidth = 0,
  annotate = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_genoprob_+3A_probs1">probs1</code></td>
<td>
<p>Genotype probabilities (as produced by <code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>)
or allele dosages (as produced by <code><a href="#topic+genoprob_to_alleleprob">genoprob_to_alleleprob()</a></code>).</p>
</td></tr>
<tr><td><code id="compare_genoprob_+3A_probs2">probs2</code></td>
<td>
<p>A second set of genotype probabilities, just like <code>probs1</code>.</p>
</td></tr>
<tr><td><code id="compare_genoprob_+3A_cross">cross</code></td>
<td>
<p>Object of class <code>"cross2"</code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.</p>
</td></tr>
<tr><td><code id="compare_genoprob_+3A_ind">ind</code></td>
<td>
<p>Individual to plot, either a numeric index or an ID.</p>
</td></tr>
<tr><td><code id="compare_genoprob_+3A_chr">chr</code></td>
<td>
<p>Selected chromosome; a single character string.</p>
</td></tr>
<tr><td><code id="compare_genoprob_+3A_minprob">minprob</code></td>
<td>
<p>Minimum probability for inferring genotypes (passed to <code><a href="#topic+maxmarg">maxmarg()</a></code>).</p>
</td></tr>
<tr><td><code id="compare_genoprob_+3A_minmarkers">minmarkers</code></td>
<td>
<p>Minimum number of markers in results.</p>
</td></tr>
<tr><td><code id="compare_genoprob_+3A_minwidth">minwidth</code></td>
<td>
<p>Minimum width in results.</p>
</td></tr>
<tr><td><code id="compare_genoprob_+3A_annotate">annotate</code></td>
<td>
<p>If TRUE, add some annotations to the <code>geno1</code> and
<code>geno2</code> columns to indicate, where they differ, which one
matches what appears to be the best genotype. (<code>*</code> = matches
the best genotype; <code>-</code> = lower match).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function does the following:
</p>

<ul>
<li><p> Reduce the probabilities to a set of common locations that also appear in <code>cross</code>.
</p>
</li>
<li><p> Use <code><a href="#topic+maxmarg">maxmarg()</a></code> to infer the genotype at every position using each set of probabilities.
</p>
</li>
<li><p> Identify intervals where the two inferred genotypes are constant.
</p>
</li>
<li><p> Within each segment, compare the observed SNP genotypes to the founders' genotypes.
</p>
</li></ul>



<h3>Value</h3>

<p>A data frame with each row corresponding to an interval over which
<code>probs1</code> and <code>probs2</code> each have a fixed inferred genotype. Columns
include the two inferred genotypes, the start and end points and
width of the interval, and when founder genotypes are in <code>cross</code>,
the proportions of SNPs where the individual matches each possible
genotypes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_genoprobcomp">plot_genoprobcomp()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))
iron &lt;- iron[1,"2"]   # subset to first individual on chr 2
map &lt;- insert_pseudomarkers(iron$gmap, step=1)

# in presence of a genotyping error, how much does error_prob matter?
iron$geno[[1]][1,3] &lt;- 3
pr_e &lt;- calc_genoprob(iron, map, error_prob=0.002)
pr_ne &lt;- calc_genoprob(iron, map, error_prob=1e-15)

compare_genoprob(pr_e, pr_ne, iron, minmarkers=1, minprob=0.5)

</code></pre>

<hr>
<h2 id='compare_maps'>Compare two marker maps</h2><span id='topic+compare_maps'></span>

<h3>Description</h3>

<p>Compare two marker maps, identifying markers that are only in one
of the two maps, or that are in different orders on the two maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_maps(map1, map2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_maps_+3A_map1">map1</code></td>
<td>
<p>A list of numeric vectors; each vector gives marker
positions for a single chromosome.</p>
</td></tr>
<tr><td><code id="compare_maps_+3A_map2">map2</code></td>
<td>
<p>A second map, in the same format as <code>map1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing
</p>

<ul>
<li> <p><code>marker</code> - marker name
</p>
</li>
<li> <p><code>chr_map1</code> - chromosome ID on <code>map1</code>
</p>
</li>
<li> <p><code>pos_map1</code> - position on <code>map1</code>
</p>
</li>
<li> <p><code>chr_map2</code> - chromosome ID on <code>map2</code>
</p>
</li>
<li> <p><code>pos_map2</code> - position on <code>map2</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># load some data
iron &lt;- read_cross2( system.file("extdata", "iron.zip", package="qtl2") )
gmap &lt;- iron$gmap
pmap &lt;- iron$pmap

# omit a marker from each map
gmap[[7]] &lt;- gmap[[7]][-3]
pmap[[8]] &lt;- pmap[[8]][-7]
# swap order of a couple of markers on the physical map
names(pmap[[9]])[3:4] &lt;- names(pmap[[9]])[4:3]
# move a marker to a different chromosome
pmap[[10]] &lt;- c(pmap[[10]], pmap[[1]][2])[c(1,3,2)]
pmap[[1]] &lt;- pmap[[1]][-2]

# compare these messed-up maps
compare_maps(gmap, pmap)

</code></pre>

<hr>
<h2 id='convert2cross2'>Convert R/qtl cross object to new format</h2><span id='topic+convert2cross2'></span>

<h3>Description</h3>

<p>Convert a cross object from the R/qtl format to the R/qtl2 format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert2cross2(cross)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert2cross2_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>"cross"</code>; see
<code><a href="qtl.html#topic+read.cross">qtl::read.cross()</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"cross2"</code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_cross2">read_cross2()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(qtl)
data(hyper)
hyper2 &lt;- convert2cross2(hyper)
</code></pre>

<hr>
<h2 id='count_xo'>Count numbers of crossovers</h2><span id='topic+count_xo'></span>

<h3>Description</h3>

<p>Estimate the numbers of crossovers in each individual on each chromosome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_xo(geno, quiet = TRUE, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_xo_+3A_geno">geno</code></td>
<td>
<p>List of matrices of genotypes (output of <code><a href="#topic+maxmarg">maxmarg()</a></code> or <code><a href="#topic+viterbi">viterbi()</a></code>)
or a list of 3d-arrays of genotypes (output of <code><a href="#topic+sim_geno">sim_geno()</a></code>).</p>
</td></tr>
<tr><td><code id="count_xo_+3A_quiet">quiet</code></td>
<td>
<p>If FALSE, print progress messages.</p>
</td></tr>
<tr><td><code id="count_xo_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of crossover counts, individuals x chromosomes, or
(if the input was the output of <code><a href="#topic+sim_geno">sim_geno()</a></code>) a
3d-array of crossover counts, individuals x chromosomes x
imputations.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locate_xo">locate_xo()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))

map &lt;- insert_pseudomarkers(iron$gmap, step=1)
pr &lt;- calc_genoprob(iron, map, error_prob=0.002, map_function="c-f")
g &lt;- maxmarg(pr)
n_xo &lt;- count_xo(g)

# imputations
imp &lt;- sim_geno(iron, map, error_prob=0.002, map_function="c-f", n_draws=32)
n_xo_imp &lt;- count_xo(imp)
# sums across chromosomes
tot_xo_imp &lt;- apply(n_xo_imp, c(1,3), sum)
# mean and SD across imputations
summary_xo &lt;- cbind(mean=rowMeans(tot_xo_imp),
                    sd=apply(tot_xo_imp, 1, sd))

</code></pre>

<hr>
<h2 id='create_gene_query_func'>Create a function to query genes</h2><span id='topic+create_gene_query_func'></span>

<h3>Description</h3>

<p>Create a function that will connect to a SQLite database of gene
information and return a data frame with gene information for a
selected region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_gene_query_func(
  dbfile = NULL,
  db = NULL,
  table_name = "genes",
  chr_field = "chr",
  start_field = "start",
  stop_field = "stop",
  name_field = "Name",
  strand_field = "strand",
  filter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_gene_query_func_+3A_dbfile">dbfile</code></td>
<td>
<p>Name of database file</p>
</td></tr>
<tr><td><code id="create_gene_query_func_+3A_db">db</code></td>
<td>
<p>Optional database connection (provide one of <code>file</code> and <code>db</code>).</p>
</td></tr>
<tr><td><code id="create_gene_query_func_+3A_table_name">table_name</code></td>
<td>
<p>Name of table in the database</p>
</td></tr>
<tr><td><code id="create_gene_query_func_+3A_chr_field">chr_field</code></td>
<td>
<p>Name of chromosome field</p>
</td></tr>
<tr><td><code id="create_gene_query_func_+3A_start_field">start_field</code></td>
<td>
<p>Name of field with start position (in basepairs)</p>
</td></tr>
<tr><td><code id="create_gene_query_func_+3A_stop_field">stop_field</code></td>
<td>
<p>Name of field with stop position (in basepairs)</p>
</td></tr>
<tr><td><code id="create_gene_query_func_+3A_name_field">name_field</code></td>
<td>
<p>Name of field with gene name</p>
</td></tr>
<tr><td><code id="create_gene_query_func_+3A_strand_field">strand_field</code></td>
<td>
<p>Name of field with strand (+/-)</p>
</td></tr>
<tr><td><code id="create_gene_query_func_+3A_filter">filter</code></td>
<td>
<p>Additional SQL filter (as a character string).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function assumes that the database has
<code>start</code> and <code>stop</code> fields that are in basepairs, but
the selection uses positions in Mbp, and the output data frame
should have <code>start</code> and <code>stop</code> columns in Mbp.
</p>
<p>Also note that a SQLite database of MGI mouse genes
is available at figshare:
<a href="https://doi.org/10.6084/m9.figshare.5286019.v7">doi:10.6084/m9.figshare.5286019.v7</a>
</p>


<h3>Value</h3>

<p>Function with three arguments, <code>chr</code>, <code>start</code>,
and <code>end</code>, which returns a data frame with the genes
overlapping that region, with <code>start</code> and <code>end</code> being
in Mbp. The output should contain at least the columns
<code>Name</code>, <code>chr</code>, <code>start</code>, and <code>stop</code>, the
latter two being positions in Mbp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create query function by connecting to file
dbfile &lt;- system.file("extdata", "mouse_genes_small.sqlite", package="qtl2")
query_genes &lt;- create_gene_query_func(dbfile, filter="(source=='MGI')")
# query_genes will connect and disconnect each time
genes &lt;- query_genes("2", 97.0, 98.0)

# connect and disconnect separately
library(RSQLite)
db &lt;- dbConnect(SQLite(), dbfile)
query_genes &lt;- create_gene_query_func(db=db, filter="(source=='MGI')")
genes &lt;- query_genes("2", 97.0, 98.0)
dbDisconnect(db)
</code></pre>

<hr>
<h2 id='create_snpinfo'>Create snp information table for a cross</h2><span id='topic+create_snpinfo'></span>

<h3>Description</h3>

<p>Create a table of snp information from a cross, for use with <code><a href="#topic+scan1snps">scan1snps()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_snpinfo(cross)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_snpinfo_+3A_cross">cross</code></td>
<td>
<p>Object of class <code>"cross2"</code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of SNP information with the following columns:
</p>

<ul>
<li> <p><code>chr</code> - Character string or factor with chromosome
</p>
</li>
<li> <p><code>pos</code> - Position (in same units as in the <code>"map"</code>
attribute in <code>genoprobs</code>.
</p>
</li>
<li> <p><code>snp</code> - Character string with SNP identifier (if
missing, the rownames are used).
</p>
</li>
<li> <p><code>sdp</code> - Strain distribution pattern: an integer, between
1 and <code class="reqn">2^n - 2</code> where <code class="reqn">n</code> is the number of strains, whose
binary encoding indicates the founder genotypes
SNPs with missing founder genotypes are omitted.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+index_snps">index_snps()</a></code>, <code><a href="#topic+scan1snps">scan1snps()</a></code>, <code><a href="#topic+genoprob_to_snpprob">genoprob_to_snpprob()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data and calculate genotype probabilities
file &lt;- paste0("https://raw.githubusercontent.com/rqtl/",
               "qtl2data/main/DO_Recla/recla.zip")
recla &lt;- read_cross2(file)
snpinfo &lt;- create_snpinfo(recla)

# calculate genotype probabilities
pr &lt;- calc_genoprob(recla, error_prob=0.002, map_function="c-f")

# index the snp information
snpinfo &lt;- index_snps(recla$pmap, snpinfo)

# sex covariate
sex &lt;- setNames((recla$covar$Sex=="female")*1, rownames(recla$covar))

# perform a SNP scan
out &lt;- scan1snps(pr, recla$pmap, recla$pheno[,"bw"], addcovar=sex, snpinfo=snpinfo)

# plot the LOD scores
plot(out$lod, snpinfo, altcol="green3")

## End(Not run)

</code></pre>

<hr>
<h2 id='create_variant_query_func'>Create a function to query variants</h2><span id='topic+create_variant_query_func'></span>

<h3>Description</h3>

<p>Create a function that will connect to a SQLite database of founder
variant information and return a data frame with variants for a
selected region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_variant_query_func(
  dbfile = NULL,
  db = NULL,
  table_name = "variants",
  chr_field = "chr",
  pos_field = "pos",
  id_field = "snp_id",
  sdp_field = "sdp",
  filter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_variant_query_func_+3A_dbfile">dbfile</code></td>
<td>
<p>Name of database file</p>
</td></tr>
<tr><td><code id="create_variant_query_func_+3A_db">db</code></td>
<td>
<p>Optional database connection (provide one of <code>file</code> and <code>db</code>).</p>
</td></tr>
<tr><td><code id="create_variant_query_func_+3A_table_name">table_name</code></td>
<td>
<p>Name of table in the database</p>
</td></tr>
<tr><td><code id="create_variant_query_func_+3A_chr_field">chr_field</code></td>
<td>
<p>Name of chromosome field</p>
</td></tr>
<tr><td><code id="create_variant_query_func_+3A_pos_field">pos_field</code></td>
<td>
<p>Name of position field</p>
</td></tr>
<tr><td><code id="create_variant_query_func_+3A_id_field">id_field</code></td>
<td>
<p>Name of SNP/variant ID field</p>
</td></tr>
<tr><td><code id="create_variant_query_func_+3A_sdp_field">sdp_field</code></td>
<td>
<p>Name of strain distribution pattern (SDP) field</p>
</td></tr>
<tr><td><code id="create_variant_query_func_+3A_filter">filter</code></td>
<td>
<p>Additional SQL filter (as a character string)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function assumes that the database has a
<code>pos</code> field that is in basepairs, but the selection uses
<code>start</code> and <code>end</code> positions in Mbp, and the output
data frame should have <code>pos</code> in Mbp.
</p>
<p>Also note that a SQLite database of variants in the founder strains
of the mouse Collaborative Cross is available at figshare:
<a href="https://doi.org/10.6084/m9.figshare.5280229.v3">doi:10.6084/m9.figshare.5280229.v3</a>
</p>


<h3>Value</h3>

<p>Function with three arguments, <code>chr</code>, <code>start</code>,
and <code>end</code>, which returns a data frame with the variants in
that region, with <code>start</code> and <code>end</code> being in Mbp. The
output should contain at least the columns <code>chr</code> and
<code>pos</code>, the latter being position in Mbp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create query function by connecting to file
dbfile &lt;- system.file("extdata", "cc_variants_small.sqlite", package="qtl2")
query_variants &lt;- create_variant_query_func(dbfile)
# query_variants will connect and disconnect each time
variants &lt;- query_variants("2", 97.0, 98.0)

# create query function to just grab SNPs
query_snps &lt;- create_variant_query_func(dbfile, filter="type=='snp'")
# query_variants will connect and disconnect each time
snps &lt;- query_snps("2", 97.0, 98.0)

# connect and disconnect separately
library(RSQLite)
db &lt;- dbConnect(SQLite(), dbfile)
query_variants &lt;- create_variant_query_func(db=db)
variants &lt;- query_variants("2", 97.0, 98.0)
dbDisconnect(db)
</code></pre>

<hr>
<h2 id='decomp_kinship'>Calculate eigen decomposition of kinship matrix</h2><span id='topic+decomp_kinship'></span>

<h3>Description</h3>

<p>Calculate the eigen decomposition of a kinship matrix, or of a list of such matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decomp_kinship(kinship, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decomp_kinship_+3A_kinship">kinship</code></td>
<td>
<p>A square matrix, or a list of square matrices.</p>
</td></tr>
<tr><td><code id="decomp_kinship_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The result contains an attribute <code>"eigen_decomp"</code>.
</p>


<h3>Value</h3>

<p>The eigen values and the <strong>transposed</strong> eigen vectors,
as a list containing a vector <code>values</code> and a matrix
<code>vectors</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))

map &lt;- insert_pseudomarkers(iron$gmap, step=1)
probs &lt;- calc_genoprob(iron, map, error_prob=0.002)
K &lt;- calc_kinship(probs)

Ke &lt;- decomp_kinship(K)

</code></pre>

<hr>
<h2 id='drop_markers'>Drop markers from a cross2 object</h2><span id='topic+drop_markers'></span>

<h3>Description</h3>

<p>Drop a vector of markers from a cross2 object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_markers(cross, markers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_markers_+3A_cross">cross</code></td>
<td>
<p>Object of class <code>"cross2"</code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.</p>
</td></tr>
<tr><td><code id="drop_markers_+3A_markers">markers</code></td>
<td>
<p>A vector of marker names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>cross</code> with the specified markers removed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pull_markers">pull_markers()</a></code>, <code><a href="#topic+drop_nullmarkers">drop_nullmarkers()</a></code>, <code><a href="#topic+reduce_markers">reduce_markers()</a></code>, <code><a href="#topic+find_dup_markers">find_dup_markers()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
markers2drop &lt;- c("BH.342C/347L-Col", "GH.94L", "EG.357C/359L-Col", "CD.245L", "ANL2")
grav2_rev &lt;- drop_markers(grav2, markers2drop)
</code></pre>

<hr>
<h2 id='drop_nullmarkers'>Drop markers with no genotype data</h2><span id='topic+drop_nullmarkers'></span>

<h3>Description</h3>

<p>Drop markers with no genotype data (or no informative genotypes)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_nullmarkers(cross, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_nullmarkers_+3A_cross">cross</code></td>
<td>
<p>Object of class <code>"cross2"</code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.</p>
</td></tr>
<tr><td><code id="drop_nullmarkers_+3A_quiet">quiet</code></td>
<td>
<p>If FALSE, print information about how many markers were dropped.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We omit any markers that have completely missing data, or
if founder genotypes are present (e.g., for Diversity Outbreds),
the founder genotypes are missing or are all the same.
</p>


<h3>Value</h3>

<p>The input <code>cross</code> with the uninformative markers removed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drop_markers">drop_markers()</a></code>, <code><a href="#topic+pull_markers">pull_markers()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
# make a couple of markers missing
grav2$geno[[2]][,c(3,25)] &lt;- 0
grav2_rev &lt;- drop_nullmarkers(grav2)
</code></pre>

<hr>
<h2 id='est_herit'>Estimate heritability with a linear mixed model</h2><span id='topic+est_herit'></span>

<h3>Description</h3>

<p>Estimate the heritability of a set of traits via a linear mixed
model, with possible allowance for covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_herit(
  pheno,
  kinship,
  addcovar = NULL,
  weights = NULL,
  reml = TRUE,
  cores = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est_herit_+3A_pheno">pheno</code></td>
<td>
<p>A numeric matrix of phenotypes, individuals x phenotypes.</p>
</td></tr>
<tr><td><code id="est_herit_+3A_kinship">kinship</code></td>
<td>
<p>A kinship matrix.</p>
</td></tr>
<tr><td><code id="est_herit_+3A_addcovar">addcovar</code></td>
<td>
<p>An optional numeric matrix of additive covariates.</p>
</td></tr>
<tr><td><code id="est_herit_+3A_weights">weights</code></td>
<td>
<p>An optional numeric vector of positive weights for the
individuals. As with the other inputs, it must have <code>names</code>
for individual identifiers.</p>
</td></tr>
<tr><td><code id="est_herit_+3A_reml">reml</code></td>
<td>
<p>If true, use REML; otherwise, use maximimum likelihood.</p>
</td></tr>
<tr><td><code id="est_herit_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
<tr><td><code id="est_herit_+3A_...">...</code></td>
<td>
<p>Additional control parameters (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We fit the model <code class="reqn">y = X \beta + \epsilon</code> where
<code class="reqn">\epsilon</code> is multivariate normal with mean 0 and covariance
matrix <code class="reqn">\sigma^2 [h^2 (2 K) + I]</code> where
<code class="reqn">K</code> is the kinship matrix and <code class="reqn">I</code> is the identity matrix.
</p>
<p>If <code>weights</code> are provided, the covariance matrix becomes
<code class="reqn">\sigma^2 [h^2 (2 K) + D]</code> where
<code class="reqn">D</code> is a diagonal matrix with the reciprocal of the weights.
</p>
<p>For each of the inputs, the row names are used as
individual identifiers, to align individuals.
</p>
<p>If <code>reml=TRUE</code>, restricted maximum likelihood (reml) is used
to estimate the heritability, separately for each phenotype.
</p>
<p>Additional control parameters include <code>tol</code> for the tolerance
for convergence, <code>quiet</code> for controlling whether messages will
be display, <code>max_batch</code> for the maximum number of phenotypes
in a batch, and <code>check_boundary</code> for whether the 0 and 1
boundary values for the estimated heritability will be checked
explicitly.
</p>


<h3>Value</h3>

<p>A vector of estimated heritabilities, corresponding to the
columns in <code>pheno</code>. The result has attributes <code>"sample_size"</code>,
<code>"log10lik"</code> and <code>"resid_sd"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))


# insert pseudomarkers into map
map &lt;- insert_pseudomarkers(iron$gmap, step=1)

# calculate genotype probabilities
probs &lt;- calc_genoprob(iron, map, error_prob=0.002)

# kinship matrix
kinship &lt;- calc_kinship(probs)

# grab phenotypes and covariates; ensure that covariates have names attribute
pheno &lt;- iron$pheno
covar &lt;- match(iron$covar$sex, c("f", "m")) # make numeric
names(covar) &lt;- rownames(iron$covar)

# perform genome scan
hsq &lt;- est_herit(pheno, kinship, covar)

</code></pre>

<hr>
<h2 id='est_map'>Estimate genetic maps</h2><span id='topic+est_map'></span>

<h3>Description</h3>

<p>Uses a hidden Markov model to re-estimate the genetic map for an
experimental cross, with possible allowance for genotyping errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_map(
  cross,
  error_prob = 0.0001,
  map_function = c("haldane", "kosambi", "c-f", "morgan"),
  lowmem = FALSE,
  maxit = 10000,
  tol = 0.000001,
  quiet = TRUE,
  save_rf = FALSE,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est_map_+3A_cross">cross</code></td>
<td>
<p>Object of class <code>"cross2"</code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.</p>
</td></tr>
<tr><td><code id="est_map_+3A_error_prob">error_prob</code></td>
<td>
<p>Assumed genotyping error probability</p>
</td></tr>
<tr><td><code id="est_map_+3A_map_function">map_function</code></td>
<td>
<p>Character string indicating the map function to
use to convert genetic distances to recombination fractions.</p>
</td></tr>
<tr><td><code id="est_map_+3A_lowmem">lowmem</code></td>
<td>
<p>If <code>FALSE</code>, precalculate initial and emission
probabilities, and at each iteration calculate the transition
matrices for a chromosome; potentially a lot faster but using
more memory. Needs to be tailored somewhat to cross type. For
example, multi-way RIL may need to reorder the transition
matrix according to cross order, and AIL and DO need separate
transition matrices for each generation.</p>
</td></tr>
<tr><td><code id="est_map_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations in EM algorithm.</p>
</td></tr>
<tr><td><code id="est_map_+3A_tol">tol</code></td>
<td>
<p>Tolerance for determining convergence</p>
</td></tr>
<tr><td><code id="est_map_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code>, print progress messages.</p>
</td></tr>
<tr><td><code id="est_map_+3A_save_rf">save_rf</code></td>
<td>
<p>If <code>TRUE</code>, save the estimated recombination
fractions as an attribute (<code>"rf"</code>) of the result.</p>
</td></tr>
<tr><td><code id="est_map_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The map is estimated assuming no crossover interference,
but a map function (by default, Haldane's) is used to derive the genetic distances.
</p>


<h3>Value</h3>

<p>A list of numeric vectors, with the estimated marker
locations (in cM). The location of the initial marker on each
chromosome is kept the same as in the input <code>cross</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))

gmap &lt;- est_map(grav2, error_prob=0.002)
</code></pre>

<hr>
<h2 id='find_dup_markers'>Find markers with identical genotype data</h2><span id='topic+find_dup_markers'></span>

<h3>Description</h3>

<p>Identify sets of markers with identical genotype data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_dup_markers(cross, chr, exact_only = TRUE, adjacent_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_dup_markers_+3A_cross">cross</code></td>
<td>
<p>Object of class <code>"cross2"</code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.</p>
</td></tr>
<tr><td><code id="find_dup_markers_+3A_chr">chr</code></td>
<td>
<p>Optional vector specifying which chromosomes to consider.
This may be a logical, numeric, or character string vector.</p>
</td></tr>
<tr><td><code id="find_dup_markers_+3A_exact_only">exact_only</code></td>
<td>
<p>If TRUE, look only for markers that have matching
genotypes and the same pattern of missing data; if FALSE, also look for
cases where the observed genotypes at one marker match those at
another, and where the first marker has missing genotype whenever the
genotype for the second marker is missing.</p>
</td></tr>
<tr><td><code id="find_dup_markers_+3A_adjacent_only">adjacent_only</code></td>
<td>
<p>If TRUE, look only for sets of markers that are
adjacent to each other.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>exact.only=TRUE</code>, we look only for groups of markers whose
pattern of missing data and observed genotypes match exactly.  One
marker (chosen at random) is selected as the name of the group (in the
output of the function).
</p>
<p>If <code>exact.only=FALSE</code>, we look also for markers whose observed genotypes
are contained in the observed genotypes of another marker.  We use a
pair of nested loops, working from the markers with the most observed
genotypes to the markers with the fewest observed genotypes.
</p>


<h3>Value</h3>

<p>A list of marker names; each component is a set of markers whose
genotypes match one other marker, and the name of the component is the
name of the marker that they match.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drop_markers">drop_markers()</a></code>, <code><a href="#topic+drop_nullmarkers">drop_nullmarkers()</a></code>, <code><a href="#topic+reduce_markers">reduce_markers()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
dup &lt;- find_dup_markers(grav2)
grav2_nodup &lt;- drop_markers(grav2, unlist(dup))
</code></pre>

<hr>
<h2 id='find_ibd_segments'>Find IBD segments for a set of strains</h2><span id='topic+find_ibd_segments'></span>

<h3>Description</h3>

<p>Find IBD segments (regions with a lot of shared SNP genotypes) for
a set of strains
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_ibd_segments(geno, map, min_lod = 15, error_prob = 0.001, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_ibd_segments_+3A_geno">geno</code></td>
<td>
<p>List of matrices of founder genotypes. The matrices
correspond to the genotypes on chromosomes and are arrayed as
founders x markers.</p>
</td></tr>
<tr><td><code id="find_ibd_segments_+3A_map">map</code></td>
<td>
<p>List of vectors of marker positions</p>
</td></tr>
<tr><td><code id="find_ibd_segments_+3A_min_lod">min_lod</code></td>
<td>
<p>Threshold for minimum LOD score for a segment</p>
</td></tr>
<tr><td><code id="find_ibd_segments_+3A_error_prob">error_prob</code></td>
<td>
<p>Genotyping error/mutation probability</p>
</td></tr>
<tr><td><code id="find_ibd_segments_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each strain pair on each chromosome, we consider all
marker intervals and calculate a LOD score comparing the two
hypotheses: that the strains are IBD in the interval, vs. that
they are not. We assume that the two strains are homozygous at
all markers, and use the model from Broman and Weber (1999),
which assumes linkage equilibrium between markers and uses a
simple model for genotype frequencies in the presence of genotyping
errors or mutations.
</p>
<p>Note that inference of IBD segments is heavily dependent on how
SNPs were chosen to be genotyped. (For example, were the SNPs ascertained
based on their polymorphism between a particular strain pair?)
</p>


<h3>Value</h3>

<p>A data frame whose rows are IBD segments and whose columns
are:
</p>

<ul>
<li><p> Strain 1
</p>
</li>
<li><p> Strain 2
</p>
</li>
<li><p> Chromosome
</p>
</li>
<li><p> Left marker
</p>
</li>
<li><p> Right marker
</p>
</li>
<li><p> Left position
</p>
</li>
<li><p> Right position
</p>
</li>
<li><p> Left marker index
</p>
</li>
<li><p> Right marker index
</p>
</li>
<li><p> Interval length
</p>
</li>
<li><p> Number of markers
</p>
</li>
<li><p> Number of mismatches
</p>
</li>
<li><p> LOD score
</p>
</li></ul>



<h3>References</h3>

<p>Broman KW, Weber JL (1999) Long homozygous chromosomal segments in
reference families from the Centre dtude du Polymorphisme Humain.
Am J Hum Genet 65:1493&ndash;1500.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load DO data from Recla et al. (2014) Mamm Genome 25:211-222.
recla &lt;- read_cross2("https://raw.githubusercontent.com/rqtl/qtl2data/main/DO_Recla/recla.zip")

# grab founder genotypes and physical map
fg &lt;- recla$founder_geno
pmap &lt;- recla$pmap

# find shared segments
(segs &lt;- find_ibd_segments(fg, pmap, min_lod=10, error_prob=0.0001))

## End(Not run)

</code></pre>

<hr>
<h2 id='find_index_snp'>Find name of indexed snp</h2><span id='topic+find_index_snp'></span>

<h3>Description</h3>

<p>For a particular SNP, find the name of the corresponding indexed SNP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_index_snp(snpinfo, snp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_index_snp_+3A_snpinfo">snpinfo</code></td>
<td>
<p>Data frame with SNP information with the following columns:
</p>

<ul>
<li> <p><code>chr</code> - Character string or factor with chromosome
</p>
</li>
<li> <p><code>index</code> - Numeric index of equivalent, indexed SNP, as produced by <code><a href="#topic+index_snps">index_snps()</a></code>.
</p>
</li>
<li> <p><code>snp</code> - Character string with SNP identifier (if
missing, the rownames are used).
</p>
</li></ul>
</td></tr>
<tr><td><code id="find_index_snp_+3A_snp">snp</code></td>
<td>
<p>Name of snp to look for (can be a vector).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of SNP IDs (the corresponding indexed SNPs), with NA if a SNP is not found.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_marker">find_marker()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data and calculate genotype probabilities
file &lt;- paste0("https://raw.githubusercontent.com/rqtl/",
               "qtl2data/main/DO_Recla/recla.zip")
recla &lt;- read_cross2(file)

# founder genotypes for a set of SNPs
snpgeno &lt;- rbind(m1=c(3,1,1,3,1,1,1,1),
                 m2=c(3,1,1,3,1,1,1,1),
                 m3=c(1,1,1,1,3,3,3,3),
                 m4=c(1,3,1,3,1,3,1,3))
sdp &lt;- calc_sdp(snpgeno)
snpinfo &lt;- data.frame(chr=c("19", "19", "X", "X"),
                      pos=c(40.36, 40.53, 110.91, 111.21),
                      sdp=sdp,
                      snp=c("m1", "m2", "m3", "m4"), stringsAsFactors=FALSE)

# update snp info by adding the SNP index column
snpinfo &lt;- index_snps(recla$pmap, snpinfo)

# find indexed snp for a particular snp
find_index_snp(snpinfo, "m3")

## End(Not run)

</code></pre>

<hr>
<h2 id='find_map_gaps'>Find gaps in a genetic map</h2><span id='topic+find_map_gaps'></span>

<h3>Description</h3>

<p>Find gaps between markers in a genetic map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_map_gaps(map, min_gap = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_map_gaps_+3A_map">map</code></td>
<td>
<p>Genetic map as a list of vectors (each vector is a
chromosome and contains the marker positions).</p>
</td></tr>
<tr><td><code id="find_map_gaps_+3A_min_gap">min_gap</code></td>
<td>
<p>Minimum gap length to return.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with 6 columns: chromosome, marker to left of gap,
numeric index of marker to left, marker to right of gap, numeric
index of marker to right, and the length of the gap.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reduce_map_gaps">reduce_map_gaps()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))
find_map_gaps(iron$gmap, 40)

</code></pre>

<hr>
<h2 id='find_marker'>Find markers by chromosome position</h2><span id='topic+find_marker'></span>

<h3>Description</h3>

<p>Find markers closest to specified set of positions, or within a specified interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_marker(map, chr, pos = NULL, interval = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_marker_+3A_map">map</code></td>
<td>
<p>A map object: a list (corresponding to chromosomes) of
vectors of marker positions. Can also be a snpinfo object (data
frame with columns <code>chr</code> and <code>pos</code>; marker names taken from
column <code>snp</code> or if that doesn't exist from the row names)</p>
</td></tr>
<tr><td><code id="find_marker_+3A_chr">chr</code></td>
<td>
<p>A vector of chromosomes</p>
</td></tr>
<tr><td><code id="find_marker_+3A_pos">pos</code></td>
<td>
<p>A vector of positions</p>
</td></tr>
<tr><td><code id="find_marker_+3A_interval">interval</code></td>
<td>
<p>A pair of positions (provide either <code>pos</code> or <code>interval</code> but not both)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>pos</code> is provided, <code>interval</code> should not be, and vice versa.
</p>
<p>If <code>pos</code> is provided, then <code>chr</code> and <code>pos</code> should
either be the same length, or one of them should have length 1 (to
be expanded to the length of the other).
</p>
<p>If <code>interval</code> is provided, then <code>chr</code> should have length 1.
</p>


<h3>Value</h3>

<p>A vector of marker names, either closest to the positions
specified by <code>pos</code>, or within the interval defined by
<code>interval</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_markerpos">find_markerpos()</a></code>, <code><a href="#topic+find_index_snp">find_index_snp()</a></code>, <code><a href="#topic+pull_genoprobpos">pull_genoprobpos()</a></code>, <code><a href="#topic+pull_genoprobint">pull_genoprobint()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))

# find markers by their genetic map positions
find_marker(iron$gmap, c(8, 11), c(37.7, 56.9))

# find markers by their physical map positions (two markers on chr 7)
find_marker(iron$pmap, 7, c(44.2, 108.9))

# find markers in an interval
find_marker(iron$pmap, 16, interval=c(35, 80))
</code></pre>

<hr>
<h2 id='find_markerpos'>Find positions of markers</h2><span id='topic+find_markerpos'></span>

<h3>Description</h3>

<p>Find positions of markers within a cross object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_markerpos(cross, markers, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_markerpos_+3A_cross">cross</code></td>
<td>
<p>Object of class <code>"cross2"</code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.
Can also be a map (as a list of vectors of marker positions).</p>
</td></tr>
<tr><td><code id="find_markerpos_+3A_markers">markers</code></td>
<td>
<p>A vector of marker names.</p>
</td></tr>
<tr><td><code id="find_markerpos_+3A_na.rm">na.rm</code></td>
<td>
<p>If TRUE, don't include not-found markers in the
results (but issue a warning if some markers weren't found). If
FALSE, include those markers with <code>NA</code> for chr and position.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with chromosome and genetic and physical
positions (in columns <code>"gmap"</code> and <code>"pmap"</code>), with markers as
row names. If the input <code>cross</code> is not a cross2 object but
rather a map, the output contains <code>chr</code> and <code>pos</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_marker">find_marker()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))

# find markers
find_markerpos(iron, c("D8Mit294", "D11Mit101"))
</code></pre>

<hr>
<h2 id='find_peaks'>Find peaks in a set of LOD curves</h2><span id='topic+find_peaks'></span>

<h3>Description</h3>

<p>Find peaks in a set of LOD curves (output from <code><a href="#topic+scan1">scan1()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_peaks(
  scan1_output,
  map,
  threshold = 3,
  peakdrop = Inf,
  drop = NULL,
  prob = NULL,
  thresholdX = NULL,
  peakdropX = NULL,
  dropX = NULL,
  probX = NULL,
  expand2markers = TRUE,
  sort_by = c("column", "pos", "lod"),
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_peaks_+3A_scan1_output">scan1_output</code></td>
<td>
<p>An object of class <code>"scan1"</code> as returned by
<code><a href="#topic+scan1">scan1()</a></code>.</p>
</td></tr>
<tr><td><code id="find_peaks_+3A_map">map</code></td>
<td>
<p>A list of vectors of marker positions, as produced by
<code><a href="#topic+insert_pseudomarkers">insert_pseudomarkers()</a></code>. Can also be an indexed SNP info table,
as from <code><a href="#topic+index_snps">index_snps()</a></code> or <code><a href="#topic+scan1snps">scan1snps()</a></code>.</p>
</td></tr>
<tr><td><code id="find_peaks_+3A_threshold">threshold</code></td>
<td>
<p>Minimum LOD score for a peak (can be a vector with
separate thresholds for each lod score column in
<code>scan1_output</code>)</p>
</td></tr>
<tr><td><code id="find_peaks_+3A_peakdrop">peakdrop</code></td>
<td>
<p>Amount that the LOD score must drop between peaks,
if multiple peaks are to be defined on a chromosome. (Can be a vector with
separate values for each lod score column in
<code>scan1_output</code>.)</p>
</td></tr>
<tr><td><code id="find_peaks_+3A_drop">drop</code></td>
<td>
<p>If provided, LOD support intervals are included in the
results, and this indicates the amount to drop in the support
interval. (Can be a vector with
separate values for each lod score column in
<code>scan1_output</code>.) Must be <code class="reqn">\le</code> <code>peakdrop</code></p>
</td></tr>
<tr><td><code id="find_peaks_+3A_prob">prob</code></td>
<td>
<p>If provided, Bayes credible intervals are included in the
results, and this indicates the nominal coverage.
(Can be a vector with
separate values for each lod score column in
<code>scan1_output</code>.) Provide just one of <code>drop</code> and <code>prob</code>.</p>
</td></tr>
<tr><td><code id="find_peaks_+3A_thresholdx">thresholdX</code></td>
<td>
<p>Separate threshold for the X chromosome; if
unspecified, the same threshold is used for both autosomes and the
X chromosome. (Like <code>threshold</code>, this can be a vector with
separate thresholds for each lod score column.)</p>
</td></tr>
<tr><td><code id="find_peaks_+3A_peakdropx">peakdropX</code></td>
<td>
<p>Like <code>peakdrop</code>, but for the X chromosome; if
unspecified, the same value is used for both autosomes and the X
chromosome.  (Can be a vector with separate values for each lod
score column in <code>scan1_output</code>.)</p>
</td></tr>
<tr><td><code id="find_peaks_+3A_dropx">dropX</code></td>
<td>
<p>Amount to drop for LOD support intervals on the X
chromosome.  Ignored if <code>drop</code> is not provided. (Can be a
vector with separate values for each lod score column in
<code>scan1_output</code>.)</p>
</td></tr>
<tr><td><code id="find_peaks_+3A_probx">probX</code></td>
<td>
<p>Nominal coverage for Bayes intervals on the X
chromosome.  Ignored if <code>prob</code> is not provided. (Can be a
vector with separate values for each lod score column in
<code>scan1_output</code>.)</p>
</td></tr>
<tr><td><code id="find_peaks_+3A_expand2markers">expand2markers</code></td>
<td>
<p>If TRUE (and if <code>drop</code> or <code>prob</code> is
provided, so that QTL intervals are calculated), QTL intervals are
expanded so that their endpoints are at genetic markers.</p>
</td></tr>
<tr><td><code id="find_peaks_+3A_sort_by">sort_by</code></td>
<td>
<p>Indicates whether to sort the rows by lod column,
genomic position, or LOD score.</p>
</td></tr>
<tr><td><code id="find_peaks_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each lod score column on each chromosome, we return a
set of peaks defined as local maxima that exceed the specified
<code>threshold</code>, with the requirement that the LOD score must have
dropped by at least <code>peakdrop</code> below the lowest of any two
adjacent peaks.
</p>
<p>At a given peak, if there are ties, with multiple positions jointly
achieving the maximum LOD score, we take the average of these
positions as the location of the peak.
</p>


<h3>Value</h3>

<p>A data frame with each row being a single peak on a single
chromosome for a single LOD score column, and with columns
</p>

<ul>
<li> <p><code>lodindex</code> - lod column index
</p>
</li>
<li> <p><code>lodcolumn</code> - lod column name
</p>
</li>
<li> <p><code>chr</code> - chromosome ID
</p>
</li>
<li> <p><code>pos</code> - peak position
</p>
</li>
<li> <p><code>lod</code> - lod score at peak
</p>
</li></ul>

<p>If <code>drop</code> or <code>prob</code> is provided, the results will include
two additional columns: <code>ci_lo</code> and <code>ci_hi</code>, with the
endpoints of the LOD support intervals or Bayes credible wintervals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scan1">scan1()</a></code>, <code><a href="#topic+lod_int">lod_int()</a></code>, <code><a href="#topic+bayes_int">bayes_int()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))


# insert pseudomarkers into map
map &lt;- insert_pseudomarkers(iron$gmap, step=1)

# calculate genotype probabilities
probs &lt;- calc_genoprob(iron, map, error_prob=0.002)

# grab phenotypes and covariates; ensure that covariates have names attribute
pheno &lt;- iron$pheno
covar &lt;- match(iron$covar$sex, c("f", "m")) # make numeric
names(covar) &lt;- rownames(iron$covar)
Xcovar &lt;- get_x_covar(iron)

# perform genome scan
out &lt;- scan1(probs, pheno, addcovar=covar, Xcovar=Xcovar)

# find just the highest peak on each chromosome
find_peaks(out, map, threshold=3)

# possibly multiple peaks per chromosome
find_peaks(out, map, threshold=3, peakdrop=1)

# possibly multiple peaks, also getting 1-LOD support intervals
find_peaks(out, map, threshold=3, peakdrop=1, drop=1)

# possibly multiple peaks, also getting 90% Bayes intervals
find_peaks(out, map, threshold=3, peakdrop=1, prob=0.9)
</code></pre>

<hr>
<h2 id='fit1'>Fit single-QTL model at a single position</h2><span id='topic+fit1'></span>

<h3>Description</h3>

<p>Fit a single-QTL model at a single putative QTL position and get detailed results
about estimated coefficients and individuals contributions to the LOD score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit1(
  genoprobs,
  pheno,
  kinship = NULL,
  addcovar = NULL,
  nullcovar = NULL,
  intcovar = NULL,
  weights = NULL,
  contrasts = NULL,
  model = c("normal", "binary"),
  zerosum = TRUE,
  se = TRUE,
  hsq = NULL,
  reml = TRUE,
  blup = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit1_+3A_genoprobs">genoprobs</code></td>
<td>
<p>A matrix of genotype probabilities, individuals x genotypes.
If NULL, we create a single intercept column, matching the individual IDs in <code>pheno</code>.</p>
</td></tr>
<tr><td><code id="fit1_+3A_pheno">pheno</code></td>
<td>
<p>A numeric vector of phenotype values (just one phenotype, not a matrix of them)</p>
</td></tr>
<tr><td><code id="fit1_+3A_kinship">kinship</code></td>
<td>
<p>Optional kinship matrix.</p>
</td></tr>
<tr><td><code id="fit1_+3A_addcovar">addcovar</code></td>
<td>
<p>An optional numeric matrix of additive covariates.</p>
</td></tr>
<tr><td><code id="fit1_+3A_nullcovar">nullcovar</code></td>
<td>
<p>An optional numeric matrix of additional additive
covariates that are used under the null hypothesis (of no QTL)
but not under the alternative (with a QTL). This is needed for
the X chromosome, where we might need sex as a additive
covariate under the null hypothesis, but we wouldn't want to
include it under the alternative as it would be collinear with
the QTL effects.</p>
</td></tr>
<tr><td><code id="fit1_+3A_intcovar">intcovar</code></td>
<td>
<p>An optional numeric matrix of interactive covariates.</p>
</td></tr>
<tr><td><code id="fit1_+3A_weights">weights</code></td>
<td>
<p>An optional numeric vector of positive weights for the
individuals. As with the other inputs, it must have <code>names</code>
for individual identifiers.</p>
</td></tr>
<tr><td><code id="fit1_+3A_contrasts">contrasts</code></td>
<td>
<p>An optional numeric matrix of genotype contrasts, size
genotypes x genotypes. For an intercross, you might use
<code>cbind(mu=c(1,1,1), a=c(-1, 0, 1), d=c(0, 1, 0))</code> to get
mean, additive effect, and dominance effect. The default is the
identity matrix.</p>
</td></tr>
<tr><td><code id="fit1_+3A_model">model</code></td>
<td>
<p>Indicates whether to use a normal model (least
squares) or binary model (logistic regression) for the phenotype.
If <code>model="binary"</code>, the phenotypes must have values in
<code class="reqn">[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="fit1_+3A_zerosum">zerosum</code></td>
<td>
<p>If TRUE, force the genotype or allele coefficients
sum to 0 by subtracting their mean and add another column with
the mean. Ignored if <code>contrasts</code> is provided.</p>
</td></tr>
<tr><td><code id="fit1_+3A_se">se</code></td>
<td>
<p>If TRUE, calculate the standard errors.</p>
</td></tr>
<tr><td><code id="fit1_+3A_hsq">hsq</code></td>
<td>
<p>(Optional) residual heritability; used only if
<code>kinship</code> provided.</p>
</td></tr>
<tr><td><code id="fit1_+3A_reml">reml</code></td>
<td>
<p>If <code>kinship</code> provided: if <code>reml=TRUE</code>, use
REML; otherwise maximum likelihood.</p>
</td></tr>
<tr><td><code id="fit1_+3A_blup">blup</code></td>
<td>
<p>If TRUE, fit a model with QTL effects being random, as in <code><a href="#topic+scan1blup">scan1blup()</a></code>.</p>
</td></tr>
<tr><td><code id="fit1_+3A_...">...</code></td>
<td>
<p>Additional control parameters; see Details;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each of the inputs, the row names are used as
individual identifiers, to align individuals.
</p>
<p>If <code>kinship</code> is absent, Haley-Knott regression is performed.
If <code>kinship</code> is provided, a linear mixed model is used, with a
polygenic effect estimated under the null hypothesis of no (major)
QTL, and then taken as fixed as known in the genome scan.
</p>
<p>If <code>contrasts</code> is provided, the genotype probability matrix,
<code class="reqn">P</code>, is post-multiplied by the contrasts matrix, <code class="reqn">A</code>, prior
to fitting the model. So we use <code class="reqn">P \cdot A</code> as the <code class="reqn">X</code>
matrix in the model. One might view the rows of
<em>A</em><sup>-1</sup>
as the set of contrasts, as the estimated effects are the estimated
genotype effects pre-multiplied by
<em>A</em><sup>-1</sup>.
</p>
<p>The <code>...</code> argument can contain several additional control
parameters; suspended for simplicity (or confusion, depending on
your point of view). <code>tol</code> is used as a tolerance value for linear
regression by QR decomposition (in determining whether columns are
linearly dependent on others and should be omitted); default
<code>1e-12</code>. <code>maxit</code> is the maximum number of iterations for
converence of the iterative algorithm used when <code>model=binary</code>.
<code>bintol</code> is used as a tolerance for converence for the iterative
algorithm used when <code>model=binary</code>. <code>eta_max</code> is the maximum value
for the &quot;linear predictor&quot; in the case <code>model="binary"</code> (a bit of a
technicality to avoid fitted values exactly at 0 or 1).
</p>


<h3>Value</h3>

<p>A list containing
</p>

<ul>
<li> <p><code>coef</code> - Vector of estimated coefficients.
</p>
</li>
<li> <p><code>SE</code> - Vector of estimated standard errors (included if <code>se=TRUE</code>).
</p>
</li>
<li> <p><code>lod</code> - The overall lod score.
</p>
</li>
<li> <p><code>ind_lod</code> - Vector of individual contributions to the LOD score (not provided if <code>kinship</code> is used).
</p>
</li>
<li> <p><code>fitted</code>  - Fitted values.
</p>
</li>
<li> <p><code>resid</code>  - Residuals.
If <code>blup==TRUE</code>, only <code>coef</code> and <code>SE</code> are included at present.
</p>
</li></ul>



<h3>References</h3>

<p>Haley CS, Knott SA (1992) A simple
regression method for mapping quantitative trait loci in line
crosses using flanking markers.  Heredity 69:315&ndash;324.
</p>
<p>Kang HM, Zaitlen NA, Wade CM, Kirby A, Heckerman D, Daly MJ, Eskin
E (2008) Efficient control of population structure in model
organism association mapping. Genetics 178:1709&ndash;1723.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pull_genoprobpos">pull_genoprobpos()</a></code>, <code><a href="#topic+find_marker">find_marker()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))


# insert pseudomarkers into map
map &lt;- insert_pseudomarkers(iron$gmap, step=5)

# calculate genotype probabilities
probs &lt;- calc_genoprob(iron, map, error_prob=0.002)

# grab phenotypes and covariates; ensure that covariates have names attribute
pheno &lt;- iron$pheno[,1]
covar &lt;- match(iron$covar$sex, c("f", "m")) # make numeric
names(covar) &lt;- rownames(iron$covar)

# scan chromosome 7 to find peak
out &lt;- scan1(probs[,"7"], pheno, addcovar=covar)

# find peak position
max_pos &lt;- max(out, map)

# genoprobs at max position
pr_max &lt;- pull_genoprobpos(probs, map, max_pos$chr, max_pos$pos)

# fit QTL model just at that position
out_fit1 &lt;- fit1(pr_max, pheno, addcovar=covar)

</code></pre>

<hr>
<h2 id='fread_csv'>Read a csv file</h2><span id='topic+fread_csv'></span>

<h3>Description</h3>

<p>Read a csv file via <code><a href="data.table.html#topic+fread">data.table::fread()</a></code> using a
particular set of options, including the ability to transpose the
result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fread_csv(
  filename,
  sep = ",",
  na.strings = c("NA", "-"),
  comment.char = "#",
  transpose = FALSE,
  rownames_included = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fread_csv_+3A_filename">filename</code></td>
<td>
<p>Name of input file</p>
</td></tr>
<tr><td><code id="fread_csv_+3A_sep">sep</code></td>
<td>
<p>Field separator</p>
</td></tr>
<tr><td><code id="fread_csv_+3A_na.strings">na.strings</code></td>
<td>
<p>Missing value codes</p>
</td></tr>
<tr><td><code id="fread_csv_+3A_comment.char">comment.char</code></td>
<td>
<p>Comment character; rest of line after this character is ignored</p>
</td></tr>
<tr><td><code id="fread_csv_+3A_transpose">transpose</code></td>
<td>
<p>If TRUE, transpose the result</p>
</td></tr>
<tr><td><code id="fread_csv_+3A_rownames_included">rownames_included</code></td>
<td>
<p>If TRUE, the first column is taken to be row names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Initial two lines can contain comments with number of rows
and columns. Number of columns includes an ID column; number of
rows does not include the header row.
</p>
<p>The first column is taken to be a set of row names
</p>


<h3>Value</h3>

<p>Data frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fread_csv_numer">fread_csv_numer()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: mydata &lt;- fread_csv("myfile.csv", transpose=TRUE)
</code></pre>

<hr>
<h2 id='fread_csv_numer'>Read a csv file that has numeric columns</h2><span id='topic+fread_csv_numer'></span>

<h3>Description</h3>

<p>Read a csv file via <code><a href="data.table.html#topic+fread">data.table::fread()</a></code> using a
particular set of options, including the ability to transpose the
result. This version assumes that the contents other than the first
column and the header row are strictly numeric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fread_csv_numer(
  filename,
  sep = ",",
  na.strings = c("NA", "-"),
  comment.char = "#",
  transpose = FALSE,
  rownames_included = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fread_csv_numer_+3A_filename">filename</code></td>
<td>
<p>Name of input file</p>
</td></tr>
<tr><td><code id="fread_csv_numer_+3A_sep">sep</code></td>
<td>
<p>Field separator</p>
</td></tr>
<tr><td><code id="fread_csv_numer_+3A_na.strings">na.strings</code></td>
<td>
<p>Missing value codes</p>
</td></tr>
<tr><td><code id="fread_csv_numer_+3A_comment.char">comment.char</code></td>
<td>
<p>Comment character; rest of line after this character is ignored</p>
</td></tr>
<tr><td><code id="fread_csv_numer_+3A_transpose">transpose</code></td>
<td>
<p>If TRUE, transpose the result</p>
</td></tr>
<tr><td><code id="fread_csv_numer_+3A_rownames_included">rownames_included</code></td>
<td>
<p>If TRUE, the first column is taken to be row names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Initial two lines can contain comments with number of rows
and columns. Number of columns includes an ID column; number of
rows does not include the header row.
</p>
<p>The first column is taken to be a set of row names
</p>


<h3>Value</h3>

<p>Data frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fread_csv">fread_csv()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: mydata &lt;- fread_csv_numer("myfile.csv", transpose=TRUE)
</code></pre>

<hr>
<h2 id='genoprob_to_alleleprob'>Convert genotype probabilities to allele probabilities</h2><span id='topic+genoprob_to_alleleprob'></span>

<h3>Description</h3>

<p>Reduce genotype probabilities (as calculated by
<code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>) to allele probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genoprob_to_alleleprob(probs, quiet = TRUE, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genoprob_to_alleleprob_+3A_probs">probs</code></td>
<td>
<p>Genotype probabilities, as calculated from
<code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.</p>
</td></tr>
<tr><td><code id="genoprob_to_alleleprob_+3A_quiet">quiet</code></td>
<td>
<p>IF <code>FALSE</code>, print progress messages.</p>
</td></tr>
<tr><td><code id="genoprob_to_alleleprob_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"calc_genoprob"</code>, like the input <code>probs</code>,
but with probabilities collapsed to alleles rather than genotypes. See <code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))
gmap_w_pmar &lt;- insert_pseudomarkers(iron, step=1)
probs &lt;- calc_genoprob(iron, gmap_w_pmar, error_prob=0.002)
allele_probs &lt;- genoprob_to_alleleprob(probs)
</code></pre>

<hr>
<h2 id='genoprob_to_snpprob'>Convert genotype probabilities to SNP probabilities</h2><span id='topic+genoprob_to_snpprob'></span>

<h3>Description</h3>

<p>For multi-parent populations, convert use founder genotypes at a
set of SNPs to convert founder-based genotype probabilities to SNP
genotype probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genoprob_to_snpprob(genoprobs, snpinfo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genoprob_to_snpprob_+3A_genoprobs">genoprobs</code></td>
<td>
<p>Genotype probabilities as
calculated by <code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.</p>
</td></tr>
<tr><td><code id="genoprob_to_snpprob_+3A_snpinfo">snpinfo</code></td>
<td>
<p>Data frame with SNP information with the following
columns (the last three are generally derived with
<code><a href="#topic+index_snps">index_snps()</a></code>):
</p>

<ul>
<li> <p><code>chr</code> - Character string or factor with chromosome
</p>
</li>
<li> <p><code>pos</code> - Position (in same units as in the <code>"map"</code>
attribute in <code>genoprobs</code>.
</p>
</li>
<li> <p><code>sdp</code> - Strain distribution pattern: an integer, between
1 and <code class="reqn">2^n - 2</code> where <code class="reqn">n</code> is the number of strains, whose
binary encoding indicates the founder genotypes
</p>
</li>
<li> <p><code>snp</code> - Character string with SNP identifier (if
missing, the rownames are used).
</p>
</li>
<li> <p><code>index</code> - Indices that indicate equivalent
groups of SNPs, calculated by <code><a href="#topic+index_snps">index_snps()</a></code>.
</p>
</li>
<li> <p><code>intervals</code> - Indexes that indicate which marker
intervals the SNPs reside.
</p>
</li>
<li> <p><code>on_map</code> - Indicate whether SNP coincides with a marker
in the <code>genoprobs</code>
</p>
</li></ul>

<p>Alternatively, <code>snpinfo</code> can be a object of class <code>"cross2"</code>,
as output by <code><a href="#topic+read_cross2">read_cross2()</a></code>, containing the data for a multi-parent
population with founder genotypes, in which case the SNP
information for all markers with complete founder genotype data is
calculated and then used. But, in this case, the genotype
probabilities must be at the markers in the cross.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We first split the SNPs by chromosome and use
<code>snpinfo$index</code> to subset to non-equivalent SNPs.
<code>snpinfo$interval</code> indicates the intervals in the genotype
probabilities that contain each. For SNPs contained within an
interval, we use the average of the probabilities for the two
endpoints. We then collapse the probabilities according to the
strain distribution pattern.
</p>


<h3>Value</h3>

<p>An object of class <code>"calc_genoprob"</code>, like the input <code>genoprobs</code>,
but with imputed genotype probabilities at the selected SNPs indicated in
<code>snpinfo$index</code>. See <code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.
</p>
<p>If the input <code>genoprobs</code> is for allele probabilities, the
<code>probs</code> output has just two probability columns (for the two SNP
alleles). If the input has a full set of <code class="reqn">n(n+1)/2</code>
probabilities for <code class="reqn">n</code> strains, the <code>probs</code> output has 3 probabilities
(for the three SNP genotypes). If the input has full genotype
probabilities for the X chromosome (<code class="reqn">n(n+1)/2</code> genotypes for
the females followed by <code class="reqn">n</code> hemizygous genotypes for the
males), the output has 5 probabilities: the 3 female SNP genotypes
followed by the two male hemizygous SNP genotypes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+index_snps">index_snps()</a></code>, <code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>, <code><a href="#topic+scan1snps">scan1snps()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data and calculate genotype probabilities
file &lt;- paste0("https://raw.githubusercontent.com/rqtl/",
               "qtl2data/main/DO_Recla/recla.zip")
recla &lt;- read_cross2(file)
recla &lt;- recla[c(1:2,53:54), c("19","X")] # subset to 4 mice and 2 chromosomes
probs &lt;- calc_genoprob(recla, error_prob=0.002)

# founder genotypes for a set of SNPs
snpgeno &lt;- rbind(m1=c(3,1,1,3,1,1,1,1),
                 m2=c(1,3,1,3,1,3,1,3),
                 m3=c(1,1,1,1,3,3,3,3),
                 m4=c(1,3,1,3,1,3,1,3))
sdp &lt;- calc_sdp(snpgeno)
snpinfo &lt;- data.frame(chr=c("19", "19", "X", "X"),
                      pos=c(40.36, 40.53, 110.91, 111.21),
                      sdp=sdp,
                      snp=c("m1", "m2", "m3", "m4"), stringsAsFactors=FALSE)

# identify groups of equivalent SNPs
snpinfo &lt;- index_snps(recla$pmap, snpinfo)

# collapse to SNP genotype probabilities
snpprobs &lt;- genoprob_to_snpprob(probs, snpinfo)

# could also first convert to allele probs
aprobs &lt;- genoprob_to_alleleprob(probs)
snpaprobs &lt;- genoprob_to_snpprob(aprobs, snpinfo)

## End(Not run)

</code></pre>

<hr>
<h2 id='get_common_ids'>Get common set of IDs from objects</h2><span id='topic+get_common_ids'></span>

<h3>Description</h3>

<p>For a set objects with IDs as row names (or, for a vector, just
names), find the IDs that are present in all of the objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_common_ids(..., complete.cases = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_common_ids_+3A_...">...</code></td>
<td>
<p>A set of objects: vectors, lists, matrices, data frames,
and/or arrays. If one is a character vector with no names
attribute, it's taken to be a set of IDs, itself.</p>
</td></tr>
<tr><td><code id="get_common_ids_+3A_complete.cases">complete.cases</code></td>
<td>
<p>If TRUE, look at matrices and non-character
vectors and keep only individuals with no missing values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is used (mostly internally) to align phenotypes,
genotype probabilities, and covariates in preparation for a genome
scan. The <code>complete.cases</code> argument is used to omit
individuals with any missing covariate values.
</p>


<h3>Value</h3>

<p>A vector of character strings for the individuals that are
in common.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(0, nrow=10, ncol=5); rownames(x) &lt;- LETTERS[1:10]
y &lt;- matrix(0, nrow=5, ncol=5);  rownames(y) &lt;- LETTERS[(1:5)+7]
z &lt;- LETTERS[5:15]
get_common_ids(x, y, z)

x[8,1] &lt;- NA
get_common_ids(x, y, z)
get_common_ids(x, y, z, complete.cases=TRUE)

</code></pre>

<hr>
<h2 id='get_x_covar'>Get X chromosome covariates</h2><span id='topic+get_x_covar'></span>

<h3>Description</h3>

<p>Get the matrix of covariates to be used for the null hypothesis when
performing QTL analysis with the X chromosome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_x_covar(cross)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_x_covar_+3A_cross">cross</code></td>
<td>
<p>Object of class <code>"cross2"</code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For most crosses, the result is either <code>NULL</code>
(indicating no additional covariates are needed) or a
matrix with a single column containing sex indicators (1 for males
and 0 for females).
</p>
<p>For an intercross, we also consider cross direction. There are
four cases: (1) All male or all female but just one direction: no
covariate; (2) All female but both directions: covariate indicating
cross direction; (3) Both sexes, one direction: covariate
indicating sex; (4) Both sexes, both directions: a covariate
indicating sex and a covariate that is 1 for females from the
reverse direction and 0 otherwise.
</p>


<h3>Value</h3>

<p>A matrix of size individuals x no. covariates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))
xcovar &lt;- get_x_covar(iron)
</code></pre>

<hr>
<h2 id='guess_phase'>Guess phase of imputed genotypes</h2><span id='topic+guess_phase'></span>

<h3>Description</h3>

<p>Turn imputed genotypes into phased genotypes along chromosomes by
attempting to pick the phase that leads to the fewest recombination
events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess_phase(cross, geno, deterministic = FALSE, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guess_phase_+3A_cross">cross</code></td>
<td>
<p>Object of class <code>"cross2"</code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.</p>
</td></tr>
<tr><td><code id="guess_phase_+3A_geno">geno</code></td>
<td>
<p>Imputed genotypes, as a list of matrices, as from <code><a href="#topic+maxmarg">maxmarg()</a></code>.</p>
</td></tr>
<tr><td><code id="guess_phase_+3A_deterministic">deterministic</code></td>
<td>
<p>If TRUE, preferentially put smaller allele first when there's uncertainty.
If FALSE, the order of alleles is random in such cases.</p>
</td></tr>
<tr><td><code id="guess_phase_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We randomly assign the pair of alleles at the first locus
to two haplotypes, and then work left to right, assigning
alleles to haplotypes one locus at a time seeking the fewest
recombination events. The results are subject to arbitrary and
random choices. For example, to the right of a homozygous
region, either orientation is equally reasonable.
</p>


<h3>Value</h3>

<p>If input cross is phase-known (e.g., recombinant inbred lines),
the output will be the input <code>geno</code>. Otherwise, the output
will be a list of three-dimensional arrays of imputed
genotypes, individual x position x haplotype (1/2).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maxmarg">maxmarg()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))
gmap &lt;- insert_pseudomarkers(iron$gmap, step=1)
probs &lt;- calc_genoprob(iron, gmap, error_prob=0.002)
imp_geno &lt;- maxmarg(probs)
ph_geno &lt;- guess_phase(iron, imp_geno)
</code></pre>

<hr>
<h2 id='index_snps'>Create index of equivalent SNPs</h2><span id='topic+index_snps'></span>

<h3>Description</h3>

<p>For a set of SNPs and a map of marker/pseudomarkers, partition the
SNPs into groups that are contained within common intervals and
have the same strain distribution pattern, and then create an index
to a set of distinct SNPs, one per partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_snps(map, snpinfo, tol = 0.00000001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index_snps_+3A_map">map</code></td>
<td>
<p>Physical map of markers and pseudomarkers; generally
created from <code><a href="#topic+insert_pseudomarkers">insert_pseudomarkers()</a></code> and
used for a set of genotype probabilities (calculated with
<code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>) that are to be used to
interpolate SNP genotype probabilities (with
<code><a href="#topic+genoprob_to_snpprob">genoprob_to_snpprob()</a></code>).</p>
</td></tr>
<tr><td><code id="index_snps_+3A_snpinfo">snpinfo</code></td>
<td>
<p>Data frame with SNP information with the following columns:
</p>

<ul>
<li> <p><code>chr</code> - Character string or factor with chromosome
</p>
</li>
<li> <p><code>pos</code> - Position (in same units as in the <code>"map"</code>).
</p>
</li>
<li> <p><code>sdp</code> - Strain distribution pattern: an integer, between
1 and <code class="reqn">2^n - 2</code> where <code class="reqn">n</code> is the number of strains, whose
binary encoding indicates the founder genotypes
</p>
</li>
<li> <p><code>snp</code> - Character string with SNP identifier (if
missing, the rownames are used).
</p>
</li></ul>
</td></tr>
<tr><td><code id="index_snps_+3A_tol">tol</code></td>
<td>
<p>Tolerance for determining whether a SNP is exactly at a
position at which genotype probabilities were already calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We split the SNPs by chromosome and identify the intervals
in the <code>map</code> that contain each. For SNPs within <code>tol</code>
of a position at which the genotype probabilities were
calculated, we take the SNP to be at that position. For each
marker position or interval, we then partition the SNPs into
groups that have distinct strain distribution patterns, and
choose a single index SNP for each partition.
</p>


<h3>Value</h3>

<p>A data frame containing the input <code>snpinfo</code> with three
added columns: <code>"index"</code> (which indicates the groups of
equivalent SNPs), <code>"interval"</code> (which indicates the map
interval containing the SNP, with values starting at 0), and
<code>on_map</code> (which indicates that the SNP is within
<code>tol</code> of a position on the map). The rows get reordered,
so that they are ordered by chromosome and position, and the
values in the <code>"index"</code> column are <em>by chromosome</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genoprob_to_snpprob">genoprob_to_snpprob()</a></code>, <code><a href="#topic+scan1snps">scan1snps()</a></code>, <code><a href="#topic+find_index_snp">find_index_snp()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data and calculate genotype probabilities
file &lt;- paste0("https://raw.githubusercontent.com/rqtl/",
               "qtl2data/main/DO_Recla/recla.zip")
recla &lt;- read_cross2(file)

# founder genotypes for a set of SNPs
snpgeno &lt;- rbind(m1=c(3,1,1,3,1,1,1,1),
                 m2=c(1,3,1,3,1,3,1,3),
                 m3=c(1,1,1,1,3,3,3,3),
                 m4=c(1,3,1,3,1,3,1,3))
sdp &lt;- calc_sdp(snpgeno)
snpinfo &lt;- data.frame(chr=c("19", "19", "X", "X"),
                      pos=c(40.36, 40.53, 110.91, 111.21),
                      sdp=sdp,
                      snp=c("m1", "m2", "m3", "m4"), stringsAsFactors=FALSE)

# update snp info by adding the SNP index column
snpinfo &lt;- index_snps(recla$pmap, snpinfo)

## End(Not run)

</code></pre>

<hr>
<h2 id='insert_pseudomarkers'>Insert pseudomarkers into a marker map</h2><span id='topic+insert_pseudomarkers'></span>

<h3>Description</h3>

<p>Insert pseudomarkers into a map of genetic markers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert_pseudomarkers(
  map,
  step = 0,
  off_end = 0,
  stepwidth = c("fixed", "max"),
  pseudomarker_map = NULL,
  tol = 0.01,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insert_pseudomarkers_+3A_map">map</code></td>
<td>
<p>A list of numeric vectors; each vector gives marker
positions for a single chromosome.</p>
</td></tr>
<tr><td><code id="insert_pseudomarkers_+3A_step">step</code></td>
<td>
<p>Distance between pseudomarkers and markers; if
<code>step=0</code> no pseudomarkers are inserted.</p>
</td></tr>
<tr><td><code id="insert_pseudomarkers_+3A_off_end">off_end</code></td>
<td>
<p>Distance beyond terminal markers in which to insert
pseudomarkers.</p>
</td></tr>
<tr><td><code id="insert_pseudomarkers_+3A_stepwidth">stepwidth</code></td>
<td>
<p>Indicates whether to use a fixed grid
(<code>stepwidth="fixed"</code>) or to use the maximal distance between
pseudomarkers to ensure that no two adjacent markers/pseudomarkers
are more than <code>step</code> apart.</p>
</td></tr>
<tr><td><code id="insert_pseudomarkers_+3A_pseudomarker_map">pseudomarker_map</code></td>
<td>
<p>A map of pseudomarker locations; if provided the
<code>step</code>, <code>off_end</code>, and <code>stepwidth</code> arguments are
ignored.</p>
</td></tr>
<tr><td><code id="insert_pseudomarkers_+3A_tol">tol</code></td>
<td>
<p>Tolerance for determining whether a pseudomarker would duplicate a marker position.</p>
</td></tr>
<tr><td><code id="insert_pseudomarkers_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>stepwidth="fixed"</code>, a grid of pseudomarkers is
added to the marker map.
</p>
<p>If <code>stepwidth="max"</code>, a minimal set of pseudomarkers are
added, so that the maximum distance between adjacent markers or
pseudomarkers is at least <code>step</code>. If two adjacent markers are
separated by less than <code>step</code>, no pseudomarkers will be added
to the interval. If they are more then <code>step</code> apart, a set of
equally-spaced pseudomarkers will be added.
</p>
<p>If <code>pseudomarker_map</code> is provided, then the <code>step</code>,
<code>off_end</code>, and <code>stepwidth</code> arguments are ignored, and the
input <code>pseudomarker_map</code> is taken to be the set of
pseudomarker positions.
</p>


<h3>Value</h3>

<p>A list like the input <code>map</code> with pseudomarkers
inserted. Will also have an attribute <code>"is_x_chr"</code>, taken
from the input <code>map</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>, <code><a href="#topic+calc_grid">calc_grid()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))
gmap_w_pmar &lt;- insert_pseudomarkers(iron$gmap, step=1)
</code></pre>

<hr>
<h2 id='interp_genoprob'>Interpolate genotype probabilities</h2><span id='topic+interp_genoprob'></span>

<h3>Description</h3>

<p>Linear interpolation of genotype probabilities, mostly to get two sets onto the same map for comparison purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interp_genoprob(probs, map, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interp_genoprob_+3A_probs">probs</code></td>
<td>
<p>Genotype probabilities, as calculated from
<code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.</p>
</td></tr>
<tr><td><code id="interp_genoprob_+3A_map">map</code></td>
<td>
<p>List of vectors of map positions.</p>
</td></tr>
<tr><td><code id="interp_genoprob_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We reduce <code>probs</code> to the positions present in <code>map</code> and then
interpolate the genotype probabilities at additional positions
in <code>map</code> by linear interpolation using the two adjacent
positions. Off the ends, we just copy over the first or last
value unchanged.
</p>
<p>In general, it's better to use <code><a href="#topic+insert_pseudomarkers">insert_pseudomarkers()</a></code> and
<code><a href="#topic+calc_genoprob">calc_genoprob()</a></code> to get genotype probabilities at additional
positions along a chromosome. This function is a <strong>very</strong> crude
alternative that was implemented in order to compare genotype
probabilities derived by different methods, where we first need to
get them onto a common set of positions.
</p>


<h3>Value</h3>

<p>An object of class <code>"calc_genoprob"</code>, like the input,
but with additional positions present in <code>map</code>. See <code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))

probs &lt;- calc_genoprob(iron, iron$gmap, error_prob=0.002)

# you generally wouldn't want to do this, but this is an illustration
map &lt;- insert_pseudomarkers(iron$gmap, step=1)
probs_map &lt;- interp_genoprob(probs, map)

</code></pre>

<hr>
<h2 id='interp_map'>Interpolate between maps</h2><span id='topic+interp_map'></span>

<h3>Description</h3>

<p>Use interpolate to convert from one map to another
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interp_map(map, oldmap, newmap)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interp_map_+3A_map">map</code></td>
<td>
<p>The map to be interpolated; a list of vectors.</p>
</td></tr>
<tr><td><code id="interp_map_+3A_oldmap">oldmap</code></td>
<td>
<p>Map with positions in the original scale, as in <code>map</code>.</p>
</td></tr>
<tr><td><code id="interp_map_+3A_newmap">newmap</code></td>
<td>
<p>Map with positions in the new scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of same form as input <code>map</code> but in the units as in <code>newmap</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example data
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))

# positions to interpolate from cM to Mbp
tointerp &lt;- list("7" = c(pos7.1= 5, pos7.2=15, pos7.3=25),
                 "9" = c(pos9.1=20, pos9.2=40))

interp_map(tointerp, iron$gmap, iron$pmap)

</code></pre>

<hr>
<h2 id='invert_sdp'>Calculate SNP genotype matrix from strain distribution patterns</h2><span id='topic+invert_sdp'></span>

<h3>Description</h3>

<p>Calculate the matrix of SNP genotypes from a vector of strain distribution patterns (SDPs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invert_sdp(sdp, n_strains)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invert_sdp_+3A_sdp">sdp</code></td>
<td>
<p>Vector of strain distribution patterns (integers between
1 and <code class="reqn">2^n-2</code> where <code class="reqn">n</code> is the number of strains.</p>
</td></tr>
<tr><td><code id="invert_sdp_+3A_n_strains">n_strains</code></td>
<td>
<p>Number of strains</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of SNP genotypes, markers x strains, coded as 1
(AA) and 3 (BB). Markers with values other than 1 or 3 are omitted,
and monomorphic markers, are omitted.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sdp2char">sdp2char()</a></code>, <code><a href="#topic+calc_sdp">calc_sdp()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sdp &lt;- c(m1=1, m2=12, m3=240)
invert_sdp(sdp, 8)
</code></pre>

<hr>
<h2 id='locate_xo'>Locate crossovers</h2><span id='topic+locate_xo'></span>

<h3>Description</h3>

<p>Estimate the locations of crossovers in each individual on each chromosome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locate_xo(geno, map, quiet = TRUE, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locate_xo_+3A_geno">geno</code></td>
<td>
<p>List of matrices of genotypes (output of <code><a href="#topic+maxmarg">maxmarg()</a></code> or <code><a href="#topic+viterbi">viterbi()</a></code>).</p>
</td></tr>
<tr><td><code id="locate_xo_+3A_map">map</code></td>
<td>
<p>List of vectors with the map positions of the markers.</p>
</td></tr>
<tr><td><code id="locate_xo_+3A_quiet">quiet</code></td>
<td>
<p>If FALSE, print progress messages.</p>
</td></tr>
<tr><td><code id="locate_xo_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lists of estimated crossover locations, with
crossovers placed at the midpoint of the intervals that contain
them.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+count_xo">count_xo()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))
map &lt;- insert_pseudomarkers(iron$gmap, step=1)
pr &lt;- calc_genoprob(iron, map, error_prob=0.002, map_function="c-f")
g &lt;- maxmarg(pr)
pos &lt;- locate_xo(g, iron$gmap)

</code></pre>

<hr>
<h2 id='lod_int'>Calculate LOD support intervals</h2><span id='topic+lod_int'></span>

<h3>Description</h3>

<p>Calculate LOD support intervals for a single LOD curve on a single
chromosome, with the ability to identify intervals for multiple LOD
peaks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lod_int(
  scan1_output,
  map,
  chr = NULL,
  lodcolumn = 1,
  threshold = 0,
  peakdrop = Inf,
  drop = 1.5,
  expand2markers = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lod_int_+3A_scan1_output">scan1_output</code></td>
<td>
<p>An object of class <code>"scan1"</code> as returned by
<code><a href="#topic+scan1">scan1()</a></code>.</p>
</td></tr>
<tr><td><code id="lod_int_+3A_map">map</code></td>
<td>
<p>A list of vectors of marker positions, as produced by
<code><a href="#topic+insert_pseudomarkers">insert_pseudomarkers()</a></code>.</p>
</td></tr>
<tr><td><code id="lod_int_+3A_chr">chr</code></td>
<td>
<p>Chromosome ID to consider (must be a single value).</p>
</td></tr>
<tr><td><code id="lod_int_+3A_lodcolumn">lodcolumn</code></td>
<td>
<p>LOD score column to consider (must be a single value).</p>
</td></tr>
<tr><td><code id="lod_int_+3A_threshold">threshold</code></td>
<td>
<p>Minimum LOD score for a peak.</p>
</td></tr>
<tr><td><code id="lod_int_+3A_peakdrop">peakdrop</code></td>
<td>
<p>Amount that the LOD score must drop between peaks,
if multiple peaks are to be defined on a chromosome.</p>
</td></tr>
<tr><td><code id="lod_int_+3A_drop">drop</code></td>
<td>
<p>Amount to drop in the support interval.  Must be
<code class="reqn">\le</code> <code>peakdrop</code></p>
</td></tr>
<tr><td><code id="lod_int_+3A_expand2markers">expand2markers</code></td>
<td>
<p>If TRUE, QTL intervals are expanded so
that their endpoints are at genetic markers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We identify a set of peaks defined as local maxima that
exceed the specified <code>threshold</code>, with the requirement that
the LOD score must have dropped by at least <code>peakdrop</code> below
the lowest of any two adjacent peaks.
</p>
<p>At a given peak, if there are ties, with multiple positions jointly
achieving the maximum LOD score, we take the average of these
positions as the location of the peak.
</p>
<p>The default is to use <code>threshold=0</code>, <code>peakdrop=Inf</code>, and
<code>drop=1.5</code>. We then return results a single peak, no matter the
maximum LOD score, and give a 1.5-LOD support interval.
</p>


<h3>Value</h3>

<p>A matrix with three columns:
</p>

<ul>
<li> <p><code>ci_lo</code> - lower bound of interval
</p>
</li>
<li> <p><code>pos</code> - peak position
</p>
</li>
<li> <p><code>ci_hi</code> - upper bound of interval
</p>
</li></ul>

<p>Each row corresponds to a different peak.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayes_int">bayes_int()</a></code>, <code><a href="#topic+find_peaks">find_peaks()</a></code>, <code><a href="#topic+scan1">scan1()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))


# insert pseudomarkers into map
map &lt;- insert_pseudomarkers(iron$gmap, step=1)

# calculate genotype probabilities
probs &lt;- calc_genoprob(iron, map, error_prob=0.002)

# grab phenotypes and covariates; ensure that covariates have names attribute
pheno &lt;- iron$pheno
covar &lt;- match(iron$covar$sex, c("f", "m")) # make numeric
names(covar) &lt;- rownames(iron$covar)
Xcovar &lt;- get_x_covar(iron)

# perform genome scan
out &lt;- scan1(probs, pheno, addcovar=covar, Xcovar=Xcovar)

# 1.5-LOD support interval for QTL on chr 7, first phenotype
lod_int(out, map, chr=7, lodcolum=1)
</code></pre>

<hr>
<h2 id='map_to_grid'>Subset a map to positions on a grid</h2><span id='topic+map_to_grid'></span>

<h3>Description</h3>

<p>Subset a map object to the locations on some grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_to_grid(map, grid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_to_grid_+3A_map">map</code></td>
<td>
<p>A list of vectors of marker positions.</p>
</td></tr>
<tr><td><code id="map_to_grid_+3A_grid">grid</code></td>
<td>
<p>A list of logical vectors (aligned with
<code>map</code>), with TRUE indicating the position is on the grid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is generally for the case of a map created with
<code><a href="#topic+insert_pseudomarkers">insert_pseudomarkers()</a></code> with <code>step</code>&gt;0 and
<code>stepwidth="fixed"</code>, so that the pseudomarkers form a grid
along each chromosome.
</p>


<h3>Value</h3>

<p>Same list as input, but subset to just include
pseudomarkers along a grid.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_grid">calc_grid()</a></code>, <code><a href="#topic+probs_to_grid">probs_to_grid()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
map_w_pmar &lt;- insert_pseudomarkers(grav2$gmap, step=1)
sapply(map_w_pmar, length)
grid &lt;- calc_grid(grav2$gmap, step=1)
map_sub &lt;- map_to_grid(map_w_pmar, grid)
sapply(map_sub, length)
</code></pre>

<hr>
<h2 id='mat2strata'>Define strata based on rows of a matrix</h2><span id='topic+mat2strata'></span>

<h3>Description</h3>

<p>Use the rows of a matrix to define a set of strata for a stratified permutation test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat2strata(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat2strata_+3A_mat">mat</code></td>
<td>
<p>A covariate matrix, as individuals x covariates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of character strings: for each row of <code>mat</code>,
we use <code><a href="base.html#topic+paste">base::paste()</a></code> with <code>collapse="|"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_x_covar">get_x_covar()</a></code>, <code><a href="#topic+scan1perm">scan1perm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))

Xcovar &lt;- get_x_covar(iron)
perm_strata &lt;- mat2strata(Xcovar)

</code></pre>

<hr>
<h2 id='max_compare_geno'>Find pair with most similar genotypes</h2><span id='topic+max_compare_geno'></span><span id='topic+max.compare_geno'></span>

<h3>Description</h3>

<p>From results of <code><a href="#topic+compare_geno">compare_geno()</a></code>, show the pair with most similar genotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_compare_geno(object, ...)

## S3 method for class 'compare_geno'
max(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_compare_geno_+3A_object">object</code></td>
<td>
<p>A square matrix with genotype comparisons for pairs
of individuals, as output by <code><a href="#topic+compare_geno">compare_geno()</a></code>.</p>
</td></tr>
<tr><td><code id="max_compare_geno_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with individual pair, proportion matches, number
of mismatches, number of matches, and total markers genotyped.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
cg &lt;- compare_geno(grav2)
max(cg)
</code></pre>

<hr>
<h2 id='max_scan1'>Find position with maximum LOD score</h2><span id='topic+max_scan1'></span><span id='topic+max.scan1'></span>

<h3>Description</h3>

<p>Return data frame with the positions having maximum LOD score for a
particular LOD score column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_scan1(
  scan1_output,
  map = NULL,
  lodcolumn = 1,
  chr = NULL,
  na.rm = TRUE,
  ...
)

## S3 method for class 'scan1'
max(scan1_output, map = NULL, lodcolumn = 1, chr = NULL, na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_scan1_+3A_scan1_output">scan1_output</code></td>
<td>
<p>An object of class <code>"scan1"</code> as returned by
<code><a href="#topic+scan1">scan1()</a></code>.</p>
</td></tr>
<tr><td><code id="max_scan1_+3A_map">map</code></td>
<td>
<p>A list of vectors of marker positions, as produced by
<code><a href="#topic+insert_pseudomarkers">insert_pseudomarkers()</a></code>. Can also be an indexed SNP info table,
as from <code><a href="#topic+index_snps">index_snps()</a></code> or <code><a href="#topic+scan1snps">scan1snps()</a></code>.</p>
</td></tr>
<tr><td><code id="max_scan1_+3A_lodcolumn">lodcolumn</code></td>
<td>
<p>An integer or character string indicating the LOD
score column, either as a numeric index or column name.
If <code>NULL</code>, return maximum for all columns.</p>
</td></tr>
<tr><td><code id="max_scan1_+3A_chr">chr</code></td>
<td>
<p>Optional vector of chromosomes to consider.</p>
</td></tr>
<tr><td><code id="max_scan1_+3A_na.rm">na.rm</code></td>
<td>
<p>Ignored (take to be TRUE)</p>
</td></tr>
<tr><td><code id="max_scan1_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>map</code> is NULL, the genome-wide maximum LOD score for the selected column is returned.
If also <code>lodcolumn</code> is NULL, you get a vector with the maximum LOD for each column.
</p>
<p>If <code>map</code> is provided, the return value is a data.frame with three columns: chr, pos, and lod score.
But if <code>lodcolumn</code> is NULL, you get the maximum for each lod score column, in the format provided by
<code><a href="#topic+find_peaks">find_peaks()</a></code>, so a data.frame with five columns: lodindex, lodcolumn, chr, pos, and lod.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))

# insert pseudomarkers into map
map &lt;- insert_pseudomarkers(iron$gmap, step=1)

# calculate genotype probabilities
probs &lt;- calc_genoprob(iron, map, error_prob=0.002)

# grab phenotypes and covariates; ensure that covariates have names attribute
pheno &lt;- iron$pheno
covar &lt;- match(iron$covar$sex, c("f", "m")) # make numeric
names(covar) &lt;- rownames(iron$covar)
Xcovar &lt;- get_x_covar(iron)

# perform genome scan
out &lt;- scan1(probs, pheno, addcovar=covar, Xcovar=Xcovar)

# maximum of first column
max(out, map)

# maximum of spleen column
max(out, map, lodcolumn="spleen")

# maximum of first column on chr 2
max(out, map, chr="2")
</code></pre>

<hr>
<h2 id='maxlod'>Overall maximum LOD score</h2><span id='topic+maxlod'></span>

<h3>Description</h3>

<p>Find overall maximum LOD score in genome scan results, across all positions and columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxlod(scan1_output, map = NULL, chr = NULL, lodcolumn = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxlod_+3A_scan1_output">scan1_output</code></td>
<td>
<p>An object of class <code>"scan1"</code> as returned by
<code><a href="#topic+scan1">scan1()</a></code>.</p>
</td></tr>
<tr><td><code id="maxlod_+3A_map">map</code></td>
<td>
<p>A list of vectors of marker positions, as produced by
<code><a href="#topic+insert_pseudomarkers">insert_pseudomarkers()</a></code>.</p>
</td></tr>
<tr><td><code id="maxlod_+3A_chr">chr</code></td>
<td>
<p>Optional vector of chromosomes to consider.</p>
</td></tr>
<tr><td><code id="maxlod_+3A_lodcolumn">lodcolumn</code></td>
<td>
<p>An integer or character string indicating the LOD
score column, either as a numeric index or column name.
If <code>NULL</code>, return maximum for all columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single number: the maximum LOD score across all columns and positions for
the selected chromosomes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))

# insert pseudomarkers into map
map &lt;- insert_pseudomarkers(iron$gmap, step=1)

# calculate genotype probabilities
probs &lt;- calc_genoprob(iron, map, error_prob=0.002)

# grab phenotypes and covariates; ensure that covariates have names attribute
pheno &lt;- iron$pheno
covar &lt;- match(iron$covar$sex, c("f", "m")) # make numeric
names(covar) &lt;- rownames(iron$covar)
Xcovar &lt;- get_x_covar(iron)

# perform genome scan
out &lt;- scan1(probs, pheno, addcovar=covar, Xcovar=Xcovar)

# overall maximum
maxlod(out)

# maximum on chromosome 2
maxlod(out, map, "2")
</code></pre>

<hr>
<h2 id='maxmarg'>Find genotypes with maximum marginal probabilities</h2><span id='topic+maxmarg'></span>

<h3>Description</h3>

<p>For each individual at each position, find the genotype with the maximum marginal probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxmarg(
  probs,
  map = NULL,
  minprob = 0.95,
  chr = NULL,
  pos = NULL,
  return_char = FALSE,
  quiet = TRUE,
  cores = 1,
  tol = 0.0000000000001
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxmarg_+3A_probs">probs</code></td>
<td>
<p>Genotype probabilities, as calculated from
<code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.</p>
</td></tr>
<tr><td><code id="maxmarg_+3A_map">map</code></td>
<td>
<p>Map of pseudomarkers in <code>probs</code>. Used only if <code>chr</code> and <code>pos</code> are provided.</p>
</td></tr>
<tr><td><code id="maxmarg_+3A_minprob">minprob</code></td>
<td>
<p>Minimum probability for making a call. If maximum
probability is less then this value, give <code>NA</code>.</p>
</td></tr>
<tr><td><code id="maxmarg_+3A_chr">chr</code></td>
<td>
<p>If provided (along with <code>pos</code>), consider only the single specified position.</p>
</td></tr>
<tr><td><code id="maxmarg_+3A_pos">pos</code></td>
<td>
<p>If provided (along with <code>chr</code>), consider only the single specified position.</p>
</td></tr>
<tr><td><code id="maxmarg_+3A_return_char">return_char</code></td>
<td>
<p>If TRUE, return genotype names as character strings.</p>
</td></tr>
<tr><td><code id="maxmarg_+3A_quiet">quiet</code></td>
<td>
<p>IF <code>FALSE</code>, print progress messages.</p>
</td></tr>
<tr><td><code id="maxmarg_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
<tr><td><code id="maxmarg_+3A_tol">tol</code></td>
<td>
<p>Tolerance value; genotypes with probability that are within
<code>tol</code> of each other are treated as equivalent.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If multiple genotypes share the maximum probability, one is chosen at random.
</p>


<h3>Value</h3>

<p>If <code>chr</code> and <code>pos</code> are provided, a vector of
genotypes is returned. In this case, <code>map</code> is needed.
</p>
<p>Otherwise, the result is a object like that returned by <code><a href="#topic+viterbi">viterbi()</a></code>,
A list of two-dimensional arrays of imputed genotypes,
individuals x positions. Also includes these attributes:
</p>

<ul>
<li> <p><code>crosstype</code> - The cross type of the input <code>cross</code>.
</p>
</li>
<li> <p><code>is_x_chr</code> - Logical vector indicating whether chromosomes
are to be treated as the X chromosome or not, from input <code>cross</code>.
</p>
</li>
<li> <p><code>alleles</code> - Vector of allele codes, from input
<code>cross</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+sim_geno">sim_geno()</a></code>, <code><a href="#topic+viterbi">viterbi()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data and calculate genotype probabilities
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))
pr &lt;- calc_genoprob(iron, error_prob=0.002)

# full set of imputed genotypes
ginf &lt;- maxmarg(pr)

# imputed genotypes at a fixed position
g &lt;- maxmarg(pr, iron$gmap, chr=8, pos=45.5)

# return genotype names rather than integers
g &lt;- maxmarg(pr, iron$gmap, chr=8, pos=45.5, return_char=TRUE)
</code></pre>

<hr>
<h2 id='n_missing'>Count missing genotypes</h2><span id='topic+n_missing'></span><span id='topic+n_typed'></span>

<h3>Description</h3>

<p>Number (or proportion) of missing (or non-missing) genotypes by individual or marker
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_missing(
  cross,
  by = c("individual", "marker"),
  summary = c("count", "proportion")
)

n_typed(
  cross,
  by = c("individual", "marker"),
  summary = c("count", "proportion")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_missing_+3A_cross">cross</code></td>
<td>
<p>An object of class <code>"cross2"</code>, as output by <code><a href="#topic+read_cross2">read_cross2()</a></code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.</p>
</td></tr>
<tr><td><code id="n_missing_+3A_by">by</code></td>
<td>
<p>Whether to summarize by individual or marker</p>
</td></tr>
<tr><td><code id="n_missing_+3A_summary">summary</code></td>
<td>
<p>Whether to take count or proportion</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of counts (or proportions) of missing (or non-missing) genotypes.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>n_missing()</code>: Count missing genotypes
</p>
</li>
<li> <p><code>n_typed()</code>: Count genotypes
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))
nmis_ind &lt;- n_missing(iron)
pmis_mar &lt;- n_typed(iron, "mar", "proportion")
plot(nmis_ind, xlab="Individual", ylab="No. missing genotypes")
plot(pmis_mar, xlab="Markers", ylab="Prop. genotyped")
</code></pre>

<hr>
<h2 id='plot_coef'>Plot QTL effects along chromosome</h2><span id='topic+plot_coef'></span><span id='topic+plot_coefCC'></span><span id='topic+plot.scan1coef'></span>

<h3>Description</h3>

<p>Plot estimated QTL effects along a chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_coef(
  x,
  map,
  columns = NULL,
  col = NULL,
  scan1_output = NULL,
  add = FALSE,
  gap = NULL,
  top_panel_prop = 0.65,
  legend = NULL,
  ...
)

plot_coefCC(
  x,
  map,
  columns = 1:8,
  col = qtl2::CCcolors,
  scan1_output = NULL,
  add = FALSE,
  gap = NULL,
  top_panel_prop = 0.65,
  legend = NULL,
  ...
)

## S3 method for class 'scan1coef'
plot(
  x,
  map,
  columns = 1,
  col = NULL,
  scan1_output = NULL,
  add = FALSE,
  gap = NULL,
  top_panel_prop = 0.65,
  legend = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_coef_+3A_x">x</code></td>
<td>
<p>Estimated QTL effects (&quot;coefficients&quot;) as obtained from
<code><a href="#topic+scan1coef">scan1coef()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_coef_+3A_map">map</code></td>
<td>
<p>A list of vectors of marker positions, as produced by
<code><a href="#topic+insert_pseudomarkers">insert_pseudomarkers()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_coef_+3A_columns">columns</code></td>
<td>
<p>Vector of columns to plot</p>
</td></tr>
<tr><td><code id="plot_coef_+3A_col">col</code></td>
<td>
<p>Vector of colors, same length as <code>columns</code>. If
NULL, some default choices are made.</p>
</td></tr>
<tr><td><code id="plot_coef_+3A_scan1_output">scan1_output</code></td>
<td>
<p>If provided, we make a two-panel plot with
coefficients on top and LOD scores below. Should have just one LOD
score column; if multiple, only the first is used.</p>
</td></tr>
<tr><td><code id="plot_coef_+3A_add">add</code></td>
<td>
<p>If TRUE, add to current plot (must have same map and
chromosomes).</p>
</td></tr>
<tr><td><code id="plot_coef_+3A_gap">gap</code></td>
<td>
<p>Gap between chromosomes. The default is 1% of the total genome length.</p>
</td></tr>
<tr><td><code id="plot_coef_+3A_top_panel_prop">top_panel_prop</code></td>
<td>
<p>If <code>scan1_output</code> provided, this gives the
proportion of the plot that is devoted to the top panel.</p>
</td></tr>
<tr><td><code id="plot_coef_+3A_legend">legend</code></td>
<td>
<p>Location of legend, such as <code>"bottomleft"</code> or <code>"topright"</code> (NULL for no legend)</p>
</td></tr>
<tr><td><code id="plot_coef_+3A_...">...</code></td>
<td>
<p>Additional graphics parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot_coefCC()</code> is the same as <code>plot_coef()</code>, but forcing
<code>columns=1:8</code> and using the Collaborative Cross colors,
<a href="#topic+CCcolors">CCcolors</a>.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Hidden graphics parameters</h3>

<p>A number of graphics parameters can be passed via <code>...</code>. For
example, <code>bgcolor</code> to control the background color, and things
like <code>ylab</code> and <code>ylim</code>. These are not included as formal
parameters in order to avoid cluttering the function definition.
</p>
<p>In the case that <code>scan1_output</code> is provided, <code>col</code>,
<code>ylab</code>, and <code>ylim</code> all control the panel with estimated
QTL effects, while <code>col_lod</code>, <code>ylab_lod</code>, and
<code>ylim_lod</code> control the LOD curve panel.
</p>
<p>If <code>legend</code> is indicated so that a legend is shown, <code>legend_lab</code>
controls the labels in the legend, and <code>legend_ncol</code> indicates the
number of columns in the legend.
</p>


<h3>See Also</h3>

<p><a href="#topic+CCcolors">CCcolors</a>, <code><a href="#topic+plot_scan1">plot_scan1()</a></code>, <code><a href="#topic+plot_snpasso">plot_snpasso()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))

# insert pseudomarkers into map
map &lt;- insert_pseudomarkers(iron$gmap, step=1)

# calculate genotype probabilities
probs &lt;- calc_genoprob(iron, map, error_prob=0.002)

# grab phenotypes and covariates; ensure that covariates have names attribute
pheno &lt;- iron$pheno[,1]
covar &lt;- match(iron$covar$sex, c("f", "m")) # make numeric
names(covar) &lt;- rownames(iron$covar)

# calculate coefficients for chromosome 7
coef &lt;- scan1coef(probs[,7], pheno, addcovar=covar)

# plot QTL effects (note the need to subset the map object, for chromosome 7)
plot(coef, map[7], columns=1:3, col=c("slateblue", "violetred", "green3"))
</code></pre>

<hr>
<h2 id='plot_compare_geno'>Plot of compare_geno object.</h2><span id='topic+plot_compare_geno'></span><span id='topic+plot.compare_geno'></span>

<h3>Description</h3>

<p>From results of <code><a href="#topic+compare_geno">compare_geno()</a></code>, plot histogram of
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_compare_geno(x, rug = TRUE, ...)

## S3 method for class 'compare_geno'
plot(x, rug = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_compare_geno_+3A_x">x</code></td>
<td>
<p>A square matrix with genotype comparisons for pairs
of individuals, as output by <code><a href="#topic+compare_geno">compare_geno()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_compare_geno_+3A_rug">rug</code></td>
<td>
<p>If true, use <code><a href="graphics.html#topic+rug">rug()</a></code> to plot tick marks at observed values below the histogram.</p>
</td></tr>
<tr><td><code id="plot_compare_geno_+3A_...">...</code></td>
<td>
<p>Additional graphics parameters passed to <code><a href="graphics.html#topic+hist">hist()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
cg &lt;- compare_geno(grav2)
plot(cg)
</code></pre>

<hr>
<h2 id='plot_genes'>Plot gene locations for a genomic interval</h2><span id='topic+plot_genes'></span>

<h3>Description</h3>

<p>Plot gene locations for a genomic interval, as rectangles with gene
symbol (and arrow indicating strand/direction) below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_genes(
  genes,
  minrow = 4,
  padding = 0.2,
  colors = c("black", "red3", "green4", "blue3", "orange"),
  scale_pos = 1,
  start_field = "start",
  stop_field = "stop",
  strand_field = "strand",
  name_field = "Name",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_genes_+3A_genes">genes</code></td>
<td>
<p>Data frame containing <code>start</code> and <code>stop</code> in
Mbp, <code>strand</code> (as <code>"-"</code>, <code>"+"</code>, or <code>NA</code>), and
<code>Name</code>.</p>
</td></tr>
<tr><td><code id="plot_genes_+3A_minrow">minrow</code></td>
<td>
<p>Minimum number of rows of genes in the plot</p>
</td></tr>
<tr><td><code id="plot_genes_+3A_padding">padding</code></td>
<td>
<p>Proportion to pad with white space around the genes</p>
</td></tr>
<tr><td><code id="plot_genes_+3A_colors">colors</code></td>
<td>
<p>Vectors of colors, used sequentially and then re-used.</p>
</td></tr>
<tr><td><code id="plot_genes_+3A_scale_pos">scale_pos</code></td>
<td>
<p>Factor by which to scale position (for example, to convert basepairs to Mbp)</p>
</td></tr>
<tr><td><code id="plot_genes_+3A_start_field">start_field</code></td>
<td>
<p>Character string with name of column containing the genes' start positions.</p>
</td></tr>
<tr><td><code id="plot_genes_+3A_stop_field">stop_field</code></td>
<td>
<p>Character string with name of column containing the genes' stop positions.</p>
</td></tr>
<tr><td><code id="plot_genes_+3A_strand_field">strand_field</code></td>
<td>
<p>Character string with name of column containing the genes' strands.
(The values of the corresponding field can be character strings <code>"+"</code> or <code>"-"</code>, or numeric +1 or -1.)</p>
</td></tr>
<tr><td><code id="plot_genes_+3A_name_field">name_field</code></td>
<td>
<p>Character string with name of column containing the genes' names.</p>
</td></tr>
<tr><td><code id="plot_genes_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to <code>plot()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Hidden graphics parameters</h3>

<p>Graphics parameters can be passed via <code>...</code>. For
example, <code>xlim</code> to control the x-axis limits.
These are not included as formal
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genes &lt;- data.frame(chr = c("6", "6", "6", "6", "6", "6", "6", "6"),
                    start = c(139988753, 140680185, 141708118, 142234227, 142587862,
                              143232344, 144398099, 144993835),
                    stop  = c(140041457, 140826797, 141773810, 142322981, 142702315,
                              143260627, 144399821, 145076184),
                    strand = c("-", "+", "-", "-", "-", NA, "+", "-"),
                    Name = c("Plcz1", "Gm30215", "Gm5724", "Slco1a5", "Abcc9",
                             "4930407I02Rik", "Gm31777", "Bcat1"),
                    stringsAsFactors=FALSE)

# use scale_pos=1e-6 because data in bp but we want the plot in Mbp
plot_genes(genes, xlim=c(140, 146), scale_pos=1e-6)
</code></pre>

<hr>
<h2 id='plot_genoprob'>Plot genotype probabilities for one individual on one chromosome.</h2><span id='topic+plot_genoprob'></span><span id='topic+plot.calc_genoprob'></span>

<h3>Description</h3>

<p>Plot the genotype probabilities for one individual on one chromosome, as a heat map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_genoprob(
  probs,
  map,
  ind = 1,
  chr = NULL,
  geno = NULL,
  color_scheme = c("gray", "viridis"),
  col = NULL,
  threshold = 0,
  swap_axes = FALSE,
  ...
)

## S3 method for class 'calc_genoprob'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_genoprob_+3A_probs">probs</code></td>
<td>
<p>Genotype probabilities (as produced by <code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>)
or allele dosages (as produced by <code><a href="#topic+genoprob_to_alleleprob">genoprob_to_alleleprob()</a></code>).</p>
</td></tr>
<tr><td><code id="plot_genoprob_+3A_map">map</code></td>
<td>
<p>Marker map (a list of vectors of marker positions).</p>
</td></tr>
<tr><td><code id="plot_genoprob_+3A_ind">ind</code></td>
<td>
<p>Individual to plot, either a numeric index or an ID.</p>
</td></tr>
<tr><td><code id="plot_genoprob_+3A_chr">chr</code></td>
<td>
<p>Selected chromosome to plot; a single character string.</p>
</td></tr>
<tr><td><code id="plot_genoprob_+3A_geno">geno</code></td>
<td>
<p>Optional vector of genotypes or alleles to be shown
(vector of integers or character strings)</p>
</td></tr>
<tr><td><code id="plot_genoprob_+3A_color_scheme">color_scheme</code></td>
<td>
<p>Color scheme for the heatmap (ignored if <code>col</code> is provided).</p>
</td></tr>
<tr><td><code id="plot_genoprob_+3A_col">col</code></td>
<td>
<p>Optional vector of colors for the heatmap.</p>
</td></tr>
<tr><td><code id="plot_genoprob_+3A_threshold">threshold</code></td>
<td>
<p>Threshold for genotype probabilities; only genotypes that achieve
this value somewhere on the chromosome will be shown.</p>
</td></tr>
<tr><td><code id="plot_genoprob_+3A_swap_axes">swap_axes</code></td>
<td>
<p>If TRUE, swap the axes, so that the genotypes are
on the x-axis and the chromosome position is on the y-axis.</p>
</td></tr>
<tr><td><code id="plot_genoprob_+3A_...">...</code></td>
<td>
<p>Additional graphics parameters passed to <code><a href="graphics.html#topic+image">graphics::image()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_genoprob_+3A_x">x</code></td>
<td>
<p>Genotype probabilities (as produced by
<code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>) or allele dosages (as produced by
<code><a href="#topic+genoprob_to_alleleprob">genoprob_to_alleleprob()</a></code>). (For the S3 type plot
function, this has to be called <code>x</code>.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Hidden graphics parameters</h3>

<p>A number of graphics parameters can be passed via <code>...</code>. For
example, <code>hlines</code>, <code>hlines_col</code>, <code>hlines_lwd</code>, and <code>hlines_lty</code> to
control the horizontal grid lines. (Use <code>hlines=NA</code> to avoid
plotting horizontal grid lines.) Similarly <code>vlines</code>, <code>vlines_col</code>,
<code>vlines_lwd</code>, and <code>vlines_lty</code> for vertical grid lines. You can
also use many standard graphics parameters like <code>xlab</code> and <code>xlim</code>.
These are not included as formal parameters in order to avoid
cluttering the function definition.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_genoprobcomp">plot_genoprobcomp()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data and calculate genotype probabilities
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))
iron &lt;- iron[,"2"] # subset to chr 2
map &lt;- insert_pseudomarkers(iron$gmap, step=1)
pr &lt;- calc_genoprob(iron, map, error_prob=0.002)

# plot the probabilities for the individual labeled "262"
#  (white = 0, black = 1)
plot_genoprob(pr, map, ind="262")

# change the x-axis label
plot_genoprob(pr, map, ind="262", xlab="Position (cM)")

# swap the axes so that the chromosome runs vertically
plot_genoprob(pr, map, ind="262", swap_axes=TRUE, ylab="Position (cM)")

# This is more interesting for a Diversity Outbred mouse example
## Not run: 
file &lt;- paste0("https://raw.githubusercontent.com/rqtl/",
               "qtl2data/main/DOex/DOex.zip")
DOex &lt;- read_cross2(file)
# subset to chr 2 and X and individuals labeled "232" and "256"
DOex &lt;- DOex[c("232", "256"), c("2", "X")]
pr &lt;- calc_genoprob(DOex, error_prob=0.002)
# plot individual "256" on chr 2 (default is to pick first chr in the probs)
plot_genoprob(pr, DOex$pmap, ind="256")

# omit states that never have probability &gt;= 0.5
plot_genoprob(pr, DOex$pmap, ind="256", threshold=0.05)

# X chr male 232: just show the AY-HY genotype probabilities
plot_genoprob(pr, DOex$pmap, ind="232", chr="X", geno=paste0(LETTERS[1:8], "Y"))
# could also indicate genotypes by number
plot_genoprob(pr, DOex$pmap, ind="232", chr="X", geno=37:44)
# and can use negative indexes
plot_genoprob(pr, DOex$pmap, ind="232", chr="X", geno=-(1:36))

# X chr female 256: just show the first 36 genotype probabilities
plot_genoprob(pr, DOex$pmap, ind="256", chr="X", geno=1:36)

# again, can give threshold to omit genotypes whose probabilities never reach that threshold
plot_genoprob(pr, DOex$pmap, ind="256", chr="X", geno=1:36, threshold=0.5)

# can also look at the allele dosages
apr &lt;- genoprob_to_alleleprob(pr)
plot_genoprob(apr, DOex$pmap, ind="232")

## End(Not run)

</code></pre>

<hr>
<h2 id='plot_genoprobcomp'>Plot comparison of two sets of genotype probabilities</h2><span id='topic+plot_genoprobcomp'></span>

<h3>Description</h3>

<p>Plot a comparison of two sets of genotype probabilities for one individual on one chromosome, as a heat map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_genoprobcomp(
  probs1,
  probs2,
  map,
  ind = 1,
  chr = NULL,
  geno = NULL,
  threshold = 0,
  n_colors = 256,
  swap_axes = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_genoprobcomp_+3A_probs1">probs1</code></td>
<td>
<p>Genotype probabilities (as produced by <code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>)
or allele dosages (as produced by <code><a href="#topic+genoprob_to_alleleprob">genoprob_to_alleleprob()</a></code>).</p>
</td></tr>
<tr><td><code id="plot_genoprobcomp_+3A_probs2">probs2</code></td>
<td>
<p>A second set of genotype probabilities, just like <code>probs1</code>.</p>
</td></tr>
<tr><td><code id="plot_genoprobcomp_+3A_map">map</code></td>
<td>
<p>Marker map (a list of vectors of marker positions).</p>
</td></tr>
<tr><td><code id="plot_genoprobcomp_+3A_ind">ind</code></td>
<td>
<p>Individual to plot, either a numeric index or an ID.</p>
</td></tr>
<tr><td><code id="plot_genoprobcomp_+3A_chr">chr</code></td>
<td>
<p>Selected chromosome to plot; a single character string.</p>
</td></tr>
<tr><td><code id="plot_genoprobcomp_+3A_geno">geno</code></td>
<td>
<p>Optional vector of genotypes or alleles to be shown
(vector of integers or character strings)</p>
</td></tr>
<tr><td><code id="plot_genoprobcomp_+3A_threshold">threshold</code></td>
<td>
<p>Threshold for genotype probabilities; only genotypes that achieve
this value somewhere on the chromosome (in one or the other set of probabilities) will be shown.</p>
</td></tr>
<tr><td><code id="plot_genoprobcomp_+3A_n_colors">n_colors</code></td>
<td>
<p>Number of colors in each color scale.</p>
</td></tr>
<tr><td><code id="plot_genoprobcomp_+3A_swap_axes">swap_axes</code></td>
<td>
<p>If TRUE, swap the axes, so that the genotypes are
on the x-axis and the chromosome position is on the y-axis.</p>
</td></tr>
<tr><td><code id="plot_genoprobcomp_+3A_...">...</code></td>
<td>
<p>Additional graphics parameters passed to <code><a href="graphics.html#topic+image">graphics::image()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We plot the first set of probabilities in the range white to blue
and the second set in the range white to red and attempt to combine
them, for colors that are white, some amount of blue or red, or
where both are large something like blackish purple.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_genoprob">plot_genoprob()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))
iron &lt;- iron[228,"1"]   # subset to one individual on chr 1
map &lt;- insert_pseudomarkers(iron$gmap, step=5)

# introduce genotype error and look at difference in genotype probabilities
pr_ne &lt;- calc_genoprob(iron, map, error_prob=0.002)
iron$geno[[1]][1,2] &lt;- 3
pr_e &lt;- calc_genoprob(iron, map, error_prob=0.002)

# image of probabilities + comparison

par(mfrow=c(3,1))
plot_genoprob(pr_ne, map, main="No error")
plot_genoprob(pr_e, map, main="With an error")
plot_genoprobcomp(pr_ne, pr_e, map, main="Comparison")


</code></pre>

<hr>
<h2 id='plot_lodpeaks'>Plot LOD scores vs QTL peak locations</h2><span id='topic+plot_lodpeaks'></span>

<h3>Description</h3>

<p>Create a scatterplot of LOD scores vs QTL peak locations (possibly with intervals) for multiple traits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_lodpeaks(peaks, map, chr = NULL, gap = NULL, intervals = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_lodpeaks_+3A_peaks">peaks</code></td>
<td>
<p>Data frame such as that produced by
<code><a href="#topic+find_peaks">find_peaks()</a></code>) containing columns
<code>chr</code>, <code>pos</code>, <code>lodindex</code>, and <code>lodcolumn</code>.
May also contain columns <code>ci_lo</code> and <code>ci_hi</code>, in
which case intervals will be plotted.</p>
</td></tr>
<tr><td><code id="plot_lodpeaks_+3A_map">map</code></td>
<td>
<p>Marker map, used to get chromosome lengths (and start
and end positions).</p>
</td></tr>
<tr><td><code id="plot_lodpeaks_+3A_chr">chr</code></td>
<td>
<p>Selected chromosomes to plot; a vector of character
strings.</p>
</td></tr>
<tr><td><code id="plot_lodpeaks_+3A_gap">gap</code></td>
<td>
<p>Gap between chromosomes. The default is 1% of the total genome length.</p>
</td></tr>
<tr><td><code id="plot_lodpeaks_+3A_intervals">intervals</code></td>
<td>
<p>If TRUE and <code>peaks</code> contains QTL intervals, plot the intervals.</p>
</td></tr>
<tr><td><code id="plot_lodpeaks_+3A_...">...</code></td>
<td>
<p>Additional graphics parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Hidden graphics parameters</h3>

<p>A number of graphics parameters can be passed via <code>...</code>. For
example, <code>bgcolor</code> to control the background color and
<code>altbgcolor</code> to control the background color on alternate chromosomes.
These are not included as formal parameters in order to avoid
cluttering the function definition.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_peaks">find_peaks()</a></code>, <code><a href="#topic+plot_peaks">plot_peaks()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))


# insert pseudomarkers into map
map &lt;- insert_pseudomarkers(iron$gmap, step=1)

# calculate genotype probabilities
probs &lt;- calc_genoprob(iron, map, error_prob=0.002)

# grab phenotypes and covariates; ensure that covariates have names attribute
pheno &lt;- iron$pheno
covar &lt;- match(iron$covar$sex, c("f", "m")) # make numeric
names(covar) &lt;- rownames(iron$covar)
Xcovar &lt;- get_x_covar(iron)

# perform genome scan
out &lt;- scan1(probs, pheno, addcovar=covar, Xcovar=Xcovar)

# find peaks above lod=3.5 (and calculate 1.5-LOD support intervals)
peaks &lt;- find_peaks(out, map, threshold=3.5, drop=1.5)

plot_lodpeaks(peaks, map)
</code></pre>

<hr>
<h2 id='plot_onegeno'>Plot one individual's genome-wide genotypes</h2><span id='topic+plot_onegeno'></span>

<h3>Description</h3>

<p>Plot one individual's genome-wide genotypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_onegeno(
  geno,
  map,
  ind = 1,
  chr = NULL,
  col = NULL,
  na_col = "white",
  swap_axes = FALSE,
  border = "black",
  shift = FALSE,
  chrwidth = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_onegeno_+3A_geno">geno</code></td>
<td>
<p>Imputed phase-known genotypes, as a list of matrices
(as produced by <code><a href="#topic+maxmarg">maxmarg()</a></code>) or a list of
three-dimensional arrays (as produced by <code><a href="#topic+guess_phase">guess_phase()</a></code>).</p>
</td></tr>
<tr><td><code id="plot_onegeno_+3A_map">map</code></td>
<td>
<p>Marker map (a list of vectors of marker positions).</p>
</td></tr>
<tr><td><code id="plot_onegeno_+3A_ind">ind</code></td>
<td>
<p>Individual to plot, either a numeric index or an ID.</p>
</td></tr>
<tr><td><code id="plot_onegeno_+3A_chr">chr</code></td>
<td>
<p>Selected chromosomes to plot; a vector of character strings.</p>
</td></tr>
<tr><td><code id="plot_onegeno_+3A_col">col</code></td>
<td>
<p>Vector of colors for the different genotypes.</p>
</td></tr>
<tr><td><code id="plot_onegeno_+3A_na_col">na_col</code></td>
<td>
<p>Color for missing segments.</p>
</td></tr>
<tr><td><code id="plot_onegeno_+3A_swap_axes">swap_axes</code></td>
<td>
<p>If TRUE, swap the axes, so that the chromosomes run horizontally.</p>
</td></tr>
<tr><td><code id="plot_onegeno_+3A_border">border</code></td>
<td>
<p>Color of outer border around chromosome rectangles.</p>
</td></tr>
<tr><td><code id="plot_onegeno_+3A_shift">shift</code></td>
<td>
<p>If TRUE, shift the chromosomes so they all start at 0.</p>
</td></tr>
<tr><td><code id="plot_onegeno_+3A_chrwidth">chrwidth</code></td>
<td>
<p>Total width of rectangles for each chromosome, as a
fraction of the distance between them.</p>
</td></tr>
<tr><td><code id="plot_onegeno_+3A_...">...</code></td>
<td>
<p>Additional graphics parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Hidden graphics parameters</h3>

<p>A number of graphics parameters can be passed via <code>...</code>. For
example, <code>bgcolor</code> to control the background color.
These are not included as formal parameters in order to avoid
cluttering the function definition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data and calculate genotype probabilities
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))
iron &lt;- iron["146", ] # subset to individual 146
map &lt;- insert_pseudomarkers(iron$gmap, step=1)
pr &lt;- calc_genoprob(iron, map, error_prob=0.002)

# infer genotypes, as those with maximal marginal probability
m &lt;- maxmarg(pr)

# guess phase
ph &lt;- guess_phase(iron, m)

# plot phased genotypes
plot_onegeno(ph, map, shift=TRUE, col=c("slateblue", "Orchid"))

# this is more interesting for Diversity Outbred mouse data
## Not run: 
file &lt;- paste0("https://raw.githubusercontent.com/rqtl/",
               "qtl2data/main/DOex/DOex.zip")
DOex &lt;- read_cross2(file)
# subset to individuals labeled "232" and "256"
DOex &lt;- DOex[c("232", "256"), ]
pr &lt;- calc_genoprob(DOex, error_prob=0.002)

# infer genotypes, as those with maximal marginal probability
m &lt;- maxmarg(pr, minprob=0.5)
# guess phase
ph &lt;- guess_phase(DOex, m)

# plot phased genotypes
plot_onegeno(ph, DOex$gmap, shift=TRUE)
plot_onegeno(ph, DOex$gmap, ind="256", shift=TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot_peaks'>Plot QTL peak locations</h2><span id='topic+plot_peaks'></span>

<h3>Description</h3>

<p>Plot QTL peak locations (possibly with intervals) for multiple traits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_peaks(
  peaks,
  map,
  chr = NULL,
  tick_height = 0.3,
  gap = NULL,
  lod_labels = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_peaks_+3A_peaks">peaks</code></td>
<td>
<p>Data frame such as that produced by
<code><a href="#topic+find_peaks">find_peaks()</a></code>) containing columns
<code>chr</code>, <code>pos</code>, <code>lodindex</code>, and <code>lodcolumn</code>.
May also contain columns <code>ci_lo</code> and <code>ci_hi</code>, in
which case intervals will be plotted.</p>
</td></tr>
<tr><td><code id="plot_peaks_+3A_map">map</code></td>
<td>
<p>Marker map, used to get chromosome lengths (and start
and end positions).</p>
</td></tr>
<tr><td><code id="plot_peaks_+3A_chr">chr</code></td>
<td>
<p>Selected chromosomes to plot; a vector of character
strings.</p>
</td></tr>
<tr><td><code id="plot_peaks_+3A_tick_height">tick_height</code></td>
<td>
<p>Height of tick marks at the peaks (a number between 0 and 1).</p>
</td></tr>
<tr><td><code id="plot_peaks_+3A_gap">gap</code></td>
<td>
<p>Gap between chromosomes. The default is 1% of the total genome length.</p>
</td></tr>
<tr><td><code id="plot_peaks_+3A_lod_labels">lod_labels</code></td>
<td>
<p>If TRUE, plot LOD scores near the intervals. Uses
three hidden graphics parameters, <code>label_gap</code> (distance between
CI and LOD text label), <code>label_left</code> (vector that indicates
whether the labels should go on the left side; TRUE=on left,
FALSE=on right, NA=put into larger gap on that chromosome), and
<code>label_cex</code> that controls the size of these labels</p>
</td></tr>
<tr><td><code id="plot_peaks_+3A_...">...</code></td>
<td>
<p>Additional graphics parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Hidden graphics parameters</h3>

<p>A number of graphics parameters can be passed via <code>...</code>. For
example, <code>bgcolor</code> to control the background color and
<code>altbgcolor</code> to control the background color on alternate chromosomes.
These are not included as formal parameters in order to avoid
cluttering the function definition.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_peaks">find_peaks()</a></code>, <code><a href="#topic+plot_lodpeaks">plot_lodpeaks()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))


# insert pseudomarkers into map
map &lt;- insert_pseudomarkers(iron$gmap, step=1)

# calculate genotype probabilities
probs &lt;- calc_genoprob(iron, map, error_prob=0.002)

# grab phenotypes and covariates; ensure that covariates have names attribute
pheno &lt;- iron$pheno
covar &lt;- match(iron$covar$sex, c("f", "m")) # make numeric
names(covar) &lt;- rownames(iron$covar)
Xcovar &lt;- get_x_covar(iron)

# perform genome scan
out &lt;- scan1(probs, pheno, addcovar=covar, Xcovar=Xcovar)

# find peaks above lod=3.5 (and calculate 1.5-LOD support intervals)
peaks &lt;- find_peaks(out, map, threshold=3.5, drop=1.5)

plot_peaks(peaks, map)

# show LOD scores
plot_peaks(peaks, map, lod_labels=TRUE)

# show LOD scores, controlling whether they go on the left or right
plot_peaks(peaks, map, lod_labels=TRUE,
           label_left=c(TRUE, TRUE, TRUE, FALSE, TRUE, FALSE))
</code></pre>

<hr>
<h2 id='plot_pxg'>Plot phenotype vs genotype</h2><span id='topic+plot_pxg'></span>

<h3>Description</h3>

<p>Plot phenotype vs genotype for a single putative QTL and a single phenotype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_pxg(
  geno,
  pheno,
  sort = TRUE,
  SEmult = NULL,
  pooledSD = TRUE,
  swap_axes = FALSE,
  jitter = 0.2,
  force_labels = TRUE,
  alternate_labels = FALSE,
  omit_points = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_pxg_+3A_geno">geno</code></td>
<td>
<p>Vector of genotypes, for example as produced by
<code><a href="#topic+maxmarg">maxmarg()</a></code> with specific <code>chr</code> and <code>pos</code>.</p>
</td></tr>
<tr><td><code id="plot_pxg_+3A_pheno">pheno</code></td>
<td>
<p>Vector of phenotypes.</p>
</td></tr>
<tr><td><code id="plot_pxg_+3A_sort">sort</code></td>
<td>
<p>If TRUE, sort genotypes from largest to smallest.</p>
</td></tr>
<tr><td><code id="plot_pxg_+3A_semult">SEmult</code></td>
<td>
<p>If specified, interval estimates of the within-group
averages will be displayed, as <code style="white-space: pre;">&#8288;mean +/- SE * SEmult&#8288;</code>.</p>
</td></tr>
<tr><td><code id="plot_pxg_+3A_pooledsd">pooledSD</code></td>
<td>
<p>If TRUE and <code>SEmult</code> is specified, calculated
a pooled within-group SD. Otherwise, get separate estimates of
the within-group SD for each group.</p>
</td></tr>
<tr><td><code id="plot_pxg_+3A_swap_axes">swap_axes</code></td>
<td>
<p>If TRUE, swap the axes, so that the genotypes are
on the y-axis and the phenotype is on the x-axis.</p>
</td></tr>
<tr><td><code id="plot_pxg_+3A_jitter">jitter</code></td>
<td>
<p>Amount to jitter the points horizontally, if a vector
of length &gt; 0, it is taken to be the actual jitter amounts
(with values between -0.5 and 0.5).</p>
</td></tr>
<tr><td><code id="plot_pxg_+3A_force_labels">force_labels</code></td>
<td>
<p>If TRUE, force all genotype labels to be shown.</p>
</td></tr>
<tr><td><code id="plot_pxg_+3A_alternate_labels">alternate_labels</code></td>
<td>
<p>If TRUE, place genotype labels in two rows</p>
</td></tr>
<tr><td><code id="plot_pxg_+3A_omit_points">omit_points</code></td>
<td>
<p>If TRUE, omit the points, just plotting the averages (and, potentially, the +/- SE intervals).</p>
</td></tr>
<tr><td><code id="plot_pxg_+3A_...">...</code></td>
<td>
<p>Additional graphics parameters, passed to <code>plot()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(Invisibly) A matrix with rows being the genotype groups
and columns for the means and (if <code>SEmult</code> is specified) the SEs.
</p>


<h3>Hidden graphics parameters</h3>

<p>A number of graphics parameters can be passed via <code>...</code>. For
example, <code>bgcolor</code> to control the background color, and
<code>seg_width</code>, <code>seg_lwd</code>, and <code>seg_col</code> to control the lines at the
confidence intervals. Further, <code>hlines</code>, <code>hlines_col</code>,
<code>hlines_lwd</code>, and <code>hlines_lty</code> to control the horizontal grid
lines. (Use <code>hlines=NA</code> to avoid plotting horizontal grid lines.)
Similarly <code>vlines</code>, <code>vlines_col</code>, <code>vlines_lwd</code>, and <code>vlines_lty</code>
for vertical grid lines. These are not included as formal
parameters in order to avoid cluttering the function definition.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_coef">plot_coef()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))


# insert pseudomarkers into map
map &lt;- insert_pseudomarkers(iron$gmap, step=1)

# calculate genotype probabilities
probs &lt;- calc_genoprob(iron, map, error_prob=0.002)

# inferred genotype at a 28.6 cM on chr 16
geno &lt;- maxmarg(probs, map, chr=16, pos=28.6, return_char=TRUE)

# plot phenotype vs genotype
plot_pxg(geno, log10(iron$pheno[,1]), ylab=expression(log[10](Liver)))

# include +/- 2 SE intervals
plot_pxg(geno, log10(iron$pheno[,1]), ylab=expression(log[10](Liver)),
         SEmult=2)

# plot just the means
plot_pxg(geno, log10(iron$pheno[,1]), ylab=expression(log[10](Liver)),
         omit_points=TRUE)

# plot just the means +/- 2 SEs
plot_pxg(geno, log10(iron$pheno[,1]), ylab=expression(log[10](Liver)),
         omit_points=TRUE, SEmult=2)
</code></pre>

<hr>
<h2 id='plot_scan1'>Plot a genome scan</h2><span id='topic+plot_scan1'></span><span id='topic+plot.scan1'></span>

<h3>Description</h3>

<p>Plot LOD curves for a genome scan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_scan1(x, map, lodcolumn = 1, chr = NULL, add = FALSE, gap = NULL, ...)

## S3 method for class 'scan1'
plot(x, map, lodcolumn = 1, chr = NULL, add = FALSE, gap = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_scan1_+3A_x">x</code></td>
<td>
<p>An object of class <code>"scan1"</code>, as output by <code><a href="#topic+scan1">scan1()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_scan1_+3A_map">map</code></td>
<td>
<p>A list of vectors of marker positions, as produced by
<code><a href="#topic+insert_pseudomarkers">insert_pseudomarkers()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_scan1_+3A_lodcolumn">lodcolumn</code></td>
<td>
<p>LOD score column to plot (a numeric index, or a
character string for a column name). Only one value allowed.</p>
</td></tr>
<tr><td><code id="plot_scan1_+3A_chr">chr</code></td>
<td>
<p>Selected chromosomes to plot; a vector of character
strings.</p>
</td></tr>
<tr><td><code id="plot_scan1_+3A_add">add</code></td>
<td>
<p>If TRUE, add to current plot (must have same map and
chromosomes).</p>
</td></tr>
<tr><td><code id="plot_scan1_+3A_gap">gap</code></td>
<td>
<p>Gap between chromosomes. The default is 1% of the total genome length.</p>
</td></tr>
<tr><td><code id="plot_scan1_+3A_...">...</code></td>
<td>
<p>Additional graphics parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Hidden graphics parameters</h3>

<p>A number of graphics parameters can be passed via <code>...</code>. For
example, <code>bgcolor</code> to control the background color and
<code>altbgcolor</code> to control the background color on alternate chromosomes.
<code>col</code> controls the color of lines/curves; <code>altcol</code> can be used if
you want alternative chromosomes in different colors.
These are not included as formal parameters in order to avoid
cluttering the function definition.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_coef">plot_coef()</a></code>, <code><a href="#topic+plot_coefCC">plot_coefCC()</a></code>, <code><a href="#topic+plot_snpasso">plot_snpasso()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))

# insert pseudomarkers into map
map &lt;- insert_pseudomarkers(iron$gmap, step=1)

# calculate genotype probabilities
probs &lt;- calc_genoprob(iron, map, error_prob=0.002)

# grab phenotypes and covariates; ensure that covariates have names attribute
pheno &lt;- iron$pheno
covar &lt;- match(iron$covar$sex, c("f", "m")) # make numeric
names(covar) &lt;- rownames(iron$covar)
Xcovar &lt;- get_x_covar(iron)

# perform genome scan
out &lt;- scan1(probs, pheno, addcovar=covar, Xcovar=Xcovar)

# plot the results for selected chromosomes
ylim &lt;- c(0, maxlod(out)*1.02) # need to strip class to get overall max LOD
chr &lt;- c(2,7,8,9,15,16)
plot(out, map, chr=chr, ylim=ylim)
plot(out, map, lodcolumn=2, chr=chr, col="violetred", add=TRUE)
legend("topleft", lwd=2, col=c("darkslateblue", "violetred"), colnames(out),
       bg="gray90")

# plot just one chromosome
plot(out, map, chr=8, ylim=ylim)
plot(out, map, chr=8, lodcolumn=2, col="violetred", add=TRUE)

# lodcolumn can also be a column name
plot(out, map, lodcolumn="liver", ylim=ylim)
plot(out, map, lodcolumn="spleen", col="violetred", add=TRUE)
</code></pre>

<hr>
<h2 id='plot_sdp'>plot strain distribution patterns for SNPs</h2><span id='topic+plot_sdp'></span>

<h3>Description</h3>

<p>plot the strain distribution patterns of SNPs
using tracks of tick-marks for each founder strain
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_sdp(pos, sdp, strain_labels = names(qtl2::CCcolors), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_sdp_+3A_pos">pos</code></td>
<td>
<p>vector of SNP positions</p>
</td></tr>
<tr><td><code id="plot_sdp_+3A_sdp">sdp</code></td>
<td>
<p>vector of strain distribution patterns (as integers)</p>
</td></tr>
<tr><td><code id="plot_sdp_+3A_strain_labels">strain_labels</code></td>
<td>
<p>names of the strains</p>
</td></tr>
<tr><td><code id="plot_sdp_+3A_...">...</code></td>
<td>
<p>additional graphic arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additional arguments, such as <code>xlab</code>, <code>ylab</code>, <code>xlim</code>, and <code>main</code>,
are passed via <code>...</code>; also <code>bgcolor</code> to control the color of the
background, and <code>col</code> and <code>lwd</code> to control the color and thickness
of the tick marks.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_sdp">calc_sdp()</a></code>, <code><a href="#topic+invert_sdp">invert_sdp()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_tick &lt;- 50
plot_sdp(runif(n_tick, 0, 100), sample(0:255, n_tick, replace=TRUE))
</code></pre>

<hr>
<h2 id='plot_snpasso'>Plot SNP associations</h2><span id='topic+plot_snpasso'></span>

<h3>Description</h3>

<p>Plot SNP associations, with possible expansion from distinct snps to all snps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_snpasso(
  scan1output,
  snpinfo,
  genes = NULL,
  lodcolumn = 1,
  show_all_snps = TRUE,
  chr = NULL,
  add = FALSE,
  drop_hilit = NA,
  col_hilit = "violetred",
  col = "darkslateblue",
  gap = NULL,
  minlod = 0,
  sdp_panel = FALSE,
  strain_labels = names(qtl2::CCcolors),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_snpasso_+3A_scan1output">scan1output</code></td>
<td>
<p>Output of <code><a href="#topic+scan1">scan1()</a></code> using
SNP probabilities derived by
<code><a href="#topic+genoprob_to_snpprob">genoprob_to_snpprob()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_snpasso_+3A_snpinfo">snpinfo</code></td>
<td>
<p>Data frame with SNP information with the following
columns (the last three are generally derived from with
<code><a href="#topic+index_snps">index_snps()</a></code>):
</p>

<ul>
<li> <p><code>chr</code> - Character string or factor with chromosome
</p>
</li>
<li> <p><code>pos</code> - Position (in same units as in the <code>"map"</code>
attribute in <code>genoprobs</code>.
</p>
</li>
<li> <p><code>sdp</code> - Strain distribution pattern: an integer, between
1 and <code class="reqn">2^n - 2</code> where <code class="reqn">n</code> is the number of strains, whose
binary encoding indicates the founder genotypes
</p>
</li>
<li> <p><code>snp</code> - Character string with SNP identifier (if
missing, the rownames are used).
</p>
</li>
<li> <p><code>index</code> - Indices that indicate equivalent
groups of SNPs.
</p>
</li>
<li> <p><code>intervals</code> - Indexes that indicate which marker
intervals the SNPs reside.
</p>
</li>
<li> <p><code>on_map</code> - Indicate whether SNP coincides with a marker
in the <code>genoprobs</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_snpasso_+3A_genes">genes</code></td>
<td>
<p>Optional data frame containing gene information for
the region, with columns <code>start</code> and <code>stop</code> in Mbp, <code>strand</code>
(as <code>"-"</code>, <code>"+"</code>, or <code>NA</code>), and <code>Name</code>. If included, a
two-panel plot is produced, with SNP associations above and
gene locations below.</p>
</td></tr>
<tr><td><code id="plot_snpasso_+3A_lodcolumn">lodcolumn</code></td>
<td>
<p>LOD score column to plot (a numeric index, or a
character string for a column name). Only one value allowed.</p>
</td></tr>
<tr><td><code id="plot_snpasso_+3A_show_all_snps">show_all_snps</code></td>
<td>
<p>If TRUE, expand to show all SNPs.</p>
</td></tr>
<tr><td><code id="plot_snpasso_+3A_chr">chr</code></td>
<td>
<p>Vector of character strings with chromosome IDs to plot.</p>
</td></tr>
<tr><td><code id="plot_snpasso_+3A_add">add</code></td>
<td>
<p>If TRUE, add to current plot (must have same map and
chromosomes).</p>
</td></tr>
<tr><td><code id="plot_snpasso_+3A_drop_hilit">drop_hilit</code></td>
<td>
<p>SNPs with LOD score within this amount of the maximum SNP association will be highlighted.</p>
</td></tr>
<tr><td><code id="plot_snpasso_+3A_col_hilit">col_hilit</code></td>
<td>
<p>Color of highlighted points</p>
</td></tr>
<tr><td><code id="plot_snpasso_+3A_col">col</code></td>
<td>
<p>Color of other points</p>
</td></tr>
<tr><td><code id="plot_snpasso_+3A_gap">gap</code></td>
<td>
<p>Gap between chromosomes. The default is 1% of the total genome length.</p>
</td></tr>
<tr><td><code id="plot_snpasso_+3A_minlod">minlod</code></td>
<td>
<p>Minimum LOD to display. (Mostly for GWAS, in which
case using <code>minlod=1</code> will greatly increase the plotting speed,
since the vast majority of points would be omittted.</p>
</td></tr>
<tr><td><code id="plot_snpasso_+3A_sdp_panel">sdp_panel</code></td>
<td>
<p>Include a panel with the strain distribution patterns for the highlighted SNPs</p>
</td></tr>
<tr><td><code id="plot_snpasso_+3A_strain_labels">strain_labels</code></td>
<td>
<p>Labels for the strains, if <code>sdp_panel=TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot_snpasso_+3A_...">...</code></td>
<td>
<p>Additional graphics parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Hidden graphics parameters</h3>

<p>A number of graphics parameters can be passed via <code>...</code>. For
example, <code>bgcolor</code> to control the background color,<code>altbgcolor</code>
to control the background color on alternate chromosomes,
<code>altcol</code> to control the point color on alternate chromosomes,
<code>cex</code> for character expansion for the points (default 0.5),
<code>pch</code> for the plotting character for the points (default 16),
and <code>ylim</code> for y-axis limits.
If you are including genes and/or SDP panels, you can use
<code>panel_prop</code> to control the relative heights of the panels,
from top to bottom.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_scan1">plot_scan1()</a></code>, <code><a href="#topic+plot_coef">plot_coef()</a></code>, <code><a href="#topic+plot_coefCC">plot_coefCC()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example DO data from web
file &lt;- paste0("https://raw.githubusercontent.com/rqtl/",
               "qtl2data/main/DOex/DOex.zip")
DOex &lt;- read_cross2(file)

# subset to chr 2
DOex &lt;- DOex[,"2"]

# calculate genotype probabilities and convert to allele probabilities
pr &lt;- calc_genoprob(DOex, error_prob=0.002)
apr &lt;- genoprob_to_alleleprob(pr)

# query function for grabbing info about variants in region
snp_dbfile &lt;- system.file("extdata", "cc_variants_small.sqlite", package="qtl2")
query_variants &lt;- create_variant_query_func(snp_dbfile)

# SNP association scan
out_snps &lt;- scan1snps(apr, DOex$pmap, DOex$pheno, query_func=query_variants,
                      chr=2, start=97, end=98, keep_all_snps=TRUE)

# plot results
plot_snpasso(out_snps$lod, out_snps$snpinfo)

# can also just type plot()
plot(out_snps$lod, out_snps$snpinfo)

# plot just subset of distinct SNPs
plot(out_snps$lod, out_snps$snpinfo, show_all_snps=FALSE)

# highlight the top snps (with LOD within 1.5 of max)
plot(out_snps$lod, out_snps$snpinfo, drop_hilit=1.5)

# query function for finding genes in region
gene_dbfile &lt;- system.file("extdata", "mouse_genes_small.sqlite", package="qtl2")
query_genes &lt;- create_gene_query_func(gene_dbfile)
genes &lt;- query_genes(2, 97, 98)

# plot SNP association results with gene locations
plot(out_snps$lod, out_snps$snpinfo, drop_hilit=1.5, genes=genes)

# plot SNP asso results with genes plus SDPs of highlighted SNPs
plot(out_snps$lod, out_snps$snpinfo, drop_hilit=2, genes=genes, sdp_panel=TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='predict_snpgeno'>Predict SNP genotypes</h2><span id='topic+predict_snpgeno'></span>

<h3>Description</h3>

<p>Predict SNP genotypes in a multiparent population from inferred genotypes plus founder strains' SNP alleles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_snpgeno(cross, geno, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_snpgeno_+3A_cross">cross</code></td>
<td>
<p>Object of class <code>"cross2"</code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.</p>
</td></tr>
<tr><td><code id="predict_snpgeno_+3A_geno">geno</code></td>
<td>
<p>Imputed genotypes, as a list of matrices, as from <code><a href="#topic+maxmarg">maxmarg()</a></code>.</p>
</td></tr>
<tr><td><code id="predict_snpgeno_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of matrices with inferred SNP genotypes, coded 1/2/3.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maxmarg">maxmarg()</a></code>, <code><a href="#topic+viterbi">viterbi()</a></code>, <code><a href="#topic+calc_errorlod">calc_errorlod()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data and calculate genotype probabilities
file &lt;- paste0("https://raw.githubusercontent.com/rqtl/",
               "qtl2data/main/DOex/DOex.zip")
DOex &lt;- read_cross2(file)
probs &lt;- calc_genoprob(DOex, error_prob=0.002)

# inferred genotypes
m &lt;- maxmarg(probs, minprob=0.5)

# inferred SNP genotypes
inferg &lt;- predict_snpgeno(DOex, m)

## End(Not run)

</code></pre>

<hr>
<h2 id='print.cross2'>Print a cross2 object</h2><span id='topic+print.cross2'></span>

<h3>Description</h3>

<p>Print a summary of a cross2 object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cross2'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cross2_+3A_x">x</code></td>
<td>
<p>An object of class <code>"cross2"</code>, as output by <code><a href="#topic+read_cross2">read_cross2()</a></code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.</p>
</td></tr>
<tr><td><code id="print.cross2_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>

<hr>
<h2 id='print.summary.scan1perm'>Print summary of scan1perm permutations</h2><span id='topic+print.summary.scan1perm'></span>

<h3>Description</h3>

<p>Print summary of scan1perm permutations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.scan1perm'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.scan1perm_+3A_x">x</code></td>
<td>
<p>Object of class <code>"summary.scan1perm"</code>, as produced by <code><a href="#topic+summary_scan1perm">summary_scan1perm()</a></code>.</p>
</td></tr>
<tr><td><code id="print.summary.scan1perm_+3A_digits">digits</code></td>
<td>
<p>Number of digits in printing significance thresholds; passed to <code><a href="base.html#topic+print">base::print()</a></code>.</p>
</td></tr>
<tr><td><code id="print.summary.scan1perm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is to go with <code><a href="#topic+summary_scan1perm">summary_scan1perm()</a></code>, so
that the summary output is printed in a nice format. Generally
not called directly, but it can be in order to control the
number of digits that appear.
</p>


<h3>Value</h3>

<p>Invisibly returns the input, <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))


# insert pseudomarkers into map
map &lt;- insert_pseudomarkers(iron$gmap, step=1)

# calculate genotype probabilities
probs &lt;- calc_genoprob(iron, map, error_prob=0.002)

# grab phenotypes and covariates; ensure that covariates have names attribute
pheno &lt;- iron$pheno
covar &lt;- match(iron$covar$sex, c("f", "m")) # make numeric
names(covar) &lt;- rownames(iron$covar)
Xcovar &lt;- get_x_covar(iron)

# permutations with genome scan (just 3 replicates, for illustration)
operm &lt;- scan1perm(probs, pheno, addcovar=covar, Xcovar=Xcovar,
                   n_perm=3)

print( summary(operm, alpha=c(0.20, 0.05)), digits=8 )

</code></pre>

<hr>
<h2 id='probs_to_grid'>Subset genotype probability array to pseudomarkers on a grid</h2><span id='topic+probs_to_grid'></span>

<h3>Description</h3>

<p>Subset genotype probability array (from <code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>
to a grid of pseudomarkers along each chromosome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probs_to_grid(probs, grid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probs_to_grid_+3A_probs">probs</code></td>
<td>
<p>Genotype probabilities as output from
<code><a href="#topic+calc_genoprob">calc_genoprob()</a></code> with <code>stepwidth="fixed"</code>.</p>
</td></tr>
<tr><td><code id="probs_to_grid_+3A_grid">grid</code></td>
<td>
<p>List of logical vectors that indicate which positions
are on the grid and should be retained.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This only works if <code><a href="#topic+calc_genoprob">calc_genoprob()</a></code> was run
with <code>stepwidth="fixed"</code>, so that the genotype
probabilities were calculated at a grid of
markers/pseudomarkers. When this is the case, we omit all but
the probabilities on this grid. Use <code><a href="#topic+calc_grid">calc_grid()</a></code> to
find the grid positions.
</p>


<h3>Value</h3>

<p>An object of class <code>"calc_genoprob"</code>, like the input, subset to just include
pseudomarkers along a grid. See <code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_grid">calc_grid()</a></code>, <code><a href="#topic+map_to_grid">map_to_grid()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
map_w_pmar &lt;- insert_pseudomarkers(grav2$gmap, step=1)
probs &lt;- calc_genoprob(grav2, map_w_pmar, error_prob=0.002)
sapply(probs, dim)
grid &lt;- calc_grid(grav2$gmap, step=1)
probs_sub &lt;- probs_to_grid(probs, grid)
sapply(probs_sub, dim)
</code></pre>

<hr>
<h2 id='pull_genoprobint'>Pull genotype probabilities for an interval</h2><span id='topic+pull_genoprobint'></span>

<h3>Description</h3>

<p>Pull out the genotype probabilities for a given genomic interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull_genoprobint(genoprobs, map, chr, interval)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pull_genoprobint_+3A_genoprobs">genoprobs</code></td>
<td>
<p>Genotype probabilities as calculated by
<code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.</p>
</td></tr>
<tr><td><code id="pull_genoprobint_+3A_map">map</code></td>
<td>
<p>The marker map for the genotype probabilities</p>
</td></tr>
<tr><td><code id="pull_genoprobint_+3A_chr">chr</code></td>
<td>
<p>Chromosome ID (single character sting)</p>
</td></tr>
<tr><td><code id="pull_genoprobint_+3A_interval">interval</code></td>
<td>
<p>Interval (pair of numbers)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a single 3d array of genotype probabilities, like the input <code>genoprobs</code>
but for the designated interval.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_marker">find_marker()</a></code>, <code><a href="#topic+pull_genoprobpos">pull_genoprobpos()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))

gmap &lt;- insert_pseudomarkers(iron$gmap, step=1)
pr &lt;- calc_genoprob(iron, gmap, error_prob=0.002)

pr_sub &lt;- pull_genoprobint(pr, gmap, "8", c(25, 35))

</code></pre>

<hr>
<h2 id='pull_genoprobpos'>Pull genotype probabilities for a particular position</h2><span id='topic+pull_genoprobpos'></span>

<h3>Description</h3>

<p>Pull out the genotype probabilities for a particular position (by
name)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull_genoprobpos(genoprobs, map = NULL, chr = NULL, pos = NULL, marker = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pull_genoprobpos_+3A_genoprobs">genoprobs</code></td>
<td>
<p>Genotype probabilities as calculated by
<code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.</p>
</td></tr>
<tr><td><code id="pull_genoprobpos_+3A_map">map</code></td>
<td>
<p>A map object: a list (corresponding to chromosomes) of
vectors of marker positions. Can also be a snpinfo object (data
frame with columns <code>chr</code> and <code>pos</code>; marker names taken from
column <code>snp</code> or if that doesn't exist from the row names)</p>
</td></tr>
<tr><td><code id="pull_genoprobpos_+3A_chr">chr</code></td>
<td>
<p>A chromosome ID</p>
</td></tr>
<tr><td><code id="pull_genoprobpos_+3A_pos">pos</code></td>
<td>
<p>A numeric position</p>
</td></tr>
<tr><td><code id="pull_genoprobpos_+3A_marker">marker</code></td>
<td>
<p>A single character string with the name of the
position to pull out.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provide either a marker/pseudomarker name (with the argument <code>marker</code>)
or all of <code>map</code>, <code>chr</code>, and <code>pos</code>.
</p>


<h3>Value</h3>

<p>A matrix of genotype probabilities for the specified position.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_marker">find_marker()</a></code>, <code><a href="#topic+fit1">fit1()</a></code>, <code><a href="#topic+pull_genoprobint">pull_genoprobint()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))

gmap &lt;- insert_pseudomarkers(iron$gmap, step=1)
pr &lt;- calc_genoprob(iron, gmap, error_prob=0.002)

pmar &lt;- find_marker(gmap, 8, 40)
pr_8_40 &lt;- pull_genoprobpos(pr, pmar)

pr_8_40_alt &lt;- pull_genoprobpos(pr, gmap, 8, 40)

</code></pre>

<hr>
<h2 id='pull_markers'>Drop all but a specified set of markers</h2><span id='topic+pull_markers'></span>

<h3>Description</h3>

<p>Drop all markers from a cross2 object expect those in a specified vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull_markers(cross, markers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pull_markers_+3A_cross">cross</code></td>
<td>
<p>Object of class <code>"cross2"</code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.</p>
</td></tr>
<tr><td><code id="pull_markers_+3A_markers">markers</code></td>
<td>
<p>A vector of marker names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>cross</code> with only the specified markers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drop_markers">drop_markers()</a></code>, <code><a href="#topic+drop_nullmarkers">drop_nullmarkers()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
markers2drop &lt;- c("BH.342C/347L-Col", "GH.94L", "EG.357C/359L-Col", "CD.245L", "ANL2")
grav2_rev &lt;- pull_markers(grav2, markers2drop)
</code></pre>

<hr>
<h2 id='qtl2version'>Installed version of R/qtl2</h2><span id='topic+qtl2version'></span>

<h3>Description</h3>

<p>Get installed version of R/qtl2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtl2version()
</code></pre>


<h3>Value</h3>

<p>A character string with the installed version of the R/qtl2 package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qtl2version()

</code></pre>

<hr>
<h2 id='rbind.calc_genoprob'>Join genotype probabilities for different individuals</h2><span id='topic+rbind.calc_genoprob'></span>

<h3>Description</h3>

<p>Join multiple genotype probability objects, as produced by
<code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>, for the same set of markers and genotypes but for
different individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calc_genoprob'
rbind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind.calc_genoprob_+3A_...">...</code></td>
<td>
<p>Genotype probability objects as produced by
<code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>. Must have the same set of markers and
genotypes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"calc_genoprob"</code>, like the input; see <code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cbind.calc_genoprob">cbind.calc_genoprob()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
map &lt;- insert_pseudomarkers(grav2$gmap, step=1)
probsA &lt;- calc_genoprob(grav2[1:5,], map, error_prob=0.002)
probsB &lt;- calc_genoprob(grav2[6:12,], map, error_prob=0.002)
probs &lt;- rbind(probsA, probsB)

</code></pre>

<hr>
<h2 id='rbind.scan1'>Join genome scan results for different chromosomes.</h2><span id='topic+rbind.scan1'></span>

<h3>Description</h3>

<p>Join multiple <code><a href="#topic+scan1">scan1()</a></code> results for different
chromosomes; must have the same set of lod score column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scan1'
rbind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind.scan1_+3A_...">...</code></td>
<td>
<p>Genome scan objects of class <code>"scan1"</code>, as produced by <code><a href="#topic+scan1">scan1()</a></code>.
Must have the same lod score columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If components <code>addcovar</code>, <code>Xcovar</code>,
<code>intcovar</code>, <code>weights</code>, <code>sample_size</code> do not match
between objects, we omit this information.
</p>
<p>If <code>hsq</code> present, we simply <code>rbind()</code> the contents.
</p>


<h3>Value</h3>

<p>An object of class '&quot;scan1&quot;, like the inputs, but with
the results for different sets of chromosomes combined.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cbind.scan1">cbind.scan1()</a></code>, <code><a href="#topic+scan1">scan1()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
map &lt;- insert_pseudomarkers(grav2$gmap, step=1)
probs &lt;- calc_genoprob(grav2, map, error_prob=0.002)
phe &lt;- grav2$pheno[,1,drop=FALSE]

out1 &lt;- scan1(probs[,1], phe) # chr 1
out2 &lt;- scan1(probs[,5], phe) # chr 5
out &lt;- rbind(out1, out2)

</code></pre>

<hr>
<h2 id='rbind.scan1perm'>Combine data from scan1perm objects</h2><span id='topic+rbind.scan1perm'></span><span id='topic+c.scan1perm'></span>

<h3>Description</h3>

<p>Row-bind multiple scan1perm objects with the same set of columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scan1perm'
rbind(...)

## S3 method for class 'scan1perm'
c(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind.scan1perm_+3A_...">...</code></td>
<td>
<p>A set of permutation results from
<code><a href="#topic+scan1perm">scan1perm()</a></code> (objects of class <code>"scan1perm"</code>).
They must have the same set of columns. If any include
autosome/X chromosome-specific permutations, they must all be
such.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aim of this function is to concatenate the results
from multiple runs of a permutation test with
<code><a href="#topic+scan1perm">scan1perm()</a></code>, to assist in the case that such
permutations are done on multiple processors in parallel.
</p>


<h3>Value</h3>

<p>The combined row-binded input, as an object of class <code>"scan1perm"</code>; see <code><a href="#topic+scan1perm">scan1perm()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cbind.scan1perm">cbind.scan1perm()</a></code>, <code><a href="#topic+scan1perm">scan1perm()</a></code>, <code><a href="#topic+scan1">scan1()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))


# insert pseudomarkers into map
map &lt;- insert_pseudomarkers(iron$gmap, step=1)

# calculate genotype probabilities
probs &lt;- calc_genoprob(iron, map, error_prob=0.002)

# grab phenotypes and covariates; ensure that covariates have names attribute
pheno &lt;- iron$pheno
covar &lt;- match(iron$covar$sex, c("f", "m")) # make numeric
names(covar) &lt;- rownames(iron$covar)
Xcovar &lt;- get_x_covar(iron)

# permutations with genome scan (just 3 replicates, for illustration)
operm1 &lt;- scan1perm(probs, pheno, addcovar=covar, Xcovar=Xcovar, n_perm=3)
operm2 &lt;- scan1perm(probs, pheno, addcovar=covar, Xcovar=Xcovar, n_perm=3)

operm &lt;- rbind(operm1, operm2)

</code></pre>

<hr>
<h2 id='rbind.sim_geno'>Join genotype imputations for different individuals</h2><span id='topic+rbind.sim_geno'></span>

<h3>Description</h3>

<p>Join multiple genotype imputation objects, as produced by
<code><a href="#topic+sim_geno">sim_geno()</a></code>, for the same set of markers but for different
individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sim_geno'
rbind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind.sim_geno_+3A_...">...</code></td>
<td>
<p>Genotype imputation objects as produced by
<code><a href="#topic+sim_geno">sim_geno()</a></code>. Must have the same set of markers and
genotypes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"sim_geno"</code>, like the input; see <code><a href="#topic+sim_geno">sim_geno()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cbind.sim_geno">cbind.sim_geno()</a></code>, <code><a href="#topic+sim_geno">sim_geno()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
map &lt;- insert_pseudomarkers(grav2$gmap, step=1)
drawsA &lt;- sim_geno(grav2[1:5,], map, error_prob=0.002, n_draws=4)
drawsB &lt;- sim_geno(grav2[6:12,], map, error_prob=0.002, n_draws=4)
draws &lt;- rbind(drawsA, drawsB)

</code></pre>

<hr>
<h2 id='rbind.viterbi'>Join Viterbi results for different individuals</h2><span id='topic+rbind.viterbi'></span>

<h3>Description</h3>

<p>Join multiple imputed genotype objects, as produced by <code><a href="#topic+viterbi">viterbi()</a></code>,
for the same set of markers but for different individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'viterbi'
rbind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind.viterbi_+3A_...">...</code></td>
<td>
<p>Imputed genotype objects as produced by
<code><a href="#topic+viterbi">viterbi()</a></code>. Must have the same set of markers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"viterbi"</code>, like the input; see <code><a href="#topic+viterbi">viterbi()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cbind.viterbi">cbind.viterbi()</a></code>, <code><a href="#topic+viterbi">viterbi()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
map &lt;- insert_pseudomarkers(grav2$gmap, step=1)
gA &lt;- viterbi(grav2[1:5,], map, error_prob=0.002)
gB &lt;- viterbi(grav2[6:12,], map, error_prob=0.002)
g &lt;- rbind(gA, gB)

</code></pre>

<hr>
<h2 id='read_cross2'>Read QTL data from files</h2><span id='topic+read_cross2'></span>

<h3>Description</h3>

<p>Read QTL data from a set of files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_cross2(file, quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_cross2_+3A_file">file</code></td>
<td>
<p>Character string with path to the
<a href="https://yaml.org">YAML</a> or <a href="https://json.org">JSON</a> file containing all of the control
information. This could instead be a zip file containing all of the
data files, in which case the contents are unzipped to a temporary
directory and then read.</p>
</td></tr>
<tr><td><code id="read_cross2_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code>, print progress messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A control file in <a href="https://yaml.org">YAML</a> or
<a href="https://json.org">JSON</a> format contains information
about basic parameters as well as the names of the series of
data files to be read. See the
<a href="https://kbroman.org/qtl2/pages/sampledata.html">sample data files</a> and the
<a href="https://kbroman.org/qtl2/assets/vignettes/input_files.html">vignette describing the input file format</a>.
</p>


<h3>Value</h3>

<p>Object of class <code>"cross2"</code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_pheno">read_pheno()</a></code>, <code><a href="#topic+write_control_file">write_control_file()</a></code>,
sample data files at <a href="https://kbroman.org/qtl2/pages/sampledata.html">https://kbroman.org/qtl2/pages/sampledata.html</a>
and <a href="https://github.com/rqtl/qtl2data">https://github.com/rqtl/qtl2data</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
yaml_file &lt;- "https://kbroman.org/qtl2/assets/sampledata/grav2/grav2.yaml"
grav2 &lt;- read_cross2(yaml_file)

## End(Not run)
zip_file &lt;- system.file("extdata", "grav2.zip", package="qtl2")
grav2 &lt;- read_cross2(zip_file)
</code></pre>

<hr>
<h2 id='read_pheno'>Read phenotype data</h2><span id='topic+read_pheno'></span>

<h3>Description</h3>

<p>Read phenotype data from a CSV file (and, optionally, phenotype
covariate data from a separate CSV file). The CSV files may be
contained in zip files, separately or together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_pheno(
  file,
  phenocovarfile = NULL,
  sep = ",",
  na.strings = c("-", "NA"),
  comment.char = "#",
  transpose = FALSE,
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_pheno_+3A_file">file</code></td>
<td>
<p>Character string with path to the phenotype data file
(or a zip file containing both the phenotype and phenotype
covariate files).</p>
</td></tr>
<tr><td><code id="read_pheno_+3A_phenocovarfile">phenocovarfile</code></td>
<td>
<p>Character string with path to the phenotype
covariate file. This can be a separate CSV or zip file; if a zip
file, it must contain exactly one CSV file. Alternatively, if the
<code>file</code> argument indicates a zip file that contains two files
(phenotypes and phenotype covariates), then this
<code>phenocovarfile</code> argument must indicate the base name for the
phenotype covariate file.</p>
</td></tr>
<tr><td><code id="read_pheno_+3A_sep">sep</code></td>
<td>
<p>the field separator character</p>
</td></tr>
<tr><td><code id="read_pheno_+3A_na.strings">na.strings</code></td>
<td>
<p>a character vector of strings which are to be
interpreted as <code>NA</code> values.</p>
</td></tr>
<tr><td><code id="read_pheno_+3A_comment.char">comment.char</code></td>
<td>
<p>A character vector of length one containing a
single character to denote comments within the CSV files.</p>
</td></tr>
<tr><td><code id="read_pheno_+3A_transpose">transpose</code></td>
<td>
<p>If TRUE, the phenotype data will be transposed. The
phenotype covariate information is <strong>never</strong> transposed.</p>
</td></tr>
<tr><td><code id="read_pheno_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code>, print progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a matrix of phenotype data, or a list containing
<code>pheno</code> (phenotype matrix) and <code>phenocovar</code> (phenotype
covariate matrix).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_cross2">read_cross2()</a></code>,
sample data files at <a href="https://kbroman.org/qtl2/pages/sampledata.html">https://kbroman.org/qtl2/pages/sampledata.html</a>
and <a href="https://github.com/rqtl/qtl2data">https://github.com/rqtl/qtl2data</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
file &lt;- paste0("https://raw.githubusercontent.com/rqtl/",
               "qtl2data/main/Gough/gough_pheno.csv")
phe &lt;- read_pheno(file)

phecovfile &lt;- paste0("https://raw.githubusercontent.com/rqtl/",
                     "qtl2data/main/Gough/gough_phenocovar.csv")
phe_list &lt;- read_pheno(file, phecovfile)

## End(Not run)
</code></pre>

<hr>
<h2 id='recode_snps'>Recode SNPs by major allele</h2><span id='topic+recode_snps'></span>

<h3>Description</h3>

<p>For multi-parent populations with founder genotypes, recode the raw
SNP genotypes so that <code>1</code> means homozygous for the major allele in the
founders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode_snps(cross)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode_snps_+3A_cross">cross</code></td>
<td>
<p>Object of class <code>"cross2"</code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input cross object with the raw SNP genotypes recoded so that
<code>1</code> is homozygous for the major alleles in the founders.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_raw_founder_maf">calc_raw_founder_maf()</a></code>, <code><a href="#topic+calc_raw_maf">calc_raw_maf()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data and calculate genotype probabilities
file &lt;- paste0("https://raw.githubusercontent.com/rqtl/",
               "qtl2data/main/DOex/DOex.zip")
DOex &lt;- read_cross2(file)
DOex &lt;- recode_snps(DOex)

## End(Not run)
</code></pre>

<hr>
<h2 id='reduce_map_gaps'>Reduce the lengths of gaps in a map</h2><span id='topic+reduce_map_gaps'></span>

<h3>Description</h3>

<p>Reduce the lengths of gaps in a map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce_map_gaps(map, min_gap = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce_map_gaps_+3A_map">map</code></td>
<td>
<p>Genetic map as a list of vectors (each vector is a
chromosome and contains the marker positions).</p>
</td></tr>
<tr><td><code id="reduce_map_gaps_+3A_min_gap">min_gap</code></td>
<td>
<p>Minimum gap length to return.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Input map with any gaps greater than <code>min_gap</code> reduced to <code>min_gap</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_map_gaps">find_map_gaps()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))
rev_map &lt;- reduce_map_gaps(iron$gmap, 30)

</code></pre>

<hr>
<h2 id='reduce_markers'>Reduce markers to a subset of more-evenly-spaced ones</h2><span id='topic+reduce_markers'></span>

<h3>Description</h3>

<p>Find the largest subset of markers such that no two adjacent
markers are separated by less than some distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce_markers(
  map,
  min_distance = 1,
  weights = NULL,
  max_batch = 10000,
  batch_distance_mult = 1,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce_markers_+3A_map">map</code></td>
<td>
<p>A list with each component being a vector with the
marker positions for a chromosome.</p>
</td></tr>
<tr><td><code id="reduce_markers_+3A_min_distance">min_distance</code></td>
<td>
<p>Minimum distance between markers.</p>
</td></tr>
<tr><td><code id="reduce_markers_+3A_weights">weights</code></td>
<td>
<p>A (optional) list of weights on the markers; same
size as <code>map</code>.</p>
</td></tr>
<tr><td><code id="reduce_markers_+3A_max_batch">max_batch</code></td>
<td>
<p>Maximum number of markers to consider in a batch</p>
</td></tr>
<tr><td><code id="reduce_markers_+3A_batch_distance_mult">batch_distance_mult</code></td>
<td>
<p>If working with batches of markers,
reduce <code>min_distance</code> by this multiple.</p>
</td></tr>
<tr><td><code id="reduce_markers_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses a dynamic programming algorithm to find, for each
chromosome, the subset of markers for with max(<code>weights</code>) is
maximal, subject to the constraint that no two adjacent markers may
be separated by more than <code>min_distance</code>.
</p>
<p>The computation time for the algorithm grows with like the square
of the number of markers, like 1 sec for 10k markers
but 30 sec for 50k markers. If the number of markers on a chromosome
is greater than <code>max_batch</code>, the markers are split into batches and
the algorithm applied to each batch with min_distance smaller by a
factor <code>min_distance_mult</code>, and then merged together for one last pass.
</p>


<h3>Value</h3>

<p>A list like the input <code>map</code>, but with the selected
subset of markers.
</p>


<h3>References</h3>

<p>Broman KW, Weber JL (1999) Method for constructing
confidently ordered linkage maps. Genet Epidemiol 16:337&ndash;343
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_dup_markers">find_dup_markers()</a></code>, <code><a href="#topic+drop_markers">drop_markers()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))

# grab genetic map
gmap &lt;- grav2$gmap

# subset to markers that are &gt;= 1 cM apart
gmap_sub &lt;- reduce_markers(gmap, 1)

# drop all of the other markers from the cross
markers2keep &lt;- unlist(lapply(gmap_sub, names))
grav2_sub &lt;- pull_markers(grav2, markers2keep)
</code></pre>

<hr>
<h2 id='replace_ids'>Replace individual IDs</h2><span id='topic+replace_ids'></span><span id='topic+replace_ids.cross2'></span><span id='topic+replace_ids.calc_genoprob'></span><span id='topic+replace_ids.viterbi'></span><span id='topic+replace_ids.sim_geno'></span><span id='topic+replace_ids.matrix'></span><span id='topic+replace_ids.data.frame'></span>

<h3>Description</h3>

<p>Replace the individual IDs in an object with new ones
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_ids(x, ids)

## S3 method for class 'cross2'
replace_ids(x, ids)

## S3 method for class 'calc_genoprob'
replace_ids(x, ids)

## S3 method for class 'viterbi'
replace_ids(x, ids)

## S3 method for class 'sim_geno'
replace_ids(x, ids)

## S3 method for class 'matrix'
replace_ids(x, ids)

## S3 method for class 'data.frame'
replace_ids(x, ids)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_ids_+3A_x">x</code></td>
<td>
<p>Object whose IDs will be replaced</p>
</td></tr>
<tr><td><code id="replace_ids_+3A_ids">ids</code></td>
<td>
<p>Vector of character strings with the new individual IDs, with the names being the original IDs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>x</code> object, but with individual IDs replaced.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>replace_ids(cross2)</code>: Replace IDs in a <code>"cross2"</code> object
</p>
</li>
<li> <p><code>replace_ids(calc_genoprob)</code>: Replace IDs in output from <code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>
</p>
</li>
<li> <p><code>replace_ids(viterbi)</code>: Replace IDs in output from <code><a href="#topic+viterbi">viterbi()</a></code>
</p>
</li>
<li> <p><code>replace_ids(sim_geno)</code>: Replace IDs in output from <code><a href="#topic+sim_geno">sim_geno()</a></code>
</p>
</li>
<li> <p><code>replace_ids(matrix)</code>: Replace IDs in a matrix
</p>
</li>
<li> <p><code>replace_ids(data.frame)</code>: Replace IDs in a data frame
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))
ids &lt;- as.numeric(ind_ids(iron))

# replace the numeric IDs with IDs like "mouse003"
new_ids &lt;- setNames( sprintf("mouse%03d", as.numeric(ids)), ids)

iron &lt;- replace_ids(iron, new_ids)
</code></pre>

<hr>
<h2 id='scale_kinship'>Scale kinship matrix</h2><span id='topic+scale_kinship'></span>

<h3>Description</h3>

<p>Scale kinship matrix to be like a correlation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_kinship(kinship)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_kinship_+3A_kinship">kinship</code></td>
<td>
<p>A kinship matrix, or a list of such in the case of
the &quot;leave one chromosome out&quot; method, as calculated by
<code><a href="#topic+calc_kinship">calc_kinship()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We take
<em>c<sub>ij</sub> = k<sub>ij</sub> / &radic;(k<sub>ii</sub> k<sub>jj</sub>)</em>
</p>


<h3>Value</h3>

<p>A matrix or list of matrices, as with the input, but with
the matrices scaled to be like correlation matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
map &lt;- insert_pseudomarkers(grav2$gmap, step=1)
probs &lt;- calc_genoprob(grav2, map, error_prob=0.002)
K &lt;- calc_kinship(probs)
Ka &lt;- scale_kinship(K)
</code></pre>

<hr>
<h2 id='scan1'>Genome scan with a single-QTL model</h2><span id='topic+scan1'></span>

<h3>Description</h3>

<p>Genome scan with a single-QTL model by Haley-Knott regression or a
linear mixed model, with possible allowance for covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan1(
  genoprobs,
  pheno,
  kinship = NULL,
  addcovar = NULL,
  Xcovar = NULL,
  intcovar = NULL,
  weights = NULL,
  reml = TRUE,
  model = c("normal", "binary"),
  hsq = NULL,
  cores = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan1_+3A_genoprobs">genoprobs</code></td>
<td>
<p>Genotype probabilities as calculated by
<code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.</p>
</td></tr>
<tr><td><code id="scan1_+3A_pheno">pheno</code></td>
<td>
<p>A numeric matrix of phenotypes, individuals x phenotypes.</p>
</td></tr>
<tr><td><code id="scan1_+3A_kinship">kinship</code></td>
<td>
<p>Optional kinship matrix, or a list of kinship matrices (one
per chromosome), in order to use the LOCO (leave one chromosome
out) method.</p>
</td></tr>
<tr><td><code id="scan1_+3A_addcovar">addcovar</code></td>
<td>
<p>An optional numeric matrix of additive covariates.</p>
</td></tr>
<tr><td><code id="scan1_+3A_xcovar">Xcovar</code></td>
<td>
<p>An optional numeric matrix with additional additive covariates used for
null hypothesis when scanning the X chromosome.</p>
</td></tr>
<tr><td><code id="scan1_+3A_intcovar">intcovar</code></td>
<td>
<p>An numeric optional matrix of interactive covariates.</p>
</td></tr>
<tr><td><code id="scan1_+3A_weights">weights</code></td>
<td>
<p>An optional numeric vector of positive weights for the
individuals. As with the other inputs, it must have <code>names</code>
for individual identifiers.</p>
</td></tr>
<tr><td><code id="scan1_+3A_reml">reml</code></td>
<td>
<p>If <code>kinship</code> provided: if <code>reml=TRUE</code>, use
REML; otherwise maximum likelihood.</p>
</td></tr>
<tr><td><code id="scan1_+3A_model">model</code></td>
<td>
<p>Indicates whether to use a normal model (least
squares) or binary model (logistic regression) for the phenotype.
If <code>model="binary"</code>, the phenotypes must have values in <code class="reqn">[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="scan1_+3A_hsq">hsq</code></td>
<td>
<p>Considered only if <code>kinship</code> is provided, in which case
this is taken as the assumed value for the residual
heritability. It should be a vector with length corresponding
to the number of columns in <code>pheno</code>, or (if <code>kinship</code>
corresponds to a list of LOCO kinship matrices) a matrix with dimension
<code style="white-space: pre;">&#8288;length(kinship) x ncol(pheno)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="scan1_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
<tr><td><code id="scan1_+3A_...">...</code></td>
<td>
<p>Additional control parameters; see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We first fit the model <code class="reqn">y = X \beta + \epsilon</code>
where <code class="reqn">X</code> is a matrix of covariates (or just an intercept) and
<code class="reqn">\epsilon</code> is multivariate normal with mean 0 and covariance
matrix <code class="reqn">\sigma^2 [h^2 (2 K) + I]</code> where
<code class="reqn">K</code> is the kinship matrix and <code class="reqn">I</code> is the identity matrix.
</p>
<p>We then take <code class="reqn">h^2</code> as fixed and then scan the genome, at
each genomic position fitting the model <code class="reqn">y = P \alpha + X \beta
+ \epsilon</code> where <code class="reqn">P</code> is a matrix of genotype
probabilities for the current position and again <code class="reqn">X</code> is a
matrix of covariates <code class="reqn">\epsilon</code> is multivariate normal with
mean 0 and covariance matrix <code class="reqn">\sigma^2 [h^2 (2 K) +
I]</code>, taking <code class="reqn">h^2</code> to be known.
</p>
<p>Note that if <code>weights</code> are provided, the covariance matrix becomes
<code class="reqn">\sigma^2 [h^2 (2 K) + D]</code> where
<code class="reqn">D</code> is a diagonal matrix with the reciprocal of the weights.
</p>
<p>For each of the inputs, the row names are used as
individual identifiers, to align individuals. The <code>genoprobs</code>
object should have a component <code>"is_x_chr"</code> that indicates
which of the chromosomes is the X chromosome, if any.
</p>
<p>The <code>...</code> argument can contain several additional control
parameters; suspended for simplicity (or confusion, depending on
your point of view). <code>tol</code> is used as a tolerance value for linear
regression by QR decomposition (in determining whether columns are
linearly dependent on others and should be omitted); default
<code>1e-12</code>. <code>intcovar_method</code> indicates whether to use a high-memory
(but potentially faster) method or a low-memory (and possibly
slower) method, with values <code>"highmem"</code> or <code>"lowmem"</code>; default
<code>"lowmem"</code>. <code>max_batch</code> indicates the maximum number of phenotypes
to run together; default is unlimited. <code>maxit</code> is the maximum
number of iterations for converence of the iterative algorithm
used when <code>model=binary</code>. <code>bintol</code> is used as a tolerance for
converence for the iterative algorithm used when <code>model=binary</code>.
<code>eta_max</code> is the maximum value for the &quot;linear predictor&quot; in the
case <code>model="binary"</code> (a bit of a technicality to avoid fitted
values exactly at 0 or 1).
</p>
<p>If <code>kinship</code> is absent, Haley-Knott regression is performed.
If <code>kinship</code> is provided, a linear mixed model is used, with a
polygenic effect estimated under the null hypothesis of no (major)
QTL, and then taken as fixed as known in the genome scan.
</p>
<p>If <code>kinship</code> is a single matrix, then the <code>hsq</code>
in the results is a vector of heritabilities (one value for each phenotype). If
<code>kinship</code> is a list (one matrix per chromosome), then
<code>hsq</code> is a matrix, chromosomes x phenotypes.
</p>


<h3>Value</h3>

<p>An object of class <code>"scan1"</code>: a matrix of LOD scores, positions x phenotypes.
Also contains one or more of the following attributes:
</p>

<ul>
<li> <p><code>sample_size</code> - Vector of sample sizes used for each
phenotype
</p>
</li>
<li> <p><code>hsq</code> - Included if <code>kinship</code> provided: A matrix of
estimated heritabilities under the null hypothesis of no
QTL. Columns are the phenotypes. If the <code>"loco"</code> method was
used with <code><a href="#topic+calc_kinship">calc_kinship()</a></code> to calculate a list
of kinship matrices, one per chromosome, the rows of <code>hsq</code>
will be the heritabilities for the different chromosomes (well,
leaving out each one). If <code>Xcovar</code> was not NULL, there will at
least be an autosome and X chromosome row.
</p>
</li></ul>



<h3>References</h3>

<p>Haley CS, Knott SA (1992) A simple
regression method for mapping quantitative trait loci in line
crosses using flanking markers.  Heredity 69:315&ndash;324.
</p>
<p>Kang HM, Zaitlen NA, Wade CM, Kirby A, Heckerman D, Daly MJ, Eskin
E (2008) Efficient control of population structure in model
organism association mapping. Genetics 178:1709&ndash;1723.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scan1perm">scan1perm()</a></code>, <code><a href="#topic+scan1coef">scan1coef()</a></code>, <code><a href="#topic+cbind.scan1">cbind.scan1()</a></code>, <code><a href="#topic+rbind.scan1">rbind.scan1()</a></code>, <code><a href="#topic+scan1max">scan1max()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))


# insert pseudomarkers into map
map &lt;- insert_pseudomarkers(iron$gmap, step=1)

# calculate genotype probabilities
probs &lt;- calc_genoprob(iron, map, error_prob=0.002)

# grab phenotypes and covariates; ensure that covariates have names attribute
pheno &lt;- iron$pheno
covar &lt;- match(iron$covar$sex, c("f", "m")) # make numeric
names(covar) &lt;- rownames(iron$covar)
Xcovar &lt;- get_x_covar(iron)

# perform genome scan
out &lt;- scan1(probs, pheno, addcovar=covar, Xcovar=Xcovar)

# leave-one-chromosome-out kinship matrices
kinship &lt;- calc_kinship(probs, "loco")

# genome scan with a linear mixed model
out_lmm &lt;- scan1(probs, pheno, kinship, covar, Xcovar)

</code></pre>

<hr>
<h2 id='scan1blup'>Calculate BLUPs of QTL effects in scan along one chromosome</h2><span id='topic+scan1blup'></span>

<h3>Description</h3>

<p>Calculate BLUPs of QTL effects in scan along one chromosome, with a
single-QTL model treating the QTL effects as random, with possible
allowance for covariates and for a residual polygenic effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan1blup(
  genoprobs,
  pheno,
  kinship = NULL,
  addcovar = NULL,
  nullcovar = NULL,
  contrasts = NULL,
  se = FALSE,
  reml = TRUE,
  tol = 0.000000000001,
  cores = 1,
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan1blup_+3A_genoprobs">genoprobs</code></td>
<td>
<p>Genotype probabilities as calculated by
<code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.</p>
</td></tr>
<tr><td><code id="scan1blup_+3A_pheno">pheno</code></td>
<td>
<p>A numeric vector of phenotype values (just one phenotype, not a matrix of them)</p>
</td></tr>
<tr><td><code id="scan1blup_+3A_kinship">kinship</code></td>
<td>
<p>Optional kinship matrix, or a list of kinship matrices (one
per chromosome), in order to use the LOCO (leave one chromosome
out) method.</p>
</td></tr>
<tr><td><code id="scan1blup_+3A_addcovar">addcovar</code></td>
<td>
<p>An optional numeric matrix of additive covariates.</p>
</td></tr>
<tr><td><code id="scan1blup_+3A_nullcovar">nullcovar</code></td>
<td>
<p>An optional numeric matrix of additional additive
covariates that are used under the null hypothesis (of no QTL) but
not under the alternative (with a QTL). This is needed for the X
chromosome, where we might need sex as a additive covariate under
the null hypothesis, but we wouldn't want to include it under the
alternative as it would be collinear with the QTL effects. Only
used if <code>kinship</code> is provided but <code>hsq</code> is not, to get
estimate of residual heritability.</p>
</td></tr>
<tr><td><code id="scan1blup_+3A_contrasts">contrasts</code></td>
<td>
<p>An optional numeric matrix of genotype contrasts, size
genotypes x genotypes. For an intercross, you might use
<code>cbind(mu=c(1,0,0), a=c(-1, 0, 1), d=c(0, 1, 0))</code> to get
mean, additive effect, and dominance effect. The default is the
identity matrix.</p>
</td></tr>
<tr><td><code id="scan1blup_+3A_se">se</code></td>
<td>
<p>If TRUE, also calculate the standard errors.</p>
</td></tr>
<tr><td><code id="scan1blup_+3A_reml">reml</code></td>
<td>
<p>If <code>reml=TRUE</code>, use
REML to estimate variance components; otherwise maximum likelihood.</p>
</td></tr>
<tr><td><code id="scan1blup_+3A_tol">tol</code></td>
<td>
<p>Tolerance value for convergence of linear mixed model fit.</p>
</td></tr>
<tr><td><code id="scan1blup_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
<tr><td><code id="scan1blup_+3A_quiet">quiet</code></td>
<td>
<p>If FALSE, print message about number of cores used when multi-core.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each of the inputs, the row names are used as
individual identifiers, to align individuals.
</p>
<p>If <code>kinship</code> is provided, the linear mixed model accounts for
a residual polygenic effect, with a the polygenic variance
estimated under the null hypothesis of no (major) QTL, and then
taken as fixed as known in the scan to estimate QTL effects.
</p>
<p>If <code>contrasts</code> is provided, the genotype probability matrix,
<code class="reqn">P</code>, is post-multiplied by the contrasts matrix, <code class="reqn">A</code>, prior
to fitting the model. So we use <code class="reqn">P \cdot A</code> as the <code class="reqn">X</code>
matrix in the model. One might view the rows of
<em>A</em><sup>-1</sup>
as the set of contrasts, as the estimated effects are the estimated
genotype effects pre-multiplied by
<em>A</em><sup>-1</sup>.
</p>


<h3>Value</h3>

<p>An object of class <code>"scan1coef"</code>: a matrix of estimated regression coefficients, of dimension
positions x number of effects. The number of effects is
<code>n_genotypes + n_addcovar</code>.
May also contain the following attributes:
</p>

<ul>
<li> <p><code>SE</code> - Present if <code>se=TRUE</code>: a matrix of estimated
standard errors, of same dimension as <code>coef</code>.
</p>
</li>
<li> <p><code>sample_size</code> - Vector of sample sizes used for each
phenotype
</p>
</li></ul>



<h3>References</h3>

<p>Haley CS, Knott SA (1992) A simple
regression method for mapping quantitative trait loci in line
crosses using flanking markers.  Heredity 69:315&ndash;324.
</p>
<p>Kang HM, Zaitlen NA, Wade CM, Kirby A, Heckerman D, Daly MJ, Eskin
E (2008) Efficient control of population structure in model
organism association mapping. Genetics 178:1709&ndash;1723.
</p>
<p>Robinson GK (1991) That BLUP is a good thing: The estimation of
random effects. Statist Sci 6:15&ndash;32.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))


# insert pseudomarkers into map
map &lt;- insert_pseudomarkers(iron$gmap, step=1)

# calculate genotype probabilities
probs &lt;- calc_genoprob(iron, map, error_prob=0.002)


# convert to allele probabilities
aprobs &lt;- genoprob_to_alleleprob(probs)

# grab phenotypes and covariates; ensure that covariates have names attribute
pheno &lt;- iron$pheno[,1]
covar &lt;- match(iron$covar$sex, c("f", "m")) # make numeric
names(covar) &lt;- rownames(iron$covar)

# calculate BLUPs of coefficients for chromosome 7
blup &lt;- scan1blup(aprobs[,"7"], pheno, addcovar=covar)

# leave-one-chromosome-out kinship matrix for chr 7
kinship7 &lt;- calc_kinship(probs, "loco")[["7"]]

# calculate BLUPs of coefficients for chromosome 7, adjusting for residual polygenic effect
blup_pg &lt;- scan1blup(aprobs[,"7"], pheno, kinship7, addcovar=covar)

</code></pre>

<hr>
<h2 id='scan1coef'>Calculate QTL effects in scan along one chromosome</h2><span id='topic+scan1coef'></span>

<h3>Description</h3>

<p>Calculate QTL effects in scan along one chromosome with a
single-QTL model using Haley-Knott regression or a linear mixed
model (the latter to account for a residual polygenic effect), with
possible allowance for covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan1coef(
  genoprobs,
  pheno,
  kinship = NULL,
  addcovar = NULL,
  nullcovar = NULL,
  intcovar = NULL,
  weights = NULL,
  contrasts = NULL,
  model = c("normal", "binary"),
  zerosum = TRUE,
  se = FALSE,
  hsq = NULL,
  reml = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan1coef_+3A_genoprobs">genoprobs</code></td>
<td>
<p>Genotype probabilities as calculated by
<code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.</p>
</td></tr>
<tr><td><code id="scan1coef_+3A_pheno">pheno</code></td>
<td>
<p>A numeric vector of phenotype values (just one phenotype, not a matrix of them)</p>
</td></tr>
<tr><td><code id="scan1coef_+3A_kinship">kinship</code></td>
<td>
<p>Optional kinship matrix, or a list of kinship matrices (one
per chromosome), in order to use the LOCO (leave one chromosome
out) method.</p>
</td></tr>
<tr><td><code id="scan1coef_+3A_addcovar">addcovar</code></td>
<td>
<p>An optional numeric matrix of additive covariates.</p>
</td></tr>
<tr><td><code id="scan1coef_+3A_nullcovar">nullcovar</code></td>
<td>
<p>An optional numeric matrix of additional additive
covariates that are used under the null hypothesis (of no QTL) but
not under the alternative (with a QTL). This is needed for the X
chromosome, where we might need sex as a additive covariate under
the null hypothesis, but we wouldn't want to include it under the
alternative as it would be collinear with the QTL effects. Only
used if <code>kinship</code> is provided but <code>hsq</code> is not, to get
estimate of residual heritability.</p>
</td></tr>
<tr><td><code id="scan1coef_+3A_intcovar">intcovar</code></td>
<td>
<p>An optional numeric matrix of interactive covariates.</p>
</td></tr>
<tr><td><code id="scan1coef_+3A_weights">weights</code></td>
<td>
<p>An optional numeric vector of positive weights for the
individuals. As with the other inputs, it must have <code>names</code>
for individual identifiers.</p>
</td></tr>
<tr><td><code id="scan1coef_+3A_contrasts">contrasts</code></td>
<td>
<p>An optional numeric matrix of genotype contrasts, size
genotypes x genotypes. For an intercross, you might use
<code>cbind(mu=c(1,1,1), a=c(-1, 0, 1), d=c(0, 1, 0))</code> to get
mean, additive effect, and dominance effect. The default is the
identity matrix.</p>
</td></tr>
<tr><td><code id="scan1coef_+3A_model">model</code></td>
<td>
<p>Indicates whether to use a normal model (least
squares) or binary model (logistic regression) for the phenotype.
If <code>model="binary"</code>, the phenotypes must have values in <code class="reqn">[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="scan1coef_+3A_zerosum">zerosum</code></td>
<td>
<p>If TRUE, force the genotype or allele coefficients
sum to 0 by subtracting their mean and add another column with
the mean. Ignored if <code>contrasts</code> is provided.</p>
</td></tr>
<tr><td><code id="scan1coef_+3A_se">se</code></td>
<td>
<p>If TRUE, also calculate the standard errors.</p>
</td></tr>
<tr><td><code id="scan1coef_+3A_hsq">hsq</code></td>
<td>
<p>(Optional) residual heritability; used only if
<code>kinship</code> provided.</p>
</td></tr>
<tr><td><code id="scan1coef_+3A_reml">reml</code></td>
<td>
<p>If <code>kinship</code> provided: if <code>reml=TRUE</code>, use
REML; otherwise maximum likelihood.</p>
</td></tr>
<tr><td><code id="scan1coef_+3A_...">...</code></td>
<td>
<p>Additional control parameters; see Details;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each of the inputs, the row names are used as
individual identifiers, to align individuals.
</p>
<p>If <code>kinship</code> is absent, Haley-Knott regression is performed.
If <code>kinship</code> is provided, a linear mixed model is used, with a
polygenic effect estimated under the null hypothesis of no (major)
QTL, and then taken as fixed as known in the genome scan.
</p>
<p>If <code>contrasts</code> is provided, the genotype probability matrix,
<code class="reqn">P</code>, is post-multiplied by the contrasts matrix, <code class="reqn">A</code>, prior
to fitting the model. So we use <code class="reqn">P \cdot A</code> as the <code class="reqn">X</code>
matrix in the model. One might view the rows of
<em>A</em><sup>-1</sup>
as the set of contrasts, as the estimated effects are the estimated
genotype effects pre-multiplied by
<em>A</em><sup>-1</sup>.
</p>
<p>The <code>...</code> argument can contain several additional control
parameters; suspended for simplicity (or confusion, depending on
your point of view). <code>tol</code> is used as a tolerance value for linear
regression by QR decomposition (in determining whether columns are
linearly dependent on others and should be omitted); default
<code>1e-12</code>. <code>maxit</code> is the maximum number of iterations for
converence of the iterative algorithm used when <code>model=binary</code>.
<code>bintol</code> is used as a tolerance for converence for the iterative
algorithm used when <code>model=binary</code>. <code>eta_max</code> is the maximum value
for the &quot;linear predictor&quot; in the case <code>model="binary"</code> (a bit of a
technicality to avoid fitted values exactly at 0 or 1).
</p>


<h3>Value</h3>

<p>An object of class <code>"scan1coef"</code>: a matrix of estimated regression coefficients, of dimension
positions x number of effects. The number of effects is
<code>n_genotypes + n_addcovar + (n_genotypes-1)*n_intcovar</code>.
May also contain the following attributes:
</p>

<ul>
<li> <p><code>SE</code> - Present if <code>se=TRUE</code>: a matrix of estimated
standard errors, of same dimension as <code>coef</code>.
</p>
</li>
<li> <p><code>sample_size</code> - Vector of sample sizes used for each
phenotype
</p>
</li></ul>



<h3>References</h3>

<p>Haley CS, Knott SA (1992) A simple
regression method for mapping quantitative trait loci in line
crosses using flanking markers.  Heredity 69:315&ndash;324.
</p>
<p>Kang HM, Zaitlen NA, Wade CM, Kirby A, Heckerman D, Daly MJ, Eskin
E (2008) Efficient control of population structure in model
organism association mapping. Genetics 178:1709&ndash;1723.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))


# insert pseudomarkers into map
map &lt;- insert_pseudomarkers(iron$gmap, step=1)

# calculate genotype probabilities
probs &lt;- calc_genoprob(iron, map, error_prob=0.002)


# grab phenotypes and covariates; ensure that covariates have names attribute
pheno &lt;- iron$pheno[,1]
covar &lt;- match(iron$covar$sex, c("f", "m")) # make numeric
names(covar) &lt;- rownames(iron$covar)

# calculate coefficients for chromosome 7
coef &lt;- scan1coef(probs[,"7"], pheno, addcovar=covar)

# leave-one-chromosome-out kinship matrix for chr 7
kinship7 &lt;- calc_kinship(probs, "loco")[["7"]]

# calculate coefficients for chromosome 7, adjusting for residual polygenic effect
coef_pg &lt;- scan1coef(probs[,"7"], pheno, kinship7, addcovar=covar)

</code></pre>

<hr>
<h2 id='scan1max'>Maximum LOD score from genome scan with a single-QTL model</h2><span id='topic+scan1max'></span>

<h3>Description</h3>

<p>Maximum LOD score from genome scan with a single-QTL model by
Haley-Knott regression or a linear mixed model, with possible
allowance for covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan1max(
  genoprobs,
  pheno,
  kinship = NULL,
  addcovar = NULL,
  Xcovar = NULL,
  intcovar = NULL,
  weights = NULL,
  reml = TRUE,
  model = c("normal", "binary"),
  hsq = NULL,
  by_chr = FALSE,
  cores = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan1max_+3A_genoprobs">genoprobs</code></td>
<td>
<p>Genotype probabilities as calculated by
<code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.</p>
</td></tr>
<tr><td><code id="scan1max_+3A_pheno">pheno</code></td>
<td>
<p>A numeric matrix of phenotypes, individuals x phenotypes.</p>
</td></tr>
<tr><td><code id="scan1max_+3A_kinship">kinship</code></td>
<td>
<p>Optional kinship matrix, or a list of kinship matrices (one
per chromosome), in order to use the LOCO (leave one chromosome
out) method.</p>
</td></tr>
<tr><td><code id="scan1max_+3A_addcovar">addcovar</code></td>
<td>
<p>An optional numeric matrix of additive covariates.</p>
</td></tr>
<tr><td><code id="scan1max_+3A_xcovar">Xcovar</code></td>
<td>
<p>An optional numeric matrix with additional additive covariates used for
null hypothesis when scanning the X chromosome.</p>
</td></tr>
<tr><td><code id="scan1max_+3A_intcovar">intcovar</code></td>
<td>
<p>An numeric optional matrix of interactive covariates.</p>
</td></tr>
<tr><td><code id="scan1max_+3A_weights">weights</code></td>
<td>
<p>An optional numeric vector of positive weights for the
individuals. As with the other inputs, it must have <code>names</code>
for individual identifiers.</p>
</td></tr>
<tr><td><code id="scan1max_+3A_reml">reml</code></td>
<td>
<p>If <code>kinship</code> provided: if <code>reml=TRUE</code>, use
REML; otherwise maximum likelihood.</p>
</td></tr>
<tr><td><code id="scan1max_+3A_model">model</code></td>
<td>
<p>Indicates whether to use a normal model (least
squares) or binary model (logistic regression) for the phenotype.
If <code>model="binary"</code>, the phenotypes must have values in <code class="reqn">[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="scan1max_+3A_hsq">hsq</code></td>
<td>
<p>Considered only if <code>kinship</code> is provided, in which case
this is taken as the assumed value for the residual
heritability. It should be a vector with length corresponding
to the number of columns in <code>pheno</code>, or (if <code>kinship</code>
corresponds to a list of LOCO kinship matrices) a matrix with dimension
<code style="white-space: pre;">&#8288;length(kinship) x ncol(pheno)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="scan1max_+3A_by_chr">by_chr</code></td>
<td>
<p>If TRUE, save the individual chromosome maxima.</p>
</td></tr>
<tr><td><code id="scan1max_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
<tr><td><code id="scan1max_+3A_...">...</code></td>
<td>
<p>Additional control parameters; see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Equivalent to running <code>scan1()</code> and then saving the column
maxima, with some savings in memory usage.
</p>


<h3>Value</h3>

<p>Either a vector of genome-wide maximum LOD scores, or if
<code>by_chr</code> is TRUE, a matrix with the chromosome-specific maxima,
with the rows being the chromosomes and the columns being the
phenotypes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scan1">scan1()</a></code>, <code><a href="#topic+scan1perm">scan1perm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))


# insert pseudomarkers into map
map &lt;- insert_pseudomarkers(iron$gmap, step=1)

# calculate genotype probabilities
probs &lt;- calc_genoprob(iron, map, error_prob=0.002)

# grab phenotypes and covariates; ensure that covariates have names attribute
pheno &lt;- iron$pheno
covar &lt;- match(iron$covar$sex, c("f", "m")) # make numeric
names(covar) &lt;- rownames(iron$covar)
Xcovar &lt;- get_x_covar(iron)

# perform genome scan
out &lt;- scan1max(probs, pheno, addcovar=covar, Xcovar=Xcovar)

</code></pre>

<hr>
<h2 id='scan1perm'>Permutation test for genome scan with a single-QTL model</h2><span id='topic+scan1perm'></span>

<h3>Description</h3>

<p>Permutation test for a enome scan with a single-QTL model by
Haley-Knott regression or a linear mixed model, with possible
allowance for covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan1perm(
  genoprobs,
  pheno,
  kinship = NULL,
  addcovar = NULL,
  Xcovar = NULL,
  intcovar = NULL,
  weights = NULL,
  reml = TRUE,
  model = c("normal", "binary"),
  n_perm = 1,
  perm_Xsp = FALSE,
  perm_strata = NULL,
  chr_lengths = NULL,
  cores = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan1perm_+3A_genoprobs">genoprobs</code></td>
<td>
<p>Genotype probabilities as calculated by
<code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.</p>
</td></tr>
<tr><td><code id="scan1perm_+3A_pheno">pheno</code></td>
<td>
<p>A numeric matrix of phenotypes, individuals x phenotypes.</p>
</td></tr>
<tr><td><code id="scan1perm_+3A_kinship">kinship</code></td>
<td>
<p>Optional kinship matrix, or a list of kinship matrices (one
per chromosome), in order to use the LOCO (leave one chromosome
out) method.</p>
</td></tr>
<tr><td><code id="scan1perm_+3A_addcovar">addcovar</code></td>
<td>
<p>An optional numeric matrix of additive covariates.</p>
</td></tr>
<tr><td><code id="scan1perm_+3A_xcovar">Xcovar</code></td>
<td>
<p>An optional numeric matrix with additional additive covariates used for
null hypothesis when scanning the X chromosome.</p>
</td></tr>
<tr><td><code id="scan1perm_+3A_intcovar">intcovar</code></td>
<td>
<p>An optional numeric matrix of interactive covariates.</p>
</td></tr>
<tr><td><code id="scan1perm_+3A_weights">weights</code></td>
<td>
<p>An optional numeric vector of positive weights for the
individuals. As with the other inputs, it must have <code>names</code>
for individual identifiers.</p>
</td></tr>
<tr><td><code id="scan1perm_+3A_reml">reml</code></td>
<td>
<p>If <code>kinship</code> provided: if <code>reml=TRUE</code>, use
REML; otherwise maximum likelihood.</p>
</td></tr>
<tr><td><code id="scan1perm_+3A_model">model</code></td>
<td>
<p>Indicates whether to use a normal model (least
squares) or binary model (logistic regression) for the phenotype.
If <code>model="binary"</code>, the phenotypes must have values in <code class="reqn">[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="scan1perm_+3A_n_perm">n_perm</code></td>
<td>
<p>Number of permutation replicates.</p>
</td></tr>
<tr><td><code id="scan1perm_+3A_perm_xsp">perm_Xsp</code></td>
<td>
<p>If TRUE, do separate permutations for the autosomes
and the X chromosome.</p>
</td></tr>
<tr><td><code id="scan1perm_+3A_perm_strata">perm_strata</code></td>
<td>
<p>Vector of strata, for a stratified permutation
test. Should be named in the same way as the rows of
<code>pheno</code>. The unique values define the strata.</p>
</td></tr>
<tr><td><code id="scan1perm_+3A_chr_lengths">chr_lengths</code></td>
<td>
<p>Lengths of the chromosomes; needed only if
<code>perm_Xsp=TRUE</code>. See <code><a href="#topic+chr_lengths">chr_lengths()</a></code>.</p>
</td></tr>
<tr><td><code id="scan1perm_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
<tr><td><code id="scan1perm_+3A_...">...</code></td>
<td>
<p>Additional control parameters; see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>kinship</code> is not provided, so that analysis proceeds by
Haley-Knott regression, we permute the rows of the phenotype data;
the same permutations are also applied to the rows of the
covariates (<code>addcovar</code>, <code>Xcovar</code>, and <code>intcovar</code>)
are permuted.
</p>
<p>If <code>kinship</code> is provided, we instead permute the rows of the
genotype data and fit an LMM with the same residual heritability
(estimated under the null hypothesis of no QTL).
</p>
<p>If <code>Xcovar</code> is provided and <code>perm_strata=NULL</code>, we do a
stratified permutation test with the strata defined by the rows of
<code>Xcovar</code>. If a simple permutation test is desired, provide
<code>perm_strata</code> that is a vector containing a single repeated
value.
</p>
<p>The <code>...</code> argument can contain several additional control
parameters; suspended for simplicity (or confusion, depending on
your point of view). <code>tol</code> is used as a tolerance value for linear
regression by QR decomposition (in determining whether columns are
linearly dependent on others and should be omitted); default
<code>1e-12</code>. <code>maxit</code> is the maximum number of iterations for
converence of the iterative algorithm used when <code>model=binary</code>.
<code>bintol</code> is used as a tolerance for converence for the iterative
algorithm used when <code>model=binary</code>. <code>eta_max</code> is the maximum value
for the &quot;linear predictor&quot; in the case <code>model="binary"</code> (a bit of a
technicality to avoid fitted values exactly at 0 or 1).
</p>


<h3>Value</h3>

<p>If <code>perm_Xsp=FALSE</code>, the result is matrix of
genome-wide maximum LOD scores, permutation replicates x
phenotypes. If <code>perm_Xsp=TRUE</code>, the result is a list of
two matrices, one for the autosomes and one for the X
chromosome. The object is given class <code>"scan1perm"</code>.
</p>


<h3>References</h3>

<p>Churchill GA, Doerge RW (1994) Empirical threshold
values for quantitative trait mapping. Genetics 138:963&ndash;971.
</p>
<p>Manichaikul A, Palmer AA, Sen S, Broman KW (2007) Significance
thresholds for quantitative trait locus mapping under selective
genotyping. Genetics 177:1963&ndash;1966.
</p>
<p>Haley CS, Knott SA (1992) A simple regression method for mapping
quantitative trait loci in line crosses using flanking markers.
Heredity 69:315&ndash;324.
</p>
<p>Kang HM, Zaitlen NA, Wade CM, Kirby A, Heckerman D, Daly MJ, Eskin
E (2008) Efficient control of population structure in model
organism association mapping. Genetics 178:1709&ndash;1723.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scan1">scan1()</a></code>, <code><a href="#topic+chr_lengths">chr_lengths()</a></code>, <code><a href="#topic+mat2strata">mat2strata()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))


# insert pseudomarkers into map
map &lt;- insert_pseudomarkers(iron$gmap, step=1)

# calculate genotype probabilities
probs &lt;- calc_genoprob(iron, map, error_prob=0.002)

# grab phenotypes and covariates; ensure that covariates have names attribute
pheno &lt;- iron$pheno
covar &lt;- match(iron$covar$sex, c("f", "m")) # make numeric
names(covar) &lt;- rownames(iron$covar)
Xcovar &lt;- get_x_covar(iron)

# strata for permutations
perm_strata &lt;- mat2strata(Xcovar)

# permutations with genome scan (just 3 replicates, for illustration)
operm &lt;- scan1perm(probs, pheno, addcovar=covar, Xcovar=Xcovar,
                   n_perm=3, perm_strata=perm_strata)
summary(operm)

# leave-one-chromosome-out kinship matrices
kinship &lt;- calc_kinship(probs, "loco")

# permutations of genome scan with a linear mixed model

operm_lmm &lt;- scan1perm(probs, pheno, kinship, covar, Xcovar, n_perm=3,
                       perm_Xsp=TRUE, perm_strata=perm_strata,
                       chr_lengths=chr_lengths(map))
summary(operm_lmm)


</code></pre>

<hr>
<h2 id='scan1snps'>Single-QTL genome scan at imputed SNPs</h2><span id='topic+scan1snps'></span>

<h3>Description</h3>

<p>Perform a single-QTL scan across the genome or a defined region at
SNPs genotyped in the founders, by Haley-Knott regression or a
liear mixed model, with possible allowance for covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan1snps(
  genoprobs,
  map,
  pheno,
  kinship = NULL,
  addcovar = NULL,
  Xcovar = NULL,
  intcovar = NULL,
  weights = NULL,
  reml = TRUE,
  model = c("normal", "binary"),
  query_func = NULL,
  chr = NULL,
  start = NULL,
  end = NULL,
  snpinfo = NULL,
  batch_length = 20,
  keep_all_snps = FALSE,
  cores = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan1snps_+3A_genoprobs">genoprobs</code></td>
<td>
<p>Genotype probabilities as calculated by
<code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.</p>
</td></tr>
<tr><td><code id="scan1snps_+3A_map">map</code></td>
<td>
<p>Physical map for the positions in the <code>genoprobs</code>
object: A list of numeric vectors; each vector gives marker
positions for a single chromosome.</p>
</td></tr>
<tr><td><code id="scan1snps_+3A_pheno">pheno</code></td>
<td>
<p>A numeric matrix of phenotypes, individuals x phenotypes.</p>
</td></tr>
<tr><td><code id="scan1snps_+3A_kinship">kinship</code></td>
<td>
<p>Optional kinship matrix, or a list of kinship matrices (one
per chromosome), in order to use the LOCO (leave one chromosome
out) method.</p>
</td></tr>
<tr><td><code id="scan1snps_+3A_addcovar">addcovar</code></td>
<td>
<p>An optional numeric matrix of additive covariates.</p>
</td></tr>
<tr><td><code id="scan1snps_+3A_xcovar">Xcovar</code></td>
<td>
<p>An optional numeric matrix with additional additive covariates used for
null hypothesis when scanning the X chromosome.</p>
</td></tr>
<tr><td><code id="scan1snps_+3A_intcovar">intcovar</code></td>
<td>
<p>An optional numeric matrix of interactive covariates.</p>
</td></tr>
<tr><td><code id="scan1snps_+3A_weights">weights</code></td>
<td>
<p>An optional numeric vector of positive weights for the
individuals. As with the other inputs, it must have <code>names</code>
for individual identifiers.</p>
</td></tr>
<tr><td><code id="scan1snps_+3A_reml">reml</code></td>
<td>
<p>If <code>kinship</code> provided: if <code>reml=TRUE</code>, use
REML; otherwise maximum likelihood.</p>
</td></tr>
<tr><td><code id="scan1snps_+3A_model">model</code></td>
<td>
<p>Indicates whether to use a normal model (least
squares) or binary model (logistic regression) for the phenotype.
If <code>model="binary"</code>, the phenotypes must have values in <code class="reqn">[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="scan1snps_+3A_query_func">query_func</code></td>
<td>
<p>Function for querying SNP information; see
<code><a href="#topic+create_variant_query_func">create_variant_query_func()</a></code>). Takes arguments
<code>chr</code>, <code>start</code>, <code>end</code>, (with <code>start</code> and <code>end</code> in the units in
<code>map</code>, generally Mbp), and returns a data frame containing
the columns <code>snp</code>, <code>chr</code>, <code>pos</code>, and <code>sdp</code>. (See <code>snpinfo</code> below.)</p>
</td></tr>
<tr><td><code id="scan1snps_+3A_chr">chr</code></td>
<td>
<p>Chromosome or chromosomes to scan</p>
</td></tr>
<tr><td><code id="scan1snps_+3A_start">start</code></td>
<td>
<p>Position defining the start of an interval to scan.
Should be a single number, and if provided, <code>chr</code> should also
have length 1.</p>
</td></tr>
<tr><td><code id="scan1snps_+3A_end">end</code></td>
<td>
<p>Position defining the end of an interval to scan.
Should be a single number, and if provided, <code>chr</code> should also
have length 1.</p>
</td></tr>
<tr><td><code id="scan1snps_+3A_snpinfo">snpinfo</code></td>
<td>
<p>Optional data frame of SNPs to scan; if provided,
<code>query_func</code>, <code>chr</code>, <code>start</code>, and <code>end</code> are ignored. Should
contain the following columns:
</p>

<ul>
<li> <p><code>chr</code> - Character string or factor with chromosome
</p>
</li>
<li> <p><code>pos</code> - Position (in same units as in the <code>"map"</code>).
</p>
</li>
<li> <p><code>sdp</code> - Strain distribution pattern: an integer, between
1 and <code class="reqn">2^n - 2</code> where <code class="reqn">n</code> is the number of strains, whose
binary encoding indicates the founder genotypes
</p>
</li>
<li> <p><code>snp</code> - Character string with SNP identifier (if
missing, the rownames are used).
</p>
</li></ul>
</td></tr>
<tr><td><code id="scan1snps_+3A_batch_length">batch_length</code></td>
<td>
<p>Interval length (in units of <code>map</code>, generally
Mbp) to scan at one time.</p>
</td></tr>
<tr><td><code id="scan1snps_+3A_keep_all_snps">keep_all_snps</code></td>
<td>
<p>SNPs are grouped into equivalence classes based
on position and founder genotypes; if <code>keep_all_snps=FALSE</code>,
the return value will contain information only on the indexed
SNPs (one per equivalence class).</p>
</td></tr>
<tr><td><code id="scan1snps_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
<tr><td><code id="scan1snps_+3A_...">...</code></td>
<td>
<p>Additional control parameters passed to <code><a href="#topic+scan1">scan1()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The analysis proceeds as follows:
</p>

<ul>
<li><p> Call <code>query_func()</code> to grab all SNPs over a region.
</p>
</li>
<li><p> Use <code><a href="#topic+index_snps">index_snps()</a></code> to group SNPs into equivalence classes.
</p>
</li>
<li><p> Use <code><a href="#topic+genoprob_to_snpprob">genoprob_to_snpprob()</a></code> to convert <code>genoprobs</code> to SNP probabilities.
</p>
</li>
<li><p> Use <code><a href="#topic+scan1">scan1()</a></code> to do a single-QTL scan at the SNPs.
</p>
</li></ul>



<h3>Value</h3>

<p>A list with two components: <code>lod</code> (matrix of LOD scores)
and <code>snpinfo</code> (a data frame of SNPs that were scanned,
including columns <code>index</code> which indicates groups of equivalent
SNPs)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scan1">scan1()</a></code>, <code><a href="#topic+genoprob_to_snpprob">genoprob_to_snpprob()</a></code>, <code><a href="#topic+index_snps">index_snps()</a></code>, <code><a href="#topic+create_variant_query_func">create_variant_query_func()</a></code>, <code><a href="#topic+plot_snpasso">plot_snpasso()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data and calculate genotype probabilities
file &lt;- paste0("https://raw.githubusercontent.com/rqtl/",
               "qtl2data/main/DOex/DOex.zip")
DOex &lt;- read_cross2(file)
probs &lt;- calc_genoprob(DOex, error_prob=0.002)

snpdb_file &lt;- system.file("extdata", "cc_variants_small.sqlite", package="qtl2")
queryf &lt;- create_variant_query_func(snpdb_file)

out &lt;- scan1snps(probs, DOex$pmap, DOex$pheno, query_func=queryf, chr=2, start=97, end=98)

## End(Not run)

</code></pre>

<hr>
<h2 id='sdp2char'>Convert strain distribution patterns to character strings</h2><span id='topic+sdp2char'></span>

<h3>Description</h3>

<p>Convert a vector of numeric codes for strain distribution patterns to character strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdp2char(sdp, n_strains = NULL, strains = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdp2char_+3A_sdp">sdp</code></td>
<td>
<p>Vector of strain distribution patterns (integers between
1 and <code class="reqn">2^n-2</code> where <code class="reqn">n</code> is the number of strains.</p>
</td></tr>
<tr><td><code id="sdp2char_+3A_n_strains">n_strains</code></td>
<td>
<p>Number of founder strains (if missing but
<code>strains</code> is provided, we use the length of <code>strains</code>)</p>
</td></tr>
<tr><td><code id="sdp2char_+3A_strains">strains</code></td>
<td>
<p>Vector of single-letter codes for the strains</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of character strings with the two groups of alleles
separated by a vertical bar (|).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+invert_sdp">invert_sdp()</a></code>, <code><a href="#topic+calc_sdp">calc_sdp()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sdp &lt;- c(m1=1, m2=12, m3=240)
sdp2char(sdp, 8)
sdp2char(sdp, strains=c("A", "B", "1", "D", "Z", "C", "P", "W"))
</code></pre>

<hr>
<h2 id='sim_geno'>Simulate genotypes given observed marker data</h2><span id='topic+sim_geno'></span>

<h3>Description</h3>

<p>Uses a hidden Markov model to simulate from the joint distribution
Pr(g | O) where g is the underlying sequence of true genotypes and
O is the observed multipoint marker data, with possible allowance
for genotyping errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_geno(
  cross,
  map = NULL,
  n_draws = 1,
  error_prob = 0.0001,
  map_function = c("haldane", "kosambi", "c-f", "morgan"),
  lowmem = FALSE,
  quiet = TRUE,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_geno_+3A_cross">cross</code></td>
<td>
<p>Object of class <code>"cross2"</code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.</p>
</td></tr>
<tr><td><code id="sim_geno_+3A_map">map</code></td>
<td>
<p>Genetic map of markers. May include pseudomarker
locations (that is, locations that are not within the marker
genotype data). If NULL, the genetic map in <code>cross</code> is used.</p>
</td></tr>
<tr><td><code id="sim_geno_+3A_n_draws">n_draws</code></td>
<td>
<p>Number of simulations to perform.</p>
</td></tr>
<tr><td><code id="sim_geno_+3A_error_prob">error_prob</code></td>
<td>
<p>Assumed genotyping error probability</p>
</td></tr>
<tr><td><code id="sim_geno_+3A_map_function">map_function</code></td>
<td>
<p>Character string indicating the map function to
use to convert genetic distances to recombination fractions.</p>
</td></tr>
<tr><td><code id="sim_geno_+3A_lowmem">lowmem</code></td>
<td>
<p>If <code>FALSE</code>, split individuals into groups with
common sex and crossinfo and then precalculate the transition
matrices for a chromosome; potentially a lot faster but using more
memory.</p>
</td></tr>
<tr><td><code id="sim_geno_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code>, print progress messages.</p>
</td></tr>
<tr><td><code id="sim_geno_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After performing the backward equations, we draw from
<code class="reqn">Pr(g_1 = v | O)</code> and then <code class="reqn">Pr(g_{k+1} = v |
   O, g_k = u)</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"sim_geno"</code>: a list of three-dimensional arrays of imputed genotypes,
individuals x positions x draws. Also contains three attributes:
</p>

<ul>
<li> <p><code>crosstype</code> - The cross type of the input <code>cross</code>.
</p>
</li>
<li> <p><code>is_x_chr</code> - Logical vector indicating whether chromosomes
are to be treated as the X chromosome or not, from input <code>cross</code>.
</p>
</li>
<li> <p><code>alleles</code> - Vector of allele codes, from input
<code>cross</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+cbind.sim_geno">cbind.sim_geno()</a></code>, <code><a href="#topic+rbind.sim_geno">rbind.sim_geno()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
map_w_pmar &lt;- insert_pseudomarkers(grav2$gmap, step=1)
draws &lt;- sim_geno(grav2, map_w_pmar, n_draws=4, error_prob=0.002)
</code></pre>

<hr>
<h2 id='smooth_gmap'>Smooth genetic map</h2><span id='topic+smooth_gmap'></span>

<h3>Description</h3>

<p>Smooth a genetic map by mixing it with a bit of constant
recombination (using a separate recombination rate for each
chromosome), to eliminate intervals that have exactly 0
recombination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_gmap(gmap, pmap, alpha = 0.02)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_gmap_+3A_gmap">gmap</code></td>
<td>
<p>Genetic map, as a list of numeric vectors; each vector gives marker
positions for a single chromosome.</p>
</td></tr>
<tr><td><code id="smooth_gmap_+3A_pmap">pmap</code></td>
<td>
<p>Physical map, as a list of numeric vectors; each vector gives marker
positions for a single chromosome, with the same chromosomes and markers as <code>gmap</code>.</p>
</td></tr>
<tr><td><code id="smooth_gmap_+3A_alpha">alpha</code></td>
<td>
<p>Proportion of mixture to take from constant recombination.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An interval of genetic length <code class="reqn">d_g</code> and physical
length <code class="reqn">d_p</code> is changed to have length
<code class="reqn">(1-\alpha)d_g + \alpha d_p r</code>
where <code class="reqn">r = L_g / L_p</code> is the chromosome-specific
recombination rate.
</p>


<h3>Value</h3>

<p>A genetic map like the input <code>gmap</code>, but smoothed by mixing
it with a proportion <code>alpha</code> of constant recombination on each
chromosome.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unsmooth_gmap">unsmooth_gmap()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))
gmap_adj &lt;- smooth_gmap(iron$gmap, iron$pmap)

</code></pre>

<hr>
<h2 id='subset_scan1'>Subset scan1 output</h2><span id='topic+subset_scan1'></span><span id='topic+subset.scan1'></span>

<h3>Description</h3>

<p>Subset the output of <code><a href="#topic+scan1">scan1()</a></code> by chromosome or column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_scan1(x, map = NULL, chr = NULL, lodcolumn = NULL, ...)

## S3 method for class 'scan1'
subset(x, map = NULL, chr = NULL, lodcolumn = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_scan1_+3A_x">x</code></td>
<td>
<p>An object of class <code>"scan1"</code> as returned by
<code><a href="#topic+scan1">scan1()</a></code>.</p>
</td></tr>
<tr><td><code id="subset_scan1_+3A_map">map</code></td>
<td>
<p>A list of vectors of marker positions, as produced by
<code><a href="#topic+insert_pseudomarkers">insert_pseudomarkers()</a></code>.</p>
</td></tr>
<tr><td><code id="subset_scan1_+3A_chr">chr</code></td>
<td>
<p>Vector of chromosomes.</p>
</td></tr>
<tr><td><code id="subset_scan1_+3A_lodcolumn">lodcolumn</code></td>
<td>
<p>Vector of integers or character strings indicating the LOD
score columns, either as a numeric indexes or column names.</p>
</td></tr>
<tr><td><code id="subset_scan1_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"scan1"</code>, like the input, but subset by chromosome and/or column. See <code><a href="#topic+scan1">scan1()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))

# insert pseudomarkers into map
map &lt;- insert_pseudomarkers(iron$gmap, step=1)

# calculate genotype probabilities
probs &lt;- calc_genoprob(iron, map, error_prob=0.002)

# grab phenotypes and covariates; ensure that covariates have names attribute
pheno &lt;- iron$pheno
covar &lt;- match(iron$covar$sex, c("f", "m")) # make numeric
names(covar) &lt;- rownames(iron$covar)
Xcovar &lt;- get_x_covar(iron)

# perform genome scan
out &lt;- scan1(probs, pheno, addcovar=covar, Xcovar=Xcovar)

# pull out chromosome 8
out_c8 &lt;- subset(out, map, chr="8")

# just the second column on chromosome 2
out_c2_spleen &lt;- subset(out, map, "2", "spleen")

# all positions, but just the "liver" column
out_spleen &lt;- subset(out, map, lodcolumn="spleen")
</code></pre>

<hr>
<h2 id='subset.calc_genoprob'>Subsetting genotype probabilities</h2><span id='topic+subset.calc_genoprob'></span><span id='topic++5B.calc_genoprob'></span>

<h3>Description</h3>

<p>Pull out a specified set of individuals and/or chromosomes from
the results of <code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calc_genoprob'
subset(x, ind = NULL, chr = NULL, ...)

## S3 method for class 'calc_genoprob'
x[ind = NULL, chr = NULL]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.calc_genoprob_+3A_x">x</code></td>
<td>
<p>Genotype probabilities as output from <code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.</p>
</td></tr>
<tr><td><code id="subset.calc_genoprob_+3A_ind">ind</code></td>
<td>
<p>A vector of individuals: numeric indices, logical
values, or character string IDs</p>
</td></tr>
<tr><td><code id="subset.calc_genoprob_+3A_chr">chr</code></td>
<td>
<p>A vector of chromosomes: logical values, or character
string IDs. Numbers are interpreted as character string IDs.</p>
</td></tr>
<tr><td><code id="subset.calc_genoprob_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"calc_genoprob"</code>, like the input, with the selected
individuals and/or chromsomes; see <code><a href="#topic+calc_genoprob">calc_genoprob()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))

pr &lt;- calc_genoprob(grav2)
# keep just individuals 1:5, chromosome 2
prsub &lt;- pr[1:5,2]
# keep just chromosome 2
prsub2 &lt;- pr[,2]
</code></pre>

<hr>
<h2 id='subset.cross2'>Subsetting data for a QTL experiment</h2><span id='topic+subset.cross2'></span><span id='topic++5B.cross2'></span>

<h3>Description</h3>

<p>Pull out a specified set of individuals and/or chromosomes from a
<code>cross2</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cross2'
subset(x, ind = NULL, chr = NULL, ...)

## S3 method for class 'cross2'
x[ind = NULL, chr = NULL]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.cross2_+3A_x">x</code></td>
<td>
<p>An object of class <code>"cross2"</code>, as output by <code><a href="#topic+read_cross2">read_cross2()</a></code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.</p>
</td></tr>
<tr><td><code id="subset.cross2_+3A_ind">ind</code></td>
<td>
<p>A vector of individuals: numeric indices, logical
values, or character string IDs.</p>
</td></tr>
<tr><td><code id="subset.cross2_+3A_chr">chr</code></td>
<td>
<p>A vector of chromosomes: numeric indices, logical
values, or character string IDs</p>
</td></tr>
<tr><td><code id="subset.cross2_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When subsetting by individual, if <code>ind</code> is numeric, they're
assumed to be numeric indices; if character strings, they're
assumed to be individual IDs. <code>ind</code> can be numeric or logical
only if the genotype, phenotype, and covariate data all have the
same individuals in the same order.
</p>
<p>When subsetting by chromosome, <code>chr</code> is <em>always</em>
converted to character strings and treated as chromosome IDs. So if
there are three chromosomes with IDs <code>"18"</code>, <code>"19"</code>, and
<code>"X"</code>, <code>mycross[,18]</code> will give the first of the
chromosomes (labeled <code>"18"</code>) and <code>mycross[,3]</code> will give
an error.
</p>
<p>When using character string IDs for <code>ind</code> or <code>chr</code>, you
can use &quot;negative&quot; subscripts to indicate exclusions, for example
<code>mycross[,c("-18", "-X")]</code> or <code>mycross["-Mouse2501",]</code>.
But you can't mix &quot;positive&quot; and &quot;negative&quot; subscripts, and if any
of the individuals has an ID that begins with <code>"-"</code>, you can't
use negative subscripts like this.
</p>


<h3>Value</h3>

<p>The input <code>cross2</code> object, with the selected
individuals and/or chromsomes.
</p>


<h3>Warning</h3>

<p>The order of the two arguments is reversed relative to the related
function in <a href="https://rqtl.org">R/qtl</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
# keep individuals 1-20 and chromosomes 3 and 4
grav2sub &lt;- grav2[1:20, c(3,4)]
# keep just chromosome 1
grav2_c1 &lt;- grav2[,1]
</code></pre>

<hr>
<h2 id='subset.sim_geno'>Subsetting imputed genotypes</h2><span id='topic+subset.sim_geno'></span><span id='topic++5B.sim_geno'></span>

<h3>Description</h3>

<p>Pull out a specified set of individuals and/or chromosomes from
the results of <code><a href="#topic+sim_geno">sim_geno()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sim_geno'
subset(x, ind = NULL, chr = NULL, ...)

## S3 method for class 'sim_geno'
x[ind = NULL, chr = NULL]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.sim_geno_+3A_x">x</code></td>
<td>
<p>Imputed genotypes as output from <code><a href="#topic+sim_geno">sim_geno()</a></code>.</p>
</td></tr>
<tr><td><code id="subset.sim_geno_+3A_ind">ind</code></td>
<td>
<p>A vector of individuals: numeric indices, logical
values, or character string IDs</p>
</td></tr>
<tr><td><code id="subset.sim_geno_+3A_chr">chr</code></td>
<td>
<p>A vector of chromosomes: logical values, or character
string IDs. Numbers are interpreted as character string IDs.</p>
</td></tr>
<tr><td><code id="subset.sim_geno_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"sim_geno"</code>, like the input
with the selected individuals and/or chromsomes; see <code><a href="#topic+sim_geno">sim_geno()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))

dr &lt;- sim_geno(grav2, n_draws=4)
# keep just individuals 1:5, chromosome 2
drsub &lt;- dr[1:5,2]
# keep just chromosome 2
drsub2 &lt;- dr[,2]
</code></pre>

<hr>
<h2 id='subset.viterbi'>Subsetting Viterbi results</h2><span id='topic+subset.viterbi'></span><span id='topic++5B.viterbi'></span>

<h3>Description</h3>

<p>Pull out a specified set of individuals and/or chromosomes from
the results of <code><a href="#topic+viterbi">viterbi()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'viterbi'
subset(x, ind = NULL, chr = NULL, ...)

## S3 method for class 'viterbi'
x[ind = NULL, chr = NULL]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.viterbi_+3A_x">x</code></td>
<td>
<p>Imputed genotypes as output from <code><a href="#topic+viterbi">viterbi()</a></code>.</p>
</td></tr>
<tr><td><code id="subset.viterbi_+3A_ind">ind</code></td>
<td>
<p>A vector of individuals: numeric indices, logical
values, or character string IDs</p>
</td></tr>
<tr><td><code id="subset.viterbi_+3A_chr">chr</code></td>
<td>
<p>A vector of chromosomes: logical values, or character
string IDs. Numbers are interpreted as character string IDs.</p>
</td></tr>
<tr><td><code id="subset.viterbi_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"viterbi"</code>, like the input, with the
selected individuals and/or chromosomes; see <code><a href="#topic+viterbi">viterbi()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))

g &lt;- viterbi(grav2)
# keep just individuals 1:5, chromosome 2
gsub &lt;- g[1:5,2]
# keep just chromosome 2
gsub2 &lt;- g[,2]
</code></pre>

<hr>
<h2 id='summary_compare_geno'>Basic summary of compare_geno object</h2><span id='topic+summary_compare_geno'></span><span id='topic+summary.compare_geno'></span><span id='topic+print.summary.compare_geno'></span>

<h3>Description</h3>

<p>From results of <code><a href="#topic+compare_geno">compare_geno()</a></code>, show pairs of individuals with similar genotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_compare_geno(object, threshold = 0.9, ...)

## S3 method for class 'compare_geno'
summary(object, threshold = 0.9, ...)

## S3 method for class 'summary.compare_geno'
print(x, digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_compare_geno_+3A_object">object</code></td>
<td>
<p>A square matrix with genotype comparisons for pairs
of individuals, as output by <code><a href="#topic+compare_geno">compare_geno()</a></code>.</p>
</td></tr>
<tr><td><code id="summary_compare_geno_+3A_threshold">threshold</code></td>
<td>
<p>Minimum proportion matches for a pair of individuals to be shown.</p>
</td></tr>
<tr><td><code id="summary_compare_geno_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="summary_compare_geno_+3A_x">x</code></td>
<td>
<p>Results of <code><a href="#topic+summary.compare_geno">summary.compare_geno()</a></code></p>
</td></tr>
<tr><td><code id="summary_compare_geno_+3A_digits">digits</code></td>
<td>
<p>Number of digits to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with names of individuals in pair, proportion
matches, number of mismatches, number of matches, and total
markers genotyped. Last two columns are the numeric indexes of
the individuals in the pair.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
cg &lt;- compare_geno(grav2)
summary(cg)
</code></pre>

<hr>
<h2 id='summary_scan1perm'>Summarize scan1perm results</h2><span id='topic+summary_scan1perm'></span><span id='topic+summary.scan1perm'></span>

<h3>Description</h3>

<p>Summarize permutation test results from <code><a href="#topic+scan1perm">scan1perm()</a></code>, as significance thresholds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_scan1perm(object, alpha = 0.05)

## S3 method for class 'scan1perm'
summary(object, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_scan1perm_+3A_object">object</code></td>
<td>
<p>An object of class <code>"scanoneperm"</code>, as output by <code><a href="#topic+scan1perm">scan1perm()</a></code></p>
</td></tr>
<tr><td><code id="summary_scan1perm_+3A_alpha">alpha</code></td>
<td>
<p>Vector of significance levels</p>
</td></tr>
<tr><td><code id="summary_scan1perm_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the case of X-chromosome-specific permutations (when
<code><a href="#topic+scan1perm">scan1perm()</a></code> was run with <code>perm_Xsp=TRUE</code>, we
follow the approach of Broman et al. (2006) to get separate
thresholds for the autosomes and X chromosome, using
</p>
<p>Let <code class="reqn">L_A</code> and <code class="reqn">L_X</code> be total the genetic lengths of the
autosomes and X chromosome, respectively, and let <code class="reqn">L_T = L_A +
L_X</code> Then in place of <code class="reqn">\alpha</code>, we use </p>
<p style="text-align: center;"><code class="reqn">\alpha_A =
1 - (1-\alpha)^{L_A/L_T}</code>
</p>
<p> as
the significance level for the autosomes and </p>
<p style="text-align: center;"><code class="reqn">\alpha_X = 1 -
(1-\alpha)^{L_X/L_T}</code>
</p>
<p> as the
significance level for the X chromosome.
</p>


<h3>Value</h3>

<p>An object of class <code>summary.scan1perm</code>. If
<code><a href="#topic+scan1perm">scan1perm()</a></code> was run with <code>perm_Xsp=FALSE</code>, this is
a single matrix of significance thresholds, with rows being
signicance levels and columns being the columns in the input. If
<code><a href="#topic+scan1perm">scan1perm()</a></code> was run with <code>perm_Xsp=TRUE</code>, this is
a list of two matrices, with the significance thresholds for the
autosomes and X chromosome, respectively.
</p>
<p>The result has an attribute <code>"n_perm"</code> that has the numbers of
permutation replicates (either a matrix or a list of two matrices).
</p>


<h3>References</h3>

<p>Broman KW, Sen , Owens SE, Manichaikul A, Southard-Smith EM,
Churchill GA (2006) The X chromosome in quantitative trait locus
mapping. Genetics 174:2151-2158
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))


# insert pseudomarkers into map
map &lt;- insert_pseudomarkers(iron$gmap, step=1)

# calculate genotype probabilities
probs &lt;- calc_genoprob(iron, map, error_prob=0.002)

# grab phenotypes and covariates; ensure that covariates have names attribute
pheno &lt;- iron$pheno
covar &lt;- match(iron$covar$sex, c("f", "m")) # make numeric
names(covar) &lt;- rownames(iron$covar)
Xcovar &lt;- get_x_covar(iron)

# permutations with genome scan (just 3 replicates, for illustration)
operm &lt;- scan1perm(probs, pheno, addcovar=covar, Xcovar=Xcovar,
                   n_perm=3)

summary(operm, alpha=c(0.20, 0.05))

</code></pre>

<hr>
<h2 id='summary.cross2'>Summary of cross2 object</h2><span id='topic+summary.cross2'></span>

<h3>Description</h3>

<p>Summarize a cross2 object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cross2'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cross2_+3A_object">object</code></td>
<td>
<p>An object of class <code>"cross2"</code>, as output by <code><a href="#topic+read_cross2">read_cross2()</a></code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.</p>
</td></tr>
<tr><td><code id="summary.cross2_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>See Also</h3>

<p><a href="#topic+basic_summaries">basic_summaries</a>
</p>

<hr>
<h2 id='top_snps'>Create table of top snp associations</h2><span id='topic+top_snps'></span>

<h3>Description</h3>

<p>Create a table of the top snp associations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>top_snps(
  scan1_output,
  snpinfo,
  lodcolumn = 1,
  chr = NULL,
  drop = 1.5,
  show_all_snps = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="top_snps_+3A_scan1_output">scan1_output</code></td>
<td>
<p>Output of <code><a href="#topic+scan1">scan1()</a></code>.
Should contain a component <code>"snpinfo"</code>, as when
<code><a href="#topic+scan1">scan1()</a></code> is run with SNP probabilities
produced by <code><a href="#topic+genoprob_to_snpprob">genoprob_to_snpprob()</a></code>.</p>
</td></tr>
<tr><td><code id="top_snps_+3A_snpinfo">snpinfo</code></td>
<td>
<p>Data frame with SNP information with the following
columns (the last three are generally derived with
<code><a href="#topic+index_snps">index_snps()</a></code>):
</p>

<ul>
<li> <p><code>chr</code> - Character string or factor with chromosome
</p>
</li>
<li> <p><code>pos</code> - Position (in same units as in the <code>"map"</code>
attribute in <code>genoprobs</code>.
</p>
</li>
<li> <p><code>sdp</code> - Strain distribution pattern: an integer, between
1 and <code class="reqn">2^n - 2</code> where <code class="reqn">n</code> is the number of strains, whose
binary encoding indicates the founder genotypes
</p>
</li>
<li> <p><code>snp</code> - Character string with SNP identifier (if
missing, the rownames are used).
</p>
</li>
<li> <p><code>index</code> - Indices that indicate equivalent
groups of SNPs, calculated by <code><a href="#topic+index_snps">index_snps()</a></code>.
</p>
</li>
<li> <p><code>intervals</code> - Indexes that indicate which marker
intervals the SNPs reside.
</p>
</li>
<li> <p><code>on_map</code> - Indicate whether SNP coincides with a marker
in the <code>genoprobs</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="top_snps_+3A_lodcolumn">lodcolumn</code></td>
<td>
<p>Selected LOD score column to (a numeric index, or a
character string for a column name). Only one value allowed.</p>
</td></tr>
<tr><td><code id="top_snps_+3A_chr">chr</code></td>
<td>
<p>Selected chromosome; only one value allowed.</p>
</td></tr>
<tr><td><code id="top_snps_+3A_drop">drop</code></td>
<td>
<p>Show all SNPs with LOD score within this amount of the
maximum SNP association.</p>
</td></tr>
<tr><td><code id="top_snps_+3A_show_all_snps">show_all_snps</code></td>
<td>
<p>If TRUE, expand to show all SNPs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame like the input <code>snpinfo</code> with just the selected
subset of rows, and with an added column with the LOD score.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+index_snps">index_snps()</a></code>, <code><a href="#topic+genoprob_to_snpprob">genoprob_to_snpprob()</a></code>, <code><a href="#topic+scan1snps">scan1snps()</a></code>, <code><a href="#topic+plot_snpasso">plot_snpasso()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example DO data from web
file &lt;- paste0("https://raw.githubusercontent.com/rqtl/",
               "qtl2data/main/DOex/DOex.zip")
DOex &lt;- read_cross2(file)

# subset to chr 2
DOex &lt;- DOex[,"2"]

# calculate genotype probabilities and convert to allele probabilities
pr &lt;- calc_genoprob(DOex, error_prob=0.002)
apr &lt;- genoprob_to_alleleprob(pr)

# query function for grabbing info about variants in region
dbfile &lt;- system.file("extdata", "cc_variants_small.sqlite", package="qtl2")
query_variants &lt;- create_variant_query_func(dbfile)

# SNP association scan, keep information on all SNPs
out_snps &lt;- scan1snps(apr, DOex$pmap, DOex$pheno, query_func=query_variants,
                      chr=2, start=97, end=98, keep_all_snps=TRUE)

# table with top SNPs
top_snps(out_snps$lod, out_snps$snpinfo)

# top SNPs among the distinct subset at which calculations were performed
top_snps(out_snps$lod, out_snps$snpinfo, show_all_snps=FALSE)

# top SNPs within 0.5 LOD of max
top_snps(out_snps$lod, out_snps$snpinfo, drop=0.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='unsmooth_gmap'>Unsmooth genetic map</h2><span id='topic+unsmooth_gmap'></span>

<h3>Description</h3>

<p>Performs the reverse operation of <code><a href="#topic+smooth_gmap">smooth_gmap()</a></code>, in case one wants to go back
to the original genetic map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unsmooth_gmap(gmap, pmap, alpha = 0.02)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unsmooth_gmap_+3A_gmap">gmap</code></td>
<td>
<p>Genetic map, as a list of numeric vectors; each vector gives marker
positions for a single chromosome.</p>
</td></tr>
<tr><td><code id="unsmooth_gmap_+3A_pmap">pmap</code></td>
<td>
<p>Physical map, as a list of numeric vectors; each vector gives marker
positions for a single chromosome, with the same chromosomes and markers as <code>gmap</code>.</p>
</td></tr>
<tr><td><code id="unsmooth_gmap_+3A_alpha">alpha</code></td>
<td>
<p>Proportion of mixture to take from constant recombination.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An interval of genetic length <code class="reqn">d_g</code> and physical
length <code class="reqn">d_p</code> is changed to have length
<code class="reqn">(d_g - \alpha d_p r)/(1-\alpha)</code>
where <code class="reqn">r = L_g / L_p</code> is the chromosome-specific
recombination rate.
</p>


<h3>Value</h3>

<p>A genetic map like the input <code>gmap</code>, but with the reverse
operation of <code><a href="#topic+smooth_gmap">smooth_gmap()</a></code> applied, provided that exactly the
same physical map and <code>alpha</code> are used.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth_gmap">smooth_gmap()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))
gmap_adj &lt;- smooth_gmap(iron$gmap, iron$pmap)
gmap_back &lt;- unsmooth_gmap(gmap_adj, iron$pmap)

</code></pre>

<hr>
<h2 id='viterbi'>Calculate most probable sequence of genotypes</h2><span id='topic+viterbi'></span>

<h3>Description</h3>

<p>Uses a hidden Markov model to calculate arg max Pr(g | O) where g
is the underlying sequence of true genotypes and O is the observed
multipoint marker data, with possible allowance for genotyping
errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viterbi(
  cross,
  map = NULL,
  error_prob = 0.0001,
  map_function = c("haldane", "kosambi", "c-f", "morgan"),
  lowmem = FALSE,
  quiet = TRUE,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="viterbi_+3A_cross">cross</code></td>
<td>
<p>Object of class <code>"cross2"</code>. For details, see the
<a href="https://kbroman.org/qtl2/assets/vignettes/developer_guide.html">R/qtl2 developer guide</a>.</p>
</td></tr>
<tr><td><code id="viterbi_+3A_map">map</code></td>
<td>
<p>Genetic map of markers. May include pseudomarker
locations (that is, locations that are not within the marker
genotype data). If NULL, the genetic map in <code>cross</code> is used.</p>
</td></tr>
<tr><td><code id="viterbi_+3A_error_prob">error_prob</code></td>
<td>
<p>Assumed genotyping error probability</p>
</td></tr>
<tr><td><code id="viterbi_+3A_map_function">map_function</code></td>
<td>
<p>Character string indicating the map function to
use to convert genetic distances to recombination fractions.</p>
</td></tr>
<tr><td><code id="viterbi_+3A_lowmem">lowmem</code></td>
<td>
<p>If <code>FALSE</code>, split individuals into groups with
common sex and crossinfo and then precalculate the transition
matrices for a chromosome; potentially a lot faster but using more
memory.</p>
</td></tr>
<tr><td><code id="viterbi_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code>, print progress messages.</p>
</td></tr>
<tr><td><code id="viterbi_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use, for parallel calculations.
(If <code>0</code>, use <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>.)
Alternatively, this can be links to a set of cluster sockets, as
produced by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We use a hidden Markov model to find, for each individual
on each chromosome, the most probable sequence of underlying
genotypes given the observed marker data.
</p>
<p>Note that we break ties at random, and our method for doing this
may introduce some bias.
</p>
<p>Consider the results with caution; the most probable sequence can
have very low probability, and can have features that are quite
unusual (for example, the number of recombination events can be too
small). In most cases, the results of a single imputation with
<code><a href="#topic+sim_geno">sim_geno()</a></code> will be more realistic.
</p>


<h3>Value</h3>

<p>An object of class <code>"viterbi"</code>: a list of two-dimensional
arrays of imputed genotypes, individuals x positions.
Also contains three attributes:
</p>

<ul>
<li> <p><code>crosstype</code> - The cross type of the input <code>cross</code>.
</p>
</li>
<li> <p><code>is_x_chr</code> - Logical vector indicating whether chromosomes
are to be treated as the X chromosome or not, from input <code>cross</code>.
</p>
</li>
<li> <p><code>alleles</code> - Vector of allele codes, from input
<code>cross</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+sim_geno">sim_geno()</a></code>, <code><a href="#topic+maxmarg">maxmarg()</a></code>, <code><a href="#topic+cbind.viterbi">cbind.viterbi()</a></code>, <code><a href="#topic+rbind.viterbi">rbind.viterbi()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grav2 &lt;- read_cross2(system.file("extdata", "grav2.zip", package="qtl2"))
map_w_pmar &lt;- insert_pseudomarkers(grav2$gmap, step=1)
g &lt;- viterbi(grav2, map_w_pmar, error_prob=0.002)
</code></pre>

<hr>
<h2 id='write_control_file'>Write a control file for QTL data</h2><span id='topic+write_control_file'></span>

<h3>Description</h3>

<p>Write the control file (in <a href="https://yaml.org">YAML</a> or <a href="https://json.org">JSON</a>) needed
by <code><a href="#topic+read_cross2">read_cross2()</a></code> for a set of QTL data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_control_file(
  output_file,
  crosstype = NULL,
  geno_file = NULL,
  founder_geno_file = NULL,
  gmap_file = NULL,
  pmap_file = NULL,
  pheno_file = NULL,
  covar_file = NULL,
  phenocovar_file = NULL,
  sex_file = NULL,
  sex_covar = NULL,
  sex_codes = NULL,
  crossinfo_file = NULL,
  crossinfo_covar = NULL,
  crossinfo_codes = NULL,
  geno_codes = NULL,
  alleles = NULL,
  xchr = NULL,
  sep = ",",
  na.strings = c("-", "NA"),
  comment.char = "#",
  geno_transposed = FALSE,
  founder_geno_transposed = FALSE,
  pheno_transposed = FALSE,
  covar_transposed = FALSE,
  phenocovar_transposed = FALSE,
  description = NULL,
  comments = NULL,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_control_file_+3A_output_file">output_file</code></td>
<td>
<p>File name (with path) of the
<a href="https://yaml.org">YAML</a> or <a href="https://json.org">JSON</a> file to be created, as a character
string. If extension is <code>.json</code>, JSON format is used; otherwise, YAML is used.</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_crosstype">crosstype</code></td>
<td>
<p>Character string with the cross type.</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_geno_file">geno_file</code></td>
<td>
<p>File name for genotype data.</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_founder_geno_file">founder_geno_file</code></td>
<td>
<p>File name for the founder genotype data.</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_gmap_file">gmap_file</code></td>
<td>
<p>File name for genetic map.</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_pmap_file">pmap_file</code></td>
<td>
<p>File name for the physical map.</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_pheno_file">pheno_file</code></td>
<td>
<p>File name for the phenotype data.</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_covar_file">covar_file</code></td>
<td>
<p>File name for the covariate data.</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_phenocovar_file">phenocovar_file</code></td>
<td>
<p>File name for the phenotype covariate data
(i.e., metadata about the phenotypes).</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_sex_file">sex_file</code></td>
<td>
<p>File name for the individuals' sex. (Specify just
one of <code>sex_file</code> or <code>sex_covar</code>.)</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_sex_covar">sex_covar</code></td>
<td>
<p>Column name in the covariate data that corresponds
to sex. (Specify just one of <code>sex_file</code> or <code>sex_covar</code>.)</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_sex_codes">sex_codes</code></td>
<td>
<p>Named vector of character strings specifying the
encoding of sex. The names attribute should be the codes used in
the data files; the values within the vector should be
<code>"female"</code> and <code>"male"</code>.</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_crossinfo_file">crossinfo_file</code></td>
<td>
<p>File name for the <code>cross_info</code> data. (Specify just
one of <code>crossinfo_file</code> or <code>crossinfo_covar</code>.)</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_crossinfo_covar">crossinfo_covar</code></td>
<td>
<p>Column name in the covariate data that
corresponds to the <code>cross_info</code> data. (Specify just one of
<code>crossinfo_file</code> or <code>crossinfo_covar</code>.)</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_crossinfo_codes">crossinfo_codes</code></td>
<td>
<p>In the case that there is a single cross
info column (whether in a file or as a covariate), you can
provide a named vector of character strings specifying the
encoding of <code>cross_info</code>. The names attribute should be the
codes used; the values within the vector should be the codes to
which they will be converted (for example, <code>0</code> and <code>1</code> for an
intercross).</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_geno_codes">geno_codes</code></td>
<td>
<p>Named vector specifying the encoding of
genotypes. The names attribute has the codes used within the
genotype and founder genotype data files; the values within the
vector should be the integers to which the genotypes will be
converted.</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_alleles">alleles</code></td>
<td>
<p>Vector of single-character codes for the founder
alleles.</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_xchr">xchr</code></td>
<td>
<p>Character string with the ID for the X chromosome.</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_sep">sep</code></td>
<td>
<p>Character string that separates columns in the data files.</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_na.strings">na.strings</code></td>
<td>
<p>Vector of character strings with codes to be
treated as missing values.</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_comment.char">comment.char</code></td>
<td>
<p>Character string that is used as initial
character in a set of leading comment lines in the data files.</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_geno_transposed">geno_transposed</code></td>
<td>
<p>If TRUE, genotype file is transposed (with markers as rows).</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_founder_geno_transposed">founder_geno_transposed</code></td>
<td>
<p>If TRUE, founder genotype file is transposed (with markers as rows).</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_pheno_transposed">pheno_transposed</code></td>
<td>
<p>If TRUE, phenotype file is transposed (with phenotypes as rows).</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_covar_transposed">covar_transposed</code></td>
<td>
<p>If TRUE, covariate file is transposed (with covariates as rows).</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_phenocovar_transposed">phenocovar_transposed</code></td>
<td>
<p>If TRUE, phenotype covariate file is transposed (with phenotype covariates as rows).</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_description">description</code></td>
<td>
<p>Optional character string describing the data.</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_comments">comments</code></td>
<td>
<p>Vector of character strings to be inserted as
comments at the top of the file (in the case of YAML), with each
string as a line. For JSON, the comments are instead included
within the control object.</p>
</td></tr>
<tr><td><code id="write_control_file_+3A_overwrite">overwrite</code></td>
<td>
<p>If TRUE, overwrite file if it exists. If FALSE
(the default) and the file exists, stop with an error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a set of parameters and creates the
control file (in <a href="https://yaml.org">YAML</a> or <a href="https://json.org">JSON</a> format) needed
for the new input data file format for
<a href="https://kbroman.org/qtl2/">R/qtl2</a>.  See the
<a href="https://kbroman.org/qtl2/pages/sampledata.html">sample data files</a> and the
<a href="https://kbroman.org/qtl2/assets/vignettes/input_files.html">vignette describing the input file format</a>.
</p>


<h3>Value</h3>

<p>(Invisibly) The data structure that was written.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_cross2">read_cross2()</a></code>, sample data files at
<a href="https://kbroman.org/qtl2/pages/sampledata.html">https://kbroman.org/qtl2/pages/sampledata.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Control file for the sample dataset, grav2
grav2_control_file &lt;- file.path(tempdir(), "grav2.yaml")
write_control_file(grav2_control_file,
                   crosstype="riself",
                   geno_file="grav2_geno.csv",
                   gmap_file="grav2_gmap.csv",
                   pheno_file="grav2_pheno.csv",
                   phenocovar_file="grav2_phenocovar.csv",
                   geno_codes=c(L=1L, C=2L),
                   alleles=c("L", "C"),
                   na.strings=c("-", "NA"))

# Control file for the sample dataset, iron
iron_control_file &lt;- file.path(tempdir(), "iron.yaml")
write_control_file(iron_control_file,
                   crosstype="f2",
                   geno_file="iron_geno.csv",
                   gmap_file="iron_gmap.csv",
                   pheno_file="iron_pheno.csv",
                   covar_file="iron_covar.csv",
                   phenocovar_file="iron_phenocovar.csv",
                   geno_codes=c(SS=1L, SB=2L, BB=3L),
                   sex_covar="sex",
                   sex_codes=c(f="female", m="male"),
                   crossinfo_covar="cross_direction",
                   crossinfo_codes=c("(SxB)x(SxB)"=0L, "(BxS)x(BxS)"=1L),
                   xchr="X",
                   alleles=c("S", "B"),
                   na.strings=c("-", "NA"))

# Remove these files, to clean up temporary directory
unlink(c(grav2_control_file, iron_control_file))
</code></pre>

<hr>
<h2 id='xpos_scan1'>Get x-axis position for genomic location</h2><span id='topic+xpos_scan1'></span>

<h3>Description</h3>

<p>For a plot of <code><a href="#topic+scan1">scan1()</a></code> results, get the x-axis
location that corresponds to a particular genomic location
(chromosome ID and position).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xpos_scan1(map, chr = NULL, gap = NULL, thechr, thepos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xpos_scan1_+3A_map">map</code></td>
<td>
<p>A list of vectors of marker positions, as produced by
<code><a href="#topic+insert_pseudomarkers">insert_pseudomarkers()</a></code>.</p>
</td></tr>
<tr><td><code id="xpos_scan1_+3A_chr">chr</code></td>
<td>
<p>Selected chromosomes that were plotted (if used in the
call to <code><a href="#topic+plot_scan1">plot_scan1()</a></code>.</p>
</td></tr>
<tr><td><code id="xpos_scan1_+3A_gap">gap</code></td>
<td>
<p>The gap between chromosomes used in the call to
<code><a href="#topic+plot_scan1">plot_scan1()</a></code>.</p>
</td></tr>
<tr><td><code id="xpos_scan1_+3A_thechr">thechr</code></td>
<td>
<p>Vector of chromosome IDs</p>
</td></tr>
<tr><td><code id="xpos_scan1_+3A_thepos">thepos</code></td>
<td>
<p>Vector of chromosomal positions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>thechr</code> and <code>thepos</code> should be the same length,
or should have length 1 (in which case they are expanded to the
length of the other vector).
</p>


<h3>Value</h3>

<p>A vector of x-axis locations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># read data
iron &lt;- read_cross2(system.file("extdata", "iron.zip", package="qtl2"))

# insert pseudomarkers into map
map &lt;- insert_pseudomarkers(iron$gmap, step=1)

# calculate genotype probabilities
probs &lt;- calc_genoprob(iron, map, error_prob=0.002)

# grab phenotypes and covariates; ensure that covariates have names attribute
pheno &lt;- iron$pheno
covar &lt;- match(iron$covar$sex, c("f", "m")) # make numeric
names(covar) &lt;- rownames(iron$covar)
Xcovar &lt;- get_x_covar(iron)

# perform genome scan
out &lt;- scan1(probs, pheno, addcovar=covar, Xcovar=Xcovar)

# plot the results for selected chromosomes
ylim &lt;- c(0, maxlod(out)*1.02) # need to strip class to get overall max LOD
chr &lt;- c(2,7,8,9,15,16)
plot(out, map, chr=chr, ylim=ylim)
plot(out, map, lodcolumn=2, chr=chr, col="violetred", add=TRUE)
legend("topleft", lwd=2, col=c("darkslateblue", "violetred"), colnames(out),
       bg="gray90")

# Use xpos_scan1 to add points at the peaks
# first find the peaks with LOD &gt; 3
peaks &lt;- find_peaks(out, map)

# keep just the peaks for chromosomes that were plotted
peaks &lt;- peaks[peaks$chr %in% chr,]

# find x-axis positions
xpos &lt;- xpos_scan1(map, chr=chr, thechr=peaks$chr, thepos=peaks$pos)

# point colors
ptcolor &lt;- c("darkslateblue", "violetred")[match(peaks$lodcolumn, c("liver", "spleen"))]

# plot points
points(xpos, peaks$lod, pch=21, bg=ptcolor)
</code></pre>

<hr>
<h2 id='zip_datafiles'>Zip a set of data files</h2><span id='topic+zip_datafiles'></span>

<h3>Description</h3>

<p>Zip a set of data files (in format read by <code><a href="#topic+read_cross2">read_cross2()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zip_datafiles(control_file, zip_file = NULL, overwrite = FALSE, quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zip_datafiles_+3A_control_file">control_file</code></td>
<td>
<p>Character string with path to the control file
(<a href="https://yaml.org">YAML</a> or <a href="https://json.org">JSON</a>)
containing all of the control information.</p>
</td></tr>
<tr><td><code id="zip_datafiles_+3A_zip_file">zip_file</code></td>
<td>
<p>Name of zip file to use. If NULL, we use the
stem of <code>control_file</code> but with a <code>.zip</code> extension.</p>
</td></tr>
<tr><td><code id="zip_datafiles_+3A_overwrite">overwrite</code></td>
<td>
<p>If <code>TRUE</code>, overwrite file if it exists. If <code>FALSE</code>
(the default) and the file exists, stop with an error.</p>
</td></tr>
<tr><td><code id="zip_datafiles_+3A_quiet">quiet</code></td>
<td>
<p>If <code>FALSE</code>, print progress messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input <code>control_file</code> is the control file (in
<a href="https://yaml.org">YAML</a> or <a href="https://json.org">JSON</a> format)
to be read by <code><a href="#topic+read_cross2">read_cross2()</a></code>.  (See the
<a href="https://kbroman.org/qtl2/pages/sampledata.html">sample data files</a> and the
<a href="https://kbroman.org/qtl2/assets/vignettes/input_files.html">vignette describing the input file format</a>.)
</p>
<p>The <code><a href="utils.html#topic+zip">utils::zip()</a></code> function is used to do the zipping.
</p>
<p>The files should all be contained within the directory where the
<code>control_file</code> sits, or in a subdirectory of that directory.
If file paths use <code>..</code>, these get stripped by zip, and so the
resulting zip file may not work with <code><a href="#topic+read_cross2">read_cross2()</a></code>.
</p>


<h3>Value</h3>

<p>Character string with the file name of the zip file that
was created.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_cross2">read_cross2()</a></code>, sample data files at <a href="https://kbroman.org/qtl2/pages/sampledata.html">https://kbroman.org/qtl2/pages/sampledata.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
zipfile &lt;- file.path(tempdir(), "grav2.zip")
zip_datafiles("grav2.yaml", zipfile)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
