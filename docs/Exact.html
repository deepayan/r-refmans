<!DOCTYPE html><html lang="en"><head><title>Help for package Exact</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Exact}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Exact-package'><p>Unconditional Exact Tests R Package</p></a></li>
<li><a href='#exact.reject.region'><p>Rejection Region for 2x2 Tables with Independent Samples</p></a></li>
<li><a href='#exact.test'><p>Unconditional Exact Tests for 2x2 Tables with Independent Samples</p></a></li>
<li><a href='#paired.exact.test'><p>Unconditional Exact Tests for 2x2 Tables with Paired Samples</p></a></li>
<li><a href='#paired.reject.region'><p>Rejection Region for 2x2 Tables with Paired Samples</p></a></li>
<li><a href='#power.exact.test'><p>Power Calculations for 2x2 Tables with Independent Samples</p></a></li>
<li><a href='#power.paired.test'><p>Power Calculations for 2x2 Tables with Paired Samples</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Unconditional Exact Test</td>
</tr>
<tr>
<td>Version:</td>
<td>3.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Calhoun [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Calhoun &lt;calhoun.peter@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs unconditional exact tests and power calculations for 2x2 contingency tables.
  For comparing two independent proportions, performs Barnard's test (1945)
  &lt;<a href="https://doi.org/10.1038%2F156177a0">doi:10.1038/156177a0</a>&gt; using the original CSM test (Barnard, 1947 &lt;<a href="https://doi.org/10.1093%2Fbiomet%2F34.1-2.123">doi:10.1093/biomet/34.1-2.123</a>&gt;),
  using Fisher's p-value referred to as Boschloo's test (1970) &lt;<a href="https://doi.org/10.1111%2Fj.1467-9574.1970.tb00104.x">doi:10.1111/j.1467-9574.1970.tb00104.x</a>&gt;,
  or using a Z-statistic (Suissa and Shuster, 1985, &lt;<a href="https://doi.org/10.2307%2F2981892">doi:10.2307/2981892</a>&gt;).
  For comparing two binary proportions, performs unconditional exact test using McNemar's
  Z-statistic (Berger and Sidik, 2003, &lt;<a href="https://doi.org/10.1191%2F0962280203sm312ra">doi:10.1191/0962280203sm312ra</a>&gt;),
  using McNemar's conditional p-value, using McNemar's Z-statistic with continuity correction,
  or using CSM test.  Calculates confidence intervals for the difference in proportion.
  This package interacts with pre-computed data available through the ExactData R package,
  which is available in a 'drat' repository.
  Install the ExactData R package from GitHub at <a href="https://pcalhoun1.github.io/drat/">https://pcalhoun1.github.io/drat/</a>.
  The ExactData R package is approximately 85 MB.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, utils, rootSolve</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ExactData</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://pcalhoun1.github.io/drat">https://pcalhoun1.github.io/drat</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-21 00:26:38 UTC; pcalh</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-21 06:50:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='Exact-package'>Unconditional Exact Tests R Package</h2><span id='topic+Exact'></span><span id='topic+binom.CI'></span><span id='topic+checkPairedParam'></span><span id='topic+checkParam'></span><span id='topic+chisq_TX'></span><span id='topic+confInt'></span><span id='topic+confIntPaired'></span><span id='topic+convertMethod'></span><span id='topic+csmPairedTemp'></span><span id='topic+csmPairedTemp2sidedDelta'></span><span id='topic+csmTemp'></span><span id='topic+csmTemp2sidedDelta'></span><span id='topic+dbinomCalc'></span><span id='topic+discordant.CI'></span><span id='topic+fisher.2x2'></span><span id='topic+lowerMatVal'></span><span id='topic+maxPvalue'></span><span id='topic+maxPvalueLookup'></span><span id='topic+maxPvaluePaired'></span><span id='topic+maxPvaluePairedLookup'></span><span id='topic+maxPvalueMultinom'></span><span id='topic+mcnemar.2x2'></span><span id='topic+mcnemar_TX'></span><span id='topic+methodText'></span><span id='topic+moreExtreme'></span><span id='topic+moreExtremeCSM'></span><span id='topic+moreExtremePaired'></span><span id='topic+moreExtremePairedCSM'></span><span id='topic+multinom'></span><span id='topic+pairedMethodText'></span><span id='topic+santner_TX'></span><span id='topic+searchExtreme'></span><span id='topic+searchExtremePaired'></span><span id='topic+trinom'></span><span id='topic+trinomCalc'></span><span id='topic+updateMat'></span><span id='topic+zpooled_TX'></span><span id='topic+zunpooled_TX'></span>

<h3>Description</h3>

<p>This package performs unconditional exact tests using <code><a href="#topic+exact.test">exact.test</a></code> for independent samples or <code><a href="#topic+paired.exact.test">paired.exact.test</a></code> function for paired samples.  The unconditional exact tests for independent samples are referred to as Barnard's (1945, 1947) test and also extended to test two paired proportions.  This package also includes the <code><a href="#topic+power.exact.test">power.exact.test</a></code> and <code><a href="#topic+power.paired.test">power.paired.test</a></code> functions to calculate the power of various tests and the <code><a href="#topic+exact.reject.region">exact.reject.region</a></code> and <code><a href="#topic+paired.reject.region">paired.reject.region</a></code> functions to determine the rejection region of a test.
</p>


<h3>Details</h3>

<p>Unconditional exact tests are a more powerful alternative than conditional exact tests.  This package can compute p-values, confidence intervals, and power calculations for various tests.  Details of the tests are given in the <code><a href="#topic+exact.test">exact.test</a></code> documentation for independent samples and <code><a href="#topic+paired.exact.test">paired.exact.test</a></code> documentation for paired samples.
</p>


<h3>Note</h3>

<p>Thoughout the years I have received help while creating this package. 
Special thanks goes to Philo Calhoun, Tal Galili, Kamil Erguler, Roger Berger, Karl Hufthammer, and the R community.
</p>


<h3>Author(s)</h3>

<p>Peter Calhoun [aut, cre]
</p>
<p>Maintainer: Peter Calhoun &lt;calhoun.peter@gmail.com&gt;
</p>


<h3>References</h3>

<p>Barnard, G.A. (1945) A new test for 2x2 tables. <em>Nature</em>, <b>156</b>, 177
</p>
<p>Barnard, G.A. (1947) Significance tests for 2x2 tables. <em>Biometrika</em>, <b>34</b>, 123&ndash;138
</p>
<p>Boschloo, R. D. (1970), Raised Conditional Level of Significance for the 2x2-table when Testing the Equality of Two Probabilities. <em>Statistica Neerlandica</em>, <b>24</b>, 1&ndash;35
</p>
<p>Berger, R.L. and Sidik, K. (2003) Exact unconditional tests for 2 x 2 matched-pairs design. <em>Statistical Methods in Medical Research</em>, <b>12</b>, 91&ndash;108
</p>
<p>Hsueh, H., Liu, J., and Chen, J.J. (2001) Unconditional exact tests for equivalence or noninferiority for paired binary endpoints. <em>Biometrics</em>, <b>57</b>, 478&ndash;483
</p>

<hr>
<h2 id='exact.reject.region'>Rejection Region for 2x2 Tables with Independent Samples</h2><span id='topic+exact.reject.region'></span>

<h3>Description</h3>

<p>Determines the rejection region for comparing two independent proportions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>exact.reject.region(n1, n2, alternative = c("two.sided", "less", "greater"),
    alpha = 0.05, npNumbers = 100, np.interval = FALSE, beta = 0.001,
    method = c("z-pooled", "z-unpooled", "boschloo", "santner and snell",
               "csm", "fisher", "pearson chisq", "yates chisq"),
    tsmethod = c("square", "central"), delta = 0, convexity = TRUE,
    useStoredCSM = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exact.reject.region_+3A_n1">n1</code></td>
<td>
<p>The sample size in first group</p>
</td></tr>
<tr><td><code id="exact.reject.region_+3A_n2">n2</code></td>
<td>
<p>The sample size in second group</p>
</td></tr>
<tr><td><code id="exact.reject.region_+3A_alternative">alternative</code></td>
<td>
<p>Indicates the alternative hypothesis: must be either &quot;two.sided&quot;, &quot;less&quot;, or &quot;greater&quot;</p>
</td></tr>
<tr><td><code id="exact.reject.region_+3A_alpha">alpha</code></td>
<td>
<p>Significance level</p>
</td></tr>
<tr><td><code id="exact.reject.region_+3A_npnumbers">npNumbers</code></td>
<td>
<p>Number: The number of nuisance parameters considered</p>
</td></tr>
<tr><td><code id="exact.reject.region_+3A_np.interval">np.interval</code></td>
<td>
<p>Logical: Indicates if a confidence interval on the nuisance parameter should be computed</p>
</td></tr>
<tr><td><code id="exact.reject.region_+3A_beta">beta</code></td>
<td>
<p>Number: Confidence level for constructing the interval of nuisance parameters considered.  Only used if np.interval=TRUE</p>
</td></tr>
<tr><td><code id="exact.reject.region_+3A_method">method</code></td>
<td>

<p>Indicates the method for finding the more extreme tables:
must be either &quot;Z-pooled&quot;, &quot;Z-unpooled&quot;, &quot;Santner and Snell&quot;, &quot;Boschloo&quot;, &quot;CSM&quot;, &quot;Fisher&quot;, &quot;Pearson Chisq&quot;, or &quot;Yates Chisq&quot;</p>
</td></tr>
<tr><td><code id="exact.reject.region_+3A_tsmethod">tsmethod</code></td>
<td>
<p>Indicates two-sided method: must be either &quot;square&quot; or &quot;central&quot;</p>
</td></tr>
<tr><td><code id="exact.reject.region_+3A_delta">delta</code></td>
<td>
<p>Number: null hypothesis of the difference in proportion</p>
</td></tr>
<tr><td><code id="exact.reject.region_+3A_convexity">convexity</code></td>
<td>
<p>Logical: assumes convexity for interval approach.  Only used if np.interval=TRUE</p>
</td></tr>
<tr><td><code id="exact.reject.region_+3A_usestoredcsm">useStoredCSM</code></td>
<td>
<p>Logical: uses stored CSM ordering matrix.  Only used if method=&quot;csm&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rejection region is calculated for binomial models with independent samples.  The design must know the fixed sample sizes in advance.  Rejection region can be determined for any unconditional exact test in <code><a href="#topic+exact.test">exact.test</a></code>, Fisher's exact test, or chi-square test (Yates' or Pearson's; note: these are not exact tests).  In very rare cases, using the nuisance parameter interval approach does not attain the convexity property, so it is possible using <code>convexity=TRUE</code> could yield an inaccurate power calculation with this method.  This is <em>extremely unlikely</em> though, so default is to assume convexity and speed up computation time.  For details regarding parameters, see <code><a href="#topic+exact.test">exact.test</a></code>.
</p>


<h3>Value</h3>

<p>A matrix of the rejection region.  The columns represent the number of successes in first group, rows represent the number of successess in second group, and cells represent whether the test is rejected (1) or failed to be rejected (0).  This matrix represents all possible 2x2 tables.
</p>


<h3>Note</h3>

<p>Pearson's and Yates' chi-square tests are not exact tests, so the function name may be a misnomer.  These tests may have inflated type 1 error rates.  These options were added to compute the rejection region efficiently when using asymptotic tests.
</p>


<h3>Author(s)</h3>

<p>Peter Calhoun</p>


<h3>References</h3>

<p>Barnard, G.A. (1947) Significance tests for 2x2 tables. <em>Biometrika</em>, <b>34</b>, 123-138
</p>
<p>Chan, I. (2003), Proving non-inferiority or equivalence of two treatments with dichotomous endpoints using exact methods, <em>Statistical Methods in Medical Research</em>, <b>12</b>, 37&ndash;58
</p>


<h3>See Also</h3>

<p><code><a href="#topic+power.exact.test">power.exact.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Ensure that the ExactData R package is available before running the CSM test.
if (requireNamespace("ExactData", quietly = TRUE)) {
exact.reject.region(n1=10, n2=20, alternative="two.sided", method="CSM")
}

## End(Not run)

exact.reject.region(n1=10, n2=20, alternative="less", method="Z-pooled", delta=0.10)
</code></pre>

<hr>
<h2 id='exact.test'>Unconditional Exact Tests for 2x2 Tables with Independent Samples</h2><span id='topic+exact.test'></span><span id='topic+binomialCode'></span><span id='topic+multinomCode'></span>

<h3>Description</h3>

<p>Calculates Barnard's or Boschloo's unconditional exact test for binomial or multinomial models with independent samples</p>


<h3>Usage</h3>

<pre><code class='language-R'>exact.test(data, alternative = c("two.sided", "less", "greater"), npNumbers = 100,
    np.interval = FALSE, beta = 0.001,
     method = c("z-pooled", "z-unpooled", "boschloo", "santner and snell", "csm"),
    model = c("Binomial", "Multinomial"), tsmethod = c("square", "central"),
    conf.int = FALSE, conf.level = 0.95,
    cond.row = TRUE, to.plot = TRUE, ref.pvalue = TRUE,
    delta = 0, reject.alpha = NULL, useStoredCSM = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exact.test_+3A_data">data</code></td>
<td>
<p>A two dimensional contingency table in matrix form</p>
</td></tr>
<tr><td><code id="exact.test_+3A_alternative">alternative</code></td>
<td>
<p>Indicates the alternative hypothesis: must be either &quot;two.sided&quot;, &quot;less&quot;, or &quot;greater&quot;</p>
</td></tr>
<tr><td><code id="exact.test_+3A_npnumbers">npNumbers</code></td>
<td>
<p>Number: The number of nuisance parameters considered</p>
</td></tr>
<tr><td><code id="exact.test_+3A_np.interval">np.interval</code></td>
<td>
<p>Logical: Indicates if a confidence interval on the nuisance parameter should be computed</p>
</td></tr>
<tr><td><code id="exact.test_+3A_beta">beta</code></td>
<td>
<p>Number: Confidence level for constructing the interval of nuisance parameters considered.  Only used if np.interval=TRUE</p>
</td></tr>
<tr><td><code id="exact.test_+3A_method">method</code></td>
<td>

<p>Indicates the method for finding the more extreme tables:
must be either &quot;Z-pooled&quot;, &quot;Z-unpooled&quot;, &quot;Santner and Snell&quot;, &quot;Boschloo&quot;, or &quot;CSM&quot;.
CSM tests cannot be calculated for multinomial models</p>
</td></tr>
<tr><td><code id="exact.test_+3A_model">model</code></td>
<td>
<p>The model being used: must be either &quot;Binomial&quot; or &quot;Multinomial&quot;</p>
</td></tr>
<tr><td><code id="exact.test_+3A_tsmethod">tsmethod</code></td>
<td>

<p>Indicates two-sided method: must be either &quot;square&quot; or &quot;central&quot;.  Only used if model=&quot;Binomial&quot;</p>
</td></tr>
<tr><td><code id="exact.test_+3A_conf.int">conf.int</code></td>
<td>

<p>Logical: Indicates if a confidence interval on the difference in proportion should be computed.
Only used if model=&quot;Binomial&quot;</p>
</td></tr>
<tr><td><code id="exact.test_+3A_conf.level">conf.level</code></td>
<td>
<p>Number: Confidence level of interval on difference in proportion.  Only used if conf.int=TRUE</p>
</td></tr>
<tr><td><code id="exact.test_+3A_cond.row">cond.row</code></td>
<td>
<p>Logical: Indicates if row margins are fixed in the binomial models.  Only used if model=&quot;Binomial&quot;</p>
</td></tr>
<tr><td><code id="exact.test_+3A_to.plot">to.plot</code></td>
<td>
<p>Logical: Indicates if plot of p-value vs. nuisance parameter should be generated.  Only used if model=&quot;Binomial&quot;</p>
</td></tr>
<tr><td><code id="exact.test_+3A_ref.pvalue">ref.pvalue</code></td>
<td>
<p>Logical: Indicates if p-value should be refined by maximizing the p-value function after the nuisance parameter is selected.  Only used if model=&quot;Binomial&quot;</p>
</td></tr>
<tr><td><code id="exact.test_+3A_delta">delta</code></td>
<td>
<p>Number: null hypothesis of the difference in proportion.  Only used if model=&quot;Binomial&quot;</p>
</td></tr>
<tr><td><code id="exact.test_+3A_reject.alpha">reject.alpha</code></td>
<td>
<p>Number: significance level for exact test.  Optional and primarily used to speed up <code><a href="#topic+exact.reject.region">exact.reject.region</a></code> function</p>
</td></tr>
<tr><td><code id="exact.test_+3A_usestoredcsm">useStoredCSM</code></td>
<td>
<p>Logical: uses stored CSM ordering matrix.  Only used if method=&quot;csm&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unconditional exact tests (i.e., Barnard's test) can be performed for binomial or multinomial models with independent samples. The binomial model assumes the row or column margins (but not both) are known in advance, while the multinomial model assumes only the total sample size is known beforehand.  For the binomial model, the user needs to specify which margin is fixed (default is rows). Conditional tests (e.g., Fisher's exact test) have both row and column margins fixed, but this is a very uncommon design.  For paired samples, see <code><a href="#topic+paired.exact.test">paired.exact.test</a></code>.
</p>
<p>For the binomial model, the null hypothesis is the difference of proportion is equal to 0. Under the null hypothesis, the probability of a 2x2 table is the product of two binomials. The p-value is calculated by maximizing a nuisance parameter and summing the as or more extreme tables. The <code>method</code> parameter specifies the method to determine the more extreme tables (see references for more details):
</p>

<ul>
<li><p> Z-pooled (or Score) - Uses the test statistic from a Z-test using a pooled proportion
</p>
</li>
<li><p> Z-unpooled - Uses the test statistic from a Z-test without using the pooled proportion
</p>
</li>
<li><p> Santner and Snell - Uses the difference in proportion
</p>
</li>
<li><p> Boschloo - Uses the p-value from Fisher's exact test
</p>
</li>
<li><p> CSM - Starts with the most extreme table and sequentially adds more extreme tables based on the smallest p-value (calculated by maximizing the probability of a 2x2 table).  This is Barnard's original method
</p>
</li></ul>

<p>There is some disagreement on which method to use.  Barnard's CSM (Convexity, Symmetry, and Minimization) test is often the most powerful test, but is much more computationally intensive.  This test is recommended by Mato and Andres and the author of this R package when computationally feasible.  Suissa and Shuster suggested using a Z-pooled statistic, which is uniformly more powerful than Fisher's test for balanced designs.  Boschloo recommended using the p-value for Fisher's test as the test statistic.  This method became known as Boschloo's test, and it is always uniformly more powerful than Fisher's test.  Many researchers argue that Fisher's exact test should <strong>never</strong> be used to analyze 2x2 tables (except in the rare instance both margins are fixed).
</p>
<p>Once the more extreme tables are determined, the p-value is calculated by maximizing over the common success probability &ndash; a nuisance parameter.  The p-value computation has many local maxima and can be computationally intensive.  The code performs an exhaustive search by considering many values of the nuisance parameter from 0 to 1, represented by <code>npNumbers</code>.  If <code>ref.pvalue = TRUE</code>, then the code will also use the <code>optimise</code> function near the nuisance parameter to refine the p-value.  Increasing <code>npNumbers</code> and using <code>ref.pvalue</code> ensures the p-value is correctly calculated at the expense of slightly more computation time.
</p>
<p>Another approach, proposed by Berger and Boos, is to calculate the Clopper-Pearson confidence interval of the nuisance parameter (represented by <code>np.interval</code>) and only maximize the p-value function for nuisance parameters within the confidence interval; this approach adds a small penalty to the p-value to control for the type 1 error rate (cannot be used with CSM).
</p>
<p>The tests can also be implemented for non-inferiority hypotheses by changing the <code>delta</code> for binomial models. A confidence interval for the difference in proportion can be constructed by determining the smallest delta such that all greater deltas are significant (essentially the delta that crosses from non-significant to significant, but since the p-value is non-monotonic as a function of delta, this code takes the supremum).  For details regarding calculation, please see Chan (2003).  We note the &quot;z-pooled&quot; method uses a delta-projected Z-statistic (aka Score) and uses a constrained MLE of the success proportions, while &quot;boschloo&quot; method ignores the delta and uses the same ordering procedure.  
</p>
<p>For two-sided tests, the code will either sum the probabilities for both sides of the table if <code>tsmethod = "square"</code> (Default, same approach as <code>fisher.test</code>) or construct a one-sided test and double the p-value if <code>tsmethod = "central"</code>.  Generally, the &quot;square&quot; procedure is more powerful and conventional, although there are some advantages with using the &quot;central&quot; procedure.  Mainly, Boschloo's test cannot order tables (i.e., use Fisher's p-value) for a two-sided alternative with non-zero delta.  Thus, to calculate a two-sided confidence interval with Boschloo's test, one has to resort to using the &quot;central&quot; approach.  For other tests, there is an equivalent statistic based on delta, and the two-sided p-value is determined by either the Agresti-Min interval (<code>tsmethod = "square"</code>) or Chan-Zhang interval (<code>tsmethod = "central"</code>).
</p>
<p>The CSM test is computationally intensive due to iteratively maximizing the p-value calculation to order the tables.  The CSM ordering matrix has been stored for all possible sample sizes less than or equal to 100 (i.e., max(n1,n2)&lt;=100).  In addition, any table with (n1+1)x(n2+1)&lt;=15,000 with a ratio between 1:1 and 2:1 is stored.  Thus, using the <code>useStoredCSM = TRUE</code> can greatly improve computation time.  However, the stored ordering matrix was computed with <code>npNumbers=100</code> and it is possible that the ordering matrix was not optimal for larger <code>npNumbers</code>.  Increasing <code>npNumbers</code> and setting <code>useStoredCSM = FALSE</code> ensures the p-value is correctly calculated at the expense of significantly greater computation time.  The stored ordering matrix is not used in the calculation of confidence intervals or non-inferiority tests, so CSM can still be very computationally intensive.
</p>
<p>The above description applies to the binomial model.  The multinomial model is similar except there are two nuisance parameters.  The CSM test has not been developed for multinomial models.  Improvements to the code have focused on the binomial model, so multinomial models takes substantially longer.
</p>


<h3>Value</h3>

<p>A list with class &quot;htest&quot; containing the following components:
</p>
<table role = "presentation">
<tr><td><code>p.value</code></td>
<td>
<p>The p-value of the test</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The observed test statistic to determine more extreme tables</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>An estimate of the difference in proportion</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>The difference in proportion under the null</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>A confidence interval for the difference in proportion.  Only present if <code>conf.int = TRUE</code></p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>A character string describing the alternative hypothesis</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A character string describing the model design (&quot;Binomial&quot; or &quot;Multinomial&quot;)</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A character string describing the method to determine more extreme tables</p>
</td></tr>
<tr><td><code>tsmethod</code></td>
<td>
<p>A character string describing the method to implement two-sided tests.  Only present if <code>model = "binomial"</code></p>
</td></tr>
<tr><td><code>np</code></td>
<td>
<p>The nuisance parameter that maximizes the p-value.  For multinomial models, both nuisance parameters are given</p>
</td></tr>
<tr><td><code>np.range</code></td>
<td>
<p>The range of nuisance parameters considered.  For multinomial models, both nuisance parameter ranges are given</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>A character string giving the names of the data</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>The sample sizes</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>Multinomial models and CSM tests with confidence intervals may take a very long time, even for small sample sizes.</p>


<h3>Note</h3>

<p>CSM test and multinomial models are much more computationally intensive.  I have also spent a greater amount of time improving the computation speed and adding functionality to the binomial model. Increasing the number of nuisance parameters considered and refining the p-value will increase the computation time, but more likely to ensure accurate calculations. Performing confidence intervals also greatly increases computation time.
</p>
<p>This code was influenced by the FORTRAN program located at <a href="https://www4.stat.ncsu.edu/~boos/exact/">https://www4.stat.ncsu.edu/~boos/exact/</a>
</p>


<h3>Author(s)</h3>

<p>Peter Calhoun</p>


<h3>References</h3>

<p>Agresti, A. and Min, Y. (2001) On small-sample confidence intervals for parameters in discrete distributions. <em>Biometrics</em>, <b>57</b>, 963&ndash;971
</p>
<p>Barnard, G.A. (1945) A new test for 2x2 tables. <em>Nature</em>, <b>156</b>, 177
</p>
<p>Barnard, G.A. (1947) Significance tests for 2x2 tables. <em>Biometrika</em>, <b>34</b>, 123&ndash;138
</p>
<p>Berger, R. and Boos D. (1994) P values maximized over a confidence set for the nuisance parameter. <em>Journal of the American Statistical Association</em>, <b>89</b>, 1012&ndash;1016
</p>
<p>Berger, R. (1994) Power comparison of exact unconditional tests for comparing two binomial proportions. <em>Institute of Statistics Mimeo Series No. 2266</em>
</p>
<p>Berger, R. (1996) More powerful tests from confidence interval p values. <em>American Statistician</em>, <b>50</b>, 314&ndash;318
</p>
<p>Boschloo, R. D. (1970), Raised Conditional Level of Significance for the 2x2-table when Testing the Equality of Two Probabilities. <em>Statistica Neerlandica</em>, <b>24</b>, 1&ndash;35
</p>
<p>Chan, I. (2003), Proving non-inferiority or equivalence of two treatments with dichotomous endpoints using exact methods, <em>Statistical Methods in Medical Research</em>, <b>12</b>, 37&ndash;58
</p>
<p>Cardillo, G. (2009) MyBarnard: a very compact routine for Barnard's exact test on 2x2 matrix.
<a href="https://www.mathworks.com/matlabcentral/fileexchange/25760-mybarnard">https://www.mathworks.com/matlabcentral/fileexchange/25760-mybarnard</a>
</p>
<p>Mato, S. and Andres, M. (1997), Simplifying the calculation of the P-value for Barnard's test and its derivatives.  <em>Statistics and Computing</em>, <b>7</b>, 137&ndash;143
</p>
<p>Mehrotra, D., Chan, I., Berger, R. (2003), A Cautionary Note on Exact Unconditional Inference for a Difference Between Two Independent Binomial Proportions.  <em>Biometrics</em>, <b>59</b>, 441&ndash;450
</p>
<p>Ruxton, G. D. and Neuhauser M (2010), Good practice in testing for an association in contingency tables. <em>Behavioral Ecology and Sociobiology</em>, <b>64</b>, 1505&ndash;1513
</p>
<p>Suissa, S. and Shuster, J. J. (1985), Exact Unconditional Sample Sizes for the 2x2 Binomial Trial, <em>Journal of the Royal Statistical Society, Ser. A</em>, <b>148</b>, 317&ndash;327
</p>


<h3>See Also</h3>

<p><code>fisher.test</code> and <span class="pkg">exact2x2</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- matrix(c(7, 8, 12, 3), 2, 2, byrow=TRUE)
exact.test(data, alternative="two.sided", method="Z-pooled",
           conf.int=TRUE, conf.level=0.95)
exact.test(data, alternative="two.sided", method="Boschloo",
           np.interval=TRUE, beta=0.001, tsmethod="central")

## Not run: 
# Ensure that the ExactData R package is available before running the CSM test.
if (requireNamespace("ExactData", quietly = TRUE)) {
# Example from Barnard's (1947) appendix:
data &lt;- matrix(c(4, 0, 3, 7), 2, 2,
               dimnames=list(c("Box 1","Box 2"), c("Defective","Not Defective")))
exact.test(data, method="CSM", alternative="two.sided")
}

## End(Not run)
</code></pre>

<hr>
<h2 id='paired.exact.test'>Unconditional Exact Tests for 2x2 Tables with Paired Samples</h2><span id='topic+paired.exact.test'></span><span id='topic+pairedCode'></span>

<h3>Description</h3>

<p>Calculates unconditional exact test for paired samples</p>


<h3>Usage</h3>

<pre><code class='language-R'>paired.exact.test(data, alternative = c("two.sided", "less", "greater"), npNumbers = 100,
    np.interval = FALSE, beta = 0.001,
    method = c("uam", "ucm", "uamcc", "csm"),
    tsmethod = c("square", "central"),
    conf.int = FALSE, conf.level = 0.95, to.plot = TRUE,
    ref.pvalue = TRUE, delta = 0,
    reject.alpha = NULL, useStoredCSM = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paired.exact.test_+3A_data">data</code></td>
<td>
<p>A two dimensional contingency table in matrix form</p>
</td></tr>
<tr><td><code id="paired.exact.test_+3A_alternative">alternative</code></td>
<td>
<p>Indicates the alternative hypothesis: must be either &quot;two.sided&quot;, &quot;less&quot;, or &quot;greater&quot;</p>
</td></tr>
<tr><td><code id="paired.exact.test_+3A_npnumbers">npNumbers</code></td>
<td>
<p>Number: The number of nuisance parameters considered</p>
</td></tr>
<tr><td><code id="paired.exact.test_+3A_np.interval">np.interval</code></td>
<td>
<p>Logical: Indicates if a confidence interval on the nuisance parameter should be computed</p>
</td></tr>
<tr><td><code id="paired.exact.test_+3A_beta">beta</code></td>
<td>
<p>Number: Confidence level for constructing the interval of nuisance parameters considered.  Only used if np.interval=TRUE</p>
</td></tr>
<tr><td><code id="paired.exact.test_+3A_method">method</code></td>
<td>

<p>Indicates the method for finding the more extreme tables:
must be either &quot;UAM&quot;, &quot;UCM&quot;, &quot;UAMCC&quot;, or &quot;CSM&quot;</p>
</td></tr>
<tr><td><code id="paired.exact.test_+3A_tsmethod">tsmethod</code></td>
<td>
<p>A character string describing the method to implement two-sided tests.</p>
</td></tr>
<tr><td><code id="paired.exact.test_+3A_conf.int">conf.int</code></td>
<td>

<p>Logical: Indicates if a confidence interval on the difference in proportion should be computed</p>
</td></tr>
<tr><td><code id="paired.exact.test_+3A_conf.level">conf.level</code></td>
<td>
<p>Number: Confidence level of interval on difference in proportion.  Only used if conf.int=TRUE</p>
</td></tr>
<tr><td><code id="paired.exact.test_+3A_to.plot">to.plot</code></td>
<td>
<p>Logical: Indicates if plot of p-value vs. nuisance parameter should be generated</p>
</td></tr>
<tr><td><code id="paired.exact.test_+3A_ref.pvalue">ref.pvalue</code></td>
<td>
<p>Logical: Indicates if p-value should be refined by maximizing the p-value function after the nuisance parameter is selected</p>
</td></tr>
<tr><td><code id="paired.exact.test_+3A_delta">delta</code></td>
<td>
<p>Number: null hypothesis of the difference in proportion</p>
</td></tr>
<tr><td><code id="paired.exact.test_+3A_reject.alpha">reject.alpha</code></td>
<td>
<p>Number: significance level for exact test.  Optional and primarily used to speed up <code><a href="#topic+paired.reject.region">paired.reject.region</a></code> function</p>
</td></tr>
<tr><td><code id="paired.exact.test_+3A_usestoredcsm">useStoredCSM</code></td>
<td>
<p>Logical: uses stored CSM ordering matrix.  Only used if method=&quot;csm&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs unconditional exact tests to compare two paired proportions.  The null hypothesis is the difference of two paired proportions is equal to 0. Under the null hypothesis, the probability of a 2x2 table is a trinomial distribution. The p-value is calculated by maximizing a nuisance parameter and summing the as or more extreme tables. The <code>method</code> parameter specifies the method to determine the more extreme tables (see references for more details):
</p>

<ul>
<li><p> UAM (Unconditional Asymptotic McNemar) - Uses McNemar's Z-statistic
</p>
</li>
<li><p> UCM (Unconditional Conditional McNemar) - Uses McNemar's conditional p-value
</p>
</li>
<li><p> UAMCC (Unconditional Asyptotic McNemar with Continuity Correction) - Uses McNemar's Z-statistic with Continuity Correction
</p>
</li>
<li><p> CSM - Starts with the most extreme table and sequentially adds more extreme tables based on the smallest p-value (calculated by maximizing the probability of a 2x2 table).  This is extending Barnard's original method to test two paired proportions
</p>
</li></ul>

<p>There is little research comparing two paired proportions.  The author of this R package recommends using the CSM (Convexity, Symmetry, and Minimization) test as this test is often the most powerful, but is much more computationally intensive.
</p>
<p>Once the more extreme tables are determined, the p-value is calculated by maximizing over the common discordant probability &ndash; a nuisance parameter.  The p-value computation has many local maxima and can be computationally intensive.  The code performs an exhaustive search by considering many values of the nuisance parameter from 0 to 0.5, represented by <code>npNumbers</code>.  If <code>ref.pvalue = TRUE</code>, then the code will also use the <code>optimise</code> function near the nuisance parameter to refine the p-value.  Increasing <code>npNumbers</code> and using <code>ref.pvalue</code> ensures the p-value is correctly calculated at the expense of slightly more computation time.
</p>
<p>Another approach, proposed by Berger and Sidik, is to calculate the Clopper-Pearson confidence interval of the nuisance parameter (represented by <code>np.interval</code>) and only maximize the p-value function for nuisance parameters within the confidence interval; this approach adds a small penalty to the p-value to control for the type 1 error rate (cannot be used with CSM).  If the CSM test is too computationally intensive, the author of this R package generally recommends using the UAM test with confidence interval approach.
</p>
<p>The tests can also be implemented for non-inferiority hypotheses by changing the <code>delta</code>. A confidence interval for the difference in proportion can be constructed by determining the smallest delta such that all greater deltas are significant (essentially the delta that crosses from non-significant to significant, but since the p-value is non-monotonic as a function of delta, this code takes the supremum).  We note the &quot;UAM&quot; method uses a delta-projected Z-statistic, while &quot;UCM&quot; method ignores the delta and uses the same ordering procedure.
</p>
<p>For two-sided tests, the code will either sum the probabilities for both sides of the table if <code>tsmethod = "square"</code> (Default) or construct a one-sided test and double the p-value if <code>tsmethod = "central"</code>.  The two methods give the same results when delta is zero.  For a non-zero delta, the &quot;square&quot; procedure is generally more powerful and conventional, although there are some advantages with using the &quot;central&quot; procedure.  Mainly, UCM test cannot order tables (i.e., use McNemar's conditional p-value) for a two-sided alternative with non-zero delta.  Thus, to calculate a two-sided confidence interval with UCM test, one has to resort to using the &quot;central&quot; approach.  For other tests, there is an equivalent statistic based on delta, and the two-sided p-value is determined by either the Agresti-Min interval (<code>tsmethod = "square"</code>) or Chan-Zhang interval (<code>tsmethod = "central"</code>).
</p>
<p>The CSM test is computationally intensive due to iteratively maximizing the p-value calculation to order the tables.  The CSM ordering matrix has been stored for total sample sizes less than or equal to 200.  Thus, using the <code>useStoredCSM = TRUE</code> can greatly improve computation time.  However, the stored ordering matrix was computed with <code>npNumbers=100</code> and it is possible that the ordering matrix was not optimal for larger <code>npNumbers</code>.  Increasing <code>npNumbers</code> and setting <code>useStoredCSM = FALSE</code> ensures the p-value is correctly calculated at the expense of significantly greater computation time.  The stored ordering matrix is not used in the calculation of confidence intervals or non-inferiority tests, so CSM can still be very computationally intensive.
</p>


<h3>Value</h3>

<p>A list with class &quot;htest&quot; containing the following components:
</p>
<table role = "presentation">
<tr><td><code>p.value</code></td>
<td>
<p>The p-value of the test</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The observed test statistic to determine more extreme tables</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>An estimate of the difference in proportion</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>The difference in proportion under the null</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>A confidence interval for the difference in proportion.  Only present if <code>conf.int = TRUE</code></p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>A character string describing the alternative hypothesis</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A character string describing the method to determine more extreme tables</p>
</td></tr>
<tr><td><code>tsmethod</code></td>
<td>
<p>A character string describing the method to implement two-sided tests</p>
</td></tr>
<tr><td><code>np</code></td>
<td>
<p>The nuisance parameter that maximizes the p-value</p>
</td></tr>
<tr><td><code>np.range</code></td>
<td>
<p>The range of nuisance parameters considered</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>A character string giving the names of the data</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>The sample sizes</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>CSM tests with confidence intervals may take a very long time, even for small sample sizes.</p>


<h3>Note</h3>

<p>CSM test is much more computationally intensive.  Increasing the number of nuisance parameters considered and refining the p-value will increase the computation time, but more likely to ensure accurate calculations. Performing confidence intervals also greatly increases computation time.
</p>


<h3>Author(s)</h3>

<p>Peter Calhoun</p>


<h3>References</h3>

<p>Berger, R.L. and Sidik, K. (2003) Exact unconditional tests for 2 x 2 matched-pairs design. <em>Statistical Methods in Medical Research</em>, <b>12</b>, 91&ndash;108
</p>
<p>Hsueh, H., Liu, J., and Chen, J.J. (2001) Unconditional exact tests for equivalence or noninferiority for paired binary endpoints. <em>Biometrics</em>, <b>57</b>, 478&ndash;483
</p>


<h3>See Also</h3>

<p><code>mcnemar.test</code> and <span class="pkg">exact2x2</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- matrix(c(3,6,1,0), 2, 2,
               dimnames=list(c("Population 1 Success", "Population 1 Failure"),
                             c("Population 2 Success", "Population 2 Failure")))
paired.exact.test(data, method="UAM", alternative="less")

## Not run: 
# Ensure that the ExactData R package is available before running the CSM test.
if (requireNamespace("ExactData", quietly = TRUE)) {
paired.exact.test(data, method="CSM", alternative="less")
}

## End(Not run)
</code></pre>

<hr>
<h2 id='paired.reject.region'>Rejection Region for 2x2 Tables with Paired Samples</h2><span id='topic+paired.reject.region'></span>

<h3>Description</h3>

<p>Determines the rejection region for comparing two paired proportions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>paired.reject.region(N, alternative = c("two.sided", "less", "greater"),
    alpha = 0.05, npNumbers = 100, np.interval = FALSE, beta = 0.001,
    method = c("uam", "ucm", "uamcc", "csm", "cm", "am", "amcc"),
    tsmethod = c("square", "central"),
    delta = 0, convexity = TRUE, useStoredCSM = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paired.reject.region_+3A_n">N</code></td>
<td>
<p>The total sample size</p>
</td></tr>
<tr><td><code id="paired.reject.region_+3A_alternative">alternative</code></td>
<td>
<p>Indicates the alternative hypothesis: must be either &quot;two.sided&quot;, &quot;less&quot;, or &quot;greater&quot;</p>
</td></tr>
<tr><td><code id="paired.reject.region_+3A_alpha">alpha</code></td>
<td>
<p>Significance level</p>
</td></tr>
<tr><td><code id="paired.reject.region_+3A_npnumbers">npNumbers</code></td>
<td>
<p>Number: The number of nuisance parameters considered</p>
</td></tr>
<tr><td><code id="paired.reject.region_+3A_np.interval">np.interval</code></td>
<td>
<p>Logical: Indicates if a confidence interval on the nuisance parameter should be computed</p>
</td></tr>
<tr><td><code id="paired.reject.region_+3A_beta">beta</code></td>
<td>
<p>Number: Confidence level for constructing the interval of nuisance parameters considered.  Only used if np.interval=TRUE</p>
</td></tr>
<tr><td><code id="paired.reject.region_+3A_method">method</code></td>
<td>

<p>Indicates the method for finding the more extreme tables:
must be either &quot;UAM&quot;, &quot;UCM&quot;, &quot;UAMCC&quot;, &quot;CSM&quot;, &quot;CM&quot;, &quot;AM&quot;, or &quot;AMCC&quot;</p>
</td></tr>
<tr><td><code id="paired.reject.region_+3A_tsmethod">tsmethod</code></td>
<td>
<p>A character string describing the method to implement two-sided tests</p>
</td></tr>
<tr><td><code id="paired.reject.region_+3A_delta">delta</code></td>
<td>
<p>Number: null hypothesis of the difference in proportion</p>
</td></tr>
<tr><td><code id="paired.reject.region_+3A_convexity">convexity</code></td>
<td>
<p>Logical: assumes convexity for interval approach.  Only used if np.interval=TRUE</p>
</td></tr>
<tr><td><code id="paired.reject.region_+3A_usestoredcsm">useStoredCSM</code></td>
<td>
<p>Logical: uses stored CSM ordering matrix.  Only used if method=&quot;csm&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rejection region is calculated for paired samples.  Rejection region can be determined for any unconditional exact test in <code><a href="#topic+paired.exact.test">paired.exact.test</a></code>, the Conditional McNemar's (CM) exact test, the Asymptotic McNemar's (AM) test, or Asymptotic McNemar's test with Continuity Correction (AMCC) (note: asymptotic tests are not exact tests).  In very rare cases, using the nuisance parameter interval approach does not attain the convexity property, so it is possible using <code>convexity=TRUE</code> could yield an inaccurate power calculation with this method.  This is <em>extremely unlikely</em> though, so default is to assume convexity and speed up computation time.  For details regarding parameters, see <code><a href="#topic+paired.exact.test">paired.exact.test</a></code>.
</p>


<h3>Value</h3>

<p>A matrix of the rejection region.  The rows and columns represent the discordant pairs.  Specifically, the columns represent x12, the number of successes in first group and number of failures in second group, and rows represent x21, the number of failures in first group and number of successes in second group.  The number of concordant pairs is simply the total sample size minus number of discordant pairs.  The cells represent whether the test is rejected (1) or failed to be rejected (0).  Values with an NA are not possible.  This matrix represents all possible 2x2 tables.
</p>


<h3>Note</h3>

<p>McNemar's asymptotic tests are not exact test and may have inflated type 1 error rates.  These options were added to compute the rejection region efficiently when using asymptotic tests.
</p>


<h3>Author(s)</h3>

<p>Peter Calhoun</p>


<h3>See Also</h3>

<p><code><a href="#topic+power.paired.test">power.paired.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Ensure that the ExactData R package is available before running the CSM test.
if (requireNamespace("ExactData", quietly = TRUE)) {
paired.reject.region(N=15, alternative="two.sided", method="CSM")
}

## End(Not run)

paired.reject.region(N=15, alternative="less", method="UAM", delta=0.10)
</code></pre>

<hr>
<h2 id='power.exact.test'>Power Calculations for 2x2 Tables with Independent Samples</h2><span id='topic+power.exact.test'></span>

<h3>Description</h3>

<p>Calculates the power of the design for known sample sizes and true probabilities.</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.exact.test(p1, p2, n1, n2, alternative = c("two.sided", "less", "greater"),
    alpha = 0.05, npNumbers = 100, np.interval = FALSE, beta = 0.001,
    method = c("z-pooled", "z-unpooled", "boschloo", "santner and snell", "csm",
               "fisher", "pearson chisq", "yates chisq"),
    tsmethod = c("square", "central"), simulation = FALSE, nsim = 100,
    delta = 0, convexity = TRUE, useStoredCSM = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power.exact.test_+3A_p1">p1</code></td>
<td>
<p>The probability of success given in first group</p>
</td></tr>
<tr><td><code id="power.exact.test_+3A_p2">p2</code></td>
<td>
<p>The probability of success given in second group</p>
</td></tr>
<tr><td><code id="power.exact.test_+3A_n1">n1</code></td>
<td>
<p>The sample size in first group</p>
</td></tr>
<tr><td><code id="power.exact.test_+3A_n2">n2</code></td>
<td>
<p>The sample size in second group</p>
</td></tr>
<tr><td><code id="power.exact.test_+3A_alternative">alternative</code></td>
<td>
<p>Indicates the alternative hypothesis: must be either &quot;two.sided&quot;, &quot;less&quot;, or &quot;greater&quot;</p>
</td></tr>
<tr><td><code id="power.exact.test_+3A_alpha">alpha</code></td>
<td>
<p>Significance level</p>
</td></tr>
<tr><td><code id="power.exact.test_+3A_npnumbers">npNumbers</code></td>
<td>
<p>Number: The number of nuisance parameters considered</p>
</td></tr>
<tr><td><code id="power.exact.test_+3A_np.interval">np.interval</code></td>
<td>
<p>Logical: Indicates if a confidence interval on the nuisance parameter should be computed</p>
</td></tr>
<tr><td><code id="power.exact.test_+3A_beta">beta</code></td>
<td>
<p>Number: Confidence level for constructing the interval of nuisance parameters considered.  Only used if np.interval=TRUE</p>
</td></tr>
<tr><td><code id="power.exact.test_+3A_method">method</code></td>
<td>

<p>Indicates the method for finding more extreme tables:
must be either &quot;Z-pooled&quot;, &quot;Z-unpooled&quot;, &quot;Santner and Snell&quot;, &quot;Boschloo&quot;, &quot;CSM&quot;, &quot;Fisher&quot;, &quot;Pearson Chisq&quot;, or &quot;Yates Chisq&quot;</p>
</td></tr>
<tr><td><code id="power.exact.test_+3A_tsmethod">tsmethod</code></td>
<td>
<p>Indicates two-sided method: must be either &quot;square&quot; or &quot;central&quot;</p>
</td></tr>
<tr><td><code id="power.exact.test_+3A_simulation">simulation</code></td>
<td>
<p>Logical: Indicates if the power calculation is exact or estimated by simulation</p>
</td></tr>
<tr><td><code id="power.exact.test_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations run.  Only used if simulation=TRUE</p>
</td></tr>
<tr><td><code id="power.exact.test_+3A_delta">delta</code></td>
<td>
<p>Number: null hypothesis of the difference in proportion</p>
</td></tr>
<tr><td><code id="power.exact.test_+3A_convexity">convexity</code></td>
<td>
<p>Logical: assumes convexity for interval approach.  Only used if np.interval=TRUE</p>
</td></tr>
<tr><td><code id="power.exact.test_+3A_usestoredcsm">useStoredCSM</code></td>
<td>
<p>Logical: uses stored CSM ordering matrix.  Only used if method=&quot;csm&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The power calculations are for binomial models with independent samples.  The design must know the fixed sample sizes in advance.  There are (n1+1) x (n2+1) possible tables that could be produced.  There are two ways to calculate the power: simulate the tables under two independent binomial distributions or determine the rejection region for all possible tables and calculate the exact power.  The calculations can be done using any <code><a href="#topic+exact.test">exact.test</a></code> computation, Fisher's exact test, or chi-square tests (Yates' or Pearson's; note: these are not exact tests).  The power calculations utilize the convexity property, which greatly speeds up computation time (see <code><a href="#topic+exact.reject.region">exact.reject.region</a></code> documentation).
</p>


<h3>Value</h3>

<p>A list with class &quot;power.htest&quot; containing the following components:
</p>
<table role = "presentation">
<tr><td><code>n1</code>, <code>n2</code></td>
<td>
<p>The respective sample sizes</p>
</td></tr>
<tr><td><code>p1</code>, <code>p2</code></td>
<td>
<p>The respective success probabilities</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>Significance level</p>
</td></tr>
<tr><td><code>power</code></td>
<td>
<p>Power of the test</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>A character string describing the alternative hypothesis</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>Null hypothesis of the difference in proportion</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A character string describing the method to determine more extreme tables</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Pearson's and Yates' chi-square tests are not exact tests, so the function name may be a misnomer.  These tests may have inflated type 1 error rates.  These options were added to compute the power efficiently when using asymptotic tests.
</p>


<h3>Author(s)</h3>

<p>Peter Calhoun</p>


<h3>References</h3>

<p>Berger, R. (1994) Power comparison of exact unconditional tests for comparing two binomial proportions. <em>Institute of Statistics Mimeo Series No. 2266</em>
</p>
<p>Berger, R. (1996) More powerful tests from confidence interval p values. <em>American Statistician</em>, <b>50</b>, 314-318
</p>
<p>Boschloo, R. D. (1970), Raised Conditional Level of Significance for the 2x2-table when Testing the Equality of Two Probabilities. <em>Statistica Neerlandica</em>, <b>24</b>, 1-35
</p>


<h3>See Also</h3>

<p><code><a href="#topic+exact.reject.region">exact.reject.region</a></code> and <span class="pkg">statmod</span></p>


<h3>Examples</h3>

<pre><code class='language-R'># Superiority power #
power.exact.test(p1=0.15, p2=0.60, n1=15, n2=30, method="Z-pooled")
power.exact.test(p1=0.15, p2=0.60, n1=15, n2=30, method="Fisher")
power.exact.test(p1=0.15, p2=0.60, n1=15, n2=30, method="Boschloo",
                 np.interval=TRUE, beta=0.001)
## Not run: 
# Ensure that the ExactData R package is available before running the CSM test.
if (requireNamespace("ExactData", quietly = TRUE)) {
power.exact.test(p1=0.15, p2=0.60, n1=15, n2=30, method="CSM")
}

## End(Not run)

# Non-inferiority power #
power.exact.test(p1=0.30, p2=0.30, n1=65, n2=65, method="Z-pooled",
                 delta=0.2, alternative="less")
</code></pre>

<hr>
<h2 id='power.paired.test'>Power Calculations for 2x2 Tables with Paired Samples</h2><span id='topic+power.paired.test'></span>

<h3>Description</h3>

<p>Calculates the power of the design for known sample size and true probabilities.</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.paired.test(p12, p21, N, alternative = c("two.sided", "less", "greater"),
    alpha = 0.05, npNumbers = 100, np.interval = FALSE, beta = 0.001,
    method = c("uam", "ucm", "uamcc", "csm", "cm", "am", "amcc"),
    tsmethod = c("square", "central"),
    simulation = FALSE, nsim = 100,
    delta = 0, convexity = TRUE, useStoredCSM = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power.paired.test_+3A_p12">p12</code></td>
<td>
<p>The probability of success in first group and failure in second group.  This is the probability of the discordant pair x12</p>
</td></tr>
<tr><td><code id="power.paired.test_+3A_p21">p21</code></td>
<td>
<p>The probability of failure in first group and success in second group.  This is the probability of the discordant pair x21</p>
</td></tr>
<tr><td><code id="power.paired.test_+3A_n">N</code></td>
<td>
<p>The total sample size</p>
</td></tr>
<tr><td><code id="power.paired.test_+3A_alternative">alternative</code></td>
<td>
<p>Indicates the alternative hypothesis: must be either &quot;two.sided&quot;, &quot;less&quot;, or &quot;greater&quot;</p>
</td></tr>
<tr><td><code id="power.paired.test_+3A_alpha">alpha</code></td>
<td>
<p>Significance level</p>
</td></tr>
<tr><td><code id="power.paired.test_+3A_npnumbers">npNumbers</code></td>
<td>
<p>Number: The number of nuisance parameters considered</p>
</td></tr>
<tr><td><code id="power.paired.test_+3A_np.interval">np.interval</code></td>
<td>
<p>Logical: Indicates if a confidence interval on the nuisance parameter should be computed</p>
</td></tr>
<tr><td><code id="power.paired.test_+3A_beta">beta</code></td>
<td>
<p>Number: Confidence level for constructing the interval of nuisance parameters considered.  Only used if np.interval=TRUE</p>
</td></tr>
<tr><td><code id="power.paired.test_+3A_method">method</code></td>
<td>

<p>Indicates the method for finding the more extreme tables:
must be either &quot;UAM&quot;, &quot;UCM&quot;, &quot;UAMCC&quot;, &quot;CSM&quot;, &quot;CM&quot;, &quot;AM&quot;, or &quot;AMCC&quot;
</p>
</td></tr>
<tr><td><code id="power.paired.test_+3A_tsmethod">tsmethod</code></td>
<td>
<p>A character string describing the method to implement two-sided tests</p>
</td></tr>
<tr><td><code id="power.paired.test_+3A_simulation">simulation</code></td>
<td>
<p>Logical: Indicates if the power calculation is exact or estimated by simulation</p>
</td></tr>
<tr><td><code id="power.paired.test_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations run.  Only used if simulation=TRUE</p>
</td></tr>
<tr><td><code id="power.paired.test_+3A_delta">delta</code></td>
<td>
<p>Number: null hypothesis of the difference in proportion</p>
</td></tr>
<tr><td><code id="power.paired.test_+3A_convexity">convexity</code></td>
<td>
<p>Logical: assumes convexity for interval approach.  Only used if np.interval=TRUE</p>
</td></tr>
<tr><td><code id="power.paired.test_+3A_usestoredcsm">useStoredCSM</code></td>
<td>
<p>Logical: uses stored CSM ordering matrix.  Only used if method=&quot;csm&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The power calculations are for paired samples.  All possible tables can be represented by an (N+1) x (N+1) matrix.  There are two ways to calculate the power: simulate the tables under a trinomial distribution or determine the rejection region for all possible tables and calculate the exact power.  The power calculations can be determined for any unconditional exact test in <code><a href="#topic+paired.exact.test">paired.exact.test</a></code>, the Conditional McNemar's (CM) exact test, the Asymptotic McNemar's (AM) test, or Asymptotic McNemar's test with Continuity Correction (AMCC) (note: asymptotic tests are not exact tests).  The power calculations utilize the convexity property, which greatly speeds up computation time (see <code><a href="#topic+paired.reject.region">paired.reject.region</a></code> documentation).
</p>


<h3>Value</h3>

<p>A list with class &quot;power.htest&quot; containing the following components:
</p>
<table role = "presentation">
<tr><td><code>N</code></td>
<td>
<p>The total sample size</p>
</td></tr>
<tr><td><code>p12</code>, <code>p21</code></td>
<td>
<p>The respective discordant probabilities</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>Significance level</p>
</td></tr>
<tr><td><code>power</code></td>
<td>
<p>Power of the test</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>A character string describing the alternative hypothesis</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>Null hypothesis of the difference in proportion</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A character string describing the method to determine more extreme tables</p>
</td></tr>
</table>


<h3>Note</h3>

<p>McNemar's asymptotic tests are not exact test and may have inflated type 1 error rates.  These options were added to compute the power efficiently when using asymptotic tests.
</p>


<h3>Author(s)</h3>

<p>Peter Calhoun</p>


<h3>References</h3>

<p>Berger, R.L. and Sidik, K. (2003) Exact unconditional tests for 2 x 2 matched-pairs design. <em>Statistical Methods in Medical Research</em>, <b>12</b>, 91&ndash;108
</p>


<h3>See Also</h3>

<p><code><a href="#topic+paired.reject.region">paired.reject.region</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Superiority power #
power.paired.test(p12=0.15, p21=0.45, N=40, method="UAM")
## Not run: 
# Ensure that the ExactData R package is available before running the CSM test.
if (requireNamespace("ExactData", quietly = TRUE)) {
power.paired.test(p12=0.15, p21=0.45, N=40, method="CSM")
}

## End(Not run)

# Non-inferiority power #
power.paired.test(p12=0.30, p21=0.30, N=80, method="UAM",
                  alternative="less", delta=0.2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
