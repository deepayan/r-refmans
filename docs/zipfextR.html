<!DOCTYPE html><html><head><title>Help for package zipfextR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {zipfextR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#getInitialValues'><p>Calculates initial values for the parameters of the models.</p></a></li>
<li><a href='#moezipf'><p>The Marshal-Olkin Extended Zipf Distribution (MOEZipf).</p></a></li>
<li><a href='#moezipfFit'><p>MOEZipf parameters estimation.</p></a></li>
<li><a href='#moezipfMean'><p>Expected value.</p></a></li>
<li><a href='#moezipfMoments'><p>Distribution Moments.</p></a></li>
<li><a href='#moezipfVariance'><p>Variance of the MOEZipf distribution.</p></a></li>
<li><a href='#zi_zipfpss'><p>The Zero Inflated Zipf-Poisson Stop Sum Distribution (ZI Zipf-PSS).</p></a></li>
<li><a href='#zi_zipfpssFit'><p>Zero Inflated Zipf-PSS parameters estimation.</p></a></li>
<li><a href='#zipfpe'><p>The Zipf-Poisson Extreme Distribution (Zipf-PE).</p></a></li>
<li><a href='#zipfpeFit'><p>Zipf-PE parameters estimation.</p></a></li>
<li><a href='#zipfpeMean'><p>Expected value of the Zipf-PE distribution.</p></a></li>
<li><a href='#zipfpeMoments'><p>Distribution Moments.</p></a></li>
<li><a href='#zipfpeVariance'><p>Variance of the Zipf-PE distribution.</p></a></li>
<li><a href='#zipfPolylog'><p>The Zipf-Polylog Distribution (Zipf-Polylog).</p></a></li>
<li><a href='#zipfPolylogFit'><p>ZipfPolylog parameters estimation.</p></a></li>
<li><a href='#zipfpolylogMean'><p>Expected value of the ZipfPolylog distribution.</p></a></li>
<li><a href='#zipfpolylogMoments'><p>Moments of the Zipf-Polylog Distribution.</p></a></li>
<li><a href='#zipfpoylogVariance'><p>Variance of the ZipfPolylog distribution.</p></a></li>
<li><a href='#zipfpss'><p>The Zipf-Poisson Stop Sum Distribution (Zipf-PSS).</p></a></li>
<li><a href='#zipfpssFit'><p>Zipf-PSS parameters estimation.</p></a></li>
<li><a href='#zipfpssMean'><p>Expected value of the Zipf-PSS distribution.</p></a></li>
<li><a href='#zipfpssMoments'><p>Distribution Moments.</p></a></li>
<li><a href='#zipfpssVariance'><p>Variance of the Zipf-PSS distribution.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Zipf Extended Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Ariel Duarte-López
    <a href="https://orcid.org/0000-0002-7432-0344"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Marta Pérez-Casany
    <a href="https://orcid.org/0000-0003-3675-6902"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ariel Duarte-López &lt;aduarte@ac.upc.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of four extensions of the Zipf distribution: the Marshall-Olkin 
  Extended Zipf (MOEZipf) Pérez-Casany, M., &amp; Casellas, A. (2013) &lt;<a href="https://doi.org/10.48550/arXiv.1304.4540">doi:10.48550/arXiv.1304.4540</a>&gt;, the Zipf-Poisson Extreme (Zipf-PE), the 
  Zipf-Poisson Stopped Sum (Zipf-PSS) and the Zipf-Polylog distributions. 
  In log-log scale, the two first extensions allow for top-concavity 
  and top-convexity while the third one only allows for top-concavity. 
  All the extensions maintain the linearity associated with the Zipf model in the tail.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.0.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>VGAM (&ge; 0.9.8), tolerance(&ge; 1.2.0), copula(&ge; 0.999-18)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ardlop/zipfextR">https://github.com/ardlop/zipfextR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ardlop/zipfextR/issues">https://github.com/ardlop/zipfextR/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-07-07 07:30:49 UTC; ariel</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-07-07 08:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='getInitialValues'>Calculates initial values for the parameters of the models.</h2><span id='topic+getInitialValues'></span>

<h3>Description</h3>

<p>The selection of appropiate initial values to compute the maximum likelihood estimations
reduces the number of iterations which in turn, reduces the computation time.
The initial values proposed by this function are computed using the first two empirical
frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInitialValues(data, model = "zipf")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getInitialValues_+3A_data">data</code></td>
<td>
<p>Matrix of count data.</p>
</td></tr>
<tr><td><code id="getInitialValues_+3A_model">model</code></td>
<td>
<p>Specify the model that requests the initial values (default='zipf').</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>data</code> is a two column matrix with the first column containing the observations and
the second column containing their frequencies. The argument <code>model</code> refers to the selected model of those
implemented in the package. The possible values are: <em>zipf</em>, <em>moezipf</em>, <em>zipfpe</em>,
<em>zipfpss</em> or its zero truncated version <em>zt_zipfpss</em>. By default, the selected model is the Zipf one.
</p>
<p>For the MOEZipf, the Zipf-PE and the zero truncated Zipf-PSS models that contain the Zipf model as
a particular case, the <code class="reqn">\beta</code> value will correspond to the one of the Zipf model (i.e. <code class="reqn">\beta = 1</code> for the MOEZipf,
<code class="reqn">\beta = 0</code> for the Zipf-PE and <code class="reqn">\lambda = 0</code> for the zero truncated Zipf-PSS model) and the initial value for <code class="reqn">\alpha</code>
is set to be equal to:
</p>
<p style="text-align: center;"><code class="reqn">\alpha_0 = log_2 \big (\frac{f_r(1)}{f_r(2)} \big),</code>
</p>

<p>where <code class="reqn">f_r(1)</code> and <code class="reqn">f_r(2)</code> are the empirical relative frequencies of one and two.
This value is obtained equating the two empirical probabilities to their theoritical ones.
</p>
<p>For the case of the Zipf-PSS the proposed initial values are obtained equating the empirical probability of zero
to the theoretical one which gives:
</p>
<p style="text-align: center;"><code class="reqn">\lambda_0 = -log(f_r(0)),</code>
</p>

<p>where <code class="reqn">f_r(0)</code> is the empirical relative frequency of zero. The initial value of <code class="reqn">\alpha</code> is obtained
equating the ratio of the theoretical probabilities at zero and one to the empirical ones. This gives place to:
</p>
<p style="text-align: center;"><code class="reqn">\alpha_0 = \zeta^{-1}(\lambda_0 * f_r(0)/f_r(1)),</code>
</p>

<p>where <code class="reqn">f_r(0)</code> and <code class="reqn">f_r(1)</code> are the empirical relative frequencies associated to the values 0 and 1 respectively.
The inverse of the Riemman Zeta function is obtained using the <code>optim</code> routine.
</p>


<h3>Value</h3>

<p>Returns the initial values of the parameters for a given distribution.
</p>


<h3>References</h3>

<p> Güney, Y., Tuaç, Y., &amp; Arslan, O. (2016). Marshall–Olkin distribution: parameter estimation and
application to cancer data. Journal of Applied Statistics, 1-13.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- rmoezipf(100, 2.5, 1.3)
data &lt;- as.data.frame(table(data))
data[,1] &lt;- as.numeric(levels(data[,1])[data[,1]])
initials &lt;- getInitialValues(data, model='zipf')
</code></pre>

<hr>
<h2 id='moezipf'>The Marshal-Olkin Extended Zipf Distribution (MOEZipf).</h2><span id='topic+moezipf'></span><span id='topic+dmoezipf'></span><span id='topic+pmoezipf'></span><span id='topic+qmoezipf'></span><span id='topic+rmoezipf'></span>

<h3>Description</h3>

<p>Probability mass function, cumulative distribution function, quantile function and random number
generation for the MOEZipf distribution with parameters <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>. The support of the MOEZipf
distribution are the strictly positive integer numbers large or equal than one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmoezipf(x, alpha, beta, log = FALSE)

pmoezipf(q, alpha, beta, log.p = FALSE, lower.tail = TRUE)

qmoezipf(p, alpha, beta, log.p = FALSE, lower.tail = TRUE)

rmoezipf(n, alpha, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moezipf_+3A_x">x</code>, <code id="moezipf_+3A_q">q</code></td>
<td>
<p>Vector of positive integer values.</p>
</td></tr>
<tr><td><code id="moezipf_+3A_alpha">alpha</code></td>
<td>
<p>Value of the <code class="reqn">\alpha</code> parameter (<code class="reqn">\alpha &gt; 1</code> ).</p>
</td></tr>
<tr><td><code id="moezipf_+3A_beta">beta</code></td>
<td>
<p>Value of the <code class="reqn">\beta</code> parameter (<code class="reqn">\beta &gt; 0</code> ).</p>
</td></tr>
<tr><td><code id="moezipf_+3A_log">log</code>, <code id="moezipf_+3A_log.p">log.p</code></td>
<td>
<p>Logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="moezipf_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if TRUE (default), probabilities are <code class="reqn">P[X \leq x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="moezipf_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="moezipf_+3A_n">n</code></td>
<td>
<p>Number of random values to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>probability mass function</em> at a positive integer value <code class="reqn">x</code> of the MOEZipf distribution with
parameters <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> is computed as follows:
</p>
<p style="text-align: center;"><code class="reqn">p(x | \alpha, \beta) = \frac{x^{-\alpha} \beta \zeta(\alpha) }{[\zeta(\alpha) - \bar{\beta} \zeta (\alpha, x)] [\zeta (\alpha) - \bar{\beta} \zeta (\alpha, x + 1)]},\, x = 1,2,...,\, \alpha &gt; 1, \beta &gt; 0, </code>
</p>

<p>where <code class="reqn">\zeta(\alpha)</code> is the Riemann-zeta function at <code class="reqn">\alpha</code>, <code class="reqn">\zeta(\alpha, x)</code>
is the Hurtwitz zeta function with arguments <code class="reqn">\alpha</code> and x, and <code class="reqn">\bar{\beta} = 1 - \beta</code>.
</p>
<p>The <em>cumulative distribution function</em>, at a given positive integer value <code class="reqn">x</code>,
is computed as <code class="reqn">F(x) = 1 - S(x)</code>, where the survival function <code class="reqn">S(x)</code> is equal to:
</p>
<p style="text-align: center;"><code class="reqn">S(x) = \frac{\beta\, \zeta(\alpha, x + 1)}{\zeta(\alpha) - \bar{\beta}\,\zeta(\alpha, x + 1)},\, x = 1, 2, .. </code>
</p>

<p>The quantile of the MOEZipf<code class="reqn">(\alpha, \beta)</code> distribution of a given probability value p
is equal to the quantile of the Zipf<code class="reqn">(\alpha)</code> distribution at the value:
</p>
<p style="text-align: center;"><code class="reqn">p\prime = \frac{p\,\beta}{1 + p\,(\beta - 1)}</code>
</p>

<p>The quantiles of the Zipf<code class="reqn">(\alpha)</code> distribution are computed by means of the <em>tolerance</em>
package.
</p>
<p>To generate random data from a MOEZipf one applies the <em>quantile</em> function over <em>n</em> values randomly generated
from an Uniform distribution in the interval (0, 1).
</p>


<h3>Value</h3>


<p><code>dmoezipf</code> gives the probability mass function,
<code>pmoezipf</code> gives the cumulative distribution function,
<code>qmoezipf</code> gives the quantile function, and
<code>rmoezipf</code> generates random values from a MOEZipf distribution.
</p>


<h3>References</h3>


<p>Casellas, A. (2013) <em>La distribució Zipf Estesa segons la transformació Marshall-Olkin</em>. Universitat Politécnica de Catalunya.
</p>
<p>Devroye L. (1986) Non-Uniform Random Variate Generation. Springer, New York, NY.
</p>
<p>Duarte-López, A., Prat-Pérez, A., &amp; Pérez-Casany, M. (2015). <em>Using the Marshall-Olkin Extended Zipf Distribution in Graph Generation</em>. European Conference on Parallel Processing, pp. 493-502, Springer International Publishing.
</p>
<p>Pérez-Casany, M. and Casellas, A. (2013) <em>Marshall-Olkin Extended Zipf Distribution</em>. arXiv preprint arXiv:1304.4540.
</p>
<p>Young, D. S. (2010). <em>Tolerance: an R package for estimating tolerance intervals</em>. Journal of Statistical Software, 36(5), 1-39.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>dmoezipf(1:10, 2.5, 1.3)
pmoezipf(1:10, 2.5, 1.3)
qmoezipf(0.56, 2.5, 1.3)
rmoezipf(10, 2.5, 1.3)

</code></pre>

<hr>
<h2 id='moezipfFit'>MOEZipf parameters estimation.</h2><span id='topic+moezipfFit'></span><span id='topic+residuals.moezipfR'></span><span id='topic+fitted.moezipfR'></span><span id='topic+coef.moezipfR'></span><span id='topic+plot.moezipfR'></span><span id='topic+print.moezipfR'></span><span id='topic+summary.moezipfR'></span><span id='topic+logLik.moezipfR'></span><span id='topic+AIC.moezipfR'></span><span id='topic+BIC.moezipfR'></span>

<h3>Description</h3>

<p>For a given sample of strictly positive integer numbers,  usually of the type of ranking data or
frequencies of frequencies data, estimates the parameters of the MOEZipf distribution by means of
the maximum likelihood method. The input data should be provided as a frequency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moezipfFit(data, init_alpha = NULL, init_beta = NULL, level = 0.95,
  ...)

## S3 method for class 'moezipfR'
residuals(object, ...)

## S3 method for class 'moezipfR'
fitted(object, ...)

## S3 method for class 'moezipfR'
coef(object, ...)

## S3 method for class 'moezipfR'
plot(x, ...)

## S3 method for class 'moezipfR'
print(x, ...)

## S3 method for class 'moezipfR'
summary(object, ...)

## S3 method for class 'moezipfR'
logLik(object, ...)

## S3 method for class 'moezipfR'
AIC(object, ...)

## S3 method for class 'moezipfR'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moezipfFit_+3A_data">data</code></td>
<td>
<p>Matrix of count data in form of a table of frequencies.</p>
</td></tr>
<tr><td><code id="moezipfFit_+3A_init_alpha">init_alpha</code></td>
<td>
<p>Initial value of <code class="reqn">\alpha</code> parameter (<code class="reqn">\alpha &gt; 1</code>).</p>
</td></tr>
<tr><td><code id="moezipfFit_+3A_init_beta">init_beta</code></td>
<td>
<p>Initial value of <code class="reqn">\beta</code> parameter (<code class="reqn">\beta &gt; 0</code>).</p>
</td></tr>
<tr><td><code id="moezipfFit_+3A_level">level</code></td>
<td>
<p>Confidence level used to calculate the confidence intervals (default 0.95).</p>
</td></tr>
<tr><td><code id="moezipfFit_+3A_...">...</code></td>
<td>
<p>Further arguments to the generic functions. The extra arguments are passing to the <em><a href="stats.html#topic+optim">optim</a></em> function.</p>
</td></tr>
<tr><td><code id="moezipfFit_+3A_object">object</code></td>
<td>
<p>An object from class &quot;moezipfR&quot; (output of <em>moezipfFit</em> function).</p>
</td></tr>
<tr><td><code id="moezipfFit_+3A_x">x</code></td>
<td>
<p>An object from class &quot;moezipfR&quot; (output of <em>moezipfFit</em> function).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>data</code> is a two column matrix with the first column containing the observations and
the second column containing their frequencies.
</p>
<p>The log-likelihood function is equal to:
</p>
<p style="text-align: center;"><code class="reqn">l(\alpha, \beta; x) = -\alpha \sum_{i = 1} ^m f_{a}(x_{i}) log(x_{i}) + N (log(\beta) + \log(\zeta(\alpha)))</code>
</p>

<p style="text-align: center;"><code class="reqn"> - \sum_{i = 1} ^m f_a(x_i) log[(\zeta(\alpha) - \bar{\beta}\zeta(\alpha, x_i)(\zeta(\alpha) - \bar{\beta}\zeta(\alpha, x_i + 1)))], </code>
</p>

<p>where <code class="reqn">f_{a}(x_i)</code> is the absolute frequency of <code class="reqn">x_i</code>, <code class="reqn">m</code> is the number of different values in the sample and <code class="reqn">N</code> is the sample size,
i.e.  <code class="reqn">N = \sum_{i = 1} ^m x_i f_a(x_i)</code>.
</p>
<p>By default the initial values of the parameters are computed using the function <code>getInitialValues</code>.
</p>
<p>The function <em><a href="stats.html#topic+optim">optim</a></em> is used to estimate the parameters.
</p>


<h3>Value</h3>

<p>Returns a <em>moezipfR</em> object composed by the maximum likelihood parameter estimations
jointly with their standard deviation and confidence intervals. It also contains
the value of the log-likelihood at the maximum likelihood estimator.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getInitialValues">getInitialValues</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- rmoezipf(100, 2.5, 1.3)
data &lt;- as.data.frame(table(data))
data[,1] &lt;- as.numeric(as.character(data[,1]))
data[,2] &lt;- as.numeric(as.character(data[,2]))
initValues &lt;- getInitialValues(data, model='moezipf')
obj &lt;- moezipfFit(data, init_alpha = initValues$init_alpha, init_beta = initValues$init_beta)
</code></pre>

<hr>
<h2 id='moezipfMean'>Expected value.</h2><span id='topic+moezipfMean'></span>

<h3>Description</h3>

<p>Computes the expected value of the MOEZipf distribution for given values of parameters
<code class="reqn">\alpha</code> and <code class="reqn">\beta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moezipfMean(alpha, beta, tolerance = 10^(-4))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moezipfMean_+3A_alpha">alpha</code></td>
<td>
<p>Value of the <code class="reqn">\alpha</code> parameter (<code class="reqn">\alpha &gt; 2</code>).</p>
</td></tr>
<tr><td><code id="moezipfMean_+3A_beta">beta</code></td>
<td>
<p>Value of the <code class="reqn">\beta</code> parameter (<code class="reqn">\beta &gt; 0</code>).</p>
</td></tr>
<tr><td><code id="moezipfMean_+3A_tolerance">tolerance</code></td>
<td>
<p>Tolerance used in the calculations (default = <code class="reqn">10^{-4}</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean of the distribution only exists for <code class="reqn">\alpha</code> strictly greater than 2.
It is computed by calculating the partial sums of the serie, and stopping when two
consecutive partial sums differ less than the <code>tolerance</code> value.
The value of the last partial sum is returned.
</p>


<h3>Value</h3>

<p>A positive real value corresponding to the mean value of the distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>moezipfMean(2.5, 1.3)
moezipfMean(2.5, 1.3, 10^(-3))
</code></pre>

<hr>
<h2 id='moezipfMoments'>Distribution Moments.</h2><span id='topic+moezipfMoments'></span>

<h3>Description</h3>

<p>General function to compute the k-th moment of the MOEZipf distribution for any integer value <code class="reqn">k \geq 1</code>,
when it exists. The k-th moment exists if and only if  <code class="reqn">\alpha &gt; k + 1</code>.
For k = 1, this function returns the same value as the <a href="#topic+moezipfMean">moezipfMean</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moezipfMoments(k, alpha, beta, tolerance = 10^(-4))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moezipfMoments_+3A_k">k</code></td>
<td>
<p>Order of the moment to compute.</p>
</td></tr>
<tr><td><code id="moezipfMoments_+3A_alpha">alpha</code></td>
<td>
<p>Value of the <code class="reqn">\alpha</code> parameter (<code class="reqn">\alpha &gt; k + 1</code>).</p>
</td></tr>
<tr><td><code id="moezipfMoments_+3A_beta">beta</code></td>
<td>
<p>Value of the <code class="reqn">\beta</code> parameter (<code class="reqn">\beta &gt; 0</code>).</p>
</td></tr>
<tr><td><code id="moezipfMoments_+3A_tolerance">tolerance</code></td>
<td>
<p>Tolerance used in the calculations (default = <code class="reqn">10^{-4}</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The k-th moment is computed by calculating the partial sums of the serie, and stopping when two
consecutive partial sums differ less than the <code>tolerance</code> value.
The value of the last partial sum is returned.
</p>


<h3>Value</h3>

<p>A positive real value corresponding to the k-th moment of the distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>moezipfMoments(3, 4.5, 1.3)
moezipfMoments(3, 4.5, 1.3,  1*10^(-3))
</code></pre>

<hr>
<h2 id='moezipfVariance'>Variance of the MOEZipf distribution.</h2><span id='topic+moezipfVariance'></span>

<h3>Description</h3>

<p>Computes the variance of the MOEZipf distribution for given values of <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moezipfVariance(alpha, beta, tolerance = 10^(-4))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moezipfVariance_+3A_alpha">alpha</code></td>
<td>
<p>Value of the <code class="reqn">\alpha</code> parameter (<code class="reqn">\alpha &gt; 3</code>).</p>
</td></tr>
<tr><td><code id="moezipfVariance_+3A_beta">beta</code></td>
<td>
<p>Value of the <code class="reqn">\beta</code> parameter (<code class="reqn">\beta &gt; 0</code>).</p>
</td></tr>
<tr><td><code id="moezipfVariance_+3A_tolerance">tolerance</code></td>
<td>
<p>Tolerance used in the calculations. (default = <code class="reqn">10^{-4}</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variance of the distribution only exists for <code class="reqn">\alpha</code> strictly greater than 3.
</p>


<h3>Value</h3>

<p>A positive real value corresponding to the variance of the distribution.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+moezipfMoments">moezipfMoments</a></code>, <code><a href="#topic+moezipfMean">moezipfMean</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>moezipfVariance(3.5, 1.3)
</code></pre>

<hr>
<h2 id='zi_zipfpss'>The Zero Inflated Zipf-Poisson Stop Sum Distribution (ZI Zipf-PSS).</h2><span id='topic+zi_zipfpss'></span><span id='topic+d_zi_zipfpss'></span>

<h3>Description</h3>

<p>Probability mass function for the zero inflated Zipf-PSS distribution with parameters <code class="reqn">\alpha</code>, <code class="reqn">\lambda</code> and <code class="reqn">w</code>.
The support of thezero inflated Zipf-PSS distribution are the positive integer numbers including the zero value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_zi_zipfpss(x, alpha, lambda, w, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zi_zipfpss_+3A_x">x</code></td>
<td>
<p>Vector of positive integer values.</p>
</td></tr>
<tr><td><code id="zi_zipfpss_+3A_alpha">alpha</code></td>
<td>
<p>Value of the <code class="reqn">\alpha</code> parameter (<code class="reqn">\alpha &gt; 1</code> ).</p>
</td></tr>
<tr><td><code id="zi_zipfpss_+3A_lambda">lambda</code></td>
<td>
<p>Value of the <code class="reqn">\lambda</code> parameter (<code class="reqn">\lambda &gt; 0</code> ).</p>
</td></tr>
<tr><td><code id="zi_zipfpss_+3A_w">w</code></td>
<td>
<p>Value of the <code class="reqn">w</code> parameter (0 &lt; <code class="reqn">w &lt; 1</code> ).</p>
</td></tr>
<tr><td><code id="zi_zipfpss_+3A_log">log</code></td>
<td>
<p>Logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The support of the <code class="reqn">\lambda</code> parameter increases when the distribution is truncated at zero being
<code class="reqn">\lambda \geq 0</code>. It has been proved that when <code class="reqn">\lambda = 0</code> one has the degenerated version of the distribution at one.
</p>


<h3>References</h3>


<p>Panjer, H. H. (1981). Recursive evaluation of a family of compound
distributions. ASTIN Bulletin: The Journal of the IAA, 12(1), 22-26.
</p>
<p>Sundt, B., &amp; Jewell, W. S. (1981). Further results on recursive evaluation of
compound distributions. ASTIN Bulletin: The Journal of the IAA, 12(1), 27-39.

</p>

<hr>
<h2 id='zi_zipfpssFit'>Zero Inflated Zipf-PSS parameters estimation.</h2><span id='topic+zi_zipfpssFit'></span><span id='topic+residuals.zi_zipfpssR'></span><span id='topic+fitted.zi_zipfpssR'></span><span id='topic+coef.zi_zipfpssR'></span><span id='topic+plot.zi_zipfpssR'></span><span id='topic+print.zi_zipfpssR'></span><span id='topic+summary.zi_zipfpssR'></span><span id='topic+logLik.zi_zipfpssR'></span><span id='topic+AIC.zi_zipfpssR'></span><span id='topic+BIC.zi_zipfpssR'></span>

<h3>Description</h3>

<p>For a given sample of strictly positive integer numbers,  usually of the type of ranking data or
frequencies of frequencies data, estimates the parameters of the zero inflated Zipf-PSS distribution by means of
the maximum likelihood method. The input data should be provided as a frequency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zi_zipfpssFit(data, init_alpha = 1.5, init_lambda = 1.5,
  init_w = 0.1, level = 0.95, ...)

## S3 method for class 'zi_zipfpssR'
residuals(object, ...)

## S3 method for class 'zi_zipfpssR'
fitted(object, ...)

## S3 method for class 'zi_zipfpssR'
coef(object, ...)

## S3 method for class 'zi_zipfpssR'
plot(x, ...)

## S3 method for class 'zi_zipfpssR'
print(x, ...)

## S3 method for class 'zi_zipfpssR'
summary(object, ...)

## S3 method for class 'zi_zipfpssR'
logLik(object, ...)

## S3 method for class 'zi_zipfpssR'
AIC(object, ...)

## S3 method for class 'zi_zipfpssR'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zi_zipfpssFit_+3A_data">data</code></td>
<td>
<p>Matrix of count data in form of table of frequencies.</p>
</td></tr>
<tr><td><code id="zi_zipfpssFit_+3A_init_alpha">init_alpha</code></td>
<td>
<p>Initial value of <code class="reqn">\alpha</code> parameter (<code class="reqn">\alpha &gt; 1</code>).</p>
</td></tr>
<tr><td><code id="zi_zipfpssFit_+3A_init_lambda">init_lambda</code></td>
<td>
<p>Initial value of <code class="reqn">\lambda</code> parameter (<code class="reqn">\lambda &gt; 0</code>).</p>
</td></tr>
<tr><td><code id="zi_zipfpssFit_+3A_init_w">init_w</code></td>
<td>
<p>Initial value of <code class="reqn">w</code> parameter (<code class="reqn">0 &lt; w &lt; 1</code>).</p>
</td></tr>
<tr><td><code id="zi_zipfpssFit_+3A_level">level</code></td>
<td>
<p>Confidence level used to calculate the confidence intervals (default 0.95).</p>
</td></tr>
<tr><td><code id="zi_zipfpssFit_+3A_...">...</code></td>
<td>
<p>Further arguments to the generic functions. The extra arguments are passing
to the <em><a href="stats.html#topic+optim">optim</a></em> function.</p>
</td></tr>
<tr><td><code id="zi_zipfpssFit_+3A_object">object</code></td>
<td>
<p>An object from class &quot;zpssR&quot; (output of <em>zipfpssFit</em> function).</p>
</td></tr>
<tr><td><code id="zi_zipfpssFit_+3A_x">x</code></td>
<td>
<p>An object from class &quot;zpssR&quot; (output of <em>zipfpssFit</em> function).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>data</code> is a two column matrix with the first column containing the observations and
the second column containing their frequencies.
</p>


<h3>References</h3>


<p>Panjer, H. H. (1981). Recursive evaluation of a family of compound
distributions. ASTIN Bulletin: The Journal of the IAA, 12(1), 22-26.
</p>
<p>Sundt, B., &amp; Jewell, W. S. (1981). Further results on recursive evaluation of
compound distributions. ASTIN Bulletin: The Journal of the IAA, 12(1), 27-39.

</p>


<h3>See Also</h3>

<p><code><a href="#topic+getInitialValues">getInitialValues</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- rzipfpss(100, 2.5, 1.3)
data &lt;- as.data.frame(table(data))
data[,1] &lt;- as.numeric(as.character(data[,1]))
data[,2] &lt;- as.numeric(as.character(data[,2]))
obj &lt;- zipfpssFit(data, init_alpha = 1.5, init_lambda = 1.5)
</code></pre>

<hr>
<h2 id='zipfpe'>The Zipf-Poisson Extreme Distribution (Zipf-PE).</h2><span id='topic+zipfpe'></span><span id='topic+dzipfpe'></span><span id='topic+pzipfpe'></span><span id='topic+qzipfpe'></span><span id='topic+rzipfpe'></span>

<h3>Description</h3>

<p>Probability mass function, cumulative distribution function, quantile function and random number
generation for the Zipf-PE distribution with parameters <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>. The support of the Zipf-PE
distribution are the strictly positive integer numbers large or equal than one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dzipfpe(x, alpha, beta, log = FALSE)

pzipfpe(q, alpha, beta, log.p = FALSE, lower.tail = TRUE)

qzipfpe(p, alpha, beta, log.p = FALSE, lower.tail = TRUE)

rzipfpe(n, alpha, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zipfpe_+3A_x">x</code>, <code id="zipfpe_+3A_q">q</code></td>
<td>
<p>Vector of positive integer values.</p>
</td></tr>
<tr><td><code id="zipfpe_+3A_alpha">alpha</code></td>
<td>
<p>Value of the <code class="reqn">\alpha</code> parameter (<code class="reqn">\alpha &gt; 1</code> ).</p>
</td></tr>
<tr><td><code id="zipfpe_+3A_beta">beta</code></td>
<td>
<p>Value of the <code class="reqn">\beta</code> parameter (<code class="reqn">\beta\in (-\infty, +\infty)</code> ).</p>
</td></tr>
<tr><td><code id="zipfpe_+3A_log">log</code>, <code id="zipfpe_+3A_log.p">log.p</code></td>
<td>
<p>Logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="zipfpe_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if TRUE (default), probabilities are <code class="reqn">P[X \leq x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="zipfpe_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="zipfpe_+3A_n">n</code></td>
<td>
<p>Number of random values to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>probability mass function</em> of the Zipf-PE distribution with parameters <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>
at a positive integer value <code class="reqn">x</code> is computed as follows:
</p>
<p style="text-align: center;"><code class="reqn">p(x | \alpha, \beta) = \frac{e^{\beta (1 - \frac{\zeta(\alpha, x)}{\zeta(\alpha)})} (e^{\beta \frac{x^{-\alpha}}{\zeta(\alpha)}} - 1)}
{e^{\beta} - 1},\, x= 1,2,...,\, \alpha &gt; 1,\, -\infty &lt; \beta &lt; +\infty,</code>
</p>

<p>where <code class="reqn">\zeta(\alpha)</code> is the Riemann-zeta function at <code class="reqn">\alpha</code>, and <code class="reqn">\zeta(\alpha, x)</code>
is the Hurtwitz zeta function with arguments <code class="reqn">\alpha</code> and x.
</p>
<p>The <em>cumulative distribution function</em> at a given positive
integer value <code class="reqn">x</code>, <code class="reqn">F(x)</code>, is equal to:
</p>
<p style="text-align: center;"><code class="reqn">F(x) = \frac{e^{\beta (1 - \frac{\zeta(\alpha, x + 1)}{\zeta(\alpha)})} - 1}{e^{\beta} -1}</code>
</p>

<p>The quantile of the Zipf-PE<code class="reqn">(\alpha, \beta)</code> distribution of a given probability value p
is equal to the quantile of the Zipf<code class="reqn">(\alpha)</code> distribution at the value:
</p>
<p style="text-align: center;"><code class="reqn">p\prime = \frac{log(p\, (e^{\beta} - 1) + 1)}{\beta}</code>
</p>

<p>The quantiles of the Zipf<code class="reqn">(\alpha)</code> distribution are computed by means of the <em>tolerance</em>
package.
</p>
<p>To generate random data from a Zipf-PE one applies the <em>quantile</em> function over <em>n</em> values randomly generated
from an Uniform distribution in the interval (0, 1).
</p>


<h3>Value</h3>


<p><code>dzipfpe</code> gives the probability mass function,
<code>pzipfpe</code> gives the cumulative function,
<code>qzipfpe</code> gives the quantile function, and
<code>rzipfpe</code> generates random values from a Zipf-PE distribution.  
</p>


<h3>References</h3>


<p>Young, D. S. (2010). <em>Tolerance: an R package for estimating tolerance intervals</em>. Journal of Statistical Software, 36(5), 1-39.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>dzipfpe(1:10, 2.5, -1.5)
pzipfpe(1:10, 2.5, -1.5)
qzipfpe(0.56, 2.5, 1.3)
rzipfpe(10, 2.5, 1.3)

</code></pre>

<hr>
<h2 id='zipfpeFit'>Zipf-PE parameters estimation.</h2><span id='topic+zipfpeFit'></span><span id='topic+residuals.zipfpeR'></span><span id='topic+fitted.zipfpeR'></span><span id='topic+coef.zipfpeR'></span><span id='topic+plot.zipfpeR'></span><span id='topic+print.zipfpeR'></span><span id='topic+summary.zipfpeR'></span><span id='topic+logLik.zipfpeR'></span><span id='topic+AIC.zipfpeR'></span><span id='topic+BIC.zipfpeR'></span>

<h3>Description</h3>

<p>For a given sample of strictly positive integer values,  usually of the type of ranking data or
frequencies of frequencies data, estimates the parameters of the Zipf-PE
distribution by means of the maximum likelihood method. The input data should be provided as a frequency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zipfpeFit(data, init_alpha = NULL, init_beta = NULL, level = 0.95,
  ...)

## S3 method for class 'zipfpeR'
residuals(object, ...)

## S3 method for class 'zipfpeR'
fitted(object, ...)

## S3 method for class 'zipfpeR'
coef(object, ...)

## S3 method for class 'zipfpeR'
plot(x, ...)

## S3 method for class 'zipfpeR'
print(x, ...)

## S3 method for class 'zipfpeR'
summary(object, ...)

## S3 method for class 'zipfpeR'
logLik(object, ...)

## S3 method for class 'zipfpeR'
AIC(object, ...)

## S3 method for class 'zipfpeR'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zipfpeFit_+3A_data">data</code></td>
<td>
<p>Matrix of count data in form of table of frequencies.</p>
</td></tr>
<tr><td><code id="zipfpeFit_+3A_init_alpha">init_alpha</code></td>
<td>
<p>Initial value of <code class="reqn">\alpha</code> parameter (<code class="reqn">\alpha &gt; 1</code>).</p>
</td></tr>
<tr><td><code id="zipfpeFit_+3A_init_beta">init_beta</code></td>
<td>
<p>Initial value of <code class="reqn">\beta</code> parameter (<code class="reqn">\beta \in (-\infty, +\infty)</code>).</p>
</td></tr>
<tr><td><code id="zipfpeFit_+3A_level">level</code></td>
<td>
<p>Confidence level used to calculate the confidence intervals (default 0.95).</p>
</td></tr>
<tr><td><code id="zipfpeFit_+3A_...">...</code></td>
<td>
<p>Further arguments to the generic functions.The extra arguments are passing
to the <em><a href="stats.html#topic+optim">optim</a></em> function.</p>
</td></tr>
<tr><td><code id="zipfpeFit_+3A_object">object</code></td>
<td>
<p>An object from class &quot;zpeR&quot; (output of <em>zipfpeFit</em> function).</p>
</td></tr>
<tr><td><code id="zipfpeFit_+3A_x">x</code></td>
<td>
<p>An object from class &quot;zpeR&quot; (output of <em>zipfpeFit</em> function).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>data</code> is a two column matrix with the first column containing the observations and
the second column containing their frequencies.
</p>
<p>The log-likelihood function is equal to:
</p>
<p style="text-align: center;"><code class="reqn">l(\alpha, \beta; x) = \beta\, (N - \zeta(\alpha)^{-1}\, \sum_{i = 1} ^m  f_{a}(x_{i})\, \zeta(\alpha, x_i)) +
\sum_{i = 1} ^m f_{a}(x_{i})\,  log \left( \frac{e^{\frac{\beta\, x_{i}^{-\alpha}}{\zeta(\alpha)}} - 1}{e^{\beta} - 1} \right), </code>
</p>

<p>where <code class="reqn">f_{a}(x_i)</code> is the absolute frequency of <code class="reqn">x_i</code>, <code class="reqn">m</code> is the number of different values in the sample and <code class="reqn">N</code> is the sample size,
i.e.  <code class="reqn">N = \sum_{i = 1} ^m x_i f_a(x_i)</code>.
</p>
<p>By default the initial values of the parameters are computed using the function <code>getInitialValues</code>.
</p>
<p>The function <em><a href="stats.html#topic+optim">optim</a></em> is used to estimate the parameters.
</p>


<h3>Value</h3>

<p>Returns an object composed by the maximum likelihood parameter estimations
jointly with their standard deviation and confidence intervals. It also contains
the value of the log-likelihood at the maximum likelihood estimator.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getInitialValues">getInitialValues</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- rzipfpe(100, 2.5, 1.3)
data &lt;- as.data.frame(table(data))
data[,1] &lt;- as.numeric(as.character(data[,1]))
data[,2] &lt;- as.numeric(as.character(data[,2]))
initValues &lt;- getInitialValues(data, model='zipfpe')
obj &lt;- zipfpeFit(data, init_alpha = initValues$init_alpha, init_beta = initValues$init_beta)
</code></pre>

<hr>
<h2 id='zipfpeMean'>Expected value of the Zipf-PE distribution.</h2><span id='topic+zipfpeMean'></span>

<h3>Description</h3>

<p>Computes the expected value of the Zipf-PE distribution for given values of parameters
<code class="reqn">\alpha</code> and <code class="reqn">\beta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zipfpeMean(alpha, beta, tolerance = 10^(-4))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zipfpeMean_+3A_alpha">alpha</code></td>
<td>
<p>Value of the <code class="reqn">\alpha</code> parameter (<code class="reqn">\alpha &gt; 2</code>).</p>
</td></tr>
<tr><td><code id="zipfpeMean_+3A_beta">beta</code></td>
<td>
<p>Value of the <code class="reqn">\beta</code> parameter (<code class="reqn">\beta \in (-\infty, +\infty)</code>).</p>
</td></tr>
<tr><td><code id="zipfpeMean_+3A_tolerance">tolerance</code></td>
<td>
<p>Tolerance used in the calculations (default = <code class="reqn">10^{-4}</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean of the distribution only exists for <code class="reqn">\alpha</code> strictly greater than 2.
It is computed by calculating the partial sums of the serie, and stopping when two
consecutive partial sums differ less than the <code>tolerance</code> value.
The value of the last partial sum is returned.
</p>


<h3>Value</h3>

<p>A positive real value corresponding to the mean value of the Zipf-PE distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zipfpeMean(2.5, 1.3)
zipfpeMean(2.5, 1.3, 10^(-3))
</code></pre>

<hr>
<h2 id='zipfpeMoments'>Distribution Moments.</h2><span id='topic+zipfpeMoments'></span>

<h3>Description</h3>

<p>General function to compute the k-th moment of the Zipf-PE distribution for any integer value <code class="reqn">k \geq 1</code>,
when it exists. The k-th moment exists if and only if  <code class="reqn">\alpha &gt; k + 1</code>.
For k = 1, this function returns the same value as the <a href="#topic+zipfpeMean">zipfpeMean</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zipfpeMoments(k, alpha, beta, tolerance = 10^(-4))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zipfpeMoments_+3A_k">k</code></td>
<td>
<p>Order of the moment to compute.</p>
</td></tr>
<tr><td><code id="zipfpeMoments_+3A_alpha">alpha</code></td>
<td>
<p>Value of the <code class="reqn">\alpha</code> parameter (<code class="reqn">\alpha &gt; k + 1</code>).</p>
</td></tr>
<tr><td><code id="zipfpeMoments_+3A_beta">beta</code></td>
<td>
<p>Value of the <code class="reqn">\beta</code> parameter (<code class="reqn">\beta \in (-\infty, +\infty)</code>).</p>
</td></tr>
<tr><td><code id="zipfpeMoments_+3A_tolerance">tolerance</code></td>
<td>
<p>Tolerance used in the calculations (default = <code class="reqn">10^{-4}</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The k-th moment of the Zipf-PE distribution is finite for <code class="reqn">\alpha</code> values strictly greater than <code class="reqn">k + 1</code>.
It is computed by calculating the partial sums of the serie, and stopping when two
consecutive partial sums differ less than the <code>tolerance</code> value.
The value of the last partial sum is returned.
</p>


<h3>Value</h3>

<p>A positive real value corresponding to the k-th moment of the distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zipfpeMoments(3, 4.5, 1.3)
zipfpeMoments(3, 4.5, 1.3,  1*10^(-3))
</code></pre>

<hr>
<h2 id='zipfpeVariance'>Variance of the Zipf-PE distribution.</h2><span id='topic+zipfpeVariance'></span>

<h3>Description</h3>

<p>Computes the variance of the Zipf-PE distribution for given values of <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zipfpeVariance(alpha, beta, tolerance = 10^(-4))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zipfpeVariance_+3A_alpha">alpha</code></td>
<td>
<p>Value of the <code class="reqn">\alpha</code> parameter (<code class="reqn">\alpha &gt; 3</code>).</p>
</td></tr>
<tr><td><code id="zipfpeVariance_+3A_beta">beta</code></td>
<td>
<p>Value of the <code class="reqn">\beta</code> parameter (<code class="reqn">\beta \in (-\infty, +\infty)</code>).</p>
</td></tr>
<tr><td><code id="zipfpeVariance_+3A_tolerance">tolerance</code></td>
<td>
<p>Tolerance used in the calculations. (default = <code class="reqn">10^{-4}</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variance of the distribution only exists for <code class="reqn">\alpha</code> strictly greater than 3.
</p>


<h3>Value</h3>

<p>A positive real value corresponding to the variance of the distribution.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zipfpeMoments">zipfpeMoments</a></code>, <code><a href="#topic+zipfpeMean">zipfpeMean</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zipfpeVariance(3.5, 1.3)
</code></pre>

<hr>
<h2 id='zipfPolylog'>The Zipf-Polylog Distribution (Zipf-Polylog).</h2><span id='topic+zipfPolylog'></span><span id='topic+dzipfpolylog'></span><span id='topic+pzipfpolylog'></span><span id='topic+qzipfpolylog'></span><span id='topic+rzipfpolylog'></span>

<h3>Description</h3>

<p>Probability mass function of the Zipf-Polylog distribution with parameters <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>.
The support of the Zipf-Polylog distribution are the strictly positive integer numbers large or equal
than one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dzipfpolylog(x, alpha, beta, log = FALSE, nSum = 1000)

pzipfpolylog(x, alpha, beta, log.p = FALSE, lower.tail = TRUE,
  nSum = 1000)

qzipfpolylog(p, alpha, beta, log.p = FALSE, lower.tail = TRUE,
  nSum = 1000)

rzipfpolylog(n, alpha, beta, nSum = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zipfPolylog_+3A_x">x</code></td>
<td>
<p>Vector of positive integer values.</p>
</td></tr>
<tr><td><code id="zipfPolylog_+3A_alpha">alpha</code></td>
<td>
<p>Value of the <code class="reqn">\alpha</code> parameter (<code class="reqn">\alpha &gt; 1</code> ).</p>
</td></tr>
<tr><td><code id="zipfPolylog_+3A_beta">beta</code></td>
<td>
<p>Value of the <code class="reqn">\beta</code> parameter (<code class="reqn">\beta &gt; 0</code> ).</p>
</td></tr>
<tr><td><code id="zipfPolylog_+3A_log">log</code>, <code id="zipfPolylog_+3A_log.p">log.p</code></td>
<td>
<p>Logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="zipfPolylog_+3A_nsum">nSum</code></td>
<td>
<p>The number of terms used for computing the Polylogarithm function (Default = 1000).</p>
</td></tr>
<tr><td><code id="zipfPolylog_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if TRUE (default), probabilities are <code class="reqn">P[X \leq x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="zipfPolylog_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="zipfPolylog_+3A_n">n</code></td>
<td>
<p>Number of random values to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>probability mass function</em> at a positive integer value <code class="reqn">x</code> of the Zipf-Polylog distribution with
parameters <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> is computed as follows:
</p>


<h3>Value</h3>


<p><code>dzipfpolylog</code> gives the probability mass function

</p>


<h3>Examples</h3>

<pre><code class='language-R'>dzipfpolylog(1:10, 1.61, 0.98)
pzipfpolylog(1:10, 1.61, 0.98)
qzipfpolylog(0.8, 1.61, 0.98)
</code></pre>

<hr>
<h2 id='zipfPolylogFit'>ZipfPolylog parameters estimation.</h2><span id='topic+zipfPolylogFit'></span><span id='topic+residuals.zipfPolyR'></span><span id='topic+fitted.zipfPolyR'></span><span id='topic+coef.zipfPolyR'></span><span id='topic+plot.zipfPolyR'></span><span id='topic+print.zipfPolyR'></span><span id='topic+summary.zipfPolyR'></span><span id='topic+logLik.zipfPolyR'></span><span id='topic+AIC.zipfPolyR'></span><span id='topic+BIC.zipfPolyR'></span>

<h3>Description</h3>

<p>For a given sample of strictly positive integer numbers,  usually of the type of ranking data or
frequencies of frequencies data, estimates the parameters of the ZipfPolylog distribution by means of
the maximum likelihood method. The input data should be provided as a frequency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zipfPolylogFit(data, init_alpha, init_beta, level = 0.95, ...)

## S3 method for class 'zipfPolyR'
residuals(object, ...)

## S3 method for class 'zipfPolyR'
fitted(object, ...)

## S3 method for class 'zipfPolyR'
coef(object, ...)

## S3 method for class 'zipfPolyR'
plot(x, ...)

## S3 method for class 'zipfPolyR'
print(x, ...)

## S3 method for class 'zipfPolyR'
summary(object, ...)

## S3 method for class 'zipfPolyR'
logLik(object, ...)

## S3 method for class 'zipfPolyR'
AIC(object, ...)

## S3 method for class 'zipfPolyR'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zipfPolylogFit_+3A_data">data</code></td>
<td>
<p>Matrix of count data in form of a table of frequencies.</p>
</td></tr>
<tr><td><code id="zipfPolylogFit_+3A_init_alpha">init_alpha</code></td>
<td>
<p>Initial value of <code class="reqn">\alpha</code> parameter (<code class="reqn">\alpha &gt; 1</code>).</p>
</td></tr>
<tr><td><code id="zipfPolylogFit_+3A_init_beta">init_beta</code></td>
<td>
<p>Initial value of <code class="reqn">\beta</code> parameter (<code class="reqn">\beta &gt; 0</code>).</p>
</td></tr>
<tr><td><code id="zipfPolylogFit_+3A_level">level</code></td>
<td>
<p>Confidence level used to calculate the confidence intervals (default 0.95).</p>
</td></tr>
<tr><td><code id="zipfPolylogFit_+3A_...">...</code></td>
<td>
<p>Further arguments to the generic functions. The extra arguments are passing to the <em><a href="stats.html#topic+optim">optim</a></em> function.</p>
</td></tr>
<tr><td><code id="zipfPolylogFit_+3A_object">object</code></td>
<td>
<p>An object from class &quot;zipfPolyR&quot; (output of <em>zipfPolylogFit</em> function).</p>
</td></tr>
<tr><td><code id="zipfPolylogFit_+3A_x">x</code></td>
<td>
<p>An object from class &quot;zipfPolyR&quot; (output of <em>zipfPolylogFit</em> function).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>data</code> is a two column matrix with the first column containing the observations and
the second column containing their frequencies.
</p>
<p>The log-likelihood function is equal to:
</p>
<p>The function <em><a href="stats.html#topic+optim">optim</a></em> is used to estimate the parameters.
</p>


<h3>Value</h3>

<p>Returns a <em>zipfPolyR</em> object composed by the maximum likelihood parameter estimations
jointly with their standard deviation and confidence intervals. It also contains
the value of the log-likelihood at the maximum likelihood estimator.
</p>

<hr>
<h2 id='zipfpolylogMean'>Expected value of the ZipfPolylog distribution.</h2><span id='topic+zipfpolylogMean'></span>

<h3>Description</h3>

<p>Computes the expected value of the ZipfPolylog distribution for given values of parameters
<code class="reqn">\alpha</code> and <code class="reqn">\beta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zipfpolylogMean(alpha, beta, tolerance = 10^(-4))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zipfpolylogMean_+3A_alpha">alpha</code></td>
<td>
<p>Value of the <code class="reqn">\alpha</code> parameter (<code class="reqn">\alpha &gt; 2</code>).</p>
</td></tr>
<tr><td><code id="zipfpolylogMean_+3A_beta">beta</code></td>
<td>
<p>Value of the <code class="reqn">\beta</code> parameter (<code class="reqn">\beta \in (-\infty, +\infty)</code>).</p>
</td></tr>
<tr><td><code id="zipfpolylogMean_+3A_tolerance">tolerance</code></td>
<td>
<p>Tolerance used in the calculations (default = <code class="reqn">10^{-4}</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A positive real value corresponding to the mean value of the ZipfPolylog distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zipfpolylogMean(0.5, 0.8)
zipfpolylogMean(2.5, 0.8, 10^(-3))
</code></pre>

<hr>
<h2 id='zipfpolylogMoments'>Moments of the Zipf-Polylog Distribution.</h2><span id='topic+zipfpolylogMoments'></span>

<h3>Description</h3>

<p>General function to compute the k-th moment of the ZipfPolylog distribution for any integer value <code class="reqn">k \geq 1</code>,
when it exists. #'
For k = 1, this function returns the same value as the <a href="#topic+zipfpolylogMean">zipfpolylogMean</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zipfpolylogMoments(k, alpha, beta, tolerance = 10^(-4), nSum = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zipfpolylogMoments_+3A_k">k</code></td>
<td>
<p>Order of the moment to compute.</p>
</td></tr>
<tr><td><code id="zipfpolylogMoments_+3A_alpha">alpha</code></td>
<td>
<p>Value of the <code class="reqn">\alpha</code> parameter (<code class="reqn">\alpha &gt; k + 1</code>).</p>
</td></tr>
<tr><td><code id="zipfpolylogMoments_+3A_beta">beta</code></td>
<td>
<p>Value of the <code class="reqn">\beta</code> parameter (<code class="reqn">\beta \in (-\infty, +\infty)</code>).</p>
</td></tr>
<tr><td><code id="zipfpolylogMoments_+3A_tolerance">tolerance</code></td>
<td>
<p>Tolerance used in the calculations (default = <code class="reqn">10^{-4}</code>).</p>
</td></tr>
<tr><td><code id="zipfpolylogMoments_+3A_nsum">nSum</code></td>
<td>
<p>The number of terms used for computing the Polylogarithm function (default = 1000).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The k-th moment of the Zipf-Polylog distribution is always finite, but,
for <code class="reqn">\alpha &gt;1</code> and <code class="reqn">\beta = 0</code> the k-th moment is only finite for all <code class="reqn">\alpha &gt; k + 1</code>.
It is computed by calculating the partial sums of the serie, and stopping when two
consecutive partial sums differ less than the <code>tolerance</code> value.
The value of the last partial sum is returned.
</p>


<h3>Value</h3>

<p>A positive real value corresponding to the k-th moment of the distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zipfpolylogMoments(1, 0.2, 0.90)
zipfpolylogMoments(3, 4.5, 0.90,  1*10^(-3))
</code></pre>

<hr>
<h2 id='zipfpoylogVariance'>Variance of the ZipfPolylog distribution.</h2><span id='topic+zipfpoylogVariance'></span>

<h3>Description</h3>

<p>Computes the variance of the ZipfPolylog distribution for given values of <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zipfpoylogVariance(alpha, beta, tolerance = 10^(-4))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zipfpoylogVariance_+3A_alpha">alpha</code></td>
<td>
<p>Value of the <code class="reqn">\alpha</code> parameter (<code class="reqn">\alpha &gt; 3</code>).</p>
</td></tr>
<tr><td><code id="zipfpoylogVariance_+3A_beta">beta</code></td>
<td>
<p>Value of the <code class="reqn">\beta</code> parameter (<code class="reqn">\beta \in (-\infty, +\infty)</code>).</p>
</td></tr>
<tr><td><code id="zipfpoylogVariance_+3A_tolerance">tolerance</code></td>
<td>
<p>Tolerance used in the calculations. (default = <code class="reqn">10^{-4}</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variance of the distribution only exists for <code class="reqn">\alpha</code> strictly greater than 3.
</p>


<h3>Value</h3>

<p>A positive real value corresponding to the variance of the distribution.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zipfpolylogMoments">zipfpolylogMoments</a></code>, <code><a href="#topic+zipfpolylogMean">zipfpolylogMean</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zipfpoylogVariance(0.5, 0.75)
</code></pre>

<hr>
<h2 id='zipfpss'>The Zipf-Poisson Stop Sum Distribution (Zipf-PSS).</h2><span id='topic+zipfpss'></span><span id='topic+dzipfpss'></span><span id='topic+pzipfpss'></span><span id='topic+rzipfpss'></span><span id='topic+qzipfpss'></span>

<h3>Description</h3>

<p>Probability mass function, cumulative distribution function, quantile function and random number
generation for the Zipf-PSS distribution with parameters <code class="reqn">\alpha</code> and <code class="reqn">\lambda</code>. The support of the Zipf-PSS
distribution are the positive integer numbers including the zero value. In order to work with its zero-truncated version
the parameter <code>isTruncated</code> should be equal to True.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dzipfpss(x, alpha, lambda, log = FALSE, isTruncated = FALSE)

pzipfpss(q, alpha, lambda, log.p = FALSE, lower.tail = TRUE,
  isTruncated = FALSE)

rzipfpss(n, alpha, lambda, log.p = FALSE, lower.tail = TRUE,
  isTruncated = FALSE)

qzipfpss(p, alpha, lambda, log.p = FALSE, lower.tail = TRUE,
  isTruncated = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zipfpss_+3A_x">x</code>, <code id="zipfpss_+3A_q">q</code></td>
<td>
<p>Vector of positive integer values.</p>
</td></tr>
<tr><td><code id="zipfpss_+3A_alpha">alpha</code></td>
<td>
<p>Value of the <code class="reqn">\alpha</code> parameter (<code class="reqn">\alpha &gt; 1</code> ).</p>
</td></tr>
<tr><td><code id="zipfpss_+3A_lambda">lambda</code></td>
<td>
<p>Value of the <code class="reqn">\lambda</code> parameter (<code class="reqn">\lambda &gt; 0</code> ).</p>
</td></tr>
<tr><td><code id="zipfpss_+3A_log">log</code>, <code id="zipfpss_+3A_log.p">log.p</code></td>
<td>
<p>Logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="zipfpss_+3A_istruncated">isTruncated</code></td>
<td>
<p>Logical; if TRUE, the zero truncated version of the distribution is returned.</p>
</td></tr>
<tr><td><code id="zipfpss_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if TRUE (default), probabilities are <code class="reqn">P[X \leq x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="zipfpss_+3A_n">n</code></td>
<td>
<p>Number of random values to return.</p>
</td></tr>
<tr><td><code id="zipfpss_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The support of the <code class="reqn">\lambda</code> parameter increases when the distribution is truncated at zero being
<code class="reqn">\lambda \geq 0</code>. It has been proved that when <code class="reqn">\lambda = 0</code> one has the degenerated version of the distribution at one.
</p>


<h3>References</h3>


<p>Panjer, H. H. (1981). Recursive evaluation of a family of compound
distributions. ASTIN Bulletin: The Journal of the IAA, 12(1), 22-26.
</p>
<p>Sundt, B., &amp; Jewell, W. S. (1981). Further results on recursive evaluation of
compound distributions. ASTIN Bulletin: The Journal of the IAA, 12(1), 27-39.

</p>

<hr>
<h2 id='zipfpssFit'>Zipf-PSS parameters estimation.</h2><span id='topic+zipfpssFit'></span><span id='topic+residuals.zipfpssR'></span><span id='topic+fitted.zipfpssR'></span><span id='topic+coef.zipfpssR'></span><span id='topic+plot.zipfpssR'></span><span id='topic+print.zipfpssR'></span><span id='topic+summary.zipfpssR'></span><span id='topic+logLik.zipfpssR'></span><span id='topic+AIC.zipfpssR'></span><span id='topic+BIC.zipfpssR'></span>

<h3>Description</h3>

<p>For a given sample of strictly positive integer numbers,  usually of the type of ranking data or
frequencies of frequencies data, estimates the parameters of the Zipf-PSS distribution by means of
the maximum likelihood method. The input data should be provided as a frequency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zipfpssFit(data, init_alpha = NULL, init_lambda = NULL, level = 0.95,
  isTruncated = FALSE, ...)

## S3 method for class 'zipfpssR'
residuals(object, isTruncated = FALSE, ...)

## S3 method for class 'zipfpssR'
fitted(object, isTruncated = FALSE, ...)

## S3 method for class 'zipfpssR'
coef(object, ...)

## S3 method for class 'zipfpssR'
plot(x, isTruncated = FALSE, ...)

## S3 method for class 'zipfpssR'
print(x, ...)

## S3 method for class 'zipfpssR'
summary(object, isTruncated = FALSE, ...)

## S3 method for class 'zipfpssR'
logLik(object, ...)

## S3 method for class 'zipfpssR'
AIC(object, ...)

## S3 method for class 'zipfpssR'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zipfpssFit_+3A_data">data</code></td>
<td>
<p>Matrix of count data in form of table of frequencies.</p>
</td></tr>
<tr><td><code id="zipfpssFit_+3A_init_alpha">init_alpha</code></td>
<td>
<p>Initial value of <code class="reqn">\alpha</code> parameter (<code class="reqn">\alpha &gt; 1</code>).</p>
</td></tr>
<tr><td><code id="zipfpssFit_+3A_init_lambda">init_lambda</code></td>
<td>
<p>Initial value of <code class="reqn">\lambda</code> parameter (<code class="reqn">\lambda &gt; 0</code>).</p>
</td></tr>
<tr><td><code id="zipfpssFit_+3A_level">level</code></td>
<td>
<p>Confidence level used to calculate the confidence intervals (default 0.95).</p>
</td></tr>
<tr><td><code id="zipfpssFit_+3A_istruncated">isTruncated</code></td>
<td>
<p>Logical; if TRUE, the truncated version of the distribution is returned.(default = FALSE)</p>
</td></tr>
<tr><td><code id="zipfpssFit_+3A_...">...</code></td>
<td>
<p>Further arguments to the generic functions. The extra arguments are passing
to the <em><a href="stats.html#topic+optim">optim</a></em> function.</p>
</td></tr>
<tr><td><code id="zipfpssFit_+3A_object">object</code></td>
<td>
<p>An object from class &quot;zpssR&quot; (output of <em>zipfpssFit</em> function).</p>
</td></tr>
<tr><td><code id="zipfpssFit_+3A_x">x</code></td>
<td>
<p>An object from class &quot;zpssR&quot; (output of <em>zipfpssFit</em> function).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>data</code> is a two column matrix with the first column containing the observations and
the second column containing their frequencies.
</p>
<p>The log-likelihood function is equal to:
</p>
<p style="text-align: center;"><code class="reqn">l(\alpha, \lambda, x) = \sum_{i =1} ^{m} f_a(x_i)\, log(P(Y = x_i)),</code>
</p>

<p>where <code class="reqn">m</code> is the number of different values in the sample, being <code class="reqn">f_{a}(x_i)</code> is the absolute
frequency of <code class="reqn">x_i</code>.The probabilities are calculated applying the Panjer recursion.
By default the initial values of the parameters are computed using the function <code>getInitialValues</code>.
The function <em><a href="stats.html#topic+optim">optim</a></em> is used to estimate the parameters.
</p>


<h3>Value</h3>

<p>Returns a <em>zpssR</em> object composed by the maximum likelihood parameter estimations jointly
with their standard deviation and confidence intervals and the value of the log-likelihood at the
maximum likelihood estimator.
</p>


<h3>References</h3>


<p>Panjer, H. H. (1981). Recursive evaluation of a family of compound
distributions. ASTIN Bulletin: The Journal of the IAA, 12(1), 22-26.
</p>
<p>Sundt, B., &amp; Jewell, W. S. (1981). Further results on recursive evaluation of
compound distributions. ASTIN Bulletin: The Journal of the IAA, 12(1), 27-39.

</p>


<h3>See Also</h3>

<p><code><a href="#topic+getInitialValues">getInitialValues</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- rzipfpss(100, 2.5, 1.3)
data &lt;- as.data.frame(table(data))
data[,1] &lt;- as.numeric(as.character(data[,1]))
data[,2] &lt;- as.numeric(as.character(data[,2]))
initValues &lt;- getInitialValues(data, model='zipfpss')
obj &lt;- zipfpssFit(data, init_alpha = initValues$init_alpha, init_lambda = initValues$init_lambda)
</code></pre>

<hr>
<h2 id='zipfpssMean'>Expected value of the Zipf-PSS distribution.</h2><span id='topic+zipfpssMean'></span>

<h3>Description</h3>

<p>Computes the expected value of the Zipf-PSS distribution for given values of parameters
<code class="reqn">\alpha</code> and <code class="reqn">\lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zipfpssMean(alpha, lambda, isTruncated = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zipfpssMean_+3A_alpha">alpha</code></td>
<td>
<p>Value of the <code class="reqn">\alpha</code> parameter (<code class="reqn">\alpha &gt; 2</code>).</p>
</td></tr>
<tr><td><code id="zipfpssMean_+3A_lambda">lambda</code></td>
<td>
<p>Value of the <code class="reqn">\lambda</code> parameter (<code class="reqn">\lambda &gt; 0</code>).</p>
</td></tr>
<tr><td><code id="zipfpssMean_+3A_istruncated">isTruncated</code></td>
<td>
<p>Logical; if TRUE Use the zero-truncated version of the distribution to calculate the expected value (default = FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expected value of the Zipf-PSS distribution only exists for <code class="reqn">\alpha</code> values strictly
greater than 2. The value is obtained from the <em>law of total expectation</em> that says that: </p>
<p style="text-align: center;"><code class="reqn">E[Y] = E[N]\, E[X],</code>
</p>

<p>where E[X] is the mean value of the Zipf distribution and E[N] is the expected value of a Poisson one.
From where one has that:
</p>
<p style="text-align: center;"><code class="reqn">E[Y] = \lambda\, \frac{\zeta(\alpha - 1)}{\zeta(\alpha)}</code>
</p>

<p>Particularlly, if one is working with the zero-truncated version of the Zipf-PSS distribution.
This values is computed as:
</p>
<p style="text-align: center;"><code class="reqn">E[Y^{ZT}] = \frac{\lambda\, \zeta(\alpha - 1)}{\zeta(\alpha)\, (1 - e^{-\lambda})}</code>
</p>



<h3>Value</h3>

<p>A positive real value corresponding to the mean value of the distribution.
</p>


<h3>References</h3>


<p>Sarabia Alegría, J. M., Gómez Déniz, E. M. I. L. I. O., &amp; Vázquez Polo, F. (2007).
Estadística actuarial: teoría y aplicaciones. Pearson Prentice Hall.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>zipfpssMean(2.5, 1.3)
zipfpssMean(2.5, 1.3, TRUE)
</code></pre>

<hr>
<h2 id='zipfpssMoments'>Distribution Moments.</h2><span id='topic+zipfpssMoments'></span>

<h3>Description</h3>

<p>General function to compute the k-th moment of the Zipf-PSS distribution for any integer value <code class="reqn">k \geq 1</code>,
when it exists. The k-th moment exists if and only if  <code class="reqn">\alpha &gt; k + 1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zipfpssMoments(k, alpha, lambda, isTruncated = FALSE,
  tolerance = 10^(-4))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zipfpssMoments_+3A_k">k</code></td>
<td>
<p>Order of the moment to compute.</p>
</td></tr>
<tr><td><code id="zipfpssMoments_+3A_alpha">alpha</code></td>
<td>
<p>Value of the <code class="reqn">\alpha</code> parameter (<code class="reqn">\alpha &gt; k + 1</code>).</p>
</td></tr>
<tr><td><code id="zipfpssMoments_+3A_lambda">lambda</code></td>
<td>
<p>Value of the <code class="reqn">\lambda</code> parameter (<code class="reqn">\lambda &gt; 0</code>).</p>
</td></tr>
<tr><td><code id="zipfpssMoments_+3A_istruncated">isTruncated</code></td>
<td>
<p>Logical; if TRUE, the truncated version of the distribution is returned.</p>
</td></tr>
<tr><td><code id="zipfpssMoments_+3A_tolerance">tolerance</code></td>
<td>
<p>Tolerance used in the calculations (default = <code class="reqn">10^{-4}</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The k-th moment of the Zipf-PSS distribution is finite for <code class="reqn">\alpha</code> values
strictly greater than <code class="reqn">k + 1</code>.
It is computed by calculating the partial sums of the serie, and stopping when two
consecutive partial sums differ less than the <code>tolerance</code> value.
The value of the last partial sum is returned.
</p>


<h3>Value</h3>

<p>A positive real value corresponding to the k-th moment of the distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zipfpssMoments(1, 2.5, 2.3)
zipfpssMoments(1, 2.5, 2.3, TRUE)
</code></pre>

<hr>
<h2 id='zipfpssVariance'>Variance of the Zipf-PSS distribution.</h2><span id='topic+zipfpssVariance'></span>

<h3>Description</h3>

<p>Computes the variance of the Zipf-PSS distribution for given values of parameters
<code class="reqn">\alpha</code> and <code class="reqn">\lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zipfpssVariance(alpha, lambda, isTruncated = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zipfpssVariance_+3A_alpha">alpha</code></td>
<td>
<p>Value of the <code class="reqn">\alpha</code> parameter (<code class="reqn">\alpha &gt; 3</code>).</p>
</td></tr>
<tr><td><code id="zipfpssVariance_+3A_lambda">lambda</code></td>
<td>
<p>Value of the <code class="reqn">\lambda</code> parameter (<code class="reqn">\lambda &gt; 0</code>).</p>
</td></tr>
<tr><td><code id="zipfpssVariance_+3A_istruncated">isTruncated</code></td>
<td>
<p>Logical; if TRUE Use the zero-truncated version of the distribution to calculate the expected value (default = FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variance of the Zipf-PSS distribution only exists for <code class="reqn">\alpha</code> values strictly greater than 3.
The value is obtained from the <em>law of total variance</em> that says that: </p>
<p style="text-align: center;"><code class="reqn">Var[Y] = E[N]\, Var[X] + E[X]^2 \, Var[N],</code>
</p>

<p>where X follows a Zipf distribution with parameter <code class="reqn">\alpha</code>, and N follows a Poisson distribution with
parameter <code class="reqn">\lambda</code>. From where one has that:
</p>
<p style="text-align: center;"><code class="reqn">Var[Y] = \lambda\, \frac{\zeta(\alpha - 2)}{\zeta(\alpha)}</code>
</p>

<p>Particularlly, if one is working with the zero-truncated version of the Zipf-PSS distribution.
This values is computed as:
</p>
<p style="text-align: center;"><code class="reqn">Var[Y^{ZT}] = \frac{\lambda\, \zeta(\alpha)\, \zeta(\alpha - 2)\, (1 - e^{-\lambda}) - \lambda^2 \, \zeta(\alpha - 1)^2 \, e^{-\lambda}}{\zeta(\alpha)^2 \, (1 - e^{-\lambda})^2}</code>
</p>



<h3>Value</h3>

<p>A positive real value corresponding to the variance of the distribution.
</p>


<h3>References</h3>


<p>Sarabia Alegría, JM. and Gómez Déniz, E. and Vázquez Polo, F. Estadística actuarial: teoría y aplicaciones. Pearson Prentice Hall.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>zipfpssVariance(4.5, 2.3)
zipfpssVariance(4.5, 2.3, TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
