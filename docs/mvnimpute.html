<!DOCTYPE html><html lang="en"><head><title>Help for package mvnimpute</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mvnimpute}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mvnimpute-package'><p>mvnimpute: Multiple imputation for multivariate data with missing and censored values</p></a></li>
<li><a href='#acf.calc'><p>Autocorrelation function</p></a></li>
<li><a href='#avg.plot'><p>Averaged simulated values plot function</p></a></li>
<li><a href='#conv.plot'><p>Convergence plot function</p></a></li>
<li><a href='#data.generation'><p>Data generation function</p></a></li>
<li><a href='#marg.plot'><p>Marginal density plots function</p></a></li>
<li><a href='#multiple.imputation'><p>Multiple imputation function</p></a></li>
<li><a href='#NHANES.dat'><p>Combined NHANES dataset from 1999-2004 NHANES study</p></a></li>
<li><a href='#simulated.dat'><p>Simulated continuous data with missing and censored values</p></a></li>
<li><a href='#visual.plot'><p>Draws percentage plot for different type of values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simultaneously Impute the Missing and Censored Values</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Author:</td>
<td>Hesen Li</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hesen Li &lt;li.hesen.21@gmail.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/hli226/mvnimpute">https://github.com/hli226/mvnimpute</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hli226/mvnimpute/issues">https://github.com/hli226/mvnimpute/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Implementing a multiple imputation algorithm for multivariate data with missing and censored values under a coarsening at random assumption (Heitjan and Rubin, 1991&lt;<a href="https://doi.org/10.1214%2Faos%2F1176348396">doi:10.1214/aos/1176348396</a>&gt;). The multiple imputation algorithm is based on the data augmentation algorithm proposed by Tanner and Wong (1987)&lt;<a href="https://doi.org/10.1080%2F01621459.1987.10478458">doi:10.1080/01621459.1987.10478458</a>&gt;. The Gibbs sampling algorithm is adopted to to update the model parameters and draw imputations of the coarse data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppDist</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, reshape2, LaplacesDemon, rlang, Rcpp, MASS, truncnorm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mice, clusterGeneration</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-05 19:44:02 UTC; hesenli</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-06 09:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mvnimpute-package'>mvnimpute: Multiple imputation for multivariate data with missing and censored values</h2><span id='topic+mvnimpute-package'></span>

<h3>Description</h3>

<p>The mvnimpute package implements multiple imputation for simultaneously imputing missing and censored values based on the joint normal
model assumption.
</p>


<h3>Author(s)</h3>

<p>Hesen Li
</p>

<hr>
<h2 id='acf.calc'>Autocorrelation function</h2><span id='topic+acf.calc'></span>

<h3>Description</h3>

<p>Calculates the autocorrelation function and draws the plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acf.calc(data.mat, lag = 50, plot = TRUE, title = NULL, details = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acf.calc_+3A_data.mat">data.mat</code></td>
<td>
<p>matrix including the variables of which autocorrelations are calculated.</p>
</td></tr>
<tr><td><code id="acf.calc_+3A_lag">lag</code></td>
<td>
<p>lag at which the autocorrelation is calculated, default is set as 50.</p>
</td></tr>
<tr><td><code id="acf.calc_+3A_plot">plot</code></td>
<td>
<p>logical variable to specify whether the plot is generated, default is set to TRUE.</p>
</td></tr>
<tr><td><code id="acf.calc_+3A_title">title</code></td>
<td>
<p>title of each generated autocorrelation plot.</p>
</td></tr>
<tr><td><code id="acf.calc_+3A_details">details</code></td>
<td>
<p>boolean variable to specify whether the autocorrelation values are returned, default is set to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the autocorrelations of all the variables on a column by column base.
The default value of <code>lag</code> is set as 50, the maximum number of lag should not exceed the number of rows of the dataset,
which reflects the corresponding number of iteration of running the multiple imputation.
</p>


<h3>Value</h3>

<p>If <code>details</code> = TRUE, a matrix containing the calculated autocorrelations of all the variables in the dataset will be returned.
If <code>plot</code> = TRUE, the autocorrelation plots of all the variables will be drawn.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### generate some data
dat &lt;- MASS::mvrnorm(n = 1000, mu = c(1, 2, 3, 4), Sigma = diag(4))

### ACF plots
acf.calc(data.mat = dat, title = paste0("Var ", 1:nrow(dat)))

</code></pre>

<hr>
<h2 id='avg.plot'>Averaged simulated values plot function</h2><span id='topic+avg.plot'></span>

<h3>Description</h3>

<p>Calculates the average simulated values of all parameters and generates plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avg.plot(
  data.mat,
  start,
  end,
  x.lab = "Iteration number",
  y.lab = "Average of simulated values",
  title = NULL,
  details = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="avg.plot_+3A_data.mat">data.mat</code></td>
<td>
<p>data matrix including the simulated values for plot.</p>
</td></tr>
<tr><td><code id="avg.plot_+3A_start">start</code></td>
<td>
<p>the number of cycle to start.</p>
</td></tr>
<tr><td><code id="avg.plot_+3A_end">end</code></td>
<td>
<p>the number of cycle to end.</p>
</td></tr>
<tr><td><code id="avg.plot_+3A_x.lab">x.lab</code></td>
<td>
<p>label of the x axis in the generated plot, default is set to &quot;Iteration number&quot;.</p>
</td></tr>
<tr><td><code id="avg.plot_+3A_y.lab">y.lab</code></td>
<td>
<p>label of the y axis in the generated plot, default is set to &quot;Average of simulated values&quot;.</p>
</td></tr>
<tr><td><code id="avg.plot_+3A_title">title</code></td>
<td>
<p>title of each generated plot.</p>
</td></tr>
<tr><td><code id="avg.plot_+3A_details">details</code></td>
<td>
<p>logical variable to specify whether the average simulated values are returned, default is set to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the average simulated values across simulations.
<code>iter</code> can be any number of iterations you want to draw, the corresponding number of rows
of the data should be <code>iter</code> + 1.
</p>


<h3>Value</h3>

<p>The plot of averaged values across iterations. If <code>details</code> = TRUE,
a matrix containing the averaged values of all the variables across iterations will be returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### generate some normal data
dat &lt;- MASS::mvrnorm(n = 1000, mu = c(1, 2, 3, 4), Sigma = diag(4))

### set column names
colnames(dat) &lt;- paste0("Var ", 1:ncol(dat))

### average values plot: take sample from 500 to 1000 rows
avg.plot(data.mat = dat[500:1000, ], start = 500, end = 1000, title = "Random Variables")

</code></pre>

<hr>
<h2 id='conv.plot'>Convergence plot function</h2><span id='topic+conv.plot'></span>

<h3>Description</h3>

<p>Draws convergence plot for the simulated parameter values of all variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv.plot(
  data.mat,
  start,
  end,
  x.lab = "Iteration number",
  y.lab = "Simulated values",
  title = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conv.plot_+3A_data.mat">data.mat</code></td>
<td>
<p>data matrix including the simulated values.</p>
</td></tr>
<tr><td><code id="conv.plot_+3A_start">start</code></td>
<td>
<p>the number of cycle to start.</p>
</td></tr>
<tr><td><code id="conv.plot_+3A_end">end</code></td>
<td>
<p>the number of cycle to end.</p>
</td></tr>
<tr><td><code id="conv.plot_+3A_x.lab">x.lab</code></td>
<td>
<p>label of the x axis in the generated plot, default is set to &quot;Iteration number&quot;.</p>
</td></tr>
<tr><td><code id="conv.plot_+3A_y.lab">y.lab</code></td>
<td>
<p>label of the y axis in the generated plot, default is set to &quot;Simulated values&quot;.</p>
</td></tr>
<tr><td><code id="conv.plot_+3A_title">title</code></td>
<td>
<p>title of each generated plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates the trace plot of simulated values across iterations.
<code>iter</code> can be any number of iterations you want to draw, the corresponding number of rows
of the data is <code>iter</code> + 1.
</p>


<h3>Value</h3>

<p>The plot of simulated values across iterations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### generate some data
dat &lt;- MASS::mvrnorm(n = 1000, mu = c(1, 2, 3, 4), Sigma = diag(4))

### set column names
colnames(dat) &lt;- paste0("Var ", 1:ncol(dat))

### convergence plot: select samples from 500 to 1000 rows
conv.plot(data.mat = dat[500:1000, ], start = 500, end = 1000, title = "Random Variables")

</code></pre>

<hr>
<h2 id='data.generation'>Data generation function</h2><span id='topic+data.generation'></span>

<h3>Description</h3>

<p>Simulates multivariate normal data with missing and censored values. In this function, missing values will be
generated first in the multivariate data, then censored values will be generated for the non-missing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.generation(
  num_ind = 2000,
  mean_vec = rnorm(5),
  cov_mat = diag(5),
  miss_var = c(2, 3),
  miss_mech = "MCAR",
  miss_prob = c(0.2, 0.4),
  censor_var = 4,
  censor_type = "interval",
  censor_param = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.generation_+3A_num_ind">num_ind</code></td>
<td>
<p>number of subjects.</p>
</td></tr>
<tr><td><code id="data.generation_+3A_mean_vec">mean_vec</code></td>
<td>
<p>mean vectors.</p>
</td></tr>
<tr><td><code id="data.generation_+3A_cov_mat">cov_mat</code></td>
<td>
<p>covariance matrix.</p>
</td></tr>
<tr><td><code id="data.generation_+3A_miss_var">miss_var</code></td>
<td>
<p>variables that have missing values.</p>
</td></tr>
<tr><td><code id="data.generation_+3A_miss_mech">miss_mech</code></td>
<td>
<p>missing mechanism. &quot;MCAR&quot; or &quot;MAR&quot;. Default &quot;MCAR&quot;.</p>
</td></tr>
<tr><td><code id="data.generation_+3A_miss_prob">miss_prob</code></td>
<td>
<p>missing data probability when missing data is MCAR.</p>
</td></tr>
<tr><td><code id="data.generation_+3A_censor_var">censor_var</code></td>
<td>
<p>variables that have censored values.</p>
</td></tr>
<tr><td><code id="data.generation_+3A_censor_type">censor_type</code></td>
<td>
<p>type of censoring. &quot;interval&quot;, &quot;right&quot; or &quot;left. Default &quot;interval&quot;.</p>
</td></tr>
<tr><td><code id="data.generation_+3A_censor_param">censor_param</code></td>
<td>
<p>rate parameter of the exponential distribution that the censoring times come from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the fully observed data, the observed data,
the bounds information of the observed data and the data type indicator matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### generate a multivariate normal dataset of 2000 sample size
### using the default arguments
data.generation()

</code></pre>

<hr>
<h2 id='marg.plot'>Marginal density plots function</h2><span id='topic+marg.plot'></span>

<h3>Description</h3>

<p>Draws marginal density plots for all variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marg.plot(data.mat, title = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="marg.plot_+3A_data.mat">data.mat</code></td>
<td>
<p>data matrix including all the variables.</p>
</td></tr>
<tr><td><code id="marg.plot_+3A_title">title</code></td>
<td>
<p>title of each generated plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Marginal density plot for each variable in the dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### generate some data
dat &lt;- MASS::mvrnorm(n = 1000, mu = c(1, 2, 3, 4), Sigma = diag(4))

### set column names
colnames(dat) &lt;- paste0("Var ", 1:ncol(dat))

### marginal plots
marg.plot(data.mat = dat, title = paste0("Var", 1:nrow(dat)))
</code></pre>

<hr>
<h2 id='multiple.imputation'>Multiple imputation function</h2><span id='topic+multiple.imputation'></span>

<h3>Description</h3>

<p>Multiply imputes the missing and censored values in multivariate data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiple.imputation(data, prior.params, initial.values, iter, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multiple.imputation_+3A_data">data</code></td>
<td>
<p>a list of data containing the lower and upper bounds information for the missing and censored values.</p>
</td></tr>
<tr><td><code id="multiple.imputation_+3A_prior.params">prior.params</code></td>
<td>
<p>list of prior parameter specifications.</p>
</td></tr>
<tr><td><code id="multiple.imputation_+3A_initial.values">initial.values</code></td>
<td>
<p>list of initial values.</p>
</td></tr>
<tr><td><code id="multiple.imputation_+3A_iter">iter</code></td>
<td>
<p>number of rounds for doing multiple imputation.</p>
</td></tr>
<tr><td><code id="multiple.imputation_+3A_verbose">verbose</code></td>
<td>
<p>boolean variable indicating whether the running status is printed in the console. Default is set to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A multivariate normal model is assumed on the data, the sweep operator is adopted to
calculate the parameters of the conditional models. The implemented multiple imputation algorithm
is based on the data augmentation algorithm proposed by Tanner and Wong (1987). The Gibbs sampling algorithm
is adopted to update the model parameters and draw imputations of the coarse data. Output is a
list including the parameters of the normal models and the imputed data across different iterations
of multiple imputation.
</p>


<h3>Value</h3>

<p>A list including the simulated mean and variance values of the assumed normal model, the covariance matrix, the imputed data,
and the conditional model parameters across different iterations of multiple imputation.
</p>


<h3>References</h3>

<p>Goodnight, J. H. (1979). A tutorial on the SWEEP operator. <em>The American Statistician</em>, <b>33(3)</b>, 149-158.
</p>
<p>Tanner, M., &amp; Wong, W. (1987). The Calculation of Posterior Distributions by Data Augmentation.
<em>Journal of the American Statistical Association</em>, <b>82(398)</b>, 528-540.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### data and indicator
miss.dat &lt;- simulated.dat[[1]]
data.ind &lt;- simulated.dat[[2]]

### number of observations and variables
n &lt;- nrow(miss.dat); p &lt;- ncol(miss.dat)

#### bound matrices
b1 &lt;- b2 &lt;- matrix(nrow = nrow(data.ind), ncol = ncol(data.ind))

for (i in 1:nrow(b1)) {
  for (j in 1:ncol(b1)) {
    b1[i, j] &lt;- ifelse(data.ind[i, j] != 1, NA,
                       miss.dat[i, j])
    b2[i, j] &lt;- ifelse(data.ind[i, j] == 0, NA, miss.dat[i, j])
  }
}
colnames(b1) &lt;- colnames(b2) &lt;- colnames(miss.dat)

#### create a matrix for including the lower and upper bounds
bounds &lt;- list()
bounds[[1]] &lt;- b1; bounds[[2]] &lt;- b2

### prior specifications
prior.param &lt;- list(
  mu.0 = rep(0, p),
  Lambda.0 = diag(100, p),
  kappa.0 = 2,
  nu.0 = p * (p + 1) / 2
)

### starting values
start.vals &lt;- list(
  mu = rep(0, p),
  sigma = diag(100, p)
)

### imputation
sim.res &lt;- multiple.imputation(
   data = bounds,
   prior.params = prior.param,
   initial.values = start.vals,
   iter = 500,
   verbose = FALSE
)

## End(Not run)

</code></pre>

<hr>
<h2 id='NHANES.dat'>Combined NHANES dataset from 1999-2004 NHANES study</h2><span id='topic+NHANES.dat'></span>

<h3>Description</h3>

<p>A dataset including the age, gender and diastolic blood pressure, body mass index and 24 PCB
measurements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NHANES.dat
</code></pre>


<h3>Format</h3>

<p>A list including data frame with 5874 rows and 24 variables and associated indicator matrix:
</p>

<dl>
<dt>BPXDAR</dt><dd><p>Diastolic blood pressure</p>
</dd>
<dt>RIAGENDR</dt><dd><p>Gender, 1 = male, 2 = female</p>
</dd>
<dt>RIDAGEYR</dt><dd><p>Age in years</p>
</dd>
<dt>BMXBMI</dt><dd><p>Body mass index</p>
</dd>
</dl>



<h3>Details</h3>

<p>The dataset is combined from the NHANES release cycles 1999-2000, 2001-2002, and 2003-2004. Almost
all PCB have both the missing and censored values as falling below the limits of detection (LODs). The dataset include
two components, the first component is the observed NHANES data where the censored PCB measurements are replaced
by the LODs dividing the square root of 2. The second component is a data frame including the censoring indicators
of the data, in that data frame, 0 indicates an observed PCB measurement, 1 indicates a censored PCB measurement, and 'NA' indicates
a missing PCB measurement.
</p>


<h3>Note</h3>

<p>The subset provided here was selected to demonstrate the functionality of the mvnimpute package,
no clinical conclusions should be derived from it.
</p>


<h3>Source</h3>

<p><a href="https://www.cdc.gov/nchs/nhanes/index.htm">https://www.cdc.gov/nchs/nhanes/index.htm</a>
</p>

<hr>
<h2 id='simulated.dat'>Simulated continuous data with missing and censored values</h2><span id='topic+simulated.dat'></span>

<h3>Description</h3>

<p>A dataset including simulated data with missing and censored values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulated.dat
</code></pre>


<h3>Format</h3>

<p>A list including data matrix with 200 rows and 4 variables and associated indicator matrix:
</p>

<dl>
<dt>y</dt><dd><p>Outcome variable to be used in the regression model after imputation</p>
</dd>
<dt>x1</dt><dd><p>First covariate variable subject to MAR missing and non-informative censored values</p>
</dd>
<dt>x2</dt><dd><p>Second covariate variable subject to MAR missing and non-informative censored values</p>
</dd>
<dt>x3</dt><dd><p>Third covariate variable that is fully observed</p>
</dd>
</dl>



<h3>Details</h3>

<p>A simulated dataset and its associated indicator matrix are included into a list. In the
indicator matrix, 0 stands for the missing values, 1 stands for the observed values, and 3 stands
for the left censored values.
</p>

<hr>
<h2 id='visual.plot'>Draws percentage plot for different type of values</h2><span id='topic+visual.plot'></span>

<h3>Description</h3>

<p>Draws plot that graphically shows the percentages of the missing, censored and observed data. It supports
generating plots for all major types of censoring including left, right and interval censoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visual.plot(data.indicator, title = "Percentages of different data type")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="visual.plot_+3A_data.indicator">data.indicator</code></td>
<td>
<p>matrix including the data type indicators of the original data.</p>
</td></tr>
<tr><td><code id="visual.plot_+3A_title">title</code></td>
<td>
<p>title of the generated plot, default is set to &quot;Percentages of different data type&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function draws the plot that graphically shows the percentages of the missing, censored and observed
data in the dataset. <code>data.indicator</code> should be a matrix containing the data type indicators as generated in the
data preparation step. 0 for missing values, 1 for observed values, and 2 for right censored values, 3 for left censored values,
and 4 for interval censored values. <code>title</code> is the title
of the generated plot.
</p>


<h3>Value</h3>

<p>The plot that shows the details of the different type of data in the dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.ind &lt;- simulated.dat[[2]]
visual.plot(data.ind)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
