<!DOCTYPE html><html><head><title>Help for package remaCor</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {remaCor}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hotelling'><p>Hottelling T^2 test for multivariate regression</p></a></li>
<li><a href='#LS'><p>Fixed effect meta-analysis for correlated test statistics</p></a></li>
<li><a href='#LS.empirical'><p>Fixed effect meta-analysis for correlated test statistics</p></a></li>
<li><a href='#pkg.env'><p>Local environment</p></a></li>
<li><a href='#plotCor'><p>Correlation plot</p></a></li>
<li><a href='#plotForest'><p>Forest plot of coefficients</p></a></li>
<li><a href='#RE2C'><p>Random effect meta-analysis for correlated test statistics</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Random Effects Meta-Analysis for Correlated Test Statistics</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.18</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-08</td>
</tr>
<tr>
<td>Description:</td>
<td>Meta-analysis is widely used to summarize estimated effects sizes across multiple statistical tests. Standard fixed and random effect meta-analysis methods assume that the estimated of the effect sizes are statistically independent.  Here we relax this assumption and enable meta-analysis when the correlation matrix between effect size estimates is known.  Fixed effect meta-analysis uses the method of Lin and Sullivan (2009) &lt;<a href="https://doi.org/10.1016%2Fj.ajhg.2009.11.001">doi:10.1016/j.ajhg.2009.11.001</a>&gt;, and random effects meta-analysis uses the method of Han, et al. &lt;<a href="https://doi.org/10.1093%2Fhmg%2Fddw049">doi:10.1093/hmg/ddw049</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/Artistic-2.0">Artistic-2.0</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://diseaseneurogenomics.github.io/remaCor/">https://diseaseneurogenomics.github.io/remaCor/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/DiseaseNeurogenomics/remaCor/issues">https://github.com/DiseaseNeurogenomics/remaCor/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, RUnit, clusterGeneration, metafor</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), ggplot2, methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>mvtnorm, grid, reshape2, compiler, Rcpp, EnvStats, Rdpack,
stats</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-08 14:45:13 UTC; gabrielhoffman</td>
</tr>
<tr>
<td>Author:</td>
<td>Gabriel Hoffman <a href="https://orcid.org/0000-0002-0957-0224"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gabriel Hoffman &lt;gabriel.hoffman@mssm.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-08 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='hotelling'>Hottelling T^2 test for multivariate regression</h2><span id='topic+hotelling'></span>

<h3>Description</h3>

<p>Hottelling T^2 test compares estimated regression coefficients to specified values under the null.  This tests a global hypothesis for all specified coefficients.  It uses the F-distribution as the null for the test statistic which is exact under finite sample size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hotelling(beta, Sigma, n, mu_null = rep(0, length(beta)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hotelling_+3A_beta">beta</code></td>
<td>
<p>regressioin coefficients</p>
</td></tr>
<tr><td><code id="hotelling_+3A_sigma">Sigma</code></td>
<td>
<p>covariance matrix of regression coefficients</p>
</td></tr>
<tr><td><code id="hotelling_+3A_n">n</code></td>
<td>
<p>sample size used for estimation</p>
</td></tr>
<tr><td><code id="hotelling_+3A_mu_null">mu_null</code></td>
<td>
<p>the values of the regression coefficients under the null hypothesis.  Defaults to all zeros</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Hotelling T2 test is not defined when n - p &lt; 1.  Returns <code>data.frame</code> with <code>stat = pvalue = NA</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(clusterGeneration)
library(mvtnorm)

# sample size
n = 30

# number of response variables
m = 2

# Error covariance
Sigma = genPositiveDefMat(m)$Sigma

# regression parameters
beta = matrix(.6, 1, m)

# covariates
X = matrix(rnorm(n), ncol=1)

# Simulate response variables
Y = X %*% beta + rmvnorm(n, sigma = Sigma)

# Multivariate regression
fit = lm(Y ~ X)

# extract coefficients and covariance
# corresponding to the x variable
beta = coef(fit)['X',]
S = vcov(fit)[c(2,4), c(2,4)]

# perform Hotelling test
hotelling(beta, S, n)

</code></pre>

<hr>
<h2 id='LS'>Fixed effect meta-analysis for correlated test statistics</h2><span id='topic+LS'></span>

<h3>Description</h3>

<p>Fixed effect meta-analysis for correlated test statistics using the Lin-Sullivan method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LS(beta, stders, cor = diag(1, length(beta)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LS_+3A_beta">beta</code></td>
<td>
<p>regression coefficients from each analysis</p>
</td></tr>
<tr><td><code id="LS_+3A_stders">stders</code></td>
<td>
<p>standard errors corresponding to betas</p>
</td></tr>
<tr><td><code id="LS_+3A_cor">cor</code></td>
<td>
<p>correlation matrix between of test statistics.  Default considers uncorrelated test statistics</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Perform fixed effect meta-analysis for correlated test statistics using method of Lin and Sullivan (2009).  By default, correlation is set to identity matrix to for independent test statistics.  
</p>
<p>This method requires the correlation matrix to be symmatric positive definite (SPD).  If this condition is not satisfied, results will be NA.  If the matrix is not SPD, there is likely an issue with how it was generated. 
</p>
<p>However, evaluating the correlation between observations that are not pairwise complete can give correlation matricies that are not SPD.  In this case, consider running <code>Matrix::nearPD( x, corr=TRUE)</code> to produce the nearest SPD matrix to the input.
</p>


<h3>Value</h3>


<dl>
<dt>beta:</dt><dd><p>effect size</p>
</dd>
<dt>se:</dt><dd><p>effect size standard error</p>
</dd>
<dt>p:</dt><dd><p>p-value</p>
</dd>
</dl>



<h3>References</h3>


<p>Lin D, Sullivan PF (2009).
&ldquo;Meta-analysis of genome-wide association studies with overlapping subjects.&rdquo;
<em>The American Journal of Human Genetics</em>, <b>85</b>(6), 862&ndash;872.
<a href="https://doi.org/10.1016/j.ajhg.2009.11.001">https://doi.org/10.1016/j.ajhg.2009.11.001</a>.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(clusterGeneration)
library(mvtnorm)

# sample size
n = 30

# number of response variables
m = 6

# Error covariance
Sigma = genPositiveDefMat(m)$Sigma

# regression parameters
beta = matrix(.6, 1, m)

# covariates
X = matrix(rnorm(n), ncol=1)

# Simulate response variables
Y = X %*% beta + rmvnorm(n, sigma = Sigma)

# Multivariate regression
fit = lm(Y ~ X)

# Correlation between residuals
C = cor(residuals(fit))

# Extract effect sizes and standard errors from model fit
df = lapply(coef(summary(fit)), function(a) 
 data.frame(beta = a["X", 1], se = a["X", 2]))
df = do.call(rbind, df)

# Run fixed effects meta-analysis, 
# assume identity correlation  
LS( df$beta, df$se)
 
# Run fixed effects meta-analysis, 
# account for correlation 
LS( df$beta, df$se, C)
</code></pre>

<hr>
<h2 id='LS.empirical'>Fixed effect meta-analysis for correlated test statistics</h2><span id='topic+LS.empirical'></span>

<h3>Description</h3>

<p>Fixed effect meta-analysis for correlated test statistics using the Lin-Sullivan method using Monte Carlo draws from the null distribution to compute the p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LS.empirical(
  beta,
  stders,
  cor = diag(1, length(beta)),
  nu,
  n.mc.samples = 10000,
  seed = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LS.empirical_+3A_beta">beta</code></td>
<td>
<p>regression coefficients from each analysis</p>
</td></tr>
<tr><td><code id="LS.empirical_+3A_stders">stders</code></td>
<td>
<p>standard errors corresponding to betas</p>
</td></tr>
<tr><td><code id="LS.empirical_+3A_cor">cor</code></td>
<td>
<p>correlation matrix between of test statistics.  Default considers uncorrelated test statistics</p>
</td></tr>
<tr><td><code id="LS.empirical_+3A_nu">nu</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code id="LS.empirical_+3A_n.mc.samples">n.mc.samples</code></td>
<td>
<p>number of Monte Carlo samples</p>
</td></tr>
<tr><td><code id="LS.empirical_+3A_seed">seed</code></td>
<td>
<p>random seed so results are reproducable</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The theoretical null for the Lin-Sullivan statistic for fixed effects meta-analysis is chisq when the regression coefficients are estimated from a large sample size. But for finite sample size, this null distribution is not well characterized. In this case, we are not aware of a closed from cumulative distribution function.  Instead we draw covariance matrices from a Wishart distribution, sample coefficients from a multivariate normal with this covariance, and then compute the Lin-Sullivan statistic.  A gamma distribution is then fit to these  draws from the null distribution and a p-value is computed from the cumulative distribution function of this gamma.
</p>


<h3>See Also</h3>

<p><code>LS()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(clusterGeneration)
library(mvtnorm)

# sample size
n = 30

# number of response variables
m = 6

# Error covariance
Sigma = genPositiveDefMat(m)$Sigma

# regression parameters
beta = matrix(.6, 1, m)

# covariates
X = matrix(rnorm(n), ncol=1)

# Simulate response variables
Y = X %*% beta + rmvnorm(n, sigma = Sigma)

# Multivariate regression
fit = lm(Y ~ X)

# Correlation between residuals
C = cor(residuals(fit))

# Extract effect sizes and standard errors from model fit
df = lapply(coef(summary(fit)), function(a) 
	data.frame(beta = a["X", 1], se = a["X", 2]))
df = do.call(rbind, df)

# Meta-analysis assuming infinite sample size
# but the p-value is anti-conservative
LS(df$beta, df$se, C)

# Meta-analysis explicitly modeling the finite sample size
# Gives properly calibrated p-values
# nu is the residual degrees of freedom from the model fit
LS.empirical(df$beta, df$se, C, nu=n-2)
</code></pre>

<hr>
<h2 id='pkg.env'>Local environment</h2><span id='topic+pkg.env'></span>

<h3>Description</h3>

<p>Local environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkg.env
</code></pre>


<h3>Format</h3>

<p>An object of class <code>environment</code> of length 0.
</p>

<hr>
<h2 id='plotCor'>Correlation plot</h2><span id='topic+plotCor'></span>

<h3>Description</h3>

<p>Correlation plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCor(cor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCor_+3A_cor">cor</code></td>
<td>
<p>correlation matrix between of test statistics.  Default considers uncorrelated test statistics</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of correlation matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate effects
library(mvtnorm)
library(clusterGeneration )

n = 4
Sigma = cov2cor(genPositiveDefMat(n)$Sigma)
beta = t(rmvnorm(1, rep(0, n), Sigma))
stders = rep(.1, n)	

# set names
rownames(Sigma) = colnames(Sigma) = LETTERS[1:n]
rownames(beta) = names(stders) = LETTERS[1:n]

# Run random effects meta-analysis,
# account for correlation 
RE2C( beta, stders, Sigma)

# Make plot
plotCor( Sigma )

</code></pre>

<hr>
<h2 id='plotForest'>Forest plot of coefficients</h2><span id='topic+plotForest'></span>

<h3>Description</h3>

<p>Forest plot of coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotForest(beta, stders)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotForest_+3A_beta">beta</code></td>
<td>
<p>regression coefficients from each analysis</p>
</td></tr>
<tr><td><code id="plotForest_+3A_stders">stders</code></td>
<td>
<p>standard errors corresponding to betas</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Forest plot of effect sizes and standard errors
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate effects
library(mvtnorm)
library(clusterGeneration )

n = 4
Sigma = cov2cor(genPositiveDefMat(n)$Sigma)
beta = t(rmvnorm(1, rep(0, n), Sigma))
stders = rep(.1, n)	

# set names
rownames(Sigma) = colnames(Sigma) = LETTERS[1:n]
rownames(beta) = names(stders) = LETTERS[1:n]

# Run random effects meta-analysis,
# account for correlation 
RE2C( beta, stders, Sigma)

# Make plot
plotForest( beta, stders )

</code></pre>

<hr>
<h2 id='RE2C'>Random effect meta-analysis for correlated test statistics</h2><span id='topic+RE2C'></span>

<h3>Description</h3>

<p>Random effect meta-analysis for correlated test statistics using RE2C
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RE2C(beta, stders, cor = diag(1, length(beta)), twoStep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RE2C_+3A_beta">beta</code></td>
<td>
<p>regression coefficients from each analysis</p>
</td></tr>
<tr><td><code id="RE2C_+3A_stders">stders</code></td>
<td>
<p>standard errors corresponding to betas</p>
</td></tr>
<tr><td><code id="RE2C_+3A_cor">cor</code></td>
<td>
<p>correlation matrix between of test statistics.  Default considers uncorrelated test statistics</p>
</td></tr>
<tr><td><code id="RE2C_+3A_twostep">twoStep</code></td>
<td>
<p>Apply two step version of RE2C that is designed to be applied only after the fixed effect model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Perform random effect meta-analysis for correlated test statistics using RE2 method of Han and Eskin (2011), or RE2 for correlated test statistics from Han, et al., (2016).  Also uses RE2C method of Lee, Eskin and Han (2017) to further test for heterogenity in effect size. By default, correlation is set to identity matrix to for independent test statistics.
</p>
<p>This method requires the correlation matrix to be symmatric positive definite (SPD).  If this condition is not satisfied, results will be NA.  If the matrix is not SPD, there is likely an issue with how it was generated. 
</p>
<p>However, evaluating the correlation between observations that are not pairwise complete can give correlation matricies that are not SPD.  In this case, consider running <code>Matrix::nearPD( x, corr=TRUE)</code> to produce the nearest SPD matrix to the input.
</p>


<h3>Value</h3>


<dl>
<dt>stat1:</dt><dd><p>statistic testing effect mean</p>
</dd>
<dt>stat2:</dt><dd><p>statistic testing effect heterogeneity</p>
</dd>
<dt>RE2Cp:</dt><dd><p>RE2 p-value accounting for correlelation between tests</p>
</dd>
<dt>RE2Cp.twoStep:</dt><dd><p>two step RE2C test after fixed effect test.  Only evaluated if <code>twoStep==TRUE</code></p>
</dd>
<dt>QE:</dt><dd><p>test statistic for the test of (residual) heterogeneity</p>
</dd>
<dt>QEp:</dt><dd><p>p-value for the test of (residual) heterogeneity</p>
</dd>
<dt>Isq:</dt><dd><p>I^2 statistic</p>
</dd>
</dl>

<p><code>QE</code>, <code>QEp</code> and <code>ISq</code> are only evaluted if correlation is diagonal
</p>


<h3>References</h3>


<p>Lee CH, Eskin E, Han B (2017).
&ldquo;Increasing the power of meta-analysis of genome-wide association studies to detect heterogeneous effects.&rdquo;
<em>Bioinformatics</em>, <b>33</b>(14), i379&ndash;i388.
<a href="https://doi.org/10.1093/bioinformatics/btx242">https://doi.org/10.1093/bioinformatics/btx242</a>.
</p>
<p>Han B, Duong D, Sul JH, de Bakker PI, Eskin E, Raychaudhuri S (2016).
&ldquo;A general framework for meta-analyzing dependent studies with overlapping subjects in association mapping.&rdquo;
<em>Human Molecular Genetics</em>, <b>25</b>(9), 1857&ndash;1866.
<a href="https://doi.org/10.1093/hmg/ddw049">https://doi.org/10.1093/hmg/ddw049</a>.
</p>
<p>Han B, Eskin E (2011).
&ldquo;Random-effects model aimed at discovering associations in meta-analysis of genome-wide association studies.&rdquo;
<em>The American Journal of Human Genetics</em>, <b>88</b>(5), 586&ndash;598.
<a href="https://doi.org/10.1016/j.ajhg.2011.04.014">https://doi.org/10.1016/j.ajhg.2011.04.014</a>.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(clusterGeneration)
library(mvtnorm)

# sample size
n = 30

# number of response variables
m = 6

# Error covariance
Sigma = genPositiveDefMat(m)$Sigma

# regression parameters
beta = matrix(.6, 1, m)

# covariates
X = matrix(rnorm(n), ncol=1)

# Simulate response variables
Y = X %*% beta + rmvnorm(n, sigma = Sigma)

# Multivariate regression
fit = lm(Y ~ X)

# Correlation between residuals
C = cor(residuals(fit))

# Extract effect sizes and standard errors from model fit
df = lapply(coef(summary(fit)), function(a) 
 data.frame(beta = a["X", 1], se = a["X", 2]))
df = do.call(rbind, df)

# Run fixed effects meta-analysis, 
# assume identity correlation  
LS( df$beta, df$se)

# Run random effects meta-analysis,
# assume identity correlation  
RE2C( df$beta, df$se)

# Run fixed effects meta-analysis, 
# account for correlation 
LS( df$beta, df$se, C)

# Run random effects meta-analysis,
# account for correlation 
RE2C( df$beta, df$se, C)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
