<!DOCTYPE html><html lang="en"><head><title>Help for package ParallelPC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ParallelPC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cor2'><p>The Pearson's correlation test</p></a></li>
<li><a href='#fci_parallel'><p>Estimate a Partial Ancestral Graph using the FCI_parallel algorithm</p></a></li>
<li><a href='#fci_stable'><p>Estimate a PAG, using the FCI_stable algorithm</p></a></li>
<li><a href='#IDA_parallel'><p>Estimate  Total Causal Effects  using the IDA_parallel Algorithm</p></a></li>
<li><a href='#IDA_stable'><p>Estimate  Total Causal Effects</p></a></li>
<li><a href='#jointIDA_direct'><p>Estimate  Total Causal Effects  of Joint Interventions</p></a></li>
<li><a href='#jointIDA_parallel'><p>Estimate  Total Causal Effects  of Joint Interventions</p></a></li>
<li><a href='#mccor'><p>The Monte Carlo permutation test (mc-cor)</p></a></li>
<li><a href='#mcmig'><p>The Monte Carlo permutation test (mc-mi-g)</p></a></li>
<li><a href='#mczf'><p>The Monte Carlo permutation test for Gaussian conditional independence test</p></a></li>
<li><a href='#mig'><p>Mutual information test</p></a></li>
<li><a href='#migsh'><p>Shrinkage estimator for the mutual information (mi-g-sh)</p></a></li>
<li><a href='#pc_parallel'><p>Estimate the Equivalence Class of a DAG  using the PC_parallel Algorithm</p></a></li>
<li><a href='#pc_stable'><p>Estimate the Equivalence Class of a DAG using the PC_stable Algorithm</p></a></li>
<li><a href='#pcSelect_parallel'><p>Estimate subgraph around a response variable using pcSelect_parallel.</p></a></li>
<li><a href='#pcSelect_stable'><p>Estimate subgraph around a response variable using pcSelect</p></a></li>
<li><a href='#rfci_parallel'><p>Estimate a PAG fast using the RFCI_parallel Algorithm</p></a></li>
<li><a href='#rfci_stable'><p>Estimate a PAG using the RFCI_stable Algorithm</p></a></li>
<li><a href='#skeleton_parallel'><p>Estimate (Initial) Skeleton of a DAG.</p></a></li>
<li><a href='#skeleton_stable'><p>Estimate (Initial) Skeleton of a DAG using the PC_stable Algorithm</p></a></li>
<li><a href='#smccor'><p>The sequential Monte Carlo permutation test (smc-cor)</p></a></li>
<li><a href='#smcmig'><p>The sequential Monte Carlo permutation test (smc-mi-g)</p></a></li>
<li><a href='#smczf'><p>The sequential Monte Carlo permutation test for Gaussian conditional independence test.</p></a></li>
<li><a href='#zf'><p>Gaussian conditional independence test</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Paralellised Versions of Constraint Based Causal Discovery
Algorithms</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2015-10-30</td>
</tr>
<tr>
<td>Author:</td>
<td>Thuc Duy Le, Tao Hoang, Shu Hu, and Liang Zhang</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thuc Duy Le &lt;Thuc.Le@unisa.edu.au&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bnlearn, pcalg, parallel, Rgraphviz</td>
</tr>
<tr>
<td>Description:</td>
<td>Parallelise constraint based causality discovery and causal inference methods. The parallelised algorithms in the package will generate the same results as that of the 'pcalg' package but will be much more efficient. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2015-12-31 01:21:41 UTC; thucle</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2015-12-31 08:37:51</td>
</tr>
</table>
<hr>
<h2 id='cor2'>The Pearson's correlation test</h2><span id='topic+cor2'></span>

<h3>Description</h3>

<p>Linear correlation: Pearson's linear correlation test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor2(x, y, S, suffStat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor2_+3A_x">x</code>, <code id="cor2_+3A_y">y</code>, <code id="cor2_+3A_s">S</code></td>
<td>
<p>It is tested, whether x and y are conditionally independent given the subset S of
the remaining nodes. x, y, S all are integers, corresponding to variable or node
numbers.</p>
</td></tr>
<tr><td><code id="cor2_+3A_suffstat">suffStat</code></td>
<td>
<p>the dataset with rows are samples and columns are variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the p-value of the test.
</p>


<h3>References</h3>

<p>Marco Scutari (2010). Learning Bayesian Networks with the bnlearn R Package. Journal of Statistical Software, 35(3), 1-22.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
## Using cor2 as a conditional independence test
##########################################
library(pcalg)
library(bnlearn)
data("gmG")
suffStat&lt;-gmG$x
cor2(1,2,3,suffStat)
##Use cor2 with a causal discovery algorithm, e.g. PC
pc_stable(gmG$x, indepTest=cor2, p=ncol(gmG$x), alpha=0.01)
</code></pre>

<hr>
<h2 id='fci_parallel'>Estimate a Partial Ancestral Graph using the FCI_parallel algorithm</h2><span id='topic+fci_parallel'></span>

<h3>Description</h3>

<p>Estimate a Partial Ancestral Graph (PAG) from observational data, using the FCI_parallel Algorithm. This is the parallelised version of the FCI algorithm in the pcalg package.
The parameters are consistent with the FCI algorithm in pcalg, except the parameter num.cores for specifying the number of cores CPU.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fci_parallel(suffStat, indepTest, alpha, labels, p,
  skel.method = c("parallel"), mem.efficient = FALSE, type = c("normal",
  "anytime", "adaptive"), fixedGaps = NULL, fixedEdges = NULL,
  NAdelete = TRUE, m.max = Inf, pdsep.max = Inf, rules = rep(TRUE, 10),
  doPdsep = TRUE, biCC = FALSE, conservative = FALSE, maj.rule = FALSE,
  verbose = FALSE, num.cores = detectCores())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fci_parallel_+3A_suffstat">suffStat</code></td>
<td>
<p>Sufficient statistics: List containing all necessary elements for the conditional independence decisions in the function indepTest.</p>
</td></tr>
<tr><td><code id="fci_parallel_+3A_indeptest">indepTest</code></td>
<td>
<p>Predefined function for testing conditional independence. The function is internally called as indepTest(x,y,S,suffStat), and tests conditional independence of x and y given S. Here, x and y are variables, and S is a (possibly empty) vector of variables (all variables are denoted by their column numbers in the adjacency matrix). suffStat is a list containing all relevant elements for the conditional independence decisions. The return value of indepTest is the p-value of the test for conditional independence.</p>
</td></tr>
<tr><td><code id="fci_parallel_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for the individual conditional independence tests.</p>
</td></tr>
<tr><td><code id="fci_parallel_+3A_labels">labels</code></td>
<td>
<p>(optional) character vector of variable (or &quot;node&quot;) names. Typically preferred to specifying p.</p>
</td></tr>
<tr><td><code id="fci_parallel_+3A_p">p</code></td>
<td>
<p>(optional) number of variables (or nodes). May be specified if labels are not, in which case labels is set to 1:p.</p>
</td></tr>
<tr><td><code id="fci_parallel_+3A_skel.method">skel.method</code></td>
<td>
<p>Character string specifying method; the default, &quot;parallel&quot;, uses the parallelised method to build the skeleton of the graph, see skeleton_parallel.</p>
</td></tr>
<tr><td><code id="fci_parallel_+3A_mem.efficient">mem.efficient</code></td>
<td>
<p>Uses less amount of memory at any time point while running the algorithm.</p>
</td></tr>
<tr><td><code id="fci_parallel_+3A_type">type</code></td>
<td>
<p>Character string specifying the version of the FCI algorithm to be used. By default, it is &quot;normal&quot;, and so the normal FCI algorithm is called. If set to &quot;anytime&quot;, the 'Anytime FCI' is called and m.max needs to be specified. If set to &quot;adaptive&quot;, the 'Adaptive Anytime FCI' is called and m.max is not used. For more information, see Details.</p>
</td></tr>
<tr><td><code id="fci_parallel_+3A_fixedgaps">fixedGaps</code></td>
<td>
<p>A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is removed before starting the algorithm. Therefore, this edge is guaranteed to be absent in the resulting graph.</p>
</td></tr>
<tr><td><code id="fci_parallel_+3A_fixededges">fixedEdges</code></td>
<td>
<p>A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is never considered for removal. Therefore, this edge is guaranteed to be present in the resulting graph.</p>
</td></tr>
<tr><td><code id="fci_parallel_+3A_nadelete">NAdelete</code></td>
<td>
<p>If indepTest returns NA and this option is TRUE, the corresponding edge is deleted. If this option is FALSE, the edge is not deleted.</p>
</td></tr>
<tr><td><code id="fci_parallel_+3A_m.max">m.max</code></td>
<td>
<p>Maximum size of the conditioning sets that are considered in the conditional independence tests.</p>
</td></tr>
<tr><td><code id="fci_parallel_+3A_pdsep.max">pdsep.max</code></td>
<td>
<p>Maximum size of Possible-D-SEP for which subsets are considered as conditioning sets in the conditional independence tests. See pcalg for more details.</p>
</td></tr>
<tr><td><code id="fci_parallel_+3A_rules">rules</code></td>
<td>
<p>Logical vector of length 10 indicating which rules should be used when directing edges. See pcalg for more details.</p>
</td></tr>
<tr><td><code id="fci_parallel_+3A_dopdsep">doPdsep</code></td>
<td>
<p>If TRUE, Possible-D-SEP is computed for all nodes, and all subsets of Possible-D-SEP are considered as conditioning sets in the conditional independence tests, if not defined otherwise in pdsep.max. If FALSE, Possible-D-SEP is not computed, so that the algorithm simplifies to the Modified PC algorithm of Spirtes, Glymour and Scheines (2000, p.84).</p>
</td></tr>
<tr><td><code id="fci_parallel_+3A_bicc">biCC</code></td>
<td>
<p>If TRUE, only nodes on paths between nodes x and y are considered to be in Possible-D-SEP(x) when testing independence between x and y. Uses biconnected components, biConnComp from RBGL.</p>
</td></tr>
<tr><td><code id="fci_parallel_+3A_conservative">conservative</code></td>
<td>
<p>Logical indicating if the unshielded triples should be checked for ambiguity the second time when v-structures are determined.</p>
</td></tr>
<tr><td><code id="fci_parallel_+3A_maj.rule">maj.rule</code></td>
<td>
<p>Logical indicating if the unshielded triples should be checked for ambiguity the second time when v-structures are determined using a majority rule idea, which is less strict than the standard conservative. For more information, see details.</p>
</td></tr>
<tr><td><code id="fci_parallel_+3A_verbose">verbose</code></td>
<td>
<p>If true, more detailed output is provided.</p>
</td></tr>
<tr><td><code id="fci_parallel_+3A_num.cores">num.cores</code></td>
<td>
<p>Numbers of cores CPU to run the algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class fciAlgo (see fciAlgo in the pcalg package) containing the estimated graph (in the form of an adjacency matrix with various possible edge marks), the conditioning sets that lead to edge removals (sepset) and several other parameters.
</p>


<h3>References</h3>

<p>1. Diego Colombo, Marloes H Maathuis, Markus Kalisch, Thomas S Richardson, et al. Learning high-dimensional directed acyclic graphs with latent and selection variables. The Annals of Statistics, 40(1):294-321, 2012.
</p>
<p>2. Markus Kalisch, Martin Machler, Diego Colombo, Marloes H Maathuis, and Peter Buhlmann. Causal inference using graphical models with the r package pcalg.
Journal of Statistical Software, 47(11):1-26, 2012.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
## Using fci_parallel without mem.efficeient
##########################################
library(pcalg)
library(parallel)
data("gmG")
p&lt;-ncol(gmG$x)
suffStat&lt;-list(C=cor(gmG$x),n=nrow(gmG$x))
fci_parallel(suffStat, indepTest=gaussCItest, p=p, skel.method="parallel", alpha=0.01, num.cores=2)

##########################################
## Using fci_parallel with mem.efficeient
##########################################

suffStat&lt;-list(C=cor(gmG$x),n=nrow(gmG$x))
fci_parallel(suffStat, indepTest=gaussCItest, p=p, skel.method="parallel",
alpha=0.01, num.cores=2, mem.efficient=TRUE)

#################################################
## Using fci_parallel with mutual information test
#################################################
library(pcalg)
library(parallel)
data("gmG")
p&lt;-ncol(gmG$x)
#' # The first parameter is the dataset
fci_parallel(gmG$x, indepTest=mig, p=p, skel.method="parallel",
alpha=0.01, num.cores=2, mem.efficient=TRUE)
</code></pre>

<hr>
<h2 id='fci_stable'>Estimate a PAG, using the FCI_stable algorithm</h2><span id='topic+fci_stable'></span>

<h3>Description</h3>

<p>This is the FCI stable version in the pcalg package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fci_stable(suffStat, indepTest, alpha, labels, p, skel.method = c("stable",
  "original", "stable.fast"), type = c("normal", "anytime", "adaptive"),
  fixedGaps = NULL, fixedEdges = NULL, NAdelete = TRUE, m.max = Inf,
  pdsep.max = Inf, rules = rep(TRUE, 10), doPdsep = TRUE, biCC = FALSE,
  conservative = FALSE, maj.rule = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fci_stable_+3A_suffstat">suffStat</code></td>
<td>
<p>Sufficient statistics: List containing all necessary elements for the conditional independence decisions in the function indepTest.</p>
</td></tr>
<tr><td><code id="fci_stable_+3A_indeptest">indepTest</code></td>
<td>
<p>Predefined function for testing conditional independence. The function is internally called as indepTest(x,y,S,suffStat), and tests conditional independence of x and y given S. Here, x and y are variables, and S is a (possibly empty) vector of variables (all variables are denoted by their column numbers in the adjacency matrix). suffStat is a list containing all relevant elements for the conditional independence decisions. The return value of indepTest is the p-value of the test for conditional independence.</p>
</td></tr>
<tr><td><code id="fci_stable_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for the individual conditional independence tests.</p>
</td></tr>
<tr><td><code id="fci_stable_+3A_labels">labels</code></td>
<td>
<p>(optional) character vector of variable (or &quot;node&quot;) names. Typically preferred to specifying p.</p>
</td></tr>
<tr><td><code id="fci_stable_+3A_p">p</code></td>
<td>
<p>(optional) number of variables (or nodes). May be specified if labels are not, in which case labels is set to 1:p.</p>
</td></tr>
<tr><td><code id="fci_stable_+3A_skel.method">skel.method</code></td>
<td>
<p>Character string specifying method; the default, &quot;stable&quot;, provides an order-independent skeleton, see skeleton.</p>
</td></tr>
<tr><td><code id="fci_stable_+3A_type">type</code></td>
<td>
<p>Character string specifying the version of the FCI algorithm to be used. By default, it is &quot;normal&quot;, and so the normal FCI algorithm is called. If set to &quot;anytime&quot;, the 'Anytime FCI' is called and m.max needs to be specified. If set to &quot;adaptive&quot;, the 'Adaptive Anytime FCI' is called and m.max is not used. For more information, see the FCI function in the pcalg package.</p>
</td></tr>
<tr><td><code id="fci_stable_+3A_fixedgaps">fixedGaps</code></td>
<td>
<p>A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is removed before starting the algorithm. Therefore, this edge is guaranteed to be absent in the resulting graph.</p>
</td></tr>
<tr><td><code id="fci_stable_+3A_fixededges">fixedEdges</code></td>
<td>
<p>A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is never considered for removal. Therefore, this edge is guaranteed to be present in the resulting graph.</p>
</td></tr>
<tr><td><code id="fci_stable_+3A_nadelete">NAdelete</code></td>
<td>
<p>If indepTest returns NA and this option is TRUE, the corresponding edge is deleted. If this option is FALSE, the edge is not deleted.</p>
</td></tr>
<tr><td><code id="fci_stable_+3A_m.max">m.max</code></td>
<td>
<p>Maximum size of the conditioning sets that are considered in the conditional independence tests.</p>
</td></tr>
<tr><td><code id="fci_stable_+3A_pdsep.max">pdsep.max</code></td>
<td>
<p>Maximum size of Possible-D-SEP for which subsets are considered as conditioning sets in the conditional independence tests. See pcalg for more details.</p>
</td></tr>
<tr><td><code id="fci_stable_+3A_rules">rules</code></td>
<td>
<p>Logical vector of length 10 indicating which rules should be used when directing edges. See pcalg for more details.</p>
</td></tr>
<tr><td><code id="fci_stable_+3A_dopdsep">doPdsep</code></td>
<td>
<p>If TRUE, Possible-D-SEP is computed for all nodes, and all subsets of Possible-D-SEP are considered as conditioning sets in the conditional independence tests, if not defined otherwise in pdsep.max. If FALSE, Possible-D-SEP is not computed, so that the algorithm simplifies to the Modified PC algorithm of Spirtes, Glymour and Scheines (2000, p.84).</p>
</td></tr>
<tr><td><code id="fci_stable_+3A_bicc">biCC</code></td>
<td>
<p>If TRUE, only nodes on paths between nodes x and y are considered to be in Possible-D-SEP(x) when testing independence between x and y. Uses biconnected components, biConnComp from RBGL.</p>
</td></tr>
<tr><td><code id="fci_stable_+3A_conservative">conservative</code></td>
<td>
<p>Logical indicating if the unshielded triples should be checked for ambiguity the second time when v-structures are determined.</p>
</td></tr>
<tr><td><code id="fci_stable_+3A_maj.rule">maj.rule</code></td>
<td>
<p>Logical indicating if the unshielded triples should be checked for ambiguity the second time when v-structures are determined using a majority rule idea, which is less strict than the standard conservative. For more information, see details.</p>
</td></tr>
<tr><td><code id="fci_stable_+3A_verbose">verbose</code></td>
<td>
<p>If true, more detailed output is provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class fciAlgo (see fciAlgo in the pcalg package) containing the estimated graph (in the form of an adjacency matrix with various possible edge marks), the conditioning sets that lead to edge removals (sepset) and several other parameters.
</p>


<h3>References</h3>

<p>1. Diego Colombo, Marloes H Maathuis, Markus Kalisch, Thomas S Richardson, et al. Learning high-dimensional directed acyclic graphs with latent and selection variables. The Annals of Statistics, 40(1):294-321, 2012.
</p>
<p>2. Markus Kalisch, Martin Machler, Diego Colombo, Marloes H Maathuis, and Peter Buhlmann. Causal inference using graphical models with the r package pcalg.
Journal of Statistical Software, 47(11):1-26, 2012.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
## Using fci_stable
##########################################
library(pcalg)
library(parallel)
data("gmG")
p&lt;-ncol(gmG$x)
suffStat&lt;-list(C=cor(gmG$x),n=nrow(gmG$x))
fci_stable(suffStat, indepTest=gaussCItest, p=p, skel.method="stable", alpha=0.01)
</code></pre>

<hr>
<h2 id='IDA_parallel'>Estimate  Total Causal Effects  using the IDA_parallel Algorithm</h2><span id='topic+IDA_parallel'></span>

<h3>Description</h3>

<p>This is the parallelised version of the IDA (stable) algorithm in the pcalg package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IDA_parallel(datacsv, cause, effect, pcmethod, alpha, num.cores,
  mem.efficient = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IDA_parallel_+3A_datacsv">datacsv</code></td>
<td>
<p>The dataset in csv format.</p>
</td></tr>
<tr><td><code id="IDA_parallel_+3A_cause">cause</code></td>
<td>
<p>The number of integer positions of the cause variables in the dataset.</p>
</td></tr>
<tr><td><code id="IDA_parallel_+3A_effect">effect</code></td>
<td>
<p>The number of integer  positions of the target variables  in the dataset.</p>
</td></tr>
<tr><td><code id="IDA_parallel_+3A_pcmethod">pcmethod</code></td>
<td>
<p>Character string specifying method; the default, &quot;parallel&quot;, will use the parallelised method for learning the skeleton of the graph, see skeleton_parallel.</p>
</td></tr>
<tr><td><code id="IDA_parallel_+3A_alpha">alpha</code></td>
<td>
<p>significance level (number in (0; 1) for the individual conditional independence tests.</p>
</td></tr>
<tr><td><code id="IDA_parallel_+3A_num.cores">num.cores</code></td>
<td>
<p>The numbers of cores CPU to run the algorithm</p>
</td></tr>
<tr><td><code id="IDA_parallel_+3A_mem.efficient">mem.efficient</code></td>
<td>
<p>If TRUE, uses less amount of memory at any time point while running the algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix that shows the causal effects (minimum of all possible effects) of the causes (columns) on the effects (rows)
</p>


<h3>References</h3>

<p>Marloes H Maathuis, Markus Kalisch, Peter Buhlmann, et al. Estimating high-dimensional
intervention effects from observational data. The Annals of Statistics, 37(6A):3133-3164,2009.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
## Using IDA_parallel without mem.efficeient
##########################################
library(bnlearn)
library(pcalg)
library(parallel)
data("gmI")
datacsv &lt;- cov(gmI$x)
IDA_parallel(datacsv,1:2,3:4,"parallel",0.01, 2)

##########################################
## Using IDA_parallel with mem.efficeient
##########################################
library(bnlearn)
library(pcalg)
library(parallel)
data("gmI")
datacsv &lt;- cov(gmI$x)
IDA_parallel(datacsv,1:2,3:4,"parallel",0.01, 2, TRUE)
</code></pre>

<hr>
<h2 id='IDA_stable'>Estimate  Total Causal Effects</h2><span id='topic+IDA_stable'></span>

<h3>Description</h3>

<p>This the stable version (using stable-PC for structure learning) of the IDA algorithm in the pcalg package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IDA_stable(datacsv, cause, effect, pcmethod, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IDA_stable_+3A_datacsv">datacsv</code></td>
<td>
<p>The dataset in csv format with rows are samples and columns are variables</p>
</td></tr>
<tr><td><code id="IDA_stable_+3A_cause">cause</code></td>
<td>
<p>The number of integer positions of the cause variables in the dataset</p>
</td></tr>
<tr><td><code id="IDA_stable_+3A_effect">effect</code></td>
<td>
<p>The number of integer positions of the target variables  in the dataset.</p>
</td></tr>
<tr><td><code id="IDA_stable_+3A_pcmethod">pcmethod</code></td>
<td>
<p>Character string specifying method; the default, &quot;stable&quot;, provides an order-independent skeleton. See Colombo, 2014.</p>
</td></tr>
<tr><td><code id="IDA_stable_+3A_alpha">alpha</code></td>
<td>
<p>significance level (number in (0; 1) for the individual conditional independence tests.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix that shows the causal effects (minimum of all possible effects) of the causes (columns) on the effects (rows).
</p>


<h3>References</h3>

<p>1. Marloes H Maathuis, Markus Kalisch, Peter Buhlmann, et al. Estimating high-dimensional
intervention effects from observational data. The Annals of Statistics, 37(6A):3133-3164,2009.
</p>
<p>2. Diego Colombo and Marloes H Maathuis. Order-independent constraint-based causal structure learning. The Journal of Machine Learning Research, 15(1):3741-3782, 2014.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
## Using IDA_stable
##########################################
library(pcalg)
data("gmI")
datacsv &lt;- cov(gmI$x)
IDA_stable(datacsv,1:2,3:4,"stable",0.01)
</code></pre>

<hr>
<h2 id='jointIDA_direct'>Estimate  Total Causal Effects  of Joint Interventions</h2><span id='topic+jointIDA_direct'></span>

<h3>Description</h3>

<p>This is the parallelised version of the jointIDA (stable) algorithm in the pcalg package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jointIDA_direct(datacsv, cause, effect, method = c("min", "max", "median"),
  pcmethod = "stable", alpha, num.cores = 1, mem.efficient = FALSE,
  technique = c("RRC", "MCD"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jointIDA_direct_+3A_datacsv">datacsv</code></td>
<td>
<p>The dataset in the csv format with rows are samples and columns are the variables.</p>
</td></tr>
<tr><td><code id="jointIDA_direct_+3A_cause">cause</code></td>
<td>
<p>The number of integer positions of the intervention variables in the dataset.</p>
</td></tr>
<tr><td><code id="jointIDA_direct_+3A_effect">effect</code></td>
<td>
<p>the  integer position of the target variable in the dataset.</p>
</td></tr>
<tr><td><code id="jointIDA_direct_+3A_method">method</code></td>
<td>
<p>the method of calculating the final effect from multiple possible effects, e.g. min, max, median</p>
</td></tr>
<tr><td><code id="jointIDA_direct_+3A_pcmethod">pcmethod</code></td>
<td>
<p>Character string specifying the method of the PC algorithm, e.g. stable for stable-PC, and parallel for parallel-PC.</p>
</td></tr>
<tr><td><code id="jointIDA_direct_+3A_alpha">alpha</code></td>
<td>
<p>significance level (number in (0; 1) for the conditional independence tests.</p>
</td></tr>
<tr><td><code id="jointIDA_direct_+3A_num.cores">num.cores</code></td>
<td>
<p>The numbers of cores CPU to run the algorithm</p>
</td></tr>
<tr><td><code id="jointIDA_direct_+3A_mem.efficient">mem.efficient</code></td>
<td>
<p>If TRUE, uses less amount of memory at any time point while running the algorithm</p>
</td></tr>
<tr><td><code id="jointIDA_direct_+3A_technique">technique</code></td>
<td>
<p>The character string specifying the technique that will be used to estimate the total joint causal effects in the pcalg package.
RRC for Recursive regression for causal effects
MCD for Modifying the Cholesky decomposition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix that shows the direct causal effects (minimum of all possible effects) of the (first) cause (columns) on the effects (rows)
</p>

<hr>
<h2 id='jointIDA_parallel'>Estimate  Total Causal Effects  of Joint Interventions</h2><span id='topic+jointIDA_parallel'></span>

<h3>Description</h3>

<p>This is the parallelised version of the IDA (stable) algorithm in the pcalg package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jointIDA_parallel(datacsv, cause, effect, pcmethod = "stable", alpha,
  num.cores = 1, mem.efficient = FALSE, technique = c("RRC", "MCD"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jointIDA_parallel_+3A_datacsv">datacsv</code></td>
<td>
<p>The dataset in csv format with rows are samples and columns are variables.</p>
</td></tr>
<tr><td><code id="jointIDA_parallel_+3A_cause">cause</code></td>
<td>
<p>The number of integer positions of the intervention variables in the dataset.</p>
</td></tr>
<tr><td><code id="jointIDA_parallel_+3A_effect">effect</code></td>
<td>
<p>the integer position of the target variable in the dataset.</p>
</td></tr>
<tr><td><code id="jointIDA_parallel_+3A_pcmethod">pcmethod</code></td>
<td>
<p>Character string specifying the method of the PC algorithm, e.g. stable for stable-PC, and parallel for parallel-PC.</p>
</td></tr>
<tr><td><code id="jointIDA_parallel_+3A_alpha">alpha</code></td>
<td>
<p>significance level (number in (0; 1) for the conditional independence tests.</p>
</td></tr>
<tr><td><code id="jointIDA_parallel_+3A_num.cores">num.cores</code></td>
<td>
<p>The numbers of cores CPU to run the algorithm</p>
</td></tr>
<tr><td><code id="jointIDA_parallel_+3A_mem.efficient">mem.efficient</code></td>
<td>
<p>If TRUE, uses less amount of memory at any time point while running the algorithm</p>
</td></tr>
<tr><td><code id="jointIDA_parallel_+3A_technique">technique</code></td>
<td>
<p>The character string specifying the technique that will be used to estimate the total joint causal effects in the pcalg package.
RRC for Recursive regression for causal effects
MCD for Modifying the Cholesky decomposition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix that shows the causal effects  of the causes (rows) on the effect. Different columns show different possible causal effect values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
## Using IDA_parallel without mem.efficeient
##########################################
library(bnlearn)
library(pcalg)
library(parallel)
data("gmI")
datacsv &lt;- cov(gmI$x)
jointIDA_parallel(datacsv,1:2,3, pcmethod="parallel",0.01, 2, technique="RRC")

##########################################
## Using IDA_parallel with mem.efficeient
##########################################
library(bnlearn)
library(pcalg)
library(parallel)
data("gmI")
datacsv &lt;- cov(gmI$x)
jointIDA_parallel(datacsv,1:2,3, pcmethod="parallel",0.01, 2, TRUE, technique="RRC")
</code></pre>

<hr>
<h2 id='mccor'>The Monte Carlo permutation test (mc-cor)</h2><span id='topic+mccor'></span>

<h3>Description</h3>

<p>The Monte Carlo permutation test for Pearson's chi-square. See bnlearn package for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mccor(x, y, S, suffStat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mccor_+3A_x">x</code>, <code id="mccor_+3A_y">y</code>, <code id="mccor_+3A_s">S</code></td>
<td>
<p>It is tested, whether x and y are conditionally independent given the subset S of
the remaining nodes. x, y, S all are integers, corresponding to variable or node
numbers.</p>
</td></tr>
<tr><td><code id="mccor_+3A_suffstat">suffStat</code></td>
<td>
<p>The dataset in matrix format with rows are samples and columns are variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The p-value of the test.
</p>


<h3>References</h3>

<p>Marco Scutari (2010). Learning Bayesian Networks with the bnlearn R Package. Journal of Statistical Software, 35(3), 1-22.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
## Using mccor
##########################################
library(bnlearn)
library(pcalg)
data("gmG")
suffStat&lt;-gmG$x
mccor(1,2,3,suffStat)
</code></pre>

<hr>
<h2 id='mcmig'>The Monte Carlo permutation test (mc-mi-g)</h2><span id='topic+mcmig'></span>

<h3>Description</h3>

<p>The Monte Carlo permutation test for mutual information. See bnlearn package for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmig(x, y, S, suffStat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmig_+3A_x">x</code>, <code id="mcmig_+3A_y">y</code>, <code id="mcmig_+3A_s">S</code></td>
<td>
<p>It is tested, whether x and y are conditionally independent given the subset S of
the remaining nodes. x, y, S all are integers, corresponding to variable or node
numbers.</p>
</td></tr>
<tr><td><code id="mcmig_+3A_suffstat">suffStat</code></td>
<td>
<p>The dataset in matrix format with rows are samples and columns are variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the p-value of the test.
</p>


<h3>References</h3>

<p>Marco Scutari (2010). Learning Bayesian Networks with the bnlearn R Package. Journal of Statistical Software, 35(3), 1-22.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
## Using mcmig
##########################################
library(bnlearn)
library(pcalg)
data("gmG")
suffStat&lt;-gmG$x
mcmig(1,2,3,suffStat)
</code></pre>

<hr>
<h2 id='mczf'>The Monte Carlo permutation test for Gaussian conditional independence test</h2><span id='topic+mczf'></span>

<h3>Description</h3>

<p>The Monte Carlo permutation test for Gaussian conditional independence test. See the mc-zf function in the bnlearn package for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mczf(x, y, S, suffStat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mczf_+3A_x">x</code>, <code id="mczf_+3A_y">y</code>, <code id="mczf_+3A_s">S</code></td>
<td>
<p>It is tested, whether x and y are conditionally independent given the subset S of
the remaining nodes. x, y, S all are integers, corresponding to variable or node
numbers.</p>
</td></tr>
<tr><td><code id="mczf_+3A_suffstat">suffStat</code></td>
<td>
<p>The dataset in matrix format with rows are samples and columns are variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the p-value of the test.
</p>


<h3>References</h3>

<p>Marco Scutari (2010). Learning Bayesian Networks with the bnlearn R Package. Journal of Statistical Software, 35(3), 1-22.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
## Using mczf
##########################################
library(bnlearn)
library(pcalg)
data("gmG")
suffStat&lt;-gmG$x
mczf(1,2,3,suffStat)
</code></pre>

<hr>
<h2 id='mig'>Mutual information test</h2><span id='topic+mig'></span>

<h3>Description</h3>

<p>Mutual information test. See function mi-g in bnlearn package for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mig(x, y, S, suffStat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mig_+3A_x">x</code>, <code id="mig_+3A_y">y</code>, <code id="mig_+3A_s">S</code></td>
<td>
<p>It is tested, whether x and y are conditionally independent given the subset S of
the remaining nodes. x, y, S all are integers, corresponding to variable or node
numbers.</p>
</td></tr>
<tr><td><code id="mig_+3A_suffstat">suffStat</code></td>
<td>
<p>The dataset in matrix format with rows are samples and columns are variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The p-value of the test.
</p>


<h3>References</h3>

<p>Marco Scutari (2010). Learning Bayesian Networks with the bnlearn R Package. Journal of Statistical Software, 35(3), 1-22.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
## Using mig
##########################################
library(bnlearn)
library(pcalg)
data("gmG")
suffStat&lt;-gmG$x
mig(1,2,3,suffStat)
</code></pre>

<hr>
<h2 id='migsh'>Shrinkage estimator for the mutual information (mi-g-sh)</h2><span id='topic+migsh'></span>

<h3>Description</h3>

<p>Shrinkage estimator for the mutual information. See bnlearn package for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>migsh(x, y, S, suffStat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="migsh_+3A_x">x</code>, <code id="migsh_+3A_y">y</code>, <code id="migsh_+3A_s">S</code></td>
<td>
<p>It is tested, whether x and y are conditionally independent given the subset S of
the remaining nodes. x, y, S all are integers, corresponding to variable or node
numbers.</p>
</td></tr>
<tr><td><code id="migsh_+3A_suffstat">suffStat</code></td>
<td>
<p>The dataset in matrix format with rows are samples and columns are variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The p-value of the test.
</p>


<h3>References</h3>

<p>Marco Scutari (2010). Learning Bayesian Networks with the bnlearn R Package. Journal of Statistical Software, 35(3), 1-22.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
## Using migsh
##########################################
library(bnlearn)
library(pcalg)
data("gmG")
suffStat&lt;-gmG$x
migsh(1,2,3,suffStat)
</code></pre>

<hr>
<h2 id='pc_parallel'>Estimate the Equivalence Class of a DAG  using the PC_parallel Algorithm</h2><span id='topic+pc_parallel'></span>

<h3>Description</h3>

<p>Estimate the equivalence class of a directed acyclic graph (DAG) from observational data, using the PC_parallel algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pc_parallel(suffStat, indepTest, alpha, labels, p, fixedGaps = NULL,
  fixedEdges = NULL, NAdelete = TRUE, m.max = Inf, u2pd = c("relaxed",
  "rand", "retry"), skel.method = c("parallel"), mem.efficient = FALSE,
  conservative = FALSE, maj.rule = FALSE, solve.confl = FALSE,
  verbose = FALSE, num.cores = detectCores())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pc_parallel_+3A_suffstat">suffStat</code></td>
<td>
<p>A list of sufficient statistics, containing all necessary elements for the conditional independence decisions in the function indepTest.</p>
</td></tr>
<tr><td><code id="pc_parallel_+3A_indeptest">indepTest</code></td>
<td>
<p>A function for testing conditional independence. It is internally called as indepTest(x,y,S,suffStat), and tests conditional independence of x and y given S. Here, x and y are variables, and S is a (possibly empty) vector of variables (all variables are denoted by their column numbers in the adjacency matrix). suffStat is a list, see the argument above. The return value of indepTest is the p-value of the test for conditional independence.</p>
</td></tr>
<tr><td><code id="pc_parallel_+3A_alpha">alpha</code></td>
<td>
<p>significance level (number in (0,1) for the individual conditional independence tests.</p>
</td></tr>
<tr><td><code id="pc_parallel_+3A_labels">labels</code></td>
<td>
<p>(optional) character vector of variable (or &quot;node&quot;) names. Typically preferred to specifying p.</p>
</td></tr>
<tr><td><code id="pc_parallel_+3A_p">p</code></td>
<td>
<p>(optional) number of variables (or nodes). May be specified if labels are not, in which case labels is set to 1:p.</p>
</td></tr>
<tr><td><code id="pc_parallel_+3A_fixedgaps">fixedGaps</code></td>
<td>
<p>A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is removed before starting the algorithm. Therefore, this edge is guaranteed to be absent in the resulting graph.</p>
</td></tr>
<tr><td><code id="pc_parallel_+3A_fixededges">fixedEdges</code></td>
<td>
<p>A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is never considered for removal. Therefore, this edge is guaranteed to be present in the resulting graph.</p>
</td></tr>
<tr><td><code id="pc_parallel_+3A_nadelete">NAdelete</code></td>
<td>
<p>If indepTest returns NA and this option is TRUE, the corresponding edge is deleted. If this option is FALSE, the edge is not deleted.</p>
</td></tr>
<tr><td><code id="pc_parallel_+3A_m.max">m.max</code></td>
<td>
<p>Maximal size of the conditioning sets that are considered in the conditional independence tests.</p>
</td></tr>
<tr><td><code id="pc_parallel_+3A_u2pd">u2pd</code></td>
<td>
<p>String specifying the method for dealing with conflicting information when trying to orient edges (see pcalg for details).</p>
</td></tr>
<tr><td><code id="pc_parallel_+3A_skel.method">skel.method</code></td>
<td>
<p>Character string specifying method; the default, &quot;parallel&quot;,  skeleton_parallel for learning the causal structure.</p>
</td></tr>
<tr><td><code id="pc_parallel_+3A_mem.efficient">mem.efficient</code></td>
<td>
<p>If TRUE, uses less amount of memory at any time point while running the algorithm.</p>
</td></tr>
<tr><td><code id="pc_parallel_+3A_conservative">conservative</code></td>
<td>
<p>Logical indicating if the conservative PC is used. In this case, only option u2pd = &quot;relaxed&quot; is supported. Note that therefore the resulting object might not be extendable to a DAG. See pcalg for details.</p>
</td></tr>
<tr><td><code id="pc_parallel_+3A_maj.rule">maj.rule</code></td>
<td>
<p>Logical indicating that the triples shall be checked for ambiguity using a majority rule idea, which is less strict than the conservative PC algorithm. For more information, see pcalg.</p>
</td></tr>
<tr><td><code id="pc_parallel_+3A_solve.confl">solve.confl</code></td>
<td>
<p>If TRUE, the orientation of the v-structures and the orientation rules work with lists for candidate sets and allow bi-directed edges to resolve conflicting edge orientations.See pcalg for details.</p>
</td></tr>
<tr><td><code id="pc_parallel_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, detailed output is provided.</p>
</td></tr>
<tr><td><code id="pc_parallel_+3A_num.cores">num.cores</code></td>
<td>
<p>The numbers of cores CPU to run the algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;pcAlgo&quot; (see pcAlgo in the pcalg package) containing an estimate of the equivalence class of the underlying DAG.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
## Using pc_parallel without mem.efficeient
##########################################
library(pcalg)
library(parallel)
data("gmG")
p&lt;-ncol(gmG$x)
suffStat&lt;-list(C=cor(gmG$x),n=nrow(gmG$x))
pc_parallel(suffStat, indepTest=gaussCItest, p=p, skel.method="parallel", alpha=0.01, num.cores=2)

##########################################
## Using pc_parallel with mem.efficeient
##########################################
library(pcalg)
library(parallel)
data("gmG")
p&lt;-ncol(gmG$x)
suffStat&lt;-list(C=cor(gmG$x),n=nrow(gmG$x))
pc_parallel(suffStat, indepTest=gaussCItest, p=p, skel.method="parallel",
alpha=0.01, num.cores=2, mem.efficient=TRUE)

#################################################
## Using pc_parallel with mutual information test
#################################################
library(pcalg)
library(parallel)
data("gmG")
p&lt;-ncol(gmG$x)
#The first parameter is the dataset rather than suffStat
pc_parallel(gmG$x, indepTest=mig, p=p, skel.method="parallel",
alpha=0.01, num.cores=2, mem.efficient=TRUE)
</code></pre>

<hr>
<h2 id='pc_stable'>Estimate the Equivalence Class of a DAG using the PC_stable Algorithm</h2><span id='topic+pc_stable'></span>

<h3>Description</h3>

<p>Estimate the equivalence class of a directed acyclic graph (DAG) from observational data, using the PC_stable algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pc_stable(suffStat, indepTest, alpha, labels, p, fixedGaps = NULL,
  fixedEdges = NULL, NAdelete = TRUE, m.max = Inf, u2pd = c("relaxed",
  "rand", "retry"), skel.method = c("stable", "original", "stable.fast"),
  conservative = FALSE, maj.rule = FALSE, solve.confl = FALSE,
  verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pc_stable_+3A_suffstat">suffStat</code></td>
<td>
<p>A list of sufficient statistics, containing all necessary elements for the conditional independence decisions in the function indepTest.</p>
</td></tr>
<tr><td><code id="pc_stable_+3A_indeptest">indepTest</code></td>
<td>
<p>A function for testing conditional independence. It is internally called as indepTest(x,y,S,suffStat), and tests conditional independence of x and y given S. Here, x and y are variables, and S is a (possibly empty) vector of variables (all variables are denoted by their column numbers in the adjacency matrix). suffStat is a list, see the argument above. The return value of indepTest is the p-value of the test for conditional independence.</p>
</td></tr>
<tr><td><code id="pc_stable_+3A_alpha">alpha</code></td>
<td>
<p>significance level (number in (0,1) for the individual conditional independence tests.</p>
</td></tr>
<tr><td><code id="pc_stable_+3A_labels">labels</code></td>
<td>
<p>(optional) character vector of variable (or &quot;node&quot;) names. Typically preferred to specifying p.</p>
</td></tr>
<tr><td><code id="pc_stable_+3A_p">p</code></td>
<td>
<p>(optional) number of variables (or nodes). May be specified if labels are not, in which case labels is set to 1:p.</p>
</td></tr>
<tr><td><code id="pc_stable_+3A_fixedgaps">fixedGaps</code></td>
<td>
<p>A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is removed before starting the algorithm. Therefore, this edge is guaranteed to be absent in the resulting graph.</p>
</td></tr>
<tr><td><code id="pc_stable_+3A_fixededges">fixedEdges</code></td>
<td>
<p>A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is never considered for removal. Therefore, this edge is guaranteed to be present in the resulting graph.</p>
</td></tr>
<tr><td><code id="pc_stable_+3A_nadelete">NAdelete</code></td>
<td>
<p>If indepTest returns NA and this option is TRUE, the corresponding edge is deleted. If this option is FALSE, the edge is not deleted.</p>
</td></tr>
<tr><td><code id="pc_stable_+3A_m.max">m.max</code></td>
<td>
<p>Maximal size of the conditioning sets that are considered in the conditional independence tests.</p>
</td></tr>
<tr><td><code id="pc_stable_+3A_u2pd">u2pd</code></td>
<td>
<p>String specifying the method for dealing with conflicting information when trying to orient edges (see pcalg for details).</p>
</td></tr>
<tr><td><code id="pc_stable_+3A_skel.method">skel.method</code></td>
<td>
<p>Character string specifying method; the default, &quot;stable&quot; provides an order-independent skeleton.</p>
</td></tr>
<tr><td><code id="pc_stable_+3A_conservative">conservative</code></td>
<td>
<p>Logical indicating if the conservative PC is used. In this case, only option u2pd = &quot;relaxed&quot; is supported. See pcalg for more information.</p>
</td></tr>
<tr><td><code id="pc_stable_+3A_maj.rule">maj.rule</code></td>
<td>
<p>Logical indicating that the triples shall be checked for ambiguity using a majority rule idea, which is less strict than the conservative PC algorithm. For more information, see the pcalg package.</p>
</td></tr>
<tr><td><code id="pc_stable_+3A_solve.confl">solve.confl</code></td>
<td>
<p>If TRUE, the orientation of the v-structures and the orientation rules work with lists for candidate sets and allow bi-directed edges to resolve conflicting edge orientations. In this case, only option u2pd = relaxed is supported. Note, that therefore the resulting object might not be a CPDAG because bi-directed edges might be present. See details for more information.</p>
</td></tr>
<tr><td><code id="pc_stable_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, detailed output is provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;pcAlgo&quot; (see pcAlgo in the pcalg package) containing an estimate of the equivalence class of the underlying DAG.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
## Using pc_stable
##########################################
library(pcalg)
library(parallel)
data("gmG")
p&lt;-ncol(gmG$x)
suffStat&lt;-list(C=cor(gmG$x),n=nrow(gmG$x))
pc_stable(suffStat, indepTest=gaussCItest, p=p, skel.method="stable", alpha=0.01)
</code></pre>

<hr>
<h2 id='pcSelect_parallel'>Estimate subgraph around a response variable using pcSelect_parallel.</h2><span id='topic+pcSelect_parallel'></span>

<h3>Description</h3>

<p>This is the parallelised version of the pcSelect (stable) function in the pcalg package. Assume that we have a fixed target variable, the algorithm will test the
dependency between each variable and the target variable conditioning on combinations of other variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcSelect_parallel(y, dm, method = c("parallel"), mem.efficient = FALSE,
  num_workers, alpha, corMethod = "standard", verbose = FALSE,
  directed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcSelect_parallel_+3A_y">y</code></td>
<td>
<p>The target (response) variable.</p>
</td></tr>
<tr><td><code id="pcSelect_parallel_+3A_dm">dm</code></td>
<td>
<p>Data matrix with rows are samples and columns are variables.</p>
</td></tr>
<tr><td><code id="pcSelect_parallel_+3A_method">method</code></td>
<td>
<p>Character string specifying method; the default, &quot;parallel&quot; provides an parallelised method to implement all the conditional independence tests.</p>
</td></tr>
<tr><td><code id="pcSelect_parallel_+3A_mem.efficient">mem.efficient</code></td>
<td>
<p>If TRUE, uses less amount of memory at any time point while running the algorithm</p>
</td></tr>
<tr><td><code id="pcSelect_parallel_+3A_num_workers">num_workers</code></td>
<td>
<p>The numbers of cores CPU to run the algorithm</p>
</td></tr>
<tr><td><code id="pcSelect_parallel_+3A_alpha">alpha</code></td>
<td>
<p>Significance level of individual partial correlation tests.</p>
</td></tr>
<tr><td><code id="pcSelect_parallel_+3A_cormethod">corMethod</code></td>
<td>
<p>&quot;standard&quot; or &quot;Qn&quot; for standard or robust correlation estimation</p>
</td></tr>
<tr><td><code id="pcSelect_parallel_+3A_verbose">verbose</code></td>
<td>
<p>Logical or in {0,1,2};
</p>
<p>FALSE, 0: No output,
</p>
<p>TRUE, 1: Little output,
</p>
<p>2: Detailed output.
</p>
<p>Note that such output makes the function very much slower.</p>
</td></tr>
<tr><td><code id="pcSelect_parallel_+3A_directed">directed</code></td>
<td>
<p>Logical; should the output graph be directed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>G    A logical vector indicating which column of dm is associated with y.
</p>
<p>zMin   The minimal z-values when testing partial correlations between y and each column of dm. The larger the number, the more consistent is the edge with the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
## Using pcSelect_parallel without mem.efficeient
##########################################
library(pcalg)
library(parallel)
p &lt;- 10
set.seed(101)
myDAG &lt;- randomDAG(p, prob = 0.2)
n &lt;- 1000
d.mat &lt;- rmvDAG(n, myDAG, errDist = "normal")
pcSelect_parallel(d.mat[,10],d.mat[,-10], alpha=0.05,num_workers=2)

##########################################
## Using pcSelelct_parallel with mem.efficeient
##########################################
library(pcalg)
library(parallel)
p &lt;- 10
set.seed(101)
myDAG &lt;- randomDAG(p, prob = 0.2)
n &lt;- 1000
d.mat &lt;- rmvDAG(n, myDAG, errDist = "normal")
pcSelect_parallel(d.mat[,10],d.mat[,-10], alpha=0.05,mem.efficient=TRUE,num_workers=2)
</code></pre>

<hr>
<h2 id='pcSelect_stable'>Estimate subgraph around a response variable using pcSelect</h2><span id='topic+pcSelect_stable'></span>

<h3>Description</h3>

<p>This is the stable version (order independent version) of the pcSelect function (pc-Simple algorithm) in the pcalg package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcSelect_stable(y, dm, alpha, corMethod = "standard", method = "stable",
  verbose = FALSE, directed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcSelect_stable_+3A_y">y</code></td>
<td>
<p>The target (response) variable.</p>
</td></tr>
<tr><td><code id="pcSelect_stable_+3A_dm">dm</code></td>
<td>
<p>Data matrix with rows are samples and columns are variables.</p>
</td></tr>
<tr><td><code id="pcSelect_stable_+3A_alpha">alpha</code></td>
<td>
<p>Significance level of individual partial correlation tests.</p>
</td></tr>
<tr><td><code id="pcSelect_stable_+3A_cormethod">corMethod</code></td>
<td>
<p>&quot;standard&quot; or &quot;Qn&quot; for standard or robust correlation estimation</p>
</td></tr>
<tr><td><code id="pcSelect_stable_+3A_method">method</code></td>
<td>
<p>Character string specifying method; the default, &quot;stable&quot; provides an Order-independent version.</p>
</td></tr>
<tr><td><code id="pcSelect_stable_+3A_verbose">verbose</code></td>
<td>
<p>Logical or in {0,1,2};
</p>
<p>FALSE, 0: No output,
</p>
<p>TRUE, 1: Little output,
</p>
<p>2: Detailed output.
</p>
<p>Note that such output makes the function very much slower.</p>
</td></tr>
<tr><td><code id="pcSelect_stable_+3A_directed">directed</code></td>
<td>
<p>Logical; should the output graph be directed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>G    A logical vector indicating which column of dm is associated with y.
</p>
<p>zMin   The minimal z-values when testing partial correlations between y and each column of dm. The larger the number, the more consistent is the edge with the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
## Using pcSelect_stable
##########################################
library(pcalg)
library(parallel)
p &lt;- 10
set.seed(101)
myDAG &lt;- randomDAG(p, prob = 0.2)
n &lt;- 1000
d.mat &lt;- rmvDAG(n, myDAG, errDist = "normal")
pcSelect_stable(d.mat[,10],d.mat[,-10], alpha=0.05)
</code></pre>

<hr>
<h2 id='rfci_parallel'>Estimate a PAG fast using the RFCI_parallel Algorithm</h2><span id='topic+rfci_parallel'></span>

<h3>Description</h3>

<p>This is the parallelised version of the RFCI algorithm in the pcalg package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfci_parallel(suffStat, indepTest, alpha, labels, p,
  skel.method = c("parallel"), mem.efficient = FALSE, fixedGaps = NULL,
  fixedEdges = NULL, NAdelete = TRUE, m.max = Inf, rules = rep(TRUE,
  10), conservative = FALSE, maj.rule = FALSE, verbose = FALSE,
  num.cores = detectCores())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rfci_parallel_+3A_suffstat">suffStat</code></td>
<td>
<p>Sufficient statistics: List containing all necessary elements for the conditional independence decisions in the function indepTest.</p>
</td></tr>
<tr><td><code id="rfci_parallel_+3A_indeptest">indepTest</code></td>
<td>
<p>Predefined function for testing conditional independence. The function is internally called as indepTest(x,y,S,suffStat), and tests conditional independence of x and y given S. Here, x and y are variables, and S is a (possibly empty) vector of variables (all variables are denoted by their column numbers in the adjacency matrix). suffStat is a list containing all relevant elements for the conditional independence decisions. The return value of indepTest is the p-value of the test for conditional independence.</p>
</td></tr>
<tr><td><code id="rfci_parallel_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for the individual conditional independence tests.</p>
</td></tr>
<tr><td><code id="rfci_parallel_+3A_labels">labels</code></td>
<td>
<p>(optional) character vector of variable (or &quot;node&quot;) names. Typically preferred to specifying p.</p>
</td></tr>
<tr><td><code id="rfci_parallel_+3A_p">p</code></td>
<td>
<p>(optional) number of variables (or nodes). May be specified if labels are not, in which case labels is set to 1:p.</p>
</td></tr>
<tr><td><code id="rfci_parallel_+3A_skel.method">skel.method</code></td>
<td>
<p>Character string specifying method; the default, &quot;parallel&quot; provides an efficient skeleton, see skeleton_parallel.</p>
</td></tr>
<tr><td><code id="rfci_parallel_+3A_mem.efficient">mem.efficient</code></td>
<td>
<p>Uses less amount of memory at any time point while running the algorithm</p>
</td></tr>
<tr><td><code id="rfci_parallel_+3A_fixedgaps">fixedGaps</code></td>
<td>
<p>A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is removed before starting the algorithm. Therefore, this edge is guaranteed to be absent in the resulting graph.</p>
</td></tr>
<tr><td><code id="rfci_parallel_+3A_fixededges">fixedEdges</code></td>
<td>
<p>A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is never considered for removal. Therefore, this edge is guaranteed to be present in the resulting graph.</p>
</td></tr>
<tr><td><code id="rfci_parallel_+3A_nadelete">NAdelete</code></td>
<td>
<p>If indepTest returns NA and this option is TRUE, the corresponding edge is deleted. If this option is FALSE, the edge is not deleted.</p>
</td></tr>
<tr><td><code id="rfci_parallel_+3A_m.max">m.max</code></td>
<td>
<p>Maximum size of the conditioning sets that are considered in the conditional independence tests.</p>
</td></tr>
<tr><td><code id="rfci_parallel_+3A_rules">rules</code></td>
<td>
<p>Logical vector of length 10 indicating which rules should be used when directing edges. See the pcalg package for details.</p>
</td></tr>
<tr><td><code id="rfci_parallel_+3A_conservative">conservative</code></td>
<td>
<p>Logical indicating if the unshielded triples should be checked for ambiguity the second time when v-structures are determined. For more information, see pcalg.</p>
</td></tr>
<tr><td><code id="rfci_parallel_+3A_maj.rule">maj.rule</code></td>
<td>
<p>Logical indicating if the unshielded triples should be checked for ambiguity the second time when v-structures are determined using a majority rule idea, which is less strict than the standard conservative. For more information, see pcalg.</p>
</td></tr>
<tr><td><code id="rfci_parallel_+3A_verbose">verbose</code></td>
<td>
<p>If true, more detailed output is provided.</p>
</td></tr>
<tr><td><code id="rfci_parallel_+3A_num.cores">num.cores</code></td>
<td>
<p>The numbers of cores CPU to run the algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class fciAlgo (see fciAlgo in the pcalg package) containing the estimated graph (in the form of an adjacency matrix with various possible edge marks), the conditioning sets that lead to edge removals (sepset) and several other parameters.
</p>


<h3>References</h3>

<p>1. Diego Colombo, Marloes H Maathuis, Markus Kalisch, Thomas S Richardson, et al. Learning high-dimensional directed acyclic graphs with latent and selection variables. The Annals of Statistics, 40(1):294-321, 2012.
</p>
<p>2. Markus Kalisch, Martin Machler, Diego Colombo, Marloes H Maathuis, and Peter Buhlmann. Causal inference using graphical models with the r package pcalg.
Journal of Statistical Software, 47(11):1-26, 2012.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
## Using rfci_parallel without mem.efficeient
##########################################
library(pcalg)
library(parallel)
data("gmG")
p&lt;-ncol(gmG$x)
suffStat&lt;-list(C=cor(gmG$x),n=nrow(gmG$x))
rfci_parallel(suffStat, indepTest=gaussCItest, p=p, skel.method="parallel", alpha=0.01, num.cores=2)

##########################################
## Using rfci_parallel with mem.efficeient
##########################################
library(pcalg)
library(parallel)
data("gmG")
p&lt;-ncol(gmG$x)
suffStat&lt;-list(C=cor(gmG$x),n=nrow(gmG$x))
rfci_parallel(suffStat, indepTest=gaussCItest, p=p, skel.method="parallel",
alpha=0.01, num.cores=2, mem.efficient=TRUE)

#################################################
## Using fci_parallel with mutual information test
#################################################
library(pcalg)
library(parallel)
data("gmG")
p&lt;-ncol(gmG$x)

# The first parameter is the dataset
rfci_parallel(gmG$x, indepTest=mig, p=p, skel.method="parallel",
alpha=0.01, num.cores=2, mem.efficient=TRUE)
</code></pre>

<hr>
<h2 id='rfci_stable'>Estimate a PAG using the RFCI_stable Algorithm</h2><span id='topic+rfci_stable'></span>

<h3>Description</h3>

<p>This is the RFCI stable version in the pcalg package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfci_stable(suffStat, indepTest, alpha, labels, p, skel.method = c("stable",
  "original", "stable.fast"), fixedGaps = NULL, fixedEdges = NULL,
  NAdelete = TRUE, m.max = Inf, rules = rep(TRUE, 10),
  conservative = FALSE, maj.rule = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rfci_stable_+3A_suffstat">suffStat</code></td>
<td>
<p>Sufficient statistics: List containing all necessary elements for the conditional independence decisions in the function indepTest.</p>
</td></tr>
<tr><td><code id="rfci_stable_+3A_indeptest">indepTest</code></td>
<td>
<p>Predefined function for testing conditional independence. The function is internally called as indepTest(x,y,S,suffStat), and tests conditional independence of x and y given S. Here, x and y are variables, and S is a (possibly empty) vector of variables (all variables are denoted by their column numbers in the adjacency matrix). suffStat is a list containing all relevant elements for the conditional independence decisions. The return value of indepTest is the p-value of the test for conditional independence.</p>
</td></tr>
<tr><td><code id="rfci_stable_+3A_alpha">alpha</code></td>
<td>
<p>significance level (number in (0,1) for the individual conditional independence tests.</p>
</td></tr>
<tr><td><code id="rfci_stable_+3A_labels">labels</code></td>
<td>
<p>(optional) character vector of variable (or &quot;node&quot;) names. Typically preferred to specifying p.</p>
</td></tr>
<tr><td><code id="rfci_stable_+3A_p">p</code></td>
<td>
<p>(optional) number of variables (or nodes). May be specified if labels are not, in which case labels is set to 1:p.</p>
</td></tr>
<tr><td><code id="rfci_stable_+3A_skel.method">skel.method</code></td>
<td>
<p>Character string specifying method; the default, &quot;stable&quot; provides an order-independent skeleton, see skeleton.</p>
</td></tr>
<tr><td><code id="rfci_stable_+3A_fixedgaps">fixedGaps</code></td>
<td>
<p>A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is removed before starting the algorithm. Therefore, this edge is guaranteed to be absent in the resulting graph.</p>
</td></tr>
<tr><td><code id="rfci_stable_+3A_fixededges">fixedEdges</code></td>
<td>
<p>A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is never considered for removal. Therefore, this edge is guaranteed to be present in the resulting graph.</p>
</td></tr>
<tr><td><code id="rfci_stable_+3A_nadelete">NAdelete</code></td>
<td>
<p>If indepTest returns NA and this option is TRUE, the corresponding edge is deleted. If this option is FALSE, the edge is not deleted.</p>
</td></tr>
<tr><td><code id="rfci_stable_+3A_m.max">m.max</code></td>
<td>
<p>Maximum size of the conditioning sets that are considered in the conditional independence tests.</p>
</td></tr>
<tr><td><code id="rfci_stable_+3A_rules">rules</code></td>
<td>
<p>Logical vector of length 10 indicating which rules should be used when directing edges. See the pcalg package for details.</p>
</td></tr>
<tr><td><code id="rfci_stable_+3A_conservative">conservative</code></td>
<td>
<p>Logical indicating if the unshielded triples should be checked for ambiguity after the skeleton has been found, similar to the conservative PC algorithm.</p>
</td></tr>
<tr><td><code id="rfci_stable_+3A_maj.rule">maj.rule</code></td>
<td>
<p>Logical indicating if the unshielded triples should be checked for ambiguity after the skeleton has been found using a majority rule idea, which is less strict than the conservative.</p>
</td></tr>
<tr><td><code id="rfci_stable_+3A_verbose">verbose</code></td>
<td>
<p>If true, more detailed output is provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class fciAlgo (see fciAlgo in the pcalg package) containing the estimated graph (in the form of an adjacency matrix with various possible edge marks), the conditioning sets that lead to edge removals (sepset) and several other parameters.
</p>


<h3>References</h3>

<p>1. Diego Colombo, Marloes H Maathuis, Markus Kalisch, Thomas S Richardson, et al. Learning high-dimensional directed acyclic graphs with latent and selection variables. The Annals of Statistics, 40(1):294-321, 2012.
</p>
<p>2. Markus Kalisch, Martin Machler, Diego Colombo, Marloes H Maathuis, and Peter Buhlmann. Causal inference using graphical models with the r package pcalg.
Journal of Statistical Software, 47(11):1-26, 2012.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
## Using rfci_stable
##########################################
library(pcalg)
library(parallel)
data("gmG")
p&lt;-ncol(gmG$x)
suffStat&lt;-list(C=cor(gmG$x),n=nrow(gmG$x))
rfci_stable(suffStat, indepTest=gaussCItest, p=p, skel.method="stable", alpha=0.01)
</code></pre>

<hr>
<h2 id='skeleton_parallel'>Estimate (Initial) Skeleton of a DAG.</h2><span id='topic+skeleton_parallel'></span>

<h3>Description</h3>

<p>This is the parallelised version of the skeleton function in the pcalg package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skeleton_parallel(suffStat, indepTest, alpha, labels, p,
  method = c("parallel"), mem.efficient = FALSE, workers, num_workers,
  m.max = Inf, fixedGaps = NULL, fixedEdges = NULL, NAdelete = TRUE,
  verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="skeleton_parallel_+3A_suffstat">suffStat</code></td>
<td>
<p>Sufficient statistics: List containing all necessary elements for the conditional independence decisions in the function indepTest.</p>
</td></tr>
<tr><td><code id="skeleton_parallel_+3A_indeptest">indepTest</code></td>
<td>
<p>Predefined function for testing conditional independence. The function is internally called as indepTest(x,y,S,suffStat) and tests conditional independence of x and y given S. Here, x and y are variables, and S is a (possibly empty) vector of variables (all variables are denoted by their column numbers in the adjacency matrix). suffStat is a list containing all relevant elements for the conditional independence decisions. The return value of indepTest is the p-value of the test for conditional independence.</p>
</td></tr>
<tr><td><code id="skeleton_parallel_+3A_alpha">alpha</code></td>
<td>
<p>significance level (number in (0; 1) for the individual conditional independence tests.</p>
</td></tr>
<tr><td><code id="skeleton_parallel_+3A_labels">labels</code></td>
<td>
<p>(optional) character vector of variable (or &quot;node&quot;) names. Typically preferred to specifying p.</p>
</td></tr>
<tr><td><code id="skeleton_parallel_+3A_p">p</code></td>
<td>
<p>(optional) number of variables (or nodes). May be specified if labels are not, in which case labels is set to 1:p.</p>
</td></tr>
<tr><td><code id="skeleton_parallel_+3A_method">method</code></td>
<td>
<p>Character string specifying method; the default, &quot;parallel&quot; provides an efficient skeleton, see skeleton_parallel.</p>
</td></tr>
<tr><td><code id="skeleton_parallel_+3A_mem.efficient">mem.efficient</code></td>
<td>
<p>Uses less amount of memory at any time point while running the algorithm</p>
</td></tr>
<tr><td><code id="skeleton_parallel_+3A_workers">workers</code></td>
<td>
<p>Creates a set of copies of R running in parallel and communicating over sockets.</p>
</td></tr>
<tr><td><code id="skeleton_parallel_+3A_num_workers">num_workers</code></td>
<td>
<p>The numbers of cores CPU as numbers of workers to run the algorithm</p>
</td></tr>
<tr><td><code id="skeleton_parallel_+3A_m.max">m.max</code></td>
<td>
<p>Maximal size of the conditioning sets that are considered in the conditional independence tests.</p>
</td></tr>
<tr><td><code id="skeleton_parallel_+3A_fixedgaps">fixedGaps</code></td>
<td>
<p>A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is removed before starting the algorithm. Therefore, this edge is guaranteed to be absent in the resulting graph.</p>
</td></tr>
<tr><td><code id="skeleton_parallel_+3A_fixededges">fixedEdges</code></td>
<td>
<p>A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is never considered for removal. Therefore, this edge is guaranteed to be present in the resulting graph.</p>
</td></tr>
<tr><td><code id="skeleton_parallel_+3A_nadelete">NAdelete</code></td>
<td>
<p>logical needed for the case indepTest(*) returns NA. If it is true, the corresponding edge is deleted, otherwise not.</p>
</td></tr>
<tr><td><code id="skeleton_parallel_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, detailed output is provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;pcAlgo&quot; (see pcAlgo in the pcalg package) containing an estimate of the skeleton of the underlying DAG, the conditioning sets (sepset) that led to edge removals and several other parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
## Using skeleton_parallel without mem.efficeient
##########################################
library(pcalg)
library(parallel)
data("gmG")
p&lt;-ncol(gmG$x)
suffStat&lt;-list(C=cor(gmG$x),n=nrow(gmG$x))
skeleton_parallel(suffStat,indepTest=gaussCItest,p=p,method="parallel",alpha=0.01,num_workers=2)

##########################################
## Using skeleton_parallel with mem.efficeient
##########################################
library(pcalg)
library(parallel)
data("gmG")
p&lt;-ncol(gmG$x)
suffStat&lt;-list(C=cor(gmG$x),n=nrow(gmG$x))
skeleton_parallel(suffStat,indepTest=gaussCItest,p=p,method="parallel",
alpha=0.01,num_workers=2,mem.efficient=TRUE)
</code></pre>

<hr>
<h2 id='skeleton_stable'>Estimate (Initial) Skeleton of a DAG using the PC_stable Algorithm</h2><span id='topic+skeleton_stable'></span>

<h3>Description</h3>

<p>This is the skeleton (stable) function in the pcalg package. It is copied here to localise the parallel functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skeleton_stable(suffStat, indepTest, alpha, labels, p, method = c("stable",
  "original", "stable.fast"), m.max = Inf, fixedGaps = NULL,
  fixedEdges = NULL, NAdelete = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="skeleton_stable_+3A_suffstat">suffStat</code></td>
<td>
<p>Sufficient statistics: List containing all necessary elements for the conditional independence decisions in the function indepTest.</p>
</td></tr>
<tr><td><code id="skeleton_stable_+3A_indeptest">indepTest</code></td>
<td>
<p>Predefined function for testing conditional independence. The function is internally called as indepTest(x,y,S,suffStat) and tests conditional independence of x and y given S. Here, x and y are variables, and S is a (possibly empty) vector of variables (all variables are denoted by their column numbers in the adjacency matrix). suffStat is a list containing all relevant elements for the conditional independence decisions. The return value of indepTest is the p-value of the test for conditional independence.</p>
</td></tr>
<tr><td><code id="skeleton_stable_+3A_alpha">alpha</code></td>
<td>
<p>significance level (number in (0,1) for the individual conditional independence tests.</p>
</td></tr>
<tr><td><code id="skeleton_stable_+3A_labels">labels</code></td>
<td>
<p>(optional) character vector of variable (or &quot;node&quot;) names. Typically preferred to specifying p.</p>
</td></tr>
<tr><td><code id="skeleton_stable_+3A_p">p</code></td>
<td>
<p>(optional) number of variables (or nodes). May be specified if labels are not, in which case labels is set to 1:p.</p>
</td></tr>
<tr><td><code id="skeleton_stable_+3A_method">method</code></td>
<td>
<p>Character string specifying method; the default, &quot;stable&quot; provides an order-independent skeleton, see 'Details' below.</p>
</td></tr>
<tr><td><code id="skeleton_stable_+3A_m.max">m.max</code></td>
<td>
<p>Maximal size of the conditioning sets that are considered in the conditional independence tests.</p>
</td></tr>
<tr><td><code id="skeleton_stable_+3A_fixedgaps">fixedGaps</code></td>
<td>
<p>logical symmetric matrix of dimension p*p. If entry [i,j] is true, the edge i-j is removed before starting the algorithm. Therefore, this edge is guaranteed to be absent in the resulting graph.</p>
</td></tr>
<tr><td><code id="skeleton_stable_+3A_fixededges">fixedEdges</code></td>
<td>
<p>a logical symmetric matrix of dimension p*p. If entry [i,j] is true, the edge i-j is never considered for removal. Therefore, this edge is guaranteed to be present in the resulting graph.</p>
</td></tr>
<tr><td><code id="skeleton_stable_+3A_nadelete">NAdelete</code></td>
<td>
<p>logical needed for the case indepTest(*) returns NA. If it is true, the corresponding edge is deleted, otherwise not.</p>
</td></tr>
<tr><td><code id="skeleton_stable_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, detailed output is provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;pcAlgo&quot; (see pcAlgo in the pcalg package) containing an estimate of the skeleton of the underlying DAG, the conditioning sets (sepset) that led to edge removals and several other parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
## Using skeleton_stable
##########################################
library(pcalg)
library(parallel)
data("gmG")
p&lt;-ncol(gmG$x)
suffStat&lt;-list(C=cor(gmG$x),n=nrow(gmG$x))
skeleton_stable(suffStat, indepTest=gaussCItest, p=p, method="stable", alpha=0.01)
</code></pre>

<hr>
<h2 id='smccor'>The sequential Monte Carlo permutation test (smc-cor)</h2><span id='topic+smccor'></span>

<h3>Description</h3>

<p>The sequential Monte Carlo permutation test. See bnlearn package for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smccor(x, y, S, suffStat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smccor_+3A_x">x</code>, <code id="smccor_+3A_y">y</code>, <code id="smccor_+3A_s">S</code></td>
<td>
<p>It is tested, whether x and y are conditionally independent given the subset S of
the remaining nodes. x, y, S all are integers, corresponding to variable or node
numbers.</p>
</td></tr>
<tr><td><code id="smccor_+3A_suffstat">suffStat</code></td>
<td>
<p>The dataset in matrix format with rows are samples and columns are variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The p-value of the test.
</p>


<h3>References</h3>

<p>Marco Scutari (2010). Learning Bayesian Networks with the bnlearn R Package. Journal of Statistical Software, 35(3), 1-22.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
## Using smccor
##########################################
library(bnlearn)
library(pcalg)
data("gmG")
suffStat&lt;-gmG$x
smccor(1,2,3,suffStat)
</code></pre>

<hr>
<h2 id='smcmig'>The sequential Monte Carlo permutation test (smc-mi-g)</h2><span id='topic+smcmig'></span>

<h3>Description</h3>

<p>The sequential Monte Carlo permutation test. See bnlearn package for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smcmig(x, y, S, suffStat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smcmig_+3A_x">x</code>, <code id="smcmig_+3A_y">y</code>, <code id="smcmig_+3A_s">S</code></td>
<td>
<p>It is tested, whether x and y are conditionally independent given the subset S of
the remaining nodes. x, y, S all are integers, corresponding to variable or node
numbers.</p>
</td></tr>
<tr><td><code id="smcmig_+3A_suffstat">suffStat</code></td>
<td>
<p>The data matrix with rows are samples and columns are variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The p-value of the test.
</p>


<h3>References</h3>

<p>Marco Scutari (2010). Learning Bayesian Networks with the bnlearn R Package. Journal of Statistical Software, 35(3), 1-22.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
## Using smcmig
##########################################
library(bnlearn)
library(pcalg)
data("gmG")
suffStat&lt;-gmG$x
smcmig(1,2,3,suffStat)
</code></pre>

<hr>
<h2 id='smczf'>The sequential Monte Carlo permutation test for Gaussian conditional independence test.</h2><span id='topic+smczf'></span>

<h3>Description</h3>

<p>The sequential Monte Carlo permutation test for Gaussian conditional independence test. See the smc-zf function in the bnlearn package for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smczf(x, y, S, suffStat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smczf_+3A_x">x</code>, <code id="smczf_+3A_y">y</code>, <code id="smczf_+3A_s">S</code></td>
<td>
<p>It is tested, whether x and y are conditionally independent given the subset S of
the remaining nodes. x, y, S all are integers, corresponding to variable or node
numbers.</p>
</td></tr>
<tr><td><code id="smczf_+3A_suffstat">suffStat</code></td>
<td>
<p>The data matrix with rows are samples and columns are variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The p-value of the test.
</p>


<h3>References</h3>

<p>Marco Scutari (2010). Learning Bayesian Networks with the bnlearn R Package. Journal of Statistical Software, 35(3), 1-22.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
## Using smczf
##########################################
library(bnlearn)
library(pcalg)
data("gmG")
suffStat&lt;-gmG$x
smczf(1,2,3,suffStat)
</code></pre>

<hr>
<h2 id='zf'>Gaussian conditional independence test</h2><span id='topic+zf'></span>

<h3>Description</h3>

<p>Gaussian conditional independence test. See the zf function in the bnlearn package for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zf(x, y, S, suffStat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zf_+3A_x">x</code>, <code id="zf_+3A_y">y</code>, <code id="zf_+3A_s">S</code></td>
<td>
<p>It is tested, whether x and y are conditionally independent given the subset S of
the remaining nodes. x, y, S all are integers, corresponding to variable or node
numbers.</p>
</td></tr>
<tr><td><code id="zf_+3A_suffstat">suffStat</code></td>
<td>
<p>the data matrix with rows are samples and columns are the variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The p-value of the test.
</p>


<h3>References</h3>

<p>Marco Scutari (2010). Learning Bayesian Networks with the bnlearn R Package. Journal of Statistical Software, 35(3), 1-22.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################
## Using zf
##########################################
library(bnlearn)
library(pcalg)
data("gmG")
suffStat&lt;-gmG$x
zf(1,2,3,suffStat)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
