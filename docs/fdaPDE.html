<!DOCTYPE html><html lang="en"><head><title>Help for package fdaPDE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fdaPDE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#covs.test'><p>Covariate test function for the horseshoe domain</p></a></li>
<li><a href='#create.FEM.basis'><p>Create a FEM basis</p></a></li>
<li><a href='#create.mesh.1.5D'><p>Create a 1.5D linear network mesh</p></a></li>
<li><a href='#create.mesh.2.5D'><p>Create a <code>mesh.2.5D</code> object from the nodes locations and the connectivity matrix</p></a></li>
<li><a href='#create.mesh.2D'><p>Create a 2D triangular mesh</p></a></li>
<li><a href='#create.mesh.3D'><p>Create a <code>mesh.3D</code> object from the connectivity matrix and nodes locations</p></a></li>
<li><a href='#DE.FEM'><p>Nonparametric density estimation with differential regularization</p></a></li>
<li><a href='#DE.FEM.time'><p>Nonparametric spatio-temporal density estimation with differential regularization</p></a></li>
<li><a href='#DE.heat.FEM'><p>Density initialization</p></a></li>
<li><a href='#DE.heat.FEM.time'><p>Spatio-temporal density initialization</p></a></li>
<li><a href='#eval.FEM'><p>Evaluate a FEM object at a set of point locations</p></a></li>
<li><a href='#eval.FEM.time'><p>Evaluate a FEM.time object at a set of point locations</p></a></li>
<li><a href='#fdaPDE-deprecated'><p>Deprecated Functions</p></a></li>
<li><a href='#FEM'><p>Define a surface or spatial field by a Finite Element basis expansion</p></a></li>
<li><a href='#FEM.time'><p>Define a spatio-temporal field by a Finite Element basis expansion</p></a></li>
<li><a href='#FPCA.FEM'><p>Smooth Functional Principal Component Analysis</p></a></li>
<li><a href='#fs.test'><p>FELSPLINE test function</p></a></li>
<li><a href='#fs.test.3D'><p>FELSPLINE 3D test function</p></a></li>
<li><a href='#horseshoe2.5D'><p>Horseshoe2.5D domain</p></a></li>
<li><a href='#horseshoe2D'><p>Horseshoe domain</p></a></li>
<li><a href='#hub2.5D'><p>Hub domain</p></a></li>
<li><a href='#image.FEM'><p>Image Plot of a 2D FEM object</p></a></li>
<li><a href='#image.FEM.time'><p>Image plot of a 2D FEM.time object at a given time</p></a></li>
<li><a href='#inferenceDataObject-class'><p>Class for inference data</p></a></li>
<li><a href='#inferenceDataObjectBuilder'><p>Constructor for inferenceDataObject class</p></a></li>
<li><a href='#inferenceDataObjectTime-class'><p>Class for inference data in ST case</p></a></li>
<li><a href='#inferenceDataObjectTimeBuilder'><p>Constructor for inferenceDataObjectTime class</p></a></li>
<li><a href='#plot.FEM'><p>Plot a <code>FEM</code> object</p></a></li>
<li><a href='#plot.FEM.time'><p>Plot a <code>FEM.time</code> object at a given time</p></a></li>
<li><a href='#plot.mesh.1.5D'><p>Plot a mesh.1.5D object</p></a></li>
<li><a href='#plot.mesh.2.5D'><p>Plot a mesh.2.5D object</p></a></li>
<li><a href='#plot.mesh.2D'><p>Plot a mesh.2D object</p></a></li>
<li><a href='#plot.mesh.3D'><p>Plot a mesh.3D object</p></a></li>
<li><a href='#projection.points.1.5D'><p>Project 2D points onto 1.5D linear network mesh</p></a></li>
<li><a href='#projection.points.2.5D'><p>Project 3D points onto 2D 2.5D triangular mesh</p></a></li>
<li><a href='#quasicircle2D'><p>Quasicircle2D domain</p></a></li>
<li><a href='#quasicircle2Dareal'><p>Quasicircle2Dareal domain</p></a></li>
<li><a href='#refine.by.splitting.mesh.1.5D'><p>Create a <code>mesh.1.5D</code> object by splitting each edge of a given mesh into two subedges.</p></a></li>
<li><a href='#refine.by.splitting.mesh.2.5D'><p>Create a <code>mesh.2.5D</code> object by splitting each triangle of a given mesh into four subtriangles.</p></a></li>
<li><a href='#refine.by.splitting.mesh.2D'><p>Create a <code>mesh.2D</code> object by splitting each triangle of a given mesh into four subtriangles.</p></a></li>
<li><a href='#refine.by.splitting.mesh.3D'><p>Create a <code>mesh.3D</code> object by splitting each tetrahedron of a given mesh into eight subtetrahedrons.</p></a></li>
<li><a href='#refine.mesh.1.5D'><p>Refine 1.5D mesh</p></a></li>
<li><a href='#refine.mesh.2D'><p>Refine a 2D triangular mesh</p></a></li>
<li><a href='#smooth.FEM'><p>Spatial regression with differential regularization</p></a></li>
<li><a href='#smooth.FEM.time'><p>Space-time regression with differential regularization</p></a></li>
<li><a href='#sphere3Ddata'><p>Sphere3Ddata</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.1-21</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-01</td>
</tr>
<tr>
<td>Title:</td>
<td>Physics-Informed Spatial and Functional Data Analysis</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eleonora Arnone &lt;eleonora.arnone@polimi.it&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), stats, grDevices, graphics, rgl, Matrix, plot3D,
methods</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppEigen, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of regression models with partial differential regularizations, making use of the Finite Element Method. The models efficiently handle data distributed over irregularly shaped domains and can comply with various conditions at the boundaries of the domain. A priori information about the spatial structure of the phenomenon under study can be incorporated in the model via the differential regularization. See Sangalli, L. M. (2021) &lt;<a href="https://doi.org/10.1111%2Finsr.12444">doi:10.1111/insr.12444</a>&gt; "Spatial Regression With Partial Differential Equation Regularisation" for an overview. The release 1.1-9 requires R (&gt;= 4.2.0) to be installed on windows machines.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-03 13:58:20 UTC; aldoclemente</td>
</tr>
<tr>
<td>Author:</td>
<td>Eleonora Arnone [aut, cre],
  Aldo Clemente [aut],
  Laura M. Sangalli [aut],
  Eardi Lila [aut],
  Jim Ramsay [aut],
  Luca Formaggia [aut],
  Giovanni Ardenghi [ctb],
  Blerta Begu [ctb],
  Michele Cavazzutti [ctb],
  Alessandra Colli [ctb],
  Alberto Colombo [ctb],
  Luca Colombo [ctb],
  Carlo de Falco [ctb],
  Enrico Dall'Acqua [ctb],
  Giulia Ferla [ctb],
  Lorenzo Ghilotti [ctb],
  Cristina Galimberti [ctb],
  Jiyoung Kim [ctb],
  Martina Massardi [ctb],
  Giorgio Meretti [ctb],
  Simone Panzeri [ctb],
  Giulio Perin [ctb],
  Clara Pigolotti [ctb],
  Andrea Poiatti [ctb],
  Gian Matteo Rinaldi [ctb],
  Stefano Spaziani [ctb],
  Andrea Vicini [ctb],
  David C. Sterratt [cph] (Author of included Triangle source files)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-08 18:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='covs.test'>Covariate test function for the horseshoe domain</h2><span id='topic+covs.test'></span>

<h3>Description</h3>

<p>Implements a finite area test function the horseshoe domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covs.test(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covs.test_+3A_x">x</code>, <code id="covs.test_+3A_y">y</code></td>
<td>
<p>Points at which to evaluate the test function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns function evaluations.
</p>

<hr>
<h2 id='create.FEM.basis'>Create a FEM basis</h2><span id='topic+create.FEM.basis'></span>

<h3>Description</h3>

<p>Sets up a Finite Element basis. It requires a <code>mesh.2D</code>, <code>mesh.2.5D</code> or <code>mesh.3D</code> object,
as input.
The basis' functions are globally continuos functions, that are polynomials once restricted to a triangle in the mesh.
The current implementation includes linear finite elements (when <code>order = 1</code> in the input <code>mesh</code>) and
quadratic finite elements (when <code>order = 2</code> in the input <code>mesh</code>).
If saveTree flag is TRUE, it saves the tree mesh information in advance inside mesh object and can be used later on to save mesh construction time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.FEM.basis(mesh, saveTree = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.FEM.basis_+3A_mesh">mesh</code></td>
<td>
<p>A <code>mesh.2D</code>, <code>mesh.2.5D</code> or <code>mesh.3D</code> object representing the domain triangulation. See <a href="#topic+create.mesh.2D">create.mesh.2D</a>, <a href="#topic+create.mesh.2.5D">create.mesh.2.5D</a>, <a href="#topic+create.mesh.3D">create.mesh.3D</a>.</p>
</td></tr>
<tr><td><code id="create.FEM.basis_+3A_savetree">saveTree</code></td>
<td>
<p>a flag to decide to save the tree mesh information in advance (default is FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>FEMbasis</code> object. This contains the <code>mesh</code>, along with some additional quantities:
</p>

<dl>
<dt><code>order</code></dt><dd><p>Either &quot;1&quot; or &quot;2&quot; for the 2D and 2.5D case, and &quot;1&quot; for the 3D case.
Order of the Finite Element basis.</p>
</dd>
<dt><code>nbasis</code></dt><dd><p>Scalar. The number of basis.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+create.mesh.2D">create.mesh.2D</a></code>, <code><a href="#topic+create.mesh.2.5D">create.mesh.2.5D</a></code>,<code><a href="#topic+create.mesh.3D">create.mesh.3D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)
## Upload the quasicircle2D data
data(quasicircle2D)

## Create the 2D mesh
mesh = create.mesh.2D(nodes = rbind(quasicircle2D$boundary_nodes, 
quasicircle2D$locations), segments = quasicircle2D$boundary_segments)
## Plot it
plot(mesh)
## Create the basis
FEMbasis = create.FEM.basis(mesh)
## Upload the hub2.5D data
data(hub2.5D)

hub2.5D.nodes = hub2.5D$hub2.5D.nodes
hub2.5D.triangles = hub2.5D$hub2.5D.triangles
## Create the 2.5D mesh
mesh = create.mesh.2.5D(nodes = hub2.5D.nodes, triangles = hub2.5D.triangles)
## Plot it
plot(mesh)
## Create the basis
FEMbasis = create.FEM.basis(mesh)
</code></pre>

<hr>
<h2 id='create.mesh.1.5D'>Create a 1.5D linear network mesh</h2><span id='topic+create.mesh.1.5D'></span>

<h3>Description</h3>

<p>Create a 1.5D linear network mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.mesh.1.5D(nodes, edges = NULL, order = 1, nodesattributes = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.mesh.1.5D_+3A_nodes">nodes</code></td>
<td>
<p>A #nodes-by-2 matrix containing the x and y coordinates of the mesh nodes.</p>
</td></tr>
<tr><td><code id="create.mesh.1.5D_+3A_edges">edges</code></td>
<td>
<p>A #edges-by-2 (when <code>order</code> = 1) or #triangles-by-3 (when <code>order</code> = 2) matrix.
This option is used when a triangulation is already available. It specifies the edges giving the row's indices in <code>nodes</code> of the edges' vertices and (when <code>nodes</code> = 2) also if the triangles' edges midpoints. The triangles' vertices and midpoints are ordered as
1&mdash;3&mdash;2
In this case the function <code>create.mesh.1.5D</code> is used to produce a complete mesh.1.5D object.</p>
</td></tr>
<tr><td><code id="create.mesh.1.5D_+3A_order">order</code></td>
<td>
<p>Either '1' or '2'. It specifies wether each mesh should be represented by 2 nodes (the edges vertices) or by 3 nodes (the edges's vertices and midpoint).
These are
respectively used for linear (order = 1) and quadratic (order = 2) Finite Elements. Default is <code>order</code> = 1.</p>
</td></tr>
<tr><td><code id="create.mesh.1.5D_+3A_nodesattributes">nodesattributes</code></td>
<td>
<p>A matrix with #nodes rows containing nodes' attributes.
These are passed unchanged to the output. If a node is added during the triangulation process or mesh refinement, its attributes are computed
by linear interpolation using the attributes of neighboring nodes. This functionality is for instance used to compute the value
of a Dirichlet boundary condition at boundary nodes added during the triangulation process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class mesh.1.5D with the following output:
</p>

<dl>
<dt><code>nodes</code></dt><dd><p>A #nodes-by-2 matrix containing the x and y coordinates of the mesh nodes.</p>
</dd>
<dt><code>nodesmarkers</code></dt><dd><p>A vector of length #nodes, with entries either '1' or '0'. An entry '1' indicates that the corresponding node is a boundary node; an entry '0' indicates that the corresponding node is not a boundary node.</p>
</dd>
<dt><code>nodesattributes</code></dt><dd><p>A matrix with #nodes rows containing nodes' attributes.
These are passed unchanged from the input.</p>
</dd>
<dt><code>edges</code></dt><dd><p>A #edges-by-2 matrix containing all the edges of the triangles in the output triangulation. Each row contains the row's indices in <code>nodes</code>, indicating the nodes where the edge starts from and ends to.</p>
</dd>
<dt><code>neighbors</code></dt><dd><p>A #edges-by-2 matrix of list. Each row contains the indices of the neighbouring edges. An empty entry indicates that one node of the edge is a boundary node.</p>
</dd>
<dt><code>order</code></dt><dd><p>Either '1' or '2'. It specifies wether each mesh triangle should be represented by 3 nodes (the triangle' vertices) or by 6 nodes (the triangle's vertices and midpoints).
These are respectively used for linear (order = 1) and quadratic (order = 2) Finite Elements.</p>
</dd>
</dl>


<hr>
<h2 id='create.mesh.2.5D'>Create a <code>mesh.2.5D</code> object from the nodes locations and the connectivity matrix</h2><span id='topic+create.mesh.2.5D'></span>

<h3>Description</h3>

<p>Create a <code>mesh.2.5D</code> object from the nodes locations and the connectivity matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.mesh.2.5D(
  nodes,
  triangles = NULL,
  order = 1,
  nodesattributes = NULL,
  segments = NULL,
  holes = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.mesh.2.5D_+3A_nodes">nodes</code></td>
<td>
<p>A #nodes-by-3 matrix containing the x, y, z coordinates of the mesh nodes.</p>
</td></tr>
<tr><td><code id="create.mesh.2.5D_+3A_triangles">triangles</code></td>
<td>
<p>A #triangles-by-3 (when <code>order</code> = 1) or #triangles-by-6 (when <code>order</code> = 2) matrix.
It specifies the triangles giving the row's indices in <code>nodes</code> of the triangles' vertices and (when <code>nodes</code> = 2) also if the triangles' edges midpoints. The triangles' vertices and midpoints are ordered as described
at <br /> https://www.cs.cmu.edu/~quake/triangle.highorder.html.</p>
</td></tr>
<tr><td><code id="create.mesh.2.5D_+3A_order">order</code></td>
<td>
<p>Either '1' or '2'. It specifies wether each mesh triangle should be represented by 3 nodes (the triangle' vertices) or by 6 nodes (the triangle's vertices and midpoints).
These are
respectively used for linear (order = 1) and quadratic (order = 2) Finite Elements. Default is <code>order</code> = 1.</p>
</td></tr>
<tr><td><code id="create.mesh.2.5D_+3A_nodesattributes">nodesattributes</code></td>
<td>
<p>A matrix with #nodes rows containing nodes' attributes.
These are passed unchanged to the output. This has been added for consistency with the function <code>create.mesh.2D</code>.</p>
</td></tr>
<tr><td><code id="create.mesh.2.5D_+3A_segments">segments</code></td>
<td>
<p>A #segments-by-2 matrix. Each row contains the row's indices in <code>nodes</code> of the vertices where the segment starts from and ends to.
Segments are edges that are not splitted during the triangulation process. These are for instance used to define the boundaries
of the domain. This has been added for consistency with the function <code>create.mesh.2D</code>.</p>
</td></tr>
<tr><td><code id="create.mesh.2.5D_+3A_holes">holes</code></td>
<td>
<p>A #holes-by-3 matrix containing the x, y, z coordinates of a point internal to each hole of the mesh. These points are used to carve holes
in the triangulation, when the domain has holes. This has been added for consistency with the function <code>create.mesh.2D</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class mesh.2.5D with the following output:
</p>

<dl>
<dt><code>nodes</code></dt><dd><p>A #nodes-by-3 matrix containing the x, y, z coordinates of the mesh nodes.</p>
</dd>
<dt><code>nodesmarkers</code></dt><dd><p>A vector of length #nodes, with entries either '1' or '0'. An entry '1' indicates that the corresponding node is a boundary node; an entry '0' indicates that the corresponding node is not a boundary node.</p>
</dd>
<dt><code>nodesattributes</code></dt><dd><p>A matrix with #nodes rows containing nodes' attributes.
These are passed unchanged from the input.</p>
</dd>
<dt><code>triangles</code></dt><dd><p>A #triangles-by-3 (when <code>order</code> = 1) or #triangles-by-6 (when <code>order</code> = 2) matrix.
It specifies the triangles giving the indices in <code>nodes</code> of the triangles' vertices and (when <code>nodes</code> = 2) also if the triangles' edges midpoints. The triangles' vertices and midpoints are ordered as described
at  <br /> https://www.cs.cmu.edu/~quake/triangle.highorder.html.</p>
</dd>
<dt><code>segmentsmarkers</code></dt><dd><p>A vector of length #segments with entries either '1' or '0'. An entry '1' indicates that the corresponding element in <code>segments</code> is a boundary segment;
an entry '0' indicates that the corresponding segment is not a boundary segment.</p>
</dd>
<dt><code>edges</code></dt><dd><p>A #edges-by-2 matrix containing all the edges of the triangles in the output triangulation. Each row contains the row's indices in <code>nodes</code>, indicating the nodes where the edge starts from and ends to.</p>
</dd>
<dt><code>edgesmarkers</code></dt><dd><p>A vector of lenght #edges with entries either '1' or '0'. An entry '1' indicates that the corresponding element in <code>edge</code> is a boundary edge;
an entry '0' indicates that the corresponding edge is not a boundary edge.</p>
</dd>
<dt><code>neighbors</code></dt><dd><p>A #triangles-by-3 matrix. Each row contains the indices of the three neighbouring triangles. An entry '-1' indicates that
one edge of the triangle is a boundary edge.</p>
</dd>
<dt><code>holes</code></dt><dd><p>A #holes-by-3 matrix containing the x, y, z coordinates of a point internal to each hole of the mesh. These points are used to carve holes
in the triangulation, when the domain has holes. These are passed unchanged from the input.</p>
</dd>
<dt><code>order</code></dt><dd><p>Either '1' or '2'. It specifies wether each mesh triangle should be represented by 3 nodes (the triangle' vertices) or by 6 nodes (the triangle's vertices and midpoints).
These are respectively used for linear (order = 1) and quadratic (order = 2) Finite Elements.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)

## Upload the hub2.5D the data
data(hub2.5D)
hub2.5D.nodes = hub2.5D$hub2.5D.nodes
hub2.5D.triangles = hub2.5D$hub2.5D.triangles

## Create mesh from nodes and connectivity matrix:
mesh = create.mesh.2.5D(nodes = hub2.5D.nodes, triangles = hub2.5D.triangles)
plot(mesh)
</code></pre>

<hr>
<h2 id='create.mesh.2D'>Create a 2D triangular mesh</h2><span id='topic+create.mesh.2D'></span>

<h3>Description</h3>

<p>This function is a wrapper of the Triangle library (http://www.cs.cmu.edu/~quake/triangle.html). It can be used
to create a triangulation of the domain of interest starting from a list of points, to be used as triangles' vertices, and a list of segments, that define the domain boundary. The resulting
mesh is a Constrained Delaunay triangulation. This is constructed in a way to preserve segments provided in the input <code>segments</code> without splitting them. This imput can be used to define the boundaries
of the domain. If this imput is NULL, it generates a triangulation over the
convex hull of the points.
It is also possible to create a mesh.2D from the nodes locations and the connectivity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.mesh.2D(nodes, nodesattributes = NA, segments = NA, holes = NA,
                     triangles = NA, order = 1, verbosity = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.mesh.2D_+3A_nodes">nodes</code></td>
<td>
<p>A #nodes-by-2 matrix containing the x and y coordinates of the mesh nodes.</p>
</td></tr>
<tr><td><code id="create.mesh.2D_+3A_nodesattributes">nodesattributes</code></td>
<td>
<p>A matrix with #nodes rows containing nodes' attributes.
These are passed unchanged to the output. If a node is added during the triangulation process or mesh refinement, its attributes are computed
by linear interpolation using the attributes of neighboring nodes. This functionality is for instance used to compute the value
of a Dirichlet boundary condition at boundary nodes added during the triangulation process.</p>
</td></tr>
<tr><td><code id="create.mesh.2D_+3A_segments">segments</code></td>
<td>
<p>A #segments-by-2 matrix. Each row contains the row's indices in <code>nodes</code> of the vertices where the segment starts from and ends to.
Segments are edges that are not splitted during the triangulation process. These are for instance used to define the boundaries
of the domain. If this is input is NULL, it generates a triangulation over the
convex hull of the points specified in <code>nodes</code>.</p>
</td></tr>
<tr><td><code id="create.mesh.2D_+3A_holes">holes</code></td>
<td>
<p>A #holes-by-2 matrix containing the x and y coordinates of a point internal to each hole of the mesh. These points are used to carve holes
in the triangulation, when the domain has holes.</p>
</td></tr>
<tr><td><code id="create.mesh.2D_+3A_triangles">triangles</code></td>
<td>
<p>A #triangles-by-3 (when <code>order</code> = 1) or #triangles-by-6 (when <code>order</code> = 2) matrix.
This option is used when a triangulation is already available. It specifies the triangles giving the row's indices in <code>nodes</code> of the triangles' vertices and (when <code>nodes</code> = 2) also if the triangles' edges midpoints. The triangles' vertices and midpoints are ordered as described
at <br /> https://www.cs.cmu.edu/~quake/triangle.highorder.html.
In this case the function <code>create.mesh.2D</code> is used to produce a complete mesh.2D object.</p>
</td></tr>
<tr><td><code id="create.mesh.2D_+3A_order">order</code></td>
<td>
<p>Either '1' or '2'. It specifies wether each mesh triangle should be represented by 3 nodes (the triangle' vertices) or by 6 nodes (the triangle's vertices and midpoints).
These are
respectively used for linear (order = 1) and quadratic (order = 2) Finite Elements. Default is <code>order</code> = 1.</p>
</td></tr>
<tr><td><code id="create.mesh.2D_+3A_verbosity">verbosity</code></td>
<td>
<p>This can be '0', '1' or '2'. It indicates the level of verbosity in the triangulation process. When <code>verbosity</code> = 0 no message is returned
during the triangulation. When <code>verbosity</code> = 2 the triangulation process is described step by step by displayed messages.
Default is <code>verbosity</code> = 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class mesh.2D with the following output:
</p>

<dl>
<dt><code>nodes</code></dt><dd><p>A #nodes-by-2 matrix containing the x and y coordinates of the mesh nodes.</p>
</dd>
<dt><code>nodesmarkers</code></dt><dd><p>A vector of length #nodes, with entries either '1' or '0'. An entry '1' indicates that the corresponding node is a boundary node; an entry '0' indicates that the corresponding node is not a boundary node.</p>
</dd>
<dt><code>nodesattributes</code></dt><dd><p>A matrix with #nodes rows containing nodes' attributes.
These are passed unchanged from the input.</p>
</dd>
<dt><code>triangles</code></dt><dd><p>A #triangles-by-3 (when <code>order</code> = 1) or #triangles-by-6 (when <code>order</code> = 2) matrix.
This option is used when a triangulation is already available. It specifies the triangles giving the indices in <code>nodes</code> of the triangles' vertices and (when <code>nodes</code> = 2) also if the triangles' edges midpoints. The triangles' vertices and midpoints are ordered as described
at  <br /> https://www.cs.cmu.edu/~quake/triangle.highorder.html.</p>
</dd>
<dt><code>segmentsmarkers</code></dt><dd><p>A vector of length #segments with entries either '1' or '0'. An entry '1' indicates that the corresponding element in <code>segments</code> is a boundary segment;
an entry '0' indicates that the corresponding segment is not a boundary segment.</p>
</dd>
<dt><code>edges</code></dt><dd><p>A #edges-by-2 matrix containing all the edges of the triangles in the output triangulation. Each row contains the row's indices in <code>nodes</code>, indicating the nodes where the edge starts from and ends to.</p>
</dd>
<dt><code>edgesmarkers</code></dt><dd><p>A vector of lenght #edges with entries either '1' or '0'. An entry '1' indicates that the corresponding element in <code>edge</code> is a boundary edge;
an entry '0' indicates that the corresponding edge is not a boundary edge.</p>
</dd>
<dt><code>neighbors</code></dt><dd><p>A #triangles-by-3 matrix. Each row contains the indices of the three neighbouring triangles. An entry '-1' indicates that
one edge of the triangle is a boundary edge.</p>
</dd>
<dt><code>holes</code></dt><dd><p>A #holes-by-2 matrix containing the x and y coordinates of a point internal to each hole of the mesh. These points are used to carve holes
in the triangulation, when the domain has holes.</p>
</dd>
<dt><code>order</code></dt><dd><p>Either '1' or '2'. It specifies wether each mesh triangle should be represented by 3 nodes (the triangle' vertices) or by 6 nodes (the triangle's vertices and midpoints).
These are respectively used for linear (order = 1) and quadratic (order = 2) Finite Elements.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+refine.mesh.2D">refine.mesh.2D</a></code>, <code><a href="#topic+create.FEM.basis">create.FEM.basis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)

## Upload the quasicirle2D data
data(quasicircle2D)
boundary_nodes = quasicircle2D$boundary_nodes
boundary_segments = quasicircle2D$boundary_segments
locations = quasicircle2D$locations
data = quasicircle2D$data

## Create mesh from boundary
## if the domain is convex it is sufficient to call:
mesh = create.mesh.2D(nodes = rbind(boundary_nodes, locations))
plot(mesh)

## if the domain is not convex, pass in addition the segments the compose the boundary:
mesh = create.mesh.2D(nodes = rbind(boundary_nodes, locations), segments = boundary_segments)

## Create mesh from data locations (without knowing the boundary)
mesh = create.mesh.2D(nodes = locations)
plot(mesh)
## In this case the domain is the convex hull of the data locations.
## Do this only if you do not have any information about the shape of the domain of interest.
</code></pre>

<hr>
<h2 id='create.mesh.3D'>Create a <code>mesh.3D</code> object from the connectivity matrix and nodes locations</h2><span id='topic+create.mesh.3D'></span>

<h3>Description</h3>

<p>Create a <code>mesh.3D</code> object from the connectivity matrix and nodes locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.mesh.3D(
  nodes,
  tetrahedrons,
  order = 1,
  nodesattributes = NULL,
  segments = NULL,
  holes = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.mesh.3D_+3A_nodes">nodes</code></td>
<td>
<p>A #nodes-by-3 matrix containing the x, y, z coordinates of the mesh nodes.</p>
</td></tr>
<tr><td><code id="create.mesh.3D_+3A_tetrahedrons">tetrahedrons</code></td>
<td>
<p>A #tetrahedrons-by-4 (when <code>order</code> = 1) or #tetrahedrons-by-10 (when <code>order</code> = 2) matrix.
It specifies the tetrahedrons giving the row's indices in <code>nodes</code> of the tetrahedrons' vertices and (when <code>nodes</code> = 2) also if the tetrahedrons' edges midpoints. The tetrahedrons' vertices and midpoints are ordered as described
in &quot;The Finite Element Method its Basis and Fundamentals&quot; by O. C. Zienkiewicz, R. L. Taylor and J.Z. Zhu</p>
</td></tr>
<tr><td><code id="create.mesh.3D_+3A_order">order</code></td>
<td>
<p>Either '1' or '2'. It specifies wether each mesh tetrahedron should be represented by 4 nodes (the tetrahedron's vertices) or by 10 nodes (the tetrahedron's vertices and edge midpoints).
These are
respectively used for linear (order = 1) and quadratic (order = 2) Finite Elements. Default is <code>order</code> = 1.</p>
</td></tr>
<tr><td><code id="create.mesh.3D_+3A_nodesattributes">nodesattributes</code></td>
<td>
<p>A matrix with #nodes rows containing nodes' attributes.
These are passed unchanged to the output. This has been added for consistency with the function <code>create.mesh.2D</code>.</p>
</td></tr>
<tr><td><code id="create.mesh.3D_+3A_segments">segments</code></td>
<td>
<p>A #segments-by-2 matrix. Each row contains the row's indices in <code>nodes</code> of the vertices where the segment starts from and ends to.
Segments are edges that are not splitted during the triangulation process. These are for instance used to define the boundaries
of the domain. This has been added for consistency with the function <code>create.mesh.2D</code>.</p>
</td></tr>
<tr><td><code id="create.mesh.3D_+3A_holes">holes</code></td>
<td>
<p>A #holes-by-3 matrix containing the x, y, z coordinates of a point internal to each hole of the mesh. These points are used to carve holes
in the triangulation, when the domain has holes. This has been added for consistency with the function <code>create.mesh.2D</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class mesh.3D with the following output:
</p>

<dl>
<dt><code>nodes</code></dt><dd><p>A #nodes-by-3 matrix containing the x, y, z coordinates of the mesh nodes.</p>
</dd>
<dt><code>nodesmarkers</code></dt><dd><p>A vector of length #nodes, with entries either '1' or '0'. An entry '1' indicates that the corresponding node is a boundary node; an entry '0' indicates that the corresponding node is not a boundary node.</p>
</dd>
<dt><code>nodesattributes</code></dt><dd><p>A matrix with #nodes rows containing nodes' attributes.
These are passed unchanged from the input.</p>
</dd>
<dt><code>tetrahedrons</code></dt><dd><p>A #tetrahedrons-by-4 (when <code>order</code> = 1) or #tetrahedrons-by-10 (when <code>order</code> = 2) matrix.
It specifies the tetrahedrons giving the indices in <code>nodes</code> of the tetrahedrons' vertices and (when <code>nodes</code> = 2) also if the tetrahedrons' edges midpoints.</p>
</dd> 
<dt><code>segmentsmarkers</code></dt><dd><p>A vector of length #segments with entries either '1' or '0'. An entry '1' indicates that the corresponding element in <code>segments</code> is a boundary segment;
an entry '0' indicates that the corresponding segment is not a boundary segment.</p>
</dd>
<dt><code>faces</code></dt><dd><p>A #faces-by-3 matrix containing all the faces of the tetrahedrons in the output triangulation. Each row contains the row's indices in <code>nodes</code>, indicating the nodes where the face starts from and ends to.</p>
</dd>
<dt><code>facesmarkers</code></dt><dd><p>A vector of lenght #faces with entries either '1' or '0'. An entry '1' indicates that the corresponding element in <code>faces</code> is a boundary face;
an entry '0' indicates that the corresponding edge is not a boundary face.</p>
</dd>
<dt><code>neighbors</code></dt><dd><p>A #triangles-by-4 matrix. Each row contains the indices of the four neighbouring tetrahedrons An entry '-1' indicates that
one face of the tetrahedrons is a boundary face.</p>
</dd>
<dt><code>holes</code></dt><dd><p>A #holes-by-3 matrix containing the x, y, z coordinates of a point internal to each hole of the mesh. These points are used to carve holes
in the triangulation, when the domain has holes. These are passed unchanged from the input.</p>
</dd>
<dt><code>order</code></dt><dd><p>Either '1' or '2'. It specifies wether each mesh tetrahedron should be represented by 3 nodes (the tetrahedron's vertices) or by 6 nodes (the tetrahedron's vertices and midpoints).
These are respectively used for linear (order = 1) and quadratic (order = 2) Finite Elements.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)

##Load the matrix nodes and tetrahedrons
data(sphere3Ddata)

nodes=sphere3Ddata$nodes
tetrahedrons=sphere3Ddata$tetrahedrons

##Create the triangulated mesh from the connectivity matrix and nodes locations
mesh=create.mesh.3D(nodes,tetrahedrons)
</code></pre>

<hr>
<h2 id='DE.FEM'>Nonparametric density estimation with differential regularization</h2><span id='topic+DE.FEM'></span>

<h3>Description</h3>

<p>This function implements a nonparametric density estimation method with differential regularization 
(given by the square root of the L2 norm of the laplacian of the density function), when points are located over a 
planar mesh. The computation relies only on the C++ implementation of the algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DE.FEM(data, FEMbasis, lambda, scaling=NULL, fvec=NULL, heatStep=0.1, heatIter=500,
       stepProposals=NULL,tol1=1e-4, tol2=0, print=FALSE, nfolds=0,
       nsimulations=500, step_method="Fixed_Step", direction_method="BFGS",
       preprocess_method="NoCrossValidation", search = "tree", inference = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DE.FEM_+3A_data">data</code></td>
<td>
<p>A matrix of dimensions #observations-by-ndim. Data are locations: each row corresponds to one point, 
the first column corresponds to the <code>x</code>-coordinates, the second column corresponds to the <code>y</code>-coordinates 
and, if ndim=3, the third column corresponds to the <code>z</code>-coordinates.</p>
</td></tr>
<tr><td><code id="DE.FEM_+3A_fembasis">FEMbasis</code></td>
<td>
<p>A <code>FEMbasis</code> object describing the Finite Element basis, as created by <code><a href="#topic+create.FEM.basis">create.FEM.basis</a></code>.</p>
</td></tr>
<tr><td><code id="DE.FEM_+3A_lambda">lambda</code></td>
<td>
<p>A scalar or vector of smoothing parameters. If it is a vector, the optimal smoothing parameter is chosen
with a <code>k</code>-fold cross-validation procedure based on the L2 norm.</p>
</td></tr>
<tr><td><code id="DE.FEM_+3A_scaling">scaling</code></td>
<td>
<p>A positive factor needed to scale the smoothing parameter in the construction of confidence intervals.
If the scaling is not specified, it is automatically set as the square root of the number of observations.</p>
</td></tr>
<tr><td><code id="DE.FEM_+3A_fvec">fvec</code></td>
<td>
<p>A vector of length #<code>nodes</code> of the mesh. It corresponds to the node values of the initial density function.
If this is <code>NULL</code> the initial density is estimated thanks to a discretized heat diffusion 
process that starts from the empirical density of the data. Default is <code>NULL</code>.
N.B. This vector cannot be the constant vector of zeros since the algorithm works with the log(f).</p>
</td></tr>
<tr><td><code id="DE.FEM_+3A_heatstep">heatStep</code></td>
<td>
<p>A real specifying the time step for the discretized heat diffusion process. Default is <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="DE.FEM_+3A_heatiter">heatIter</code></td>
<td>
<p>An integer specifying the number of iterations to perform the discretized heat diffusion process. Default is <code>500</code>.</p>
</td></tr>
<tr><td><code id="DE.FEM_+3A_stepproposals">stepProposals</code></td>
<td>
<p>A scalar or a vector containing the step parameters useful for the descent algorithm. If there is a
vector of parameters, the biggest one such that the functional decreases at each iteration is chosen. If it is <code>NULL</code>
the following vector <code>c(0.1, 0.01, 0.001, 0.0001, 0.00001, 0.000001, 1e-7, 1e-8, 1e-9)</code> is proposed. Default is <code>NULL</code>.
N.B. If the program does not receive a right parameter, it aborts the R session. Try a smaller parameter.</p>
</td></tr>
<tr><td><code id="DE.FEM_+3A_tol1">tol1</code></td>
<td>
<p>A scalar specifying the tolerance to use for the termination criterion based on the percentage difference
between two consecutive iterations of the minimization algorithm of the loss function, the log-likelihood and the
penalization. Default is 1e-5.</p>
</td></tr>
<tr><td><code id="DE.FEM_+3A_tol2">tol2</code></td>
<td>
<p>A scalar specifying the tolerance to use for the termination criterion based on the norm of the gradient 
of the functional to be minimized (the true minimum is such that this norm is zero). The default does not use this 
criterion. Default is 0.</p>
</td></tr>
<tr><td><code id="DE.FEM_+3A_print">print</code></td>
<td>
<p>A boolean that is <code>TRUE</code> if the user wants the value of the functional, of the loglikelihood and of the
penalization term printed on console at each iteration of the descent algorithm. Default is <code>FALSE</code>.
N.B. We suggest to let it <code>FALSE</code> if <code>preprocess_method</code> is 'RightCV' or 'SimplifiedCV'.</p>
</td></tr>
<tr><td><code id="DE.FEM_+3A_nfolds">nfolds</code></td>
<td>
<p>An integer specifying the number of folds used in cross validation technique to find the best <code>lambda</code> parameter.
If there is only one <code>lambda</code> it can be <code>0</code>. Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="DE.FEM_+3A_nsimulations">nsimulations</code></td>
<td>
<p>An integer specifying the number of iterations used in the optimization algorithms. Default value is 500.</p>
</td></tr>
<tr><td><code id="DE.FEM_+3A_step_method">step_method</code></td>
<td>
<p>String. This parameter specifies which step method use in the descent algorithm. 
If it is <code>Fixed_Step</code>, the step is constant during all the algorithm and it is chosen according to <code>stepProposals</code>;
if it is <code>Backtracking_Method</code>, the step is computed at each iteration according to the backtracking method; finally
if it is <code>Wolfe_Method</code>, the step is computed at each iteration according to the Wolfe method. Default is <code>Fixed_Step</code>.</p>
</td></tr>
<tr><td><code id="DE.FEM_+3A_direction_method">direction_method</code></td>
<td>
<p>String. This parameter specifies which descent direction use in the descent algorithm. 
If it is <code>Gradient</code>, the direction is the one given by the gradient descent method (the opposite to the gradient of
the functional); if instead it is <code>BFGS</code> the direction is the one given by the BFGS method
(Broyden Fletcher Goldfarb and Shanno, a Quasi-Newton method). Default is <code>BFGS</code>. Other possible choices:
Conjugate Gradient direction with Fletcher-Reeves formula (<code>ConjugateGradientFR</code>), Conjugate Gradient direction with
Polak-Ribi√©re-Polyak formula (<code>ConjugateGradientPRP</code>), Conjugate Gradient direction with Hestenes-Stiefel formula
(<code>ConjugateGradientHS</code>), Conjugate Gradient direction with Dai-Yuan formula (<code>ConjugateGradientDY</code>), Conjugate
Gradient direction with Conjugate-Descent formula (<code>ConjugateGradientCD</code>), Conjugate Gradient direction with Liu-Storey
formula (<code>ConjugateGradientLS</code>), L-BFGS direction with 5 correction vectors (<code>L-BFGS5</code>), L-BFGS direction with 10
correction vectors (<code>L-BFGS10</code>).</p>
</td></tr>
<tr><td><code id="DE.FEM_+3A_preprocess_method">preprocess_method</code></td>
<td>
<p>String. This parameter specifies the k fold cross validation technique to use, if there is more
than one smoothing parameter <code>lambda</code> (otherwise it should be <code>NULL</code>). If it is <code>RightCV</code> the usual k fold 
cross validation method is performed. If it is <code>SimplifiedCV</code> a simplified version is performed. 
In the latter case the number of smoothing parameters <code>lambda</code> must be equal to the number of folds <code>nfolds</code>.
Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="DE.FEM_+3A_search">search</code></td>
<td>
<p>a flag to decide the search algorithm type (tree or naive or walking search algorithm). Default is <code>tree</code>.</p>
</td></tr>
<tr><td><code id="DE.FEM_+3A_inference">inference</code></td>
<td>
<p>A boolean that is <code>TRUE</code> if the user wants to estimate confidence intervals. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following variables:
</p>
<table role = "presentation">
<tr><td><code>FEMbasis</code></td>
<td>
<p>Given FEMbasis with tree information.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>A vector of length #<code>nodes</code> that represents the value of the g-function estimated for each <code>node</code> of the mesh.
The density is the exponential of this function.</p>
</td></tr>
<tr><td><code>f_init</code></td>
<td>
<p>A #<code>nodes</code>-by-#<code>lambda</code> parameters matrix. Each column contains the node values of the initial
density used for the lambda given by the column.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>A scalar representing the optimal smoothing parameter selected via k fold cross validation, if in the 
input there is a vector of parameters; the scalar given in input otherwise.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>A matrix of dimensions #observations-by-ndim containing the data used in the algorithm. They are the 
same given in input if the domain is 2D pr 3D; they are the original data projected on the mesh if the domain is 2.5D.</p>
</td></tr>
<tr><td><code>CV_err</code></td>
<td>
<p>A vector of length <code>nfolds</code> containing the cross validation errors obtained in each fold, if 
<code>preprocess_method</code> is either <code>RightCV</code> or <code>SimplifiedCV</code>.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p>Ferraccioli, F., Arnone, E., Finos, L., Ramsay, J. O., Sangalli, L. M. (2021). Nonparametric density estimation over complicated domains.
Journal of the Royal Statistical Society: Series B (Statistical Methodology), 83(2), 346-368.
</p>
</li>
<li><p>Arnone, E., Ferraccioli, F., Pigolotti, C., Sangalli, L.M. (2021), A roughness penalty approach to estimate densities over two-dimensional manifolds, Computational Statistics and Data Analysis, to appear.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)

## Create a 2D mesh over a squared domain
Xbound &lt;- seq(-3, 3, length.out = 10)
Ybound &lt;- seq(-3, 3, length.out = 10)
grid_XY &lt;- expand.grid(Xbound, Ybound)
Bounds &lt;- grid_XY[(grid_XY$Var1 %in% c(-3, 3)) | (grid_XY$Var2 %in% c(-3, 3)), ]
mesh &lt;- create.mesh.2D(nodes = Bounds, order = 1)
mesh &lt;- refine.mesh.2D(mesh, maximum_area = 0.2)
FEMbasis &lt;- create.FEM.basis(mesh)

## Generate data
n &lt;- 50
set.seed(10)
data_x &lt;- rnorm(n)
data_y &lt;- rnorm(n)
data &lt;- cbind(data_x, data_y)

plot(mesh)
points(data, col="red", pch=19, cex=0.5)

## Density Estimation
lambda = 0.1
sol &lt;- DE.FEM(data = data, FEMbasis = FEMbasis, lambda = lambda, fvec=NULL, heatStep=0.1,
                  heatIter=500, nsimulations=300,step_method = "Fixed_Step", inference = TRUE)

## Visualization 
n = 100
X &lt;- seq(-3, 3, length.out = n)
Y&lt;- seq(-3, 3, length.out = n)
grid &lt;- expand.grid(X, Y)

evaluation &lt;- eval.FEM(FEM(FEMbasis, coeff = sol$g), locations = grid)
lower_bound_g &lt;- eval.FEM(FEM(FEMbasis, coeff = sol$g_CI_L), locations = grid)
upper_bound_g &lt;- eval.FEM(FEM(FEMbasis, coeff = sol$g_CI_U), locations = grid)
evaluation &lt;- exp(evaluation)
lower_bound_g &lt;- exp(lower_bound_g)
upper_bound_g &lt;- exp(upper_bound_g)
eval &lt;- matrix(evaluation, n, n)
eval_L &lt;- matrix(lower_bound_g, n, n)
eval_U &lt;- matrix(upper_bound_g, n, n)

image2D(x = X, y = Y, z = eval_L, col = heat.colors(100), xlab = "x", ylab = "y",
        contour = list(drawlabels = FALSE), main = "Estimated CI lower bound")
image2D(x = X, y = Y, z = eval, col = heat.colors(100), xlab = "x", ylab = "y", 
        contour = list(drawlabels = FALSE), main = "Estimated density")
image2D(x = X, y = Y, z = eval_U, col = heat.colors(100), xlab = "x", ylab = "y",
        contour = list(drawlabels = FALSE), main = "Estimated CI upper bound")
</code></pre>

<hr>
<h2 id='DE.FEM.time'>Nonparametric spatio-temporal density estimation with differential regularization</h2><span id='topic+DE.FEM.time'></span>

<h3>Description</h3>

<p>This function implements a nonparametric spatio-temporal density estimation method with differential regularization
(given by the sum of the square of the L2 norm of the laplacian of the density function and the square of the L2 norm of the second-
order time-derivative), when points are located over a planar mesh. The computation relies only on the C++ implementation of the algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DE.FEM.time(data, data_time, FEMbasis, mesh_time, lambda, lambda_time, scaling=NULL,
                   fvec=NULL, heatStep=0.1, heatIter=10, stepProposals=NULL, tol1=1e-4,
                   tol2=0, print=FALSE, nfolds=0, nsimulations=500,
                   step_method="Fixed_Step", direction_method="BFGS",
                   preprocess_method="NoCrossValidation", search="tree",
                   isTimeDiscrete=FALSE, flagMass=FALSE, flagLumped=FALSE,
                   inference = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DE.FEM.time_+3A_data">data</code></td>
<td>
<p>A matrix of dimensions #observations-by-ndim. Data are locations: each row corresponds to one point,
the first column corresponds to the <code>x</code>-coordinates, the second column corresponds to the <code>y</code>-coordinates
and, if ndim=3, the third column corresponds to the <code>z</code>-coordinates.</p>
</td></tr>
<tr><td><code id="DE.FEM.time_+3A_data_time">data_time</code></td>
<td>
<p>A vector of length #observations. The i-th datum is the time instant during which the i-th location is
observed (according to the order in which locations are provided in data).</p>
</td></tr>
<tr><td><code id="DE.FEM.time_+3A_fembasis">FEMbasis</code></td>
<td>
<p>A <code>FEMbasis</code> object describing the Finite Element basis, as created by <code><a href="#topic+create.FEM.basis">create.FEM.basis</a></code>.</p>
</td></tr>
<tr><td><code id="DE.FEM.time_+3A_mesh_time">mesh_time</code></td>
<td>
<p>A vector containing the b-splines knots for separable smoothing. It is the time mesh of the considered time domain
(interval). Its nodes are in increasing order.</p>
</td></tr>
<tr><td><code id="DE.FEM.time_+3A_lambda">lambda</code></td>
<td>
<p>A scalar or vector of smoothing parameters in space. If it is a vector, the optimal smoothing parameter in space
is chosen, together with the optimal smoothing parameter in time, with a <code>k</code>-fold cross-validation procedure based on the L2 norm.</p>
</td></tr>
<tr><td><code id="DE.FEM.time_+3A_lambda_time">lambda_time</code></td>
<td>
<p>A scalar or vector of smoothing parameters in time. If it is a vector, the optimal smoothing parameter in time
is chosen, together with the optimal smoothing parameter in space, with a <code>k</code>-fold cross-validation procedure based on the L2 norm.</p>
</td></tr>
<tr><td><code id="DE.FEM.time_+3A_scaling">scaling</code></td>
<td>
<p>A positive factor needed to scale the smoothing parameters in the construction of confidence intervals.
If the scaling is not specified, it is automatically set as the square root of the number of observations.</p>
</td></tr>
<tr><td><code id="DE.FEM.time_+3A_fvec">fvec</code></td>
<td>
<p>A vector of length #<code>nodes</code> of the spatial mesh times #<code>B-spline</code> temporal functional basis. It corresponds to the
node values of the initial density function. If this is <code>NULL</code> the initial density is estimated thanks to a discretized heat diffusion
process that starts from the empirical density of the data. Default is <code>NULL</code>.
N.B. This vector cannot be the constant vector of zeros since the algorithm works with the log(f).</p>
</td></tr>
<tr><td><code id="DE.FEM.time_+3A_heatstep">heatStep</code></td>
<td>
<p>A real specifying the time step for the discretized heat diffusion process. Default is <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="DE.FEM.time_+3A_heatiter">heatIter</code></td>
<td>
<p>An integer specifying the number of iterations to perform the discretized heat diffusion process. Default is <code>10</code>.</p>
</td></tr>
<tr><td><code id="DE.FEM.time_+3A_stepproposals">stepProposals</code></td>
<td>
<p>A scalar or a vector containing the step parameters useful for the descent algorithm. If there is a
vector of parameters, the biggest one such that the functional decreases at each iteration is chosen. If it is <code>NULL</code>
the following vector <code>c(0.1, 0.01, 0.001, 0.0001, 0.00001, 0.000001, 1e-7, 1e-8, 1e-9)</code> is proposed. Default is <code>NULL</code>.
N.B. If the program does not receive a right parameter, it aborts the R session. Try a smaller parameter.</p>
</td></tr>
<tr><td><code id="DE.FEM.time_+3A_tol1">tol1</code></td>
<td>
<p>A scalar specifying the tolerance to use for the termination criterion based on the percentage difference
between two consecutive iterations of the minimization algorithm of the loss function, the log-likelihood and the
penalizations. Default is 1e-5.</p>
</td></tr>
<tr><td><code id="DE.FEM.time_+3A_tol2">tol2</code></td>
<td>
<p>A scalar specifying the tolerance to use for the termination criterion based on the norm of the gradient
of the functional to be minimized (the true minimum is such that this norm is zero). The default version does not use this
criterion. Default is 0.</p>
</td></tr>
<tr><td><code id="DE.FEM.time_+3A_print">print</code></td>
<td>
<p>A boolean that is <code>TRUE</code> if the user wants the value of the functional, of the loglikelihood and of the
penalization terms printed on console at each iteration of the descent algorithm (plus some other information/warnings). Default is <code>FALSE</code>.
N.B. We suggest to let it <code>FALSE</code> if <code>preprocess_method</code> is 'RightCV' or 'SimplifiedCV'.</p>
</td></tr>
<tr><td><code id="DE.FEM.time_+3A_nfolds">nfolds</code></td>
<td>
<p>An integer specifying the number of folds used in cross validation technique to find the best pair of
(<code>lambda</code>, <code>lambda_time</code>) smoothing parameters.
If there is only one pair of (<code>lambda</code>, <code>lambda_time</code>) it can be <code>0</code>. Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="DE.FEM.time_+3A_nsimulations">nsimulations</code></td>
<td>
<p>An integer specifying the number of iterations used in the optimization algorithms. Default value is 500.</p>
</td></tr>
<tr><td><code id="DE.FEM.time_+3A_step_method">step_method</code></td>
<td>
<p>A string specifying which step method to use in the descent algorithm.
If it is <code>Fixed_Step</code>, the step is constant during the algorithm and it is chosen according to <code>stepProposals</code>;
if it is <code>Backtracking_Method</code>, the step is computed at each iteration according to the backtracking method; finally
if it is <code>Wolfe_Method</code>, the step is computed at each iteration according to the Wolfe method. Default is <code>Fixed_Step</code>.</p>
</td></tr>
<tr><td><code id="DE.FEM.time_+3A_direction_method">direction_method</code></td>
<td>
<p>A string specifying which descent direction to use in the descent algorithm.
If it is <code>Gradient</code>, the direction is the one given by the gradient descent method (the opposite to the gradient of
the functional); if instead it is <code>BFGS</code> the direction is the one given by the BFGS method
(Broyden-Fletcher-Goldfarb-Shanno, a Quasi-Newton method). Default is <code>BFGS</code>. Other possible choices:
Conjugate Gradient direction with Fletcher-Reeves formula (<code>ConjugateGradientFR</code>), Conjugate Gradient direction with
Polak-Ribi√©re-Polyak formula (<code>ConjugateGradientPRP</code>), Conjugate Gradient direction with Hestenes-Stiefel formula
(<code>ConjugateGradientHS</code>), Conjugate Gradient direction with Dai-Yuan formula (<code>ConjugateGradientDY</code>), Conjugate
Gradient direction with Conjugate-Descent formula (<code>ConjugateGradientCD</code>), Conjugate Gradient direction with Liu-Storey
formula (<code>ConjugateGradientLS</code>), L-BFGS direction with 5 correction vectors (<code>L-BFGS5</code>), L-BFGS direction with 10
correction vectors (<code>L-BFGS10</code>).</p>
</td></tr>
<tr><td><code id="DE.FEM.time_+3A_preprocess_method">preprocess_method</code></td>
<td>
<p>A string specifying the k fold cross validation technique to use, if there is more than one pair of
smoothing parameters in space and in time (<code>lambda</code>, <code>lambda_time</code>); otherwise it should be <code>NULL</code>.
If it is <code>RightCV</code> the usual k fold cross validation method is performed. If it is <code>SimplifiedCV</code> a simplified
version is performed. In the latter case the number of possible pairs of smoothing parameters in space and in time
(<code>lambda</code>, <code>lambda_time</code>) must be equal to the number of folds <code>nfolds</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="DE.FEM.time_+3A_search">search</code></td>
<td>
<p>A flag to decide the search algorithm type (tree or naive or walking search algorithm). Default is <code>tree</code>.</p>
</td></tr>
<tr><td><code id="DE.FEM.time_+3A_istimediscrete">isTimeDiscrete</code></td>
<td>
<p>A boolean specifying the time data type: <code>TRUE</code> for discrete (with many duplicates) time data;
<code>FALSE</code> for continuous time data. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="DE.FEM.time_+3A_flagmass">flagMass</code></td>
<td>
<p>A boolean specifying whether to consider full mass matrices (<code>TRUE</code>) or identity mass matrices
(<code>FALSE</code>) for the computation of space and time penalty matrices. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="DE.FEM.time_+3A_flaglumped">flagLumped</code></td>
<td>
<p>A boolean specifying whether to perform mass lumping. This numerical technique presents computational
advantages during the procedure involving a mass matrix inversion for the computation of the space penalty matrix.
Default is <code>FALSE</code>.
N.B. We suggest to use it as <code>TRUE</code> in case of a large spatial domain or in case of a dense/refined spatial mesh.</p>
</td></tr>
<tr><td><code id="DE.FEM.time_+3A_inference">inference</code></td>
<td>
<p>A boolean that is <code>TRUE</code> if the user wants to estimate confidence intervals. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following variables:
</p>
<table role = "presentation">
<tr><td><code>FEMbasis</code></td>
<td>
<p>Given FEMbasis with tree information.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>A vector of length #<code>nodes</code> times #<code>B-splines</code> that represents the value of the g-function estimated for
each <code>node</code> of the spatial mesh and at each time instant of the time mesh. The density is the exponential of this function.</p>
</td></tr>
<tr><td><code>f_init</code></td>
<td>
<p>A #<code>nodes</code>-by-#<code>lambda</code>x#<code>lambda_time</code> parameters matrix. Each column contains the node values of the initial
density used for the pair (<code>lambda</code>, <code>lambda_time</code>) given by the column.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>A scalar representing the optimal smoothing parameter in space selected, together with <code>lambda_time</code>,
via k fold cross validation, if in the input there is a vector of parameters (in space and/or in time); the scalar given in input otherwise.</p>
</td></tr>
<tr><td><code>lambda_time</code></td>
<td>
<p>A scalar representing the optimal smoothing parameter in time selected, together with <code>lambda</code>,
via k fold cross validation, if in the input there is a vector of parameters (in space and/or in time); the scalar given in input otherwise.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>A matrix of dimensions #observations-by-ndim containing the spatial data used in the algorithm. They are the
same given in input if the domain is 2D pr 3D; they are the original data projected on the mesh if the domain is 2.5D. Data lying
outside the spatial domain, defined through its mesh, are not considered.</p>
</td></tr>
<tr><td><code>data_time</code></td>
<td>
<p>A vector of length #observations containing the time data used in the algorithm. Data lying
outside the temporal domain, defined through its mesh, are not considered.</p>
</td></tr>
<tr><td><code>CV_err</code></td>
<td>
<p>A vector of length <code>nfolds</code> containing the cross validation errors obtained in each fold, if
<code>preprocess_method</code> is either <code>RightCV</code> or <code>SimplifiedCV</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)

## Create a 2D mesh over a squared domain
Xbound &lt;- seq(-3, 3, length.out = 10)
Ybound &lt;- seq(-3, 3, length.out = 10)
grid_XY &lt;- expand.grid(Xbound, Ybound)
Bounds &lt;- grid_XY[(grid_XY$Var1 %in% c(-3, 3)) | (grid_XY$Var2 %in% c(-3, 3)), ]
mesh &lt;- create.mesh.2D(nodes = Bounds, order = 1)
mesh &lt;- refine.mesh.2D(mesh, maximum_area = 0.25, minimum_angle = 20)
FEMbasis &lt;- create.FEM.basis(mesh)

## Create a 1D time mesh over a (non-negative) interval
mesh_time &lt;- seq(0, 1, length.out=3)

## Generate data
n &lt;- 50
set.seed(10)
x &lt;- rnorm(n,0,2)
y &lt;- rnorm(n,0,2)
locations &lt;- cbind(x,y)
times &lt;- runif(n,0,1)
data &lt;- cbind(locations, times)

t &lt;- 0.5 # time instant in which to evaluate the solution

plot(mesh)
sample &lt;- data[abs(data[,3]-t)&lt;0.05,1:2]
points(sample, col="red", pch=19, cex=1, main=paste('Sample | ', t-0.05,' &lt; t &lt; ', t+0.05))

## Density Estimation
lambda &lt;- 0.1
lambda_time &lt;- 0.001
sol &lt;- DE.FEM.time(data = locations, data_time = times, FEMbasis = FEMbasis, mesh_time = mesh_time,
                   lambda = lambda, lambda_time = lambda_time, nsimulations=300, inference=TRUE)

## Visualization
n = 100
X &lt;- seq(-3, 3, length.out = n)
Y &lt;- seq(-3, 3, length.out = n)
grid &lt;- expand.grid(X, Y)

FEMfunction = FEM.time(sol$g, mesh_time, FEMbasis, FLAG_PARABOLIC = FALSE)
evaluation &lt;- eval.FEM.time(FEM.time = FEMfunction, locations = grid, time.instants = t)
FEMfunction_L = FEM.time(sol$g_CI_L, mesh_time, FEMbasis, FLAG_PARABOLIC = FALSE)
evaluation_L &lt;- eval.FEM.time(FEM.time = FEMfunction_L, locations = grid, time.instants = t)
FEMfunction_U = FEM.time(sol$g_CI_U, mesh_time, FEMbasis, FLAG_PARABOLIC = FALSE)
evaluation_U &lt;- eval.FEM.time(FEM.time = FEMfunction_U, locations = grid, time.instants = t)

image2D(x = X, y = Y, z = matrix(exp(evaluation_L), n, n), col = heat.colors(100),
        xlab = "x", ylab = "y", contour = list(drawlabels = FALSE),
        main = paste("Estimated CI lower bound at t = ", t), zlim=c(0,0.3), asp = 1)
image2D(x = X, y = Y, z = matrix(exp(evaluation), n, n), col = heat.colors(100),
        xlab = "x", ylab = "y", contour = list(drawlabels = FALSE),
        main = paste("Estimated density at t = ", t), zlim=c(0,0.3), asp = 1)
image2D(x = X, y = Y, z = matrix(exp(evaluation_U), n, n), col = heat.colors(100),
        xlab = "x", ylab = "y", contour = list(drawlabels = FALSE),
        main = paste("Estimated CI upper bound at t = ", t), zlim=c(0,0.3), asp = 1)
</code></pre>

<hr>
<h2 id='DE.heat.FEM'>Density initialization</h2><span id='topic+DE.heat.FEM'></span>

<h3>Description</h3>

<p>This function implements two methods for the density initialization procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DE.heat.FEM(data, FEMbasis, lambda=NULL, heatStep=0.1, heatIter=500, 
            init="Heat", nFolds=5, search = "tree")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DE.heat.FEM_+3A_data">data</code></td>
<td>
<p>A matrix of dimensions #observations-by-ndim. Data are locations: each row corresponds to one point, 
the first column corresponds to the <code>x</code>-coordinates, the second column corresponds to the <code>y</code>-coordinates 
and, if ndim=3, the third column corresponds to the <code>z</code>-coordinates.</p>
</td></tr>
<tr><td><code id="DE.heat.FEM_+3A_fembasis">FEMbasis</code></td>
<td>
<p>A <code>FEMbasis</code> object describing the Finite Element basis, as created by <code><a href="#topic+create.FEM.basis">create.FEM.basis</a></code>.</p>
</td></tr>
<tr><td><code id="DE.heat.FEM_+3A_lambda">lambda</code></td>
<td>
<p>A scalar or vector of smoothing parameters. Default is NULL. It is useful only if <code>init='Heat'</code>.</p>
</td></tr>
<tr><td><code id="DE.heat.FEM_+3A_heatstep">heatStep</code></td>
<td>
<p>Real specifying the time step for the discretized heat diffusionn process.</p>
</td></tr>
<tr><td><code id="DE.heat.FEM_+3A_heatiter">heatIter</code></td>
<td>
<p>Integer specifying the number of iteriations to perform the discretized heat diffusion process.</p>
</td></tr>
<tr><td><code id="DE.heat.FEM_+3A_init">init</code></td>
<td>
<p>String. This parameter specifies the initialization procedure. It can be either 'Heat' or 'CV'.</p>
</td></tr>
<tr><td><code id="DE.heat.FEM_+3A_nfolds">nFolds</code></td>
<td>
<p>An integer specifying the number of folds used in cross validation techinque. It is useful only 
for the case <code>init = 'CV'</code>.</p>
</td></tr>
<tr><td><code id="DE.heat.FEM_+3A_search">search</code></td>
<td>
<p>a flag to decide the search algorithm type (tree or naive or walking search algorithm).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>init = 'Heat'</code> it returns a matrix in which each column contains the initial vector 
for each <code>lambda</code>. If <code>init = 'CV'</code> it returns the initial vector associated to the <code>lambda</code> given.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)

## Create a 2D mesh over a squared domain
Xbound &lt;- seq(-3, 3, length.out = 10)
Ybound &lt;- seq(-3, 3, length.out = 10)
grid_XY &lt;- expand.grid(Xbound, Ybound)
Bounds &lt;- grid_XY[(grid_XY$Var1 %in% c(-3, 3)) | (grid_XY$Var2 %in% c(-3, 3)), ]
mesh &lt;- create.mesh.2D(nodes = Bounds, order = 1)
mesh &lt;- refine.mesh.2D(mesh, maximum_area = 0.2)
FEMbasis &lt;- create.FEM.basis(mesh)

## Generate data
n &lt;- 50
set.seed(10)
data_x &lt;- rnorm(n)
data_y &lt;- rnorm(n)
data &lt;- cbind(data_x, data_y)

plot(mesh)
points(data, col="red", pch=19, cex=0.5)

## Density initialization
lambda = 0.1
sol = DE.heat.FEM(data, FEMbasis, lambda, heatStep=0.1, heatIter=500, init="Heat")

## Visualization 
plot(FEM(coeff=sol$f_init, FEMbasis=FEMbasis))
</code></pre>

<hr>
<h2 id='DE.heat.FEM.time'>Spatio-temporal density initialization</h2><span id='topic+DE.heat.FEM.time'></span>

<h3>Description</h3>

<p>This function implements two methods for the density initialization procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DE.heat.FEM.time(data, data_time, FEMbasis, mesh_time, lambda=NULL,
                            lambda_time=NULL, heatStep=0.1, heatIter=10, 
                            init="Heat", nFolds=5, search="tree", 
                            isTimeDiscrete=FALSE, flagMass=FALSE, flagLumped=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DE.heat.FEM.time_+3A_data">data</code></td>
<td>
<p>A matrix of dimensions #observations-by-ndim. Data are locations: each row corresponds to one point,
the first column corresponds to the <code>x</code>-coordinates, the second column corresponds to the <code>y</code>-coordinates
and, if ndim=3, the third column corresponds to the <code>z</code>-coordinates.</p>
</td></tr>
<tr><td><code id="DE.heat.FEM.time_+3A_data_time">data_time</code></td>
<td>
<p>A vector of dimensions #observations. The i-th datum is the time instant during which the i-th location is observed
(according to the order in which data are provided).</p>
</td></tr>
<tr><td><code id="DE.heat.FEM.time_+3A_fembasis">FEMbasis</code></td>
<td>
<p>A <code>FEMbasis</code> object describing the Finite Element basis, as created by <code><a href="#topic+create.FEM.basis">create.FEM.basis</a></code>.</p>
</td></tr>
<tr><td><code id="DE.heat.FEM.time_+3A_mesh_time">mesh_time</code></td>
<td>
<p>A vector containing the b-splines knots for separable smoothing. It is the time mesh of the considered time domain
(interval). Its nodes are in increasing order.</p>
</td></tr>
<tr><td><code id="DE.heat.FEM.time_+3A_lambda">lambda</code></td>
<td>
<p>A scalar or vector of smoothing parameters in space. Default is NULL. It is useful only if <code>init='Heat'</code>.</p>
</td></tr>
<tr><td><code id="DE.heat.FEM.time_+3A_lambda_time">lambda_time</code></td>
<td>
<p>A scalar or vector of smoothing parameters in time. Default is NULL. It is useful only if <code>init='Heat'</code>.</p>
</td></tr>
<tr><td><code id="DE.heat.FEM.time_+3A_heatstep">heatStep</code></td>
<td>
<p>A real specifying the time step for the discretized heat diffusion process.</p>
</td></tr>
<tr><td><code id="DE.heat.FEM.time_+3A_heatiter">heatIter</code></td>
<td>
<p>An integer specifying the number of iterations to perform the discretized heat diffusion process.</p>
</td></tr>
<tr><td><code id="DE.heat.FEM.time_+3A_init">init</code></td>
<td>
<p>A string specifying the initialization procedure. It can be either 'Heat' or 'CV'.</p>
</td></tr>
<tr><td><code id="DE.heat.FEM.time_+3A_nfolds">nFolds</code></td>
<td>
<p>An integer specifying the number of folds used in the cross validation technique. It is useful only
for the case <code>init = 'CV'</code>.</p>
</td></tr>
<tr><td><code id="DE.heat.FEM.time_+3A_search">search</code></td>
<td>
<p>A flag to decide the search algorithm type (tree or naive or walking search algorithm).</p>
</td></tr>
<tr><td><code id="DE.heat.FEM.time_+3A_istimediscrete">isTimeDiscrete</code></td>
<td>
<p>A boolean specifying the time data type: <code>TRUE</code> for discrete (with many duplicates) time data;
<code>FALSE</code> for continuous time data. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="DE.heat.FEM.time_+3A_flagmass">flagMass</code></td>
<td>
<p>A boolean specifying whether to consider full mass matrices (<code>TRUE</code>) or identity mass matrices
(<code>FALSE</code>) for the computation of space and time penalty matrices. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="DE.heat.FEM.time_+3A_flaglumped">flagLumped</code></td>
<td>
<p>A boolean specifying whether to perform mass lumping. This numerical technique presents computational
advantages during the procedure involving a mass matrix inversion for the computation of the space penalty matrix.
Default is <code>FALSE</code>.
N.B. We suggest to put it <code>TRUE</code> in case of a large spatial domain or in case of a dense/refined spatial mesh.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>init = 'Heat'</code> it returns a matrix in which each column contains the initial vector
for each possible pair (<code>lambda</code>, <code>lambda_time</code>). If <code>init = 'CV'</code> it returns the initial vector associated
to the unique pair (<code>lambda</code>, <code>lambda_time</code>) given.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)

## Create a 2D mesh over a squared domain
Xbound &lt;- seq(-3, 3, length.out = 10)
Ybound &lt;- seq(-3, 3, length.out = 10)
grid_XY &lt;- expand.grid(Xbound, Ybound)
Bounds &lt;- grid_XY[(grid_XY$Var1 %in% c(-3, 3)) | (grid_XY$Var2 %in% c(-3, 3)), ]
mesh &lt;- create.mesh.2D(nodes = Bounds, order = 1)
mesh &lt;- refine.mesh.2D(mesh, maximum_area = 0.25, minimum_angle = 20)
FEMbasis &lt;- create.FEM.basis(mesh)

## Create a 1D time mesh over a (non-negative) interval
mesh_time &lt;- seq(0, 1, length.out=3)

## Generate data
n &lt;- 50
set.seed(10)
x &lt;- rnorm(n,0,2)
y &lt;- rnorm(n,0,2)
locations &lt;- cbind(x,y)
times &lt;- runif(n,0,1)
data &lt;- cbind(locations, times)

t &lt;- 0.5 # time instant in which to evaluate the solution

plot(mesh)
sample &lt;- data[abs(data[,3]-t)&lt;0.05,1:2]
points(sample, col="red", pch=19, cex=1, main=paste('Sample | ', t-0.05,' &lt; t &lt; ', t+0.05))

## Density initialization
lambda = 0.1
lambda_time &lt;- 0.001
sol = DE.heat.FEM.time(data = locations, data_time = times, FEMbasis = FEMbasis,
                       mesh_time = mesh_time, lambda = lambda, lambda_time = lambda_time,
                       heatStep=0.1, heatIter=10, init="Heat")

## Visualization

n = 100
X &lt;- seq(-3, 3, length.out = n)
Y &lt;- seq(-3, 3, length.out = n)
grid &lt;- expand.grid(X, Y)

FEMfunction = FEM.time(sol$f_init[,1,1], mesh_time, FEMbasis, FLAG_PARABOLIC = FALSE)
evaluation &lt;- eval.FEM.time(FEM.time = FEMfunction, locations = grid, time.instants = t)
image2D(x = X, y = Y, z = matrix(evaluation, n, n), col = heat.colors(100),
        xlab = "", ylab = "", contour = list(drawlabels = FALSE),
        main = paste("Initial guess at t = ", t), zlim=c(0,0.2), asp = 1)

</code></pre>

<hr>
<h2 id='eval.FEM'>Evaluate a FEM object at a set of point locations</h2><span id='topic+eval.FEM'></span>

<h3>Description</h3>

<p>It evaluates a FEM object at the specified set of locations or areal regions. The locations are used for
pointwise evaluations and incidence matrix for areal evaluations.
The locations and the incidence matrix cannot be both NULL or both provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.FEM(FEM, locations = NULL, incidence_matrix = NULL, search = "tree", 
                bary.locations = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eval.FEM_+3A_fem">FEM</code></td>
<td>
<p>A <code>FEM</code> object to be evaluated.</p>
</td></tr>
<tr><td><code id="eval.FEM_+3A_locations">locations</code></td>
<td>
<p>A 2-columns (in 1.5D or 2D) or 3-columns (in 2.5D and 3D) matrix with the spatial locations where the
FEM object should be evaluated.</p>
</td></tr>
<tr><td><code id="eval.FEM_+3A_incidence_matrix">incidence_matrix</code></td>
<td>
<p>In case of areal evaluations, the #regions-by-#elements incidence matrix defining the regions
where the FEM object should be evaluated.</p>
</td></tr>
<tr><td><code id="eval.FEM_+3A_search">search</code></td>
<td>
<p>a flag to decide the search algorithm type (tree or naive or walking search algorithm).</p>
</td></tr>
<tr><td><code id="eval.FEM_+3A_bary.locations">bary.locations</code></td>
<td>
<p>A list with three vectors:
<code>locations</code>, location points which are same as the given locations options. (checks whether both locations are the same);
<code>element ids</code>, a vector of element id of the points from the mesh where they are located;
<code>barycenters</code>, a vector of barycenter of points from the located element.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or a matrix of numeric evaluations of the <code>FEM</code> object.
If the <code>FEM</code> object contains multiple finite element functions the output is a matrix, and
each row corresponds to the location (or areal region) where the evaluation has been taken, while each column
corresponds to the function evaluated.
</p>


<h3>References</h3>


<ul>
<li><p>Sangalli, L. M., Ramsay, J. O., &amp; Ramsay, T. O. (2013). Spatial spline regression models.
Journal of the Royal Statistical Society: Series B (Statistical Methodology), 75(4), 681-703.
</p>
</li>
<li><p>Azzimonti, L., Sangalli, L. M., Secchi, P., Domanin, M., &amp; Nobile, F. (2015). Blood flow velocity field estimation
via spatial regression with PDE penalization. Journal of the American Statistical Association, 110(511), 1057-1071.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)
## Upload the horseshoe2D data
data(horseshoe2D)
boundary_nodes = horseshoe2D$boundary_nodes
boundary_segments = horseshoe2D$boundary_segments
locations = horseshoe2D$locations

## Create the 2D mesh
mesh = create.mesh.2D(nodes = rbind(boundary_nodes, locations), segments = boundary_segments)
## Create the FEM basis
FEMbasis = create.FEM.basis(mesh)
## Compute the coeff vector evaluating the desired function at the mesh nodes
## In this case we consider the fs.test() function introduced by Wood et al. 2008
coeff = fs.test(mesh$nodes[,1], mesh$nodes[,2])
## Create the FEM object
FEMfunction = FEM(coeff, FEMbasis)

## Evaluate the finite element function in the location (1,0.5)
eval.FEM(FEMfunction, locations = matrix(c(1, 0.5), ncol = 2))

## Evaluate the mean of the finite element function over the fifth triangle of the mesh
incidence_matrix = matrix(0, ncol = nrow(mesh$triangles))
incidence_matrix[1,5] = 1
eval.FEM(FEMfunction, incidence_matrix = incidence_matrix)
</code></pre>

<hr>
<h2 id='eval.FEM.time'>Evaluate a FEM.time object at a set of point locations</h2><span id='topic+eval.FEM.time'></span>

<h3>Description</h3>

<p>It evaluates a <code>FEM.time</code> object at the specified set of locations or regions. 
If <code>space.time.locations</code> is provided <code>locations</code>, <code>incidence_matrix</code> and 
<code>time.instants</code> must be NULL. Otherwise <code>time.instants</code> and one of <code>locations</code> and 
<code>incidence_matrix</code> must be given. In this case the evaluation is perform on the tensor grid
<code>time.instants</code>-by-<code>locations</code> (or <code>time.instants</code>-by-areal domains).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.FEM.time(FEM.time, locations = NULL, time.instants = NULL, 
                     space.time.locations = NULL, incidence_matrix = NULL, lambdaS = 1, 
                     lambdaT = 1, search = "tree", bary.locations = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eval.FEM.time_+3A_fem.time">FEM.time</code></td>
<td>
<p>A <code>FEM.time</code> object to be evaluated.</p>
</td></tr>
<tr><td><code id="eval.FEM.time_+3A_locations">locations</code></td>
<td>
<p>A 2-columns (in case of planar mesh) or 3-columns(in case of 2D manifold in a 3D space or a 3D volume) matrix with the spatial locations where the FEM.time object should be evaluated.</p>
</td></tr>
<tr><td><code id="eval.FEM.time_+3A_time.instants">time.instants</code></td>
<td>
<p>A vector with the time instants where the FEM.time object should be evaluated.</p>
</td></tr>
<tr><td><code id="eval.FEM.time_+3A_space.time.locations">space.time.locations</code></td>
<td>
<p>A 3-columns (in case of planar mesh) or 4-columns(in case of 2D manifold in a 3D space or a 3D volume) 
matrix with the time instants and spatial locations where the FEM.time object should be evaluated. 
The first column is for the time instants. If given, <code>locations</code>, <code>incidence_matrix</code> and <code>time.instants</code> must be NULL.</p>
</td></tr>
<tr><td><code id="eval.FEM.time_+3A_incidence_matrix">incidence_matrix</code></td>
<td>
<p>In case of areal data, the #regions x #elements incidence matrix defining the regions.</p>
</td></tr>
<tr><td><code id="eval.FEM.time_+3A_lambdas">lambdaS</code></td>
<td>
<p>The index of the lambdaS choosen for the evaluation.</p>
</td></tr>
<tr><td><code id="eval.FEM.time_+3A_lambdat">lambdaT</code></td>
<td>
<p>The index of the lambdaT choosen for the evaluation.</p>
</td></tr>
<tr><td><code id="eval.FEM.time_+3A_search">search</code></td>
<td>
<p>a flag to decide the search algorithm type (tree or naive or walking search algorithm).</p>
</td></tr>
<tr><td><code id="eval.FEM.time_+3A_bary.locations">bary.locations</code></td>
<td>
<p>A list with three vectors:
<code>locations</code>, location points which are same as the given locations options. (checks whether both locations are the same);
<code>element ids</code>, a vector of element id of the points from the mesh where they are located;
<code>barycenters</code>, a vector of barycenter of points from the located element.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of numeric evaluations of the <code>FEM.time</code> object. Each row indicates the location where 
the evaluation has been taken, the column indicates the function evaluated.
</p>


<h3>References</h3>

<p>Devillers, O. et al. 2001. Walking in a Triangulation, Proceedings of the Seventeenth Annual Symposium on Computational Geometry
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)
## Upload the horseshoe2D data
data(horseshoe2D)
boundary_nodes = horseshoe2D$boundary_nodes
boundary_segments = horseshoe2D$boundary_segments
locations = horseshoe2D$locations

## Create the 2D mesh
mesh = create.mesh.2D(nodes = rbind(boundary_nodes, locations), segments = boundary_segments)
## Create the FEM basis
FEMbasis = create.FEM.basis(mesh)
## Compute the coeff vector evaluating the desired function at the mesh nodes
## In this case we consider the fs.test() function introduced by Wood et al. 2008
time = 1:5
coeff = rep(fs.test(mesh$nodes[,1], mesh$nodes[,2]),5)*time
## Create the FEM.time object
FEM_time_function = FEM.time(coeff=coeff, time_mesh=1:5, FEMbasis=FEMbasis, FLAG_PARABOLIC=TRUE)

evaluations = eval.FEM.time(FEM_time_function, locations = matrix(c(-0.92,0), ncol=2), 
                            time.instants = time)
</code></pre>

<hr>
<h2 id='fdaPDE-deprecated'>Deprecated Functions</h2><span id='topic+fdaPDE-deprecated'></span><span id='topic+R_mass'></span><span id='topic+R_stiff'></span><span id='topic+R_smooth.FEM.basis'></span><span id='topic+R_eval.FEM.basis'></span><span id='topic+R_eval.FEM'></span><span id='topic+smooth.FEM.basis'></span><span id='topic+smooth.FEM.PDE.basis'></span><span id='topic+smooth.FEM.PDE.sv.basis'></span><span id='topic+create.MESH.2D'></span><span id='topic+refine.MESH.2D'></span><span id='topic+plot.MESH2D'></span>

<h3>Description</h3>

<p>Only executed when <code>smooth.FEM.basis</code> is run with the option  <code>CPP_CODE</code> = <code>FALSE</code>. It computes the mass matrix. The element (i,j) of this matrix contains the integral over the domain of the product between the ith and kth element 
of the Finite Element basis. As common practise in Finite Element Analysis, this quantities are computed iterating over all the mesh triangles.
</p>
<p>Only executed when <code>smooth.FEM.basis</code> is run with the option  <code>CPP_CODE</code> = <code>FALSE</code>. It computes the stifness matrix. The element (i,j) of this matrix contains the integral over the domain of the scalar product between the gradient of the ith and kth element 
of the Finite Element basis. As common practise in Finite Element Analysis, this quantities are computed iterating over all the mesh triangles.
</p>
<p>Only executed when the function <code>smooth.FEM.basis</code> is run with the option <code>CPP_CODE</code> = <code>FALSE</code>. It evaluates the Finite Element basis functions and their derivatives up to order 2 at the specified set of locations. 
This version of the function is implemented using only R code. It is called by <a href="#topic+R_smooth.FEM.basis">R_smooth.FEM.basis</a>.
</p>
<p>Only executed when the function <code>smooth.FEM.basis</code> is run with the option <code>CPP_CODE</code> = <code>FALSE</code>. It evaluates a FEM object at the specified set of locations.
</p>
<p>This function implements a spatial regression model with differential regularization; isotropic and stationary case. In particular, the regularizing term involves the Laplacian of the spatial field. Space-varying covariates can be included in the model. The technique accurately handle data distributed over irregularly shaped domains. Moreover, various conditions can be imposed at the domain boundaries.
</p>
<p>This function implements a spatial regression model with differential regularization; anysotropic case. In particular, the regularizing term involves a second order elliptic PDE, that models the space-variation of the phenomenon. Space-varying covariates can be included in the model. The technique accurately handle data distributed over irregularly shaped domains. Moreover, various conditions can be imposed at the domain boundaries.
</p>
<p>This function implements a spatial regression model with differential regularization; anysotropic and non-stationary case. In particular, the regularizing term involves a second order elliptic PDE with space-varying coefficients, that models the space-variation of the phenomenon. Space-varying covariates can be included in the model. The technique accurately handle data distributed over irregularly shaped domains. Moreover, various conditions can be imposed at the domain boundaries.
</p>
<p>This function is a wrapper of the Triangle library (http://www.cs.cmu.edu/~quake/triangle.html). It can be used
to create a triangulation of the domain of interest starting from a list of points, to be used as triangles' vertices, and a list of segments, that define the domain boundary. The resulting
mesh is a Constrained Delaunay triangulation. This is constructed in a way to preserve segments provided in the input <code>segments</code> without splitting them. This imput can be used to define the boundaries
of the domain. If this imput is NULL, it generates a triangulation over the
convex hull of the points.
</p>
<p>This function refines a Constrained Delaunay triangulation into a Conforming Delaunay triangulation. This is a wrapper of the Triangle library (http://www.cs.cmu.edu/~quake/triangle.html). It can be used to 
refine a mesh created previously with <a href="#topic+create.MESH.2D">create.MESH.2D</a>. The algorithm can add Steiner points (points through which the <code>segments</code> are splitted)
in order to meet the imposed refinement conditions.
</p>
<p>Plot a mesh MESH2D object, generated by <code>create.MESH.2D</code> or <code>refine.MESH.2D</code>. Circles indicate the mesh nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R_mass(FEMbasis)

R_stiff(FEMbasis)

R_smooth.FEM.basis(
  locations,
  observations,
  FEMbasis,
  lambda,
  covariates = NULL,
  GCV
)

R_eval.FEM.basis(FEMbasis, locations, nderivs = matrix(0, 1, 2))

R_eval.FEM(FEM, locations)

smooth.FEM.basis(
  locations = NULL,
  observations,
  FEMbasis,
  lambda,
  covariates = NULL,
  BC = NULL,
  GCV = FALSE,
  CPP_CODE = TRUE
)

smooth.FEM.PDE.basis(
  locations = NULL,
  observations,
  FEMbasis,
  lambda,
  PDE_parameters,
  covariates = NULL,
  BC = NULL,
  GCV = FALSE,
  CPP_CODE = TRUE
)

smooth.FEM.PDE.sv.basis(
  locations = NULL,
  observations,
  FEMbasis,
  lambda,
  PDE_parameters,
  covariates = NULL,
  BC = NULL,
  GCV = FALSE,
  CPP_CODE = TRUE
)

create.MESH.2D(nodes, nodesattributes = NA, segments = NA, holes = NA, 
                     triangles = NA, order = 1, verbosity = 0)

refine.MESH.2D(mesh, minimum_angle, maximum_area, delaunay, verbosity)

## S3 method for class 'MESH2D'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fdaPDE-deprecated_+3A_fembasis">FEMbasis</code></td>
<td>
<p>A <code>FEMbasis</code> object describing the Finite Element basis, as created by <code><a href="#topic+create.FEM.basis">create.FEM.basis</a></code>.</p>
</td></tr>
<tr><td><code id="fdaPDE-deprecated_+3A_locations">locations</code></td>
<td>
<p>A #observations-by-2 matrix where each row specifies the spatial coordinates <code>x</code> and <code>y</code> of the corresponding observations in the vector <code>observations</code>.
This parameter can be <code>NULL</code>. In this case the spatial coordinates of the corresponding observations are assigned as specified in <code>observations</code>.</p>
</td></tr>
<tr><td><code id="fdaPDE-deprecated_+3A_observations">observations</code></td>
<td>
<p>A vector of length #observations with the observed data values over the domain. 
The locations of the observations can be specified with the <code>locations</code> argument. 
Otherwise if only the vector of observations is given, these are consider to be located in the corresponding node in the table
<code>nodes</code> of the mesh. In this last case, an <code>NA</code> value in the <code>observations</code> vector indicates that there is no observation associated to the corresponding
node.</p>
</td></tr>
<tr><td><code id="fdaPDE-deprecated_+3A_lambda">lambda</code></td>
<td>
<p>A scalar or vector of smoothing parameters.</p>
</td></tr>
<tr><td><code id="fdaPDE-deprecated_+3A_covariates">covariates</code></td>
<td>
<p>A #observations-by-#covariates matrix where each row represents the covariates associated with the corresponding observed data value in <code>observations</code>.</p>
</td></tr>
<tr><td><code id="fdaPDE-deprecated_+3A_gcv">GCV</code></td>
<td>
<p>Boolean. If <code>TRUE</code> the following quantities are computed: the trace of the smoothing matrix, the estimated error standard deviation,  and 
the Generalized Cross Validation criterion, for each value of the smoothing parameter specified in <code>lambda</code>.</p>
</td></tr>
<tr><td><code id="fdaPDE-deprecated_+3A_nderivs">nderivs</code></td>
<td>
<p>A vector of lenght 2 specifying the order of the partial derivatives of the bases to be evaluated. The vectors' entries can
be 0,1 or 2, where 0 indicates that only the basis functions, and not their derivatives, should be evaluated.</p>
</td></tr>
<tr><td><code id="fdaPDE-deprecated_+3A_fem">FEM</code></td>
<td>
<p>A <code>FEM</code> object to be evaluated</p>
</td></tr>
<tr><td><code id="fdaPDE-deprecated_+3A_bc">BC</code></td>
<td>
<p>A list with two vectors: 
<code>BC_indices</code>, a vector with the indices in <code>nodes</code> of boundary nodes where a Dirichlet Boundary Condition should be applied;
<code>BC_values</code>, a vector with the values that the spatial field must take at the nodes indicated in <code>BC_indices</code>.</p>
</td></tr>
<tr><td><code id="fdaPDE-deprecated_+3A_cpp_code">CPP_CODE</code></td>
<td>
<p>Boolean. If <code>TRUE</code> the computation relies on the C++ implementation of the algorithm. This usually ensures a much faster computation.</p>
</td></tr>
<tr><td><code id="fdaPDE-deprecated_+3A_pde_parameters">PDE_parameters</code></td>
<td>
<p>A list specifying the space-varying parameters of the elliptic PDE in the regularizing term: <code>K</code>, a function that for each spatial location in the spatial domain 
(indicated by the vector of the 2 spatial coordinates) returns a 2-by-2 matrix of diffusion coefficients. This induces an anisotropic 
smoothing with a local preferential direction that corresponds to the first eigenvector of the diffusion matrix K.The function must support recycling for efficiency reasons, thus if the input parameter is a #point-by-2 matrix, the output should be
an array with dimensions 2-by-2-by-#points.<code>b</code>, a function that for each spatial location in the spatial domain returns 
a vector of length 2 of transport coefficients. This induces a local smoothing only in the direction specified by the vector <code>b</code>. The function must support recycling for efficiency reasons, thus if the input parameter is a #point-by-2 matrix, the output should be
a matrix with dimensions 2-by-#points; <code>c</code>, a function that for each spatial location in the spatial domain  returns a scalar reaction coefficient.
<code>c</code> induces a shrinkage of the surface to zero. The function must support recycling for efficiency reasons, thus if the input parameter is a #point-by-2 matrix, the output should be
a vector with length #points; <code>u</code>, a function that for each spatial location in the spatial domain  returns a scalar reaction coefficient.
<code>u</code> induces a reaction effect. The function must support recycling for efficiency reasons, thus if the input parameter is a #point-by-2 matrix, the output should be
a vector with length #points.</p>
</td></tr>
<tr><td><code id="fdaPDE-deprecated_+3A_nodes">nodes</code></td>
<td>
<p>A #nodes-by-2 matrix containing the x and y coordinates of the mesh nodes.</p>
</td></tr>
<tr><td><code id="fdaPDE-deprecated_+3A_nodesattributes">nodesattributes</code></td>
<td>
<p>A matrix with #nodes rows containing nodes' attributes. 
These are passed unchanged to the output. If a node is added during the triangulation process or mesh refinement, its attributes are computed  
by linear interpolation using the attributes of neighboring nodes. This functionality is for instance used to compute the value 
of a Dirichlet boundary condition at boundary nodes added during the triangulation process.</p>
</td></tr>
<tr><td><code id="fdaPDE-deprecated_+3A_segments">segments</code></td>
<td>
<p>A #segments-by-2 matrix. Each row contains the row's indices in <code>nodes</code> of the vertices where the segment starts from and ends to.
Segments are edges that are not splitted during the triangulation process. These are for instance used to define the boundaries
of the domain. If this is input is NULL, it generates a triangulation over the
convex hull of the points specified in <code>nodes</code>.</p>
</td></tr>
<tr><td><code id="fdaPDE-deprecated_+3A_holes">holes</code></td>
<td>
<p>A #holes-by-2 matrix containing the x and y coordinates of a point internal to each hole of the mesh. These points are used to carve holes
in the triangulation, when the domain has holes.</p>
</td></tr>
<tr><td><code id="fdaPDE-deprecated_+3A_triangles">triangles</code></td>
<td>
<p>A #triangles-by-3 (when <code>order</code> = 1) or #triangles-by-6 (when <code>order</code> = 2) matrix.
This option is used when a triangulation is already available. It specifies the triangles giving the row's indices in <code>nodes</code> of the triangles' vertices and (when <code>nodes</code> = 2) also if the triangles' edges midpoints. The triangles' vertices and midpoints are ordered as described 
at <br /> https://www.cs.cmu.edu/~quake/triangle.highorder.html.
In this case the function <code>create.MESH.2D</code> is used to produce a complete MESH2D object.</p>
</td></tr>
<tr><td><code id="fdaPDE-deprecated_+3A_order">order</code></td>
<td>
<p>Either '1' or '2'. It specifies wether each mesh triangle should be represented by 3 nodes (the triangle' vertices) or by 6 nodes (the triangle's vertices and midpoints). 
These are
respectively used for linear (order = 1) and quadratic (order = 2) Finite Elements. Default is <code>order</code> = 1.</p>
</td></tr>
<tr><td><code id="fdaPDE-deprecated_+3A_verbosity">verbosity</code></td>
<td>
<p>This can be '0', '1' or '2'. It indicates the level of verbosity in the triangulation process.</p>
</td></tr>
<tr><td><code id="fdaPDE-deprecated_+3A_mesh">mesh</code></td>
<td>
<p>A MESH2D object representing the triangular mesh, created by <a href="#topic+create.MESH.2D">create.MESH.2D</a>.</p>
</td></tr>
<tr><td><code id="fdaPDE-deprecated_+3A_minimum_angle">minimum_angle</code></td>
<td>
<p>A scalar specifying a minimun value for the triangles angles.</p>
</td></tr>
<tr><td><code id="fdaPDE-deprecated_+3A_maximum_area">maximum_area</code></td>
<td>
<p>A scalar specifying a maximum value for the triangles areas.</p>
</td></tr>
<tr><td><code id="fdaPDE-deprecated_+3A_delaunay">delaunay</code></td>
<td>
<p>A boolean parameter indicating whether or not the output mesh should satisfy the Delaunay condition.</p>
</td></tr>
<tr><td><code id="fdaPDE-deprecated_+3A_x">x</code></td>
<td>
<p>A MESH2D object defining the triangular mesh, as generated by <code>create.Mesh.2D</code> or <code>refine.Mesh.2D</code>.</p>
</td></tr>
<tr><td><code id="fdaPDE-deprecated_+3A_...">...</code></td>
<td>
<p>Arguments representing graphical options to be passed to <a href="graphics.html#topic+par">par</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are Deprecated in this release of fdaPDE, they will be 
marked as Defunct and removed in a future version.
</p>


<h3>Value</h3>

<p>A square matrix with the integrals of all the basis' functions pairwise products.
The dimension of the matrix is equal to the number of the nodes of the mesh.
</p>
<p>A square matrix with the integrals of all the basis functions' gradients pairwise dot products.
The dimension of the matrix is equal to the number of the nodes of the mesh.
</p>
<p>A list with the following quantities:
</p>
<table role = "presentation">
<tr><td><code>fit.FEM</code></td>
<td>
<p>A <code>FEM</code> object that represents the fitted spatial field.</p>
</td></tr>
<tr><td><code>PDEmisfit.FEM</code></td>
<td>
<p>A <code>FEM</code> object that represents the Laplacian of the estimated spatial field.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>If covariates is not <code>NULL</code>, a vector of length #covariates with the regression coefficients associated with each covariate.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>If GCV is <code>TRUE</code>, a scalar or vector with the trace of the smoothing matrix for each value of the smoothing parameter specified in <code>lambda</code>.</p>
</td></tr>
<tr><td><code>stderr</code></td>
<td>
<p>If GCV is <code>TRUE</code>, a scalar or vector with the estimate of the standard deviation of the error for each value of the smoothing parameter specified in <code>lambda</code>.</p>
</td></tr>
<tr><td><code>GCV</code></td>
<td>
<p>If GCV is <code>TRUE</code>, a  scalar or vector with the value of the GCV criterion for each value of the smoothing parameter specified in <code>lambda</code>.</p>
</td></tr>
</table>
<p>A matrix of basis function values. Each row indicates the location where the evaluation has been taken, the column indicates the 
basis function evaluated
</p>
<p>A matrix of numeric evaluations of the <code>FEM</code> object. Each row indicates the location where the evaluation has been taken, the column indicates the 
function evaluated.
</p>
<p>A list with the following variables:
</p>

<dl>
<dt><code>fit.FEM</code></dt><dd><p>A <code>FEM</code> object that represents the fitted spatial field.</p>
</dd>
<dt><code>PDEmisfit.FEM</code></dt><dd><p>A <code>FEM</code> object that represents the Laplacian of the estimated spatial field.</p>
</dd>
<dt><code>solution</code></dt><dd><p>A list, note that all terms are matrices or row vectors: the <code>j</code>th column represents the vector of related to <code>lambda[j]</code> if <code>lambda.selection.criterion="grid"</code> and <code>lambda.selection.lossfunction="unused"</code>.
In all the other cases is returned just the column related to the best penalization parameter
</p>

<dl>
<dt><code>f</code></dt><dd><p>Matrix, estimate of function f, first half of solution vector</p>
</dd>
<dt><code>g</code></dt><dd><p>Matrix, second half of solution vector</p>
</dd>
<dt><code>z_hat</code></dt><dd><p>Matrix, prediction of the output in the locations</p>
</dd>
<dt><code>beta</code></dt><dd><p>If <code>covariates</code> is not <code>NULL</code>, a matrix with number of rows equal to the number of covariates and number of columns equal to length of lambda. It is the regression coefficients estimate</p>
</dd>
<dt><code>rmse</code></dt><dd><p>Estimate of the root mean square error in the locations</p>
</dd>
<dt><code>estimated_sd</code></dt><dd><p>Estiimate of the standard deviation of the error</p>
</dd>
</dl>

</dd>
<dt><code>optimization</code></dt><dd><p>A detailed list of optimization related data:
</p>

<dl>
<dt><code>lambda_solution</code></dt><dd><p>numerical value of best lambda acording to <code>lambda.selection.lossfunction</code>, -1 if <code>lambda.selection.lossfunction="unused"</code></p>
</dd>
<dt><code>lambda_position</code></dt><dd><p>integer, postion in <code>lambda_vector</code> of best lambda acording to <code>lambda.selection.lossfunction</code>, -1 if <code>lambda.selection.lossfunction="unused"</code></p>
</dd>
<dt><code>GCV</code></dt><dd><p>numeric value of GCV in correspondence of the optimum</p>
</dd>
<dt><code>optimization_details</code></dt><dd><p>list containing further information about the optimization method used and the nature of its termination, eventual number of iterations</p>
</dd>
<dt><code>dof</code></dt><dd><p>numeric vector, value of dof for all the penalizations it has been computed, empty if not computed</p>
</dd>
<dt><code>lambda_vector</code></dt><dd><p>numeric value of the penalization factors passed by the user or found in the iterations of the optimization method</p>
</dd>
<dt><code>GCV_vector</code></dt><dd><p>numeric vector, value of GCV for all the penalizations it has been computed</p>
</dd>
</dl>

</dd>
<dt><code>time</code></dt><dd><p>Duration of the entire optimization computation</p>
</dd>
<dt><code>bary.locations</code></dt><dd><p>A barycenter information of the given locations if the locations are not mesh nodes.</p>
</dd>
</dl>

<p>A list with the following variables:
</p>

<dl>
<dt><code>fit.FEM</code></dt><dd><p>A <code>FEM</code> object that represents the fitted spatial field.</p>
</dd>
<dt><code>PDEmisfit.FEM</code></dt><dd><p>A <code>FEM</code> object that represents the Laplacian of the estimated spatial field.</p>
</dd>
<dt><code>solution</code></dt><dd><p>A list, note that all terms are matrices or row vectors: the <code>j</code>th column represents the vector of related to <code>lambda[j]</code> if <code>lambda.selection.criterion="grid"</code> and <code>lambda.selection.lossfunction="unused"</code>.
In all the other cases is returned just the column related to the best penalization parameter
</p>

<dl>
<dt><code>f</code></dt><dd><p>Matrix, estimate of function f, first half of solution vector</p>
</dd>
<dt><code>g</code></dt><dd><p>Matrix, second half of solution vector</p>
</dd>
<dt><code>z_hat</code></dt><dd><p>Matrix, prediction of the output in the locations</p>
</dd>
<dt><code>beta</code></dt><dd><p>If <code>covariates</code> is not <code>NULL</code>, a matrix with number of rows equal to the number of covariates and number of columns equal to length of lambda. It is the regression coefficients estimate</p>
</dd>
<dt><code>rmse</code></dt><dd><p>Estimate of the root mean square error in the locations</p>
</dd>
<dt><code>estimated_sd</code></dt><dd><p>Estiimate of the standard deviation of the error</p>
</dd>
</dl>

</dd>
<dt><code>optimization</code></dt><dd><p>A detailed list of optimization related data:
</p>

<dl>
<dt><code>lambda_solution</code></dt><dd><p>numerical value of best lambda acording to <code>lambda.selection.lossfunction</code>, -1 if <code>lambda.selection.lossfunction="unused"</code></p>
</dd>
<dt><code>lambda_position</code></dt><dd><p>integer, postion in <code>lambda_vector</code> of best lambda acording to <code>lambda.selection.lossfunction</code>, -1 if <code>lambda.selection.lossfunction="unused"</code></p>
</dd>
<dt><code>GCV</code></dt><dd><p>numeric value of GCV in correspondence of the optimum</p>
</dd>
<dt><code>optimization_details</code></dt><dd><p>list containing further information about the optimization method used and the nature of its termination, eventual number of iterations</p>
</dd>
<dt><code>dof</code></dt><dd><p>numeric vector, value of dof for all the penalizations it has been computed, empty if not computed</p>
</dd>
<dt><code>lambda_vector</code></dt><dd><p>numeric value of the penalization factors passed by the user or found in the iterations of the optimization method</p>
</dd>
<dt><code>GCV_vector</code></dt><dd><p>numeric vector, value of GCV for all the penalizations it has been computed</p>
</dd>
</dl>

</dd>
<dt><code>time</code></dt><dd><p>Duration of the entire optimization computation</p>
</dd>
<dt><code>bary.locations</code></dt><dd><p>A barycenter information of the given locations if the locations are not mesh nodes.</p>
</dd>
</dl>

<p>A list with the following variables:
</p>

<dl>
<dt><code>fit.FEM</code></dt><dd><p>A <code>FEM</code> object that represents the fitted spatial field.</p>
</dd>
<dt><code>PDEmisfit.FEM</code></dt><dd><p>A <code>FEM</code> object that represents the Laplacian of the estimated spatial field.</p>
</dd>
<dt><code>solution</code></dt><dd><p>A list, note that all terms are matrices or row vectors: the <code>j</code>th column represents the vector of related to <code>lambda[j]</code> if <code>lambda.selection.criterion="grid"</code> and <code>lambda.selection.lossfunction="unused"</code>.
In all the other cases is returned just the column related to the best penalization parameter
</p>

<dl>
<dt><code>f</code></dt><dd><p>Matrix, estimate of function f, first half of solution vector</p>
</dd>
<dt><code>g</code></dt><dd><p>Matrix, second half of solution vector</p>
</dd>
<dt><code>z_hat</code></dt><dd><p>Matrix, prediction of the output in the locations</p>
</dd>
<dt><code>beta</code></dt><dd><p>If <code>covariates</code> is not <code>NULL</code>, a matrix with number of rows equal to the number of covariates and number of columns equal to length of lambda. It is the regression coefficients estimate</p>
</dd>
<dt><code>rmse</code></dt><dd><p>Estimate of the root mean square error in the locations</p>
</dd>
<dt><code>estimated_sd</code></dt><dd><p>Estiimate of the standard deviation of the error</p>
</dd>
</dl>

</dd>
<dt><code>optimization</code></dt><dd><p>A detailed list of optimization related data:
</p>

<dl>
<dt><code>lambda_solution</code></dt><dd><p>numerical value of best lambda acording to <code>lambda.selection.lossfunction</code>, -1 if <code>lambda.selection.lossfunction="unused"</code></p>
</dd>
<dt><code>lambda_position</code></dt><dd><p>integer, postion in <code>lambda_vector</code> of best lambda acording to <code>lambda.selection.lossfunction</code>, -1 if <code>lambda.selection.lossfunction="unused"</code></p>
</dd>
<dt><code>GCV</code></dt><dd><p>numeric value of GCV in correspondence of the optimum</p>
</dd>
<dt><code>optimization_details</code></dt><dd><p>list containing further information about the optimization method used and the nature of its termination, eventual number of iterations</p>
</dd>
<dt><code>dof</code></dt><dd><p>numeric vector, value of dof for all the penalizations it has been computed, empty if not computed</p>
</dd>
<dt><code>lambda_vector</code></dt><dd><p>numeric value of the penalization factors passed by the user or found in the iterations of the optimization method</p>
</dd>
<dt><code>GCV_vector</code></dt><dd><p>numeric vector, value of GCV for all the penalizations it has been computed</p>
</dd>
</dl>

</dd>
<dt><code>time</code></dt><dd><p>Duration of the entire optimization computation</p>
</dd>
<dt><code>bary.locations</code></dt><dd><p>A barycenter information of the given locations if the locations are not mesh nodes.</p>
</dd>
</dl>

<p>An object of the class MESH2D with the following output:
</p>
<table role = "presentation">
<tr><td><code>nodes</code></td>
<td>
<p>A #nodes-by-2 matrix containing the x and y coordinates of the mesh nodes.</p>
</td></tr>
<tr><td><code>nodesmarkers</code></td>
<td>
<p>A vector of length #nodes, with entries either '1' or '0'. An entry '1' indicates that the corresponding node is a boundary node; an entry '0' indicates that the corresponding node is not a boundary node.</p>
</td></tr>
<tr><td><code>nodesattributes</code></td>
<td>
<p>nodesattributes A matrix with #nodes rows containing nodes' attributes. 
These are passed unchanged to the output. If a node is added during the triangulation process or mesh refinement, its attributes are computed  
by linear interpolation using the attributes of neighboring nodes. This functionality is for instance used to compute the value 
of a Dirichlet boundary condition at boundary nodes added during the triangulation process.</p>
</td></tr>
<tr><td><code>triangles</code></td>
<td>
<p>A #triangles-by-3 (when <code>order</code> = 1) or #triangles-by-6 (when <code>order</code> = 2) matrix.
This option is used when a triangulation is already available. It specifies the triangles giving the indices in <code>nodes</code> of the triangles' vertices and (when <code>nodes</code> = 2) also if the triangles' edges midpoints. The triangles' vertices and midpoints are ordered as described 
at  <br /> https://www.cs.cmu.edu/~quake/triangle.highorder.html.</p>
</td></tr>
<tr><td><code>segmentsmarker</code></td>
<td>
<p>A vector of length #segments with entries either '1' or '0'. An entry '1' indicates that the corresponding element in <code>segments</code> is a boundary segment;  
an entry '0' indicates that the corresponding segment is not a boundary segment.</p>
</td></tr>
<tr><td><code>edges</code></td>
<td>
<p>A #edges-by-2 matrix containing all the edges of the triangles in the output triangulation. Each row contains the row's indices in <code>nodes</code>, indicating the nodes where the edge starts from and ends to.</p>
</td></tr>
<tr><td><code>edgesmarkers</code></td>
<td>
<p>A vector of lenght #edges with entries either '1' or '0'. An entry '1' indicates that the corresponding element in <code>edge</code> is a boundary edge;  
an entry '0' indicates that the corresponding edge is not a boundary edge.</p>
</td></tr>
<tr><td><code>neighbors</code></td>
<td>
<p>A #triangles-by-3 matrix. Each row contains the indices of the three neighbouring triangles. An entry '-1' indicates that 
one edge of the triangle is a boundary edge.</p>
</td></tr>
<tr><td><code>holes</code></td>
<td>
<p>A #holes-by-2 matrix containing the x and y coordinates of a point internal to each hole of the mesh. These points are used to carve holes
in the triangulation, when the domain has holes.</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p>Either '1' or '2'. It specifies wether each mesh triangle should be represented by 3 nodes (the triangle' vertices) or by 6 nodes (the triangle's vertices and midpoints). 
These are respectively used for linear (order = 1) and quadratic (order = 2) Finite Elements. Default is <code>order</code> = 1.</p>
</td></tr>
</table>
<p>A MESH2D object representing the refined triangular mesh,  with the following output:
</p>
<table role = "presentation">
<tr><td><code>nodes</code></td>
<td>
<p>A #nodes-by-2 matrix containing the x and y coordinates of the mesh nodes.</p>
</td></tr>
<tr><td><code>nodesmarkers</code></td>
<td>
<p>A vector of length #nodes, with entries either '1' or '0'. An entry '1' indicates that the corresponding node is a boundary node; an entry '0' indicates that the corresponding node is not a boundary node.</p>
</td></tr>
<tr><td><code>nodesattributes</code></td>
<td>
<p>nodesattributes A matrix with #nodes rows containing nodes' attributes. 
These are passed unchanged to the output. If a node is added during the triangulation process or mesh refinement, its attributes are computed  
by linear interpolation using the attributes of neighboring nodes. This functionality is for instance used to compute the value 
of a Dirichlet boundary condition at boundary nodes added during the triangulation process.</p>
</td></tr>
<tr><td><code>triangles</code></td>
<td>
<p>A #triangles-by-3 (when <code>order</code> = 1) or #triangles-by-6 (when <code>order</code> = 2) matrix.
This option is used when a triangulation is already available. It specifies the triangles giving the row's indices in <code>nodes</code> of the triangles' vertices and (when <code>nodes</code> = 2) also if the triangles' edges midpoints. The triangles' vertices and midpoints are ordered as described 
at <br />  https://www.cs.cmu.edu/~quake/triangle.highorder.html.</p>
</td></tr>
<tr><td><code>edges</code></td>
<td>
<p>A #edges-by-2 matrix. Each row contains the row's indices of the nodes where the edge starts from and ends to.</p>
</td></tr>
<tr><td><code>edgesmarkers</code></td>
<td>
<p>A vector of lenght #edges with entries either '1' or '0'. An entry '1' indicates that the corresponding element in <code>edge</code> is a boundary edge;  
an entry '0' indicates that the corresponding edge is not a boundary edge.</p>
</td></tr>
<tr><td><code>neighbors</code></td>
<td>
<p>A #triangles-by-3 matrix. Each row contains the indices of the three neighbouring triangles. An entry '-1' indicates that 
one edge of the triangle is a boundary edge.</p>
</td></tr>
<tr><td><code>holes</code></td>
<td>
<p>A #holes-by-2 matrix containing the x and y coordinates of a point internal to each hole of the mesh. These points are used to carve holes
in the triangulation, when the domain has holes.</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p>Either '1' or '2'. It specifies wether each mesh triangle should be represented by 3 nodes (the triangle' vertices) or by 6 nodes (the triangle's vertices and midpoints). 
These are respectively used for linear (order = 1) and quadratic (order = 2) Finite Elements. Default is <code>order</code> = 1.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+refine.MESH.2D">refine.MESH.2D</a></code>, <code><a href="#topic+create.FEM.basis">create.FEM.basis</a></code>
</p>
<p><code><a href="#topic+create.MESH.2D">create.MESH.2D</a></code>, <code><a href="#topic+create.FEM.basis">create.FEM.basis</a></code>
</p>

<hr>
<h2 id='FEM'>Define a surface or spatial field by a Finite Element basis expansion</h2><span id='topic+FEM'></span>

<h3>Description</h3>

<p>This function defines a FEM object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FEM(coeff,FEMbasis)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FEM_+3A_coeff">coeff</code></td>
<td>
<p>A vector or a matrix containing the coefficients for the Finite Element basis expansion. The number of rows
(or the vector's length) corresponds to the number of basis in <code>FEMbasis</code>.
The number of columns corresponds to the number of functions.</p>
</td></tr>
<tr><td><code id="FEM_+3A_fembasis">FEMbasis</code></td>
<td>
<p>A <code>FEMbasis</code> object defining the Finite Element basis, created by <a href="#topic+create.FEM.basis">create.FEM.basis</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>FEM</code> object. This contains a list with components <code>coeff</code> and <code>FEMbasis</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)
## Upload the horseshoe2D data
data(horseshoe2D)

## Create the 2D mesh
mesh = create.mesh.2D(nodes = rbind(horseshoe2D$boundary_nodes, horseshoe2D$locations), 
                      segments = horseshoe2D$boundary_segments)
## Create the FEM basis
FEMbasis = create.FEM.basis(mesh)
## Compute the coeff vector evaluating the desired function at the mesh nodes
## In this case we consider the fs.test() function introduced by Wood et al. 2008
coeff = fs.test(mesh$nodes[,1], mesh$nodes[,2])
## Create the FEM object
FEMfunction = FEM(coeff, FEMbasis)
## Plot it
plot(FEMfunction)
</code></pre>

<hr>
<h2 id='FEM.time'>Define a spatio-temporal field by a Finite Element basis expansion</h2><span id='topic+FEM.time'></span>

<h3>Description</h3>

<p>This function defines a FEM.time object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FEM.time(coeff,time_mesh,FEMbasis,FLAG_PARABOLIC=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FEM.time_+3A_coeff">coeff</code></td>
<td>
<p>A vector or a matrix containing the coefficients for the spatio-temporal basis expansion. The number of rows
(or the vector's length) corresponds to the number of basis in <code>FEMbasis</code> times the number of knots in <code>time_mesh</code>.</p>
</td></tr>
<tr><td><code id="FEM.time_+3A_time_mesh">time_mesh</code></td>
<td>
<p>A vector containing the b-splines knots for separable smoothing and the nodes for finite differences for parabolic smoothing</p>
</td></tr>
<tr><td><code id="FEM.time_+3A_fembasis">FEMbasis</code></td>
<td>
<p>A <code>FEMbasis</code> object defining the Finite Element basis, created by <a href="#topic+create.FEM.basis">create.FEM.basis</a>.</p>
</td></tr>
<tr><td><code id="FEM.time_+3A_flag_parabolic">FLAG_PARABOLIC</code></td>
<td>
<p>Boolean. If <code>TRUE</code> the coefficients are from parabolic smoothing, if <code>FALSE</code> the separable one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>FEM.time</code> object. This contains a list with components <code>coeff</code>, <code>mesh_time</code>, <code>FEMbasis</code> and <code>FLAG_PARABOLIC</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)
## Upload the horseshoe2D data
data(horseshoe2D)

## Create the 2D mesh
mesh = create.mesh.2D(nodes = rbind(horseshoe2D$boundary_nodes, horseshoe2D$locations), 
                      segments = horseshoe2D$boundary_segments)
## Create the FEM basis
FEMbasis = create.FEM.basis(mesh)
## Compute the coeff vector evaluating the desired function at the mesh nodes
## In this case we consider the fs.test() function introduced by Wood et al. 2008
coeff = rep(fs.test(mesh$nodes[,1], mesh$nodes[,2]),5)
time_mesh = seq(0,1,length.out = 5)
## Create the FEM object
FEMfunction = FEM.time(coeff, time_mesh, FEMbasis, FLAG_PARABOLIC = TRUE)
## Plot it at desired time
plot(FEMfunction,0.7)
</code></pre>

<hr>
<h2 id='FPCA.FEM'>Smooth Functional Principal Component Analysis</h2><span id='topic+FPCA.FEM'></span>

<h3>Description</h3>

<p>This function implements a smooth functional principal component analysis over a planar mesh,
a smooth manifold or a volume.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FPCA.FEM(locations = NULL, datamatrix, FEMbasis, lambda, nPC = 1, validation = NULL,
                NFolds = 5,GCVmethod = "Stochastic", nrealizations = 100, search = "tree",
                bary.locations = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FPCA.FEM_+3A_locations">locations</code></td>
<td>
<p>A #observations-by-2 matrix in the 2D case and #observations-by-3 matrix in the 2.5D and 3D case, where
each row specifies the spatial coordinates <code>x</code> and <code>y</code> (and <code>z</code> in 2.5D and 3D) of the corresponding
observation in the <code>datamatrix</code>.
If the locations of the observations coincide with (or are a subset of) the nodes of the mesh in the <code>FEMbasis</code>,
leave the parameter <code>locations = NULL</code> for a faster implementation.</p>
</td></tr>
<tr><td><code id="FPCA.FEM_+3A_datamatrix">datamatrix</code></td>
<td>
<p>A matrix of dimensions #samples-by-#locations with the observed data values over the domain
for each sample. The datamatrix needs to have zero mean.
If the <code>locations</code> argument is left <code>NULL</code> the datamatrix has to be dimensions #samples-by-#nodes where #nodes
is the number of nodes of the mesh in the FEMbasis. In this case, each observation is associated to the corresponding
node in the mesh.
If the data are observed only on a subset of the mesh nodes, fill with <code>NA</code> the values of the
<code>datamatrix</code> in correspondence of unobserved data.</p>
</td></tr>
<tr><td><code id="FPCA.FEM_+3A_fembasis">FEMbasis</code></td>
<td>
<p>A <code>FEMbasis</code> object describing the Finite Element basis, as created by <code><a href="#topic+create.FEM.basis">create.FEM.basis</a></code>.</p>
</td></tr>
<tr><td><code id="FPCA.FEM_+3A_lambda">lambda</code></td>
<td>
<p>A scalar or vector of smoothing parameters.</p>
</td></tr>
<tr><td><code id="FPCA.FEM_+3A_npc">nPC</code></td>
<td>
<p>An integer specifying the number of Principal Components to compute.</p>
</td></tr>
<tr><td><code id="FPCA.FEM_+3A_validation">validation</code></td>
<td>
<p>A string specifying the type of validation to perform. If <code>lambda</code> is a vector, it has to
be specified as <code>"GCV"</code> or <code>"KFold"</code>. This parameter specify which method of cross-validation is used
to select the best parameter <code>lambda</code> among those values of the smoothing parameter specified in <code>lambda</code>
for each Principal Component.</p>
</td></tr>
<tr><td><code id="FPCA.FEM_+3A_nfolds">NFolds</code></td>
<td>
<p>This parameter is used only in case <code>validation = "KFold"</code>. It is an integer specifying
the number of folds to use if the KFold cross-validation method for the
selection of the best parameter <code>lambda</code> is chosen. Default value is 5.</p>
</td></tr>
<tr><td><code id="FPCA.FEM_+3A_gcvmethod">GCVmethod</code></td>
<td>
<p>This parameter is considered only when <code>validation = "GCV"</code>. It can be either &quot;Exact&quot; or
&quot;Stochastic&quot;. If set to &quot;Exact&quot; the algoritm performs an exact (but possibly slow) computation
of the GCV index. If set to &quot;Stochastic&quot; the GCV is approximated by a stochastic algorithm.</p>
</td></tr>
<tr><td><code id="FPCA.FEM_+3A_nrealizations">nrealizations</code></td>
<td>
<p>The number of realizations to be used in the stochastic algorithm for the estimation of GCV.</p>
</td></tr>
<tr><td><code id="FPCA.FEM_+3A_search">search</code></td>
<td>
<p>a flag to decide the search algorithm type (tree or naive or walking search algorithm).</p>
</td></tr>
<tr><td><code id="FPCA.FEM_+3A_bary.locations">bary.locations</code></td>
<td>
<p>A list with three vectors:
<code>locations</code>, location points which are same as the given locations options. (checks whether both locations are the same);
<code>element ids</code>, a vector of element id of the points from the mesh where they are located;
<code>barycenters</code>, a vector of barycenter of points from the located element.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following variables:
</p>

<dl>
<dt><code>loadings.FEM</code></dt><dd><p>A <code>FEM</code> object that represents the L^2-normalized functional loadings for each
Principal Component computed.</p>
</dd>
<dt><code>scores</code></dt><dd><p>A #samples-by-#PrincipalComponents matrix that represents the unnormalized scores or PC vectors.</p>
</dd>
<dt><code>lambda</code></dt><dd><p>A vector of length #PrincipalComponents with the values of the smoothing parameter <code>lambda</code>
chosen for that Principal Component.</p>
</dd>
<dt><code>variance_explained</code></dt><dd><p>A vector of length #PrincipalComponents where each value represent the variance explained by that component.</p>
</dd>
<dt><code>cumsum_percentage</code></dt><dd><p>A vector of length #PrincipalComponents containing the cumulative percentage of the variance explained by the first components.</p>
</dd>
<dt><code>bary.locations</code></dt><dd><p>A barycenter information of the given locations if the locations are not mesh nodes.</p>
</dd>
</dl>



<h3>References</h3>

<p>Lila, E., Aston, J.A.D.,  Sangalli, L.M., 2016a. Smooth Principal Component Analysis over two-dimensional
manifolds with an application to neuroimaging. Ann. Appl. Stat., 10(4), pp. 1854-1879.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)

## Load the hub data
data(hub2.5D)
hub2.5D.nodes = hub2.5D$hub2.5D.nodes
hub2.5D.triangles = hub2.5D$hub2.5D.triangles

mesh = create.mesh.2.5D(nodes = hub2.5D.nodes, triangles = hub2.5D.triangles)
## Create the Finite Element basis
FEMbasis = create.FEM.basis(mesh)
## Create a datamatrix
datamatrix = NULL
for(ii in 1:50){
  a1 = rnorm(1, mean = 1, sd = 1)
  a2 = rnorm(1, mean = 1, sd = 1)
  a3 = rnorm(1, mean = 1, sd = 1)

  func_evaluation = numeric(nrow(mesh$nodes))
  for (i in 0:(nrow(mesh$nodes)-1)){
    func_evaluation[i+1] = a1* sin(2*pi*mesh$nodes[i+1,1]) +
                           a2* sin(2*pi*mesh$nodes[i+1,2]) +
                           a3*sin(2*pi*mesh$nodes[i+1,3]) + 1
  }
  data = func_evaluation + rnorm(nrow(mesh$nodes), mean = 0, sd = 0.5)
  datamatrix = rbind(datamatrix, data)
}
## Compute the mean of the datamatrix and subtract it to the data
data_bar = colMeans(datamatrix)
data_demean = matrix(rep(data_bar,50), nrow=50, byrow=TRUE)

datamatrix_demeaned = datamatrix - data_demean
## Set the smoothing parameter lambda
lambda = 0.00375
## Estimate the first 2 Principal Components
FPCA_solution = FPCA.FEM(datamatrix = datamatrix_demeaned,
                      FEMbasis = FEMbasis, lambda = lambda, nPC = 2)

## Plot the functional loadings of the estimated Principal Components
plot(FPCA_solution$loadings.FEM)
</code></pre>

<hr>
<h2 id='fs.test'>FELSPLINE test function</h2><span id='topic+fs.test'></span>

<h3>Description</h3>

<p>Implements a finite area test function based on one proposed by Tim Ramsay (2002) proposed by 
Simon Wood (2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fs.test(x, y, r0 = 0.1, r = 0.5, l = 3, b = 1, exclude = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fs.test_+3A_x">x</code>, <code id="fs.test_+3A_y">y</code></td>
<td>
<p>Points at which to evaluate the test function.</p>
</td></tr>
<tr><td><code id="fs.test_+3A_r0">r0</code></td>
<td>
<p>The test domain is a sort of bent sausage. This is the radius of the inner bend.</p>
</td></tr>
<tr><td><code id="fs.test_+3A_r">r</code></td>
<td>
<p>The radius of the curve at the centre of the sausage.</p>
</td></tr>
<tr><td><code id="fs.test_+3A_l">l</code></td>
<td>
<p>The length of an arm of the sausage.</p>
</td></tr>
<tr><td><code id="fs.test_+3A_b">b</code></td>
<td>
<p>The rate at which the function increases per unit increase in distance along the centre line of the sausage.</p>
</td></tr>
<tr><td><code id="fs.test_+3A_exclude">exclude</code></td>
<td>
<p>Should exterior points be set to NA?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns function evaluations, or NAs for points outside the horseshoe domain.
</p>


<h3>References</h3>


<ul>
<li><p>Ramsay, T. 2002. Spline smoothing over difficult regions. J.R.Statist. Soc. B 64(2):307-319
</p>
</li>
<li><p>Wood, S. N., Bravington, M. V., &amp; Hedley, S. L. (2008). Soap film smoothing. Journal of the Royal 
Statistical Society: Series B (Statistical Methodology), 70(5), 931-955.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)

## Upload the horseshoe2D data
data(horseshoe2D)
boundary_nodes = horseshoe2D$boundary_nodes
boundary_segments = horseshoe2D$boundary_segments
locations = horseshoe2D$locations

## Create the 2D mesh
mesh = create.mesh.2D(nodes = rbind(boundary_nodes, locations), segments = boundary_segments)
## Create the FEM basis
FEMbasis = create.FEM.basis(mesh)
## Compute the coeff vector evaluating the desired function at the mesh nodes
## In this case we consider the fs.test() function introduced by Wood et al. 2008
coeff = fs.test(mesh$nodes[,1], mesh$nodes[,2], exclude = FALSE)
## Create the FEM object
FEMfunction = FEM(coeff, FEMbasis)
## Plot it
plot(FEMfunction)
</code></pre>

<hr>
<h2 id='fs.test.3D'>FELSPLINE 3D test function</h2><span id='topic+fs.test.3D'></span>

<h3>Description</h3>

<p>Implements a finite area test function based on one proposed by Tim Ramsay (2002) and by 
Simon Wood (2008) in 3D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fs.test.3D(x, y, z, r0 = 0.25, r = 1.25, l = 5, b = 1, exclude = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fs.test.3D_+3A_x">x</code>, <code id="fs.test.3D_+3A_y">y</code>, <code id="fs.test.3D_+3A_z">z</code></td>
<td>
<p>Points at which to evaluate the test function.</p>
</td></tr>
<tr><td><code id="fs.test.3D_+3A_r0">r0</code></td>
<td>
<p>The test domain is a sort of bent sausage. This is the radius of the inner bend.</p>
</td></tr>
<tr><td><code id="fs.test.3D_+3A_r">r</code></td>
<td>
<p>The radius of the curve at the centre of the sausage.</p>
</td></tr>
<tr><td><code id="fs.test.3D_+3A_l">l</code></td>
<td>
<p>The length of an arm of the sausage.</p>
</td></tr>
<tr><td><code id="fs.test.3D_+3A_b">b</code></td>
<td>
<p>The rate at which the function increases per unit increase in distance along the centre line of the sausage.</p>
</td></tr>
<tr><td><code id="fs.test.3D_+3A_exclude">exclude</code></td>
<td>
<p>Should exterior points be set to NA?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns function evaluations, or NAs for points outside the horseshoe domain.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)

data(horseshoe2.5D)
mesh = horseshoe2.5D
FEMbasis=create.FEM.basis(mesh)

# Evaluation at nodes
sol_exact=fs.test.3D(mesh$nodes[,1],mesh$nodes[,3],mesh$nodes[,2])
plot(FEM(sol_exact, FEMbasis))
</code></pre>

<hr>
<h2 id='horseshoe2.5D'>Horseshoe2.5D domain</h2><span id='topic+horseshoe2.5D'></span>

<h3>Description</h3>

<p>A <code>mesh2.5D</code> object with nodes and connectivity matrix of a triangular mesh of the horseshoe 2.5D domain.
</p>

<hr>
<h2 id='horseshoe2D'>Horseshoe domain</h2><span id='topic+horseshoe2D'></span>

<h3>Description</h3>

<p>The boundary and interior nodes and connectivity matrix of a triangular mesh of the horseshoe domain. 
This dataset can be used to create a <code>mesh.2D</code> object with the function <code>create.mesh.2D</code>.
</p>

<hr>
<h2 id='hub2.5D'>Hub domain</h2><span id='topic+hub2.5D'></span>

<h3>Description</h3>

<p>The nodes and connectivity matrix of a triangular mesh of a manifold representing a hub geometry. 
This dataset can be used to create a <code>MESH.2.5D</code> object with the function <code>create.MESH.2.5D</code>.
</p>

<hr>
<h2 id='image.FEM'>Image Plot of a 2D FEM object</h2><span id='topic+image.FEM'></span>

<h3>Description</h3>

<p>Image plot of a <code>FEM</code> object, generated by the function <code>FEM</code> or returned by
<code>smooth.FEM</code> and <code>FPCA.FEM</code>. Only FEM objects defined over a 2D mesh can be plotted with this method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FEM'
image(x, num_refinements, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="image.FEM_+3A_x">x</code></td>
<td>
<p>A 2D-mesh <code>FEM</code> object.</p>
</td></tr>
<tr><td><code id="image.FEM_+3A_num_refinements">num_refinements</code></td>
<td>
<p>A natural number specifying how many bisections should by applied to each triangular element for
plotting purposes. This functionality is useful where a discretization with 2nd order Finite Element is applied.</p>
</td></tr>
<tr><td><code id="image.FEM_+3A_...">...</code></td>
<td>
<p>Arguments representing  graphical options to be passed to <a href="rgl.html#topic+plot3d">plot3d</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FEM">FEM</a></code> <code><a href="#topic+plot.FEM">plot.FEM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)
## Upload the horseshoe2D data
data(horseshoe2D)
boundary_nodes = horseshoe2D$boundary_nodes
boundary_segments = horseshoe2D$boundary_segments
locations = horseshoe2D$locations

## Create the 2D mesh
mesh = create.mesh.2D(nodes = rbind(boundary_nodes, locations), segments = boundary_segments)
## Create the FEM basis
FEMbasis = create.FEM.basis(mesh)
## Compute the coeff vector evaluating the desired function at the mesh nodes
## In this case we consider the fs.test() function introduced by Wood et al. 2008
coeff = fs.test(mesh$nodes[,1], mesh$nodes[,2])
## Create the FEM object
FEMfunction = FEM(coeff, FEMbasis)

## Plot the FEM function
image(FEMfunction)
</code></pre>

<hr>
<h2 id='image.FEM.time'>Image plot of a 2D FEM.time object at a given time</h2><span id='topic+image.FEM.time'></span>

<h3>Description</h3>

<p>Image plot of a <code>FEM.time</code> object, generated by the function <code>FEM.time</code> or returned by
<code>smooth.FEM.time</code>. Only FEM objects defined over a 2D mesh can be plotted with this method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FEM.time'
image(x,t,lambdaS=1,lambdaT=1,num_refinements=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="image.FEM.time_+3A_x">x</code></td>
<td>
<p>A 2D-mesh <code>FEM.time</code> object.</p>
</td></tr>
<tr><td><code id="image.FEM.time_+3A_t">t</code></td>
<td>
<p>time at which do the plot</p>
</td></tr>
<tr><td><code id="image.FEM.time_+3A_lambdas">lambdaS</code></td>
<td>
<p>index of the space penalization parameter to use for the plot, useful when <code>FEM.time</code> returned by <code>smooth.FEM.time</code> using GCV</p>
</td></tr>
<tr><td><code id="image.FEM.time_+3A_lambdat">lambdaT</code></td>
<td>
<p>index of the time penalization parameter to use for the plot, useful when <code>FEM.time</code> returned by <code>smooth.FEM.time</code> using GCV</p>
</td></tr>
<tr><td><code id="image.FEM.time_+3A_num_refinements">num_refinements</code></td>
<td>
<p>A natural number specifying how many bisections should by applied to each triangular element for
plotting purposes. This functionality is useful where a discretization with 2nd order Finite Element is applied.</p>
</td></tr>
<tr><td><code id="image.FEM.time_+3A_...">...</code></td>
<td>
<p>Arguments representing  graphical options to be passed to <a href="rgl.html#topic+plot3d">plot3d</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FEM.time">FEM.time</a></code> <code><a href="#topic+image.FEM.time">image.FEM.time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)
## Upload the horseshoe2D data
data(horseshoe2D)
boundary_nodes = horseshoe2D$boundary_nodes
boundary_segments = horseshoe2D$boundary_segments
locations = horseshoe2D$locations

## Create the 2D mesh
mesh = create.mesh.2D(nodes = rbind(boundary_nodes, locations), segments = boundary_segments)
## Create the FEM basis
FEMbasis = create.FEM.basis(mesh)
## Compute the coeff vector evaluating the desired function at the mesh nodes
## In this case we consider the fs.test() function introduced by Wood et al. 2008
time = 1:5
coeff = rep(fs.test(mesh$nodes[,1], mesh$nodes[,2]),5)*time
## Create the FEM.time object
FEM_time_function = FEM.time(coeff=coeff, time_mesh=1:5,FEMbasis=FEMbasis,FLAG_PARABOLIC=TRUE)

## Plot the FEM function
t = c(1.2,1.5,3.6,2.4,4.5)
image(FEM_time_function,t)
</code></pre>

<hr>
<h2 id='inferenceDataObject-class'>Class for inference data</h2><span id='topic+inferenceDataObject-class'></span><span id='topic+inferenceDataObject'></span>

<h3>Description</h3>

<p>A class that contains all possible information for inference over linear parameters and/or nonparametric field in spatial regression with
differential regularization problem. This object can be used as parameter in smoothing function of the fdaPDE library <code><a href="#topic+smooth.FEM">smooth.FEM</a></code>.
</p>


<h3>Details</h3>

<p>At least one between test and interval must be nonzero. <code>n_cov</code>, <code>coeff</code> and <code>beta0</code>, if provided, need to be coherent. 
<code>dim</code> and <code>locations</code>, if provided, need to be coherent.
The usage of <code><a href="#topic+inferenceDataObjectBuilder">inferenceDataObjectBuilder</a></code> is recommended for the construction of an object of this class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>test</code></dt><dd><p>A vector of integers taking value 0, 1 or 2; if 0 no test is performed, if 1 one-at-the-time tests are performed, if 2 a simultaneous test is performed.</p>
</dd>
<dt><code>interval</code></dt><dd><p>A vector of integers taking value 0, 1, 2 or 3; if 0 no confidence interval is computed, if 1 one-at-the-time confidence intervals are computed, 
if 2 simultaneous confidence intervals are computed, if 3 Bonferroni confidence intervals are computed.</p>
</dd>
<dt><code>type</code></dt><dd><p>A vector of integers taking value 1, 2, 3, 4 or 5 corresponding to Wald, Speckman, Eigen-Sign-Flip, Enhanced-Eigen-Sign-Flip or Sign-Flip inferential approach.</p>
</dd>
<dt><code>component</code></dt><dd><p>A vector of integers taking value 1, 2 or 3, indicating whether the inferential analysis should be carried out respectively for the parametric, nonparametric or both the components.</p>
</dd>
<dt><code>exact</code></dt><dd><p>An integer taking value 1 or 2. If 1 an exact computation of the test statistics will be performed,
whereas if 2 an approximated computation will be carried out (not implemented in this version).</p>
</dd>
<dt><code>dim</code></dt><dd><p>Dimension of the problem, it is equal to 2 in the 1.5D and 2D cases and equal to 3 in the 2.5D and 3D cases.</p>
</dd>
<dt><code>n_cov</code></dt><dd><p>Number of covariates taken into account in the linear part of the regression problem.</p>
</dd>
<dt><code>locations</code></dt><dd><p>A matrix of numeric coefficients with columns of dimension <code>dim</code>. When nonparametric inference is requested it represents the set of spatial locations for which the inferential analysis should be performed. 
The default values is a one-dimensional matrix of value 1 indicating that all the observed location points should be considered. 
In the sign-flip and eigen-sign-flip implementations only observed points are allowed.</p>
</dd>
<dt><code>locations_indices</code></dt><dd><p>A vector of indices indicating which spatial points have to be considered among the observed ones for nonparametric inference. If a vector of location indices is provided
then the slot 'location' is discarded.</p>
</dd>
<dt><code>locations_are_nodes</code></dt><dd><p>An integer taking value 1 or 2; in the first case it indicates that the selected locations to perform inference on f are all coinciding with the nodes; otherwise it takes value 2;</p>
</dd>
<dt><code>coeff</code></dt><dd><p>A matrix of numeric coefficients with columns of dimension <code>n_cov</code> and each row represents a linear combination of the linear parameters to be tested and/or to be
estimated via confidence interval.</p>
</dd>
<dt><code>beta0</code></dt><dd><p>Vector of null hypothesis values for the linear parameters of the model. Used only if <code>test</code> is not 0 and <code>component</code> is not 2.</p>
</dd>
<dt><code>f0</code></dt><dd><p>Function representing the expression of the nonparametric component f under the null hypothesis. Used only if <code>component</code> is not 1.</p>
</dd>
<dt><code>f0_eval</code></dt><dd><p>Vector of f0 evaluations at the chosen test locations. It will be eventually set later in checkInferenceParameters, if nonparametric inference is required.</p>
</dd>
<dt><code>f_var</code></dt><dd><p>An integer taking value 1 or 2. If 1 local variance estimates for the nonlinear part of the model will be computed,
whereas if 2 they will not.</p>
</dd>
<dt><code>quantile</code></dt><dd><p>Vector of quantiles needed for confidence intervals, used only if interval is not 0.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>1 minus confidence level vector of sign-flipping approaches confidence intervals. Used only if interval is not 0.</p>
</dd>
<dt><code>n_flip</code></dt><dd><p>An integer representing the number of sign-flips in the case of sign-flipping approaches.</p>
</dd>
<dt><code>tol_fspai</code></dt><dd><p>A real number greater than 0 specifying the tolerance for FSPAI algorithm, in case of non-exact inference (not implemented in this version).</p>
</dd>
<dt><code>definition</code></dt><dd><p>An integer taking value 0 or 1. If set to 1, the class will be considered as created by the function <code><a href="#topic+inferenceDataObjectBuilder">inferenceDataObjectBuilder</a></code>,
leading to avoid some of the checks that are performed on inference data within smoothing functions.</p>
</dd>
</dl>

<hr>
<h2 id='inferenceDataObjectBuilder'>Constructor for inferenceDataObject class</h2><span id='topic+inferenceDataObjectBuilder'></span>

<h3>Description</h3>

<p>A function that build an <code><a href="#topic+inferenceDataObject">inferenceDataObject</a></code>. In the process of construction many checks over the input parameters are carried out so that the output is a well defined object,
that can be used as parameter in <code><a href="#topic+smooth.FEM">smooth.FEM</a></code> or <code><a href="#topic+smooth.FEM.time">smooth.FEM.time</a></code> functions. Notice that this constructor ensures well-posedness of the object, but a further check on consistency with the smoothing functions parameters will be carried out.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inferenceDataObjectBuilder(test = NULL, 
interval = NULL, 
type = 'w', 
component = 'parametric',
dim = NULL, 
n_cov = NULL,
locations = NULL,
locations_indices = NULL,
locations_by_nodes = FALSE,
coeff = NULL, 
beta0 = NULL, 
f0 = NULL,
f_var = FALSE,
level = 0.95,
n_flip = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inferenceDataObjectBuilder_+3A_test">test</code></td>
<td>
<p>A string defining the type of test to be performed. Multiple tests can be required. In this case the length of the list needs to be coherent with the ones of <code>type</code>,
<code>component</code> and <code>interval</code>. The default is NULL, and can take values:
</p>

<dl>
<dt>'oat'</dt><dd><p>: one-at-the-time tests, available only when <code>component</code> is 'parametric'.</p>
</dd>
<dt>'sim'</dt><dd><p>: simultaneous tests.</p>
</dd>
<dt>'none'</dt><dd><p>: no test required. <code>interval</code> must be set.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="inferenceDataObjectBuilder_+3A_interval">interval</code></td>
<td>
<p>A string defining the type of confidence intervals to be computed. Multiple intervals can be required. In this case the length of the list needs to be coherent with the ones of <code>type</code>,
<code>component</code> and <code>test</code>. The default is NULL, and can take values:
</p>

<dl>
<dt>'oat'</dt><dd><p>: one-at-the-time intervals.</p>
</dd>
<dt>'sim'</dt><dd><p>: simultaneous intervals, available only when <code>component</code> is 'parametric' and no sign-flipping approaches are required.</p>
</dd>
<dt>'bonf'</dt><dd><p>: Bonferroni intervals, available only when <code>component</code> is 'parametric'</p>
</dd>
<dt>'none'</dt><dd><p>: no interval required. <code>test</code> must be set.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="inferenceDataObjectBuilder_+3A_type">type</code></td>
<td>
<p>A list of strings defining the type of implementation for the inferential analysis. The possible values are:
</p>

<dl>
<dt>'w'</dt><dd><p>: Wald parametric approach (default).</p>
</dd>
<dt>'s'</dt><dd><p>: Speckman parametric approach.</p>
</dd>
<dt>'sf'</dt><dd><p>: sign-flip nonparametric approach.</p>
</dd>
<dt>'esf'</dt><dd><p>: eigen-sign-flip nonparametric approach.</p>
</dd>
<dt>'enh-esf'</dt><dd><p>: enhanced-eigen-sign-flip nonparametric approach.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="inferenceDataObjectBuilder_+3A_component">component</code></td>
<td>
<p>A list of strings defining on which model component inference has to be performed. It can take values 'parametric' (default), 'nonparametric' or 'both'.</p>
</td></tr>
<tr><td><code id="inferenceDataObjectBuilder_+3A_dim">dim</code></td>
<td>
<p>Dimension of the problem, defaulted to NULL. It can take value 2 or 3 corresponding to 1.5D/2D or 2.5D/3D problems (Must be set by the user)</p>
</td></tr>
<tr><td><code id="inferenceDataObjectBuilder_+3A_n_cov">n_cov</code></td>
<td>
<p>Number of the covariates, defaulted to NULL. (Must be set by the user)</p>
</td></tr>
<tr><td><code id="inferenceDataObjectBuilder_+3A_locations">locations</code></td>
<td>
<p>A matrix of the locations of interest when testing the nonparametric component f, defaulted to NULL</p>
</td></tr>
<tr><td><code id="inferenceDataObjectBuilder_+3A_locations_indices">locations_indices</code></td>
<td>
<p>A vector of indices indicating the locations to be considered among the observed ones for nonparametric inference, defaulted to NULL.
If a vector of indices is provided, then the slot 'locations' is discarded.</p>
</td></tr>
<tr><td><code id="inferenceDataObjectBuilder_+3A_locations_by_nodes">locations_by_nodes</code></td>
<td>
<p>A logical used to indicate whether the selected locations to perform inference on f are all coinciding with the nodes;</p>
</td></tr>
<tr><td><code id="inferenceDataObjectBuilder_+3A_coeff">coeff</code></td>
<td>
<p>A matrix, with <code>n_cov</code> number of columns, of numeric coefficients representing the linear combinations of the parametric components of the model.
The default is NULL, corresponding to an identity matrix. If at least one sing-flipping approach is required in <code>type</code>, needs to be an identity matrix.</p>
</td></tr>
<tr><td><code id="inferenceDataObjectBuilder_+3A_beta0">beta0</code></td>
<td>
<p>Vector of real numbers (default NULL). It is used only if the <code>test</code> parameter is set, and <code>component</code> is not 'nonparametric'; its length is the number of rows of matrix <code>coeff</code> if provided. 
If <code>test</code> is set and <code>beta0</code> is NULL, will be set to a vector of zeros.</p>
</td></tr>
<tr><td><code id="inferenceDataObjectBuilder_+3A_f0">f0</code></td>
<td>
<p>A function object representing the expression of the nonparametric component f under the null hypothesis. Taken into account if <code>test</code> is set and <code>component</code> is not parametric.
If NULL, the default is the null function, hence a test on the significance of the nonparametric component is carried out.</p>
</td></tr>
<tr><td><code id="inferenceDataObjectBuilder_+3A_f_var">f_var</code></td>
<td>
<p>A logical used to decide whether to estimate the local variance of the nonlinear part of the model.
The possible values are: FALSE (default) and TRUE.</p>
</td></tr>
<tr><td><code id="inferenceDataObjectBuilder_+3A_level">level</code></td>
<td>
<p>A vector containing the level of significance used to compute quantiles for confidence intervals, defaulted to 0.95. It is taken into account only if <code>interval</code> is set.</p>
</td></tr>
<tr><td><code id="inferenceDataObjectBuilder_+3A_n_flip">n_flip</code></td>
<td>
<p>Number of flips performed in sign-flipping approaches, defaulted to 1000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a well defined <code><a href="#topic+inferenceDataObject">inferenceDataObject</a></code>, that can be used as input parameter in the <code><a href="#topic+smooth.FEM">smooth.FEM</a></code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obj&lt;-inferenceDataObjectBuilder(test = 'oat', dim = 2, beta0 = rep(1,4), n_cov = 4);
obj2&lt;-inferenceDataObjectBuilder(test = 'sim', dim = 3, component = 'nonparametric', n_cov = 3);
</code></pre>

<hr>
<h2 id='inferenceDataObjectTime-class'>Class for inference data in ST case</h2><span id='topic+inferenceDataObjectTime-class'></span><span id='topic+inferenceDataObjectTime'></span>

<h3>Description</h3>

<p>A class that contains all possible information for inference over linear parameters and/or nonparametric field in spatio-temporal regression with
differential regularization problem. This object can be used as parameter in smoothing function of the fdaPDE library <code><a href="#topic+smooth.FEM.time">smooth.FEM.time</a></code>.
</p>


<h3>Details</h3>

<p>At least one between test and interval must be nonzero. <code>n_cov</code>, <code>coeff</code> and <code>beta0</code>, if provided, need to be coherent. 
<code>dim</code> and <code>locations</code>, if provided, need to be coherent.
The usage of <code><a href="#topic+inferenceDataObjectTimeBuilder">inferenceDataObjectTimeBuilder</a></code> is recommended for the construction of an object of this class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>test</code></dt><dd><p>A vector of integers taking value 0, 1 or 2; if 0 no test is performed, if 1 one-at-the-time tests are performed, if 2 a simultaneous test is performed.</p>
</dd>
<dt><code>interval</code></dt><dd><p>A vector of integers taking value 0, 1, 2 or 3; if 0 no confidence interval is computed, if 1 one-at-the-time confidence intervals are computed, 
if 2 simultaneous confidence intervals are computed, if 3 Bonferroni confidence intervals are computed.</p>
</dd>
<dt><code>type</code></dt><dd><p>A vector of integers taking value 1, 2, 3 or 4 corresponding to Wald, Speckman, Eigen-Sign-Flip, Enhanced-Eigen-Sign-Flip inferential approach.</p>
</dd>
<dt><code>component</code></dt><dd><p>A vector of integers taking value 1, 2 or 3, indicating whether the inferential analysis should be carried out respectively for the parametric, nonparametric or both the components.</p>
</dd>
<dt><code>exact</code></dt><dd><p>An integer taking value 1 or 2. If 1 an exact computation of the test statistics will be performed,
whereas if 2 an approximated computation will be carried out (not implemented in this version).</p>
</dd>
<dt><code>dim</code></dt><dd><p>Dimension of the problem, it is equal to 2 in the 1.5D and 2D cases and equal to 3 in the 2.5D and 3D cases.</p>
</dd>
<dt><code>n_cov</code></dt><dd><p>Number of covariates taken into account in the linear part of the regression problem.</p>
</dd>
<dt><code>locations</code></dt><dd><p>A matrix of numeric coefficients with columns of dimension <code>dim</code>. When nonparametric inference is requested it represents the set of spatial locations for which the inferential analysis should be performed. 
The default values is a one-dimensional matrix of value 1 indicating that all the observed location points should be considered. 
In the sign-flip and eigen-sign-flip implementations only observed points are allowed.</p>
</dd>
<dt><code>locations_indices</code></dt><dd><p>A vector of indices indicating which spatial points have to be considered among the observed ones for nonparametric inference. If a vector of location indices is provided
then the slot 'location' is discarded.</p>
</dd>
<dt><code>locations_are_nodes</code></dt><dd><p>An integer taking value 1 or 2; in the first case it indicates that the selected locations to perform inference on f are all coinciding with the nodes; otherwise it takes value 2;</p>
</dd>
<dt><code>time_locations</code></dt><dd><p>A vector of numeric coefficients containing the set of times of interest for inference on the nonparametric component. This parameter can be <code>NULL</code>. 
In this case the temporal locations are assumed to coincide with the <code>time_locations</code> provided to the smoothing functions. Used only if <code>component</code> is not 1.</p>
</dd>
<dt><code>coeff</code></dt><dd><p>A matrix of numeric coefficients with columns of dimension <code>n_cov</code> and each row represents a linear combination of the linear parameters to be tested and/or to be
estimated via confidence interval.</p>
</dd>
<dt><code>beta0</code></dt><dd><p>Vector of null hypothesis values for the linear parameters of the model. Used only if <code>test</code> is not 0 and <code>component</code> is not 2.</p>
</dd>
<dt><code>f0</code></dt><dd><p>Function representing the expression of the nonparametric component f under the null hypothesis. Used only if <code>component</code> is not 1.</p>
</dd>
<dt><code>f0_eval</code></dt><dd><p>Matrix of f0 evaluations at the chosen space and time locations. It will be eventually set later in checkInferenceParametersTime, if nonparametric inference is required.</p>
</dd>
<dt><code>f_var</code></dt><dd><p>An integer taking value 1 or 2. If 1 local variance estimates for the nonlinear part of the model will be computed,
whereas if 2 they will not.</p>
</dd>
<dt><code>quantile</code></dt><dd><p>Vector of quantiles needed for confidence intervals, used only if interval is not 0.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>1 minus confidence level vector of sign-flipping approaches confidence intervals. Used only if interval is not 0.</p>
</dd>
<dt><code>n_flip</code></dt><dd><p>An integer representing the number of sign-flips in the case of sign-flipping approaches.</p>
</dd>
<dt><code>tol_fspai</code></dt><dd><p>A real number greater than 0 specifying the tolerance for FSPAI algorithm, in case of non-exact inference (not implemented in this version).</p>
</dd>
<dt><code>definition</code></dt><dd><p>An integer taking value 0 or 1. If set to 1, the class will be considered as created by the function <code><a href="#topic+inferenceDataObjectTimeBuilder">inferenceDataObjectTimeBuilder</a></code>,
leading to avoid some of the checks that are performed on inference data within smoothing functions.</p>
</dd>
</dl>

<hr>
<h2 id='inferenceDataObjectTimeBuilder'>Constructor for inferenceDataObjectTime class</h2><span id='topic+inferenceDataObjectTimeBuilder'></span>

<h3>Description</h3>

<p>A function that build an <code><a href="#topic+inferenceDataObjectTime">inferenceDataObjectTime</a></code>. In the process of construction many checks over the input parameters are carried out so that the output is a well defined object,
that can be used as parameter in <code><a href="#topic+smooth.FEM">smooth.FEM</a></code> or <code><a href="#topic+smooth.FEM.time">smooth.FEM.time</a></code> functions.
Notice that this constructor ensures well-posedness of the object, but a further check on consistency with the smoothing functions parameters will be carried out.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inferenceDataObjectTimeBuilder(test = NULL, 
interval = NULL, 
type = 'w', 
component = 'parametric',
dim = NULL, 
n_cov = NULL,
locations = NULL,
locations_indices = NULL,
locations_by_nodes = F,
time_locations = NULL,
coeff = NULL, 
beta0 = NULL, 
f0 = NULL,
f_var = F,
level = 0.95,
n_flip = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inferenceDataObjectTimeBuilder_+3A_test">test</code></td>
<td>
<p>A string defining the type of test to be performed. Multiple tests can be required. In this case the length of the list needs to be coherent with the ones of <code>type</code>,
<code>component</code> and <code>interval</code>. The default is NULL, and can take values:
</p>

<dl>
<dt>'oat'</dt><dd><p>: one-at-the-time tests, available only when <code>component</code> is 'parametric'.</p>
</dd>
<dt>'sim'</dt><dd><p>: simultaneous tests.</p>
</dd>
<dt>'none'</dt><dd><p>: no test required. <code>interval</code> must be set.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="inferenceDataObjectTimeBuilder_+3A_interval">interval</code></td>
<td>
<p>A string defining the type of confidence intervals to be computed. Multiple intervals can be required. In this case the length of the list needs to be coherent with the ones of <code>type</code>,
<code>component</code> and <code>test</code>. The default is NULL, and can take values:
</p>

<dl>
<dt>'oat'</dt><dd><p>: one-at-the-time intervals.</p>
</dd>
<dt>'sim'</dt><dd><p>: simultaneous intervals, available only when <code>component</code> is 'parametric' and no sign-flipping approaches are required.</p>
</dd>
<dt>'bonf'</dt><dd><p>: Bonferroni intervals, available only when <code>component</code> is 'parametric'</p>
</dd>
<dt>'none'</dt><dd><p>: no interval required. <code>test</code> must be set.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="inferenceDataObjectTimeBuilder_+3A_type">type</code></td>
<td>
<p>A list of strings defining the type of implementation for the inferential analysis. The possible values are:
</p>

<dl>
<dt>'w'</dt><dd><p>: Wald parametric approach (default).</p>
</dd>
<dt>'s'</dt><dd><p>: Speckman parametric approach, available only when <code>component</code> is 'parametric'.</p>
</dd>
<dt>'esf'</dt><dd><p>: eigen-sign-flip nonparametric approach, available only when <code>component</code> is 'parametric'.</p>
</dd>
<dt>'enh-esf'</dt><dd><p>: enhanced-eigen-sign-flip nonparametric approach, available only when <code>component</code> is 'parametric'.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="inferenceDataObjectTimeBuilder_+3A_component">component</code></td>
<td>
<p>A list of strings defining on which model component inference has to be performed. It can take values 'parametric' (default), 'nonparametric' or 'both'.</p>
</td></tr>
<tr><td><code id="inferenceDataObjectTimeBuilder_+3A_dim">dim</code></td>
<td>
<p>Dimension of the problem, defaulted to NULL. It can take value 2 or 3 corresponding to 1.5D/2D or 2.5D/3D problems (Must be set by the user)</p>
</td></tr>
<tr><td><code id="inferenceDataObjectTimeBuilder_+3A_n_cov">n_cov</code></td>
<td>
<p>Number of the covariates, defaulted to NULL. (Must be set by the user)</p>
</td></tr>
<tr><td><code id="inferenceDataObjectTimeBuilder_+3A_locations">locations</code></td>
<td>
<p>A matrix of the locations of interest when testing the nonparametric component f, defaulted to NULL.</p>
</td></tr>
<tr><td><code id="inferenceDataObjectTimeBuilder_+3A_locations_indices">locations_indices</code></td>
<td>
<p>A vector of indices indicating the locations to be considered among the observed ones for nonparametric inference, defaulted to NULL.
If a vector of indices is provided, then the slot 'locations' is discarded.</p>
</td></tr>
<tr><td><code id="inferenceDataObjectTimeBuilder_+3A_locations_by_nodes">locations_by_nodes</code></td>
<td>
<p>A logical used to indicate whether the selected locations to perform inference on f are all coinciding with the nodes.</p>
</td></tr>
<tr><td><code id="inferenceDataObjectTimeBuilder_+3A_time_locations">time_locations</code></td>
<td>
<p>A vector of times of interest when testing the nonparametric component f, defaulted to NULL. If <code>FLAG_parabolic = TRUE</code>, <code>time_locations</code> need to be NULL or to coincide with the time mesh.</p>
</td></tr>
<tr><td><code id="inferenceDataObjectTimeBuilder_+3A_coeff">coeff</code></td>
<td>
<p>A matrix, with <code>n_cov</code> number of columns, of numeric coefficients representing the linear combinations of the parametric components of the model.
The default is NULL, corresponding to an identity matrix. If at least one sing-flipping approach is required in <code>type</code>, needs to be an identity matrix.</p>
</td></tr>
<tr><td><code id="inferenceDataObjectTimeBuilder_+3A_beta0">beta0</code></td>
<td>
<p>Vector of real numbers (default NULL). It is used only if the <code>test</code> parameter is set, and <code>component</code> is not 'nonparametric'; its length is the number of rows of matrix <code>coeff</code> if provided. 
If <code>test</code> is set and <code>beta0</code> is NULL, will be set to a vector of zeros.</p>
</td></tr>
<tr><td><code id="inferenceDataObjectTimeBuilder_+3A_f0">f0</code></td>
<td>
<p>A function object representing the expression of the nonparametric component f under the null hypothesis. Taken into account if <code>test</code> is set and <code>component</code> is not parametric.
If NULL, the default is the null function, hence a test on the significance of the nonparametric component is carried out.</p>
</td></tr>
<tr><td><code id="inferenceDataObjectTimeBuilder_+3A_f_var">f_var</code></td>
<td>
<p>A logical used to decide whether to estimate the local variance of the nonlinear part of the model.
The possible values are: FALSE (default) and TRUE.</p>
</td></tr>
<tr><td><code id="inferenceDataObjectTimeBuilder_+3A_level">level</code></td>
<td>
<p>A vector containing the level of significance used to compute quantiles for confidence intervals, defaulted to 0.95. It is taken into account only if <code>interval</code> is set.</p>
</td></tr>
<tr><td><code id="inferenceDataObjectTimeBuilder_+3A_n_flip">n_flip</code></td>
<td>
<p>Number of flips performed in sign-flipping approaches, defaulted to 1000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a well defined <code><a href="#topic+inferenceDataObjectTime">inferenceDataObjectTime</a></code>, that can be used as input parameter in the <code><a href="#topic+smooth.FEM">smooth.FEM</a></code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obj&lt;-inferenceDataObjectTimeBuilder(test = 'oat', dim = 2, beta0 = rep(1,4), n_cov = 4);
obj2&lt;-inferenceDataObjectTimeBuilder(test = 'sim', dim = 3, component = 'nonparametric', n_cov = 3);
</code></pre>

<hr>
<h2 id='plot.FEM'>Plot a <code>FEM</code> object</h2><span id='topic+plot.FEM'></span>

<h3>Description</h3>

<p>Three-dimensional plot of a <code>FEM</code> object, generated by <code>FEM</code> or returned by
<code>smooth.FEM</code> or <code>FPCA.FEM</code>.
If the <code>mesh</code> of the <code>FEMbasis</code> component is of class <code>mesh.2D</code> both the 3rd axis and the color represent
the value of the coefficients for the Finite Element basis expansion (<code>coeff</code> component of the <code>FEM</code> object).
If the <code>mesh</code> is of class <code>mesh.3D</code>, the color of each triangle or tetrahedron represent the mean value of
the coefficients for the Finite Element basis expansion (<code>coeff</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FEM'
plot(x, colormap = "heat.colors", num_refinements = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.FEM_+3A_x">x</code></td>
<td>
<p>A <code>FEM</code> object.</p>
</td></tr>
<tr><td><code id="plot.FEM_+3A_colormap">colormap</code></td>
<td>
<p>A colormap exploited in the plot. The default value is the heat colormap.</p>
</td></tr>
<tr><td><code id="plot.FEM_+3A_num_refinements">num_refinements</code></td>
<td>
<p>A natural number specifying how many bisections should be applied to each triangular element for
plotting purposes. This functionality is useful where a discretization with 2nd order Finite Element is applied.
This parameter can be specified only when a FEM object defined over a 2D mesh is plotted.</p>
</td></tr>
<tr><td><code id="plot.FEM_+3A_...">...</code></td>
<td>
<p>Arguments representing graphical options to be passed to <a href="rgl.html#topic+plot3d">plot3d</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FEM">FEM</a></code>, <code><a href="#topic+image.FEM">image.FEM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)
## Upload the horseshoe2D data
data(horseshoe2D)
boundary_nodes = horseshoe2D$boundary_nodes
boundary_segments = horseshoe2D$boundary_segments
locations = horseshoe2D$locations

## Create the 2D mesh
mesh = create.mesh.2D(nodes = rbind(boundary_nodes, locations), segments = boundary_segments)
## Create the FEM basis
FEMbasis = create.FEM.basis(mesh)
## Compute the coeff vector evaluating the desired function at the mesh nodes
## In this case we consider the fs.test() function introduced by Wood et al. 2008
coeff = fs.test(mesh$nodes[,1], mesh$nodes[,2])
## Create the FEM object
FEMfunction = FEM(coeff, FEMbasis)

## Plot the FEM function
plot(FEMfunction)
</code></pre>

<hr>
<h2 id='plot.FEM.time'>Plot a <code>FEM.time</code> object at a given time</h2><span id='topic+plot.FEM.time'></span>

<h3>Description</h3>

<p>Plot of a <code>FEM.time</code> object, generated by <code>FEM.time</code> or returned by
<code>smooth.FEM.time</code>. <code>time_locations</code> and <code>locations</code> must not be both provided.
If <code>time_locations</code> is provided, the spatial field is plotted for the provided temporal instnts.
If <code>locations</code> is provided, the temporal evolution in the provided space locations is plotted.
If both <code>time_locations</code> and <code>locations</code> are NULL a default plot is provided.
If the <code>mesh</code> of the <code>FEMbasis</code> component is of class <code>mesh.2D</code> both the 3rd axis and the color represent
the value of the coefficients for the Finite Element basis expansion (<code>coeff</code> component of the <code>FEM.time</code> object).
If the <code>mesh</code> is of class <code>mesh.3D</code>, the color of each triangle or tetrahedron represent the mean value of
the coefficients for the Finite Element basis expansion (<code>coeff</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FEM.time'
plot(x, time_locations = NULL, locations = NULL,
                lambdaS = NULL, lambdaT = NULL, num_refinements = NULL, Nt = 100,
                add = FALSE, main = NULL, col = "red", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.FEM.time_+3A_x">x</code></td>
<td>
<p>A <code>FEM.time</code> object.</p>
</td></tr>
<tr><td><code id="plot.FEM.time_+3A_time_locations">time_locations</code></td>
<td>
<p>A vector with the instants in which plot the spatial field</p>
</td></tr>
<tr><td><code id="plot.FEM.time_+3A_locations">locations</code></td>
<td>
<p>A 2-column matrix when <code>x$FEMbasis$mesh</code> is of class <code>mesh.2D</code>
or a 3-column matrix otherwise with the spatial locations for which plot the temporal evolution</p>
</td></tr>
<tr><td><code id="plot.FEM.time_+3A_lambdas">lambdaS</code></td>
<td>
<p>Index of the space penalization parameter to use for the plot, useful when <code>FEM.time</code> returned by <code>smooth.FEM.time</code> using GCV</p>
</td></tr>
<tr><td><code id="plot.FEM.time_+3A_lambdat">lambdaT</code></td>
<td>
<p>Index of the time penalization parameter to use for the plot, useful when <code>FEM.time</code> returned by <code>smooth.FEM.time</code> using GCV</p>
</td></tr>
<tr><td><code id="plot.FEM.time_+3A_num_refinements">num_refinements</code></td>
<td>
<p>A natural number specifying how many bisections should be applied to each triangular element for
plotting purposes. This functionality is useful where a discretization with 2nd order Finite Element is applied.
This parameter can be specified only when a FEM object defined over a 2D mesh is plotted.</p>
</td></tr>
<tr><td><code id="plot.FEM.time_+3A_nt">Nt</code></td>
<td>
<p>The number of instants to plot when <code>locations</code> is not NULL</p>
</td></tr>
<tr><td><code id="plot.FEM.time_+3A_add">add</code></td>
<td>
<p>Boolean, used only when locations is not NULL, if TURE it performs the graphic over the last plot</p>
</td></tr>
<tr><td><code id="plot.FEM.time_+3A_main">main</code></td>
<td>
<p>The title of the plot when <code>locations</code> is not NULL</p>
</td></tr>
<tr><td><code id="plot.FEM.time_+3A_col">col</code></td>
<td>
<p>The color of the plot when <code>locations</code> is not NULL. May be a single color or a vector of colors</p>
</td></tr>
<tr><td><code id="plot.FEM.time_+3A_...">...</code></td>
<td>
<p>Arguments representing graphical options to be passed to <a href="rgl.html#topic+plot3d">plot3d</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FEM.time">FEM.time</a></code>, <code><a href="#topic+image.FEM.time">image.FEM.time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)
## Upload the horseshoe2D data
data(horseshoe2D)
boundary_nodes = horseshoe2D$boundary_nodes
boundary_segments = horseshoe2D$boundary_segments
locations = horseshoe2D$locations

## Create the 2D mesh
mesh = create.mesh.2D(nodes = rbind(boundary_nodes, locations), segments = boundary_segments)
## Create the FEM basis
FEMbasis = create.FEM.basis(mesh)
## Compute the coeff vector evaluating the desired function at the mesh nodes
## In this case we consider the fs.test() function introduced by Wood et al. 2008
time = 1:5
coeff = rep(fs.test(mesh$nodes[,1], mesh$nodes[,2]),5)*time
## Create the FEM.time object
FEM_time_function = FEM.time(coeff=coeff, time_mesh=1:5, FEMbasis=FEMbasis, FLAG_PARABOLIC=TRUE)

## Plot the FEM function
plot(FEM_time_function)

## plot spatial field in some instants
t = c(1.2,1.5,3.6,2.4,4.5)
plot(FEM_time_function, t)

## plot time evolution in some locations
plot(FEM_time_function, locations = locations[1:10,])
</code></pre>

<hr>
<h2 id='plot.mesh.1.5D'>Plot a mesh.1.5D object</h2><span id='topic+plot.mesh.1.5D'></span>

<h3>Description</h3>

<p>Plot a mesh.1.5D object, generated by <code>create.mesh.1.5D</code> or <code>refine.mesh.1.5D</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mesh.1.5D'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mesh.1.5D_+3A_x">x</code></td>
<td>
<p>A <code>mesh.1.5D</code> object defining the triangular mesh, as generated by <code>create.mesh.1.5D</code>
or <code>refine.mesh.1.5D</code>.</p>
</td></tr>
<tr><td><code id="plot.mesh.1.5D_+3A_...">...</code></td>
<td>
<p>Arguments representing graphical options to be passed to <a href="graphics.html#topic+par">par</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>

<hr>
<h2 id='plot.mesh.2.5D'>Plot a mesh.2.5D object</h2><span id='topic+plot.mesh.2.5D'></span>

<h3>Description</h3>

<p>Plot the triangulation of a <code>mesh.2.5D</code> object, generated by <code>create.mesh.2.5D</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mesh.2.5D'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mesh.2.5D_+3A_x">x</code></td>
<td>
<p>A <code>mesh.2.5D</code> object generated by <code>create.mesh.2.5D</code>.</p>
</td></tr>
<tr><td><code id="plot.mesh.2.5D_+3A_...">...</code></td>
<td>
<p>Arguments representing graphical options to be passed to <a href="graphics.html#topic+par">par</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)

## Upload the hub2.5D the data
data(hub2.5D)
hub2.5D.nodes = hub2.5D$hub2.5D.nodes
hub2.5D.triangles = hub2.5D$hub2.5D.triangles

## Create mesh
mesh = create.mesh.2.5D(nodes = hub2.5D.nodes, triangles = hub2.5D.triangles)
plot(mesh)
</code></pre>

<hr>
<h2 id='plot.mesh.2D'>Plot a mesh.2D object</h2><span id='topic+plot.mesh.2D'></span>

<h3>Description</h3>

<p>Plot a mesh.2D object, generated by <code>create.mesh.2D</code> or <code>refine.mesh.2D</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mesh.2D'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mesh.2D_+3A_x">x</code></td>
<td>
<p>A <code>mesh.2D</code> object defining the triangular mesh, as generated by <code>create.mesh.2D</code>
or <code>refine.mesh.2D</code>.</p>
</td></tr>
<tr><td><code id="plot.mesh.2D_+3A_...">...</code></td>
<td>
<p>Arguments representing graphical options to be passed to <a href="graphics.html#topic+par">par</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)

## Upload the quasicirle2D data
data(quasicircle2D)
boundary_nodes = quasicircle2D$boundary_nodes
boundary_segments = quasicircle2D$boundary_segments
locations = quasicircle2D$locations
data = quasicircle2D$data

## Create mesh
mesh = create.mesh.2D(nodes = rbind(boundary_nodes, locations), segments = boundary_segments)

## Plot the mesh
plot(mesh)
</code></pre>

<hr>
<h2 id='plot.mesh.3D'>Plot a mesh.3D object</h2><span id='topic+plot.mesh.3D'></span>

<h3>Description</h3>

<p>Plot a <code>mesh.3D</code> object, generated by <code>create.mesh.3D</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mesh.3D'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mesh.3D_+3A_x">x</code></td>
<td>
<p>A <code>mesh.3D</code> object generated by <code>create.mesh.3D</code>.</p>
</td></tr>
<tr><td><code id="plot.mesh.3D_+3A_...">...</code></td>
<td>
<p>Arguments representing graphical options to be passed to <a href="graphics.html#topic+par">par</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)

##Load the matrix nodes and tetrahedrons
data(sphere3Ddata)

nodes = sphere3Ddata$nodes
tetrahedrons = sphere3Ddata$tetrahedrons

##Create the triangulated mesh from the connectivity matrix and nodes locations
mesh = create.mesh.3D(nodes,tetrahedrons)

##Plot the triangulation of the object
plot(mesh)
</code></pre>

<hr>
<h2 id='projection.points.1.5D'>Project 2D points onto 1.5D linear network mesh</h2><span id='topic+projection.points.1.5D'></span>

<h3>Description</h3>

<p>This function projects any 2D points onto 1.5D linear network mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projection.points.1.5D(mesh, locations)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="projection.points.1.5D_+3A_mesh">mesh</code></td>
<td>
<p>A mesh.1.5D object representing the graph mesh, created by <a href="#topic+create.mesh.1.5D">create.mesh.1.5D</a>.</p>
</td></tr>
<tr><td><code id="projection.points.1.5D_+3A_locations">locations</code></td>
<td>
<p>2D points to be projected onto 1.5D mesh.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>2D points projected onto 1.5D linear network mesh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)
##Create Mesh

nodes=matrix(c(0.25,0.25,0.5,0.25,0.75,0.5,0.75,0.), nrow = 4, byrow=TRUE)
edges=matrix(c(1,2,2,3,2,4),nrow = 3,byrow = TRUE)
mesh_ = create.mesh.1.5D(nodes,edges,order=1)

## Create 2D points to be projected
locations=matrix(nrow=5,ncol=2)
locations[,1] = runif(5,min=0.25,max=0.75)
locations[,2] = runif(5,min=0.25,max=0.5)

## Project the points on the mesh
loc = projection.points.1.5D(mesh_, locations)
</code></pre>

<hr>
<h2 id='projection.points.2.5D'>Project 3D points onto 2D 2.5D triangular mesh</h2><span id='topic+projection.points.2.5D'></span>

<h3>Description</h3>

<p>This function projects any 3D points onto 2.5D triangular mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projection.points.2.5D(mesh, locations)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="projection.points.2.5D_+3A_mesh">mesh</code></td>
<td>
<p>A mesh.2.5D object representing the triangular mesh, created by <a href="#topic+create.mesh.2.5D">create.mesh.2.5D</a>.</p>
</td></tr>
<tr><td><code id="projection.points.2.5D_+3A_locations">locations</code></td>
<td>
<p>3D points to be projected onto 2.5D triangular mesh.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3D points projected onto 2.5D triangluar mesh.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)

## Upload the hub2.5D the data
data(hub2.5D)
hub2.5D.nodes = hub2.5D$hub2.5D.nodes
hub2.5D.triangles = hub2.5D$hub2.5D.triangles

## Create mesh
mesh = create.mesh.2.5D(nodes = hub2.5D.nodes, triangles = hub2.5D.triangles)

## Create 3D points to be projected
x &lt;- cos(seq(0,2*pi, length.out = 9))
y &lt;- sin(seq(0,2*pi, length.out = 9))
z &lt;- rep(0.5, 9)
locations = cbind(x,y,z)

## Project the points on the mesh
loc = projection.points.2.5D(mesh, locations)
</code></pre>

<hr>
<h2 id='quasicircle2D'>Quasicircle2D domain</h2><span id='topic+quasicircle2D'></span>

<h3>Description</h3>

<p>The boundary and interior nodes and connectivity matrix of a triangular mesh of a quasicircular domain, together 
with a non-stationary field observed over the nodes of the mesh.  
This dataset can be used to create a <code>mesh.2D</code> object with the function <code>create.mesh.2D</code> and to test
the smooth.FEM function.
</p>

<hr>
<h2 id='quasicircle2Dareal'>Quasicircle2Dareal domain</h2><span id='topic+quasicircle2Dareal'></span>

<h3>Description</h3>

<p>The mesh of a quasicircular domain, together with a non-stationary field observed over seven circular subdomains and 
the incindence matrix defining the subdomains used by Azzimonti et. al 2015.   
This dataset can be used to test the smooth.FEM function for areal data.
</p>


<h3>References</h3>

<p>Azzimonti, L., Sangalli, L. M., Secchi, P., Domanin, M., &amp; Nobile, F. (2015). Blood flow velocity 
field estimation via spatial regression with PDE penalization. Journal of the American Statistical 
Association, 110(511), 1057-1071.
</p>

<hr>
<h2 id='refine.by.splitting.mesh.1.5D'>Create a <code>mesh.1.5D</code> object by splitting each edge of a given mesh into two subedges.</h2><span id='topic+refine.by.splitting.mesh.1.5D'></span>

<h3>Description</h3>

<p>Create a <code>mesh.1.5D</code> object by splitting each edge of a given mesh into two subedges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refine.by.splitting.mesh.1.5D(mesh = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="refine.by.splitting.mesh.1.5D_+3A_mesh">mesh</code></td>
<td>
<p>a <code>mesh.1.5D</code> object to split</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class mesh.1.5D with splitted edges
</p>

<hr>
<h2 id='refine.by.splitting.mesh.2.5D'>Create a <code>mesh.2.5D</code> object by splitting each triangle of a given mesh into four subtriangles.</h2><span id='topic+refine.by.splitting.mesh.2.5D'></span>

<h3>Description</h3>

<p>Create a <code>mesh.2.5D</code> object by splitting each triangle of a given mesh into four subtriangles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refine.by.splitting.mesh.2.5D(mesh = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="refine.by.splitting.mesh.2.5D_+3A_mesh">mesh</code></td>
<td>
<p>a <code>mesh.2.5D</code> object to split</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class mesh.2.5D with splitted triangles
</p>

<hr>
<h2 id='refine.by.splitting.mesh.2D'>Create a <code>mesh.2D</code> object by splitting each triangle of a given mesh into four subtriangles.</h2><span id='topic+refine.by.splitting.mesh.2D'></span>

<h3>Description</h3>

<p>Create a <code>mesh.2D</code> object by splitting each triangle of a given mesh into four subtriangles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refine.by.splitting.mesh.2D(mesh = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="refine.by.splitting.mesh.2D_+3A_mesh">mesh</code></td>
<td>
<p>a <code>mesh.2D</code> object to split</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class mesh.2D with splitted triangles
</p>

<hr>
<h2 id='refine.by.splitting.mesh.3D'>Create a <code>mesh.3D</code> object by splitting each tetrahedron of a given mesh into eight subtetrahedrons.</h2><span id='topic+refine.by.splitting.mesh.3D'></span>

<h3>Description</h3>

<p>Create a <code>mesh.3D</code> object by splitting each tetrahedron of a given mesh into eight subtetrahedrons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refine.by.splitting.mesh.3D(mesh = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="refine.by.splitting.mesh.3D_+3A_mesh">mesh</code></td>
<td>
<p>a <code>mesh.3D</code> object to split</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class mesh.3D with splitted tetrahedrons
</p>

<hr>
<h2 id='refine.mesh.1.5D'>Refine 1.5D mesh</h2><span id='topic+refine.mesh.1.5D'></span>

<h3>Description</h3>

<p>Refine 1.5D mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refine.mesh.1.5D(mesh, delta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="refine.mesh.1.5D_+3A_mesh">mesh</code></td>
<td>
<p>a <code>mesh.1.5D</code> object to refine</p>
</td></tr>
<tr><td><code id="refine.mesh.1.5D_+3A_delta">delta</code></td>
<td>
<p>the maximum allowed length</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class mesh.1.5D with refined edges
</p>

<hr>
<h2 id='refine.mesh.2D'>Refine a 2D triangular mesh</h2><span id='topic+refine.mesh.2D'></span>

<h3>Description</h3>

<p>This function refines a Constrained Delaunay triangulation into a Conforming Delaunay triangulation. This is a wrapper of the Triangle library (http://www.cs.cmu.edu/~quake/triangle.html). It can be used to
refine a mesh previously created with <a href="#topic+create.mesh.2D">create.mesh.2D</a>. The algorithm can add Steiner points (points through which the <code>segments</code> are splitted)
in order to meet the imposed refinement conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refine.mesh.2D(mesh, minimum_angle, maximum_area, delaunay, verbosity)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="refine.mesh.2D_+3A_mesh">mesh</code></td>
<td>
<p>A mesh.2D object representing the triangular mesh, created by <a href="#topic+create.mesh.2D">create.mesh.2D</a>.</p>
</td></tr>
<tr><td><code id="refine.mesh.2D_+3A_minimum_angle">minimum_angle</code></td>
<td>
<p>A scalar specifying a minimun value for the triangles angles.</p>
</td></tr>
<tr><td><code id="refine.mesh.2D_+3A_maximum_area">maximum_area</code></td>
<td>
<p>A scalar specifying a maximum value for the triangles areas.</p>
</td></tr>
<tr><td><code id="refine.mesh.2D_+3A_delaunay">delaunay</code></td>
<td>
<p>A boolean parameter indicating whether or not the output mesh should satisfy the Delaunay condition.</p>
</td></tr>
<tr><td><code id="refine.mesh.2D_+3A_verbosity">verbosity</code></td>
<td>
<p>This can be '0', '1' or '2'. It indicates the level of verbosity in the triangulation process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mesh.2D object representing the refined triangular mesh,  with the following output:
</p>

<dl>
<dt><code>nodes</code></dt><dd><p>A #nodes-by-2 matrix containing the x and y coordinates of the mesh nodes.</p>
</dd>
<dt><code>nodesmarkers</code></dt><dd><p>A vector of length #nodes, with entries either '1' or '0'. An entry '1' indicates that the corresponding node is a boundary node; an entry '0' indicates that the corresponding node is not a boundary node.</p>
</dd>
<dt><code>nodesattributes</code></dt><dd><p>nodesattributes A matrix with #nodes rows containing nodes' attributes.
These are passed unchanged to the output. If a node is added during the triangulation process or mesh refinement, its attributes are computed
by linear interpolation using the attributes of neighboring nodes. This functionality is for instance used to compute the value
of a Dirichlet boundary condition at boundary nodes added during the triangulation process.</p>
</dd>
<dt><code>triangles</code></dt><dd><p>A #triangles-by-3 (when <code>order</code> = 1) or #triangles-by-6 (when <code>order</code> = 2) matrix.</p>
</dd>
<dt><code>edges</code></dt><dd><p>A #edges-by-2 matrix. Each row contains the row's indices of the nodes where the edge starts from and ends to.</p>
</dd>
<dt><code>edgesmarkers</code></dt><dd><p>A vector of lenght #edges with entries either '1' or '0'. An entry '1' indicates that the corresponding element in <code>edge</code> is a boundary edge;
an entry '0' indicates that the corresponding edge is not a boundary edge.</p>
</dd>
<dt><code>neighbors</code></dt><dd><p>A #triangles-by-3 matrix. Each row contains the indices of the three neighbouring triangles. An entry '-1' indicates that
one edge of the triangle is a boundary edge.</p>
</dd>
<dt><code>holes</code></dt><dd><p>A #holes-by-2 matrix containing the x and y coordinates of a point internal to each hole of the mesh. These points are used to carve holes
in the triangulation, when the domain has holes.</p>
</dd>
<dt><code>order</code></dt><dd><p>Either '1' or '2'. It specifies wether each mesh triangle should be represented by 3 nodes (the triangle' vertices) or by 6 nodes (the triangle's vertices and midpoints).
These are respectively used for linear (order = 1) and quadratic (order = 2) Finite Elements.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+create.mesh.2D">create.mesh.2D</a></code>, <code><a href="#topic+create.FEM.basis">create.FEM.basis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)

## Upload the quasicircle2D data
data(quasicircle2D)
boundary_nodes = quasicircle2D$boundary_nodes
boundary_segments = quasicircle2D$boundary_segments
locations = quasicircle2D$locations
data = quasicircle2D$data

## Create mesh from boundary:
mesh = create.mesh.2D(nodes = boundary_nodes, segments = boundary_segments)
plot(mesh)
## Refine the mesh with the maximum area criterion:
finemesh = refine.mesh.2D(mesh = mesh, maximum_area = 0.1)
plot(finemesh)
## Refine the mesh with the minimum angle criterion:
finemesh2 = refine.mesh.2D(mesh = mesh, minimum_angle = 30)
plot(finemesh2)
</code></pre>

<hr>
<h2 id='smooth.FEM'>Spatial regression with differential regularization</h2><span id='topic+smooth.FEM'></span>

<h3>Description</h3>

<p>This function implements a spatial regression model with differential regularization.
The regularizing term involves a Partial Differential Equation (PDE). In the simplest case the PDE involves only the
Laplacian of the spatial field, that induces an isotropic smoothing. When prior information about the anisotropy or
non-stationarity is available the PDE involves a general second order linear differential operator with possibly
space-varying coefficients. 
The technique accurately handle data distributed over irregularly shaped domains. Moreover, various conditions
can be imposed at the domain boundaries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth.FEM(locations = NULL, observations, FEMbasis,
 covariates = NULL, PDE_parameters = NULL, BC = NULL,
 incidence_matrix = NULL, areal.data.avg = TRUE,
 search = "tree", bary.locations = NULL,
 family = "gaussian", mu0 = NULL, scale.param = NULL, threshold.FPIRLS = 0.0002020, 
 max.steps.FPIRLS = 15, lambda.selection.criterion = "grid", DOF.evaluation = NULL, 
 lambda.selection.lossfunction = NULL, lambda = NULL, DOF.stochastic.realizations = 100,
 DOF.stochastic.seed = 0, DOF.matrix = NULL, GCV.inflation.factor = 1, 
 lambda.optimization.tolerance = 0.05,
 inference.data.object=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth.FEM_+3A_locations">locations</code></td>
<td>
<p>A #observations-by-2 matrix in the 2D case and #observations-by-3 matrix in the 2.5D and 3D case, where
each row specifies the spatial coordinates <code>x</code> and <code>y</code> (and <code>z</code> in 2.5D and 3D) of the corresponding
observation in the vector <code>observations</code>.
If the locations of the observations coincide with (or are a subset of) the nodes of the mesh in the <code>FEMbasis</code>,
leave the parameter <code>locations = NULL</code> for a faster implementation.</p>
</td></tr>
<tr><td><code id="smooth.FEM_+3A_observations">observations</code></td>
<td>
<p>A vector of length #observations with the observed data values over the domain.
If the <code>locations</code> argument is left NULL the vector of the observations have to be of length #nodes of the
mesh in the FEMbasis. In this case, each observation is associated to the corresponding node in the mesh.
If the observations are observed only on a subset of the mesh nodes, fill with <code>NA</code> the values of the vector
<code>observations</code> in correspondence of unobserved data.</p>
</td></tr>
<tr><td><code id="smooth.FEM_+3A_fembasis">FEMbasis</code></td>
<td>
<p>A <code>FEMbasis</code> object describing the Finite Element basis, as created by <code><a href="#topic+create.FEM.basis">create.FEM.basis</a></code>.</p>
</td></tr>
<tr><td><code id="smooth.FEM_+3A_covariates">covariates</code></td>
<td>
<p>A #observations-by-#covariates matrix where each row represents the covariates associated with
the corresponding observed data value in <code>observations</code> and each column is a different covariate.</p>
</td></tr>
<tr><td><code id="smooth.FEM_+3A_pde_parameters">PDE_parameters</code></td>
<td>
<p>A list specifying the parameters of the PDE in the regularizing term. Default is NULL, i.e.
regularization is by means of the Laplacian (stationary, isotropic case).
If the coefficients of the PDE are constant over the domain <code>PDE_parameters</code> must contain:
</p>

<ul>
<li><p><code>K</code>, a 2-by-2 matrix of diffusion coefficients. This induces an anisotropic
smoothing with a preferential direction that corresponds to the first eigenvector of the diffusion matrix K;
</p>
</li>
<li><p><code>b</code>, a vector of length 2 of advection coefficients. This induces a
smoothing only in the direction specified by the vector <code>b</code>;
</p>
</li>
<li><p><code>c</code>, a scalar reaction coefficient. <code>c</code> induces a shrinkage of the surface to zero.
</p>
</li></ul>

<p>If the coefficients of the PDE are space-varying <code>PDE_parameters</code> must contain:
</p>

<ul>
<li><p><code>K</code>, a function that for each spatial location in the spatial domain (indicated by the vector of the 2
spatial coordinates) returns a 2-by-2 matrix of diffusion coefficients. The function must support recycling for
efficiency reasons, thus if the input parameter is a #point-by-2 matrix, the output should be
an array with dimensions 2-by-2-by-#points.
</p>
</li>
<li><p><code>b</code>, a function that for each spatial location in the spatial domain returns
a vector of length 2 of transport coefficients. The function must support recycling for efficiency reasons, thus
if the input parameter is a #point-by-2 matrix, the output should be
a matrix with dimensions 2-by-#points;
</p>
</li>
<li><p><code>c</code>, a function that for each spatial location in the spatial domain  returns a scalar reaction coefficient.
The function must support recycling for efficiency reasons, thus if the input parameter is a #point-by-2 matrix, the output should be
a vector with length #points;
</p>
</li>
<li><p><code>u</code>, a function that for each spatial location in the spatial domain  returns a scalar reaction coefficient.
<code>u</code> induces a reaction effect. The function must support recycling for efficiency reasons, thus if the input
parameter is a #point-by-2 matrix, the output should be
a vector with length #points.
</p>
</li></ul>

<p>For 2.5D and 3D, only the Laplacian is available (<code>PDE_parameters=NULL</code>).</p>
</td></tr>
<tr><td><code id="smooth.FEM_+3A_bc">BC</code></td>
<td>
<p>A list with two vectors:
<code>BC_indices</code>, a vector with the indices in <code>nodes</code> of boundary nodes where a Dirichlet Boundary Condition should be applied;
<code>BC_values</code>, a vector with the values that the spatial field must take at the nodes indicated in <code>BC_indices</code>.</p>
</td></tr>
<tr><td><code id="smooth.FEM_+3A_incidence_matrix">incidence_matrix</code></td>
<td>
<p>A #regions-by-#triangles/tetrahedrons matrix where the element (i,j) equals 1 if the j-th
triangle/tetrahedron is in the i-th region and 0 otherwise.
This is needed only for areal data. In case of pointwise data, this parameter is set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="smooth.FEM_+3A_areal.data.avg">areal.data.avg</code></td>
<td>
<p>Boolean. It involves the computation of Areal Data. If <code>TRUE</code> the areal data are averaged, otherwise not.</p>
</td></tr>
<tr><td><code id="smooth.FEM_+3A_search">search</code></td>
<td>
<p>a flag to decide the search algorithm type (tree or naive or walking search algorithm).</p>
</td></tr>
<tr><td><code id="smooth.FEM_+3A_bary.locations">bary.locations</code></td>
<td>
<p>A list with three vectors:
<code>locations</code>, location points which are same as the given locations options. (checks whether both locations are the same);
<code>element ids</code>, a vector of element id of the points from the mesh where they are located;
<code>barycenters</code>, a vector of barycenter of points from the located element.</p>
</td></tr>
<tr><td><code id="smooth.FEM_+3A_family">family</code></td>
<td>
<p>This parameter specify the distibution within exponential family used for GLM model.
The following distribution are implemented: &quot;binomial&quot;, &quot;exponential&quot;, &quot;gamma&quot;, &quot;poisson&quot;, &quot;gaussian&quot;, &quot;invgaussian&quot;.
The default link function for binomial is <code>logit</code> if you want either <code>probit</code> or <code>clogloc</code> set <code>family = "probit"</code>, <code>family = "cloglog"</code>.</p>
</td></tr>
<tr><td><code id="smooth.FEM_+3A_mu0">mu0</code></td>
<td>
<p>This parameter is a vector that set the starting point for FPIRLS algorithm. It represent an initial guess of the location parameter.
Default is set to observation for non binary distribution while equal to <code>0.5(observations + 0.5)</code> for binary data.</p>
</td></tr>
<tr><td><code id="smooth.FEM_+3A_scale.param">scale.param</code></td>
<td>
<p>Dispersion parameter of the chosen distribution. This is only required for &quot;gamma&quot;, &quot;gaussian&quot;, &quot;invgaussian&quot;.
User may specify the parameter as a positive real number. If the parameter is not supplied, it is estimated from data according to Wilhelm Sangalli 2016.</p>
</td></tr>
<tr><td><code id="smooth.FEM_+3A_threshold.fpirls">threshold.FPIRLS</code></td>
<td>
<p>This parameter is used for arresting algorithm iterations. Algorithm stops when two successive iterations lead to improvement in penalized log-likelihood smaller than threshold.FPIRLS.
Default value <code>threshold.FPIRLS = 0.0002020</code>.</p>
</td></tr>
<tr><td><code id="smooth.FEM_+3A_max.steps.fpirls">max.steps.FPIRLS</code></td>
<td>
<p>This parameter is used to limit the maximum number of iteration.
Default value <code>max.steps.FPIRLS=15</code>.</p>
</td></tr>
<tr><td><code id="smooth.FEM_+3A_lambda.selection.criterion">lambda.selection.criterion</code></td>
<td>
<p>This parameter is used to select the optimization method for the smoothing parameter <code>lambda</code>.
The following methods are implemented: 'grid', 'newton', 'newton_fd'.
The former is a pure evaluation method. A test vector of <code>lambda</code> must be provided.
The remaining two are optimization methods that automatically select the best penalization according to <code>lambda.selection.lossfunction</code> criterion.
They implement respectively a pure Newton method and a finite differences Newton method.
Default value <code>lambda.selection.criterion='grid'</code></p>
</td></tr>
<tr><td><code id="smooth.FEM_+3A_dof.evaluation">DOF.evaluation</code></td>
<td>
<p>This parameter is used to identify if and how to perform degrees of freedom computation.
The following possibilities are allowed: NULL, 'exact' and 'stochastic'
In the former case no degree of freedom is computed, while the other two methods enable computation.
Stochastic computation of DOFs may be slightly less accurate than its deterministic counterpart, but it is fairly less time consuming. Stochastic evaluation is highly suggested for meshes with more than 5000 nodes.
Default value <code>DOF.evaluation=NULL</code></p>
</td></tr>
<tr><td><code id="smooth.FEM_+3A_lambda.selection.lossfunction">lambda.selection.lossfunction</code></td>
<td>
<p>This parameter is used to determine if some loss function has to be evaluated.
The following possibilities are allowed: NULL and 'GCV' (generalized cross validation)
If NULL is selected, <code>lambda.selection.criterion='grid'</code> is required. 'GCV' is employed for both <code>lambda.selection.criterion='grid'</code> and optimization methods.
Default value <code>lambda.selection.lossfunction=NULL</code></p>
</td></tr>
<tr><td><code id="smooth.FEM_+3A_lambda">lambda</code></td>
<td>
<p>a vector of spatial smoothing parameters provided if <code>lambda.selection.criterion='grid'</code>. An optional initialization otherwise.</p>
</td></tr>
<tr><td><code id="smooth.FEM_+3A_dof.stochastic.realizations">DOF.stochastic.realizations</code></td>
<td>
<p>This positive integer is considered only when <code>DOF.evaluation = 'stochastic'</code>.
It is the number of uniform random variables used in stochastic DOF evaluation.
Default value <code>DOF.stochastic.realizations=100</code>.</p>
</td></tr>
<tr><td><code id="smooth.FEM_+3A_dof.stochastic.seed">DOF.stochastic.seed</code></td>
<td>
<p>This positive integer is considered only when <code>DOF.evaluation = 'stochastic'</code>.
It is a user defined seed employed in stochastic DOF evaluation.
Default value <code>DOF.stochastic.seed = 0</code> means random.</p>
</td></tr>
<tr><td><code id="smooth.FEM_+3A_dof.matrix">DOF.matrix</code></td>
<td>
<p>Matrix of degrees of freedom. This parameter can be used if the DOF.matrix corresponding to <code>lambda</code> is available from precedent computation. This allows to save time,
since the computation of the DOFs is the most time consuming part of GCV evaluation.</p>
</td></tr>
<tr><td><code id="smooth.FEM_+3A_gcv.inflation.factor">GCV.inflation.factor</code></td>
<td>
<p>Tuning parameter used for the estimation of GCV. Default value <code>GCV.inflation.factor = 1.0</code> or <code>1.8</code> in GAM.
It is advised to set <code>GCV.inflation.factor</code> larger than 1 to avoid overfitting.</p>
</td></tr>
<tr><td><code id="smooth.FEM_+3A_lambda.optimization.tolerance">lambda.optimization.tolerance</code></td>
<td>
<p>Tolerance parameter, a double between 0 and 1 that fixes how much precision is required by the optimization method: the smaller the parameter, the higher the accuracy.
Used only if <code>lambda.selection.criterion='newton'</code> or <code>lambda.selection.criterion='newton_fd'</code>.
Default value <code>lambda.optimization.tolerance=0.05</code>.</p>
</td></tr>
<tr><td><code id="smooth.FEM_+3A_inference.data.object">inference.data.object</code></td>
<td>
<p>An <code><a href="#topic+inferenceDataObject">inferenceDataObject</a></code> that stores all the information regarding inference over the linear and nonlinear parameters of the model. This parameter needs to be 
consistent with <code>covariates</code>, otherwise will be discarded. If set and well defined, the function will have in output the inference results. It is suggested to create this object via <code><a href="#topic+inferenceDataObjectBuilder">inferenceDataObjectBuilder</a></code> function, so that the object is guaranteed to be well defined.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following variables:
</p>

<dl>
<dt><code>fit.FEM</code></dt><dd><p>A <code>FEM</code> object that represents the fitted spatial field.</p>
</dd>
<dt><code>PDEmisfit.FEM</code></dt><dd><p>A <code>FEM</code> object that represents the Laplacian of the estimated spatial field.</p>
</dd>
<dt><code>solution</code></dt><dd><p>A list, note that all terms are matrices or row vectors: the <code>j</code>th column represents the vector related to <code>lambda[j]</code> if <code>lambda.selection.criterion="grid"</code> and <code>lambda.selection.lossfunction=NULL</code>.</p>
</dd>
</dl>
<p>In all the other cases, only the column related to the best smoothing parameter is returned.
</p>
<dl>
<dt><code>f</code></dt><dd><p>Matrix, estimate of function f, first half of solution vector.</p>
</dd>
<dt><code>g</code></dt><dd><p>Matrix, second half of solution vector.</p>
</dd>
<dt><code>z_hat</code></dt><dd><p>Matrix, prediction of the output in the locations.</p>
</dd>
<dt><code>beta</code></dt><dd><p>If <code>covariates</code> is not <code>NULL</code>, a matrix with number of rows equal to the number of covariates and number of columns equal to length of lambda. It is the regression coefficients estimate.</p>
</dd>
<dt><code>rmse</code></dt><dd><p>Estimate of the root mean square error in the locations.</p>
</dd>
<dt><code>estimated_sd</code></dt><dd><p>Estimate of the standard deviation of the error.</p>
</dd>
<dt><code>optimization</code></dt><dd><p>A detailed list of optimization related data:
</p>

<dl>
<dt><code>lambda_solution</code></dt><dd><p>numerical value of best lambda according to <code>lambda.selection.lossfunction</code>, -1 if <code>lambda.selection.lossfunction=NULL</code>.</p>
</dd>
<dt><code>lambda_position</code></dt><dd><p>integer, position in <code>lambda_vector</code> of best lambda according to
<code>lambda.selection.lossfunction</code>, -1 if <code>lambda.selection.lossfunction=NULL</code>.</p>
</dd>
<dt><code>GCV</code></dt><dd><p>numeric value of GCV in correspondence of the optimum.</p>
</dd>
<dt><code>optimization_details</code></dt><dd><p>list containing further information about the optimization method used and the nature of its termination, eventual number of iterations.</p>
</dd>
<dt><code>dof</code></dt><dd><p>vector of positive numbers, DOFs for all the lambdas in <code>lambda_vector</code>, empty or invalid if not computed.</p>
</dd>
<dt><code>lambda_vector</code></dt><dd><p>vector of positive numbers: penalizations either passed by the user or found in the iterations of the optimization method.</p>
</dd>
<dt><code>GCV_vector</code></dt><dd><p>vector of positive numbers, GCV values for all the lambdas in <code>lambda_vector</code></p>
</dd>
</dl>

</dd>
<dt><code>time</code></dt><dd><p>Duration of the entire optimization computation.</p>
</dd>
<dt><code>bary.locations</code></dt><dd><p>Barycenter information of the given locations, if the locations are not mesh nodes.</p>
</dd>
<dt><code>GAM_output</code></dt><dd><p>A list of GAM related data:
</p>

<dl>
<dt><code>fn_hat</code></dt><dd><p>A matrix with number of rows equal to number of locations and number of columns equal to length of lambda. Each column contains the evaluaton of the spatial field in the location points.</p>
</dd>
<dt><code>J_minima</code></dt><dd><p>A vector of the same length of lambda, containing the reached minima for each value of the smoothing parameter.</p>
</dd>
<dt><code>variance.est</code></dt><dd><p>A vector which returns the variance estimates for the Generative Additive Models.</p>
</dd>
</dl>

</dd>
<dt><code>inference</code></dt><dd><p>A list set only if a well defined <code><a href="#topic+inferenceDataObject">inferenceDataObject</a></code> is passed as parameter to the function; contains all inference outputs required:
</p>

<dl>
<dt><code>p_values</code></dt><dd><p>list of lists set only if at least one p-value is required; contains the p-values divided by implementation:
</p>

<dl>
<dt><code>wald</code></dt><dd><p>list containing all the Wald p-values required, in the same order of the  <code>type</code> list in <code>inference.data.object</code>. 
If one-at-the-time tests are required, the corresponding item is a vector of p values ordered as the rows of <code>coeff</code> matrix in <code>inference.data.object</code>.
</p>
</dd>
<dt><code>speckman</code></dt><dd><p>list containing all the Speckman p-values required, in the same order of the  <code>type</code> list in  <code>inference.data.object</code>. 
If one-at-the-time tests are required, the corresponding item is a vector of p values ordered as the rows of <code>coeff</code> matrix in <code>inference.data.object</code>.
</p>
</dd>
<dt><code>eigen_sign_flip</code></dt><dd><p>list containing all the Eigen-Sign-Flip p-values required, in the same order of the <code>type</code> list in <code>inference.data.object</code>. 
If one-at-the-time tests are required, the corresponding item is a vector of p values ordered as the rows of <code>coeff</code> matrix in <code>inference.data.object</code>. 
</p>
</dd>
</dl>

</dd>
<dt><code>CI</code></dt><dd><p>list of lists set only if at least one confidence interval is required; contains the confidence intervals divided by implementation:
</p>

<dl>
<dt><code>wald</code></dt><dd><p>list containing all the Wald confidence intervals required, in the same order of the  <code>type</code> list in <code>inference.data.object</code>.
Each item is a matrix with 3 columns and p rows, p being the number of rows of <code>coeff</code> matrix in <code>inference.data.object</code>; each row is the CI for the corresponding row of <code>coeff</code> matrix. 
</p>
</dd>
<dt><code>speckman</code></dt><dd><p>list containing all the Speckman confidence intervals required, in the same order of the  <code>type</code> list in <code>inference.data.object</code>.
Each item is a matrix with 3 columns and p rows, p being the number of rows of <code>coeff</code> matrix in <code>inference.data.object</code>; each row is the CI for the corresponding row of <code>coeff</code> matrix.
</p>
</dd>
</dl>

</dd>
</dl>

</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Sangalli, L. M., Ramsay, J. O., Ramsay, T. O. (2013). Spatial spline regression models.
Journal of the Royal Statistical Society: Series B (Statistical Methodology), 75(4), 681-703.
</p>
</li>
<li><p> Azzimonti, L., Sangalli, L. M., Secchi, P., Domanin, M., Nobile, F. (2015). Blood flow velocity field estimation
via spatial regression with PDE penalization. Journal of the American Statistical Association, 110(511), 1057-1071.
</p>
</li>
<li><p> Matthieu Wilhelm &amp; Laura M. Sangalli (2016). Generalized spatial regression with differential regularization.
Journal of Statistical Computation and Simulation, 86:13, 2497-2518.
</p>
</li>
<li><p> Federico Ferraccioli, Laura M. Sangalli &amp; Livio Finos (2022). Some first inferential tools for spatial regression
with differential regularization. Journal of Multivariate Analysis, 189, 104866.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)

#### No prior information about anysotropy/non-stationarity (laplacian smoothing) ####
data(horseshoe2D)
boundary_nodes = horseshoe2D$boundary_nodes
boundary_segments = horseshoe2D$boundary_segments
locations = horseshoe2D$locations

mesh = create.mesh.2D(nodes = rbind(boundary_nodes, locations), segments = boundary_segments)
FEMbasis = create.FEM.basis(mesh)
lambda = 10^-1
# no covariate
data = fs.test(mesh$nodes[,1], mesh$nodes[,2]) + rnorm(nrow(mesh$nodes), sd = 0.5)

solution = smooth.FEM(observations = data, FEMbasis = FEMbasis, lambda = lambda)
plot(solution$fit.FEM)

# with covariates
covariate = covs.test(mesh$nodes[,1], mesh$nodes[,2])
data = fs.test(mesh$nodes[,1], mesh$nodes[,2]) + 2*covariate + rnorm(nrow(mesh$nodes), sd = 0.5)

#Inferential tests and confidence intervals
inference.data.object = inferenceDataObjectBuilder(test = 'oat', type = 'w', dim = 2, n_cov = 1)

solution = smooth.FEM(observations = data, covariates = covariate, 
                      FEMbasis = FEMbasis, lambda = lambda,
                      inference.data.object=inference.data.object)

# beta estimate:
solution$solution$beta
# tests over beta estimates p-values:
solution$inference$beta$p_values
# confidence intervals for beta estimates:
solution$inference$beta$CI
# non-parametric estimate:
plot(solution$fit.FEM)

# Choose lambda with GCV - stochastic grid evaluation:
lambda = 10^(-2:0)
solution = smooth.FEM(observations = data,
                            covariates = covariate,
                            FEMbasis = FEMbasis,
                            lambda = lambda, DOF.evaluation = 'stochastic', 
                            lambda.selection.lossfunction = 'GCV')
bestLambda = solution$optimization$lambda_solution
# Choose lambda with GCV - Newton finite differences stochastic evaluation -:
solution = smooth.FEM(observations = data,
                            covariates = covariate,
                            FEMbasis = FEMbasis,
                            DOF.evaluation = 'stochastic', lambda.selection.lossfunction = 'GCV')
bestLambda = solution$optimization$lambda_solution


#### Smoothing with prior information about anysotropy/non-stationarity and boundary conditions ####
# See Azzimonti et al. for reference to the current example
data(quasicircle2D)
boundary_nodes = quasicircle2D$boundary_nodes
boundary_segments = quasicircle2D$boundary_segments
locations = quasicircle2D$locations
data = quasicircle2D$data

mesh = create.mesh.2D(nodes = rbind(boundary_nodes, locations), segments = boundary_segments)
FEMbasis = create.FEM.basis(mesh)
lambda = 10^-2

# Set the PDE parameters
R = 2.8
K1 = 0.1
K2 = 0.2
beta = 0.5
K_func&lt;-function(points)
{
  output = array(0, c(2, 2, nrow(points)))
  for (i in 1:nrow(points))
    output[,,i]=10*rbind(c(points[i,2]^2+K1*points[i,1]^2+K2*(R^2-points[i,1]^2-points[i,2]^2),
                           (K1-1)*points[i,1]*points[i,2]),
                         c((K1-1)*points[i,1]*points[i,2],
                           points[i,1]^2+K1*points[i,2]^2+K2*(R^2-points[i,1]^2-points[i,2]^2)))
  output
}

b_func&lt;-function(points)
{
  output = array(0, c(2, nrow(points)))
  for (i in 1:nrow(points))
    output[,i] = 10*beta*c(points[i,1],points[i,2])
  output
}

c_func&lt;-function(points)
{
  rep(c(0), nrow(points))
}

u_func&lt;-function(points)
{
  rep(c(0), nrow(points))
}
PDE_parameters = list(K = K_func, b = b_func, c = c_func, u = u_func)

# Set the boundary conditions
BC = NULL
BC$BC_indices = which(mesh$nodesmarkers == 1) # b.c. on the complete boundary
BC$BC_values = rep(0,length(BC$BC_indices)) # homogeneus b.c.

# Since the data locations are a subset of the mesh nodes for a faster solution use:
dataNA = rep(NA, FEMbasis$nbasis)
dataNA[mesh$nodesmarkers == 0] = data
#grid evaluation
solution = smooth.FEM(observations = dataNA,
                            FEMbasis = FEMbasis,
                            lambda = lambda,
                            PDE_parameters = PDE_parameters,
                            BC = BC)
plot(solution$fit.FEM)
image(solution$fit.FEM)
# Newton's method
solution = smooth.FEM(observations = dataNA,
                            FEMbasis = FEMbasis,
                            PDE_parameters = PDE_parameters,
                            BC = BC)
plot(solution$fit.FEM)
image(solution$fit.FEM)

#### Smoothing with areal data ####
# See Azzimonti et al. for reference to the current exemple
data(quasicircle2Dareal)
incidence_matrix = quasicircle2Dareal$incidence_matrix
data = quasicircle2Dareal$data
mesh = quasicircle2Dareal$mesh

FEMbasis = create.FEM.basis(mesh)
lambda = 10^-4

# Set the PDE parameters
R = 2.8
K1 = 0.1
K2 = 0.2
beta = 0.5
K_func&lt;-function(points)
{
  output = array(0, c(2, 2, nrow(points)))
  for (i in 1:nrow(points))
    output[,,i]=10*rbind(c(points[i,2]^2+K1*points[i,1]^2+K2*(R^2-points[i,1]^2-points[i,2]^2),
                           (K1-1)*points[i,1]*points[i,2]),
                         c((K1-1)*points[i,1]*points[i,2],
                           points[i,1]^2+K1*points[i,2]^2+K2*(R^2-points[i,1]^2-points[i,2]^2)))
  output
}

b_func&lt;-function(points)
{
  output = array(0, c(2, nrow(points)))
  for (i in 1:nrow(points))
    output[,i] = 10*beta*c(points[i,1],points[i,2])
  output
}

c_func&lt;-function(points)
{
  rep(c(0), nrow(points))
}

u_func&lt;-function(points)
{
  rep(c(0), nrow(points))
}
PDE_parameters = list(K = K_func, b = b_func, c = c_func, u = u_func)

# Set the boundary conditions
BC = NULL
BC$BC_indices = which(mesh$nodesmarkers == 1) # b.c. on the complete boundary
BC$BC_values = rep(0,length(BC$BC_indices)) # homogeneus b.c.
#grid evaluation
solution = smooth.FEM(observations = data,
                            incidence_matrix = incidence_matrix,
                            FEMbasis = FEMbasis,
                            lambda = lambda,
                            PDE_parameters = PDE_parameters,
                            BC = BC)
plot(solution$fit.FEM)
image(solution$fit.FEM)
#Newton's method
solution = smooth.FEM(observations = data,
                            incidence_matrix = incidence_matrix,
                            FEMbasis = FEMbasis,
                            PDE_parameters = PDE_parameters,
                            BC = BC)
plot(solution$fit.FEM)
image(solution$fit.FEM)

</code></pre>

<hr>
<h2 id='smooth.FEM.time'>Space-time regression with differential regularization</h2><span id='topic+smooth.FEM.time'></span>

<h3>Description</h3>

<p>Space-time regression  with differential regularization. Space-varying covariates can be included in the model. The technique accurately handle data distributed over irregularly shaped domains. Moreover, various conditions can be imposed at the domain boundaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth.FEM.time(locations = NULL, time_locations = NULL, observations, FEMbasis, 
time_mesh=NULL, covariates = NULL, PDE_parameters = NULL,  BC = NULL,
incidence_matrix = NULL, areal.data.avg = TRUE,
FLAG_MASS = FALSE, FLAG_PARABOLIC = FALSE, FLAG_ITERATIVE = FALSE,
threshold = 10^(-4), max.steps = 50, IC = NULL,
search = "tree", bary.locations = NULL,
family = "gaussian", mu0 = NULL, scale.param = NULL,
threshold.FPIRLS = 0.0002020, max.steps.FPIRLS = 15,
lambda.selection.criterion = "grid", DOF.evaluation = NULL, 
lambda.selection.lossfunction = NULL, lambdaS = NULL, lambdaT = NULL, 
DOF.stochastic.realizations = 100, DOF.stochastic.seed = 0, 
DOF.matrix = NULL, GCV.inflation.factor = 1, lambda.optimization.tolerance = 0.05,
inference.data.object.time=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth.FEM.time_+3A_locations">locations</code></td>
<td>
<p>A matrix where each row specifies the spatial coordinates <code>x</code> and <code>y</code> (and <code>z</code> if ndim=3) of the corresponding observations in the vector <code>observations</code>.
This parameter can be <code>NULL</code>. In this case, if also the incidence matrix is <code>NULL</code> the spatial coordinates are assumed to coincide with the nodes of the <code>mesh</code>.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_time_locations">time_locations</code></td>
<td>
<p>A vector containing the times of the corresponding observations in the vector <code>observations</code>. 
This parameter can be <code>NULL</code>. In this case the temporal locations are assumed to coincide with the nodes of the <code>time_mesh</code>.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_observations">observations</code></td>
<td>
<p>A matrix of #locations x #time_locations with the observed data values over the spatio-temporal domain.
The spatial locations of the observations can be specified with the <code>locations</code> argument.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_fembasis">FEMbasis</code></td>
<td>
<p>A <code>FEMbasis</code> object describing the Finite Element basis, as created by <code><a href="#topic+create.FEM.basis">create.FEM.basis</a></code>.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_time_mesh">time_mesh</code></td>
<td>
<p>A vector specifying the time mesh.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_covariates">covariates</code></td>
<td>
<p>A #observations-by-#covariates matrix where each row represents the covariates associated with the corresponding observed data value in <code>observations</code>.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_pde_parameters">PDE_parameters</code></td>
<td>
<p>A list specifying the parameters of the PDE in the regularizing term. Default is NULL, i.e. regularization is by means of the Laplacian (stationary, isotropic case).
If the PDE is elliptic it must contain: <code>K</code>, a 2-by-2 matrix of diffusion coefficients. This induces an anisotropic
smoothing with a preferential direction that corresponds to the first eigenvector of the diffusion matrix K; <code>b</code>, a vector of length 2 of advection coefficients. This induces a
smoothing only in the direction specified by the vector <code>b</code>; <code>c</code>, a scalar reaction coefficient. <code>c</code> induces a shrinkage of the surface to zero
If the PDE is space-varying it must contain: <code>K</code>, a function that for each spatial location in the spatial domain
(indicated by the vector of the 2 spatial coordinates) returns a 2-by-2 matrix of diffusion coefficients. This induces an anisotropic
smoothing with a local preferential direction that corresponds to the first eigenvector of the diffusion matrix K.The function must support recycling for efficiency reasons, thus if the input parameter is a #point-by-2 matrix, the output should be
an array with dimensions 2-by-2-by-#points.<code>b</code>, a function that for each spatial location in the spatial domain returns
a vector of length 2 of transport coefficients. This induces a local smoothing only in the direction specified by the vector <code>b</code>. The function must support recycling for efficiency reasons, thus if the input parameter is a #point-by-2 matrix, the output should be
a matrix with dimensions 2-by-#points; <code>c</code>, a function that for each spatial location in the spatial domain  returns a scalar reaction coefficient.
<code>c</code> induces a shrinkage of the surface to zero. The function must support recycling for efficiency reasons, thus if the input parameter is a #point-by-2 matrix, the output should be
a vector with length #points; <code>u</code>, a function that for each spatial location in the spatial domain  returns a scalar reaction coefficient.
<code>u</code> induces a reaction effect. The function must support recycling for efficiency reasons, thus if the input parameter is a #point-by-2 matrix, the output should be
a vector with length #points.
For 2.5D and 3D only the Laplacian is available (<code>PDE_parameters=NULL</code>)</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_bc">BC</code></td>
<td>
<p>A list with two vectors:
<code>BC_indices</code>, a vector with the indices in <code>nodes</code> of boundary nodes where a Dirichlet Boundary Condition should be applied;
<code>BC_values</code>, a vector with the values that the spatial field must take at the nodes indicated in <code>BC_indices</code>.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_incidence_matrix">incidence_matrix</code></td>
<td>
<p>A #regions-by-#triangles/tetrahedrons matrix where the element (i,j) equals 1 if the j-th triangle/tetrahedron is in the i-th region and 0 otherwise.
This is only for areal data. In case of pointwise data, this parameter is set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_areal.data.avg">areal.data.avg</code></td>
<td>
<p>Boolean. It involves the computation of Areal Data. If <code>TRUE</code> the areal data are averaged, otherwise not.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_flag_mass">FLAG_MASS</code></td>
<td>
<p>Boolean. This parameter is considered only for separable problems i.e. when <code>FLAG_PARABOLIC==FALSE</code>. If <code>TRUE</code> the mass matrix in space and in time are used, if <code>FALSE</code> they are substituted with proper identity matrices.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_flag_parabolic">FLAG_PARABOLIC</code></td>
<td>
<p>Boolean. If <code>TRUE</code> the parabolic problem problem is selected, if <code>FALSE</code> the separable one.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_flag_iterative">FLAG_ITERATIVE</code></td>
<td>
<p>Boolean. If <code>TRUE</code> the iterative method is selected, if <code>FALSE</code> the monolithic one.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_threshold">threshold</code></td>
<td>
<p>This parameter is used for arresting algorithm iterations. Algorithm stops when two successive iterations lead to improvement in penalized log-likelihood smaller than threshold.
Default value <code>threshold = 10^(-4)</code>.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_max.steps">max.steps</code></td>
<td>
<p>This parameter is used to limit the maximum number of iteration.
Default value <code>max.steps=50</code>.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_ic">IC</code></td>
<td>
<p>Initial condition needed in case of parabolic problem i.e. when <code>FLAG_PARABOLIC==TRUE</code>. 
If <code>FLAG_PARABOLIC==FALSE</code> this parameter is ignored. If <code>FLAG_PARABOLIC=TRUE</code> and <code>IC=NULL</code> it is necessary to provide
also data at the initial time. IC will be estimated from them.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_search">search</code></td>
<td>
<p>a flag to decide the search algorithm type (tree or naive or walking search algorithm).</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_bary.locations">bary.locations</code></td>
<td>
<p>A list with three vectors:
<code>locations</code>, location points which are same as the given locations options. (checks whether both locations are the same);
<code>element ids</code>, a vector of element id of the points from the mesh where they are located;
<code>barycenters</code>, a vector of barycenter of points from the located element.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_family">family</code></td>
<td>
<p>This parameter specify the distribution within exponential family used for GLM model.
The following distribution are implemented: &quot;binomial&quot;, &quot;exponential&quot;, &quot;gamma&quot;, &quot;poisson&quot;, &quot;gaussian&quot;, &quot;invgaussian&quot;.
The default link function for binomial is <code>logit</code> if you want either <code>probit</code> or <code>clogloc</code> set <code>family = "probit"</code>, <code>family = "cloglog"</code>.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_mu0">mu0</code></td>
<td>
<p>This parameter is a vector that set the starting point for FPIRLS algorithm. It represent an initial guess of the location parameter.
Default is set to observation for non binary distribution while equal to <code>0.5(observations + 0.5)</code> for binary data.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_scale.param">scale.param</code></td>
<td>
<p>Dispersion parameter of the chosen distribution. This is only required for &quot;gamma&quot;, &quot;gaussian&quot;, &quot;invgaussian&quot;.
User may specify the parameter as a positive real number. If the parameter is not supplied, it is estimated from data according to Wilhelm Sangalli 2016.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_threshold.fpirls">threshold.FPIRLS</code></td>
<td>
<p>This parameter is used for arresting algorithm iterations. Algorithm stops when two successive iterations lead to improvement in penalized log-likelihood smaller than threshold.FPIRLS.
Default value <code>threshold.FPIRLS = 0.0002020</code>.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_max.steps.fpirls">max.steps.FPIRLS</code></td>
<td>
<p>This parameter is used to limit the maximum number of iteration.
Default value <code>max.steps.FPIRLS=15</code>.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_lambda.selection.criterion">lambda.selection.criterion</code></td>
<td>
<p>This parameter is used to select the optimization method related to smoothing parameter <code>lambda</code>.
The following methods are implemented: 'grid', further optimization methods are yet to come. 
The 'grid' is a pure evaluation method, therefore a vector of <code>lambda</code> testing penalizations must be provided.
Default value <code>lambda.selection.criterion='grid'</code></p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_dof.evaluation">DOF.evaluation</code></td>
<td>
<p>This parameter is used to identify if and how degrees of freedom computation has to be performed.
The following possibilities are allowed: NULL, 'exact' and 'stochastic'
In the former case no degree of freedom is computed, while the other two methods enable computation.
Stochastic computation of DOFs may be slightly less accurate than its deterministic counterpart, but is highly suggested for meshes of more than 5000 nodes, being fairly less time consuming.
Default value <code>DOF.evaluation=NULL</code></p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_lambda.selection.lossfunction">lambda.selection.lossfunction</code></td>
<td>
<p>This parameter is used to understand if some loss function has to be evaluated.
The following possibilities are allowed: NULL and 'GCV' (generalized cross validation)
The former case is that of <code>lambda.selection.criterion='grid'</code> pure evaluation, while the second can be employed for optimization methods.
Default value <code>lambda.selection.lossfunction=NULL</code></p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_lambdas">lambdaS</code></td>
<td>
<p>A scalar or vector of spatial smoothing parameters.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_lambdat">lambdaT</code></td>
<td>
<p>A scalar or vector of temporal smoothing parameters.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_dof.stochastic.realizations">DOF.stochastic.realizations</code></td>
<td>
<p>This parameter is considered only when <code>DOF.evaluation = 'stochastic'</code>.
It is a positive integer that represents the number of uniform random variables used in stochastic GCV computation.
Default value <code>DOF.stochastic.realizations=100</code>.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_dof.stochastic.seed">DOF.stochastic.seed</code></td>
<td>
<p>This parameter is considered only when <code>DOF.evaluation = 'stochastic'</code>.
It is a positive integer that represents user defined seed employed in stochastic GCV computation.
Default value <code>DOF.stochastic.seed=0</code>.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_dof.matrix">DOF.matrix</code></td>
<td>
<p>Matrix of degrees of freedom. This parameter can be used if the DOF.matrix corresponding to <code>lambdaS</code> and <code>lambdaT</code> is available from precedent computation. This allows to save time
since the computation of the DOFs is the most expensive part of GCV.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_gcv.inflation.factor">GCV.inflation.factor</code></td>
<td>
<p>Tuning parameter used for the estimation of GCV. Default value <code>GCV.inflation.factor = 1.0</code>.
It is advised to set it grather than 1 to avoid overfitting.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_lambda.optimization.tolerance">lambda.optimization.tolerance</code></td>
<td>
<p>Tolerance parameter, a double between 0 and 1 that fixes how much precision is required by the optimization method: the smaller the parameter, the higher the accuracy.
Used only if <code>lambda.selection.criterion='newton'</code> or <code>lambda.selection.criterion='newton_fd'</code>, thus ot implemented yet.
Default value <code>lambda.optimization.tolerance=0.05</code>.</p>
</td></tr>
<tr><td><code id="smooth.FEM.time_+3A_inference.data.object.time">inference.data.object.time</code></td>
<td>
<p>An <code><a href="#topic+inferenceDataObjectTime">inferenceDataObjectTime</a></code> that stores all the information regarding inference over the linear and nonlinear parameters of the model. This parameter needs to be 
consistent with <code>covariates</code> and mesh dimension number, otherwise will be discarded. If set and well defined, the function will have in output the inference results. It is suggested to create this object via <code><a href="#topic+inferenceDataObjectTimeBuilder">inferenceDataObjectTimeBuilder</a></code> function, so that the object is guaranteed to be well defined.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following variables:
</p>

<dl>
<dt><code>fit.FEM.time</code></dt><dd><p>A <code>FEM.time</code> object that represents the fitted spatio-temporal field.</p>
</dd>
<dt><code>PDEmisfit.FEM.time</code></dt><dd><p>A <code>FEM.time</code> object that represents the misfit of the penalized PDE.</p>
</dd>
<dt><code>beta</code></dt><dd><p>If <code>covariates</code> is not <code>NULL</code>, a matrix with number of rows equal to the number of covariates and number of columns equal to length of lambda.  The <code>j</code>th column represents the vector of regression coefficients when
the smoothing parameter is equal to <code>lambda[j]</code>.</p>
</dd>
<dt><code>edf</code></dt><dd><p>If GCV is <code>TRUE</code>, a scalar or matrix with the trace of the smoothing matrix for each combination of the smoothing parameters specified in <code>lambdaS</code> and <code>lambdaT</code>.</p>
</dd>
<dt><code>stderr</code></dt><dd><p>If GCV is <code>TRUE</code>, a scalar or matrix with the estimate of the standard deviation of the error for each combination of the smoothing parameters specified in <code>lambdaS</code> and <code>lambdaT</code>.</p>
</dd>
<dt><code>GCV</code></dt><dd><p>If GCV is <code>TRUE</code>, a  scalar or matrix with the value of the GCV criterion for each combination of the smoothing parameters specified in <code>lambdaS</code> and <code>lambdaT</code>.</p>
</dd>
<dt><code>bestlambda</code></dt><dd><p>If GCV is <code>TRUE</code>, a 2-elements vector with the indices of smoothing parameters returning the lowest GCV</p>
</dd>
<dt><code>ICestimated</code></dt><dd><p>If FLAG_PARABOLIC is <code>TRUE</code> and IC is <code>NULL</code>, a list containing a <code>FEM</code> object with the initial conditions, the value of the smoothing parameter lambda returning the lowest GCV and, in presence of covariates, the estimated beta coefficients</p>
</dd>
<dt><code>bary.locations</code></dt><dd><p>A barycenter information of the given locations if the locations are not mesh nodes.</p>
</dd>
<dt><code>inference</code></dt><dd><p>A list set only if a well defined <code><a href="#topic+inferenceDataObjectTime">inferenceDataObjectTime</a></code> is passed as parameter to the function; contains all inference outputs required:
</p>

<dl>
<dt><code>p_values</code></dt><dd><p>list of lists set only if at least one p-value is required; contains the p-values divided by implementation:
</p>

<dl>
<dt><code>wald</code></dt><dd><p>list containing all the Wald p-values required, in the same order of the  <code>type</code> list in <code>inference.data.object.time</code>. 
If one-at-the-time tests are required, the corresponding item is a vector of p values ordered as the rows of <code>coeff</code> matrix in <code>inference.data.object.time</code>.
</p>
</dd>
<dt><code>speckman</code></dt><dd><p>list containing all the Speckman p-values required, in the same order of the  <code>type</code> list in  <code>inference.data.object.time</code>. 
If one-at-the-time tests are required, the corresponding item is a vector of p values ordered as the rows of <code>coeff</code> matrix in <code>inference.data.object.time</code>.
</p>
</dd>
<dt><code>eigen_sign_flip</code></dt><dd><p>list containing all the Eigen-Sign-Flip p-values required, in the same order of the <code>type</code> list in <code>inference.data.object.time</code>. 
If one-at-the-time tests are required, the corresponding item is a vector of p values ordered as the rows of <code>coeff</code> matrix in <code>inference.data.object.time</code>. 
</p>
</dd>
</dl>

</dd>
<dt><code>CI</code></dt><dd><p>list of lists set only if at least one confidence interval is required; contains the confidence intervals divided by implementation:
</p>

<dl>
<dt><code>wald</code></dt><dd><p>list containing all the Wald confidence intervals required, in the same order of the  <code>type</code> list in <code>inference.data.object.time</code>.
Each item is a matrix with 3 columns and p rows, p being the number of rows of <code>coeff</code> matrix in <code>inference.data.object.time</code>; each row is the CI for the corresponding row of <code>coeff</code> matrix. 
</p>
</dd>
<dt><code>speckman</code></dt><dd><p>list containing all the Speckman confidence intervals required, in the same order of the  <code>type</code> list in <code>inference.data.object.time</code>.
Each item is a matrix with 3 columns and p rows, p being the number of rows of <code>coeff</code> matrix in <code>inference.data.object.time</code>; each row is the CI for the corresponding row of <code>coeff</code> matrix.
</p>
</dd>
</dl>

</dd>
</dl>

</dd>
</dl>



<h3>References</h3>

<p>#' @references Arnone, E., Azzimonti, L., Nobile, F., &amp; Sangalli, L. M. (2019). Modeling 
spatially dependent functional data via regression with differential regularization. 
Journal of Multivariate Analysis, 170, 275-295.
Bernardi, M. S., Sangalli, L. M., Mazza, G., &amp; Ramsay, J. O. (2017). A penalized 
regression model for spatial functional data with application to the analysis of the 
production of waste in Venice province. 
Stochastic Environmental Research and Risk Assessment, 31(1), 23-38.
Federico Ferraccioli, Laura M. Sangalli &amp; Livio Finos (2022). Some first inferential tools for spatial regression
with differential regularization. Journal of Multivariate Analysis, 189, 104866.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fdaPDE)

data(horseshoe2D)
boundary_nodes = horseshoe2D$boundary_nodes
boundary_segments = horseshoe2D$boundary_segments
locations = horseshoe2D$locations
time_locations = seq(0,1,length.out = 5)

mesh = create.mesh.2D(nodes = rbind(boundary_nodes, locations), segments = boundary_segments)

space_time_locations = cbind(rep(time_locations,each=nrow(mesh$nodes)),
                             rep(mesh$nodes[,1],5),rep(mesh$nodes[,2],5))

FEMbasis = create.FEM.basis(mesh)
lambdaS = 10^-1
lambdaT = 10^-1
data = fs.test(space_time_locations[,2], 
               space_time_locations[,3])*cos(pi*space_time_locations[,1]) +
       rnorm(nrow(space_time_locations), sd = 0.5)
data = matrix(data, nrow = nrow(mesh$nodes), ncol = length(time_locations), byrow = TRUE)

solution = smooth.FEM.time(observations = data, time_locations = time_locations,
                           FEMbasis = FEMbasis, lambdaS = lambdaS, lambdaT = lambdaT)
plot(solution$fit.FEM)
</code></pre>

<hr>
<h2 id='sphere3Ddata'>Sphere3Ddata</h2><span id='topic+sphere3Ddata'></span>

<h3>Description</h3>

<p>A dataset with information about the connectivity matrix and the nodes locations of a sphere geometry. It containes:
</p>

<ul>
<li><p> nodes. A #nodes-by-3 matrix specifying the locations of each node.
</p>
</li>
<li><p> tetrahedrons. A #tetrahedrons-by-4 matrix specifying the indices of the nodes in each tetrahedron.
</p>
</li></ul>

<p>This dataset can be used to create a <code>MESH.3D</code> object with the function <code>create.MESH.3D</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
