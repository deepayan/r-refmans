<!DOCTYPE html><html lang="en"><head><title>Help for package bartMan</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bartMan}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acceptRate'><p>acceptRate</p></a></li>
<li><a href='#bartClassifDiag'><p>bartClassifDiag</p></a></li>
<li><a href='#bartDiag'><p>bartDiag</p></a></li>
<li><a href='#bartRegrDiag'><p>bartRegrDiag</p></a></li>
<li><a href='#clusterTrees'><p>Cluster Trees by Variable</p></a></li>
<li><a href='#combineDummy'><p>Update Dummy Variable Names</p></a></li>
<li><a href='#extractTreeData'><p>extractTreeData</p></a></li>
<li><a href='#get_stump_colour_for_legend'><p>Determines the stump color for a legend based on its mean value</p></a></li>
<li><a href='#getChildren'><p>Generate Child and Parent Node Relationships</p></a></li>
<li><a href='#getObservations'><p>Get Observations Falling into Each Node</p></a></li>
<li><a href='#guide_colourfan'><p>Colourfan guide</p></a></li>
<li><a href='#input_data'><p>input_data</p></a></li>
<li><a href='#localProcedure'><p>localProcedure</p></a></li>
<li><a href='#mdsBart'><p>mdsBart</p></a></li>
<li><a href='#node_depth'><p>Calculate Node Depths in a Tree Data Frame</p></a></li>
<li><a href='#pal_vsup'><p>Variance suppressing uncertainty palette</p></a></li>
<li><a href='#permVimp'><p>permVimp</p></a></li>
<li><a href='#permVint'><p>permVint</p></a></li>
<li><a href='#plotProximity'><p>plotProximity</p></a></li>
<li><a href='#plotSingleTree'><p>plotSingleTree</p></a></li>
<li><a href='#plotTrees'><p>Plot Trees with Customisations</p></a></li>
<li><a href='#print.hideHelper1'><p>print.hideHelper</p></a></li>
<li><a href='#proximityMatrix'><p>proximityMatrix</p></a></li>
<li><a href='#RangeBivariate'><p>Constructor for bivariate range object</p></a></li>
<li><a href='#ScaleBivariate'><p>Constructor for bivariate scale object</p></a></li>
<li><a href='#sort_trees_by_depthMax'><p>Sort Trees by Maximum Depth</p></a></li>
<li><a href='#splitDensity'><p>splitDensity</p></a></li>
<li><a href='#terminalFunction'><p>Generate Terminal Node Indicator</p></a></li>
<li><a href='#train_bivariate'><p>Train range for bivariate scale</p></a></li>
<li><a href='#tree_data_example'><p>tree_data_example</p></a></li>
<li><a href='#tree_dataframe'><p>Transform tree data into a structured dataframe</p></a></li>
<li><a href='#treeBarPlot'><p>Plot Frequency of Tree Structures</p></a></li>
<li><a href='#treeDepth'><p>treeDepth</p></a></li>
<li><a href='#treeList'><p>Generate a List of Tree Structures from BART Model Output</p></a></li>
<li><a href='#treeNodes'><p>treeNodes</p></a></li>
<li><a href='#vimpBart'><p>vimpBart</p></a></li>
<li><a href='#vimpPlot'><p>vimpPlot</p></a></li>
<li><a href='#vintPlot'><p>vintPlot</p></a></li>
<li><a href='#viviBart'><p>viviBart</p></a></li>
<li><a href='#viviBartMatrix'><p>viviBartMatrix</p></a></li>
<li><a href='#viviBartPlot'><p>viviBartPlot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Create Visualisations for BART Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alan Inglis &lt;alan.inglis@mu.ie&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Investigating and visualising Bayesian Additive Regression Tree (BART) (Chipman, H. A., George, E. I., &amp; McCulloch, R. E. 2010) &lt;<a href="https://doi.org/10.1214%2F09-AOAS285">doi:10.1214/09-AOAS285</a>&gt; model fits.  We construct conventional plots to analyze a modelâ€™s performance and stability  as well as create new tree-based plots to analyze variable importance, interaction, and tree structure.  We employ Value Suppressing Uncertainty Palettes (VSUP) to construct heatmaps that display variable importance  and interactions jointly using colour scale to represent posterior uncertainty.  Our visualisations are designed to work with the most popular BART R packages available, namely 'BART' Rodney Sparapani and Charles Spanbauer and Robert McCulloch 2021 &lt;<a href="https://doi.org/10.18637%2Fjss.v097.i01">doi:10.18637/jss.v097.i01</a>&gt;,  'dbarts'  (Vincent Dorie 2023) <a href="https://CRAN.R-project.org/package=dbarts">https://CRAN.R-project.org/package=dbarts</a>,  and 'bartMachine' (Adam Kapelner and Justin Bleich 2016) &lt;<a href="https://doi.org/10.18637%2Fjss.v070.i04">doi:10.18637/jss.v070.i04</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>colorspace, cowplot, DendSer, dplyr, ggiraph, ggnewscale,
ggplot2, ggraph, grid, grDevices, gtable, igraph, patchwork,
purrr, rlang, rrapply, scales, stats, tidybayes, tidygraph,
tidyr, tidytreatment, utils, tibble, BART, bartMachine, dbarts,
rJava, cli</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ROCR, ggridges, ggforce, lvplot</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-24 11:58:11 UTC; alaninglis</td>
</tr>
<tr>
<td>Author:</td>
<td>Alan Inglis [aut, cre],
  Andrew Parnell [aut],
  Catherine Hurley [aut],
  Claus Wilke [ctb] (Developer of VSUP script)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-24 12:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='acceptRate'>acceptRate</h2><span id='topic+acceptRate'></span>

<h3>Description</h3>

<p>Plots the acceptance rate of trees from a BART model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acceptRate(trees)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acceptRate_+3A_trees">trees</code></td>
<td>
<p>A data frame created by extractTreeData function.
Displays a division on the plot to separate prior and post burn-in iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object plot of acceptance rate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("dbarts", quietly = TRUE)){
# Load the dbarts package to access the bart function
library(dbarts)
# Get Data
df &lt;- na.omit(airquality)
# Create Simple dbarts Model For Regression:
set.seed(1701)
dbartModel &lt;- bart(df[2:6], df[,1], ntree = 5, keeptrees = TRUE, nskip = 10, ndpost = 10)
# Tree Data
trees_data &lt;- extractTreeData(model = dbartModel, data = df)
acceptRate(trees = trees_data)}


</code></pre>

<hr>
<h2 id='bartClassifDiag'>bartClassifDiag</h2><span id='topic+bartClassifDiag'></span>

<h3>Description</h3>

<p>Displays a selection of diagnostic plots for a BART model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bartClassifDiag(
  model,
  data,
  response,
  threshold = "Youden",
  pNorm = FALSE,
  showInterval = TRUE,
  combineFactors = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bartClassifDiag_+3A_model">model</code></td>
<td>
<p>a model created from either the BART, dbarts, or bartMachine package.</p>
</td></tr>
<tr><td><code id="bartClassifDiag_+3A_data">data</code></td>
<td>
<p>A dataframe</p>
</td></tr>
<tr><td><code id="bartClassifDiag_+3A_response">response</code></td>
<td>
<p>The name of the response for the fit.</p>
</td></tr>
<tr><td><code id="bartClassifDiag_+3A_threshold">threshold</code></td>
<td>
<p>A dashed line on some plots to indicate a chosen threshold value.
by default the Youden index is shown.</p>
</td></tr>
<tr><td><code id="bartClassifDiag_+3A_pnorm">pNorm</code></td>
<td>
<p>apply pnorm to the y-hat data</p>
</td></tr>
<tr><td><code id="bartClassifDiag_+3A_showinterval">showInterval</code></td>
<td>
<p>LOGICAL if TRUE then show 5% and 95% quantile intervals.</p>
</td></tr>
<tr><td><code id="bartClassifDiag_+3A_combinefactors">combineFactors</code></td>
<td>
<p>Whether or not to combine dummy variables (if present) in display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A selection of diagnostic plots
</p>

<hr>
<h2 id='bartDiag'>bartDiag</h2><span id='topic+bartDiag'></span>

<h3>Description</h3>

<p>Displays a selection of diagnostic plots for a BART model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bartDiag(
  model,
  data,
  response,
  burnIn = 0,
  threshold = "Youden",
  pNorm = FALSE,
  showInterval = TRUE,
  combineFactors = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bartDiag_+3A_model">model</code></td>
<td>
<p>a model created from either the BART, modelarts, or bartMachine package.</p>
</td></tr>
<tr><td><code id="bartDiag_+3A_data">data</code></td>
<td>
<p>A dataframe used to build the model.</p>
</td></tr>
<tr><td><code id="bartDiag_+3A_response">response</code></td>
<td>
<p>The name of the response for the fit.</p>
</td></tr>
<tr><td><code id="bartDiag_+3A_burnin">burnIn</code></td>
<td>
<p>Trace plot will only show iterations above selected burn in value.</p>
</td></tr>
<tr><td><code id="bartDiag_+3A_threshold">threshold</code></td>
<td>
<p>A dashed line on some plots to indicate a chosen threshold value (classification only).
by default the Youden index is shown.</p>
</td></tr>
<tr><td><code id="bartDiag_+3A_pnorm">pNorm</code></td>
<td>
<p>apply pnorm to the y-hat data (classification only).</p>
</td></tr>
<tr><td><code id="bartDiag_+3A_showinterval">showInterval</code></td>
<td>
<p>LOGICAL if TRUE then show 5% and 95% quantile intervals on ROC an PC curves (classification only).</p>
</td></tr>
<tr><td><code id="bartDiag_+3A_combinefactors">combineFactors</code></td>
<td>
<p>Whether or not to combine dummy variables (if present) in display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A selection of diagnostic plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# For Regression
# Generate Friedman data
fData &lt;- function(n = 200, sigma = 1.0, seed = 1701, nvar = 5) {
  set.seed(seed)
  x &lt;- matrix(runif(n * nvar), n, nvar)
  colnames(x) &lt;- paste0("x", 1:nvar)
  Ey &lt;- 10 * sin(pi * x[, 1] * x[, 2]) + 20 * (x[, 3] - 0.5)^2 + 10 * x[, 4] + 5 * x[, 5]
  y &lt;- rnorm(n, Ey, sigma)
  data &lt;- as.data.frame(cbind(x, y))
  return(data)
}
f_data &lt;- fData(nvar = 10)
x &lt;- f_data[, 1:10]
y &lt;- f_data$y

# Create dbarts model
library(dbarts)
set.seed(1701)
dbartModel &lt;- bart(x, y, ntree = 5, keeptrees = TRUE, nskip = 10, ndpost = 10)

bartDiag(model = dbartModel, response = "y", burnIn = 100, data = f_data)


# For Classification
data(iris)
iris2 &lt;- iris[51:150, ]
iris2$Species &lt;- factor(iris2$Species)

# Create dbarts model
dbartModel &lt;- bart(iris2[, 1:4], iris2[, 5], ntree = 5, keeptrees = TRUE, nskip = 10, ndpost = 10)

bartDiag(model = dbartModel, data = iris2, response = iris2$Species)


</code></pre>

<hr>
<h2 id='bartRegrDiag'>bartRegrDiag</h2><span id='topic+bartRegrDiag'></span>

<h3>Description</h3>

<p>Displays a selection of diagnostic plots for a BART model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bartRegrDiag(model, response, burnIn = 0, data, combineFactors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bartRegrDiag_+3A_model">model</code></td>
<td>
<p>a model created from either the BART, modelarts, or bartMachine package.</p>
</td></tr>
<tr><td><code id="bartRegrDiag_+3A_response">response</code></td>
<td>
<p>The name of the response for the fit.</p>
</td></tr>
<tr><td><code id="bartRegrDiag_+3A_burnin">burnIn</code></td>
<td>
<p>Trace plot will only show iterations above selected burn in value.</p>
</td></tr>
<tr><td><code id="bartRegrDiag_+3A_data">data</code></td>
<td>
<p>A dataframe used to build the model.</p>
</td></tr>
<tr><td><code id="bartRegrDiag_+3A_combinefactors">combineFactors</code></td>
<td>
<p>Whether or not to combine dummy variables (if present) in display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A selection of diagnostic plots
</p>

<hr>
<h2 id='clusterTrees'>Cluster Trees by Variable</h2><span id='topic+clusterTrees'></span>

<h3>Description</h3>

<p>Reorders a list of tree structures based on the clustering of variables within each tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterTrees(tree_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clusterTrees_+3A_tree_list">tree_list</code></td>
<td>
<p>A list of trees, where each tree is expected to have a 'var' column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of trees reordered based on the clustering of variables.
</p>

<hr>
<h2 id='combineDummy'>Update Dummy Variable Names</h2><span id='topic+combineDummy'></span>

<h3>Description</h3>

<p>This function updates the 'var' column in the 'structure' component of the 'trees' list,
replacing dummy variable names derived from factor variables with their original factor variable names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineDummy(trees)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combineDummy_+3A_trees">trees</code></td>
<td>
<p>A list containing at least two components: 'data' and 'structure'.
'data' should be a dataframe, and 'structure' a dataframe that includes a 'var' column.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first identifies factor variables in 'trees$data', then checks each entry
in 'trees$structure$var' for matches with these factor variables. If a match is found, indicating
a dummy variable, the entry is replaced with the original factor variable name.
</p>


<h3>Value</h3>

<p>The modified 'trees' list with updated 'var' column entries in 'trees$structure'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("dbarts", quietly = TRUE)){
# Load the dbarts package to access the bart function
 library(dbarts)
 # Create Simple dbarts Model with Dummies
 set.seed(1701)
 dbartModel &lt;- bart(iris[2:5], iris[,1], ntree = 5, keeptrees = TRUE, nskip = 10, ndpost = 10)
 # Tree Data
 trees_data &lt;- extractTreeData(model = dbartModel, data = iris)
 combined_trees &lt;- combineDummy(trees = trees_data)
}

</code></pre>

<hr>
<h2 id='extractTreeData'>extractTreeData</h2><span id='topic+extractTreeData'></span>

<h3>Description</h3>

<p>Creates a list of all tree attributes for a model
created by either the BART, dbarts or bartMachine packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractTreeData(model, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractTreeData_+3A_model">model</code></td>
<td>
<p>Model created from either the BART, dbarts or bartMachine packages.</p>
</td></tr>
<tr><td><code id="extractTreeData_+3A_data">data</code></td>
<td>
<p>a data frame used to build the BART model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the extracted and processed tree data. This list includes:
</p>

<ol>
<li> <p><strong>Tree Data Frame</strong>: A data frame containing tree attributes.
</p>
</li>
<li> <p><strong>Variable Name</strong>: The names of the variables used in building the model.
</p>
</li>
<li> <p><strong>nMCMC</strong>: The total number of iterations (posterior draws) after burn-in.
</p>
</li>
<li> <p><strong>nTree</strong>: The total number of trees grown in the sum-of-trees model.
</p>
</li>
<li> <p><strong>nVar</strong>: The total number of covariates used in the model.
</p>
</li></ol>

<p>The object created by the 'extractTreeData' function encompasses these elements,
facilitating detailed analysis and visualisation of BART model components.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("dbarts", quietly = TRUE)){
# Load the dbarts package to access the bart function
library(dbarts)
# Get Data
df &lt;- na.omit(airquality)
# Create Simple dbarts Model For Regression:
set.seed(1701)
dbartModel &lt;- bart(df[2:6], df[,1], ntree = 5, keeptrees = TRUE, nskip = 10, ndpost = 10)
# Tree Data
trees_data &lt;- extractTreeData(model = dbartModel, data = df)
}

</code></pre>

<hr>
<h2 id='get_stump_colour_for_legend'>Determines the stump color for a legend based on its mean value</h2><span id='topic+get_stump_colour_for_legend'></span>

<h3>Description</h3>

<p>This function is internal and is used to compute the color of a stump
for the purpose of legend display, based on the mean value relative to specified limits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_stump_colour_for_legend(lims, mean_value, palette)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_stump_colour_for_legend_+3A_lims">lims</code></td>
<td>
<p>A numeric vector of length 2 specifying the limits within which the mean value falls.</p>
</td></tr>
<tr><td><code id="get_stump_colour_for_legend_+3A_mean_value">mean_value</code></td>
<td>
<p>The mean value for which the color needs to be determined.</p>
</td></tr>
<tr><td><code id="get_stump_colour_for_legend_+3A_palette">palette</code></td>
<td>
<p>A character vector of colors representing the palette from which the color is selected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string specifying the color corresponding to the mean value.
</p>

<hr>
<h2 id='getChildren'>Generate Child and Parent Node Relationships</h2><span id='topic+getChildren'></span>

<h3>Description</h3>

<p>Populates 'childLeft', 'childRight', and 'parent' columns in the dataset to establish
parent-child relationships between nodes based on tree structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getChildren(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getChildren_+3A_data">data</code></td>
<td>
<p>A data frame with tree structure, including 'iteration',
'treeNum', 'node', and 'depth' columns, along with a 'terminal' indicator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified data frame with 'childLeft', 'childRight', and 'parent' columns added,
detailing the tree's parent-child node relationships.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("tree_data_example")
# Create Terminal Column
tree_data_example &lt;- transform(tree_data_example,
                               terminal = ifelse(is.na(var),
                               TRUE,
                               FALSE))
# Get depths
depthList &lt;- lapply(split(tree_data_example, ~treeNum + iteration),
                    function(x) cbind(x, depth = node_depth(x)-1))
# Turn into data frame
tree_data_example &lt;- dplyr::bind_rows(depthList, .id = "list_id")
# Add node number sequntially
tree_data_example$node &lt;- with(tree_data_example,
                               ave(seq_along(iteration),
                               list(iteration, treeNum),
                               FUN = seq_along))
# get children
getChildren(data = tree_data_example)

</code></pre>

<hr>
<h2 id='getObservations'>Get Observations Falling into Each Node</h2><span id='topic+getObservations'></span>

<h3>Description</h3>

<p>This function determines which observations from a given dataset fall into
which nodes of a tree, based on a tree structure defined in 'treeData'.
The treeData object must include 'iteration', 'treeNum', 'var', and 'splitValue' columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getObservations(data, treeData)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getObservations_+3A_data">data</code></td>
<td>
<p>A data frame used to build BART model.</p>
</td></tr>
<tr><td><code id="getObservations_+3A_treedata">treeData</code></td>
<td>
<p>A data frame representing the tree structure, including the
necessary columns 'iteration', 'treeNum', 'var', and 'splitValue'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified version of 'treeData' that includes two new columns: 'obsNode' and
'noObs'. 'obsNode' lists the observations falling into each node, and
'noObs' provides the count of observations for each node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("tree_data_example")
# Create Terminal Column
tree_data_example &lt;- transform(tree_data_example,
                              terminal = ifelse(is.na(var),
                              TRUE,
                               FALSE))
# Create Split Value Column
tree_data_example &lt;- transform(tree_data_example,
                               splitValue = ifelse(terminal == FALSE,
                               value,
                               NA_integer_))
# get the observations
getObservations(data = input_data, treeData = tree_data_example)

</code></pre>

<hr>
<h2 id='guide_colourfan'>Colourfan guide</h2><span id='topic+guide_colourfan'></span><span id='topic+guide_colorfan'></span>

<h3>Description</h3>

<p>Colourfan guide
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guide_colourfan(
  title = waiver(),
  title.x.position = "top",
  title.y.position = "right",
  title.theme = NULL,
  title.hjust = 0.5,
  title.vjust = NULL,
  label = TRUE,
  label.theme = NULL,
  barwidth = NULL,
  barheight = NULL,
  nbin = 32,
  reverse = FALSE,
  order = 0,
  available_aes = c("colour", "color", "fill"),
  ...
)

guide_colorfan(
  title = waiver(),
  title.x.position = "top",
  title.y.position = "right",
  title.theme = NULL,
  title.hjust = 0.5,
  title.vjust = NULL,
  label = TRUE,
  label.theme = NULL,
  barwidth = NULL,
  barheight = NULL,
  nbin = 32,
  reverse = FALSE,
  order = 0,
  available_aes = c("colour", "color", "fill"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="guide_colourfan_+3A_title">title</code></td>
<td>
<p>Title</p>
</td></tr>
<tr><td><code id="guide_colourfan_+3A_title.x.position">title.x.position</code></td>
<td>
<p>Title x position</p>
</td></tr>
<tr><td><code id="guide_colourfan_+3A_title.y.position">title.y.position</code></td>
<td>
<p>Title y position</p>
</td></tr>
<tr><td><code id="guide_colourfan_+3A_title.theme">title.theme</code></td>
<td>
<p>Title theme</p>
</td></tr>
<tr><td><code id="guide_colourfan_+3A_title.hjust">title.hjust</code></td>
<td>
<p>Title hjust</p>
</td></tr>
<tr><td><code id="guide_colourfan_+3A_title.vjust">title.vjust</code></td>
<td>
<p>Title vjust</p>
</td></tr>
<tr><td><code id="guide_colourfan_+3A_label">label</code></td>
<td>
<p>Label</p>
</td></tr>
<tr><td><code id="guide_colourfan_+3A_label.theme">label.theme</code></td>
<td>
<p>Label theme</p>
</td></tr>
<tr><td><code id="guide_colourfan_+3A_barwidth">barwidth</code></td>
<td>
<p>Barwidth</p>
</td></tr>
<tr><td><code id="guide_colourfan_+3A_barheight">barheight</code></td>
<td>
<p>Barheight</p>
</td></tr>
<tr><td><code id="guide_colourfan_+3A_nbin">nbin</code></td>
<td>
<p>Number of bins</p>
</td></tr>
<tr><td><code id="guide_colourfan_+3A_reverse">reverse</code></td>
<td>
<p>Reverse</p>
</td></tr>
<tr><td><code id="guide_colourfan_+3A_order">order</code></td>
<td>
<p>order</p>
</td></tr>
<tr><td><code id="guide_colourfan_+3A_available_aes">available_aes</code></td>
<td>
<p>Available aesthetics</p>
</td></tr>
<tr><td><code id="guide_colourfan_+3A_...">...</code></td>
<td>
<p>Extra paramters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'grob' object representing a color fan. This 'grob' can be added to a grid-based plot
or a ggplot2 object to visualize a range of colors in a fan-like structure. Each segment of the fan
corresponds to a color specified in the 'colours' parameter, allowing for an intuitive representation
of color gradients or palettes.
</p>

<hr>
<h2 id='input_data'>input_data</h2><span id='topic+input_data'></span>

<h3>Description</h3>

<p>Small example of Friedman data following the formula:
</p>
<p style="text-align: center;"><code class="reqn">y = 10 \sin(\pi x_1 x_2) + 20 (x_3 - 0.5)^2 + 10 x_4 + 5 x_5 + e</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>input_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 10 rows and 6 columns:
</p>

<dl>
<dt>x1</dt><dd><p>Covariate</p>
</dd>
<dt>x2</dt><dd><p>Covariate</p>
</dd>
<dt>x3</dt><dd><p>Covariate</p>
</dd>
<dt>x4</dt><dd><p>Covariate</p>
</dd>
<dt>x5</dt><dd><p>Covariate</p>
</dd>
<dt>y</dt><dd><p>Response</p>
</dd>
</dl>
<p>...

</p>

<hr>
<h2 id='localProcedure'>localProcedure</h2><span id='topic+localProcedure'></span>

<h3>Description</h3>

<p>A variable selection approach performed by permuting the response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localProcedure(
  model,
  data,
  response,
  numRep = 10,
  numTreesRep = NULL,
  alpha = 0.5,
  shift = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="localProcedure_+3A_model">model</code></td>
<td>
<p>Model created from either the BART, dbarts or bartMachine packages.</p>
</td></tr>
<tr><td><code id="localProcedure_+3A_data">data</code></td>
<td>
<p>A data frame containing variables in the model.</p>
</td></tr>
<tr><td><code id="localProcedure_+3A_response">response</code></td>
<td>
<p>The name of the response for the fit.</p>
</td></tr>
<tr><td><code id="localProcedure_+3A_numrep">numRep</code></td>
<td>
<p>The number of replicates to perform for the BART null model's variable inclusion proportions.</p>
</td></tr>
<tr><td><code id="localProcedure_+3A_numtreesrep">numTreesRep</code></td>
<td>
<p>The number of trees to be used in the replicates.
As suggested by Chipman (2009), a small number of trees is recommended (~20) to force important
variables to used in the model. If NULL, then the number of trees from the true model is used.</p>
</td></tr>
<tr><td><code id="localProcedure_+3A_alpha">alpha</code></td>
<td>
<p>The cut-off level for the thresholds.</p>
</td></tr>
<tr><td><code id="localProcedure_+3A_shift">shift</code></td>
<td>
<p>Whether to shift the inclusion proportion points by the difference
in distance between the quantile and the value of the inclusion proportion point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variable selection plot using the local procedure method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("dbarts", quietly = TRUE)){
# Load the dbarts package to access the bart function
library(dbarts)

# Get Data
df &lt;- na.omit(airquality)
# Create Simple dbarts Model For Regression:
set.seed(1701)
dbartModel &lt;- bart(df[2:6], df[,1], ntree = 5, keeptrees = TRUE, nskip = 10, ndpost = 10)
localProcedure(model = dbartModel,
               data = df,
               numRep = 5,
               numTreesRep = 5,
               alpha = 0.5,
               shift = FALSE)
}


</code></pre>

<hr>
<h2 id='mdsBart'>mdsBart</h2><span id='topic+mdsBart'></span>

<h3>Description</h3>

<p>Multi-dimensional Scaling Plot of proximity matrix from a BART model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdsBart(
  trees,
  data,
  target,
  response,
  plotType = "rows",
  showGroup = TRUE,
  level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mdsBart_+3A_trees">trees</code></td>
<td>
<p>A data frame created by 'extractTreeData' function.</p>
</td></tr>
<tr><td><code id="mdsBart_+3A_data">data</code></td>
<td>
<p>a dataframe used in building the model.</p>
</td></tr>
<tr><td><code id="mdsBart_+3A_target">target</code></td>
<td>
<p>A target proximity matrix to</p>
</td></tr>
<tr><td><code id="mdsBart_+3A_response">response</code></td>
<td>
<p>The name of the response for the fit.</p>
</td></tr>
<tr><td><code id="mdsBart_+3A_plottype">plotType</code></td>
<td>
<p>Type of plot to show. Either 'interactive' - showing interactive confidence ellipses.
'point' - a point plot showing the average position of a observation.
'rows' - displaying the average position of a observation number instead of points.
'all' - show all observations (not averaged).</p>
</td></tr>
<tr><td><code id="mdsBart_+3A_showgroup">showGroup</code></td>
<td>
<p>Logical. Show confidence ellipses.</p>
</td></tr>
<tr><td><code id="mdsBart_+3A_level">level</code></td>
<td>
<p>The confidence level to show. Default is 95% confidence level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For this function, the MDS coordinates are calculated for each iteration.
Procrustes method is then applied to align each of the coordinates to a target set
of coordinates. The returning result is then a clustered average of each point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("dbarts", quietly = TRUE)) {
 # Load the dbarts package to access the bart function
 library(dbarts)
 # Get Data
 df &lt;- na.omit(airquality)
 # Create Simple dbarts Model For Regression:
 set.seed(1701)
 dbartModel &lt;- bart(df[2:6],
   df[, 1],
   ntree = 5,
   keeptrees = TRUE,
   nskip = 10,
   ndpost = 10
 )
 # Tree Data
 trees_data &lt;- extractTreeData(model = dbartModel, data = df)
 # Cretae Porximity Matrix
 bmProx &lt;- proximityMatrix(
   trees = trees_data,
   reorder = TRUE,
   normalize = TRUE,
   iter = 1
 )
 # MDS plot
 mdsBart(
   trees = trees_data, data = df, target = bmProx,
   plotType = "interactive", level = 0.25, response = "Ozone"
 )
}

</code></pre>

<hr>
<h2 id='node_depth'>Calculate Node Depths in a Tree Data Frame</h2><span id='topic+node_depth'></span>

<h3>Description</h3>

<p>Computes the depth of each node in a given tree data frame, assuming a binary tree structure.
Requires the tree data frame to contain a logical column 'terminal' indicating terminal nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_depth(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="node_depth_+3A_tree">tree</code></td>
<td>
<p>A data frame representing a tree, must contain a 'terminal' column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of depths corresponding to each node in the tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("tree_data_example")
# Create Terminal Column
tree_data_example &lt;- transform(tree_data_example, terminal = ifelse(is.na(var), TRUE, FALSE))
# Get depths
depthList &lt;- lapply(split(tree_data_example, ~treeNum + iteration),
                    function(x) cbind(x, depth = node_depth(x)-1))
# Turn into data frame
tree_data_example &lt;- dplyr::bind_rows(depthList, .id = "list_id")

</code></pre>

<hr>
<h2 id='pal_vsup'>Variance suppressing uncertainty palette</h2><span id='topic+pal_vsup'></span>

<h3>Description</h3>

<p>Returns a palette function that turns 'v' (value) and 'u' (uncertainty) (both between 0 and 1) into
colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pal_vsup(
  values,
  unc_levels = 4,
  max_light = 0.9,
  max_desat = 0,
  pow_light = 0.8,
  pow_desat = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pal_vsup_+3A_values">values</code></td>
<td>
<p>Color values to be used at minimum uncertainty. Needs to be a vector of
length '2^unc_levels'.</p>
</td></tr>
<tr><td><code id="pal_vsup_+3A_unc_levels">unc_levels</code></td>
<td>
<p>Number of discrete uncertainty levels. The number of discrete colors
at each level doubles.</p>
</td></tr>
<tr><td><code id="pal_vsup_+3A_max_light">max_light</code></td>
<td>
<p>Maximum amount of lightening</p>
</td></tr>
<tr><td><code id="pal_vsup_+3A_max_desat">max_desat</code></td>
<td>
<p>Maximum amount of desaturation</p>
</td></tr>
<tr><td><code id="pal_vsup_+3A_pow_light">pow_light</code></td>
<td>
<p>Power exponent of lightening</p>
</td></tr>
<tr><td><code id="pal_vsup_+3A_pow_desat">pow_desat</code></td>
<td>
<p>Power exponent of desaturation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that takes two parameters, 'v' (value) and 'u' (uncertainty), both expected to be
in the range of 0 to 1, and returns a color. This color is determined by the specified 'values' colors
at minimum uncertainty, and modified according to the given 'v' and 'u' parameters to represent
uncertainty by adjusting lightness and saturation. The resulting function is useful for creating
color palettes that can encode both value and uncertainty in visualizations.
</p>

<hr>
<h2 id='permVimp'>permVimp</h2><span id='topic+permVimp'></span>

<h3>Description</h3>

<p>A variable selection approach which creates a null model by
permuting the response, rebuilding the model, and calculating the inclusion proportion (IP) on the null model.
The final result displayed is the original model's IP minus the null IP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permVimp(model, data, response, numTreesPerm = NULL, plotType = "barplot")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permVimp_+3A_model">model</code></td>
<td>
<p>Model created from either the BART, dbarts or bartMachine packages.</p>
</td></tr>
<tr><td><code id="permVimp_+3A_data">data</code></td>
<td>
<p>A data frame containing variables in the model.</p>
</td></tr>
<tr><td><code id="permVimp_+3A_response">response</code></td>
<td>
<p>The name of the response for the fit.</p>
</td></tr>
<tr><td><code id="permVimp_+3A_numtreesperm">numTreesPerm</code></td>
<td>
<p>The number of trees to be used in the null model.
As suggested by Chipman (2009), a small number of trees is recommended (~20) to force important
variables to used in the model. If NULL, then the number of trees from the true model is used.</p>
</td></tr>
<tr><td><code id="permVimp_+3A_plottype">plotType</code></td>
<td>
<p>Either a bar plot ('barplot') or a point plot ('point')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variable selection plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("dbarts", quietly = TRUE)) {
 # Load the dbarts package to access the bart function
 library(dbarts)
 # Get Data
 df &lt;- na.omit(airquality)
 # Create Simple dbarts Model For Regression:
 set.seed(1701)
 dbartModel &lt;- bart(df[2:6],
   df[, 1],
   ntree = 5,
   keeptrees = TRUE,
   nskip = 10,
   ndpost = 10
 )
 # Tree Data
 trees_data &lt;- extractTreeData(model = dbartModel, data = df)
 permVimp(model = dbartModel, data = df, response = 'Ozone', numTreesPerm = 2, plotType = 'point')
}

</code></pre>

<hr>
<h2 id='permVint'>permVint</h2><span id='topic+permVint'></span>

<h3>Description</h3>

<p>A variable interaction evaluation which creates a null model by
permuting the response, rebuilding the model, and calculating the inclusion proportion (IP)
of adjacent splits on the null model.
The final result displayed is the original model's IP minus the null IP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permVint(model, data, trees, response, numTreesPerm = NULL, top = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permVint_+3A_model">model</code></td>
<td>
<p>Model created from either the BART, dbarts or bartMachine packages.</p>
</td></tr>
<tr><td><code id="permVint_+3A_data">data</code></td>
<td>
<p>A data frame containing variables in the model.</p>
</td></tr>
<tr><td><code id="permVint_+3A_trees">trees</code></td>
<td>
<p>A data frame created by extractTreeData function.</p>
</td></tr>
<tr><td><code id="permVint_+3A_response">response</code></td>
<td>
<p>The name of the response for the fit.</p>
</td></tr>
<tr><td><code id="permVint_+3A_numtreesperm">numTreesPerm</code></td>
<td>
<p>The number of trees to be used in the null model.
As suggested by Chipman (2009), a small number of trees is recommended (~20) to force important
variables to used in the model. If NULL, then the number of trees from the true model is used.</p>
</td></tr>
<tr><td><code id="permVint_+3A_top">top</code></td>
<td>
<p>Display only the top X interactions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variable interaction plot. Note that for a dbarts fit, due to the internal workings of
dbarts, the null model is hard-coded to 20 trees, a burn-in of 100, and 1000 iterations. Both a
BART and bartMachine null model will extract the identical parameters from the original model.
</p>

<hr>
<h2 id='plotProximity'>plotProximity</h2><span id='topic+plotProximity'></span>

<h3>Description</h3>

<p>Plot a proximity matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotProximity(
  matrix,
  pal = rev(colorspace::sequential_hcl(palette = "Blues 2", n = 100)),
  limit = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotProximity_+3A_matrix">matrix</code></td>
<td>
<p>A matrix of proximities created by the proximityMatrix function</p>
</td></tr>
<tr><td><code id="plotProximity_+3A_pal">pal</code></td>
<td>
<p>A vector of colours to show proximity scores, for use with scale_fill_gradientn.</p>
</td></tr>
<tr><td><code id="plotProximity_+3A_limit">limit</code></td>
<td>
<p>Specifies the fit range for the color map for proximity scores.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of proximity values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("dbarts", quietly = TRUE)){
 # Load the dbarts package to access the bart function
 library(dbarts)
 # Get Data
 df &lt;- na.omit(airquality)
 # Create Simple dbarts Model For Regression:
 set.seed(1701)
 dbartModel &lt;- bart(df[2:6],
   df[, 1],
   ntree = 5,
   keeptrees = TRUE,
   nskip = 10,
   ndpost = 10)
 # Tree Data
 trees_data &lt;- extractTreeData(model = dbartModel, data = df)
 # Create Proximity Matrix
 mProx &lt;- proximityMatrix(trees = trees_data, reorder = TRUE, normalize = TRUE, iter = 1)
 # Plot
 plotProximity(matrix = mProx)
}
</code></pre>

<hr>
<h2 id='plotSingleTree'>plotSingleTree</h2><span id='topic+plotSingleTree'></span>

<h3>Description</h3>

<p>Plots individual trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSingleTree(trees, iter = 1, treeNo = 1, plotType = "icicle")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotSingleTree_+3A_trees">trees</code></td>
<td>
<p>A data frame created by <code>extractTreeData</code> function</p>
</td></tr>
<tr><td><code id="plotSingleTree_+3A_iter">iter</code></td>
<td>
<p>The MCMC iteration or chain to plot.</p>
</td></tr>
<tr><td><code id="plotSingleTree_+3A_treeno">treeNo</code></td>
<td>
<p>The tree number to plot.</p>
</td></tr>
<tr><td><code id="plotSingleTree_+3A_plottype">plotType</code></td>
<td>
<p>What type of plot to display. either dendrogram or icicle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of an individual tree
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("dbarts", quietly = TRUE)) {
 # Load the dbarts package to access the bart function
 library(dbarts)
 # Get Data
 df &lt;- na.omit(airquality)
 # Create Simple dbarts Model For Regression:
 set.seed(1701)
 dbartModel &lt;- bart(df[2:6],
   df[, 1],
   ntree = 5,
   keeptrees = TRUE,
   nskip = 10,
   ndpost = 10
 )
 # Tree Data
 trees_data &lt;- extractTreeData(model = dbartModel, data = df)
 plotSingleTree(trees = trees_data, iter = 1, treeNo = 1)
}
</code></pre>

<hr>
<h2 id='plotTrees'>Plot Trees with Customisations</h2><span id='topic+plotTrees'></span>

<h3>Description</h3>

<p>This function plots trees from a list of tidygraph objects. It allows for various
customisations such as fill colour based on node response or value, node size adjustments,
and color palettes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTrees(
  trees,
  iter = NULL,
  treeNo = NULL,
  fillBy = NULL,
  sizeNodes = FALSE,
  removeStump = FALSE,
  selectedVars = NULL,
  pal = rev(colorRampPalette(c("steelblue", "#f7fcfd", "orange"))(5)),
  center_Mu = TRUE,
  cluster = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotTrees_+3A_trees">trees</code></td>
<td>
<p>A data frame of trees.</p>
</td></tr>
<tr><td><code id="plotTrees_+3A_iter">iter</code></td>
<td>
<p>An integer specifying the iteration number of trees to be included in the output.
If NULL, trees from all iterations are included.</p>
</td></tr>
<tr><td><code id="plotTrees_+3A_treeno">treeNo</code></td>
<td>
<p>An integer specifying the number of the tree to include in the output.
If NULL, all trees are included.</p>
</td></tr>
<tr><td><code id="plotTrees_+3A_fillby">fillBy</code></td>
<td>
<p>A character string specifying the attribute to color nodes by.
Options are 'response' for coloring nodes based on their mean response values or
'mu' for coloring nodes based on their predicted value, or NULL for no
specific fill attribute.</p>
</td></tr>
<tr><td><code id="plotTrees_+3A_sizenodes">sizeNodes</code></td>
<td>
<p>A logical value indicating whether to adjust node sizes.
If TRUE, node sizes are adjusted; if FALSE, all nodes are given the same size.</p>
</td></tr>
<tr><td><code id="plotTrees_+3A_removestump">removeStump</code></td>
<td>
<p>A logical value. If TRUE, then stumps are removed from plot.</p>
</td></tr>
<tr><td><code id="plotTrees_+3A_selectedvars">selectedVars</code></td>
<td>
<p>A vector of selected variables to display. Either a character vector of names
or the variables column number.</p>
</td></tr>
<tr><td><code id="plotTrees_+3A_pal">pal</code></td>
<td>
<p>A colour palette for node colouring. Palette is used when 'fillBy' is specified for gradient colouring.</p>
</td></tr>
<tr><td><code id="plotTrees_+3A_center_mu">center_Mu</code></td>
<td>
<p>A logical value indicating whether to center the color scale for the 'mu'
attribute around zero. Applicable only when 'fillBy' is set to &quot;mu&quot;.</p>
</td></tr>
<tr><td><code id="plotTrees_+3A_cluster">cluster</code></td>
<td>
<p>A character string that specifies the criterion for reordering trees in the output.
Currently supports &quot;depth&quot; for ordering by the maximum depth of nodes, and &quot;var&quot; for a
clustering based on variables. If NULL, no reordering is performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object representing the plotted trees with the specified customisations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("dbarts", quietly = TRUE)) {
 # Load the dbarts package to access the bart function
 library(dbarts)
 # Get Data
 df &lt;- na.omit(airquality)
 # Create Simple dbarts Model For Regression:
 set.seed(1701)
 dbartModel &lt;- bart(df[2:6],
   df[, 1],
   ntree = 5,
   keeptrees = TRUE,
   nskip = 10,
   ndpost = 10
 )
 # Tree Data
 trees_data &lt;- extractTreeData(model = dbartModel, data = df)
 plotTrees(trees = trees_data, fillBy = 'response', sizeNodes = TRUE)
}

</code></pre>

<hr>
<h2 id='print.hideHelper1'>print.hideHelper</h2><span id='topic+print.hideHelper1'></span>

<h3>Description</h3>

<p>This function hides parts from the print out
but are still accessible via indexing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hideHelper1'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.hideHelper1_+3A_x">x</code></td>
<td>
<p>A data frame of trees</p>
</td></tr>
<tr><td><code id="print.hideHelper1_+3A_...">...</code></td>
<td>
<p>Extra parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value; this function is called for its side effect of printing a formatted summary
of the tree data frame. It displays parts of the data frame, such as the tree structure and various
counts (like number of MCMC iterations, number of trees, and number of variables), while keeping
the complete data accessible via indexing.
</p>

<hr>
<h2 id='proximityMatrix'>proximityMatrix</h2><span id='topic+proximityMatrix'></span>

<h3>Description</h3>

<p>Creates a matrix of proximity values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proximityMatrix(trees, nRows, normalize = TRUE, reorder = TRUE, iter = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="proximityMatrix_+3A_trees">trees</code></td>
<td>
<p>A list of tree attributes created by 'extractTreeData' function.</p>
</td></tr>
<tr><td><code id="proximityMatrix_+3A_nrows">nRows</code></td>
<td>
<p>Number of rows to consider.</p>
</td></tr>
<tr><td><code id="proximityMatrix_+3A_normalize">normalize</code></td>
<td>
<p>Default is TRUE. Divide the total number of pairs of observations by
the number of trees.</p>
</td></tr>
<tr><td><code id="proximityMatrix_+3A_reorder">reorder</code></td>
<td>
<p>Default is TRUE. Whether to sort the matrix so high values are pushed to top left.</p>
</td></tr>
<tr><td><code id="proximityMatrix_+3A_iter">iter</code></td>
<td>
<p>Which iteration to use, if NULL the proximity matrix is calculated over all
iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing proximity values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("dbarts", quietly = TRUE)){
 # Load the dbarts package to access the bart function
 library(dbarts)
 # Get Data
 df &lt;- na.omit(airquality)
 # Create Simple dbarts Model For Regression:
 set.seed(1701)
 dbartModel &lt;- bart(df[2:6], df[, 1], ntree = 5, keeptrees = TRUE, nskip = 10, ndpost = 10)

 # Tree Data
 trees_data &lt;- extractTreeData(model = dbartModel, data = df)
 # Create Proximity Matrix
 mProx &lt;- proximityMatrix(trees = trees_data, reorder = TRUE, normalize = TRUE, iter = 1)
}
</code></pre>

<hr>
<h2 id='RangeBivariate'>Constructor for bivariate range object</h2><span id='topic+RangeBivariate'></span><span id='topic+bivariate_range'></span>

<h3>Description</h3>

<p>Constructor for bivariate range object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bivariate_range()
</code></pre>


<h3>Format</h3>

<p>An object of class <code>RangeBivariate</code> (inherits from <code>Range</code>, <code>ggproto</code>, <code>gg</code>) of length 2.
</p>

<hr>
<h2 id='ScaleBivariate'>Constructor for bivariate scale object</h2><span id='topic+ScaleBivariate'></span><span id='topic+bivariate_scale'></span>

<h3>Description</h3>

<p>Constructor for bivariate scale object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bivariate_scale(
  aesthetics,
  palette,
  name = waiver(),
  breaks = waiver(),
  labels = waiver(),
  limits = NULL,
  rescaler = scales::rescale,
  oob = scales::censor,
  expand = waiver(),
  na.value = NA_real_,
  trans = "identity",
  guide = "none",
  super = ScaleBivariate,
  scale_name = "bivariate_scale"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ScaleBivariate_+3A_aesthetics">aesthetics</code></td>
<td>
<p>The names of the aesthetics that this scale works with.</p>
</td></tr>
<tr><td><code id="ScaleBivariate_+3A_palette">palette</code></td>
<td>
<p>A palette function that when called with a numeric vector with
values between 0 and 1 returns the corresponding output values
(e.g., <code><a href="scales.html#topic+pal_area">scales::pal_area()</a></code>).</p>
</td></tr>
<tr><td><code id="ScaleBivariate_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="ScaleBivariate_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no breaks
</p>
</li>
<li> <p><code>waiver()</code> for the default breaks computed by the
<a href="scales.html#topic+new_transform">transformation object</a>
</p>
</li>
<li><p> A numeric vector of positions
</p>
</li>
<li><p> A function that takes the limits as input and returns breaks
as output (e.g., a function returned by <code><a href="scales.html#topic+breaks_extended">scales::extended_breaks()</a></code>).
Note that for position scales, limits are provided after scale expansion.
Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ScaleBivariate_+3A_labels">labels</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ScaleBivariate_+3A_limits">limits</code></td>
<td>
<p>Data frame with two columns of length two each defining the limits for the two data dimensions.</p>
</td></tr>
<tr><td><code id="ScaleBivariate_+3A_rescaler">rescaler</code></td>
<td>
<p>Either one rescaling function applied to both data dimensions or list of two rescaling functions,
one for each data dimension.</p>
</td></tr>
<tr><td><code id="ScaleBivariate_+3A_oob">oob</code></td>
<td>
<p>One of:
</p>

<ul>
<li><p> Function that handles limits outside of the scale limits
(out of bounds). Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a>
function notation.
</p>
</li>
<li><p> The default (<code><a href="scales.html#topic+oob">scales::censor()</a></code>) replaces out of
bounds values with <code>NA</code>.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish()</a></code> for squishing out of bounds values into range.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish_infinite()</a></code> for squishing infinite values into range.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ScaleBivariate_+3A_expand">expand</code></td>
<td>
<p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="ggplot2.html#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</td></tr>
<tr><td><code id="ScaleBivariate_+3A_na.value">na.value</code></td>
<td>
<p>Missing values will be replaced with this value.</p>
</td></tr>
<tr><td><code id="ScaleBivariate_+3A_trans">trans</code></td>
<td>
<p>Either one transformation applied to both data dimensions or list of two transformations, one
for each data dimension. Transformations can be given as either the name of a transformation object
or the object itself. See ['ggplot2::continuous_scale()'] for details.</p>
</td></tr>
<tr><td><code id="ScaleBivariate_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="ggplot2.html#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="ScaleBivariate_+3A_super">super</code></td>
<td>
<p>The super class to use for the constructed scale</p>
</td></tr>
<tr><td><code id="ScaleBivariate_+3A_scale_name">scale_name</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The name of the scale
that should be used for error messages associated with this scale.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>ScaleBivariate</code> (inherits from <code>Scale</code>, <code>ggproto</code>, <code>gg</code>) of length 15.
</p>

<hr>
<h2 id='sort_trees_by_depthMax'>Sort Trees by Maximum Depth</h2><span id='topic+sort_trees_by_depthMax'></span>

<h3>Description</h3>

<p>Sort Trees by Maximum Depth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_trees_by_depthMax(tree_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sort_trees_by_depthMax_+3A_tree_list">tree_list</code></td>
<td>
<p>List of 'tbl_graph' trees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sorted list of 'tbl_graph' trees by decreasing maximum depth.
</p>

<hr>
<h2 id='splitDensity'>splitDensity</h2><span id='topic+splitDensity'></span>

<h3>Description</h3>

<p>Density plots of the split value for each variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitDensity(
  trees,
  data,
  bandWidth = NULL,
  panelScale = NULL,
  scaleFactor = NULL,
  display = "histogram"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splitDensity_+3A_trees">trees</code></td>
<td>
<p>A list of trees created using the trees function.</p>
</td></tr>
<tr><td><code id="splitDensity_+3A_data">data</code></td>
<td>
<p>Data frame containing variables from the model.</p>
</td></tr>
<tr><td><code id="splitDensity_+3A_bandwidth">bandWidth</code></td>
<td>
<p>Bandwidth used for density calculation. If not provided, is estimated from the data.</p>
</td></tr>
<tr><td><code id="splitDensity_+3A_panelscale">panelScale</code></td>
<td>
<p>If TRUE, the default, relative scaling is calculated separately for each panel.
If FALSE, relative scaling is calculated globally.
@param scaleFactor A scaling factor to scale the height of the ridgelines relative to the spacing between them.
A value of 1 indicates that the maximum point of any ridgeline touches the baseline right above,
assuming even spacing between baselines.</p>
</td></tr>
<tr><td><code id="splitDensity_+3A_scalefactor">scaleFactor</code></td>
<td>
<p>A numerical value to scale the plot.</p>
</td></tr>
<tr><td><code id="splitDensity_+3A_display">display</code></td>
<td>
<p>Choose how to display the plot. Either histogram, facet wrap, ridges
or display both the split value and density of the predictor by using dataSplit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A faceted group of density plots
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("dbarts", quietly = TRUE)){
 # Load the dbarts package to access the bart function
 library(dbarts)
 # Get Data
 df &lt;- na.omit(airquality)
 # Create Simple dbarts Model For Regression:
 set.seed(1701)
 dbartModel &lt;- bart(df[2:6], df[, 1], ntree = 5, keeptrees = TRUE, nskip = 10, ndpost = 10)

 # Tree Data
 trees_data &lt;- extractTreeData(model = dbartModel, data = df)
 splitDensity(trees = trees_data, data = df, display = 'ridge')
}

</code></pre>

<hr>
<h2 id='terminalFunction'>Generate Terminal Node Indicator</h2><span id='topic+terminalFunction'></span>

<h3>Description</h3>

<p>Adds a boolean 'terminal' column to the dataset indicating whether each node is terminal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>terminalFunction(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="terminalFunction_+3A_data">data</code></td>
<td>
<p>A data frame containing tree structure information with at least 'treeNum',
'iteration', and 'depth' columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified data frame with an additional 'terminal' column.
</p>

<hr>
<h2 id='train_bivariate'>Train range for bivariate scale</h2><span id='topic+train_bivariate'></span>

<h3>Description</h3>

<p>Train range for bivariate scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>train_bivariate(new, existing = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="train_bivariate_+3A_new">new</code></td>
<td>
<p>New data on which to train.</p>
</td></tr>
<tr><td><code id="train_bivariate_+3A_existing">existing</code></td>
<td>
<p>Existing range</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing two columns, 'range1' and 'range2', each representing the trained
continuous range based on the new and existing data. This function is used to update or define
the scales of a bivariate analysis by considering both new input data and any existing range
specifications.
</p>

<hr>
<h2 id='tree_data_example'>tree_data_example</h2><span id='topic+tree_data_example'></span>

<h3>Description</h3>

<p>Small example of tree data, like that obtained when using 'extractTreeData()' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_data_example
</code></pre>


<h3>Format</h3>

<p>A data frame with 14 rows and 4 columns representing the structure of trees:
</p>

<dl>
<dt>var</dt><dd><p>Variable name used for splitting.</p>
</dd>
<dt>value</dt><dd><p>The value in a node (i.e., either the split value or leaf value).</p>
</dd>
<dt>iteration</dt><dd><p>Iteration Number.</p>
</dd>
<dt>treeNum</dt><dd><p>Tree Number in the iteration.</p>
</dd>
</dl>
<p>...

</p>

<hr>
<h2 id='tree_dataframe'>Transform tree data into a structured dataframe</h2><span id='topic+tree_dataframe'></span>

<h3>Description</h3>

<p>This function takes raw data and a tree structure, then processes it to form a detailed and structured dataframe.
The data is transformed to indicate terminal nodes, calculate leaf values, and determine split values. It then
assigns labels, calculates node depth, and establishes hierarchical relationships within the tree.
Additional metadata about the tree, such as maximum depth, parent and child node relationships, and observation
nodes are also included. The final dataframe is organized and enriched with necessary attributes for further analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_dataframe(data, trees, response = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tree_dataframe_+3A_data">data</code></td>
<td>
<p>A dataframe containing the raw data used for building the tree.</p>
</td></tr>
<tr><td><code id="tree_dataframe_+3A_trees">trees</code></td>
<td>
<p>A dataframe representing the initial tree structure, including variables and values for splits.</p>
</td></tr>
<tr><td><code id="tree_dataframe_+3A_response">response</code></td>
<td>
<p>Optional character of the name of the response variable in your BART model. Including the response
will remove it from the list elements 'Variable names' and 'nVar'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a detailed dataframe of the tree structure ('structure') with added information such as
node depth, parent and child nodes, and observational data, along with meta-information about the tree like
variable names ('varNames'), number of MCMC iterations ('nMCMC'), number of trees ('nTree'), and number of variables ('nVar').
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("input_data")
data("tree_data_example")
my_trees &lt;- tree_dataframe(data = input_data, trees = tree_data_example, response = "y")

</code></pre>

<hr>
<h2 id='treeBarPlot'>Plot Frequency of Tree Structures</h2><span id='topic+treeBarPlot'></span>

<h3>Description</h3>

<p>Generates a bar plot showing the frequency of different tree structures
represented in a list of tree graphs. Optionally, it can filter to show only the top N trees
and handle stump trees specially.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeBarPlot(trees, iter = NULL, topTrees = NULL, removeStump = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treeBarPlot_+3A_trees">trees</code></td>
<td>
<p>A list of tree graphs to display</p>
</td></tr>
<tr><td><code id="treeBarPlot_+3A_iter">iter</code></td>
<td>
<p>Optional; specifies the iteration to display.</p>
</td></tr>
<tr><td><code id="treeBarPlot_+3A_toptrees">topTrees</code></td>
<td>
<p>Optional; the number of top tree structures to display. If NULL, displays all.</p>
</td></tr>
<tr><td><code id="treeBarPlot_+3A_removestump">removeStump</code></td>
<td>
<p>Logical; if TRUE, trees with no edges (stumps) are excluded from the display</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function processes a list of tree structures to compute the frequency of each unique structure,
represented by a bar plot. It has options to exclude stump trees (trees with no edges) and to limit
the plot to the top N most frequent structures.
</p>


<h3>Value</h3>

<p>A 'ggplot' object representing the bar plot of tree frequencies.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("dbarts", quietly = TRUE)){
 # Load the dbarts package to access the bart function
 library(dbarts)
 # Get Data
 df &lt;- na.omit(airquality)
 # Create Simple dbarts Model For Regression:
 set.seed(1701)
 dbartModel &lt;- bart(df[2:6], df[, 1], ntree = 5, keeptrees = TRUE, nskip = 10, ndpost = 10)

 # Tree Data
 trees_data &lt;- extractTreeData(model = dbartModel, data = df)
 plot &lt;- treeBarPlot(trees = trees_data, topTrees = 3, removeStump = TRUE)
}

</code></pre>

<hr>
<h2 id='treeDepth'>treeDepth</h2><span id='topic+treeDepth'></span>

<h3>Description</h3>

<p>A plot of tree depth over iterations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeDepth(trees)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treeDepth_+3A_trees">trees</code></td>
<td>
<p>A list of tree attributes created using the extractTreeData function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of average tree depths over iteration
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("dbarts", quietly = TRUE)){
 # Load the dbarts package to access the bart function
 library(dbarts)
 # Get Data
 df &lt;- na.omit(airquality)
 # Create Simple dbarts Model For Regression:
 set.seed(1701)
 dbartModel &lt;- bart(df[2:6], df[, 1], ntree = 5, keeptrees = TRUE, nskip = 10, ndpost = 10)

 # Tree Data
 trees_data &lt;- extractTreeData(model = dbartModel, data = df)
 treeDepth(trees = trees_data)
}

</code></pre>

<hr>
<h2 id='treeList'>Generate a List of Tree Structures from BART Model Output</h2><span id='topic+treeList'></span>

<h3>Description</h3>

<p>This function takes a dataframe of trees, which is output from a BART model, and organizes
it into a list of tree structures. It allows for filtering based on iteration number, tree
number, and optionally reordering based on the maximum depth of nodes or variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeList(trees, iter = NULL, treeNo = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treeList_+3A_trees">trees</code></td>
<td>
<p>A dataframe that contains the tree structures generated by a BART model.
Expected columns include iteration, treeNum, parent, node, obsNode,</p>
</td></tr>
<tr><td><code id="treeList_+3A_iter">iter</code></td>
<td>
<p>An integer specifying the iteration number of trees to be included in the output.
If NULL, trees from all iterations are included.</p>
</td></tr>
<tr><td><code id="treeList_+3A_treeno">treeNo</code></td>
<td>
<p>An integer specifying the number of the tree to include in the output.
If NULL, all trees are included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of tidygraph objects, each representing the structure of a tree. Each tidygraph object includes
node and edge information necessary for visualisation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("dbarts", quietly = TRUE)){
 # Load the dbarts package to access the bart function
 library(dbarts)
 library(ggplot2)
 # Get Data
 df &lt;- na.omit(airquality)
 # Create Simple dbarts Model For Regression:
 set.seed(1701)
 dbartModel &lt;- bart(df[2:6], df[, 1], ntree = 5, keeptrees = TRUE, nskip = 10, ndpost = 10)

 # Tree Data
 trees_data &lt;- extractTreeData(model = dbartModel, data = df)
 trees_list &lt;- treeList(trees_data)
}

</code></pre>

<hr>
<h2 id='treeNodes'>treeNodes</h2><span id='topic+treeNodes'></span>

<h3>Description</h3>

<p>A plot of number of nodes over iterations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeNodes(trees)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treeNodes_+3A_trees">trees</code></td>
<td>
<p>A list of tree attributes created using the extractTreeData function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of tree number of nodes over iterations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("dbarts", quietly = TRUE)){
 # Load the dbarts package to access the bart function
 library(dbarts)
 # Get Data
 df &lt;- na.omit(airquality)
 # Create Simple dbarts Model For Regression:
 set.seed(1701)
 dbartModel &lt;- bart(df[2:6], df[, 1], ntree = 5, keeptrees = TRUE, nskip = 10, ndpost = 10)

 # Tree Data
 trees_data &lt;- extractTreeData(model = dbartModel, data = df)
 treeNodes(trees = trees_data)
}

</code></pre>

<hr>
<h2 id='vimpBart'>vimpBart</h2><span id='topic+vimpBart'></span>

<h3>Description</h3>

<p>A matrix with nMCMC rows with each variable as a column.
Each row represents an MCMC iteration. For each variable, the total count
of the number of times that variable is used in a tree is given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vimpBart(trees, type = "prop")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vimpBart_+3A_trees">trees</code></td>
<td>
<p>A data frame created by 'extractTreeData' function.</p>
</td></tr>
<tr><td><code id="vimpBart_+3A_type">type</code></td>
<td>
<p>What value to return. Either the raw count 'val', the proportion 'prop',
the column means of the proportions 'propMean', or the median of the proportions 'propMedian'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of importance values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("dbarts", quietly = TRUE)){
 # Load the dbarts package to access the bart function
 library(dbarts)
 # Get Data
 df &lt;- na.omit(airquality)
 # Create Simple dbarts Model For Regression:
 set.seed(1701)
 dbartModel &lt;- bart(df[2:6], df[, 1], ntree = 5, keeptrees = TRUE, nskip = 10, ndpost = 10)

 # Tree Data
 trees_data &lt;- extractTreeData(model = dbartModel, data = df)
 vimpBart(trees_data, type = 'prop')
 }
</code></pre>

<hr>
<h2 id='vimpPlot'>vimpPlot</h2><span id='topic+vimpPlot'></span>

<h3>Description</h3>

<p>Plot the variable importance for a BART model with the 25
quantile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vimpPlot(trees, type = "prop", plotType = "barplot", metric = "median")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vimpPlot_+3A_trees">trees</code></td>
<td>
<p>A data frame created by 'extractTreeData' function.</p>
</td></tr>
<tr><td><code id="vimpPlot_+3A_type">type</code></td>
<td>
<p>What value to return. Either the raw count 'count'
or the proportions 'prop' averaged over iterations.</p>
</td></tr>
<tr><td><code id="vimpPlot_+3A_plottype">plotType</code></td>
<td>
<p>Which type of plot to return. Either a barplot 'barplot' with the
quantiles shown as a line, a point plot with the quantiles shown as a gradient 'point', or a
letter-value plot 'lvp'.</p>
</td></tr>
<tr><td><code id="vimpPlot_+3A_metric">metric</code></td>
<td>
<p>Whether to show the 'mean' or 'median' importance values. Note, this has
no effect when using plotType = 'lvp'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of variable importance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("dbarts", quietly = TRUE)){
 # Load the dbarts package to access the bart function
 library(dbarts)
 # Get Data
 df &lt;- na.omit(airquality)
 # Create Simple dbarts Model For Regression:
 set.seed(1701)
 dbartModel &lt;- bart(df[2:6], df[, 1], ntree = 5, keeptrees = TRUE, nskip = 10, ndpost = 10)

 # Tree Data
 trees_data &lt;- extractTreeData(model = dbartModel, data = df)
 vimpPlot(trees = trees_data, plotType = 'point')
}

</code></pre>

<hr>
<h2 id='vintPlot'>vintPlot</h2><span id='topic+vintPlot'></span>

<h3>Description</h3>

<p>Plot the pair-wise variable interactions inclusion porportions
for a BART model with the 25
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vintPlot(trees, plotType = "barplot", top = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vintPlot_+3A_trees">trees</code></td>
<td>
<p>A data frame created by 'extractTreeData' function.</p>
</td></tr>
<tr><td><code id="vintPlot_+3A_plottype">plotType</code></td>
<td>
<p>Which type of plot to return. Either a barplot 'barplot' with the
quantiles shown as a line, a point plot with the quantiles shown as a gradient 'point', or a
letter-value plot 'lvp'.</p>
</td></tr>
<tr><td><code id="vintPlot_+3A_top">top</code></td>
<td>
<p>Display only the top X metrics (does not apply to the letter-value plot).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of variable importance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("dbarts", quietly = TRUE)){
 # Load the dbarts package to access the bart function
 library(dbarts)
 # Get Data
 df &lt;- na.omit(airquality)
 # Create Simple dbarts Model For Regression:
 set.seed(1701)
 dbartModel &lt;- bart(df[2:6], df[, 1], ntree = 5, keeptrees = TRUE, nskip = 10, ndpost = 10)

 # Tree Data
 trees_data &lt;- extractTreeData(model = dbartModel, data = df)
 vintPlot(trees = trees_data, top = 5)
}
</code></pre>

<hr>
<h2 id='viviBart'>viviBart</h2><span id='topic+viviBart'></span>

<h3>Description</h3>

<p>Returns a list containing a dataframe of variable importance summaries
and a dataframe of variable interaction summaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viviBart(trees, out = "vivi")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="viviBart_+3A_trees">trees</code></td>
<td>
<p>A data frame created by 'extractTreeData' function.</p>
</td></tr>
<tr><td><code id="viviBart_+3A_out">out</code></td>
<td>
<p>Choose to either output just the variable importance ('vimp'),
the variable interaction ('vint'), or both ('vivi') (default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of dataframes of VIVI summaries.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("dbarts", quietly = TRUE)){
 # Load the dbarts package to access the bart function
 library(dbarts)
 # Get Data
 df &lt;- na.omit(airquality)
 # Create Simple dbarts Model For Regression:
 set.seed(1701)
 dbartModel &lt;- bart(df[2:6], df[, 1], ntree = 5, keeptrees = TRUE, nskip = 10, ndpost = 10)

 # Tree Data
 trees_data &lt;- extractTreeData(model = dbartModel, data = df)
 viviBart(trees = trees_data, out = 'vivi')
 }


</code></pre>

<hr>
<h2 id='viviBartMatrix'>viviBartMatrix</h2><span id='topic+viviBartMatrix'></span>

<h3>Description</h3>

<p>Returns a matrix or list of matrices. If type = 'standard' a
matrix filled with vivi values is returned. If type = 'vsup' two matrices are returned.
One with the actual values and another matrix of uncertainty values.
If type = 'quantiles', three matrices are returned. One for the 25
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viviBartMatrix(
  trees,
  type = "standard",
  metric = "propMean",
  metricError = "CV",
  reorder = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="viviBartMatrix_+3A_trees">trees</code></td>
<td>
<p>A data frame created by 'extractTreeData' function.</p>
</td></tr>
<tr><td><code id="viviBartMatrix_+3A_type">type</code></td>
<td>
<p>Which type of matrix to return. Either 'standard', 'vsup', 'quantiles'</p>
</td></tr>
<tr><td><code id="viviBartMatrix_+3A_metric">metric</code></td>
<td>
<p>Which metric to use to fill the actual values matrix. Either 'propMean' or 'count'.</p>
</td></tr>
<tr><td><code id="viviBartMatrix_+3A_metricerror">metricError</code></td>
<td>
<p>Which metric to use to fill the uncertainty matrix. Either 'SD', 'CV' or 'SE'.</p>
</td></tr>
<tr><td><code id="viviBartMatrix_+3A_reorder">reorder</code></td>
<td>
<p>LOGICAL. If TRUE then the matrix is reordered so high values are pushed to the top left.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A heatmap plot showing variable importance on the diagonal
and variable interaction on the off-diagonal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("dbarts", quietly = TRUE)){
 # Load the dbarts package to access the bart function
 library(dbarts)
 # Get Data
 df &lt;- na.omit(airquality)
 # Create Simple dbarts Model For Regression:
 set.seed(1701)
 dbartModel &lt;- bart(df[2:6], df[, 1], ntree = 5, keeptrees = TRUE, nskip = 10, ndpost = 10)

 # Tree Data
 trees_data &lt;- extractTreeData(model = dbartModel, data = df)

 # VSUP Matrix
 vsupMat &lt;- viviBartMatrix(trees = trees_data,
                           type = 'vsup',
                           metric = 'propMean',
                            metricError = 'CV')
 }

</code></pre>

<hr>
<h2 id='viviBartPlot'>viviBartPlot</h2><span id='topic+viviBartPlot'></span>

<h3>Description</h3>

<p>Plots a Heatmap showing variable importance on the diagonal
and variable interaction on the off-diagonal with uncertainty included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viviBartPlot(
  matrix,
  intPal = NULL,
  impPal = NULL,
  intLims = NULL,
  impLims = NULL,
  uncIntLims = NULL,
  uncImpLims = NULL,
  unc_levels = 4,
  max_desat = 0.6,
  pow_desat = 0.2,
  max_light = 0.6,
  pow_light = 1,
  angle = 0,
  border = FALSE,
  label = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="viviBartPlot_+3A_matrix">matrix</code></td>
<td>
<p>Matrices, such as that returned by viviBartMatrix, of values to be plotted.</p>
</td></tr>
<tr><td><code id="viviBartPlot_+3A_intpal">intPal</code></td>
<td>
<p>A vector of colours to show interactions, for use with scale_fill_gradientn. Palette number has to be 2^x/2</p>
</td></tr>
<tr><td><code id="viviBartPlot_+3A_imppal">impPal</code></td>
<td>
<p>A vector of colours to show importance, for use with scale_fill_gradientn. Palette number has to be 2^x/2</p>
</td></tr>
<tr><td><code id="viviBartPlot_+3A_intlims">intLims</code></td>
<td>
<p>Specifies the fit range for the color map for interaction strength.</p>
</td></tr>
<tr><td><code id="viviBartPlot_+3A_implims">impLims</code></td>
<td>
<p>Specifies the fit range for the color map for importance.</p>
</td></tr>
<tr><td><code id="viviBartPlot_+3A_uncintlims">uncIntLims</code></td>
<td>
<p>Specifies the fit range for the color map for interaction strength uncertainties.</p>
</td></tr>
<tr><td><code id="viviBartPlot_+3A_uncimplims">uncImpLims</code></td>
<td>
<p>Specifies the fit range for the color map for importance uncertainties.</p>
</td></tr>
<tr><td><code id="viviBartPlot_+3A_unc_levels">unc_levels</code></td>
<td>
<p>The number of uncertainty levels</p>
</td></tr>
<tr><td><code id="viviBartPlot_+3A_max_desat">max_desat</code></td>
<td>
<p>The maximum desaturation level.</p>
</td></tr>
<tr><td><code id="viviBartPlot_+3A_pow_desat">pow_desat</code></td>
<td>
<p>The power of desaturation level.</p>
</td></tr>
<tr><td><code id="viviBartPlot_+3A_max_light">max_light</code></td>
<td>
<p>The maximum light level.</p>
</td></tr>
<tr><td><code id="viviBartPlot_+3A_pow_light">pow_light</code></td>
<td>
<p>The power of light level.</p>
</td></tr>
<tr><td><code id="viviBartPlot_+3A_angle">angle</code></td>
<td>
<p>The angle to rotate the x-axis labels. Defaults to zero.</p>
</td></tr>
<tr><td><code id="viviBartPlot_+3A_border">border</code></td>
<td>
<p>Logical. If TRUE then draw a black border around the diagonal elements.</p>
</td></tr>
<tr><td><code id="viviBartPlot_+3A_label">label</code></td>
<td>
<p>legend label for the uncertainty measure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a heatmap, VSUP, or quantile heatmap plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("dbarts", quietly = TRUE)){
 # Load the dbarts package to access the bart function
 library(dbarts)
 # Get Data
 df &lt;- na.omit(airquality)
 # Create Simple dbarts Model For Regression:
 set.seed(1701)
 dbartModel &lt;- bart(df[2:6], df[, 1], ntree = 5, keeptrees = TRUE, nskip = 10, ndpost = 10)

 # Tree Data
 trees_data &lt;- extractTreeData(model = dbartModel, data = df)

 # VSUP Matrix
 vsupMat &lt;- viviBartMatrix(trees = trees_data,
                           type = 'vsup',
                           metric = 'propMean',
                           metricError = 'CV')
 # Plot
 viviBartPlot(vsupMat, label = 'CV')
 }


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
