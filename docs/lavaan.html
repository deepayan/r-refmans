<!DOCTYPE html><html lang="en"><head><title>Help for package lavaan</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lavaan}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bootstrapLavaan'><p>Bootstrapping a Lavaan Model</p></a></li>
<li><a href='#cfa'><p>Fit Confirmatory Factor Analysis Models</p></a></li>
<li><a href='#Demo.growth'>
<p>Demo dataset for a illustrating a linear growth model.</p></a></li>
<li><a href='#Demo.twolevel'>
<p>Demo dataset for a illustrating a multilevel CFA.</p></a></li>
<li><a href='#efa'><p>Exploratory Factor Analysis</p></a></li>
<li><a href='#estfun'><p>Extract Empirical Estimating Functions</p></a></li>
<li><a href='#FacialBurns'><p>Dataset for illustrating the InformativeTesting function.</p></a></li>
<li><a href='#fitMeasures'><p>Fit Measures for a Latent Variable Model</p></a></li>
<li><a href='#getCov'><p>Utility Functions For Covariance Matrices</p></a></li>
<li><a href='#growth'><p>Fit Growth Curve Models</p></a></li>
<li><a href='#HolzingerSwineford1939'>
<p>Holzinger and Swineford Dataset (9 Variables)</p></a></li>
<li><a href='#InformativeTesting'><p>Testing order/inequality Constrained Hypotheses in SEM</p></a></li>
<li><a href='#InformativeTesting+20methods'><p>Methods for output InformativeTesting()</p></a></li>
<li><a href='#inspectSampleCov'><p>Observed Variable Correlation Matrix from a Model and Data</p></a></li>
<li><a href='#lav_constraints'><p>Utility Functions: Constraints</p></a></li>
<li><a href='#lav_data'><p>lavaan data functions</p></a></li>
<li><a href='#lav_export_estimation'><p>lav_export_estimation</p></a></li>
<li><a href='#lav_func'><p>Utility Functions: Gradient and Jacobian</p></a></li>
<li><a href='#lav_matrix'><p>Utility Functions: Matrices and Vectors</p></a></li>
<li><a href='#lav_model'><p>lavaan model functions</p></a></li>
<li><a href='#lav_partable'><p>lavaan partable functions</p></a></li>
<li><a href='#lav_samplestats'><p>lavaan samplestats functions</p></a></li>
<li><a href='#lavaan'><p>Fit a Latent Variable Model</p></a></li>
<li><a href='#lavaan-class'><p>Class For Representing A (Fitted) Latent Variable Model</p></a></li>
<li><a href='#lavaanList'><p>Fit List of Latent Variable Models</p></a></li>
<li><a href='#lavaanList-class'><p>Class For Representing A List of (Fitted) Latent Variable Models</p></a></li>
<li><a href='#lavCor'><p>Polychoric, polyserial and Pearson correlations</p></a></li>
<li><a href='#lavExport'><p>lavaan Export</p></a></li>
<li><a href='#lavInspect'><p>Inspect or extract information from a fitted lavaan object</p></a></li>
<li><a href='#lavListInspect'><p>Inspect or extract information from a lavaanList object</p></a></li>
<li><a href='#lavMatrixRepresentation'><p>lavaan matrix representation</p></a></li>
<li><a href='#lavNames'><p>lavaan Names</p></a></li>
<li><a href='#lavOptions'><p>lavaan Options</p></a></li>
<li><a href='#lavPredict'><p>Predict the values of latent variables (and their indicators).</p></a></li>
<li><a href='#lavPredictY'><p>Predict the values of y-variables given the values of x-variables</p></a></li>
<li><a href='#lavPredictY_cv'><p>Determine an optimal lambda penalty value through cross-validation</p></a></li>
<li><a href='#lavResiduals'><p>Residuals</p></a></li>
<li><a href='#lavTables'><p>lavaan frequency tables</p></a></li>
<li><a href='#lavTablesFitCp'><p>Pairwise maximum likelihood fit statistics</p></a></li>
<li><a href='#lavTest'><p>Test of exact fit</p></a></li>
<li><a href='#lavTestLRT'><p>LRT test</p></a></li>
<li><a href='#lavTestScore'><p>Score test</p></a></li>
<li><a href='#lavTestWald'><p>Wald test</p></a></li>
<li><a href='#model.syntax'><p>The Lavaan Model Syntax</p></a></li>
<li><a href='#modificationIndices'><p>Modification Indices</p></a></li>
<li><a href='#mplus2lavaan'><p>mplus to lavaan converter</p></a></li>
<li><a href='#mplus2lavaan.modelSyntax'><p>Convert Mplus model syntax to lavaan</p></a></li>
<li><a href='#parameterEstimates'><p>Parameter Estimates</p></a></li>
<li><a href='#parTable'><p>Parameter Table</p></a></li>
<li><a href='#PoliticalDemocracy'>
<p>Industrialization And Political Democracy Dataset</p></a></li>
<li><a href='#sam'><p>Fit Structural Equation Models using the SAM approach</p></a></li>
<li><a href='#sem'><p>Fit Structural Equation Models</p></a></li>
<li><a href='#simulateData'><p>Simulate Data From a Lavaan Model Syntax</p></a></li>
<li><a href='#standardizedSolution'><p>Standardized Solution</p></a></li>
<li><a href='#summary.efaList'><p>Summarizing EFA Fits</p></a></li>
<li><a href='#varTable'><p>Variable Table</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Latent Variable Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6-19</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit a variety of latent variable models, including confirmatory
   factor analysis, structural equation modeling and latent growth curve models.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats4, stats, utils, graphics, MASS, mnormt,
pbivnorm, numDeriv, quadprog</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/yrosseel/lavaan/issues">https://github.com/yrosseel/lavaan/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://lavaan.ugent.be">https://lavaan.ugent.be</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-26 12:26:32 UTC; yves</td>
</tr>
<tr>
<td>Author:</td>
<td>Yves Rosseel <a href="https://orcid.org/0000-0002-4129-4477"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Terrence D. Jorgensen
    <a href="https://orcid.org/0000-0001-5111-6773"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Luc De Wilde [aut],
  Daniel Oberski [ctb],
  Jarrett Byrnes [ctb],
  Leonard Vanbrabant [ctb],
  Victoria Savalei [ctb],
  Ed Merkle [ctb],
  Michael Hallquist [ctb],
  Mijke Rhemtulla [ctb],
  Myrsini Katsikatsou [ctb],
  Mariska Barendse [ctb],
  Nicholas Rockwood [ctb],
  Florian Scharf [ctb],
  Han Du [ctb],
  Haziq Jamil <a href="https://orcid.org/0000-0003-3298-1010"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Franz Classe [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yves Rosseel &lt;Yves.Rosseel@UGent.be&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-26 15:50:14 UTC</td>
</tr>
</table>
<hr>
<h2 id='bootstrapLavaan'>Bootstrapping a Lavaan Model</h2><span id='topic+bootstrapLavaan'></span><span id='topic+bootstrapLRT'></span>

<h3>Description</h3>

<p>Bootstrap the LRT, or any other statistic (or vector
of statistics) you can extract from a fitted lavaan object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrapLavaan(object, R = 1000L, type = "ordinary", verbose = FALSE, 
                FUN = "coef", keep.idx = FALSE,
                parallel = c("no", "multicore", "snow"),
                ncpus = 1L, cl = NULL, iseed = NULL, h0.rmsea = NULL, ...)

bootstrapLRT(h0 = NULL, h1 = NULL, R = 1000L, type="bollen.stine", 
             verbose = FALSE, return.LRT = FALSE, double.bootstrap = "no", 
             double.bootstrap.R = 500L, double.bootstrap.alpha = 0.05, 
             parallel = c("no", "multicore", "snow"),
             ncpus = 1L, cl = NULL, iseed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootstrapLavaan_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+lavaan-class">lavaan</a></code>.</p>
</td></tr>
<tr><td><code id="bootstrapLavaan_+3A_h0">h0</code></td>
<td>
<p>An object of class <code><a href="#topic+lavaan-class">lavaan</a></code>. The restricted
model.</p>
</td></tr>
<tr><td><code id="bootstrapLavaan_+3A_h1">h1</code></td>
<td>
<p>An object of class <code><a href="#topic+lavaan-class">lavaan</a></code>. The unrestricted
model.</p>
</td></tr>
<tr><td><code id="bootstrapLavaan_+3A_r">R</code></td>
<td>
<p>Integer. The number of bootstrap draws.</p>
</td></tr>
<tr><td><code id="bootstrapLavaan_+3A_type">type</code></td>
<td>
<p>If <code>"ordinary"</code> or <code>"nonparametric"</code>, the usual (naive)
bootstrap method is used. If <code>"bollen.stine"</code>, the data is first
transformed such that the null hypothesis holds exactly in the resampling
space. If <code>"yuan"</code>, the data is first transformed by combining data and
theory (model), such that the resampling space is closer to the population
space. Note that both <code>"bollen.stine"</code> and <code>"yuan"</code> require the data
to be continuous. They will not work with ordinal data.  If
<code>"parametric"</code>, the parametric bootstrap approach is used; currently, this
is only valid for continuous data following a multivariate normal distribution.
See references for more details.</p>
</td></tr>
<tr><td><code id="bootstrapLavaan_+3A_fun">FUN</code></td>
<td>
<p>A function which when applied to the <code><a href="#topic+lavaan-class">lavaan</a></code> 
object returns a vector containing the statistic(s) of interest.
The default is <code>FUN="coef"</code>, returning the estimated values of the
free parameters in the model.</p>
</td></tr>
<tr><td><code id="bootstrapLavaan_+3A_...">...</code></td>
<td>
<p>Other named arguments for <code>FUN</code> which are passed
unchanged each time it is called.</p>
</td></tr>
<tr><td><code id="bootstrapLavaan_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, show information for each bootstrap draw.</p>
</td></tr>
<tr><td><code id="bootstrapLavaan_+3A_keep.idx">keep.idx</code></td>
<td>
<p>If <code>TRUE</code>, store the indices of each bootstrap run (i.e.,
the observations that were used for this bootstrap run) as an attribute.</p>
</td></tr>
<tr><td><code id="bootstrapLavaan_+3A_return.lrt">return.LRT</code></td>
<td>
<p>If <code>TRUE</code>, return the LRT values as an attribute to the pvalue.</p>
</td></tr>
<tr><td><code id="bootstrapLavaan_+3A_parallel">parallel</code></td>
<td>
<p>The type of parallel operation to be used (if any).  If
missing, the default is <code>"no"</code>.  </p>
</td></tr>
<tr><td><code id="bootstrapLavaan_+3A_ncpus">ncpus</code></td>
<td>
<p>Integer: number of processes to be used in parallel operation.
By default
this is the number of cores (as detected by <code>parallel::detectCores()</code>)
minus one.</p>
</td></tr> 
<tr><td><code id="bootstrapLavaan_+3A_cl">cl</code></td>
<td>
<p>An optional <span class="pkg">parallel</span> or <span class="pkg">snow</span> cluster for use if
<code>parallel = "snow"</code>.  If not supplied, a cluster on the local machine is
created for the duration of the <code>bootstrapLavaan</code> or <code>bootstrapLRT</code>
call.</p>
</td></tr>
<tr><td><code id="bootstrapLavaan_+3A_iseed">iseed</code></td>
<td>
<p>An integer to set the seed. Or NULL if no reproducible results are
needed. This works for both serial (non-parallel) and parallel settings.
Internally, <code>RNGkind()</code> is set to <code>"L'Ecuyer-CMRG"</code> if
<code>parallel = "multicore"</code>. If <code>parallel = "snow"</code> (under windows),
<code>parallel::clusterSetRNGStream()</code> is called which
automatically switches to <code>"L'Ecuyer-CMRG"</code>. When <code>iseed</code> is not 
NULL, <code>.Random.seed</code> (if it exists) in the global environment is 
left untouched.</p>
</td></tr>
<tr><td><code id="bootstrapLavaan_+3A_h0.rmsea">h0.rmsea</code></td>
<td>
<p>Only used if <code>type="yuan"</code>. Allows one to do the Yuan
bootstrap under the hypothesis that the population RMSEA equals a specified
value.</p>
</td></tr>
<tr><td><code id="bootstrapLavaan_+3A_double.bootstrap">double.bootstrap</code></td>
<td>
<p>If <code>"standard"</code> the genuine double bootstrap is
used to compute an additional set of plug-in p-values for each boostrap sample.
If <code>"FDB"</code>, the fast double bootstrap is used to compute   second level
LRT-values for each bootstrap sample. If <code>"no"</code>, no double bootstrap is
used. The default is set to <code>"FDB"</code>.</p>
</td></tr>
<tr><td><code id="bootstrapLavaan_+3A_double.bootstrap.r">double.bootstrap.R</code></td>
<td>
<p>Integer. The number of bootstrap draws to be use for
the double bootstrap.</p>
</td></tr>
<tr><td><code id="bootstrapLavaan_+3A_double.bootstrap.alpha">double.bootstrap.alpha</code></td>
<td>
<p>The significance level to compute the adjusted
alpha based on the plugin p-values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The FUN function can return either a scalar or a numeric vector.
This function can be an existing function (for example <code>coef</code>) or
can be a custom defined function. For example:
</p>
<pre>
myFUN &lt;- function(x) {
    # require(lavaan)
    modelImpliedCov &lt;- fitted(x)$cov
    vech(modelImpliedCov)
}
</pre>
<p>If <code>parallel="snow"</code>, it is imperative that the <code>require(lavaan)</code>
is included in the custom function.</p>


<h3>Value</h3>

<p>For <code>bootstrapLavaan()</code>, the bootstrap distribution of the value(s)
returned by <code>FUN</code>, when the object can be simplified to a vector.
For <code>bootstrapLRT()</code>, a bootstrap <em>p</em> value, calculated as the
proportion of bootstrap samples with a LRT statistic at least as large as
the LRT statistic for the original data.</p>


<h3>Author(s)</h3>

<p>Yves Rosseel and Leonard Vanbrabant. Ed Merkle contributed
Yuan's bootstrap. Improvements to Yuan's bootstrap were contributed
by Hao Wu and Chuchu Cheng. The handling of iseed was contributed by
Shu Fai Cheung.</p>


<h3>References</h3>

<p>Bollen, K. and Stine, R. (1992) Bootstrapping Goodness of Fit Measures in
Structural Equation Models. Sociological Methods and Research, 21,
205&ndash;229.
</p>
<p>Yuan, K.-H., Hayashi, K., &amp; Yanagihara, H. (2007). A class of population
covariance matrices in the bootstrap approach to covariance structure analysis.
Multivariate Behavioral Research, 42, 261&ndash;281.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fit the Holzinger and Swineford (1939) example
HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- cfa(HS.model, data=HolzingerSwineford1939, se="none")

# get the test statistic for the original sample
T.orig &lt;- fitMeasures(fit, "chisq")

# bootstrap to get bootstrap test statistics
# we only generate 10 bootstrap sample in this example; in practice
# you may wish to use a much higher number
T.boot &lt;- bootstrapLavaan(fit, R=10, type="bollen.stine",
                          FUN=fitMeasures, fit.measures="chisq")

# compute a bootstrap based p-value
pvalue.boot &lt;- length(which(T.boot &gt; T.orig))/length(T.boot)
</code></pre>

<hr>
<h2 id='cfa'>Fit Confirmatory Factor Analysis Models</h2><span id='topic+cfa'></span>

<h3>Description</h3>

<p>Fit a Confirmatory Factor Analysis (CFA) model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfa(model = NULL, data = NULL, ordered = NULL, sampling.weights = NULL,
    sample.cov = NULL, sample.mean = NULL, sample.th = NULL,
    sample.nobs = NULL, group = NULL, cluster = NULL,
    constraints = "", WLS.V = NULL, NACOV = NULL, ov.order = "model",
    ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cfa_+3A_model">model</code></td>
<td>
<p>A description of the user-specified model. Typically, the model
is described using the lavaan model syntax. See                 
<code><a href="#topic+model.syntax">model.syntax</a></code> for more information. Alternatively, a
parameter table (eg. the output of the <code>lavaanify()</code> function) is also
accepted.</p>
</td></tr>
<tr><td><code id="cfa_+3A_data">data</code></td>
<td>
<p>An optional data frame containing the observed variables used in
the model. If some variables are declared as ordered factors, lavaan will
treat them as ordinal variables.</p>
</td></tr>
<tr><td><code id="cfa_+3A_ordered">ordered</code></td>
<td>
<p>Character vector. Only used if the data is in a data.frame.
Treat these variables as ordered (ordinal) variables, if they are
endogenous in the model. Importantly, all other variables will be treated
as numeric (unless they are declared as ordered in the data.frame.)
Since 0.6-4, ordered can also be logical. If TRUE, all
observed endogenous variables are treated as ordered (ordinal).
If FALSE, all observed endogenous variables are considered to be numeric
(again, unless they are declared as ordered in the data.frame.)</p>
</td></tr>
<tr><td><code id="cfa_+3A_sampling.weights">sampling.weights</code></td>
<td>
<p>A variable name in the data frame containing
sampling weight information. Currently only available for non-clustered 
data. Depending on the <code>sampling.weights.normalization</code> option, these
weights may be rescaled (or not) so that their sum equals the number of 
observations (total or per group).</p>
</td></tr>
<tr><td><code id="cfa_+3A_sample.cov">sample.cov</code></td>
<td>
<p>Numeric matrix. A sample variance-covariance matrix.
The rownames and/or colnames must contain the observed variable names.
For a multiple group analysis, a list with a variance-covariance matrix
for each group.</p>
</td></tr>
<tr><td><code id="cfa_+3A_sample.mean">sample.mean</code></td>
<td>
<p>A sample mean vector. For a multiple group analysis,
a list with a mean vector for each group.</p>
</td></tr>
<tr><td><code id="cfa_+3A_sample.th">sample.th</code></td>
<td>
<p>Vector of sample-based thresholds. For a multiple group 
analysis, a list with a vector of thresholds for each group.</p>
</td></tr>
<tr><td><code id="cfa_+3A_sample.nobs">sample.nobs</code></td>
<td>
<p>Number of observations if the full data frame is missing
and only sample moments are given. For a multiple group analysis, a list
or a vector with the number of observations for each group.</p>
</td></tr>
<tr><td><code id="cfa_+3A_group">group</code></td>
<td>
<p>Character. A variable name in the data frame defining the groups
in a multiple group analysis.</p>
</td></tr>
<tr><td><code id="cfa_+3A_cluster">cluster</code></td>
<td>
<p>Character. A (single) variable name in the data frame defining the clusters in a two-level dataset.</p>
</td></tr>
<tr><td><code id="cfa_+3A_constraints">constraints</code></td>
<td>
<p>Additional (in)equality constraints not yet included in the
model syntax. See <code><a href="#topic+model.syntax">model.syntax</a></code> for more information.</p>
</td></tr>
<tr><td><code id="cfa_+3A_wls.v">WLS.V</code></td>
<td>
<p>A user provided weight matrix to be used by estimator <code>"WLS"</code>;
if the estimator is <code>"DWLS"</code>, only the diagonal of this matrix will be 
used. For a multiple group analysis, a list with a weight matrix
for each group. The elements of the weight matrix should be in the
following order (if all data is continuous): first the means (if a 
meanstructure is involved), then the lower triangular elements of the 
covariance matrix including the diagonal, ordered column by column. In
the categorical case: first the thresholds (including the means for 
continuous variables), then the slopes (if any), the variances of 
continuous variables (if any), and finally the lower triangular elements 
of the correlation/covariance matrix excluding the diagonal, ordered 
column by column.</p>
</td></tr>
<tr><td><code id="cfa_+3A_nacov">NACOV</code></td>
<td>
<p>A user provided matrix containing the elements of (N times)
the asymptotic variance-covariance matrix of the sample statistics.
For a multiple group analysis, a list with an asymptotic 
variance-covariance matrix for each group. See the <code>WLS.V</code> 
argument for information about the order of the elements.</p>
</td></tr>
<tr><td><code id="cfa_+3A_ov.order">ov.order</code></td>
<td>
<p>Character. If <code>"model"</code> (the default), the order of
the observed variable names (as reflected for example in the output of
<code>lavNames()</code>) is determined by the model syntax. If
<code>"data"</code>, the order is determined by the data (either the full
data.frame or the sample (co)variance matrix). If the <code>WLS.V</code>
and/or <code>NACOV</code> matrices are provided, this argument is currently
set to <code>"data"</code>.</p>
</td></tr>
<tr><td><code id="cfa_+3A_...">...</code></td>
<td>
<p>Many more additional options can be defined, using 'name = value'.
See <code><a href="#topic+lavOptions">lavOptions</a></code> for a complete list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>cfa</code> function is a wrapper for the more general 
<code><a href="#topic+lavaan">lavaan</a></code> function, using the following default arguments:
<code>int.ov.free = TRUE</code>, <code>int.lv.free = FALSE</code>, 
<code>auto.fix.first = TRUE</code> (unless <code>std.lv = TRUE</code>), 
<code>auto.fix.single = TRUE</code>, <code>auto.var = TRUE</code>, 
<code>auto.cov.lv.x = TRUE</code>, <code>auto.efa = TRUE</code>,
<code>auto.th = TRUE</code>, <code>auto.delta = TRUE</code>,
and <code>auto.cov.y = TRUE</code>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+lavaan-class">lavaan</a></code>, for which several methods
are available, including a <code>summary</code> method.
</p>


<h3>References</h3>

<p>Yves Rosseel (2012). lavaan: An R Package for Structural Equation
Modeling. Journal of Statistical Software, 48(2), 1-36.
<a href="https://doi.org/10.18637/jss.v048.i02">doi:10.18637/jss.v048.i02</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lavaan">lavaan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The famous Holzinger and Swineford (1939) example
HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- cfa(HS.model, data = HolzingerSwineford1939)
summary(fit, fit.measures = TRUE)
</code></pre>

<hr>
<h2 id='Demo.growth'>
Demo dataset for a illustrating a linear growth model.
</h2><span id='topic+Demo.growth'></span>

<h3>Description</h3>

<p>A toy dataset containing measures on 4 time points (t1,t2, t3 and t4),
two predictors (x1 and x2) influencing the random intercept and slope, and 
a time-varying covariate (c1, c2, c3 and c4).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Demo.growth)</code></pre>


<h3>Format</h3>

<p>A data frame of 400 observations of 10 variables.
</p>

<dl>
<dt><code>t1</code></dt><dd><p>Measured value at time point 1</p>
</dd>
<dt><code>t2</code></dt><dd><p>Measured value at time point 2</p>
</dd>
<dt><code>t3</code></dt><dd><p>Measured value at time point 3</p>
</dd>
<dt><code>t4</code></dt><dd><p>Measured value at time point 4</p>
</dd>
<dt><code>x1</code></dt><dd><p>Predictor 1 influencing intercept and slope</p>
</dd>
<dt><code>x2</code></dt><dd><p>Predictor 2 influencing intercept and slope</p>
</dd>
<dt><code>c1</code></dt><dd><p>Time-varying covariate time point 1</p>
</dd>
<dt><code>c2</code></dt><dd><p>Time-varying covariate time point 2</p>
</dd>
<dt><code>c3</code></dt><dd><p>Time-varying covariate time point 3</p>
</dd>
<dt><code>c4</code></dt><dd><p>Time-varying covariate time point 4</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+growth">growth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(Demo.growth)
</code></pre>

<hr>
<h2 id='Demo.twolevel'>
Demo dataset for a illustrating a multilevel CFA.
</h2><span id='topic+Demo.twolevel'></span>

<h3>Description</h3>

<p>A toy dataset containing measures on 6 items (y1-y6), 3 within-level 
covariates (x1-x3) and 2 between-level covariates (w1-w2). The data
is clustered (200 clusters of size 5, 10, 15 and 20), and the cluster 
variable is &ldquo;cluster&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Demo.twolevel)</code></pre>


<h3>Format</h3>

<p>A data frame of 2500 observations of 12 variables.
clusters.
</p>

<dl>
<dt><code>y1</code></dt><dd><p>item 1</p>
</dd>
<dt><code>y2</code></dt><dd><p>item 2</p>
</dd>
<dt><code>y3</code></dt><dd><p>item 3</p>
</dd>
<dt><code>y4</code></dt><dd><p>item 4</p>
</dd>
<dt><code>y5</code></dt><dd><p>item 5</p>
</dd>
<dt><code>y6</code></dt><dd><p>item 6</p>
</dd>
<dt><code>x1</code></dt><dd><p>within-level covariate 1</p>
</dd>
<dt><code>x2</code></dt><dd><p>within-level covariate 2</p>
</dd>
<dt><code>x3</code></dt><dd><p>within-level covariate 3</p>
</dd>
<dt><code>w1</code></dt><dd><p>between-level covariate 1</p>
</dd>
<dt><code>w2</code></dt><dd><p>between-level covariate 2</p>
</dd>
<dt><code>cluster</code></dt><dd><p>cluster variable</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>head(Demo.twolevel)

model &lt;- '
    level: 1
        fw =~ y1 + y2 + y3
        fw ~ x1 + x2 + x3
    level: 2
        fb =~ y1 + y2 + y3
        fb ~ w1 + w2
'
fit &lt;- sem(model, data = Demo.twolevel, cluster = "cluster")
summary(fit)
</code></pre>

<hr>
<h2 id='efa'>Exploratory Factor Analysis</h2><span id='topic+efa'></span><span id='topic+rotation'></span>

<h3>Description</h3>

<p>Fit one or more Exploratory Factor Analysis (EFA) model(s).</p>


<h3>Usage</h3>

<pre><code class='language-R'>efa(data = NULL, nfactors = 1L, sample.cov = NULL, sample.nobs = NULL,
    rotation = "geomin", rotation.args = list(), ov.names = names(data),
    bounds = "pos.var", ..., output = "efa")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="efa_+3A_data">data</code></td>
<td>
<p>A data frame containing the observed variables we need for the
EFA. If only a subset of the observed variables is needed, use the
<code>ov.names</code> argument.</p>
</td></tr>
<tr><td><code id="efa_+3A_nfactors">nfactors</code></td>
<td>
<p>Integer or Integer vector. The desired number of factors
to extract. Can be a single number, or a vector of numbers
(e.g., <code>nfactors = 1:4</code>.), For each different number, a model
is fitted.</p>
</td></tr>
<tr><td><code id="efa_+3A_sample.cov">sample.cov</code></td>
<td>
<p>Numeric matrix. A sample variance-covariance matrix.
The rownames and/or colnames must contain the observed variable names.
Unlike sem and CFA, the matrix may be a correlation matrix.</p>
</td></tr>
<tr><td><code id="efa_+3A_sample.nobs">sample.nobs</code></td>
<td>
<p>Number of observations if the full data frame is missing
and only the sample variance-covariance matrix is given.</p>
</td></tr>
<tr><td><code id="efa_+3A_rotation">rotation</code></td>
<td>
<p>Character. The rotation method to be used. Possible options
are varimax, quartimax, orthomax, oblimin, quartimin, geomin, promax,
entropy, mccammon, infomax, tandem1, tandem2, oblimax, bentler, simplimax, 
target, pst (=partially specified target), cf, crawford-ferguson,
cf-quartimax,  cf-varimax, cf-equamax,
cf-parsimax, cf-facparsim, biquartimin, bigeomin. The latter two are
for bifactor rotation only. The rotation algorithms (except promax) 
are similar to those from the GPArotation package, but have been 
reimplemented for better control. The promax method is taken from the
stats package.</p>
</td></tr>
<tr><td><code id="efa_+3A_rotation.args">rotation.args</code></td>
<td>
<p>List. Options related to the rotation algorithm. The
default options (and their alternatives) are <code>orthogonal = FALSE</code>,
<code>row.weights = "default"</code> (or <code>"kaiser"</code>,
<code>"cureton.mulaik"</code> or <code>"none"</code>), <code>std.ov = TRUE</code>,
<code>algorithm = "gpa"</code> (or <code>"pairwise"</code>), <code>rstarts = 30</code>,
<code>gpa.tol = 1e-05</code>, <code>tol = 1e-08</code>, <code>max.iter = 10000L</code>,
<code>warn = FALSE</code>, <code>verbose = FALSE</code>, <code>reflect = TRUE</code>,
<code>order.lv.by = "index"</code> (or <code>"sumofsquares"</code> or <code>"none"</code>).
Other options are specific for a particular rotation criterion: 
<code>geomin.epsilon = 0.001</code>, <code>orthomax.gamma = 1</code>,
<code>promax.kappa = 4</code>,
<code>cf.gamma = 0</code>, and <code>oblimin.gamma = 0</code>.</p>
</td></tr>
<tr><td><code id="efa_+3A_ov.names">ov.names</code></td>
<td>
<p>Character vector. The variables names that are needed for
the EFA. Should be a subset of the variables names in the data.frame.
By default, all the variables in the data are used.</p>
</td></tr>
<tr><td><code id="efa_+3A_bounds">bounds</code></td>
<td>
<p>Per default, <code>bounds = "pos.var"</code> forces all variances
of both observed and latent variables to be strictly nonnegative. See
the entry in <code><a href="#topic+lavOptions">lavOptions</a></code> for more options.</p>
</td></tr>
<tr><td><code id="efa_+3A_...">...</code></td>
<td>
<p>Aditional options to be passed to lavaan, using 'name = value'.
See <code><a href="#topic+lavOptions">lavOptions</a></code> for a complete list.</p>
</td></tr>
<tr><td><code id="efa_+3A_output">output</code></td>
<td>
<p>Character. If <code>"efa"</code> (the default), the output mimics
the typical output of an EFA. If <code>"lavaan"</code>, a lavaan object returned.
The latter is only possible if nfactors contains a single (integer) number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>efa</code> function is essentially a wrapper around the
<code>lavaan</code> function. It generates the model syntax (for a given number
of factors) and then calls <code>lavaan()</code> treating the factors as 
a single block that should be rotated. The function only supports
a single group. Categorical data is handled as usual by first computing
an appropriate (e.g., tetrachoric or polychoric) correlation matrix,
which is then used as input for the EFA. 
There is also (limited) support for
twolevel data. The same number of factors is then extracted at the
within and the between level.
The promax rotation method (taken from the stats package) is only 
provided for convenience. Because promax is a two-step algorithm (first 
varimax, then oblique rotation to get simple structure), it does not 
use the gpa or pairwise rotation algorithms, and as a result, no
standard errors are provided.
</p>


<h3>Value</h3>

<p>If <code>output = "lavaan"</code>, an object of class 
<code><a href="#topic+lavaan-class">lavaan</a></code>. If <code>output = "efa"</code>,
a list of class <code>efaList</code> for which a <code>print()</code>,  
<code>summary()</code> and <code>fitMeasures()</code> method are available. Because
we added the (standardized) loadings as an extra element, the <code>loadings</code>
function (which is not a generic function) from the stats package will
also work on <code>efaList</code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.efaList">summary.efaList</a></code> for a summary method if the output is
of class <code>efaList</code>.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The famous Holzinger and Swineford (1939) example
fit &lt;- efa(data = HolzingerSwineford1939, 
           ov.names = paste("x", 1:9, sep = ""),
           nfactors = 1:3,
           rotation = "geomin",
           rotation.args = list(geomin.epsilon = 0.01, rstarts = 1))
summary(fit, nd = 3L, cutoff = 0.2, dot.cutoff = 0.05)
fitMeasures(fit, fit.measures = "all")
</code></pre>

<hr>
<h2 id='estfun'>Extract Empirical Estimating Functions</h2><span id='topic+estfun.lavaan'></span><span id='topic+lavScores'></span>

<h3>Description</h3>

<p>A function for extracting the empirical estimating functions of a fitted 
lavaan model. This is the derivative of the objective function 
with respect to the parameter vector, evaluated at the observed (case-wise)
data. In other words, this function returns the case-wise scores, evaluated
at the fitted model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estfun.lavaan(object, scaling = FALSE, ignore.constraints = FALSE,
              remove.duplicated = TRUE, remove.empty.cases = TRUE)
lavScores(object, scaling = FALSE, ignore.constraints = FALSE,
          remove.duplicated = TRUE, remove.empty.cases = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estfun_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+lavaan-class">lavaan</a></code>.</p>
</td></tr>
<tr><td><code id="estfun_+3A_scaling">scaling</code></td>
<td>
<p>Only used for the ML estimator. If <code>TRUE</code>, the scores are
scaled to reflect the specific objective function used by lavaan. If
<code>FALSE</code> (the default), the objective function is the loglikelihood
function assuming multivariate normality.</p>
</td></tr>
<tr><td><code id="estfun_+3A_ignore.constraints">ignore.constraints</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the scores do not reflect
the (equality or inequality) constraints. If <code>FALSE</code>, the scores are
computed by taking the unconstrained scores, and adding the term <code>t(R)
lambda</code>, where <code>lambda</code> are the (case-wise) Lagrange Multipliers, and
<code>R</code> is the Jacobian of the constraint function. Only in the latter case
will the sum of the columns be (almost) equal to zero.</p>
</td></tr>
<tr><td><code id="estfun_+3A_remove.duplicated">remove.duplicated</code></td>
<td>
<p>If <code>TRUE</code>, and all the equality constraints have
a simple form (eg. a == b), the unconstrained scores are post-multiplied with a
transformation matrix in order to remove the duplicated parameters.</p>
</td></tr>
<tr><td><code id="estfun_+3A_remove.empty.cases">remove.empty.cases</code></td>
<td>
<p>If <code>TRUE</code>, empty cases with only missing values
will be removed from the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A n x k matrix corresponding to n observations and k parameters.</p>


<h3>Author(s)</h3>

<p>Ed Merkle for the ML case; the <code>remove.duplicated</code>,
<code>ignore.constraints</code> and <code>remove.empty.cases</code> arguments were added by
Yves Rosseel; Franz Classe for the WLS case.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The famous Holzinger and Swineford (1939) example
HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- cfa(HS.model, data = HolzingerSwineford1939)
head(lavScores(fit))
</code></pre>

<hr>
<h2 id='FacialBurns'>Dataset for illustrating the InformativeTesting function.</h2><span id='topic+FacialBurns'></span>

<h3>Description</h3>

<p>A dataset from the Dutch burn center (http://www.adbc.nl). 
The data were used to examine psychosocial functioning in patients with 
facial burn wounds. Psychosocial functioning was measured by 
Anxiety and depression symptoms (HADS), and self-esteem 
(Rosenberg's self-esteem scale).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(FacialBurns)</code></pre>


<h3>Format</h3>

<p>A data frame of 77 observations of 6 variables.
</p>

<dl>
<dt><code>Selfesteem</code></dt><dd><p>Rosenberg's self-esteem scale</p>
</dd>
<dt><code>HADS</code></dt><dd><p>Anxiety and depression scale</p>
</dd>
<dt><code>Age</code></dt><dd><p>Age measured in years, control variable</p>
</dd>
<dt><code>TBSA</code></dt><dd><p>Total Burned Surface Area</p>
</dd>
<dt><code>RUM</code></dt><dd><p>Rumination, control variable</p>
</dd>
<dt><code>Sex</code></dt><dd><p>Gender, grouping variable</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>head(FacialBurns)
</code></pre>

<hr>
<h2 id='fitMeasures'>Fit Measures for a Latent Variable Model</h2><span id='topic+fitMeasures'></span><span id='topic+fitmeasures'></span><span id='topic+fitMeasures+2Clavaan-method'></span><span id='topic+fitmeasures+2Clavaan-method'></span><span id='topic+fitindices'></span>

<h3>Description</h3>

<p>This function computes a variety of fit measures to assess the global
fit of a latent variable model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitMeasures(object, fit.measures = "all",
            baseline.model = NULL, h1.model = NULL,
            fm.args = list(standard.test     = "default",
                           scaled.test       = "default",
                           rmsea.ci.level    = 0.90,
                           rmsea.close.h0    = 0.05,
                           rmsea.notclose.h0 = 0.08,
                           robust            = TRUE,
                           cat.check.pd      = TRUE),
            output = "vector", ...)
fitmeasures(object, fit.measures = "all",
            baseline.model = NULL, h1.model = NULL,
            fm.args = list(standard.test     = "default",
                           scaled.test       = "default",
                           rmsea.ci.level    = 0.90,
                           rmsea.close.h0    = 0.05,
                           rmsea.notclose.h0 = 0.08,
                           robust            = TRUE,
                           cat.check.pd      = TRUE),
            output = "vector", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitMeasures_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+lavaan-class">lavaan</a></code>.</p>
</td></tr>
<tr><td><code id="fitMeasures_+3A_fit.measures">fit.measures</code></td>
<td>
<p>If <code>"all"</code>, all fit measures available will be
returned. If only a single or a few fit measures are specified by name,
only those are computed and returned.</p>
</td></tr>
<tr><td><code id="fitMeasures_+3A_baseline.model">baseline.model</code></td>
<td>
<p>If not NULL, an object of class
<code><a href="#topic+lavaan-class">lavaan</a></code>, representing a user-specified baseline model.
If a baseline model is provided, all fit indices relying on a
baseline model (eg. CFI or TLI) will use the test statistics from
this user-specified baseline model, instead of the default baseline model.</p>
</td></tr>
<tr><td><code id="fitMeasures_+3A_h1.model">h1.model</code></td>
<td>
<p>If not NULL, an object of class <code><a href="#topic+lavaan-class">lavaan</a></code>,
representing a user-specified alternative to the default unrestricted model.
If <code>h1.model</code> is provided, all fit indices calculated from chi-squared
will use the chi-squared <em>difference</em> test statistics from 
<code><a href="#topic+lavTestLRT">lavTestLRT</a></code>, which compare the user-provided <code>h1.model</code> 
to <code>object</code>.</p>
</td></tr>
<tr><td><code id="fitMeasures_+3A_fm.args">fm.args</code></td>
<td>
<p>List. Additional options for certain fit measures. The
<code>standard.test</code> element determines the main test statistic (chi-square
value) that will be used to compute all the fit measures that depend on this
test statistic. Usually this is <code>"standard"</code>. The <code>scaled.test</code>
element determines which scaling method is to be used for the scaled fit
measures (in case multiple scaling methods were requested). The
<code>rmsea.ci.level</code> element determines the level of the confidence
interval for the rmsea value. The <code>rmsea.close.h0</code> element
is the rmsea value
that is used under the null hypothesis that <code>rmsea &lt;= rmsea.close.h0</code>.
The <code>rmsea.notclose.h0</code> element is the rmsea value that is used under the
null hypothesis that <code>rsmsea &gt;= rmsea.notclose.h0</code>. The <code>robust</code> 
element can be set to <code>FALSE</code> to avoid computing the so-called robust
rmsea/cfi measures (for example if the computations take too long).
The <code>cat.check.pd</code> element is only used when data is categorical. If
<code>TRUE</code>, robust values for RMSEA and CFI are only computed if the input
correlation matrix is positive-definite (for all groups).</p>
</td></tr>
<tr><td><code id="fitMeasures_+3A_output">output</code></td>
<td>
<p>Character. If <code>"vector"</code> (the default), display the
output as a named (lavaan-formatted) vector. If <code>"matrix"</code>, display
the output as a 1-column matrix. If <code>"text"</code>, display the
output using subsections and verbose descriptions. The latter is used
in the summary output, and does not print the chi-square test by default.
In addition, <code>fit.measures</code> should contain the main ingredient
(for example <code>"rmsea"</code>) if related fit measures are requested
(for example <code>"rmsea.ci.lower"</code>). Otherwise, nothing will be 
printed in that section.
See the examples how to add the chi-square test in the text output.</p>
</td></tr>
<tr><td><code id="fitMeasures_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Not currently
used for <code>lavaan</code> objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named numeric vector of fit measures.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- cfa(HS.model, data = HolzingerSwineford1939)
fitMeasures(fit)
fitMeasures(fit, "cfi")
fitMeasures(fit, c("chisq", "df", "pvalue", "cfi", "rmsea"))
fitMeasures(fit, c("chisq", "df", "pvalue", "cfi", "rmsea"), 
            output = "matrix")
fitMeasures(fit, c("chisq", "df", "pvalue", "cfi", "rmsea"),
            output = "text")

## fit a more restricted model
fit0 &lt;- cfa(HS.model, data = HolzingerSwineford1939, orthogonal = TRUE)
## Calculate RMSEA_D (Savalei et al., 2023)
## See https://psycnet.apa.org/doi/10.1037/met0000537
fitMeasures(fit0, "rmsea", h1.model = fit)
</code></pre>

<hr>
<h2 id='getCov'>Utility Functions For Covariance Matrices</h2><span id='topic+getCov'></span><span id='topic+cor2cov'></span><span id='topic+char2num'></span>

<h3>Description</h3>

<p>Convenience functions to deal with covariance and correlation
matrices.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCov(x, lower = TRUE, diagonal = TRUE, sds = NULL,
       names = paste("V", 1:nvar, sep=""))
char2num(s)
cor2cov(R, sds, names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCov_+3A_x">x</code></td>
<td>
<p>The elements of the covariance matrix. Either inside a character 
string or as a numeric vector. In the former case, the function
<code>char2num</code> is used to convert the numbers (inside the character
string) to numeric values.</p>
</td></tr>
<tr><td><code id="getCov_+3A_lower">lower</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the numeric values in <code>x</code> are
the lower-triangular elements of the (symmetric) covariance matrix only.
If <code>FALSE</code>, <code>x</code> contains the upper triangular elements only.
Note we always assumed the elements are provided row-wise!</p>
</td></tr>
<tr><td><code id="getCov_+3A_diagonal">diagonal</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the numeric values in <code>x</code>
include the diagonal elements. If <code>FALSE</code>, a unit diagonal is assumed.</p>
</td></tr>
<tr><td><code id="getCov_+3A_sds">sds</code></td>
<td>
<p>A numeric vector containing the standard deviations to be 
used to scale the elements in <code>x</code> or the correlation matrix <code>R</code>
into a covariance matrix.</p>
</td></tr>
<tr><td><code id="getCov_+3A_names">names</code></td>
<td>
<p>The variable names of the observed variables.</p>
</td></tr>
<tr><td><code id="getCov_+3A_s">s</code></td>
<td>
<p>Character string containing numeric values; comma's and semi-colons
are ignored.</p>
</td></tr>
<tr><td><code id="getCov_+3A_r">R</code></td>
<td>
<p>A correlation matrix, to be scaled into a covariance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>getCov</code> function is typically used to input the lower 
(or upper) triangular elements of a (symmetric) covariance matrix. In many 
examples found in handbooks, only those elements are shown. However, lavaan 
needs a full matrix to proceed. 
</p>
<p>The <code>cor2cov</code> function is the inverse of the <code><a href="stats.html#topic+cov2cor">cov2cor</a></code> 
function, and scales a correlation matrix into a covariance matrix given
the standard deviations of the variables. Optionally, variable names can
be given.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The classic Wheaton et. al. (1977) model 
# panel data on he stability of alienation
lower &lt;- '
 11.834,
  6.947,    9.364,
  6.819,    5.091,   12.532,
  4.783,    5.028,    7.495,    9.986,
 -3.839,   -3.889,   -3.841,   -3.625,   9.610,
-21.899,  -18.831,  -21.748,  -18.775,  35.522,  450.288 '

# convert to a full symmetric covariance matrix with names
wheaton.cov &lt;- getCov(lower, names=c("anomia67","powerless67", "anomia71",
                                     "powerless71","education","sei"))

# the model
wheaton.model &lt;- '
  # measurement model
    ses     =~ education + sei
    alien67 =~ anomia67 + powerless67
    alien71 =~ anomia71 + powerless71

  # equations
    alien71 ~ alien67 + ses
    alien67 ~ ses

  # correlated residuals
    anomia67 ~~ anomia71
    powerless67 ~~ powerless71
'

# fitting the model
fit &lt;- sem(wheaton.model, sample.cov=wheaton.cov, sample.nobs=932)

# showing the results
summary(fit, standardized=TRUE)
</code></pre>

<hr>
<h2 id='growth'>Fit Growth Curve Models</h2><span id='topic+growth'></span>

<h3>Description</h3>

<p>Fit a Growth Curve model. Only useful if all the latent variables in the model
are growth factors. For more complex models, it may be better to use the
<code><a href="#topic+lavaan">lavaan</a></code> function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth(model = NULL, data = NULL, ordered = NULL, sampling.weights = NULL,
       sample.cov = NULL, sample.mean = NULL, sample.th = NULL,
       sample.nobs = NULL, group = NULL, cluster = NULL, 
       constraints = "", WLS.V = NULL, NACOV = NULL, ov.order = "model",
       ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="growth_+3A_model">model</code></td>
<td>
<p>A description of the user-specified model. Typically, the model
is described using the lavaan model syntax. See            
<code><a href="#topic+model.syntax">model.syntax</a></code> for more information. Alternatively, a
parameter table (eg. the output of the <code>lavaanify()</code> function) is also
accepted.</p>
</td></tr>
<tr><td><code id="growth_+3A_data">data</code></td>
<td>
<p>An optional data frame containing the observed variables used in
the model. If some variables are declared as ordered factors, lavaan will
treat them as ordinal variables.</p>
</td></tr>
<tr><td><code id="growth_+3A_ordered">ordered</code></td>
<td>
<p>Character vector. Only used if the data is in a data.frame.
Treat these variables as ordered (ordinal) variables, if they are
endogenous in the model. Importantly, all other variables will be treated
as numeric (unless they are declared as ordered in the data.frame.) 
Since 0.6-4, ordered can also be logical. If TRUE, all
observed endogenous variables are treated as ordered (ordinal).
If FALSE, all observed endogenous variables are considered to be numeric
(again, unless they are declared as ordered in the data.frame.)</p>
</td></tr>
<tr><td><code id="growth_+3A_sampling.weights">sampling.weights</code></td>
<td>
<p>A variable name in the data frame containing 
sampling weight information. Currently only available for non-clustered
data. Depending on the <code>sampling.weights.normalization</code> option, these
weights may be rescaled (or not) so that their sum equals the number of
observations (total or per group).</p>
</td></tr>
<tr><td><code id="growth_+3A_sample.cov">sample.cov</code></td>
<td>
<p>Numeric matrix. A sample variance-covariance matrix.
The rownames and/or colnames must contain the observed variable names.
For a multiple group analysis, a list with a variance-covariance matrix
for each group.</p>
</td></tr>
<tr><td><code id="growth_+3A_sample.mean">sample.mean</code></td>
<td>
<p>A sample mean vector. For a multiple group analysis,
a list with a mean vector for each group.</p>
</td></tr>
<tr><td><code id="growth_+3A_sample.th">sample.th</code></td>
<td>
<p>Vector of sample-based thresholds. For a multiple group 
analysis, a list with a vector of thresholds for each group.</p>
</td></tr>
<tr><td><code id="growth_+3A_sample.nobs">sample.nobs</code></td>
<td>
<p>Number of observations if the full data frame is missing
and only sample moments are given. For a multiple group analysis, a list
or a vector with the number of observations for each group.</p>
</td></tr>
<tr><td><code id="growth_+3A_group">group</code></td>
<td>
<p>Character. A variable name in the data frame defining the groups
in a multiple group analysis.</p>
</td></tr>
<tr><td><code id="growth_+3A_cluster">cluster</code></td>
<td>
<p>Character. A (single) variable name in the data frame defining the clusters in a two-level dataset.</p>
</td></tr>
<tr><td><code id="growth_+3A_constraints">constraints</code></td>
<td>
<p>Additional (in)equality constraints not yet included in the
model syntax. See <code><a href="#topic+model.syntax">model.syntax</a></code> for more information.</p>
</td></tr>
<tr><td><code id="growth_+3A_wls.v">WLS.V</code></td>
<td>
<p>A user provided weight matrix to be used by estimator <code>"WLS"</code>;
if the estimator is <code>"DWLS"</code>, only the diagonal of this matrix will be
used. For a multiple group analysis, a list with a weight matrix
for each group. The elements of the weight matrix should be in the
following order (if all data is continuous): first the means (if a
meanstructure is involved), then the lower triangular elements of the
covariance matrix including the diagonal, ordered column by column. In
the categorical case: first the thresholds (including the means for
continuous variables), then the slopes (if any), the variances of
continuous variables (if any), and finally the lower triangular elements
of the correlation/covariance matrix excluding the diagonal, ordered
column by column.</p>
</td></tr>
<tr><td><code id="growth_+3A_nacov">NACOV</code></td>
<td>
<p>A user provided matrix containing the elements of (N times)
the asymptotic variance-covariance matrix of the sample statistics.
For a multiple group analysis, a list with an asymptotic
variance-covariance matrix for each group. See the <code>WLS.V</code>
argument for information about the order of the elements.</p>
</td></tr>
<tr><td><code id="growth_+3A_ov.order">ov.order</code></td>
<td>
<p>Character. If <code>"model"</code> (the default), the order of
the observed variable names (as reflected for example in the output of
<code>lavNames()</code>) is determined by the model syntax. If
<code>"data"</code>, the order is determined by the data (either the full
data.frame or the sample (co)variance matrix). If the <code>WLS.V</code>
and/or <code>NACOV</code> matrices are provided, this argument is currently
set to <code>"data"</code>.</p>
</td></tr>
<tr><td><code id="growth_+3A_...">...</code></td>
<td>
<p>Many more additional options can be defined, using 'name = value'.
See <code><a href="#topic+lavOptions">lavOptions</a></code> for a complete list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>growth</code> function is a wrapper for the more general
<code><a href="#topic+lavaan">lavaan</a></code> function, using the following default arguments:
<code>meanstructure = TRUE</code>, 
<code>int.ov.free = FALSE</code>, <code>int.lv.free = TRUE</code>,
<code>auto.fix.first = TRUE</code> (unless <code>std.lv = TRUE</code>),
<code>auto.fix.single = TRUE</code>, <code>auto.var = TRUE</code>,
<code>auto.cov.lv.x = TRUE</code>, <code>auto.efa = TRUE</code>,
<code>auto.th = TRUE</code>, <code>auto.delta = TRUE</code>,
and <code>auto.cov.y = TRUE</code>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+lavaan-class">lavaan</a></code>, for which several methods
are available, including a <code>summary</code> method.
</p>


<h3>References</h3>

<p>Yves Rosseel (2012). lavaan: An R Package for Structural Equation
Modeling. Journal of Statistical Software, 48(2), 1-36. 
<a href="https://doi.org/10.18637/jss.v048.i02">doi:10.18637/jss.v048.i02</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lavaan">lavaan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## linear growth model with a time-varying covariate
model.syntax &lt;- '
  # intercept and slope with fixed coefficients
    i =~ 1*t1 + 1*t2 + 1*t3 + 1*t4
    s =~ 0*t1 + 1*t2 + 2*t3 + 3*t4

  # regressions
    i ~ x1 + x2
    s ~ x1 + x2

  # time-varying covariates
    t1 ~ c1
    t2 ~ c2
    t3 ~ c3
    t4 ~ c4
'

fit &lt;- growth(model.syntax, data = Demo.growth)
summary(fit)
</code></pre>

<hr>
<h2 id='HolzingerSwineford1939'>
Holzinger and Swineford Dataset (9 Variables)
</h2><span id='topic+HolzingerSwineford1939'></span>

<h3>Description</h3>

<p>The classic Holzinger and Swineford (1939) dataset consists of mental
ability test scores of seventh- and eighth-grade children from two
different schools (Pasteur and Grant-White). In the original dataset
(available in the <code>MBESS</code> package), there are scores for 26 tests.
However, a smaller subset with 9 variables is more widely used in the 
literature (for example in Joreskog's 1969 paper, which also uses the 145 
subjects from the Grant-White school only). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(HolzingerSwineford1939)</code></pre>


<h3>Format</h3>

<p>A data frame with 301 observations of 15 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>Identifier</p>
</dd>
<dt><code>sex</code></dt><dd><p>Gender</p>
</dd>
<dt><code>ageyr</code></dt><dd><p>Age, year part</p>
</dd>
<dt><code>agemo</code></dt><dd><p>Age, month part</p>
</dd>
<dt><code>school</code></dt><dd><p>School (Pasteur or Grant-White)</p>
</dd>
<dt><code>grade</code></dt><dd><p>Grade</p>
</dd>
<dt><code>x1</code></dt><dd><p>Visual perception</p>
</dd>
<dt><code>x2</code></dt><dd><p>Cubes</p>
</dd>
<dt><code>x3</code></dt><dd><p>Lozenges</p>
</dd>
<dt><code>x4</code></dt><dd><p>Paragraph comprehension</p>
</dd>
<dt><code>x5</code></dt><dd><p>Sentence completion</p>
</dd>
<dt><code>x6</code></dt><dd><p>Word meaning</p>
</dd>
<dt><code>x7</code></dt><dd><p>Speeded addition</p>
</dd>
<dt><code>x8</code></dt><dd><p>Speeded counting of dots</p>
</dd>
<dt><code>x9</code></dt><dd><p>Speeded discrimination straight and curved capitals</p>
</dd>
</dl>



<h3>Source</h3>

<p>This dataset was originally retrieved from <code style="white-space: pre;">&#8288;http://web.missouri.edu/~kolenikovs/stata/hs-cfa.dta&#8288;</code> (link no longer active) and converted to an R dataset.
</p>


<h3>References</h3>

<p>Holzinger, K., and Swineford, F. (1939). A study in factor analysis: The 
stability of a bifactor solution. Supplementary Educational Monograph, no. 48. 
Chicago: University of Chicago Press. 
</p>
<p>Joreskog, K. G. (1969). A general approach to confirmatory maximum likelihood
factor analysis. <em>Psychometrika</em>, 34, 183-202.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cfa">cfa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(HolzingerSwineford1939)
</code></pre>

<hr>
<h2 id='InformativeTesting'>Testing order/inequality Constrained Hypotheses in SEM</h2><span id='topic+InformativeTesting'></span><span id='topic+informativetesting'></span>

<h3>Description</h3>

<p>Testing order/inequality constrained Hypotheses in SEM</p>


<h3>Usage</h3>

<pre><code class='language-R'>InformativeTesting(model = NULL, data, constraints = NULL, 
                   R = 1000L, type = "bollen.stine",
                   return.LRT = TRUE, 
                   double.bootstrap = "standard",
                   double.bootstrap.R = 249L, 
                   double.bootstrap.alpha = 0.05,
                   parallel = c("no", "multicore", "snow"), 
                   ncpus = 1L, cl = NULL, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="InformativeTesting_+3A_model">model</code></td>
<td>
<p>Model syntax specifying the model. See <code><a href="#topic+model.syntax">model.syntax</a></code> 
for more information.</p>
</td></tr>
<tr><td><code id="InformativeTesting_+3A_data">data</code></td>
<td>
<p>The data frame containing the observed variables being used to 
fit the model.</p>
</td></tr>
<tr><td><code id="InformativeTesting_+3A_constraints">constraints</code></td>
<td>
<p>The imposed inequality constraints on the model.</p>
</td></tr>
<tr><td><code id="InformativeTesting_+3A_r">R</code></td>
<td>
<p>Integer; number of bootstrap draws. The default value is set to 1000.</p>
</td></tr>
<tr><td><code id="InformativeTesting_+3A_type">type</code></td>
<td>
<p>If <code>"parametric"</code>, the parametric bootstrap is used. 
If <code>"bollen.stine"</code>, the semi-nonparametric Bollen-Stine bootstrap 
is used. The default is set to <code>"bollen.stine"</code>.</p>
</td></tr>
<tr><td><code id="InformativeTesting_+3A_return.lrt">return.LRT</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the function returns bootstrapped         
LRT-values.</p>
</td></tr>
<tr><td><code id="InformativeTesting_+3A_double.bootstrap">double.bootstrap</code></td>
<td>
<p>If <code>"standard"</code> (default) the genuine double bootstrap is 
used to compute an additional set of plug-in p-values for each bootstrap       
sample. If <code>"no"</code>, no double bootstrap is used. If <code>"FDB"</code>, 
the fast double bootstrap is used to compute second level LRT-values for 
each bootstrap sample. Note that the <code>"FDB"</code> is experimental and should 
not be used by inexperienced users.</p>
</td></tr>    
<tr><td><code id="InformativeTesting_+3A_double.bootstrap.r">double.bootstrap.R</code></td>
<td>
<p>Integer; number of double bootstrap draws. The default 
value is set to 249.</p>
</td></tr>
<tr><td><code id="InformativeTesting_+3A_double.bootstrap.alpha">double.bootstrap.alpha</code></td>
<td>
<p>The significance level to compute the adjusted 
alpha based on the plugin p-values. Only used if <code>double.bootstrap = "standard"</code>. 
The default value is set to 0.05.</p>
</td></tr>
<tr><td><code id="InformativeTesting_+3A_parallel">parallel</code></td>
<td>
<p>The type of parallel operation to be used (if any). If missing, 
the default is set &quot;no&quot;.</p>
</td></tr>
<tr><td><code id="InformativeTesting_+3A_ncpus">ncpus</code></td>
<td>
<p>Integer: number of processes to be used in parallel operation: 
typically one would chose this to the number of available CPUs.</p>
</td></tr> 
<tr><td><code id="InformativeTesting_+3A_cl">cl</code></td>
<td>
<p>An optional parallel or snow cluster for use if 
<code>parallel = "snow"</code>. If not supplied, a cluster on the local machine 
is created for the duration of the <code>InformativeTesting</code> call.</p>
</td></tr>
<tr><td><code id="InformativeTesting_+3A_verbose">verbose</code></td>
<td>
<p>Logical; if <code>TRUE</code>, information is shown at each bootstrap         
draw.</p>
</td></tr>
<tr><td><code id="InformativeTesting_+3A_...">...</code></td>
<td>
<p>Other named arguments from the lavaan package which are passed to 
the function. For example <code>"group"</code> in a multiple group model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following hypothesis tests are available:
</p>

<ul>
<li><p> Type A: Test H0: all restriktions with equalities (&quot;=&quot;) 
active against HA: at least one inequality restriktion (&quot;&gt;&quot;) 
strictly true.
</p>
</li>
<li><p> Type B: Test H0: all restriktions with inequalities (&quot;&gt;&quot;) 
(including some equalities (&quot;=&quot;)) active against HA: at least 
one restriktion false (some equality restriktions may be 
maintained).</p>
</li></ul>



<h3>Value</h3>

<p>An object of class InformativeTesting for which a 
print and a plot method is available.</p>


<h3>Author(s)</h3>

<p>Leonard Vanbrabant
<a href="mailto:lgf.vanbrabant@gmail.com">lgf.vanbrabant@gmail.com</a>
</p>


<h3>References</h3>

<p>Van de Schoot, R., Hoijtink, H., &amp; Dekovic, M. (2010). 
Testing inequality constrained hypotheses in SEM models. 
<em>Structural Equation Modeling</em>, <b>17</b>, 443-463.
</p>
<p>Van de Schoot, R., Strohmeier, D. (2011). 
Testing informative hypotheses in SEM increases power: An 
illustration contrasting classical. <em>International Journal 
of Behavioral Development</em>, <b>35</b>, 180-190.
</p>
<p>Silvapulle, M.J. and Sen, P.K. (2005). <em>Constrained 
Statistical Inference</em>. Wiley, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#########################
### real data example ###
#########################
# Multiple group path model for facial burns example.

# model syntax with starting values.
  burns.model &lt;- 'Selfesteem ~ Age + c(m1, f1)*TBSA + HADS +
                             start(-.10, -.20)*TBSA  
                 HADS ~ Age + c(m2, f2)*TBSA + RUM +
                        start(.10, .20)*TBSA '
 
 
# constraints syntax
 burns.constraints &lt;- 'f2 &gt; 0  ; m1 &lt; 0
                       m2 &gt; 0  ; f1 &lt; 0
                       f2 &gt; m2 ; f1 &lt; m1'
 
# we only generate 2 bootstrap samples in this example; in practice
# you may wish to use a much higher number. 
# the double bootstrap was switched off; in practice you probably 
# want to set it to "standard".
example1 &lt;- InformativeTesting(model = burns.model, data = FacialBurns,
                               R = 2, constraints = burns.constraints,
                               double.bootstrap = "no", group = "Sex")

example1

##########################
### artificial example ###
##########################
# Simple ANOVA model with 3 groups (N = 20 per group)
set.seed(1234)
Y &lt;- cbind(c(rnorm(20,0,1), rnorm(20,0.5,1), rnorm(20,1,1)))
grp &lt;- c(rep("1", 20), rep("2", 20), rep("3", 20))
Data &lt;- data.frame(Y, grp)

#create model matrix
fit.lm &lt;- lm(Y ~ grp, data = Data)
mfit &lt;- fit.lm$model
mm &lt;- model.matrix(mfit)

Y &lt;- model.response(mfit)
X &lt;- data.frame(mm[,2:3])
names(X) &lt;- c("d1", "d2")
Data.new &lt;- data.frame(Y, X)

# model
model &lt;- 'Y ~ 1 + a1*d1 + a2*d2'

# fit without constraints
fit &lt;- sem(model, data = Data.new)

# constraints syntax: mu1 &lt; mu2 &lt; mu3
constraints &lt;- ' a1 &gt; 0
                 a1 &lt; a2 '

# we only generate 10 bootstrap samples in this example; in practice
# you may wish to use a much higher number, say &gt; 1000. The double 
# bootstrap is not necessary in case of an univariate ANOVA model.
example2 &lt;- InformativeTesting(model = model, data = Data.new, 
                               start = parTable(fit),
                               R = 10L, double.bootstrap = "no",
                               constraints = constraints)
example2

## End(Not run)
</code></pre>

<hr>
<h2 id='InformativeTesting+20methods'>Methods for output InformativeTesting()</h2><span id='topic+print.InformativeTesting'></span><span id='topic+plot.InformativeTesting'></span>

<h3>Description</h3>

<p>The print function shows the results of hypothesis tests
Type A and Type B. The plot function plots the distributions of 
bootstrapped LRT values and plug-in p-values.</p>


<h3>Usage</h3>

<pre><code class='language-R'>    
## S3 method for class 'InformativeTesting'
print(x, digits = max(3, getOption("digits") - 3), ...)
  
## S3 method for class 'InformativeTesting'
plot(x, ..., type = c("lr","ppv"), 
   main = "main", xlab = "xlabel", ylab = "Frequency", freq = TRUE, 
   breaks = 15, cex.main = 1, cex.lab = 1, cex.axis = 1, 
   col = "grey", border = par("fg"), vline = TRUE, 
   vline.col = c("red", "blue"), lty = c(1,2), lwd = 1, 
   legend = TRUE, bty = "o", cex.legend = 1, loc.legend = "topright")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="InformativeTesting+2B20methods_+3A_x">x</code></td>
<td>
<p>object of class &quot;InformativeTesting&quot;.</p>
</td></tr>
<tr><td><code id="InformativeTesting+2B20methods_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="InformativeTesting+2B20methods_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="InformativeTesting+2B20methods_+3A_type">type</code></td>
<td>
<p>If <code>"lr"</code>, a distribution of the first-level 
bootstrapped LR values is plotted. If <code>"ppv"</code> a distribution of 
the bootstrapped plug-in p-values is plotted.</p>
</td></tr>
<tr><td><code id="InformativeTesting+2B20methods_+3A_main">main</code></td>
<td>
<p>The main title(s) for the plot(s).</p>
</td></tr>
<tr><td><code id="InformativeTesting+2B20methods_+3A_xlab">xlab</code></td>
<td>
<p>A label for the x axis, default depends on input type.</p>
</td></tr>
<tr><td><code id="InformativeTesting+2B20methods_+3A_ylab">ylab</code></td>
<td>
<p>A label for the y axis.</p>
</td></tr>
<tr><td><code id="InformativeTesting+2B20methods_+3A_freq">freq</code></td>
<td>
<p>Logical; if TRUE, the histogram graphic is a representation of 
frequencies, the counts component of the result; if <code>FALSE</code>, 
probability densities, component density, are plotted 
(so that the histogram has a total area of one). The default is 
set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="InformativeTesting+2B20methods_+3A_breaks">breaks</code></td>
<td>
<p>see <code><a href="graphics.html#topic+hist">hist</a></code></p>
</td></tr> 
<tr><td><code id="InformativeTesting+2B20methods_+3A_cex.main">cex.main</code></td>
<td>
<p>The magnification to be used for main titles relative to the 
current setting of cex.</p>
</td></tr>
<tr><td><code id="InformativeTesting+2B20methods_+3A_cex.lab">cex.lab</code></td>
<td>
<p>The magnification to be used for x and y labels relative to 
the current setting of cex.</p>
</td></tr>
<tr><td><code id="InformativeTesting+2B20methods_+3A_cex.axis">cex.axis</code></td>
<td>
<p>The magnification to be used for axis annotation relative to         
the current setting of cex.</p>
</td></tr>  
<tr><td><code id="InformativeTesting+2B20methods_+3A_col">col</code></td>
<td>
<p>A colour to be used to fill the bars. The default of NULL 
yields unfilled bars.</p>
</td></tr>
<tr><td><code id="InformativeTesting+2B20methods_+3A_border">border</code></td>
<td>
<p>Color for rectangle border(s). The default means par(&quot;fg&quot;).</p>
</td></tr>
<tr><td><code id="InformativeTesting+2B20methods_+3A_vline">vline</code></td>
<td>
<p>Logical; if <code>TRUE</code> a vertical line is drawn 
at the observed LRT value. If 
<code>double.bootstrap = "FDB"</code> a vertical line is drawn at the 1-p* quantile 
of the second-level LRT values, where p* is the first-level bootstrapped p-value</p>
</td></tr>
<tr><td><code id="InformativeTesting+2B20methods_+3A_vline.col">vline.col</code></td>
<td>
<p>Color(s) for the vline.LRT.</p>
</td></tr>
<tr><td><code id="InformativeTesting+2B20methods_+3A_lty">lty</code></td>
<td>
<p>The line type. Line types can either be specified as an integer 
(0=blank, 1=solid (default), 2=dashed, 3=dotted, 4=dotdash, 
5=longdash, 6=twodash) or as one of the character strings 
&quot;blank&quot;, &quot;solid&quot;, &quot;dashed&quot;, &quot;dotted&quot;, &quot;dotdash&quot;, &quot;longdash&quot;, or 
&quot;twodash&quot;, where &quot;blank&quot; uses 'invisible lines' 
(i.e., does not draw them).</p>
</td></tr>
<tr><td><code id="InformativeTesting+2B20methods_+3A_lwd">lwd</code></td>
<td>
<p>The line width, a positive number, defaulting to 1.</p>
</td></tr>
<tr><td><code id="InformativeTesting+2B20methods_+3A_legend">legend</code></td>
<td>
<p>Logical; if <code>TRUE</code> a legend is added to the plot.</p>
</td></tr>
<tr><td><code id="InformativeTesting+2B20methods_+3A_bty">bty</code></td>
<td>
<p>A character string which determined the type of box which is drawn 
about plots. If bty is one of &quot;o&quot; (the default), &quot;l&quot;, &quot;7&quot;, &quot;c&quot;, &quot;u&quot;, or &quot;]&quot; 
the resulting box resembles the corresponding upper case letter. A value of 
&quot;n&quot; suppresses the box.</p>
</td></tr>
<tr><td><code id="InformativeTesting+2B20methods_+3A_cex.legend">cex.legend</code></td>
<td>
<p>A numerical value giving the amount by which the legend 
text and symbols should be magnified relative to the default. 
This starts as 1 when a device is opened, and is reset when the layout 
is changed.</p>
</td></tr>
<tr><td><code id="InformativeTesting+2B20methods_+3A_loc.legend">loc.legend</code></td>
<td>
<p>The location of the legend, specified by a single 
keyword from the list <code>"bottomright"</code>, <code>"bottom"</code>, 
<code>"bottomleft"</code>, <code>"left"</code>, <code>"topleft"</code>, <code>"top"</code>, 
<code>"topright"</code>, <code>"right"</code> and <code>"center"</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Leonard Vanbrabant
<a href="mailto:lgf.vanbrabant@gmail.com">lgf.vanbrabant@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#########################
### real data example ###
#########################
# Multiple group path model for facial burns example.

# model syntax with starting values.
  burns.model &lt;- 'Selfesteem ~ Age + c(m1, f1)*TBSA + HADS +
                             start(-.10, -.20)*TBSA  
                 HADS ~ Age + c(m2, f2)*TBSA + RUM +
                        start(.10, .20)*TBSA '
 
 
# constraints syntax
 burns.constraints &lt;- 'f2 &gt; 0  ; m1 &lt; 0
                       m2 &gt; 0  ; f1 &lt; 0
                       f2 &gt; m2 ; f1 &lt; m1'
 
# we only generate 2 bootstrap samples in this example; in practice
# you may wish to use a much higher number. 
# the double bootstrap was switched off; in practice you probably 
# want to set it to "standard".
example1 &lt;- InformativeTesting(model = burns.model, data = FacialBurns,
                               R = 2, constraints = burns.constraints,
                               double.bootstrap = "no", group = "Sex")
example1
plot(example1)

##########################
### artificial example ###
##########################
# Simple ANOVA model with 3 groups (N = 20 per group)
set.seed(1234)
Y &lt;- cbind(c(rnorm(20,0,1), rnorm(20,0.5,1), rnorm(20,1,1)))
grp &lt;- c(rep("1", 20), rep("2", 20), rep("3", 20))
Data &lt;- data.frame(Y, grp)

#create model matrix
fit.lm &lt;- lm(Y ~ grp, data = Data)
mfit &lt;- fit.lm$model
mm &lt;- model.matrix(mfit)

Y &lt;- model.response(mfit)
X &lt;- data.frame(mm[,2:3])
names(X) &lt;- c("d1", "d2")
Data.new &lt;- data.frame(Y, X)

# model
model &lt;- 'Y ~ 1 + a1*d1 + a2*d2'

# fit without constraints
fit &lt;- sem(model, data = Data.new)

# constraints syntax: mu1 &lt; mu2 &lt; mu3
constraints &lt;- ' a1 &gt; 0
                 a1 &lt; a2 '

# we only generate 10 bootstrap samples in this example; in practice
# you may wish to use a much higher number, say &gt; 1000. The double 
# bootstrap is not necessary in case of an univariate ANOVA model.
example2 &lt;- InformativeTesting(model = model, data = Data.new, 
                               start = parTable(fit),
                               R = 10L, double.bootstrap = "no",
                               constraints = constraints)
example2
# plot(example2)

## End(Not run)
</code></pre>

<hr>
<h2 id='inspectSampleCov'>Observed Variable Correlation Matrix from a Model and Data</h2><span id='topic+inspectSampleCov'></span>

<h3>Description</h3>

<p>The lavaan model syntax describes a latent variable model. Often, the user wants to see the covariance matrix generated by their model for diagnostic purposes.  However, their data may have far more columns of information than what is contained in their model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>inspectSampleCov(model, data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inspectSampleCov_+3A_model">model</code></td>
<td>
<p>The model that will be fit by lavaan.</p>
</td></tr>
<tr><td><code id="inspectSampleCov_+3A_data">data</code></td>
<td>
<p>The data frame being used to fit the model.</p>
</td></tr>
<tr><td><code id="inspectSampleCov_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="#topic+sem">sem</a></code> for how to deal with 
multiple groups, missing values, etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One must supply both a model, coded with proper <code><a href="#topic+model.syntax">model.syntax</a></code> and
a data frame from which a covariance matrix will be calculated. This function
essentially calls <code><a href="#topic+sem">sem</a></code>, but doesn't fit the model, then uses
<code><a href="#topic+lavInspect">lavInspect</a></code> to get the sample covariance matrix and meanstructure.
</p>


<h3>See also</h3>

<p><code><a href="#topic+sem">sem</a></code>, <code><a href="#topic+lavInspect">lavInspect</a></code> </p>


<h3>Author(s)</h3>

<p>Jarrett Byrnes</p>

<hr>
<h2 id='lav_constraints'>Utility Functions: Constraints</h2><span id='topic+lav_constraints_parse'></span><span id='topic+lav_partable_constraints_ceq'></span><span id='topic+lav_partable_constraints_ciq'></span><span id='topic+lav_partable_constraints_def'></span>

<h3>Description</h3>

<p>Utility functions for equality and inequality constraints.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lav_constraints_parse(partable = NULL, constraints = NULL, theta = NULL, 
                     debug = FALSE)
lav_partable_constraints_ceq(partable, con = NULL, debug = FALSE, 
                             txtOnly = FALSE)
lav_partable_constraints_ciq(partable, con = NULL, debug = FALSE, 
                             txtOnly = FALSE)
lav_partable_constraints_def(partable, con = NULL, debug = FALSE, 
                             txtOnly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lav_constraints_+3A_partable">partable</code></td>
<td>
<p>A lavaan parameter table.</p>
</td></tr>
<tr><td><code id="lav_constraints_+3A_constraints">constraints</code></td>
<td>
<p>A character string containing the constraints.</p>
</td></tr>
<tr><td><code id="lav_constraints_+3A_theta">theta</code></td>
<td>
<p>A numeric vector. Optional vector with values for the
model parameters in the parameter table.</p>
</td></tr>
<tr><td><code id="lav_constraints_+3A_debug">debug</code></td>
<td>
<p>Logical. If TRUE, show debugging information.</p>
</td></tr>
<tr><td><code id="lav_constraints_+3A_con">con</code></td>
<td>
<p>An optional partable where the operator is one of &lsquo;==&rsquo;,
&lsquo;&gt;&rsquo;, &lsquo;&lt;&rsquo; or &lsquo;:=&rsquo;</p>
</td></tr>
<tr><td><code id="lav_constraints_+3A_txtonly">txtOnly</code></td>
<td>
<p>Logical. If TRUE, only the body of the function is returned as a character string. If FALSE, a function is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a collection of lower-level constraint related functions
that are used in the lavaan code. They are made public per
request of package developers. Below is a brief description of what
they do:
</p>
<p>The <code>lav_constraints_parse</code> function parses the constraints
specification (provided as a string, see example), and generates
a list with useful information about the constraints.
</p>
<p>The <code>lav_partable_constraints_ceq</code> function creates a function 
which takes the (unconstrained) parameter vector as input, and
returns the slack values for each equality constraint. If the equality
constraints hold perfectly, this function returns zeroes.
</p>
<p>The <code>lav_partable_constraints_ciq</code> function creates a function
which takes the (unconstrained) parameter vector as input, and
returns the slack values for each inequality constraint. 
</p>
<p>The <code>lav_partable_constraints_def</code> function creates a function
which takes the (unconstrained) parameter vector as input, and
returns the computed values of the defined parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myModel &lt;- 'x1 ~ a*x2 + b*x3 + c*x4'
myParTable &lt;- lavaanify(myModel, as.data.frame. = FALSE)
con &lt;- ' a == 2*b
         b - c == 5 '
conInfo &lt;- lav_constraints_parse(myParTable, constraints = con)

myModel2 &lt;- 'x1 ~ a*x2 + b*x3 + c*x4
             a == 2*b
             b - c == 5 '
ceq &lt;- lav_partable_constraints_ceq(partable = lavaanify(myModel2))
ceq( c(2,3,4) )
</code></pre>

<hr>
<h2 id='lav_data'>lavaan data functions</h2><span id='topic+lav_data_update'></span>

<h3>Description</h3>

<p>Utility functions related to the Data slot</p>


<h3>Usage</h3>

<pre><code class='language-R'># update data slot with new data (of the same size)
lav_data_update(lavdata = NULL, newX = NULL, BOOT.idx = NULL, lavoptions = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lav_data_+3A_lavdata">lavdata</code></td>
<td>
<p>A lavdata object.</p>
</td></tr>
<tr><td><code id="lav_data_+3A_newx">newX</code></td>
<td>
<p>A list of (new) data matrices (per group) of the same size. 
They will replace the data stored in the internal dataslot.</p>
</td></tr>
<tr><td><code id="lav_data_+3A_boot.idx">BOOT.idx</code></td>
<td>
<p>A list of integers. If bootstrapping was used to produce
the data in newX, use these indices to adapt the remaining slots.</p>
</td></tr>
<tr><td><code id="lav_data_+3A_lavoptions">lavoptions</code></td>
<td>
<p>A named list. The Options lsot from a lavaan object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># generate syntax for an independence model
HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- cfa(HS.model, data=HolzingerSwineford1939)

# extract data slot and options
lavdata &lt;- fit@Data
lavoptions &lt;- lavInspect(fit, "options")

# create bootstrap sample
boot.idx &lt;- sample(x = nobs(fit), size = nobs(fit), replace = TRUE)
newX &lt;- list(lavdata@X[[1]][boot.idx,])

# generate update lavdata object
newdata &lt;- lav_data_update(lavdata = lavdata, newX = newX, 
                           lavoptions = lavoptions)
</code></pre>

<hr>
<h2 id='lav_export_estimation'>lav_export_estimation</h2><span id='topic+lav_export_estimation'></span>

<h3>Description</h3>

<p>lavaan provides a range of optimization methods with the optim.method argument
(nlminb, BFGS, L-BFGS-B, GN, and nlminb.constr). 'lav_export_estimation' 
allows exporting objects and functions necessary to pass a lavaan model into
any optimizer that takes a combination of (1) starting values, (2) fit-function,
(3) gradient-function, and (4) upper and lower bounds. This allows testing new
optimization frameworks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lav_export_estimation(lavaan_model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lav_export_estimation_+3A_lavaan_model">lavaan_model</code></td>
<td>
<p>a fitted lavaan model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with:
</p>

<ul>
<li><p> get_coef - When working with equality constraints, lavaan internally
uses some transformations. get_coef is a functions that recreates the coef
function for the parameters. 
</p>
</li>
<li><p> starting_values - starting_values to be used in the optimization
</p>
</li>
<li><p> objective_function - objective function, expecting the current parameter
values and the lavaan model
</p>
</li>
<li><p> gradient_function - gradient function, expecting the current parameter
values and the lavaan model
</p>
</li>
<li><p> lower - lower bounds for parameters
</p>
</li>
<li><p> upper - upper bound for parameters
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(lavaan)
model &lt;- ' 
  # latent variable definitions
     ind60 =~ x1 + x2 + x3
     dem60 =~ y1 + y2 + y3 + y4
     dem65 =~ y5 + a*y6 + y7 + y8

  # regressions
    dem60 ~ ind60
    dem65 ~ ind60 + dem60
'

fit &lt;- sem(model, 
           data = PoliticalDemocracy, 
           do.fit = FALSE)

est &lt;- lav_export_estimation(lavaan_model = fit)

# The starting values are:
est$starting_values
# Note that these do not have labels (and may also differ from coef(fit)
# in case of equality constraints):
coef(fit)
# To get the same parameters, use:
est$get_coef(parameter_values = est$starting_values, 
             lavaan_model = fit)

# The objective function can be used to compute the fit at the current estimates:
est$objective_function(parameter_values = est$starting_values, 
                       lavaan_model = fit)

# The gradient function can be used to compute the gradients at the current estimates:
est$gradient_function(parameter_values = est$starting_values, 
                      lavaan_model = fit)

# Together, these elements provide the means to estimate the parameters with a large
# range of optimizers. For simplicity, here is an example using optim:
est_fit &lt;- optim(par = est$starting_values, 
                 fn = est$objective_function,
                 gr = est$gradient_function,
                 lavaan_model = fit,
                 method = "BFGS")
est$get_coef(parameter_values = est_fit$par,
             lavaan_model = fit)

# This is identical to
coef(sem(model, 
         data = PoliticalDemocracy))

# Example using ridge regularization for parameter a
fn_ridge &lt;- function(parameter_values, lavaan_model, est, lambda){
  return(est$objective_function(parameter_values = parameter_values, 
                                lavaan_model = lavaan_model) + lambda * parameter_values[6]^2)
}
ridge_fit &lt;- optim(par = est$get_coef(est$starting_values,
                                      lavaan_model = fit), 
                   fn = fn_ridge, 
                   lavaan_model = fit,
                   est = est,
                   lambda = 10)
est$get_coef(parameter_values = ridge_fit$par,
             lavaan_model = fit)
</code></pre>

<hr>
<h2 id='lav_func'>Utility Functions: Gradient and Jacobian</h2><span id='topic+lav_func_gradient_complex'></span><span id='topic+lav_func_gradient_simple'></span><span id='topic+lav_func_jacobian_complex'></span><span id='topic+lav_func_jacobian_simple'></span>

<h3>Description</h3>

<p>Utility functions for computing the gradient of a scalar-valued 
function or the Jacobian of a vector-valued function by numerical approximation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lav_func_gradient_complex(func, x, h = .Machine$double.eps, ..., 
                          fallback.simple = TRUE)
lav_func_jacobian_complex(func, x, h = .Machine$double.eps, ...,
                          fallback.simple = TRUE)

lav_func_gradient_simple(func, x, h = sqrt(.Machine$double.eps), ...)
lav_func_jacobian_simple(func, x, h = sqrt(.Machine$double.eps), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lav_func_+3A_func">func</code></td>
<td>
<p>A real-valued function returning a numeric scalar or a 
numeric vector.</p>
</td></tr>
<tr><td><code id="lav_func_+3A_x">x</code></td>
<td>
<p>A numeric vector: the point(s) at which the gradient/Jacobian
of the function should be computed.</p>
</td></tr>
<tr><td><code id="lav_func_+3A_h">h</code></td>
<td>
<p>Numeric value representing a small change in &lsquo;x&rsquo; when
computing the gradient/Jacobian.</p>
</td></tr>
<tr><td><code id="lav_func_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function &lsquo;func&rsquo;.</p>
</td></tr>
<tr><td><code id="lav_func_+3A_fallback.simple">fallback.simple</code></td>
<td>
<p>Logical. If TRUE, and the function evaluation fails,
we call the corresponding simple (non-complex) method instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The complex versions use complex numbers to gain more precision, while
retaining the simplicity (and speed) of the simple forward method (see
references). These
functions were added to lavaan (around 2012) when the complex functionality
was not part of the numDeriv package. They were used internally, and made
public in 0.5-17 per request of other package developers.
</p>


<h3>References</h3>

<p>Squire, W. and Trapp, G. (1998). Using Complex Variables to Estimate 
Derivatives of Real Functions. SIAM Review, 40(1), 110-112.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># very accurate complex method
lav_func_gradient_complex(func = exp, x = 1) - exp(1)

# less accurate forward method
lav_func_gradient_simple(func = exp, x = 1) - exp(1)

# very accurate complex method
diag(lav_func_jacobian_complex(func = exp, x = c(1,2,3))) - exp(c(1,2,3))

# less accurate forward method
diag(lav_func_jacobian_simple(func = exp, x = c(1,2,3))) - exp(c(1,2,3))
</code></pre>

<hr>
<h2 id='lav_matrix'>Utility Functions: Matrices and Vectors</h2><span id='topic+lav_matrix_vec'></span><span id='topic+lav_matrix_vecr'></span><span id='topic+lav_matrix_vech'></span><span id='topic+lav_matrix_vechr'></span><span id='topic+lav_matrix_vechu'></span><span id='topic+lav_matrix_vechru'></span><span id='topic+lav_matrix_vech_idx'></span><span id='topic+lav_matrix_vech_row_idx'></span><span id='topic+lav_matrix_vech_col_idx'></span><span id='topic+lav_matrix_vechr_idx'></span><span id='topic+lav_matrix_vechu_idx'></span><span id='topic+lav_matrix_vechru_idx'></span><span id='topic+lav_matrix_vech_reverse'></span><span id='topic+lav_matrix_vechru_reverse'></span><span id='topic+lav_matrix_upper2full'></span><span id='topic+lav_matrix_vechr_reverse'></span><span id='topic+lav_matrix_vechu_reverse'></span><span id='topic+lav_matrix_lower2full'></span><span id='topic+lav_matrix_diag_idx'></span><span id='topic+lav_matrix_diagh_idx'></span><span id='topic+lav_matrix_antidiag_idx'></span><span id='topic+lav_matrix_duplication'></span><span id='topic+lav_matrix_duplication_pre'></span><span id='topic+lav_matrix_duplication_post'></span><span id='topic+lav_matrix_duplication_pre_post'></span><span id='topic+lav_matrix_duplication_ginv'></span><span id='topic+lav_matrix_duplication_ginv_pre'></span><span id='topic+lav_matrix_duplication_ginv_post'></span><span id='topic+lav_matrix_duplication_ginv_pre_post'></span><span id='topic+lav_matrix_commutation'></span><span id='topic+lav_matrix_commutation_pre'></span><span id='topic+lav_matrix_commutation_post'></span><span id='topic+lav_matrix_commutation_pre_post'></span><span id='topic+lav_matrix_commutation_mn_pre'></span><span id='topic+lav_matrix_symmetric_sqrt'></span><span id='topic+lav_matrix_orthogonal_complement'></span><span id='topic+lav_matrix_bdiag'></span><span id='topic+lav_matrix_trace'></span><span id='topic+lav_matrix_cov'></span>

<h3>Description</h3>

<p>Utility functions for Matrix and Vector operations.</p>


<h3>Usage</h3>

<pre><code class='language-R'># matrix to vector
lav_matrix_vec(A)
lav_matrix_vecr(A)
lav_matrix_vech(S, diagonal = TRUE)
lav_matrix_vechr(S, diagonal = TRUE)

# matrix/vector indices
lav_matrix_vech_idx(n = 1L, diagonal = TRUE)
lav_matrix_vech_row_idx(n = 1L, diagonal = TRUE)
lav_matrix_vech_col_idx(n = 1L, diagonal = TRUE)
lav_matrix_vechr_idx(n = 1L, diagonal = TRUE)
lav_matrix_vechru_idx(n = 1L, diagonal = TRUE)
lav_matrix_diag_idx(n = 1L)
lav_matrix_diagh_idx(n = 1L)
lav_matrix_antidiag_idx(n = 1L)

# vector to matrix
lav_matrix_vech_reverse(x, diagonal = TRUE)
lav_matrix_vechru_reverse(x, diagonal = TRUE) 
lav_matrix_upper2full(x, diagonal = TRUE)
lav_matrix_vechr_reverse(x, diagonal = TRUE)
lav_matrix_vechu_reverse(x, diagonal = TRUE)
lav_matrix_lower2full(x, diagonal = TRUE)

# the duplication matrix
lav_matrix_duplication(n = 1L)
lav_matrix_duplication_pre(A = matrix(0,0,0))
lav_matrix_duplication_post(A = matrix(0,0,0))
lav_matrix_duplication_pre_post(A = matrix(0,0,0))
lav_matrix_duplication_ginv(n = 1L)
lav_matrix_duplication_ginv_pre(A = matrix(0,0,0))
lav_matrix_duplication_ginv_post(A = matrix(0,0,0))
lav_matrix_duplication_ginv_pre_post(A = matrix(0,0,0))

# the commutation matrix
lav_matrix_commutation(m = 1L, n = 1L)
lav_matrix_commutation_pre(A = matrix(0,0,0))
lav_matrix_commutation_post(A = matrix(0,0,0))
lav_matrix_commutation_pre_post(A = matrix(0,0,0))
lav_matrix_commutation_mn_pre(A, m = 1L, n = 1L)

# sample statistics
lav_matrix_cov(Y, Mu = NULL)

# other matrix operations
lav_matrix_symmetric_sqrt(S = matrix(0,0,0))
lav_matrix_orthogonal_complement(A = matrix(0,0,0))
lav_matrix_bdiag(...)
lav_matrix_trace(..., check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lav_matrix_+3A_a">A</code></td>
<td>
<p>A general matrix.</p>
</td></tr>
<tr><td><code id="lav_matrix_+3A_s">S</code></td>
<td>
<p>A symmetric matrix.</p>
</td></tr>
<tr><td><code id="lav_matrix_+3A_y">Y</code></td>
<td>
<p>A matrix representing a (numeric) dataset.</p>
</td></tr>
<tr><td><code id="lav_matrix_+3A_diagonal">diagonal</code></td>
<td>
<p>Logical. If TRUE, include the diagonal.</p>
</td></tr>
<tr><td><code id="lav_matrix_+3A_n">n</code></td>
<td>
<p>Integer. When it is the only argument, the dimension of a square 
matrix. If m is also provided, the number of column of the matrix.</p>
</td></tr>
<tr><td><code id="lav_matrix_+3A_m">m</code></td>
<td>
<p>Integer. The number of rows of a matrix.</p>
</td></tr>
<tr><td><code id="lav_matrix_+3A_x">x</code></td>
<td>
<p>Numeric. A vector.</p>
</td></tr>
<tr><td><code id="lav_matrix_+3A_mu">Mu</code></td>
<td>
<p>Numeric. If given, use Mu (instead of sample mean) to center, before 
taking the crossproduct.</p>
</td></tr>
<tr><td><code id="lav_matrix_+3A_...">...</code></td>
<td>
<p>One or more matrices, or a list of matrices.</p>
</td></tr>
<tr><td><code id="lav_matrix_+3A_check">check</code></td>
<td>
<p>Logical. If <code>check = TRUE</code>, we check if the (final) matrix 
is square.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are a collection of lower-level matrix/vector related functions
that are used throughout the lavaan code. They are made public per
request of package developers. Below is a brief description of what
they do:
</p>
<p>The <code>lav_matrix_vec</code> function implements the vec operator (for
'vectorization') and transforms a matrix into a vector by stacking the
columns of the matrix one underneath the other.
</p>
<p>The <code>lav_matrix_vecr</code> function is similar to the <code>lav_matrix_vec</code>
function but transforms a matrix into a vector by stacking the
rows of the matrix one underneath the other.
</p>
<p>The <code>lav_matrix_vech</code> function implements the vech operator
(for 'half vectorization') and transforms a symmetric matrix
into a vector by stacking the columns of the matrix one underneath the
other, but eliminating all supradiagonal elements. If diagonal = FALSE,
the diagonal elements are also eliminated.
</p>
<p>The <code>lav_matrix_vechr</code> function is similar to the <code>lav_matrix_vech</code> 
function but transforms a matrix into a vector by stacking the
rows of the matrix one underneath the other, eliminating all 
supradiagonal elements.
</p>
<p>The <code>lav_matrix_vech_idx</code> function returns the vector indices of the lower
triangular elements of a symmetric matrix of size n, column by column.
</p>
<p>The <code>lav_matrix_vech_row_idx</code> function returns the row indices of the
lower triangular elements of a symmetric matrix of size n.
</p>
<p>The <code>lav_matrix_vech_col_idx</code> function returns the column indices of the
lower triangular elements of a symmetric matrix of size n.
</p>
<p>The <code>lav_matrix_vechr_idx</code> function returns the vector indices of the
lower triangular elements of a symmetric matrix of size n, row by row.
</p>
<p>The <code>lav_matrix_vechu_idx</code> function returns the vector indices of the
upper triangular elements of a symmetric matrix of size n, column by column.
</p>
<p>The <code>lav_matrix_vechru_idx</code> function returns the vector indices
of the upper triangular elements of a symmetric matrix of size n, row by row.
</p>
<p>The <code>lav_matrix_diag_idx</code> function returns the vector indices of the
diagonal elements of a symmetric matrix of size n.
</p>
<p>The <code>lav_matrix_diagh_idx</code> function returns the vector indices of
the lower part of a symmetric matrix of size n.
</p>
<p>The <code>lav_matrix_antidiag_idx</code> function returns the vector indices of
the anti diagonal elements a symmetric matrix of size n.
</p>
<p>The <code>lav_matrix_vech_reverse</code> function (alias:
<code>lav_matrix_vechru_reverse</code> and <code>lav_matrix_upper2full</code>) creates a
symmetric matrix, given only upper triangular elements, row by row. If
diagonal = FALSE, an diagonal with zero elements is added.
</p>
<p>The <code>lav_matrix_vechr_reverse</code> (alias: <code>lav_matrix_vechu_reverse</code> and
<code>lav_matrix_lower2full</code>) creates a symmetric matrix, given only the lower
triangular elements, row by row. If diagonal = FALSE, an diagonal with zero
elements is added.
</p>
<p>The <code>lav_matrix_duplication</code> function generates the duplication matrix
for a symmetric matrix of size n. This matrix duplicates the elements in
vech(S) to create vec(S) (where S is symmetric). This matrix is very
sparse, and should probably never be explicitly created. Use one of 
the functions below.
</p>
<p>The <code>lav_matrix_duplication_pre</code> function computes the product of the
transpose of the duplication matrix and a matrix A. The A matrix should have
n*n rows, where n is an integer. The duplication matrix is not explicitly
created.
</p>
<p>The <code>lav_matrix_duplication_post</code> function computes the product of a
matrix A with the duplication matrix. The A matrix should have n*n columns,
where n is an integer. The duplication matrix is not explicitly created.
</p>
<p>The <code>lav_matrix_duplication_pre_post</code> function first pre-multiplies a
matrix A with the transpose of the duplication matrix, and then post multiplies
the result again with the duplication matrix. A must be square matrix with n*n
rows and columns, where n is an integer. The duplication matrix is not
explicitly created.
</p>
<p>The <code>lav_matrix_duplication_ginv</code> function computes the generalized
inverse of the duplication matrix. The matrix removes the duplicated elements
in vec(S) to create vech(S). This matrix is very sparse, and should probably
never be explicitly created. Use one of the functions below.
</p>
<p>The <code>lav_matrix_duplication_ginv_pre</code> function computes the product of the
generalized inverse of the duplication matrix and a matrix A with n*n rows,
where n is an integer. The generalized inverse of the duplication matrix
is not explicitly created.
</p>
<p>The <code>lav_matrix_duplication_ginv_post</code> function computes the product of a
matrix A (with n*n columns, where n is an integer) and the transpose of the
generalized inverse of the duplication matrix. The generalized inverse of the
duplication matrix is not explicitly created.
</p>
<p>The <code>lav_matrix_duplication_ginv_pre_post</code> function first pre-multiplies
a matrix A with the transpose of the generalized inverse of the duplication
matrix, and then post multiplies the result again with the transpose of the
generalized inverse matrix. The matrix A must be square with n*n rows and
columns, where n is an integer. The generalized inverse of the duplication
matrix is not explicitly created.
</p>
<p>The <code>lav_matrix_commutation</code> function computes the commutation matrix which
is a permutation matrix which transforms vec(A) (with m rows and n columns) 
into vec(t(A)).
</p>
<p>The <code>lav_matrix_commutation_pre</code> function computes the product of the
commutation matrix with a matrix A, without explicitly creating the commutation
matrix. The matrix A must have n*n rows, where n is an integer.
</p>
<p>The <code>lav_matrix_commutation_post</code> function computes the product of a 
matrix A with the commutation matrix, without explicitly creating the 
commutation matrix. The matrix A must have n*n rows, where n is an integer.
</p>
<p>The <code>lav_matrix_commutation_pre_post</code> function first pre-multiplies
a matrix A with the commutation matrix, and then post multiplies the result again with the commutation matrix, without explicitly creating the 
commutation matrix. The matrix A must have n*n rows, where n is an integer.
</p>
<p>The <code>lav_matrix_commutation_mn_pre</code> function computes the product of the
commutation matrix with a matrix A, without explicitly creating the commutation
matrix. The matrix A must have m*n rows, where m and n are integers.
</p>
<p>The <code>lav_matrix_cov</code> function computes the sample covariance matrix of
its input matrix, where the elements are divided by N (the number of rows).
</p>
<p>The <code>lav_matrix_symmetric_sqrt</code> function computes the square root of a
positive definite symmetric matrix (using an eigen decomposition).  If some of
the eigenvalues are negative, they are silently fixed to zero.
</p>
<p>The <code>lav_matrix_orthogonal_complement</code> function computes an orthogonal
complement of the matrix A, using a qr decomposition.
</p>
<p>The <code>lav_matrix_bdiag</code> function constructs a block diagonal matrix from
its arguments.
</p>
<p>The <code>lav_matrix_trace</code> function computes the trace (the sum of the
diagonal elements) of a single (square) matrix, or if multiple matrices are
provided (either as a list, or as multiple arguments), we first compute their
product (which must result in a square matrix), and then we compute the trace; 
if <code>check = TRUE</code>, we check if the (final) matrix is square.
</p>


<h3>References</h3>

<p>Magnus, J. R. and H. Neudecker (1999). Matrix Differential Calculus
with Applications in Statistics and Econometrics, Second Edition, John Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># upper elements of a 3 by 3 symmetric matrix (row by row)
x &lt;- c(30, 16, 5, 10, 3, 1)
# construct full symmetric matrix
S &lt;- lav_matrix_upper2full(x)

# compute the normal theory `Gamma' matrix given a covariance
# matrix (S), using the formula: Gamma = 2 * D^{+} (S %x% S) t(D^{+})
Gamma.NT &lt;- 2 * lav_matrix_duplication_ginv_pre_post(S %x% S)
Gamma.NT
</code></pre>

<hr>
<h2 id='lav_model'>lavaan model functions</h2><span id='topic+lav_model_get_parameters'></span><span id='topic+lav_model_set_parameters'></span><span id='topic+lav_model_implied'></span><span id='topic+lav_model_vcov_se'></span>

<h3>Description</h3>

<p>Utility functions related to internal model representation (lavmodel)</p>


<h3>Usage</h3>

<pre><code class='language-R'># set/get free parameters
lav_model_set_parameters(lavmodel, x = NULL)
lav_model_get_parameters(lavmodel, GLIST = NULL, type = "free",
                         extra = TRUE)

# compute model-implied statistics
lav_model_implied(lavmodel, GLIST = NULL, delta = TRUE)

# compute standard errors
lav_model_vcov_se(lavmodel, lavpartable, VCOV = NULL, BOOT = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lav_model_+3A_lavmodel">lavmodel</code></td>
<td>
<p>An internal representation of a lavaan model.</p>
</td></tr>
<tr><td><code id="lav_model_+3A_x">x</code></td>
<td>
<p>Numeric. A vector containing the values of all the free model parameters.</p>
</td></tr>
<tr><td><code id="lav_model_+3A_glist">GLIST</code></td>
<td>
<p>List. A list of model matrices, similar to the output of 
<code>lavInspect(object, "est")</code>.</p>
</td></tr>
<tr><td><code id="lav_model_+3A_type">type</code></td>
<td>
<p>Character string. If <code>"free"</code>, only return the free model
parameters. If <code>"user"</code>, return all the parameters (free and fixed) as
they appear in the user-specified parameter table.</p>
</td></tr>
<tr><td><code id="lav_model_+3A_extra">extra</code></td>
<td>
<p>Logical. If <code>TRUE</code>, also include values for rows in
the parameter table where the operator is one of <code>":="</code>, <code>"=="</code>,
<code>"&lt;"</code> or <code>"&gt;"</code>.</p>
</td></tr>
<tr><td><code id="lav_model_+3A_delta">delta</code></td>
<td>
<p>Logical. If <code>TRUE</code>, and a Delta matrix is present in GLIST,
use the (diagonal) values of the Delta matrix to rescale the covariance matrix.
This is usually needed in the categorical setting to convert covariances to
correlations.</p>
</td></tr>
<tr><td><code id="lav_model_+3A_lavpartable">lavpartable</code></td>
<td>
<p>A parameter table.</p>
</td></tr>
<tr><td><code id="lav_model_+3A_vcov">VCOV</code></td>
<td>
<p>Numeric matrix containing an estimate of the variance covariance matrix of the free model parameters.</p>
</td></tr>
<tr><td><code id="lav_model_+3A_boot">BOOT</code></td>
<td>
<p>Numeric matrix containing the bootstrap based parameter estimates (in the columns) for each bootstrap sample (in the rows).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- cfa(HS.model, data=HolzingerSwineford1939)
lavmodel &lt;- fit@Model

est &lt;- lav_model_get_parameters(lavmodel)
est
</code></pre>

<hr>
<h2 id='lav_partable'>lavaan partable functions</h2><span id='topic+lav_partable_independence'></span><span id='topic+lav_partable_unrestricted'></span><span id='topic+lav_partable_df'></span><span id='topic+lav_partable_ndat'></span><span id='topic+lav_partable_npar'></span><span id='topic+lav_partable_labels'></span><span id='topic+lav_partable_from_lm'></span><span id='topic+lav_partable_complete'></span><span id='topic+lav_partable_attributes'></span><span id='topic+lav_partable_merge'></span><span id='topic+lav_partable_add'></span>

<h3>Description</h3>

<p>Utility functions related to the parameter table (partable)</p>


<h3>Usage</h3>

<pre><code class='language-R'># extract information from a parameter table
lav_partable_df(partable)
lav_partable_ndat(partable)
lav_partable_npar(partable)
lav_partable_attributes(partable, pta = NULL)

# generate parameter labels
lav_partable_labels(partable, blocks = c("group", "level"), 
                    group.equal = "", group.partial = "", type = "user")

# generate parameter table for specific models
lav_partable_independence(lavobject = NULL, lavdata = NULL,
    lavpta = NULL, lavoptions = NULL, lavsamplestats = NULL,
    lavh1 = NULL,
    sample.cov = NULL, sample.mean = NULL, sample.slopes = NULL,
    sample.th = NULL, sample.th.idx = NULL,
    sample.cov.x = NULL, sample.mean.x = NULL)

lav_partable_unrestricted(lavobject = NULL, lavdata = NULL, 
    lavpta = NULL, lavoptions = NULL, lavsamplestats = NULL, 
    lavh1 = NULL,
    sample.cov = NULL, sample.mean = NULL, sample.slopes = NULL, 
    sample.th = NULL, sample.th.idx = NULL,
    sample.cov.x = NULL, sample.mean.x = NULL) 

lav_partable_from_lm(object, est = FALSE, label = FALSE, 
    as.data.frame. = FALSE)

# complete a parameter table only containing a few columns (lhs,op,rhs)
lav_partable_complete(partable = NULL, start = TRUE)

# merge two parameter tables
lav_partable_merge(pt1 = NULL, pt2 = NULL, remove.duplicated = FALSE, 
    fromLast = FALSE, warn = TRUE)

# add a single parameter to an existing parameter table
lav_partable_add(partable = NULL, add = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lav_partable_+3A_partable">partable</code></td>
<td>
<p>A parameter table. See <code><a href="#topic+lavParTable">lavParTable</a></code> 
for more information.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_blocks">blocks</code></td>
<td>
<p>Character vector. Which columns in the parameter table should be
taken to distinguish between different blocks of parameters (and hence
be given different labels)? If <code>"blocks"</code> includes <code>"group"</code>, a
suffix <code>".g"</code> and the group number (or group label) is added for 
the parameters of  all but the first group. If <code>"blocks"</code> includes 
<code>"level"</code>, a suffix <code>".l"</code> and the level number is added for 
the parameters of all but the first level. If <code>"blocks"</code> includes, 
say <code>"foo"</code>, a suffix <code>".foo"</code> and the corresponding value of
<code>"foo"</code> is added to all parameters.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_group.equal">group.equal</code></td>
<td>
<p>The same options can be used here as in the fitting functions. Parameters that are constrained to be equal across groups will be given the
same label.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_group.partial">group.partial</code></td>
<td>
<p>A vector of character strings containing the labels
of the parameters which should be free in all groups.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_type">type</code></td>
<td>
<p>Character string. Can be either &lsquo;user&rsquo; or &lsquo;free&rsquo; to select all
entries or only the free parameters from the parameter table respectively.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_lavobject">lavobject</code></td>
<td>
<p>An object of class &lsquo;lavaan&rsquo;. If this argument is provided,
it should be the only argument. All the values for the other arguments 
are extracted from this object.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_lavdata">lavdata</code></td>
<td>
<p>An object of class &lsquo;lavData&rsquo;. The Data slot from a lavaan object.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_lavoptions">lavoptions</code></td>
<td>
<p>A named list. The Options lsot from a lavaan object.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_lavsamplestats">lavsamplestats</code></td>
<td>
<p>An object of class &lsquo;lavSampleStats&rsquo;. The SampleStats
slot from a lavaan object.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_lavh1">lavh1</code></td>
<td>
<p>A named list. The h1 slot from a lavaan object.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_lavpta">lavpta</code></td>
<td>
<p>The pta (parameter table attributes) slot from a lavaan object.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_sample.cov">sample.cov</code></td>
<td>
<p>Optional list of numeric matrices. 
Each list element contains a sample variance-covariance matrix for this group.
If provided, these values will be used as starting values.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_sample.mean">sample.mean</code></td>
<td>
<p>Optional list of numeric vectors. 
Each list element contains a sample mean vector for this group. 
If provided, these values will be used as starting values.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_sample.slopes">sample.slopes</code></td>
<td>
<p>Optional list of numeric matrices.
Each list element contains the sample slopes for this group (only used
when <code>conditional.x = TRUE</code>).
If provided, these values will be used as starting values.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_sample.th">sample.th</code></td>
<td>
<p>Optional list of numeric vectors. 
Each list element contains a vector of sample thresholds for this group.
If provided (and also sample.th.idx is provided), 
these values will be used as starting values.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_sample.th.idx">sample.th.idx</code></td>
<td>
<p>Optional list of integers. Each list contains the
threshold indices for this group.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_sample.cov.x">sample.cov.x</code></td>
<td>
<p>Optional list of numeric matrices.  Each list element
contains a sample variance-covariance matrix for the exogenous variables
for this group (only used when <code>conditional.x = TRUE</code>).  If provided,
these values will be used as starting values.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_sample.mean.x">sample.mean.x</code></td>
<td>
<p>Optional list of numeric vectors.
Each list element contains a sample mean vector for the exogenous variables
for this group (only used when <code>conditional.x = TRUE</code>).
If provided, these values will be used as starting values.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_est">est</code></td>
<td>
<p>Logical. If TRUE, include the fitted estimates in the parameter table.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_label">label</code></td>
<td>
<p>Logical. If TRUE, include parameter labels in the parameter table.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_as.data.frame.">as.data.frame.</code></td>
<td>
<p>Logical. If TRUE, return the parameter table as a data.frame.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_object">object</code></td>
<td>
<p>An object of class <code>lm</code>.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_start">start</code></td>
<td>
<p>Logical. If TRUE, include a start column, based on 
the simple method for generating starting values.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_pta">pta</code></td>
<td>
<p>A list containing parameter attributes.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_pt1">pt1</code></td>
<td>
<p>A parameter table.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_pt2">pt2</code></td>
<td>
<p>A parameter table.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_remove.duplicated">remove.duplicated</code></td>
<td>
<p>Logical. If <code>TRUE</code>, remove duplicated elements
when merging two parameter tables.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_fromlast">fromLast</code></td>
<td>
<p>Logical. If <code>TRUE</code>, duplicated elements are considered
from the bottom of the merged parameter table.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_warn">warn</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a warning is produced when duplicated
elements are found, when merging two parameter tables.</p>
</td></tr>
<tr><td><code id="lav_partable_+3A_add">add</code></td>
<td>
<p>A named list.  A single row of a parameter table as a named list.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># generate syntax for an independence model
HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- cfa(HS.model, data=HolzingerSwineford1939)
lav &lt;- lav_partable_independence(fit)
as.data.frame(lav, stringsAsFactors = FALSE)


# how many free parameters?
lav_partable_npar(lav)

# how many sample statistics?
lav_partable_ndat(lav)
</code></pre>

<hr>
<h2 id='lav_samplestats'>lavaan samplestats functions</h2><span id='topic+lav_samplestats_from_data'></span>

<h3>Description</h3>

<p>Utility functions related to the sample statistics</p>


<h3>Usage</h3>

<pre><code class='language-R'># generate samplestats object from full data
lav_samplestats_from_data(lavdata = NULL, lavoptions = NULL, 
                          WLS.V = NULL, NACOV = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lav_samplestats_+3A_lavdata">lavdata</code></td>
<td>
<p>A lavdata object.</p>
</td></tr>
<tr><td><code id="lav_samplestats_+3A_lavoptions">lavoptions</code></td>
<td>
<p>A named list. The Options lsot from a lavaan object.</p>
</td></tr>
<tr><td><code id="lav_samplestats_+3A_wls.v">WLS.V</code></td>
<td>
<p>A user provided weight matrix.</p>
</td></tr>
<tr><td><code id="lav_samplestats_+3A_nacov">NACOV</code></td>
<td>
<p>A user provided matrix containing the elements of (N times)
the asymptotic variance-covariance matrix of the sample statistics.
For a multiple group analysis, a list with an asymptotic
variance-covariance matrix for each group.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># generate syntax for an independence model
HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- cfa(HS.model, data=HolzingerSwineford1939)

# extract data slot and options
lavdata &lt;- fit@Data
lavoptions &lt;- lavInspect(fit, "options")

# generate sample statistics object
sampleStats &lt;- lav_samplestats_from_data(lavdata = lavdata, 
                                         lavoptions = lavoptions)
</code></pre>

<hr>
<h2 id='lavaan'>Fit a Latent Variable Model</h2><span id='topic+lavaan'></span>

<h3>Description</h3>

<p>Fit a latent variable model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavaan(model = NULL, data = NULL, ordered = NULL,
       sampling.weights   = NULL,
       sample.cov = NULL, sample.mean = NULL, sample.th = NULL,
       sample.nobs = NULL,
       group = NULL, cluster = NULL, constraints = "", 
       WLS.V = NULL, NACOV = NULL, ov.order = "model",
       slotOptions = NULL, slotParTable = NULL, slotSampleStats = NULL,
       slotData = NULL, slotModel = NULL, slotCache = NULL,
       sloth1 = NULL,
       ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lavaan_+3A_model">model</code></td>
<td>
<p>A description of the user-specified model. Typically, the model
is described using the lavaan model syntax. See            
<code><a href="#topic+model.syntax">model.syntax</a></code> for more information. Alternatively, a
parameter table (eg. the output of the <code>lavaanify()</code> function) is also
accepted.</p>
</td></tr>
<tr><td><code id="lavaan_+3A_data">data</code></td>
<td>
<p>An optional data frame containing the observed variables used in
the model. If some variables are declared as ordered factors, lavaan will
treat them as ordinal variables.</p>
</td></tr>
<tr><td><code id="lavaan_+3A_ordered">ordered</code></td>
<td>
<p>Character vector. Only used if the data is in a data.frame.
Treat these variables as ordered (ordinal) variables, if they are
endogenous in the model. Importantly, all other variables will be treated
as numeric (unless they are declared as ordered in the data.frame.) 
Since 0.6-4, ordered can also be logical. If TRUE, all
observed endogenous variables are treated as ordered (ordinal).
If FALSE, all observed endogenous variables are considered to be numeric
(again, unless they are declared as ordered in the data.frame.)</p>
</td></tr>
<tr><td><code id="lavaan_+3A_sampling.weights">sampling.weights</code></td>
<td>
<p>A variable name in the data frame containing 
sampling weight information. Currently only available for non-clustered
data. Depending on the <code>sampling.weights.normalization</code> option, these
weights may be rescaled (or not) so that their sum equals the number of
observations (total or per group).</p>
</td></tr>
<tr><td><code id="lavaan_+3A_sample.cov">sample.cov</code></td>
<td>
<p>Numeric matrix. A sample variance-covariance matrix.
The rownames and/or colnames must contain the observed variable names.
For a multiple group analysis, a list with a variance-covariance matrix
for each group.</p>
</td></tr>
<tr><td><code id="lavaan_+3A_sample.mean">sample.mean</code></td>
<td>
<p>A sample mean vector. For a multiple group analysis,
a list with a mean vector for each group.</p>
</td></tr>
<tr><td><code id="lavaan_+3A_sample.th">sample.th</code></td>
<td>
<p>Vector of sample-based thresholds. For a multiple group
analysis, a list with a vector of thresholds for each group.</p>
</td></tr>
<tr><td><code id="lavaan_+3A_sample.nobs">sample.nobs</code></td>
<td>
<p>Number of observations if the full data frame is missing
and only sample moments are given. For a multiple group analysis, a list
or a vector with the number of observations for each group.</p>
</td></tr>
<tr><td><code id="lavaan_+3A_group">group</code></td>
<td>
<p>Character. A variable name in the data frame defining the groups
in a multiple group analysis.</p>
</td></tr>
<tr><td><code id="lavaan_+3A_cluster">cluster</code></td>
<td>
<p>Character. A (single) variable name in the data frame defining the clusters in a two-level dataset.</p>
</td></tr>
<tr><td><code id="lavaan_+3A_constraints">constraints</code></td>
<td>
<p>Additional (in)equality constraints not yet included in the
model syntax. See <code><a href="#topic+model.syntax">model.syntax</a></code> for more information.</p>
</td></tr>
<tr><td><code id="lavaan_+3A_wls.v">WLS.V</code></td>
<td>
<p>A user provided weight matrix to be used by estimator <code>"WLS"</code>;
if the estimator is <code>"DWLS"</code>, only the diagonal of this matrix will be
used. For a multiple group analysis, a list with a weight matrix
for each group. The elements of the weight matrix should be in the
following order (if all data is continuous): first the means (if a
meanstructure is involved), then the lower triangular elements of the
covariance matrix including the diagonal, ordered column by column. In
the categorical case: first the thresholds (including the means for
continuous variables), then the slopes (if any), the variances of
continuous variables (if any), and finally the lower triangular elements
of the correlation/covariance matrix excluding the diagonal, ordered
column by column.</p>
</td></tr>
<tr><td><code id="lavaan_+3A_nacov">NACOV</code></td>
<td>
<p>A user provided matrix containing the elements of (N times)
the asymptotic variance-covariance matrix of the sample statistics.
For a multiple group analysis, a list with an asymptotic
variance-covariance matrix for each group. See the <code>WLS.V</code>
argument for information about the order of the elements.</p>
</td></tr>
<tr><td><code id="lavaan_+3A_ov.order">ov.order</code></td>
<td>
<p>Character. If <code>"model"</code> (the default), the order of
the observed variable names (as reflected for example in the output of
<code>lavNames()</code>) is determined by the model syntax. If
<code>"data"</code>, the order is determined by the data (either the full
data.frame or the sample (co)variance matrix). If the <code>WLS.V</code> 
and/or <code>NACOV</code> matrices are provided, this argument is currently 
set to <code>"data"</code>.</p>
</td></tr>
<tr><td><code id="lavaan_+3A_slotoptions">slotOptions</code></td>
<td>
<p>Options slot from a fitted lavaan object. If provided,
no new Options slot will be created by this call.</p>
</td></tr>
<tr><td><code id="lavaan_+3A_slotpartable">slotParTable</code></td>
<td>
<p>ParTable slot from a fitted lavaan object. If provided,
no new ParTable slot will be created by this call.</p>
</td></tr>
<tr><td><code id="lavaan_+3A_slotsamplestats">slotSampleStats</code></td>
<td>
<p>SampleStats slot from a fitted lavaan object. 
If provided, no new SampleStats slot will be created by this call.</p>
</td></tr>
<tr><td><code id="lavaan_+3A_slotdata">slotData</code></td>
<td>
<p>Data slot from a fitted lavaan object. If provided,
no new Data slot will be created by this call.</p>
</td></tr>
<tr><td><code id="lavaan_+3A_slotmodel">slotModel</code></td>
<td>
<p>Model slot from a fitted lavaan object. If provided,
no new Model slot will be created by this call.</p>
</td></tr>
<tr><td><code id="lavaan_+3A_slotcache">slotCache</code></td>
<td>
<p>Cache slot from a fitted lavaan object. If provided,
no new Cache slot will be created by this call.</p>
</td></tr>
<tr><td><code id="lavaan_+3A_sloth1">sloth1</code></td>
<td>
<p>h1 slot from a fitted lavaan object. If provided,
no new h1 slot will be created by this call.</p>
</td></tr>
<tr><td><code id="lavaan_+3A_...">...</code></td>
<td>
<p>Many more additional options can be defined, using 'name = value'. 
See <code><a href="#topic+lavOptions">lavOptions</a></code> for a complete list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+lavaan-class">lavaan</a></code>, for which several methods
are available, including a <code>summary</code> method.
</p>


<h3>References</h3>

<p>Yves Rosseel (2012). lavaan: An R Package for Structural Equation
Modeling. Journal of Statistical Software, 48(2), 1-36. 
<a href="https://doi.org/10.18637/jss.v048.i02">doi:10.18637/jss.v048.i02</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+cfa">cfa</a></code>, <code><a href="#topic+sem">sem</a></code>, <code><a href="#topic+growth">growth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The Holzinger and Swineford (1939) example
HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- lavaan(HS.model, data=HolzingerSwineford1939,
              auto.var=TRUE, auto.fix.first=TRUE,
              auto.cov.lv.x=TRUE)
summary(fit, fit.measures=TRUE)
</code></pre>

<hr>
<h2 id='lavaan-class'>Class For Representing A (Fitted) Latent Variable Model</h2><span id='topic+lavaan-class'></span><span id='topic+coef+2Clavaan-method'></span><span id='topic+vcov+2Clavaan-method'></span><span id='topic+anova+2Clavaan-method'></span><span id='topic+predict+2Clavaan-method'></span><span id='topic+resid+2Clavaan-method'></span><span id='topic+residuals+2Clavaan-method'></span><span id='topic+fitted+2Clavaan-method'></span><span id='topic+fitted.values+2Clavaan-method'></span><span id='topic+nobs'></span><span id='topic+nobs+2Clavaan-method'></span><span id='topic+logLik+2Clavaan-method'></span><span id='topic+update+2Clavaan-method'></span><span id='topic+show+2Clavaan-method'></span><span id='topic+summary+2Clavaan-method'></span>

<h3>Description</h3>

<p>The <code>lavaan</code> class represents a (fitted) latent variable
model. It contains a description of the model as specified by the user,
a summary of the data, an internal matrix representation, and if the model
was fitted, the fitting results.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created via the
<code><a href="#topic+cfa">cfa</a></code>, <code><a href="#topic+sem">sem</a></code>, <code><a href="#topic+growth">growth</a></code> or
<code><a href="#topic+lavaan">lavaan</a></code> functions.
</p>


<h3>Slots</h3>


<dl>
<dt><code>version</code>:</dt><dd><p>The lavaan package version used to create this objects</p>
</dd>
<dt><code>call</code>:</dt><dd><p>The function call as returned by <code>match.call()</code>.</p>
</dd>
<dt><code>timing</code>:</dt><dd><p>The elapsed time (user+system) for various parts of
the program as a list, including the total time.</p>
</dd>
<dt><code>Options</code>:</dt><dd><p>Named list of options that were provided by
the user, or filled-in automatically.</p>
</dd>
<dt><code>ParTable</code>:</dt><dd><p>Named list describing the model parameters. Can be coerced to a data.frame. In the documentation, this is called the &lsquo;parameter table&rsquo;.</p>
</dd>
<dt><code>pta</code>:</dt><dd><p>Named list containing parameter table attributes.</p>
</dd>
<dt><code>Data</code>:</dt><dd><p>Object of internal class <code>"Data"</code>: information
about the data.</p>
</dd>
<dt><code>SampleStats</code>:</dt><dd><p>Object of internal class <code>"SampleStats"</code>: sample
statistics</p>
</dd>
<dt><code>Model</code>:</dt><dd><p>Object of internal class <code>"Model"</code>: the
internal (matrix) representation of the model</p>
</dd>
<dt><code>Cache</code>:</dt><dd><p>List using objects that we try to compute only once, and reuse many times.</p>
</dd>
<dt><code>Fit</code>:</dt><dd><p>Object of internal class <code>"Fit"</code>: the
results of fitting the model. No longer used.</p>
</dd>
<dt><code>boot</code>:</dt><dd><p>List. Results and information about the bootstrap.</p>
</dd>
<dt><code>optim</code>:</dt><dd><p>List. Information about the optimization.</p>
</dd>
<dt><code>loglik</code>:</dt><dd><p>List. Information about the loglikelihood of the model (if maximum likelihood was used).</p>
</dd>
<dt><code>implied</code>:</dt><dd><p>List. Model implied statistics.</p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>List. Information about the variance matrix (vcov) of the model parameters.</p>
</dd>
<dt><code>test</code>:</dt><dd><p>List. Different test statistics.</p>
</dd>
<dt><code>h1</code>:</dt><dd><p>List. Information about the unrestricted h1 model (if available).</p>
</dd>
<dt><code>baseline</code>:</dt><dd><p>List. Information about a baseline model (often
the independence model) (if available).</p>
</dd>
<dt><code>internal</code>:</dt><dd><p>List. For internal use only.</p>
</dd>
<dt><code>external</code>:</dt><dd><p>List. Empty slot to be used by add-on packages.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p><code>signature(object = "lavaan", type = "free")</code>: Returns
the estimates of the parameters in the model as a named numeric vector.
If <code>type="free"</code>, only the free parameters are returned.
If <code>type="user"</code>, all parameters listed in the parameter table
are returned, including constrained and fixed parameters.</p>
</dd>
<dt>fitted.values</dt><dd><p><code>signature(object = "lavaan")</code>: Returns the
implied moments of the model as a list with two elements (per group):
<code>cov</code> for the implied covariance matrix,
and <code>mean</code> for the implied mean
vector. If only the covariance matrix was analyzed, the implied mean
vector will be zero.</p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "lavaan")</code>: an alias for
<code>fitted.values</code>.</p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "lavaan", type="raw")</code>: 
If <code>type = "raw"</code>, this function returns the raw (= unscaled)
difference between the observed and the expected (model-implied) summary
statistics.
If <code>type = "cor"</code>, or <code>type = "cor.bollen"</code>, the observed and
model implied covariance matrices are first transformed to a correlation 
matrix (using <code>cov2cor()</code>), before the residuals are computed.  
If <code>type = "cor.bentler"</code>, both the observed and model implied
covariance matrices are rescaled by dividing the elements by the square 
roots of the corresponding variances of the observed covariance matrix.  
If <code>type="normalized"</code>, the residuals are divided by the square 
root of the asymptotic variance of the corresponding summary statistic 
(the variance estimate depends on the choice for the <code>se</code> argument).
Unfortunately, the corresponding normalized residuals are not entirely
correct, and this option is only available for historical interest.
If <code>type="standardized"</code>, the residuals are divided by the square 
root of the asymptotic variance of these residuals. The resulting 
standardized residuals elements can be interpreted as z-scores.  
If <code>type="standardized.mplus"</code>, the residuals are divided by the 
square root of the asymptotic variance of these residuals. However, a 
simplified formula is used (see the Mplus reference below) which often 
results in negative estimates for the variances, resulting in many 
<code>NA</code> values for the standardized residuals.</p>
</dd>
<dt>resid</dt><dd><p><code>signature(object = "lavaan")</code>: an alias
for <code>residuals</code></p>
</dd>
<dt>vcov</dt><dd><p><code>signature(object = "lavaan")</code>: returns the
covariance matrix of the estimated parameters.</p>
</dd>
<dt>predict</dt><dd><p><code>signature(object = "lavaan")</code>: compute
factor scores for all cases that are provided in the data frame. For
complete data only.</p>
</dd>
<dt>anova</dt><dd><p><code>signature(object = "lavaan")</code>: returns
model comparison statistics. This method is just a wrapper around
the function <code><a href="#topic+lavTestLRT">lavTestLRT</a></code>.
If only a single argument (a fitted
model) is provided, this model is compared to the unrestricted
model. If two or more arguments (fitted models) are provided, the models
are compared in a sequential order. Test statistics are based on the
likelihood ratio test. For more details and
further options, see the <code><a href="#topic+lavTestLRT">lavTestLRT</a></code> page.</p>
</dd>
<dt>update</dt><dd><p><code>signature(object = "lavaan", model, add, ...,
        evaluate=TRUE)</code>: update a fitted lavaan object and evaluate it
(unless <code>evaluate=FALSE</code>). Note that we use the environment
that is stored within the lavaan object, which is not necessarily
the parent frame. The <code>add</code> argument is analogous to the one
described in the <code><a href="#topic+lavTestScore">lavTestScore</a></code> page, and can be used to
add parameters to the specified model rather than passing an entirely
new <code>model</code> argument.</p>
</dd>
<dt>nobs</dt><dd><p><code>signature(object = "lavaan")</code>: returns the effective
number of observations used when fitting the model. In a multiple group
analysis, this is the sum of all observations per group.</p>
</dd>
<dt>logLik</dt><dd><p><code>signature(object = "lavaan")</code>:
returns the log-likelihood of the fitted model, if maximum likelihood estimation
was used. The <code><a href="stats.html#topic+AIC">AIC</a></code> and <code><a href="stats.html#topic+BIC">BIC</a></code>
methods automatically work via <code>logLik()</code>.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "lavaan")</code>: Print a short summary
of the model fit</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "lavaan", header = TRUE,
     fit.measures = FALSE, estimates = TRUE, ci = FALSE, fmi = FALSE,
     standardized = FALSE, std.nox = FALSE,
     remove.step1 = TRUE, remove.unused = TRUE, cov.std = TRUE, rsquare = FALSE,
     modindices = FALSE, ci = FALSE, nd = 3L)</code>:
Print a nice summary of the model estimates.
If <code>header = TRUE</code>, the header section (including fit measures) is
printed.
If <code>fit.measures = TRUE</code>, additional fit measures are added to the
header section. The related <code>fm.args</code> list allows to set options
related to the fit measures. See <code><a href="#topic+fitMeasures">fitMeasures</a></code> 
for more details.
If <code>estimates = TRUE</code>, print the parameter estimates section.
If <code>ci = TRUE</code>, add confidence intervals to the parameter estimates
section.
If <code>fmi = TRUE</code>, add the fmi (fraction of missing information)
column, if it is available.
If <code>standardized=TRUE</code> or a character vector, the standardized 
solution is also printed (see <code><a href="#topic+parameterEstimates">parameterEstimates</a></code>).  
Note that <em>SE</em>s and
tests are still based on unstandardized estimates. Use
<code><a href="#topic+standardizedSolution">standardizedSolution</a></code> to obtain <em>SE</em>s and test
statistics for standardized estimates.
The <code>std.nox</code> argument is deprecated; the <code>standardized</code>
argument allows <code>"std.nox"</code> solution to be specifically requested.
If <code>remove.step1</code>, the parameters of the measurement part are not
shown (only used when using <code>sam()</code>.)
If <code>remove.unused</code>, automatically added parameters that are
fixed to their default (0 or 1) values are removed.
If <code>rsquare=TRUE</code>, the R-Square values for the dependent variables
in the model are printed.
If <code>efa = TRUE</code>, EFA related information is printed. The related
<code>efa.args</code> list allows to set options related to the EFA output.
See <code><a href="#topic+summary.efaList">summary.efaList</a></code> for more details.
If <code>modindices=TRUE</code>, modification indices
are printed for all fixed parameters.
The argument <code>nd</code> determines the number of digits after the
decimal point to be printed (currently only in the parameter estimates
section.) Historically, nothing was returned, but since 0.6-12, a
list is returned of class <code>lavaan.summary</code> for which is print
function is available.</p>
</dd>
</dl>



<h3>References</h3>

<p>Yves Rosseel (2012). lavaan: An R Package for Structural Equation
Modeling. Journal of Statistical Software, 48(2), 1-36. 
<a href="https://doi.org/10.18637/jss.v048.i02">doi:10.18637/jss.v048.i02</a>
</p>
<p>Standardized Residuals in Mplus. Document retrieved from URL
https://www.statmodel.com/download/StandardizedResiduals.pdf
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cfa">cfa</a></code>, <code><a href="#topic+sem">sem</a></code>,
<code><a href="#topic+fitMeasures">fitMeasures</a></code>, <code><a href="#topic+standardizedSolution">standardizedSolution</a></code>,
<code><a href="#topic+parameterEstimates">parameterEstimates</a></code>, <code><a href="#topic+lavInspect">lavInspect</a></code>,
<code><a href="#topic+modindices">modindices</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- cfa(HS.model, data = HolzingerSwineford1939)

summary(fit, standardized = TRUE, fit.measures = TRUE, rsquare = TRUE)
fitted(fit)
coef(fit)
resid(fit, type = "normalized")
</code></pre>

<hr>
<h2 id='lavaanList'>Fit List of Latent Variable Models</h2><span id='topic+lavaanList'></span><span id='topic+semList'></span><span id='topic+cfaList'></span>

<h3>Description</h3>

<p>Fit the same latent variable model, for a (potentially large) number of datasets.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavaanList(model = NULL, dataList = NULL, dataFunction = NULL, 
    dataFunction.args = list(), ndat = length(dataList), cmd = "lavaan", 
    ..., store.slots = c("partable"), FUN = NULL, show.progress = FALSE,
    store.failed = FALSE, parallel = c("no", "multicore", "snow"), 
    ncpus = max(1L, parallel::detectCores() - 1L), cl = NULL, iseed = NULL)

semList(model = NULL, dataList = NULL, dataFunction = NULL,
    dataFunction.args = list(), ndat = length(dataList),
    ..., store.slots = c("partable"), FUN = NULL, show.progress = FALSE,
    store.failed = FALSE, parallel = c("no", "multicore", "snow"), 
    ncpus = max(1L, parallel::detectCores() - 1L), cl = NULL, iseed = NULL)

cfaList(model = NULL, dataList = NULL, dataFunction = NULL,
    dataFunction.args = list(), ndat = length(dataList),
    ..., store.slots = c("partable"), FUN = NULL, show.progress = FALSE,
    store.failed = FALSE, parallel = c("no", "multicore", "snow"), 
    ncpus = max(1L, parallel::detectCores() - 1L), cl = NULL, iseed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lavaanList_+3A_model">model</code></td>
<td>
<p>A description of the user-specified model. Typically, the model
is described using the lavaan model syntax. See            
<code><a href="#topic+model.syntax">model.syntax</a></code> for more information. Alternatively, a
parameter table (eg. the output of the <code>lavaanify()</code> function) is also
accepted.</p>
</td></tr>
<tr><td><code id="lavaanList_+3A_datalist">dataList</code></td>
<td>
<p>List. Each element contains a full data frame containing
the observed variables used in the model.</p>
</td></tr>
<tr><td><code id="lavaanList_+3A_datafunction">dataFunction</code></td>
<td>
<p>Function. A function that generated a full data frame
containing the observed variables used in the model. It can also be
a matrix, if the columns are named.</p>
</td></tr>
<tr><td><code id="lavaanList_+3A_datafunction.args">dataFunction.args</code></td>
<td>
<p>List. Optional list of arguments that are passed
to the <code>dataFunction</code> function.</p>
</td></tr>
<tr><td><code id="lavaanList_+3A_ndat">ndat</code></td>
<td>
<p>Integer. The number of datasets that should be generated using
the <code>dataFunction</code> function.</p>
</td></tr>
<tr><td><code id="lavaanList_+3A_cmd">cmd</code></td>
<td>
<p>Character. Which command is used to run the sem models. The possible
choices are <code>"sem"</code>, <code>"cfa"</code> or <code>"lavaan"</code>, determining how
we deal with default options.</p>
</td></tr>
<tr><td><code id="lavaanList_+3A_...">...</code></td>
<td>
<p>Other named arguments for <code>lavaan</code> function.</p>
</td></tr>
<tr><td><code id="lavaanList_+3A_store.slots">store.slots</code></td>
<td>
<p>Character vector. Which slots (from a lavaan object) 
should be stored for each dataset? The possible choices are
<code>"timing"</code>, <code>"partable"</code>, <code>"data"</code>, <code>"samplestats"</code>,
<code>"vcov"</code>, <code>"test"</code>, <code>"optim"</code>, <code>"h1"</code>, <code>"loglik"</code>,
or <code>"implied"</code>. Finally, <code>"all"</code> selects all slots.</p>
</td></tr>
<tr><td><code id="lavaanList_+3A_fun">FUN</code></td>
<td>
<p>Function. A function which when applied to the
<code><a href="#topic+lavaan-class">lavaan</a></code> object returns the information of interest.</p>
</td></tr>
<tr><td><code id="lavaanList_+3A_store.failed">store.failed</code></td>
<td>
<p>Logical. If <code>TRUE</code>, write (to tempdir()) the dataset
and (if available) the fitted object when the estimation for a particular
dataset somehow failed. This will allow posthoc inspection of the problem.</p>
</td></tr>
<tr><td><code id="lavaanList_+3A_parallel">parallel</code></td>
<td>
<p>The type of parallel operation to be used (if any). If
missing, the default is <code>"no"</code>.</p>
</td></tr>
<tr><td><code id="lavaanList_+3A_ncpus">ncpus</code></td>
<td>
<p>Integer. The number of processes to be used in parallel operation:
typically one would chose this to the number of available CPUs.</p>
</td></tr>
<tr><td><code id="lavaanList_+3A_cl">cl</code></td>
<td>
<p>An optional <span class="pkg">parallel</span> or <span class="pkg">snow</span> cluster for use if
<code>parallel = "snow"</code>.  If not supplied, a cluster on the local machine is
created for the duration of the <code>lavaanList</code> call.</p>
</td></tr>
<tr><td><code id="lavaanList_+3A_iseed">iseed</code></td>
<td>
<p>An integer to set the seed. Or NULL if no reproducible seeds are
needed. To make this work, make sure the first
RNGkind() element is <code>"L'Ecuyer-CMRG"</code>. You can check this by
typing <code>RNGkind()</code> in the console. You can set it by typing
<code>RNGkind("L'Ecuyer-CMRG")</code>, before the lavaanList functions are called.</p>
</td></tr>
<tr><td><code id="lavaanList_+3A_show.progress">show.progress</code></td>
<td>
<p>If <code>TRUE</code>, show information for each dataset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+lavaanList-class">lavaanList</a></code>, for which several methods
are available, including a <code>summary</code> method.
</p>


<h3>See Also</h3>

<p>class <code><a href="#topic+lavaanList-class">lavaanList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The Holzinger and Swineford (1939) example
HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

# a data generating function
generateData &lt;- function() simulateData(HS.model, sample.nobs = 100)

set.seed(1234)
fit &lt;- semList(HS.model, dataFunction = generateData, ndat = 5,
               store.slots = "partable")

# show parameter estimates, per dataset
coef(fit)
</code></pre>

<hr>
<h2 id='lavaanList-class'>Class For Representing A List of (Fitted) Latent Variable Models</h2><span id='topic+lavaanList-class'></span><span id='topic+coef+2ClavaanList-method'></span><span id='topic+summary+2ClavaanList-method'></span>

<h3>Description</h3>

<p>The <code>lavaanList</code> class represents a collection of (fitted)
latent variable models, for a (potentially large) number of datasets. 
It contains information about the model (which is always the same),
and for every dataset a set of (user-specified) slots from a regular
lavaan object.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created via the
<code><a href="#topic+cfaList">cfaList</a></code>, <code><a href="#topic+semList">semList</a></code>, or
<code><a href="#topic+lavaanList">lavaanList</a></code> functions.
</p>


<h3>Slots</h3>


<dl>
<dt><code>version</code>:</dt><dd><p>The lavaan package version used to create this objects</p>
</dd>
<dt><code>call</code>:</dt><dd><p>The function call as returned by <code>match.call()</code>.</p>
</dd>
<dt><code>Options</code>:</dt><dd><p>Named list of options that were provided by
the user, or filled-in automatically.</p>
</dd>
<dt><code>ParTable</code>:</dt><dd><p>Named list describing the model parameters. Can be coerced to a data.frame. In the documentation, this is called the &lsquo;parameter table&rsquo;.</p>
</dd>
<dt><code>pta</code>:</dt><dd><p>Named list containing parameter table attributes.</p>
</dd>
<dt><code>Data</code>:</dt><dd><p>Object of internal class <code>"Data"</code>: information
about the data.</p>
</dd>
<dt><code>Model</code>:</dt><dd><p>Object of internal class <code>"Model"</code>: the 
internal (matrix) representation of the model</p>
</dd>
<dt><code>meta</code>:</dt><dd><p>List containing additional flags. For internal use only.</p>
</dd>
<dt><code>timingList</code>:</dt><dd><p>List. Timing slot per dataset.</p>
</dd>
<dt><code>ParTableList</code>:</dt><dd><p>List. ParTable slot per dataset.</p>
</dd>
<dt><code>DataList</code>:</dt><dd><p>List. Data slot per dataset.</p>
</dd>
<dt><code>SampleStatsList</code>:</dt><dd><p>List. SampleStats slot per dataset.</p>
</dd>
<dt><code>CacheList</code>:</dt><dd><p>List. Cache slot per dataset.</p>
</dd>
<dt><code>vcovList</code>:</dt><dd><p>List. vcov slot per dataset.</p>
</dd>
<dt><code>testList</code>:</dt><dd><p>List. test slot per dataset.</p>
</dd>
<dt><code>optimList</code>:</dt><dd><p>List. optim slot per dataset.</p>
</dd>
<dt><code>impliedList</code>:</dt><dd><p>List. implied slot per dataset.</p>
</dd>
<dt><code>h1List</code>:</dt><dd><p>List. h1 slot per dataset.</p>
</dd>
<dt><code>loglikList</code>:</dt><dd><p>List. loglik slot per dataset.</p>
</dd>
<dt><code>baselineList</code>:</dt><dd><p>List. baseline slot per dataset.</p>
</dd>
<dt><code>funList</code>:</dt><dd><p>List. fun slot per dataset.</p>
</dd>
<dt><code>internalList</code>:</dt><dd><p>List. internal slot per dataset.</p>
</dd>
<dt><code>external</code>:</dt><dd><p>List. Empty slot to be used by add-on packages.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p><code>signature(object = "lavaanList", type = "free")</code>: Returns 
the estimates of the parameters in the model as the columns in a matrix;
each column corresponds to a different dataset.
If <code>type="free"</code>, only the free parameters are returned.
If <code>type="user"</code>, all parameters listed in the parameter table
are returned, including constrained and fixed parameters.</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "lavaanList", header = TRUE, estimates = TRUE, nd = 3L)</code>: 
Print a summary of the collection of fitted models.
If <code>header = TRUE</code>, the header section is
printed.  
If <code>estimates = TRUE</code>, print the parameter estimates section.
The argument <code>nd</code> determines the number of digits after the
decimal point to be printed (currently only in the parameter estimates
section.)
Nothing is returned (use 
<code>parameterEstimates</code> or another extractor function 
to extract information from this object).</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+cfaList">cfaList</a></code>, <code><a href="#topic+semList">semList</a></code>, <code><a href="#topic+lavaanList">lavaanList</a></code>
</p>

<hr>
<h2 id='lavCor'>Polychoric, polyserial and Pearson correlations</h2><span id='topic+lavCor'></span>

<h3>Description</h3>

<p>Fit an unrestricted model to compute polychoric, polyserial and/or Pearson
correlations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavCor(object, ordered = NULL, group = NULL, missing = "listwise", 
       ov.names.x = NULL, sampling.weights = NULL,
       se = "none", test = "none", 
       estimator = "two.step", baseline = FALSE, ..., 
       cor.smooth = FALSE, cor.smooth.tol = 1e-04, output = "cor")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lavCor_+3A_object">object</code></td>
<td>
<p>Either a <code>data.frame</code>, or an object of class
<code><a href="#topic+lavaan-class">lavaan</a></code>. If the input is a <code>data.frame</code>, and
some variables are declared as ordered factors, lavaan will
treat them as ordinal variables.</p>
</td></tr>
<tr><td><code id="lavCor_+3A_ordered">ordered</code></td>
<td>
<p>Character vector. Only used if <code>object</code> is a 
<code>data.frame</code>. Treat these variables as ordered (ordinal) variables. 
Importantly, all other variables will be treated as numeric (unless they 
are declared as ordered in the original data frame.)</p>
</td></tr>
<tr><td><code id="lavCor_+3A_group">group</code></td>
<td>
<p>Only used if <code>object</code> is a <code>data.frame</code>. Specify
a grouping variable.</p>
</td></tr>
<tr><td><code id="lavCor_+3A_missing">missing</code></td>
<td>
<p>If <code>"listwise"</code>, cases with missing values are removed
listwise from the data frame. If <code>"direct"</code> or
<code>"ml"</code> or <code>"fiml"</code> and the estimator is maximum likelihood,
an EM algorithm is used to estimate the unrestricted covariance matrix
(and mean vector). If <code>"pairwise"</code>, pairwise deletion is used. If
<code>"default"</code>, the value is set depending on the estimator and the
mimic option.</p>
</td></tr>
<tr><td><code id="lavCor_+3A_sampling.weights">sampling.weights</code></td>
<td>
<p>Only used if <code>object</code> is a <code>data.frame</code>. 
Specify a variable containing sampling weights.</p>
</td></tr>
<tr><td><code id="lavCor_+3A_ov.names.x">ov.names.x</code></td>
<td>
<p>Only used if <code>object</code> is a <code>data.frame</code>. Specify
variables that need to be treated as exogenous. Only used if at least
one variable is declared as ordered.</p>
</td></tr>
<tr><td><code id="lavCor_+3A_se">se</code></td>
<td>
<p>Only used if <code>output</code> (see below) contains standard errors.
See <code><a href="#topic+lavOptions">lavOptions</a></code> for possible options.</p>
</td></tr>
<tr><td><code id="lavCor_+3A_test">test</code></td>
<td>
<p>Only used if output is <code>"fit"</code> or <code>"lavaan"</code>. See
<code><a href="#topic+lavOptions">lavOptions</a></code> for possible options.</p>
</td></tr>
<tr><td><code id="lavCor_+3A_estimator">estimator</code></td>
<td>
<p>If <code>"none"</code> or <code>"two.step"</code> or <code>"two.stage"</code>,
only starting values are computed for the correlations (and thresholds),
without any further estimation. If all variables are continuous, the 
starting values are the sample covariances (converted to correlations
if <code>output = "cor"</code>). If at least one variable is ordered, 
the thresholds are computed using univariate information only. The
polychoric and/or polyserial correlations are computed in a second
stage, keeping the values of the thresholds constant. If an estimator
(other than <code>"two.step"</code> or <code>"two.stage"</code>) is specified
(for example <code>estimator = "PML"</code>), these starting values are
further updated by fitting the unrestricted model using the chosen
estimator. See the <code><a href="#topic+lavaan">lavaan</a></code> function for alternative 
estimators.</p>
</td></tr>
<tr><td><code id="lavCor_+3A_baseline">baseline</code></td>
<td>
<p>Only used if output is <code>"fit"</code> or <code>"lavaan"</code>. If
<code>TRUE</code>, a baseline model is also estimated. Note that the <code>test</code>
argument should also be set to a value other than <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="lavCor_+3A_...">...</code></td>
<td>
<p>Optional parameters that are passed to the <code><a href="#topic+lavaan">lavaan</a></code> 
function.</p>
</td></tr>
<tr><td><code id="lavCor_+3A_cor.smooth">cor.smooth</code></td>
<td>
<p>Logical. Only used if <code>output = "cor"</code>. 
If <code>TRUE</code>, ensure the resulting correlation matrix is positive
definite. The following simple method is used: an eigenvalue decomposition
is computed; then, eigenvalues smaller than <code>cor.smooth.tol</code>
are set to be equal to <code>cor.smooth.tol</code>, before the  matrix 
is again reconstructed. Finally, the matrix (which may no longer have unit
diagonal elements) is converted to a correlation matrix using 
<code>cov2cor</code>.</p>
</td></tr>
<tr><td><code id="lavCor_+3A_cor.smooth.tol">cor.smooth.tol</code></td>
<td>
<p>Numeric. Smallest eigenvalue used when reconstructing
the correlation matrix after an eigenvalue decomposition.</p>
</td></tr>
<tr><td><code id="lavCor_+3A_output">output</code></td>
<td>
<p>If <code>"cor"</code>, the function returns the correlation matrix only.   If <code>"cov"</code>, the function returns the covariance matrix (this only makes
a difference if at least one variable is numeric). If <code>"th"</code> or
<code>"thresholds"</code>, only the thresholds are returned. If <code>"sampstat"</code>,
the output equals the result of <code>lavInspect(fit, "sampstat")</code> where
fit is the unrestricted model. If <code>"est"</code> or <code>"pe"</code> or 
<code>"parameterEstimates"</code>, the output equals the result of
<code>parameterEstimates(fit)</code>. Finally, if output is <code>"fit"</code> or
<code>"lavaan"</code>, the function returns an object of class 
<code><a href="#topic+lavaan-class">lavaan</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper around the <code><a href="#topic+lavaan">lavaan</a></code> function,
but where the model is defined as the unrestricted model. The
following free parameters are included: all covariances/correlations among
the variables, variances for continuous variables, means for continuous
variables, thresholds for ordered variables, and if exogenous variables 
are included (<code>ov.names.x</code> is not empty) while some variables
are ordered, also the regression slopes enter the model.
</p>


<h3>Value</h3>

<p>By default, if <code>output = "cor"</code> or <code>output = "cov"</code>, a symmetric
matrix (of class <code>"lavaan.matrix.symmetric"</code>, which only affects the
way the matrix is printed). If <code>output = "th"</code>, a named vector of
thresholds. If <code>output = "fit"</code> or <code>output = "lavaan"</code>, 
an object of class  <code><a href="#topic+lavaan-class">lavaan</a></code>. 
</p>


<h3>References</h3>

<p>Olsson, U. (1979). Maximum likelihood estimation of the polychoric correlation 
coefficient. Psychometrika, 44(4), 443-460.
</p>
<p>Olsson, U., Drasgow, F., &amp; Dorans, N. J. (1982). The polyserial correlation coefficient. Psychometrika, 47(3), 337-347.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lavaan">lavaan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Holzinger and Swineford (1939) example
HS9 &lt;- HolzingerSwineford1939[,c("x1","x2","x3","x4","x5",
                                 "x6","x7","x8","x9")]

# Pearson correlations
lavCor(HS9)

# ordinal version, with three categories
HS9ord &lt;- as.data.frame( lapply(HS9, cut, 3, labels = FALSE) )

# polychoric correlations, two-stage estimation
lavCor(HS9ord, ordered=names(HS9ord))

# thresholds only
lavCor(HS9ord, ordered=names(HS9ord), output = "th")

# polychoric correlations, with standard errors
lavCor(HS9ord, ordered=names(HS9ord), se = "standard", output = "est")

# polychoric correlations, full output
fit.un &lt;- lavCor(HS9ord, ordered=names(HS9ord), se = "standard", 
                 output = "fit")
summary(fit.un)
</code></pre>

<hr>
<h2 id='lavExport'>lavaan Export</h2><span id='topic+lavExport'></span>

<h3>Description</h3>

<p>Export a fitted lavaan object to an external program.</p>


<h3>Usage</h3>

<pre><code class='language-R'>
lavExport(object, target = "lavaan", prefix = "sem", dir.name = "lavExport", 
          export = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lavExport_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+lavaan-class">lavaan</a></code>.</p>
</td></tr>
<tr><td><code id="lavExport_+3A_target">target</code></td>
<td>
<p>The target program. Current options are <code>"lavaan"</code> and
<code>"Mplus"</code>.</p>
</td></tr>
<tr><td><code id="lavExport_+3A_prefix">prefix</code></td>
<td>
<p>The prefix used to create the input files; the name of the
input file has the pattern &lsquo;prefix dot target dot in&rsquo;; the name of the
data file has the pattern &lsquo;prefix dot target dot raw&rsquo;.</p>
</td></tr>
<tr><td><code id="lavExport_+3A_dir.name">dir.name</code></td>
<td>
<p>The directory name (including a full path) where the 
input files will be written.</p>
</td></tr>
<tr><td><code id="lavExport_+3A_export">export</code></td>
<td>
<p>If <code>TRUE</code>, the files are written to the output directory
(<code>dir.name</code>). If <code>FALSE</code>, only the syntax is generated as a
character string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was mainly created to quickly generate an Mplus syntax file to
compare the results between Mplus and lavaan. The target <code>"lavaan"</code> can
be useful to create a full model syntax as needed for the <code>lavaan()</code>
function. More targets (perhaps for <code>LISREL</code> or <code>EQS</code>) will be added
in future releases.
</p>


<h3>Value</h3>

<p>If <code>export = TRUE</code>, a directory (called <code>lavExport</code> by default) will
be created, typically containing a data file, and an input file so that the
same analysis can be run using an external program. If <code>export = FALSE</code>, a
character string containing the model syntax only for the target program.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lavaanify">lavaanify</a></code>, <code><a href="#topic+mplus2lavaan">mplus2lavaan</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- cfa(HS.model, data=HolzingerSwineford1939)
out &lt;- lavExport(fit, target = "Mplus", export=FALSE)
cat(out)
</code></pre>

<hr>
<h2 id='lavInspect'>Inspect or extract information from a fitted lavaan object</h2><span id='topic+lavInspect'></span><span id='topic+inspect'></span><span id='topic+lavTech'></span>

<h3>Description</h3>

<p>The <code>lavInspect()</code> and <code>lavTech()</code> functions can be used to
inspect/extract information that is stored inside (or can be computed from) a
fitted lavaan object. Note: the (older) <code>inspect()</code> function is
now simply a shortcut for <code>lavInspect()</code> with default arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavInspect(object, what = "free", add.labels = TRUE, add.class = TRUE,
           list.by.group = TRUE,
           drop.list.single.group = TRUE)

lavTech(object, what = "free", add.labels = FALSE, add.class = FALSE,
        list.by.group = FALSE,
        drop.list.single.group = FALSE)

inspect(object, what = "free", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lavInspect_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+lavaan-class">lavaan</a></code>.</p>
</td></tr>
<tr><td><code id="lavInspect_+3A_what">what</code></td>
<td>
<p>Character. What needs to be inspected/extracted? See Details for a
full list. Note: the <code>what</code> argument is not case-sensitive
(everything is converted to lower case.)</p>
</td></tr>
<tr><td><code id="lavInspect_+3A_add.labels">add.labels</code></td>
<td>
<p>If <code>TRUE</code>, variable names are added to the vectors
and/or matrices.</p>
</td></tr>
<tr><td><code id="lavInspect_+3A_add.class">add.class</code></td>
<td>
<p>If <code>TRUE</code>, vectors are given the &lsquo;lavaan.vector&rsquo; class;
matrices are given the &lsquo;lavaan.matrix&rsquo; class, and symmetric matrices are
given the &lsquo;lavaan.matrix.symmetric&rsquo; class. This only affects the way they
are printed on the screen.</p>
</td></tr>
<tr><td><code id="lavInspect_+3A_list.by.group">list.by.group</code></td>
<td>
<p>Logical. Only used when the output are model matrices.
If <code>TRUE</code>, the model matrices are nested within groups. If <code>FALSE</code>,
a flattened list is returned containing all model matrices, with repeated
names for multiple groups.</p>
</td></tr>
<tr><td><code id="lavInspect_+3A_drop.list.single.group">drop.list.single.group</code></td>
<td>
<p>If <code>FALSE</code>, the results are returned as
a list, where each element corresponds to a group (even if there is only
a single group). If <code>TRUE</code>, the list will be unlisted if there is
only a single group.</p>
</td></tr>
<tr><td><code id="lavInspect_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used by lavaan, but by other packages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>lavInspect()</code> and <code>lavTech()</code> functions only differ in the way
they return the results. The <code>lavInspect()</code> function will prettify the
output by default, while the <code>lavTech()</code> will not attempt to prettify the
output by default. The (older) <code>inspect()</code> function is a simplified
version of <code>lavInspect()</code> with only the first two arguments.
</p>
<p>Below is a list of possible values for the <code>what</code> argument, organized
in several sections:
</p>
<p>Model matrices:
</p>

<dl>
<dt><code>"free"</code>:</dt><dd><p>A list of model matrices. The non-zero integers
represent the free parameters. The numbers themselves correspond
to the position of the free parameter in the parameter vector.
This determines the order of the model parameters in the output
of for example <code>coef()</code> and <code>vcov()</code>.</p>
</dd>
<dt><code>"partable"</code>:</dt><dd><p>A list of model matrices. The non-zero integers
represent both the fixed parameters (for example, factor loadings
fixed at 1.0), and the free parameters if we ignore any equality
constraints. They correspond with all entries (fixed or free)
in the parameter table. See <code><a href="#topic+parTable">parTable</a></code>.</p>
</dd>
<dt><code>"se"</code>:</dt><dd><p>A list of model matrices. The non-zero numbers
represent the standard errors for the free parameters in the model.
If two parameters are constrained to be equal, they will have the
same standard error for both parameters.
Aliases: <code>"std.err"</code> and <code>"standard.errors"</code>.</p>
</dd>
<dt><code>"start"</code>:</dt><dd><p>A list of model matrices. The values represent
the starting values for all model parameters.
Alias: <code>"starting.values"</code>.</p>
</dd>
<dt><code>"est"</code>:</dt><dd><p>A list of model matrices. The values represent
the estimated model parameters. Aliases:
<code>"estimates"</code>, and <code>"x"</code>.</p>
</dd>
<dt><code>"dx.free"</code>:</dt><dd><p>A list of model matrices. The values represent
the gradient (first derivative) values of the model parameters.
If two parameters are constrained to be equal, they will have the
same gradient value.</p>
</dd>
<dt><code>"dx.all"</code>:</dt><dd><p>A list of model matrices. The values represent
the first derivative with respect to all possible matrix elements.
Currently, this is only available when the estimator is <code>"ML"</code>
or <code>"GLS"</code>.</p>
</dd>
<dt><code>"std"</code>:</dt><dd><p>A list of model matrices. The values represent
the (completely) standardized model parameters (the variances of
both the observed and the latent variables are set to unity).
Aliases: <code>"std.all"</code>, <code>"standardized"</code>.</p>
</dd>
<dt><code>"std.lv"</code>:</dt><dd><p>A list of model matrices. The values represent
the standardized model parameters (only the variances of the
latent variables are set to unity.)</p>
</dd>
<dt><code>"std.nox"</code>:</dt><dd><p>A list of model matrices. The values represent
the (completely) standardized model parameters (the variances of
both the observed and the latent variables are set to unity;
however, the variances of any observed exogenous variables are not
set to unity; hence no-x.)</p>
</dd>
</dl>

<p>Information about the data:
</p>

<dl>
<dt><code>"data"</code>:</dt><dd><p>A matrix containing the observed variables
that have been used to fit the model. No column/row names are provided.
Column names correspond to the output of <code>lavNames(object)</code>,
while the rows correspond to the output of
<code>lavInspect(object, "case.idx"</code>.</p>
</dd>
<dt><code>"ordered"</code>:</dt><dd><p>A character vector. The ordered variables.</p>
</dd>
<dt><code>"nobs"</code>:</dt><dd><p>Integer vector. The number of observations
in each group that were used in the analysis.</p>
</dd>
<dt><code>"norig"</code>:</dt><dd><p>Integer vector. The original number of observations
in each group.</p>
</dd>
<dt><code>"ntotal"</code>:</dt><dd><p>Integer. The total number of observations that
were used in the analysis. If there is just a single group, this
is the same as the <code>"nobs"</code> option; if there are multiple groups,
this is the sum of the <code>"nobs"</code> numbers for each group.</p>
</dd>
<dt><code>"case.idx"</code>:</dt><dd><p>Integer vector. The case/observation numbers 
that were used in the analysis.
In the case of multiple groups: a list of numbers.</p>
</dd>
<dt><code>"empty.idx"</code>:</dt><dd><p>The case/observation numbers of those
cases/observations that contained missing values only
(at least for the observed variables that were included in the model).
In the case of multiple groups: a list of numbers.</p>
</dd>
<dt><code>"patterns"</code>:</dt><dd><p>A binary matrix. The rows of the matrix
are the missing data patterns where 1 and 0 denote non-missing
and missing values for the corresponding observed variables
respectively (or
<code>TRUE</code> and <code>FALSE</code> if <code>lavTech()</code> is used.)
If the data is complete (no missing values), there will be only
a single pattern. In the case of multiple groups: a list of
pattern matrices.</p>
</dd>
<dt><code>"coverage"</code>:</dt><dd><p>A symmetric matrix where each element contains
the proportion of observed datapoints for the corresponding
pair of observed variables.
In the case of multiple groups: a list of coverage matrices.</p>
</dd>
<dt><code>"group"</code>:</dt><dd><p>A character string. The group variable in
the data.frame (if any).</p>
</dd>
<dt><code>"ngroups"</code>:</dt><dd><p>Integer. The number of groups.</p>
</dd>
<dt><code>"group.label"</code>:</dt><dd><p>A character vector. The group labels.</p>
</dd>
<dt><code>"level.label"</code>:</dt><dd><p>A character vector. The level labels.</p>
</dd>
<dt><code>"cluster"</code>:</dt><dd><p>A character vector. The cluster variable(s)
in the data.frame (if any).</p>
</dd>
<dt><code>"nlevels"</code>:</dt><dd><p>Integer. The number of levels.</p>
</dd>
<dt><code>"nclusters"</code>:</dt><dd><p>Integer. The number of clusters
that were used in the analysis.</p>
</dd>
<dt><code>"ncluster.size"</code>:</dt><dd><p>Integer. The number of different cluster
sizes.</p>
</dd>
<dt><code>"cluster.size"</code>:</dt><dd><p>Integer vector. The number of observations
within each cluster. For multigroup multilevel models, a list of
integer vectors, indicating cluster sizes within each group.</p>
</dd>
<dt><code>"cluster.id"</code>:</dt><dd><p>Integer vector. The cluster IDs identifying
the clusters. For multigroup multilevel models, a list of
integer vectors, indicating cluster IDs within each group.</p>
</dd>
<dt><code>"cluster.idx"</code>:</dt><dd><p>Integer vector. The cluster index for
each observation. The cluster index ranges from 1 to the
number of clusters. For multigroup multilevel models, a list of
integer vectors, indicating cluster indices within each group.</p>
</dd>
<dt><code>"cluster.label"</code>:</dt><dd><p>Integer vector. The cluster ID for
each observation. For multigroup multilevel models, a list of
integer vectors, indicating the cluster ID for each observation 
within each group.</p>
</dd>
<dt><code>"cluster.sizes"</code>:</dt><dd><p>Integer vector. The different cluster
sizes that were used in the analysis. For multigroup multilevel 
models, a list of integer vectors, indicating the different cluster 
sizes within each group.</p>
</dd>
<dt><code>"average.cluster.size"</code>:</dt><dd><p>Integer. The average cluster
size (using the formula 
<code>s = (N^2 - sum(cluster.size^2)) / (N*(nclusters - 1L))</code>). 
For multigroup multilevel
models, a list containing the average cluster size per group.</p>
</dd>
</dl>

<p>Observed sample statistics:
</p>

<dl>
<dt><code>"sampstat"</code>:</dt><dd><p>Observed sample statistics. Aliases:
<code>"obs"</code>, <code>"observed"</code>, <code>"samp"</code>, <code>"sample"</code>,
<code>"samplestatistics"</code>. Since
0.6-3, we always check if an h1 slot is available (the estimates
for the unrestricted model); if present, we extract the sample
statistics from this slot. This implies that if variables are
continuous, and <code>missing = "ml"</code> (or <code>"fiml"</code>), we
return the covariance matrix (and mean vector) as computed by
the EM algorithm under the unrestricted (h1) model. If the h1 is
not present (perhaps, because the model was fitted with
<code>h1 = FALSE</code>), we return the sample statistics from the
SampleStats slot. Here, pairwise deletion is used for the elements
of the covariance matrix (or correlation matrix), and
listwise deletion for all univariate statistics (means, intercepts
and thresholds).</p>
</dd>
<dt><code>"sampstat.h1"</code>:</dt><dd><p>Deprecated. Do not use any longer.</p>
</dd>
<dt><code>"wls.obs"</code>:</dt><dd><p>The observed sample statistics (covariance
elements, intercepts/thresholds, etc.) in a single vector.</p>
</dd>
<dt><code>"wls.v"</code>:</dt><dd><p>The weight vector as used in weighted least
squares estimation.</p>
</dd>
<dt><code>"gamma"</code>:</dt><dd><p>N times the asymptotic variance matrix of the
sample statistics. Alias: <code>"sampstat.nacov"</code>.</p>
</dd>
</dl>

<p>Model features:
</p>

<dl>
<dt><code>"meanstructure"</code>:</dt><dd><p>Logical. <code>TRUE</code> if a meanstructure
was included in the model.</p>
</dd>
<dt><code>"categorical"</code>:</dt><dd><p>Logical. <code>TRUE</code> if categorical endogenous
variables were part of the model.</p>
</dd>
<dt><code>"fixed.x"</code>:</dt><dd><p>Logical. <code>TRUE</code> if the exogenous x-covariates
are treated as fixed.</p>
</dd>
<dt><code>"parameterization"</code>:</dt><dd><p>Character. Either <code>"delta"</code> or
<code>"theta"</code>.</p>
</dd>
</dl>

<p>Model-implied sample statistics:
</p>

<dl>
<dt><code>"implied"</code>:</dt><dd><p>The model-implied summary statistics.
Alias: <code>"fitted"</code>, <code>"expected"</code>, <code>"exp"</code>.</p>
</dd>
<dt><code>"resid"</code>:</dt><dd><p>The difference between observed and model-implied
summary statistics.
Alias: <code>"residuals"</code>, <code>"residual"</code>, <code>"res"</code>.</p>
</dd>
<dt><code>"cov.lv"</code>:</dt><dd><p>The model-implied variance-covariance matrix
of the latent variables. Alias: <code>"veta"</code> [for V(eta)].</p>
</dd>
<dt><code>"cor.lv"</code>:</dt><dd><p>The model-implied correlation matrix of the
latent variables.</p>
</dd>
<dt><code>"mean.lv"</code>:</dt><dd><p>The model-implied mean vector of the latent
variables. Alias: <code>"eeta"</code> [for E(eta)].</p>
</dd>
<dt><code>"cov.ov"</code>:</dt><dd><p>The model-implied variance-covariance matrix
of the observed variables.
Aliases: <code>"sigma"</code>, <code>"sigma.hat"</code>.</p>
</dd>
<dt><code>"cor.ov"</code>:</dt><dd><p>The model-implied correlation matrix
of the observed variables.</p>
</dd>
<dt><code>"mean.ov"</code>:</dt><dd><p>The model-implied mean vector of the observed
variables. Aliases: <code>"mu"</code>, <code>"mu.hat"</code>.</p>
</dd>
<dt><code>"cov.all"</code>:</dt><dd><p>The model-implied variance-covariance matrix
of both the observed and latent variables.</p>
</dd>
<dt><code>"cor.all"</code>:</dt><dd><p>The model-implied correlation matrix
of both the observed and latent variables.</p>
</dd>
<dt><code>"th"</code>:</dt><dd><p>The model-implied thresholds.
Alias: <code>"thresholds"</code>.</p>
</dd>
<dt><code>"wls.est"</code>:</dt><dd><p>The model-implied sample statistics (covariance
elements, intercepts/thresholds, etc.) in a single vector.</p>
</dd>
<dt><code>"vy"</code>:</dt><dd><p>The model-implied unconditional variances of the
observed variables.</p>
</dd>
<dt><code>"rsquare"</code>:</dt><dd><p>The R-square value for all endogenous variables.
Aliases: <code>"r-square"</code>, <code>"r2"</code>.</p>
</dd>
<dt><code>"fs.determinacy"</code>:</dt><dd><p>The factor determinacies (based on
regression factor scores). They represent the (estimated) correlation
between the factor scores and the latent variables scores.</p>
</dd>
<dt><code>"fs.reliability"</code>:</dt><dd><p>The factor reliabilities (based on
regression factor scores). They are the square of the factor 
determinacies.</p>
</dd>
<dt><code>"fs.determinacy.Bartlett"</code>:</dt><dd><p>The factor determinacies (based on
Bartlett factor scores). They represent the (estimated) correlation
between the factor scores and the latent variables scores.</p>
</dd>
<dt><code>"fs.reliability.Bartlett"</code>:</dt><dd><p>The factor reliabilities (based on
Bartlett factor scores). They are the square of the factor 
determinacies.</p>
</dd>
</dl>

<p>Diagnostics:
</p>

<dl>
<dt><code>"mdist2.fs"</code>:</dt><dd><p>The squared Mahalanobis distances for the (Bartlett) factor scores.</p>
</dd>
<dt><code>"mdist.fs"</code>:</dt><dd><p>The Mahalanobis distances for the (Bartlett) factor scores.</p>
</dd>
<dt><code>"mdist2.resid"</code>:</dt><dd><p>The squared Mahalanobis distances for the (Bartlett-based) casewise residuals.</p>
</dd>
<dt><code>"mdist.fs"</code>:</dt><dd><p>The Mahalanobis distances for the (Bartlett-based) casewise residuals.</p>
</dd>
</dl>

<p>Optimizer information:
</p>

<dl>
<dt><code>"converged"</code>:</dt><dd><p>Logical. <code>TRUE</code> if the optimizer has
converged; <code>FALSE</code> otherwise.</p>
</dd>
<dt><code>"iteratons"</code>:</dt><dd><p>Integer. The number of iterations used by the
optimizer.</p>
</dd>
<dt><code>"optim"</code>:</dt><dd><p>List. All available information regarding the
optimization results.</p>
</dd>
<dt><code>"npar"</code>:</dt><dd><p>Integer. Number of free parameters (ignoring constraints).</p>
</dd>
</dl>

<p>Gradient, Hessian, observed, expected and first.order information matrices:
</p>

<dl>
<dt><code>"gradient"</code>:</dt><dd><p>Numeric vector containing the first derivatives
of the discrepancy function with respect to the (free) model
parameters.</p>
</dd>
<dt><code>"hessian"</code>:</dt><dd><p>Matrix containing the second derivatives
of the discrepancy function with respect to the (free) model
parameters.</p>
</dd>
<dt><code>"information"</code>:</dt><dd><p>Matrix containing either the observed or
the expected information matrix (depending on the information option
of the fitted model). This is unit-information, not total-information.</p>
</dd>
<dt><code>"information.expected"</code>:</dt><dd><p>Matrix containing the expected
information matrix for the free model parameters.</p>
</dd>
<dt><code>"information.observed"</code>:</dt><dd><p>Matrix containing the observed
information matrix for the free model parameters.</p>
</dd>
<dt><code>"information.first.order"</code>:</dt><dd><p>Matrix containing the first.order
information matrix for the free model parameters. This is the
outer product of the gradient elements (the first derivative of
the discrepancy function with respect to the (free) model parameters).
Alias: <code>"first.order"</code>.</p>
</dd>
<dt><code>"augmented.information"</code>:</dt><dd><p>Matrix containing either the
observed or the expected augmented (or bordered) information
matrix (depending on the information option of the fitted model.
Only relevant if constraints have been used in the model.</p>
</dd>
<dt><code>"augmented.information.expected"</code>:</dt><dd><p>Matrix containing the
expected augmented (or bordered) information matrix.
Only relevant if constraints have been used in the model.</p>
</dd>
<dt><code>"augmented.information.observed"</code>:</dt><dd><p>Matrix containing the
observed augmented (or bordered) information matrix.
Only relevant if constraints have been used in the model.</p>
</dd>
<dt><code>"augmented.information.first.order"</code>:</dt><dd><p>Matrix containing
the first.order augmented (or bordered) information matrix.
Only relevant if constraints have been used in the model.</p>
</dd>
<dt><code>"inverted.information"</code>:</dt><dd><p>Matrix containing either the
observed or the expected inverted information matrix
(depending on the information option of the fitted model.</p>
</dd>
<dt><code>"inverted.information.expected"</code>:</dt><dd><p>Matrix containing the
inverted expected information matrix for the free model parameters.</p>
</dd>
<dt><code>"inverted.information.observed"</code>:</dt><dd><p>Matrix containing the
inverted observed information matrix for the free model parameters.</p>
</dd>
<dt><code>"inverted.information.first.order"</code>:</dt><dd><p>Matrix containing the
inverted first.order information matrix for the free model parameters.</p>
</dd>
<dt><code>"h1.information"</code>:</dt><dd><p>Matrix containing either the observed,
expected or first.order information matrix (depending on the 
information option of the fitted model) of the unrestricted h1
model. This is unit-information, not total-information.</p>
</dd>
<dt><code>"h1.information.expected"</code>:</dt><dd><p>Matrix containing the expected
information matrix for the unrestricted h1 model.</p>
</dd>
<dt><code>"h1.information.observed"</code>:</dt><dd><p>Matrix containing the observed
information matrix for the unrestricted h1 model.</p>
</dd>
<dt><code>"h1.information.first.order"</code>:</dt><dd><p>Matrix containing the 
first.order information matrix for the the unrestricted h1 model.
Alias: <code>"h1.first.order"</code>.</p>
</dd>
</dl>

<p>Variance covariance matrix of the model parameters:
</p>

<dl>
<dt><code>"vcov"</code>:</dt><dd><p>Matrix containing the variance covariance matrix
of the estimated model parameters.</p>
</dd>
<dt><code>"vcov.std.all"</code>:</dt><dd><p>Matrix containing the variance covariance
matrix of the standardized estimated model parameters. Standardization
is done with respect to both observed and latent variables.</p>
</dd>
<dt><code>"vcov.std.lv"</code>:</dt><dd><p>Matrix containing the variance covariance
matrix of the standardized estimated model parameters. Standardization
is done with respect to the latent variables only.</p>
</dd>
<dt><code>"vcov.std.nox"</code>:</dt><dd><p>Matrix containing the variance covariance
matrix of the standardized estimated model parameters. Standardization
is done with respect to both observed and latent variables, but
ignoring any exogenous observed covariates.</p>
</dd>
<dt><code>"vcov.def"</code>:</dt><dd><p>Matrix containing the variance covariance matrix
of the user-defined (using the := operator) parameters.</p>
</dd>
<dt><code>"vcov.def.std.all"</code>:</dt><dd><p>Matrix containing the variance covariance
matrix of the standardized user-defined parameters. Standardization
is done with respect to both observed and latent variables.</p>
</dd>
<dt><code>"vcov.def.std.lv"</code>:</dt><dd><p>Matrix containing the variance covariance
matrix of the standardized user-defined parameters. Standardization
is done with respect to the latent variables only.</p>
</dd>
<dt><code>"vcov.def.std.nox"</code>:</dt><dd><p>Matrix containing the variance covariance
matrix of the standardized user-defined parameters. Standardization
is done with respect to both observed and latent variables, but
ignoring any exogenous observed covariates.</p>
</dd>
<dt><code>"vcov.def.joint"</code>:</dt><dd><p>Matrix containing the joint variance
covariance matrix of both the estimated model parameters and
the defined (using the := operator) parameters.</p>
</dd>
<dt><code>"vcov.def.joint.std.all"</code>:</dt><dd><p>Matrix containing the joint
variance covariance matrix of both the standardized model parameters
and the user-defined parameters. Standardization
is done with respect to both observed and latent variables.</p>
</dd>
<dt><code>"vcov.def.joint.std.lv"</code>:</dt><dd><p>Matrix containing the joint
variance covariance matrix of both the standardized model parameters
and the user-defined parameters. Standardization
is done with respect to the latent variables only.</p>
</dd>
<dt><code>"vcov.def.joint.std.nox"</code>:</dt><dd><p>Matrix containing the joint
variance covariance matrix of both the standardized model parameters
and the user-defined parameters. Standardization
is done with respect to both observed and latent variables, but
ignoring any exogenous observed covariates.</p>
</dd>
</dl>

<p>Miscellaneous:
</p>

<dl>
<dt><code>"coef.boot"</code>:</dt><dd><p>Matrix containing estimated model parameters for         for each bootstrap sample. Only relevant when bootstrapping was used.</p>
</dd>
<dt><code>"UGamma"</code>:</dt><dd><p>Matrix containing the product of 'U' and 'Gamma'
matrices as used by the Satorra-Bentler correction. The trace of
this matrix, divided by the degrees of freedom, gives the scaling
factor.</p>
</dd>
<dt><code>"UfromUGamma"</code>:</dt><dd><p>Matrix containing the 'U' matrix
as used by the Satorra-Bentler correction. Alias: <code>"U"</code>.</p>
</dd>
<dt><code>"list"</code>:</dt><dd><p>The parameter table. The same output as given
by <code>parTable()</code>.</p>
</dd>
<dt><code>"fit"</code>:</dt><dd><p>The fit measures. Aliases: <code>"fitmeasures"</code>,
<code>"fit.measures"</code>, <code>"fit.indices"</code>. The same output as
given by <code>fitMeasures()</code>.</p>
</dd>
<dt><code>"mi"</code>:</dt><dd><p>The modification indices. Alias: <code>"modindices"</code>,
<code>"modification.indices"</code>. The same output as given
by <code>modindices()</code>.</p>
</dd>
<dt><code>"loglik.casewise"</code>:</dt><dd><p>Vector containing the casewise 
loglikelihood contributions. Only available if estimator = <code>"ML"</code>.</p>
</dd>
<dt><code>"options"</code>:</dt><dd><p>List. The option list.</p>
</dd>
<dt><code>"call"</code>:</dt><dd><p>List. The call as returned by match.call, coerced to
a list.</p>
</dd>
<dt><code>"timing"</code>:</dt><dd><p>List. The timing (in milliseconds) of various
lavaan subprocedures.</p>
</dd>
<dt><code>"test"</code>:</dt><dd><p>List. All available information regarding the
(goodness-of-fit) test statistic(s).</p>
</dd>
<dt><code>"baseline.test"</code>:</dt><dd><p>List. All available information regarding the
(goodness-of-fit) test statistic(s) of the baseline model.</p>
</dd>
<dt><code>"baseline.partable"</code>:</dt><dd><p>Data.frame. The parameter table of
the (internal) baseline model.</p>
</dd>
<dt><code>"post.check"</code>:</dt><dd><p>Post-fitting check if the solution is
admissible. A warning is raised if negative variances are found, or if
either <code>lavInspect(fit, "cov.lv")</code> or
<code>lavInspect(fit, "theta")</code> return a non-positive definite matrix.</p>
</dd>
<dt><code>"zero.cell.tables"</code>:</dt><dd><p>List. List of bivariate frequency tables
where at least one cell is empty.</p>
</dd>
<dt><code>"version"</code>:</dt><dd><p>The lavaan version number that was used to
construct the fitted lavaan object.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+lavaan">lavaan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fit model
HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '


fit &lt;- cfa(HS.model, data = HolzingerSwineford1939, group = "school")

# extract information
lavInspect(fit, "sampstat")
lavTech(fit, "sampstat")
</code></pre>

<hr>
<h2 id='lavListInspect'>Inspect or extract information from a lavaanList object</h2><span id='topic+lavListInspect'></span><span id='topic+lavListTech'></span>

<h3>Description</h3>

<p>The <code>lavListInspect()</code> and <code>lavListTech()</code> functions can be used to
inspect/extract information that is stored inside (or can be computed from) a
lavaanList object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavListInspect(object, what = "free", add.labels = TRUE,
               add.class = TRUE, list.by.group = TRUE,
               drop.list.single.group = TRUE)

lavListTech(object, what = "free", add.labels = FALSE,
            add.class = FALSE, list.by.group = FALSE,
            drop.list.single.group = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lavListInspect_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+lavaanList-class">lavaanList</a></code>.</p>
</td></tr>
<tr><td><code id="lavListInspect_+3A_what">what</code></td>
<td>
<p>Character. What needs to be inspected/extracted? See Details for a
full list. Note: the <code>what</code> argument is not case-sensitive
(everything is converted to lower case.)</p>
</td></tr>
<tr><td><code id="lavListInspect_+3A_add.labels">add.labels</code></td>
<td>
<p>If <code>TRUE</code>, variable names are added to the vectors
and/or matrices.</p>
</td></tr>
<tr><td><code id="lavListInspect_+3A_add.class">add.class</code></td>
<td>
<p>If <code>TRUE</code>, vectors are given the &lsquo;lavaan.vector&rsquo; class;
matrices are given the &lsquo;lavaan.matrix&rsquo; class, and symmetric matrices are
given the &lsquo;lavaan.matrix.symmetric&rsquo; class. This only affects the way they
are printed on the screen.</p>
</td></tr>
<tr><td><code id="lavListInspect_+3A_list.by.group">list.by.group</code></td>
<td>
<p>Logical. Only used when the output are model matrices.
If <code>TRUE</code>, the model matrices are nested within groups. If <code>FALSE</code>,
a flattened list is returned containing all model matrices, with repeated
names for multiple groups.</p>
</td></tr>
<tr><td><code id="lavListInspect_+3A_drop.list.single.group">drop.list.single.group</code></td>
<td>
<p>If <code>FALSE</code>, the results are returned as
a list, where each element corresponds to a group (even if there is only
a single group.) If <code>TRUE</code>, the list will be unlisted if there is
only a single group.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>lavListInspect()</code> and <code>lavListTech()</code> functions only differ in
the way they return the results. The <code>lavListInspect()</code> function will
prettify the output by default, while the <code>lavListTech()</code> will not attempt
to prettify the output by default.
</p>
<p>Below is a list of possible values for the <code>what</code> argument, organized
in several sections:
</p>
<p>Model matrices:
</p>

<dl>
<dt><code>"free"</code>:</dt><dd><p>A list of model matrices. The non-zero integers
represent the free parameters. The numbers themselves correspond
to the position of the free parameter in the parameter vector.
This determines the order of the model parameters in the output
of for example <code>coef()</code> and <code>vcov()</code>.</p>
</dd>
<dt><code>"partable"</code>:</dt><dd><p>A list of model matrices. The non-zero integers
represent both the fixed parameters (for example, factor loadings
fixed at 1.0), and the free parameters if we ignore any equality
constraints. They correspond with all entries (fixed or free)
in the parameter table. See <code><a href="#topic+parTable">parTable</a></code>.</p>
</dd>
<dt><code>"start"</code>:</dt><dd><p>A list of model matrices. The values represent
the starting values for all model parameters.
Alias: <code>"starting.values"</code>.</p>
</dd>
</dl>

<p>Information about the data (including missing patterns):
</p>

<dl>
<dt><code>"group"</code>:</dt><dd><p>A character string. The group variable in
the data.frame (if any).</p>
</dd>
<dt><code>"ngroups"</code>:</dt><dd><p>Integer. The number of groups.</p>
</dd>
<dt><code>"group.label"</code>:</dt><dd><p>A character vector. The group labels.</p>
</dd>
<dt><code>"level.label"</code>:</dt><dd><p>A character vector. The level labels.</p>
</dd>
<dt><code>"cluster"</code>:</dt><dd><p>A character vector. The cluster variable(s)
in the data.frame (if any).</p>
</dd>
<dt><code>"nlevels"</code>:</dt><dd><p>Integer. The number of levels.</p>
</dd>
<dt><code>"ordered"</code>:</dt><dd><p>A character vector. The ordered variables.</p>
</dd>
<dt><code>"nobs"</code>:</dt><dd><p>Integer vector. The number of observations
in each group that were used in the analysis (in each dataset).</p>
</dd>
<dt><code>"norig"</code>:</dt><dd><p>Integer vector. The original number of observations
in each group (in each dataset).</p>
</dd>
<dt><code>"ntotal"</code>:</dt><dd><p>Integer. The total number of observations that
were used in the analysis. If there is just a single group, this
is the same as the <code>"nobs"</code> option; if there are multiple groups,
this is the sum of the <code>"nobs"</code> numbers for each group
(in each dataset).</p>
</dd>
</dl>

<p>Model features:
</p>

<dl>
<dt><code>"meanstructure"</code>:</dt><dd><p>Logical. <code>TRUE</code> if a meanstructure
was included in the model.</p>
</dd>
<dt><code>"categorical"</code>:</dt><dd><p>Logical. <code>TRUE</code> if categorical endogenous
variables were part of the model.</p>
</dd>
<dt><code>"fixed.x"</code>:</dt><dd><p>Logical. <code>TRUE</code> if the exogenous x-covariates
are treated as fixed.</p>
</dd>
<dt><code>"parameterization"</code>:</dt><dd><p>Character. Either <code>"delta"</code> or
<code>"theta"</code>.</p>
</dd>
</dl>


<dl>
<dt><code>"list"</code>:</dt><dd><p>The parameter table. The same output as given
by <code>parTable()</code>.</p>
</dd>
<dt><code>"options"</code>:</dt><dd><p>List. The option list.</p>
</dd>
<dt><code>"call"</code>:</dt><dd><p>List. The call as returned by match.call, coerced to
a list.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+lavaanList">lavaanList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fit model
HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

# a data generating function
generateData &lt;- function() simulateData(HS.model, sample.nobs = 100)

set.seed(1234)
fit &lt;- semList(HS.model, dataFunction = generateData, ndat = 5,
               store.slots = "partable")

# extract information
lavListInspect(fit, "free")
lavListTech(fit, "free")
</code></pre>

<hr>
<h2 id='lavMatrixRepresentation'>lavaan matrix representation</h2><span id='topic+lavMatrixRepresentation'></span>

<h3>Description</h3>

<p>Extend the parameter table with a matrix representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavMatrixRepresentation(partable, representation = "LISREL", 
                        add.attributes = FALSE, as.data.frame. = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lavMatrixRepresentation_+3A_partable">partable</code></td>
<td>
<p>A lavaan parameter table (as extracted by the 
<code><a href="#topic+parTable">parTable</a></code> function, or generated by the 
<code><a href="#topic+lavPartable">lavPartable</a></code> function).</p>
</td></tr>
<tr><td><code id="lavMatrixRepresentation_+3A_representation">representation</code></td>
<td>
<p>Character. The matrix representation style.
Currently, only the all-y version of the LISREL representation 
is supported.</p>
</td></tr>
<tr><td><code id="lavMatrixRepresentation_+3A_add.attributes">add.attributes</code></td>
<td>
<p>Logical. If <code>TRUE</code>, additional information
about the model matrix representation is added as attributes.</p>
</td></tr>
<tr><td><code id="lavMatrixRepresentation_+3A_as.data.frame.">as.data.frame.</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the extended parameter table is
returned as a data.frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list or a data.frame containing the original parameter table, plus
three columns: a <code>"mat"</code> column containing matrix names, and
a <code>"row"</code> and <code>"col"</code> column for the row and column indices
of the model parameters in the model matrices.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lavParTable">lavParTable</a></code>, <code><a href="#topic+parTable">parTable</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- cfa(HS.model, data=HolzingerSwineford1939)

# extract partable
partable &lt;- parTable(fit)

# add matrix representation (and show only a few columns)
lavMatrixRepresentation(partable)[,c("lhs","op","rhs","mat","row","col")]
</code></pre>

<hr>
<h2 id='lavNames'>lavaan Names</h2><span id='topic+lavNames'></span><span id='topic+lavaanNames'></span>

<h3>Description</h3>

<p>Extract variables names from a fitted lavaan object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavNames(object, type = "ov", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lavNames_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+lavaan-class">lavaan</a></code>.</p>
</td></tr>
<tr><td><code id="lavNames_+3A_type">type</code></td>
<td>
<p>Character. The type of variables whose names should be extracted. 
See details for a complete list.</p>
</td></tr>
<tr><td><code id="lavNames_+3A_...">...</code></td>
<td>
<p>Additional selection variables. For example <code>"group = 2L"</code>
(in a multiple-group analysis) only considers the variables included
in the model for the second group.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order of the variable names, as returned by <code>lavNames</code> 
determines the order in which the variables are listed in the parameter
table, and therefore also in the summary output.
</p>
<p>The following variable types are available:
</p>

<ul>
<li> <p><code>"ov"</code>: observed variables
</p>
</li>
<li> <p><code>"ov.x"</code>: (pure) exogenous observed variables (no mediators)
</p>
</li>
<li> <p><code>"ov.nox"</code>: non-exogenous observed variables
</p>
</li>
<li> <p><code>"ov.model"</code>: modelled observed variables (joint vs conditional)
</p>
</li>
<li> <p><code>"ov.y"</code>: (pure) endogenous variables (dependent only) (no mediators)
</p>
</li>
<li> <p><code>"ov.num"</code>: numeric observed variables
</p>
</li>
<li> <p><code>"ov.ord"</code>: ordinal observed variables
</p>
</li>
<li> <p><code>"ov.ind"</code>: observed indicators of latent variables
</p>
</li>
<li> <p><code>"ov.orphan"</code>: lonely observed variables (only intercepts/variancesappear in the model syntax)
</p>
</li>
<li> <p><code>"ov.interaction"</code>: interaction terms (defined by the colon operator)
</p>
</li>
<li> <p><code>"th"</code>: threshold names ordinal variables only
</p>
</li>
<li> <p><code>"th.mean"</code>: threshold names ordinal + numeric variables (if any)
</p>
</li>
<li> <p><code>"lv"</code>: latent variables
</p>
</li>
<li> <p><code>"lv.regular"</code>: latent variables (defined by =~ only)
</p>
</li>
<li> <p><code>"lv.formative"</code>: latent variables (defined by &lt;~ only)
</p>
</li>
<li> <p><code>"lv.x"</code>: (pure) exogenous variables
</p>
</li>
<li> <p><code>"lv.y"</code>: (pure) endogenous variables
</p>
</li>
<li> <p><code>"lv.nox"</code>: non-exogenous latent variables
</p>
</li>
<li> <p><code>"lv.nonnormal"</code>: latent variables with non-normal indicators
</p>
</li>
<li> <p><code>"lv.interaction"</code>:  interaction terms at the latent level
</p>
</li>
<li> <p><code>"eqs.y"</code>: variables that appear as dependent variables in a
regression formula (but not indicators of latent
variables)
</p>
</li>
<li> <p><code>"eqs.x"</code>: variables that appear as independent variables in
a regression formula
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+lavaanify">lavaanify</a></code>, <code><a href="#topic+parTable">parTable</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- cfa(HS.model, data=HolzingerSwineford1939)
lavNames(fit, "ov")
</code></pre>

<hr>
<h2 id='lavOptions'>lavaan Options</h2><span id='topic+lavOptions'></span><span id='topic+lavoptions'></span>

<h3>Description</h3>

<p>Show the default options used by the <code>lavaan()</code> function. The
options can be changed by passing 'name = value' arguments to the 
<code>lavaan()</code> function call, where they will be added to the '...'
argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavOptions(x = NULL, default = NULL, mimic = "lavaan")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lavOptions_+3A_x">x</code></td>
<td>
<p>Character. A character string holding an option name, or a character
string vector holding multiple option names. All option names are converted to
lower case.</p>
</td></tr>
<tr><td><code id="lavOptions_+3A_default">default</code></td>
<td>
<p>If a single option is specified but not available, this value
is returned.</p>
</td></tr>
<tr><td><code id="lavOptions_+3A_mimic">mimic</code></td>
<td>
<p>Not used for now.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the full list of options that are accepted by the <code>lavaan()</code>
function, organized in several sections:
</p>
<p>Model features (always available):
</p>

<dl>
<dt><code>meanstructure</code>:</dt><dd><p>If <code>TRUE</code>, the means of the observed
variables enter the model. If <code>"default"</code>, the value is set based
on the user-specified model, and/or the values of other arguments.</p>
</dd>
<dt><code>int.ov.free</code>:</dt><dd><p>If <code>FALSE</code>, the intercepts of the 
observed variables are fixed to zero.</p>
</dd>
<dt><code>int.lv.free</code>:</dt><dd><p>If <code>FALSE</code>, the intercepts of the latent 
variables are fixed to zero.</p>
</dd>
<dt><code>conditional.x</code>:</dt><dd><p>If <code>TRUE</code>, we set up the model 
conditional on the exogenous &lsquo;x&rsquo; covariates; the model-implied sample 
statistics only include the non-x variables. If <code>FALSE</code>, the 
exogenous &lsquo;x&rsquo; variables are modeled jointly with the other variables, and 
the model-implied statistics refect both sets of variables. If
<code>"default"</code>, the value is set depending on the estimator, and
whether or not the model involves categorical endogenous variables.</p>
</dd>
<dt><code>fixed.x</code>:</dt><dd><p>If <code>TRUE</code>, the exogenous &lsquo;x&rsquo; covariates are 
considered fixed variables and the means, variances and covariances of 
these variables are fixed to their sample values. If <code>FALSE</code>, they 
are considered random, and the means, variances and covariances are free 
parameters. If <code>"default"</code>, the value is set depending on the mimic 
option.</p>
</dd>
<dt><code>orthogonal</code>:</dt><dd><p>If <code>TRUE</code>, all covariances among
latent variables are set to zero.</p>
</dd>
<dt><code>orthogonal.y</code>:</dt><dd><p>If <code>TRUE</code>, all covariances among
endogenous latent variables only are set to zero.</p>
</dd>
<dt><code>orthogonal.x</code>:</dt><dd><p>If <code>TRUE</code>, all covariances among
exogenous latent variables only are set to zero.</p>
</dd>
<dt><code>std.lv</code>:</dt><dd><p>If <code>TRUE</code>, the metric of each latent variable 
is determined by fixing their (residual) variances to 1.0. If 
<code>FALSE</code>, the metric of each latent variable is determined by fixing 
the factor loading of the first indicator to 1.0. If there are multiple
groups, <code>std.lv = TRUE</code> and <code>"loadings"</code> is included in 
the <code>group.equal</code> argument, then only the latent variances
of the first group will be fixed to 1.0, while the latent
variances of other groups are set free.</p>
</dd>
<dt><code>effect.coding</code>:</dt><dd><p>Can be logical or character string. If
logical and <code>TRUE</code>, this implies 
<code>effect.coding = c("loadings", "intercepts")</code>. If logical and 
<code>FALSE</code>, it is set equal to the empty string. 
If <code>"loadings"</code> is included, equality
constraints are used so that the average of the factor loadings (per
latent variable) equals 1. Note that this should not be used 
together with <code>std.lv = TRUE</code>. If <code>"intercepts"</code> is
included, equality constraints are used so that the sum of the
intercepts (belonging to the indicators of a single latent variable) 
equals zero.
As a result, the latent mean will be freely estimated and usually 
equal the average of the means of the involved indicators.</p>
</dd>
<dt><code>ceq.simple</code>:</dt><dd><p>Logical. If <code>TRUE</code>, and no other 
general (equality or inequality) constraints are used in the model, 
simple equality constraints
are represented in the parameter table as duplicated free parameters 
(instead of extra rows with <code>op = "=="</code>).</p>
</dd>
<dt><code>parameterization</code>:</dt><dd><p>Currently only used if data is 
categorical. If <code>"delta"</code>, the delta parameterization is used. 
If <code>"theta"</code>, the theta parameterization is used.</p>
</dd>
<dt><code>correlation</code>:</dt><dd><p>Only used for (single-level)
continuous data. If <code>TRUE</code>, analyze a correlation matrix (instead
of a (co)variance matrix). This implies that the residual observed
variances are no longer free parameters. Instead, they are set to
values to ensure the model-implied variances are unity. This also
affects the standard errors. The only available estimators are GLS and
WLS, which produce correct standard errors and a correct test statistic
under normal and non-normal conditions respectively. Always assuming
<code>fixed.x = FALSE</code> and <code>conditional.x = FALSE</code> (for now).</p>
</dd>
</dl>

<p>Model features (only available for the <code>lavaan()</code> function):
</p>

<dl>
<dt><code>auto.fix.first</code>:</dt><dd><p>If <code>TRUE</code>, the factor loading of the 
first indicator is set to 1.0 for every latent variable.</p>
</dd>
<dt><code>auto.fix.single</code>:</dt><dd><p>If <code>TRUE</code>, the residual variance (if 
included) of an observed indicator is set to zero if it is the only 
indicator of a latent variable.</p>
</dd>
<dt>auto.var</dt><dd><p>If <code>TRUE</code>, the (residual) variances of both observed
and latent variables are set free.</p>
</dd>
<dt><code>auto.cov.lv.x</code>:</dt><dd><p>If <code>TRUE</code>, the covariances of exogenous 
latent variables are included in the model and set free.</p>
</dd>
<dt><code>auto.cov.y</code>:</dt><dd><p>If <code>TRUE</code>, the covariances of dependent 
variables (both observed and latent) are included in the model and set 
free.</p>
</dd>
<dt><code>auto.th</code>:</dt><dd><p>If <code>TRUE</code>, thresholds for limited dependent 
variables are included in the model and set free.</p>
</dd>
<dt><code>auto.delta</code>:</dt><dd><p>If <code>TRUE</code>, response scaling parameters 
for limited dependent variables are included in the model and set free.</p>
</dd>
<dt><code>auto.efa</code>:</dt><dd><p>If <code>TRUE</code>, the necessary constraints are
imposed to make the (unrotated) exploratory factor analysis blocks
identifiable: for each block, factor variances are set to 1, factor
covariances are constrained to be zero, and factor loadings are
constrained to follow an echelon pattern.</p>
</dd>
</dl>

<p>Data options:
</p>

<dl>
<dt><code>std.ov</code>:</dt><dd><p>If <code>TRUE</code>, observed variables are 
standardized before entering the analysis. By default, these are
only the non-exogenous observed variables, unless <code>fixed.x = FALSE</code>.
Use this option with caution; it can be used to test if (for example)
nonconvergence was due to scaling issues. But this is still a covariance
based analysis, in the sense that no constraints are involved (to 
ensure the model-implied (co)variance matrix has unit variances), and the
standard errors still assume that the input was unstandardized. See
also the <code>correlation</code> option.</p>
</dd>
<dt><code>missing</code>:</dt><dd><p>The default setting is <code>"listwise"</code>: all
cases with missing values
are removed listwise from the data before the analysis starts. This is
only valid if the data are missing completely at random (MCAR).
Therefore, it may not be the optimal choice, but
it can be useful for a first run. If the estimator belongs to
the ML family, another option is <code>"ml"</code> (alias: <code>"fiml"</code>
or <code>"direct"</code>). This corresponds to the so-called full information
maximum likelihood approach (fiml), where we compute the likelihood
case by case, using all available data from that case. Note
that if the model contains exogenous observed covariates, and
<code>fixed.x = TRUE</code> (the default), all cases with any missing values
on these covariates will be deleted first. The option <code>"ml.x"</code>
(alias: <code>"fiml.x"</code> or <code>"direct.x"</code>) is similar to <code>"ml"</code>,
but does not delete any cases with missing values for the exogenous
covariates, even if <code>fixed.x = TRUE</code>. (Note: all lavaan versions
&lt; 0.6 used <code>"ml.x"</code> instead of <code>"ml"</code>).
If you wish to use multiple
imputation, you need to use an external package (eg. mice) to
generate imputed datasets, which can then be analyzed using
the <code><a href="#topic+semList">semList</a></code> function. The semTools package contains
several functions to do this automatically. Another option (with
continuous data) is to use <code>"two.stage"</code>
or <code>"robust.two.stage"</code>. In this approach, we first estimate
the sample statistics (mean vector, variance-covariance matrix) using
an EM algorithm. Then, we use these estimated sample statistics as
input for a regular analysis (as if the data were complete). The
standard errors and test statistics
are adjusted correctly to reflect the two-step procedure. The
<code>"robust.two.stage"</code> option produces standard errors and
a test statistic that are robust against non-normality.
If (part of) the data is categorical, and the estimator is
from the (W)LS family, the only option (besides listwise deletion)
is <code>"pairwise"</code>. In this three-step approach, missingness is
only an issue in the first two steps. In the first step, we compute
thresholds (for categorical variables) and means or intercepts
(for continuous variables) using univariate information only.
In this step, we simply ignore
the missing values just like in mean(x, na.rm = TRUE). In the second
step, we compute polychoric/polyserial/pearson correlations using (only)
two variables at a time. Here we use pairwise deletion: we only keep
those observations for which both values are observed (not-missing).
And this may change from pair to pair.
By default, in the categorical case we use <code>conditional.x = TRUE</code>. 
Therefore, any cases
with missing values on the exogenous covariates will be deleted listwise
from the data first.
Finally, if the estimator is <code>"PML"</code>, the available options are
<code>"pairwise"</code>, <code>"available.cases"</code> and
<code>"doubly.robust"</code>. See the PML tutorial on the lavaan website for
more information about these approaches.</p>
</dd>
<dt><code>sampling.weights.normalization</code>:</dt><dd><p>If <code>"none"</code>, the
sampling weights (if provided) will not be transformed. If <code>"total"</code>,
the sampling weights are normalized by dividing by the total sum of
the weights, and multiplying again by the total sample size. 
If <code>"group"</code>, the sampling weights are normalized per group:
by dividing by the sum of the weights (in each group), and multiplying
again by the group size. The default is <code>"total"</code>.</p>
</dd>
<dt><code>samplestats</code>:</dt><dd><p>Logical. If <code>FALSE</code>, no sample statistics
will be computed (and no estimation can take place). This can be useful
when only a dummy lavaan object is requested, without any computations.
The default is <code>TRUE</code>.</p>
</dd>
</dl>

<p>Data summary options:
</p>

<dl>
<dt><code>sample.cov.rescale</code>:</dt><dd><p>If <code>TRUE</code>, the sample covariance 
matrix provided by the user is internally rescaled by multiplying it 
with a factor (N-1)/N.  If <code>"default"</code>, the value is set depending 
on the estimator and the likelihood option: it is set to <code>TRUE</code> if 
maximum likelihood estimation is used and <code>likelihood="normal"</code>, 
and <code>FALSE</code> otherwise.</p>
</dd>
<dt><code>ridge</code>:</dt><dd><p>Logical. If <code>TRUE</code> a small constant value will
be added the diagonal elements of the covariance (or correlation) 
matrix before analysis. The value can be set using the 
<code>ridge.constant</code> option.</p>
</dd>
<dt><code>ridge.constant</code>:</dt><dd><p>Numeric. Small constant used for ridging.
The default value is 1e-05.</p>
</dd>
</dl>

<p>Multiple group options:
</p>
      
<dl>
<dt><code>group.label</code>:</dt><dd><p>A character vector. The user can specify 
which group (or factor) levels need to be selected from the grouping 
variable, and in which order. If missing, all grouping levels are 
selected, in the order as they appear in the data.</p>
</dd>
<dt><code>group.equal</code>:</dt><dd><p>A vector of character strings. Only used in
a multiple group analysis. Can be one or more of the following:
<code>"loadings"</code>, <code>"composite.loadings"</code>, 
<code>"intercepts"</code>, <code>"means"</code>,
<code>"thresholds"</code>, <code>"regressions"</code>, <code>"residuals"</code>,
<code>"residual.covariances"</code>, <code>"lv.variances"</code> or
<code>"lv.covariances"</code>, specifying the pattern of equality
constraints across multiple groups.</p>
</dd>
<dt><code>group.partial</code>:</dt><dd><p>A vector of character strings containing 
the labels of the parameters which should be free in all groups (thereby
overriding the group.equal argument for some specific parameters).</p>
</dd>
<dt><code>group.w.free</code>:</dt><dd><p>Logical. If <code>TRUE</code>, the group 
frequencies are considered to be free parameters in the model. In this 
case, a Poisson model is fitted to estimate the group frequencies. If
<code>FALSE</code> (the default), the group frequencies are fixed to their
observed values.</p>
</dd>
</dl>

<p>Estimation options:
</p>

<dl>
<dt><code>estimator</code>:</dt><dd><p>The estimator to be used. Can be one of the 
following: <code>"ML"</code> for maximum likelihood, <code>"GLS"</code> for 
(normal theory) generalized least squares, 
<code>"WLS"</code> for weighted least squares 
(sometimes called ADF estimation), <code>"ULS"</code> for unweighted least 
squares, <code>"DWLS"</code> for diagonally weighted least squares,
and <code>"DLS"</code> for distributionally-weighted least squares. These
are the main options that affect the estimation. For convenience, the
<code>"ML"</code> option can be extended as <code>"MLM"</code>, <code>"MLMV"</code>,
<code>"MLMVS"</code>, <code>"MLF"</code>, and <code>"MLR"</code>.
The estimation will still be plain <code>"ML"</code>, but now
with robust standard errors and a robust (scaled) test statistic. For
<code>"MLM"</code>, <code>"MLMV"</code>, <code>"MLMVS"</code>, classic robust standard
errors are used (<code>se="robust.sem"</code>); for <code>"MLF"</code>, standard
errors are based on first-order derivatives 
(<code>information = "first.order"</code>);
for <code>"MLR"</code>, &lsquo;Huber-White&rsquo; robust standard errors are used
(<code>se="robust.huber.white"</code>). In addition, <code>"MLM"</code> will compute
a Satorra-Bentler scaled (mean adjusted) test statistic
(<code>test="satorra.bentler"</code>) , <code>"MLMVS"</code> will compute a
mean and variance adjusted test statistic (Satterthwaite style)
(<code>test="mean.var.adjusted"</code>), <code>"MLMV"</code> will compute a mean
and variance adjusted test statistic (scaled and shifted)
(<code>test="scaled.shifted"</code>), and <code>"MLR"</code> will
compute a test statistic which is asymptotically
equivalent to the Yuan-Bentler T2-star test statistic
(<code>test="yuan.bentler.mplus"</code>). Analogously,
the estimators <code>"WLSM"</code> and <code>"WLSMV"</code> imply the <code>"DWLS"</code>
estimator (not the <code>"WLS"</code> estimator) with robust standard errors
and a mean or mean and variance adjusted test statistic. Estimators
<code>"ULSM"</code> and <code>"ULSMV"</code> imply the <code>"ULS"</code>
estimator with robust standard errors
and a mean or mean and variance adjusted test statistic.</p>
</dd>
<dt><code>likelihood</code>:</dt><dd><p>Only relevant for ML estimation. If 
<code>"wishart"</code>, the wishart likelihood approach is used. In this 
approach, the covariance matrix has been divided by N-1, and both 
standard errors and test statistics are based on N-1.
If <code>"normal"</code>, the normal likelihood approach is used. Here,
the covariance matrix has been divided by N, and both standard errors
and test statistics are based on N. If <code>"default"</code>, it depends
on the mimic option: if <code>mimic="lavaan"</code> or <code>mimic="Mplus"</code>,
normal likelihood is used; otherwise, wishart likelihood is used.</p>
</dd>
<dt><code>link</code>:</dt><dd><p>Not used yet. This is just a placeholder until
the MML estimator is back.</p>
</dd>
<dt><code>information</code>:</dt><dd><p>If <code>"expected"</code>, the expected 
information matrix is used (to compute the standard errors). If 
<code>"observed"</code>, the observed information matrix is used. 
If <code>"first.order"</code>, the information matrix is based on the
outer product of the casewise scores. See also the options
<code>"h1.information"</code> and <code>"observed.information"</code> for
further control. If <code>"default"</code>, the value is set depending 
on the estimator, the missing argument, and the mimic option. If
the argument is a vector with two elements, the first element
is used for the computation of the standard errors, while the
second element is used for the (robust) test statistic.</p>
</dd>
<dt><code>h1.information</code>:</dt><dd><p>If <code>"structured"</code> (the default), the
unrestricted (h1) information part of the (expected, first.order or 
observed if h1 is used) information matrix is based on the structured, 
or model-implied statistics (model-implied covariance matrix, 
model-implied mean vector, etc.). 
If <code>"unstructured"</code>, the unrestricted (h1) information part is
based on sample-based statistics (observed covariance matrix, observed
mean vector, etc.) If
the argument is a vector with two elements, the first element
is used for the computation of the standard errors, while the
second element is used for the (robust) test statistic.</p>
</dd>
<dt><code>observed.information</code>:</dt><dd><p>If <code>"hessian"</code>, the observed
information matrix is based on the hessian of the objective function.
If <code>"h1"</code>, an approximation is used that is based on 
the observed information matrix of the unrestricted (h1) model. If
the argument is a vector with two elements, the first element
is used for the computation of the standard errors, while the
second element is used for the (robust) test statistic.</p>
</dd>
<dt><code>se</code>:</dt><dd><p>If <code>"standard"</code>, conventional standard errors
are computed based on inverting the (expected, observed or first.order) 
information matrix. If <code>"robust.sem"</code>, conventional robust
standard errors are computed.  If <code>"robust.huber.white"</code>,
standard errors are computed based on the 'mlr' (aka pseudo ML,
Huber-White) approach.
If <code>"robust"</code>, either <code>"robust.sem"</code> or
<code>"robust.huber.white"</code> is used depending on the estimator,
the mimic option, and whether the data are complete or not.
If <code>"boot"</code> or <code>"bootstrap"</code>, bootstrap standard errors are
computed using standard bootstrapping (unless Bollen-Stine bootstrapping
is requested for the test statistic; in this case bootstrap standard
errors are computed using model-based bootstrapping).
If <code>"none"</code>, no standard errors are computed.</p>
</dd>
<dt><code>test</code>:</dt><dd><p>Character vector. See the documentation of
the <code><a href="#topic+lavTest">lavTest</a></code> function for a full list. Multiple names
of test statistics can be provided. If <code>"default"</code>, the value 
depends on the values of other arguments. See also the 
<code><a href="#topic+lavTest">lavTest</a></code> function to extract (alternative)     
test statistics from a fitted lavaan object.</p>
</dd>
<dt><code>scaled.test</code>:</dt><dd><p>Character. Choose the test statistic
that will be scaled (if a scaled test statistic is requested).
The default is <code>"standard"</code>, but it could also be (for example)
<code>"Browne.residual.nt"</code>.</p>
</dd>
<dt><code>gamma.n.minus.one</code></dt><dd><p>Logical. If <code>TRUE</code>, we divide the
Gamma matrix by N-1 (instead of the default N).</p>
</dd>
<dt><code>gamma.unbiased</code></dt><dd><p>Logical. If <code>TRUE</code>, we compute an
unbiased version for the Gamma matrix. Only available for single-level
complete data and when <code>conditional.x = FALSE</code> and 
<code>fixed.x = FALSE</code> (for now).</p>
</dd>
<dt><code>bootstrap</code>:</dt><dd><p>Number of bootstrap draws, if bootstrapping is 
used.</p>
</dd>
<dt><code>do.fit</code>:</dt><dd><p>If <code>FALSE</code>, the model is not fit, and the 
current starting values of the model parameters are preserved.</p>
</dd>
</dl>

<p>Optimization options:
</p>

<dl>
<dt><code>control</code>:</dt><dd><p>A list containing control parameters passed to 
the external optimizer. By default, lavaan uses <code>"nlminb"</code>. 
See the manpage of <code><a href="stats.html#topic+nlminb">nlminb</a></code> for an overview of the control 
parameters. If another (external) optimizer is selected, see the
manpage for that optimizer to see the possible control parameters.</p>
</dd>
<dt><code>optim.method</code>:</dt><dd><p>Character. The optimizer that should be
used. For unconstrained optimization or models with only linear
equality constraints (i.e., the model syntax
does not include any &quot;==&quot;, &quot;&gt;&quot; or &quot;&lt;&quot; operators),
the available options are <code>"nlminb"</code> (the default), <code>"BFGS"</code>,
<code>"L-BFGS-B"</code>. These are all quasi-newton methods. A basic 
implementation of Gauss-Newton is also available
(<code>optim.method = "GN"</code>). The latter is the default when 
<code>estimator = "DLS"</code>.
For constrained
optimization, the only available option is <code>"nlminb.constr"</code>,
which uses an augmented Lagrangian minimization algorithm.</p>
</dd>
<dt><code>optim.force.converged</code>:</dt><dd><p>Logical. If <code>TRUE</code>, pretend
the model has converged, no matter what.</p>
</dd>
<dt><code>optim.dx.tol</code></dt><dd><p>Numeric. Tolerance used for checking if
the elements of the (unscaled) gradient are all zero (in absolute 
value). The default value is 0.001.</p>
</dd>
<dt><code>optim.gn.tol.x</code>:</dt><dd><p>Numeric. Only used when 
<code>optim.method = "GN"</code>. Optimization stops when
the root mean square of the difference between the old and new
parameter values are smaller than this tolerance value. Default is
<code>1e-05</code> for DLS estimation and <code>1e-07</code> otherwise.</p>
</dd>
<dt><code>optim.gn.iter.max</code>:</dt><dd><p>Integer. Only used when 
<code>optim.method = "GN"</code>. The maximum number of GN iterations. 
The default is 200.</p>
</dd>
<dt><code>bounds</code>:</dt><dd><p>Only used if <code>optim.method = "nlminb"</code>.
If logical: <code>FALSE</code> implies no bounds are imposed on the parameters.
If <code>TRUE</code>, this implies <code>bounds = "wide"</code>. If character,
possible options are <code>"none"</code> (the default), <code>"standard"</code>,
<code>"wide"</code>, <code>"pos.var"</code>, <code>"pos.ov.var"</code>, and 
<code>"pos.lv.var"</code>. 
If <code>bounds = "pos.ov.var"</code>, the observed variances are forced to be
nonnegative. If <code>bounds = "pos.lv.var"</code>, the latent variances are
forced to be nonnegative. If <code>bounds = "pos.var"</code>, both observed
and latent variances are forced to be nonnegative. If 
<code>bounds = "standard"</code>, lower and upper bounds are computed for
observed and latent variances, and factor loadings. If
<code>bounds = "wide"</code>, lower and upper bounds are computed for
observed and latent variances, and factor loadings; but the range of
the bounds is enlarged (allowing again for slightly negative variances).</p>
</dd>
<dt><code>optim.bounds</code>:</dt><dd><p>List. This can be used instead of the 
<code>bounds</code> argument to allow more control. Possible elements of the
list are <code>lower</code>, <code>upper</code>, <code>lower.factor</code> and 
<code>upper.factor</code>. All of these accept a vector. The <code>lower</code> and
<code>upper</code> elements indicate for which type of parameters bounds
should be computed. Possible choice are <code>"ov.var"</code>, <code>"lv.var"</code>,
<code>"loadings"</code> and <code>"covariances"</code>. The <code>lower.factor</code> and 
<code>upper.factor</code> elements should have the same length as the 
<code>lower</code> and <code>upper</code> elements respectively. They indicate the
factor by which the range of the bounds should be enlarged (for 
example, 1.1 or 1.2; the default is 1.0). Other elements are
<code>min.reliability.marker</code> which sets the lower bound for the
reliability of the marker indicator (if any) of each factor 
(default is 0.1). Finally, the <code>min.var.lv.endo</code> element indicates
the lower bound of the variance of any endogenous latent variance
(default is 0.0).</p>
</dd>
</dl>

<p>Parallelization options (currently only used for bootstrapping):
</p>

<dl>
<dt>parallel</dt><dd><p>The type of parallel operation to be used (if any).  If
missing, the default is <code>"no"</code>.  </p>
</dd>
<dt>ncpus</dt><dd><p>Integer: number of processes to be used in parallel operation:
typically one would chose this to the number of available CPUs. By
By default this is the number of cores (as detected by 
<code>parallel::detectCores()</code>) minus one.</p>
</dd>
<dt>cl</dt><dd><p>An optional <span class="pkg">parallel</span> or <span class="pkg">snow</span> cluster for use if
<code>parallel = "snow"</code>. If not supplied, a cluster on the local 
machine is created for the duration of the <code>bootstrapLavaan</code> 
or <code>bootstrapLRT</code> call.</p>
</dd>
<dt>iseed</dt><dd><p>An integer to set the seed. Or NULL if no reproducible 
results are needed. This works for both serial (non-parallel) and 
parallel settings. Internally, <code>RNGkind()</code> is set to 
<code>"L'Ecuyer-CMRG"</code> if <code>parallel = "multicore"</code>. If 
<code>parallel = "snow"</code> (under windows), 
<code>parallel::clusterSetRNGStream()</code> is called which automatically 
switches to <code>"L'Ecuyer-CMRG"</code>. When <code>iseed</code> is not
NULL, <code>.Random.seed</code> (if it exists) in the global environment is
left untouched.</p>
</dd>
</dl>

<p>Categorical estimation options:
</p>

<dl>
<dt><code>zero.add</code>:</dt><dd><p>A numeric vector containing two values. These 
values affect the calculation of polychoric correlations when some 
frequencies in the bivariate table are zero. The first value only 
applies for 2x2 tables. The second value for larger tables. This value 
is added to the zero frequency in the bivariate table. If 
<code>"default"</code>, the value is set depending on the <code>"mimic"</code>
option. By default, lavaan uses <code>zero.add = c(0.5. 0.0)</code>.</p>
</dd>
<dt><code>zero.keep.margins</code>:</dt><dd><p>Logical. This argument only affects 
the computation of polychoric correlations for 2x2 tables with an empty 
cell, and where a value is added to the empty cell. If <code>TRUE</code>, the 
other values of the frequency table are adjusted so that all margins are 
unaffected. If <code>"default"</code>, the value is set depending on the 
<code>"mimic"</code>. The default is <code>TRUE</code>.</p>
</dd>
<dt><code>zero.cell.warn</code>:</dt><dd><p>Logical. Only used if some observed 
endogenous variables are categorical. If <code>TRUE</code>, give a warning if 
one or more cells of a bivariate frequency table are empty.</p>
</dd>
<dt><code>allow.empty.cell</code>:</dt><dd><p>Logical. If <code>TRUE</code>, ignore
situations where an ordinal variable has fewer categories than
expected, or where a category is empty in a specific group.</p>
</dd>
</dl>

<p>Starting values options:
</p>

<dl>
<dt><code>start</code>:</dt><dd><p>If it is a character string, the two options are 
currently <code>"simple"</code> and <code>"Mplus"</code>. In the first case, all 
parameter values are set to zero, except the factor loadings and
(residual) variances, which are set to one.
When <code>start</code> is <code>"Mplus"</code>, the factor loadings are
estimated using the fabin3 estimator (tsls) per factor. The
residual variances of observed variables are set tot half the 
observed variance, and all other (residual) variances are set to 0.05.
The remaining parameters (regression coefficients, covariances) are
set to zero.
If <code>start</code> is a fitted object of class <code><a href="#topic+lavaan-class">lavaan</a></code>,
the estimated values of the corresponding parameters will be extracted.
If it is a parameter table, for example the output of the
<code>paramaterEstimates()</code> function, the values of the <code>est</code> or
<code>start</code> or <code>ustart</code> column (whichever is found first) will be
extracted.</p>
</dd>
<dt><code>rstarts</code>:</dt><dd><p>Integer. The number of refits that lavaan should
try with random starting values. Random starting values are computed
by drawing random numbers from a uniform distribution. Correlations
are drawn from the interval [-0.5, +0.5] and then converted to
covariances. Lower and upper bounds for (residual) variances are
computed just like the standard bounds in bounded estimation.
Random starting values are not computed for regression coefficients
(which are always zero) and factor loadings of higher-order constructs
(which are always unity). From all the runs that converged, the final
solution is the one that resulted in the smallest value for the
discrepancy function.</p>
</dd>
</dl>

<p>Check options:
</p>

<dl>
<dt><code>check.start</code>:</dt><dd><p>Logical. If <code>TRUE</code>,
the starting values are checked for possibly 
inconsistent values (for example values implying correlations larger 
than one). If needed, a warning is given.</p>
</dd>
<dt><code>check.gradient</code>:</dt><dd><p>Logical. If <code>TRUE</code>, and the model
converged, a warning
is given if the optimizer decided that a (local) solution has
been found, while not all elements of the (unscaled) gradient (as 
seen by the optimizer) are (near) zero, as
they should be (the tolerance used is 0.001).</p>
</dd>
<dt><code>check.post</code>:</dt><dd><p>Logical. If <code>TRUE</code>, and the model
converged, a check is performed after (post) fitting, to verify if 
the solution is admissible. This implies that all variances are
non-negative, and all the model-implied covariance matrices are 
positive (semi-)definite. For the latter test, we tolerate a tiny 
negative eigenvalue that is smaller than .Machine$double.eps^(3/4), 
treating it as being zero.</p>
</dd>
<dt><code>check.vcov</code>:</dt><dd><p>Logical. If <code>TRUE</code>, and the model converged,
we check if the variance-covariance matrix of the free parameters
is positive definite. We take into account possible equality and
acitive inequality constraints. If needed, a warning is given.</p>
</dd>
<dt><code>check.lv.names</code>:</dt><dd><p>Logical. If <code>TRUE</code>, and latent variables
are defined in the model, lavaan will stop with an error message if
a latent variable name also occurs in the data (implying it is also
an observed variable).</p>
</dd>
</dl>

<p>Verbosity options:
</p>

<dl>
<dt><code>verbose</code>:</dt><dd><p>If <code>TRUE</code>, show what lavaan is doing. During
estimation, the function value is printed out 
during each iteration.</p>
</dd>
<dt><code>warn</code>:</dt><dd><p>If <code>FALSE</code>, suppress all lavaan-specific 
warning messages.</p>
</dd>
<dt><code>debug</code>:</dt><dd><p>If <code>TRUE</code>, debugging information is printed 
out.</p>
</dd>
</dl>

<p>Miscellaneous:
</p>

<dl>
<dt><code>model.type</code>:</dt><dd><p>Set the model type: possible values
are <code>"cfa"</code>, <code>"sem"</code> or <code>"growth"</code>. This may affect
how starting values are computed, and may be used to alter the terminology
used in the summary output, or the layout of path diagrams that are
based on a fitted lavaan object.</p>
</dd>
<dt><code>mimic</code>:</dt><dd><p>If <code>"Mplus"</code>, an attempt is made to mimic the 
Mplus program. If <code>"EQS"</code>, an attempt is made to mimic the EQS 
program. If <code>"default"</code>, the value is (currently) set to to 
<code>"lavaan"</code>, which is very close to <code>"Mplus"</code>.</p>
</dd>
<dt><code>representation</code>:</dt><dd><p>If <code>"LISREL"</code> the classical LISREL 
matrix representation is used to represent the model (using the all-y 
variant). No other options are available (for now).</p>
</dd>
<dt><code>implied</code>:</dt><dd><p>Logical. If <code>TRUE</code>, compute the model-implied
statistics, and store them in the implied slot.</p>
</dd>
<dt><code>h1</code>:</dt><dd><p>Logical. If <code>TRUE</code>, compute the unrestricted model
and store the unrestricted summary statistics (and perhaps a 
loglikelihood) in the h1 slot.</p>
</dd>
<dt><code>baseline:</code></dt><dd><p>Logical. If <code>TRUE</code>, compute a baseline model
(currently always the independence model, assuming all variables
are uncorrelated) and store the results in the baseline slot.</p>
</dd>
<dt><code>baseline.conditional.x.free.slopes</code>:</dt><dd><p>Logical. If <code>TRUE</code>,
and <code>conditional.x = TRUE</code>, the (default) baseline model will
allow the slopestructure to be unrestricted.</p>
</dd>
<dt><code>store.vcov</code></dt><dd><p>Logical. If <code>TRUE</code>, and <code>se=</code> is not
set to <code>"none"</code>, store the full variance-covariance matrix of
the model parameters in the vcov slot of the fitted lavaan object.</p>
</dd>
<dt><code>parser</code></dt><dd><p>Character. If <code>"new"</code> (the default), the new
parser is used to parse the model syntax. If <code>"old"</code>, the original
(pre 0.6-18) parser is used.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+lavaan">lavaan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lavOptions()
lavOptions("std.lv")
lavOptions(c("std.lv", "orthogonal"))
</code></pre>

<hr>
<h2 id='lavPredict'>Predict the values of latent variables (and their indicators).</h2><span id='topic+lavPredict'></span><span id='topic+lavpredict'></span>

<h3>Description</h3>

<p>The main purpose of the <code>lavPredict()</code> function is to compute (or
&lsquo;predict&rsquo;) estimated values for the latent variables in the model
(&lsquo;factor scores&rsquo;). NOTE: the goal of this
function is NOT to predict future values of dependent variables as in the
regression framework! (For models with only continuous observed variables, the function <code>lavPredictY()</code> supports this.)</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavPredict(object, newdata = NULL, type = "lv", method = "EBM",
           transform = FALSE, se = "none", acov = "none", 
           label = TRUE, fsm = FALSE, mdist = FALSE, rel = FALSE,
           append.data = FALSE, assemble = FALSE,
           level = 1L, optim.method = "bfgs", ETA = NULL,
           drop.list.single.group = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lavPredict_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+lavaan-class">lavaan</a></code>.</p>
</td></tr>
<tr><td><code id="lavPredict_+3A_newdata">newdata</code></td>
<td>
<p>An optional data.frame, containing the same variables as
the data.frame used when fitting the model in object.</p>
</td></tr>
<tr><td><code id="lavPredict_+3A_type">type</code></td>
<td>
<p>A character string. If <code>"lv"</code>, estimated values for the latent
variables in the model are computed. If <code>"ov"</code>, model predicted values for
the indicators of the latent variables in the model are computed. If
<code>"yhat"</code>, the estimated value for the observed indicators, given
user-specified values for the latent variables provided by de <code>ETA</code>
argument.  If <code>"fy"</code>, densities (or probabilities) for each observed
indicator, given user-specified values for the latent variables provided by de
<code>ETA</code> argument.</p>
</td></tr>
<tr><td><code id="lavPredict_+3A_method">method</code></td>
<td>
<p>A character string. In the linear case (when the indicators are
continuous), the possible options are <code>"regression"</code> or <code>"Bartlett"</code>.
In the categorical case, the two options are <code>"EBM"</code> for
the Empirical Bayes Modal approach, and <code>"ML"</code> for the maximum
likelihood approach.</p>
</td></tr>
<tr><td><code id="lavPredict_+3A_transform">transform</code></td>
<td>
<p>Logical. If <code>TRUE</code>, transform the factor scores (per
group) so that their mean and variance-covariance matrix matches the
model-implied mean and variance-covariance matrix. This may be useful if the
individual factor scores will be used in a follow-up (regression) analysis.
Note: the standard errors (if requested) and the factor score matrix (if
requested) are not transformed (yet).</p>
</td></tr>
<tr><td><code id="lavPredict_+3A_se">se</code></td>
<td>
<p>Character. If <code>"none"</code>, no standard errors are computed.
If <code>"standard"</code>, naive standard errors are computed (assuming the
parameters of the measurement model are known). The standard errors are
returned as an attribute. Currently only available for complete continuous
data.</p>
</td></tr>
<tr><td><code id="lavPredict_+3A_acov">acov</code></td>
<td>
<p>Similar to the <code>"se"</code> argument, but optionally returns the full
sampling covariance matrix of factor scores as an attribute. Currently 
only available for complete continuous data.</p>
</td></tr>
<tr><td><code id="lavPredict_+3A_label">label</code></td>
<td>
<p>Logical. If TRUE, the columns in the output are labeled.</p>
</td></tr>
<tr><td><code id="lavPredict_+3A_fsm">fsm</code></td>
<td>
<p>Logical. If TRUE, return the factor score matrix as an attribute.
Only for numeric data.</p>
</td></tr>
<tr><td><code id="lavPredict_+3A_mdist">mdist</code></td>
<td>
<p>Logical. If TRUE, the (squared)
Mahalanobis distances of the factor scores (if <code>type = "lv"</code>) or
the casewise residuals (if <code>type = "resid"</code>) are returned as an 
attribute.</p>
</td></tr>
<tr><td><code id="lavPredict_+3A_rel">rel</code></td>
<td>
<p>Logical. Only used if <code>type = "lv"</code>. If TRUE,
the factor reliabilities are returned as an attribute. (The squared
values are often called the factor determinacies.)</p>
</td></tr>
<tr><td><code id="lavPredict_+3A_append.data">append.data</code></td>
<td>
<p>Logical. Only used when <code>type = "lv"</code>. If TRUE, 
the original data (or the data provided
in the newdata argument) is appended to the factor scores.</p>
</td></tr>
<tr><td><code id="lavPredict_+3A_assemble">assemble</code></td>
<td>
<p>Logical. If TRUE, 
the separate multiple groups are reassembled again to form a single data.frame
with a group column, having the same dimensions are the original (or
newdata) dataset.</p>
</td></tr>
<tr><td><code id="lavPredict_+3A_level">level</code></td>
<td>
<p>Integer. Only used in a multilevel SEM.
If <code>level = 1</code>, only factor scores for latent variable
defined at the first (within) level are computed; if <code>level = 2</code>,
only factor scores for latent variables defined at the second (between) level
are computed.</p>
</td></tr>
<tr><td><code id="lavPredict_+3A_optim.method">optim.method</code></td>
<td>
<p>Character string. Only used in the categorical case.
If <code>"nlminb"</code> (the default in 0.5), the <code>"nlminb()"</code> function is used
for the optimization. If <code>"bfgs"</code> or <code>"BFGS"</code> (the default in 0.6),
the <code>"optim()"</code> function is used with the BFGS method.</p>
</td></tr>
<tr><td><code id="lavPredict_+3A_eta">ETA</code></td>
<td>
<p>An optional matrix or list, containing latent variable values
for each observation. Used for computations when <code>type = "ov"</code>.</p>
</td></tr>
<tr><td><code id="lavPredict_+3A_drop.list.single.group">drop.list.single.group</code></td>
<td>
<p>Logical. If <code>FALSE</code>, the results are 
returned as
a list, where each element corresponds to a group (even if there is only
a single group). If <code>TRUE</code>, the list will be unlisted if there is
only a single group.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>predict()</code> function calls the <code>lavPredict()</code> function
with its default options.
</p>
<p>If there are no latent variables in the model, <code>type = "ov"</code> will
simply return the values of the observed variables. Note that this function
can not be used to &lsquo;predict&rsquo; values of dependent variables, given the
values of independent values (in the regression sense). In other words,
the structural component is completely ignored (for now).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lavPredictY">lavPredictY</a></code> to predict y-variables given x-variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HolzingerSwineford1939)

## fit model
HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- cfa(HS.model, data = HolzingerSwineford1939)
head(lavPredict(fit))
head(lavPredict(fit, type = "ov"))


## ------------------------------------------
## merge factor scores to original data.frame
## ------------------------------------------

idx &lt;- lavInspect(fit, "case.idx")
fscores &lt;- lavPredict(fit)
## loop over factors
for (fs in colnames(fscores)) {
  HolzingerSwineford1939[idx, fs] &lt;- fscores[ , fs]
}
head(HolzingerSwineford1939)


## multigroup models return a list of factor scores (one per group)
data(HolzingerSwineford1939)
mgfit &lt;- update(fit, group = "school", group.equal = c("loadings","intercepts"))

idx &lt;- lavInspect(mgfit, "case.idx") # list: 1 vector per group
fscores &lt;- lavPredict(mgfit)         # list: 1 matrix per group
## loop over groups and factors
for (g in seq_along(fscores)) {
  for (fs in colnames(fscores[[g]])) {
    HolzingerSwineford1939[ idx[[g]], fs] &lt;- fscores[[g]][ , fs]
  }
}
head(HolzingerSwineford1939)

## -------------------------------------
## Use factor scores in susequent models
## -------------------------------------

## see Examples in semTools package: ?plausibleValues
</code></pre>

<hr>
<h2 id='lavPredictY'>Predict the values of y-variables given the values of x-variables</h2><span id='topic+lavPredictY'></span>

<h3>Description</h3>

<p>This function can be used to predict the values of (observed) y-variables
given the values of (observed) x-variables in a structural equation model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavPredictY(object, newdata = NULL, 
            ynames = lavNames(object, "ov.y"),
            xnames = lavNames(object, "ov.x"), 
            method = "conditional.mean",
            label = TRUE, assemble = TRUE,
            force.zero.mean = FALSE,
            lambda = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lavPredictY_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+lavaan-class">lavaan</a></code>.</p>
</td></tr>
<tr><td><code id="lavPredictY_+3A_newdata">newdata</code></td>
<td>
<p>An optional data.frame, containing the same variables as
the data.frame that was used when fitting the model in <code>object</code>. 
This data.frame should also include
the y-variables (although their values will be ignored).
Note that if no meanstructure was used in the original fit, we will
use the saturated sample means of the original fit as substitutes for the
model-implied means. Alternatively, refit the model using <code>meanstructure = TRUE</code>.</p>
</td></tr>
<tr><td><code id="lavPredictY_+3A_ynames">ynames</code></td>
<td>
<p>The names of the observed variables that should be treated as the
y-variables. It is for these variables that the function will predict 
the (model-based) values for each observation. Can also be a list to allow 
for a separate set of variable names per group (or block).</p>
</td></tr>
<tr><td><code id="lavPredictY_+3A_xnames">xnames</code></td>
<td>
<p>The names of the observed variables that should be treated as the
x-variables. Can also be a list to allow 
for a separate set of variable names per group (or block).</p>
</td></tr>
<tr><td><code id="lavPredictY_+3A_method">method</code></td>
<td>
<p>A character string. The only available option for now is
<code>"conditional.mean"</code>. See Details.</p>
</td></tr>
<tr><td><code id="lavPredictY_+3A_label">label</code></td>
<td>
<p>Logical. If TRUE, the columns of the output are labeled.</p>
</td></tr>
<tr><td><code id="lavPredictY_+3A_assemble">assemble</code></td>
<td>
<p>Logical. If TRUE, 
the predictions of the separate multiple groups in the output are 
reassembled again to form a single data.frame
with a group column, having the same dimensions as the original 
(or newdata) dataset.</p>
</td></tr>
<tr><td><code id="lavPredictY_+3A_force.zero.mean">force.zero.mean</code></td>
<td>
<p>Logical. Only relevant if there is no mean structure.
If <code>TRUE</code>, the (model-implied) mean vector is set to the zero vector.
If <code>FALSE</code>, the (model-implied) mean vector is set to the (unrestricted)
sample mean vector.</p>
</td></tr>
<tr><td><code id="lavPredictY_+3A_lambda">lambda</code></td>
<td>
<p>Numeric. A lambda regularization penalty term.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used for (SEM-based) out-of-sample predictions of
outcome (y) variables, given the values of predictor (x) variables. This
is in contrast to the <code>lavPredict()</code> function which (historically)
only &lsquo;predicts&rsquo; the (factor) scores for latent variables, ignoring the
structural part of the model.
</p>
<p>When <code>method = "conditional.mean"</code>, predictions (for y given x) 
are based on the (joint y and x) model-implied variance-covariance (Sigma) 
matrix and  mean vector (Mu), and the standard expression for the 
conditional mean of a multivariate normal distribution. Note that if the
model is saturated (and hence df = 0), the SEM-based predictions are identical
to ordinary least squares predictions.
</p>
<p>Lambda is a regularization penalty term to improve prediction accuracy that can
be determined using the <code>lavPredictY_cv</code> function.
</p>


<h3>References</h3>

<p>de Rooij, M., Karch, J.D., Fokkema, M., Bakk, Z., Pratiwi, B.C, and 
Kelderman, H. (2022) SEM-Based Out-of-Sample Predictions,
Structural Equation Modeling: A Multidisciplinary Journal.
DOI:10.1080/10705511.2022.2061494
</p>
<p>Molina, M. D., Molina, L., &amp; Zappaterra, M. W. (2024). Aspects of Higher
Consciousness: A Psychometric Validation and Analysis of a New Model of Mystical
Experience. <a href="https://doi.org/10.31219/osf.io/cgb6e">doi:10.31219/osf.io/cgb6e</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lavPredict">lavPredict</a></code> to compute scores for latent variables.
</p>
<p><code><a href="#topic+lavPredictY_cv">lavPredictY_cv</a></code> to determine an optimal lambda to increase
prediction accuracy.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- ' 
  # latent variable definitions
     ind60 =~ x1 + x2 + x3
     dem60 =~ y1 + a*y2 + b*y3 + c*y4 
     dem65 =~ y5 + a*y6 + b*y7 + c*y8
    
  # regressions
    dem60 ~ ind60
    dem65 ~ ind60 + dem60
    
  # residual correlations
    y1 ~~ y5
    y2 ~~ y4 + y6
    y3 ~~ y7
    y4 ~~ y8
    y6 ~~ y8
'
fit &lt;- sem(model, data = PoliticalDemocracy)

lavPredictY(fit, ynames = c("y5", "y6", "y7", "y8"),
                 xnames = c("x1", "x2", "x3", "y1", "y2", "y3", "y4"))
</code></pre>

<hr>
<h2 id='lavPredictY_cv'>Determine an optimal lambda penalty value through cross-validation</h2><span id='topic+lavPredictY_cv'></span>

<h3>Description</h3>

<p>This function can be used to determine an optimal lambda value for the
<code>lavPredictY</code> function. based on cross-validation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavPredictY_cv(object, data = NULL,
              xnames = lavNames(object, "ov.x"),
              ynames = lavNames(object, "ov.y"),
              n.folds = 10L,
              lambda.seq = seq(0, 1, 0.1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lavPredictY_cv_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+lavaan-class">lavaan</a></code>.</p>
</td></tr>
<tr><td><code id="lavPredictY_cv_+3A_data">data</code></td>
<td>
<p>A data.frame, containing the same variables as the data.frame that
was used when fitting the model in <code>object</code>.</p>
</td></tr> 
<tr><td><code id="lavPredictY_cv_+3A_xnames">xnames</code></td>
<td>
<p>The names of the observed variables that should be treated as the
x-variables. Can also be a list to allow for a separate set of variable names
per group (or block).</p>
</td></tr>
<tr><td><code id="lavPredictY_cv_+3A_ynames">ynames</code></td>
<td>
<p>The names of the observed variables that should be treated as the
y-variables. It is for these variables that the function will predict the
(model-based) values for each observation. Can also be a list to allow for a
separate set of variable names per group (or block).</p>
</td></tr>
<tr><td><code id="lavPredictY_cv_+3A_n.folds">n.folds</code></td>
<td>
<p>Integer. The number of folds to be used during
cross-validation.</p>
</td></tr>
<tr><td><code id="lavPredictY_cv_+3A_lambda.seq">lambda.seq</code></td>
<td>
<p>An R <code>seq()</code> containing the range of lambda penalty
values to be tested during cross-validation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to generate an optimal lambda value for
<code>lavPredictY</code> predictions to improve prediction accuracy.
</p>


<h3>References</h3>

<p>de Rooij, M., Karch, J.D., Fokkema, M., Bakk, Z., Pratiwi, B.C, and 
Kelderman, H. (2022) SEM-Based Out-of-Sample Predictions,
Structural Equation Modeling: A Multidisciplinary Journal.
DOI:10.1080/10705511.2022.2061494
</p>
<p>Molina, M. D., Molina, L., &amp; Zappaterra, M. W. (2024). Aspects of Higher
Consciousness: A Psychometric Validation and Analysis of a New Model of
Mystical Experience. <a href="https://doi.org/10.31219/osf.io/cgb6e">doi:10.31219/osf.io/cgb6e</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lavPredictY">lavPredictY</a></code> to predict the values of (observed) y-variables given
the values of (observed) x-variables in a structural equation model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>colnames(PoliticalDemocracy) &lt;- c("z1", "z2", "z3", "z4", 
                                  "y1", "y2", "y3", "y4", 
                                  "x1", "x2", "x3")

model &lt;- '
  # latent variable definitions
  ind60 =~ x1 + x2 + x3
  dem60 =~ z1 + z2 + z3 + z4
  dem65 =~ y1 + y2 + y3 + y4
  # regressions
  dem60 ~ ind60
  dem65 ~ ind60 + dem60
  # residual correlations
  z1 ~~ y1
  z2 ~~ z4 + y2
  z3 ~~ y3
  z4 ~~ y4
  y2 ~~ y4
'
fit &lt;- sem(model, data = PoliticalDemocracy, meanstructure = TRUE)

percent &lt;- 0.5
nobs &lt;- lavInspect(fit, "ntotal")
idx &lt;- sort(sample(x = nobs, size = floor(percent*nobs)))

xnames = c("z1", "z2", "z3", "z4", "x1", "x2", "x3")
ynames = c("y1", "y2", "y3", "y4")

reg.results &lt;- lavPredictY_cv(
    fit,
    PoliticalDemocracy[-idx, ],
    xnames = xnames,
    ynames = ynames,
    n.folds = 10L,
    lambda.seq = seq(from = .6, to = 2.5, by = .1)
)
lam &lt;- reg.results$lambda.min

lavPredictY(fit, newdata = PoliticalDemocracy[idx,],
                 ynames  = ynames,
                 xnames  = xnames,
                 lambda  = lam)
</code></pre>

<hr>
<h2 id='lavResiduals'>Residuals</h2><span id='topic+lavResiduals'></span><span id='topic+lavResidual'></span>

<h3>Description</h3>

<p>&lsquo;lavResiduals&rsquo; provides model residuals and standardized residuals from
a fitted lavaan object, as well as various summaries of these residuals.
</p>
<p>The &lsquo;residuals()&rsquo; (and &lsquo;resid()&rsquo;) methods are just shortcuts to
this function with a limited set of arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavResiduals(object, type = "cor.bentler", custom.rmr = NULL,
    se = FALSE, zstat = TRUE, summary = TRUE, h1.acov = "unstructured",
    add.type = TRUE, add.labels = TRUE, add.class = TRUE,
    drop.list.single.group = TRUE,
    maximum.number = length(res.vech), output = "list")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lavResiduals_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+lavaan-class">lavaan</a></code>.</p>
</td></tr>
<tr><td><code id="lavResiduals_+3A_type">type</code></td>
<td>
<p>Character.
If <code>type = "raw"</code>, this function returns the raw (= unscaled)
difference between the observed and the expected (model-implied) summary
statistics, as well as the standardized version of these residualds.
If <code>type = "cor"</code>, or <code>type = "cor.bollen"</code>, the observed and model
implied covariance matrices are first transformed to a correlation matrix
(using <code>cov2cor()</code>), before the residuals are computed.
If <code>type = "cor.bentler"</code>, both the observed and model implied covariance
matrices are rescaled by dividing the elements by the square roots of the
corresponding variances of the observed covariance matrix.</p>
</td></tr>
<tr><td><code id="lavResiduals_+3A_custom.rmr">custom.rmr</code></td>
<td>
<p><code>list</code>. Not used yet.</p>
</td></tr>
<tr><td><code id="lavResiduals_+3A_se">se</code></td>
<td>
<p>Logical. If <code>TRUE</code>, show the estimated standard errors
for the residuals.</p>
</td></tr>
<tr><td><code id="lavResiduals_+3A_zstat">zstat</code></td>
<td>
<p>Logical. If <code>TRUE</code>, show the standardized residuals, which
are the raw residuals divided by the corresponding (estimated) standard
errors.</p>
</td></tr>
<tr><td><code id="lavResiduals_+3A_summary">summary</code></td>
<td>
<p>Logical. If <code>TRUE</code>, show various summaries of the
(possibly scaled) residuals. When <code>type = "raw"</code>, we compute the
RMR. When <code>type = "cor.bentler"</code>,
we compute the SRMR. When <code>type = "cor.bollen"</code>, we compute the CRMR.
An unbiased version of these summaries is also computed, as well as a
standard error, a z-statistic and a p-value for the test of exact fit
based on these summaries.</p>
</td></tr>
<tr><td><code id="lavResiduals_+3A_h1.acov">h1.acov</code></td>
<td>
<p>Character. If <code>"unstructured"</code>, the observed summary
statistics are used as consistent estimates of the corresponding (unrestricted)
population statistics. If <code>"structured"</code>, the model-implied summary
statistics are used as consistent estimates of the corresponding (unrestricted)
population statistics. This affects the way the asymptotic variance matrix
of the summary statistics is computed.</p>
</td></tr>
<tr><td><code id="lavResiduals_+3A_add.type">add.type</code></td>
<td>
<p>Logical. If <code>TRUE</code>, show the type of residuals
in the output.</p>
</td></tr>
<tr><td><code id="lavResiduals_+3A_add.labels">add.labels</code></td>
<td>
<p>If <code>TRUE</code>, variable names are added to the vectors
and/or matrices.</p>
</td></tr>
<tr><td><code id="lavResiduals_+3A_add.class">add.class</code></td>
<td>
<p>If <code>TRUE</code>, vectors are given the &lsquo;lavaan.vector&rsquo;
class; matrices are given the &lsquo;lavaan.matrix&rsquo; class, and symmetric
matrices are given the &lsquo;lavaan.matrix.symmetric&rsquo; class.
This only affects the way they are printed on the screen.</p>
</td></tr>
<tr><td><code id="lavResiduals_+3A_drop.list.single.group">drop.list.single.group</code></td>
<td>
<p>If <code>FALSE</code>, the results are returned as
a list, where each element corresponds to a group (even if there is only
a single group). If <code>TRUE</code>, the list will be unlisted if there is
only a single group.</p>
</td></tr>
<tr><td><code id="lavResiduals_+3A_maximum.number">maximum.number</code></td>
<td>
<p>Integer. Only used if <code>output ="table"</code>. Show only
the first maximum.number rows of the data.frame.</p>
</td></tr>
<tr><td><code id="lavResiduals_+3A_output">output</code></td>
<td>
<p>Character. By default, <code>output = "list"</code>, and the output
is a list of elements. If <code>output = "table"</code>, only the residuals of
the variance-covariance matrix are shown in a data.frame, sorted from high 
(in absolute value) to low.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>drop.list.single.group = TRUE</code>, a list of (residualized) summary
statistics, including type, standardized residuals, and summaries. If
<code>drop.list.single.group = FALSE</code>, the list of summary statistics is nested
within a list for each group.
</p>


<h3>References</h3>

<p>Bentler, P.M. and Dijkstra, T. (1985). Efficient estimation via linearization
in structural models. In Krishnaiah, P.R. (Ed.),
<em>Multivariate analysis - VI</em>, (pp. 9&ndash;42). New York, NY: Elsevier.
</p>
<p>Ogasawara, H. (2001). Standard errors of fit indices using residuals in
structural equation modeling. <em>Psychometrika, 66</em>(3), 421&ndash;436.
doi:10.1007/BF02294443
</p>
<p>Maydeu-Olivares, A. (2017). Assessing the size of model misfit in structural
equation models. <em>Psychometrika, 82</em>(3), 533&ndash;558.
doi:10.1007/s11336-016-9552-7
</p>
<p>Standardized Residuals in M<em>plus</em>. Document retrieved from URL
http://www.statmodel.com/download/StandardizedResiduals.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- cfa(HS.model, data = HolzingerSwineford1939)
lavResiduals(fit)
</code></pre>

<hr>
<h2 id='lavTables'>lavaan frequency tables</h2><span id='topic+lavTables'></span>

<h3>Description</h3>

<p>Frequency tables for categorical variables and related statistics.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavTables(object, dimension = 2L, type = "cells", categorical = NULL,
    group = NULL, statistic = "default", G2.min = 3, X2.min = 3,
    p.value = FALSE, output = "data.frame", patternAsString = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lavTables_+3A_object">object</code></td>
<td>
<p>Either a <code>data.frame</code>, or an object of class 
<code><a href="#topic+lavaan-class">lavaan</a></code>.</p>
</td></tr>
<tr><td><code id="lavTables_+3A_dimension">dimension</code></td>
<td>
<p>Integer. If 0L, display all response patterns. If 1L, 
display one-dimensional (one-way) tables; if 2L, display two-dimensional 
(two-way or pairwise) tables. For the latter, we can change the information
per row: if <code>type = "cells"</code>, each row is a cell in a pairwise table;
if <code>type = "table"</code>, each row is a table.</p>
</td></tr>
<tr><td><code id="lavTables_+3A_type">type</code></td>
<td>
<p>If <code>"cells"</code>, display information for each cell in the
(one-way or two-way) table. If <code>"table"</code>, display information per table.
If <code>"pattern"</code>, display response patterns (implying 
<code>"dimension = 0L"</code>).</p>
</td></tr>
<tr><td><code id="lavTables_+3A_categorical">categorical</code></td>
<td>
<p>Only used if <code>object</code> is a <code>data.frame</code>. Specify
variables that need to be treated as categorical.</p>
</td></tr>
<tr><td><code id="lavTables_+3A_group">group</code></td>
<td>
<p>Only used if <code>object</code> is a <code>data.frame</code>. Specify
a grouping variable.</p>
</td></tr>
<tr><td><code id="lavTables_+3A_statistic">statistic</code></td>
<td>
<p>Either a character string, or a vector of character strings
requesting one or more statistics for each cell, pattern or table.  Always
available are <code>X2</code> and <code>G2</code> for the Pearson and LRT based
goodness-of-fit statistics. A distinction is made between the unrestricted and
restricted model. The statistics based on the former have an extension
<code>*.un</code>, as in <code>X2.un</code> and <code>G2.un</code>.  If object is a
<code>data.frame</code>, the unrestricted versions of the statistics are the only
ones available.  For one-way tables, additional statistics are the thresholds
(<code>th.un</code> and <code>th</code>). For two-way tables and <code>type = "table"</code>, the
following statistics are available: <code>X2</code>, <code>G2</code>, <code>cor</code>
(polychoric correlation), <code>RMSEA</code> and the corresponding unrestricted
versions (<code>X2.un</code> etc). Additional statistics are <code>G2.average</code>,
<code>G2.nlarge</code> and <code>G2.plarge</code> statistics based on the cell values 
<code>G2</code>:
<code>G2.average</code> is the average of the <code>G2</code> values in each cell of the
two-way table; <code>G2.nlarge</code> is the number of cells with a <code>G2</code> value
larger than <code>G2.min</code>, and <code>G2.plarge</code> is the proportion of cells with
a <code>G2</code> value larger than <code>G2.min</code>. A similar set of statistics based
on <code>X2</code> is also available. If <code>"default"</code>, the selection of
statistics (if any) depends on the <code>dim</code> and <code>type</code> arguments, and if
the object is a <code>data.frame</code> or a fitted lavaan object.</p>
</td></tr>
<tr><td><code id="lavTables_+3A_g2.min">G2.min</code></td>
<td>
<p>Numeric. All cells with a G2 statistic larger than this number
are considered &lsquo;large&rsquo;, as reflected in the (optional) <code>"G2.plarge"</code> and
<code>"G2.nlarge"</code> columns.</p>
</td></tr>
<tr><td><code id="lavTables_+3A_x2.min">X2.min</code></td>
<td>
<p>Numeric. All cells with a X2 statistic larger than this number
are considered &lsquo;large&rsquo;, as reflected in the (optional) <code>"X2.plarge"</code> and
<code>"X2.nlarge"</code> columns.</p>
</td></tr>
<tr><td><code id="lavTables_+3A_p.value">p.value</code></td>
<td>
<p>Logical. If <code>"TRUE"</code>, p-values are computed for 
requested statistics (eg G2 or X2) if possible.</p>
</td></tr>
<tr><td><code id="lavTables_+3A_output">output</code></td>
<td>
<p>If <code>"data.frame"</code>, the output is presented as a data.frame
where each row is either a cell, a table, or a response pattern, depending
on the <code>"type"</code> argument. If <code>"table"</code>, the output is presented
as a table (or matrix) or a list of tables. Only a single statistic can be
shown in this case, and if the <code>statistic</code> is empty, the observed 
frequencies are shown.</p>
</td></tr>
<tr><td><code id="lavTables_+3A_patternasstring">patternAsString</code></td>
<td>
<p>Logical. Only used for response patterns (dimension = 0L). If <code>"TRUE"</code>, response patterns are displayed as a compact string. 
If <code>"FALSE"</code>, as many columns as observed variables are displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>output = "data.frame"</code>, the output is presented as a data.frame
where each row is either a cell, a table, or a response pattern, depending on
the <code>"type"</code> argument.
If <code>output = "table"</code> (only for two-way tables),
a list of tables (if <code>type = "cells"</code>) where each list element 
corresponds to a pairwise table, or if <code>type = "table"</code>, a single table
(per group). In both cases, the table entries are determined by the
(single) <code>statistic</code> argument.
</p>


<h3>References</h3>

<p>Joreskog, K.G. &amp; Moustaki, I. (2001). Factor analysis of ordinal variables: A
comparison of three approaches. Multivariate Behavioral Research, 36, 347-387.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varTable">varTable</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>HS9 &lt;- HolzingerSwineford1939[,c("x1","x2","x3","x4","x5",
                                 "x6","x7","x8","x9")]
HSbinary &lt;- as.data.frame( lapply(HS9, cut, 2, labels=FALSE) )

# using the data only
lavTables(HSbinary, dim = 0L, categorical = names(HSbinary))
lavTables(HSbinary, dim = 1L, categorical = names(HSbinary), stat=c("th.un"))
lavTables(HSbinary, dim = 2L, categorical = names(HSbinary), type = "table")

# fit a model
HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- cfa(HS.model, data=HSbinary, ordered=names(HSbinary))


lavTables(fit, 1L)
lavTables(fit, 2L, type="cells")
lavTables(fit, 2L, type="table", stat=c("cor.un", "G2", "cor"))
lavTables(fit, 2L, type="table", output="table", stat="X2")
</code></pre>

<hr>
<h2 id='lavTablesFitCp'>Pairwise maximum likelihood fit statistics</h2><span id='topic+lavTablesFit'></span><span id='topic+lavTablesFitCp'></span><span id='topic+lavTablesFitCf'></span><span id='topic+lavTablesFitCm'></span>

<h3>Description</h3>

<p>Three measures of fit for the pairwise maximum likelihood estimation method that are based on likelihood ratios (LR) are defined: 
<code class="reqn">C_F</code>, <code class="reqn">C_M</code>, and <code class="reqn">C_P</code>. Subscript <code class="reqn">F</code> signifies a comparison of model-implied proportions of full response 
patterns with observed sample proportions, subscript <code class="reqn">M</code> signifies a comparison of model-implied proportions of full response 
patterns with the proportions implied by the assumption of multivariate normality, and subscript <code class="reqn">P</code> signifies
a comparison of model-implied proportions of pairs of item responses with the observed proportions of pairs of item responses. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavTablesFitCf(object)
lavTablesFitCp(object, alpha = 0.05)
lavTablesFitCm(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lavTablesFitCp_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+lavaan-class">lavaan</a></code>.</p>
</td></tr>
<tr><td><code id="lavTablesFitCp_+3A_alpha">alpha</code></td>
<td>
<p>The nominal level of signifiance of global fit.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4><code class="reqn">C_F</code></h4>

<p>The <code class="reqn">C_F</code> statistic compares the log-likelihood of the model-implied proportions (<code class="reqn">\pi_r</code>) with the observed proportions (<code class="reqn">p_r</code>)
of the full multivariate responses patterns:
</p>
<p style="text-align: center;"><code class="reqn">
C_F = 2N\sum_{r}p_{r}\ln[p_{r}/\hat{\pi}_{r}],
</code>
</p>

<p>which asymptotically has a chi-square distribution with
</p>
<p style="text-align: center;"><code class="reqn">
df_F = m^k - n - 1,
</code>
</p>

<p>where <code class="reqn">k</code> denotes the number of items with discrete response scales, <code class="reqn">m</code> denotes the number of response options, and <code class="reqn">n</code> denotes 
the number of parameters to be estimated. Notice that <code class="reqn">C_F</code> results may be biased because of large numbers of empty cells in the multivariate 
contingency table.
</p>



<h4><code class="reqn">C_M</code></h4>

<p>The <code class="reqn">C_M</code> statistic is based on the <code class="reqn">C_F</code> statistic, and compares the proportions implied by the model of interest (Model 1) 
with proportions implied by the assumption of an underlying multivariate normal distribution (Model 0):
</p>
<p style="text-align: center;"><code class="reqn">
C_M = C_{F1} - C_{F0},
</code>
</p>

<p>where <code class="reqn">C_{F0}</code> is <code class="reqn">C_F</code> for Model 0 and <code class="reqn">C_{F1}</code> is <code class="reqn">C_F</code> for Model 1. Statistic <code class="reqn">C_M</code> has a chi-square distribution with 
degrees of freedom
</p>
<p style="text-align: center;"><code class="reqn">
df_M = k(k-1)/2 + k(m-1) - n_{1},
</code>
</p>

<p>where <code class="reqn">k</code> denotes the number of items with discrete response scales, <code class="reqn">m</code> denotes the number of response options, and <code class="reqn">k(k-1)/2</code> 
denotes the number of polychoric correlations, <code class="reqn">k(m-1)</code> denotes the number of thresholds, and <code class="reqn">n_1</code> is the number of parameters of the 
model of interest. Notice that <code class="reqn">C_M</code>  results may be biased because of large numbers of empty cells in the multivariate contingency table. However, 
bias may cancels out as both Model 1 and Model 0 contain the same pattern of empty responses.
</p>



<h4><code class="reqn">C_P</code></h4>

<p>With the <code class="reqn">C_P</code> statistic we only consider pairs of responses, and compare observed sample proportions (<code class="reqn">p</code>) with model-implied proportions 
of pairs of responses(<code class="reqn">\pi</code>). For items <code class="reqn">i</code> and <code class="reqn">j</code> we obtain a pairwise likelihood ratio test statistic <code class="reqn">C_{P_{ij}}</code>
</p>
<p style="text-align: center;"><code class="reqn">
C_{P_{ij}}=2N\sum_{c_i=1}^m \sum_{c_j=1}^m
p_{c_i,c_j}\ln[p_{c_i,c_j}/\hat{\pi}_{c_i,c_j}],
</code>
</p>

<p>where <code class="reqn">m</code> denotes the number of response options and <code class="reqn">N</code> denotes sample size. The <code class="reqn">C_P</code> statistic has an asymptotic chi-square distribution 
with degrees of freedom equal to the information <code class="reqn">(m^2 -1)</code> minus the number of parameters (2(m-1) thresholds and 1 correlation),
</p>
<p style="text-align: center;"><code class="reqn">
df_P = m^{2} - 2(m - 1) - 2.
</code>
</p>

<p>As <code class="reqn">k</code> denotes the number of items, there are <code class="reqn">k(k-1)/2</code> possible pairs of items. The <code class="reqn">C_P</code> statistic should therefore be applied with 
a Bonferroni adjusted level of significance <code class="reqn">\alpha^*</code>, with
</p>
<p style="text-align: center;"><code class="reqn">
\alpha^*= \alpha /(k(k-1)/2)),
</code>
</p>

<p>to keep the family-wise error rate at <code class="reqn">\alpha</code>. The hypothesis of overall goodness-of-fit is tested at <code class="reqn">\alpha</code> and rejected as 
soon as <code class="reqn">C_P</code> is significant at <code class="reqn">\alpha^*</code> for at least one pair of items. Notice that with dichotomous items, <code class="reqn">m = 2</code>, 
and <code class="reqn">df_P = 0</code>, so that hypothesis can not be tested. 
</p>



<h3>References</h3>

<p>Barendse, M. T., Ligtvoet, R., Timmerman, M. E., &amp; Oort, F. J. (2016). Structural Equation Modeling of Discrete data: 
Model Fit after Pairwise Maximum Likelihood. <em>Frontiers in psychology, 7</em>, 1-8. 
</p>
<p>Joreskog, K. G., &amp; Moustaki, I. (2001). Factor analysis of ordinal variables: A comparison of three approaches. 
<em>Multivariate Behavioral Research, 36</em>, 347-387. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lavTables">lavTables</a>, <a href="#topic+lavaan">lavaan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data
HS9 &lt;- HolzingerSwineford1939[,c("x1","x2","x3","x4","x5",
                                 "x6","x7","x8","x9")]
HSbinary &lt;- as.data.frame( lapply(HS9, cut, 2, labels=FALSE) )

# Single group example with one latent factor
HS.model &lt;- ' trait =~ x1 + x2 + x3 + x4 '
fit &lt;- cfa(HS.model, data=HSbinary[,1:4], ordered=names(HSbinary[,1:4]),
           estimator="PML")
lavTablesFitCm(fit)
lavTablesFitCp(fit)
lavTablesFitCf(fit)
</code></pre>

<hr>
<h2 id='lavTest'>Test of exact fit</h2><span id='topic+lavTest'></span><span id='topic+lavtest'></span>

<h3>Description</h3>

<p>Compute a variety of test statistics evaluating the global fit of
the model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>    lavTest(lavobject, test = "standard", scaled.test = "standard",
            output = "list", drop.list.single = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lavTest_+3A_lavobject">lavobject</code></td>
<td>
<p>An object of class <code><a href="#topic+lavaan-class">lavaan</a></code>.</p>
</td></tr>
<tr><td><code id="lavTest_+3A_test">test</code></td>
<td>
<p>Character vector. Multiple names of test statistics can be provided.
If <code>"standard"</code> is included, a conventional chi-square test
is computed. If <code>"Browne.residual.adf"</code> is included,
Browne's residual-based test statistic using ADF theory is computed.
If <code>"Browne.residual.nt"</code> is included, Browne's residual-based
test statistic using normal theory is computed.
If <code>"Satorra.Bentler"</code> is included, a Satorra-Bentler scaled test
statistic is computed. If <code>"Yuan.Bentler"</code> is included, 
a Yuan-Bentler scaled test statistic is computed. 
If <code>"Yuan.Bentler.Mplus"</code> is included, a
test statistic is computed that is asymptotically equal to the
Yuan-Bentler scaled test statistic. If <code>"mean.var.adjusted"</code> or
<code>"Satterthwaite"</code> is included, a mean and variance adjusted test 
statistic is computed. If <code>"scaled.shifted"</code> is included, 
an alternative mean and variance adjusted test statistic is 
computed (as in Mplus version 6 or higher).
If <code>"boot"</code> or <code>"bootstrap"</code> or <code>"Bollen.Stine"</code> is 
included, the
Bollen-Stine bootstrap is used to compute the bootstrap probability value
of the (regular) test statistic.</p>
</td></tr>
<tr><td><code id="lavTest_+3A_scaled.test">scaled.test</code></td>
<td>
<p>Character. Choose the test statistic 
that will be scaled (if a scaled test statistic is requested). 
The default is <code>"standard"</code>, but it could also be (for example)
<code>"Browne.residual.nt"</code>.</p>
</td></tr>
<tr><td><code id="lavTest_+3A_output">output</code></td>
<td>
<p>Character. If <code>"list"</code> (the default), return a list with
all test statistics. If <code>"text"</code>, display the output as text with 
verbose descriptions (as in the summary output). If any scaled
test statistics are included, they are printed first in a two-column
format. Next come the other test statistics in a one-column format.</p>
</td></tr>
<tr><td><code id="lavTest_+3A_drop.list.single">drop.list.single</code></td>
<td>
<p>Logical. Only used when <code>output = "list"</code>.
If <code>TRUE</code> and the list is of length one (i.e. only a single test 
statistic), drop the outer list. If <code>FALSE</code>, return a nested list 
with as many elements as we have test statistics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>output = "list"</code>: a nested list with test statistics, or if
only a single test statistic is requested (and 
<code>drop.list.single = TRUE</code>), a list with details for this test
statistic. If <code>output = "text"</code>: the text is printed, and a
nested list of test statistics (including an info attribute) is
returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HS.model &lt;- '
    visual  =~ x1 + x2 + x3
    textual =~ x4 + x5 + x6
    speed   =~ x7 + x8 + x9
'
fit &lt;- cfa(HS.model, data = HolzingerSwineford1939)
lavTest(fit, test = "browne.residual.adf")
</code></pre>

<hr>
<h2 id='lavTestLRT'>LRT test</h2><span id='topic+lavTestLRT'></span><span id='topic+lavtestLRT'></span><span id='topic+LRT'></span><span id='topic+lavLRTTest'></span><span id='topic+lavLRT'></span><span id='topic+anova'></span>

<h3>Description</h3>

<p>LRT test for comparing (nested) lavaan models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavTestLRT(object, ..., method = "default", test = "default",
           A.method = "delta", scaled.shifted = TRUE,
           type = "Chisq", model.names = NULL)
anova(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lavTestLRT_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+lavaan-class">lavaan</a></code>.</p>
</td></tr>
<tr><td><code id="lavTestLRT_+3A_...">...</code></td>
<td>
<p>additional objects of class <code><a href="#topic+lavaan-class">lavaan</a></code>.</p>
</td></tr>
<tr><td><code id="lavTestLRT_+3A_method">method</code></td>
<td>
<p>Character string. The possible options are 
<code>"satorra.bentler.2001"</code>, <code>"satorra.bentler.2010"</code>,
<code>"satorra.2000"</code>, and <code>"standard"</code>. See details.</p>
</td></tr>
<tr><td><code id="lavTestLRT_+3A_test">test</code></td>
<td>
<p>Character string specifying which scaled test statistics to use,
in case multiple scaled <code>test=</code> options were requested when fitting the
model(s). See details.</p>
</td></tr>
<tr><td><code id="lavTestLRT_+3A_a.method">A.method</code></td>
<td>
<p>Character string. The possible options are <code>"exact"</code>
and <code>"delta"</code>. This is only used when method = <code>"satorra.2000"</code>.
It determines how the Jacobian of the constraint function (the matrix A)
will be computed. Note that if <code>A.method = "exact"</code>, the models must
be nested in the parameter sense, while if <code>A.method = "delta"</code>, they
only need to be nested in the covariance matrix sense.</p>
</td></tr>
<tr><td><code id="lavTestLRT_+3A_scaled.shifted">scaled.shifted</code></td>
<td>
<p>Logical. Only used when method = <code>"satorra.2000"</code>.
If <code>TRUE</code>, we use a scaled and shifted test statistic; if <code>FALSE</code>,
we use a mean and variance adjusted (Satterthwaite style) test statistic.</p>
</td></tr>
<tr><td><code id="lavTestLRT_+3A_type">type</code></td>
<td>
<p>Character. If <code>"Chisq"</code>, the test statistic for each
model is the (scaled or unscaled) model fit test statistic. If <code>"Cf"</code>, 
the test statistic for each model is computed by the 
<code><a href="#topic+lavTablesFitCf">lavTablesFitCf</a></code> function. If <code>"browne.residual.adf"</code> (alias
<code>"browne"</code>) or <code>"browne.residual.nt"</code>, the standard chi-squared
difference is calculated from each model's residual-based statistic.</p>
</td></tr>
<tr><td><code id="lavTestLRT_+3A_model.names">model.names</code></td>
<td>
<p>Character vector. If provided, use these model names in
the first column of the anova table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>anova</code> function for lavaan objects simply calls the
<code>lavTestLRT</code> function, which has a few additional arguments.
</p>
<p>The only <code>test=</code> options that currently have actual consequences are 
<code>"satorra.bentler"</code>, <code>"yuan.bentler"</code>, or <code>"yuan.bentler.mplus"</code>
because <code>"mean.var.adjusted"</code> and <code>"scaled.shifted"</code> are
currently distinguished by the <code>scaled.shifted</code> argument.
See <code><a href="#topic+lavOptions">lavOptions</a></code> for details about <code>test=</code> options
implied by robust <code>estimator=</code> options). The <code>"default"</code> is to
select the first available scaled statistic, if any. To check which test(s)
were calculated when fitting your model(s), use 
<code>lavInspect(fit, "options")$test</code>.
</p>
<p>If <code>type = "Chisq"</code> and the test statistics are scaled, a
special scaled difference test statistic is computed. If <code>method</code> is
<code>"satorra.bentler.2001"</code>, a simple approximation is used
described in Satorra &amp; Bentler (2001). In some settings,
this can lead to a negative test statistic. To ensure a positive
test statistic, we can use the method proposed by 
Satorra &amp; Bentler (2010). Alternatively, when <code>method="satorra.2000"</code>,
the original formulas of Satorra (2000) are used.  The latter is used for
model comparison, when <code>...</code> contain additional (nested) models.
Even when test statistics are scaled in <code>object</code> or <code>...</code>,
users may request the  <code>method="standard"</code> test statistic,
without a robust adjustment.
</p>


<h3>Value</h3>

<p>An object of class anova. When given a single argument, it simply 
returns the test statistic of this model. When given a sequence of 
objects, this function tests the models against one another, after
reordering the models according to their degrees of freedom.
</p>


<h3>Note</h3>

<p>If there is a <code><a href="#topic+lavaan-class">lavaan</a></code> model stored in 
<code>object@external$h1.model</code>, it will be added to <code>...</code>
</p>


<h3>References</h3>

<p>Satorra, A. (2000). Scaled and adjusted restricted tests in multi-sample
analysis of moment structures. In Heijmans, R.D.H., Pollock, D.S.G. &amp; Satorra,
A. (eds.), <em>Innovations in multivariate statistical analysis</em>:
<em>A Festschrift for Heinz Neudecker</em> (pp.233-247). 
London, UK: Kluwer Academic Publishers.     
</p>
<p>Satorra, A., &amp; Bentler, P. M. (2001). A scaled difference chi-square test
statistic for moment structure analysis. <em>Psychometrika, 66</em>(4), 507-514.
<a href="https://doi.org/10.1007/BF02296192">doi:10.1007/BF02296192</a>
</p>
<p>Satorra, A., &amp; Bentler, P. M. (2010). Ensuring postiveness of the scaled
difference chi-square test statistic. <em>Psychometrika, 75</em>(2), 243-248.
<a href="https://doi.org/10.1007/s11336-009-9135-y">doi:10.1007/s11336-009-9135-y</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HS.model &lt;- '
    visual  =~ x1 + b1*x2 + x3
    textual =~ x4 + b2*x5 + x6
    speed   =~ x7 + b3*x8 + x9
'
fit1 &lt;- cfa(HS.model, data = HolzingerSwineford1939)
fit0 &lt;- cfa(HS.model, data = HolzingerSwineford1939, 
            orthogonal = TRUE)
lavTestLRT(fit1, fit0)


## When multiple test statistics are selected when the model is fitted,
## use the type= and test= arguments to select a test for comparison.

## refit models, requesting 6 test statistics (in addition to "standard")
t6.1 &lt;- cfa(HS.model, data = HolzingerSwineford1939,
            test = c("browne.residual.adf","scaled.shifted","mean.var.adjusted",
                     "satorra.bentler", "yuan.bentler", "yuan.bentler.mplus"))
t6.0 &lt;- cfa(HS.model, data = HolzingerSwineford1939, orthogonal = TRUE,
            test = c("browne.residual.adf","scaled.shifted","mean.var.adjusted",
                     "satorra.bentler", "yuan.bentler", "yuan.bentler.mplus"))

## By default (test="default", type="Chisq"), the first scaled statistic
## requested will be used. Here, that is "scaled.shifted"
lavTestLRT(t6.1, t6.0)
## But even if "satorra.bentler" were requested first, method="satorra.2000"
## provides the scaled-shifted chi-squared difference test:
lavTestLRT(t6.1, t6.0, method = "satorra.2000")
## == lavTestLRT(update(t6.1, test = "scaled.shifted"), update(t6.0, test = "scaled.shifted"))

## The mean- and variance-adjusted (Satterthwaite) statistic implies
## scaled.shifted = FALSE
lavTestLRT(t6.1, t6.0, method = "satorra.2000", scaled.shifted = FALSE)

## Because "satorra.bentler" is not the first scaled test in the list,
## we MUST request it explicitly:
lavTestLRT(t6.1, t6.0, test = "satorra.bentler") # method="satorra.bentler.2001"
## == lavTestLRT(update(t6.1, test = "satorra.bentler"),
##               update(t6.0, test = "satorra.bentler"))
## The "strictly-positive test" is necessary when the above test is &lt; 0:
lavTestLRT(t6.1, t6.0, test = "satorra.bentler", method = "satorra.bentler.2010")

## Likewise, other scaled statistics can be selected:
lavTestLRT(t6.1, t6.0, test = "yuan.bentler")
## == lavTestLRT(update(t6.1, test = "yuan.bentler"),
##               update(t6.0, test = "yuan.bentler"))
lavTestLRT(t6.1, t6.0, test = "yuan.bentler.mplus")
## == lavTestLRT(update(t6.1, test = "yuan.bentler.mplus"),
##               update(t6.0, test = "yuan.bentler.mplus"))

## To request the difference between Browne's (1984) residual-based statistics,
## rather than statistics based on the fitted model's discrepancy function,
## use the type= argument:
lavTestLRT(t6.1, t6.0, type = "browne.residual.adf")

## Despite requesting multiple robust tests, it is still possible to obtain
## the standard chi-squared difference test (i.e., without a robust correction)
lavTestLRT(t6.1, t6.0, method = "standard")
## == lavTestLRT(update(t6.1, test = "standard"), update(t6.0, test = "standard"))

</code></pre>

<hr>
<h2 id='lavTestScore'>Score test</h2><span id='topic+lavTestScore'></span><span id='topic+lavtestscore'></span><span id='topic+score'></span><span id='topic+Score'></span><span id='topic+lavScoreTest'></span>

<h3>Description</h3>

<p>Score test (or Lagrange Multiplier test) for releasing one or more
fixed or constrained parameters in model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavTestScore(object, add = NULL, release = NULL,
             univariate = TRUE, cumulative = FALSE,
             epc = FALSE, standardized = epc, cov.std = epc,
             verbose = FALSE, warn = TRUE, information = "expected")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lavTestScore_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+lavaan-class">lavaan</a></code>.</p>
</td></tr>
<tr><td><code id="lavTestScore_+3A_add">add</code></td>
<td>
<p>Either a character string (typically between single quotes) or
a parameter table containing additional (currently fixed-to-zero) parameters
for which the score test must be computed.</p>
</td></tr>
<tr><td><code id="lavTestScore_+3A_release">release</code></td>
<td>
<p>Vector of Integers. The indices of the constraints that
should be released. The indices correspond to the order of the equality
constraints as they appear in the parameter table.</p>
</td></tr>
<tr><td><code id="lavTestScore_+3A_univariate">univariate</code></td>
<td>
<p>Logical. If <code>TRUE</code>, compute the univariate score
statistics, one for each constraints.</p>
</td></tr>
<tr><td><code id="lavTestScore_+3A_cumulative">cumulative</code></td>
<td>
<p>Logical. If <code>TRUE</code>, order the univariate score
statistics from large to small, and compute a series of
multivariate score statistics, each time adding an additional constraint.</p>
</td></tr>
<tr><td><code id="lavTestScore_+3A_epc">epc</code></td>
<td>
<p>Logical. If <code>TRUE</code>, and we are releasing existing constraints,
compute the expected parameter changes for the existing (free) parameters,
for each released constraint.</p>
</td></tr>
<tr><td><code id="lavTestScore_+3A_standardized">standardized</code></td>
<td>
<p>If <code>TRUE</code>, two extra columns (sepc.lv and sepc.all)
in the <code>$epc</code> table
will contain standardized values for the EPCs. In the first column (sepc.lv),
standardization is based on the variances of the (continuous) latent
variables. In the second column (sepc.all), standardization is based
on both the variances of both (continuous) observed and latent variables.
(Residual) covariances are standardized using (residual) variances.</p>
</td></tr>
<tr><td><code id="lavTestScore_+3A_cov.std">cov.std</code></td>
<td>
<p>Logical. See <code><a href="#topic+standardizedSolution">standardizedSolution</a></code>.</p>
</td></tr>
<tr><td><code id="lavTestScore_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Not used for now.</p>
</td></tr>
<tr><td><code id="lavTestScore_+3A_warn">warn</code></td>
<td>
<p>Logical. If <code>TRUE</code>, print out warnings if they occur.</p>
</td></tr>
<tr><td><code id="lavTestScore_+3A_information">information</code></td>
<td>
<p><code>character</code> indicating the type of information matrix
to use (check <code><a href="#topic+lavInspect">lavInspect</a></code> for available options). <code>"expected"</code>
information is the default, which provides better control of Type I errors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to compute both multivariate and univariate
score tests. There are two modes: 1) releasing fixed-to-zero parameters
(using the <code>add</code> argument), and 2) releasing existing equality
constraints (using the <code>release</code> argument). The two modes can not
be used simultaneously.
</p>
<p>When adding new parameters, they should not already be part of the model
(i.e. not listed in the parameter table). If you want to test for
a parameter that was explicitly fixed to a constant (say to zero),
it is better to label the parameter, and use an explicit equality
constraint.
</p>


<h3>Value</h3>

<p>A list containing at least one <code>data.frame</code>:
</p>

<ul>
<li><p><code>$test</code>: The total score test, with columns for the score
test statistic (<code>X2</code>), the degrees of freedom (<code>df</code>), and
a <em>p</em> value under the <code class="reqn">\chi^2</code> distribution (<code>p.value</code>).
</p>
</li>
<li><p><code>$uni</code>: Optional (if <code>univariate=TRUE</code>).
Each 1-<em>df</em> score test, equivalent to modification indices.
If <code>epc=TRUE</code> when <code>add</code>ing parameters (not when releasing
constraints), an unstandardized EPC is provided for each added parameter,
as would be returned by <code><a href="#topic+modificationIndices">modificationIndices</a></code>.
</p>
</li>
<li><p><code>$cumulative</code>: Optional (if <code>cumulative=TRUE</code>).
Cumulative score tests.
</p>
</li>
<li><p><code>$epc</code>: Optional (if <code>epc=TRUE</code>). Parameter estimates,
expected parameter changes, and expected parameter values if all
the tested constraints were freed.
</p>
</li></ul>



<h3>References</h3>

<p>Bentler, P. M., &amp; Chou, C. P. (1993). Some new covariance structure model
improvement statistics. Sage Focus Editions, 154, 235-255.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HS.model &lt;- '
    visual  =~ x1 + b1*x2 + x3
    textual =~ x4 + b2*x5 + x6
    speed   =~ x7 + b3*x8 + x9

    b1 == b2
    b2 == b3
'
fit &lt;- cfa(HS.model, data=HolzingerSwineford1939)

# test 1: release both two equality constraints
lavTestScore(fit, cumulative = TRUE)

# test 2: the score test for adding two (currently fixed
# to zero) cross-loadings
newpar = '
    visual =~ x9
    textual =~ x3
'
lavTestScore(fit, add = newpar)

# equivalently, "add" can be a parameter table specifying parameters to free,
# but must include some additional information:
PT.add &lt;- data.frame(lhs = c("visual","textual"),
                     op = c("=~","=~"),
                     rhs = c("x9","x3"),
                     user = 10L, # needed to identify new parameters
                     free = 1, # arbitrary numbers &gt; 0
                     start = 0) # null-hypothesized value
PT.add
lavTestScore(fit, add = PT.add) # same result as above

</code></pre>

<hr>
<h2 id='lavTestWald'>Wald test</h2><span id='topic+lavTestWald'></span><span id='topic+lavtestwald'></span><span id='topic+wald'></span><span id='topic+Wald'></span><span id='topic+lavWaldTest'></span>

<h3>Description</h3>

<p>Wald test for testing a linear hypothesis about the parameters of 
fitted lavaan object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavTestWald(object, constraints = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lavTestWald_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+lavaan-class">lavaan</a></code>.</p>
</td></tr>
<tr><td><code id="lavTestWald_+3A_constraints">constraints</code></td>
<td>
<p>A character string (typically between single quotes) 
containing one or more equality constraints. See examples for more details.</p>
</td></tr>
<tr><td><code id="lavTestWald_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, print out the restriction matrix
and the estimated restricted values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constraints are specified using the <code>"=="</code> operator. Both
the left-hand side and the right-hand side of the equality can contain
a linear combination of model parameters, or a constant (like zero).
The model parameters must be specified by their user-specified labels. 
Names of defined parameters (using the <code>":="</code> operator) can be 
included too.
</p>


<h3>Value</h3>

<p>A list containing three elements: the Wald test statistic (stat), the
degrees of freedom (df), and a p-value under the chi-square distribution
(p.value).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HS.model &lt;- '
    visual  =~ x1 + b1*x2 + x3
    textual =~ x4 + b2*x5 + x6
    speed   =~ x7 + b3*x8 + x9
'

fit &lt;- cfa(HS.model, data=HolzingerSwineford1939)

# test 1: test about a single parameter
# this is the 'chi-square' version of the 
# z-test from the summary() output
lavTestWald(fit, constraints = "b1 == 0")

# test 2: several constraints
con = '
   2*b1 == b3
   b2 - b3 == 0
'
lavTestWald(fit, constraints = con)
</code></pre>

<hr>
<h2 id='model.syntax'>The Lavaan Model Syntax</h2><span id='topic+model.syntax'></span><span id='topic+lavaanify'></span><span id='topic+lavParTable'></span><span id='topic+lavpartable'></span><span id='topic+lavPartable'></span><span id='topic+parseModelString'></span><span id='topic+lavParseModelString'></span>

<h3>Description</h3>

<p>The lavaan model syntax describes a latent variable model. The 
function <code>lavaanify</code> turns it into a table that represents the full
model as specified by the user. We refer to this table as the parameter table.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavaanify(model = NULL, meanstructure = FALSE, int.ov.free = FALSE, 
    int.lv.free = FALSE, marker.int.zero = FALSE,
    orthogonal = FALSE, orthogonal.y = FALSE,
    orthogonal.x = FALSE, orthogonal.efa = FALSE, std.lv = FALSE,
    correlation = FALSE, effect.coding = "", conditional.x = FALSE, 
    fixed.x = FALSE, parameterization = "delta", constraints = NULL, 
    ceq.simple = FALSE, auto = FALSE, model.type = "sem", 
    auto.fix.first = FALSE, auto.fix.single = FALSE, auto.var = FALSE, 
    auto.cov.lv.x = FALSE, auto.cov.y = FALSE, auto.th = FALSE, 
    auto.delta = FALSE, auto.efa = FALSE, 
    varTable = NULL, ngroups = 1L, nthresholds = NULL, 
    group.equal = NULL, group.partial = NULL, group.w.free = FALSE,
    debug = FALSE, warn = TRUE, as.data.frame. = TRUE)

lavParTable(model = NULL, meanstructure = FALSE, int.ov.free = FALSE,
    int.lv.free = FALSE, marker.int.zero = FALSE,
    orthogonal = FALSE, orthogonal.y = FALSE, 
    orthogonal.x = FALSE, orthogonal.efa = FALSE, std.lv = FALSE,
    correlation = FALSE, effect.coding = "", conditional.x = FALSE, 
    fixed.x = FALSE, parameterization = "delta", constraints = NULL, 
    ceq.simple = FALSE, auto = FALSE, model.type = "sem",
    auto.fix.first = FALSE, auto.fix.single = FALSE, auto.var = FALSE,
    auto.cov.lv.x = FALSE, auto.cov.y = FALSE, auto.th = FALSE,
    auto.delta = FALSE, auto.efa = FALSE,
    varTable = NULL, ngroups = 1L, nthresholds = NULL,
    group.equal = NULL, group.partial = NULL, group.w.free = FALSE,
    debug = FALSE, warn = TRUE, as.data.frame. = TRUE)

lavParseModelString(model.syntax = '', as.data.frame. = FALSE,
                    parser = "new", warn = TRUE, debug = FALSE)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model.syntax_+3A_model">model</code></td>
<td>
<p>A description of the user-specified model. Typically, the model
is described using the lavaan model syntax; see details for more 
information. Alternatively, a parameter table (e.g., the output of
<code>lavParseModelString</code> is also accepted.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_model.syntax">model.syntax</code></td>
<td>
<p>The model syntax specifying the model. Must be a literal
string.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_meanstructure">meanstructure</code></td>
<td>
<p>If <code>TRUE</code>, intercepts/means will be added to
the model both for both observed and latent variables.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_int.ov.free">int.ov.free</code></td>
<td>
<p>If <code>FALSE</code>, the intercepts of the observed variables
are fixed to zero.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_int.lv.free">int.lv.free</code></td>
<td>
<p>If <code>FALSE</code>, the intercepts of the latent variables
are fixed to zero.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_marker.int.zero">marker.int.zero</code></td>
<td>
<p>Logical. Only relevant if the metric of each latent
variable is set by fixing the first factor loading to unity.
If <code>TRUE</code>, it implies <code>meanstructure = TRUE</code> and 
<code>std.lv = FALSE</code>, and it fixes the intercepts of the marker
indicators to zero, while freeing the means/intercepts of the latent
variables. Only works correcly for single group, single level models.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_orthogonal">orthogonal</code></td>
<td>
<p>If <code>TRUE</code>, all covariances among
latent variables are set to zero.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_orthogonal.y">orthogonal.y</code></td>
<td>
<p>If <code>TRUE</code>, all covariances among
endogenous latent variables only are set to zero.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_orthogonal.x">orthogonal.x</code></td>
<td>
<p>If <code>TRUE</code>, all covariances among
exogenous latent variables only are set to zero.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_orthogonal.efa">orthogonal.efa</code></td>
<td>
<p>If <code>TRUE</code>, all covariances among
latent variables involved in rotation only are set to zero.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_std.lv">std.lv</code></td>
<td>
<p>If <code>TRUE</code>, the metric of each latent variable is
determined by fixing their variances to 1.0. If <code>FALSE</code>, the metric
of each latent variable is determined by fixing the factor loading of the
first indicator to 1.0. If there are multiple
groups, <code>std.lv = TRUE</code> and <code>"loadings"</code> is included in 
the <code>group.label</code> argument, then only the latent variances i
of the first group will be fixed to 1.0, while the latent
variances of other groups are set free.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_correlation">correlation</code></td>
<td>
<p>If <code>TRUE</code>, a correlation structure is fitted. For
continuous data, this implies that the (residual) variances are no
longer parameters of the model.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_effect.coding">effect.coding</code></td>
<td>
<p>Can be logical or character string. If
logical and <code>TRUE</code>, this implies     
<code>effect.coding = c("loadings", "intercepts")</code>. If logical and 
<code>FALSE</code>, it is set equal to the empty string. 
If <code>"loadings"</code> is included, equality
constraints are used so that the average of the factor loadings (per
latent variable) equals 1. Note that this should not be used 
together with <code>std.lv = TRUE</code>. If <code>"intercepts"</code> is
included, equality constraints are used so that the sum of the
intercepts (belonging to the indicators of a single latent variable)
equals zero.
As a result, the latent mean will be freely estimated and usually
equal the average of the means of the involved indicators.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_conditional.x">conditional.x</code></td>
<td>
<p>If <code>TRUE</code>, we set up the model conditional on
the exogenous &lsquo;x&rsquo; covariates; the model-implied sample statistics
only include the non-x variables. If <code>FALSE</code>, the exogenous &lsquo;x&rsquo;
variables are modeled jointly with the other variables, and the
model-implied statistics refect both sets of variables.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_fixed.x">fixed.x</code></td>
<td>
<p>If <code>TRUE</code>, the exogenous &lsquo;x&rsquo; covariates are considered
fixed variables and the means, variances and covariances of these variables
are fixed to their sample values. If <code>FALSE</code>, they are considered
random, and the means, variances and covariances are free parameters.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_parameterization">parameterization</code></td>
<td>
<p>Currently only used if data is categorical. If
<code>"delta"</code>, the delta parameterization is used. If <code>"theta"</code>,
the theta parameterization is used.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_constraints">constraints</code></td>
<td>
<p>Additional (in)equality constraints. See details for
more information.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_ceq.simple">ceq.simple</code></td>
<td>
<p>If <code>TRUE</code>, and no other general constraints are
used in the model, simple equality constraints are represented in the
parameter table as duplicated free parameters (instead of extra rows
with <code>op = "=="</code>).</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_auto">auto</code></td>
<td>
<p>If <code>TRUE</code>, the default values are used for the auto.*
arguments, depending on the value of <code>model.type</code>.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_model.type">model.type</code></td>
<td>
<p>Either <code>"sem"</code> or <code>"growth"</code>; only used if
<code>auto=TRUE</code>.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_auto.fix.first">auto.fix.first</code></td>
<td>
<p>If <code>TRUE</code>, the factor loading of the first indicator
is set to 1.0 for every latent variable.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_auto.fix.single">auto.fix.single</code></td>
<td>
<p>If <code>TRUE</code>, the residual variance (if included)
of an observed indicator is set to zero if it is the only indicator of a
latent variable.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_auto.var">auto.var</code></td>
<td>
<p>If <code>TRUE</code>, the (residual) variances of both observed
and latent variables are set free.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_auto.cov.lv.x">auto.cov.lv.x</code></td>
<td>
<p>If <code>TRUE</code>, the covariances of exogenous latent
variables are included in the model and set free.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_auto.cov.y">auto.cov.y</code></td>
<td>
<p>If <code>TRUE</code>, the covariances of dependent variables
(both observed and latent) are included in the model and set free.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_auto.th">auto.th</code></td>
<td>
<p>If <code>TRUE</code>, thresholds for limited dependent variables
are included in the model and set free.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_auto.delta">auto.delta</code></td>
<td>
<p>If <code>TRUE</code>, response scaling parameters for limited
dependent variables are included in the model and set free.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_auto.efa">auto.efa</code></td>
<td>
<p>If <code>TRUE</code>, the necessary constraints are
imposed to make the (unrotated) exploratory factor analysis blocks
identifiable: for each block, factor variances are set to 1, factor
covariances are constrained to be zero, and factor loadings are
constrained to follow an echelon pattern.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_vartable">varTable</code></td>
<td>
<p>The variable table containing information about the
observed variables in the model.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_ngroups">ngroups</code></td>
<td>
<p>The number of (independent) groups.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_nthresholds">nthresholds</code></td>
<td>
<p>Either a single integer or a named vector of integers.
If <code>nthresholds</code> is a single integer, all endogenous
variables are assumed to be ordered with <code>nthresholds</code> indicating 
the number of thresholds needed in the model. If <code>nthresholds</code> is a 
named vector, it indicates the number of thresholds for these ordered
variables only. This argument should not be used in combination with 
varTable.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_group.equal">group.equal</code></td>
<td>
<p>A vector of character strings. Only used in
a multiple group analysis. Can be one or more of the following:
<code>"loadings"</code>, <code>"intercepts"</code>,
<code>"means"</code>, <code>"regressions"</code>, <code>"residuals"</code> or
<code>"covariances"</code>, specifying the pattern of equality
constraints across multiple groups. When (in the model syntax) a vector 
of labels is used as a modifier for a certain parameter, this will 
override the group.equal setting if it applies to this parameter. 
See also the Multiple groups section below for using modifiers in multiple
groups.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_group.partial">group.partial</code></td>
<td>
<p>A vector of character strings containing the labels
of the parameters which should be free in all groups (thereby
overriding the group.equal argument for some specific parameters).</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_group.w.free">group.w.free</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the group frequencies are
considered to be free parameters in the model. In this case, a
Poisson model is fitted to estimate the group frequencies. If
<code>FALSE</code> (the default), the group frequencies are fixed to their
observed values.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_as.data.frame.">as.data.frame.</code></td>
<td>
<p>If <code>TRUE</code>, return the list of model parameters
as a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_parser">parser</code></td>
<td>
<p>Character. If <code>"old"</code>, use the original/classic parser.
If <code>"new"</code>, use the new/ldw parser. The default is <code>"new"</code>.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_warn">warn</code></td>
<td>
<p>If <code>TRUE</code>, some (possibly harmless) warnings are printed
out.</p>
</td></tr>
<tr><td><code id="model.syntax_+3A_debug">debug</code></td>
<td>
<p>If <code>TRUE</code>, debugging information is printed out.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model syntax consists of one or more formula-like expressions, each one
describing a specific part of the model. The model syntax can be read from
a file (using <code><a href="base.html#topic+readLines">readLines</a></code>), or can be specified as a literal
string enclosed by single quotes as in the example below. 
</p>
<pre>myModel &lt;- '
  # 1. latent variable definitions
    f1 =~ y1 + y2 + y3
    f2 =~ y4 + y5 + y6
    f3 =~ y7 + y8 + 
          y9 + y10 
    f4 =~ y11 + y12 + y13

  ! this is also a comment
 
  # 2. regressions
    f1 ~ f3 + f4
    f2 ~ f4
    y1 + y2 ~ x1 + x2 + x3

  # 3. (co)variances
    y1 ~~ y1
    y2 ~~ y4 + y5 
    f1 ~~ f2

  # 4. intercepts
    f1 ~ 1; y5 ~ 1

  # 5. thresholds
    y11 | t1 + t2 + t3
    y12 | t1
    y13 | t1 + t2

  # 6. scaling factors
    y11 ~*~ y11
    y12 ~*~ y12
    y13 ~*~ y13

  # 7. formative factors
    f5 &lt;~ z1 + z2 + z3 + z4
'
</pre>
<p>Blank lines and comments can be used in between the formulas, and formulas can
be split over multiple lines. Both the sharp (#) and the exclamation (!) 
characters can be used to start a comment. Multiple formulas can be placed
on a single line if they are separated by a semicolon (;).
</p>
<p>There can be seven types of formula-like expressions in the model syntax:
</p>

<ol>
<li><p> Latent variable definitions: The <code>"=~"</code> operator can be
used to define (continuous) latent variables. The name of the latent
variable is on the left of the <code>"=~"</code> operator, while the terms 
on the right, separated by <code>"+"</code> operators, are the indicators 
of the latent variable. 
</p>
<p>The operator <code>"=~"</code> can be read as &ldquo;is manifested by&rdquo;.
</p>
</li>
<li><p> Regressions: The <code>"~"</code> operator specifies a regression.
The dependent variable is on the left of a <code>"~"</code> operator and the
independent variables, separated by <code>"+"</code> operators, are on the right.
These regression formulas are similar to the way ordinary linear regression
formulas are used in R, but they may include latent variables. Interaction
terms are currently not supported. 
</p>
</li>
<li><p> Variance-covariances: The <code>"~~"</code> (&lsquo;double tilde&rsquo;) operator specifies
(residual) variances of an observed or latent variable, or a set of 
covariances between one variable, and several other variables (either
observed or latent). Several variables, separated by <code>"+"</code> 
operators can appear on the right. This way, several pairwise 
(co)variances involving the same left-hand variable can be expressed in a
single expression. The distinction between variances and residual variances
is made automatically.
</p>
</li>
<li><p> Intercepts: A special case of a regression formula can be used to
specify an intercept (or a mean) of either an observed or a latent variable.
The variable name is on the left of a <code>"~"</code> operator. On the right is
only the number <code>"1"</code> representing the intercept. Including an intercept
formula in the model automatically implies <code>meanstructure = TRUE</code>. The
distinction between intercepts and means is made automatically.
</p>
</li>
<li><p> Thresholds: The <code>"|"</code> operator can be used to define the 
thresholds of categorical endogenous variables (on the left hand side
of the operator). By convention, the
thresholds (on the right hand sided, separated by the <code>"+"</code> operator,
are named <code>"t1"</code>, <code>"t2"</code>, etcetera.
</p>
</li>
<li><p> Scaling factors: The <code>"~*~"</code> operator defines a scale factor.
The variable name on the left hand side must be the same as the variable
name on the right hand side. Scale factors are used in the Delta
parameterization, in a multiple group analysis when factor indicators
are categorical.
</p>
</li>
<li><p> Formative factors: The <code>"&lt;~"</code> operator can be used to define
a formative factor (on the right hand side of the operator), in a
similar way to how a reflexive factor is defined (using the <code>"=~"</code>
operator). This is just syntax sugar to define a phantom latent
variable (equivalent to using <code>"f =~ 0"</code>). And in addition, the
(residual) variance of the formative factor is fixed to zero.
</p>
</li></ol>

<p>There are 4 additional operators, also with left- and right-hand sides, that can
be included in model syntax.  Three of them are used to specify (in)equality
constraints on estimated parameters (<code>==</code>, <code>&gt;</code>, and <code>&lt;</code>), and
those are demonstrated in a later section about 
<b>(In)equality constraints</b>.
The final additional operator (<code>:=</code>) can be used to define &ldquo;new&rdquo; parameters
that are functions of one or more other estimated parameters. The <code>:=</code>
operator is demonstrated in a section about <b>User-defined parameters</b>.
</p>
<p>Usually, only a single variable name appears on the left side of an
operator. However, if multiple variable names are specified, 
separated by the <code>"+"</code> operator, the formula is repeated for each
element on the left side (as for example in the third regression 
formula in the example above). The only exception are scaling factors, where
only a single element is allowed on the left hand side. 
</p>
<p>In the right-hand side of these formula-like expressions, each element can be
modified (using the <code>"*"</code> operator) by either a numeric constant,
an expression resulting in a numeric constant, an expression resulting
in a character vector, or one
of three special functions: <code>start()</code>, <code>label()</code> and <code>equal()</code>.
This provides the user with a mechanism to fix parameters, to provide
alternative starting values, to label the parameters, and to define equality
constraints among model parameters. All <code>"*"</code> expressions are
referred to as <em>modifiers</em>. They are explained in more detail in the
following sections.
</p>


<h3>Fixing parameters</h3>

<p>It is often desirable to fix a model parameter that is otherwise (by default)
free. Any parameter in a model can be fixed by using a modifier resulting
in a numerical constaint. Here are some examples:
</p>

<ul>
<li><p> Fixing the regression coefficient of the predictor 
<code>x2</code>: </p>
<pre>y ~ x1 + 2.4*x2 + x3</pre>
</li>
<li><p> Specifying an orthogonal (zero) covariance between two latent 
variables: </p>
<pre>f1 ~~ 0*f2</pre>
</li>
<li><p> Specifying an intercept and a linear slope in a growth 
model: </p>
<pre>i =~ 1*y11 + 1*y12 + 1*y13 + 1*y14
s =~ 0*y11 + 1*y12 + 2*y13 + 3*y14</pre>
</li></ul>

<p>Instead of a numeric constant, one can use a mathematical function that returns
a numeric constant, for example <code>sqrt(10)</code>. Multiplying with <code>NA</code>
will force the corresponding parameter to be free.
</p>
<p>Additionally, the <code>==</code> operator can be used to set a <em>labeled</em> parameter
equal to a specific numeric value. This will be demonstrated in the section below
about <b>(In)equality constraints</b>.
</p>


<h3>Starting values</h3>

<p>User-provided starting values can be given by using the special function
<code>start()</code>, containing a numeric constant. For example:
</p>
<pre>y ~ x1 + start(1.0)*x2 + x3</pre>
<p>Note that if a starting value is provided, the parameter is not 
automatically considered to be free.
</p>


<h3>Parameter labels and equality constraints</h3>

<p>Each free parameter in a model is automatically given a name (or label).
The name given to a model
parameter consists of three parts, coerced to a single character vector.
The first part is the name of the variable in the left-hand side of the
formula where the parameter was
implied. The middle part is based on the special &lsquo;operator&rsquo; used in the
formula. This can be either one of <code>"=~"</code>, <code>"~"</code> or <code>"~~"</code>. The
third part is the name of the variable in the right-hand side of the formula
where the parameter was implied, or <code>"1"</code> if it is an intercept. The three
parts are pasted together in a single string. For example, the name of the
fixed regression coefficient in the regression formula
<code>y ~ x1 + 2.4*x2 + x3</code> is the string <code>"y~x2"</code>.
The name of the parameter
corresponding to the covariance between two latent variables in the
formula <code>f1 ~~ f2</code> is the string <code>"f1~~f2"</code>.
</p>
<p>Although this automatic labeling of parameters is convenient, the user may
specify its own labels for specific parameters simply by pre-multiplying
the corresponding term (on the right hand side of the operator only) by
a character string (starting with a letter).
For example, in the formula <code>f1 =~ x1 + x2 + mylabel*x3</code>, the parameter 
corresponding with the factor loading of
<code>x3</code> will be named <code>"mylabel"</code>.
An alternative way to specify the label is as follows: 
<code>f1 =~ x1 + x2 + label("mylabel")*x3</code>, 
where the label is the argument of special function <code>label()</code>;
this can be useful if the label contains a space, or an operator (like &quot;~&quot;).
</p>
<p>To constrain a parameter
to be equal to another target parameter, there are two ways. If you
have specified your own labels, you can use the fact that 
<em>equal labels imply equal parameter values</em>. 
If you rely on automatic parameter labels, you
can use the special function <code>equal()</code>. The argument of
<code>equal()</code> is the (automatic or user-specified) name of the target
parameter. For example, in the confirmatory factor analysis example below, the
intercepts of the three indicators of each latent variable are constrained to
be equal to each other. For the first three, we have used the default
names. For the last three, we have provided a custom label for the 
<code>y2a</code> intercept.
</p>
<pre>model &lt;- '
  # two latent variables with fixed loadings
    f1 =~ 1*y1a + 1*y1b + 1*y1c
    f2 =~ 1*y2a + 1*y2b + 1*y2c

  # intercepts constrained to be equal
  # using the default names
    y1a ~ 1
    y1b ~ equal("y1a~1") * 1
    y1c ~ equal("y1a~1") * 1

  # intercepts constrained to be equal
  # using a custom label
    y2a ~ int2*1
    y2b ~ int2*1
    y2c ~ int2*1
'
</pre>


<h3>Multiple groups</h3>

<p>In a multiple group analysis, modifiers that contain a single element
should be replaced by a vector, having the same length as the number
of groups. If you provide a single element, it will be recycled
for all the groups. This may be dangerous, in particular when the modifier
is a label. In that case, the (same) label is copied across all groups,
and this would imply an equality constraint across groups.
Therefore, when using modifiers in a multiple group setting, it is always  
safer (and cleaner) to specify the same number of 
elements as the number of groups. Consider this example with two groups:
</p>
<pre>
HS.model &lt;- ' visual  =~ x1 + 0.5*x2 + c(0.6, 0.8)*x3
              textual =~ x4 + start(c(1.2, 0.6))*x5 + x6
              speed   =~ x7 + x8 + c(x9.group1, x9.group2)*x9 '
</pre>
<p>In this example, the factor loading of the &lsquo;x2&rsquo; indicator is fixed to the
value 0.5 for both groups. However, the factor loadings of the &lsquo;x3&rsquo; indicator 
are fixed to 0.6 and 0.8 for group 1 and group 2 respectively. The same
logic is used for all modifiers. Note that character vectors can contain
unquoted strings.
</p>


<h3>Multiple modifiers</h3>

<p>In the model syntax, you can specify a variable more than once on the right hand
side of an operator; therefore, several &lsquo;modifiers&rsquo; can be applied
simultaneously; for example, if you want to fix the value of a parameter and
also label that parameter, you can use something like:
</p>
<pre> f1 =~ x1 + x2 + 4*x3 + x3.loading*x3</pre>


<h3>(In)equality constraints</h3>

<p>The <code>==</code> operator can be used either to fix a parameter to a specific value,
or to set an estimated parameter equal to another parameter. Adapting the
example in the <b>Parameter labels and equality constraints</b> section, we
could have used different labels for the second factor's intercepts:
</p>
<pre>
    y2a ~ int1*1
    y2b ~ int2*1
    y2c ~ int3*1
</pre>
<p>Then, we could fix the first intercept to zero by including in the syntax an
operation that indicates the parameter's label equals that value:
</p>
<pre>
    int1 == 0
</pre>
<p>Whereas we could still estimate the other two intercepts under an equality
constraint by setting their different labels equal to each other:
</p>
<pre>
    int2 == int3
</pre>
<p>Optimization can be less efficient when constraining parameters this way (see
the documentation linked under <b>See also</b> for more information). But the
flexibility might be advantageous.  For example, the constraints could be
specified in a separate character-string object, which can be passed to the
<code>lavaan(..., constraints=)</code> argument, enabling users to compare results
with(out) the constraints.
</p>
<p>Inequality constraints work much the same way, using the <code>&lt;</code> or <code>&gt;</code>
operator indicate which estimated parameter is hypothesized to be greater/less
than either a specific value or another estimated parameter.  For example, a
variance can be constrained to be nonnegative:
</p>
<pre>
    y1a ~~ var1a*y1a
    ## hypothesized constraint:
    var1a &gt; 0
</pre>
<p>Or the factor loading of a particular indicator might be expected to exceed
other indicators' loadings:
</p>
<pre>
    f1 =~ L1*y1a + L2*y1b + L3*y1c
    ## hypothesized constraints:
    L1 &gt; L2
    L3 &lt; L1
</pre>


<h3>User-defined parameters</h3>

<p>Functions of parameters can be useful to test particular hypotheses. Following
from the <code>Multiple groups</code> example, we might be interested in which group's
factor loading is larger (i.e., an estimate of differential item functioning
(DIF) when the latent scales are linked by anchor items with equal loadings).
</p>
<pre>
  speed =~ c(L7, L7)*x7 + c(L8, L8)*x8 + c(L9.group1, L9.group2)*x9 '
  ## user-defined parameter:
  DIF_L9 := L9.group1 - L9.group2
</pre>
<p>Note that this hypothesis is easily tested without a user-defined parameter by
using the <code>lavTestWald()</code> function. However, a user-defined parameter 
additionally provides an estimate of the parameter being tested.
</p>
<p>User-defined parameters are particularly useful for specifying indirect effects
in models of mediation. For example:
</p>
<pre>
model &lt;- ' # direct effect
             Y ~ c*X
           # mediator
             M ~ a*X
             Y ~ b*M
             
# user defined parameters:

    # indirect effect (a*b)
             ab := a*b
    # total effect (defined using another user-defined parameter)
             total := ab + c
'
</pre>


<h3>References</h3>

<p>Rosseel, Y. (2012). <code>lavaan</code>: An R package for structural equation
modeling. <em>Journal of Statistical Software, 48</em>(2), 1&ndash;36. 
<a href="https://doi.org/10.18637/jss.v048.i02">doi:10.18637/jss.v048.i02</a>
</p>

<hr>
<h2 id='modificationIndices'>Modification Indices</h2><span id='topic+modificationIndices'></span><span id='topic+modificationindices'></span><span id='topic+modindices'></span>

<h3>Description</h3>

<p>Given a fitted lavaan object, compute the modification indices
(= univariate score tests) for a selected set of fixed-to-zero parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modificationIndices(object, standardized = TRUE, cov.std = TRUE,
                    information = "expected",
                    power = FALSE, delta = 0.1, alpha = 0.05,
                    high.power = 0.75, sort. = FALSE, minimum.value = 0,
                    maximum.number = nrow(LIST), free.remove = TRUE,
                    na.remove = TRUE, op = NULL)
modindices(object, standardized = TRUE, cov.std = TRUE, information = "expected",
                    power = FALSE, delta = 0.1, alpha = 0.05, high.power = 0.75,
                    sort. = FALSE, minimum.value = 0,
                    maximum.number = nrow(LIST), free.remove = TRUE,
                    na.remove = TRUE, op = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modificationIndices_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+lavaan-class">lavaan</a></code>.</p>
</td></tr>
<tr><td><code id="modificationIndices_+3A_standardized">standardized</code></td>
<td>
<p>If <code>TRUE</code>, two extra columns (sepc.lv and sepc.all)
will contain standardized values for the EPCs. In the first column (sepc.lv),
standardization is based on the variances of the (continuous) latent
variables. In the second column (sepc.all), standardization is based
on both the variances of both (continuous) observed and latent variables.
(Residual) covariances are standardized using (residual) variances.</p>
</td></tr>
<tr><td><code id="modificationIndices_+3A_cov.std">cov.std</code></td>
<td>
<p>Logical. See <code><a href="#topic+standardizedSolution">standardizedSolution</a></code>.</p>
</td></tr>
<tr><td><code id="modificationIndices_+3A_information">information</code></td>
<td>
<p><code>character</code> indicating the type of information matrix
to use (check <code><a href="#topic+lavInspect">lavInspect</a></code> for available options). <code>"expected"</code>
information is the default, which provides better control of Type I errors.</p>
</td></tr>
<tr><td><code id="modificationIndices_+3A_power">power</code></td>
<td>
<p>If <code>TRUE</code>, the (post-hoc) power is computed for each
modification index, using the values of <code>delta</code> and <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="modificationIndices_+3A_delta">delta</code></td>
<td>
<p>The value of the effect size, as used in the post-hoc power
computation, currently using the unstandardized metric of the epc column.</p>
</td></tr>
<tr><td><code id="modificationIndices_+3A_alpha">alpha</code></td>
<td>
<p>The significance level used for deciding if the modification
index is statistically significant or not.</p>
</td></tr>
<tr><td><code id="modificationIndices_+3A_high.power">high.power</code></td>
<td>
<p>If the computed power is higher than this cutoff value,
the power is considered &lsquo;high&rsquo;. If not, the power is considered &lsquo;low&rsquo;.
This affects the values in the 'decision' column in the output.</p>
</td></tr>
<tr><td><code id="modificationIndices_+3A_sort.">sort.</code></td>
<td>
<p>Logical. If TRUE, sort the output using the values of
the modification index values. Higher values appear first.</p>
</td></tr>
<tr><td><code id="modificationIndices_+3A_minimum.value">minimum.value</code></td>
<td>
<p>Numeric. Filter output and only show rows with a
modification index value equal or higher than this minimum value.</p>
</td></tr>
<tr><td><code id="modificationIndices_+3A_maximum.number">maximum.number</code></td>
<td>
<p>Integer. Filter output and only show the first
maximum number rows. Most useful when combined with the <code>sort.</code> option.</p>
</td></tr>
<tr><td><code id="modificationIndices_+3A_free.remove">free.remove</code></td>
<td>
<p>Logical. If TRUE, filter output by removing all rows
corresponding to free (unconstrained) parameters in the original model.</p>
</td></tr>
<tr><td><code id="modificationIndices_+3A_na.remove">na.remove</code></td>
<td>
<p>Logical. If TRUE, filter output by removing all rows with
NA values for the modification indices.</p>
</td></tr>
<tr><td><code id="modificationIndices_+3A_op">op</code></td>
<td>
<p>Character string. Filter the output by selecting only those rows with
operator <code>op</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Modification indices are just 1-df (or univariate) score tests. The
modification index (or score test) for a single parameter reflects
(approximately) the improvement in model fit (in terms of the chi-square
test statistic), if we would refit the model but allow this parameter to
be free.
This function is a convenience function in the sense that it produces a
(hopefully sensible) table of currently fixed-to-zero (or fixed to another
constant) parameters. For each of these parameters, a modification index
is computed, together with an expected parameter change (epc) value.
It is important to realize that this function will only consider
fixed-to-zero parameters. If you have equality constraints in the model,
and you wish to examine what happens if you release all (or some) of these
equality constraints, use the <code><a href="#topic+lavTestScore">lavTestScore</a></code> function.
</p>


<h3>Value</h3>

<p>A data.frame containing modification indices and EPC's.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- cfa(HS.model, data=HolzingerSwineford1939)
modindices(fit, minimum.value = 10, sort = TRUE)
</code></pre>

<hr>
<h2 id='mplus2lavaan'>mplus to lavaan converter</h2><span id='topic+mplus2lavaan'></span><span id='topic+lavImport'></span>

<h3>Description</h3>

<p>Read in an Mplus input file, convert it to lavaan syntax, and fit
the model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mplus2lavaan(inpfile, run = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mplus2lavaan_+3A_inpfile">inpfile</code></td>
<td>
<p>The filename (including a full path) of the Mplus input file.
The data (as referred to in the Mplus input file) should be in the same
directory as the Mplus input file.</p>
</td></tr>
<tr><td><code id="mplus2lavaan_+3A_run">run</code></td>
<td>
<p>Whether to run the specified Mplus input syntax (<code>TRUE</code>) or
only to parse and convert the syntax (<code>FALSE</code>).</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>A <code>lavaan</code> object with the fitted results of the Mplus model. The parsed
and converted Mplus syntax is preserved in the <code>@external</code> slot of the <code>lavaan</code>
object in the <code>$mplus.inp</code> element. If <code>run</code> is <code>FALSE</code>, a <code>list</code> of converted
syntax is returned.
</p>


<h3>Author(s)</h3>

<p>Michael Hallquist</p>


<h3>See Also</h3>

<p><code><a href="#topic+lavExport">lavExport</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
out &lt;- mplus2lavaan("ex5.1.inp")
summary(out)

## End(Not run)
</code></pre>

<hr>
<h2 id='mplus2lavaan.modelSyntax'>Convert Mplus model syntax to lavaan</h2><span id='topic+mplus2lavaan.modelSyntax'></span>

<h3>Description</h3>

<p>Converts Mplus model syntax into lavaan model syntax.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mplus2lavaan.modelSyntax(syntax)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mplus2lavaan.modelSyntax_+3A_syntax">syntax</code></td>
<td>
<p>A character vector containing Mplus model syntax to be
converted to lavaan model syntax. Note that parsing Mplus syntax often
requires correct usage of newline characters. If <code>syntax</code> is a
vector of multiple strings, these will be joined with newlines prior
to conversion. Alternatively, <code>\n</code> characters can be included
inline in <code>syntax</code>.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A character string of converted <code>lavaan</code> model syntax.
</p>


<h3>Author(s)</h3>

<p>Michael Hallquist</p>


<h3>See Also</h3>

<p><code><a href="#topic+mplus2lavaan">mplus2lavaan</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
syntax &lt;- '
    f1 BY x1*1 x2 x3;
    x1 WITH x2;
    x3 (1);
    x2 (1);
'
lavSyntax &lt;- mplus2lavaan.modelSyntax(syntax)
cat(lavSyntax)

## End(Not run)
</code></pre>

<hr>
<h2 id='parameterEstimates'>Parameter Estimates</h2><span id='topic+parameterEstimates'></span><span id='topic+parameterestimates'></span>

<h3>Description</h3>

<p>Parameter estimates of a latent variable model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameterEstimates(object, 
                   se = TRUE, zstat = TRUE, pvalue = TRUE, ci = TRUE, 
                   standardized = FALSE, 
                   fmi = FALSE, level = 0.95, boot.ci.type = "perc", 
                   cov.std = TRUE, fmi.options = list(), 
                   rsquare = FALSE, 
                   remove.system.eq = TRUE, remove.eq = TRUE, 
                   remove.ineq = TRUE, remove.def = FALSE, 
                   remove.nonfree = FALSE, remove.step1 = TRUE,
                   remove.unused = FALSE, add.attributes = FALSE, 
                   output = "data.frame", header = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parameterEstimates_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+lavaan-class">lavaan</a></code>.</p>
</td></tr>
<tr><td><code id="parameterEstimates_+3A_se">se</code></td>
<td>
<p>Logical. If <code>TRUE</code>, include column containing the standard
errors. If <code>FALSE</code>, this implies <code>zstat</code> and <code>pvalue</code> and
<code>ci</code> are also <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="parameterEstimates_+3A_zstat">zstat</code></td>
<td>
<p>Logical. If <code>TRUE</code>, an extra column is added containing
the so-called z-statistic, which is simply the value of the estimate divided
by its standard error.</p>
</td></tr>
<tr><td><code id="parameterEstimates_+3A_pvalue">pvalue</code></td>
<td>
<p>Logical. If <code>TRUE</code>, an extra column is added containing
the pvalues corresponding to the z-statistic, evaluated under a standard
normal distribution.</p>
</td></tr>
<tr><td><code id="parameterEstimates_+3A_ci">ci</code></td>
<td>
<p>If <code>TRUE</code>, confidence intervals are added to the output</p>
</td></tr>
<tr><td><code id="parameterEstimates_+3A_level">level</code></td>
<td>
<p>The confidence level required.</p>
</td></tr>
<tr><td><code id="parameterEstimates_+3A_boot.ci.type">boot.ci.type</code></td>
<td>
<p>If bootstrapping was used, the type of interval required.
The value should be one of <code>"norm"</code>, <code>"basic"</code>, <code>"perc"</code>,
or <code>"bca.simple"</code>. For the first three options, see the help page of
the <code>boot.ci</code> function in the boot package. The
<code>"bca.simple"</code> option produces intervals using the adjusted bootstrap
percentile (BCa) method, but with no correction for acceleration (only for
bias). Note that the p-value is still computed assuming that the z-statistic
follows a standard normal distribution.</p>
</td></tr>
<tr><td><code id="parameterEstimates_+3A_standardized">standardized</code></td>
<td>
<p>Logical or character. If <code>TRUE</code>, standardized estimates
are added to the output. Note that <em>SE</em>s and tests are still based on
unstandardized estimates. Use <code><a href="#topic+standardizedSolution">standardizedSolution</a></code> to obtain
<em>SE</em>s and test statistics for standardized estimates. If a character
vector is passed with any of <code>c("std.lv","std.all","std.nox")</code>, only the
selected standardization methods are added.</p>
</td></tr>
<tr><td><code id="parameterEstimates_+3A_cov.std">cov.std</code></td>
<td>
<p>Logical. If TRUE, the (residual) observed
covariances are scaled by the square root of the &lsquo;Theta&rsquo; diagonal elements, and
the (residual) latent covariances are scaled by the square root of the &lsquo;Psi&rsquo;
diagonal elements. If FALSE, the (residual) observed covariances
are scaled by the square root of the diagonal elements of the observed
model-implied covariance matrix (Sigma), and the (residual) latent covariances
are scaled by the square root of diagonal elements of the model-implied
covariance matrix of the latent variables.</p>
</td></tr>
<tr><td><code id="parameterEstimates_+3A_fmi">fmi</code></td>
<td>
<p>Logical. If <code>TRUE</code>, an extra column is added containing the
fraction of missing information for each estimated parameter. Only
available if
<code>estimator="ML"</code>, <code>missing="(fi)ml"</code>, and <code>se="standard"</code>.
See references for more information.</p>
</td></tr>
<tr><td><code id="parameterEstimates_+3A_fmi.options">fmi.options</code></td>
<td>
<p>List. If non-empty, arguments can be provided to alter
the default options when the model is fitted with the complete(d) data;
otherwise, the same options are used as the original model.</p>
</td></tr>
<tr><td><code id="parameterEstimates_+3A_remove.eq">remove.eq</code></td>
<td>
<p>Logical. If <code>TRUE</code>, filter the output by removing all
rows containing user-specified equality constraints, if any.</p>
</td></tr>
<tr><td><code id="parameterEstimates_+3A_remove.system.eq">remove.system.eq</code></td>
<td>
<p>Logical. If <code>TRUE</code>, filter the output by
removing all rows containing system-generated equality constraints, if any.</p>
</td></tr>
<tr><td><code id="parameterEstimates_+3A_remove.ineq">remove.ineq</code></td>
<td>
<p>Logical. If <code>TRUE</code>, filter the output by removing all
rows containing inequality constraints, if any.</p>
</td></tr>
<tr><td><code id="parameterEstimates_+3A_remove.def">remove.def</code></td>
<td>
<p>Logical. If <code>TRUE</code>, filter the output by removing all
rows containing parameter definitions, if any.</p>
</td></tr>
<tr><td><code id="parameterEstimates_+3A_remove.nonfree">remove.nonfree</code></td>
<td>
<p>Logical. If <code>TRUE</code>, filter the output by removing 
all rows containing fixed (non-free) parameters.</p>
</td></tr>
<tr><td><code id="parameterEstimates_+3A_remove.step1">remove.step1</code></td>
<td>
<p>Logical. Only used by <code>sam()</code>. 
If <code>TRUE</code>, filter the 
output by removing all rows corresponding to the measurement parameters
that are part of the first step.</p>
</td></tr>
<tr><td><code id="parameterEstimates_+3A_remove.unused">remove.unused</code></td>
<td>
<p>Logical. If <code>TRUE</code>, filter the output by removing
all rows containing automatically added parameters (user == 0) that are 
nonfree, and with their final (est) values fixed to their default values 
(typically 1 or 0); currently only used for intercepts and 
scaling-factors.</p>
</td></tr>
<tr><td><code id="parameterEstimates_+3A_rsquare">rsquare</code></td>
<td>
<p>Logical. If <code>TRUE</code>, add additional rows containing
the rsquare values (in the <code>est</code> column) of all endogenous variables
in the model. Both the <code>lhs</code> and <code>rhs</code> column contain the
name of the endogenous variable, while the <code>op</code> column contains <code>r2</code>,
to indicate that the values in the <code>est</code> column are rsquare values.</p>
</td></tr>
<tr><td><code id="parameterEstimates_+3A_add.attributes">add.attributes</code></td>
<td>
<p>Deprecated argument. Please use output= instead.</p>
</td></tr>
<tr><td><code id="parameterEstimates_+3A_output">output</code></td>
<td>
<p>Character. If <code>"data.frame"</code>, the parameter table is
displayed as a standard (albeit lavaan-formatted) data.frame. 
If <code>"text"</code> (or alias <code>"pretty"</code>), the parameter table is
prettyfied, and displayed with subsections (as used by the summary function).</p>
</td></tr>
<tr><td><code id="parameterEstimates_+3A_header">header</code></td>
<td>
<p>Logical. Only used if <code>output = "text"</code>. If
<code>TRUE</code>, print a header at the top of the parameter list. This header
contains information about the information matrix, if saturated (h1) model
is structured or unstructured, and which type of standard errors are shown
in the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing the estimated parameters,
parameters, standard errors, and (by default) z-values , p-values, and
the lower and upper values of the confidence intervals. If requested,
extra columns are added with standardized versions of the parameter
estimates.
</p>


<h3>References</h3>

<p>Savalei, V. &amp; Rhemtulla, M. (2012). On obtaining estimates of the fraction of
missing information from FIML. Structural Equation Modeling: A
Multidisciplinary Journal, 19(3), 477-494.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- cfa(HS.model, data=HolzingerSwineford1939)
parameterEstimates(fit)
parameterEstimates(fit, output = "text")
</code></pre>

<hr>
<h2 id='parTable'>Parameter Table</h2><span id='topic+parameterTable'></span><span id='topic+parametertable'></span><span id='topic+parTable'></span><span id='topic+partable'></span>

<h3>Description</h3>

<p>Show the parameter table of a fitted model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameterTable(object)
parTable(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parTable_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+lavaan-class">lavaan</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the model parameters. This is
simply the output of the <code><a href="#topic+lavaanify">lavaanify</a></code> function 
coerced to a <code>data.frame</code> (with <code>stringsAsFactors = FALSE</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lavaanify">lavaanify</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- cfa(HS.model, data=HolzingerSwineford1939)
parTable(fit)
</code></pre>

<hr>
<h2 id='PoliticalDemocracy'>
Industrialization And Political Democracy Dataset
</h2><span id='topic+PoliticalDemocracy'></span>

<h3>Description</h3>

<p>The &lsquo;famous&rsquo; Industrialization and Political Democracy dataset. This dataset is
used throughout Bollen's 1989 book (see pages 12, 17, 36 in chapter 2, pages
228 and following in chapter 7, pages 321 and following in chapter 8).
The dataset contains various measures of political democracy and
industrialization in developing countries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PoliticalDemocracy)</code></pre>


<h3>Format</h3>

<p>A data frame of 75 observations of 11 variables.
</p>

<dl>
<dt><code>y1</code></dt><dd><p>Expert ratings of the freedom of the press in 1960</p>
</dd>
<dt><code>y2</code></dt><dd><p>The freedom of political opposition in 1960</p>
</dd>
<dt><code>y3</code></dt><dd><p>The fairness of elections in 1960</p>
</dd>
<dt><code>y4</code></dt><dd><p>The effectiveness of the elected legislature in 1960</p>
</dd>
<dt><code>y5</code></dt><dd><p>Expert ratings of the freedom of the press in 1965</p>
</dd>
<dt><code>y6</code></dt><dd><p>The freedom of political opposition in 1965</p>
</dd>
<dt><code>y7</code></dt><dd><p>The fairness of elections in 1965</p>
</dd>
<dt><code>y8</code></dt><dd><p>The effectiveness of the elected legislature in 1965</p>
</dd>
<dt><code>x1</code></dt><dd><p>The gross national product (GNP) per capita in 1960</p>
</dd>
<dt><code>x2</code></dt><dd><p>The inanimate energy consumption per capita in 1960</p>
</dd>
<dt><code>x3</code></dt><dd><p>The percentage of the labor force in industry in 1960</p>
</dd>
</dl>



<h3>Source</h3>

<p>The dataset was originally retrieved from <code style="white-space: pre;">&#8288;http://web.missouri.edu/~kolenikovs/Stat9370/democindus.txt&#8288;</code> (link no longer valid; see discussion on SEMNET 18 Jun 2009). The dataset is part of a larger (public) dataset (ICPSR 2532), see
<code style="white-space: pre;">&#8288;https://www.icpsr.umich.edu/web/ICPSR/studies/2532&#8288;</code>.
</p>


<h3>References</h3>

<p>Bollen, K. A. (1989). <em>Structural Equations with Latent Variables.</em> 
Wiley Series in Probability and Mathematical Statistics. New York: Wiley.
</p>
<p>Bollen, K. A. (1979). Political democracy and the timing of development.
<em>American Sociological Review</em>, 44, 572-587.
</p>
<p>Bollen, K. A. (1980). Issues in the comparative measurement of political
democracy. <em>American Sociological Review</em>, 45, 370-390.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(PoliticalDemocracy)
</code></pre>

<hr>
<h2 id='sam'>Fit Structural Equation Models using the SAM approach</h2><span id='topic+sam'></span><span id='topic+fsr'></span>

<h3>Description</h3>

<p>Fit a Structural Equation Model (SEM) using the Structural After Measurement
(SAM) approach.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sam(model = NULL, data = NULL, cmd = "sem", se = "twostep", 
    mm.list = NULL, mm.args = list(bounds = "wide.zerovar"), 
    struc.args = list(estimator = "ML"), 
    sam.method = "local", ..., 
    local.options = list(M.method = "ML", lambda.correction = TRUE, 
                         alpha.correction = 0L, twolevel.method = "h1"), 
    global.options = list(), output = "lavaan")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sam_+3A_model">model</code></td>
<td>
<p>A description of the user-specified model. Typically, the model
is described using the lavaan model syntax. See            
<code><a href="#topic+model.syntax">model.syntax</a></code> for more information. Alternatively, a
parameter table (eg. the output of the <code>lavaanify()</code> function) is also
accepted.</p>
</td></tr>
<tr><td><code id="sam_+3A_data">data</code></td>
<td>
<p>A data frame containing the observed variables used in
the model.</p>
</td></tr>
<tr><td><code id="sam_+3A_cmd">cmd</code></td>
<td>
<p>Character. Which command is used to run the sem models. The possible
choices are <code>"sem"</code>, <code>"cfa"</code> or <code>"lavaan"</code>, determining how
we deal with default options.</p>
</td></tr>
<tr><td><code id="sam_+3A_se">se</code></td>
<td>
<p>Character. The type of standard errors that are used in the
final (structural) model. If <code>"twostep"</code> (the default), the
standard errors take the estimation uncertainty of the first (measurement) 
stage into account. If <code>"standard"</code>, this uncertainty is ignored,
and we treat the measurement information as known. If <code>"none"</code>,
no standard errors are computed.</p>
</td></tr>
<tr><td><code id="sam_+3A_mm.list">mm.list</code></td>
<td>
<p>List. Define the measurement blocks. 
Each element of the list should
be either a single name of a latent variable, or a vector of latent
variable names.  If omitted, a separate measurement
block is used for each latent variable.</p>
</td></tr>
<tr><td><code id="sam_+3A_mm.args">mm.args</code></td>
<td>
<p>List. Optional arguments for the fitting
function(s) of the measurement block(s) only. See <code><a href="#topic+lavOptions">lavOptions</a></code> 
for a complete list.</p>
</td></tr>
<tr><td><code id="sam_+3A_struc.args">struc.args</code></td>
<td>
<p>List. Optional arguments for the fitting function of the
structural part only. See <code><a href="#topic+lavOptions">lavOptions</a></code> for a complete list.</p>
</td></tr>
<tr><td><code id="sam_+3A_sam.method">sam.method</code></td>
<td>
<p>Character. Can be set to <code>"local"</code>, <code>"global"</code>
or <code>"fsr"</code>. In the latter case, the results are the same as if
Bartlett factor scores were used, without any bias correction.</p>
</td></tr>
<tr><td><code id="sam_+3A_...">...</code></td>
<td>
<p>Many more additional options can be defined, using 'name = value'.
See <code><a href="#topic+lavOptions">lavOptions</a></code> for a complete list. These options affect
both the measurement blocks and the structural part.</p>
</td></tr>
<tr><td><code id="sam_+3A_local.options">local.options</code></td>
<td>
<p>List. Options specific for local SAM method (these
options may change over time). If <code>lambda.correction = TRUE</code>,
we ensure that the variance matrix of the latent variables (VETA)
is positive definite. The <code>alpha.correction</code> options must be an
integer. Acceptable values are in the range 0 till
N-1. If zero (the default), no small sample correction is performed,
and the bias-correction is the same as with local SAM. When equal to N-1,
the bias-correction is eliminated, and the results are the same as
naive FSR. Typical values are 0, P+1 (where P is the number of
predictors in the structural model), P+5, and (N-1)/2.</p>
</td></tr>
<tr><td><code id="sam_+3A_global.options">global.options</code></td>
<td>
<p>List. Options specific for global SAM method (not
used for now).</p>
</td></tr>
<tr><td><code id="sam_+3A_output">output</code></td>
<td>
<p>Character. If <code>"lavaan"</code>, a lavaan object returned. If
<code>"list"</code>, a list is returned with all the ingredients from the 
different stages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>sam</code> function tries to automate the SAM approach, by first
estimating the measurement part of the model,
and then the structural part of the model. See reference for more
details.
</p>
<p>Note that in the current implementation, all indicators of latent
variables have to be observed. This implies: no support for second-order 
factor structures (for now).
</p>


<h3>Value</h3>

<p>If <code>output = "lavaan"</code>, an object of class 
<code><a href="#topic+lavaan-class">lavaan</a></code>, for which several methods
are available, including a <code>summary</code> method. If <code>output = "list"</code>,
a list.
</p>


<h3>References</h3>

<p>Rosseel and Loh (2021). A structural-after-measurement approach to Structural
Equation Modeling. Psychological Methods. Advance online publication.
https://dx.doi.org/10.1037/met0000503
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lavaan">lavaan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The industrialization and Political Democracy Example 
## Bollen (1989), page 332
model &lt;- ' 
  # latent variable definitions
     ind60 =~ x1 + x2 + x3
     dem60 =~ y1 + a*y2 + b*y3 + c*y4
     dem65 =~ y5 + a*y6 + b*y7 + c*y8

  # regressions
    dem60 ~ ind60
    dem65 ~ ind60 + dem60

  # residual correlations
    y1 ~~ y5
    y2 ~~ y4 + y6
    y3 ~~ y7
    y4 ~~ y8
    y6 ~~ y8
'

fit.sam &lt;- sam(model, data = PoliticalDemocracy,
               mm.list = list(ind = "ind60", dem = c("dem60", "dem65")))
summary(fit.sam)
</code></pre>

<hr>
<h2 id='sem'>Fit Structural Equation Models</h2><span id='topic+sem'></span>

<h3>Description</h3>

<p>Fit a Structural Equation Model (SEM).</p>


<h3>Usage</h3>

<pre><code class='language-R'>sem(model = NULL, data = NULL, ordered = NULL, sampling.weights = NULL,
    sample.cov = NULL, sample.mean = NULL, sample.th = NULL,
    sample.nobs = NULL, group = NULL, cluster = NULL, 
    constraints = "", WLS.V = NULL, NACOV = NULL, ov.order = "model",
    ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sem_+3A_model">model</code></td>
<td>
<p>A description of the user-specified model. Typically, the model
is described using the lavaan model syntax. See            
<code><a href="#topic+model.syntax">model.syntax</a></code> for more information. Alternatively, a
parameter table (eg. the output of the <code>lavaanify()</code> function) is also
accepted.</p>
</td></tr>
<tr><td><code id="sem_+3A_data">data</code></td>
<td>
<p>An optional data frame containing the observed variables used in
the model. If some variables are declared as ordered factors, lavaan will
treat them as ordinal variables.</p>
</td></tr>
<tr><td><code id="sem_+3A_ordered">ordered</code></td>
<td>
<p>Character vector. Only used if the data is in a data.frame.
Treat these variables as ordered (ordinal) variables, if they are
endogenous in the model. Importantly, all other variables will be treated
as numeric (unless they are declared as ordered in the data.frame.)
Since 0.6-4, ordered can also be logical. If TRUE, all
observed endogenous variables are treated as ordered (ordinal).
If FALSE, all observed endogenous variables are considered to be numeric
(again, unless they are declared as ordered in the data.frame.)</p>
</td></tr>
<tr><td><code id="sem_+3A_sampling.weights">sampling.weights</code></td>
<td>
<p>A variable name in the data frame containing 
sampling weight information. Currently only available for non-clustered
data. Depending on the <code>sampling.weights.normalization</code> option, these
weights may be rescaled (or not) so that their sum equals the number of
observations (total or per group).</p>
</td></tr>
<tr><td><code id="sem_+3A_sample.cov">sample.cov</code></td>
<td>
<p>Numeric matrix. A sample variance-covariance matrix.
The rownames and/or colnames must contain the observed variable names.
For a multiple group analysis, a list with a variance-covariance matrix
for each group.</p>
</td></tr>
<tr><td><code id="sem_+3A_sample.mean">sample.mean</code></td>
<td>
<p>A sample mean vector. For a multiple group analysis,
a list with a mean vector for each group.</p>
</td></tr>
<tr><td><code id="sem_+3A_sample.th">sample.th</code></td>
<td>
<p>Vector of sample-based thresholds. For a multiple group 
analysis, a list with a vector of thresholds for each group.</p>
</td></tr>
<tr><td><code id="sem_+3A_sample.nobs">sample.nobs</code></td>
<td>
<p>Number of observations if the full data frame is missing
and only sample moments are given. For a multiple group analysis, a list
or a vector with the number of observations for each group.</p>
</td></tr>
<tr><td><code id="sem_+3A_group">group</code></td>
<td>
<p>Character. A variable name in the data frame defining the groups
in a multiple group analysis.</p>
</td></tr>
<tr><td><code id="sem_+3A_cluster">cluster</code></td>
<td>
<p>Character. A (single) variable name in the data frame defining the clusters in a two-level dataset.</p>
</td></tr>
<tr><td><code id="sem_+3A_constraints">constraints</code></td>
<td>
<p>Additional (in)equality constraints not yet included in the
model syntax. See <code><a href="#topic+model.syntax">model.syntax</a></code> for more information.</p>
</td></tr>
<tr><td><code id="sem_+3A_wls.v">WLS.V</code></td>
<td>
<p>A user provided weight matrix to be used by estimator <code>"WLS"</code>;
if the estimator is <code>"DWLS"</code>, only the diagonal of this matrix will be
used. For a multiple group analysis, a list with a weight matrix
for each group. The elements of the weight matrix should be in the
following order (if all data is continuous): first the means (if a
meanstructure is involved), then the lower triangular elements of the
covariance matrix including the diagonal, ordered column by column. In
the categorical case: first the thresholds (including the means for
continuous variables), then the slopes (if any), the variances of
continuous variables (if any), and finally the lower triangular elements
of the correlation/covariance matrix excluding the diagonal, ordered
column by column.</p>
</td></tr>
<tr><td><code id="sem_+3A_nacov">NACOV</code></td>
<td>
<p>A user provided matrix containing the elements of (N times)
the asymptotic variance-covariance matrix of the sample statistics.
For a multiple group analysis, a list with an asymptotic
variance-covariance matrix for each group. See the <code>WLS.V</code>
argument for information about the order of the elements.</p>
</td></tr>
<tr><td><code id="sem_+3A_ov.order">ov.order</code></td>
<td>
<p>Character. If <code>"model"</code> (the default), the order of
the observed variable names (as reflected for example in the output of
<code>lavNames()</code>) is determined by the model syntax. If
<code>"data"</code>, the order is determined by the data (either the full
data.frame or the sample (co)variance matrix). If the <code>WLS.V</code>
and/or <code>NACOV</code> matrices are provided, this argument is currently
set to <code>"data"</code>.</p>
</td></tr>
<tr><td><code id="sem_+3A_...">...</code></td>
<td>
<p>Many more additional options can be defined, using 'name = value'.
See <code><a href="#topic+lavOptions">lavOptions</a></code> for a complete list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>sem</code> function is a wrapper for the more general
<code><a href="#topic+lavaan">lavaan</a></code> function, but setting the following default options:
<code>int.ov.free = TRUE</code>, <code>int.lv.free = FALSE</code>,
<code>auto.fix.first = TRUE</code> (unless <code>std.lv = TRUE</code>),
<code>auto.fix.single = TRUE</code>, <code>auto.var = TRUE</code>,
<code>auto.cov.lv.x = TRUE</code>, <code>auto.efa = TRUE</code>,
<code>auto.th = TRUE</code>, <code>auto.delta = TRUE</code>,
and <code>auto.cov.y = TRUE</code>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+lavaan-class">lavaan</a></code>, for which several methods
are available, including a <code>summary</code> method.
</p>


<h3>References</h3>

<p>Yves Rosseel (2012). lavaan: An R Package for Structural Equation
Modeling. Journal of Statistical Software, 48(2), 1-36. 
<a href="https://doi.org/10.18637/jss.v048.i02">doi:10.18637/jss.v048.i02</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lavaan">lavaan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The industrialization and Political Democracy Example 
## Bollen (1989), page 332
model &lt;- ' 
  # latent variable definitions
     ind60 =~ x1 + x2 + x3
     dem60 =~ y1 + a*y2 + b*y3 + c*y4
     dem65 =~ y5 + a*y6 + b*y7 + c*y8

  # regressions
    dem60 ~ ind60
    dem65 ~ ind60 + dem60

  # residual correlations
    y1 ~~ y5
    y2 ~~ y4 + y6
    y3 ~~ y7
    y4 ~~ y8
    y6 ~~ y8
'

fit &lt;- sem(model, data = PoliticalDemocracy)
summary(fit, fit.measures = TRUE)
</code></pre>

<hr>
<h2 id='simulateData'>Simulate Data From a Lavaan Model Syntax</h2><span id='topic+simulateData'></span>

<h3>Description</h3>

<p>Simulate data starting from a lavaan model syntax.</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateData(model = NULL, model.type = "sem", meanstructure = FALSE, 
    int.ov.free = TRUE, int.lv.free = FALSE, 
    marker.int.zero = FALSE, conditional.x = FALSE, fixed.x = FALSE, 
    orthogonal = FALSE, std.lv = TRUE, auto.fix.first = FALSE, 
    auto.fix.single = FALSE, auto.var = TRUE, auto.cov.lv.x = TRUE, 
    auto.cov.y = TRUE, ..., sample.nobs = 500L, ov.var = NULL, 
    group.label = paste("G", 1:ngroups, sep = ""), skewness = NULL, 
    kurtosis = NULL, seed = NULL, empirical = FALSE, 
    return.type = "data.frame", return.fit = FALSE,
    debug = FALSE, standardized = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulateData_+3A_model">model</code></td>
<td>
<p>A description of the user-specified model. Typically, the model
is described using the lavaan model syntax. See
<code><a href="#topic+model.syntax">model.syntax</a></code> for more information. Alternatively, a
parameter table (eg. the output of the <code>lavaanify()</code> function) is also
accepted.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_model.type">model.type</code></td>
<td>
<p>Set the model type: possible values
are <code>"cfa"</code>, <code>"sem"</code> or <code>"growth"</code>. This may affect
how starting values are computed, and may be used to alter the terminology
used in the summary output, or the layout of path diagrams that are
based on a fitted lavaan object.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_meanstructure">meanstructure</code></td>
<td>
<p>If <code>TRUE</code>, the means of the observed
variables enter the model. If <code>"default"</code>, the value is set based
on the user-specified model, and/or the values of other arguments.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_int.ov.free">int.ov.free</code></td>
<td>
<p>If <code>FALSE</code>, the intercepts of the observed variables
are fixed to zero.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_int.lv.free">int.lv.free</code></td>
<td>
<p>If <code>FALSE</code>, the intercepts of the latent variables
are fixed to zero.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_marker.int.zero">marker.int.zero</code></td>
<td>
<p>Logical. Only relevant if the metric of each latent
variable is set by fixing the first factor loading to unity.
If <code>TRUE</code>, it implies <code>meanstructure = TRUE</code> and 
<code>std.lv = FALSE</code>, and it fixes the intercepts of the marker
indicators to zero, while freeing the means/intercepts of the latent
variables. Only works correcly for single group, single level models.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_conditional.x">conditional.x</code></td>
<td>
<p>If <code>TRUE</code>, we set up the model conditional on
the exogenous &lsquo;x&rsquo; covariates; the model-implied sample statistics
only include the non-x variables. If <code>FALSE</code>, the exogenous &lsquo;x&rsquo;
variables are modeled jointly with the other variables, and the
model-implied statistics refect both sets of variables. If
<code>"default"</code>, the value is set depending on the estimator, and
whether or not the model involves categorical endogenous variables.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_fixed.x">fixed.x</code></td>
<td>
<p>If <code>TRUE</code>, the exogenous &lsquo;x&rsquo; covariates are considered
fixed variables and the means, variances and covariances of these variables
are fixed to their sample values. If <code>FALSE</code>, they are considered
random, and the means, variances and covariances are free parameters. If
<code>"default"</code>, the value is set depending on the mimic option.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_orthogonal">orthogonal</code></td>
<td>
<p>If <code>TRUE</code>, the exogenous latent variables
are assumed to be uncorrelated.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_std.lv">std.lv</code></td>
<td>
<p>If <code>TRUE</code>, the metric of each latent variable is
determined by fixing their variances to 1.0. If <code>FALSE</code>, the metric
of each latent variable is determined by fixing the factor loading of the
first indicator to 1.0.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_auto.fix.first">auto.fix.first</code></td>
<td>
<p>If <code>TRUE</code>, the factor loading of the first indicator
is set to 1.0 for every latent variable.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_auto.fix.single">auto.fix.single</code></td>
<td>
<p>If <code>TRUE</code>, the residual variance (if included)
of an observed indicator is set to zero if it is the only indicator of a
latent variable.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_auto.var">auto.var</code></td>
<td>
<p>If <code>TRUE</code>, the (residual) variances of both observed
and latent variables are set free.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_auto.cov.lv.x">auto.cov.lv.x</code></td>
<td>
<p>If <code>TRUE</code>, the covariances of exogenous latent
variables are included in the model and set free.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_auto.cov.y">auto.cov.y</code></td>
<td>
<p>If <code>TRUE</code>, the covariances of dependent variables
(both observed and latent) are included in the model and set free.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the <code><a href="#topic+lavaan">lavaan</a></code>
function.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_sample.nobs">sample.nobs</code></td>
<td>
<p>Number of observations. If a vector, multiple datasets
are created. If <code>return.type = "matrix"</code> or 
<code>return.type = "cov"</code>, a list of <code>length(sample.nobs)</code> 
is returned, with either the data or covariance matrices, each one
based on the number of observations as specified in <code>sample.nobs</code>.
If <code>return.type = "data.frame"</code>, all datasets are merged and 
a <code>group</code> variable is added to mimic a multiple group dataset.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_ov.var">ov.var</code></td>
<td>
<p>The user-specified variances of the observed variables.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_group.label">group.label</code></td>
<td>
<p>The group labels that should be used if multiple
groups are created.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_skewness">skewness</code></td>
<td>
<p>Numeric vector. The skewness values for the observed variables. Defaults to zero.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_kurtosis">kurtosis</code></td>
<td>
<p>Numeric vector. The kurtosis values for the observed variables. Defaults to zero.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_seed">seed</code></td>
<td>
<p>Set random seed.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_empirical">empirical</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the implied moments (Mu and Sigma)
specify the empirical not population mean and covariance matrix.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_return.type">return.type</code></td>
<td>
<p>If <code>"data.frame"</code>, a data.frame is returned. If
<code>"matrix"</code>, a numeric matrix is returned (without any variable names).
If <code>"cov"</code>, a covariance matrix is returned (without any variable 
names).</p>
</td></tr>
<tr><td><code id="simulateData_+3A_return.fit">return.fit</code></td>
<td>
<p>If <code>TRUE</code>, return the fitted model that has been used
to generate the data as an attribute (called <code>"fit"</code>); this 
may be useful for inspection.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_debug">debug</code></td>
<td>
<p>If <code>TRUE</code>, debugging information is displayed.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_standardized">standardized</code></td>
<td>
<p>If <code>TRUE</code>, the residual variances of the observed
variables are set in such a way such that the model implied variances 
are unity. This allows regression coefficients and factor loadings 
(involving observed variables) to be specified in a standardized metric.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Model parameters can be specified by fixed values in the lavaan
model syntax. If no fixed values are specified, the value zero will be 
assumed, except for factor loadings and variances, which are set to unity 
by default. By default, multivariate normal data are generated. However,
by providing skewness and/or kurtosis values, nonnormal multivariate data
can be generated, using the Vale &amp; Maurelli (1983) method.</p>


<h3>Value</h3>

<p>The generated data. Either as a data.frame 
(if <code>return.type="data.frame"</code>), 
a numeric matrix (if <code>return.type="matrix"</code>),
or a covariance matrix (if <code>return.type="cov"</code>).</p>


<h3>Examples</h3>

<pre><code class='language-R'># specify population model
population.model &lt;- ' f1 =~ x1 + 0.8*x2 + 1.2*x3
                      f2 =~ x4 + 0.5*x5 + 1.5*x6
                      f3 =~ x7 + 0.1*x8 + 0.9*x9

                      f3 ~ 0.5*f1 + 0.6*f2
                    '

# generate data
set.seed(1234)
myData &lt;- simulateData(population.model, sample.nobs=100L)

# population moments
fitted(sem(population.model))

# sample moments
round(cov(myData), 3)
round(colMeans(myData), 3)

# fit model
myModel &lt;- ' f1 =~ x1 + x2 + x3
             f2 =~ x4 + x5 + x6
             f3 =~ x7 + x8 + x9
             f3 ~ f1 + f2 '
fit &lt;- sem(myModel, data=myData)
summary(fit)
</code></pre>

<hr>
<h2 id='standardizedSolution'>Standardized Solution</h2><span id='topic+standardizedSolution'></span><span id='topic+standardizedsolution'></span>

<h3>Description</h3>

<p>Standardized solution of a latent variable model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardizedSolution(object, type = "std.all", se = TRUE, zstat = TRUE, 
                     pvalue = TRUE, ci = TRUE, level = 0.95, cov.std = TRUE, 
                     remove.eq = TRUE, remove.ineq = TRUE, remove.def = FALSE, 
                     partable = NULL, GLIST = NULL, est = NULL,
                     output = "data.frame")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardizedSolution_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+lavaan-class">lavaan</a></code>.</p>
</td></tr>
<tr><td><code id="standardizedSolution_+3A_type">type</code></td>
<td>
<p>If <code>"std.lv"</code>, the standardized estimates are
on the variances of the (continuous) latent variables only.
If <code>"std.all"</code>, the standardized estimates are based
on both the variances of both (continuous) observed and latent variables.
If <code>"std.nox"</code>, the standardized estimates are based
on both the variances of both (continuous) observed and latent variables, 
but not the variances of exogenous covariates.</p>
</td></tr>
<tr><td><code id="standardizedSolution_+3A_se">se</code></td>
<td>
<p>Logical. If TRUE, standard errors for the standardized parameters
will be computed, together with a z-statistic and a p-value.</p>
</td></tr>
<tr><td><code id="standardizedSolution_+3A_zstat">zstat</code></td>
<td>
<p>Logical. If <code>TRUE</code>, an extra column is added containing
the so-called z-statistic, which is simply the value of the estimate divided
by its standard error.</p>
</td></tr>
<tr><td><code id="standardizedSolution_+3A_pvalue">pvalue</code></td>
<td>
<p>Logical. If <code>TRUE</code>, an extra column is added containing
the pvalues corresponding to the z-statistic, evaluated under a standard
normal distribution.</p>
</td></tr>
<tr><td><code id="standardizedSolution_+3A_ci">ci</code></td>
<td>
<p>If <code>TRUE</code>, simple symmetric confidence intervals are added to 
the output</p>
</td></tr>
<tr><td><code id="standardizedSolution_+3A_level">level</code></td>
<td>
<p>The confidence level required.</p>
</td></tr>
<tr><td><code id="standardizedSolution_+3A_cov.std">cov.std</code></td>
<td>
<p>Logical. If TRUE, the (residual) observed
covariances are scaled by the square root of the &lsquo;Theta&rsquo; diagonal elements, and
the (residual) latent covariances are scaled by the square root of the &lsquo;Psi&rsquo;
diagonal elements. If FALSE, the (residual) observed covariances
are scaled by the square root of the diagonal elements of the observed
model-implied covariance matrix (Sigma), and the (residual) latent covariances
are scaled by the square root of diagonal elements of the model-implied
covariance matrix of the latent variables.</p>
</td></tr>
<tr><td><code id="standardizedSolution_+3A_remove.eq">remove.eq</code></td>
<td>
<p>Logical. If TRUE, filter the output by removing all rows 
containing equality constraints, if any.</p>
</td></tr>
<tr><td><code id="standardizedSolution_+3A_remove.ineq">remove.ineq</code></td>
<td>
<p>Logical. If TRUE, filter the output by removing all
rows containing inequality constraints, if any.</p>
</td></tr>
<tr><td><code id="standardizedSolution_+3A_remove.def">remove.def</code></td>
<td>
<p>Logical. If TRUE, filter the ouitput by removing all
rows containing parameter definitions, if any.</p>
</td></tr>
<tr><td><code id="standardizedSolution_+3A_glist">GLIST</code></td>
<td>
<p>List of model matrices. If provided, they will be used
instead of the GLIST inside the object@Model slot. Only works if the
<code>est</code> argument is also provided. See Note.</p>
</td></tr>
<tr><td><code id="standardizedSolution_+3A_est">est</code></td>
<td>
<p>Numeric. Parameter values (as in the &lsquo;est&rsquo; column of a
parameter table). If provided, they will be used instead of 
the parameters that can be extract from object. Only works if the <code>GLIST</code> 
argument is also provided. See Note.</p>
</td></tr>
<tr><td><code id="standardizedSolution_+3A_partable">partable</code></td>
<td>
<p>A custom <code>list</code> or <code>data.frame</code> in which to store
the standardized parameter values. If provided, it will be used instead of 
the parameter table inside the object@ParTable slot.</p>
</td></tr>
<tr><td><code id="standardizedSolution_+3A_output">output</code></td>
<td>
<p>Character. If <code>"data.frame"</code>, the parameter table is
displayed as a standard (albeit lavaan-formatted) data.frame.
If <code>"text"</code> (or alias <code>"pretty"</code>), the parameter table is
prettyfied, and displayed with subsections (as used by the summary function).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing standardized model parameters.
</p>


<h3>Note</h3>

<p>The <code>est</code>, <code>GLIST</code>, and <code>partable</code> arguments are not meant for
everyday users, but for authors of external R packages that depend on
<code>lavaan</code>. Only to be used with great caution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- cfa(HS.model, data=HolzingerSwineford1939)
standardizedSolution(fit)
</code></pre>

<hr>
<h2 id='summary.efaList'>Summarizing EFA Fits</h2><span id='topic+summary.efaList'></span><span id='topic+efaList'></span><span id='topic+print.efaList.summary'></span>

<h3>Description</h3>

<p>S3 summary and print methods for class <code>efaList</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'efaList'
summary(object,
        nd = 3L, cutoff = 0.3, dot.cutoff = 0.1, alpha.level = 0.01,
        lambda = TRUE, theta = TRUE, psi = TRUE, fit.table = TRUE,
        fs.determinacy = FALSE, eigenvalues = TRUE, sumsq.table = TRUE, 
        lambda.structure = FALSE, se = FALSE, zstat = FALSE,
        pvalue = FALSE, ...)

## S3 method for class 'efaList.summary'
print(x, nd = 3L, cutoff = 0.3, dot.cutoff = 0.1,
               alpha.level = 0.01, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.efaList_+3A_object">object</code></td>
<td>
<p>An object of class <code>efaList</code>, usually, a result of a call
to <code><a href="#topic+efa">efa</a></code> with (the default) <code>output = "efa"</code>.</p>
</td></tr>
<tr><td><code id="summary.efaList_+3A_x">x</code></td>
<td>
<p>An object of class <code>summary.efaList</code>, usually, a result of a 
call to <code>summary.efaList</code>.</p>
</td></tr>
<tr><td><code id="summary.efaList_+3A_nd">nd</code></td>
<td>
<p>Integer. The number of digits that are printed after the decimal 
point in the output.</p>
</td></tr>
<tr><td><code id="summary.efaList_+3A_cutoff">cutoff</code></td>
<td>
<p>Numeric. Factor loadings smaller that this value (in absolute
value) are not printed
(even if they are significantly different from zero). The idea is that
only medium to large factor loadings are printed, to better see the
overall structure.</p>
</td></tr>
<tr><td><code id="summary.efaList_+3A_dot.cutoff">dot.cutoff</code></td>
<td>
<p>Numeric. Factor loadings larger (in absolute value) 
than this value, but smaller (in absolute value) than the cutoff value 
are shown as a dot. They represent small loadings that may still need your
attention.</p>
</td></tr>
<tr><td><code id="summary.efaList_+3A_alpha.level">alpha.level</code></td>
<td>
<p>Numeric. If the the p-value of a factor loading is smaller
than this value, a significance star is printed to the right of the 
factor loading. To switch this off, use <code>alpha.level = 0</code>.</p>
</td></tr>
<tr><td><code id="summary.efaList_+3A_lambda">lambda</code></td>
<td>
<p>Logical. If <code>TRUE</code>, include the (standardized) factor 
loadings in the summary.</p>
</td></tr>
<tr><td><code id="summary.efaList_+3A_theta">theta</code></td>
<td>
<p>Logical. If <code>TRUE</code>, include the unique variances and
the communalities in the table of factor loadings.</p>
</td></tr>
<tr><td><code id="summary.efaList_+3A_psi">psi</code></td>
<td>
<p>Logical. If <code>TRUE</code>, include the factor correlations in the 
summary. Ignored if only a single factor is used.</p>
</td></tr>
<tr><td><code id="summary.efaList_+3A_fit.table">fit.table</code></td>
<td>
<p>Logical. If <code>TRUE</code>, show fit information for each
model.</p>
</td></tr>
<tr><td><code id="summary.efaList_+3A_fs.determinacy">fs.determinacy</code></td>
<td>
<p>Logical. If <code>TRUE</code>, show the factor score
determinacy values per factor (assuming regression factor scores are used)
and their squared values.</p>
</td></tr>
<tr><td><code id="summary.efaList_+3A_eigenvalues">eigenvalues</code></td>
<td>
<p>Logical. If <code>TRUE</code>, include the eigenvalues of the
sample variance-covariance matrix in the summary.</p>
</td></tr>
<tr><td><code id="summary.efaList_+3A_sumsq.table">sumsq.table</code></td>
<td>
<p>Logical. If <code>TRUE</code>, include a table including sums
of squares of factor loadings (and related measures) in the summary.
The sums of squares are computed as the
diagonal elements of Lambda times Psi (where Psi is the matrix of
factor correlations.).
If orthogonal rotation was used, Psi is diagonal and the sums of 
squares are identical to the sums of the squared column elements of the 
Lambda matrix (i.e., the factor loadings). This is no longer the case
when obique rotation has been used. But in both cases (orthgonal or
oblique), the (total) sum of the sums of squares equals the sum of the
communalities. In the second row of the table (Proportion of total), 
the sums of squares are divided by the total. In the third row of the 
table (Proportion var), the sums of squares are divided by the 
number of items.</p>
</td></tr>
<tr><td><code id="summary.efaList_+3A_lambda.structure">lambda.structure</code></td>
<td>
<p>Logical. If <code>TRUE</code>, show the structure matrix
(i.e., the factor loadings multiplied by the factor correlations).</p>
</td></tr>
<tr><td><code id="summary.efaList_+3A_se">se</code></td>
<td>
<p>Logical. If <code>TRUE</code>, include the standard errors of the 
standardized lambda, theta and psi elements in the summary.</p>
</td></tr>
<tr><td><code id="summary.efaList_+3A_zstat">zstat</code></td>
<td>
<p>Logical. If <code>TRUE</code>, include the Z-statistics of the 
standardized lambda, theta and psi elements in the summary.</p>
</td></tr>    
<tr><td><code id="summary.efaList_+3A_pvalue">pvalue</code></td>
<td>
<p>Logical. If <code>TRUE</code>, include the P-values of the 
standardized lambda, theta and psi elements in the summary.</p>
</td></tr>
<tr><td><code id="summary.efaList_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>summary.efaList</code> computes and returns a list of 
summary statistics for the list of EFA models in <code>object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The famous Holzinger and Swineford (1939) example
fit &lt;- efa(data = HolzingerSwineford1939, 
           ov.names = paste("x", 1:9, sep = ""),
           nfactors = 1:3,
           rotation = "geomin",
           rotation.args = list(geomin.epsilon = 0.01, rstarts = 1))
summary(fit, nd = 3L, cutoff = 0.2, dot.cutoff = 0.05,
        lambda.structure = TRUE, pvalue = TRUE)
</code></pre>

<hr>
<h2 id='varTable'>Variable Table</h2><span id='topic+varTable'></span><span id='topic+vartable'></span><span id='topic+variableTable'></span><span id='topic+variabletable'></span>

<h3>Description</h3>

<p>Summary information about the variables included in either a data.frame, 
or a fitted lavaan object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>varTable(object, ov.names = names(object), ov.names.x = NULL, 
    ordered = NULL, factor = NULL, as.data.frame. = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varTable_+3A_object">object</code></td>
<td>
<p>Either a data.frame, or an object of class 
<code><a href="#topic+lavaan-class">lavaan</a></code>.</p>
</td></tr>
<tr><td><code id="varTable_+3A_ov.names">ov.names</code></td>
<td>
<p>Only used if object is a data.frame. A character vector containing the variables that need to be summarized.</p>
</td></tr>
<tr><td><code id="varTable_+3A_ov.names.x">ov.names.x</code></td>
<td>
<p>Only used if object is a data.frame. A character vector containing additional variables that need to be summarized.</p>
</td></tr>
<tr><td><code id="varTable_+3A_ordered">ordered</code></td>
<td>
<p>Character vector. Which variables should be treated as ordered
factors</p>
</td></tr>
<tr><td><code id="varTable_+3A_factor">factor</code></td>
<td>
<p>Character vector. Which variables should be treated as (unordered) factors?</p>
</td></tr>
<tr><td><code id="varTable_+3A_as.data.frame.">as.data.frame.</code></td>
<td>
<p>If TRUE, return the list as a data.frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> or <code>data.frame</code> containing summary information about
variables in a data.frame. If <code>object</code> is a fitted lavaan object,
it displays the summary information about the observed variables that are
included in the model. The summary information includes
variable type (numeric, ordered, ...), the number of non-missing values,
the mean and variance for numeric variables, the number of levels of 
ordered variables, and the labels for ordered variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- cfa(HS.model, data=HolzingerSwineford1939)
varTable(fit)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
