<!DOCTYPE html><html lang="en"><head><title>Help for package ergMargins</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ergMargins}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#edge.prob2'><p>Function to compute tie probabilities for each dyad.</p></a></li>
<li><a href='#ergm.AME'>
<p>Function to compute average marginal effects in ERGM.</p></a></li>
<li><a href='#ergm.MEM'>
<p>Function to compute marginal effects at means in ERGM.</p></a></li>
<li><a href='#ergm.mma'>
<p>Function to conduct marginal effects mediation analysis in ERGM.</p></a></li>
<li><a href='#ergm.mod.mma'><p>Function to assess mediated moderation using marginal effects in ERGM.</p></a></li>
<li><a href='#vif.ergm'>
<p>Function to diagnose multicollinearity in ERGM.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Process Analysis for Exponential Random Graph Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Scott Duxbury &lt;duxbury@email.unc.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates marginal effects and conducts process analysis in exponential family random graph models (ERGM).
    Includes functions to conduct mediation and moderation analyses and to diagnose
    multicollinearity.
    URL: <a href="https://github.com/sduxbury/ergMargins">https://github.com/sduxbury/ergMargins</a>.
    BugReports: <a href="https://github.com/sduxbury/ergMargins/issues">https://github.com/sduxbury/ergMargins/issues</a>.
    Duxbury, Scott W (2021) &lt;<a href="https://doi.org/10.1177%2F0049124120986178">doi:10.1177/0049124120986178</a>&gt;.
    Long, J. Scott, and Sarah Mustillo (2018) &lt;<a href="https://doi.org/10.1177%2F0049124118799374">doi:10.1177/0049124118799374</a>&gt;.
    Mize, Trenton D. (2019) &lt;<a href="https://doi.org/10.15195%2Fv6.a4">doi:10.15195/v6.a4</a>&gt;.
    Karlson, Kristian Bernt, Anders Holm, and Richard Breen (2012) &lt;<a href="https://doi.org/10.1177%2F0081175012444861">doi:10.1177/0081175012444861</a>&gt;.
    Duxbury, Scott W (2018) &lt;<a href="https://doi.org/10.1177%2F0049124118782543">doi:10.1177/0049124118782543</a>&gt;.
    Duxbury, Scott W, Jenna Wertsching (2023) &lt;<a href="https://doi.org/10.1016%2Fj.socnet.2023.02.003">doi:10.1016/j.socnet.2023.02.003</a>&gt;.
    Huang, Peng, Carter Butts (2023) &lt;<a href="https://doi.org/10.1016%2Fj.socnet.2023.07.001">doi:10.1016/j.socnet.2023.07.001</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>numDeriv, stats, ergm, Matrix, btergm, parallel, dplyr, sna,
network, sampling</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, knitr, rmarkdown, methods, statnet.common, Rcpp,
ergm.count</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-11 13:15:29 UTC; Scott D</td>
</tr>
<tr>
<td>Author:</td>
<td>Scott Duxbury [aut, cre, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-08 21:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='edge.prob2'>Function to compute tie probabilities for each dyad.
</h2><span id='topic+edge.prob2'></span>

<h3>Description</h3>

<p>Computes tie probabilities for each dyad. Largely a wrapper for edgeprob() in btergm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge.prob2(model,verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edge.prob2_+3A_model">model</code></td>
<td>
<p> model is the ergm object.
</p>
</td></tr>
<tr><td><code id="edge.prob2_+3A_verbose">verbose</code></td>
<td>
<p>Boolean operator. If set to T, updates user on progress of edge.prob2. May be useful for large networks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes tie probabilities for each dyad in the ERGM sample space.This function is largely a wrapper for the edgeprob function in btergm, but can be applied to curved ERGMs.
</p>


<h3>Value</h3>

<p>Returns a dataframe where weach row is a dyad and each column is a term in the model, an identification variable for the vertices/dyads, or the estimated probability of observing a tie. See edgeprob() in btergm for more details.
</p>


<h3>Author(s)</h3>

<p>Scott Duxbury, Assistant Professor, University of North Carolina&ndash;Chapel Hill, Department of Sociology.
original author is Philip Leifeld at University of Essex.
</p>


<h3>See Also</h3>

<p><code><a href="btergm.html#topic+edgeprob">edgeprob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(ergm)


data("faux.dixon.high")


my.ergm&lt;-ergm(faux.dixon.high~edges+
                nodeifactor("sex")+
                nodeofactor("sex")+
                nodematch("sex")+
                mutual)
edge.prob2(my.ergm)

</code></pre>

<hr>
<h2 id='ergm.AME'>
Function to compute average marginal effects in ERGM.</h2><span id='topic+ergm.AME'></span>

<h3>Description</h3>

<p>ERGM function to compute average marginal effects for main effects or at various levels of a moderator. Also provides tests of significance for second differences for interaction terms. Currently accepts <code>ergm</code>, <code>btergm</code>, <code>mtergm</code>, <code>ergm.count</code>, <code>mlergm</code>, and <code>ergm.multi</code> objects. See ergm.MEM to compute marginal effects at means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm.AME(model,var1,var2=NULL,inter=NULL, at.2=NULL,  at.controls=NULL,
                   control_vals=NULL,return.dydx=FALSE,
        return.at.2=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ergm.AME_+3A_model">model</code></td>
<td>
<p>the ergm object to be analyzed.
</p>
</td></tr>
<tr><td><code id="ergm.AME_+3A_var1">var1</code></td>
<td>
<p>the character string containing the name of the focal variable on which to compute the average marginal effect. If var2 is NULL, this is the average marginal effect.</p>
</td></tr>
<tr><td><code id="ergm.AME_+3A_var2">var2</code></td>
<td>
<p>if examining moderation, the character string containing the name of the moderator variable. Default value is NULL.</p>
</td></tr>
<tr><td><code id="ergm.AME_+3A_inter">inter</code></td>
<td>
<p>if examining moderation, the character string containing the name of the interaction between var1 and var2. Default value is NULL.</p>
</td></tr>
<tr><td><code id="ergm.AME_+3A_at.2">at.2</code></td>
<td>
<p>the levels of var2 at which to compute the average marginal effects. If var2=NULL, this parameter is ignored. If var2!=NULL and at.2=NULL, the function computes the AME at each unique value of var2. at.2 can also be set to meaningful values, such as the mean of var2 or other discrete values of interest. If var2 is discrete, leaving at.2 NULL will compute the AME for each discrete category of the moderator variable. It is usually safe to leave at.2=NULL unless examining a large network where var2 has a large number of unique values, in which case computation times can be restrictive.</p>
</td></tr>
<tr><td><code id="ergm.AME_+3A_at.controls">at.controls</code></td>
<td>
<p>A character string containing the names of all control variables to be specified at fixed levels when calculating the marginal effect. Should match ERGM output exactly.</p>
</td></tr>
<tr><td><code id="ergm.AME_+3A_control_vals">control_vals</code></td>
<td>
<p>A vector specifying the values to hold at.controls variables. Ignored if at.controls = NULL</p>
</td></tr>
<tr><td><code id="ergm.AME_+3A_return.dydx">return.dydx</code></td>
<td>
<p>logical parameter indicating whether to return the marginal effects for each dyad. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="ergm.AME_+3A_return.at.2">return.at.2</code></td>
<td>
<p>logical parameter indicating whether to return the levels of at.2 as part of the output list object. Default value is F. Intended primarily for internal use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the AME for variables specified. If var2 and inter are left at NULL, this is the simple AME. All AMEs are computed as tie probabilities (not on the linear scale). Standard errors are estimated using the Delta method. If a moderator is specified using var2 and inter, a table of AMEs is returned at each level of at.2. If at.2=NULL, this is computed for every unique level of var2. So, if var2 has many levels and the model is complex, run times may be restrictive when at.2 is left NULL.
</p>
<p>When at.2 and var2 are specified, a table of second differences is also returned. The table of second differences assesses whether the difference in marginal effects is significant between levels of a moderator (values of at.2). If the moderator is binary, the second difference tests the overall significance of an interaction. The tests statistic is a Wald test.
</p>
<p>If more than 2 values of at.2 are specified, the function also computes the average absolute Wald test statistic and average second difference. The average second difference measures the average change in the AME of var1 between levels of a moderator. The average absolute Wald test is the mean absolute value of the Wald tests for all second differences. It assesses whether, on average, there is a significant difference between the second differences and zero. A significant result means the interaction is significant.
</p>
<p>Note that when an interaction term is an absolute difference between nodal covariates, ergm.AME holds the value of var1 at its mean. This is because the partial derivative for the absolute difference between covariates treats allows var1 to vary, which tells us little about tendencies towards tie variables when two nodal covariates are at similar values. Thus, the mean is used as a representative value at which to compute the AME for absolute differences.
</p>
<p>If at.controls and control_vals are provided, the AME is calculated while holding specified control variables at fixed values provided in control_vals, rather than their observed vales.
</p>


<h3>Value</h3>

<p>If var2 and inter=NULL, then a table is returned with the AME for var1, its standard error, and test statistic. Note again that all AMEs are in the metric of tie probabilities, not log-odds.
</p>
<p>If a moderator is specified, a list is returned with the following elements:
</p>
<table role = "presentation">
<tr><td><code>`Average Marginal Effects`</code></td>
<td>
<p>is the table of AMEs at each level of at.2. If at.2=NULL, the table contains unique entries for every unique value of at.2.</p>
</td></tr>
<tr><td><code>`Second differences`</code></td>
<td>
<p>is a table containing point estimates, standard errors, and Wald tests for the difference in AMEs between each level of at.2. It has a number of rows equal to length(at.2)-1</p>
</td></tr>
<tr><td><code>`Aggregate output`</code></td>
<td>
<p>is a table of summary statistics when at.2 has length &gt; 2. Reports the mean second difference and mean absolute Wald statistic for the second differences. If at.2 has length &lt; 3, it is not returned</p>
</td></tr>
<tr><td><code>`Marginal effects`</code></td>
<td>
<p>if return.dydx=TRUE, returns the marginal effects (partial derivatives with respect to var1) for each dyad in the ERGM sample space.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>Note that AMEs can take a long time to estimate in large networks or high dimensional models. If AME computation time proves to be restrictive, see the ergm.MEM function, which computes marginal effects at means.</p>


<h3>Note</h3>

<p>Syntax is loosely based on the margins package by Thomas Leeper and Stata's margins commands. Currently only available for two-way interactions.</p>


<h3>Author(s)</h3>

<p>Scott Duxbury, Assistant Professor, University of North Carolina&ndash;Chapel Hill, Department of Sociology.
</p>


<h3>References</h3>

<p>Duxbury, Scott W. Forthcoming. &quot;The Problem of Scaling in Exponential Random Graph Models.&quot; <em>Sociological Methods &amp; Research</em>.
</p>
<p>Long, J. Scott, and Sarah Mustillo. 2018. &quot;Using Predictions and Marginal Effects to Compare Groups in Regression Models for Binary Outcomes.&quot; <em>Sociological Methods and Research</em>
</p>
<p>Mize, Trenton D. 2019. &quot;Best Practices for Estimating, Interpreting, and Presenting Nonlinear Interaction Effects.&quot; <em>Sociological Science</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergm.MEM">ergm.MEM</a></code>
<code><a href="#topic+ergm.mma">ergm.mma</a></code>
<code><a href="margins.html#topic+margins">margins</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


library(ergm)


data("faux.dixon.high")


set.seed(21093)

my.ergm&lt;-ergm(faux.dixon.high~edges+
                nodeicov("grade")+
                nodeocov("grade")+
                nodeifactor("sex")+
                nodeofactor("sex")+
                absdiff("grade")+
                nodematch("sex")+
                mutual)

#main effect
main.eff&lt;-ergm.AME(my.ergm,"mutual")

#main effect of "mutual" when sender and receiver effects for sex == 1
ergm.AME(my.ergm,"mutual",
              at.controls=c("nodeifactor.sex.2","nodeofactor.sex.2"),
              control_vals=c(1,1))


##with moderator
sex.inter&lt;-ergm.AME(my.ergm,"nodeifactor.sex.2","nodeofactor.sex.2","nodematch.sex")

##with moderator at specific values
grade.inter&lt;-ergm.AME(my.ergm,"nodeicov.grade","nodeocov.grade","absdiff.grade",
            at.2=c(9,12))

##when moderator changes from mean to mean +sd

tie.probs&lt;-edge.prob2(my.ergm)
m&lt;-mean(tie.probs$nodeocov.grade)
m.sd&lt;-m+sd(tie.probs$nodeocov.grade)

grade.inter.at.means&lt;-ergm.AME(my.ergm,"nodeicov.grade","nodeocov.grade",
                              "absdiff.grade",at.2=c(m,m.sd))







</code></pre>

<hr>
<h2 id='ergm.MEM'>
Function to compute marginal effects at means in ERGM.
</h2><span id='topic+ergm.MEM'></span>

<h3>Description</h3>

<p>ERGM function to compute marginal effects at means for main effects or at various levels of a moderator. Also provides tests of significance for second differences for interaction terms. Currently accepts <code>ergm</code>, <code>btergm</code>, <code>mtergm</code>, <code>ergm.count</code>, <code>mlergm</code>, and <code>ergm.multi</code> objects. See ergm.AME to compute average marginal effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm.MEM(model,var1,var2=NULL,inter=NULL,at.2=NULL,
                at.controls=NULL, control_vals=NULL,
            return.dydx=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ergm.MEM_+3A_model">model</code></td>
<td>
<p>the ergm object to be analyzed.
</p>
</td></tr>
<tr><td><code id="ergm.MEM_+3A_var1">var1</code></td>
<td>
<p>the character string containing the name of the focal variable on which to compute the MEM. If var2 is NULL, this is the simple MEM.</p>
</td></tr>
<tr><td><code id="ergm.MEM_+3A_var2">var2</code></td>
<td>
<p>the character string containing the name of the moderator variable. Default value is NULL.</p>
</td></tr>
<tr><td><code id="ergm.MEM_+3A_inter">inter</code></td>
<td>
<p>the character string containing the name of the interaction between var1 and var2. Default value is NULL.</p>
</td></tr>
<tr><td><code id="ergm.MEM_+3A_at.2">at.2</code></td>
<td>
<p>the levels of var2 at which to compute the MEMs. If var2=NULL, this parameter is ignored. If var2!=NULL and at.2=NULL, the function computes the AME at each unique value of var2. at.2 can also be set to meaningful values, such as the mean of var2 or other discrete values of interest. If var2 is discrete, leaving at.2 NULL will compute the AME for each discrete category of the moderator variable. It is usually safe to leave at.2=NULL unless examining a large network where var2 has a large number of unique values, in which case computation times can be restrictive.</p>
</td></tr>
<tr><td><code id="ergm.MEM_+3A_at.controls">at.controls</code></td>
<td>
<p>A character string containing the names of all control variables to be specified at fixed levels when calculating the marginal effect. Should match ERGM output exactly.</p>
</td></tr>
<tr><td><code id="ergm.MEM_+3A_control_vals">control_vals</code></td>
<td>
<p>A vector specifying the values to hold at.controls variables. Ignored if at.controls = NULL</p>
</td></tr>
<tr><td><code id="ergm.MEM_+3A_return.dydx">return.dydx</code></td>
<td>
<p>logical parameter indicating whether to return the marginal effects for each dyad observation. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Largely a wrapper for ergm.AME. The only difference is that marginal effects are computed at variable means.
</p>
<p>Computes the MEM for variables specified. If var2 and inter are left at NULL, this is the simple MEM. All MEMs are computed as tie probabilities (not on the linear scale). Standard errors are computed using the Delta method. If a moderator is specified using var2 and inter, a table of MEMs is returned at each level of at.2. If at.2=NULL, this is computed for every unique level of var2.
</p>
<p>When at.2 and var2 are specified, a table of second differences is also returned. The table of second differences assesses whether the difference in marginal effects is significant between levels of a moderator (values of at.2). If the moderator is binary, the second difference tests the overall significance of an interaction. The tests statistic is a Wald test.
</p>
<p>If more than 2 values of at.2 are specified, the function also computes the average absolute Wald test statistic and average second difference. The average second difference measures the average change in the MEM of var1 between levels of a moderator. The average absolute Wald test is the mean absolute value of the Wald tests for all second differences. It assesses whether, on average, there is a significant difference between the second differences and zero. A significant result means the interaction is significant.
</p>
<p>If at.controls and control_vals are provided, the MEM is calculated while holding specified control variables at fixed values provided in control_vals, rather than at their means
</p>


<h3>Value</h3>

<p>If var2 and inter=NULL, then a table is returned with the MEM for var1, its standard error, and test statistic. Note again that all MEMs are in the metric of tie probabilities, not log-odds. If a moderator is specified, a list is returned with the following elements:
</p>
<table role = "presentation">
<tr><td><code>`Marginal effects at means`</code></td>
<td>
<p>is the table of MEMs at each level of at.2. If at.2=NULL, the table contains unique entries for every unique value of at.2.</p>
</td></tr>
<tr><td><code>`Second differences`</code></td>
<td>
<p>is a table containing point estimates, standard errors, and Wald tests for the difference in MEMs between each level of at.2. It has a number of rows equal to length(at.2)-1</p>
</td></tr>
<tr><td><code>`Aggregate output`</code></td>
<td>
<p>is a table of summary statistics when at.2 has length &gt; 2. Reports the mean second difference and mean absolute Wald statistic for the second differences. If at.2 has length&lt;3, it is not returned</p>
</td></tr>
<tr><td><code>`Marginal effects`</code></td>
<td>
<p>if return.dydx=TRUE, returns the marginal effects (partial derivatives with respect to var1) for each dyad in the ERGM sample space.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Syntax is loosely based on the margins package by Thomas Leeper and Stata's margins commands. See ergm.AME to compute average marginal effects. Currently only considers two-ways interactions.</p>


<h3>Author(s)</h3>

<p>Scott Duxbury, Assistant Professor, University of North Carolina&ndash;Chapel Hill, Department of Sociology.
</p>


<h3>References</h3>

<p>Duxbury, Scott W. Forthcoming. &quot;The Problem of Scaling in Exponential Random Graph Models.&quot; <em>Sociological Methods &amp; Research</em>.
</p>
<p>Long, J. Scott, and Sarah Mustillo. 2018. &quot;Using Predictions and Marginal Effects to Compare Groups in Regression Models for Binary Outcomes.&quot; <em>Sociological Methods and Research</em>
</p>
<p>Mize, Trenton D. 2019. &quot;Best Practices for Estimating, Interpreting, and Presenting Nonlinear Interaction Effects.&quot; <em>Sociological Science</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergm.AME">ergm.AME</a></code>
<code><a href="#topic+ergm.mma">ergm.mma</a></code>
<code><a href="margins.html#topic+margins">margins</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


library(ergm)


data("faux.dixon.high")


set.seed(21093)

my.ergm&lt;-ergm(faux.dixon.high~edges+
                nodeicov("grade")+
                nodeocov("grade")+
                nodeifactor("sex")+
                nodeofactor("sex")+
                absdiff("grade")+
                nodematch("sex")+
                mutual)

#main effect
main.eff&lt;-ergm.MEM(my.ergm,"mutual")

#main effect of "mutual" when sender and receiver effects for sex == 1
ergm.MEM(my.ergm,"mutual",
              at.controls=c("nodeifactor.sex.2","nodeofactor.sex.2"),
              control_vals=c(1,1))


##with moderator
sex.inter&lt;-ergm.MEM(my.ergm,"nodeifactor.sex.2","nodeofactor.sex.2","nodematch.sex")

##with moderator at specific levels
grade.inter&lt;-ergm.MEM(my.ergm,"nodeicov.grade","nodeocov.grade","absdiff.grade",
          at.2=c(9,12))

##when moderator changes from mean to mean +sd
tie.probs&lt;-edge.prob2(my.ergm)
m&lt;-mean(tie.probs$nodeocov.grade)
m.sd&lt;-m+sd(tie.probs$nodeocov.grade)

grade.inter.at.means&lt;-ergm.MEM(my.ergm,"nodeicov.grade","nodeocov.grade",
                            "absdiff.grade",at.2=c(m,m.sd))



</code></pre>

<hr>
<h2 id='ergm.mma'>
Function to conduct marginal effects mediation analysis in ERGM.
</h2><span id='topic+ergm.mma'></span>

<h3>Description</h3>

<p>ergm.mma is a function to conduct mediation analysis in ERGM using marginal effects. It computes the total, direct, and indirect average marginal effects for two nested ERGMs fit to the same data. Can be used with discrete or continuous mediators and for multiple mediator analyses. Currently accepts <code>ergm</code>, <code>btergm</code>, <code>mtergm</code>, <code>ergm.count</code>, <code>mlergm</code>, and <code>ergm.multi</code> objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm.mma(restricted.model,full.model,direct.effect,mediator,
                  at.controls=NULL, control_vals=NULL,ME="AME")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ergm.mma_+3A_restricted.model">restricted.model</code></td>
<td>
<p>the ergm without the mediator variable.
</p>
</td></tr>
<tr><td><code id="ergm.mma_+3A_full.model">full.model</code></td>
<td>
<p>the ergm including the mediator variable.</p>
</td></tr>
<tr><td><code id="ergm.mma_+3A_mediator">mediator</code></td>
<td>
<p>a character string containing the name of the mediator variable. When examining joint mediation with multiple mediators, this is a vector with each entry containing the character strings for each mediator variable.</p>
</td></tr>
<tr><td><code id="ergm.mma_+3A_direct.effect">direct.effect</code></td>
<td>
<p>a character string containing the name of the direct effect.</p>
</td></tr>
<tr><td><code id="ergm.mma_+3A_at.controls">at.controls</code></td>
<td>
<p>a vector of character strings containing the names of control variables to hold at prespecified values.</p>
</td></tr>
<tr><td><code id="ergm.mma_+3A_control_vals">control_vals</code></td>
<td>
<p>a vector of numeric values to hold at.controls at during estimation.</p>
</td></tr>
<tr><td><code id="ergm.mma_+3A_me">ME</code></td>
<td>
<p>the type of marginal effect to calculate. Currently accepts either &quot;AME&quot; or &quot;MEM&quot;. Defaul it &quot;AME&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ergm.mma conducts marginal effects mediation analysis for nested ERGMs fit to the same network by computing the change in average marginal effects between models. The AMEs are estimated on the scale of tie probabilities, not the linear component (log-odds). Standard errors are computed using the Delta method.
</p>
<p>A few notes on using ergm.mma:
</p>

<ul>
<li><p> ergm.mma default specification uses the AME, which can be computationally intensive in large networks or high dimensional models. If run times are an issue, try specifying ME=&quot;MEM&quot;.
</p>
</li>
<li><p> ergm.mma can be applied to discrete mediators or multiple mediator analysis.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a table including the point estimates and standard errors for total, direct, and indirect effects. A single indirect effect is reported for joint mediation analyses. All marginal effects are computed on the scale of tie probabilities, not the linear component (log-odds).
</p>


<h3>Note</h3>

<p>Note that ergm.mma may have restrictive run times in large networks or high dimensional models.
</p>


<h3>Author(s)</h3>

<p>Scott Duxbury, Assistant Professor, University of North Carolina&ndash;Chapel Hill, Department of Sociology.
</p>


<h3>References</h3>

<p>Duxbury, Scott W. Forthcoming. &quot;The Problem of Scaling in Exponential Random Graph Models.&quot; <em>Sociological Methods &amp; Research</em>.
</p>
<p>Karlson, Kristian Bernt, Holm, Anders, and Richard Breen. 2012. &quot;Comparing Regression Coefficients Between Same-sample Nested Models Using Logit and Probit: A New Method.&quot; <em>Sociological Methodology</em> 42: 286 - 313.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergm.AME">ergm.AME</a></code>
<code><a href="#topic+ergm.mod.mma">ergm.mod.mma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


library(ergm)


data("faux.mesa.high")

faux.mesa.high

set.seed(21093)

my.ergm1&lt;-ergm(faux.mesa.high~edges+
            nodecov("Grade")+
            nodefactor("Race")+
            nodefactor("Sex")+
            nodematch("Grade")+
            nodematch("Sex")+
            nodematch("Race"),
            estimate = "MLE")


set.seed(21093)

my.ergm2&lt;-ergm(faux.mesa.high~edges+
                nodecov("Grade")+
                nodefactor("Race")+
                nodefactor("Sex")+
                nodematch("Grade")+
                nodematch("Sex")+
                nodematch("Race")+
               gwesp(.5,fixed=TRUE))


###gwesp as single mediator
ergm.mma(my.ergm1,my.ergm2,mediator="gwesp.fixed.0.5",
             direct.effect="nodecov.Grade")


###multiple mediators

set.seed(21093)

my.ergm3&lt;-ergm(faux.mesa.high~edges+
                 nodecov("Grade")+
                 nodefactor("Race")+
                 nodefactor("Sex")+
                 nodematch("Grade")+
                 nodematch("Sex")+
                 nodematch("Race")+
                 gwdsp(1,fixed=TRUE)+
                 gwesp(.5,fixed=TRUE),
                 #increase MC sample to facilitate convergence
               control = control.ergm(MCMC.samplesize=5000)
)

##joint mediation for gwdsp and gwesp
ergm.mma(my.ergm2,my.ergm3,mediator=c("gwdsp.fixed.1","gwesp.fixed.0.5"),
         direct.effect=names(my.ergm3$coef[8]))


</code></pre>

<hr>
<h2 id='ergm.mod.mma'>Function to assess mediated moderation using marginal effects in ERGM.
</h2><span id='topic+ergm.mod.mma'></span>

<h3>Description</h3>

<p>ergm.mod.mma is a function to asssess mediated moderation in ERGM using average marginal effects (AME), e.g. when the main effect is a part of an interaction. If joint=TRUE, the function computes the total, partial, and indirect effects for all parts of the interaction. If int.eff=TRUE, the function computes the same values, but only for the moderating effect (e.g., only the moderated portion). Both joint=TRUE and int.eff=TRUE can be set simultaneously. Currently accepts <code>ergm</code>, <code>btergm</code>, <code>mtergm</code>, <code>ergm.count</code>, <code>mlergm</code>, and <code>ergm.multi</code> objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm.mod.mma(restricted.model,full.model,var1, var2, inter,mediator,
                   at.2=NULL,joint=FALSE,int.eff=FALSE,
                   at.controls=NULL, control_vals=NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ergm.mod.mma_+3A_restricted.model">restricted.model</code></td>
<td>
<p>the ergm without the mediator variable.
</p>
</td></tr>
<tr><td><code id="ergm.mod.mma_+3A_full.model">full.model</code></td>
<td>
<p>the ergm including the mediator variable.</p>
</td></tr>
<tr><td><code id="ergm.mod.mma_+3A_var1">var1</code></td>
<td>
<p>the character string containing the name of the main effect of the direct effect.</p>
</td></tr>
<tr><td><code id="ergm.mod.mma_+3A_var2">var2</code></td>
<td>
<p>the character string containing the name of the moderator variable for the direct effect.</p>
</td></tr>
<tr><td><code id="ergm.mod.mma_+3A_inter">inter</code></td>
<td>
<p>the character string containing the name of the interaction for the direct effect.</p>
</td></tr>
<tr><td><code id="ergm.mod.mma_+3A_at.2">at.2</code></td>
<td>
<p>the levels of var2 at which to compute the average marginal effects. If at.2=NULL, the function computes the AME at each unique value of var2. at.2 can also be set to meaningful values, such as the mean of var2 or other discrete values of interest. If var2 is discrete, leaving at.2 NULL will compute the AME for each discrete category of the moderator variable. It is usually safe to leave at.2=NULL unless examining a large network where var2 has a large number of unique values, in which case computation times can be restrictive.</p>
</td></tr>
<tr><td><code id="ergm.mod.mma_+3A_mediator">mediator</code></td>
<td>
<p>a character string containing the name of the mediator variable. When examining joint mediation with multiple mediators, this is a vector with each entry containing the character strings for each mediator variable.</p>
</td></tr>
<tr><td><code id="ergm.mod.mma_+3A_joint">joint</code></td>
<td>
<p>logical parameter indicates whether to compute the mediated composite effect.</p>
</td></tr>
<tr><td><code id="ergm.mod.mma_+3A_int.eff">int.eff</code></td>
<td>
<p>logical parameter indicating whether to compute the mediated effect <em>only</em> for the interaction, net of the main effect. Either int.eff or joint must be set to TRUE for function to work.</p>
</td></tr>
<tr><td><code id="ergm.mod.mma_+3A_at.controls">at.controls</code></td>
<td>
<p>a vector of character strings containing the names of control variables to hold at prespecified values.</p>
</td></tr>
<tr><td><code id="ergm.mod.mma_+3A_control_vals">control_vals</code></td>
<td>
<p>a vector of numeric values to hold at.controls at during estimation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ergm.mod.mma conducts mediation analyses using marginal effects when the main effect is part of an interaction. There are three ways to construe the mediating pathways. First, a researcher may be interested in whether a mediator variable mediates the main effect in an interaction, net of the moderator. To assess this, use ergm.mma for var1. This will compute the AME when the effect of the moderator is zero. Second, a researcher may be interested in the total or composite effect of an interaction, including the moderator and main effect. To assess this, set joint=TRUE. This computes the indirect effect for the AME at every level of at.2. The third scenario is when a researcher is interested in only the interaction effect. The interaction effect is defined here as the difference in AMEs between levels of a moderator (e.g., levels of at.2). Thus, the indirect effect is the third difference, or the difference in second differences between the restricted and full models. An example is whether triad closure mediates the effect of matched nodal characteristics, net of the main effect for nodal attributes (e.g., net of nodefactor/nodecov). To assess this, set int.eff=TRUE. Both joint=TRUE and int.eff=TRUE can be specified at the same time, but at least one must be specified for the function to work.
</p>


<h3>Value</h3>

<p>Returns a list object containing the total, partial, and indirect AMEs at each level of at.2. If joint=TRUE is specified, returns:
</p>
<table role = "presentation">
<tr><td><code>marginal.effects</code></td>
<td>
<p>a list containing the indirect, total, and partial effects for each level of at.2</p>
</td></tr>
<tr><td><code>summary.stats</code></td>
<td>
<p>a table reporting the mean second difference and mean absolute Wald statistic for the indirect AMEs.</p>
</td></tr>
</table>
<p>If int.eff=TRUE is specified, returns a list with elements:
</p>
<table role = "presentation">
<tr><td><code>partial.marginal.effects</code></td>
<td>
<p>the marginal effects for each level of at.2 in the full model.</p>
</td></tr>
<tr><td><code>total.marginal.effects</code></td>
<td>
<p>the marginal effects for each level of at.2 in the restricted model.</p>
</td></tr>
<tr><td><code>partial.second.diffs</code></td>
<td>
<p>the second differences between levels of at.2 in the full model.</p>
</td></tr>
<tr><td><code>total.second.diffs</code></td>
<td>
<p>the second differences between levels of at.2 in the restricted model.</p>
</td></tr>
<tr><td><code>third.diffs</code></td>
<td>
<p>the difference in second differences between the partial and full models.</p>
</td></tr>
<tr><td><code>summary.output</code></td>
<td>
<p>the mean third difference and mean absolute Wald statistic for the third differences.</p>
</td></tr>
</table>
<p>If both int.eff=TRUE and joint=TRUE, returns a list with elements:
</p>
<table role = "presentation">
<tr><td><code>joint.effect</code></td>
<td>
<p>a list containing all elements when joint=TRUE</p>
</td></tr>
<tr><td><code>moderator.effect</code></td>
<td>
<p>a list containing all elements when int.eff=TRUE.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Scott Duxbury, Assistant Professor, University of North Carolina&ndash;Chapel Hill, Department of Sociology.
</p>


<h3>References</h3>

<p>Duxbury, Scott W. Forthcoming. &quot;The Problem of Scaling in Exponential Random Graph Models.&quot; <em>Sociological Methods &amp; Research</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergm.AME">ergm.AME</a></code>
<code><a href="#topic+ergm.MEM">ergm.MEM</a></code>
<code><a href="#topic+ergm.mma">ergm.mma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


library(ergm)


data("faux.dixon.high")

faux.dixon.high


my.ergm&lt;-ergm(faux.dixon.high~edges+
                nodeifactor("sex")+
                nodeofactor("sex")+
                nodematch("sex"))

my.ergmb&lt;-ergm(faux.dixon.high~edges+
                nodeifactor("sex")+
                nodeofactor("sex")+
                nodematch("sex")+
                mutual)

summary(my.ergmb)


sex.mod.med&lt;-ergm.mod.mma(my.ergm,my.ergmb,var1="nodeifactor.sex.2",var2="nodeofactor.sex.2",
             inter="nodematch.sex",mediator="mutual",int.eff = TRUE,joint=TRUE)

</code></pre>

<hr>
<h2 id='vif.ergm'>
Function to diagnose multicollinearity in ERGM.</h2><span id='topic+vif.ergm'></span>

<h3>Description</h3>

<p>Computes the variance inflation factor from the covariance matrix of the ERGM estimator.</p>


<h3>Usage</h3>

<pre><code class='language-R'>vif.ergm(my.ergm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vif.ergm_+3A_my.ergm">my.ergm</code></td>
<td>
<p>an ergm object.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the variance inflation factor using the covariance matrix of the ERGM estimator. Values above 20 indicate the onset of moderate collinearity problems, values above 100 indicate that strong collinearity likely exists and may be problematizing the convergence of the Markov chain to the stationarity distribution. High VIFs alongside a near-singular Hessian matrix is a clear indicator of multicollinearity. Consider changing model specification in such cases.
</p>


<h3>Value</h3>

<p>Returns a matrix of VIFs for each model parameter. Higher values indicate that the variable in one column of the data matrix is highly correlated with a linear combination of the remaining model covariates. High VIFs can also arise from a large bivariate correlation.
</p>


<h3>Author(s)</h3>

<p>Scott Duxbury, Assistant Professor, University of North Carolina&ndash;Chapel Hill, Department of Sociology.
</p>


<h3>References</h3>

<p>Duxbury, Scott W. 2018. &quot;Diagnosing Multicollinearity in Exponential Random Graph Models&quot; <em>Sociological Methods and Research.</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(21093)

library(ergm)
data("faux.mesa.high")

my.ergm2&lt;-ergm(faux.mesa.high~edges+
                nodecov("Grade")+
                nodefactor("Race")+
                nodefactor("Sex")+
                nodematch("Grade")+
                nodematch("Sex")+
                nodematch("Race"))

vif.ergm(my.ergm2)

#to compute the tolerance instead of the VIF

tol&lt;-1/(vif.ergm(my.ergm2))

#to compute R squared
r.sq&lt;-1-tol

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
