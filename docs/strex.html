<!DOCTYPE html><html><head><title>Help for package strex</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {strex}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#before-and-after'><p>Extract text before or after <code>n</code>th occurrence of pattern.</p></a></li>
<li><a href='#currency'><p>Extract currency amounts from a string.</p></a></li>
<li><a href='#str_alphord_nums'><p>Make string numbers comply with alphabetical order.</p></a></li>
<li><a href='#str_before_last_dot'><p>Extract the part of a string before the last period.</p></a></li>
<li><a href='#str_can_be_numeric'><p>Check if a string could be considered as numeric.</p></a></li>
<li><a href='#str_detect_all'><p>Detect any or all patterns.</p></a></li>
<li><a href='#str_elem'><p>Extract a single character from a string, using its index.</p></a></li>
<li><a href='#str_elems'><p>Extract several single elements from a string.</p></a></li>
<li><a href='#str_extract_non_numerics'><p>Extract non-numbers from a string.</p></a></li>
<li><a href='#str_extract_numbers'><p>Extract numbers from a string.</p></a></li>
<li><a href='#str_give_ext'><p>Ensure a file name has the intended extension.</p></a></li>
<li><a href='#str_locate_braces'><p>Locate the braces in a string.</p></a></li>
<li><a href='#str_locate_nth'><p>Locate the indices of the <code>n</code>th instance of a pattern.</p></a></li>
<li><a href='#str_match_arg'><p>Argument Matching.</p></a></li>
<li><a href='#str_nth_non_numeric'><p>Extract the <code>n</code>th non-numeric substring from a string.</p></a></li>
<li><a href='#str_nth_number'><p>Extract the <code>n</code>th number from a string.</p></a></li>
<li><a href='#str_nth_number_after_mth'><p>Find the <code>n</code>th number after the <code>m</code>th occurrence of a pattern.</p></a></li>
<li><a href='#str_nth_number_before_mth'><p>Find the <code>n</code>th number before the <code>m</code>th occurrence of a pattern.</p></a></li>
<li><a href='#str_paste_elems'><p>Extract single elements of a string and paste them together.</p></a></li>
<li><a href='#str_remove_quoted'><p>Remove the quoted parts of a string.</p></a></li>
<li><a href='#str_singleize'><p>Remove back-to-back duplicates of a pattern in a string.</p></a></li>
<li><a href='#str_split_by_numbers'><p>Split a string by its numeric characters.</p></a></li>
<li><a href='#str_split_camel_case'><p>Split a string based on CamelCase.</p></a></li>
<li><a href='#str_to_vec'><p>Convert a string to a vector of characters</p></a></li>
<li><a href='#str_trim_anything'><p>Trim something other than whitespace</p></a></li>
<li><a href='#strex'><p><code>strex</code>: extra string manipulation functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Extra String Manipulation Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>There are some things that I wish were easier with the
    'stringr' or 'stringi' packages. The foremost of these is the
    extraction of numbers from strings. 'stringr' and 'stringi' make you
    figure out the regular expression for yourself; 'strex' takes care of
    this for you. There are many other handy functionalities in 'strex'.
    Contributions to this package are encouraged; it is intended as a
    miscellany of string manipulation functions that cannot be found in
    'stringi' or 'stringr'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rorynolan.github.io/strex/">https://rorynolan.github.io/strex/</a>,
<a href="https://github.com/rorynolan/strex">https://github.com/rorynolan/strex</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rorynolan/strex/issues">https://github.com/rorynolan/strex/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), stringr (&ge; 1.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate (&ge; 1.9.3), lifecycle, magrittr (&ge; 1.5), rlang (&ge;
1.0), stats, stringi (&ge; 1.7.8), utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bench, covr, knitr, purrr, rmarkdown, spelling, testthat (&ge;
3.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Biarch:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-31 16:01:02 UTC; rnolan</td>
</tr>
<tr>
<td>Author:</td>
<td>Rory Nolan <a href="https://orcid.org/0000-0002-5239-4043"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rory Nolan &lt;rorynoolan@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-31 17:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='before-and-after'>Extract text before or after <code>n</code>th occurrence of pattern.</h2><span id='topic+before-and-after'></span><span id='topic+str_after_nth'></span><span id='topic+str_after_first'></span><span id='topic+str_after_last'></span><span id='topic+str_before_nth'></span><span id='topic+str_before_first'></span><span id='topic+str_before_last'></span>

<h3>Description</h3>

<p>Extract the part of a string which is before or after the <code>n</code>th occurrence of
a specified pattern, vectorized over the string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_after_nth(string, pattern, n)

str_after_first(string, pattern)

str_after_last(string, pattern)

str_before_nth(string, pattern, n)

str_before_first(string, pattern)

str_before_last(string, pattern)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="before-and-after_+3A_string">string</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="before-and-after_+3A_pattern">pattern</code></td>
<td>
<p>The pattern to look for.
</p>
<p>The default interpretation is a regular expression, as described in
<a href="stringi.html#topic+about_search_regex">stringi::about_search_regex</a>.
</p>
<p>To match a without regular expression (i.e. as a human would), use
<a href="stringr.html#topic+modifiers">coll()</a>. For details see <code><a href="stringr.html#topic+modifiers">stringr::regex()</a></code>.</p>
</td></tr>
<tr><td><code id="before-and-after_+3A_n">n</code></td>
<td>
<p>A vector of integerish values. Must be either length 1 or
have length equal to the length of <code>string</code>. Negative indices count from
the back: while <code>n = 1</code> and <code>n = 2</code> correspond to first and second, <code>n = -1</code> and <code>n = -2</code> correspond to last and second-last. <code>n = 0</code> will return
<code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

 <ul>
<li> <p><code>str_after_first(...)</code> is just <code>str_after_nth(..., n = 1)</code>.
</p>
</li>
<li> <p><code>str_after_last(...)</code> is just <code>str_after_nth(..., n = -1)</code>. </p>
</li>
<li>
<p><code>str_before_first(...)</code> is just <code>str_before_nth(..., n = 1)</code>. </p>
</li>
<li>
<p><code>str_before_last(...)</code> is just <code>str_before_nth(..., n = -1)</code>. </p>
</li></ul>



<h3>Value</h3>

<p>A character vector.
</p>


<h3>See Also</h3>

<p>Other bisectors: 
<code><a href="#topic+str_before_last_dot">str_before_last_dot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>string &lt;- "abxxcdxxdexxfgxxh"
str_after_nth(string, "xx", 3)
str_before_nth(string, "e", 1:2)
str_before_nth(string, "xx", -3)
str_before_nth(string, ".", -3)
str_before_nth(rep(string, 2), "..x", -3)
str_before_first(string, "d")
str_before_last(string, "x")
string &lt;- c("abc", "xyz.zyx")
str_after_first(string, ".") # using regex
str_after_first(string, coll(".")) # using human matching
str_after_last(c("xy", "xz"), "x")
</code></pre>

<hr>
<h2 id='currency'>Extract currency amounts from a string.</h2><span id='topic+currency'></span><span id='topic+str_extract_currencies'></span><span id='topic+str_nth_currency'></span><span id='topic+str_first_currency'></span><span id='topic+str_last_currency'></span>

<h3>Description</h3>

<p>The currency of a number is defined as the character coming before the number
in the string. If nothing comes before (i.e. if the number is the first thing
in the string), the currency is the empty string, similarly the currency can
be a space, comma or any manner of thing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_extract_currencies(string)

str_nth_currency(string, n)

str_first_currency(string)

str_last_currency(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="currency_+3A_string">string</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="currency_+3A_n">n</code></td>
<td>
<p>A vector of integerish values. Must be either length 1 or
have length equal to the length of <code>string</code>. Negative indices count from
the back: while <code>n = 1</code> and <code>n = 2</code> correspond to first and second, <code>n = -1</code> and <code>n = -2</code> correspond to last and second-last. <code>n = 0</code> will return
<code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are vectorized over <code>string</code> and <code>n</code>.
</p>
<p><code><a href="#topic+str_extract_currencies">str_extract_currencies()</a></code> extracts all currency amounts.
</p>
<p><code>str_nth_currency()</code> just gets the <code>n</code>th currency amount from each string.
<code>str_first_currency(string)</code> and <code>str_last_currency(string)</code> are just
wrappers for <code>str_nth_currency(string, n = 1)</code> and <code>str_nth_currency(string, n = -1)</code>.
</p>
<p>&quot;-$2.00&quot; and &quot;$-2.00&quot; are interpreted as negative two dollars.
</p>
<p>If you request e.g. the 5th currency amount but there are only 3 currency
amounts, you get an amount and currency symbol of <code>NA</code>.
</p>


<h3>Value</h3>

<p>A data frame with 4 columns: <code>string_num</code>, <code>string</code>, <code>curr_sym</code> and
<code>amount</code>. Every extracted currency amount gets its own row in the data
frame detailing the string number and string that it was extracted from,
the currency symbol and the amount.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>string &lt;- c("ab3 13", "$1", "35.00 $1.14", "abc5 $3.8", "stuff")
str_extract_currencies(string)
str_nth_currency(string, n = 2)
str_nth_currency(string, n = -2)
str_nth_currency(string, c(1, -2, 1, 2, -1))
str_first_currency(string)
str_last_currency(string)
</code></pre>

<hr>
<h2 id='str_alphord_nums'>Make string numbers comply with alphabetical order.</h2><span id='topic+str_alphord_nums'></span>

<h3>Description</h3>

<p>If strings are numbered, their numbers may not <em>comply</em> with alphabetical
order, e.g. &quot;abc2&quot; comes after <code>"abc10"</code> in alphabetical order. We might (for
whatever reason) wish to change them such that they come in the order <em>that
we would like</em>. This function alters the strings such that they comply with
alphabetical order, so here <code>"abc2"</code> would be renamed to &quot;abc02&quot;. It works on
file names with more than one number in them e.g. <code>"abc01def3"</code> (a string
with 2 numbers). All the strings in the character vector <code>string</code> must have
the same number of numbers, and the non-number bits must be the same.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_alphord_nums(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_alphord_nums_+3A_string">string</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>string &lt;- paste0("abc", 1:12)
print(string)
str_alphord_nums(string)
str_alphord_nums(c("abc9def55", "abc10def7"))
str_alphord_nums(c("01abc9def55", "5abc10def777", "99abc4def4"))
str_alphord_nums(1:10)
## Not run: 
str_alphord_nums(c("abc9def55", "abc10xyz7")) # error

## End(Not run)

</code></pre>

<hr>
<h2 id='str_before_last_dot'>Extract the part of a string before the last period.</h2><span id='topic+str_before_last_dot'></span>

<h3>Description</h3>

<p>This is usually used to get the part of a file name that doesn't include the
file extension. It is vectorized over <code>string</code>. If there is no period in
<code>string</code>, the input is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_before_last_dot(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_before_last_dot_+3A_string">string</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>See Also</h3>

<p>Other bisectors: 
<code><a href="#topic+before-and-after">before-and-after</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str_before_last_dot(c("spreadsheet1.csv", "doc2.doc", ".R"))
</code></pre>

<hr>
<h2 id='str_can_be_numeric'>Check if a string could be considered as numeric.</h2><span id='topic+str_can_be_numeric'></span>

<h3>Description</h3>

<p>After padding is removed, could the input string be considered to be numeric,
i.e. could it be coerced to numeric. This function is vectorized over its one
argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_can_be_numeric(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_can_be_numeric_+3A_string">string</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str_can_be_numeric("3")
str_can_be_numeric("5 ")
str_can_be_numeric(c("1a", "abc"))
</code></pre>

<hr>
<h2 id='str_detect_all'>Detect any or all patterns.</h2><span id='topic+str_detect_all'></span><span id='topic+str_detect_any'></span>

<h3>Description</h3>

<p>Vectorized over <code>string</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_detect_all(string, pattern, negate = FALSE)

str_detect_any(string, pattern, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_detect_all_+3A_string">string</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="str_detect_all_+3A_pattern">pattern</code></td>
<td>
<p>A character vector. The patterns to look for. Default is
<code>stringi</code>-style regular expression. <code><a href="stringr.html#topic+modifiers">stringr::coll()</a></code> and
<code><a href="stringr.html#topic+modifiers">stringr::fixed()</a></code> are also permissible.</p>
</td></tr>
<tr><td><code id="str_detect_all_+3A_negate">negate</code></td>
<td>
<p>A flag. If <code>TRUE</code>, inverts the result.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str_detect_all("quick brown fox", c("x", "y", "z"))
str_detect_all(c(".", "-"), ".")
str_detect_all(c(".", "-"), coll("."))
str_detect_all(c(".", "-"), coll("."), negate = TRUE)
str_detect_all(c(".", "-"), c(".", ":"))
str_detect_all(c(".", "-"), coll(c(".", ":")))
str_detect_all("xyzabc", c("a", "c", "z"))
str_detect_all(c("xyzabc", "abcxyz"), c(".b", "^x"))

str_detect_any("quick brown fox", c("x", "y", "z"))
str_detect_any(c(".", "-"), ".")
str_detect_any(c(".", "-"), coll("."))
str_detect_any(c(".", "-"), coll("."), negate = TRUE)
str_detect_any(c(".", "-"), c(".", ":"))
str_detect_any(c(".", "-"), coll(c(".", ":")))
str_detect_any(c("xyzabc", "abcxyz"), c(".b", "^x"))

</code></pre>

<hr>
<h2 id='str_elem'>Extract a single character from a string, using its index.</h2><span id='topic+str_elem'></span>

<h3>Description</h3>

<p>If the element does not exist, this function returns the empty string. This
is consistent with <code><a href="stringr.html#topic+str_sub">stringr::str_sub()</a></code>. This function is vectorised over
both arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_elem(string, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_elem_+3A_string">string</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="str_elem_+3A_index">index</code></td>
<td>
<p>An integer. Negative indexing is allowed as in
<code><a href="stringr.html#topic+str_sub">stringr::str_sub()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A one-character string.
</p>


<h3>See Also</h3>

<p>Other single element extractors: 
<code><a href="#topic+str_elems">str_elems</a>()</code>,
<code><a href="#topic+str_paste_elems">str_paste_elems</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str_elem(c("abcd", "xyz"), 3)
str_elem("abcd", -2)
</code></pre>

<hr>
<h2 id='str_elems'>Extract several single elements from a string.</h2><span id='topic+str_elems'></span>

<h3>Description</h3>

<p>Efficiently extract several elements from a string. See <code><a href="#topic+str_elem">str_elem()</a></code> for
extracting single elements. This function is vectorized over the first
argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_elems(string, indices, byrow = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_elems_+3A_string">string</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="str_elems_+3A_indices">indices</code></td>
<td>
<p>A vector of integerish values. Negative indexing is allowed as
in <code><a href="stringr.html#topic+str_sub">stringr::str_sub()</a></code>.</p>
</td></tr>
<tr><td><code id="str_elems_+3A_byrow">byrow</code></td>
<td>
<p>Should the elements be organised in the matrix with one row per
string (<code>byrow = TRUE</code>, the default) or one column per string (<code>byrow = FALSE</code>). See examples if you don't understand.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character matrix.
</p>


<h3>See Also</h3>

<p>Other single element extractors: 
<code><a href="#topic+str_elem">str_elem</a>()</code>,
<code><a href="#topic+str_paste_elems">str_paste_elems</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>string &lt;- c("abc", "def", "ghi", "vwxyz")
str_elems(string, 1:2)
str_elems(string, 1:2, byrow = FALSE)
str_elems(string, c(1, 2, 3, 4, -1))
</code></pre>

<hr>
<h2 id='str_extract_non_numerics'>Extract non-numbers from a string.</h2><span id='topic+str_extract_non_numerics'></span>

<h3>Description</h3>

<p>Extract the non-numeric bits of a string where numbers are optionally defined
with decimals, scientific notation and thousand separators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_extract_non_numerics(
  string,
  decimals = FALSE,
  leading_decimals = decimals,
  negs = FALSE,
  sci = FALSE,
  big_mark = "",
  commas = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_extract_non_numerics_+3A_string">string</code></td>
<td>
<p>A string.</p>
</td></tr>
<tr><td><code id="str_extract_non_numerics_+3A_decimals">decimals</code></td>
<td>
<p>Do you want to include the possibility of decimal numbers
(<code>TRUE</code>) or not (<code>FALSE</code>, the default).</p>
</td></tr>
<tr><td><code id="str_extract_non_numerics_+3A_leading_decimals">leading_decimals</code></td>
<td>
<p>Do you want to allow a leading decimal point to be
the start of a number?</p>
</td></tr>
<tr><td><code id="str_extract_non_numerics_+3A_negs">negs</code></td>
<td>
<p>Do you want to allow negative numbers? Note that double negatives
are not handled here (see the examples).</p>
</td></tr>
<tr><td><code id="str_extract_non_numerics_+3A_sci">sci</code></td>
<td>
<p>Make the search aware of scientific notation e.g. 2e3 is the same
as 2000.</p>
</td></tr>
<tr><td><code id="str_extract_non_numerics_+3A_big_mark">big_mark</code></td>
<td>
<p>A character. Allow this character to be used as a thousands
separator. This character will be removed from between digits before they
are converted to numeric. You may specify many at once by pasting them
together e.g. <code>big_mark = ",_"</code> will allow both commas and underscores.
Internally, this will be used inside a <code style="white-space: pre;">&#8288;[]&#8288;</code> regex block so e.g. <code>"a-z"</code>
will behave differently to <code>"az-"</code>. Most common separators (commas, spaces,
underscores) should work fine.</p>
</td></tr>
<tr><td><code id="str_extract_non_numerics_+3A_commas">commas</code></td>
<td>
<p>Deprecated. Use <code>big_mark</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

 <ul>
<li> <p><code>str_first_non_numeric(...)</code> is just
<code>str_nth_non_numeric(..., n = 1)</code>. </p>
</li>
<li> <p><code>str_last_non_numeric(...)</code> is just
<code>str_nth_non_numeric(..., n = -1)</code>. </p>
</li></ul>



<h3>See Also</h3>

<p>Other non-numeric extractors: 
<code><a href="#topic+str_nth_non_numeric">str_nth_non_numeric</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>strings &lt;- c(
  "abc123def456", "abc-0.12def.345", "abc.12e4def34.5e9",
  "abc1,100def1,230.5", "abc1,100e3,215def4e1,000"
)
str_extract_non_numerics(strings)
str_extract_non_numerics(strings, decimals = TRUE, leading_decimals = FALSE)
str_extract_non_numerics(strings, decimals = TRUE)
str_extract_non_numerics(strings, big_mark = ",")
str_extract_non_numerics(strings,
  decimals = TRUE, leading_decimals = TRUE,
  sci = TRUE
)
str_extract_non_numerics(strings,
  decimals = TRUE, leading_decimals = TRUE,
  sci = TRUE, big_mark = ",", negs = TRUE
)
str_extract_non_numerics(c("22", "1.2.3"), decimals = TRUE)
</code></pre>

<hr>
<h2 id='str_extract_numbers'>Extract numbers from a string.</h2><span id='topic+str_extract_numbers'></span>

<h3>Description</h3>

<p>Extract the numbers from a string, where decimals, scientific notation and
thousand separators are optionally allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_extract_numbers(
  string,
  decimals = FALSE,
  leading_decimals = decimals,
  negs = FALSE,
  sci = FALSE,
  big_mark = "",
  leave_as_string = FALSE,
  commas = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_extract_numbers_+3A_string">string</code></td>
<td>
<p>A string.</p>
</td></tr>
<tr><td><code id="str_extract_numbers_+3A_decimals">decimals</code></td>
<td>
<p>Do you want to include the possibility of decimal numbers
(<code>TRUE</code>) or not (<code>FALSE</code>, the default).</p>
</td></tr>
<tr><td><code id="str_extract_numbers_+3A_leading_decimals">leading_decimals</code></td>
<td>
<p>Do you want to allow a leading decimal point to be
the start of a number?</p>
</td></tr>
<tr><td><code id="str_extract_numbers_+3A_negs">negs</code></td>
<td>
<p>Do you want to allow negative numbers? Note that double negatives
are not handled here (see the examples).</p>
</td></tr>
<tr><td><code id="str_extract_numbers_+3A_sci">sci</code></td>
<td>
<p>Make the search aware of scientific notation e.g. 2e3 is the same
as 2000.</p>
</td></tr>
<tr><td><code id="str_extract_numbers_+3A_big_mark">big_mark</code></td>
<td>
<p>A character. Allow this character to be used as a thousands
separator. This character will be removed from between digits before they
are converted to numeric. You may specify many at once by pasting them
together e.g. <code>big_mark = ",_"</code> will allow both commas and underscores.
Internally, this will be used inside a <code style="white-space: pre;">&#8288;[]&#8288;</code> regex block so e.g. <code>"a-z"</code>
will behave differently to <code>"az-"</code>. Most common separators (commas, spaces,
underscores) should work fine.</p>
</td></tr>
<tr><td><code id="str_extract_numbers_+3A_leave_as_string">leave_as_string</code></td>
<td>
<p>Do you want to return the number as a string (<code>TRUE</code>)
or as numeric (<code>FALSE</code>, the default)?</p>
</td></tr>
<tr><td><code id="str_extract_numbers_+3A_commas">commas</code></td>
<td>
<p>Deprecated. Use <code>big_mark</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If any part of a string contains an ambiguous number (e.g. <code style="white-space: pre;">&#8288;1.2.3&#8288;</code> would be
ambiguous if <code>decimals = TRUE</code> (but not otherwise)), the value returned for
that string will be <code>NA</code> and a <code>warning</code> will be issued.
</p>
<p>With scientific notation, it is assumed that the exponent is not a decimal
number e.g. <code style="white-space: pre;">&#8288;2e2.4&#8288;</code> is unacceptable. Thousand separators, however, are
acceptable in the exponent.
</p>
<p>Numbers outside the double precision floating point range (i.e. with absolute
value greater than 1.797693e+308) are read as <code>Inf</code> (or <code>-Inf</code> if they begin
with a minus sign). This is what <code>base::as.numeric()</code> does.
</p>


<h3>Value</h3>

<p>For <code>str_extract_numbers</code> and <code>str_extract_non_numerics</code>, a list of
numeric or character vectors, one list element for each element of
<code>string</code>. For <code>str_nth_number</code> and <code>str_nth_non_numeric</code>, a numeric or
character vector the same length as the vector <code>string</code>.
</p>


<h3>See Also</h3>

<p>Other numeric extractors: 
<code><a href="#topic+str_nth_number_after_mth">str_nth_number_after_mth</a>()</code>,
<code><a href="#topic+str_nth_number_before_mth">str_nth_number_before_mth</a>()</code>,
<code><a href="#topic+str_nth_number">str_nth_number</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>strings &lt;- c(
  "abc123def456", "abc-0.12def.345", "abc.12e4def34.5e9",
  "abc1,100def1,230.5", "abc1,100e3,215def4e1,000"
)
str_extract_numbers(strings)
str_extract_numbers(strings, decimals = TRUE)
str_extract_numbers(strings, decimals = TRUE, leading_decimals = TRUE)
str_extract_numbers(strings, big_mark = ",")
str_extract_numbers(strings,
  decimals = TRUE, leading_decimals = TRUE,
  sci = TRUE
)
str_extract_numbers(strings,
  decimals = TRUE, leading_decimals = TRUE,
  sci = TRUE, big_mark = ",", negs = TRUE
)
str_extract_numbers(strings,
  decimals = TRUE, leading_decimals = FALSE,
  sci = FALSE, big_mark = ",", leave_as_string = TRUE
)
str_extract_numbers(c("22", "1.2.3"), decimals = TRUE)
</code></pre>

<hr>
<h2 id='str_give_ext'>Ensure a file name has the intended extension.</h2><span id='topic+str_give_ext'></span>

<h3>Description</h3>

<p>Say you want to ensure a name is fit to be the name of a csv file. Then, if
the input doesn't end with &quot;.csv&quot;, this function will tack &quot;.csv&quot; onto the
end of it. This is vectorized over the first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_give_ext(string, ext, replace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_give_ext_+3A_string">string</code></td>
<td>
<p>The intended file name.</p>
</td></tr>
<tr><td><code id="str_give_ext_+3A_ext">ext</code></td>
<td>
<p>The intended file extension (with or without the &quot;.&quot;).</p>
</td></tr>
<tr><td><code id="str_give_ext_+3A_replace">replace</code></td>
<td>
<p>If the file has an extension already, replace it (or append
the new extension name)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string: the file name in your intended form.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str_give_ext(c("abc", "abc.csv"), "csv")
str_give_ext("abc.csv", "pdf")
str_give_ext("abc.csv", "pdf", replace = TRUE)
</code></pre>

<hr>
<h2 id='str_locate_braces'>Locate the braces in a string.</h2><span id='topic+str_locate_braces'></span>

<h3>Description</h3>

<p>Give the positions of <code>(</code>, <code style="white-space: pre;">&#8288;)&#8288;</code>, <code>[</code>, <code style="white-space: pre;">&#8288;]&#8288;</code>, <code style="white-space: pre;">&#8288;\{&#8288;</code>, <code style="white-space: pre;">&#8288;\}&#8288;</code> within a string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_locate_braces(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_locate_braces_+3A_string">string</code></td>
<td>
<p>A character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with 4 columns: <code>string_num</code>, <code>string</code>, <code>position</code> and
<code>brace</code>. Every extracted brace amount gets its own row in the tibble
detailing the string number and string that it was extracted from, the
position in its string and the brace.
</p>


<h3>See Also</h3>

<p>Other locators: 
<code><a href="#topic+str_locate_nth">str_locate_nth</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str_locate_braces(c("a{](kkj)})", "ab(]c{}"))
</code></pre>

<hr>
<h2 id='str_locate_nth'>Locate the indices of the <code>n</code>th instance of a pattern.</h2><span id='topic+str_locate_nth'></span><span id='topic+str_locate_first'></span><span id='topic+str_locate_last'></span>

<h3>Description</h3>

<p>The <code>n</code>th instance of an pattern will cover a series of character
indices. These functions tell you which indices those are. These functions
are vectorised over all arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_locate_nth(string, pattern, n)

str_locate_first(string, pattern)

str_locate_last(string, pattern)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_locate_nth_+3A_string">string</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="str_locate_nth_+3A_pattern">pattern</code></td>
<td>
<p>The pattern to look for.
</p>
<p>The default interpretation is a regular expression, as described in
<a href="stringi.html#topic+about_search_regex">stringi::about_search_regex</a>.
</p>
<p>To match a without regular expression (i.e. as a human would), use
<a href="stringr.html#topic+modifiers">coll()</a>. For details see <code><a href="stringr.html#topic+modifiers">stringr::regex()</a></code>.</p>
</td></tr>
<tr><td><code id="str_locate_nth_+3A_n">n</code></td>
<td>
<p>A vector of integerish values. Must be either length 1 or
have length equal to the length of <code>string</code>. Negative indices count from
the back: while <code>n = 1</code> and <code>n = 2</code> correspond to first and second, <code>n = -1</code> and <code>n = -2</code> correspond to last and second-last. <code>n = 0</code> will return
<code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

 <ul>
<li> <p><code>str_locate_first(...)</code> is just <code>str_locate_nth(..., n = 1)</code>.
</p>
</li>
<li> <p><code>str_locate_last(...)</code> is just <code>str_locate_nth(..., n = -1)</code>. </p>
</li></ul>



<h3>Value</h3>

<p>A two-column matrix. The <code class="reqn">i</code>th row of this matrix gives the start
and end indices of the <code class="reqn">n</code>th instance of <code>pattern</code> in the <code class="reqn">i</code>th
element of <code>string</code>.
</p>


<h3>See Also</h3>

<p>Other locators: 
<code><a href="#topic+str_locate_braces">str_locate_braces</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str_locate_nth(c("abcdabcxyz", "abcabc"), "abc", 2)
str_locate_nth(
  c("This old thing.", "That beautiful thing there."),
  "\\w+", c(2, -2)
)
str_locate_nth("abc", "b", c(0, 1, 1, 2))
str_locate_first("abcxyzabc", "abc")
str_locate_last("abcxyzabc", "abc")
</code></pre>

<hr>
<h2 id='str_match_arg'>Argument Matching.</h2><span id='topic+str_match_arg'></span><span id='topic+match_arg'></span>

<h3>Description</h3>

<p>Match <code>arg</code> against a series of candidate <code>choices</code>. <code>arg</code> <em>matches</em> an
element of <code>choices</code> if <code>arg</code> is a prefix of that element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_match_arg(
  arg,
  choices = NULL,
  index = FALSE,
  several_ok = FALSE,
  ignore_case = FALSE
)

match_arg(
  arg,
  choices = NULL,
  index = FALSE,
  several_ok = FALSE,
  ignore_case = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_match_arg_+3A_arg">arg</code></td>
<td>
<p>A character vector (of length one unless <code>several_ok = TRUE</code>).</p>
</td></tr>
<tr><td><code id="str_match_arg_+3A_choices">choices</code></td>
<td>
<p>A character vector of candidate values.</p>
</td></tr>
<tr><td><code id="str_match_arg_+3A_index">index</code></td>
<td>
<p>Return the index of the match rather than the match itself?</p>
</td></tr>
<tr><td><code id="str_match_arg_+3A_several_ok">several_ok</code></td>
<td>
<p>Allow <code>arg</code> to have length greater than one to match
several arguments at once?</p>
</td></tr>
<tr><td><code id="str_match_arg_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Ignore case while matching. If this is <code>TRUE</code>, the
returned value is the matched element of <code>choices</code> (with its original
casing).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ERROR</code>s are thrown when a match is not made and where the match is
ambiguous. However, sometimes ambiguities are inevitable. Consider the case
where <code>choices = c("ab", "abc")</code>, then there's no way to choose <code>"ab"</code>
because <code>"ab"</code> is a prefix for <code>"ab"</code> and <code>"abc"</code>. If this is the case, you
need to provide a full match, i.e. using <code>arg = "ab"</code> will get you <code>"ab"</code>
without an error, however <code>arg = "a"</code> will throw an ambiguity error.
</p>
<p>When <code>choices</code> is <code>NULL</code>, the <code>choices</code> are obtained from a default setting
for the formal argument <code>arg</code> of the function from which <code>str_match_arg</code> was
called. This is consistent with <code>base::match.arg()</code>. See the examples for
details.
</p>
<p>When <code>arg</code> and <code>choices</code> are identical and <code>several_ok = FALSE</code>, the first
element of <code>choices</code> is returned. This is consistent with
<code>base::match.arg()</code>.
</p>
<p>This function inspired by <code>RSAGA::match.arg.ext()</code>. Its behaviour is almost
identical (the difference is that <code>RSAGA::match.arg.ext(..., ignore.case = TRUE)</code> always returns in all lower case; <code>strex::match_arg(..., ignore_case = TRUE)</code> ignores case while matching but returns the element of <code>choices</code> in
its original case). <code>RSAGA</code> is a heavy package to depend upon so
<code>strex::match_arg()</code> is handy for package developers.
</p>
<p>This function is designed to be used inside of other functions. It's fine to
use it for other purposes, but the error messages might be a bit weird.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>choices &lt;- c("Apples", "Pears", "Bananas", "Oranges")
match_arg("A", choices)
match_arg("B", choices, index = TRUE)
match_arg(c("a", "b"), choices, several_ok = TRUE, ignore_case = TRUE)
match_arg(c("b", "a"), choices,
  ignore_case = TRUE, index = TRUE,
  several_ok = TRUE
)
myword &lt;- function(w = c("abacus", "baseball", "candy")) {
  w &lt;- match_arg(w)
  w
}
myword("b")
myword()
myword &lt;- function(w = c("abacus", "baseball", "candy")) {
  w &lt;- match_arg(w, several_ok = TRUE)
  w
}
myword("c")
myword()
</code></pre>

<hr>
<h2 id='str_nth_non_numeric'>Extract the <code>n</code>th non-numeric substring from a string.</h2><span id='topic+str_nth_non_numeric'></span><span id='topic+str_first_non_numeric'></span><span id='topic+str_last_non_numeric'></span>

<h3>Description</h3>

<p>Extract the <code>n</code>th non-numeric bit of a string where numbers are optionally
defined with decimals, scientific notation and thousand separators.
</p>
 <ul>
<li> <p><code>str_first_non_numeric(...)</code> is just
<code>str_nth_non_numeric(..., n = 1)</code>. </p>
</li>
<li> <p><code>str_last_non_numeric(...)</code> is
just <code>str_nth_non_numeric(..., n = -1)</code>. </p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>str_nth_non_numeric(
  string,
  n,
  decimals = FALSE,
  leading_decimals = decimals,
  negs = FALSE,
  sci = FALSE,
  big_mark = "",
  commas = FALSE
)

str_first_non_numeric(
  string,
  decimals = FALSE,
  leading_decimals = decimals,
  negs = FALSE,
  sci = FALSE,
  big_mark = "",
  commas = FALSE
)

str_last_non_numeric(
  string,
  decimals = FALSE,
  leading_decimals = decimals,
  negs = FALSE,
  sci = FALSE,
  big_mark = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_nth_non_numeric_+3A_string">string</code></td>
<td>
<p>A string.</p>
</td></tr>
<tr><td><code id="str_nth_non_numeric_+3A_n">n</code></td>
<td>
<p>A vector of integerish values. Must be either length 1 or
have length equal to the length of <code>string</code>. Negative indices count from
the back: while <code>n = 1</code> and <code>n = 2</code> correspond to first and second, <code>n = -1</code> and <code>n = -2</code> correspond to last and second-last. <code>n = 0</code> will return
<code>NA</code>.</p>
</td></tr>
<tr><td><code id="str_nth_non_numeric_+3A_decimals">decimals</code></td>
<td>
<p>Do you want to include the possibility of decimal numbers
(<code>TRUE</code>) or not (<code>FALSE</code>, the default).</p>
</td></tr>
<tr><td><code id="str_nth_non_numeric_+3A_leading_decimals">leading_decimals</code></td>
<td>
<p>Do you want to allow a leading decimal point to be
the start of a number?</p>
</td></tr>
<tr><td><code id="str_nth_non_numeric_+3A_negs">negs</code></td>
<td>
<p>Do you want to allow negative numbers? Note that double negatives
are not handled here (see the examples).</p>
</td></tr>
<tr><td><code id="str_nth_non_numeric_+3A_sci">sci</code></td>
<td>
<p>Make the search aware of scientific notation e.g. 2e3 is the same
as 2000.</p>
</td></tr>
<tr><td><code id="str_nth_non_numeric_+3A_big_mark">big_mark</code></td>
<td>
<p>A character. Allow this character to be used as a thousands
separator. This character will be removed from between digits before they
are converted to numeric. You may specify many at once by pasting them
together e.g. <code>big_mark = ",_"</code> will allow both commas and underscores.
Internally, this will be used inside a <code style="white-space: pre;">&#8288;[]&#8288;</code> regex block so e.g. <code>"a-z"</code>
will behave differently to <code>"az-"</code>. Most common separators (commas, spaces,
underscores) should work fine.</p>
</td></tr>
<tr><td><code id="str_nth_non_numeric_+3A_commas">commas</code></td>
<td>
<p>Deprecated. Use <code>big_mark</code> instead.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other non-numeric extractors: 
<code><a href="#topic+str_extract_non_numerics">str_extract_non_numerics</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>strings &lt;- c(
  "abc123def456", "abc-0.12def.345", "abc.12e4def34.5e9",
  "abc1,100def1,230.5", "abc1,100e3,215def4e1,000"
)
str_nth_non_numeric(strings, n = 2)
str_nth_non_numeric(strings, n = -2, decimals = TRUE)
str_first_non_numeric(strings, decimals = TRUE, leading_decimals = FALSE)
str_last_non_numeric(strings, big_mark = ",")
str_nth_non_numeric(strings,
  n = 1, decimals = TRUE, leading_decimals = TRUE,
  sci = TRUE
)
str_first_non_numeric(strings,
  decimals = TRUE, leading_decimals = TRUE,
  sci = TRUE, big_mark = ",", negs = TRUE
)
str_first_non_numeric(c("22", "1.2.3"), decimals = TRUE)
</code></pre>

<hr>
<h2 id='str_nth_number'>Extract the <code>n</code>th number from a string.</h2><span id='topic+str_nth_number'></span><span id='topic+str_first_number'></span><span id='topic+str_last_number'></span>

<h3>Description</h3>

<p>Extract the <code>n</code>th number from a string, where decimals, scientific notation
and thousand separators are optionally allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_nth_number(
  string,
  n,
  decimals = FALSE,
  leading_decimals = decimals,
  negs = FALSE,
  sci = FALSE,
  big_mark = "",
  leave_as_string = FALSE,
  commas = FALSE
)

str_first_number(
  string,
  decimals = FALSE,
  leading_decimals = decimals,
  negs = FALSE,
  sci = FALSE,
  big_mark = "",
  leave_as_string = FALSE,
  commas = FALSE
)

str_last_number(
  string,
  decimals = FALSE,
  leading_decimals = decimals,
  negs = FALSE,
  sci = FALSE,
  big_mark = "",
  leave_as_string = FALSE,
  commas = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_nth_number_+3A_string">string</code></td>
<td>
<p>A string.</p>
</td></tr>
<tr><td><code id="str_nth_number_+3A_n">n</code></td>
<td>
<p>A vector of integerish values. Must be either length 1 or
have length equal to the length of <code>string</code>. Negative indices count from
the back: while <code>n = 1</code> and <code>n = 2</code> correspond to first and second, <code>n = -1</code> and <code>n = -2</code> correspond to last and second-last. <code>n = 0</code> will return
<code>NA</code>.</p>
</td></tr>
<tr><td><code id="str_nth_number_+3A_decimals">decimals</code></td>
<td>
<p>Do you want to include the possibility of decimal numbers
(<code>TRUE</code>) or not (<code>FALSE</code>, the default).</p>
</td></tr>
<tr><td><code id="str_nth_number_+3A_leading_decimals">leading_decimals</code></td>
<td>
<p>Do you want to allow a leading decimal point to be
the start of a number?</p>
</td></tr>
<tr><td><code id="str_nth_number_+3A_negs">negs</code></td>
<td>
<p>Do you want to allow negative numbers? Note that double negatives
are not handled here (see the examples).</p>
</td></tr>
<tr><td><code id="str_nth_number_+3A_sci">sci</code></td>
<td>
<p>Make the search aware of scientific notation e.g. 2e3 is the same
as 2000.</p>
</td></tr>
<tr><td><code id="str_nth_number_+3A_big_mark">big_mark</code></td>
<td>
<p>A character. Allow this character to be used as a thousands
separator. This character will be removed from between digits before they
are converted to numeric. You may specify many at once by pasting them
together e.g. <code>big_mark = ",_"</code> will allow both commas and underscores.
Internally, this will be used inside a <code style="white-space: pre;">&#8288;[]&#8288;</code> regex block so e.g. <code>"a-z"</code>
will behave differently to <code>"az-"</code>. Most common separators (commas, spaces,
underscores) should work fine.</p>
</td></tr>
<tr><td><code id="str_nth_number_+3A_leave_as_string">leave_as_string</code></td>
<td>
<p>Do you want to return the number as a string (<code>TRUE</code>)
or as numeric (<code>FALSE</code>, the default)?</p>
</td></tr>
<tr><td><code id="str_nth_number_+3A_commas">commas</code></td>
<td>
<p>Deprecated. Use <code>big_mark</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

 <ul>
<li> <p><code>str_first_number(...)</code> is just <code>str_nth_number(..., n = 1)</code>.
</p>
</li>
<li> <p><code>str_last_number(...)</code> is just <code>str_nth_number(..., n = -1)</code>. </p>
</li></ul>

<p>For a detailed explanation of the number extraction, see
<code><a href="#topic+str_extract_numbers">str_extract_numbers()</a></code>.
</p>


<h3>Value</h3>

<p>A numeric vector (or a character vector if <code>leave_as_string = TRUE</code>).
</p>


<h3>See Also</h3>

<p>Other numeric extractors: 
<code><a href="#topic+str_extract_numbers">str_extract_numbers</a>()</code>,
<code><a href="#topic+str_nth_number_after_mth">str_nth_number_after_mth</a>()</code>,
<code><a href="#topic+str_nth_number_before_mth">str_nth_number_before_mth</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>strings &lt;- c(
  "abc123def456", "abc-0.12def.345", "abc.12e4def34.5e9",
  "abc1,100def1,230.5", "abc1,100e3,215def4e1,000"
)
str_nth_number(strings, n = 2)
str_nth_number(strings, n = -2, decimals = TRUE)
str_first_number(strings, decimals = TRUE, leading_decimals = TRUE)
str_last_number(strings, big_mark = ",")
str_nth_number(strings,
  n = 1, decimals = TRUE, leading_decimals = TRUE,
  sci = TRUE
)
str_first_number(strings,
  decimals = TRUE, leading_decimals = TRUE,
  sci = TRUE, big_mark = ",", negs = TRUE
)
str_last_number(strings,
  decimals = TRUE, leading_decimals = FALSE,
  sci = FALSE, big_mark = ",", negs = TRUE, leave_as_string = TRUE
)
str_first_number(c("22", "1.2.3"), decimals = TRUE)
</code></pre>

<hr>
<h2 id='str_nth_number_after_mth'>Find the <code>n</code>th number after the <code>m</code>th occurrence of a pattern.</h2><span id='topic+str_nth_number_after_mth'></span><span id='topic+str_nth_number_after_first'></span><span id='topic+str_nth_number_after_last'></span><span id='topic+str_first_number_after_mth'></span><span id='topic+str_last_number_after_mth'></span><span id='topic+str_first_number_after_first'></span><span id='topic+str_first_number_after_last'></span><span id='topic+str_last_number_after_first'></span><span id='topic+str_last_number_after_last'></span>

<h3>Description</h3>

<p>Given a string, a pattern and natural numbers <code>n</code> and <code>m</code>, find the <code>n</code>th
number after the <code>m</code>th occurrence of the pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_nth_number_after_mth(
  string,
  pattern,
  n,
  m,
  decimals = FALSE,
  leading_decimals = decimals,
  negs = FALSE,
  sci = FALSE,
  big_mark = "",
  leave_as_string = FALSE,
  commas = FALSE
)

str_nth_number_after_first(
  string,
  pattern,
  n,
  decimals = FALSE,
  leading_decimals = decimals,
  negs = FALSE,
  sci = FALSE,
  big_mark = "",
  leave_as_string = FALSE,
  commas = FALSE
)

str_nth_number_after_last(
  string,
  pattern,
  n,
  decimals = FALSE,
  leading_decimals = decimals,
  negs = FALSE,
  sci = FALSE,
  big_mark = "",
  leave_as_string = FALSE,
  commas = FALSE
)

str_first_number_after_mth(
  string,
  pattern,
  m,
  decimals = FALSE,
  leading_decimals = decimals,
  negs = FALSE,
  sci = FALSE,
  big_mark = "",
  leave_as_string = FALSE,
  commas = FALSE
)

str_last_number_after_mth(
  string,
  pattern,
  m,
  decimals = FALSE,
  leading_decimals = decimals,
  negs = FALSE,
  sci = FALSE,
  big_mark = "",
  leave_as_string = FALSE,
  commas = FALSE
)

str_first_number_after_first(
  string,
  pattern,
  decimals = FALSE,
  leading_decimals = decimals,
  negs = FALSE,
  sci = FALSE,
  big_mark = "",
  leave_as_string = FALSE,
  commas = FALSE
)

str_first_number_after_last(
  string,
  pattern,
  decimals = FALSE,
  leading_decimals = decimals,
  negs = FALSE,
  sci = FALSE,
  big_mark = "",
  leave_as_string = FALSE,
  commas = FALSE
)

str_last_number_after_first(
  string,
  pattern,
  decimals = FALSE,
  leading_decimals = decimals,
  negs = FALSE,
  sci = FALSE,
  big_mark = "",
  leave_as_string = FALSE,
  commas = FALSE
)

str_last_number_after_last(
  string,
  pattern,
  decimals = FALSE,
  leading_decimals = decimals,
  negs = FALSE,
  sci = FALSE,
  big_mark = "",
  leave_as_string = FALSE,
  commas = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_nth_number_after_mth_+3A_string">string</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="str_nth_number_after_mth_+3A_pattern">pattern</code></td>
<td>
<p>The pattern to look for.
</p>
<p>The default interpretation is a regular expression, as described in
<a href="stringi.html#topic+about_search_regex">stringi::about_search_regex</a>.
</p>
<p>To match a without regular expression (i.e. as a human would), use
<a href="stringr.html#topic+modifiers">coll()</a>. For details see <code><a href="stringr.html#topic+modifiers">stringr::regex()</a></code>.</p>
</td></tr>
<tr><td><code id="str_nth_number_after_mth_+3A_n">n</code>, <code id="str_nth_number_after_mth_+3A_m">m</code></td>
<td>
<p>Vectors of integerish values. Must be either length 1 or have
length equal to the length of <code>string</code>. Negative indices count from the
back: while <code>1</code> and <code>2</code> correspond to first and second, <code>-1</code> and <code>-2</code>
correspond to last and second-last. <code>0</code> will return <code>NA</code>.</p>
</td></tr>
<tr><td><code id="str_nth_number_after_mth_+3A_decimals">decimals</code></td>
<td>
<p>Do you want to include the possibility of decimal numbers
(<code>TRUE</code>) or not (<code>FALSE</code>, the default).</p>
</td></tr>
<tr><td><code id="str_nth_number_after_mth_+3A_leading_decimals">leading_decimals</code></td>
<td>
<p>Do you want to allow a leading decimal point to be
the start of a number?</p>
</td></tr>
<tr><td><code id="str_nth_number_after_mth_+3A_negs">negs</code></td>
<td>
<p>Do you want to allow negative numbers? Note that double negatives
are not handled here (see the examples).</p>
</td></tr>
<tr><td><code id="str_nth_number_after_mth_+3A_sci">sci</code></td>
<td>
<p>Make the search aware of scientific notation e.g. 2e3 is the same
as 2000.</p>
</td></tr>
<tr><td><code id="str_nth_number_after_mth_+3A_big_mark">big_mark</code></td>
<td>
<p>A character. Allow this character to be used as a thousands
separator. This character will be removed from between digits before they
are converted to numeric. You may specify many at once by pasting them
together e.g. <code>big_mark = ",_"</code> will allow both commas and underscores.
Internally, this will be used inside a <code style="white-space: pre;">&#8288;[]&#8288;</code> regex block so e.g. <code>"a-z"</code>
will behave differently to <code>"az-"</code>. Most common separators (commas, spaces,
underscores) should work fine.</p>
</td></tr>
<tr><td><code id="str_nth_number_after_mth_+3A_leave_as_string">leave_as_string</code></td>
<td>
<p>Do you want to return the number as a string (<code>TRUE</code>)
or as numeric (<code>FALSE</code>, the default)?</p>
</td></tr>
<tr><td><code id="str_nth_number_after_mth_+3A_commas">commas</code></td>
<td>
<p>Deprecated. Use <code>big_mark</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric or character vector.
</p>


<h3>See Also</h3>

<p>Other numeric extractors: 
<code><a href="#topic+str_extract_numbers">str_extract_numbers</a>()</code>,
<code><a href="#topic+str_nth_number_before_mth">str_nth_number_before_mth</a>()</code>,
<code><a href="#topic+str_nth_number">str_nth_number</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>string &lt;- c(
  "abc1abc2abc3abc4abc5abc6abc7abc8abc9",
  "abc1def2ghi3abc4def5ghi6abc7def8ghi9"
)
str_nth_number_after_mth(string, "abc", 1, 3)
str_nth_number_after_mth(string, "abc", 2, 3)
str_nth_number_after_first(string, "abc", 2)
str_nth_number_after_last(string, "abc", -1)
str_first_number_after_mth(string, "abc", 2)
str_last_number_after_mth(string, "abc", 1)
str_first_number_after_first(string, "abc")
str_first_number_after_last(string, "abc")
str_last_number_after_first(string, "abc")
str_last_number_after_last(string, "abc")
</code></pre>

<hr>
<h2 id='str_nth_number_before_mth'>Find the <code>n</code>th number before the <code>m</code>th occurrence of a pattern.</h2><span id='topic+str_nth_number_before_mth'></span><span id='topic+str_nth_number_before_first'></span><span id='topic+str_nth_number_before_last'></span><span id='topic+str_first_number_before_mth'></span><span id='topic+str_last_number_before_mth'></span><span id='topic+str_first_number_before_first'></span><span id='topic+str_first_number_before_last'></span><span id='topic+str_last_number_before_first'></span><span id='topic+str_last_number_before_last'></span>

<h3>Description</h3>

<p>Given a string, a pattern and natural numbers <code>n</code> and <code>m</code>, find the <code>n</code>th
number that comes before the <code>m</code>th occurrence of the pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_nth_number_before_mth(
  string,
  pattern,
  n,
  m,
  decimals = FALSE,
  leading_decimals = decimals,
  negs = FALSE,
  sci = FALSE,
  big_mark = "",
  leave_as_string = FALSE,
  commas = FALSE
)

str_nth_number_before_first(
  string,
  pattern,
  n,
  decimals = FALSE,
  leading_decimals = decimals,
  negs = FALSE,
  sci = FALSE,
  big_mark = "",
  leave_as_string = FALSE,
  commas = FALSE
)

str_nth_number_before_last(
  string,
  pattern,
  n,
  decimals = FALSE,
  leading_decimals = decimals,
  negs = FALSE,
  sci = FALSE,
  big_mark = "",
  leave_as_string = FALSE,
  commas = FALSE
)

str_first_number_before_mth(
  string,
  pattern,
  m,
  decimals = FALSE,
  leading_decimals = decimals,
  negs = FALSE,
  sci = FALSE,
  big_mark = "",
  leave_as_string = FALSE,
  commas = FALSE
)

str_last_number_before_mth(
  string,
  pattern,
  m,
  decimals = FALSE,
  leading_decimals = decimals,
  negs = FALSE,
  sci = FALSE,
  big_mark = "",
  leave_as_string = FALSE,
  commas = FALSE
)

str_first_number_before_first(
  string,
  pattern,
  decimals = FALSE,
  leading_decimals = decimals,
  negs = FALSE,
  sci = FALSE,
  big_mark = "",
  leave_as_string = FALSE,
  commas = FALSE
)

str_first_number_before_last(
  string,
  pattern,
  decimals = FALSE,
  leading_decimals = decimals,
  negs = FALSE,
  sci = FALSE,
  big_mark = "",
  leave_as_string = FALSE,
  commas = FALSE
)

str_last_number_before_first(
  string,
  pattern,
  decimals = FALSE,
  leading_decimals = decimals,
  negs = FALSE,
  sci = FALSE,
  big_mark = "",
  leave_as_string = FALSE,
  commas = FALSE
)

str_last_number_before_last(
  string,
  pattern,
  decimals = FALSE,
  leading_decimals = decimals,
  negs = FALSE,
  sci = FALSE,
  big_mark = "",
  leave_as_string = FALSE,
  commas = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_nth_number_before_mth_+3A_string">string</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="str_nth_number_before_mth_+3A_pattern">pattern</code></td>
<td>
<p>The pattern to look for.
</p>
<p>The default interpretation is a regular expression, as described in
<a href="stringi.html#topic+about_search_regex">stringi::about_search_regex</a>.
</p>
<p>To match a without regular expression (i.e. as a human would), use
<a href="stringr.html#topic+modifiers">coll()</a>. For details see <code><a href="stringr.html#topic+modifiers">stringr::regex()</a></code>.</p>
</td></tr>
<tr><td><code id="str_nth_number_before_mth_+3A_n">n</code>, <code id="str_nth_number_before_mth_+3A_m">m</code></td>
<td>
<p>Vectors of integerish values. Must be either length 1 or have
length equal to the length of <code>string</code>. Negative indices count from the
back: while <code>1</code> and <code>2</code> correspond to first and second, <code>-1</code> and <code>-2</code>
correspond to last and second-last. <code>0</code> will return <code>NA</code>.</p>
</td></tr>
<tr><td><code id="str_nth_number_before_mth_+3A_decimals">decimals</code></td>
<td>
<p>Do you want to include the possibility of decimal numbers
(<code>TRUE</code>) or not (<code>FALSE</code>, the default).</p>
</td></tr>
<tr><td><code id="str_nth_number_before_mth_+3A_leading_decimals">leading_decimals</code></td>
<td>
<p>Do you want to allow a leading decimal point to be
the start of a number?</p>
</td></tr>
<tr><td><code id="str_nth_number_before_mth_+3A_negs">negs</code></td>
<td>
<p>Do you want to allow negative numbers? Note that double negatives
are not handled here (see the examples).</p>
</td></tr>
<tr><td><code id="str_nth_number_before_mth_+3A_sci">sci</code></td>
<td>
<p>Make the search aware of scientific notation e.g. 2e3 is the same
as 2000.</p>
</td></tr>
<tr><td><code id="str_nth_number_before_mth_+3A_big_mark">big_mark</code></td>
<td>
<p>A character. Allow this character to be used as a thousands
separator. This character will be removed from between digits before they
are converted to numeric. You may specify many at once by pasting them
together e.g. <code>big_mark = ",_"</code> will allow both commas and underscores.
Internally, this will be used inside a <code style="white-space: pre;">&#8288;[]&#8288;</code> regex block so e.g. <code>"a-z"</code>
will behave differently to <code>"az-"</code>. Most common separators (commas, spaces,
underscores) should work fine.</p>
</td></tr>
<tr><td><code id="str_nth_number_before_mth_+3A_leave_as_string">leave_as_string</code></td>
<td>
<p>Do you want to return the number as a string (<code>TRUE</code>)
or as numeric (<code>FALSE</code>, the default)?</p>
</td></tr>
<tr><td><code id="str_nth_number_before_mth_+3A_commas">commas</code></td>
<td>
<p>Deprecated. Use <code>big_mark</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric or character vector.
</p>


<h3>See Also</h3>

<p>Other numeric extractors: 
<code><a href="#topic+str_extract_numbers">str_extract_numbers</a>()</code>,
<code><a href="#topic+str_nth_number_after_mth">str_nth_number_after_mth</a>()</code>,
<code><a href="#topic+str_nth_number">str_nth_number</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>string &lt;- c(
  "abc1abc2abc3abc4def5abc6abc7abc8abc9",
  "abc1def2ghi3abc4def5ghi6abc7def8ghi9"
)
str_nth_number_before_mth(string, "def", 1, 1)
str_nth_number_before_mth(string, "abc", 2, 3)
str_nth_number_before_first(string, "def", 2)
str_nth_number_before_last(string, "def", -1)
str_first_number_before_mth(string, "abc", 2)
str_last_number_before_mth(string, "def", 1)
str_first_number_before_first(string, "def")
str_first_number_before_last(string, "def")
str_last_number_before_first(string, "def")
str_last_number_before_last(string, "def")
</code></pre>

<hr>
<h2 id='str_paste_elems'>Extract single elements of a string and paste them together.</h2><span id='topic+str_paste_elems'></span>

<h3>Description</h3>

<p>This is a quick way around doing a call to <code><a href="#topic+str_elems">str_elems()</a></code> followed by a call
of <code>apply(..., paste)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_paste_elems(string, indices, sep = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_paste_elems_+3A_string">string</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="str_paste_elems_+3A_indices">indices</code></td>
<td>
<p>A vector of integerish values. Negative indexing is allowed as
in <code><a href="stringr.html#topic+str_sub">stringr::str_sub()</a></code>.</p>
</td></tr>
<tr><td><code id="str_paste_elems_+3A_sep">sep</code></td>
<td>
<p>A string. The separator for pasting <code>string</code> elements together.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Elements that don't exist e.g. element 5 of <code>"abc"</code> are ignored.
</p>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>See Also</h3>

<p>Other single element extractors: 
<code><a href="#topic+str_elems">str_elems</a>()</code>,
<code><a href="#topic+str_elem">str_elem</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>string &lt;- c("abc", "def", "ghi", "vwxyz")
str_paste_elems(string, 1:2)
str_paste_elems(string, c(1, 2, 3, 4, -1))
str_paste_elems("abc", c(1, 5, 55, 43, 3))
</code></pre>

<hr>
<h2 id='str_remove_quoted'>Remove the quoted parts of a string.</h2><span id='topic+str_remove_quoted'></span>

<h3>Description</h3>

<p>If any parts of a string are quoted (between quotation marks), remove those
parts of the string, including the quotes. Run the examples and you'll know
exactly how this function works.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_remove_quoted(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_remove_quoted_+3A_string">string</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>See Also</h3>

<p>Other removers: 
<code><a href="#topic+str_singleize">str_singleize</a>()</code>,
<code><a href="#topic+str_trim_anything">str_trim_anything</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>string &lt;- "\"abc\"67a\'dk\'f"
cat(string)
str_remove_quoted(string)
</code></pre>

<hr>
<h2 id='str_singleize'>Remove back-to-back duplicates of a pattern in a string.</h2><span id='topic+str_singleize'></span>

<h3>Description</h3>

<p>If a string contains a given pattern duplicated back-to-back a number of
times, remove that duplication, leaving the pattern appearing once in that
position (works if the pattern is duplicated in different parts of a string,
removing all instances of duplication). This is vectorized over string and
pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_singleize(string, pattern)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_singleize_+3A_string">string</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="str_singleize_+3A_pattern">pattern</code></td>
<td>
<p>The pattern to look for.
</p>
<p>The default interpretation is a regular expression, as described in
<a href="stringi.html#topic+about_search_regex">stringi::about_search_regex</a>.
</p>
<p>To match a without regular expression (i.e. as a human would), use
<a href="stringr.html#topic+modifiers">coll()</a>. For details see <code><a href="stringr.html#topic+modifiers">stringr::regex()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>See Also</h3>

<p>Other removers: 
<code><a href="#topic+str_remove_quoted">str_remove_quoted</a>()</code>,
<code><a href="#topic+str_trim_anything">str_trim_anything</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str_singleize("abc//def", "/")
str_singleize("abababcabab", "ab")
str_singleize(c("abab", "cdcd"), "cd")
str_singleize(c("abab", "cdcd"), c("ab", "cd"))
</code></pre>

<hr>
<h2 id='str_split_by_numbers'>Split a string by its numeric characters.</h2><span id='topic+str_split_by_numbers'></span>

<h3>Description</h3>

<p>Break a string wherever you go from a numeric character to a non-numeric or
vice-versa. Keep the whole string, just split it up. Vectorised over
<code>string</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_split_by_numbers(
  string,
  decimals = FALSE,
  leading_decimals = FALSE,
  negs = FALSE,
  sci = FALSE,
  big_mark = "",
  commas = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_split_by_numbers_+3A_string">string</code></td>
<td>
<p>A string.</p>
</td></tr>
<tr><td><code id="str_split_by_numbers_+3A_decimals">decimals</code></td>
<td>
<p>Do you want to include the possibility of decimal numbers
(<code>TRUE</code>) or not (<code>FALSE</code>, the default).</p>
</td></tr>
<tr><td><code id="str_split_by_numbers_+3A_leading_decimals">leading_decimals</code></td>
<td>
<p>Do you want to allow a leading decimal point to be
the start of a number?</p>
</td></tr>
<tr><td><code id="str_split_by_numbers_+3A_negs">negs</code></td>
<td>
<p>Do you want to allow negative numbers? Note that double negatives
are not handled here (see the examples).</p>
</td></tr>
<tr><td><code id="str_split_by_numbers_+3A_sci">sci</code></td>
<td>
<p>Make the search aware of scientific notation e.g. 2e3 is the same
as 2000.</p>
</td></tr>
<tr><td><code id="str_split_by_numbers_+3A_big_mark">big_mark</code></td>
<td>
<p>A character. Allow this character to be used as a thousands
separator. This character will be removed from between digits before they
are converted to numeric. You may specify many at once by pasting them
together e.g. <code>big_mark = ",_"</code> will allow both commas and underscores.
Internally, this will be used inside a <code style="white-space: pre;">&#8288;[]&#8288;</code> regex block so e.g. <code>"a-z"</code>
will behave differently to <code>"az-"</code>. Most common separators (commas, spaces,
underscores) should work fine.</p>
</td></tr>
<tr><td><code id="str_split_by_numbers_+3A_commas">commas</code></td>
<td>
<p>Deprecated. Use <code>big_mark</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors.
</p>


<h3>See Also</h3>

<p>Other splitters: 
<code><a href="#topic+str_split_camel_case">str_split_camel_case</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str_split_by_numbers(c("abc123def456.789gh", "a1b2c344"))
str_split_by_numbers("abc123def456.789gh", decimals = TRUE)
str_split_by_numbers(c("22", "1.2.3"), decimals = TRUE)
</code></pre>

<hr>
<h2 id='str_split_camel_case'>Split a string based on CamelCase.</h2><span id='topic+str_split_camel_case'></span>

<h3>Description</h3>

<p>Vectorized over <code>string</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_split_camel_case(string, lower = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_split_camel_case_+3A_string">string</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="str_split_camel_case_+3A_lower">lower</code></td>
<td>
<p>Do you want the output to be all lower case (or as is)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors, one list element for each element of
<code>string</code>.
</p>


<h3>References</h3>

<p>Adapted from Ramnath Vaidyanathan's answer at
http://stackoverflow.com/questions/8406974/splitting-camelcase-in-r.
</p>


<h3>See Also</h3>

<p>Other splitters: 
<code><a href="#topic+str_split_by_numbers">str_split_by_numbers</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str_split_camel_case(c("RoryNolan", "NaomiFlagg", "DepartmentOfSillyHats"))
str_split_camel_case(c("RoryNolan", "NaomiFlagg", "DepartmentOfSillyHats",
  lower = TRUE
))
</code></pre>

<hr>
<h2 id='str_to_vec'>Convert a string to a vector of characters</h2><span id='topic+str_to_vec'></span>

<h3>Description</h3>

<p>Go from a string to a vector whose <code class="reqn">i</code>th element is the <code class="reqn">i</code>th
character in the string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_to_vec(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_to_vec_+3A_string">string</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str_to_vec("abcdef")
</code></pre>

<hr>
<h2 id='str_trim_anything'>Trim something other than whitespace</h2><span id='topic+str_trim_anything'></span>

<h3>Description</h3>

<p>The <code>stringi</code> and <code>stringr</code> packages let you trim whitespace, but
what if you want to trim something else from either (or both) side(s) of a
string? This function lets you select which pattern to trim and from which
side(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_trim_anything(string, pattern, side = "both")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_trim_anything_+3A_string">string</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="str_trim_anything_+3A_pattern">pattern</code></td>
<td>
<p>The pattern to look for.
</p>
<p>The default interpretation is a regular expression, as described in
<a href="stringi.html#topic+about_search_regex">stringi::about_search_regex</a>.
</p>
<p>To match a without regular expression (i.e. as a human would), use
<a href="stringr.html#topic+modifiers">coll()</a>. For details see <code><a href="stringr.html#topic+modifiers">stringr::regex()</a></code>.</p>
</td></tr>
<tr><td><code id="str_trim_anything_+3A_side">side</code></td>
<td>
<p>Which side do you want to trim from? <code>"both"</code> is the
default, but you can also have just either <code>"left"</code> or <code>"right"</code>
(or optionally the shortened <code>"b"</code>, <code>"l"</code> and <code>"r"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string.
</p>


<h3>See Also</h3>

<p>Other removers: 
<code><a href="#topic+str_remove_quoted">str_remove_quoted</a>()</code>,
<code><a href="#topic+str_singleize">str_singleize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str_trim_anything("..abcd.", ".", "left")
str_trim_anything("..abcd.", coll("."), "left")
str_trim_anything("-ghi--", "-", "both")
str_trim_anything("-ghi--", "-")
str_trim_anything("-ghi--", "-", "right")
str_trim_anything("-ghi--", "--")
str_trim_anything("-ghi--", "i-+")
</code></pre>

<hr>
<h2 id='strex'><code>strex</code>: extra string manipulation functions</h2><span id='topic+strex'></span><span id='topic+strex-package'></span>

<h3>Description</h3>

<p>There are some things that I wish were easier with the <code>stringr</code> or <code>stringi</code>
packages. The foremost of these is the extraction of numbers from strings.
<code>stringr</code> makes you figure out the regex for yourself; <code>strex</code> takes care of
this for you. There are many more useful functionalities in <code>strex</code>. In
particular, there's a <code>match_arg()</code> function which is more flexible than the
base <code>match.arg()</code>. Contributions to this package are encouraged: it is
intended as a miscellany of string manipulation functions which cannot be
found in <code>stringi</code> or <code>stringr</code>.
</p>


<h3>References</h3>

<p>Rory Nolan and Sergi Padilla-Parra (2017). filesstrings: An R
package for file and string manipulation. The Journal of Open Source
Software, 2(14).  <a href="https://doi.org/10.21105/joss.00260">doi:10.21105/joss.00260</a>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
