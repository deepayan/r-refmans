<!DOCTYPE html><html lang="en"><head><title>Help for package lg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lg'><p><code>lg</code>: A package for calculating the local Gaussian correlation in</p>
multivariate applications.</a></li>
<li><a href='#accept_reject'><p>Generate sample from a conditional density estimate</p></a></li>
<li><a href='#bw_select'><p>Bandwidth selection for local Gaussian correlation.</p></a></li>
<li><a href='#bw_select_cv_bivariate'><p>Cross-validation for bivariate distributions</p></a></li>
<li><a href='#bw_select_cv_trivariate'><p>Cross-validation for trivariate distributions</p></a></li>
<li><a href='#bw_select_cv_univariate'><p>Cross-validation for univariate distributions</p></a></li>
<li><a href='#bw_select_plugin_multivariate'><p>Plugin bandwidth selection for multivariate data</p></a></li>
<li><a href='#bw_select_plugin_univariate'><p>Plugin bandwidth selection for univariate data</p></a></li>
<li><a href='#bw_simple'><p>Create simple bandwidth object</p></a></li>
<li><a href='#check_bw_bivariate'><p>Check bandwidth vector</p></a></li>
<li><a href='#check_bw_method'><p>Check bw method</p></a></li>
<li><a href='#check_bw_trivariate'><p>Check bandwidth vector</p></a></li>
<li><a href='#check_data'><p>Check the data and grid</p></a></li>
<li><a href='#check_dmvnorm_arguments'><p>Check the arguments for the <code>dmvnorm_wrapper</code> function</p></a></li>
<li><a href='#check_est_method'><p>Check estimation method</p></a></li>
<li><a href='#check_lg'><p>Check that an object has class &quot;lg&quot;</p></a></li>
<li><a href='#ci_test'><p>Test for conditional independence</p></a></li>
<li><a href='#ci_test_statistic'><p>Calculate the value of the test statistic for the conditional independence</p>
test</a></li>
<li><a href='#clg'><p>The locally Gaussian conditional density estimator</p></a></li>
<li><a href='#cont_test'><p>Test for financial contagion</p></a></li>
<li><a href='#corplot'><p>Plot local correlation maps</p></a></li>
<li><a href='#dlg'><p>The locally Gaussian density estimator (LGDE)</p></a></li>
<li><a href='#dlg_bivariate'><p>Bivariate density estimation</p></a></li>
<li><a href='#dlg_marginal'><p>Marginal density estimation</p></a></li>
<li><a href='#dlg_marginal_wrapper'><p>Marginal estimates for multivariate data</p></a></li>
<li><a href='#dlg_trivariate'><p>Trivariate density estimation</p></a></li>
<li><a href='#dmvnorm_wrapper'><p>Wrapper for <code>dmvnorm</code></p></a></li>
<li><a href='#dmvnorm_wrapper_single'><p>Wrapper for <code>dmvnorm</code> - single point</p></a></li>
<li><a href='#gradient'><p>Auxiliary function for calculating the asymptotic standard deviations for the</p>
local Gaussian correlations</a></li>
<li><a href='#ind_test'><p>Independence tests</p></a></li>
<li><a href='#ind_teststat'><p>Function that calculates the test statistic in the independence tests.</p></a></li>
<li><a href='#interpolate_conditional_density'><p>Interpolate a univariate conditional density function</p></a></li>
<li><a href='#lg_main'><p>Create an <code>lg</code> object</p></a></li>
<li><a href='#local_conditional_covariance'><p>Calculate the local conditional covariance between two variables</p></a></li>
<li><a href='#make_C'><p>Auxiliary function for calculating the asymptotic standard deviations for the</p>
local Gaussian correlations</a></li>
<li><a href='#mvnorm_eval'><p>Evaluate the multivariate normal</p></a></li>
<li><a href='#partial_cor'><p>Calculate the local Gaussian partial correlation</p></a></li>
<li><a href='#replicate_under_ci'><p>Bootstrap replication under the null hypothesis</p></a></li>
<li><a href='#trans_normal'><p>Transform the marginals of a multivariate data set to standard normality</p>
based on the logspline density estimator (Kooperberg and Stone, 1991). See
Otneim and Tjøstheim (2017) for details.</a></li>
<li><a href='#u'><p>Auxiliary function for calculating the local score function u</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Locally Gaussian Distributions: Estimation and Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of locally Gaussian distributions. It provides methods for
    implementing locally Gaussian multivariate density estimation, conditional density 
    estimation, various independence tests for iid and time series data, a test for conditional 
    independence and a test for financial contagion.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Imports:</td>
<td>mvtnorm, localgauss, logspline, ggplot2, ks, np, tseries</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-12-05 11:05:29 UTC; hakon</td>
</tr>
<tr>
<td>Author:</td>
<td>Håkon Otneim [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Håkon Otneim &lt;hakon.otneim@nhh.no&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-12-05 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='lg'><code>lg</code>: A package for calculating the local Gaussian correlation in
multivariate applications.</h2><span id='topic+lg'></span><span id='topic+lg-package'></span>

<h3>Description</h3>

<p>The <code>lg</code> package provides implementations for the multivariate density
estimation and the conditional density estimation methods using local
Gaussian correlation as presented in Otneim &amp; Tjøstheim (2017) and Otneim &amp;
Tjøstheim (2018).
</p>


<h3>Details</h3>

<p>The main function is called <code>lg_main</code>, and takes as argument a data set
(represented by a matrix or data frame) as well as various (optional)
configurations that is described in detail in the articles mentioned above,
and in the documentation of this package. In particular, this function
will calculate the bandwidths used for estimation, using either a plugin
estimate (default), or a cross validation estimate. If <code>x</code> is the data
set, then the following line of code will create an <code>lg</code> object using
the default configuration, that can be used for density estimation
afterwards:
</p>
<p><code>lg_object &lt;- lg_main(x)</code>
</p>
<p>You can change estimation method, bandwidth selection method and other
parameters by using the arguments of the <code>lg_main</code> function.
</p>
<p>You can evaluate the multivariate density estimate on a <code>grid</code> as
described in Otneim &amp; Tjøstheim (2017) using the <code>dlg</code>-function as
follows:
</p>
<p><code>dens_est &lt;- dlg(lg_object, grid = grid).</code>
</p>
<p>Assuming that the data set has <strong>p</strong> variables, you can evaluate the <em>conditional</em> density of the <strong>p - q</strong> first variables (counting from column 1), <em>given</em> the remaining <strong>q</strong> variables being equal to <code>condition = c(v1, ..., vq)</code>, on a <code>grid</code>, by running
</p>
<p><code>conditional_dens_est &lt;- clg(lg_object, grid = grid, condition = condition)</code>.
</p>


<h3>References</h3>

<p>Otneim, Håkon, and Dag Tjøstheim. &quot;The locally gaussian density estimator for
multivariate data.&quot; Statistics and Computing 27, no. 6 (2017): 1595-1616.
</p>
<p>Otneim, Håkon, and Dag Tjøstheim. &quot;Conditional density estimation using
the local Gaussian correlation&quot; Statistics and Computing 28, no. 2 (2018):
303-321.
</p>

<hr>
<h2 id='accept_reject'>Generate sample from a conditional density estimate</h2><span id='topic+accept_reject'></span>

<h3>Description</h3>

<p>Generate a sample from a locally Gaussian conditional density estimate using
the accept-reject algorithm. If the <code>transform_to_marginal_normality</code>-
component of the lg_object is <code>TRUE</code>, the replicates will be on the
standard normal scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accept_reject(lg_object, condition, n_new, nodes, M = NULL,
  M_sim = 1500, M_corr = 1.5, n_corr = 1.2, return_just_M = FALSE,
  extend = 0.3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="accept_reject_+3A_lg_object">lg_object</code></td>
<td>
<p>An object of type <code>lg</code>, as produced by the
<code>lg_main</code>-function</p>
</td></tr>
<tr><td><code id="accept_reject_+3A_condition">condition</code></td>
<td>
<p>The value of the conditioning variables</p>
</td></tr>
<tr><td><code id="accept_reject_+3A_n_new">n_new</code></td>
<td>
<p>The number of observations to generate</p>
</td></tr>
<tr><td><code id="accept_reject_+3A_nodes">nodes</code></td>
<td>
<p>Either the number of equidistant nodes to generate, or a vector
of nodes supplied by the user</p>
</td></tr>
<tr><td><code id="accept_reject_+3A_m">M</code></td>
<td>
<p>The value for M in the accept-reject algorithm if already known</p>
</td></tr>
<tr><td><code id="accept_reject_+3A_m_sim">M_sim</code></td>
<td>
<p>The number of replicates to simulate in order to find a value
for M</p>
</td></tr>
<tr><td><code id="accept_reject_+3A_m_corr">M_corr</code></td>
<td>
<p>Correction factor for M, to be on the safe side</p>
</td></tr>
<tr><td><code id="accept_reject_+3A_n_corr">n_corr</code></td>
<td>
<p>Correction factor for n_new, so that we mostly will generate
enough observations in the first go</p>
</td></tr>
<tr><td><code id="accept_reject_+3A_return_just_m">return_just_M</code></td>
<td>
<p><code>TRUE</code> if we just want to find M, without actually
generating any replications.</p>
</td></tr>
<tr><td><code id="accept_reject_+3A_extend">extend</code></td>
<td>
<p>How far to extend the grid beyond the extreme data points when
interpolating, in share of the range</p>
</td></tr>
</table>

<hr>
<h2 id='bw_select'>Bandwidth selection for local Gaussian correlation.</h2><span id='topic+bw_select'></span>

<h3>Description</h3>

<p>Takes a matrix of data points and returns the bandwidths used for estimating
the local Gaussian correlations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_select(x, bw_method = "plugin", est_method = "1par",
  plugin_constant_marginal = 1.75, plugin_exponent_marginal = -1/5,
  plugin_constant_joint = 1.75, plugin_exponent_joint = -1/6,
  tol_marginal = 10^(-3), tol_joint = 10^(-3))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bw_select_+3A_x">x</code></td>
<td>
<p>A matrix or data frame with data, one column per variable, one row
per observation.</p>
</td></tr>
<tr><td><code id="bw_select_+3A_bw_method">bw_method</code></td>
<td>
<p>The method used for bandwidth selection. Must be either
<code>"cv"</code> (cross-validation, slow, but accurate) or <code>"plugin"</code>
(fast, but crude).</p>
</td></tr>
<tr><td><code id="bw_select_+3A_est_method">est_method</code></td>
<td>
<p>The estimation method, must be either &quot;1par&quot;, &quot;5par&quot; or
&quot;5par_marginals_fixed&quot;, see <code><a href="#topic+lg_main">lg_main</a></code>.</p>
</td></tr>
<tr><td><code id="bw_select_+3A_plugin_constant_marginal">plugin_constant_marginal</code></td>
<td>
<p>The constant <code>c</code> in <code>cn^a</code> used for
finding the plugin bandwidth for locally Gaussian marginal density
estimates, which we need if estimation method is &quot;5par_marginals_fixed&quot;.</p>
</td></tr>
<tr><td><code id="bw_select_+3A_plugin_exponent_marginal">plugin_exponent_marginal</code></td>
<td>
<p>The constant <code>a</code> in <code>cn^a</code> used for
finding the plugin bandwidth for locally Gaussian marginal density
estimates, which we need if estimation method is &quot;5par_marginals_fixed&quot;.</p>
</td></tr>
<tr><td><code id="bw_select_+3A_plugin_constant_joint">plugin_constant_joint</code></td>
<td>
<p>The constant <code>c</code> in <code>cn^a</code> used for
finding the plugin bandwidth for estimating the pairwise local Gaussian
correlation between two variables.</p>
</td></tr>
<tr><td><code id="bw_select_+3A_plugin_exponent_joint">plugin_exponent_joint</code></td>
<td>
<p>The constant <code>a</code> in <code>cn^a</code> used for
finding the plugin bandwidth for estimating the pairwise local Gaussian
correlation between two variables.</p>
</td></tr>
<tr><td><code id="bw_select_+3A_tol_marginal">tol_marginal</code></td>
<td>
<p>The absolute tolerance in the optimization for finding
the marginal bandwidths when using cross validation.</p>
</td></tr>
<tr><td><code id="bw_select_+3A_tol_joint">tol_joint</code></td>
<td>
<p>The absolute tolerance in the optimization for finding the
joint bandwidths when using cross-validation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main bandwidth selection function within the framework of locally
Gaussian distributions as described in Otneim and Tjøstheim (2017). This
function takes in a data set of arbitrary dimension, and calculates the
bandwidths needed to find the pairwise local Gaussian correlations, and
is mainly used by the main <code>lg_main</code> wrapper function.
</p>


<h3>Value</h3>

<p>A list with three elements, <code>marginal</code>  contains the bandwidths
used for the marginal locally Gaussian estimation,
<code>marginal_convergence</code> contains the convergence flags for the marginal
bandwidths, as returned by the <code>optim</code> function, and <code>joint</code>
contains the pairwise bandwidths and convergence flags.
</p>


<h3>References</h3>

<p>Otneim, Håkon, and Dag Tjøstheim. &quot;The locally gaussian density estimator for
multivariate data.&quot; Statistics and Computing 27, no. 6 (2017): 1595-1616.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- cbind(rnorm(100), rnorm(100), rnorm(100))
  bw &lt;- bw_select(x)

</code></pre>

<hr>
<h2 id='bw_select_cv_bivariate'>Cross-validation for bivariate distributions</h2><span id='topic+bw_select_cv_bivariate'></span>

<h3>Description</h3>

<p>Uses cross-validation to find the optimal bandwidth for a bivariate locally
Gaussian fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_select_cv_bivariate(x, tol = 10^(-3), est_method = "1par",
  bw_marginal = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bw_select_cv_bivariate_+3A_x">x</code></td>
<td>
<p>The matrix of data points.</p>
</td></tr>
<tr><td><code id="bw_select_cv_bivariate_+3A_tol">tol</code></td>
<td>
<p>The absolute tolerance in the optimization, used by the
<code>optim</code>-function.</p>
</td></tr>
<tr><td><code id="bw_select_cv_bivariate_+3A_est_method">est_method</code></td>
<td>
<p>The estimation method for the bivariate fit. If estimation
method is <code>5par_marginals_fixed</code>, the marginal bandwidths must be
supplied as well through the argument <code>bw_marginal</code>. This is
automatically handled by the <code>lg_main</code> wrapper function.</p>
</td></tr>
<tr><td><code id="bw_select_cv_bivariate_+3A_bw_marginal">bw_marginal</code></td>
<td>
<p>The bandwidths for estimation of the marginals if method
<code>5par_fixed_marginals</code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides an implementation for the Cross Validation algorithm
for bandwidth selection described in Otneim &amp; Tjøstheim (2017), Section 4.
Let <code class="reqn">\hat{f}_h(x)</code> be the bivariate locally Gaussian density estimate
obtained using the bandwidth <code class="reqn">h</code>, then this function returns the
bandwidth that maximizes </p>
<p style="text-align: center;"><code class="reqn">CV(h) = n^{-1} \sum_{i=1}^n \log
\hat{f}_h^{(-i)}(x_i),</code>
</p>
<p> where <code class="reqn">\hat{f}_h^{(-i)}</code> is the density estimate
calculated without observation <code class="reqn">x_i</code>.
</p>
<p>The recommended use of this function is through the <code>lg_main</code> wrapper
function.
</p>


<h3>Value</h3>

<p>The function returns a list with two elements: <code>bw</code> is the
selected bandwidths, and <code>convergence</code> is the convergence flag returned
by the <code>optim</code>-function.
</p>


<h3>References</h3>

<p>Otneim, Håkon, and Dag Tjøstheim. &quot;The locally gaussian density estimator for
multivariate data.&quot; Statistics and Computing 27, no. 6 (2017): 1595-1616.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    x &lt;- cbind(rnorm(100), rnorm(100))
    bw &lt;- bw_select_cv_univariate(x)
  
## End(Not run)

</code></pre>

<hr>
<h2 id='bw_select_cv_trivariate'>Cross-validation for trivariate distributions</h2><span id='topic+bw_select_cv_trivariate'></span>

<h3>Description</h3>

<p>Uses cross-validation to find the optimal bandwidth for a trivariate locally
Gaussian fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_select_cv_trivariate(x, tol = 10^(-3))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bw_select_cv_trivariate_+3A_x">x</code></td>
<td>
<p>The matrix of data points.</p>
</td></tr>
<tr><td><code id="bw_select_cv_trivariate_+3A_tol">tol</code></td>
<td>
<p>The absolute tolerance in the optimization, used by the
<code>optim</code>-function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides an implementation for the Cross Validation algorithm
for bandwidth selection described in Otneim &amp; Tjøstheim (2017), Section 4,
but for trivariate distributions. Let <code class="reqn">\hat{f}_h(x)</code> be the trivariate
locally Gaussian density estimate obtained using the bandwidth <code class="reqn">h</code>, then
this function returns the bandwidth that maximizes
</p>
<p style="text-align: center;"><code class="reqn">CV(h) = n^{-1} \sum_{i=1}^n \log \hat{f}_h^{(-i)}(x_i),</code>
</p>
<p> where
<code class="reqn">\hat{f}_h^{(-i)}</code> is the density estimate calculated without observation
<code class="reqn">x_i</code>.
</p>
<p>The recommended use of this function is through the <code>lg_main</code> wrapper
function.
</p>


<h3>Value</h3>

<p>The function returns a list with two elements: <code>bw</code> is the
selected bandwidths, and <code>convergence</code> is the convergence flag returned
by the <code>optim</code>-function.
</p>


<h3>References</h3>

<p>Otneim, Håkon, and Dag Tjøstheim. &quot;The locally gaussian density estimator for
multivariate data.&quot; Statistics and Computing 27, no. 6 (2017): 1595-1616.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    x &lt;- cbind(rnorm(100), rnorm(100), rnorm(100))
    bw &lt;- bw_select_cv_trivariate(x)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='bw_select_cv_univariate'>Cross-validation for univariate distributions</h2><span id='topic+bw_select_cv_univariate'></span>

<h3>Description</h3>

<p>Uses cross-validation to find the optimal bandwidth for a univariate locally
Gaussian fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_select_cv_univariate(x, tol = 10^(-3))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bw_select_cv_univariate_+3A_x">x</code></td>
<td>
<p>The vector of data points.</p>
</td></tr>
<tr><td><code id="bw_select_cv_univariate_+3A_tol">tol</code></td>
<td>
<p>The absolute tolerance in the optimization, passed to the
<code>optim</code>-function using the BFGS-method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides the univariate version of the Cross Validation
algorithm for bandwidth selection described in Otneim &amp; Tjøstheim (2017),
Section 4. Let <code class="reqn">\hat{f}_h(x)</code> be the univariate locally Gaussian density
estimate obtained using the bandwidth <code class="reqn">h</code>, then this function returns the
bandwidth that maximizes </p>
<p style="text-align: center;"><code class="reqn">CV(h) = n^{-1} \sum_{i=1}^n \log
\hat{f}_h^{(-i)}(x_i),</code>
</p>
<p> where <code class="reqn">\hat{f}_h^{(-i)}</code> is the density estimate
calculated without observation <code class="reqn">x_i</code>.
</p>


<h3>Value</h3>

<p>The function returns a list with two elements: <code>bw</code> is the
selected bandwidth, and <code>convergence</code> is the convergence flag returned
by the <code>optim</code>-function.
</p>


<h3>References</h3>

<p>Otneim, Håkon, and Dag Tjøstheim. &quot;The locally gaussian density estimator for
multivariate data.&quot; Statistics and Computing 27, no. 6 (2017): 1595-1616.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- rnorm(100)
  bw &lt;- bw_select_cv_univariate(x)

</code></pre>

<hr>
<h2 id='bw_select_plugin_multivariate'>Plugin bandwidth selection for multivariate data</h2><span id='topic+bw_select_plugin_multivariate'></span>

<h3>Description</h3>

<p>Returns a plugin bandwidth for multivariate data matrices for the estimation
of local Gaussian correlations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_select_plugin_multivariate(x = NULL, n = nrow(x), c = 1.75,
  a = -1/6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bw_select_plugin_multivariate_+3A_x">x</code></td>
<td>
<p>The data matrix.</p>
</td></tr>
<tr><td><code id="bw_select_plugin_multivariate_+3A_n">n</code></td>
<td>
<p>The number of data points. Can provide only this if we do not want
to supply the entire data vector.</p>
</td></tr>
<tr><td><code id="bw_select_plugin_multivariate_+3A_c">c</code></td>
<td>
<p>A constant, se details.</p>
</td></tr>
<tr><td><code id="bw_select_plugin_multivariate_+3A_a">a</code></td>
<td>
<p>A constant, se details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes in a data matrix with <code>n</code> rows, and returns a the
real number <code>c*n^a</code>, which is a quick and dirty way of selecting a
bandwidth for locally Gaussian density estimation. The number  <code>c</code> is by
default set to <code>1.75</code>, and <code>c = -1/6</code> is the usual exponent, that
stems from the asymptotic convergence rate of the density estimate. This
function is usually called from the <code>lg_main</code> wrapper function.
</p>


<h3>Value</h3>

<p>A number, the selected bandwidth.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- cbind(rnorm(100), rnorm(100))
  bw &lt;- bw_select_plugin_multivariate(x = x)
  bw &lt;- bw_select_plugin_multivariate(n = 100)

</code></pre>

<hr>
<h2 id='bw_select_plugin_univariate'>Plugin bandwidth selection for univariate data</h2><span id='topic+bw_select_plugin_univariate'></span>

<h3>Description</h3>

<p>Returns a plugin bandwidth for data vectors for use with univariate locally
Gaussian density estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_select_plugin_univariate(x = NULL, n = length(x), c = 1.75,
  a = -1/5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bw_select_plugin_univariate_+3A_x">x</code></td>
<td>
<p>The data vector.</p>
</td></tr>
<tr><td><code id="bw_select_plugin_univariate_+3A_n">n</code></td>
<td>
<p>The number of data points. Can provide only this if we do not want
to supply the entire data vector.</p>
</td></tr>
<tr><td><code id="bw_select_plugin_univariate_+3A_c">c</code></td>
<td>
<p>A constant, se details.</p>
</td></tr>
<tr><td><code id="bw_select_plugin_univariate_+3A_a">a</code></td>
<td>
<p>A constant, se details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes in a data vector of length <code>n</code>, and returns a the
real number <code>c*n^a</code>, which is a quick and dirty way of selecting a
bandwidth for univariate locally Gaussian density estimation. The number
<code>c</code> is by default set to <code>1.75</code>, and <code>c = -1/5</code> is the usual
exponent that stems from the asymptotic convergence rate of the density
estimate. Recommended use of this function is through the <code>lg_main</code> wrapper
function.
</p>


<h3>Value</h3>

<p>A number, the selected bandwidth.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- rnorm(100)
  bw &lt;- bw_select_plugin_univariate(x = x)
  bw &lt;- bw_select_plugin_univariate(n = 100)

</code></pre>

<hr>
<h2 id='bw_simple'>Create simple bandwidth object</h2><span id='topic+bw_simple'></span>

<h3>Description</h3>

<p>Create a simple bandwidths object for local Gaussian correlations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_simple(joint = 1, marg = NA, x = NULL, dim = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bw_simple_+3A_joint">joint</code></td>
<td>
<p>Joint bandwidth</p>
</td></tr>
<tr><td><code id="bw_simple_+3A_marg">marg</code></td>
<td>
<p>Marginal bandwidths</p>
</td></tr>
<tr><td><code id="bw_simple_+3A_x">x</code></td>
<td>
<p>The data set</p>
</td></tr>
<tr><td><code id="bw_simple_+3A_dim">dim</code></td>
<td>
<p>The number of variables</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a quick way of producing a bandwidth object that may
be used in the <code>lg_main()</code>-function. The user must specify a bandwidth
<code>joint</code> that is used for all joint bandwidths, and the user may specify
<code>marg</code>, a marginal bandwidth that will be used for all marginal
bandwidths. This is needed if the subsequent analyses use
<code>est_method = "5par_marginals_fixed"</code>.
</p>
<p>The function must know the dimension of the problem, which is achieved by
either supplying the data set <code>x</code> or the number of variables <code>dim</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  bw_object &lt;- bw_simple(joint = 1, marg = 1, dim = 3)

</code></pre>

<hr>
<h2 id='check_bw_bivariate'>Check bandwidth vector</h2><span id='topic+check_bw_bivariate'></span>

<h3>Description</h3>

<p>Checks that the bandwidth vector supplied to the bivariate density function
is a numeric vector of length 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_bw_bivariate(bw)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_bw_bivariate_+3A_bw">bw</code></td>
<td>
<p>The bandwidth vector to be checked</p>
</td></tr>
</table>

<hr>
<h2 id='check_bw_method'>Check bw method</h2><span id='topic+check_bw_method'></span>

<h3>Description</h3>

<p>Checks that the bandwidth method is one of the allowed values, currently &quot;cv&quot;
or &quot;plugin&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_bw_method(bw_method)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_bw_method_+3A_bw_method">bw_method</code></td>
<td>
<p>Check if equal to &quot;cv&quot; or &quot;plugin&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='check_bw_trivariate'>Check bandwidth vector</h2><span id='topic+check_bw_trivariate'></span>

<h3>Description</h3>

<p>Checks that the bandwidth vector supplied to the bivariate density function
is a numeric vector of length 3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_bw_trivariate(bw)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_bw_trivariate_+3A_bw">bw</code></td>
<td>
<p>The bandwidth vector to be checked</p>
</td></tr>
</table>

<hr>
<h2 id='check_data'>Check the data and grid</h2><span id='topic+check_data'></span>

<h3>Description</h3>

<p>Checks that the data or grid provided is of the correct form. This function
is an auxiliary function that can quickly check that a supplied data set or
grid is a matrix or a data frame, and that it has the correct dimension, as
defined by the <code>dim_check</code> parameter. The <code>type</code> argument is simply
a character vector &quot;data&quot; or &quot;grid&quot; that is used for printing error messages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_data(x, dim_check = NA, type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_data_+3A_x">x</code></td>
<td>
<p>Data or grid</p>
</td></tr>
<tr><td><code id="check_data_+3A_dim_check">dim_check</code></td>
<td>
<p>How many columns do we expect?</p>
</td></tr>
<tr><td><code id="check_data_+3A_type">type</code></td>
<td>
<p>Is it the &quot;grid&quot; or &quot;data&quot; for use in error messages.</p>
</td></tr>
</table>

<hr>
<h2 id='check_dmvnorm_arguments'>Check the arguments for the <code>dmvnorm_wrapper</code> function</h2><span id='topic+check_dmvnorm_arguments'></span>

<h3>Description</h3>

<p>Checks that the arguments provided to the <code>dmvnorm_wrapper</code>-function are
numerical vectors, all having the same lengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dmvnorm_arguments(eval_points, mu_1, mu_2, sig_1, sig_2, rho)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_dmvnorm_arguments_+3A_eval_points">eval_points</code></td>
<td>
<p>A <code>kx2</code> matrix with evaluation points</p>
</td></tr>
<tr><td><code id="check_dmvnorm_arguments_+3A_mu_1">mu_1</code></td>
<td>
<p>The first expectation vector</p>
</td></tr>
<tr><td><code id="check_dmvnorm_arguments_+3A_mu_2">mu_2</code></td>
<td>
<p>The second expectation vector</p>
</td></tr>
<tr><td><code id="check_dmvnorm_arguments_+3A_sig_1">sig_1</code></td>
<td>
<p>The first standard deviation vector</p>
</td></tr>
<tr><td><code id="check_dmvnorm_arguments_+3A_sig_2">sig_2</code></td>
<td>
<p>The second standard deviation vector</p>
</td></tr>
<tr><td><code id="check_dmvnorm_arguments_+3A_rho">rho</code></td>
<td>
<p>The correlation vector</p>
</td></tr>
</table>

<hr>
<h2 id='check_est_method'>Check estimation method</h2><span id='topic+check_est_method'></span>

<h3>Description</h3>

<p>Checks that the estimation method is one of the allowed values, currently
&quot;1par&quot;, &quot;5par&quot; and &quot;5par_marginals_fixed&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_est_method(est_method)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_est_method_+3A_est_method">est_method</code></td>
<td>
<p>Check if equal to a valid value</p>
</td></tr>
</table>

<hr>
<h2 id='check_lg'>Check that an object has class &quot;lg&quot;</h2><span id='topic+check_lg'></span>

<h3>Description</h3>

<p>Checks that the provided object has class <code>lg</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_lg(check_object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_lg_+3A_check_object">check_object</code></td>
<td>
<p>The object to be checked</p>
</td></tr>
</table>

<hr>
<h2 id='ci_test'>Test for conditional independence</h2><span id='topic+ci_test'></span>

<h3>Description</h3>

<p>Perform a test for conditional independence between the first two variables
in the data set, given the remaining variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_test(lg_object, h = function(x) x^2, S = function(y) rep(T,
  nrow(y)), n_rep = 500, nodes = 100, M = NULL, M_sim = 1500,
  M_corr = 1.5, n_corr = 1.2, extend = 0.3, return_time = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ci_test_+3A_lg_object">lg_object</code></td>
<td>
<p>An object of type <code>lg</code>, as produced by the
<code>lg_main</code>-function</p>
</td></tr>
<tr><td><code id="ci_test_+3A_h">h</code></td>
<td>
<p>The <code>h</code>-function used in the calculation of the test statistic.
The default value is <code>h(x) = x^2</code>.</p>
</td></tr>
<tr><td><code id="ci_test_+3A_s">S</code></td>
<td>
<p>The integration area in the test statistic. Logical function that
takes grid points as argument.</p>
</td></tr>
<tr><td><code id="ci_test_+3A_n_rep">n_rep</code></td>
<td>
<p>The number of replicated bootstrap samples</p>
</td></tr>
<tr><td><code id="ci_test_+3A_nodes">nodes</code></td>
<td>
<p>Either the number of equidistant nodes to generate, or a vector
of nodes supplied by the user</p>
</td></tr>
<tr><td><code id="ci_test_+3A_m">M</code></td>
<td>
<p>The value for M in the accept-reject algorithm if already known</p>
</td></tr>
<tr><td><code id="ci_test_+3A_m_sim">M_sim</code></td>
<td>
<p>The number of replicates to simulate in order to find a value
for M</p>
</td></tr>
<tr><td><code id="ci_test_+3A_m_corr">M_corr</code></td>
<td>
<p>Correction factor for M, to be on the safe side</p>
</td></tr>
<tr><td><code id="ci_test_+3A_n_corr">n_corr</code></td>
<td>
<p>Correction factor for n_new, so that we mostly will generate
enough observations in the first go</p>
</td></tr>
<tr><td><code id="ci_test_+3A_extend">extend</code></td>
<td>
<p>How far to extend the grid beyond the extreme data points when
interpolating, in share of the range</p>
</td></tr>
<tr><td><code id="ci_test_+3A_return_time">return_time</code></td>
<td>
<p>Measure how long the test takes to run, and return along
with the test result</p>
</td></tr>
</table>

<hr>
<h2 id='ci_test_statistic'>Calculate the value of the test statistic for the conditional independence
test</h2><span id='topic+ci_test_statistic'></span>

<h3>Description</h3>

<p>Calculate the test statistic in the test for conditional independence between
the first two variables in the data set, given the remaining variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_test_statistic(lg_object, h = function(x) x^2, S = function(y)
  rep(T, nrow(y)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ci_test_statistic_+3A_lg_object">lg_object</code></td>
<td>
<p>An object of type <code>lg</code>, as produced by the
<code>lg_main</code>-function</p>
</td></tr>
<tr><td><code id="ci_test_statistic_+3A_h">h</code></td>
<td>
<p>The <code>h</code>-function used in the calculation of the test statistic.
The default value is <code>h(x) = x^2</code>.</p>
</td></tr>
<tr><td><code id="ci_test_statistic_+3A_s">S</code></td>
<td>
<p>The integration area in the test statistic. Logical function that
takes grid points as argument.</p>
</td></tr>
</table>

<hr>
<h2 id='clg'>The locally Gaussian conditional density estimator</h2><span id='topic+clg'></span>

<h3>Description</h3>

<p>Estimate a conditional density function using locally Gaussian
approximations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clg(lg_object, grid = NULL, condition = NULL,
  normalization_points = NULL, fixed_grid = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clg_+3A_lg_object">lg_object</code></td>
<td>
<p>An object of type <code>lg</code>, as produced by the
<code>lg_main</code>-function.</p>
</td></tr>
<tr><td><code id="clg_+3A_grid">grid</code></td>
<td>
<p>A matrix of grid points, where we want to evaluate the density
estimate. Number of columns *must* be the same as number of variables in
X1.</p>
</td></tr>
<tr><td><code id="clg_+3A_condition">condition</code></td>
<td>
<p>A vector with conditions for the variables that we condition
upon. Length of this vector *must* be the same as the number of variables
in X2. The function will throw an error of there is any discrepancy in the
dimensions of the <code>grid</code>, <code>condition</code> and data set.</p>
</td></tr>
<tr><td><code id="clg_+3A_normalization_points">normalization_points</code></td>
<td>
<p>How many grid points for approximating the integral
of the density estimate, to use for normalization?</p>
</td></tr>
<tr><td><code id="clg_+3A_fixed_grid">fixed_grid</code></td>
<td>
<p>Not used presently.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the conditional version of the locally Gaussian density
estimator (LGDE), described in Otneim &amp; Tjøstheim (2018). The function takes
as arguments an <code>lg</code>-object as produced by the main <code>lg_main</code>- function,
a grid of points where the density estimate should be estimated, and a set of
conditions.
</p>
<p>The variables must be sorted before they are supplied to this function. It
will always assume that the free variables come before the conditioning
variables.
</p>
<p>Assume that X is a stochastic vector with two components X1 and X2. This
function will thus estimate the conditional density of X1 given a specified
value of X2.
</p>


<h3>Value</h3>

<p>A list containing the conditional density estimate as well as all the
running parameters that has been used. The elements are:
</p>

<ul>
<li> <p><code>f_est</code>: The estimated conditional density.
</p>
</li>
<li> <p><code>c_mean</code>: The estimated local conditional means as defined in
equation (10) of Otneim &amp; Tjøstheim (2017).
</p>
</li>
<li> <p><code>c_cov</code>: The estimated local conditional covariance matrices
as defined in equation (11) of Otneim &amp; Tjøstheim (2017).
</p>
</li>
<li> <p><code>x</code>: The data set.
</p>
</li>
<li> <p><code>bw</code>: The bandwidth object.
</p>
</li>
<li> <p><code>transformed_data</code>: The data transformed to approximate
marginal standard normality (if selected).
</p>
</li>
<li> <p><code>normalizing_constants</code>: The normalizing constants used to
transform data and grid back and forth to the marginal standard
normality scale, as seen in eq. (8) of Otneim &amp; Tjøstheim (2017)
(if selected).
</p>
</li>
<li> <p><code>grid</code>: The grid where the estimation was performed, on the
original scale.
</p>
</li>
<li> <p><code>transformed_grid</code>: The grid where the estimation was
performed, on the marginal standard normal scale.
</p>
</li>
<li> <p><code>normalization_points</code> Number of grid points used
to approximate the integral of the density estimate, in order to
normalize?
</p>
</li>
<li> <p><code>normalization_constant</code> If approximated, the integral of the
non-normalized density estimate. NA if not normalized.
</p>
</li>
<li> <p><code>density_normalized</code> Logical, indicates whether the final
density estimate (contained in f_est) has been approximately
normalized to have unit integral.
</p>
</li></ul>



<h3>References</h3>

<p>Otneim, Håkon, and Dag Tjøstheim. &quot;Conditional density estimation using
the local Gaussian correlation&quot; Statistics and Computing 28, no. 2 (2018):
303-321.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # A 3 variate example
  x &lt;- cbind(rnorm(100), rnorm(100), rnorm(100))

  # Generate the lg-object with default settings
  lg_object &lt;- lg_main(x)

  # Estimate the conditional density of X1|X2 = 0, X3 = 1 on a small grid
  cond_dens &lt;- clg(lg_object, grid = matrix(-4:4, ncol = 1), condition = c(0, 1))

</code></pre>

<hr>
<h2 id='cont_test'>Test for financial contagion</h2><span id='topic+cont_test'></span>

<h3>Description</h3>

<p>Test for financial contagion by means of the local Gaussian correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cont_test(lg_object_nc, lg_object_c,
  grid_range = quantile(rbind(lg_object_nc$x, lg_object_c$x), c(0.05,
  0.95)), grid_length = 30, n_rep = 1000, weight = function(y) {    
  rep(1, nrow(y)) })
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cont_test_+3A_lg_object_nc">lg_object_nc</code></td>
<td>
<p>An object of type <code>lg</code>, as produced by the
<code>lg_main</code>-function for the observations covering the non-crisis
period. The data must be two dimensional.</p>
</td></tr>
<tr><td><code id="cont_test_+3A_lg_object_c">lg_object_c</code></td>
<td>
<p>An object of type <code>lg</code>, as produced by the
<code>lg_main</code>-function for the observations covering the crisis period.
The data must be two dimensional.</p>
</td></tr>
<tr><td><code id="cont_test_+3A_grid_range">grid_range</code></td>
<td>
<p>This test measures the local correlations a long the
diagonal specified by this vector of length two.</p>
</td></tr>
<tr><td><code id="cont_test_+3A_grid_length">grid_length</code></td>
<td>
<p>The number of grid points.</p>
</td></tr>
<tr><td><code id="cont_test_+3A_n_rep">n_rep</code></td>
<td>
<p>The number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="cont_test_+3A_weight">weight</code></td>
<td>
<p>Weight function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an implementation of the test for financial contagion
developed by Støve, Tjøstheim and Hufthammer (2013). They test whether the
local correlations between two financial time series are different before and
during crisis times. The distinction between crisis and non-crisis times must
be made by the user.
</p>


<h3>Value</h3>

<p>A list containing the test result as well as various parameters. The
elements are:
</p>

<ul>
<li> <p><code>observed</code> The observed value of the test statistic.
</p>
</li>
<li> <p><code>replicated</code> The replicated values of the test statistic.
</p>
</li>
<li> <p><code>p_value</code> The p-value of the test.
</p>
</li>
<li> <p><code>local_correlations</code> The local correlations measured along the
diagonal, for the non-crisis and crisis periods respectively.
</p>
</li></ul>



<h3>References</h3>

<p>Støve, Bård, Dag Tjøstheim, and Karl Ove Hufthammer. &quot;Using local Gaussian
correlation in a nonlinear re-examination of financial contagion.&quot; Journal
of Empirical Finance 25 (2014): 62-82.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   # Run the test on some built-in stock data
   data(EuStockMarkets)
   x &lt;- apply(EuStockMarkets, 2, function(x) diff(log(x)))[, 1:2]

   # Define the crisis and non-crisis periods (arbitrarily for this simple
   # example)
   non_crisis &lt;- x[1:100, ]
   crisis     &lt;- x[101:200, ]

   # Create the lg-objects, with parameters that match the applications in the
   # original publication describibg the test
   lg_object_nc &lt;- lg_main(non_crisis, est_method = "5par",
                           transform_to_marginal_normality = FALSE)
   lg_object_c  &lt;- lg_main(crisis, est_method = "5par",
                           transform_to_marginal_normality = FALSE)

   ## Not run: 
   # Run the test (with very few resamples for illustration)
   test_result &lt;- cont_test(lg_object_nc, lg_object_c,
                            n_rep = 10)
   
## End(Not run)

</code></pre>

<hr>
<h2 id='corplot'>Plot local correlation maps</h2><span id='topic+corplot'></span>

<h3>Description</h3>

<p>Plot the estimated local correlation map (or local <em>partial</em> correlation
map) for a pair of variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corplot(dlg_object, pair = 1, gaussian_scale = FALSE,
  plot_colormap = TRUE, plot_obs = FALSE, plot_labels = TRUE,
  plot_legend = FALSE, plot_thres = 0, alpha_tile = 0.8,
  alpha_point = 0.8, low_color = "blue", high_color = "red",
  break_int = 0.2, label_size = 3, font_family = "sans",
  point_size = NULL, xlim = NULL, ylim = NULL, xlab = NULL,
  ylab = NULL, rholab = NULL, main = NULL, subtitle = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="corplot_+3A_dlg_object">dlg_object</code></td>
<td>
<p>The density estimation object produced by the dlg-function</p>
</td></tr>
<tr><td><code id="corplot_+3A_pair">pair</code></td>
<td>
<p>Integer indicating which pair of variables you want to plot. The
function looks up the corresponding variables in the bandwidth object used
to calculate the dlg object, and you can inspect this in
<code>dlg_object$bw$joint</code>. Defaults to 1 (the first pair, usually variable
1 against variable 2).</p>
</td></tr>
<tr><td><code id="corplot_+3A_gaussian_scale">gaussian_scale</code></td>
<td>
<p>Logical, if <code>TRUE</code> the plot is produced on the
marginal standard Gaussian scale.</p>
</td></tr>
<tr><td><code id="corplot_+3A_plot_colormap">plot_colormap</code></td>
<td>
<p>Logical, if <code>TRUE</code> the plot includes a colormap to
visualize the value of the local correlation.</p>
</td></tr>
<tr><td><code id="corplot_+3A_plot_obs">plot_obs</code></td>
<td>
<p>Logical, if <code>TRUE</code> the observations are plotted.</p>
</td></tr>
<tr><td><code id="corplot_+3A_plot_labels">plot_labels</code></td>
<td>
<p>Logical, if <code>TRUE</code> character labels with local
correlation values are plotted.</p>
</td></tr>
<tr><td><code id="corplot_+3A_plot_legend">plot_legend</code></td>
<td>
<p>Logical, if <code>TRUE</code> a color legend is plotted.</p>
</td></tr>
<tr><td><code id="corplot_+3A_plot_thres">plot_thres</code></td>
<td>
<p>A number between 0 and 1 indicating the threshold value to
be used for not plotting the estimated local correlation in areas with no
data. Uses a quick bivariate kernel density estimate a criterion, and skips
plotting in areas with kernel density estimate less than the fraction
plot_thres of the maximum density estimate. If 0 (default), everything is
plotted, if 1 nothing is plotted. Typical values may be in the
0.001-0.01-range.</p>
</td></tr>
<tr><td><code id="corplot_+3A_alpha_tile">alpha_tile</code></td>
<td>
<p>The alpha-value indicating the transparency of the color
tiles. Number between 0 (transparent) and 1 (not transparent).</p>
</td></tr>
<tr><td><code id="corplot_+3A_alpha_point">alpha_point</code></td>
<td>
<p>he alpha-value indicating the transparency of the
observations. Number between 0 (transparent) and 1 (not transparent).</p>
</td></tr>
<tr><td><code id="corplot_+3A_low_color">low_color</code></td>
<td>
<p>The color corresponding to correlation equal to -1 (default:
blue).</p>
</td></tr>
<tr><td><code id="corplot_+3A_high_color">high_color</code></td>
<td>
<p>The color corresponding to correlation equal to 1 (default:
red).</p>
</td></tr>
<tr><td><code id="corplot_+3A_break_int">break_int</code></td>
<td>
<p>Break interval in the color gradient.</p>
</td></tr>
<tr><td><code id="corplot_+3A_label_size">label_size</code></td>
<td>
<p>Size of text labels, if plotted.</p>
</td></tr>
<tr><td><code id="corplot_+3A_font_family">font_family</code></td>
<td>
<p>Font family used for text labels, if plotted.</p>
</td></tr>
<tr><td><code id="corplot_+3A_point_size">point_size</code></td>
<td>
<p>Size of points used for plotting the observations.</p>
</td></tr>
<tr><td><code id="corplot_+3A_xlim">xlim</code></td>
<td>
<p>x-limits</p>
</td></tr>
<tr><td><code id="corplot_+3A_ylim">ylim</code></td>
<td>
<p>y-limits</p>
</td></tr>
<tr><td><code id="corplot_+3A_xlab">xlab</code></td>
<td>
<p>x-label</p>
</td></tr>
<tr><td><code id="corplot_+3A_ylab">ylab</code></td>
<td>
<p>y-label</p>
</td></tr>
<tr><td><code id="corplot_+3A_rholab">rholab</code></td>
<td>
<p>Label for the legend, if plotted</p>
</td></tr>
<tr><td><code id="corplot_+3A_main">main</code></td>
<td>
<p>Title of plot</p>
</td></tr>
<tr><td><code id="corplot_+3A_subtitle">subtitle</code></td>
<td>
<p>Subtitle of plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots a map of estimated local Gaussian correlations of a
specified pair (defaults to the first pair) of variables as produced by the
dlg-function. This plot is heavily inspired by the local correlation plots
produced by the 'localgauss'-package by Berentsen et. al (2014), but it is
here more easily customized and specially adapted to the ecosystem within the
<code>lg</code>-package. The plotting is carried out using the ggplot2-package
(Wickham, 2009). This function now also accepts objects created by the
<code>partial_cor()</code>-function, in order to create local <em>partial</em>
correlation maps.
</p>


<h3>References</h3>

<p>Berentsen, G. D., Kleppe, T. S., &amp; Tjøstheim, D. (2014). Introducing
localgauss, an R package for estimating and visualizing local Gaussian
correlation. Journal of Statistical Software, 56(1), 1-18.
</p>
<p>H. Wickham. ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New
York, 2009.
</p>

<hr>
<h2 id='dlg'>The locally Gaussian density estimator (LGDE)</h2><span id='topic+dlg'></span>

<h3>Description</h3>

<p>Estimate a multivariate density function using locally Gaussian
approximations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlg(lg_object, grid, level = 0.95, normalization_points = NULL,
  bootstrap = F, B = 500)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlg_+3A_lg_object">lg_object</code></td>
<td>
<p>An object of type <code>lg</code>, as produced by the
<code>lg_main</code>-function.</p>
</td></tr>
<tr><td><code id="dlg_+3A_grid">grid</code></td>
<td>
<p>A matrix of grid points, where we want to evaluate the density
estimate.</p>
</td></tr>
<tr><td><code id="dlg_+3A_level">level</code></td>
<td>
<p>Specify a level if asymptotic standard deviations and confidence
intervals should be returned.</p>
</td></tr>
<tr><td><code id="dlg_+3A_normalization_points">normalization_points</code></td>
<td>
<p>How many grid points for approximating the integral
of the density estimate, to use for normalization?</p>
</td></tr>
<tr><td><code id="dlg_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Calculate bootstrapped confidence intervals instead.</p>
</td></tr>
<tr><td><code id="dlg_+3A_b">B</code></td>
<td>
<p>Number of bootstrap replications if using bootstrapped confidence
intervals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does multivariate density estimation using the locally Gaussian
density estimator (LGDE), that was introduced by Otneim &amp; Tjøstheim (2017).
The function takes as arguments an <code>lg</code>-object as produced by the main
<code>lg_main</code>-function (where all the running parameters are specified), and
a grid of points where the density estimate should be estimated.
</p>


<h3>Value</h3>

<p>A list containing the density estimate as well as all the running
parameters that has been used. The elements are:
</p>

<ul>
<li> <p><code>f_est</code>: The estimated multivariate density.
</p>
</li>
<li> <p><code>loc_mean</code>: The estimated local means if <code>est_method</code>
is &quot;5par&quot; or &quot;5par_marginals_fixed&quot;, a matrix of zeros if
<code>est_method</code> is &quot;1par&quot;.
</p>
</li>
<li> <p><code>loc_sd</code>: The estimated local st. deviations if
<code>est_method</code> is &quot;5par&quot; or &quot;5par_marginals_fixed&quot;, a matrix
of ones if <code>est_method</code> is &quot;1par&quot;.
</p>
</li>
<li> <p><code>loc_cor</code>: Matrix of estimated local correlations, one
column for each pair of variables, in the same order as specified
in the bandwidth object.
</p>
</li>
<li> <p><code>x</code>: The data set.
</p>
</li>
<li> <p><code>bw</code>: The bandwidth object.
</p>
</li>
<li> <p><code>transformed_data</code>: The data transformed to approximate
marginal standard normality.
</p>
</li>
<li> <p><code>normalizing_constants</code>: The normalizing constants used to
transform data and grid back and forth to the marginal standard
normality scale, as seen in eq. (8) of Otneim &amp; Tjøstheim (2017).
</p>
</li>
<li> <p><code>grid</code>: The grid where the estimation was performed, on the
original scale.
</p>
</li>
<li> <p><code>transformed_grid</code>: The grid where the estimation was
performed, on the marginal standard normal scale.
</p>
</li>
<li> <p><code>normalization_points</code> Number of grid points used
to approximate the integral of the density estimate, in order to
normalize?
</p>
</li>
<li> <p><code>normalization_constant</code> If approximated, the integral of the
non-normalized density estimate. NA if not normalized.
</p>
</li>
<li> <p><code>density_normalized</code> Logical, indicates whether the final
density estimate (contained in f_est) has been approximately
normalized to have unit integral.
</p>
</li>
<li> <p><code>loc_cor_sd</code> Estimated asymptotic standard deviation for the
local correlations.
</p>
</li>
<li> <p><code>loc_cor_lower</code> Lower confidence limit based on the asymptotic
standard deviation.
</p>
</li>
<li> <p><code>loc_cor_upper</code> Upper confidence limit based on the asymptotic
standard deviation.
</p>
</li></ul>



<h3>References</h3>

<p>Otneim, Håkon, and Dag Tjøstheim. &quot;The locally gaussian density estimator for
multivariate data.&quot; Statistics and Computing 27, no. 6 (2017): 1595-1616.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   x &lt;- cbind(rnorm(100), rnorm(100), rnorm(100))
   lg_object &lt;- lg_main(x)  # Put all the running parameters in here.
   grid &lt;- cbind(seq(-4, 4, 1), seq(-4, 4, 1), seq(-4, 4, 1))
   density_estimate &lt;- dlg(lg_object, grid = grid)

</code></pre>

<hr>
<h2 id='dlg_bivariate'>Bivariate density estimation</h2><span id='topic+dlg_bivariate'></span>

<h3>Description</h3>

<p><code>dlg_bivariate</code> returns the locally Gaussian density estimate of a
bivariate distribution on a given grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlg_bivariate(x, eval_points = NA, grid_size = 15, bw = c(1, 1),
  est_method = "1par", tol = .Machine$double.eps^0.25/10^4,
  run_checks = TRUE, marginal_estimates = NA, bw_marginal = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlg_bivariate_+3A_x">x</code></td>
<td>
<p>The data matrix (or data frame). Must have exactly 2 columns.</p>
</td></tr>
<tr><td><code id="dlg_bivariate_+3A_eval_points">eval_points</code></td>
<td>
<p>The grid where the density should be estimated. Must have
exactly 2 columns.</p>
</td></tr>
<tr><td><code id="dlg_bivariate_+3A_grid_size">grid_size</code></td>
<td>
<p>If <code>eval_points</code> is not supplied, then the function
will create a suitable grid diagonally through the data, with this many
grid points.</p>
</td></tr>
<tr><td><code id="dlg_bivariate_+3A_bw">bw</code></td>
<td>
<p>The two bandwidths, a numeric vector of length 2.</p>
</td></tr>
<tr><td><code id="dlg_bivariate_+3A_est_method">est_method</code></td>
<td>
<p>The estimation method, must either be &quot;1par&quot; for estimation
with just the local correlation, or &quot;5par&quot;  for a full locally Gaussian fit
with all 5 parameters.</p>
</td></tr>
<tr><td><code id="dlg_bivariate_+3A_tol">tol</code></td>
<td>
<p>The numerical tolerance to be used in the optimization. Only
applicable in the 1-parameter optimization.</p>
</td></tr>
<tr><td><code id="dlg_bivariate_+3A_run_checks">run_checks</code></td>
<td>
<p>Logical. Should sanity checks be run on the arguments?
Useful to disable this when doing cross-validation for example.</p>
</td></tr>
<tr><td><code id="dlg_bivariate_+3A_marginal_estimates">marginal_estimates</code></td>
<td>
<p>Provide the marginal estimates here if estimation
method is &quot;<code>5par_marginals_fixed</code>&quot;, and the marginal estimates have
already been found. Useful for cross-validation. List with two elements as
returned by <code>dlg_marginal_wrapper</code>.</p>
</td></tr>
<tr><td><code id="dlg_bivariate_+3A_bw_marginal">bw_marginal</code></td>
<td>
<p>Vector of bandwidths used to estimate the marginal
distributions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function serves as the backbone in the body of methods concerning local
Gaussian correlation. It takes a bivariate data set, <code>x</code>, and a
bivariate set of grid points <code>eval_points</code>, and returns the bivariate,
locally Gaussian density estimate in these points. We also need a vector of
bandwidths, <code>bw</code>, with two elements, and an estimation method
<code>est_method</code>
</p>


<h3>Value</h3>

<p>A list including the data set <code>$x</code>, the grid
<code>$eval_points</code>, the bandwidths <code>$bw</code>, as well as a matrix of the
estimated parameter estimates <code>$par_est</code> and the estimated bivariate
density <code>$f_est</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- cbind(rnorm(100), rnorm(100))
  bw &lt;- c(1, 1)
  eval_points &lt;- cbind(seq(-4, 4, 1), seq(-4, 4, 1))

  estimate &lt;- dlg_bivariate(x, eval_points = eval_points, bw = bw)

</code></pre>

<hr>
<h2 id='dlg_marginal'>Marginal density estimation</h2><span id='topic+dlg_marginal'></span>

<h3>Description</h3>

<p>Function that estimates a univariate density estimation by local Gaussian
approximations, as described in Hufthammer and Tjøstheim (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlg_marginal(x, bw = 1, eval_points = seq(quantile(x, 0.01),
  quantile(x, 0.99), length.out = grid_size), grid_size = 15)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlg_marginal_+3A_x">x</code></td>
<td>
<p>The data vector.</p>
</td></tr>
<tr><td><code id="dlg_marginal_+3A_bw">bw</code></td>
<td>
<p>The bandwidth (a single number).</p>
</td></tr>
<tr><td><code id="dlg_marginal_+3A_eval_points">eval_points</code></td>
<td>
<p>The grid where we want to evaluate the density. Chosen
suitably if not provided, with length equal to grid_size.</p>
</td></tr>
<tr><td><code id="dlg_marginal_+3A_grid_size">grid_size</code></td>
<td>
<p>Number of grid points if grid is not provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mainly mean to be used as a tool in multivariate analysis as
away to obtain the estimate of a univariate (marginal) density function, but
it can of course be used in general to estimate univariate densities.
</p>


<h3>Value</h3>

<p>A list including the data set <code>$x</code>, the grid
<code>$eval_points</code>, the bandwidth <code>$bw</code>, as well as a matrix of the
estimated parameter estimates <code>$par_est</code> and the estimated bivariate
density <code>$f_est</code>.
</p>


<h3>References</h3>

<p>Hufthammer, Karl Ove, and Dag Tjøstheim. &quot;Local Gaussian Likelihood and Local
Gaussian Correlation&quot; PhD Thesis of Karl Ove Hufthammer, University of
Bergen, 2009.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- rnorm(100)
  estimate &lt;- dlg_marginal(x, bw = 1, eval_points = -4:4)

</code></pre>

<hr>
<h2 id='dlg_marginal_wrapper'>Marginal estimates for multivariate data</h2><span id='topic+dlg_marginal_wrapper'></span>

<h3>Description</h3>

<p>Estimates the marginal locally Gaussian parameters for a
multivariate data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlg_marginal_wrapper(data_matrix, eval_matrix, bw_vector)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlg_marginal_wrapper_+3A_data_matrix">data_matrix</code></td>
<td>
<p>The matrix of data points. One column constitutes an
observation vector.</p>
</td></tr>
<tr><td><code id="dlg_marginal_wrapper_+3A_eval_matrix">eval_matrix</code></td>
<td>
<p>The matrix of evaluation points. One column constitutes a
vector of grid points.</p>
</td></tr>
<tr><td><code id="dlg_marginal_wrapper_+3A_bw_vector">bw_vector</code></td>
<td>
<p>The vector of bandwidths, one element per component.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes in a matrix of observations, a matrix of evaluation
points and a vector of bandwidths, and does a locally Gaussian fit on each of
the marginals using the <code>dlg_bivariate</code>-function. This function assumes
that the data and evaluation points are organized column-wise in matrices,
and that the bandwidth is found in the corresponding element in the bandwidth
matrix. The primary use for this function is multivariate density estimation
using the &quot;5par_marginals_fixed&quot;-method.
</p>


<h3>Value</h3>

<p>A list with marginal parameter and density estimates as provided by
the <code>dlg_bivariate</code>-function. One element per column in the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data_matrix &lt;- cbind(rnorm(100), rnorm(100))
  eval_matrix &lt;- cbind(seq(-4, 4, 1), seq(-4, 4, 1))
  bw &lt;- c(1, 1)

  estimate &lt;- dlg_marginal_wrapper(data_matrix, eval_matrix = eval_matrix, bw = bw)

</code></pre>

<hr>
<h2 id='dlg_trivariate'>Trivariate density estimation</h2><span id='topic+dlg_trivariate'></span>

<h3>Description</h3>

<p><code>dlg_trivariate</code> returns the locally Gaussian density estimate of a
trivariate distribution on a given grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlg_trivariate(x, eval_points = NULL, grid_size = 15, bw = c(1, 1,
  1), est_method = "trivariate", run_checks = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlg_trivariate_+3A_x">x</code></td>
<td>
<p>The data matrix (or data frame). Must have exactly 2 columns.</p>
</td></tr>
<tr><td><code id="dlg_trivariate_+3A_eval_points">eval_points</code></td>
<td>
<p>The grid where the density should be estimated. Must have
exactly 2 columns.</p>
</td></tr>
<tr><td><code id="dlg_trivariate_+3A_grid_size">grid_size</code></td>
<td>
<p>If <code>eval_points</code> is not supplied, then the function
will create a suitable grid diagonally through the data, with this many
grid points.</p>
</td></tr>
<tr><td><code id="dlg_trivariate_+3A_bw">bw</code></td>
<td>
<p>The two bandwidths, a numeric vector of length 2.</p>
</td></tr>
<tr><td><code id="dlg_trivariate_+3A_est_method">est_method</code></td>
<td>
<p>The estimation method, must either be &quot;1par&quot; for estimation
with just the local correlation, or &quot;5par&quot;  for a full locally Gaussian fit
with all 5 parameters.</p>
</td></tr>
<tr><td><code id="dlg_trivariate_+3A_run_checks">run_checks</code></td>
<td>
<p>Logical. Should sanity checks be run on the arguments?
Useful to disable this when doing cross-validation for example.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In some applications it may be desired to produce a full locally Gaussian fit
of a trivariate density function without having to resort to bivariate
approximations. This function takes a trivariate data set, <code>x</code>, and a
trivariate set of grid points <code>eval_points</code>, and returns the trivariate,
locally Gaussian density estimate in these points. We also need a vector of
bandwidths, <code>bw</code>, with three elements, and an estimation method
<code>est_method</code>, which in this case is fixed at &quot;trivariate&quot;, and
included only to be fully compatible with the other methods in this package.
</p>
<p>This function will only work on the marginally standard normal scale! Please
use the wrapper function <code>dlg()</code> for density estimation. This will
ensure that all parameters have proper values.
</p>


<h3>Value</h3>

<p>A list including the data set <code>$x</code>, the grid
<code>$eval_points</code>, the bandwidths <code>$bw</code>, as well as a matrix of the
estimated parameter estimates <code>$par_est</code> and the estimated bivariate
density <code>$f_est</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- cbind(rnorm(100), rnorm(100), rnorm(100))
  bw &lt;- c(1, 1, 1)
  eval_points &lt;- cbind(seq(-4, 4, 1), seq(-4, 4, 1), seq(-4, 4, 1))

  estimate &lt;- dlg_trivariate(x, eval_points = eval_points, bw = bw)

</code></pre>

<hr>
<h2 id='dmvnorm_wrapper'>Wrapper for <code>dmvnorm</code></h2><span id='topic+dmvnorm_wrapper'></span>

<h3>Description</h3>

<p><code>dmvnorm_wrapper</code> is a function that evaluates the bivariate normal
distribution in a matrix of evaluation points, with local parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmvnorm_wrapper(eval_points, mu_1 = rep(0, nrow(eval_points)),
  mu_2 = rep(0, nrow(eval_points)), sig_1 = rep(1, nrow(eval_points)),
  sig_2 = rep(1, nrow(eval_points)), rho = rep(0, nrow(eval_points)),
  run_checks = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dmvnorm_wrapper_+3A_eval_points">eval_points</code></td>
<td>
<p>A <code>kx2</code> matrix with evaluation points</p>
</td></tr>
<tr><td><code id="dmvnorm_wrapper_+3A_mu_1">mu_1</code></td>
<td>
<p>The first expectation vector</p>
</td></tr>
<tr><td><code id="dmvnorm_wrapper_+3A_mu_2">mu_2</code></td>
<td>
<p>The second expectation vector</p>
</td></tr>
<tr><td><code id="dmvnorm_wrapper_+3A_sig_1">sig_1</code></td>
<td>
<p>The first standard deviation vector</p>
</td></tr>
<tr><td><code id="dmvnorm_wrapper_+3A_sig_2">sig_2</code></td>
<td>
<p>The second standard deviation vector</p>
</td></tr>
<tr><td><code id="dmvnorm_wrapper_+3A_rho">rho</code></td>
<td>
<p>The correlation vector</p>
</td></tr>
<tr><td><code id="dmvnorm_wrapper_+3A_run_checks">run_checks</code></td>
<td>
<p>Run sanity check for the arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions takes as arguments a matrix of grid points, and vectors of
parameter values, and returns the bivariate normal density at these points,
with these parameter values.
</p>

<hr>
<h2 id='dmvnorm_wrapper_single'>Wrapper for <code>dmvnorm</code> - single point</h2><span id='topic+dmvnorm_wrapper_single'></span>

<h3>Description</h3>

<p>Function that evaluates the bivariate normal in a single point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmvnorm_wrapper_single(x1, x2, mu_1, mu_2, sig_1, sig_2, rho)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dmvnorm_wrapper_single_+3A_x1">x1</code></td>
<td>
<p>The first component of the evaluation point</p>
</td></tr>
<tr><td><code id="dmvnorm_wrapper_single_+3A_x2">x2</code></td>
<td>
<p>The second component of the evaluation point</p>
</td></tr>
<tr><td><code id="dmvnorm_wrapper_single_+3A_mu_1">mu_1</code></td>
<td>
<p>The first expectation</p>
</td></tr>
<tr><td><code id="dmvnorm_wrapper_single_+3A_mu_2">mu_2</code></td>
<td>
<p>The second expectation</p>
</td></tr>
<tr><td><code id="dmvnorm_wrapper_single_+3A_sig_1">sig_1</code></td>
<td>
<p>The first standard deviation</p>
</td></tr>
<tr><td><code id="dmvnorm_wrapper_single_+3A_sig_2">sig_2</code></td>
<td>
<p>The second standard deviation</p>
</td></tr>
<tr><td><code id="dmvnorm_wrapper_single_+3A_rho">rho</code></td>
<td>
<p>The correlation</p>
</td></tr>
</table>

<hr>
<h2 id='gradient'>Auxiliary function for calculating the asymptotic standard deviations for the
local Gaussian correlations</h2><span id='topic+gradient'></span>

<h3>Description</h3>

<p>Auxiliary function for calculating the asymptotic standard deviations for the
local Gaussian correlations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradient(sigma, sigma_k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gradient_+3A_sigma">sigma</code></td>
<td>
<p>sigma</p>
</td></tr>
<tr><td><code id="gradient_+3A_sigma_k">sigma_k</code></td>
<td>
<p>sigma_k</p>
</td></tr>
</table>

<hr>
<h2 id='ind_test'>Independence tests</h2><span id='topic+ind_test'></span>

<h3>Description</h3>

<p>Independence tests based on the local Gaussian correlation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind_test(lg_object, h = function(x) x^2, S = function(y)
  as.logical(rep(1, nrow(y))), bootstrap_type = "plain",
  block_length = NULL, n_rep = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ind_test_+3A_lg_object">lg_object</code></td>
<td>
<p>An object of type <code>lg</code>, as produced by the
<code>lg_main</code>-function. The data must be two dimensional.</p>
</td></tr>
<tr><td><code id="ind_test_+3A_h">h</code></td>
<td>
<p>The <code>h</code>-function used in the calculation of the test statistic.
The default value is <code>h(x) = x^2</code>.</p>
</td></tr>
<tr><td><code id="ind_test_+3A_s">S</code></td>
<td>
<p>The integration area for the test statistic. Must be a logical
function that accepts an n x 2 matrix and returns TRUE if a row is in S.</p>
</td></tr>
<tr><td><code id="ind_test_+3A_bootstrap_type">bootstrap_type</code></td>
<td>
<p>The bootstrap method. Choose &quot;plain&quot; for the ordinary
nonparametric bootstrap valid for independence test for iid data and for
serial dependence within a time series. Choose &quot;stationary&quot; or &quot;block&quot; for
a test for cross dependence between two time series.</p>
</td></tr>
<tr><td><code id="ind_test_+3A_block_length">block_length</code></td>
<td>
<p>Block length if using block bootstrap for the cross
dependence test. Calculated by <code>np::b.star()</code> if not supplied.</p>
</td></tr>
<tr><td><code id="ind_test_+3A_n_rep">n_rep</code></td>
<td>
<p>Number of bootstrap replications.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implementation of three independence tests: For iid data (Berentsen et al., 2014),
for serial dependence within a time series (Lacal and Tjøstheim, 2017a), and
for serial cross-dependence between two time series (Lacal and Tjøstheim,
2017b). The first test has a different theoretical foundation than the latter
two, but the implementations are similar and differ only in the bootstrap
procedure. For the time series applications, the user must lag the series to
his/her convenience before making the <code>lg</code>_object and calling this
function.
</p>


<h3>Value</h3>

<p>A list containing the test result as well as various parameters. The
elements are:
</p>

<ul>
<li> <p><code>lg_object</code> The lg-object supplied by the user.
</p>
</li>
<li> <p><code>observed</code> The observed value of the test statistic.
</p>
</li>
<li> <p><code>replicated</code> The replicated values of the test statistic.
</p>
</li>
<li> <p><code>bootstrap_type</code> The bootstrap type.
</p>
</li>
<li> <p><code>block_length</code> The block length used for the block bootstrap.
</p>
</li>
<li> <p><code>p_value</code> The p-value of the test.
</p>
</li></ul>



<h3>References</h3>

<p>Berentsen, Geir Drage, and Dag Tjøstheim. &quot;Recognizing and visualizing
departures from independence in bivariate data using local Gaussian
correlation.&quot; Statistics and Computing 24.5 (2014): 785-801.
</p>
<p>Lacal, Virginia, and Dag Tjøstheim. &quot;Local Gaussian autocorrelation and
tests for serial independence.&quot; Journal of Time Series Analysis 38.1
(2017a): 51-71.
</p>
<p>Lacal, Virginia, and Dag Tjøstheim. &quot;Estimating and testing nonlinear local
dependence between two time series.&quot; Journal of Business &amp; Economic
Statistics just-accepted (2017b).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
    # Remember to increase the number of bootstrap samplesin preactical
    # implementations.

    ## Not run: 

    # Test for independence between two vectors, iid data.
    x1 &lt;- cbind(rnorm(100), rnorm(100))
    lg_object1 &lt;- lg_main(x1)
    test_result1 = ind_test(lg_object1,
                            bootstrap_type = "plain",
                            n_rep = 20)

    # Test for serial dependence in time series, lag 1
    data(EuStockMarkets)
    logreturns &lt;- apply(EuStockMarkets, 2, function(x) diff(log(x)))
    x2 &lt;- cbind(logreturns[1:100,1], logreturns[2:101, 1])
    lg_object2 &lt;- lg_main(x2)
    test_result2 = ind_test(lg_object2,
                            bootstrap_type = "plain",
                            n_rep = 20)

    # Test for cross-dependence, lag 1
    x3 &lt;- cbind(logreturns[1:100,1], logreturns[2:101, 2])
    lg_object3 &lt;- lg_main(x3)
    test_result3 = ind_test(lg_object3,
                            bootstrap_type = "block",
                            n_rep = 20)
    
## End(Not run)

</code></pre>

<hr>
<h2 id='ind_teststat'>Function that calculates the test statistic in the independence tests.</h2><span id='topic+ind_teststat'></span>

<h3>Description</h3>

<p>This is an auxiliary function used by the independence tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind_teststat(x_replicated, lg_object, S, h)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ind_teststat_+3A_x_replicated">x_replicated</code></td>
<td>
<p>A sample.</p>
</td></tr>
<tr><td><code id="ind_teststat_+3A_lg_object">lg_object</code></td>
<td>
<p>An lg-object.</p>
</td></tr>
<tr><td><code id="ind_teststat_+3A_s">S</code></td>
<td>
<p>Integration area, see <code>?ind_test</code>.</p>
</td></tr>
<tr><td><code id="ind_teststat_+3A_h">h</code></td>
<td>
<p>h-function for test statistic, see <code>?ind_test</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='interpolate_conditional_density'>Interpolate a univariate conditional density function</h2><span id='topic+interpolate_conditional_density'></span>

<h3>Description</h3>

<p>Estimates the conditional density function for one free variable on a grid.
Returns a function that interpolates between these grid points so that it can
be evaluated more quickly, without new optimizations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate_conditional_density(lg_object, condition, nodes,
  extend = 0.3,
  gaussian_scale = lg_object$transform_to_marginal_normality)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpolate_conditional_density_+3A_lg_object">lg_object</code></td>
<td>
<p>An object of type <code>lg</code>, as produced by the
<code>lg_main</code>-function</p>
</td></tr>
<tr><td><code id="interpolate_conditional_density_+3A_condition">condition</code></td>
<td>
<p>A vector with conditions for the variables that we condition
upon. Must have exactly one more element than there are columns in the data</p>
</td></tr>
<tr><td><code id="interpolate_conditional_density_+3A_nodes">nodes</code></td>
<td>
<p>Either the number of equidistant nodes to generate, or a vector
of nodes supplied by the user</p>
</td></tr>
<tr><td><code id="interpolate_conditional_density_+3A_extend">extend</code></td>
<td>
<p>How far to extend the grid beyond the extreme data points, in
share of the range</p>
</td></tr>
<tr><td><code id="interpolate_conditional_density_+3A_gaussian_scale">gaussian_scale</code></td>
<td>
<p>Stay on the standard Gaussian scale, useful for the
accept-reject algorithm</p>
</td></tr>
</table>

<hr>
<h2 id='lg_main'>Create an <code>lg</code> object</h2><span id='topic+lg_main'></span>

<h3>Description</h3>

<p>Create an <code>lg</code>-object, that can be used to estimate local Gaussian
correlations, unconditional and conditional densities, local partial
correlation and for testing purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lg_main(x, bw_method = "plugin", est_method = "1par",
  transform_to_marginal_normality = TRUE, bw = NULL,
  plugin_constant_marginal = 1.75, plugin_constant_joint = 1.75,
  plugin_exponent_marginal = -1/5, plugin_exponent_joint = -1/6,
  tol_marginal = 10^(-3), tol_joint = 10^(-3))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lg_main_+3A_x">x</code></td>
<td>
<p>A matrix or data frame with data, on column per variable, one row per
observation.</p>
</td></tr>
<tr><td><code id="lg_main_+3A_bw_method">bw_method</code></td>
<td>
<p>The method used for bandwidth selection. Must be either
<code>"cv"</code> (cross-validation, slow, but accurate) or <code>"plugin"</code> (fast,
but crude).</p>
</td></tr>
<tr><td><code id="lg_main_+3A_est_method">est_method</code></td>
<td>
<p>The estimation method, must be either &quot;1par&quot;, &quot;5par&quot;,
&quot;5par_marginals_fixed&quot; or &quot;trivariate&quot;. (see details).</p>
</td></tr>
<tr><td><code id="lg_main_+3A_transform_to_marginal_normality">transform_to_marginal_normality</code></td>
<td>
<p>Logical, <code>TRUE</code> if we want to
transform our data to marginal standard normality. This is assumed by method
&quot;1par&quot;, but can of course be skipped using this argument if it has been done
already.</p>
</td></tr>
<tr><td><code id="lg_main_+3A_bw">bw</code></td>
<td>
<p>Bandwidth object if it has already been calculated.</p>
</td></tr>
<tr><td><code id="lg_main_+3A_plugin_constant_marginal">plugin_constant_marginal</code></td>
<td>
<p>The constant <code>c</code> in <code>cn^a</code> used for
finding the plugin bandwidth for locally Gaussian marginal density
estimates, which we need if estimation method is &quot;5par_marginals_fixed&quot;.</p>
</td></tr>
<tr><td><code id="lg_main_+3A_plugin_constant_joint">plugin_constant_joint</code></td>
<td>
<p>The constant <code>c</code> in <code>cn^a</code> used for
finding the plugin bandwidth for estimating the pairwise local Gaussian
correlation between two variables.</p>
</td></tr>
<tr><td><code id="lg_main_+3A_plugin_exponent_marginal">plugin_exponent_marginal</code></td>
<td>
<p>The constant <code>a</code> in <code>cn^a</code> used for
finding the plugin bandwidth for locally Gaussian marginal density
estimates, which we need if estimation method is &quot;5par_marginals_fixed&quot;.</p>
</td></tr>
<tr><td><code id="lg_main_+3A_plugin_exponent_joint">plugin_exponent_joint</code></td>
<td>
<p>The constant <code>a</code> in <code>cn^a</code> used for
finding the plugin bandwidth for estimating the pairwise local Gaussian
correlation between two variables.</p>
</td></tr>
<tr><td><code id="lg_main_+3A_tol_marginal">tol_marginal</code></td>
<td>
<p>The absolute tolerance in the optimization for finding the
marginal bandwidths, passed on to the <code>optim</code>-function.</p>
</td></tr>
<tr><td><code id="lg_main_+3A_tol_joint">tol_joint</code></td>
<td>
<p>The absolute tolerance in the optimization for finding the
joint bandwidths. Passed on to the <code>optim</code>-function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main function in the package. It lets the user supply a data set
and set a number of options, which is then used to prepare an <code>lg</code> object
that can be supplied to other functions in the package, such as <code>dlg</code>
(density estimation), <code>clg</code> (conditional density estimation). The details
has been laid out in Otneim &amp; Tjøstheim (2017) and Otneim &amp; Tjøstheim (2018).
</p>
<p>The papers mentioned above deal with the estimation of multivariate density
functions and conditional density functions. The idea is to fit a multivariate
Normal locally to the unknown density function by first transforming the data
to marginal standard normality, and then estimate the local correlations
<strong>pairwise</strong>. The local means and local standard deviations are held
fixed and constantly equal to 0 and 1 respectively to reflect the knowledge
that the marginals are approximately standard normal. Use <code>est_method =
"1par"</code> for this strategy, which means that we only estimate one local
parameter (the correlation) for each pair, and note that this method requires
marginally standard normal data. If <code>est_method = "1par"</code> and
<code>transform_to_marginal_normality = FALSE</code> the function will throw a
warning. It might be okay though, if you know that the data are marginally
standard normal already.
</p>
<p>The second option is <code>est_method = "5par_marginals_fixed"</code> which is more
flexible than <code>"1par"</code>. This method will estimate univariate local
Gaussian fits to each marginal, thus producing local estimates of the local
means: <code class="reqn">\mu_i(x_i)</code> and <code class="reqn">\sigma_i(x_i)</code> that will be held fixed in the
next step when the <strong>pairwise</strong> local correlations are estimated. This
method can in many situations provide a better fit, even if the marginals are
standard normal. It also opens up for creating a multivariate locally Gaussian
fit to any density without having to transform the marginals if you for some
reason want to avoid that.
</p>
<p>The third option is <code>est_method = "5par"</code>, which is a full nonparametric
locally Gaussian fit of a bivariate density as laid out and used by Tjøstheim
&amp; Hufthammer (2013) and others. This is simply a wrapper for the
<code>localgauss</code>-package by Berentsen et.al. (2014).
</p>
<p>A recent option is described by Otneim and Tjøstheim (2019), who allow a full
trivariate fit to a three dimensional data set that is transformed to marginal
standard normality in the context of their test for conditional independence
(see <code>?ci_test</code> for details), but this can of course be used as an option
to estimate three-variate density functions as well.
</p>


<h3>References</h3>

<p>Berentsen, Geir Drage, Tore Selland Kleppe, and Dag Tjøstheim. &quot;Introducing
localgauss, an R package for estimating and visualizing local Gaussian
correlation.&quot; Journal of Statistical Software 56.1 (2014): 1-18.
</p>
<p>Hufthammer, Karl Ove, and Dag Tjøstheim. &quot;Local Gaussian Likelihood and Local
Gaussian Correlation&quot; PhD Thesis of Karl Ove Hufthammer, University of Bergen,
2009.
</p>
<p>Otneim, Håkon, and Dag Tjøstheim. &quot;The locally gaussian density estimator for
multivariate data.&quot; Statistics and Computing 27, no. 6 (2017): 1595-1616.
</p>
<p>Otneim, Håkon, and Dag Tjøstheim. &quot;Conditional density estimation using
the local Gaussian correlation&quot; Statistics and Computing 28, no. 2 (2018):
303-321.
</p>
<p>Otneim, Håkon, and Dag Tjøstheim. &quot;The local Gaussian partial correlation&quot;
Working paper (2019).
</p>
<p>Tjøstheim, D., &amp; Hufthammer, K. O. (2013). Local Gaussian correlation: a new
measure of dependence. Journal of Econometrics, 172(1), 33-48.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- cbind(rnorm(100), rnorm(100), rnorm(100))

  # Quick example
  lg_object1 &lt;- lg_main(x, bw_method = "plugin", est_method = "1par")

  # In the simulation experiments in Otneim &amp; Tjøstheim (2017a),
  # the cross-validation bandwidth selection is used:
  ## Not run: 
  lg_object2 &lt;- lg_main(x, bw_method = "cv", est_method = "1par")
  
## End(Not run)

  # If you do not wish to transform the data to standard normality,
  # use the five parameter fit:
  lg_object3 &lt;- lg_main(x, est_method = "5par_marginals_fixed",
                  transform_to_marginal_normality = FALSE)

  # In the bivariate case, you can use the full nonparametric fit:
  x_biv &lt;- cbind(rnorm(100), rnorm(100))
  lg_object4 &lt;- lg_main(x_biv, est_method = "5par",
                  transform_to_marginal_normality = FALSE)

  # Whichever method you choose, the lg-object can now be passed on
  # to the dlg- or clg-functions for evaluation of the density or
  # conditional density estimate. Control the grid with the grid
  # argument.
  grid1 &lt;- x[1:10,]
  dens_est &lt;- dlg(lg_object1, grid = grid1)

  # The conditional density of X1 given X2 = 1 and X2 = 0:
  grid2 &lt;- matrix(-3:3, ncol = 1)
  c_dens_est &lt;- clg(lg_object1, grid = grid2, condition = c(1, 0))

</code></pre>

<hr>
<h2 id='local_conditional_covariance'>Calculate the local conditional covariance between two variables</h2><span id='topic+local_conditional_covariance'></span>

<h3>Description</h3>

<p>Wrapper for the <code>clg</code> function that extracts the local Gaussian conditional
covariance between two variables from an object that is produced by the clg-function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_conditional_covariance(clg_object, coord = c(1, 2))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="local_conditional_covariance_+3A_clg_object">clg_object</code></td>
<td>
<p>The object produced by the clg-function</p>
</td></tr>
<tr><td><code id="local_conditional_covariance_+3A_coord">coord</code></td>
<td>
<p>The variables for which the conditional covariance should be extracted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for the clag-function, and extracts the estimated local
conditional covariance between the first two variables in the data matrix, on the grid
specified to the clg-function.
</p>

<hr>
<h2 id='make_C'>Auxiliary function for calculating the asymptotic standard deviations for the
local Gaussian correlations</h2><span id='topic+make_C'></span>

<h3>Description</h3>

<p>Auxiliary function for calculating the asymptotic standard deviations for the
local Gaussian correlations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_C(r, pairs, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_C_+3A_r">r</code></td>
<td>
<p>r</p>
</td></tr>
<tr><td><code id="make_C_+3A_pairs">pairs</code></td>
<td>
<p>pairs</p>
</td></tr>
<tr><td><code id="make_C_+3A_p">p</code></td>
<td>
<p>p</p>
</td></tr>
</table>

<hr>
<h2 id='mvnorm_eval'>Evaluate the multivariate normal</h2><span id='topic+mvnorm_eval'></span>

<h3>Description</h3>

<p>Function that evaluates the multivariate normal distribution with local
parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvnorm_eval(eval_points, loc_mean, loc_sd, loc_cor, pairs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvnorm_eval_+3A_eval_points">eval_points</code></td>
<td>
<p>A matrix of grid points</p>
</td></tr>
<tr><td><code id="mvnorm_eval_+3A_loc_mean">loc_mean</code></td>
<td>
<p>A matrix of local means, one row per grid point, one column
per component</p>
</td></tr>
<tr><td><code id="mvnorm_eval_+3A_loc_sd">loc_sd</code></td>
<td>
<p>A  matrix of local standard deviations, one row per grid point,
one column per component</p>
</td></tr>
<tr><td><code id="mvnorm_eval_+3A_loc_cor">loc_cor</code></td>
<td>
<p>A matrix of local correlations, one row per grid point, on
column per pair of variables</p>
</td></tr>
<tr><td><code id="mvnorm_eval_+3A_pairs">pairs</code></td>
<td>
<p>A data frame specifying the components that make up each pair,</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes in a grid, where we want to evaluate the multivariate normal, and in
each grid point we have a new set of parameters.
</p>

<hr>
<h2 id='partial_cor'>Calculate the local Gaussian partial correlation</h2><span id='topic+partial_cor'></span>

<h3>Description</h3>

<p>A function that calculates the local Gaussian partial correlation for a pair
of variables, given the values of some conditioning variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial_cor(lg_object, grid = NULL, condition = NULL, level = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partial_cor_+3A_lg_object">lg_object</code></td>
<td>
<p>An object of type <code>lg</code>, as produced by the
<code>lg_main</code>-function.</p>
</td></tr>
<tr><td><code id="partial_cor_+3A_grid">grid</code></td>
<td>
<p>A matrix of grid points, where we want to evaluate the density
estimate. Number of columns *must* be equal to 2.</p>
</td></tr>
<tr><td><code id="partial_cor_+3A_condition">condition</code></td>
<td>
<p>A vector with conditions for the variables that we condition
upon. Length of this vector *must* be the same as the number of variables in
X3. The function will throw an error of there is any discrepancy in the
dimensions of the <code>grid</code>, <code>condition</code> and data set.</p>
</td></tr>
<tr><td><code id="partial_cor_+3A_level">level</code></td>
<td>
<p>Specify a level if asymptotic standard deviations and confidence
intervals should be returned. If not, set to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for the <code>clg</code>-function (for conditional
density estimation) that returns the local conditional, or partial,
correlations described by Otneim &amp; Tjøstheim (2018). The function takes as
arguments an <code>lg</code>-object as produced by the main <code>lg_main</code>-
function, a grid of points where the density estimate should be estimated, and
a set of conditions.
</p>
<p>The variables must be sorted before they are supplied to this function. It
will always assume that the free variables come before the conditioning
variables, see <code>?clg</code> for details.
</p>
<p>Assume that X is a stochastic vector with scalar components X1 and X2, and a
possibly d-dimensional component X3. This function will thus compute the local
*partial* correlation between X1 and X2 given X3 = x3.
</p>


<h3>Value</h3>

<p>A list containing the local partial Gaussian correlations as well as all the
running parameters that has been used. The elements are:
</p>

<ul>
<li> <p><code>grid</code> The grid where the estimation was performed, on the
original scale.
</p>
</li>
<li> <p><code>partial_correlations</code> The estimated local partial Gaussian
correlations.
</p>
</li>
<li> <p><code>cond_density</code> The estimated conditional density of X1 and X2 given
X3, as described by Otneim &amp; Tjøstheim (2018).
</p>
</li>
<li> <p><code>transformed_grid</code>: The grid where the estimation was
performed, on the marginal standard normal scale.
</p>
</li>
<li> <p><code>bw</code>: The bandwidth object.
</p>
</li>
<li> <p><code>partial_correlations_sd</code> Estimated standard deviations of the local
partial Gaussian correlations, as described in a forthcoming paper.
</p>
</li>
<li> <p><code>partial_correlations_lower</code> Lower confidence limit based on the
asymptotic standard deviation.
</p>
</li>
<li> <p><code>partial_correlations_upper</code> Upper confidence limit based on the
asymptotic standard deviation.
</p>
</li></ul>



<h3>References</h3>

<p>Otneim, Håkon, and Dag Tjøstheim. &quot;Conditional density estimation using
the local Gaussian correlation&quot; Statistics and Computing 28, no. 2 (2018):
303-321.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # A 3 variate example
  x &lt;- cbind(rnorm(100), rnorm(100), rnorm(100))

  # Generate the lg-object with default settings
  lg_object &lt;- lg_main(x)

  # Estimate the local partial Gaussian correlation between X1 and X2 given X3 = 1 on
  # a small grid
  partial_correlations &lt;- partial_cor(lg_object,
                                     grid = cbind(-4:4, -4:4),
                                     condition = 1)

</code></pre>

<hr>
<h2 id='replicate_under_ci'>Bootstrap replication under the null hypothesis</h2><span id='topic+replicate_under_ci'></span>

<h3>Description</h3>

<p>Generate bootstrap replicates under the null hypothesis that the first two
variables are conditionally independent given the rest of the variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replicate_under_ci(lg_object, n_rep, nodes, M = NULL, M_sim = 1500,
  M_corr = 1.5, n_corr = 1.2, extend = 0.3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replicate_under_ci_+3A_lg_object">lg_object</code></td>
<td>
<p>An object of type <code>lg</code>, as produced by the
<code>lg_main</code>-function</p>
</td></tr>
<tr><td><code id="replicate_under_ci_+3A_n_rep">n_rep</code></td>
<td>
<p>The number of replicated bootstrap samples</p>
</td></tr>
<tr><td><code id="replicate_under_ci_+3A_nodes">nodes</code></td>
<td>
<p>Either the number of equidistant nodes to generate, or a vector
of nodes supplied by the user</p>
</td></tr>
<tr><td><code id="replicate_under_ci_+3A_m">M</code></td>
<td>
<p>The value for M in the accept-reject algorithm if already known</p>
</td></tr>
<tr><td><code id="replicate_under_ci_+3A_m_sim">M_sim</code></td>
<td>
<p>The number of replicates to simulate in order to find a value
for M</p>
</td></tr>
<tr><td><code id="replicate_under_ci_+3A_m_corr">M_corr</code></td>
<td>
<p>Correction factor for M, to be on the safe side</p>
</td></tr>
<tr><td><code id="replicate_under_ci_+3A_n_corr">n_corr</code></td>
<td>
<p>Correction factor for n_new, so that we mostly will generate
enough observations in the first go</p>
</td></tr>
<tr><td><code id="replicate_under_ci_+3A_extend">extend</code></td>
<td>
<p>How far to extend the grid beyond the extreme data points when
interpolating, in share of the range</p>
</td></tr>
</table>

<hr>
<h2 id='trans_normal'>Transform the marginals of a multivariate data set to standard normality
based on the logspline density estimator (Kooperberg and Stone, 1991). See
Otneim and Tjøstheim (2017) for details.</h2><span id='topic+trans_normal'></span>

<h3>Description</h3>

<p>Transform the marginals of a multivariate data set to standard normality
based on the logspline density estimator (Kooperberg and Stone, 1991). See
Otneim and Tjøstheim (2017) for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trans_normal(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trans_normal_+3A_x">x</code></td>
<td>
<p>The data matrix, one row per observation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the transformed data ($transformed_data), and a
function ($trans_new)  that can be used to transform grid points and obtain
normalizing constants for use in density estimation functions
</p>


<h3>References</h3>

<p>Kooperberg, Charles, and Charles J. Stone. &quot;A study of logspline density
estimation.&quot; Computational Statistics &amp; Data Analysis 12.3 (1991): 327-347.
</p>
<p>Otneim, Håkon, and Dag Tjøstheim. &quot;The locally gaussian density estimator for
multivariate data.&quot; Statistics and Computing 27, no. 6 (2017): 1595-1616.
</p>

<hr>
<h2 id='u'>Auxiliary function for calculating the local score function u</h2><span id='topic+u'></span>

<h3>Description</h3>

<p>Auxiliary function for calculating the local score function u
</p>


<h3>Usage</h3>

<pre><code class='language-R'>u(z1, z2, rho)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="u_+3A_z1">z1</code></td>
<td>
<p>z1</p>
</td></tr>
<tr><td><code id="u_+3A_z2">z2</code></td>
<td>
<p>z2</p>
</td></tr>
<tr><td><code id="u_+3A_rho">rho</code></td>
<td>
<p>rho</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to estimate the asymptotic variance of the estimates.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
