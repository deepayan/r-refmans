<!DOCTYPE html><html lang="en"><head><title>Help for package sdetorus</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sdetorus}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sdetorus'><p>sdetorus - Statistical Tools for Toroidal Diffusions</p></a></li>
<li><a href='#alphaToA'><p>Valid drift matrices for the Ornstein&ndash;Uhlenbeck diffusion in 2D</p></a></li>
<li><a href='#approxMleWn1D'><p>Approximate MLE of the WN diffusion in 1D</p></a></li>
<li><a href='#approxMleWn2D'><p>Approximate MLE of the WN diffusion in 2D</p></a></li>
<li><a href='#approxMleWnPairs'><p>Approximate MLE of the WN diffusion in 2D from a sample of initial</p>
and final pairs of angles.</a></li>
<li><a href='#crankNicolson1D'><p>Crank&ndash;Nicolson finite difference scheme for the 1D Fokker&ndash;Planck equation with periodic boundaries</p></a></li>
<li><a href='#crankNicolson2D'><p>Crank&ndash;Nicolson finite difference scheme for the 2D Fokker&ndash;Planck equation with periodic boundaries</p></a></li>
<li><a href='#dBvm'><p>Bivariate Sine von Mises density</p></a></li>
<li><a href='#diffCirc'><p>Lagged differences for circular time series</p></a></li>
<li><a href='#dJp'><p>Jones and Pewsey (2005)'s circular distribution</p></a></li>
<li><a href='#dPsTpd'><p>Wrapped Euler and Shoji&ndash;Ozaki pseudo-transition probability densities</p></a></li>
<li><a href='#driftJp'><p>Drift for the JP diffusion</p></a></li>
<li><a href='#driftMixIndVm'><p>Drift for the mivM diffusion</p></a></li>
<li><a href='#driftMixVm'><p>Drift for the mivM diffusion (circular case)</p></a></li>
<li><a href='#driftMvm'><p>Drift for the MvM diffusion</p></a></li>
<li><a href='#driftWn'><p>Drift for the WN diffusion</p></a></li>
<li><a href='#driftWn1D'><p>Drift of the WN diffusion in 1D</p></a></li>
<li><a href='#driftWn2D'><p>Drift of the WN diffusion in 2D</p></a></li>
<li><a href='#dStatWn2D'><p>Stationary density of a WN diffusion (with diagonal diffusion matrix) in 2D</p></a></li>
<li><a href='#dTpdMou'><p>Transition probability density of the multivariate OU diffusion</p></a></li>
<li><a href='#dTpdOu'><p>Transition probability density of the univariate OU diffusion</p></a></li>
<li><a href='#dTpdPde1D'><p>Transition probability density in 1D by PDE solving</p></a></li>
<li><a href='#dTpdPde2D'><p>Transition probability density in 2D by PDE solving</p></a></li>
<li><a href='#dTpdWou'><p>Conditional probability density of the WOU process</p></a></li>
<li><a href='#dTpdWou1D'><p>Approximation of the transition probability density of the WN diffusion in 1D</p></a></li>
<li><a href='#dTpdWou2D'><p>Approximation of the transition probability density of the WN diffusion in 2D</p></a></li>
<li><a href='#dTvm'><p>Mixtures of toroidal von Mises densities</p></a></li>
<li><a href='#dVm'><p>Density of the von Mises</p></a></li>
<li><a href='#dWn1D'><p>WN density in 1D</p></a></li>
<li><a href='#euler1D'><p>Simulation of trajectories of the WN or vM diffusion in 1D</p></a></li>
<li><a href='#euler2D'><p>Simulation of trajectories of the WN or MvM diffusion in 2D</p></a></li>
<li><a href='#kIndex'><p>Utilities for conversion between row-column indexing and linear</p>
indexing of matrices</a></li>
<li><a href='#linesCirc'><p>Lines and arrows with vertical wrapping</p></a></li>
<li><a href='#linesTorus'><p>Lines and arrows with wrapping in the torus</p></a></li>
<li><a href='#linesTorus3d'><p>Lines and arrows with wrapping in the torus</p></a></li>
<li><a href='#logBesselI0Scaled'><p>Efficient computation of Bessel related functions</p></a></li>
<li><a href='#logLikWouPairs'><p>Loglikelihood of WN in 2D when only the initial and final points are observed</p></a></li>
<li><a href='#matlab.like.colorRamps'><p>Generate color palettes similar to the Matlab default</p></a></li>
<li><a href='#matMatch'><p>Matching of matrices</p></a></li>
<li><a href='#mcTorusIntegrate'><p>Monte Carlo integration on the torus</p></a></li>
<li><a href='#mleMou'><p>Maximum likelihood estimation of the multivariate OU diffusion</p></a></li>
<li><a href='#mleOptimWrapper'><p>Optimization wrapper for likelihood-based procedures</p></a></li>
<li><a href='#mleOu'><p>Maximum likelihood estimation of the OU diffusion</p></a></li>
<li><a href='#mlePde1D'><p>MLE for toroidal process via PDE solving in 1D</p></a></li>
<li><a href='#mlePde2D'><p>MLE for toroidal process via PDE solving in 2D</p></a></li>
<li><a href='#periodicTrapRule1D'><p>Quadrature rules in 1D, 2D and 3D</p></a></li>
<li><a href='#plotSurface2D'><p>Contour plot of a 2D surface</p></a></li>
<li><a href='#plotSurface3D'><p>Visualization of a 3D surface</p></a></li>
<li><a href='#psMle'><p>Maximum pseudo-likelihood estimation by wrapped pseudo-likelihoods</p></a></li>
<li><a href='#repRow'><p>Replication of rows and columns</p></a></li>
<li><a href='#rStatWn2D'><p>Simulation from the stationary density of a WN diffusion in 2D</p></a></li>
<li><a href='#rTpdWn2D'><p>Simulation from the approximated transition distribution of a WN diffusion in 2D</p></a></li>
<li><a href='#rTrajLangevin'><p>Simulation of trajectories of a Langevin diffusion</p></a></li>
<li><a href='#rTrajMou'><p>Simulation of trajectories for the multivariate OU diffusion</p></a></li>
<li><a href='#rTrajOu'><p>Simulation of trajectories for the univariate OU diffusion</p></a></li>
<li><a href='#rTrajWn1D'><p>Simulation of trajectories for the WN diffusion in 1D</p></a></li>
<li><a href='#rTrajWn2D'><p>Simulation of trajectories for the WN diffusion in 2D</p></a></li>
<li><a href='#safeSoftMax'><p>Safe softmax function for computing weights</p></a></li>
<li><a href='#scoreMatchWnBvm'><p>Score and moment matching of a univariate or bivariate wrapped normal</p>
by a von Mises</a></li>
<li><a href='#sigmaDiff'><p>High-frequency estimate of the diffusion matrix</p></a></li>
<li><a href='#solveTridiag'><p>Thomas algorithm for solving tridiagonal matrix systems, with optional presaving of LU decomposition</p></a></li>
<li><a href='#stepAheadWn1D'><p>Multiple simulation of trajectory ends of the WN or vM diffusion in 1D</p></a></li>
<li><a href='#stepAheadWn2D'><p>Multiple simulation of trajectory ends of the WN or MvM diffusion in 2D</p></a></li>
<li><a href='#table.ramp.colorRamps'><p>Constructs color palettes with sharp breaks</p></a></li>
<li><a href='#toPiInt'><p>Wrapping of radians to its principal values</p></a></li>
<li><a href='#torusAxis'><p>Draws pretty axis labels for circular variables</p></a></li>
<li><a href='#torusAxis3d'><p>Draws pretty axis labels for circular variables</p></a></li>
<li><a href='#unwrapCircSeries'><p>Unwrapping of circular time series</p></a></li>
<li><a href='#weightsLinearInterp1D'><p>Weights for linear interpolation in 1D and 2D</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Tools for Toroidal Diffusions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.10</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-01</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of statistical methods for the estimation of
    toroidal diffusions. Several diffusive models are provided, most of them
    belonging to the Langevin family of diffusions on the torus. Specifically,
    the wrapped normal and von Mises processes are included, which can be seen
    as toroidal analogues of the Ornstein-Uhlenbeck diffusion. A collection of
    methods for approximate maximum likelihood estimation, organized in four
    blocks, is given: (i) based on the exact transition probability density,
    obtained as the numerical solution to the Fokker-Plank equation; (ii) based
    on wrapped pseudo-likelihoods; (iii) based on specific analytic
    approximations by wrapped processes; (iv) based on maximum likelihood of
    the stationary densities. The package allows the replicability of the
    results in García-Portugués et al. (2019) &lt;<a href="https://doi.org/10.1007%2Fs11222-017-9790-2">doi:10.1007/s11222-017-9790-2</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), Rcpp, mvtnorm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rgl, Bessel, manipulate</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/egarpor/sdetorus">https://github.com/egarpor/sdetorus</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/egarpor/sdetorus">https://github.com/egarpor/sdetorus</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-01 11:06:25 UTC; Eduardo</td>
</tr>
<tr>
<td>Author:</td>
<td>Eduardo García-Portugués
    <a href="https://orcid.org/0000-0002-9224-4111"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eduardo García-Portugués &lt;edgarcia@est-econ.uc3m.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-01 12:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sdetorus'>sdetorus - Statistical Tools for Toroidal Diffusions</h2><span id='topic+sdetorus'></span><span id='topic+sdetorus-package'></span>

<h3>Description</h3>

<p>Implementation of statistical methods for the estimation of
toroidal diffusions. Several diffusive models are provided, most of them
belonging to the Langevin family of diffusions on the torus. Specifically,
the wrapped normal and von Mises processes are included, which can be seen
as toroidal analogues of the Ornstein&ndash;Uhlenbeck diffusion. A collection of
methods for approximate maximum likelihood estimation, organized in four
blocks, is given: (i) based on the exact transition probability density,
obtained as the numerical solution to the Fokker-Plank equation;
(ii) based on wrapped pseudo-likelihoods; (iii) based on specific analytic
approximations by wrapped processes; (iv) based on maximum likelihood of
the stationary densities. The package allows the replicability of the
results in García-Portugués et al. (2019) &lt;doi:10.1007/s11222-017-9790-2&gt;.
</p>


<h3>Author(s)</h3>

<p>Eduardo García-Portugués.
</p>


<h3>References</h3>

<p>García-Portugués, E., Sørensen, M., Mardia, K. V. and Hamelryck, T. (2019)
Langevin diffusions on the torus: estimation and applications.
<em>Statistics and Computing</em>, 29(2):1&ndash;22. <a href="https://doi.org/10.1007/s11222-017-9790-2">doi:10.1007/s11222-017-9790-2</a>
</p>

<hr>
<h2 id='alphaToA'>Valid drift matrices for the Ornstein&ndash;Uhlenbeck diffusion in 2D</h2><span id='topic+alphaToA'></span><span id='topic+aToAlpha'></span>

<h3>Description</h3>

<p>Constructs drift matrices <code class="reqn">A</code> such that
<code>solve(A) %*% Sigma</code> is symmetric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alphaToA(alpha, sigma = NULL, rho = 0, Sigma = NULL)

aToAlpha(A, sigma = NULL, rho = 0, Sigma = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alphaToA_+3A_alpha">alpha</code></td>
<td>
<p>vector of length <code>3</code> containing the <code>A</code> matrix. The
first two elements are the diagonal.</p>
</td></tr>
<tr><td><code id="alphaToA_+3A_sigma">sigma</code></td>
<td>
<p>vector of length <code>2</code> containing the <strong>square root</strong>
of the diagonal of <code>Sigma</code>.</p>
</td></tr>
<tr><td><code id="alphaToA_+3A_rho">rho</code></td>
<td>
<p>correlation of <code>Sigma</code>.</p>
</td></tr>
<tr><td><code id="alphaToA_+3A_sigma">Sigma</code></td>
<td>
<p>the diffusion matrix of size <code>c(2, 2)</code>.</p>
</td></tr>
<tr><td><code id="alphaToA_+3A_a">A</code></td>
<td>
<p>matrix of size <code>c(2, 2)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parametrization enforces that <code>solve(A) %*% Sigma</code>
is symmetric. Positive definiteness is guaranteed if <code>alpha[3]^2 &lt;
rho^2 * (alpha[1] - alpha[2])^2 / 4 + alpha[1] * alpha[2]</code>.
</p>


<h3>Value</h3>

<p>The drift matrix <code>A</code> or the <code>alpha</code> vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Parameters
alpha &lt;- 3:1
Sigma &lt;- rbind(c(1, 0.5), c(0.5, 4))

# Covariance matrix
A &lt;- alphaToA(alpha = alpha, Sigma = Sigma)
S &lt;- 0.5 * solve(A) %*% Sigma
det(S)

# Check
aToAlpha(A = alphaToA(alpha = alpha, Sigma = Sigma), Sigma = Sigma)
alphaToA(alpha = aToAlpha(A = A, Sigma = Sigma), Sigma = Sigma)
</code></pre>

<hr>
<h2 id='approxMleWn1D'>Approximate MLE of the WN diffusion in 1D</h2><span id='topic+approxMleWn1D'></span>

<h3>Description</h3>

<p>Approximate Maximum Likelihood Estimation (MLE) for the Wrapped
Normal (WN) in 1D using the wrapped Ornstein&ndash;Uhlenbeck diffusion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approxMleWn1D(data, delta, start, alpha = NA, mu = NA, sigma = NA,
  lower = c(0.01, -pi, 0.01), upper = c(25, pi, 25), vmApprox = FALSE,
  maxK = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="approxMleWn1D_+3A_data">data</code></td>
<td>
<p>a matrix of dimension <code>c(n, p)</code>.</p>
</td></tr>
<tr><td><code id="approxMleWn1D_+3A_delta">delta</code></td>
<td>
<p>discretization step.</p>
</td></tr>
<tr><td><code id="approxMleWn1D_+3A_start">start</code></td>
<td>
<p>starting values, a matrix with <code>p</code> columns, with each
entry representing a different starting value.</p>
</td></tr>
<tr><td><code id="approxMleWn1D_+3A_alpha">alpha</code>, <code id="approxMleWn1D_+3A_mu">mu</code>, <code id="approxMleWn1D_+3A_sigma">sigma</code></td>
<td>
<p>if their values are provided, the likelihood function
is optimized with respect to the rest of unspecified parameters. The number
of elements in <code>start</code>, <code>lower</code> and <code>upper</code> has to be modified
accordingly (see examples).</p>
</td></tr>
<tr><td><code id="approxMleWn1D_+3A_lower">lower</code>, <code id="approxMleWn1D_+3A_upper">upper</code></td>
<td>
<p>bound for box constraints as in method <code>"L-BFGS-B"</code>
of <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="approxMleWn1D_+3A_vmapprox">vmApprox</code></td>
<td>
<p>flag to indicate von Mises approximation to wrapped normal.
See<br /> <code><a href="#topic+momentMatchWnVm">momentMatchWnVm</a></code> and <code><a href="#topic+scoreMatchWnBvm">scoreMatchWnBvm</a></code>.</p>
</td></tr>
<tr><td><code id="approxMleWn1D_+3A_maxk">maxK</code></td>
<td>
<p>maximum absolute winding number used if <code>circular = TRUE</code>.</p>
</td></tr>
<tr><td><code id="approxMleWn1D_+3A_...">...</code></td>
<td>
<p>further parameters passed to <code><a href="#topic+mleOptimWrapper">mleOptimWrapper</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Section 3.3 in García-Portugués et al. (2019) for details.
</p>


<h3>Value</h3>

<p>Output from <code><a href="#topic+mleOptimWrapper">mleOptimWrapper</a></code>.
</p>


<h3>References</h3>

<p>García-Portugués, E., Sørensen, M., Mardia, K. V. and Hamelryck, T. (2019)
Langevin diffusions on the torus: estimation and applications.
<em>Statistics and Computing</em>, 29(2):1&ndash;22. <a href="https://doi.org/10.1007/s11222-017-9790-2">doi:10.1007/s11222-017-9790-2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;- 0.5
mu &lt;- 0
sigma &lt;- 2
samp &lt;- rTrajWn1D(x0 = 0, alpha = alpha, mu = mu, sigma = sigma, N = 1000,
                    delta = 0.1)
approxMleWn1D(data = samp, delta = 0.1, start = c(alpha, mu, sigma))
approxMleWn1D(data = samp, delta = 0.1, sigma = sigma, start = c(alpha, mu),
                lower = c(0.01, -pi), upper = c(25, pi))
approxMleWn1D(data = samp, delta = 0.1, mu = mu, start = c(alpha, sigma),
                lower = c(0.01, 0.01), upper = c(25, 25))
</code></pre>

<hr>
<h2 id='approxMleWn2D'>Approximate MLE of the WN diffusion in 2D</h2><span id='topic+approxMleWn2D'></span>

<h3>Description</h3>

<p>Approximate Maximum Likelihood Estimation (MLE) for the Wrapped
Normal (WN) in 2D using the wrapped Ornstein&ndash;Uhlenbeck diffusion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approxMleWn2D(data, delta, start, alpha = rep(NA, 3), mu = rep(NA, 2),
  sigma = rep(NA, 2), rho = NA, lower = c(0.01, 0.01, -25, -pi, -pi,
  0.01, 0.01, -0.99), upper = c(rep(25, 3), pi, pi, 25, 25, 0.99),
  maxK = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="approxMleWn2D_+3A_data">data</code></td>
<td>
<p>a matrix of dimension <code>c(n, p)</code>.</p>
</td></tr>
<tr><td><code id="approxMleWn2D_+3A_delta">delta</code></td>
<td>
<p>discretization step.</p>
</td></tr>
<tr><td><code id="approxMleWn2D_+3A_start">start</code></td>
<td>
<p>starting values, a matrix with <code>p</code> columns, with each
entry representing a different starting value.</p>
</td></tr>
<tr><td><code id="approxMleWn2D_+3A_alpha">alpha</code>, <code id="approxMleWn2D_+3A_mu">mu</code>, <code id="approxMleWn2D_+3A_sigma">sigma</code>, <code id="approxMleWn2D_+3A_rho">rho</code></td>
<td>
<p>if their values are provided, the likelihood
function is optimized with respect to the rest of unspecified parameters.
The number of elements in <code>start</code>, <code>lower</code> and <code>upper</code> has to
be modified accordingly (see examples).</p>
</td></tr>
<tr><td><code id="approxMleWn2D_+3A_lower">lower</code>, <code id="approxMleWn2D_+3A_upper">upper</code></td>
<td>
<p>bound for box constraints as in method <code>"L-BFGS-B"</code>
of <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="approxMleWn2D_+3A_maxk">maxK</code></td>
<td>
<p>maximum absolute winding number used if <code>circular = TRUE</code>.</p>
</td></tr>
<tr><td><code id="approxMleWn2D_+3A_...">...</code></td>
<td>
<p>further parameters passed to <code><a href="#topic+mleOptimWrapper">mleOptimWrapper</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Section 3.3 in García-Portugués et al. (2019) for details.
</p>


<h3>Value</h3>

<p>Output from <code><a href="#topic+mleOptimWrapper">mleOptimWrapper</a></code>.
</p>


<h3>References</h3>

<p>García-Portugués, E., Sørensen, M., Mardia, K. V. and Hamelryck, T. (2019)
Langevin diffusions on the torus: estimation and applications.
<em>Statistics and Computing</em>, 29(2):1&ndash;22. <a href="https://doi.org/10.1007/s11222-017-9790-2">doi:10.1007/s11222-017-9790-2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;- c(2, 2, -0.5)
mu &lt;- c(0, 0)
sigma &lt;- c(1, 1)
rho &lt;- 0.2
samp &lt;- rTrajWn2D(x0 = c(0, 0), alpha = alpha, mu = mu, sigma = sigma,
                  rho = rho, N = 1000, delta = 0.1)
approxMleWn2D(data = samp, delta = 0.1, start = c(alpha, mu, sigma, rho))
approxMleWn2D(data = samp, delta = 0.1, alpha = alpha,
              start = c(mu, sigma), lower = c(-pi, -pi, 0.01, 0.01),
              upper = c(pi, pi, 25, 25))
mleMou(data = samp, delta = 0.1, start = c(alpha, mu, sigma),
       optMethod = "Nelder-Mead")
</code></pre>

<hr>
<h2 id='approxMleWnPairs'>Approximate MLE of the WN diffusion in 2D from a sample of initial
and final pairs of angles.</h2><span id='topic+approxMleWnPairs'></span>

<h3>Description</h3>

<p>Approximate Maximum Likelihood Estimation (MLE) for the Wrapped
Normal (WN) diffusion, using the wrapped Ornstein&ndash;Uhlenbeck diffusion and
assuming initial stationarity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approxMleWnPairs(data, delta, start = c(0, 0, 1, 1, 0, 1, 1),
  alpha = rep(NA, 3), mu = rep(NA, 2), sigma = rep(NA, 2), rho = NA,
  lower = c(-pi, -pi, 0.01, 0.01, -25, 0.01, 0.01, -0.99), upper = c(pi,
  pi, 25, 25, 25, 25, 25, 0.99), maxK = 2, expTrc = 30, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="approxMleWnPairs_+3A_data">data</code></td>
<td>
<p>a matrix of dimension <code>c(n, p)</code>.</p>
</td></tr>
<tr><td><code id="approxMleWnPairs_+3A_delta">delta</code></td>
<td>
<p>discretization step.</p>
</td></tr>
<tr><td><code id="approxMleWnPairs_+3A_start">start</code></td>
<td>
<p>starting values, a matrix with <code>p</code> columns, with each
entry representing a different starting value.</p>
</td></tr>
<tr><td><code id="approxMleWnPairs_+3A_alpha">alpha</code></td>
<td>
<p>vector of length <code>3</code> parametrizing the <code>A</code> matrix as in <code><a href="#topic+alphaToA">alphaToA</a></code>.</p>
</td></tr>
<tr><td><code id="approxMleWnPairs_+3A_mu">mu</code></td>
<td>
<p>a vector of length <code>2</code> giving the mean.</p>
</td></tr>
<tr><td><code id="approxMleWnPairs_+3A_sigma">sigma</code></td>
<td>
<p>vector of length <code>2</code> containing the <strong>square root</strong> of the diagonal of <code class="reqn">\Sigma</code>, the diffusion matrix.</p>
</td></tr>
<tr><td><code id="approxMleWnPairs_+3A_rho">rho</code></td>
<td>
<p>correlation coefficient of <code class="reqn">\Sigma</code>.</p>
</td></tr>
<tr><td><code id="approxMleWnPairs_+3A_lower">lower</code>, <code id="approxMleWnPairs_+3A_upper">upper</code></td>
<td>
<p>bound for box constraints as in method <code>"L-BFGS-B"</code>
of <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="approxMleWnPairs_+3A_maxk">maxK</code></td>
<td>
<p>maximum absolute value of the windings considered in the computation of the WN.</p>
</td></tr>
<tr><td><code id="approxMleWnPairs_+3A_exptrc">expTrc</code></td>
<td>
<p>truncation for exponential: <code>exp(x)</code> with <code>x &lt;= -expTrc</code> is set to zero. Defaults to <code>30</code>.</p>
</td></tr>
<tr><td><code id="approxMleWnPairs_+3A_...">...</code></td>
<td>
<p>further parameters passed to <code><a href="#topic+mleOptimWrapper">mleOptimWrapper</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output from <code><a href="#topic+mleOptimWrapper">mleOptimWrapper</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- c(0, 0)
alpha &lt;- c(1, 2, 0.5)
sigma &lt;- c(1, 1)
rho &lt;- 0.5
set.seed(4567345)
begin &lt;- rStatWn2D(n = 200, mu = mu, alpha = alpha, sigma = sigma)
end &lt;- t(apply(begin, 1, function(x) rTrajWn2D(x0 = x, alpha = alpha,
                                               mu = mu, sigma = sigma,
                                               rho = rho, N = 1,
                                               delta = 0.1)[2, ]))
data &lt;- cbind(begin, end)
approxMleWnPairs(data = data, delta = 0.1,
                 start = c(2, pi/2, 2, 0.5, 0, 2, 1, 0.5))
</code></pre>

<hr>
<h2 id='crankNicolson1D'>Crank&ndash;Nicolson finite difference scheme for the 1D Fokker&ndash;Planck equation with periodic boundaries</h2><span id='topic+crankNicolson1D'></span>

<h3>Description</h3>

<p>Implementation of the Crank&ndash;Nicolson scheme for solving the Fokker&ndash;Planck equation
</p>
<p style="text-align: center;"><code class="reqn">p(x, t)_t = -(p(x, t) b(x))_x + \frac{1}{2}(\sigma^2(x) p(x, t))_{xx},</code>
</p>

<p>where <code class="reqn">p(x, t)</code> is the transition probability density of the circular diffusion
</p>
<p style="text-align: center;"><code class="reqn">dX_t=b(X_t)dt+\sigma(X_t)dW_t</code>
</p>
<p>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crankNicolson1D(u0, b, sigma2, N, deltat, Mx, deltax, imposePositive = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crankNicolson1D_+3A_u0">u0</code></td>
<td>
<p>matrix of size <code>c(Mx, 1)</code> giving the initial condition. Typically, the evaluation of a density highly concentrated at a given point. If <code>nt == 1</code>, then <code>u0</code> can be a matrix <code>c(Mx, nu0)</code> containing different starting values in the columns.</p>
</td></tr>
<tr><td><code id="crankNicolson1D_+3A_b">b</code></td>
<td>
<p>vector of length <code>Mx</code> containing the evaluation of the drift.</p>
</td></tr>
<tr><td><code id="crankNicolson1D_+3A_sigma2">sigma2</code></td>
<td>
<p>vector of length <code>Mx</code> containing the evaluation of the squared diffusion coefficient.</p>
</td></tr>
<tr><td><code id="crankNicolson1D_+3A_n">N</code></td>
<td>
<p>increasing integer vector of length <code>nt</code> giving the indexes of the times at which the solution is desired. The times of the solution are <code>delta * c(0:max(N))[N + 1]</code>.</p>
</td></tr>
<tr><td><code id="crankNicolson1D_+3A_deltat">deltat</code></td>
<td>
<p>time step.</p>
</td></tr>
<tr><td><code id="crankNicolson1D_+3A_mx">Mx</code></td>
<td>
<p>size of the equispaced spatial grid in <code class="reqn">[-\pi,\pi)</code>.</p>
</td></tr>
<tr><td><code id="crankNicolson1D_+3A_deltax">deltax</code></td>
<td>
<p>space grid discretization.</p>
</td></tr>
<tr><td><code id="crankNicolson1D_+3A_imposepositive">imposePositive</code></td>
<td>
<p>flag to indicate whether the solution should be transformed in order to be always larger than a given tolerance. This prevents spurious negative values. The tolerance will be taken as <code>imposePositiveTol</code> if this is different from <code>FALSE</code> or <code>0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function makes use of <code><a href="#topic+solvePeriodicTridiag">solvePeriodicTridiag</a></code> for obtaining implicitly the next step in time of the solution.
</p>
<p>If <code>imposePositive = TRUE</code>, the code implicitly assumes that the solution integrates to one at any step. This might b unrealistic if the initial condition is not properly represented in the grid (for example, highly concentrated density in a sparse grid).
</p>


<h3>Value</h3>


<ul>
<li><p> If <code>nt &gt; 1</code>, a matrix of size <code>c(Mx, nt)</code> containing the discretized solution at the required times.
</p>
</li>
<li><p> If <code>nt == 1</code>, a matrix of size <code>c(Mx, nu0)</code> containing the discretized solution at a fixed time for different starting values.
</p>
</li></ul>



<h3>References</h3>

<p>Thomas, J. W. (1995). <em>Numerical Partial Differential Equations: Finite Difference Methods</em>. Springer, New York. <a href="https://doi.org/10.1007/978-1-4899-7278-1">doi:10.1007/978-1-4899-7278-1</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Parameters
Mx &lt;- 200
N &lt;- 200
x &lt;- seq(-pi, pi, l = Mx + 1)[-c(Mx + 1)]
times &lt;- seq(0, 1, l = N + 1)
u0 &lt;- dWn1D(x, pi/2, 0.05)
b &lt;- driftWn1D(x, alpha = 1, mu = pi, sigma = 1)
sigma2 &lt;- rep(1, Mx)

# Full trajectory of the solution (including initial condition)
u &lt;- crankNicolson1D(u0 = cbind(u0), b = b, sigma2 = sigma2, N = 0:N,
                     deltat = 1 / N, Mx = Mx, deltax = 2 * pi / Mx)

# Mass conservation
colMeans(u) * 2 * pi

# Visualization of tpd
plotSurface2D(times, x, z = t(u), levels = seq(0, 3, l = 50))

# Only final time
v &lt;- crankNicolson1D(u0 = cbind(u0), b = b, sigma2 = sigma2, N = N,
                     deltat = 1 / N, Mx = Mx, deltax = 2 * pi / Mx)
sum(abs(u[, N + 1] - v))
</code></pre>

<hr>
<h2 id='crankNicolson2D'>Crank&ndash;Nicolson finite difference scheme for the 2D Fokker&ndash;Planck equation with periodic boundaries</h2><span id='topic+crankNicolson2D'></span>

<h3>Description</h3>

<p>Implementation of the Crank&ndash;Nicolson scheme for solving the Fokker&ndash;Planck equation
</p>
<p style="text-align: center;"><code class="reqn">p(x, y, t)_t = -(p(x, y, t) b_1(x, y))_x -(p(x, y, t) b_2(x, y))_y+</code>
</p>

<p style="text-align: center;"><code class="reqn">+ \frac{1}{2}(\sigma_1^2(x, y) p(x, y, t))_{xx} + \frac{1}{2}(\sigma_2^2(x, y) p(x, y, t))_{yy} + (\sigma_{12}(x, y) p(x, y, t))_{xy},</code>
</p>

<p>where <code class="reqn">p(x, y, t)</code> is the transition probability density of the toroidal diffusion
</p>
<p style="text-align: center;"><code class="reqn">dX_t=b_1(X_t,Y_t)dt+\sigma_1(X_t,Y_t)dW^1_t+\sigma_{12}(X_t,Y_t)dW^2_t,</code>
</p>

<p style="text-align: center;"><code class="reqn">dY_t=b_2(X_t,Y_t)dt+\sigma_{12}(X_t,Y_t)dW^1_t+\sigma_2(X_t,Y_t)dW^2_t.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>crankNicolson2D(u0, bx, by, sigma2x, sigma2y, sigmaxy, N, deltat, Mx, deltax,
  My, deltay, imposePositive = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crankNicolson2D_+3A_u0">u0</code></td>
<td>
<p>matrix of size <code>c(Mx * My, 1)</code> giving the initial condition matrix column-wise stored. Typically, the evaluation of a density highly concentrated at a given point. If <code>nt == 1</code>, then <code>u0</code> can be a matrix <code>c(Mx * My, nu0)</code> containing different starting values in the columns.</p>
</td></tr>
<tr><td><code id="crankNicolson2D_+3A_bx">bx</code>, <code id="crankNicolson2D_+3A_by">by</code></td>
<td>
<p>matrices of size <code>c(Mx, My)</code> containing the evaluation of the drift in the first and second space coordinates, respectively.</p>
</td></tr>
<tr><td><code id="crankNicolson2D_+3A_sigma2x">sigma2x</code>, <code id="crankNicolson2D_+3A_sigma2y">sigma2y</code>, <code id="crankNicolson2D_+3A_sigmaxy">sigmaxy</code></td>
<td>
<p>matrices of size <code>c(Mx, My)</code> containing the evaluation of the entries of the diffusion matrix (it has to be positive definite)<br />
<code>rbind(c(sigma2x, sigmaxy),
            c(sigmaxy, sigma2y))</code>.</p>
</td></tr>
<tr><td><code id="crankNicolson2D_+3A_n">N</code></td>
<td>
<p>increasing integer vector of length <code>nt</code> giving the indexes of the times at which the solution is desired. The times of the solution are <code>delta * c(0:max(N))[N + 1]</code>.</p>
</td></tr>
<tr><td><code id="crankNicolson2D_+3A_deltat">deltat</code></td>
<td>
<p>time step.</p>
</td></tr>
<tr><td><code id="crankNicolson2D_+3A_mx">Mx</code>, <code id="crankNicolson2D_+3A_my">My</code></td>
<td>
<p>sizes of the equispaced spatial grids in <code class="reqn">[-\pi,\pi)</code> for each component.</p>
</td></tr>
<tr><td><code id="crankNicolson2D_+3A_deltax">deltax</code>, <code id="crankNicolson2D_+3A_deltay">deltay</code></td>
<td>
<p>space grid discretizations for each component.</p>
</td></tr>
<tr><td><code id="crankNicolson2D_+3A_imposepositive">imposePositive</code></td>
<td>
<p>flag to indicate whether the solution should be transformed in order to be always larger than a given tolerance. This prevents spurious negative values. The tolerance will be taken as <code>imposePositiveTol</code> if this is different from <code>FALSE</code> or <code>0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function makes use of <code><a href="#topic+solvePeriodicTridiag">solvePeriodicTridiag</a></code> for obtaining implicitly the next step in time of the solution.
</p>
<p>If <code>imposePositive = TRUE</code>, the code implicitly assumes that the solution integrates to one at any step. This might b unrealistic if the initial condition is not properly represented in the grid (for example, highly concentrated density in a sparse grid).
</p>


<h3>Value</h3>


<ul>
<li><p> If <code>nt &gt; 1</code>, a matrix of size <code>c(Mx * My, nt)</code> containing the discretized solution at the required times with the <code>c(Mx, My)</code> matrix stored column-wise.
</p>
</li>
<li><p> If <code>nt == 1</code>, a matrix of size <code>c(Mx * My, nu0)</code> containing the discretized solution at a fixed time for different starting values.
</p>
</li></ul>



<h3>References</h3>

<p>Thomas, J. W. (1995). <em>Numerical Partial Differential Equations: Finite Difference Methods</em>. Springer, New York. <a href="https://doi.org/10.1007/978-1-4899-7278-1">doi:10.1007/978-1-4899-7278-1</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Parameters
Mx &lt;- 100
My &lt;- 100
N &lt;- 200
x &lt;- seq(-pi, pi, l = Mx + 1)[-c(Mx + 1)]
y &lt;- seq(-pi, pi, l = My + 1)[-c(My + 1)]
m &lt;- c(pi / 2, pi)
p &lt;- c(0, 1)
u0 &lt;- c(outer(dWn1D(x, p[1], 0.5), dWn1D(y, p[2], 0.5)))
bx &lt;- outer(x, y, function(x, y) 5 * sin(m[1] - x))
by &lt;- outer(x, y, function(x, y) 5 * sin(m[2] - y))
sigma2 &lt;- matrix(1, nrow = Mx, ncol = My)
sigmaxy &lt;- matrix(0.5, nrow = Mx, ncol = My)

# Full trajectory of the solution (including initial condition)
u &lt;- crankNicolson2D(u0 = cbind(u0), bx = bx, by = by, sigma2x = sigma2,
                     sigma2y = sigma2, sigmaxy = sigmaxy,
                     N = 0:N, deltat = 1 / N, Mx = Mx, deltax = 2 * pi / Mx,
                     My = My, deltay = 2 * pi / My)

# Mass conservation
colMeans(u) * 4 * pi^2

# Only final time
v &lt;- crankNicolson2D(u0 = cbind(u0), bx = bx, by = by, sigma2x = sigma2,
                     sigma2y = sigma2, sigmaxy = sigmaxy,
                     N = N, deltat = 1 / N, Mx = Mx, deltax = 2 * pi / Mx,
                     My = My, deltay = 2 * pi / My)
sum(abs(u[, N + 1] - v))

## Not run: 
# Visualization of tpd
library(manipulate)
manipulate({
  plotSurface2D(x, y, z = matrix(u[, j + 1], Mx, My),
                main = round(mean(u[, j + 1]) * 4 * pi^2, 4),
                levels = seq(0, 2, l = 21))
  points(p[1], p[2], pch = 16)
  points(m[1], m[2], pch = 16)
}, j = slider(0, N))

## End(Not run)
</code></pre>

<hr>
<h2 id='dBvm'>Bivariate Sine von Mises density</h2><span id='topic+dBvm'></span><span id='topic+constBvm'></span>

<h3>Description</h3>

<p>Evaluation of the bivariate Sine von Mises density and its
normalizing constant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dBvm(x, mu, kappa, logConst = NULL)

constBvm(M = 25, kappa)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dBvm_+3A_x">x</code></td>
<td>
<p>a matrix of size <code>c(nx, 2)</code> for evaluating the density.</p>
</td></tr>
<tr><td><code id="dBvm_+3A_mu">mu</code></td>
<td>
<p>two-dimensional vector of circular means.</p>
</td></tr>
<tr><td><code id="dBvm_+3A_kappa">kappa</code></td>
<td>
<p>three-dimensional vector with concentrations
<code class="reqn">(\kappa_1, \kappa_2, \lambda)</code>.</p>
</td></tr>
<tr><td><code id="dBvm_+3A_logconst">logConst</code></td>
<td>
<p>logarithm of the normalizing constant. Computed if
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="dBvm_+3A_m">M</code></td>
<td>
<p>number of terms considered in the series expansion used for
evaluating the normalizing constant.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">\kappa_1 = 0</code> or <code class="reqn">\kappa_2 = 0</code> and <code class="reqn">\lambda \neq 0</code>,
then <code>constBvm</code> will perform a Monte Carlo integration of the constant.
</p>


<h3>Value</h3>

<p>A vector of length <code>nx</code> with the evaluated density
(<code>dBvm</code>) or a scalar with the normaalizing constant (<code>constBvm</code>).
</p>


<h3>References</h3>

<p>Singh, H., Hnizdo, V. and Demchuk, E. (2002) Probabilistic model
for two dependent circular variables, <em>Biometrika</em>, 89(3):719&ndash;723,
<a href="https://doi.org/10.1093/biomet/89.3.719">doi:10.1093/biomet/89.3.719</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-pi, pi, l = 101)[-101]
plotSurface2D(x, x, f = function(x) dBvm(x = x, mu = c(0, pi / 2),
                                         kappa = c(2, 3, 1)),
             fVect = TRUE)
</code></pre>

<hr>
<h2 id='diffCirc'>Lagged differences for circular time series</h2><span id='topic+diffCirc'></span>

<h3>Description</h3>

<p>Returns suitably lagged and iterated circular differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffCirc(x, circular = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diffCirc_+3A_x">x</code></td>
<td>
<p>wrapped or unwrapped angles to be differenced. Must be a vector
or a matrix, see details.</p>
</td></tr>
<tr><td><code id="diffCirc_+3A_circular">circular</code></td>
<td>
<p>convenience flag to indicate whether wrapping should be
done. If <code>FALSE</code>, the function is exactly <code><a href="base.html#topic+diff">diff</a></code>.</p>
</td></tr>
<tr><td><code id="diffCirc_+3A_...">...</code></td>
<td>
<p>parameters to be passed to <code><a href="base.html#topic+diff">diff</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a matrix then the difference operations are carried
out row-wise, on each column separately.
</p>


<h3>Value</h3>

<p>The value of <code>diff(x, ...)</code>, circularly wrapped. Default
parameters give an object of the kind of <code>x</code> with one less entry or row.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Vectors
x &lt;- c(-pi, -pi/2, pi - 0.1, -pi + 0.2)
diffCirc(x) - diff(x)

# Matrices
set.seed(234567)
N &lt;- 100
x &lt;- t(euler2D(x0 = rbind(c(0, 0)), A = diag(c(1, 1)), sigma = rep(2, 2),
               mu = c(pi, pi), N = N, delta = 1, type = 2)[1, , ])
diffCirc(x) - diff(x)
</code></pre>

<hr>
<h2 id='dJp'>Jones and Pewsey (2005)'s circular distribution</h2><span id='topic+dJp'></span><span id='topic+constJp'></span>

<h3>Description</h3>

<p>Computes the circular density of Jones and Pewsey (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dJp(x, mu, kappa, psi, const = NULL)

constJp(mu, kappa, psi, M = 200)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dJp_+3A_x">x</code></td>
<td>
<p>evaluation angles, not necessary in <code class="reqn">[\pi,\pi)</code>.</p>
</td></tr>
<tr><td><code id="dJp_+3A_mu">mu</code></td>
<td>
<p>circular mean.</p>
</td></tr>
<tr><td><code id="dJp_+3A_kappa">kappa</code></td>
<td>
<p>non-negative concentration parameter.</p>
</td></tr>
<tr><td><code id="dJp_+3A_psi">psi</code></td>
<td>
<p>shape parameter, see details.</p>
</td></tr>
<tr><td><code id="dJp_+3A_const">const</code></td>
<td>
<p>normalizing constant, computed with <code>constJp</code> if not
provided.</p>
</td></tr>
<tr><td><code id="dJp_+3A_m">M</code></td>
<td>
<p>grid size for computing the normalizing constant by numerical
integration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Particular interesting choices for the shape parameter are:
</p>

<ul>
<li> <p><code>psi = -1</code>: gives the Wrapped Cauchy as stationary density.
</p>
</li>
<li> <p><code>psi = 0</code>: is the sinusoidal drift of the vM diffusion.
</p>
</li>
<li> <p><code>psi = 1</code>: gives the Cardioid as stationary density.
</p>
</li></ul>



<h3>Value</h3>

<p>A vector of the same length as <code>x</code> containing the density.
</p>


<h3>References</h3>

<p>Jones, M. C. and Pewsey, A. (2005). A family of symmetric distributions on
the circle. <em>Journal of the American Statistical Association</em>,
100(472):1422&ndash;1428. <a href="https://doi.org/10.1198/016214505000000286">doi:10.1198/016214505000000286</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-pi, pi, l = 200)
plot(x, x, type = "n", ylab = "Density", ylim = c(0, 0.6))
for (i in 0:20) {
  lines(x, dJp(x = x, mu = 0, kappa = 1, psi = -2 + 4 * i / 20),
        col = rainbow(21)[i + 1])
}
</code></pre>

<hr>
<h2 id='dPsTpd'>Wrapped Euler and Shoji&ndash;Ozaki pseudo-transition probability densities</h2><span id='topic+dPsTpd'></span>

<h3>Description</h3>

<p>Wrapped pseudo-transition probability densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dPsTpd(x, x0, t, method = c("E", "SO", "SO2"), b, jac.b, sigma2, b1, b2,
  circular = TRUE, maxK = 2, vmApprox = FALSE, twokpi = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dPsTpd_+3A_x">x</code></td>
<td>
<p>a matrix of dimension <code>c(n, p)</code>. If a vector is provided, is
assumed that <code>p = 1</code>.</p>
</td></tr>
<tr><td><code id="dPsTpd_+3A_x0">x0</code></td>
<td>
<p>a matrix of dimension <code>c(n, p)</code>. If all <code>x0</code> are the
same, a matrix of dimension <code>c(1, p)</code> can be passed for better
performance. If a vector is provided, is assumed that <code>p = 1</code>.</p>
</td></tr>
<tr><td><code id="dPsTpd_+3A_t">t</code></td>
<td>
<p>time step between <code>x</code> and <code>x0</code>.</p>
</td></tr>
<tr><td><code id="dPsTpd_+3A_method">method</code></td>
<td>
<p>a string for choosing <code>"E"</code> (Euler), <code>"SO"</code>
(Shoji&ndash;Ozaki) or <code>"SO2"</code> (Shoji&ndash;Ozaki with Ito's expansion in the
drift) method.</p>
</td></tr>
<tr><td><code id="dPsTpd_+3A_b">b</code></td>
<td>
<p>drift function. Must return a matrix of the same size as <code>x</code>.</p>
</td></tr>
<tr><td><code id="dPsTpd_+3A_jac.b">jac.b</code></td>
<td>
<p>jacobian of the drift function.</p>
</td></tr>
<tr><td><code id="dPsTpd_+3A_sigma2">sigma2</code></td>
<td>
<p>diagonal of the diffusion matrix (if univariate, this is the
square of the diffusion coefficient). Must return an object of the same
size as <code>x</code>.</p>
</td></tr>
<tr><td><code id="dPsTpd_+3A_b1">b1</code></td>
<td>
<p>first derivative of the drift function (univariate). Must return
a vector of the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="dPsTpd_+3A_b2">b2</code></td>
<td>
<p>second derivative of the drift function (univariate). Must return
a vector of the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="dPsTpd_+3A_circular">circular</code></td>
<td>
<p>flag to indicate circular data.</p>
</td></tr>
<tr><td><code id="dPsTpd_+3A_maxk">maxK</code></td>
<td>
<p>maximum absolute winding number used if <code>circular = TRUE</code>.</p>
</td></tr>
<tr><td><code id="dPsTpd_+3A_vmapprox">vmApprox</code></td>
<td>
<p>flag to indicate von Mises approximation to wrapped normal.
See<br /> <code><a href="#topic+momentMatchWnVm">momentMatchWnVm</a></code> and <code><a href="#topic+scoreMatchWnBvm">scoreMatchWnBvm</a></code>.</p>
</td></tr>
<tr><td><code id="dPsTpd_+3A_twokpi">twokpi</code></td>
<td>
<p>optional matrix of winding numbers to avoid its recomputation.
See details.</p>
</td></tr>
<tr><td><code id="dPsTpd_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code>b</code>, <code>b1</code>, <code>b2</code>,
<code>jac.b</code> and <code>sigma2</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Section 3.2 in García-Portugués et al. (2019) for details.
<code>"SO2"</code> implements Shoji and Ozai (1998)'s expansion with for
<code>p = 1</code>. <code>"SO"</code> is the same expansion, for arbitrary <code>p</code>, but
considering null second derivatives.
</p>
<p><code>twokpi</code> is <code>repRow(2 * pi * c(-maxK:maxK), n = n)</code> if <code>p = 1</code>
and<br /> <code>as.matrix(do.call(what = expand.grid,
args = rep(list(2 * pi * c(-maxK:maxK)), p)))</code> otherwise.
</p>


<h3>Value</h3>

<p>Output from <code><a href="#topic+mleOptimWrapper">mleOptimWrapper</a></code>.
</p>


<h3>References</h3>

<p>García-Portugués, E., Sørensen, M., Mardia, K. V. and Hamelryck, T. (2019)
Langevin diffusions on the torus: estimation and applications.
<em>Statistics and Computing</em>, 29(2):1&ndash;22. <a href="https://doi.org/10.1007/s11222-017-9790-2">doi:10.1007/s11222-017-9790-2</a>
</p>
<p>Shoji, I. and Ozaki, T. (1998) A statistical method of estimation and
simulation for systems of stochastic differential equations.
<em>Biometrika</em>, 85(1):240&ndash;243. <a href="https://doi.org/10.1093/biomet/85.1.240">doi:10.1093/biomet/85.1.240</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1D
grid &lt;- seq(-pi, pi, l = 501)[-501]
alpha &lt;- 1
sigma &lt;- 1
t &lt;- 0.5
x0 &lt;- pi/2
# manipulate::manipulate({

  # Drifts
  b &lt;- function(x) driftWn1D(x = x, alpha = alpha, mu = 0, sigma = sigma)
  b1 &lt;- function(x, h = 1e-4) {
    l &lt;- length(x)
    res &lt;- driftWn1D(x = c(x + h, x - h), alpha = alpha, mu = 0,
                     sigma = sigma)
    drop(res[1:l] - res[(l + 1):(2 * l)])/(2 * h)
  }
  b2 &lt;- function(x, h = 1e-4) {
    l &lt;- length(x)
    res &lt;- driftWn1D(x = c(x + h, x, x - h), alpha = alpha, mu = 0,
                     sigma = sigma)
    drop(res[1:l] - 2 * res[(l + 1):(2 * l)] +
          res[(2 * l + 1):(3 * l)]) / (h^2)
  }

  # Squared diffusion
  sigma2 &lt;- function(x) rep(sigma^2, length(x))

  # Plot
  plot(grid, dTpdPde1D(Mx = length(grid), x0 = x0, t = t, alpha = alpha,
                       mu = 0, sigma = sigma), type = "l",
       ylab = "Density", xlab = "", ylim = c(0, 0.75), lwd = 2)
  lines(grid, dTpdWou1D(x = grid, x0 = rep(x0, length(grid)), t = t,
                       alpha = alpha, mu = 0, sigma = sigma), col = 2)
  lines(grid, dPsTpd(x = grid, x0 = x0, t = t, method = "E", b = b,
                     b1 = b1, b2 = b2, sigma2 = sigma2), col = 3)
  lines(grid, dPsTpd(x = grid, x0 = x0, t = t, method = "SO", b = b,
                     b1 = b1, b2 = b2, sigma2 = sigma2), col = 4)
  lines(grid, dPsTpd(x = grid, x0 = x0, t = t, method = "SO2", b = b,
                     b1 = b1, b2 = b2, sigma2 = sigma2),
        col = 5)
  lines(grid, dPsTpd(x = grid, x0 = x0, t = t, method = "E", b = b,
                     b1 = b1, b2 = b2, sigma2 = sigma2, vmApprox = TRUE),
        col = 6)
  lines(grid, dPsTpd(x = grid, x0 = x0, t = t, method = "SO", b = b,
                     b1 = b1, b2 = b2, sigma2 = sigma2, vmApprox = TRUE),
        col = 7)
  lines(grid, dPsTpd(x = grid, x0 = x0, t = t, method = "SO2", b = b,
                     b1 = b1, b2 = b2, sigma2 = sigma2, vmApprox = TRUE),
        col = 8)
  legend("topright", legend = c("PDE", "WOU", "E", "SO1", "SO2", "EvM",
                                "SO1vM", "SO2vM"), lwd = 2, col = 1:8)

# }, x0 = manipulate::slider(-pi, pi, step = 0.1, initial = -pi),
# alpha = manipulate::slider(0.1, 5, step = 0.1, initial = 1),
# sigma = manipulate::slider(0.1, 5, step = 0.1, initial = 1),
# t = manipulate::slider(0.1, 5, step = 0.1, initial = 1))

# 2D
grid &lt;- seq(-pi, pi, l = 76)[-76]
alpha1 &lt;- 2
alpha2 &lt;- 1
alpha3 &lt;- 0.5
sig1 &lt;- 1
sig2 &lt;- 2
t &lt;- 0.5
x01 &lt;- pi/2
x02 &lt;- -pi/2
# manipulate::manipulate({

  alpha &lt;- c(alpha1, alpha2, alpha3)
  sigma &lt;- c(sig1, sig2)
  x0 &lt;- c(x01, x02)

  # Drifts
  b &lt;- function(x) driftWn2D(x = x, A = alphaToA(alpha = alpha,
                                                 sigma = sigma),
                             mu = rep(0, 2), sigma = sigma)
  jac.b &lt;- function(x, h = 1e-4) {
    l &lt;- nrow(x)
    res &lt;- driftWn2D(x = rbind(cbind(x[, 1] + h, x[, 2]),
                               cbind(x[, 1] - h, x[, 2]),
                               cbind(x[, 1], x[, 2] + h),
                               cbind(x[, 1], x[, 2] - h)),
                     A = alphaToA(alpha = alpha, sigma = sigma),
                     mu = rep(0, 2), sigma = sigma)
    cbind(res[1:l, ] - res[(l + 1):(2 * l), ],
          res[2 * l + 1:l, ] - res[2 * l + (l + 1):(2 * l), ]) / (2 * h)
  }

  # Squared diffusion
  sigma2 &lt;- function(x) matrix(sigma^2, nrow = length(x) / 2L, ncol = 2)

  # Plot
  old_par &lt;- par(mfrow = c(3, 2))
  plotSurface2D(grid, grid, z = dTpdPde2D(Mx = length(grid),
                                          My = length(grid), x0 = x0,
                                          t = t, alpha = alpha,
                                          mu = rep(0, 2), sigma = sigma),
                levels = seq(0, 1, l = 20), main = "Exact")
  plotSurface2D(grid, grid,
                f = function(x) drop(dTpdWou2D(x = x,
                                               x0 = repRow(x0, nrow(x)),
                                               t = t, alpha = alpha,
                                               mu = rep(0, 2),
                                               sigma = sigma)),
                levels = seq(0, 1, l = 20), fVect = TRUE, main = "WOU")
  plotSurface2D(grid, grid,
                f = function(x) dPsTpd(x = x, x0 = rbind(x0), t = t,
                                       method = "E", b = b, jac.b = jac.b,
                                       sigma2 = sigma2),
                levels = seq(0, 1, l = 20), fVect = TRUE, main = "E")
  plotSurface2D(grid, grid,
                f = function(x) dPsTpd(x = x, x0 = rbind(x0), t = t,
                                       method = "SO", b = b, jac.b = jac.b,
                                       sigma2 = sigma2),
                levels = seq(0, 1, l = 20), fVect = TRUE, main = "SO")
  plotSurface2D(grid, grid,
                f = function(x) dPsTpd(x = x, x0 = rbind(x0), t = t,
                                       method = "E", b = b, jac.b = jac.b,
                                       sigma2 = sigma2, vmApprox = TRUE),
                levels = seq(0, 1, l = 20), fVect = TRUE, main = "EvM")
  plotSurface2D(grid, grid,
                f = function(x) dPsTpd(x = x, x0 = rbind(x0), t = t,
                                       method = "SO", b = b, jac.b = jac.b,
                                       sigma2 = sigma2, vmApprox = TRUE),
                levels = seq(0, 1, l = 20), fVect = TRUE, main = "SOvM")
  par(old_par)

# }, x01 = manipulate::slider(-pi, pi, step = 0.1, initial = -pi),
# x02 = manipulate::slider(-pi, pi, step = 0.1, initial = -pi),
# alpha1 = manipulate::slider(0.1, 5, step = 0.1, initial = 1),
# alpha2 = manipulate::slider(0.1, 5, step = 0.1, initial = 1),
# alpha3 = manipulate::slider(-5, 5, step = 0.1, initial = 0),
# sig1 = manipulate::slider(0.1, 5, step = 0.1, initial = 1),
# sig2 = manipulate::slider(0.1, 5, step = 0.1, initial = 1),
# t = manipulate::slider(0.01, 5, step = 0.01, initial = 1))
</code></pre>

<hr>
<h2 id='driftJp'>Drift for the JP diffusion</h2><span id='topic+driftJp'></span>

<h3>Description</h3>

<p>Drift for the Langevin diffusion associated to the Jones and
Pewsey (JP) family of circular distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>driftJp(x, alpha, mu, psi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="driftJp_+3A_x">x</code></td>
<td>
<p>vector with the evaluation points for the drift.</p>
</td></tr>
<tr><td><code id="driftJp_+3A_alpha">alpha</code></td>
<td>
<p>strength of the drift.</p>
</td></tr>
<tr><td><code id="driftJp_+3A_mu">mu</code></td>
<td>
<p>unconditional mean of the diffusion.</p>
</td></tr>
<tr><td><code id="driftJp_+3A_psi">psi</code></td>
<td>
<p>shape parameter, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Particular interesting choices for the shape parameter are:
</p>

<ul>
<li> <p><code>psi = -1</code>: gives the Wrapped Cauchy as stationary density.
</p>
</li>
<li> <p><code>psi = 0</code>: is the sinusoidal drift of the vM diffusion.
</p>
</li>
<li> <p><code>psi = 1</code>: gives the Cardioid as stationary density.
</p>
</li></ul>

<p>See Section 2.2.3 in García-Portugués et al. (2019) for details.
</p>


<h3>Value</h3>

<p>A vector of the same length as <code>x</code> containing the drift.
</p>


<h3>References</h3>

<p>García-Portugués, E., Sørensen, M., Mardia, K. V. and Hamelryck, T. (2019)
Langevin diffusions on the torus: estimation and applications.
<em>Statistics and Computing</em>, 29(2):1&ndash;22. <a href="https://doi.org/10.1007/s11222-017-9790-2">doi:10.1007/s11222-017-9790-2</a>
</p>
<p>Jones, M. C. and Pewsey, A. (2005). A family of symmetric distributions on
the circle. <em>Journal of the American Statistical Association</em>,
100(472):1422&ndash;1428. <a href="https://doi.org/10.1198/016214505000000286">doi:10.1198/016214505000000286</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-pi, pi, l = 200)
plot(x, x, type = "n", ylab = "drift")
for (i in 0:20) {
  lines(x, driftJp(x = x, alpha = 1, mu = 0, psi = -1 + 2 * i / 20),
        col = rainbow(21)[i + 1])
}
</code></pre>

<hr>
<h2 id='driftMixIndVm'>Drift for the mivM diffusion</h2><span id='topic+driftMixIndVm'></span>

<h3>Description</h3>

<p>Drift for the Langevin diffusion associated to a mixture of
<code>m</code> independent (multivariate) von Mises (mivM) of dimension <code>p</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>driftMixIndVm(x, A, M, sigma, p, expTrc = 30)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="driftMixIndVm_+3A_x">x</code></td>
<td>
<p>matrix of size <code>c(n, p)</code> with the evaluation points for the
drift.</p>
</td></tr>
<tr><td><code id="driftMixIndVm_+3A_a">A</code></td>
<td>
<p>matrix of size <code>c(m, p)</code> giving the strengths of the drifts.</p>
</td></tr>
<tr><td><code id="driftMixIndVm_+3A_m">M</code></td>
<td>
<p>matrix of size <code>c(m, p)</code> giving the means.</p>
</td></tr>
<tr><td><code id="driftMixIndVm_+3A_sigma">sigma</code></td>
<td>
<p>diffusion coefficient.</p>
</td></tr>
<tr><td><code id="driftMixIndVm_+3A_p">p</code></td>
<td>
<p>vector of length <code>m</code> giving the proportions. Must add to one.</p>
</td></tr>
<tr><td><code id="driftMixIndVm_+3A_exptrc">expTrc</code></td>
<td>
<p>truncation for exponential: <code>exp(x)</code> with <code>x &lt;= -expTrc</code> is set to zero. Defaults to <code>30</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+driftMixVm">driftMixVm</a></code> is more efficient for the circular case.
The diffusion matrix is <code class="reqn">\sigma\bold{I}</code>. See Section 2.2.4 in
García-Portugués et al. (2019) for details.
</p>


<h3>Value</h3>

<p>A matrix of the same size as <code>x</code> containing the drift.
</p>


<h3>References</h3>

<p>García-Portugués, E., Sørensen, M., Mardia, K. V. and Hamelryck, T. (2019)
Langevin diffusions on the torus: estimation and applications.
<em>Statistics and Computing</em>, 29(2):1&ndash;22. <a href="https://doi.org/10.1007/s11222-017-9790-2">doi:10.1007/s11222-017-9790-2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1D
x &lt;- seq(-pi, pi, l = 200)
plot(x, x, type = "n", ylab = "drift")
for (i in 1:10) {
  lines(x, driftMixIndVm(x = cbind(x), A = cbind(c(2, 2)),
        M = cbind(c(0, -pi + 2 * pi * i / 10)), sigma = 1, p = c(0.5, 0.5)),
        col = rainbow(10)[i])
}

# 2D
x &lt;- seq(-pi, pi, l = 100)
plotSurface2D(x, x, f = function(x) sqrt(rowSums(driftMixIndVm(x = x,
              A = rbind(c(1, 1), c(1, 1)), M = rbind(c(1, 1), c(-1, -1)),
              sigma = 1, p = c(0.25, 0.75))^2)), fVect = TRUE)
</code></pre>

<hr>
<h2 id='driftMixVm'>Drift for the mivM diffusion (circular case)</h2><span id='topic+driftMixVm'></span>

<h3>Description</h3>

<p>Drift for the Langevin diffusion associated to a mixture of
<code>m</code> independent von Mises (mivM) of dimension one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>driftMixVm(x, alpha, mu, sigma, p, expTrc = 30)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="driftMixVm_+3A_x">x</code></td>
<td>
<p>vector with the evaluation points for the drift.</p>
</td></tr>
<tr><td><code id="driftMixVm_+3A_alpha">alpha</code></td>
<td>
<p>vector of length <code>m</code> giving the strengths of the drifts.</p>
</td></tr>
<tr><td><code id="driftMixVm_+3A_mu">mu</code></td>
<td>
<p>vector of length <code>m</code> giving the means.</p>
</td></tr>
<tr><td><code id="driftMixVm_+3A_sigma">sigma</code></td>
<td>
<p>diffusion coefficient.</p>
</td></tr>
<tr><td><code id="driftMixVm_+3A_p">p</code></td>
<td>
<p>vector of length <code>m</code> giving the proportions. Must add to one.</p>
</td></tr>
<tr><td><code id="driftMixVm_+3A_exptrc">expTrc</code></td>
<td>
<p>truncation for exponential: <code>exp(x)</code> with <code>x &lt;= -expTrc</code> is set to zero. Defaults to <code>30</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+driftMixIndVm">driftMixIndVm</a></code> is more general, but less efficient for
the circular case. See Section 2.2.4 in García-Portugués et al. (2019) for
details.
</p>


<h3>Value</h3>

<p>A vector of the same length as <code>x</code> containing the drift.
</p>


<h3>References</h3>

<p>García-Portugués, E., Sørensen, M., Mardia, K. V. and Hamelryck, T. (2019)
Langevin diffusions on the torus: estimation and applications.
<em>Statistics and Computing</em>, 29(2):1&ndash;22. <a href="https://doi.org/10.1007/s11222-017-9790-2">doi:10.1007/s11222-017-9790-2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-pi, pi, l = 200)
plot(x, x, type = "n", ylab = "drift")
for (i in 1:10) {
  lines(x, driftMixVm(x = x, alpha = c(2, 2),
                      mu = c(0, -pi + 2 * pi * i / 10),
                      sigma = 1, p = c(0.5, 0.5)), col = rainbow(10)[i])
}
</code></pre>

<hr>
<h2 id='driftMvm'>Drift for the MvM diffusion</h2><span id='topic+driftMvm'></span>

<h3>Description</h3>

<p>Drift for the Langevin diffusion associated to the Multivariate
von Mises (MvM) in dimension <code>p</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>driftMvm(x, alpha, mu, A = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="driftMvm_+3A_x">x</code></td>
<td>
<p>matrix of size <code>c(n, p)</code> with the evaluation points for the
drift.</p>
</td></tr>
<tr><td><code id="driftMvm_+3A_alpha">alpha</code></td>
<td>
<p>vector of length <code>p</code> with the strength of the drift in
the diagonal (<code class="reqn">\sin</code> terms).</p>
</td></tr>
<tr><td><code id="driftMvm_+3A_mu">mu</code></td>
<td>
<p>vector of length <code>p</code> with the unconditional mean of the
diffusion.</p>
</td></tr>
<tr><td><code id="driftMvm_+3A_a">A</code></td>
<td>
<p>matrix of size <code>c(p, p)</code> with the strength of the drift in
cross terms (<code class="reqn">\cos</code>-<code class="reqn">\sin</code> terms). The diagonal has to
be zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Section 2.2.1 in García-Portugués et al. (2019) for details.
</p>


<h3>Value</h3>

<p>A matrix of the same size as <code>x</code> containing the drift.
</p>


<h3>References</h3>

<p>García-Portugués, E., Sørensen, M., Mardia, K. V. and Hamelryck, T. (2019)
Langevin diffusions on the torus: estimation and applications.
<em>Statistics and Computing</em>, 29(2):1&ndash;22. <a href="https://doi.org/10.1007/s11222-017-9790-2">doi:10.1007/s11222-017-9790-2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1D
x &lt;- seq(-pi, pi, l = 200)
plot(x, x, type = "n", ylab = "drift")
for (i in 0:20) {
  lines(x, driftMvm(x = x, alpha = 3 * i / 20, mu = 0, A = 0),
        col = rainbow(21)[i + 1])
}

# 2D
x &lt;- seq(-pi, pi, l = 100)
plotSurface2D(x, x, f = function(x) sqrt(rowSums(driftMvm(x = x,
              alpha = c(2, 2), mu = c(-1, -1),
              A = rbind(c(0, 0), c(0, 0)))^2)),
              fVect = TRUE)
</code></pre>

<hr>
<h2 id='driftWn'>Drift for the WN diffusion</h2><span id='topic+driftWn'></span>

<h3>Description</h3>

<p>Drift for the Langevin diffusion associated to the
(multivariate) Wrapped Normal (WN) in dimension <code>p</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>driftWn(x, A, mu, Sigma, invSigmaA = NULL, maxK = 2, expTrc = 30)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="driftWn_+3A_x">x</code></td>
<td>
<p>matrix of size <code>c(n, p)</code> with the evaluation points for the
drift.</p>
</td></tr>
<tr><td><code id="driftWn_+3A_a">A</code></td>
<td>
<p>matrix of size <code>c(p, p)</code> giving the drift strength.</p>
</td></tr>
<tr><td><code id="driftWn_+3A_mu">mu</code></td>
<td>
<p>vector of length <code>p</code> with the unconditional mean of the
diffusion.</p>
</td></tr>
<tr><td><code id="driftWn_+3A_sigma">Sigma</code></td>
<td>
<p>diffusion matrix, of size <code>c(p, p)</code>.</p>
</td></tr>
<tr><td><code id="driftWn_+3A_invsigmaa">invSigmaA</code></td>
<td>
<p>the matrix <code>solve(Sigma) %*% A</code> (optional).</p>
</td></tr>
<tr><td><code id="driftWn_+3A_maxk">maxK</code></td>
<td>
<p>maximum absolute value of the windings considered in the computation of the WN.</p>
</td></tr>
<tr><td><code id="driftWn_+3A_exptrc">expTrc</code></td>
<td>
<p>truncation for exponential: <code>exp(x)</code> with <code>x &lt;= -expTrc</code> is set to zero. Defaults to <code>30</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Section 2.2.2 in García-Portugués et al. (2019) for details.
</p>
<p><code><a href="#topic+driftWn1D">driftWn1D</a></code> and <code><a href="#topic+driftWn2D">driftWn2D</a></code> are more
efficient for the 1D and 2D cases.
</p>


<h3>Value</h3>

<p>A matrix of the same size as <code>x</code> containing the drift.
</p>


<h3>References</h3>

<p>García-Portugués, E., Sørensen, M., Mardia, K. V. and Hamelryck, T. (2019)
Langevin diffusions on the torus: estimation and applications.
<em>Statistics and Computing</em>, 29(2):1&ndash;22. <a href="https://doi.org/10.1007/s11222-017-9790-2">doi:10.1007/s11222-017-9790-2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1D
x &lt;- seq(-pi, pi, l = 200)
plot(x, x, type = "n", ylab = "drift")
for (i in 1:20) {
  lines(x, driftWn(x = cbind(x), A = 1 * i / 20, mu = 0, Sigma = 1),
        col = rainbow(20)[i])
}

# 2D
x &lt;- seq(-pi, pi, l = 100)
plotSurface2D(x, x, f = function(x) sqrt(rowSums(
              driftWn(x = x, A = alphaToA(alpha = c(1, 1, 0.5),
                                          sigma = c(1.5, 1.5)), mu = c(0, 0),
              Sigma = diag(c(1.5^2, 1.5^2)))^2)), fVect = TRUE)
</code></pre>

<hr>
<h2 id='driftWn1D'>Drift of the WN diffusion in 1D</h2><span id='topic+driftWn1D'></span>

<h3>Description</h3>

<p>Computes the drift of the WN diffusion in 1D in a vectorized way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>driftWn1D(x, alpha, mu, sigma, maxK = 2L, expTrc = 30)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="driftWn1D_+3A_x">x</code></td>
<td>
<p>a vector of length <code>n</code> containing angles. They all must be in <code class="reqn">[\pi,\pi)</code> so that the truncated wrapping by <code>maxK</code> windings is able to capture periodicity.</p>
</td></tr>
<tr><td><code id="driftWn1D_+3A_alpha">alpha</code></td>
<td>
<p>drift parameter.</p>
</td></tr>
<tr><td><code id="driftWn1D_+3A_mu">mu</code></td>
<td>
<p>mean parameter. Must be in <code class="reqn">[\pi,\pi)</code>.</p>
</td></tr>
<tr><td><code id="driftWn1D_+3A_sigma">sigma</code></td>
<td>
<p>diffusion coefficient.</p>
</td></tr>
<tr><td><code id="driftWn1D_+3A_maxk">maxK</code></td>
<td>
<p>maximum absolute value of the windings considered in the computation of the WN.</p>
</td></tr>
<tr><td><code id="driftWn1D_+3A_exptrc">expTrc</code></td>
<td>
<p>truncation for exponential: <code>exp(x)</code> with <code>x &lt;= -expTrc</code> is set to zero. Defaults to <code>30</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>n</code> containing the drift evaluated at <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>driftWn1D(x = seq(0, pi, l = 10), alpha = 1, mu = 0, sigma = 1, maxK = 2,
          expTrc = 30)
</code></pre>

<hr>
<h2 id='driftWn2D'>Drift of the WN diffusion in 2D</h2><span id='topic+driftWn2D'></span>

<h3>Description</h3>

<p>Computes the drift of the WN diffusion in 2D in a vectorized way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>driftWn2D(x, A, mu, sigma, rho = 0, maxK = 2L, expTrc = 30)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="driftWn2D_+3A_x">x</code></td>
<td>
<p>a matrix of dimension <code>c(n, 2)</code> containing angles. They all must be in <code class="reqn">[\pi,\pi)</code> so that the truncated wrapping by <code>maxK</code> windings is able to capture periodicity.</p>
</td></tr>
<tr><td><code id="driftWn2D_+3A_a">A</code></td>
<td>
<p>drift matrix of size <code>c(2, 2)</code>.</p>
</td></tr>
<tr><td><code id="driftWn2D_+3A_mu">mu</code></td>
<td>
<p>a vector of length <code>2</code> giving the mean.</p>
</td></tr>
<tr><td><code id="driftWn2D_+3A_sigma">sigma</code></td>
<td>
<p>vector of length <code>2</code> containing the <strong>square root</strong> of the diagonal of <code class="reqn">\Sigma</code>, the diffusion matrix.</p>
</td></tr>
<tr><td><code id="driftWn2D_+3A_rho">rho</code></td>
<td>
<p>correlation coefficient of <code class="reqn">\Sigma</code>.</p>
</td></tr>
<tr><td><code id="driftWn2D_+3A_maxk">maxK</code></td>
<td>
<p>maximum absolute value of the windings considered in the computation of the WN.</p>
</td></tr>
<tr><td><code id="driftWn2D_+3A_exptrc">expTrc</code></td>
<td>
<p>truncation for exponential: <code>exp(x)</code> with <code>x &lt;= -expTrc</code> is set to zero. Defaults to <code>30</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size <code>c(n, 2)</code> containing the drift evaluated at <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;- 3:1
mu &lt;- c(0, 0)
sigma &lt;- 1:2
rho &lt;- 0.5
Sigma &lt;- diag(sigma^2)
Sigma[1, 2] &lt;- Sigma[2, 1] &lt;- rho * prod(sigma)
A &lt;- alphaToA(alpha = alpha, sigma = sigma, rho = rho)
x &lt;- rbind(c(0, 1), c(1, 0.1), c(pi, pi), c(-pi, -pi), c(pi / 2, 0))
driftWn2D(x = x, A = A, mu = mu, sigma = sigma, rho = rho)
driftWn(x = x, A = A, mu = c(0, 0), Sigma = Sigma)
</code></pre>

<hr>
<h2 id='dStatWn2D'>Stationary density of a WN diffusion (with diagonal diffusion matrix) in 2D</h2><span id='topic+dStatWn2D'></span>

<h3>Description</h3>

<p>Stationary density of the WN diffusion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dStatWn2D(x, alpha, mu, sigma, rho = 0, maxK = 2L, expTrc = 30)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dStatWn2D_+3A_x">x</code></td>
<td>
<p>a matrix of dimension <code>c(n, 2)</code> containing angles. They all must be in <code class="reqn">[\pi,\pi)</code> so that the truncated wrapping by <code>maxK</code> windings is able to capture periodicity.</p>
</td></tr>
<tr><td><code id="dStatWn2D_+3A_alpha">alpha</code></td>
<td>
<p>vector of length <code>3</code> parametrizing the <code>A</code> matrix as in <code><a href="#topic+alphaToA">alphaToA</a></code>.</p>
</td></tr>
<tr><td><code id="dStatWn2D_+3A_mu">mu</code></td>
<td>
<p>a vector of length <code>2</code> giving the mean.</p>
</td></tr>
<tr><td><code id="dStatWn2D_+3A_sigma">sigma</code></td>
<td>
<p>vector of length <code>2</code> containing the <strong>square root</strong> of the diagonal of <code class="reqn">\Sigma</code>, the diffusion matrix.</p>
</td></tr>
<tr><td><code id="dStatWn2D_+3A_rho">rho</code></td>
<td>
<p>correlation coefficient of <code class="reqn">\Sigma</code>.</p>
</td></tr>
<tr><td><code id="dStatWn2D_+3A_maxk">maxK</code></td>
<td>
<p>maximum absolute value of the windings considered in the computation of the WN.</p>
</td></tr>
<tr><td><code id="dStatWn2D_+3A_exptrc">expTrc</code></td>
<td>
<p>truncation for exponential: <code>exp(x)</code> with <code>x &lt;= -expTrc</code> is set to zero. Defaults to <code>30</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of size <code>n</code> containing the stationary density evaluated at <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(345567)
alpha &lt;- c(2, 1, -1)
sigma &lt;- c(1.5, 2)
Sigma &lt;- diag(sigma^2)
A &lt;- alphaToA(alpha = alpha, sigma = sigma)
mu &lt;- c(pi, pi)
dStatWn2D(x = toPiInt(matrix(1:20, nrow = 10, ncol = 2)), mu = mu,
          alpha = alpha, sigma = sigma)
dTpdWou(t = 10, x = toPiInt(matrix(1:20, nrow = 10, ncol = 2)), A = A,
         mu = mu, Sigma = Sigma, x0 = mu)
xth &lt;- seq(-pi, pi, l = 100)
contour(xth, xth, matrix(dStatWn2D(x = as.matrix(expand.grid(xth, xth)),
                                   alpha = alpha, sigma = sigma, mu = mu),
                         nrow = length(xth), ncol = length(xth)), nlevels = 50)
points(rStatWn2D(n = 1000, mu = mu, alpha = alpha, sigma = sigma), col = 2)
</code></pre>

<hr>
<h2 id='dTpdMou'>Transition probability density of the multivariate OU diffusion</h2><span id='topic+dTpdMou'></span><span id='topic+meantMou'></span><span id='topic+covtMou'></span>

<h3>Description</h3>

<p>Transition probability density of the <em>multivariate</em>
Ornstein&ndash;Uhlenbeck (OU) diffusion
</p>
<p style="text-align: center;"><code class="reqn">dX_t=A(\mu - X_t)dt+\Sigma^\frac{1}{2}dW_t, X_0=x_0.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dTpdMou(x, x0, t, A, mu, Sigma, eigA = NULL, log = FALSE)

meantMou(t, x0, A, mu, eigA = NULL)

covtMou(t, A, Sigma, eigA = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dTpdMou_+3A_x">x</code></td>
<td>
<p>matrix of with <code>p</code> columns containing the evaluation points.</p>
</td></tr>
<tr><td><code id="dTpdMou_+3A_x0">x0</code></td>
<td>
<p>initial point.</p>
</td></tr>
<tr><td><code id="dTpdMou_+3A_t">t</code></td>
<td>
<p>time between observations.</p>
</td></tr>
<tr><td><code id="dTpdMou_+3A_a">A</code></td>
<td>
<p>the drift matrix, of size <code>c(p, p)</code>.</p>
</td></tr>
<tr><td><code id="dTpdMou_+3A_mu">mu</code></td>
<td>
<p>unconditional mean of the diffusion.</p>
</td></tr>
<tr><td><code id="dTpdMou_+3A_sigma">Sigma</code></td>
<td>
<p>square of the diffusion matrix, a matrix of size <code>c(p, p)</code>.</p>
</td></tr>
<tr><td><code id="dTpdMou_+3A_eiga">eigA</code></td>
<td>
<p>optional argument containing <code>eigen(A)</code> for reuse.</p>
</td></tr>
<tr><td><code id="dTpdMou_+3A_log">log</code></td>
<td>
<p>flag to indicate whether to compute the logarithm of the density.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The transition probability density is a multivariate normal with
mean <code><a href="#topic+meantMou">meantMou</a></code> and covariance <code><a href="#topic+covtMou">covtMou</a></code>. See
<code><a href="#topic+dTpdOu">dTpdOu</a></code> for the univariate case (more efficient).
</p>
<p><code>solve(A) %*% Sigma</code> has to be a covariance matrix (symmetric and
positive definite) in order to have a proper transition density. For the
bivariate case, this can be ensured with the <code><a href="#topic+alphaToA">alphaToA</a></code> function.
In the multivariate case, it is ensured if <code>Sigma</code> is isotropic and
<code>A</code> is a covariance matrix.
</p>


<h3>Value</h3>

<p>A matrix of the same size as <code>x</code> containing the evaluation of
the density.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-4, 4, by = 0.1)
xx &lt;- as.matrix(expand.grid(x, x))
isRStudio &lt;- identical(.Platform$GUI, "RStudio")
if (isRStudio) {
  manipulate::manipulate(
    image(x, x, matrix(dTpdMou(x = xx, x0 = c(1, 2), t = t,
                               A = alphaToA(alpha = c(1, 2, 0.5),
                                            sigma = 1:2),
                               mu = c(0, 0), Sigma = diag((1:2)^2)),
                       nrow = length(x), ncol = length(x)),
          zlim = c(0, 0.25)), t = manipulate::slider(0.1, 5, step = 0.1))
}
</code></pre>

<hr>
<h2 id='dTpdOu'>Transition probability density of the univariate OU diffusion</h2><span id='topic+dTpdOu'></span><span id='topic+meantOu'></span><span id='topic+vartOu'></span><span id='topic+covstOu'></span>

<h3>Description</h3>

<p>Transition probability density of the <em>univariate</em>
Ornstein&ndash;Uhlenbeck (OU) diffusion
</p>
<p style="text-align: center;"><code class="reqn">dX_t=\alpha(\mu - X_t)dt+\sigma dW_t, X_0=x_0.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>dTpdOu(x, x0, t, alpha, mu, sigma, log = FALSE)

meantOu(x0, t, alpha, mu)

vartOu(t, alpha, sigma)

covstOu(s, t, alpha, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dTpdOu_+3A_x">x</code></td>
<td>
<p>vector with the evaluation points.</p>
</td></tr>
<tr><td><code id="dTpdOu_+3A_x0">x0</code></td>
<td>
<p>initial point.</p>
</td></tr>
<tr><td><code id="dTpdOu_+3A_t">t</code>, <code id="dTpdOu_+3A_s">s</code></td>
<td>
<p>time between observations.</p>
</td></tr>
<tr><td><code id="dTpdOu_+3A_alpha">alpha</code></td>
<td>
<p>strength of the drift.</p>
</td></tr>
<tr><td><code id="dTpdOu_+3A_mu">mu</code></td>
<td>
<p>unconditional mean of the diffusion.</p>
</td></tr>
<tr><td><code id="dTpdOu_+3A_sigma">sigma</code></td>
<td>
<p>diffusion coefficient.</p>
</td></tr>
<tr><td><code id="dTpdOu_+3A_log">log</code></td>
<td>
<p>flag to indicate whether to compute the logarithm of the density.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The transition probability density is a normal density with mean
<code><a href="#topic+meantOu">meantOu</a></code> and variance <code><a href="#topic+vartOu">vartOu</a></code>. See
<code><a href="#topic+dTpdMou">dTpdMou</a></code> for the multivariate case (less efficient for
dimension one).
</p>


<h3>Value</h3>

<p>A vector of the same length as <code>x</code> containing the evaluation of
the density.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-4, 4, by = 0.01)
plot(x, dTpdOu(x = x, x0 = 3, t = 0.1, alpha = 1, mu = -1, sigma = 1),
     type = "l", ylim = c(0, 1.5), xlab = "x", ylab = "Density",
     col = rainbow(20)[1])
for (i in 2:20) {
  lines(x, dTpdOu(x = x, x0 = 3, t = i / 10, alpha = 1, mu = -1, sigma = 1),
        col = rainbow(20)[i])
}
</code></pre>

<hr>
<h2 id='dTpdPde1D'>Transition probability density in 1D by PDE solving</h2><span id='topic+dTpdPde1D'></span>

<h3>Description</h3>

<p>Computation of the transition probability density (tpd) of the
Wrapped Normal (WN) or von Mises (vM) diffusion, by solving its associated
Fokker&ndash;Planck Partial Differential Equation (PDE) in 1D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dTpdPde1D(Mx = 500, x0, t, alpha, mu, sigma, type = "WN",
  Mt = ceiling(100 * t), sdInitial = 0.1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dTpdPde1D_+3A_mx">Mx</code></td>
<td>
<p>size of the equispaced spatial grid in <code class="reqn">[-\pi,\pi)</code>.</p>
</td></tr>
<tr><td><code id="dTpdPde1D_+3A_x0">x0</code></td>
<td>
<p>point giving the mean of the initial circular density, a WN with
standard deviation equal to <code>sdInitial</code>.</p>
</td></tr>
<tr><td><code id="dTpdPde1D_+3A_t">t</code></td>
<td>
<p>time separating <code>x0</code> and the evaluation of the tpd.</p>
</td></tr>
<tr><td><code id="dTpdPde1D_+3A_alpha">alpha</code></td>
<td>
<p>drift parameter.</p>
</td></tr>
<tr><td><code id="dTpdPde1D_+3A_mu">mu</code></td>
<td>
<p>mean parameter. Must be in <code class="reqn">[\pi,\pi)</code>.</p>
</td></tr>
<tr><td><code id="dTpdPde1D_+3A_sigma">sigma</code></td>
<td>
<p>diffusion coefficient.</p>
</td></tr>
<tr><td><code id="dTpdPde1D_+3A_type">type</code></td>
<td>
<p>either <code>"WN"</code> or <code>"vM"</code>.</p>
</td></tr>
<tr><td><code id="dTpdPde1D_+3A_mt">Mt</code></td>
<td>
<p>size of the time grid in <code class="reqn">[0, t]</code>.</p>
</td></tr>
<tr><td><code id="dTpdPde1D_+3A_sdinitial">sdInitial</code></td>
<td>
<p>the standard deviation of the concentrated WN giving the
initial condition.</p>
</td></tr>
<tr><td><code id="dTpdPde1D_+3A_...">...</code></td>
<td>
<p>Further parameters passed to <code><a href="#topic+crankNicolson1D">crankNicolson1D</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A combination of small <code>sdInitial</code> and coarse space-time
discretization (small <code>Mx</code> and <code>Mt</code>) is prone to create numerical
instabilities. See Sections 3.4.1, 2.2.1 and 2.2.2 in García-Portugués et
al. (2019) for details.
</p>


<h3>Value</h3>

<p>A vector of length <code>Mx</code> with the tpd evaluated at
<code>seq(-pi, pi, l = Mx + 1)[-(Mx + 1)]</code>.
</p>


<h3>References</h3>

<p>García-Portugués, E., Sørensen, M., Mardia, K. V. and Hamelryck, T. (2019)
Langevin diffusions on the torus: estimation and applications.
<em>Statistics and Computing</em>, 29(2):1&ndash;22. <a href="https://doi.org/10.1007/s11222-017-9790-2">doi:10.1007/s11222-017-9790-2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Mx &lt;- 100
x &lt;- seq(-pi, pi, l = Mx + 1)[-c(Mx + 1)]
x0 &lt;- pi
t &lt;- 0.5
alpha &lt;- 1
mu &lt;- 0
sigma &lt;- 1
isRStudio &lt;- identical(.Platform$GUI, "RStudio")
if (isRStudio) {
  manipulate::manipulate({
  plot(x, dTpdPde1D(Mx = Mx, x0 = x0, t = t, alpha = alpha, mu = 0,
                    sigma = sigma), type = "l", ylab = "Density",
       xlab = "", ylim = c(0, 0.75))
  lines(x, dTpdWou1D(x = x, x0 = rep(x0, Mx), t = t, alpha = alpha, mu = 0,
                      sigma = sigma), col = 2)
  }, x0 = manipulate::slider(-pi, pi, step = 0.01, initial = 0),
  alpha = manipulate::slider(0.01, 5, step = 0.01, initial = 1),
  sigma = manipulate::slider(0.01, 5, step = 0.01, initial = 1),
  t = manipulate::slider(0.01, 5, step = 0.01, initial = 1))
}
</code></pre>

<hr>
<h2 id='dTpdPde2D'>Transition probability density in 2D by PDE solving</h2><span id='topic+dTpdPde2D'></span>

<h3>Description</h3>

<p>Computation of the transition probability density (tpd) of the
Wrapped Normal (WN) or Multivariate von Mises (MvM) diffusion, by solving
its associated Fokker&ndash;Planck Partial Differential Equation (PDE) in 2D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dTpdPde2D(Mx = 50, My = 50, x0, t, alpha, mu, sigma, rho = 0,
  type = "WN", Mt = ceiling(100 * t), sdInitial = 0.1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dTpdPde2D_+3A_mx">Mx</code>, <code id="dTpdPde2D_+3A_my">My</code></td>
<td>
<p>sizes of the equispaced spatial grids in <code class="reqn">[-\pi,\pi)</code> for each component.</p>
</td></tr>
<tr><td><code id="dTpdPde2D_+3A_x0">x0</code></td>
<td>
<p>point giving the mean of the initial circular density, an
isotropic WN with standard deviations equal to <code>sdInitial</code>.</p>
</td></tr>
<tr><td><code id="dTpdPde2D_+3A_t">t</code></td>
<td>
<p>time separating <code>x0</code> and the evaluation of the tpd.</p>
</td></tr>
<tr><td><code id="dTpdPde2D_+3A_alpha">alpha</code></td>
<td>
<p>for <code>"WN"</code>, a vector of length <code>3</code> parametrizing
the <code>A</code> matrix as in <code><a href="#topic+alphaToA">alphaToA</a></code>. For <code>"vM"</code>, a vector
of length <code>3</code> containing <code>c(alpha[1:2], A[1, 2])</code>, from the
arguments <code>alpha</code> and <code>A</code> in <code><a href="#topic+driftMvm">driftMvm</a></code>.</p>
</td></tr>
<tr><td><code id="dTpdPde2D_+3A_mu">mu</code></td>
<td>
<p>vector of length <code>2</code> giving the mean.</p>
</td></tr>
<tr><td><code id="dTpdPde2D_+3A_sigma">sigma</code></td>
<td>
<p>for <code>"WN"</code>, a vector of length <code>2</code> containing the
<strong>square root</strong> of the diagonal of the diffusion matrix. For
<code>"vM"</code>, the standard deviation giving the isotropic diffusion matrix.</p>
</td></tr>
<tr><td><code id="dTpdPde2D_+3A_rho">rho</code></td>
<td>
<p>for <code>"WN"</code>, the correlation of the diffusion matrix.</p>
</td></tr>
<tr><td><code id="dTpdPde2D_+3A_type">type</code></td>
<td>
<p>either <code>"WN"</code> or <code>"vM"</code>.</p>
</td></tr>
<tr><td><code id="dTpdPde2D_+3A_mt">Mt</code></td>
<td>
<p>size of the time grid in <code class="reqn">[0, t]</code>.</p>
</td></tr>
<tr><td><code id="dTpdPde2D_+3A_sdinitial">sdInitial</code></td>
<td>
<p>standard deviations of the concentrated WN giving the
initial condition.</p>
</td></tr>
<tr><td><code id="dTpdPde2D_+3A_...">...</code></td>
<td>
<p>Further parameters passed to <code><a href="#topic+crankNicolson2D">crankNicolson2D</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A combination of small <code>sdInitial</code> and coarse space-time
discretization (small <code>Mx</code> and <code>Mt</code>) is prone to create numerical
instabilities. See Sections 3.4.2, 2.2.1 and 2.2.2 in García-Portugués et al.
(2019) for details.
</p>


<h3>Value</h3>

<p>A matrix of size <code>c(Mx, My)</code> with the tpd evaluated at the
combinations of <code>seq(-pi, pi, l = Mx + 1)[-(Mx + 1)]</code> and
<code>seq(-pi, pi, l = My + 1)[-(My + 1)]</code>.
</p>


<h3>References</h3>

<p>García-Portugués, E., Sørensen, M., Mardia, K. V. and Hamelryck, T. (2019)
Langevin diffusions on the torus: estimation and applications.
<em>Statistics and Computing</em>, 29(2):1&ndash;22. <a href="https://doi.org/10.1007/s11222-017-9790-2">doi:10.1007/s11222-017-9790-2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- 100
x &lt;- seq(-pi, pi, l = M + 1)[-c(M + 1)]
image(x, x, dTpdPde2D(Mx = M, My = M, x0 = c(0, pi), t = 1,
                      alpha = c(1, 1, 0.5), mu = c(pi / 2, 0), sigma = 1:2),
      zlim = c(0, 0.25), col = matlab.like.colorRamps(20),
      xlab = "x", ylab = "y")
</code></pre>

<hr>
<h2 id='dTpdWou'>Conditional probability density of the WOU process</h2><span id='topic+dTpdWou'></span>

<h3>Description</h3>

<p>Conditional probability density of the Wrapped
Ornstein&ndash;Uhlenbeck (WOU) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dTpdWou(x, t, A, mu, Sigma, x0, maxK = 2, eigA = NULL, invASigma = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dTpdWou_+3A_x">x</code></td>
<td>
<p>matrix of size <code>c(n, p)</code> with the evaluation points in
<code class="reqn">[-\pi,\pi)^p</code>.</p>
</td></tr>
<tr><td><code id="dTpdWou_+3A_t">t</code></td>
<td>
<p>a scalar containing the times separating <code>x</code> and <code>x0</code>.</p>
</td></tr>
<tr><td><code id="dTpdWou_+3A_a">A</code></td>
<td>
<p>matrix of size <code>c(p, p)</code> giving the drift strength.</p>
</td></tr>
<tr><td><code id="dTpdWou_+3A_mu">mu</code></td>
<td>
<p>mean parameter. Must be in <code class="reqn">[\pi,\pi)</code>.</p>
</td></tr>
<tr><td><code id="dTpdWou_+3A_sigma">Sigma</code></td>
<td>
<p>diffusion matrix, of size <code>c(p, p)</code>.</p>
</td></tr>
<tr><td><code id="dTpdWou_+3A_x0">x0</code></td>
<td>
<p>vector of length <code>p</code> with the initial point in
<code class="reqn">[-\pi,\pi)^p</code>.</p>
</td></tr>
<tr><td><code id="dTpdWou_+3A_maxk">maxK</code></td>
<td>
<p>maximum absolute value of the windings considered in the computation of the WN.</p>
</td></tr>
<tr><td><code id="dTpdWou_+3A_eiga">eigA</code></td>
<td>
<p>optional argument containing <code>eigen(A)</code> for reuse.</p>
</td></tr>
<tr><td><code id="dTpdWou_+3A_invasigma">invASigma</code></td>
<td>
<p>the matrix <code>solve(Sigma) %*% A</code> (optional).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Section 3.3 in García-Portugués et al. (2019) for details.
<code><a href="#topic+dTpdWou1D">dTpdWou1D</a></code> and <code><a href="#topic+dTpdWou2D">dTpdWou2D</a></code> are more efficient
implementations for the 1D and 2D cases, respectively.
</p>


<h3>Value</h3>

<p>A vector of length <code>n</code> with the density evaluated at <code>x</code>.
</p>


<h3>References</h3>

<p>García-Portugués, E., Sørensen, M., Mardia, K. V. and Hamelryck, T. (2019)
Langevin diffusions on the torus: estimation and applications.
<em>Statistics and Computing</em>, 29(2):1&ndash;22. <a href="https://doi.org/10.1007/s11222-017-9790-2">doi:10.1007/s11222-017-9790-2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1D
t &lt;- 0.5
alpha &lt;- 1
mu &lt;- 0
sigma &lt;- 1
x0 &lt;- pi
x &lt;- seq(-pi, pi, l = 10)
dTpdWou(x = cbind(x), x0 = x0, t = t, A = alpha, mu = 0, Sigma = sigma^2) -
dTpdWou1D(x = cbind(x), x0 = rep(x0, 10), t = t, alpha = alpha, mu = 0,
          sigma = sigma)

# 2D
t &lt;- 0.5
alpha &lt;- c(2, 1, -1)
sigma &lt;- c(1.5, 2)
rho &lt;- 0.9
Sigma &lt;- diag(sigma^2)
Sigma[1, 2] &lt;- Sigma[2, 1] &lt;- rho * prod(sigma)
A &lt;- alphaToA(alpha = alpha, sigma = sigma, rho = rho)
mu &lt;- c(pi, 0)
x0 &lt;- c(0, 0)
x &lt;- seq(-pi, pi, l = 5)
x &lt;- as.matrix(expand.grid(x, x))
dTpdWou(x = x, x0 = x0, t = t, A = A, mu = mu, Sigma = Sigma) -
dTpdWou2D(x = x, x0 = rbind(x0), t = t, alpha = alpha, mu = mu,
          sigma = sigma, rho = rho)
</code></pre>

<hr>
<h2 id='dTpdWou1D'>Approximation of the transition probability density of the WN diffusion in 1D</h2><span id='topic+dTpdWou1D'></span>

<h3>Description</h3>

<p>Computation of the transition probability density (tpd) for a WN diffusion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dTpdWou1D(x, x0, t, alpha, mu, sigma, maxK = 2L, expTrc = 30,
  vmApprox = 0L, kt = 0, logConstKt = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dTpdWou1D_+3A_x">x</code></td>
<td>
<p>a vector of length <code>n</code> containing angles. They all must be in <code class="reqn">[\pi,\pi)</code> so that the truncated wrapping by <code>maxK</code> windings is able to capture periodicity.</p>
</td></tr>
<tr><td><code id="dTpdWou1D_+3A_x0">x0</code></td>
<td>
<p>a vector of length <code>n</code> containing the starting angles. They all must be in <code class="reqn">[\pi,\pi)</code>.</p>
</td></tr>
<tr><td><code id="dTpdWou1D_+3A_t">t</code></td>
<td>
<p>a scalar containing the times separating <code>x</code> and <code>x0</code>.</p>
</td></tr>
<tr><td><code id="dTpdWou1D_+3A_alpha">alpha</code></td>
<td>
<p>drift parameter.</p>
</td></tr>
<tr><td><code id="dTpdWou1D_+3A_mu">mu</code></td>
<td>
<p>mean parameter. Must be in <code class="reqn">[\pi,\pi)</code>.</p>
</td></tr>
<tr><td><code id="dTpdWou1D_+3A_sigma">sigma</code></td>
<td>
<p>diffusion coefficient.</p>
</td></tr>
<tr><td><code id="dTpdWou1D_+3A_maxk">maxK</code></td>
<td>
<p>maximum absolute value of the windings considered in the computation of the WN.</p>
</td></tr>
<tr><td><code id="dTpdWou1D_+3A_exptrc">expTrc</code></td>
<td>
<p>truncation for exponential: <code>exp(x)</code> with <code>x &lt;= -expTrc</code> is set to zero. Defaults to <code>30</code>.</p>
</td></tr>
<tr><td><code id="dTpdWou1D_+3A_vmapprox">vmApprox</code></td>
<td>
<p>whether to use the von Mises approximation to a wrapped normal (<code>1</code>) or not (<code>0</code>, default).</p>
</td></tr>
<tr><td><code id="dTpdWou1D_+3A_kt">kt</code></td>
<td>
<p>concentration for the von Mises, a suitable output from <code><a href="#topic+momentMatchWnVm">momentMatchWnVm</a></code> (see examples).</p>
</td></tr>
<tr><td><code id="dTpdWou1D_+3A_logconstkt">logConstKt</code></td>
<td>
<p>the logarithm of the von Mises normalizing constant associated to the concentration <code>kt</code> (see examples)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Section 3.3 in García-Portugués et al. (2019) for details. See <code><a href="#topic+dTpdWou">dTpdWou</a></code> for the general case (less efficient for 2D).
</p>


<h3>Value</h3>

<p>A vector of size <code>n</code> containing the tpd evaluated at <code>x</code>.
</p>


<h3>References</h3>

<p>García-Portugués, E., Sørensen, M., Mardia, K. V. and Hamelryck, T. (2019) Langevin diffusions on the torus: estimation and applications. <em>Statistics and Computing</em>, 29(2):1&ndash;22. <a href="https://doi.org/10.1007/s11222-017-9790-2">doi:10.1007/s11222-017-9790-2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- 0.5
alpha &lt;- 1
mu &lt;- 0
sigma &lt;- 1
x0 &lt;- 0.1
dTpdWou1D(x = seq(-pi, pi, l = 10), x0 = rep(x0, 10), t = t, alpha = alpha,
          mu = mu, sigma = sigma, vmApprox = 0)

# von Mises approximation
kt &lt;- scoreMatchWnVm(sigma2 = sigma^2 * (1 - exp(-2 * alpha * t)) / (2 * alpha))
dTpdWou1D(x = seq(-pi, pi, l = 10), x0 = rep(x0, 10), t = t, alpha = alpha,
          mu = mu, sigma = sigma, vmApprox = 1, kt = kt,
          logConstKt = -log(2 * pi * besselI(x = kt, nu = 0,
                                             expon.scaled = TRUE)))
</code></pre>

<hr>
<h2 id='dTpdWou2D'>Approximation of the transition probability density of the WN diffusion in 2D</h2><span id='topic+dTpdWou2D'></span>

<h3>Description</h3>

<p>Computation of the transition probability density (tpd) for a WN diffusion (with diagonal diffusion matrix)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dTpdWou2D(x, x0, t, alpha, mu, sigma, rho = 0, maxK = 2L, expTrc = 30)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dTpdWou2D_+3A_x">x</code></td>
<td>
<p>a matrix of dimension <code>c(n, 2)</code> containing angles. They all must be in <code class="reqn">[\pi,\pi)</code> so that the truncated wrapping by <code>maxK</code> windings is able to capture periodicity.</p>
</td></tr>
<tr><td><code id="dTpdWou2D_+3A_x0">x0</code></td>
<td>
<p>a matrix of dimension <code>c(n, 2)</code> containing the starting angles. They all must be in <code class="reqn">[\pi,\pi)</code>. If all <code>x0</code> are the same, a matrix of dimension <code>c(1, 2)</code> can be passed for better performance.</p>
</td></tr>
<tr><td><code id="dTpdWou2D_+3A_t">t</code></td>
<td>
<p>a scalar containing the times separating <code>x</code> and <code>x0</code>.</p>
</td></tr>
<tr><td><code id="dTpdWou2D_+3A_alpha">alpha</code></td>
<td>
<p>vector of length <code>3</code> parametrizing the <code>A</code> matrix as in <code><a href="#topic+alphaToA">alphaToA</a></code>.</p>
</td></tr>
<tr><td><code id="dTpdWou2D_+3A_mu">mu</code></td>
<td>
<p>a vector of length <code>2</code> giving the mean.</p>
</td></tr>
<tr><td><code id="dTpdWou2D_+3A_sigma">sigma</code></td>
<td>
<p>vector of length <code>2</code> containing the <strong>square root</strong> of the diagonal of <code class="reqn">\Sigma</code>, the diffusion matrix.</p>
</td></tr>
<tr><td><code id="dTpdWou2D_+3A_rho">rho</code></td>
<td>
<p>correlation coefficient of <code class="reqn">\Sigma</code>.</p>
</td></tr>
<tr><td><code id="dTpdWou2D_+3A_maxk">maxK</code></td>
<td>
<p>maximum absolute value of the windings considered in the computation of the WN.</p>
</td></tr>
<tr><td><code id="dTpdWou2D_+3A_exptrc">expTrc</code></td>
<td>
<p>truncation for exponential: <code>exp(x)</code> with <code>x &lt;= -expTrc</code> is set to zero. Defaults to <code>30</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function checks for positive definiteness. If violated, it resets <code>A</code> such that <code>solve(A) %*% Sigma</code> is positive definite.
</p>
<p>See Section 3.3 in García-Portugués et al. (2019) for details. See <code><a href="#topic+dTpdWou">dTpdWou</a></code> for the general case (less efficient for 1D).
</p>


<h3>Value</h3>

<p>A vector of size <code>n</code> containing the tpd evaluated at <code>x</code>.
</p>


<h3>References</h3>

<p>García-Portugués, E., Sørensen, M., Mardia, K. V. and Hamelryck, T. (2019) Langevin diffusions on the torus: estimation and applications. <em>Statistics and Computing</em>, 29(2):1&ndash;22. <a href="https://doi.org/10.1007/s11222-017-9790-2">doi:10.1007/s11222-017-9790-2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(3455267)
alpha &lt;- c(2, 1, -1)
sigma &lt;- c(1.5, 2)
rho &lt;- 0.9
Sigma &lt;- diag(sigma^2)
Sigma[1, 2] &lt;- Sigma[2, 1] &lt;- rho * prod(sigma)
A &lt;- alphaToA(alpha = alpha, sigma = sigma, rho = rho)
solve(A) %*% Sigma
mu &lt;- c(pi, 0)
x &lt;- t(euler2D(x0 = matrix(c(0, 0), nrow = 1), A = A, mu = mu,
               sigma = sigma, N = 500, delta = 0.1)[1, , ])

sum(sapply(1:49, function(i) log(dTpdWou(x = matrix(x[i + 1, ], ncol = 2),
                                         x0 = x[i, ], t = 1.5, A = A,
                                         Sigma = Sigma, mu = mu))))

sum(log(dTpdWou2D(x = matrix(x[2:50, ], ncol = 2),
                  x0 = matrix(x[1:49, ], ncol = 2), t = 1.5, alpha = alpha,
                  mu = mu, sigma = sigma, rho = rho)))

lgrid &lt;- 56
grid &lt;- seq(-pi, pi, l = lgrid + 1)[-(lgrid + 1)]
image(grid, grid, matrix(dTpdWou(x = as.matrix(expand.grid(grid, grid)),
                                 x0 = c(0, 0), t = 0.5, A = A,
                                 Sigma = Sigma, mu = mu),
                         nrow = 56, ncol = 56), zlim = c(0, 0.25),
      main = "dTpdWou")
image(grid, grid, matrix(dTpdWou2D(x = as.matrix(expand.grid(grid, grid)),
                                   x0 = matrix(0, nrow = 56^2, ncol = 2),
                                   t = 0.5, alpha = alpha, sigma = sigma,
                                   mu = mu),
                         nrow = 56, ncol = 56), zlim = c(0, 0.25),
      main = "dTpdWou2D")

x &lt;- seq(-pi, pi, l = 100)
t &lt;- 1
image(x, x, matrix(dTpdWou2D(x = as.matrix(expand.grid(x, x)),
                             x0 = matrix(rep(0, 100 * 2), nrow = 100 * 100,
                                         ncol = 2),
                             t = t, alpha = alpha, mu = mu, sigma = sigma,
                             maxK = 2, expTrc = 30),
                             nrow = 100, ncol = 100),
      zlim = c(0, 0.25))
points(stepAheadWn2D(x0 = rbind(c(0, 0)), delta = t / 500,
                     A = alphaToA(alpha = alpha, sigma = sigma), mu = mu,
                     sigma = sigma, N = 500, M = 1000, maxK = 2,
                     expTrc = 30))

</code></pre>

<hr>
<h2 id='dTvm'>Mixtures of toroidal von Mises densities</h2><span id='topic+dTvm'></span><span id='topic+emTvm'></span>

<h3>Description</h3>

<p>Undocumented functions implementing mixtures of independent
von Mises densities on the torus and their estimation by an
Expectation-Maximization algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dTvm(x, M, K, alpha = NULL, besselInterp = FALSE)

emTvm(data, k, M = NULL, K = NULL, alpha = NULL, tol = c(0.001, 0.001,
  0.001/k), kappaMax = 500, maxIter = 100, isotropic = FALSE,
  besselInterp = FALSE, verbose = 0)
</code></pre>

<hr>
<h2 id='dVm'>Density of the von Mises</h2><span id='topic+dVm'></span>

<h3>Description</h3>

<p>Computes the density of a von Mises in a numerically stable way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dVm(x, mu, kappa)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dVm_+3A_x">x</code></td>
<td>
<p>evaluation angles, not necessary in <code class="reqn">[\pi,\pi)</code>.</p>
</td></tr>
<tr><td><code id="dVm_+3A_mu">mu</code></td>
<td>
<p>circular mean.</p>
</td></tr>
<tr><td><code id="dVm_+3A_kappa">kappa</code></td>
<td>
<p>non-negative concentration parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as <code>x</code> containing the density.
</p>


<h3>References</h3>

<p>Jammalamadaka, S. R. and SenGupta, A. (2001) <em>Topics in Circular
Statistics</em>. World Scientific, Singapore. <a href="https://doi.org/10.1142/4031">doi:10.1142/4031</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-pi, pi, l = 200)
plot(x, x, type = "n", ylab = "Density", ylim = c(0, 1))
for (i in 0:20) {
  lines(x, dVm(x = x, mu = 0, kappa = 5 * i / 20),
        col = rainbow(21)[i + 1])
}
</code></pre>

<hr>
<h2 id='dWn1D'>WN density in 1D</h2><span id='topic+dWn1D'></span>

<h3>Description</h3>

<p>Computation of the WN density in 1D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dWn1D(x, mu, sigma, maxK = 2L, expTrc = 30, vmApprox = 0L, kt = 0,
  logConstKt = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dWn1D_+3A_x">x</code></td>
<td>
<p>a vector of length <code>n</code> containing angles. They all must be in <code class="reqn">[\pi,\pi)</code> so that the truncated wrapping by <code>maxK</code> windings is able to capture periodicity.</p>
</td></tr>
<tr><td><code id="dWn1D_+3A_mu">mu</code></td>
<td>
<p>mean parameter. Must be in <code class="reqn">[\pi,\pi)</code>.</p>
</td></tr>
<tr><td><code id="dWn1D_+3A_sigma">sigma</code></td>
<td>
<p>diffusion coefficient.</p>
</td></tr>
<tr><td><code id="dWn1D_+3A_maxk">maxK</code></td>
<td>
<p>maximum absolute value of the windings considered in the computation of the WN.</p>
</td></tr>
<tr><td><code id="dWn1D_+3A_exptrc">expTrc</code></td>
<td>
<p>truncation for exponential: <code>exp(x)</code> with <code>x &lt;= -expTrc</code> is set to zero. Defaults to <code>30</code>.</p>
</td></tr>
<tr><td><code id="dWn1D_+3A_vmapprox">vmApprox</code></td>
<td>
<p>whether to use the von Mises approximation to a wrapped normal (<code>1</code>) or not (<code>0</code>, default).</p>
</td></tr>
<tr><td><code id="dWn1D_+3A_kt">kt</code></td>
<td>
<p>concentration for the von Mises, a suitable output from <code><a href="#topic+momentMatchWnVm">momentMatchWnVm</a></code> (see examples).</p>
</td></tr>
<tr><td><code id="dWn1D_+3A_logconstkt">logConstKt</code></td>
<td>
<p>the logarithm of the von Mises normalizing constant associated to the concentration <code>kt</code> (see examples)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of size <code>n</code> containing the density evaluated at <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- 0
sigma &lt;- 1
dWn1D(x = seq(-pi, pi, l = 10), mu = mu, sigma = sigma, vmApprox = 0)

# von Mises approximation
kt &lt;- scoreMatchWnVm(sigma2 = sigma^2)
dWn1D(x = seq(-pi, pi, l = 10), mu = mu, sigma = sigma, vmApprox = 1, kt = kt,
      logConstKt = -log(2 * pi * besselI(x = kt, nu = 0, expon.scaled = TRUE)))
</code></pre>

<hr>
<h2 id='euler1D'>Simulation of trajectories of the WN or vM diffusion in 1D</h2><span id='topic+euler1D'></span>

<h3>Description</h3>

<p>Simulation of the Wrapped Normal (WN) diffusion or von Mises (vM) diffusion by the Euler method in 1D, for several starting values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euler1D(x0, alpha, mu, sigma, N = 100L, delta = 0.01, type = 1L,
  maxK = 2L, expTrc = 30)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="euler1D_+3A_x0">x0</code></td>
<td>
<p>vector of length <code>nx0</code> giving the initial points.</p>
</td></tr>
<tr><td><code id="euler1D_+3A_alpha">alpha</code></td>
<td>
<p>drift parameter.</p>
</td></tr>
<tr><td><code id="euler1D_+3A_mu">mu</code></td>
<td>
<p>mean parameter. Must be in <code class="reqn">[\pi,\pi)</code>.</p>
</td></tr>
<tr><td><code id="euler1D_+3A_sigma">sigma</code></td>
<td>
<p>diffusion coefficient.</p>
</td></tr>
<tr><td><code id="euler1D_+3A_n">N</code></td>
<td>
<p>number of discretization steps.</p>
</td></tr>
<tr><td><code id="euler1D_+3A_delta">delta</code></td>
<td>
<p>discretization step.</p>
</td></tr>
<tr><td><code id="euler1D_+3A_type">type</code></td>
<td>
<p>integer giving the type of diffusion. Currently, only <code>1</code> for WN and <code>2</code> for vM are supported.</p>
</td></tr>
<tr><td><code id="euler1D_+3A_maxk">maxK</code></td>
<td>
<p>maximum absolute value of the windings considered in the computation of the WN.</p>
</td></tr>
<tr><td><code id="euler1D_+3A_exptrc">expTrc</code></td>
<td>
<p>truncation for exponential: <code>exp(x)</code> with <code>x &lt;= -expTrc</code> is set to zero. Defaults to <code>30</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size <code>c(nx0, N + 1)</code> containing the <code>nx0</code> discretized trajectories. The first column corresponds to the vector <code>x0</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100
nx0 &lt;- 20
x0 &lt;- seq(-pi, pi, l = nx0 + 1)[-(nx0 + 1)]
set.seed(12345678)
samp &lt;- euler1D(x0 = x0, mu = 0, alpha = 3, sigma = 1, N = N,
                delta = 0.01, type = 2)
tt &lt;- seq(0, 1, l = N + 1)
plot(rep(0, nx0), x0, pch = 16, col = rainbow(nx0), xlim = c(0, 1))
for (i in 1:nx0) linesCirc(tt, samp[i, ], col = rainbow(nx0)[i])
</code></pre>

<hr>
<h2 id='euler2D'>Simulation of trajectories of the WN or MvM diffusion in 2D</h2><span id='topic+euler2D'></span>

<h3>Description</h3>

<p>Simulation of the Wrapped Normal (WN) diffusion or Multivariate von Mises (MvM) diffusion by the Euler method in 2D, for several starting values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euler2D(x0, A, mu, sigma, rho = 0, N = 100L, delta = 0.01, type = 1L,
  maxK = 2L, expTrc = 30)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="euler2D_+3A_x0">x0</code></td>
<td>
<p>matrix of size <code>c(nx0, 2)</code> giving the initial points.</p>
</td></tr>
<tr><td><code id="euler2D_+3A_a">A</code></td>
<td>
<p>drift matrix of size <code>c(2, 2)</code>.</p>
</td></tr>
<tr><td><code id="euler2D_+3A_mu">mu</code></td>
<td>
<p>a vector of length <code>2</code> giving the mean.</p>
</td></tr>
<tr><td><code id="euler2D_+3A_sigma">sigma</code></td>
<td>
<p>vector of length <code>2</code> containing the <strong>square root</strong> of the diagonal of <code class="reqn">\Sigma</code>, the diffusion matrix.</p>
</td></tr>
<tr><td><code id="euler2D_+3A_rho">rho</code></td>
<td>
<p>correlation coefficient of <code class="reqn">\Sigma</code>.</p>
</td></tr>
<tr><td><code id="euler2D_+3A_n">N</code></td>
<td>
<p>number of discretization steps.</p>
</td></tr>
<tr><td><code id="euler2D_+3A_delta">delta</code></td>
<td>
<p>discretization step.</p>
</td></tr>
<tr><td><code id="euler2D_+3A_type">type</code></td>
<td>
<p>integer giving the type of diffusion. Currently, only <code>1</code> for WN and <code>2</code> for vM are supported.</p>
</td></tr>
<tr><td><code id="euler2D_+3A_maxk">maxK</code></td>
<td>
<p>maximum absolute value of the windings considered in the computation of the WN.</p>
</td></tr>
<tr><td><code id="euler2D_+3A_exptrc">expTrc</code></td>
<td>
<p>truncation for exponential: <code>exp(x)</code> with <code>x &lt;= -expTrc</code> is set to zero. Defaults to <code>30</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of size <code>c(nx0, 2, N + 1)</code> containing the <code>nx0</code> discretized trajectories. The first slice corresponds to the matrix <code>x0</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100
nx0 &lt;- 5
x0 &lt;- seq(-pi, pi, l = nx0 + 1)[-(nx0 + 1)]
x0 &lt;- as.matrix(expand.grid(x0, x0))
nx0 &lt;- nx0^2
set.seed(12345678)
samp &lt;- euler2D(x0 = x0, mu = c(0, 0), A = rbind(c(3, 1), 1:2),
                sigma = c(1, 1), N = N, delta = 0.01, type = 2)
plot(x0[, 1], x0[, 2], xlim = c(-pi, pi), ylim = c(-pi, pi), pch = 16,
     col = rainbow(nx0))
for (i in 1:nx0) linesTorus(samp[i, 1, ], samp[i, 2, ],
                           col = rainbow(nx0, alpha = 0.5)[i])
</code></pre>

<hr>
<h2 id='kIndex'>Utilities for conversion between row-column indexing and linear
indexing of matrices</h2><span id='topic+kIndex'></span><span id='topic+ijIndex'></span><span id='topic+kColToRow'></span><span id='topic+kRowToCol'></span>

<h3>Description</h3>

<p>Conversions between <code>cbind(i, j)</code> and <code>k</code> such that
<code>A[i, j] == A[k]</code> for a matrix <code>A</code>. Either column or row
ordering can be specified for the linear indexing, and also direct
conversions between both types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kIndex(i, j, nr, nc, byRows = FALSE)

ijIndex(k, nr, nc, byRows = FALSE)

kColToRow(k, nr, nc)

kRowToCol(k, nr, nc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kIndex_+3A_i">i</code></td>
<td>
<p>row index.</p>
</td></tr>
<tr><td><code id="kIndex_+3A_j">j</code></td>
<td>
<p>column index.</p>
</td></tr>
<tr><td><code id="kIndex_+3A_nr">nr</code></td>
<td>
<p>number of rows.</p>
</td></tr>
<tr><td><code id="kIndex_+3A_nc">nc</code></td>
<td>
<p>number of columns.</p>
</td></tr>
<tr><td><code id="kIndex_+3A_byrows">byRows</code></td>
<td>
<p>whether to use row-ordering instead of the default
column-ordering.</p>
</td></tr>
<tr><td><code id="kIndex_+3A_k">k</code></td>
<td>
<p>linear indexes for column-stacking or row-stacking ordering (if
<code>byRows = TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the function:
</p>

<ul>
<li> <p><code>kIndex</code>: a vector of length <code>nr * nc</code> with the linear
indexes for <code>A</code>.
</p>
</li>
<li> <p><code>ijIndex</code>: a matrix of dimension <code>c(length(k), 2)</code> giving
<code>cbind(i, j)</code>.
</p>
</li>
<li> <p><code>kColToRow</code> and <code>kRowToCol</code>: a vector of length
<code>nr * nc</code> giving the permuting indexes to change the ordering of the
linear indexes.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Indexes of a 3 x 5 matrix
ij &lt;- expand.grid(i = 1:3, j = 1:5)
kCols &lt;- kIndex(i = ij[, 1], j = ij[, 2], nr = 3, nc = 5)
kRows &lt;- kIndex(i = ij[, 1], j = ij[, 2], nr = 3, nc = 5, byRows = TRUE)

# Checks
ijIndex(kCols, nr = 3, nc = 5)
ij
ijIndex(kRows, nr = 3, nc = 5, byRows = TRUE)
ij

# Change column to row (and viceversa) ordering in the linear indexes
matrix(1:10, nr = 2, nc = 5)
kColToRow(1:10, nr = 2, nc = 5)
kRowToCol(kColToRow(1:10, nr = 2, nc = 5), nr = 2, nc = 5)
</code></pre>

<hr>
<h2 id='linesCirc'>Lines and arrows with vertical wrapping</h2><span id='topic+linesCirc'></span>

<h3>Description</h3>

<p>Joins the corresponding points with line segments or arrows that
exhibit wrapping in <code class="reqn">[-\pi,\pi)</code> in the vertical axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linesCirc(x = seq_along(y), y, col = 1, lty = 1, ltyCross = lty,
  arrows = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linesCirc_+3A_x">x</code></td>
<td>
<p>vector with horizontal coordinates.</p>
</td></tr>
<tr><td><code id="linesCirc_+3A_y">y</code></td>
<td>
<p>vector with vertical coordinates, wrapped in <code class="reqn">[-\pi,\pi)</code>.</p>
</td></tr>
<tr><td><code id="linesCirc_+3A_col">col</code></td>
<td>
<p>color vector of length <code>1</code> or the same length of <code>x</code> and
<code>y</code>.</p>
</td></tr>
<tr><td><code id="linesCirc_+3A_lty">lty</code></td>
<td>
<p>line type as in <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="linesCirc_+3A_ltycross">ltyCross</code></td>
<td>
<p>specific line type for crossing segments.</p>
</td></tr>
<tr><td><code id="linesCirc_+3A_arrows">arrows</code></td>
<td>
<p>flag for drawing arrows instead of line segments.</p>
</td></tr>
<tr><td><code id="linesCirc_+3A_...">...</code></td>
<td>
<p>further graphical parameters passed to
<code><a href="graphics.html#topic+segments">segments</a></code> or <code><a href="graphics.html#topic+arrows">arrows</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>y</code> is wrapped to <code class="reqn">[-\pi,\pi)</code> before plotting.
</p>


<h3>Value</h3>

<p>Nothing. The functions are called for drawing wrapped lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:100
y &lt;- toPiInt(pi * cos(2 * pi * x / 100) + 0.5 * runif(50, -pi, pi))
plot(x, y, ylim = c(-pi, pi))
linesCirc(x = x, y = y, col = rainbow(length(x)), ltyCross = 2)
plot(x, y, ylim = c(-pi, pi))
linesCirc(x = x, y = y, col = rainbow(length(x)), arrows = TRUE)
</code></pre>

<hr>
<h2 id='linesTorus'>Lines and arrows with wrapping in the torus</h2><span id='topic+linesTorus'></span>

<h3>Description</h3>

<p>Joins the corresponding points with line segments or arrows that
exhibit wrapping in <code class="reqn">[-\pi,\pi)</code> in the horizontal and vertical axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linesTorus(x, y, col = 1, lty = 1, ltyCross = lty, arrows = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linesTorus_+3A_x">x</code></td>
<td>
<p>vector with horizontal coordinates, wrapped in <code class="reqn">[-\pi,\pi)</code>.</p>
</td></tr>
<tr><td><code id="linesTorus_+3A_y">y</code></td>
<td>
<p>vector with vertical coordinates, wrapped in <code class="reqn">[-\pi,\pi)</code>.</p>
</td></tr>
<tr><td><code id="linesTorus_+3A_col">col</code></td>
<td>
<p>color vector of length <code>1</code> or the same length of <code>x</code> and
<code>y</code>.</p>
</td></tr>
<tr><td><code id="linesTorus_+3A_lty">lty</code></td>
<td>
<p>line type as in <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="linesTorus_+3A_ltycross">ltyCross</code></td>
<td>
<p>specific line type for crossing segments.</p>
</td></tr>
<tr><td><code id="linesTorus_+3A_arrows">arrows</code></td>
<td>
<p>flag for drawing arrows instead of line segments.</p>
</td></tr>
<tr><td><code id="linesTorus_+3A_...">...</code></td>
<td>
<p>further graphical parameters passed to
<code><a href="graphics.html#topic+segments">segments</a></code> or <code><a href="graphics.html#topic+arrows">arrows</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code> and <code>y</code> are wrapped to <code class="reqn">[-\pi,\pi)</code> before
plotting.
</p>


<h3>Value</h3>

<p>Nothing. The functions are called for drawing wrapped lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- toPiInt(rnorm(50, mean = seq(-pi, pi, l = 50), sd = 0.5))
y &lt;- toPiInt(x + rnorm(50, mean = seq(-pi, pi, l = 50), sd = 0.5))
plot(x, y, xlim = c(-pi, pi), ylim = c(-pi, pi), col = rainbow(length(x)),
     pch = 19)
linesTorus(x = x, y = y, col = rainbow(length(x)), ltyCross = 2)
plot(x, y, xlim = c(-pi, pi), ylim = c(-pi, pi), col = rainbow(length(x)),
     pch = 19)
linesTorus(x = x, y = y, col = rainbow(length(x)), arrows = TRUE)
</code></pre>

<hr>
<h2 id='linesTorus3d'>Lines and arrows with wrapping in the torus</h2><span id='topic+linesTorus3d'></span>

<h3>Description</h3>

<p>Joins the corresponding points with line segments or arrows that
exhibit wrapping in <code class="reqn">[-\pi,\pi)</code> in the horizontal and vertical axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linesTorus3d(x, y, z, col = 1, arrows = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linesTorus3d_+3A_x">x</code>, <code id="linesTorus3d_+3A_y">y</code></td>
<td>
<p>vectors with horizontal coordinates, wrapped in <code class="reqn">[-\pi,\pi)</code>.</p>
</td></tr>
<tr><td><code id="linesTorus3d_+3A_z">z</code></td>
<td>
<p>vector with vertical coordinates, wrapped in <code class="reqn">[-\pi,\pi)</code>.</p>
</td></tr>
<tr><td><code id="linesTorus3d_+3A_col">col</code></td>
<td>
<p>color vector of length <code>1</code> or the same length of <code>x</code>,
<code>y</code>, and <code>z</code>.</p>
</td></tr>
<tr><td><code id="linesTorus3d_+3A_arrows">arrows</code></td>
<td>
<p>flag for drawing arrows instead of line segments.</p>
</td></tr>
<tr><td><code id="linesTorus3d_+3A_...">...</code></td>
<td>
<p>further graphical parameters passed to
<code><a href="graphics.html#topic+segments">segments</a></code> or <code><a href="graphics.html#topic+arrows">arrows</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code>, <code>y</code>, and <code>z</code> are wrapped to <code class="reqn">[-\pi,\pi)</code>
before plotting. <code>arrows = TRUE</code> makes sequential calls to
<code><a href="rgl.html#topic+arrow3d">arrow3d</a></code>, and is substantially slower than
<code>arrows = FALSE</code>.
</p>


<h3>Value</h3>

<p>Nothing. The functions are called for drawing wrapped lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("rgl")) {
  n &lt;- 20
  x &lt;- toPiInt(rnorm(n, mean = seq(-pi, pi, l = n), sd = 0.5))
  y &lt;- toPiInt(rnorm(n, mean = seq(-pi, pi, l = n), sd = 0.5))
  z &lt;- toPiInt(x + y + rnorm(n, mean = seq(-pi, pi, l = n), sd = 0.5))
  rgl::plot3d(x, y, z, xlim = c(-pi, pi), ylim = c(-pi, pi),
              zlim = c(-pi, pi), col = rainbow(n), size = 2,
              box = FALSE, axes = FALSE)
  linesTorus3d(x = x, y = y, z = z, col = rainbow(n), lwd = 2)
  torusAxis3d()
  rgl::plot3d(x, y, z, xlim = c(-pi, pi), ylim = c(-pi, pi),
              zlim = c(-pi, pi), col = rainbow(n), size = 2,
              box = FALSE, axes = FALSE)
  linesTorus3d(x = x, y = y, z = z, col = rainbow(n), ltyCross = 2,
               arrows = TRUE, theta = 0.1 * pi / 180, barblen = 0.1)
  torusAxis3d()
}

</code></pre>

<hr>
<h2 id='logBesselI0Scaled'>Efficient computation of Bessel related functions</h2><span id='topic+logBesselI0Scaled'></span><span id='topic+a1Inv'></span>

<h3>Description</h3>

<p>Computation of <code class="reqn">\log(I_0(x))-x</code> and the
inverse of <code class="reqn">A_1(k)=\frac{I_0(k)}{I_1(k)}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logBesselI0Scaled(x, splineApprox = TRUE)

a1Inv(x, splineApprox = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logBesselI0Scaled_+3A_x">x</code></td>
<td>
<p>evaluation vector. For <code>logBesselI0Scaled</code>, <code>x</code> must
contain non-negative values. For <code>a1Inv</code>, <code>x</code> must be in
<code class="reqn">[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="logBesselI0Scaled_+3A_splineapprox">splineApprox</code></td>
<td>
<p>whether to use a pre-computed spline approximation
(faster) or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both functions may rely on pre-computed spline interpolations
(<code>logBesselI0ScaledSpline</code> and <code>a1InvSpline</code>). Otherwise, a call
to <code>besselI</code> is done for <code class="reqn">\log(I_0(x))-x</code> and
<code class="reqn">A_1(k)=x</code> is solved numerically. The data in which the
interpolation is based is given in the examples.
</p>
<p>For <code>x</code> larger than <code>5e4</code>, the asymptotic expansion of
<code><a href="Bessel.html#topic+besselIasym">besselIasym</a></code> is employed.
</p>


<h3>Value</h3>

<p>A vector of the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data employed for log besselI0 scaled
x1 &lt;- c(seq(0, 1, by = 1e-4), seq(1 + 1e-2, 10, by = 1e-3),
        seq(10 + 1e-1, 100, by = 1e-2), seq(100 + 1e0, 1e3, by = 1e0),
        seq(1000 + 1e1, 5e4, by = 2e1))
logBesselI0ScaledEvalGrid &lt;- log(besselI(x = x1, nu = 0,
                                         expon.scaled = TRUE))
# save(list = "logBesselI0ScaledEvalGrid",
#      file = "logBesselI0ScaledEvalGrid.rda", compress = TRUE)

# Data employed for A1 inverse
x2 &lt;- rev(c(seq(1e-04, 0.9 - 1e-4, by = 1e-4),
            seq(0.9, 1 - 1e-05, by = 1e-5)))
a1InvEvalGrid &lt;- sapply(x2, function(k) {
  uniroot(f = function(x) k - besselI(x, nu = 1, expon.scaled = TRUE) /
          besselI(x, nu = 0, expon.scaled = TRUE),
          lower = 1e-06, upper = 1e+05, tol = 1e-15)$root
})
# save(list = "a1InvEvalGrid", file = "a1InvEvalGrid.rda", compress = TRUE)

# Accuracy logBesselI0Scaled
x &lt;- seq(0, 1e3, l = 1e3)
summary(logBesselI0Scaled(x = x, splineApprox = TRUE) -
        logBesselI0Scaled(x = x, splineApprox = FALSE))

# Accuracy a1Inv
y &lt;- seq(0, 1 - 1e-4, l = 1e3)
summary(a1Inv(x = y, splineApprox = TRUE) -
        a1Inv(x = y, splineApprox = FALSE))
</code></pre>

<hr>
<h2 id='logLikWouPairs'>Loglikelihood of WN in 2D when only the initial and final points are observed</h2><span id='topic+logLikWouPairs'></span>

<h3>Description</h3>

<p>Computation of the loglikelihood for a WN diffusion (with diagonal diffusion matrix) from a sample of initial and final pairs of angles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLikWouPairs(x, t, alpha, mu, sigma, rho = 0, maxK = 2L, expTrc = 30)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLikWouPairs_+3A_x">x</code></td>
<td>
<p>a matrix of dimension <code>c(n, 4)</code> of initial and final pairs of angles. Each row is an observation containing <code class="reqn">(\phi_0, \psi_0, \phi_t, \psi_t)</code>.
They all must be in <code class="reqn">[\pi,\pi)</code> so that the truncated wrapping by <code>maxK</code> windings is able to capture periodicity.</p>
</td></tr>
<tr><td><code id="logLikWouPairs_+3A_t">t</code></td>
<td>
<p>either a scalar or a vector of length <code>n</code> containing the times the initial and final dihedrals. If <code>t</code> is a scalar, a common time is assumed.</p>
</td></tr>
<tr><td><code id="logLikWouPairs_+3A_alpha">alpha</code></td>
<td>
<p>vector of length <code>3</code> parametrizing the <code>A</code> matrix as in <code><a href="#topic+alphaToA">alphaToA</a></code>.</p>
</td></tr>
<tr><td><code id="logLikWouPairs_+3A_mu">mu</code></td>
<td>
<p>a vector of length <code>2</code> giving the mean.</p>
</td></tr>
<tr><td><code id="logLikWouPairs_+3A_sigma">sigma</code></td>
<td>
<p>vector of length <code>2</code> containing the <strong>square root</strong> of the diagonal of <code class="reqn">\Sigma</code>, the diffusion matrix.</p>
</td></tr>
<tr><td><code id="logLikWouPairs_+3A_rho">rho</code></td>
<td>
<p>correlation coefficient of <code class="reqn">\Sigma</code>.</p>
</td></tr>
<tr><td><code id="logLikWouPairs_+3A_maxk">maxK</code></td>
<td>
<p>maximum absolute value of the windings considered in the computation of the WN.</p>
</td></tr>
<tr><td><code id="logLikWouPairs_+3A_exptrc">expTrc</code></td>
<td>
<p>truncation for exponential: <code>exp(x)</code> with <code>x &lt;= -expTrc</code> is set to zero. Defaults to <code>30</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A negative penalty is added if positive definiteness is violated. If the output value is Inf, -100 * N is returned instead.
</p>


<h3>Value</h3>

<p>A scalar giving the final loglikelihood, defined as the sum of the loglikelihood of the initial angles according to the stationary density
and the loglikelihood of the transitions from initial to final angles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(345567)
x &lt;- toPiInt(matrix(rnorm(200, mean = pi), ncol = 4, nrow = 50))
alpha &lt;- c(2, 1, -0.5)
mu &lt;- c(0, pi)
sigma &lt;- sqrt(c(2, 1))

# The same
logLikWouPairs(x = x, t = 0.5, alpha = alpha, mu = mu, sigma = sigma)
sum(
  log(dStatWn2D(x = x[, 1:2], alpha = alpha, mu = mu, sigma = sigma)) +
  log(dTpdWou2D(x = x[, 3:4], x0 = x[, 1:2], t = 0.5, alpha = alpha, mu = mu,
                 sigma = sigma))
)

# Different times
logLikWouPairs(x = x, t = (1:50) / 50, alpha = alpha, mu = mu, sigma = sigma)
</code></pre>

<hr>
<h2 id='matlab.like.colorRamps'>Generate color palettes similar to the Matlab default</h2><span id='topic+matlab.like.colorRamps'></span>

<h3>Description</h3>

<p>Generates Matlab-like color palettes. Functions imported from
the colorRamps package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matlab.like.colorRamps(n, two = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matlab.like.colorRamps_+3A_n">n</code></td>
<td>
<p>number of colors in the palette.</p>
</td></tr>
<tr><td><code id="matlab.like.colorRamps_+3A_two">two</code></td>
<td>
<p>flag indicating whether to use <code>colorRamps::matlab.like</code> or
<code>colorRamps::matlab.like2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of <code>n</code> colors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>image(matrix(1:100, 10), col = matlab.like.colorRamps(100))
image(matrix(1:100, 10), col = matlab.like.colorRamps(100, two = TRUE))
</code></pre>

<hr>
<h2 id='matMatch'>Matching of matrices</h2><span id='topic+matMatch'></span>

<h3>Description</h3>

<p>Wrapper for matching a matrix against another, by rows or
columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matMatch(x, mat, rows = TRUE, useMatch = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matMatch_+3A_x">x</code></td>
<td>
<p>matrix with the values to be matched.</p>
</td></tr>
<tr><td><code id="matMatch_+3A_mat">mat</code></td>
<td>
<p>matrix with the values to be matched against.</p>
</td></tr>
<tr><td><code id="matMatch_+3A_rows">rows</code></td>
<td>
<p>whether the match should be done by rows (<code>TRUE</code>) or
columns (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="matMatch_+3A_usematch">useMatch</code></td>
<td>
<p>whether to rely on <code><a href="base.html#topic+match">match</a></code> or not. Might
give unexpected mismatches due to working with lists.</p>
</td></tr>
<tr><td><code id="matMatch_+3A_...">...</code></td>
<td>
<p>further parameters passed to <code><a href="base.html#topic+match">match</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector of length <code>nrow(x)</code> (or <code>ncol(x)</code>)
giving the row (or col) position in table of the first match, if there is
a match.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># By rows
A &lt;- rbind(5:6, repRow(1:2, 3), 3:4)
B &lt;- unique(A)
ind &lt;- matMatch(x = A, mat = B)
A
B[ind, ]

# By columns
A &lt;- cbind(5:6, repCol(1:2, 3), 3:4)
B &lt;- t(unique(t(A)))
ind &lt;- matMatch(x = A, mat = B, rows = FALSE)
A
B[, ind]
</code></pre>

<hr>
<h2 id='mcTorusIntegrate'>Monte Carlo integration on the torus</h2><span id='topic+mcTorusIntegrate'></span>

<h3>Description</h3>

<p>Convenience function for Monte Carlo integration on
<code class="reqn">[-\pi, \pi)^p</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcTorusIntegrate(f, p, M = 1e+05, fVect = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcTorusIntegrate_+3A_f">f</code></td>
<td>
<p>function to be integrated.</p>
</td></tr>
<tr><td><code id="mcTorusIntegrate_+3A_p">p</code></td>
<td>
<p>dimension of the torus.</p>
</td></tr>
<tr><td><code id="mcTorusIntegrate_+3A_m">M</code></td>
<td>
<p>number of Monte Carlo replicates.</p>
</td></tr>
<tr><td><code id="mcTorusIntegrate_+3A_fvect">fVect</code></td>
<td>
<p>is <code>f</code> vectorized?</p>
</td></tr>
<tr><td><code id="mcTorusIntegrate_+3A_...">...</code></td>
<td>
<p>further parameters passed to <code>f</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar with the approximated integral.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Integral of sin(x1) * cos(x2), must be close to 0
mcTorusIntegrate(f = function(x) sin(x[, 1]) * cos(x[, 2]), p = 2)
</code></pre>

<hr>
<h2 id='mleMou'>Maximum likelihood estimation of the multivariate OU diffusion</h2><span id='topic+mleMou'></span>

<h3>Description</h3>

<p>Computation of the maximum likelihood estimator of the
parameters of the <em>multivariate</em> Ornstein&ndash;Uhlenbeck (OU) diffusion
from a discretized trajectory
<code class="reqn">\{X_{\Delta i}\}_{i=1}^N</code>. The objective
function to minimize is
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i=2}^n\log p_{\Delta}(X_{\Delta i} | X_{\Delta (i - 1)}).</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>mleMou(data, delta, alpha = rep(NA, 3), mu = rep(NA, 2), sigma = rep(NA,
  2), start, lower = c(0.01, 0.01, -25, -pi, -pi, 0.01, 0.01),
  upper = c(25, 25, 25, pi, pi, 25, 25), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mleMou_+3A_data">data</code></td>
<td>
<p>a matrix of size <code>c(N, p)</code> with the discretized trajectory
of the diffusion.</p>
</td></tr>
<tr><td><code id="mleMou_+3A_delta">delta</code></td>
<td>
<p>time discretization step.</p>
</td></tr>
<tr><td><code id="mleMou_+3A_alpha">alpha</code>, <code id="mleMou_+3A_mu">mu</code>, <code id="mleMou_+3A_sigma">sigma</code></td>
<td>
<p>arguments to fix a parameter to a given value and
perform the estimation on the rest. Defaults to <code>NA</code>, meaning that the
parameter is estimated. Note that <code>start</code>, <code>lower</code> and <code>upper</code>
must be changed accordingly if parameters are fixed, see examples.</p>
</td></tr>
<tr><td><code id="mleMou_+3A_start">start</code></td>
<td>
<p>starting values, a matrix with <code>p</code> columns, with each
entry representing a different starting value.</p>
</td></tr>
<tr><td><code id="mleMou_+3A_lower">lower</code>, <code id="mleMou_+3A_upper">upper</code></td>
<td>
<p>bound for box constraints as in method <code>"L-BFGS-B"</code>
of <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="mleMou_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="#topic+mleOptimWrapper">mleOptimWrapper</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first row in <code>data</code> is not taken into account for
estimation. See <code><a href="#topic+mleOu">mleOu</a></code> for the univariate case (more efficient).
</p>
<p><code>mleMou</code> only handles <code>p = 2</code> currently. It imposes that
<code>Sigma</code> is diagonal and handles the parametrization of <code>A</code> by
<code><a href="#topic+alphaToA">alphaToA</a></code>.
</p>


<h3>Value</h3>

<p>Output from <code><a href="#topic+mleOptimWrapper">mleOptimWrapper</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(345678)
data &lt;- rTrajMou(x0 = c(0, 0), A = alphaToA(alpha = c(1, 1, 0.5),
                                            sigma = 1:2), mu = c(1, 1),
                 Sigma = diag((1:2)^2), N = 200, delta = 0.5)
mleMou(data = data, delta = 0.5, start = c(1, 1, 0, 1, 1, 1, 2),
       lower = c(0.1, 0.1, -25, -10, -10, 0.1, 0.1),
       upper = c(25, 25, 25, 10, 10, 25, 25), maxit = 500)

# Fixed sigma and mu
mleMou(data = data, delta = 0.5, mu = c(1, 1), sigma = 1:2,
       start = c(1, 1, 0), lower = c(0.1, 0.1, -25), upper = c(25, 25, 25))
</code></pre>

<hr>
<h2 id='mleOptimWrapper'>Optimization wrapper for likelihood-based procedures</h2><span id='topic+mleOptimWrapper'></span>

<h3>Description</h3>

<p>A convenient wrapper to perform local optimization of the
likelihood function via <code>nlm</code> and <code>optim</code> including several
practical utilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mleOptimWrapper(minusLogLik, region = function(pars) list(pars = pars,
  penalty = 0), penalty = 1e+10, optMethod = "Nelder-Mead", start,
  lower = rep(-Inf, ncol(start)), upper = rep(Inf, ncol(start)),
  selectSolution = "lowestLocMin", checkCircular = TRUE, maxit = 500,
  tol = 1e-05, verbose = 0, eigTol = 1e-04, condTol = 10000, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mleOptimWrapper_+3A_minusloglik">minusLogLik</code></td>
<td>
<p>function computing the minus log-likelihood function.
Must have a single argument containing a vector of length <code>p</code>.</p>
</td></tr>
<tr><td><code id="mleOptimWrapper_+3A_region">region</code></td>
<td>
<p>function to impose a feasibility region via a penalty. See
details.</p>
</td></tr>
<tr><td><code id="mleOptimWrapper_+3A_penalty">penalty</code></td>
<td>
<p>imposed penalty if value is not finite.</p>
</td></tr>
<tr><td><code id="mleOptimWrapper_+3A_optmethod">optMethod</code></td>
<td>
<p>one of the following strings: <code>"nlm"</code>,
<code>"Nelder-Mead"</code>, <code>"BFGS"</code>, <code>"CG"</code>, <code>"L-BFGS-B"</code>,
<code>"SANN"</code>, or <code>"Brent"</code>.</p>
</td></tr>
<tr><td><code id="mleOptimWrapper_+3A_start">start</code></td>
<td>
<p>starting values, a matrix with <code>p</code> columns, with each
entry representing a different starting value.</p>
</td></tr>
<tr><td><code id="mleOptimWrapper_+3A_lower">lower</code>, <code id="mleOptimWrapper_+3A_upper">upper</code></td>
<td>
<p>bound for box constraints as in method <code>"L-BFGS-B"</code>
of <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="mleOptimWrapper_+3A_selectsolution">selectSolution</code></td>
<td>
<p>which criterion is used for selecting a solution
among possible ones, either <code>"lowest"</code>, <code>"lowestConv"</code> or
<code>"lowestLocMin"</code>. <code>"lowest"</code> returns the solution with lowest
value in the <code>minusLogLik</code> function. <code>"lowestConv"</code> restricts
the search of the best solution among the ones for which the optimizer has
converged. <code>"lowestLocMin"</code> in addition imposes that the solution is
guaranteed to be a local minimum by examining the Hessian matrix.</p>
</td></tr>
<tr><td><code id="mleOptimWrapper_+3A_checkcircular">checkCircular</code></td>
<td>
<p>logical indicating whether to automatically treat the
variables with <code>lower</code> and <code>upper</code> entries equal to <code>-pi</code> and
<code>pi</code> as circular. See details.</p>
</td></tr>
<tr><td><code id="mleOptimWrapper_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="mleOptimWrapper_+3A_tol">tol</code></td>
<td>
<p>tolerance for convergence (passed to <code>reltol</code>, <code>pgtol</code>
or <code>gradtol</code>).</p>
</td></tr>
<tr><td><code id="mleOptimWrapper_+3A_verbose">verbose</code></td>
<td>
<p>an integer from <code>0</code> to <code>2</code> if
<code>optMethod = "Nelder-Mead"</code> or from <code>0</code> to <code>4</code> otherwise
giving the amount of information displayed.</p>
</td></tr>
<tr><td><code id="mleOptimWrapper_+3A_eigtol">eigTol</code>, <code id="mleOptimWrapper_+3A_condtol">condTol</code></td>
<td>
<p>eigenvalue and condition number tolerance for the
Hessian in order to guarantee a local minimum. Used only if
<code>selectSolution = "lowestLocMin"</code>.</p>
</td></tr>
<tr><td><code id="mleOptimWrapper_+3A_...">...</code></td>
<td>
<p>further arguments passed to the <code>optMethod</code> selected. See
options in <code><a href="stats.html#topic+nlm">nlm</a></code> or <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>checkCircular = TRUE</code>, then the corresponding <code>lower</code>
and <code>upper</code> entries of the circular parameters are set to <code>-Inf</code>
and <code>Inf</code>, respectively, and <code>minusLogLik</code> is called with the
<em>principal value</em> of the circular argument.
</p>
<p>If no solution is found satisfying the criterion in <code>selectSolution</code>,
NAs are returned in the elements of the main solution.
</p>
<p>The Hessian is only computed if <code>selectSolution = "lowestLocMin"</code>.
</p>
<p>Region feasibility can be imposed by a function with the same arguments as
<code>minusLogLik</code> that resets <code>pars</code> in to the boundary of the
feasibility region and adds a penalty proportional to the violation of the
feasibility region. Note that this is <em>not the best procedure at all</em>
to solve the constrained optimization problem, but just a relatively
flexible and quick approach (for a more advanced treatment of restrictions,
see <a href="https://CRAN.R-project.org/view=Optimization">
optimization-focused packages</a>). The value must be a list with objects
<code>pars</code> and <code>penalty</code>. By default no region is imposed, i.e.,
<code>region = function(pars) list("pars" = pars, "penalty" = 0)</code>. Note that
the Hessian is computed from the unconstrained problem, hence
<code>localMinimumGuaranteed</code> might be <code>FALSE</code> even if a local minimum
to the constrained problem was found.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<ul>
<li> <p><code>par</code>: estimated minimizing parameters
</p>
</li>
<li> <p><code>value</code>: value of <code>minusLogLik</code> at the minimum.
</p>
</li>
<li> <p><code>convergence</code>: if the optimizer has converged or not.
</p>
</li>
<li> <p><code>message</code>: a character string giving any additional information
returned by the optimizer.
</p>
</li>
<li> <p><code>eigHessian</code>: eigenvalues of the Hessian at the minimum. Recall
that for the same solution slightly different outputs may be obtained
according to the different computations of the Hessian of <code>nlm</code> and
<code>optim</code>.
</p>
</li>
<li> <p><code>localMinimumGuaranteed</code>: tests if the Hessian is positive
definite (all eigenvalues larger than the tolerance <code>eigTol</code> and
condition number smaller than <code>condTol</code>).
</p>
</li>
<li> <p><code>solutionsOutput</code>: a list containing the complete output of
the selected method for the different starting values. It includes the
extra objects <code>convergence</code> and <code>localMinimumGuaranteed</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># No local minimum
head(mleOptimWrapper(minusLogLik = function(x) -sum((x - 1:4)^2),
                     start = rbind(10:13, 1:2), selectSolution = "lowest"))
head(mleOptimWrapper(minusLogLik = function(x) -sum((x - 1:4)^2),
                     start = rbind(10:13, 1:2),
                     selectSolution = "lowestConv"))
head(mleOptimWrapper(minusLogLik = function(x) -sum((x - 1:4)^2),
                     start = rbind(10:13, 1:2),
                     selectSolution = "lowestLocMin"))

# Local minimum
head(mleOptimWrapper(minusLogLik = function(x) sum((x - 1:4)^2),
                     start = rbind(10:13), optMethod = "BFGS"))
head(mleOptimWrapper(minusLogLik = function(x) sum((x - 1:4)^2),
                     start = rbind(10:13), optMethod = "Nelder-Mead"))

# Function with several local minimum and a 'spurious' one
f &lt;- function(x)  0.75 * (x[1] - 1)^2 -
                  10 / (0.1 + 0.1 * ((x[1] - 15)^2 + (x[2] - 2)^2)) -
                  9.5 / (0.1 + 0.1 * ((x[1] - 15)^2 + (x[2] + 2)^2))
plotSurface2D(x = seq(0, 20, l = 100), y = seq(-3, 3, l = 100), f = f)
head(mleOptimWrapper(minusLogLik = f,
                     start = rbind(c(15, 2), c(15, -2), c(5, 0)),
                     selectSolution = "lowest"))
head(mleOptimWrapper(minusLogLik = f,
                     start = rbind(c(15, 2), c(15, -2), c(5, 0)),
                     selectSolution = "lowestConv"))
head(mleOptimWrapper(minusLogLik = f,
                     start = rbind(c(15, 2), c(15, -2), c(5, 0)),
                     selectSolution = "lowestLocMin", eigTol = 0.01))

# With constraint region
head(mleOptimWrapper(minusLogLik = function(x) sum((x - 1:2)^2),
                     start = rbind(10:11),
                     region = function(pars) {
                       x &lt;- pars[1]
                       y &lt;- pars[2]
                       if (y &lt;= x^2) {
                         return(list("pars" = pars, "penalty" = 0))
                       } else {
                        return(list("pars" = c(sqrt(y), y),
                                    "penalty" = y - x^2))
                       }
                     }, lower = c(0.5, 1), upper = c(Inf, Inf),
                optMethod = "Nelder-Mead", selectSolution = "lowest"))
head(mleOptimWrapper(minusLogLik = function(x) sum((x - 1:2)^2),
                     start = rbind(10:11), lower = c(0.5, 1),
                     upper = c(Inf, Inf),optMethod = "Nelder-Mead"))
</code></pre>

<hr>
<h2 id='mleOu'>Maximum likelihood estimation of the OU diffusion</h2><span id='topic+mleOu'></span>

<h3>Description</h3>

<p>Computation of the maximum likelihood estimator of the
parameters of the <em>univariate</em> Ornstein&ndash;Uhlenbeck (OU) diffusion
from a discretized trajectory
<code class="reqn">\{X_{\Delta i}\}_{i=1}^N</code>. The objective
function to minimize is
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i=2}^n\log p_{\Delta}(X_{\Delta i} | X_{\Delta (i - 1)}).</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>mleOu(data, delta, alpha = NA, mu = NA, sigma = NA, start,
  lower = c(0.01, -5, 0.01), upper = c(25, 5, 25), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mleOu_+3A_data">data</code></td>
<td>
<p>a vector of size <code>N</code> with the discretized trajectory of
the diffusion.</p>
</td></tr>
<tr><td><code id="mleOu_+3A_delta">delta</code></td>
<td>
<p>time discretization step.</p>
</td></tr>
<tr><td><code id="mleOu_+3A_alpha">alpha</code>, <code id="mleOu_+3A_mu">mu</code>, <code id="mleOu_+3A_sigma">sigma</code></td>
<td>
<p>arguments to fix a parameter to a given value and
perform the estimation on the rest. Defaults to <code>NA</code>, meaning that the
parameter is estimated. Note that <code>start</code>, <code>lower</code> and <code>upper</code>
must be changed accordingly if parameters are fixed, see examples.</p>
</td></tr>
<tr><td><code id="mleOu_+3A_start">start</code></td>
<td>
<p>starting values, a matrix with <code>p</code> columns, with each
entry representing a different starting value.</p>
</td></tr>
<tr><td><code id="mleOu_+3A_lower">lower</code>, <code id="mleOu_+3A_upper">upper</code></td>
<td>
<p>bound for box constraints as in method <code>"L-BFGS-B"</code>
of <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="mleOu_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="#topic+mleOptimWrapper">mleOptimWrapper</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first element in <code>data</code> is not taken into account for
estimation. See <code><a href="#topic+mleMou">mleMou</a></code> for the multivariate case (less
efficient for dimension one).
</p>


<h3>Value</h3>

<p>Output from <code><a href="#topic+mleOptimWrapper">mleOptimWrapper</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(345678)
data &lt;- rTrajOu(x0 = 0, alpha = 1, mu = 0, sigma = 1, N = 100, delta = 0.1)
mleOu(data = data, delta = 0.1, start = c(2, 1, 2), lower = c(0.1, -10, 0.1),
      upper = c(25, 10, 25))

# Fixed sigma and mu
mleOu(data = data, delta = 0.1, mu = 0, sigma = 1, start = 2, lower = 0.1,
      upper = 25, optMethod = "nlm")
</code></pre>

<hr>
<h2 id='mlePde1D'>MLE for toroidal process via PDE solving in 1D</h2><span id='topic+mlePde1D'></span>

<h3>Description</h3>

<p>Maximum Likelihood Estimation (MLE) for arbitrary diffusions,
based on the transition probability density (tpd) obtained as the numerical
solution of the Fokker&ndash;Planck Partial Differential Equation (PDE) in 1D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlePde1D(data, delta, b, sigma2, Mx = 500, Mt = ceiling(100 * delta),
  sdInitial = 0.1, linearBinning = FALSE, start, lower, upper, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlePde1D_+3A_data">data</code></td>
<td>
<p>a vector of size <code>N</code> with the discretized trajectory of
the diffusion.</p>
</td></tr>
<tr><td><code id="mlePde1D_+3A_delta">delta</code></td>
<td>
<p>time discretization step.</p>
</td></tr>
<tr><td><code id="mlePde1D_+3A_b">b</code></td>
<td>
<p>drift function. Must return a vector of the same size as its
argument.</p>
</td></tr>
<tr><td><code id="mlePde1D_+3A_sigma2">sigma2</code></td>
<td>
<p>function giving the squared diffusion coefficient. Must
return a vector of the same size as its argument.</p>
</td></tr>
<tr><td><code id="mlePde1D_+3A_mx">Mx</code></td>
<td>
<p>size of the equispaced spatial grid in <code class="reqn">[-\pi,\pi)</code>.</p>
</td></tr>
<tr><td><code id="mlePde1D_+3A_mt">Mt</code></td>
<td>
<p>size of the time grid in <code class="reqn">[0, t]</code>.</p>
</td></tr>
<tr><td><code id="mlePde1D_+3A_sdinitial">sdInitial</code></td>
<td>
<p>the standard deviation of the concentrated WN giving the
initial condition.</p>
</td></tr>
<tr><td><code id="mlePde1D_+3A_linearbinning">linearBinning</code></td>
<td>
<p>flag to indicate whether linear binning should be
applied for the initial values of the tpd, instead of usual simple binning
(cheaper). Linear binning is always done in the evaluation of the tpd.</p>
</td></tr>
<tr><td><code id="mlePde1D_+3A_start">start</code></td>
<td>
<p>starting values, a matrix with <code>p</code> columns, with each
entry representing a different starting value.</p>
</td></tr>
<tr><td><code id="mlePde1D_+3A_lower">lower</code>, <code id="mlePde1D_+3A_upper">upper</code></td>
<td>
<p>bound for box constraints as in method <code>"L-BFGS-B"</code>
of <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="mlePde1D_+3A_...">...</code></td>
<td>
<p>Further parameters passed to <code><a href="#topic+crankNicolson1D">crankNicolson1D</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Sections 3.4.1 and 3.4.4 in García-Portugués et al. (2019) for
details.
</p>


<h3>Value</h3>

<p>Output from <code><a href="#topic+mleOptimWrapper">mleOptimWrapper</a></code>.
</p>


<h3>References</h3>

<p>García-Portugués, E., Sørensen, M., Mardia, K. V. and Hamelryck, T. (2019)
Langevin diffusions on the torus: estimation and applications.
<em>Statistics and Computing</em>, 29(2):1&ndash;22. <a href="https://doi.org/10.1007/s11222-017-9790-2">doi:10.1007/s11222-017-9790-2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Test in OU
alpha &lt;- 2
mu &lt;- 0
sigma &lt;- 1
set.seed(234567)
traj &lt;- rTrajOu(x0 = 0, alpha = alpha, mu = mu, sigma = sigma, N = 500,
                delta = 0.5)
b &lt;- function(x, pars) pars[1] * (pars[2] - x)
sigma2 &lt;- function(x, pars) rep(pars[3]^2, length(x))

exactOu &lt;- mleOu(traj, delta = 0.5, start = c(1, 1, 2),
                 lower = c(0.1, -pi, 0.1), upper = c(10, pi, 10))
pdeOu &lt;- mlePde1D(data = traj, delta = 0.5, Mx = 100, Mt = 100, b = b,
                  sigma2 = sigma2, start = c(1, 1, 2),
                  lower = c(0.1, -pi, -10), upper = c(10, pi, 10),
                  verbose = 2)
pdeOuLin &lt;- mlePde1D(data = traj, delta = 0.5, Mx = 100, Mt = 100, b = b,
                     sigma2 = sigma2, start = c(1, 1, 2),
                     lower = c(0.1, -pi, -10), upper = c(10, pi, 10),
                     linearBinning = TRUE, verbose = 2)
head(exactOu)
head(pdeOu)
head(pdeOuLin)

# Test in WN diffusion
alpha &lt;- 2
mu &lt;- 0
sigma &lt;- 1
set.seed(234567)
traj &lt;- rTrajWn1D(x0 = 0, alpha = alpha, mu = mu, sigma = sigma, N = 500,
                 delta = 0.5)

exactOu &lt;- mleOu(traj, delta = 0.5, start = c(1, 1, 2),
                 lower = c(0.1, -pi, 0.1), upper = c(10, pi, 10))
pdeWn &lt;- mlePde1D(data = traj, delta = 0.5, Mx = 100, Mt = 100,
                  b = function(x, pars)
                    driftWn1D(x = x, alpha = pars[1], mu = pars[2],
                              sigma = pars[3]),
                  sigma2 = function(x, pars) rep(pars[3]^2, length(x)),
                  start = c(1, 1, 2), lower = c(0.1, -pi, -10),
                  upper = c(10, pi, 10), verbose = 2)
pdeWnLin &lt;- mlePde1D(data = traj, delta = 0.5, Mx = 100, Mt = 100,
                     b = function(x, pars)
                       driftWn1D(x = x, alpha = pars[1], mu = pars[2],
                                 sigma = pars[3]),
                     sigma2 = function(x, pars) rep(pars[3]^2, length(x)),
                     start = c(1, 1, 2), lower = c(0.1, -pi, -10),
                     upper = c(10, pi, 10), linearBinning = TRUE,
                     verbose = 2)
head(exactOu)
head(pdeWn)
head(pdeWnLin)

</code></pre>

<hr>
<h2 id='mlePde2D'>MLE for toroidal process via PDE solving in 2D</h2><span id='topic+mlePde2D'></span>

<h3>Description</h3>

<p>Maximum Likelihood Estimation (MLE) for arbitrary diffusions,
based on the transition probability density (tpd) obtained as the numerical
solution of the Fokker&ndash;Planck Partial Differential Equation (PDE) in 2D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlePde2D(data, delta, b, sigma2, Mx = 50, My = 50, Mt = ceiling(100 *
  delta), sdInitial = 0.1, linearBinning = FALSE, start, lower, upper, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlePde2D_+3A_data">data</code></td>
<td>
<p>a matrix of dimension <code>c(n, p)</code>.</p>
</td></tr>
<tr><td><code id="mlePde2D_+3A_delta">delta</code></td>
<td>
<p>discretization step.</p>
</td></tr>
<tr><td><code id="mlePde2D_+3A_b">b</code></td>
<td>
<p>drift function. Must return a vector of the same size as its
argument.</p>
</td></tr>
<tr><td><code id="mlePde2D_+3A_sigma2">sigma2</code></td>
<td>
<p>function giving the diagonal of the diffusion matrix. Must
return a vector of the same size as its argument.</p>
</td></tr>
<tr><td><code id="mlePde2D_+3A_mx">Mx</code>, <code id="mlePde2D_+3A_my">My</code></td>
<td>
<p>sizes of the equispaced spatial grids in <code class="reqn">[-\pi,\pi)</code> for each component.</p>
</td></tr>
<tr><td><code id="mlePde2D_+3A_mt">Mt</code></td>
<td>
<p>size of the time grid in <code class="reqn">[0, t]</code>.</p>
</td></tr>
<tr><td><code id="mlePde2D_+3A_sdinitial">sdInitial</code></td>
<td>
<p>standard deviations of the concentrated WN giving the
initial condition.</p>
</td></tr>
<tr><td><code id="mlePde2D_+3A_linearbinning">linearBinning</code></td>
<td>
<p>flag to indicate whether linear binning should be
applied for the initial values of the tpd, instead of usual simple binning
(cheaper). Linear binning is always done in the evaluation of the tpd.</p>
</td></tr>
<tr><td><code id="mlePde2D_+3A_start">start</code></td>
<td>
<p>starting values, a matrix with <code>p</code> columns, with each
entry representing a different starting value.</p>
</td></tr>
<tr><td><code id="mlePde2D_+3A_lower">lower</code>, <code id="mlePde2D_+3A_upper">upper</code></td>
<td>
<p>bound for box constraints as in method <code>"L-BFGS-B"</code>
of <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="mlePde2D_+3A_...">...</code></td>
<td>
<p>further parameters passed to <code><a href="#topic+mleOptimWrapper">mleOptimWrapper</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Sections 3.4.2 and 3.4.4 in García-Portugués et al. (2019) for
details. The function currently includes the <code>region</code> function for
imposing a feasibility region on the parameters of the bivariate WN
diffusion.
</p>


<h3>Value</h3>

<p>Output from <code><a href="#topic+mleOptimWrapper">mleOptimWrapper</a></code>.
</p>


<h3>References</h3>

<p>García-Portugués, E., Sørensen, M., Mardia, K. V. and Hamelryck, T. (2019)
Langevin diffusions on the torus: estimation and applications.
<em>Statistics and Computing</em>, 29(2):1&ndash;22. <a href="https://doi.org/10.1007/s11222-017-9790-2">doi:10.1007/s11222-017-9790-2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Test in OU process
alpha &lt;- c(1, 2, -0.5)
mu &lt;- c(0, 0)
sigma &lt;- c(0.5, 1)
set.seed(2334567)
data &lt;- rTrajMou(x0 = c(0, 0), A = alphaToA(alpha = alpha, sigma = sigma),
                 mu = mu, Sigma = diag(sigma^2), N = 500, delta = 0.5)
b &lt;- function(x, pars) sweep(-x, 2, pars[4:5], "+") %*%
                       t(alphaToA(alpha = pars[1:3], sigma = sigma))
sigma2 &lt;- function(x, pars) repRow(sigma^2, nrow(x))

exactOu &lt;- mleMou(data = data, delta = 0.5, sigma = sigma,
                  start = c(1, 1, 0, 2, 2),
                  lower = c(0.1, 0.1, -25, -10, -10),
                  upper = c(25, 25, 25, 10, 10))
head(exactOu, 2)
pdeOu &lt;- mlePde2D(data = data, delta = 0.5, b = b, sigma2 = sigma2,
                  Mx = 10, My = 10, Mt = 10,
                  start = rbind(c(1, 1, 0, 2, 2)),
                  lower = c(0.1, 0.1, -25, -10, -10),
                  upper = c(25, 25, 25, 10, 10), verbose = 2)
head(pdeOu, 2)
pdeOuLin &lt;- mlePde2D(data = data, delta = 0.5, b = b, sigma2 = sigma2,
                     Mx = 10, My = 10, Mt = 10,
                     start = rbind(c(1, 1, 0, 2, 2)),
                     lower = c(0.1, 0.1, -25, -10, -10),
                     upper = c(25, 25, 25, 10, 10), verbose = 2,
                     linearBinning = TRUE)
head(pdeOuLin, 2)

# Test in WN diffusion
alpha &lt;- c(1, 0.5, 0.25)
mu &lt;- c(0, 0)
sigma &lt;- c(2, 1)
set.seed(234567)
data &lt;- rTrajWn2D(x0 = c(0, 0), alpha = alpha, mu = mu, sigma = sigma,
                    N = 200, delta = 0.5)
b &lt;- function(x, pars) driftWn2D(x = x, A = alphaToA(alpha = pars[1:3],
                                                     sigma = sigma),
                                 mu = pars[4:5], sigma = sigma)
sigma2 &lt;- function(x, pars) repRow(sigma^2, nrow(x))

exactOu &lt;- mleMou(data = data, delta = 0.5, sigma = sigma,
                  start = c(1, 1, 0, 1, 1),
                  lower = c(0.1, 0.1, -25, -25, -25),
                  upper = c(25, 25, 25, 25, 25), optMethod = "nlm")
pdeWn &lt;- mlePde2D(data = data, delta = 0.5, b = b, sigma2 = sigma2,
                  Mx = 20, My = 20, Mt = 10, start = rbind(c(1, 1, 0, 1, 1)),
                  lower = c(0.1, 0.1, -25, -25, -25),
                  upper = c(25, 25, 25, 25, 25), verbose = 2,
                  optMethod = "nlm")
pdeWnLin &lt;- mlePde2D(data = data, delta = 0.5, b = b, sigma2 = sigma2,
                     Mx = 20, My = 20, Mt = 10,
                     start = rbind(c(1, 1, 0, 1, 1)),
                     lower = c(0.1, 0.1, -25, -25, -25),
                     upper = c(25, 25, 25, 25, 25), verbose = 2,
                     linearBinning = TRUE)

head(exactOu)
head(pdeOu)
head(pdeOuLin)

</code></pre>

<hr>
<h2 id='periodicTrapRule1D'>Quadrature rules in 1D, 2D and 3D</h2><span id='topic+periodicTrapRule1D'></span><span id='topic+periodicTrapRule2D'></span><span id='topic+periodicTrapRule3D'></span><span id='topic+integrateSimp1D'></span><span id='topic+integrateSimp2D'></span><span id='topic+integrateSimp3D'></span>

<h3>Description</h3>

<p>Quadrature rules for definite integrals over intervals in 1D,
<code class="reqn">\int_{x_1}^{x_2} f(x)dx</code>, rectangles in 2D,<br />
<code class="reqn">\int_{x_1}^{x_2}\int_{y_1}^{y_2} f(x,y)dydx</code> and cubes in 3D,
<code class="reqn">\int_{x_1}^{x_2}\int_{y_1}^{y_2}\int_{z_1}^{z_2} f(x,y,z)dzdydx</code>.
The trapezoidal rules assume that the function is periodic, whereas the
Simpson rules work for arbitrary functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>periodicTrapRule1D(fx, endsMatch = FALSE, na.rm = TRUE,
  lengthInterval = 2 * pi)

periodicTrapRule2D(fxy, endsMatch = FALSE, na.rm = TRUE,
  lengthInterval = rep(2 * pi, 2))

periodicTrapRule3D(fxyz, endsMatch = FALSE, na.rm = TRUE,
  lengthInterval = rep(2 * pi, 3))

integrateSimp1D(fx, lengthInterval = 2 * pi, na.rm = TRUE)

integrateSimp2D(fxy, lengthInterval = rep(2 * pi, 2), na.rm = TRUE)

integrateSimp3D(fxyz, lengthInterval = rep(2 * pi, 3), na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="periodicTrapRule1D_+3A_fx">fx</code></td>
<td>
<p>vector containing the evaluation of the function to integrate over
a uniform grid in <code class="reqn">[x_1,x_2]</code>.</p>
</td></tr>
<tr><td><code id="periodicTrapRule1D_+3A_endsmatch">endsMatch</code></td>
<td>
<p>flag to indicate whether the values of the last entries of
<code>fx</code>, <code>fxy</code> or <code>fxyz</code> are the ones in the first entries
(elements, rows, columns, slices). See examples for usage.</p>
</td></tr>
<tr><td><code id="periodicTrapRule1D_+3A_na.rm">na.rm</code></td>
<td>
<p>logical.  Should missing values (including <code>NaN</code>) be
removed?</p>
</td></tr>
<tr><td><code id="periodicTrapRule1D_+3A_lengthinterval">lengthInterval</code></td>
<td>
<p>vector containing the lengths of the intervals of
integration.</p>
</td></tr>
<tr><td><code id="periodicTrapRule1D_+3A_fxy">fxy</code></td>
<td>
<p>matrix containing the evaluation of the function to integrate
over a uniform grid in <code class="reqn">[x_1,x_2]\times[y_1,y_2]</code>.</p>
</td></tr>
<tr><td><code id="periodicTrapRule1D_+3A_fxyz">fxyz</code></td>
<td>
<p>three dimensional array containing the evaluation of the
function to integrate over a uniform grid in
<code class="reqn">[x_1,x_2]\times[y_1,y_2]\times[z_1,z_2]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simple trapezoidal rule has a very good performance for
periodic functions in 1D and 2D(order of error ). The higher dimensional
extensions are obtained by iterative usage of the 1D rules.
</p>


<h3>Value</h3>

<p>The value of the integral.
</p>


<h3>References</h3>

<p>Press, W. H., Teukolsky, S. A., Vetterling, W. T., Flannery, B. P. (1996).
<em>Numerical Recipes in Fortran 77: The Art of Scientific Computing
(Vol. 1 of Fortran Numerical Recipes)</em>. Cambridge University Press,
Cambridge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In 1D. True value: 3.55099937
N &lt;- 21
grid &lt;- seq(-pi, pi, l = N)
fx &lt;- sin(grid)^2 * exp(cos(grid))
periodicTrapRule1D(fx = fx, endsMatch = TRUE)
periodicTrapRule1D(fx = fx[-N], endsMatch = FALSE)
integrateSimp1D(fx = fx, lengthInterval = 2 * pi)
integrateSimp1D(fx = fx[-N]) # Worse, of course

# In 2D. True value: 22.31159
fxy &lt;- outer(grid, grid, function(x, y) (sin(x)^2 * exp(cos(x)) +
                                         sin(y)^2 * exp(cos(y))) / 2)
periodicTrapRule2D(fxy = fxy, endsMatch = TRUE)
periodicTrapRule2D(fxy = fxy[-N, -N], endsMatch = FALSE)
periodicTrapRule1D(apply(fxy[-N, -N], 1, periodicTrapRule1D))
integrateSimp2D(fxy = fxy)
integrateSimp1D(apply(fxy, 1, integrateSimp1D))

# In 3D. True value: 140.1878
fxyz &lt;- array(fxy, dim = c(N, N, N))
for (i in 1:N) fxyz[i, , ] &lt;- fxy
periodicTrapRule3D(fxyz = fxyz, endsMatch = TRUE)
integrateSimp3D(fxyz = fxyz)
</code></pre>

<hr>
<h2 id='plotSurface2D'>Contour plot of a 2D surface</h2><span id='topic+plotSurface2D'></span>

<h3>Description</h3>

<p>Convenient wrapper for plotting a contour plot of a real
function of two variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSurface2D(x = seq_len(nrow(z)), y = seq_len(ncol(z)), f, z = NULL,
  nLev = 20, levels = NULL, fVect = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotSurface2D_+3A_x">x</code>, <code id="plotSurface2D_+3A_y">y</code></td>
<td>
<p>numerical grids fore each dimension. They must be in ascending
order.</p>
</td></tr>
<tr><td><code id="plotSurface2D_+3A_f">f</code></td>
<td>
<p>function to be plot. Must take a single argument (see examples).</p>
</td></tr>
<tr><td><code id="plotSurface2D_+3A_z">z</code></td>
<td>
<p>a vector of length <code>length(x) * length(y)</code> containing the
evaluation of <code>f</code> in the bivariate grid. If not provided, it is
computed internally.</p>
</td></tr>
<tr><td><code id="plotSurface2D_+3A_nlev">nLev</code></td>
<td>
<p>the number of levels the range of <code>z</code> will be divided into.</p>
</td></tr>
<tr><td><code id="plotSurface2D_+3A_levels">levels</code></td>
<td>
<p>vector of contour levels. If not provided, it is set to
<code>quantile(z, probs = seq(0, 1, l = nLev))</code>.</p>
</td></tr>
<tr><td><code id="plotSurface2D_+3A_fvect">fVect</code></td>
<td>
<p>flag to indicate whether <code>f</code> is a vectorized function
(see examples).</p>
</td></tr>
<tr><td><code id="plotSurface2D_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="graphics.html#topic+image">image</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix <code>z</code>, invisible.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
grid &lt;- seq(-pi, pi, l = 100)
plotSurface2D(grid, grid, f = function(x) sin(x[1]) * cos(x[2]), nLev = 20)
plotSurface2D(grid, grid, f = function(x) sin(x[, 1]) * cos(x[, 2]),
              levels = seq(-1, 1, l = 10), fVect = TRUE)

</code></pre>

<hr>
<h2 id='plotSurface3D'>Visualization of a 3D surface</h2><span id='topic+plotSurface3D'></span>

<h3>Description</h3>

<p>Convenient wrapper for visualizing a real function of three
variables by means of a colour scale and alpha shading.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSurface3D(x = seq_len(nrow(t)), y = seq_len(ncol(t)),
  z = seq_len(dim(t)[3]), f, t = NULL, nLev = 20, levels = NULL,
  fVect = FALSE, size = 15, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotSurface3D_+3A_x">x</code>, <code id="plotSurface3D_+3A_y">y</code>, <code id="plotSurface3D_+3A_z">z</code></td>
<td>
<p>numerical grids for each dimension.</p>
</td></tr>
<tr><td><code id="plotSurface3D_+3A_f">f</code></td>
<td>
<p>function to be plot. Must take a single argument (see examples).</p>
</td></tr>
<tr><td><code id="plotSurface3D_+3A_t">t</code></td>
<td>
<p>a vector of length <code>length(x) * length(y) * length(z)</code>
containing the evaluation of <code>f</code> in the trivariate grid. If not
provided, it is computed internally.</p>
</td></tr>
<tr><td><code id="plotSurface3D_+3A_nlev">nLev</code></td>
<td>
<p>number of levels in the colour scale.</p>
</td></tr>
<tr><td><code id="plotSurface3D_+3A_levels">levels</code></td>
<td>
<p>vector of breaks in the colour scale. If not provided, it is
set to <code>quantile(z, probs = seq(0, 1, l = nLev))</code>.</p>
</td></tr>
<tr><td><code id="plotSurface3D_+3A_fvect">fVect</code></td>
<td>
<p>flag to indicate whether <code>f</code> is a vectorized function
(see examples).</p>
</td></tr>
<tr><td><code id="plotSurface3D_+3A_size">size</code></td>
<td>
<p>size of points in pixels.</p>
</td></tr>
<tr><td><code id="plotSurface3D_+3A_alpha">alpha</code></td>
<td>
<p>alpha value between <code>0</code> (fully transparent) and <code>1</code>
(opaque).</p>
</td></tr>
<tr><td><code id="plotSurface3D_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="rgl.html#topic+plot3d">plot3d</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector <code>t</code>, invisible.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("rgl")) {
  x &lt;- seq(-pi, pi, l = 50)
  f &lt;- function(x) 10 * (sin(x[, 1]) * cos(x[, 2]) - sin(x[, 3]))^2
  t &lt;- plotSurface3D(x, x, x, size = 10, alpha = 0.01, fVect = TRUE, f = f)
  plotSurface3D(x, x, x, t = t, size = 15, alpha = 0.1,
                levels = quantile(t, probs = seq(0, 0.1, l = 20)))
}

</code></pre>

<hr>
<h2 id='psMle'>Maximum pseudo-likelihood estimation by wrapped pseudo-likelihoods</h2><span id='topic+psMle'></span>

<h3>Description</h3>

<p>Maximum pseudo-likelihood using the Euler and Shoji&ndash;Ozaki
pseudo-likelihoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psMle(data, delta, method = c("E", "SO", "SO2"), b, jac.b, sigma2, b1, b2,
  start, lower, upper, circular = TRUE, maxK = 2, vmApprox = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psMle_+3A_data">data</code></td>
<td>
<p>a matrix of dimension <code>c(n, p)</code>.</p>
</td></tr>
<tr><td><code id="psMle_+3A_delta">delta</code></td>
<td>
<p>discretization step.</p>
</td></tr>
<tr><td><code id="psMle_+3A_method">method</code></td>
<td>
<p>a string for choosing <code>"E"</code> (Euler), <code>"SO"</code>
(Shoji&ndash;Ozaki) or <code>"SO2"</code> (Shoji&ndash;Ozaki with Ito's expansion in the
drift) method.</p>
</td></tr>
<tr><td><code id="psMle_+3A_b">b</code></td>
<td>
<p>drift function. Must return a matrix of the same size as <code>x</code>.</p>
</td></tr>
<tr><td><code id="psMle_+3A_jac.b">jac.b</code></td>
<td>
<p>jacobian of the drift function.</p>
</td></tr>
<tr><td><code id="psMle_+3A_sigma2">sigma2</code></td>
<td>
<p>diagonal of the diffusion matrix (if univariate, this is the
square of the diffusion coefficient). Must return an object of the same
size as <code>x</code>.</p>
</td></tr>
<tr><td><code id="psMle_+3A_b1">b1</code></td>
<td>
<p>first derivative of the drift function (univariate). Must return
a vector of the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="psMle_+3A_b2">b2</code></td>
<td>
<p>second derivative of the drift function (univariate). Must return
a vector of the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="psMle_+3A_start">start</code></td>
<td>
<p>starting values, a matrix with <code>p</code> columns, with each
entry representing a different starting value.</p>
</td></tr>
<tr><td><code id="psMle_+3A_lower">lower</code>, <code id="psMle_+3A_upper">upper</code></td>
<td>
<p>bound for box constraints as in method <code>"L-BFGS-B"</code>
of <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="psMle_+3A_circular">circular</code></td>
<td>
<p>flag to indicate circular data.</p>
</td></tr>
<tr><td><code id="psMle_+3A_maxk">maxK</code></td>
<td>
<p>maximum absolute winding number used if <code>circular = TRUE</code>.</p>
</td></tr>
<tr><td><code id="psMle_+3A_vmapprox">vmApprox</code></td>
<td>
<p>flag to indicate von Mises approximation to wrapped normal.
See<br /> <code><a href="#topic+momentMatchWnVm">momentMatchWnVm</a></code> and <code><a href="#topic+scoreMatchWnBvm">scoreMatchWnBvm</a></code>.</p>
</td></tr>
<tr><td><code id="psMle_+3A_...">...</code></td>
<td>
<p>further parameters passed to <code><a href="#topic+mleOptimWrapper">mleOptimWrapper</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Section 3.2 in García-Portugués et al. (2019) for details.
<code>"SO2"</code> implements Shoji and Ozai (1998)'s expansion with for
<code>p = 1</code>. <code>"SO"</code> is the same expansion, for arbitrary <code>p</code>,
but considering null second derivatives.
</p>


<h3>Value</h3>

<p>Output from <code><a href="#topic+mleOptimWrapper">mleOptimWrapper</a></code>.
</p>


<h3>References</h3>

<p>García-Portugués, E., Sørensen, M., Mardia, K. V. and Hamelryck, T. (2019)
Langevin diffusions on the torus: estimation and applications.
<em>Statistics and Computing</em>, 29(2):1&ndash;22. <a href="https://doi.org/10.1007/s11222-017-9790-2">doi:10.1007/s11222-017-9790-2</a>
</p>
<p>Shoji, I. and Ozaki, T. (1998) A statistical method of estimation and
simulation for systems of stochastic differential equations.
<em>Biometrika</em>, 85(1):240&ndash;243. <a href="https://doi.org/10.1093/biomet/85.1.240">doi:10.1093/biomet/85.1.240</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example in 1D

delta &lt;- 0.5
pars &lt;- c(0.25, 0, 2)
set.seed(12345678)
samp &lt;- rTrajWn1D(x0 = 0, alpha = pars[1], mu = pars[2], sigma = pars[3],
                  N = 100, delta = delta)
b &lt;- function(x, pars) driftWn1D(x = x, alpha = pars[1], mu = pars[2],
                                 sigma = pars[3], maxK = 2, expTrc = 30)
b1 &lt;- function(x, pars, h = 1e-4) {
  l &lt;- length(x)
  res &lt;- b(x = c(x + h, x - h), pars = pars)
  drop(res[1:l] - res[(l + 1):(2 * l)])/(2 * h)
}
b2 &lt;- function(x, pars, h = 1e-4) {
  l &lt;- length(x)
  res &lt;- b(x = c(x + h, x, x - h), pars = pars)
  drop(res[1:l] - 2 * res[(l + 1):(2 * l)] + res[(2 * l + 1):(3 * l)])/(h^2)
}
sigma2 &lt;- function(x, pars) rep(pars[3]^2, length(x))
lower &lt;- c(0.1, -pi, 0.1)
upper &lt;- c(10, pi, 10)
psMle(data = samp, delta = delta, method = "E", b = b, sigma2 = sigma2,
      start = pars, lower = lower, upper = upper)
psMle(data = samp, delta = delta, method = "E", b = b, sigma2 = sigma2,
      start = pars, lower = lower, upper = upper, vmApprox = TRUE)
psMle(data = samp, delta = delta, method = "SO2", b = b, b1 = b1,
      b2 = b2, sigma2 = sigma2, start = pars, lower = lower, upper = upper)
psMle(data = samp, delta = delta, method = "SO2", b = b, b1 = b1,
      b2 = b2, sigma2 = sigma2, start = pars, lower = lower,
      upper = upper, vmApprox = TRUE)
psMle(data = samp, delta = delta, method = "SO", b = b, b1 = b1,
      lower = lower, upper = upper, sigma2 = sigma2, start = pars)
approxMleWn1D(data = samp, delta = delta, start = pars)
mlePde1D(data = samp, delta = delta, b = b, sigma2 = sigma2,
         start = pars, lower = lower, upper = upper)

# Example in 2D

delta &lt;- 0.5
pars &lt;- c(1, 0.5, 0, 0, 0, 1, 2)
set.seed(12345678)
samp &lt;- rTrajWn2D(x0 = c(0, 0), alpha = pars[1:3], mu = pars[4:5],
                  sigma = pars[6:7], N = 100, delta = delta)
b &lt;- function(x, pars) driftWn2D(x = x, A = alphaToA(alpha = pars[1:3],
                                                     sigma = pars[6:7]),
                                 mu = pars[4:5], sigma = pars[6:7], maxK = 2,
                                 expTrc = 30)
jac.b &lt;- function(x, pars, h = 1e-4) {
  l &lt;- nrow(x)
  res &lt;- b(x = rbind(cbind(x[, 1] + h, x[, 2]),
                     cbind(x[, 1] - h, x[, 2]),
                     cbind(x[, 1], x[, 2] + h),
                     cbind(x[, 1], x[, 2] - h)), pars = pars)
  cbind(res[1:l, ] - res[(l + 1):(2 * l), ],
        res[2 * l + 1:l, ] - res[2 * l + (l + 1):(2 * l), ]) / (2 * h)
}
sigma2 &lt;- function(x, pars) matrix(pars[6:7]^2, nrow = length(x) / 2L,
                                   ncol = 2)
lower &lt;- c(0.01, 0.01, -25, -pi, -pi, 0.01, 0.01)
upper &lt;- c(25, 25, 25, pi, pi, 25, 25)
psMle(data = samp, delta = delta, method = "E", b = b, sigma2 = sigma2,
      start = pars, lower = lower, upper = upper)
psMle(data = samp, delta = delta, method = "E", b = b, sigma2 = sigma2,
      start = pars, lower = lower, upper = upper, vmApprox = TRUE)
psMle(data = samp, delta = delta, method = "SO", b = b, jac.b = jac.b,
      sigma2 = sigma2, start = pars, lower = lower, upper = upper)
approxMleWn2D(data = samp, delta = delta, start = c(pars, 0))
# Set maxit = 5 to test and avoid a very long evaluation
mlePde2D(data = samp, delta = delta, b = b, sigma2 = sigma2, start = pars,
         lower = lower, upper = upper, maxit = 5)

</code></pre>

<hr>
<h2 id='repRow'>Replication of rows and columns</h2><span id='topic+repRow'></span><span id='topic+repCol'></span>

<h3>Description</h3>

<p>Wrapper for replicating a matrix/vector by rows or columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repRow(x, n)

repCol(x, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repRow_+3A_x">x</code></td>
<td>
<p>a numerical vector or matrix of dimension <code>c(nr, nc)</code>.</p>
</td></tr>
<tr><td><code id="repRow_+3A_n">n</code></td>
<td>
<p>the number of replicates of <code>x</code> by rows or columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of dimension <code>c(nr * n, nc)</code> for <code>repRow</code> or
<code>c(nr, nc * n)</code> for <code>repCol</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>repRow(1:5, 2)
repCol(1:5, 2)
A &lt;- rbind(1:5, 5:1)
A
repRow(A, 2)
repCol(A, 2)
</code></pre>

<hr>
<h2 id='rStatWn2D'>Simulation from the stationary density of a WN diffusion in 2D</h2><span id='topic+rStatWn2D'></span>

<h3>Description</h3>

<p>Simulates from the stationary density of the WN diffusion in 2D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rStatWn2D(n, mu, alpha, sigma, rho = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rStatWn2D_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="rStatWn2D_+3A_mu">mu</code></td>
<td>
<p>a vector of length <code>2</code> giving the mean.</p>
</td></tr>
<tr><td><code id="rStatWn2D_+3A_alpha">alpha</code></td>
<td>
<p>vector of length <code>3</code> parametrizing the <code>A</code> matrix as in <code><a href="#topic+alphaToA">alphaToA</a></code>.</p>
</td></tr>
<tr><td><code id="rStatWn2D_+3A_sigma">sigma</code></td>
<td>
<p>vector of length <code>2</code> containing the <strong>square root</strong> of the diagonal of <code class="reqn">\Sigma</code>, the diffusion matrix.</p>
</td></tr>
<tr><td><code id="rStatWn2D_+3A_rho">rho</code></td>
<td>
<p>correlation coefficient of <code class="reqn">\Sigma</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of dimension <code>c(n, 2)</code> containing the samples from the stationary distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(345567)
alpha &lt;- c(2, 1, -1)
sigma &lt;- c(1.5, 2)
Sigma &lt;- diag(sigma^2)
A &lt;- alphaToA(alpha = alpha, sigma = sigma)
mu &lt;- c(pi, pi)
plot(rStatWn2D(n = 1000, mu = mu, alpha = alpha, sigma = sigma))
points(toPiInt(mvtnorm::rmvnorm(n = 1000, mean = mu,
                                sigma = solve(A) %*% Sigma / 2,
                                method = "chol")), col = 2)
</code></pre>

<hr>
<h2 id='rTpdWn2D'>Simulation from the approximated transition distribution of a WN diffusion in 2D</h2><span id='topic+rTpdWn2D'></span>

<h3>Description</h3>

<p>Simulates from the approximate transition density of the WN diffusion in 2D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rTpdWn2D(n, x0, t, mu, alpha, sigma, rho = 0, maxK = 2L, expTrc = 30)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rTpdWn2D_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="rTpdWn2D_+3A_x0">x0</code></td>
<td>
<p>a matrix of dimension <code>c(nx0, 2)</code> giving the starting values.</p>
</td></tr>
<tr><td><code id="rTpdWn2D_+3A_t">t</code></td>
<td>
<p>vector of length <code>nx0</code> containing the times between observations.</p>
</td></tr>
<tr><td><code id="rTpdWn2D_+3A_mu">mu</code></td>
<td>
<p>a vector of length <code>2</code> giving the mean.</p>
</td></tr>
<tr><td><code id="rTpdWn2D_+3A_alpha">alpha</code></td>
<td>
<p>vector of length <code>3</code> parametrizing the <code>A</code> matrix as in <code><a href="#topic+alphaToA">alphaToA</a></code>.</p>
</td></tr>
<tr><td><code id="rTpdWn2D_+3A_sigma">sigma</code></td>
<td>
<p>vector of length <code>2</code> containing the <strong>square root</strong> of the diagonal of <code class="reqn">\Sigma</code>, the diffusion matrix.</p>
</td></tr>
<tr><td><code id="rTpdWn2D_+3A_rho">rho</code></td>
<td>
<p>correlation coefficient of <code class="reqn">\Sigma</code>.</p>
</td></tr>
<tr><td><code id="rTpdWn2D_+3A_maxk">maxK</code></td>
<td>
<p>maximum absolute value of the windings considered in the computation of the WN.</p>
</td></tr>
<tr><td><code id="rTpdWn2D_+3A_exptrc">expTrc</code></td>
<td>
<p>truncation for exponential: <code>exp(x)</code> with <code>x &lt;= -expTrc</code> is set to zero. Defaults to <code>30</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of dimension <code>c(n, 2, nx0)</code> containing the <code>n</code> samples of the transition distribution,
conditioned on that the process was at <code>x0</code> at <code>t</code> instants ago. The samples are all in <code class="reqn">[\pi,\pi)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;- c(3, 2, -1)
sigma &lt;- c(0.5, 1)
mu &lt;- c(pi, pi)
x &lt;- seq(-pi, pi, l = 100)
t &lt;- 0.5
image(x, x, matrix(dTpdWou2D(x = as.matrix(expand.grid(x, x)),
                            x0 = matrix(rep(0, 100 * 2),
                                        nrow = 100 * 100, ncol = 2),
                            t = t, mu = mu, alpha = alpha, sigma = sigma,
                            maxK = 2, expTrc = 30), nrow = 100, ncol = 100),
      zlim = c(0, 0.5))
points(rTpdWn2D(n = 500, x0 = rbind(c(0, 0)), t = t, mu = mu, alpha = alpha,
                sigma = sigma)[, , 1], col = 3)
points(stepAheadWn2D(x0 = rbind(c(0, 0)), delta = t / 500,
                     A = alphaToA(alpha = alpha, sigma = sigma),
                     mu = mu, sigma = sigma, N = 500, M = 500, maxK = 2,
                     expTrc = 30), col = 4)
</code></pre>

<hr>
<h2 id='rTrajLangevin'>Simulation of trajectories of a Langevin diffusion</h2><span id='topic+rTrajLangevin'></span>

<h3>Description</h3>

<p>Simulation of an arbitrary Langevin diffusion in dimension
<code>p</code> by subsampling a fine trajectory obtained by the Euler
discretization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rTrajLangevin(x0, drift, SigDif, N = 100, delta = 0.01, NFine = ceiling(N
  * delta/deltaFine), deltaFine = min(delta/100, 0.001), circular = TRUE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rTrajLangevin_+3A_x0">x0</code></td>
<td>
<p>vector of length <code>p</code> giving the initial point.</p>
</td></tr>
<tr><td><code id="rTrajLangevin_+3A_drift">drift</code></td>
<td>
<p>drift for the diffusion.</p>
</td></tr>
<tr><td><code id="rTrajLangevin_+3A_sigdif">SigDif</code></td>
<td>
<p>matrix of size <code>c(p, p)</code> giving the infinitesimal
(constant) covariance matrix of the diffusion.</p>
</td></tr>
<tr><td><code id="rTrajLangevin_+3A_n">N</code></td>
<td>
<p>number of discretization steps in the resulting trajectory.</p>
</td></tr>
<tr><td><code id="rTrajLangevin_+3A_delta">delta</code></td>
<td>
<p>discretization step.</p>
</td></tr>
<tr><td><code id="rTrajLangevin_+3A_nfine">NFine</code></td>
<td>
<p>number of discretization steps for the fine trajectory. Must
be larger than <code>N</code>.</p>
</td></tr>
<tr><td><code id="rTrajLangevin_+3A_deltafine">deltaFine</code></td>
<td>
<p>discretization step for the fine trajectory. Must be
smaller than <code>delta</code>.</p>
</td></tr>
<tr><td><code id="rTrajLangevin_+3A_circular">circular</code></td>
<td>
<p>whether to wrap the resulting trajectory to
<code class="reqn">[-\pi,\pi)^p</code>.</p>
</td></tr>
<tr><td><code id="rTrajLangevin_+3A_...">...</code></td>
<td>
<p>parameters to be passed to <code>drift</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fine trajectory is subsampled using the indexes
<code>seq(1, NFine + 1, by = NFine / N)</code>.
</p>


<h3>Value</h3>

<p>A vector of length <code>N + 1</code> containing <code>x0</code> in the first
entry and the discretized trajectory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isRStudio &lt;- identical(.Platform$GUI, "RStudio")
if (isRStudio) {
  # 1D
  manipulate::manipulate({
    x &lt;- seq(0, N * delta, by = delta)
    plot(x, x, ylim = c(-pi, pi), type = "n",
         ylab = expression(X[t]), xlab = "t")
    linesCirc(x, rTrajLangevin(x0 = 0, drift = driftJp, SigDif = sigma,
                               alpha = alpha, mu = 0, psi = psi, N = N,
                               delta = 0.01))
    }, delta = manipulate::slider(0.01, 5.01, step = 0.1),
    N = manipulate::slider(10, 500, step = 10, initial = 200),
    alpha = manipulate::slider(0.01, 5, step = 0.1, initial = 1),
    psi = manipulate::slider(-2, 2, step = 0.1, initial = 1),
    sigma = manipulate::slider(0.01, 5, step = 0.1, initial = 1))

  # 2D
  samp &lt;- rTrajLangevin(x0 = c(0, 0), drift = driftMvm, alpha = c(1, 1),
                        mu = c(2, -1), A = diag(rep(0, 2)),
                        SigDif = diag(rep(1, 2)), N = 1000, delta = 0.1)
  plot(samp, xlim = c(-pi, pi), ylim = c(-pi, pi), pch = 19, cex = 0.25,
       xlab = expression(X[t]), ylab = expression(Y[t]), col = rainbow(1000))
  linesTorus(samp[, 1], samp[, 2], col = rainbow(1000))
}
</code></pre>

<hr>
<h2 id='rTrajMou'>Simulation of trajectories for the multivariate OU diffusion</h2><span id='topic+rTrajMou'></span>

<h3>Description</h3>

<p>Simulation of trajectories of the <em>multivariate</em>
Ornstein&ndash;Uhlenbeck (OU) diffusion
</p>
<p style="text-align: center;"><code class="reqn">dX_t=A(\mu - X_t)dt+\Sigma^\frac{1}{2}dW_t, X_0=x_0</code>
</p>
<p> using the exact transition
probability density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rTrajMou(x0, A, mu, Sigma, N = 100, delta = 0.001)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rTrajMou_+3A_x0">x0</code></td>
<td>
<p>a vector of length <code>p</code> containing initial point.</p>
</td></tr>
<tr><td><code id="rTrajMou_+3A_a">A</code></td>
<td>
<p>the drift matrix, of size <code>c(p, p)</code>.</p>
</td></tr>
<tr><td><code id="rTrajMou_+3A_mu">mu</code></td>
<td>
<p>unconditional mean of the diffusion, a vector of length <code>p</code>.</p>
</td></tr>
<tr><td><code id="rTrajMou_+3A_sigma">Sigma</code></td>
<td>
<p>square of the diffusion matrix, a matrix of size <code>c(p, p)</code>.</p>
</td></tr>
<tr><td><code id="rTrajMou_+3A_n">N</code></td>
<td>
<p>number of discretization steps in the resulting trajectory.</p>
</td></tr>
<tr><td><code id="rTrajMou_+3A_delta">delta</code></td>
<td>
<p>time discretization step.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The law of the discretized trajectory at <em>each</em> time step is
a multivariate normal with mean <code><a href="#topic+meantMou">meantMou</a></code> and covariance
matrix <code><a href="#topic+covtMou">covtMou</a></code>. See <code><a href="#topic+rTrajOu">rTrajOu</a></code> for the univariate
case (more efficient).
</p>
<p><code>solve(A) %*% Sigma</code> has to be a covariance matrix (symmetric and
positive definite) in order to have a proper transition density. For the
bivariate case, this can be ensured with the <code><a href="#topic+alphaToA">alphaToA</a></code> function.
In the multivariate case, it is ensured if <code>Sigma</code> is isotropic and
<code>A</code> is a covariance matrix.
</p>


<h3>Value</h3>

<p>A matrix of size <code>c(N + 1, p)</code> containing <code>x0</code> in the
first row and  the exact discretized trajectory on the remaining rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(987658)
data &lt;- rTrajMou(x0 = c(0, 0), A = alphaToA(alpha = c(1, 2, 0.5),
                 sigma = 1:2), mu = c(1, 1), Sigma = diag((1:2)^2),
                 N = 200, delta = 0.1)
plot(data, pch = 19, col = rainbow(201), cex = 0.25)
arrows(x0 = data[-201, 1], y0 = data[-201, 2], x1 = data[-1, 1],
       y1 = data[-1, 2], col = rainbow(201), angle = 10, length = 0.1)
</code></pre>

<hr>
<h2 id='rTrajOu'>Simulation of trajectories for the univariate OU diffusion</h2><span id='topic+rTrajOu'></span>

<h3>Description</h3>

<p>Simulation of trajectories of the <em>univariate</em>
Ornstein&ndash;Uhlenbeck (OU) diffusion
</p>
<p style="text-align: center;"><code class="reqn">dX_t=\alpha(\mu - X_t)dt+\sigma dW_t, X_0=x_0</code>
</p>
<p> using the exact
transition probability density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rTrajOu(x0, alpha, mu, sigma, N = 100, delta = 0.001)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rTrajOu_+3A_x0">x0</code></td>
<td>
<p>initial point.</p>
</td></tr>
<tr><td><code id="rTrajOu_+3A_alpha">alpha</code></td>
<td>
<p>strength of the drift.</p>
</td></tr>
<tr><td><code id="rTrajOu_+3A_mu">mu</code></td>
<td>
<p>unconditional mean of the diffusion.</p>
</td></tr>
<tr><td><code id="rTrajOu_+3A_sigma">sigma</code></td>
<td>
<p>diffusion coefficient.</p>
</td></tr>
<tr><td><code id="rTrajOu_+3A_n">N</code></td>
<td>
<p>number of discretization steps in the resulting trajectory.</p>
</td></tr>
<tr><td><code id="rTrajOu_+3A_delta">delta</code></td>
<td>
<p>time discretization step.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The law of the discretized trajectory is a multivariate normal
with mean <code><a href="#topic+meantOu">meantOu</a></code> and covariance matrix <code><a href="#topic+covstOu">covstOu</a></code>.
See <code><a href="#topic+rTrajMou">rTrajMou</a></code> for the multivariate case (less efficient for
dimension one).
</p>


<h3>Value</h3>

<p>A vector of length <code>N + 1</code> containing <code>x0</code> in the first
entry and the exact discretized trajectory on the remaining elements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isRStudio &lt;- identical(.Platform$GUI, "RStudio")
if (isRStudio) {
  manipulate::manipulate({
   set.seed(345678);
   plot(seq(0, N * delta, by = delta), rTrajOu(x0 = 0, alpha = alpha, mu = 0,
        sigma = sigma, N = N, delta = delta), ylim = c(-4, 4), type = "l",
        ylab = expression(X[t]), xlab = "t")
   }, delta = manipulate::slider(0.01, 5.01, step = 0.1),
   N = manipulate::slider(10, 500, step = 10, initial = 200),
   alpha = manipulate::slider(0.01, 5, step = 0.1, initial = 1),
   sigma = manipulate::slider(0.01, 5, step = 0.1, initial = 1))
}
</code></pre>

<hr>
<h2 id='rTrajWn1D'>Simulation of trajectories for the WN diffusion in 1D</h2><span id='topic+rTrajWn1D'></span>

<h3>Description</h3>

<p>Simulation of the Wrapped Normal (WN) diffusion in 1D by
subsampling a fine trajectory obtained by the Euler discretization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rTrajWn1D(x0, alpha, mu, sigma, N = 100, delta = 0.01, NFine = ceiling(N
  * delta/deltaFine), deltaFine = min(delta/100, 0.001))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rTrajWn1D_+3A_x0">x0</code></td>
<td>
<p>initial point.</p>
</td></tr>
<tr><td><code id="rTrajWn1D_+3A_alpha">alpha</code></td>
<td>
<p>drift parameter.</p>
</td></tr>
<tr><td><code id="rTrajWn1D_+3A_mu">mu</code></td>
<td>
<p>mean parameter. Must be in <code class="reqn">[\pi,\pi)</code>.</p>
</td></tr>
<tr><td><code id="rTrajWn1D_+3A_sigma">sigma</code></td>
<td>
<p>diffusion coefficient.</p>
</td></tr>
<tr><td><code id="rTrajWn1D_+3A_n">N</code></td>
<td>
<p>number of discretization steps in the resulting trajectory.</p>
</td></tr>
<tr><td><code id="rTrajWn1D_+3A_delta">delta</code></td>
<td>
<p>discretization step.</p>
</td></tr>
<tr><td><code id="rTrajWn1D_+3A_nfine">NFine</code></td>
<td>
<p>number of discretization steps for the fine trajectory. Must
be larger than <code>N</code>.</p>
</td></tr>
<tr><td><code id="rTrajWn1D_+3A_deltafine">deltaFine</code></td>
<td>
<p>discretization step for the fine trajectory. Must be
smaller than <code>delta</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fine trajectory is subsampled using the indexes
<code>seq(1, NFine + 1, by = NFine / N)</code>.
</p>


<h3>Value</h3>

<p>A vector of length <code>N + 1</code> containing <code>x0</code> in the first
entry and the discretized trajectory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isRStudio &lt;- identical(.Platform$GUI, "RStudio")
if (isRStudio) {
  manipulate::manipulate({
    x &lt;- seq(0, N * delta, by = delta)
    plot(x, x, ylim = c(-pi, pi), type = "n",
         ylab = expression(X[t]), xlab = "t")
    linesCirc(x, rTrajWn1D(x0 = 0, alpha = alpha, mu = 0, sigma = sigma,
                           N = N, delta = 0.01))
    }, delta = slider(0.01, 5.01, step = 0.1),
    N = manipulate::slider(10, 500, step = 10, initial = 200),
    alpha = manipulate::slider(0.01, 5, step = 0.1, initial = 1),
    sigma = manipulate::slider(0.01, 5, step = 0.1, initial = 1))
}
</code></pre>

<hr>
<h2 id='rTrajWn2D'>Simulation of trajectories for the WN diffusion in 2D</h2><span id='topic+rTrajWn2D'></span>

<h3>Description</h3>

<p>Simulation of the Wrapped Normal (WN) diffusion in 2D by
subsampling a fine trajectory obtained by the Euler discretization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rTrajWn2D(x0, alpha, mu, sigma, rho = 0, N = 100, delta = 0.01,
  NFine = ceiling(N * delta/deltaFine), deltaFine = min(delta/100, 0.001))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rTrajWn2D_+3A_x0">x0</code></td>
<td>
<p>vector of length <code>2</code> giving the initial point.</p>
</td></tr>
<tr><td><code id="rTrajWn2D_+3A_alpha">alpha</code></td>
<td>
<p>vector of length <code>3</code> parametrizing the <code>A</code> matrix as in <code><a href="#topic+alphaToA">alphaToA</a></code>.</p>
</td></tr>
<tr><td><code id="rTrajWn2D_+3A_mu">mu</code></td>
<td>
<p>a vector of length <code>2</code> giving the mean.</p>
</td></tr>
<tr><td><code id="rTrajWn2D_+3A_sigma">sigma</code></td>
<td>
<p>vector of length <code>2</code> containing the <strong>square root</strong> of the diagonal of <code class="reqn">\Sigma</code>, the diffusion matrix.</p>
</td></tr>
<tr><td><code id="rTrajWn2D_+3A_rho">rho</code></td>
<td>
<p>correlation coefficient of <code class="reqn">\Sigma</code>.</p>
</td></tr>
<tr><td><code id="rTrajWn2D_+3A_n">N</code></td>
<td>
<p>number of discretization steps in the resulting trajectory.</p>
</td></tr>
<tr><td><code id="rTrajWn2D_+3A_delta">delta</code></td>
<td>
<p>discretization step.</p>
</td></tr>
<tr><td><code id="rTrajWn2D_+3A_nfine">NFine</code></td>
<td>
<p>number of discretization steps for the fine trajectory. Must
be larger than <code>N</code>.</p>
</td></tr>
<tr><td><code id="rTrajWn2D_+3A_deltafine">deltaFine</code></td>
<td>
<p>discretization step for the fine trajectory. Must be
smaller than <code>delta</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fine trajectory is subsampled using the indexes
<code>seq(1, NFine + 1, by = NFine / N)</code>.
</p>


<h3>Value</h3>

<p>A matrix of size <code>c(N + 1, 2)</code> containing <code>x0</code> in the
first entry and the discretized trajectory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>samp &lt;- rTrajWn2D(x0 = c(0, 0), alpha = c(1, 1, -0.5), mu = c(pi, pi),
                    sigma = c(1, 1), N = 1000, delta = 0.01)
plot(samp, xlim = c(-pi, pi), ylim = c(-pi, pi), pch = 19, cex = 0.25,
     xlab = expression(X[t]), ylab = expression(Y[t]), col = rainbow(1000))
linesTorus(samp[, 1], samp[, 2], col = rainbow(1000))
</code></pre>

<hr>
<h2 id='safeSoftMax'>Safe softmax function for computing weights</h2><span id='topic+safeSoftMax'></span>

<h3>Description</h3>

<p>Computes the weights <code class="reqn">w_i = \frac{e^{p_i}}{\sum_{j=1}^k e^{p_j}}</code> from <code class="reqn">p_i</code>, <code class="reqn">i=1,\ldots,k</code>
in a safe way to avoid overflows and to truncate automatically to zero low values of <code class="reqn">w_i</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>safeSoftMax(logs, expTrc = 30)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="safeSoftMax_+3A_logs">logs</code></td>
<td>
<p>matrix of logarithms where each row contains a set of <code class="reqn">p_1,\ldots,p_k</code> to compute the weights from.</p>
</td></tr>
<tr><td><code id="safeSoftMax_+3A_exptrc">expTrc</code></td>
<td>
<p>truncation for exponential: <code>exp(x)</code> with <code>x &lt;= -expTrc</code> is set to zero. Defaults to <code>30</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>logs</code> argument must be always a matrix.
</p>


<h3>Value</h3>

<p>A matrix of the size as <code>logs</code> containing the weights for each row.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A matrix
safeSoftMax(rbind(1:10, 20:11))
rbind(exp(1:10) / sum(exp(1:10)), exp(20:11) / sum(exp(20:11)))

# A row-matrix
safeSoftMax(rbind(-100:100), expTrc = 30)
exp(-100:100) / sum(exp(-100:100))
</code></pre>

<hr>
<h2 id='scoreMatchWnBvm'>Score and moment matching of a univariate or bivariate wrapped normal
by a von Mises</h2><span id='topic+scoreMatchWnBvm'></span><span id='topic+scoreMatchWnVm'></span><span id='topic+momentMatchWnVm'></span>

<h3>Description</h3>

<p>Given a wrapped normal density, find the parameters of a von
Mises that matches it according to two characteristics: moments and scores.
Score matching estimators are available for univariate and bivariate cases
and moment matching only for the former.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoreMatchWnBvm(Sigma = NULL, invSigma)

scoreMatchWnVm(sigma, sigma2 = NULL)

momentMatchWnVm(sigma, sigma2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scoreMatchWnBvm_+3A_sigma">Sigma</code>, <code id="scoreMatchWnBvm_+3A_invsigma">invSigma</code></td>
<td>
<p>covariance or precision matrix of the bivariate wrapped
normal.</p>
</td></tr>
<tr><td><code id="scoreMatchWnBvm_+3A_sigma">sigma</code>, <code id="scoreMatchWnBvm_+3A_sigma2">sigma2</code></td>
<td>
<p>standard deviation or variance of the wrapped normal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the precision matrix is singular or if there are no solutions for
the score matching estimator, <code>c(0, 0, 0)</code> is returned.
</p>


<h3>Value</h3>

<p>Vector of parameters <code class="reqn">(\kappa_1,\kappa_2,\lambda)</code>, where
<code class="reqn">(\kappa_1,\kappa_2,2\lambda)</code> is a suitable input for <code>kappa</code> in
<code>dBvm</code>.
</p>


<h3>References</h3>

<p>Mardia, K. V., Kent, J. T., and Laha, A. K. (2016). Score matching estimators
for directional distributions. <em>arXiv:1604.0847</em>.
<a href="https://arxiv.org/abs/1604.08470">https://arxiv.org/abs/1604.08470</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Univariate WN approximation
sigma &lt;- 0.5
curve(dWn1D(x = x, mu = 0, sigma = sigma), from = -pi, to = pi,
      ylab = "Density", ylim = c(0, 1))
curve(dVm(x = x, mu = 0, kappa = momentMatchWnVm(sigma = sigma)), from = -pi,
      to = pi, col = "red", add = TRUE)
curve(dVm(x = x, mu = 0, kappa = scoreMatchWnVm(sigma = sigma)), from = -pi,
      to = pi, col = "green", add = TRUE)

# Bivariate WN approximation

# WN
alpha &lt;- c(2, 1, 1)
sigma &lt;- c(1, 1)
mu &lt;- c(pi / 2, pi / 2)
x &lt;- seq(-pi, pi, l = 101)[-101]
plotSurface2D(x, x, f = function(x) dStatWn2D(x = x, alpha = alpha, mu = mu,
                                              sigma = sigma), fVect = TRUE)
A &lt;- alphaToA(alpha = alpha, sigma = sigma)
S &lt;- 0.5 * solve(A) %*% diag(sigma)

# Score matching
kappa &lt;- scoreMatchWnBvm(Sigma = S)

# dBvm uses lambda / 2 in the exponent
plotSurface2D(x, x, f = function(x) dBvm(x = x, mu = mu,
                                        kappa = c(kappa[1:2], 2 * kappa[3])),
             fVect = TRUE)

# With singular Sigma
invSigma &lt;- matrix(c(1, sqrt(0.999), sqrt(0.999), 1), nrow = 2, ncol = 2)
scoreMatchWnBvm(invSigma = invSigma)
invSigma &lt;- matrix(1, nrow = 2, ncol = 2)
scoreMatchWnBvm(invSigma = invSigma)
</code></pre>

<hr>
<h2 id='sigmaDiff'>High-frequency estimate of the diffusion matrix</h2><span id='topic+sigmaDiff'></span>

<h3>Description</h3>

<p>Estimation of the <code class="reqn">\Sigma</code> in the multivariate diffusion
</p>
<p style="text-align: center;"><code class="reqn">dX_t=b(X_t)dt+\Sigma dW_t</code>
</p>

<p>by the high-frequency estimate </p>
<p style="text-align: center;"><code class="reqn">
\hat\Sigma = \frac{1}{N\Delta}\sum_{i=1}^N(X_i-X_{i-1})(X_i-X_{i-1})^T</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>sigmaDiff(data, delta, circular = TRUE, diagonal = FALSE,
  isotropic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sigmaDiff_+3A_data">data</code></td>
<td>
<p>vector or matrix of size <code>c(N, p)</code> containing the
discretized process.</p>
</td></tr>
<tr><td><code id="sigmaDiff_+3A_delta">delta</code></td>
<td>
<p>discretization step.</p>
</td></tr>
<tr><td><code id="sigmaDiff_+3A_circular">circular</code></td>
<td>
<p>whether the process is circular or not.</p>
</td></tr>
<tr><td><code id="sigmaDiff_+3A_diagonal">diagonal</code>, <code id="sigmaDiff_+3A_isotropic">isotropic</code></td>
<td>
<p>enforce different constraints for the diffusion
matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Section 3.1 in García-Portugués et al. (2019) for details.
</p>


<h3>Value</h3>

<p>The estimated diffusion matrix of size <code>c(p, p)</code>.
</p>


<h3>References</h3>

<p>García-Portugués, E., Sørensen, M., Mardia, K. V. and Hamelryck, T. (2019)
Langevin diffusions on the torus: estimation and applications.
<em>Statistics and Computing</em>, 29(2):1&ndash;22. <a href="https://doi.org/10.1007/s11222-017-9790-2">doi:10.1007/s11222-017-9790-2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1D
x &lt;- drop(euler1D(x0 = 0, alpha = 1, mu = 0, sigma = 1, N = 1000,
                  delta = 0.01))
sigmaDiff(x, delta = 0.01)

# 2D
x &lt;- t(euler2D(x0 = rbind(c(pi, pi)), A = rbind(c(2, 1), c(1, 2)),
               mu = c(pi, pi), sigma = c(1, 1), N = 1000,
               delta = 0.01)[1, , ])
sigmaDiff(x, delta = 0.01)
sigmaDiff(x, delta = 0.01, circular = FALSE)
sigmaDiff(x, delta = 0.01, diagonal = TRUE)
sigmaDiff(x, delta = 0.01, isotropic = TRUE)
</code></pre>

<hr>
<h2 id='solveTridiag'>Thomas algorithm for solving tridiagonal matrix systems, with optional presaving of LU decomposition</h2><span id='topic+solveTridiag'></span><span id='topic+solveTridiagMatConsts'></span><span id='topic+solvePeriodicTridiag'></span><span id='topic+forwardSweepTridiag'></span><span id='topic+forwardSweepPeriodicTridiag'></span>

<h3>Description</h3>

<p>Implementation of the Thomas algorithm to solve efficiently the tridiagonal matrix system
</p>
<p style="text-align: center;"><code class="reqn">b_1 x_1 + c_1 x_2 + a_1x_n = d_1</code>
</p>

<p style="text-align: center;"><code class="reqn">a_2 x_1 + b_2 x_2 + c_2x_3 = d_2</code>
</p>

<p style="text-align: center;"><code class="reqn">\vdots \vdots \vdots</code>
</p>

<p style="text-align: center;"><code class="reqn">a_{n-1} x_{n-2} + b_{n-1} x_{n-1} + c_{n-1}x_{n} = d_{n-1}</code>
</p>

<p style="text-align: center;"><code class="reqn">c_n x_1 + a_{n} x_{n-1} + b_nx_n = d_n</code>
</p>

<p>with <code class="reqn">a_1=c_n=0</code> (usual tridiagonal matrix). If <code class="reqn">a_1\neq0</code> or <code class="reqn">c_n\neq0</code> (circulant tridiagonal matrix), then the Sherman&ndash;Morrison formula is employed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solveTridiag(a, b, c, d, LU = 0L)

solveTridiagMatConsts(a, b, c, d, LU = 0L)

solvePeriodicTridiag(a, b, c, d, LU = 0L)

forwardSweepTridiag(a, b, c)

forwardSweepPeriodicTridiag(a, b, c)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="solveTridiag_+3A_a">a</code>, <code id="solveTridiag_+3A_b">b</code>, <code id="solveTridiag_+3A_c">c</code></td>
<td>
<p>subdiagonal (below main diagonal), diagonal and superdiagonal (above main diagonal), respectively. They all are vectors of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="solveTridiag_+3A_d">d</code></td>
<td>
<p>vector of constant terms, of length <code>n</code>. For <code>solveTridiagMatConsts</code>, it can be a matrix with <code>n</code> rows.</p>
</td></tr>
<tr><td><code id="solveTridiag_+3A_lu">LU</code></td>
<td>
<p>flag denoting if the forward sweep encoding the LU decomposition is supplied in vectors <code>b</code> and <code>c</code>. See details and examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Thomas algorithm is stable if the matrix is diagonally dominant.
</p>
<p>For the periodic case, two non-periodic tridiagonal systems with different constant terms (but same coefficients) are solved using <code>solveTridiagMatConsts</code>. These two solutions are combined by the Sherman&ndash;Morrison formula to obtain the solution to the periodic system.
</p>
<p>Note that the output of <code>solveTridiag</code> and <code>solveTridiagMatConsts</code> are independent from the values of <code>a[1]</code> and <code>c[n]</code>, but <code>solvePeriodicTridiag</code> is not.
</p>
<p>If <code>LU</code> is <code>TRUE</code>, then <code>b</code> and <code>c</code> must be precomputed with <code>forwardSweepTridiag</code> or<br /> <code>forwardSweepPeriodicTridiag</code> for its use in the call of the appropriate solver, which will be slightly faster.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>solve*</code> functions: the solution, a vector of length <code>n</code> and a matrix with <code>n</code> rows for<br /> <code>solveTridiagMatConsts</code>.
</p>
</li>
<li> <p><code>forward*</code> functions: the matrix <code>cbind(b, c)</code> creating the suitable <code>b</code> and <code>c</code> arguments for calling <code>solve*</code> when <code>LU</code> is <code>TRUE</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Thomas, J. W. (1995). <em>Numerical Partial Differential Equations: Finite Difference Methods</em>. Springer, New York. <a href="https://doi.org/10.1007/978-1-4899-7278-1">doi:10.1007/978-1-4899-7278-1</a>
</p>
<p>Conte, S. D. and de Boor, C. (1980). <em>Elementary Numerical Analysis: An Algorithmic Approach</em>. Third edition. McGraw-Hill, New York. <a href="https://doi.org/10.1137/1.9781611975208">doi:10.1137/1.9781611975208</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Tridiagonal matrix
n &lt;- 10
a &lt;- rnorm(n, 3, 1)
b &lt;- rnorm(n, 10, 1)
c &lt;- rnorm(n, 0, 1)
d &lt;- rnorm(n, 0, 1)
A &lt;- matrix(0, nrow = n, ncol = n)
diag(A) &lt;- b
for (i in 1:(n - 1)) {
  A[i + 1, i] &lt;- a[i + 1]
  A[i, i + 1] &lt;- c[i]
}
A

# Same solutions
drop(solveTridiag(a = a, b = b, c = c, d = d))
solve(a = A, b = d)

# Presaving the forward sweep (encodes the LU factorization)
LU &lt;- forwardSweepTridiag(a = a, b = b, c = c)
drop(solveTridiag(a = a, b = LU[, 1], c = LU[, 2], d = d, LU = 1))

# With equal coefficient matrix
solveTridiagMatConsts(a = a, b = b, c = c, d = cbind(d, d + 1))
cbind(solve(a = A, b = d), solve(a = A, b = d + 1))
LU &lt;- forwardSweepTridiag(a = a, b = b, c = c)
solveTridiagMatConsts(a = a, b = LU[, 1], c = LU[, 2], d = cbind(d, d + 1), LU = 1)

# Periodic matrix
A[1, n] &lt;- a[1]
A[n, 1] &lt;- c[n]
A

# Same solutions
drop(solvePeriodicTridiag(a = a, b = b, c = c, d = d))
solve(a = A, b = d)

# Presaving the forward sweep (encodes the LU factorization)
LU &lt;- forwardSweepPeriodicTridiag(a = a, b = b, c = c)
drop(solvePeriodicTridiag(a = a, b = LU[, 1], c = LU[, 2], d = d, LU = 1))
</code></pre>

<hr>
<h2 id='stepAheadWn1D'>Multiple simulation of trajectory ends of the WN or vM diffusion in 1D</h2><span id='topic+stepAheadWn1D'></span>

<h3>Description</h3>

<p>Simulates <code>M</code> trajectories starting from different initial values <code>x0</code> of the WN or vM diffusion in 1D, by the Euler method, and returns their ends.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepAheadWn1D(x0, alpha, mu, sigma, M, N = 100L, delta = 0.01, type = 1L,
  maxK = 2L, expTrc = 30)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stepAheadWn1D_+3A_x0">x0</code></td>
<td>
<p>vector of length <code>nx0</code> giving the initial points.</p>
</td></tr>
<tr><td><code id="stepAheadWn1D_+3A_alpha">alpha</code></td>
<td>
<p>drift parameter.</p>
</td></tr>
<tr><td><code id="stepAheadWn1D_+3A_mu">mu</code></td>
<td>
<p>mean parameter. Must be in <code class="reqn">[\pi,\pi)</code>.</p>
</td></tr>
<tr><td><code id="stepAheadWn1D_+3A_sigma">sigma</code></td>
<td>
<p>diffusion coefficient.</p>
</td></tr>
<tr><td><code id="stepAheadWn1D_+3A_m">M</code></td>
<td>
<p>number of Monte Carlo replicates.</p>
</td></tr>
<tr><td><code id="stepAheadWn1D_+3A_n">N</code></td>
<td>
<p>number of discretization steps.</p>
</td></tr>
<tr><td><code id="stepAheadWn1D_+3A_delta">delta</code></td>
<td>
<p>discretization step.</p>
</td></tr>
<tr><td><code id="stepAheadWn1D_+3A_type">type</code></td>
<td>
<p>integer giving the type of diffusion. Currently, only <code>1</code> for WN and <code>2</code> for vM are supported.</p>
</td></tr>
<tr><td><code id="stepAheadWn1D_+3A_maxk">maxK</code></td>
<td>
<p>maximum absolute value of the windings considered in the computation of the WN.</p>
</td></tr>
<tr><td><code id="stepAheadWn1D_+3A_exptrc">expTrc</code></td>
<td>
<p>truncation for exponential: <code>exp(x)</code> with <code>x &lt;= -expTrc</code> is set to zero. Defaults to <code>30</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size <code>c(nx0, M)</code> containing the <code>M</code> trajectory ends for each starting value <code>x0</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100
nx0 &lt;- 20
x0 &lt;- seq(-pi, pi, l = nx0 + 1)[-(nx0 + 1)]
set.seed(12345678)
samp1 &lt;- euler1D(x0 = x0, mu = 0, alpha = 3, sigma = 1, N = N,
                 delta = 0.01, type = 2)
tt &lt;- seq(0, 1, l = N + 1)
plot(rep(0, nx0), x0, pch = 16, col = rainbow(nx0), xlim = c(0, 1))
for (i in 1:nx0) linesCirc(tt, samp1[i, ], col = rainbow(nx0)[i])
set.seed(12345678)
samp2 &lt;- stepAheadWn1D(x0 = x0, mu = 0, alpha = 3, sigma = 1, M = 1,
                       N = N, delta = 0.01, type = 2)
points(rep(1, nx0), samp2[, 1], pch = 16, col = rainbow(nx0))
samp1[, N + 1]
samp2[, 1]
</code></pre>

<hr>
<h2 id='stepAheadWn2D'>Multiple simulation of trajectory ends of the WN or MvM diffusion in 2D</h2><span id='topic+stepAheadWn2D'></span>

<h3>Description</h3>

<p>Simulates <code>M</code> trajectories starting from different initial values <code>x0</code> of the WN or MvM diffusion in 2D, by the Euler method, and returns their ends.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepAheadWn2D(x0, mu, A, sigma, rho = 0, M = 100L, N = 100L,
  delta = 0.01, type = 1L, maxK = 2L, expTrc = 30)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stepAheadWn2D_+3A_x0">x0</code></td>
<td>
<p>matrix of size <code>c(nx0, 2)</code> giving the initial points.</p>
</td></tr>
<tr><td><code id="stepAheadWn2D_+3A_mu">mu</code></td>
<td>
<p>a vector of length <code>2</code> giving the mean.</p>
</td></tr>
<tr><td><code id="stepAheadWn2D_+3A_a">A</code></td>
<td>
<p>drift matrix of size <code>c(2, 2)</code>.</p>
</td></tr>
<tr><td><code id="stepAheadWn2D_+3A_sigma">sigma</code></td>
<td>
<p>vector of length <code>2</code> containing the <strong>square root</strong> of the diagonal of <code class="reqn">\Sigma</code>, the diffusion matrix.</p>
</td></tr>
<tr><td><code id="stepAheadWn2D_+3A_rho">rho</code></td>
<td>
<p>correlation coefficient of <code class="reqn">\Sigma</code>.</p>
</td></tr>
<tr><td><code id="stepAheadWn2D_+3A_m">M</code></td>
<td>
<p>number of Monte Carlo replicates.</p>
</td></tr>
<tr><td><code id="stepAheadWn2D_+3A_n">N</code></td>
<td>
<p>number of discretization steps.</p>
</td></tr>
<tr><td><code id="stepAheadWn2D_+3A_delta">delta</code></td>
<td>
<p>discretization step.</p>
</td></tr>
<tr><td><code id="stepAheadWn2D_+3A_type">type</code></td>
<td>
<p>integer giving the type of diffusion. Currently, only <code>1</code> for WN and <code>2</code> for vM are supported.</p>
</td></tr>
<tr><td><code id="stepAheadWn2D_+3A_maxk">maxK</code></td>
<td>
<p>maximum absolute value of the windings considered in the computation of the WN.</p>
</td></tr>
<tr><td><code id="stepAheadWn2D_+3A_exptrc">expTrc</code></td>
<td>
<p>truncation for exponential: <code>exp(x)</code> with <code>x &lt;= -expTrc</code> is set to zero. Defaults to <code>30</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of size <code>c(nx0, 2, M)</code> containing the <code>M</code> trajectory ends for each starting value <code>x0</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100
nx0 &lt;- 3
x0 &lt;- seq(-pi, pi, l = nx0 + 1)[-(nx0 + 1)]
x0 &lt;- as.matrix(expand.grid(x0, x0))
nx0 &lt;- nx0^2
set.seed(12345678)
samp1 &lt;- euler2D(x0 = x0, mu = c(0, 0), A = rbind(c(3, 1), 1:2),
                 sigma = c(1, 1), N = N, delta = 0.01, type = 2)
plot(x0[, 1], x0[, 2], xlim = c(-pi, pi), ylim = c(-pi, pi), pch = 16,
     col = rainbow(nx0))
for (i in 1:nx0) linesTorus(samp1[i, 1, ], samp1[i, 2, ],
                           col = rainbow(nx0, alpha = 0.75)[i])
set.seed(12345678)
samp2 &lt;- stepAheadWn2D(x0 = x0, mu = c(0, 0), A = rbind(c(3, 1), 1:2),
                       sigma = c(1, 1), M = 2, N = N, delta = 0.01,
                       type = 2)
points(samp2[, 1, 1], samp2[, 2, 1], pch = 16, col = rainbow(nx0))
samp1[, , N + 1]
samp2[, , 1]
</code></pre>

<hr>
<h2 id='table.ramp.colorRamps'>Constructs color palettes with sharp breaks</h2><span id='topic+table.ramp.colorRamps'></span>

<h3>Description</h3>

<p>See <code>?colorRamps::rgb.tables</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table.ramp.colorRamps(n, mid = 0.5, sill = 0.5, base = 1, height = 1)
</code></pre>

<hr>
<h2 id='toPiInt'>Wrapping of radians to its principal values</h2><span id='topic+toPiInt'></span><span id='topic+to2PiInt'></span><span id='topic+toInt'></span>

<h3>Description</h3>

<p>Utilities for transforming a reals into <code class="reqn">[-\pi, \pi)</code>,
<code class="reqn">[0, 2\pi)</code> or <code class="reqn">[a, b)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toPiInt(x)

to2PiInt(x)

toInt(x, a, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="toPiInt_+3A_x">x</code></td>
<td>
<p>a vector, matrix or object for whom <code><a href="base.html#topic+Arithmetic">Arithmetic</a></code>
is defined.</p>
</td></tr>
<tr><td><code id="toPiInt_+3A_a">a</code>, <code id="toPiInt_+3A_b">b</code></td>
<td>
<p>the lower and upper limits of <code class="reqn">[a, b)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code class="reqn">b</code> is <b>excluded</b> from the result, see examples.
</p>


<h3>Value</h3>

<p>The wrapped vector in the chosen interval.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Wrapping of angles
x &lt;- seq(-3 * pi, 5 * pi, l = 100)
toPiInt(x)
to2PiInt(x)

# Transformation to [1, 5)
x &lt;- 1:10
toInt(x, 1, 5)
toInt(x + 1, 1, 5)

# Transformation to [1, 5]
toInt(x, 1, 6)
toInt(x + 1, 1, 6)
</code></pre>

<hr>
<h2 id='torusAxis'>Draws pretty axis labels for circular variables</h2><span id='topic+torusAxis'></span>

<h3>Description</h3>

<p>Wrapper for drawing pretty axis labels for circular variables.
To be invoked after <code>plot</code> with <code>axes = FALSE</code> has been called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>torusAxis(sides = 1:2, twoPi = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="torusAxis_+3A_sides">sides</code></td>
<td>
<p>an integer vector specifying which side of the plot the axes are
to be drawn on. The axes are placed as follows: <code>1</code> = below,
<code>2</code> = left, <code>3</code> = above, and <code>4</code> = right.</p>
</td></tr>
<tr><td><code id="torusAxis_+3A_twopi">twoPi</code></td>
<td>
<p>flag indicating that <code class="reqn">[0,2\pi)</code> is the support, instead of
<code class="reqn">[-\pi,\pi)</code>.</p>
</td></tr>
<tr><td><code id="torusAxis_+3A_...">...</code></td>
<td>
<p>further parameters passed to <code><a href="graphics.html#topic+axis">axis</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calls <code><a href="graphics.html#topic+box">box</a></code>.
</p>


<h3>Value</h3>

<p>This function is usually invoked for its side effect, which is to
add axes to an already existing plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid &lt;- seq(-pi, pi, l = 100)
plotSurface2D(grid, grid, f = function(x) sin(x[1]) * cos(x[2]),
              nLev = 20, axes = FALSE)
torusAxis()
</code></pre>

<hr>
<h2 id='torusAxis3d'>Draws pretty axis labels for circular variables</h2><span id='topic+torusAxis3d'></span>

<h3>Description</h3>

<p>Wrapper for drawing pretty axis labels for circular variables.
To be invoked after <code>plot3d</code> with <code>axes = FALSE</code> and
<code>box = FALSE</code> has been called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>torusAxis3d(sides = 1:3, twoPi = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="torusAxis3d_+3A_sides">sides</code></td>
<td>
<p>an integer vector specifying which side of the plot the axes are
to be drawn on. The axes are placed as follows: <code>1</code> = x, <code>2</code> = y,
<code>3</code> = z.</p>
</td></tr>
<tr><td><code id="torusAxis3d_+3A_twopi">twoPi</code></td>
<td>
<p>flag indicating that <code class="reqn">[0,2\pi)</code> is the support, instead of
<code class="reqn">[-\pi,\pi)</code>.</p>
</td></tr>
<tr><td><code id="torusAxis3d_+3A_...">...</code></td>
<td>
<p>further parameters passed to <code><a href="rgl.html#topic+axes3d">axis3d</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calls <code><a href="rgl.html#topic+axes3d">box3d</a></code>.
</p>


<h3>Value</h3>

<p>This function is usually invoked for its side effect, which is to
add axes to an already existing plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("rgl")) {
  n &lt;- 50
  x &lt;- toPiInt(rnorm(n, mean = seq(-pi, pi, l = n), sd = 0.5))
  y &lt;- toPiInt(rnorm(n, mean = seq(-pi, pi, l = n), sd = 0.5))
  z &lt;- toPiInt(x + y + rnorm(n, mean = seq(-pi, pi, l = n), sd = 0.5))
  rgl::plot3d(x, y, z, xlim = c(-pi, pi), ylim = c(-pi, pi),
              zlim = c(-pi, pi), col = rainbow(n), size = 2,
              box = FALSE, axes = FALSE)
  torusAxis3d()
}

</code></pre>

<hr>
<h2 id='unwrapCircSeries'>Unwrapping of circular time series</h2><span id='topic+unwrapCircSeries'></span>

<h3>Description</h3>

<p>Completes a circular time series to a linear one by
computing the closest wind numbers. Useful for plotting circular
trajectories with crossing of boundaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unwrapCircSeries(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unwrapCircSeries_+3A_x">x</code></td>
<td>
<p>wrapped angles. Must be a vector or a matrix, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a matrix then the unwrapping is carried out
row-wise, on each column separately.
</p>


<h3>Value</h3>

<p>A vector or matrix containing a choice of unwrapped angles of
<code>x</code> that maximizes linear continuity.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Vectors
x &lt;- c(-pi, -pi/2, pi - 0.1, -pi + 0.2)
u &lt;- unwrapCircSeries(x)
max(abs(toPiInt(u) - x))
plot(toPiInt(x), ylim = c(-pi, pi))
for(k in -1:1) lines(u + 2 * k * pi)

# Matrices
N &lt;- 100
set.seed(234567)
x &lt;- t(euler2D(x0 = rbind(c(0, 0)), A = diag(c(1, 1)), sigma = rep(1, 2),
                 mu = c(pi, pi), N = N, delta = 1, type = 2)[1, , ])
u &lt;- unwrapCircSeries(x)
max(abs(toPiInt(u) - x))
plot(x, xlim = c(-pi, pi), ylim = c(-pi, pi))
for(k1 in -3:3) for(k2 in -3:3) lines(u[, 1] + 2 * k1 * pi,
                                      u[, 2] + 2 * k2 * pi, col = gray(0.5))
</code></pre>

<hr>
<h2 id='weightsLinearInterp1D'>Weights for linear interpolation in 1D and 2D</h2><span id='topic+weightsLinearInterp1D'></span><span id='topic+weightsLinearInterp2D'></span>

<h3>Description</h3>

<p>Computation of weights for linear interpolation in 1D and 2D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightsLinearInterp1D(x, g1, g2, circular = FALSE)

weightsLinearInterp2D(x, y, gx1, gx2, gy1, gy2, circular = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weightsLinearInterp1D_+3A_x">x</code>, <code id="weightsLinearInterp1D_+3A_y">y</code></td>
<td>
<p>vectors of length <code>n</code> containing the points where the
weights should be computed.</p>
</td></tr>
<tr><td><code id="weightsLinearInterp1D_+3A_g1">g1</code>, <code id="weightsLinearInterp1D_+3A_g2">g2</code>, <code id="weightsLinearInterp1D_+3A_gx1">gx1</code>, <code id="weightsLinearInterp1D_+3A_gx2">gx2</code>, <code id="weightsLinearInterp1D_+3A_gy1">gy1</code>, <code id="weightsLinearInterp1D_+3A_gy2">gy2</code></td>
<td>
<p>vectors of length <code>n</code> such that
<code>g1 &lt;= x &lt;= g2</code> for 1D and <code>gx1 &lt;= x &lt;= gx2</code> and
<code>gy1 &lt;= y &lt;= gy2</code> for 2D.</p>
</td></tr>
<tr><td><code id="weightsLinearInterp1D_+3A_circular">circular</code></td>
<td>
<p>flag to indicate whether the differences should be
circularly wrapped.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the examples for how to use the weights for linear binning.
</p>


<h3>Value</h3>


<ul>
<li><p> For 1D, a matrix of size <code>c(n, 2)</code> containing the weights for
lower (<code>g1</code>) and upper (<code>g1</code>) bins.
</p>
</li>
<li><p> For 2D, a matrix of size <code>c(n, 4)</code> containing the weights for
lower-lower (<code>g1x</code>, <code>g1y</code>), <em>upper-lower</em> (<code>g2x</code>,
<code>g1y</code>), <em>lower-upper</em> (<code>g1x</code>, <code>g2y</code>) and upper-upper
(<code>g2x</code>, <code>g2y</code>) bins. <code>cbind(g1x, g1y)</code>,
<code>cbind(g1x, g1y)</code>, <code>cbind(g1x, g1y)</code> and <code>cbind(g2x, g2y)</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># 1D, linear
x &lt;- seq(-4, 4, by = 0.5)
g1 &lt;- x - 0.25
g2 &lt;- x + 0.5
w &lt;- weightsLinearInterp1D(x = x, g1 = g1, g2 = g2)
f &lt;- function(x) 2 * x + 1
rowSums(w * cbind(f(g1), f(g2)))
f(x)

# 1D, circular
x &lt;- seq(-pi, pi, by = 0.5)
g1 &lt;- toPiInt(x - 0.25)
g2 &lt;- toPiInt(x + 0.5)
w &lt;- weightsLinearInterp1D(x = x, g1 = g1, g2 = g2, circular = TRUE)
f &lt;- function(x) 2 * sin(x) + 1
rowSums(w * cbind(f(g1), f(g2)))
f(x)

# 2D, linear
x &lt;- seq(-4, 4, by = 0.5)
y &lt;- 2 * x
gx1 &lt;- x - 0.25
gx2 &lt;- x + 0.5
gy1 &lt;- y - 0.75
gy2 &lt;- y + 0.25
w &lt;- weightsLinearInterp2D(x = x, y = y, gx1 = gx1, gx2 = gx2,
                           gy1 = gy1, gy2 = gy2)
f &lt;- function(x, y) 2 * x + 3 * y + 1
rowSums(w * cbind(f(gx1, gy1), f(gx2, gy1), f(gx1, gy2), f(gx2, gy2)))
f(x, y)

# 2D, circular
x &lt;- seq(-pi, pi, by = 0.5)
y &lt;- toPiInt(2 * x)
gx1 &lt;- toPiInt(x - 0.25)
gx2 &lt;- toPiInt(x + 0.5)
gy1 &lt;- toPiInt(y - 0.75)
gy2 &lt;- toPiInt(y + 0.25)
w &lt;- weightsLinearInterp2D(x = x, y = y, gx1 = gx1, gx2 = gx2,
                           gy1 = gy1, gy2 = gy2, circular = TRUE)
f &lt;- function(x, y) 2 * sin(x) + 3 * cos(y) + 1
rowSums(w * cbind(f(gx1, gy1), f(gx2, gy1), f(gx1, gy2), f(gx2, gy2)))
f(x, y)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
