<!DOCTYPE html><html lang="en-US"><head><title>Help for package hrf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hrf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aic_Param'><p>aic</p></a></li>
<li><a href='#ar_order_Param'><p>ar_order</p></a></li>
<li><a href='#ar_smooth_Param'><p>ar_smooth</p></a></li>
<li><a href='#BayesGLM_argChecks'><p>Bayes GLM arg checks</p></a></li>
<li><a href='#BOLD_Param_BayesGLM'><p>BOLD</p></a></li>
<li><a href='#brainstructures_Param_BayesGLM'><p>brainstructures</p></a></li>
<li><a href='#cbind2'><p><code>cbind</code> if first argument might be <code>NULL</code></p></a></li>
<li><a href='#cderiv'><p>Central derivative</p></a></li>
<li><a href='#Connectome_Workbench_Description'><p>Connectome Workbench</p></a></li>
<li><a href='#design_Param_BayesGLM'><p>design</p></a></li>
<li><a href='#do_QC'><p>Mask out invalid data</p></a></li>
<li><a href='#faces_Param'><p>faces</p></a></li>
<li><a href='#field_names_Param'><p>field_names</p></a></li>
<li><a href='#format_design'><p>Format design</p></a></li>
<li><a href='#format_EV'><p>Is this a valid entry in <code>EVs</code>?</p></a></li>
<li><a href='#format_nuisance'><p>Format nuisance</p></a></li>
<li><a href='#format_scrub'><p>Format scrub</p></a></li>
<li><a href='#GLM_multi'><p>GLM multi</p></a></li>
<li><a href='#hpf_Param_BayesGLM'><p>hpf</p></a></li>
<li><a href='#HRF_calc'><p>Canonical HRF and Derivatives</p></a></li>
<li><a href='#HRF_main'><p>Canonical (double-gamma) HRF</p></a></li>
<li><a href='#HRF96'><p>Canonical (double-gamma) HRF (old one from SPM96, Glover)</p></a></li>
<li><a href='#is_matrix_or_df'><p>Is a matrix or data.frame?</p></a></li>
<li><a href='#is_valid_one_design'><p>Is a valid design?</p></a></li>
<li><a href='#is_valid_one_nuisance'><p>Is a valid nuisance?</p></a></li>
<li><a href='#is_valid_one_scrub'><p>Is a valid scrub?</p></a></li>
<li><a href='#make_design'><p>Make design matrix</p></a></li>
<li><a href='#mask_Param_vertices'><p>mask: vertices</p></a></li>
<li><a href='#mean_var_Tol_Param'><p>mean and variance tolerance</p></a></li>
<li><a href='#multiGLM'><p>multiGLM for CIFTI</p></a></li>
<li><a href='#multiGLM_fun'><p>multiGLM0</p></a></li>
<li><a href='#nuisance_Param_BayesGLM'><p>nuisance</p></a></li>
<li><a href='#plot_design'><p>Plot design matrix</p></a></li>
<li><a href='#plot.BfMRI_design'><p>S3 method: use <code>view_xifti</code> to plot a <code>"BGLM"</code> object</p></a></li>
<li><a href='#resamp_res_Param_BayesGLM'><p>resamp_res</p></a></li>
<li><a href='#scale_BOLD_Param'><p>scale_BOLD</p></a></li>
<li><a href='#scale_design_mat'><p>Scale the design matrix</p></a></li>
<li><a href='#scrub_Param_BayesGLM'><p>scrub</p></a></li>
<li><a href='#session_names_Param'><p>session_names</p></a></li>
<li><a href='#summary.BfMRI_design'><p>Summarize a <code>"BfMRI_design"</code> object</p></a></li>
<li><a href='#surfaces_Param_BayesGLM'><p>surfaces</p></a></li>
<li><a href='#TR_Param_BayesGLM'><p>TR</p></a></li>
<li><a href='#verbose_Param'><p>verbose</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Hemodynamic Response Function</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Amanda Mejia &lt;mandy.mejia@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes the hemodynamic response function (HRF) for task 
    functional magnetic resonance imaging (fMRI) data. Also includes functions
    for constructing a design matrix from task fMRI event timings, and for
    comparing multiple design matrices in a general linear model (GLM). A
    wrapper function is provided for GLM analysis of CIFTI-format data. Lastly,
    there are supporting functions which provide visual summaries of the
    HRFs and design matrices.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mandymejia/hrf">https://github.com/mandymejia/hrf</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mandymejia/hrf/issues">https://github.com/mandymejia/hrf/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>car, ciftiTools (&ge; 0.15.0), fMRItools, Matrix, matrixStats,
stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, ggplot2, knitr, rmarkdown, testthat (&ge; 3.0.0), tidyr,
spelling</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-29 20:47:30 UTC; ddpham</td>
</tr>
<tr>
<td>Author:</td>
<td>Amanda Mejia [aut, cre],
  Damon Pham <a href="https://orcid.org/0000-0001-7563-4727"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  David Bolin [ctb],
  Yu (Ryan) Yue [ctb],
  Daniel Spencer <a href="https://orcid.org/0000-0002-9705-3605"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Sarah Ryan [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-30 19:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aic_Param'>aic</h2><span id='topic+aic_Param'></span>

<h3>Description</h3>

<p>aic
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aic_Param_+3A_aic">aic</code></td>
<td>
<p>(For prewhitening) Use the Akaike information criterion (AIC) to
select AR model orders between <code>0</code> and <code>ar_order</code>? Default:
<code>FALSE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='ar_order_Param'>ar_order</h2><span id='topic+ar_order_Param'></span>

<h3>Description</h3>

<p>ar_order
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ar_order_Param_+3A_ar_order">ar_order</code></td>
<td>
<p>(For prewhitening) The order of the autoregressive (AR) model
to use for prewhitening. If <code>0</code>, do not prewhiten. Default: <code>6</code>.
</p>
<p>For multi-session modeling, note that a single AR model is used; its
coefficients will be the average estimate from each session.</p>
</td></tr>
</table>

<hr>
<h2 id='ar_smooth_Param'>ar_smooth</h2><span id='topic+ar_smooth_Param'></span>

<h3>Description</h3>

<p>ar_smooth
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ar_smooth_Param_+3A_ar_smooth">ar_smooth</code></td>
<td>
<p>(For prewhitening) The FWHM parameter for spatially
smoothing the coefficient estimates for the AR model to use for
prewhitening. Recall that
<code class="reqn">\sigma = \frac{FWHM}{2*sqrt(2*log(2)}</code>. Set to <code>0</code> to not smooth
the estimates. Default: <code>5</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='BayesGLM_argChecks'>Bayes GLM arg checks</h2><span id='topic+BayesGLM_argChecks'></span>

<h3>Description</h3>

<p>Checks arguments for <code>BayesGLM</code> and <code>fit_bayesglm</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesGLM_argChecks(
  scale_BOLD = c("mean", "sd", "none"),
  Bayes = TRUE,
  EM = FALSE,
  ar_order = 6,
  ar_smooth = 5,
  aic = FALSE,
  n_threads = 4,
  return_INLA = c("trimmed", "full", "minimal"),
  verbose = 1,
  meanTol = 1e-06,
  varTol = 1e-06,
  emTol = 0.001
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BayesGLM_argChecks_+3A_scale_bold">scale_BOLD</code></td>
<td>
<p>See <code>BayesGLM</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_argChecks_+3A_bayes">Bayes</code>, <code id="BayesGLM_argChecks_+3A_em">EM</code></td>
<td>
<p>See <code>BayesGLM</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_argChecks_+3A_ar_order">ar_order</code>, <code id="BayesGLM_argChecks_+3A_ar_smooth">ar_smooth</code>, <code id="BayesGLM_argChecks_+3A_aic">aic</code></td>
<td>
<p>See <code>BayesGLM</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_argChecks_+3A_n_threads">n_threads</code></td>
<td>
<p>See <code>BayesGLM</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_argChecks_+3A_return_inla">return_INLA</code></td>
<td>
<p>See <code>BayesGLM</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_argChecks_+3A_verbose">verbose</code></td>
<td>
<p>See <code>BayesGLM</code>.</p>
</td></tr>
<tr><td><code id="BayesGLM_argChecks_+3A_meantol">meanTol</code>, <code id="BayesGLM_argChecks_+3A_vartol">varTol</code>, <code id="BayesGLM_argChecks_+3A_emtol">emTol</code></td>
<td>
<p>See <code>BayesGLM</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Avoids duplicated code between <code>BayesGLM</code> and <code>fit_bayesglm</code>
</p>


<h3>Value</h3>

<p>The arguments that may have changed, in a list: <code>scale_BOLD</code>,
<code>do_Bayesian</code>, <code>do_EM</code>, and <code>do_pw</code>.
</p>

<hr>
<h2 id='BOLD_Param_BayesGLM'>BOLD</h2><span id='topic+BOLD_Param_BayesGLM'></span>

<h3>Description</h3>

<p>BOLD
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BOLD_Param_BayesGLM_+3A_bold">BOLD</code></td>
<td>
<p>fMRI timeseries data in CIFTI format (&quot;*.dtseries.nii&quot;).
For single-session analysis this can be a file path to a CIFTI file or a
<code>"xifti"</code> object from the <code>ciftiTools</code> package. For multi-session
analysis this can be a vector of file paths or a list of <code>"xifti"</code>
objects.
</p>
<p>If <code>BOLD</code> is a <code>"xifti"</code> object(s), the surfaces, if any, will be
used for the spatial model. However, if <code>surfL</code> and <code>surfR</code> are
provided, they will override any surfaces in <code>BOLD</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='brainstructures_Param_BayesGLM'>brainstructures</h2><span id='topic+brainstructures_Param_BayesGLM'></span>

<h3>Description</h3>

<p>brainstructures
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brainstructures_Param_BayesGLM_+3A_brainstructures">brainstructures</code></td>
<td>
<p>Character vector indicating which brain structure(s)
of <code>BOLD</code> to analyze: <code>"left"</code> cortex; <code>"right"</code> cortex;
and/or <code>"subcortical"</code> structures. Or <code>"all"</code> to model all three.
Default: <code>c("left","right")</code> (cortex only).</p>
</td></tr>
</table>

<hr>
<h2 id='cbind2'><code>cbind</code> if first argument might be <code>NULL</code></h2><span id='topic+cbind2'></span>

<h3>Description</h3>

<p><code>cbind</code>, but return the second argument if the first is <code>NULL</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbind2(mat_or_NULL, to_add)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cbind2_+3A_mat_or_null">mat_or_NULL</code></td>
<td>
<p><code>NULL</code> or a numeric matrix</p>
</td></tr>
<tr><td><code id="cbind2_+3A_to_add">to_add</code></td>
<td>
<p>A numeric matrix with the same number of rows as <code>mat_or_NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cbind(mat_or_NULL, to_add)</code>, or just <code>to_add</code> if the first argument is NULL.
</p>

<hr>
<h2 id='cderiv'>Central derivative</h2><span id='topic+cderiv'></span>

<h3>Description</h3>

<p>Take the central derivative of numeric vectors by averaging the forward and
backward differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cderiv(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cderiv_+3A_x">x</code></td>
<td>
<p>A numeric matrix, or a vector which will be converted to a
single-column matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or vector the same dimensions as <code>x</code>, with the
derivative taken for each column of <code>x</code>. The first and last rows may
need to be deleted, depending on the application.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- cderiv(seq(5))
stopifnot(all(x == c(.5, 1, 1, 1, .5)))

</code></pre>

<hr>
<h2 id='Connectome_Workbench_Description'>Connectome Workbench</h2><span id='topic+Connectome_Workbench_Description'></span>

<h3>Description</h3>

<p>Connectome Workbench
</p>


<h3>Connectome Workbench Requirement</h3>

<p>This function uses a system wrapper for the 'wb_command' executable. The
user must first download and install the Connectome Workbench, available
from https://www.humanconnectome.org/software/get-connectome-workbench .
</p>

<hr>
<h2 id='design_Param_BayesGLM'>design</h2><span id='topic+design_Param_BayesGLM'></span>

<h3>Description</h3>

<p>design
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="design_Param_BayesGLM_+3A_design">design</code></td>
<td>
<p>A numeric matrix or <code>data.frame</code>, or a
<code>"BayesfMRI_design"</code> object from <code>make_design</code>. Can also
be an array where the third dimension is the same length as the number of
data locations, to model each location with its own design.</p>
</td></tr>
</table>

<hr>
<h2 id='do_QC'>Mask out invalid data</h2><span id='topic+do_QC'></span>

<h3>Description</h3>

<p>Mask out data locations that are invalid (missing data, low mean, or low
variance) for any session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_QC(BOLD, meanTol = 1e-06, varTol = 1e-06, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="do_QC_+3A_bold">BOLD</code></td>
<td>
<p>A session-length list of <code class="reqn">T \times V</code> numeric BOLD data.</p>
</td></tr>
<tr><td><code id="do_QC_+3A_meantol">meanTol</code>, <code id="do_QC_+3A_vartol">varTol</code></td>
<td>
<p>Tolerance for mean and variance of each data location.
Locations which do not meet these thresholds are masked out of the analysis.
Defaults: <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="do_QC_+3A_verbose">verbose</code></td>
<td>
<p>Print messages counting how many locations are removed?
Default: <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector indicating locations that are valid across all sessions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nT &lt;- 30
nV &lt;- 400
BOLD1 &lt;- matrix(rnorm(nT*nV), nrow=nT)
BOLD1[,seq(30,50)] &lt;- NA
BOLD2 &lt;- matrix(rnorm(nT*nV), nrow=nT)
BOLD2[,65] &lt;- BOLD2[,65] / 1e10
BOLD &lt;- list(sess1=BOLD1, sess2=BOLD2)
do_QC(BOLD)

</code></pre>

<hr>
<h2 id='faces_Param'>faces</h2><span id='topic+faces_Param'></span>

<h3>Description</h3>

<p>faces
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="faces_Param_+3A_faces">faces</code></td>
<td>
<p>An <code class="reqn">F \times 3</code> matrix, where each row contains the vertex
indices for a given triangular face in the mesh. <code class="reqn">F</code> is the number of
faces in the mesh.</p>
</td></tr>
</table>

<hr>
<h2 id='field_names_Param'>field_names</h2><span id='topic+field_names_Param'></span>

<h3>Description</h3>

<p>field_names
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="field_names_Param_+3A_field_names">field_names</code></td>
<td>
<p>(Optional) Names of fields represented in design matrix.</p>
</td></tr>
</table>

<hr>
<h2 id='format_design'>Format design</h2><span id='topic+format_design'></span>

<h3>Description</h3>

<p>Format design for <code>BayesGLM</code>, <code>fit_bayesglm</code>,
<code>multiGLM</code>, and <code>multiGLM_fun</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_design(
  design,
  scale_design = TRUE,
  nS_expect = NULL,
  nT_expect = NULL,
  nD_expect = NULL,
  per_location_design = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format_design_+3A_design">design</code></td>
<td>
<p>The <code>design</code> argument input. Will be formatted to a
<code>nS</code>-length list.</p>
</td></tr>
<tr><td><code id="format_design_+3A_scale_design">scale_design</code></td>
<td>
<p>Scale the design matrix by dividing each column by its
maximum and then subtracting the mean? Default: <code>TRUE</code>. If
<code>FALSE</code>, the design matrix is centered but not scaled.</p>
</td></tr>
<tr><td><code id="format_design_+3A_ns_expect">nS_expect</code></td>
<td>
<p>The expected number of sessions, if known.</p>
</td></tr>
<tr><td><code id="format_design_+3A_nt_expect">nT_expect</code></td>
<td>
<p>The expected number of timepoints, if known. For
multi-session data this is a session-length vector.</p>
</td></tr>
<tr><td><code id="format_design_+3A_nd_expect">nD_expect</code></td>
<td>
<p>The expected number of designs, if known. For per-location
modeling this is equal to <code>nVd0</code>, the initial number of data locations.
For multi-session data this is a session-length vector.</p>
</td></tr>
<tr><td><code id="format_design_+3A_per_location_design">per_location_design</code></td>
<td>
<p><code>FALSE</code> if per-location modeling is not
being performed (i.e. for multiGLM); <code>TRUE</code> if it is; or, <code>NULL</code>
to infer based on the dimensions of <code>design</code> (<code>TRUE</code> if the
design has three dimensions.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>design</code>
</p>

<hr>
<h2 id='format_EV'>Is this a valid entry in <code>EVs</code>?</h2><span id='topic+format_EV'></span>

<h3>Description</h3>

<p>Is this valid data for a single task's EVs? Expects a data.frame or
numeric matrix with two numeric columns, EVs and durations, and at least
one row. Or, the value <code>NA</code> for an empty task.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_EV(EV)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format_EV_+3A_ev">EV</code></td>
<td>
<p>The putative EVs matrix or data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Length-one logical vector.
</p>

<hr>
<h2 id='format_nuisance'>Format nuisance</h2><span id='topic+format_nuisance'></span>

<h3>Description</h3>

<p>Format nuisance for <code>BayesGLM</code>, <code>fit_bayesglm</code>,
<code>multiGLM</code>, and <code>multiGLM_fun</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_nuisance(nuisance, nS_expect = NULL, nT_expect = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format_nuisance_+3A_nuisance">nuisance</code></td>
<td>
<p>The <code>nuisance</code> argument input. Will be formatted to a
<code>nS</code>-length list.</p>
</td></tr>
<tr><td><code id="format_nuisance_+3A_ns_expect">nS_expect</code></td>
<td>
<p>The expected number of sessions, if known.</p>
</td></tr>
<tr><td><code id="format_nuisance_+3A_nt_expect">nT_expect</code></td>
<td>
<p>The expected number of timepoints, if known. For
multi-session data this is a session-length vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nuisance</code>
</p>

<hr>
<h2 id='format_scrub'>Format scrub</h2><span id='topic+format_scrub'></span>

<h3>Description</h3>

<p>Format scrub for <code>BayesGLM</code>, <code>fit_bayesglm</code>,
<code>multiGLM</code>, and <code>multiGLM_fun</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_scrub(scrub, nS_expect = NULL, nT_expect = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format_scrub_+3A_scrub">scrub</code></td>
<td>
<p>The <code>scrub</code> argument input. Will be formatted to a
<code>nS</code>-length list.</p>
</td></tr>
<tr><td><code id="format_scrub_+3A_ns_expect">nS_expect</code></td>
<td>
<p>The expected number of sessions, if known.</p>
</td></tr>
<tr><td><code id="format_scrub_+3A_nt_expect">nT_expect</code></td>
<td>
<p>The expected number of timepoints, if known. For
multi-session data this is a session-length vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>scrub</code>
</p>

<hr>
<h2 id='GLM_multi'>GLM multi</h2><span id='topic+GLM_multi'></span>

<h3>Description</h3>

<p>GLM multi
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLM_multi(y, X, X2, Xc = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GLM_multi_+3A_y">y</code>, <code id="GLM_multi_+3A_x">X</code>, <code id="GLM_multi_+3A_x2">X2</code></td>
<td>
<p>BOLD, design, nuisance</p>
</td></tr>
<tr><td><code id="GLM_multi_+3A_xc">Xc</code></td>
<td>
<p>(Optional) canonical design matrix</p>
</td></tr>
<tr><td><code id="GLM_multi_+3A_verbose">verbose</code></td>
<td>
<p>verbose?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Results for GLM multi
</p>

<hr>
<h2 id='hpf_Param_BayesGLM'>hpf</h2><span id='topic+hpf_Param_BayesGLM'></span>

<h3>Description</h3>

<p>hpf
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hpf_Param_BayesGLM_+3A_hpf">hpf</code></td>
<td>
<p>Add DCT bases to <code>nuisance</code> to apply a temporal high-pass
filter to the data, for detrending? <code>hpf</code> is the filter frequency.
Use <code>NULL</code> to skip detrending. Detrending is strongly recommended for
fMRI data, to help reduce the autocorrelation in the residuals, so
<code>NULL</code> will induce a warning. Use <code>"already"</code> to disable the
warning while skipping highpass filtering.
</p>
<p>Using at least two DCT bases is as sufficient for detrending as using linear
and quadratic drift terms in the nuisance matrix. So if DCT detrending is
being used here, there is no need to add linear and quadratic drift terms to
<code>nuisance</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='HRF_calc'>Canonical HRF and Derivatives</h2><span id='topic+HRF_calc'></span>

<h3>Description</h3>

<p>Calculate the HRF from a time vector and parameters, or its derivative with
respect to delay or dispersion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HRF_calc(
  t,
  deriv = 0,
  a1 = 6,
  b1 = 1,
  a2 = 16/6 * a1 * sqrt(b1),
  b2 = b1,
  c = 1/6,
  o = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HRF_calc_+3A_t">t</code></td>
<td>
<p>time vector (in units of seconds)</p>
</td></tr>
<tr><td><code id="HRF_calc_+3A_deriv">deriv</code></td>
<td>
<p><code>0</code> (default) for the HRF, <code>1</code> for the delay derivative
of the HRF, or <code>2</code> for the dispersion derivative of the HRF.</p>
</td></tr>
<tr><td><code id="HRF_calc_+3A_a1">a1</code></td>
<td>
<p>delay of response. Default: <code>6</code></p>
</td></tr>
<tr><td><code id="HRF_calc_+3A_b1">b1</code></td>
<td>
<p>response dispersion. Default: <code>1</code></p>
</td></tr>
<tr><td><code id="HRF_calc_+3A_a2">a2</code></td>
<td>
<p>delay of undershoot. Default: <code>16/6 * a1 * sqrt(b1) = 16</code></p>
</td></tr>
<tr><td><code id="HRF_calc_+3A_b2">b2</code></td>
<td>
<p>dispersion of undershoot. Default: <code>b1 = 1</code></p>
</td></tr>
<tr><td><code id="HRF_calc_+3A_c">c</code></td>
<td>
<p>scale of undershoot. Default: <code>1/6</code></p>
</td></tr>
<tr><td><code id="HRF_calc_+3A_o">o</code></td>
<td>
<p>onset of response. Default: <code>0</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>HRF vector (or dHRF, or d2HRF) corresponding to time vector t
</p>


<h3>Examples</h3>

<pre><code class='language-R'>samples_per_sec &lt;- 200
nsec &lt;- 50
HRF_calc(seq(nsec*samples_per_sec)/samples_per_sec)

</code></pre>

<hr>
<h2 id='HRF_main'>Canonical (double-gamma) HRF</h2><span id='topic+HRF_main'></span>

<h3>Description</h3>

<p>Calculate the HRF from a time vector and parameters. Optionally compute the
first or second derivative of the HRF instead. Form of HRF is similar to SPM
but here the response and undershoot are scaled so the difference of the HRFs
peaks at 1 and -c
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HRF_main(t, a1 = 6, b1 = 1, a2 = NULL, b2 = NULL, c = 1/6, o = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HRF_main_+3A_t">t</code></td>
<td>
<p>time vector (in seconds). Must be equally spaced.</p>
</td></tr>
<tr><td><code id="HRF_main_+3A_a1">a1</code></td>
<td>
<p>delay of response. Default: <code>6</code></p>
</td></tr>
<tr><td><code id="HRF_main_+3A_b1">b1</code></td>
<td>
<p>response dispersion. Default: <code>1</code></p>
</td></tr>
<tr><td><code id="HRF_main_+3A_a2">a2</code></td>
<td>
<p>delay of undershoot. Default: <code>16/6*a1 = 16</code></p>
</td></tr>
<tr><td><code id="HRF_main_+3A_b2">b2</code></td>
<td>
<p>dispersion of undershoot. Default: <code>b1 = 1</code></p>
</td></tr>
<tr><td><code id="HRF_main_+3A_c">c</code></td>
<td>
<p>scale of undershoot. Default: <code>1/6</code></p>
</td></tr>
<tr><td><code id="HRF_main_+3A_o">o</code></td>
<td>
<p>onset of response (in seconds). Default: <code>0</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>HRF vector corresponding to time vector t
</p>


<h3>Examples</h3>

<pre><code class='language-R'>upsample &lt;- 100
HRF_main(seq(0, 30, by=1/upsample))

</code></pre>

<hr>
<h2 id='HRF96'>Canonical (double-gamma) HRF (old one from SPM96, Glover)</h2><span id='topic+HRF96'></span>

<h3>Description</h3>

<p>Calculate the HRF from a time vector and parameters. Optionally compute the
first or second derivative of the HRF instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HRF96(t, deriv = 0, a1 = 6, b1 = 0.9, a2 = 12, b2 = 0.9, c = 0.35)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HRF96_+3A_t">t</code></td>
<td>
<p>time vector</p>
</td></tr>
<tr><td><code id="HRF96_+3A_deriv">deriv</code></td>
<td>
<p><code>0</code> (default) for the HRF, <code>1</code> for the first derivative
of the HRF, or <code>2</code> for the second derivative of the HRF.</p>
</td></tr>
<tr><td><code id="HRF96_+3A_a1">a1</code></td>
<td>
<p>delay of response. Default: <code>6</code></p>
</td></tr>
<tr><td><code id="HRF96_+3A_b1">b1</code></td>
<td>
<p>response dispersion. Default: <code>0.9</code></p>
</td></tr>
<tr><td><code id="HRF96_+3A_a2">a2</code></td>
<td>
<p>delay of undershoot. Default: <code>12</code></p>
</td></tr>
<tr><td><code id="HRF96_+3A_b2">b2</code></td>
<td>
<p>dispersion of undershoot. Default: <code>0.9</code></p>
</td></tr>
<tr><td><code id="HRF96_+3A_c">c</code></td>
<td>
<p>scale of undershoot. Default: <code>0.35</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>HRF vector (or dHRF, or d2HRF) corresponding to time
</p>


<h3>Examples</h3>

<pre><code class='language-R'>upsample &lt;- 100
HRF96(seq(0, 30, by=1/upsample))

</code></pre>

<hr>
<h2 id='is_matrix_or_df'>Is a matrix or data.frame?</h2><span id='topic+is_matrix_or_df'></span>

<h3>Description</h3>

<p>Is this a matrix or data.frame?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_matrix_or_df(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_matrix_or_df_+3A_x">x</code></td>
<td>
<p>The object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Length-one logical.
</p>

<hr>
<h2 id='is_valid_one_design'>Is a valid design?</h2><span id='topic+is_valid_one_design'></span>

<h3>Description</h3>

<p>Is a valid design?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_valid_one_design(design)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_valid_one_design_+3A_design">design</code></td>
<td>
<p>The design matrix/array</p>
</td></tr>
</table>

<hr>
<h2 id='is_valid_one_nuisance'>Is a valid nuisance?</h2><span id='topic+is_valid_one_nuisance'></span>

<h3>Description</h3>

<p>Is a valid nuisance?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_valid_one_nuisance(nuisance)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_valid_one_nuisance_+3A_nuisance">nuisance</code></td>
<td>
<p>The nuisance matrix</p>
</td></tr>
</table>

<hr>
<h2 id='is_valid_one_scrub'>Is a valid scrub?</h2><span id='topic+is_valid_one_scrub'></span>

<h3>Description</h3>

<p>Is a valid scrub?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_valid_one_scrub(scrub)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_valid_one_scrub_+3A_scrub">scrub</code></td>
<td>
<p>The scrub matrix</p>
</td></tr>
</table>

<hr>
<h2 id='make_design'>Make design matrix</h2><span id='topic+make_design'></span>

<h3>Description</h3>

<p>Make the design matrix for the GLM, from the task information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_design(
  EVs,
  nTime,
  TR,
  dHRF = 0,
  upsample = 100,
  onset = NULL,
  offset = NULL,
  scale_design = TRUE,
  onsets_sep = FALSE,
  offsets_sep = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_design_+3A_evs">EVs</code></td>
<td>
<p>The explanatory variables i.e. the task stimulus information,
from which a design matrix will be constructed. This is a list where each
entry represents a task as a matrix of onsets (first column) and durations
(second column) for each stimuli (each row) of the task, in seconds. List
names should be the task names. <code>nTime</code> and <code>TR</code> are required.
</p>
<p>An example of a properly-formatted <code>EVs</code> is:
<code>on_s1 &lt;- list(taskA=cbind(on=c(1,9,17), dr=rep(1,3)),
 taskB=cbind(on=c(3,27), dr=rep(5,2)))</code>.
In this example, there are two tasks: the first has three 1s-long stimuli,
while the second has two 5s-long stimuli.</p>
</td></tr>
<tr><td><code id="make_design_+3A_ntime">nTime</code></td>
<td>
<p>the number of timepoints (volumes) in the task fMRI data.</p>
</td></tr>
<tr><td><code id="make_design_+3A_tr">TR</code></td>
<td>
<p>the temporal resolution of the data, in seconds.</p>
</td></tr>
<tr><td><code id="make_design_+3A_dhrf">dHRF</code></td>
<td>
<p>Controls the extent of HRF derivatives modeling.
</p>
<p>Set to <code>0</code> to only model the main HRF regressor (default), and not include its
derivatives; set to <code>1</code> to model the temporal derivative too;
or, set to <code>2</code> to model both the temporal and dispersion derivatives.
If <code>dHRF==0</code>, there is one design column (field) per task. If
<code>dHRF==1</code>, there are two fields per task. And if <code>dHRF==2</code>, there
are three fields per task.
</p>
<p>If there are several tasks and <code>dHRF&gt;0</code>, the total number of design
matrix columns may exceed five, which may require large computation times
with INLA. The analysis can be adjusted by modeling the derivatives as
nuisance signals rather than as fields. To do so, move the corresponding
columns from the design matrix to the <code>nuisance</code> argument for
<code>BayesGLM</code>.</p>
</td></tr>
<tr><td><code id="make_design_+3A_upsample">upsample</code></td>
<td>
<p>Upsample factor for convolving stimulus boxcar or stick
function with canonical HRF. Default: <code>100</code>.</p>
</td></tr>
<tr><td><code id="make_design_+3A_onset">onset</code>, <code id="make_design_+3A_offset">offset</code></td>
<td>
<p>Add task regressors indicating the onset and/or offset of
each event block? Provide the names of the tasks as a character vector. All
onsets (or offsets) across the specified tasks will be represented by one
additional column in the design matrix. The task names must match the names
of <code>EVs</code>. Can also be <code>"all"</code> to use all tasks.
</p>
<p>Onsets/offset modeling is only compatible with a block design experiment.
An error will be raised if the events in <code>EVs</code> do not have duration
greater than one second.</p>
</td></tr>
<tr><td><code id="make_design_+3A_scale_design">scale_design</code></td>
<td>
<p>Scale the columns of the design matrix? Default:
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="make_design_+3A_onsets_sep">onsets_sep</code>, <code id="make_design_+3A_offsets_sep">offsets_sep</code></td>
<td>
<p>Model the onsets (<code>onsets_sep</code>) or offsets
(<code>offsets_sep</code>) separately for each task? Default: <code>FALSE</code>, to
model all onsets together, or all offsets together, as a single field in the
design.</p>
</td></tr>
<tr><td><code id="make_design_+3A_verbose">verbose</code></td>
<td>
<p>Print diagnostic messages? Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="make_design_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="#topic+HRF_calc">HRF_calc</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"BfMRI_design"</code> object: a list with elements
</p>

<dl>
<dt>design</dt><dd><p>The volumes by fields design matrix. Column names are field names.</p>
</dd>
<dt>field_names</dt><dd><p>The name of each task from the provided onsets.</p>
</dd>
<dt>dHRF</dt><dd><p>The input <code>dHRF</code> parameter.</p>
</dd>
<dt>HRF_info</dt><dd><p>Additional HRF modeling results.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>EVs &lt;- list(taskA=cbind(on=c(1,9,17), dr=rep(1,3)), taskB=cbind(on=c(3,27), dr=rep(5,2)))
TR &lt;- .72
nTime &lt;- ceiling(65/TR)
make_design(EVs, nTime, TR)

</code></pre>

<hr>
<h2 id='mask_Param_vertices'>mask: vertices</h2><span id='topic+mask_Param_vertices'></span>

<h3>Description</h3>

<p>mask: vertices
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mask_Param_vertices_+3A_mask">mask</code></td>
<td>
<p>A length <code class="reqn">V</code> logical vector indicating if each vertex is
within the input mask.</p>
</td></tr>
</table>

<hr>
<h2 id='mean_var_Tol_Param'>mean and variance tolerance</h2><span id='topic+mean_var_Tol_Param'></span>

<h3>Description</h3>

<p>mean and variance tolerance
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean_var_Tol_Param_+3A_meantol">meanTol</code>, <code id="mean_var_Tol_Param_+3A_vartol">varTol</code></td>
<td>
<p>Tolerance for mean and variance of each data location.
Locations which do not meet these thresholds are masked out of the analysis.
Default: <code>1e-6</code> for both.</p>
</td></tr>
</table>

<hr>
<h2 id='multiGLM'>multiGLM for CIFTI</h2><span id='topic+multiGLM'></span>

<h3>Description</h3>

<p>Performs classical Bayesian GLM for task fMRI activation with CIFTI-format
data, evaluating multiple design matrices. Includes the pre-processing
steps of nuisance regression. Supports single-session analysis only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiGLM(
  BOLD,
  design,
  brainstructures = c("left", "right"),
  TR = NULL,
  resamp_res = 10000,
  hpf = NULL,
  nuisance = NULL,
  design_canonical = NULL,
  verbose = 1,
  meanTol = 1e-06,
  varTol = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multiGLM_+3A_bold">BOLD</code></td>
<td>
<p>fMRI timeseries data in CIFTI format (&quot;*.dtseries.nii&quot;).
For single-session analysis this can be a file path to a CIFTI file or a
<code>"xifti"</code> object from the <code>ciftiTools</code> package. For multi-session
analysis this can be a vector of file paths or a list of <code>"xifti"</code>
objects.
</p>
<p>If <code>BOLD</code> is a <code>"xifti"</code> object(s), the surfaces, if any, will be
used for the spatial model. However, if <code>surfL</code> and <code>surfR</code> are
provided, they will override any surfaces in <code>BOLD</code>.</p>
</td></tr>
<tr><td><code id="multiGLM_+3A_design">design</code></td>
<td>
<p>A 3D numeric array that is locations by fields by designs.</p>
</td></tr>
<tr><td><code id="multiGLM_+3A_brainstructures">brainstructures</code></td>
<td>
<p>Character vector indicating which brain structure(s)
of <code>BOLD</code> to analyze: <code>"left"</code> cortex; <code>"right"</code> cortex;
and/or <code>"subcortical"</code> structures. Or <code>"all"</code> to model all three.
Default: <code>c("left","right")</code> (cortex only).</p>
</td></tr>
<tr><td><code id="multiGLM_+3A_tr">TR</code></td>
<td>
<p>Temporal resolution of the data, in seconds.</p>
</td></tr>
<tr><td><code id="multiGLM_+3A_resamp_res">resamp_res</code></td>
<td>
<p>For cortex spatial model. The number of vertices to which
each cortical surface should be resampled, or <code>NULL</code> to not resample.
</p>
<p>For computational feasibility, a value of <code>10000</code> (default) or lower is
recommended for Bayesian spatial modeling. If <code>Bayes=FALSE</code>,
<code>resamp_res</code> can be set to <code>NULL</code> for full-resolution classical
modeling.</p>
</td></tr>
<tr><td><code id="multiGLM_+3A_hpf">hpf</code></td>
<td>
<p>Add DCT bases to <code>nuisance</code> to apply a temporal high-pass
filter to the data, for detrending? <code>hpf</code> is the filter frequency.
Use <code>NULL</code> to skip detrending. Detrending is strongly recommended for
fMRI data, to help reduce the autocorrelation in the residuals, so
<code>NULL</code> will induce a warning. Use <code>"already"</code> to disable the
warning while skipping highpass filtering.
</p>
<p>Using at least two DCT bases is as sufficient for detrending as using linear
and quadratic drift terms in the nuisance matrix. So if DCT detrending is
being used here, there is no need to add linear and quadratic drift terms to
<code>nuisance</code>.</p>
</td></tr>
<tr><td><code id="multiGLM_+3A_nuisance">nuisance</code></td>
<td>
<p>(Optional) A <code class="reqn">T \times N_{nuis}</code> matrix of nuisance signals,
where <code class="reqn">T</code> is the number of timepoints and <code class="reqn">N</code> is the number of
nuisance signals, or a list of these for multi-session analysis. Nuisance
signals are regressed from the fMRI data and design matrix prior to GLM
computation. Nuisance signals can include motion regressors, HRF derivatives
not being modeled as tasks, and other sources of noise.
</p>
<p>Detrending/high-pass filtering is accomplished by adding DCT bases to the
nuisance matrix; see the parameters <code>hpf</code> and <code>DCT</code>.
</p>
<p>Do not add spike regressors for scrubbing to the <code>nuisance</code> matrix.
Rather, provide these in <code>scrub</code> so that their corresponding timepoints
are also removed from the BOLD data after nuisance regression.</p>
</td></tr>
<tr><td><code id="multiGLM_+3A_design_canonical">design_canonical</code></td>
<td>
<p>TO DO</p>
</td></tr>
<tr><td><code id="multiGLM_+3A_verbose">verbose</code></td>
<td>
<p><code>1</code> (default) to print occasional updates during model
computation; <code>2</code> for occasional updates as well as running INLA in
verbose mode (if <code>Bayes</code>), or <code>0</code> for no printed updates.</p>
</td></tr>
<tr><td><code id="multiGLM_+3A_meantol">meanTol</code>, <code id="multiGLM_+3A_vartol">varTol</code></td>
<td>
<p>Tolerance for mean and variance of each data location.
Locations which do not meet these thresholds are masked out of the analysis.
Default: <code>1e-6</code> for both.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"mGLM"</code>: a list with elements
</p>

<dl>
<dt>brainstructures</dt><dd><p><code>data.frame</code> summarizing the spatial features of each brain structure modeled.</p>
</dd>
<dt>fields</dt><dd><p><code>data.frame</code> with the <code>name</code>, related <code>task</code>, and <code>HRF_order</code> of each field.</p>
</dd>
</dl>



<h3>Connectome Workbench Requirement</h3>

<p>This function uses a system wrapper for the 'wb_command' executable. The
user must first download and install the Connectome Workbench, available
from https://www.humanconnectome.org/software/get-connectome-workbench .
</p>

<hr>
<h2 id='multiGLM_fun'>multiGLM0</h2><span id='topic+multiGLM_fun'></span>

<h3>Description</h3>

<p>Performs classical GLM for task fMRI activation, comparing multiple designs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiGLM_fun(
  BOLD,
  design,
  nuisance = NULL,
  design_canonical = NULL,
  verbose = 1,
  meanTol = 1e-06,
  varTol = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multiGLM_fun_+3A_bold">BOLD</code>, <code id="multiGLM_fun_+3A_design">design</code>, <code id="multiGLM_fun_+3A_nuisance">nuisance</code></td>
<td>
<p>Session-length list of numeric matrices/arrays,
each with volumes along the first dimension.</p>
</td></tr>
<tr><td><code id="multiGLM_fun_+3A_design_canonical">design_canonical</code></td>
<td>
<p>TO DO</p>
</td></tr>
<tr><td><code id="multiGLM_fun_+3A_verbose">verbose</code></td>
<td>
<p><code>1</code> (default) to print occasional updates during model
computation; <code>2</code> for occasional updates as well as running INLA in
verbose mode (if <code>Bayes</code>), or <code>0</code> for no printed updates.</p>
</td></tr>
<tr><td><code id="multiGLM_fun_+3A_meantol">meanTol</code>, <code id="multiGLM_fun_+3A_vartol">varTol</code></td>
<td>
<p>Tolerance for mean, variance and SNR of each data location.
Locations which do not meet these thresholds are masked out of the analysis.
Default: <code>1e-6</code> for mean and variance, <code>50</code> for SNR.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements
</p>

<dl>
<dt>bestmodel</dt><dd><p>...</p>
</dd>
<dt>Fstat</dt><dd><p>...</p>
</dd>
<dt>pvalF</dt><dd><p>...</p>
</dd>
</dl>


<hr>
<h2 id='nuisance_Param_BayesGLM'>nuisance</h2><span id='topic+nuisance_Param_BayesGLM'></span>

<h3>Description</h3>

<p>nuisance
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nuisance_Param_BayesGLM_+3A_nuisance">nuisance</code></td>
<td>
<p>(Optional) A <code class="reqn">T \times N_{nuis}</code> matrix of nuisance signals,
where <code class="reqn">T</code> is the number of timepoints and <code class="reqn">N</code> is the number of
nuisance signals, or a list of these for multi-session analysis. Nuisance
signals are regressed from the fMRI data and design matrix prior to GLM
computation. Nuisance signals can include motion regressors, HRF derivatives
not being modeled as tasks, and other sources of noise.
</p>
<p>Detrending/high-pass filtering is accomplished by adding DCT bases to the
nuisance matrix; see the parameters <code>hpf</code> and <code>DCT</code>.
</p>
<p>Do not add spike regressors for scrubbing to the <code>nuisance</code> matrix.
Rather, provide these in <code>scrub</code> so that their corresponding timepoints
are also removed from the BOLD data after nuisance regression.</p>
</td></tr>
</table>

<hr>
<h2 id='plot_design'>Plot design matrix</h2><span id='topic+plot_design'></span><span id='topic+plot_design_line'></span><span id='topic+plot_design_image'></span>

<h3>Description</h3>

<p>Plot design matrix
</p>
<p>Plot design with lineplot
</p>
<p>Plot design with imageplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_design(design, method = c("lineplot", "imageplot"), ...)

plot_design_line(
  design,
  colors = "Set1",
  linetype = "solid",
  linewidth = 0.7,
  alpha = 0.8
)

plot_design_image(design)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_design_+3A_design">design</code></td>
<td>
<p>The timepoints by fields design matrix or data.frame.</p>
</td></tr>
<tr><td><code id="plot_design_+3A_method">method</code></td>
<td>
<p><code>"lineplot"</code> (default) or <code>"imageplot"</code>.</p>
</td></tr>
<tr><td><code id="plot_design_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>plot_design_line</code> or
<code>plot_design_image</code>.</p>
</td></tr>
<tr><td><code id="plot_design_+3A_colors">colors</code></td>
<td>
<p>The name of a ColorBrewer palette (see
RColorBrewer::brewer.pal.info and colorbrewer2.org), the name of a
viridisLite palette, or a character vector of colors. Default:
<code>"Set1"</code>.</p>
</td></tr>
<tr><td><code id="plot_design_+3A_linetype">linetype</code>, <code id="plot_design_+3A_linewidth">linewidth</code>, <code id="plot_design_+3A_alpha">alpha</code></td>
<td>
<p>Parameters for <code>ggplot2::geom_line</code>.
Defaults: <code>"solid"</code> linetype, <code>0.7</code> linewidth and <code>0.8</code>
alpha. <code>linetype</code> can also be a vector of options with length matching
the number of fields in <code>design</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot
</p>
<p>A ggplot
</p>
<p>A ggplot
</p>

<hr>
<h2 id='plot.BfMRI_design'>S3 method: use <code><a href="ciftiTools.html#topic+view_xifti">view_xifti</a></code> to plot a <code>"BGLM"</code> object</h2><span id='topic+plot.BfMRI_design'></span>

<h3>Description</h3>

<p>S3 method: use <code><a href="ciftiTools.html#topic+view_xifti">view_xifti</a></code> to plot a <code>"BGLM"</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BfMRI_design'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.BfMRI_design_+3A_x">x</code></td>
<td>
<p>An object of class &quot;BfMRI_design&quot;.</p>
</td></tr>
<tr><td><code id="plot.BfMRI_design_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="#topic+plot_design">plot_design</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result of the call to <code><a href="#topic+plot_design">plot_design</a></code>
</p>

<hr>
<h2 id='resamp_res_Param_BayesGLM'>resamp_res</h2><span id='topic+resamp_res_Param_BayesGLM'></span>

<h3>Description</h3>

<p>resamp_res
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resamp_res_Param_BayesGLM_+3A_resamp_res">resamp_res</code></td>
<td>
<p>For cortex spatial model. The number of vertices to which
each cortical surface should be resampled, or <code>NULL</code> to not resample.
</p>
<p>For computational feasibility, a value of <code>10000</code> (default) or lower is
recommended for Bayesian spatial modeling. If <code>Bayes=FALSE</code>,
<code>resamp_res</code> can be set to <code>NULL</code> for full-resolution classical
modeling.</p>
</td></tr>
</table>

<hr>
<h2 id='scale_BOLD_Param'>scale_BOLD</h2><span id='topic+scale_BOLD_Param'></span>

<h3>Description</h3>

<p>scale_BOLD
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_BOLD_Param_+3A_scale_bold">scale_BOLD</code></td>
<td>
<p>Controls scaling the BOLD response at each location.
</p>

<dl>
<dt>&quot;mean&quot;:</dt><dd><p>   Scale the data to percent local signal change.</p>
</dd>
<dt>&quot;sd&quot;:</dt><dd><p>   Scale the data by local standard deviation.</p>
</dd>
<dt>&quot;none&quot;:</dt><dd><p>   Center the data but do not scale it.</p>
</dd>
</dl>
</td></tr>
</table>

<hr>
<h2 id='scale_design_mat'>Scale the design matrix</h2><span id='topic+scale_design_mat'></span>

<h3>Description</h3>

<p>Scale the design matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_design_mat(design_mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_design_mat_+3A_design_mat">design_mat</code></td>
<td>
<p>The original (unscaled) design matrix that is T x K, where
T is the number of time points, and k is the number of field covariates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scaled design matrix
</p>

<hr>
<h2 id='scrub_Param_BayesGLM'>scrub</h2><span id='topic+scrub_Param_BayesGLM'></span>

<h3>Description</h3>

<p>scrub
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scrub_Param_BayesGLM_+3A_scrub">scrub</code></td>
<td>
<p>(Optional) A <code class="reqn">T \times N_{scrub}</code> matrix of spike regressors
(one 1 value at the timepoint to scrub, and 0 for all other values), or a
logical vector indicating the timepoints to scrub (<code>TRUE</code> to scrub, and
<code>FALSE</code> to keep). For multi-session data, a session-length list of
such matrices or logical vectors.
</p>
<p>The spike regressors will be included in the nuisance
regression, and afterwards the timepoints indicated in <code>scrub</code> will be
removed from the BOLD data and design matrix.</p>
</td></tr>
</table>

<hr>
<h2 id='session_names_Param'>session_names</h2><span id='topic+session_names_Param'></span>

<h3>Description</h3>

<p>session_names
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="session_names_Param_+3A_session_names">session_names</code></td>
<td>
<p>The names of the task-fMRI <code>BOLD</code> sessions, for
multi-session analysis. If not provided here, will be inferred from
<code>names(BOLD)</code>, inferred from <code>names(design)</code>, or generated
automatically, in that order.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.BfMRI_design'>Summarize a <code>"BfMRI_design"</code> object</h2><span id='topic+summary.BfMRI_design'></span><span id='topic+print.summary.BfMRI_design'></span><span id='topic+print.BfMRI_design'></span>

<h3>Description</h3>

<p>Summary method for class <code>"BfMRI_design"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BfMRI_design'
summary(object, ...)

## S3 method for class 'summary.BfMRI_design'
print(x, ...)

## S3 method for class 'BfMRI_design'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.BfMRI_design_+3A_object">object</code></td>
<td>
<p>Object of class <code>"BfMRI_design"</code>.</p>
</td></tr>
<tr><td><code id="summary.BfMRI_design_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.BfMRI_design_+3A_x">x</code></td>
<td>
<p>Object of class <code>"summary.BfMRI_design"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"summary.BfMRI_design"</code> object, a list summarizing the
properties of <code>object</code>.
</p>
<p><code>NULL</code>, invisibly.
</p>
<p><code>NULL</code>, invisibly.
</p>

<hr>
<h2 id='surfaces_Param_BayesGLM'>surfaces</h2><span id='topic+surfaces_Param_BayesGLM'></span>

<h3>Description</h3>

<p>surfaces
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surfaces_Param_BayesGLM_+3A_surfl">surfL</code>, <code id="surfaces_Param_BayesGLM_+3A_surfr">surfR</code></td>
<td>
<p>For cortex spatial model. Left and right cortex surface
geometry in GIFTI format (&quot;*.surf.gii&quot;). These can be a file path to
a GIFTI file or a <code>"surf"</code> object from <code>ciftiTools</code>.
</p>
<p>Surfaces can alternatively be provided through the <code>$surf</code> metadata in
<code>BOLD</code> if it is <code>"xifti"</code> data. If neither are provided, by default the
HCP group-average fs_LR inflated surfaces included in <code>ciftiTools</code> will be
used for the cortex spatial model.</p>
</td></tr>
</table>

<hr>
<h2 id='TR_Param_BayesGLM'>TR</h2><span id='topic+TR_Param_BayesGLM'></span>

<h3>Description</h3>

<p>TR
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TR_Param_BayesGLM_+3A_tr">TR</code></td>
<td>
<p>Temporal resolution of the data, in seconds.</p>
</td></tr>
</table>

<hr>
<h2 id='verbose_Param'>verbose</h2><span id='topic+verbose_Param'></span>

<h3>Description</h3>

<p>verbose
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="verbose_Param_+3A_verbose">verbose</code></td>
<td>
<p><code>1</code> (default) to print occasional updates during model
computation; <code>2</code> for occasional updates as well as running INLA in
verbose mode (if <code>Bayes</code>), or <code>0</code> for no printed updates.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
