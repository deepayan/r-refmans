<!DOCTYPE html><html><head><title>Help for package SmCCNet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SmCCNet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#aggregateCVSingle'><p>Aggregate and Save Cross-validation Result for Single-omics Analysis</p></a></li>
<li><a href='#classifierEval'><p>Evaluation of Binary Classifier with Different Evaluation Metrics</p></a></li>
<li><a href='#dataPreprocess'><p>preprocess a omics dataset before running omics SmCCNet</p></a></li>
<li><a href='#fastAutoSmCCNet'><p>Automated SmCCNet to Streamline the SmCCNet Pipeline</p></a></li>
<li><a href='#getAbar'><p>Calculate similarity matrix based on canonical weights.</p></a></li>
<li><a href='#getCanCorMulti'><p>Canonical Correlation Value for SmCCA</p></a></li>
<li><a href='#getCanWeightsMulti'><p>Get Canonical Weight SmCCA Algorithm (No Subsampling)</p></a></li>
<li><a href='#getCCAout_single'><p>Internal functions called by getRobustPseudoWeights_single.</p></a></li>
<li><a href='#getOmicsModules'><p>Extract Omics Modules based on Similarity Matrix.</p></a></li>
<li><a href='#getRobustWeightsMulti'><p>Run Sparse multiple Canonical Correlation Analysis and Obtain Canonical Weights (with Subsampling)</p></a></li>
<li><a href='#getRobustWeightsMultiBinary'><p>Run Sparse multiple Canonical Correlation Analysis and Obtain Canonical Weights (with Subsampling)</p></a></li>
<li><a href='#getRobustWeightsSingle'><p>Single-omics SmCCA with Quantitative Phenotype</p></a></li>
<li><a href='#getRobustWeightsSingleBinary'><p>Single-omics SmCCA with Binary Phenotype</p></a></li>
<li><a href='#networkPruning'><p>Prunes Subnetwork and Return Final Pruned Subnetwork Module</p></a></li>
<li><a href='#scalingFactorInput'><p>Scaling Factor Input Prompt</p></a></li>
<li><a href='#summarizeNetSHy'><p>NetSHy Summarization Score</p></a></li>
<li><a href='#X1'><p>A synthetic mRNA expression dataset.</p></a></li>
<li><a href='#X2'><p>A synthetic miRNA expression dataset.</p></a></li>
<li><a href='#Y'><p>A synthetic phenotype dataset.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Sparse Multiple Canonical Correlation Network Analysis Tool</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-1-13</td>
</tr>
<tr>
<td>Author:</td>
<td>
    Weixuan Liu [aut, cre],
    Yonghua Zhuang [aut, cre],
    W. Jenny Shi [aut, cre],
    Thao Vu [aut],
    Iain Konigsberg [aut],
    Katherine Pratte [aut],
    Laura Saba [aut],
    Katerina Kechris [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Weixuan Liu &lt;weixuan.liu@cuanschutz.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>
   A canonical correlation based framework (SmCCNet) designed for the construction of phenotype-specific multi-omics networks. This framework adeptly integrates single or multiple omics data types along with a quantitative or binary phenotype of interest. It offers a streamlined setup process that can be tailored manually or configured automatically, ensuring a flexible and user-friendly experience.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/KechrisLab/SmCCNet">https://github.com/KechrisLab/SmCCNet</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>EnvStats, future, pROC, spls, Matrix, pbapply, igraph,
magrittr, rlist, furrr, purrr, pracma</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>biocViews:</td>
<td>Network</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-13 20:18:48 UTC; liux4</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-13 21:50:17 UTC</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), dplyr, reshape2,
shadowtext, tidyverse, parallel, mltools, caret,</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling 'rhs(lhs)'.
</p>

<hr>
<h2 id='aggregateCVSingle'>Aggregate and Save Cross-validation Result for Single-omics Analysis</h2><span id='topic+aggregateCVSingle'></span>

<h3>Description</h3>

<p>Saves cross-validation results in a table with the
user-defined directory and outputs penalty term with the highest testing canonical correlation,
lowest prediction error, and lowest scaled prediction error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregateCVSingle(CVDir, SCCAmethod = "SmCCA", K = 5, NumSubsamp = 500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregateCVSingle_+3A_cvdir">CVDir</code></td>
<td>
<p>A directory where the result is stored.</p>
</td></tr>
<tr><td><code id="aggregateCVSingle_+3A_sccamethod">SCCAmethod</code></td>
<td>
<p>The canonical correlation analysis method that is used in
the model, used to name cross-validation table file, default is set to 'SmCCA'.</p>
</td></tr>
<tr><td><code id="aggregateCVSingle_+3A_k">K</code></td>
<td>
<p>number of folds for cross-validation.</p>
</td></tr>
<tr><td><code id="aggregateCVSingle_+3A_numsubsamp">NumSubsamp</code></td>
<td>
<p>Number of subsampling used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 3 with indices of the penalty term that (1) maximize the testing canonical correlation,
(2) minimize the prediction error and (3) minimize the scaled prediction error.
</p>

<hr>
<h2 id='classifierEval'>Evaluation of Binary Classifier with Different Evaluation Metrics</h2><span id='topic+classifierEval'></span>

<h3>Description</h3>

<p>Evaluate binary classifier's performance with respect to user-selected
metric (accuracy, auc score, precision, recall, f1 score) for binary phenotype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classifierEval(
  obs,
  pred,
  EvalMethod = "accuracy",
  BinarizeThreshold = 0.5,
  print_score = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classifierEval_+3A_obs">obs</code></td>
<td>
<p>Observed phenotype, vector consists of 0, 1.</p>
</td></tr>
<tr><td><code id="classifierEval_+3A_pred">pred</code></td>
<td>
<p>Predicted probability of the phenotype, vector consists of any value between 0 and 1</p>
</td></tr>
<tr><td><code id="classifierEval_+3A_evalmethod">EvalMethod</code></td>
<td>
<p>Binary classifier evaluation method, should be one of the following:
'accuracy' (default), 'auc', 'precision', 'recall', and 'f1'.</p>
</td></tr>
<tr><td><code id="classifierEval_+3A_binarizethreshold">BinarizeThreshold</code></td>
<td>
<p>Cutoff threshold to binarize the predicted probability, default is set 
to 0.5.</p>
</td></tr>
<tr><td><code id="classifierEval_+3A_print_score">print_score</code></td>
<td>
<p>Whether to print out the evaluation score, default is set to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An evaluation score corresponding to the selected metric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate observed binary phenotype
obs &lt;- rbinom(100,1,0.5)
# simulate predicted probability
pred &lt;- runif(100, 0,1)
# calculate the score
pred_score &lt;- classifierEval(obs, pred, EvalMethod = 'f1', print_score = FALSE)

</code></pre>

<hr>
<h2 id='dataPreprocess'>preprocess a omics dataset before running omics SmCCNet</h2><span id='topic+dataPreprocess'></span>

<h3>Description</h3>

<p>Data preprocess pipeline to: (1) filter by coefficient of variation (cv), (2) center or scale data
and (3) adjust for clinical covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataPreprocess(
  X,
  covariates = NULL,
  is_cv = FALSE,
  cv_quantile = 0,
  center = TRUE,
  scale = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataPreprocess_+3A_x">X</code></td>
<td>
<p>dataframe with the size of <code class="reqn">n</code> by <code class="reqn">p</code>, where <code class="reqn">n</code> is the sample size and <code class="reqn">p</code> is the feature size.</p>
</td></tr>
<tr><td><code id="dataPreprocess_+3A_covariates">covariates</code></td>
<td>
<p>dataframe with covariates to be adjusted for.</p>
</td></tr>
<tr><td><code id="dataPreprocess_+3A_is_cv">is_cv</code></td>
<td>
<p>Whether to use coefficient of variation filter (small cv filter out).</p>
</td></tr>
<tr><td><code id="dataPreprocess_+3A_cv_quantile">cv_quantile</code></td>
<td>
<p>CV filtering quantile.</p>
</td></tr>
<tr><td><code id="dataPreprocess_+3A_center">center</code></td>
<td>
<p>Whether to center the dataset X.</p>
</td></tr>
<tr><td><code id="dataPreprocess_+3A_scale">scale</code></td>
<td>
<p>Whether to scale the dataset X.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Processed omics data with the size of nxp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
X1 &lt;- as.data.frame(matrix(rnorm(600, 0, 1), nrow = 60))
covar &lt;- as.data.frame(matrix(rnorm(120, 0, 1), nrow = 60))
processed_data &lt;- dataPreprocess(X = X1, covariates = covar, is_cv = TRUE, 
cv_quantile = 0.5, center = TRUE, scale = TRUE)

</code></pre>

<hr>
<h2 id='fastAutoSmCCNet'>Automated SmCCNet to Streamline the SmCCNet Pipeline</h2><span id='topic+fastAutoSmCCNet'></span>

<h3>Description</h3>

<p>Automated SmCCNet automatically identifies the project problem (single-omics vs multi-omics), 
and type of analysis (CCA for quantitative phenotype vs. PLS for binary phenotype) 
based on the input data that is provided. This method automatically preprocesses data, 
chooses scaling factors, subsampling percentage, and optimal penalty terms, 
then runs through the complete SmCCNet pipeline without the requirement for users to provide additional information. 
This function will store all the subnetwork information to a user-defined directory, as well as return all the global network and evaluation information. 
Refer to the automated SmCCNet vignette for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastAutoSmCCNet(
  X,
  Y,
  AdjustedCovar = NULL,
  preprocess = FALSE,
  Kfold = 5,
  EvalMethod = "accuracy",
  subSampNum = 100,
  DataType,
  BetweenShrinkage = 2,
  ScalingPen = c(0.1, 0.1),
  CutHeight = 1 - 0.1^10,
  min_size = 10,
  max_size = 100,
  summarization = "NetSHy",
  saving_dir = getwd(),
  ncomp_pls = 3,
  tuneLength = 5,
  tuneRangeCCA = c(0.1, 0.5),
  tuneRangePLS = c(0.5, 0.9),
  seed = 123
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastAutoSmCCNet_+3A_x">X</code></td>
<td>
<p>A list of matrices with same set and order of subjects (<code class="reqn">n</code>).</p>
</td></tr>
<tr><td><code id="fastAutoSmCCNet_+3A_y">Y</code></td>
<td>
<p>Phenotype variable of either numeric or binary, for binary variable, for binary <code class="reqn">Y</code>, it should be binarized to 0,1 before running this function.</p>
</td></tr>
<tr><td><code id="fastAutoSmCCNet_+3A_adjustedcovar">AdjustedCovar</code></td>
<td>
<p>A data frame of covariates of interest to be adjusted for through regressing-out approach, argument preprocess need to be set to TRUE if adjusting covariates are supplied.</p>
</td></tr>
<tr><td><code id="fastAutoSmCCNet_+3A_preprocess">preprocess</code></td>
<td>
<p>Whether the data preprocessing step should be conducted, default is set to FALSE. If regressing out covariates is needed, provide corresponding covariates to AdjustCovar argument.</p>
</td></tr>
<tr><td><code id="fastAutoSmCCNet_+3A_kfold">Kfold</code></td>
<td>
<p>Number of folds for cross-validation, default is set to 5.</p>
</td></tr>
<tr><td><code id="fastAutoSmCCNet_+3A_evalmethod">EvalMethod</code></td>
<td>
<p>The evaluation methods used to selected the optimal penalty parameter(s) when binary phenotype is given. The selections is among 'accuracy', 'auc', 'precision', 'recall', and 'f1', default is set to 'accuracy'.</p>
</td></tr>
<tr><td><code id="fastAutoSmCCNet_+3A_subsampnum">subSampNum</code></td>
<td>
<p>Number of subsampling to run, the higher the better in terms of accuracy, but at a cost of computational time, we generally recommend 500-1000 to increase robustness for larger data, default is set to 100.</p>
</td></tr>
<tr><td><code id="fastAutoSmCCNet_+3A_datatype">DataType</code></td>
<td>
<p>A vector indicating annotation of each dataset of <code class="reqn">X</code>, example would be <code>c('gene', 'miRNA')</code>.</p>
</td></tr>
<tr><td><code id="fastAutoSmCCNet_+3A_betweenshrinkage">BetweenShrinkage</code></td>
<td>
<p>A real number &gt; 0 that helps shrink the importance of omics-omics correlation component, the larger this number
is, the greater the shrinkage it is, default is set to 2.</p>
</td></tr>
<tr><td><code id="fastAutoSmCCNet_+3A_scalingpen">ScalingPen</code></td>
<td>
<p>A numeric vector of length 2 used as the penalty terms for scaling factor determination method: default set to 0.1 for both datasets, and 
should be between 0 and 1.</p>
</td></tr>
<tr><td><code id="fastAutoSmCCNet_+3A_cutheight">CutHeight</code></td>
<td>
<p>A numeric value specifying the cut height for hierarchical clustering, should be between 0 and 1, default is set to 1 - 0.1^10.</p>
</td></tr>
<tr><td><code id="fastAutoSmCCNet_+3A_min_size">min_size</code></td>
<td>
<p>Minimally possible subnetwork size after network pruning, default set to 10.</p>
</td></tr>
<tr><td><code id="fastAutoSmCCNet_+3A_max_size">max_size</code></td>
<td>
<p>Maximally possible subnetwork size after network pruning, default set to 100.</p>
</td></tr>
<tr><td><code id="fastAutoSmCCNet_+3A_summarization">summarization</code></td>
<td>
<p>Summarization method used for network pruning and summarization, should be either 'NetSHy' or 'PCA'.</p>
</td></tr>
<tr><td><code id="fastAutoSmCCNet_+3A_saving_dir">saving_dir</code></td>
<td>
<p>Directory where user would like to store the subnetwork results, default is set to the current working directory.</p>
</td></tr>
<tr><td><code id="fastAutoSmCCNet_+3A_ncomp_pls">ncomp_pls</code></td>
<td>
<p>Number of components for PLS algorithm, only used when binary phenotype is given, default is set to 3.</p>
</td></tr>
<tr><td><code id="fastAutoSmCCNet_+3A_tunelength">tuneLength</code></td>
<td>
<p>The total number of candidate penalty term values for each omics data, default is set to 5.</p>
</td></tr>
<tr><td><code id="fastAutoSmCCNet_+3A_tunerangecca">tuneRangeCCA</code></td>
<td>
<p>A vector of length 2 that represents the range of candidate penalty term values for each omics data based on canonical correlation analysis, 
default is set to <code>c(0.1,0.5)</code>.</p>
</td></tr>
<tr><td><code id="fastAutoSmCCNet_+3A_tunerangepls">tuneRangePLS</code></td>
<td>
<p>A vector of length 2 that represents the range of candidate penalty term values for each omics data based on partial least squared discriminant analysis, 
default is set to <code>c(0.5,0.9)</code>.</p>
</td></tr>
<tr><td><code id="fastAutoSmCCNet_+3A_seed">seed</code></td>
<td>
<p>Random seed for result reproducibility, default is set to 123.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the global adjacency matrix, omics data details, network clustering outcomes, and cross-validation results. Pruned subnetwork modules are saved in the directory specified by the user.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# library(SmCCNet)
# set.seed(123)
# data("ExampleData")
# Y_binary &lt;- ifelse(Y &gt; quantile(Y, 0.5), 1, 0)
## single-omics PLS
# result &lt;- fastAutoSmCCNet(X = list(X1), Y = as.factor(Y_binary), Kfold = 3, 
#                          subSampNum = 100, DataType = c('Gene'),
#                          saving_dir = getwd(), EvalMethod = 'auc', 
#                          summarization = 'NetSHy', 
#                          CutHeight = 1 - 0.1^10, ncomp_pls = 5)
## single-omics CCA
# result &lt;- fastAutoSmCCNet(X = list(X1), Y = Y, Kfold = 3, preprocess = FALSE,
#                           subSampNum = 50, DataType = c('Gene'),
#                           saving_dir = getwd(), summarization = 'NetSHy',
#                           CutHeight = 1 - 0.1^10)
## multi-omics PLS
# result &lt;- fastAutoSmCCNet(X = list(X1,X2), Y = as.factor(Y_binary), 
#                           Kfold = 3, subSampNum = 50, 
#                           DataType = c('Gene', 'miRNA'), 
#                           CutHeight = 1 - 0.1^10,
#                           saving_dir = getwd(), EvalMethod = 'auc', 
#                           summarization = 'NetSHy',
#                           BetweenShrinkage = 5, ncomp_pls = 3)
## multi-omics CCA
# result &lt;- fastAutoSmCCNet(X = list(X1,X2), Y = Y, 
#                           K = 3, subSampNum = 50, DataType = c('Gene', 'miRNA'), 
#                           CutHeight = 1 - 0.1^10,
#                           saving_dir = getwd(),  
#                           summarization = 'NetSHy',
#                           BetweenShrinkage = 5)

</code></pre>

<hr>
<h2 id='getAbar'>Calculate similarity matrix based on canonical weights.</h2><span id='topic+getAbar'></span>

<h3>Description</h3>

<p>Compute the similarity matrix based on the outer products of absolute
canonical correlation weights, can be used for both single and multi-omics setting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAbar(Ws, FeatureLabel = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAbar_+3A_ws">Ws</code></td>
<td>
<p>A canonical correlation weight vector or matrix. If <code>Ws</code> is a
matrix, then each column corresponds to one weight vector.</p>
</td></tr>
<tr><td><code id="getAbar_+3A_featurelabel">FeatureLabel</code></td>
<td>
<p>A vector of feature labels for each feature in the adjacency matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">p\times p</code> symmetric non-negative matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
w &lt;- matrix(rnorm(6), nrow = 3)
Ws &lt;- apply(w, 2, function(x)return(x/sqrt(sum(x^2))))
abar &lt;- getAbar(Ws,  FeatureLabel = c('omics1', 'omics2', 'omics3'))

</code></pre>

<hr>
<h2 id='getCanCorMulti'>Canonical Correlation Value for SmCCA</h2><span id='topic+getCanCorMulti'></span>

<h3>Description</h3>

<p>Calculate canonical correlation value for SmCCA given canonical weight vectors and scaling factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCanCorMulti(X, CCcoef, CCWeight, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCanCorMulti_+3A_x">X</code></td>
<td>
<p>A list of data each with same number of subjects.</p>
</td></tr>
<tr><td><code id="getCanCorMulti_+3A_cccoef">CCcoef</code></td>
<td>
<p>A vector of scaling factors indicating weights for each pairwise canonical correlation.</p>
</td></tr>
<tr><td><code id="getCanCorMulti_+3A_ccweight">CCWeight</code></td>
<td>
<p>A list of canonical weight vectors corresponds to each data in <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="getCanCorMulti_+3A_y">Y</code></td>
<td>
<p>A phenotype matrix, should have only one column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value of the total canonical correlation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SmCCNet)
data("ExampleData")
getCanCorMulti(list(X1,X2), CCcoef = c(1,1,1), 
CCWeight = list(rnorm(500,0,1), rnorm(100,0,1)), Y = Y)
</code></pre>

<hr>
<h2 id='getCanWeightsMulti'>Get Canonical Weight SmCCA Algorithm (No Subsampling)</h2><span id='topic+getCanWeightsMulti'></span>

<h3>Description</h3>

<p>Run Sparse multiple Canonical Correlation Analysis (SmCCA) and return
canonical weight vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCanWeightsMulti(
  X,
  Trait = NULL,
  Lambda,
  CCcoef = NULL,
  NoTrait = TRUE,
  trace = FALSE,
  TraitWeight = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCanWeightsMulti_+3A_x">X</code></td>
<td>
<p>A list of omics data each with n subjects.</p>
</td></tr>
<tr><td><code id="getCanWeightsMulti_+3A_trait">Trait</code></td>
<td>
<p>An <code class="reqn">n</code> by 1 trait (phenotype) data for the same samples.</p>
</td></tr>
<tr><td><code id="getCanWeightsMulti_+3A_lambda">Lambda</code></td>
<td>
<p>Lasso penalty vector with length equals to the number of omics data (<code class="reqn">X</code>). <code>Lambda</code> needs
to be between 0 and 1.</p>
</td></tr>
<tr><td><code id="getCanWeightsMulti_+3A_cccoef">CCcoef</code></td>
<td>
<p>Optional scaling factors for the SmCCA pairwise canonical
correlations. If <code>CCcoef = NULL</code> (default), then the objective function
is the total sum of all pairwise canonical correlations. It follows the column order of <code>combn(T+1, 2)</code>, where <code>T</code> is the total number of omics data.</p>
</td></tr>
<tr><td><code id="getCanWeightsMulti_+3A_notrait">NoTrait</code></td>
<td>
<p>Whether or not trait (phenotype) information is provided, default is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="getCanWeightsMulti_+3A_trace">trace</code></td>
<td>
<p>Whether to display CCA algorithm trace, default is set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getCanWeightsMulti_+3A_traitweight">TraitWeight</code></td>
<td>
<p>Whether to return canonical weight for trait (phenotype), default is set to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonical weight vector with size of <code class="reqn">p</code> by 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This function is typically used as an internal function.
# It is also used when performing cross-validation,
# refer to multi-omics vignette for more detail.
# X &lt;- list(X1,X2)
# result &lt;- getCanWeightsMulti(X, Trait = as.matrix(Y), Lambda = c(0.5,0.5), NoTrait = FALSE)
# result &lt;- getCanWeightsMulti(X, Trait = NULL, Lambda = c(0.5,0.5), NoTrait = TRUE)
# cccoef &lt;- c(1,10,10)
# result &lt;- getCanWeightsMulti(X, Trait = as.matrix(Y), CCcoef = cccoef, 
#                              Lambda = c(0.5,0.5), NoTrait = FALSE)
</code></pre>

<hr>
<h2 id='getCCAout_single'>Internal functions called by getRobustPseudoWeights_single.</h2><span id='topic+getCCAout_single'></span>

<h3>Description</h3>

<p>Internal functions called by getRobustPseudoWeights_single.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCCAout_single(X1, Trait, Lambda1, trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCCAout_single_+3A_x1">X1</code></td>
<td>
<p>data.</p>
</td></tr>
<tr><td><code id="getCCAout_single_+3A_trait">Trait</code></td>
<td>
<p>phenotype.</p>
</td></tr>
<tr><td><code id="getCCAout_single_+3A_lambda1">Lambda1</code></td>
<td>
<p>penalty term</p>
</td></tr>
<tr><td><code id="getCCAout_single_+3A_trace">trace</code></td>
<td>
<p>Whether to display CCA algorithm trace.</p>
</td></tr>
</table>

<hr>
<h2 id='getOmicsModules'>Extract Omics Modules based on Similarity Matrix.</h2><span id='topic+getOmicsModules'></span>

<h3>Description</h3>

<p>Apply hierarchical tree cutting to the similarity matrix and extract multi/single-omics network modules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getOmicsModules(Abar, CutHeight = 1 - 0.1^10, PlotTree = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getOmicsModules_+3A_abar">Abar</code></td>
<td>
<p>A similary matrix for all features (all omics data types).</p>
</td></tr>
<tr><td><code id="getOmicsModules_+3A_cutheight">CutHeight</code></td>
<td>
<p>Height threshold for the hierarchical tree cutting. Default
is <code class="reqn">1-0.1^{10}</code>.</p>
</td></tr>
<tr><td><code id="getOmicsModules_+3A_plottree">PlotTree</code></td>
<td>
<p>Logical. Whether to create a hierarchical tree plot, default is set to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of multi/single-omics modules.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
w &lt;- rnorm(5)
w &lt;- w/sqrt(sum(w^2))
feature_name &lt;- paste0('feature_', 1:5)
abar &lt;- getAbar(w, FeatureLabel = feature_name)
modules &lt;- getOmicsModules(abar, CutHeight = 0.5)
</code></pre>

<hr>
<h2 id='getRobustWeightsMulti'>Run Sparse multiple Canonical Correlation Analysis and Obtain Canonical Weights (with Subsampling)</h2><span id='topic+getRobustWeightsMulti'></span>

<h3>Description</h3>

<p>SmCCNet algorithm with multi-omics data and quantitative phenotype. Calculate the canonical weights for SmCCA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRobustWeightsMulti(
  X,
  Trait,
  Lambda,
  s = NULL,
  NoTrait = FALSE,
  SubsamplingNum = 1000,
  CCcoef = NULL,
  trace = FALSE,
  TraitWeight = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRobustWeightsMulti_+3A_x">X</code></td>
<td>
<p>A list of omics data each with n subjects.</p>
</td></tr>
<tr><td><code id="getRobustWeightsMulti_+3A_trait">Trait</code></td>
<td>
<p>An <code class="reqn">n\times 1</code> trait (phenotype) data matrix for the same n subjects.</p>
</td></tr>
<tr><td><code id="getRobustWeightsMulti_+3A_lambda">Lambda</code></td>
<td>
<p>Lasso penalty vector with length equals to the number of omics data (<code class="reqn">X</code>). <code>Lambda</code> needs
to be between 0 and 1.</p>
</td></tr>
<tr><td><code id="getRobustWeightsMulti_+3A_s">s</code></td>
<td>
<p>A vector with length equals to the number of omics data (<code class="reqn">X</code>), specifying the 
percentage of omics feature being subsampled at each subsampling iteration.</p>
</td></tr>
<tr><td><code id="getRobustWeightsMulti_+3A_notrait">NoTrait</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Whether trait information
is provided.</p>
</td></tr>
<tr><td><code id="getRobustWeightsMulti_+3A_subsamplingnum">SubsamplingNum</code></td>
<td>
<p>Number of feature subsamples. Default is 1000. Larger
number leads to more accurate results, but at a higher computational cost.</p>
</td></tr>
<tr><td><code id="getRobustWeightsMulti_+3A_cccoef">CCcoef</code></td>
<td>
<p>Optional scaling factors for the SmCCA pairwise canonical
correlations. If <code>CCcoef = NULL</code> (default), then the objective function
is the total sum of all pairwise canonical correlations. This 
coefficient vector follows the column order of <code>combn(T+1, 2)</code> assuming there are T omics data and a phenotype data.</p>
</td></tr>
<tr><td><code id="getRobustWeightsMulti_+3A_trace">trace</code></td>
<td>
<p>Whether to display the CCA algorithm trace, default is set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getRobustWeightsMulti_+3A_traitweight">TraitWeight</code></td>
<td>
<p>Whether to return canonical weight for trait (phenotype), default is set to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonical correlation weight matrix with <code class="reqn">p = \sum_{i} p_i</code> rows, where <code class="reqn">p_i</code> is the number of features for the <code class="reqn">i</code>th omics. Each
column is the canonical correlation weights based on subsampled features. The number of columns is <code>SubsamplingNum</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## For illustration, we only subsample 5 times.
set.seed(123)
X1 &lt;- matrix(rnorm(600,0,1), nrow = 60)
X2 &lt;- matrix(rnorm(600,0,1), nrow = 60)
Y &lt;- matrix(rnorm(60,0,1), nrow = 60)
# Unweighted SmCCA
result &lt;- getRobustWeightsMulti(X = list(X1, X2), Trait = Y, NoTrait = FALSE,
Lambda = c(0.5, 0.5),s = c(0.7, 0.7), SubsamplingNum = 20)
  
</code></pre>

<hr>
<h2 id='getRobustWeightsMultiBinary'>Run Sparse multiple Canonical Correlation Analysis and Obtain Canonical Weights (with Subsampling)</h2><span id='topic+getRobustWeightsMultiBinary'></span>

<h3>Description</h3>

<p>SmCCNet algorithm with multi-omics data and binary phenotype. This is a stepwise approach 
(1) use SmCCA to identify relationship between omics (exlude phenotype), (2) within highly connected omics features
selected in step 1, identify relationship between these selected omics features and phenotype of interest with 
sparse PLS. First, it computes PLSDA by assuming outcome is continuous to extract multiple latent factors, then uses latent factors to fit logistic regression, and weight latent factor by
regression parameters. Refer to multi-omics vignette for more detail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRobustWeightsMultiBinary(
  X,
  Y,
  Between_Discriminate_Ratio = c(1, 1),
  SubsamplingPercent = NULL,
  CCcoef = NULL,
  LambdaBetween,
  LambdaPheno = NULL,
  SubsamplingNum = 1000,
  ncomp_pls = 3,
  EvalClassifier = FALSE,
  testData = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRobustWeightsMultiBinary_+3A_x">X</code></td>
<td>
<p>A list of omics data each with n subjects.</p>
</td></tr>
<tr><td><code id="getRobustWeightsMultiBinary_+3A_y">Y</code></td>
<td>
<p>A vector of binary variable, user needs to set the level of this 
variable to 0 and 1.</p>
</td></tr>
<tr><td><code id="getRobustWeightsMultiBinary_+3A_between_discriminate_ratio">Between_Discriminate_Ratio</code></td>
<td>
<p>A vector with length 2 specifying the relative importance
of between-omics relationship and omics-phenotype relationship. For instance a ratio of 1:1 (c(1,1) in the argument)
means between-omics relationship and omics-phenotype relationship contribute equally to the canonical weights extraction.</p>
</td></tr>
<tr><td><code id="getRobustWeightsMultiBinary_+3A_subsamplingpercent">SubsamplingPercent</code></td>
<td>
<p>A vector with length equal to the number of omics data (<code>X</code>), specifying the 
percentage of omics feature being subsampled at each subsampling iteration.</p>
</td></tr>
<tr><td><code id="getRobustWeightsMultiBinary_+3A_cccoef">CCcoef</code></td>
<td>
<p>A vector of scaling factors only for between-omics relationship (exclude omics-phenotype). This 
coefficient vector follows the column order of <code>combn(T, 2)</code> when there are <code>T</code> omics data.</p>
</td></tr>
<tr><td><code id="getRobustWeightsMultiBinary_+3A_lambdabetween">LambdaBetween</code></td>
<td>
<p>A vector of sparsity penalty value for each omics data to run the between-omics SmCCA, each 
penalty term should be within the range of 0 and 1.</p>
</td></tr>
<tr><td><code id="getRobustWeightsMultiBinary_+3A_lambdapheno">LambdaPheno</code></td>
<td>
<p>A penalty term when running the sparse PLS with phenotype, penalty term should be within the range of 0 and 1.</p>
</td></tr>
<tr><td><code id="getRobustWeightsMultiBinary_+3A_subsamplingnum">SubsamplingNum</code></td>
<td>
<p>Number of feature subsamples. Default is 1000. Larger
number leads to more accurate results, but at a higher computational cost, default is set to 1000.</p>
</td></tr>
<tr><td><code id="getRobustWeightsMultiBinary_+3A_ncomp_pls">ncomp_pls</code></td>
<td>
<p>Number of latent components for PLS, default set to 3.</p>
</td></tr>
<tr><td><code id="getRobustWeightsMultiBinary_+3A_evalclassifier">EvalClassifier</code></td>
<td>
<p>If <code>TRUE</code>, the algorithm is at the phase of evaluating classification performance, and the latent factors from SPLSDA will be returned; if FALSE, the algorithm is at the phase of constructing multi-omics network, canonical weight will be returned. 
Default is set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getRobustWeightsMultiBinary_+3A_testdata">testData</code></td>
<td>
<p>A list of testing omics data matrix, should have the exact same order as data list X, only used when EvalClassifier is set to <code>TRUE</code> for performing cross-validation, refer to multi-omics vignette for detail.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>EvalClassifier</code> is set to <code>FALSE</code>, a canonical correlation weight matrix is returned with combined omics data. Each
column is the canonical correlation weights based on subsampled X features. The number of columns is <code>SubsamplingNum</code>. If <code>EvalClassifier</code> is set to <code>TRUE</code>, then latent factors from training and testing data will be returned for classifier evaluation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## For illustration, we only subsample 5 times.
set.seed(123)
X1 &lt;- matrix(rnorm(600,0,1), nrow = 60)
X2 &lt;- matrix(rnorm(600,0,1), nrow = 60)
Y_binary &lt;- rbinom(60,1,0.5)

Ws &lt;- getRobustWeightsMultiBinary(list(X1,X2), Y_binary, 
      SubsamplingPercent = c(0.8,0.8), CCcoef = NULL,
      LambdaBetween = c(0.5,0.5), LambdaPheno = 0.1, SubsamplingNum = 10)
  
</code></pre>

<hr>
<h2 id='getRobustWeightsSingle'>Single-omics SmCCA with Quantitative Phenotype</h2><span id='topic+getRobustWeightsSingle'></span>

<h3>Description</h3>

<p>Compute aggregated (SmCCA) canonical weights for single omics data with quantitative phenotype (subampling enabled).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRobustWeightsSingle(
  X1,
  Trait,
  Lambda1,
  s1 = 0.7,
  SubsamplingNum = 1000,
  trace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRobustWeightsSingle_+3A_x1">X1</code></td>
<td>
<p>An <code class="reqn">n\times p_1</code> data matrix (e.g. mRNA) with <code class="reqn">p_1</code>
features and <code class="reqn">n</code> subjects.</p>
</td></tr>
<tr><td><code id="getRobustWeightsSingle_+3A_trait">Trait</code></td>
<td>
<p>An <code class="reqn">n\times 1</code> trait (phenotype) data matrix for the same <code class="reqn">n</code> subjects.</p>
</td></tr>
<tr><td><code id="getRobustWeightsSingle_+3A_lambda1">Lambda1</code></td>
<td>
<p>LASSO penalty parameter for <code>X1</code>. <code>Lambda1</code> needs
to be between 0 and 1.</p>
</td></tr>
<tr><td><code id="getRobustWeightsSingle_+3A_s1">s1</code></td>
<td>
<p>Proportion of features in <code>X1</code> to be included, default at <code>s1 =
0.7</code>. <code>s1</code> needs to be between 0 and 1, default is set to 0.7.</p>
</td></tr>
<tr><td><code id="getRobustWeightsSingle_+3A_subsamplingnum">SubsamplingNum</code></td>
<td>
<p>Number of feature subsamples. Default is 1000. Larger
number leads to more accurate results, but at a higher computational cost.</p>
</td></tr>
<tr><td><code id="getRobustWeightsSingle_+3A_trace">trace</code></td>
<td>
<p>Whether to display the CCA algorithm trace, default is set to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A canonical correlation weight matrix with <code class="reqn">p_1</code> rows. Each
column is the canonical correlation weights based on subsampled <code>X1</code>
features. The number of columns is <code>SubsamplingNum</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## For illustration, we only subsample 5 times.
set.seed(123)

# Single Omics SmCCA
W1 &lt;- getRobustWeightsSingle(X1, Trait = Y, Lambda1 = 0.05,
  s1 = 0.7, 
  SubsamplingNum = 5, trace = FALSE)
  
  
</code></pre>

<hr>
<h2 id='getRobustWeightsSingleBinary'>Single-omics SmCCA with Binary Phenotype</h2><span id='topic+getRobustWeightsSingleBinary'></span>

<h3>Description</h3>

<p>Compute aggregated (SmCCA) canonical weights for single omics data with quantitative phenotype (subampling enabled).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRobustWeightsSingleBinary(
  X1,
  Trait,
  Lambda1,
  s1 = 0.7,
  SubsamplingNum = 1000,
  K = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRobustWeightsSingleBinary_+3A_x1">X1</code></td>
<td>
<p>An <code class="reqn">n\times p_1</code> data matrix (e.g. mRNA) with <code class="reqn">p_1</code>
features and <code class="reqn">n</code> subjects.</p>
</td></tr>
<tr><td><code id="getRobustWeightsSingleBinary_+3A_trait">Trait</code></td>
<td>
<p>An <code class="reqn">n\times 1</code> trait (phenotype) data matrix for the same <code class="reqn">n</code> subjects.</p>
</td></tr>
<tr><td><code id="getRobustWeightsSingleBinary_+3A_lambda1">Lambda1</code></td>
<td>
<p>LASSO penalty parameter for <code>X1</code>. <code>Lambda1</code> needs
to be between 0 and 1.</p>
</td></tr>
<tr><td><code id="getRobustWeightsSingleBinary_+3A_s1">s1</code></td>
<td>
<p>Proportion of mRNA features to be included, default at <code>s1 =
0.7</code>. <code>s1</code> needs to be between 0 and 1, default is set to 0.7.</p>
</td></tr>
<tr><td><code id="getRobustWeightsSingleBinary_+3A_subsamplingnum">SubsamplingNum</code></td>
<td>
<p>Number of feature subsamples. Default is 1000. Larger
number leads to more accurate results, but at a higher computational cost.</p>
</td></tr>
<tr><td><code id="getRobustWeightsSingleBinary_+3A_k">K</code></td>
<td>
<p>Number of hidden components for PLSDA, default is set to 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A partial least squared weight matrix with <code class="reqn">p_1</code> rows. Each
column is the canonical correlation weights based on subsampled <code>X1</code>
features. The number of columns is <code>SubsamplingNum</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

X &lt;- matrix(rnorm(600,0,1), nrow = 60)
Y &lt;- rbinom(60,1,0.5)
Ws &lt;- getRobustWeightsSingleBinary(X1 = X, Trait = as.matrix(Y), Lambda1 = 0.8, 
0.7, SubsamplingNum = 10)

</code></pre>

<hr>
<h2 id='networkPruning'>Prunes Subnetwork and Return Final Pruned Subnetwork Module</h2><span id='topic+networkPruning'></span>

<h3>Description</h3>

<p>Prunes subnetworks with network pruning algorithm (see multi-omics vignette for detail), and save the final pruned subnetwork to the user-defined directory.
The final subnetwork is an .Rdata file with a name 'size_m_net_ind.Rdata', where <code class="reqn">m</code> is the final pruned network size, and ind is the index of the subnetwork module after hierarchical clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>networkPruning(
  Abar,
  CorrMatrix,
  data,
  Pheno,
  type,
  ModuleIdx,
  min_mod_size = 10,
  max_mod_size,
  damping = 0.9,
  method = "NetSHy",
  saving_dir
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="networkPruning_+3A_abar">Abar</code></td>
<td>
<p>Adjacency matrix of subnetwork with size <code class="reqn">m^{*}</code> by <code class="reqn">m^{*}</code> after hierarchical clustering.</p>
</td></tr>
<tr><td><code id="networkPruning_+3A_corrmatrix">CorrMatrix</code></td>
<td>
<p>The correlation matrix of features in <code>Abar</code>, it should be
<code class="reqn">m^{*}</code> by <code class="reqn">m^{*}</code> as well.</p>
</td></tr>
<tr><td><code id="networkPruning_+3A_data">data</code></td>
<td>
<p>The omics data for the subnetwork.</p>
</td></tr>
<tr><td><code id="networkPruning_+3A_pheno">Pheno</code></td>
<td>
<p>The trait (phenotype) data used for network pruning.</p>
</td></tr>
<tr><td><code id="networkPruning_+3A_type">type</code></td>
<td>
<p>A vector with length equal to total number of features in the adjacency matrix
indicating the type of data for each feature. For instance, for a subnetwork with 2 genes and a protein, the <code>type</code> argument should be set to <code>c('gene', 'gene', 'protein')</code>, see multi-omics vignette for more information.</p>
</td></tr>
<tr><td><code id="networkPruning_+3A_moduleidx">ModuleIdx</code></td>
<td>
<p>The index of the network module that summarization score is
intended to be stored, this is used for naming the subnetwork file in user-defined directory.</p>
</td></tr>
<tr><td><code id="networkPruning_+3A_min_mod_size">min_mod_size</code></td>
<td>
<p>The minimally possible subnetwork size for the pruned network module,
should be an integer from 1 to the largest possible size of the subnetwork, default is set to 10.</p>
</td></tr>
<tr><td><code id="networkPruning_+3A_max_mod_size">max_mod_size</code></td>
<td>
<p>the maximally possible subnetwork size for the pruned network module,
should be an integer from 1 to the largest possible size of the subnetwork, and it needs to be greater than the value specified in <code>min_mod_size</code>.</p>
</td></tr>
<tr><td><code id="networkPruning_+3A_damping">damping</code></td>
<td>
<p>damping parameter for the PageRank algorithm, default is set to 0.9, see <code>igraph</code> package for more detail.</p>
</td></tr>
<tr><td><code id="networkPruning_+3A_method">method</code></td>
<td>
<p>Selection between NetSHy' and 'PCA', specifying the network summarization method used for network pruning, default is set to NetSHy.</p>
</td></tr>
<tr><td><code id="networkPruning_+3A_saving_dir">saving_dir</code></td>
<td>
<p>User-defined directory to store pruned subnetwork.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A file stored in the user-defined directory, which contains the
following: (1) correlation_sub: correlation matrix for the subnetwork.
(2) M: adjacency matrix for the subnetwork.
(3) omics_corelation_data: individual molecular feature correlation with phenotype.
(4) pc_correlation: first 3 PCs correlation with phenotype.
(5) pc_loading: principal component loadings.
(6) pca_x1_score: principal component score and phenotype data.
(7) mod_size: number of molecular features in the subnetwork.
(8) sub_type: type of feature for each molecular features.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SmCCNet)
set.seed(123)
w &lt;- rnorm(20)
w &lt;- w/sqrt(sum(w^2))
labels &lt;- paste0('feature_', 1:20)
abar &lt;- getAbar(w, FeatureLabel = labels)
modules &lt;- getOmicsModules(abar, CutHeight = 0.1)
x &lt;- X1[ ,seq_len(20)]
corr &lt;- stats::cor(x)
# display only example
# networkPruning(abar, corr, data = x, Pheno = Y,
# ModuleIdx = 1,  min_mod_size = 3, max_mod_size = 10, method = 'NetSHy', saving_dir = 
# )

</code></pre>

<hr>
<h2 id='scalingFactorInput'>Scaling Factor Input Prompt</h2><span id='topic+scalingFactorInput'></span>

<h3>Description</h3>

<p>Input the vector of the annotation of each type of dataset in the data list X (e.g., <code>c('gene', 'protein')</code>), and return prompt ask the user to supply the scaling 
factor for SmCCNet algorithm to prioritize the correlation structures of 
interest. All scaling factor values supplied should be numeric and nonnegative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalingFactorInput(DataType = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalingFactorInput_+3A_datatype">DataType</code></td>
<td>
<p>A character vector that contains the annotation of each type of omics dataset in X.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of scaling factors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># not run
# scalingFactorInput(c('gene','mirna', 'phenotype'))

</code></pre>

<hr>
<h2 id='summarizeNetSHy'>NetSHy Summarization Score</h2><span id='topic+summarizeNetSHy'></span>

<h3>Description</h3>

<p>Implement NetSHy network summarization via a hybrid approach (Vu et al.,) to 
summarize network by considering the network topology with Laplacian matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarizeNetSHy(X, A, npc = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarizeNetSHy_+3A_x">X</code></td>
<td>
<p>An <code class="reqn">n\times m</code> data matrix  with <code class="reqn">m</code>
features and <code class="reqn">n</code> subjects.</p>
</td></tr>
<tr><td><code id="summarizeNetSHy_+3A_a">A</code></td>
<td>
<p>Corresponding adjacency matrix of size <code class="reqn">p</code> by <code class="reqn">p</code>.</p>
</td></tr>
<tr><td><code id="summarizeNetSHy_+3A_npc">npc</code></td>
<td>
<p>Number of principal components used to summarize the network, default is set to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consists of (1) subject-level network summarization score,
(2) principal component importance information: standard deviation, percent of variance explained, and cumulative proportion of variance explained, and (3) principal component feature-level loadings.
</p>


<h3>References</h3>

<p>Vu, Thao, Elizabeth M. Litkowski, Weixuan Liu, Katherine A. Pratte, Leslie Lange, Russell P. Bowler, Farnoush Banaei-Kashani, and Katerina J. Kechris. &quot;NetSHy: network summarization via a hybrid approach leveraging topological properties.&quot; Bioinformatics 39, no. 1 (2023): btac818.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate omics data
OmicsData &lt;- matrix(rnorm(200,0,1), nrow = 10, ncol = 20)
# simulate omics adjacency matrix
set.seed(123)
w &lt;- rnorm(20)
w &lt;- w/sqrt(sum(w^2))
featurelabel &lt;- paste0('omics',1:20)
abar &lt;- getAbar(w, FeatureLabel = featurelabel)
# extract NetSHy summarization score
netshy_score &lt;- summarizeNetSHy(OmicsData, abar)

</code></pre>

<hr>
<h2 id='X1'>A synthetic mRNA expression dataset.</h2><span id='topic+X1'></span>

<h3>Description</h3>

<p>A matrix containing simulated mRNA expression levels for 358 subjects (rows)
and 500 features (columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>X1
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 358 rows and 500 columns.
</p>

<hr>
<h2 id='X2'>A synthetic miRNA expression dataset.</h2><span id='topic+X2'></span>

<h3>Description</h3>

<p>A matrix containing simulated miRNA expression levels for 358 subjects (rows)
and 100 features (columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>X2
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 358 rows and 100 columns.
</p>

<hr>
<h2 id='Y'>A synthetic phenotype dataset.</h2><span id='topic+Y'></span>

<h3>Description</h3>

<p>A matrix containing simulated quantitative phenotype measures for 358 
subjects (rows).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Y
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 358 rows and 1 columns.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
