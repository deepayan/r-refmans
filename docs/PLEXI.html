<!DOCTYPE html><html><head><title>Help for package PLEXI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PLEXI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_igraph'><p>Convert plexi graph data to igraph</p></a></li>
<li><a href='#as_plexi_graph'><p>Convert adjacency matrix to plexi graph data</p></a></li>
<li><a href='#distance'><p>Function to calculate distance between two vectors</p></a></li>
<li><a href='#ednn'><p>Encoder decoder neural network (EDNN) function</p></a></li>
<li><a href='#ednn_io_prepare'><p>Preparing the input and output of the EDNN for a multiplex graph</p></a></li>
<li><a href='#example_data'><p>Example Data</p></a></li>
<li><a href='#network_gen'><p>Multiplex Network Generation</p></a></li>
<li><a href='#p_val_count'><p>Calculate p.value for x given set of null values using counts</p></a></li>
<li><a href='#p_val_norm'><p>Calculate p.value for x given set of null values using a Gaussian null pdf</p></a></li>
<li><a href='#p_val_rank'><p>Calculate p.value for x given a set of null values using ranks</p></a></li>
<li><a href='#plexi_distance_test_isn'><p>Test the embedding distances of local neighbors change between the two conditions for ISNs.</p></a></li>
<li><a href='#plexi_distance_test1_isn'><p>Test the extremeness of embedding distances of local neighbors.</p></a></li>
<li><a href='#plexi_embedding'><p>Calculate the embedding space for a multiplex network</p></a></li>
<li><a href='#plexi_embedding_2layer'><p>Calculate the embedding space for a two layer multiplex network</p></a></li>
<li><a href='#plexi_node_detection_2layer'><p>Detecting the nodes whose local neighbors change bweteen the two conditions.</p></a></li>
<li><a href='#plexi_node_distance'><p>Detecting the nodes whose local neighbors change between the two conditions for ISNs.</p></a></li>
<li><a href='#Rank'><p>Ranking a vector</p></a></li>
<li><a href='#rep_random_walk'><p>Repetitive Fixed-length (weighted) random walk algorithm</p></a></li>
<li><a href='#subgraph_difference_plot'><p>Visualization of a difference subgroup using a circular graph</p></a></li>
<li><a href='#subgraph_plot'><p>Visualization of a subgroup using a circular graph</p></a></li>
<li><a href='#weightd_random_walk'><p>Weighted Random Walk algorithm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiplex Network Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Interactions between different biological entities are crucial for the function of biological systems. 
    In such networks, nodes represent biological elements, such as genes, proteins and microbes, and their interactions can be defined by edges, which can be either binary or weighted.
    The dysregulation of these networks can be associated with different clinical conditions such as diseases and response to treatments. 
    However, such variations often occur locally and do not concern the whole network. 
    To capture local variations of such networks, we propose multiplex network differential analysis (MNDA). 
    MNDA allows to quantify the variations in the local neighborhood of each node (e.g. gene) between the two given clinical states, and to test for statistical significance of such variation.
    Yousefi et al. (2023) &lt;<a href="https://doi.org/10.1101%2F2023.01.22.525058">doi:10.1101/2023.01.22.525058</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, igraph, keras, ggraph, ggplot2, aggregation,
stats, graphics</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-26 21:04:31 UTC; behnam</td>
</tr>
<tr>
<td>Author:</td>
<td>Behnam Yousefi [aut, cre, cph],
  Farzaneh Firoozbakht [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Behnam Yousefi &lt;yousefi.bme@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-09 15:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_igraph'>Convert plexi graph data to igraph</h2><span id='topic+as_igraph'></span>

<h3>Description</h3>

<p>Convert plexi graph data to igraph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_igraph(plexi.graph, edge.threshold = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_igraph_+3A_plexi.graph">plexi.graph</code></td>
<td>
<p>plexi graph data</p>
</td></tr>
<tr><td><code id="as_igraph_+3A_edge.threshold">edge.threshold</code></td>
<td>
<p>numeric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>igraph object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = example_data()
graph = as_igraph(plexi.graph = data[["plexi_graph_example"]])

</code></pre>

<hr>
<h2 id='as_plexi_graph'>Convert adjacency matrix to plexi graph data</h2><span id='topic+as_plexi_graph'></span>

<h3>Description</h3>

<p>Convert adjacency matrix to plexi graph data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_plexi_graph(adj.list, outcome = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_plexi_graph_+3A_adj.list">adj.list</code></td>
<td>
<p>list of adjacency matrices with matching nodes</p>
</td></tr>
<tr><td><code id="as_plexi_graph_+3A_outcome">outcome</code></td>
<td>
<p>graph outcomes or graph labels. If NULL, <code>outcome = 1:N_graphs</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plexi.graph data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = example_data()
adj.list = list(data[["adj_mat_example"]], data[["adj_mat_example"]])
graph.data = as_plexi_graph(adj.list)

</code></pre>

<hr>
<h2 id='distance'>Function to calculate distance between two vectors</h2><span id='topic+distance'></span>

<h3>Description</h3>

<p>Function to calculate distance between two vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance(x, y, method = "cosine")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="distance_+3A_y">y</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="distance_+3A_method">method</code></td>
<td>
<p>distance calculation method: cosine (default), dot.prod, euclidian, manhattan, chebyshev, coassociation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the distance value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = c(1,2,3)
y = c(6,4,6)
distance(x,y)

</code></pre>

<hr>
<h2 id='ednn'>Encoder decoder neural network (EDNN) function</h2><span id='topic+ednn'></span>

<h3>Description</h3>

<p>Encoder decoder neural network (EDNN) function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ednn(
  x,
  y,
  x.test,
  embedding.size = 2,
  epochs = 10,
  batch.size = 5,
  l2reg = 0,
  demo = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ednn_+3A_x">x</code></td>
<td>
<p>concatenated adjacency matrices for different layers containing the nodes in training phase</p>
</td></tr>
<tr><td><code id="ednn_+3A_y">y</code></td>
<td>
<p>concatenated random walk probability matrices for different layers containing the nodes in training phase</p>
</td></tr>
<tr><td><code id="ednn_+3A_x.test">x.test</code></td>
<td>
<p>concatenated adjacency matrices for different layers containing the nodes in test phase. Can be = <em>X</em> for transductive inference.</p>
</td></tr>
<tr><td><code id="ednn_+3A_embedding.size">embedding.size</code></td>
<td>
<p>the dimension of embedding space, equal to the number of the bottleneck hidden nodes.</p>
</td></tr>
<tr><td><code id="ednn_+3A_epochs">epochs</code></td>
<td>
<p>maximum number of pocks. An early stopping callback with a patience of 5 has been set inside the function (default = 10).</p>
</td></tr>
<tr><td><code id="ednn_+3A_batch.size">batch.size</code></td>
<td>
<p>batch size for learning (default = 5).</p>
</td></tr>
<tr><td><code id="ednn_+3A_l2reg">l2reg</code></td>
<td>
<p>the coefficient of L2 regularization for the input layer (default = 0).</p>
</td></tr>
<tr><td><code id="ednn_+3A_demo">demo</code></td>
<td>
<p>a boolean vector to indicate this is a demo example or not</p>
</td></tr>
<tr><td><code id="ednn_+3A_verbose">verbose</code></td>
<td>
<p>if <em>TRUE</em> a progress bar is shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The embedding space for x.test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myNet = network_gen(n.nodes = 50)
graphData = myNet[["data_graph"]]
edge.list = graphData[,1:2]
edge.weight = graphData[,3:4]
XY = ednn_io_prepare(edge.list, edge.weight)
X = XY[["X"]]
Y = XY[["Y"]]
embeddingSpace = ednn(x = X, y = Y, x.test = X)

</code></pre>

<hr>
<h2 id='ednn_io_prepare'>Preparing the input and output of the EDNN for a multiplex graph</h2><span id='topic+ednn_io_prepare'></span>

<h3>Description</h3>

<p>Preparing the input and output of the EDNN for a multiplex graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ednn_io_prepare(
  edge.list,
  edge.weight,
  outcome = NULL,
  indv.index = NULL,
  edge.threshold = 0,
  walk.rep = 10,
  n.steps = 5,
  random.walk = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ednn_io_prepare_+3A_edge.list">edge.list</code></td>
<td>
<p>edge list as a dataframe with two columns.</p>
</td></tr>
<tr><td><code id="ednn_io_prepare_+3A_edge.weight">edge.weight</code></td>
<td>
<p>edge weights as a dataframe. Each column corresponds to a graph. By default, the <code>colnames</code> are considered as outcomes unless indicated in <code>outcome</code> argument.</p>
</td></tr>
<tr><td><code id="ednn_io_prepare_+3A_outcome">outcome</code></td>
<td>
<p>clinical outcomes for each graph. If not mentioned, the <code>colnames(edge.weight)</code> are considered by default.</p>
</td></tr>
<tr><td><code id="ednn_io_prepare_+3A_indv.index">indv.index</code></td>
<td>
<p>the index of individual networks.</p>
</td></tr>
<tr><td><code id="ednn_io_prepare_+3A_edge.threshold">edge.threshold</code></td>
<td>
<p>numeric value to set edge weights below the threshold to zero (default: 0). the greater edge weights do not change.</p>
</td></tr>
<tr><td><code id="ednn_io_prepare_+3A_walk.rep">walk.rep</code></td>
<td>
<p>number of repeats for the random walk (default: 100).</p>
</td></tr>
<tr><td><code id="ednn_io_prepare_+3A_n.steps">n.steps</code></td>
<td>
<p>number of the random walk steps (default: 5).</p>
</td></tr>
<tr><td><code id="ednn_io_prepare_+3A_random.walk">random.walk</code></td>
<td>
<p>boolean value to enable the random walk algorithm (default: TRUE).</p>
</td></tr>
<tr><td><code id="ednn_io_prepare_+3A_verbose">verbose</code></td>
<td>
<p>if <em>TRUE</em> a progress bar is shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the input and output required to train the EDNN
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myNet = network_gen(n.nodes = 50)
graphData = myNet[["data_graph"]]
edge.list = graphData[,1:2]
edge.weight = graphData[,3:4]
XY = ednn_io_prepare(edge.list, edge.weight)
X = XY[["X"]]
Y = XY[["Y"]]

</code></pre>

<hr>
<h2 id='example_data'>Example Data</h2><span id='topic+example_data'></span>

<h3>Description</h3>

<p>Example Data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_data()
</code></pre>


<h3>Value</h3>

<p>example data as a list: &quot;adj_mat_example&quot;, &quot;igraph_example&quot;, &quot;plexi_graph_example&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = example_data()
</code></pre>

<hr>
<h2 id='network_gen'>Multiplex Network Generation</h2><span id='topic+network_gen'></span>

<h3>Description</h3>

<p>Multiplex Network Generation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_gen(n.nodes = 100, n.var.nodes = 5, n.var.nei = 90, noise.sd = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_gen_+3A_n.nodes">n.nodes</code></td>
<td>
<p>number of nodes in the graph</p>
</td></tr>
<tr><td><code id="network_gen_+3A_n.var.nodes">n.var.nodes</code></td>
<td>
<p>number of nodes whose neighborhood should change from layer 1 to 2</p>
</td></tr>
<tr><td><code id="network_gen_+3A_n.var.nei">n.var.nei</code></td>
<td>
<p>number of neighbors that should be changing from layer 1 to 2</p>
</td></tr>
<tr><td><code id="network_gen_+3A_noise.sd">noise.sd</code></td>
<td>
<p>the standard deviation of the noise added to the edge weights</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this script we generate random pairs of gene co-expression networks,
which are different only in a few (pre-set) number of nodes.
</p>


<h3>Value</h3>

<p>No return value, called to plot subgraphs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myNet = network_gen(n.nodes = 100)
graphData = myNet[["data_graph"]]
varNodes = myNet[["var_node_set"]]

</code></pre>

<hr>
<h2 id='p_val_count'>Calculate p.value for x given set of null values using counts</h2><span id='topic+p_val_count'></span>

<h3>Description</h3>

<p>Calculate p.value for x given set of null values using counts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_val_count(x, null.values, alternative = "two.sided")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_val_count_+3A_x">x</code></td>
<td>
<p>numeric value</p>
</td></tr>
<tr><td><code id="p_val_count_+3A_null.values">null.values</code></td>
<td>
<p>a numeric vector of null distribution samples</p>
</td></tr>
<tr><td><code id="p_val_count_+3A_alternative">alternative</code></td>
<td>
<p>alterative test including: <code>"two.sided"</code> [default],
<code>"greater"</code>, and  <code>"less"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>p.value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p.val = p_val_count(1, 1:100)

</code></pre>

<hr>
<h2 id='p_val_norm'>Calculate p.value for x given set of null values using a Gaussian null pdf</h2><span id='topic+p_val_norm'></span>

<h3>Description</h3>

<p>Calculate p.value for x given set of null values using a Gaussian null pdf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_val_norm(x, null.values, alternative = "two.sided")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_val_norm_+3A_x">x</code></td>
<td>
<p>numeric value</p>
</td></tr>
<tr><td><code id="p_val_norm_+3A_null.values">null.values</code></td>
<td>
<p>a numeric vector of null distribution samples</p>
</td></tr>
<tr><td><code id="p_val_norm_+3A_alternative">alternative</code></td>
<td>
<p>alterative test including: <code>"two.sided"</code> [default],
<code>"greater"</code>, and  <code>"less"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>p.value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p.val = p_val_norm(1, rnorm(1000,0,1))

</code></pre>

<hr>
<h2 id='p_val_rank'>Calculate p.value for x given a set of null values using ranks</h2><span id='topic+p_val_rank'></span>

<h3>Description</h3>

<p>Calculate p.value for x given a set of null values using ranks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_val_rank(x, null.values, alternative = "two.sided")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_val_rank_+3A_x">x</code></td>
<td>
<p>numeric value</p>
</td></tr>
<tr><td><code id="p_val_rank_+3A_null.values">null.values</code></td>
<td>
<p>a numeric vector of null distribution samples</p>
</td></tr>
<tr><td><code id="p_val_rank_+3A_alternative">alternative</code></td>
<td>
<p>alterative test including: <code>"two.sided"</code> [default],
<code>"greater"</code>, and  <code>"less"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>p.value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p.val = p_val_rank(1, 1:100)

</code></pre>

<hr>
<h2 id='plexi_distance_test_isn'>Test the embedding distances of local neighbors change between the two conditions for ISNs.</h2><span id='topic+plexi_distance_test_isn'></span>

<h3>Description</h3>

<p>Test the embedding distances of local neighbors change between the two conditions for ISNs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plexi_distance_test_isn(
  distance,
  y,
  stat.test = "wilcox.test",
  p.adjust.method = "none"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plexi_distance_test_isn_+3A_distance">distance</code></td>
<td>
<p>a distance list obtained by the <code>plexi_node_distance()</code> function.</p>
</td></tr>
<tr><td><code id="plexi_distance_test_isn_+3A_y">y</code></td>
<td>
<p>vector with the length equal to the number of individuals.</p>
</td></tr>
<tr><td><code id="plexi_distance_test_isn_+3A_stat.test">stat.test</code></td>
<td>
<p>statistical test used to detect the nodes <code>c("t.test","wilcox.test")</code> (default: wilcox.test)</p>
</td></tr>
<tr><td><code id="plexi_distance_test_isn_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p-value (including methods on <code>p.adjust.methods</code>).
If set to &quot;none&quot; (default), no adjustment will be performed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The adjusted p-values for each node is calculated based on their distance variation between
the two conditions.
</p>


<h3>Value</h3>

<p>The adjusted pvalues for each node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ISN1 = network_gen(n.nodes = 50, n.var.nodes = 5, n.var.nei = 40, noise.sd = .01)
ISN2 = network_gen(n.nodes = 50, n.var.nodes = 5, n.var.nei = 40, noise.sd = .01)
graph_data = cbind(ISN1[["data_graph"]], ISN1[["data_graph"]][,3:4])
embeddingSpaceList = plexi_embedding(graph.data=graph_data, outcome=c(1,2,1,2),
indv.index=c(1,1,2,2), train.rep=2, random.walk=FALSE)
Dist = plexi_node_distance(embeddingSpaceList)
Result = plexi_distance_test_isn(Dist, y = c(1,2))

</code></pre>

<hr>
<h2 id='plexi_distance_test1_isn'>Test the extremeness of embedding distances of local neighbors.</h2><span id='topic+plexi_distance_test1_isn'></span>

<h3>Description</h3>

<p>Test the extremeness of embedding distances of local neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plexi_distance_test1_isn(distance, p.adjust.method = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plexi_distance_test1_isn_+3A_distance">distance</code></td>
<td>
<p>a distance list obtained by the <code>plexi_node_distance()</code> function.</p>
</td></tr>
<tr><td><code id="plexi_distance_test1_isn_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p-value (including methods on <code>p.adjust.methods</code>).
If set to &quot;none&quot; (default), no adjustment will be performed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The adjusted p-values for each node is calculated based on their distance.
</p>


<h3>Value</h3>

<p>The adjusted pvalues for each node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ISN1 = network_gen(n.nodes = 50, n.var.nodes = 5, n.var.nei = 40, noise.sd = .01)
ISN2 = network_gen(n.nodes = 50, n.var.nodes = 5, n.var.nei = 40, noise.sd = .01)
graph_data = cbind(ISN1[["data_graph"]], ISN1[["data_graph"]][,3:4])
embeddingSpaceList = plexi_embedding(graph.data=graph_data, outcome=c(1,2,1,2),
indv.index=c(1,1,2,2), train.rep=2, random.walk=FALSE)
Dist = plexi_node_distance(embeddingSpaceList)
Result = plexi_distance_test1_isn(Dist)

</code></pre>

<hr>
<h2 id='plexi_embedding'>Calculate the embedding space for a multiplex network</h2><span id='topic+plexi_embedding'></span>

<h3>Description</h3>

<p>Calculate the embedding space for a multiplex network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plexi_embedding(
  graph.data,
  outcome,
  indv.index = NULL,
  edge.threshold = 0,
  train.rep = 50,
  embedding.size = 2,
  epochs = 10,
  batch.size = 5,
  l2reg = 0,
  walk.rep = 100,
  n.steps = 5,
  random.walk = TRUE,
  demo = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plexi_embedding_+3A_graph.data">graph.data</code></td>
<td>
<p>dataframe of the graph data containing edge list and edge weights.
column 1 and 2 consisting of the edge list (undirected).
column 3 and 4 consisting the edge weights corresponding to each graph, respectively.</p>
</td></tr>
<tr><td><code id="plexi_embedding_+3A_outcome">outcome</code></td>
<td>
<p>a vector of outcomes for each network.</p>
</td></tr>
<tr><td><code id="plexi_embedding_+3A_indv.index">indv.index</code></td>
<td>
<p>the index of individual networks.</p>
</td></tr>
<tr><td><code id="plexi_embedding_+3A_edge.threshold">edge.threshold</code></td>
<td>
<p>numeric value to set edge weights below the threshold to zero (default: 0). the greater edge weights do not change.</p>
</td></tr>
<tr><td><code id="plexi_embedding_+3A_train.rep">train.rep</code></td>
<td>
<p>numeric value to set the number of EDNN training repeats (default: 50).</p>
</td></tr>
<tr><td><code id="plexi_embedding_+3A_embedding.size">embedding.size</code></td>
<td>
<p>the dimension of embedding space, equal to the number of the bottleneck hidden nodes (default: 5).</p>
</td></tr>
<tr><td><code id="plexi_embedding_+3A_epochs">epochs</code></td>
<td>
<p>maximum number of pocks. An early stopping callback with a patience of 5 has been set inside the function (default = 10).</p>
</td></tr>
<tr><td><code id="plexi_embedding_+3A_batch.size">batch.size</code></td>
<td>
<p>batch size for learning (default = 5).</p>
</td></tr>
<tr><td><code id="plexi_embedding_+3A_l2reg">l2reg</code></td>
<td>
<p>the coefficient of L2 regularization for the input layer (default = 0).</p>
</td></tr>
<tr><td><code id="plexi_embedding_+3A_walk.rep">walk.rep</code></td>
<td>
<p>number of repeats for the random walk (default: 100).</p>
</td></tr>
<tr><td><code id="plexi_embedding_+3A_n.steps">n.steps</code></td>
<td>
<p>number of the random walk steps (default: 5).</p>
</td></tr>
<tr><td><code id="plexi_embedding_+3A_random.walk">random.walk</code></td>
<td>
<p>boolean value to enable the random walk algorithm (default: TRUE).</p>
</td></tr>
<tr><td><code id="plexi_embedding_+3A_demo">demo</code></td>
<td>
<p>a boolean vector to indicate this is a demo example or not</p>
</td></tr>
<tr><td><code id="plexi_embedding_+3A_verbose">verbose</code></td>
<td>
<p>if <em>TRUE</em> a progress bar is shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of embedding spaces for each node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myNet = network_gen(n.nodes = 50, n.var.nodes = 5, n.var.nei = 40, noise.sd = .01)
graph_data = myNet[["data_graph"]]
embeddingSpaceList = plexi_embedding(graph.data=graph_data, outcome=c(1,2),
train.rep=2, random.walk=FALSE)

</code></pre>

<hr>
<h2 id='plexi_embedding_2layer'>Calculate the embedding space for a two layer multiplex network</h2><span id='topic+plexi_embedding_2layer'></span>

<h3>Description</h3>

<p>Calculate the embedding space for a two layer multiplex network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plexi_embedding_2layer(
  graph.data,
  edge.threshold = 0,
  train.rep = 50,
  embedding.size = 2,
  epochs = 10,
  batch.size = 5,
  l2reg = 0,
  walk.rep = 100,
  n.steps = 5,
  random.walk = TRUE,
  null.perm = TRUE,
  demo = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plexi_embedding_2layer_+3A_graph.data">graph.data</code></td>
<td>
<p>dataframe of the graph data containing edge list and edge weights.
column 1 and 2 consisting of the edge list (undirected).
column 3 and 4 consisting the edge weights corresponding to each graph, respectively.</p>
</td></tr>
<tr><td><code id="plexi_embedding_2layer_+3A_edge.threshold">edge.threshold</code></td>
<td>
<p>numeric value to set edge weights below the threshold to zero (default: 0). the greater edge weights do not change.</p>
</td></tr>
<tr><td><code id="plexi_embedding_2layer_+3A_train.rep">train.rep</code></td>
<td>
<p>numeric value to set the number of EDNN training repeats (default: 50).</p>
</td></tr>
<tr><td><code id="plexi_embedding_2layer_+3A_embedding.size">embedding.size</code></td>
<td>
<p>the dimension of embedding space, equal to the number of the bottleneck hidden nodes (default: 5).</p>
</td></tr>
<tr><td><code id="plexi_embedding_2layer_+3A_epochs">epochs</code></td>
<td>
<p>maximum number of pocks. An early stopping callback with a patience of 5 has been set inside the function (default = 10).</p>
</td></tr>
<tr><td><code id="plexi_embedding_2layer_+3A_batch.size">batch.size</code></td>
<td>
<p>batch size for learning (default = 5).</p>
</td></tr>
<tr><td><code id="plexi_embedding_2layer_+3A_l2reg">l2reg</code></td>
<td>
<p>the coefficient of L2 regularization for the input layer (default = 0).</p>
</td></tr>
<tr><td><code id="plexi_embedding_2layer_+3A_walk.rep">walk.rep</code></td>
<td>
<p>number of repeats for the random walk (default: 100).</p>
</td></tr>
<tr><td><code id="plexi_embedding_2layer_+3A_n.steps">n.steps</code></td>
<td>
<p>number of the random walk steps (default: 5).</p>
</td></tr>
<tr><td><code id="plexi_embedding_2layer_+3A_random.walk">random.walk</code></td>
<td>
<p>boolean value to enable the random walk algorithm (default: TRUE).</p>
</td></tr>
<tr><td><code id="plexi_embedding_2layer_+3A_null.perm">null.perm</code></td>
<td>
<p>boolean to enable permuting two random graphs and embed them, along with the main two graphs, for the null distribution (default: TRUE).</p>
</td></tr>
<tr><td><code id="plexi_embedding_2layer_+3A_demo">demo</code></td>
<td>
<p>a boolean vector to indicate this is a demo example or not</p>
</td></tr>
<tr><td><code id="plexi_embedding_2layer_+3A_verbose">verbose</code></td>
<td>
<p>if <em>TRUE</em> a progress bar is shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of embedding spaces for each node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myNet = network_gen(n.nodes = 50, n.var.nodes = 5, n.var.nei = 40, noise.sd = .01)
graph_data = myNet[["data_graph"]]
embeddingSpaceList = plexi_embedding_2layer(graph.data=graph_data, train.rep=5, walk.rep=5)

</code></pre>

<hr>
<h2 id='plexi_node_detection_2layer'>Detecting the nodes whose local neighbors change bweteen the two conditions.</h2><span id='topic+plexi_node_detection_2layer'></span>

<h3>Description</h3>

<p>Detecting the nodes whose local neighbors change bweteen the two conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plexi_node_detection_2layer(
  embeddingSpaceList,
  p.adjust.method = "none",
  alpha = 0.05,
  rank.prc = 0.1,
  volcano.plot = TRUE,
  ranksum.sort.plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plexi_node_detection_2layer_+3A_embeddingspacelist">embeddingSpaceList</code></td>
<td>
<p>a list obtained by the <code>plexi_embedding_2layer()</code> function.</p>
</td></tr>
<tr><td><code id="plexi_node_detection_2layer_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for adjusting p-value (including methods on <code>p.adjust.methods</code>).
If set to &quot;none&quot; (default), no adjustment will be performed.</p>
</td></tr>
<tr><td><code id="plexi_node_detection_2layer_+3A_alpha">alpha</code></td>
<td>
<p>numeric value of significance level (default: 0.05)</p>
</td></tr>
<tr><td><code id="plexi_node_detection_2layer_+3A_rank.prc">rank.prc</code></td>
<td>
<p>numeric value of the rank percentage threshold (default: 0.1)</p>
</td></tr>
<tr><td><code id="plexi_node_detection_2layer_+3A_volcano.plot">volcano.plot</code></td>
<td>
<p>boolean value for generating the Volcano plot (default: TRUE)</p>
</td></tr>
<tr><td><code id="plexi_node_detection_2layer_+3A_ranksum.sort.plot">ranksum.sort.plot</code></td>
<td>
<p>boolean value for generating the sorted rank sum plot (default: FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculating the distance of node pairs in the embedding space and check their significance.
To find the significantly varying nodes in the 2-layer-network, the distance between
the corresponding nodes are calculated along with the null distribution.
The null distribution is obtained based on the pairwise distances on null graphs.
if in <code>plexi_embedding_2layer</code> function <code>null.perm=FALSE</code>, the multiplex network
does not have the two randomly permuted graphs, thus the distances between all the nodes will
be used for the null distribution.
</p>


<h3>Value</h3>

<p>the highly variable nodes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myNet = network_gen(n.nodes = 50, n.var.nodes = 5, n.var.nei = 40, noise.sd = .01)
graph_data = myNet[["data_graph"]]
embeddingSpaceList = plexi_embedding_2layer(graph.data=graph_data, train.rep=5, walk.rep=5)
Nodes = plexi_node_detection_2layer(embeddingSpaceList)

</code></pre>

<hr>
<h2 id='plexi_node_distance'>Detecting the nodes whose local neighbors change between the two conditions for ISNs.</h2><span id='topic+plexi_node_distance'></span>

<h3>Description</h3>

<p>Detecting the nodes whose local neighbors change between the two conditions for ISNs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plexi_node_distance(embedding.space.list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plexi_node_distance_+3A_embedding.space.list">embedding.space.list</code></td>
<td>
<p>a list obtained by the <code>plexi_embedding_2layer()</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculating the distance of node pairs in the embedding space and check their significance.
To find the significantly varying nodes in the 2-layer-network, the distance between
the corresponding nodes are calculated along with the null distribution.
The null distribution is obtained based on the pairwise distances on null graphs.
if in <code>plexi_embedding_2layer</code> function <code>null.perm=FALSE</code>, the multiplex network
does not have the two randomly permuted graphs, thus the distances between all the nodes will
be used for the null distribution.
</p>


<h3>Value</h3>

<p>the distances for each repeat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myNet = network_gen(n.nodes = 50, n.var.nodes = 5, n.var.nei = 40, noise.sd = .01)
graph_data = myNet[["data_graph"]]
embeddingSpaceList = plexi_embedding(graph.data=graph_data, outcome=c(1,2),
indv.index=c(1,1), train.rep=2, random.walk=FALSE)
Dist = plexi_node_distance(embeddingSpaceList)

</code></pre>

<hr>
<h2 id='Rank'>Ranking a vector</h2><span id='topic+Rank'></span>

<h3>Description</h3>

<p>Ranking a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rank(x, decreasing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rank_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="Rank_+3A_decreasing">decreasing</code></td>
<td>
<p>logical. Should the sort order be increasing or decreasing? (defualt: FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>hint: What is the difference between Order and Rank<br />
Order: [the index of the greatest number, ..., the index of the smallest number]<br />
Rank: [the rank of the 1st number, ..., the rank of the last number]<br />
In Rank, the order of the numbers remains constant so can be used for ranksum.<br />
ex) <br />
&gt; a = c(10, 20, 50, 30, 40)<br />
&gt; order(a)<br />
[1] 1 2 4 5 3]]<br />
&gt; Rank(a)<br />
[1] 1 2 5 3 4
</p>


<h3>Value</h3>

<p>the rank of the vector elements
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = c(10, 20, 50, 30, 40)
Rank(a)

</code></pre>

<hr>
<h2 id='rep_random_walk'>Repetitive Fixed-length (weighted) random walk algorithm</h2><span id='topic+rep_random_walk'></span>

<h3>Description</h3>

<p>Repetitive Fixed-length (weighted) random walk algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rep_random_walk(
  graph,
  Nrep = 100,
  Nstep = 5,
  weighted_walk = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rep_random_walk_+3A_graph">graph</code></td>
<td>
<p>an igraph object</p>
</td></tr>
<tr><td><code id="rep_random_walk_+3A_nrep">Nrep</code></td>
<td>
<p>number of repeats (default:100)</p>
</td></tr>
<tr><td><code id="rep_random_walk_+3A_nstep">Nstep</code></td>
<td>
<p>maximum number steps (default:5)</p>
</td></tr>
<tr><td><code id="rep_random_walk_+3A_weighted_walk">weighted_walk</code></td>
<td>
<p>choose the <em>weighted walk</em> algorithm if <em>TRUE</em> and <em>simple random</em> walk if <em>FALSE</em>. (default: <em>TRUE</em>)</p>
</td></tr>
<tr><td><code id="rep_random_walk_+3A_verbose">verbose</code></td>
<td>
<p>if <em>TRUE</em> a progress bar is shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Steps (S): The total number of times a node is visited starting from the corresponding node in the row.
Probabilities (P): The node visit probabilities starting from the corresponding node in the row.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = example_data()
RW = rep_random_walk(graph = data[["igraph_example"]])
Steps = RW[["Steps"]]
Probabilities = RW[["Probabilities"]]

</code></pre>

<hr>
<h2 id='subgraph_difference_plot'>Visualization of a difference subgroup using a circular graph</h2><span id='topic+subgraph_difference_plot'></span>

<h3>Description</h3>

<p>Visualization of a difference subgroup using a circular graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subgraph_difference_plot(
  plexi.graph,
  node.importance,
  n.var.nodes = 5,
  n.neigh = 10,
  diff.threshold = 0,
  edge.width = c(0.5, 4)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subgraph_difference_plot_+3A_plexi.graph">plexi.graph</code></td>
<td>
<p>plexi.graph data</p>
</td></tr>
<tr><td><code id="subgraph_difference_plot_+3A_node.importance">node.importance</code></td>
<td>
<p>named numeric vector of the node importance to sort the nodes clockwise.</p>
</td></tr>
<tr><td><code id="subgraph_difference_plot_+3A_n.var.nodes">n.var.nodes</code></td>
<td>
<p>number of variable nodes to show</p>
</td></tr>
<tr><td><code id="subgraph_difference_plot_+3A_n.neigh">n.neigh</code></td>
<td>
<p>number of neighboring  nodes to show</p>
</td></tr>
<tr><td><code id="subgraph_difference_plot_+3A_diff.threshold">diff.threshold</code></td>
<td>
<p>edge threshold</p>
</td></tr>
<tr><td><code id="subgraph_difference_plot_+3A_edge.width">edge.width</code></td>
<td>
<p>numeric value to adjust the thickness of the edges in plot.
Two modes are defined: [i] two numbers indicating the min and max (default: c(0.5,4));
or [ii] a single number that weights the min/max of original edge weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing to return
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myNet = network_gen(n.nodes = 100, n.var.nodes = 5, n.var.nei = 90, noise.sd = .01)
graph_data = myNet[["data_graph"]]
node_importance_dummy = 1:100
names(node_importance_dummy) = 1:100
subgraph_difference_plot(graph_data, node.importance = node_importance_dummy)

</code></pre>

<hr>
<h2 id='subgraph_plot'>Visualization of a subgroup using a circular graph</h2><span id='topic+subgraph_plot'></span>

<h3>Description</h3>

<p>Visualization of a subgroup using a circular graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subgraph_plot(
  graph,
  node_set,
  labels = NULL,
  node.importance = NULL,
  n.nodes = NULL,
  node_size = 5,
  font_size = 4,
  edge_width = c(0.5, 4),
  margin = 2.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subgraph_plot_+3A_graph">graph</code></td>
<td>
<p>an igraph object</p>
</td></tr>
<tr><td><code id="subgraph_plot_+3A_node_set">node_set</code></td>
<td>
<p>the names or indices of the nodes around which the subgroup is plotted.</p>
</td></tr>
<tr><td><code id="subgraph_plot_+3A_labels">labels</code></td>
<td>
<p>the labels of the nodes to be indicated. Labels should be a named vector if the <code>node_set</code> consists of the node names.</p>
</td></tr>
<tr><td><code id="subgraph_plot_+3A_node.importance">node.importance</code></td>
<td>
<p>named numeric vector of the node importance to sort the nodes clockwise.</p>
</td></tr>
<tr><td><code id="subgraph_plot_+3A_n.nodes">n.nodes</code></td>
<td>
<p>number of nodes to be displayed. If NULL, all the <code>node_set</code> and their neighbors are considered.</p>
</td></tr>
<tr><td><code id="subgraph_plot_+3A_node_size">node_size</code></td>
<td>
<p>size of the nodes in plot (default: 5)</p>
</td></tr>
<tr><td><code id="subgraph_plot_+3A_font_size">font_size</code></td>
<td>
<p>font size of labels if available (default: 4)</p>
</td></tr>
<tr><td><code id="subgraph_plot_+3A_edge_width">edge_width</code></td>
<td>
<p>numeric value to adjust the thickness of the edges in plot.
Two modes are defined: [i] two numbers indicating the min and max (default: c(0.5,4));
or [ii] a single number that weights the min/max of original edge weights.</p>
</td></tr>
<tr><td><code id="subgraph_plot_+3A_margin">margin</code></td>
<td>
<p>the figure margin (default: 2.5)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots a sub-graph given by a set of nodes as circular plot.
the main inputs to the function are: a graph (as an igraph object) and a set of nodes
(e.g. highly variable nodes) around which the subgroup is calculated.
</p>


<h3>Value</h3>

<p>nothing to return
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = example_data()
subgraph_plot(graph = data[["igraph_example"]], node_set = "a")

</code></pre>

<hr>
<h2 id='weightd_random_walk'>Weighted Random Walk algorithm</h2><span id='topic+weightd_random_walk'></span>

<h3>Description</h3>

<p>Weighted Random Walk algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightd_random_walk(graph, startNode, maxStep = 5, node_names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weightd_random_walk_+3A_graph">graph</code></td>
<td>
<p>an igraph object</p>
</td></tr>
<tr><td><code id="weightd_random_walk_+3A_startnode">startNode</code></td>
<td>
<p>the starting node (i.e. a node name or a node index)</p>
</td></tr>
<tr><td><code id="weightd_random_walk_+3A_maxstep">maxStep</code></td>
<td>
<p>maximum number steps (default:5)</p>
</td></tr>
<tr><td><code id="weightd_random_walk_+3A_node_names">node_names</code></td>
<td>
<p>a list of names for nodes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The set of nodes passed by the random walker.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = example_data()
nodePath = weightd_random_walk(graph = data[["igraph_example"]], startNode = 1)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
