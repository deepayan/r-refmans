<!DOCTYPE html><html><head><title>Help for package MOEADr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MOEADr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#box_constraints'><p>Box constraints routine</p></a></li>
<li><a href='#calcIGD'><p>Inverted Generational Distance</p></a></li>
<li><a href='#check_stop_criteria'><p>Stop criteria for MOEA/D</p></a></li>
<li><a href='#constraint_none'><p>NULL constraint handling method for MOEA/D</p></a></li>
<li><a href='#constraint_penalty'><p>&quot;Penalty&quot; constraint handling method for MOEA/D</p></a></li>
<li><a href='#constraint_vbr'><p>&quot;Violation-based Ranking&quot; constraint handling method for MOEA/D</p></a></li>
<li><a href='#create_population'><p>Create population</p></a></li>
<li><a href='#decomposition_msld'><p>Problem Decomposition using Multi-layered Simplex-lattice Design</p></a></li>
<li><a href='#decomposition_sld'><p>Problem Decomposition using Simplex-lattice Design</p></a></li>
<li><a href='#decomposition_uniform'><p>Problem Decomposition using Uniform Design</p></a></li>
<li><a href='#define_neighborhood'><p>Calculate neighborhood relations</p></a></li>
<li><a href='#evaluate_population'><p>Evaluate population</p></a></li>
<li><a href='#example_problem'><p>Example problem</p></a></li>
<li><a href='#find_nondominated_points'><p>Find non-dominated points</p></a></li>
<li><a href='#generate_weights'><p>Calculate weight vectors</p></a></li>
<li><a href='#get_constraint_methods'><p>Print available constraint methods</p></a></li>
<li><a href='#get_decomposition_methods'><p>Print available decomposition methods</p></a></li>
<li><a href='#get_localsearch_methods'><p>Print available local search methods</p></a></li>
<li><a href='#get_scalarization_methods'><p>Print available scalarization methods</p></a></li>
<li><a href='#get_stop_criteria'><p>Print available stop criteria</p></a></li>
<li><a href='#get_update_methods'><p>Print available update methods</p></a></li>
<li><a href='#get_variation_operators'><p>Print available variation operators</p></a></li>
<li><a href='#ls_dvls'><p>Differential vector-based local search</p></a></li>
<li><a href='#ls_tpqa'><p>Three-point quadratic approximation local search</p></a></li>
<li><a href='#make_vectorized_smoof'><p>Make vectorized smoof function</p></a></li>
<li><a href='#moead'><p>MOEA/D</p></a></li>
<li><a href='#order_neighborhood'><p>Order Neighborhood for MOEA/D</p></a></li>
<li><a href='#perform_variation'><p>Run variation operators</p></a></li>
<li><a href='#plot.moead'><p>plot.moead</p></a></li>
<li><a href='#preset_moead'><p>preset_moead</p></a></li>
<li><a href='#print_progress'><p>Print progress of MOEA/D</p></a></li>
<li><a href='#print.moead'><p>print.moead</p></a></li>
<li><a href='#scalarization_awt'><p>Adjusted Weighted Tchebycheff Scalarization</p></a></li>
<li><a href='#scalarization_ipbi'><p>Inverted Penalty-based Boundary Intersection Scalarization</p></a></li>
<li><a href='#scalarization_pbi'><p>Penalty-based Boundary Intersection Scalarization</p></a></li>
<li><a href='#scalarization_ws'><p>Weighted Sum Scalarization</p></a></li>
<li><a href='#scalarization_wt'><p>Weighted Tchebycheff Scalarization</p></a></li>
<li><a href='#scalarize_values'><p>Scalarize values for MOEA/D</p></a></li>
<li><a href='#scale_objectives'><p>Scaling of the objective function values</p></a></li>
<li><a href='#stop_maxeval'><p>Stop criterion: maximum number of evaluations</p></a></li>
<li><a href='#stop_maxiter'><p>Stop criterion: maximum number of iterations</p></a></li>
<li><a href='#stop_maxtime'><p>Stop criterion: maximum runtime</p></a></li>
<li><a href='#summary.moead'><p>summary.moead</p></a></li>
<li><a href='#unitary_constraints'><p>Unitary constraints routine</p></a></li>
<li><a href='#update_population'><p>Update population</p></a></li>
<li><a href='#updt_best'><p>Best Neighborhood Replacement Update for MOEA/D</p></a></li>
<li><a href='#updt_restricted'><p>Restricted Neighborhood Replacement Update for MOEA/D</p></a></li>
<li><a href='#updt_standard'><p>Standard Neighborhood Replacement Update for MOEA/D</p></a></li>
<li><a href='#variation_binrec'><p>Binomial Recombination</p></a></li>
<li><a href='#variation_diffmut'><p>Differential Mutation</p></a></li>
<li><a href='#variation_localsearch'><p>Local search Operators</p></a></li>
<li><a href='#variation_none'><p>Identity operator</p></a></li>
<li><a href='#variation_polymut'><p>Polynomial mutation</p></a></li>
<li><a href='#variation_sbx'><p>Simulated binary crossover</p></a></li>
<li><a href='#variation_truncate'><p>Truncate</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Component-Wise MOEA/D Implementation</td>
</tr>
<tr>
<td>Description:</td>
<td>Modular implementation of Multiobjective Evolutionary Algorithms 
              based on Decomposition (MOEA/D) [Zhang and Li (2007), 
              &lt;<a href="https://doi.org/10.1109%2FTEVC.2007.892759">doi:10.1109/TEVC.2007.892759</a>&gt;] for quick assembling and 
              testing of new algorithmic components, as well as easy 
              replication of published MOEA/D proposals. The full framework is
              documented in a paper published in the Journal of Statistical 
              Software [&lt;<a href="https://doi.org/10.18637%2Fjss.v092.i06">doi:10.18637/jss.v092.i06</a>&gt;].</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-06</td>
</tr>
<tr>
<td>Imports:</td>
<td>FNN, assertthat</td>
</tr>
<tr>
<td>Suggests:</td>
<td>smoof, scatterplot3d, MASS, grDevices, irace, testthat,
knitr, rmarkdown, emoa, ggplot2, reshape2, pkgdown</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Author:</td>
<td>Felipe Campelo [aut, cre],
  Lucas Batista [com],
  Claus Aranha [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Felipe Campelo &lt;fcampelo@ufmg.br&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://fcampelo.github.io/MOEADr/">https://fcampelo.github.io/MOEADr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/fcampelo/MOEADr/issues">https://github.com/fcampelo/MOEADr/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-06 12:41:15 UTC; campelof</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-08 14:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='box_constraints'>Box constraints routine</h2><span id='topic+box_constraints'></span>

<h3>Description</h3>

<p>Calculates the constraint values and violations when only box constraints are
present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>box_constraints(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="box_constraints_+3A_x">X</code></td>
<td>
<p>Population matrix of the MOEA/D (each row is a candidate solution).
If <code>NULL</code> the function searches for <code>X</code> in the calling environment.</p>
</td></tr>
<tr><td><code id="box_constraints_+3A_...">...</code></td>
<td>
<p>other parameters (unused, included for compatibility with
generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine calculates the constraint values and violations for a population
matrix in the MOEA/D. Each row of the matrix is considered as a candidate
solution. This routine expects the candidate solutions to be standardized,
i.e., that the variable limits given in <code>problem$xmin</code> and
<code>problem$xmax</code> are mapped to <code>0</code> and <code>1</code>, respectively.
</p>


<h3>Value</h3>

<p>List objective containing a matrix of constraint values <code>Cmatrix</code>, a
matrix of individual constraint violations <code>Vmatrix</code>, and a vector of total
constraint violations <code>v</code>.
</p>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>

<hr>
<h2 id='calcIGD'>Inverted Generational Distance</h2><span id='topic+calcIGD'></span>

<h3>Description</h3>

<p>Calculate IGD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcIGD(Y, Yref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcIGD_+3A_y">Y</code></td>
<td>
<p>Matrix of points in the objective space</p>
</td></tr>
<tr><td><code id="calcIGD_+3A_yref">Yref</code></td>
<td>
<p>Matrix of Pareto-optimal reference points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>igd value (scalar)
</p>

<hr>
<h2 id='check_stop_criteria'>Stop criteria for MOEA/D</h2><span id='topic+check_stop_criteria'></span>

<h3>Description</h3>

<p>Verifies stop criteria for the MOEADr package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_stop_criteria(stopcrit, call.env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_stop_criteria_+3A_stopcrit">stopcrit</code></td>
<td>
<p>list containing the parameters defining the stop
handling method. See Section <code style="white-space: pre;">&#8288;Stop Criteria&#8288;</code> of the <code><a href="#topic+moead">moead()</a></code>
documentation for details.</p>
</td></tr>
<tr><td><code id="check_stop_criteria_+3A_call.env">call.env</code></td>
<td>
<p>List vector containing the stop criteria to be used.
See <code><a href="#topic+moead">moead()</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine is intended to be used internally by <code><a href="#topic+moead">moead()</a></code>,
and should not be called directly by the user.
</p>


<h3>Value</h3>

<p>Flag <code>keep.running</code>, indicating whether the algorithm should continue
(<code>TRUE</code>) or terminate (<code>FALSE</code>).
</p>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>

<hr>
<h2 id='constraint_none'>NULL constraint handling method for MOEA/D</h2><span id='topic+constraint_none'></span>

<h3>Description</h3>

<p>Construct the preference index matrix based only on performance values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constraint_none(B, bigZ, bigV, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constraint_none_+3A_b">B</code></td>
<td>
<p>Matrix of neighborhoods (generated by <code>define_neighborhood(...))</code>)</p>
</td></tr>
<tr><td><code id="constraint_none_+3A_bigz">bigZ</code></td>
<td>
<p>Matrix of scalarized objective values for each neighborhood and the
incumbent solution (generated by <code>scalarize_values</code>)</p>
</td></tr>
<tr><td><code id="constraint_none_+3A_bigv">bigV</code></td>
<td>
<p>Matrix of violation values for each neighborhood and the
incumbent solution</p>
</td></tr>
<tr><td><code id="constraint_none_+3A_...">...</code></td>
<td>
<p>other parameters (unused, included for compatibility with
generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function ignores the violation values when constructing the preference
index matrix, using only the scalarized performance values.
</p>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;[ N x (T+1) ]&#8288;</code> matrix of preference indices. Each row <code>i</code> contains
a permutation of <code style="white-space: pre;">&#8288;{1, 2, ..., (T+1)}&#8288;</code>, where <code style="white-space: pre;">&#8288;1,...,T&#8288;</code> correspond
to the solutions contained in the neighborhood of the i-th subproblem,
<code>B[i, ]</code>, and <code>T+1</code> corresponds to the incumbent solution for that
subproblem. The order of the permutation is defined by the increasing values
of <code>f(xk)</code>, where <code>f(xk)</code> is the aggregation function value of
the k-th solution being compared.
</p>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>

<hr>
<h2 id='constraint_penalty'>&quot;Penalty&quot; constraint handling method for MOEA/D</h2><span id='topic+constraint_penalty'></span>

<h3>Description</h3>

<p>Uses the Penalty Function constraint handling method to generate a
preference index for the MOEADr framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constraint_penalty(B, bigZ, bigV, beta, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constraint_penalty_+3A_b">B</code></td>
<td>
<p>Matrix of neighborhoods (generated by <code><a href="#topic+define_neighborhood">define_neighborhood()</a></code><code style="white-space: pre;">&#8288;$B&#8288;</code>)</p>
</td></tr>
<tr><td><code id="constraint_penalty_+3A_bigz">bigZ</code></td>
<td>
<p>Matrix of scalarized objective values for each neighborhood and
the incumbent solution (generated by <code><a href="#topic+scalarize_values">scalarize_values()</a></code>)</p>
</td></tr>
<tr><td><code id="constraint_penalty_+3A_bigv">bigV</code></td>
<td>
<p>Matrix of violation values for each neighborhood and the
incumbent solution (generated in <code><a href="#topic+order_neighborhood">order_neighborhood()</a></code>)</p>
</td></tr>
<tr><td><code id="constraint_penalty_+3A_beta">beta</code></td>
<td>
<p>Penalization constant (non-negative value)</p>
</td></tr>
<tr><td><code id="constraint_penalty_+3A_...">...</code></td>
<td>
<p>other parameters (unused, included for compatibility with
generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the preference index of a set of neighborhoods
based on the &quot;penalty&quot; constraint handling method. Please
see <code><a href="#topic+order_neighborhood">order_neighborhood()</a></code> for more information on the preference index
matrix.
</p>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;[ N x (T+1) ]&#8288;</code> matrix of preference indices. Each row <code>i</code> contains
a permutation of <code style="white-space: pre;">&#8288;{1, 2, ..., (T+1)}&#8288;</code>, where <code style="white-space: pre;">&#8288;1,...,T&#8288;</code> correspond
to the solutions contained in the neighborhood of the i-th subproblem,
<code>B[i, ]</code>, and <code>T+1</code> corresponds to the incumbent solution for that
subproblem. The order of the permutation is defined by the increasing values
of <code>f(xk) + beta * v(xk)</code>, where <code>f(xk)</code> is the aggregation function value of
the k-th solution being compared, and v(xk) is its total constraint violation
(calculated in <code><a href="#topic+evaluate_population">evaluate_population()</a></code><code style="white-space: pre;">&#8288;$V$v&#8288;</code>).
</p>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>

<hr>
<h2 id='constraint_vbr'>&quot;Violation-based Ranking&quot; constraint handling method for MOEA/D</h2><span id='topic+constraint_vbr'></span>

<h3>Description</h3>

<p>Uses the Violation-based Ranking handling method to generate a
preference index for the MOEADr framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constraint_vbr(bigZ, bigV, type = c("ts", "sr", "vt"), pf = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constraint_vbr_+3A_bigz">bigZ</code></td>
<td>
<p>Matrix of scalarized objective values for each neighborhood and
the incumbent solution (generated by <code><a href="#topic+scalarize_values">scalarize_values()</a></code>)</p>
</td></tr>
<tr><td><code id="constraint_vbr_+3A_bigv">bigV</code></td>
<td>
<p>Matrix of violation values for each neighborhood and the
incumbent solution (generated in <code><a href="#topic+order_neighborhood">order_neighborhood()</a></code>)</p>
</td></tr>
<tr><td><code id="constraint_vbr_+3A_type">type</code></td>
<td>
<p>type of <code>c(x)</code> function to use (see <code style="white-space: pre;">&#8288;c(x) Criteria&#8288;</code> for details).</p>
</td></tr>
<tr><td><code id="constraint_vbr_+3A_pf">pf</code></td>
<td>
<p>probability parameter for type = &quot;sr&quot; (ignored in other modes).</p>
</td></tr>
<tr><td><code id="constraint_vbr_+3A_...">...</code></td>
<td>
<p>other parameters (unused, included for compatibility with
generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the preference index of a set of neighborhoods
based on the &quot;violation-based ranking&quot; (VBR) constraint handling method. Please
see <code><a href="#topic+order_neighborhood">order_neighborhood()</a></code> for more information on the preference index
matrix.
</p>
<p>The VBR strategy generalizes some well-known methods for handling constraints
in population-based metaheuristics (see Section <code style="white-space: pre;">&#8288;c(x) Criteria&#8288;</code>).
This strategy essentially ranks points within for a given subproblem based on
their aggregated function value (<code>f^{agg}(x|w_i)</code>) or their total constraint
violation (<code>v(x)</code>). Specific variations of this strategy differ on the
criteria for using one or the other.
</p>
<p>The value used for ranking a given point <code>x</code> can be summarized as:
</p>

<table>
<tr>
 <td style="text-align: left;">
Violation  </td><td style="text-align: left;"> | c(x) criterion </td><td style="text-align: left;"> | Rank using: </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>v(x) = 0</code> </td><td style="text-align: left;"> | <code style="white-space: pre;">&#8288;c(x) = *&#8288;</code>     </td><td style="text-align: left;"> | <code>f^{agg}(x|w_i)</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>v(x) &gt; 0</code> </td><td style="text-align: left;"> | <code>c(x) == TRUE</code> </td><td style="text-align: left;"> | <code>f^{agg}(x|w_i)</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>v(x) &gt; 0</code> </td><td style="text-align: left;"> | <code>c(x) == FALSE</code></td><td style="text-align: left;"> | <code>v(x)</code>      </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Points compared according to their <code>f^{agg}(x|w_i)</code> values (i.e., feasible
points and those for which <code>c(x) = TRUE</code>) are ranked first (i.e., receive
ranks between <code>1</code> and <code style="white-space: pre;">&#8288;n_{feas}&#8288;</code>, where <code style="white-space: pre;">&#8288;n_{feas}&#8288;</code> is the
number of feasible points in the i-th neighborhood), with points that are
compared according to their <code>v(x)</code> values receiving ranks between
<code style="white-space: pre;">&#8288;(n_{feas} + 1)&#8288;</code> and <code>T + 1</code> (<code>T</code> being the size of the neighborhood. The <code>+1</code>
comes from including the incumbent solution in the comparison).
</p>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;[ N x (T+1) ]&#8288;</code> matrix of preference indices. Each row <code>i</code> contains
a permutation of <code style="white-space: pre;">&#8288;{1, 2, ..., (T+1)}&#8288;</code>, where <code style="white-space: pre;">&#8288;1,...,T&#8288;</code> correspond
to the solutions contained in the neighborhood of the i-th subproblem,
<code>B[i, ]</code>, and <code>T+1</code> corresponds to the incumbent solution for that
subproblem. The order of the permutation is defined by the specific strategy
defined by the input variable <code>type</code>).
</p>


<h3>c(x) Criteria</h3>

<p>Specific variations of the VBR differ on how the criterion c(x) is
implemented. Three variants are currently implemented in the MOEADr package:
</p>

<table>
<tr>
 <td style="text-align: left;">
Method                                 </td><td style="text-align: left;"> | ID            </td><td style="text-align: left;"> | <code>c(x)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
Tournament Selection <code style="white-space: pre;">&#8288;[Deb2000]&#8288;</code>       </td><td style="text-align: left;"> | <code style="white-space: pre;">&#8288;$type = "ts"&#8288;</code></td><td style="text-align: left;"> | <code>FALSE</code></td>
</tr>
<tr>
 <td style="text-align: left;">
Stochastic Ranking <code style="white-space: pre;">&#8288;[Runarsson2000]&#8288;</code>   </td><td style="text-align: left;"> | <code style="white-space: pre;">&#8288;$type = "sr"&#8288;</code></td><td style="text-align: left;"> | <code>runif() &lt; pf</code></td>
</tr>
<tr>
 <td style="text-align: left;">
Violation Threshold <code style="white-space: pre;">&#8288;[Asafuddoula2014]&#8288;</code></td><td style="text-align: left;"> | <code style="white-space: pre;">&#8288;$type = "vt"&#8288;</code></td><td style="text-align: left;"> | <code>v(x) &lt; eps_v^i</code></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>where <code class="reqn">pf \in [0,1]</code> is a user-defined parameter for the &quot;sr&quot; method, and
<code>eps_v^i</code> is subproblem-dependent, adaptive quantity calculated internally
in the routine (see <code style="white-space: pre;">&#8288;[Asafuddoula2014]&#8288;</code> and <code style="white-space: pre;">&#8288;[Campelo2017]&#8288;</code> for details).
</p>


<h3>Using an External Archive</h3>

<p>For types &quot;sr&quot; and &quot;vt&quot;, it is possible for the algorithm to lose feasible
solutions during its update step, since there is a non-zero probability of
unfeasible solutions replacing feasible ones. In these cases, it is
recommended to set the <code><a href="#topic+moead">moead()</a></code> parameter <code>update$UseArchive = TRUE</code>, so
that an external archive is built with the best feasible solutions found for
each subproblem.
</p>


<h3>References</h3>

<p><code style="white-space: pre;">&#8288;[Deb2000]&#8288;</code> K. Deb,
&quot;An efficient constraint handling method for genetic algorithm&quot;,
Computer Methods in Applied Mechanics and Engineering 186(2–4):311–338, 2000.
</p>
<p><code style="white-space: pre;">&#8288;[Runarsson2000]&#8288;</code> T. Runarsson, X. Yao,
&quot;Stochastic ranking for constrained evolutionary optimization&quot;,
IEEE Transactions on Evolutionary Computation4(3):284–294, 2000.<br />
</p>
<p><code style="white-space: pre;">&#8288;[Asafuddoula2014]&#8288;</code> M. Asafuddoula, T. Ray, R. Sarker, K. Alam,
&quot;An adaptive constraint handling approach embedded MOEA/D,”
2012 IEEE Congress on Evolutionary Computation (CEC).<br />
</p>
<p><code style="white-space: pre;">&#8288;[Campelo2017]&#8288;</code>  F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr
Package: A Component-Based Framework for Multiobjective Evolutionary
Algorithms Based on Decomposition. Journal of Statistical Software
<a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>

<hr>
<h2 id='create_population'>Create population</h2><span id='topic+create_population'></span>

<h3>Description</h3>

<p>Create a population for the MOEADr package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_population(N, problem)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_population_+3A_n">N</code></td>
<td>
<p>population size</p>
</td></tr>
<tr><td><code id="create_population_+3A_problem">problem</code></td>
<td>
<p>list of named problem parameters. See Section
<code style="white-space: pre;">&#8288;Problem Description&#8288;</code> of the <code><a href="#topic+moead">moead()</a></code> documentation for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine creates a population matrix for the MOEA/D. Currently only a
multivariate uniform distribution is implemented. All points are created
within the standardized space <code class="reqn">0 \le x_i \le 1, i = 1,...,n_v</code>.
</p>


<h3>Value</h3>

<p>A population matrix X for the MOEA/D.
</p>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex.problem &lt;- list(name = "example_problem",
                   xmin = rep(-1, 5),
                   xmax = rep(1, 5),
                   m    = 2)
X &lt;- create_population(20, ex.problem)

</code></pre>

<hr>
<h2 id='decomposition_msld'>Problem Decomposition using Multi-layered Simplex-lattice Design</h2><span id='topic+decomposition_msld'></span>

<h3>Description</h3>

<p>Problem Decomposition using Multi-layered Simplex-lattice Design for MOEADr
package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decomposition_msld(decomp, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decomposition_msld_+3A_decomp">decomp</code></td>
<td>
<p>list containing the relevant decomposition parameters.
Besides <code>decomp$name = "msld"</code>, this method requires the definition of the
following key-value pairs in <code>decomp</code>:
</p>

<ul>
<li> <p><code>decomp$H</code>: array of positive integers representing the
<code>H</code> values to be used by the SLD decomposition
at each layer (see <code><a href="#topic+decomposition_sld">decomposition_sld()</a></code> for
details).
</p>
</li>
<li> <p><code>decomp$tau</code>: array of scale multipliers for each layer,
<code class="reqn">0 &lt; \tau_i \le 1</code>, <code class="reqn">\tau_i != \tau_j</code> for all <code class="reqn">i != j</code>.
Must have the same length as <code>decomp$H</code>.
</p>
</li>
<li> <p><code>decomp$.nobj</code>: integer value, <code>decomp$.nobj &gt; 1</code>. Number of
objectives of the problem.
</p>
</li></ul>
</td></tr>
<tr><td><code id="decomposition_msld_+3A_...">...</code></td>
<td>
<p>other parameters (included for compatibility with generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine calculates the weight vectors for the MOEA/D using the
Multi-layered Simplex-lattice Design.
</p>


<h3>References</h3>

<p>K. Li et al. (2014), &quot;An Evolutionary Many-Objective Optimization
Algorithm Based on Dominance and Decomposition&quot;,
IEEE Trans. Evol. Comp. 19(5):694-716, 2015. DOI: 10.1109/TEVC.2014.2373386
</p>
<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>decomp &lt;- list(name = "msld", H = c(5, 3), tau = c(.9, .5), .nobj = 4)
W &lt;- decomposition_msld(decomp)

</code></pre>

<hr>
<h2 id='decomposition_sld'>Problem Decomposition using Simplex-lattice Design</h2><span id='topic+decomposition_sld'></span>

<h3>Description</h3>

<p>Problem Decomposition using Simplex-lattice Design for MOEADr package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decomposition_sld(decomp, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decomposition_sld_+3A_decomp">decomp</code></td>
<td>
<p>list containing the relevant decomposition parameters.
Besides <code>decomp$name = "sld"</code>, this method requires the definition of the
following key-value pairs:
</p>

<ul>
<li> <p><code>decomp$H</code>, decomposition constant. Suggested values for <code>decomp$H</code>
are (use with caution):
</p>

<table>
<tr>
 <td style="text-align: center;">
<code>m</code></td><td style="text-align: center;"> |</td><td style="text-align: center;"><code>H</code></td><td style="text-align: center;"> |</td><td style="text-align: center;"><code>N</code></td>
</tr>
<tr>
 <td style="text-align: center;">
<code>2</code>    </td><td style="text-align: center;">  |</td><td style="text-align: center;"><code>99</code>      </td><td style="text-align: center;"> |</td><td style="text-align: center;"><code>100</code></td>
</tr>
<tr>
 <td style="text-align: center;">
<code>3</code>    </td><td style="text-align: center;">  |</td><td style="text-align: center;"><code>12</code>      </td><td style="text-align: center;"> |</td><td style="text-align: center;"><code>91</code></td>
</tr>
<tr>
 <td style="text-align: center;">
<code>5</code>    </td><td style="text-align: center;">  |</td><td style="text-align: center;"><code>6</code>       </td><td style="text-align: center;"> |</td><td style="text-align: center;"><code>210</code></td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>It is important to highlight that the number of vectors generated (<code>N</code>) must
be greater than the number of neighbors declared in <code>neighbors$T</code>
(see <code><a href="#topic+moead">moead()</a></code> for details).
</p>
</li>
<li> <p><code>decomp$.nobj</code>: integer value, <code>decomp$.nobj &gt; 1</code>. Number of
objectives of the problem.
</p>
</li></ul>
</td></tr>
<tr><td><code id="decomposition_sld_+3A_...">...</code></td>
<td>
<p>other parameters (included for compatibility with generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine calculates the weight vectors for the MOEA/D using the
Simplex-lattice Design.
</p>


<h3>References</h3>

<p>I. Das, J. Dennis (1998), &quot;Normal Boundary Intersection - A New Method
for Generating the Pareto Surface in Nonlinear Multicriteria Optimization
Problems&quot;, SIAM J. Optim., 8(3), 631-657. DOI: 10.1137/S1052623496307510
</p>
<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>decomp &lt;- list(name = "sld", H = 99, .nobj = 2)
W &lt;- decomposition_sld(decomp)

</code></pre>

<hr>
<h2 id='decomposition_uniform'>Problem Decomposition using Uniform Design</h2><span id='topic+decomposition_uniform'></span>

<h3>Description</h3>

<p>Problem Decomposition using Uniform Design for MOEADr package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decomposition_uniform(decomp, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decomposition_uniform_+3A_decomp">decomp</code></td>
<td>
<p>list containing the relevant decomposition parameters.
Besides <code>decomp$name = "uniform"</code>, this method requires the definition of the
following key-value pairs:
</p>

<ul>
<li> <p><code>decomp$N</code>, number of subproblems to generate. It is important to
highlight that the number of subproblems must be greater than the
number of neighbors declared in <code>neighbors$T</code> (see <code><a href="#topic+moead">moead()</a></code> for
details).
</p>
</li>
<li> <p><code>decomp$.nobj</code>: integer value, <code>decomp$.nobj &gt; 1</code>. Number of
objectives of the problem.
</p>
</li></ul>
</td></tr>
<tr><td><code id="decomposition_uniform_+3A_...">...</code></td>
<td>
<p>other parameters (included for compatibility with generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine calculates the weight vectors for the MOEA/D using the Uniform
Design:
</p>


<h3>References</h3>

<p>R. Wang, T. Zhang, B. Guo, &quot;An enhanced MOEA/D using uniform directions
and a pre-organization procedure&quot;. Proc. IEEE Congress on Evolutionary
Computation, Cancun, Mexico, 2013, pp. 2390–2397.
</p>
<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>decomp &lt;- list(name = "uniform", N = 50, .nobj = 3)
W &lt;- decomposition_uniform(decomp)
</code></pre>

<hr>
<h2 id='define_neighborhood'>Calculate neighborhood relations</h2><span id='topic+define_neighborhood'></span>

<h3>Description</h3>

<p>Calculates neighborhood relations for the MOEADr package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_neighborhood(neighbors, v.matrix, iter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_neighborhood_+3A_neighbors">neighbors</code></td>
<td>
<p>List containing the decomposition method parameters.
This list must contain the following key-value pairs:
</p>

<ul>
<li> <p><code>neighbors$name</code>, type of neighborhood to use. The following types
are currently available:
</p>

<ul>
<li> <p><code>neighbors$name = "lambda"</code>: defines the neighborhood using
the distance matrix for the weight vectors. The calculation is
performed only once for the entire run.
</p>
</li>
<li> <p><code>neighbors$name = "x"</code>: defines the neighborhood using
the distance matrix for the incumbent solution associated with
each subproblem. In this case the calculation is performed at
each iteration.
</p>
</li></ul>

</li>
<li> <p><code>neighbors$T</code>: Neighborhood size. The value of <code>neighbors$T</code>
must be smaller than the number of subproblems.
</p>
</li>
<li> <p><code>neighbors$delta.p</code>: Probability of sampling from the neighborhood
when performing variation. Must be a scalar value between 0 and 1.
</p>
</li></ul>
</td></tr>
<tr><td><code id="define_neighborhood_+3A_v.matrix">v.matrix</code></td>
<td>
<p>matrix of vectors to be used for defining the neighborhoods.</p>
</td></tr>
<tr><td><code id="define_neighborhood_+3A_iter">iter</code></td>
<td>
<p>iteration counter of the MOEA/D</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine calculates the neighborhood relations for the MOEA/D.
</p>
<p><strong>Warning</strong>: this routine may access (but not directly modify) variables
from the calling environment.
</p>


<h3>Value</h3>

<p>List containing the matrix of selection probabilities (<code>P</code>) and
the matrix of neighborhoods (<code>B</code>).
</p>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>

<hr>
<h2 id='evaluate_population'>Evaluate population</h2><span id='topic+evaluate_population'></span>

<h3>Description</h3>

<p>Evaluate a population matrix on the objective functions for the MOEADr
package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_population(X, problem, nfe)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_population_+3A_x">X</code></td>
<td>
<p>Population matrix of the MOEA/D (each row is a candidate solution).</p>
</td></tr>
<tr><td><code id="evaluate_population_+3A_problem">problem</code></td>
<td>
<p>list of named problem parameters. See Section
<code style="white-space: pre;">&#8288;Problem Description&#8288;</code> of the <code><a href="#topic+moead">moead()</a></code> documentation for details.</p>
</td></tr>
<tr><td><code id="evaluate_population_+3A_nfe">nfe</code></td>
<td>
<p>counter of function evaluations from the <code><a href="#topic+moead">moead()</a></code> routine.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine evaluates a population matrix for the MOEA/D. Each row of the
matrix is considered as a candidate solution. This routine expects the
candidate solutions to be standardized, i.e., that the variable limits given
in <code>problem$xmin</code> and <code>problem$xmax</code> are mapped to <code>0</code> and
<code>1</code>, respectively.
</p>


<h3>Value</h3>

<p>List object containing the matrix of objective function values,
a list object containing information about the constraint violations (a
matrix of constraint values <code>Cmatrix</code>, a matrix of constraint violations
<code>Vmatrix</code>, and a vector of total violations <code>v</code>), and the updated counter
<code>nfe</code>.
</p>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex.problem &lt;- list(name = "example_problem",
                   xmin = rep(-1, 5),
                   xmax = rep(1, 5),
                   m    = 2)
X &lt;- create_population(20, ex.problem)
Y &lt;- evaluate_population(X, ex.problem, nfe = 0)

</code></pre>

<hr>
<h2 id='example_problem'>Example problem</h2><span id='topic+example_problem'></span>

<h3>Description</h3>

<p>Example problem - minimization of shifted sphere and rastrigin functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_problem(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="example_problem_+3A_x">X</code></td>
<td>
<p>population matrix (see <code><a href="#topic+moead">moead()</a></code> for details)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of objective function values
</p>

<hr>
<h2 id='find_nondominated_points'>Find non-dominated points</h2><span id='topic+find_nondominated_points'></span>

<h3>Description</h3>

<p>Non-dominated point finding for <strong>minimization</strong> problems
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_nondominated_points(Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_nondominated_points_+3A_y">Y</code></td>
<td>
<p>row matrix of points in the space of objectives.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Non-dominated point finding, based on portions of function <em>fastNonDominatedSorting</em>
from package NSGA2R
(<a href="https://CRAN.R-project.org/package=nsga2R">https://CRAN.R-project.org/package=nsga2R</a>)
</p>


<h3>Value</h3>

<p>logical vector of length <code>nrow(Y)</code> indicating the nondominated points
as <code>TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y  &lt;- matrix(runif(200), ncol = 2)
nd &lt;- find_nondominated_points(Y)
plot(Y[, 1], Y[, 2], type = "p", pch = 20, las = 1)
points(Y[nd, 1], Y[nd, 2], type = "p", pch = 16, col = 2, cex = 1.5)

</code></pre>

<hr>
<h2 id='generate_weights'>Calculate weight vectors</h2><span id='topic+generate_weights'></span>

<h3>Description</h3>

<p>Calculates weight vectors for the MOEADr package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_weights(decomp, m, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_weights_+3A_decomp">decomp</code></td>
<td>
<p>List containing the decomposition method parameters. See
<code><a href="#topic+moead">moead()</a></code> for details.</p>
</td></tr>
<tr><td><code id="generate_weights_+3A_m">m</code></td>
<td>
<p>Number of objectives (<code class="reqn">m \ge 2</code>)</p>
</td></tr>
<tr><td><code id="generate_weights_+3A_...">...</code></td>
<td>
<p>other parameters (included for compatibility with generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine calculates the weight vectors for the MOEA/D. The
list of available methods for generating the weights, as well as information
about their specific parameters, can be generated using
<code>get_decomposition_methods()</code>.
</p>


<h3>Value</h3>

<p>Weight matrix <code>W</code>
</p>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>decomp &lt;- list(name = "sld", H = 99)
W &lt;- generate_weights(decomp, m = 2)

</code></pre>

<hr>
<h2 id='get_constraint_methods'>Print available constraint methods</h2><span id='topic+get_constraint_methods'></span>

<h3>Description</h3>

<p>Prints the constraint handling methods available in the MOEADr package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_constraint_methods()
</code></pre>


<h3>Details</h3>

<p>This routine prints the names of the constraint handling methods available in
the MOEADr package, to be used as the <code>constraint$name</code> parameter in the
<code>moead(...)</code> call. Instructions for obtaining more info on each
operator are also returned.
</p>


<h3>Value</h3>

<p>Formatted data frame containing reference name (for
<code>constraint$name</code>) and instructions for More Info about each method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_constraint_methods()

</code></pre>

<hr>
<h2 id='get_decomposition_methods'>Print available decomposition methods</h2><span id='topic+get_decomposition_methods'></span>

<h3>Description</h3>

<p>Prints the decomposition methods available in the MOEADr package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_decomposition_methods()
</code></pre>


<h3>Details</h3>

<p>This routine prints the names of the decomposition methods available in
the MOEADr package, to be used as the <code>decomp$name</code> parameter in the
<code>moead(...)</code> call. Instructions for obtaining more info on each
operator are also returned.
</p>


<h3>Value</h3>

<p>Formatted data frame containing reference name (for
<code>decomp$name</code>) and instructions for More Info about each method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_decomposition_methods()

</code></pre>

<hr>
<h2 id='get_localsearch_methods'>Print available local search methods</h2><span id='topic+get_localsearch_methods'></span>

<h3>Description</h3>

<p>Prints the local search methods available in the MOEADr package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_localsearch_methods()
</code></pre>


<h3>Details</h3>

<p>This routine prints the names of the local search methods available in
the MOEADr package, to be used as the <code>aggfun$name</code> parameter in the
<code>moead(...)</code> call. Instructions for obtaining more info on each
operator are also returned.
</p>


<h3>Value</h3>

<p>Formatted data frame containing reference name (for
<code>variation$localsearch$type</code>) and instructions for More Info about
each method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_localsearch_methods()

</code></pre>

<hr>
<h2 id='get_scalarization_methods'>Print available scalarization methods</h2><span id='topic+get_scalarization_methods'></span>

<h3>Description</h3>

<p>Prints the scalarization methods available in the MOEADr package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_scalarization_methods()
</code></pre>


<h3>Details</h3>

<p>This routine prints the names of the scalarization methods available in
the MOEADr package, to be used as the <code>aggfun$name</code> parameter in the
<code>moead(...)</code> call. Instructions for obtaining more info on each
operator are also returned.
</p>


<h3>Value</h3>

<p>Formatted data frame containing reference name (for
<code>aggfun$name</code>) and instructions for More Info about each method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_scalarization_methods()

</code></pre>

<hr>
<h2 id='get_stop_criteria'>Print available stop criteria</h2><span id='topic+get_stop_criteria'></span>

<h3>Description</h3>

<p>Prints the stop criteria available in the MOEADr package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_stop_criteria()
</code></pre>


<h3>Details</h3>

<p>This routine prints the names of the stop criteria available in
the MOEADr package, to be used as the <code>stopcrit[[i]]$name</code> parameter
in the <code>moead(...)</code> call. Instructions for obtaining more info on each
criterion are also returned.
</p>


<h3>Value</h3>

<p>Formatted data frame containing reference name (for
<code>stopcrit[[i]]$name</code>) and instructions for More Info about each
criterion.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_stop_criteria()

</code></pre>

<hr>
<h2 id='get_update_methods'>Print available update methods</h2><span id='topic+get_update_methods'></span>

<h3>Description</h3>

<p>Prints the update methods available in the MOEADr package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_update_methods()
</code></pre>


<h3>Details</h3>

<p>This routine prints the names of the update methods available in
the MOEADr package, to be used as the <code>update$name</code> parameter in the
<code>moead(...)</code> call. Instructions for obtaining more info on each
operator are also returned.
</p>


<h3>Value</h3>

<p>Formatted data frame containing reference name (for
<code>update$name</code>) and instructions for More Info about each method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_update_methods()

</code></pre>

<hr>
<h2 id='get_variation_operators'>Print available variation operators</h2><span id='topic+get_variation_operators'></span>

<h3>Description</h3>

<p>Prints the variation operators available in the MOEADr package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_variation_operators()
</code></pre>


<h3>Details</h3>

<p>This routine prints the names of the variation operators available in
the MOEADr package, to be used as the <code>variation$name</code> parameter in the
<code>moead(...)</code> call. Instructions for obtaining more info on each
operator are also returned.
</p>


<h3>Value</h3>

<p>Formatted data frame containing reference name (for
<code>variation$name</code>) and instructions for More Info about each operator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_variation_operators()

</code></pre>

<hr>
<h2 id='ls_dvls'>Differential vector-based local search</h2><span id='topic+ls_dvls'></span>

<h3>Description</h3>

<p>Differential vector-based local search (DVLS) implementation for the MOEA/D
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ls_dvls(
  Xt,
  Yt,
  Vt,
  B,
  W,
  which.x,
  trunc.x,
  problem,
  scaling,
  aggfun,
  constraint,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ls_dvls_+3A_xt">Xt</code></td>
<td>
<p>Matrix of incumbent solutions</p>
</td></tr>
<tr><td><code id="ls_dvls_+3A_yt">Yt</code></td>
<td>
<p>Matrix of objective function values for Xt</p>
</td></tr>
<tr><td><code id="ls_dvls_+3A_vt">Vt</code></td>
<td>
<p>List object containing information about the constraint violations
of the <em>incumbent solutions</em>, generated by <code><a href="#topic+evaluate_population">evaluate_population()</a></code></p>
</td></tr>
<tr><td><code id="ls_dvls_+3A_b">B</code></td>
<td>
<p>Neighborhood matrix, generated by <code><a href="#topic+define_neighborhood">define_neighborhood()</a></code>.</p>
</td></tr>
<tr><td><code id="ls_dvls_+3A_w">W</code></td>
<td>
<p>matrix of weights (generated by <code><a href="#topic+generate_weights">generate_weights()</a></code>).</p>
</td></tr>
<tr><td><code id="ls_dvls_+3A_which.x">which.x</code></td>
<td>
<p>logical vector indicating which subproblems should undergo
local search</p>
</td></tr>
<tr><td><code id="ls_dvls_+3A_trunc.x">trunc.x</code></td>
<td>
<p>logical flag indicating whether candidate solutions generated
by local search should be truncated to the variable limits of the problem.</p>
</td></tr>
<tr><td><code id="ls_dvls_+3A_problem">problem</code></td>
<td>
<p>list of named problem parameters. See Section
<code style="white-space: pre;">&#8288;Problem Description&#8288;</code> of the <code><a href="#topic+moead">moead()</a></code> documentation for details.</p>
</td></tr>
<tr><td><code id="ls_dvls_+3A_scaling">scaling</code></td>
<td>
<p>list containing the scaling parameters (see <code><a href="#topic+moead">moead()</a></code> for
details).</p>
</td></tr>
<tr><td><code id="ls_dvls_+3A_aggfun">aggfun</code></td>
<td>
<p>List containing the aggregation function parameters. See
Section <code style="white-space: pre;">&#8288;Scalar Aggregation Functions&#8288;</code> of the <code><a href="#topic+moead">moead()</a></code> documentation for
details.</p>
</td></tr>
<tr><td><code id="ls_dvls_+3A_constraint">constraint</code></td>
<td>
<p>list containing the parameters defining the constraint
handling method. See Section <code style="white-space: pre;">&#8288;Constraint Handling&#8288;</code> of the <code><a href="#topic+moead">moead()</a></code>
documentation for details.</p>
</td></tr>
<tr><td><code id="ls_dvls_+3A_...">...</code></td>
<td>
<p>other parameters (included for compatibility with generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine implements the differential vector-based local search for
the MOEADr package. Check the references for details.
</p>
<p>This routine is intended to be used internally by <code><a href="#topic+variation_localsearch">variation_localsearch()</a></code>,
and should not be called directly by the user.
</p>


<h3>Value</h3>

<p>List object with fields <code>X</code> (matrix containing the modified points,
with points that did not undergo local search indicated as NA) and <code>nfe</code>
(integer value informing how many additional function evaluations were
performed).
</p>


<h3>References</h3>

<p>B. Chen, W. Zeng, Y. Lin, D. Zhang,
&quot;A new local search-based multiobjective optimization algorithm&quot;,
IEEE Trans. Evolutionary Computation 19(1):50-73, 2015.<br />
</p>
<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>

<hr>
<h2 id='ls_tpqa'>Three-point quadratic approximation local search</h2><span id='topic+ls_tpqa'></span>

<h3>Description</h3>

<p>Three-point quadratic approximation (TPQA) local search implementation for
the MOEA/D
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ls_tpqa(
  Xt,
  Yt,
  W,
  B,
  Vt,
  scaling,
  aggfun,
  constraint,
  epsilon = 1e-06,
  which.x,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ls_tpqa_+3A_xt">Xt</code></td>
<td>
<p>Matrix of incumbent solutions</p>
</td></tr>
<tr><td><code id="ls_tpqa_+3A_yt">Yt</code></td>
<td>
<p>Matrix of objective function values for Xt</p>
</td></tr>
<tr><td><code id="ls_tpqa_+3A_w">W</code></td>
<td>
<p>matrix of weights (generated by <code><a href="#topic+generate_weights">generate_weights()</a></code>).</p>
</td></tr>
<tr><td><code id="ls_tpqa_+3A_b">B</code></td>
<td>
<p>Neighborhood matrix, generated by <code><a href="#topic+define_neighborhood">define_neighborhood()</a></code>.</p>
</td></tr>
<tr><td><code id="ls_tpqa_+3A_vt">Vt</code></td>
<td>
<p>List object containing information about the constraint violations
of the <em>incumbent solutions</em>, generated by <code><a href="#topic+evaluate_population">evaluate_population()</a></code></p>
</td></tr>
<tr><td><code id="ls_tpqa_+3A_scaling">scaling</code></td>
<td>
<p>list containing the scaling parameters (see <code><a href="#topic+moead">moead()</a></code> for
details).</p>
</td></tr>
<tr><td><code id="ls_tpqa_+3A_aggfun">aggfun</code></td>
<td>
<p>List containing the aggregation function parameters. See
Section <code style="white-space: pre;">&#8288;Scalar Aggregation Functions&#8288;</code> of the <code><a href="#topic+moead">moead()</a></code> documentation for
details.</p>
</td></tr>
<tr><td><code id="ls_tpqa_+3A_constraint">constraint</code></td>
<td>
<p>list containing the parameters defining the constraint
handling method. See Section <code style="white-space: pre;">&#8288;Constraint Handling&#8288;</code> of the <code><a href="#topic+moead">moead()</a></code>
documentation for details.</p>
</td></tr>
<tr><td><code id="ls_tpqa_+3A_epsilon">epsilon</code></td>
<td>
<p>threshold for using the quadratic approximation value</p>
</td></tr>
<tr><td><code id="ls_tpqa_+3A_which.x">which.x</code></td>
<td>
<p>logical vector indicating which subproblems should undergo
local search</p>
</td></tr>
<tr><td><code id="ls_tpqa_+3A_...">...</code></td>
<td>
<p>other parameters (included for compatibility with generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine implements the 3-point quadratic approximation local search for
the MOEADr package. Check the references for details.
</p>
<p>This routine is intended to be used internally by <code><a href="#topic+variation_localsearch">variation_localsearch()</a></code>,
and should not be called directly by the user.
</p>


<h3>Value</h3>

<p>Matrix <code>X</code>' containing the modified population
</p>


<h3>References</h3>

<p>Y. Tan, Y. Jiao, H. Li, X. Wang,
&quot;A modification to MOEA/D-DE for multiobjective optimization problems with
complicated Pareto sets&quot;,
Information Sciences 213(1):14-38, 2012.<br />
</p>
<p>Y.-C. Jiao, C. Dang, Y. Leung, Y. Hao,
&quot;A modification to the new version of the prices algorithm for continuous
global optimization problems&quot;,
J. Global Optimization 36(4):609-626, 2006.<br />
</p>
<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>

<hr>
<h2 id='make_vectorized_smoof'>Make vectorized smoof function</h2><span id='topic+make_vectorized_smoof'></span>

<h3>Description</h3>

<p>Make a vectorized version of test functions available in package &quot;smoof&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_vectorized_smoof(prob.name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_vectorized_smoof_+3A_prob.name">prob.name</code></td>
<td>
<p>name of the problem to build</p>
</td></tr>
<tr><td><code id="make_vectorized_smoof_+3A_...">...</code></td>
<td>
<p>other parameters passed to each specific function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine builds MOEADr-compliant versions of the classic multiobjective
test functions available in package smoof. The most commonly used ones are:
</p>

<ul>
<li> <p><code>prob.name = ZDT1, ... , ZDT6</code>, in which case the function
requires additional parameter <code>dimensions</code> (positive integer)
</p>
</li>
<li> <p><code>prob.name = DTLZ1, ..., DTLZ7</code>, in which case the function
requires additional parameters <code>dimensions</code> (positive integer),
<code>n.objectives</code> (= 2 or 3) and, for DTLZ4, <code>alpha</code>
(positive integer, defaults to 100).
</p>
</li>
<li> <p><code>prob.name = UF</code>, in which case the function requires
additional parameters <code>dimensions</code> (positive integer) and
<code>id</code> (= 1, ..., 10).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  library(smoof)
  DTLZ2 &lt;- make_vectorized_smoof(prob.name    = "DTLZ2",
                                 dimensions   = 10,
                                 n.objectives = 2)
  DTLZ2(X = matrix(runif(100), ncol = 10))

## End(Not run)

</code></pre>

<hr>
<h2 id='moead'>MOEA/D</h2><span id='topic+moead'></span>

<h3>Description</h3>

<p>MOEA/D implementation in R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moead(
  preset = NULL,
  problem = NULL,
  decomp = NULL,
  aggfun = NULL,
  neighbors = NULL,
  variation = NULL,
  update = NULL,
  constraint = NULL,
  scaling = NULL,
  stopcrit = NULL,
  showpars = NULL,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moead_+3A_preset">preset</code></td>
<td>
<p>List object containing preset values for one or more
of the other parameters of the <code>moead</code> function. Values provided in
the <code>preset</code> list will override any other value provided. Presets should be
generated by the <code><a href="#topic+preset_moead">preset_moead()</a></code> function.</p>
</td></tr>
<tr><td><code id="moead_+3A_problem">problem</code></td>
<td>
<p>List containing the problem parameters.
See <code>Problem Description</code> for details.</p>
</td></tr>
<tr><td><code id="moead_+3A_decomp">decomp</code></td>
<td>
<p>List containing the decomposition method parameters
See <code>Decomposition methods</code> for details.</p>
</td></tr>
<tr><td><code id="moead_+3A_aggfun">aggfun</code></td>
<td>
<p>List containing the aggregation function parameters
See <code>Scalarization methods</code> for details.</p>
</td></tr>
<tr><td><code id="moead_+3A_neighbors">neighbors</code></td>
<td>
<p>List containing the decomposition method parameters
See <code>Neighborhood strategies</code> for details.</p>
</td></tr>
<tr><td><code id="moead_+3A_variation">variation</code></td>
<td>
<p>List containing the variation operator parameters
See <code>Variation operators</code> for details.</p>
</td></tr>
<tr><td><code id="moead_+3A_update">update</code></td>
<td>
<p>List containing the population update parameters
See <code>Update strategies</code> for details.</p>
</td></tr>
<tr><td><code id="moead_+3A_constraint">constraint</code></td>
<td>
<p>List containing the constraint handing parameters
See <code>Constraint operators</code> for details.</p>
</td></tr>
<tr><td><code id="moead_+3A_scaling">scaling</code></td>
<td>
<p>List containing the objective scaling parameters
See <code>Objective scaling</code> for details.</p>
</td></tr>
<tr><td><code id="moead_+3A_stopcrit">stopcrit</code></td>
<td>
<p>list containing the stop criteria parameters.
See <code>Stop criteria</code> for details.</p>
</td></tr>
<tr><td><code id="moead_+3A_showpars">showpars</code></td>
<td>
<p>list containing the echoing behavior parameters.
See <code><a href="#topic+print_progress">print_progress()</a></code> for details.</p>
</td></tr>
<tr><td><code id="moead_+3A_seed">seed</code></td>
<td>
<p>seed for the pseudorandom number generator. Defaults to NULL,
in which case <code>as.integer(Sys.time())</code> is used for the definition.</p>
</td></tr>
<tr><td><code id="moead_+3A_...">...</code></td>
<td>
<p>Other parameters (useful for development and debugging, not
necessary in regular use)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Component-wise implementation of the Multiobjective Evolutionary Algorithm
based on decomposition - MOEA/D.
</p>


<h3>Value</h3>

<p>List object of class <em>moead</em> containing:
</p>

<ul>
<li><p> information on the final population (<code>X</code>), its objective values (<code>Y</code>) and
constraint information list (<code>V</code>) (see <code><a href="#topic+evaluate_population">evaluate_population()</a></code> for details);
</p>
</li>
<li><p> Archive population list containing its corresponding <code>X</code>, <code>Y</code> and <code>V</code>
fields (only if <code>update$UseArchive = TRUE</code>).
</p>
</li>
<li><p> Estimates of the <em>ideal</em> and <em>nadir</em> points, calculated for the final
population;
</p>
</li>
<li><p> Number of function evaluations, iterations, and total execution time;
</p>
</li>
<li><p> Random seed employed in the run, for reproducibility
</p>
</li></ul>



<h3>Problem Description</h3>

<p>The <code>problem</code> parameter consists of a list with all necessary
definitions for the multiobjective optimization problem to be solved.
<code>problem</code> must contain at least the following fields:
</p>

<ul>
<li> <p><code>problem$name</code>: name of the problem instance function, that is, a
routine that calculates <strong>Y</strong> = <strong>f</strong>(<strong>X</strong>);
</p>
</li>
<li> <p><code>problem$xmin</code>: vector of lower bounds of each variable
</p>
</li>
<li> <p><code>problem$xmax</code>: vector of upper bounds of each variable
</p>
</li>
<li> <p><code>problem$m</code>:  integer indicating the number of objectives
</p>
</li></ul>

<p>Besides these fields, <code>problem</code> should contain any other relevant inputs
for the routine listed in <code style="white-space: pre;">&#8288;$name&#8288;</code>. <code>problem</code> may also contain the
(optional) field <code>problem$constraints</code>, which is a list object
containing information about the problem constraints. If present, this list
must have the following fields:
</p>

<ul>
<li> <p><code>problem$constraints$name</code> - (required) name of the function that
calculates the constraint values (see below for details)
</p>
</li>
<li> <p><code>problem$constraints$epsilon</code> - (optional) a small non-negative value
indicating the tolerance to be considered for equality constraints.
Defaults to zero.
</p>
</li></ul>

<p>Besides these fields, <code>problem$constraint</code> should contain any other
relevant inputs for the routine listed in <code>problem$constraint$name</code>.
</p>
<p>Detailed instructions for defining the routines for calculating the
objective and constraint functions are provided in the vignette
<em>Defining Problems in the MOEADr Package</em>. Check that documentation for
details.
</p>


<h3>Decomposition Methods</h3>

<p>The <code>decomp</code> parameter is a list that defines the method to be used for the
generation of the weight vectors. <code>decomp</code> must have
at least the <code style="white-space: pre;">&#8288;$name&#8288;</code> parameter. Currently available methods can be
verified using <code><a href="#topic+get_decomposition_methods">get_decomposition_methods()</a></code>. Check
<code><a href="#topic+generate_weights">generate_weights()</a></code> and the information provided by
<code><a href="#topic+get_decomposition_methods">get_decomposition_methods()</a></code> for more details.
</p>


<h3>Neighborhood Strategies</h3>

<p>The <code>neighbors</code> parameter is a list that defines the method for defining the
neighborhood relations among subproblems. <code>neighbors</code> must have
at least three parameters:
</p>

<ul>
<li> <p><code>neighbors$name</code>, name of the strategy used to define the neighborhoods.
Currently available methods are:
- <code style="white-space: pre;">&#8288;$name = "lambda"&#8288;</code>: uses the distances between weight vectors.
The calculation is performed only once for the entire run,
since the weight vectors are assumed static.
- <code style="white-space: pre;">&#8288;$name = "x"&#8288;</code>: uses the distances between the incumbent solutions
associated with each subproblem. In this case the calculation is
performed at each iteration, since incumbent solutions may change.
</p>
</li>
<li> <p><code>neighbors$T</code>: defines the neighborhood size. This parameter must receive
a value smaller than the number of subproblems defined for the MOEA/D.
</p>
</li>
<li> <p><code>neighbors$delta.p</code>: parameter that defines the probability of sampling
from the neighborhood when performing variation.
</p>
</li></ul>

<p>Check <code><a href="#topic+define_neighborhood">define_neighborhood()</a></code> for more details.
</p>


<h3>Variation Operators</h3>

<p>The <code>variation</code> parameter consists of a list vector, in which each
sublist defines a variation operator to be used as part of the variation
block. Each sublist must have at least a field <code style="white-space: pre;">&#8288;$name&#8288;</code>, containing the name
of the <code>i</code>-th variation operator to be applied. Use
<code><a href="#topic+get_variation_operators">get_variation_operators()</a></code> to generate a list of available operators, and
consult the vignette <code style="white-space: pre;">&#8288;Variation Stack in the MOEADr Package&#8288;</code> for more
details.
</p>


<h3>Scalar Aggregation Functions</h3>

<p>The <code>aggfun</code> parameter is a list that defines the scalar aggregation function
to be used. <code>aggfun</code> must have at least the <code style="white-space: pre;">&#8288;$name&#8288;</code> parameter. Currently
available methods can be verified using <code><a href="#topic+get_scalarization_methods">get_scalarization_methods()</a></code>. Check
<code><a href="#topic+scalarize_values">scalarize_values()</a></code> and the information provided by
<code><a href="#topic+get_scalarization_methods">get_scalarization_methods()</a></code> for more details.
</p>


<h3>Update Methods</h3>

<p>The <code>update</code> parameter is a list that defines the population update strategy
to be used. <code>update</code> must have at least the <code style="white-space: pre;">&#8288;$name&#8288;</code> parameter. Currently
available methods can be verified using <code><a href="#topic+get_update_methods">get_update_methods()</a></code>. Check
<code><a href="#topic+update_population">update_population()</a></code> and the information provided by
<code><a href="#topic+get_update_methods">get_update_methods()</a></code> for more details.
</p>
<p>Another (optional) field of the <code>update</code> parameter is <code>update$UseArchive</code>,
which is a binary flag defining whether the algorithm should keep an
external solution archive (<code>TRUE</code>) or not (<code>FALSE</code>). Since it adds to the
computational burden and memory requirements of the algorithm, the use of an
archive population is recommended only in the case of constrained problems
with constraint handling method that can occasionally accept unfeasible
solutions, leading to the potential loss of feasible efficient solutions for
certain subproblems (e.g., <code><a href="#topic+constraint_vbr">constraint_vbr()</a></code> with <code>type</code> = &quot;sr&quot; or &quot;vt&quot;).
</p>


<h3>Constraint Handling Methods</h3>

<p>The <code>constraint</code> parameter is a list that defines the constraint-handling
technique to be used. <code>constraint</code> must have at least the <code style="white-space: pre;">&#8288;$name&#8288;</code> parameter.
Currently available methods can be verified using <code><a href="#topic+get_constraint_methods">get_constraint_methods()</a></code>.
Check <code><a href="#topic+update_population">update_population()</a></code> and the information provided by
<code><a href="#topic+get_constraint_methods">get_constraint_methods()</a></code> for more details.
</p>


<h3>Objective Scaling</h3>

<p>Objective scaling refers to the re-scaling of the objective values at each
iteration, which is generally considered to prevent problems arising from
differently-scaled objective functions. <code>scaling</code> is a list that must have
at least the <code style="white-space: pre;">&#8288;$name&#8288;</code> parameter. Currently available options are
<code style="white-space: pre;">&#8288;$name = "none"&#8288;</code>, which does not perform any scaling, and <code style="white-space: pre;">&#8288;$name = "simple"&#8288;</code>,
which performs a simple linear scaling of the objectives to the interval
<code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.
</p>


<h3>Stop Criteria</h3>

<p>The <code>stopcrit</code> parameter consists of a list vector, in which each
sublist defines a termination criterion to be used for the MOEA/D. Each
sublist must have at least a field <code style="white-space: pre;">&#8288;$name&#8288;</code>, containing the name of the
<code>i</code>-th criterion to be verified. The iterative cycle of the MOEA/D is
terminated whenever any criterion is met. Use <code><a href="#topic+get_stop_criteria">get_stop_criteria()</a></code> to
generate a list of available criteria, and check the information provided by
that function for more details.
</p>


<h3>Echoing Options</h3>

<p>The <code>showpars</code> parameter is a list that defines the echoing options of the
MOEA/D. <code>showpars</code> must contain two fields:
</p>

<ul>
<li> <p><code>showpars$show.iters</code>, defining the type of echoing output. <code style="white-space: pre;">&#8288;$show.iters&#8288;</code>
can be set as <code>"none"</code>, <code>"numbers"</code>, or <code>"dots"</code>.
</p>
</li>
<li> <p><code>showpars$showevery</code>, defining the period of echoing (in iterations).
<code style="white-space: pre;">&#8288;$showevery&#8288;</code> must be a positive integer.
</p>
</li></ul>



<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Prepare a test problem composed of minimization of the (shifted)
## sphere and Rastrigin functions
sphere     &lt;- function(x){sum((x + seq_along(x) * 0.1) ^ 2)}
rastringin &lt;- function(x){
                x.shift &lt;- x - seq_along(x) * 0.1
                sum((x.shift) ^ 2 - 10 * cos(2 * pi * x.shift) + 10)}
problem.sr &lt;- function(X){
                t(apply(X, MARGIN = 1,
                FUN = function(X){c(sphere(X), rastringin(X))}))}


## Set the input parameters for the moead() routine
## This reproduces the Original MOEA/D of Zhang and Li (2007)
## (with a few changes in the computational budget, to make it run faster)
problem   &lt;- list(name       = "problem.sr",
                  xmin       = rep(-1, 30),
                  xmax       = rep(1, 30),
                  m          = 2)
decomp    &lt;- list(name       = "SLD", H = 49) # &lt;-- H = 99 in the original
neighbors &lt;- list(name       = "lambda",
                  T          = 20,
                  delta.p    = 1)
aggfun    &lt;- list(name       = "wt")
variation &lt;- list(list(name  = "sbx",
                       etax  = 20, pc = 1),
                  list(name  = "polymut",
                       etam  = 20, pm = 0.1),
                  list(name  = "truncate"))
update    &lt;- list(name       = "standard", UseArchive = FALSE)
scaling   &lt;- list(name       = "none")
constraint&lt;- list(name       = "none")
stopcrit  &lt;- list(list(name  = "maxiter",
                    maxiter  = 50))      # &lt;-- maxiter = 200 in the original
showpars  &lt;- list(show.iters = "dots",
                  showevery  = 10)
seed      &lt;- 42

## Run MOEA/D
out1 &lt;- moead(preset = NULL,
              problem, decomp, aggfun, neighbors, variation, update,
              constraint, scaling, stopcrit, showpars, seed)

## Examine the output:
summary(out1)

## Alternatively, the standard MOEA/D could also be set up using the
## preset_moead() function. The code below runs the original MOEA/D with
## exactly the same configurations as in Zhang and Li (2007).
## Not run: 
  out2 &lt;- moead(preset   = preset_moead("original"),
                problem  = problem,
                showpars = showpars,
                seed     = 42)

  ## Examine the output:
  summary(out2)
  plot(out2, suppress.pause = TRUE)

## End(Not run)

# Rerun with MOEA/D-DE configuration and AWT scalarization
out3 &lt;- moead(preset   = preset_moead("moead.de"),
              problem  = problem,
              aggfun   = list(name = "awt"),
              stopcrit = list(list(name    = "maxiter",
                                   maxiter = 50)),
              seed    = seed)
plot(out3, suppress.pause = TRUE)
</code></pre>

<hr>
<h2 id='order_neighborhood'>Order Neighborhood for MOEA/D</h2><span id='topic+order_neighborhood'></span>

<h3>Description</h3>

<p>Calculates the ordering of competing solutions for each subproblem in the
MOEA/D, based on their scalarized performance and violation values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_neighborhood(bigZ, B, V, Vt, constraint)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order_neighborhood_+3A_bigz">bigZ</code></td>
<td>
<p>Matrix of scalarized performance values by neighborhood,
generated by <code><a href="#topic+scalarize_values">scalarize_values()</a></code></p>
</td></tr>
<tr><td><code id="order_neighborhood_+3A_b">B</code></td>
<td>
<p>Neighborhood matrix, generated by <code><a href="#topic+define_neighborhood">define_neighborhood()</a></code>.</p>
</td></tr>
<tr><td><code id="order_neighborhood_+3A_v">V</code></td>
<td>
<p>List object containing information about the constraint violations
of the <em>candidate solutions</em>, generated by <code><a href="#topic+evaluate_population">evaluate_population()</a></code></p>
</td></tr>
<tr><td><code id="order_neighborhood_+3A_vt">Vt</code></td>
<td>
<p>List object containing information about the constraint violations
of the <em>incumbent solutions</em>, generated by <code><a href="#topic+evaluate_population">evaluate_population()</a></code></p>
</td></tr>
<tr><td><code id="order_neighborhood_+3A_constraint">constraint</code></td>
<td>
<p>list containing the parameters defining the constraint
handling method. See Section <code style="white-space: pre;">&#8288;Constraint Handling&#8288;</code> of the <code><a href="#topic+moead">moead()</a></code>
documentation for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine receives a matrix of scalarized performance values (returned by
<code><a href="#topic+scalarize_values">scalarize_values()</a></code>), a neighborhood matrix, and the list of violation
values for the candidate and incumbent populations. It calculates the
preference order of the candidates for each neighborhood based on the
performance values and constraint handling method.
</p>
<p>The list of available constraint handling methods can be generated using
<code><a href="#topic+get_constraint_methods">get_constraint_methods()</a></code>.
</p>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;[N x (T+1)]&#8288;</code> matrix of preference indexes. Each row contains
the T indexes of the candidate solutions in the neighborhood of
a given subproblem, plus a value (column T+1) for the incumbent solution of
that subproblem, in an order defined by the constraint handling method
specified in <code>moead.env$constraint</code>.
</p>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>

<hr>
<h2 id='perform_variation'>Run variation operators</h2><span id='topic+perform_variation'></span>

<h3>Description</h3>

<p>Sequentially apply variation operators for the MOEADr package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perform_variation(variation, X, iter, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perform_variation_+3A_variation">variation</code></td>
<td>
<p>List vector containing the variation operators to be used.
See <code><a href="#topic+moead">moead()</a></code> for details.</p>
</td></tr>
<tr><td><code id="perform_variation_+3A_x">X</code></td>
<td>
<p>Population matrix of the MOEA/D (each row is a candidate solution).</p>
</td></tr>
<tr><td><code id="perform_variation_+3A_iter">iter</code></td>
<td>
<p>iterations counter of the <code><a href="#topic+moead">moead()</a></code> function.</p>
</td></tr>
<tr><td><code id="perform_variation_+3A_...">...</code></td>
<td>
<p>other parameters to be passed down to the individual variation
operators (see documentation of the specific <code>variation_</code><strong>xyz</strong><code style="white-space: pre;">&#8288;()&#8288;</code>
functions for details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine performs the variation block for the MOEA/D. The
list of available variation operators can be generated using
<code><a href="#topic+get_variation_operators">get_variation_operators()</a></code>.
</p>
<p>If the <code>localsearch</code> operator is included, it is executed whenever its
conditions (period of occurrence or probability of occurrence) are verified.
See <code><a href="#topic+variation_localsearch">variation_localsearch()</a></code> for details.
</p>


<h3>Value</h3>

<p>List object containing a modified population matrix <code>X</code>, a
local search argument list <code>ls.arg</code>, and the number of function evaluations
used by the variation operators, <code>var.nfe</code>.
</p>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>

<hr>
<h2 id='plot.moead'>plot.moead</h2><span id='topic+plot.moead'></span>

<h3>Description</h3>

<p>S3 method for plotting <em>moead</em> objects (the output of <code><a href="#topic+moead">moead()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'moead'
plot(
  x,
  ...,
  useArchive = FALSE,
  feasible.only = TRUE,
  viol.threshold = 1e-06,
  nondominated.only = TRUE,
  plot.weights = FALSE,
  which.objectives = NULL,
  suppress.pause = FALSE,
  color.by.obj = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.moead_+3A_x">x</code></td>
<td>
<p>list object of class <em>moead</em>
(generated by <code><a href="#topic+moead">moead()</a></code>)</p>
</td></tr>
<tr><td><code id="plot.moead_+3A_...">...</code></td>
<td>
<p>other parameters to be passed down to specific plotting functions (currently unused)</p>
</td></tr>
<tr><td><code id="plot.moead_+3A_usearchive">useArchive</code></td>
<td>
<p>logical flag to use information from <code>x$Archive</code>.
Only used if x$Archive is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot.moead_+3A_feasible.only">feasible.only</code></td>
<td>
<p>logical flag to use only feasible points in the plots.</p>
</td></tr>
<tr><td><code id="plot.moead_+3A_viol.threshold">viol.threshold</code></td>
<td>
<p>threshold of tolerated constraint violation, used to
determine feasibility if <code>feasible.only == TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.moead_+3A_nondominated.only">nondominated.only</code></td>
<td>
<p>logical flag to use only nondominated points in the
plots.</p>
</td></tr>
<tr><td><code id="plot.moead_+3A_plot.weights">plot.weights</code></td>
<td>
<p>logical flag to plot the weight vectors for 2 and
3-objective problems.</p>
</td></tr>
<tr><td><code id="plot.moead_+3A_which.objectives">which.objectives</code></td>
<td>
<p>integer vector of which objectives to plot.
Defaults to <code>NULL</code> (use all objectives)</p>
</td></tr>
<tr><td><code id="plot.moead_+3A_suppress.pause">suppress.pause</code></td>
<td>
<p>logical flag to prevent pause messages from being show after every image.
Defaults to <code>FALSE</code> (show pause messages)</p>
</td></tr>
<tr><td><code id="plot.moead_+3A_color.by.obj">color.by.obj</code></td>
<td>
<p>integer, determines which objective is used as the basis
for coloring the parallel coordinates plot.</p>
</td></tr>
</table>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>problem.1 &lt;- list(name = "example_problem",
                  xmin = rep(-1,30),
                  xmax = rep(1,30),
                  m    = 2)
out &lt;- moead(preset    = preset_moead("original2"),
             problem   = problem.1,
             stopcrit  = list(list(name = "maxiter",
                                   maxiter = 100)),
             showpars  = list(show.iters = "dots",
                              showevery  = 10))
plot(out, suppress.pause = TRUE)

</code></pre>

<hr>
<h2 id='preset_moead'>preset_moead</h2><span id='topic+preset_moead'></span>

<h3>Description</h3>

<p>Generate a preset configuration for moead()].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preset_moead(name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preset_moead_+3A_name">name</code></td>
<td>
<p>name of the preset to be generated. Use <code>preset_moead()</code> to obtain
the list of available options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a list of configuration presets taken from
the literature to be used with the <code><a href="#topic+moead">moead()</a></code> function in package <code>MOEADr</code>.
</p>
<p>Use these configurations as a starting point. We strongly
recommend that you play around with the particular configurations
(see example).
</p>


<h3>Value</h3>

<p>List object containing the preset, to be used as an input to <code><a href="#topic+moead">moead()</a></code>;
or, if <code>name == NULL</code> (the default), returns a logical flag invisibly.
</p>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate list of available presets
preset_moead(name = NULL)

## Not run: 
  library(smoof) # &lt; Install package smoof if needed
  ZDT1 &lt;- make_vectorized_smoof(prob.name  = "ZDT1",
                                dimensions = 30)
                                problem   &lt;- list(name       = "ZDT1",
                                                  xmin       = rep(0, 30),
                                                  xmax       = rep(1, 30),
                                                  m          = 2)

  # Get preset configuration for original MOEA/D
  configuration &lt;- preset_moead("original")

  # Modify whatever you fancy:
  stopcrit &lt;- list(list(name = "maxiter", maxiter = 50))
  showpars &lt;- list(show.iters = "dots", showevery  = 10)
  seed     &lt;- 42

  output &lt;- moead(problem  = problem,
                  preset   = configuration,
                  showpars = showpars,
                  stopcrit = stopcrit,
                  seed     = seed)

## End(Not run)

</code></pre>

<hr>
<h2 id='print_progress'>Print progress of MOEA/D</h2><span id='topic+print_progress'></span>

<h3>Description</h3>

<p>Echoes progress of MOEA/D to the terminal for the MOEADr package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_progress(iter.times, showpars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_progress_+3A_iter.times">iter.times</code></td>
<td>
<p>vector of iteration times of the <code><a href="#topic+moead">moead()</a></code> routine.</p>
</td></tr>
<tr><td><code id="print_progress_+3A_showpars">showpars</code></td>
<td>
<p>list object containing parameters that control the printed
output of <code><a href="#topic+moead">moead()</a></code>. Parameter <code>showpars</code> can have the
following key-value pairs:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;$show.iters&#8288;</code>: type of output (&quot;dots&quot;, &quot;numbers&quot;, or &quot;none&quot;). If
not present in <code>showpars</code>, it defaults to &quot;numbers&quot;;
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$showevery&#8288;</code>: positive integer that determines how frequently
the routine echoes something to the terminal. If not present in
<code>showpars</code>, it defaults to <code>10</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>

<hr>
<h2 id='print.moead'>print.moead</h2><span id='topic+print.moead'></span>

<h3>Description</h3>

<p>S3 method for printing <em>moead</em> objects (the output of <code><a href="#topic+moead">moead()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'moead'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.moead_+3A_x">x</code></td>
<td>
<p>list object of class <em>moead</em>
(generated by <code><a href="#topic+moead">moead()</a></code>)</p>
</td></tr>
<tr><td><code id="print.moead_+3A_...">...</code></td>
<td>
<p>other parameters to be passed down to specific summary functions
(currently unused)</p>
</td></tr>
</table>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>problem.1 &lt;- list(name = "example_problem",
                  xmin = rep(-1,30),
                  xmax = rep(1,30),
                  m    = 2)
out &lt;- moead(preset    = preset_moead("original2"),
             problem   = problem.1,
             stopcrit  = list(list(name = "maxiter",
                                   maxiter = 100)),
             showpars  = list(show.iters = "dots",
                              showevery  = 10))
print(out)

</code></pre>

<hr>
<h2 id='scalarization_awt'>Adjusted Weighted Tchebycheff Scalarization</h2><span id='topic+scalarization_awt'></span>

<h3>Description</h3>

<p>Perform Adjusted Weighted Tchebycheff Scalarization for the MOEADr package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalarization_awt(Y, W, minP, eps = 1e-16, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalarization_awt_+3A_y">Y</code></td>
<td>
<p>matrix of objective function values</p>
</td></tr>
<tr><td><code id="scalarization_awt_+3A_w">W</code></td>
<td>
<p>matrix of weights.</p>
</td></tr>
<tr><td><code id="scalarization_awt_+3A_minp">minP</code></td>
<td>
<p>numeric vector containing estimated ideal point</p>
</td></tr>
<tr><td><code id="scalarization_awt_+3A_eps">eps</code></td>
<td>
<p>tolerance value for avoiding divisions by zero.</p>
</td></tr>
<tr><td><code id="scalarization_awt_+3A_...">...</code></td>
<td>
<p>other parameters (included for compatibility with generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine calculates the scalarized performance values for the MOEA/D
using the Adjusted Weighted Tchebycheff method.
</p>


<h3>Value</h3>

<p>Vector of scalarized performance values.
</p>


<h3>References</h3>

<p>Y. Qi, X. Ma, F. Liu, L. Jiao, J. Sun, and J. Wu, “MOEA/D with
adaptive weight adjustment,” Evolutionary Computation, vol. 22,
no. 2, pp. 231–264, 2013.<br />
</p>
<p>R. Wang, T. Zhang, and B. Guo, “An enhanced MOEA/D using uniform
directions and a pre-organization procedure,” in IEEE Congress on
Evolutionary Computation, Cancun, Mexico, 2013, pp. 2390–2397.<br />
</p>
<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W    &lt;- generate_weights(decomp = list(name = "sld", H = 19), m = 2)
Y    &lt;- matrix(runif(40), ncol = 2)
minP &lt;- apply(Y, 2, min)
Z    &lt;- scalarization_awt(Y, W, minP)

</code></pre>

<hr>
<h2 id='scalarization_ipbi'>Inverted Penalty-based Boundary Intersection Scalarization</h2><span id='topic+scalarization_ipbi'></span>

<h3>Description</h3>

<p>Perform inverted PBI Scalarization for the MOEADr package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalarization_ipbi(Y, W, maxP, aggfun, eps = 1e-16, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalarization_ipbi_+3A_y">Y</code></td>
<td>
<p>matrix of objective function values</p>
</td></tr>
<tr><td><code id="scalarization_ipbi_+3A_w">W</code></td>
<td>
<p>matrix of weights.</p>
</td></tr>
<tr><td><code id="scalarization_ipbi_+3A_maxp">maxP</code></td>
<td>
<p>numeric vector containing estimated ideal point</p>
</td></tr>
<tr><td><code id="scalarization_ipbi_+3A_aggfun">aggfun</code></td>
<td>
<p>list containing parameters for the aggregation function. Must
contain the non-negative numeric constant <code>aggfun$theta</code>.</p>
</td></tr>
<tr><td><code id="scalarization_ipbi_+3A_eps">eps</code></td>
<td>
<p>tolerance value for avoiding divisions by zero.</p>
</td></tr>
<tr><td><code id="scalarization_ipbi_+3A_...">...</code></td>
<td>
<p>other parameters (included for compatibility with generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine calculates the scalarized performance values for the MOEA/D
using the inverted PBI method.
</p>


<h3>Value</h3>

<p>Vector of scalarized performance values.
</p>


<h3>References</h3>

<p>H. Sato,
&quot;Inverted PBI in MOEA/D and its impact on the search performance on multi
and many-objective optimization.&quot;
Proceedings of the 2014 Annual Conference on Genetic and
Evolutionary Computation (GECCO), 2014.<br />
</p>
<p>H. Sato,
&quot;Analysis of inverted PBI and comparison with other scalarizing functions in
decomposition based MOEAs.&quot;
Journal of Heuristics 21(6):819-849, 2015<br />
</p>
<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W      &lt;- generate_weights(decomp = list(name = "sld", H = 19), m = 2)
Y      &lt;- matrix(runif(40), ncol = 2)
minP   &lt;- apply(Y, 2, min)
aggfun &lt;- aggfun    &lt;- list(name = "ipbi", theta = 5)
Z      &lt;- scalarization_ipbi(Y, W, minP, aggfun)

</code></pre>

<hr>
<h2 id='scalarization_pbi'>Penalty-based Boundary Intersection Scalarization</h2><span id='topic+scalarization_pbi'></span>

<h3>Description</h3>

<p>Perform PBI Scalarization for the MOEADr package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalarization_pbi(Y, W, minP, aggfun, eps = 1e-16, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalarization_pbi_+3A_y">Y</code></td>
<td>
<p>matrix of objective function values</p>
</td></tr>
<tr><td><code id="scalarization_pbi_+3A_w">W</code></td>
<td>
<p>matrix of weights.</p>
</td></tr>
<tr><td><code id="scalarization_pbi_+3A_minp">minP</code></td>
<td>
<p>numeric vector containing estimated ideal point</p>
</td></tr>
<tr><td><code id="scalarization_pbi_+3A_aggfun">aggfun</code></td>
<td>
<p>list containing parameters for the aggregation function. Must
contain the non-negative numeric constant <code>aggfun$theta</code>.</p>
</td></tr>
<tr><td><code id="scalarization_pbi_+3A_eps">eps</code></td>
<td>
<p>tolerance value for avoiding divisions by zero.</p>
</td></tr>
<tr><td><code id="scalarization_pbi_+3A_...">...</code></td>
<td>
<p>other parameters (included for compatibility with generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine calculates the scalarized performance values for the MOEA/D
using the PBI method.
</p>


<h3>Value</h3>

<p>Vector of scalarized performance values.
</p>


<h3>References</h3>

<p>Q. Zhang and H. Li, &quot;MOEA/D: A Multiobjective Evolutionary Algorithm
Based on Decomposition&quot;, IEEE Trans. Evol. Comp. 11(6): 712-731, 2007.<br />
</p>
<p>H. Li, Q. Zhang, &quot;Multiobjective Optimization Problems With Complicated
Pareto Sets, MOEA/D and NSGA-II&quot;, IEEE. Trans. Evol. Comp. 12(2):284-302,
2009.<br />
</p>
<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W      &lt;- generate_weights(decomp = list(name = "sld", H = 19), m = 2)
Y      &lt;- matrix(runif(40), ncol = 2)
minP   &lt;- apply(Y, 2, min)
aggfun &lt;- aggfun    &lt;- list(name = "pbi", theta = 5)
Z      &lt;- scalarization_pbi(Y, W, minP, aggfun)

</code></pre>

<hr>
<h2 id='scalarization_ws'>Weighted Sum Scalarization</h2><span id='topic+scalarization_ws'></span>

<h3>Description</h3>

<p>Perform Weighted Sum Scalarization for the MOEADr package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalarization_ws(Y, W, minP, eps = 1e-16, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalarization_ws_+3A_y">Y</code></td>
<td>
<p>matrix of objective function values</p>
</td></tr>
<tr><td><code id="scalarization_ws_+3A_w">W</code></td>
<td>
<p>matrix of weights.</p>
</td></tr>
<tr><td><code id="scalarization_ws_+3A_minp">minP</code></td>
<td>
<p>numeric vector containing estimated ideal point</p>
</td></tr>
<tr><td><code id="scalarization_ws_+3A_eps">eps</code></td>
<td>
<p>tolerance value for avoiding divisions by zero.</p>
</td></tr>
<tr><td><code id="scalarization_ws_+3A_...">...</code></td>
<td>
<p>other parameters (included for compatibility with generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine calculates the scalarized performance values for the MOEA/D
using the  Weighted Sum method.
</p>


<h3>Value</h3>

<p>vector of scalarized performance values.
</p>


<h3>References</h3>

<p>Q. Zhang and H. Li, &quot;MOEA/D: A Multiobjective Evolutionary Algorithm
Based on Decomposition&quot;, IEEE Trans. Evol. Comp. 11(6): 712-731, 2007.<br />
</p>
<p>H. Li, Q. Zhang, &quot;Multiobjective Optimization Problems With Complicated
Pareto Sets, MOEA/D and NSGA-II&quot;, IEEE. Trans. Evol. Comp. 12(2):284-302,
2009.<br />
</p>
<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W    &lt;- generate_weights(decomp = list(name = "sld", H = 19), m = 2)
Y    &lt;- matrix(runif(40), ncol = 2)
minP &lt;- apply(Y, 2, min)
Z    &lt;- scalarization_ws(Y, W, minP)

</code></pre>

<hr>
<h2 id='scalarization_wt'>Weighted Tchebycheff Scalarization</h2><span id='topic+scalarization_wt'></span>

<h3>Description</h3>

<p>Perform Weighted Tchebycheff Scalarization for the MOEADr package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalarization_wt(Y, W, minP, eps = 1e-16, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalarization_wt_+3A_y">Y</code></td>
<td>
<p>matrix of objective function values</p>
</td></tr>
<tr><td><code id="scalarization_wt_+3A_w">W</code></td>
<td>
<p>matrix of weights.</p>
</td></tr>
<tr><td><code id="scalarization_wt_+3A_minp">minP</code></td>
<td>
<p>numeric vector containing estimated ideal point</p>
</td></tr>
<tr><td><code id="scalarization_wt_+3A_eps">eps</code></td>
<td>
<p>tolerance value for avoiding divisions by zero.</p>
</td></tr>
<tr><td><code id="scalarization_wt_+3A_...">...</code></td>
<td>
<p>other parameters (included for compatibility with generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine calculates the scalarized performance values for the MOEA/D
using the  Weighted Tchebycheff method.
</p>


<h3>Value</h3>

<p>Vector of scalarized performance values.
</p>


<h3>References</h3>

<p>Q. Zhang and H. Li, &quot;MOEA/D: A Multiobjective Evolutionary Algorithm
Based on Decomposition&quot;, IEEE Trans. Evol. Comp. 11(6): 712-731, 2007.<br />
</p>
<p>H. Li, Q. Zhang, &quot;Multiobjective Optimization Problems With Complicated
Pareto Sets, MOEA/D and NSGA-II&quot;, IEEE. Trans. Evol. Comp. 12(2):284-302,
2009.<br />
</p>
<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W    &lt;- generate_weights(decomp = list(name = "sld", H = 19), m = 2)
Y    &lt;- matrix(runif(40), ncol = 2)
minP &lt;- apply(Y, 2, min)
Z    &lt;- scalarization_wt(Y, W, minP)

</code></pre>

<hr>
<h2 id='scalarize_values'>Scalarize values for MOEA/D</h2><span id='topic+scalarize_values'></span>

<h3>Description</h3>

<p>Perform scalarization for the MOEADr package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalarize_values(normYs, W, B, aggfun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalarize_values_+3A_normys">normYs</code></td>
<td>
<p>List generated by <code><a href="#topic+scale_objectives">scale_objectives()</a></code>, containing two matrices
of scaled objective values (<code>normYs$Y</code> and <code>normYs$Yt</code>) and two vectors,
containing the current estimates of the ideal (<code>normYs$minP</code>) and nadir
(<code>normYs$maxP</code>) points. See <code><a href="#topic+scale_objectives">scale_objectives()</a></code> for details.</p>
</td></tr>
<tr><td><code id="scalarize_values_+3A_w">W</code></td>
<td>
<p>matrix of weights, generated by <code><a href="#topic+generate_weights">generate_weights()</a></code>.</p>
</td></tr>
<tr><td><code id="scalarize_values_+3A_b">B</code></td>
<td>
<p>neighborhood matrix, generated by <code><a href="#topic+define_neighborhood">define_neighborhood()</a></code>.</p>
</td></tr>
<tr><td><code id="scalarize_values_+3A_aggfun">aggfun</code></td>
<td>
<p>List containing the aggregation function parameters. See
Section <code style="white-space: pre;">&#8288;Scalar Aggregation Functions&#8288;</code> of the <code><a href="#topic+moead">moead()</a></code> documentation for
details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine calculates the scalarized performance values for the MOEA/D.
</p>
<p>The list of available scalarization methods can be generated using
<code>get_scalarization_methods()</code>
</p>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;[ (T+1) x N ]&#8288;</code> matrix of scalarized performance values. Each column
contains the T scalarized performances of the candidate solutions in the
neighborhood of a given subproblem, plus the scalarized performance value
for the incumbent solution for that subproblem.
</p>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>

<hr>
<h2 id='scale_objectives'>Scaling of the objective function values</h2><span id='topic+scale_objectives'></span>

<h3>Description</h3>

<p>Performs scaling of the objective function values for the MOEADr package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_objectives(Y, Yt, scaling, eps = 1e-16, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_objectives_+3A_y">Y</code></td>
<td>
<p>matrix of objective function values for the incumbent solutions</p>
</td></tr>
<tr><td><code id="scale_objectives_+3A_yt">Yt</code></td>
<td>
<p>matrix of objective function values for the candidate solutions</p>
</td></tr>
<tr><td><code id="scale_objectives_+3A_scaling">scaling</code></td>
<td>
<p>list containing the scaling parameters (see <code><a href="#topic+moead">moead()</a></code> for
details).</p>
</td></tr>
<tr><td><code id="scale_objectives_+3A_eps">eps</code></td>
<td>
<p>tolerance value for avoiding divisions by zero.</p>
</td></tr>
<tr><td><code id="scale_objectives_+3A_...">...</code></td>
<td>
<p>other parameters (included for compatibility with generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine scales the matrices of objective function values for the
current (<code>Yt</code>) and candidate (<code>Y</code>) solutions. The
following methods are currently available:
</p>

<ul>
<li> <p><code>scaling$name = "none"</code>: no scaling
</p>
</li>
<li> <p><code>scaling$name = "simple"</code>: simple linear scaling between
estimated ideal and nadir points, calculated from the available points in
<code>Y</code> and <code>Yt</code> at each iteration.
</p>
</li></ul>



<h3>Value</h3>

<p>List object containing scaled objective function value matrices
<code>Y</code> and <code>Yt</code>, as well as estimates of the &quot;ideal&quot; point <code style="white-space: pre;">&#8288;minP`` and "nadir" point &#8288;</code>maxP'.
</p>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>

<hr>
<h2 id='stop_maxeval'>Stop criterion: maximum number of evaluations</h2><span id='topic+stop_maxeval'></span>

<h3>Description</h3>

<p>Verifies stop criterion &quot;maximum number of evaluations&quot; for the MOEADr
package. For internal use only, not to be called directly by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_maxeval(stopcrit, nfe, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_maxeval_+3A_stopcrit">stopcrit</code></td>
<td>
<p>list containing the parameters defining the stop
handling method. See Section <code style="white-space: pre;">&#8288;Constraint Handling&#8288;</code> of the <code><a href="#topic+moead">moead()</a></code>
documentation for details.</p>
</td></tr>
<tr><td><code id="stop_maxeval_+3A_nfe">nfe</code></td>
<td>
<p>evaluations counter of <code><a href="#topic+moead">moead()</a></code>.</p>
</td></tr>
<tr><td><code id="stop_maxeval_+3A_...">...</code></td>
<td>
<p>other parameters (included for compatibility with generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When this stop criterion is used, one element of the <code>stopcrit</code>
parameter (see <code><a href="#topic+moead">moead()</a></code>) must have the following structure:
</p>

<ul>
<li> <p><code>stopcrit$name = "maxeval"</code>
</p>
</li>
<li> <p><code>stopcrit$maxeval</code>, containing a positive integer representing the
desired maximum number of evaluations.
</p>
</li></ul>



<h3>Value</h3>

<p>boolean value: <code>TRUE</code> if this criterion has been met, <code>FALSE</code>
otherwise.
</p>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>

<hr>
<h2 id='stop_maxiter'>Stop criterion: maximum number of iterations</h2><span id='topic+stop_maxiter'></span>

<h3>Description</h3>

<p>Verifies stop criterion &quot;maximum number of iterations&quot; for the MOEADr
package. For internal use only, not to be called directly by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_maxiter(stopcrit, iter, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_maxiter_+3A_stopcrit">stopcrit</code></td>
<td>
<p>list containing the parameters defining the stop
handling method. See Section <code style="white-space: pre;">&#8288;Constraint Handling&#8288;</code> of the <code><a href="#topic+moead">moead()</a></code>
documentation for details.</p>
</td></tr>
<tr><td><code id="stop_maxiter_+3A_iter">iter</code></td>
<td>
<p>iterations counter of <code><a href="#topic+moead">moead()</a></code>.</p>
</td></tr>
<tr><td><code id="stop_maxiter_+3A_...">...</code></td>
<td>
<p>other parameters (included for compatibility with generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When this stop criterion is used, one element of the <code>stopcrit</code>
parameter (see <code><a href="#topic+moead">moead()</a></code>) must have the following structure:
</p>

<ul>
<li> <p><code>stopcrit$name = "maxiter"</code>
</p>
</li>
<li> <p><code>stopcrit$maxiter</code>, containing a positive integer representing the
desired maximum number of iterations.
</p>
</li></ul>



<h3>Value</h3>

<p>boolean value: <code>TRUE</code> if this criterion has been met, <code>FALSE</code>
otherwise.
</p>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>

<hr>
<h2 id='stop_maxtime'>Stop criterion: maximum runtime</h2><span id='topic+stop_maxtime'></span>

<h3>Description</h3>

<p>Verifies stop criterion &quot;run time limit&quot; for the MOEADr
package. For internal use only, not to be called directly by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_maxtime(stopcrit, iter.times, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_maxtime_+3A_stopcrit">stopcrit</code></td>
<td>
<p>list containing the parameters defining the stop
handling method. See Section <code style="white-space: pre;">&#8288;Constraint Handling&#8288;</code> of the <code><a href="#topic+moead">moead()</a></code>
documentation for details.</p>
</td></tr>
<tr><td><code id="stop_maxtime_+3A_iter.times">iter.times</code></td>
<td>
<p>vector containing the times spent by each iteration of the
moead() routine, up to the current one.</p>
</td></tr>
<tr><td><code id="stop_maxtime_+3A_...">...</code></td>
<td>
<p>other parameters (included for compatibility with generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When this stop criterion is used, one element of the <code>stopcrit</code>
parameter (see <code><a href="#topic+moead">moead()</a></code>) must have the following structure:
</p>

<ul>
<li> <p><code>stopcrit$name = "maxtime"</code>
</p>
</li>
<li> <p><code>stopcrit$maxtime</code>, containing a positive integer representing the
desired time limit (in seconds).
</p>
</li></ul>



<h3>Value</h3>

<p>boolean value: <code>TRUE</code> if this criterion has been met, <code>FALSE</code>
otherwise.
</p>


<h3>Warning</h3>

<p>This function uses Sys.time() for verifying the total run time, i.e., it
counts wall-clock time, not CPU time.
</p>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>

<hr>
<h2 id='summary.moead'>summary.moead</h2><span id='topic+summary.moead'></span>

<h3>Description</h3>

<p>S3 method for summarizing <em>moead</em> objects (the output of <code><a href="#topic+moead">moead()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'moead'
summary(
  object,
  ...,
  useArchive = FALSE,
  viol.threshold = 1e-06,
  ndigits = 3,
  ref.point = NULL,
  ref.front = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.moead_+3A_object">object</code></td>
<td>
<p>list object of class <em>moead</em>
(generated by <code><a href="#topic+moead">moead()</a></code>)</p>
</td></tr>
<tr><td><code id="summary.moead_+3A_...">...</code></td>
<td>
<p>other parameters to be passed down to specific summary functions (currently unused)</p>
</td></tr>
<tr><td><code id="summary.moead_+3A_usearchive">useArchive</code></td>
<td>
<p>logical flag to use information from <code>object$Archive</code>.
Only used if object$Archive is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="summary.moead_+3A_viol.threshold">viol.threshold</code></td>
<td>
<p>threshold of tolerated constraint violation, used to
determine feasibility of points in <code>object</code>.</p>
</td></tr>
<tr><td><code id="summary.moead_+3A_ndigits">ndigits</code></td>
<td>
<p>number of decimal places to use for the ideal and nadir estimates</p>
</td></tr>
<tr><td><code id="summary.moead_+3A_ref.point">ref.point</code></td>
<td>
<p>reference point for calculating the dominated hypervolume
(only if package <code>emoa</code> is available). If <code>NULL</code> the estimated nadir
point is used instead.</p>
</td></tr>
<tr><td><code id="summary.moead_+3A_ref.front">ref.front</code></td>
<td>
<p><code style="white-space: pre;">&#8288;Np x Nobj&#8288;</code> matrix containing a sample of the true Pareto-optimal
front, for calculating IGD.</p>
</td></tr>
</table>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>problem.1 &lt;- list(name = "example_problem",
                  xmin = rep(-1,30),
                  xmax = rep(1,30),
                  m    = 2)
out &lt;- moead(preset    = preset_moead("original2"),
             problem   = problem.1,
             stopcrit  = list(list(name = "maxiter",
                                   maxiter = 100)),
             showpars  = list(show.iters = "dots",
                              showevery  = 10))
summary(out)

</code></pre>

<hr>
<h2 id='unitary_constraints'>Unitary constraints routine</h2><span id='topic+unitary_constraints'></span>

<h3>Description</h3>

<p>Calculates the constraint values and violations when only unitary constraints
(i.e., the sum of all variables equals one) are present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitary_constraints(X, epsilon = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unitary_constraints_+3A_x">X</code></td>
<td>
<p>Population matrix of the MOEA/D (each row is a candidate solution).
If <code>NULL</code> the function searches for <code>X</code> in the calling environment.</p>
</td></tr>
<tr><td><code id="unitary_constraints_+3A_epsilon">epsilon</code></td>
<td>
<p>small non-negative value indicating the tolerance to be
considered for the equality constraint. Defaults to zero.</p>
</td></tr>
<tr><td><code id="unitary_constraints_+3A_...">...</code></td>
<td>
<p>other parameters (unused, included for compatibility with
generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine calculates the constraint values and violations for a population
matrix in the MOEA/D. Each row of the matrix is considered as a candidate
solution. This routine expects the candidate solutions to be standardized,
i.e., that the variable limits given in <code>problem$xmin</code> and
<code>problem$xmax</code> are mapped to <code>0</code> and <code>1</code>, respectively.
</p>


<h3>Value</h3>

<p>List objective containing a matrix of constraint values <code>Cmatrix</code>, a
matrix of individual constraint violations <code>Vmatrix</code>, and a vector of total
constraint violations <code>v</code>.
</p>

<hr>
<h2 id='update_population'>Update population</h2><span id='topic+update_population'></span>

<h3>Description</h3>

<p>Selection and population update procedures for the MOEA/D
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_population(update, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_population_+3A_update">update</code></td>
<td>
<p>List containing the population update parameters. See
Section <code style="white-space: pre;">&#8288;Update Strategies&#8288;</code> of the <code><a href="#topic+moead">moead()</a></code> documentation for
details.</p>
</td></tr>
<tr><td><code id="update_population_+3A_...">...</code></td>
<td>
<p>other parameters to be passed down to the specific
<code>updt_</code><strong>xyz</strong><code style="white-space: pre;">&#8288;()&#8288;</code> routines.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This update routine is intended to be used internally by the main <code><a href="#topic+moead">moead()</a></code>
function, and should not be called directly by the user. The list of
available update methods can be generated using <code><a href="#topic+get_update_methods">get_update_methods()</a></code>.
</p>


<h3>Value</h3>

<p>List object containing the updated values of the population matrix
<code>X</code>, objective function matrix <code>Y</code>, and constraint values list <code>V</code>, as well
as an updated Archive list containing its corresponding components <code>X</code>, <code>Y</code>
and <code>V</code>.
</p>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>

<hr>
<h2 id='updt_best'>Best Neighborhood Replacement Update for MOEA/D</h2><span id='topic+updt_best'></span>

<h3>Description</h3>

<p>Population update using the best neighborhood replacement method for the
MOEADr package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updt_best(update, X, Xt, Y, Yt, V, Vt, normYs, W, BP, constraint, aggfun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updt_best_+3A_update">update</code></td>
<td>
<p>List containing the population update parameters. See
Section <code style="white-space: pre;">&#8288;Update Strategies&#8288;</code> of the <code><a href="#topic+moead">moead()</a></code> documentation for
details. <code>update</code> must have the following key-value pairs:
</p>

<ul>
<li> <p><code>update$Tr</code>: positive integer, neighborhood size for the update
operation
</p>
</li>
<li> <p><code>update$nr</code>: positive integer, maximum number of copies of a given
candidate solution.
</p>
</li></ul>
</td></tr>
<tr><td><code id="updt_best_+3A_x">X</code></td>
<td>
<p>Matrix of candidate solutions</p>
</td></tr>
<tr><td><code id="updt_best_+3A_xt">Xt</code></td>
<td>
<p>Matrix of incumbent solutions</p>
</td></tr>
<tr><td><code id="updt_best_+3A_y">Y</code></td>
<td>
<p>Matrix of objective function values of <code>X</code></p>
</td></tr>
<tr><td><code id="updt_best_+3A_yt">Yt</code></td>
<td>
<p>Matrix of objective function values of <code>Xt</code></p>
</td></tr>
<tr><td><code id="updt_best_+3A_v">V</code></td>
<td>
<p>List object containing information about the constraint violations
of the candidate solutions, generated by <code><a href="#topic+evaluate_population">evaluate_population()</a></code></p>
</td></tr>
<tr><td><code id="updt_best_+3A_vt">Vt</code></td>
<td>
<p>List object containing information about the constraint violations
of the incumbent solutions, generated by <code><a href="#topic+evaluate_population">evaluate_population()</a></code></p>
</td></tr>
<tr><td><code id="updt_best_+3A_normys">normYs</code></td>
<td>
<p>List generated by <code><a href="#topic+scale_objectives">scale_objectives()</a></code>, containing two matrices
of scaled objective values (<code>normYs$Y</code> and <code>normYs$Yt</code>) and two vectors,
containing the current estimates of the ideal (<code>normYs$minP</code>) and nadir
(<code>normYs$maxP</code>) points. See <code><a href="#topic+scale_objectives">scale_objectives()</a></code> for details.</p>
</td></tr>
<tr><td><code id="updt_best_+3A_w">W</code></td>
<td>
<p>matrix of weights, generated by <code><a href="#topic+generate_weights">generate_weights()</a></code>.</p>
</td></tr>
<tr><td><code id="updt_best_+3A_bp">BP</code></td>
<td>
<p>Neighborhood list, generated by <code><a href="#topic+define_neighborhood">define_neighborhood()</a></code>.</p>
</td></tr>
<tr><td><code id="updt_best_+3A_constraint">constraint</code></td>
<td>
<p>list containing the parameters defining the constraint
handling method. See Section <code style="white-space: pre;">&#8288;Constraint Handling&#8288;</code> of the <code><a href="#topic+moead">moead()</a></code>
documentation for details.</p>
</td></tr>
<tr><td><code id="updt_best_+3A_aggfun">aggfun</code></td>
<td>
<p>List containing the aggregation function parameters. See
Section <code style="white-space: pre;">&#8288;Scalar Aggregation Functions&#8288;</code> of the <code><a href="#topic+moead">moead()</a></code> documentation for
details.</p>
</td></tr>
<tr><td><code id="updt_best_+3A_...">...</code></td>
<td>
<p>other parameters (included for compatibility with generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Best Neighborhood Replacement method consists of three steps:
</p>

<ul>
<li><p> For each subproblem <code>i</code>, the best candidate solution <code>x_j</code> from the
entire population is determined.
</p>
</li>
<li><p> The neighborhood of subproblem <code>i</code> is replaced by the neighborhood
of subproblem j. The size of this neighborhood is given by a parameter
<code>Tr</code>.
</p>
</li>
<li><p> The Restricted replacement (see <code><a href="#topic+updt_restricted">updt_restricted()</a></code>) is then
applied using this new neighborhood.
</p>
</li></ul>

<p>This update routine is intended to be used internally by the main <code><a href="#topic+moead">moead()</a></code>
function, and should not be called directly by the user.
</p>


<h3>Value</h3>

<p>List object containing the update population matrix (<code>X</code>),
and its corresponding matrix of objective function values (<code>Y</code>) and
constraint value list (<code>V</code>).
</p>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>

<hr>
<h2 id='updt_restricted'>Restricted Neighborhood Replacement Update for MOEA/D</h2><span id='topic+updt_restricted'></span>

<h3>Description</h3>

<p>Population update using the restricted neighborhood replacement
method for the MOEADr package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updt_restricted(update, X, Xt, Y, Yt, V, Vt, sel.indx, B, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updt_restricted_+3A_update">update</code></td>
<td>
<p>List containing the population update parameters. See
Section <code style="white-space: pre;">&#8288;Update Strategies&#8288;</code> of the <code><a href="#topic+moead">moead()</a></code> documentation for
details. <code>update</code> must contain a field <code>update$nr</code>, a positive integer that
determines the maximum number of copies of each candidate solution.</p>
</td></tr>
<tr><td><code id="updt_restricted_+3A_x">X</code></td>
<td>
<p>Matrix of candidate solutions</p>
</td></tr>
<tr><td><code id="updt_restricted_+3A_xt">Xt</code></td>
<td>
<p>Matrix of incumbent solutions</p>
</td></tr>
<tr><td><code id="updt_restricted_+3A_y">Y</code></td>
<td>
<p>Matrix of objective function values of <code>X</code></p>
</td></tr>
<tr><td><code id="updt_restricted_+3A_yt">Yt</code></td>
<td>
<p>Matrix of objective function values of <code>Xt</code></p>
</td></tr>
<tr><td><code id="updt_restricted_+3A_v">V</code></td>
<td>
<p>List object containing information about the constraint violations
of the candidate solutions, generated by <code><a href="#topic+evaluate_population">evaluate_population()</a></code></p>
</td></tr>
<tr><td><code id="updt_restricted_+3A_vt">Vt</code></td>
<td>
<p>List object containing information about the constraint violations
of the incumbent solutions, generated by <code><a href="#topic+evaluate_population">evaluate_population()</a></code></p>
</td></tr>
<tr><td><code id="updt_restricted_+3A_sel.indx">sel.indx</code></td>
<td>
<p>matrix of selection indices, generated by
<code><a href="#topic+order_neighborhood">order_neighborhood()</a></code></p>
</td></tr>
<tr><td><code id="updt_restricted_+3A_b">B</code></td>
<td>
<p>Neighborhood matrix, generated by <code><a href="#topic+define_neighborhood">define_neighborhood()</a></code>.</p>
</td></tr>
<tr><td><code id="updt_restricted_+3A_...">...</code></td>
<td>
<p>other parameters (included for compatibility with generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The restricted neighborhood replacement method behaves like the &quot;standard&quot;
replacement method, except that each individual can only be selected up to
<code>nr</code> times. After this limit has been reached, the next best individual in
the same neighborhood is selected.
</p>
<p>This update routine is intended to be used internally by the main <code><a href="#topic+moead">moead()</a></code>
function, and should not be called directly by the user.
</p>


<h3>Value</h3>

<p>List object containing the update population matrix (<code>X</code>),
and its corresponding matrix of objective function values (<code>Y</code>) and
constraint value list (<code>V</code>).
</p>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>

<hr>
<h2 id='updt_standard'>Standard Neighborhood Replacement Update for MOEA/D</h2><span id='topic+updt_standard'></span>

<h3>Description</h3>

<p>Population update using the standard neighborhood replacement method for the
MOEADr package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updt_standard(X, Xt, Y, Yt, V, Vt, sel.indx, B, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updt_standard_+3A_x">X</code></td>
<td>
<p>Matrix of candidate solutions</p>
</td></tr>
<tr><td><code id="updt_standard_+3A_xt">Xt</code></td>
<td>
<p>Matrix of incumbent solutions</p>
</td></tr>
<tr><td><code id="updt_standard_+3A_y">Y</code></td>
<td>
<p>Matrix of objective function values of <code>X</code></p>
</td></tr>
<tr><td><code id="updt_standard_+3A_yt">Yt</code></td>
<td>
<p>Matrix of objective function values of <code>Xt</code></p>
</td></tr>
<tr><td><code id="updt_standard_+3A_v">V</code></td>
<td>
<p>List object containing information about the constraint violations
of the candidate solutions, generated by <code><a href="#topic+evaluate_population">evaluate_population()</a></code></p>
</td></tr>
<tr><td><code id="updt_standard_+3A_vt">Vt</code></td>
<td>
<p>List object containing information about the constraint violations
of the incumbent solutions, generated by <code><a href="#topic+evaluate_population">evaluate_population()</a></code></p>
</td></tr>
<tr><td><code id="updt_standard_+3A_sel.indx">sel.indx</code></td>
<td>
<p>matrix of selection indices, generated by
<code><a href="#topic+order_neighborhood">order_neighborhood()</a></code></p>
</td></tr>
<tr><td><code id="updt_standard_+3A_b">B</code></td>
<td>
<p>Neighborhood matrix, generated by <code><a href="#topic+define_neighborhood">define_neighborhood()</a></code>.</p>
</td></tr>
<tr><td><code id="updt_standard_+3A_...">...</code></td>
<td>
<p>other parameters (included for compatibility with generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine executes the standard neighborhood replacement operation to
update the population matrix of the MOEA/D.
This update routine is intended to be used internally by the main <code><a href="#topic+moead">moead()</a></code>
function, and should not be called directly by the user.
</p>


<h3>Value</h3>

<p>List object containing the update population matrix (<code>X</code>),
and its corresponding matrix of objective function values (<code>Y</code>) and
constraint value list (<code>V</code>).
</p>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>

<hr>
<h2 id='variation_binrec'>Binomial Recombination</h2><span id='topic+variation_binrec'></span>

<h3>Description</h3>

<p>Binomial recombination implementation for the MOEA/D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variation_binrec(X, Xt, rho, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variation_binrec_+3A_x">X</code></td>
<td>
<p>Population matrix</p>
</td></tr>
<tr><td><code id="variation_binrec_+3A_xt">Xt</code></td>
<td>
<p>Original population matrix</p>
</td></tr>
<tr><td><code id="variation_binrec_+3A_rho">rho</code></td>
<td>
<p>mutation probability</p>
</td></tr>
<tr><td><code id="variation_binrec_+3A_...">...</code></td>
<td>
<p>other parameters (included for compatibility with generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This variation operator only works if at least one other variation operator
is performed prior to its execution, otherwise it becomes an identity
operator (returns an unchanged matrix X).
</p>


<h3>Value</h3>

<p>Matrix <code>X</code>' containing the recombined population
</p>


<h3>References</h3>

<p>K. Price, R.M. Storn, J.A. Lampinen, &quot;Differential Evolution: A
Practical Approach to Global Optimization&quot;, Springer 2005<br />
</p>
<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>

<hr>
<h2 id='variation_diffmut'>Differential Mutation</h2><span id='topic+variation_diffmut'></span>

<h3>Description</h3>

<p>Differential Mutation implementation for the MOEA/D
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variation_diffmut(X, P, B, Phi = NULL, basis = "rand", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variation_diffmut_+3A_x">X</code></td>
<td>
<p>Population matrix</p>
</td></tr>
<tr><td><code id="variation_diffmut_+3A_p">P</code></td>
<td>
<p>Matrix of selection probabilities (generated by
<code><a href="#topic+define_neighborhood">define_neighborhood()</a></code>)</p>
</td></tr>
<tr><td><code id="variation_diffmut_+3A_b">B</code></td>
<td>
<p>Matrix of neighborhoods (generated by <code><a href="#topic+define_neighborhood">define_neighborhood()</a></code>)</p>
</td></tr>
<tr><td><code id="variation_diffmut_+3A_phi">Phi</code></td>
<td>
<p>Mutation parameter. Either a scalar numeric constant, or NULL for
randomly chosen between <code>0</code> and <code>1</code> (independently sampled for
each operation).</p>
</td></tr>
<tr><td><code id="variation_diffmut_+3A_basis">basis</code></td>
<td>
<p>how to select the basis vector. Currently supported methods are:
</p>

<ul>
<li> <p><code>basis = "rand"</code>, for using a randomly sampled vector from the
population;
</p>
</li>
<li> <p><code>basis = "mean"</code>, for using the mean point of the
neighborhood;
</p>
</li>
<li> <p><code>basis = "wgi"</code>, for using the the weighted mean point of the
neighborhood.
</p>
</li></ul>
</td></tr>
<tr><td><code id="variation_diffmut_+3A_...">...</code></td>
<td>
<p>other parameters to be passed down to specific options of basis
vector generation (e.g., <code>Y</code>, <code>Yt</code>, <code>W</code>, <code>scaling</code> and <code>aggfun</code>, required
when <code>basis = "wgi"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generalizes many variations of the Differential Mutation
operator with general form:
</p>
<p><code>u = x_basis + Phi(x_a - x_b)</code>
</p>
<p>Where u is the new candidate vector, <code>Phi != 0</code> is a real number,
and <code>x_basis</code>, <code>x_a</code> and <code>x_b</code> are distinct vectors.
</p>
<p>This routine is intended to be used internally by <code><a href="#topic+perform_variation">perform_variation()</a></code>,
and should not be called directly by the user.
</p>


<h3>Value</h3>

<p>Matrix <code>X</code>' containing the mutated population
</p>


<h3>References</h3>

<p>K. Price, R.M. Storn, J.A. Lampinen, &quot;Differential Evolution: A
Practical Approach to Global Optimization&quot;, Springer 2005<br />
</p>
<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>
<p>D. V. Arnold, “Weighted multirecombination evolution strategies,”
Theoretical Computer Science 361(1):18–37, 2006.
</p>

<hr>
<h2 id='variation_localsearch'>Local search Operators</h2><span id='topic+variation_localsearch'></span>

<h3>Description</h3>

<p>Local search operators for the MOEA/D
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variation_localsearch(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variation_localsearch_+3A_...">...</code></td>
<td>
<p>arguments to be passed down to the specific <code>ls_</code><strong>xyz</strong><code style="white-space: pre;">&#8288;()&#8288;</code>
functions. A list of available local search methods can be generated by
<code><a href="#topic+get_localsearch_methods">get_localsearch_methods()</a></code>. Consult the documentation of the specific
functions for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine calls the local search operator for the MOEADr package, as part
of the call to <code><a href="#topic+perform_variation">perform_variation()</a></code>. This operator requires its entry
in the variation stack (see Section <code style="white-space: pre;">&#8288;Variation Operators&#8288;</code> of <code><a href="#topic+moead">moead()</a></code>)
to contain the following fields:
</p>

<ul>
<li> <p><code>name = "localsearch"</code>
</p>
</li>
<li> <p><code>type</code> (see <code><a href="#topic+get_localsearch_methods">get_localsearch_methods()</a></code> for details)
</p>
</li>
<li> <p><code>gamma.ls</code> (optional): probability of application of local search to a
given subproblem at any given iteration (numeric between 0 and 1)
</p>
</li>
<li> <p><code>tau.ls</code> (optional): period of application of local search to each
subproblem (positive integer)
</p>
</li>
<li> <p><code>trunc.x</code> (optional): logical flag for truncating the results of the
local search operator to the limits defined by <code>problem$xmin</code>,
<code>problem$xmax</code> (logical). Defaults to <code>TRUE</code>.
</p>
</li></ul>

<p>Whenever local search is triggered for a given subproblem, it cancels
all other variation operators <em>for that subproblem</em> and is executed directly
on the incumbent solution.
</p>
<p>This routine is intended to be used internally by <code><a href="#topic+perform_variation">perform_variation()</a></code>,
and should not be called directly by the user.
</p>


<h3>Value</h3>

<p>Either a matrix <code>Xls</code> containing the modified points (points
that did not undergo local search are indicated as NA in this output matrix),
or a list object containing the <code>Xls</code> matrix and an integer <code>nfe</code>, informing
how many additional function evaluations were performed by the local search
operator. The specific output is defined by the <code>ls_</code><strong>xyz</strong><code style="white-space: pre;">&#8288;()&#8288;</code> method used.
</p>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>

<hr>
<h2 id='variation_none'>Identity operator</h2><span id='topic+variation_none'></span>

<h3>Description</h3>

<p>Identity operator (no variation performed)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variation_none(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variation_none_+3A_x">X</code></td>
<td>
<p>Population matrix</p>
</td></tr>
<tr><td><code id="variation_none_+3A_...">...</code></td>
<td>
<p>other parameters (included for compatibility with generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs the identity operator (no variation). This routine is included to
simplify the use of automated tuning / design tools such as Iterated Racing.
</p>


<h3>Value</h3>

<p>Input matrix <code>X</code>
</p>

<hr>
<h2 id='variation_polymut'>Polynomial mutation</h2><span id='topic+variation_polymut'></span>

<h3>Description</h3>

<p>Polynomial mutation implementation for the MOEA/D
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variation_polymut(X, etam, pm, eps = 1e-06, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variation_polymut_+3A_x">X</code></td>
<td>
<p>Population matrix</p>
</td></tr>
<tr><td><code id="variation_polymut_+3A_etam">etam</code></td>
<td>
<p>mutation constant</p>
</td></tr>
<tr><td><code id="variation_polymut_+3A_pm">pm</code></td>
<td>
<p>variable-wise probability of mutation (numeric value 0 &lt;= pm &lt;= 1,
or use &quot;n&quot; for setting it as (1 / problem dimension).)</p>
</td></tr>
<tr><td><code id="variation_polymut_+3A_eps">eps</code></td>
<td>
<p>small constant used to prevent divisions by zero</p>
</td></tr>
<tr><td><code id="variation_polymut_+3A_...">...</code></td>
<td>
<p>other parameters (included for compatibility with generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This R implementation of the Polynomial Mutation reproduces the C code
implementation available in the R package <strong>emoa</strong> 0.5-0, by Olaf Mersmann.
The differences between the present version and the original one are:
</p>

<ul>
<li><p> The operator is performed on the variables scaled to the <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>
interval, which simplifies the calculations.
</p>
</li>
<li><p> Calculations are vectorized over variables, which also simplifies
the implementation.
</p>
</li></ul>



<h3>Value</h3>

<p>Matrix <code>X</code>' containing the mutated population
</p>


<h3>References</h3>

<p>K. Deb and S. Agrawal (1999). A Niched-Penalty Approach for Constraint
Handling in Genetic Algorithms. In: Artificial Neural Nets and Genetic
Algorithms, pp. 235-243, Springer.<br />
</p>
<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>
<p>Olaf Mersmann (2012). emoa: Evolutionary Multiobjective
Optimization Algorithms. R package version 0.5-0.<br />
http://CRAN.R-project.org/package=emoa
</p>

<hr>
<h2 id='variation_sbx'>Simulated binary crossover</h2><span id='topic+variation_sbx'></span>

<h3>Description</h3>

<p>SBX implementation for the MOEA/D
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variation_sbx(X, P, etax, pc = 1, eps = 1e-06, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variation_sbx_+3A_x">X</code></td>
<td>
<p>Population matrix</p>
</td></tr>
<tr><td><code id="variation_sbx_+3A_p">P</code></td>
<td>
<p>Matrix of probabilities of selection for variation (created by
<code><a href="#topic+define_neighborhood">define_neighborhood()</a></code>).</p>
</td></tr>
<tr><td><code id="variation_sbx_+3A_etax">etax</code></td>
<td>
<p>spread constant</p>
</td></tr>
<tr><td><code id="variation_sbx_+3A_pc">pc</code></td>
<td>
<p>variable-wise probability of recombination</p>
</td></tr>
<tr><td><code id="variation_sbx_+3A_eps">eps</code></td>
<td>
<p>smallest difference considered for recombination</p>
</td></tr>
<tr><td><code id="variation_sbx_+3A_...">...</code></td>
<td>
<p>other parameters (included for compatibility with generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This R implementation of the Simulated Binary Crossover reproduces the C code
implementation available in the R package <strong>emoa</strong> 0.5-0, by Olaf Mersmann.
The differences between the present version and the original one are:
</p>

<ul>
<li><p> The operator is performed on the variables scaled to the <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>
interval, which simplifies the calculations.
</p>
</li>
<li><p> Calculations are vectorized over variables, which also simplifies
the implementation.
</p>
</li></ul>



<h3>Value</h3>

<p>Matrix <code>X</code>' containing the recombined population
</p>


<h3>References</h3>

<p>Deb, K. and Agrawal, R. B. (1995) Simulated binary crossover for continuous
search space. Complex Systems, 9 115-148 <br />
</p>
<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>
<p>Olaf Mersmann (2012). emoa: Evolutionary Multiobjective
Optimization Algorithms. R package version 0.5-0.<br />
http://CRAN.R-project.org/package=emoa
</p>

<hr>
<h2 id='variation_truncate'>Truncate</h2><span id='topic+variation_truncate'></span>

<h3>Description</h3>

<p>Truncation variation operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variation_truncate(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variation_truncate_+3A_x">X</code></td>
<td>
<p>Population matrix</p>
</td></tr>
<tr><td><code id="variation_truncate_+3A_...">...</code></td>
<td>
<p>other parameters (included for compatibility with generic call)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Truncate the solution matrix <code>X</code> to the <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code> interval.
</p>


<h3>Value</h3>

<p>Truncated matrix <code>X</code>'.
</p>


<h3>References</h3>

<p>F. Campelo, L.S. Batista, C. Aranha (2020): The MOEADr Package: A
Component-Based Framework for Multiobjective Evolutionary Algorithms Based on
Decomposition. Journal of Statistical Software <a href="https://doi.org/10.18637/jss.v092.i06">doi:10.18637/jss.v092.i06</a><br />
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
