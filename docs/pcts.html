<!DOCTYPE html><html lang="en"><head><title>Help for package pcts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pcts}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pcts-package'>






<p>Periodically Correlated and Periodically Integrated Time Series</p></a></li>
<li><a href='#+5B-methods'><p>Indexing of objects from classes in package pcts</p></a></li>
<li><a href='#+5B+5B-methods'><p>Methods for function<code>`[[`</code> in package 'pcts'</p></a></li>
<li><a href='#+5B+26lt+3B+26ndash+3Bmethods'><p>Index assignments for objects from classes in package pcts</p></a></li>
<li><a href='#+24-methods'><p>Methods for function<code>$</code> in package 'pcts'</p></a></li>
<li><a href='#allSeasons'><p>Get names of seasons</p></a></li>
<li><a href='#as_date-methods'><p>Replace methods for as_date in package pcts</p></a></li>
<li><a href='#as_datetime-methods'><p>Methods for as_datetime in package pcts</p></a></li>
<li><a href='#autocorrelations-methods'><p>Compute autocorrelations and periodic autocorrelations</p></a></li>
<li><a href='#autocovariances-methods'><p>Compute autocovariances and periodic autocovariances</p></a></li>
<li><a href='#availStart'><p>Time of first or last non-NA value</p></a></li>
<li><a href='#backwardPartialCoefficients-methods'>
<p>Compute periodic backward partial coefficients</p></a></li>
<li><a href='#backwardPartialVariances-methods'>
<p>Compute periodic backward partial variances</p></a></li>
<li><a href='#BareCycle-class'><p>Class BareCycle</p></a></li>
<li><a href='#BasicCycle-class'><p>Class BasicCycle</p></a></li>
<li><a href='#BuiltinCycle-class'><p>Class <code>"BuiltinCycle"</code> and its subclasses in package 'pcts'</p></a></li>
<li><a href='#Cyclic'><p>Create objects from class Cyclic</p></a></li>
<li><a href='#Cyclic-class'><p>Class <code>"Cyclic"</code></p></a></li>
<li><a href='#dataFranses1996'><p>Example data from Franses (1996)</p></a></li>
<li><a href='#date+26lt+3B+26ndash+3Bmethods'><p>Replace methods for date in package pcts</p></a></li>
<li><a href='#ex1f'><p>An example PAR autocorrelation function</p></a></li>
<li><a href='#filterCoef-methods'><p>Get the coefficients of a periodic filter</p></a></li>
<li><a href='#filterPoly-methods'><p>~~ Dummy title ~~</p></a></li>
<li><a href='#filterPolyCoef-methods'><p>~~ Dummy title ~~</p></a></li>
<li><a href='#fit_trigPAR_optim'><p>Fit a subset trigonometric PAR model</p></a></li>
<li><a href='#fitPM'><p>Fit periodic time series models</p></a></li>
<li><a href='#FittedPeriodicArmaModel-class'><p>Class FittedPeriodicArmaModel</p></a></li>
<li><a href='#FittedPeriodicArModel-class'><p>Class FittedPeriodicArModel</p></a></li>
<li><a href='#four_stocks_since2016_01_01'><p>Data for four stocks since 2016-01-01</p></a></li>
<li><a href='#Fraser2017'><p>Fraser River at Hope, mean monthly flow</p></a></li>
<li><a href='#head-methods'><p>Methods for function head() in package pcts</p></a></li>
<li><a href='#LegacyPeriodicFilterModel-class'><p>Class LegacyPeriodicFilterModel</p></a></li>
<li><a href='#maxLag-methods'><p>Methods for function maxLag() in package 'pcts'</p></a></li>
<li><a href='#mC.ss'><p>Create environment for mc-fitting</p></a></li>
<li><a href='#mcOptimCore-class'><p>Class mcOptimCore</p></a></li>
<li><a href='#meanvarcheck'><p>Asymptotic covariance matrix of periodic mean</p></a></li>
<li><a href='#modelCycle'><p>Get the cycle of a periodic object</p></a></li>
<li><a href='#ModelCycleSpec-class'><p>Class ModelCycleSpec</p></a></li>
<li><a href='#nCycles'>
<p>Basic information about periodic ts objects</p></a></li>
<li><a href='#nSeasons-methods'><p>Number of seasons of a periodic object</p></a></li>
<li><a href='#nTicks-methods'><p>Number of observations in a time series</p></a></li>
<li><a href='#num2pcpar'><p>Fit PAR model using sample autocorrelations</p></a></li>
<li><a href='#parcovmatlist'><p>Compute asymptotic covariance matrix for PAR model</p></a></li>
<li><a href='#partialAutocorrelations-methods'>
<p>Compute periodic partial autocorrelations</p></a></li>
<li><a href='#partialAutocovariances-methods'>
<p>Compute periodic partial autocovariances</p></a></li>
<li><a href='#partialCoefficients-methods'>
<p>Compute periodic partial coefficients</p></a></li>
<li><a href='#PartialCycle-class'><p>Class PartialCycle</p></a></li>
<li><a href='#PartialPeriodicAutocorrelations-class'><p>Class PartialPeriodicAutocorrelations</p></a></li>
<li><a href='#partialVariances-methods'>
<p>Compute periodic partial variances</p></a></li>
<li><a href='#pc_sdfactor'><p> Compute normalising factors</p></a></li>
<li><a href='#pc.filter'><p> Applies a periodic ARMA filter to a time series</p></a></li>
<li><a href='#pc.filter.xarma'><p> Filter time series with periodic arma filters</p></a></li>
<li><a href='#pc.hat.h'><p> function to compute estimates of the h weights</p></a></li>
<li><a href='#pcacf_pwn_var'><p> Variances of sample periodic autocorrelations</p></a></li>
<li><a href='#pcacfMat'><p>Compute PAR autocovariance matrix</p></a></li>
<li><a href='#pcalg1'>
<p>Periodic Levinson-Durbin algorithm</p></a></li>
<li><a href='#pcalg1util'>
<p>Give partial periodic autocorrelations or other partial prediction</p>
quantities for a pcAcvf object.</a></li>
<li><a href='#pcApply-methods'><p>Apply a function to each season</p></a></li>
<li><a href='#pcAr.ss'><p>Compute the sum of squares for a given PAR model</p></a></li>
<li><a href='#pcAR2acf'><p>Compute periodic autocorrelations from PAR coefficients</p></a></li>
<li><a href='#pcarma_acvf2model'><p>Fit a PC-ARMA model to a periodic autocovariance function</p></a></li>
<li><a href='#pcarma_solve'>
<p>Functions to compute various characteristics of a PCARMA model</p>
</p></a></li>
<li><a href='#pcarma_unvec'>
<p>Functions for work with a simple list specification of pcarma models</p></a></li>
<li><a href='#pcCycle-methods'><p>Create or extract Cycle objects</p></a></li>
<li><a href='#pclsdf'><p>Fit PAR models using least squares</p></a></li>
<li><a href='#pclspiar'><p>Fit a periodically integrated autoregressive model</p></a></li>
<li><a href='#pcMean-methods'><p>Compute periodic mean</p></a></li>
<li><a href='#pcPlot'><p>Plot periodic time series</p></a></li>
<li><a href='#pcTest-methods'><p>Test for periodicity</p></a></li>
<li><a href='#Pctime'><p>Convert between Pctime and datetime objects</p></a></li>
<li><a href='#pcts'><p>Create objects from periodic time series classes</p></a></li>
<li><a href='#pcts_exdata'><p>Periodic time series objects for examples</p></a></li>
<li><a href='#pcts_reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#pcts-deprecated'><p>Deprecated Functions and classes in Package <span class="pkg">pcts</span></p></a></li>
<li><a href='#pdSafeParOrder'><p> Functions for some basic operations with seasons</p></a></li>
<li><a href='#periodic_acf1_test'><p>McLeod's test for periodic autocorrelation</p></a></li>
<li><a href='#PeriodicArmaFilter-class'><p>Class <code>"PeriodicArmaFilter"</code></p></a></li>
<li><a href='#PeriodicArmaModel-class'><p>Class PeriodicArmaModel</p></a></li>
<li><a href='#PeriodicArmaSpec-class'><p>Class PeriodicArmaSpec</p></a></li>
<li><a href='#PeriodicArModel-class'><p>Class PeriodicArModel</p></a></li>
<li><a href='#PeriodicArModel-methods'><p>Create objects from class PeriodicArModel</p></a></li>
<li><a href='#PeriodicAutocorrelations-class'><p>Class PeriodicAutocorrelations</p></a></li>
<li><a href='#PeriodicAutocovariances-class'><p>Class PeriodicAutocovariances</p></a></li>
<li><a href='#PeriodicBJFilter-class'><p>Class PeriodicBJFilter</p></a></li>
<li><a href='#PeriodicFilterModel-class'><p>Class PeriodicFilterModel</p></a></li>
<li><a href='#PeriodicIntegratedArmaSpec-class'><p>Class PeriodicIntegratedArmaSpec</p></a></li>
<li><a href='#PeriodicInterceptSpec-class'><p>Class PeriodicInterceptSpec</p></a></li>
<li><a href='#PeriodicMaModel-class'><p>Class PeriodicMaModel</p></a></li>
<li><a href='#PeriodicMTS_ts-class'><p>Class <code>"PeriodicMTS_ts"</code></p></a></li>
<li><a href='#PeriodicMTS_zooreg-class'><p>Class <code>"PeriodicMTS_zooreg"</code></p></a></li>
<li><a href='#PeriodicMTS-class'><p>Class <code>"PeriodicMTS"</code></p></a></li>
<li><a href='#PeriodicSPFilter-class'><p>Class PeriodicSPFilter</p></a></li>
<li><a href='#PeriodicTimeSeries-class'><p>Class PeriodicTimeSeries</p></a></li>
<li><a href='#PeriodicTS_ts-class'><p>Class <code>"PeriodicTS_ts"</code></p></a></li>
<li><a href='#PeriodicTS_zooreg-class'><p>Class <code>"PeriodicTS_zooreg"</code></p></a></li>
<li><a href='#PeriodicTS-class'><p>Class <code>"PeriodicTS"</code></p></a></li>
<li><a href='#PeriodicVector-class'><p>Class PeriodicVector</p></a></li>
<li><a href='#permean2intercept'><p>Convert between periodic centering and intercepts</p></a></li>
<li><a href='#permodelmf'><p>Compute the multi-companion form of a per model</p></a></li>
<li><a href='#pi1ar2par'><p>Convert PIAR coefficients to PAR coefficients</p></a></li>
<li><a href='#PiPeriodicArmaModel-class'><p>Class PiPeriodicArmaModel</p></a></li>
<li><a href='#PiPeriodicArModel-class'><p>Class PiPeriodicArModel</p></a></li>
<li><a href='#PiPeriodicMaModel-class'><p>Class PiPeriodicMaModel</p></a></li>
<li><a href='#pwn_McLeodLjungBox_test'><p> McLeod-Ljung-Box test for periodic white noise</p></a></li>
<li><a href='#SamplePeriodicAutocorrelations-class'><p>Class SamplePeriodicAutocorrelations</p></a></li>
<li><a href='#SamplePeriodicAutocovariances-class'><p>Class SamplePeriodicAutocovariances</p></a></li>
<li><a href='#seqSeasons-methods'><p>Methods for seqSeasons() in package pcts</p></a></li>
<li><a href='#sigmaSq-methods'><p>Methods for <code>sigmaSq</code> in package pcts</p></a></li>
<li><a href='#sim_parAcvf'><p>Create a random periodic autocovariance function</p></a></li>
<li><a href='#sim_parCoef'><p> Generate a periodic autoregression model</p></a></li>
<li><a href='#sim_pc'><p>Simulate periodically correlated ARMA series</p></a></li>
<li><a href='#sim_pwn'><p>Simulate periodic white noise</p></a></li>
<li><a href='#SimpleCycle-class'><p>Class SimpleCycle</p></a></li>
<li><a href='#SiPeriodicArmaModel-class'><p>Class SiPeriodicArmaModel</p></a></li>
<li><a href='#SiPeriodicArModel-class'><p>Class SiPeriodicArModel</p></a></li>
<li><a href='#SiPeriodicMaModel-class'><p>Class SiPeriodicMaModel</p></a></li>
<li><a href='#sl_utils'><p> Functions for some basic operations with seasons</p></a></li>
<li><a href='#SLTypeMatrix-class'><p>Class SLTypeMatrix</p></a></li>
<li><a href='#SubsetPM-class'><p>Class SubsetPM</p></a></li>
<li><a href='#tail-methods'><p>Methods for function tail() in package pcts</p></a></li>
<li><a href='#test_piar'><p>Test for periodic integration</p></a></li>
<li><a href='#unitCycle-methods'><p>Methods for <code>unitCycle</code> and <code>unitSeason</code> in package pcts</p></a></li>
<li><a href='#unitCycle+26lt+3B+26ndash+3Bmethods'><p>Methods for <code>`unitCycle&lt;-`</code> and <code>`unitSeason&lt;-`</code> in package pcts</p></a></li>
<li><a href='#Vec'><p>Core data of periodic time series</p></a></li>
<li><a href='#VirtualPeriodicArmaModel-class'><p>Class VirtualPeriodicArmaModel</p></a></li>
<li><a href='#VirtualPeriodicArModel-class'><p>~~ Dummy title ~~</p></a></li>
<li><a href='#VirtualPeriodicAutocorrelations-class'><p>~~ Dummy title ~~</p></a></li>
<li><a href='#VirtualPeriodicAutocovarianceModel-class'><p>~~ Dummy title ~~</p></a></li>
<li><a href='#VirtualPeriodicAutocovariances-class'><p>~~ Dummy title ~~</p></a></li>
<li><a href='#VirtualPeriodicFilterModel-class'><p>~~ Dummy title ~~</p></a></li>
<li><a href='#VirtualPeriodicMaModel-class'><p>~~ Dummy title ~~</p></a></li>
<li><a href='#VirtualPeriodicMeanModel-class'><p>~~ Dummy title ~~</p></a></li>
<li><a href='#VirtualPeriodicModel-class'><p>~~ Dummy title ~~</p></a></li>
<li><a href='#VirtualPeriodicMonicFilter-class'><p>~~ Dummy title ~~</p></a></li>
<li><a href='#VirtualPeriodicStationaryModel-class'><p>~~ Dummy title ~~</p></a></li>
<li><a href='#VirtualPeriodicWhiteNoiseModel-class'><p>~~ Dummy title ~~</p></a></li>
<li><a href='#window'><p>Periodic methods for base R functions</p></a></li>
<li><a href='#zoo-class'><p>Class zoo made S4</p></a></li>
<li><a href='#zooreg-class'><p>Virtual S4 class zooreg</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Periodically Correlated and Periodically Integrated Time Series</td>
</tr>
<tr>
<td>Description:</td>
<td>Classes and methods for modelling and simulation of
    periodically correlated (PC) and periodically integrated time
    series.  Compute theoretical periodic autocovariances and related
    properties of PC autoregressive moving average models. Some original
    methods including Boshnakov &amp; Iqelan (2009)
    &lt;<a href="https://doi.org/10.1111%2Fj.1467-9892.2009.00617.x">doi:10.1111/j.1467-9892.2009.00617.x</a>&gt;, Boshnakov (1996)
    &lt;<a href="https://doi.org/10.1111%2Fj.1467-9892.1996.tb00281.x">doi:10.1111/j.1467-9892.1996.tb00281.x</a>&gt;.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.15.8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>sarima, Matrix (&ge; 1.5-0), BB, PolynomF (&ge; 2.0-2), gbutils,
zoo, xts, stats4, lagged (&ge; 0.2.2), mcompanion (&ge; 0.5.8),
Rdpack (&ge; 0.9), lubridate</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, fUnitRoots, knitr, rmarkdown</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://geobosh.github.io/pcts/">https://geobosh.github.io/pcts/</a> (doc)
<a href="https://github.com/GeoBosh/pcts/">https://github.com/GeoBosh/pcts/</a> (devel)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/GeoBosh/pcts/issues">https://github.com/GeoBosh/pcts/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Collate:</td>
<td>utils.R test1.r PeriodicCalc.R pcstat.R pc00smallutil.r
pc02filters.r pc03simu.r acfsums.R pcls.R pcarma_model.R
pcarma_acf.R generics.R autocovariances.R classCycle.R
pcFilterClasses.R PeriodicClasses.R cyclic.R
FittedPeriodicModels.R fitPM.R pcTest.R PeriodicVector.R sim.R
optimcore.R trig.R</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-17 09:33:01 UTC; georgi</td>
</tr>
<tr>
<td>Author:</td>
<td>Georgi N. Boshnakov
    <a href="https://orcid.org/0000-0003-2839-346X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Georgi N. Boshnakov &lt;georgi.boshnakov@manchester.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-17 11:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='pcts-package'>






Periodically Correlated and Periodically Integrated Time Series
</h2><span id='topic+pcts-package'></span>

<h3>Description</h3>

<p>Classes and methods for modelling and simulation of
    periodically correlated (PC) and periodically integrated time
    series.  Compute theoretical periodic autocovariances and related
    properties of PC autoregressive moving average models. Some original
    methods including Boshnakov &amp; Iqelan (2009)
    &lt;doi:10.1111/j.1467-9892.2009.00617.x&gt;, Boshnakov (1996)
    &lt;doi:10.1111/j.1467-9892.1996.tb00281.x&gt;.
</p>


<h3>Details</h3>

<p>The underlying assumption is that the observations are made at regular
intervals, such as quarter, month, week, day &mdash; or represent data for
such intervals &mdash; and these intervals are nested into larger periods.
In pcts we call the larger period a cycle and its parts seasons. Typical
examples of season-cycle timing are months in a year, quarters in a
year, days in a week (or business week). The number of seasons in a
cycle is called frequency in class <code>"ts"</code> in base <span class="rlang"><b>R</b></span>.
</p>
<p>Cycles in pcts keep not only the number of seasons (frequency) but other
information, such as the names of the seasons and units of seasons.  In
pcts there are a number of builtin cycle classes for typical cases, as
well as provision for creation of custom cycles on the fly.  See
<code><a href="#topic+pcCycle">pcCycle</a></code> and <code><a href="#topic+BuiltinCycle">BuiltinCycle</a></code> for ways to create
cycle objects, and <code><a href="#topic+allSeasons">allSeasons</a></code> for further examples.
</p>
<p>Periodic time series can be created with <code><a href="#topic+pcts">pcts</a></code>, which
accepts as input vectors, matrices and time series objects from base R
and some other packages, including zoo and xts.  When importing data,
the time information is taken from the data and an attempt is made to
guess the periodicity from the frequency (for time series objects that
have it set) and an analysis of the datetime stamps, if present.
<code>pcts</code> also has arguments for specifying the number of seasons or
the cycle, as well as the start datetime.
</p>
<p>The main periodic time series classes in <span class="pkg">pcts</span> are
<code><a href="#topic+PeriodicTS-class">PeriodicTS</a></code> and <code><a href="#topic+PeriodicMTS-class">PeriodicMTS</a></code>,
for univariate and multivariate time series, respectively.  Standard
base-R time series functions can be used with them directly, see for
example
<code><a href="#topic+window.PeriodicTS">window</a></code>,
<code><a href="#topic+frequency.PeriodicTimeSeries">frequency</a></code>,
<code><a href="#topic+cycle.PeriodicTimeSeries">cycle</a></code>,
<code><a href="#topic+time.PeriodicTimeSeries">time</a></code>,
<code><a href="#topic+deltat.PeriodicTimeSeries">deltat</a></code>,
<code><a href="#topic+start.Cyclic">start</a></code>,
<code><a href="#topic+end.Cyclic">end</a></code>,  
<code><a href="#topic+boxplot.PeriodicTimeSeries">boxplot</a></code>,
<code><a href="#topic+monthplot.PeriodicTimeSeries">monthplot</a></code>,
<code><a href="#topic+na.trim.PeriodicTS">na.trim</a></code> (<code>na.trim</code> is from package <span class="pkg">zoo</span>).
</p>
<p>Methods for
<code>plot</code>,
<code>summary</code>,
<code>print</code>,
<code>show</code>,
<code>head</code>,
<code>tail</code>,
and other base-R functions are defined where suitable.  Examples can be
found in section Examples and in help pages for the corresponding
functions, classes and methods.
</p>
<p>The naming conventions are as follows. Names of classes generally
consists of one or more words. The first letter of each word, is
capitalised.  Only the first letter of abbreviations for models, such as
ARMA, is capitalised. Similarly for generic functions but for them the
first word is not capitalised. In a few names PM stands for 'periodic
model' and TS for 'time series'.
</p>
<p>Significant portion of the code was written in 2005&ndash;2007. Many of the
functions and classes have been renamed under the above
conventions and most of those that are not are not exported but a few
still are and they should be considered subject to change.
</p>
<p><code>autocovariances</code>, <code>autocorrelations</code>, <code>partialAutocorrelations</code>
and others are one-stop generic functions for computation of properties
of time series and models. What to compute is deduced from the type of
the object. For models they compute theoretical quantities &mdash; periodic
or non-periodic, scalar or multivariate. For time series they compute
the corresponding sample counterparts.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov [aut, cre]
    (&lt;https://orcid.org/0000-0003-2839-346X&gt;)
</p>
<p>Maintainer: Georgi N. Boshnakov &lt;georgi.boshnakov@manchester.ac.uk&gt;
</p>


<h3>References</h3>



<p>Boshnakov GN (1994).
&ldquo;Periodically Correlated Sequences: Some Properties and Recursions.&rdquo;
Research Report 1, Division of Quality Technology and Statistics, Luleo University, Sweden.<br /><br /> Boshnakov GN (1996).
&ldquo;The asymptotic covariance matrix of the multivariate serial correlations.&rdquo;
<em>Stochastic Process. Appl.</em>, <b>65</b>(2), 251&ndash;258.
ISSN 0304-4149, <a href="https://doi.org/10.1016/S0304-4149%2896%2900104-4">doi:10.1016/S0304-4149(96)00104-4</a>.<br /><br /> Boshnakov GN (1996).
&ldquo;Recursive computation of the parameters of periodic autoregressive moving-average processes.&rdquo;
<em>J. Time Ser. Anal.</em>, <b>17</b>(4), 333&ndash;349.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.1996.tb00281.x">doi:10.1111/j.1467-9892.1996.tb00281.x</a>.<br /><br /> Boshnakov GN (1997).
&ldquo;Periodically correlated solutions to a class of stochastic difference equations.&rdquo;
In Csiszar I, Michaletzky G (eds.), <em>Stochastic differential and difference equations (Gyor, 1996)</em>, volume 23 of <em>Progr. Systems Control Theory</em>, 1&ndash;9.
Birkhauser Boston, Boston, MA.<br /><br /> Boshnakov GN (2002).
&ldquo;Multi-companion matrices.&rdquo;
<em>Linear Algebra Appl.</em>, <b>354</b>, 53&ndash;83.
ISSN 0024-3795, <a href="https://doi.org/10.1016/S0024-3795%2801%2900475-X">doi:10.1016/S0024-3795(01)00475-X</a>.<br /><br /> Boshnakov GN, Boteva A (1992).
&ldquo;An algorithm for the computation of the theoretical autocovariances of a periodic autoregression process.&rdquo;
Varna.<br /><br /> Boshnakov GN, Iqelan BM (2009).
&ldquo;Generation of time series models with given spectral properties.&rdquo;
<em>J. Time Series Anal.</em>, <b>30</b>(3), 349&ndash;368.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.2009.00617.x">doi:10.1111/j.1467-9892.2009.00617.x</a>.<br /><br /> Boshnakov GN, Iqelan BM (2012).
&ldquo;Maximum entropy models for general lag patterns.&rdquo;
<em>Journal of Time Series Analysis</em>, <b>33</b>(1), 112&ndash;120.
ISSN 1467-9892, <a href="https://doi.org/10.1111/j.1467-9892.2011.00744.x">doi:10.1111/j.1467-9892.2011.00744.x</a>.<br /><br /> Boshnakov GN, Lambert-Lacroix S (2009).
&ldquo;Maximum entropy for periodically correlated processes from nonconsecutive autocovariance coefficients.&rdquo;
<em>J. Time Series Anal.</em>, <b>30</b>(5), 467&ndash;486.
<a href="https://doi.org/10.1111/j.1467-9892.2009.00619.x">doi:10.1111/j.1467-9892.2009.00619.x</a>.<br /><br /> Boshnakov GN, Lambert-Lacroix S (2011).
<em>pcme: Maximum entropy estimation of periodically correlated time series</em>.
R package version 0.55, <a href="https://personalpages.manchester.ac.uk/staff/georgi.boshnakov/Rpackages/">https://personalpages.manchester.ac.uk/staff/georgi.boshnakov/Rpackages/</a>.<br /><br /> Boshnakov GN, Lambert-Lacroix S (2012).
&ldquo;A periodic Levinson-Durbin algorithm for entropy maximization.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>56</b>, 15&ndash;24.
ISSN 0167-9473, <a href="https://doi.org/10.1016/j.csda.2011.07.001">doi:10.1016/j.csda.2011.07.001</a>.<br /><br /> Boswijk HP, Franses PH (1996).
&ldquo;Unit roots in periodic autoregressions.&rdquo;
<em>Journal of Time Series Analysis</em>, <b>17</b>(3), 221&ndash;245.<br /><br /> Francq C, Roy R, Saidi A (2011).
&ldquo;Asymptotic properties of weighted least squares estimation in weak parma models.&rdquo;
<em>Journal of Time Series Analysis</em>, <b>32</b>(6), 699&ndash;723.<br /><br /> Franses PH (1996).
<em>Periodicity and Stochastic Trends In Economic Time Series</em>.
Oxford University Press Inc., New York.<br /><br /> Franses PH, Paap R (2004).
<em>Periodic Time Series Models</em>.
Oxford University Press Inc., New York.<br /><br /> Grolemund G, Wickham H (2011).
&ldquo;Dates and Times Made Easy with lubridate.&rdquo;
<em>Journal of Statistical Software</em>, <b>40</b>(3), 1&ndash;25.
<a href="https://doi.org/10.18637/jss.v040.i03">doi:10.18637/jss.v040.i03</a>.<br /><br /> Hipel KW, McLeod AI (1994).
<em>Time series modelling of water resources and environmental systems</em>,  Developments in water science; 45.
London; Amsterdam: Elsevier.<br /><br /> Lambert-Lacroix S (2000).
&ldquo;On periodic autoregressive process estimation.&rdquo;
<em>IEEE Transactions on Signal Processing</em>, <b>48</b>(6), 1800-1803.<br /><br /> Lambert-Lacroix S (2005).
&ldquo;Extension of autocovariance coefficients sequence for periodically correlated processes.&rdquo;
<em>Journal of Time Series Analysis</em>, <b>26</b>(3), 423-435.<br /><br /> Lancaster P, Tismenetsky M (1985).
<em>The theory of matrices</em>, Second edition.
Academic Press, New York.<br /><br /> McLeod AI (1993).
&ldquo;Parsimony, model adequacy and periodic correlation in time series forecasting.&rdquo;
<em>Internat. Statist. Rev.</em>, <b>61</b>(3), 387-393.<br /><br /> McLeod AI (1993).
&ldquo;Parsimony, model adequacy and periodic correlation in time series forecasting.&rdquo;
<em>Internat. Statist. Rev.</em>, <b>61</b>(3), 387-393.<br /><br /> McLeod AI (1994).
&ldquo;Diagnostic checking of periodic autoregression models with application.&rdquo;
<em>Journal of Time Series Analysis</em>, <b>15</b>(2), 221&ndash;233.<br /><br /> McLeod AI (1995).
&ldquo;Diagnostic checking of periodic autoregression models with application.&rdquo;
<em>Journal of Time Series Analysis</em>, <b>16</b>(6), 647-648.
<a href="https://doi.org/10.1111/j.1467-9892.1995.tb00260.x">doi:10.1111/j.1467-9892.1995.tb00260.x</a>, This corrects some typos in the eponimous article  McLeod (1994).<br /><br /> Pagano M (1978).
&ldquo;On periodic and multiple autoregression.&rdquo;
<em>Ann. Statist.</em>, <b>6</b>, 1310-1317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcts">pcts</a></code>,
</p>
<p><code><a href="#topic+fitPM">fitPM</a></code>,
<code><a href="#topic+pclsdf">pclsdf</a></code>,
<code><a href="#topic+pclspiar">pclspiar</a></code>
</p>
<p><code><a href="#topic+autocorrelations">autocorrelations</a></code>
</p>
<p><code><a href="#topic+dataFranses1996">dataFranses1996</a></code>, <code><a href="#topic+Fraser2017">Fraser2017</a></code>,
<code><a href="#topic+four_stocks_since2016_01_01">four_stocks_since2016_01_01</a></code>,
</p>
<p><code><a href="mcompanion.html#topic+mcompanion-package">mcompanion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataFranses1996) 
class(dataFranses1996) # [1] "mts"    "ts"     "matrix"

pcfr &lt;- pcts(dataFranses1996)

class(pcfr)        # "PeriodicMTS"
nSeasons(pcfr) # 4
allSeasons(pcfr)
allSeasons(pcfr, abb = TRUE)

## subsetting
## one index, x[i], is analogous to lists
pcfr2to4 &lt;- pcfr[2:4]; class(pcfr2to4) # "PeriodicMTS"
pcfr2to2 &lt;- pcfr[2];   class(pcfr2to2) # "PeriodicMTS"
pcfr2    &lt;- pcfr[[2]]; class(pcfr2)    # note '[[', "PeriodicTS"

## data for 1990 quarter 3
pcfr2to4[as_date("1990-07-01")] # note: not "1990-03-01"!
pct1990_Q3 &lt;- Pctime(c(1990, 3), pcCycle(pcfr2to4))
pcfr2to4[pct1990_Q3]

## with empty index, returns the underlying data
dim(pcfr[]) # [1] 148  19
dim(pcfr2to2[]) # 148 1
length(pcfr2[]) # 148 (this is numeric)

summary(pcfr2)
summary(pcfr2to4)
## make the output width shorter
summary(pcfr2to4, row.names = FALSE)
summary(pcfr2to4, row.names = 5) # trim row names to 5 characters

head(pcfr2to4)  # starts with NA's
tail(pcfr2to4)  # some NA's at the end too

## time of first and last data, may be NA's
start(pcfr2to4) # 1955 Q1
end(pcfr2to4)   # 1991 Q4

## time of first nonNA:
availStart(pcfr2)    # 1955 Q1
availStart(pcfr2to4) # 1955 Q1

## time of last nonNA:
availEnd(pcfr[[2]])   # 1991 Q4
availEnd(pcfr[[3]])   # 1987 Q4
availEnd(pcfr[[4]])   # 1990 Q4
## but at least one of them is  available for 1991 Q4, so:
availEnd(pcfr2to4)   # 1991 Q4

## use window() to pick part of the ts by time:
window(pcfr2to4, start = c(1990, 1), end = c(1991, 4))
## drop NA's at the start and end:
window(pcfr2to4, start = availStart(pcfr2to4), end = availEnd(pcfr2to4))

plot(pcfr2) # the points mark the first season in each cycle
boxplot(pcfr2)
monthplot(pcfr2)
</code></pre>

<hr>
<h2 id='+5B-methods'>Indexing of objects from classes in package pcts</h2><span id='topic++5B-methods'></span><span id='topic++5B+2CBasicCycle+2CANY+2Cmissing+2CANY-method'></span><span id='topic++5B+2CBasicCycle+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic++5B+2CPeriodicMTS+2CANY+2Cmissing+2CANY-method'></span><span id='topic++5B+2CPeriodicMTS+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic++5B+2CPeriodicVector+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CPeriodicVector+2CANY+2Cmissing+2CANY-method'></span><span id='topic++5B+2CPeriodicVector+2Cmissing+2CANY+2CANY-method'></span><span id='topic++5B+2CPeriodicVector+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic++5B+2CVirtualPeriodicAutocovarianceModel+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic++5B+2CVirtualPeriodicAutocovarianceModel+2Cmissing+2Cnumeric+2CANY-method'></span><span id='topic++5B+2CVirtualPeriodicAutocovarianceModel+2Cnumeric+2Cmissing+2CANY-method'></span><span id='topic++5B+2CVirtualPeriodicAutocovarianceModel+2Cnumeric+2Cnumeric+2CANY-method'></span><span id='topic++5B+2CPeriodicTS+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic++5B+2CPeriodicMTS+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CPeriodicMTS+2CAnyDateTime+2CANY+2CANY-method'></span><span id='topic++5B+2CPeriodicMTS+2CAnyDateTime+2Cmissing+2CANY-method'></span><span id='topic++5B+2CPeriodicTS+2CAnyDateTime+2Cmissing+2CANY-method'></span>

<h3>Description</h3>

<p>Indexing of objects from classes in package pcts.</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "BasicCycle", i = "ANY", j = "missing", drop = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "BasicCycle", i = "missing", j = "missing", drop = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "PeriodicMTS", i = "ANY", j = "missing", drop = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "PeriodicMTS", i = "missing", j = "missing", drop = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "PeriodicVector", i = "ANY", j = "ANY", drop = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "PeriodicVector", i = "ANY", j = "missing", drop = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "PeriodicVector", i = "missing", j = "ANY", drop = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "PeriodicVector", i = "missing", j = "missing", 
          drop = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "VirtualPeriodicAutocovarianceModel", i = "missing", 
          j = "missing", drop = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "VirtualPeriodicAutocovarianceModel", i = "missing", 
          j = "numeric", drop = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "VirtualPeriodicAutocovarianceModel", i = "numeric", 
          j = "missing", drop = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "VirtualPeriodicAutocovarianceModel", i = "numeric", 
          j = "numeric", drop = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "PeriodicTS", i = "missing", j = "missing", drop = "ANY")</code></dt><dd>

</dd>
<dt><code>signature(x = "PeriodicMTS", i = "ANY", j = "ANY", drop = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "PeriodicMTS", i = "AnyDateTime", j = "ANY", drop = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "PeriodicMTS", i = "AnyDateTime", j = "missing", 
          drop = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "PeriodicTS", i = "AnyDateTime", j = "missing", 
          drop = "ANY")</code></dt><dd>

</dd></dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>

<hr>
<h2 id='+5B+5B-methods'>Methods for function<code>`[[`</code> in package 'pcts'</h2><span id='topic++5B+5B-methods'></span><span id='topic++5B+5B+2CPeriodicMTS+2CANY-method'></span><span id='topic++5B+5B+2CPeriodicAutocovarianceModel+2Cnumeric-method'></span><span id='topic++5B+5B+2CPeriodicMTS+2CANY+2CANY-method'></span><span id='topic++5B+5B+2CVirtualPeriodicAutocovarianceModel+2Cnumeric+2CANY-method'></span>

<h3>Description</h3>

<p>Methods for function<code>`[[`</code> in package 'pcts'.</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "PeriodicMTS", i = "ANY", j = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "VirtualPeriodicAutocovarianceModel", i = "numeric", 
          j = "ANY")</code></dt><dd>

</dd></dl>

<hr>
<h2 id='+5B+26lt+3B+26ndash+3Bmethods'>Index assignments for objects from classes in package pcts</h2><span id='topic++5B+3C--methods'></span><span id='topic++5B+3C-+2Cpc.armaPQ+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2CslMatrix+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2CANY+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2CPeriodicVector+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2CPeriodicVector+2Cmissing+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2CBasicCycle+2CANY+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2CBasicCycle+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2CPeriodicAutocovarianceModel+2CANY+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>Index assignments for objects from classes in package pcts.</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "PeriodicVector", i = "ANY", j = "ANY", value = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "PeriodicVector", i = "missing", j = "ANY", value = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "BasicCycle", i = "ANY", j = "missing", value = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "BasicCycle", i = "missing", j = "missing", value = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "PeriodicAutocovarianceModel", i = "ANY", j = "ANY",
          value = "ANY")</code></dt><dd>

</dd></dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>

<hr>
<h2 id='+24-methods'>Methods for function<code>$</code> in package 'pcts'</h2><span id='topic++24-methods'></span><span id='topic++24+2CPeriodicMTS-method'></span>

<h3>Description</h3>

<p>Methods for function<code>$</code> in package 'pcts'.</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "PeriodicMTS")</code></dt><dd>
</dd>
</dl>

<hr>
<h2 id='allSeasons'>Get names of seasons</h2><span id='topic+allSeasons'></span><span id='topic+allSeasons-methods'></span><span id='topic+allSeasons+2CCyclic+2CANY-method'></span><span id='topic+allSeasons+2CVirtualPeriodicModel+2CANY-method'></span><span id='topic+allSeasons+2CBasicCycle+2CANY-method'></span><span id='topic+allSeasons+2CSimpleCycle+2CANY-method'></span><span id='topic+allSeasons+2COpenCloseCycle+2Clogical-method'></span><span id='topic+allSeasons+2COpenCloseCycle+2Cmissing-method'></span><span id='topic+allSeasons+2CQuarterYearCycle+2Clogical-method'></span><span id='topic+allSeasons+2CQuarterYearCycle+2Cmissing-method'></span><span id='topic+allSeasons+2CDayWeekCycle+2Clogical-method'></span><span id='topic+allSeasons+2CDayWeekCycle+2Cmissing-method'></span><span id='topic+allSeasons+2CMonthYearCycle+2Clogical-method'></span><span id='topic+allSeasons+2CMonthYearCycle+2Cmissing-method'></span><span id='topic+allSeasons+2CEvery30MinutesCycle+2Clogical-method'></span><span id='topic+allSeasons+2CEvery30MinutesCycle+2Cmissing-method'></span><span id='topic+allSeasons+3C-'></span><span id='topic+allSeasons+3C-+2CCyclic-method'></span><span id='topic+allSeasons+3C-+2CSimpleCycle-method'></span><span id='topic+unitSeason'></span><span id='topic+unitCycle'></span><span id='topic+seqSeasons'></span><span id='topic+unitSeason+3C-'></span><span id='topic+unitCycle+3C-'></span>

<h3>Description</h3>

<p>Functions and methods fo get names of seasons and related quantities
for objects from the cycle, periodic time series classes and other
objects for which the concepts are defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitSeason(x)
unitCycle(x)
seqSeasons(x)
allSeasons(x, abb = FALSE, prefix = "S", ...)

unitSeason ( x, ... ) &lt;- value
unitCycle ( x, ... ) &lt;- value
allSeasons ( x, abb, ... ) &lt;- value

## S4 replacement method for signature 'SimpleCycle'
allSeasons(x, abb, prefix, ...) &lt;- value

## S4 replacement method for signature 'Cyclic'
allSeasons(x, abb = FALSE, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allSeasons_+3A_x">x</code></td>
<td>

<p>a cycle, time series or other object for which the concept of
seasons is defined.
</p>
</td></tr>
<tr><td><code id="allSeasons_+3A_abb">abb</code></td>
<td>
<p>if <code>TRUE</code> give the abbreviated names of the seasons.</p>
</td></tr>
<tr><td><code id="allSeasons_+3A_prefix">prefix</code></td>
<td>

<p>use this prefix for automatically generated names of seasons.
</p>
</td></tr>
<tr><td><code id="allSeasons_+3A_...">...</code></td>
<td>
<p>further arguments for methods.</p>
</td></tr>
<tr><td><code id="allSeasons_+3A_value">value</code></td>
<td>
<p>a character string</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cycle classes, i.e. classes inheriting from class
<code><a href="#topic+BasicCycle-class">BasicCycle</a></code>, provide common functionality. In
particular, they guarantee that the functions described in this topic
are available. These functions work also for the periodic time series
classes and may be defined for other classes where they make sense.
</p>


<h3>Methods</h3>

<p>Methods for <code>allSeasons()</code>:
</p>

<dl>
<dt><code>signature(x = "BasicCycle", abb = "ANY")</code></dt><dd>
</dd>
<dt><code>signature(x = "DayWeekCycle", abb = "logical")</code></dt><dd>
</dd>
<dt><code>signature(x = "DayWeekCycle", abb = "missing")</code></dt><dd>
</dd>
<dt><code>signature(x = "MonthYearCycle", abb = "logical")</code></dt><dd>
</dd>
<dt><code>signature(x = "MonthYearCycle", abb = "missing")</code></dt><dd>
</dd>
<dt><code>signature(x = "OpenCloseCycle", abb = "logical")</code></dt><dd>
</dd>
<dt><code>signature(x = "OpenCloseCycle", abb = "missing")</code></dt><dd>
</dd>
<dt><code>signature(x = "QuarterYearCycle", abb = "logical")</code></dt><dd>
</dd>
<dt><code>signature(x = "QuarterYearCycle", abb = "missing")</code></dt><dd>
</dd>
<dt><code>signature(x = "SimpleCycle", abb = "ANY")</code></dt><dd>
</dd>
<dt><code>signature(x = "Cyclic", abb = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "Every30MinutesCycle", abb = "logical")</code></dt><dd>

</dd><dt><code>signature(x = "Every30MinutesCycle", abb = "missing")</code></dt><dd>

</dd><dt><code>signature(x = "VirtualPeriodicModel", abb = "ANY")</code></dt><dd>

</dd></dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>opcycle &lt;- new("OpenCloseCycle")
## convert to SimpleCycle to change some names
siopcycle &lt;- as(opcycle, "SimpleCycle")
## siopcycle inherits names from opcycle
unitSeason(siopcycle)             # "Season"
unitCycle(siopcycle)              # "Cycle"
allSeasons(siopcycle)             # "Open"  "Close"
allSeasons(siopcycle, abb = TRUE) # "O" "C"

allSeasons(siopcycle) &lt;- c("Day", "Night")
allSeasons(siopcycle) # now: "Day"   "Night"
## change also abbreviations
allSeasons(siopcycle, abb = TRUE) &lt;- c("D", "N")
allSeasons(siopcycle, abb = TRUE) # now: "D" "N"

seasons &lt;- new("SimpleCycle", 4)
unitSeason(seasons)             # "Season"
unitCycle(seasons)              # "Cycle"
allSeasons(seasons)
allSeasons(seasons, abb = TRUE) 

unitCycle(seasons) &lt;- "Year"
unitCycle(seasons)
allSeasons(seasons) &lt;- c("Winter", "Spring", "Summer", "Autumn")
allSeasons(seasons)
allSeasons(seasons, abb = TRUE) &lt;- c("Win", "Spr", "Sum", "Aut")
allSeasons(seasons, abb = TRUE)

## change autumn to Fall
allSeasons(seasons)[4] &lt;- "Fall"
allSeasons(seasons, abb = TRUE)[4] &lt;- "Fal"
allSeasons(seasons)
allSeasons(seasons, abb = TRUE)

## indexing of cycle objects is equivalent to allSeasons.
seasons[]
seasons[ , abb = TRUE]

seasons[4] &lt;- "Herbst"
seasons

unitCycle(seasons) &lt;- "Jahre"
unitCycle(seasons)
unitSeason(seasons) &lt;- "Jahreszeit"
seasons[] &lt;- c("Winter", "Frueling", "Sommer", "Herbst")
seasons[ , abb = TRUE] &lt;- c("W", "F", "S", "H")
seasons[]
seasons
</code></pre>

<hr>
<h2 id='as_date-methods'>Replace methods for as_date in package pcts</h2><span id='topic+as_date-methods'></span><span id='topic+as_date+2CPeriodicTimeSeries-method'></span><span id='topic+as_date+2CANY-method'></span><span id='topic+as_date+2Ccharacter-method'></span><span id='topic+as_date+2CCyclic-method'></span><span id='topic+as_date+2Cnumeric-method'></span><span id='topic+as_date+2CPOSIXt-method'></span>

<h3>Description</h3>

<p>Replace methods for as_date in package pcts.</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "PeriodicTimeSeries")</code></dt><dd>
</dd>
<dt><code>signature(x = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "character")</code></dt><dd>

</dd><dt><code>signature(x = "Cyclic")</code></dt><dd>

</dd><dt><code>signature(x = "numeric")</code></dt><dd>

</dd><dt><code>signature(x = "POSIXt")</code></dt><dd>

</dd></dl>

<hr>
<h2 id='as_datetime-methods'>Methods for as_datetime in package pcts</h2><span id='topic+as_datetime-methods'></span><span id='topic+as_datetime+2CPeriodicTimeSeries-method'></span>

<h3>Description</h3>

<p>Methods for as_datetime in package pcts.</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "PeriodicTimeSeries")</code></dt><dd>
</dd>
</dl>

<hr>
<h2 id='autocorrelations-methods'>Compute autocorrelations and periodic autocorrelations</h2><span id='topic+autocorrelations'></span><span id='topic+autocorrelations-methods'></span><span id='topic+autocorrelations+2Cnumeric+2CANY+2Cmissing-method'></span><span id='topic+autocorrelations+2CPeriodicTimeSeries+2CANY+2Cmissing-method'></span><span id='topic+autocorrelations+2CPeriodicAutocovariances+2CANY+2Cmissing-method'></span><span id='topic+autocorrelations+2CSamplePeriodicAutocovariances+2CANY+2Cmissing-method'></span><span id='topic+autocorrelations+2CVirtualPeriodicAutocovariances+2CANY+2Cmissing-method'></span><span id='topic+autocorrelations+2CVirtualPeriodicAutocovarianceModel+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Methods for computation of autocorrelations and periodic
autocorrelations.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "numeric", maxlag = "ANY", lag_0 = "missing")</code></dt><dd>

</dd><dt><code>signature(x = "PeriodicTimeSeries", maxlag = "ANY", lag_0 = "missing")</code></dt><dd>

</dd><dt><code>signature(x = "PeriodicAutocovariances", maxlag = "ANY", 
          lag_0 = "missing")</code></dt><dd>

</dd><dt><code>signature(x = "SamplePeriodicAutocovariances", maxlag = "ANY", 
          lag_0 = "missing")</code></dt><dd>

</dd><dt><code>signature(x = "VirtualPeriodicAutocovariances", maxlag = "ANY", 
          lag_0 = "missing")</code></dt><dd>

</dd><dt><code>signature(x = "VirtualPeriodicAutocovarianceModel", maxlag = "ANY", 
          lag_0 = "missing")</code></dt><dd>

</dd></dl>



<h3>See Also</h3>

<p><code><a href="sarima.html#topic+autocorrelations">autocorrelations</a></code> in package <span class="pkg">sarima</span>
for further details.
</p>
<p><code><a href="#topic+autocovariances">autocovariances</a></code> for autocovariances; 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## periodic ts object =&gt; peridic acf
autocorrelations(pcts(AirPassengers), maxlag = 10)

## for "ts" or "numeric" objects the default is non-periodic acf
autocorrelations(AirPassengers, maxlag = 10) 
autocorrelations(as.numeric(AirPassengers))
## argument 'nseasons' forces periodic acf
autocorrelations(AirPassengers, maxlag = 10, nseasons = 12)
autocorrelations(as.numeric(AirPassengers), maxlag = 10, nseasons = 12)
</code></pre>

<hr>
<h2 id='autocovariances-methods'>Compute autocovariances and periodic autocovariances</h2><span id='topic+autocovariances'></span><span id='topic+autocovariances-methods'></span><span id='topic+autocovariances+2Cmatrix+2CANY-method'></span><span id='topic+autocovariances+2Cnumeric+2CANY-method'></span><span id='topic+autocovariances+2CPeriodicArmaModel+2CANY-method'></span><span id='topic+autocovariances+2CPeriodicArModel+2CANY-method'></span><span id='topic+autocovariances+2Cmatrix-method'></span><span id='topic+autocovariances+2Cnumeric-method'></span><span id='topic+autocovariances+2CPeriodicArmaModel-method'></span><span id='topic+autocovariances+2CPeriodicArModel-method'></span><span id='topic+autocovariances+2CPeriodicTS+2CANY-method'></span><span id='topic+autocovariances+2CVirtualPeriodicAutocovariances+2CANY-method'></span>

<h3>Description</h3>

<p>Methods for the generic function <code>autocovariances()</code>, which
computes autocovariances meaningful for the first argument. For
objects representing time series, it computes sample autocovariances
(univariate, multivariate, periodic, as appropriate). For objects
representing models, it computes the relevant theoretical
autocovariances.
</p>


<h3>Methods</h3>

<dl>
<dt><code>signature(x = "matrix", maxlag = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "numeric", maxlag = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "PeriodicArmaModel", maxlag = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "PeriodicArModel", maxlag = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "PeriodicAutocovarianceModel", maxlag = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "PeriodicTS", maxlag = "ANY")</code></dt><dd>

</dd><dt><code>signature(x = "VirtualPeriodicAutocovariances", maxlag = "ANY")</code></dt><dd>
<p>If <code>maxlag</code> is missing or equal to <code>maxLag(x)</code>, <code>x</code>
is returned unchanged. Otherwise the number of available lags is
adjusted to <code>maxlag</code>.
</p>

</dd></dl>


<h3>See Also</h3>

<p><code><a href="sarima.html#topic+autocovariances">autocovariances</a></code> in package <span class="pkg">sarima</span>
for further details.
</p>
<p><code><a href="#topic+autocorrelations">autocorrelations</a></code> for autocorrelations; 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## periodic ts object =&gt; peridic acvf
autocovariances(pcts(AirPassengers), maxlag = 10)

## for "ts" or "numeric" objects the default is non-periodic acvf
autocovariances(AirPassengers, maxlag = 10) 
autocovariances(as.numeric(AirPassengers))
## argument 'nseasons' forces periodic acvf
autocovariances(AirPassengers, maxlag = 10, nseasons = 12)
autocovariances(as.numeric(AirPassengers), maxlag = 10, nseasons = 12)
</code></pre>

<hr>
<h2 id='availStart'>Time of first or last non-NA value</h2><span id='topic+availStart'></span><span id='topic+availEnd'></span>

<h3>Description</h3>

<p>Time of first or last non-NA value.</p>


<h3>Usage</h3>

<pre><code class='language-R'>availStart(x, any = TRUE)

availEnd(x, any = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="availStart_+3A_x">x</code></td>
<td>
<p>a time series or similar object</p>
</td></tr>
<tr><td><code id="availStart_+3A_any">any</code></td>
<td>

<p>logical flag for multivariate objects. The default <code>TRUE</code>
requests the first/last index containing any non-NA value.
<code>FALSE</code> requires that all values at
the first/last index must be non-NA. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The time is given as a cycle-season pair.
</p>
<p>Argument <code>any</code> is meaningful only for multivariate objects.  Its
name is short for
&quot;the first/last index for which any of the values (ie at least one) is non-<code>NA</code>&quot;.
<code>any = FALSE</code> is taken to mean that the index is the first/last
for which all values are non-<code>NA</code>.
</p>
<p>The functions can be used together with <code>windows</code> to trim
<code>NA</code>'s from the beginning and/or end of the data. As an
alternative we provide also methods for periodic time series methods
for <code>zoo:na.trim</code>, see the examples below.
</p>


<h3>Value</h3>

<p>numeric, length 2
</p>


<h3>See Also</h3>

<p><code><a href="#topic+window">window</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tipi &lt;- pcts(dataFranses1996[ , "USTotalIPI"])
start(tipi)
end(tipi)
head(tipi)
tail(tipi)

tipi &lt;- window(tipi, start = availStart(tipi), end = availEnd(tipi))
start(tipi)
end(tipi)
plot(tipi)

pcfr &lt;- pcts(dataFranses1996)

pcfr2to4 &lt;- pcfr[2:4]
head(pcfr2to4)
tail(pcfr2to4)
## time of first and last data, can be NA's
start(pcfr2to4) # 1955 Q1
end(pcfr2to4)   # 1991 Q4

## time of first nonNA:
availStart(pcfr[[2]]) # 1960 Q1
availStart(pcfr2to4)  # 1960 Q1

## time of last nonNA:
availEnd(pcfr[[2]])   # 1991 Q4
availEnd(pcfr[[3]])   # 1987 Q4
availEnd(pcfr[[4]])   # 1990 Q4
## but at least one of them is  available for 1991 Q4, so:
availEnd(pcfr2to4)   # 1991 Q4
## this requests the time of the last full record:
availEnd(pcfr2to4, any = FALSE)   # 1987 Q4

pcfr2to4a &lt;- window(pcfr2to4, start = availStart(pcfr2to4), end = availEnd(pcfr2to4))
head(pcfr2to4a)
tail(pcfr2to4a, 20)

## trim NA's from both ends, up to the firsxst/last full record:
pcfr2to4b &lt;- window(pcfr2to4, start = availStart(pcfr2to4, FALSE),
                              end = availEnd(pcfr2to4, FALSE))

## TODO: need a better example here since the first non-NA value for all
##     ts in pcfr2to4 is at the same

## alternatively, use na.trim(), the default for is.na is "any"
pcpres &lt;- window(pcts(presidents), end = c(1972, 4))

availStart(pcpres) # 1945 2
availEnd(pcpres)   # 1972 2

both &lt;- na.trim(pcpres) # same as "both"
identical(na.trim(pcpres), both) # TRUE
head(both, 7)
tail(both)
head(na.trim(pcpres, "left"), 7)
tail(na.trim(pcpres, "right"))

cguk &lt;- pcfr[c("CanadaUnemployment", "GermanyGNP", "UKTotalInvestment")]
availStart(cguk)
availStart(cguk, TRUE) # same

availStart(cguk, FALSE)

availEnd(cguk)
availEnd(cguk, TRUE) # same

availEnd(cguk, FALSE)


na.trim(cguk)
head( na.trim(cguk, sides = "left") )
tail( na.trim(cguk, sides = "right") )

head( na.trim(cguk, sides = "left", is.na = "all") )
tail( na.trim(cguk, sides = "right", is.na = "all") )
</code></pre>

<hr>
<h2 id='backwardPartialCoefficients-methods'>
Compute periodic backward partial coefficients
</h2><span id='topic+backwardPartialCoefficients-methods'></span><span id='topic+backwardPartialCoefficients+2CVirtualPeriodicAutocovariances-method'></span>

<h3>Description</h3>

<p>Methods for computation of periodic backward partial coefficients.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "VirtualPeriodicAutocovariances")</code></dt><dd>
</dd>
</dl>

<hr>
<h2 id='backwardPartialVariances-methods'>
Compute periodic backward partial variances
</h2><span id='topic+backwardPartialVariances-methods'></span><span id='topic+backwardPartialVariances+2CVirtualPeriodicAutocovariances-method'></span>

<h3>Description</h3>

<p>Compute periodic backward partial variances.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "VirtualPeriodicAutocovariances")</code></dt><dd>
</dd>
</dl>

<hr>
<h2 id='BareCycle-class'>Class BareCycle</h2><span id='topic+BareCycle-class'></span>

<h3>Description</h3>

<p>Class BareCycle.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>pcCycle(nseasons)</code>
or <code>new("BareCycle", nseasons)</code>.
</p>
<p>Class <code>"BareCycle"</code> represents the number of seasons and is
sufficient for many computations.
</p>


<h3>Slots</h3>


<dl>
<dt><code>nseasons</code>:</dt><dd><p>Object of class <code>"integer"</code>, the number
of seasons.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+BasicCycle-class">BasicCycle</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "BareCycle")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "BareCycle", to = "SimpleCycle")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "BuiltinCycle", to = "BareCycle")</code>: ... </p>
</dd>
<dt>nSeasons</dt><dd><p><code>signature(object = "BareCycle")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "BareCycle")</code>: ... </p>
</dd>


</dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcCycle">pcCycle</a></code> for creation of cycle objects and extraction of
cycle part of time series,
</p>
<p><code><a href="#topic+BuiltinCycle-class">BuiltinCycle-class</a></code>,
<code><a href="#topic+SimpleCycle-class">SimpleCycle-class</a></code>,
</p>
<p><code><a href="#topic+DayWeekCycle-class">DayWeekCycle-class</a></code>,
<code><a href="#topic+MonthYearCycle-class">MonthYearCycle-class</a></code>,
<code><a href="#topic+OpenCloseCycle-class">OpenCloseCycle-class</a></code>,
<code><a href="#topic+QuarterYearCycle-class">QuarterYearCycle-class</a></code>
<code><a href="#topic+PartialCycle-class">PartialCycle-class</a></code>,
</p>
<p><code><a href="#topic+BasicCycle-class">BasicCycle-class</a></code> (virtual, for use in signatures)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pcCycle(5)
cycle &lt;- new("BareCycle", 5)
identical(new("BareCycle", 5), pcCycle(5)) # TRUE

unitSeason(cycle)
unitCycle(cycle)
allSeasons(cycle)
seqSeasons(cycle)

cycle[]
cycle[3]

## if cycle represents 5-days week one may prefer:
BuiltinCycle(5)
</code></pre>

<hr>
<h2 id='BasicCycle-class'>Class BasicCycle</h2><span id='topic+BasicCycle-class'></span>

<h3>Description</h3>

<p>Virtual class <code>"BasicCycle"</code> is a class union that can be used in
signatures of methods and classes when any of the cycle classes is
admissible as argument or slot.
</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.
</p>


<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "BasicCycle", i = "ANY", j = "missing", drop = "ANY")</code> </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "BasicCycle", i = "missing", j = "missing", drop = "ANY")</code> </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "BasicCycle", i = "ANY", j = "missing", value = "ANY")</code> </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "BasicCycle", i = "missing", j = "missing", value = "ANY")</code> </p>
</dd>
<dt>date&lt;-</dt><dd><p><code>signature(x = "BasicCycle")</code>: ... </p>
</dd>
<dt>allSeasons</dt><dd><p><code>signature(x = "BasicCycle", abb = "ANY")</code> </p>
</dd>
<dt>seqSeasons</dt><dd><p><code>signature(x = "BasicCycle")</code> </p>
</dd>
<dt>pcCycle</dt><dd><p><code>signature(x = "BasicCycle", type = "character")</code>: ... </p>
</dd>
<dt>pcCycle</dt><dd><p><code>signature(x = "BasicCycle", type = "missing")</code>: ... </p>
</dd>
<dt>pcts</dt><dd><p><code>signature(x = "matrix", nseasons = "BasicCycle")</code>: ... </p>
</dd>
<dt>pcts</dt><dd><p><code>signature(x = "numeric", nseasons = "BasicCycle")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+BareCycle-class">BareCycle-class</a></code> (just number of seasons),
</p>
<p><code><a href="#topic+SimpleCycle-class">SimpleCycle-class</a></code> (named seasons),
</p>
<p><code><a href="#topic+BuiltinCycle-class">BuiltinCycle-class</a></code> (common cycles, e.g.,
<code><a href="#topic+DayWeekCycle-class">DayWeekCycle-class</a></code>,
<code><a href="#topic+MonthYearCycle-class">MonthYearCycle-class</a></code>,
<code><a href="#topic+OpenCloseCycle-class">OpenCloseCycle-class</a></code>,
<code><a href="#topic+QuarterYearCycle-class">QuarterYearCycle-class</a></code>),
</p>
<p><code><a href="#topic+PartialCycle-class">PartialCycle-class</a></code> (cycles obtained from others by
subsetting or otherwise)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("BasicCycle")
</code></pre>

<hr>
<h2 id='BuiltinCycle-class'>Class <code>"BuiltinCycle"</code> and its subclasses in package 'pcts'</h2><span id='topic+BuiltinCycle-class'></span><span id='topic+allSeasons+2CBuiltinCycle-method'></span><span id='topic+initialize+2CBuiltinCycle-method'></span><span id='topic+unitCycle+2CBuiltinCycle-method'></span><span id='topic+unitSeason+2CBuiltinCycle-method'></span><span id='topic+OpenCloseCycle-class'></span><span id='topic+QuarterYearCycle-class'></span><span id='topic+DayWeekCycle-class'></span><span id='topic+MonthYearCycle-class'></span><span id='topic+Every30MinutesCycle-class'></span>

<h3>Description</h3>

<p>Class <code>"BuiltinCycle"</code> and its subclasses in package 'pcts'.</p>


<h3>Objects from the Class</h3>

<p>Class <code>"BuiltinCycle"</code> is a virtual Class: no objects may be
created from it. Class <code>"BuiltinCycle"</code> has several built-in
cycle subclasses. Objects from the subclasses can be created by calls
of the form <code>new("className", first, ...)</code>, where
<code>"className"</code> is the name of the subclass. The optional argument
<code>first</code> can be used to designate a season to be considered first
in the cycle, by default the first.
</p>
<p>The function <code><a href="#topic+BuiltinCycle">BuiltinCycle</a></code> provides a more convenient way
to generate objects from subclasses of class
<code>"BuiltinCycle"</code>. Its argument is the number of seasons.
</p>
<p>These classes are effectively unmodifiable, but the user can convert
them to other cycle classes, e.g. class &quot;SimpleCycle&quot;, and adapt as
needed.
</p>
<p>The subclasses of <code>"BuiltinCycle"</code> have definitions for all
methods promised by its superclass <code>"BasicCycle"</code>.
</p>
<p>Currently, the following builtin classes are defined:
</p>

<table>
<tr>
 <td style="text-align: left;">
    Name                         </td><td style="text-align: left;"> Description                  </td><td style="text-align: right;"> nSeasons </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"DayWeekCycle"</code>        </td><td style="text-align: left;"> weekdays                     </td><td style="text-align: right;">        7 </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"QuarterYearCycle"</code>    </td><td style="text-align: left;"> quarters in a year           </td><td style="text-align: right;">        4 </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"MonthYearCycle"</code>      </td><td style="text-align: left;"> months in a year             </td><td style="text-align: right;">       12 </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"Every30MinutesCycle"</code> </td><td style="text-align: left;"> half-hour intervals in a day </td><td style="text-align: right;">       48 </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"OpenCloseCycle"</code>      </td><td style="text-align: left;"> start/end of a working day   </td><td style="text-align: right;">        2
  </td>
</tr>

</table>
		     
<p>There is also a class <code>"FiveDayWeekCycle"</code> but it is deprecated
and will be removed in the near future. Use <code><a href="#topic+BuiltinCycle">BuiltinCycle</a>(5)</code>
to create objects with equivalent functionality.
</p>


<h3>Slots</h3>

<p>The class <code>"BuiltinCycle"</code> and its subclasses have a single
common slot:
</p>

<dl>
<dt><code>first</code>:</dt><dd><p>Object of class <code>"integer"</code>,
the index of the season to be treated as the first in a cycle.
</p>
</dd>
</dl>


<h3>Extends</h3>

<p>Class <code>"BuiltinCycle"</code> extends class
<code>"<a href="#topic+BasicCycle-class">BasicCycle</a>"</code>, directly.
</p>
<p>Classes <code>"DayWeekCycle"</code>, <code>"Every30MinutesCycle"</code>,
<code>"FiveDayWeekCycle"</code>, <code>"OpenCloseCycle"</code> and
<code>"QuarterYearCycle"</code> 
extend:
</p>
<p>Class <code>"<a href="#topic+BuiltinCycle-class">BuiltinCycle</a>"</code>, directly.
Class <code>"<a href="#topic+BasicCycle-class">BasicCycle</a>"</code>, by class &quot;BuiltinCycle&quot;, distance 2.
</p>


<h3>Methods</h3>

<p>Functions with methods for this class:
</p>

<dl>
<dt>coerce</dt><dd><p><code>signature(from = "BuiltinCycle", to = "BareCycle")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "BuiltinCycle", to = "SimpleCycle")</code>: ... </p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "BuiltinCycle")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "BuiltinCycle")</code>: ... </p>
</dd>
</dl>

<p>The functions to extract properties from objects from the builtin
cycle classes have identical signatures (except for the name of the
class). For example, for <code>"QuarterYearCycle"</code> the methods are as
follows:
</p>

<dl>
<dt>allSeasons</dt><dd><p><code>signature(x = "QuarterYearCycle", abb = "logical")</code>: ... </p>
</dd>
<dt>allSeasons</dt><dd><p><code>signature(x = "QuarterYearCycle", abb = "missing")</code>: ... </p>
</dd>
<dt>nSeasons</dt><dd><p><code>signature(object = "QuarterYearCycle")</code>: ... </p>
</dd>
<dt>unitCycle</dt><dd><p><code>signature(x = "QuarterYearCycle")</code>: ... </p>
</dd>
<dt>unitSeason</dt><dd><p><code>signature(x = "QuarterYearCycle")</code>: ... </p>
</dd>
</dl>

<p>The methods for the remaining builtin classes are the same with
<code>"QuarterYearCycle"</code> replaced suitably.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+BuiltinCycle">BuiltinCycle</a></code>,
<code><a href="#topic+pcCycle">pcCycle</a></code> for creation of cycle objects and extraction of
cycle part of time series,
</p>
<p>class <code><a href="#topic+PartialCycle-class">PartialCycle</a></code> for creating variants of the
builtin classes, e.g., 5-day weeks.
</p>
<p><code><a href="#topic+BareCycle-class">BareCycle-class</a></code>,
<code><a href="#topic+SimpleCycle-class">SimpleCycle-class</a></code>,
</p>



<h3>Examples</h3>

<pre><code class='language-R'>## class "DayWeekCycle"
dwcycle &lt;- BuiltinCycle(7) # new("DayWeekCycle")

unitSeason(dwcycle)
unitCycle(dwcycle)

allSeasons(dwcycle)
dwcycle[] # same

allSeasons(dwcycle, abb = TRUE)
dwcycle[ , abb = TRUE] # same

dwcycle[2]
dwcycle[2, abb = TRUE]

seqSeasons(dwcycle)

## start the week on Sunday
dws &lt;- BuiltinCycle(7, first = 7) # new("DayWeekCycle", first = 7)
dws[1] # "Sunday"
allSeasons(dws)

## class "Every30MinutesCycle"
cyc48 &lt;- BuiltinCycle(48) # new("Every30MinutesCycle")
nSeasons(cyc48)
allSeasons(cyc48)

## class "FiveDayWeekCycle" is deprecated, use the equivalent:
fdcycle &lt;- BuiltinCycle(5)

unitSeason(fdcycle)
unitCycle(fdcycle)

allSeasons(fdcycle)
fdcycle[] # same

allSeasons(fdcycle, abb = TRUE)
fdcycle[ , abb = TRUE] # same

fdcycle[2]
fdcycle[2, abb = TRUE]

seqSeasons(fdcycle)

## class "MonthYearCycle"
mycycle &lt;- BuiltinCycle(12) # new("MonthYearCycle")

unitSeason(mycycle)
unitCycle(mycycle)

allSeasons(mycycle)
mycycle[ ] # same

allSeasons(mycycle, , abb = TRUE)
mycycle[ , abb = TRUE] # same

mycycle[2]
mycycle[2, abb = TRUE]

seqSeasons(mycycle)

## class "OpenCloseCycle"
opcycle &lt;- new("OpenCloseCycle")

unitSeason(opcycle)
unitCycle(opcycle)

allSeasons(opcycle)
opcycle[ , abb = FALSE] # same

allSeasons(opcycle, abb = FALSE)
opcycle[] # same

opcycle[2]
opcycle[2, abb = TRUE]

seqSeasons(opcycle)

## class "QuarterYearCycle"
qycycle &lt;- new("QuarterYearCycle")

unitSeason(qycycle)
unitCycle(qycycle)

allSeasons(qycycle)
qycycle[] # same

allSeasons(qycycle, abb = TRUE)
qycycle[ , abb = TRUE] # same

qycycle[2]
qycycle[2, abb = TRUE]

seqSeasons(qycycle)
</code></pre>

<hr>
<h2 id='Cyclic'>Create objects from class Cyclic</h2><span id='topic+Cyclic'></span><span id='topic+date+3C-'></span><span id='topic+as.Date.Cyclic'></span><span id='topic+date.Cyclic'></span><span id='topic+as.Date.PeriodicTimeSeries'></span>

<h3>Description</h3>

<p>Create objects from class Cyclic.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cyclic(cycle, start = NULL, ...)

## S3 method for class 'Cyclic'
as.Date(x, ...)

## S3 method for class 'Cyclic'
date(x)

## S3 method for class 'PeriodicTimeSeries'
as.Date(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Cyclic_+3A_cycle">cycle</code></td>
<td>

<p>a cycle object, a positive integer giving the number of seasons, or
any other object that can be used to create a cycle with
<code>pcCycle(x, ...)</code>.
</p>
</td></tr>
<tr><td><code id="Cyclic_+3A_start">start</code></td>
<td>

<p>a cycle-season pair, a datetime object, a Date object or any object
that can be converted to datetime with <code>as_datetime(start)</code>.
</p>
</td></tr>
<tr><td><code id="Cyclic_+3A_...">...</code></td>
<td>

<p>for <code>Cyclic</code>, arguments passed to <code>pcCycle</code>, used only if
<code>cycle</code> is not from a cycle class. 
</p>
</td></tr>
<tr><td><code id="Cyclic_+3A_x">x</code></td>
<td>
<p>a Cyclic object</p>
</td></tr>

</table>


<h3>Value</h3>

<p>for <code>Cyclic</code>, an object from class <code>"Cyclic"</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BuiltinCycle">BuiltinCycle</a></code>, <code><a href="#topic+pcCycle">pcCycle</a></code> for creation of cycle objects,
</p>
<p><code><a href="#topic+pcts">pcts</a></code> importing and creating periodic time series
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## bare bone Cyclic starting at Cycle 1, season 1
Cyclic(4)    
Cyclic(4, c(1,1)) # same

## with quarter/year cycle
qu &lt;- Cyclic(BuiltinCycle(4), start = c(2020, 1))
start(qu)
as_datetime(qu)

date(qu) &lt;- c(2009, 2)
qu

ap &lt;- pcts(AirPassengers)
as.Date(ap)
</code></pre>

<hr>
<h2 id='Cyclic-class'>Class <code>"Cyclic"</code></h2><span id='topic+Cyclic-class'></span>

<h3>Description</h3>

<p>Class <code>"Cyclic"</code></p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("Cyclic", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>cycle</code>:</dt><dd><p>Object of class <code>"BasicCycle"</code> ~~ </p>
</dd>
<dt><code>pcstart</code>:</dt><dd><p>Object of class <code>"ANY"</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>




<dl>
<dt>allSeasons</dt><dd><p><code>signature(x = "Cyclic", abb = "ANY")</code>: ... </p>
</dd>
<dt>allSeasons&lt;-</dt><dd><p><code>signature(x = "Cyclic")</code>: ... </p>
</dd>
<dt>as_date</dt><dd><p><code>signature(x = "Cyclic")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "PeriodicMTS", to = "Cyclic")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "PeriodicTS", to = "Cyclic")</code>: ... </p>
</dd>
<dt>coerce&lt;-</dt><dd><p><code>signature(from = "PeriodicMTS", to = "Cyclic")</code>: ... </p>
</dd>
<dt>coerce&lt;-</dt><dd><p><code>signature(from = "PeriodicTS", to = "Cyclic")</code>: ... </p>
</dd>
<dt>date&lt;-</dt><dd><p><code>signature(x = "Cyclic")</code>: ... </p>
</dd>
<dt>nSeasons</dt><dd><p><code>signature(object = "Cyclic")</code>: ... </p>
</dd>
<dt>nTicks</dt><dd><p><code>signature(x = "Cyclic")</code>: ... </p>
</dd>
<dt>pcCycle</dt><dd><p><code>signature(x = "Cyclic", type = "ANY")</code>: ... </p>
</dd>
<dt>seqSeasons</dt><dd><p><code>signature(x = "Cyclic")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "Cyclic")</code>: ... </p>
</dd>
<dt>unitCycle</dt><dd><p><code>signature(x = "Cyclic")</code>: ... </p>
</dd>
<dt>unitCycle&lt;-</dt><dd><p><code>signature(x = "Cyclic")</code>: ... </p>
</dd>
<dt>unitSeason</dt><dd><p><code>signature(x = "Cyclic")</code>: ... </p>
</dd>
<dt>unitSeason&lt;-</dt><dd><p><code>signature(x = "Cyclic")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+Pctime">Pctime</a></code> for conversion from/to dates and datetimes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("Cyclic")
</code></pre>

<hr>
<h2 id='dataFranses1996'>Example data from Franses (1996)</h2><span id='topic+dataFranses1996'></span>

<h3>Description</h3>

<p>A multivariate time series containing the data used
in examples by Franses (1996).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dataFranses1996")</code></pre>


<h3>Format</h3>

<p>A multivariate quarterly time series.
</p>


<h3>Details</h3>

<p>Each column is a quarterly time series. The time series start and end
at different times, so <code>NA</code>'s are used to align them in a single
multivariate time series. Detailed account of the sources of the data
is given by
@FransesB1; Data Appendix), p. 214.
</p>

<dl>
<dt><code>year</code></dt><dd><p>(column 1)
</p>
<p>The time formatted as <code style="white-space: pre;">&#8288;yyyy.Q&#8288;</code>, where <code style="white-space: pre;">&#8288;yyyy&#8288;</code> is the year
and <code style="white-space: pre;">&#8288;Q&#8288;</code> is the quarter (one of 1, 2, 3 or 4.). This column
was part of the original data but is not really needed here since
the time series object contains the time information.
</p>
</dd>
<dt><code>USTotalIPI</code></dt><dd><p> (column 2)
</p>
<p>Total Industrial Production Index for the United States (1985 =
100), 1960.1&ndash;1991.4.


</p>
</dd>
<dt><code>CanadaUnemployment</code></dt><dd><p> (column 3)
</p>
<p>Unemployment in Canada, measured in 1000 persons, 1960.1 - 1987.4.

</p>
</dd>
<dt><code>GermanyGNP</code></dt><dd><p> (column 4)
</p>
<p>Real GNP in Germany, 1960.1 - 1990.4 .

</p>
</dd>
<dt><code>UKTotalInvestment</code></dt><dd><p> (column 5)
</p>
<p>Real Total Investment in the United Kindom, 1955.1 - 1988.4.

</p>
</dd>
<dt><code>SA_USTotalIPI</code></dt><dd><p> (column 6)
Seasonally adjusted <code>USTotalIPI</code>.
</p>
</dd>
<dt><code>SA_CanadaUnemployment</code></dt><dd><p> (column 7)
</p>
<p>Seasonally adjusted <code>CanadaUnemployment</code>.
</p>
</dd>
<dt><code>SA_GermanyGNP</code></dt><dd><p> (column 8)
</p>
<p>Seasonally adjusted <code>GermanyGNP</code>.
</p>
</dd>
<dt><code>UKGDP</code></dt><dd><p> (column 9)
</p>
<p>United Kingdom gross domestic product (at 1985 prices),
1955.1&ndash;1988.4. 

</p>
</dd>
<dt><code>UKTotalConsumption</code></dt><dd><p> (column 10)
</p>
<p>United Kingdom total consumption (at 1985 prices),
1955.1&ndash;1988.4. 

</p>
</dd>
<dt><code>UKNondurablesConsumption</code></dt><dd><p> (column 11)
</p>
<p>United Kindom nondurables consumption (at 1985 prices), 1955.1&ndash;1988.4.

</p>
</dd>
<dt><code>UKExport</code></dt><dd><p> (column 12)
</p>
<p>United Kindom exports of goods and services (at 1985 prices),
1955.1&ndash;1988.4.

</p>
</dd>
<dt><code>UKImport</code></dt><dd><p> (column 13)
</p>
<p>United Kindom imports of goods and services (at 1985 prices),
1955.1&ndash;1988.4.

</p>
</dd>
<dt><code>UKPublicInvestment</code></dt><dd><p> (column 14)
</p>
<p>United Kindom public investment (at 1985 prices), 1962.1&ndash;1988.4.

</p>
</dd>
<dt><code>UKWorkforce</code></dt><dd><p> (column 15)
</p>
<p>United Kindom workforce (consisting of workforce in employment and
unemployment), 1955.1&ndash;1988.4.

</p>
</dd>
<dt><code>SwedenNondurablesConsumption</code></dt><dd><p> (column 16)
</p>
<p>Real per capita non-durables consumption in Sweden (measured in
logs), 1963.1&ndash;1988.1.

</p>
</dd>
<dt><code>SwedenDisposableIncome</code></dt><dd><p> (column 17)
</p>
<p>Real per capita disposable income in Sweden (measured in logs),
1963.1&ndash;1988.1.

</p>
</dd>
<dt><code>SA_SwedenNondurablesConsumption</code></dt><dd><p> (column 18)
</p>
<p>Seasonally adjusted <code>SwedenNondurablesConsumption</code> with
Census X-11 method, 1964.1&ndash;1988.1.  (Using the approximate linear
Census X-11 filter given in Table 4.1, p. 52 in
Franses (1996) and generating the forecasts
and backcasts as described in Ooms (1994)).
</p>
</dd>
<dt><code>SA_SwedenDisposableIncome</code></dt><dd><p> (column 19)
</p>
<p>Seasonally adjusted <code>SwedenDisposableIncome</code> with Census X-11
method, 1964.1&ndash;1988.1. (Using the same method as above.)
</p>
</dd>
</dl>

<p>More details on the individual time series are given by
Franses (1996). 
</p>


<h3>Note</h3>

<p>Most of the time series in <code>dataFranses1996</code> are available as
separate datasets in package &lsquo;partsm&rsquo;. The numbers should be the same
but note that, at the time of writing this, not all datasets there
carry complete time information.
</p>


<h3>Source</h3>

<p>The data were downloaded from 
<code style="white-space: pre;">&#8288;http://people.few.eur.nl/franses/research/data/data1.txt&#8288;</code>,
but this link is now broken.
</p>


<h3>References</h3>

<p>Franses PH (1996).
<em>Periodicity and Stochastic Trends In Economic Time Series</em>.
Oxford University Press Inc., New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fraser2017">Fraser2017</a></code>,
<code><a href="#topic+four_stocks_since2016_01_01">four_stocks_since2016_01_01</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataFranses1996)
class(dataFranses1996)
colnames(dataFranses1996)
dim(dataFranses1996) # c(148, 19)
plot(dataFranses1996[ , 2:11])

tipi &lt;- dataFranses1996[ , "USTotalIPI"]
plot(tipi)
## convert to PeriodicTS and remove NA's at the start and end
pctipi &lt;- pcts(tipi)
pctipi &lt;- window(pctipi, start = availStart(pctipi), end = availEnd(pctipi))
plot(pctipi)

## convert  the whole dataset to class "PeriodicMTS"
pcfr &lt;- pcts(dataFranses1996)

colnames(pcfr)[2:3] #  "USTotalIPI" "CanadaUnemployment"

## subset as "PeriodicMTS"
pcfr2to3 &lt;- pcfr[2:3]
plot(pcfr2to3)
## "[" "PeriodicMTS" even with length one arg.
pcfr2to2  &lt;- pcfr[2]
pcfr2to2a &lt;- pcfr["USTotalIPI"] # same

## use "[[" or $ to get "PeriodicTS"
pcfr2 &lt;- pcfr[[2]]
pcfr2a &lt;- pcfr[["USTotalIPI"]] # same
pcfr2b &lt;- pcfr$USTotalIPI      # same
identical(pcfr2, pcfr2a) # TRUE
identical(pcfr2, pcfr2b) # TRUE

cycle(pcfr)
frequency(pcfr)
</code></pre>

<hr>
<h2 id='date+26lt+3B+26ndash+3Bmethods'>Replace methods for date in package pcts</h2><span id='topic+date+3C--methods'></span><span id='topic+date+3C-+2CBasicCycle-method'></span><span id='topic+date+3C-+2CCyclic-method'></span>

<h3>Description</h3>

<p>Replace methods for date in package pcts.</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "BasicCycle")</code></dt><dd>
</dd>
<dt><code>signature(x = "Cyclic")</code></dt><dd>
</dd>
</dl>

<hr>
<h2 id='ex1f'>An example PAR autocorrelation function</h2><span id='topic+ex1f'></span>

<h3>Description</h3>

<p><code>ex1</code> is the autocorrelation function used in the reference as an
example when the solution of the periodic Yule-Walker system gives an
invalid PAR model.  This can happen only if Lambert-Lacroix's
condition on the PAR order is not satisfied, see <code>pdSafeParOrder</code>.
</p>


<h3>Format</h3>

<p>A function of two arguments</p>


<h3>Source</h3>

<p>See pp. 429&ndash;430 of the reference.</p>


<h3>References</h3>


<p>Lambert-Lacroix S (2005).
&ldquo; Extension of autocovariance coefficients sequence for periodically correlated
processes.&rdquo;
<em>Journal of Time Series Analysis</em>, <b>26</b>(6), pp. 423-435.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+pdSafeParOrder">pdSafeParOrder</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex1f)
## compute the first few autocorrelations
pc3 &lt;- slMatrix(period = 2, maxlag = 5, f = ex1f, type = "tt")
## Fir a PAR(0,2) model
res0p2 &lt;- alg1(pc3[],c(0,2))
## model is invalid since a partial autocorrelation is larger than one:
res0p2$be
## Find a modified order:
pdSafeParOrder(c(0,2)) # PAR(1,2)
## now the parcor's are fine:
res1p2 &lt;- alg1(pc3[],c(1,2))
res1p2$be
</code></pre>

<hr>
<h2 id='filterCoef-methods'>Get the coefficients of a periodic filter</h2><span id='topic+filterCoef-methods'></span><span id='topic+filterCoef+2CPeriodicBJFilter+2Ccharacter-method'></span><span id='topic+filterCoef+2CPeriodicSPFilter+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Get the coefficients of a periodic filter.</p>


<h3>Details</h3>

<p><code>filterCoef</code> is a generic function to extract the coefficients of
periodic filters. Argument <code>convention</code> can be used to force a
particular convention for the signs. The description here is for the
methods defined in this package.
</p>
<p>If <code>convention</code> is missing, the coefficient matrix is returned as
stored in the object. Otherwise, if <code>convention</code> is one of the
strings <code>"BJ"</code>, <code>"--"</code> or <code>"-"</code>, the coefficients
returned have the opposite sign of those in the auxilliary polynomial
(Box-Jenkins' convention). If <code>convention</code> is one of <code>"SP"</code>,
<code>"++"</code> or <code>"+"</code>, the coefficients are as in the auxilliary
polynomial (convention used in signal processing).
</p>


<h3>Value</h3>

<p>a matrix
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "PeriodicBJFilter", convention = "character")</code></dt><dd>

</dd><dt><code>signature(object = "PeriodicSPFilter", convention = "character")</code></dt><dd>

</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="sarima.html#topic+filterCoef">filterCoef</a></code> for further details;
</p>
<p><code><a href="#topic+PeriodicBJFilter-class">PeriodicBJFilter</a></code> for examples
</p>

<hr>
<h2 id='filterPoly-methods'>~~ Dummy title ~~</h2><span id='topic+filterPoly-methods'></span><span id='topic+filterPoly+2CPeriodicBJFilter-method'></span><span id='topic+filterPoly+2CPeriodicSPFilter-method'></span>

<h3>Description</h3>

<p>~~ Dummy description ~~</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "PeriodicBJFilter")</code></dt><dd>
</dd>
<dt><code>signature(object = "PeriodicSPFilter")</code></dt><dd>
</dd>
</dl>

<hr>
<h2 id='filterPolyCoef-methods'>~~ Dummy title ~~</h2><span id='topic+filterPolyCoef-methods'></span><span id='topic+filterPolyCoef+2CPeriodicBJFilter-method'></span><span id='topic+filterPolyCoef+2CPeriodicSPFilter-method'></span>

<h3>Description</h3>

<p>~~ Dummy description ~~</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "PeriodicBJFilter")</code></dt><dd>
</dd>
<dt><code>signature(object = "PeriodicSPFilter")</code></dt><dd>
</dd>
</dl>

<hr>
<h2 id='fit_trigPAR_optim'>Fit a subset trigonometric PAR model</h2><span id='topic+fit_trigPAR_optim'></span>

<h3>Description</h3>

<p>Fit a subset PAR model with trigonometric parameterisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_trigPAR_optim(x, order, nseasons, seasonof1st = 1, maxiter = 200, 
                  harmonics = NULL, sintercept = FALSE, tol = 1e-07, 
                  type = c("vecbyrow", "bylag"), verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_trigPAR_optim_+3A_x">x</code></td>
<td>
<p>time series.</p>
</td></tr>
<tr><td><code id="fit_trigPAR_optim_+3A_order">order</code></td>
<td>
<p>order, an integer number.</p>
</td></tr>
<tr><td><code id="fit_trigPAR_optim_+3A_nseasons">nseasons</code></td>
<td>
<p>number of seasons, an integer number.</p>
</td></tr>
<tr><td><code id="fit_trigPAR_optim_+3A_seasonof1st">seasonof1st</code></td>
<td>
<p>season of the first observation.</p>
</td></tr>
<tr><td><code id="fit_trigPAR_optim_+3A_maxiter">maxiter</code></td>
<td>
<p>max number of iterations.</p>
</td></tr>
<tr><td><code id="fit_trigPAR_optim_+3A_harmonics">harmonics</code></td>
<td>

<p>the harmonics to include in the model, vector of non-negative
integers.
</p>
</td></tr>
<tr><td><code id="fit_trigPAR_optim_+3A_sintercept">sintercept</code></td>
<td>
<p>if <code>TRUE</code> include seasonal intercept.</p>
</td></tr>
<tr><td><code id="fit_trigPAR_optim_+3A_tol">tol</code></td>
<td>
<p>when to stop the iterations.</p>
</td></tr>
<tr><td><code id="fit_trigPAR_optim_+3A_type">type</code></td>
<td>

<p>type of parameterisation, currently one of <code>"vecbyrow"</code> or
<code>"bylag"</code>.
</p>
</td></tr>
<tr><td><code id="fit_trigPAR_optim_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> print more details during estimation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fits a subset PAR model using trigonometric parameterisation,
i.e. Fourier series for the periodic coefficients written in terms of
sines and cosines.
</p>
<p>If argument <code>type</code> is <code>bylag</code>, the parameters for each lag
are parameterised independently from other lags. If <code>sintercept</code>
is <code>TRUE</code>, it has its own trigonometric representation.
</p>
<p>If argument <code>type</code> is <code>vecbyrow</code> (&ldquo;Vec operation by
row&rdquo;), the PAR  parameters are stacked in a vector with all parameters
for the first season, followed by all parameters for the second, and
so on. The trigonometric parameterisation for this vector is used.
So the fundamental frequency is <code>1/(nseasons * order)</code>.
If <code>sintercept</code> is <code>TRUE</code> when <code>type = vecbyrow</code>, then
then the intercept for eaach season is put before the PAR parameters
and the fundamental frequency becomes <code>1/(nseasons * (order + 1)</code>. 
Putting together the intercepts and the PAR parameters may not be very
useful for parsimonious trigonometric parameterisation, so to have a
separate set of coefficients for the intercepts set
attribute <code>"merge"</code> of <code>sintercept</code> to <code>FALSE</code>.
</p>


<h3>Value</h3>

<p>an object from class <code><a href="#topic+SubsetPM-class">SubsetPM</a></code>
</p>


<h3>Note</h3>

<p>This function may change.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples for class "SubsetPM"
</code></pre>

<hr>
<h2 id='fitPM'>Fit periodic time series models</h2><span id='topic+fitPM'></span><span id='topic+fitPM-methods'></span><span id='topic+fitPM+2CANY+2CANY-method'></span><span id='topic+fitPM+2CmcSpec+2CANY-method'></span><span id='topic+fitPM+2Cnumeric+2CANY-method'></span><span id='topic+fitPM+2CPeriodicArModel+2CANY-method'></span><span id='topic+fitPM+2CPeriodicArModel+2CPeriodicMTS-method'></span><span id='topic+fitPM+2CPeriodicArModel+2CPeriodicTS-method'></span><span id='topic+fitPM+2CPiPeriodicArModel+2CANY-method'></span><span id='topic+fitPM+2CSiPeriodicArModel+2CANY-method'></span>

<h3>Description</h3>

<p>Generic function with methods for fitting periodic time series models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitPM( model, x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitPM_+3A_x">x</code></td>
<td>
<p>the time series.</p>
</td></tr>
<tr><td><code id="fitPM_+3A_model">model</code></td>
<td>
<p>a periodic model, see Details.</p>
</td></tr>
<tr><td><code id="fitPM_+3A_...">...</code></td>
<td>
<p>further arguments to be passed on to individual methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic function.
</p>
<p><code>model</code> provides the specification of the model. In particular,
the class of <code>model</code> determines what model is fitted.  Specific
values of the parameters are generally ignored by non-iterative
methods but some methods can handle more detailed specifications, see
the individual methods.
</p>


<h3>Value</h3>

<p>the fitted model,
typically an object of class <code>class(model)</code>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(model = "ANY", x = "ANY")</code></dt><dd>
<p>This is the default method. It simply exits with an error message
stating that <code>fitPM</code> does not have a method for the model
specified by <code>model</code>.
</p>
</dd>
<dt><code>signature(model = "numeric", x = "ANY")</code></dt><dd>
<p>Fits a PAR model to <code>x</code>. <code>model</code> should be a vector of
non-negative integers giving the PAR order. The length of this vector
is taken to be the number of seasons.
</p>
<p>This is a convenience method. It constructs a PAR model and callls the
method for <code>model = "PeriodicArModel"</code>.
</p>
</dd>
<dt><code>signature(model = "PeriodicArModel", x = "ANY")</code></dt><dd>
<p>Fits a PAR model.
</p>
</dd>
<dt><code>signature(model = "mcSpec", x = "ANY")</code></dt><dd>
<p>Fits a periodic model according to the specification given by
<code>model</code>.
</p>
<p>Currently this method uses <code><a href="#topic+mC.ss">mC.ss</a></code> to set up the
optimisation environment and then calls one of the optimisation
functions in that environment as specified by argument
<code>optim.method</code>, see below.
</p>
<p>Additional arguments may be specified to control the optimisation.
</p>
<p>Argument <code>init</code> can be used to give initial values. It is
passed on to <code>mC.ss</code> (and so has the format required by it).
</p>
<p><code>optim.method</code> is the name of an optimisation function in the
environment returned by <code>mC.ss</code>. The default is
<code>optim.method = "minim"</code>, which is based on the standard <span class="rlang"><b>R</b></span> function
<code>optim</code>.  Alternatives are &quot;minimBB&quot; or &quot;minimBBLU&quot;. All this
needs to be documented but see <code>mC.ss</code> and <code>xx.ss</code> for
details.
</p>
<p>Further arguments are passed on to the optimisation method. A
typical argument supported by most optimisation functions is
<code>control</code>.
</p>
</dd>
<dt><code>signature(model = "PiPeriodicArModel", x = "ANY")</code></dt><dd>
<p>Fits a periodically integrated PAR model using the parameters of
<code>model</code> as initial values. Calls <code><a href="#topic+pclspiar">pclspiar</a></code> to do the
actual work.

</p>
</dd><dt><code>signature(model = "SiPeriodicArModel", x = "ANY")</code></dt><dd>
<p>Fits a seasonally integrated PAR model.
</p>

</dd>
<dt><code>signature(model = "PeriodicArModel", x = "PeriodicMTS")</code></dt><dd>

</dd><dt><code>signature(model = "PeriodicArModel", x = "PeriodicTS")</code></dt><dd>

</dd></dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p> (todo: to be completed properly later)
</p>
<p>Hipel KW, McLeod AI (1994).
<em>Time series modelling of water resources and environmental systems</em>,  Developments in water science; 45.
London; Amsterdam: Elsevier.
</p>
<p>Boshnakov GN, Iqelan BM (2009).
&ldquo;Generation of time series models with given spectral properties.&rdquo;
<em>J. Time Series Anal.</em>, <b>30</b>(3), 349&ndash;368.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.2009.00617.x">doi:10.1111/j.1467-9892.2009.00617.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## newm1 &lt;- list(phi = matrix(1:12, nrow=4), p=rep(3,4), period=4, si2 = rep(1,4))
## new_pfm1 &lt;- PeriodicFilterModel(newm1, intercept=0)

## generate some data;
set.seed(1234)
simts1 &lt;- pcts(rnorm(1024), nseasons = 4)

fitPM(c(3,3,3,3), simts1)
fitPM(3, simts1)
## the fit on the underlying data is equivalent.
fitPM(c(3,3,3,3), as.numeric(simts1))

## equivalently, use a PAR(3,3,3,3) model for argument 'model'
## here the coefficients of pfm1 are ignored, since the estimation is linear.
pfm1 &lt;- PeriodicArModel(matrix(1:12, nrow = 4), order = rep(3,4), sigma2 = 1)
pfm1
## these give same results as above
fitPM(pfm1, simts1)
fitPM(pfm1, as.numeric(simts1))

fitPM(c(1,1,1,1), simts1)
fitPM(c(3,2,2,1), simts1)
fitPM(c(3,2,2,2), simts1)

pdSafeParOrder(c(3,2,2,1))
pdSafeParOrder(rev(c(3,2,2,1)))

x &lt;- arima.sim(list(ar = 0.9), n = 960)
pcx &lt;- pcts(x, nseasons = 4)
mx &lt;- matrix(x, nrow = 4)

##pc.acf(mx)
##pc.acf(mx, maxlag=10)
## TODO: avoid the warning when length ot the time series is not multiple
autocovariances(t(mx), maxlag = 6, nseasons = 4)
autocovariances(t(mx))

##It is an error to have more columns than rows.
## autocovariances(mx, maxlag = 6, nseasons = 4)
## autocovariances(mx)

num2pcpar(mx, c(1,1,1,1), period = 4)
num2pcpar(mx, c(3,3,3,3), period = 4)

sipfm1 &lt;- new("SiPeriodicArModel", iorder = 1, siorder = 1, pcmodel = pfm1)
sipfm1
fitPM(sipfm1, mx)
pfm1


## experiments and testing
fit1    &lt;- fitPM(c(3,3,3,3), simts1)
fit1_mf &lt;- new("MultiFilter", coef = fit1@ar@coef)
vs      &lt;- mcompanion::mf_VSform(fit1_mf, form = "I")
tmp &lt;- mcompanion::VAR2pcfilter(vs$Phi[ , -4],
                                Phi0inv = vs$Phi0inv, D = fit1@sigma2, what = "")
names(tmp) #  "pcfilter" "var"      "Uform"   
tmp$var
zapsmall(tmp$pcfilter)
fit1@ar@coef
all.equal(tmp$pcfilter[ , 1:3], fit1@ar@coef, check.attributes = FALSE) # TRUE
tmp$Uform
fit1@sigma2

## both give the matrix Sigma for the "I" form
identical(
    vs$Phi0inv %*% diag(fit1@sigma2) %*% t(vs$Phi0inv)
    ,
    tmp$Uform$U0inv %*% diag(tmp$Uform$Sigma)  %*% t(tmp$Uform$U0inv)
) # TRUE

## no, this is a different matrix
var1_mat &lt;- cbind(vs$Phi0, # identity matrix
                  - vs$Phi) # drop trailing zero columns?
var1_mat &lt;- mcompanion::mCompanion(var1_mat)
var1_Sigma &lt;- vs$Phi0inv %*% diag(fit1@sigma2) %*% t(vs$Phi0inv)
abs(eigen(diag(nrow(var1_mat)) - var1_mat)$values)
</code></pre>

<hr>
<h2 id='FittedPeriodicArmaModel-class'>Class FittedPeriodicArmaModel</h2><span id='topic+FittedPeriodicArmaModel-class'></span><span id='topic+as_pcarma_list+2CFittedPeriodicArmaModel-method'></span><span id='topic+show+2CFittedPeriodicArmaModel-method'></span>

<h3>Description</h3>

<p>Class FittedPeriodicArmaModel in package pcts</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("FittedPeriodicArmaModel", ..., mean)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ar</code>:</dt><dd><p>Object of class <code>"PeriodicBJFilter"</code> ~~ </p>
</dd>
<dt><code>ma</code>:</dt><dd><p>Object of class <code>"PeriodicSPFilter"</code> ~~ </p>
</dd>
<dt><code>modelCycle</code>:</dt><dd><p>Object of class <code>"BasicCycle"</code> ~~ </p>
</dd>
<dt><code>center</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>intercept</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>sigma2</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>theTS</code>:</dt><dd><p>Object of class <code>"PeriodicTS"</code> ~~ </p>
</dd>
<dt><code>asyCov</code>:</dt><dd><p>Object of class <code>"ANY"</code> ~~ </p>
</dd>
<dt><code>ns</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+PeriodicArmaModel-class">PeriodicArmaModel</a>"</code>, directly.
Class <code>"FittedPM"</code>, directly.
Class <code>"<a href="#topic+VirtualPeriodicArmaModel-class">VirtualPeriodicArmaModel</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 2.
Class <code>"<a href="#topic+PeriodicArmaSpec-class">PeriodicArmaSpec</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 2.
Class <code>"<a href="#topic+VirtualPeriodicFilterModel-class">VirtualPeriodicFilterModel</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 3.
Class <code>"<a href="#topic+VirtualPeriodicStationaryModel-class">VirtualPeriodicStationaryModel</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 3.
Class <code>"<a href="#topic+PeriodicArmaFilter-class">PeriodicArmaFilter</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 3.
Class <code>"<a href="#topic+PeriodicInterceptSpec-class">PeriodicInterceptSpec</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 3.
Class <code>"<a href="#topic+VirtualPeriodicAutocovarianceModel-class">VirtualPeriodicAutocovarianceModel</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 4.
Class <code>"<a href="#topic+VirtualPeriodicMeanModel-class">VirtualPeriodicMeanModel</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 4.
Class <code>"<a href="sarima.html#topic+VirtualArmaFilter-class">VirtualArmaFilter</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 4.
Class <code>"<a href="#topic+ModelCycleSpec-class">ModelCycleSpec</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 4.
Class <code>"<a href="sarima.html#topic+InterceptSpec-class">InterceptSpec</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 4.
Class <code>"<a href="#topic+VirtualPeriodicModel-class">VirtualPeriodicModel</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 5.
Class <code>"<a href="sarima.html#topic+VirtualMonicFilter-class">VirtualMonicFilter</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 5.
</p>


<h3>Methods</h3>


<dl>
<dt>as_pcarma_list</dt><dd><p><code>signature(object = "FittedPeriodicArmaModel")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "FittedPeriodicArmaModel")</code>: ... </p>
</dd>
</dl>


<hr>
<h2 id='FittedPeriodicArModel-class'>Class FittedPeriodicArModel</h2><span id='topic+FittedPeriodicArModel-class'></span>

<h3>Description</h3>

<p>Class FittedPeriodicArModel.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("FittedPeriodicArModel", ar, ma, sigma2, ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>asyCov</code>:</dt><dd><p>Object of class <code>"ANY"</code> ~~ </p>
</dd>

<dt><code>sigma2</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>ar</code>:</dt><dd><p>Object of class <code>"PeriodicArFilter"</code> ~~ </p>
</dd>
<dt><code>ma</code>:</dt><dd><p>Object of class <code>"PeriodicMaFilter"</code> ~~ </p>
</dd>
<dt><code>center</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>intercept</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>theTS</code>:</dt><dd><p>Object of class <code>"PeriodicTS"</code> ~~ </p>
</dd>
<dt><code>ns</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>modelCycle</code>:</dt><dd><p>Object of class <code>"BasicCycle"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+PeriodicArModel-class">PeriodicArModel</a>"</code>, directly.
Class <code>"<a href="#topic+PeriodicArmaModel-class">PeriodicArmaModel</a>"</code>, by class &quot;PeriodicArModel&quot;, distance 2.
Class <code>"<a href="#topic+VirtualPeriodicArmaModel-class">VirtualPeriodicArmaModel</a>"</code>, by class &quot;PeriodicArModel&quot;, distance 3.
Class <code>"<a href="#topic+PeriodicArmaSpec-class">PeriodicArmaSpec</a>"</code>, by class &quot;PeriodicArModel&quot;, distance 3.
Class <code>"<a href="#topic+VirtualPeriodicFilterModel-class">VirtualPeriodicFilterModel</a>"</code>, by class &quot;PeriodicArModel&quot;, distance 4.
Class <code>"<a href="#topic+VirtualPeriodicStationaryModel-class">VirtualPeriodicStationaryModel</a>"</code>, by class &quot;PeriodicArModel&quot;, distance 4.
Class <code>"<a href="#topic+VirtualPeriodicAutocovarianceModel-class">VirtualPeriodicAutocovarianceModel</a>"</code>, by class &quot;PeriodicArModel&quot;, distance 5.
Class <code>"<a href="#topic+VirtualPeriodicMeanModel-class">VirtualPeriodicMeanModel</a>"</code>, by class &quot;PeriodicArModel&quot;, distance 5.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "FittedPeriodicArModel")</code>: ... </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "FittedPeriodicArModel")</code>: ... </p>
</dd>
<dt>as_pcarma_list</dt><dd><p><code>signature(object = "FittedPeriodicArModel")</code>: ... </p>
</dd>
</dl>


<hr>
<h2 id='four_stocks_since2016_01_01'>Data for four stocks since 2016-01-01</h2><span id='topic+four_stocks_since2016_01_01'></span>

<h3>Description</h3>

<p>Data for four stocks since 2016-01-01.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("four_stocks_since2016_01_01")</code></pre>


<h3>Format</h3>

<p>A list with components &quot;DELL&quot;,&quot;MSFT&quot;, &quot;INTC&quot;, &quot;IBM&quot;.
Each component is a time series from class <code>"xts" "zoo"</code>.
</p>


<h3>Details</h3>

<p>Stock market data for Dell, Microsoft, Intel and IBM, from 2016-01-01
to 2020-04-17. The Dell data start from 2016-08-17. All data were
downloaded from Yahoo Finance on 2020-04-18.
</p>


<h3>Source</h3>

<p><code>https://finance.yahoo.com/</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fraser2017">Fraser2017</a></code>,
<code><a href="#topic+dataFranses1996">dataFranses1996</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(four_stocks_since2016_01_01)
DELL &lt;- four_stocks_since2016_01_01$DELL
head(DELL)
tail(DELL)

dell &lt;- pcts(DELL)

head(as_datetime(dell))
head(Pctime(dell))

## Weekends are totally absent from the data,
## so a Monday-Friday sub-cycle is created:
nSeasons(dell)
dell@cycle


## there are some NA's in the data, due to Bank holidays
Pctime(c(2624, 5), pcCycle(dell))               # "W2624 Fri"
as_datetime(Pctime(c(2624, 5), pcCycle(dell)))  # "2020-04-10 UTC"

## dell["2020-04-10 UTC"]

head(cycle(dell))

tail(Pctime(dell))
tail(as.Date(Pctime(dell)))
</code></pre>

<hr>
<h2 id='Fraser2017'>Fraser River at Hope, mean monthly flow</h2><span id='topic+Fraser2017'></span>

<h3>Description</h3>

<p>Mean monthly flow (cms) of Fraser River From March 1912 to December
2017, recorded by Fraser River at Hope station.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Fraser2017")
</code></pre>


<h3>Format</h3>

<p>A time series (class <code>"ts"</code>) with frequency 12, starting from
January 1912 (the first two data values are <code>NA</code>) to December 2017.
</p>


<h3>Details</h3>

<p>Dataset <code>Fraser2017</code> is an extention of dataset <code>"Fraser"</code>
in package <code>"pear"</code>. The latter runs upto December 1990 (not the
documented December 1991). At the time of writing this package
<code>"pear"</code> is archived on CRAN, which is the main reason to include
the dataset (with the added benefit of almost 30 years of additional
data).
</p>


<h3>Source</h3>

<p><a href="https://wateroffice.ec.gc.ca/">https://wateroffice.ec.gc.ca/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dataFranses1996">dataFranses1996</a></code>,
<code><a href="#topic+four_stocks_since2016_01_01">four_stocks_since2016_01_01</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Fraser2017)

fr &lt;- window(Fraser2017, start = c(1912, 3), end = c(1990, 12))
## all.equal(as.numeric(fr), as.numeric(pear::Fraser)) # TRUE
## all.equal(tsp(fr), tsp(pear::Fraser))               # TRUE
</code></pre>

<hr>
<h2 id='head-methods'>Methods for function head() in package pcts</h2><span id='topic+head-methods'></span><span id='topic+head+2CPeriodicTimeSeries-method'></span>

<h3>Description</h3>

<p>Methods for function head() in package pcts.</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "PeriodicTimeSeries")</code></dt><dd>
</dd>
</dl>

<hr>
<h2 id='LegacyPeriodicFilterModel-class'>Class LegacyPeriodicFilterModel</h2><span id='topic+LegacyPeriodicFilterModel-class'></span>

<h3>Description</h3>

<p>Class LegacyPeriodicFilterModel.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("LegacyPeriodicFilterModel", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>intercept</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>arFilter</code>:</dt><dd><p>Object of class <code>"PeriodicArFilter"</code> ~~ </p>
</dd>
<dt><code>maFilter</code>:</dt><dd><p>Object of class <code>"PeriodicMaFilter"</code> ~~ </p>
</dd>
<dt><code>scalesq</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>jordan</code>:</dt><dd><p>Object of class <code>"ANY"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+VirtualPeriodicFilterModel-class">VirtualPeriodicFilterModel</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;LegacyPeriodicFilterModel&quot; in the signature.
</p>

<hr>
<h2 id='maxLag-methods'>Methods for function maxLag() in package 'pcts'</h2><span id='topic+maxLag-methods'></span><span id='topic+maxLag+2CPeriodicArmaFilter-method'></span>

<h3>Description</h3>

<p>Methods for function maxLag() in package 'pcts'.</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "PeriodicArmaFilter")</code></dt><dd>


</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## non-periodic autocovariances
maxLag(autocovariances(AirPassengers))

## periodic
pcts_exdata() # creates ap, ap7to9, pcfr, pcfr2to4,

maxLag(autocovariances(ap, maxlag = 6))

## pcarma filter
m &lt;- rbind(c(0.81, 0), c(0.4972376, 0.4972376))
ar_filt3 &lt;- new("PeriodicBJFilter",  coef =  m, order = c(1,2))
arma_filt3 &lt;- new("PeriodicArmaFilter", ar = ar_filt3)
maxLag(arma_filt3)
</code></pre>

<hr>
<h2 id='mC.ss'>Create environment for mc-fitting</h2><span id='topic+mC.ss'></span><span id='topic+xx.ss'></span>

<h3>Description</h3>

<p>Creates an environment for mc-fitting. These functions are transitory,
hence the strange names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mC.ss(spec, ...)

xx.ss(period, type.eigval, n.root, eigabs, eigsign, co_r, co_arg, 
      init = NULL, len.block = NULL, mo.col, generators = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mC.ss_+3A_spec">spec</code></td>
<td>
<p>a model, an object of class mcSpec.</p>
</td></tr>
<tr><td><code id="mC.ss_+3A_...">...</code></td>
<td>
<p>further arguments to be passed on to <code>xx.ss</code>.</p>
</td></tr>
<tr><td><code id="mC.ss_+3A_period">period</code></td>
<td>
<p>the number of seasons.</p>
</td></tr>
<tr><td><code id="mC.ss_+3A_type.eigval">type.eigval</code></td>
<td>
<p>types of the eigenvalues, a character vector with
elements &quot;r&quot; or &quot;cp&quot;, see Details.</p>
</td></tr>
<tr><td><code id="mC.ss_+3A_n.root">n.root</code></td>
<td>
<p>number of roots. Currently the dimension of the matrix
is set to this.</p>
</td></tr>
<tr><td><code id="mC.ss_+3A_eigabs">eigabs</code></td>
<td>
<p>The absolute values/moduli of the eigenvalues, numeric vector.</p>
</td></tr>
<tr><td><code id="mC.ss_+3A_eigsign">eigsign</code></td>
<td>
<p>The signs/moduli of the eigenvalues.</p>
</td></tr>
<tr><td><code id="mC.ss_+3A_co_r">co_r</code></td>
<td>
<p>similar to <code>eigabs</code> but for the co parameters.</p>
</td></tr>
<tr><td><code id="mC.ss_+3A_co_arg">co_arg</code></td>
<td>
<p>similar to <code>eigsign</code> but for the co parameters.</p>
</td></tr>
<tr><td><code id="mC.ss_+3A_init">init</code></td>
<td>

<p>initial values, see Details.
</p>
</td></tr>
<tr><td><code id="mC.ss_+3A_len.block">len.block</code></td>
<td>
<p>lengths of Jordan blocks.</p>
</td></tr>
<tr><td><code id="mC.ss_+3A_mo.col">mo.col</code></td>
<td>
<p>last non-zero column in the top of the matrix.</p>
</td></tr>
<tr><td><code id="mC.ss_+3A_generators">generators</code></td>
<td>
<p>~~ TODO: describe this argument. ~~</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mC.ss</code> takes the specification of the model as an object of
class mcSpec and calls <code>xx.ss</code>.
</p>
<p>Basically, the value returned by these functions is an extended
model specification together with an environment which can be used for
fitting the model, exploring the results and trying various things.
This may be used for getting better understanding of the model and the
optimisation routines.
</p>
<p>The result of both functions is a list, containing several functions
and an environment. The environment (element <code>env</code>) is the most
important element since it allows access to everything in the model
environment. The function elements of the list are simply a
convenience.
</p>
<p>Several functions in <code>env</code> are available for fitting the
model. Currently these are <code>minim</code>, <code>minimBB</code> and
<code>minimBBlu</code>. The first argument of all these functions is a time
series to which the model is to be fitted. By default, a conditional
likelihood is being optimised. To base the optimisation on conditional
sum of squares, set argument <code>CONDLIK</code> to FALSE.  The remaining
arguments in a call to any of the above functions are passed on to the
corresponding optimisation routine (whose help page should be
consulted for details).
</p>
<p><code>minim</code> uses the core <span class="rlang"><b>R</b></span> function <code>optim</code>.
<code>minimBB</code> and <code>minimBBlu</code> use <code>BBoptim</code> from package
<code>BB</code>. They result is a list, as returned by the corresponding
optimisation function with the optimal parameters  in element
<code>par</code>. The elements of this vector are named to help somewhat in
its interpretation but complete information about the fitted model can
be obtained from the environment.
</p>
<p>Firstly, at the end of the optimisation, the optimal parameters and
other information are stored in <code>env</code>. If the same call (maybe
with modified instructions for the optimisation) is repeated, these
parameters will be used as initial values for a new optimisation
run. This may be useful, for example, if the previous run didn't
converge.
</p>
<p>Secondly, properties of the fitted model and more useful
representations can be obtained using functions in the environment or
the convinience functions in the list returned by <code>xx.ss</code>.
</p>
<p><code>optparam2mcparam</code> converts a vector of parameters into the
more familiar filter representation, where the i-th row contains the
coefficients for the i-th season. This function takes one argument the
vector of parameters, e.g. the one returned by the fitting
functions. It updates a number of variables in <code>env</code>, computes
the filter representation of the model and stores it in
<code>wrkmodel</code>. It returns NULL.
This function may be used for exploratory purposes or to set new
values for the parameters, e.g. to be used as starting values for a
new optimisation run.
</p>
<p><code>mcparam2optparam</code> does the opposite. It converts the current
model in <code>env</code> to a vector of parameter. This function does not
have arguments.
</p>
<p><code>mclik</code> computes the value of the conditional likelihood for
given parameters. Its first argument is a time series, the second is a
vector of parameters and the third is a vector of innovations. Only
the first argument is compulsory. If <code>param</code> is not supplied, the
current parameters in <code>env</code> are used. Otherwise, they are updated
with the new parameters and then used. The innovations default to the
zero vector.
<code>mcss</code> is similar but computes the conditional sum of squares.
</p>
<p><strong>Argument <code>init</code></strong> can be used to provide initial
values. If it is missing or NULL, random initial values are generated
for the free parameters.
<code>init</code> may also be a numeric vector suitable for the call
<code>optparam2mcparam(init)</code>, see above. This vector would typically
come from a previous optimisation run.
</p>
<p><code>init</code> may also be a list with elements <code>"eigabs"</code>,
<code>"eigsign"</code>, <code>"co_r"</code>, <code>"co_abs"</code>. These components
have the same meaning as the corresponding arguments of <code>xx.ss</code>.
</p>
<p><strong>TODO: more is needed here!</strong>
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>fmcss</code></td>
<td>
<p>a function to compute the sum of squares for a model.</p>
</td></tr>
<tr><td><code>fparamvec</code></td>
<td>
<p>a function to convert mc-parameters to optimisation
parameters.</p>
</td></tr>
<tr><td><code>fmcparam</code></td>
<td>
<p>a function to convert optimisation parameters to
mc-parameters.</p>
</td></tr>
<tr><td><code>env</code></td>
<td>
<p>an object of class <code>environment</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Boshnakov GN, Iqelan BM (2009).
&ldquo;Generation of time series models with given spectral properties.&rdquo;
<em>J. Time Series Anal.</em>, <b>30</b>(3), 349&ndash;368.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.2009.00617.x">doi:10.1111/j.1467-9892.2009.00617.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xx.ss">xx.ss</a></code> which is called by <code>mC.ss</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># test0 roots
spec.coz2 &lt;- mcompanion::mcSpec(dim = 5, mo = 4, root1 = c(1,1), order = rep(2,4))
spec.coz2
xxcoz2a &lt;- mC.ss(spec.coz2)

## test0 roots
spec.coz4 &lt;- mcompanion::mcSpec(dim = 5, mo = 4, root1 = c(1,1), order = rep(3,4))
xxcoz4a &lt;- mC.ss(spec.coz4)
</code></pre>

<hr>
<h2 id='mcOptimCore-class'>Class mcOptimCore</h2><span id='topic+mcOptimCore-class'></span>

<h3>Description</h3>

<p>Class mcOptimCore.</p>


<h3>Extends</h3>

<p>All reference classes extend and inherit methods from <code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>.
</p>


<h3>Fields</h3>


<dl>
<dt><code>flag.exploring</code>:</dt><dd><p>Object of class <code>logical</code> ~~ </p>
</dd>
<dt><code>private.counter.fn</code>:</dt><dd><p>Object of class <code>integer</code> ~~ </p>
</dd>
<dt><code>period</code>:</dt><dd><p>Object of class <code>integer</code> ~~ </p>
</dd>
<dt><code>len.block</code>:</dt><dd><p>Object of class <code>integer</code> ~~ </p>
</dd>
<dt><code>n_col</code>:</dt><dd><p>Object of class <code>integer</code> ~~ </p>
</dd>
<dt><code>r_col</code>:</dt><dd><p>Object of class <code>integer</code> ~~ </p>
</dd>
<dt><code>cp_col</code>:</dt><dd><p>Object of class <code>integer</code> ~~ </p>
</dd>
<dt><code>ind.r.eigval</code>:</dt><dd><p>Object of class <code>integer</code> ~~ </p>
</dd>
<dt><code>r_ind</code>:</dt><dd><p>Object of class <code>integer</code> ~~ </p>
</dd>
<dt><code>ind.cp.eigval</code>:</dt><dd><p>Object of class <code>integer</code> ~~ </p>
</dd>
<dt><code>cp_ind</code>:</dt><dd><p>Object of class <code>integer</code> ~~ </p>
</dd>
<dt><code>filter.order</code>:</dt><dd><p>Object of class <code>integer</code> ~~ </p>
</dd>
<dt><code>ev_abs</code>:</dt><dd><p>Object of class <code>matrix</code> ~~ </p>
</dd>
<dt><code>ev_sign</code>:</dt><dd><p>Object of class <code>matrix</code> ~~ </p>
</dd>
<dt><code>co_r</code>:</dt><dd><p>Object of class <code>matrix</code> ~~ </p>
</dd>
<dt><code>co_arg</code>:</dt><dd><p>Object of class <code>matrix</code> ~~ </p>
</dd>
<dt><code>flag.generators</code>:</dt><dd><p>Object of class <code>logical</code> ~~ </p>
</dd>
<dt><code>par.ind</code>:</dt><dd><p>Object of class <code>ANY</code> ~~ </p>
</dd>
<dt><code>auto.ind</code>:</dt><dd><p>Object of class <code>ANY</code> ~~ </p>
</dd>
<dt><code>inf.ind</code>:</dt><dd><p>Object of class <code>ANY</code> ~~ </p>
</dd>
<dt><code>universe</code>:</dt><dd><p>Object of class <code>ANY</code> ~~ </p>
</dd>
<dt><code>col.minusinf.ind</code>:</dt><dd><p>Object of class <code>ANY</code> ~~ </p>
</dd>
<dt><code>col.inf.ind</code>:</dt><dd><p>Object of class <code>ANY</code> ~~ </p>
</dd>
<dt><code>ind1</code>:</dt><dd><p>Object of class <code>integer</code> ~~ </p>
</dd>
<dt><code>ind2</code>:</dt><dd><p>Object of class <code>integer</code> ~~ </p>
</dd>
<dt><code>ind3</code>:</dt><dd><p>Object of class <code>integer</code> ~~ </p>
</dd>
<dt><code>ind4</code>:</dt><dd><p>Object of class <code>integer</code> ~~ </p>
</dd>
<dt><code>n1</code>:</dt><dd><p>Object of class <code>integer</code> ~~ </p>
</dd>
<dt><code>n2</code>:</dt><dd><p>Object of class <code>integer</code> ~~ </p>
</dd>
<dt><code>n3</code>:</dt><dd><p>Object of class <code>integer</code> ~~ </p>
</dd>
<dt><code>n4</code>:</dt><dd><p>Object of class <code>integer</code> ~~ </p>
</dd>
<dt><code>seqn1</code>:</dt><dd><p>Object of class <code>integer</code> ~~ </p>
</dd>
<dt><code>seqn2</code>:</dt><dd><p>Object of class <code>integer</code> ~~ </p>
</dd>
<dt><code>seqn3</code>:</dt><dd><p>Object of class <code>integer</code> ~~ </p>
</dd>
<dt><code>seqn4</code>:</dt><dd><p>Object of class <code>integer</code> ~~ </p>
</dd>
<dt><code>co</code>:</dt><dd><p>Object of class <code>matrix</code> ~~ </p>
</dd>
<dt><code>initmodel</code>:</dt><dd><p>Object of class <code>ANY</code> ~~ </p>
</dd>
<dt><code>wrkmodel</code>:</dt><dd><p>Object of class <code>ANY</code> ~~ </p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>list</code> ~~ </p>
</dd>
<dt><code>tempnam</code>:</dt><dd><p>Object of class <code>ANY</code> ~~ </p>
</dd>
<dt><code>param_names</code>:</dt><dd><p>Object of class <code>character</code> ~~ </p>
</dd>
<dt><code>lo_bound</code>:</dt><dd><p>Object of class <code>ANY</code> ~~ </p>
</dd>
<dt><code>up_bound</code>:</dt><dd><p>Object of class <code>ANY</code> ~~ </p>
</dd>
<dt><code>mcss.cnt</code>:</dt><dd><p>Object of class <code>integer</code> ~~ </p>
</dd>
<dt><code>wrkev</code>:</dt><dd><p>Object of class <code>ANY</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>mclik(param, x, eps)</code>:</dt><dd><p> ~~ </p>
</dd>
<dt><code>minimBBlu(x, ..., CONDLIK)</code>:</dt><dd><p> ~~ </p>
</dd>
<dt><code>mcss(param, x, eps)</code>:</dt><dd><p> ~~ </p>
</dd>
<dt><code>matepshat(param, x, eps)</code>:</dt><dd><p> ~~ </p>
</dd>
<dt><code>process.mcss.cnt(mclik, mepshat)</code>:</dt><dd><p> ~~ </p>
</dd>
<dt><code>sigma2hat(param, x, eps)</code>:</dt><dd><p> ~~ </p>
</dd>
<dt><code>initialize(...)</code>:</dt><dd><p> ~~ </p>
</dd>
<dt><code>mcparam2optparam()</code>:</dt><dd><p> ~~ </p>
</dd>
<dt><code>optparam2mcparam(param)</code>:</dt><dd><p> ~~ </p>
</dd>
<dt><code>minimBB(x, ..., CONDLIK)</code>:</dt><dd><p> ~~ </p>
</dd>
<dt><code>optimize(optimfn, mcmethod, x, ..., MCBOUNDS)</code>:</dt><dd><p> ~~ </p>
</dd>
<dt><code>mcsigma2(param, x, eps)</code>:</dt><dd><p> ~~ </p>
</dd>
<dt><code>minim(x, ..., CONDLIK)</code>:</dt><dd><p> ~~ </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("mcOptimCore")
</code></pre>

<hr>
<h2 id='meanvarcheck'>Asymptotic covariance matrix of periodic mean</h2><span id='topic+meanvarcheck'></span><span id='topic+meancovmat'></span>

<h3>Description</h3>

<p>Asymptotic covariance matrix of periodic mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanvarcheck(parmodel, n)

meancovmat(parmodel, n, cor = FALSE, result = "var")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meanvarcheck_+3A_parmodel">parmodel</code></td>
<td>
<p>a periodic model.</p>
</td></tr>
<tr><td><code id="meanvarcheck_+3A_n">n</code></td>
<td>
<p>number of observations (TODO: need clarification here).</p>
</td></tr>
<tr><td><code id="meanvarcheck_+3A_cor">cor</code></td>
<td>
<p>if <code>TRUE</code>, return correlations</p>
</td></tr>
<tr><td><code id="meanvarcheck_+3A_result">result</code></td>
<td>

<p>if <code>"var"</code>, return the diagonal of the covariance matrix,
otherwise return the matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes asymptotic covariance or correlation matrix of the periodic
means.
</p>


<h3>Value</h3>

<p>if <code>result = "var"</code> a matrix,
otherwise a vector
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+parcovmatlist">parcovmatlist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- arima.sim(list(ar=0.9), n=1000)
proba1 &lt;- fitPM(c(3,2,2,2), x)

meancovmat(proba1, 100)
meancovmat(proba1, 100, cor = TRUE)
meancovmat(proba1, 100, result = "")
meancovmat(proba1, 100, cor = TRUE, result = "")

meanvarcheck(proba1, 100)
</code></pre>

<hr>
<h2 id='modelCycle'>Get the cycle of a periodic object</h2><span id='topic+modelCycle'></span><span id='topic+modelCycle-methods'></span><span id='topic+modelCycle+2CANY-method'></span><span id='topic+modelCycle+2CModelCycleSpec-method'></span><span id='topic+modelCycle+3C-'></span><span id='topic+modelCycle+3C--methods'></span><span id='topic+modelCycle+3C-+2CANY-method'></span><span id='topic+modelCycle+3C-+2CModelCycleSpec-method'></span>

<h3>Description</h3>

<p>Get the cycle of a periodic object, a generic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelCycle(object)

modelCycle(object, ... ) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelCycle_+3A_object">object</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="modelCycle_+3A_value">value</code></td>
<td>

<p>the new value for the cycle, an object inheriting from
<code>"BasicCycle"</code>.
</p>
</td></tr>
<tr><td><code id="modelCycle_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>modelCycle</code> is essentially internal, for programming. The user
level function to get the cycle of an object is <code><a href="#topic+pcCycle">pcCycle</a></code>.
</p>
<p><code>modelCycle</code> returns the Cycle object (in the sense of package
<span class="pkg">pcts</span>), associated with <code>object</code>.  <code>modelCycle</code> is a
generic function which makes it possible to associate a cycle with
objects from a class, without inheriting from the cycle classes.
</p>
<p>By definition, <code>NULL</code> represents the model cycle of objects from
classes with no (inherited) method for <code>modelCycle</code>.
</p>
<p>The default method of <code>modelCycle</code> returns <code>NULL</code>.
The default method for its replacement version throws error.
</p>


<h3>Value</h3>

<p>for <code>modelCycle</code>, an object inheriting from class
<code>"BasicCycle"</code> or <code>NULL</code>;
</p>
<p><code>"modelCycle&lt;-"</code> is used for the side effect of changing the
cycle of <code>object</code>. 
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "ANY")</code></dt><dd>
</dd>
<dt><code>signature(object = "ModelCycleSpec")</code></dt><dd>
</dd>
</dl>

<hr>
<h2 id='ModelCycleSpec-class'>Class ModelCycleSpec</h2><span id='topic+ModelCycleSpec-class'></span>

<h3>Description</h3>

<p>Class ModelCycleSpec.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("ModelCycleSpec", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>modelCycle</code>:</dt><dd><p>Object of class <code>"BasicCycle"</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>modelCycle</dt><dd><p><code>signature(object = "ModelCycleSpec")</code>: ... </p>
</dd>
<dt>modelCycle&lt;-</dt><dd><p><code>signature(object = "ModelCycleSpec")</code>: ... </p>
</dd>
</dl>


<hr>
<h2 id='nCycles'>
Basic information about periodic ts objects
</h2><span id='topic+nCycles'></span><span id='topic+nTicks'></span><span id='topic+nVariables'></span><span id='topic+nSeasons'></span>

<h3>Description</h3>

<p>Basic information about periodic periodic time series objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nCycles(x, ...)

nTicks(x)

nVariables(x, ...)

nSeasons(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nCycles_+3A_x">x</code>, <code id="nCycles_+3A_object">object</code></td>
<td>
<p>an object from a periodic time series class.</p>
</td></tr>
<tr><td><code id="nCycles_+3A_...">...</code></td>
<td>
<p>further arguments for methods.</p>
</td></tr>
</table>


<h3>Details</h3>




<p><code>nTicks</code> gives the number of time points, i.e. number of rows in
the matrix representation.
</p>
<p><code>nVariables</code> gives the number of variables in the time series.
</p>
<p><code>nSeasons</code> gives the number of seasons of time series and other
periodic objects.
</p>
<p><code>nCycles</code> gives the number of cycles available in the data,
e.g. number of years for monthly data. It always gives an integer
number. Currently, if the result is not an integer an error is
raised. <strong>TODO:</strong> There is a case to round up or give the number of full
cycles available but this seems somewhat dangerous if done quietly. A
good alternative is to provide argument for control of this.
</p>
<p>There are further functions to get or set the names of the units of
season and the seasons, see <code><a href="#topic+allSeasons">allSeasons</a></code>.
</p>


<h3>Value</h3>

<p>an integer number
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+allSeasons">allSeasons</a></code>, <code>"<a href="#topic+nSeasons-methods">nSeasons-methods</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ap &lt;- pcts(AirPassengers)
nVariables(ap)
nTicks(ap)
nCycles(ap)
nSeasons(ap)

monthplot(ap)
boxplot(ap)
</code></pre>

<hr>
<h2 id='nSeasons-methods'>Number of seasons of a periodic object</h2><span id='topic+nSeasons-methods'></span><span id='topic+nSeasons+2CCyclic-method'></span><span id='topic+nSeasons+2CBareCycle-method'></span><span id='topic+nSeasons+2CPartialCycle-method'></span><span id='topic+nSeasons+2CDayWeekCycle-method'></span><span id='topic+nSeasons+2CMonthYearCycle-method'></span><span id='topic+nSeasons+2CQuarterYearCycle-method'></span><span id='topic+nSeasons+2COpenCloseCycle-method'></span><span id='topic+nSeasons+2CEvery30MinutesCycle-method'></span><span id='topic+nSeasons+2CVirtualPeriodicArmaFilter-method'></span><span id='topic+nSeasons+2CVirtualArmaFilter-method'></span><span id='topic+nSeasons+2CPeriodicMonicFilterSpec-method'></span><span id='topic+nSeasons+2CSarimaFilter-method'></span><span id='topic+nSeasons+2CPeriodicInterceptSpec-method'></span><span id='topic+nSeasons+2CPeriodicIntegratedArmaSpec-method'></span><span id='topic+nSeasons+2CPeriodicFilterModel-method'></span><span id='topic+nSeasons+2CVirtualPeriodicModel-method'></span>

<h3>Description</h3>

<p>Number of seasons of a periodic object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Cyclic'
nSeasons(object)

## same signature for all periodic classes in package "pcts"
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nSeasons-methods_+3A_object">object</code></td>
<td>

<p>an object for which the notion of number of seasons makes sense.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nSeasons</code> is a generic function. This page gives is for the
methods defined in package <code>"pcts"</code> - all periodic classes have
(or inherit) a method.
</p>


<h3>Value</h3>

<p>an integer number
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "DayWeekCycle")</code></dt><dd>

</dd><dt><code>signature(object = "MonthYearCycle")</code></dt><dd>

</dd><dt><code>signature(object = "PeriodicIntegratedArmaSpec")</code></dt><dd>

</dd><dt><code>signature(object = "QuarterYearCycle")</code></dt><dd>

</dd><dt><code>signature(object = "PeriodicMonicFilterSpec")</code></dt><dd>

</dd><dt><code>signature(object = "PeriodicInterceptSpec")</code></dt><dd>

</dd><dt><code>signature(object = "Cyclic")</code></dt><dd>

</dd><dt><code>signature(object = "BareCycle")</code></dt><dd>

</dd><dt><code>signature(object = "OpenCloseCycle")</code></dt><dd>

</dd><dt><code>signature(object = "Every30MinutesCycle")</code></dt><dd>

</dd><dt><code>signature(object = "PartialCycle")</code></dt><dd>

</dd><dt><code>signature(object = "VirtualPeriodicModel")</code></dt><dd>

</dd><dt><code>signature(object = "SarimaFilter")</code></dt><dd>

</dd><dt><code>signature(object = "VirtualArmaFilter")</code></dt><dd>

</dd></dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+allSeasons">allSeasons</a></code> for other functions related to the
seasonality of an object;
</p>
<p><code><a href="#topic+nCycles">nCycles</a></code> for related functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## scalar time series
ap &lt;- pcts(AirPassengers)
nSeasons(ap) # 12

## multivariate time series
pcfr &lt;- pcts(dataFranses1996)
nSeasons(pcfr) # 4

## five-day-week period
five_day_week &lt;- BuiltinCycle(5)
five_day_week
nSeasons(five_day_week)
</code></pre>

<hr>
<h2 id='nTicks-methods'>Number of observations in a time series</h2><span id='topic+nTicks-methods'></span><span id='topic+nTicks+2Cmatrix-method'></span><span id='topic+nTicks+2Cnumeric-method'></span><span id='topic+nTicks+2CPeriodicTimeSeries-method'></span><span id='topic+nTicks+2CCyclic-method'></span>

<h3>Description</h3>

<p>Number of observations in a time series.</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "matrix")</code></dt><dd>
</dd>
<dt><code>signature(x = "numeric")</code></dt><dd>
</dd>
<dt><code>signature(x = "PeriodicTimeSeries")</code></dt><dd>
</dd>
<dt><code>signature(x = "Cyclic")</code></dt><dd>

</dd></dl>

<hr>
<h2 id='num2pcpar'>Fit PAR model using sample autocorrelations</h2><span id='topic+num2pcpar'></span>

<h3>Description</h3>

<p>Fit PAR model using sample autocorrelations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>num2pcpar(x, order, result = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="num2pcpar_+3A_x">x</code></td>
<td>
<p>time series, a numeric vector.</p>
</td></tr>
<tr><td><code id="num2pcpar_+3A_order">order</code></td>
<td>
<p>PAR order, a single number or a vector with one entry for
each season.</p>
</td></tr>





<tr><td><code id="num2pcpar_+3A_result">result</code></td>
<td>
<p>what to return, the default is to return the full model,
see Details.</p>
</td></tr>
<tr><td><code id="num2pcpar_+3A_...">...</code></td>
<td>
<p>passed on to <code>calc_peracf</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the periodic autocorrelations and fits a PAR model using the
Periodic Levinson-Durbin algorithm. 
</p>
<p>The order is a vector of non-negative integers, specifying the
autoregressive orders for each season. If <code>order</code> is a single
number, then all seasons have that order.
</p>
<p><code>mean</code> controls centering in the computation of the
autocorrelations.  If <code>mean</code> is numeric, then subtract the
supplied mean before computing the autocovariances. If <code>mean</code> is
TRUE, the default, compute and subtract the sample periodic mean
before computing the autocovariances. If <code>mean</code> is FALSE, do not
centre the series, i.e. assume that the mean is zero.
</p>
<p>If <code>result</code> is NULL, the default, returns the full model. If
<code>result = "coef"</code>, returns the PAR coefficients only (currently
any value of <code>result</code> other than NULL has this effect).
</p>


<h3>Value</h3>

<p>The coefficients of the fitted model or a list with components:
</p>
<table role = "presentation">
<tr><td><code>mean</code></td>
<td>
<p>the mean, set as described in Details.</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>forward prediction coefficients.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>standard deviations of the innovations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitPM">fitPM</a></code> which uses <code>num2pcpar</code> for calculations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simts1 &lt;- matrix(rnorm(100), nrow = 4)

num2pcpar(simts1, order = c(3,2,2,2), period = 4 )
num2pcpar(simts1, order = c(3,2,1,2), period = 4 )
pdSafeParOrder(c(3,2,1,2))
pdSafeParOrder(c(3,2,2,1))
num2pcpar(simts1, order = c(3,2,2,1), period = 4 )
num2pcpar(simts1, order = pdSafeParOrder(c(3,2,2,1)), period = 4 )

num2pcpar(simts1, order = c(3,2,1,2), period = 4 )
num2pcpar(simts1, order = c(3,2,1,2), period = 4, mean = rep(0,4) )
num2pcpar(simts1, order = c(3,2,1,2), period = 4, mean = FALSE )
num2pcpar(simts1, order = c(3,2,1,2), period = 4, mean = FALSE )$coef@m -
       num2pcpar(simts1, order = c(3,2,1,2), period = 4 )$coef@m

## End(Not run)
</code></pre>

<hr>
<h2 id='parcovmatlist'>Compute asymptotic covariance matrix for PAR model</h2><span id='topic+parcovmatlist'></span>

<h3>Description</h3>

<p>Compute asymptotic covariance matrix for PAR model</p>


<h3>Usage</h3>

<pre><code class='language-R'>parcovmatlist(parmodel, n, cor = FALSE, result = "list")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parcovmatlist_+3A_parmodel">parmodel</code></td>
<td>
<p>PAR model, object of class <code>parModel</code></p>
</td></tr>
<tr><td><code id="parcovmatlist_+3A_n">n</code></td>
<td>
<p>length of the series or a vector with one element for each
season.
</p>
</td></tr>
<tr><td><code id="parcovmatlist_+3A_cor">cor</code></td>
<td>
<p>If TRUE return correlation matrix.</p>
</td></tr>
<tr><td><code id="parcovmatlist_+3A_result">result</code></td>
<td>
<p>if &quot;list&quot;, the default, return a list, if &quot;Matrix&quot;
return a Matrix object, otherwise return an ordinary matrix, see
Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses eq. (3.3) in the reference.
</p>
<p>If <code>result = "list"</code>, <code>parcovmatlist</code> returns a list whose
s-th element is the covariance matrix of the PAR parameters for the
s-th season. Otherwise, if <code>result = "Matrix"</code> it returns a
block-diagonal matrix created by <code>.bdiag()</code> from package
&quot;Matrix&quot;. If <code>result = "matrix"</code> it returns an ordinary matrix
(with the current implementation this is returned for any value other
than &quot;list&quot; or &quot;Matriix&quot;).
</p>


<h3>Value</h3>

<p>a list, matrix or block-diagonal matrix, as described in Details
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>McLeod AI (1994).
&ldquo;Diagnostic checking of periodic autoregression models with application.&rdquo;
<em>Journal of Time Series Analysis</em>, <b>15</b>(2), 221&ndash;233.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcacfMat">pcacfMat</a></code>,
<code><a href="#topic+pc.acf.parModel">pc.acf.parModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- arima.sim(list(ar=0.9), n=1000)
proba1 &lt;- fitPM(c(3,2,2,2), x)

parcovmatlist(proba1, 100)
parcovmatlist(proba1, 100, cor = TRUE)
sqrt(diag(parcovmatlist(proba1, 100, cor = TRUE)[[1]]))

meanvarcheck(proba1, 100)
</code></pre>

<hr>
<h2 id='partialAutocorrelations-methods'>
Compute periodic partial autocorrelations
</h2><span id='topic+partialAutocorrelations'></span><span id='topic+partialAutocorrelations-methods'></span><span id='topic+partialAutocorrelations+2CPeriodicAutocovariances+2CANY+2Cmissing-method'></span><span id='topic+partialAutocorrelations+2CVirtualPeriodicAutocovariances+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>Methods for computation of periodic partial autocorrelations.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "PeriodicAutocovariances", maxlag = "ANY", lag_0 = "missing")</code></dt><dd>
</dd>
<dt><code>signature(x = "VirtualPeriodicAutocovariances", maxlag = "ANY", lag_0 = "ANY")</code></dt><dd>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="sarima.html#topic+partialAutocorrelations">partialAutocorrelations</a></code> in package <span class="pkg">sarima</span>
for further details.
</p>
<p><code><a href="#topic+partialVariances">partialVariances</a></code>,
<code><a href="#topic+partialAutocovariances">partialAutocovariances</a></code> 
</p>

<hr>
<h2 id='partialAutocovariances-methods'>
Compute periodic partial autocovariances
</h2><span id='topic+partialAutocovariances'></span><span id='topic+partialAutocovariances-methods'></span><span id='topic+partialAutocovariances+2CVirtualPeriodicAutocovariances-method'></span>

<h3>Description</h3>

<p>Compute periodic partial autocovariances.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "VirtualPeriodicAutocovariances")</code></dt><dd>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="sarima.html#topic+partialAutocorrelations">partialAutocorrelations</a></code> in package <span class="pkg">sarima</span>
for further details.
</p>
<p><code><a href="#topic+partialAutocorrelations">partialAutocorrelations</a></code>,
<code><a href="#topic+partialVariances">partialVariances</a></code>
</p>

<hr>
<h2 id='partialCoefficients-methods'>
Compute periodic partial coefficients
</h2><span id='topic+partialCoefficients'></span><span id='topic+partialCoefficients-methods'></span><span id='topic+partialCoefficients+2CPeriodicArModel-method'></span><span id='topic+partialCoefficients+2CVirtualPeriodicAutocovariances-method'></span>

<h3>Description</h3>

<p>Methods for computation of periodic partial coefficients.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "PeriodicArModel")</code></dt><dd>
</dd>
<dt><code>signature(x = "VirtualPeriodicAutocovariances")</code></dt><dd>
</dd>
</dl>

<hr>
<h2 id='PartialCycle-class'>Class PartialCycle</h2><span id='topic+PartialCycle-class'></span><span id='topic+allSeasons+2CPartialCycle+2Clogical-method'></span><span id='topic+allSeasons+2CPartialCycle+2Cmissing-method'></span>

<h3>Description</h3>

<p>Class PartialCycle</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PartialCycle", ...)</code>.
</p>
<p>Partial cycles are often created implicitly when subsetting time series
using <code>window()</code> with argument <code>seasons</code>, see the examples.
</p>


<h3>Slots</h3>


<dl>
<dt><code>orig</code>:</dt><dd>
<p>the parent class of the partial cycle, an object inheriting from
class <code>"BasicCycle"</code>.
</p>
</dd>
<dt><code>subindex</code>:</dt><dd>
<p>an integer vector specifying the seasons to include in the partial
cycle.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+BasicCycle-class">BasicCycle</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>allSeasons</dt><dd><p><code>signature(x = "PartialCycle", abb = "logical")</code>: ... </p>
</dd>
<dt>allSeasons</dt><dd><p><code>signature(x = "PartialCycle", abb = "missing")</code>: ... </p>
</dd>
<dt>nSeasons</dt><dd><p><code>signature(object = "PartialCycle")</code>: ... </p>
</dd>
<dt>unitCycle</dt><dd><p><code>signature(x = "PartialCycle")</code>: ... </p>
</dd>
<dt>unitSeason</dt><dd><p><code>signature(x = "PartialCycle")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "PartialCycle")</code>: ... </p>
</dd></dl>









<h3>See Also</h3>

<p><code><a href="#topic+BuiltinCycle">BuiltinCycle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dwc &lt;- new("DayWeekCycle")
dwc
allSeasons(dwc)

## a five day week cycle
dwc5 &lt;- new("PartialCycle", orig = dwc, subindex = 1:5)
dwc5
allSeasons(dwc5)

weekend &lt;- new("PartialCycle", orig = dwc, subindex = 6:7)
weekend
allSeasons(weekend)

ap &lt;- pcts(AirPassengers)

## take data for the summer months (in Northern hemisphere)
ap7to9 &lt;- window(ap, seasons = 7:9)
## the above implicitly creates a partial cycle
ap7to9
allSeasons(ap7to9)
</code></pre>

<hr>
<h2 id='PartialPeriodicAutocorrelations-class'>Class PartialPeriodicAutocorrelations</h2><span id='topic+PartialPeriodicAutocorrelations-class'></span>

<h3>Description</h3>

<p>Class PartialPeriodicAutocorrelations.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PartialPeriodicAutocorrelations", ..., data)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>modelCycle</code>:</dt><dd><p>Object of class <code>"BasicCycle"</code> ~~ </p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"Lagged"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+ModelCycleSpec-class">ModelCycleSpec</a>"</code>, directly.
Class <code>"<a href="lagged.html#topic+FlexibleLagged-class">FlexibleLagged</a>"</code>, directly.
Class <code>"<a href="#topic+VirtualPeriodicAutocorrelations-class">VirtualPeriodicAutocorrelations</a>"</code>, directly.
Class <code>"<a href="lagged.html#topic+Lagged-class">Lagged</a>"</code>, by class &quot;FlexibleLagged&quot;, distance 2.
Class <code>"<a href="#topic+VirtualPeriodicModel-class">VirtualPeriodicModel</a>"</code>, by class &quot;VirtualPeriodicAutocorrelations&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "PartialPeriodicAutocorrelations")</code>: ... </p>
</dd>
</dl>


<hr>
<h2 id='partialVariances-methods'>
Compute periodic partial variances
</h2><span id='topic+partialVariances'></span><span id='topic+partialVariances-methods'></span><span id='topic+partialVariances+2CVirtualPeriodicAutocovariances-method'></span>

<h3>Description</h3>

<p>Compute periodic partial variances.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "VirtualPeriodicAutocovariances")</code></dt><dd>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="sarima.html#topic+partialVariances">partialVariances</a></code> in package <span class="pkg">sarima</span>
for further details.
</p>
<p><code><a href="#topic+partialAutocorrelations">partialAutocorrelations</a></code> for for partial autocorrelations.
</p>

<hr>
<h2 id='pc_sdfactor'> Compute normalising factors </h2><span id='topic+pc_sdfactor'></span><span id='topic+pc.sdfactor'></span>

<h3>Description</h3>

<p>Compute a matrix of factors such that elementwise division of the
periodic autocovariance matrix by it will give the periodic
autocorrelations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pc_sdfactor(sd, maxlag)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pc_sdfactor_+3A_sd">sd</code></td>
<td>
<p>standard deviations of the seasons numeric.</p>
</td></tr>
<tr><td><code id="pc_sdfactor_+3A_maxlag">maxlag</code></td>
<td>
<p>maximal lag, a number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of coefficients of size <code>period x (maxlag+1)</code>. The
length of <code>sd</code> is taken to be the period.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

 <p><code><a href="#topic+autocorrelations">autocorrelations</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## equivalent to  data(Fraser, package = "pear")
Fraser &lt;- window(Fraser2017, start = c(1912, 3), end = c(1990, 12))

logfraser &lt;- window(pcts(log(Fraser)), start = c(1913, 1))
acvf1 &lt;- autocovariances(logfraser, maxlag = 2)
fac &lt;- pc_sdfactor(sqrt(acvf1[ , 0]), 2)
fac[ , 1:3]

acrf1 &lt;- autocorrelations(logfraser, maxlag = 2)
all.equal(acvf1[], acrf1[] * fac) # TRUE
</code></pre>

<hr>
<h2 id='pc.filter'> Applies a periodic ARMA filter to a time series </h2><span id='topic+pc.filter'></span><span id='topic+pc.armafilter'></span>

<h3>Description</h3>

<p>Filter time series with a periodic arma filter.
If <code>whiten</code> is <code>FALSE</code> (default) the function applies
the given ARMA filter to <code>eps</code> (<code>eps</code> is often periodic
white noise).  If <code>whiten</code> is <code>TRUE</code> the function applies
the &ldquo;inverse filter&rdquo; to <code class="reqn">x</code>, effectively computing
residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pc.filter(model, x, eps, seasonof1st = 1, from = NA, whiten = FALSE,
          nmean = NULL, nintercept = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pc.filter_+3A_x">x</code></td>
<td>
<p> the time series to be filtered, a vector. </p>
</td></tr>
<tr><td><code id="pc.filter_+3A_eps">eps</code></td>
<td>
<p> residuals, a vector or NULL. </p>
</td></tr>
<tr><td><code id="pc.filter_+3A_model">model</code></td>
<td>

<p>the model parameters, a list with components <code>"phi"</code>,
<code>"theta"</code>, <code>"p"</code>, <code>"q"</code>, <code>"period"</code>,
<code>"mean"</code> and <code>"intercept"</code>, see Details.
</p>
</td></tr>
<tr><td><code id="pc.filter_+3A_seasonof1st">seasonof1st</code></td>
<td>

<p>the season of the first observation (i.e., of x[1]).
</p>
</td></tr>
<tr><td><code id="pc.filter_+3A_from">from</code></td>
<td>
<p> the index from which to start filtering. </p>
</td></tr>
<tr><td><code id="pc.filter_+3A_whiten">whiten</code></td>
<td>

<p>if TRUE use <code>x</code> as input and apply the inverse filter to
produce <code>eps</code> (&quot;whiten&quot; <code>x</code>), if FALSE use <code>eps</code> as
input and generate <code>x</code> (&quot;colour&quot; <code>eps</code>).
</p>
</td></tr>
<tr><td><code id="pc.filter_+3A_nmean">nmean</code></td>
<td>

<p>a vector of means having the length of the series, see Details.
</p>
</td></tr>
<tr><td><code id="pc.filter_+3A_nintercept">nintercept</code></td>
<td>

<p>a vector of intercepts having the length of the series, see details.
</p>
</td></tr>
</table>


<h3>Details</h3>



<p>The model is specified by argument <code>model</code>, which is a list with
the following components:
</p>

<dl>
<dt><code>phi</code></dt><dd><p> the autoregression parameters,</p>
</dd>
<dt><code>theta</code></dt><dd><p> the moving average parameters,</p>
</dd>
<dt><code>p</code></dt><dd><p>the autoregression orders, a single number or a
vector with one element for each season,</p>
</dd>
<dt><code>q</code></dt><dd><p>the moving average orders, a single number or a
vector with one element for each season,</p>
</dd>
<dt><code>period</code></dt><dd><p> number of seasons in a cycle,</p>
</dd>
<dt><code>mean</code></dt><dd><p> means of the seasons,</p>
</dd>
<dt><code>intercept</code></dt><dd><p>intercepts of the seasons.</p>
</dd>
</dl>

<p>The relation between <code>x</code> and <code>eps</code> is assumed to be the
following. Let
</p>
<p style="text-align: center;"><code class="reqn">y_t = x_t - mu_t</code>
</p>

<p>be the mean corrected series, where <code class="reqn">mu_t</code> is the mean, see below.
The equation relating the
mean corrected series, <code class="reqn">y_t=x_t - \mu_t</code>, and
<code>eps</code> is the following:
</p>
<p style="text-align: center;"><code class="reqn"> y_t
    =   c_t
      + \sum_{i=1}^{p_t} \phi  _t(i)y          _{t-i}
      + \sum_{i=1}^{q_t} \theta_t(i)\varepsilon_{t-i}
      + \varepsilon_t
    </code>
</p>

<p>where <code class="reqn">c_t</code> is the intercept, <code>nintercept</code>. The inverse
filter is obtained by writing this as an equation expressing
<code class="reqn">\varepsilon_t</code> through the remaining quantities.
</p>
<p>If <code>whiten = TRUE</code>, <code>pc.filter</code> uses the above formula to
compute the filtered values of <code>x</code> for <code>t=from,...,n</code>,
i.e. whitening the time series if <code>eps</code> is white noise.  If
<code>whiten = FALSE</code>, <code>eps</code> is computed, i.e. the inverse filter
is applied <code>x</code> from <code>eps</code>, i.e. &ldquo;colouring&rdquo; <code>x</code>.
In both cases the first few values in <code>x</code> and/or <code>eps</code> are
used as initial values.
</p>
<p>Essentially, the mean is subtracted from the series to obtain the
mean-corrected series, say <code>y</code>. Then either <code>y</code> is filtered
to obtain <code>eps</code> or the inverse filter is applied to obtain
<code>y</code> from <code>eps</code>
finally the mean is added back to <code>y</code> and the result returned.
</p>
<p>The mean is formed by <code>model$mean</code> and argument <code>nmean</code>.  If
<code>model$mean</code> is supplied it is recycled periodically to the
length of the series <code>x</code> and subtracted from <code>x</code>. If
argument <code>nmean</code> is supplied, it is subtracted from <code>x</code>. If
both <code>model$mean</code> and <code>nmean</code> are supplied their sum is
subtracted from <code>x</code>.
</p>
<p>The above gives a vector <code>y</code>, <code class="reqn">y_t=x_t -
  \mu_t</code>, which is then filtered.  If the mean is
zero, <code class="reqn">y_t=x_t</code> in the formulas below.
</p>
<p>Finally, the mean is added back, <code class="reqn">x_t=y_t+\mu_t</code>, and the new
<code>x</code> is returned.
</p>
<p>The above gives a vector <code>y</code> which is used in the filtering.  If
the mean is zero, <code class="reqn">y_t=x_t</code> in the formulae below.
</p>
<p><code>pc.filter</code> can be used to simulate pc-arma series with the
default value of <code>whiten=FALSE</code>. In this case <code>eps</code> is the
input series and <code>y</code> the output.
</p>
<p style="text-align: center;"><code class="reqn"> y_t
    = c_t
      + \sum_{i=1}^{p_t} \phi  _t(i)y          _{t-i}
      + \sum_{i=1}^{q_t} \theta_t(i)\varepsilon_{t-i}
      + \varepsilon_t
    </code>
</p>

<p>Then <code>model$mean</code> or <code>nmean</code> are added to <code>y</code> to form the
output vector <code>x</code>.
</p>
<p>Residuals corresponding to a series <code>y</code> can be obtained by
setting <code>whiten=TRUE</code>. In this case <code>y</code> is the input series.
The elements of the output vector <code>eps</code> are calculated by the
formula:
</p>
<p style="text-align: center;"><code class="reqn"> \varepsilon_t
    = - c_t
      - \sum_{i=1}^{q_t} \theta_t(i)\varepsilon_{t-i}
      - \sum_{i=1}^{p_t} \phi  _t(i)y          _{t-i}
      + y_t
    </code>
</p>

<p>There is no need in this case to restore <code>x</code> since <code>eps</code> is
returned.
</p>
<p>In both cases any necessary initial values are assumed to be already
in the vectors. If <code>from</code> is not supplied it is chosen as the
smallest <code>i</code> such that for all <code class="reqn">t\ge i</code>,
<code>t-p[t]&gt;0</code> and <code>t-q[t]&gt;0</code>, i.e.  the filter will not require
negative indices for <code>x</code> or <code>eps</code>.
</p>
<p><code>pc.filter</code> calls the lower level function <code>pc.filter.xarma</code>
to do the computation.
</p>


<h3>Value</h3>

<p>The filtered series: the modified <code>x</code> if <code>whiten=FALSE</code>, the
modified <code>eps</code> if <code>whiten=TRUE</code>.
</p>


<h3>Level</h3>

<p>1</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p>the lower level functions
<code><a href="#topic+pc.filter.xarma">pc.filter.xarma</a></code> 
which do the computations
</p>

<hr>
<h2 id='pc.filter.xarma'> Filter time series with periodic arma filters </h2><span id='topic+pc.filter.xarma'></span>

<h3>Description</h3>

<p>Filter time series with periodic arma filters with or options for
periodic and non-periodic intercepts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pc.filter.xarma(x, eps, phi, theta, period, p, q, n, from,
              seasonof1st = 1, intercept = NULL, nintercept = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pc.filter.xarma_+3A_x">x</code></td>
<td>
<p> the time series to be filtered, a vector. </p>
</td></tr>
<tr><td><code id="pc.filter.xarma_+3A_eps">eps</code></td>
<td>
<p> the innovations, a vector.  </p>
</td></tr>
<tr><td><code id="pc.filter.xarma_+3A_phi">phi</code></td>
<td>
<p> the autoregression parameters, a matrix. </p>
</td></tr>
<tr><td><code id="pc.filter.xarma_+3A_theta">theta</code></td>
<td>
<p> the moving average parameters, a matrix. </p>
</td></tr>
<tr><td><code id="pc.filter.xarma_+3A_period">period</code></td>
<td>
<p> the period (number of seasons in a year). </p>
</td></tr>
<tr><td><code id="pc.filter.xarma_+3A_p">p</code></td>
<td>

<p>the autoregression orders, recycled to <code>period</code>
if <code>length(p)=1</code>.
</p>
</td></tr>
<tr><td><code id="pc.filter.xarma_+3A_q">q</code></td>
<td>

<p>the moving average orders, recycled to <code>period</code> if
<code>length(q)=1</code>.
</p>
</td></tr>
<tr><td><code id="pc.filter.xarma_+3A_n">n</code></td>
<td>

<p>a positive  integer, the time index of the last observation to be
filtered.
</p>
</td></tr>
<tr><td><code id="pc.filter.xarma_+3A_from">from</code></td>
<td>

<p>a positive  integer, the time index of the first observation to be
filtered.
</p>
</td></tr>
<tr><td><code id="pc.filter.xarma_+3A_seasonof1st">seasonof1st</code></td>
<td>

<p>a positive  integer, the season of the time index of <code>x[1]</code>,
see Details.
</p>
</td></tr>
<tr><td><code id="pc.filter.xarma_+3A_intercept">intercept</code></td>
<td>

<p>the intercepts of the seasons, a vector of length <code>period</code>.
</p>
</td></tr>
<tr><td><code id="pc.filter.xarma_+3A_nintercept">nintercept</code></td>
<td>

<p>intercepts, a vector of the same length as <code>x</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>


<p><code>pc.filter.xarma</code> is somewhat lower level.
The user level function is <code>pc.filter</code> which uses
<code>pc.filter.xarma</code> to do the computations.

</p>































<p><code>pc.filter.xarma</code> filters the time series <code>x</code> by the
following formula (for <code>t=from,...,n</code>):
</p>
<p style="text-align: center;"><code class="reqn"> x_t
    =   c_t
      + \sum_{i=1}^{p_t} \phi  _t(i)x          _{t-i}
      + \sum_{i=1}^{q_t} \theta_t(i)\varepsilon_{t-i}
      + \varepsilon_t,
    </code>
</p>

<p>where <code class="reqn">c_t</code> is the overall intercept at time <code class="reqn">t</code>, see
below.  Values of <code>x[t]</code> for <code>t</code> outside the range
<code>from,n</code>, if any, are left unchanged. Values for <code>t&lt;from</code>
are used as initial values when needed.
</p>
<p>Two intercepts are provided for convenience and some flexibility.  The
periodic intercept, <code>intercept</code>, is a vector of length
<code>period</code>. It is replicated to length <code>n</code>, taking care to
ensure that the first element of the resulting vector, say <code class="reqn">a</code>,
starts with <code>intercept[seasonof1st]</code>.  <code>nintercept</code> can be
an arbitrary vector of length <code>n</code>. It can be used to represent
trend or contributions from covariates.  <code>nintercept</code> is not
necessarilly periodic and argument <code>seasonof1st</code> does not affect
its use.  The overall intercept is obtained as the sum <code>c = a +
  nintercept</code>.
</p>
<p>Usually <code>x</code> is a numeric vector but it can also be a matrix in
which each column represents the data for one &ldquo;year&rdquo;.
Also, the length of <code>x</code> is typically, but not necessarilly, equal
to <code>n</code>. It is prudent to ensure that <code>length(x) &gt;= n</code> and
this must be done if <code>x</code> is a matrix.
</p>







<p>Argument <code>phi</code> is ignored if <code>p==0</code>,
argument <code>theta</code> is ignored if <code>q==0</code>.
</p>
<p><code>pc.filter.xarma</code> is meant to be called by other functions whose
task is to prepare the arguments with proper checks.  It does not make
much sense to repeat the checks in <code>pc.filter.xarma</code>.  In
particular, no check is made to ensure that <code>from</code> and <code>n</code>
are correctly specified.
</p>
<p><b>This is a low level function meant to be used with basic vectors
and matrices.  TODO: Implement in C/C++.</b>  In the current
implementation. it accesses the elements of the arguments with
straightforward indexing, so objects from classes may be used as
well, provided that <code>x[t]</code>, <code>eps[t]</code>, <code>phi[t,i]</code>,
<code>theta[t,i]</code>, as well as assignment to <code>x[t]</code>, are defined
for scalar indices.
</p>


<h3>Value</h3>

<p>Returns <code>x</code> with <code>x[from]</code> to <code>x[n]</code> filled with the
filtered values and values outside the interval <code>from,...,n</code>
left unchanged.
</p>
<p>The mode of <code>x</code> is left unchanged. In particular, <code>x</code> may be
a matrix with each row representing the data for a season. This is
convenient since periodic time series are often more easily processed
in this form.
</p>


<h3>Level</h3>

<p>0 (base) </p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

 <p><code><a href="#topic+pc.filter">pc.filter</a></code> </p>

<hr>
<h2 id='pc.hat.h'> function to compute estimates of the h weights </h2><span id='topic+pc.hat.h'></span>

<h3>Description</h3>

<p>The h coefficients are scaled cross-covariances between the time
series and the innovations. This function computes estimates for h
using as input the observed series, a series of estimated innovations,
and an estimate of the variance of the innovations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pc.hat.h(x, eps, maxlag, si2hat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pc.hat.h_+3A_x">x</code></td>
<td>
<p> the observed time series x(t) </p>
</td></tr>
<tr><td><code id="pc.hat.h_+3A_eps">eps</code></td>
<td>
<p> a series of esimated innovations  </p>
</td></tr>
<tr><td><code id="pc.hat.h_+3A_maxlag">maxlag</code></td>
<td>
<p> maximum lag  </p>
</td></tr>
<tr><td><code id="pc.hat.h_+3A_si2hat">si2hat</code></td>
<td>
<p> estimate of the variance of the innovations </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If missing, the variance of the innovations is estimated from <code>eps</code>.
</p>


<h3>Value</h3>

<p>A matrix of the coefficient up to lag maxlag with one row for each season.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Boshnakov GN (1996).
&ldquo;Recursive computation of the parameters of periodic autoregressive moving-average processes.&rdquo;
<em>J. Time Ser. Anal.</em>, <b>17</b>(4), 333&ndash;349.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.1996.tb00281.x">doi:10.1111/j.1467-9892.1996.tb00281.x</a>.
</p>

<hr>
<h2 id='pcacf_pwn_var'> Variances of sample periodic autocorrelations </h2><span id='topic+pcacf_pwn_var'></span>

<h3>Description</h3>

<p>Computes the variances of sample periodic autocorrelations from
periodic white noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcacf_pwn_var(nepoch, period, lag, season)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcacf_pwn_var_+3A_lag">lag</code></td>
<td>
<p> desired lags, a vector of positive integers.</p>
</td></tr>
<tr><td><code id="pcacf_pwn_var_+3A_season">season</code></td>
<td>
<p> desired seasons. </p>
</td></tr>
<tr><td><code id="pcacf_pwn_var_+3A_nepoch">nepoch</code></td>
<td>
<p> number of epochs. </p>
</td></tr>
<tr><td><code id="pcacf_pwn_var_+3A_period">period</code></td>
<td>
<p> number of seasons. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are given by McLeod (1994), see the reference, eq. (4.3).
</p>


<h3>Value</h3>

<p>A matrix whose (i,j)th entry contains the variance of the
autocorrelation coefficient for season <code>season[i]</code> and lag <code>lag[j]</code>.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>McLeod AI (1994).
&ldquo;Diagnostic checking of periodic autoregression models with application.&rdquo;
<em>Journal of Time Series Analysis</em>, <b>15</b>(2), 221&ndash;233.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pcacf_pwn_var(79, 12, 0:16, 1:12)
</code></pre>

<hr>
<h2 id='pcacfMat'>Compute PAR autocovariance matrix</h2><span id='topic+pcacfMat'></span><span id='topic+pc.acf.parModel'></span>

<h3>Description</h3>

<p>Compute PAR autocovariance matrix</p>


<h3>Usage</h3>

<pre><code class='language-R'>pc.acf.parModel(parmodel, maxlag = NULL)

pcacfMat(parmodel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcacfMat_+3A_parmodel">parmodel</code></td>
<td>
<p>PAR model, an object of class <code>parModel</code>.</p>
</td></tr>
<tr><td><code id="pcacfMat_+3A_maxlag">maxlag</code></td>
<td>
<p>maximum lag</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pc.acf.parModel</code> returns the autocovariances of a PAR model in
season-lag form with maximum lag equal to <code>maxlag</code>. If
<code>maxlag</code> is larger than the available precomputed
autocovariances, they missing ones are computed using the Yule-Walker
relations. Note that <code>pc.acf.parModel</code>
assumes that there are enough precomputed autocovariances to use the
Yule-Walker recursions directly.
</p>
<p>TODO: <code>pc.acf.parModel</code> is tied to the old classes since it accesses
their slots. Could be used as a template to streamline the method for
<code>autocovariances</code> for class <code>"PeriodicAutocovariance"</code>.
</p>
<p>The season-lag form can be easily converted to other forms with the
powerful indexing operator, see  the examples and <code><a href="lagged.html#topic+slMatrix-class">slMatrix-class</a></code>.
</p>
<p><code>pcacfMat</code> is a convenience function for statistical
inference. It creates a covariance matrix with dimension chosen
automatically. This covariance matrix is such that the asymptotic
covariance matrix of the estimated parameters can be obtained by dividing
sub-blocks by innovation variances and inverting them.  See,
eq. (3.3) in the reference.
</p>


<h3>Value</h3>

<p>for <code>pcacfMat</code>, a matrix
</p>
<p>for <code>pc.acf.parModel</code>, an <code>slMatrix</code>
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>McLeod AI (1994).
&ldquo;Diagnostic checking of periodic autoregression models with application.&rdquo;
<em>Journal of Time Series Analysis</em>, <b>15</b>(2), 221&ndash;233.
</p>


<h3>See Also</h3>

<p><code><a href="lagged.html#topic+slMatrix-class">slMatrix-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- arima.sim(list(ar = 0.9), n = 1000)
proba1 &lt;- fitPM(c(3,2,2,2), x)

acfb &lt;- pc.acf.parModel(proba1, maxlag = 8)
acfb[4:(-2), 4:(-2), type = "tt"]

pcacfMat(proba1)

</code></pre>

<hr>
<h2 id='pcalg1'>
Periodic Levinson-Durbin algorithm
</h2><span id='topic+alg1'></span>

<h3>Description</h3>

<p>Calculate partial periodic autocorrelations, forward and backward
prediction coefficients and error variances using the periodic
Levinson-Durbin algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alg1(r, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcalg1_+3A_r">r</code></td>
<td>
<p>periodic autocovariances, a matrix, see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="pcalg1_+3A_p">p</code></td>
<td>
<p>autoregressive orders, numeric vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>alg1(r,p)</code> calculates the partial periodic correlations from
autocovariances <code>r</code> and autoregression orders <code>p</code>. The
matrix <code>r</code> has the same format as that of the <code>r</code> slot of
<code>pcAcvf</code> objects.  The periodicity, <code>d</code>, is set equal to
the number of rows in <code>r</code>. If the length of <code>p</code> is not
equal to the periodicity, all autoregressive orders are set to the
first element of <code>p</code>. This last feature is really meant to be
used only with a scalar <code>p</code>.
</p>
<p>The convention for the signs of the coefficients is the one from
Boshnakov(1996) and is consistent with other <span class="rlang"><b>R</b></span> time series
functions.
</p>
<p><code>pmax</code> below stands for the maximal element of <code>p</code>,
i.e. the maximal AR order.
</p>
<p>As in the non-periodic case, the periodic Levinson-Durbin algorithm
fits recursively models of order 0, 1, ..., <code>pmax</code>. Namely,  at
step <code>i</code> the AR orders for all seasons are set to
<code>i</code>. This is done in a way that correctly handles the case when
not all elements of <code>p</code> are equal, see the references.
</p>
<p>The essential quantities calculated by the periodic Levinson-Durbin
algorithm are returned as matrices, whose <code class="reqn">i</code>th rows
contain values for season <code class="reqn">i</code>. The complete details depend on
the quantities, as described below.
</p>
<p>The partial autocorrelations, the forward innovation variances and
the backward innovation variances are returned as matrices with
<code>d</code> rows and <code>1+pmax</code> columns, whose j-th columns contain
the quantities for order j-1 (partial autocorrelations, forward
innovation variances and backward innovation variances, respectively).
Note that the lag-0 partial autocorrelations are the autocovariances
for lag 0, see the references for details.
</p>
<p>The forward autoregression parameters are returned as a list whose
<code class="reqn">j</code>th element is a matrix containing the coefficients for
order <code class="reqn">j</code>. Similarly for the backward autoregression parameters.
</p>
<p>One often is interested in the model of order <code>p</code> only. Its
coefficients are given by <code>af[[pmax]]</code>, while the innovation
variances are in the last column of <code>fv</code>.
</p>


<h3>Value</h3>

<p>A list with the following elements.
</p>
<table role = "presentation">
<tr><td><code>orders</code></td>
<td>
<p>autoregression orders</p>
</td></tr>
<tr><td><code>be</code></td>
<td>
<p>partial autocorrelations, a matrix with d rows</p>
</td></tr>
<tr><td><code>fv</code></td>
<td>
<p>forward innovation variances, a matrix with d rows</p>
</td></tr>
<tr><td><code>bv</code></td>
<td>
<p>backward innovation variances, a matrix with d rows</p>
</td></tr>
<tr><td><code>af</code></td>
<td>
<p>forward  autoregression parameters, a list with one
element for the parameters for each order. </p>
</td></tr>
<tr><td><code>ab</code></td>
<td>
<p>backward autoregression parameters, a list with one
element for the parameters for each order.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The autoregression orders of the output are not necessarilly the same
as those specified in the call. There may be no PAR model with the
requested orders, see the references.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Boshnakov GN (1996).
&ldquo;Recursive computation of the parameters of periodic autoregressive moving-average processes.&rdquo;
<em>J. Time Ser. Anal.</em>, <b>17</b>(4), 333&ndash;349.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.1996.tb00281.x">doi:10.1111/j.1467-9892.1996.tb00281.x</a>.
</p>
<p>Lambert-Lacroix S (2000).
&ldquo;On periodic autoregressive process estimation.&rdquo;
<em>IEEE Transactions on Signal Processing</em>, <b>48</b>(6), 1800-1803.
</p>
<p>Lambert-Lacroix S (2005).
&ldquo;Extension of autocovariance coefficients sequence for periodically correlated processes.&rdquo;
<em>Journal of Time Series Analysis</em>, <b>26</b>(3), 423-435.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+pdSafeParOrder">pdSafeParOrder</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r1 &lt;- rbind(c(1,0.81,0.729),c(1,0.90,0.900))
alg1(r1,2)

## pc2 &lt;- pcAcvf(init=r1)
## pc2a &lt;- pcAcvf(init=r1,seasonnames=c("am","pm"), periodunit="day")

# example of Lambert-Lacroix
data(ex1f)
pc3 &lt;- slMatrix(period=2,maxlag=5,f=ex1f,type="tt")
res0p2 &lt;- alg1(pc3[],c(0,2))
res1p2 &lt;- alg1(pc3[],c(1,2))
res3p3 &lt;- alg1(pc3[],c(3,3))

paramsys1 &lt;- pcarma_param_system(pc3, NULL, NULL, 2, 0, 2)
t1 &lt;- solve(paramsys1$A,paramsys1$b)

# this is from tests.r but I have lost t1
# set it to pc3 below
# note: t1 is not the t1 computed above and in other examples!

t1 &lt;- pc3
t1
t1[]
alg1(t1[],c(1,1))
alg1(t1[],c(1,0))
alg1(t1[],c(0,1))
alg1(t1[],c(5,5))
alg1(t1[],c(2,2))
alg1(t1[],c(2,3))
alg1(t1[],c(3,3))
alg1(t1[],c(4,4))
alg1(t1[],c(5,5))
</code></pre>

<hr>
<h2 id='pcalg1util'>
Give partial periodic autocorrelations or other partial prediction
quantities for a pcAcvf object.
</h2><span id='topic+alg1util'></span>

<h3>Description</h3>

<p>Give partial periodic autocorrelations or other partial prediction
quantities for a pcAcvf object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alg1util(x, s, at0 = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcalg1util_+3A_x">x</code></td>
<td>
<p>an object of a class inheriting from
<code>pc.Model.WeaklyStat</code></p>
</td></tr>
<tr><td><code id="pcalg1util_+3A_s">s</code></td>
<td>
<p> the required quantity, the name of one of the elements of
the list returned by <code><a href="#topic+alg1">alg1</a></code>.</p>
</td></tr>
<tr><td><code id="pcalg1util_+3A_at0">at0</code></td>
<td>
<p>if not identical to &quot;var&quot;, replace the elements of the
result at lag zero with 1, see &lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for <code>alg1()</code>. It calls <code>alg1</code>, to
do the computations and returns the requested element as an object
from class <code>slMatrix</code>.  The model order is set to the maximal lag
avialable in <code>x</code>,
</p>
<p>If <code>at0</code> is the character string &quot;var&quot;, then the lag zero values
in the result are set to the lag zero autocovariances, otherwise they
are set to 1.
This is mainly relevant for the periodic partial autocorrelations
(<code>s="be"</code>), since the setting <code>at0="var"</code> ensures that they
are in one to one correspondence with the autocovariances.
</p>


<h3>Value</h3>

<p>the requested quantity as an object of type slMatrix
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>


<p>Lambert-Lacroix S (2000).
&ldquo;On periodic autoregressive process estimation .&rdquo;
<em> IEEE Transactions on Signal Processing</em>, <b>48</b>( 6 ), pp. 1800-1803.
</p>

<p>Lambert-Lacroix S (2005).
&ldquo; Extension of autocovariance coefficients sequence for periodically correlated
processes.&rdquo;
<em>Journal of Time Series Analysis</em>, <b>26</b>(6), pp. 423-435.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+pdSafeParOrder">pdSafeParOrder</a></code>,
<code><a href="#topic+alg1">alg1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r1 &lt;- rbind(c(1,0.81,0.729),c(1,0.90,0.900))

# example of Lambert-Lacroix
data(ex1f)
pc3 &lt;- slMatrix(period=2,maxlag=5,f=ex1f,type="tt")
res0p2 &lt;- alg1(pc3[],c(0,2))
res1p2 &lt;- alg1(pc3[],c(1,2))
res3p3 &lt;- alg1(pc3[],c(3,3))
</code></pre>

<hr>
<h2 id='pcApply-methods'>Apply a function to each season</h2><span id='topic+pcApply'></span><span id='topic+pcApply-methods'></span><span id='topic+pcApply+2Cmatrix-method'></span><span id='topic+pcApply+2Cnumeric-method'></span><span id='topic+pcApply+2CPeriodicMTS-method'></span><span id='topic+pcApply+2CPeriodicTS-method'></span>

<h3>Description</h3>

<p>Apply a function to each season.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcApply(object, ...)

## S4 method for signature 'numeric'
pcApply(object, nseasons, FUN, ...)

## S4 method for signature 'matrix'
pcApply(object, nseasons, FUN, ...)

## S4 method for signature 'PeriodicTS'
pcApply(object, FUN, ...)

## S4 method for signature 'PeriodicMTS'
pcApply(object, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcApply-methods_+3A_object">object</code></td>
<td>
<p>an object for which periodic mean makes sense.</p>
</td></tr>
<tr><td><code id="pcApply-methods_+3A_nseasons">nseasons</code></td>
<td>
<p>number of seasons.</p>
</td></tr>
<tr><td><code id="pcApply-methods_+3A_fun">FUN</code></td>
<td>
<p>a function, as for <code><a href="base.html#topic+apply">apply</a></code>. </p>
</td></tr>
<tr><td><code id="pcApply-methods_+3A_...">...</code></td>
<td>
<p>further arguments for <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For univariate periodic time series, <code>pcApply</code> applies <code>FUN</code>
to the data for each season. For multivariate periodic time series,
this is done for each variable.
</p>
<p>The methods for <code>"numeric"</code> and <code>"matrix"</code> are equivalent to
those for <code>"PeriodicTS"</code> and <code>"PeriodicMTS"</code>,
respectively. The difference is that the latter two don't need
argument <code>nseasons</code> and take the names of the seasons from
<code>object</code>.
</p>
<p>Argument <code>"..."</code> is for further arguments to <code>FUN</code>. In
particular, with many standard <span class="rlang"><b>R</b></span> functions argument <code>na.rm =
  TRUE</code> can be used to omit NA's, see the examples.
</p>
<p>In the univariate case, when  <code>length(object)</code> is an integer
multiple of the number of seasons the periodic mean is equivalent to
<code>apply(matrix(object, nrow = nseasons), 1, FUN, ...)</code>.
</p>


<h3>Value</h3>

<p>numeric or matrix for the methods described here, see section
Details. 
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "matrix")</code></dt><dd>

</dd>
<dt><code>signature(object = "numeric")</code></dt><dd>

</dd>
<dt><code>signature(object = "PeriodicMTS")</code></dt><dd>

</dd>
<dt><code>signature(object = "PeriodicTS")</code></dt><dd>

</dd>
</dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcMean">pcMean</a></code>,
<code><a href="base.html#topic+apply">apply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pcApply(pcts(presidents), mean, na.rm = TRUE)
pcMean(pcts(presidents), na.rm = TRUE) # same

pcApply(pcts(presidents), median, na.rm = TRUE)
pcApply(pcts(presidents), var, na.rm = TRUE)
pcApply(pcts(presidents), sd, na.rm = TRUE)

pcfr2to4 &lt;- pcts(dataFranses1996)[2:4]
pcApply(pcfr2to4, median, na.rm = TRUE)
pcApply(pcfr2to4, sd, na.rm = TRUE)
</code></pre>

<hr>
<h2 id='pcAr.ss'>Compute the sum of squares for a given PAR model</h2><span id='topic+pcAr.ss'></span>

<h3>Description</h3>

<p>Compute the sum of squares for a given PAR model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcAr.ss(x, model, eps = numeric(length(x)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcAr.ss_+3A_x">x</code></td>
<td>
<p>time series, a numeric vector.</p>
</td></tr>
<tr><td><code id="pcAr.ss_+3A_model">model</code></td>
<td>
<p>a model.</p>
</td></tr>
<tr><td><code id="pcAr.ss_+3A_eps">eps</code></td>
<td>
<p>residuals, defaults to a vector of zeroes. This may be used
for models with moving average terms, for example.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>todo:
</p>


<h3>Value</h3>

<p>a number
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>

<hr>
<h2 id='pcAR2acf'>Compute periodic autocorrelations from PAR coefficients</h2><span id='topic+pcAR2acf'></span>

<h3>Description</h3>

<p>Compute periodic autocorrelations from PAR
coefficients. This effectively solves the inverse problem to that
solved by the periodic Levinson-Durbin algorithm but does not use a
recursion.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcAR2acf(coef, sigma2, p, maxlag = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcAR2acf_+3A_coef">coef</code></td>
<td>
<p>PAR coefficients, a matrix, see Details.</p>
</td></tr>
<tr><td><code id="pcAR2acf_+3A_sigma2">sigma2</code></td>
<td>
<p>innovations variances.</p>
</td></tr>
<tr><td><code id="pcAR2acf_+3A_p">p</code></td>
<td>
<p>PAR order.</p>
</td></tr>
<tr><td><code id="pcAR2acf_+3A_maxlag">maxlag</code></td>
<td>
<p>How many lags to compute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>coef</code> is a matrix with the coefficients for season <code>i</code> in
the i-th row. The coefficients start from lag 1.
</p>
<p>The first few autocorrelations are computed by solving a linear
system, see the references. The rest, are generated using the periodic
Yule-Walker equations.
</p>


<h3>Value</h3>

<p>a matrix, in which row <code>s</code> contains the acf's for season <code>s</code>
for lags 0, 1, ..., maxlag (in this order).
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Boshnakov GN (1996).
&ldquo;Recursive computation of the parameters of periodic autoregressive moving-average processes.&rdquo;
<em>J. Time Ser. Anal.</em>, <b>17</b>(4), 333&ndash;349.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.1996.tb00281.x">doi:10.1111/j.1467-9892.1996.tb00281.x</a>.
</p>
<p>Boshnakov GN, Boteva A (1992).
&ldquo;An algorithm for the computation of the theoretical autocovariances of a periodic autoregression process.&rdquo;
Varna.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcarma_acvf_lazy">pcarma_acvf_lazy</a></code>, which does the main computation, but note
that the coefficients for it start from lag zero
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- rbind( c(0.81, 0), c(0.4972376, 0.4972376) )
si2 &lt;- PeriodicVector(c(0.3439000, 0.1049724))

pcAR2acf(m)
pcAR2acf(m, si2)
pcAR2acf(m, si2, 2)
pcAR2acf(m, si2, 2, maxlag = 10)


# same using pcarma_acvf_lazy directly
m1 &lt;- rbind( c(1, 0.81, 0), c(1, 0.4972376, 0.4972376) )

testphi &lt;- slMatrix(init = m1)
myf &lt;- pcarma_acvf_lazy(testphi, testtheta, si2, 2, 0, 2, maxlag = 10)
myf(1:2, 0:9)    # get a matrix of values

all(myf(1:2, 0:9) == pcAR2acf(m, si2, 2, maxlag = 9)) # TRUE

</code></pre>

<hr>
<h2 id='pcarma_acvf2model'>Fit a PC-ARMA model to a periodic autocovariance function</h2><span id='topic+pcarma_acvf2model'></span>

<h3>Description</h3>

<p>Fit a PC-ARMA model to a periodic autocovariance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcarma_acvf2model(acf, model, maxlag)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcarma_acvf2model_+3A_acf">acf</code></td>
<td>
<p>a periodic autocovariance function, an object of class
<code>pcAcvf</code>.</p>
</td></tr>
<tr><td><code id="pcarma_acvf2model_+3A_model">model</code></td>
<td>
<p>a pc- arma model, an object of class
<code>pcARMApq</code>. (todo: check!)</p>
</td></tr>
<tr><td><code id="pcarma_acvf2model_+3A_maxlag">maxlag</code></td>
<td>
<p>not used. (todo: check!)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>~Describe the value returned
If it is a LIST, use
</p>
<table role = "presentation">
<tr><td><code>comp1</code></td>
<td>
<p>Description of 'comp1'</p>
</td></tr>
<tr><td><code>comp2</code></td>
<td>
<p>Description of 'comp2'</p>
</td></tr>
</table>
<p>...
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Boshnakov GN (1996).
&ldquo;Recursive computation of the parameters of periodic autoregressive moving-average processes.&rdquo;
<em>J. Time Ser. Anal.</em>, <b>17</b>(4), 333&ndash;349.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.1996.tb00281.x">doi:10.1111/j.1467-9892.1996.tb00281.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ex1f)
pc3 &lt;- slMatrix(period=2,maxlag=5,f=ex1f,type="tt")
# pcarma_param_system(pc3, NULL, NULL, 2, 0, 2)
parsys &lt;- pcarma_param_system(pc3, NULL, NULL, c(2,2), 0, 2)
param &lt;- solve(parsys$A,parsys$b)

# res &lt;- pcarma_acvf2model(pc3, list(p=c(1,2),q=0,period=2))
# res &lt;- pcarma_acvf2model(pc3, list(p=c(1,2),q=0))
# res &lt;- pcarma_acvf2model(pc3, list(p=c(1,2),period=2))
res &lt;- pcarma_acvf2model(pc3, list(p=c(1,2)))

print(param)
print(res)
</code></pre>

<hr>
<h2 id='pcarma_solve'>
Functions to compute various characteristics of a PCARMA model
</h2><span id='topic+pcarma_acvf_lazy'></span><span id='topic+pcarma_h_lazy'></span><span id='topic+pcarma_acvf_system'></span><span id='topic+pcarma_param_system'></span><span id='topic+pcarma_h'></span>

<h3>Description</h3>

<p>Given a PCARMA model, create a function for computing autocovariances
or coefficients of the corresponding infinite moving average
representation or prepare the linear system whose solution provides
the first few autocovariances of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcarma_acvf_lazy(phi, theta, sigma2, p, q, period, maxlag = 100)
pcarma_h_lazy(phi, theta, p, q, period, maxlag = 200)
pcarma_acvf_system(phi, theta, sigma2, p, q, period)
pcarma_param_system(acf, h, sigma2, p, q, period)
pcarma_h(h, na = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcarma_solve_+3A_phi">phi</code></td>
<td>

<p>the autoregression parameters, an object of class <code>"slMatrix"</code>
</p>
</td></tr>
<tr><td><code id="pcarma_solve_+3A_theta">theta</code></td>
<td>

<p>the moving average parameters, an object of class <code>"slMatrix"</code>
</p>
</td></tr>
<tr><td><code id="pcarma_solve_+3A_sigma2">sigma2</code></td>
<td>
<p>the innovation variances, an object of class
<code>"PeriodicVector"</code> or  a vector of size <code>period</code>, Details.
</p>
</td></tr>
<tr><td><code id="pcarma_solve_+3A_p">p</code></td>
<td>

<p>the (maximal) autoregression order or the autoregression orders.
</p>
</td></tr>
<tr><td><code id="pcarma_solve_+3A_q">q</code></td>
<td>

<p>the (maximal) moving average order or the moving average orders.
</p>
</td></tr>
<tr><td><code id="pcarma_solve_+3A_period">period</code></td>
<td>
<p> number of seasons in an epoch </p>
</td></tr>
<tr><td><code id="pcarma_solve_+3A_maxlag">maxlag</code></td>
<td>

<p>maximal lag for which the result is stored internally.
</p>
</td></tr>
<tr><td><code id="pcarma_solve_+3A_acf">acf</code></td>
<td>
<p> the autocovariance function, an object of class pcAcvf,
slMatrix, or similar </p>
</td></tr>
<tr><td><code id="pcarma_solve_+3A_h">h</code></td>
<td>
  <p><code>pcarma_param_system</code>,
<code>h(t,k)</code>  is expected to return the coefficient
<code class="reqn">h_{t,k}</code>. <code>h</code> is usually created by
<code>pcarma_h_lazy</code>.
For <code>pcarma_h</code>,  a matrix of h(t,i) coefficients.
</p>
</td></tr>
<tr><td><code id="pcarma_solve_+3A_na">na</code></td>
<td>

<p>not used currently, controls what to do for large lags.
</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Compute acvf from parameters</h4>

<p><code>pcarma_acvf_lazy</code> creates a function that will compute (on
demand) values of the acf by a recursive formula. Computed values
are stored internally for lags up to <code>maxlag</code>.
</p>



<h4>System for acvf from parameters</h4>

<p><code>pcarma_acvf_system</code> forms a linear system for the calculation
of autocovariances from the parameters of a pc-arma model.  The
argument <code>theta</code> is not used if <code class="reqn">q=0</code> and <code>phi</code> is not
used if <code class="reqn">p=0</code>.
</p>



<h4>System for parameters from acvf</h4>

<p><code>pcarma_param_system</code> takes
the periodic autocovariances of a pc-arma model and computes a
matrix and a vector representing the linear system whose solution
provides the parameters of the model.
</p>
<p>Scalar <code>p</code> specifies the same autoregression order for each
season, similarly for <code>q</code>.  <code>p</code> and <code>q</code> may be
vectors of length <code>period</code> specifying the order for each season
individually. In the latter case the solution of the system may not
be a proper model or, if it is, its autocovariances may not be the
ones used here! See the references for details.
</p>
<p>The class of <code>acf</code> is not required to be one of those
explicitly listed above, but it should understand their indexing
conventions, similarly for <code>sigma2</code>.
</p>
<p>For pure autoregression, <code class="reqn">q=0</code>, the arguments <code>h</code> and
<code>sigma2</code> are ignored. <strong>TODO: add sigma2 (if supplied) to
the returned list?</strong>
</p>



<h4>Compute h from parameters</h4>

<p><code>pcarma_h_lazy</code>: h(t,i) are the coefficients in infinite the
moving average representation of the pc.arma model. The calculations
use formula (4.4) from my paper (or elsewhere) with internal storage
(in an slMatrix) of calculated results (for i&lt;maxlag) and recursive
calls to itself. So, it is not necessary to compute h(t,i) in any
particular order.
</p>



<h4>Infinite MA coefficients(h)</h4>

<p><code>pcarma_h</code> Function to create a function for lazy computation
of h(t,i) in pc.arma models
</p>
<p>Takes a matrix of h(t,i) coefficeints and returns a function that
calculates h(t,i) from my paper xxx. The returned value can be used
in the same way as that of <code>pcarma_h_lazy</code>.
</p>



<h3>Value</h3>



<h4>for pcarma_acvf_lazy</h4>

<p>a function taking two arguments <code>t</code> and <code>k</code> such that for
scalar <code>t</code> and <code>k</code> the call <code>f(t,k)</code> will return
EX(t)X(t-k). If either of the arguments is a vector, then
<code>f(t,k)</code> returns a matrix of size (<code>length(t),length(k)</code>)
containing the respective autocovariances.
</p>



<h4>for pcarma_h_lazy</h4>

<p>a function, say <code>h</code>. In calls to <code>h</code>, if both arguments
are scalars <code>h(t,i)</code> returns <code class="reqn">h_{t,i}</code>. If at least one of the
arguments is a vector a matrix of values of <code class="reqn">h</code> is returned.
</p>



<h4>for pcarma_acvf_system</h4>

<p>a list with two components representing the linear system:
</p>

<dl>
<dt>A</dt><dd>
<p>The
<code class="reqn">(p+1)\mbox{period}\times(p+1)\mbox{period}</code>
matrix of the system, an object of class &quot;matrix&quot;.
</p>
</dd>
<dt>b</dt><dd>
<p>The right-hand side of the system,  a vector of length
<code class="reqn">(p+1)\mbox{period}</code>, an object of class &quot;vector&quot;.
</p>
</dd>
</dl>

<p><code class="reqn">A^{-1}b</code> can be used to get a vector of the
autocovariances in the following order (d is the period, p is the
maximal AR order):
</p>
<p style="text-align: center;"><code class="reqn">K(1,0),...,K(d,0), K(1,1),...,K(d,1),...,K(1,p),...,K(d,p).</code>
</p>




<h4>for pcarma_param_system</h4>

<p>A list with components representing the linear system and the AR and
MA orders:
</p>

<dl>
<dt>A</dt><dd><p>The matrix of the system</p>
</dd>
<dt>b</dt><dd><p>The right-hand side of the system</p>
</dd>
<dt>p</dt><dd><p>The AR order</p>
</dd>
<dt>q</dt><dd><p>The MA order</p>
</dd>
</dl>

<p><code class="reqn">A^{-1}b</code> will return a vector of the parameters of the
pc-arma model: all parameters for the first season, followed by all
parameters for the second seasons and so on. For each season the
parameters are in the following order (s is the current season, d is
the period, <code class="reqn">p[s]</code> and <code class="reqn">q[s]</code> are the corresponding AR and
MA orders):
</p>
<p style="text-align: center;"><code class="reqn">
      \sigma^2(s), \phi(s,1),...,\phi(s,p[s]),\theta(s,1),...,\theta(s,q[s]).
    </code>
</p>




<h4>for pcarma_h</h4>

<p>a function, say <code>h</code>. In calls to <code>h</code>, if both arguments
are scalars <code>h(t,i)</code> returns <code class="reqn">h_{t,i}</code>. If at least one of the
arguments is a vector a matrix of values of <code class="reqn">h</code> is returned.
Analogous to <code>pcarma_h_lazy</code>.
</p>



<h3>Note</h3>

<p>for <code>pcarma_acvf_lazy</code>: The recursion may become extremely slow for lags greater than
<code>maxlag</code>. If large lags are likely to be needed the argument
<code>maxlag</code> should be used to increase the internal storage. The
default for <code>maxlag</code> currently is 100.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Boshnakov GN (1996).
&ldquo;Recursive computation of the parameters of periodic autoregressive moving-average processes.&rdquo;
<em>J. Time Ser. Anal.</em>, <b>17</b>(4), 333&ndash;349.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.1996.tb00281.x">doi:10.1111/j.1467-9892.1996.tb00281.x</a>.
</p>


<h3>See Also</h3>


<p><code><a href="#topic+pcarma_h">pcarma_h</a></code>,
<code><a href="#topic+pcarma_param_system">pcarma_param_system</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## periodic acf of Lambert-Lacroix
data(ex1f)
(pc3 &lt;- slMatrix(period = 2, maxlag = 5, f = ex1f, type = "tt"))
## find the parameters
s3 &lt;- pcarma_param_system(pc3, NULL, NULL, 2, 0, 2)
coef3 &lt;- solve(s3$A, s3$b)
pcarma_unvec(list(p = 2, q = 0, period = 2, param = coef3))

## actually, the model is PAR(1,2):
s3a &lt;- pcarma_param_system(pc3, NULL, NULL, c(1, 2), 0, 2)
coef3a &lt;- solve(s3a$A, s3a$b)
pcarma_unvec(list(p = c(1,2), q = 0, period = 2, param = coef3a))


## prepare test parameters for a PAR(2) model with period=2.
##   (rounded to 6 digits from the above example.
m1 &lt;- rbind(c(1, 0.81, 0), c(1, 0.4972376, 0.4972376) )
m2 &lt;- rbind(c(1, 0, 0), c(1, 0, 0) )
testphi &lt;- slMatrix(init = m1)
testtheta &lt;- slMatrix(init = m2)
si2 &lt;- PeriodicVector(c(0.3439000, 0.1049724)) #     # or si2 &lt;- c(1,1)

## acf from parameters
myf &lt;- pcarma_acvf_lazy(testphi, testtheta, si2, 2, 0, 2, maxlag = 110)
myf(1,4)        # compute a value
a1 &lt;- myf(1:2,0:9)    # get a matrix of values

## h from parameters
h &lt;- pcarma_h_lazy(testphi, testtheta, 2, 2, 2)
h(3, 2)           # a scalar
h1 &lt;- h(1:2, 1:4) # a matrix

## compute acvf from parameters
( acfsys &lt;- pcarma_acvf_system(testphi, testtheta, si2, 2, 0, 2) )
acfvec &lt;- solve(acfsys$A, acfsys$b)
acf1 &lt;- slMatrix(acfvec, period = 2)

## TODO: examples wirh q != 0
</code></pre>

<hr>
<h2 id='pcarma_unvec'>
Functions for work with a simple list specification of pcarma models
</h2><span id='topic+pcarma_unvec'></span><span id='topic+pcarma_tovec'></span><span id='topic+pcarma_prepare'></span>

<h3>Description</h3>

<p>Handle a simple list specification of pcarma models.
Functions to convert to and from a representation appropriate for
handing on to optimisation functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcarma_prepare(model, type)
pcarma_unvec(model)
pcarma_tovec(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcarma_unvec_+3A_model">model</code></td>
<td>
<p>specification of a pcarma model, a list, see Details.</p>
</td></tr>
<tr><td><code id="pcarma_unvec_+3A_type">type</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions work with a specification of a pcarma model as a list
with components <code>period</code>, <code>p</code>, <code>q</code>, <code>param</code>,
<code>phi</code>, <code>theta</code> and <code>si2</code>, see also section &lsquo;Values&rsquo;.
The functions do not necessarily need or examine all these components.
</p>
<p>Argument <code>model</code> is a list with components as accepted by
<code>pcarma_prepare</code>. Details are below but the guiding rule is that
there are sensible defaults for absent components.
</p>
<p><code>pcarma_prepare</code> gives a standard representation of <code>model</code>, in
the sense that it ensures that the model has components <code>period</code>,
<code>p</code> and <code>q</code>, such that <code>p</code> and <code>q</code> are vectors of
length <code>period</code>. <code>pcarma_prepare</code>  does not examine any other
components of the model. (<strong>TODO:</strong> do the same for the
innovation variance?)
</p>
<p>If <code>model$period</code> is NULL, <code>pcarma_prepare</code> sets it to the
length of the longer of <code>model$p</code> and <code>model$q</code>.  If
<code>model$p</code> is a scalar it is extended with <code>rep(model$p,
  period)</code>.  Missing or NULL <code>model$p</code> is equivalent to
<code>model$p = 0</code>.  <code>model$q</code> is processed analogously.
</p>
<p>The net effect is that <code>period</code>, <code>p</code> and <code>q</code> will be set
as expected as long as <code>period</code> is given or at least one of the
other two is of length equal to the period. A warning is issued if
<code>period &lt;= 1</code> (it is all too easy to give scalar values for
<code>p</code> and <code>q</code> and forget to set the period, in which case
<code>period</code> will be deduced to be one).
</p>
<p>A number of functions (including <code>pcarma_tovec</code> and
<code>pcarma_unvec</code>) dealing with the list representation of pcarma
models start by calling <code>pcarma_prepare</code> to avoid the need for
handling all possible cases.
</p>
<p><code>pcarma_tovec</code> returns a list with components <code>p</code>,
<code>q</code> and <code>param</code>, where <code>param</code> is a numeric vector
containing the pcarma parameters and the innovations variances and
thus is suitable for optimisation functions. Notice that it is
component param that is a vector. The reason that <code>pcarma_tovec</code>
returns a list, is that the caller may need to do further work before
calling a generic optimisation function. For exampe, it may wish to
dop the variances from the vector.
</p>
<p><code>pcarma_unvec(model)</code> performs the inverse operation. It takes a
list like that produced by <code>pcarma_tovec</code> and converts it to a
detailed list containing the components of the model.
</p>


<h3>Value</h3>

<p>for <code>pcarma_unvec</code>, a list with components:
</p>
<table role = "presentation">
<tr><td><code>p</code></td>
<td>
<p>autoregressive orders, numeric vector</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>moving average orders, numeric vector</p>
</td></tr>
<tr><td><code>si2</code></td>
<td>
<p>innovation variances</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>autoregressive parameters</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>moving average parameters</p>
</td></tr>
</table>
<p>for <code>pcarma_tovec</code>,  a list with components:
</p>
<table role = "presentation">
<tr><td><code>p</code></td>
<td>
<p>autoregressive order</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>moving average order</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>parameters of the model, a numeric vector.
TODO: give the order of the parameters in the vector!
</p>
</td></tr>
</table>
<p>for <code>pcarma_prepare</code>, a list as <code>pcarma_unvec</code>, see also
Details.
</p>


<h3>Note</h3>

<p>The specification and the functions were created ad hoc to get the
computations going and are not always consistent with other parts of
the package.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>

<hr>
<h2 id='pcCycle-methods'>Create or extract Cycle objects</h2><span id='topic+pcCycle'></span><span id='topic+pcCycle-methods'></span><span id='topic+BuiltinCycle'></span><span id='topic+pcCycle+2Ccharacter+2CANY-method'></span><span id='topic+pcCycle+2CCyclic+2CANY-method'></span><span id='topic+pcCycle+2Cnumeric+2Ccharacter-method'></span><span id='topic+pcCycle+2Cnumeric+2Cmissing-method'></span><span id='topic+pcCycle+2CBasicCycle+2Ccharacter-method'></span><span id='topic+pcCycle+2CBasicCycle+2Cmissing-method'></span><span id='topic+pcCycle+2Ccharacter+2Ccharacter-method'></span><span id='topic+pcCycle+2Ccharacter+2Cmissing-method'></span><span id='topic+pcCycle+2CPeriodicTimeSeries+2Ccharacter-method'></span><span id='topic+pcCycle+2CPeriodicTimeSeries+2Cmissing-method'></span><span id='topic+pcCycle+2Cts+2Ccharacter-method'></span><span id='topic+pcCycle+2Cts+2Cmissing-method'></span>

<h3>Description</h3>

<p><code>pcCycle()</code> is a generic function with methods for creating,
converting, modifying, and extracting cycle objects. <code>BuiltinCycle()</code> 
is a function to create cycle objects from the builtin cycle classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcCycle(x, type, ...)

BuiltinCycle(n, coerce = FALSE, first = 1, stop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcCycle-methods_+3A_x">x</code></td>
<td>

<p>an object, methods include numeric, character and cyclic objects,
see Details.
</p>
</td></tr>
<tr><td><code id="pcCycle-methods_+3A_type">type</code></td>
<td>

<p>class of the result. If equal to <code>"auto"</code>, the default, the
class is determined by the argument(s), otherwise should be the name
of a cycle class.
</p>
</td></tr>
<tr><td><code id="pcCycle-methods_+3A_...">...</code></td>
<td>

<p>further arguments for methods.
</p>
</td></tr>
<tr><td><code id="pcCycle-methods_+3A_n">n</code></td>
<td>
<p>number of seasons, an integer.</p>
</td></tr>
<tr><td><code id="pcCycle-methods_+3A_coerce">coerce</code></td>
<td>

<p>if <code>TRUE</code> coerce the objects to a modifiable cycle class,
currently <code>"SimpleCycle"</code>.
</p>
</td></tr>
<tr><td><code id="pcCycle-methods_+3A_first">first</code></td>
<td>
<p>which season is first for this object.</p>
</td></tr>
<tr><td><code id="pcCycle-methods_+3A_stop">stop</code></td>
<td>

<p>if <code>TRUE</code>, the default, throw error if there is no builtin
class with <code>n</code> seasons, otherwise create a <code>"BareCycle"</code>
object.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pcCycle</code> serves as both a constructor and extractor of cycle
objects. It is meant to just do the right thing, relieving the user
from the burden of specifying a particular cycle class.
</p>
<p>If <code>x</code> is numeric it constructs a cycle object with period
<code>x</code> and additional properties as specified by the other
arguments.  If <code>x</code> is a character string, it is taken to be the
name of one of the builtin cycles.
</p>
<p><code>pcCycle</code> can be used to create a modified version of a cycle
object and/or convert it to another cycle type. This is done by
providing a cycle object as argument <code>x</code>, i.e. one inheriting
from <code>"BasicCycle"</code>. 
</p>
<p>If <code>x</code> inherits from <code>"Cyclic"</code>, <code>pcCycle</code> returns its
cycle component.
</p>
<p>Argument <code>type</code> should be rarely needed, except maybe to
conveniently force conversion of the builtin type to an ordinary type.
</p>
<p>The descriptions of the individual methods in section Methods give
some further specific details.
</p>
<p><code>BuiltinCycle</code> is a convenience function to create objects from
builtin cycle classes by specifying the number of seasons.  The
builtin cycle classes are esseintially fixed, except that which season
is considered first can be changed using argument <code>first</code>. If
other modifications are desired, convert the returned builtin cycle
object to class <code>"SimpleCycle"</code>. This can be done also in the
call to <code>BuiltinCycle()</code> by specifying <code>coerce = TRUE</code>.
</p>
<p>By default, <code>BuiltinCycle</code> throws an error if there is no builtin
class with the requested number of seasons. Set argument <code>stop</code>
to FALSE to create an object from class <code>"BareCycle"</code> instead
(and it will be converted to <code>"SimpleCycle"</code> if <code>coerce =
  TRUE</code>). Argument <code>stop</code> is mainly for programming.
</p>


<h3>Value</h3>

<p>for <code>pcCycle</code>, an object from one of the cycle classes;
</p>
<p>for <code>BuiltinCycle</code>, an object from one of the builtin classes,
coerced if requested.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "numeric", type = "missing")</code></dt><dd>
<p>creates a cycle object with period <code>x</code>. If <code>x</code> is the only
argument, a <code>"BareCycle"</code> object is created, otherwise the
constructor of <code>"SimpleCycle"</code> is invoked with all arguments
except <code>type</code> passed on to it.
</p>
</dd>
<dt><code>signature(x = "character", type = "missing")</code></dt><dd>
<p>creates an object from the class specified by <code>x</code>.
Currently this is equivalent to <code>new(x, ...)</code> but somewhat
more portable. Future amendments may use a more suitable class
for some combinations of the arguments. Also, if a class is renamed,
a code will be inserted here to create an equivalent object.
</p>
</dd>
<dt><code>signature(x = "numeric", type = "character")</code></dt><dd> </dd>
<dt><code>signature(x = "character", type = "character")</code></dt><dd>
<p>first call the method with <code>type = "missing"</code>, then
convert the result to class <code>type</code>.
</p>
</dd>
<dt><code>signature(x = "Cyclic", type = "ANY")</code></dt><dd>
<p>extracts the cycle component of <code>x</code> (<code>x@cycle</code>).
Currently ignores the remaining arguments.
</p>
</dd>
<dt><code>signature(x = "BasicCycle", type = "missing")</code></dt><dd>
<p>convert an object from any cycle class to class
<code>"SimpleCycle"</code>. This is like <code>as(x, "SimpleCycle")</code> but
can have further arguments. 
</p>
</dd>
<dt><code>signature(x = "BasicCycle", type = "character")</code></dt><dd>
<p>convert an object from any cycle class to class
<code>type</code>. 
</p>
</dd>
<dt><code>signature(x = "ts", type = "missing")</code></dt><dd> </dd>
<dt><code>signature(x = "ts", type = "character")</code></dt><dd>
<p>when <code>x</code> is of class <code>"ts"</code>, extract the frequency and
convert it to a cycle class. Just as for <code>"ts"</code>, certain
frequencies are taken to correspond to specific classes. While base
<span class="rlang"><b>R</b></span> treats periodicities 4 and 12 specially, <code>pcCycle</code> extends
this to all builtin classes in pcts. Argument <code>type</code> can be
used to overwrite this default behaviour by requesting a specific
class. In particular, <code>type = "BareCycle"</code> and <code>type = ""</code>
cause the result to be <code>"BareCycle"</code>.
</p>
</dd>
<dt><code>signature(x = "PeriodicTimeSeries", type = "missing")</code></dt><dd> </dd>
<dt><code>signature(x = "PeriodicTimeSeries", type = "character")</code></dt><dd>
<p>extract the cycle part of an object inheriting from
<code>"PeriodicTimeSeries"</code>, currently <code>"PeriodicTS"</code> or
<code>"PeriodicMTS"</code>. Argument <code>type</code> can be used to force the
result to be from a specific cycle class, as in the methods for
<code>"ts"</code>.
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+allSeasons">allSeasons</a></code> for further examples,
</p>
<p>class <code><a href="#topic+BuiltinCycle-class">BuiltinCycle</a></code> for the available builtin
classes and more examples,
</p>
<p><code><a href="#topic+Pctime">Pctime</a></code> for representation of dates and conversion
from/to datetime objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## pcCycle
pcCycle(4)
pcCycle(4, seasons = c("Spring", "Summer", "Autumn", "Winter"))

pcCycle("QuarterYearCycle")
BuiltinCycle(4) # same, recommended

pcCycle("QuarterYearCycle", type = "BareCycle")
pcCycle("QuarterYearCycle", type = "SimpleCycle")

## BuiltinCycle
BuiltinCycle(2)  # "OpenCloseCycle"
BuiltinCycle(4)  # "QuarterYearCycle"
BuiltinCycle(5)  #  five day week cycle
BuiltinCycle(7)  # "DayWeekCycle"
BuiltinCycle(12) # "MonthYearCycle"
BuiltinCycle(48) # "Every30MinutesCycle"

## error, since there is no builtin cycle with 19 seasons:
## BuiltinCycle(19)

## use stop = FALSE to reate a default cycle in this case
BuiltinCycle(19, stop = FALSE)
BuiltinCycle(19, coerce = TRUE, stop = FALSE)
</code></pre>

<hr>
<h2 id='pclsdf'>Fit PAR models using least squares</h2><span id='topic+pclsdf'></span>

<h3>Description</h3>

<p>Fit PAR models using least squares. The model may contain
intercepts and linear trends, seasonal or non-seasonal.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pclsdf(x, d, lags = integer(0), sintercept = TRUE, sslope = FALSE,
       intercept = FALSE, slope = FALSE, xreg, contrasts = NULL,
       seasonof1st = NULL, coefonly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pclsdf_+3A_x">x</code></td>
<td>
<p>time series, a numeric vector.</p>
</td></tr>
<tr><td><code id="pclsdf_+3A_d">d</code></td>
<td>
<p>period, an integer.</p>
</td></tr>
<tr><td><code id="pclsdf_+3A_lags">lags</code></td>
<td>
<p>an integer vector, typically <code>1:p</code>, where <code>p</code> is
the order of the autoregression. The same lags are used for all
seasons.
</p>
</td></tr>
<tr><td><code id="pclsdf_+3A_sintercept">sintercept</code></td>
<td>
<p>if TRUE include seasonal intercepts.</p>
</td></tr>
<tr><td><code id="pclsdf_+3A_sslope">sslope</code></td>
<td>
<p>if TRUE include seasonal linear trend.</p>
</td></tr>
<tr><td><code id="pclsdf_+3A_intercept">intercept</code></td>
<td>
<p>if TRUE include non-seasonal intercept.</p>
</td></tr>
<tr><td><code id="pclsdf_+3A_slope">slope</code></td>
<td>
<p>if TRUE include non-seasonal linear trend.</p>
</td></tr>
<tr><td><code id="pclsdf_+3A_xreg">xreg</code></td>
<td>
<p>additional regressors, not used currently.</p>
</td></tr>

<tr><td><code id="pclsdf_+3A_contrasts">contrasts</code></td>
<td>
<p>contrasts to use for the seasons factor variable.</p>
</td></tr>
<tr><td><code id="pclsdf_+3A_seasonof1st">seasonof1st</code></td>
<td>
<p>season of the first observation in the time series,
see Details.
</p>
</td></tr>
<tr><td><code id="pclsdf_+3A_coefonly">coefonly</code></td>
<td>
<p>if TRUE, return only the parameters of the fitted
model, otherwise include also the object returned by <code>lm</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits PAR models by the method of least squares.
Seasonal intercepts are included by default. Non-seasonal intercepts
are available, as well as seasonal and non-seasonal linear trend.
Separate arguments are provided, so that any combination of seasonal
and non-seasonal intercepts and slopes can be specified.
</p>
<p>If <code>coefonly</code> is TRUE, <code>pclsdf</code> returns only the estimated
parameters, otherwise it includes additional statistical information,
see section Note for the current details.
</p>


<h3>Value</h3>

<p>A list with the components listed below. Some components are present
only if included in the model specification.
</p>
<table role = "presentation">
<tr><td><code>par</code></td>
<td>
<p>the PAR coefficients, a matrix with a row for each season.</p>
</td></tr>
<tr><td><code>sintercept</code></td>
<td>
<p>(if specified) seasonal intercepts, a numeric vector.</p>
</td></tr>
<tr><td><code>sigma2hat</code></td>
<td>
<p>innovation variances.</p>
</td></tr>
<tr><td><code>formula.char</code></td>
<td>
<p>the formula used in the call of <code>lm</code>, a
character string.
</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>(if <code>coefonly = FALSE</code>) the fitted object obtained
from <code>lm</code>.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Currently, <code>pclsdf</code> prepares a model formula according to the
specification and calls <code>lm</code> to do the fitting. Component &quot;fit&quot;
in the result (available when <code>coefonly = FALSE</code>) contains the
raw fitted object returned by <code>lm</code>. Statistical inference based
on this object would, in general, not be justified for correlated
data.
</p>
<p><strong>todo:</strong> currently some of the parameters are returned only via the
fitted object from <code>lm</code>.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pclspiar">pclspiar</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data(dataFranses1996)
cu &lt;- pcts(dataFranses1996[ , "CanadaUnemployment"])
cu &lt;- window(cu, start = availStart(cu), end = availEnd(cu))

pclsdf(cu, 4, 1:2, sintercept = TRUE)

pclsdf(austres, 4, lags = 1:3)
pclsdf(austres, 4, lags = 1:3, sintercept = TRUE)
pclsdf(austres, 4, lags = 1:3, sintercept = TRUE, sslope = TRUE)

x &lt;- rep(1:4,10)
pclsdf(x, 4, lags = 1:3, sintercept = TRUE, sslope = TRUE)

## this is for the version when contrasts arg. was passed on directly to lm.
## tmp1 &lt;- pclsdf(austres, 4, lags = 1, sintercept = FALSE, sslope = TRUE,
##                contrasts = list(Season = "contr.sum" ))
</code></pre>

<hr>
<h2 id='pclspiar'>Fit a periodically integrated autoregressive model</h2><span id='topic+pclspiar'></span>

<h3>Description</h3>

<p>Fit a periodically integrated autoregressive model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pclspiar(x, d, p, icoef = NULL, parcoef = NULL, sintercept = FALSE,
         seasonof1st = 1, weights = TRUE, itol = 1e-07, maxniter = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pclspiar_+3A_x">x</code></td>
<td>
<p>time series.</p>
</td></tr>
<tr><td><code id="pclspiar_+3A_d">d</code></td>
<td>
<p>period.</p>
</td></tr>
<tr><td><code id="pclspiar_+3A_p">p</code></td>
<td>
<p>order of the model, a positive integer, see Details.</p>
</td></tr>
<tr><td><code id="pclspiar_+3A_icoef">icoef</code></td>
<td>

<p>initial values for the periodic integration coefficients. If missing
or <code>NULL</code> suitable values are computed.
</p>
</td></tr>
<tr><td><code id="pclspiar_+3A_parcoef">parcoef</code></td>
<td>
<p>not used currently.</p>
</td></tr>
<tr><td><code id="pclspiar_+3A_sintercept">sintercept</code></td>
<td>
<p>if <code>TRUE</code> include seasonal intercepts.</p>
</td></tr>
<tr><td><code id="pclspiar_+3A_seasonof1st">seasonof1st</code></td>
<td>
<p>season of the first observation.</p>
</td></tr>
<tr><td><code id="pclspiar_+3A_weights">weights</code></td>
<td>
<p>if <code>TRUE</code>, use periodic weights in the nonlinear least
squares, see Details.
</p>
</td></tr>
<tr><td><code id="pclspiar_+3A_itol">itol</code></td>
<td>
<p>threshold value for the stopping criterion.
</p>
</td></tr>
<tr><td><code id="pclspiar_+3A_maxniter">maxniter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a periodically integrated autoregressive model
using non-linear least squares. The order of integration is one and
the order of the periodically correlated part is <code>p - 1</code>. So,
<code>p</code> must be greater than or equal to one.
</p>
<p>If <code>weights = TRUE</code> the non-linear optimisation is done with
weights inversely proportional to the innovation variances for the
seasons, otherwise the unweighted sum of squared residuals is
minimised.
</p>


<h3>Value</h3>

<p>a list currently containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>icoef</code></td>
<td>
<p>coefficients of the periodic integration filter.</p>
</td></tr>
<tr><td><code>parcoef</code></td>
<td>
<p>coefficients of the PAR filter.</p>
</td></tr>
<tr><td><code>sintercept</code></td>
<td>
<p>seasonal intercepts.</p>
</td></tr>
<tr><td><code>sigma2hat</code></td>
<td>
<p>innovation variances.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov
</p>


<h3>References</h3>

<p>Franses PH (1996).
<em>Periodicity and Stochastic Trends In Economic Time Series</em>.
Oxford University Press Inc., New York.
</p>
<p>Franses PH, Paap R (2004).
<em>Periodic Time Series Models</em>.
Oxford University Press Inc., New York.
</p>
<p>Boshnakov GN, Iqelan BM (2009).
&ldquo;Generation of time series models with given spectral properties.&rdquo;
<em>J. Time Series Anal.</em>, <b>30</b>(3), 349&ndash;368.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.2009.00617.x">doi:10.1111/j.1467-9892.2009.00617.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pclsdf">pclsdf</a></code>,
<code><a href="#topic+test_piar">test_piar</a></code>,
<code><a href="#topic+fitPM">fitPM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see also the examples for fitPM()
ts1 &lt;- window(dataFranses1996[ , "CanadaUnemployment"],
              start = c(1960, 1), end = c(1987, 4))
pclspiar(ts1, 4, p = 1, sintercept = TRUE)
pclspiar(ts1, 4, p = 2, sintercept = TRUE)
</code></pre>

<hr>
<h2 id='pcMean-methods'>Compute periodic mean</h2><span id='topic+pcMean'></span><span id='topic+pcMean-methods'></span><span id='topic+pcMean+2Cmatrix-method'></span><span id='topic+pcMean+2Cnumeric-method'></span><span id='topic+pcMean+2CPeriodicMTS-method'></span><span id='topic+pcMean+2CPeriodicTS-method'></span><span id='topic+pcMean+2CVirtualPeriodicArmaModel-method'></span>

<h3>Description</h3>

<p>Compute periodic mean, generic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcMean(object, ...)

## S4 method for signature 'numeric'
pcMean(object, nseasons, ...)

## S4 method for signature 'matrix'
pcMean(object, nseasons, ...)

## S4 method for signature 'PeriodicTS'
pcMean(object, ...)

## S4 method for signature 'PeriodicMTS'
pcMean(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcMean-methods_+3A_object">object</code></td>
<td>
<p>an object for which periodic mean makes sense.</p>
</td></tr>
<tr><td><code id="pcMean-methods_+3A_nseasons">nseasons</code></td>
<td>
<p>number of seasons.</p>
</td></tr>
<tr><td><code id="pcMean-methods_+3A_...">...</code></td>
<td>
<p>further arguments for methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For univariate periodic time series, <code>pcMean</code> computes the mean
for each season and returns a named vector. For multivariate periodic
time series, the result is a matrix with one column for each variable.
</p>
<p>The methods for <code>"numeric"</code> and <code>"matrix"</code> are equivalent to
those for <code>"PeriodicTS"</code> and <code>"PeriodicMTS"</code>,
respectively. The difference is that the latter two don't need
argument <code>nseasons</code> and take the names of the seasons from
<code>object</code>.
</p>
<p>Argument <code>na.rm = TRUE</code> can be used to omit NA's.
</p>
<p>In the univariate case, when  <code>length(object)</code> is an integer
multiple of the number of seasons the periodic mean is equivalent to
computing the row means of <code>matrix(object, nrow = nseasons)</code>.
</p>


<h3>Value</h3>

<p>numeric or matrix for the methods described here, see section
&lsquo;Details&rsquo;.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "matrix")</code></dt><dd>

</dd>
<dt><code>signature(object = "numeric")</code></dt><dd>

</dd>
<dt><code>signature(object = "PeriodicMTS")</code></dt><dd>

</dd>
<dt><code>signature(object = "PeriodicTS")</code></dt><dd>

</dd>
<dt><code>signature(object = "VirtualPeriodicArmaModel")</code></dt><dd>

</dd>
</dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcApply">pcApply</a></code> which applies an arbitrary function by season
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pcMean(pcts(presidents))
pcMean(pcts(presidents), na.rm = TRUE)

pcMean(pcts(dataFranses1996)[2:5], na.rm = TRUE)

pcMean(1:20, nseasons = 4)
m &lt;- matrix(1:20, nrow = 4)
all(apply(m, 1, mean) == pcMean(1:20, nseasons = 4)) # TRUE
</code></pre>

<hr>
<h2 id='pcPlot'>Plot periodic time series</h2><span id='topic+pcPlot'></span><span id='topic+monthplot.PeriodicTimeSeries'></span><span id='topic+boxplot.PeriodicTimeSeries'></span>

<h3>Description</h3>

<p>Plot periodic time series.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PeriodicTimeSeries'
boxplot(x, ...)

## S3 method for class 'PeriodicTimeSeries'
monthplot(x, ylab = deparse(substitute(x)), base, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcPlot_+3A_x">x</code></td>
<td>
<p>a periodic time series object.</p>
</td></tr>
<tr><td><code id="pcPlot_+3A_...">...</code></td>
<td>

<p>further arguments to be passed to the plotting function.
</p>
</td></tr>
<tr><td><code id="pcPlot_+3A_ylab">ylab</code></td>
<td>
<p>label for the y-axis, only used for univariate time series.</p>
</td></tr>
<tr><td><code id="pcPlot_+3A_base">base</code></td>
<td>
<p>a function for use for computing reference lines.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions for periodic/seasonal plots and boxplots.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+monthplot">monthplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ap &lt;- pcts(AirPassengers)
monthplot(ap)
boxplot(ap)

fr23 &lt;- pcts(dataFranses1996[ , 2:3])
monthplot(fr23)
boxplot(fr23)
</code></pre>

<hr>
<h2 id='pcTest-methods'>Test for periodicity</h2><span id='topic+pcTest'></span><span id='topic+pcTest-methods'></span><span id='topic+pcTest+2CANY+2CANY-method'></span><span id='topic+pcTest+2CANY+2Ccharacter-method'></span><span id='topic+pcTest+2CslMatrix+2Ccharacter-method'></span><span id='topic+pcTest+2Cnumeric+2Ccharacter-method'></span><span id='topic+pcTest+2CPeriodicTimeSeries+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Test for periodicity</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcTest(x, nullmodel, nseasons, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcTest-methods_+3A_x">x</code></td>
<td>
<p>the object to be tested, e.g. a time series or a periodic acf</p>
</td></tr>
<tr><td><code id="pcTest-methods_+3A_nullmodel">nullmodel</code></td>
<td>
<p>specification of the test to be performed</p>
</td></tr>
<tr><td><code id="pcTest-methods_+3A_nseasons">nseasons</code></td>
<td>
<p>number of seasons</p>
</td></tr>
<tr><td><code id="pcTest-methods_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed on to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic function which acts as a dispatcher for various
tests for periodicity and periodic correlation.
</p>
<p><code>x</code> is typically a time series but conceptually it is an object
containing the statistics needed for carrying out the requested test.
For example, <code>x</code> may be the periodic autocovariance function for
tests based on sample autocorrelations and autocovariances.
</p>
<p>The method with signature <code>(x = "ANY", nullmodel = "character"</code>) may
be considered as default for <code>pcTest</code>.  The &ldquo;real&rdquo; default
method simply prints an error message.
</p>


<h3>Value</h3>

<p>a list containing the results of the requested test,
see the individual methods for details
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "ANY", nullmodel = "character")</code></dt><dd>
<p>Argument <code>nullmodel</code> specifies the test to be performed.
It should be a single character string. If it is one of
the strings recognised by this method,  the test specified below is
carried out. Otherwise <code>nullmodel</code> is taken to be the name of a
function which is called with arguments <code>(x,...)</code>.
</p>
<p>Currently, the following character strings are recognised:
</p>

<dl>
<dt>&quot;wn&quot;</dt><dd><p>Box test for (non-periodic) white noise, simply calls <code>Box.test</code>.</p>
</dd>
<dt>&quot;piar&quot;</dt><dd><p>Franses (1996) test for periodic integration.</p>
</dd>
</dl>

</dd>
<dt><code>signature(x = "slMatrix", nullmodel = "character")</code></dt><dd>
<p><code>x</code> here is the periodic autocovariance function. This method
works similarly to the method for signature <code>(x = "ANY",
  nullmodel = "character")</code>, see its description.
</p>
<p>Currently, the following character strings are recognised:
</p>

<dl>
<dt>&quot;pwn&quot;</dt><dd><p>Ljung-Box test for periodic white noise,</p>
</dd>
<dt>&quot;periodicity&quot;</dt><dd><p>McLeod test for periodic correlation.</p>
</dd>
</dl>

</dd>
<dt><code>signature(x = "numeric", nullmodel = "character")</code></dt><dd>

</dd><dt><code>signature(x = "PeriodicTimeSeries", nullmodel = "character")</code></dt><dd>

</dd></dl>


<h3>Note</h3>

<p>TODO: critical values
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+test_piar">test_piar</a></code>,
<code><a href="#topic+pwn_McLeodLjungBox_test">pwn_McLeodLjungBox_test</a></code>
<code><a href="#topic+periodic_acf1_test">periodic_acf1_test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cu &lt;- pcts(dataFranses1996[ , "CanadaUnemployment"])
cu &lt;- window(cu, start = availStart(cu), end = availEnd(cu))

test_piar(cu, 4, 1, sintercept = TRUE)
pcTest(cu, "piar", 4, 1, sintercept = TRUE)
</code></pre>

<hr>
<h2 id='Pctime'>Convert between Pctime and datetime objects</h2><span id='topic+Pctime'></span><span id='topic+as_Pctime.Cyclic'></span><span id='topic+as_Pctime.PeriodicTimeSeries'></span><span id='topic++5B.Pctime'></span><span id='topic++5B+5B.Pctime'></span><span id='topic++5B.Date'></span><span id='topic++5B+5B.Date'></span><span id='topic++5B.ts'></span><span id='topic++5B+3C-.POSIXlt'></span><span id='topic+as_Pctime'></span>

<h3>Description</h3>

<p>Class <code>"Pctime"</code> is an S3 class inheriting from the base R
datetime class <code>"POSIXct"</code>. It has methods for conversion between
datetimes and the pcts cycle-season pairs, as well as convenience
methods for a few other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pctime(x, cycle, ...)

as_Pctime(x, ...)

## S3 method for class 'Pctime'
x[i, j, drop = TRUE]

## S3 method for class 'Pctime'
x[[..., drop = TRUE]]

## S3 method for class 'Cyclic'
as_Pctime(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Pctime_+3A_x">x</code></td>
<td>

<p>for <code>Pctime</code>, numeric vector, matrix with two columns, or any
object that is or can be converted to datetime. For the other
functions see Details.
</p>
</td></tr>
<tr><td><code id="Pctime_+3A_cycle">cycle</code></td>
<td>

<p>a positive integer, cycle object, or missing. 
</p>
</td></tr>
<tr><td><code id="Pctime_+3A_i">i</code></td>
<td>
<p>subscript</p>
</td></tr>
<tr><td><code id="Pctime_+3A_j">j</code></td>
<td>
<p>noi used</p>
</td></tr>
<tr><td><code id="Pctime_+3A_drop">drop</code></td>
<td>
<p>not used</p>
</td></tr>

<tr><td><code id="Pctime_+3A_...">...</code></td>
<td>
<p>further argument for methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Pctime</code> represents periodic times with cycle specification
contained in attribute <code>"cycle"</code>. It is basically datetime
(inheriting from <code>"POSIXct"</code>) with additional attribute(s).
</p>
<p>For printing Pctime objects are shown as cycle-season pairs.  To print
in other formats, just convert them using <code>as_datetime</code> or other
suitable function. Note though that some cycles in pcts do not have
natural datetime representation. For them, Pctime sets it arbitrarilly
as the number of seconds from a origin.
</p>
<p>The seasons in cycle-season pairs are numbered from one to the number
of seasons. Names and abbreviations are used when available and this is
the case for all builtin cycles and partial cycles obtained from them. 
</p>
<p>The cycles in cycle-season pairs are numbered from a starting point.
For years, it is what is expected. For cycles representing weeks, week 1
is the first ISO week of 1970, so <code>c(1,1)</code> corresponds to
1969-12-29. For some other cycle classes <code>c(1,1)</code> also corresponds
to the first time in the first ISO week of 1970.
</p>
<p>Subsetting with <code>"["</code> keeps the <code>Pctime</code> class, while
<code>"[["</code> returns a datetime object. Other standard functions work
with Pctime objects, as well, including <code>seq</code>.
</p>
<p>A common source of frustration is the accidental use of <code>as.Date</code>
or <code>as_date</code>, instead of <code>as.POSIXlt</code> or <code>as_datetime</code>.
These four are often equivalent, most notably for monthly, quarterly and
daily observations but, in general, conversion to dates drops the
fractional day part of a datetime.
</p>
<p>The default time zone is UTC. Other time zones can be used since the
calculations use standard datetime and date functions from base R and
package lubridate (Grolemund and Wickham 2011), but currently this has
not been tested.
</p>


<h3>Value</h3>

<p>for <code>Pctime</code>, an object from S3 class Pctime
</p>


<h3>References</h3>

<p>Grolemund G, Wickham H (2011).
&ldquo;Dates and Times Made Easy with lubridate.&rdquo;
<em>Journal of Statistical Software</em>, <b>40</b>(3), 1&ndash;25.
<a href="https://doi.org/10.18637/jss.v040.i03">doi:10.18637/jss.v040.i03</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a bare bone date for four seasons
pct4 &lt;- Pctime(c(2020, 2), pcCycle(4))
pct4

## quarterly cycle
Pctime("2020-04-01", BuiltinCycle(4))
pctQ &lt;- Pctime(c(2020, 2), BuiltinCycle(4))  # same
pctQ

## day-in-week cycle
## c(1, 1) is the start of the first ISO week of 1970
weekW1S1 &lt;- Pctime(c(1, 1), BuiltinCycle(7))  # W1 Mon
weekW1S1
as_datetime(weekW1S1)

Pctime("1970-01-01", BuiltinCycle(7)) #  W1 Thu
pctW1Th &lt;- Pctime(c(1, 4), BuiltinCycle(7))  # same
pctW1Th

Pctime("2020-04-01", BuiltinCycle(7))
pctW2623Wed &lt;- Pctime(c(2623, 3), BuiltinCycle(7))  # same
pctW2623Wed
as_datetime(pctW2623Wed)

## Monday-Friday week - a partial cycle derived from DayOfWeekCycle
BuiltinCycle(5)
pctMF &lt;- Pctime("2020-04-03", BuiltinCycle(5)) # Fri
seq(pctMF, length.out = 10) # note: Sat, Sun are skipped

Pctime("2020-04-04", BuiltinCycle(5)) # Sat, not in the cycle

## monthly cycle
Pctime("2020-04-01", BuiltinCycle(12))
pctY2020Apr &lt;- Pctime(c(50, 4), BuiltinCycle(12))  # same
pctY2020Apr
as_datetime(pctW2623Wed)

## Pctime can hold a vector of times
ap &lt;- pcts(AirPassengers)
aptime &lt;- Pctime(ap)              #  as_Pctime(ap)
aptime[1:12] # keep Pctime class
aptime[1]

aptime[[1]] # drop Pctime class

head(aptime)
tail(aptime)

apdates &lt;- as_datetime(ap)
head(apdates)
tail(apdates)
</code></pre>

<hr>
<h2 id='pcts'>Create objects from periodic time series classes</h2><span id='topic+pcts'></span><span id='topic+pcts-methods'></span><span id='topic+pcts+2CANY-method'></span><span id='topic+pcts+2Cdata.frame+2CANY-method'></span><span id='topic+pcts+2Cmatrix+2CBasicCycle-method'></span><span id='topic+pcts+2Cmatrix+2Cmissing-method'></span><span id='topic+pcts+2Cmatrix+2Cnumeric-method'></span><span id='topic+pcts+2Cmts+2Cmissing-method'></span><span id='topic+pcts+2Cmts+2Cnumeric-method'></span><span id='topic+pcts+2Cnumeric+2CBasicCycle-method'></span><span id='topic+pcts+2Cnumeric+2Cmissing-method'></span><span id='topic+pcts+2Cnumeric+2Cnumeric-method'></span><span id='topic+pcts+2Cts+2Cmissing-method'></span><span id='topic+pcts+2Cts+2Cnumeric-method'></span><span id='topic+pcts+2CxtsORzoo+2Cmissing-method'></span>

<h3>Description</h3>

<p>Create objects from periodic time series classes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcts(x, nseasons, start, ..., keep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcts_+3A_x">x</code></td>
<td>
<p>a time series.</p>
</td></tr>
<tr><td><code id="pcts_+3A_nseasons">nseasons</code></td>
<td>

<p>number of seasons. This argument is ignored by some methods.
</p>
</td></tr>
<tr><td><code id="pcts_+3A_start">start</code></td>
<td>

<p>the starting time of the time series, can be a <code>(cycle,
      season)</code> pair or any object that can be converted to datetime.
</p>
</td></tr>
<tr><td><code id="pcts_+3A_keep">keep</code></td>
<td>

<p>if <code>TRUE</code> and <code>x</code> is from class <code>"ts"</code>,
<code>"mts"</code>, <code>"zoo"</code>, or <code>"zooreg"</code>, create a periodic
object inheriting from that class.
</p>
</td></tr>
<tr><td><code id="pcts_+3A_...">...</code></td>
<td>
<p>further arguments to be passed on to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pcts</code> creates periodic time series objects inheriting from
<code>"PeriodicTimeSeries"</code>. The particular class depends on arguments
<code>x</code> and, in some cases, <code>keep</code>.  The idea is that in normal
use the user does not care about the particular class. See section
&lsquo;Methods&rsquo; for further details.
</p>
<p>Familiar functions from base-R work with the objects created by
<code>pcts</code>. The help page <code><a href="#topic+window">window</a></code> describes such methods
and gives examples.
</p>
<p>There are also methods for <code>as</code> for conversion to and from the
time series classes defined in package <span class="pkg">pcts</span>.
</p>


<h3>Value</h3>

<p>an object inheriting from <code>"PeriodicTimeSeries"</code>, the defaults
are <code>"PeriodicTS"</code> for univariate and <code>"PeriodicMTS"</code> and
for multivariate time series.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "numeric", nseasons = "missing")</code></dt><dd> </dd>
<dt><code>signature(x = "numeric", nseasons = "numeric")</code></dt><dd> </dd>
<dt><code>signature(x = "numeric", nseasons = "BasicCycle")</code></dt><dd> 
<p>Creates an object of class <code>"PeriodicTS"</code>, the native class for
univariate periodic time series in package <span class="pkg">&quot;pcts&quot;</span>.
</p>
</dd>
<dt><code>signature(x = "matrix", nseasons = "missing")</code></dt><dd> </dd>
<dt><code>signature(x = "matrix", nseasons = "numeric")</code></dt><dd> </dd>
<dt><code>signature(x = "matrix", nseasons = "BasicCycle")</code></dt><dd>
<p>Creates an object of class <code>"PeriodicMTS"</code>, the native class
for multivariate periodic time series in package <span class="pkg">&quot;pcts&quot;</span>.
</p>
</dd>
<dt><code>signature(x = "data.frame", nseasons = "ANY")</code></dt><dd>
<p>Currently this just converts <code>x</code> to matrix and calls
<code>pcts</code> recursively. See the methods with <code>x = "matrix"</code> in
the signature.
</p>
</dd>
<dt><code>signature(x = "ts", nseasons = "missing")</code></dt><dd> </dd>
<dt><code>signature(x = "ts", nseasons = "numeric")</code></dt><dd>
<p>If <code>keep = TRUE</code> creates an object of class
<code>"PeriodicTS_ts"</code>, otherwise the result is from
<code>"PeriodicTS"</code>. The number of seasons is taken from the
<code>"mts"</code> object. 
</p>
</dd>
<dt><code>signature(x = "mts", nseasons = "missing")</code></dt><dd> </dd>
<dt><code>signature(x = "mts", nseasons = "numeric")</code></dt><dd>
<p>If <code>keep = TRUE</code> creates an object of class
<code>"PeriodicMTS_ts"</code>, otherwise the result is from
<code>"PeriodicMTS"</code>. The number of seasons is taken from the
<code>"ts"</code> object.
</p>
</dd>
<dt><code>signature(x = "xtsORzoo", nseasons = "missing")</code></dt><dd>
<p><code>x</code> needs to be a regular time series, possibly with missing
values for some times (technically, <code>zoo::is.regular(x)</code> should
give TRUE). For daily time series, the cycle is taken to be day of
week or a subcycle of it, most commonly Monday-Friday.
The implementation of this method is incomplete but for daily data
should work as described.
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+PeriodicTS-class">PeriodicTS</a></code>,
<code><a href="#topic+PeriodicMTS-class">PeriodicMTS</a></code>, the two main periodic time series
classes in the package;
</p>
<p><code><a href="#topic+dataFranses1996">dataFranses1996</a></code>, <code><a href="#topic+Fraser2017">Fraser2017</a></code>,
<code><a href="#topic+four_stocks_since2016_01_01">four_stocks_since2016_01_01</a></code> for further examples;
</p>
<p><code><a href="#topic+window">window</a></code> for extraction of subsets;
</p>
<p><code><a href="#topic+pcApply">pcApply</a></code> for applying a function to each season;
</p>
<p><code><a href="#topic+Vec">Vec</a></code>,
<code><a href="#topic+tsVec">tsVec</a></code>,
<code><a href="#topic+pcMatrix">pcMatrix</a></code> for extraction of the core data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## convert a ts object, no need for further info
pcts(AirPassengers, 12)

## numeric
v24 &lt;- rnorm(24)
pcts(v24, nseasons = 4)          # generic seasons
pcts(v24, nseasons = BuiltinCycle(4)) # Quarter/Year
ts1 &lt;- pcts(v24, nseasons = BuiltinCycle(4), c(2006, 1)) # Quarter/Year with dates

## select subset of the seasons
window(ts1, seasons = 3:4)

## matrix, multivariate pcts
m24 &lt;- matrix(v24, ncol =3)
colnames(m24) &lt;- c("A", "B", "C")
pcts(m24, nseasons = 4)          # generic seasons
pcts(m24, nseasons = BuiltinCycle(4)) # Quarter/Year
mts1 &lt;- pcts(m24, nseasons = BuiltinCycle(4), c(2006, 1)) # Quarter/Year with dates
mts1

## select subset of the seasons for mutivariate
window(mts1, seasons = 3:4)
</code></pre>

<hr>
<h2 id='pcts_exdata'>Periodic time series objects for examples</h2><span id='topic+pcts_exdata'></span>

<h3>Description</h3>

<p>Periodic time series objects for examples and tests. These objects are
from classes defined in package &ldquo;pcts&rdquo; and as a consequence are
not suitable for access with <code>data()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcts_exdata(x, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcts_exdata_+3A_x">x</code></td>
<td>

<p>a character vector giving the names of objects. If missing, all
available objects will be created. Can also be <code>NA</code>. In that
case no objects are created and the names of all available objects
are returned.
</p>
</td></tr>
<tr><td><code id="pcts_exdata_+3A_envir">envir</code></td>
<td>

<p>environment where the objects are put, the default is the
environment of the caller.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The requested objects are created and put in <code>envir</code>.  Its
default is the environment of the caller, which should be sufficient
in most use cases.
</p>
<p>The following objects are currently available:
<code>ap</code>, <code>ap7to9</code>, <code>pcfr</code>, <code>pcfr2to4</code>.
</p>


<h3>Value</h3>

<p>if <code>x</code> is <code>NA</code>, the names of the available objects.
Otherwise the function is called for the side effect of creating
objects in <code>envir</code> and the return value (the names of the created
objects) is usually discarded.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dataFranses1996">dataFranses1996</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## the objects are created with something like:
ap &lt;- pcts(AirPassengers)
ap7to9 &lt;- window(ap, seasons = 7:9)

pcfr &lt;- pcts(dataFranses1996)
pcfr2to4 &lt;- pcfr[2:4]
</code></pre>

<hr>
<h2 id='pcts_reexports'>Objects exported from other packages</h2><span id='topic+pcts_reexports'></span><span id='topic+slMatrix'></span><span id='topic+date'></span><span id='topic+as.Date'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>lagged</dt><dd><p><code><a href="lagged.html#topic+slMatrix">slMatrix</a></code></p>
</dd>
<dt>date</dt><dd><p><code><a href="lubridate.html#topic+date">date</a></code></p>
</dd>
<dt>as.Date</dt><dd><p><code><a href="zoo.html#topic+as.Date">as.Date</a></code></p>
</dd>
</dl>


<hr>
<h2 id='pcts-deprecated'>Deprecated Functions and classes in Package <span class="pkg">pcts</span></h2><span id='topic+pcts-deprecated'></span><span id='topic+mCpar'></span><span id='topic+sim_arAcf'></span><span id='topic+ptildeorders'></span><span id='topic+FiveDayWeekCycle-class'></span><span id='topic+allSeasons+2CFiveDayWeekCycle+2Clogical-method'></span><span id='topic+allSeasons+2CFiveDayWeekCycle+2Cmissing-method'></span><span id='topic+nSeasons+2CFiveDayWeekCycle-method'></span><span id='topic+unitCycle+2CFiveDayWeekCycle-method'></span><span id='topic+unitSeason+2CFiveDayWeekCycle-method'></span>

<h3>Description</h3>

<p>These functions and classes are marked for removal and are provided
temporarily for compatibility with older versions of package
<span class="pkg">pcts</span> only. Use the recommended renamed or new functions instead.
</p>
<p>Class <code>"FiveDayWeekCycle"</code> is deprecated, use
<code>BuiltinCycle(5)</code> to create objects with equivalent
functionality, see <code><a href="#topic+BuiltinCycle">BuiltinCycle</a></code>.
</p>


<h3>Details</h3>


<dl>
<dt>mCpar</dt><dd><p>has been renamed to <code>sim_parCoef</code></p>
</dd>
<dt>sim_arAcf</dt><dd><p>has been renamed to <code>sim_parAcvf</code></p>
</dd>
</dl>


<hr>
<h2 id='pdSafeParOrder'> Functions for some basic operations with seasons</h2><span id='topic+pdSafeParOrder'></span>

<h3>Description</h3>

<p>Functions for some basic operations with seasons.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdSafeParOrder(p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pdSafeParOrder_+3A_p">p</code></td>
<td>
<p>autoregression order, a vector of integers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pdSafeParOrder(p)</code> modifies the periodic AR order specified by vector
<code>p</code>. The modified order is such that the correspondence between
autocovariances and partial autocorrelations is one-to-one, see
the references for details.
</p>


<h3>Value</h3>

<p>a vector of integers
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>


<p>Lambert-Lacroix S (2000).
&ldquo;On periodic autoregressive process estimation .&rdquo;
<em> IEEE Transactions on Signal Processing</em>, <b>48</b>( 6 ), pp. 1800-1803.
</p>

<p>Lambert-Lacroix S (2005).
&ldquo; Extension of autocovariance coefficients sequence for periodically correlated
processes.&rdquo;
<em>Journal of Time Series Analysis</em>, <b>26</b>(6), pp. 423-435.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pdSafeParOrder(c(0,2))
pdSafeParOrder(c(2,3))
</code></pre>

<hr>
<h2 id='periodic_acf1_test'>McLeod's test for periodic autocorrelation</h2><span id='topic+periodic_acf1_test'></span>

<h3>Description</h3>

<p>Performs McLeod's test for periodic autocorrelation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>periodic_acf1_test(acf, nepochs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="periodic_acf1_test_+3A_acf">acf</code></td>
<td>
<p> sample periodic autocorrelation function </p>
</td></tr>
<tr><td><code id="periodic_acf1_test_+3A_nepochs">nepochs</code></td>
<td>
<p> the number of epochs used to get the acf </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test statistic is a scaled sum of squares of lag 1 sample periodic
autocorrelation coefficients, see McLeod (1993), eq. (5). The
distribution is approximately chi-square under the null hypothesis of
no periodic autocorrelation.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the  test statistic.</p>
</td></tr>
<tr><td><code>pvalue</code></td>
<td>
<p>the p-value associated with the  test statistic.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>McLeod AI (1993).
&ldquo;Parsimony, model adequacy and periodic correlation in time series forecasting.&rdquo;
<em>Internat. Statist. Rev.</em>, <b>61</b>(3), 387-393.
</p>
<p>McLeod AI (1994).
&ldquo;Diagnostic checking of periodic autoregression models with application.&rdquo;
<em>Journal of Time Series Analysis</em>, <b>15</b>(2), 221&ndash;233.
</p>
<p>McLeod AI (1995).
&ldquo;Diagnostic checking of periodic autoregression models with application.&rdquo;
<em>Journal of Time Series Analysis</em>, <b>16</b>(6), 647-648.
<a href="https://doi.org/10.1111/j.1467-9892.1995.tb00260.x">doi:10.1111/j.1467-9892.1995.tb00260.x</a>, This corrects some typos in the eponimous article  McLeod (1994).
</p>

<hr>
<h2 id='PeriodicArmaFilter-class'>Class <code>"PeriodicArmaFilter"</code></h2><span id='topic+PeriodicArmaFilter-class'></span><span id='topic+PeriodicArFilter-class'></span><span id='topic+PeriodicMaFilter-class'></span>

<h3>Description</h3>

<p>Class PeriodicArmaFilter.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PeriodicArmaFilter", ..., ar, ma, nseasons)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ar</code>:</dt><dd><p>Object of class <code>"PeriodicBJFilter"</code> ~~ </p>
</dd>
<dt><code>ma</code>:</dt><dd><p>Object of class <code>"PeriodicSPFilter"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="sarima.html#topic+VirtualArmaFilter-class">VirtualArmaFilter</a>"</code>, directly.
Class <code>"<a href="sarima.html#topic+VirtualMonicFilter-class">VirtualMonicFilter</a>"</code>, by class &quot;VirtualArmaFilter&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p><code>signature(from = "PeriodicArmaFilter", to = "PeriodicArFilter")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "PeriodicArmaFilter", to = "PeriodicMaFilter")</code>: ... </p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "PeriodicArmaFilter")</code>: ... </p>
</dd>
<dt>maxLag</dt><dd><p><code>signature(object = "PeriodicArmaFilter")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "PeriodicArmaFilter")</code>: ... </p>
</dd>
</dl>


<hr>
<h2 id='PeriodicArmaModel-class'>Class PeriodicArmaModel</h2><span id='topic+PeriodicArmaModel-class'></span>

<h3>Description</h3>

<p>Class PeriodicArmaModel.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PeriodicArmaModel", ar, ma, sigma2, ...)</code>.
</p>


<h3>Slots</h3>



<dl>
<dt><code>sigma2</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>ar</code>:</dt><dd><p>Object of class <code>"PeriodicArFilter"</code> ~~ </p>
</dd>
<dt><code>ma</code>:</dt><dd><p>Object of class <code>"PeriodicMaFilter"</code> ~~ </p>
</dd>
<dt><code>center</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>intercept</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>modelCycle</code>:</dt><dd><p>Object of class <code>"BasicCycle"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+VirtualPeriodicArmaModel-class">VirtualPeriodicArmaModel</a>"</code>, directly.
Class <code>"<a href="#topic+PeriodicArmaSpec-class">PeriodicArmaSpec</a>"</code>, directly.
Class <code>"<a href="#topic+VirtualPeriodicFilterModel-class">VirtualPeriodicFilterModel</a>"</code>, by class &quot;VirtualPeriodicArmaModel&quot;, distance 2.
Class <code>"<a href="#topic+VirtualPeriodicStationaryModel-class">VirtualPeriodicStationaryModel</a>"</code>, by class &quot;VirtualPeriodicArmaModel&quot;, distance 2.
Class <code>"<a href="#topic+PeriodicArmaFilter-class">PeriodicArmaFilter</a>"</code>, by class &quot;PeriodicArmaSpec&quot;, distance 2.
Class <code>"<a href="#topic+VirtualPeriodicAutocovarianceModel-class">VirtualPeriodicAutocovarianceModel</a>"</code>, by class &quot;VirtualPeriodicArmaModel&quot;, distance 3.
Class <code>"<a href="#topic+VirtualPeriodicMeanModel-class">VirtualPeriodicMeanModel</a>"</code>, by class &quot;VirtualPeriodicArmaModel&quot;, distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>autocovariances</dt><dd><p><code>signature(x = "PeriodicArmaModel", maxlag = "ANY")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "PeriodicArmaModel", to = "list")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "PeriodicArmaModel", to = "PeriodicArModel")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "PeriodicArmaModel")</code>: ... </p>
</dd>
</dl>


<hr>
<h2 id='PeriodicArmaSpec-class'>Class PeriodicArmaSpec</h2><span id='topic+PeriodicArmaSpec-class'></span><span id='topic+innovationVariances+2CPeriodicArmaSpec-method'></span>

<h3>Description</h3>

<p>Class PeriodicArmaSpec.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PeriodicArmaSpec", pcmean, pcintercept, ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>sigma2</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>ar</code>:</dt><dd><p>Object of class <code>"PeriodicArFilter"</code> ~~ </p>
</dd>
<dt><code>ma</code>:</dt><dd><p>Object of class <code>"PeriodicMaFilter"</code> ~~ </p>
</dd>
<dt><code>center</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>intercept</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>modelCycle</code>:</dt><dd><p>Object of class <code>"BasicCycle"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+PeriodicArmaFilter-class">PeriodicArmaFilter</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>Functions with methods for this class:
</p>

<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "PeriodicArmaSpec")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "PeriodicArmaSpec")</code>: ... </p>
</dd>
</dl>


<hr>
<h2 id='PeriodicArModel-class'>Class PeriodicArModel</h2><span id='topic+PeriodicArModel-class'></span>

<h3>Description</h3>

<p>Class PeriodicArModel.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PeriodicArModel", ar, ma, sigma2, ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>sigma2</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>ar</code>:</dt><dd><p>Object of class <code>"PeriodicArFilter"</code> ~~ </p>
</dd>
<dt><code>ma</code>:</dt><dd><p>Object of class <code>"PeriodicMaFilter"</code> ~~ </p>
</dd>
<dt><code>center</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>intercept</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>modelCycle</code>:</dt><dd><p>Object of class <code>"BasicCycle"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+PeriodicArmaModel-class">PeriodicArmaModel</a>"</code>, directly.
Class <code>"<a href="#topic+VirtualPeriodicArmaModel-class">VirtualPeriodicArmaModel</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 2.
Class <code>"<a href="#topic+PeriodicArmaSpec-class">PeriodicArmaSpec</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 2.
Class <code>"<a href="#topic+VirtualPeriodicFilterModel-class">VirtualPeriodicFilterModel</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 3.
Class <code>"<a href="#topic+VirtualPeriodicStationaryModel-class">VirtualPeriodicStationaryModel</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 3.
Class <code>"<a href="#topic+PeriodicArmaFilter-class">PeriodicArmaFilter</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 3.
Class <code>"<a href="#topic+VirtualPeriodicAutocovarianceModel-class">VirtualPeriodicAutocovarianceModel</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 4.
Class <code>"<a href="#topic+VirtualPeriodicMeanModel-class">VirtualPeriodicMeanModel</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 4.
</p>


<h3>Methods</h3>


<dl>
<dt>autocovariances</dt><dd><p><code>signature(x = "PeriodicArModel", maxlag = "ANY")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "PeriodicArmaModel", to = "PeriodicArModel")</code>: ... </p>
</dd>
<dt>fitPM</dt><dd><p><code>signature(model = "PeriodicArModel", x = "ANY")</code>: ... </p>
</dd>
<dt>fitPM</dt><dd><p><code>signature(model = "PeriodicArModel", x = "PeriodicMTS")</code>: ... </p>
</dd>
<dt>fitPM</dt><dd><p><code>signature(model = "PeriodicArModel", x = "PeriodicTS")</code>: ... </p>
</dd>
<dt>partialCoefficients</dt><dd><p><code>signature(x = "PeriodicArModel")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "PeriodicArModel")</code>: ... </p>
</dd>
</dl>


<hr>
<h2 id='PeriodicArModel-methods'>Create objects from class PeriodicArModel</h2><span id='topic+PeriodicArModel'></span><span id='topic+PeriodicArModel-methods'></span><span id='topic+PeriodicArModel+2Cmatrix-method'></span><span id='topic+PeriodicArModel+2Cnumeric-method'></span><span id='topic+PeriodicArModel+2CPeriodicArmaModel-method'></span><span id='topic+PeriodicArModel+2CPeriodicMonicFilterSpec-method'></span><span id='topic+PeriodicArModel+2CVirtualPeriodicArmaModel-method'></span>

<h3>Description</h3>

<p>Create objects from class PeriodicArModel</p>


<h3>Usage</h3>

<pre><code class='language-R'>PeriodicArModel(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PeriodicArModel-methods_+3A_object">object</code></td>
<td>
<p>an object, can have one of a number of classes.</p>
</td></tr>
<tr><td><code id="PeriodicArModel-methods_+3A_...">...</code></td>
<td>
<p>further arguments for methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>PeriodicArModel</code> creates objects from class
<code>PeriodicArModel</code>. This is a generic function with dispatch methods on
the first argument.
</p>


<h3>Value</h3>

<p>an object from class <code>"PeriodicArModel"</code>
</p>


<h3>Methods</h3>



<dl>
<dt><code>signature(object = "matrix")</code></dt><dd>
<p><code>"object"</code> gives the coefficients, one row per season.
</p>
</dd>
<dt><code>signature(object = "numeric")</code></dt><dd>
<p><code>"object"</code> gives the model order. Its length is taken to be
the number of seasons. The coefficients are set to NA.
</p>
</dd>
<dt><code>signature(object = "PeriodicMonicFilterSpec")</code></dt><dd>

</dd><dt><code>signature(object = "VirtualPeriodicArmaModel")</code></dt><dd>

</dd><dt><code>signature(object = "PeriodicMonicFilterSpec")</code></dt><dd>

</dd><dt><code>signature(object = "VirtualPeriodicArmaModel")</code></dt><dd>

</dd></dl>

<hr>
<h2 id='PeriodicAutocorrelations-class'>Class PeriodicAutocorrelations</h2><span id='topic+PeriodicAutocorrelations-class'></span><span id='topic+plot+2CPeriodicAutocorrelations+2Cmissing-method'></span>

<h3>Description</h3>

<p>Class PeriodicAutocorrelations.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PeriodicAutocorrelations", ..., data)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>modelCycle</code>:</dt><dd><p>Object of class <code>"BasicCycle"</code> ~~ </p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"Lagged"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+ModelCycleSpec-class">ModelCycleSpec</a>"</code>, directly.
Class <code>"<a href="lagged.html#topic+FlexibleLagged-class">FlexibleLagged</a>"</code>, directly.
Class <code>"<a href="#topic+VirtualPeriodicAutocorrelations-class">VirtualPeriodicAutocorrelations</a>"</code>, directly.
Class <code>"<a href="lagged.html#topic+Lagged-class">Lagged</a>"</code>, by class &quot;FlexibleLagged&quot;, distance 2.
Class <code>"<a href="#topic+VirtualPeriodicModel-class">VirtualPeriodicModel</a>"</code>, by class &quot;VirtualPeriodicAutocorrelations&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = "PeriodicAutocorrelations", y = "missing")</code>: ... </p>
</dd>
</dl>


<hr>
<h2 id='PeriodicAutocovariances-class'>Class PeriodicAutocovariances</h2><span id='topic+PeriodicAutocovariances-class'></span>

<h3>Description</h3>

<p>Class PeriodicAutocovariances.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PeriodicAutocovariances", ..., data)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>modelCycle</code>:</dt><dd><p>Object of class <code>"BasicCycle"</code> ~~ </p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"Lagged"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+ModelCycleSpec-class">ModelCycleSpec</a>"</code>, directly.
Class <code>"<a href="lagged.html#topic+FlexibleLagged-class">FlexibleLagged</a>"</code>, directly.
Class <code>"<a href="#topic+VirtualPeriodicAutocovariances-class">VirtualPeriodicAutocovariances</a>"</code>, directly.
Class <code>"<a href="lagged.html#topic+Lagged-class">Lagged</a>"</code>, by class &quot;FlexibleLagged&quot;, distance 2.
Class <code>"<a href="#topic+VirtualPeriodicModel-class">VirtualPeriodicModel</a>"</code>, by class &quot;VirtualPeriodicAutocovariances&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>autocorrelations</dt><dd><p><code>signature(x = "PeriodicAutocovariances", maxlag = "ANY", lag_0 = "missing")</code>: ... </p>
</dd>
<dt>partialAutocorrelations</dt><dd><p><code>signature(x = "PeriodicAutocovariances", maxlag = "ANY", lag_0 = "missing")</code>: ... </p>
</dd>
</dl>


<hr>
<h2 id='PeriodicBJFilter-class'>Class PeriodicBJFilter</h2><span id='topic+PeriodicBJFilter-class'></span><span id='topic+PeriodicMonicFilterSpec-class'></span>

<h3>Description</h3>

<p>A class for filters following the Box-Jenkins sign convention</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PeriodicBJFilter", coef, order, ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>coef</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>order</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+PeriodicMonicFilterSpec-class">PeriodicMonicFilterSpec</a>"</code>, directly.
Class <code>"<a href="sarima.html#topic+VirtualBJFilter-class">VirtualBJFilter</a>"</code>, directly.
Class <code>"<a href="sarima.html#topic+VirtualMonicFilterSpec-class">VirtualMonicFilterSpec</a>"</code>, by class &quot;PeriodicMonicFilterSpec&quot;, distance 2.
Class <code>"<a href="sarima.html#topic+VirtualMonicFilter-class">VirtualMonicFilter</a>"</code>, by class &quot;VirtualBJFilter&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>filterCoef</dt><dd><p><code>signature(object = "PeriodicBJFilter", convention = "character")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "matrix", to = "PeriodicBJFilter")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "PeriodicBJFilter", to = "PeriodicSPFilter")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "PeriodicSPFilter", to = "PeriodicBJFilter")</code>: ... </p>
</dd>
<dt>filterPoly</dt><dd><p><code>signature(object = "PeriodicBJFilter")</code>: ... </p>
</dd>
<dt>filterPolyCoef</dt><dd><p><code>signature(object = "PeriodicBJFilter")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "PeriodicBJFilter")</code>: ... </p>
</dd></dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+PeriodicSPFilter-class">PeriodicSPFilter</a></code>
</p>
<p><code><a href="sarima.html#topic+filterCoef">filterCoef</a></code> for more details on the generics
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a toy filter of order c(3, 3, 3, 3) and 4 seasons
co &lt;- matrix(c(1, 1, 0,
               2, 2, 2,
               3, 0, 0,
               4, 4, 4), nrow = 4, ncol = 3)

## these are equivalent:
bj1 &lt;- new("PeriodicBJFilter", coef = co)
bj1b &lt;- new("PeriodicBJFilter", coef = co, order = 3)
bj1c &lt;- new("PeriodicBJFilter", coef = co, order = c(3, 3, 3, 3))
identical(bj1b, bj1c) # TRUE
identical(bj1, bj1b) # FALSE but only because classbj1@order is "integer"

    
## a more refined spec. for the order:
show( new("PeriodicBJFilter", coef = co, order = c(2, 3, 1, 3)) )

## as()
show( as(co, "PeriodicBJFilter") )
show( as(co, "PeriodicSPFilter") )

## change the sign convention:
sp1 &lt;- as(bj1, "PeriodicSPFilter")

## the two parameterisations have different signs:
bj1
sp1

## nevertheless, bj1 and sp1 represent the same filter
filterPoly(bj1)
filterPoly(sp1)
identical(filterPoly(bj1), filterPoly(sp1)) # TRUE

filterPolyCoef(bj1)
filterPolyCoef(sp1)
identical(filterPolyCoef(bj1), filterPolyCoef(sp1)) # TRUE

filterOrder(bj1)
nSeasons(bj1)
</code></pre>

<hr>
<h2 id='PeriodicFilterModel-class'>Class PeriodicFilterModel</h2><span id='topic+PeriodicFilterModel-class'></span>

<h3>Description</h3>

<p>Class PeriodicFilterModel.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PeriodicFilterModel", pcmean, pcintercept, ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>center</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>intercept</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>sigma2</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>ar</code>:</dt><dd><p>Object of class <code>"PeriodicArFilter"</code> ~~ </p>
</dd>
<dt><code>ma</code>:</dt><dd><p>Object of class <code>"PeriodicMaFilter"</code> ~~ </p>
</dd>
<dt><code>modelCycle</code>:</dt><dd><p>Object of class <code>"BasicCycle"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+VirtualPeriodicFilterModel-class">VirtualPeriodicFilterModel</a>"</code>, directly.
Class <code>"<a href="#topic+PeriodicArmaSpec-class">PeriodicArmaSpec</a>"</code>, directly.
Class <code>"<a href="#topic+PeriodicArmaFilter-class">PeriodicArmaFilter</a>"</code>, by class &quot;PeriodicArmaSpec&quot;, distance 2.
</p>


<h3>Methods</h3>

<p>Functions with methods for this class:
</p>

<dl>
<dt>show</dt><dd><p><code>signature(object = "PeriodicFilterModel")</code>: ... </p>
</dd>
</dl>


<hr>
<h2 id='PeriodicIntegratedArmaSpec-class'>Class PeriodicIntegratedArmaSpec</h2><span id='topic+PeriodicIntegratedArmaSpec-class'></span>

<h3>Description</h3>

<p>Class PeriodicIntegratedArmaSpec.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PeriodicIntegratedArmaSpec", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>pcmodel</code>:</dt><dd><p>Object of class <code>"PeriodicArmaModel"</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>sigmaSq</dt><dd><p><code>signature(object = "PeriodicIntegratedArmaSpec")</code>: ... </p>
</dd>
<dt>nSeasons</dt><dd><p><code>signature(object = "PeriodicIntegratedArmaSpec")</code>: ...</p>
</dd>
</dl>


<hr>
<h2 id='PeriodicInterceptSpec-class'>Class PeriodicInterceptSpec</h2><span id='topic+PeriodicInterceptSpec-class'></span>

<h3>Description</h3>

<p>Class PeriodicInterceptSpec.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PeriodicInterceptSpec", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>center</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>intercept</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>sigma2</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>modelCycle</code>:</dt><dd><p>Object of class <code>"BasicCycle"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="methods.html#topic+numeric-class">numeric</a>"</code>, from data part.
Class <code>"<a href="methods.html#topic+vector-class">vector</a>"</code>, by class &quot;numeric&quot;, distance 2.
Class <code>"<a href="Matrix.html#topic+index-class">index</a>"</code>, by class &quot;numeric&quot;, distance 2.
Class <code>"<a href="Matrix.html#topic+replValue-class">replValue</a>"</code>, by class &quot;numeric&quot;, distance 2.
Class <code>"numLike"</code>, by class &quot;numeric&quot;, distance 2.
Class <code>"<a href="Matrix.html#topic+number-class">number</a>"</code>, by class &quot;numeric&quot;, distance 2.
Class <code>"<a href="Matrix.html#topic+atomicVector-class">atomicVector</a>"</code>, by class &quot;numeric&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>sigmaSq</dt><dd><p><code>signature(object = "PeriodicInterceptSpec")</code>: ... </p>
</dd>
<dt>allSeasons</dt><dd><p><code>signature(x = "PeriodicInterceptSpec", abb = "ANY")</code>: ... </p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "PeriodicInterceptSpec")</code>: ... </p>
</dd>
<dt>nSeasons</dt><dd><p><code>signature(object = "PeriodicInterceptSpec")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "PeriodicInterceptSpec")</code>:
... </p>
</dd>
</dl>


<hr>
<h2 id='PeriodicMaModel-class'>Class PeriodicMaModel</h2><span id='topic+PeriodicMaModel-class'></span>

<h3>Description</h3>

<p>Class PeriodicMaModel.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PeriodicMaModel", ar, ma, sigma2, ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>sigma2</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>ar</code>:</dt><dd><p>Object of class <code>"PeriodicArFilter"</code> ~~ </p>
</dd>
<dt><code>ma</code>:</dt><dd><p>Object of class <code>"PeriodicMaFilter"</code> ~~ </p>
</dd>
<dt><code>center</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>intercept</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>modelCycle</code>:</dt><dd><p>Object of class <code>"BasicCycle"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+PeriodicArmaModel-class">PeriodicArmaModel</a>"</code>, directly.
Class <code>"<a href="#topic+VirtualPeriodicArmaModel-class">VirtualPeriodicArmaModel</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 2.
Class <code>"<a href="#topic+PeriodicArmaSpec-class">PeriodicArmaSpec</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 2.
Class <code>"<a href="#topic+VirtualPeriodicFilterModel-class">VirtualPeriodicFilterModel</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 3.
Class <code>"<a href="#topic+VirtualPeriodicStationaryModel-class">VirtualPeriodicStationaryModel</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 3.
Class <code>"<a href="#topic+PeriodicArmaFilter-class">PeriodicArmaFilter</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 3.
Class <code>"<a href="#topic+VirtualPeriodicAutocovarianceModel-class">VirtualPeriodicAutocovarianceModel</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 4.
Class <code>"<a href="#topic+VirtualPeriodicMeanModel-class">VirtualPeriodicMeanModel</a>"</code>, by class &quot;PeriodicArmaModel&quot;, distance 4.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "PeriodicMaModel")</code>: ... </p>
</dd>
</dl>


<hr>
<h2 id='PeriodicMTS_ts-class'>Class <code>"PeriodicMTS_ts"</code></h2><span id='topic+PeriodicMTS_ts-class'></span>

<h3>Description</h3>

<p>Class <code>"PeriodicMTS_ts"</code> is a periodic class holding
multivariate <code>"ts"</code> objects.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PeriodicMTS_ts", x, ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"vector"</code> ~~ </p>
</dd>
<dt><code>cycle</code>:</dt><dd><p>Object of class <code>"BasicCycle"</code> ~~ </p>
</dd>
<dt><code>pcstart</code>:</dt><dd><p>Object of class <code>"ANY"</code> ~~ </p>
</dd>
<dt><code>tsp</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>.S3Class</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+PeriodicTimeSeries-class">PeriodicTimeSeries</a>"</code>, directly.
Class <code>"<a href="methods.html#topic+ts-class">ts</a>"</code>, directly.
Class <code>"<a href="#topic+Cyclic-class">Cyclic</a>"</code>, by class &quot;PeriodicTimeSeries&quot;, distance 2.
Class <code>"<a href="methods.html#topic+structure-class">structure</a>"</code>, by class &quot;ts&quot;, distance 2.
Class <code>"<a href="methods.html#topic+oldClass-class">oldClass</a>"</code>, by class &quot;ts&quot;, distance 2.
Class <code>"<a href="methods.html#topic+vector-class">vector</a>"</code>, by class &quot;ts&quot;, distance 3, with explicit coerce.
</p>


<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p><code>signature(from = "ts", to = "PeriodicMTS_ts")</code>: ... </p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "PeriodicMTS_ts")</code>: ... </p>
</dd>
</dl>


<hr>
<h2 id='PeriodicMTS_zooreg-class'>Class <code>"PeriodicMTS_zooreg"</code></h2><span id='topic+PeriodicMTS_zooreg-class'></span>

<h3>Description</h3>

<p>Class <code>"PeriodicMTS_zooreg"</code> is a periodic class holding
multivariate <code>"zooreg"</code> objects.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PeriodicMTS_zooreg", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>cycle</code>:</dt><dd><p>Object of class <code>"BasicCycle"</code> ~~ </p>
</dd>
<dt><code>.S3Class</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>pcstart</code>:</dt><dd><p>Object of class <code>"ANY"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+PeriodicTimeSeries-class">PeriodicTimeSeries</a>"</code>, directly.
Class <code>"<a href="methods.html#topic+ts-class">ts</a>"</code>, directly.
Class <code>"<a href="#topic+Cyclic-class">Cyclic</a>"</code>, by class &quot;PeriodicTimeSeries&quot;, distance 2.
Class <code>"<a href="methods.html#topic+structure-class">structure</a>"</code>, by class &quot;ts&quot;, distance 2.
Class <code>"<a href="methods.html#topic+oldClass-class">oldClass</a>"</code>, by class &quot;ts&quot;, distance 2.
Class <code>"<a href="methods.html#topic+vector-class">vector</a>"</code>, by class &quot;ts&quot;, distance 3, with explicit coerce.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;PeriodicMTS_zooreg&quot; in the signature.
</p>

<hr>
<h2 id='PeriodicMTS-class'>Class <code>"PeriodicMTS"</code></h2><span id='topic+PeriodicMTS-class'></span><span id='topic+plot+2CPeriodicMTS+2Cmissing-method'></span>

<h3>Description</h3>

<p>Class <code>"PeriodicMTS"</code> is the main class for multivariate periodic
time series in package <code>"pcts"</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form
<code>new("PeriodicMTS", ...)</code> but it is recommended to use 
the function <code><a href="#topic+pcts">pcts</a></code> in most cases. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"matrix"</code>,
the core data.  Several functions can be used to extract it in
various formats, see <code><a href="#topic+Vec">Vec</a></code>.
</p>
</dd>
<dt><code>cycle</code>:</dt><dd><p>Object of class <code>"BasicCycle"</code>,
representing the seasonal information, see
<code><a href="#topic+pcCycle">pcCycle</a></code>. 
</p>
</dd>
<dt><code>pcstart</code>:</dt><dd><p>Object of class <code>"ANY"</code>,
the time of the first observation.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+PeriodicTimeSeries-class">PeriodicTimeSeries</a>"</code>, directly.
Class <code>"<a href="methods.html#topic+matrix-class">matrix</a>"</code>, from data part.
Class <code>"<a href="#topic+Cyclic-class">Cyclic</a>"</code>, by class &quot;PeriodicTimeSeries&quot;, distance 2.
Class <code>"<a href="methods.html#topic+array-class">array</a>"</code>, by class &quot;matrix&quot;, distance 2.
Class <code>"mMatrix"</code>, by class &quot;matrix&quot;, distance 2.
Class <code>"<a href="mcompanion.html#topic+optionalMatrix-class">optionalMatrix-class</a>"</code>, by class &quot;matrix&quot;, distance 2.
Class <code>"<a href="methods.html#topic+structure-class">structure</a>"</code>, by class &quot;matrix&quot;, distance 3.
Class <code>"<a href="methods.html#topic+vector-class">vector</a>"</code>, by class &quot;matrix&quot;, distance 4, with explicit coerce.
</p>


<h3>Methods</h3>


<dl>
<dt>$</dt><dd><p><code>signature(x = "PeriodicMTS")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "PeriodicMTS", i = "missing", j = "missing", drop = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "PeriodicMTS", i = "ANY", j = "missing", drop = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "PeriodicMTS", i = "ANY", j = "ANY", drop = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "PeriodicMTS", i = "AnyDateTime", j = "missing", drop = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "PeriodicMTS", i = "AnyDateTime", j = "ANY", drop = "ANY")</code>: ... </p>
</dd>
<dt>[[</dt><dd><p><code>signature(x = "PeriodicMTS", i = "ANY", j = "ANY")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "mts", to = "PeriodicMTS")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "PeriodicMTS", to = "ts")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "ts", to = "PeriodicMTS")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "PeriodicMTS", to = "Cyclic")</code>: ... </p>
</dd>
<dt>coerce&lt;-</dt><dd><p><code>signature(from = "PeriodicMTS", to = "Cyclic")</code>: ... </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "PeriodicMTS", y = "missing")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "PeriodicMTS")</code>: ... </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "PeriodicMTS")</code>: ... </p>
</dd>
<dt>fitPM</dt><dd><p><code>signature(model = "PeriodicArModel", x = "PeriodicMTS")</code>: ... </p>
</dd>
<dt>pcApply</dt><dd><p><code>signature(object = "PeriodicMTS")</code>: ... </p>
</dd>
<dt>pcMean</dt><dd><p><code>signature(object = "PeriodicMTS")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

<p>class <code><a href="#topic+PeriodicTS-class">PeriodicTS</a></code> (univariate periodic time series),
</p>
<p><code><a href="#topic+pcts">pcts</a></code> (create periodic time series),
</p>
<p><code><a href="#topic+dataFranses1996">dataFranses1996</a></code> and <code><a href="#topic+pcts-package">pcts-package</a></code> for examples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pcfr &lt;- pcts(dataFranses1996)
colnames(pcfr)[4] # "GermanyGNP"

## extracting single time series as univariate 
class(pcfr[[4]]) # "PeriodicTS"
identical(pcfr[[4]], pcfr$GermanyGNP )     # TRUE
identical(pcfr[[4]], pcfr[["GermanyGNP"]]) # TRUE
plot(pcfr[[4]])

## ... and as multivariate
pcfr[4] #  "PeriodicMTS"
plot(pcfr[4])

## extracting more than one time series
plot(pcfr[2:4])
summary(pcfr[2:4])

pcfr2 &lt;- pcfr[[2]]
plot(pcfr2)
</code></pre>

<hr>
<h2 id='PeriodicSPFilter-class'>Class PeriodicSPFilter</h2><span id='topic+PeriodicSPFilter-class'></span>

<h3>Description</h3>

<p>A class for filters following the signal processing sign convention.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PeriodicSPFilter", coef, order, ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>coef</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>order</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+PeriodicMonicFilterSpec-class">PeriodicMonicFilterSpec</a>"</code>, directly.
Class <code>"<a href="sarima.html#topic+VirtualSPFilter-class">VirtualSPFilter</a>"</code>, directly.
Class <code>"<a href="sarima.html#topic+VirtualMonicFilterSpec-class">VirtualMonicFilterSpec</a>"</code>, by class &quot;PeriodicMonicFilterSpec&quot;, distance 2.
Class <code>"<a href="sarima.html#topic+VirtualMonicFilter-class">VirtualMonicFilter</a>"</code>, by class &quot;VirtualSPFilter&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p><code>signature(from = "matrix", to = "PeriodicSPFilter")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "PeriodicBJFilter", to = "PeriodicSPFilter")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "PeriodicSPFilter", to = "PeriodicBJFilter")</code>: ... </p>
</dd>
<dt>filterCoef</dt><dd><p><code>signature(object = "PeriodicSPFilter", convention = "character")</code>: ... </p>
</dd>
<dt>filterPoly</dt><dd><p><code>signature(object = "PeriodicSPFilter")</code>: ... </p>
</dd>
<dt>filterPolyCoef</dt><dd><p><code>signature(object = "PeriodicSPFilter")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "PeriodicSPFilter")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+PeriodicBJFilter-class">PeriodicBJFilter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see "PeriodicBJFilter-class" for examples
</code></pre>

<hr>
<h2 id='PeriodicTimeSeries-class'>Class PeriodicTimeSeries</h2><span id='topic+PeriodicTimeSeries-class'></span>

<h3>Description</h3>

<p>Class PeriodicTimeSeries.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.
</p>
<p><code>PeriodicTimeSeries</code> is the root class for the periodic time
series classes in package <code>"pcts"</code>. It can be used in signatures
for methods that can handle objcets from any of them.
</p>


<h3>Slots</h3>


<dl>
<dt><code>cycle</code>:</dt><dd><p>Object of class <code>"BasicCycle"</code>.</p>
</dd>
<dt><code>pcstart</code>:</dt><dd><p>Object of class <code>"ANY"</code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+Cyclic-class">Cyclic</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>as_date</dt><dd><p><code>signature(x = "PeriodicTimeSeries")</code>: ... </p>
</dd>
<dt>as_datetime</dt><dd><p><code>signature(x = "PeriodicTimeSeries")</code>: ... </p>
</dd>
<dt>autocorrelations</dt><dd><p><code>signature(x = "PeriodicTimeSeries", maxlag = "ANY", lag_0 = "missing")</code>: ... </p>
</dd>
<dt>pcTest</dt><dd><p><code>signature(x = "PeriodicTimeSeries", nullmodel = "character")</code>: ... </p>
</dd>
<dt>head</dt><dd><p><code>signature(x = "PeriodicTimeSeries")</code>: ... </p>
</dd>
<dt>nTicks</dt><dd><p><code>signature(x = "PeriodicTimeSeries")</code>: ... </p>
</dd>
<dt>pcCycle</dt><dd><p><code>signature(x = "PeriodicTimeSeries", type = "character")</code>: ... </p>
</dd>
<dt>pcCycle</dt><dd><p><code>signature(x = "PeriodicTimeSeries", type =
	"missing")</code>: ... </p>
</dd>
<dt>tail</dt><dd><p><code>signature(x = "PeriodicTimeSeries")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

<p>classes <code><a href="#topic+PeriodicTS-class">PeriodicTS</a></code>, <code><a href="#topic+PeriodicMTS-class">PeriodicMTS</a></code>
</p>

<hr>
<h2 id='PeriodicTS_ts-class'>Class <code>"PeriodicTS_ts"</code></h2><span id='topic+PeriodicTS_ts-class'></span>

<h3>Description</h3>

<p>Class <code>"PeriodicTS_ts"</code> is a periodic class holding
<code>"ts"</code> objects.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PeriodicTS_zooreg", ...)</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PeriodicTS_ts", x, ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"vector"</code> ~~ </p>
</dd>
<dt><code>cycle</code>:</dt><dd><p>Object of class <code>"BasicCycle"</code> ~~ </p>
</dd>
<dt><code>tsp</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>.S3Class</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>pcstart</code>:</dt><dd><p>Object of class <code>"ANY"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+PeriodicTimeSeries-class">PeriodicTimeSeries</a>"</code>, directly.
Class <code>"<a href="methods.html#topic+ts-class">ts</a>"</code>, directly.
Class <code>"<a href="#topic+Cyclic-class">Cyclic</a>"</code>, by class &quot;PeriodicTimeSeries&quot;, distance 2.
Class <code>"<a href="methods.html#topic+structure-class">structure</a>"</code>, by class &quot;ts&quot;, distance 2.
Class <code>"<a href="methods.html#topic+oldClass-class">oldClass</a>"</code>, by class &quot;ts&quot;, distance 2.
Class <code>"<a href="methods.html#topic+vector-class">vector</a>"</code>, by class &quot;ts&quot;, distance 3, with explicit coerce.
</p>


<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p><code>signature(from = "ts", to = "PeriodicTS_ts")</code>: ... </p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "PeriodicTS_ts")</code>: ...</p>
</dd>
</dl>


<hr>
<h2 id='PeriodicTS_zooreg-class'>Class <code>"PeriodicTS_zooreg"</code></h2><span id='topic+PeriodicTS_zooreg-class'></span>

<h3>Description</h3>

<p>Class <code>"PeriodicTS_zooreg"</code> is a periodic class holding
<code>"zooreg"</code> objects.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PeriodicTS_zooreg", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>cycle</code>:</dt><dd><p>Object of class <code>"BasicCycle"</code> ~~ </p>
</dd>
<dt><code>.S3Class</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>pcstart</code>:</dt><dd><p>Object of class <code>"ANY"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+PeriodicTimeSeries-class">PeriodicTimeSeries</a>"</code>, directly.
Class <code>"<a href="methods.html#topic+ts-class">ts</a>"</code>, directly.
Class <code>"<a href="#topic+Cyclic-class">Cyclic</a>"</code>, by class &quot;PeriodicTimeSeries&quot;, distance 2.
Class <code>"<a href="methods.html#topic+structure-class">structure</a>"</code>, by class &quot;ts&quot;, distance 2.
Class <code>"<a href="methods.html#topic+oldClass-class">oldClass</a>"</code>, by class &quot;ts&quot;, distance 2.
Class <code>"<a href="methods.html#topic+vector-class">vector</a>"</code>, by class &quot;ts&quot;, distance 3, with explicit coerce.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;PeriodicTS_zooreg&quot; in the signature.
</p>


<h3>See Also</h3>

<p>classes <code><a href="#topic+PeriodicTS-class">PeriodicTS</a></code> and
<code><a href="#topic+PeriodicMTS-class">PeriodicMTS</a></code>
</p>

<hr>
<h2 id='PeriodicTS-class'>Class <code>"PeriodicTS"</code></h2><span id='topic+PeriodicTS-class'></span><span id='topic+coerce+2Cmts+2CPeriodicTS-method'></span><span id='topic+coerce+2CPeriodicTS+2Cts-method'></span><span id='topic+coerce+2Cts+2CPeriodicTS-method'></span><span id='topic+plot+2CPeriodicTS+2Cmissing-method'></span><span id='topic+show+2CPeriodicTS-method'></span><span id='topic+summary+2CPeriodicTS-method'></span>

<h3>Description</h3>

<p>Class <code>"PeriodicTS"</code> is the main class for univariate periodic
time series in package <code>"pcts"</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created from numeric vectors and objects from other
time series classes by calling <code><a href="#topic+pcts">pcts</a></code> (recommended in most
cases).
</p>
<p>It is possible also to use calls of the form <code>new("PeriodicTS",
  ...)</code>. This is more useful in programming. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"numeric"</code>,
the core data.  Several functions can be used to extract it in
various formats, see <code><a href="#topic+Vec">Vec</a></code>.
</p>
</dd>
<dt><code>cycle</code>:</dt><dd><p>Object of class <code>"BasicCycle"</code>,
representing the seasonal information, see
<code><a href="#topic+pcCycle">pcCycle</a></code>. 
</p>
</dd>
<dt><code>pcstart</code>:</dt><dd><p>Object of class <code>"ANY"</code>,
the time of the first observation.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+PeriodicTimeSeries-class">PeriodicTimeSeries</a>"</code>, directly.
Class <code>"<a href="methods.html#topic+numeric-class">numeric</a>"</code>, from data part.
Class <code>"<a href="#topic+Cyclic-class">Cyclic</a>"</code>, by class &quot;PeriodicTimeSeries&quot;, distance 2.
Class <code>"<a href="methods.html#topic+vector-class">vector</a>"</code>, by class &quot;numeric&quot;, distance 2.
Class <code>"<a href="Matrix.html#topic+index-class">index</a>"</code>, by class &quot;numeric&quot;, distance 2.
Class <code>"<a href="Matrix.html#topic+replValue-class">replValue</a>"</code>, by class &quot;numeric&quot;, distance 2.
Class <code>"numLike"</code>, by class &quot;numeric&quot;, distance 2.
Class <code>"<a href="Matrix.html#topic+number-class">number</a>"</code>, by class &quot;numeric&quot;, distance 2.
Class <code>"<a href="Matrix.html#topic+atomicVector-class">atomicVector</a>"</code>, by class &quot;numeric&quot;, distance 2.
Class <code>"numericVector"</code>, by class &quot;numeric&quot;, distance 2.
Class <code>"replValueSp"</code>, by class &quot;numeric&quot;, distance 3.
Class <code>"Mnumeric"</code>, by class &quot;numeric&quot;, distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "PeriodicTS", i = "AnyDateTime", j = "missing", drop = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "PeriodicTS", i = "missing", j = "missing", drop = "ANY")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "mts", to = "PeriodicTS")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "PeriodicTS", to = "ts")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "ts", to = "PeriodicTS")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "PeriodicTS", to = "Cyclic")</code>: ... </p>
</dd>
<dt>coerce&lt;-</dt><dd><p><code>signature(from = "PeriodicTS", to = "Cyclic")</code>: ... </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "PeriodicTS", y = "missing")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "PeriodicTS")</code>: ... </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "PeriodicTS")</code>: ... </p>
</dd>
<dt>autocovariances</dt><dd><p><code>signature(x = "PeriodicTS", maxlag = "ANY")</code>: ... </p>
</dd>
<dt>fitPM</dt><dd><p><code>signature(model = "PeriodicArModel", x = "PeriodicTS")</code>: ... </p>
</dd>
<dt>pcApply</dt><dd><p><code>signature(object = "PeriodicTS")</code>: ... </p>
</dd>
<dt>pcMean</dt><dd><p><code>signature(object = "PeriodicTS")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+pcts">pcts</a></code> for creating <code>"PeriodicTS" </code> objects from raw
vectors and objects from other time series classes.
</p>
<p><code><a href="#topic+PeriodicMTS-class">PeriodicMTS</a></code> for multivariate periodic time
series.
</p>

<hr>
<h2 id='PeriodicVector-class'>Class PeriodicVector</h2><span id='topic+PeriodicVector-class'></span><span id='topic+PeriodicVector'></span>

<h3>Description</h3>

<p>Objects and methods for class PeriodicVector.</p>


<h3>Usage</h3>

<pre><code class='language-R'>PeriodicVector(x, period = length(x))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PeriodicVector-class_+3A_x">x</code></td>
<td>
<p>the values for inidices from 1 to <code>period</code>, numeric.</p>
</td></tr>
<tr><td><code id="PeriodicVector-class_+3A_period">period</code></td>
<td>
<p>the period, defaults to <code>length(x)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code class="reqn">p</code>-periodic vector, <code class="reqn">X</code>, is such that <code class="reqn">X_{i+pk} = X_i</code>
for any integers <code class="reqn">i,k</code>.
</p>
<p>Class <code>PeriodicVector</code> stores the values of <code class="reqn">X_1,\ldots,X_p</code>
and provides indexing methods for extracting and setting its
elements.
</p>


<h3>Value</h3>

<p>an object from class <code>"PeriodicVector"</code>
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PeriodicVector", ...)</code>
or more conveniently by using <code>"PeriodicVector()"</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>period</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="methods.html#topic+numeric-class">numeric</a>"</code>, from data part.
Class <code>"<a href="methods.html#topic+vector-class">vector</a>"</code>, by class &quot;numeric&quot;, distance 2.
Class <code>"<a href="Matrix.html#topic+atomicVector-class">atomicVector</a>"</code>, by class &quot;numeric&quot;, distance 2.
Class <code>"<a href="Matrix.html#topic+index-class">index</a>"</code>, by class &quot;numeric&quot;, distance 2.
</p>
<p>Class <code>"numLike"</code>, by class &quot;numeric&quot;, distance 2.
</p>
<p>Class <code>"<a href="Matrix.html#topic+number-class">number</a>"</code>, by class &quot;numeric&quot;, distance 2.
Class <code>"<a href="Matrix.html#topic+replValue-class">replValue</a>"</code>, by class &quot;numeric&quot;, distance 2.
</p>


<h3>Methods</h3>

<p><code>"PeriodicVector"</code> methods are defined for <code>"["</code> and
<code>"[&lt;-"</code>. Arithmetic operations just inherit the recycling rules
from <code>"numeric"</code>.
</p>

<dl>
<dt>[</dt><dd><p><code>signature(x = "PeriodicVector", i = "ANY", j = "ANY", drop = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "PeriodicVector", i = "ANY", j = "missing", drop = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "PeriodicVector", i = "missing", j = "ANY", drop = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "PeriodicVector", i = "missing", j = "missing", drop = "ANY")</code>: ... </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "PeriodicVector", i = "ANY", j = "ANY", value = "ANY")</code>: ... </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "PeriodicVector", i = "missing", j = "ANY", value = "ANY")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+PeriodicVector">PeriodicVector</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PeriodicVector(1:4, period = 4)
PeriodicVector(1:4) ## same
new("PeriodicVector", 1:4, period = 4)

## if period is given but x is missing, the vector is filled with NA's
PeriodicVector(period = 4)

## this throws error, since length(x) != period:
##    PeriodicVector(1:3, period = 4)

## extract
x &lt;- PeriodicVector(1:4)
x[3:12]
x[c(3, 7, 11, 15)]

# any indices in (-Inf, Inf) work
x[0]
x[-3:0]

## "[&lt;-" works on the underling vector
x[1] &lt;- 11; x

## modulo indexing works also in assignments:
x[5] &lt;- 21; x

## empty index returns the underlying vector
x[]

## the recycling rule applies on assignment
x[] &lt;- 9; x
x[] &lt;- 1:2; x

## this gives warning, as for numeric vectors
##     x[] &lt;- 8:1
## compare:
##     x &lt;- 1:4
##     x[] &lt;- 8:1

## arithmetic works as usual:
2 * x
x + 1:4
## x + 1:3 # warning - '... a multiple ...'
</code></pre>

<hr>
<h2 id='permean2intercept'>Convert between periodic centering and intercepts</h2><span id='topic+permean2intercept'></span><span id='topic+intercept2permean'></span>

<h3>Description</h3>

<p>Convert a periodic mean to periodic intercept and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permean2intercept(mean, coef, order, nseasons = nrow(coef))

intercept2permean(intercept, coef, order, nseasons = nrow(coef))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permean2intercept_+3A_mean">mean</code></td>
<td>
<p>periodic mean, numeric.</p>
</td></tr>
<tr><td><code id="permean2intercept_+3A_coef">coef</code></td>
<td>
<p>PAR coefficients, matrix.</p>
</td></tr>
<tr><td><code id="permean2intercept_+3A_order">order</code></td>
<td>
<p>PAR order, vector of positive integers.</p>
</td></tr>
<tr><td><code id="permean2intercept_+3A_nseasons">nseasons</code></td>
<td>
<p>number of seasons, a.k.a. period.</p>
</td></tr>
<tr><td><code id="permean2intercept_+3A_intercept">intercept</code></td>
<td>
<p>periodic intercepts, numeric.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A PAR model can be written in mean corrected or intercept form.
<code>permean2intercept</code> calculates the intercepts from the means,
while <code>intercept2permean</code> does the inverse (means from
intercepts).
</p>
<p>No check is made for periodic stationarity of the model. Converting
from mean corrected to intercept form allways succeeds and in fact the
means do not need to be means. In the opposite direction there may be
problems due to unit roots and similar features.
</p>


<h3>Value</h3>

<p>a numeric vector
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- c(1, 2)
pm1 &lt;- PeriodicArModel(matrix(c(0.5, 0.5), nrow = 2), order = rep(1, 2), sigma2 = 1, mean = mu)

cc &lt;- permean2intercept(mu, pm1@ar@coef, c(1,1))
cc
intercept2permean(cc, pm1@ar@coef, c(1,1))

d &lt;- 4
mu &lt;- 1:d
co &lt;- rep(0.5, d)
pm1 &lt;- PeriodicArModel(matrix(co, nrow = d), order = rep(1, d), sigma2 = 1, mean = mu)

cc &lt;- permean2intercept(mu, pm1@ar@coef, order = rep(1, d))
cc
intercept2permean(cc, pm1@ar@coef, order = rep(1, d) )

</code></pre>

<hr>
<h2 id='permodelmf'>Compute the multi-companion form of a per model</h2><span id='topic+permodelmf'></span>

<h3>Description</h3>

<p>Compute the multi-companion form of a per model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>permodelmf(permodel, update = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permodelmf_+3A_permodel">permodel</code></td>
<td>
<p>a model.</p>
</td></tr>
<tr><td><code id="permodelmf_+3A_update">update</code></td>
<td>
<p>If TRUE store the multi-companion form in
<code>permodel</code> and return the whole model, otherwise simply return
the multi-companion form.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>todo:</p>


<h3>Value</h3>

<p>the multi-companion form of the model or the updated model, as
described in Details.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Boshnakov GN, Iqelan BM (2009).
&ldquo;Generation of time series models with given spectral properties.&rdquo;
<em>J. Time Series Anal.</em>, <b>30</b>(3), 349&ndash;368.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.2009.00617.x">doi:10.1111/j.1467-9892.2009.00617.x</a>.
</p>

<hr>
<h2 id='pi1ar2par'>Convert PIAR coefficients to PAR coefficients</h2><span id='topic+pi1ar2par'></span><span id='topic+piar2par'></span>

<h3>Description</h3>

<p>Convert PIAR coefficients to PAR coefficients</p>


<h3>Usage</h3>

<pre><code class='language-R'>pi1ar2par(picoef, parcoef)
piar2par(picoef, parcoef)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pi1ar2par_+3A_picoef">picoef</code></td>
<td>
<p>coefficients of the periodic integration filter, a
numeric vector or matrix, see Details.
</p>
</td></tr>
<tr><td><code id="pi1ar2par_+3A_parcoef">parcoef</code></td>
<td>

<p>coefficients of the periodically correlated part of the model.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions expand periodic filters represented in multiplicative
form.  The non-periodic analogue of the operation of these functions
is representing a multiplicative filter like <code class="reqn">(1-B)(1-aB)</code>, where
<code class="reqn">B</code> is the backward shift operator, by the single filter <code class="reqn">1 -
  (1+a)B + aB^2</code>, which is just a product of the polynomials, <code class="reqn">1-B</code>
and <code class="reqn">1 - aB</code>.
</p>
<p>In the non-periodic case however this operation is not, in general,
equivalent to multiplication of the corresponding polynomials. It is
also not commutative.
</p>
<p><code>pi1ar2par</code> converts PIAR(1) model coefficients specified as a
set of coefficients corresponding to a periodic unit root and PAR
coefficients to coefficients for a single filter.
</p>
<p><code>piar2par</code> does the same but admits higher order periodic
integration.
</p>
<p><code>picoef</code> is a matrix, specifying one or more first order periodic
unit root filters. Each column contains the coefficients of one
filter. If there is only one filter, its coefficients can be given as
a numeric vector.
</p>
<p>The filters are applied from right to left, in the sense that first
the PAR filter is applied to the time series, then the filter
specified by the last column and so on.
</p>


<h3>Value</h3>

<p>a matrix, whose i-th row contains the coefficients for the i-th season.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Lina's example
parcoef    &lt;- rbind(c(0.5, -0.06), c(0.6, -0.08),
                    c(0.7, -0.1),  c(0.2, 0.15) )
picoef1    &lt;- c(0.8, 1.25, 2, 0.5)
parcoef2   &lt;- pi1ar2par(picoef1, parcoef)

picoef2    &lt;- c(4, 0.25, 5, 0.2)
coefper2I2 &lt;- pi1ar2par(picoef2, parcoef2)
</code></pre>

<hr>
<h2 id='PiPeriodicArmaModel-class'>Class PiPeriodicArmaModel</h2><span id='topic+PiPeriodicArmaModel-class'></span>

<h3>Description</h3>

<p>Class PiPeriodicArmaModel.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PiPeriodicArmaModel", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>piorder</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>picoef</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>pcmodel</code>:</dt><dd><p>Object of class <code>"PeriodicArmaModel"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+VirtualPeriodicFilterModel-class">VirtualPeriodicFilterModel</a>"</code>, directly.
Class <code>"<a href="#topic+PeriodicIntegratedArmaSpec-class">PeriodicIntegratedArmaSpec</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "PiPeriodicArmaModel")</code>: ... </p>
</dd>
</dl>


<hr>
<h2 id='PiPeriodicArModel-class'>Class PiPeriodicArModel</h2><span id='topic+PiPeriodicArModel-class'></span>

<h3>Description</h3>

<p>Class PiPeriodicArModel.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PiPeriodicArModel", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>piorder</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>picoef</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>pcmodel</code>:</dt><dd><p>Object of class <code>"PeriodicArmaModel"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+PiPeriodicArmaModel-class">PiPeriodicArmaModel</a>"</code>, directly.
Class <code>"<a href="#topic+VirtualPeriodicFilterModel-class">VirtualPeriodicFilterModel</a>"</code>, by class &quot;PiPeriodicArmaModel&quot;, distance 2.
Class <code>"<a href="#topic+PeriodicIntegratedArmaSpec-class">PeriodicIntegratedArmaSpec</a>"</code>, by class &quot;PiPeriodicArmaModel&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>fitPM</dt><dd><p><code>signature(x = "ANY", model = "PiPeriodicArModel")</code>: ... </p>
</dd>
<dt>fitPM</dt><dd><p><code>signature(model = "PiPeriodicArModel", x = "ANY")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "PiPeriodicArModel")</code>: ... </p>
</dd>
</dl>


<hr>
<h2 id='PiPeriodicMaModel-class'>Class PiPeriodicMaModel</h2><span id='topic+PiPeriodicMaModel-class'></span>

<h3>Description</h3>

<p>Class PiPeriodicMaModel.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("PiPeriodicMaModel", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>piorder</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>picoef</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>pcmodel</code>:</dt><dd><p>Object of class <code>"PeriodicArmaModel"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+PiPeriodicArmaModel-class">PiPeriodicArmaModel</a>"</code>, directly.
Class <code>"<a href="#topic+VirtualPeriodicFilterModel-class">VirtualPeriodicFilterModel</a>"</code>, by class &quot;PiPeriodicArmaModel&quot;, distance 2.
Class <code>"<a href="#topic+PeriodicIntegratedArmaSpec-class">PeriodicIntegratedArmaSpec</a>"</code>, by class &quot;PiPeriodicArmaModel&quot;, distance 2.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;PiPeriodicMaModel&quot; in the signature.
</p>

<hr>
<h2 id='pwn_McLeodLjungBox_test'> McLeod-Ljung-Box test for periodic white noise </h2><span id='topic+pwn_McLeodLjungBox_test'></span>

<h3>Description</h3>

<p>Compute the McLeod-Ljung-Box test statistic for examining
the null hypothesis of periodic white noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pwn_McLeodLjungBox_test(acf, nepoch, use = 1:maxlag,
                 maxlag = ncol(as.matrix(acf)) - 1,
                 period = nrow(as.matrix(acf)), fitdf = numeric(period))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pwn_McLeodLjungBox_test_+3A_acf">acf</code></td>
<td>

<p>the sample periodic autocorrelation function of the time series.
</p>
</td></tr>
<tr><td><code id="pwn_McLeodLjungBox_test_+3A_nepoch">nepoch</code></td>
<td>
<p> number of cycles used in computing the acf. </p>
</td></tr>
<tr><td><code id="pwn_McLeodLjungBox_test_+3A_use">use</code></td>
<td>
<p> number of lags to use, may be a vector.</p>
</td></tr>
<tr><td><code id="pwn_McLeodLjungBox_test_+3A_maxlag">maxlag</code></td>
<td>
<p>maximal lag.</p>
</td></tr>
<tr><td><code id="pwn_McLeodLjungBox_test_+3A_period">period</code></td>
<td>
<p>number of seasons in a cycle.</p>
</td></tr>
<tr><td><code id="pwn_McLeodLjungBox_test_+3A_fitdf">fitdf</code></td>
<td>
<p>degrees of freedom corrections for the number of
estimated parameters, see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The McLeod-Ljung-Box test can be used to test the null hypothesis of
periodic white noise.
</p>
<p>If <code>acf</code> contains sample autocorrelations of residuals from a
fitted model, a correction of the degrees of freedom is strongly
recommended.
</p>
<p>Argument <code>fitdf</code> is a vector specifying how may degrees of
freedom to subtract for each season. In the case of PAR models
<code>fitdf</code> can be set to the PAR orders.
</p>
<p>The value of the statistic is set to NA where the correction for
degrees of freedom results in negative numbers.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the  test statistic for each lag
specified by <code>use</code>.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the corresponding degrees of freedom</p>
</td></tr>
</table>


<h3>Note</h3>

<p>TODO: Consolidate this and similar tests!
</p>
<p>There is a typo in McLeod (1994), eq. (4.5),
noted by (McLeod 1995).
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>McLeod AI (1994).
&ldquo;Diagnostic checking of periodic autoregression models with application.&rdquo;
<em>Journal of Time Series Analysis</em>, <b>15</b>(2), 221&ndash;233.<br /><br /> McLeod AI (1995).
&ldquo;Diagnostic checking of periodic autoregression models with application.&rdquo;
<em>Journal of Time Series Analysis</em>, <b>16</b>(6), 647-648.
<a href="https://doi.org/10.1111/j.1467-9892.1995.tb00260.x">doi:10.1111/j.1467-9892.1995.tb00260.x</a>, This corrects some typos in the eponimous article  McLeod (1994).
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Box.test">Box.test</a></code> for the non-periodic case
</p>

<hr>
<h2 id='SamplePeriodicAutocorrelations-class'>Class SamplePeriodicAutocorrelations</h2><span id='topic+SamplePeriodicAutocorrelations-class'></span>

<h3>Description</h3>

<p>Class SamplePeriodicAutocorrelations.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("SamplePeriodicAutocorrelations", ..., data)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>modelCycle</code>:</dt><dd><p>Object of class <code>"BasicCycle"</code> ~~ </p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"Lagged"</code> ~~ </p>
</dd>
<dt><code>n</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>varnames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>objectname</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+PeriodicAutocorrelations-class">PeriodicAutocorrelations</a>"</code>, directly.
Class <code>"<a href="sarima.html#topic+Fitted-class">Fitted</a>"</code>, directly.
Class <code>"<a href="#topic+ModelCycleSpec-class">ModelCycleSpec</a>"</code>, by class &quot;PeriodicAutocorrelations&quot;, distance 2.
Class <code>"<a href="lagged.html#topic+FlexibleLagged-class">FlexibleLagged</a>"</code>, by class &quot;PeriodicAutocorrelations&quot;, distance 2.
Class <code>"<a href="#topic+VirtualPeriodicAutocorrelations-class">VirtualPeriodicAutocorrelations</a>"</code>, by class &quot;PeriodicAutocorrelations&quot;, distance 2.
Class <code>"<a href="lagged.html#topic+Lagged">Lagged</a>"</code>, by class &quot;PeriodicAutocorrelations&quot;, distance 3.
Class <code>"<a href="#topic+VirtualPeriodicModel-class">VirtualPeriodicModel</a>"</code>, by class &quot;PeriodicAutocorrelations&quot;, distance 3.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;SamplePeriodicAutocorrelations&quot; in the signature.
</p>

<hr>
<h2 id='SamplePeriodicAutocovariances-class'>Class SamplePeriodicAutocovariances</h2><span id='topic+SamplePeriodicAutocovariances-class'></span>

<h3>Description</h3>

<p>Class SamplePeriodicAutocovariances.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("SamplePeriodicAutocovariances", ..., data)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>modelCycle</code>:</dt><dd><p>Object of class <code>"BasicCycle"</code> ~~ </p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"Lagged"</code> ~~ </p>
</dd>
<dt><code>n</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>varnames</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>objectname</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+PeriodicAutocovariances-class">PeriodicAutocovariances</a>"</code>, directly.
Class <code>"<a href="sarima.html#topic+Fitted-class">Fitted</a>"</code>, directly.
Class <code>"<a href="#topic+ModelCycleSpec-class">ModelCycleSpec</a>"</code>, by class &quot;PeriodicAutocovariances&quot;, distance 2.
Class <code>"<a href="lagged.html#topic+FlexibleLagged-class">FlexibleLagged</a>"</code>, by class &quot;PeriodicAutocovariances&quot;, distance 2.
Class <code>"<a href="#topic+VirtualPeriodicAutocovariances-class">VirtualPeriodicAutocovariances</a>"</code>, by class &quot;PeriodicAutocovariances&quot;, distance 2.
Class <code>"<a href="lagged.html#topic+Lagged-class">Lagged</a>"</code>, by class &quot;PeriodicAutocovariances&quot;, distance 3.
Class <code>"<a href="#topic+VirtualPeriodicModel-class">VirtualPeriodicModel</a>"</code>, by class &quot;PeriodicAutocovariances&quot;, distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>autocorrelations</dt><dd><p><code>signature(x = "SamplePeriodicAutocovariances", maxlag = "ANY", lag_0 = "missing")</code>: ... </p>
</dd>
</dl>


<hr>
<h2 id='seqSeasons-methods'>Methods for seqSeasons() in package pcts</h2><span id='topic+seqSeasons-methods'></span><span id='topic+seqSeasons+2CBasicCycle-method'></span><span id='topic+seqSeasons+2CCyclic-method'></span><span id='topic+seqSeasons+2CVirtualPeriodicModel-method'></span>

<h3>Description</h3>

<p>Methods for seqSeasons() in package pcts.</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "BasicCycle")</code></dt><dd>
</dd>
<dt><code>signature(x = "Cyclic")</code></dt><dd>
</dd>
<dt><code>signature(x = "VirtualPeriodicModel")</code></dt><dd>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+allSeasons">allSeasons</a></code> for related functions and examples
</p>

<hr>
<h2 id='sigmaSq-methods'>Methods for <code>sigmaSq</code> in package pcts</h2><span id='topic+sigmaSq-methods'></span><span id='topic+sigmaSq+2CPeriodicIntegratedArmaSpec-method'></span><span id='topic+sigmaSq+2CPeriodicInterceptSpec-method'></span>

<h3>Description</h3>

<p>Methods for <code>sigmaSq</code> in package pcts.</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "PeriodicIntegratedArmaSpec")</code></dt><dd>

</dd>
<dt><code>signature(object = "PeriodicInterceptSpec")</code></dt><dd>

</dd>
</dl>


<hr>
<h2 id='sim_parAcvf'>Create a random periodic autocovariance function</h2><span id='topic+sim_parAcvf'></span>

<h3>Description</h3>

<p>Select randomly a periodic autoregression model and return the
periodic autocovariances associated with it. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_parAcvf(period, order, sigma2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_parAcvf_+3A_period">period</code></td>
<td>
<p>the period, a positive integer.</p>
</td></tr>
<tr><td><code id="sim_parAcvf_+3A_order">order</code></td>
<td>
<p>the AR order, a vector of non-negative integers.</p>
</td></tr>
<tr><td><code id="sim_parAcvf_+3A_sigma2">sigma2</code></td>
<td>
<p>the variances of the innovations, a numeric vector of
length <code>period</code> (todo: or one?).
</p>
</td></tr>

</table>


<h3>Details</h3>

<p>Uses <code>sim_parCoef()</code> to generate a random PAR model.
</p>


<h3>Value</h3>

<p>an object of class &quot;matrix&quot;. In addition, the specification of the
model is in attribute <code>"model"</code> which is a list with the
following components:
</p>
<table role = "presentation">
<tr><td><code>ar</code></td>
<td>
<p>a matrix, the coefficients of the PAR model,</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>numeric, the innovation variances,</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p>the PAR order.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Boshnakov GN, Iqelan BM (2009).
&ldquo;Generation of time series models with given spectral properties.&rdquo;
<em>J. Time Series Anal.</em>, <b>30</b>(3), 349&ndash;368.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.2009.00617.x">doi:10.1111/j.1467-9892.2009.00617.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim_parAcvf(2, 5)
sim_parAcvf(3, 5)

res &lt;- sim_parAcvf(2, 6)
res
slMatrix(res)[3, 4, type = "tt"]

res &lt;- sim_parAcvf(2, 4)
attr(res, "model")
acv &lt;- res[ , ] # drop attributes

acv[2, 1 + 0]
acv[2, 1 + 1]
slMatrix(acv)[2, 0]
slMatrix(acv)[2, 1]
slMatrix(acv)[3, 4, type = "tt"]
slMatrix(acv)[1:2, 1:2, type = "tt"]
slMatrix(acv)[1:4, 1:4, type = "tt"]

## TODO: need method for autocorrelation()
## pc.acrf(acv)

## TODO: these need changing, after the change of the return values of sim_parAcvf
## pc.fcoeffs(acv, 2)
## pc.fcoeffs(acv, 3)
## pc.fcoeffs(acv, 4)
pcts:::calc_predictionCoefficients(acv, c(2, 2))
pcts:::calc_predictionCoefficients(acv, c(3, 3))
pcts:::calc_predictionCoefficients(acv, c(4, 4))
</code></pre>

<hr>
<h2 id='sim_parCoef'> Generate a periodic autoregression model </h2><span id='topic+sim_parCoef'></span>

<h3>Description</h3>

<p>Generate a periodic autoregression model, possibly integrated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_parCoef(period, n.root, sigma2 = rep(1, period), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_parCoef_+3A_period">period</code></td>
<td>
<p> number of seasons in a cycle. </p>
</td></tr>
<tr><td><code id="sim_parCoef_+3A_n.root">n.root</code></td>
<td>
<p> number of non-zero roots, see details. </p>
</td></tr>
<tr><td><code id="sim_parCoef_+3A_sigma2">sigma2</code></td>
<td>
<p> variances of the innovations. </p>
</td></tr>
<tr><td><code id="sim_parCoef_+3A_...">...</code></td>
<td>
<p> additional arguments to be passed down to <code>sim_pcfilter</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sim_parCoef</code> uses the multi-companion method to generate the
model. The function is essentially a wrapper for <code>sim_pcfilter</code>.
</p>
<p>The order of the filter is set to <code>n.root</code> for each season.  Part
of the spectral information may be specified with the <code>"..."</code>
arguments, see <code><a href="mcompanion.html#topic+sim_pcfilter">sim_pcfilter</a></code> and <code><a href="mcompanion.html#topic+sim_mc">sim_mc</a></code> for
a discussion of this.
</p>


<h3>Value</h3>

<p>a periodic autoregression model as a list with elements:
</p>
<table role = "presentation">
<tr><td><code>ar</code></td>
<td>
<p>a matrix whose <code class="reqn">i</code>th row contains the coefficients
for the <code class="reqn">i</code>season,</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>the innovation variances, a numeric vector.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Boshnakov GN, Iqelan BM (2009).
&ldquo;Generation of time series models with given spectral properties.&rdquo;
<em>J. Time Series Anal.</em>, <b>30</b>(3), 349&ndash;368.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.2009.00617.x">doi:10.1111/j.1467-9892.2009.00617.x</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="mcompanion.html#topic+sim_pcfilter">sim_pcfilter</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>sim_parCoef(2, 4)                    # 2 seasons
sim_parCoef(2, 4, sigma2 = c(2, 4))
sim_parCoef(2, 1)
sim_parCoef(4, 2)                    # 4 seasons

sim_parCoef(period = 4, n.root = 6,
    eigabs = c(1, 1, 1, 0.036568887, 0.001968887),
    type.eigval = c("cp", "r", "r", "r",  "r"),
    eigsign     = c(pi/2,   1,  -1,   1,   -1))
</code></pre>

<hr>
<h2 id='sim_pc'>Simulate periodically correlated ARMA series </h2><span id='topic+sim_pc'></span>

<h3>Description</h3>

<p>Simulate a realization of a periodically correlated arma model
or a continuation of an existing series.
Initial values may be given too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_pc(model, n = NA, randgen = rnorm, seasonof1st = 1, nepochs = NA,
              n.start = NA, x, eps, nmean = NULL, nintercept = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_pc_+3A_model">model</code></td>
<td>
<p> a list with elements
<code>phi</code>, <code>theta</code>, <code>p</code>, <code>q</code>, <code>period</code>,
<code>mean</code>, <code>intercept</code>,
specifying the model. </p>
</td></tr>
<tr><td><code id="sim_pc_+3A_n">n</code></td>
<td>
<p> length of the series. </p>
</td></tr>
<tr><td><code id="sim_pc_+3A_randgen">randgen</code></td>
<td>
<p> random number generator as required by
<code><a href="#topic+sim_pwn">sim_pwn</a></code>. </p>
</td></tr>





<tr><td><code id="sim_pc_+3A_seasonof1st">seasonof1st</code></td>
<td>
<p> season of the first value. </p>
</td></tr>
<tr><td><code id="sim_pc_+3A_nepochs">nepochs</code></td>
<td>

<p>number of epochs; if <code>nepochs</code> is given, then <code>n</code> is
computed as <code class="reqn">nepochs * period</code>. </p>
</td></tr>
<tr><td><code id="sim_pc_+3A_n.start">n.start</code></td>
<td>

<p>burn-in number; generate <code class="reqn">\code{n.start + n}</code> observations and
discard the first <code>n.start</code> of them, see Details.
</p>
</td></tr>
<tr><td><code id="sim_pc_+3A_x">x</code></td>
<td>
<p><em>initial</em> or <em>before</em> values, see Details.</p>
</td></tr>
<tr><td><code id="sim_pc_+3A_eps">eps</code></td>
<td>
<p>innovations, see Details. </p>
</td></tr>
<tr><td><code id="sim_pc_+3A_nmean">nmean</code></td>
<td>
<p>a vector of length <code>n</code> of means, see Details.</p>
</td></tr>
<tr><td><code id="sim_pc_+3A_nintercept">nintercept</code></td>
<td>

<p>a vector of length <code>n</code> of intercepts, see Details.
</p>
</td></tr> 
<tr><td><code id="sim_pc_+3A_...">...</code></td>
<td>

<p>any additional arguments to be passed on to <code>sim_pwn</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>x</code> can be used to specify two types of initialisation
values - &lsquo;before&rsquo; and &lsquo;init&rsquo;. They are used similarly in computations
but &lsquo;before&rsquo; values are not included in the result, while &lsquo;init&rsquo;
values are (unless dropped due to <code>n.start</code>). &lsquo;Before&rsquo; values
provide a convenient way to simulate continuation trajectories for a
time series, for example for simulation based prediction intervals.
</p>
<p>If <code>x</code> is <code>"numeric"</code>, it represents &lsquo;before&rsquo;
values. Alternatively, <code>x</code> can be a list with components
<code>"before"</code> and <code>"init"</code>.
</p>
<p>Innovations are usually generated with the random number generator
specified by <code>randgen</code> (with default <code>rnorm</code>) and the
<code>...</code> parameters by a call to the function <code>sim_pwn</code>, see
the documentation for <code>sim_pwn</code> for various ways to control the
distribution of the generated sequence.
</p>
<p>The innovations can also be generated in advance and supplied using
argument <code>eps</code>. If <code>eps</code> is numeric, it is taken to
represent the innovations. Alternatively, <code>eps</code> can be a list
with the innovations in component <code>"main"</code>. This list may also
contain components <code>"before"</code> and/or <code>"init"</code> specifying
&lsquo;before&rsquo; or &lsquo;initial&rsquo; values, with interpretation as for <code>x</code>.
</p>
<p><code>nintercept</code> can be used to specify trend representing the effect
of time and/or covariates. As for <code>eps</code>, if it is numeric it is
taken to represent the main values. It can also be a list with
components <code>before</code>, <code>init</code>, and <code>main</code>. 
</p>
<p>To avoid ambiguity, let's reiterate that <em>before</em> values are past
values of the corresponding quantity (before the start of the
simulated series), while <em>init</em> values are &quot;initial&quot; values. In
particular, if initial values are specified for <code>x</code>, these will
form the start of the generated series (unless <code>n.start</code> leads to
them being discarded).
</p>
<p>If <em>before</em> values are specified for the series and the
innovations, then they play a role analogous to that of initial
values, so it does not make much sense to supply also <em>initial</em>
values.
</p>
<p>The function effectively does the following.
<code>innov</code> is generated if not supplied,
a vector of innovations is created
<code>eps &lt;- c(innovbefore,innovinit,innov)</code>,
a vector <code>x</code> is created of the same length as <code>eps</code>,
and initialised with <code>xbefore</code> and <code>xinit</code>.
If there are no initial or before values, these are assumed to be 0.
The remaining values of <code>x</code> are filled using the pc-arma equations.
Finally, the <code>xbefore</code> values are discarded as well as the first
<code>n.start</code> values.
</p>
<p><code>n.start</code> should usually be a multiple of the period since
otherwise the first observation in the returned vector will not
correspond to <code>seasonof1st</code>.
</p>
<p><code>sim_pc</code> deals mainly with the interpretation of the parameters.
The actual computations are done by <code>pc.filter</code>. Moreover,
<code>sim_pc</code> does not look at the <code>model</code>. It knows only about
<code>model$period</code> and uses it to compute <code>n</code> if <code>n</code> is not
specified.
(It probably should not care even about this.)
</p>


<h3>Value</h3>

<p>numeric, the simulated time series
</p>


<h3>To do</h3>

<p>option to return the innovation sequence;
option to include the before values.
</p>
<p>option to return the season of the first value in the returned series
(it may be different from seasonof1st due to <code>n.start</code>).
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sim_pwn">sim_pwn</a></code>, <code><a href="#topic+pc.filter">pc.filter</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- rbind( c(1, 0.81, 0), c(1, 0.4972376, 0.4972376) )
testphi &lt;- slMatrix( init = m1 )

m2 &lt;- rbind( c(1, 0, 0), c(1, 0, 0) )
testtheta &lt;- slMatrix( init = m2 )

## phi and theta are slMatrix here.
mo1 &lt;- list(phi = testphi, theta = testtheta, p = 2, q = 2, period = 2)
set.seed(1234)
a1 &lt;- sim_pc(mo1, 100)

## phi and theta are ordinary matrices here.
mo2 &lt;- list(phi = m1[ , 2:ncol(m1)], theta = m2[ , 2:ncol(m2)], p = 2, q = 2, period = 2)
set.seed(1234)
a2 &lt;- sim_pc(mo2, 100)
identical(a1, a2)

## Lina's PAR model
parcoef    &lt;- rbind(c(0.5, -0.06), c(0.6, -0.08),
                    c(0.7, -0.1),  c(0.2, 0.15) )
picoef1    &lt;- c(0.8, 1.25, 2, 0.5)
parcoef2   &lt;- pi1ar2par(picoef1, parcoef)

picoef2    &lt;- c(4, 0.25, 5, 0.2)
coefper2I2 &lt;- pi1ar2par(picoef2, parcoef2)

#### specify the model using multi-companion approach
mc2I2       &lt;- mcompanion::mc_from_filter(coefper2I2)
co2I2       &lt;- eigen(mc2I2)$vectors
co2I2
m2I2 &lt;-  mcompanion::sim_pcfilter(period = 4, n.root = 4,
                 eigabs = c(1, 0.036568887, 0.001968887),
                 eigsign = c(1, 1, -1),
                 len.block = c(2, 1, 1),
                 type.eigval  =  c("r", "r", "r"),
                 co = cbind(co2I2[ ,1], rep(NA, 4), co2I2[,3:4]))
m2I2$pcfilter
perunit2mc  &lt;- sim_pc(list(phi = m2I2$pcfilter, p = 4, q = 0, period = 4), 500)
plot(perunit2mc)
plot(perunit2mc, type = "p")

# todo: give example with sigmat^2 !!!
</code></pre>

<hr>
<h2 id='sim_pwn'>Simulate periodic white noise</h2><span id='topic+sim_pwn'></span>

<h3>Description</h3>

<p>Simulate periodic white noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_pwn(n = 100, period = NA, seasonof1st = 1, scale = NULL, 
        shift = NULL, f = rnorm, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_pwn_+3A_n">n</code></td>
<td>
<p>length of the generated sample.</p>
</td></tr>
<tr><td><code id="sim_pwn_+3A_period">period</code></td>
<td>
<p>number of seasons in an epoch.</p>
</td></tr>
<tr><td><code id="sim_pwn_+3A_seasonof1st">seasonof1st</code></td>
<td>
<p>season of the first observation in the result.</p>
</td></tr>
<tr><td><code id="sim_pwn_+3A_scale">scale</code></td>
<td>

<p>scale the series by this amount, a vector of length <code>period</code> or 1.
</p>
</td></tr>
<tr><td><code id="sim_pwn_+3A_shift">shift</code></td>
<td>

<p>shift the series by this amount, a vector of length <code>period</code> or 1.
</p>
</td></tr>
<tr><td><code id="sim_pwn_+3A_f">f</code></td>
<td>

<p>a function or list of functions to generate random numbers.
</p>
</td></tr>
<tr><td><code id="sim_pwn_+3A_...">...</code></td>
<td>

<p>arguments for the random number generator(s) specified by <code>f</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First a series, say <code class="reqn">x</code>, of random numbers is generated as
requested by the argument <code>f</code>. Then, if <code>shift</code> and/or
<code>scale</code> are supplied, the values are modified as follows:
</p>
<p style="text-align: center;"><code class="reqn">y_t = shift_{k} + scale_{k} x_t</code>
</p>

<p>where  <code class="reqn">k</code> is the season corresponding to time <code class="reqn">t</code>.
The vector <code class="reqn">y</code> is returned.
</p>
<p>If <code>f</code> is a single a function (or name of a function), then the
series is generated (effectively) by the call <code>f(n,...)</code>.
</p>
<p>The argument <code>f</code> may also be a list whose <code class="reqn">k</code>th element
is itself a list specifying the random number generator for the
<code class="reqn">k</code>th season. The first element being the function (such as
<code>rnorm</code>) and the remaining elements being parameters for that
function.  Parameters common to all seasons may be supplied through
the ... argument.
</p>
<p>The argument <code>period</code> may be omitted. In that case it is inferred
from <code>f</code> and/or the lengths of <code>shift</code> and
<code>scale</code>. Currently there is no check for consistency here.
</p>
<p>The arguments <code>shift</code> and <code>scale</code> may be used to specify
simple linear transformations of the generated values, possibly
different for the different seasons. Each of them should be a vector
of length <code>period</code> or one.
</p>
<p><code>seasonof1st</code> can be used to request the simulated time series to
start from a season other than the first one.  Note that whatever the
value of <code>seasonof1st</code>, the first elements of <code>scale</code>,
<code>shift</code> and <code>f</code> (if a list) are taken to refer to season
one.
</p>


<h3>Value</h3>

<p>A vector of length <code class="reqn">n</code> representing a realization of a periodic
white noise series. The season of the first observation is
<code>seasonof1st</code>.
</p>


<h3> Level </h3>

<p> 0 (base) </p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>## three equivalent ways to specify periodic white noise with
## normal innovatios, 2 seasons, s.d. = 0.5 for season 1, and 2 for season 2
sim_pwn(100, f = rnorm, scale = c(0.5, 2))
sim_pwn(n = 100, scale = c(0.5, 2))  # rnorm is the default generator
sim_pwn(100, f = list(c(rnorm, 0, 0.5), c(rnorm, 0, 2)))
</code></pre>

<hr>
<h2 id='SimpleCycle-class'>Class SimpleCycle</h2><span id='topic+SimpleCycle-class'></span>

<h3>Description</h3>

<p>Class SimpleCycle.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("SimpleCycle",
  nseasons, seasons, first)</code>.
</p>

<p>In addition to number of seasons, class <code>"SimpleCycle"</code> holds
also seasons' names and the index of the season to be treated as the
first in a cycle.
</p>


<h3>Slots</h3>


<dl>
<dt><code>seasons</code>:</dt><dd><p>Object of class <code>"character"</code>,
the names of the seasons.
</p>
</dd>
<dt><code>nseasons</code>:</dt><dd><p>Object of class <code>"integer"</code>,
number of seasons.
</p>
</dd>
<dt><code>cycle</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>season</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>abbreviated</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+BareCycle-class">BareCycle</a>"</code>, directly.
Class <code>"<a href="#topic+BasicCycle-class">BasicCycle</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>allSeasons</dt><dd><p><code>signature(x = "SimpleCycle", abb = "ANY")</code>: ... </p>
</dd>
<dt>allSeasons&lt;-</dt><dd><p><code>signature(x = "SimpleCycle")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "BareCycle", to = "SimpleCycle")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "BuiltinCycle", to = "SimpleCycle")</code>: ... </p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "SimpleCycle")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "SimpleCycle")</code>: ... </p>
</dd>
<dt>unitCycle</dt><dd><p><code>signature(x = "SimpleCycle")</code>: ... </p>
</dd>
<dt>unitCycle&lt;-</dt><dd><p><code>signature(x = "SimpleCycle")</code>: ... </p>
</dd>
<dt>unitSeason</dt><dd><p><code>signature(x = "SimpleCycle")</code>: ... </p>
</dd>
<dt>unitSeason&lt;-</dt><dd><p><code>signature(x = "SimpleCycle")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcCycle">pcCycle</a></code> for creation of cycle objects and extraction of
cycle part of time series,
</p>
<p><code><a href="#topic+BuiltinCycle-class">BuiltinCycle-class</a></code>,
<code><a href="#topic+SimpleCycle-class">SimpleCycle-class</a></code>,
</p>
<p><code><a href="#topic+DayWeekCycle-class">DayWeekCycle-class</a></code>,
<code><a href="#topic+MonthYearCycle-class">MonthYearCycle-class</a></code>,
<code><a href="#topic+OpenCloseCycle-class">OpenCloseCycle-class</a></code>,
<code><a href="#topic+QuarterYearCycle-class">QuarterYearCycle-class</a></code>,
<code><a href="#topic+PartialCycle-class">PartialCycle-class</a></code>
</p>
<p><code><a href="#topic+BasicCycle-class">BasicCycle-class</a></code> (virtual, for use in signatures)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("SimpleCycle")
</code></pre>

<hr>
<h2 id='SiPeriodicArmaModel-class'>Class SiPeriodicArmaModel</h2><span id='topic+SiPeriodicArmaModel-class'></span>

<h3>Description</h3>

<p>Class SiPeriodicArmaModel.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("SiPeriodicArmaModel", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>iorder</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>siorder</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>pcmodel</code>:</dt><dd><p>Object of class <code>"PeriodicArmaModel"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+VirtualPeriodicFilterModel-class">VirtualPeriodicFilterModel</a>"</code>, directly.
Class <code>"<a href="#topic+PeriodicIntegratedArmaSpec-class">PeriodicIntegratedArmaSpec</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;SiPeriodicArmaModel&quot; in the signature.
</p>

<hr>
<h2 id='SiPeriodicArModel-class'>Class SiPeriodicArModel</h2><span id='topic+SiPeriodicArModel-class'></span>

<h3>Description</h3>

<p>Class SiPeriodicArModel.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("SiPeriodicArModel", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>iorder</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>siorder</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>pcmodel</code>:</dt><dd><p>Object of class <code>"PeriodicArmaModel"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+SiPeriodicArmaModel-class">SiPeriodicArmaModel</a>"</code>, directly.
Class <code>"<a href="#topic+VirtualPeriodicFilterModel-class">VirtualPeriodicFilterModel</a>"</code>, by class &quot;SiPeriodicArmaModel&quot;, distance 2.
Class <code>"<a href="#topic+PeriodicIntegratedArmaSpec-class">PeriodicIntegratedArmaSpec</a>"</code>, by class &quot;SiPeriodicArmaModel&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>fitPM</dt><dd><p><code>signature(model = "SiPeriodicArModel", x = "ANY")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "SiPeriodicArModel")</code>: ... </p>
</dd>
</dl>


<hr>
<h2 id='SiPeriodicMaModel-class'>Class SiPeriodicMaModel</h2><span id='topic+SiPeriodicMaModel-class'></span>

<h3>Description</h3>

<p>Class SiPeriodicMaModel.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("SiPeriodicMaModel", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>iorder</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>siorder</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>pcmodel</code>:</dt><dd><p>Object of class <code>"PeriodicArmaModel"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+SiPeriodicArmaModel-class">SiPeriodicArmaModel</a>"</code>, directly.
Class <code>"<a href="#topic+VirtualPeriodicFilterModel-class">VirtualPeriodicFilterModel</a>"</code>, by class &quot;SiPeriodicArmaModel&quot;, distance 2.
Class <code>"<a href="#topic+PeriodicIntegratedArmaSpec-class">PeriodicIntegratedArmaSpec</a>"</code>, by class &quot;SiPeriodicArmaModel&quot;, distance 2.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;SiPeriodicMaModel&quot; in the signature.
</p>

<hr>
<h2 id='sl_utils'> Functions for some basic operations with seasons</h2><span id='topic+toSeason'></span><span id='topic+toSeasonPair'></span><span id='topic+ttTosl'></span><span id='topic+ttmatToslPairs'></span>

<h3>Description</h3>

<p>Functions for some basic operations with seasons.</p>


<h3>Usage</h3>

<pre><code class='language-R'>toSeason(t, period, t1 = 1, from = 1)
toSeasonPair(t, s, period, ...)
ttTosl(r, period)
ttmatToslPairs(i, j, period)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sl_utils_+3A_r">r</code></td>
<td>
<p>covariance matrix, see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="sl_utils_+3A_t">t</code></td>
<td>
<p>a vector of integers, representing times.</p>
</td></tr>
<tr><td><code id="sl_utils_+3A_s">s</code></td>
<td>
<p>a vector of integers, representing times.</p>
</td></tr>
<tr><td><code id="sl_utils_+3A_period">period</code></td>
<td>
<p>the number of seasons.</p>
</td></tr>
<tr><td><code id="sl_utils_+3A_t1">t1</code></td>
<td>
<p>time corresponding to the first season, an integer number.</p>
</td></tr>
<tr><td><code id="sl_utils_+3A_from">from</code></td>
<td>
<p>1 or 0, depending on whether the season numbers start from
1 or 0.</p>
</td></tr>
<tr><td><code id="sl_utils_+3A_i">i</code></td>
<td>
<p>a vector of integers.</p>
</td></tr>
<tr><td><code id="sl_utils_+3A_j">j</code></td>
<td>
<p>a vector of integers.</p>
</td></tr>
<tr><td><code id="sl_utils_+3A_...">...</code></td>
<td>
<p> todo: describe! </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ttmatToslPairs(i,j,period)</code> transforms time-time pairs to
season-lag pairs. The time pairs are obtained by pairing each element
of <code>i</code> with each element of <code>j</code>. A four column matrix is
created with one row for each pair <code>(t,s)</code>, such that
<code>t=i[m]</code> and <code>s=j[n]</code> for some <code>m</code> and <code>n</code>.  The
row is <code>m, n, s, l</code>, where <code>(s,l)</code> is the season-lag pair
corresponding to <code>(t,s)</code>.
</p>
<p><code>ttTosl(r,period)</code> converts autocovariances given in a covariance
matrix (i.e. in &ldquo;tt&rdquo; form) to the &ldquo;sl&rdquo; form. The result is a
<code>period x (maxlag+1)</code> matrix, where <code>maxlag</code> is the maximal
lag available in <code>r</code>. Entries for which no values are available
are filled with <code>NA</code>'s.  Warning is given if contradictory entries
are found (i.e. if <code>r</code> is not from a periodically correlated
process with the given period).
</p>
<p><code>toSeason(t,period,t1=1,from=1)</code> returns the season corresponding
to <code>t</code>.  <code>t1</code> is a time (integer) whose season is the first
season, <code>from</code> is 1 if the numbering of seasons is 1,2,...,period,
or 0 if the numbering of seasons is 0,1,...,period-1.  Other values for
<code>from</code> are not admissible (but not checked).  <strong>Note:</strong> some
of the functions in this package implicitly assume that <code>t1=1</code> and
<code>from=1</code>.
</p>
<p><code>toSeasonPair(t,s,period)</code> converts the &ldquo;tt&rdquo; pair <code>t,s</code> to
&ldquo;sl&rdquo; pair and returns the result in the form of a list with elements
<code>season</code> and <code>lag</code>. Currently <code>t</code> and <code>s</code> must be
scalars.
</p>
<p><code>pc.omitneg</code> helps to implement dropping of negative indices in
season-lag objects. It returns its first argument, <code>lags</code>, if all
of its elements are non-negative. Otherwise, all elements of
<code>lags</code> must be non-positive. In this case the function creates the
vector <code>0:maxlag</code> and drops the elements specified by lags.  Note
that the default indexing will not work properly since zero elements in
an index are omitted (and there are such indices in season-lag
objects).
</p>


<h3>Value</h3>

<p>for <code>ttmatToslPairs</code>, a matrix with four columns;
</p>
<p>for <code>ttTosl</code>, a matrix with <code>period</code> rows;
</p>
<p>for <code>toSeason(t,period,t1=1,from=1)</code>, a vector of integers;
</p>
<p>for <code>toSeasonPair(t,s,period)</code>, a list with elements
<code>season</code> and <code>lag</code>;
</p>
<p>for <code>pc.omitneg</code>, a vector of lags (non-negative integers).
</p>


<h3>Note</h3>

<p>2013-10-24 - Corrected the description of the return value of
<code>ttmatToslPairs</code>. It incorrectly stated that the first two
columns are &quot;tt&quot; pair (they are actually indices in <code>i</code> and
<code>j</code>).
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>

<p>Boshnakov GN, Iqelan BM (2009).
&ldquo;Generation of time series models with given spectral properties.&rdquo;
<em>J. Time Series Anal.</em>, <b>30</b>(3), 349&ndash;368.
ISSN 0143-9782, <a href="https://doi.org/10.1111/j.1467-9892.2009.00617.x">doi:10.1111/j.1467-9892.2009.00617.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ttmatToslPairs
ttmatToslPairs(3, 3, 4)  # 1, 1, 3, 0
ttmatToslPairs(3, 2, 4)  # 1, 1, 3, 1

ttmatToslPairs(1:4, 1:4, 4)

ttmatToslPairs(3:4, 3:4, 4)

# ttTosl -  :todo:

# toSeason
toSeason(1:10, 4)           # 1 2 3 4  1 2 3 4  1 2
toSeason(1:10, 4, from = 0) # 0 1 2 3  0 1 2 3  0 1

## first data is for 3rd quarter
toSeason(1:10, 4, t1 = 3)  # 3 4 1 2 3 4 1 2 3 4

# toSeasonPair
toSeasonPair(3, 3, period=4) # season=3, lag = 0
toSeasonPair(8, 8, period=4) # season=4, lag = 0

toSeasonPair(3, 2, period=4) # season=3, lag = 1
toSeasonPair(7, 6, period=4) # same

#### # pc.omitneg
#### pc.omitneg(0:5,10) # 0:5, unchaged since all values &gt;= 0
#### 
#### pc.omitneg(-(0:5),10) # 6:10, works like
#### (0:10)[-(0:5 +1)]     # same
#### 
#### # don't mix positive and negative numbers in pc.omitneg
#### \dontrun{pc.omitneg(c(0,2,3,-4,5), 10)}
</code></pre>

<hr>
<h2 id='SLTypeMatrix-class'>Class SLTypeMatrix</h2><span id='topic+SLTypeMatrix-class'></span>

<h3>Description</h3>

<p>Class SLTypeMatrix is a virtual class for classes that can hold
objects with season-lag conventions. 
</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;SLTypeMatrix&quot; in the signature.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("SLTypeMatrix")
</code></pre>

<hr>
<h2 id='SubsetPM-class'>Class SubsetPM</h2><span id='topic+SubsetPM-class'></span><span id='topic+coef+2CSubsetPM-method'></span><span id='topic+fitted+2CSubsetPM-method'></span><span id='topic+residuals+2CSubsetPM-method'></span><span id='topic+show+2CSubsetPM-method'></span><span id='topic+vcov+2CSubsetPM-method'></span>

<h3>Description</h3>

<p>Class <code>"SubsetPM"</code> - subset PAR models with trigonometric
parameterisation.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("SubsetPM", ...)</code>
but they are typically created by model fitting functions, see the examples.
</p>


<h3>Slots</h3>


<dl>
<dt><code>theTS</code>:</dt><dd>
<p><code>"ANY"</code>, the time series to which the model is fitted.
</p>
</dd>
<dt><code>period</code>:</dt><dd>
<p><code>"integer"</code>, the period.
</p>
</dd>
<dt><code>order</code>:</dt><dd><p><code>"integer"</code>, the order.
</p>
</dd>
<dt><code>findex</code>:</dt><dd>
<p><code>"function"</code>.
</p>
</dd>
<dt><code>harmonics</code>:</dt><dd>
<p><code>"integer"</code>, Fourier harmonics to include in the model.
</p>
</dd>
<dt><code>call</code>:</dt><dd>
<p><code>"call"</code>, the call used to fit the model.
</p>
</dd>
<dt><code>other</code>:</dt><dd>
<p><code>"namedList"</code>.
</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p><code>signature(object = "SubsetPM")</code>: ... </p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "SubsetPM")</code>: ... </p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "SubsetPM")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "SubsetPM")</code>: ... </p>
</dd>
<dt>vcov</dt><dd><p><code>signature(object = "SubsetPM")</code>: ... </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+fit_trigPAR_optim">fit_trigPAR_optim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pcfr4 &lt;- pcts(dataFranses1996)[[4]]
x4 &lt;- as.numeric(window(pcfr4, start = availStart(pcfr4), end = availEnd(pcfr4)))

## without 'harmonics' these models are equivalent
tmpfit  &lt;- fit_trigPAR_optim(x4, 2, 4, tol = 1e-14, verbose = FALSE)
tmpfitL &lt;- fit_trigPAR_optim(x4, 2, 4, tol = 1e-14, type = "bylag", verbose = FALSE)

## for comparison
tmpfitP &lt;- pclsdf(x4, 4, 1:2, sintercept = FALSE)

## with intercept
tmpfitc  &lt;- fit_trigPAR_optim(x4, 2, 4, tol = 1e-14, verbose = FALSE,
    sintercept = TRUE)
tmpfitcn  &lt;- fit_trigPAR_optim(x4, 2, 4, tol = 1e-14, verbose = FALSE,
    sintercept = structure(TRUE, merge = TRUE))
tmpfitLc &lt;- fit_trigPAR_optim(x4, 2, 4, tol = 1e-14, type = "bylag",
    verbose = FALSE, sintercept = TRUE)

coef(tmpfitc, matrix = TRUE)
coef(tmpfitcn, matrix = TRUE)
coef(tmpfitLc, matrix = TRUE)

coef(tmpfitc)
coef(tmpfitcn)
coef(tmpfitLc)

coef(tmpfit)
coef(tmpfitL)

## convert to PAR coefficients:
coef(tmpfitc,  type = "PAR", matrix = TRUE)
coef(tmpfitcn, type = "PAR", matrix = TRUE)
coef(tmpfitLc, type = "PAR", matrix = TRUE)

coef(tmpfitL, type = "PAR", matrix = TRUE)



predict(tmpfitc, n.ahead = 4)
predict(tmpfitcn, n.ahead = 4)

sqrt(diag((vcov(tmpfitL))))
e &lt;- residuals(tmpfitL)
fi &lt;-  fitted(tmpfitL)
</code></pre>

<hr>
<h2 id='tail-methods'>Methods for function tail() in package pcts</h2><span id='topic+tail-methods'></span><span id='topic+tail+2CPeriodicTimeSeries-method'></span>

<h3>Description</h3>

<p>Methods for function tail() in package pcts.</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "PeriodicTimeSeries")</code></dt><dd>
</dd>
</dl>

<hr>
<h2 id='test_piar'>Test for periodic integration</h2><span id='topic+test_piar'></span>

<h3>Description</h3>

<p>Test if a time series is periodically integrated.</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_piar(x, d, p, sintercept = FALSE, sslope = FALSE, homoschedastic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_piar_+3A_x">x</code></td>
<td>
<p>time series.</p>
</td></tr>
<tr><td><code id="test_piar_+3A_d">d</code></td>
<td>
<p>period.</p>
</td></tr>
<tr><td><code id="test_piar_+3A_p">p</code></td>
<td>
<p>autoregressive order, a positive integer.</p>
</td></tr>
<tr><td><code id="test_piar_+3A_sintercept">sintercept</code></td>
<td>
<p>if TRUE, include seasonal intercept.</p>
</td></tr>
<tr><td><code id="test_piar_+3A_sslope">sslope</code></td>
<td>
<p>if TRUE, include seasonal slope.</p>
</td></tr>
<tr><td><code id="test_piar_+3A_homoschedastic">homoschedastic</code></td>
<td>
<p>if TRUE, assume the innovations variance is the
same for all seasons.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes test statistics for Franses (1996) test for periodic
integration of order 1. The test is based on periodic autoregression
of order <code>p</code>, where <code>p</code> can be any positive integer.
</p>


<h3>Value</h3>

<p>a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>p</code></td>
<td>
<p>autoregressive order.</p>
</td></tr>
<tr><td><code>spec</code></td>
<td>

<p>values of <code>sintercept</code>, <code>sslope</code>, and
<code>homoschedastic</code>, a named logical vector.
</p>
</td></tr>
<tr><td><code>statistics</code></td>
<td>

<p>a matrix containing the test statistics (first row) and the
corresponding p-values (second row).  <code>"LR"</code> is not normalised,
so its p-value is <code>NA</code>.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Currently only the case <code>p = 1</code> is handled, for <code>p &gt; 1</code> the
statistics are set to NA. <strong>:TODO: handle this.</strong>
</p>
<p>All statistics are computed but some p-values are not computed yet.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>References</h3>


<p>Boswijk HP and Franses PH (1996).
&ldquo;Unit roots in periodic autoregressions.&rdquo;
<em>Journal of Time Series Analysis</em>, <b>17</b>(3), pp. 221&ndash;245.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pclspiar">pclspiar</a></code>,
<code><a href="#topic+pclsdf">pclsdf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ts1 &lt;- window(dataFranses1996[ , "CanadaUnemployment"],
              start = c(1960, 1), end = c(1987, 4))
test_piar(ts1, 4, 1, sintercept = TRUE)
pcTest(ts1, "piar", 4, 1, sintercept = TRUE) # same

test_piar(ts1, 4, 1, sintercept = TRUE, sslope = TRUE)
test_piar(ts1, 4, 1)              
test_piar(ts1, 4, 1, homoschedastic = TRUE)              
</code></pre>

<hr>
<h2 id='unitCycle-methods'>Methods for <code>unitCycle</code> and <code>unitSeason</code> in package pcts</h2><span id='topic+unitCycle-methods'></span><span id='topic+unitCycle+2CANY-method'></span><span id='topic+unitCycle+2CVirtualPeriodicModel-method'></span><span id='topic+unitCycle+2CCyclic-method'></span><span id='topic+unitCycle+2CSimpleCycle-method'></span><span id='topic+unitCycle+2CPartialCycle-method'></span><span id='topic+unitCycle+2COpenCloseCycle-method'></span><span id='topic+unitCycle+2CQuarterYearCycle-method'></span><span id='topic+unitCycle+2CDayWeekCycle-method'></span><span id='topic+unitCycle+2CMonthYearCycle-method'></span><span id='topic+unitCycle+2CEvery30MinutesCycle-method'></span><span id='topic+unitSeason-methods'></span><span id='topic+unitSeason+2CANY-method'></span><span id='topic+unitSeason+2CVirtualPeriodicModel-method'></span><span id='topic+unitSeason+2CCyclic-method'></span><span id='topic+unitSeason+2CSimpleCycle-method'></span><span id='topic+unitSeason+2CPartialCycle-method'></span><span id='topic+unitSeason+2COpenCloseCycle-method'></span><span id='topic+unitSeason+2CQuarterYearCycle-method'></span><span id='topic+unitSeason+2CDayWeekCycle-method'></span><span id='topic+unitSeason+2CMonthYearCycle-method'></span><span id='topic+unitSeason+2CEvery30MinutesCycle-method'></span>

<h3>Description</h3>

<p>Methods for <code>unitCycle</code> and <code>unitSeason</code> in package pcts.</p>


<h3>Methods</h3>

<p><code>unitCycle</code> and <code>unitSeason</code> have methods with identical
signatures:
</p>

<dl>
<dt><code>signature(x = "ANY")</code></dt><dd>

</dd>
<dt><code>signature(x = "VirtualPeriodicModel")</code></dt><dd>

</dd>
<dt><code>signature(x = "Cyclic")</code></dt><dd>

</dd>
<dt><code>signature(x = "SimpleCycle")</code></dt><dd>

</dd>
<dt><code>signature(x = "PartialCycle")</code></dt><dd>

</dd>
<dt><code>signature(x = "OpenCloseCycle")</code></dt><dd>

</dd>
<dt><code>signature(x = "QuarterYearCycle")</code></dt><dd>

</dd>



<dt><code>signature(x = "DayWeekCycle")</code></dt><dd>

</dd>
<dt><code>signature(x = "MonthYearCycle")</code></dt><dd>

</dd>
<dt><code>signature(x = "Every30MinutesCycle")</code></dt><dd>

</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+allSeasons">allSeasons</a></code> for examples and related functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## presidents is a quarterly time series in base-R
tsp(presidents)

pc_presidents &lt;- pcts(presidents)
unitCycle(pc_presidents)
unitSeason(pc_presidents)
</code></pre>

<hr>
<h2 id='unitCycle+26lt+3B+26ndash+3Bmethods'>Methods for <code>`unitCycle&lt;-`</code> and <code>`unitSeason&lt;-`</code> in package pcts</h2><span id='topic+unitCycle+3C--methods'></span><span id='topic+unitCycle+3C-+2CCyclic-method'></span><span id='topic+unitCycle+3C-+2CSimpleCycle-method'></span><span id='topic+unitSeason+3C--methods'></span><span id='topic+unitSeason+3C-+2CCyclic-method'></span><span id='topic+unitSeason+3C-+2CSimpleCycle-method'></span>

<h3>Description</h3>

<p>Methods for <code>`unitCycle&lt;-`</code> and <code>`unitSeason&lt;-`</code>
in package pcts.
</p>


<h3>Methods</h3>

<p><code>`unitCycle&lt;-`</code> and <code>`unitSeason&lt;-`</code> have methods with identical
signatures:
</p>

<dl>
<dt><code>signature(x = "Cyclic")</code></dt><dd>

</dd>
<dt><code>signature(x = "SimpleCycle")</code></dt><dd>

</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+allSeasons">allSeasons</a></code> for related functions and examples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qrt &lt;- BuiltinCycle(4)
unitSeason(qrt)                 # "Quarter"
unitCycle(qrt)                  # "Year"

moreve &lt;- new("SimpleCycle", 2)
unitSeason(moreve)             # "Season"
unitCycle(moreve)              # "Cycle"
allSeasons(moreve)             # c("Season_1", "Season_2")

## change the names
unitCycle(moreve) &lt;- "Day"
unitSeason(moreve) &lt;- "TimeOfDay"
allSeasons(moreve) &lt;- c("Morning", "Evening")

unitSeason(moreve)
unitCycle(moreve) 
allSeasons(moreve)
</code></pre>

<hr>
<h2 id='Vec'>Core data of periodic time series</h2><span id='topic+Vec'></span><span id='topic+tsMatrix'></span><span id='topic+tsVector'></span><span id='topic+tsVec'></span><span id='topic+pcMatrix'></span><span id='topic+pcArray'></span><span id='topic+pctsArray'></span>

<h3>Description</h3>

<p>Extract the core data from a periodic time series as a vector, matrix
or array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Vec(x, ...)

tsMatrix(x, ...)

tsVector(x, ...)

tsVec(x, ...)

pcMatrix(x, ...)

pcArray(x, ndim = 3, ...)

pctsArray(x, ndim = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Vec_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="Vec_+3A_...">...</code></td>
<td>
<p>further arguments for methods.</p>
</td></tr>
<tr><td><code id="Vec_+3A_ndim">ndim</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions give the core data in various common forms.
</p>
<p>The data values can be extracted as a vector from a periodic time
series object, say <code>x</code>, with <code>as.vector(x)</code> or <code>as(x,
  "vector")</code>.  For multivariate time series the vector returned by
<code>as.vector(x)</code> (or <code>as(x, "vector")</code>) is equivalent to
<code>as.vector(as.matrix(x))</code>.
</p>
<p>Similarly, <code>as.matrix()</code> and <code>as(x, "matrix")</code>
extract the data as a matrix containing one column per variable.  
</p>
<p><code>Vec()</code> is like <code>as.vector()</code> but the result is a matrix
with one column (column vector). The default does literally this.
Thus both, <code>Vec()</code> and <code>as.vector()</code>, implement the
<strong>Vec</strong> operation from matrix calculus but the latter returns the
result as a vector, not matrix.
</p>
<p>The most common representation of data in statistics is matrix-like
with one column per variable.  The descriptions of algorithms for
multivariate time series however usually define the vector of
observations at a given time to be a column vector. In particular,
implementations of the Kalman filter often require precisely this
arrangement.  In that case the data matrix is the transposed of the
more common one and the vectorising operation stacks the observations,
not the variables.
</p>
<p>The functions <code>tsMatrix()</code>, <code>tsVector()</code> and <code>tsVec()</code>
provide the analogues of <code>as.vector()</code>, <code>as.matrix()</code> and
<code>Vec()</code> for the &ldquo;transposed&rdquo; arrangement.
</p>
<p>These functions may look redundant since they are simple combinations
of the above and traspose operations. Having functions makes for more
readable programming. They may be more efficient, as well, for example
if the underlying time series class stores the data in the transposed
format.
</p>
<p><code>pcMatrix()</code> and <code>pcArray()</code> also give the core
data. Effectively, they give an additional dimension to the
seasons. The season becomes the first dimension since for column
oriented data the season changes fastest. <code>pcMatrix</code> is most
suitable for univariate time series, <code>pcArray()</code> for
multivariate. Note that <code>pcArray()</code> easily extends to multiple
periodicities although currently (2019-04-19) there are no methods
that exploit this.
</p>
<p>For univariate time series, in the matrix returned by
<code>pcMatrix()</code> each row represents the data for one season and each
column for one cycle. For multivariate time series, the matrices for
each variable are put next to each other.
</p>
<p><code>pcArray()</code> returns the data as an array, whose last dimension
corresponds to variables.  In the default case the array is
3-dimensonal with dimensions (season, year, variable).
</p>
<p><code>pctsArray()</code> is a variant of <code>pcArray()</code> corresponding to
the arrangement of <code>tsMatrix()</code>. The ordering of the dimensions
here is (variable, season, cycle).
</p>




<h3>Value</h3>

<p>vector, matrix or array, as indicated by the name of the function and
described in section &lsquo;Details&rsquo;. 
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov</p>


<h3>Examples</h3>

<pre><code class='language-R'>## window to make number of years different from number of months
ap &lt;- pcts(window(AirPassengers, start = c(1956, 1)))
class( as.vector(ap)    )
class( as(ap, "vector") )

dim( as.matrix(ap)    )
dim( as(ap, "matrix") )

dim( tsMatrix(ap) )

class( tsVector(ap) ) 
dim(   tsVec(ap)    ) 

dim( pcMatrix(ap)   )
dim( pcArray(ap)    )
dim( pctsArray(ap)  )

dfr &lt;- pcts(dataFranses1996)
dim(dfr)                     # c(148, 19)
nSeasons(dfr)                # 4

length(as.vector(dfr))

all.equal(as.vector(dfr)[1:148],       as.matrix(dfr)[ , 1]) # TRUE
all.equal(tsVector(dfr)[1:19],  unname(as.matrix(dfr)[1, ])) # TRUE

dim( as.matrix(dfr) ) # c(148, 19)
dim( tsMatrix(dfr)  ) # c(19, 148)
all.equal(tsMatrix(dfr)[ , 1],  as.matrix(dfr)[1, ]) # TRUE

dim( Vec(dfr)   ) 
dim( tsVec(dfr) ) 
all.equal(tsVec(dfr)[1:19],  unname(as.matrix(dfr)[1, ])) # TRUE

dim( pcMatrix(dfr)   ) # c(4, 703), one row for each season
dim( pcArray(dfr)    ) # c(4, 37, 19), note: 703 == 37*19   

dim( pctsArray(dfr)  ) # c(19, 4, 37), note: 703 == 37*19   
</code></pre>

<hr>
<h2 id='VirtualPeriodicArmaModel-class'>Class VirtualPeriodicArmaModel</h2><span id='topic+VirtualPeriodicArmaModel-class'></span>

<h3>Description</h3>

<p>Class VirtualPeriodicArmaModel.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("VirtualPeriodicArmaModel", ...)</code>.
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+VirtualPeriodicFilterModel-class">VirtualPeriodicFilterModel</a>"</code>, directly.
Class <code>"<a href="#topic+VirtualPeriodicStationaryModel-class">VirtualPeriodicStationaryModel</a>"</code>, directly.
Class <code>"<a href="#topic+VirtualPeriodicAutocovarianceModel-class">VirtualPeriodicAutocovarianceModel</a>"</code>, by class &quot;VirtualPeriodicStationaryModel&quot;, distance 2.
Class <code>"<a href="#topic+VirtualPeriodicMeanModel-class">VirtualPeriodicMeanModel</a>"</code>, by class &quot;VirtualPeriodicStationaryModel&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>PeriodicArModel</dt><dd><p><code>signature(object = "VirtualPeriodicArmaModel")</code>: ... </p>
</dd></dl>


<hr>
<h2 id='VirtualPeriodicArModel-class'>~~ Dummy title ~~</h2><span id='topic+VirtualPeriodicArModel-class'></span>

<h3>Description</h3>

<p>~~ Dummy description ~~</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("VirtualPeriodicArModel", ...)</code>.
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+VirtualPeriodicArmaModel-class">VirtualPeriodicArmaModel</a>"</code>, directly.
Class <code>"<a href="#topic+VirtualPeriodicFilterModel-class">VirtualPeriodicFilterModel</a>"</code>, by class &quot;VirtualPeriodicArmaModel&quot;, distance 2.
Class <code>"<a href="#topic+VirtualPeriodicStationaryModel-class">VirtualPeriodicStationaryModel</a>"</code>, by class &quot;VirtualPeriodicArmaModel&quot;, distance 2.
Class <code>"<a href="#topic+VirtualPeriodicAutocovarianceModel-class">VirtualPeriodicAutocovarianceModel</a>"</code>, by class &quot;VirtualPeriodicArmaModel&quot;, distance 3.
Class <code>"<a href="#topic+VirtualPeriodicMeanModel-class">VirtualPeriodicMeanModel</a>"</code>, by class &quot;VirtualPeriodicArmaModel&quot;, distance 3.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;VirtualPeriodicArModel&quot; in the signature.
</p>

<hr>
<h2 id='VirtualPeriodicAutocorrelations-class'>~~ Dummy title ~~</h2><span id='topic+VirtualPeriodicAutocorrelations-class'></span>

<h3>Description</h3>

<p>~~ Dummy description ~~</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+VirtualPeriodicModel-class">VirtualPeriodicModel</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;VirtualPeriodicAutocorrelations&quot; in the signature.
</p>

<hr>
<h2 id='VirtualPeriodicAutocovarianceModel-class'>~~ Dummy title ~~</h2><span id='topic+VirtualPeriodicAutocovarianceModel-class'></span>

<h3>Description</h3>

<p>~~ Dummy description ~~</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "VirtualPeriodicAutocovarianceModel", i = "missing", j = "missing", drop = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "VirtualPeriodicAutocovarianceModel", i = "missing", j = "numeric", drop = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "VirtualPeriodicAutocovarianceModel", i = "numeric", j = "missing", drop = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "VirtualPeriodicAutocovarianceModel", i = "numeric", j = "numeric", drop = "ANY")</code>: ... </p>
</dd>
<dt>maxLag</dt><dd><p><code>signature(object = "VirtualPeriodicAutocovarianceModel")</code>: ... </p>
</dd>
<dt>autocorrelations</dt><dd><p><code>signature(x = "VirtualPeriodicAutocovarianceModel", maxlag = "missing", lag_0 = "ANY")</code>: ... </p>
</dd>
<dt>autocorrelations</dt><dd><p><code>signature(x = "VirtualPeriodicAutocovarianceModel", maxlag = "numeric", lag_0 = "ANY")</code>: ... </p>
</dd></dl>


<hr>
<h2 id='VirtualPeriodicAutocovariances-class'>~~ Dummy title ~~</h2><span id='topic+VirtualPeriodicAutocovariances-class'></span>

<h3>Description</h3>

<p>~~ Dummy description ~~</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+VirtualPeriodicModel-class">VirtualPeriodicModel</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>autocorrelations</dt><dd><p><code>signature(x = "VirtualPeriodicAutocovariances", maxlag = "ANY", lag_0 = "missing")</code>: ... </p>
</dd>
<dt>autocovariances</dt><dd><p><code>signature(x = "VirtualPeriodicAutocovariances", maxlag = "ANY")</code>: ... </p>
</dd>
<dt>backwardPartialCoefficients</dt><dd><p><code>signature(x = "VirtualPeriodicAutocovariances")</code>: ... </p>
</dd>
<dt>backwardPartialVariances</dt><dd><p><code>signature(x = "VirtualPeriodicAutocovariances")</code>: ... </p>
</dd>
<dt>partialAutocorrelations</dt><dd><p><code>signature(x = "VirtualPeriodicAutocovariances", maxlag = "ANY", lag_0 = "ANY")</code>: ... </p>
</dd>
<dt>partialAutocovariances</dt><dd><p><code>signature(x = "VirtualPeriodicAutocovariances")</code>: ... </p>
</dd>
<dt>partialCoefficients</dt><dd><p><code>signature(x = "VirtualPeriodicAutocovariances")</code>: ... </p>
</dd>
<dt>partialVariances</dt><dd><p><code>signature(x = "VirtualPeriodicAutocovariances")</code>: ... </p>
</dd>
<dt>pc.bU</dt><dd><p><code>signature(x = "VirtualPeriodicAutocovariances")</code>: ... </p>
</dd>
<dt>pc.fL</dt><dd><p><code>signature(x = "VirtualPeriodicAutocovariances")</code>: ... </p>
</dd>
<dt>pc.phis2</dt><dd><p><code>signature(x = "VirtualPeriodicAutocovariances")</code>: ... </p>
</dd>
</dl>


<hr>
<h2 id='VirtualPeriodicFilterModel-class'>~~ Dummy title ~~</h2><span id='topic+VirtualPeriodicFilterModel-class'></span>

<h3>Description</h3>

<p>~~ Dummy description ~~</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;VirtualPeriodicFilterModel&quot; in the signature.
</p>

<hr>
<h2 id='VirtualPeriodicMaModel-class'>~~ Dummy title ~~</h2><span id='topic+VirtualPeriodicMaModel-class'></span>

<h3>Description</h3>

<p>~~ Dummy description ~~</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("VirtualPeriodicMaModel", ...)</code>.
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+VirtualPeriodicArmaModel-class">VirtualPeriodicArmaModel</a>"</code>, directly.
Class <code>"<a href="#topic+VirtualPeriodicFilterModel-class">VirtualPeriodicFilterModel</a>"</code>, by class &quot;VirtualPeriodicArmaModel&quot;, distance 2.
Class <code>"<a href="#topic+VirtualPeriodicStationaryModel-class">VirtualPeriodicStationaryModel</a>"</code>, by class &quot;VirtualPeriodicArmaModel&quot;, distance 2.
Class <code>"<a href="#topic+VirtualPeriodicAutocovarianceModel-class">VirtualPeriodicAutocovarianceModel</a>"</code>, by class &quot;VirtualPeriodicArmaModel&quot;, distance 3.
Class <code>"<a href="#topic+VirtualPeriodicMeanModel-class">VirtualPeriodicMeanModel</a>"</code>, by class &quot;VirtualPeriodicArmaModel&quot;, distance 3.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;VirtualPeriodicMaModel&quot; in the signature.
</p>

<hr>
<h2 id='VirtualPeriodicMeanModel-class'>~~ Dummy title ~~</h2><span id='topic+VirtualPeriodicMeanModel-class'></span>

<h3>Description</h3>

<p>~~ Dummy description ~~</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;VirtualPeriodicMeanModel&quot; in the signature.
</p>

<hr>
<h2 id='VirtualPeriodicModel-class'>~~ Dummy title ~~</h2><span id='topic+VirtualPeriodicModel-class'></span>

<h3>Description</h3>

<p>~~ Dummy description ~~</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>


<dl>
<dt>allSeasons</dt><dd><p><code>signature(x = "VirtualPeriodicModel", abb = "ANY")</code>: ... </p>
</dd>
<dt>nSeasons</dt><dd><p><code>signature(object = "VirtualPeriodicModel")</code>: ... </p>
</dd>
<dt>seqSeasons</dt><dd><p><code>signature(x = "VirtualPeriodicModel")</code>: ... </p>
</dd>
<dt>unitCycle</dt><dd><p><code>signature(x = "VirtualPeriodicModel")</code>: ... </p>
</dd>
<dt>unitSeason</dt><dd><p><code>signature(x = "VirtualPeriodicModel")</code>: ... </p>
</dd>
</dl>


<hr>
<h2 id='VirtualPeriodicMonicFilter-class'>~~ Dummy title ~~</h2><span id='topic+VirtualPeriodicMonicFilter-class'></span>

<h3>Description</h3>

<p>~~ Dummy description ~~</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;VirtualPeriodicMonicFilter&quot; in the signature.
</p>

<hr>
<h2 id='VirtualPeriodicStationaryModel-class'>~~ Dummy title ~~</h2><span id='topic+VirtualPeriodicStationaryModel-class'></span>

<h3>Description</h3>

<p>~~ Dummy description ~~</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("VirtualPeriodicStationaryModel", ...)</code>.
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+VirtualPeriodicAutocovarianceModel-class">VirtualPeriodicAutocovarianceModel</a>"</code>, directly.
Class <code>"<a href="#topic+VirtualPeriodicMeanModel-class">VirtualPeriodicMeanModel</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;VirtualPeriodicStationaryModel&quot; in the signature.
</p>

<hr>
<h2 id='VirtualPeriodicWhiteNoiseModel-class'>~~ Dummy title ~~</h2><span id='topic+VirtualPeriodicWhiteNoiseModel-class'></span>

<h3>Description</h3>

<p>~~ Dummy description ~~</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("VirtualPeriodicWhiteNoiseModel", ...)</code>.
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+VirtualPeriodicStationaryModel-class">VirtualPeriodicStationaryModel</a>"</code>, directly.
Class <code>"<a href="#topic+VirtualPeriodicAutocovarianceModel-class">VirtualPeriodicAutocovarianceModel</a>"</code>, by class &quot;VirtualPeriodicStationaryModel&quot;, distance 2.
Class <code>"<a href="#topic+VirtualPeriodicMeanModel-class">VirtualPeriodicMeanModel</a>"</code>, by class &quot;VirtualPeriodicStationaryModel&quot;, distance 2.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;VirtualPeriodicWhiteNoiseModel&quot; in the signature.
</p>

<hr>
<h2 id='window'>Periodic methods for base R functions</h2><span id='topic+window'></span><span id='topic+window.PeriodicTS'></span><span id='topic+window.PeriodicMTS'></span><span id='topic+na.trim'></span><span id='topic+na.trim.PeriodicTS'></span><span id='topic+na.trim.PeriodicMTS'></span><span id='topic+frequency.PeriodicTimeSeries'></span><span id='topic+deltat.PeriodicTimeSeries'></span><span id='topic+cycle.PeriodicTimeSeries'></span><span id='topic+time.PeriodicTimeSeries'></span><span id='topic+start.Cyclic'></span><span id='topic+end.Cyclic'></span>

<h3>Description</h3>

<p>Periodic methods for base R functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PeriodicTS'
window(x, start = NULL, end = NULL, seasons = NULL, ...)

## S3 method for class 'PeriodicMTS'
window(x, start = NULL, end = NULL, seasons = NULL, ...)

## S3 method for class 'PeriodicTS'
na.trim(object, sides = c("both", "left", "right"), ...)

## S3 method for class 'PeriodicMTS'
na.trim(object, sides = c("both", "left", "right"), 
        is.na = c("any", "all"), ...)

## S3 method for class 'PeriodicTimeSeries'
frequency(x, ...)

## S3 method for class 'PeriodicTimeSeries'
deltat(x, ...)

## S3 method for class 'PeriodicTimeSeries'
cycle(x, ...)

## S3 method for class 'PeriodicTimeSeries'
time(x, offset = 0, ...)

## S3 method for class 'Cyclic'
start(x, ...)

## S3 method for class 'Cyclic'
end(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="window_+3A_x">x</code>, <code id="window_+3A_object">object</code></td>
<td>
<p>an object from the indicated periodic class.</p>
</td></tr>
<tr><td><code id="window_+3A_start">start</code></td>
<td>
<p><code>numeric(2)</code>, start time.</p>
</td></tr>
<tr><td><code id="window_+3A_end">end</code></td>
<td>
<p><code>numeric(2)</code>, end time.</p>
</td></tr>
<tr><td><code id="window_+3A_seasons">seasons</code></td>
<td>
<p>numeric, a subset of <code>1:nSeasons(x)</code>.</p>
</td></tr>
<tr><td><code id="window_+3A_...">...</code></td>
<td>
<p>Not used by these methods.</p>
</td></tr>
<tr><td><code id="window_+3A_sides">sides</code></td>
<td>

<p>which side to trim: start (<code>"left"</code>), end (<code>"right"</code>), or
both (<code>"both"</code>).
</p>
</td></tr>
<tr><td><code id="window_+3A_is.na">is.na</code></td>
<td>

<p>for multivariate time series: if <code>"all"</code>, the observation at
time <code class="reqn">t</code> will be considered missing only if all variables are
<code>NA</code> at that time. Otherwise, if <code>"any"</code>,  any variable
with value <code>NA</code> will cause the observation at time <code class="reqn">t</code> to
be considered missing.
</p>
</td></tr>
<tr><td><code id="window_+3A_offset">offset</code></td>
<td>
<p>currently ignored (:TODO:)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Periodic methods for base R and other common functions for
manipulation of time series. These methods work analogoulsly to their
base R cousins and only the differences, if any, are discussed below.
</p>
<p><code><a href="stats.html#topic+window">window</a></code> takes a part of <code>x</code>, preserving the
class of the object. Argument <code>seasons</code> selects a subset of the
seasons. 
</p>
<p><code><a href="zoo.html#topic+na.trim">na.trim</a></code> is a function defined in package <span class="pkg">zoo</span>
and re-exported by <span class="pkg">pcts</span>. It trims <code>NA</code>s from one or both
ends of the time series, as requested by the arguments.  The arguments
of the methods defined by <span class="pkg">pcts</span> have the same meaning as those in
<span class="pkg">zoo</span>.
</p>


<h3>Value</h3>

<p>for <code>window</code> and <code>na.trim</code>, 
an object from the same class as the original, representing the
requested part of the time series.
</p>
<p>for <code>frequency</code>, an integer number.
</p>
<p>for <code>deltat</code>, a number (1/frequency).
</p>
<p>for <code>cycle</code> and <code>time</code>, a <code>"PeriodicTS"</code> object.
</p>
<p>for <code>start</code> and <code>end</code>, time of first/last observation,
encoded as a pair of numbers.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+window">window</a></code>,
<code><a href="stats.html#topic+frequency">frequency</a></code>, 
<code><a href="zoo.html#topic+na.trim">na.trim</a></code> for details on what these functions do.
</p>
<p><code><a href="#topic+availStart">availStart</a></code> and <code><a href="#topic+availEnd">availEnd</a></code> give the times of
the first and last non-NA observations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pres &lt;- pcts(presidents)
head(pres, 8)
availStart(pres)

tail(pres, 12)
availEnd(pres)

## Q3 and Q4 only
presQ3Q4 &lt;- window(pres, seasons = 3:4)
head(presQ3Q4)

identical(na.trim(pres),
          window(pres, start = availStart(pres), end = availEnd(pres)))
## TRUE
</code></pre>

<hr>
<h2 id='zoo-class'>Class zoo made S4</h2><span id='topic+zoo-class'></span>

<h3>Description</h3>

<p>Class zoo made S4</p>


<h3>
Objects from the Class</h3>

<p>A virtual Class: No objects may be created
from it.
</p>
<p>S4 Class <code>"zoo"</code> is derived from its namesake in package
<span class="pkg">zoo</span> for use as a super class for periodic time series classes
and in S4 method signatures.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.S3Class</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="methods.html#topic+oldClass-class">oldClass</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;zoo&quot; in the signature.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PeriodicTS_zooreg-class">PeriodicTS_zooreg</a></code>,
<code><a href="#topic+zooreg-class">zooreg</a></code>
and package <span class="pkg">zoo</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("zoo")
</code></pre>

<hr>
<h2 id='zooreg-class'>Virtual S4 class zooreg</h2><span id='topic+zooreg-class'></span>

<h3>Description</h3>

<p>Virtual S4 class zooreg.</p>


<h3>
Objects from the Class</h3>

<p>A virtual Class: No objects may be created
from it.
</p>
<p>S4 Class <code>"zooreg"</code> is derived from its namesake in package
<span class="pkg">zoo</span> for use as a super class for periodic time series classes
and in S4 method signatures.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.S3Class</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+zoo-class">zoo</a>"</code>, directly.
Class <code>"<a href="methods.html#topic+oldClass-class">oldClass</a>"</code>, by class &quot;zoo&quot;, distance 2.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;zooreg&quot; in the signature.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PeriodicTS_zooreg-class">PeriodicTS_zooreg</a></code>,
<code><a href="#topic+zoo-class">zoo</a></code>
and package <span class="pkg">zoo</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("zooreg")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
