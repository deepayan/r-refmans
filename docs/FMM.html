<!DOCTYPE html><html><head><title>Help for package FMM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FMM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ecgData'><p>Fifth annotated beat (lead MLII) from patient sel100 in 'QT database'</p></a></li>
<li><a href='#extractWaves'><p>Individual contribution to the fitted values of each FMM wave</p></a></li>
<li><a href='#fitFMM'><p>Fitting FMM models</p></a></li>
<li><a href='#FMM-class'><p>FMM Class Representation</p></a></li>
<li><a href='#FMM-internal'><p>Internal functions for the 'FMM' package.</p></a></li>
<li><a href='#FMM-methods'><p>Methods for objects of class <code>'FMM'</code></p></a></li>
<li><a href='#FMM-package'><p>Rhythmic Patterns Modeling by FMM Models</p></a></li>
<li><a href='#generateFMM'><p>Simulating data from FMM models</p></a></li>
<li><a href='#getFMMPeaks'><p>Peak and trough times and signal values</p></a></li>
<li><a href='#getS4'><p>General S4 Class Extractor Functions</p></a></li>
<li><a href='#mouseGeneExp'><p>Iqgap2 gene expression data from mouse liver</p></a></li>
<li><a href='#neuronalAPTrain'><p>Neuronal AP Train Data simulated with Hodgkin-Huxley model</p></a></li>
<li><a href='#neuronalSpike'><p>Neuronal Spike Data simulated with Hodgkin-Huxley model</p></a></li>
<li><a href='#plotFMM'><p>Plot fitted FMM models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Rhythmic Patterns Modeling by FMM Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Itziar Fernandez, Alejandro Rodriguez-Collado, Yolanda Larriba, Adrian Lamela, Christian Canedo, Cristina Rueda</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Itziar Fernandez &lt;itziar.fernandez@uva.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a collection of functions to fit and explore single, multi-component and restricted Frequency Modulated Moebius (FMM) models. 'FMM' is a nonlinear parametric regression model capable of fitting non-sinusoidal shapes in rhythmic patterns. Details about the mathematical formulation of 'FMM' models can be found in Rueda et al. (2019) &lt;<a href="https://doi.org/10.1038%2Fs41598-019-54569-1">doi:10.1038/s41598-019-54569-1</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/alexARC26/FMM">https://github.com/alexARC26/FMM</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, rlang, foreach, iterators, parallel, doParallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, gridExtra, knitr, RColorBrewer, rmarkdown, testthat
(&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-12-17 12:30:05 UTC; itziar</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-12-17 12:52:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='ecgData'>Fifth annotated beat (lead MLII) from patient sel100 in 'QT database'</h2><span id='topic+ecgData'></span>

<h3>Description</h3>

<p>Voltage electric activity data (mV) of the fifth annotated heartbeat for patient sel100 in 'QT database'.
200 samples were collected along 0.8 seconds with a sampling frequency of 250 Hz.
Data records correspond to samples from 151248 to 151049 and can be dowload as text files from 'Physionet' website.
Annotated beats were manually revised by experts including R peaks and fiducial marks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ecgData)
</code></pre>


<h3>Format</h3>

<p>A numeric vector.
</p>


<h3>Source</h3>

<p>'QT database' from 'Physionet' &lt;https://archive.physionet.org/cgi-bin/atm/ATM&gt;
</p>


<h3>References</h3>

<p>Goldberger A, Amaral L, Glass L, Hausdorff J et al. (2000).
A qrs detection and r point recognition method for wearable single-lead ecg devices.
<em>Circulation</em>, <b>101</b> (23), E215-20. <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5621148/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5621148/</a>
</p>
<p>Laguna P, Mark RG, Goldberg A,  Moody GB (1997).
A database for evaluation of algorithms for measurement of qt and other waveform intervals
in the ecg.
<em>Computers in cardiology 1997</em>, 673-676. <a href="https://ieeexplore.ieee.org/document/648140">https://ieeexplore.ieee.org/document/648140</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ecgData)
str(ecgData)
</code></pre>

<hr>
<h2 id='extractWaves'>Individual contribution to the fitted values of each FMM wave</h2><span id='topic+extractWaves'></span>

<h3>Description</h3>

<p><code>extractWaves</code> extracts individual contribution to the fitted values of each FMM wave.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractWaves(objFMM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractWaves_+3A_objfmm">objFMM</code></td>
<td>
<p>Object of class <code>'FMM'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Individual contribution to the fitted values of each FMM wave. It is a <code>list</code> object with as many elements as FMM components have been fitted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate example data:
fmm2.data &lt;- generateFMM(M = 0, A = rep(1, 2),
                         alpha = c(1.5, 3.4), beta = c(0.2, 2.3), omega = c(0.1, 0.2),
                         plot = FALSE, outvalues = TRUE,
                         sigmaNoise = 0.5) # add a gaussian noise with sigma = 0.5

## Fit the FMM model with nback = 2 components
## fit is an object of S4 class 'FMM'
fit &lt;- fitFMM(fmm2.data$y,timePoints = fmm2.data$t,nback = 2,
              lengthAlphaGrid = 24,lengthOmegaGrid = 10)
## extracts individual contribution of each FMM wave
extractWaves(fit)

</code></pre>

<hr>
<h2 id='fitFMM'>Fitting FMM models</h2><span id='topic+fitFMM'></span>

<h3>Description</h3>

<p><code>fitFMM()</code> is used to fit FMM models. The only required argument to fit FMM models is the input data.
By default it is assumed that time points, corresponding to a single time period, are equally spaced from 0 to <code class="reqn">2\pi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitFMM(
  vData,
  nPeriods = 1,
  timePoints = NULL,
  nback = 1,
  betaOmegaRestrictions = 1:nback,
  maxiter = nback,
  stopFunction = alwaysFalse,
  lengthAlphaGrid = 48,
  lengthOmegaGrid = 24,
  numReps = 3,
  showProgress = TRUE,
  showTime = FALSE,
  parallelize = FALSE,
  restrExactSolution = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitFMM_+3A_vdata">vData</code></td>
<td>
<p>A numeric vector containing the data to be fitted a FMM model.</p>
</td></tr>
<tr><td><code id="fitFMM_+3A_nperiods">nPeriods</code></td>
<td>
<p>A numeric value specifying the number of periods at which <code>vData</code> is observed.</p>
</td></tr>
<tr><td><code id="fitFMM_+3A_timepoints">timePoints</code></td>
<td>
<p>A numeric vector containing the time points at which each data of one single period is observed. The default value is <code>NULL</code>,
in which case they are equally spaced in range <code class="reqn">[0, 2\pi]</code>. It must be between 0 and <code class="reqn">2\pi</code>.</p>
</td></tr>
<tr><td><code id="fitFMM_+3A_nback">nback</code></td>
<td>
<p>Number of FMM components to be fitted. Its default value is 1.</p>
</td></tr>
<tr><td><code id="fitFMM_+3A_betaomegarestrictions">betaOmegaRestrictions</code></td>
<td>
<p>An integer vector of length <code>nback</code> indicating which FMM waves are constrained to have equal <code>beta</code> and <code>omega</code> parameters. For example, <code>c(1,1,1,2,2)</code> indicates that <code>beta1=beta2=beta3</code> and
<code>beta4=beta5</code> as well as <code>omega1=omega2=omega3</code> and <code>omega4=omega5</code>. In brief, some waves are restricted to have the same shape. Its default value is the sequence <code>1:nback</code> to fit the FMM model without restrictions on shape parameters (<code>beta</code> and <code>omega</code>).</p>
</td></tr>
<tr><td><code id="fitFMM_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations for the backfitting algorithm. By default, it is set at <code>nback</code>.</p>
</td></tr>
<tr><td><code id="fitFMM_+3A_stopfunction">stopFunction</code></td>
<td>
<p>Function to check the convergence criterion for the backfitting algorithm (see Details).</p>
</td></tr>
<tr><td><code id="fitFMM_+3A_lengthalphagrid">lengthAlphaGrid</code></td>
<td>
<p>Precision of the grid of alpha in the search of the best model. If it is increased, more possible values of alpha will be considered, resulting in an increasing in the computation time too.
By default, it is set to 48 possible values of alpha, equally spaced between 0 and <code class="reqn">2\pi</code>.</p>
</td></tr>
<tr><td><code id="fitFMM_+3A_lengthomegagrid">lengthOmegaGrid</code></td>
<td>
<p>Precision of the grid of omega in the search of the best model. If it is increased, more possible values of omega will be considered, resulting in an increasing in the computation time too.
By default it is set to 24 possible values of omega, equally spaced between 0 and 1 in a logarithmic way.</p>
</td></tr>
<tr><td><code id="fitFMM_+3A_numreps">numReps</code></td>
<td>
<p>Number of times (alpha, omega) parameters are refined.</p>
</td></tr>
<tr><td><code id="fitFMM_+3A_showprogress">showProgress</code></td>
<td>
<p><code>TRUE</code> to display a progress indicator on the console.</p>
</td></tr>
<tr><td><code id="fitFMM_+3A_showtime">showTime</code></td>
<td>
<p><code>TRUE</code> to display execution time on the console.</p>
</td></tr>
<tr><td><code id="fitFMM_+3A_parallelize">parallelize</code></td>
<td>
<p><code>TRUE</code> to use parallelized procedure to fit FMM model. Its default value is <code>FALSE</code>. When it is <code>TRUE</code>, the number of cores to be used is equal to 12, or if the machine has less, the number of cores - 1.</p>
</td></tr>
<tr><td><code id="fitFMM_+3A_restrexactsolution">restrExactSolution</code></td>
<td>
<p><code>FALSE</code> to use an aproximated algorithm to fit the FMM model with restrictions (default). If <code>TRUE</code> is specified, the exact solution is computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data will be collected over <code>nPeriods</code> periods. When <code>nPeriods &gt; 1</code> the fitting is carried out by averaging the data collected
at each time point across all considered periods. The model is fitting to summarized data.
<code>timePoints</code> is a <code>n</code>-length numeric vector where <code>n</code> is the number of different time points per period.
</p>
<p>The <code>stopFunction</code> argument can either be the functions <code>alwaysFalse</code> or <code>R2</code> included in the package or user-defined functions that have the same arguments. The included functions serve for the following:
</p>

<ul>
<li><p><code>alwaysFalse()</code>, its default value, which returns <code>FALSE</code> to force <code>maxiter</code> iterations; and
</p>
</li>
<li><p><code>R2(vData,pred,prevPred,difMax = 0.001)</code>, a function that computes the difference between the explained variability in two consecutive iterations returning <code>TRUE</code> when the convergence criterion is reached.
To calculate the explained variability difference, the data and the fitted values from the current and previous iteration are passed as arguments <code>vData</code>, <code>pred</code> and <code>prevPred</code>, respectively. The convergence
criterion is fulfilled when the explained variability difference is less than the argument <code>difMax</code> (by default 0.001).
</p>
</li></ul>



<h3>Value</h3>

<p>An S4 object of class <code>'FMM'</code> with information about the fitted model. The object contains the following slots:
</p>

<dl>
<dt>@timePoints</dt><dd><p>The time points as specified by the input argument. It is a numeric vector containing the time points at which each data of one single period is observed.</p>
</dd>
<dt>@data</dt><dd><p>The data as specified by the input argument. It is a numeric vector containing the data to be fitted a FMM model. Data could be collected over multiple periods.</p>
</dd>
<dt>@summarizedData</dt><dd><p>When the data has more than one period, a numeric vector containing <code>data</code> averaging the data at each time point across all considered periods.</p>
</dd>
<dt>@nPeriods</dt><dd><p>A numeric value containing the number of periods in data as specified by the input argument.</p>
</dd>
<dt>@fittedValues</dt><dd><p>A numeric vector of the fitted values by the FMM model.</p>
</dd>
<dt>@M</dt><dd><p>A numeric value of the estimated intercept parameter <code class="reqn">M</code>.</p>
</dd>
<dt>@A</dt><dd><p>A numeric value or vector of the estimated FMM wave amplitude parameter(s) <code class="reqn">A</code>.</p>
</dd>
<dt>@alpha</dt><dd><p>A numeric value or vector of the estimated FMM wave phase translation parameter(s) <code class="reqn">\alpha</code>.</p>
</dd>
<dt>@beta</dt><dd><p>A numeric value or vector of the estimated FMM wave skewness parameter(s) <code class="reqn">\beta</code>.</p>
</dd>
<dt>@omega</dt><dd><p>A numeric value or vector of the estimated FMM wave kurtosis parameter(s) <code class="reqn">\omega</code>.</p>
</dd>
<dt>@SSE</dt><dd><p>A numeric value of the sum of the residual squares values.</p>
</dd>
<dt>@R2</dt><dd><p>A numeric vector specifying the explained variance by each of the fitted FMM components.</p>
</dd>
<dt>@nIter</dt><dd><p>A numeric value specifying the number of iterations of the fitting algorithm.</p>
</dd>
</dl>



<h3>References</h3>

<p>Rueda C, Larriba Y, Peddada SD (2019). Frequency Modulated Moebius Model Accurately Predicts Rhythmic Signals in Biological and Physical Sciences.
<em>Scientific reports</em>, <b>9</b> (1), 18701. <a href="https://www.nature.com/articles/s41598-019-54569-1">https://www.nature.com/articles/s41598-019-54569-1</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A monocomponent FMM model is fitted.
FMM_data &lt;- generateFMM(2, 3, 1.5, 2.3, 0.1,
                        from = 0, to = 2*pi, length.out = 100,
                        outvalues = TRUE, sigmaNoise = 0.3, plot = FALSE)
fit &lt;- fitFMM(FMM_data$y, lengthAlphaGrid = 10, lengthOmegaGrid = 10)
summary(fit)

# To see the differences between number of repetitions.
FMM_data &lt;- generateFMM(2, 1, 1.5, 1.1 ,0.14 , outvalues = TRUE, sigmaNoise = 0.15, plot=TRUE)
fit1 &lt;- fitFMM(FMM_data$y, lengthAlphaGrid = 6, lengthOmegaGrid = 3, numReps = 1)
fit2 &lt;- fitFMM(FMM_data$y, lengthAlphaGrid = 6, lengthOmegaGrid = 3, numReps = 6,
               showProgress = FALSE)  # suppress progress messages
getSSE(fit1)
getSSE(fit2)

# Finer resolution grid.
fit3 &lt;- fitFMM(FMM_data$y, lengthAlphaGrid = 10, lengthOmegaGrid = 5, numReps = 1)
getSSE(fit3)

# Two component FMM model with beta and omega restricted
restFMM2w_data &lt;- generateFMM(M = 3, A = c(7, 4), alpha = c(0.5, 5), beta = c(rep(3, 2)),
                              omega = rep(0.05, 2), from = 0, to = 2*pi, length.out = 100,
                              sigmaNoise = 0.3, plot = FALSE)
fit2w.rest &lt;- fitFMM(restFMM2w_data$y, nback = 2, maxiter = 1, numReps = 1,
                     lengthAlphaGrid = 15, lengthOmegaGrid = 10,
                     betaOmegaRestrictions = c(1, 1))
plotFMM(fit2w.rest, components = TRUE)

</code></pre>

<hr>
<h2 id='FMM-class'>FMM Class Representation</h2><span id='topic+FMM-class'></span>

<h3>Description</h3>

<p>Class representation for an S4 object of class <code>'FMM'</code>.
</p>


<h3>Value</h3>

<p>The S4 object of class <code>'FMM'</code> contains the following slots:
</p>
<table>
<tr><td><code>@timePoints</code></td>
<td>

<p>The time points as specified by the input argument. It is a numeric vector containing the time points
at which each data of one single period is observed.
</p>
</td></tr>
<tr><td><code>@data</code></td>
<td>

<p>The data as specified by the input argument. It is a numeric vector containing the data to be fitted
a FMM model. Data could be collected over multiple periods.
</p>
</td></tr>
<tr><td><code>@summarizedData</code></td>
<td>

<p>When the data has more than one period, a numeric vector containing <code>data</code> averaging the data at
each time point across all considered periods.
</p>
</td></tr>
<tr><td><code>@nPeriods</code></td>
<td>

<p>A numeric value containing the number of periods in data as specified by the input argument.
</p>
</td></tr>
<tr><td><code>@fittedValues</code></td>
<td>

<p>A numeric vector of the fitted values by the FMM model.
</p>
</td></tr>
<tr><td><code>@M</code></td>
<td>

<p>A numeric value of the estimated intercept parameter <code class="reqn">M</code>.
</p>
</td></tr>
<tr><td><code>@A</code></td>
<td>

<p>A numeric value or vector of the estimated FMM wave amplitude parameter(s) <code class="reqn">A</code>.
</p>
</td></tr>
<tr><td><code>@alpha</code></td>
<td>

<p>A numeric value or vector of the estimated FMM wave phase translation parameter(s) <code class="reqn">\alpha</code>.
</p>
</td></tr>
<tr><td><code>@beta</code></td>
<td>

<p>A numeric value or vector of the estimated FMM wave skewness parameter(s) <code class="reqn">\beta</code>.
</p>
</td></tr>
<tr><td><code>@omega</code></td>
<td>

<p>A numeric value or vector of the estimated FMM wave kurtosis parameter(s) <code class="reqn">\omega</code>.
</p>
</td></tr>
<tr><td><code>@SSE</code></td>
<td>

<p>A numeric value of the sum of the residual squares values.
</p>
</td></tr>
<tr><td><code>@R2</code></td>
<td>

<p>A numeric vector specifying the explained variance by each of the fitted FMM components.
</p>
</td></tr>
<tr><td><code>@nIter</code></td>
<td>

<p>A numeric value specifying the number of iterations of the fitting algorithm.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## FMM class
getClass("FMM")
getSlots("FMM")
</code></pre>

<hr>
<h2 id='FMM-internal'>Internal functions for the 'FMM' package.</h2><span id='topic+internal'></span><span id='topic+fitFMM_unit'></span><span id='topic+fitFMM_back'></span><span id='topic+fitFMM_restr'></span><span id='topic+fitFMM_restr_omega_beta'></span><span id='topic+fitFMM_unit_restr'></span><span id='topic+step1FMM'></span><span id='topic+bestStep1'></span><span id='topic+step2FMM'></span><span id='topic+step2FMM_restr'></span><span id='topic+backfittingRestr'></span><span id='topic+iterateOmegaGrid'></span><span id='topic+stepOmega'></span><span id='topic+R2'></span><span id='topic+alwaysFalse'></span><span id='topic+PV'></span><span id='topic+PVj'></span><span id='topic+angularMean'></span><span id='topic+seqTimes'></span><span id='topic+calculateCosPhi'></span><span id='topic+getApply'></span><span id='topic+addShowMethod'></span>

<h3>Description</h3>

<p>The 'FMM' package contains several internal functions called by other functions that are not designed to be called by the user.
</p>
<p>To fit a 'FMM' model: The fitting function <code>fitFMM()</code> calls different internal functions for fits in different situations. <code>fitFMM_unit()</code> function fits a monocomponent 'FMM' model and <code>fitFMM_back()</code> fits a multicomponent 'FMM' model via a backfitting algorithm. For restricted version, <code>fitFMM_unit_restr()</code> is used to fit a monocomponent FMM model with fixed omega; <code>fitFMM_restr_omega_beta()</code> and <code>fitFMM_restr()</code> are used to fit multicomponent 'FMM' models with equality constraints for the beta and omega parameters.
</p>
<p>To fit a single 'FMM' component: The functions <code>step1FMM()</code>, <code>bestStep1()</code> are used to find the initial parameter estimations and their optimal values in the first step of the fitting process. <code>step2FMM()</code> computes the residual sum of squares in the second step of 'FMM' fitting process. In the restricted version, this function is called <code>step2FMM_restr()</code>. In addition, <code>stepOmega()</code> function is used in an extra optimization step of omega.
</p>
<p>To check the convergence criterion for the backfitting algorithm: <code>alwaysFalse()</code> is used to force a number of iterations while <code>R2()</code> is used to check if the stop condition, based on the difference between the variability explained in two consecutive iterations, is reached.
</p>
<p>Additional functions: The functions <code>PV()</code>, <code>PVj()</code>, <code>angularMean()</code> and <code>calculateCosPhi()</code> are used in the fitting process to compute the total percentage of variability explained, the percentage of variability explained by each component of 'FMM' model, the angular mean and the cosinus of each of the waves phase,respectively. <code>seqTimes()</code> is used to build a sequence of equally time points spaced in range <code class="reqn">[0, 2\pi]</code>. <code>getApply()</code> serves to prepare the parallelized estimation procedure.
</p>


<h3>Details</h3>

<p>These are not to be called directly by the user.</p>


<h3>Value</h3>

<p>Depending on the returned value:
</p>

<ul>
<li><p><code>fitFMM_unit()</code>, <code>fitFMM_back()</code>, <code>fitFMM_unit_restr()</code>,
<code>fitFMM_restr_omegaBeta()</code>, <code>backFittingRestr()</code> and <code>fitFMM_restr()</code>
return an S4 object of class <code>'FMM'</code>.

</p>
</li>
<li><p><code>iterateOmegaGrid()</code> returns a list with S4 objects of class FMM.

</p>
</li>
<li><p><code>step1FMM()</code> and <code>bestStep1()</code> return a numerical vector with the initial parameter estimations
and residual sum of squares, respectively. <code>PVj()</code> returns a vector with the percentage of variability
explained by each component of 'FMM' model. <code>seqTime()</code> returns a numerical vector with a sequence of
equally time points spaced in range [0,2*pi].

</p>
</li>
<li><p><code>step2FMM()</code>, <code>step2FMM_restr()</code> and <code>stepOmega()</code> return a numerical value with residual
sum of squares of a possible solution. <code>PV()</code> returns the total percentage of variability explained
by the model. <code>angularMean()</code> returns the angular mean of the input angles.

</p>
</li>
<li><p><code>R2()</code> and <code>alwaysFalse()</code> return a logical value. <code>alwaysFalse()</code> always returns
<code>FALSE</code> while <code>R2()</code> returns <code>TRUE</code> when the convergence criterion is reached.

</p>
</li></ul>


<hr>
<h2 id='FMM-methods'>Methods for objects of class <code>'FMM'</code></h2><span id='topic+FMM-methods'></span><span id='topic+summary'></span><span id='topic+coef'></span><span id='topic+fitted'></span><span id='topic+resid'></span><span id='topic+summary+2CFMM-method'></span><span id='topic+coef+2CFMM-method'></span><span id='topic+fitted+2CFMM-method'></span><span id='topic+resid+2CFMM-method'></span>

<h3>Description</h3>

<p>The methods for objects of class <code>'FMM'</code> are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>coef</code>    </td><td style="text-align: left;"> coef method for S4 class <code>'FMM'</code>, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>summary</code> </td><td style="text-align: left;"> summary method for S4 class <code>'FMM'</code>, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>fitted</code>  </td><td style="text-align: left;"> fitted method for S4 class <code>'FMM'</code>, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>resid</code>   </td><td style="text-align: left;"> resid method for S4 class <code>'FMM'</code>.</td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 coef method for signature 'FMM'
coef(object,...)

## S4 summary method for signature 'FMM'
summary(object,...)

## S4 fitted method for signature 'FMM'
fitted(object,...)

## S4 resid method for signature 'FMM'
resid(object,...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FMM-methods_+3A_object">object</code></td>
<td>
<p>object of class <code>'FMM'</code>.</p>
</td></tr>
<tr><td><code id="FMM-methods_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the method.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p>The function <code>coef()</code> returns a <code>list</code> with two components:
</p>

<table>
<tr>
 <td style="text-align: left;">
        </td><td style="text-align: left;">  <code>M</code>    </td><td style="text-align: left;"> A numeric value. The estimated intercept parameter <code class="reqn">M</code>.</td>
</tr>
<tr>
 <td style="text-align: left;">
        </td><td style="text-align: left;">  <code>wave</code> </td><td style="text-align: left;"> A <code>data.frame</code> with the estimates of each FMM wave parameters.
                          It is organised as one component per row.
      </td>
</tr>

</table>


</li>
<li><p> The function <code>summary()</code> displays relevant results of the fitting.
When it is assigned, this function returns a <code>list</code> with the following components:
</p>

<table>
<tr>
 <td style="text-align: left;">
         </td><td style="text-align: left;">   <code>coef</code>        </td><td style="text-align: left;">    The <code>list</code> returns by the function <code>coef()</code>.</td>
</tr>
<tr>
 <td style="text-align: left;">
         </td><td style="text-align: left;">   <code>peak.time</code>   </td><td style="text-align: left;">    A <code>data.frame</code> with the estimates of the peak and trough
                                           times of each wave. It is organised as one component per row.</td>
</tr>
<tr>
 <td style="text-align: left;">
         </td><td style="text-align: left;">   <code>resid</code>       </td><td style="text-align: left;">    The <code>vector</code> of residuals.</td>
</tr>
<tr>
 <td style="text-align: left;">
         </td><td style="text-align: left;">   <code>R.squared</code>   </td><td style="text-align: left;">    A numerical value with the R squared of each wave. The total R square
                                           is computed as the sum of the contribution of each component.
      </td>
</tr>

</table>


</li>
<li><p>The function <code>fitted()</code> returns a <code>data.frame</code> with two columns:
<code>timePoints</code> and <code>fittedValues</code>.

</p>
</li>
<li><p>The function <code>resid()</code> returns a numeric <code>vector</code> with residuals of the model.

</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Generate example data:
fmm2.data &lt;- generateFMM(0, rep(2, 2), c(1.5, 3.4), c(0.2, 2.3), c(0.1, 0.2),
                    plot = FALSE, outvalues = TRUE,
                    sigmaNoise = 0.5) # add a gaussian noise with sigma = 0.5

## Fit the FMM model with nback = 2 component
## fit is an object of S4 class 'FMM'
fit &lt;- fitFMM(vData = fmm2.data$y,timePoints = fmm2.data$t,nback = 2,
              lengthAlphaGrid = 24,lengthOmegaGrid = 10)

## Extract coefficients of the model:
coef(fit)

## Summarize results:
summary(fit)

## Results on a list:
res &lt;- summary(fit)
res$peak.time # fiducial points

## fitted values:
fit.values &lt;- fitted(fit)

## residuals
res &lt;- resid(fit)

</code></pre>

<hr>
<h2 id='FMM-package'>Rhythmic Patterns Modeling by FMM Models</h2><span id='topic+FMM-package'></span><span id='topic+FMM'></span>

<h3>Description</h3>

<p>Provides a collection of functions to fit and explore single, multi-component and restricted Frequency Modulated Moebius (FMM) models. 'FMM' is a nonlinear parametric regression model capable of fitting non-sinusoidal shapes in rhythmic patterns.
</p>


<h3>Details</h3>

<pre>
     Package:    FMM
     Type:       Package
     Version:    0.1.1
     Date:       2021
     License:    GPL Version 2 or later
    </pre>
<p>For a complete list of functions with individual help pages, use <code>library(help = "FMM")</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Lamela, Itziar Fernandez, Yolanda Larriba, Alejandro Rodriguez, Cristina Rueda
</p>
<p>Maintainer: Itziar Fernandez &lt;itziar.fernandez@uva.es&gt;
</p>


<h3>References</h3>

<p>Rueda C, Larriba Y, Peddada SD (2019).
Frequency Modulated Moebius Model Accurately Predicts Rhythmic Signals in Biological and Physical Sciences.
<em>Scientific reports</em>, <b>9</b> (1), 18701. <a href="https://www.nature.com/articles/s41598-019-54569-1">https://www.nature.com/articles/s41598-019-54569-1</a>
</p>

<hr>
<h2 id='generateFMM'>Simulating data from FMM models</h2><span id='topic+generateFMM'></span>

<h3>Description</h3>

<p><code>generateFMM()</code> simulates data from a FMM model defined by parameters <code>M</code>, <code>A</code>, <code class="reqn">\alpha</code>, <code class="reqn">\beta</code> and <code class="reqn">\omega</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateFMM(
  M,
  A,
  alpha,
  beta,
  omega,
  from = 0,
  to = 2 * pi,
  length.out = 200,
  plot = TRUE,
  outvalues = TRUE,
  sigmaNoise = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateFMM_+3A_m">M</code></td>
<td>
<p>A numeric vector which contains the value of the intercept parameter <code>M</code>.</p>
</td></tr>
<tr><td><code id="generateFMM_+3A_a">A</code></td>
<td>
<p>A positive numeric vector which contains the value of the FMM wave amplitude parameter <code>A</code>.</p>
</td></tr>
<tr><td><code id="generateFMM_+3A_alpha">alpha</code></td>
<td>
<p>A numeric vector which contains the value of the FMM wave phase translation parameter <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code id="generateFMM_+3A_beta">beta</code></td>
<td>
<p>A numeric vector which contains the value of the FMM wave skewness parameter <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code id="generateFMM_+3A_omega">omega</code></td>
<td>
<p>A numeric vector which contains the value of the FMM wave kurtosis parameter <code class="reqn">\omega</code>. <code>omega</code> parameter must be between 0 and 1.</p>
</td></tr>
<tr><td><code id="generateFMM_+3A_from">from</code></td>
<td>
<p>A numeric value which contains the initial time point of the simulated data. By default, it is 0.</p>
</td></tr>
<tr><td><code id="generateFMM_+3A_to">to</code></td>
<td>
<p>A numeric value which contains the final time point of the simulated data. By default, it is <code class="reqn">2\pi</code>.</p>
</td></tr>
<tr><td><code id="generateFMM_+3A_length.out">length.out</code></td>
<td>
<p>A non-negative number wich contains the desired length of the simulation. By default, it is 100.</p>
</td></tr>
<tr><td><code id="generateFMM_+3A_plot">plot</code></td>
<td>
<p>A logical value indicating whether the simulated data should be drawn on a plot. By default, it is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="generateFMM_+3A_outvalues">outvalues</code></td>
<td>
<p>A logical value indicating whether the numerical simulation should be return. By default, it is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="generateFMM_+3A_sigmanoise">sigmaNoise</code></td>
<td>
<p>A non-negative number which contains the standard deviation of the gaussian noise to be added. Its default value is zero equivalent to a simulation set-up without noise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To simulate a multicomponent FMM model, arguments <code>A</code>, <code>alpha</code>, <code>beta</code> and <code>omega</code> are vectors of length <code class="reqn">m</code>, where <code class="reqn">m</code> represents the number of FMM waves. With different lengths, the smaller vectors will be replicate until thay are the same length as the longest vector.
</p>
<p>With <code>sigmaNoise = s</code>, <code>s&gt;0</code>, the <code>generateFMM</code> function uses <code>rnorm(length.out, 0, sigmaNoise)</code> to create the normally distributed noise and adds it to the simulated values.
</p>


<h3>Value</h3>

<p>When <code>outvalues = TRUE</code> a list of with the following components is returned:
</p>
<table>
<tr><td><code>input</code></td>
<td>
<p>a list with the input parameters <code>M</code>, <code>A</code>, <code>alpha</code>, <code>beta</code> and <code>omega</code>.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>a numeric vector with the time points at each data is simulated.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a numeric vector with the data simulated.</p>
</td></tr>
</table>
<p>When <code>plot = TRUE</code> a scatter plot of <code>y</code> vs <code>t</code> is drawn.
</p>


<h3>References</h3>

<p>Rueda C, Larriba Y, Peddada SD (2019).
Frequency Modulated Moebius Model Accurately Predicts Rhythmic Signals in Biological and Physical Sciences.
<em>Scientific reports</em>, <b>9</b> (1), 18701. <a href="https://www.nature.com/articles/s41598-019-54569-1">https://www.nature.com/articles/s41598-019-54569-1</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data from a monocomponent FMM model. A plot with the simulated model is shown
generateFMM(M = 2,A = 3,alpha = 1.5,beta = 2.3, omega = 0.1, outvalues = FALSE)

# Add a gaussian noise with standard deviation 0.3. The numeric results are returned
generateFMM(M = 2, A = 3, alpha = 1.5, beta = 2.3, omega = 0.1,
            sigmaNoise = 0.3, plot = FALSE, outvalues = TRUE)

# Simulate data from a multicomponent FMM model with two FMM waves
# both with amplitude parameter = 2
generateFMM(M = 0, A = rep(2, 2), alpha = c(1.5, 3.4), beta = c(0.2, 2.3), omega = c(0.1, 0.2))


</code></pre>

<hr>
<h2 id='getFMMPeaks'>Peak and trough times and signal values</h2><span id='topic+getFMMPeaks'></span>

<h3>Description</h3>

<p><code>getFMMPeaks()</code> is used to estimate peak and trough times and signal values at those times for each component of the model. These parameters result to be useful in multiple applications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFMMPeaks(objFMM, timePointsIn2pi = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFMMPeaks_+3A_objfmm">objFMM</code></td>
<td>
<p>Object of class <code>'FMM'</code></p>
</td></tr>
<tr><td><code id="getFMMPeaks_+3A_timepointsin2pi">timePointsIn2pi</code></td>
<td>
<p><code>TRUE</code> to return peak and trough times in the <code class="reqn">[0, 2\pi]</code> interval. When <code>timePointsIn2pi = FALSE</code> the positions of peak and trough times are returned. Its default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components is returned:
</p>
<table>
<tr><td><code>tpeakU</code></td>
<td>
<p>a numeric vector with the time points at which the peak of each wave is estimated.</p>
</td></tr>
<tr><td><code>tpeakL</code></td>
<td>
<p>a numeric vector with the time points at which the trough of each wave is estimated.</p>
</td></tr>
<tr><td><code>ZU</code></td>
<td>
<p>a numeric vector with the estimated signal peak values of each wave.</p>
</td></tr>
<tr><td><code>ZL</code></td>
<td>
<p>a numeric vector with the estimated signal trough values of each wave.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rueda C, Larriba Y, Peddada SD (2019).
Frequency Modulated Moebius Model Accurately Predicts Rhythmic Signals in Biological and Physical Sciences.
<em>Scientific reports</em>, <b>9</b> (1), 18701. <a href="https://www.nature.com/articles/s41598-019-54569-1">https://www.nature.com/articles/s41598-019-54569-1</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate example data:
fmm2.data &lt;- generateFMM(0, rep(2, 2), c(1.5, 3.4), c(0.2, 2.3), c(0.1, 0.2),
                         plot = FALSE, outvalues = TRUE,
                         sigmaNoise = 0.5) # add a gaussian noise with sigma = 0.5

## Fit the FMM model with nback = 2 components
## fit is an object of S4 class 'FMM'
fit &lt;- fitFMM(fmm2.data$y,timePoints = fmm2.data$t,nback = 2,
              lengthAlphaGrid = 24,lengthOmegaGrid = 10)
getFMMPeaks(fit, timePointsIn2pi = TRUE) # times in the [0,2*pi] interval

</code></pre>

<hr>
<h2 id='getS4'>General S4 Class Extractor Functions</h2><span id='topic+getTimePoints'></span><span id='topic+getData'></span><span id='topic+getSummarizedData'></span><span id='topic+getNPeriods'></span><span id='topic+getFittedValues'></span><span id='topic+getM'></span><span id='topic+getA'></span><span id='topic+getAlpha'></span><span id='topic+getBeta'></span><span id='topic+getOmega'></span><span id='topic+getSSE'></span><span id='topic+getR2'></span><span id='topic+getNIter'></span>

<h3>Description</h3>

<p>A collection of functions to extract slots from S4 objects of class <code>'FMM'</code>.
<br />
</p>
<p>The extractor functions are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    
    <code>getTimePoints</code> </td><td style="text-align: left;"> Extracts the timePoints slot from a S4 object of class <code>'FMM'</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>getData</code> </td><td style="text-align: left;"> Extracts the data slot from a S4 object of class <code>'FMM'</code>, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>getSummarizedData</code> </td><td style="text-align: left;"> Extracts the  summarizedData slot from a S4 object of class <code>'FMM'</code>, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>getNPeriods</code> </td><td style="text-align: left;"> Extracts the  nPeriods slot from a S4 object of class <code>'FMM'</code>, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>getFittedValues</code> </td><td style="text-align: left;"> Extracts the fittedValues slot from a S4 object of class <code>'FMM'</code>, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>getM</code> </td><td style="text-align: left;"> Extracts the M slot from a S4 object of class <code>'FMM'</code>, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>getA</code> </td><td style="text-align: left;"> Extracts the A slot from a S4 object of class <code>'FMM'</code>, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>getAlpha</code> </td><td style="text-align: left;"> Extracts the alpha slot from a S4 object of class <code>'FMM'</code>, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>getBeta</code> </td><td style="text-align: left;"> Extracts the beta slot from a S4 object of class <code>'FMM'</code>, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>getOmega</code> </td><td style="text-align: left;"> Extracts the omega slot from a S4 object of class <code>'FMM'</code>, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>getSSE</code> </td><td style="text-align: left;"> Extracts the SSE slot from a S4 object of class <code>'FMM'</code>, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>getR2</code> </td><td style="text-align: left;"> Extracts the R2 slot from a S4 object of class <code>'FMM'</code>, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>getNIter</code> </td><td style="text-align: left;"> Extracts the nIter slot from a S4 object of class <code>'FMM'</code>, </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>getM(objFMM)
getOmega(objFMM)
getData(objFMM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getS4_+3A_objfmm">objFMM</code></td>
<td>
<p>an object of class of class <code>'FMM'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return the content of the corresponding slot.
</p>

<hr>
<h2 id='mouseGeneExp'>Iqgap2 gene expression data from mouse liver</h2><span id='topic+mouseGeneExp'></span>

<h3>Description</h3>

<p>Data from High-temporal resolution profiling of mouse liver.
Samples were collected every hour for 48 hours from 3-5 mice per time point from liver.
Samples were pooled and analyzed using Affymetrix arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mouseGeneExp)
</code></pre>


<h3>Format</h3>

<p>A numeric vector.
</p>


<h3>Source</h3>

<p>'NCBI GEO', accession number GSE11923 &lt;https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE11923&gt;
</p>


<h3>References</h3>

<p>Hughes ME, DiTacchio L, Hayes KR, Vollmers C et al.
Harmonics of circadian gene transcription in mammals.
PLoS Genet 2009 Apr;5(4):e1000442. PMID: 19343201
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mouseGeneExp)
str(mouseGeneExp)
</code></pre>

<hr>
<h2 id='neuronalAPTrain'>Neuronal AP Train Data simulated with Hodgkin-Huxley model</h2><span id='topic+neuronalAPTrain'></span>

<h3>Description</h3>

<p>Voltage data in mV simulated with Hodgkin Huxley model (parameters: C=1, 
gNa=232, gK=45, gL=0.215, vK=-12, vNa=115, vL=10.6, bar(alphaN)=0.95, 
bar(betaN)=1.3, bar(alphaM)=1, bar(betaM)=1.15, bar(alphaH)=1, 
bar(betaH)=1) and applied current of 4.5 microA 1 millisecond. The 
simulation has been done with a modified NeuroDynex Python module.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(neuronalAPTrain)
</code></pre>


<h3>Format</h3>

<p>A numeric vector.
</p>


<h3>Source</h3>

<p>NeuroDynex Documentation, &lt;https://lcn-neurodynex-exercises.readthedocs.io/en/latest/#&gt;
</p>


<h3>References</h3>

<p>Wulfram Gerstner, Werner M. Kistler, Richard Naud, 
and Liam Paninski (2014). Neuronal Dynamics: From Single Neurons to 
Networks and Models of Cognition.
([Online Book](https://neuronaldynamics.epfl.ch/online/))
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(neuronalAPTrain)
str(neuronalAPTrain) 
</code></pre>

<hr>
<h2 id='neuronalSpike'>Neuronal Spike Data simulated with Hodgkin-Huxley model</h2><span id='topic+neuronalSpike'></span>

<h3>Description</h3>

<p>Voltage data in mV simulated with Hodgkin Huxley model (parameters: C=1,
gNa=260, gK=30, gL=0.31, vK=-12, vNa=115, vL=10.6, bar(alphaN)=1.15, 
bar(betaN)=0.85, bar(alphaM)=0.9, bar(betaM)=1.3, bar(alphaH)=1, 
bar(betaH)=1) and applied current of 12 microA 1 millisecond. The 
simulation has been done with a modified NeuroDynex Python module.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(neuronalSpike)
</code></pre>


<h3>Format</h3>

<p>A numeric vector.
</p>


<h3>Source</h3>

<p>NeuroDynex Documentation, &lt;https://lcn-neurodynex-exercises.readthedocs.io/en/latest/#&gt;
</p>


<h3>References</h3>

<p>Wulfram Gerstner, Werner M. Kistler, Richard Naud, 
and Liam Paninski (2014). Neuronal Dynamics: From Single Neurons to 
Networks and Models of Cognition.
([Online Book](https://neuronaldynamics.epfl.ch/online/))
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(neuronalSpike)
str(neuronalSpike) 
</code></pre>

<hr>
<h2 id='plotFMM'>Plot fitted FMM models</h2><span id='topic+plotFMM'></span>

<h3>Description</h3>

<p><code>plotFMM()</code> is used to plot fitted FMM models. The function can either
plot the fitted model against the data or each of the components of the model
separately. Optionally <code>'ggplot2'</code> can be used as graphic library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotFMM(
  objFMM,
  components = FALSE,
  plotAlongPeriods = FALSE,
  use_ggplot2 = FALSE,
  legendInComponentsPlot = TRUE,
  textExtra = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotFMM_+3A_objfmm">objFMM</code></td>
<td>
<p>Object of class FMM</p>
</td></tr>
<tr><td><code id="plotFMM_+3A_components">components</code></td>
<td>
<p>A logical value indicating if the centered wave components of the model should be separately
plotted (case where it is <code>TRUE</code>). If <code>FALSE</code>, the default, the fitted FMM model
along with the observed data is plotted.</p>
</td></tr>
<tr><td><code id="plotFMM_+3A_plotalongperiods">plotAlongPeriods</code></td>
<td>
<p>A logical value indicating if more than one period should be plotted in the plots
by default. Its default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotFMM_+3A_use_ggplot2">use_ggplot2</code></td>
<td>
<p>A logical value. If <code>FALSE</code>, the default, R base graphics are used. If <code>TRUE</code>,
<code>'ggplot2'</code> library is used as graphics engine.</p>
</td></tr>
<tr><td><code id="plotFMM_+3A_legendincomponentsplot">legendInComponentsPlot</code></td>
<td>
<p>A logical value indicating whether the legend should be plotted in the components
plot. By defaults it is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotFMM_+3A_textextra">textExtra</code></td>
<td>
<p>A character vector for extra text to be added to the titles of the plots.</p>
</td></tr>
</table>


<h3>Details</h3>

 <p><code>plotFMM()</code> can generate two types of plots: the basic plot compares the fitted model against the original data while the components plot represents separately the centered waves of the model (if the argument components is TRUE).
</p>
<p>The function is also capable of plotting multiple periods if the data has more than one, as is the case in many applications such as chronobiology. In this case, the argument plotAlongPeriods should be TRUE. In the case of components plots the value taken by the latter argument is ignored as they are plotted along just one period.
</p>
<p>While, by default, plots are created using base R graphics, 'ggplot2' can also be used for more aesthetic and customizable plots. Optional arguments legendInComponentsPlot and textExtra serve to control, respectively, whether a legend to the components plot should be added and adding extra text to the plot's title.

</p>


<h3>Value</h3>

<p>None if base R graphics are used, a named <code>ggplot2</code> list if <code>'ggplot2'</code> is used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulates an scenario in which an FMM model is suitable,
res &lt;- generateFMM(2,3,1.5,2.3,0.1,outvalues = TRUE,sigmaNoise = 0.3, plot=FALSE)
# then a FMM model is fitted to the data.
fit &lt;- fitFMM(res$y, lengthAlphaGrid=20,lengthOmegaGrid=12)
plotFMM(fit)

# Components plot of FMM Model fitted to neuronal data with various optional aesthetics
data("neuronalSpike")
fittedFMM2&lt;-fitFMM(neuronalSpike, nback=2,
                   lengthAlphaGrid = 24,lengthOmegaGrid = 10, numReps = 1)

plotFMM(fittedFMM2, components = TRUE)
plotFMM(fittedFMM2, components = TRUE,
        legendInComponentsPlot = FALSE,
        textExtra = "Neuronal Data")

# With ggplot2, customizable plots can be created,
library(ggplot2)
# standard plots
plotFMM(fittedFMM2, use_ggplot2 = TRUE)
# modify x-axis with original timePoints
timePoints &lt;- getTimePoints(fittedFMM2)
nObs &lt;- length(timePoints)
sTimePoints &lt;- round(c(1, nObs*0.25, nObs*0.5, nObs*0.75, nObs))
plotFMM(fittedFMM2, use_ggplot2 = TRUE) +
  scale_x_continuous(breaks = sTimePoints,
                     labels = function(x) round(timePoints[x],2))
# and components plots
plotFMM(fittedFMM2, components = TRUE, use_ggplot2 = TRUE)

# Plot of fitted model to more than one period.
data("mouseGeneExp")
fittedFMM2&lt;-fitFMM(mouseGeneExp, nPeriods = 2,
                   lengthAlphaGrid = 20,lengthOmegaGrid = 10)
plotFMM(fittedFMM2, plotAlongPeriods = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
