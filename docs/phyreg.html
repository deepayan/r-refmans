<!DOCTYPE html><html><head><title>Help for package phyreg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {phyreg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#phyreg-package'>
<p>The Phylogenetic Regression of Grafen (1989)</p></a></li>
<li><a href='#Example+20datasets'>
<p>Example data</p></a></li>
<li><a href='#factory_default'>
<p>Default settings for &quot;minor&quot; parameters</p></a></li>
<li><a href='#inf'>
<p>Provides information about the stored output of a call to phyreg()</p></a></li>
<li><a href='#phyreg'>
<p>Performs a phylogenetic regression</p></a></li>
<li><a href='#Translating+20phylogenies'>
<p>Using phylogenies formatted in standard but &quot;other&quot; ways</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>The Phylogenetic Regression of Grafen (1989)</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-04-12</td>
</tr>
<tr>
<td>Author:</td>
<td>Alan Grafen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alan Grafen &lt;alan.grafen@sjc.ox.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides general linear model facilities (single y-variable, multiple x-variables with arbitrary mixture of continuous and categorical and arbitrary interactions) for cross-species data. The method is, however, based on the nowadays rather uncommon situation in which uncertainty about a phylogeny is well represented by adopting a single polytomous tree. The theory is in A. Grafen (1989, Proc. R. Soc. B 326, 119-157) and aims to cope with both recognised phylogeny (closely related species tend to be similar) and unrecognised phylogeny (a polytomy usually indicates ignorance about the true  sequence of binary splits).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-04-12 14:37:51 UTC; Alan</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-04-12 16:35:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='phyreg-package'>
The Phylogenetic Regression of Grafen (1989)
</h2><span id='topic+phyreg-package'></span>

<h3>Description</h3>

<p>The Phylogenetic Regression provides general linear model facilities for cross-species analyses, including hypothesis testing and parameter estimation, based on the now rather uncommon situation in which the uncertainty about a phylogeny is well represented as a polytomous tree (see below for further discussion). It uses branch lengths to account for recognised phylogeny (which makes the errors of more closely related species more similar), and the single contrast approach to account for unrecognised phylogeny (that a polytomy usually represents ignorance about which exact binary tree is true, and so one higher node should contribute only one degree of freedom to the test). One dimension of flexibility in the branch lengths is fitted automatically.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> phyreg</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-04-12</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2 | GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>You need a dataset of species data, and a phylogeny for those species that is in either (i) a series of taxonomic vectors, (ii) a &quot;phylo&quot; object, (iii) in newick format, or (iv) a single vector of the kind used internally in this package. For branch lengths, you can use the default &quot;Figure 2&quot; method of Grafen (1989), or specify the height of each node, or give a height to each level of the taxonomic vectors. Then you can test for H0 of one model against an HA of another, where the difference can be one or more x-variables, or interactions, or both, where the x-variables can be continuous or categorical. You may choose which species to include and exclude in each analysis. Missing data is handled automatically: you needn't do anything special, though a species is simply omitted from an analysis for which it has missing data in the response or in the control or test variables. It is assumed that missing data has the standard R value of NA.
</p>
<p>In all linear models, the logic of each test involves controlling for some model terms while adding some test term(s). In simple cases such as ordinary multiple regression, the same analysis will give lots of tests and the user need only work out what the (often implicit) control and test terms are for each test. With the phylogenetic regression, only one test can be performed for a given analysis, and it is necessary to be explicit each time about the control terms and the test terms. This is because the single contrast taken across the daughters of one higher node depends upon the residuals in the control model.
</p>
<p>At the time of the development of the theory, the best representation of the biologist's uncertain knowledge about a phylogeny was a polytomous tree where the polytomies represented uncertainty about the true order of splitting. By 2018, it has for some years been different. Now the common situation is to have a list of binary phylogenies with some kind of weighting as to how strongly each binary phylogeny is compatible with the data used to create the phylogeny. <code>phyreg()</code> is about the first, historical, kind of uncertainty, and not about the more modern kind. Thus, it will only occasionally be found useful today. However, I like to have the sophisticated test available in a convenient form, thanks to the structure of R. For example, all the output and many inner workings can be made available as variables after an analysis.
</p>
<p>Version 1.0.1 (appeared on CRAN 2018-04-08) made the package compatible with updated rules for having packages on CRAN but did not change the functionality. Version 1.0.2 (2018-04-12) made the package compatible with more of those updated rules that were drawn to my attention only after 1.0.1 had appeared on CRAN, and these changes necessitated dropping the capacity to retain default parameter values across sessions - sorry!
</p>
<p>Full details and examples are given under <code><a href="#topic+phyreg">phyreg</a></code>
</p>


<h3>Author(s)</h3>

<p>Alan Grafen, with portions copied as follows.
</p>
<p>(1) <code>read.newick</code> (used internally only) copied from Liam Rewell (see <code><a href="#topic+phyfromnewick">phyfromnewick</a></code> for a more detailed acknowledgment)
</p>
<p>(2) the definition of <code>ginv</code> has been copied from MASS (package comes with current R downloads; book is W.N. Venables and B.D. Ripley (2002) Modern Applied Statistics in S. (Fourth Edition), Springer &ndash; <a href="http://www.stats.ox.ac.uk/pub/MASS4">http://www.stats.ox.ac.uk/pub/MASS4</a>). This avoids having to <code>require</code> the whole package, though it may mean I have amend it if R and MASS make a simultaneous change in the low-level routines they use. <code>ginv</code> was copied and pasted from R 3.0.2 on 64-bit MacOS on 24th January 2014. It finds the generalised inverse of a matrix.
</p>
<p>(3) code for dealing with model formulae (internal functions <code>merge.formulae.ag</code> and <code>merge.formulae.test.ag</code>) was adapted from code of Steven Carlisle Walker obtained from 
<a href="https://stevencarlislewalker.wordpress.com/2012/08/06/merging-combining-adding-together-two-formula-objects-in-r/">https://stevencarlislewalker.wordpress.com/2012/08/06/merging-combining-adding-together-two-formula-objects-in-r/</a> in January 2014.
</p>
<p>Maintainer: Alan Grafen &lt;alan.grafen@sjc.ox.ac.uk&gt;
</p>


<h3>References</h3>

<p>Grafen, A. 1989. The phylogenetic regression. Philosophical Transactions of the Royal Society B, 326, 119-157.
Available online at <a href="http://users.ox.ac.uk/~grafen/cv/phyreg.pdf">http://users.ox.ac.uk/~grafen/cv/phyreg.pdf</a>. Some further information including GLIM and SAS implementations is available at <a href="http://users.ox.ac.uk/~grafen/phylo/index.html">http://users.ox.ac.uk/~grafen/phylo/index.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phyreg">phyreg</a></code>
</p>

<hr>
<h2 id='Example+20datasets'>
Example data
</h2><span id='topic+myd0'></span><span id='topic+myd1'></span><span id='topic+myd2'></span><span id='topic+myd3'></span><span id='topic+extax'></span><span id='topic+newickstr'></span>

<h3>Description</h3>

<p>Datasets <code>myd0</code> to <code>myd3</code> are data frames that contain a y-variable, three continuous x-variables <code>X1</code> to <code>X3</code>, and two factors <code>A</code> and <code>B</code>. They were simulated by a phylogenetic method, and also contain the error. The phylogeny was created from the taxonomic variables in <code>extax</code> &ndash; the heights of the levels were assumed to be 0 for species, 1,2,3 for the three taxonomic variables, and 4 for the root.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(myd0)
data(myd1)
data(myd2)
data(myd3)
data(extax)
data(newickstr)</code></pre>


<h3>Format</h3>

<p><code>myd0</code> to <code>myd3</code> are datasets with 100 observations on the following 7 variables.
</p>

<dl>
<dt><code>error</code></dt><dd><p>drawn from a standard Normal distribution for each species, but of course correlated appropriately for the phylogeny</p>
</dd>
<dt><code>X1-X3</code></dt><dd><p>continuous variables</p>
</dd>
<dt><code>A, B</code></dt><dd><p>factors with four levels <code>1</code> to <code>4</code></p>
</dd>
<dt><code>y</code></dt><dd><p>the response variable.</p>
</dd>
</dl>

<p><code>extax</code> is a data frame containing three taxonomic variables describing a phylogeny for 100 species
<code>newickstr</code> is a character variable containing the same phylogeny as represented by <code>extax</code>, but in newick format &ndash; see Description for explanation of the heights.
</p>


<h3>Details</h3>

<p>The formula calculating y from the independent variables was the same in each dataset, but the independent variables and the error were resampled for each dataset. The mean square error increases from <code>myd0</code> to <code>myd3</code>. By including &quot;error&quot; in the model (never possible in life, of course) you can obtain the coefficients and root mean square error used to construct the data. The categorical characters are evolved on the tree by taking a transition matrix (<code>tm</code>) to represent the transition probabilities after one unit of time, taking the matrix logarithm (<code>ltm&lt;-logm(tm)</code>), and using the transition matrix <code>expm(bl * ltm)</code> for a branch length of duration <code>bl</code>. (Note that <code>expm()</code> and especially <code>logm()</code> are available in the package <code>expm</code>.)
</p>
<p>For examples of use, see <code><a href="#topic+phyreg">phyreg</a></code>.
</p>


<h3>See Also</h3>

<p>The data is useful in calls to <code><a href="#topic+phyreg">phyreg</a></code>, with arguments specified as <code>data=myd0</code> etc and <code>taxmatrix=extax</code>. <code>newickstr</code> is useful in calls to <code>phyfromnewick</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(myd0, myd1, myd2, myd3, extax, newickstr)
</code></pre>

<hr>
<h2 id='factory_default'>
Default settings for &quot;minor&quot; parameters
</h2><span id='topic+factory_default'></span><span id='topic+new_default'></span>

<h3>Description</h3>

<p>These functions change the effect of including <code>reset=TRUE</code> as an argument to <code>phyreg()</code>. After a call of <code>factory_default()</code>, the reset will be to the original values hard-wired in the package's code. If you call <code>new_default()</code>, the values of the minor parameters in place at that moment become the reset values for all uses of <code>reset=TRUE</code> until a future call of one of these functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factory_default()
new_default()
</code></pre>


<h3>Details</h3>

<p>The unstored, major, parameters are the <code>control</code> and <code>test</code> parameters, and the data parameters, namely <code>data</code>, <code>phydata</code>, <code>taxmatrix</code> and <code>heightsdata</code>. The remaining parameters are minor. All the parameters are listed under <code><a href="#topic+phyreg">phyreg</a></code>, and examples of use are also given there. Note that changing a parameter whether major or minor leaves the newly set value of that parameter as the default for future calls of <code>phyreg()</code> until either the parameter is changed again, or <code>reset=TRUE</code> is included as an argument of <code>phyreg()</code>.
</p>


<h3>Author(s)</h3>

<p>Alan Grafen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phyreg">phyreg</a></code>
</p>

<hr>
<h2 id='inf'>
Provides information about the stored output of a call to phyreg()
</h2><span id='topic+inf'></span>

<h3>Description</h3>

<p>After an instruction <code>m&lt;-phyreg(...)</code>, you can type <code>inf(m,...)</code> to provide information about <code>m</code>. You can see output again, or that you didn't ask for from the initial call of <code>phyreg()</code>. And you can find out whether optional storage took place of the different possible outputs, if not, how to ask for it, and if so, how to access it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inf(inpr, ..., oppf = 5, opdf = 1, oprho = 0, dfwarning = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inf_+3A_inpr">inpr</code></td>
<td>

<p>An object of class <code>phyreglm</code> i.e. that has been produced from an assignment of the form <code>m&lt;-phyreg(...)</code>.
</p>
</td></tr>
<tr><td><code id="inf_+3A_...">...</code></td>
<td>

<p>To see the list of the possible parameters, call <code>inf()</code> itself with no parameters. They are arguments of <code>phyreg</code> that influence printing and storage of information. Four are shown below and can vary the way information is presented compared to the original call. See Details for information on the others.
</p>
</td></tr>
<tr><td><code id="inf_+3A_oppf">oppf</code></td>
<td>

<p>If non-zero, the p-value and F-statistic are printed out at each call of <code>phyreg</code>, with <code>ndigits=oppf</code>. If zero, they are not printed out. <code>(inf)</code> will print these out for you if you include <code>"oppf"</code>.
</p>
</td></tr>
<tr><td><code id="inf_+3A_opdf">opdf</code></td>
<td>

<p>If non-zero, a breakdown of degrees of freedom is printed out at each call of <code>phyreg</code>. <code>(inf)</code> will print this out for you if you include <code>"opdf"</code>.
</p>
</td></tr>
<tr><td><code id="inf_+3A_oprho">oprho</code></td>
<td>

<p>If nonzero, details of rho will be printed with <code>ndigits=oprho</code>. If rho was fitted, the value of rho and the log-likelihood will be given, and how the search ended (lower boundary, or an internal maximum). <code>(inf)</code> will print this out for you if you include <code>"oprho"</code>.
</p>
</td></tr>
<tr><td><code id="inf_+3A_dfwarning">dfwarning</code></td>
<td>

<p>If <code>TRUE</code> or <code>1</code>, the loss of degrees of freedom for phylogenetic reasons is detailed. <code>(inf)</code> will print this out for you if you include <code>"dfwarning"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>...</code> are used rather irregularly to allow values to be specified as character constants. These are the 13 final arguments of <code>phyreg()</code>, which specify material to be printed or to be stored. The printed material will be reprinted by <code>inf()</code>, saving the need to repeat the analysis. For saved material, including the character constant will instruct <code>inf()</code> to tell you whether that material was stored and both how to access it if it was stored and , if not, how to store it next time you use <code>(phyreg)</code>. You may include as many as these character constants as you like in one call of <code>inf()</code>. The &quot;printing&quot; constants are <code>"parmx"</code>, <code>"parmxz"</code>, <code>"opfunccall"</code>, <code>"means"</code>, and <code>"addDF"</code>, while the &quot;saving&quot; constants are <code>"linputs"</code>, <code>"sinputs"</code>, <code>"lmshortx"</code>, <code>"lmshortxz"</code>, <code>"lmlongx"</code>, <code>"lmlongxz"</code>, <code>"hinput"</code> and <code>"paper"</code>. To find what information is stored or printed by each character constant, see the help file for <code>phyreg</code> and look for the argument with the same name.
</p>


<h3>Author(s)</h3>

<p>Alan Grafen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phyreg">phyreg</a></code>
</p>

<hr>
<h2 id='phyreg'>
Performs a phylogenetic regression 
</h2><span id='topic+phyreg'></span>

<h3>Description</h3>

<p>If this documentation looks daunting, look first at the examples below!
</p>
<p>Takes a control formula, some test terms, a dataframe, a phylogeny, and optionally a set of node heights, and performs a test of H0 (control terms only) vs HA (control plus test terms). The user can specify a value of rho (a parameter that determines whether branch lengths are bigger near the root or near the tips), or ask that it be fitted by maximum likelihood. The primary outputs are a p-value and F-ratio, and parameter estimates. Much more information is available, much of it needing to be interpreted very cautiously.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyreg(control, test, data, subset, phydata, taxmatrix, heightsdata, 
rho = -1, lorho = 0.3, hirho = 0.6, errrho = 0.02, minrho = 1e-04, 
tolerance = 1e-06, oppf = 5, opdf = 0, parmx = 0, parmxz = 0, 
opfunccall = 0, addDF = 0, linputs = FALSE, sinputs = FALSE, means = FALSE, 
lmshortx = FALSE, lmshortxz = FALSE, lmlongx = FALSE, lmlongxz = FALSE, 
hinput = FALSE, paper = FALSE, dfwarning = TRUE, oprho = FALSE, reset = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phyreg_+3A_control">control</code></td>
<td>

<p>The null hypothesis model, which should be a formula with a response variable. If there are no variables to control for, specify <code>y~1</code>. (<code>y~0</code> is not permitted, as it undermines the logic of the test.)
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_test">test</code></td>
<td>
<p>The test terms. To control for <code>y~b</code>, and test for <code>a*x</code>, you can specify (i) <code>test="a*x"</code> or (ii) <code>test=y~b+a*x</code> or (iii) <code>test=~+a*x</code>. Note the &quot;+&quot; <em>and</em> the absence of the response variable in the final form
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_data">data</code></td>
<td>
<p>A mandatory dataframe containing the variables in the model formulae</p>
</td></tr>
<tr><td><code id="phyreg_+3A_subset">subset</code></td>
<td>

<p>a vector of the same length as the data, containing 0/1 for exclusion or inclusion of a species. If unspecified, the internal default is to include all species. To return to being unspecified, say <code>subset=NULL</code>
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_phydata">phydata</code></td>
<td>

<p>a vector with the phylogeny in the internal package format (containing for each non-root node the ID number of its parent). Either <code>phydata</code> or <code>taxmatrix</code> must be supplied. To unspecify, say <code>phydata=NULL</code> or <code>taxmatrix=NULL</code>. A phylogeny in newick or phylo format can be converted into the internal forma, preserving height information, with <code>phyfromnewick</code> or <code>phyfromphylo</code>.
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_taxmatrix">taxmatrix</code></td>
<td>

<p>a dataframe with a set of taxonomic vectors to specify the working phylogeny. There should be no species column, and the others should start with low levels (e.g. genus) and end with the highest (perhaps order). If <code>taxmatrix</code> is specified, you can alternatively specify <code>heightsdata</code> with a vector containing one height for each level you've given, plus a height for the root, or if that is <code>NULL</code> the default &quot;Figure 2&quot; of Grafen (1989) will be used. Either <code>taxmatrix</code> or <code>phydata</code> (&ndash; not both) must be supplied. Despecify with <code>taxmatrix=NULL</code>.
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_heightsdata">heightsdata</code></td>
<td>

<p>If not specified, the height of nodes will be calculated using the default &quot;Figure 2&quot; method of Grafen (1989). If a height is specified for each node, then the vector will be one element longer than <code>phydata</code>, as the root has a height but no parent. If <code>taxmatrix</code> is specified, then <code>heightsdata</code> can also be specified as a vector of length one plus the number of taxonomic vectors, in which case each node is given a height corresponding to its level in the taxonomy &ndash; the extra element is the height of the root. In both cases, <code>heightsdata</code> must be non-decreasing.
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_rho">rho</code></td>
<td>

<p>If zero or negative, <code>rho</code> will be fitted by maximum likelihood. If positive, that value will taken for rho and no fitting will be done. Once the node heights are scaled to lie between 0 and 1, each height is raised to the power rho before being used to determine the error structure in the model. See Grafen (1989) for details.
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_lorho">lorho</code></td>
<td>

<p>The starting lower bound for the search for rho
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_hirho">hirho</code></td>
<td>

<p>The starting upper bound for the search for rho
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_errrho">errrho</code></td>
<td>

<p>The search for rho will stop when it is known to lie in an interval of length <code>errrho</code>
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_minrho">minrho</code></td>
<td>

<p>The search for rho will stop when the whole current search interval lies below <code>minrho</code>. A zero value of rho is problematic for the program.
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_tolerance">tolerance</code></td>
<td>

<p>This tolerance decides whether there is enough variability among the daughters of a higher node to justify putting it into the short regression. This is because the residuals in the long regression on the control variables are used to calculate a contrast; if they are very small, then the contrast is effectively being determined by machine rounding errors, and if they are zero, then all contrasts should also be zero and so the higher node will be irrelevant in a regression through the origin.
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_oppf">oppf</code></td>
<td>

<p>If non-zero, the p-value and F-statistic are printed out at each call of <code>phyreg</code>, with <code>ndigits=oppf</code>. If zero, they are not printed out.
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_opdf">opdf</code></td>
<td>

<p>If non-zero, a breakdown of degrees of freedom is printed out at each call of <code>phyreg</code>.
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_parmx">parmx</code></td>
<td>

<p>If non-zero, the parameters in the long regression with the control formula are printed out at each call of <code>phyreg</code>.
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_parmxz">parmxz</code></td>
<td>

<p>If non-zero, the parameters in the long regression with the control+test formula are printed out at each call of <code>phyreg</code>. Note these should be regarded with caution, as the value of rho was fitted just on the control formula. For better estimates, run <code>phyreg</code> again with the old control+test as the new control, and set <code>opparmx=1</code>. But <code>opparmxz</code> will usually give a good rough guide.
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_opfunccall">opfunccall</code></td>
<td>

<p>If non-zero, the function call is printed out
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_adddf">addDF</code></td>
<td>

<p>Advised to leave well alone. Included for backwards compatibility with the original GLIM version. It was originally but misguidedly intended to make a correction to the total degrees of freedom for the test in recognition of the fitting of rho. However, the fitting of rho is now regarded as affecting the numerator and denominator SS equally, and so not to require the correction.
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_linputs">linputs</code></td>
<td>

<p>If <code>TRUE</code> or <code>1</code>, the inputs to the long regression will be stored. After <code>x&lt;-phyreg(...,linputs=1)</code>, it will be found that <code>x$linputs$y</code>, <code>x$linputs$designxz</code> and <code>x$linputs$w</code> will contain the response, design matrix, and weights for the long regression, respectively. Use with care. The whole point of the the problem of <em>unrecognised</em> phylogeny is that the standard errors from this regression cannot be trusted, though with a dependable binary phylogeny, the output can be accepted at face value.
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_sinputs">sinputs</code></td>
<td>

<p>If <code>TRUE</code> or <code>1</code>, the inputs to the short regression will be stored. After <code>x&lt;-phyreg(...,sinputs=1)</code>, it will be found that <code>x$sinputs$y</code>, <code>x$sinputs$designxz</code> and <code>x$sinputs$w</code> will contain the response, design matrix, and weights for the short regression, respectively. Use with care. Not only can the standard errors from this regression not be trusted, but the parameter estimates are biassed!
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_means">means</code></td>
<td>

<p>If <code>TRUE</code> or <code>1</code>, the phylogenetically-weighted means will be printed for the response and for each variable in the design matrix of the control+test model (in the original species dataset, which are the same as the weighted means in the long regression).
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_lmshortx">lmshortx</code></td>
<td>

<p>If <code>TRUE</code> or <code>1</code>, then after <code>x&lt;-phyreg(...,lmshortx=1)</code>, the <code>lm.wfit()</code> output from the short regression with the control formula will be stored in <code>x$lmshortx</code>. Use with care &ndash; the parameter estimates are biassed...
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_lmshortxz">lmshortxz</code></td>
<td>

<p>If <code>TRUE</code> or <code>1</code>, then after <code>x&lt;-phyreg(...,lmshortxz=1)</code>, the <code>lm.wfit()</code> output from the short regression with the control+test formula will be stored in <code>x$lmshortxz</code>. Use with care &ndash; the parameter estimates are biassed...
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_lmlongx">lmlongx</code></td>
<td>

<p>If <code>TRUE</code> or <code>1</code>, then after <code>x&lt;-phyreg(...,lmlongx=1)</code>, the <code>lm.wfit()</code> output from the long regression with the control formula will be stored in <code>x$lmlongx</code>. The SEs cannot be trusted for non-binary phylogenies.
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_lmlongxz">lmlongxz</code></td>
<td>

<p>If <code>TRUE</code> or <code>1</code>, then after <code>x&lt;-phyreg(...,lmlongxz=1)</code>, the <code>lm.wfit()</code> output from the long regression with the control+test formula will be stored in <code>x$lmlongxz</code>. The SEs cannot be trusted for non-binary phylogenies.
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_hinput">hinput</code></td>
<td>

<p>If <code>TRUE</code> or <code>1</code>, then after <code>x&lt;-phyreg(...,hinput=1)</code>, the heights used will be stored in <code>x$hinput</code>. If you use <code>taxmatrix=...</code>, this is a way to obtain the internal &quot;phy&quot; version of the heights for each higher node. These heights have <em>not</em> been modulated by rho i.e. they are the starting heights before rho is applied.
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_paper">paper</code></td>
<td>

<p>If <code>TRUE</code> or <code>1</code>, then after <code>x&lt;-phyreg(...,paper=1)</code>, various matrices that appear in the appendix of the source paper (Grafen 1989) will be stored under x$paper. Type <code>names(x$paper)</code> to see which ones!
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_dfwarning">dfwarning</code></td>
<td>

<p>If <code>TRUE</code> or <code>1</code>, the loss of degrees of freedom for phylogenetic reasons is detailed.
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_oprho">oprho</code></td>
<td>

<p>If nonzero, details of rho will be printed with <code>ndigits=oprho</code>. If rho was fitted, the value of rho and the log-likelihood will be given, and how the search ended (lower boundary, or an internal maximum).
</p>
</td></tr>
<tr><td><code id="phyreg_+3A_reset">reset</code></td>
<td>
<p>	If <code>TRUE</code> or <code>1</code>, the minor parameters will all be reset to their default values. Useful if you've forgotten what you've set, or if you're moving on to another analysis. See <code><a href="#topic+new_default">new_default</a></code> and <code><a href="#topic+factory_default">factory_default</a></code> for changing the default values themselves, and for what a <em>minor</em> parameter is.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One key point for using the program is that each node in the phylogeny has an ID number, with which it is identified. For a species, the number is given by its position in the data frame with the data itself, which is assumed to have species in the same order as in the taxonomic variables data frame, if that is specified, and the same order as in the newick-style phylogeny if you use <code>phyfromnewick</code>. If <code>phyfromphylo</code> is used, the code numbers of the species are carried over from the &quot;phylo&quot; object to the internally formatted &quot;phy&quot; vector. These species ID numbers are fixed no matter whether that species or another is excluded by the <code>subset</code> parameter of <code>phyreg</code>, or for missing data. Higher nodes have ID numbers too. In every phylogeny, each node's parent has a higher ID number than it does, except the root, which has no parent. The numbers for higher nodes <em>do</em> vary when species are omitted for any reason.
</p>
<p>The main feature of phylogenetic data that the Phylogenetic Regression deals with differently from other methods is <em>unrecognised phylogeny</em>. It operates on the principle that each higher node should provide one datapoint to a valid test, and not more, and does so by choosing just one linear contrast across the daughters of each higher node. The contrast coefficients come from the residuals of the long regression on the control model. For a full mathematical justification of this choice, see the appendix to Grafen (1989), and see the paper itself for conceptual explanations. With binary phylogenies, of course, there is no unrecognised phylogeny. A parameter of the branch lengths is fitted automatically, unless the user wishes to impose a value, which allows the strength of phylogenetic association to be make weaker or stronger. Simulation studies in Grafen (1989) show that the method has good properties, and also that ignoring unrecognised phylogeny can create serious problems. 
</p>
<p>On some occasions, degrees of freedom are lost &quot;for phylogenetic reasons&quot;. A whole node may be lost to the final test if the residuals of its daughter nodes are all zero in the long regression. This can happen for various reasons, most often when (i) the response is in fact binary, and so there is no variation in it below a node, or (ii) a categorical variable has so many values restricted to one part of the tree that a subset of its parameter values can adjust to render all the residuals zero in that part of the tree. That is called a node being lost in the denominator. The other possibility is that once the contrasts have been taken across each higher node, the design matrix for the model has lower rank than it did before, which is called losing a degree of freedom in the numerator (it is transferred to the denominator). You can choose to be warned when degrees of freedom are lost for phylogenetic reasons (use <code>dfwarning</code>=1), or to see a whole breakdown of degrees of freedom including any lost (use <code>opdf=1</code>). If nodes are lost in the denominator, their ID numbers are stored in the output <code>$shornode</code>, though note this also contains an initial <code>0</code> for programming convenience. These phylogenetic degree of freedom issues need to be handled properly to provide a valid test &ndash; see Grafen (1989) for details.
</p>
<p>The data for long and short regressions, and the <code>lm.wfit()</code> output are provided on request, but must be used with great caution. The whole point of the phylogenetic regression is that neither type of regression provides results that can be taken at face value, except the long regression under binary phylogenies. Use at your own risk! See Grafen (1989) for details.
</p>
<p>Some simulated data is included to facilitate the examples below &ndash; see <code><a href="#topic+myd0">myd0</a></code>
</p>


<h3>Value</h3>

<table>
<tr><td><code>H0model</code></td>
<td>
<p>The control model</p>
</td></tr>
<tr><td><code>HAmodel</code></td>
<td>
<p>The control+test model</p>
</td></tr>
<tr><td><code>spu</code></td>
<td>
<p>A vector with a 0/1 for each species to indicate whether it was used (1) or not (0), depending on the argument <code>subset</code> and on missing values</p>
</td></tr>
<tr><td><code>nomspuse</code></td>
<td>
<p>The number of species omitted because of missing values (not counting those already omitted because of the argument <code>subset</code>)</p>
</td></tr>
<tr><td><code>longrss</code></td>
<td>
<p>The residual sum of squares in the long regression with the control formula </p>
</td></tr>
<tr><td><code>missingnodes</code></td>
<td>
<p>A vector of the ID numbers of nodes omitted for phyogenetic reasons (see Details above). An extra zero is included for programming convenience.</p>
</td></tr>
<tr><td><code>shornode</code></td>
<td>
<p>The ID numbers of the higher nodes in the supplied phylogeny that are used in the short regression, so <code>shornode[5]</code> gives the ID number of the node for the 5th datapoint.</p>
</td></tr>
<tr><td><code>details</code></td>
<td>
<p>contains various numbers needed for output, namely <code>$poff</code> (the p-value), <code>$testf</code> (the F-ratio), <code>$testnumdf</code> (the numerator DF), <code>$testdendf</code> (the denominator DF), <code>$nspec</code> (total number of species, included and excluded, so it equals nrow(input_dataframe)), <code>$nommiss</code> (the number of species omitted because of missing values (not counting those already omitted because of the argument <code>subset</code>)), <code>$nspecactive</code> (number of species included in the analysis), <code>$nomspuse</code> (number of species omitted because of the argument <code>subset</code>), <code>$nphyhinodes</code> (the number of non-species nodes in the supplied phylogeny (ie. with all species included)), <code>$hilostomsp</code> (the number of higher nodes lost through species omitted because of the argument <code>subset</code>, <code>$hilostvar</code> (number of higher nodes lost to the short regression through lack of variability in the long regression &ndash; see &quot;Phylogenetic Degrees of Freedom&quot; in Details), <code>$shortotdf</code> (total DF in short regression), <code>$dflx</code> (rank of the long regression with the control model), <code>$dfxlost</code> (loss of numerator DF in short regression &ndash; see &quot;Phylogenetic Degrees of Freedom&quot; in Details), <code>$dfsx</code> (rank of short regression with control model), <code>$testlongdf</code> (<code>=$dflxz-$dflx</code>, the degrees of freedom for the test terms in the long regression), <code>$testlost</code> (degrees of freedom for the test variables, lost for phylogenetic reasons &ndash; see &quot;Phylogenetic Degrees of Freedom&quot; in Details)), <code>$shortcondf</code> (control degrees of freedom in the short regression), <code>$addDF</code> (retains the argument <code>addDF</code> as it's needed in calculations), <code>$rho</code> (the value of rho used in the final test), <code>$lik</code> (the log-likelihood of that value of rho), <code>$edge</code> (coded -1 for error, 2 for rho set by the user, and, with a fitted rho, 0 for an internal maximum of the likelihood, and 1 for a maximum at the lower edge of the search region (specified by <code>minrho</code>)), <code>$missingnodes</code> (the numbers of the higher nodes omitted for lack of variability in the short regression, but an extra 0 at the start &ndash; see Details)</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>The phylogenetically weighted means of the response variable and the design matrix for the control+test model</p>
</td></tr>
<tr><td><code>parmx</code></td>
<td>
<p>Parameter estimates from the long regression with the control model</p>
</td></tr>
<tr><td><code>parmxz</code></td>
<td>
<p>Parameter estimates from the long regression with the control+test model</p>
</td></tr>
<tr><td><code>funccall</code></td>
<td>
<p>The function call with which you invoked <code>phyreg</code></p>
</td></tr>
<tr><td><code>fullphy</code></td>
<td>
<p>The full phylogeny for all species. This will just be <code>phydata</code> if you specified the phylogeny that way, but otherwise has been converted from taxonomic vectors.</p>
</td></tr>
<tr><td><code>usedphy</code></td>
<td>
<p>The phylogeny for the species included in the analysis. There is an entry for every species, and each included species has its original ID, and every omitted species has zero. There may well be fewer higher nodes in <code>usedphy</code> than in <code>fullphy</code>, because only higher nodes with two or more daughters are retained. This vector is useful if you want to study the matrices from the paper (see the argument and value<code>paper</code>) as many are indexed by <code>usedphy</code>. All node numbers reported by the program elsewhere are the original IDs, and so <code>usedphy</code> is important only for internal and/or technical reasons.</p>
</td></tr>
<tr><td><code>originalIDs</code></td>
<td>
<p>This tells you, for each node in <code>usedphy</code>, which node in <code>fullphy</code> it corresponds to.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>A list with <code>$rho</code>, <code>$lik</code> and <code>$edge</code> &ndash; see <code>$details</code> for details</p>
</td></tr>
<tr><td><code>sinputs</code></td>
<td>
<p>(optional) the inputs to the short regression namely <code>sinputs$y</code>, <code>sinputs$design</code> and <code>sinputs$w</code> for the response, design matrix and weights</p>
</td></tr>
<tr><td><code>linputs</code></td>
<td>
<p>(optional) the inputs to the long regression namely <code>linputs$y</code>, <code>linputs$design</code> and <code>linputs$w</code> for the response, design matrix and weights</p>
</td></tr>
<tr><td><code>lmlongx</code></td>
<td>
<p>(optional) The <code>lm.wfit()</code> output from the long regression with the control model. Choose to store using the argument of the same name.</p>
</td></tr>
<tr><td><code>lmlongxz</code></td>
<td>
<p>(optional) The <code>lm.wfit()</code> output from the long regression with the control+test model. Choose to store using the argument of the same name.</p>
</td></tr>
<tr><td><code>lmshortx</code></td>
<td>
<p>(optional) The <code>lm.wfit()</code> output from the short regression with the control model. Choose to store using the argument of the same name.</p>
</td></tr>
<tr><td><code>lmshortxz</code></td>
<td>
<p>(optional) The <code>lm.wfit()</code> output from the short regression with the control+test model. Choose to store using the argument of the same name.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alan Grafen, with portions copied as follows.
</p>
<p>(1) <code>read.newick</code> (used internally only) copied from Liam Rewell (see <code><a href="#topic+phyfromnewick">phyfromnewick</a></code> for a more detailed acknowledgment)
</p>
<p>(2) the definition of <code>ginv</code> has been copied from MASS (package comes with current R downloads; book is W.N. Venables and B.D. Ripley (2002) Modern Applied Statistics in S. (Fourth Edition), Springer &ndash; <a href="http://www.stats.ox.ac.uk/pub/MASS4">http://www.stats.ox.ac.uk/pub/MASS4</a>). This avoids having to <code>require</code> the whole package, though it may mean I have amend it if R and MASS make a simultaneous change in the low-level routines they use. <code>ginv</code> was copied and pasted from R 3.0.2 on 64-bit MacOS on 24th January 2014. It finds the generalised inverse of a matrix.
</p>
<p>(3) code for dealing with model formulae (internal functions <code>merge.formulae.ag</code> and <code>merge.formulae.test.ag</code>) was adapted from code of Steven Carlisle Walker obtained from 
<a href="https://stevencarlislewalker.wordpress.com/2012/08/06/merging-combining-adding-together-two-formula-objects-in-r/">https://stevencarlislewalker.wordpress.com/2012/08/06/merging-combining-adding-together-two-formula-objects-in-r/</a> in January 2014. 
</p>


<h3>References</h3>

<p>The source paper is Grafen, A. 1989. The phylogenetic regression. Philosophical Transactions of the Royal Society B, 326, 119-157. Some further information is at <a href="http://users.ox.ac.uk/~grafen/phylo/index.html">http://users.ox.ac.uk/~grafen/phylo/index.html</a>, including previous implementations in GLIM and SAS.
</p>


<h3>See Also</h3>

<p>The package helpfile is at <code><a href="#topic+phyreg-package">phyreg-package</a></code>. Functions are <code><a href="#topic+inf">inf</a></code>, <code><a href="#topic+phyfromnewick">phyfromnewick</a></code>, <code><a href="#topic+phyfromphylo">phyfromphylo</a></code>, <code><a href="#topic+factory_default">factory_default</a></code>, <code><a href="#topic+new_default">new_default</a></code>. For simulated data see <code><a href="#topic+myd0">myd0</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First get some data
data(myd0,myd1, myd2, myd3, extax)
## Then do our first analysis
phyreg(y~X1,"A",myd0,taxmatrix=extax)
## and test instead for "B", noticing that only the changed parameter need be given
phyreg(test="B")
## and we do more complicated analysis involving an interaction with an existing term
phyreg(y~X1+X2,"A*X1")
## Now we choose to see the output relating to rho and to how the degrees of freedom are determined,
##   and we also wish to see the means for each variable, and the parameters from the long 
##   regression on control+test variables
phyreg(oprho=6, opdf=1, means=1,parmxz=1)
## To illustrate inf, we store the results of an analysis in m1
m1&lt;-phyreg(y~A,"X1+X2")
## Note we still get the extra output from the previous call, because those parameters 
##   too are remembered within a session. But we can see it again, whether or not we
##   saw it the first time, with inf. inf reminds you if you forget quite how to use it
inf()
inf(m1)
inf(m1,oppf=3)
inf(m1,oppf=7, oprho=5)
inf(m1, oppf=5, "means", "parmx")
inf(m1,"sinputs","lmshortx")
## The final call asks for things m1 doesn't have because it wasn't stored at the time. Now
##  we turn to changing the default parameters with new_default and factory_default. The help 
##  pages for those functions explain that only minor parameters (those affecting output and
##  storage, and those affecting rho), and not the models or the data-bearing parameters, have
##  default values.
new_default()
## This call takes the most recent parameters to phyreg and makes them the default, which
##   in the first instance changes nothing. But if we later call reset=TRUE as an argument
##   of phyreg, it is the values at the time of calling new_default() that will be returned
##   to. In this instance, we would automatically get output on rho and degrees
##   of freedom, and the means and xz parameters printed).
##   
##   To see this in operation, we would change those parameters...
phyreg(oprho=0,opdf=0,means=0,parmxz=0)
##   ... and then in the next call use reset=1. That will restore the defaults, which we changed
##   with new_default. To change the defaults back to the values that shipped with the
##   package, 
factory_default()
##   does the job.
##
## Finally, the phylogeny has so far been determined by a data frame of taxonomic variables in the
##   argument taxmatrix. If we have the phylogeny available in newick style, we can convert to 
##   the internal format, and then use that instead. Fortunately, one is provided. Note it is
##   good form to unset the other method of specifying a phylogeny (which is being remembered by
##   the package) with taxmatrix=NULL
data(newickstr)
z&lt;-phyfromnewick(text=newickstr)
phyreg(phydata=z$phy,taxmatrix=NULL)
##   ... and if branch lengths were supplied, and we trust them, we can
phyreg(y~X1, "A", phydata=z$phy, heightsdata=z$hts)
##  Similarly with a phylogeny in phylo format. We obtain one of those by using the "phylo"
##    value from phyfromnewick, and use an intermediate variable"phyloobject" to show how
##    to use one if you have one
phyloobject&lt;-z$orphylo
phyconverted&lt;-phyfromphylo(phyloobject)
phyreg(phydata=phyconverted$phy)
phyreg(phydata=phyconverted$phy, heightsdata=phyconverted$hts)
## The results should all be the same because it's the same phylogeny represented in three
##   different ways, with the same heights.
##
## Enjoy!
</code></pre>

<hr>
<h2 id='Translating+20phylogenies'>
Using phylogenies formatted in standard but &quot;other&quot; ways
</h2><span id='topic+phyfromnewick'></span><span id='topic+phyfromphylo'></span>

<h3>Description</h3>

<p>The two functions convert phylogenies in a standard format (newick or phylo) into a form that can be supplied as the argument <code>phydata</code> of <code>phyreg</code>. If node heights are specified, these are also provided in the value returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyfromnewick(file = "", text)
phyfromphylo(phylo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Translating+2B20phylogenies_+3A_file">file</code></td>
<td>

<p>a textfile containing the newick phylogeny, which must end with a semi-colon (<code>phyfromnewick</code> only)</p>
</td></tr>
<tr><td><code id="Translating+2B20phylogenies_+3A_text">text</code></td>
<td>

<p>a character variable containing the newick phylogeny, which must end with a semi-colon. Exactly one of these arguments should be supplied (<code>phyfromnewick</code> only)</p>
</td></tr>
<tr><td><code id="Translating+2B20phylogenies_+3A_phylo">phylo</code></td>
<td>
<p>an R-variable containing a &quot;phylo&quot; object, as used, for example, in the <code>ape</code> package (<code>phyfromphylo</code> only).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before passing the text to <code>read.newick</code>, I strip out all the spaces, to avoid problems.
</p>
<p><code>phyfromnewick</code> contains a function <code>read.newick</code> which &quot;reads Newick style tree with branch lengths into memory as an <code>ape</code> &quot;phylo&quot; object&quot;, and was written by Liam J. Revell in 2011, and downloaded on 24th January 2014. See references for url.
</p>
<p>Examples are given under <code><a href="#topic+phyreg">phyreg</a></code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>phy</code></td>
<td>
<p>The phylogenetic vector in internal format, with an element for every node, except the root, but including species. If <code>jj==phy[[ii]</code>, then <code>jj</code> is the parent-node of <code>ii</code>. It is a requirement for the internal format that <code>jj&gt;ii</code> in every case (it is <em>not</em> true of &quot;phylo&quot; objects that a parent's ID has to be greater than its offspring's). Suitable for supplying as the <code>phydata</code> argument of <code>phyreg</code></p>
</td></tr>
<tr><td><code>hts</code></td>
<td>
<p>The heights of each node, a vector with an element for every node. Thus it is longer by one than $phy. Suitable for supplying as the <code>heightsdata</code> argument of <code>phyreg</code></p>
</td></tr>
<tr><td><code>orphylo</code></td>
<td>
<p>The &quot;phylo&quot; style object created by <code>read.newick</code>. (<code>phylofromnewick</code> only)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alan Grafen,
with an internal function (<code>read.newick</code>) written by Liam J. Revell in 2011, downloaded on 24th January 2014. See references for url.
</p>


<h3>References</h3>

<p><a href="https://github.com/liamrevell/phytools/blob/master/R/read.newick.R">https://github.com/liamrevell/phytools/blob/master/R/read.newick.R</a> 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phyreg">phyreg</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
