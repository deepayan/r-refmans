<!DOCTYPE html><html lang="en"><head><title>Help for package qountstat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qountstat}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CP.hypotheses'><p>CP hypotheses</p></a></li>
<li><a href='#CPCAT'><p>CPCAT</p></a></li>
<li><a href='#CPCAT.bMDD'><p>CPCAT bootstrap MDD (bMDD)</p></a></li>
<li><a href='#CPCAT.Poisson.sub.test'><p>CPCAT Poisson sub-test</p></a></li>
<li><a href='#CPCAT.Poisson.test'><p>CPCAT Poisson test</p></a></li>
<li><a href='#CPCAT.power'><p>CPCAT power</p></a></li>
<li><a href='#CPFISH'><p>CPFISH</p></a></li>
<li><a href='#CPFISH.bMDD'><p>CPFISH bootstrap MDD (bMDD)</p></a></li>
<li><a href='#CPFISH.contingency.table'><p>CPFISH.contingency.table is a dataset to showcase analyses with CPFISH</p></a></li>
<li><a href='#CPFISH.power'><p>CPFISH power</p></a></li>
<li><a href='#Daphnia.counts'><p>Daphnia.counts is a dataset to showcase analyses with CPCAT and Dunnett.GLM</p></a></li>
<li><a href='#Dunnett.GLM'><p>Dunnett.GLM</p></a></li>
<li><a href='#Dunnett.GLM.bMDD'><p>Dunnett.GLM bootstrap MDD (bMDD)</p></a></li>
<li><a href='#Dunnett.GLM.power'><p>Dunnett.GLM power</p></a></li>
<li><a href='#Multi.group.test.bMDD'><p>Multi-group test bMDD</p></a></li>
<li><a href='#Multi.group.test.power'><p>Multi-group test power</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Analysis of Count Data and Quantal Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Benjamin Daniels &lt;Benjamin.Daniels@uba.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for statistical analysis of count data and quantal data.
    For the analysis of count data an implementation of the Closure Principle Computational Approach Test ("CPCAT") is provided (Lehmann, R et al. (2016) &lt;<a href="https://doi.org/10.1007%2Fs00477-015-1079-4">doi:10.1007/s00477-015-1079-4</a>&gt;), as well as an implementation of a "Dunnett GLM" approach using a Quasi-Poisson regression (Hothorn, L, Kluxen, F (2020) &lt;<a href="https://doi.org/10.1101%2F2020.01.15.907881">doi:10.1101/2020.01.15.907881</a>&gt;).
    For the analysis of quantal data an implementation of the Closure Principle Fisher–Freeman–Halton test ("CPFISH") is provided (Lehmann, R et al. (2018) &lt;<a href="https://doi.org/10.1007%2Fs00477-017-1392-1">doi:10.1007/s00477-017-1392-1</a>&gt;). P-values and no/lowest observed (adverse) effect concentration values are calculated.
    All implemented methods include further functions to evaluate the power and the minimum detectable difference using a bootstrapping approach.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>multcomp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-20 12:23:17 UTC; Benni Daniels</td>
</tr>
<tr>
<td>Author:</td>
<td>Benjamin Daniels <a href="https://orcid.org/0000-0002-8344-6141"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, ctb],
  Christian Dietrich [aut],
  Thomas Graeff [ctb],
  Magnus Wang [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-21 11:30:25 UTC</td>
</tr>
</table>
<hr>
<h2 id='CP.hypotheses'>CP hypotheses</h2><span id='topic+CP.hypotheses'></span>

<h3>Description</h3>

<p>Function to generate hypotheses for the Closure Principle concept using 0/1 contrast matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CP.hypotheses(n, treatment.names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CP.hypotheses_+3A_n">n</code></td>
<td>
<p>Number of groups</p>
</td></tr>
<tr><td><code id="CP.hypotheses_+3A_treatment.names">treatment.names</code></td>
<td>
<p>Optional vector with names of treatment groups</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Contrast matrix (all 0/1 combinations)
</p>

<hr>
<h2 id='CPCAT'>CPCAT</h2><span id='topic+CPCAT'></span>

<h3>Description</h3>

<p>When conducting statistical tests with multiple treatments, such as a control group and
increasing concentrations of a test substance, ANOVA and parametric post-hoc tests (e.g. Dunnett's test)
are commonly used. However, these tests require the assumptions of homogeneous variances and normally
distributed data. For count data (e.g. counts of animals), these assumptions are typically violated,
as the data are usually Poisson-distributed. Additionally, multiple testing using post-hoc tests can
lead to alpha-inflation. To address these issues, CPCAT was proposed by Lehmann et al. (2016). CPCAT has
two components. The first is the Closure Principle (CP) developed by Bretz et al. (2010), which aims
to eliminate alpha-inflation. CP applies a stepwise approach to identify at which concentration effects
begin to occur. The second part of CPCAT is the actual significance test, CAT (Computational Approach
Test; introduced by Chang et al., 2010), which uses a test based on the Poisson distribution rather
than a parametric test based on normal distribution assumptions. For details on the structure of the
input data, please refer to the dataset 'Daphnia.counts' provided alongside this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CPCAT(
  groups,
  counts,
  control.name = NULL,
  bootstrap.runs = 10000,
  hampel.threshold = 5,
  use.fixed.random.seed = NULL,
  get.contrasts.and.p.values = FALSE,
  show.output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CPCAT_+3A_groups">groups</code></td>
<td>
<p>Group vector</p>
</td></tr>
<tr><td><code id="CPCAT_+3A_counts">counts</code></td>
<td>
<p>Vector with count data</p>
</td></tr>
<tr><td><code id="CPCAT_+3A_control.name">control.name</code></td>
<td>
<p>Character string with control group name (optional)</p>
</td></tr>
<tr><td><code id="CPCAT_+3A_bootstrap.runs">bootstrap.runs</code></td>
<td>
<p>Number of bootstrap runs</p>
</td></tr>
<tr><td><code id="CPCAT_+3A_hampel.threshold">hampel.threshold</code></td>
<td>
<p>Threshold for Hampel identifier (measure for over-/underdispersion)</p>
</td></tr>
<tr><td><code id="CPCAT_+3A_use.fixed.random.seed">use.fixed.random.seed</code></td>
<td>
<p>Use fixed seed, e.g. 123, for reproducible results. If NULL no seed is set.</p>
</td></tr>
<tr><td><code id="CPCAT_+3A_get.contrasts.and.p.values">get.contrasts.and.p.values</code></td>
<td>
<p>Get each row of the contrast matrices evaluated</p>
</td></tr>
<tr><td><code id="CPCAT_+3A_show.output">show.output</code></td>
<td>
<p>Show/hide output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>R object with results and information from CPCAT calculations
</p>


<h3>References</h3>

<p>Bretz, F.; Hothorn, T.; Westfall, P. (2010): Multiple comparisons using R. 1st Edition, Chapman and Hall/CRC, New York
</p>
<p>Chang, C.-H.; Pal, N.; Lin, J.-J. (2010): A Note on Comparing Several Poisson Means. In: Commun. Stat. Simul. Comput., 2010, 39(8), p. 1605-1627, https://doi.org/10.1080/03610918.2010.508860
</p>
<p>Lehmann, R.; Bachmann, J.; Maletzki, D.; Polleichtner, C.; Ratte, H.; Ratte, M. (2016): A new approach to overcome shortcomings with multiple testing of reproduction data in ecotoxicology. In: Stochastic Environmental Research and Risk Assessment, 2016, 30(3), p. 871-882, https://doi.org/10.1007/s00477-015-1079-4
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Daphnia.counts	# example data provided alongside the package

# Test CPCAT
CPCAT(groups = Daphnia.counts$Concentration,
	 counts = Daphnia.counts$Number_Young,
	 control.name = NULL,
	 bootstrap.runs = 10000,
	 use.fixed.random.seed = 123,  #fixed seed for reproducible results
	 get.contrasts.and.p.values = FALSE,
	 show.output = TRUE)
</code></pre>

<hr>
<h2 id='CPCAT.bMDD'>CPCAT bootstrap MDD (bMDD)</h2><span id='topic+CPCAT.bMDD'></span>

<h3>Description</h3>

<p>The basic idea of the calculation of bootstrap MDD (bMDD) using the CPCAT approach
is to shift the lambda parameter of Poisson distribution until there is a certain proportion of
results significantly different from the control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CPCAT.bMDD(
  groups,
  counts,
  control.name = NULL,
  alpha = 0.05,
  shift.step = -0.25,
  bootstrap.runs = 200,
  power = 0.8,
  max.iterations = 1000,
  use.fixed.random.seed = NULL,
  CPCAT.bootstrap.runs = 200,
  show.progress = TRUE,
  show.results = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CPCAT.bMDD_+3A_groups">groups</code></td>
<td>
<p>Group vector</p>
</td></tr>
<tr><td><code id="CPCAT.bMDD_+3A_counts">counts</code></td>
<td>
<p>Vector with count data</p>
</td></tr>
<tr><td><code id="CPCAT.bMDD_+3A_control.name">control.name</code></td>
<td>
<p>Character string with control group name (optional)</p>
</td></tr>
<tr><td><code id="CPCAT.bMDD_+3A_alpha">alpha</code></td>
<td>
<p>Significance level</p>
</td></tr>
<tr><td><code id="CPCAT.bMDD_+3A_shift.step">shift.step</code></td>
<td>
<p>Step of shift (negative as a reduction is assumed)</p>
</td></tr>
<tr><td><code id="CPCAT.bMDD_+3A_bootstrap.runs">bootstrap.runs</code></td>
<td>
<p>Number of bootstrap runs</p>
</td></tr>
<tr><td><code id="CPCAT.bMDD_+3A_power">power</code></td>
<td>
<p>Proportion of bootstrap.runs that return significant differences</p>
</td></tr>
<tr><td><code id="CPCAT.bMDD_+3A_max.iterations">max.iterations</code></td>
<td>
<p>Max. number of iterations to not get stuck in the while loop</p>
</td></tr>
<tr><td><code id="CPCAT.bMDD_+3A_use.fixed.random.seed">use.fixed.random.seed</code></td>
<td>
<p>Use fixed seed, e.g. 123, for reproducible results. If NULL no seed is set.</p>
</td></tr>
<tr><td><code id="CPCAT.bMDD_+3A_cpcat.bootstrap.runs">CPCAT.bootstrap.runs</code></td>
<td>
<p>Bootstrap runs within CPCAT method</p>
</td></tr>
<tr><td><code id="CPCAT.bMDD_+3A_show.progress">show.progress</code></td>
<td>
<p>Show progress for each shift of lambda</p>
</td></tr>
<tr><td><code id="CPCAT.bMDD_+3A_show.results">show.results</code></td>
<td>
<p>Show results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with results from bMDD analysis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Daphnia.counts	# example data provided alongside the package

# Test CPCAT bootstrap MDD
CPCAT.bMDD(groups = Daphnia.counts$Concentration,
		  counts = Daphnia.counts$Number_Young,
		  control.name = NULL,
		  alpha = 0.05,
		  shift.step = -1,		# Caution: big step size for testing
		  bootstrap.runs = 5,	# Caution: low number of bootstrap runs for testing
		  power = 0.8,
		  max.iterations = 1000,
		  use.fixed.random.seed = 123,  #fixed seed for reproducible results
		  CPCAT.bootstrap.runs = 10,
		  show.progress = TRUE,
		  show.results = TRUE)

</code></pre>

<hr>
<h2 id='CPCAT.Poisson.sub.test'>CPCAT Poisson sub-test</h2><span id='topic+CPCAT.Poisson.sub.test'></span>

<h3>Description</h3>

<p>Helper function for CPCAT
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CPCAT.Poisson.sub.test(dat, contrast, bootstrap.runs = 10000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CPCAT.Poisson.sub.test_+3A_dat">dat</code></td>
<td>
<p>Data frame to be evaluated</p>
</td></tr>
<tr><td><code id="CPCAT.Poisson.sub.test_+3A_contrast">contrast</code></td>
<td>
<p>Contrast matrix</p>
</td></tr>
<tr><td><code id="CPCAT.Poisson.sub.test_+3A_bootstrap.runs">bootstrap.runs</code></td>
<td>
<p>Number of bootstrap runs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p-value for tested data and contrast
</p>

<hr>
<h2 id='CPCAT.Poisson.test'>CPCAT Poisson test</h2><span id='topic+CPCAT.Poisson.test'></span>

<h3>Description</h3>

<p>Helper function for CPCAT
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CPCAT.Poisson.test(dat, contrastmatrix, bootstrap.runs = 10000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CPCAT.Poisson.test_+3A_dat">dat</code></td>
<td>
<p>Data frame to be evaluated</p>
</td></tr>
<tr><td><code id="CPCAT.Poisson.test_+3A_contrastmatrix">contrastmatrix</code></td>
<td>
<p>Contrast matrix</p>
</td></tr>
<tr><td><code id="CPCAT.Poisson.test_+3A_bootstrap.runs">bootstrap.runs</code></td>
<td>
<p>Number of bootstrap runs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of p-values for tested contrast matrices
</p>

<hr>
<h2 id='CPCAT.power'>CPCAT power</h2><span id='topic+CPCAT.power'></span>

<h3>Description</h3>

<p>The basic idea of CPCAT power calculations is to do parametric bootstrapping
for each dose/concentration group and to evaluate the proportion of results significantly different from the control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CPCAT.power(
  groups,
  counts,
  control.name = NULL,
  alpha = 0.05,
  bootstrap.runs = 200,
  use.fixed.random.seed = NULL,
  CPCAT.bootstrap.runs = 200,
  show.progress = TRUE,
  show.results = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CPCAT.power_+3A_groups">groups</code></td>
<td>
<p>Group vector</p>
</td></tr>
<tr><td><code id="CPCAT.power_+3A_counts">counts</code></td>
<td>
<p>Vector with count data</p>
</td></tr>
<tr><td><code id="CPCAT.power_+3A_control.name">control.name</code></td>
<td>
<p>Character string with control group name (optional)</p>
</td></tr>
<tr><td><code id="CPCAT.power_+3A_alpha">alpha</code></td>
<td>
<p>Significance level</p>
</td></tr>
<tr><td><code id="CPCAT.power_+3A_bootstrap.runs">bootstrap.runs</code></td>
<td>
<p>Number of bootstrap runs</p>
</td></tr>
<tr><td><code id="CPCAT.power_+3A_use.fixed.random.seed">use.fixed.random.seed</code></td>
<td>
<p>Use fixed seed, e.g. 123, for reproducible results. If NULL no seed is set.</p>
</td></tr>
<tr><td><code id="CPCAT.power_+3A_cpcat.bootstrap.runs">CPCAT.bootstrap.runs</code></td>
<td>
<p>Bootstrap runs within CPCAT method</p>
</td></tr>
<tr><td><code id="CPCAT.power_+3A_show.progress">show.progress</code></td>
<td>
<p>Show progress for each shift of lambda</p>
</td></tr>
<tr><td><code id="CPCAT.power_+3A_show.results">show.results</code></td>
<td>
<p>Show results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with results from power analysis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Daphnia.counts	# example data provided alongside the package

# Test CPCAT power
CPCAT.power(groups = Daphnia.counts$Concentration,
		   counts = Daphnia.counts$Number_Young,
		   control.name = NULL,
		   alpha = 0.05,
		   bootstrap.runs = 10,		# Caution: low number of bootstrap runs for testing
		   use.fixed.random.seed = 123,  #fixed seed for reproducible results
		   CPCAT.bootstrap.runs = 10,# Caution: low number of bootstrap runs for testing
		   show.progress = TRUE,
		   show.results = TRUE)
</code></pre>

<hr>
<h2 id='CPFISH'>CPFISH</h2><span id='topic+CPFISH'></span>

<h3>Description</h3>

<p>For quantal data (e.g. survival data, '14 out of 20 animals died') e.g. in the form of
a contingency table, CPFISH was proposed by Lehmann et al. (2018). Like CPCAT, CPFISH is based on
the Closure Principle (CP), but instead of a bootstrapping approach, a Fisher test is performed for
all sub-hypotheses to be analyzed. For details on the structure of the input table, please refer to
the dataset 'CPFISH.contingency.table' provided alongside this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CPFISH(
  contingency.table,
  control.name = NULL,
  simulate.p.value = TRUE,
  use.fixed.random.seed = NULL,
  show.output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CPFISH_+3A_contingency.table">contingency.table</code></td>
<td>
<p>Matrix with observed data (e.g. survival counts, survival must be in first row)</p>
</td></tr>
<tr><td><code id="CPFISH_+3A_control.name">control.name</code></td>
<td>
<p>Character string with control group name (optional)</p>
</td></tr>
<tr><td><code id="CPFISH_+3A_simulate.p.value">simulate.p.value</code></td>
<td>
<p>Use simulated p-values in Fisher test or not</p>
</td></tr>
<tr><td><code id="CPFISH_+3A_use.fixed.random.seed">use.fixed.random.seed</code></td>
<td>
<p>Use fixed seed, e.g. 123, for reproducible results. If NULL no seed is set.</p>
</td></tr>
<tr><td><code id="CPFISH_+3A_show.output">show.output</code></td>
<td>
<p>Show/hide output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>R object with results and information from CPFISH calculations
</p>


<h3>References</h3>

<p>Lehmann, R.; Bachmann, J.; Karaoglan, B.; Lacker, J.; Polleichtner, C.; Ratte, H.; Ratte, M. (2018): An alternative approach to overcome shortcomings with multiple testing of binary data in ecotoxicology. In: Stochastic Environmental Research and Risk Assessment, 2018, 32(1), p. 213-222, https://doi.org/10.1007/s00477-017-1392-1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CPFISH.contingency.table	# example data provided alongside the package

# Test CPFISH
CPFISH(contingency.table = CPFISH.contingency.table,
		control.name = NULL,
		simulate.p.value = TRUE,
		use.fixed.random.seed = 123,  #fixed seed for reproducible results
		show.output = TRUE)
</code></pre>

<hr>
<h2 id='CPFISH.bMDD'>CPFISH bootstrap MDD (bMDD)</h2><span id='topic+CPFISH.bMDD'></span>

<h3>Description</h3>

<p>The basic idea of the calculation of bootstrap MDD (bMDD) using the CPCAT approach
is to shift the probability of binomial distribution until there is a certain proportion of
results significantly different from the control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CPFISH.bMDD(
  contingency.table,
  control.name = NULL,
  alpha = 0.05,
  shift.step = -0.01,
  bootstrap.runs = 200,
  power = 0.8,
  max.iterations = 1000,
  simulate.p.value = TRUE,
  use.fixed.random.seed = NULL,
  show.progress = TRUE,
  show.results = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CPFISH.bMDD_+3A_contingency.table">contingency.table</code></td>
<td>
<p>Matrix with observed data (e.g. survival counts, survival must be in first row)</p>
</td></tr>
<tr><td><code id="CPFISH.bMDD_+3A_control.name">control.name</code></td>
<td>
<p>Character string with control group name (optional)</p>
</td></tr>
<tr><td><code id="CPFISH.bMDD_+3A_alpha">alpha</code></td>
<td>
<p>Significance level</p>
</td></tr>
<tr><td><code id="CPFISH.bMDD_+3A_shift.step">shift.step</code></td>
<td>
<p>Step of shift (negative as a reduction is assumed)</p>
</td></tr>
<tr><td><code id="CPFISH.bMDD_+3A_bootstrap.runs">bootstrap.runs</code></td>
<td>
<p>Number of bootstrap runs (draw Poisson data n times)</p>
</td></tr>
<tr><td><code id="CPFISH.bMDD_+3A_power">power</code></td>
<td>
<p>Proportion of bootstrap.runs that return significant differences</p>
</td></tr>
<tr><td><code id="CPFISH.bMDD_+3A_max.iterations">max.iterations</code></td>
<td>
<p>Max. number of iterations to not get stuck in the while loop</p>
</td></tr>
<tr><td><code id="CPFISH.bMDD_+3A_simulate.p.value">simulate.p.value</code></td>
<td>
<p>Use simulated p-values in Fisher test or not</p>
</td></tr>
<tr><td><code id="CPFISH.bMDD_+3A_use.fixed.random.seed">use.fixed.random.seed</code></td>
<td>
<p>Use fixed seed, e.g. 123, for reproducible results. If NULL no seed is set.</p>
</td></tr>
<tr><td><code id="CPFISH.bMDD_+3A_show.progress">show.progress</code></td>
<td>
<p>Show progress for each shift of the probability</p>
</td></tr>
<tr><td><code id="CPFISH.bMDD_+3A_show.results">show.results</code></td>
<td>
<p>Show results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with results from bMDD analysis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CPFISH.contingency.table	# example data provided alongside the package

# Test CPFISH bootstrap MDD
CPFISH.bMDD(contingency.table = CPFISH.contingency.table,
		   control.name = NULL,
		   alpha = 0.05,
		   shift.step = -0.1,		# Caution: big step size for testing
		   bootstrap.runs = 10,		# Caution: low number of bootstrap runs for testing
		   power = 0.8,
		   max.iterations = 1000,
		   simulate.p.value = TRUE,
		   use.fixed.random.seed = 123,  #fixed seed for reproducible results
		   show.progress = TRUE,
		   show.results = TRUE)
</code></pre>

<hr>
<h2 id='CPFISH.contingency.table'>CPFISH.contingency.table is a dataset to showcase analyses with CPFISH</h2><span id='topic+CPFISH.contingency.table'></span>

<h3>Description</h3>

<p>CPFISH.contingency.table is a dataset to showcase analyses with CPFISH
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CPFISH.contingency.table
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 2 rows and 3 columns.
</p>


<h3>Source</h3>

<p>The CPFISH data was artificially created.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CPFISH.contingency.table)
</code></pre>

<hr>
<h2 id='CPFISH.power'>CPFISH power</h2><span id='topic+CPFISH.power'></span>

<h3>Description</h3>

<p>The basic idea of CPFISH power calculations is to do parametric bootstrapping
for each dose/concentration group and to evaluate the proportion of results significantly different from the control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CPFISH.power(
  contingency.table,
  control.name = NULL,
  alpha = 0.05,
  bootstrap.runs = 200,
  simulate.p.value = TRUE,
  use.fixed.random.seed = NULL,
  show.progress = TRUE,
  show.results = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CPFISH.power_+3A_contingency.table">contingency.table</code></td>
<td>
<p>Matrix with observed data (e.g. survival counts, survival must be in first row)</p>
</td></tr>
<tr><td><code id="CPFISH.power_+3A_control.name">control.name</code></td>
<td>
<p>Character string with control group name (optional)</p>
</td></tr>
<tr><td><code id="CPFISH.power_+3A_alpha">alpha</code></td>
<td>
<p>Significance level</p>
</td></tr>
<tr><td><code id="CPFISH.power_+3A_bootstrap.runs">bootstrap.runs</code></td>
<td>
<p>Number of bootstrap runs (draw Poisson data n times)</p>
</td></tr>
<tr><td><code id="CPFISH.power_+3A_simulate.p.value">simulate.p.value</code></td>
<td>
<p>Use simulated p-values in Fisher test or not</p>
</td></tr>
<tr><td><code id="CPFISH.power_+3A_use.fixed.random.seed">use.fixed.random.seed</code></td>
<td>
<p>Use fixed seed, e.g. 123, for reproducible results. If NULL no seed is set.</p>
</td></tr>
<tr><td><code id="CPFISH.power_+3A_show.progress">show.progress</code></td>
<td>
<p>Show progress for each shift of the probability</p>
</td></tr>
<tr><td><code id="CPFISH.power_+3A_show.results">show.results</code></td>
<td>
<p>Show results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with results from power analysis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CPFISH.contingency.table	# example data provided alongside the package

# Test CPFISH power
CPFISH.power(contingency.table = CPFISH.contingency.table,
			control.name = NULL,
			alpha = 0.05,
			bootstrap.runs = 10,	# Caution: low number of bootstrap runs for testing
			simulate.p.value = TRUE,
			use.fixed.random.seed = 123,  #fixed seed for reproducible results
			show.progress = TRUE,
			show.results = TRUE)
</code></pre>

<hr>
<h2 id='Daphnia.counts'>Daphnia.counts is a dataset to showcase analyses with CPCAT and Dunnett.GLM</h2><span id='topic+Daphnia.counts'></span>

<h3>Description</h3>

<p>Daphnia.counts is a dataset to showcase analyses with CPCAT and Dunnett.GLM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Daphnia.counts
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 60 rows and 3 columns.
</p>


<h3>Source</h3>

<p>The daphnia data was taken from Hothorn and Kluxen (2020).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Daphnia.counts)
</code></pre>

<hr>
<h2 id='Dunnett.GLM'>Dunnett.GLM</h2><span id='topic+Dunnett.GLM'></span>

<h3>Description</h3>

<p>When conducting statistical tests with multiple treatments, such as a control group and
increasing concentrations of a test substance, ANOVA and parametric post-hoc tests (e.g. Dunnett's test)
are commonly used. However, these tests require the assumptions of homogeneous variances and normally
distributed data. For count data (e.g. counts of animals), these assumptions are typically violated,
as the data are usually Poisson-distributed. The Dunnett.GLM function is based on a GLM followed by a
Dunnett test to the model estimates. It was implemented to serve as an alternative approach to CPCAT
while using a Quasi-Poisson regression.
The basic approach from Hothorn and Kluxen (2020) was adjusted to overcome methodological issues (see
description of 'zero.treatment.action parameter').
For details on the structure of the input data, please refer to the dataset 'Daphnia.counts' provided
alongside this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dunnett.GLM(
  groups,
  counts,
  control.name = NULL,
  zero.treatment.action = "identity.link",
  show.output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Dunnett.GLM_+3A_groups">groups</code></td>
<td>
<p>Group vector</p>
</td></tr>
<tr><td><code id="Dunnett.GLM_+3A_counts">counts</code></td>
<td>
<p>Vector with count data</p>
</td></tr>
<tr><td><code id="Dunnett.GLM_+3A_control.name">control.name</code></td>
<td>
<p>Character string with control group name (optional)</p>
</td></tr>
<tr><td><code id="Dunnett.GLM_+3A_zero.treatment.action">zero.treatment.action</code></td>
<td>
<p>Method for dealing with treatments only containing zeros (use either
&quot;identity.link&quot; or &quot;log(x+1)&quot;). The method is only used if the data set contains dose/concentration
groups that exclusively contain zero values (since the basic method provides for a logarithmic
transformation of the data averages, it would lead to incorrect results). To deal with this
methodological shortcoming, two options were implemented. The 'identity.link' option: the 'identity'
link is used in the GLM instead of the 'log' link, i.e. the data are no longer transformed. The 'log(x+1)'
option: The 'log' link is retained and 1 is added to each count value at the start of the procedure so
that the subsequent log-transformation can be carried out without any problems. Note that both options
may slightly distort the results.</p>
</td></tr>
<tr><td><code id="Dunnett.GLM_+3A_show.output">show.output</code></td>
<td>
<p>Show/hide output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>R object with results and information from Dunnett.GLM calculations
</p>


<h3>References</h3>

<p>Hothorn, L.; Kluxen, F. (2020): Statistical analysis of no observed effect concentrations or levels in eco-toxicological assays with overdispersed count endpoints. In: bioRxiv, 2020, https://doi.org/10.1101/2020.01.15.907881
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Daphnia.counts	# example data provided alongside the package

# Test Dunnett.GLM with 'identity.link' option
Dunnett.GLM(groups = Daphnia.counts$Concentration,
			   counts = Daphnia.counts$Number_Young,
			   control.name = NULL,
			   zero.treatment.action = "identity.link",
			   show.output = TRUE)

# Test Dunnett.GLM with 'log(x+1)' option
Dunnett.GLM(groups = Daphnia.counts$Concentration,
		   counts = Daphnia.counts$Number_Young,
		   control.name = NULL,
		   zero.treatment.action = "log(x+1)",
		   show.output = TRUE)
</code></pre>

<hr>
<h2 id='Dunnett.GLM.bMDD'>Dunnett.GLM bootstrap MDD (bMDD)</h2><span id='topic+Dunnett.GLM.bMDD'></span>

<h3>Description</h3>

<p>The basic idea of the calculation of bootstrap MDD (bMDD) using the Dunnett.GLM approach
is to shift the lambda parameter of Poisson distribution until there is a certain proportion of
results significantly different from the control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dunnett.GLM.bMDD(
  groups,
  counts,
  control.name = NULL,
  alpha = 0.05,
  shift.step = -0.25,
  bootstrap.runs = 200,
  power = 0.8,
  max.iterations = 1000,
  use.fixed.random.seed = NULL,
  Dunnett.GLM.zero.treatment.action = "log(x+1)",
  show.progress = TRUE,
  show.results = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Dunnett.GLM.bMDD_+3A_groups">groups</code></td>
<td>
<p>Group vector</p>
</td></tr>
<tr><td><code id="Dunnett.GLM.bMDD_+3A_counts">counts</code></td>
<td>
<p>Vector with count data</p>
</td></tr>
<tr><td><code id="Dunnett.GLM.bMDD_+3A_control.name">control.name</code></td>
<td>
<p>Character string with control group name (optional)</p>
</td></tr>
<tr><td><code id="Dunnett.GLM.bMDD_+3A_alpha">alpha</code></td>
<td>
<p>Significance level</p>
</td></tr>
<tr><td><code id="Dunnett.GLM.bMDD_+3A_shift.step">shift.step</code></td>
<td>
<p>Step of shift (negative as a reduction is assumed)</p>
</td></tr>
<tr><td><code id="Dunnett.GLM.bMDD_+3A_bootstrap.runs">bootstrap.runs</code></td>
<td>
<p>Number of bootstrap runs</p>
</td></tr>
<tr><td><code id="Dunnett.GLM.bMDD_+3A_power">power</code></td>
<td>
<p>Proportion of bootstrap.runs that return significant differences</p>
</td></tr>
<tr><td><code id="Dunnett.GLM.bMDD_+3A_max.iterations">max.iterations</code></td>
<td>
<p>Max. number of iterations to not get stuck in the while loop</p>
</td></tr>
<tr><td><code id="Dunnett.GLM.bMDD_+3A_use.fixed.random.seed">use.fixed.random.seed</code></td>
<td>
<p>Use fixed seed, e.g. 123, for reproducible results. If NULL no seed is set.</p>
</td></tr>
<tr><td><code id="Dunnett.GLM.bMDD_+3A_dunnett.glm.zero.treatment.action">Dunnett.GLM.zero.treatment.action</code></td>
<td>
<p>Dunnett.GLM method to be used for treatments only containing zeros</p>
</td></tr>
<tr><td><code id="Dunnett.GLM.bMDD_+3A_show.progress">show.progress</code></td>
<td>
<p>Show progress for each shift of lambda</p>
</td></tr>
<tr><td><code id="Dunnett.GLM.bMDD_+3A_show.results">show.results</code></td>
<td>
<p>Show results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with results from bMDD analysis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Daphnia.counts	# example data provided alongside the package

# Test Dunnett.GLM bootstrap MDD
Dunnett.GLM.bMDD(groups = Daphnia.counts$Concentration,
	counts = Daphnia.counts$Number_Young,
	control.name = NULL,
	alpha = 0.05,
	shift.step = -1,		# Caution: big step size for testing
	bootstrap.runs = 5,	# Caution: low number of bootstrap runs for testing
	power = 0.8,
	max.iterations = 1000,
	use.fixed.random.seed = 123,  #fixed seed for reproducible results
	Dunnett.GLM.zero.treatment.action = "log(x+1)",
	show.progress = TRUE,
	show.results = TRUE)
</code></pre>

<hr>
<h2 id='Dunnett.GLM.power'>Dunnett.GLM power</h2><span id='topic+Dunnett.GLM.power'></span>

<h3>Description</h3>

<p>The basic idea of Dunnett.GLM power calculations is to do parametric bootstrapping
for each dose/concentration group and to evaluate the proportion of results significantly different from the control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dunnett.GLM.power(
  groups,
  counts,
  control.name = NULL,
  alpha = 0.05,
  bootstrap.runs = 200,
  use.fixed.random.seed = NULL,
  Dunnett.GLM.zero.treatment.action = "log(x+1)",
  show.progress = TRUE,
  show.results = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Dunnett.GLM.power_+3A_groups">groups</code></td>
<td>
<p>Group vector</p>
</td></tr>
<tr><td><code id="Dunnett.GLM.power_+3A_counts">counts</code></td>
<td>
<p>Vector with count data</p>
</td></tr>
<tr><td><code id="Dunnett.GLM.power_+3A_control.name">control.name</code></td>
<td>
<p>Character string with control group name (optional)</p>
</td></tr>
<tr><td><code id="Dunnett.GLM.power_+3A_alpha">alpha</code></td>
<td>
<p>Significance level</p>
</td></tr>
<tr><td><code id="Dunnett.GLM.power_+3A_bootstrap.runs">bootstrap.runs</code></td>
<td>
<p>Number of bootstrap runs</p>
</td></tr>
<tr><td><code id="Dunnett.GLM.power_+3A_use.fixed.random.seed">use.fixed.random.seed</code></td>
<td>
<p>Use fixed seed, e.g. 123, for reproducible results. If NULL no seed is set.</p>
</td></tr>
<tr><td><code id="Dunnett.GLM.power_+3A_dunnett.glm.zero.treatment.action">Dunnett.GLM.zero.treatment.action</code></td>
<td>
<p>GLM.Dunnett method to be used for treatments only containing zeros</p>
</td></tr>
<tr><td><code id="Dunnett.GLM.power_+3A_show.progress">show.progress</code></td>
<td>
<p>Show progress for each shift of lambda</p>
</td></tr>
<tr><td><code id="Dunnett.GLM.power_+3A_show.results">show.results</code></td>
<td>
<p>Show results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with results from power analysis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Daphnia.counts	# example data provided alongside the package

# Test Dunnett.GLM power
Dunnett.GLM.power(groups = Daphnia.counts$Concentration,
	counts = Daphnia.counts$Number_Young,
	control.name = NULL,
	alpha = 0.05,
	bootstrap.runs = 10,	# Caution: low number of bootstrap runs for testing
	use.fixed.random.seed = 123,  #fixed seed for reproducible results
	Dunnett.GLM.zero.treatment.action = "log(x+1)",
	show.progress = TRUE,
	show.results = TRUE)
</code></pre>

<hr>
<h2 id='Multi.group.test.bMDD'>Multi-group test bMDD</h2><span id='topic+Multi.group.test.bMDD'></span>

<h3>Description</h3>

<p>Idea: shift lambda of Poisson distribution until there is a certain proportion of significant results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Multi.group.test.bMDD(
  groups,
  counts,
  control.name = NULL,
  alpha = 0.05,
  shift.step = -0.25,
  bootstrap.runs = 200,
  power = 0.8,
  max.iterations = 1000,
  use.fixed.random.seed = NULL,
  CPCAT.bootstrap.runs = 200,
  Dunnett.GLM.zero.treatment.action = "log(x+1)",
  show.progress = TRUE,
  show.results = TRUE,
  get.effect.and.power = FALSE,
  use.CMP.distribution = FALSE,
  CMP.dispersion.factor = 1,
  test = "CPCAT"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Multi.group.test.bMDD_+3A_groups">groups</code></td>
<td>
<p>Group vector</p>
</td></tr>
<tr><td><code id="Multi.group.test.bMDD_+3A_counts">counts</code></td>
<td>
<p>Vector with count data</p>
</td></tr>
<tr><td><code id="Multi.group.test.bMDD_+3A_control.name">control.name</code></td>
<td>
<p>Character string with control group name (optional)</p>
</td></tr>
<tr><td><code id="Multi.group.test.bMDD_+3A_alpha">alpha</code></td>
<td>
<p>Significance level</p>
</td></tr>
<tr><td><code id="Multi.group.test.bMDD_+3A_shift.step">shift.step</code></td>
<td>
<p>Step of shift (negative as a reduction is assumed)</p>
</td></tr>
<tr><td><code id="Multi.group.test.bMDD_+3A_bootstrap.runs">bootstrap.runs</code></td>
<td>
<p>Number of bootstrap runs</p>
</td></tr>
<tr><td><code id="Multi.group.test.bMDD_+3A_power">power</code></td>
<td>
<p>Proportion of bootstrap.runs that return significant differences</p>
</td></tr>
<tr><td><code id="Multi.group.test.bMDD_+3A_max.iterations">max.iterations</code></td>
<td>
<p>Max. number of iterations to not get stuck in the while loop</p>
</td></tr>
<tr><td><code id="Multi.group.test.bMDD_+3A_use.fixed.random.seed">use.fixed.random.seed</code></td>
<td>
<p>Use fixed seed, e.g. 123, for reproducible results. If NULL no seed is set.</p>
</td></tr>
<tr><td><code id="Multi.group.test.bMDD_+3A_cpcat.bootstrap.runs">CPCAT.bootstrap.runs</code></td>
<td>
<p>Bootstrap runs within CPCAT method</p>
</td></tr>
<tr><td><code id="Multi.group.test.bMDD_+3A_dunnett.glm.zero.treatment.action">Dunnett.GLM.zero.treatment.action</code></td>
<td>
<p>Dunnett.GLM method to be used for treatments only containing zeros</p>
</td></tr>
<tr><td><code id="Multi.group.test.bMDD_+3A_show.progress">show.progress</code></td>
<td>
<p>Show progress for each shift of lambda</p>
</td></tr>
<tr><td><code id="Multi.group.test.bMDD_+3A_show.results">show.results</code></td>
<td>
<p>Show results</p>
</td></tr>
<tr><td><code id="Multi.group.test.bMDD_+3A_get.effect.and.power">get.effect.and.power</code></td>
<td>
<p>Return effect size (percent of control) and power for each step (only for last treatment)</p>
</td></tr>
<tr><td><code id="Multi.group.test.bMDD_+3A_use.cmp.distribution">use.CMP.distribution</code></td>
<td>
<p>Use Conway-Maxwell-Poisson distribution for sampling</p>
</td></tr>
<tr><td><code id="Multi.group.test.bMDD_+3A_cmp.dispersion.factor">CMP.dispersion.factor</code></td>
<td>
<p>Dispersion parameter phi has to be sqrt(factor) to scale the variance by this factor</p>
</td></tr>
<tr><td><code id="Multi.group.test.bMDD_+3A_test">test</code></td>
<td>
<p>Either &quot;CPCAT&quot; or &quot;GLM.Dunnett&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with results from bMDD analysis
</p>

<hr>
<h2 id='Multi.group.test.power'>Multi-group test power</h2><span id='topic+Multi.group.test.power'></span>

<h3>Description</h3>

<p>Idea: Do parametric bootstrapping for each group and evaluate the proportion of significant results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Multi.group.test.power(
  groups,
  counts,
  control.name = NULL,
  alpha = 0.05,
  bootstrap.runs = 200,
  use.fixed.random.seed = NULL,
  CPCAT.bootstrap.runs = 200,
  Dunnett.GLM.zero.treatment.action = "log(x+1)",
  show.progress = TRUE,
  show.results = TRUE,
  test = "CPCAT"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Multi.group.test.power_+3A_groups">groups</code></td>
<td>
<p>Group vector</p>
</td></tr>
<tr><td><code id="Multi.group.test.power_+3A_counts">counts</code></td>
<td>
<p>Vector with count data</p>
</td></tr>
<tr><td><code id="Multi.group.test.power_+3A_control.name">control.name</code></td>
<td>
<p>Character string with control group name (optional)</p>
</td></tr>
<tr><td><code id="Multi.group.test.power_+3A_alpha">alpha</code></td>
<td>
<p>Significance level</p>
</td></tr>
<tr><td><code id="Multi.group.test.power_+3A_bootstrap.runs">bootstrap.runs</code></td>
<td>
<p>Number of bootstrap runs</p>
</td></tr>
<tr><td><code id="Multi.group.test.power_+3A_use.fixed.random.seed">use.fixed.random.seed</code></td>
<td>
<p>Use fixed seed, e.g. 123, for reproducible results. If NULL no seed is set.</p>
</td></tr>
<tr><td><code id="Multi.group.test.power_+3A_cpcat.bootstrap.runs">CPCAT.bootstrap.runs</code></td>
<td>
<p>Bootstrap runs within CPCAT method</p>
</td></tr>
<tr><td><code id="Multi.group.test.power_+3A_dunnett.glm.zero.treatment.action">Dunnett.GLM.zero.treatment.action</code></td>
<td>
<p>GLM.Dunnett method to be used for treatments only containing zeros</p>
</td></tr>
<tr><td><code id="Multi.group.test.power_+3A_show.progress">show.progress</code></td>
<td>
<p>Show progress for each shift of lambda</p>
</td></tr>
<tr><td><code id="Multi.group.test.power_+3A_show.results">show.results</code></td>
<td>
<p>Show results</p>
</td></tr>
<tr><td><code id="Multi.group.test.power_+3A_test">test</code></td>
<td>
<p>Either &quot;CPCAT&quot; or &quot;GLM.Dunnett&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with results from power analysis
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
