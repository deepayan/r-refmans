<!DOCTYPE html><html lang="en"><head><title>Help for package linbin</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {linbin}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_events'><p>Coerce to an Event Table</p></a></li>
<li><a href='#build_function_call'><p>Build Function Call</p></a></li>
<li><a href='#crop_events'><p>Crop Events</p></a></li>
<li><a href='#cut_events'><p>Cut Events</p></a></li>
<li><a href='#elwha'><p>Elwha River Survey</p></a></li>
<li><a href='#event_coverage'><p>Event Coverage</p></a></li>
<li><a href='#event_gaps'><p>Event Gaps</p></a></li>
<li><a href='#event_midpoints'><p>Event midpoints</p></a></li>
<li><a href='#event_overlaps'><p>Event Overlaps</p></a></li>
<li><a href='#event_range'><p>Event Range</p></a></li>
<li><a href='#events'><p>Event Tables</p></a></li>
<li><a href='#fill_event_gaps'><p>Fill Event Gaps</p></a></li>
<li><a href='#find_intersecting_events'><p>Find Intersecting Events</p></a></li>
<li><a href='#fishmotion'><p>Fish Movements</p></a></li>
<li><a href='#group_nonoverlapping_events'><p>Overlapping Events</p></a></li>
<li><a href='#if_else'><p>Generalized If Else</p></a></li>
<li><a href='#is_events'><p>Validate Event Table</p></a></li>
<li><a href='#is_not_integer'><p>Not Integers</p></a></li>
<li><a href='#netmap'><p>Dungeness River (NetMap)</p></a></li>
<li><a href='#plot_events'><p>Plot Events as Bar Plots</p></a></li>
<li><a href='#plot_events_single'><p>Plot Events as Bars</p></a></li>
<li><a href='#quinault'><p>Quinault River Survey</p></a></li>
<li><a href='#read_events'><p>Read File as Event Table</p></a></li>
<li><a href='#rgrep_exact'><p>Full Name Matching</p></a></li>
<li><a href='#sample_events'><p>Sample Events</p></a></li>
<li><a href='#sampling_functions'><p>Build Sampling Functions</p></a></li>
<li><a href='#seq_events'><p>Generate Sequential Events</p></a></li>
<li><a href='#simple'><p>Simple Event Table</p></a></li>
<li><a href='#sort_events'><p>Sorted Events</p></a></li>
<li><a href='#to_date'><p>Convert event endpoints to dates</p></a></li>
<li><a href='#to_datetime'><p>Convert event endpoints to date-times</p></a></li>
<li><a href='#transform_events'><p>Transform Events</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-04-16</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.1)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Binning and Plotting of Linearly Referenced Data</td>
</tr>
<tr>
<td>Description:</td>
<td>Short for 'linear binning', the linbin package provides functions
    for manipulating, binning, and plotting linearly referenced data. Although
    developed for data collected on river networks, it can be used with any interval
    or point data referenced to a 1-dimensional coordinate system. Flexible bin
    generation and batch processing makes it easy to compute and visualize variables
    at multiple scales, useful for identifying patterns within and between variables
    and investigating the influence of scale of observation on data interpretation.</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, graphics, grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ezwelty/linbin">https://github.com/ezwelty/linbin</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ezwelty/linbin/issues">https://github.com/ezwelty/linbin/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-04-20 05:23:55 UTC; Admin</td>
</tr>
<tr>
<td>Author:</td>
<td>Ethan Z. Welty [aut, cre],
  Christian E. Torgersen [ctb] (author support and guidance),
  Samuel J. Brenkman [ctb] (elwha and quinault datasets),
  Jeffrey J. Duda [ctb] (elwha dataset),
  Jonathan B. Armstrong [ctb] (fishmotion dataset)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ethan Z. Welty &lt;ethan.welty+linbin@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-04-20 12:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_events'>Coerce to an Event Table</h2><span id='topic+as_events'></span><span id='topic+as_events.numeric'></span><span id='topic+as_events.POSIXt'></span><span id='topic+as_events.Date'></span><span id='topic+as_events.matrix'></span><span id='topic+as_events.data.frame'></span>

<h3>Description</h3>

<p>Attempts to coerce an object to an event table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_events(x, ...)

## S3 method for class 'numeric'
as_events(x, ...)

## S3 method for class 'POSIXt'
as_events(x, ...)

## S3 method for class 'Date'
as_events(x, ...)

## S3 method for class 'matrix'
as_events(x, from.col = 1, to.col = NULL, ...)

## S3 method for class 'data.frame'
as_events(x, from.col = 1, to.col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_events_+3A_x">x</code></td>
<td>
<p>Object to be coerced to an event table.</p>
</td></tr>
<tr><td><code id="as_events_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to or used by methods.</p>
</td></tr>
<tr><td><code id="as_events_+3A_from.col">from.col</code>, <code id="as_events_+3A_to.col">to.col</code></td>
<td>
<p>Names or indices of the columns in <code>x</code> containing the event endpoints. Values are swapped as needed to ensure that <code>to &gt; or = from</code> on all rows. If <code>NULL</code>, <code>to.col</code> defaults to <code>from.col + 1</code> (if column exists) or <code>from.col</code>.</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>numeric</code>: Expands a numeric vector into two columns of event endpoints.
</p>
</li>
<li> <p><code>POSIXt</code>: Coerces to numeric before dispatching.
</p>
</li>
<li> <p><code>Date</code>: Coerces to numeric before dispatching.
</p>
</li>
<li> <p><code>matrix</code>: Converts the matrix to a data frame, then calls the <code>data.frame</code> method.
</p>
</li>
<li> <p><code>data.frame</code>: Renames <code>from.col</code> and <code>to.col</code> to &quot;from&quot; and &quot;to&quot; as needed. Since these column names must be unique, other columns cannot also be called &quot;from&quot; or &quot;to&quot;.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+events">events</a></code> for creating event tables and <code><a href="#topic+read_events">read_events</a></code> for reading files as event tables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_events(1)
as_events(1:5)
as_events(cbind(1:5, 1:5), 1, 2)
as_events(data.frame(x = 1, start = 1:5, stop = 1:5), "start", "stop")
</code></pre>

<hr>
<h2 id='build_function_call'>Build Function Call</h2><span id='topic+build_function_call'></span>

<h3>Description</h3>

<p>Helper function for <code><a href="#topic+sampling_functions">sampling_functions</a></code>. Builds a function call in a enclosed environment with all fixed arguments and column indices so that the function can later be passed row subsets of an event table for sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_function_call(
  fun,
  bin.col,
  data.cols,
  arg.cols = NULL,
  group.cols = NULL,
  arglist = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_function_call_+3A_fun">fun</code></td>
<td>
<p>Function to use.</p>
</td></tr>
<tr><td><code id="build_function_call_+3A_bin.col">bin.col</code></td>
<td>
<p>Column defining the grouping of bins.</p>
</td></tr>
<tr><td><code id="build_function_call_+3A_data.cols">data.cols</code></td>
<td>
<p>Columns to each be passed as first argument to the function.</p>
</td></tr>
<tr><td><code id="build_function_call_+3A_arg.cols">arg.cols</code></td>
<td>
<p>Columns to be passed as the second, third, ... arguments of the function.</p>
</td></tr>
<tr><td><code id="build_function_call_+3A_group.cols">group.cols</code></td>
<td>
<p>Columns to be used as factors.</p>
</td></tr>
<tr><td><code id="build_function_call_+3A_arglist">arglist</code></td>
<td>
<p>Additional arguments to pass to function <code>fun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function whose parent environment encloses all of its fixed arguments.
</p>

<hr>
<h2 id='crop_events'>Crop Events</h2><span id='topic+crop_events'></span>

<h3>Description</h3>

<p>Crops events to the specified intervals. Events are cut at interval endpoints and any whole or partial events lying outside the intervals are removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crop_events(e, crops, scaled.cols = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crop_events_+3A_e">e</code></td>
<td>
<p>An event table.</p>
</td></tr>
<tr><td><code id="crop_events_+3A_crops">crops</code></td>
<td>
<p>An event table specifying the intervals for cropping. Point intervals are allowed, and will create new point events where they intersect the interior, but not the endpoints, of line events.</p>
</td></tr>
<tr><td><code id="crop_events_+3A_scaled.cols">scaled.cols</code></td>
<td>
<p>Names or indices of the columns of the event table to be rescaled after cutting (see <code><a href="#topic+cut_events">cut_events</a></code>). Names are interpreted as regular expressions (<code><a href="base.html#topic+regex">regex</a></code>) matching full column names.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+cut_events">cut_events</a></code> for only cutting events.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e &lt;- events(c(0, 10, 20), c(10, 20, 30), x = 10)
crop_events(e, events(c(0, 15)))
crop_events(e, events(c(0, 5, 15)))
crop_events(e, events(c(0, 5, 15)), scaled.cols = "x")
crop_events(e, events(c(0, 5, 5, 15)), scaled.cols = "x")   # creates new points inside lines
crop_events(e, events(c(0, 10, 10, 15)), scaled.cols = "x") # but not at line event endpoints
</code></pre>

<hr>
<h2 id='cut_events'>Cut Events</h2><span id='topic+cut_events'></span>

<h3>Description</h3>

<p>Cuts events at the specified locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_events(e, cuts, scaled.cols = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cut_events_+3A_e">e</code></td>
<td>
<p>an event table.</p>
</td></tr>
<tr><td><code id="cut_events_+3A_cuts">cuts</code></td>
<td>
<p>the cut locations. Can be either a numeric vector or an event table. If an event table that contains points, point events will be created where they intersect the interior, but not the endpoints, of line events in <code>e</code>.</p>
</td></tr>
<tr><td><code id="cut_events_+3A_scaled.cols">scaled.cols</code></td>
<td>
<p>names or indices of the event table columns to be scaled to their new length after cutting. Names are interpreted as regular expressions (<code><a href="base.html#topic+regex">regex</a></code>) matching full column names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Line events straddling cut locations are cut into multiple event segments. Columns <code>scaled.cols</code> are scaled by the fraction of the original event length in each resulting event (which assumes that these variables were uniformly distributed over the original interval). To have a record of the parents of the resulting event segments, append an unique identification field to the event table before calling this function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crop_events">crop_events</a></code> for both cutting and removing events.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e &lt;- events(c(0, 10, 20), c(10, 20, 30), x = 10)
cut_events(e, events(c(0, 5, 15)))
cut_events(e, events(c(0, 5, 15)), scaled.cols = "x")
cut_events(e, events(c(0, 5, 5, 15)), scaled.cols = "x")   # creates new points inside lines
cut_events(e, events(c(0, 10, 10, 15)), scaled.cols = "x") # but not at line event endpoints
</code></pre>

<hr>
<h2 id='elwha'>Elwha River Survey</h2><span id='topic+elwha'></span>

<h3>Description</h3>

<p>An event table containing the results of a survey of the Elwha River (Washington, USA) carried out in August-September 2008. Both physical variables and fish counts were collected.
</p>


<h3>Format</h3>

<p>A data frame with 249 rows and 33 variables.
</p>


<h3>Details</h3>


<ul>
<li><p> from, to - distance upstream from the river mouth [km]
</p>
</li>
<li><p> unit.length - unit length [m]
</p>
</li>
<li><p> unit.type - unit type (P = pool, GP = glide-like pool, G = glide, GR = glide-like riffle, R = riffle)
</p>
</li>
<li><p> channel.type - channel type (1 = main, 2 = secondary)
</p>
</li>
<li><p> mean.depth - mean depth [m]
</p>
</li>
<li><p> max.depth - max depth [m]
</p>
</li>
<li><p> mean.width - mean wetted width [m]
</p>
</li>
<li><p> bedrock - bedrock substrate [%]
</p>
</li>
<li><p> boulder - boulder substrate [%]
</p>
</li>
<li><p> cobble - cobble substrate [%]
</p>
</li>
<li><p> gravel - gravel substrate [%]
</p>
</li>
<li><p> sand - sand substrate [%]
</p>
</li>
<li><p> silt - silt substrate [%]
</p>
</li>
<li><p> overhang.cover - channel banks with overhanging vegetation [%]
</p>
</li>
<li><p> boulder.cover - channel area covered by boulders [%]
</p>
</li>
<li><p> jams - number of log jams
</p>
</li>
<li><p> jam.area - total area of log jams [m^2]
</p>
</li>
<li><p> SACO.10/20/30/40/total - number of Bull Trout (<em>Salvelinus confluentus</em>) sized 10 - 20 cm / 20 - 30 cm / 30 - 40 cm / &gt; 40 cm / total, respectively.
</p>
</li>
<li><p> ONXX.10/20/30/40/total - number of trout (<em>Oncorhynchus sp.</em>) sized 10 - 20 cm / 20 - 30 cm / 30 - 40 cm / &gt; 40 cm / total, respectively.
</p>
</li>
<li><p> SAFO - number of Brook Trout (<em>Salvelinus fontinalis</em>)
</p>
</li>
<li><p> ONTS - number of Chinook Salmon (<em>Oncorhynchus tshawytscha</em>)
</p>
</li>
<li><p> ONNE - number of Sockeye Salmon (<em>Oncorhynchus nerka</em>)
</p>
</li>
<li><p> LATR - number of Pacific Lamprey (<em>Lampetra tridentata</em>)
</p>
</li>
<li><p> ONKI - number of Coho Salmon (<em>Oncorhynchus kisutch</em>)
</p>
</li></ul>



<h3>Source</h3>

<p>Brenkman, S. J., J. J. Duda, C. E. Torgersen, E. Z. Welty, G. R. Pess, R. Peters, and M. L. McHenry. 2012. A riverscape perspective of Pacific salmonids and aquatic habitats prior to large-scale dam removal in the Elwha River, Washington, USA. Fisheries Management and Ecology 19:36-53. DOI: doi: <a href="https://doi.org/10.1111/j.1365-2400.2011.00815.x">10.1111/j.1365-2400.2011.00815.x</a>
</p>

<hr>
<h2 id='event_coverage'>Event Coverage</h2><span id='topic+event_coverage'></span>

<h3>Description</h3>

<p>Returns the intervals over which the number of events is always one or greater.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>event_coverage(e, closed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="event_coverage_+3A_e">e</code></td>
<td>
<p>An event table.</p>
</td></tr>
<tr><td><code id="event_coverage_+3A_closed">closed</code></td>
<td>
<p>Logical value indicating whether events should be interpreted as closed intervals. If <code>TRUE</code>, coverage is continuous at breaks between two adjacent events.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>closed = TRUE</code>, breaks between adjacent events are dropped. If <code>closed = FALSE</code>, breaks between adjacent events are retained, including point events on line event endpoints. Duplicate points are dropped in both cases.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+event_gaps">event_gaps</a></code> for gaps (the inverse of coverage), <code><a href="#topic+event_range">event_range</a></code> for range (coverage with gaps ignored).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e &lt;- events(c(1, 2, 4, 8), c(3, 4, 5, 10))
event_coverage(e, closed = TRUE)  # retains breaks
event_coverage(e, closed = FALSE) # drops breaks
e &lt;- events(c(0, 2, 2, 2, 8, 10), c(0, 2, 2, 6, 10, 10))
event_coverage(e, closed = TRUE)  # retains isolated points
event_coverage(e, closed = FALSE) # retains isolated points and points adjacent to lines
</code></pre>

<hr>
<h2 id='event_gaps'>Event Gaps</h2><span id='topic+event_gaps'></span>

<h3>Description</h3>

<p>Returns the intervals over which there are no events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>event_gaps(e, closed = TRUE, range = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="event_gaps_+3A_e">e</code></td>
<td>
<p>An event table.</p>
</td></tr>
<tr><td><code id="event_gaps_+3A_closed">closed</code></td>
<td>
<p>Logical value indicating whether events should be interpreted as closed intervals. If <code>TRUE</code>, no gaps are returned at breaks between two adjacent events.</p>
</td></tr>
<tr><td><code id="event_gaps_+3A_range">range</code></td>
<td>
<p>An event table specifying, by its <code><a href="#topic+event_range">event_range</a></code>, the interval within which to check for gaps. If <code>NULL</code>, the range of <code>e</code> is used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+event_coverage">event_coverage</a></code> for coverage (the inverse of gaps), <code><a href="#topic+fill_event_gaps">fill_event_gaps</a></code> for filling gaps with empty events.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>event_gaps(events(c(1, 3, 5), c(2, 4, 5)))    # gaps between events
event_gaps(events(1:5))                       # no gaps
event_gaps(events(1:5), closed = FALSE)       # gaps at breaks
event_gaps(events(1:5), range = events(0, 6)) # gaps to edge of range  
</code></pre>

<hr>
<h2 id='event_midpoints'>Event midpoints</h2><span id='topic+event_midpoints'></span>

<h3>Description</h3>

<p>Event midpoints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>event_midpoints(e)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="event_midpoints_+3A_e">e</code></td>
<td>
<p>Event table.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>e &lt;- events(c(0, 10, 15, 25, 30), c(10, 20, 25, 40, 30))
event_midpoints(e)
</code></pre>

<hr>
<h2 id='event_overlaps'>Event Overlaps</h2><span id='topic+event_overlaps'></span>

<h3>Description</h3>

<p>Returns the number of events on each interval. Useful for sampling the original data with <code><a href="#topic+sample_events">sample_events</a></code> at the highest possible resolution that nevertheless flattens overlapping events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>event_overlaps(e)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="event_overlaps_+3A_e">e</code></td>
<td>
<p>An event table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Point events are preserved and line events are cut as necessary at the endpoints of other point or line events.
</p>


<h3>Value</h3>

<p>An endpoint-only event table with column &quot;n&quot; listing the number of overlapping events on that interval.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+event_coverage">event_coverage</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e &lt;- events(c(0, 10, 15, 25, 30), c(10, 20, 25, 40, 30))
event_overlaps(e)
</code></pre>

<hr>
<h2 id='event_range'>Event Range</h2><span id='topic+event_range'></span>

<h3>Description</h3>

<p>Returns the minimum and maximum endpoints of all the events in an event table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>event_range(e)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="event_range_+3A_e">e</code></td>
<td>
<p>An event table.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+event_coverage">event_coverage</a></code> for an alternative that accounts for gaps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>event_range(events(1:5))            # no gaps
event_range(events(c(1,5), c(1,5))) # gaps
</code></pre>

<hr>
<h2 id='events'>Event Tables</h2><span id='topic+events'></span>

<h3>Description</h3>

<p>Creates an event table, a custom <code>data.frame</code> used throughout the <code>linbin</code> package to store and manipulate linearly referenced data. Each row includes an event's endpoints <code>from</code> and <code>to</code> (which can be equal, to describe a point, or non-equal, to describe a line) and the values of any variables measured on that interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>events(from = numeric(), to = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="events_+3A_from">from</code>, <code id="events_+3A_to">to</code></td>
<td>
<p>Event endpoints, in any format coercible to single data frame columns. <code>from</code> and <code>to</code> are swapped as needed so that <code>to</code> &gt; or = <code>from</code> on all rows. If <code>from</code> is the only non-empty argument, <code><a href="#topic+as_events">as_events</a></code> is dispatched for object coercion.</p>
</td></tr>
<tr><td><code id="events_+3A_...">...</code></td>
<td>
<p>Additional arguments, either of the form <code>value</code> or <code>tag = value</code>, to be passed directly to <code><a href="base.html#topic+data.frame">data.frame</a></code> following <code>from</code> and <code>to</code>. Component names are created based on the tag (if present) or the deparsed argument itself.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Event endpoints (and any additional arguments) are coerced to a data frame with <code><a href="base.html#topic+data.frame">data.frame</a></code>, then coerced to an event table with <code><a href="#topic+as_events">as_events</a></code>. A valid event table has two columns named &quot;from&quot; and &quot;to&quot; containing only finite numeric values (i.e., no <code>NA</code>, <code>NaN</code>, or <code>Inf</code>) and ordered such that <code>to</code> &gt; or = <code>from</code>. <code><a href="#topic+is_events">is_events</a></code> tests for these requirements. The other columns in the event table can be of any type supported by the <code>data.frame</code> class.
</p>


<h3>Value</h3>

<p>An event table, the <code>data.frame</code> object used by <code>linbin</code> to describe interval data.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>
<p><code><a href="#topic+as_events">as_events</a></code> and <code><a href="#topic+read_events">read_events</a></code> for coercing objects and files to event tables, <code><a href="#topic+is_events">is_events</a></code> to validate event tables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>events(1, 5)
events(1:5)
events(c(0, 15, 25), c(10, 30, 35), x = 1, y = c('a', 'b', 'c'))
</code></pre>

<hr>
<h2 id='fill_event_gaps'>Fill Event Gaps</h2><span id='topic+fill_event_gaps'></span><span id='topic+collapse_event_gaps'></span>

<h3>Description</h3>

<p><code>fill_event_gaps</code> fills gaps below a maximum length with empty events. <code>collapse_event_gaps</code> shifts event endpoints to close gaps below a maximum length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_event_gaps(e, max.length = Inf)

collapse_event_gaps(e, max.length = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fill_event_gaps_+3A_e">e</code></td>
<td>
<p>An event table.</p>
</td></tr>
<tr><td><code id="fill_event_gaps_+3A_max.length">max.length</code></td>
<td>
<p>The maximum length of gaps to be filled or closed.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+event_gaps">event_gaps</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e &lt;- events(c(1, 4), c(2, 5), x = 1)
fill_event_gaps(e)
fill_event_gaps(e, max.length = 1)
collapse_event_gaps(e)
collapse_event_gaps(e, max.length = 1)
</code></pre>

<hr>
<h2 id='find_intersecting_events'>Find Intersecting Events</h2><span id='topic+find_intersecting_events'></span>

<h3>Description</h3>

<p>Returns a logical matrix indicating whether or not each pair of events intersect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_intersecting_events(ex, ey, equal.points = TRUE, closed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_intersecting_events_+3A_ex">ex</code>, <code id="find_intersecting_events_+3A_ey">ey</code></td>
<td>
<p>Event tables.</p>
</td></tr>
<tr><td><code id="find_intersecting_events_+3A_equal.points">equal.points</code></td>
<td>
<p>If <code>TRUE</code>, equal-valued points are considered intersecting. This is always <code>TRUE</code> if <code>closed = TRUE</code>.</p>
</td></tr>
<tr><td><code id="find_intersecting_events_+3A_closed">closed</code></td>
<td>
<p>If <code>TRUE</code>, events are interpreted as closed intervals and events sharing only an endpoint are reported as intersecting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical matrix with <code>ey</code> events as rows and <code>ex</code> events as columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex &lt;- events(c(0, 5, 5, 10))
find_intersecting_events(ex, events(5), equal.points = FALSE) # equal points don't intersect
find_intersecting_events(ex, events(5), equal.points = TRUE)  # equal points do intersect
find_intersecting_events(ex, events(5), closed = TRUE)        # adjacent events intersect
find_intersecting_events(ex, ex)
</code></pre>

<hr>
<h2 id='fishmotion'>Fish Movements</h2><span id='topic+fishmotion'></span>

<h3>Description</h3>

<p>A pair of event tables (in a list) documenting the movements of tagged Coho Salmon (<em>Oncorhynchus kisutch</em>) in Bear Creek (Southwest Alaska, USA) for 29 July - 19 August 2008. Table <code>motion</code> lists individual fish residence time intervals in each of three stream regions, while table <code>origin</code> lists the study-wide residence time of each fish and the stream region in which the fish was first tagged.
</p>


<h3>Format</h3>

<p>Two data frames <code>motion</code> and <code>origin</code> with 1,140 rows and 149 rows of 4 variables, respectively.
</p>


<h3>Details</h3>


<ul>
<li><p> from, to - start and end times as seconds since 1970-01-01 UTC (POSIXct)
</p>
</li>
<li><p> fish.id - unique identifier for each fish
</p>
</li>
<li><p> region - stream region (1 = 0 - 930 m, a cold downstream region with abundant and spawning sockeye salmon; 2 = 930 - 1360 m, a cold middle region with few if any sockeye salmon; 3 = &gt; 1360 m, a warm upstream region where sockeye salmon were absent)
</p>
</li></ul>



<h3>Source</h3>

<p>Armstrong, J. B., D. E. Schindler, C. P. Ruff, G. T. Brooks, K. E. Bentley, and C. E. Torgersen. 2013. Diel horizontal migration in streams: juvenile fish exploit spatial heterogeneity in thermal and trophic resources. Ecology 94:2066-2075. DOI: doi: <a href="https://doi.org/10.1890/12-1200.1">10.1890/12-1200.1</a>
</p>

<hr>
<h2 id='group_nonoverlapping_events'>Overlapping Events</h2><span id='topic+group_nonoverlapping_events'></span><span id='topic+has_overlapping_events'></span>

<h3>Description</h3>

<p><code>group_nonoverlapping_events</code> assigns each event to a group such that each group contains no overlaps. <code>has_overlapping_events</code> checks whether an event table has events that overlap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_nonoverlapping_events(e)

has_overlapping_events(e)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_nonoverlapping_events_+3A_e">e</code></td>
<td>
<p>An event table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By convention in <code>linbin</code>, events are considered overlapping if they are line events that share more than an endpoint, or point events that have equal endpoints. Point events on line event endpoints are not considered overlaps.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+event_overlaps">event_overlaps</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e &lt;- events(c(0, 2, 3), c(3, 4, 5))
cbind(group = group_nonoverlapping_events(e), e)  # adjacent lines do not overlap
e &lt;- events(c(0, 0, 0, 1, 1), c(0, 0, 1, 1, 2))    
cbind(group = group_nonoverlapping_events(e), e)  # equal points do overlap
has_overlapping_events(events(c(0, 2), c(2, 4)))  # adjacent lines
has_overlapping_events(events(c(0, 2), c(3, 4)))  # has overlapping lines
has_overlapping_events(events(c(0, 5, 5, 10)))    # points adjcent to lines
has_overlapping_events(events(c(0, 5, 5, 5, 10))) # has overlapping points
</code></pre>

<hr>
<h2 id='if_else'>Generalized If Else</h2><span id='topic+if_else'></span>

<h3>Description</h3>

<p>Returns different values depending on whether a test is <code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>if_else(test, yes, no)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="if_else_+3A_test">test</code></td>
<td>
<p>An object which can be coerced to a logical value.</p>
</td></tr>
<tr><td><code id="if_else_+3A_yes">yes</code></td>
<td>
<p>Value returned if <code>test</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="if_else_+3A_no">no</code></td>
<td>
<p>Value returned if <code>test</code> is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+ifelse">ifelse</a></code>
</p>

<hr>
<h2 id='is_events'>Validate Event Table</h2><span id='topic+is_events'></span>

<h3>Description</h3>

<p>Tests whether the object meets the basic requirements of an event table, i.e. a data frame containing at least two numeric, finite columns named 'from' and 'to' ordered such that <code>to</code> &gt; or = <code>from</code> on all rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_events(x, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_events_+3A_x">x</code></td>
<td>
<p>An R object.</p>
</td></tr>
<tr><td><code id="is_events_+3A_verbose">verbose</code></td>
<td>
<p>Logical value indicating whether to print the reason for test failure.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+events">events</a></code>, <code><a href="#topic+as_events">as_events</a></code>, and <code><a href="#topic+read_events">read_events</a></code> for creating valid event tables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>verbose &lt;- TRUE
is_events(c(1, 3), verbose)
is_events(data.frame(from = 1, t = 3), verbose)
is_events(data.frame(from = 1, from = 1, to = 3), verbose)
is_events(data.frame(from = 1, to = TRUE), verbose)
is_events(data.frame(from = 1, to = NA), verbose)
is_events(data.frame(from = 3, to = 1), verbose)
is_events(data.frame(from = 1, to = 3), verbose)   # TRUE
</code></pre>

<hr>
<h2 id='is_not_integer'>Not Integers</h2><span id='topic+is_not_integer'></span>

<h3>Description</h3>

<p>Tests whether a vector is empty, non-numeric, or contains any non-integer numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_not_integer(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_not_integer_+3A_x">x</code></td>
<td>
<p>An R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>FALSE</code> if <code>x</code> is a numeric vector containing only whole numbers, <code>TRUE</code> otherwise.
</p>

<hr>
<h2 id='netmap'>Dungeness River (NetMap)</h2><span id='topic+netmap'></span>

<h3>Description</h3>

<p>NetMap (<a href="https://terrainworks.com">terrainworks.com</a>) output for the entire fluvial network of the Dungeness River (Washington, USA). NetMap employs digital elevation models to generate detailed river networks and compute biophysical variables for spatially continuous hydrologic units throughout the networks.
</p>


<h3>Format</h3>

<p>A data frame with 16,616 rows and 47 variables.
</p>


<h3>Details</h3>


<ul>
<li><p> CHAN_ID - channel identifier (1 = mainstem, all others are tributaries)
</p>
</li>
<li><p> OUT_DIST - distance upstream from the river mouth to the downstream end of the unit [km]
</p>
</li>
<li><p> LENGTH_M - unit length [m]
</p>
</li>
<li><p> ... - see NetMap's <a href="http://www.netmaptools.org/Pages/NetMapHelp/master_attribute_list.htm">Master Attribute List</a>
</p>
</li></ul>



<h3>Source</h3>

<p><a href="https://terrainworks.com">https://terrainworks.com</a>
</p>

<hr>
<h2 id='plot_events'>Plot Events as Bar Plots</h2><span id='topic+plot_events'></span>

<h3>Description</h3>

<p>Plots an event table as a grid of bar plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_events(
  e,
  group.col = NULL,
  groups = NULL,
  data.cols = NULL,
  dim = NULL,
  byrow = TRUE,
  main = NULL,
  xlabs = character(),
  ylabs = character(),
  xlim = NULL,
  ylim = NULL,
  xticks = NULL,
  yticks = NULL,
  xtick.labels = NULL,
  ytick.labels = NULL,
  plot.grid = FALSE,
  sigfigs = c(3, 3),
  col = NULL,
  border = par("fg"),
  lty = par("lty"),
  lwd = par("lwd"),
  xpd = FALSE,
  mar = c(2.1, 2.75, 1.5, 0.5),
  oma = c(2, 2, 2, 2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_events_+3A_e">e</code></td>
<td>
<p>An event table.</p>
</td></tr>
<tr><td><code id="plot_events_+3A_group.col">group.col</code></td>
<td>
<p>Name or index of column defining the event grouping for plotting. If <code>NULL</code>, the events are treated as one group. Group <code>NA</code> is not plotted.</p>
</td></tr>
<tr><td><code id="plot_events_+3A_groups">groups</code></td>
<td>
<p>Vector of values from <code>group.col</code> specifying which groups to plot. If <code>NULL</code>, all groups are plotted by order of first appearance in <code>group.col</code>.</p>
</td></tr>
<tr><td><code id="plot_events_+3A_data.cols">data.cols</code></td>
<td>
<p>Names or indices of columns to plot, given as a list of character or numeric vectors. If multiple columns are specified, their bars are stacked together in one plot. Names are interpreted as regular expressions (<code><a href="base.html#topic+regex">regex</a></code>) matching full column names. If <code>NULL</code>, all columns not named <code>from</code>, <code>to</code>, or <code>group.col</code> are each plotted individually in order of appearance.</p>
</td></tr>
<tr><td><code id="plot_events_+3A_dim">dim</code></td>
<td>
<p>The row and column dimensions of the grid. If <code>NULL</code>, the grid is column groups (rows) by event groups (columns) if <code>byrow = TRUE</code>, and event groups (rows) by column groups (columns) if <code>byrow = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_events_+3A_byrow">byrow</code></td>
<td>
<p>Plots are added by column group, then bin group. If <code>TRUE</code>, plots are added by rows, rather than columns, to the grid.</p>
</td></tr>
<tr><td><code id="plot_events_+3A_main">main</code></td>
<td>
<p>Titles for each plot. If <code>NULL</code>, plots are titled by the column names, pasted together with separator &quot; + &quot;. Set <code>main = NA</code> to not title the plots.</p>
</td></tr>
<tr><td><code id="plot_events_+3A_xlabs">xlabs</code>, <code id="plot_events_+3A_ylabs">ylabs</code></td>
<td>
<p>Labels arranged at equal intervals along the bottom and left side of the plot grid. These are drawn in the outer margins of the figure, so <code>oma[1]</code> and <code>oma[2]</code> must be non-zero.</p>
</td></tr>
<tr><td><code id="plot_events_+3A_xlim">xlim</code>, <code id="plot_events_+3A_ylim">ylim</code></td>
<td>
<p>Limits for the x and y axes of all plots. If <code>NULL</code>, limits are set to the range of the data and the y limits extended as needed to include 0.</p>
</td></tr>
<tr><td><code id="plot_events_+3A_xticks">xticks</code>, <code id="plot_events_+3A_yticks">yticks</code></td>
<td>
<p>The positions of x and y tick marks for all plots. If <code>NULL</code>, only the min and max x and y are ticked (and 0 as needed for y). If <code><a href="graphics.html#topic+axTicks">axTicks</a></code>, that function will be used to calculate R default tick mark positions. If <code>NA</code>, no ticks are drawn.</p>
</td></tr>
<tr><td><code id="plot_events_+3A_xtick.labels">xtick.labels</code>, <code id="plot_events_+3A_ytick.labels">ytick.labels</code></td>
<td>
<p>The labels for the x and y tick marks, coerced to character vectors and recycled as necessary. If <code>NULL</code>, the positions of the ticks are used as the labels, formatted with <code>sigfigs</code>. If <code>NA</code>, the tick marks are not labeled.</p>
</td></tr>
<tr><td><code id="plot_events_+3A_plot.grid">plot.grid</code></td>
<td>
<p>If <code>TRUE</code>, a lined horizontal grid is plotted at the yticks.</p>
</td></tr>
<tr><td><code id="plot_events_+3A_sigfigs">sigfigs</code></td>
<td>
<p>The maximum significant figures of the x and y axis labels.</p>
</td></tr>
<tr><td><code id="plot_events_+3A_col">col</code></td>
<td>
<p>Color(s) for the bars in each plot. If <code>NA</code>, bars are transparent. If <code>NULL</code>, a grey palette is used.</p>
</td></tr>
<tr><td><code id="plot_events_+3A_border">border</code></td>
<td>
<p>Color(s) for bar borders in each plot. If <code>NA</code>, borders are omitted.</p>
</td></tr>
<tr><td><code id="plot_events_+3A_lty">lty</code></td>
<td>
<p>Line type(s) for bar borders in each plot.</p>
</td></tr>
<tr><td><code id="plot_events_+3A_lwd">lwd</code></td>
<td>
<p>Line width(s) for bar borders in each plot.</p>
</td></tr>
<tr><td><code id="plot_events_+3A_xpd">xpd</code></td>
<td>
<p>Logical value or <code>NA</code>. If <code>FALSE</code>, all plotting is clipped to the plot region, if <code>TRUE</code>, all plotting is clipped to the figure region, and if <code>NA</code>, all plotting is clipped to the device region.</p>
</td></tr>
<tr><td><code id="plot_events_+3A_mar">mar</code></td>
<td>
<p>Numerical vector of the form c(bottom, left, top, right) giving the size of the inner margins of each plot in lines of text.</p>
</td></tr>
<tr><td><code id="plot_events_+3A_oma">oma</code></td>
<td>
<p>Numeric vector of the form c(bottom, left, top, right) giving the size of the outer figure margins in lines of text.</p>
</td></tr>
<tr><td><code id="plot_events_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a grouping variable for the rows of the event table (e.g., groups of bins of different sizes used in <code><a href="#topic+sample_events">sample_events</a></code>), and groups of columns to plot, bar plots are drawn in a grid for each combination of event and column groups. In each plot, the specified event table columns are plotted together as stacked bars. Negative and positive values are stacked separately from the <code>y = 0</code> baseline. Events with <code>NA</code> are not shown, differentiating them from zero-valued events which are drawn as thin black lines. Point events are drawn as thin vertical lines. Overlapping events are drawn as overlapping bars, so it is best to use <code><a href="#topic+sample_events">sample_events</a></code> with non-overlapping bins to flatten the data before plotting.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seq_events">seq_events</a></code> for generating groups of sequential bins, <code><a href="#topic+sample_events">sample_events</a></code> to populate groups of bins with event data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e &lt;- events(from = c(0, 10, 15, 25), to = c(10, 20, 25, 40), length = c(10, 10, 10, 15),
            x = c(1, 2, 1, 1), f = c('a', 'b', 'a', 'a'))
bins &lt;- seq_events(event_coverage(e), c(8, 4, 2, 1))
e.bins &lt;- sample_events(e, bins, list(sum, c('x', 'length')), scaled.cols = 'length')
plot_events(e.bins, group.col = 'group')
</code></pre>

<hr>
<h2 id='plot_events_single'>Plot Events as Bars</h2><span id='topic+plot_events_single'></span>

<h3>Description</h3>

<p>Plots event table columns as vertical bars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_events_single(
  e,
  cols,
  xlim = NULL,
  ylim = NULL,
  xticks = NULL,
  yticks = NULL,
  xtick.labels = NULL,
  ytick.labels = NULL,
  main = NA,
  xlab = NA,
  ylab = NA,
  plot.grid = FALSE,
  sigfigs = c(3, 3),
  col = grDevices::grey.colors(length(cols)),
  border = par("fg"),
  lty = par("lty"),
  lwd = par("lwd"),
  xpd = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_events_single_+3A_e">e</code></td>
<td>
<p>An event table.</p>
</td></tr>
<tr><td><code id="plot_events_single_+3A_cols">cols</code></td>
<td>
<p>Names or indices of the event table columns to plot together as stacked bars.</p>
</td></tr>
<tr><td><code id="plot_events_single_+3A_xlim">xlim</code>, <code id="plot_events_single_+3A_ylim">ylim</code></td>
<td>
<p>Limits for the x and y axes. If <code>NULL</code>, limits are set to the range of the data and the y limits extended as needed to include 0.</p>
</td></tr>
<tr><td><code id="plot_events_single_+3A_xticks">xticks</code>, <code id="plot_events_single_+3A_yticks">yticks</code></td>
<td>
<p>The values to label on the x and y axes. If <code>NULL</code>, only the min and max x and y are labeled (and 0 as needed for y). If <code><a href="graphics.html#topic+axTicks">axTicks</a></code>, the function will be used to generate R default tick marks.</p>
</td></tr>
<tr><td><code id="plot_events_single_+3A_xtick.labels">xtick.labels</code>, <code id="plot_events_single_+3A_ytick.labels">ytick.labels</code></td>
<td>
<p>Labels for the x and y tick positions.</p>
</td></tr>
<tr><td><code id="plot_events_single_+3A_main">main</code></td>
<td>
<p>An overall title for the plot.</p>
</td></tr>
<tr><td><code id="plot_events_single_+3A_xlab">xlab</code>, <code id="plot_events_single_+3A_ylab">ylab</code></td>
<td>
<p>Titles for the x and y axes.</p>
</td></tr>
<tr><td><code id="plot_events_single_+3A_plot.grid">plot.grid</code></td>
<td>
<p>If <code>TRUE</code>, a lined horizontal grid is plotted at the yticks.</p>
</td></tr>
<tr><td><code id="plot_events_single_+3A_sigfigs">sigfigs</code></td>
<td>
<p>The maximum significant figures to use for the x and y axis labels.</p>
</td></tr>
<tr><td><code id="plot_events_single_+3A_col">col</code></td>
<td>
<p>Color(s) for the bars. If <code>NULL</code>, bars are transparent. By default, a grey palette is used.</p>
</td></tr>
<tr><td><code id="plot_events_single_+3A_border">border</code></td>
<td>
<p>Color(s) for bar borders. Use border = NA to omit borders.</p>
</td></tr>
<tr><td><code id="plot_events_single_+3A_lty">lty</code></td>
<td>
<p>Line type(s) for bar borders.</p>
</td></tr>
<tr><td><code id="plot_events_single_+3A_lwd">lwd</code></td>
<td>
<p>Line width(s) for bar borders.</p>
</td></tr>
<tr><td><code id="plot_events_single_+3A_xpd">xpd</code></td>
<td>
<p>Logical value or <code>NA</code>. If <code>FALSE</code>, all plotting is clipped to the plot region, if <code>TRUE</code>, all plotting is clipped to the figure region, and if <code>NA</code>, all plotting is clipped to the device region.</p>
</td></tr>
<tr><td><code id="plot_events_single_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The specified event table columns are plotted together as stacked bars. Negative and positive values are stacked separately from the <code>y = 0</code> baseline. Events with <code>NA</code> are not shown, differentiating them from zero-valued events which are drawn as thin black lines. Point events are drawn as thin vertical lines. Overlapping events are drawn as overlapping bars, so it is best to use <code><a href="#topic+sample_events">sample_events</a></code> with non-overlapping bins to flatten the data before plotting.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_events">plot_events</a></code>.
</p>

<hr>
<h2 id='quinault'>Quinault River Survey</h2><span id='topic+quinault'></span>

<h3>Description</h3>

<p>An event table containing the results of a survey of the Quinault River (Washington, USA) in August 2009. Both physical variables and fish counts were collected.
</p>


<h3>Format</h3>

<p>A data frame with 363 rows and 31 variables.
</p>


<h3>Details</h3>


<ul>
<li><p> from, to - distance upstream from the river mouth [km]
</p>
</li>
<li><p> altitude - mean elevation above sea level [m]
</p>
</li>
<li><p> channel.type - channel type (1 = main, 2 = secondary)
</p>
</li>
<li><p> unit.type - unit type (P = pool, GP = glide-like pool, GR = glide-like riffle, R = riffle)
</p>
</li>
<li><p> unit.length - unit length [m]
</p>
</li>
<li><p> mean.width - mean wetted width [m]
</p>
</li>
<li><p> mean.depth - mean depth [m]
</p>
</li>
<li><p> max.depth - max depth [m]
</p>
</li>
<li><p> overhang.cover - channel banks with overhanging vegetation [%]
</p>
</li>
<li><p> boulder.cover - channel area covered by boulders [%]
</p>
</li>
<li><p> jams - number of log jams
</p>
</li>
<li><p> jam.area - total area of log jams [m^2]
</p>
</li>
<li><p> SACO.10/20/30/50/total - number of Bull Trout (<em>Salvelinus confluentus</em>) sized 10 - 20 cm / 20 - 30 cm / 30 - 50 cm / &gt; 50 cm / total, respectively.
</p>
</li>
<li><p> ONXX.10/20/30/total - number of trout (<em>Oncorhynchus sp.</em>) sized 10 - 20 cm / 20 - 30 cm / &gt; 30 cm / total, respectively.
</p>
</li>
<li><p> PRWI - number of Mountain Whitefish (<em>Prosopium williamsoni</em>)
</p>
</li>
<li><p> ONTS - number of Chinook Salmon (<em>Oncorhynchus tshawytscha</em>)
</p>
</li>
<li><p> ONMY - number of Rainbow Trout (<em>Oncorhynchus mykiss</em>)
</p>
</li>
<li><p> ONKI - number of Coho Salmon (<em>Oncorhynchus kisutch</em>)
</p>
</li>
<li><p> ONNE - number of Sockeye Salmon (<em>Oncorhynchus nerka</em>)
</p>
</li>
<li><p> ONGO - number of Pink Salmon (<em>Oncorhynchus gorbushcha</em>)
</p>
</li>
<li><p> ONKE - number of Chum Salmon (<em>Oncorhynchus keta</em>)
</p>
</li>
<li><p> CAMA - number of Largescale Sucker (<em>Catostomus macrocheilus</em>)
</p>
</li>
<li><p> LATR - number of Pacific Lamprey (<em>Lampetra tridentata</em>)
</p>
</li></ul>



<h3>Source</h3>

<p>Samuel J. Brenkman (National Park Service, Olympic National Park, Washington, USA), unpublished data.
</p>

<hr>
<h2 id='read_events'>Read File as Event Table</h2><span id='topic+read_events'></span>

<h3>Description</h3>

<p>Reads a file in table format and attempts to coerce it to an event table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_events(file, from.col = 1, to.col = 2, sep = "", header = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_events_+3A_file">file</code></td>
<td>
<p>Name, <code><a href="base.html#topic+connection">connection</a></code>, or <code><a href="base.html#topic+url">url</a></code> of the file to be read as an event table.</p>
</td></tr>
<tr><td><code id="read_events_+3A_from.col">from.col</code>, <code id="read_events_+3A_to.col">to.col</code></td>
<td>
<p>Names or indices of the columns containing event endpoints. Values are swapped as needed to ensure that <code>to &gt; or = from</code> on all rows.</p>
</td></tr>
<tr><td><code id="read_events_+3A_sep">sep</code></td>
<td>
<p>Character separating values on each line of the file. If <code>sep = ""</code> (the default), the separator is 'white space' (that is, any combination of one or more spaces, tabs, newlines and carriage returns).</p>
</td></tr>
<tr><td><code id="read_events_+3A_header">header</code></td>
<td>
<p>Logical value indicating whether the file contains column names as its first line. If <code>FALSE</code>, columns will be named &quot;V&quot; followed by the column number, unless <code>col.names</code> (a vector of optional column names) is provided as an additional argument.</p>
</td></tr>
<tr><td><code id="read_events_+3A_...">...</code></td>
<td>
<p>Additional arguments, of the form <code>tag = value</code>, to be passed directly to <code><a href="utils.html#topic+read.table">read.table</a></code> to control how the file is read.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The file is read into R by calling <code><a href="utils.html#topic+read.table">read.table</a></code>. Any of its arguments can be set by passing additional <code>tag = value</code> pairs. <code>from.col</code> and <code>to.col</code> are renamed to &quot;from&quot; and &quot;to&quot; as needed. Since these column names must be unique, other columns cannot also be called &quot;from&quot; or &quot;to&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>.
</p>
<p><code><a href="#topic+events">events</a></code> and <code><a href="#topic+as_events">as_events</a></code> for creating event tables from existing objects.
</p>

<hr>
<h2 id='rgrep_exact'>Full Name Matching</h2><span id='topic+rgrep_exact'></span>

<h3>Description</h3>

<p>Recursive wrapper for <code>grep</code> returning only full matches to elements of a character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgrep_exact(patterns, x, ..., simplify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgrep_exact_+3A_patterns">patterns</code></td>
<td>
<p>Character vector containing regular expressions to be matched.</p>
</td></tr>
<tr><td><code id="rgrep_exact_+3A_x">x</code></td>
<td>
<p>Character vector where matches are sought, or an object which can be coerced by <code>as.character</code> to a character vector.</p>
</td></tr>
<tr><td><code id="rgrep_exact_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="base.html#topic+grep">grep</a></code>.</p>
</td></tr>
<tr><td><code id="rgrep_exact_+3A_simplify">simplify</code></td>
<td>
<p>If <code>TRUE</code>, the result is simplified from a list to a vector or matrix if appropriate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List, matrix, or vector of the indices of the elements of <code>x</code> that yielded a match to each element of <code>patterns</code>.
</p>

<hr>
<h2 id='sample_events'>Sample Events</h2><span id='topic+sample_events'></span>

<h3>Description</h3>

<p>Computes event table variables over the specified sampling intervals, or &quot;bins&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_events(
  e,
  bins,
  ...,
  scaled.cols = NULL,
  col.names = NULL,
  drop.empty = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_events_+3A_e">e</code></td>
<td>
<p>An event table.</p>
</td></tr>
<tr><td><code id="sample_events_+3A_bins">bins</code></td>
<td>
<p>An event table specifying the intervals for sampling.</p>
</td></tr>
<tr><td><code id="sample_events_+3A_...">...</code></td>
<td>
<p>Lists specifying the sampling functions and parameters to be used (see the <code>Details</code>).</p>
</td></tr>
<tr><td><code id="sample_events_+3A_scaled.cols">scaled.cols</code></td>
<td>
<p>Names or indices of the event columns to be rescaled after cutting (see <code><a href="#topic+cut_events">cut_events</a></code>). Names are interpreted as regular expressions (<code><a href="base.html#topic+regex">regex</a></code>) matching full column names.</p>
</td></tr>
<tr><td><code id="sample_events_+3A_col.names">col.names</code></td>
<td>
<p>Character vector of names for the columns output by the sampling functions. If <code>NULL</code>, the columns are named automatically (see the <code>Details</code>).</p>
</td></tr>
<tr><td><code id="sample_events_+3A_drop.empty">drop.empty</code></td>
<td>
<p>If <code>TRUE</code>, bins not intersecting any events are dropped.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Events are cut at bin endpoints, and any <code>scaled.cols</code> columns are rescaled to the length of the resulting event segments. The event segments falling into each bin are passed to the sampling functions to compute the variables for each bin. Bins sample from events they overlap: line events with whom they share more than an endpoint, or point events with equal endpoints (if the bin itself is a point).
</p>
<p>Sampling functions are specified in lists with the format <code>list(FUN, data.cols, by = group.cols, ...)</code>. The first element in the list is the function to use. It must compute a single value from one or more vectors of the same length. The following unnamed element is a vector specifying the event column names or indices to recursively pass as the first argument of the function. Names are interpreted as regular expressions (<code><a href="base.html#topic+regex">regex</a></code>) matching full column names. Additional unnamed elements are vectors specifying additional event columns to pass as the second, third, ... argument of the function. The first &quot;by&quot; element is a vector of event column names or indices used as grouping variables. Any additional named arguments are passed directly to the function. For example:
</p>
<p>list(sum, 1:2, na.rm = TRUE) =&gt; sum(events[1], na.rm = TRUE), sum(events[2], na.rm = TRUE)
list(sum, 1, 3:4, 5) =&gt; sum(events[1], events[3], events[4], events[5]), ...
list(sum, c('x', 'y'), by = 3:4) =&gt; list(sum, 'x'), list(sum, 'y') grouped into all combinations of columns 3 and 4
</p>
<p>Using the latter example above, column names are taken from the first argument (e.g. <code>x, y</code>), and all grouping variables are appended (e.g. <code>x.a, y.a, x.b, y.b</code>), where <code>a</code> and <code>b</code> are the levels of columns 3 and 4. <code>NA</code> is also treated as a factor level. Columns are added left to right in order of the sampling function arguments. Finally, names are made unique by appending sequence numbers to duplicates (using <code><a href="base.html#topic+make.unique">make.unique</a></code>).
</p>


<h3>Value</h3>

<p>The <code>bins</code> event table with the columns output by the sampling functions appended.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seq_events">seq_events</a></code> to generate sequential bins.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e &lt;- events(from = c(0, 10, 15, 25), to = c(10, 20, 25, 40), length = c(10, 10, 10, 15), 
            x = c(1, 2, 1, 1), f = c('a', 'b', 'a', 'a'))
bins &lt;- rbind(seq_events(event_coverage(e), 4), c(18, 18))
sample_events(e, bins, list(sum, 'length'))
sample_events(e, bins, list(sum, 'length'), scaled.cols = 'length')
sample_events(e, bins, list(sum, 'length', by = 'f'), scaled.cols = 'length')
sample_events(e, bins, list(weighted.mean, 'x', 'length'), scaled.cols = 'length')
sample_events(e, bins, list(paste0, 'f', collapse = "."))
</code></pre>

<hr>
<h2 id='sampling_functions'>Build Sampling Functions</h2><span id='topic+sampling_functions'></span>

<h3>Description</h3>

<p>Helper function for <code><a href="#topic+sample_events">sample_events</a></code>. Parses function call parameters into self-enclosed function calls that can be passed row subsets of an event table for sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampling_functions(col.names, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampling_functions_+3A_col.names">col.names</code></td>
<td>
<p>Names of columns, for converting column name indices to numeric column indices.</p>
</td></tr>
<tr><td><code id="sampling_functions_+3A_...">...</code></td>
<td>
<p>Lists of sampling function parameters (see <code><a href="#topic+sample_events">sample_events</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE: Assumes bin assignments will be appended to the end of the event table.
</p>


<h3>Value</h3>

<p>A list of functions.
</p>

<hr>
<h2 id='seq_events'>Generate Sequential Events</h2><span id='topic+seq_events'></span>

<h3>Description</h3>

<p>Generates groups of regularly sequenced events fitted to the specified intervals. Intended for use as bins with <code><a href="#topic+sample_events">sample_events</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_events(coverage, length.out = NULL, by = NULL, adaptive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seq_events_+3A_coverage">coverage</code></td>
<td>
<p>An event table specifying the non-overlapping intervals to which the event sequences will be fitted. Gaps in coverage do not count towards event length. Points in the coverage are currently ignored.</p>
</td></tr>
<tr><td><code id="seq_events_+3A_length.out">length.out</code></td>
<td>
<p>The number of events in each sequence. Event lengths are chosen such that they evenly divide the <code>coverage</code>.</p>
</td></tr>
<tr><td><code id="seq_events_+3A_by">by</code></td>
<td>
<p>The length of the events in each sequence. Ignored if <code>length.out</code> is defined. When the length does not evenly divide the <code>coverage</code>, a shorter event is appended to the end of the sequence.</p>
</td></tr>
<tr><td><code id="seq_events_+3A_adaptive">adaptive</code></td>
<td>
<p>If <code>TRUE</code>, events are adjusted locally so that a whole number of events fit within each coverage interval, preserving breaks and gaps.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An endpoint-only event table with an additional group field if the length of <code>length.out</code> or <code>by</code> is <code>&gt;</code> 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+event_range">event_range</a></code>, <code><a href="#topic+event_coverage">event_coverage</a></code>, and <code><a href="#topic+fill_event_gaps">fill_event_gaps</a></code> for building a <code>coverage</code> from an existing event table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e &lt;- events(c(0, 20, 40), c(10, 30, 45))
no.gaps &lt;- event_range(e)
has.gaps &lt;- event_coverage(e)
seq_events(no.gaps, by = 10)                           # unequal length (last is shorter)
seq_events(no.gaps, by = 10, adaptive = TRUE)          # equal length (11.25)
seq_events(no.gaps, length.out = 4)                    # equal length (11.25)
seq_events(has.gaps, length.out = 4, adaptive = FALSE) # equal coverage (11.25), straddling gaps
seq_events(has.gaps, length.out = 4, adaptive = TRUE)  # unequal coverage, fitted to gaps
seq_events(no.gaps, length.out = c(2, 4))              # "group" column added
</code></pre>

<hr>
<h2 id='simple'>Simple Event Table</h2><span id='topic+simple'></span>

<h3>Description</h3>

<p>A simple, hypothetical event table.
</p>


<h3>Format</h3>

<p>A data frame with 11 rows and 7 variables.
</p>


<h3>Details</h3>


<ul>
<li><p> from, to - endpoint positions
</p>
</li>
<li><p> x, y, z - numeric variables
</p>
</li>
<li><p> factor - a factor variable
</p>
</li></ul>


<hr>
<h2 id='sort_events'>Sorted Events</h2><span id='topic+sort_events'></span><span id='topic+is_unsorted_events'></span>

<h3>Description</h3>

<p><code>sort_events</code> sorts events by ascending <code>from</code>, then ascending <code>to</code>. <code>is_unsorted_events</code> tests whether the events are not sorted, without the cost of sorting them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_events(e)

is_unsorted_events(e)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sort_events_+3A_e">e</code></td>
<td>
<p>An event table.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>e &lt;- events(c(1, 1, 3, 2), c(2, 1, 4, 3))
is_unsorted_events(e)
sort_events(e)
</code></pre>

<hr>
<h2 id='to_date'>Convert event endpoints to dates</h2><span id='topic+to_date'></span>

<h3>Description</h3>

<p>Convert event endpoints to dates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_date(e, origin = as.Date("1970-01-01"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to_date_+3A_e">e</code></td>
<td>
<p>Event table or atomic vector.</p>
</td></tr>
<tr><td><code id="to_date_+3A_origin">origin</code></td>
<td>
<p>Date object (see <code><a href="base.html#topic+as.Date">as.Date</a></code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- as.Date("1970-01-01") + 0:4
e &lt;- events(t)
to_date(e)
to_date(e$from)
</code></pre>

<hr>
<h2 id='to_datetime'>Convert event endpoints to date-times</h2><span id='topic+to_datetime'></span>

<h3>Description</h3>

<p>Convert event endpoints to date-times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_datetime(e, tz = "UTC", origin = as.POSIXct("1970-01-01", tz = "UTC"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to_datetime_+3A_e">e</code></td>
<td>
<p>Event table or atomic vector.</p>
</td></tr>
<tr><td><code id="to_datetime_+3A_tz">tz</code></td>
<td>
<p>Time zone (see <code><a href="base.html#topic+timezones">timezones</a></code>).</p>
</td></tr>
<tr><td><code id="to_datetime_+3A_origin">origin</code></td>
<td>
<p>Date-time object (see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- as.POSIXct("1970-01-01", tz = "UTC") + 0:4
e &lt;- events(t)
to_datetime(e)
to_datetime(e$from)
</code></pre>

<hr>
<h2 id='transform_events'>Transform Events</h2><span id='topic+transform_events'></span>

<h3>Description</h3>

<p>Transforms events by scaling, then translating their endpoint positions. That is, the transformed <code>[from, to] = scale * [from, to] + translate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_events(e, scale = 1, translate = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform_events_+3A_e">e</code></td>
<td>
<p>An event table.</p>
</td></tr>
<tr><td><code id="transform_events_+3A_scale">scale</code></td>
<td>
<p>Number by which event endpoints should be scaled.</p>
</td></tr>
<tr><td><code id="transform_events_+3A_translate">translate</code></td>
<td>
<p>Number by which event endpoints should be translated.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>e &lt;- events(c(10, 100), c(100, 1000))
transform_events(e, scale = 2, translate = 1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
