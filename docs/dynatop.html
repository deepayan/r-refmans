<!DOCTYPE html><html lang="en-GB"><head><title>Help for package dynatop</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dynatop}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dynatop-package'><p>dynatop</p></a></li>
<li><a href='#dynatop'><p>R6 Class for Dynamic TOPMODEL</p></a></li>
<li><a href='#evap_est'><p>Create sinusoidal time series of potential evapotranspiration input</p></a></li>
<li><a href='#resample_xts'><p>Functions to resample an xts time series</p></a></li>
<li><a href='#Swindale'><p>Example dynamic TOPMODEL setup</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>An Implementation of Dynamic TOPMODEL Hydrological Model in R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.3</td>
</tr>
<tr>
<td>Description:</td>
<td>An R implementation and enhancement of the Dynamic TOPMODEL semi-distributed hydrological model originally proposed by Beven and Freer (2001) &lt;<a href="https://doi.org/10.1002%2Fhyp.252">doi:10.1002/hyp.252</a>&gt;. The 'dynatop' package implements code for simulating models which can be created using the 'dynatopGIS' package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, zoo, xts, Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/waternumbers/dynatop/issues">https://github.com/waternumbers/dynatop/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://waternumbers.github.io/dynatop/">https://waternumbers.github.io/dynatop/</a>,
<a href="https://github.com/waternumbers/dynatop">https://github.com/waternumbers/dynatop</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>raster, knitr, rmarkdown, bookdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-10 13:53:47 UTC; paul</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul Smith <a href="https://orcid.org/0000-0002-0034-3412"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Peter Metcalfe [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul Smith &lt;paul@waternumbers.co.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-10 20:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='dynatop-package'>dynatop</h2><span id='topic+dynatop-package'></span>

<h3>Description</h3>

<p>This package contains the core code for the R implementation of dynamic TOPMODEL
</p>

<hr>
<h2 id='dynatop'>R6 Class for Dynamic TOPMODEL</h2><span id='topic+dynatop'></span>

<h3>Description</h3>

<p>R6 Class for Dynamic TOPMODEL
</p>
<p>R6 Class for Dynamic TOPMODEL
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-dynatop-new"><code>dynatop$new()</code></a>
</p>
</li>
<li> <p><a href="#method-dynatop-add_data"><code>dynatop$add_data()</code></a>
</p>
</li>
<li> <p><a href="#method-dynatop-clear_data"><code>dynatop$clear_data()</code></a>
</p>
</li>
<li> <p><a href="#method-dynatop-initialise"><code>dynatop$initialise()</code></a>
</p>
</li>
<li> <p><a href="#method-dynatop-initialise_channel"><code>dynatop$initialise_channel()</code></a>
</p>
</li>
<li> <p><a href="#method-dynatop-sim_hillslope"><code>dynatop$sim_hillslope()</code></a>
</p>
</li>
<li> <p><a href="#method-dynatop-sim_channel"><code>dynatop$sim_channel()</code></a>
</p>
</li>
<li> <p><a href="#method-dynatop-sim"><code>dynatop$sim()</code></a>
</p>
</li>
<li> <p><a href="#method-dynatop-get_channel_inflow"><code>dynatop$get_channel_inflow()</code></a>
</p>
</li>
<li> <p><a href="#method-dynatop-plot_channel_inflow"><code>dynatop$plot_channel_inflow()</code></a>
</p>
</li>
<li> <p><a href="#method-dynatop-get_gauge_flow"><code>dynatop$get_gauge_flow()</code></a>
</p>
</li>
<li> <p><a href="#method-dynatop-plot_gauge_flow"><code>dynatop$plot_gauge_flow()</code></a>
</p>
</li>
<li> <p><a href="#method-dynatop-get_obs_data"><code>dynatop$get_obs_data()</code></a>
</p>
</li>
<li> <p><a href="#method-dynatop-get_model"><code>dynatop$get_model()</code></a>
</p>
</li>
<li> <p><a href="#method-dynatop-get_mass_errors"><code>dynatop$get_mass_errors()</code></a>
</p>
</li>
<li> <p><a href="#method-dynatop-get_states"><code>dynatop$get_states()</code></a>
</p>
</li>
<li> <p><a href="#method-dynatop-plot_state"><code>dynatop$plot_state()</code></a>
</p>
</li>
<li> <p><a href="#method-dynatop-clone"><code>dynatop$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-dynatop-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a dynatop class object from the a list based model description as generated by dynatopGIS.
</p>


<h5>Usage</h5>

<div class="r"><pre>dynatop$new(model, use_states = FALSE, delta = 1e-13)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>model</code></dt><dd><p>a dynamic TOPMODEL list object</p>
</dd>
<dt><code>use_states</code></dt><dd><p>logical if states should be imported</p>
</dd>
<dt><code>delta</code></dt><dd><p>error term in checking redistribution sums</p>
</dd>
<dt><code>drop_map</code></dt><dd><p>logical if the map should be dropped</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This function makes some basic consistency checks on a list representing a dynamic TOPMODEL model. The checks performed and basic 'sanity' checks. They do not check for the logic of the parameter values nor the consistency of states and parameters. Sums of the redistribution matrices are checked to be in the range 1 +/- delta.
</p>



<h5>Returns</h5>

<p>invisible(self) suitable for chaining
</p>


<hr>
<a id="method-dynatop-add_data"></a>



<h4>Method <code>add_data()</code></h4>

<p>Adds observed data to a dynatop object
</p>


<h5>Usage</h5>

<div class="r"><pre>dynatop$add_data(obs_data)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>obs_data</code></dt><dd><p>an xts object of observed data</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This function makes some basic consistency checks on the observations to ensure they have uniform timestep and all required series are present.
</p>



<h5>Returns</h5>

<p>invisible(self) suitable for chaining
</p>


<hr>
<a id="method-dynatop-clear_data"></a>



<h4>Method <code>clear_data()</code></h4>

<p>Clears all forcing and simulation data except current states
</p>


<h5>Usage</h5>

<div class="r"><pre>dynatop$clear_data()</pre></div>



<h5>Returns</h5>

<p>invisible(self) suitable for chaining
</p>


<hr>
<a id="method-dynatop-initialise"></a>



<h4>Method <code>initialise()</code></h4>

<p>Initialises a dynatop object in the most simple way possible.
</p>


<h5>Usage</h5>

<div class="r"><pre>dynatop$initialise(tol = 2 * .Machine$double.eps, max_it = 1000)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>tol</code></dt><dd><p>tolerance for the solution for the saturated zone</p>
</dd>
<dt><code>max_it</code></dt><dd><p>maximum number of iterations to use in the solution of the saturated zone</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>invisible(self) suitable for chaining
</p>


<hr>
<a id="method-dynatop-initialise_channel"></a>



<h4>Method <code>initialise_channel()</code></h4>

<p>Initialises only the channel part of a dynatop object in the most simple way possible.
</p>


<h5>Usage</h5>

<div class="r"><pre>dynatop$initialise_channel()</pre></div>



<h5>Returns</h5>

<p>invisible(self) suitable for chaining
</p>


<hr>
<a id="method-dynatop-sim_hillslope"></a>



<h4>Method <code>sim_hillslope()</code></h4>

<p>Simulate the hillslope output of a dynatop object
</p>


<h5>Usage</h5>

<div class="r"><pre>dynatop$sim_hillslope(
  keep_states = NULL,
  sub_step = NULL,
  tol = 2 * .Machine$double.eps,
  max_it = 1000,
  ftol = Inf
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>keep_states</code></dt><dd><p>a vector of POSIXct objects (e.g. from xts) giving the time stamp at which the states should be kept</p>
</dd>
<dt><code>sub_step</code></dt><dd><p>simulation timestep in seconds, default value of NULL results in data time step</p>
</dd>
<dt><code>tol</code></dt><dd><p>tolerance on width of bounds in the solution for the saturated zone</p>
</dd>
<dt><code>max_it</code></dt><dd><p>maximum number of iterations to use in the solution of the saturated zone</p>
</dd>
<dt><code>ftol</code></dt><dd><p>tolerance in closeness to 0 in the solution for the saturated zone</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Both saving the states at every timestep and keeping the mass balance can generate very large data sets!!
While ftol is implemented it is currently set to <code>Inf</code> to mimic the behaviour of previous versions. This will change in the future.
</p>



<h5>Returns</h5>

<p>invisible(self) for chaining
</p>


<hr>
<a id="method-dynatop-sim_channel"></a>



<h4>Method <code>sim_channel()</code></h4>

<p>Simulate the channel output of a dynatop object
</p>


<h5>Usage</h5>

<div class="r"><pre>dynatop$sim_channel()</pre></div>



<h5>Returns</h5>

<p>invisible(self) for chaining
</p>


<hr>
<a id="method-dynatop-sim"></a>



<h4>Method <code>sim()</code></h4>

<p>Simulate the hillslope and channel components of a dynatop object
</p>


<h5>Usage</h5>

<div class="r"><pre>dynatop$sim(
  keep_states = NULL,
  sub_step = NULL,
  tol = 2 * .Machine$double.eps,
  max_it = 1000,
  ftol = Inf
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>keep_states</code></dt><dd><p>a vector of POSIXct objects (e.g. from xts) giving the time stamp at which the states should be kept</p>
</dd>
<dt><code>sub_step</code></dt><dd><p>simulation timestep in seconds, default value of NULL results in data time step</p>
</dd>
<dt><code>tol</code></dt><dd><p>tolerance on width of bounds in the solution for the saturated zone</p>
</dd>
<dt><code>max_it</code></dt><dd><p>maximum number of iterations to use in the solution of the saturated zone</p>
</dd>
<dt><code>ftol</code></dt><dd><p>tolerance in closeness to 0 in the solution for the saturated zone</p>
</dd>
<dt><code>mass_check</code></dt><dd><p>Flag indicating is a record of mass balance errors should be kept</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Calls the sim_hillslope and sim_channel in sequence. Both saving the states at every timestep and keeping the mass balance can generate very large data sets!!
</p>



<h5>Returns</h5>

<p>invisible(self) for chaining
</p>


<hr>
<a id="method-dynatop-get_channel_inflow"></a>



<h4>Method <code>get_channel_inflow()</code></h4>

<p>Return channel inflow as an xts series or list of xts series
</p>


<h5>Usage</h5>

<div class="r"><pre>dynatop$get_channel_inflow(total = FALSE, separate = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>total</code></dt><dd><p>logical if plot total inflow is to be plotted</p>
</dd>
<dt><code>separate</code></dt><dd><p>logical if the surface and saturated zone inflows should be returned separately</p>
</dd>
</dl>

</div>


<hr>
<a id="method-dynatop-plot_channel_inflow"></a>



<h4>Method <code>plot_channel_inflow()</code></h4>

<p>Plot the channel inflow
</p>


<h5>Usage</h5>

<div class="r"><pre>dynatop$plot_channel_inflow(total = FALSE, separate = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>total</code></dt><dd><p>logical if total inflow is to be plotted</p>
</dd>
<dt><code>separate</code></dt><dd><p>logical logical if the surface and saturated zone inflows should be plotted separately</p>
</dd>
</dl>

</div>


<hr>
<a id="method-dynatop-get_gauge_flow"></a>



<h4>Method <code>get_gauge_flow()</code></h4>

<p>Return flow at the gauges as an xts series
</p>


<h5>Usage</h5>

<div class="r"><pre>dynatop$get_gauge_flow(gauge = colnames(private$time_series$gauge_flow))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>gauge</code></dt><dd><p>names of gauges to return (default is all gauges)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-dynatop-plot_gauge_flow"></a>



<h4>Method <code>plot_gauge_flow()</code></h4>

<p>Get the flow at gauges
</p>


<h5>Usage</h5>

<div class="r"><pre>dynatop$plot_gauge_flow(gauge = colnames(private$time_series$gauge_flow))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>gauge</code></dt><dd><p>names of gauges to return (default is all gauges)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-dynatop-get_obs_data"></a>



<h4>Method <code>get_obs_data()</code></h4>

<p>Get the observed data
</p>


<h5>Usage</h5>

<div class="r"><pre>dynatop$get_obs_data()</pre></div>


<hr>
<a id="method-dynatop-get_model"></a>



<h4>Method <code>get_model()</code></h4>

<p>Return the model
</p>


<h5>Usage</h5>

<div class="r"><pre>dynatop$get_model()</pre></div>


<hr>
<a id="method-dynatop-get_mass_errors"></a>



<h4>Method <code>get_mass_errors()</code></h4>

<p>Return the model
</p>


<h5>Usage</h5>

<div class="r"><pre>dynatop$get_mass_errors()</pre></div>


<hr>
<a id="method-dynatop-get_states"></a>



<h4>Method <code>get_states()</code></h4>

<p>Return states
</p>


<h5>Usage</h5>

<div class="r"><pre>dynatop$get_states(record = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>record</code></dt><dd><p>logical TRUE if the record should be returned. Otherwise the current states returned</p>
</dd>
</dl>

</div>


<hr>
<a id="method-dynatop-plot_state"></a>



<h4>Method <code>plot_state()</code></h4>

<p>Plot a current state of the system
</p>


<h5>Usage</h5>

<div class="r"><pre>dynatop$plot_state(state, add_channel = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>state</code></dt><dd><p>the name of the state to be plotted</p>
</dd>
<dt><code>add_channel</code></dt><dd><p>Logical indicating if the channel should be added to the plot</p>
</dd>
</dl>

</div>


<hr>
<a id="method-dynatop-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>dynatop$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## the vignettes contains further details of the method calls.

data("Swindale") ## example data
ctch_mdl &lt;- dynatop$new(Swindale$model) ## create with model
ctch_mdl$add_data(Swindale$obs) ## add observations
ctch_mdl$initialise() ## initialise model
ctch_mdl$sim() ## simulate model
</code></pre>

<hr>
<h2 id='evap_est'>Create sinusoidal time series of potential evapotranspiration input</h2><span id='topic+evap_est'></span>

<h3>Description</h3>

<p>Generate series of potential evapotranspiration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evap_est(ts, eMin = 0, eMax = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evap_est_+3A_ts">ts</code></td>
<td>
<p>as vector of POSIXct data/times</p>
</td></tr>
<tr><td><code id="evap_est_+3A_emin">eMin</code></td>
<td>
<p>Minimum daily PE total (m or mm)</p>
</td></tr>
<tr><td><code id="evap_est_+3A_emax">eMax</code></td>
<td>
<p>Maximum daily PE total (m or mm)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dynamic TOPMODEL requires a time series of potential
evapotranspiration in order to calculate and remove actual
evapotranspiration from the root zone during a run. Many sophisticated
physical models have been developed for estimating potential and actual evapotranspiration, including the
Priestly-Taylor (Priestley and Taylor, 1972) and Penman-Monteith (Montieth,
1965) methods. These, however, require detailed meteorological data such as
radiation input and relative humidities that are, in general, difficult to
obtain. Calder (1983) demonstrated that a simple approximation using a
sinusoidal variation in potential evapotranspiration to be a good
approximation to more complex schemes.
</p>
<p>If the insolation is also taken to vary sinusoidally through the daylight
hours then, ignoring diurnal meteorological variations, the potential
evapotranspiration during daylight hours for each year day number can be
calculated (for the catchment's latitude). Integration over the daylight
hours allows the daily maximum to be calculated and thus a sub-daily series
generated.
</p>


<h3>Value</h3>

<p>Time series (xts) of potential evapotranspiration totals for the time steps given in same units as eMin and eMax
</p>


<h3>References</h3>

<p>Beven, K. J. (2012). Rainfall-runoff modelling : the primer. Chichester, UK, Wiley-Blackwell.
</p>
<p>Calder, I. R. (1986). A stochastic model of rainfall interception. Journal of Hydrology, 89(1), 65-71.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generating daily PET data for 1970
## the values of eMin and eMax may not by not be realistic
st &lt;- as.POSIXct("1970-01-02 00:00:00",tz='GMT')
fn &lt;- as.POSIXct("1971-01-01 00:00:00",tz='GMT')
daily_ts &lt;- seq(st,fn,by=24*60*60)
dpet &lt;- evap_est(daily_ts,0,1)

## create hourly data for the same period
st &lt;- as.POSIXct("1970-01-01 01:00:00",tz='GMT')
fn &lt;- as.POSIXct("1971-01-01 00:00:00",tz='GMT')
hour_ts &lt;- seq(st,fn,by=1*60*60)
hpet &lt;- evap_est(hour_ts,0,1)

## the totals should eb the same...
stopifnot(all.equal(sum(hpet), sum(dpet)))
</code></pre>

<hr>
<h2 id='resample_xts'>Functions to resample an xts time series</h2><span id='topic+resample_xts'></span>

<h3>Description</h3>

<p>Takes an xts time series object and resamples then to a new time step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_xts(obs, dt, is.rate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resample_xts_+3A_obs">obs</code></td>
<td>
<p>A times series (xts) object with a POSIXct index.</p>
</td></tr>
<tr><td><code id="resample_xts_+3A_dt">dt</code></td>
<td>
<p>New time interval in seconds</p>
</td></tr>
<tr><td><code id="resample_xts_+3A_is.rate">is.rate</code></td>
<td>
<p>If TRUE then these are rates i.e m/h. Otherwise they are absolute values accumulated within the preceding time interval. Values are scaled before returning so resampling is conservative.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Time series of observation data are often of different temporal resolutions, however the input to most hydrological models, as is the case with the Dynamic TOPMODEL, requires those data at the same interval. This provides a method to resample a collection of such data to a single interval.
</p>
<p>Because of the methods used the results:
</p>
<p>- are not accurate when the input data does not have a constant timestep. The code issues a warning and proceeds assuming the data are equally spaced with the modal timestep.
- do not guarantee the requested time step but returns a series with the timestep computed from an integer rounding the ratio of the current and requested time step.
</p>


<h3>Value</h3>

<p>An xts object with the new timestep
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Resample Swindale Rainfall to hourly intervals
require(dynatop)
data("Swindale")
obs &lt;- Swindale$obs
cobs &lt;- resample_xts(obs, dt=60*60) # hourly data
dobs &lt;- resample_xts(cobs,dt=15*60) # back to 15 minute data
cdobs &lt;- resample_xts(dobs,dt=60*60) # back to hourly data - checks time stamp conversion
obs &lt;- obs[zoo::index(obs)&lt;=max(zoo::index(cobs)),]

# check totals
stopifnot( all.equal(sum(obs),sum(cobs)) )
stopifnot( all.equal(sum(obs),sum(dobs)) )
stopifnot( all.equal(cobs,cdobs) )
</code></pre>

<hr>
<h2 id='Swindale'>Example dynamic TOPMODEL setup</h2><span id='topic+Swindale'></span>

<h3>Description</h3>

<p>This data set contains a processed model and observation data for Swindale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Swindale)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dynatop">dynatop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(dynatop)
data(Swindale)

# Show it
# plot(obs)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
